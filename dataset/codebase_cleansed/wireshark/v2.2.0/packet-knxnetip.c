static void dissect_hpai(tvbuff_t *tvb, guint32 *offset, proto_tree *insert_tree, const char *append_text) {\r\nproto_item *hpai_item = NULL;\r\nproto_item *slength = NULL;\r\nproto_tree *hpai_tree = NULL;\r\nhpai_item = proto_tree_add_item( insert_tree, hf_knxnetip_hpai, tvb, *offset, 8, ENC_NA );\r\nhpai_tree = proto_item_add_subtree(hpai_item, ett_knxnetip_hpai);\r\nproto_item_append_text(hpai_item, "%s", append_text);\r\nslength= proto_tree_add_item(hpai_tree, hf_knxnetip_hpai_structure_length, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(slength, " octets");\r\n*offset+=1;\r\nproto_tree_add_item(hpai_tree, hf_knxnetip_hpai_host_protocol, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(hpai_tree, hf_knxnetip_hpai_ip_address, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nproto_tree_add_item(hpai_tree, hf_knxnetip_hpai_port, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\n}\r\nstatic gboolean dissect_dib(tvbuff_t *tvb, guint32 *offset, proto_tree *insert_tree) {\r\nproto_item *dib_item = NULL;\r\nproto_item *struct_length = NULL;\r\nproto_item *projectid_item = NULL;\r\nproto_item *service_item = NULL;\r\nproto_tree *dib_tree = NULL;\r\nproto_tree *projectid_tree = NULL;\r\nproto_tree *service_tree = NULL;\r\nguint8 i;\r\nguint8 dib_type;\r\nguint8 length;\r\nguint16 knx_address;\r\nguint16 install_id;\r\nlength = tvb_get_guint8(tvb, *offset);\r\ndib_item = proto_tree_add_item(insert_tree, hf_knxnetip_dib, tvb, *offset, length, ENC_NA);\r\ndib_tree = proto_item_add_subtree(dib_item, ett_knxnetip_dib);\r\nstruct_length= proto_tree_add_item(dib_tree, hf_knxnetip_structure_length, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(struct_length, " octets");\r\n*offset+=1;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_type, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\ndib_type = tvb_get_guint8(tvb, *offset);\r\nproto_item_append_text(dib_item, ": %s", val_to_str_const(dib_type, knxnetip_dib_description_type_codes, "Unknown Type"));\r\n*offset+=1;\r\nswitch (dib_type){\r\ncase(DIB_DEVICE_INFO):\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_medium, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_bitmask(dib_tree, tvb, *offset, hf_knxnetip_dib_status, ett_knxnetip_dib_status, dib_device_status_flags, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nknx_address = tvb_get_ntohs(tvb, *offset);\r\nproto_tree_add_uint_format(dib_tree, hf_knxnetip_knxaddress, tvb, *offset, 2, knx_address, "KNX Address %d.%d.%d", ((knx_address & 0xF000)>>12),((knx_address & 0x0F00)>>8),(knx_address & 0xFF));\r\n*offset+=2;\r\nprojectid_item = proto_tree_add_item(dib_tree, hf_knxnetip_dib_projectid, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\nprojectid_tree = proto_item_add_subtree(projectid_item, ett_knxnetip_dib_projectid);\r\ninstall_id = tvb_get_ntohs(tvb, *offset);\r\nproto_tree_add_uint_format(projectid_tree, hf_knxnetip_projectnumber, tvb, *offset, 2, install_id, "Project number %d", (install_id & 0xFFF0)>>4);\r\nproto_tree_add_uint_format(projectid_tree, hf_knxnetip_installnumber, tvb, *offset, 2, install_id, "Installation number %d", (install_id & 0xF));\r\n*offset+=2;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_serialnumber, tvb, *offset, 6, ENC_NA);\r\n*offset+=6;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_multicast_address, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_mac_address, tvb, *offset, 6, ENC_NA);\r\n*offset+=6;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_friendly, tvb, *offset, 30, ENC_ASCII|ENC_NA );\r\n*offset+=30;\r\nbreak;\r\ncase(DIB_SUPP_SVC):\r\nif (length > 4) {\r\nlength-=4;\r\n} else {\r\nreturn TRUE;\r\n}\r\nfor (i = 0; i <= length; i+=2) {\r\nservice_item = proto_tree_add_item(dib_tree, hf_knxnetip_dib_service, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nservice_tree = proto_item_add_subtree(service_item, ett_knxnetip_dib_service);\r\n*offset+=1;\r\nproto_tree_add_item(service_tree, hf_knxnetip_dib_svc_version, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\n}\r\nbreak;\r\ncase(DIB_IP_CONF):\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_ipaddress, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_subnet, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_gateway, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nproto_tree_add_bitmask(dib_tree, tvb, *offset, hf_knxnetip_dib_ipcapa, ett_knxnetip_dib_ipcapa, dib_ipcapabilities_flags, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_ipassign, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nbreak;\r\ncase(DIB_IP_CURRENT):\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_ipaddress, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_subnet, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_gateway, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_dhcp, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_ipassign, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_reserved, tvb, *offset, 1, ENC_NA);\r\n*offset+=1;\r\nbreak;\r\ncase(DIB_KNX_ADDRESS):\r\nif (length > 4) {\r\nlength-=4;\r\n} else {\r\nreturn TRUE;\r\n}\r\nfor (i = 0; i <= length; i+=2) {\r\nknx_address = tvb_get_ntohs(tvb, *offset);\r\nproto_tree_add_uint_format(dib_tree, hf_knxnetip_knxaddress, tvb, *offset, 2, knx_address, "KNX Address %d.%d.%d", ((knx_address & 0xF000)>>12),((knx_address & 0x0F00)>>8),(knx_address & 0xFF));\r\n*offset+=2;\r\n}\r\nbreak;\r\ncase(DIB_MFR_DATA):\r\nif (length > 4) {\r\nlength-=4;\r\n} else {\r\nreturn TRUE;\r\n}\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_manuid, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nproto_tree_add_item(dib_tree, hf_knxnetip_dib_manudata, tvb, *offset, length, ENC_ASCII|ENC_NA);\r\n*offset+=length;\r\nbreak;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic guint dissect_cri(tvbuff_t *tvb, guint32 offset, proto_tree *insert_tree) {\r\nproto_item *cri_item = NULL;\r\nproto_item *cri_length = NULL;\r\nproto_tree *cri_tree = NULL;\r\nguint8 length;\r\nlength = tvb_get_guint8(tvb ,offset);\r\ncri_item = proto_tree_add_item(insert_tree, hf_knxnetip_cri, tvb, offset, length, ENC_NA);\r\ncri_tree = proto_item_add_subtree(cri_item, ett_knxnetip_cri);\r\ncri_length= proto_tree_add_item(cri_tree, hf_knxnetip_structure_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(cri_length, " octets");\r\noffset+=1;\r\nproto_tree_add_item(cri_tree, hf_knxnetip_connection_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nif (tvb_get_guint8(tvb,offset-1)== KNX_TUNNEL_CONNECTION ){\r\nproto_tree_add_item(cri_tree, hf_knxnetip_knxlayer, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nproto_tree_add_item(cri_tree, hf_knxnetip_reserved, tvb, offset, 1, ENC_NA);\r\noffset+=1;\r\n}\r\nelse if (length > 2) {\r\nproto_tree_add_item(cri_tree, hf_knxnetip_cri_protocol_data, tvb, offset, (length-2), ENC_NA);\r\noffset+=(length-2);\r\n}\r\nreturn offset;\r\n}\r\nstatic void dissect_crd(tvbuff_t *tvb, guint32 *offset, proto_tree *insert_tree) {\r\nproto_item *crd_item = NULL;\r\nproto_item *crd_length = NULL;\r\nproto_tree *crd_tree = NULL;\r\nguint8 length;\r\nguint16 knx_address;\r\nlength = tvb_get_guint8(tvb, *offset);\r\ncrd_item = proto_tree_add_item(insert_tree, hf_knxnetip_crd, tvb, *offset, length, ENC_NA);\r\ncrd_tree = proto_item_add_subtree(crd_item, ett_knxnetip_crd);\r\ncrd_length= proto_tree_add_item(crd_tree, hf_knxnetip_structure_length, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(crd_length, " octets");\r\n*offset+=1;\r\nproto_tree_add_item(crd_tree, hf_knxnetip_connection_type, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nif (tvb_get_guint8(tvb, *offset-1) == KNX_TUNNEL_CONNECTION){\r\nknx_address = tvb_get_ntohs(tvb, *offset);\r\nproto_tree_add_uint_format(crd_tree, hf_knxnetip_knxaddress, tvb, *offset, 2, knx_address, "KNX Address %d.%d.%d", ((knx_address & 0xF000)>>12),((knx_address & 0x0F00)>>8),(knx_address & 0xFF));\r\n*offset+=2;\r\n}\r\nelse if (length > 2) {\r\nproto_tree_add_item(crd_tree, hf_knxnetip_crd_protocol_data, tvb, *offset, (length-2), ENC_NA);\r\n*offset+=(length-2);\r\n}\r\n}\r\nstatic guint dissect_connection_header(tvbuff_t *tvb, guint32 offset, proto_tree *insert_tree, gboolean have_status) {\r\nproto_item *struct_length = NULL;\r\nstruct_length= proto_tree_add_item(insert_tree, hf_knxnetip_structure_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(struct_length, " octets");\r\noffset+=1;\r\nproto_tree_add_item(insert_tree, hf_knxnetip_communication_channel_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nproto_tree_add_item(insert_tree, hf_knxnetip_counter, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nif (have_status == FALSE){\r\nproto_tree_add_item(insert_tree, hf_knxnetip_reserved, tvb, offset, 1, ENC_NA);\r\noffset+=1;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint dissect_selector(tvbuff_t *tvb, guint32 offset, proto_tree *insert_tree){\r\nproto_item *struct_length = NULL;\r\nstruct_length= proto_tree_add_item(insert_tree, hf_knxnetip_structure_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(struct_length, " octets");\r\noffset+=1;\r\nproto_tree_add_item(insert_tree, hf_knxnetip_selector_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nif (tvb_get_guint8(tvb, offset-1)==0x02){\r\nproto_tree_add_item(insert_tree, hf_knxnetip_mac_address, tvb, offset, 6, ENC_NA);\r\noffset+=6;\r\n}\r\nreturn offset;\r\n}\r\nstatic void dissect_apci(tvbuff_t *tvb, guint32 *offset, proto_tree *insert_tree, gboolean tpdu){\r\nguint16 type;\r\nguint16 sub_type;\r\nguint8 length;\r\nlength = tvb_get_guint8(tvb, *offset-1);\r\nif (tpdu == TRUE){\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_reserved, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_tpci, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\ntype = (tvb_get_guint8(tvb, *offset)&0xC0);\r\nif (type == 0x40 || type == 0xC0){\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_counter, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nif (length != 0) {\r\ntype = (tvb_get_ntohs(tvb, *offset) & 0x03C0);\r\nswitch (type){\r\ncase(A_ADC_RED):\r\ncase(A_ADC_RES):\r\ntype = (tvb_get_ntohs(tvb, *offset) & 0x2FF);\r\nif (type == A_SYS_RED || type == A_SYS_RES || type == A_SYS_WRT || type == A_SYS_BROAD){\r\nproto_tree_add_bits_item(insert_tree, hf_knxnetip_cemi_apci, tvb, (*offset*8)+6, 10, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_bits_item(insert_tree, hf_knxnetip_cemi_apci, tvb, (*offset*8)+6, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(insert_tree, hf_knxnetip_cemi_channel, tvb, (*offset*8)+10, 6, ENC_BIG_ENDIAN);\r\n}\r\n*offset+=2;\r\nbreak;\r\ncase(A_GROUPVALUE_RES):\r\ncase(A_GROUPVALUE_WRT):\r\nproto_tree_add_bits_item(insert_tree, hf_knxnetip_cemi_apci, tvb, (*offset*8)+6, 4, ENC_BIG_ENDIAN);\r\nif (length == 1){\r\nproto_tree_add_bits_item(insert_tree, hf_knxnetip_cemi_data, tvb, (*offset*8)+10, 6, ENC_BIG_ENDIAN);\r\n}\r\n*offset+=2;\r\nbreak;\r\ncase(A_MEM_RED):\r\ncase(A_MEM_RES):\r\ncase(A_MEM_WRT):\r\nproto_tree_add_bits_item(insert_tree, hf_knxnetip_cemi_apci, tvb, (*offset*8)+6, 6, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(insert_tree, hf_knxnetip_cemi_apci_memory_number, tvb, (*offset*8)+12, 4, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_apci_mem_address, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nbreak;\r\ncase(COUPLER_SPECIFIC_SERVICE):\r\nsub_type = (tvb_get_ntohs(tvb, *offset) & 0x3FF);\r\nproto_tree_add_bits_item(insert_tree, hf_knxnetip_cemi_apci, tvb, (*offset*8)+6, 10, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nswitch(sub_type){\r\ncase(A_AUTHORIZE_REQ):\r\ncase(A_KEY_WRT):\r\nproto_tree_add_item(insert_tree, hf_knxnetip_reserved, tvb, *offset, 1, ENC_NA);\r\n*offset+=1;\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_apci_key, tvb, *offset, 4, ENC_NA);\r\n*offset+=4;\r\nbreak;\r\ncase(A_AUTHORIZE_RES):\r\ncase(A_KEY_RES):\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_apci_level, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nbreak;\r\ncase(A_PROPVALUE_RED):\r\ncase(A_PROPVALUE_RES):\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_apci_object, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_apci_propid, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_noe, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(insert_tree, hf_knxnetip_cemi_six, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_bits_item(insert_tree, hf_knxnetip_cemi_apci, tvb, (*offset*8)+6, 10, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\n}\r\nif (length >= 1){\r\nlength-=1;\r\n}\r\nif (length >= 1 && (tvb_reported_length_remaining(tvb, *offset) > 0)){\r\nproto_tree_add_item(insert_tree, hf_knxnetip_data, tvb, *offset, -1, ENC_NA);\r\n*offset+=length;\r\n}\r\n}\r\nelse {\r\n*offset+=1;\r\n}\r\n}\r\nstatic gboolean dissect_cemi(tvbuff_t *tvb, guint32 *offset, proto_tree *insert_tree, packet_info *pinfo){\r\nproto_item *cemi_item = NULL;\r\nproto_item *additional_info_totallength = NULL;\r\nproto_item *additional_item = NULL;\r\nproto_item *additional_info = NULL;\r\nproto_item *tpdu_length = NULL;\r\nproto_item *npdu_length = NULL;\r\nproto_tree *cemi_tree = NULL;\r\nproto_tree *additional_tree = NULL;\r\nproto_tree *additional_subtree = NULL;\r\nguint8 i;\r\nguint8 messagecode;\r\nguint8 length;\r\nguint8 type_id;\r\nguint8 noe;\r\nguint8 num_of_octets;\r\nguint16 knx_address;\r\nguint16 six;\r\ncemi_item = proto_tree_add_item(insert_tree, hf_knxnetip_cemi, tvb, *offset, -1, ENC_NA);\r\ncemi_tree = proto_item_add_subtree(cemi_item, ett_knxnetip_cemi);\r\nmessagecode = tvb_get_guint8(tvb, *offset);\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_mc, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "| cEMI: %s", val_to_str(messagecode, cemi_messagecodes, "Unknown MC:0x%0x"));\r\n*offset+=1;\r\nif ((messagecode & 0xF0) < 0xF0){\r\nlength = tvb_get_guint8(tvb, *offset);\r\nadditional_info_totallength= proto_tree_add_item(cemi_tree, hf_knxnetip_cemi_addlength, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(additional_info_totallength, " octets");\r\n*offset+=1;\r\nif (length != 0){\r\nadditional_info = proto_tree_add_item(cemi_tree, hf_knxnetip_additional, tvb, *offset, length, ENC_NA);\r\nadditional_tree = proto_item_add_subtree(additional_info, ett_knxnetip_cemi_additional);\r\ndo {\r\ntype_id = tvb_get_guint8(tvb, *offset);\r\nadditional_item = proto_tree_add_item(additional_tree, hf_knxnetip_cemi_typid, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nadditional_subtree = proto_item_add_subtree(additional_item, ett_knxnetip_cemi_additional_item);\r\n*offset+=1;\r\nadditional_info_totallength= proto_tree_add_item(additional_item, hf_knxnetip_cemi_additemlength, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(additional_info_totallength, " octets");\r\n*offset+=1;\r\nif (length >= 2){\r\nlength-=2;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nswitch(type_id){\r\ncase(PL_INFO):\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_pl, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nif (length >= 2){\r\nlength-=2;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase(RF_INFO):\r\nproto_tree_add_bitmask(additional_subtree, tvb, *offset, hf_knxnetip_cemi_type_rf_info, ett_knxnetip_cemi_rf_info, cemi_rf_info, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_rf_sn, tvb, *offset, 6, ENC_BIG_ENDIAN);\r\n*offset+=6;\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_rf_lfn, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nif (length >= 8){\r\nlength-=8;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase(BUSMON_INFO):\r\nproto_tree_add_bitmask(additional_subtree, tvb, *offset, hf_knxnetip_cemi_type_bus, ett_knxnetip_cemi_bus_info, cemi_bus_flags, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nif (length >= 1){\r\nlength-=1;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase(TIME_REL):\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_relt, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nif (length >= 2){\r\nlength-=2;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase(TIME_DELAY):\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_delay, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nif (length >= 4){\r\nlength-=4;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase(EXEND_TIME):\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_exttime, tvb, *offset, 4, ENC_BIG_ENDIAN);\r\n*offset+=4;\r\nif (length >= 4){\r\nlength-=4;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase(BIBAT_INFO):\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_bibat, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_bibat_block, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nif (length >= 2){\r\nlength-=2;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase(RF_MULTI):\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_rf_multi_freq, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_rf_multi_channel, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_rf_multi_fastack, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_rf_multi_recep_freq, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nif (length >= 4){\r\nlength-=4;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase(PREAMBEL):\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_preamble_length, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_type_postamble_length, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nif (length >= 3){\r\nlength-=3;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ncase(RF_FAST_ACK):\r\nnum_of_octets = tvb_get_guint8(tvb, *offset-1);\r\nfor(i=0; i<num_of_octets; i++) {\r\nproto_tree_add_bitmask(additional_subtree, tvb, *offset, hf_knxnetip_cemi_type_fastack, ett_knxnetip_cemi_fastack, cemi_fastack_flags, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nif (length >= 2){\r\nlength-=2;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\n}\r\nbreak;\r\ncase(MANU_DATA):\r\nnum_of_octets = tvb_get_guint8(tvb, *offset-1);\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_dib_manuid, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_subfunction, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_cemi_manuspecificdata, tvb, *offset, (num_of_octets-3), ENC_NA);\r\n*offset+=(num_of_octets-3);\r\nif (length >= num_of_octets){\r\nlength-=num_of_octets;\r\n}\r\nelse{\r\nreturn TRUE;\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(additional_subtree, hf_knxnetip_unknown, tvb, *offset, -1, ENC_NA);\r\nreturn *offset;\r\n}\r\n} while (length > 0);\r\n}\r\n}\r\nswitch (messagecode){\r\ncase(DATA_REQ):\r\ncase(DATA_CON):\r\ncase(DATA_IND):\r\ncase(POLL_DATA_REQ):\r\ncase(POLL_DATA_CON):\r\nproto_tree_add_bitmask(cemi_tree, tvb, *offset, hf_knxnetip_cemi_controlfield1, ett_knxnetip_cemi_control1, cemi_control1_flags, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_bitmask(cemi_tree, tvb, *offset, hf_knxnetip_cemi_controlfield2, ett_knxnetip_cemi_control2, cemi_control2_flags, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nknx_address = tvb_get_ntohs(tvb, *offset);\r\nproto_tree_add_uint_format(cemi_tree, hf_knxnetip_cemi_sourceaddress, tvb, *offset, 2, knx_address, "Source Address %d.%d.%d", ((knx_address & 0xF000)>>12),((knx_address & 0x0F00)>>8),(knx_address & 0xFF));\r\n*offset+=2;\r\nknx_address = tvb_get_ntohs(tvb, *offset);\r\nif ((tvb_get_guint8(tvb, *offset-3) & 0x80) == GROUPADD){\r\nproto_tree_add_uint_format(cemi_tree, hf_knxnetip_cemi_destaddress, tvb, *offset, 2, knx_address, "Destination Address %d/%d/%d or %d/%d", ((knx_address & 0x7800)>>11),((knx_address & 0x0700)>>8),(knx_address & 0xFF), ((knx_address & 0x7800)>>11),(knx_address & 0x7FF));\r\n}\r\nelse {\r\nproto_tree_add_uint_format(cemi_tree, hf_knxnetip_cemi_destaddress, tvb, *offset, 2, knx_address, "Destination Address %d.%d.%d", ((knx_address & 0xF000)>>12),((knx_address & 0x0F00)>>8),(knx_address & 0xFF));\r\n}\r\n*offset+=2;\r\nif (messagecode == POLL_DATA_REQ){\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_numberofslots, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\n}\r\nelse if (messagecode == POLL_DATA_CON){\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_numberofslots, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_polldata, tvb, *offset, -1, ENC_NA);\r\n}\r\nelse {\r\nnpdu_length = proto_tree_add_item(cemi_tree, hf_knxnetip_cemi_npdu_length, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(npdu_length, " octets");\r\n*offset+=1;\r\ndissect_apci(tvb, offset, cemi_tree, FALSE);\r\n}\r\nbreak;\r\ncase(RAW_REQ):\r\ncase(RAW_CON):\r\ncase(RAW_IND):\r\ncase(BUSMON_IND):\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_raw, tvb, *offset, -1, ENC_NA);\r\nbreak;\r\ncase(DATA_INDV_IND):\r\ncase(DATA_INDV_REQ):\r\ncase(DATA_CONNEC_IND):\r\ncase(DATA_CONNEC_REQ):\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_reserved, tvb, *offset, 6, ENC_NA);\r\n*offset+=6;\r\ntpdu_length = proto_tree_add_item(cemi_tree, hf_knxnetip_cemi_tpdu_length, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tpdu_length, " octets");\r\n*offset+=1;\r\ndissect_apci(tvb, offset, cemi_tree, TRUE);\r\nbreak;\r\ncase(PROPREAD_REQ):\r\ncase(PROPREAD_CON):\r\ncase(PROPWRITE_REQ):\r\ncase(PROPWRITE_CON):\r\ncase(PROPINFO_IND):\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_iot, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_oi, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_pid, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nnoe = ((tvb_get_guint8(tvb, *offset)& 0xF0)>>4);\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_noe, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\nsix = tvb_get_bits16(tvb, (*offset*8+4), 12, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_six, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nif (messagecode == PROPREAD_REQ || (messagecode == PROPREAD_CON && noe > 0)){\r\nbreak;\r\n}\r\nelse if (noe == 0){\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_error, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\n}\r\nelse if (noe == 1 && six == 0){\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_numberofelements, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\n}\r\nelse {\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_data, tvb, *offset, -1, ENC_NA);\r\n}\r\nbreak;\r\ncase(FUNCPROPCOM_REQ):\r\ncase(FUNCPROPSTATREAD_REQ):\r\ncase(FUNCPROPCOM_CON):\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_iot, tvb, *offset, 2, ENC_BIG_ENDIAN);\r\n*offset+=2;\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_oi, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_pid, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\nif (messagecode == FUNCPROPCOM_CON){\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_cemi_return, tvb, *offset, 1, ENC_BIG_ENDIAN);\r\n*offset+=1;\r\n}\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_data, tvb, *offset, -1, ENC_NA);\r\nbreak;\r\ncase(RESET_REQ):\r\ncase(RESET_IND):\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(cemi_tree, hf_knxnetip_data, tvb, *offset, -1, ENC_NA);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void dissect_knxnetip (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {\r\nproto_item *knx_item = NULL;\r\nproto_item *total_length = NULL;\r\nproto_item *struct_length = NULL;\r\nproto_item *busy_item = NULL;\r\nproto_tree *knx_tree = NULL;\r\nproto_tree *header_tree = NULL;\r\nproto_tree *body_tree = NULL;\r\nguint offset = 0;\r\nguint16 service_type = 0;\r\ngboolean err = FALSE;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "KNXnetIP");\r\ncol_clear(pinfo->cinfo,COL_INFO);\r\nknx_item = proto_tree_add_item(tree, proto_knxnetip, tvb, 0, -1, ENC_NA);\r\nknx_tree = proto_item_add_subtree(knx_item, ett_knxnetip);\r\nheader_tree = proto_tree_add_subtree(knx_tree, tvb, offset, 6, ett_knxnetip_header, NULL, "Header");\r\nproto_tree_add_item(header_tree, hf_knxnetip_headerlength, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nproto_tree_add_item(header_tree, hf_knxnetip_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nservice_type = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(header_tree, hf_knxnetip_servicetype, tvb, offset, 2, ENC_BIG_ENDIAN);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s %d > %d", val_to_str(service_type, knxnetip_service_identifier, "Unknown Identifier:0x%02x"), pinfo->srcport, pinfo->destport);\r\noffset+=2;\r\ntotal_length = proto_tree_add_item(header_tree, hf_knxnetip_totallength, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(total_length, " octets");\r\noffset+=2;\r\nbody_tree = proto_tree_add_subtree(knx_tree, tvb, offset, -1, ett_knxnetip_body, NULL, "Body");\r\nswitch(service_type) {\r\ncase(SEARCH_REQ):\r\ndissect_hpai(tvb, &offset, body_tree, ": Discovery endpoint");\r\nbreak;\r\ncase(SEARCH_RES):\r\ndissect_hpai(tvb, &offset, body_tree, ": Control endpoint");\r\nerr = dissect_dib(tvb, &offset, body_tree);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\nbreak;\r\n}\r\nerr = dissect_dib(tvb, &offset, body_tree);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\nbreak;\r\n}\r\nbreak;\r\ncase(DESCRIPTION_REQ):\r\ndissect_hpai(tvb, &offset, body_tree, ": Control endpoint");\r\nbreak;\r\ncase(DESCRIPTION_RES):\r\nerr = dissect_dib(tvb, &offset, body_tree);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\nbreak;\r\n}\r\nerr = dissect_dib(tvb, &offset, body_tree);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\nbreak;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) != 0){\r\nerr = dissect_dib(tvb, &offset, body_tree);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\n}\r\n}\r\nbreak;\r\ncase(CONNECT_REQ):\r\ndissect_hpai(tvb, &offset, body_tree, ": Discovery endpoint");\r\ndissect_hpai(tvb, &offset, body_tree, ": Data endpoint");\r\noffset = dissect_cri(tvb, offset, body_tree);\r\nbreak;\r\ncase(CONNECT_RES):\r\nproto_tree_add_item(body_tree, hf_knxnetip_communication_channel_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nproto_tree_add_item(body_tree, hf_knxnetip_connect_status, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\ndissect_hpai(tvb, &offset, body_tree, ": Data endpoint");\r\ndissect_crd(tvb, &offset, body_tree);\r\nbreak;\r\ncase(CONNECTIONSTATE_REQ):\r\ncase(DISCONNECT_REQ):\r\nproto_tree_add_item(body_tree, hf_knxnetip_communication_channel_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nproto_tree_add_item(body_tree, hf_knxnetip_reserved, tvb, offset, 1, ENC_NA);\r\noffset+=1;\r\ndissect_hpai(tvb, &offset, body_tree, ": Control endpoint");\r\nbreak;\r\ncase(DISCONNECT_RES):\r\ncase(CONNECTIONSTATE_RES):\r\nproto_tree_add_item(body_tree, hf_knxnetip_communication_channel_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nproto_tree_add_item(body_tree, hf_knxnetip_connectionstate_status, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nbreak;\r\ncase(DEVICE_CONFIGURATION_ACK):\r\noffset = dissect_connection_header(tvb, offset, body_tree, TRUE);\r\nproto_tree_add_item(body_tree, hf_knxnetip_confack_status, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nbreak;\r\ncase(DEVICE_CONFIGURATION_REQ):\r\ncase(TUNNELLING_REQ):\r\noffset = dissect_connection_header(tvb, offset, body_tree, FALSE);\r\nerr = dissect_cemi (tvb, &offset, body_tree, pinfo);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\n}\r\nbreak;\r\ncase(TUNNELLING_ACK):\r\noffset = dissect_connection_header(tvb, offset, body_tree, TRUE);\r\nproto_tree_add_item(body_tree, hf_knxnetip_tunnelack_status, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase(ROUTING_INDICATION):\r\nerr = dissect_cemi (tvb, &offset, body_tree, pinfo);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\n}\r\nbreak;\r\ncase(ROUTING_LOST):\r\nstruct_length= proto_tree_add_item(body_tree, hf_knxnetip_structure_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(struct_length, " octets");\r\noffset+=1;\r\nproto_tree_add_bitmask(body_tree, tvb, offset, hf_knxnetip_devicestate, ett_knxnetip_devicestate, devicestate_flags, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nproto_tree_add_item(body_tree, hf_knxnetip_numberoflost, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nbreak;\r\ncase(ROUTING_BUSY):\r\nstruct_length= proto_tree_add_item(body_tree, hf_knxnetip_structure_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(struct_length, " octets");\r\noffset+=1;\r\nproto_tree_add_bitmask(body_tree, tvb, offset, hf_knxnetip_devicestate, ett_knxnetip_devicestate, devicestate_flags, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nbusy_item = proto_tree_add_item(body_tree, hf_knxnetip_busywaittime, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(busy_item, " ms");\r\noffset+=2;\r\nproto_tree_add_item(body_tree, hf_knxnetip_busycontrol, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nbreak;\r\ncase(REMOTE_DIAG_REQ):\r\ndissect_hpai(tvb, &offset, body_tree, ": Discovery endpoint");\r\noffset = dissect_selector(tvb ,offset, body_tree);\r\nbreak;\r\ncase(REMOTE_DIAG_RES):\r\noffset = dissect_selector(tvb ,offset, body_tree);\r\ndo{\r\nerr = dissect_dib(tvb, &offset, body_tree);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\nbreak;\r\n}\r\n} while (tvb_reported_length_remaining(tvb,offset) > 0);\r\nbreak;\r\ncase(REMOTE_BASIC_CONF_REQ):\r\ndissect_hpai(tvb, &offset, body_tree, ": Discovery endpoint");\r\noffset = dissect_selector(tvb ,offset, body_tree);\r\nerr = dissect_dib(tvb, &offset, body_tree);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\nbreak;\r\n}\r\nif (tvb_reported_length_remaining(tvb,offset) > 0) {\r\nerr = dissect_dib(tvb, &offset, body_tree);\r\nif (err == TRUE){\r\nproto_tree_add_expert(body_tree, pinfo, &ei_knxnetip_length, tvb, offset, -1);\r\n}\r\n}\r\nbreak;\r\ncase(REMOTE_RESET_REQ):\r\noffset = dissect_selector(tvb ,offset, body_tree);\r\nproto_tree_add_item(body_tree, hf_knxnetip_reset, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset+=1;\r\nproto_tree_add_item(body_tree, hf_knxnetip_reserved, tvb, offset, 1, ENC_NA);\r\noffset+=1;\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(body_tree, hf_knxnetip_unknown, tvb, offset, -1, ENC_NA);\r\n}\r\n}\r\nstatic gboolean dissect_knxnetip_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_) {\r\ngint idx;\r\nidx = 0;\r\nif (tvb_captured_length(tvb) < 8){\r\nreturn (FALSE);\r\n}\r\nif ( tvb_get_guint8(tvb, 0) != KNXNETIP_HEADER_LENGTH) {\r\nreturn (FALSE);\r\n}\r\nif ( tvb_get_guint8(tvb, 1) != KNXNETIP_PROTOCOL_VERSION){\r\nreturn (FALSE);\r\n}\r\ntry_val_to_str_idx((guint32)tvb_get_ntohs(tvb, 2), knxnetip_service_identifier, &idx);\r\nif (idx == -1){\r\nreturn (FALSE);\r\n}\r\ndissect_knxnetip(tvb, pinfo, tree);\r\nreturn (TRUE);\r\n}\r\nvoid proto_register_knxnetip (void) {\r\nexpert_module_t* expert_knxnetip;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_knxnetip_headerlength,\r\n{ "Header Length", "knxnetip.header_length", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_version,\r\n{ "Protocol Version", "knxnetip.version", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_servicetype,\r\n{ "Service Type Identifier", "knxnetip.service_type_identifier", FT_UINT16, BASE_HEX, VALS(knxnetip_service_identifier), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_totallength,\r\n{ "Total Length", "knxnetip.total_length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_hpai,\r\n{ "HPAI", "knxnetip.hpai", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_hpai_structure_length,\r\n{ "Structure Length", "knxnetip.hpai_structure_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_structure_length,\r\n{ "Structure Length", "knxnetip.struct_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_hpai_host_protocol,\r\n{ "Host Protocol Code", "knxnetip.hpai_host_protocol", FT_UINT8, BASE_HEX, VALS(knxnetip_host_protocol_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_hpai_ip_address,\r\n{ "IP Address", "knxnetip.hpai_ip_address", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_hpai_port,\r\n{ "IP Port", "knxnetip.hpai_port", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib,\r\n{ "DIB", "knxnetip.dib", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cri,\r\n{ "Connection Request Information", "knxnetip.cri", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_type,\r\n{ "Description Type", "knxnetip.dib_type", FT_UINT8, BASE_HEX, VALS(knxnetip_dib_description_type_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_medium,\r\n{ "KNX medium", "knxnetip.dib_medium", FT_UINT8, BASE_HEX, VALS(knxnetip_dib_medium_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_status,\r\n{ "Device Status", "knxnetip.dib_status", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_projectid,\r\n{ "Project-Installation identifier", "knxnetip.dib_projectid", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_knxaddress,\r\n{ "KNX Individual Address", "knxnetip.knxaddress", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_serialnumber,\r\n{ "KNXnet/IP device serial number", "knxnetip.serialnumber", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_multicast_address,\r\n{ "KNXnet/IP device multicast address", "knxnetip.multicast", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_mac_address,\r\n{ "KNXnet/IP device MAC address", "knxnetip.macaddress", FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_friendly,\r\n{ "Device Friendly Name", "knxnetip.devicename", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_service,\r\n{ "Service ID", "knxnetip.dib_service", FT_UINT8, BASE_HEX, VALS(knxnetip_service_types), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_ipaddress,\r\n{ "IP Address", "knxnetip.dib_ipaddress", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_subnet,\r\n{ "Subnet Mask", "knxnetip.dib_subnet", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_gateway,\r\n{ "Default Gateway", "knxnetip.dib_gateway", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_ipcapa,\r\n{ "IP Capabilities", "knxnetip.dib_ipcapabilities", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_ipassign,\r\n{ "IP assignment method", "knxnetip.dib_assignment", FT_UINT8, BASE_HEX, VALS(knxnetip_ip_assignment_method), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_dhcp,\r\n{ "DHCP Server", "knxnetip.dib_dhcp", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_manuid,\r\n{ "Manufacturer ID", "knxnetip.manufacturer_id", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_manudata,\r\n{ "Manufacturer specific data", "knxnetip.manufacturer_data", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_connection_type,\r\n{ "Connection Type", "knxnetip.connection_type", FT_UINT8, BASE_HEX, VALS(knxnetip_connection_types), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cri_protocol_data,\r\n{ "Protocol Data", "knxnetip.cri_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_communication_channel_id,\r\n{ "Communication Channel ID", "knxnetip.communication_channel_id", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_connect_status,\r\n{ "Status", "knxnetip.connect_status", FT_UINT8, BASE_HEX, VALS(knxnetip_connect_response_status_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_crd_protocol_data,\r\n{ "Protocol Data", "knxnetip.crd_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_crd,\r\n{ "Connection Response Data Block", "knxnetip.crd", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_connectionstate_status,\r\n{ "Status", "knxnetip.connect_state_status", FT_UINT8, BASE_HEX, VALS(knxnetip_connectionstate_response_status_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_counter,\r\n{ "Sequence Counter", "knxnetip.sequence_counter", FT_UINT8, BASE_DEC, 0x0, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_confack_status,\r\n{ "Status", "knxnetip.confirm_ack_status", FT_UINT8, BASE_HEX, VALS(knxnetip_device_configuration_ack_status_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_tunnelack_status,\r\n{ "Status", "knxnetip.tunnel_status", FT_UINT8, BASE_HEX, VALS(knxnetip_tunneling_error_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_status_flag_reserved,\r\n{ "reserved", "knxnetip.dib_reserved", FT_UINT8, BASE_HEX, NULL, FLAGS_DEVICESTATUS_RESERVED, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_status_flag_program,\r\n{ "program mode", "knxnetip.dib_program_mode", FT_UINT8, BASE_DEC, NULL, FLAGS_DEVICESTATUS_PROGRAM, NULL , HFILL }},\r\n{ &hf_knxnetip_dib_ipcapa_flag_reserved,\r\n{ "reserved", "knxnetip.ip_capabilities_reserved", FT_UINT8, BASE_HEX, NULL, FLAGS_IPCAPABILITES_RESERVED, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_ipcapa_flag_bootip,\r\n{ "BootIP", "knxnetip.ip_capabilities_bootip", FT_UINT8, BASE_DEC, NULL, FLAGS_IPCAPABILITES_BOOTIP, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_ipcapa_flag_dhcp,\r\n{ "DHCP", "knxnetip.ip_capabilities_dhcp", FT_UINT8, BASE_DEC, NULL, FLAGS_IPCAPABILITES_DHCP, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_ipcapa_flag_autoip,\r\n{ "AutoIP", "knxnetip.ip_capabilities_autoip", FT_UINT8, BASE_DEC, NULL, FLAGS_IPCAPABILITES_AUTOIP, NULL, HFILL }},\r\n{ &hf_knxnetip_devicestate,\r\n{ "DeviceState", "knxnetip.devicestate", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_devicestate_reserved,\r\n{ "reserved", "knxnetip.devicestate_reserved", FT_UINT8, BASE_HEX, NULL, FLAGS_DEVICESTATE_RESERVED, NULL, HFILL }},\r\n{ &hf_knxnetip_devicestate_knx,\r\n{ "KNX Fault", "knxnetip.devicestate_knx", FT_UINT8, BASE_DEC, NULL, FLAGS_DEVICESTATE_KNX, "is set if KNX network cannot be accessed", HFILL }},\r\n{ &hf_knxnetip_devicestate_ip,\r\n{ "IP Fault", "knxnetip.devicestate_ip", FT_UINT8, BASE_DEC, NULL, FLAGS_DEVICESTATE_IP, "is set if IP network cannot be accessed", HFILL }},\r\n{ &hf_knxnetip_numberoflost,\r\n{ "NumberofLostMessages", "knxnetip.number_of_lost_msg", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_busywaittime,\r\n{ "Busy Wait Time", "knxnetip.busy_time", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_busycontrol,\r\n{ "Busy Control Field", "knxnetip.busy_control", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_knxlayer,\r\n{ "KNX Layer", "knxnetip.layer", FT_UINT8, BASE_HEX, VALS(knxnetip_knxlayer_values), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_selector_type,\r\n{ "Selector Type Code", "knxnetip.selector", FT_UINT8, BASE_HEX, VALS(knxnetip_selector_types), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_reset,\r\n{ "Reset Command", "knxnetip.reset", FT_UINT8, BASE_HEX, VALS(knxnetip_reset_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi,\r\n{ "cEMI", "knxnetip.cemi", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_mc,\r\n{ "messagecode", "knxnetip.cemi_messagecode", FT_UINT8, BASE_HEX, VALS(cemi_messagecodes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_addlength,\r\n{ "add information length", "knxnetip.additional_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_additemlength,\r\n{ "Length", "knxnetip.additional_item_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_typid,\r\n{ "Type id", "knxnetip.cemi_type_id", FT_UINT8, BASE_HEX, VALS(cemi_add_type_id), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_pl,\r\n{ "Domain-Address", "knxnetip.cemi_type_pl", FT_UINT16, BASE_HEX, 0x0, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_bus,\r\n{ "Busmonitor error flags", "knxnetip.cemi_type_bus", FT_UINT8, BASE_HEX, 0x0, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_relt,\r\n{ "relative timestamp", "knxnetip.cemi_type_reltime", FT_UINT16, BASE_HEX, 0x0, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_delay,\r\n{ "delay", "knxnetip.cemi_type_delay", FT_UINT32, BASE_HEX, 0x0, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_exttime,\r\n{ "extended timestamp", "knxnetip.cemi_type_exttime", FT_UINT32, BASE_HEX, 0x0, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_bibat,\r\n{ "BiBat", "knxnetip.cemi_type_bibat", FT_UINT8, BASE_HEX, VALS(cemi_bibat_ctrl), 0xF8, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_controlfield1,\r\n{ "Controlfield 1", "knxnetip.controlfield_one", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_flag_frametype,\r\n{ "Frametype", "knxnetip.controlfield_type", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_CONTROL1_FT, "0: extended frame; 1: standard frame", HFILL }},\r\n{ &hf_knxnetip_cemi_flag_repeat,\r\n{ "Repeat", "knxnetip.controlfield_repeat", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_CONTROL1_R, "0: repeat if error frame; 1: do not repeat", HFILL }},\r\n{ &hf_knxnetip_cemi_flag_sb,\r\n{ "System-Broadcast", "knxnetip.controlfield_broadcast", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_CONTROL1_SB, "0: system-broadcast; 1: broadcast", HFILL }},\r\n{ &hf_knxnetip_cemi_flag_priority,\r\n{ "Priority", "knxnetip.controlfield_priority", FT_UINT8, BASE_HEX, NULL, FLAGS_CEMI_CONTROL1_P, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_flag_ack,\r\n{ "Acknowledge-Request", "knxnetip.controlfield_ack", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_CONTROL1_A, "0: no request for ack; 1: request ack", HFILL }},\r\n{ &hf_knxnetip_cemi_flag_confirm,\r\n{ "Confirm-Flag", "knxnetip.controlfield_confirm", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_CONTROL1_C, "0: no error in frame; 1: error in frame", HFILL }},\r\n{ &hf_knxnetip_cemi_controlfield2,\r\n{ "Controlfield 2", "knxnetip.controlfield_two", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_flag_destaddress,\r\n{ "Destination address type", "knxnetip.controldestaddress", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_CONTROL2_AT, "0: individual; 1: group", HFILL }},\r\n{ &hf_knxnetip_flag_hop,\r\n{ "Hop count", "knxnetip.controlhop", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_CONTROL2_HC, NULL, HFILL }},\r\n{ &hf_knxnetip_flag_eff,\r\n{ "Extended Frame Format", "knxnetip.controleff", FT_UINT8, BASE_HEX, NULL, FLAGS_CEMI_CONTROL2_EFF, "0000b for standard frame", HFILL }},\r\n{ &hf_knxnetip_cemi_sourceaddress,\r\n{ "Source Address", "knxnetip.cemisource", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_destaddress,\r\n{ "Destination Address", "knxnetip.cemidestination", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_tpci,\r\n{ "TPCI", "knxnetip.cemitpci", FT_UINT8, BASE_HEX, VALS(cemi_tpci_vals), 0xC0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_npdu_length,\r\n{ "NPDU length", "knxnetip.npdulength", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_tpdu_length,\r\n{ "TPDU length", "knxnetip.tpdulength", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_counter,\r\n{ "sequence NCD/NDT", "knxnetip.npduseq", FT_UINT8, BASE_DEC, NULL, 0x3C, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_apci,\r\n{ "APCI", "knxnetip.npduapci", FT_UINT16, BASE_HEX, VALS(cemi_apci_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_data,\r\n{ "Data", "knxnetip.cemidata", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_numberofslots,\r\n{ "number of slots", "knxnetip.ceminumberofslots", FT_UINT8, BASE_DEC, NULL, 0xF, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_apci_memory_number,\r\n{ "number of octets to be read/write", "knxnetip.cemidata", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_iot,\r\n{ "Interface object type", "knxnetip.cemiiot", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_oi,\r\n{ "Object Instance", "knxnetip.cemioi", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_pid,\r\n{ "Property Identifier", "knxnetip.cemipid", FT_UINT8, BASE_DEC, VALS(cemi_propertyid), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_noe,\r\n{ "Number of Elements", "knxnetip.ceminoe", FT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_six,\r\n{ "Startindex", "knxnetip.cemipid", FT_UINT16, BASE_DEC, NULL, 0xFFF, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_numberofelements,\r\n{ "Number of Elements", "knxnetip.ceminumber", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_error,\r\n{ "Error Code", "knxnetip.cemierror", FT_UINT8, BASE_HEX, VALS(cemi_error_codes), 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_return,\r\n{ "retrun code", "knxnetip.cemireturn", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_reserved,\r\n{ "reserved", "knxnetip.cemireserved", FT_UINT8, BASE_HEX, NULL, 0xFC, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_info,\r\n{ "RF-Info", "knxnetip.cemirfinfo", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_mesure,\r\n{ "received signal strength", "knxnetip.cemirfmesure", FT_UINT8, BASE_HEX, NULL, FLAGS_CEMI_RF_MESURE, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_reserved,\r\n{ "reserved", "knxnetip.cemirfreserved", FT_UINT8, BASE_HEX, NULL, FLAGS_CEMI_RF_RESERVED, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_mesure_re,\r\n{ "retransmitter signal strrength", "knxnetip.cemirfmesurere", FT_UINT8, BASE_HEX, NULL, FLAGS_CEMI_RF_MESURE_RE, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_battery,\r\n{ "Battery state", "knxnetip.cemirfbattery", FT_UINT8, BASE_HEX, NULL, FLAGS_CEMI_RF_BATTERY, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_bidirekt,\r\n{ "is not bidirektional", "knxnetip.cemirfbattery", FT_UINT8, BASE_HEX, NULL, FLAGS_CEMI_RF_BIDIRETIONAL, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_rf_sn,\r\n{ "KNX Serial Number", "knxnetip.cemiknxsn", FT_UINT64, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_rf_lfn,\r\n{ "Data Link Layer frame number", "knxnetip.cemilfn", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_bus_flag_f,\r\n{ "Frame error flag", "knxnetip.cemibusferror", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_BUS_F, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_bus_flag_b,\r\n{ "Bit error flag", "knxnetip.cemibusberror", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_BUS_B, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_bus_flag_p,\r\n{ "Parity error flag", "knxnetip.cemibusparity", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_BUS_P, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_bus_flag_d,\r\n{ "dont care", "knxnetip.cemibusdont", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_BUS_D, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_bus_flag_l,\r\n{ "Lost flag", "knxnetip.cemibuslost", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_BUS_L, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_bus_flag_sss,\r\n{ "Sequence Number", "knxnetip.cemibusseq", FT_UINT8, BASE_DEC, NULL, FLAGS_CEMI_BUS_SSS, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_bibat_block,\r\n{ "BiBat Block number", "knxnetip.cemibibbatblock", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_multi_fastack,\r\n{ "KNX RF Multi Fast Ack", "knxnetip.cemirffastack", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_multi_freq,\r\n{ "KNX RF Multi Transmission Frequency", "knxnetip.cemirffreq", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_multi_channel,\r\n{ "KNX RF Multi Call Channel", "knxnetip.cemirfchannel", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_rf_multi_recep_freq,\r\n{ "KNX RF Multi Reception Frequency", "knxnetip.cemirfrecfreq", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_preamble_length,\r\n{ "Preamble Length", "knxnetip.cemipreamblelength", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_postamble_length,\r\n{ "Postamble Length", "knxnetip.cemipostamblelength", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_fastack,\r\n{ "Fast Ack information", "knxnetip.cemifastack", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_fastack_crc,\r\n{ "Fast Ack is received with a CRC", "knxnetip.cemifastackcrc", FT_UINT16, BASE_DEC, NULL, FLAGS_CEMI_FASTACK_CRC, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_fastack_error,\r\n{ "Fast Ack is received with a Manchester error", "knxnetip.cemifastackerror", FT_UINT16, BASE_DEC, NULL, FLAGS_CEMI_FASTACK_ERROR, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_fastack_received,\r\n{ "Fast Ack has been received", "knxnetip.cemifastackres", FT_UINT16, BASE_DEC, NULL, FLAGS_CEMI_FASTACK_RES, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_type_fastack_info,\r\n{ "Fast Ack Info", "knxnetip.cemifastackinfo", FT_UINT16, BASE_HEX, NULL, FLAGS_CEMI_FASTACK_INFO, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_subfunction,\r\n{ "Subfunction", "knxnetip.cemisubfunction", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_manuspecificdata,\r\n{ "Manufacturer specific data", "knxnetip.cemimanuspecificdata", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_projectnumber,\r\n{ "Project number", "knxnetip.projectnumber", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_installnumber,\r\n{ "Installation number", "knxnetip.installnumber", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_dib_svc_version,\r\n{ "Version", "knxnetip.svcversion", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_reserved,\r\n{ "reserved", "knxnetip.reserved", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_data,\r\n{ "data", "knxnetip.data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_polldata,\r\n{ "Poll data", "knxnetip.polldata", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_raw,\r\n{ "RAW Frame", "knxnetip.raw", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_additional,\r\n{ "Additional information", "knxnetip.additional", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_unknown,\r\n{ "UNKNOWN", "knxnetip.unknown", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_apci_mem_address,\r\n{ "Memory Address", "knxnetip.cemimemaddress", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_channel,\r\n{ "Channel nr", "knxnetip.cemichannel", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_apci_key,\r\n{ "key", "knxnetip.apcikey", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_apci_level,\r\n{ "level", "knxnetip.apcilevel", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_apci_object,\r\n{ "object index", "knxnetip.apciobjidx", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_knxnetip_cemi_apci_propid,\r\n{ "property id", "knxnetip.apcipropid", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_knxnetip,\r\n&ett_knxnetip_header,\r\n&ett_knxnetip_body,\r\n&ett_knxnetip_hpai,\r\n&ett_knxnetip_dib,\r\n&ett_knxnetip_dib_projectid,\r\n&ett_knxnetip_dib_service,\r\n&ett_knxnetip_cri,\r\n&ett_knxnetip_crd,\r\n&ett_knxnetip_dib_status,\r\n&ett_knxnetip_dib_ipcapa,\r\n&ett_knxnetip_devicestate,\r\n&ett_knxnetip_cemi,\r\n&ett_knxnetip_cemi_additional,\r\n&ett_knxnetip_cemi_additional_item,\r\n&ett_knxnetip_cemi_control1,\r\n&ett_knxnetip_cemi_control2,\r\n&ett_knxnetip_cemi_rf_info,\r\n&ett_knxnetip_cemi_bus_info,\r\n&ett_knxnetip_cemi_fastack\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_knxnetip_length, { "knxnetip.invalid.length", PI_PROTOCOL, PI_ERROR, "invalid length", EXPFILL }},\r\n};\r\nproto_knxnetip = proto_register_protocol("KNXnet/IP", "knxnetip", "knx");\r\nproto_register_field_array(proto_knxnetip, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_knxnetip = expert_register_protocol(proto_knxnetip);\r\nexpert_register_field_array(expert_knxnetip, ei, array_length(ei));\r\n}\r\nvoid proto_reg_handoff_knxnetip(void) {\r\nheur_dissector_add("tcp", dissect_knxnetip_heur, "KNXnet/IP over TCP", "knxnetip_tcp", proto_knxnetip, HEURISTIC_ENABLE);\r\nheur_dissector_add("udp", dissect_knxnetip_heur, "KNXnet/IP over UDP", "knxnetip_udp", proto_knxnetip, HEURISTIC_ENABLE);\r\n}
