static int\r\ndissect_nstrace(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *ns_tree = NULL, *flagtree = NULL;\r\nproto_item *ti = NULL, *flagitem = NULL;\r\nstruct nstr_phdr *pnstr = &(pinfo->pseudo_header->nstr);\r\ntvbuff_t *next_tvb_eth_client;\r\nguint8 offset;\r\nwmem_strbuf_t *flags_strbuf = wmem_strbuf_new_label(wmem_packet_scope());\r\nguint8 flagoffset;\r\nguint8 src_vmname_len = 0, dst_vmname_len = 0;\r\nguint8 variable_ns_len = 0;\r\nwmem_strbuf_append(flags_strbuf, "None");\r\nif (pnstr->rec_type == NSPR_HEADER_VERSION205 || pnstr->rec_type == NSPR_HEADER_VERSION300 || pnstr->rec_type == NSPR_HEADER_VERSION206) {\r\nsrc_vmname_len = tvb_get_guint8(tvb,pnstr->src_vmname_len_offset);\r\ndst_vmname_len = tvb_get_guint8(tvb,pnstr->dst_vmname_len_offset);\r\nvariable_ns_len = src_vmname_len + dst_vmname_len;\r\npnstr->eth_offset += variable_ns_len;\r\n}\r\nti = proto_tree_add_protocol_format(tree, proto_nstrace, tvb, 0, pnstr->eth_offset, "NetScaler Packet Trace");\r\nns_tree = proto_item_add_subtree(ti, ett_ns);\r\nproto_tree_add_item(ns_tree, hf_ns_dir, tvb, pnstr->dir_offset, pnstr->dir_len, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_nicno, tvb, pnstr->nicno_offset, pnstr->nicno_len, ENC_LITTLE_ENDIAN);\r\nswitch (pnstr->rec_type)\r\n{\r\ncase NSPR_HEADER_VERSION300:\r\ncase NSPR_HEADER_VERSION206:\r\nflagoffset = pnstr->ns_activity_offset;\r\nflagitem = proto_tree_add_item(ns_tree, hf_ns_activity, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nflagtree = proto_item_add_subtree(flagitem, ett_ns_activity_flags);\r\nproto_tree_add_item(flagtree, hf_ns_activity_perf_collection, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flagtree, hf_ns_activity_pcb_zombie, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flagtree, hf_ns_activity_natpcb_zombie, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flagtree, hf_ns_activity_lbstats_sync, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flagtree, hf_ns_activity_stats_req, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_snd_cwnd, tvb, (flagoffset + 4), 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_realtime_rtt, tvb, (flagoffset + 8), 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_ts_recent, tvb, (flagoffset + 12), 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_http_abort_tracking_reason, tvb, (pnstr->dst_vmname_len_offset + 1), 1, ENC_LITTLE_ENDIAN);\r\ncase NSPR_HEADER_VERSION205:\r\nif(src_vmname_len){\r\nproto_tree_add_item(ns_tree,hf_ns_src_vm,tvb,pnstr->data_offset,src_vmname_len,ENC_ASCII|ENC_NA);\r\n}\r\nif(dst_vmname_len){\r\nproto_tree_add_item(ns_tree,hf_ns_dst_vm,tvb,pnstr->data_offset+src_vmname_len,dst_vmname_len,ENC_ASCII|ENC_NA);\r\n}\r\ncase NSPR_HEADER_VERSION204:\r\n{\r\nstatic const int * clflags[] = {\r\n&hf_ns_clflags_res,\r\n&hf_ns_clflags_rssh,\r\n&hf_ns_clflags_rss,\r\n&hf_ns_clflags_dfd,\r\n&hf_ns_clflags_fr,\r\n&hf_ns_clflags_fp,\r\nNULL\r\n};\r\nproto_tree_add_item(ns_tree, hf_ns_snode, tvb, pnstr->srcnodeid_offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_dnode, tvb, pnstr->destnodeid_offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(ns_tree, tvb, pnstr->clflags_offset, hf_ns_clflags, ett_ns_flags, clflags, ENC_NA);\r\n}\r\ncase NSPR_HEADER_VERSION203:\r\nproto_tree_add_item(ns_tree, hf_ns_coreid, tvb, pnstr->coreid_offset, 2, ENC_LITTLE_ENDIAN);\r\ncase NSPR_HEADER_VERSION202:\r\ncol_add_fstr(pinfo->cinfo, COL_8021Q_VLAN_ID, "%d", tvb_get_letohs(tvb, pnstr->vlantag_offset));\r\nproto_tree_add_item(ns_tree, hf_ns_vlantag, tvb, pnstr->vlantag_offset, 2, ENC_LITTLE_ENDIAN);\r\ncase NSPR_HEADER_VERSION201:\r\nproto_tree_add_item(ns_tree, hf_ns_pcbdevno, tvb, pnstr->pcb_offset, 4, ENC_LITTLE_ENDIAN);\r\nti = proto_tree_add_item(ns_tree, hf_ns_devno, tvb, pnstr->pcb_offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(ti);\r\nproto_tree_add_item(ns_tree, hf_ns_l_pcbdevno, tvb, pnstr->l_pcb_offset, 4, ENC_LITTLE_ENDIAN);\r\nti = proto_tree_add_item(ns_tree, hf_ns_devno, tvb, pnstr->l_pcb_offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(ti);\r\nbreak;\r\ncase NSPR_HEADER_VERSION350:\r\n{\r\nproto_tree *capflagtree = NULL;\r\nproto_item *capflagitem = NULL;\r\nflagoffset = pnstr->ns_activity_offset;\r\nflagitem = proto_tree_add_item(ns_tree, hf_ns_activity, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nflagtree = proto_item_add_subtree(flagitem, ett_ns_activity_flags);\r\nproto_tree_add_item(flagtree, hf_ns_activity_perf_collection, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flagtree, hf_ns_activity_pcb_zombie, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flagtree, hf_ns_activity_natpcb_zombie, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flagtree, hf_ns_activity_lbstats_sync, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(flagtree, hf_ns_activity_stats_req, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\ncapflagitem = proto_tree_add_item(ns_tree, hf_ns_capflags, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\ncapflagtree = proto_item_add_subtree(capflagitem, ett_ns_capflags);\r\nproto_tree_add_item(capflagtree, hf_ns_capflags_dbg, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(capflagtree, hf_ns_capflags_int, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(capflagtree, hf_ns_capflags_skipnwhdr, tvb, flagoffset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_errorcode, tvb, NSHDR_OFFSET_35(fp_errorcode), sizeof(guint8), ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_app, tvb, NSHDR_OFFSET_35(fp_app), sizeof(guint8), ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_coreid, tvb, pnstr->coreid_offset, 2, ENC_LITTLE_ENDIAN);\r\ncol_add_fstr(pinfo->cinfo, COL_8021Q_VLAN_ID, "%d", tvb_get_letohs(tvb, pnstr->vlantag_offset));\r\nproto_tree_add_item(ns_tree, hf_ns_vlantag, tvb, pnstr->vlantag_offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ns_tree, hf_ns_pcbdevno, tvb, pnstr->pcb_offset, 4, ENC_LITTLE_ENDIAN);\r\nti = proto_tree_add_item(ns_tree, hf_ns_devno, tvb, pnstr->pcb_offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(ti);\r\nproto_tree_add_item(ns_tree, hf_ns_l_pcbdevno, tvb, pnstr->l_pcb_offset, 4, ENC_LITTLE_ENDIAN);\r\nti = proto_tree_add_item(ns_tree, hf_ns_devno, tvb, pnstr->l_pcb_offset, 4, ENC_LITTLE_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(ti);\r\nadd35records(tvb, pinfo, tree, ns_tree);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif(pnstr->rec_type != NSPR_HEADER_VERSION350){\r\noffset = pnstr->eth_offset;\r\nnext_tvb_eth_client = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(eth_withoutfcs_handle, next_tvb_eth_client, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid add35records(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ns_tree)\r\n{\r\ntvbuff_t *next_tvb_eth_client;\r\nguint nsheaderlen=0;\r\nguint8 ssl_internal=0;\r\nguint offset;\r\nint morerecs=1;\r\nint loopcount=0;\r\nstatic const int * cluster_flags[] = {\r\n&hf_ns_clu_clflags_fp,\r\n&hf_ns_clu_clflags_fr,\r\n&hf_ns_clu_clflags_dfd,\r\n&hf_ns_clu_clflags_rss,\r\n&hf_ns_clu_clflags_rssh,\r\n&hf_ns_clu_clflags_res,\r\nNULL,\r\n};\r\nint cur_record=tvb_get_guint8(tvb,NSHDR_OFFSET_35(fp_nextrecord));\r\nnsheaderlen = tvb_get_letohs(tvb, NSHDR_OFFSET_35(fp_headerlen));\r\noffset = sizeof(nspr_pktracefull_v35_t);\r\ndo{\r\nswitch(cur_record){\r\ncase NSREC_ETHERNET:\r\nnext_tvb_eth_client = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(eth_withoutfcs_handle, next_tvb_eth_client, pinfo, tree);\r\nif(ssl_internal){\r\ncol_prepend_fence_fstr(pinfo->cinfo, COL_INFO, "[NS_INTERNAL_SSL]");\r\n}\r\nmorerecs=0;\r\nbreak;\r\ncase NSREC_HTTP:\r\n{\r\ntvbuff_t *next_tvb_http_client;\r\nmorerecs=0;\r\nnext_tvb_http_client = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(http_handle, next_tvb_http_client, pinfo, tree);\r\n}\r\nbreak;\r\ncase NSREC_TCPDEBUG:\r\n{\r\nproto_item *tcpdbgItem=NULL;\r\nproto_tree *tcpdbgTree=NULL;\r\nint reclen = tvb_get_letohs(tvb,offset+NSHDR_RECOFFSET_35(rec_len));\r\nint nextrec = tvb_get_guint8(tvb,offset+NSHDR_RECOFFSET_35(nextrec_type));\r\ntcpdbgItem = proto_tree_add_item(ns_tree, hf_ns_tcpdbg, tvb, offset, reclen, ENC_NA);\r\ntcpdbgTree = proto_item_add_subtree(tcpdbgItem, ett_ns_tcpdebug);\r\nproto_tree_add_item(tcpdbgTree, hf_ns_tcpdbg_cwnd, tvb, offset+TCPRECOFFSET(snd_cwnd), 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tcpdbgTree, hf_ns_tcpdbg_rtrtt, tvb, offset+TCPRECOFFSET(real_time_rtt), 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tcpdbgTree, hf_ns_tcpdbg_tsrecent, tvb, offset+TCPRECOFFSET(ts_recent), 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tcpdbgTree, hf_ns_tcpdbg_httpabort, tvb, offset+TCPRECOFFSET(http_abort_reason), 1, ENC_LITTLE_ENDIAN);\r\noffset += reclen;\r\ncur_record = nextrec;\r\n}\r\nbreak;\r\ncase NSREC_INFO:\r\n{\r\nproto_item *infoItem=NULL;\r\nproto_tree *infoTree=NULL;\r\nint reclen = tvb_get_letohs(tvb,offset+NSHDR_RECOFFSET_35(rec_len));\r\nint nextrec = tvb_get_guint8(tvb,offset+NSHDR_RECOFFSET_35(nextrec_type));\r\ninfoItem = proto_tree_add_item(ns_tree, hf_ns_inforec, tvb, offset, reclen, ENC_NA);\r\ninfoTree = proto_item_add_subtree(infoItem, ett_ns_inforec);\r\nproto_tree_add_item(infoTree, hf_ns_inforec_info, tvb, offset+(guint)sizeof(nspr_rec_info_t), reclen-3, ENC_ASCII|ENC_NA);\r\noffset += reclen;\r\ncur_record = nextrec;\r\n}\r\nbreak;\r\ncase NSREC_SSL:\r\n{\r\nproto_item *sslItem=NULL;\r\nproto_tree *sslTree=NULL;\r\nint reclen = tvb_get_letohs(tvb,offset+NSHDR_RECOFFSET_35(rec_len));\r\nint nextrec = tvb_get_guint8(tvb,offset+NSHDR_RECOFFSET_35(nextrec_type));\r\nsslItem = proto_tree_add_item(ns_tree, hf_ns_sslrec, tvb, offset, reclen, ENC_NA);\r\nsslTree = proto_item_add_subtree(sslItem, ett_ns_sslrec);\r\nproto_tree_add_item(sslTree, hf_ns_sslrec_seq, tvb, offset+SSLRECOFFSET(seq), 4, ENC_LITTLE_ENDIAN);\r\nssl_internal=1;\r\noffset += reclen;\r\ncur_record = nextrec;\r\n}\r\nbreak;\r\ncase NSREC_MPTCP:\r\n{\r\nproto_item *mptcpItem=NULL;\r\nproto_tree *mptcpTree=NULL;\r\nint reclen = tvb_get_letohs(tvb,offset+NSHDR_RECOFFSET_35(rec_len));\r\nint nextrec = tvb_get_guint8(tvb,offset+NSHDR_RECOFFSET_35(nextrec_type));\r\nmptcpItem = proto_tree_add_item(ns_tree, hf_ns_mptcprec, tvb, offset, reclen, ENC_NA);\r\nmptcpTree = proto_item_add_subtree(mptcpItem, ett_ns_mptcprec);\r\nproto_tree_add_item(mptcpTree, hf_ns_mptcprec_subflowid, tvb, offset+MPTCPRECOFFSET(subflowid), 1, ENC_LITTLE_ENDIAN);\r\noffset += reclen;\r\ncur_record = nextrec;\r\n}\r\nbreak;\r\ncase NSREC_VMNAMES:\r\n{\r\nproto_item *vmnameItem=NULL;\r\nproto_tree *vmnameTree=NULL;\r\ngint reclen = tvb_get_letohs(tvb,offset+NSHDR_RECOFFSET_35(rec_len));\r\ngint nextrec = tvb_get_guint8(tvb,offset+NSHDR_RECOFFSET_35(nextrec_type));\r\ngint srcvmnamelen = tvb_get_guint8(tvb,offset+VMNAMERECOFFSET(src_vmname_len));\r\ngint dstvmnamelen = tvb_get_guint8(tvb,offset+VMNAMERECOFFSET(dst_vmname_len));\r\nvmnameItem = proto_tree_add_item(ns_tree, hf_ns_vmnamerec, tvb, offset, reclen, ENC_NA);\r\nvmnameTree = proto_item_add_subtree(vmnameItem, ett_ns_vmnamerec);\r\nproto_tree_add_item(vmnameTree, hf_ns_vmnamerec_srcvmname, tvb, offset+(guint)sizeof(nspr_rec_vmname_t),\r\nsrcvmnamelen, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(vmnameTree, hf_ns_vmnamerec_dstvmname, tvb, offset+(guint)sizeof(nspr_rec_vmname_t)+srcvmnamelen,\r\ndstvmnamelen, ENC_ASCII|ENC_NA);\r\noffset += reclen;\r\ncur_record = nextrec;\r\n}\r\nbreak;\r\ncase NSREC_CLUSTER:\r\n{\r\nproto_item *clusterItem=NULL;\r\nproto_tree *clusterTree=NULL;\r\ngint reclen = tvb_get_letohs(tvb,offset+NSHDR_RECOFFSET_35(rec_len));\r\ngint nextrec = tvb_get_guint8(tvb,offset+NSHDR_RECOFFSET_35(nextrec_type));\r\nclusterItem = proto_tree_add_item(ns_tree, hf_ns_clusterrec, tvb, offset, reclen, ENC_NA);\r\nclusterTree = proto_item_add_subtree(clusterItem, ett_ns_clusterrec);\r\nproto_tree_add_item(clusterTree, hf_ns_clu_snode, tvb, offset+CLUSTERRECOFFSET(fp_srcNodeId), 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(clusterTree, hf_ns_clu_dnode, tvb, offset+CLUSTERRECOFFSET(fp_destNodeId), 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bitmask(clusterTree,tvb, offset+CLUSTERRECOFFSET(fp_clFlags),hf_ns_clu_clflags,ett_ns_flags,cluster_flags,ENC_NA);\r\noffset += reclen;\r\ncur_record = nextrec;\r\n}\r\nbreak;\r\ncase NSREC_NULL:\r\nmorerecs = 0;\r\nbreak;\r\ndefault:\r\n{\r\nproto_item *unknownItem=NULL;\r\nproto_tree *unknownTree=NULL;\r\nint reclen = tvb_get_letohs(tvb,offset+NSHDR_RECOFFSET_35(rec_len));\r\nint nextrec = tvb_get_guint8(tvb,offset+NSHDR_RECOFFSET_35(nextrec_type));\r\nloopcount++;\r\nunknownItem = proto_tree_add_item(ns_tree, hf_ns_unknownrec, tvb, offset, reclen, ENC_NA);\r\nunknownTree = proto_item_add_subtree(unknownItem, ett_ns_unknownrec);\r\nproto_tree_add_item(unknownTree, hf_ns_unknowndata, tvb, offset+3, reclen-3, ENC_NA);\r\nif(cur_record == UNKNOWN_LAST){\r\nmorerecs=0;\r\n}else{\r\noffset += reclen;\r\ncur_record = nextrec;\r\n}\r\n}\r\n}\r\n}while( morerecs &&\r\nloopcount < (MAX_UNKNOWNREC_LOOP) &&\r\noffset<=nsheaderlen);\r\n}\r\nvoid\r\nproto_register_ns(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ns_nicno,\r\n{ "Nic No", "nstrace.nicno",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_src_vm,\r\n{ "Src Vm Name", "nstrace.src_vm",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_dst_vm,\r\n{ "Dst Vm Name", "nstrace.dst_vm",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_coreid,\r\n{ "Core Id", "nstrace.coreid",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_dir,\r\n{ "Operation", "nstrace.dir",\r\nFT_UINT8, BASE_HEX, VALS(ns_dir_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_pcbdevno,\r\n{ "PcbDevNo", "nstrace.pdevno",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_l_pcbdevno,\r\n{ "Linked PcbDevNo", "nstrace.l_pdevno",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_devno,\r\n{ "DevNo", "nstrace.devno",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_vlantag,\r\n{ "Vlan", "nstrace.vlan",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_snode,\r\n{ "Source Node", "nstrace.snode",\r\nFT_INT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_dnode,\r\n{ "Destination Node", "nstrace.dnode",\r\nFT_INT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_clflags,\r\n{ "Cluster Flags", "nstrace.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_clflags_res,\r\n{ "Reserved", "nstrace.flags.res",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_RES,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clflags_rssh,\r\n{ "RSSHASH", "nstrace.flags.rssh",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_RSSH,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clflags_rss,\r\n{ "SRSS", "nstrace.flags.srss",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_RSS,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clflags_dfd,\r\n{ "DFD", "nstrace.flags.dfd",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_DFD,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clflags_fr,\r\n{ "Flow receiver (FR)", "nstrace.flags.fr",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_FR,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clflags_fp,\r\n{ "Flow processor (FP)", "nstrace.flags.fp",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_FP,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_activity,\r\n{ "Activity Flags", "nstrace.activity",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_activity_perf_collection,\r\n{ "Perf Collection", "nstrace.activity.perfcollection",\r\nFT_BOOLEAN, 32, NULL, NS_PE_STATE_PERF_COLLECTION_IN_PROG,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_activity_pcb_zombie,\r\n{ "PCB Zombie", "nstrace.activity.pcbzombie",\r\nFT_BOOLEAN, 32, NULL, NS_PE_STATE_PCB_ZOMBIE_IN_PROG,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_activity_natpcb_zombie,\r\n{ "NATPCB Zombie", "nstrace.activity.natpcbzombie",\r\nFT_BOOLEAN, 32, NULL, NS_PE_STATE_NATPCB_ZOMBIE_IN_PROG,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_activity_lbstats_sync,\r\n{ "LB Stats Sync", "nstrace.activity.lbstatssync",\r\nFT_BOOLEAN, 32, NULL, NS_PE_STATE_LBSTATS_SYNC_IN_PROG,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_activity_stats_req,\r\n{ "Stats Req", "nstrace.activity.statsreq",\r\nFT_BOOLEAN, 32, NULL, NS_PE_STATE_STATS_REQ_IN_PROG,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_snd_cwnd,\r\n{ "SendCwnd", "nstrace.sndcwnd",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_realtime_rtt,\r\n{ "RTT", "nstrace.rtt",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_ts_recent,\r\n{ "tsRecent", "nstrace.tsrecent",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_http_abort_tracking_reason,\r\n{ "httpAbortTrackCode", "nstrace.httpabort",\r\nFT_UINT8, BASE_DEC, VALS(ns_httpabortcode_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_capflags,\r\n{ "Capture Flags", "nstrace.capflags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_capflags_dbg,\r\n{ "debug packet", "nstrace.capflags.dbg",\r\nFT_BOOLEAN, 32, NULL, NS_CAPFLAG_DBG,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_capflags_int,\r\n{ "internal packet", "nstrace.capflags.int",\r\nFT_BOOLEAN, 32, NULL, NS_CAPFLAG_INT,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_capflags_skipnwhdr,\r\n{ "skip headers", "nstrace.capflags.skipnwhdr",\r\nFT_BOOLEAN, 32, NULL, NS_CAPFLAG_SKIPNWHDR,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_tcpdbg,\r\n{ "TCP Debug Info", "nstrace.tcpdbg",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_tcpdbg_cwnd,\r\n{ "TcpCwnd", "nstrace.tcpdbg.tcpcwnd",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_tcpdbg_rtrtt,\r\n{ "TcpRTT", "nstrace.tcpdbg.rtrtt",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_tcpdbg_tsrecent,\r\n{ "TcpTsrecent", "nstrace.tcpdbg.tcptsrecent",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_tcpdbg_httpabort,\r\n{ "HTTPabrtReason", "nstrace.tcpdbg.httpabort",\r\nFT_UINT8, BASE_DEC, VALS(ns_httpabortcode_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_unknownrec,\r\n{ "unknown ns record", "nstrace.unknown",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_unknowndata,\r\n{ "data", "nstrace.unknown.data",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_inforec,\r\n{ "info record", "nstrace.inforec",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_inforec_info,\r\n{ "info", "nstrace.inforec.info",\r\nFT_STRING, STR_ASCII, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_sslrec,\r\n{ "ssl record", "nstrace.sslrec",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_sslrec_seq,\r\n{ "SSL record seq no", "nstrace.sslrec.seq",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_mptcprec,\r\n{ "mptcp record", "nstrace.mptcp",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_mptcprec_subflowid,\r\n{ "MPTCP subflow id", "nstrace.sslrec.subflow",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_vmnamerec,\r\n{ "vmname record", "nstrace.vmnames",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_vmnamerec_srcvmname,\r\n{ "SrcVmName", "nstrace.vmnames.srcvmname",\r\nFT_STRING, STR_ASCII, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_vmnamerec_dstvmname,\r\n{ "DstVmName", "nstrace.vmnames.dstvmnames",\r\nFT_STRING, STR_ASCII, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clusterrec,\r\n{ "cluster record", "nstrace.cluster",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clu_snode,\r\n{ "Source Node", "nstrace.cluster.snode",\r\nFT_INT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_clu_dnode,\r\n{ "Destination Node", "nstrace.cluster.dnode",\r\nFT_INT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_clu_clflags,\r\n{ "Cluster Flags", "nstrace.cluster.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_clu_clflags_res,\r\n{ "Reserved", "nstrace.cluster.flags.res",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_RES,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clu_clflags_rssh,\r\n{ "RSSHASH", "nstrace.cluster.flags.rssh",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_RSSH,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clu_clflags_rss,\r\n{ "SRSS", "nstrace.cluster.flags.srss",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_RSS,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clu_clflags_dfd,\r\n{ "DFD", "nstrace.cluster.flags.dfd",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_DFD,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clu_clflags_fr,\r\n{ "Flow receiver (FR)", "nstrace.cluster.flags.fr",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_FR,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_clu_clflags_fp,\r\n{ "Flow processor (FP)", "nstrace.cluster.flags.fp",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), CL_FP,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ns_errorcode,\r\n{ "Errorcode", "nstrace.err",\r\nFT_UINT8, BASE_HEX, VALS(ns_errorcode_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ns_app,\r\n{ "App", "nstrace.app",\r\nFT_UINT8, BASE_HEX, VALS(ns_app_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ns,\r\n&ett_ns_flags,\r\n&ett_ns_activity_flags,\r\n&ett_ns_tcpdebug,\r\n&ett_ns_unknownrec,\r\n&ett_ns_inforec,\r\n&ett_ns_vmnamerec,\r\n&ett_ns_clusterrec,\r\n&ett_ns_clu_clflags,\r\n&ett_ns_sslrec,\r\n&ett_ns_mptcprec,\r\n&ett_ns_capflags,\r\n};\r\nproto_nstrace = proto_register_protocol("NetScaler Trace", "NS Trace", "ns");\r\nproto_register_field_array(proto_nstrace, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid proto_reg_handoff_ns(void)\r\n{\r\ndissector_handle_t nstrace_handle;\r\neth_withoutfcs_handle = find_dissector_add_dependency("eth_withoutfcs", proto_nstrace);\r\nhttp_handle = find_dissector_add_dependency("http", proto_nstrace);\r\nnstrace_handle = create_dissector_handle(dissect_nstrace, proto_nstrace);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NSTRACE_1_0, nstrace_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NSTRACE_2_0, nstrace_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NSTRACE_3_0, nstrace_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NSTRACE_3_5, nstrace_handle);\r\n}
