static int\r\ndissect_sap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nint sap_version, is_ipv6, is_del, is_enc, is_comp, addr_len;\r\nguint8 vers_flags;\r\nguint8 auth_len;\r\nguint8 auth_flags;\r\ntvbuff_t *next_tvb;\r\nproto_item *si, *sif;\r\nproto_tree *sap_tree = NULL, *sap_flags_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "SAP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nvers_flags = tvb_get_guint8(tvb, offset);\r\nis_ipv6 = vers_flags&MCAST_SAP_BIT_A;\r\nis_del = vers_flags&MCAST_SAP_BIT_T;\r\nis_enc = vers_flags&MCAST_SAP_BIT_E;\r\nis_comp = vers_flags&MCAST_SAP_BIT_C;\r\nsap_version = (vers_flags&MCAST_SAP_VERSION_MASK)>>MCAST_SAP_VERSION_SHIFT;\r\naddr_len = (is_ipv6) ? (int)sizeof(struct e_in6_addr) : 4;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s (v%u)",\r\n(is_del) ? "Deletion" : "Announcement", sap_version);\r\nif (tree) {\r\nsi = proto_tree_add_item(tree, proto_sap, tvb, offset, -1, ENC_NA);\r\nsap_tree = proto_item_add_subtree(si, ett_sap);\r\nsif = proto_tree_add_item(sap_tree, hf_sap_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nsap_flags_tree = proto_item_add_subtree(sif, ett_sap_flags);\r\nproto_tree_add_item(sap_flags_tree, hf_sap_flags_v, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sap_flags_tree, hf_sap_flags_a, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(sap_flags_tree, hf_sap_flags_r, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(sap_flags_tree, hf_sap_flags_t, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(sap_flags_tree, hf_sap_flags_e, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(sap_flags_tree, hf_sap_flags_c, tvb, offset, 1, ENC_NA);\r\n}\r\noffset++;\r\nauth_len = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(sap_tree, hf_sap_auth_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(sap_tree, hf_sap_message_identifier_hash, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset +=2;\r\nif (is_ipv6)\r\nproto_tree_add_item(sap_tree, hf_sap_originating_source_ipv6, tvb, offset, addr_len, ENC_NA);\r\nelse\r\nproto_tree_add_item(sap_tree, hf_sap_originating_source_ipv4, tvb, offset, addr_len, ENC_BIG_ENDIAN);\r\noffset += addr_len;\r\nif (auth_len > 0) {\r\nguint32 auth_data_len;\r\nproto_item *sdi, *sai;\r\nproto_tree *sa_tree, *saf_tree;\r\nint has_pad;\r\nguint8 pad_len = 0;\r\nauth_data_len = (guint32)(auth_len * sizeof(guint32));\r\nsdi = proto_tree_add_item(sap_tree, hf_auth_data, tvb, offset, auth_data_len, ENC_NA);\r\nsa_tree = proto_item_add_subtree(sdi, ett_sap_auth);\r\nauth_flags = tvb_get_guint8(tvb, offset);\r\nsai = proto_tree_add_item(sa_tree, hf_auth_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nsaf_tree = proto_item_add_subtree(sai, ett_sap_authf);\r\nproto_tree_add_item(saf_tree, hf_auth_flags_v, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(saf_tree, hf_auth_flags_p, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(saf_tree, hf_auth_flags_t, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nhas_pad = auth_flags&MCAST_SAP_AUTH_BIT_P;\r\nif (has_pad) {\r\npad_len = tvb_get_guint8(tvb, offset+auth_data_len-1);\r\n}\r\nif ((int) auth_data_len - pad_len - 1 < 0) {\r\nexpert_add_info_format(pinfo, sai, &ei_sap_bogus_authentication_or_pad_length,\r\n"Bogus authentication length (%d) or pad length (%d)", auth_len, pad_len);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nproto_tree_add_item(sa_tree, hf_sap_auth_subheader, tvb, offset+1, auth_data_len-pad_len-1, ENC_NA);\r\nif (has_pad) {\r\nproto_tree_add_item(sa_tree, hf_sap_auth_data_padding_len, tvb, offset+auth_data_len-1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sa_tree, hf_sap_auth_data_padding, tvb, offset+auth_data_len-pad_len, pad_len, ENC_NA);\r\n}\r\noffset += auth_data_len;\r\n}\r\nif (is_enc || is_comp) {\r\nexpert_field *mangle;\r\nif (is_enc && is_comp)\r\nmangle = &ei_sap_compressed_and_encrypted;\r\nelse if (is_enc)\r\nmangle = &ei_sap_encrypted;\r\nelse\r\nmangle = &ei_sap_compressed;\r\nproto_tree_add_expert(sap_tree, pinfo, mangle, tvb, offset, -1);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nif (tree) {\r\nif (tvb_strneql(tvb, offset, "v=", strlen("v="))) {\r\ngint remaining_len;\r\nguint32 pt_len;\r\nint pt_string_len;\r\nguint8* pt_str;\r\nremaining_len = tvb_captured_length_remaining(tvb, offset);\r\nif (remaining_len == 0) {\r\nremaining_len = 1;\r\n}\r\npt_string_len = tvb_strnlen(tvb, offset, remaining_len);\r\nif (pt_string_len == -1) {\r\npt_string_len = remaining_len;\r\npt_len = pt_string_len;\r\n} else {\r\npt_len = pt_string_len + 1;\r\n}\r\npt_str = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, pt_string_len, ENC_ASCII);\r\nproto_tree_add_string_format_value(sap_tree, hf_sap_payload_type, tvb, offset, pt_len,\r\npt_str, "%.*s", pt_string_len, pt_str);\r\noffset += pt_len;\r\n}\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(sdp_handle, next_tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_sap(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_sap_flags,\r\n{ "Flags", "sap.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Bits in the beginning of the SAP header", HFILL }},\r\n{ &hf_sap_flags_v,\r\n{ "Version Number", "sap.flags.v",\r\nFT_UINT8, BASE_DEC, VALS(mcast_sap_ver), MCAST_SAP_VERSION_MASK,\r\n"3 bit version field in the SAP header", HFILL }},\r\n{ &hf_sap_flags_a,\r\n{ "Address Type", "sap.flags.a",\r\nFT_BOOLEAN, 8, TFS(&mcast_sap_address_type), MCAST_SAP_BIT_A,\r\n"Originating source address type", HFILL }},\r\n{ &hf_sap_flags_r,\r\n{ "Reserved", "sap.flags.r",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), MCAST_SAP_BIT_R,\r\nNULL, HFILL }},\r\n{ &hf_sap_flags_t,\r\n{ "Message Type", "sap.flags.t",\r\nFT_BOOLEAN, 8, TFS(&mcast_sap_message_type), MCAST_SAP_BIT_T,\r\n"Announcement type", HFILL }},\r\n{ &hf_sap_flags_e,\r\n{ "Encryption Bit", "sap.flags.e",\r\nFT_BOOLEAN, 8, TFS(&mcast_sap_crypt_type), MCAST_SAP_BIT_E,\r\nNULL, HFILL }},\r\n{ &hf_sap_flags_c,\r\n{ "Compression Bit", "sap.flags.c",\r\nFT_BOOLEAN, 8, TFS(&mcast_sap_comp_type), MCAST_SAP_BIT_C,\r\nNULL, HFILL }},\r\n{ &hf_auth_data,\r\n{ "Authentication data", "sap.auth",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_auth_flags,\r\n{ "Authentication data flags", "sap.auth.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_auth_flags_v,\r\n{ "Version Number", "sap.auth.flags.v",\r\nFT_UINT8, BASE_DEC, VALS(mcast_sap_auth_ver), MCAST_SAP_VERSION_MASK,\r\nNULL, HFILL }},\r\n{ &hf_auth_flags_p,\r\n{ "Padding Bit", "sap.auth.flags.p",\r\nFT_BOOLEAN, 8, TFS(&mcast_sap_auth_pad), MCAST_SAP_AUTH_BIT_P,\r\nNULL, HFILL }},\r\n{ &hf_auth_flags_t,\r\n{ "Authentication Type", "sap.auth.flags.t",\r\nFT_UINT8, BASE_DEC, VALS(mcast_sap_auth_type), MCAST_SAP_AUTH_TYPE_MASK,\r\nNULL, HFILL }},\r\n{ &hf_sap_auth_len, { "Authentication Length", "sap.auth.len", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sap_message_identifier_hash, { "Message Identifier Hash", "sap.message_identifier_hash", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sap_originating_source_ipv4, { "Originating Source", "sap.originating_source", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sap_originating_source_ipv6, { "Originating Source", "sap.originating_source.ipv6", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sap_auth_subheader, { "Authentication subheader", "sap.auth.subheader", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sap_auth_data_padding, { "Authentication data padding", "sap.auth.data_padding", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sap_auth_data_padding_len, { "Authentication data pad count (bytes)", "sap.auth.data_padding.len", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sap_payload_type, { "Payload type", "sap.payload_type", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_sap,\r\n&ett_sap_flags,\r\n&ett_sap_auth,\r\n&ett_sap_authf,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_sap_compressed_and_encrypted, { "sap.compressed_and_encrypted", PI_UNDECODED, PI_WARN, "The rest of the packet is compressed and encrypted", EXPFILL }},\r\n{ &ei_sap_encrypted, { "sap.encrypted", PI_UNDECODED, PI_WARN, "The rest of the packet is encrypted", EXPFILL }},\r\n{ &ei_sap_compressed, { "sap.compressed", PI_UNDECODED, PI_WARN, "The rest of the packet is compressed", EXPFILL }},\r\n{ &ei_sap_bogus_authentication_or_pad_length, { "sap.bogus_authentication_or_pad_length", PI_PROTOCOL, PI_WARN, "Bogus authentication length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_sap;\r\nproto_sap = proto_register_protocol("Session Announcement Protocol", "SAP", "sap");\r\nproto_register_field_array(proto_sap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_sap = expert_register_protocol(proto_sap);\r\nexpert_register_field_array(expert_sap, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_sap(void)\r\n{\r\ndissector_handle_t sap_handle;\r\nsap_handle = create_dissector_handle(dissect_sap, proto_sap);\r\ndissector_add_uint("udp.port", UDP_PORT_SAP, sap_handle);\r\nsdp_handle = find_dissector_add_dependency("sdp", proto_sap);\r\n}
