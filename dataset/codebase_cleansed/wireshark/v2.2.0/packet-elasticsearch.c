static void elasticsearch_format_version(gchar *buf, guint32 value) {\r\ng_snprintf(buf, ELASTICSEARCH_VERSION_LABEL_LENGTH, "%d.%d.%d (%d)", (value / 1000000) % 100,\r\n(value / 10000) % 100, (value/ 100) % 100, value);\r\n}\r\nstatic vint_t read_vint(tvbuff_t *tvb, int offset){\r\nvint_t vint;\r\nguint8 b = tvb_get_guint8(tvb, offset);\r\nvint.value = b & 0x7F;\r\nif ((b & 0x80) == 0) {\r\nvint.length = 1;\r\nreturn vint;\r\n}\r\nb = tvb_get_guint8(tvb, offset+1);\r\nvint.value |= (b & 0x7F) << 7;\r\nif ((b & 0x80) == 0) {\r\nvint.length = 2;\r\nreturn vint;\r\n}\r\nb = tvb_get_guint8(tvb, offset+2);\r\nvint.value |= (b & 0x7F) << 14;\r\nif ((b & 0x80) == 0) {\r\nvint.length = 3;\r\nreturn vint;\r\n}\r\nb = tvb_get_guint8(tvb, offset+3);\r\nvint.value |= (b & 0x7F) << 21;\r\nif ((b & 0x80) == 0) {\r\nvint.length = 4;\r\nreturn vint;\r\n}\r\nb = tvb_get_guint8(tvb, offset+4);\r\nvint.length = 5;\r\nvint.value |= ((b & 0x7F) << 28);\r\nreturn vint;\r\n}\r\nstatic vstring_t read_vstring(tvbuff_t *tvb, int offset) {\r\nvstring_t vstring;\r\nint string_starting_offset;\r\nint string_length;\r\nvstring.vint_length = read_vint(tvb, offset);\r\nstring_starting_offset = offset + vstring.vint_length.length;\r\nstring_length = vstring.vint_length.value;\r\nvstring.value = tvb_get_string_enc(wmem_packet_scope(), tvb, string_starting_offset, string_length, ENC_UTF_8);\r\nvstring.length = string_length + vstring.vint_length.length;\r\nreturn vstring;\r\n}\r\nstatic int elasticsearch_partial_dissect_address(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset) {\r\nproto_tree *address_tree;\r\nproto_item *address_item;\r\nint start_offset;\r\nguint8 es_address_format;\r\nguint8 address_length;\r\nvstring_t address_name;\r\nguint16 address_type_id;\r\nstart_offset = offset;\r\naddress_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_elasticsearch_address, &address_item, "Address" );\r\nproto_tree_add_item(address_tree, hf_elasticsearch_address_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\naddress_type_id = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nif(address_type_id != ADDRESS_TYPE_SOCKET) {\r\nexpert_add_info(pinfo, tree, &ei_elasticsearch_unsupported_address_type);\r\nreturn offset;\r\n}\r\nes_address_format = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(address_tree, hf_elasticsearch_address_format, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nswitch(es_address_format) {\r\ncase ADDRESS_FORMAT_NUEMRIC:\r\naddress_length = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(address_tree, hf_elasticsearch_address_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (address_length == IPv4_ADDRESS_LENGTH) {\r\nproto_tree_add_item(address_tree, hf_elasticsearch_address_ipv4, tvb, offset, 4, ENC_NA);\r\noffset += 4;\r\n}\r\nelse {\r\nproto_tree_add_item(address_tree, hf_elasticsearch_address_ipv6, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\nproto_tree_add_item(address_tree, hf_elasticsearch_address_ipv6_scope_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nbreak;\r\ncase ADDRESS_FORMAT_STRING:\r\naddress_name = read_vstring(tvb, offset);\r\nproto_tree_add_string(address_tree, hf_elasticsearch_address_name, tvb, offset, address_name.length, address_name.value);\r\noffset += address_name.length;\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, tree, &ei_elasticsearch_unsupported_address_format);\r\nbreak;\r\n}\r\nproto_tree_add_item(address_item, hf_elasticsearch_address_port, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_item_set_len(address_item, offset - start_offset);\r\nreturn offset;\r\n}\r\nstatic version_t elasticsearch_parse_version(tvbuff_t *tvb, int offset){\r\nversion_t version;\r\nvint_t raw_version_value;\r\nraw_version_value = read_vint(tvb, offset);\r\nversion.length = raw_version_value.length;\r\nversion.value = raw_version_value.value;\r\ng_snprintf(version.string, sizeof(version.string), "%d.%d.%d", (version.value / 1000000) % 100,\r\n(version.value / 10000) % 100, (version.value/ 100) % 100);\r\nreturn version;\r\n}\r\nstatic int dissect_elasticsearch_zen_ping(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_){\r\nint offset = 0;\r\nversion_t version;\r\nvstring_t cluster_name;\r\nvstring_t node_name;\r\nvstring_t node_id;\r\nvstring_t host_name;\r\nvstring_t host_address;\r\nvint_t attributes_length;\r\nversion_t node_version;\r\nproto_item *root_elasticsearch_item;\r\nproto_tree *elasticsearch_tree;\r\nproto_tree *discovery_node_tree;\r\nproto_item *discovery_node_item;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Elasticsearch");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nroot_elasticsearch_item = proto_tree_add_item(tree, proto_elasticsearch, tvb, 0, -1, ENC_NA);\r\nelasticsearch_tree = proto_item_add_subtree(root_elasticsearch_item,ett_elasticsearch);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Zen Ping: ");\r\nproto_tree_add_item(elasticsearch_tree, hf_elasticsearch_internal_header, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nversion = elasticsearch_parse_version(tvb, offset);\r\nproto_tree_add_uint(elasticsearch_tree, hf_elasticsearch_version, tvb, offset, version.length, version.value);\r\noffset += version.length;\r\nproto_tree_add_item(elasticsearch_tree, hf_elasticsearch_ping_request_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ncluster_name = read_vstring(tvb, offset);\r\nproto_tree_add_string(elasticsearch_tree, hf_elasticsearch_cluster_name, tvb, offset, cluster_name.length, cluster_name.value);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "cluster=%s", cluster_name.value);\r\noffset += cluster_name.length;\r\ndiscovery_node_tree = proto_tree_add_subtree(elasticsearch_tree, tvb, offset, -1, ett_elasticsearch_discovery_node, &discovery_node_item, "Node" );\r\nnode_name = read_vstring(tvb, offset);\r\nproto_tree_add_string(discovery_node_tree, hf_elasticsearch_node_name, tvb, offset, node_name.length, node_name.value);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", name=%s", node_name.value);\r\noffset += node_name.length;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", version=%s", version.string);\r\nnode_id = read_vstring(tvb, offset);\r\nproto_tree_add_string(discovery_node_tree, hf_elasticsearch_node_id, tvb, offset, node_id.length, node_id.value);\r\noffset += node_id.length;\r\nhost_name = read_vstring(tvb, offset);\r\nproto_tree_add_string(discovery_node_tree, hf_elasticsearch_host_name, tvb, offset, host_name.length, host_name.value);\r\noffset += host_name.length;\r\nhost_address = read_vstring(tvb, offset);\r\nproto_tree_add_string(discovery_node_tree, hf_elasticsearch_host_address, tvb, offset, host_address.length, host_address.value);\r\noffset += host_address.length;\r\noffset = elasticsearch_partial_dissect_address(tvb, pinfo, discovery_node_tree, offset);\r\nattributes_length = read_vint(tvb, offset);\r\nproto_tree_add_uint(discovery_node_tree, hf_elasticsearch_attributes_length, tvb, offset, attributes_length.length, attributes_length.value);\r\noffset += attributes_length.length;\r\nnode_version = elasticsearch_parse_version(tvb, offset);\r\nproto_tree_add_uint(elasticsearch_tree, hf_elasticsearch_version, tvb, offset, node_version.length, node_version.value);\r\noffset += node_version.length;\r\nreturn offset;\r\n}\r\nstatic int elasticsearch_binary_header_is_valid(tvbuff_t *tvb){\r\nreturn tvb_captured_length(tvb) >= 1 && tvb_get_ntohs(tvb, 0) == ELASTICSEARCH_BINARY_HEADER_TOKEN;\r\n}\r\nstatic int elasticsearch_transport_status_flag_is_a_response(gint8 transport_status_flags) {\r\nreturn transport_status_flags & ELASTICSEARCH_STATUS_FLAG_RESPONSE;\r\n}\r\nstatic int transport_status_flag_is_a_request(gint8 transport_status_flags){\r\nreturn !elasticsearch_transport_status_flag_is_a_response(transport_status_flags);\r\n}\r\nstatic int elasticsearch_is_compressed(gint8 transport_status_flags){\r\nreturn transport_status_flags & ELASTICSEARCH_STATUS_FLAG_COMPRESSED;\r\n}\r\nstatic void elasticsearch_decode_binary_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, gint8 transport_status_flags) {\r\nvstring_t action;\r\nif(elasticsearch_is_compressed(transport_status_flags)){\r\nproto_tree_add_item(tree, hf_elasticsearch_data_compressed, tvb, offset, -1, ENC_NA);\r\ncol_append_str(pinfo->cinfo, COL_INFO, "[COMPRESSED], ");\r\n} else {\r\naction = read_vstring(tvb, offset);\r\nproto_tree_add_string(tree, hf_elasticsearch_action, tvb, offset, action.length, action.value);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "action=%s, ", action.value);\r\noffset += action.length;\r\nproto_tree_add_item(tree, hf_elasticsearch_data, tvb, offset, -1, ENC_NA);\r\n}\r\n}\r\nstatic void append_status_info_to_column(packet_info *pinfo, gint8 transport_status_flags) {\r\nif(transport_status_flags & ELASTICSEARCH_STATUS_FLAG_ERROR){\r\ncol_append_str(pinfo->cinfo, COL_INFO, "[ERROR], ");\r\n}else{\r\ncol_append_str(pinfo->cinfo, COL_INFO, "[OK], ");\r\n}\r\n}\r\nstatic void elasticsearch_decode_binary_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, gint8 transport_status_flags) {\r\nappend_status_info_to_column(pinfo, transport_status_flags);\r\nif(elasticsearch_is_compressed(transport_status_flags)){\r\ncol_append_str(pinfo->cinfo, COL_INFO, "[COMPRESSED], ");\r\nproto_tree_add_item(tree, hf_elasticsearch_data_compressed, tvb, offset, -1, ENC_NA);\r\n} else {\r\nproto_tree_add_item(tree, hf_elasticsearch_data, tvb, offset, -1, ENC_NA);\r\n}\r\n}\r\nstatic int elasticsearch_dissect_valid_binary_packet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_){\r\nint offset = 0;\r\ngint8 transport_status_flags;\r\nguint64 request_id;\r\nproto_item *transport_status_flags_item;\r\nproto_tree *transport_status_flags_tree;\r\nproto_tree_add_item(tree, hf_elasticsearch_header_token, tvb, offset, 2, ENC_ASCII|ENC_NA);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_elasticsearch_header_message_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_elasticsearch_header_request_id, tvb, offset, 8, ENC_BIG_ENDIAN);\r\nrequest_id = tvb_get_ntoh64(tvb, offset);\r\noffset += 8;\r\ntransport_status_flags = tvb_get_guint8(tvb, offset);\r\ntransport_status_flags_item = proto_tree_add_uint(tree, hf_elasticsearch_header_status_flags, tvb, offset, 1, transport_status_flags);\r\ntransport_status_flags_tree = proto_item_add_subtree(transport_status_flags_item, ett_elasticsearch_status_flags);\r\nif(elasticsearch_transport_status_flag_is_a_response(transport_status_flags)){\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Response: ");\r\n} else {\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Request: ");\r\n}\r\nproto_tree_add_bits_item(transport_status_flags_tree, hf_elasticsearch_header_status_flags_compression, tvb, offset * BITS_IN_A_BYTE + 5, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(transport_status_flags_tree, hf_elasticsearch_header_status_flags_error, tvb, offset * BITS_IN_A_BYTE + 6, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(transport_status_flags_tree, hf_elasticsearch_header_status_flags_message_type, tvb, offset * BITS_IN_A_BYTE + 7, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_elasticsearch_version, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (transport_status_flag_is_a_request(transport_status_flags)) {\r\nelasticsearch_decode_binary_request(tvb, pinfo, tree, offset, transport_status_flags);\r\n} else {\r\nelasticsearch_decode_binary_response(tvb, pinfo, tree, offset, transport_status_flags);\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "request_id=%"G_GUINT64_FORMAT" ", request_id);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint elasticsearch_get_binary_message_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nreturn (guint)tvb_get_ntohl(tvb, offset+ELASTICSEARCH_MESSAGE_LENGTH_OFFSET) + ELASTICSEARCH_HEADER_LENGTH;\r\n}\r\nstatic void elasticsearch_dissect_binary_protocol(tvbuff_t *tvb, packet_info *pinfo, void *data, int offset, proto_tree *elasticsearch_tree) {\r\nif(elasticsearch_binary_header_is_valid(tvb)){\r\ntcp_dissect_pdus(tvb, pinfo, elasticsearch_tree, TRUE, ELASTICSEARCH_HEADER_LENGTH,\r\nelasticsearch_get_binary_message_len, elasticsearch_dissect_valid_binary_packet, data);\r\n} else {\r\nproto_tree_add_item(elasticsearch_tree, hf_elasticsearch_data, tvb, offset, -1, ENC_NA);\r\nexpert_add_info(pinfo, elasticsearch_tree, &ei_elasticsearch_unsupported_version);\r\n}\r\n}\r\nstatic void elasticsearch_dissect_tcp_message_types(tvbuff_t *tvb, packet_info *pinfo, void *data, int offset,\r\nproto_tree *elasticsearch_tree, proto_tree *root_tree) {\r\nif(pinfo->srcport == ELASTICSEARCH_BINARY_PORT || pinfo->destport == ELASTICSEARCH_BINARY_PORT){\r\nelasticsearch_dissect_binary_protocol(tvb, pinfo, data, offset, elasticsearch_tree);\r\n} else if(pinfo->srcport == ELASTICSEARCH_HTTP_PORT || pinfo->destport == ELASTICSEARCH_HTTP_PORT) {\r\npinfo->can_desegment = pinfo->saved_can_desegment;\r\ncall_dissector(elasticsearch_http_handle, tvb, pinfo, root_tree);\r\n}\r\n}\r\nstatic int dissect_elasticsearch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data) {\r\nint offset = 0;\r\nproto_item *root_elasticsearch_item;\r\nproto_tree *elasticsearch_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Elasticsearch");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nroot_elasticsearch_item = proto_tree_add_item(tree, proto_elasticsearch, tvb, 0, -1, ENC_NA);\r\nelasticsearch_tree = proto_item_add_subtree(root_elasticsearch_item,ett_elasticsearch);\r\nelasticsearch_dissect_tcp_message_types(tvb, pinfo, data, offset, elasticsearch_tree, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_elasticsearch(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_elasticsearch_internal_header,\r\n{ "Internal header", "elasticsearch.internal_header",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_version,\r\n{ "Version", "elasticsearch.version",\r\nFT_UINT32, BASE_CUSTOM,\r\nCF_FUNC(elasticsearch_format_version), 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_ping_request_id,\r\n{ "Ping ID", "elasticsearch.ping_request_id",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_cluster_name,\r\n{ "Cluster name", "elasticsearch.cluster_name",\r\nFT_STRING, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_node_name,\r\n{ "Node name", "elasticsearch.node_name",\r\nFT_STRING, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_node_id,\r\n{ "Node ID", "elasticsearch.node_id",\r\nFT_STRING, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_host_name,\r\n{ "Hostname", "elasticsearch.host_name",\r\nFT_STRING, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_host_address,\r\n{ "Host address", "elasticsearch.host_address",\r\nFT_STRING, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_address_type,\r\n{ "Type", "elasticsearch.address.type",\r\nFT_UINT16, BASE_DEC,\r\nVALS(address_types), 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_address_format,\r\n{ "Format", "elasticsearch.address.format",\r\nFT_UINT8, BASE_DEC,\r\nVALS(address_format), 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_address_name,\r\n{ "Name", "elasticsearch.address.name",\r\nFT_STRING, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_address_length,\r\n{ "Length", "elasticsearch.address.length",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_address_ipv4,\r\n{ "IP", "elasticsearch.address.ipv4",\r\nFT_IPv4, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_address_ipv6,\r\n{ "IP", "elasticsearch.address.ipv6",\r\nFT_IPv6, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_address_ipv6_scope_id,\r\n{ "IP", "elasticsearch.address.ipv6.scope_id",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_address_port,\r\n{ "Port", "elasticsearch.address.port",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_attributes_length,\r\n{ "Attributes length", "elasticsearch.attributes.length",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_header_token,\r\n{ "Token", "elasticsearch.header.token",\r\nFT_STRING, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_header_message_length,\r\n{ "Message length", "elasticsearch.header.message_length",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_header_request_id,\r\n{ "Request ID", "elasticsearch.header.request_id",\r\nFT_UINT64, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_header_status_flags,\r\n{ "Status flags", "elasticsearch.header.status_flags",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_header_status_flags_message_type,\r\n{ "Message type", "elasticsearch.header.status_flags.message_type",\r\nFT_UINT8, BASE_DEC,\r\nVALS(status_flag_message_type), 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_header_status_flags_error,\r\n{ "Error", "elasticsearch.header.status_flags.error",\r\nFT_BOOLEAN, BASE_NONE,\r\nTFS(&tfs_set_notset), 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_header_status_flags_compression,\r\n{ "Compression", "elasticsearch.header.status_flags.compression",\r\nFT_BOOLEAN, BASE_NONE,\r\nTFS(&tfs_set_notset), 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_action,\r\n{ "Action", "elasticsearch.action",\r\nFT_STRING, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_data,\r\n{ "Data", "elasticsearch.data",\r\nFT_NONE, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_elasticsearch_data_compressed,\r\n{ "Compressed data", "elasticsearch.data_compressed",\r\nFT_NONE, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_elasticsearch,\r\n&ett_elasticsearch_address,\r\n&ett_elasticsearch_discovery_node,\r\n&ett_elasticsearch_status_flags,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_elasticsearch_unsupported_version, { "elasticsearch.version.unsupported", PI_UNDECODED, PI_WARN, "Unsupported header type: Elasticsearch version < 0.20.0RC1", EXPFILL }},\r\n{ &ei_elasticsearch_unsupported_address_format, { "elasticsearch.address.format.unsupported", PI_MALFORMED, PI_WARN, "Unsupported address format", EXPFILL }},\r\n{ &ei_elasticsearch_unsupported_address_type, { "elasticsearch.address.type.unsupported", PI_MALFORMED, PI_WARN, "Unsupported address type", EXPFILL }},\r\n};\r\nexpert_module_t*expert_elasticsearch;\r\nexpert_elasticsearch = expert_register_protocol(proto_elasticsearch);\r\nexpert_register_field_array(expert_elasticsearch, ei, array_length(ei));\r\nproto_elasticsearch = proto_register_protocol(\r\n"Elasticsearch",\r\n"Elasticsearch",\r\n"elasticsearch"\r\n);\r\nproto_register_field_array(proto_elasticsearch, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid proto_reg_handoff_elasticsearch(void) {\r\ndissector_handle_t elasticsearch_handle;\r\ndissector_handle_t elasticsearch_zen_handle;\r\nelasticsearch_http_handle = find_dissector_add_dependency("http", proto_elasticsearch);\r\nelasticsearch_handle = create_dissector_handle(dissect_elasticsearch, proto_elasticsearch);\r\nelasticsearch_zen_handle = create_dissector_handle(dissect_elasticsearch_zen_ping, proto_elasticsearch);\r\ndissector_add_uint("udp.port", ELASTICSEARCH_DISCOVERY_PORT, elasticsearch_zen_handle);\r\ndissector_add_uint("tcp.port", ELASTICSEARCH_BINARY_PORT, elasticsearch_handle);\r\ndissector_add_uint("tcp.port", ELASTICSEARCH_HTTP_PORT, elasticsearch_handle);\r\n}
