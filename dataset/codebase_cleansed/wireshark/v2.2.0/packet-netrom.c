static void\r\ndissect_netrom_type(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree,\r\nint hf_netrom_type_param, gint ett_netrom_type_param, const netrom_tf_items *type_items )\r\n{\r\nproto_tree *tc;\r\nproto_tree *type_tree;\r\nchar *info_buffer;\r\nguint8 type;\r\nguint8 op_code;\r\ntype = tvb_get_guint8( tvb, offset );\r\nop_code = type &0x0f;\r\ninfo_buffer = wmem_strdup_printf( wmem_packet_scope(), "%s%s%s%s (0x%02x)",\r\nval_to_str_const( op_code, op_code_vals_text, "Unknown" ),\r\n( type & NETROM_MORE_FLAG ) ? ", More" : "",\r\n( type & NETROM_NAK_FLAG ) ? ", NAK" : "",\r\n( type & NETROM_CHOKE_FLAG ) ? ", Choke" : "",\r\ntype );\r\ncol_add_str( pinfo->cinfo, COL_INFO, info_buffer );\r\nif ( tree )\r\n{\r\ntc = proto_tree_add_uint_format( tree,\r\nhf_netrom_type_param,\r\ntvb,\r\noffset,\r\n1,\r\ntype,\r\n"Type field: %s",\r\ninfo_buffer\r\n);\r\ntype_tree = proto_item_add_subtree( tc, ett_netrom_type_param );\r\nproto_tree_add_item( type_tree, *type_items->hf_tf_op, tvb, offset, 1, ENC_BIG_ENDIAN );\r\nproto_tree_add_item( type_tree, *type_items->hf_tf_choke, tvb, offset, 1, ENC_BIG_ENDIAN );\r\nproto_tree_add_item( type_tree, *type_items->hf_tf_nak, tvb, offset, 1, ENC_BIG_ENDIAN );\r\nproto_tree_add_item( type_tree, *type_items->hf_tf_more, tvb, offset, 1, ENC_BIG_ENDIAN );\r\n}\r\n}\r\nstatic void\r\ndissect_netrom_proto(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *netrom_tree;\r\nint offset;\r\n#if 0\r\nguint8 src_ssid;\r\nguint8 dst_ssid;\r\n#endif\r\nguint8 op_code;\r\nguint8 cct_index;\r\nguint8 cct_id;\r\ntvbuff_t *next_tvb;\r\ncol_set_str( pinfo->cinfo, COL_PROTOCOL, "NET/ROM" );\r\ncol_clear( pinfo->cinfo, COL_INFO );\r\noffset = 0;\r\nset_address_tvb(&pinfo->dl_src, AT_AX25, AX25_ADDR_LEN, tvb, offset);\r\nset_address_tvb(&pinfo->src, AT_AX25, AX25_ADDR_LEN, tvb, offset);\r\noffset += AX25_ADDR_LEN;\r\nset_address_tvb(&pinfo->dl_dst, AT_AX25, AX25_ADDR_LEN, tvb, offset);\r\nset_address_tvb(&pinfo->dst, AT_AX25, AX25_ADDR_LEN, tvb, offset);\r\noffset += AX25_ADDR_LEN;\r\noffset += 1;\r\ncct_index = tvb_get_guint8( tvb, offset );\r\noffset += 1;\r\ncct_id = tvb_get_guint8( tvb, offset );\r\noffset += 1;\r\noffset += 1;\r\noffset += 1;\r\nop_code = tvb_get_guint8( tvb, offset ) & 0x0f;\r\ncol_add_fstr( pinfo->cinfo, COL_INFO, "%s", val_to_str_const( op_code, op_code_vals_text, "Unknown" ));\r\n{\r\nti = proto_tree_add_protocol_format( tree, proto_netrom, tvb, 0, NETROM_HEADER_SIZE,\r\n"NET/ROM, Src: %s, Dst: %s",\r\naddress_to_str(wmem_packet_scope(), &pinfo->src),\r\naddress_to_str(wmem_packet_scope(), &pinfo->dst));\r\nnetrom_tree = proto_item_add_subtree( ti, ett_netrom );\r\noffset = 0;\r\nproto_tree_add_item( netrom_tree, hf_netrom_src, tvb, offset, AX25_ADDR_LEN, ENC_NA );\r\noffset += AX25_ADDR_LEN;\r\nproto_tree_add_item( netrom_tree, hf_netrom_dst, tvb, offset, AX25_ADDR_LEN, ENC_NA );\r\noffset += AX25_ADDR_LEN;\r\nproto_tree_add_item( netrom_tree, hf_netrom_ttl, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nswitch ( op_code )\r\n{\r\ncase NETROM_PROTOEXT :\r\nproto_tree_add_item( netrom_tree, hf_netrom_my_cct_index, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_my_cct_id, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\noffset += 1;\r\noffset += 1;\r\nbreak;\r\ncase NETROM_CONNREQ :\r\nproto_tree_add_item( netrom_tree, hf_netrom_my_cct_index, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_my_cct_id, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\noffset += 1;\r\noffset += 1;\r\nbreak;\r\ncase NETROM_CONNACK :\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_index, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_id, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_my_cct_index, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_my_cct_id, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nbreak;\r\ncase NETROM_DISCREQ :\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_index, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_id, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\noffset += 1;\r\noffset += 1;\r\nbreak;\r\ncase NETROM_DISCACK :\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_index, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_id, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\noffset += 1;\r\noffset += 1;\r\nbreak;\r\ncase NETROM_INFO :\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_index, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_id, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_n_s, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_n_r, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nbreak;\r\ncase NETROM_INFOACK :\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_index, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_your_cct_id, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_n_r, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nbreak;\r\ndefault :\r\noffset += 1;\r\noffset += 1;\r\noffset += 1;\r\noffset += 1;\r\nbreak;\r\n}\r\ndissect_netrom_type( tvb,\r\noffset,\r\npinfo,\r\nnetrom_tree,\r\nhf_netrom_type,\r\nett_netrom_type,\r\n&netrom_type_items\r\n);\r\noffset += 1;\r\nswitch ( op_code )\r\n{\r\ncase NETROM_PROTOEXT :\r\nbreak;\r\ncase NETROM_CONNREQ :\r\nproto_tree_add_item( netrom_tree, hf_netrom_pwindow, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nproto_tree_add_item( netrom_tree, hf_netrom_user, tvb, offset, AX25_ADDR_LEN, ENC_NA );\r\noffset += AX25_ADDR_LEN;\r\nproto_tree_add_item( netrom_tree, hf_netrom_node, tvb, offset, AX25_ADDR_LEN, ENC_NA );\r\noffset += AX25_ADDR_LEN;\r\nbreak;\r\ncase NETROM_CONNACK :\r\nproto_tree_add_item( netrom_tree, hf_netrom_awindow, tvb, offset, 1, ENC_BIG_ENDIAN );\r\noffset += 1;\r\nbreak;\r\ncase NETROM_DISCREQ :\r\nbreak;\r\ncase NETROM_DISCACK :\r\nbreak;\r\ncase NETROM_INFO :\r\nbreak;\r\ncase NETROM_INFOACK :\r\nbreak;\r\ndefault :\r\nbreak;\r\n}\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nswitch ( op_code )\r\n{\r\ncase NETROM_PROTOEXT :\r\nif ( cct_index == NETROM_PROTO_IP && cct_id == NETROM_PROTO_IP )\r\ncall_dissector( ip_handle , next_tvb, pinfo, tree );\r\nelse\r\ncall_data_dissector(next_tvb, pinfo, tree );\r\nbreak;\r\ncase NETROM_INFO :\r\ndefault :\r\ncall_data_dissector(next_tvb, pinfo, tree );\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndissect_netrom_routing(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\ntvbuff_t *next_tvb;\r\nconst guint8* mnemonic;\r\ngint mnemonic_len;\r\ncol_set_str( pinfo->cinfo, COL_PROTOCOL, "NET/ROM");\r\ncol_set_str( pinfo->cinfo, COL_INFO, "routing table frame");\r\nif (tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *netrom_tree;\r\nti = proto_tree_add_item( tree, proto_netrom, tvb, 0, -1, ENC_NA);\r\nnetrom_tree = proto_item_add_subtree( ti, ett_netrom );\r\nproto_tree_add_item_ret_string_and_length(netrom_tree, hf_netrom_mnemonic, tvb, 1, 6, ENC_ASCII|ENC_NA,\r\nwmem_packet_scope(), &mnemonic, &mnemonic_len);\r\nproto_item_append_text(ti, ", routing table frame, Node: %.6s", mnemonic);\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, 7);\r\ncall_data_dissector(next_tvb, pinfo, tree );\r\n}\r\nstatic int\r\ndissect_netrom(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nif ( tvb_get_guint8( tvb, 0 ) == 0xff )\r\ndissect_netrom_routing( tvb, pinfo, tree );\r\nelse\r\ndissect_netrom_proto( tvb, pinfo, tree );\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ncapture_netrom( const guchar *pd _U_, int offset, int len, capture_packet_info_t *cpinfo _U_, const union wtap_pseudo_header *pseudo_header _U_)\r\n{\r\nif ( ! BYTES_ARE_IN_FRAME( offset, len, NETROM_MIN_SIZE ) )\r\nreturn FALSE;\r\nreturn FALSE;\r\n}\r\nvoid\r\nproto_register_netrom(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_netrom_src,\r\n{ "Source", "netrom.src",\r\nFT_AX25, BASE_NONE, NULL, 0x0,\r\n"Source callsign", HFILL }\r\n},\r\n{ &hf_netrom_dst,\r\n{ "Destination", "netrom.dst",\r\nFT_AX25, BASE_NONE, NULL, 0x0,\r\n"Destination callsign", HFILL }\r\n},\r\n{ &hf_netrom_ttl,\r\n{ "TTL", "netrom.ttl",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netrom_my_cct_index,\r\n{ "My circuit index", "netrom.my.cct.index",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netrom_my_cct_id,\r\n{ "My circuit ID", "netrom.my.cct.id",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netrom_your_cct_index,\r\n{ "Your circuit index", "netrom.your.cct.index",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netrom_your_cct_id,\r\n{ "Your circuit ID", "netrom.your.cct.id",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netrom_n_r,\r\n{ "N(r)", "netrom.n_r",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netrom_n_s,\r\n{ "N(s)", "netrom.n_s",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netrom_type,\r\n{ "Type", "netrom.type",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Packet type field", HFILL }\r\n},\r\n{ &hf_netrom_op,\r\n{ "OP code", "netrom.op",\r\nFT_UINT8, BASE_HEX, VALS( op_code_vals_abbrev ), 0x0f,\r\n"Protocol operation code", HFILL }\r\n},\r\n{ &hf_netrom_more,\r\n{ "More", "netrom.flag.more",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), NETROM_MORE_FLAG,\r\n"More flag", HFILL }\r\n},\r\n{ &hf_netrom_nak,\r\n{ "NAK", "netrom.flag.nak",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), NETROM_NAK_FLAG,\r\n"NAK flag", HFILL }\r\n},\r\n{ &hf_netrom_choke,\r\n{ "Choke", "netrom.flag.choke",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), NETROM_CHOKE_FLAG,\r\n"Choke flag", HFILL }\r\n},\r\n{ &hf_netrom_user,\r\n{ "User", "netrom.user",\r\nFT_AX25, BASE_NONE, NULL, 0x0,\r\n"User callsign", HFILL }\r\n},\r\n{ &hf_netrom_node,\r\n{ "Node", "netrom.node",\r\nFT_AX25, BASE_NONE, NULL, 0x0,\r\n"Node callsign", HFILL }\r\n},\r\n{ &hf_netrom_pwindow,\r\n{ "Window", "netrom.pwindow",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Proposed window", HFILL }\r\n},\r\n{ &hf_netrom_awindow,\r\n{ "Window", "netrom.awindow",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Accepted window", HFILL }\r\n},\r\n{ &hf_netrom_mnemonic,\r\n{ "Node name", "netrom.name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_netrom,\r\n&ett_netrom_type,\r\n};\r\nproto_netrom = proto_register_protocol( "Amateur Radio NET/ROM", "NET/ROM", "netrom" );\r\nproto_register_field_array( proto_netrom, hf, array_length(hf ) );\r\nproto_register_subtree_array( ett, array_length( ett ) );\r\n}\r\nvoid\r\nproto_reg_handoff_netrom(void)\r\n{\r\ndissector_add_uint( "ax25.pid", AX25_P_NETROM, create_dissector_handle( dissect_netrom, proto_netrom ) );\r\nregister_capture_dissector("ax25.pid", AX25_P_NETROM, capture_netrom, proto_netrom);\r\nip_handle = find_dissector_add_dependency( "ip", proto_netrom );\r\n}
