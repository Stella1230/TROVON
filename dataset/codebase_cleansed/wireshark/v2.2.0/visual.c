wtap_open_return_val visual_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar magic[sizeof visual_magic];\r\nstruct visual_file_hdr vfile_hdr;\r\nstruct visual_read_info * visual;\r\nint encap;\r\nif (!wtap_read_bytes(wth->fh, magic, sizeof magic, err, err_info))\r\n{\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(magic, visual_magic, sizeof visual_magic) != 0)\r\n{\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &vfile_hdr, sizeof vfile_hdr, err, err_info))\r\n{\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nvfile_hdr.file_version = pletoh16(&vfile_hdr.file_version);\r\nif (vfile_hdr.file_version != 1)\r\n{\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("visual: file version %u unsupported", vfile_hdr.file_version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nswitch (pletoh16(&vfile_hdr.media_type))\r\n{\r\ncase 6:\r\nencap = WTAP_ENCAP_ETHERNET;\r\nbreak;\r\ncase 9:\r\nencap = WTAP_ENCAP_TOKEN_RING;\r\nbreak;\r\ncase 16:\r\nencap = WTAP_ENCAP_LAPB;\r\nbreak;\r\ncase 22:\r\ncase 118:\r\nencap = WTAP_ENCAP_CHDLC_WITH_PHDR;\r\nbreak;\r\ncase 32:\r\nencap = WTAP_ENCAP_FRELAY_WITH_PHDR;\r\nbreak;\r\ncase 37:\r\nencap = WTAP_ENCAP_ATM_PDUS;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("visual: network type %u unknown or unsupported",\r\nvfile_hdr.media_type);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_VISUAL_NETWORKS;\r\nwth->file_encap = encap;\r\nwth->snapshot_length = pletoh16(&vfile_hdr.max_length);\r\nwth->subtype_read = visual_read;\r\nwth->subtype_seek_read = visual_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_MSEC;\r\nvisual = (struct visual_read_info *)g_malloc(sizeof(struct visual_read_info));\r\nwth->priv = (void *)visual;\r\nvisual->num_pkts = pletoh32(&vfile_hdr.num_pkts);\r\nvisual->start_time = pletoh32(&vfile_hdr.start_time);\r\nvisual->current_pkt = 1;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean visual_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\nstruct visual_read_info *visual = (struct visual_read_info *)wth->priv;\r\nif (visual->current_pkt > visual->num_pkts)\r\n{\r\n*err = 0;\r\nreturn FALSE;\r\n}\r\nvisual->current_pkt++;\r\n*data_offset = file_tell(wth->fh);\r\nreturn visual_read_packet(wth, wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info);\r\n}\r\nstatic gboolean visual_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!visual_read_packet(wth, wth->random_fh, phdr, buf, err, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nvisual_read_packet(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nstruct visual_read_info *visual = (struct visual_read_info *)wth->priv;\r\nstruct visual_pkt_hdr vpkt_hdr;\r\nguint32 packet_size;\r\nstruct visual_atm_hdr vatm_hdr;\r\nguint32 relmsecs;\r\nguint32 packet_status;\r\nguint8 *pd;\r\nif (!wtap_read_bytes_or_eof(fh, &vpkt_hdr, (unsigned int)sizeof vpkt_hdr, err, err_info))\r\n{\r\nreturn FALSE;\r\n}\r\npacket_size = pletoh16(&vpkt_hdr.incl_len);\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nrelmsecs = pletoh32(&vpkt_hdr.ts_delta);\r\nphdr->ts.secs = visual->start_time + relmsecs/1000;\r\nphdr->ts.nsecs = (relmsecs % 1000)*1000000;\r\nphdr->len = pletoh16(&vpkt_hdr.orig_len);\r\npacket_status = pletoh32(&vpkt_hdr.status);\r\nswitch (wth->file_encap)\r\n{\r\ncase WTAP_ENCAP_ETHERNET:\r\nif (phdr->len < 4)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("visual: Ethernet packet has %u-byte original packet, less than the FCS length",\r\nphdr->len);\r\nreturn FALSE;\r\n}\r\nphdr->len -= 4;\r\nphdr->pseudo_header.eth.fcs_len = -1;\r\nbreak;\r\ncase WTAP_ENCAP_CHDLC_WITH_PHDR:\r\nif (phdr->len < 2)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("visual: Cisco HDLC packet has %u-byte original packet, less than the FCS length",\r\nphdr->len);\r\nreturn FALSE;\r\n}\r\nphdr->len -= 2;\r\nphdr->pseudo_header.p2p.sent = (packet_status & PS_SENT) ? TRUE : FALSE;\r\nbreak;\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\nphdr->pseudo_header.p2p.sent = (packet_status & PS_SENT) ? TRUE : FALSE;\r\nbreak;\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\nif (phdr->len < 2)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("visual: Frame Relay packet has %u-byte original packet, less than the FCS length",\r\nphdr->len);\r\nreturn FALSE;\r\n}\r\nphdr->len -= 2;\r\nphdr->pseudo_header.x25.flags =\r\n(packet_status & PS_SENT) ? 0x00 : FROM_DCE;\r\nbreak;\r\ncase WTAP_ENCAP_LAPB:\r\nif (phdr->len < 2)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("visual: Frame Relay packet has %u-byte original packet, less than the FCS length",\r\nphdr->len);\r\nreturn FALSE;\r\n}\r\nphdr->len -= 2;\r\nphdr->pseudo_header.x25.flags =\r\n(packet_status & PS_SENT) ? 0x00 : FROM_DCE;\r\nbreak;\r\ncase WTAP_ENCAP_ATM_PDUS:\r\nif (!wtap_read_bytes(fh, &vatm_hdr, (unsigned int)sizeof vatm_hdr, err, err_info))\r\n{\r\nreturn FALSE;\r\n}\r\npacket_size -= (guint32)sizeof vatm_hdr;\r\nphdr->pseudo_header.atm.type = TRAF_UNKNOWN;\r\nphdr->pseudo_header.atm.subtype = TRAF_ST_UNKNOWN;\r\nphdr->pseudo_header.atm.aal5t_len = 0;\r\nphdr->pseudo_header.atm.aal5t_u2u = 0;\r\nphdr->pseudo_header.atm.aal5t_chksum = 0;\r\nphdr->pseudo_header.atm.flags = 0;\r\nphdr->pseudo_header.atm.aal2_cid = 0;\r\nswitch(vatm_hdr.category & VN_CAT_TYPE_MASK )\r\n{\r\ncase VN_AAL1:\r\nphdr->pseudo_header.atm.aal = AAL_1;\r\nbreak;\r\ncase VN_AAL2:\r\nphdr->pseudo_header.atm.aal = AAL_2;\r\nbreak;\r\ncase VN_AAL34:\r\nphdr->pseudo_header.atm.aal = AAL_3_4;\r\nbreak;\r\ncase VN_AAL5:\r\nphdr->pseudo_header.atm.aal = AAL_5;\r\nphdr->pseudo_header.atm.type = TRAF_LLCMX;\r\nphdr->pseudo_header.atm.aal5t_len = pntoh32(&vatm_hdr.data_length);\r\nbreak;\r\ncase VN_OAM:\r\ncase VN_O191:\r\ncase VN_IDLE:\r\ncase VN_RM:\r\nphdr->pseudo_header.atm.aal = AAL_OAMCELL;\r\nbreak;\r\ncase VN_UNKNOWN:\r\ndefault:\r\nphdr->pseudo_header.atm.aal = AAL_UNKNOWN;\r\nbreak;\r\n}\r\nphdr->pseudo_header.atm.vpi = pntoh16(&vatm_hdr.vpi) & 0x0FFF;\r\nphdr->pseudo_header.atm.vci = pntoh16(&vatm_hdr.vci);\r\nphdr->pseudo_header.atm.cells = pntoh16(&vatm_hdr.cell_count);\r\nphdr->pseudo_header.atm.channel = vatm_hdr.info & FROM_NETWORK;\r\nbreak;\r\ncase WTAP_ENCAP_TOKEN_RING:\r\ndefault:\r\nbreak;\r\n}\r\nphdr->caplen = packet_size;\r\nif (packet_size > WTAP_MAX_PACKET_SIZE)\r\n{\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("visual: File has %u-byte packet, bigger than maximum of %u",\r\npacket_size, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nif (!wtap_read_packet_bytes(fh, buf, packet_size, err, err_info))\r\nreturn FALSE;\r\nif (wth->file_encap == WTAP_ENCAP_CHDLC_WITH_PHDR)\r\n{\r\npd = ws_buffer_start_ptr(buf);\r\nif (vpkt_hdr.encap_hint == 14)\r\n{\r\nif (packet_size >= 3 &&\r\n(0xfe == pd[0]) && (0xfe == pd[1]) && (0x03 == pd[2]))\r\n{\r\nphdr->pkt_encap = WTAP_ENCAP_ATM_RFC1483;\r\n}\r\nelse\r\n{\r\nphdr->pkt_encap = WTAP_ENCAP_PPP_WITH_PHDR;\r\n}\r\n}\r\nelse\r\n{\r\nif (packet_size >= 2 && (0xff == pd[0]) && (0x03 == pd[1]))\r\n{\r\nphdr->pkt_encap = WTAP_ENCAP_PPP_WITH_PHDR;\r\n}\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nint visual_dump_can_write_encap(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nswitch (encap)\r\n{\r\ncase WTAP_ENCAP_ETHERNET:\r\ncase WTAP_ENCAP_TOKEN_RING:\r\ncase WTAP_ENCAP_LAPB:\r\ncase WTAP_ENCAP_CHDLC_WITH_PHDR:\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\ncase WTAP_ENCAP_PPP:\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\nreturn 0;\r\n}\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\ngboolean visual_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nstruct visual_write_info *visual;\r\nwdh->subtype_write = visual_dump;\r\nwdh->subtype_finish = visual_dump_finish;\r\nvisual = (struct visual_write_info *)g_malloc(sizeof(struct visual_write_info));\r\nwdh->priv = (void *)visual;\r\nvisual->index_table_index = 0;\r\nvisual->index_table_size = 1024;\r\nvisual->index_table = 0;\r\nvisual->next_offset = CAPTUREFILE_HEADER_SIZE;\r\nif (wtap_dump_file_seek(wdh, CAPTUREFILE_HEADER_SIZE, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean visual_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nstruct visual_write_info * visual = (struct visual_write_info *)wdh->priv;\r\nstruct visual_pkt_hdr vpkt_hdr;\r\nsize_t hdr_size = sizeof vpkt_hdr;\r\nguint delta_msec;\r\nguint32 packet_status;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nif (visual == 0)\r\nreturn FALSE;\r\nmemset(&vpkt_hdr, 0, hdr_size);\r\nif (visual->index_table_index == 0)\r\n{\r\nvisual->start_time = phdr->ts.secs;\r\nvisual->index_table = (guint32 *)g_malloc(1024 * sizeof *visual->index_table);\r\nvisual->index_table_size = 1024;\r\n}\r\ndelta_msec = phdr->ts.nsecs / 1000000;\r\ndelta_msec += (guint32)((phdr->ts.secs - visual->start_time) * 1000);\r\nvpkt_hdr.ts_delta = GUINT32_TO_LE(delta_msec);\r\nvpkt_hdr.orig_len = GUINT16_TO_LE(phdr->len);\r\nvpkt_hdr.incl_len = GUINT16_TO_LE(phdr->caplen);\r\nswitch (wdh->encap)\r\n{\r\ncase WTAP_ENCAP_ETHERNET:\r\nvpkt_hdr.encap_hint = 2;\r\nbreak;\r\ncase WTAP_ENCAP_TOKEN_RING:\r\nvpkt_hdr.encap_hint = 3;\r\nbreak;\r\ncase WTAP_ENCAP_PPP:\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\nvpkt_hdr.encap_hint = 14;\r\nbreak;\r\ncase WTAP_ENCAP_CHDLC_WITH_PHDR:\r\nvpkt_hdr.encap_hint = 13;\r\nbreak;\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\nvpkt_hdr.encap_hint = 12;\r\nbreak;\r\ncase WTAP_ENCAP_LAPB:\r\ndefault:\r\nvpkt_hdr.encap_hint = 1;\r\nbreak;\r\n}\r\npacket_status = 0;\r\nswitch (wdh->encap)\r\n{\r\ncase WTAP_ENCAP_CHDLC_WITH_PHDR:\r\npacket_status |= (pseudo_header->p2p.sent ? PS_SENT : 0x00);\r\nbreak;\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\ncase WTAP_ENCAP_LAPB:\r\npacket_status |=\r\n((pseudo_header->x25.flags & FROM_DCE) ? 0x00 : PS_SENT);\r\nbreak;\r\n}\r\nvpkt_hdr.status = GUINT32_TO_LE(packet_status);\r\nif (!wtap_dump_file_write(wdh, &vpkt_hdr, hdr_size, err))\r\nreturn FALSE;\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\nif (visual->index_table_index >= visual->index_table_size)\r\n{\r\nvisual->index_table_size *= 2;\r\nvisual->index_table = (guint32 *)g_realloc(visual->index_table,\r\nvisual->index_table_size * sizeof *visual->index_table);\r\n}\r\nvisual->index_table[visual->index_table_index] = GUINT32_TO_LE(visual->next_offset);\r\nvisual->index_table_index++;\r\nvisual->next_offset += (guint32) hdr_size + phdr->caplen;\r\nreturn TRUE;\r\n}\r\nstatic gboolean visual_dump_finish(wtap_dumper *wdh, int *err)\r\n{\r\nstruct visual_write_info * visual = (struct visual_write_info *)wdh->priv;\r\nsize_t n_to_write;\r\nstruct visual_file_hdr vfile_hdr;\r\nconst char *magicp;\r\nsize_t magic_size;\r\nif (visual == 0)\r\nreturn FALSE;\r\nif (visual->index_table)\r\n{\r\nn_to_write = visual->index_table_index * sizeof *visual->index_table;\r\nif (!wtap_dump_file_write(wdh, visual->index_table, n_to_write, err))\r\n{\r\nvisual_dump_free(wdh);\r\nreturn FALSE;\r\n}\r\n}\r\nif (wtap_dump_file_seek(wdh, 0, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nmagicp = visual_magic;\r\nmagic_size = sizeof visual_magic;\r\nif (!wtap_dump_file_write(wdh, magicp, magic_size, err))\r\n{\r\nvisual_dump_free(wdh);\r\nreturn FALSE;\r\n}\r\nmemset(&vfile_hdr, '\0', sizeof vfile_hdr);\r\nvfile_hdr.num_pkts = GUINT32_TO_LE(visual->index_table_index);\r\nvfile_hdr.start_time = GUINT32_TO_LE(visual->start_time);\r\nvfile_hdr.max_length = GUINT16_TO_LE(65535);\r\nvfile_hdr.file_flags = GUINT16_TO_LE(1);\r\nvfile_hdr.file_version = GUINT16_TO_LE(1);\r\ng_strlcpy(vfile_hdr.description, "Wireshark file", 64);\r\nswitch (wdh->encap)\r\n{\r\ncase WTAP_ENCAP_ETHERNET:\r\nvfile_hdr.media_type = GUINT16_TO_LE(6);\r\nbreak;\r\ncase WTAP_ENCAP_TOKEN_RING:\r\nvfile_hdr.media_type = GUINT16_TO_LE(9);\r\nbreak;\r\ncase WTAP_ENCAP_LAPB:\r\nvfile_hdr.media_type = GUINT16_TO_LE(16);\r\nbreak;\r\ncase WTAP_ENCAP_PPP:\r\ncase WTAP_ENCAP_PPP_WITH_PHDR:\r\ncase WTAP_ENCAP_CHDLC_WITH_PHDR:\r\nvfile_hdr.media_type = GUINT16_TO_LE(22);\r\nbreak;\r\ncase WTAP_ENCAP_FRELAY_WITH_PHDR:\r\nvfile_hdr.media_type = GUINT16_TO_LE(32);\r\nbreak;\r\n}\r\nif (!wtap_dump_file_write(wdh, &vfile_hdr, sizeof vfile_hdr, err))\r\n{\r\nvisual_dump_free(wdh);\r\nreturn FALSE;\r\n}\r\nvisual_dump_free(wdh);\r\nreturn TRUE;\r\n}\r\nstatic void visual_dump_free(wtap_dumper *wdh)\r\n{\r\nstruct visual_write_info * visual = (struct visual_write_info *)wdh->priv;\r\nif (visual)\r\n{\r\nif (visual->index_table)\r\ng_free(visual->index_table);\r\n}\r\n}
