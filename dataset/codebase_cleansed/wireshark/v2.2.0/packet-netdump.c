static int\r\ndissect_netdump(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Netdump");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree) {\r\nproto_item *ti = NULL;\r\nproto_tree *netdump_tree = NULL;\r\nti = proto_tree_add_item(tree, proto_netdump, tvb, 0, -1, ENC_NA);\r\nnetdump_tree = proto_item_add_subtree(ti, ett_netdump);\r\nif (tvb_reported_length(tvb) == 24) {\r\nproto_tree_add_item(netdump_tree, hf_netdump_magic_number, tvb, 0, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(netdump_tree, hf_netdump_seq_nr, tvb, 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(netdump_tree, hf_netdump_command, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(netdump_tree, hf_netdump_from, tvb, 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(netdump_tree, hf_netdump_to, tvb, 20, 4, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item(netdump_tree, hf_netdump_version, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(netdump_tree, hf_netdump_seq_nr, tvb, 1, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(netdump_tree, hf_netdump_code, tvb, 5, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(netdump_tree, hf_netdump_info, tvb, 9, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(netdump_tree, hf_netdump_payload, tvb, 13, -1, ENC_NA);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_netdump(void)\r\n{\r\nmodule_t *netdump_module;\r\nstatic gint *ett[] = {\r\n&ett_netdump\r\n};\r\nstatic hf_register_info hf[] = {\r\n{ &hf_netdump_magic_number,\r\n{ "Netdump Magic Number", "netdump.magic",\r\nFT_UINT64, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_netdump_seq_nr,\r\n{"Netdump seq number", "netdump.seq_nr",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_netdump_command,\r\n{"Netdump command", "netdump.command",\r\nFT_UINT32, BASE_DEC,\r\nVALS(command_names), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_netdump_from,\r\n{"Netdump from val", "netdump.from",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_netdump_to,\r\n{"Netdump to val", "netdump.to",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_netdump_code,\r\n{"Netdump code", "netdump.code",\r\nFT_UINT32, BASE_DEC,\r\nVALS(reply_code_names), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_netdump_info,\r\n{"Netdump info", "netdump.info",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_netdump_payload,\r\n{"Netdump payload", "netdump.payload",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_netdump_version,\r\n{"Netdump version", "netdump.version",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n}\r\n};\r\nproto_netdump = proto_register_protocol (\r\n"Netdump Protocol",\r\n"Netdump",\r\n"netdump"\r\n);\r\nproto_register_field_array(proto_netdump, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nnetdump_module = prefs_register_protocol(proto_netdump,\r\nproto_reg_handoff_netdump);\r\nprefs_register_uint_preference(netdump_module, "udp.port",\r\n"Netdump UDP port",\r\n"port if other than the default",\r\n10, &gPORT_PREF);\r\n}\r\nvoid proto_reg_handoff_netdump(void)\r\n{\r\nstatic gboolean initalized = FALSE;\r\nstatic dissector_handle_t netdump_handle;\r\nstatic int CurrentPort;\r\nif (!initalized) {\r\nnetdump_handle = create_dissector_handle(dissect_netdump,\r\nproto_netdump);\r\ndissector_add_for_decode_as("udp.port", netdump_handle);\r\ninitalized = TRUE;\r\n} else {\r\nif (CurrentPort != 0)\r\ndissector_delete_uint("udp.port", CurrentPort, netdump_handle);\r\n}\r\nCurrentPort = gPORT_PREF;\r\nif (CurrentPort != 0)\r\ndissector_add_uint("udp.port", CurrentPort, netdump_handle);\r\n}
