static void\r\ndissect_bmp_peer_down_notification(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, int offset, gint8 flags _U_)\r\n{\r\nguint8 down_reason;\r\ndown_reason = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_peer_down_reason, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (down_reason != BMP_PEER_DOWN_REMOTE_NO_NOTIFY) {\r\nif (down_reason == BMP_PEER_DOWN_LOCAL_NO_NOTIFY) {\r\nproto_tree_add_item(tree, hf_peer_down_data, tvb, offset, 2, ENC_NA);\r\n} else {\r\ncall_dissector(dissector_bgp, tvb_new_subset_remaining(tvb, offset), pinfo, tree);\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_bmp_peer_up_notification(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, int offset, gint8 flags)\r\n{\r\nif (flags & BMP_PEER_FLAG_IPV6) {\r\nproto_tree_add_item(tree, hf_peer_up_ipv6_address, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n} else {\r\nproto_tree_add_item(tree, hf_bmp_unused, tvb, offset, 12, ENC_NA);\r\noffset += 12;\r\nproto_tree_add_item(tree, hf_peer_up_ipv4_address, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(tree, hf_peer_up_local_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_peer_up_remote_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\ncall_dissector(dissector_bgp, tvb_new_subset_remaining(tvb, offset), pinfo, tree);\r\n}\r\nstatic void\r\ndissect_bmp_stat_report(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, int offset, gint8 flags _U_)\r\n{\r\nguint16 stat_len;\r\nguint32 i;\r\nguint32 stats_count = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_stats_count, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nfor (i = 0; i < stats_count; i++) {\r\nproto_item *ti;\r\nproto_item *subtree;\r\nti = proto_tree_add_item(tree, hf_stat_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nsubtree = proto_item_add_subtree(ti, ett_bmp_stat_type);\r\noffset += 2;\r\nstat_len = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(subtree, hf_stat_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (stat_len == 4) {\r\nproto_tree_add_item(subtree, hf_stat_data_4, tvb, offset, stat_len, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item(subtree, hf_stat_data_8, tvb, offset, stat_len, ENC_BIG_ENDIAN);\r\n}\r\noffset += stat_len;\r\n}\r\n}\r\nstatic void\r\ndissect_bmp_termination(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, int offset, guint8 bmp_type _U_, guint16 len)\r\n{\r\nguint16 term_type;\r\nguint16 term_len;\r\nproto_item *ti;\r\nproto_item *subtree;\r\nti = proto_tree_add_item(tree, hf_term_types, tvb, offset, len, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_bmp_term_types);\r\nterm_type = tvb_get_ntohs(tvb, offset);\r\nproto_item_append_text(subtree, ", Type %s",\r\nval_to_str(term_type, term_typevals, "Unknown (0x%02x)"));\r\nproto_tree_add_item(subtree, hf_term_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nterm_len = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(subtree, hf_term_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (term_type == BMP_TERM_TYPE_STRING) {\r\nproto_tree_add_item(subtree, hf_term_info, tvb, offset, term_len, ENC_ASCII|ENC_NA);\r\n} else {\r\nproto_tree_add_item(subtree, hf_term_reason, tvb, offset, term_len, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_bmp_peer_header(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, int offset, guint8 bmp_type, guint16 len)\r\n{\r\nguint8 flags;\r\nproto_item *item;\r\nproto_item *ti;\r\nproto_item *subtree;\r\nstatic const int * peer_flags[] = {\r\n&hf_peer_flags_ipv6,\r\n&hf_peer_flags_post_policy,\r\n&hf_peer_flags_res,\r\nNULL\r\n};\r\nti = proto_tree_add_item(tree, hf_peer_header, tvb, offset, len, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_bmp_peer_header);\r\nproto_tree_add_item(subtree, hf_peer_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nflags = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_bitmask(subtree, tvb, offset, hf_peer_flags, ett_bmp_peer_flags, peer_flags, ENC_NA);\r\noffset += 1;\r\nitem = proto_tree_add_item(subtree, hf_peer_distinguisher, tvb, offset, 8, ENC_NA);\r\nproto_item_set_text(item, "Peer Distinguisher: %s", decode_bgp_rd(tvb, offset));\r\noffset += 8;\r\nif (flags & BMP_PEER_FLAG_IPV6) {\r\nproto_tree_add_item(subtree, hf_peer_ipv6_address, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n} else {\r\nproto_tree_add_item(subtree, hf_bmp_unused, tvb, offset, 12, ENC_NA);\r\noffset += 12;\r\nproto_tree_add_item(subtree, hf_peer_ipv4_address, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(subtree, hf_peer_asn, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(subtree, hf_peer_bgp_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(subtree, hf_peer_timestamp_sec, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(subtree, hf_peer_timestamp_msec, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nswitch (bmp_type) {\r\ncase BMP_MSG_TYPE_ROUTE_MONITORING:\r\ncall_dissector(dissector_bgp, tvb_new_subset_remaining(tvb, offset), pinfo, tree);\r\nbreak;\r\ncase BMP_MSG_TYPE_STAT_REPORT:\r\ndissect_bmp_stat_report(tvb, tree, pinfo, offset, flags);\r\nbreak;\r\ncase BMP_MSG_TYPE_PEER_DOWN:\r\ndissect_bmp_peer_down_notification(tvb, tree, pinfo, offset, flags);\r\nbreak;\r\ncase BMP_MSG_TYPE_PEER_UP:\r\ndissect_bmp_peer_up_notification(tvb, tree, pinfo, offset, flags);\r\nbreak;\r\ncase BMP_MSG_TYPE_INIT:\r\ncase BMP_MSG_TYPE_TERM:\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndissect_bmp_init(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, int offset, guint8 bmp_type _U_, guint16 len)\r\n{\r\nguint16 init_type;\r\nguint16 init_len;\r\nproto_tree *pti;\r\nproto_tree *parent_tree;\r\npti = proto_tree_add_item(tree, hf_init_types, tvb, offset, len, ENC_NA);\r\nparent_tree = proto_item_add_subtree(pti, ett_bmp_init_types);\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree *ti;\r\nproto_tree *subtree;\r\ninit_type = tvb_get_ntohs(tvb, offset);\r\nproto_item_append_text(pti, ", Type %s",\r\nval_to_str(init_type, init_typevals, "Unknown (0x%02x)"));\r\nti = proto_tree_add_item(parent_tree, hf_init_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nsubtree = proto_item_add_subtree(ti, ett_bmp_init_type);\r\noffset += 2;\r\ninit_len = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(subtree, hf_init_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_init_info, tvb, offset, init_len, ENC_ASCII|ENC_NA);\r\noffset += init_len;\r\n}\r\n}\r\nstatic guint\r\nget_bmp_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nreturn tvb_get_ntohl(tvb, offset + 1);\r\n}\r\nstatic int\r\ndissect_bmp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nguint8 bmp_type;\r\nguint16 len;\r\ngint arg;\r\nproto_item *ti;\r\nproto_item *bmp_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "BMP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nbmp_type = tvb_get_guint8(tvb, 5);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Type: %s",\r\nval_to_str(bmp_type, bmp_typevals, "Unknown (0x%02x)"));\r\nti = proto_tree_add_item(tree, proto_bmp, tvb, 0, -1, ENC_NA);\r\nproto_item_append_text(ti, ", Type %s",\r\nval_to_str(bmp_type, bmp_typevals, "Unknown (0x%02x)"));\r\nswitch (bmp_type) {\r\ncase BMP_MSG_TYPE_ROUTE_MONITORING:\r\narg = ett_bmp_route_monitoring;\r\nbreak;\r\ncase BMP_MSG_TYPE_STAT_REPORT:\r\narg = ett_bmp_stat_report;\r\nbreak;\r\ncase BMP_MSG_TYPE_PEER_DOWN:\r\narg = ett_bmp_peer_down;\r\nbreak;\r\ncase BMP_MSG_TYPE_PEER_UP:\r\narg = ett_bmp_peer_up;\r\nbreak;\r\ncase BMP_MSG_TYPE_INIT:\r\narg = ett_bmp_init;\r\nbreak;\r\ncase BMP_MSG_TYPE_TERM:\r\narg = ett_bmp_term;\r\nbreak;\r\ndefault:\r\narg = ett_bmp;\r\nbreak;\r\n}\r\nbmp_tree = proto_item_add_subtree(ti, arg);\r\nproto_tree_add_item(bmp_tree, hf_bmp_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(bmp_tree, hf_bmp_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(bmp_tree, hf_bmp_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nlen = tvb_get_ntohs(tvb, offset);\r\nswitch (bmp_type) {\r\ncase BMP_MSG_TYPE_INIT:\r\ndissect_bmp_init(tvb, bmp_tree, pinfo, offset, bmp_type, len);\r\nbreak;\r\ncase BMP_MSG_TYPE_ROUTE_MONITORING:\r\ncase BMP_MSG_TYPE_STAT_REPORT:\r\ncase BMP_MSG_TYPE_PEER_DOWN:\r\ncase BMP_MSG_TYPE_PEER_UP:\r\ndissect_bmp_peer_header(tvb, bmp_tree, pinfo, offset, bmp_type, len);\r\nbreak;\r\ncase BMP_MSG_TYPE_TERM:\r\ndissect_bmp_termination(tvb, bmp_tree, pinfo, offset, bmp_type, len);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_bmp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, bmp_desegment, FRAME_HEADER_LEN, get_bmp_pdu_len, dissect_bmp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_bmp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_bmp_version,\r\n{ "Version", "bmp.version", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_bmp_length,\r\n{ "Length", "bmp.length", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_bmp_type,\r\n{ "Type", "bmp.type", FT_UINT8, BASE_DEC,\r\nVALS(bmp_typevals), 0x0, "BMP message type", HFILL }},\r\n{ &hf_bmp_unused,\r\n{ "Unused", "bmp.unused", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_init_types,\r\n{ "Information Types", "bmp.init.types", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_init_type,\r\n{ "Type", "bmp.init.type", FT_UINT16, BASE_DEC,\r\nVALS(init_typevals), 0x0, "Initiation type", HFILL }},\r\n{ &hf_init_length,\r\n{ "Length", "bmp.init.length", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_init_info,\r\n{ "Information", "bmp.init.info", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_header,\r\n{ "Per Peer Header", "bmp.peer.header", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_type,\r\n{ "Type", "bmp.peer.type", FT_UINT8, BASE_DEC,\r\nVALS(peer_typevals), 0x0, NULL, HFILL }},\r\n{ &hf_peer_flags,\r\n{ "Flags", "bmp.peer.flags", FT_UINT8, BASE_HEX,\r\nNULL, BMP_PEER_FLAG_MASK, NULL, HFILL }},\r\n{ &hf_peer_flags_ipv6,\r\n{ "IPv6", "bmp.peer.flags.ipv6", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), BMP_PEER_FLAG_IPV6, NULL, HFILL }},\r\n{ &hf_peer_flags_post_policy,\r\n{ "Post-policy", "bmp.peer.flags.post_policy", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), BMP_PEER_FLAG_POST_POLICY, NULL, HFILL }},\r\n{ &hf_peer_flags_res,\r\n{ "Reserved", "bmp.peer.flags.reserved", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), BMP_PEER_FLAG_RES, NULL, HFILL }},\r\n{ &hf_peer_distinguisher,\r\n{ "Peer Distinguisher", "bmp.peer.distinguisher", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_ipv4_address,\r\n{ "Address", "bmp.peer.ip.addr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_ipv6_address,\r\n{ "Address", "bmp.peer.ipv6.addr", FT_IPv6, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_asn,\r\n{ "ASN", "bmp.peer.asn", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_bgp_id,\r\n{ "BGP ID", "bmp.peer.id", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_timestamp_sec,\r\n{ "Timestamp (sec)", "bmp.peer.timestamp.sec", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_timestamp_msec,\r\n{ "Timestamp (msec)", "bmp.peer.timestamp.msec", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_up_ipv4_address,\r\n{ "Local Address", "bmp.peer.up.ip.addr", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_up_ipv6_address,\r\n{ "Local Address", "bmp.peer.up.ipv6.addr", FT_IPv6, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_up_local_port,\r\n{ "Local Port", "bmp.peer.up.port.local", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_up_remote_port,\r\n{ "Remote Port", "bmp.peer.up.port.remote", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_peer_down_reason,\r\n{ "Reason", "bmp.peer.down.reason", FT_UINT8, BASE_DEC,\r\nVALS(down_reason_typevals), 0x0, NULL, HFILL }},\r\n{ &hf_peer_down_data,\r\n{ "Data", "bmp.peer.down.data", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_stats_count,\r\n{ "Stats Count", "bmp.stats.count", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_stat_type,\r\n{ "Type", "bmp.stats.type", FT_UINT16, BASE_DEC,\r\nVALS(stat_typevals), 0x0, NULL, HFILL }},\r\n{ &hf_stat_len,\r\n{ "Length", "bmp.stats.length", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_stat_data_4,\r\n{ "Data", "bmp.stats.data.4byte", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_stat_data_8,\r\n{ "Data", "bmp.stats.data.8byte", FT_UINT64, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_term_types,\r\n{ "Termination Types", "bmp.term.types", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_term_type,\r\n{ "Type", "bmp.term.type", FT_UINT16, BASE_DEC,\r\nVALS(term_typevals), 0x0, NULL, HFILL }},\r\n{ &hf_term_len,\r\n{ "Length", "bmp.term.length", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_term_info,\r\n{ "Information", "bmp.term.info", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_term_reason,\r\n{ "Reason", "bmp.term.reason", FT_UINT16, BASE_DEC,\r\nVALS(term_reason_typevals), 0x0, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_bmp,\r\n&ett_bmp_route_monitoring,\r\n&ett_bmp_stat_report,\r\n&ett_bmp_stat_type,\r\n&ett_bmp_peer_down,\r\n&ett_bmp_peer_up,\r\n&ett_bmp_peer_header,\r\n&ett_bmp_peer_flags,\r\n&ett_bmp_init,\r\n&ett_bmp_init_type,\r\n&ett_bmp_init_types,\r\n&ett_bmp_term,\r\n&ett_bmp_term_type,\r\n&ett_bmp_term_types,\r\n};\r\nmodule_t *bmp_module;\r\nproto_bmp = proto_register_protocol(\r\n"BGP Monitoring Protocol",\r\n"BMP",\r\n"bmp"\r\n);\r\nproto_register_field_array(proto_bmp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nbmp_module = prefs_register_protocol(proto_bmp, NULL);\r\nprefs_register_bool_preference(bmp_module, "desegment",\r\n"Reassemble BMP messages spanning multiple TCP segments",\r\n"Whether the BMP dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&bmp_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_bmp(void)\r\n{\r\nstatic dissector_handle_t bmp_handle;\r\nbmp_handle = create_dissector_handle(dissect_bmp, proto_bmp);\r\ndissector_add_for_decode_as("tcp.port", bmp_handle);\r\ndissector_bgp = find_dissector_add_dependency("bgp", proto_bmp);\r\n}
