static const char *\r\nformat_address(const unsigned char *prefix)\r\n{\r\naddress addr;\r\nif (prefix == NULL)\r\nreturn "corrupt";\r\nelse if (memcmp(prefix, v4prefix, 12) == 0)\r\n{\r\naddr.type = AT_IPv4;\r\naddr.len = 4;\r\naddr.data = prefix + 12;\r\nreturn address_to_str(wmem_packet_scope(), &addr);\r\n}\r\nelse\r\n{\r\naddr.type = AT_IPv6;\r\naddr.len = 16;\r\naddr.data = prefix;\r\nreturn address_to_str(wmem_packet_scope(), &addr);\r\n}\r\n}\r\nstatic const char *\r\nformat_prefix(const unsigned char *prefix, unsigned char plen)\r\n{\r\nreturn wmem_strdup_printf(wmem_packet_scope(), "%s/%u", format_address(prefix), plen);\r\n}\r\nstatic int\r\nnetwork_prefix(int ae, int plen, unsigned int omitted,\r\ntvbuff_t *tvb, int offset, const unsigned char *dp,\r\nunsigned int len, unsigned char *p_r)\r\n{\r\nguint pb;\r\nunsigned char prefix[16];\r\nif (plen >= 0)\r\npb = (plen + 7) / 8;\r\nelse if (ae == 1)\r\npb = 4;\r\nelse\r\npb = 16;\r\nif (pb > 16)\r\nreturn -1;\r\nmemset(prefix, 0, 16);\r\nswitch(ae) {\r\ncase 0: break;\r\ncase 1:\r\nif (omitted > 4 || pb > 4 || (pb > omitted && len < pb - omitted))\r\nreturn -1;\r\nmemcpy(prefix, v4prefix, 12);\r\nif (omitted) {\r\nif (dp == NULL) return -1;\r\nmemcpy(prefix, dp, 12 + omitted);\r\n}\r\nif (pb > omitted)\r\ntvb_memcpy(tvb, prefix + 12 + omitted, offset, pb - omitted);\r\nbreak;\r\ncase 2:\r\nif (omitted > 16 || (pb > omitted && len < pb - omitted))\r\nreturn -1;\r\nif (omitted) {\r\nif (dp == NULL) return -1;\r\nmemcpy(prefix, dp, omitted);\r\n}\r\nif (pb > omitted)\r\ntvb_memcpy(tvb, prefix + omitted, offset, pb - omitted);\r\nbreak;\r\ncase 3:\r\nif (pb > 8 && len < pb - 8) return -1;\r\nprefix[0] = 0xfe;\r\nprefix[1] = 0x80;\r\nif (pb > 8)\r\ntvb_memcpy(tvb, prefix + 8, offset, pb - 8);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nmemcpy(p_r, prefix, 16);\r\nreturn 1;\r\n}\r\nstatic int\r\nnetwork_address(int ae, tvbuff_t *tvb, int offset, unsigned int len,\r\nunsigned char *a_r)\r\n{\r\nreturn network_prefix(ae, -1, 0, tvb, offset, NULL, len, a_r);\r\n}\r\nstatic int\r\ndissect_babel(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nunsigned char v4_prefix[16] = {0}, v6_prefix[16] = {0};\r\nint i;\r\nproto_tree *babel_tree = NULL;\r\nguint8 version;\r\nguint16 bodylen;\r\nif (tvb_captured_length(tvb) < 4)\r\nreturn 0;\r\nif (tvb_get_guint8(tvb, 0) != 42)\r\nreturn 0;\r\nversion = tvb_get_guint8(tvb, 1);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Babel");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Babel");\r\nif (version != 2) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Version %u", version);\r\nreturn 2;\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_babel, tvb, 0, -1, ENC_NA);\r\nbabel_tree = proto_item_add_subtree(ti, ett_babel);\r\nproto_tree_add_item(babel_tree, hf_babel_magic, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(babel_tree, hf_babel_version, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(babel_tree, hf_babel_bodylen,\r\ntvb, 2, 2, ENC_BIG_ENDIAN);\r\n}\r\nbodylen = tvb_get_ntohs(tvb, 2);\r\ni = 0;\r\nwhile (i < bodylen) {\r\nguint8 type, len = 0, total_length;\r\nproto_tree *message_tree = NULL;\r\nint message = 4 + i;\r\ntype = tvb_get_guint8(tvb, message);\r\nif (type == MESSAGE_PAD1)\r\ntotal_length = 1;\r\nelse {\r\nlen = tvb_get_guint8(tvb, message + 1);\r\ntotal_length = len + 2;\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s",\r\nval_to_str_const(type, messages, "unknown"));\r\nti = proto_tree_add_uint_format(babel_tree, hf_babel_message,\r\ntvb, message, total_length, type,\r\n"Message %s (%u)",\r\nval_to_str_const(type, messages, "unknown"),\r\ntype);\r\nif (tree) {\r\nmessage_tree = proto_item_add_subtree(ti, ett_message);\r\nproto_tree_add_item(message_tree, hf_babel_message_type,\r\ntvb, message, 1, ENC_BIG_ENDIAN);\r\n}\r\nif (type == MESSAGE_PAD1) {\r\ni++;\r\ncontinue;\r\n}\r\nif (tree) {\r\nproto_tree_add_item(message_tree, hf_babel_message_length,\r\ntvb, message + 1, 1, ENC_BIG_ENDIAN);\r\nif (type == MESSAGE_PADN) {\r\n} else if (type == MESSAGE_ACK_REQ) {\r\nproto_tree_add_item(message_tree, hf_babel_message_nonce,\r\ntvb, message + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_babel_message_interval,\r\ntvb, message + 6, 2, ENC_BIG_ENDIAN);\r\n} else if (type == MESSAGE_ACK) {\r\nproto_tree_add_item(message_tree, hf_babel_message_nonce,\r\ntvb, message + 2, 2, ENC_BIG_ENDIAN);\r\n} else if (type == MESSAGE_HELLO) {\r\nproto_tree_add_item(message_tree, hf_babel_message_seqno,\r\ntvb, message + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_babel_message_interval,\r\ntvb, message + 6, 2, ENC_BIG_ENDIAN);\r\n} else if (type == MESSAGE_IHU) {\r\nproto_tree *subtree;\r\nunsigned char addr_str[16];\r\nint rc =\r\nnetwork_address(tvb_get_guint8(tvb, message + 2),\r\ntvb, message + 8, len - 6, addr_str);\r\nproto_tree_add_item(message_tree, hf_babel_message_rxcost,\r\ntvb, message + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_babel_message_interval,\r\ntvb, message + 6, 2, ENC_BIG_ENDIAN);\r\nsubtree = proto_tree_add_subtree_format(message_tree,\r\ntvb, message + 4, len - 2,\r\nett_subtree, NULL, "Address: %s",\r\nformat_address(rc < 0 ?\r\nNULL : addr_str));\r\nproto_tree_add_item(subtree, hf_babel_message_ae,\r\ntvb, message + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_babel_message_prefix,\r\ntvb, message + 4, len - 2, ENC_NA);\r\n} else if (type == MESSAGE_ROUTER_ID) {\r\nproto_tree_add_item(message_tree, hf_babel_message_routerid,\r\ntvb, message + 4, 8, ENC_NA);\r\n} else if (type == MESSAGE_NH) {\r\nproto_tree *subtree;\r\nunsigned char nh[16];\r\nint rc =\r\nnetwork_address(tvb_get_guint8(tvb, message + 2),\r\ntvb, message + 4, len - 2, nh);\r\nsubtree = proto_tree_add_subtree_format(message_tree,\r\ntvb, message + 4, len - 2,\r\nett_subtree, NULL,\r\n"NH: %s",\r\nformat_address(rc < 0 ? NULL : nh));\r\nproto_tree_add_item(subtree, hf_babel_message_ae,\r\ntvb, message + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_babel_message_prefix,\r\ntvb, message + 4, len - 2, ENC_NA);\r\n} else if (type == MESSAGE_UPDATE) {\r\nproto_tree *subtree;\r\nunsigned char p[16];\r\nguint8 ae = tvb_get_guint8(tvb, message + 2);\r\nguint8 flags = tvb_get_guint8(tvb, message + 3);\r\nguint8 plen = tvb_get_guint8(tvb, message + 4);\r\nint rc =\r\nnetwork_prefix(ae, plen,\r\ntvb_get_guint8(tvb, message + 5),\r\ntvb, message + 12,\r\nae == 1 ? v4_prefix : v6_prefix,\r\nlen - 10, p);\r\nif (rc >= 0 && (flags & 0x80)) {\r\nif (ae == 1)\r\nmemcpy(v4_prefix, p, 16);\r\nelse\r\nmemcpy(v6_prefix, p, 16);\r\n}\r\nproto_tree_add_item(message_tree, hf_babel_message_flags,\r\ntvb, message + 3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_babel_message_interval,\r\ntvb, message + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_babel_message_seqno,\r\ntvb, message + 8, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_babel_message_metric,\r\ntvb, message + 10, 2, ENC_BIG_ENDIAN);\r\nsubtree = proto_tree_add_subtree_format(message_tree,\r\ntvb, message + 12, len - 10,\r\nett_subtree, NULL,\r\n"Prefix: %s",\r\nformat_prefix(rc < 0 ? NULL : p,\r\nplen));\r\nproto_tree_add_item(subtree, hf_babel_message_ae,\r\ntvb, message + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_babel_message_plen,\r\ntvb, message + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_babel_message_omitted,\r\ntvb, message + 5, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_babel_message_prefix,\r\ntvb, message + 12, len - 10, ENC_NA);\r\n} else if (type == MESSAGE_REQUEST) {\r\nproto_tree *subtree;\r\nunsigned char p[16];\r\nguint8 plen = tvb_get_guint8(tvb, message + 3);\r\nint rc =\r\nnetwork_prefix(tvb_get_guint8(tvb, message + 2), plen,\r\n0, tvb, message + 4, NULL,\r\nlen - 2, p);\r\nsubtree = proto_tree_add_subtree_format(message_tree,\r\ntvb, message + 4, len - 2,\r\nett_subtree, NULL,\r\n"Prefix: %s",\r\nformat_prefix(rc < 0 ? NULL : p,\r\nplen));\r\nproto_tree_add_item(subtree, hf_babel_message_ae,\r\ntvb, message + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_babel_message_plen,\r\ntvb, message + 3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_babel_message_prefix,\r\ntvb, message + 4, len - 2, ENC_NA);\r\n} else if (type == MESSAGE_MH_REQUEST) {\r\nproto_tree *subtree;\r\nunsigned char p[16];\r\nguint8 plen = tvb_get_guint8(tvb, message + 3);\r\nint rc =\r\nnetwork_prefix(tvb_get_guint8(tvb, message + 2), plen,\r\n0, tvb, message + 16, NULL,\r\nlen - 14, p);\r\nproto_tree_add_item(message_tree, hf_babel_message_seqno,\r\ntvb, message + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_babel_message_hopcount,\r\ntvb, message + 6, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_babel_message_routerid,\r\ntvb, message + 8, 8, ENC_NA);\r\nsubtree = proto_tree_add_subtree_format(message_tree,\r\ntvb, message + 16, len - 14,\r\nett_subtree, NULL,\r\n"Prefix: %s",\r\nformat_prefix(rc < 0 ? NULL : p,\r\nplen));\r\nproto_tree_add_item(subtree, hf_babel_message_ae,\r\ntvb, message + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_babel_message_plen,\r\ntvb, message + 3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_babel_message_prefix,\r\ntvb, message + 16, len - 14, ENC_NA);\r\n}\r\n}\r\ni += len + 2;\r\n}\r\nreturn i;\r\n}\r\nvoid\r\nproto_register_babel(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_babel_magic,\r\n{ "Magic", "babel.magic", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Magic value 42", HFILL }\r\n},\r\n{ &hf_babel_version,\r\n{ "Version", "babel.version", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Version of the Babel protocol", HFILL }\r\n},\r\n{ &hf_babel_bodylen,\r\n{ "Body Length", "babel.bodylen", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message,\r\n{ "Message", "babel.message", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Babel Message", HFILL }\r\n},\r\n{ &hf_babel_message_type,\r\n{ "Message Type", "babel.message.type", FT_UINT8, BASE_DEC,\r\nVALS(messages), 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_length,\r\n{ "Message Length", "babel.message.length", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_nonce,\r\n{ "Nonce", "babel.message.nonce", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_interval,\r\n{ "Interval", "babel.message.interval", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Interval (in centiseconds)", HFILL }\r\n},\r\n{ &hf_babel_message_seqno,\r\n{ "Seqno", "babel.message.seqno", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_ae,\r\n{ "Address Encoding", "babel.message.ae", FT_UINT8, BASE_DEC,\r\nVALS(aes), 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_prefix,\r\n{ "Raw Prefix", "babel.message.prefix", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_rxcost,\r\n{ "Rxcost", "babel.message.rxcost", FT_UINT16, BASE_HEX,\r\nNULL, 0, "Rxcost (from the point of vue of the sender)", HFILL }\r\n},\r\n{ &hf_babel_message_routerid,\r\n{ "Router ID", "babel.message.routerid", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_flags,\r\n{ "Flags", "babel.message.flags", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_plen,\r\n{ "Prefix Length", "babel.message.plen", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_omitted,\r\n{ "Omitted Bytes", "babel.message.omitted", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Number of bytes omitted from the prefix", HFILL }\r\n},\r\n{ &hf_babel_message_metric,\r\n{ "Metric", "babel.message.metric", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_babel_message_hopcount,\r\n{ "Hop Count", "babel.message.hopcount", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_babel,\r\n&ett_message,\r\n&ett_subtree,\r\n};\r\nproto_babel =\r\nproto_register_protocol("Babel Routing Protocol", "Babel", "babel");\r\nproto_register_field_array(proto_babel, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_babel(void)\r\n{\r\ndissector_handle_t babel_handle;\r\nbabel_handle = create_dissector_handle(dissect_babel, proto_babel);\r\ndissector_add_uint("udp.port", UDP_PORT_BABEL, babel_handle);\r\ndissector_add_uint("udp.port", UDP_PORT_BABEL_OLD, babel_handle);\r\n}
