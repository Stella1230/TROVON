static guint dissect_one_tlv(tvbuff_t *tvb, proto_tree *tree,\r\nguint offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *tlv_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_pp_tlv, &ti, "Property");\r\nguint len;\r\nguint pad_len;\r\nguint type = tvb_get_ntohs(tvb, offset);\r\nconst char *name = val_to_str_ext(type, &pp_pid_vals_ext, TYPE_UNKNOWN);\r\nproto_item_append_text(ti, " : %s", name);\r\nproto_tree_add_item(tlv_tree, hf_pp_pid_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nlen = tvb_get_ntohs(tvb, offset);\r\nproto_item_set_len(ti, 4 + len);\r\nproto_tree_add_item(tlv_tree, hf_pp_pid_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tlv_tree, hf_pp_pid_value, tvb, offset, len, ENC_NA);\r\noffset += len;\r\npad_len = ~(offset-1) & 3;\r\nif(pad_len)\r\n{\r\nproto_tree_add_item(tlv_tree, hf_pp_pid_pad_bytes, tvb, offset, pad_len, ENC_NA);\r\noffset += pad_len;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint\r\ndissect_multiple_tlvs(tvbuff_t *tvb, proto_item *ti,\r\nguint offset, guint len)\r\n{\r\nguint end = offset + len;\r\nwhile(offset < end) {\r\noffset = dissect_one_tlv(tvb, ti, offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic guint\r\ndissect_multiple_get_pids(tvbuff_t *tvb, proto_item *tree, guint offset, guint len)\r\n{\r\nguint end = offset + len;\r\nwhile(offset < end)\r\n{\r\nproto_tree_add_item(tree, hf_pp_get_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nreturn len;\r\n}\r\nstatic guint\r\ndissect_data_payload(tvbuff_t *tvb, proto_item *tree, guint offset, guint len)\r\n{\r\nguint end = offset + len;\r\nguint blklen = 0;\r\nguint xdmx, stc;\r\nwhile(offset < end)\r\n{\r\nproto_item *ti;\r\nproto_tree *data_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_pp_data, &ti, "xDMX Data: ");\r\nproto_tree_add_item(data_tree, hf_pp_data_encoding, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nblklen = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(data_tree, hf_pp_data_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(data_tree, hf_pp_reserved, tvb, offset++, 1, ENC_NA);\r\nstc = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(data_tree, hf_pp_data_start_code, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nxdmx = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(data_tree, hf_pp_data_dst, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(data_tree, hf_pp_data_levels, tvb, offset, blklen, ENC_NA);\r\nproto_item_append_text(ti, "%d Channels at xDMX %d (Univ %d.%d) StartCode: %d ", blklen, xdmx, xdmx / 512 + 1, xdmx % 512, stc);\r\noffset += roof4(blklen);\r\n}\r\nreturn len;\r\n}\r\nstatic guint\r\ndissect_arp_reply(tvbuff_t *tvb, proto_tree *tree, guint offset, guint len)\r\n{\r\nproto_tree_add_item(tree, hf_pp_arp_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pp_arp_ip, tvb, offset, 4, ENC_NA);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pp_arp_manuf, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_pp_arp_class, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_pp_arp_type, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_pp_arp_numdmx, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nreturn len;\r\n}\r\nstatic guint\r\ndissect_one_pdu(tvbuff_t *tvb, proto_tree *tree, guint offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *pdu_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_pp_pdu, &ti, "PDU");\r\nguint len;\r\nguint type = tvb_get_ntohs(tvb, offset);\r\nconst char *name = val_to_str(type, pp_pdu_vals, TYPE_UNKNOWN);\r\nproto_item_append_text(ti, " : %s", name);\r\nproto_tree_add_item(pdu_tree, hf_pp_pdu_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nlen = tvb_get_ntohs(tvb, offset);\r\nproto_item_set_len(ti, 4 + len);\r\nproto_tree_add_item(pdu_tree, hf_pp_pdu_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nswitch(type)\r\n{\r\ncase PP_ARP_REPLY :\r\ndissect_arp_reply(tvb, pdu_tree, offset, len);\r\nbreak;\r\ncase PP_GET :\r\ndissect_multiple_get_pids(tvb, pdu_tree, offset, len);\r\nbreak;\r\ncase PP_SET :\r\ncase PP_GET_REPLY :\r\ncase PP_ARP_INFO :\r\ndissect_multiple_tlvs(tvb, pdu_tree, offset, len);\r\nbreak;\r\ncase PP_DATA :\r\ndissect_data_payload(tvb, pdu_tree, offset, len);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(pdu_tree, hf_pp_pdu_payload, tvb, offset, len, ENC_NA);\r\nbreak;\r\n}\r\noffset += roof4(len);\r\nreturn offset;\r\n}\r\nstatic guint\r\ndissect_multiple_pdus(tvbuff_t *tvb, proto_item *ti,\r\nguint offset, guint len)\r\n{\r\nguint end = offset + len;\r\nwhile(offset < end) {\r\noffset = dissect_one_pdu(tvb, ti, offset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_header(tvbuff_t *tvb, proto_tree *parent, guint offset)\r\n{\r\nproto_tree *tree = proto_tree_add_subtree(parent, tvb, offset, PATHPORT_HEADER_LENGTH, ett_pathport, NULL, "Header");\r\nproto_tree_add_item(tree, hf_pp_prot, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pp_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pp_seq, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_pp_reserved, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(tree, hf_pp_src, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_pp_dst, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic gboolean\r\npacket_is_pathport(tvbuff_t *tvb)\r\n{\r\nif(tvb_captured_length(tvb) < PATHPORT_MIN_LENGTH)\r\nreturn FALSE;\r\nif(tvb_get_ntohs(tvb, 0) != PATHPORT_PROTO_MAGIC)\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic const char *\r\nresolve_pp_id(guint32 id)\r\n{\r\nreturn val_to_str(id, ednet_id_vals, "%X");\r\n}\r\nstatic int dissect_pathport_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *pathport_tree;\r\nguint offset = 0;\r\nguint remaining_len;\r\nguint len;\r\nguint16 type;\r\nguint32 srcid;\r\nguint32 dstid;\r\nlen = tvb_reported_length(tvb);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Pathport");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nsrcid = tvb_get_ntohl(tvb, PATHPORT_HEADER_SRCID_OFFSET);\r\ntype = tvb_get_ntohs(tvb, PATHPORT_HEADER_LENGTH);\r\nif(type == PP_ARP_REQUEST)\r\n{\r\ndstid = tvb_get_ntohl(tvb, PATHPORT_HEADER_DSTID_OFFSET);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Who has %s? Tell %s",\r\nresolve_pp_id(dstid), resolve_pp_id(srcid));\r\n}\r\nelse\r\n{\r\nif((type == PP_ARP_REPLY) && (len >= 36))\r\n{\r\nguint32 id = tvb_get_ntohl(tvb, 24);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s is at %s", resolve_pp_id(id), tvb_ip_to_str(tvb, 28));\r\n}\r\nelse if((type == PP_DATA) && (len >= 32))\r\n{\r\nguint16 xdmx_start = tvb_get_ntohs(tvb, 30);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "xDMX Data - %d channels @ %d (Univ %d.%d)",\r\ntvb_get_ntohs(tvb, 26),\r\nxdmx_start, xdmx_start / 512 + 1, xdmx_start % 512);\r\n}\r\nelse\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s", val_to_str(type, pp_pdu_vals, TYPE_UNKNOWN));\r\n}\r\n}\r\nif(tree == NULL)\r\nreturn tvb_reported_length(tvb);\r\nti = proto_tree_add_item(tree, proto_pathport, tvb, 0, -1, ENC_NA);\r\npathport_tree = proto_item_add_subtree(ti, ett_pathport);\r\noffset = dissect_header(tvb, pathport_tree, PATHPORT_HEADER_OFFSET);\r\nremaining_len = tvb_reported_length_remaining(tvb, offset);\r\noffset = dissect_multiple_pdus(tvb, tree, offset, remaining_len);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_pathport(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nif(!packet_is_pathport(tvb))\r\nreturn 0;\r\nreturn dissect_pathport_common(tvb, pinfo, tree);\r\n}\r\nstatic gboolean\r\ndissect_pathport_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nif(!packet_is_pathport(tvb))\r\nreturn FALSE;\r\ndissect_pathport_common(tvb, pinfo, tree);\r\nreturn (TRUE);\r\n}\r\nvoid\r\nproto_register_pathport(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{&hf_pp_prot, {"Protocol", "pathport.prot", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_reserved, {"Reserved", "pathport.resv", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_version, {"Version", "pathport.version", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_seq, {"Sequence", "pathport.seq", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_src, {"Source ID", "pathport.src", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_dst, {"Destination ID", "pathport.dst", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_pdu_type, {"PDU", "pathport.pdu", FT_UINT16, BASE_HEX, VALS(pp_pdu_vals), 0x0, NULL, HFILL }},\r\n{&hf_pp_pdu_len, {"Length", "pathport.len", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_pdu_payload, {"Payload", "pathport.payload", FT_BYTES, 0, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_get_type, {"Get", "pathport.get.pid", FT_UINT16, BASE_HEX | BASE_EXT_STRING, &pp_pid_vals_ext, 0x0, NULL, HFILL }},\r\n{&hf_pp_pid_type, {"Property", "pathport.pid", FT_UINT16, BASE_HEX | BASE_EXT_STRING, &pp_pid_vals_ext, 0x0, NULL, HFILL }},\r\n{&hf_pp_pid_len, {"Length", "pathport.pid.len", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_pid_value, {"Value", "pathport.pid.value", FT_BYTES, 0, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_pid_pad_bytes, {"Pad bytes", "pathport.pid.pad_bytes", FT_BYTES, 0, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_data_encoding, {"Data Encoding", "pathport.data.encoding", FT_UINT16, BASE_HEX, VALS(pp_data_encoding_vals), 0x0, NULL, HFILL }},\r\n{&hf_pp_data_start_code, {"DMX Start Code", "pathport.data.startcode", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_data_len, {"Data Length", "pathport.data.len", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_data_dst, {"xDMX Destination", "pathport.data.dst", FT_UINT16, BASE_HEX, NULL, 0x0,NULL, HFILL }},\r\n{&hf_pp_data_levels, {"Levels", "pathport.data.levels", FT_NONE, 0, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_arp_id, {"ID", "pathport.arp.id", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_arp_manuf, {"Manufacturer", "pathport.arp.manuf", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_arp_class, {"Device Class", "pathport.arp.class", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_arp_type, {"Device Type", "pathport.arp.type", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_arp_numdmx, {"Subcomponents", "pathport.arp.numdmx", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{&hf_pp_arp_ip, {"IP", "pathport.arp.ip", FT_IPv4, 0, NULL, 0x0, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pathport,\r\n&ett_pp_pdu,\r\n&ett_pp_tlv,\r\n&ett_pp_data\r\n};\r\nproto_pathport = proto_register_protocol("Pathport Protocol", "Pathport", "pathport");\r\nproto_register_field_array(proto_pathport, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_pathport(void)\r\n{\r\nstatic dissector_handle_t pathport_handle;\r\npathport_handle = create_dissector_handle(dissect_pathport, proto_pathport);\r\nheur_dissector_add("udp", dissect_pathport_heur, "Pathport over UDP", "pathport_udp", proto_pathport, HEURISTIC_ENABLE);\r\ndissector_add_uint("udp.port", PATHPORT_UDP_PORT, pathport_handle);\r\n}
