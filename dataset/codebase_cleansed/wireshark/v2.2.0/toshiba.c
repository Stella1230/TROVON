static gint64 toshiba_seek_next_packet(wtap *wth, int *err, gchar **err_info)\r\n{\r\nint byte;\r\nguint level = 0;\r\ngint64 cur_off;\r\nwhile ((byte = file_getc(wth->fh)) != EOF) {\r\nif (byte == toshiba_rec_magic[level]) {\r\nlevel++;\r\nif (level >= TOSHIBA_REC_MAGIC_SIZE) {\r\ncur_off = file_tell(wth->fh);\r\nif (cur_off == -1) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nreturn cur_off + 1;\r\n}\r\n} else {\r\nlevel = 0;\r\n}\r\n}\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nstatic gboolean toshiba_check_file_type(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar buf[TOSHIBA_LINE_LENGTH];\r\nguint i, reclen, level, line;\r\nchar byte;\r\nbuf[TOSHIBA_LINE_LENGTH-1] = 0;\r\nfor (line = 0; line < TOSHIBA_HEADER_LINES_TO_CHECK; line++) {\r\nif (file_gets(buf, TOSHIBA_LINE_LENGTH, wth->fh) == NULL) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn FALSE;\r\n}\r\nreclen = (guint) strlen(buf);\r\nif (reclen < TOSHIBA_HDR_MAGIC_SIZE) {\r\ncontinue;\r\n}\r\nlevel = 0;\r\nfor (i = 0; i < reclen; i++) {\r\nbyte = buf[i];\r\nif (byte == toshiba_hdr_magic[level]) {\r\nlevel++;\r\nif (level >= TOSHIBA_HDR_MAGIC_SIZE) {\r\nreturn TRUE;\r\n}\r\n}\r\nelse {\r\nlevel = 0;\r\n}\r\n}\r\n}\r\n*err = 0;\r\nreturn FALSE;\r\n}\r\nwtap_open_return_val toshiba_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nif (!toshiba_check_file_type(wth, err, err_info)) {\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_TOSHIBA;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = toshiba_read;\r\nwth->subtype_seek_read = toshiba_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_CSEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\ngint64 offset;\r\noffset = toshiba_seek_next_packet(wth, err, err_info);\r\nif (offset < 1)\r\nreturn FALSE;\r\n*data_offset = offset;\r\nreturn parse_toshiba_packet(wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info);\r\n}\r\nstatic gboolean\r\ntoshiba_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!parse_toshiba_packet(wth->random_fh, phdr, buf, err, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nparse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nchar line[TOSHIBA_LINE_LENGTH];\r\nint num_items_scanned;\r\nint pkt_len, pktnum, hr, min, sec, csec;\r\nchar channel[10], direction[10];\r\nint i, hex_lines;\r\nguint8 *pd;\r\nif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nnum_items_scanned = sscanf(line, "%9d] %2d:%2d:%2d.%9d %9s %9s",\r\n&pktnum, &hr, &min, &sec, &csec, channel, direction);\r\nif (num_items_scanned != 7) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("toshiba: record header isn't valid");\r\nreturn FALSE;\r\n}\r\ndo {\r\nif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nline[16] = '\0';\r\n} while (strcmp(line, "OFFSET 0001-0203") != 0);\r\nnum_items_scanned = sscanf(line+64, "LEN=%9d", &pkt_len);\r\nif (num_items_scanned != 1) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("toshiba: OFFSET line doesn't have valid LEN item");\r\nreturn FALSE;\r\n}\r\nif (pkt_len < 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("toshiba: packet header has a negative packet length");\r\nreturn FALSE;\r\n}\r\nif (pkt_len > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("toshiba: File has %u-byte packet, bigger than maximum of %u",\r\npkt_len, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nphdr->ts.secs = hr * 3600 + min * 60 + sec;\r\nphdr->ts.nsecs = csec * 10000000;\r\nphdr->caplen = pkt_len;\r\nphdr->len = pkt_len;\r\nswitch (channel[0]) {\r\ncase 'B':\r\nphdr->pkt_encap = WTAP_ENCAP_ISDN;\r\npseudo_header->isdn.uton = (direction[0] == 'T');\r\npseudo_header->isdn.channel = (guint8)\r\nstrtol(&channel[1], NULL, 10);\r\nbreak;\r\ncase 'D':\r\nphdr->pkt_encap = WTAP_ENCAP_ISDN;\r\npseudo_header->isdn.uton = (direction[0] == 'T');\r\npseudo_header->isdn.channel = 0;\r\nbreak;\r\ndefault:\r\nphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\r\npseudo_header->eth.fcs_len = -1;\r\nbreak;\r\n}\r\nws_buffer_assure_space(buf, pkt_len);\r\npd = ws_buffer_start_ptr(buf);\r\nhex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\nfor (i = 0; i < hex_lines; i++) {\r\nif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nif (!parse_single_hex_dump_line(line, pd, i * 16)) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("toshiba: hex dump not valid");\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nparse_single_hex_dump_line(char* rec, guint8 *buf, guint byte_offset) {\r\nint pos, i;\r\nchar *s;\r\nunsigned long value;\r\nguint16 word_value;\r\nrec[4] = '\0';\r\ns = rec;\r\nvalue = strtoul(s, NULL, 16);\r\nif (value != byte_offset) {\r\nreturn FALSE;\r\n}\r\nfor (pos = START_POS; pos < START_POS + HEX_LENGTH; pos++) {\r\nif (rec[pos] == ' ') {\r\nrec[pos] = '0';\r\n}\r\n}\r\npos = START_POS;\r\nfor (i = 0; i < 8; i++) {\r\nrec[pos+4] = '\0';\r\nword_value = (guint16) strtoul(&rec[pos], NULL, 16);\r\nbuf[byte_offset + i * 2 + 0] = (guint8) (word_value >> 8);\r\nbuf[byte_offset + i * 2 + 1] = (guint8) (word_value & 0x00ff);\r\npos += 5;\r\n}\r\nreturn TRUE;\r\n}
