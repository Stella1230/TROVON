static guint\r\nget_xmcp_message_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nreturn(XMCP_HDR_LEN + tvb_get_ntohs(tvb, offset+2));\r\n}\r\nstatic guint16\r\nget_xmcp_attr_padded_len(guint16 attr_length)\r\n{\r\nreturn((attr_length + 3) & 0xfffc);\r\n}\r\nstatic guint16\r\nget_xmcp_attr_fixed_len(guint16 xmcp_attr)\r\n{\r\nswitch (xmcp_attr) {\r\ncase XMCP_CLIENT_HANDLE:\r\ncase XMCP_PROTOCOL_VERSION:\r\ncase XMCP_PAGE_SIZE:\r\ncase XMCP_KEEPALIVE:\r\ncase XMCP_SERVICE_PROTOCOL:\r\ncase XMCP_SERVICE_VERSION:\r\ncase XMCP_SUBSCRIPTION_ID:\r\ncase XMCP_SERVICE_REMOVED_REASON:\r\ncase XMCP_DOMAIN:\r\nreturn(4);\r\ncase XMCP_SERVICE_IDENTITY:\r\nreturn(20);\r\ndefault:\r\nreturn(0);\r\n}\r\n}\r\nstatic guint16\r\nget_xmcp_attr_min_len(guint16 xmcp_attr)\r\n{\r\nswitch (xmcp_attr) {\r\ncase XMCP_USERNAME:\r\ncase XMCP_NONCE:\r\ncase XMCP_CLIENT_NAME:\r\ncase XMCP_CLIENT_LABEL:\r\nreturn(1);\r\ncase XMCP_ERROR_CODE:\r\nreturn(4);\r\ncase XMCP_SERVICE_TRANSPORT:\r\nreturn(8);\r\ncase XMCP_MESSAGE_INTEGRITY:\r\nreturn(20);\r\ndefault:\r\nreturn(get_xmcp_attr_fixed_len(xmcp_attr));\r\n}\r\n}\r\nstatic guint16\r\nget_xmcp_attr_max_len(guint16 xmcp_attr) {\r\nguint16 fixed_len;\r\nswitch (xmcp_attr) {\r\ncase XMCP_SERVICE_TRANSPORT:\r\nreturn(20);\r\ncase XMCP_MESSAGE_INTEGRITY:\r\nreturn(32);\r\ncase XMCP_NONCE:\r\ncase XMCP_CLIENT_NAME:\r\ncase XMCP_CLIENT_LABEL:\r\nreturn(255);\r\ndefault:\r\nfixed_len = get_xmcp_attr_fixed_len(xmcp_attr);\r\nreturn(fixed_len ? fixed_len : 0xffff);\r\n}\r\n}\r\nstatic void\r\nadd_xmcp_port_name (void)\r\n{\r\nif (!xmcp_it_service_port || xmcp_service_port == -1)\r\nreturn;\r\nswitch(xmcp_service_protocol) {\r\ncase IP_PROTO_TCP:\r\nproto_item_append_text(xmcp_it_service_port, " (TCP: %s)",\r\ntcp_port_to_display(wmem_packet_scope(), xmcp_service_port));\r\nbreak;\r\ncase IP_PROTO_UDP:\r\nproto_item_append_text(xmcp_it_service_port, " (UDP: %s)",\r\nudp_port_to_display(wmem_packet_scope(), xmcp_service_port));\r\nbreak;\r\ncase IP_PROTO_DCCP:\r\nproto_item_append_text(xmcp_it_service_port, " (DCCP: %s)",\r\ndccp_port_to_display(wmem_packet_scope(), xmcp_service_port));\r\nbreak;\r\ncase IP_PROTO_SCTP:\r\nproto_item_append_text(xmcp_it_service_port, " (SCTP: %s)",\r\nsctp_port_to_display(wmem_packet_scope(), xmcp_service_port));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndecode_xmcp_attr_value (proto_tree *attr_tree, guint16 attr_type,\r\nguint16 attr_length, tvbuff_t *tvb, guint16 offset,\r\npacket_info *pinfo)\r\n{\r\nproto_item *it;\r\nswitch (attr_type) {\r\ncase XMCP_USERNAME:\r\nproto_tree_add_item(attr_tree, xmcp_attr_username, tvb, offset,\r\nattr_length, ENC_ASCII|ENC_NA);\r\nproto_item_append_text(attr_tree, ": %s",\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, offset, attr_length, ENC_ASCII));\r\nif (xmcp_msg_type_method == XMCP_METHOD_REGISTER) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", user \"%s\"",\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, offset, attr_length, ENC_ASCII));\r\n}\r\nbreak;\r\ncase XMCP_MESSAGE_INTEGRITY:\r\nproto_tree_add_item(attr_tree, xmcp_attr_message_integrity, tvb, offset,\r\nattr_length, ENC_NA);\r\nif ((guint)(offset + get_xmcp_attr_padded_len(attr_length)) < tvb_reported_length(tvb)) {\r\nexpert_add_info(pinfo, attr_tree, &ei_xmcp_data_following_message_integrity);\r\n}\r\nbreak;\r\ncase XMCP_ERROR_CODE:\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_error_reserved, tvb, offset,\r\n3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(attr_tree, xmcp_attr_error_class, tvb, offset,\r\n3, ENC_BIG_ENDIAN);\r\n{\r\nguint8 error_class, error_number;\r\nguint16 error_code;\r\nit = proto_tree_add_item(attr_tree, xmcp_attr_error_number, tvb,\r\n(offset+3), 1, ENC_BIG_ENDIAN);\r\nerror_class = tvb_get_guint8(tvb, offset+2) & 0x07;\r\nerror_number = tvb_get_guint8(tvb, offset+3);\r\nif (error_number > 99) {\r\nexpert_add_info(pinfo, it, &ei_xmcp_attr_error_number_out_of_range);\r\n} else {\r\nerror_code = (error_class * 100) + error_number;\r\nit = proto_tree_add_uint(attr_tree, xmcp_attr_error_code, tvb,\r\n(offset+2), 2, error_code);\r\nPROTO_ITEM_SET_GENERATED(it);\r\nproto_item_append_text(attr_tree, ": %d", error_code);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", error %d (%s)", error_code,\r\nval_to_str_const(error_code, error_codes, "Unknown"));\r\nswitch (error_code) {\r\ncase 400:\r\ncase 431:\r\ncase 473:\r\ncase 476:\r\ncase 477:\r\ncase 499:\r\ncase 500:\r\nexpert_add_info_format(pinfo, it, &ei_xmcp_attr_error_code_unusual, "Unusual error code (%u, %s)", error_code, val_to_str_const(error_code, error_codes, "Unknown"));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nif (attr_length < 5)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_error_reason, tvb, (offset+4),\r\n(attr_length - 4), ENC_ASCII|ENC_NA);\r\nproto_item_append_text(attr_tree, " (%s)",\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, (offset+4),\r\n(attr_length-4), ENC_ASCII));\r\nbreak;\r\ncase XMCP_REALM:\r\nit = proto_tree_add_item(attr_tree, xmcp_attr_realm, tvb, offset,\r\nattr_length, ENC_ASCII|ENC_NA);\r\n{\r\nguint8 *realm;\r\nrealm = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, attr_length, ENC_ASCII);\r\nproto_item_append_text(attr_tree, ": %s", realm);\r\nif (attr_length != 5 || strncmp(realm, "\"SAF\"", attr_length)) {\r\nexpert_add_info(pinfo, it, &ei_xmcp_attr_realm_incorrect);\r\n}\r\n}\r\nbreak;\r\ncase XMCP_NONCE:\r\nproto_tree_add_item(attr_tree, xmcp_attr_nonce, tvb, offset,\r\nattr_length, ENC_ASCII|ENC_NA);\r\nproto_item_append_text(attr_tree, ": %s",\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, offset, attr_length, ENC_ASCII));\r\nbreak;\r\ncase XMCP_CLIENT_NAME:\r\nproto_tree_add_item(attr_tree, xmcp_attr_client_name, tvb, offset,\r\nattr_length, ENC_ASCII|ENC_NA);\r\nproto_item_append_text(attr_tree, ": %s",\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, offset, attr_length, ENC_ASCII));\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", name \"%s\"",\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, offset, attr_length, ENC_ASCII));\r\nbreak;\r\ncase XMCP_CLIENT_HANDLE:\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_client_handle, tvb, offset,\r\n4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(attr_tree, ": %u", tvb_get_ntohl(tvb, offset));\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", handle %u",\r\ntvb_get_ntohl(tvb, offset));\r\nif (xmcp_msg_type_method == XMCP_METHOD_REGISTER &&\r\nxmcp_msg_type_class == XMCP_CLASS_REQUEST) {\r\nxmcp_msg_is_keepalive = TRUE;\r\n}\r\nbreak;\r\ncase XMCP_PROTOCOL_VERSION:\r\nif (attr_length < 2)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_version_major, tvb, offset,\r\n2, ENC_BIG_ENDIAN);\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_version_minor, tvb, (offset+2),\r\n2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(attr_tree, ": %u.%u", tvb_get_ntohs(tvb, offset),\r\ntvb_get_ntohs(tvb, (offset+2)));\r\nbreak;\r\ncase XMCP_PAGE_SIZE:\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_page_size, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(attr_tree, ": %u", tvb_get_ntohl(tvb, offset));\r\nbreak;\r\ncase XMCP_CLIENT_LABEL:\r\nproto_tree_add_item(attr_tree, xmcp_attr_client_label, tvb, offset,\r\nattr_length, ENC_ASCII|ENC_NA);\r\nproto_item_append_text(attr_tree, ": %s",\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, offset, attr_length, ENC_ASCII));\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", label \"%s\"",\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, offset, attr_length, ENC_ASCII));\r\nbreak;\r\ncase XMCP_KEEPALIVE:\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_keepalive, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(attr_tree, ": %u", tvb_get_ntohl(tvb, offset));\r\nbreak;\r\ncase XMCP_SERVICE_IDENTITY:\r\nif (attr_length < 2)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_serv_service, tvb, offset,\r\n2, ENC_BIG_ENDIAN);\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_serv_subservice, tvb, (offset+2),\r\n2, ENC_BIG_ENDIAN);\r\nif (attr_length < 20)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_serv_instance, tvb, (offset+4),\r\n16, ENC_BIG_ENDIAN);\r\n{\r\ne_guid_t guid;\r\nchar buf[GUID_STR_LEN];\r\ntvb_get_guid(tvb, (offset+4), &guid, ENC_BIG_ENDIAN);\r\nguid_to_str_buf(&guid, buf, sizeof(buf));\r\nproto_item_append_text(attr_tree, ": %u:%u:%s",\r\ntvb_get_ntohs(tvb, offset),\r\ntvb_get_ntohs(tvb, (offset+2)), buf);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", service %u:%u:%s",\r\ntvb_get_ntohs(tvb, offset),\r\ntvb_get_ntohs(tvb, (offset+2)), buf);\r\n}\r\nbreak;\r\ncase XMCP_SERVICE_TRANSPORT:\r\nif (attr_length < 1)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_reserved, tvb, offset, 1, ENC_NA);\r\nif (attr_length < 2)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_servtrans_family, tvb,\r\n(offset+1), 1, ENC_BIG_ENDIAN);\r\nif (attr_length < 4)\r\nbreak;\r\nxmcp_service_port = tvb_get_ntohs(tvb, (offset+2));\r\nxmcp_it_service_port = proto_tree_add_item(attr_tree,\r\nxmcp_attr_servtrans_port,\r\ntvb, (offset+2), 2, ENC_BIG_ENDIAN);\r\nif (xmcp_service_protocol != -1) {\r\nadd_xmcp_port_name();\r\n}\r\nswitch (tvb_get_guint8(tvb, (offset+1))) {\r\ncase 0x01:\r\nif (attr_length != 8) {\r\nexpert_add_info_format(pinfo, attr_tree, &ei_xmcp_attr_length_bad, "Malformed IPv4 address");\r\n} else {\r\nproto_tree_add_item(attr_tree, xmcp_attr_servtrans_ipv4, tvb,\r\n(offset+4), 4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(attr_tree, ": %s:%u", tvb_ip_to_str(tvb, offset+4),\r\ntvb_get_ntohs(tvb, (offset+2)));\r\n}\r\nbreak;\r\ncase 0x02:\r\nif (attr_length != 20) {\r\nexpert_add_info_format(pinfo, attr_tree, &ei_xmcp_attr_length_bad, "Malformed IPv6 address");\r\n} else {\r\nproto_tree_add_item(attr_tree, xmcp_attr_servtrans_ipv6, tvb,\r\n(offset+4), 16, ENC_NA);\r\nproto_item_append_text(attr_tree, ": [%s]:%u", tvb_ip6_to_str(tvb, (offset+4)),\r\ntvb_get_ntohs(tvb, (offset+2)));\r\n}\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, attr_tree, &ei_xmcp_xmcp_attr_servtrans_unknown);\r\nbreak;\r\n}\r\nbreak;\r\ncase XMCP_SERVICE_PROTOCOL:\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_reserved, tvb, offset, 3, ENC_NA);\r\nproto_tree_add_item(attr_tree, xmcp_attr_service_protocol, tvb,\r\n(offset+3), 1, ENC_BIG_ENDIAN);\r\nxmcp_service_protocol = tvb_get_guint8(tvb, (offset+3));\r\nproto_item_append_text(attr_tree, ": %u (%s)", xmcp_service_protocol,\r\nval_to_str_ext_const(xmcp_service_protocol,\r\n&ipproto_val_ext, "Unknown"));\r\nif (xmcp_service_port != -1 && xmcp_it_service_port != NULL) {\r\nadd_xmcp_port_name();\r\n}\r\nbreak;\r\ncase XMCP_FLAGS:\r\nif (attr_length % 4 != 0) {\r\nexpert_add_info_format(pinfo, attr_tree, &ei_xmcp_attr_length_bad, "Malformed Flags - length not divisible by 4");\r\n}\r\n{\r\nguint16 flag_type, flag_value, current_offset = offset;\r\nproto_item *ti;\r\nproto_tree *flag_tree;\r\nwhile ((current_offset-offset)+3 < attr_length) {\r\nflag_type = tvb_get_ntohs(tvb, (current_offset));\r\nflag_value = tvb_get_ntohs(tvb, (current_offset+2));\r\nti = proto_tree_add_none_format(attr_tree, xmcp_attr_flag, tvb,\r\ncurrent_offset, 4,\r\n"Flag: %s:",\r\nval_to_str_const(flag_type, flag_types,\r\n"Unknown"));\r\nflag_tree = proto_item_add_subtree(ti, ett_xmcp_attr_flag);\r\nproto_tree_add_item(flag_tree, xmcp_attr_flag_type, tvb,\r\ncurrent_offset, 2, ENC_BIG_ENDIAN);\r\ncurrent_offset += 2;\r\nswitch (flag_type) {\r\ncase XMCP_FLAG_REMOVAL_REASON:\r\nproto_tree_add_item(flag_tree, xmcp_attr_flag_removal_reason_reserved,\r\ntvb, current_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree,\r\nxmcp_attr_flag_removal_reason_network_withdraw,\r\ntvb, current_offset, 2, ENC_BIG_ENDIAN);\r\nif (flag_value & XMCP_REMOVAL_REASON_NETWORK_WITHDRAW) {\r\nproto_item_append_text(flag_tree, " (network withdraw)");\r\n}\r\nif (!flag_value) {\r\nproto_item_append_text(flag_tree, " (source withdraw)");\r\n}\r\nbreak;\r\ncase XMCP_FLAG_TRUST:\r\nproto_tree_add_item(flag_tree, xmcp_attr_flag_trust, tvb,\r\ncurrent_offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(flag_tree, " %s",\r\nval_to_str_const(flag_value, flag_trust_values,\r\n"Unknown"));\r\nbreak;\r\ncase XMCP_FLAG_SERVICE_VISIBILITY:\r\nproto_tree_add_item(flag_tree, xmcp_attr_flag_visibility_reserved,\r\ntvb, current_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree,\r\nxmcp_attr_flag_visibility_unauthenticated,\r\ntvb, current_offset, 2, ENC_BIG_ENDIAN);\r\nif (flag_value & XMCP_SERVICE_VISIBILITY_UNAUTHENTICATED) {\r\nproto_item_append_text(flag_tree,\r\n" (visible to unauthenticated clients)");\r\n}\r\nif (!flag_value) {\r\nproto_item_append_text(flag_tree, " (default)");\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(flag_tree, xmcp_attr_flag_value, tvb,\r\ncurrent_offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(flag_tree, " 0x%04x", flag_value);\r\nbreak;\r\n}\r\ncurrent_offset += 2;\r\n}\r\n}\r\nbreak;\r\ncase XMCP_SERVICE_VERSION:\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_service_version, tvb, offset,\r\n4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(attr_tree, ": %u", tvb_get_ntohl(tvb, offset));\r\nbreak;\r\ncase XMCP_SERVICE_DATA:\r\nproto_tree_add_item(attr_tree, xmcp_attr_service_data, tvb, offset,\r\nattr_length, ENC_NA);\r\nif (attr_length > 0) {\r\ntvbuff_t *next_tvb;\r\nguint8 *test_string, *tok;\r\nnext_tvb = tvb_new_subset_length(tvb, offset, attr_length);\r\ntest_string = tvb_get_string_enc(wmem_packet_scope(), next_tvb, 0, (attr_length < 32 ?\r\nattr_length : 32), ENC_ASCII);\r\ntok = strtok(test_string, " \t\r\n");\r\nif (tok && tok[0] == '<') {\r\ndissector_try_string(media_type_dissector_table, "application/xml",\r\nnext_tvb, pinfo, attr_tree, NULL);\r\n} else {\r\ndissector_try_string(media_type_dissector_table, "text/plain",\r\nnext_tvb, pinfo, attr_tree, NULL);\r\n}\r\n}\r\nbreak;\r\ncase XMCP_SUBSCRIPTION_ID:\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_subscription_id, tvb, offset,\r\n4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(attr_tree, ": %u", tvb_get_ntohl(tvb, offset));\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", subscription %u",\r\ntvb_get_ntohl(tvb, offset));\r\nbreak;\r\ncase XMCP_SERVICE_REMOVED_REASON:\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_service_removed_reason, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(attr_tree, ": %s",\r\nval_to_str_const(tvb_get_ntohl(tvb, offset),\r\nservice_removed_reasons,\r\n"Unknown"));\r\nbreak;\r\ncase XMCP_DOMAIN:\r\nif (attr_length < 4)\r\nbreak;\r\nproto_tree_add_item(attr_tree, xmcp_attr_domain, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(attr_tree, ": %u", tvb_get_ntohl(tvb, offset));\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(attr_tree, xmcp_attr_value, tvb, offset,\r\nattr_length, ENC_NA);\r\nexpert_add_info(pinfo, attr_tree, &ei_xmcp_attr_type_unknown);\r\nbreak;\r\n}\r\nif (attr_length % 4 != 0) {\r\nproto_tree_add_item(attr_tree, xmcp_attr_padding, tvb, (offset+attr_length),\r\n(4 - (attr_length % 4)), ENC_NA);\r\n}\r\nif (attr_length < get_xmcp_attr_min_len(attr_type)) {\r\nexpert_add_info_format(pinfo, attr_tree, &ei_xmcp_attr_length_bad, "Length less than minimum for this attribute type");\r\n} else if (attr_length > get_xmcp_attr_max_len(attr_type)) {\r\nexpert_add_info_format(pinfo, attr_tree, &ei_xmcp_attr_length_bad, "Length exceeds maximum for this attribute type");\r\n}\r\n}\r\nstatic int\r\ndissect_xmcp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint16 msg_type, msg_length;\r\nproto_item *ti = NULL;\r\nproto_tree *xmcp_tree, *attr_all_tree, *attr_tree;\r\nguint16 offset, attr_type, attr_length;\r\nguint32 transaction_id[3];\r\nwmem_tree_key_t transaction_id_key[2];\r\nconversation_t *conversation;\r\nxmcp_conv_info_t *xmcp_conv_info;\r\nxmcp_transaction_t *xmcp_trans;\r\nif (tvb_reported_length(tvb) < XMCP_HDR_LEN) {\r\nreturn 0;\r\n}\r\nmsg_type = tvb_get_ntohs(tvb, 0);\r\nif (msg_type & XMCP_TYPE_RESERVED) {\r\nreturn 0;\r\n}\r\nif (tvb_get_ntohl(tvb, 4) != XMCP_MAGIC_COOKIE) {\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "XMCP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nxmcp_msg_type_class = ((msg_type & XMCP_TYPE_CLASS) >> 4);\r\nxmcp_msg_type_method = (msg_type & XMCP_TYPE_METHOD);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s %s",\r\nval_to_str_const(xmcp_msg_type_method, methods, "Unknown"),\r\nval_to_str_const(xmcp_msg_type_class, classes, "Unknown"));\r\ntransaction_id[0] = tvb_get_ntohl(tvb, 8);\r\ntransaction_id[1] = tvb_get_ntohl(tvb, 12);\r\ntransaction_id[2] = tvb_get_ntohl(tvb, 16);\r\ntransaction_id_key[0].length = 3;\r\ntransaction_id_key[0].key = transaction_id;\r\ntransaction_id_key[1].length = 0;\r\ntransaction_id_key[1].key = NULL;\r\nconversation = find_or_create_conversation(pinfo);\r\nxmcp_conv_info = (xmcp_conv_info_t *)conversation_get_proto_data(conversation, proto_xmcp);\r\nif (!xmcp_conv_info) {\r\nxmcp_conv_info = wmem_new(wmem_file_scope(), xmcp_conv_info_t);\r\nxmcp_conv_info->transaction_pdus = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(conversation, proto_xmcp, xmcp_conv_info);\r\n}\r\nxmcp_trans = (xmcp_transaction_t *)wmem_tree_lookup32_array(xmcp_conv_info->transaction_pdus,\r\ntransaction_id_key);\r\nif (!xmcp_trans) {\r\nxmcp_trans = wmem_new(wmem_file_scope(), xmcp_transaction_t);\r\nxmcp_trans->request_frame = 0;\r\nxmcp_trans->response_frame = 0;\r\nxmcp_trans->request_time = pinfo->abs_ts;\r\nxmcp_trans->request_is_keepalive = FALSE;\r\nwmem_tree_insert32_array(xmcp_conv_info->transaction_pdus,\r\ntransaction_id_key, (void *)xmcp_trans);\r\n}\r\nif (!pinfo->fd->flags.visited) {\r\nif (xmcp_msg_type_class == XMCP_CLASS_REQUEST) {\r\nif (xmcp_trans->request_frame == 0) {\r\nxmcp_trans->request_frame = pinfo->num;\r\nxmcp_trans->request_time = pinfo->abs_ts;\r\n}\r\n} else if (xmcp_msg_type_class != XMCP_CLASS_RESERVED) {\r\nif (xmcp_trans->response_frame == 0) {\r\nxmcp_trans->response_frame = pinfo->num;\r\n}\r\n}\r\n}\r\nti = proto_tree_add_item(tree, proto_xmcp, tvb, 0, -1, ENC_NA);\r\nxmcp_tree = proto_item_add_subtree(ti, ett_xmcp);\r\nti = proto_tree_add_bitmask(xmcp_tree, tvb, 0, hf_xmcp_type, ett_xmcp_type,\r\nxmcp_type_fields, ENC_BIG_ENDIAN);\r\nif (msg_type & XMCP_TYPE_RESERVED) {\r\nexpert_add_info(pinfo, ti, &ei_xmcp_type_reserved_not_zero);\r\n}\r\nif (xmcp_msg_type_class == XMCP_CLASS_RESERVED) {\r\nexpert_add_info(pinfo, ti, &ei_xmcp_message_class_reserved);\r\n} else if (xmcp_msg_type_class == XMCP_CLASS_RESPONSE_ERROR) {\r\nexpert_add_info(pinfo, ti, &ei_xmcp_error_response);\r\n}\r\nif (xmcp_msg_type_method < 0x001 || xmcp_msg_type_method > 0x00b) {\r\nexpert_add_info(pinfo, ti, &ei_xmcp_msg_type_method_reserved);\r\n}\r\nxmcp_msg_is_keepalive = (xmcp_trans->request_is_keepalive ||\r\n(xmcp_msg_type_method == XMCP_METHOD_KEEPALIVE));\r\nti = proto_tree_add_item(xmcp_tree, hf_xmcp_length, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nmsg_length = tvb_get_ntohs(tvb, 2);\r\nif ((guint)(msg_length + XMCP_HDR_LEN) > tvb_reported_length(tvb)) {\r\nexpert_add_info_format(pinfo, ti, &ei_xmcp_length_bad, "XMCP message length (%u-byte header + %u) exceeds packet length (%u)", XMCP_HDR_LEN, msg_length, tvb_reported_length(tvb));\r\nreturn tvb_captured_length(tvb);\r\n}\r\nti = proto_tree_add_item(xmcp_tree, hf_xmcp_cookie, tvb, 4, 4, ENC_BIG_ENDIAN);\r\nif (tvb_get_ntohl(tvb, 4) != XMCP_MAGIC_COOKIE) {\r\nexpert_add_info(pinfo, ti, &ei_xmcp_magic_cookie_incorrect);\r\n}\r\nti = proto_tree_add_item(xmcp_tree, hf_xmcp_id, tvb, 8, 12, ENC_NA);\r\nif (xmcp_msg_type_class == XMCP_CLASS_REQUEST) {\r\nif (xmcp_trans->response_frame) {\r\nti = proto_tree_add_uint(xmcp_tree, hf_xmcp_response_in, tvb, 0, 0,\r\nxmcp_trans->response_frame);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\n} else if (xmcp_msg_type_class != XMCP_CLASS_RESERVED) {\r\nif (xmcp_trans->request_frame) {\r\nnstime_t ns;\r\nti = proto_tree_add_uint(xmcp_tree, hf_xmcp_response_to, tvb, 0, 0,\r\nxmcp_trans->request_frame);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nnstime_delta(&ns, &pinfo->abs_ts, &xmcp_trans->request_time);\r\nti = proto_tree_add_time(xmcp_tree, hf_xmcp_time, tvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n} else {\r\nexpert_add_info(pinfo, ti, &ei_xmcp_response_without_request);\r\n}\r\n}\r\nxmcp_service_protocol = -1;\r\nxmcp_service_port = -1;\r\nxmcp_it_service_port = NULL;\r\nif (msg_length > 0) {\r\nti = proto_tree_add_item(xmcp_tree, hf_xmcp_attributes, tvb,\r\nXMCP_HDR_LEN, msg_length, ENC_NA);\r\nattr_all_tree = proto_item_add_subtree(ti, ett_xmcp_attr_all);\r\noffset = XMCP_HDR_LEN;\r\nwhile (offset < (msg_length + XMCP_HDR_LEN)) {\r\nattr_type = tvb_get_ntohs(tvb, offset);\r\nattr_length = tvb_get_ntohs(tvb, offset+2);\r\nti = proto_tree_add_none_format(attr_all_tree, hf_xmcp_attr, tvb, offset,\r\n(XMCP_ATTR_HDR_LEN +\r\nget_xmcp_attr_padded_len(attr_length)),\r\n"%s, length %u",\r\nval_to_str_const(attr_type, attributes,\r\n"Unknown"),\r\nattr_length);\r\nattr_tree = proto_item_add_subtree(ti, ett_xmcp_attr);\r\nproto_tree_add_item(attr_tree, xmcp_attr_type, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nti = proto_tree_add_item(attr_tree, xmcp_attr_length, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif ((offset + attr_length) > (XMCP_HDR_LEN + msg_length)) {\r\nproto_item_append_text(ti, " (bogus, exceeds message length)");\r\nexpert_add_info_format(pinfo, attr_tree, &ei_xmcp_attr_length_bad, "Attribute length exceeds message length");\r\nbreak;\r\n}\r\ndecode_xmcp_attr_value(attr_tree, attr_type, attr_length, tvb,\r\noffset, pinfo);\r\noffset += get_xmcp_attr_padded_len(attr_length);\r\n}\r\n}\r\nif (xmcp_msg_is_keepalive) {\r\nti = proto_tree_add_none_format(xmcp_tree, hf_xmcp_msg_is_keepalive, tvb,\r\n0, 0, "This is a Keepalive message");\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nif (xmcp_msg_type_method != XMCP_METHOD_KEEPALIVE) {\r\ncol_prepend_fstr(pinfo->cinfo, COL_INFO, "[Keepalive] ");\r\n}\r\nif (xmcp_msg_type_class == XMCP_CLASS_REQUEST) {\r\nxmcp_trans->request_is_keepalive = TRUE;\r\n}\r\n} else if (xmcp_msg_type_class == XMCP_CLASS_REQUEST ||\r\nxmcp_msg_type_class == XMCP_CLASS_RESPONSE_SUCCESS) {\r\nif (xmcp_msg_type_method == XMCP_METHOD_REGISTER) {\r\nexpert_add_info_format(pinfo, xmcp_tree, &ei_xmcp_new_session, "New session - Register %s", val_to_str_const(xmcp_msg_type_class, classes, ""));\r\n} else if (xmcp_msg_type_method == XMCP_METHOD_UNREGISTER ||\r\nxmcp_msg_type_method == XMCP_METHOD_REG_REVOKE) {\r\nexpert_add_info_format(pinfo, xmcp_tree, &ei_xmcp_session_termination, "Session termination - %s %s", val_to_str_const(xmcp_msg_type_method, methods, ""), val_to_str_const(xmcp_msg_type_class, classes, ""));\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_xmcp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, XMCP_HDR_LEN,\r\nget_xmcp_message_len, dissect_xmcp_message, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_xmcp_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nif (tvb_captured_length(tvb) < XMCP_HDR_LEN) {\r\nreturn FALSE;\r\n}\r\nif (tvb_get_ntohs(tvb, 0) & XMCP_TYPE_RESERVED) {\r\nreturn FALSE;\r\n}\r\nif (tvb_get_ntohl(tvb, 4) != XMCP_MAGIC_COOKIE) {\r\nreturn FALSE;\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, XMCP_HDR_LEN,\r\nget_xmcp_message_len, dissect_xmcp_message, data);\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_xmcp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_xmcp_type,\r\n{ "Message Type", "xmcp.type",\r\nFT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_xmcp_type_reserved,\r\n{ "Reserved", "xmcp.type.reserved",\r\nFT_UINT16, BASE_HEX, NULL, XMCP_TYPE_RESERVED, NULL, HFILL }\r\n},\r\n{ &hf_xmcp_type_class,\r\n{ "Class", "xmcp.type.class",\r\nFT_UINT16, BASE_HEX, VALS(classes), XMCP_TYPE_CLASS, NULL, HFILL }\r\n},\r\n{ &hf_xmcp_type_method,\r\n{ "Method", "xmcp.type.method",\r\nFT_UINT16, BASE_HEX, VALS(methods), XMCP_TYPE_METHOD, NULL, HFILL }\r\n},\r\n{ &hf_xmcp_msg_is_keepalive,\r\n{ "Message is Keepalive", "xmcp.analysis.keepalive",\r\nFT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_xmcp_length,\r\n{ "Message Length", "xmcp.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_xmcp_cookie,\r\n{ "XMCP Magic Cookie", "xmcp.cookie",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_xmcp_id,\r\n{ "Transaction ID", "xmcp.id",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_xmcp_response_in,\r\n{ "Response In", "xmcp.response-in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"The response to this XMCP request is in this frame", HFILL }\r\n},\r\n{ &hf_xmcp_response_to,\r\n{ "Response To", "xmcp.response-to",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"This is a response to the XMCP request in this frame", HFILL }\r\n},\r\n{ &hf_xmcp_time,\r\n{ "Elapsed Time", "xmcp.time",\r\nFT_RELATIVE_TIME, BASE_NONE, NULL, 0x0,\r\n"The time between the Request and the Response", HFILL }\r\n},\r\n{ &hf_xmcp_attributes,\r\n{ "Attributes", "xmcp.attributes",\r\nFT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_xmcp_attr,\r\n{ "Attribute", "xmcp.attr",\r\nFT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_type,\r\n{ "Attribute Type", "xmcp.attr.type",\r\nFT_UINT16, BASE_HEX, VALS(attributes), 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_length,\r\n{ "Attribute Length", "xmcp.attr.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_value,\r\n{ "Attribute Value", "xmcp.attr.value",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{ &xmcp_attr_padding,\r\n{ "Padding", "xmcp.attr.padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_reserved,\r\n{ "Reserved", "xmcp.attr.reserved",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_username,\r\n{ "Username", "xmcp.attr.username",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_message_integrity,\r\n{ "Message-Integrity", "xmcp.attr.hmac",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_error_reserved,\r\n{ "Reserved", "xmcp.attr.error.reserved",\r\nFT_UINT24, BASE_HEX, NULL, 0xFFFFF8, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_error_class,\r\n{ "Error Class", "xmcp.attr.error.class",\r\nFT_UINT24, BASE_DEC, NULL, 0x000007, NULL, HFILL}\r\n},\r\n{ &xmcp_attr_error_number,\r\n{ "Error Number", "xmcp.attr.error.number",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}\r\n},\r\n{ &xmcp_attr_error_code,\r\n{ "Error Code", "xmcp.attr.error",\r\nFT_UINT16, BASE_DEC, VALS(error_codes), 0x0, NULL, HFILL}\r\n},\r\n{ &xmcp_attr_error_reason,\r\n{ "Error Reason Phrase", "xmcp.attr.error.reason",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL}\r\n},\r\n{ &xmcp_attr_realm,\r\n{ "Realm", "xmcp.attr.realm",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_nonce,\r\n{ "Nonce", "xmcp.attr.nonce",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_client_name,\r\n{ "Client-Name", "xmcp.attr.client-name",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_client_handle,\r\n{ "Client-Handle", "xmcp.attr.client-handle",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_version_major,\r\n{ "Protocol Major Version", "xmcp.attr.version.major",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_version_minor,\r\n{ "Protocol Minor Version", "xmcp.attr.version.minor",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_page_size,\r\n{ "Page-Size", "xmcp.attr.page-size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_client_label,\r\n{ "Client-Label", "xmcp.attr.client-label",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_keepalive,\r\n{ "Keepalive", "xmcp.attr.keepalive",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_serv_service,\r\n{ "Service ID", "xmcp.attr.service.service",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_serv_subservice,\r\n{ "Subservice ID", "xmcp.attr.service.subservice",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_serv_instance,\r\n{ "Instance ID", "xmcp.attr.service.instance",\r\nFT_GUID, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_servtrans_family,\r\n{ "Family", "xmcp.attr.service.transport.family",\r\nFT_UINT8, BASE_HEX, VALS(address_families), 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_servtrans_port,\r\n{ "Port", "xmcp.attr.service.transport.port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_servtrans_ipv4,\r\n{ "IPv4 Address", "xmcp.attr.service.transport.ipv4",\r\nFT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_servtrans_ipv6,\r\n{ "IPv6 Address", "xmcp.attr.service.transport.ipv6",\r\nFT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_service_protocol,\r\n{ "Protocol", "xmcp.attr.service.transport.protocol",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &ipproto_val_ext,\r\n0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_flag,\r\n{ "Flag", "xmcp.attr.flag",\r\nFT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_flag_type,\r\n{ "Flag Type", "xmcp.attr.flag.type",\r\nFT_UINT16, BASE_HEX, VALS(flag_types), 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_flag_value,\r\n{ "Flag Value", "xmcp.attr.flag.value",\r\nFT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_flag_removal_reason_network_withdraw,\r\n{ "Network Withdraw",\r\n"xmcp.attr.flag.removal-reason.network-withdraw",\r\nFT_BOOLEAN, 16, TFS(&tfs_true_false),\r\nXMCP_REMOVAL_REASON_NETWORK_WITHDRAW, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_flag_removal_reason_reserved,\r\n{ "Reserved", "xmcp.attr.flag.removal-reason.reserved",\r\nFT_UINT16, BASE_HEX, NULL, XMCP_REMOVAL_REASON_RESERVED, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_flag_trust,\r\n{ "Trust", "xmcp.attr.flag.trust",\r\nFT_UINT16, BASE_HEX, VALS(flag_trust_values), 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_flag_visibility_unauthenticated,\r\n{ "Visible to Unauthenticated Clients",\r\n"xmcp.attr.flag.service-visibility.unauthenticated",\r\nFT_BOOLEAN, 16, TFS(&tfs_yes_no),\r\nXMCP_SERVICE_VISIBILITY_UNAUTHENTICATED, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_flag_visibility_reserved,\r\n{ "Reserved", "xmcp.attr.flag.service-visibility.reserved",\r\nFT_UINT16, BASE_HEX, NULL,\r\nXMCP_SERVICE_VISIBILITY_RESERVED, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_service_version,\r\n{ "Service Version", "xmcp.attr.service.version",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_service_data,\r\n{ "Service Data", "xmcp.attr.service.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_subscription_id,\r\n{ "Subscription ID", "xmcp.attr.subscription-id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_service_removed_reason,\r\n{ "Service Removed Reason", "xmcp.attr.service-removed-reason",\r\nFT_UINT32, BASE_DEC, VALS(service_removed_reasons), 0x0, NULL, HFILL }\r\n},\r\n{ &xmcp_attr_domain,\r\n{ "Domain", "xmcp.attr.domain",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_xmcp,\r\n&ett_xmcp_type,\r\n&ett_xmcp_attr_all,\r\n&ett_xmcp_attr,\r\n&ett_xmcp_attr_flag\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_xmcp_data_following_message_integrity, { "xmcp.data_following_message_integrity", PI_PROTOCOL, PI_WARN, "Data following message-integrity", EXPFILL }},\r\n{ &ei_xmcp_attr_error_number_out_of_range, { "xmcp.attr.error.number.out_of_range", PI_PROTOCOL, PI_WARN, "Error number out of 0-99 range", EXPFILL }},\r\n{ &ei_xmcp_attr_error_code_unusual, { "xmcp.attr.error.unusual", PI_RESPONSE_CODE, PI_WARN, "Unusual error code", EXPFILL }},\r\n{ &ei_xmcp_attr_realm_incorrect, { "xmcp.attr.realm.incorrect", PI_PROTOCOL, PI_WARN, "Incorrect Realm", EXPFILL }},\r\n{ &ei_xmcp_attr_length_bad, { "xmcp.attr.length.bad", PI_PROTOCOL, PI_WARN, "Malformed IPv4 address", EXPFILL }},\r\n{ &ei_xmcp_xmcp_attr_servtrans_unknown, { "xmcp.attr.service.transport.unknown", PI_PROTOCOL, PI_WARN, "Unknown transport type", EXPFILL }},\r\n{ &ei_xmcp_attr_type_unknown, { "xmcp.attr.type.unknown", PI_PROTOCOL, PI_NOTE, "Unrecognized attribute type", EXPFILL }},\r\n{ &ei_xmcp_type_reserved_not_zero, { "xmcp.type.reserved.not_zero", PI_PROTOCOL, PI_WARN, "First two bits not zero", EXPFILL }},\r\n{ &ei_xmcp_message_class_reserved, { "xmcp.message_class.reserved", PI_PROTOCOL, PI_WARN, "Reserved message class", EXPFILL }},\r\n{ &ei_xmcp_error_response, { "xmcp.error_response", PI_RESPONSE_CODE, PI_NOTE, "Error Response", EXPFILL }},\r\n{ &ei_xmcp_msg_type_method_reserved, { "xmcp.msg_type_method.reserved", PI_PROTOCOL, PI_WARN, "Reserved message method", EXPFILL }},\r\n{ &ei_xmcp_length_bad, { "xmcp.length.bad", PI_PROTOCOL, PI_ERROR, "XMCP message length exceeds packet length", EXPFILL }},\r\n{ &ei_xmcp_magic_cookie_incorrect, { "xmcp.cookie.incorrect", PI_PROTOCOL, PI_WARN, "Magic cookie not correct for XMCP", EXPFILL }},\r\n{ &ei_xmcp_response_without_request, { "xmcp.response_without_request", PI_SEQUENCE, PI_NOTE, "Response without corresponding request", EXPFILL }},\r\n{ &ei_xmcp_new_session, { "xmcp.new_session", PI_SEQUENCE, PI_CHAT, "New session - Register", EXPFILL }},\r\n{ &ei_xmcp_session_termination, { "xmcp.session_termination", PI_SEQUENCE, PI_CHAT, "Session termination", EXPFILL }},\r\n};\r\nmodule_t *xmcp_module;\r\nexpert_module_t* expert_xmcp;\r\nproto_xmcp = proto_register_protocol("eXtensible Messaging Client Protocol",\r\n"XMCP", "xmcp");\r\nproto_register_field_array(proto_xmcp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_xmcp = expert_register_protocol(proto_xmcp);\r\nexpert_register_field_array(expert_xmcp, ei, array_length(ei));\r\nxmcp_module = prefs_register_protocol(proto_xmcp, proto_reg_handoff_xmcp);\r\nprefs_register_uint_preference(xmcp_module, "tcp.port", "XMCP TCP Port",\r\n"Set the port for XMCP messages (if other"\r\n" than the default of 4788)",\r\n10, &global_xmcp_tcp_port);\r\n}\r\nvoid\r\nproto_reg_handoff_xmcp(void)\r\n{\r\nstatic gboolean xmcp_prefs_initialized = FALSE;\r\nstatic dissector_handle_t xmcp_tcp_handle;\r\nstatic guint xmcp_tcp_port;\r\nif (!xmcp_prefs_initialized) {\r\nxmcp_tcp_handle = create_dissector_handle(dissect_xmcp_tcp, proto_xmcp);\r\nheur_dissector_add("tcp", dissect_xmcp_heur, "XMCP over TCP", "xmcp_tcp", proto_xmcp, HEURISTIC_ENABLE);\r\nmedia_type_dissector_table = find_dissector_table("media_type");\r\nxmcp_prefs_initialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", xmcp_tcp_port, xmcp_tcp_handle);\r\n}\r\nxmcp_tcp_port = global_xmcp_tcp_port;\r\ndissector_add_uint("tcp.port", global_xmcp_tcp_port, xmcp_tcp_handle);\r\n}
