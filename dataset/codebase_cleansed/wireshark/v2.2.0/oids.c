static void prepopulate_oids(void) {\r\nif (!oid_root.children) {\r\nchar* debug_env = getenv("WIRESHARK_DEBUG_MIBS");\r\nguint32 subid;\r\ndebuglevel = debug_env ? (int)strtoul(debug_env,NULL,10) : 0;\r\noid_root.children = wmem_tree_new(wmem_epan_scope());\r\nsubid = 0; oid_add("itu-t",1,&subid);\r\nsubid = 1; oid_add("iso",1,&subid);\r\nsubid = 2; oid_add("joint-iso-itu-t",1,&subid);\r\n}\r\n}\r\nstatic oid_info_t* add_oid(const char* name, oid_kind_t kind, const oid_value_type_t* type, oid_key_t* key, guint oid_len, guint32 *subids) {\r\nguint i = 0;\r\noid_info_t* c = &oid_root;\r\nprepopulate_oids();\r\noid_len--;\r\ndo {\r\noid_info_t* n = (oid_info_t *)wmem_tree_lookup32(c->children,subids[i]);\r\nif(n) {\r\nif (i == oid_len) {\r\nif (n->name) {\r\nif (!g_str_equal(n->name,name)) {\r\nD(2,("Renaming Oid from: %s -> %s, this means the same oid is registered more than once",n->name,name));\r\n}\r\nwmem_free(wmem_epan_scope(), n->name);\r\n}\r\nn->name = wmem_strdup(wmem_epan_scope(), name);\r\nif (! n->value_type) {\r\nn->value_type = type;\r\n}\r\nreturn n;\r\n}\r\n} else {\r\nn = wmem_new(wmem_epan_scope(), oid_info_t);\r\nn->subid = subids[i];\r\nn->kind = kind;\r\nn->children = wmem_tree_new(wmem_epan_scope());\r\nn->value_hfid = -2;\r\nn->key = key;\r\nn->parent = c;\r\nn->bits = NULL;\r\nwmem_tree_insert32(c->children,n->subid,n);\r\nif (i == oid_len) {\r\nn->name = wmem_strdup(wmem_epan_scope(), name);\r\nn->value_type = type;\r\nn->kind = kind;\r\nreturn n;\r\n} else {\r\nn->name = NULL;\r\nn->value_type = NULL;\r\nn->kind = OID_KIND_UNKNOWN;\r\n}\r\n}\r\nc = n;\r\n} while(++i);\r\ng_assert_not_reached();\r\nreturn NULL;\r\n}\r\nvoid oid_add(const char* name, guint oid_len, guint32 *subids) {\r\ng_assert(subids && *subids <= 2);\r\nif (oid_len) {\r\ngchar* sub = oid_subid2string(NULL, subids,oid_len);\r\nD(3,("\tOid (from subids): %s %s ",name?name:"NULL", sub));\r\nadd_oid(name,OID_KIND_UNKNOWN,NULL,NULL,oid_len,subids);\r\nwmem_free(NULL, sub);\r\n} else {\r\nD(1,("Failed to add Oid: %s (from subids)",name?name:"NULL"));\r\n}\r\n}\r\nvoid oid_add_from_string(const char* name, const gchar *oid_str) {\r\nguint32* subids;\r\nguint oid_len = oid_string2subid(NULL, oid_str, &subids);\r\nif (oid_len) {\r\ngchar* sub = oid_subid2string(NULL, subids,oid_len);\r\nD(3,("\tOid (from string): %s %s ",name?name:"NULL", sub));\r\nadd_oid(name,OID_KIND_UNKNOWN,NULL,NULL,oid_len,subids);\r\nwmem_free(NULL, sub);\r\n} else {\r\nD(1,("Failed to add Oid: %s %s ",name?name:"NULL", oid_str?oid_str:NULL));\r\n}\r\nwmem_free(NULL, subids);\r\n}\r\nextern void oid_add_from_encoded(const char* name, const guint8 *oid, gint oid_len) {\r\nguint32* subids = NULL;\r\nguint subids_len = oid_encoded2subid(NULL, oid, oid_len, &subids);\r\nif (subids_len) {\r\ngchar* sub = oid_subid2string(NULL, subids,subids_len);\r\nD(3,("\tOid (from encoded): %s %s ",name, sub));\r\nadd_oid(name,OID_KIND_UNKNOWN,NULL,NULL,subids_len,subids);\r\nwmem_free(NULL, sub);\r\n} else {\r\ngchar* bytestr = bytestring_to_str(NULL, oid, oid_len, ':');\r\nD(1,("Failed to add Oid: %s [%d]%s ",name?name:"NULL", oid_len, bytestr));\r\nwmem_free(NULL, bytestr);\r\n}\r\nwmem_free(NULL, subids);\r\n}\r\nstatic void smi_free(void *ptr) {\r\n#if (SMI_VERSION_MAJOR >= 0) && (SMI_VERSION_MINOR >= 4) && (SMI_VERSION_PATCHLEVEL >= 8)\r\nsmiFree(ptr);\r\n#else\r\n#ifdef _WIN32\r\n#error Invalid Windows libsmi version ?? !!\r\n#endif\r\n#define xx_free free\r\nxx_free(ptr);\r\n#endif\r\n}\r\nstatic void smi_error_handler(char *path, int line, int severity, char *msg, char *tag) {\r\ng_string_append_printf(smi_errors,"%s:%d %d %s %s\n",\r\npath ? path : "-",\r\nline, severity,\r\ntag ? tag : "-",\r\nmsg ? msg : "");\r\n}\r\nstatic void* smi_mod_copy_cb(void* dest, const void* orig, size_t len _U_) {\r\nconst smi_module_t* m = (const smi_module_t*)orig;\r\nsmi_module_t* d = (smi_module_t*)dest;\r\nd->name = g_strdup(m->name);\r\nreturn d;\r\n}\r\nstatic void smi_mod_free_cb(void* p) {\r\nsmi_module_t* m = (smi_module_t*)p;\r\ng_free(m->name);\r\n}\r\nstatic char* alnumerize(const char* name) {\r\nchar* s = g_strdup(name);\r\nchar* r = s;\r\nchar* w = r;\r\nchar c;\r\nfor (;(c = *r); r++) {\r\nif (g_ascii_isalnum(c) || c == '_' || c == '-' || c == '.') {\r\n*(w++) = c;\r\n} else if (c == ':' && r[1] == ':') {\r\n*(w++) = '.';\r\n}\r\n}\r\n*w = '\0';\r\nreturn s;\r\n}\r\nstatic const oid_value_type_t* get_typedata(SmiType* smiType) {\r\nstatic const struct _type_mapping_t {\r\nconst char* name;\r\nSmiBasetype base;\r\nconst oid_value_type_t* type;\r\n} types[] = {\r\n{"IpAddress", SMI_BASETYPE_UNKNOWN, &ipv4_type},\r\n{"InetAddressIPv4",SMI_BASETYPE_UNKNOWN,&ipv4_type},\r\n{"InetAddressIPv6",SMI_BASETYPE_UNKNOWN,&ipv6_type},\r\n{"NetworkAddress",SMI_BASETYPE_UNKNOWN,&ipv4_type},\r\n{"MacAddress",SMI_BASETYPE_UNKNOWN,&ether_type},\r\n{"TimeTicks",SMI_BASETYPE_UNKNOWN,&timeticks_type},\r\n{"Ipv6Address",SMI_BASETYPE_UNKNOWN,&ipv6_type},\r\n{"TimeStamp",SMI_BASETYPE_UNKNOWN,&timeticks_type},\r\n{"DisplayString",SMI_BASETYPE_UNKNOWN,&string_type},\r\n{"SnmpAdminString",SMI_BASETYPE_UNKNOWN,&string_type},\r\n{"DateAndTime",SMI_BASETYPE_UNKNOWN,&date_and_time_type},\r\n{"Counter",SMI_BASETYPE_UNKNOWN,&counter32_type},\r\n{"Counter32",SMI_BASETYPE_UNKNOWN,&counter32_type},\r\n{"Unsigned32",SMI_BASETYPE_UNKNOWN,&unsigned32_type},\r\n{"Gauge",SMI_BASETYPE_UNKNOWN,&unsigned32_type},\r\n{"Gauge32",SMI_BASETYPE_UNKNOWN,&unsigned32_type},\r\n{"NsapAddress",SMI_BASETYPE_UNKNOWN,&nsap_type},\r\n{"i32",SMI_BASETYPE_INTEGER32,&integer_type},\r\n{"octets",SMI_BASETYPE_OCTETSTRING,&bytes_type},\r\n{"oid",SMI_BASETYPE_OBJECTIDENTIFIER,&oid_type},\r\n{"u32",SMI_BASETYPE_UNSIGNED32,&unsigned32_type},\r\n{"u64",SMI_BASETYPE_UNSIGNED64,&counter64_type},\r\n{"f32",SMI_BASETYPE_FLOAT32,&float_type},\r\n{"f64",SMI_BASETYPE_FLOAT64,&double_type},\r\n{"f128",SMI_BASETYPE_FLOAT128,&bytes_type},\r\n{"enum",SMI_BASETYPE_ENUM,&integer_type},\r\n{"bits",SMI_BASETYPE_BITS,&bytes_type},\r\n{"unk",SMI_BASETYPE_UNKNOWN,&unknown_type},\r\n{NULL,SMI_BASETYPE_UNKNOWN,NULL}\r\n};\r\nconst struct _type_mapping_t* t;\r\nSmiType* sT = smiType;\r\nif (!smiType) return NULL;\r\ndo {\r\nfor (t = types; t->type ; t++ ) {\r\nchar* name = smiRenderType(sT, SMI_RENDER_NAME);\r\nif (name && t->name && g_str_equal(name, t->name )) {\r\nsmi_free(name);\r\nreturn t->type;\r\n}\r\nif (name) {\r\nsmi_free (name);\r\n}\r\n}\r\n} while(( sT = smiGetParentType(sT) ));\r\nfor (t = types; t->type ; t++ ) {\r\nif(smiType->basetype == t->base) {\r\nreturn t->type;\r\n}\r\n}\r\nreturn &unknown_type;\r\n}\r\nstatic guint get_non_implicit_size(SmiType* sT) {\r\nSmiRange *sR;\r\nguint size = 0xffffffff;\r\nswitch (sT->basetype) {\r\ncase SMI_BASETYPE_OCTETSTRING:\r\ncase SMI_BASETYPE_OBJECTIDENTIFIER:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nfor ( ; sT; sT = smiGetParentType(sT) ) {\r\nfor (sR = smiGetFirstRange(sT); sR ; sR = smiGetNextRange(sR)) {\r\nif (size == 0xffffffff) {\r\nif (sR->minValue.value.unsigned32 == sR->maxValue.value.unsigned32) {\r\nsize = (guint32)sR->minValue.value.unsigned32;\r\n} else {\r\nreturn 0;\r\n}\r\n} else {\r\nif (sR->minValue.value.unsigned32 != size || sR->maxValue.value.unsigned32 != size) {\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\nreturn size == 0xffffffff ? 0 : size;\r\n}\r\nstatic inline oid_kind_t smikind(SmiNode* sN, oid_key_t** key_p) {\r\n*key_p = NULL;\r\nswitch(sN->nodekind) {\r\ncase SMI_NODEKIND_ROW: {\r\nSmiElement* sE;\r\noid_key_t* kl = NULL;\r\nconst oid_value_type_t* typedata = NULL;\r\ngboolean implied;\r\nswitch (sN->indexkind) {\r\ncase SMI_INDEX_INDEX:\r\nbreak;\r\ncase SMI_INDEX_AUGMENT:\r\ncase SMI_INDEX_REORDER:\r\ncase SMI_INDEX_SPARSE:\r\ncase SMI_INDEX_EXPAND:\r\nsN = smiGetRelatedNode(sN);\r\nbreak;\r\ncase SMI_INDEX_UNKNOWN:\r\nreturn OID_KIND_UNKNOWN;\r\n};\r\nimplied = sN->implied;\r\nfor (sE = smiGetFirstElement(sN); sE; sE = smiGetNextElement(sE)) {\r\nSmiNode* elNode = smiGetElementNode(sE) ;\r\nSmiType* elType = smiGetNodeType(elNode);\r\noid_key_t* k;\r\nguint non_implicit_size = 0;\r\nchar *oid1, *oid2;\r\nif (elType) {\r\nnon_implicit_size = get_non_implicit_size(elType);\r\n}\r\ntypedata = get_typedata(elType);\r\nk = g_new(oid_key_t,1);\r\noid1 = smiRenderOID(sN->oidlen, sN->oid, SMI_RENDER_QUALIFIED);\r\noid2 = smiRenderOID(elNode->oidlen, elNode->oid, SMI_RENDER_NAME);\r\nk->name = g_strconcat(oid1, ".", oid2, NULL);\r\nsmi_free (oid1);\r\nsmi_free (oid2);\r\nk->hfid = -2;\r\nk->ft_type = typedata ? typedata->ft_type : FT_BYTES;\r\nk->display = typedata ? typedata->display : BASE_NONE;\r\nk->next = NULL;\r\nif (typedata) {\r\nk->key_type = typedata->keytype;\r\nk->num_subids = typedata->keysize;\r\n} else {\r\nif (elType) {\r\nswitch (elType->basetype) {\r\ncase SMI_BASETYPE_BITS:\r\ncase SMI_BASETYPE_OCTETSTRING: {\r\nk->key_type = OID_KEY_TYPE_BYTES;\r\nk->num_subids = non_implicit_size;\r\nbreak;\r\n}\r\ncase SMI_BASETYPE_ENUM:\r\ncase SMI_BASETYPE_OBJECTIDENTIFIER:\r\ncase SMI_BASETYPE_INTEGER32:\r\ncase SMI_BASETYPE_UNSIGNED32:\r\ncase SMI_BASETYPE_INTEGER64:\r\ncase SMI_BASETYPE_UNSIGNED64:\r\nk->key_type = OID_KEY_TYPE_INTEGER;\r\nk->num_subids = 1;\r\nbreak;\r\ndefault:\r\nk->key_type = OID_KEY_TYPE_WRONG;\r\nk->num_subids = 0;\r\nbreak;\r\n}\r\n} else {\r\nk->key_type = OID_KEY_TYPE_WRONG;\r\nk->num_subids = 0;\r\nbreak;\r\n}\r\n}\r\nif (!*key_p) *key_p = k;\r\nif (kl) kl->next = k;\r\nkl = k;\r\n}\r\nif (implied && kl) {\r\nswitch (kl->key_type) {\r\ncase OID_KEY_TYPE_BYTES: kl->key_type = OID_KEY_TYPE_IMPLIED_BYTES; break;\r\ncase OID_KEY_TYPE_STRING: kl->key_type = OID_KEY_TYPE_IMPLIED_STRING; break;\r\ncase OID_KEY_TYPE_OID: kl->key_type = OID_KEY_TYPE_IMPLIED_OID; break;\r\ndefault: break;\r\n}\r\n}\r\nreturn OID_KIND_ROW;\r\n}\r\ncase SMI_NODEKIND_NODE: return OID_KIND_NODE;\r\ncase SMI_NODEKIND_SCALAR: return OID_KIND_SCALAR;\r\ncase SMI_NODEKIND_TABLE: return OID_KIND_TABLE;\r\ncase SMI_NODEKIND_COLUMN: return OID_KIND_COLUMN;\r\ncase SMI_NODEKIND_NOTIFICATION: return OID_KIND_NOTIFICATION;\r\ncase SMI_NODEKIND_GROUP: return OID_KIND_GROUP;\r\ncase SMI_NODEKIND_COMPLIANCE: return OID_KIND_COMPLIANCE;\r\ncase SMI_NODEKIND_CAPABILITIES: return OID_KIND_CAPABILITIES;\r\ndefault: return OID_KIND_UNKNOWN;\r\n}\r\n}\r\nstatic void unregister_mibs(void) {\r\n}\r\nstatic void restart_needed_warning(void) {\r\nif (oids_init_done)\r\nreport_failure("Wireshark needs to be restarted for these changes to take effect");\r\n}\r\nstatic void register_mibs(void) {\r\nSmiModule *smiModule;\r\nSmiNode *smiNode;\r\nguint i;\r\nint proto_mibs = -1;\r\nwmem_array_t* hfa;\r\nGArray* etta;\r\ngchar* path_str;\r\nif (!load_smi_modules) {\r\nD(1,("OID resolution not enabled"));\r\nreturn;\r\n}\r\nif (oids_init_done) {\r\nD(1,("Exiting register_mibs() to avoid double registration of MIBs proto."));\r\nreturn;\r\n} else {\r\noids_init_done = TRUE;\r\n}\r\nhfa = wmem_array_new(wmem_epan_scope(), sizeof(hf_register_info));\r\netta = g_array_new(FALSE,TRUE,sizeof(gint*));\r\nsmiInit(NULL);\r\nsmi_errors = g_string_new("");\r\nsmiSetErrorHandler(smi_error_handler);\r\npath_str = oid_get_default_mib_path();\r\nD(1,("SMI Path: '%s'",path_str));\r\nsmiSetPath(path_str);\r\nfor(i=0;i<num_smi_modules;i++) {\r\nif (!smi_modules[i].name) continue;\r\nif (smiIsLoaded(smi_modules[i].name)) {\r\ncontinue;\r\n} else {\r\nchar* mod_name = smiLoadModule(smi_modules[i].name);\r\nif (mod_name)\r\nD(2,("Loaded: '%s'[%u] as %s",smi_modules[i].name,i,mod_name ));\r\nelse\r\nD(1,("Failed to load: '%s'[%u]",smi_modules[i].name,i));\r\n}\r\n}\r\nif (smi_errors->len) {\r\nif (!suppress_smi_errors) {\r\nreport_failure("The following errors were found while loading the MIBS:\n%s\n\n"\r\n"The Current Path is: %s\n\nYou can avoid this error message "\r\n"by removing the missing MIB modules at Edit -> Preferences"\r\n" -> Name Resolution -> SMI (MIB and PIB) modules or by "\r\n"installing them.\n" , smi_errors->str , path_str);\r\n}\r\nD(1,("Errors while loading:\n%s\n",smi_errors->str));\r\n}\r\ng_free(path_str);\r\ng_string_free(smi_errors,TRUE);\r\nfor (smiModule = smiGetFirstModule();\r\nsmiModule;\r\nsmiModule = smiGetNextModule(smiModule)) {\r\nD(3,("\tModule: %s", smiModule->name));\r\nif (smiModule->conformance == 1) {\r\nif (!suppress_smi_errors) {\r\nreport_failure("Stopped processing module %s due to "\r\n"error(s) to prevent potential crash in libsmi.\n"\r\n"Module's conformance level: %d.\n"\r\n"See details at: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=560325\n",\r\nsmiModule->name, smiModule->conformance);\r\n}\r\ncontinue;\r\n}\r\nfor (smiNode = smiGetFirstNode(smiModule, SMI_NODEKIND_ANY);\r\nsmiNode;\r\nsmiNode = smiGetNextNode(smiNode, SMI_NODEKIND_ANY)) {\r\nSmiType* smiType = smiGetNodeType(smiNode);\r\nconst oid_value_type_t* typedata = get_typedata(smiType);\r\noid_key_t* key;\r\noid_kind_t kind = smikind(smiNode,&key);\r\nchar *sub;\r\nchar *oid = smiRenderOID(smiNode->oidlen, smiNode->oid, SMI_RENDER_QUALIFIED);\r\noid_info_t* oid_data = add_oid(oid,\r\nkind,\r\ntypedata,\r\nkey,\r\nsmiNode->oidlen,\r\nsmiNode->oid);\r\nsmi_free (oid);\r\nsub = oid_subid2string(NULL, smiNode->oid, smiNode->oidlen);\r\nD(4,("\t\tNode: kind=%d oid=%s name=%s ",\r\noid_data->kind, sub, oid_data->name));\r\nwmem_free(NULL, sub);\r\nif ( typedata && oid_data->value_hfid == -2 ) {\r\nSmiNamedNumber* smiEnum;\r\nhf_register_info hf;\r\nhf.p_id = &(oid_data->value_hfid);\r\nhf.hfinfo.name = g_strdup(oid_data->name);\r\nhf.hfinfo.abbrev = alnumerize(oid_data->name);\r\nhf.hfinfo.type = typedata->ft_type;\r\nhf.hfinfo.display = typedata->display;\r\nhf.hfinfo.strings = NULL;\r\nhf.hfinfo.bitmask = 0;\r\nhf.hfinfo.blurb = smiRenderOID(smiNode->oidlen, smiNode->oid, SMI_RENDER_ALL);\r\nHFILL_INIT(hf);\r\nif (strcmp(hf.hfinfo.blurb, hf.hfinfo.name) == 0) {\r\nsmi_free((void *) hf.hfinfo.blurb);\r\nhf.hfinfo.blurb = NULL;\r\n}\r\noid_data->value_hfid = -1;\r\nif ( IS_ENUMABLE(hf.hfinfo.type) && (smiEnum = smiGetFirstNamedNumber(smiType))) {\r\nGArray* vals = g_array_new(TRUE,TRUE,sizeof(value_string));\r\nfor(;smiEnum; smiEnum = smiGetNextNamedNumber(smiEnum)) {\r\nif (smiEnum->name) {\r\nvalue_string val;\r\nval.value = (guint32)smiEnum->value.value.integer32;\r\nval.strptr = g_strdup(smiEnum->name);\r\ng_array_append_val(vals,val);\r\n}\r\n}\r\nhf.hfinfo.strings = vals->data;\r\ng_array_free(vals,FALSE);\r\n}\r\n#if 0\r\n} else if (smiType->basetype == SMI_BASETYPE_BITS && ( smiEnum = smiGetFirstNamedNumber(smiType) )) {\r\nguint n = 0;\r\noid_bits_info_t* bits = g_malloc(sizeof(oid_bits_info_t));\r\ngint* ettp = &(bits->ett);\r\nbits->num = 0;\r\nbits->ett = -1;\r\ng_array_append_val(etta,ettp);\r\nfor(;smiEnum; smiEnum = smiGetNextNamedNumber(smiEnum), bits->num++);\r\nbits->data = g_malloc(sizeof(struct _oid_bit_t)*bits->num);\r\nfor(smiEnum = smiGetFirstNamedNumber(smiType),n=0;\r\nsmiEnum;\r\nsmiEnum = smiGetNextNamedNumber(smiEnum),n++) {\r\nguint mask = 1 << (smiEnum->value.value.integer32 % 8);\r\nchar* base = alnumerize(oid_data->name);\r\nchar* ext = alnumerize(smiEnum->name);\r\nhf_register_info hf2 = { &(bits->data[n].hfid), { NULL, NULL, FT_UINT8, BASE_HEX, NULL, mask, NULL, HFILL }};\r\nbits->data[n].hfid = -1;\r\nbits->data[n].offset = smiEnum->value.value.integer32 / 8;\r\nhf2.hfinfo.name = g_strconcat("%s:%s",oid_data->name, ":", smiEnum->name, NULL);\r\nhf2.hfinfo.abbrev = g_strconcat(base, ".", ext, NULL);\r\ng_free(base);\r\ng_free(ext);\r\ng_array_append_val(hfa,hf2);\r\n}\r\n#endif\r\nwmem_array_append_one(hfa,hf);\r\n}\r\nif ((key = oid_data->key)) {\r\nfor(; key; key = key->next) {\r\nhf_register_info hf;\r\nhf.p_id = &(key->hfid);\r\nhf.hfinfo.name = key->name;\r\nhf.hfinfo.abbrev = alnumerize(key->name);\r\nhf.hfinfo.type = key->ft_type;\r\nhf.hfinfo.display = key->display;\r\nhf.hfinfo.strings = NULL;\r\nhf.hfinfo.bitmask = 0;\r\nhf.hfinfo.blurb = NULL;\r\nHFILL_INIT(hf);\r\nD(5,("\t\t\tIndex: name=%s subids=%u key_type=%d",\r\nkey->name, key->num_subids, key->key_type ));\r\nif (key->hfid == -2) {\r\nwmem_array_append_one(hfa,hf);\r\nkey->hfid = -1;\r\n} else {\r\ng_free((void*)hf.hfinfo.abbrev);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nproto_mibs = proto_register_protocol("MIBs", "MIBS", "mibs");\r\nproto_register_field_array(proto_mibs, (hf_register_info*)wmem_array_get_raw(hfa), wmem_array_get_count(hfa));\r\nproto_register_subtree_array((gint**)(void*)etta->data, etta->len);\r\ng_array_free(etta,TRUE);\r\n}\r\nvoid oid_pref_init(module_t *nameres)\r\n{\r\n#ifdef HAVE_LIBSMI\r\nstatic uat_field_t smi_fields[] = {\r\nUAT_FLD_CSTRING(smi_mod,name,"Module name","The module's name"),\r\nUAT_END_FIELDS\r\n};\r\nstatic uat_field_t smi_paths_fields[] = {\r\nUAT_FLD_DIRECTORYNAME(smi_mod,name,"Directory path","The directory name"),\r\nUAT_END_FIELDS\r\n};\r\nprefs_register_bool_preference(nameres, "load_smi_modules",\r\n"Enable OID resolution",\r\n"You must restart Wireshark for this change to take effect",\r\n&load_smi_modules);\r\nprefs_register_bool_preference(nameres, "suppress_smi_errors",\r\n"Suppress SMI errors",\r\n"Some errors can be ignored. If unsure, set to false.",\r\n&suppress_smi_errors);\r\nsmi_paths_uat = uat_new("SMI Paths",\r\nsizeof(smi_module_t),\r\n"smi_paths",\r\nFALSE,\r\n(void**)&smi_paths,\r\n&num_smi_paths,\r\nUAT_AFFECTS_DISSECTION,\r\n"ChSNMPSMIPaths",\r\nsmi_mod_copy_cb,\r\nNULL,\r\nsmi_mod_free_cb,\r\nrestart_needed_warning,\r\nsmi_paths_fields);\r\nprefs_register_uat_preference(nameres,\r\n"smi_paths",\r\n"SMI (MIB and PIB) paths",\r\n"Search paths for SMI (MIB and PIB) modules. You must\n"\r\n"restart Wireshark for these changes to take effect.",\r\nsmi_paths_uat);\r\nsmi_modules_uat = uat_new("SMI Modules",\r\nsizeof(smi_module_t),\r\n"smi_modules",\r\nFALSE,\r\n(void**)&smi_modules,\r\n&num_smi_modules,\r\nUAT_AFFECTS_DISSECTION,\r\n"ChSNMPSMIModules",\r\nsmi_mod_copy_cb,\r\nNULL,\r\nsmi_mod_free_cb,\r\nrestart_needed_warning,\r\nsmi_fields);\r\nprefs_register_uat_preference(nameres,\r\n"smi_modules",\r\n"SMI (MIB and PIB) modules",\r\n"List of enabled SMI (MIB and PIB) modules. You must\n"\r\n"restart Wireshark for these changes to take effect.",\r\nsmi_modules_uat);\r\n#else\r\nprefs_register_static_text_preference(nameres, "load_smi_modules_static",\r\n"Enable OID resolution: N/A",\r\n"Support for OID resolution was not compiled into this version of Wireshark");\r\nprefs_register_static_text_preference(nameres, "suppress_smi_errors_static",\r\n"Suppress SMI errors: N/A",\r\n"Support for OID resolution was not compiled into this version of Wireshark");\r\nprefs_register_static_text_preference(nameres, "smi_module_path",\r\n"SMI (MIB and PIB) modules and paths: N/A",\r\n"Support for OID resolution was not compiled into this version of Wireshark");\r\n#endif\r\n}\r\nvoid oids_init(void) {\r\nprepopulate_oids();\r\n#ifdef HAVE_LIBSMI\r\nregister_mibs();\r\n#else\r\nD(1,("libsmi disabled oid resolution not enabled"));\r\n#endif\r\n}\r\nvoid oids_cleanup(void) {\r\n#ifdef HAVE_LIBSMI\r\nunregister_mibs();\r\n#else\r\nD(1,("libsmi disabled oid resolution not enabled"));\r\n#endif\r\n}\r\nchar* oid_subid2string(wmem_allocator_t *scope, guint32* subids, guint len) {\r\nreturn rel_oid_subid2string(scope, subids, len, TRUE);\r\n}\r\nchar* rel_oid_subid2string(wmem_allocator_t *scope, guint32* subids, guint len, gboolean is_absolute) {\r\nchar *s, *w;\r\nif(!subids || len == 0)\r\nreturn wmem_strdup(scope, "*** Empty OID ***");\r\ns = (char *)wmem_alloc0(scope, ((len)*11)+2);\r\nw = s;\r\nif (!is_absolute)\r\n*w++ = '.';\r\ndo {\r\n#ifdef _WIN32\r\nw += _snprintf(w,12,"%u.",*subids++);\r\n#else\r\nw += g_snprintf(w,12,"%u.",*subids++);\r\n#endif\r\n} while(--len);\r\nif (w!=s) *(w-1) = '\0'; else *(s) = '\0';\r\nreturn s;\r\n}\r\nstatic guint check_num_oid(const char* str) {\r\nconst char* r = str;\r\nchar c = '.';\r\nguint n = 0;\r\nD(8,("check_num_oid: '%s'",str));\r\nif (!r) return 0;\r\ndo {\r\nD(9,("\tcheck_num_oid: '%c' %u",*r,n));\r\nswitch(*r) {\r\ncase '.': case '\0':\r\nn++;\r\nif (c == '.') return 0;\r\nbreak;\r\ncase '1' : case '2' : case '3' : case '4' : case '5' :\r\ncase '6' : case '7' : case '8' : case '9' : case '0' :\r\ncontinue;\r\ndefault:\r\nreturn 0;\r\n}\r\n} while((c = *r++));\r\nreturn n;\r\n}\r\nguint oid_string2subid(wmem_allocator_t *scope, const char* str, guint32** subids_p) {\r\nconst char* r = str;\r\nguint32* subids;\r\nguint32* subids_overflow;\r\nguint n = check_num_oid(str);\r\nguint64 subid = 0;\r\nD(6,("oid_string2subid: str='%s'",str));\r\nif (!n) {\r\n*subids_p = NULL;\r\nreturn 0;\r\n}\r\n*subids_p = subids = wmem_alloc0_array(scope, guint32, n);\r\nsubids_overflow = subids + n;\r\ndo switch(*r) {\r\ncase '.':\r\nsubid = 0;\r\nsubids++;\r\ncontinue;\r\ncase '1' : case '2' : case '3' : case '4' : case '5' :\r\ncase '6' : case '7' : case '8' : case '9' : case '0' :\r\nsubid *= 10;\r\nsubid += *r - '0';\r\nif( subids >= subids_overflow || subid > 0xffffffff) {\r\n*subids_p=NULL;\r\nreturn 0;\r\n}\r\n*(subids) *= 10;\r\n*(subids) += *r - '0';\r\ncontinue;\r\ncase '\0':\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n} while(*r++);\r\nreturn n;\r\n}\r\nguint oid_encoded2subid(wmem_allocator_t *scope, const guint8 *oid_bytes, gint oid_len, guint32** subids_p) {\r\nreturn oid_encoded2subid_sub(scope, oid_bytes, oid_len, subids_p, TRUE);\r\n}\r\nguint oid_encoded2subid_sub(wmem_allocator_t *scope, const guint8 *oid_bytes, gint oid_len, guint32** subids_p,\r\ngboolean is_first) {\r\ngint i;\r\nguint n = is_first ? 1 : 0;\r\nguint32* subids;\r\nguint32* subid_overflow;\r\nguint64 subid = 0;\r\nfor (i=0; i<oid_len; i++) { if (! (oid_bytes[i] & 0x80 )) n++; }\r\n*subids_p = subids = (guint32 *)wmem_alloc(scope, sizeof(guint32)*n);\r\nsubid_overflow = subids+n;\r\nif (is_first && n == 1) {\r\n*subids = 0;\r\nreturn n;\r\n}\r\nelse if (!is_first && n == 0) {\r\nreturn n;\r\n}\r\nfor (i=0; i<oid_len; i++){\r\nguint8 byte = oid_bytes[i];\r\nsubid <<= 7;\r\nsubid |= byte & 0x7F;\r\nif (byte & 0x80) {\r\ncontinue;\r\n}\r\nif (is_first) {\r\nguint32 subid0 = 0;\r\nif (subid >= 40) { subid0++; subid-=40; }\r\nif (subid >= 40) { subid0++; subid-=40; }\r\n*subids++ = subid0;\r\nis_first = FALSE;\r\n}\r\nif( subids >= subid_overflow || subid > 0xffffffff) {\r\nwmem_free(scope, *subids_p);\r\n*subids_p = NULL;\r\nreturn 0;\r\n}\r\n*subids++ = (guint32)subid;\r\nsubid = 0;\r\n}\r\ng_assert(subids == subid_overflow);\r\nreturn n;\r\n}\r\noid_info_t* oid_get(guint len, guint32* subids, guint* matched, guint* left) {\r\noid_info_t* curr_oid = &oid_root;\r\nguint i;\r\nif(!(subids && *subids <= 2)) {\r\n*matched = 0;\r\n*left = len;\r\nreturn curr_oid;\r\n}\r\nfor( i=0; i < len; i++) {\r\noid_info_t* next_oid = (oid_info_t *)wmem_tree_lookup32(curr_oid->children,subids[i]);\r\nif (next_oid) {\r\ncurr_oid = next_oid;\r\n} else {\r\ngoto done;\r\n}\r\n}\r\ndone:\r\n*matched = i;\r\n*left = len - i;\r\nreturn curr_oid;\r\n}\r\noid_info_t* oid_get_from_encoded(wmem_allocator_t *scope, const guint8 *bytes, gint byteslen, guint32** subids_p, guint* matched_p, guint* left_p) {\r\nguint subids_len = oid_encoded2subid(scope, bytes, byteslen, subids_p);\r\nreturn oid_get(subids_len, *subids_p, matched_p, left_p);\r\n}\r\noid_info_t* oid_get_from_string(wmem_allocator_t *scope, const gchar *oid_str, guint32** subids_p, guint* matched, guint* left) {\r\nguint subids_len = oid_string2subid(scope, oid_str, subids_p);\r\nreturn oid_get(subids_len, *subids_p, matched, left);\r\n}\r\ngchar *oid_resolved_from_encoded(wmem_allocator_t *scope, const guint8 *oid, gint oid_len) {\r\nguint32 *subid_oid = NULL;\r\ngchar * ret;\r\nguint subid_oid_length = oid_encoded2subid(NULL, oid, oid_len, &subid_oid);\r\nret = oid_resolved(scope, subid_oid_length, subid_oid);\r\nwmem_free(NULL, subid_oid);\r\nreturn ret;\r\n}\r\ngchar *rel_oid_resolved_from_encoded(wmem_allocator_t *scope, const guint8 *oid, gint oid_len) {\r\nguint32 *subid_oid = NULL;\r\ngchar* ret;\r\nguint subid_oid_length = oid_encoded2subid_sub(NULL, oid, oid_len, &subid_oid, FALSE);\r\nret = rel_oid_subid2string(scope, subid_oid, subid_oid_length, FALSE);\r\nwmem_free(NULL, subid_oid);\r\nreturn ret;\r\n}\r\nguint oid_subid2encoded(wmem_allocator_t *scope, guint subids_len, guint32* subids, guint8** bytes_p) {\r\nguint bytelen = 0;\r\nguint i;\r\nguint32 subid;\r\nguint8* b;\r\nif ( !subids || subids_len <= 1) {\r\n*bytes_p = NULL;\r\nreturn 0;\r\n}\r\nfor (subid=subids[0] * 40, i = 1; i<subids_len; i++, subid=0) {\r\nsubid += subids[i];\r\nif (subid <= 0x0000007F) {\r\nbytelen += 1;\r\n} else if (subid <= 0x00003FFF ) {\r\nbytelen += 2;\r\n} else if (subid <= 0x001FFFFF ) {\r\nbytelen += 3;\r\n} else if (subid <= 0x0FFFFFFF ) {\r\nbytelen += 4;\r\n} else {\r\nbytelen += 5;\r\n}\r\n}\r\n*bytes_p = b = (guint8 *)wmem_alloc(scope, bytelen);\r\nfor (subid=subids[0] * 40, i = 1; i<subids_len; i++, subid=0) {\r\nguint len;\r\nsubid += subids[i];\r\nif ((subid <= 0x0000007F )) len = 1;\r\nelse if ((subid <= 0x00003FFF )) len = 2;\r\nelse if ((subid <= 0x001FFFFF )) len = 3;\r\nelse if ((subid <= 0x0FFFFFFF )) len = 4;\r\nelse len = 5;\r\nswitch(len) {\r\ndefault: *bytes_p=NULL; return 0;\r\ncase 5: *(b++) = ((subid & 0xF0000000) >> 28) | 0x80;\r\ncase 4: *(b++) = ((subid & 0x0FE00000) >> 21) | 0x80;\r\ncase 3: *(b++) = ((subid & 0x001FC000) >> 14) | 0x80;\r\ncase 2: *(b++) = ((subid & 0x00003F80) >> 7) | 0x80;\r\ncase 1: *(b++) = subid & 0x0000007F ; break;\r\n}\r\n}\r\nreturn bytelen;\r\n}\r\ngchar* oid_encoded2string(wmem_allocator_t *scope, const guint8* encoded, guint len) {\r\nguint32* subids = NULL;\r\ngchar* ret;\r\nguint subids_len = oid_encoded2subid(NULL, encoded, len, &subids);\r\nif (subids_len) {\r\nret = oid_subid2string(scope, subids,subids_len);\r\n} else {\r\nret = wmem_strdup(scope, "");\r\n}\r\nwmem_free(NULL, subids);\r\nreturn ret;\r\n}\r\ngchar* rel_oid_encoded2string(wmem_allocator_t *scope, const guint8* encoded, guint len) {\r\nguint32* subids = NULL;\r\ngchar* ret;\r\nguint subids_len = oid_encoded2subid_sub(NULL, encoded, len, &subids, FALSE);\r\nif (subids_len) {\r\nret = rel_oid_subid2string(scope, subids,subids_len, FALSE);\r\n} else {\r\nret = wmem_strdup(scope, "");\r\n}\r\nwmem_free(NULL, subids);\r\nreturn ret;\r\n}\r\nguint oid_string2encoded(wmem_allocator_t *scope, const char *oid_str, guint8 **bytes) {\r\nguint32* subids;\r\nguint32 subids_len;\r\nguint byteslen;\r\nif ( (subids_len = oid_string2subid(NULL, oid_str, &subids)) &&\r\n(byteslen = oid_subid2encoded(scope, subids_len, subids, bytes)) ) {\r\nwmem_free(NULL, subids);\r\nreturn byteslen;\r\n}\r\nwmem_free(NULL, subids);\r\nreturn 0;\r\n}\r\ngchar *oid_resolved_from_string(wmem_allocator_t *scope, const gchar *oid_str) {\r\nguint32 *subid_oid;\r\nguint subid_oid_length;\r\ngchar *resolved;\r\nsubid_oid_length = oid_string2subid(NULL, oid_str, &subid_oid);\r\nresolved = oid_resolved(scope, subid_oid_length, subid_oid);\r\nwmem_free(NULL, subid_oid);\r\nreturn resolved;\r\n}\r\ngchar *oid_resolved(wmem_allocator_t *scope, guint32 num_subids, guint32* subids) {\r\nguint matched;\r\nguint left;\r\noid_info_t* oid;\r\nif(! (subids && *subids <= 2 ))\r\nreturn wmem_strdup(scope, "*** Malformed OID ***");\r\noid = oid_get(num_subids, subids, &matched, &left);\r\nwhile (! oid->name ) {\r\nif (!(oid = oid->parent)) {\r\nreturn oid_subid2string(scope, subids,num_subids);\r\n}\r\nleft++;\r\nmatched--;\r\n}\r\nif (left) {\r\ngchar *ret,\r\n*str1 = oid_subid2string(NULL, subids,matched),\r\n*str2 = oid_subid2string(NULL, &(subids[matched]),left);\r\nret = wmem_strconcat(scope, oid->name ? oid->name : str1, ".", str2, NULL);\r\nwmem_free(NULL, str1);\r\nwmem_free(NULL, str2);\r\nreturn ret;\r\n} else {\r\nreturn oid->name ? wmem_strdup(scope, oid->name) : oid_subid2string(scope, subids,matched);\r\n}\r\n}\r\nextern void oid_both(wmem_allocator_t *scope, guint oid_len, guint32 *subids, gchar** resolved_p, gchar** numeric_p) {\r\n*resolved_p = oid_resolved(scope, oid_len,subids);\r\n*numeric_p = oid_subid2string(scope, subids,oid_len);\r\n}\r\nextern void oid_both_from_encoded(wmem_allocator_t *scope, const guint8 *oid, gint oid_len, gchar** resolved_p, gchar** numeric_p) {\r\nguint32* subids = NULL;\r\nguint subids_len = oid_encoded2subid(NULL, oid, oid_len, &subids);\r\n*resolved_p = oid_resolved(scope, subids_len,subids);\r\n*numeric_p = oid_subid2string(scope, subids,subids_len);\r\nwmem_free(NULL, subids);\r\n}\r\nvoid oid_both_from_string(wmem_allocator_t *scope, const gchar *oid_str, gchar** resolved_p, gchar** numeric_p) {\r\nguint32 *subids;\r\nguint subids_len;\r\nsubids_len = oid_string2subid(NULL, oid_str, &subids);\r\n*resolved_p = oid_resolved(scope, subids_len,subids);\r\n*numeric_p = oid_subid2string(scope, subids,subids_len);\r\nwmem_free(NULL, subids);\r\n}\r\nextern gchar *\r\noid_get_default_mib_path(void) {\r\n#ifdef HAVE_LIBSMI\r\nGString* path_str;\r\nchar *path;\r\nguint i;\r\npath_str = g_string_new("");\r\nif (!load_smi_modules) {\r\nD(1,("OID resolution not enabled"));\r\nreturn path_str->str;\r\n}\r\n#ifdef _WIN32\r\n#define PATH_SEPARATOR ";"\r\npath = get_datafile_path("snmp\\mibs");\r\ng_string_append_printf(path_str, "%s;", path);\r\ng_free (path);\r\npath = get_persconffile_path("snmp\\mibs", FALSE);\r\ng_string_append_printf(path_str, "%s", path);\r\ng_free (path);\r\n#else\r\n#define PATH_SEPARATOR ":"\r\npath = smiGetPath();\r\ng_string_append(path_str, "/usr/share/snmp/mibs");\r\nif (strlen(path) > 0 ) {\r\ng_string_append(path_str, PATH_SEPARATOR);\r\n}\r\ng_string_append_printf(path_str, "%s", path);\r\nsmi_free(path);\r\n#endif\r\nfor(i=0;i<num_smi_paths;i++) {\r\nif (!( smi_paths[i].name && *smi_paths[i].name))\r\ncontinue;\r\ng_string_append_printf(path_str,PATH_SEPARATOR "%s",smi_paths[i].name);\r\n}\r\nreturn g_string_free(path_str, FALSE);\r\n#else\r\nreturn g_strdup("");\r\n#endif\r\n}\r\nchar* oid_test_a2b(guint32 num_subids, guint32* subids) {\r\nguint8* sub2enc = NULL;\r\nguint8* str2enc = NULL;\r\nguint32* enc2sub = NULL;\r\nguint32* str2sub;\r\nchar* ret;\r\nchar* sub2str = oid_subid2string(NULL, subids, num_subids);\r\nguint sub2enc_len = oid_subid2encoded(NULL, num_subids, subids,&sub2enc);\r\nguint enc2sub_len = oid_encoded2subid(NULL, sub2enc, sub2enc_len, &enc2sub);\r\nchar* enc2str = oid_encoded2string(NULL, sub2enc, sub2enc_len);\r\nguint str2enc_len = oid_string2encoded(NULL, sub2str,&str2enc);\r\nguint str2sub_len = oid_string2subid(sub2str,&str2sub);\r\nret = wmem_strdup_printf(wmem_packet_scope(),\r\n"oid_subid2string=%s \n"\r\n"oid_subid2encoded=[%d]%s \n"\r\n"oid_encoded2subid=%s \n "\r\n"oid_encoded2string=%s \n"\r\n"oid_string2encoded=[%d]%s \n"\r\n"oid_string2subid=%s \n "\r\n,sub2str\r\n,sub2enc_len,bytestring_to_str(wmem_packet_scope(), sub2enc, sub2enc_len, ':')\r\n,enc2sub ? oid_subid2string(wmem_packet_scope(), enc2sub,enc2sub_len) : "-"\r\n,enc2str\r\n,str2enc_len,bytestring_to_str(wmem_packet_scope(), str2enc, str2enc_len, ':')\r\n,str2sub ? oid_subid2string(wmem_packet_scope(), str2sub,str2sub_len) : "-"\r\n);\r\nwmem_free(NULL, sub2str);\r\nwmem_free(NULL, enc2sub);\r\nwmem_free(NULL, sub2enc);\r\nwmem_free(NULL, str2enc);\r\nwmem_free(NULL, enc2str);\r\nreturn ret;\r\n}\r\nvoid add_oid_debug_subtree(oid_info_t* oid_info, proto_tree *tree) {\r\nstatic const char* oid_kinds[] = { "Unknown", "Node", "Scalar", "Table", "Row", "Column", "Notification", "Group", "Compliance", "Capabilities"};\r\nstatic const char* key_types[] = {"OID_KEY_TYPE_WRONG","OID_KEY_TYPE_INTEGER",\r\n"OID_KEY_TYPE_FIXED_STRING","OID_KEY_TYPE_FIXED_BYTES","OID_KEY_TYPE_STRING",\r\n"OID_KEY_TYPE_BYTES","OID_KEY_TYPE_NSAP","OID_KEY_TYPE_OID","OID_KEY_TYPE_IPADDR"};\r\nproto_item* pi = proto_tree_add_debug_text(tree,NULL,0,0,\r\n"OidInfo: Name='%s' sub-id=%u kind=%s hfid=%d",\r\noid_info->name ? oid_info->name : "",\r\noid_info->subid,\r\noid_info->kind <= OID_KIND_CAPABILITIES ? oid_kinds[oid_info->kind] : "BROKEN",\r\noid_info->value_hfid);\r\nproto_tree* pt = proto_item_add_subtree(pi,0);\r\noid_key_t* key;\r\nfor(key = oid_info->key; key; key = key->next) {\r\nproto_tree_add_debug_text(pt,NULL,0,0,\r\n"Key: name='%s' num_subids=%d type=%s",\r\nkey->name,\r\nkey->key_type <= OID_KEY_TYPE_IPADDR ? key_types[key->key_type] : "BROKEN"\r\n);\r\n};\r\nif (oid_info->parent) {\r\npi = proto_tree_add_debug_text(pt,NULL,0,0,"Parent:");\r\npt = proto_item_add_subtree(pi,0);\r\nadd_oid_debug_subtree(oid_info->parent, pt);\r\n}\r\n}
