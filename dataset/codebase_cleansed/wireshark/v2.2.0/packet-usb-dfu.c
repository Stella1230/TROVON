static gint\r\ndissect_usb_dfu_descriptor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *main_item;\r\nproto_tree *main_tree;\r\nproto_item *length_item;\r\ngint offset = 0;\r\nguint8 descriptor_length;\r\nguint8 descriptor_type;\r\nusb_conv_info_t *usb_conv_info = (usb_conv_info_t *) data;\r\nif (!usb_conv_info) return offset;\r\nif (!(usb_conv_info->interfaceClass == IF_CLASS_APPLICATION_SPECIFIC &&\r\nusb_conv_info->interfaceSubclass == 0x01)) return offset;\r\ndescriptor_length = tvb_get_guint8(tvb, offset);\r\ndescriptor_type = tvb_get_guint8(tvb, offset + 1);\r\nswitch (descriptor_type) {\r\ncase 0x21:\r\nmain_item = proto_tree_add_item(tree, hf_usb_dfu_descriptor, tvb, offset, -1, ENC_NA);\r\nmain_tree = proto_item_add_subtree(main_item, ett_usb_dfu_descriptor);\r\nproto_item_append_text(main_item, ": %s", val_to_str_ext_const(descriptor_type, &descriptor_type_vals_ext, "Unknown"));\r\nlength_item = dissect_usb_descriptor_header(main_tree, tvb, offset, &descriptor_type_vals_ext);\r\nif (descriptor_length != 7 && descriptor_length != 9)\r\nexpert_add_info(pinfo, length_item, &ei_descriptor_invalid_length);\r\noffset += 2;\r\nproto_tree_add_item(main_tree, hf_usb_dfu_descriptor_bmAttributes_reserved, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(main_tree, hf_usb_dfu_descriptor_bmAttributes_WillDetach, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(main_tree, hf_usb_dfu_descriptor_bmAttributes_ManifestationTolerant, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(main_tree, hf_usb_dfu_descriptor_bmAttributes_CanUpload, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(main_tree, hf_usb_dfu_descriptor_bmAttributes_CanDownload, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(main_tree, hf_usb_dfu_descriptor_wDetachTimeOut, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(main_tree, hf_usb_dfu_descriptor_wTransferSize, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif (descriptor_length > 7) {\r\nproto_tree_add_item(main_tree, hf_usb_dfu_descriptor_bcdDFUVersion, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_usb_dfu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *main_item;\r\nproto_tree *main_tree;\r\nproto_item *command_item;\r\nproto_item *sub_item;\r\nproto_tree *command_tree;\r\ngint offset = 0;\r\ngint p2p_dir_save;\r\nguint8 command;\r\ngint16 command_response = -1;\r\ncommand_data_t *command_data = NULL;\r\nwmem_tree_t *wmem_tree;\r\nwmem_tree_key_t key[5];\r\nguint32 bus_id;\r\nguint32 device_address;\r\nguint32 k_bus_id;\r\nguint32 k_device_address;\r\nguint32 k_frame_number;\r\ngint32 block_number = -1;\r\nusb_conv_info_t *usb_conv_info = (usb_conv_info_t *)data;\r\nif (!usb_conv_info) return offset;\r\nbus_id = usb_conv_info->bus_id;\r\ndevice_address = usb_conv_info->device_address;\r\nk_bus_id = bus_id;\r\nk_device_address = device_address;\r\nk_frame_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &k_bus_id;\r\nkey[1].length = 1;\r\nkey[1].key = &k_device_address;\r\nmain_item = proto_tree_add_item(tree, proto_usb_dfu, tvb, offset, -1, ENC_NA);\r\nmain_tree = proto_item_add_subtree(main_item, ett_usb_dfu);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "USB DFU");\r\np2p_dir_save = pinfo->p2p_dir;\r\npinfo->p2p_dir = (usb_conv_info->is_request) ? P2P_DIR_SENT : P2P_DIR_RECV;\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unknown direction ");\r\nbreak;\r\n}\r\nif (usb_conv_info->is_setup) {\r\nguint16 interface;\r\ncommand_item = proto_tree_add_item(main_tree, hf_setup_command, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\ncommand = tvb_get_guint8(tvb, offset);\r\nif (!((usb_conv_info->setup_requesttype == 0x21 && (command == 0x00 || command == 0x01 || command == 0x04 || command == 0x06)) ||\r\n(usb_conv_info->setup_requesttype == 0xa1 && (command == 0x02 || command == 0x03 || command == 0x05))))\r\nexpert_add_info(pinfo, command_item, &ei_invalid_command_for_request_type);\r\noffset += 1;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Command: %s",\r\nval_to_str_ext_const(command, &command_vals_ext, "Unknown"));\r\nif (command == 0x00) {\r\nproto_tree_add_item(main_tree, hf_setup_timeout, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Timeout=%u", tvb_get_letohs(tvb, offset));\r\n} else if (command == 0x01 || command == 0x02) {\r\nproto_tree_add_item(main_tree, hf_setup_block_number, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Block Number=%u", tvb_get_letohs(tvb, offset));\r\nblock_number = tvb_get_letohs(tvb, offset);\r\n} else {\r\nproto_tree_add_item(main_tree, hf_setup_unused, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n}\r\noffset += 2;\r\nproto_tree_add_item(main_tree, hf_setup_interface, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\ninterface = tvb_get_letohs(tvb, offset);\r\noffset += 2;\r\nproto_tree_add_item(main_tree, hf_setup_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif (command == 0x01) {\r\nproto_tree_add_item(main_tree, hf_data, tvb, offset, -1, ENC_NA);\r\noffset = tvb_captured_length(tvb);\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_expert(main_tree, pinfo, &ei_unexpected_data, tvb, offset, tvb_captured_length_remaining(tvb, offset));\r\noffset = tvb_captured_length(tvb);\r\n}\r\nif (!pinfo->fd->flags.visited && command != 21) {\r\nkey[2].length = 1;\r\nkey[2].key = &k_frame_number;\r\nkey[3].length = 0;\r\nkey[3].key = NULL;\r\ncommand_data = wmem_new(wmem_file_scope(), command_data_t);\r\ncommand_data->bus_id = bus_id;\r\ncommand_data->device_address = device_address;\r\ncommand_data->command = command;\r\ncommand_data->interface = interface;\r\ncommand_data->command_frame_number = pinfo->num;\r\ncommand_data->block_number = block_number;\r\nwmem_tree_insert32_array(command_info, key, command_data);\r\n}\r\npinfo->p2p_dir = p2p_dir_save;\r\nreturn offset;\r\n}\r\nkey[2].length = 0;\r\nkey[2].key = NULL;\r\nwmem_tree = (wmem_tree_t *) wmem_tree_lookup32_array(command_info, key);\r\nif (wmem_tree) {\r\ncommand_data = (command_data_t *) wmem_tree_lookup32_le(wmem_tree, pinfo->num);\r\nif (command_data) {\r\ncommand_response = command_data->command;\r\nblock_number = command_data->block_number;\r\n}\r\n}\r\nif (!command_data) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Response: Unknown");\r\nproto_tree_add_expert(main_tree, pinfo, &ei_unknown_data, tvb, offset, tvb_captured_length_remaining(tvb, offset));\r\npinfo->p2p_dir = p2p_dir_save;\r\nreturn tvb_captured_length(tvb);\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Response: %s",\r\nval_to_str_ext_const(command_response, &command_vals_ext, "Unknown"));\r\ncommand_item = proto_tree_add_uint(main_tree, hf_response, tvb, offset, 0, command_response);\r\ncommand_tree = proto_item_add_subtree(command_item, ett_command);\r\nPROTO_ITEM_SET_GENERATED(command_item);\r\nif (command_data) {\r\ncommand_item = proto_tree_add_uint(main_tree, hf_setup_interface, tvb, offset, 0, command_data->interface);\r\nPROTO_ITEM_SET_GENERATED(command_item);\r\ncommand_item = proto_tree_add_uint(main_tree, hf_command_in_frame, tvb, offset, 0, command_data->command_frame_number);\r\nPROTO_ITEM_SET_GENERATED(command_item);\r\n}\r\nswitch (command_response) {\r\ncase 0x02:\r\nif (block_number != -1) {\r\nsub_item = proto_tree_add_uint(main_tree, hf_setup_block_number, tvb, offset, 0, block_number);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Block Number=%u", block_number);\r\n}\r\nproto_tree_add_item(main_tree, hf_data, tvb, offset, -1, ENC_NA);\r\noffset = tvb_captured_length(tvb);\r\nbreak;\r\ncase 0x03:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " = Status: %s, PollTimeout: %u ms, State: %s",\r\nval_to_str_ext_const(tvb_get_guint8(tvb, offset), &status_vals_ext, "Unknown"),\r\ntvb_get_letoh24(tvb, offset + 1),\r\nval_to_str_ext_const(tvb_get_guint8(tvb, offset + 4), &state_vals_ext, "Unknown"));\r\nproto_tree_add_item(main_tree, hf_status, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(main_tree, hf_poll_timeout, tvb, offset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(main_tree, hf_state, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(main_tree, hf_iString, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nbreak;\r\ncase 0x05:\r\nproto_tree_add_item(main_tree, hf_state, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " = %s",\r\nval_to_str_ext_const(tvb_get_guint8(tvb, offset), &state_vals_ext, "Unknown"));\r\noffset += 1;\r\nbreak;\r\ncase 0x00:\r\ncase 0x01:\r\ncase 0x04:\r\ncase 0x06:\r\ndefault:\r\nproto_tree_add_expert(command_tree, pinfo, &ei_unexpected_response, tvb, offset, 0);\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_expert(main_tree, pinfo, &ei_unknown_data, tvb, offset, -1);\r\noffset = tvb_captured_length(tvb);\r\n}\r\n}\r\npinfo->p2p_dir = p2p_dir_save;\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_usb_dfu(void)\r\n{\r\nmodule_t *module;\r\nexpert_module_t *expert_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_setup_command,\r\n{ "Command", "usbdfu.command",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING, &command_vals_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_response,\r\n{ "Response", "usbdfu.response",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING, &command_vals_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_command_in_frame,\r\n{ "Command Frame", "usbdfu.command_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_setup_unused,\r\n{ "Unused", "usbdfu.unused",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_setup_interface,\r\n{ "Interface", "usbdfu.interface",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_setup_length,\r\n{ "Length", "usbdfu.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_setup_block_number,\r\n{ "Block Number", "usbdfu.block_number",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_setup_timeout,\r\n{ "Timeout", "usbdfu.timeout",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_state,\r\n{ "State", "usbdfu.state",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING, &state_vals_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_status,\r\n{ "Status", "usbdfu.status",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING, &status_vals_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_iString,\r\n{ "iString", "usbdfu.iString",\r\nFT_INT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_poll_timeout,\r\n{ "Poll Timeout", "usbdfu.poll_timeout",\r\nFT_UINT24, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_data,\r\n{ "Data", "usbdfu.data",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_dfu_descriptor,\r\n{ "DFU Descriptor", "usbdfu.descriptor",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_dfu_descriptor_bmAttributes_reserved,\r\n{ "Reserved", "usbdfu.descriptor.bmAttributes.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_dfu_descriptor_bmAttributes_WillDetach,\r\n{ "Will Detach", "usbdfu.descriptor.bmAttributes.WillDetach",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_dfu_descriptor_bmAttributes_ManifestationTolerant,\r\n{ "Manifestation Tolerant", "usbdfu.descriptor.bmAttributes.ManifestationTolerant",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_dfu_descriptor_bmAttributes_CanUpload,\r\n{ "Can Upload", "usbdfu.descriptor.bmAttributes.CanUpload",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_dfu_descriptor_bmAttributes_CanDownload,\r\n{ "Can Download", "usbdfu.descriptor.bmAttributes.CanDownload",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_dfu_descriptor_wDetachTimeOut,\r\n{ "wDetachTimeOut", "usbdfu.descriptor.wDetachTimeOut",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_dfu_descriptor_wTransferSize,\r\n{ "wTransferSize", "usbdfu.descriptor.wTransferSize",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_usb_dfu_descriptor_bcdDFUVersion,\r\n{ "bcdDFUVersion", "usbdfu.descriptor.bcdDFUVersion",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_unexpected_response, { "usb_dfu.unexpected_response", PI_PROTOCOL, PI_ERROR, "Unexpected response for this command", EXPFILL }},\r\n{ &ei_unknown_data, { "usb_dfu.unknown_data", PI_PROTOCOL, PI_NOTE, "Unknown data", EXPFILL }},\r\n{ &ei_unexpected_data, { "usb_dfu.unexpected_data", PI_PROTOCOL, PI_WARN, "Unexpected data", EXPFILL }},\r\n{ &ei_invalid_command_for_request_type, { "usb_dfu.invalid_command_for_request_type", PI_PROTOCOL, PI_WARN, "Invalid command for this Request Type", EXPFILL }},\r\n{ &ei_descriptor_invalid_length, { "usb_dfu.descriptor.invalid_length", PI_PROTOCOL, PI_WARN, "Invalid Length", EXPFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_usb_dfu,\r\n&ett_usb_dfu_descriptor,\r\n&ett_command\r\n};\r\ncommand_info = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\nproto_usb_dfu = proto_register_protocol("USB Device Firmware Upgrade ", "USB DFU", "usbdfu");\r\nproto_register_field_array(proto_usb_dfu, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nusb_dfu_handle = register_dissector("usb_dfu", dissect_usb_dfu, proto_usb_dfu);\r\nexpert_module = expert_register_protocol(proto_usb_dfu);\r\nexpert_register_field_array(expert_module, ei, array_length(ei));\r\nmodule = prefs_register_protocol(proto_usb_dfu, NULL);\r\nprefs_register_static_text_preference(module, "version",\r\n"USB DFU Specification 1.1",\r\n"Version of protocol supported by this dissector.");\r\n}\r\nvoid\r\nproto_reg_handoff_usb_dfu(void)\r\n{\r\ndissector_handle_t usf_dfu_descriptor_handle;\r\nusf_dfu_descriptor_handle = create_dissector_handle(dissect_usb_dfu_descriptor, proto_usb_dfu);\r\ndissector_add_uint("usb.descriptor", IF_CLASS_APPLICATION_SPECIFIC, usf_dfu_descriptor_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x1db5, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x6001, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x6003, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x600f, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x6011, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x6017, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x6044, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x6064, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x6069, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x6082, usb_dfu_handle);\r\ndissector_add_uint("usb.product", (0x1d50 << 16) | 0x6084, usb_dfu_handle);\r\ndissector_add_for_decode_as("usb.device", usb_dfu_handle);\r\ndissector_add_for_decode_as("usb.protocol", usb_dfu_handle);\r\n}
