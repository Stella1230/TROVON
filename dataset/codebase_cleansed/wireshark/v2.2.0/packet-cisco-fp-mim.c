static gboolean\r\ndissect_fp_heur (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint16 type = 0;\r\ntype = tvb_get_ntohs (tvb, 12);\r\nif (type == ETHERTYPE_DCE) {\r\ndissect_fp (tvb, pinfo, tree, NULL);\r\nreturn TRUE;\r\n} else {\r\nreturn FALSE;\r\n}\r\n}\r\nstatic gboolean\r\nfp_is_ig_set (guint64 hmac)\r\n{\r\nif (hmac & FP_HMAC_IG_MASK) {\r\nreturn TRUE;\r\n} else {\r\nreturn FALSE;\r\n}\r\n}\r\nstatic void\r\nfp_get_hmac_addr (guint64 hmac, guint16 *swid, guint16 *sswid, guint16 *lid) {\r\nif (!swid || !sswid || !lid) {\r\nreturn;\r\n}\r\n*swid = (guint16) ((hmac & FP_HMAC_SWID_MASK) >> 24);\r\n*sswid = (guint16) ((hmac & FP_HMAC_SSWID_MASK) >> 16);\r\n*lid = (guint16) (hmac & FP_HMAC_LID_MASK);\r\n}\r\nstatic void\r\nfp_add_hmac (tvbuff_t *tvb, proto_tree *tree, int offset) {\r\nguint16 eid;\r\nif (!tree) {\r\nreturn;\r\n}\r\neid = tvb_get_ntohs(tvb, offset);\r\neid &= FP_EID_MASK;\r\neid = ((eid & 0x00C0) >> 6) + ((eid & 0xFC00) >> 8);\r\nproto_tree_add_uint(tree, hf_eid, tvb, offset, FP_BF_LEN, eid);\r\nproto_tree_add_item (tree, hf_ul, tvb, offset, FP_BF_LEN, ENC_NA);\r\nproto_tree_add_item (tree, hf_ig, tvb, offset, FP_BF_LEN, ENC_NA);\r\nproto_tree_add_item (tree, hf_ooodl, tvb, offset, FP_BF_LEN, ENC_NA);\r\nproto_tree_add_item (tree, hf_swid, tvb, offset, FP_BF_LEN, ENC_BIG_ENDIAN);\r\noffset += FP_BF_LEN;\r\nproto_tree_add_item (tree, hf_sswid, tvb, offset, FP_SSWID_LEN, ENC_BIG_ENDIAN);\r\noffset += FP_SSWID_LEN;\r\nproto_tree_add_item (tree, hf_lid, tvb, offset, FP_LID_LEN, ENC_BIG_ENDIAN);\r\n}\r\nstatic int\r\ndissect_fp( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_ )\r\n{\r\nproto_item *ti ;\r\nproto_tree *fp_tree ;\r\nproto_tree *fp_addr_tree ;\r\ntvbuff_t *next_tvb ;\r\nint offset = 0 ;\r\nguint64 hmac_src;\r\nguint64 hmac_dst;\r\nguint16 sswid = 0;\r\nguint16 ssswid = 0;\r\nguint16 slid = 0;\r\nguint16 dswid = 0;\r\nguint16 dsswid = 0;\r\nguint16 dlid = 0;\r\nconst guint8 *dst_addr = NULL;\r\ngboolean dest_ig = FALSE;\r\ncol_set_str( pinfo->cinfo, COL_PROTOCOL, FP_PROTO_COL_NAME ) ;\r\ncol_set_str( pinfo->cinfo, COL_INFO, FP_PROTO_COL_INFO ) ;\r\nif (tree) {\r\nhmac_dst = tvb_get_ntoh48 (tvb, 0);\r\nhmac_src = tvb_get_ntoh48 (tvb, 6);\r\ndest_ig = fp_is_ig_set(hmac_dst);\r\nif (!dest_ig) {\r\nfp_get_hmac_addr (hmac_dst, &dswid, &dsswid, &dlid);\r\n} else {\r\nhmac_dst = GUINT64_TO_BE (hmac_dst);\r\ndst_addr = ((const guint8 *) &hmac_dst) + 2;\r\n}\r\nfp_get_hmac_addr (hmac_src, &sswid, &ssswid, &slid);\r\nif (PTREE_DATA(tree)->visible) {\r\nif (dest_ig) {\r\naddress ether_addr;\r\nset_address(&ether_addr, AT_ETHER, 6, dst_addr);\r\nti = proto_tree_add_protocol_format(tree, proto_fp, tvb, 0, FP_HEADER_SIZE,\r\n"Cisco FabricPath, Src: %03x.%02x.%04x, Dst: %s",\r\nsswid, ssswid, slid,\r\naddress_with_resolution_to_str(wmem_packet_scope(), &ether_addr));\r\n} else {\r\nti = proto_tree_add_protocol_format(tree, proto_fp, tvb, 0, FP_HEADER_SIZE,\r\n"Cisco FabricPath, Src: %03x.%02x.%04x, Dst: %03x.%02x.%04x",\r\nsswid, ssswid, slid,\r\ndswid, dsswid, dlid);\r\n}\r\n} else {\r\nti = proto_tree_add_item( tree, proto_fp, tvb, 0, -1, ENC_NA ) ;\r\n}\r\nfp_tree = proto_item_add_subtree( ti, ett_mim ) ;\r\noffset = 0;\r\nif (dest_ig) {\r\nproto_tree_add_ether( fp_tree, hf_d_hmac_mc, tvb, offset, 6,\r\ndst_addr);\r\n} else {\r\nti = proto_tree_add_none_format (fp_tree, hf_d_hmac, tvb, offset, 6, "Destination: %03x.%02x.%04x", dswid, dsswid, dlid);\r\nfp_addr_tree = proto_item_add_subtree (ti, ett_hmac);\r\nfp_add_hmac (tvb, fp_addr_tree, offset);\r\n}\r\noffset += FP_HMAC_LEN;\r\nti = proto_tree_add_none_format (fp_tree, hf_s_hmac, tvb, offset, 6,\r\n"Source: %03x.%02x.%04x", sswid, ssswid, slid);\r\nfp_addr_tree = proto_item_add_subtree (ti, ett_hmac);\r\nfp_add_hmac (tvb, fp_addr_tree, offset);\r\noffset += FP_HMAC_LEN;\r\noffset += 2;\r\nproto_tree_add_item (fp_tree, hf_ftag, tvb, offset, FP_FTAG_LEN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (fp_tree, hf_ttl, tvb, offset, FP_FTAG_LEN, ENC_BIG_ENDIAN);\r\n}\r\nnext_tvb = tvb_new_subset_remaining( tvb, FP_HEADER_SIZE) ;\r\ncall_dissector( eth_maybefcs_dissector, next_tvb, pinfo, tree ) ;\r\nreturn tvb_captured_length( tvb ) ;\r\n}\r\nvoid\r\nproto_register_mim(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_s_hmac,\r\n{ "Source HMAC", "cfp.s_hmac",\r\nFT_NONE, BASE_NONE, NULL,\r\n0, "Source Hierarchical MAC", HFILL }},\r\n{ &hf_d_hmac,\r\n{ "Destination HMAC", "cfp.d_hmac",\r\nFT_NONE, BASE_NONE, NULL,\r\n0, "Destination Hierarchical MAC", HFILL }},\r\n{ &hf_d_hmac_mc,\r\n{ "MC Destination", "cfp.d_hmac_mc",\r\nFT_ETHER, BASE_NONE, NULL,\r\n0, "Multicast Destination Address", HFILL }},\r\n{ &hf_ftag,\r\n{ "FTAG", "cfp.ftag",\r\nFT_UINT16, BASE_DEC, NULL, FP_FTAG_MASK,\r\n"FTAG field identifying forwarding distribution tree.", HFILL }},\r\n{ &hf_ttl,\r\n{ "TTL", "cfp.ttl",\r\nFT_UINT16, BASE_DEC, NULL, FP_TTL_MASK,\r\n"The remaining hop count for this frame", HFILL }},\r\n{\r\n&hf_swid,\r\n{ "switch-id", "cfp.swid",\r\nFT_UINT24, BASE_DEC_HEX, NULL, FP_SWID_MASK,\r\n"Switch-id/nickname of switch in FabricPath network", HFILL }},\r\n{\r\n&hf_sswid,\r\n{ "sub-switch-id", "cfp.sswid",\r\nFT_UINT8, BASE_DEC_HEX, NULL, 0x0,\r\n"Sub-switch-id of switch in FabricPath network", HFILL }},\r\n{\r\n&hf_eid,\r\n{ "End Node ID", "cfp.eid",\r\nFT_UINT24, BASE_DEC_HEX, NULL, FP_3B_EID_MASK,\r\n"Cisco FabricPath End node ID", HFILL }},\r\n{\r\n&hf_lid,\r\n{ "Source LID", "cfp.lid",\r\nFT_UINT16, BASE_DEC_HEX, NULL, 0x0,\r\n"Source or Destination Port index on switch in FabricPath network", HFILL }},\r\n{\r\n&hf_ul,\r\n{ "U/L bit", "cfp.ul",\r\nFT_BOOLEAN, 24, TFS(&ul_tfs), FP_UL_MASK,\r\n"Specifies if this is a locally administered or globally unique (IEEE assigned) address", HFILL }},\r\n{\r\n&hf_ig,\r\n{ "I/G bit", "cfp.ig",\r\nFT_BOOLEAN, 24 , TFS(&ig_tfs), FP_IG_MASK,\r\n"Specifies if this is an individual (unicast) or group (broadcast/multicast) address", HFILL }},\r\n{\r\n&hf_ooodl,\r\n{ "OOO/DL Bit", "cfp.ooodl",\r\nFT_BOOLEAN, 24 , TFS(&ooodl_tfs), FP_OOO_MASK,\r\n"Specifies Out of Order Delivery OK in destination address and Do Not Learn when set in source address", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mim,\r\n&ett_hmac\r\n};\r\nmodule_t *mim_module;\r\nproto_fp = proto_register_protocol("Cisco FabricPath", "CFP", "cfp");\r\nmim_module = prefs_register_protocol (proto_fp, proto_reg_handoff_fabricpath);\r\nprefs_register_obsolete_preference (mim_module, "enable");\r\nproto_register_field_array(proto_fp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_fabricpath(void)\r\n{\r\nstatic gboolean prefs_initialized = FALSE;\r\nif (!prefs_initialized) {\r\nheur_dissector_add ("eth", dissect_fp_heur, "Cisco FabricPath over Ethernet", "fp_eth", proto_fp, HEURISTIC_DISABLE);\r\neth_maybefcs_dissector = find_dissector_add_dependency( "eth_maybefcs", proto_fp );\r\nprefs_initialized = TRUE;\r\n}\r\n}
