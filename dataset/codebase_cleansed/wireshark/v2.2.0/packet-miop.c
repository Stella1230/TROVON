static gboolean\r\ndissect_miop_heur_check (tvbuff_t * tvb, packet_info * pinfo _U_, proto_tree * tree _U_, void * data _U_) {\r\nguint tot_len;\r\nguint32 magic;\r\ntot_len = tvb_captured_length(tvb);\r\nif (tot_len < MIOP_HEADER_SIZE)\r\n{\r\nreturn FALSE;\r\n}\r\nmagic = tvb_get_ntohl(tvb,0);\r\nif(magic != MIOP_MAGIC){\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int dissect_miop (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_) {\r\nguint offset = 0;\r\nproto_tree *miop_tree = NULL;\r\nproto_item *ti;\r\nguint8 hdr_version;\r\nguint version_major;\r\nguint version_minor;\r\nguint8 flags;\r\nguint16 packet_length;\r\nguint packet_number;\r\nguint number_of_packets;\r\nguint byte_order;\r\nguint32 unique_id_len;\r\nwmem_strbuf_t *flags_strbuf = wmem_strbuf_new_label(wmem_packet_scope());\r\nwmem_strbuf_append(flags_strbuf, "none");\r\nif (!dissect_miop_heur_check(tvb, pinfo, tree, data))\r\nreturn 0;\r\ncol_set_str (pinfo->cinfo, COL_PROTOCOL, "MIOP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nhdr_version = tvb_get_guint8(tvb, 4);\r\nversion_major = ((hdr_version & 0xf0) >> 4);\r\nversion_minor = (hdr_version & 0x0f);\r\nif (hdr_version != 16)\r\n{\r\ncol_add_fstr (pinfo->cinfo, COL_INFO, "Version %u.%u",\r\nversion_major, version_minor);\r\nti = proto_tree_add_item (tree, proto_miop, tvb, 0, -1, ENC_NA);\r\nmiop_tree = proto_item_add_subtree (ti, ett_miop);\r\nproto_tree_add_expert_format(miop_tree, pinfo, &ei_miop_version_not_supported,\r\ntvb, 0, -1,\r\n"MIOP version %u.%u not supported",\r\nversion_major, version_minor);\r\nreturn 5;\r\n}\r\nflags = tvb_get_guint8(tvb, 5);\r\nbyte_order = (flags & 0x01) ? ENC_LITTLE_ENDIAN : ENC_BIG_ENDIAN;\r\nif (byte_order == ENC_BIG_ENDIAN) {\r\npacket_length = tvb_get_ntohs(tvb, 6);\r\npacket_number = tvb_get_ntohl(tvb, 8);\r\nnumber_of_packets = tvb_get_ntohl(tvb, 12);\r\nunique_id_len = tvb_get_ntohl(tvb, 16);\r\n}\r\nelse {\r\npacket_length = tvb_get_letohs(tvb, 6);\r\npacket_number = tvb_get_letohl(tvb, 8);\r\nnumber_of_packets = tvb_get_letohl(tvb, 12);\r\nunique_id_len = tvb_get_letohl(tvb, 16);\r\n}\r\ncol_add_fstr (pinfo->cinfo, COL_INFO, "MIOP %u.%u Packet s=%d (%u of %u)",\r\nversion_major, version_minor, packet_length,\r\npacket_number + 1,\r\nnumber_of_packets);\r\nif (tree)\r\n{\r\nti = proto_tree_add_item (tree, proto_miop, tvb, 0, -1, ENC_NA);\r\nmiop_tree = proto_item_add_subtree (ti, ett_miop);\r\nproto_tree_add_item(miop_tree, hf_miop_magic, tvb, offset, 4, ENC_ASCII|ENC_NA);\r\noffset += 4;\r\nproto_tree_add_uint_format_value(miop_tree, hf_miop_hdr_version, tvb, offset, 1, hdr_version,\r\n"%u.%u", version_major, version_minor);\r\noffset++;\r\nif (flags & 0x01) {\r\nwmem_strbuf_truncate(flags_strbuf, 0);\r\nwmem_strbuf_append(flags_strbuf, "little-endian");\r\n}\r\nif (flags & 0x02) {\r\nwmem_strbuf_append_printf(flags_strbuf, "%s%s",\r\nwmem_strbuf_get_len(flags_strbuf) ? ", " : "", "last message");\r\n}\r\nproto_tree_add_uint_format_value(miop_tree, hf_miop_flags, tvb, offset, 1,\r\nflags, "0x%02x (%s)", flags, wmem_strbuf_get_str(flags_strbuf));\r\noffset++;\r\nproto_tree_add_item(miop_tree, hf_miop_packet_length, tvb, offset, 2, byte_order);\r\noffset += 2;\r\nproto_tree_add_item(miop_tree, hf_miop_packet_number, tvb, offset, 4, byte_order);\r\noffset += 4;\r\nproto_tree_add_item(miop_tree, hf_miop_number_of_packets, tvb, offset, 4, byte_order);\r\noffset += 4;\r\nti = proto_tree_add_item(miop_tree, hf_miop_unique_id_len, tvb, offset, 4, byte_order);\r\nif (unique_id_len >= MIOP_MAX_UNIQUE_ID_LENGTH) {\r\nexpert_add_info_format(pinfo, ti, &ei_miop_unique_id_len_exceed_max_value,\r\n"Unique Id length (%u) exceeds max value (%u)",\r\nunique_id_len, MIOP_MAX_UNIQUE_ID_LENGTH);\r\nreturn offset;\r\n}\r\noffset += 4;\r\nproto_tree_add_item(miop_tree, hf_miop_unique_id, tvb, offset, unique_id_len,\r\nbyte_order);\r\nif (packet_number == 0) {\r\ntvbuff_t *payload_tvb;\r\noffset += unique_id_len;\r\npayload_tvb = tvb_new_subset_remaining (tvb, offset);\r\ndissect_giop(payload_tvb, pinfo, tree);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_miop_heur (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * data _U_) {\r\nif (!dissect_miop_heur_check(tvb, pinfo, tree, data))\r\nreturn FALSE;\r\ndissect_miop (tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nvoid proto_register_miop (void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_miop_magic,\r\n{ "Magic", "miop.magic", FT_STRING, BASE_NONE, NULL, 0x0,\r\n"PacketHeader magic", HFILL }},\r\n{ &hf_miop_hdr_version,\r\n{ "Version", "miop.hdr_version", FT_UINT8, BASE_HEX, NULL, 0x0,\r\n"PacketHeader hdr_version", HFILL }},\r\n{ &hf_miop_flags,\r\n{ "Flags", "miop.flags", FT_UINT8, BASE_OCT, NULL, 0x0,\r\n"PacketHeader flags", HFILL }},\r\n{ &hf_miop_packet_length,\r\n{ "Length", "miop.packet_length", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n"PacketHeader packet_length", HFILL }},\r\n{ &hf_miop_packet_number,\r\n{ "PacketNumber", "miop.packet_number", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"PacketHeader packet_number", HFILL }},\r\n{ &hf_miop_number_of_packets,\r\n{ "NumberOfPackets", "miop.number_of_packets", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"PacketHeader number_of_packets", HFILL }},\r\n{ &hf_miop_unique_id_len,\r\n{ "UniqueIdLength", "miop.unique_id_len", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"UniqueId length", HFILL }},\r\n{ &hf_miop_unique_id,\r\n{ "UniqueId", "miop.unique_id", FT_BYTES, BASE_NONE, NULL, 0x0,\r\n"UniqueId id", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_miop\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_miop_version_not_supported, { "miop.version.not_supported", PI_UNDECODED, PI_WARN, "MIOP version not supported", EXPFILL }},\r\n{ &ei_miop_unique_id_len_exceed_max_value, { "miop.unique_id_len.exceed_max_value", PI_MALFORMED, PI_WARN, "Unique Id length exceeds max value", EXPFILL }},\r\n};\r\nexpert_module_t* expert_miop;\r\nproto_miop = proto_register_protocol("Unreliable Multicast Inter-ORB Protocol", "MIOP", "miop");\r\nproto_register_field_array (proto_miop, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nexpert_miop = expert_register_protocol(proto_miop);\r\nexpert_register_field_array(expert_miop, ei, array_length(ei));\r\nregister_dissector("miop", dissect_miop, proto_miop);\r\n}\r\nvoid proto_reg_handoff_miop (void) {\r\ndissector_handle_t miop_handle;\r\nmiop_handle = find_dissector("miop");\r\ndissector_add_for_decode_as("udp.port", miop_handle);\r\nheur_dissector_add("udp", dissect_miop_heur, "MIOP over UDP", "miop_udp", proto_miop, HEURISTIC_ENABLE);\r\n}
