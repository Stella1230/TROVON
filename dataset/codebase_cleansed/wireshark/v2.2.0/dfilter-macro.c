static gboolean free_value(gpointer k _U_, gpointer v, gpointer u _U_) {\r\nfvt_cache_entry_t* e = (fvt_cache_entry_t*)v;\r\nwmem_free(NULL, e->repr);\r\ng_free(e);\r\nreturn TRUE;\r\n}\r\nstatic gboolean fvt_cache_cb(proto_node * node, gpointer data _U_) {\r\nfield_info* finfo = PNODE_FINFO(node);\r\nfvt_cache_entry_t* e;\r\nif (!finfo) return FALSE;\r\nif ((e = (fvt_cache_entry_t*)g_hash_table_lookup(fvt_cache,finfo->hfinfo->abbrev))) {\r\ne->usable = FALSE;\r\n} else if (finfo->value.ftype->val_to_string_repr) {\r\nswitch (finfo->hfinfo->type) {\r\ncase FT_NONE:\r\ncase FT_PROTOCOL:\r\nreturn FALSE;\r\ndefault:\r\nbreak;\r\n}\r\ne = g_new(fvt_cache_entry_t,1);\r\ne->name = finfo->hfinfo->abbrev,\r\ne->repr = fvalue_to_string_repr(NULL, &(finfo->value), FTREPR_DFILTER, finfo->hfinfo->display);\r\ne->usable = TRUE;\r\ng_hash_table_insert(fvt_cache,(void*)finfo->hfinfo->abbrev,e);\r\n}\r\nreturn FALSE;\r\n}\r\nvoid dfilter_macro_build_ftv_cache(void* tree_root) {\r\ng_hash_table_foreach_remove(fvt_cache,free_value,NULL);\r\nproto_tree_traverse_post_order((proto_tree *)tree_root, fvt_cache_cb, NULL);\r\n}\r\nstatic gchar* dfilter_macro_resolve(gchar* name, gchar** args, gchar** error) {\r\nGString* text;\r\nint argc = 0;\r\ndfilter_macro_t* m = NULL;\r\nfvt_cache_entry_t* e;\r\nint* arg_pos_p;\r\ngchar** parts;\r\ngchar* ret;\r\nguint i;\r\nfor (i = 0; i < num_macros; i++) {\r\ndfilter_macro_t* c = &(macros[i]);\r\nif ( c->usable && g_str_equal(c->name,name) ) {\r\nm = c;\r\nbreak;\r\n}\r\n}\r\nif (!m) {\r\nif (fvt_cache &&\r\n(e = (fvt_cache_entry_t *)g_hash_table_lookup(fvt_cache,name)) != NULL) {\r\nif(e->usable) {\r\nreturn wmem_strdup(NULL, e->repr);\r\n} else {\r\nif (error != NULL)\r\n*error = g_strdup_printf("macro '%s' is unusable", name);\r\nreturn NULL;\r\n}\r\n} else {\r\nif (error != NULL)\r\n*error = g_strdup_printf("macro '%s' does not exist", name);\r\nreturn NULL;\r\n}\r\n}\r\nDUMP_MACRO(m);\r\nif (args) {\r\nwhile(args[argc]) argc++;\r\n}\r\nif (argc != m->argc) {\r\nif (error != NULL) {\r\n*error = g_strdup_printf("wrong number of arguments for macro '%s', expecting %d instead of %d",\r\nname, m->argc, argc);\r\n}\r\nreturn NULL;\r\n}\r\narg_pos_p = m->args_pos;\r\nparts = m->parts;\r\ntext = g_string_new(*(parts++));\r\nif (args) {\r\nwhile (*parts) {\r\ng_string_append_printf(text,"%s%s",\r\nargs[*(arg_pos_p++)],\r\n*(parts++));\r\n}\r\n}\r\nret = wmem_strdup(NULL, text->str);\r\ng_string_free(text,TRUE);\r\nreturn ret;\r\n}\r\nstatic gchar* dfilter_macro_apply_recurse(const gchar* text, guint depth, gchar** error) {\r\nenum { OUTSIDE, STARTING, NAME, ARGS } state = OUTSIDE;\r\nGString* out;\r\nGString* name = NULL;\r\nGString* arg = NULL;\r\nGPtrArray* args = NULL;\r\ngchar c;\r\nconst gchar* r = text;\r\ngboolean changed = FALSE;\r\nif ( depth > 31) {\r\nif (error != NULL)\r\n*error = g_strdup("too much nesting in macros");\r\nreturn NULL;\r\n}\r\n#define FGS(n) if (n) g_string_free(n,TRUE); n = NULL\r\n#define FREE_ALL() \\r\ndo { \\r\nFGS(name); \\r\nFGS(arg); \\r\nif (args) { \\r\nwhile(args->len) { void* p = g_ptr_array_remove_index_fast(args,0); if (p) g_free(p); } \\r\ng_ptr_array_free(args,TRUE); \\r\nargs = NULL; \\r\n} \\r\n} while(0)\r\nif (error != NULL)\r\n*error = NULL;\r\nout = g_string_sized_new(64);\r\nwhile(1) {\r\nc = *r++;\r\nswitch(state) {\r\ncase OUTSIDE: {\r\nswitch(c) {\r\ncase '\0': {\r\ngoto finish;\r\n} case '$': {\r\nstate = STARTING;\r\nbreak;\r\n} default: {\r\ng_string_append_c(out,c);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n} case STARTING: {\r\nswitch (c) {\r\ncase '{': {\r\nargs = g_ptr_array_new();\r\narg = g_string_sized_new(32);\r\nname = g_string_sized_new(32);\r\nstate = NAME;\r\nbreak;\r\n} case '\0': {\r\ng_string_append_c(out,'$');\r\ngoto finish;\r\n} default: {\r\ng_string_append_c(out,'$');\r\ng_string_append_c(out,c);\r\nstate = OUTSIDE;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n} case NAME: {\r\nif ( g_ascii_isalnum(c) || c == '_' || c == '-' || c == '.' ) {\r\ng_string_append_c(name,c);\r\n} else if ( c == ':') {\r\nstate = ARGS;\r\n} else if ( c == '}') {\r\ngchar* resolved;\r\ng_ptr_array_add(args,NULL);\r\nresolved = dfilter_macro_resolve(name->str, (gchar**)args->pdata, error);\r\nif (resolved == NULL)\r\ngoto on_error;\r\nchanged = TRUE;\r\ng_string_append(out,resolved);\r\nwmem_free(NULL, resolved);\r\nFREE_ALL();\r\nstate = OUTSIDE;\r\n} else if ( c == '\0') {\r\nif (error != NULL)\r\n*error = g_strdup("end of filter in the middle of a macro expression");\r\ngoto on_error;\r\n} else {\r\nif (error != NULL)\r\n*error = g_strdup("invalid character in macro name");\r\ngoto on_error;\r\n}\r\nbreak;\r\n} case ARGS: {\r\nswitch(c) {\r\ncase '\0': {\r\nif (error != NULL)\r\n*error = g_strdup("end of filter in the middle of a macro expression");\r\ngoto on_error;\r\n} case ';': {\r\ng_ptr_array_add(args,g_string_free(arg,FALSE));\r\narg = g_string_sized_new(32);\r\nbreak;\r\n} case '\\': {\r\nc = *r++;\r\nif (c) {\r\ng_string_append_c(arg,c);\r\nbreak;\r\n} else {\r\nif (error != NULL)\r\n*error = g_strdup("end of filter in the middle of a macro expression");\r\ngoto on_error;\r\n}\r\n} default: {\r\ng_string_append_c(arg,c);\r\nbreak;\r\n} case '}': {\r\ngchar* resolved;\r\ng_ptr_array_add(args,g_string_free(arg,FALSE));\r\ng_ptr_array_add(args,NULL);\r\narg = NULL;\r\nresolved = dfilter_macro_resolve(name->str, (gchar**)args->pdata, error);\r\nif (resolved == NULL)\r\ngoto on_error;\r\nchanged = TRUE;\r\ng_string_append(out,resolved);\r\nwmem_free(NULL, resolved);\r\nFREE_ALL();\r\nstate = OUTSIDE;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nfinish:\r\n{\r\nFREE_ALL();\r\nif (changed) {\r\ngchar* resolved = dfilter_macro_apply_recurse(out->str, depth + 1, error);\r\ng_string_free(out,TRUE);\r\nreturn resolved;\r\n} else {\r\ngchar* out_str = wmem_strdup(NULL, out->str);\r\ng_string_free(out,TRUE);\r\nreturn out_str;\r\n}\r\n}\r\non_error:\r\n{\r\nFREE_ALL();\r\nif (error != NULL) {\r\nif (*error == NULL)\r\n*error = g_strdup("unknown error in macro expression");\r\n}\r\ng_string_free(out,TRUE);\r\nreturn NULL;\r\n}\r\n}\r\ngchar* dfilter_macro_apply(const gchar* text, gchar** error) {\r\nreturn dfilter_macro_apply_recurse(text, 0, error);\r\n}\r\nstatic gboolean macro_update(void* mp, gchar** error) {\r\ndfilter_macro_t* m = (dfilter_macro_t*)mp;\r\nGPtrArray* parts;\r\nGArray* args_pos;\r\nconst gchar* r;\r\ngchar* w;\r\ngchar* part;\r\nint argc = 0;\r\nDUMP_MACRO(m);\r\n*error = NULL;\r\nif (dfilter_macro_uat && dfilter_macro_uat->post_update_cb)\r\ndfilter_macro_uat->post_update_cb();\r\nparts = g_ptr_array_new();\r\nargs_pos = g_array_new(FALSE,FALSE,sizeof(int));\r\nm->priv = part = w = g_strdup(m->text);\r\nr = m->text;\r\ng_ptr_array_add(parts,part);\r\nwhile (r && *r) {\r\nswitch (*r) {\r\ndefault:\r\n*(w++) = *(r++);\r\nbreak;\r\ncase '\0':\r\n*w = *r;\r\ngoto done;\r\ncase '\\':\r\n*(w++) = *(++r);\r\nr++;\r\nbreak;\r\ncase '$': {\r\nint cnt = 0;\r\nint arg_pos = 0;\r\ndo {\r\nchar c = *(r+1);\r\nif (c >= '0' && c <= '9') {\r\ncnt++;\r\nr++;\r\n*(w++) = '\0';\r\narg_pos *= 10;\r\narg_pos += c - '0';\r\n} else {\r\nbreak;\r\n}\r\n} while(*r);\r\nif (cnt) {\r\n*(w++) = '\0';\r\nr++;\r\nargc = argc < arg_pos ? arg_pos : argc;\r\narg_pos--;\r\ng_array_append_val(args_pos,arg_pos);\r\ng_ptr_array_add(parts,w);\r\n} else {\r\n*(w++) = *(r++);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\ndone:\r\ng_ptr_array_add(parts,NULL);\r\ng_free(m->parts);\r\nm->parts = (gchar**)parts->pdata;\r\ng_free(m->args_pos);\r\nm->args_pos = (int*)(void *)args_pos->data;\r\ng_ptr_array_free(parts,FALSE);\r\ng_array_free(args_pos,FALSE);\r\nm->argc = argc;\r\nm->usable = TRUE;\r\nDUMP_MACRO(m);\r\nreturn TRUE;\r\n}\r\nstatic void macro_free(void* r) {\r\ndfilter_macro_t* m = (dfilter_macro_t*)r;\r\nDUMP_MACRO(r);\r\ng_free(m->name);\r\ng_free(m->text);\r\ng_free(m->priv);\r\ng_free(m->parts);\r\ng_free(m->args_pos);\r\n}\r\nstatic void* macro_copy(void* dest, const void* orig, size_t len _U_) {\r\ndfilter_macro_t* d = (dfilter_macro_t*)dest;\r\nconst dfilter_macro_t* m = (const dfilter_macro_t*)orig;\r\nDUMP_MACRO(m);\r\nd->name = g_strdup(m->name);\r\nd->text = g_strdup(m->text);\r\nd->usable = m->usable;\r\nif (m->parts) {\r\nguint nparts = 0;\r\nd->priv = g_strdup(m->text);\r\n{\r\nconst gchar* oldText = m->text;\r\nconst gchar* oldPriv = (const gchar*)m->priv;\r\ngchar* newPriv = (gchar*)d->priv;\r\nwhile(oldText && *oldText) {\r\n*(newPriv++) = *(oldPriv++);\r\noldText++;\r\n}\r\n}\r\ndo nparts++; while (m->parts[nparts]);\r\nd->parts = (gchar **)g_memdup(m->parts,(nparts+1)*(guint)sizeof(void*));\r\nnparts = 0;\r\nwhile(m->parts[nparts]) {\r\nif(nparts) {\r\nd->parts[nparts] = d->parts[nparts - 1] + (m->parts[nparts] - m->parts[nparts - 1]);\r\n} else {\r\nd->parts[nparts] = (gchar *)d->priv;\r\n}\r\nnparts++;\r\n}\r\nd->args_pos = (int *)g_memdup(m->args_pos,(--nparts)*(guint)sizeof(int));\r\n}\r\nDUMP_MACRO(d);\r\nreturn d;\r\n}\r\nstatic gboolean macro_name_chk(void *mp, const char *in_name, guint name_len,\r\nconst void *u1 _U_, const void *u2 _U_, char **error) {\r\ndfilter_macro_t* m = (dfilter_macro_t*)mp;\r\nguint i;\r\nif (name_len == 0) {\r\n*error = g_strdup("invalid name");\r\nreturn FALSE;\r\n}\r\nfor (i=0; i < name_len; i++) {\r\nif (!(in_name[i] == '_' || g_ascii_isalnum(in_name[i]) ) ) {\r\n*error = g_strdup("invalid char in name");\r\nreturn FALSE;\r\n}\r\n}\r\nif (!m->name || g_strcmp0(m->name, in_name)) {\r\nfor (i = 0; i < num_macros; i++) {\r\nif (!g_strcmp0(in_name, macros[i].name)) {\r\n*error = g_strdup_printf("macro '%s' already exists",\r\nin_name);\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nvoid dfilter_macro_init(void) {\r\nstatic uat_field_t uat_fields[] = {\r\nUAT_FLD_CSTRING_OTHER(macro,name,"Name",macro_name_chk,"The name of the macro."),\r\nUAT_FLD_CSTRING_ISPRINT(macro,text,"Text","The text this macro resolves to."),\r\nUAT_END_FIELDS\r\n};\r\ndfilter_macro_uat = uat_new("Display Filter Macros",\r\nsizeof(dfilter_macro_t),\r\nDFILTER_MACRO_FILENAME,\r\nTRUE,\r\n&macros,\r\n&num_macros,\r\n0,\r\n"ChDisplayFilterMacrosSection",\r\nmacro_copy,\r\nmacro_update,\r\nmacro_free,\r\nNULL,\r\nuat_fields);\r\nfvt_cache = g_hash_table_new(g_str_hash,g_str_equal);\r\n}\r\nvoid dfilter_macro_get_uat(uat_t **dfmu_ptr_ptr) {\r\n*dfmu_ptr_ptr = dfilter_macro_uat;\r\n}\r\nvoid dump_dfilter_macro_t(const dfilter_macro_t *m, const char *function, const char *file, int line)\r\n{\r\nprintf("\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n");\r\nif(m == NULL) {\r\nprintf(" dfilter_macro_t * == NULL! (via: %s(): %s:%d)\n", function, file, line);\r\nprintf("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");\r\n}\r\nprintf("DUMP of dfilter_macro_t: %p (via: %s(): %s:%d)\n", m, function, file, line);\r\nprintf(" &dfilter_macro->name == %p\n", &m->name);\r\nif(m->name == NULL) {\r\nprintf(" ->name == NULL\n");\r\n} else {\r\nprintf(" ->name == %p\n", m->name);\r\nprintf(" ->name == <%s>\n", m->name);\r\n}\r\nprintf(" &dfilter_macro->text == %p\n", &m->text);\r\nif(m->text == NULL) {\r\nprintf(" ->text == NULL\n");\r\n} else {\r\nprintf(" ->text == %p\n", m->text);\r\nprintf(" ->text == <%s>\n", m->text);\r\n}\r\nprintf(" &dfilter_macro->usable == %p\n", &m->usable);\r\nprintf(" ->usable == %u\n", m->usable);\r\nprintf(" &dfilter_macro->parts == %p\n", &m->parts);\r\nif(m->parts == NULL) {\r\nprintf(" ->parts == NULL\n");\r\n} else {\r\nint i = 0;\r\nwhile (m->parts[i]) {\r\nprintf(" ->parts[%d] == %p\n", i, m->parts[i]);\r\nprintf(" ->parts[%d] == <%s>\n", i, m->parts[i]);\r\ni++;\r\n}\r\nprintf(" ->parts[%d] == NULL\n", i);\r\n}\r\nprintf(" &dfilter_macro->args_pos == %p\n", &m->args_pos);\r\nif(m->args_pos == NULL) {\r\nprintf(" ->args_pos == NULL\n");\r\n} else {\r\nprintf(" ->args_pos == %p\n", m->args_pos);\r\n}\r\nprintf(" &dfilter_macro->argc == %p\n", &m->argc);\r\nprintf(" ->argc == %d\n", m->argc);\r\nprintf(" &dfilter_macro->priv == %p\n", &m->priv);\r\nif(m->priv == NULL) {\r\nprintf(" ->priv == NULL\n");\r\n} else {\r\nprintf(" ->priv == %p\n", m->priv);\r\nprintf(" ->priv == <%s>\n", (char *)m->priv);\r\n}\r\nprintf("\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n");\r\n}
