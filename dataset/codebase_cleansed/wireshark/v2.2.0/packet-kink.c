static int\r\ndissect_kink(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_){\r\nproto_item *ti = NULL;\r\nproto_tree *kink_tree = NULL;\r\nguint8 type;\r\nguint32 doi;\r\nguint chsumlen;\r\nguint8 next_payload;\r\nguint8 value_a_and_front_reserved;\r\nguint8 value_a;\r\nint offset=0;\r\ntype = tvb_get_guint8(tvb,offset);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "KINK");\r\ncol_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(type, kink_type_vals, "unknown"));\r\nti = proto_tree_add_item(tree, proto_kink, tvb, offset, -1, ENC_NA);\r\nkink_tree = proto_item_add_subtree(ti, ett_kink);\r\nproto_tree_add_uint(kink_tree, hf_kink_type, tvb, offset, 1, type);\r\noffset++;\r\nproto_tree_add_item(kink_tree, hf_kink_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(kink_tree, hf_kink_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\ndoi = tvb_get_ntohl(tvb, offset);\r\nif(doi == IPSEC){\r\nproto_tree_add_uint_format_value(kink_tree, hf_kink_domain_of_interpretation, tvb, offset, 4, doi, "IPsec (%u)", doi);\r\n}\r\nelse{\r\nproto_tree_add_uint_format_value(kink_tree, hf_kink_domain_of_interpretation, tvb, offset, 4, doi, "Not IPsec (%u)", doi);\r\n}\r\noffset += 4;\r\nproto_tree_add_item(kink_tree, hf_kink_transactionId, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nchsumlen = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(kink_tree, hf_kink_checkSumLength, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(kink_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nvalue_a_and_front_reserved = tvb_get_guint8(tvb, offset);\r\nvalue_a = (value_a_and_front_reserved & FRONT_ONE_BIT) >> A_BIT_SHIFT;\r\nproto_tree_add_uint(kink_tree, hf_kink_A, tvb, offset, 1, value_a);\r\nproto_tree_add_item(kink_tree, hf_kink_reserved15, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(kink_tree, hf_kink_checkSum, tvb, offset, chsumlen, ENC_NA);\r\nif((chsumlen % PADDING) != 0){\r\nchsumlen += (PADDING - (chsumlen % PADDING));\r\noffset += chsumlen;\r\n}\r\nelse{\r\noffset += chsumlen;\r\n}\r\ncontrol_payload(pinfo, tvb, offset, next_payload, kink_tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ncontrol_payload(packet_info *pinfo, tvbuff_t *tvb, int offset, guint8 next_payload, proto_tree *kink_tree){\r\nswitch(next_payload){\r\ncase KINK_DONE:\r\nbreak;\r\ncase KINK_AP_REQ:\r\ndissect_payload_kink_ap_req(pinfo, tvb, offset, kink_tree);\r\nbreak;\r\ncase KINK_AP_REP:\r\ndissect_payload_kink_ap_rep(pinfo, tvb, offset, kink_tree);\r\nbreak;\r\ncase KINK_KRB_ERROR:\r\ndissect_payload_kink_krb_error(pinfo, tvb, offset, kink_tree);\r\nbreak;\r\ncase KINK_TGT_REQ:\r\ndissect_payload_kink_tgt_req(pinfo, tvb, offset, kink_tree);\r\nbreak;\r\ncase KINK_TGT_REP:\r\ndissect_payload_kink_tgt_rep(pinfo, tvb, offset, kink_tree);\r\nbreak;\r\ncase KINK_ISAKMP:\r\ndissect_payload_kink_isakmp(pinfo, tvb, offset, kink_tree);\r\nbreak;\r\ncase KINK_ENCRYPT:\r\ndissect_payload_kink_encrypt(pinfo, tvb, offset, kink_tree);\r\nbreak;\r\ncase KINK_ERROR:\r\ndissect_payload_kink_error(pinfo, tvb, offset, kink_tree);\r\nbreak;\r\ndefault:\r\ndissect_payload_kink_not_defined(pinfo, tvb, offset, kink_tree);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndissect_payload_kink_ap_req(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree){\r\nproto_tree *payload_kink_ap_req_tree;\r\nproto_item *ti;\r\nguint8 next_payload;\r\nguint payload_length;\r\nguint16 krb_ap_req_length;\r\nint start_payload_offset = 0;\r\nstart_payload_offset = offset;\r\npayload_length = tvb_get_ntohs(tvb, offset + TO_PAYLOAD_LENGTH);\r\npayload_kink_ap_req_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_payload_kink_ap_req, NULL, "KINK_AP_REQ");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_ap_req_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(payload_kink_ap_req_tree, hf_kink_reserved8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nti = proto_tree_add_uint(payload_kink_ap_req_tree, hf_kink_payload_length, tvb, offset, 2, payload_length);\r\nif(payload_length <= PAYLOAD_HEADER){\r\nexpert_add_info(pinfo, ti, &ei_kink_payload_length_small);\r\n}\r\noffset += 2;\r\nproto_tree_add_item(payload_kink_ap_req_tree, hf_kink_epoch, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif(payload_length > PAYLOAD_HEADER){\r\ntvbuff_t *krb_tvb;\r\nkrb_ap_req_length = payload_length - PAYLOAD_HEADER;\r\nkrb_tvb=tvb_new_subset(tvb, offset, (krb_ap_req_length>tvb_captured_length_remaining(tvb, offset))?tvb_captured_length_remaining(tvb, offset):krb_ap_req_length, krb_ap_req_length);\r\nkeytype=kerberos_output_keytype();\r\ndissect_kerberos_main(krb_tvb, pinfo, payload_kink_ap_req_tree, FALSE, NULL);\r\n}\r\nif(payload_length % PADDING != 0){\r\npayload_length += (PADDING - (payload_length % PADDING));\r\n}\r\noffset = start_payload_offset + payload_length;\r\nif(payload_length > 0) {\r\ncontrol_payload(pinfo, tvb, offset, next_payload, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_payload_kink_ap_rep(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree){\r\nproto_tree *payload_kink_ap_rep_tree;\r\nproto_item *ti;\r\nguint8 next_payload;\r\nguint payload_length;\r\nguint16 krb_ap_rep_length;\r\nint start_payload_offset = 0;\r\npayload_length = tvb_get_ntohs(tvb, offset + TO_PAYLOAD_LENGTH);\r\nstart_payload_offset = offset;\r\npayload_kink_ap_rep_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_payload_kink_ap_rep, NULL, "KINK_AP_REP");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_ap_rep_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(payload_kink_ap_rep_tree, hf_kink_reserved8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nti = proto_tree_add_uint(payload_kink_ap_rep_tree, hf_kink_payload_length, tvb, offset, 2, payload_length);\r\nif(payload_length <= PAYLOAD_HEADER){\r\nexpert_add_info(pinfo, ti, &ei_kink_payload_length_small);\r\n}\r\noffset += 2;\r\nproto_tree_add_item(payload_kink_ap_rep_tree, hf_kink_epoch, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif(payload_length > PAYLOAD_HEADER){\r\ntvbuff_t *krb_tvb;\r\nkrb_ap_rep_length = payload_length - PAYLOAD_HEADER;\r\nkrb_tvb=tvb_new_subset(tvb, offset, (krb_ap_rep_length>tvb_captured_length_remaining(tvb, offset))?tvb_captured_length_remaining(tvb, offset):krb_ap_rep_length, krb_ap_rep_length);\r\nkeytype=kerberos_output_keytype();\r\ndissect_kerberos_main(krb_tvb, pinfo, payload_kink_ap_rep_tree, FALSE, NULL);\r\n}\r\nif(payload_length % PADDING != 0){\r\npayload_length += (PADDING - (payload_length % PADDING));\r\n}\r\noffset = start_payload_offset + payload_length;\r\nif(payload_length > 0) {\r\ncontrol_payload(pinfo, tvb, offset, next_payload, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_payload_kink_krb_error(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree){\r\nproto_tree *payload_kink_krb_error_tree;\r\nproto_item *ti;\r\nguint8 next_payload;\r\nguint payload_length;\r\nguint16 krb_error_length;\r\nint start_payload_offset = 0;\r\npayload_length = tvb_get_ntohs(tvb, offset + TO_PAYLOAD_LENGTH);\r\nstart_payload_offset = offset;\r\npayload_kink_krb_error_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_payload_kink_krb_error, NULL, "KINK_KRB_ERROR");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_krb_error_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(payload_kink_krb_error_tree, hf_kink_reserved8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nti = proto_tree_add_uint(payload_kink_krb_error_tree, hf_kink_payload_length, tvb, offset, 2, payload_length);\r\nif(payload_length <= KINK_KRB_ERROR_HEADER){\r\nexpert_add_info(pinfo, ti, &ei_kink_payload_length_small);\r\n}\r\nelse {\r\noffset += 2;\r\n}\r\nif(payload_length > KINK_KRB_ERROR_HEADER){\r\ntvbuff_t *krb_tvb;\r\nkrb_error_length = payload_length - KINK_KRB_ERROR_HEADER;\r\nkrb_tvb=tvb_new_subset(tvb, offset, (krb_error_length>tvb_captured_length_remaining(tvb, offset))?tvb_captured_length_remaining(tvb, offset):krb_error_length, krb_error_length);\r\ndissect_kerberos_main(krb_tvb, pinfo, payload_kink_krb_error_tree, FALSE, NULL);\r\n}\r\nif(payload_length % PADDING != 0){\r\npayload_length += (PADDING - (payload_length % PADDING));\r\n}\r\noffset = start_payload_offset + payload_length;\r\nif(payload_length > 0) {\r\ncontrol_payload(pinfo, tvb, offset, next_payload, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_payload_kink_tgt_req(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree){\r\nproto_tree *payload_kink_tgt_req_tree;\r\nguint8 next_payload;\r\nguint payload_length;\r\nguint16 realm_name_length;\r\nint start_payload_offset = 0;\r\npayload_length = tvb_get_ntohs(tvb, offset + TO_PAYLOAD_LENGTH);\r\nrealm_name_length = tvb_get_ntohs(tvb, offset + TO_REALM_NAME_LENGTH);\r\nstart_payload_offset = offset;\r\npayload_kink_tgt_req_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_payload_kink_tgt_req, NULL, "KINK_TGT_REQ");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_tgt_req_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(payload_kink_tgt_req_tree, hf_kink_reserved8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nproto_tree_add_uint(payload_kink_tgt_req_tree, hf_kink_payload_length, tvb, offset, 2, payload_length);\r\noffset += 2;\r\nproto_tree_add_uint(payload_kink_tgt_req_tree, hf_kink_realm_name_length, tvb, offset, 2, realm_name_length);\r\noffset += 2;\r\nproto_tree_add_item(payload_kink_tgt_req_tree, hf_kink_realm_name, tvb, offset, realm_name_length, ENC_NA|ENC_ASCII);\r\nif(payload_length % PADDING != 0){\r\npayload_length += (PADDING - (payload_length % PADDING));\r\n}\r\noffset = start_payload_offset + payload_length;\r\nif(payload_length > 0) {\r\ncontrol_payload(pinfo, tvb, offset, next_payload, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_payload_kink_tgt_rep(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree){\r\nproto_tree *payload_kink_tgt_rep_tree;\r\nguint8 next_payload;\r\nguint payload_length;\r\nguint princ_name_length;\r\nguint16 tgt_length;\r\nint start_payload_offset = 0;\r\npayload_length = tvb_get_ntohs(tvb, offset + TO_PAYLOAD_LENGTH);\r\nstart_payload_offset = offset;\r\npayload_kink_tgt_rep_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_payload_kink_tgt_rep, NULL, "KINK_TGT_REP");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_tgt_rep_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(payload_kink_tgt_rep_tree, hf_kink_reserved8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nproto_tree_add_uint(payload_kink_tgt_rep_tree, hf_kink_payload_length, tvb, offset, 2, payload_length);\r\noffset += 2;\r\nprinc_name_length = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(payload_kink_tgt_rep_tree, hf_kink_princ_name_length, tvb, offset, 2, princ_name_length);\r\noffset += 2;\r\nproto_tree_add_item(payload_kink_tgt_rep_tree, hf_kink_princ_name, tvb, offset, princ_name_length, ENC_NA|ENC_ASCII);\r\nif((princ_name_length + FRONT_TGT_REP_HEADER) % PADDING != 0){\r\noffset += (princ_name_length + PADDING - ((princ_name_length + FRONT_TGT_REP_HEADER) % PADDING));\r\n}\r\nelse{\r\noffset += princ_name_length;\r\n}\r\ntgt_length = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(payload_kink_tgt_rep_tree, hf_kink_tgt_length, tvb, offset, 2, tgt_length);\r\noffset += 2;\r\nproto_tree_add_item(payload_kink_tgt_rep_tree, hf_kink_tgt, tvb, offset, tgt_length, ENC_NA|ENC_ASCII);\r\nif(payload_length % PADDING!=0){\r\npayload_length += (PADDING - (payload_length % PADDING));\r\n}\r\noffset = start_payload_offset + payload_length;\r\nif(payload_length > 0) {\r\ncontrol_payload(pinfo, tvb, offset, next_payload, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_payload_kink_isakmp(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree){\r\nproto_tree *payload_kink_isakmp_tree;\r\nproto_item *ti;\r\nguint8 next_payload;\r\nguint payload_length,isakmp_length;\r\nint length, reported_length;\r\nguint8 inner_next_pload;\r\nint start_payload_offset = 0;\r\ntvbuff_t *isakmp_tvb;\r\npayload_length = tvb_get_ntohs(tvb, offset + TO_PAYLOAD_LENGTH);\r\nstart_payload_offset = offset;\r\npayload_kink_isakmp_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_payload_kink_isakmp, NULL, "KINK_ISAKMP");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_isakmp_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(payload_kink_isakmp_tree, hf_kink_reserved8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nti = proto_tree_add_uint(payload_kink_isakmp_tree, hf_kink_payload_length, tvb, offset, 2, payload_length);\r\nif(payload_length <= PAYLOAD_HEADER){\r\nexpert_add_info(pinfo, ti, &ei_kink_payload_length_small);\r\n}\r\noffset += 2;\r\ninner_next_pload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_isakmp_tree, hf_kink_inner_next_pload, tvb, offset, 1, inner_next_pload);\r\noffset += 1;\r\nproto_tree_add_item(payload_kink_isakmp_tree, hf_kink_qmversion, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(payload_kink_isakmp_tree, hf_kink_reserved16, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif(payload_length > PAYLOAD_HEADER){\r\nisakmp_length = payload_length - PAYLOAD_HEADER;\r\nlength = tvb_captured_length_remaining(tvb, offset);\r\nif (length > (int)isakmp_length)\r\nlength = isakmp_length;\r\nreported_length = tvb_reported_length_remaining(tvb, offset);\r\nif (reported_length > (int)isakmp_length)\r\nreported_length = isakmp_length;\r\nisakmp_tvb = tvb_new_subset(tvb, offset, length, reported_length);\r\nisakmp_dissect_payloads(isakmp_tvb, payload_kink_isakmp_tree, 1, inner_next_pload, 0, isakmp_length, pinfo);\r\n}\r\nif(payload_length % PADDING != 0){\r\npayload_length += (PADDING - (payload_length % PADDING));\r\n}\r\noffset = start_payload_offset + payload_length;\r\nif(payload_length > 0) {\r\ncontrol_payload(pinfo, tvb, offset, next_payload, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_payload_kink_encrypt(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree){\r\nproto_tree *payload_kink_encrypt_tree;\r\nproto_item *ti;\r\nguint8 next_payload;\r\nguint payload_length;\r\n#ifdef HAVE_KERBEROS\r\ngint encrypt_length;\r\n#endif\r\nguint8 inner_next_pload;\r\nguint16 inner_payload_length;\r\nint start_payload_offset = 0;\r\npayload_length = tvb_get_ntohs(tvb,offset + TO_PAYLOAD_LENGTH);\r\nstart_payload_offset = offset;\r\n#ifdef HAVE_KERBEROS\r\nencrypt_length = payload_length - FROM_NP_TO_PL;\r\n#endif\r\npayload_kink_encrypt_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_payload_kink_encrypt, NULL, "KINK_ENCRYPT");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_encrypt_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(payload_kink_encrypt_tree, hf_kink_reserved8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nti = proto_tree_add_uint(payload_kink_encrypt_tree, hf_kink_payload_length, tvb, offset, 2, payload_length);\r\nif(payload_length <= PAYLOAD_HEADER){\r\nexpert_add_info(pinfo, ti, &ei_kink_payload_length_small);\r\n}\r\noffset += 2;\r\nif(keytype != 0){\r\n#ifdef HAVE_KERBEROS\r\ntvbuff_t *next_tvb;\r\nguint8 *plaintext=NULL;\r\nnext_tvb=tvb_new_subset(tvb, offset, MIN(tvb_captured_length_remaining(tvb, offset), encrypt_length), encrypt_length);\r\nplaintext=decrypt_krb5_data(tree, pinfo, 0, next_tvb, keytype, NULL);\r\nif(plaintext){\r\nnext_tvb=tvb_new_child_real_data(tvb, plaintext, encrypt_length, encrypt_length);\r\ntvb_set_free_cb(next_tvb, g_free);\r\nadd_new_data_source(pinfo, next_tvb, "decrypted kink encrypt");\r\ndissect_decrypt_kink_encrypt(pinfo, next_tvb, tree, encrypt_length);\r\n}\r\n#endif\r\n}\r\nelse{\r\ninner_next_pload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_encrypt_tree, hf_kink_inner_next_pload, tvb, offset, 1, inner_next_pload);\r\noffset += 1;\r\nproto_tree_add_item(payload_kink_encrypt_tree, hf_kink_reserved24, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nif(payload_length > PAYLOAD_HEADER){\r\ninner_payload_length = payload_length - PAYLOAD_HEADER;\r\nproto_tree_add_item(payload_kink_encrypt_tree, hf_kink_payload, tvb, offset, inner_payload_length, ENC_NA);\r\n}\r\n}\r\nif(payload_length % PADDING !=0){\r\npayload_length += (PADDING - (payload_length % PADDING));\r\n}\r\noffset = start_payload_offset + payload_length;\r\nif(payload_length > 0) {\r\ncontrol_payload(pinfo, tvb, offset, next_payload, tree);\r\n}\r\n}\r\nstatic void\r\ndissect_decrypt_kink_encrypt(packet_info *pinfo, tvbuff_t *tvb, proto_tree *tree, int payload_length){\r\nproto_tree *decrypt_kink_encrypt_tree;\r\nint offset=0;\r\nguint8 next_payload;\r\ndecrypt_kink_encrypt_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_decrypt_kink_encrypt, NULL, "decrypted data");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(decrypt_kink_encrypt_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(decrypt_kink_encrypt_tree, hf_kink_reserved24, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\ncontrol_payload(pinfo, tvb, offset, next_payload, decrypt_kink_encrypt_tree);\r\n}\r\nstatic void\r\ndissect_payload_kink_error(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree){\r\nproto_tree *payload_kink_error_tree;\r\nproto_item *ti;\r\nguint8 next_payload;\r\nguint16 payload_length;\r\nint start_payload_offset = 0;\r\npayload_length = tvb_get_ntohs(tvb,offset + TO_PAYLOAD_LENGTH);\r\nstart_payload_offset = offset;\r\npayload_kink_error_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_payload_kink_error, NULL, "KINK_ERROR");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_error_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(payload_kink_error_tree, hf_kink_reserved8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nti = proto_tree_add_uint(payload_kink_error_tree, hf_kink_payload_length, tvb, offset, 2, payload_length);\r\nif(payload_length != KINK_ERROR_LENGTH){\r\nexpert_add_info(pinfo, ti, &ei_kink_payload_length_mismatch);\r\n}\r\noffset += 2;\r\nproto_tree_add_item(payload_kink_error_tree, hf_kink_error_code, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset = start_payload_offset + KINK_ERROR_LENGTH;\r\ncontrol_payload(pinfo, tvb, offset, next_payload, tree);\r\n}\r\nstatic void\r\ndissect_payload_kink_not_defined(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree){\r\nproto_tree *payload_kink_not_defined_tree;\r\nguint8 next_payload;\r\nguint payload_length;\r\nint start_payload_offset = 0;\r\nstart_payload_offset = offset;\r\npayload_length = tvb_get_ntohs(tvb, offset + TO_PAYLOAD_LENGTH);\r\npayload_kink_not_defined_tree = proto_tree_add_subtree(tree, tvb, offset, payload_length,\r\nett_payload_not_defined, NULL, "UNKNOWN PAYLOAD");\r\nnext_payload = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(payload_kink_not_defined_tree, hf_kink_next_payload, tvb, offset, 1, next_payload);\r\noffset ++;\r\nproto_tree_add_item(payload_kink_not_defined_tree, hf_kink_reserved8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nproto_tree_add_uint(payload_kink_not_defined_tree, hf_kink_payload_length, tvb, offset, 2, payload_length);\r\nif(payload_length % PADDING != 0){\r\npayload_length += (PADDING - (payload_length % PADDING));\r\n}\r\noffset = start_payload_offset + payload_length;\r\nif(payload_length > 0) {\r\ncontrol_payload(pinfo, tvb, offset, next_payload, tree);\r\n}\r\n}\r\nstatic void\r\nkink_fmt_version( gchar *result, guint32 version )\r\n{\r\nguint8 major_version, minor_version;\r\nmajor_version = (guint8)((version & FRONT_FOUR_BIT) >> VERSION_BIT_SHIFT);\r\nminor_version = (guint8)(version & SECOND_FOUR_BIT);\r\ng_snprintf( result, ITEM_LABEL_LENGTH, "%d.%02d", major_version, minor_version);\r\n}\r\nvoid\r\nproto_register_kink(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_kink_type,\r\n{ "Type", "kink.type",\r\nFT_UINT8, BASE_DEC, VALS(kink_type_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_length,\r\n{ "Length", "kink.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_transactionId,\r\n{ "Transaction ID", "kink.transactionId",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_checkSumLength,\r\n{ "Checksum Length", "kink.checkSumLength",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_A,\r\n{ "A", "kink.A",\r\nFT_UINT8, BASE_DEC, VALS(kink_A_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_version,\r\n{ "Version", "kink.version",\r\nFT_UINT8, BASE_CUSTOM, CF_FUNC(kink_fmt_version), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_domain_of_interpretation,\r\n{ "Domain Of Interpretation", "kink.domain_of_interpretation",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_qmversion,\r\n{ "QMVersion", "kink.qmversion",\r\nFT_UINT8, BASE_CUSTOM, CF_FUNC(kink_fmt_version), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_error_code,\r\n{ "ErrorCode", "kink.error_code",\r\nFT_UINT32, BASE_DEC|BASE_RANGE_STRING, RVALS(kink_error_rvals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_reserved8,\r\n{ "Reserved", "kink.reserved",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_reserved15,\r\n{ "Reserved", "kink.reserved",\r\nFT_UINT16, BASE_DEC, NULL, SECOND_FIFTEEN_BIT,\r\nNULL, HFILL }},\r\n{ &hf_kink_reserved16,\r\n{ "Reserved", "kink.reserved",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_kink_reserved24,\r\n{ "Reserved", "kink.reserved",\r\nFT_UINT24, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_kink_checkSum,\r\n{ "Checksum", "kink.checkSum",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_next_payload,\r\n{ "Next Payload", "kink.nextPayload",\r\nFT_UINT8, BASE_DEC, VALS(kink_next_payload), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_payload_length,\r\n{ "Payload Length", "kink.payloadLength",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_epoch,\r\n{ "EPOCH", "kink.epoch",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_inner_next_pload,\r\n{ "InnerNextPload", "kink.innerNextPload",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_kink_realm_name_length,\r\n{ "RealmNameLength", "kink.realmNameLength",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_kink_realm_name,\r\n{ "RealmName", "kink.realmName",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_kink_princ_name_length,\r\n{ "PrincNameLength", "kink.princNameLength",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_kink_princ_name,\r\n{ "PrincName", "kink.princName",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_kink_tgt_length,\r\n{ "TGT Length", "kink.tgtLength",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_kink_tgt,\r\n{ "TGT", "kink.tgt",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_kink_payload,\r\n{ "Payload", "kink.payload",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_kink,\r\n&ett_kink_payload,\r\n&ett_payload_kink_ap_req,\r\n&ett_payload_kink_ap_rep,\r\n&ett_payload_kink_krb_error,\r\n&ett_payload_kink_tgt_req,\r\n&ett_payload_kink_tgt_rep,\r\n&ett_payload_kink_isakmp,\r\n&ett_payload_kink_encrypt,\r\n&ett_payload_kink_error,\r\n&ett_payload_not_defined,\r\n&ett_decrypt_kink_encrypt,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_kink_payload_length_small, { "kink.payload_length_small", PI_PROTOCOL, PI_WARN, "This Payload Length is too small", EXPFILL }},\r\n{ &ei_kink_payload_length_mismatch, { "kink.payload_length_mismatch", PI_PROTOCOL, PI_WARN, "This Payload Length is mismatch", EXPFILL }},\r\n};\r\nexpert_module_t* expert_kink;\r\nproto_kink = proto_register_protocol("Kerberized Internet Negotiation of Key", "KINK", "kink");\r\nproto_register_field_array(proto_kink, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_kink = expert_register_protocol(proto_kink);\r\nexpert_register_field_array(expert_kink, ei, array_length(ei));\r\n}\r\nvoid proto_reg_handoff_kink(void) {\r\ndissector_handle_t kink_handle = NULL;\r\nkink_handle = create_dissector_handle(dissect_kink, proto_kink);\r\ndissector_add_uint("udp.port", KINK_PORT, kink_handle);\r\n}
