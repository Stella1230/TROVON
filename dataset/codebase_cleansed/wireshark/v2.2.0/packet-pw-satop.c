static\r\nvoid dissect_pw_satop(tvbuff_t * tvb_original\r\n,packet_info * pinfo\r\n,proto_tree * tree\r\n,pwc_demux_type_t demux)\r\n{\r\nconst int encaps_size = 4;\r\ngint packet_size;\r\ngint payload_size;\r\ngint padding_size;\r\nint properties;\r\nenum {\r\nPAY_NO_IDEA = 0\r\n,PAY_LIKE_E1\r\n,PAY_LIKE_T1\r\n,PAY_LIKE_E3_T3\r\n,PAY_LIKE_OCTET_ALIGNED_T1\r\n} payload_properties;\r\npacket_size = tvb_reported_length_remaining(tvb_original, 0);\r\nif (packet_size < 4)\r\n{\r\nproto_item *item;\r\nitem = proto_tree_add_item(tree, proto, tvb_original, 0, -1, ENC_NA);\r\nexpert_add_info_format(pinfo, item, &ei_cw_packet_size_too_small,\r\n"PW packet size (%d) is too small to carry sensible information"\r\n,(int)packet_size);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, shortname);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Malformed: PW packet is too small");\r\nreturn;\r\n}\r\nswitch (demux)\r\n{\r\ncase PWC_DEMUX_MPLS:\r\nif (dissect_try_cw_first_nibble(tvb_original, pinfo, tree))\r\n{\r\nreturn;\r\n}\r\nbreak;\r\ncase PWC_DEMUX_UDP:\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nreturn;\r\n}\r\nproperties = 0;\r\nif (0 != (tvb_get_guint8(tvb_original, 0) & 0xf0 ))\r\n{\r\nproperties |= PWC_CW_BAD_BITS03;\r\n}\r\nif (0 != (tvb_get_guint8(tvb_original, 0) & 0x03 ))\r\n{\r\nproperties |= PWC_CW_BAD_RSV;\r\n}\r\nif (0 != (tvb_get_guint8(tvb_original, 1) & 0xc0 ))\r\n{\r\nproperties |= PWC_CW_BAD_FRAG;\r\n}\r\n{\r\nint cw_len;\r\ngint payload_size_from_packet;\r\ncw_len = tvb_get_guint8(tvb_original, 1) & 0x3f;\r\npayload_size_from_packet = packet_size - encaps_size;\r\nif (cw_len != 0)\r\n{\r\ngint payload_size_from_cw;\r\npayload_size_from_cw = cw_len - encaps_size;\r\npayload_size = payload_size_from_packet;\r\npadding_size = 0;\r\nif (payload_size_from_cw < 0)\r\n{\r\nproperties |= PWC_CW_BAD_PAYLEN_LT_0;\r\n}\r\nelse if (payload_size_from_cw > payload_size_from_packet)\r\n{\r\nproperties |= PWC_CW_BAD_PAYLEN_GT_PACKET;\r\n}\r\nelse if (payload_size_from_packet >= 64)\r\n{\r\nproperties |= PWC_CW_BAD_LEN_MUST_BE_0;\r\n}\r\nelse\r\n{\r\npayload_size = payload_size_from_cw;\r\npadding_size = payload_size_from_packet - payload_size_from_cw;\r\n}\r\n}\r\nelse\r\n{\r\npayload_size = payload_size_from_packet;\r\npadding_size = 0;\r\n}\r\n}\r\nif (payload_size == 0)\r\n{\r\nif (0 == (tvb_get_guint8(tvb_original, 0) & 0x08 ))\r\n{\r\nproperties |= PWC_PAY_SIZE_BAD;\r\n}\r\n}\r\nif (payload_size == 256)\r\n{\r\npayload_properties = PAY_LIKE_E1;\r\n}\r\nelse if (payload_size == 192)\r\n{\r\npayload_properties = PAY_LIKE_T1;\r\n}\r\nelse if (payload_size == 1024)\r\n{\r\npayload_properties = PAY_LIKE_E3_T3;\r\n}\r\nelse if ((payload_size != 0) && (payload_size % 25 == 0))\r\n{\r\npayload_properties = PAY_LIKE_OCTET_ALIGNED_T1;\r\n}\r\nelse\r\n{\r\npayload_properties = PAY_NO_IDEA;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, shortname);\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (properties & PWC_ANYOF_CW_BAD)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "CW:Bad, ");\r\n}\r\nif (properties & PWC_PAY_SIZE_BAD)\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Payload size:0 (Bad)");\r\n}\r\nelse\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "TDM octets:%d", (int)payload_size);\r\n}\r\nif (padding_size != 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Padding:%d", (int)padding_size);\r\n}\r\n{\r\nproto_item* item;\r\nitem = proto_tree_add_item(tree, proto, tvb_original, 0, -1, ENC_NA);\r\npwc_item_append_cw(item,tvb_get_ntohl(tvb_original, 0),TRUE);\r\npwc_item_append_text_n_items(item,(int)payload_size,"octet");\r\n{\r\nproto_tree* tree2;\r\ntree2 = proto_item_add_subtree(item, ett);\r\n{\r\ntvbuff_t* tvb;\r\nproto_item* item2;\r\ntvb = tvb_new_subset_length(tvb_original, 0, PWC_SIZEOF_CW);\r\nitem2 = proto_tree_add_item(tree2, hf_cw, tvb, 0, -1, ENC_NA);\r\npwc_item_append_cw(item2, tvb_get_ntohl(tvb, 0),FALSE);\r\n{\r\nproto_tree* tree3;\r\ntree3 = proto_item_add_subtree(item2, ett);\r\n{\r\nproto_item* item3;\r\nif (properties & PWC_CW_BAD_BITS03)\r\n{\r\nitem3 = proto_tree_add_item(tree3, hf_cw_bits03, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, item3, &ei_cw_bits03);\r\n}\r\nproto_tree_add_item(tree3, hf_cw_l , tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree3, hf_cw_r , tvb, 0, 1, ENC_BIG_ENDIAN);\r\nitem3 = proto_tree_add_item(tree3, hf_cw_rsv, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nif (properties & PWC_CW_BAD_RSV)\r\n{\r\nexpert_add_info(pinfo, item3, &ei_cw_rsv);\r\n}\r\nitem3 = proto_tree_add_item(tree3, hf_cw_frg, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nif (properties & PWC_CW_BAD_FRAG)\r\n{\r\nexpert_add_info(pinfo, item3, &ei_cw_frg);\r\n}\r\nitem3 = proto_tree_add_item(tree3, hf_cw_len, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nif (properties & PWC_CW_BAD_PAYLEN_LT_0)\r\n{\r\nexpert_add_info_format(pinfo, item3, &ei_payload_size_invalid,\r\n"Bad Length: too small, must be > %d",\r\n(int)encaps_size);\r\n}\r\nif (properties & PWC_CW_BAD_PAYLEN_GT_PACKET)\r\n{\r\nexpert_add_info_format(pinfo, item3, &ei_payload_size_invalid,\r\n"Bad Length: must be <= than PSN packet size (%d)",\r\n(int)packet_size);\r\n}\r\nif (properties & PWC_CW_BAD_LEN_MUST_BE_0)\r\n{\r\nexpert_add_info_format(pinfo, item3, &ei_payload_size_invalid,\r\n"Bad Length: must be 0 if SAToP packet size (%d) is > 64",\r\n(int)packet_size);\r\n}\r\nproto_tree_add_item(tree3, hf_cw_seq, tvb, 2, 2, ENC_BIG_ENDIAN);\r\n}\r\n}\r\n}\r\n}\r\nif (properties & PWC_PAY_SIZE_BAD)\r\n{\r\nexpert_add_info_format(pinfo, item, &ei_payload_size_invalid,\r\n"SAToP payload: none found. Size of payload must be <> 0");\r\n}\r\nelse if (payload_size == 0)\r\n{\r\nexpert_add_info(pinfo, item, &ei_payload_size_invalid_undecoded);\r\n}\r\nelse\r\n{\r\nproto_tree* tree2;\r\ntree2 = proto_item_add_subtree(item, ett);\r\n{\r\nproto_item* item2;\r\ntvbuff_t* tvb;\r\ntvb = tvb_new_subset_length(tvb_original, PWC_SIZEOF_CW, payload_size);\r\nitem2 = proto_tree_add_item(tree2, hf_payload, tvb, 0, -1, ENC_NA);\r\npwc_item_append_text_n_items(item2,(int)payload_size,"octet");\r\n{\r\nproto_tree* tree3;\r\nconst char* s;\r\nswitch(payload_properties)\r\n{\r\ncase PAY_LIKE_E1:\r\ns = " (looks like E1)";\r\nbreak;\r\ncase PAY_LIKE_T1:\r\ns = " (looks like T1)";\r\nbreak;\r\ncase PAY_LIKE_E3_T3:\r\ns = " (looks like E3/T3)";\r\nbreak;\r\ncase PAY_LIKE_OCTET_ALIGNED_T1:\r\ns = " (looks like octet-aligned T1)";\r\nbreak;\r\ncase PAY_NO_IDEA:\r\ndefault:\r\ns = "";\r\nbreak;\r\n}\r\nproto_item_append_text(item2, "%s", s);\r\ntree3 = proto_item_add_subtree(item2, ett);\r\ncall_data_dissector(tvb, pinfo, tree3);\r\nitem2 = proto_tree_add_int(tree3, hf_payload_l, tvb, 0, 0\r\n,(int)payload_size);\r\nPROTO_ITEM_SET_HIDDEN(item2);\r\n}\r\n}\r\n}\r\nif (padding_size > 0)\r\n{\r\nproto_tree* tree2;\r\ntree2 = proto_item_add_subtree(item, ett);\r\n{\r\ntvbuff_t* tvb;\r\ntvb = tvb_new_subset(tvb_original, PWC_SIZEOF_CW + payload_size, padding_size, -1);\r\ncall_dissector(pw_padding_handle, tvb, pinfo, tree2);\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic\r\nint dissect_pw_satop_mpls( tvbuff_t * tvb_original, packet_info * pinfo, proto_tree * tree, void* data _U_)\r\n{\r\ndissect_pw_satop(tvb_original,pinfo,tree,PWC_DEMUX_MPLS);\r\nreturn tvb_captured_length(tvb_original);\r\n}\r\nstatic\r\nint dissect_pw_satop_udp( tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)\r\n{\r\ndissect_pw_satop(tvb,pinfo,tree,PWC_DEMUX_UDP);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_pw_satop(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_cw ,{"Control Word" ,"pwsatop.cw"\r\n,FT_NONE ,BASE_NONE ,NULL\r\n,0 ,NULL ,HFILL }},\r\n{&hf_cw_bits03,{"Bits 0 to 3" ,"pwsatop.cw.bits03"\r\n,FT_UINT8 ,BASE_DEC ,NULL\r\n,0xf0 ,NULL ,HFILL }},\r\n{&hf_cw_l, {"L bit: TDM payload state" ,"pwsatop.cw.lbit"\r\n,FT_UINT8 ,BASE_DEC ,VALS(pwc_vals_cw_l_bit)\r\n,0x08 ,NULL ,HFILL }},\r\n{&hf_cw_r, {"R bit: Local CE-bound IWF" ,"pwsatop.cw.rbit"\r\n,FT_UINT8 ,BASE_DEC ,VALS(pwc_vals_cw_r_bit)\r\n,0x04 ,NULL ,HFILL }},\r\n{&hf_cw_rsv, {"Reserved" ,"pwsatop.cw.rsv"\r\n,FT_UINT8 ,BASE_DEC ,NULL\r\n,0x03 ,NULL ,HFILL }},\r\n{&hf_cw_frg, {"Fragmentation" ,"pwsatop.cw.frag"\r\n,FT_UINT8 ,BASE_DEC ,VALS(pwc_vals_cw_frag)\r\n,0xc0 ,NULL ,HFILL }},\r\n{&hf_cw_len, {"Length" ,"pwsatop.cw.length"\r\n,FT_UINT8 ,BASE_DEC ,NULL\r\n,0x3f ,NULL ,HFILL }},\r\n{&hf_cw_seq, {"Sequence number" ,"pwsatop.cw.seqno"\r\n,FT_UINT16 ,BASE_DEC ,NULL\r\n,0 ,NULL ,HFILL }},\r\n{&hf_payload ,{"TDM payload" ,"pwsatop.payload"\r\n,FT_BYTES ,BASE_NONE ,NULL\r\n,0 ,NULL ,HFILL }},\r\n{&hf_payload_l ,{"TDM payload length" ,"pwsatop.payload.len"\r\n,FT_INT32 ,BASE_DEC ,NULL\r\n,0 ,NULL ,HFILL }}\r\n};\r\nstatic gint *ett_array[] = {\r\n&ett\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_cw_packet_size_too_small, { "pwsatop.packet_size_too_small", PI_MALFORMED, PI_ERROR, "PW packet size (%d) is too small to carry sensible information", EXPFILL }},\r\n{ &ei_cw_bits03, { "pwsatop.cw.bits03.not_zero", PI_MALFORMED, PI_ERROR, "Bits 0..3 of Control Word must be 0", EXPFILL }},\r\n{ &ei_cw_rsv, { "pwsatop.cw.rsv.not_zero", PI_MALFORMED, PI_ERROR, "RSV bits of Control Word must be 0", EXPFILL }},\r\n{ &ei_cw_frg, { "pwsatop.cw.frag.not_allowed", PI_MALFORMED, PI_ERROR, "Fragmentation of payload is not allowed for SAToP", EXPFILL }},\r\n{ &ei_payload_size_invalid, { "pwsatop.payload.size_invalid", PI_MALFORMED, PI_ERROR, "Bad Length: too small", EXPFILL }},\r\n{ &ei_payload_size_invalid_undecoded, { "pwsatop.payload.undecoded", PI_UNDECODED, PI_NOTE, "SAToP payload: omitted to conserve bandwidth", EXPFILL }},\r\n};\r\nexpert_module_t* expert_pwsatop;\r\nproto = proto_register_protocol(pwc_longname_pw_satop, shortname, "pwsatopcw");\r\nproto_register_field_array(proto, hf, array_length(hf));\r\nproto_register_subtree_array(ett_array, array_length(ett_array));\r\nexpert_pwsatop = expert_register_protocol(proto);\r\nexpert_register_field_array(expert_pwsatop, ei, array_length(ei));\r\nregister_dissector("pw_satop_udp", dissect_pw_satop_udp, proto);\r\nreturn;\r\n}\r\nvoid proto_reg_handoff_pw_satop(void)\r\n{\r\ndissector_handle_t pw_satop_mpls_handle;\r\npw_padding_handle = find_dissector_add_dependency("pw_padding", proto);\r\npw_satop_mpls_handle = create_dissector_handle( dissect_pw_satop_mpls, proto );\r\ndissector_add_for_decode_as("mpls.label", pw_satop_mpls_handle);\r\ndissector_add_for_decode_as("udp.port", find_dissector("pw_satop_udp"));\r\n}
