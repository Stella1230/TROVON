void\r\nftypes_initialize(void)\r\n{\r\nftype_register_bytes();\r\nftype_register_double();\r\nftype_register_ieee_11073_float();\r\nftype_register_integers();\r\nftype_register_ipv4();\r\nftype_register_ipv6();\r\nftype_register_guid();\r\nftype_register_none();\r\nftype_register_string();\r\nftype_register_time();\r\nftype_register_tvbuff();\r\nftype_register_pcre();\r\n}\r\nvoid\r\nftype_register(enum ftenum ftype, ftype_t *ft)\r\n{\r\ng_assert(ftype < FT_NUM_TYPES);\r\ng_assert(ftype == ft->ftype);\r\ng_assert(type_list[ftype] == NULL);\r\ntype_list[ftype] = ft;\r\n}\r\nstatic enum ftenum\r\nsame_ftype(const enum ftenum ftype)\r\n{\r\nswitch (ftype) {\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\nreturn FT_INT32;\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\nreturn FT_UINT32;\r\ncase FT_INT40:\r\ncase FT_INT48:\r\ncase FT_INT56:\r\ncase FT_INT64:\r\nreturn FT_INT64;\r\ncase FT_UINT40:\r\ncase FT_UINT48:\r\ncase FT_UINT56:\r\ncase FT_UINT64:\r\nreturn FT_UINT64;\r\ncase FT_STRING:\r\ncase FT_STRINGZ:\r\ncase FT_UINT_STRING:\r\nreturn FT_STRING;\r\ncase FT_FLOAT:\r\ncase FT_DOUBLE:\r\nreturn FT_DOUBLE;\r\ncase FT_BYTES:\r\ncase FT_UINT_BYTES:\r\nreturn FT_BYTES;\r\ncase FT_OID:\r\ncase FT_REL_OID:\r\nreturn FT_OID;\r\ncase FT_IPv4:\r\ncase FT_IPv6:\r\ndefault:\r\nreturn ftype;\r\n}\r\n}\r\ngboolean\r\nftype_similar_types(const enum ftenum ftype_a, const enum ftenum ftype_b)\r\n{\r\nreturn (same_ftype(ftype_a) == same_ftype(ftype_b));\r\n}\r\nconst char*\r\nftype_name(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->name;\r\n}\r\nconst char*\r\nftype_pretty_name(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->pretty_name;\r\n}\r\nint\r\nftype_length(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->wire_size;\r\n}\r\ngboolean\r\nftype_can_slice(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->slice ? TRUE : FALSE;\r\n}\r\ngboolean\r\nftype_can_eq(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->cmp_eq ? TRUE : FALSE;\r\n}\r\ngboolean\r\nftype_can_ne(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->cmp_ne ? TRUE : FALSE;\r\n}\r\ngboolean\r\nftype_can_gt(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->cmp_gt ? TRUE : FALSE;\r\n}\r\ngboolean\r\nftype_can_ge(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->cmp_ge ? TRUE : FALSE;\r\n}\r\ngboolean\r\nftype_can_lt(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->cmp_lt ? TRUE : FALSE;\r\n}\r\ngboolean\r\nftype_can_le(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->cmp_le ? TRUE : FALSE;\r\n}\r\ngboolean\r\nftype_can_bitwise_and(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->cmp_bitwise_and ? TRUE : FALSE;\r\n}\r\ngboolean\r\nftype_can_contains(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->cmp_contains ? TRUE : FALSE;\r\n}\r\ngboolean\r\nftype_can_matches(enum ftenum ftype)\r\n{\r\nftype_t *ft;\r\nFTYPE_LOOKUP(ftype, ft);\r\nreturn ft->cmp_matches ? TRUE : FALSE;\r\n}\r\nfvalue_t*\r\nfvalue_new(ftenum_t ftype)\r\n{\r\nfvalue_t *fv;\r\nftype_t *ft;\r\nFvalueNewFunc new_value;\r\nfv = g_slice_new(fvalue_t);\r\nFTYPE_LOOKUP(ftype, ft);\r\nfv->ftype = ft;\r\nnew_value = ft->new_value;\r\nif (new_value) {\r\nnew_value(fv);\r\n}\r\nreturn fv;\r\n}\r\nvoid\r\nfvalue_init(fvalue_t *fv, ftenum_t ftype)\r\n{\r\nftype_t *ft;\r\nFvalueNewFunc new_value;\r\nFTYPE_LOOKUP(ftype, ft);\r\nfv->ftype = ft;\r\nnew_value = ft->new_value;\r\nif (new_value) {\r\nnew_value(fv);\r\n}\r\n}\r\nfvalue_t*\r\nfvalue_from_unparsed(ftenum_t ftype, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nfvalue_t *fv;\r\nfv = fvalue_new(ftype);\r\nif (fv->ftype->val_from_unparsed) {\r\nif (fv->ftype->val_from_unparsed(fv, s, allow_partial_value, err_msg)) {\r\nif (err_msg != NULL)\r\n*err_msg = NULL;\r\nreturn fv;\r\n}\r\n}\r\nelse {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" cannot be converted to %s.",\r\ns, ftype_pretty_name(ftype));\r\n}\r\n}\r\nFVALUE_FREE(fv);\r\nreturn NULL;\r\n}\r\nfvalue_t*\r\nfvalue_from_string(ftenum_t ftype, const char *s, gchar **err_msg)\r\n{\r\nfvalue_t *fv;\r\nfv = fvalue_new(ftype);\r\nif (fv->ftype->val_from_string) {\r\nif (fv->ftype->val_from_string(fv, s, err_msg)) {\r\nif (err_msg != NULL)\r\n*err_msg = NULL;\r\nreturn fv;\r\n}\r\n}\r\nelse {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" cannot be converted to %s.",\r\ns, ftype_pretty_name(ftype));\r\n}\r\n}\r\nFVALUE_FREE(fv);\r\nreturn NULL;\r\n}\r\nftenum_t\r\nfvalue_type_ftenum(fvalue_t *fv)\r\n{\r\nreturn fv->ftype->ftype;\r\n}\r\nconst char*\r\nfvalue_type_name(fvalue_t *fv)\r\n{\r\nreturn fv->ftype->name;\r\n}\r\nguint\r\nfvalue_length(fvalue_t *fv)\r\n{\r\nif (fv->ftype->len)\r\nreturn fv->ftype->len(fv);\r\nelse\r\nreturn fv->ftype->wire_size;\r\n}\r\nint\r\nfvalue_string_repr_len(fvalue_t *fv, ftrepr_t rtype, int field_display)\r\n{\r\ng_assert(fv->ftype->len_string_repr);\r\nreturn fv->ftype->len_string_repr(fv, rtype, field_display);\r\n}\r\nchar *\r\nfvalue_to_string_repr(wmem_allocator_t *scope, fvalue_t *fv, ftrepr_t rtype, int field_display)\r\n{\r\nchar *buf;\r\nint len;\r\nif (fv->ftype->val_to_string_repr == NULL) {\r\nreturn NULL;\r\n}\r\nif ((len = fvalue_string_repr_len(fv, rtype, field_display)) >= 0) {\r\nbuf = (char *)wmem_alloc0(scope, len + 1);\r\n} else {\r\nreturn NULL;\r\n}\r\nfv->ftype->val_to_string_repr(fv, rtype, field_display, buf, (unsigned int)len+1);\r\nreturn buf;\r\n}\r\nstatic void\r\nslice_func(gpointer data, gpointer user_data)\r\n{\r\ndrange_node *drnode = (drange_node *)data;\r\nslice_data_t *slice_data = (slice_data_t *)user_data;\r\ngint start_offset;\r\ngint length = 0;\r\ngint end_offset = 0;\r\nguint field_length;\r\nfvalue_t *fv;\r\ndrange_node_end_t ending;\r\nif (slice_data->slice_failure) {\r\nreturn;\r\n}\r\nstart_offset = drange_node_get_start_offset(drnode);\r\nending = drange_node_get_ending(drnode);\r\nfv = slice_data->fv;\r\nfield_length = fvalue_length(fv);\r\nif (start_offset < 0) {\r\nstart_offset = field_length + start_offset;\r\nif (start_offset < 0) {\r\nslice_data->slice_failure = TRUE;\r\nreturn;\r\n}\r\n}\r\nif (ending == DRANGE_NODE_END_T_TO_THE_END) {\r\nlength = field_length - start_offset;\r\nif (length <= 0) {\r\nslice_data->slice_failure = TRUE;\r\nreturn;\r\n}\r\n}\r\nelse if (ending == DRANGE_NODE_END_T_LENGTH) {\r\nlength = drange_node_get_length(drnode);\r\nif (start_offset + length > (int) field_length) {\r\nslice_data->slice_failure = TRUE;\r\nreturn;\r\n}\r\n}\r\nelse if (ending == DRANGE_NODE_END_T_OFFSET) {\r\nend_offset = drange_node_get_end_offset(drnode);\r\nif (end_offset < 0) {\r\nend_offset = field_length + end_offset;\r\nif (end_offset < start_offset) {\r\nslice_data->slice_failure = TRUE;\r\nreturn;\r\n}\r\n} else if (end_offset >= (int) field_length) {\r\nslice_data->slice_failure = TRUE;\r\nreturn;\r\n}\r\nlength = end_offset - start_offset + 1;\r\n}\r\nelse {\r\ng_assert_not_reached();\r\n}\r\ng_assert(start_offset >=0 && length > 0);\r\nfv->ftype->slice(fv, slice_data->bytes, start_offset, length);\r\n}\r\nfvalue_t*\r\nfvalue_slice(fvalue_t *fv, drange_t *d_range)\r\n{\r\nslice_data_t slice_data;\r\nfvalue_t *new_fv;\r\nslice_data.fv = fv;\r\nslice_data.bytes = g_byte_array_new();\r\nslice_data.slice_failure = FALSE;\r\ndrange_foreach_drange_node(d_range, slice_func, &slice_data);\r\nnew_fv = fvalue_new(FT_BYTES);\r\nfvalue_set_byte_array(new_fv, slice_data.bytes);\r\nreturn new_fv;\r\n}\r\nvoid\r\nfvalue_set_byte_array(fvalue_t *fv, GByteArray *value)\r\n{\r\ng_assert(fv->ftype->set_value_byte_array);\r\nfv->ftype->set_value_byte_array(fv, value);\r\n}\r\nvoid\r\nfvalue_set_bytes(fvalue_t *fv, const guint8 *value)\r\n{\r\ng_assert(fv->ftype->set_value_bytes);\r\nfv->ftype->set_value_bytes(fv, value);\r\n}\r\nvoid\r\nfvalue_set_guid(fvalue_t *fv, const e_guid_t *value)\r\n{\r\ng_assert(fv->ftype->set_value_guid);\r\nfv->ftype->set_value_guid(fv, value);\r\n}\r\nvoid\r\nfvalue_set_time(fvalue_t *fv, const nstime_t *value)\r\n{\r\ng_assert(fv->ftype->set_value_time);\r\nfv->ftype->set_value_time(fv, value);\r\n}\r\nvoid\r\nfvalue_set_string(fvalue_t *fv, const gchar *value)\r\n{\r\ng_assert(fv->ftype->set_value_string);\r\nfv->ftype->set_value_string(fv, value);\r\n}\r\nvoid\r\nfvalue_set_protocol(fvalue_t *fv, tvbuff_t *value, const gchar *name)\r\n{\r\ng_assert(fv->ftype->set_value_protocol);\r\nfv->ftype->set_value_protocol(fv, value, name);\r\n}\r\nvoid\r\nfvalue_set_uinteger(fvalue_t *fv, guint32 value)\r\n{\r\ng_assert(fv->ftype->set_value_uinteger);\r\nfv->ftype->set_value_uinteger(fv, value);\r\n}\r\nvoid\r\nfvalue_set_sinteger(fvalue_t *fv, gint32 value)\r\n{\r\ng_assert(fv->ftype->set_value_sinteger);\r\nfv->ftype->set_value_sinteger(fv, value);\r\n}\r\nvoid\r\nfvalue_set_uinteger64(fvalue_t *fv, guint64 value)\r\n{\r\ng_assert(fv->ftype->set_value_uinteger64);\r\nfv->ftype->set_value_uinteger64(fv, value);\r\n}\r\nvoid\r\nfvalue_set_sinteger64(fvalue_t *fv, gint64 value)\r\n{\r\ng_assert(fv->ftype->set_value_sinteger64);\r\nfv->ftype->set_value_sinteger64(fv, value);\r\n}\r\nvoid\r\nfvalue_set_floating(fvalue_t *fv, gdouble value)\r\n{\r\ng_assert(fv->ftype->set_value_floating);\r\nfv->ftype->set_value_floating(fv, value);\r\n}\r\ngpointer\r\nfvalue_get(fvalue_t *fv)\r\n{\r\ng_assert(fv->ftype->get_value);\r\nreturn fv->ftype->get_value(fv);\r\n}\r\nguint32\r\nfvalue_get_uinteger(fvalue_t *fv)\r\n{\r\ng_assert(fv->ftype->get_value_uinteger);\r\nreturn fv->ftype->get_value_uinteger(fv);\r\n}\r\ngint32\r\nfvalue_get_sinteger(fvalue_t *fv)\r\n{\r\ng_assert(fv->ftype->get_value_sinteger);\r\nreturn fv->ftype->get_value_sinteger(fv);\r\n}\r\nguint64\r\nfvalue_get_uinteger64(fvalue_t *fv)\r\n{\r\ng_assert(fv->ftype->get_value_uinteger64);\r\nreturn fv->ftype->get_value_uinteger64(fv);\r\n}\r\ngint64\r\nfvalue_get_sinteger64(fvalue_t *fv)\r\n{\r\ng_assert(fv->ftype->get_value_sinteger64);\r\nreturn fv->ftype->get_value_sinteger64(fv);\r\n}\r\ndouble\r\nfvalue_get_floating(fvalue_t *fv)\r\n{\r\ng_assert(fv->ftype->get_value_floating);\r\nreturn fv->ftype->get_value_floating(fv);\r\n}\r\ngboolean\r\nfvalue_eq(const fvalue_t *a, const fvalue_t *b)\r\n{\r\ng_assert(a->ftype->cmp_eq);\r\nreturn a->ftype->cmp_eq(a, b);\r\n}\r\ngboolean\r\nfvalue_ne(const fvalue_t *a, const fvalue_t *b)\r\n{\r\ng_assert(a->ftype->cmp_ne);\r\nreturn a->ftype->cmp_ne(a, b);\r\n}\r\ngboolean\r\nfvalue_gt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\ng_assert(a->ftype->cmp_gt);\r\nreturn a->ftype->cmp_gt(a, b);\r\n}\r\ngboolean\r\nfvalue_ge(const fvalue_t *a, const fvalue_t *b)\r\n{\r\ng_assert(a->ftype->cmp_ge);\r\nreturn a->ftype->cmp_ge(a, b);\r\n}\r\ngboolean\r\nfvalue_lt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\ng_assert(a->ftype->cmp_lt);\r\nreturn a->ftype->cmp_lt(a, b);\r\n}\r\ngboolean\r\nfvalue_le(const fvalue_t *a, const fvalue_t *b)\r\n{\r\ng_assert(a->ftype->cmp_le);\r\nreturn a->ftype->cmp_le(a, b);\r\n}\r\ngboolean\r\nfvalue_bitwise_and(const fvalue_t *a, const fvalue_t *b)\r\n{\r\ng_assert(a->ftype->cmp_bitwise_and);\r\nreturn a->ftype->cmp_bitwise_and(a, b);\r\n}\r\ngboolean\r\nfvalue_contains(const fvalue_t *a, const fvalue_t *b)\r\n{\r\ng_assert(a->ftype->cmp_contains);\r\nreturn a->ftype->cmp_contains(a, b);\r\n}\r\ngboolean\r\nfvalue_matches(const fvalue_t *a, const fvalue_t *b)\r\n{\r\ng_assert(a->ftype->cmp_matches);\r\nreturn a->ftype->cmp_matches(a, b);\r\n}
