static double UnquantizeRtt(unsigned char qrtt)\r\n{\r\nreturn ((qrtt <= 31) ? (((double)(qrtt+1))*(double)RTT_MIN) :\r\n(RTT_MAX/exp(((double)(255-qrtt))/(double)13.0)));\r\n}\r\nstatic double UnquantizeGSize(guint8 gsizex)\r\n{\r\nguint mant = (gsizex & 0x8) ? 5 : 1;\r\nguint exponent = gsizex & 0x7;\r\nexponent += 1;\r\nreturn mant * pow(10, exponent);\r\n}\r\nstatic guint dissect_grrtetc(proto_tree *tree, tvbuff_t *tvb, guint offset)\r\n{\r\nguint8 backoff;\r\ndouble gsizex;\r\ndouble grtt;\r\nproto_tree_add_item(tree, hf_instance_id, tvb, offset, 2, ENC_BIG_ENDIAN); offset+=2;\r\ngrtt = UnquantizeRtt(tvb_get_guint8(tvb, offset));\r\nproto_tree_add_double(tree, hf_grtt, tvb, offset, 1, grtt); offset += 1;\r\nbackoff = hi_nibble(tvb_get_guint8(tvb, offset));\r\ngsizex = UnquantizeGSize((guint8)lo_nibble(tvb_get_guint8(tvb, offset)));\r\nproto_tree_add_uint(tree, hf_backoff, tvb, offset, 1, backoff);\r\nproto_tree_add_double(tree, hf_gsize, tvb, offset, 1, gsizex);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic guint dissect_feccode(proto_tree *tree, tvbuff_t *tvb, guint offset,\r\npacket_info *pinfo, gint reserved)\r\n{\r\nnorm_packet_data_t *norm_data;\r\nguint8 encoding_id = tvb_get_guint8(tvb, offset);\r\nnorm_data = wmem_new0(wmem_file_scope(), norm_packet_data_t);\r\nnorm_data->encoding_id = encoding_id;\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_rmt_norm, 0, norm_data);\r\nproto_tree_add_item(tree, hf_fec_encoding_id, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nif (reserved) {\r\nproto_tree_add_item(tree, hf_reserved, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\n}\r\nproto_tree_add_item(tree, hf_object_transport_id, tvb, offset, 2, ENC_BIG_ENDIAN); offset+=2;\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nfec_data_exchange_t fec;\r\ntvbuff_t *new_tvb;\r\nint len;\r\nnew_tvb = tvb_new_subset_remaining(tvb, offset);\r\nfec.encoding_id = encoding_id;\r\nlen = call_dissector_with_data(rmt_fec_handle, new_tvb, pinfo, tree, &fec);\r\nif (len > 0)\r\noffset += len;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint dissect_norm_hdrext(proto_tree *tree, packet_info *pinfo,\r\ntvbuff_t *tvb, guint offset, guint8 hlen)\r\n{\r\nlct_data_exchange_t data_exchange;\r\nnorm_packet_data_t *packet_data = (norm_packet_data_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_rmt_norm, 0);\r\nmemset(&data_exchange, 0, sizeof(data_exchange));\r\nif (packet_data != NULL)\r\ndata_exchange.codepoint = packet_data->encoding_id;\r\noffset += lct_ext_decode(tree, tvb, pinfo, offset, hdrlen2bytes(hlen), &data_exchange,\r\nhf_extension, ett_hdrext);\r\nreturn offset;\r\n}\r\nstatic guint dissect_nack_data(proto_tree *tree, tvbuff_t *tvb, guint offset,\r\npacket_info *pinfo)\r\n{\r\nproto_item *ti, *tif;\r\nproto_tree *nack_tree, *flag_tree;\r\nguint16 len;\r\nnack_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_nackdata, &ti, "NACK Data");\r\nproto_tree_add_item(nack_tree, hf_nack_form, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\ntif = proto_tree_add_item(nack_tree, hf_nack_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflag_tree = proto_item_add_subtree(tif, ett_flags);\r\nproto_tree_add_item(flag_tree, hf_nack_flags_segment, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_nack_flags_block, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_nack_flags_info, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_nack_flags_object, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nlen = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(nack_tree, hf_nack_length, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nproto_item_set_len(ti, 4+len);\r\nif (len > 4) {\r\ndissect_feccode(nack_tree, tvb, offset, pinfo, 1);\r\n}\r\noffset += len;\r\nreturn offset;\r\n}\r\nstatic void dissect_norm_data(proto_tree *tree, packet_info *pinfo,\r\ntvbuff_t *tvb, guint offset, guint8 hlen)\r\n{\r\nguint8 flags;\r\nproto_item *ti;\r\nproto_tree *flag_tree;\r\noffset = dissect_grrtetc(tree, tvb, offset);\r\nti = proto_tree_add_item(tree, hf_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflags = tvb_get_guint8(tvb, offset);\r\nflag_tree = proto_item_add_subtree(ti, ett_flags);\r\nproto_tree_add_item(flag_tree, hf_flag_repair, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_norm_explicit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_info, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_unreliable, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_file, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_stream, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_msgstart, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset = dissect_feccode(tree, tvb, offset, pinfo, 0);\r\nif (offset < hdrlen2bytes(hlen)) {\r\noffset = dissect_norm_hdrext(tree, pinfo, tvb, offset, hlen);\r\n}\r\nif (flags & NORM_FLAG_STREAM) {\r\nflag_tree = proto_tree_add_subtree(tree, tvb, offset, 8, ett_streampayload, NULL, "Stream Data");\r\nproto_tree_add_item(flag_tree, hf_reserved, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nproto_tree_add_item(flag_tree, hf_payload_len, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nproto_tree_add_item(flag_tree, hf_payload_offset, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\nproto_tree_add_item(tree, hf_payload, tvb, offset, -1, ENC_NA);\r\n}\r\nstatic void dissect_norm_info(proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, guint offset, guint8 hlen)\r\n{\r\nproto_item *ti;\r\nproto_tree *flag_tree;\r\nnorm_packet_data_t *norm_data;\r\noffset = dissect_grrtetc(tree, tvb, offset);\r\nti = proto_tree_add_item(tree, hf_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflag_tree = proto_item_add_subtree(ti, ett_flags);\r\nproto_tree_add_item(flag_tree, hf_flag_repair, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_norm_explicit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_info, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_unreliable, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_file, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_stream, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_flag_msgstart, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nnorm_data = wmem_new0(wmem_file_scope(), norm_packet_data_t);\r\nnorm_data->encoding_id = tvb_get_guint8(tvb, offset);\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_rmt_norm, 0, norm_data);\r\nproto_tree_add_item(tree, hf_fec_encoding_id, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nproto_tree_add_item(tree, hf_object_transport_id, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nif (offset < hdrlen2bytes(hlen)) {\r\noffset = dissect_norm_hdrext(tree, pinfo, tvb, offset, hlen);\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\nproto_tree_add_item(tree, hf_payload, tvb, offset, -1, ENC_NA);\r\n}\r\nstatic guint dissect_norm_cmd_flush(proto_tree *tree, packet_info *pinfo,\r\ntvbuff_t *tvb, guint offset, guint8 hlen)\r\n{\r\noffset = dissect_feccode(tree, tvb, offset, pinfo, 0);\r\nif (offset < hdrlen2bytes(hlen)) {\r\noffset = dissect_norm_hdrext(tree, pinfo, tvb, offset, hlen);\r\n}\r\nreturn offset;\r\n}\r\nstatic guint dissect_norm_cmd_repairadv(proto_tree *tree, packet_info *pinfo,\r\ntvbuff_t *tvb, guint offset, guint8 hlen)\r\n{\r\nproto_tree_add_item(tree, hf_flags, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nproto_tree_add_item(tree, hf_reserved, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nif (offset < hdrlen2bytes(hlen)) {\r\noffset = dissect_norm_hdrext(tree, pinfo, tvb, offset, hlen);\r\n}\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\noffset = dissect_nack_data(tree, tvb, offset, pinfo);\r\n}\r\nreturn offset;\r\n}\r\nstatic guint dissect_norm_cmd_cc(proto_tree *tree, packet_info *pinfo,\r\ntvbuff_t *tvb, guint offset, guint8 hlen)\r\n{\r\nproto_tree_add_item(tree, hf_reserved, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nproto_tree_add_item(tree, hf_cc_sequence, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nproto_tree_add_item(tree, hf_cc_sts, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nproto_tree_add_item(tree, hf_cc_stus, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nif (offset < hdrlen2bytes(hlen)) {\r\noffset = dissect_norm_hdrext(tree, pinfo, tvb, offset, hlen);\r\n}\r\nwhile (offset < hdrlen2bytes(hlen)) {\r\nproto_item *tif;\r\nproto_tree *cc_tree, *flag_tree;\r\ndouble grtt;\r\ncc_tree = proto_tree_add_subtree(tree, tvb, offset, 8, ett_congestioncontrol, NULL, "Congestion Control");\r\nproto_tree_add_item(cc_tree, hf_cc_node_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\ntif = proto_tree_add_item(cc_tree, hf_cc_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nflag_tree = proto_item_add_subtree(tif, ett_flags);\r\nproto_tree_add_item(flag_tree, hf_cc_flags_clr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_cc_flags_plr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_cc_flags_rtt, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_cc_flags_start, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flag_tree, hf_cc_flags_leave, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\ngrtt = UnquantizeRtt(tvb_get_guint8(tvb, offset));\r\nproto_tree_add_double(cc_tree, hf_cc_rtt, tvb, offset, 1, grtt); offset += 1;\r\ngrtt = rmt_decode_send_rate(tvb_get_ntohs(tvb, offset));\r\nproto_tree_add_double(cc_tree, hf_cc_rate, tvb, offset, 2, grtt); offset += 2;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint dissect_norm_cmd_squelch(proto_tree *tree, packet_info *pinfo,\r\ntvbuff_t *tvb, guint offset)\r\n{\r\noffset = dissect_feccode(tree, tvb, offset, pinfo, 0);\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_item(tree, hf_cc_transport_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 2;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint dissect_norm_cmd_ackreq(proto_tree *tree, packet_info *pinfo _U_,\r\ntvbuff_t *tvb, guint offset)\r\n{\r\nproto_tree_add_item(tree, hf_reserved, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nproto_tree_add_item(tree, hf_ack_type, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nproto_tree_add_item(tree, hf_ack_id, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nreturn offset;\r\n}\r\nstatic void dissect_norm_cmd(proto_tree *tree, packet_info *pinfo,\r\ntvbuff_t *tvb, guint offset, guint8 hlen)\r\n{\r\nguint8 flavor;\r\noffset = dissect_grrtetc(tree, tvb, offset);\r\nflavor = tvb_get_guint8(tvb, offset);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ",\r\nval_to_str(flavor, string_norm_cmd_type, "Unknown Cmd Type (0x%04x)"));\r\nproto_tree_add_item(tree, hf_cmd_flavor, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nswitch(flavor) {\r\ncase NORM_CMD_CC:\r\noffset = dissect_norm_cmd_cc(tree, pinfo, tvb, offset, hlen);\r\nbreak;\r\ncase NORM_CMD_FLUSH:\r\noffset = dissect_norm_cmd_flush(tree, pinfo, tvb, offset, hlen);\r\nbreak;\r\ncase NORM_CMD_SQUELCH:\r\noffset = dissect_norm_cmd_squelch(tree, pinfo, tvb, offset);\r\nbreak;\r\ncase NORM_CMD_REPAIR_ADV:\r\noffset = dissect_norm_cmd_repairadv(tree, pinfo, tvb, offset, hlen);\r\nbreak;\r\ncase NORM_CMD_ACK_REQ:\r\noffset = dissect_norm_cmd_ackreq(tree, pinfo, tvb, offset);\r\nbreak;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\nproto_tree_add_item(tree, hf_payload, tvb, offset, -1, ENC_NA);\r\n}\r\nstatic void dissect_norm_ack(proto_tree *tree, packet_info *pinfo,\r\ntvbuff_t *tvb, guint offset, guint8 hlen)\r\n{\r\nguint8 acktype;\r\nproto_tree_add_item(tree, hf_ack_source, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nproto_tree_add_item(tree, hf_instance_id, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nacktype = tvb_get_guint8(tvb, offset);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ",\r\nval_to_str(acktype, string_norm_ack_type, "Unknown Ack Type (0x%04x)"));\r\nproto_tree_add_item(tree, hf_ack_type, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nproto_tree_add_item(tree, hf_ack_id, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1;\r\nproto_tree_add_item(tree, hf_ack_grtt_sec, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nproto_tree_add_item(tree, hf_ack_grtt_usec, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nif (offset < hdrlen2bytes(hlen)) {\r\noffset = dissect_norm_hdrext(tree, pinfo, tvb, offset, hlen);\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\nproto_tree_add_item(tree, hf_payload, tvb, offset, -1, ENC_NA);\r\n}\r\nstatic void dissect_norm_nack(proto_tree *tree, packet_info *pinfo,\r\ntvbuff_t *tvb, guint offset, guint8 hlen)\r\n{\r\nproto_tree_add_item(tree, hf_nack_server, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nproto_tree_add_item(tree, hf_instance_id, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nproto_tree_add_item(tree, hf_reserved, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2;\r\nproto_tree_add_item(tree, hf_nack_grtt_sec, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nproto_tree_add_item(tree, hf_nack_grtt_usec, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4;\r\nif (offset < hdrlen2bytes(hlen)) {\r\noffset = dissect_norm_hdrext(tree, pinfo, tvb, offset, hlen);\r\n}\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\noffset = dissect_nack_data(tree, tvb, offset, pinfo);\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\nproto_tree_add_item(tree, hf_payload, tvb, offset, -1, ENC_NA);\r\n}\r\nstatic int\r\ndissect_norm(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint8 version;\r\nguint8 type;\r\nguint8 hlen;\r\nguint offset = 0;\r\nproto_item *ti;\r\nproto_tree *norm_tree;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NORM");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nversion = hi_nibble(tvb_get_guint8(tvb, offset));\r\nti = proto_tree_add_item(tree, proto_rmt_norm, tvb, offset, -1, ENC_NA);\r\nnorm_tree = proto_item_add_subtree(ti, ett_main);\r\nproto_tree_add_uint(norm_tree, hf_version, tvb, offset, 1, version);\r\nif (version != 1) {\r\nexpert_add_info(pinfo, ti, &ei_version1_only);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Version: %u (not supported)", version);\r\nreturn 0;\r\n}\r\ntype = lo_nibble(tvb_get_guint8(tvb, offset));\r\nhlen = tvb_get_guint8(tvb, offset+1);\r\nif (tree) {\r\nproto_tree_add_uint(norm_tree, hf_type, tvb, offset, 1, type);\r\nproto_tree_add_item(norm_tree, hf_hlen, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(norm_tree, hf_sequence, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(norm_tree, hf_source_id, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\n}\r\noffset += 8;\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ",\r\nval_to_str(type, string_norm_type, "Unknown Type (0x%04x)"));\r\nswitch(type) {\r\ncase NORM_INFO:\r\ndissect_norm_info(norm_tree, pinfo, tvb, offset, hlen);\r\nbreak;\r\ncase NORM_DATA:\r\ndissect_norm_data(norm_tree, pinfo, tvb, offset, hlen);\r\nbreak;\r\ncase NORM_CMD:\r\ndissect_norm_cmd(norm_tree, pinfo, tvb, offset, hlen);\r\nbreak;\r\ncase NORM_ACK:\r\ndissect_norm_ack(norm_tree, pinfo, tvb, offset, hlen);\r\nbreak;\r\ncase NORM_NACK:\r\ndissect_norm_nack(norm_tree, pinfo, tvb, offset, hlen);\r\nbreak;\r\ndefault:\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\nproto_tree_add_item(norm_tree, hf_payload, tvb, offset, -1, ENC_NA);\r\nbreak;\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_norm_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nguint8 byte1;\r\nif (tvb_reported_length(tvb) < 12)\r\nreturn FALSE;\r\nbyte1 = tvb_get_guint8(tvb, 0);\r\nif (hi_nibble(byte1) != 1) return FALSE;\r\nif (lo_nibble(byte1) < 1 || lo_nibble(byte1) > 6) return FALSE;\r\nif (tvb_get_guint8(tvb, 1) > 20) return FALSE;\r\ndissect_norm(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nvoid proto_register_norm(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_version,\r\n{ "Version", "norm.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_type,\r\n{ "Message Type", "norm.type",\r\nFT_UINT8, BASE_DEC, VALS(string_norm_type), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_hlen,\r\n{ "Header length", "norm.hlen",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sequence,\r\n{ "Sequence", "norm.sequence",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_source_id,\r\n{ "Source ID", "norm.source_id",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_instance_id,\r\n{ "Instance", "norm.instance_id",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_grtt,\r\n{ "grtt", "norm.grtt",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_backoff,\r\n{ "Backoff", "norm.backoff",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsize,\r\n{ "Group Size", "norm.gsize",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_flags,\r\n{ "Flags", "norm.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_flag_repair,\r\n{ "Repair Flag", "norm.flag.repair",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_REPAIR,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flag_norm_explicit,\r\n{ "Explicit Flag", "norm.flag.explicit",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_EXPLICIT,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flag_info,\r\n{ "Info Flag", "norm.flag.info",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_INFO,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flag_unreliable,\r\n{ "Unreliable Flag", "norm.flag.unreliable",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_UNRELIABLE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flag_file,\r\n{ "File Flag", "norm.flag.file",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_FILE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flag_stream,\r\n{ "Stream Flag", "norm.flag.stream",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_STREAM,\r\nNULL, HFILL }\r\n},\r\n{ &hf_flag_msgstart,\r\n{ "Msg Start Flag", "norm.flag.msgstart",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_MSG_START,\r\nNULL, HFILL }\r\n},\r\n{ &hf_object_transport_id,\r\n{ "Object Transport ID", "norm.object_transport_id",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_extension,\r\n{ "Hdr Extension", "norm.hexext",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_reserved,\r\n{ "Reserved", "norm.reserved",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_payload_len,\r\n{ "Payload Len", "norm.payload.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_payload_offset,\r\n{ "Payload Offset", "norm.payload.offset",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cmd_flavor,\r\n{ "Flavor", "norm.flavor",\r\nFT_UINT8, BASE_DEC, VALS(string_norm_cmd_type), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_sequence,\r\n{ "CC Sequence", "norm.ccsequence",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_sts,\r\n{ "Send Time secs", "norm.cc_sts",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_stus,\r\n{ "Send Time usecs", "norm.cc_stus",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_node_id,\r\n{ "CC Node ID", "norm.cc_node_id",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_flags,\r\n{ "CC Flags", "norm.cc_flags",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_flags_clr,\r\n{ "CLR", "norm.cc_flags.clr",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_CC_CLR,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_flags_plr,\r\n{ "PLR", "norm.cc_flags.plr",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_CC_PLR,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_flags_rtt,\r\n{ "RTT", "norm.cc_flags.rtt",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_CC_RTT,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_flags_start,\r\n{ "Start", "norm.cc_flags.start",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_CC_START,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_flags_leave,\r\n{ "Leave", "norm.cc_flags.leave",\r\nFT_BOOLEAN, 8, NULL, NORM_FLAG_CC_LEAVE,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_rtt,\r\n{ "CC RTT", "norm.cc_rtt",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_rate,\r\n{ "CC Rate", "norm.cc_rate",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cc_transport_id,\r\n{ "CC Transport ID", "norm.cc_transport_id",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ack_source,\r\n{ "Ack Source", "norm.ack.source",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ack_type,\r\n{ "Ack Type", "norm.ack.type",\r\nFT_UINT8, BASE_DEC, VALS(string_norm_ack_type), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ack_id,\r\n{ "Ack ID", "norm.ack.id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ack_grtt_sec,\r\n{ "Ack GRTT Sec", "norm.ack.grtt_sec",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ack_grtt_usec,\r\n{ "Ack GRTT usec", "norm.ack.grtt_usec",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_server,\r\n{ "NAck Server", "norm.nack.server",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_grtt_sec,\r\n{ "NAck GRTT Sec", "norm.nack.grtt_sec",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_grtt_usec,\r\n{ "NAck GRTT usec", "norm.nack.grtt_usec",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_form,\r\n{ "NAck FORM", "norm.nack.form",\r\nFT_UINT8, BASE_DEC, VALS(string_norm_nack_form), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_flags,\r\n{ "NAck Flags", "norm.nack.flags",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_flags_segment,\r\n{ "Segment", "norm.nack.flags.segment",\r\nFT_BOOLEAN, 8, NULL, NORM_NACK_SEGMENT,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_flags_block,\r\n{ "Block", "norm.nack.flags.block",\r\nFT_BOOLEAN, 8, NULL, NORM_NACK_BLOCK,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_flags_info,\r\n{ "Info", "norm.nack.flags.info",\r\nFT_BOOLEAN, 8, NULL, NORM_NACK_INFO,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_flags_object,\r\n{ "Object", "norm.nack.flags.object",\r\nFT_BOOLEAN, 8, NULL, NORM_NACK_OBJECT,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nack_length,\r\n{ "NAck Length", "norm.nack.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_payload,\r\n{ "Payload", "norm.payload",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_fec_encoding_id,\r\n{ "FEC Encoding ID", "norm.fec_encoding_id",\r\nFT_UINT8, BASE_DEC, VALS(string_fec_encoding_id), 0x0,\r\nNULL, HFILL}\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_main,\r\n&ett_hdrext,\r\n&ett_flags,\r\n&ett_streampayload,\r\n&ett_congestioncontrol,\r\n&ett_nackdata\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_version1_only, { "norm.version1_only", PI_PROTOCOL, PI_WARN, "Sorry, this dissector supports NORM version 1 only", EXPFILL }}\r\n};\r\nmodule_t *module;\r\nexpert_module_t* expert_rmt_norm;\r\nproto_rmt_norm = proto_register_protocol("Negative-acknowledgment Oriented Reliable Multicast", "NORM", "norm");\r\nproto_register_field_array(proto_rmt_norm, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_rmt_norm = expert_register_protocol(proto_rmt_norm);\r\nexpert_register_field_array(expert_rmt_norm, ei, array_length(ei));\r\nmodule = prefs_register_protocol(proto_rmt_norm, NULL);\r\nprefs_register_obsolete_preference(module, "heuristic_norm");\r\n}\r\nvoid proto_reg_handoff_norm(void)\r\n{\r\nstatic dissector_handle_t handle;\r\nhandle = create_dissector_handle(dissect_norm, proto_rmt_norm);\r\ndissector_add_for_decode_as("udp.port", handle);\r\nheur_dissector_add("udp", dissect_norm_heur, "NORM over UDP", "rmt_norm_udp", proto_rmt_norm, HEURISTIC_DISABLE);\r\nrmt_fec_handle = find_dissector_add_dependency("rmt-fec", proto_rmt_norm);\r\n}
