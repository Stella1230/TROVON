static void\r\nprint_range(const void *value)\r\n{\r\nwmem_range_t *range = (wmem_range_t *)value;\r\nif(!value) {\r\nreturn;\r\n}\r\nprintf("Range: low=%" G_GUINT64_FORMAT " high=%" G_GUINT64_FORMAT " max_edge=%" G_GUINT64_FORMAT "\n", range->low, range->high, range->max_edge);\r\n}\r\nstatic void\r\nupdate_max_edge(wmem_tree_node_t *node)\r\n{\r\nwmem_range_t *range;\r\nwmem_range_t *range_l;\r\nwmem_range_t *range_r;\r\nguint64 maxEdge = 0;\r\nif(!node) {\r\nreturn ;\r\n}\r\nrange = (wmem_range_t *)node->key;\r\nrange_l = (node->left) ? (wmem_range_t *) (node->left->key) : NULL;\r\nrange_r = (node->right) ? (wmem_range_t *) (node->right->key) : NULL;\r\nmaxEdge = range->max_edge;\r\nif(range_r) {\r\nmaxEdge = MAX(maxEdge, range_r->max_edge) ;\r\n}\r\nif(range_l) {\r\nmaxEdge = MAX(maxEdge, range_l->max_edge) ;\r\n}\r\nif(range->max_edge != maxEdge) {\r\nrange->max_edge = maxEdge;\r\nupdate_max_edge(node->parent);\r\n}\r\n}\r\ngboolean\r\nwmem_itree_range_overlap(const wmem_range_t *r1, const wmem_range_t *r2)\r\n{\r\nreturn (r1->low <= r2->high && r2->low <= r1->high);\r\n}\r\nwmem_itree_t *\r\nwmem_itree_new(wmem_allocator_t *allocator)\r\n{\r\nwmem_itree_t *tree = wmem_tree_new(allocator);\r\ntree->post_rotation_cb = &update_max_edge;\r\nreturn tree;\r\n}\r\ngboolean\r\nwmem_itree_is_empty(wmem_itree_t *tree)\r\n{\r\nreturn wmem_tree_is_empty(tree);\r\n}\r\nstatic int\r\nwmem_tree_compare_ranges(const wmem_range_t *ra, const wmem_range_t *rb)\r\n{\r\nif( ra->low == rb->low) {\r\nreturn 0;\r\n}\r\nelse if(ra->low < rb->low) {\r\nreturn -1;\r\n}\r\nelse {\r\nreturn 1;\r\n}\r\n}\r\nvoid\r\nwmem_itree_insert(wmem_itree_t *tree, const guint64 low, const guint64 high, void *data)\r\n{\r\nwmem_tree_node_t *node;\r\nwmem_range_t *range = (wmem_range_t *)wmem_new(tree->allocator, wmem_range_t);\r\ng_assert(low <= high);\r\nrange->low = low;\r\nrange->high = high;\r\nrange->max_edge = high;\r\nnode = wmem_tree_insert(tree, range, data, (compare_func)wmem_tree_compare_ranges);\r\nupdate_max_edge(node);\r\n}\r\nstatic void\r\nwmem_itree_find_intervals_in_subtree(wmem_tree_node_t *node, wmem_range_t requested, wmem_list_t *results)\r\n{\r\nconst wmem_range_t* current;\r\nif(!node) {\r\nreturn;\r\n}\r\ncurrent = (wmem_range_t*)node->key;\r\nif(requested.low > current->max_edge) {\r\nreturn;\r\n}\r\nif(wmem_itree_range_overlap(current, &requested)) {\r\nwmem_list_prepend(results, node->data);\r\n}\r\nwmem_itree_find_intervals_in_subtree(node->left, requested, results);\r\nwmem_itree_find_intervals_in_subtree(node->right, requested, results);\r\n}\r\nwmem_list_t *\r\nwmem_itree_find_intervals(wmem_itree_t *tree, wmem_allocator_t *allocator, guint64 low, guint64 high)\r\n{\r\nwmem_list_t *results = NULL;\r\nwmem_range_t requested = { low, high, 0 };\r\nresults = wmem_list_new(allocator);\r\nwmem_itree_find_intervals_in_subtree(tree->root, requested, results);\r\nreturn results;\r\n}\r\nvoid\r\nwmem_print_itree(wmem_tree_t *tree)\r\n{\r\nwmem_print_tree(tree, &print_range, NULL);\r\n}
