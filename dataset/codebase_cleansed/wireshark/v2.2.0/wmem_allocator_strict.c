static inline void\r\nwmem_strict_block_check_canaries(wmem_strict_allocator_block_t *block)\r\n{\r\nguint i;\r\nguint8 *canary;\r\ncanary = WMEM_BLOCK_TO_PRE_CANARY(block);\r\nfor (i=0; i<WMEM_CANARY_SIZE; i++) g_assert(canary[i] == WMEM_CANARY_VALUE);\r\ncanary = WMEM_BLOCK_TO_POST_CANARY(block);\r\nfor (i=0; i<WMEM_CANARY_SIZE; i++) g_assert(canary[i] == WMEM_CANARY_VALUE);\r\n}\r\nstatic void *\r\nwmem_strict_alloc(void *private_data, const size_t size)\r\n{\r\nwmem_strict_allocator_t *allocator;\r\nwmem_strict_allocator_block_t *block;\r\nguint i;\r\nguint8 *canary;\r\nallocator = (wmem_strict_allocator_t*) private_data;\r\nblock = (wmem_strict_allocator_block_t *)wmem_alloc(NULL, WMEM_FULL_SIZE(size));\r\nblock->data_len = size;\r\nmemset(WMEM_BLOCK_TO_DATA(block), WMEM_PREFILL, block->data_len);\r\ncanary = WMEM_BLOCK_TO_PRE_CANARY(block);\r\nfor (i=0; i<WMEM_CANARY_SIZE; i++) canary[i] = WMEM_CANARY_VALUE;\r\ncanary = WMEM_BLOCK_TO_POST_CANARY(block);\r\nfor (i=0; i<WMEM_CANARY_SIZE; i++) canary[i] = WMEM_CANARY_VALUE;\r\nif (allocator->blocks) {\r\nallocator->blocks->prev = block;\r\n}\r\nblock->next = allocator->blocks;\r\nblock->prev = NULL;\r\nallocator->blocks = block;\r\nreturn WMEM_BLOCK_TO_DATA(block);\r\n}\r\nstatic void\r\nwmem_strict_free(void *private_data, void *ptr)\r\n{\r\nwmem_strict_allocator_t *allocator;\r\nwmem_strict_allocator_block_t *block;\r\nallocator = (wmem_strict_allocator_t*) private_data;\r\nblock = WMEM_DATA_TO_BLOCK(ptr);\r\nwmem_strict_block_check_canaries(block);\r\nif (block->next) {\r\nblock->next->prev = block->prev;\r\n}\r\nif (block->prev) {\r\nblock->prev->next = block->next;\r\n}\r\nelse {\r\nallocator->blocks = block->next;\r\n}\r\nmemset(block, WMEM_POSTFILL, WMEM_FULL_SIZE(block->data_len));\r\nwmem_free(NULL, block);\r\n}\r\nstatic void *\r\nwmem_strict_realloc(void *private_data, void *ptr, const size_t size)\r\n{\r\nwmem_strict_allocator_block_t *block;\r\nvoid *new_ptr;\r\nblock = WMEM_DATA_TO_BLOCK(ptr);\r\nnew_ptr = wmem_strict_alloc(private_data, size);\r\nif (block->data_len > size) {\r\nmemcpy(new_ptr, ptr, size);\r\n}\r\nelse {\r\nmemcpy(new_ptr, ptr, block->data_len);\r\n}\r\nwmem_strict_free(private_data, ptr);\r\nreturn new_ptr;\r\n}\r\nvoid\r\nwmem_strict_check_canaries(wmem_allocator_t *allocator)\r\n{\r\nwmem_strict_allocator_t *private_allocator;\r\nwmem_strict_allocator_block_t *block;\r\nif (allocator->type != WMEM_ALLOCATOR_STRICT) {\r\nreturn;\r\n}\r\nprivate_allocator = (wmem_strict_allocator_t*) allocator->private_data;\r\nblock = private_allocator->blocks;\r\nwhile (block) {\r\nwmem_strict_block_check_canaries(block);\r\nblock = block->next;\r\n}\r\n}\r\nstatic void\r\nwmem_strict_free_all(void *private_data)\r\n{\r\nwmem_strict_allocator_t *allocator;\r\nallocator = (wmem_strict_allocator_t*) private_data;\r\nwhile (allocator->blocks) {\r\nwmem_strict_free(private_data, WMEM_BLOCK_TO_DATA(allocator->blocks));\r\n}\r\n}\r\nstatic void\r\nwmem_strict_gc(void *private_data _U_)\r\n{\r\n}\r\nstatic void\r\nwmem_strict_allocator_cleanup(void *private_data)\r\n{\r\nwmem_free(NULL, private_data);\r\n}\r\nvoid\r\nwmem_strict_allocator_init(wmem_allocator_t *allocator)\r\n{\r\nwmem_strict_allocator_t *strict_allocator;\r\nstrict_allocator = wmem_new(NULL, wmem_strict_allocator_t);\r\nallocator->walloc = &wmem_strict_alloc;\r\nallocator->wrealloc = &wmem_strict_realloc;\r\nallocator->wfree = &wmem_strict_free;\r\nallocator->free_all = &wmem_strict_free_all;\r\nallocator->gc = &wmem_strict_gc;\r\nallocator->cleanup = &wmem_strict_allocator_cleanup;\r\nallocator->private_data = (void*) strict_allocator;\r\nstrict_allocator->blocks = NULL;\r\n}
