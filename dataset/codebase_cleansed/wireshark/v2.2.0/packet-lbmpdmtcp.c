static void lbmtcp_order_key(lbmtcp_transport_t * transport)\r\n{\r\ngboolean swap = FALSE;\r\nint compare;\r\ncompare = cmp_address(&(transport->addr1), &(transport->addr2));\r\nif (compare > 0)\r\n{\r\nswap = TRUE;\r\n}\r\nelse if (compare == 0)\r\n{\r\nif (transport->port1 > transport->port2)\r\n{\r\nswap = TRUE;\r\n}\r\n}\r\nif (swap)\r\n{\r\naddress addr;\r\nguint16 port;\r\ncopy_address_shallow(&addr, &(transport->addr1));\r\ncopy_address_shallow(&(transport->addr2), &(transport->addr1));\r\ncopy_address_shallow(&(transport->addr1), &addr);\r\nport = transport->port2;\r\ntransport->port2 = transport->port1;\r\ntransport->port1 = port;\r\n}\r\n}\r\nstatic lbmtcp_transport_t * lbmtcp_transport_add(const address * address1, guint16 port1, const address * address2, guint16 port2, guint32 frame)\r\n{\r\nlbmtcp_transport_t * entry;\r\nconversation_t * conv = NULL;\r\nconv = find_conversation(frame, address1, address2, PT_TCP, port1, port2, 0);\r\nif (conv == NULL)\r\n{\r\nconv = conversation_new(frame, address1, address2, PT_TCP, port1, port2, 0);\r\n}\r\nentry = (lbmtcp_transport_t *) conversation_get_proto_data(conv, lbmpdm_tcp_protocol_handle);\r\nif (entry != NULL)\r\n{\r\nreturn (entry);\r\n}\r\nentry = wmem_new(wmem_file_scope(), lbmtcp_transport_t);\r\ncopy_address_wmem(wmem_file_scope(), &(entry->addr1), address1);\r\nentry->port1 = port1;\r\ncopy_address_wmem(wmem_file_scope(), &(entry->addr2), address2);\r\nentry->port2 = port2;\r\nlbmtcp_order_key(entry);\r\nentry->channel = lbm_channel_assign(LBM_CHANNEL_TCP);\r\nconversation_add_proto_data(conv, lbmpdm_tcp_protocol_handle, (void *) entry);\r\nreturn (entry);\r\n}\r\nstatic gboolean lbmpdm_tcp_tag_update_cb(void * record, char * * error_string)\r\n{\r\nlbmpdm_tcp_tag_entry_t * tag = (lbmpdm_tcp_tag_entry_t *)record;\r\nif (tag->name == NULL)\r\n{\r\n*error_string = g_strdup("Tag name can't be empty");\r\nreturn FALSE;\r\n}\r\nelse\r\n{\r\ng_strstrip(tag->name);\r\nif (tag->name[0] == 0)\r\n{\r\n*error_string = g_strdup("Tag name can't be empty");\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void * lbmpdm_tcp_tag_copy_cb(void * destination, const void * source, size_t length _U_)\r\n{\r\nconst lbmpdm_tcp_tag_entry_t * src = (const lbmpdm_tcp_tag_entry_t *)source;\r\nlbmpdm_tcp_tag_entry_t * dest = (lbmpdm_tcp_tag_entry_t *)destination;\r\ndest->name = g_strdup(src->name);\r\ndest->port_low = src->port_low;\r\ndest->port_high = src->port_high;\r\nreturn (dest);\r\n}\r\nstatic void lbmpdm_tcp_tag_free_cb(void * record)\r\n{\r\nlbmpdm_tcp_tag_entry_t * tag = (lbmpdm_tcp_tag_entry_t *)record;\r\nif (tag->name != NULL)\r\n{\r\ng_free(tag->name);\r\ntag->name = NULL;\r\n}\r\n}\r\nstatic const lbmpdm_tcp_tag_entry_t * lbmpdm_tcp_tag_locate(packet_info * pinfo)\r\n{\r\nguint idx;\r\nconst lbmpdm_tcp_tag_entry_t * tag = NULL;\r\nif (!lbmpdm_tcp_use_tag)\r\n{\r\nreturn (NULL);\r\n}\r\nfor (idx = 0; idx < lbmpdm_tcp_tag_count; ++idx)\r\n{\r\ntag = &(lbmpdm_tcp_tag_entry[idx]);\r\nif (((pinfo->srcport >= tag->port_low) && (pinfo->srcport <= tag->port_high))\r\n|| ((pinfo->destport >= tag->port_low) && (pinfo->destport <= tag->port_high)))\r\n{\r\nreturn (tag);\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nstatic char * lbmpdm_tcp_tag_find(packet_info * pinfo)\r\n{\r\nconst lbmpdm_tcp_tag_entry_t * tag = NULL;\r\nif (!lbmpdm_tcp_use_tag)\r\n{\r\nreturn (NULL);\r\n}\r\ntag = lbmpdm_tcp_tag_locate(pinfo);\r\nif (tag != NULL)\r\n{\r\nreturn tag->name;\r\n}\r\nreturn (NULL);\r\n}\r\nstatic guint get_lbmpdm_tcp_pdu_length(packet_info * pinfo _U_, tvbuff_t * tvb,\r\nint offset, void *data _U_)\r\n{\r\nint encoding;\r\nint packet_len = 0;\r\npacket_len = 0;\r\nif (!lbmpdm_verify_payload(tvb, offset, &encoding, &packet_len))\r\n{\r\npacket_len = 0;\r\n}\r\nreturn (packet_len);\r\n}\r\nstatic int dissect_lbmpdm_tcp_pdu(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * dissector_data _U_)\r\n{\r\nproto_tree * lbmpdm_tcp_tree = NULL;\r\nproto_item * ti = NULL;\r\nlbmtcp_transport_t * transport = NULL;\r\nchar * tag_name = NULL;\r\nguint64 channel = LBM_CHANNEL_NO_CHANNEL;\r\nif (lbmpdm_tcp_use_tag)\r\n{\r\ntag_name = lbmpdm_tcp_tag_find(pinfo);\r\n}\r\nif (tag_name != NULL)\r\n{\r\nti = proto_tree_add_protocol_format(tree, lbmpdm_tcp_protocol_handle, tvb, 0, -1, "LBMPDM-TCP Protocol (Tag: %s)", tag_name);\r\n}\r\nelse\r\n{\r\nti = proto_tree_add_protocol_format(tree, lbmpdm_tcp_protocol_handle, tvb, 0, -1, "LBMPDM-TCP Protocol");\r\n}\r\nlbmpdm_tcp_tree = proto_item_add_subtree(ti, ett_lbmpdm_tcp);\r\ntransport = lbmtcp_transport_add(&(pinfo->src), pinfo->srcport, &(pinfo->dst), pinfo->destport, pinfo->num);\r\nif (transport != NULL)\r\n{\r\nchannel = transport->channel;\r\n}\r\nif (tag_name != NULL)\r\n{\r\nproto_item * item = NULL;\r\nitem = proto_tree_add_string(lbmpdm_tcp_tree, hf_lbmpdm_tcp_tag, tvb, 0, 0, tag_name);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif (channel != LBM_CHANNEL_NO_CHANNEL)\r\n{\r\nproto_item * item = NULL;\r\nitem = proto_tree_add_uint64(lbmpdm_tcp_tree, hf_lbmpdm_tcp_channel, tvb, 0, 0, channel);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nreturn (lbmpdm_dissect_lbmpdm_payload(tvb, 0, pinfo, tree, channel));\r\n}\r\nstatic int dissect_lbmpdm_tcp(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)\r\n{\r\nchar * tag_name = NULL;\r\ncol_add_str(pinfo->cinfo, COL_PROTOCOL, "LBMPDM-TCP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (lbmpdm_tcp_use_tag)\r\n{\r\ntag_name = lbmpdm_tcp_tag_find(pinfo);\r\n}\r\nif (tag_name != NULL)\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "[Tag: %s]", tag_name);\r\n}\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, lbmpdm_get_minimum_length(),\r\nget_lbmpdm_tcp_pdu_length, dissect_lbmpdm_tcp_pdu, NULL);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean test_lbmpdm_tcp_packet(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * user_data _U_)\r\n{\r\nint encoding = 0;\r\nint packet_len = 0;\r\nif (pinfo->ptype != PT_TCP)\r\n{\r\nreturn (FALSE);\r\n}\r\nif ((pinfo->dst.type != AT_IPv4) || (pinfo->dst.len != 4))\r\n{\r\nreturn (FALSE);\r\n}\r\nif (!lbmpdm_verify_payload(tvb, 0, &encoding, &packet_len))\r\n{\r\nreturn (FALSE);\r\n}\r\nif (lbmpdm_tcp_use_tag)\r\n{\r\nif (lbmpdm_tcp_tag_find(pinfo) != NULL)\r\n{\r\ndissect_lbmpdm_tcp(tvb, pinfo, tree, user_data);\r\nreturn (TRUE);\r\n}\r\nelse\r\n{\r\nreturn (FALSE);\r\n}\r\n}\r\nif (!(((pinfo->srcport >= lbmpdm_tcp_port_low) && (pinfo->srcport <= lbmpdm_tcp_port_high))\r\n|| ((pinfo->destport >= lbmpdm_tcp_port_low) && (pinfo->destport <= lbmpdm_tcp_port_high))))\r\n{\r\nreturn (FALSE);\r\n}\r\ndissect_lbmpdm_tcp(tvb, pinfo, tree, user_data);\r\nreturn (TRUE);\r\n}\r\nvoid proto_register_lbmpdm_tcp(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n{ &hf_lbmpdm_tcp_tag,\r\n{ "Tag", "lbmpdm_tcp.tag", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_lbmpdm_tcp_channel,\r\n{ "Channel ID", "lbmpdm_tcp.channel", FT_UINT64, BASE_HEX_DEC, NULL, 0x0, NULL, HFILL } },\r\n};\r\nstatic gint * ett[] =\r\n{\r\n&ett_lbmpdm_tcp,\r\n};\r\nmodule_t * lbmpdm_tcp_module;\r\nuat_t * tag_uat;\r\nlbmpdm_tcp_protocol_handle = proto_register_protocol("LBMPDM over TCP Protocol", "LBMPDM-TCP", "lbmpdm_tcp");\r\nproto_register_field_array(lbmpdm_tcp_protocol_handle, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nlbmpdm_tcp_module = prefs_register_protocol_subtree("29West", lbmpdm_tcp_protocol_handle, proto_reg_handoff_lbmpdm_tcp);\r\nprefs_register_uint_preference(lbmpdm_tcp_module,\r\n"port_low",\r\n"Port range low (default " MAKESTRING(LBMPDM_TCP_DEFAULT_PORT_LOW)")",\r\n"Set the low end of the TCP port range",\r\n10,\r\n&global_lbmpdm_tcp_port_low);\r\nprefs_register_uint_preference(lbmpdm_tcp_module,\r\n"port_high",\r\n"Port range high (default " MAKESTRING(LBMPDM_TCP_DEFAULT_PORT_HIGH)")",\r\n"Set the high end of the port range",\r\n10,\r\n&global_lbmpdm_tcp_port_high);\r\nprefs_register_bool_preference(lbmpdm_tcp_module,\r\n"use_lbmpdm_tcp_domain",\r\n"Use LBMPDM-TCP tag table",\r\n"Use table of LBMPDM-TCP tags to decode the packet instead of above values",\r\n&global_lbmpdm_tcp_use_tag);\r\ntag_uat = uat_new("LBMPDM-TCP tag definitions",\r\nsizeof(lbmpdm_tcp_tag_entry_t),\r\n"lbmpdm_tcp_domains",\r\nTRUE,\r\n(void * *)&lbmpdm_tcp_tag_entry,\r\n&lbmpdm_tcp_tag_count,\r\nUAT_AFFECTS_DISSECTION,\r\nNULL,\r\nlbmpdm_tcp_tag_copy_cb,\r\nlbmpdm_tcp_tag_update_cb,\r\nlbmpdm_tcp_tag_free_cb,\r\nNULL,\r\nlbmpdm_tcp_tag_array);\r\nprefs_register_uat_preference(lbmpdm_tcp_module,\r\n"tnw_lbmpdm_tcp_tags",\r\n"LBMPDM-TCP Tags",\r\n"A table to define LBMPDM-TCP tags",\r\ntag_uat);\r\n}\r\nvoid proto_reg_handoff_lbmpdm_tcp(void)\r\n{\r\nstatic gboolean already_registered = FALSE;\r\nif (!already_registered)\r\n{\r\nlbmpdm_tcp_dissector_handle = create_dissector_handle(dissect_lbmpdm_tcp, lbmpdm_tcp_protocol_handle);\r\ndissector_add_for_decode_as("tcp.port", lbmpdm_tcp_dissector_handle);\r\nheur_dissector_add("tcp", test_lbmpdm_tcp_packet, "LBMPDM over TCP", "lbmpdm_tcp", lbmpdm_tcp_protocol_handle, HEURISTIC_ENABLE);\r\n}\r\nif (global_lbmpdm_tcp_port_low <= global_lbmpdm_tcp_port_high)\r\n{\r\nlbmpdm_tcp_port_low = global_lbmpdm_tcp_port_low;\r\nlbmpdm_tcp_port_high = global_lbmpdm_tcp_port_high;\r\n}\r\nlbmpdm_tcp_use_tag = global_lbmpdm_tcp_use_tag;\r\nalready_registered = TRUE;\r\n}
