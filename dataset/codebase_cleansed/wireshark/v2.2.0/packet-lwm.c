static gboolean\r\ndissect_lwm_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nif(tvb_get_guint8(tvb, 0) & LWM_FCF_RESERVED)\r\nreturn (FALSE);\r\nif (tvb_reported_length(tvb) < LWM_HEADER_BASE_LEN)\r\nreturn (FALSE);\r\ndissect_lwm(tvb, pinfo, tree, data);\r\nreturn (TRUE);\r\n}\r\nstatic int dissect_lwm(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint lwm_header_len;\r\nguint8 lwm_fcf;\r\ngboolean lwm_fcf_security;\r\ngboolean lwm_fcf_multicast;\r\nguint8 lwm_seq;\r\nguint16 lwm_src_addr;\r\nguint16 lwm_dst_addr;\r\nguint8 lwm_endp_field;\r\nguint8 lwm_src_endp;\r\nguint8 lwm_dst_endp;\r\nproto_tree *lwm_tree = NULL;\r\nproto_item *ti_proto = NULL;\r\nproto_item *ti;\r\ntvbuff_t *new_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "LwMesh");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nlwm_header_len = LWM_HEADER_BASE_LEN;\r\nif(tree){\r\nti_proto = proto_tree_add_protocol_format(tree, proto_lwm, tvb, 0, -1, "Lightweight Mesh");\r\nlwm_tree = proto_item_add_subtree(ti_proto, ett_lwm);\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Lightweight Mesh");\r\nlwm_fcf = tvb_get_guint8(tvb, 0);\r\nlwm_fcf_security = (lwm_fcf & LWM_FCF_SEC_EN);\r\nlwm_fcf_multicast = (lwm_fcf & LWM_FCF_MULTICAST);\r\nif(tree){\r\nproto_tree *field_tree;\r\nti = proto_tree_add_uint(lwm_tree, hf_lwm_fcf, tvb, 0, 1, lwm_fcf);\r\nfield_tree = proto_item_add_subtree(ti, ett_lwm_fcf);\r\nproto_tree_add_item(field_tree, hf_lwm_fcf_ack_req, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(field_tree, hf_lwm_fcf_security, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(field_tree, hf_lwm_fcf_linklocal, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(field_tree, hf_lwm_fcf_multicast, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(field_tree, hf_lwm_fcf_reserved, tvb, 0, 1, ENC_NA);\r\n}\r\nlwm_seq = tvb_get_guint8(tvb, 1);\r\nproto_item_append_text(ti_proto, ", Sequence Number: %i", lwm_seq);\r\nproto_tree_add_uint(lwm_tree, hf_lwm_seq, tvb, 1, 1, lwm_seq);\r\nlwm_src_addr = tvb_get_letohs(tvb, 2);\r\nti = proto_tree_add_uint(lwm_tree, hf_lwm_src_addr, tvb, 2, 2, lwm_src_addr);\r\nif(lwm_src_addr < 0x8000){\r\nproto_item_append_text(ti, " (Routing node)");\r\n}else{\r\nproto_item_append_text(ti, " (Non-routing node)");\r\n}\r\nif(lwm_src_addr == LWM_BCAST_ADDR){\r\nexpert_add_info(pinfo, lwm_tree, &ei_lwm_n_src_broad);\r\n}\r\nlwm_dst_addr = tvb_get_letohs(tvb, 4);\r\nif(lwm_dst_addr == LWM_BCAST_ADDR){\r\nproto_tree_add_uint_format_value(lwm_tree, hf_lwm_dst_addr, tvb, 4, 2, lwm_dst_addr,\r\n"Broadcast (0x%04x)", lwm_dst_addr);\r\n}else{\r\nti = proto_tree_add_uint(lwm_tree, hf_lwm_dst_addr, tvb, 4, 2, lwm_dst_addr);\r\nif(lwm_fcf_multicast){\r\nproto_item_append_text(ti, " %s", LWM_MULTI_GROUP_STRING);\r\n}else{\r\nproto_item_append_text(ti, " %s", LWM_MULTI_UNICAST_STRING);\r\nif(lwm_dst_addr < 0x8000){\r\nproto_item_append_text(ti, " (Routing node)");\r\n}else{\r\nproto_item_append_text(ti, " (Non-routing node)");\r\n}\r\n}\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Nwk_Dst: 0x%04x, Nwk_Src: 0x%04x", lwm_dst_addr, lwm_src_addr);\r\nlwm_endp_field = tvb_get_guint8(tvb, 6);\r\nlwm_src_endp = (lwm_endp_field & LWM_SRC_ENDP_MASK) >> LWM_SRC_ENDP_OFFSET;\r\nlwm_dst_endp = (lwm_endp_field & LWM_DST_ENDP_MASK) >> LWM_DST_ENDP_OFFSET;\r\nti = proto_tree_add_uint(lwm_tree, hf_lwm_src_endp, tvb, 6, 1, lwm_src_endp);\r\nif(lwm_src_endp == 0){\r\nproto_item_append_text(ti, " (Stack command endpoint)");\r\n}\r\nti = proto_tree_add_uint(lwm_tree, hf_lwm_dst_endp, tvb, 6, 1, lwm_dst_endp);\r\nif(lwm_dst_endp == 0){\r\nproto_item_append_text(ti, " (Stack command endpoint)");\r\n}\r\nif( (lwm_src_endp == 0) && (lwm_dst_endp == 0)){\r\n}\r\nelse if( (lwm_src_endp == 0) || (lwm_dst_endp == 0)){\r\ncol_append_str(pinfo->cinfo, COL_INFO, "[Stack command Endpoints mismatch]");\r\nexpert_add_info(pinfo, lwm_tree, &ei_lwm_mismatch_endp);\r\n}\r\nif( (lwm_fcf_multicast) ){\r\nlwm_header_len += LWM_MULTI_HEADER_LEN;\r\nif(tree){\r\nproto_tree *multi_tree;\r\nguint16 lwm_multi_header;\r\nlwm_multi_header = tvb_get_letohs(tvb, 7);\r\nmulti_tree = proto_tree_add_subtree(lwm_tree, tvb, 7, 2, ett_lwm_multi_tree, NULL, "Multicast Header");\r\nproto_tree_add_uint(multi_tree, hf_lwm_multi_nmrad, tvb, 7, 2,\r\n(lwm_multi_header & LWM_MULTI_NON_MEM_RAD_MASK) >> LWM_MULTI_NON_MEM_RAD_OFFSET);\r\nproto_tree_add_uint(multi_tree, hf_lwm_multi_mnmrad, tvb, 7, 2,\r\n(lwm_multi_header & LWM_MULTI_MAX_NON_MEM_RAD_MASK) >> LWM_MULTI_MAX_NON_MEM_RAD_OFFSET);\r\nproto_tree_add_uint(multi_tree, hf_lwm_multi_mrad, tvb, 7, 2,\r\n(lwm_multi_header & LWM_MULTI_MEM_RAD_MASK) >> LWM_MULTI_MEM_RAD_OFFSET);\r\nproto_tree_add_uint(multi_tree, hf_lwm_multi_mmrad, tvb, 7, 2,\r\n(lwm_multi_header & LWM_MULTI_MAX_MEM_RAD_MASK) >> LWM_MULTI_MAX_MEM_RAD_OFFSET);\r\n}\r\n}\r\nif (tvb_reported_length(tvb) <= lwm_header_len) {\r\nexpert_add_info(pinfo, lwm_tree, &ei_lwm_empty_payload);\r\ncol_append_str(pinfo->cinfo, COL_INFO, "[Empty LwMesh Payload]");\r\nreturn tvb_captured_length(tvb);\r\n}\r\nnew_tvb = tvb_new_subset_remaining(tvb, lwm_header_len);\r\nif(lwm_fcf_security){\r\nguint rlen;\r\ngint start;\r\nguint32 lwm_mic;\r\nrlen = tvb_reported_length(new_tvb);\r\nstart = (rlen >= LWM_MIC_LEN) ? (rlen-LWM_MIC_LEN) : 0;\r\nproto_tree_add_item_ret_uint(lwm_tree, hf_lwm_mic, new_tvb, start, LWM_MIC_LEN, ENC_LITTLE_ENDIAN, &lwm_mic);\r\n#ifdef HAVE_LIBGCRYPT\r\nif(lwmes_key_valid)\r\n{\r\nieee802154_packet *ieee_packet = NULL;\r\ngint payload_length = 0;\r\ngint length = 0;\r\ngint payload_offset = 0;\r\nguint8 block;\r\ntvbuff_t *decrypted_tvb;\r\ngcry_cipher_hd_t cypher_hd;\r\nguint8* vector = NULL;\r\nguint8* text =NULL;\r\nguint8* text_dec =NULL;\r\nguint8 i;\r\nguint32 vmic;\r\nguint32 nwkSecurityVector[4];\r\nieee_packet = (ieee802154_packet *)data;\r\nmemset(&nwkSecurityVector, 0, sizeof(nwkSecurityVector));\r\nnwkSecurityVector[0] = lwm_seq;\r\nnwkSecurityVector[1] = ((guint32)lwm_dst_addr<< 16) | lwm_dst_endp;\r\nnwkSecurityVector[2]= ((guint32) lwm_src_addr<< 16) | lwm_src_endp;\r\nnwkSecurityVector[3] = ((guint32)ieee_packet->dst_pan << 16) | (guint8)lwm_fcf;\r\npayload_length=tvb_reported_length(new_tvb) - LWM_MIC_LEN;\r\ntext = (guint8 *)tvb_memdup(pinfo->pool, new_tvb, 0, payload_length);\r\npayload_offset=0;\r\nwhile(payload_length>0)\r\n{\r\nint gcrypt_err;\r\ngcrypt_err = gcry_cipher_open(&cypher_hd, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_ECB, 0);\r\nif(gcrypt_err == 0) {\r\ngcrypt_err = gcry_cipher_setkey(cypher_hd,(guint8 *)lwmes_key, 16);\r\n}\r\nif(gcrypt_err == 0) {\r\ngcrypt_err = gcry_cipher_encrypt(cypher_hd,(guint8 *)nwkSecurityVector,16,(guint8 *)nwkSecurityVector,16);\r\n}\r\nif(gcrypt_err)\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Encrypted data (%i byte(s)) DECRYPT FAILED",\r\ntvb_reported_length(new_tvb) - LWM_MIC_LEN);\r\nexpert_add_info(pinfo, lwm_tree, &ei_lwm_decryption_failed);\r\ntvb_set_reported_length(new_tvb, tvb_reported_length(new_tvb) - LWM_MIC_LEN);\r\ncall_data_dissector(new_tvb, pinfo, lwm_tree);\r\n}\r\ntext_dec = &text[payload_offset];\r\nvector = (guint8 *)nwkSecurityVector;\r\nblock = (payload_length < 16) ? payload_length : 16;\r\nfor (i = 0; i < block; i++)\r\n{\r\ntext_dec[i] ^= vector[i];\r\nvector[i] ^= text_dec[i];\r\n}\r\npayload_offset += block;\r\npayload_length -= block;\r\ngcry_cipher_close(cypher_hd);\r\n}\r\nvmic = nwkSecurityVector[0] ^ nwkSecurityVector[1] ^ nwkSecurityVector[2] ^ nwkSecurityVector[3];\r\nlength = tvb_reported_length(new_tvb) - LWM_MIC_LEN;\r\nif(vmic == lwm_mic)\r\n{\r\ndecrypted_tvb = tvb_new_real_data(text,length, length);\r\ncall_data_dissector(decrypted_tvb, pinfo, lwm_tree);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", MIC SUCCESS");\r\n}\r\nelse\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Encrypted data (%i byte(s)) MIC FAILURE",\r\ntvb_reported_length(new_tvb) - LWM_MIC_LEN);\r\ntvb_set_reported_length(new_tvb, tvb_reported_length(new_tvb) - LWM_MIC_LEN);\r\ncall_data_dissector(new_tvb, pinfo, lwm_tree);\r\n}\r\n}\r\nelse\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Encrypted data (%i byte(s)) NO DECRYPT KEY",\r\ntvb_reported_length(new_tvb) - LWM_MIC_LEN);\r\nexpert_add_info(pinfo, lwm_tree, &ei_lwm_no_decryption_key);\r\ntvb_set_reported_length(new_tvb, tvb_reported_length(new_tvb) - LWM_MIC_LEN);\r\ncall_data_dissector(new_tvb, pinfo, lwm_tree);\r\n}\r\n#else\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Encrypted data (%i byte(s)): libgcrypt not present, cannot decrypt",\r\ntvb_reported_length(new_tvb) - LWM_MIC_LEN);\r\nexpert_add_info(pinfo, lwm_tree, &ei_lwm_no_decryption_key);\r\ntvb_set_reported_length(new_tvb, tvb_reported_length(new_tvb) - LWM_MIC_LEN);\r\ncall_data_dissector(new_tvb, pinfo, lwm_tree);\r\n#endif\r\n}\r\nelse if( (lwm_src_endp == 0) && (lwm_dst_endp == 0) ){\r\nproto_tree *lwm_cmd_tree;\r\nguint8 lwm_cmd;\r\nguint len;\r\nlwm_cmd = tvb_get_guint8(new_tvb, 0);\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s",\r\nval_to_str(lwm_cmd, lwm_cmd_names, LWM_CMD_UNKNOWN_VAL_STRING));\r\nlwm_cmd_tree = proto_tree_add_subtree(lwm_tree, new_tvb, 0, -1, ett_lwm_cmd_tree, &ti,\r\nval_to_str(lwm_cmd, lwm_cmd_names, LWM_CMD_UNKNOWN_VAL_STRING));\r\nproto_tree_add_uint(lwm_cmd_tree, hf_lwm_cmd, new_tvb, 0, 1, lwm_cmd);\r\nswitch (lwm_cmd) {\r\ncase LWM_CMD_ACK:\r\nlen = dissect_lwm_cmd_frame_ack(new_tvb, pinfo, lwm_cmd_tree);\r\nbreak;\r\ncase LWM_CMD_ROUTE_ERR:\r\nlen = dissect_lwm_cmd_frame_route_err(new_tvb, pinfo, lwm_cmd_tree);\r\nbreak;\r\ncase LWM_CMD_ROUTE_REQ:\r\nlen = dissect_lwm_cmd_frame_route_req(new_tvb, pinfo, lwm_cmd_tree);\r\nbreak;\r\ncase LWM_CMD_ROUTE_REPLY:\r\nlen = dissect_lwm_cmd_frame_route_reply(new_tvb, pinfo, lwm_cmd_tree);\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, lwm_cmd_tree, &ei_lwm_mal_error, "Unknown command");\r\ncall_data_dissector(new_tvb, pinfo, lwm_cmd_tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nproto_item_set_len(ti, len);\r\nif (len < tvb_reported_length(new_tvb)) {\r\nexpert_add_info_format(pinfo, lwm_cmd_tree, &ei_lwm_mal_error,\r\n"Size is %i byte(s), instead of %i bytes", tvb_reported_length(new_tvb), len);\r\nnew_tvb = tvb_new_subset_remaining(new_tvb, len);\r\ncall_data_dissector(new_tvb, pinfo, lwm_tree);\r\n}\r\n}\r\nelse{\r\ncall_data_dissector(new_tvb, pinfo, lwm_tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_lwm_cmd_frame_ack(tvbuff_t *tvb, packet_info *pinfo, proto_tree *lwm_cmd_tree)\r\n{\r\nguint8 lwm_seq;\r\nlwm_seq = tvb_get_guint8(tvb, 1);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Sequence number: %d", lwm_seq);\r\nif(lwm_cmd_tree){\r\nproto_item_append_text(proto_tree_get_parent(lwm_cmd_tree), ", Sequence number: %d", lwm_seq);\r\nproto_tree_add_uint(lwm_cmd_tree, hf_lwm_cmd_seq, tvb, 1, 1, lwm_seq);\r\nproto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_cm, tvb, 2, 1, ENC_NA);\r\n}\r\nreturn LWM_CMD_FRAME_ACK_LEN;\r\n}\r\nstatic int dissect_lwm_cmd_frame_route_err(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *lwm_cmd_tree)\r\n{\r\nif(lwm_cmd_tree){\r\nproto_item *ti;\r\nproto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_route_src, tvb, 1, 2, ENC_LITTLE_ENDIAN);\r\nti = proto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_route_dst, tvb, 3, 2, ENC_LITTLE_ENDIAN);\r\nif(tvb_get_guint8(tvb, 5) == LWM_CMD_MULTI_ADDR_TRUE){\r\nproto_item_append_text(ti, " %s", LWM_MULTI_GROUP_STRING);\r\n}else{\r\nproto_item_append_text(ti, " %s", LWM_MULTI_UNICAST_STRING);\r\n}\r\nproto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_route_multi, tvb, 5, 1, ENC_NA);\r\n}\r\nreturn LWM_CMD_FRAME_ROUTE_ERR_LEN;\r\n}\r\nstatic int dissect_lwm_cmd_frame_route_req(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *lwm_cmd_tree)\r\n{\r\nif(lwm_cmd_tree){\r\nproto_item *ti;\r\nguint8 lwm_linkqual;\r\nproto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_route_src, tvb, 1, 2, ENC_LITTLE_ENDIAN);\r\nti = proto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_route_dst, tvb, 3, 2, ENC_LITTLE_ENDIAN);\r\nif(tvb_get_guint8(tvb, 5) == LWM_CMD_MULTI_ADDR_TRUE){\r\nproto_item_append_text(ti, " %s", LWM_MULTI_GROUP_STRING);\r\n}else{\r\nproto_item_append_text(ti, " %s", LWM_MULTI_UNICAST_STRING);\r\n}\r\nproto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_route_multi, tvb, 5, 1, ENC_NA);\r\nlwm_linkqual = tvb_get_guint8(tvb, 6);\r\nti = proto_tree_add_uint(lwm_cmd_tree, hf_lwm_cmd_linkquality, tvb, 6, 1, lwm_linkqual);\r\nif(lwm_linkqual == 255){\r\nproto_item_append_text(ti, " %s", LWM_CMD_LINKQ_STRING);\r\n}\r\n}\r\nreturn LWM_CMD_FRAME_ROUTE_REQ_LEN;\r\n}\r\nstatic int dissect_lwm_cmd_frame_route_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *lwm_cmd_tree)\r\n{\r\nif(lwm_cmd_tree){\r\nproto_item *ti;\r\nguint8 lwm_revlinkqual;\r\nproto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_route_src, tvb, 1, 2, ENC_LITTLE_ENDIAN);\r\nti = proto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_route_dst, tvb, 3, 2, ENC_LITTLE_ENDIAN);\r\nif(tvb_get_guint8(tvb, 5) == LWM_CMD_MULTI_ADDR_TRUE){\r\nproto_item_append_text(ti, " %s", LWM_MULTI_GROUP_STRING);\r\n}else{\r\nproto_item_append_text(ti, " %s", LWM_MULTI_UNICAST_STRING);\r\n}\r\nproto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_route_multi, tvb, 5, 1, ENC_NA);\r\nproto_tree_add_item(lwm_cmd_tree, hf_lwm_cmd_forwlinkquality, tvb, 6, 1, ENC_NA);\r\nlwm_revlinkqual = tvb_get_guint8(tvb, 7);\r\nti = proto_tree_add_uint(lwm_cmd_tree, hf_lwm_cmd_revlinkquality, tvb, 7, 1, lwm_revlinkqual);\r\nif(lwm_revlinkqual == 255){\r\nproto_item_append_text(ti, " %s", LWM_CMD_LINKQ_STRING);\r\n}\r\n}\r\nreturn LWM_CMD_FRAME_ROUTE_REPLY_LEN;\r\n}\r\nvoid proto_register_lwm(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_lwm_fcf,\r\n{ "Frame control field", "lwm.fcf", FT_UINT8, BASE_HEX, NULL, 0x0,\r\n"Control information for the frame.", HFILL }},\r\n{ &hf_lwm_fcf_ack_req,\r\n{ "Acknowledgment Request", "lwm.ack_req", FT_BOOLEAN, 8, NULL, LWM_FCF_ACK_REQUEST,\r\n"Specifies whether an acknowledgment is required from the destination node.", HFILL }},\r\n{ &hf_lwm_fcf_security,\r\n{ "Security Enabled", "lwm.security", FT_BOOLEAN, 8, NULL, LWM_FCF_SEC_EN,\r\n"Specifies whether the frame payload is encrypted.", HFILL }},\r\n{ &hf_lwm_fcf_linklocal,\r\n{ "Link Local", "lwm.linklocal", FT_BOOLEAN, 8, NULL, LWM_FCF_LINK_LOCAL,\r\n"It may be set to one to prevent neighboring nodes from rebroadcasting a frame.", HFILL }},\r\n{ &hf_lwm_fcf_multicast,\r\n{ "Multicast", "lwm.multicast", FT_BOOLEAN, 8, NULL, LWM_FCF_MULTICAST,\r\n"If the Multicast subfield is set to one, Multicast Header should be present and the Destination Address is a group address.", HFILL }},\r\n{ &hf_lwm_fcf_reserved,\r\n{ "Reserved bits", "lwm.fcf.reserved", FT_UINT8, BASE_HEX, NULL, LWM_FCF_RESERVED,\r\n"The 4 bits are reserved.", HFILL }},\r\n{ &hf_lwm_seq,\r\n{ "Sequence Number", "lwm.seq", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Specifies the sequence identifier for the frame.", HFILL }},\r\n{ &hf_lwm_src_addr,\r\n{ "Network Source Address", "lwm.src_addr", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Specifies the network address of the node originating the frame.", HFILL }},\r\n{ &hf_lwm_dst_addr,\r\n{ "Network Destination Address", "lwm.dst_addr", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Specifies the network address of the destination node or group address for multicast messages.", HFILL }},\r\n{ &hf_lwm_src_endp,\r\n{ "Source Endpoint", "lwm.src_endp", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Specifies the source endpoint identifier.", HFILL }},\r\n{ &hf_lwm_dst_endp,\r\n{ "Destination Endpoint", "lwm.dst_endp", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Specifies the destination endpoint identifier.", HFILL }},\r\n{ &hf_lwm_multi_nmrad,\r\n{ "Non-member Radius", "lwm.multi_nmrad", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Specifies remaining radius (number of hops) for Non-members of multicast group.", HFILL }},\r\n{ &hf_lwm_multi_mnmrad,\r\n{ "Maximum Non-member Radius", "lwm.multi_mnmrad", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Specifies maximum radius (number of hops) for Non-members of multicast group.", HFILL }},\r\n{ &hf_lwm_multi_mrad,\r\n{ "Member Radius", "lwm.multi_mrad", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Specifies remaining radius (number of hops) for Members of multicast group.", HFILL }},\r\n{ &hf_lwm_multi_mmrad,\r\n{ "Maximum Member Radius", "lwm.multi_mmrad", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Specifies maximum radius (number of hops) for Members of multicast group.", HFILL }},\r\n{ &hf_lwm_mic,\r\n{ "Message Integrity Code", "lwm.mic", FT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Specifies Message Integrity Code (MIC).", HFILL }},\r\n{ &hf_lwm_cmd,\r\n{ "Command ID", "lwm.cmd", FT_UINT8, BASE_HEX, VALS(lwm_cmd_names), 0x0,\r\n"It contains Command ID value.", HFILL }},\r\n{ &hf_lwm_cmd_seq,\r\n{ "Sequence number", "lwm.cmd.seq", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"It contains a network sequence number of a frame that is being acknowledged.", HFILL }},\r\n{ &hf_lwm_cmd_cm,\r\n{ "Control Message", "lwm.cmd.cm", FT_UINT8, BASE_HEX, NULL, 0x0,\r\n"It contains an arbitrary value that can be set on the sending side.", HFILL }},\r\n{ &hf_lwm_cmd_route_src,\r\n{ "Source address", "lwm.cmd.route_src", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"It contains a source network address from the frame that cannot be routed", HFILL }},\r\n{ &hf_lwm_cmd_route_dst,\r\n{ "Destination Address", "lwm.cmd.route_dst", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"It contains a destination network address from the frame that cannot be routed", HFILL }},\r\n{ &hf_lwm_cmd_route_multi,\r\n{ "Multicast", "lwm.cmd.multi", FT_UINT8, BASE_HEX, VALS(lwm_cmd_multi_names), 0x0,\r\n"If it set to 0, Destination Address field contains a network address. If it set to 1, Destination Address field contains a group ID.", HFILL }},\r\n{ &hf_lwm_cmd_linkquality,\r\n{ "Link Quality", "lwm.cmd.linkq", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"It contains a link quality value of the potential route accumulated over all hops towards the destination.", HFILL }},\r\n{ &hf_lwm_cmd_forwlinkquality,\r\n{ "Forward Link Quality", "lwm.cmd.flinkq", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"It contains a value of the Link Quality field from the corresponding Route Request Command Frame.", HFILL }},\r\n{ &hf_lwm_cmd_revlinkquality,\r\n{ "Reverse Link Quality", "lwm.cmd.rlinkq", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"It contains a link quality value of the discovered route accumulated over all hops towards the originator.", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_lwm,\r\n&ett_lwm_fcf,\r\n&ett_lwm_multi_tree,\r\n&ett_lwm_cmd_tree\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_lwm_mal_error, { "lwm.malformed_error", PI_MALFORMED, PI_ERROR, "Malformed Packet", EXPFILL }},\r\n{ &ei_lwm_n_src_broad, { "lwm.not_src_broadcast", PI_COMMENTS_GROUP, PI_NOTE, "Source address can not be broadcast address !", EXPFILL }},\r\n{ &ei_lwm_mismatch_endp, { "lwm.mismatch_endp", PI_COMMENTS_GROUP, PI_WARN, "Stack command Endpoints mismatch (should be 0, both)!", EXPFILL }},\r\n{ &ei_lwm_empty_payload, { "lwm.empty_payload", PI_COMMENTS_GROUP, PI_WARN, "Empty LwMesh Payload!", EXPFILL }},\r\n{ &ei_lwm_no_decryption_key, { "lwm.no_decryption_key", PI_PROTOCOL, PI_NOTE, "No encryption key set - can't decrypt", EXPFILL }},\r\n{ &ei_lwm_decryption_failed, { "lwm.decryption_failed", PI_PROTOCOL, PI_WARN, "Decryption Failed", EXPFILL }},\r\n};\r\nmodule_t *lw_module;\r\nexpert_module_t* expert_lwm;\r\nproto_lwm = proto_register_protocol("Lightweight Mesh (v1.1.1)", "LwMesh", "lwm");\r\nproto_register_field_array(proto_lwm, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_lwm = expert_register_protocol(proto_lwm);\r\nexpert_register_field_array(expert_lwm, ei, array_length(ei));\r\nlw_module = prefs_register_protocol(proto_lwm,proto_reg_handoff_lwm);\r\nprefs_register_string_preference(lw_module, "lwmes_key", "Lw Decryption key",\r\n"128-bit decryption key in hexadecimal format", (const char **)&lwmes_key_str);\r\nregister_dissector("lwm", dissect_lwm, proto_lwm);\r\n}\r\nvoid proto_reg_handoff_lwm(void)\r\n{\r\nGByteArray *bytes;\r\ngboolean res;\r\nbytes = g_byte_array_new();\r\nres = hex_str_to_bytes(lwmes_key_str, bytes, FALSE);\r\nlwmes_key_valid = (res && bytes->len >= IEEE802154_CIPHER_SIZE);\r\nif (lwmes_key_valid) {\r\nmemcpy(lwmes_key, bytes->data, IEEE802154_CIPHER_SIZE);\r\n}\r\ng_byte_array_free(bytes, TRUE);\r\ndissector_add_for_decode_as(IEEE802154_PROTOABBREV_WPAN_PANID, find_dissector("lwm"));\r\nheur_dissector_add(IEEE802154_PROTOABBREV_WPAN, dissect_lwm_heur, "Lightweight Mesh over IEEE 802.15.4", "lwm_wlan", proto_lwm, HEURISTIC_ENABLE);\r\n}
