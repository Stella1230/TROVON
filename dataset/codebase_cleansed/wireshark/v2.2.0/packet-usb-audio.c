static inline gboolean\r\nis_sysex_code(guint8 code)\r\n{\r\nreturn (code == 0x04 || code == 0x05 || code == 0x06 || code == 0x07);\r\n}\r\nstatic gboolean\r\nis_last_sysex_packet_in_tvb(tvbuff_t *tvb, gint offset)\r\n{\r\ngboolean last = TRUE;\r\ngint length = tvb_reported_length(tvb);\r\noffset += 4;\r\nwhile (offset < length)\r\n{\r\nguint8 code = tvb_get_guint8(tvb, offset);\r\ncode &= 0x0F;\r\nif (is_sysex_code(code))\r\n{\r\nlast = FALSE;\r\nbreak;\r\n}\r\noffset += 4;\r\n}\r\nreturn last;\r\n}\r\nstatic void\r\ndissect_usb_midi_event(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *usb_audio_tree, proto_tree *parent_tree,\r\ngint offset)\r\n{\r\nguint8 code;\r\nguint8 cable;\r\ngboolean save_fragmented;\r\nproto_tree *tree = NULL;\r\ncol_set_str(pinfo->cinfo, COL_INFO, "USB-MIDI Event Packets");\r\ncode = tvb_get_guint8(tvb, offset);\r\ncable = (code & 0xF0) >> 4;\r\ncode &= 0x0F;\r\nif (parent_tree)\r\n{\r\nproto_item *ti;\r\nti = proto_tree_add_protocol_format(usb_audio_tree, proto_usb_audio, tvb, offset, 4, "USB Midi Event Packet");\r\ntree = proto_item_add_subtree(ti, ett_usb_audio);\r\nproto_tree_add_item(tree, hf_midi_cable_number, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_midi_code_index, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_midi_event, tvb, offset+1, 3, ENC_BIG_ENDIAN);\r\n}\r\nsave_fragmented = pinfo->fragmented;\r\nif (is_sysex_code(code))\r\n{\r\ntvbuff_t* new_tvb = NULL;\r\nfragment_head *frag_sysex_msg = NULL;\r\npinfo->fragmented = TRUE;\r\nif (code == 0x04)\r\n{\r\nfrag_sysex_msg = fragment_add_seq_next(&midi_data_reassembly_table,\r\ntvb, offset+1,\r\npinfo,\r\ncable,\r\nNULL,\r\n3,\r\nTRUE);\r\n}\r\nelse\r\n{\r\nfrag_sysex_msg = fragment_add_seq_next(&midi_data_reassembly_table,\r\ntvb, offset+1,\r\npinfo,\r\ncable,\r\nNULL,\r\n(gint)(code - 4),\r\nFALSE);\r\n}\r\nif (is_last_sysex_packet_in_tvb(tvb, offset))\r\n{\r\nnew_tvb = process_reassembled_data(tvb, offset+1, pinfo,\r\n"Reassembled Message", frag_sysex_msg, &sysex_msg_frag_items,\r\nNULL, usb_audio_tree);\r\nif (code != 0x04) {\r\ncol_append_str(pinfo->cinfo, COL_INFO,\r\n" (SysEx Reassembled)");\r\n} else {\r\ncol_append_str(pinfo->cinfo, COL_INFO,\r\n" (SysEx fragment)");\r\n}\r\nif (new_tvb)\r\n{\r\ncall_dissector(sysex_handle, new_tvb, pinfo, parent_tree);\r\n}\r\n}\r\n}\r\npinfo->fragmented = save_fragmented;\r\n}\r\nstatic gint\r\ndissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, usb_conv_info_t *usb_conv_info)\r\n{\r\ngint offset_start;\r\nguint16 bcdADC;\r\nguint8 ver_major;\r\ndouble ver;\r\nguint8 if_in_collection, i;\r\naudio_conv_info_t *audio_conv_info;\r\noffset_start = offset;\r\nbcdADC = tvb_get_letohs(tvb, offset);\r\nver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\r\nver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\r\nproto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\r\ntvb, offset, 2, ver, "%2.2f", ver);\r\naudio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\r\nif(!audio_conv_info) {\r\naudio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\r\nusb_conv_info->class_data = audio_conv_info;\r\nusb_conv_info->class_data_type = USB_CONV_AUDIO;\r\n} else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\r\nreturn 0;\r\n}\r\naudio_conv_info->ver_major = ver_major;\r\noffset += 2;\r\nif (ver_major==1) {\r\nproto_tree_add_item(tree, hf_ac_if_hdr_total_len,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif_in_collection = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nfor (i=0; i<if_in_collection; i++) {\r\nproto_tree_add_item(tree, hf_ac_if_hdr_if_num,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\n}\r\n}\r\nreturn offset-offset_start;\r\n}\r\nstatic gint\r\ndissect_ac_if_input_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\r\n{\r\ngint offset_start;\r\nstatic const int *input_channelconfig[] = {\r\n&hf_ac_if_input_channelconfig_d0,\r\n&hf_ac_if_input_channelconfig_d1,\r\n&hf_ac_if_input_channelconfig_d2,\r\n&hf_ac_if_input_channelconfig_d3,\r\n&hf_ac_if_input_channelconfig_d4,\r\n&hf_ac_if_input_channelconfig_d5,\r\n&hf_ac_if_input_channelconfig_d6,\r\n&hf_ac_if_input_channelconfig_d7,\r\n&hf_ac_if_input_channelconfig_d8,\r\n&hf_ac_if_input_channelconfig_d9,\r\n&hf_ac_if_input_channelconfig_d10,\r\n&hf_ac_if_input_channelconfig_d11,\r\n&hf_ac_if_input_channelconfig_rsv,\r\nNULL\r\n};\r\noffset_start = offset;\r\nproto_tree_add_item(tree, hf_ac_if_input_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_input_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_ac_if_input_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_input_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_input_channelconfig, ett_ac_if_input_channelconfig, input_channelconfig, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_ac_if_input_channelnames, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_input_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset-offset_start;\r\n}\r\nstatic gint\r\ndissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\r\n{\r\ngint offset_start;\r\noffset_start = offset;\r\nproto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset-offset_start;\r\n}\r\nstatic gint\r\ndissect_ac_if_feature_unit(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\r\n{\r\ngint offset_start;\r\nguint8 controlsize;\r\nproto_tree *bitmap_tree;\r\nproto_item *ti;\r\nstatic const int *fu_controls0[] = {\r\n&hf_ac_if_fu_controls_d0,\r\n&hf_ac_if_fu_controls_d1,\r\n&hf_ac_if_fu_controls_d2,\r\n&hf_ac_if_fu_controls_d3,\r\n&hf_ac_if_fu_controls_d4,\r\n&hf_ac_if_fu_controls_d5,\r\n&hf_ac_if_fu_controls_d6,\r\n&hf_ac_if_fu_controls_d7,\r\nNULL };\r\nstatic const int *fu_controls1[] = {\r\n&hf_ac_if_fu_controls_d8,\r\n&hf_ac_if_fu_controls_d9,\r\n&hf_ac_if_fu_controls_rsv,\r\nNULL };\r\noffset_start = offset;\r\nproto_tree_add_item(tree, hf_ac_if_fu_unitid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_fu_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_fu_controlsize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\ncontrolsize = tvb_get_guint8(tvb, offset) + 1;\r\noffset += 1;\r\nti = proto_tree_add_item(tree, hf_ac_if_fu_controls, tvb, offset, controlsize, ENC_NA);\r\nbitmap_tree = proto_item_add_subtree(ti, ett_ac_if_fu_controls);\r\nproto_tree_add_bitmask(bitmap_tree, tvb, offset, hf_ac_if_fu_control, ett_ac_if_fu_controls0, fu_controls0, ENC_LITTLE_ENDIAN);\r\nif(controlsize >= 1){\r\nproto_tree_add_bitmask(bitmap_tree, tvb, offset + 1, hf_ac_if_fu_control, ett_ac_if_fu_controls1, fu_controls1, ENC_LITTLE_ENDIAN);\r\n}\r\noffset += controlsize;\r\nproto_tree_add_item(tree, hf_ac_if_fu_ifeature, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset-offset_start;\r\n}\r\nstatic gint\r\ndissect_ac_if_mixed_unit(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\r\n{\r\ngint offset_start;\r\nguint8 nrinpins;\r\nstatic const int *mu_channelconfig[] = {\r\n&hf_ac_if_mu_channelconfig_d0,\r\n&hf_ac_if_mu_channelconfig_d1,\r\n&hf_ac_if_mu_channelconfig_d2,\r\n&hf_ac_if_mu_channelconfig_d3,\r\n&hf_ac_if_mu_channelconfig_d4,\r\n&hf_ac_if_mu_channelconfig_d5,\r\n&hf_ac_if_mu_channelconfig_d6,\r\n&hf_ac_if_mu_channelconfig_d7,\r\n&hf_ac_if_mu_channelconfig_d8,\r\n&hf_ac_if_mu_channelconfig_d9,\r\n&hf_ac_if_mu_channelconfig_d10,\r\n&hf_ac_if_mu_channelconfig_d11,\r\n&hf_ac_if_mu_channelconfig_rsv,\r\nNULL\r\n};\r\noffset_start = offset;\r\nproto_tree_add_item(tree, hf_ac_if_mu_unitid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_mu_nrinpins, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nnrinpins = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nwhile(nrinpins){\r\nproto_tree_add_item(tree, hf_ac_if_mu_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nnrinpins--;\r\noffset += 1;\r\n}\r\nproto_tree_add_item(tree, hf_ac_if_mu_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_ac_if_mu_channelconfig, ett_ac_if_mu_channelconfig, mu_channelconfig, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_ac_if_mu_channelnames, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_mu_controls, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_ac_if_mu_imixer, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset-offset_start;\r\n}\r\nstatic gint\r\ndissect_as_if_general_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, usb_conv_info_t *usb_conv_info)\r\n{\r\naudio_conv_info_t *audio_conv_info;\r\ngint offset_start;\r\naudio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\r\nif (!audio_conv_info)\r\nreturn 0;\r\noffset_start = offset;\r\nif (audio_conv_info->ver_major==1) {\r\nproto_tree_add_item(tree, hf_as_if_gen_term_id,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_as_if_gen_delay,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_as_if_gen_format,\r\ntvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nreturn offset-offset_start;\r\n}\r\nstatic gint\r\ndissect_as_if_format_type_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\r\nproto_tree *tree, usb_conv_info_t *usb_conv_info)\r\n{\r\naudio_conv_info_t *audio_conv_info;\r\ngint offset_start;\r\nguint8 SamFreqType;\r\nguint8 format_type;\r\naudio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\r\nif (!audio_conv_info)\r\nreturn 0;\r\noffset_start = offset;\r\nproto_tree_add_item(tree, hf_as_if_ft_formattype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nformat_type = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nswitch(format_type){\r\ncase 1:\r\nproto_tree_add_item(tree, hf_as_if_ft_nrchannels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_as_if_ft_subframesize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_as_if_ft_bitresolution, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_as_if_ft_samfreqtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nSamFreqType = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nif(SamFreqType == 0){\r\nproto_tree_add_item(tree, hf_as_if_ft_lowersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(tree, hf_as_if_ft_uppersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\n}else {\r\nwhile(SamFreqType){\r\nproto_tree_add_item(tree, hf_as_if_ft_samfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nSamFreqType--;\r\n}\r\n}\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(tree, hf_as_if_ft_maxbitrate, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_as_if_ft_samplesperframe, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_as_if_ft_samfreqtype, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nSamFreqType = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nif(SamFreqType == 0){\r\nproto_tree_add_item(tree, hf_as_if_ft_lowersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(tree, hf_as_if_ft_uppersamfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\n}else {\r\nwhile(SamFreqType){\r\nproto_tree_add_item(tree, hf_as_if_ft_samfreq, tvb, offset, 3, ENC_LITTLE_ENDIAN);\r\noffset += 3;\r\nSamFreqType--;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset-offset_start;\r\n}\r\nstatic gint\r\ndissect_usb_audio_descriptor(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void *data)\r\n{\r\ngint offset = 0;\r\nusb_conv_info_t *usb_conv_info;\r\nproto_tree *desc_tree = NULL;\r\nproto_item *desc_tree_item;\r\nguint8 desc_len;\r\nguint8 desc_type;\r\nguint8 desc_subtype;\r\nconst gchar *subtype_str;\r\nusb_conv_info = (usb_conv_info_t *)data;\r\nif (!usb_conv_info || usb_conv_info->interfaceClass!=IF_CLASS_AUDIO)\r\nreturn 0;\r\ndesc_len = tvb_get_guint8(tvb, offset);\r\ndesc_type = tvb_get_guint8(tvb, offset+1);\r\nif (desc_type==CS_INTERFACE &&\r\nusb_conv_info->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOCONTROL) {\r\ndesc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\r\nett_usb_audio_desc, &desc_tree_item,\r\n"Class-specific Audio Control Interface Descriptor");\r\ndissect_usb_descriptor_header(desc_tree, tvb, offset,\r\n&aud_descriptor_type_vals_ext);\r\noffset += 2;\r\ndesc_subtype = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(desc_tree, hf_ac_if_desc_subtype,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nsubtype_str = try_val_to_str_ext(desc_subtype, &ac_subtype_vals_ext);\r\nif (subtype_str)\r\nproto_item_append_text(desc_tree_item, ": %s", subtype_str);\r\noffset++;\r\nswitch(desc_subtype) {\r\ncase AC_SUBTYPE_HEADER:\r\ndissect_ac_if_hdr_body(tvb, offset, pinfo, desc_tree, usb_conv_info);\r\nbreak;\r\ncase AC_SUBTYPE_INPUT_TERMINAL:\r\ndissect_ac_if_input_terminal(tvb, offset, pinfo, desc_tree, usb_conv_info);\r\nbreak;\r\ncase AC_SUBTYPE_OUTPUT_TERMINAL:\r\ndissect_ac_if_output_terminal(tvb, offset, pinfo, desc_tree, usb_conv_info);\r\nbreak;\r\ncase AC_SUBTYPE_MIXER_UNIT:\r\ndissect_ac_if_mixed_unit(tvb, offset, pinfo, desc_tree, usb_conv_info);\r\nbreak;\r\ncase AC_SUBTYPE_FEATURE_UNIT:\r\ndissect_ac_if_feature_unit(tvb, offset, pinfo, desc_tree, usb_conv_info);\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(desc_tree, pinfo, &ei_usb_audio_undecoded, tvb, offset-3, desc_len);\r\nbreak;\r\n}\r\n}\r\nelse if (desc_type==CS_INTERFACE &&\r\nusb_conv_info->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOSTREAMING) {\r\ndesc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\r\nett_usb_audio_desc, &desc_tree_item,\r\n"Class-specific Audio Streaming Interface Descriptor");\r\ndissect_usb_descriptor_header(desc_tree, tvb, offset,\r\n&aud_descriptor_type_vals_ext);\r\noffset += 2;\r\ndesc_subtype = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(desc_tree, hf_as_if_desc_subtype,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nsubtype_str = try_val_to_str_ext(desc_subtype, &as_subtype_vals_ext);\r\nif (subtype_str)\r\nproto_item_append_text(desc_tree_item, ": %s", subtype_str);\r\noffset++;\r\nswitch(desc_subtype) {\r\ncase AS_SUBTYPE_GENERAL:\r\ndissect_as_if_general_body(tvb, offset, pinfo,\r\ndesc_tree, usb_conv_info);\r\nbreak;\r\ncase AS_SUBTYPE_FORMAT_TYPE:\r\ndissect_as_if_format_type_body(tvb, offset, pinfo,\r\ndesc_tree, usb_conv_info);\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(desc_tree, pinfo, &ei_usb_audio_undecoded, tvb, offset-3, desc_len);\r\nbreak;\r\n}\r\n}\r\nelse if (desc_type == CS_ENDPOINT &&\r\nusb_conv_info->interfaceSubclass==AUDIO_IF_SUBCLASS_AUDIOSTREAMING) {\r\ndesc_tree = proto_tree_add_subtree(tree, tvb, offset, desc_len,\r\nett_usb_audio_desc, &desc_tree_item,\r\n"Class-specific Audio Streaming Endpoint Descriptor");\r\ndissect_usb_descriptor_header(desc_tree, tvb, offset,\r\n&aud_descriptor_type_vals_ext);\r\noffset += 2;\r\nproto_tree_add_item(desc_tree, hf_as_ep_desc_subtype,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nelse\r\nreturn 0;\r\nreturn desc_len;\r\n}\r\nstatic int\r\ndissect_usb_audio_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data)\r\n{\r\nusb_conv_info_t *usb_conv_info;\r\nproto_tree *tree;\r\nproto_item *ti;\r\ngint offset, length;\r\ngint i;\r\nif (data == NULL)\r\nreturn 0;\r\nusb_conv_info = (usb_conv_info_t *)data;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "USBAUDIO");\r\nti = proto_tree_add_protocol_format(parent_tree, proto_usb_audio, tvb, 0, -1, "USB Audio");\r\ntree = proto_item_add_subtree(ti, ett_usb_audio);\r\nlength = tvb_reported_length(tvb);\r\noffset = 0;\r\nswitch (usb_conv_info->interfaceSubclass)\r\n{\r\ncase AUDIO_IF_SUBCLASS_MIDISTREAMING:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "USB-MIDI Event Packets");\r\nfor (i = 0; i < length / 4; i++)\r\n{\r\ndissect_usb_midi_event(tvb, pinfo, tree, parent_tree, offset);\r\noffset += 4;\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(tree, pinfo, &ei_usb_audio_undecoded, tvb, offset, length);\r\n}\r\nreturn length;\r\n}\r\nstatic void\r\nmidi_data_reassemble_init(void)\r\n{\r\nreassembly_table_init(&midi_data_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\nmidi_data_reassemble_cleanup(void)\r\n{\r\nreassembly_table_destroy(&midi_data_reassembly_table);\r\n}\r\nvoid\r\nproto_register_usb_audio(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_midi_cable_number,\r\n{ "Cable Number", "usbaudio.midi.cable_number", FT_UINT8, BASE_HEX,\r\nNULL, 0xF0, NULL, HFILL }},\r\n{ &hf_midi_code_index,\r\n{ "Code Index", "usbaudio.midi.code_index", FT_UINT8, BASE_HEX,\r\nVALS(code_index_vals), 0x0F, NULL, HFILL }},\r\n{ &hf_midi_event,\r\n{ "MIDI Event", "usbaudio.midi.event", FT_UINT24, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ac_if_desc_subtype,\r\n{ "Subtype", "usbaudio.ac_if_subtype", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\r\n&ac_subtype_vals_ext, 0x00, "bDescriptorSubtype", HFILL }},\r\n{ &hf_ac_if_hdr_ver,\r\n{ "Version", "usbaudio.ac_if_hdr.bcdADC",\r\nFT_DOUBLE, BASE_NONE, NULL, 0, "bcdADC", HFILL }},\r\n{ &hf_ac_if_hdr_total_len,\r\n{ "Total length", "usbaudio.ac_if_hdr.wTotalLength",\r\nFT_UINT16, BASE_DEC, NULL, 0x00, "wTotalLength", HFILL }},\r\n{ &hf_ac_if_hdr_bInCollection,\r\n{ "Total number of interfaces", "usbaudio.ac_if_hdr.bInCollection",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bInCollection", HFILL }},\r\n{ &hf_ac_if_hdr_if_num,\r\n{ "Interface number", "usbaudio.ac_if_hdr.baInterfaceNr",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "baInterfaceNr", HFILL }},\r\n{ &hf_ac_if_input_terminalid,\r\n{ "Terminal ID", "usbaudio.ac_if_input.bTerminalID",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bTerminalID", HFILL }},\r\n{ &hf_ac_if_input_terminaltype,\r\n{ "Terminal Type", "usbaudio.ac_if_input.wTerminalType", FT_UINT16,\r\nBASE_HEX|BASE_EXT_STRING, &terminal_types_vals_ext, 0x00, "wTerminalType", HFILL }},\r\n{ &hf_ac_if_input_assocterminal,\r\n{ "Assoc Terminal", "usbaudio.ac_if_input.bAssocTerminal",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bAssocTerminal", HFILL }},\r\n{ &hf_ac_if_input_nrchannels,\r\n{ "Number Channels", "usbaudio.ac_if_input.bNrChannels",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bNrChannels", HFILL }},\r\n{ &hf_ac_if_input_channelconfig,\r\n{ "Channel Config", "usbaudio.ac_if_input.wChannelConfig",\r\nFT_UINT16, BASE_HEX, NULL, 0x00, "wChannelConfig", HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d0,\r\n{ "Left Front", "usbaudio.ac_if_input.wChannelConfig.d0",\r\nFT_BOOLEAN, 16, NULL, 0x0001, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d1,\r\n{ "Right Front", "usbaudio.ac_if_input.wChannelConfig.d1",\r\nFT_BOOLEAN, 16, NULL, 0x0002, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d2,\r\n{ "Center Front", "usbaudio.ac_if_input.wChannelConfig.d2",\r\nFT_BOOLEAN, 16, NULL, 0x0004, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d3,\r\n{ "Low Frequency Enhancement", "usbaudio.ac_if_input.wChannelConfig.d3",\r\nFT_BOOLEAN, 16, NULL, 0x0008, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d4,\r\n{ "Left Surround", "usbaudio.ac_if_input.wChannelConfig.d4",\r\nFT_BOOLEAN, 16, NULL, 0x0010, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d5,\r\n{ "Right Surround", "usbaudio.ac_if_input.wChannelConfig.d5",\r\nFT_BOOLEAN, 16, NULL, 0x0020, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d6,\r\n{ "Left of Center", "usbaudio.ac_if_input.wChannelConfig.d6",\r\nFT_BOOLEAN, 16, NULL, 0x0040, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d7,\r\n{ "Right of Center", "usbaudio.ac_if_input.wChannelConfig.d7",\r\nFT_BOOLEAN, 16, NULL, 0x0080, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d8,\r\n{ "Surround", "usbaudio.ac_if_input.wChannelConfig.d8",\r\nFT_BOOLEAN, 16, NULL, 0x0100, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d9,\r\n{ "Side Left", "usbaudio.ac_if_input.wChannelConfig.d9",\r\nFT_BOOLEAN, 16, NULL, 0x0200, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d10,\r\n{ "Side Right", "usbaudio.ac_if_input.wChannelConfig.d10",\r\nFT_BOOLEAN, 16, NULL, 0x0400, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_d11,\r\n{ "Top", "usbaudio.ac_if_input.wChannelConfig.d11",\r\nFT_BOOLEAN, 16, NULL, 0x0800, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelconfig_rsv,\r\n{ "Reserved", "usbaudio.ac_if_input.wChannelConfig.rsv",\r\nFT_UINT16, BASE_HEX, NULL, 0xF000, NULL, HFILL }},\r\n{ &hf_ac_if_input_channelnames,\r\n{ "Channel Names", "usbaudio.ac_if_input.iChannelNames",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "iChannelNames", HFILL }},\r\n{ &hf_ac_if_input_terminal,\r\n{ "Terminal", "usbaudio.ac_if_input.iTerminal",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "iTerminal", HFILL }},\r\n{ &hf_ac_if_output_terminalid,\r\n{ "Terminal ID", "usbaudio.ac_if_output.bTerminalID",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bTerminalID", HFILL }},\r\n{ &hf_ac_if_output_terminaltype,\r\n{ "Terminal Type", "usbaudio.ac_if_output.wTerminalType", FT_UINT16,\r\nBASE_HEX|BASE_EXT_STRING, &terminal_types_vals_ext, 0x00, "wTerminalType", HFILL }},\r\n{ &hf_ac_if_output_assocterminal,\r\n{ "Assoc Terminal", "usbaudio.ac_if_output.bAssocTerminal",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bAssocTerminal", HFILL }},\r\n{ &hf_ac_if_output_sourceid,\r\n{ "Source ID", "usbaudio.ac_if_output.bSourceID",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bSourceID", HFILL }},\r\n{ &hf_ac_if_output_terminal,\r\n{ "Terminal", "usbaudio.ac_if_output.iTerminal",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "iTerminal", HFILL }},\r\n{ &hf_ac_if_fu_unitid,\r\n{ "Unit ID", "usbaudio.ac_if_fu.bUnitID",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bUnitID", HFILL }},\r\n{ &hf_ac_if_fu_sourceid,\r\n{ "Source ID", "usbaudio.ac_if_fu.bSourceID",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bSourceID", HFILL }},\r\n{ &hf_ac_if_fu_controlsize,\r\n{ "Control Size", "usbaudio.ac_if_fu.bControlSize",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bControlSize", HFILL }},\r\n{ &hf_ac_if_fu_controls,\r\n{ "Controls", "usbaudio.ac_if_fu.bmaControls",\r\nFT_BYTES, BASE_NONE, NULL, 0x00, "bmaControls", HFILL }},\r\n{ &hf_ac_if_fu_control,\r\n{ "Control", "usbaudio.ac_if_fu.bmaControl",\r\nFT_UINT8, BASE_HEX, NULL, 0x00, "bmaControls", HFILL }},\r\n{ &hf_ac_if_fu_controls_d0,\r\n{ "Mute", "usbaudio.ac_if_fu.bmaControls.d0",\r\nFT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_d1,\r\n{ "Volume", "usbaudio.ac_if_fu.bmaControls.d1",\r\nFT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_d2,\r\n{ "Bass", "usbaudio.ac_if_fu.bmaControls.d2",\r\nFT_BOOLEAN, 8, NULL, 0x04, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_d3,\r\n{ "Mid", "usbaudio.ac_if_fu.bmaControls.d3",\r\nFT_BOOLEAN, 8, NULL, 0x08, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_d4,\r\n{ "Treble", "usbaudio.ac_if_fu.bmaControls.d4",\r\nFT_BOOLEAN, 8, NULL, 0x10, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_d5,\r\n{ "Graphic Equalizer", "usbaudio.ac_if_fu.bmaControls.d5",\r\nFT_BOOLEAN, 8, NULL, 0x20, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_d6,\r\n{ "Automatic Gain", "usbaudio.ac_if_fu.bmaControls.d6",\r\nFT_BOOLEAN, 8, NULL, 0x40, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_d7,\r\n{ "Delay", "usbaudio.ac_if_fu.bmaControls.d7",\r\nFT_BOOLEAN, 8, NULL, 0x80, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_d8,\r\n{ "Bass Boost", "usbaudio.ac_if_fu.bmaControls.d8",\r\nFT_BOOLEAN, 8, NULL, 0x01, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_d9,\r\n{ "Loudness", "usbaudio.ac_if_fu.bmaControls.d9",\r\nFT_BOOLEAN, 8, NULL, 0x02, NULL, HFILL }},\r\n{ &hf_ac_if_fu_controls_rsv,\r\n{ "Reserved", "usbaudio.ac_if_fu.bmaControls.rsv",\r\nFT_UINT8, BASE_HEX, NULL, 0xFC, "Must be zero", HFILL }},\r\n{ &hf_ac_if_fu_ifeature,\r\n{ "Feature", "usbaudio.ac_if_fu.iFeature",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "iFeature", HFILL }},\r\n{ &hf_ac_if_mu_unitid,\r\n{ "Unit ID", "usbaudio.ac_if_mu.bUnitID",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bUnitID", HFILL }},\r\n{ &hf_ac_if_mu_nrinpins,\r\n{ "Number In Pins", "usbaudio.ac_if_mu.bNrInPins",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bNrInPins", HFILL }},\r\n{ &hf_ac_if_mu_sourceid,\r\n{ "Source ID", "usbaudio.ac_if_mu.baSourceID",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "baSourceID", HFILL }},\r\n{ &hf_ac_if_mu_nrchannels,\r\n{ "Number Channels", "usbaudio.ac_if_mu.bNrChannels",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bNrChannels", HFILL }},\r\n{ &hf_ac_if_mu_channelconfig,\r\n{ "Channel Config", "usbaudio.ac_if_mu.wChannelConfig",\r\nFT_UINT16, BASE_HEX, NULL, 0x00, "wChannelConfig", HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d0,\r\n{ "Left Front", "usbaudio.ac_if_mu.wChannelConfig.d0",\r\nFT_BOOLEAN, 16, NULL, 0x0001, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d1,\r\n{ "Right Front", "usbaudio.ac_if_mu.wChannelConfig.d1",\r\nFT_BOOLEAN, 16, NULL, 0x0002, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d2,\r\n{ "Center Front", "usbaudio.ac_if_mu.wChannelConfig.d2",\r\nFT_BOOLEAN, 16, NULL, 0x0004, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d3,\r\n{ "Low Frequency Enhancement", "usbaudio.ac_if_mu.wChannelConfig.d3",\r\nFT_BOOLEAN, 16, NULL, 0x0008, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d4,\r\n{ "Left Surround", "usbaudio.ac_if_mu.wChannelConfig.d4",\r\nFT_BOOLEAN, 16, NULL, 0x0010, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d5,\r\n{ "Right Surround", "usbaudio.ac_if_mu.wChannelConfig.d5",\r\nFT_BOOLEAN, 16, NULL, 0x0020, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d6,\r\n{ "Left of Center", "usbaudio.ac_if_mu.wChannelConfig.d6",\r\nFT_BOOLEAN, 16, NULL, 0x0040, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d7,\r\n{ "Right of Center", "usbaudio.ac_if_mu.wChannelConfig.d7",\r\nFT_BOOLEAN, 16, NULL, 0x0080, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d8,\r\n{ "Surround", "usbaudio.ac_if_mu.wChannelConfig.d8",\r\nFT_BOOLEAN, 16, NULL, 0x0100, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d9,\r\n{ "Side Left", "usbaudio.ac_if_mu.wChannelConfig.d9",\r\nFT_BOOLEAN, 16, NULL, 0x0200, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d10,\r\n{ "Side Right", "usbaudio.ac_if_mu.wChannelConfig.d10",\r\nFT_BOOLEAN, 16, NULL, 0x0400, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_d11,\r\n{ "Top", "usbaudio.ac_if_mu.wChannelConfig.d11",\r\nFT_BOOLEAN, 16, NULL, 0x0800, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelconfig_rsv,\r\n{ "Reserved", "usbaudio.ac_if_mu.wChannelConfig.rsv",\r\nFT_UINT16, BASE_HEX, NULL, 0xF000, NULL, HFILL }},\r\n{ &hf_ac_if_mu_channelnames,\r\n{ "Channel Names", "usbaudio.ac_if_mu.iChannelNames",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "iChannelNames", HFILL }},\r\n{ &hf_ac_if_mu_controls,\r\n{ "Controls", "usbaudio.ac_if_mu.bmControls",\r\nFT_UINT8, BASE_HEX, NULL, 0x00, "bmControls", HFILL }},\r\n{ &hf_ac_if_mu_imixer,\r\n{ "Mixer", "usbaudio.ac_if_mu.iMixer",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "iMixer", HFILL }},\r\n{ &hf_as_if_desc_subtype,\r\n{ "Subtype", "usbaudio.as_if_subtype", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\r\n&as_subtype_vals_ext, 0x00, "bDescriptorSubtype", HFILL }},\r\n{ &hf_as_if_gen_term_id,\r\n{ "Terminal ID", "usbaudio.as_if_gen.bTerminalLink",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bTerminalLink", HFILL }},\r\n{ &hf_as_if_gen_delay,\r\n{ "Interface delay in frames", "usbaudio.as_if_gen.bDelay",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bDelay", HFILL }},\r\n{ &hf_as_if_gen_format,\r\n{ "Format", "usbaudio.as_if_gen.wFormatTag",\r\nFT_UINT16, BASE_HEX, NULL, 0x00, "wFormatTag", HFILL }},\r\n{ &hf_as_if_ft_formattype,\r\n{ "FormatType", "usbaudio.as_if_ft.bFormatType",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "wFormatType", HFILL }},\r\n{ &hf_as_if_ft_maxbitrate,\r\n{ "Max Bit Rate", "usbaudio.as_if_ft.wMaxBitRate",\r\nFT_UINT16, BASE_DEC, NULL, 0x00, "wMaxBitRate", HFILL }},\r\n{ &hf_as_if_ft_nrchannels,\r\n{ "Number Channels", "usbaudio.as_if_ft.bNrChannels",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bNrChannels", HFILL }},\r\n{ &hf_as_if_ft_subframesize,\r\n{ "Subframe Size", "usbaudio.as_if_ft.bSubframeSize",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bSubframeSize", HFILL }},\r\n{ &hf_as_if_ft_bitresolution,\r\n{ "Bit Resolution", "usbaudio.as_if_ft.bBitResolution",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bBitResolution", HFILL }},\r\n{ &hf_as_if_ft_samplesperframe,\r\n{ "Samples Per Frame", "usbaudio.as_if_ft.wSamplesPerFrame",\r\nFT_UINT16, BASE_DEC, NULL, 0x00, "wSamplesPerFrame", HFILL }},\r\n{ &hf_as_if_ft_samfreqtype,\r\n{ "Samples Frequence Type", "usbaudio.as_if_ft.bSamFreqType",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, "bSamFreqType", HFILL }},\r\n{ &hf_as_if_ft_lowersamfreq,\r\n{ "Lower Samples Frequence", "usbaudio.as_if_ft.tLowerSamFreq",\r\nFT_UINT24, BASE_DEC, NULL, 0x00, "tLowerSamFreq", HFILL }},\r\n{ &hf_as_if_ft_uppersamfreq,\r\n{ "Upper Samples Frequence", "usbaudio.as_if_ft.tUpperSamFreq",\r\nFT_UINT24, BASE_DEC, NULL, 0x00, "tUpperSamFreq", HFILL }},\r\n{ &hf_as_if_ft_samfreq,\r\n{ "Samples Frequence", "usbaudio.as_if_ft.tSamFreq",\r\nFT_UINT24, BASE_DEC, NULL, 0x00, "tSamFreq", HFILL }},\r\n{ &hf_as_ep_desc_subtype,\r\n{ "Subtype", "usbaudio.as_ep_subtype", FT_UINT8,\r\nBASE_HEX, NULL, 0x00, "bDescriptorSubtype", HFILL }},\r\n{ &hf_sysex_msg_fragments,\r\n{ "Message fragments", "usbaudio.sysex.fragments",\r\nFT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_fragment,\r\n{ "Message fragment", "usbaudio.sysex.fragment",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_fragment_overlap,\r\n{ "Message fragment overlap", "usbaudio.sysex.fragment.overlap",\r\nFT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_fragment_overlap_conflicts,\r\n{ "Message fragment overlapping with conflicting data",\r\n"usbaudio.sysex.fragment.overlap.conflicts",\r\nFT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_fragment_multiple_tails,\r\n{ "Message has multiple tail fragments",\r\n"usbaudio.sysex.fragment.multiple_tails",\r\nFT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_fragment_too_long_fragment,\r\n{ "Message fragment too long", "usbaudio.sysex.fragment.too_long_fragment",\r\nFT_BOOLEAN, 0, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_fragment_error,\r\n{ "Message defragmentation error", "usbaudio.sysex.fragment.error",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_fragment_count,\r\n{ "Message fragment count", "usbaudio.sysex.fragment.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_reassembled_in,\r\n{ "Reassembled in", "usbaudio.sysex.reassembled.in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_reassembled_length,\r\n{ "Reassembled length", "usbaudio.sysex.reassembled.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_sysex_msg_reassembled_data,\r\n{ "Reassembled data", "usbaudio.sysex.reassembled.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }}\r\n};\r\nstatic gint *usb_audio_subtrees[] = {\r\n&ett_usb_audio,\r\n&ett_usb_audio_desc,\r\n&ett_sysex_msg_fragment,\r\n&ett_sysex_msg_fragments,\r\n&ett_ac_if_fu_controls,\r\n&ett_ac_if_fu_controls0,\r\n&ett_ac_if_fu_controls1,\r\n&ett_ac_if_input_channelconfig,\r\n&ett_ac_if_mu_channelconfig\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_usb_audio_undecoded, { "usbaudio.undecoded", PI_UNDECODED, PI_WARN, "Not dissected yet (report to wireshark.org)", EXPFILL }},\r\n};\r\nexpert_module_t *expert_usb_audio;\r\nproto_usb_audio = proto_register_protocol("USB Audio", "USBAUDIO", "usbaudio");\r\nproto_register_field_array(proto_usb_audio, hf, array_length(hf));\r\nproto_register_subtree_array(usb_audio_subtrees, array_length(usb_audio_subtrees));\r\nexpert_usb_audio = expert_register_protocol(proto_usb_audio);\r\nexpert_register_field_array(expert_usb_audio, ei, array_length(ei));\r\nregister_init_routine(&midi_data_reassemble_init);\r\nregister_cleanup_routine(&midi_data_reassemble_cleanup);\r\nregister_dissector("usbaudio", dissect_usb_audio_bulk, proto_usb_audio);\r\n}\r\nvoid\r\nproto_reg_handoff_usb_audio(void)\r\n{\r\ndissector_handle_t usb_audio_bulk_handle, usb_audio_descr_handle;\r\nusb_audio_descr_handle = create_dissector_handle(\r\ndissect_usb_audio_descriptor, proto_usb_audio);\r\ndissector_add_uint("usb.descriptor", IF_CLASS_AUDIO, usb_audio_descr_handle);\r\nusb_audio_bulk_handle = find_dissector("usbaudio");\r\ndissector_add_uint("usb.bulk", IF_CLASS_AUDIO, usb_audio_bulk_handle);\r\nsysex_handle = find_dissector_add_dependency("sysex", proto_usb_audio);\r\n}
