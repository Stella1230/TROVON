int dispatcher_debug(int level, const char* fmt, ...) {\r\nva_list ap;\r\nchar* str;\r\nif (debug_lvl<level) return 1;\r\nva_start(ap, fmt);\r\nstr = g_strdup_vprintf(fmt,ap);\r\nva_end(ap);\r\nif (dispatcher) {\r\nfprintf(debug_fp, "dispatcher[%d]: reqh_id=%d dbg_level=%d message='%s'\n", dispatcher->pid, dispatcher->reqh_id, level, str);\r\n} else {\r\nfprintf(debug_fp, "dispatcher: dbg_level=%d message='%s'\n", level, str);\r\n}\r\nfflush(debug_fp);\r\ng_free(str);\r\nreturn 1;\r\n}\r\nstatic char* param_get_dbg_level(char** err _U_) {\r\nreturn g_strdup_printf("%d",debug_lvl);\r\n}\r\nstatic echld_bool_t param_set_dbg_level(char* val , char** err ) {\r\nchar* p;\r\nint lvl = (int)strtol(val, &p, 10);\r\nif (p<=val) {\r\n*err = g_strdup("not an integer");\r\nreturn FALSE;\r\n} else if (lvl < 0 || lvl > 5) {\r\n*err = g_strdup_printf("invalid level=%d (min=0 max=5)",lvl);\r\nreturn FALSE;\r\n}\r\ndebug_lvl = lvl;\r\nDCOM();\r\nreturn TRUE;\r\n}\r\nstatic void init_stuff(void) {\r\n#ifdef HAVE_LIBPCAP\r\ncapture_opts_init(&stuff.cap_opts);\r\ncapture_session_init(&stuff.cap_sess, &stuff.cfile);\r\n#endif\r\n}\r\nstatic void children_massacre(void) {\r\nint i;\r\nstruct dispatcher_child* cc = dispatcher->children;\r\nint max_children = dispatcher->max_children;\r\nfor(i = 0; i < max_children; i++) {\r\nstruct dispatcher_child* c = &(cc[i]);\r\nif (c->pid > 0) {\r\nDISP_DBG((0,"killing ch=%d pid=%d",c->chld_id,c->pid));\r\nkill(c->pid,SIGTERM);\r\n}\r\n}\r\n}\r\nstatic void dispatcher_fatal(int cause, const char* fmt, ...) {\r\nsize_t len= 1024;\r\ngchar err_str[len];\r\nva_list ap;\r\nva_start(ap, fmt);\r\ng_vsnprintf(err_str,len,fmt,ap);\r\nva_end(ap);\r\nDISP_DBG((0,"fatal cause=%d msg=\"%s\"",cause ,err_str));\r\nchildren_massacre();\r\nexit(cause);\r\n}\r\nstatic void dispatcher_err(int errnum, const char* fmt, ...) {\r\nsize_t len= 1024;\r\ngchar err_str[len];\r\nva_list ap;\r\nstatic GByteArray* ba;\r\nva_start(ap, fmt);\r\ng_vsnprintf(err_str,len,fmt,ap);\r\nva_end(ap);\r\nDISP_DBG((0,"error=\"%s\"",err_str));\r\nba = dispatcher->enc.to_parent->error(errnum, err_str);\r\nDISP_RESP(ba,ECHLD_ERROR);\r\ng_byte_array_free(ba,TRUE);\r\n}\r\nstatic char* intflist2json(GList* if_list, char** if_cap_err) {\r\n#define ADDRSTRLEN 46\r\nGList *if_entry;\r\nif_info_t *if_info;\r\nGSList *addr;\r\nif_addr_t *if_addr;\r\nif_capabilities_t *caps;\r\nchar addr_str[ADDRSTRLEN];\r\nGString *str = g_string_new("{ what='interfaces', interfaces={ \n");\r\nfor (if_entry = g_list_first(if_list); if_entry != NULL;\r\nif_entry = g_list_next(if_entry)) {\r\nif_info = (if_info_t *)if_entry->data;\r\ng_string_append_printf(str," %s={ intf='%s',", if_info->name, if_info->name);\r\nif (if_info->vendor_description != NULL)\r\ng_string_append_printf(str," vnd_desc='%s',", if_info->vendor_description);\r\nif (if_info->friendly_name != NULL)\r\ng_string_append_printf(str," name='%s', addrs=[ ", if_info->friendly_name);\r\nfor (addr = g_slist_nth(if_info->addrs, 0); addr != NULL;\r\naddr = g_slist_next(addr)) {\r\nif_addr = (if_addr_t *)addr->data;\r\nswitch(if_addr->ifat_type) {\r\ncase IF_AT_IPv4:\r\nif (inet_ntop(AF_INET, &if_addr->addr.ip4_addr, addr_str,\r\nADDRSTRLEN)) {\r\ng_string_append_printf(str,"'%s',", addr_str);\r\n} else {\r\ng_string_append(str,"'<unknown IPv4>',");\r\n}\r\nbreak;\r\ncase IF_AT_IPv6:\r\nif (inet_ntop(AF_INET6, &if_addr->addr.ip6_addr,\r\naddr_str, ADDRSTRLEN)) {\r\ng_string_append_printf(str,"'%s',", addr_str);\r\n} else {\r\ng_string_append(str,"'<unknown IPv6>',");\r\n}\r\nbreak;\r\ndefault:\r\ng_string_append_printf(str,"'<type unknown %u>',", if_addr->ifat_type);\r\n}\r\n}\r\ng_string_truncate(str,str->len - 1);\r\ng_string_append(str," ]");\r\nif (if_info->loopback)\r\ng_string_append(str,", loopback=1");\r\nelse\r\ng_string_append(str,", loopback=0");\r\ncaps = capture_get_if_capabilities(if_info->name, 0, NULL, if_cap_err, NULL);\r\nif (caps != NULL) {\r\nif (caps->data_link_types != NULL) {\r\nGList* lt_entry = caps->data_link_types;\r\ndata_link_info_t *data_link_info;\r\ng_string_append(str,", data_link_types=[");\r\nfor (; lt_entry != NULL; lt_entry = g_list_next(lt_entry) ) {\r\ndata_link_info = (data_link_info_t *)lt_entry->data;\r\ng_string_append_printf(str,"{ name='%s', desc='%s' }, ", data_link_info->name, (data_link_info->description) ? data_link_info->description : "" );\r\n}\r\ng_string_truncate(str,str->len - 2);\r\ng_string_append(str,"]");\r\n}\r\ng_string_append_printf(str,", can_set_rfmon=%s", caps->can_set_rfmon ? "1" : "0");\r\nif (caps->can_set_rfmon) {\r\nfree_if_capabilities(caps);\r\ncaps = capture_get_if_capabilities(if_info->name, 1, NULL, if_cap_err, NULL);\r\nif (caps->data_link_types != NULL) {\r\nGList* lt_entry = caps->data_link_types;\r\ndata_link_info_t *data_link_info;\r\ng_string_append(str,", data_link_types_rfmon=[");\r\nfor (; lt_entry != NULL; lt_entry = g_list_next(lt_entry)) {\r\ndata_link_info = (data_link_info_t *)lt_entry->data;\r\ng_string_append_printf(str,"{ name='%s', desc='%s' }, ", data_link_info->name, (data_link_info->description) ? data_link_info->description : "" );\r\n}\r\ng_string_truncate(str,str->len - 2);\r\ng_string_append(str,"]");\r\n}\r\n}\r\nfree_if_capabilities(caps);\r\n}\r\ng_string_append(str,"},\n");\r\n}\r\ng_string_truncate(str,str->len - 2);\r\ng_string_append(str,"}");\r\nreturn g_string_free(str,FALSE);\r\n}\r\nstatic void get_interfaces(char** err) {\r\nint err_no = 0;\r\nGList* if_list;\r\nerr = NULL;\r\nif_list = capture_interface_list(&err_no, err, NULL);\r\nif (err) {\r\nDISP_DBG((1,"Could not get capture interface list: %s",err));\r\n} else {\r\nintf_list = intflist2json(if_list,err);\r\nif (err) {\r\nDISP_DBG((1,"get capabilities error: %s",err));\r\n}\r\n}\r\nfree_interface_list(if_list);\r\n}\r\nstatic char* param_get_interfaces(char** err _U_) {\r\nreturn g_strdup(intf_list ? intf_list : "");\r\n}\r\nstatic char* param_get_loop_timeout(char** err _U_) {\r\nreturn g_strdup_printf("%fs", (((float)disp_loop_timeout_usec)/1000000.0) );\r\n}\r\nstatic echld_bool_t param_set_loop_timeout(char* val , char** err ) {\r\nchar* p;\r\nint usec = (int)strtol(val, &p, 10);\r\nif (p<=val) {\r\n*err = g_strdup("not an integer");\r\nreturn FALSE;\r\n}\r\ndisp_loop_timeout_usec = usec;\r\nreturn TRUE;\r\n}\r\nstatic char* param_get_long_version(char** err _U_) {\r\nreturn g_strdup(version_long_str);\r\n}\r\nstatic char* param_get_version(char** err _U_) {\r\nreturn g_strdup(version_str);\r\n}\r\nstatic char* param_get_capture_types(char** err _U_) {\r\nGString* str = g_string_new("");\r\nint i;\r\nfor (i = 0; i < WTAP_NUM_FILE_TYPES_SUBTYPES; i++) {\r\nif (wtap_dump_can_open(i)) {\r\ng_string_append_printf(str,"%s: %s\n",\r\nwtap_file_type_subtype_short_string(i), wtap_file_type_subtype_string(i));\r\n}\r\n}\r\nreturn g_string_free(str,FALSE);\r\n}\r\nstatic echld_bool_t param_set_add_hosts_file(char* val, char** err) {\r\nif (add_hosts_file(val)) {\r\nreturn TRUE;\r\n} else {\r\n*err = g_strdup_printf("Can't read host entries from \"%s\"",val);\r\nreturn FALSE;\r\n}\r\n}\r\nstatic echld_bool_t param_set_x_opt(char* val, char** err) {\r\nif (ex_opt_add(val)) {\r\nreturn TRUE;\r\n} else {\r\n*err = g_strdup_printf("Cannot set X opt '%s'",val);\r\nreturn FALSE;\r\n}\r\n}\r\nstatic char* param_get_params(char** err _U_) {\r\nreturn paramset_get_params_list(disp_params,PARAM_LIST_FMT);\r\n}\r\nstatic struct dispatcher_child* dispatcher_get_child(struct dispatcher* d, int chld_id) {\r\nint i;\r\nstruct dispatcher_child* cc = d->children;\r\nint max_children = d->max_children;\r\nfor(i = 0; i < max_children; i++) {\r\nstruct dispatcher_child* c = &(cc[i]);\r\nif (c->chld_id == chld_id) return c;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void dispatcher_clear_child(struct dispatcher_child* c) {\r\nechld_reset_reader(&(c->reader), -1, 4096);\r\nc->chld_id = -1;\r\nc->state = FREE;\r\nc->reader.fd = -1;\r\nc->write_fd = -1;\r\nc->pid = -1;\r\nc->reqh_id = -1;\r\nc->closing = FALSE;\r\n}\r\nstatic void set_dumpcap_pid(int pid) {\r\ndispatcher->dumpcap_pid = pid;\r\n}\r\nstatic void dispatcher_clear(void) {\r\nDISP_DBG((2,"dispatcher_clear"));\r\n}\r\nvoid dispatcher_sig(int sig) {\r\nDISP_FATAL((TERMINATED,"SIG sig=%d",sig));\r\nexit(1);\r\n}\r\nvoid dispatcher_reaper(int sig) {\r\nint status;\r\nint i;\r\nstruct dispatcher_child* cc = dispatcher->children;\r\nint max_children = dispatcher->max_children;\r\nint pid = waitpid(-1, &status, WNOHANG);\r\nint reqh_id_save = dispatcher->reqh_id;\r\ndispatcher->reqh_id = 0;\r\nif (sig != SIGCHLD) {\r\nDISP_DBG((1,"Reaper got wrong signal=%d",sig));\r\ndispatcher->reqh_id = reqh_id_save;\r\nreturn;\r\n}\r\nDISP_DBG((2,"Child dead pid=%d",pid));\r\nfor(i = 0; i < max_children; i++) {\r\nstruct dispatcher_child* c = &(cc[i]);\r\nif ( c->pid == pid ) {\r\nif (c->closing || dispatcher->closing) {\r\nDISP_WRITE(dispatcher->parent_out, NULL, c->chld_id, ECHLD_CLOSING, c->reqh_id);\r\n} else {\r\nchar* s = NULL;\r\nGByteArray* em;\r\nif (WIFEXITED(status)) {\r\ns = g_strdup_printf(\r\n"Unexpected dead: reason='exited' pid=%d status=%d",\r\npid, WEXITSTATUS(status));\r\n} else if ( WIFSIGNALED(status) ) {\r\ns = g_strdup_printf(\r\n"Unexpected dead: reason='signaled' pid=%d termsig=%d coredump=%s",\r\npid, WTERMSIG(status), WCOREDUMP(status) ? "yes":"no");\r\n} else if (WIFSTOPPED(status)) {\r\ns = g_strdup_printf(\r\n"Unexpected dead: reason='stopped' pid=%d stopsig=%d",\r\npid, WSTOPSIG(status));\r\n}\r\nem = dispatcher->enc.to_parent->child_dead(s);\r\ndispatcher_err(ECHLD_ERR_CRASHED_CHILD, s);\r\nif (s) g_free(s);\r\nDISP_WRITE(dispatcher->parent_out, em, c->chld_id, ECHLD_CHILD_DEAD, 0);\r\nif (em) g_byte_array_free(em,TRUE);\r\n}\r\nCHLD_SET_STATE(c,CLOSED);\r\ndispatcher_clear_child(c);\r\ndispatcher->reqh_id = reqh_id_save;\r\nreturn;\r\n}\r\n}\r\nif (pid == dispatcher->dumpcap_pid) {\r\ndispatcher->dumpcap_pid = 0;\r\ndispatcher->reqh_id = reqh_id_save;\r\nDISP_DBG((2,"dumpcap dead pid=%d",pid));\r\nreturn;\r\n}\r\ndispatcher_err(ECHLD_ERR_UNKNOWN_PID, "Unknown child pid: %d", pid);\r\ndispatcher->reqh_id = reqh_id_save;\r\n}\r\nstatic void dispatcher_destroy(void) {\r\ndispatcher->closing = TRUE;\r\nchildren_massacre();\r\nexit(0);\r\n}\r\nstatic long dispatch_to_parent(guint8* b, size_t len, echld_chld_id_t chld_id, echld_msg_type_t type, echld_reqh_id_t reqh_id, void* data) {\r\nGByteArray in_ba;\r\nstruct dispatcher_child* c = (struct dispatcher_child*)data;\r\ndispatcher->reqh_id = c->reqh_id = reqh_id;\r\nin_ba.data = b;\r\nin_ba.len = (guint)len;\r\nif (chld_id != c->chld_id) {\r\ngoto misbehabing;\r\n}\r\nswitch(type) {\r\ncase ECHLD_ERROR: break;\r\ncase ECHLD_TIMED_OUT: break;\r\ncase ECHLD_HELLO: CHLD_SET_STATE(c,IDLE); break;\r\ncase ECHLD_CLOSING:\r\nc->closing = TRUE;\r\nCHLD_SET_STATE(c,CLOSING);\r\nbreak;\r\ncase ECHLD_PARAM: break;\r\ncase ECHLD_PONG: break;\r\ncase ECHLD_FILE_OPENED: CHLD_SET_STATE(c,READING); break;\r\ncase ECHLD_INTERFACE_OPENED: CHLD_SET_STATE(c,READY); break;\r\ncase ECHLD_CAPTURE_STARTED: CHLD_SET_STATE(c,CAPTURING); break;\r\ncase ECHLD_NOTIFY: break;\r\ncase ECHLD_PACKET_SUM: break;\r\ncase ECHLD_TREE: break;\r\ncase ECHLD_BUFFER: break;\r\ncase ECHLD_EOF:\r\ncase ECHLD_CAPTURE_STOPPED: CHLD_SET_STATE(c,DONE); break;\r\ncase ECHLD_NOTE_ADDED: break;\r\ncase ECHLD_PACKET_LIST: break;\r\ncase ECHLD_FILE_SAVED: break;\r\ndefault:\r\ngoto misbehabing;\r\n}\r\nDISP_DBG((4,"Dispatching to parent reqh_id=%d chld_id=%d type='%c'",reqh_id,c->chld_id,type));\r\nreturn DISP_WRITE(dispatcher->parent_out, &in_ba, chld_id, type, reqh_id);\r\nmisbehabing:\r\nCHLD_SET_STATE(c,ERRORED);\r\nc->closing = TRUE;\r\nkill(c->pid,SIGTERM);\r\ndispatcher_err(ECHLD_ERR_CRASHED_CHILD,"chld_id=%d",chld_id);\r\nreturn 0;\r\n}\r\nstatic void detach_new_child(enc_msg_t* em, echld_chld_id_t chld_id) {\r\nstruct dispatcher_child* c;\r\nint reqh_id = dispatcher->reqh_id;\r\nint pid;\r\nif (( c = dispatcher_get_child(dispatcher, chld_id) )) {\r\ndispatcher_err(ECHLD_ERR_CHILD_EXISTS,"chld_id=%d exists already while creating new child",chld_id);\r\nreturn;\r\n} else if (( c = dispatcher_get_child(dispatcher, -1) )) {\r\nint disp_pipe_fds[2];\r\nint child_pipe_fds[2];\r\nint pipe_to_disp;\r\nint pipe_from_disp;\r\nint pipe_to_child;\r\nint pipe_from_child;\r\nDISP_DBG((5,"new_child pipe(dispatcher)"));\r\nif( pipe(disp_pipe_fds) < 0) {\r\ndispatcher_err(ECHLD_ERR_CANNOT_FORK,"CANNOT OPEN PARENT PIPE: %s",g_strerror(errno));\r\nreturn;\r\n}\r\npipe_from_disp = disp_pipe_fds[0];\r\npipe_to_child = disp_pipe_fds[1];\r\nDISP_DBG((5,"new_child pipe(child)"));\r\nif( pipe(child_pipe_fds) < 0) {\r\nclose(pipe_from_disp);\r\nclose(pipe_to_child);\r\ndispatcher_err(ECHLD_ERR_CANNOT_FORK,"CANNOT OPEN CHILD PIPE: %s",g_strerror(errno));\r\nreturn;\r\n}\r\npipe_from_child = child_pipe_fds[0];\r\npipe_to_disp = child_pipe_fds[1];\r\nDISP_DBG((4,"New Child Forking()"));\r\nswitch (( pid = fork() )) {\r\ncase -1: {\r\nclose(pipe_to_child);\r\nclose(pipe_to_disp);\r\nclose(pipe_from_child);\r\nclose(pipe_from_disp);\r\ndispatcher_err(ECHLD_ERR_CANNOT_FORK,"CANNOT FORK: %s",g_strerror(errno));\r\nreturn;\r\n}\r\ncase 0: {\r\ndispatcher_clear();\r\nclose(pipe_to_child);\r\nclose(pipe_from_child);\r\nechld_child_initialize(chld_id, pipe_from_disp,pipe_to_disp,reqh_id,&stuff);\r\nexit( echld_child_loop() );\r\nreturn;\r\n}\r\ndefault: {\r\nclose(pipe_to_disp);\r\nclose(pipe_from_disp);\r\nechld_reset_reader(&(c->reader), pipe_from_child,4096);\r\nc->write_fd = pipe_to_child;\r\nc->pid = pid;\r\nc->chld_id = chld_id;\r\nc->closing = FALSE;\r\nCHLD_SET_STATE(c,CREATING);\r\nDISP_DBG((4,"Child Forked pid=%d chld_id=%d from_fd=%d to_fd=%d",\r\npid, c->chld_id, pipe_from_child, pipe_to_child));\r\nstart_wait_time.tv_sec = (int)(start_wait_time_us / 1000000);\r\nstart_wait_time.tv_usec = (int)(start_wait_time_us % 1000000);\r\nselect(0,NULL,NULL,NULL,&start_wait_time);\r\nDISP_WRITE(pipe_to_child, em, c->chld_id, ECHLD_NEW_CHILD, dispatcher->reqh_id);\r\nreturn;\r\n}\r\n}\r\n} else {\r\ndispatcher_err(ECHLD_ERR_CANNOT_FORK, "MAX CHILDREN REACHED: max_children=%d",dispatcher->max_children);\r\nreturn;\r\n}\r\n}\r\nstatic long dispatch_to_child(guint8* b, size_t len, echld_chld_id_t chld_id, echld_msg_type_t type, echld_reqh_id_t reqh_id, void* data _U_) {\r\nGByteArray in_ba;\r\nin_ba.data = b;\r\nin_ba.len = (guint)len;\r\ndispatcher->reqh_id = reqh_id;\r\nDISP_DBG((1,"RCV<- type='%s' chld_id=%d reqh_id=%d",TY(type),chld_id,reqh_id));\r\nif (chld_id == 0) {\r\nDISP_DBG((2,"Message to Dispatcher"));\r\nswitch(type) {\r\ncase ECHLD_CLOSE_CHILD:\r\ndispatcher_destroy();\r\nreturn 0;\r\ncase ECHLD_PING:\r\nDISP_DBG((2,"PONG reqh_id=%d",reqh_id));\r\nDISP_WRITE(dispatcher->parent_out, NULL, chld_id, ECHLD_PONG, reqh_id);\r\nreturn 0;\r\ncase ECHLD_SET_PARAM:{\r\nchar* param;\r\nchar* value;\r\nif ( dispatcher->dec.from_parent->set_param(b,len,&param,&value) ) {\r\nGByteArray* ba;\r\nchar* err;\r\nif (! paramset_apply_set (disp_params, param, value, &err) ) {\r\ndispatcher_err(ECHLD_CANNOT_SET_PARAM,"%s",err);\r\ng_free(err);\r\nreturn 0;\r\n}\r\nba = dispatcher->enc.to_parent->param(param,value);\r\nDISP_RESP(ba,ECHLD_PARAM);\r\ng_byte_array_free(ba,TRUE);\r\nDISP_DBG((1,"Set Param: param='%s' value='%s'",param,value));\r\nreturn 0;\r\n} else {\r\ndispatcher_err(ECHLD_CANNOT_SET_PARAM,"reason='decoder error'");\r\nreturn 0;\r\n}\r\n}\r\ncase ECHLD_GET_PARAM: {\r\nGByteArray* ba;\r\nchar* param;\r\nif ( dispatcher->dec.from_parent->get_param(b,len,&param) ) {\r\nchar* err;\r\nchar* val;\r\nif (! (val = paramset_apply_get (disp_params, param, &err)) ) {\r\ndispatcher_err(ECHLD_CANNOT_GET_PARAM,"%s",err);\r\ng_free(err);\r\nreturn 0;\r\n}\r\nba = dispatcher->enc.to_parent->param(param,val);\r\nDISP_RESP(ba,ECHLD_PARAM);\r\ng_byte_array_free(ba,TRUE);\r\nDISP_DBG((1,"Get Param: param='%s' value='%s'",param,val));\r\nreturn 0;\r\n} else {\r\ndispatcher_err(ECHLD_CANNOT_GET_PARAM,"reason='decoder error'");\r\nreturn 0;\r\n}\r\n}\r\ndefault:\r\ndispatcher_err(ECHLD_ERR_WRONG_MSG, "wrong message to dispatcher type='%c'", type);\r\nreturn 0;\r\n}\r\n} else {\r\nstruct dispatcher_child* c;\r\nDISP_DBG((2,"Parent => Child"));\r\nif (! (c = dispatcher_get_child(dispatcher, chld_id)) ) {\r\nif (type == ECHLD_NEW_CHILD) {\r\ndetach_new_child(&in_ba,chld_id);\r\nreturn 0;\r\n} else {\r\ndispatcher_err(ECHLD_ERR_NO_SUCH_CHILD, "wrong chld_id %d", chld_id);\r\nreturn 0;\r\n}\r\n} else {\r\nswitch(type) {\r\ncase ECHLD_CLOSE_CHILD:\r\nCHLD_SET_STATE(c,CLOSED);\r\ngoto relay_frame;\r\ncase ECHLD_OPEN_FILE:\r\nCHLD_SET_STATE(c,READING);\r\ngoto relay_frame;\r\ncase ECHLD_OPEN_INTERFACE:\r\nCHLD_SET_STATE(c,READY);\r\ngoto relay_frame;\r\ncase ECHLD_START_CAPTURE:\r\nCHLD_SET_STATE(c,CAPTURING);\r\ngoto relay_frame;\r\ncase ECHLD_STOP_CAPTURE:\r\nCHLD_SET_STATE(c,DONE);\r\ngoto relay_frame;\r\ncase ECHLD_SAVE_FILE:\r\ncase ECHLD_APPLY_FILTER:\r\ncase ECHLD_SET_PARAM:\r\ncase ECHLD_GET_PARAM:\r\ncase ECHLD_PING:\r\ncase ECHLD_GET_SUM:\r\ncase ECHLD_GET_TREE:\r\ncase ECHLD_GET_BUFFER:\r\ncase ECHLD_ADD_NOTE:\r\nrelay_frame: {\r\nDISP_DBG((3,"Relay to Child chld_id=%d type='%c' req_id=%d",chld_id, type, reqh_id));\r\nreturn DISP_WRITE(c->write_fd, &in_ba, chld_id, type, reqh_id);\r\n}\r\ndefault:\r\ndispatcher_err(ECHLD_ERR_WRONG_MSG, "wrong message %d %c", reqh_id, type);\r\nreturn 0;\r\n}\r\n}\r\n}\r\n}\r\nint dispatcher_loop(void) {\r\nint parent_out = dispatcher->parent_out;\r\nint parent_in = dispatcher->parent_in.fd;\r\nstruct dispatcher_child* children = dispatcher->children;\r\nDISP_DBG((5,"LOOP in_fd=%d out_fd=%d",parent_in, parent_out));\r\ndo {\r\nfd_set rfds;\r\nfd_set efds;\r\nstruct dispatcher_child* c;\r\nint nfds;\r\nint nchld = 0;\r\nstruct timeval disp_loop_timeout;\r\nFD_ZERO(&rfds);\r\nFD_ZERO(&efds);\r\nFD_SET(parent_in,&rfds);\r\nFD_SET(parent_in,&efds);\r\nFD_SET(parent_out,&efds);\r\nfor (c = children; c->pid; c++) {\r\nif (c->chld_id > 0) {\r\nnchld++;\r\nFD_SET(c->reader.fd, &rfds);\r\nFD_SET(c->reader.fd, &efds);\r\n}\r\n}\r\nDISP_DBG((4,"Select()ing nchld=%d",nchld,disp_loop_timeout.tv_usec));\r\ndisp_loop_timeout.tv_sec = (int)(disp_loop_timeout_usec / 1000000);\r\ndisp_loop_timeout.tv_usec = (int)(disp_loop_timeout_usec % 1000000);\r\nnfds = select(FD_SETSIZE, &rfds, NULL, &efds, &disp_loop_timeout);\r\nDISP_DBG((5,"Select()ed nfds=%d",nchld,nfds));\r\nif (nfds < 0) {\r\nDISP_DBG((1,"select error='%s'",g_strerror(errno) ));\r\ncontinue;\r\n}\r\nif ( FD_ISSET(parent_in, &rfds)) {\r\nlong st = echld_read_frame(&(dispatcher->parent_in), dispatch_to_child, dispatcher);\r\nif (st < 0) {\r\nDISP_DBG((1,"read frame returning < 0 for parent"));\r\ncontinue;\r\n}\r\n}\r\nif ( FD_ISSET(parent_in, &efds) ) {\r\nDISP_DBG((1,"Parent In Pipe Errored!"));\r\ncontinue;\r\n}\r\nif ( FD_ISSET(parent_out, &efds) ) {\r\nDISP_DBG((1,"Parent Out Pipe Errored!"));\r\ncontinue;\r\n}\r\nfor (c=children; c->pid; c++) {\r\nif (c->reader.fd > 0) {\r\nif ( FD_ISSET(c->reader.fd,&efds) ) {\r\nstruct timeval wait_time;\r\nwait_time.tv_sec = 0;\r\nwait_time.tv_usec = DISP_KILLED_CHILD_WAIT;\r\nDISP_DBG((1,"errored child pipe chld_id=%d",c->chld_id));\r\nkill(c->pid,SIGTERM);\r\nselect(0,NULL,NULL,NULL,&wait_time);\r\ndispatcher_clear_child(c);\r\ncontinue;\r\n}\r\nif (FD_ISSET(c->reader.fd,&rfds)) {\r\nlong st = echld_read_frame(&(c->reader), dispatch_to_parent, c);\r\nif (st < 0) {\r\nDISP_DBG((1,"read_frame returned < 0 for chld_id=%d",c->chld_id));\r\ncontinue;\r\n}\r\ncontinue;\r\n}\r\n}\r\n}\r\n} while(1);\r\nreturn 1;\r\n}\r\nvoid dispatcher_alrm(int sig _U_) {\r\nDISP_DBG((1,"ALRM received"));\r\n}
