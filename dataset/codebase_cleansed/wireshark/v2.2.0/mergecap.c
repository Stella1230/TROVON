static void\r\nprint_usage(FILE *output)\r\n{\r\nfprintf(output, "\n");\r\nfprintf(output, "Usage: mergecap [options] -w <outfile>|- <infile> [<infile> ...]\n");\r\nfprintf(output, "\n");\r\nfprintf(output, "Output:\n");\r\nfprintf(output, " -a concatenate rather than merge files.\n");\r\nfprintf(output, " default is to merge based on frame timestamps.\n");\r\nfprintf(output, " -s <snaplen> truncate packets to <snaplen> bytes of data.\n");\r\nfprintf(output, " -w <outfile>|- set the output filename to <outfile> or '-' for stdout.\n");\r\nfprintf(output, " -F <capture type> set the output file type; default is pcapng.\n");\r\nfprintf(output, " an empty \"-F\" option will list the file types.\n");\r\nfprintf(output, " -I <IDB merge mode> set the merge mode for Interface Description Blocks; default is 'all'.\n");\r\nfprintf(output, " an empty \"-I\" option will list the merge modes.\n");\r\nfprintf(output, "\n");\r\nfprintf(output, "Miscellaneous:\n");\r\nfprintf(output, " -h display this help and exit.\n");\r\nfprintf(output, " -v verbose output.\n");\r\n}\r\nstatic void\r\nmergecap_cmdarg_err(const char *fmt, va_list ap)\r\n{\r\nfprintf(stderr, "mergecap: ");\r\nvfprintf(stderr, fmt, ap);\r\nfprintf(stderr, "\n");\r\n}\r\nstatic void\r\nmergecap_cmdarg_err_cont(const char *fmt, va_list ap)\r\n{\r\nvfprintf(stderr, fmt, ap);\r\nfprintf(stderr, "\n");\r\n}\r\nstatic gint\r\nstring_compare(gconstpointer a, gconstpointer b)\r\n{\r\nreturn strcmp(((const struct string_elem *)a)->sstr,\r\n((const struct string_elem *)b)->sstr);\r\n}\r\nstatic void\r\nstring_elem_print(gpointer data, gpointer not_used _U_)\r\n{\r\nfprintf(stderr, " %s - %s\n", ((struct string_elem *)data)->sstr,\r\n((struct string_elem *)data)->lstr);\r\n}\r\nstatic void\r\nfailure_message(const char *msg_format _U_, va_list ap _U_)\r\n{\r\nreturn;\r\n}\r\nstatic void\r\nlist_capture_types(void) {\r\nint i;\r\nstruct string_elem *captypes;\r\nGSList *list = NULL;\r\ncaptypes = g_new(struct string_elem,WTAP_NUM_FILE_TYPES_SUBTYPES);\r\nfprintf(stderr, "mergecap: The available capture file types for the \"-F\" flag are:\n");\r\nfor (i = 0; i < WTAP_NUM_FILE_TYPES_SUBTYPES; i++) {\r\nif (wtap_dump_can_open(i)) {\r\ncaptypes[i].sstr = wtap_file_type_subtype_short_string(i);\r\ncaptypes[i].lstr = wtap_file_type_subtype_string(i);\r\nlist = g_slist_insert_sorted(list, &captypes[i], string_compare);\r\n}\r\n}\r\ng_slist_foreach(list, string_elem_print, NULL);\r\ng_slist_free(list);\r\ng_free(captypes);\r\n}\r\nstatic void\r\nlist_idb_merge_modes(void) {\r\nint i;\r\nfprintf(stderr, "mergecap: The available IDB merge modes for the \"-I\" flag are:\n");\r\nfor (i = 0; i < IDB_MERGE_MODE_MAX; i++) {\r\nfprintf(stderr, " %s\n", merge_idb_merge_mode_to_string(i));\r\n}\r\n}\r\nstatic gboolean\r\nmerge_callback(merge_event event, int num,\r\nconst merge_in_file_t in_files[], const guint in_file_count,\r\nvoid *data _U_)\r\n{\r\nguint i;\r\nswitch (event) {\r\ncase MERGE_EVENT_INPUT_FILES_OPENED:\r\nfor (i = 0; i < in_file_count; i++) {\r\nfprintf(stderr, "mergecap: %s is type %s.\n", in_files[i].filename,\r\nwtap_file_type_subtype_string(wtap_file_type_subtype(in_files[i].wth)));\r\n}\r\nbreak;\r\ncase MERGE_EVENT_FRAME_TYPE_SELECTED:\r\nif (num == WTAP_ENCAP_PER_PACKET) {\r\nint first_frame_type, this_frame_type;\r\nfirst_frame_type = wtap_file_encap(in_files[0].wth);\r\nfor (i = 1; i < in_file_count; i++) {\r\nthis_frame_type = wtap_file_encap(in_files[i].wth);\r\nif (first_frame_type != this_frame_type) {\r\nfprintf(stderr, "mergecap: multiple frame encapsulation types detected\n");\r\nfprintf(stderr, " defaulting to WTAP_ENCAP_PER_PACKET\n");\r\nfprintf(stderr, " %s had type %s (%s)\n",\r\nin_files[0].filename,\r\nwtap_encap_string(first_frame_type),\r\nwtap_encap_short_string(first_frame_type));\r\nfprintf(stderr, " %s had type %s (%s)\n",\r\nin_files[i].filename,\r\nwtap_encap_string(this_frame_type),\r\nwtap_encap_short_string(this_frame_type));\r\nbreak;\r\n}\r\n}\r\n}\r\nfprintf(stderr, "mergecap: selected frame_type %s (%s)\n",\r\nwtap_encap_string(num),\r\nwtap_encap_short_string(num));\r\nbreak;\r\ncase MERGE_EVENT_READY_TO_MERGE:\r\nfprintf(stderr, "mergecap: ready to merge records\n");\r\nbreak;\r\ncase MERGE_EVENT_PACKET_WAS_READ:\r\nfprintf(stderr, "Record: %d\n", num);\r\nbreak;\r\ncase MERGE_EVENT_DONE:\r\nfprintf(stderr, "mergecap: merging complete\n");\r\nbreak;\r\n}\r\nreturn FALSE;\r\n}\r\nint\r\nmain(int argc, char *argv[])\r\n{\r\nGString *comp_info_str;\r\nGString *runtime_info_str;\r\nint opt;\r\nstatic const struct option long_options[] = {\r\n{"help", no_argument, NULL, 'h'},\r\n{"version", no_argument, NULL, 'V'},\r\n{0, 0, 0, 0 }\r\n};\r\ngboolean do_append = FALSE;\r\ngboolean verbose = FALSE;\r\nint in_file_count = 0;\r\nguint snaplen = 0;\r\n#ifdef PCAP_NG_DEFAULT\r\nint file_type = WTAP_FILE_TYPE_SUBTYPE_PCAPNG;\r\n#else\r\nint file_type = WTAP_FILE_TYPE_SUBTYPE_PCAP;\r\n#endif\r\nint out_fd;\r\nint err = 0;\r\ngchar *err_info = NULL;\r\nint err_fileno;\r\nchar *out_filename = NULL;\r\nmerge_result status;\r\nidb_merge_mode mode = IDB_MERGE_MODE_MAX;\r\ngboolean use_stdout = FALSE;\r\nmerge_progress_callback_t cb;\r\n#ifdef HAVE_PLUGINS\r\nchar *init_progfile_dir_error;\r\n#endif\r\ncmdarg_err_init(mergecap_cmdarg_err, mergecap_cmdarg_err_cont);\r\n#ifdef _WIN32\r\narg_list_utf_16to8(argc, argv);\r\ncreate_app_running_mutex();\r\n#endif\r\ncomp_info_str = get_compiled_version_info(NULL, NULL);\r\nruntime_info_str = get_runtime_version_info(NULL);\r\nws_add_crash_info("Mergecap (Wireshark) %s\n"\r\n"\n"\r\n"%s"\r\n"\n"\r\n"%s",\r\nget_ws_vcs_version_info(), comp_info_str->str, runtime_info_str->str);\r\ninit_process_policies();\r\ninit_open_routines();\r\n#ifdef HAVE_PLUGINS\r\nif ((init_progfile_dir_error = init_progfile_dir(argv[0], main))) {\r\ng_warning("mergecap: init_progfile_dir(): %s", init_progfile_dir_error);\r\ng_free(init_progfile_dir_error);\r\n} else {\r\nwtap_register_plugin_types();\r\ninit_report_err(failure_message,NULL,NULL,NULL);\r\nscan_plugins();\r\nregister_all_wiretap_modules();\r\n}\r\n#endif\r\nwhile ((opt = getopt_long(argc, argv, "aF:hI:s:vVw:", long_options, NULL)) != -1) {\r\nswitch (opt) {\r\ncase 'a':\r\ndo_append = !do_append;\r\nbreak;\r\ncase 'F':\r\nfile_type = wtap_short_string_to_file_type_subtype(optarg);\r\nif (file_type < 0) {\r\nfprintf(stderr, "mergecap: \"%s\" isn't a valid capture file type\n",\r\noptarg);\r\nlist_capture_types();\r\nexit(1);\r\n}\r\nbreak;\r\ncase 'h':\r\nprintf("Mergecap (Wireshark) %s\n"\r\n"Merge two or more capture files into one.\n"\r\n"See https://www.wireshark.org for more information.\n",\r\nget_ws_vcs_version_info());\r\nprint_usage(stdout);\r\nexit(0);\r\nbreak;\r\ncase 'I':\r\nmode = merge_string_to_idb_merge_mode(optarg);\r\nif (mode == IDB_MERGE_MODE_MAX) {\r\nfprintf(stderr, "mergecap: \"%s\" isn't a valid IDB merge mode\n",\r\noptarg);\r\nlist_idb_merge_modes();\r\nexit(1);\r\n}\r\nbreak;\r\ncase 's':\r\nsnaplen = get_positive_int(optarg, "snapshot length");\r\nbreak;\r\ncase 'v':\r\nverbose = TRUE;\r\nbreak;\r\ncase 'V':\r\nshow_version("Mergecap (Wireshark)", comp_info_str, runtime_info_str);\r\ng_string_free(comp_info_str, TRUE);\r\ng_string_free(runtime_info_str, TRUE);\r\nexit(0);\r\nbreak;\r\ncase 'w':\r\nout_filename = optarg;\r\nbreak;\r\ncase '?':\r\nswitch(optopt) {\r\ncase'F':\r\nlist_capture_types();\r\nbreak;\r\ncase'I':\r\nlist_idb_merge_modes();\r\nbreak;\r\ndefault:\r\nprint_usage(stderr);\r\n}\r\nexit(1);\r\nbreak;\r\n}\r\n}\r\ncb.callback_func = merge_callback;\r\ncb.data = NULL;\r\nin_file_count = argc - optind;\r\nif (!out_filename) {\r\nfprintf(stderr, "mergecap: an output filename must be set with -w\n");\r\nfprintf(stderr, " run with -h for help\n");\r\nreturn 1;\r\n}\r\nif (in_file_count < 1) {\r\nfprintf(stderr, "mergecap: No input files were specified\n");\r\nreturn 1;\r\n}\r\nif (mode != IDB_MERGE_MODE_MAX && file_type != WTAP_FILE_TYPE_SUBTYPE_PCAPNG) {\r\nfprintf(stderr, "The IDB merge mode can only be used with PCAPNG output format\n");\r\nreturn 1;\r\n}\r\nif (mode == IDB_MERGE_MODE_MAX) {\r\nmode = IDB_MERGE_MODE_ALL_SAME;\r\n}\r\nif (strcmp(out_filename, "-") == 0) {\r\nuse_stdout = TRUE;\r\nout_fd = 1 ;\r\n} else {\r\nout_fd = ws_open(out_filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644);\r\nif (out_fd == -1) {\r\nfprintf(stderr, "mergecap: Couldn't open output file %s: %s\n",\r\nout_filename, g_strerror(errno));\r\nexit(1);\r\n}\r\n}\r\nstatus = merge_files(out_fd, out_filename, file_type,\r\n(const char *const *) &argv[optind], in_file_count,\r\ndo_append, mode, snaplen, "mergecap", verbose ? &cb : NULL,\r\n&err, &err_info, &err_fileno);\r\nswitch (status) {\r\ncase MERGE_OK:\r\nbreak;\r\ncase MERGE_USER_ABORTED:\r\ng_assert(FALSE);\r\nbreak;\r\ncase MERGE_ERR_CANT_OPEN_INFILE:\r\nfprintf(stderr, "mergecap: Can't open %s: %s (%s)\n", argv[optind + err_fileno],\r\nwtap_strerror(err), err_info ? err_info : "no more information");\r\nbreak;\r\ncase MERGE_ERR_CANT_OPEN_OUTFILE:\r\nfprintf(stderr, "mergecap: Can't open or create %s: %s\n", out_filename,\r\nwtap_strerror(err));\r\nif (!use_stdout)\r\nws_close(out_fd);\r\nbreak;\r\ncase MERGE_ERR_CANT_READ_INFILE:\r\ncase MERGE_ERR_BAD_PHDR_INTERFACE_ID:\r\ncase MERGE_ERR_CANT_WRITE_OUTFILE:\r\ncase MERGE_ERR_CANT_CLOSE_OUTFILE:\r\ndefault:\r\nfprintf(stderr, "mergecap: %s\n", err_info ? err_info : "unknown error");\r\nbreak;\r\n}\r\ng_free(err_info);\r\nreturn (status == MERGE_OK) ? 0 : 2;\r\n}
