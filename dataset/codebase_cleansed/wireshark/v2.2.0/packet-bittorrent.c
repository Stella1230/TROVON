static guint\r\nget_bittorrent_pdu_length(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nguint8 type;\r\nguint32 length;\r\nif (tvb_get_guint8(tvb, offset) == 19 &&\r\ntvb_memeql(tvb, offset + 1, "BitTorrent protocol", 19) == 0) {\r\nreturn 1 +\r\n19 +\r\n8 +\r\n20 +\r\n20;\r\n} else {\r\nlength = tvb_get_ntohl(tvb, offset);\r\nif(length == 0) {\r\nreturn BITTORRENT_HEADER_LENGTH;\r\n}\r\nif(tvb_offset_exists(tvb, offset + BITTORRENT_HEADER_LENGTH)) {\r\ntype = tvb_get_guint8(tvb, offset + BITTORRENT_HEADER_LENGTH);\r\nif((type <= BITTORRENT_MESSAGE_PORT || type == BITTORRENT_MESSAGE_EXTENDED) && length<0x1000000) {\r\nreturn BITTORRENT_HEADER_LENGTH + length;\r\n} else {\r\nreturn tvb_reported_length_remaining(tvb, offset);\r\n}\r\n} else {\r\nreturn tvb_reported_length_remaining(tvb, offset);\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_bittorrent_message (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nint offset = 0;\r\nint i;\r\nint isamp = 0;\r\nproto_tree *mtree;\r\nguint16 type = 0;\r\nguint32 typelen = 0;\r\nguint8 prio = 0;\r\nguint32 length;\r\nconst char *msgtype = NULL;\r\nproto_item *ti;\r\nguint32 piece_index, piece_begin, piece_length;\r\nguint32 stringlen;\r\ntvbuff_t *subtvb;\r\nif (tvb_bytes_exist(tvb, offset + BITTORRENT_HEADER_LENGTH, 1)) {\r\nlength = tvb_get_ntohl(tvb, offset);\r\ntype = tvb_get_guint8(tvb, offset + BITTORRENT_HEADER_LENGTH);\r\nif (type==BITTORRENT_MESSAGE_CHOKE && length>4) {\r\nif (!tvb_bytes_exist(tvb, offset + BITTORRENT_HEADER_LENGTH, 4))\r\nreturn;\r\ntypelen = tvb_get_ntohl(tvb, offset + BITTORRENT_HEADER_LENGTH);\r\nif (4+typelen+1<=length) {\r\nif (!tvb_bytes_exist(tvb, offset + BITTORRENT_HEADER_LENGTH + 4, typelen+1))\r\nreturn;\r\nfor ( i=0 ; amp_messages[i].name ; i++ ) {\r\nif (strlen(amp_messages[i].name)==typelen &&\r\ntvb_memeql(tvb, offset + BITTORRENT_HEADER_LENGTH + 4,\r\namp_messages[i].name, (int)strlen(amp_messages[i].name))==0) {\r\nprio = tvb_get_guint8(tvb, offset + BITTORRENT_HEADER_LENGTH + 4 + typelen);\r\nif (prio==0 || prio==1 || prio==2) {\r\ntype = amp_messages[i].value;\r\nisamp = 1;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nmsgtype = try_val_to_str(type, bittorrent_messages);\r\n#if 0\r\nif (msgtype == NULL && isamp) {\r\nmsgtype = try_val_to_str(type, azureus_messages);\r\n}\r\n#endif\r\nif (msgtype == NULL) {\r\nproto_tree_add_item(tree, hf_bittorrent_continuous_data, tvb, offset, -1, ENC_NA);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Continuation data");\r\nreturn;\r\n}\r\n} else {\r\nreturn;\r\n}\r\nif (isamp) {\r\nti = proto_tree_add_item(tree, hf_azureus_msg, tvb, offset, length + BITTORRENT_HEADER_LENGTH, ENC_NA);\r\n} else {\r\nti = proto_tree_add_item(tree, hf_bittorrent_msg, tvb, offset, length + BITTORRENT_HEADER_LENGTH, ENC_NA);\r\n}\r\nmtree = proto_item_add_subtree(ti, ett_bittorrent_msg);\r\nif (length == 0) {\r\nproto_tree_add_item(mtree, hf_bittorrent_msg_len, tvb, offset, BITTORRENT_HEADER_LENGTH, ENC_BIG_ENDIAN);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "KeepAlive");\r\nreturn;\r\n}\r\nproto_tree_add_item(mtree, hf_bittorrent_msg_len, tvb, offset, BITTORRENT_HEADER_LENGTH, ENC_BIG_ENDIAN);\r\noffset += BITTORRENT_HEADER_LENGTH;\r\nif (isamp) {\r\nproto_tree_add_item(mtree, hf_azureus_msg_type_len, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mtree, hf_azureus_msg_type, tvb, offset+4, typelen, ENC_ASCII|ENC_NA);\r\nproto_item_append_text(ti, ": Len %u, %s", length, msgtype);\r\nproto_tree_add_item(mtree, hf_azureus_msg_prio, tvb, offset+4+typelen, 1, ENC_BIG_ENDIAN);\r\noffset += 4+typelen+1;\r\nlength -= 4+typelen+1;\r\n} else {\r\nproto_tree_add_item(mtree, hf_bittorrent_msg_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, ": Len:%u, %s", length, msgtype);\r\noffset += 1;\r\nlength -= 1;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_INFO, msgtype);\r\nswitch (type) {\r\ncase BITTORRENT_MESSAGE_CHOKE:\r\ncase BITTORRENT_MESSAGE_UNCHOKE:\r\ncase BITTORRENT_MESSAGE_INTERESTED:\r\ncase BITTORRENT_MESSAGE_NOT_INTERESTED:\r\nbreak;\r\ncase BITTORRENT_MESSAGE_REQUEST:\r\ncase BITTORRENT_MESSAGE_CANCEL:\r\npiece_index = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(mtree, hf_bittorrent_piece_index, tvb, offset, 4, piece_index); offset += 4;\r\npiece_begin = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(mtree, hf_bittorrent_piece_begin, tvb, offset, 4, piece_begin); offset += 4;\r\npiece_length = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(mtree, hf_bittorrent_piece_length, tvb, offset, 4, piece_length);\r\nproto_item_append_text(ti, ", Piece (Idx:0x%x,Begin:0x%x,Len:0x%x)", piece_index, piece_begin, piece_length);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Piece (Idx:0x%x,Begin:0x%x,Len:0x%x)", piece_index, piece_begin, piece_length);\r\nbreak;\r\ncase BITTORRENT_MESSAGE_PORT:\r\nproto_tree_add_item(mtree, hf_bittorrent_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase BITTORRENT_MESSAGE_EXTENDED:\r\nproto_tree_add_item(mtree, hf_bittorrent_extended, tvb, offset, length, ENC_NA);\r\nbreak;\r\ncase BITTORRENT_MESSAGE_HAVE:\r\npiece_index = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(mtree, hf_bittorrent_piece_index, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, ", Piece (Idx:0x%x)", piece_index);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Piece (Idx:0x%x)", piece_index);\r\nbreak;\r\ncase BITTORRENT_MESSAGE_BITFIELD:\r\nproto_tree_add_item(mtree, hf_bittorrent_bitfield_data, tvb, offset, length, ENC_NA);\r\nproto_item_append_text(ti, ", Len:0x%x", length);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Len:0x%x", length);\r\nbreak;\r\ncase BITTORRENT_MESSAGE_PIECE:\r\npiece_index = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(mtree, hf_bittorrent_piece_index, tvb, offset, 4, piece_index);\r\noffset += 4;\r\nlength -= 4;\r\npiece_begin = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(mtree, hf_bittorrent_piece_begin, tvb, offset, 4, piece_begin);\r\noffset += 4;\r\nlength -= 4;\r\nproto_tree_add_item(mtree, hf_bittorrent_piece_data, tvb, offset, length, ENC_NA);\r\nproto_item_append_text(ti, ", Idx:0x%x,Begin:0x%x,Len:0x%x", piece_index, piece_begin, length);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Idx:0x%x,Begin:0x%x,Len:0x%x", piece_index, piece_begin, length);\r\nbreak;\r\ncase AZUREUS_MESSAGE_HANDSHAKE:\r\ncase AZUREUS_MESSAGE_PEER_EXCHANGE:\r\nsubtvb = tvb_new_subset_length(tvb, offset, length);\r\ncall_dissector(bencode_handle, subtvb, pinfo, mtree);\r\nbreak;\r\ncase AZUREUS_MESSAGE_JPC_HELLO:\r\nstringlen = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(mtree, hf_azureus_jpc_addrlen, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mtree, hf_azureus_jpc_addr, tvb, offset+4, stringlen, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(mtree, hf_azureus_jpc_port, tvb, offset+4+stringlen, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mtree, hf_azureus_jpc_session, tvb, offset+4+stringlen+4, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase AZUREUS_MESSAGE_JPC_REPLY:\r\nproto_tree_add_item(mtree, hf_azureus_jpc_session, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ndissect_bittorrent_welcome (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nint offset = 0;\r\nint i;\r\nchar *version;\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Handshake");\r\nproto_tree_add_item(tree, hf_bittorrent_prot_name_len, tvb, offset, 1, ENC_BIG_ENDIAN); offset+=1;\r\nproto_tree_add_item(tree, hf_bittorrent_prot_name, tvb, offset, 19, ENC_ASCII|ENC_NA); offset += 19;\r\nproto_tree_add_item(tree, hf_bittorrent_reserved, tvb, offset, 8, ENC_NA); offset += 8;\r\nproto_tree_add_item(tree, hf_bittorrent_sha1_hash, tvb, offset, 20, ENC_NA);\r\noffset += 20;\r\nproto_tree_add_item(tree, hf_bittorrent_peer_id, tvb, offset, 20, ENC_NA);\r\nif(decode_client_information) {\r\nfor(i = 0; peer_id[i].name != NULL; ++i)\r\n{\r\nif(tvb_memeql(tvb, offset, peer_id[i].id, (int)strlen(peer_id[i].id)) == 0) {\r\nversion = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + (int)strlen(peer_id[i].id),\r\npeer_id[i].ver_len, ENC_ASCII);\r\nproto_tree_add_string_format(tree, hf_bittorrent_version, tvb, offset, 20, version, "Client is %s v%s",\r\npeer_id[i].name, format_text((guchar*)version, peer_id[i].ver_len));\r\nbreak;\r\n}\r\n}\r\n}\r\noffset += 20;\r\nreturn offset;\r\n}\r\nstatic\r\nint dissect_bittorrent_tcp_pdu (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "BitTorrent");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "BitTorrent ");\r\nti = proto_tree_add_item (tree, proto_bittorrent, tvb, 0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(ti, ett_bittorrent);\r\nif (tvb_get_guint8(tvb, 0) == 19 &&\r\ntvb_memeql(tvb, 1, "BitTorrent protocol", 19) == 0) {\r\ndissect_bittorrent_welcome(tvb, pinfo, tree);\r\n} else {\r\ndissect_bittorrent_message(tvb, pinfo, tree);\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO, " ");\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic\r\nint dissect_bittorrent (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, bittorrent_desegment, BITTORRENT_HEADER_LENGTH,\r\nget_bittorrent_pdu_length, dissect_bittorrent_tcp_pdu, data);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic\r\ngboolean test_bittorrent_packet (tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void *data)\r\n{\r\nconversation_t *conversation;\r\nif (tvb_captured_length(tvb) >= 20 &&\r\ntvb_get_guint8(tvb, 0) == 19 &&\r\ntvb_memeql(tvb, 1, "BitTorrent protocol", 19) == 0) {\r\nconversation = find_or_create_conversation(pinfo);\r\nconversation_set_dissector(conversation, dissector_handle);\r\ndissect_bittorrent(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nvoid\r\nproto_register_bittorrent(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n#if 0\r\n{ &hf_bittorrent_field_length,\r\n{ "Field Length", "bittorrent.length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_bittorrent_prot_name_len,\r\n{ "Protocol Name Length", "bittorrent.protocol.name.length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_prot_name,\r\n{ "Protocol Name", "bittorrent.protocol.name", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_reserved,\r\n{ "Reserved Extension Bytes", "bittorrent.reserved", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_sha1_hash,\r\n{ "SHA1 Hash of info dictionary", "bittorrent.info_hash", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_peer_id,\r\n{ "Peer ID", "bittorrent.peer_id", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_msg,\r\n{ "Message", "bittorrent.msg", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_msg_len,\r\n{ "Message Length", "bittorrent.msg.length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_msg_type,\r\n{ "Message Type", "bittorrent.msg.type", FT_UINT8, BASE_DEC, VALS(bittorrent_messages), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_azureus_msg,\r\n{ "Azureus Message", "bittorrent.azureus_msg", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_azureus_msg_type_len,\r\n{ "Message Type Length", "bittorrent.msg.typelen", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_azureus_msg_type,\r\n{ "Message Type", "bittorrent.msg.aztype", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_azureus_msg_prio,\r\n{ "Message Priority", "bittorrent.msg.prio", FT_UINT8, BASE_DEC, VALS(azureus_priorities), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_bitfield_data,\r\n{ "Bitfield data", "bittorrent.msg.bitfield", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_piece_index,\r\n{ "Piece index", "bittorrent.piece.index", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_piece_begin,\r\n{ "Begin offset of piece", "bittorrent.piece.begin", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_piece_data,\r\n{ "Data in a piece", "bittorrent.piece.data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_piece_length,\r\n{ "Piece Length", "bittorrent.piece.length", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_azureus_jpc_addrlen,\r\n{ "Cache Address Length", "bittorrent.jpc.addr.length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_azureus_jpc_addr,\r\n{ "Cache Address", "bittorrent.jpc.addr", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_azureus_jpc_port,\r\n{ "Port", "bittorrent.jpc.port", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_azureus_jpc_session,\r\n{ "Session ID", "bittorrent.jpc.session", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_port,\r\n{ "Port", "bittorrent.port", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_extended,\r\n{ "Extended Message", "bittorrent.extended", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_continuous_data,\r\n{ "Extended Message", "bittorrent.continuous_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_bittorrent_version,\r\n{ "Client version", "bittorrent.version", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_bittorrent,\r\n&ett_bittorrent_msg,\r\n&ett_peer_id,\r\n};\r\nmodule_t *bittorrent_module;\r\nproto_bittorrent = proto_register_protocol("BitTorrent", "BitTorrent", "bittorrent");\r\nproto_register_field_array(proto_bittorrent, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("bittorrent.tcp", dissect_bittorrent, proto_bittorrent);\r\nbittorrent_module = prefs_register_protocol(proto_bittorrent, NULL);\r\nprefs_register_bool_preference(bittorrent_module, "desegment",\r\n"Reassemble BitTorrent messages spanning multiple TCP segments",\r\n"Whether the BitTorrent dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&bittorrent_desegment);\r\nprefs_register_bool_preference(bittorrent_module, "decode_client",\r\n"Decode the peer_id of the handshake messages",\r\n"Enabling this will tell which BitTorrent client that produced the handshake message",\r\n&decode_client_information);\r\n}\r\nvoid\r\nproto_reg_handoff_bittorrent(void)\r\n{\r\nbencode_handle = find_dissector_add_dependency("bencode", proto_bittorrent);\r\ndissector_handle = find_dissector("bittorrent.tcp");\r\n#if 0\r\ndissector_add_uint("tcp.port", 6881, dissector_handle);\r\ndissector_add_uint("tcp.port", 6882, dissector_handle);\r\ndissector_add_uint("tcp.port", 6883, dissector_handle);\r\ndissector_add_uint("tcp.port", 6884, dissector_handle);\r\ndissector_add_uint("tcp.port", 6885, dissector_handle);\r\ndissector_add_uint("tcp.port", 6886, dissector_handle);\r\ndissector_add_uint("tcp.port", 6887, dissector_handle);\r\ndissector_add_uint("tcp.port", 6888, dissector_handle);\r\ndissector_add_uint("tcp.port", 6889, dissector_handle);\r\n#endif\r\nheur_dissector_add("tcp", test_bittorrent_packet, "BitTorrent over TCP", "bittorrent_tcp", proto_bittorrent, HEURISTIC_ENABLE);\r\n}
