static gboolean\r\ncheck_imap_heur(tvbuff_t *tvb)\r\n{\r\nconst gchar *s;\r\ngint i;\r\nif (!tvb_bytes_exist(tvb, 0, IMAP_HEUR_LEN)) {\r\nreturn TRUE;\r\n}\r\ns = (const gchar *)tvb_get_ptr(tvb, 0, IMAP_HEUR_LEN);\r\nfor (i = 0; i < IMAP_HEUR_LEN; i++) {\r\nif (!g_ascii_isprint(s[i])) {\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\ndissect_imap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ngboolean is_request;\r\nproto_tree *imap_tree, *reqresp_tree;\r\nproto_item *ti, *hidden_item;\r\ngint offset = 0;\r\ngint uid_offset = 0;\r\ngint folder_offset = 0;\r\nconst guchar *line;\r\nconst guchar *uid_line;\r\nconst guchar *folder_line;\r\ngint next_offset;\r\nint linelen;\r\nint tokenlen;\r\nint uid_tokenlen;\r\nint folder_tokenlen;\r\nconst guchar *next_token;\r\nconst guchar *uid_next_token;\r\nconst guchar *folder_next_token;\r\nguchar *tokenbuf;\r\nguchar *command_token;\r\nint iter;\r\nint commandlen;\r\nconversation_t *conversation;\r\nimap_state_t *session_state;\r\nconversation = find_or_create_conversation(pinfo);\r\nsession_state = (imap_state_t *)conversation_get_proto_data(conversation, proto_imap);\r\nif (!session_state) {\r\nsession_state = wmem_new0(wmem_file_scope(), imap_state_t);\r\nsession_state->ssl_requested = FALSE;\r\nif (imap_ssl_heuristic)\r\nsession_state->ssl_heur_tries_left = 2;\r\nelse\r\nsession_state->ssl_heur_tries_left = -1;\r\nconversation_add_proto_data(conversation, proto_imap, session_state);\r\n}\r\nif (imap_ssl_heuristic && session_state->ssl_heur_tries_left < 0) {\r\nsession_state->ssl_heur_tries_left = 2;\r\n}\r\nelse if (!imap_ssl_heuristic && session_state->ssl_heur_tries_left >= 0) {\r\nsession_state->ssl_heur_tries_left = -1;\r\n}\r\nif (session_state->ssl_heur_tries_left > 0) {\r\nsession_state->ssl_heur_tries_left--;\r\nif (!check_imap_heur(tvb)) {\r\nssl_starttls_post_ack(ssl_handle, pinfo, imap_handle);\r\nsession_state->ssl_heur_tries_left = 0;\r\nreturn call_dissector(ssl_handle, tvb, pinfo, tree);\r\n}\r\n}\r\ntokenbuf = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);\r\ncommand_token = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);\r\ncommandlen = 0;\r\nfolder_offset = 0;\r\nfolder_tokenlen = 0;\r\nfolder_line = NULL;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IMAP");\r\nif (pinfo->match_uint == pinfo->destport)\r\nis_request = TRUE;\r\nelse\r\nis_request = FALSE;\r\nlinelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nline = tvb_get_ptr(tvb, offset, linelen);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s: %s", is_request ? "Request" : "Response", format_text(line, linelen));\r\n{\r\nti = proto_tree_add_item(tree, proto_imap, tvb, offset, -1, ENC_NA);\r\nimap_tree = proto_item_add_subtree(ti, ett_imap);\r\nhidden_item = proto_tree_add_boolean(imap_tree, hf_imap_isrequest, tvb, 0, 0, is_request);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nwhile(tvb_offset_exists(tvb, offset)) {\r\nlinelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nline = tvb_get_ptr(tvb, offset, linelen);\r\nti = proto_tree_add_item(imap_tree, hf_imap_line, tvb, offset, next_offset - offset, ENC_ASCII|ENC_NA);\r\nreqresp_tree = proto_item_add_subtree(ti, ett_imap_reqresp);\r\nif ( (line) && ((line[0] != '*') || (TRUE == is_request)) ) {\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nif (tokenlen != 0) {\r\nproto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_tag : hf_imap_response_tag, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\noffset += (gint) (next_token - line);\r\nlinelen -= (int) (next_token - line);\r\nline = next_token;\r\n}\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nif (tokenlen != 0) {\r\nfor (iter = 0; iter < tokenlen && iter < MAX_BUFFER-1; iter++) {\r\ntokenbuf[iter] = g_ascii_tolower(line[iter]);\r\n}\r\nif (tree && is_request && strncmp(tokenbuf, "uid", tokenlen) == 0) {\r\nproto_tree_add_item(reqresp_tree, hf_imap_request_uid, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\nuid_offset = offset;\r\nuid_offset += (gint) (next_token - line);\r\nuid_line = next_token;\r\nuid_tokenlen = get_token_len(uid_line, uid_line + (linelen - tokenlen), &uid_next_token);\r\nif (tokenlen != 0) {\r\nproto_tree_add_item(reqresp_tree, hf_imap_request_command, tvb, uid_offset, uid_tokenlen, ENC_ASCII|ENC_NA);\r\nfor (iter = 0; iter < uid_tokenlen && iter < MAX_BUFFER-1; iter++) {\r\ncommand_token[iter] = g_ascii_tolower(uid_line[iter]);\r\n}\r\ncommandlen = uid_tokenlen;\r\nfolder_offset = uid_offset;\r\nfolder_offset += (gint) (uid_next_token - uid_line);\r\nfolder_line = uid_next_token;\r\nfolder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - uid_tokenlen), &folder_next_token);\r\n}\r\n} else {\r\nproto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_command : hf_imap_response_status, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\r\nif (is_request) {\r\nfor (iter = 0; iter < tokenlen && iter < 256; iter++) {\r\ncommand_token[iter] = g_ascii_tolower(line[iter]);\r\n}\r\ncommandlen = tokenlen;\r\nfolder_offset = offset;\r\nfolder_offset += (gint) (next_token - line);\r\nfolder_line = next_token;\r\nfolder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - 1), &folder_next_token);\r\n}\r\n}\r\nif (tree && commandlen > 0 && (\r\nstrncmp(command_token, "select", commandlen) == 0 ||\r\nstrncmp(command_token, "examine", commandlen) == 0 ||\r\nstrncmp(command_token, "create", commandlen) == 0 ||\r\nstrncmp(command_token, "delete", commandlen) == 0 ||\r\nstrncmp(command_token, "rename", commandlen) == 0 ||\r\nstrncmp(command_token, "subscribe", commandlen) == 0 ||\r\nstrncmp(command_token, "unsubscribe", commandlen) == 0 ||\r\nstrncmp(command_token, "status", commandlen) == 0 ||\r\nstrncmp(command_token, "append", commandlen) == 0 ||\r\nstrncmp(command_token, "search", commandlen) == 0)) {\r\nif (folder_tokenlen != 0)\r\nproto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);\r\n}\r\nif (tree && is_request && (NULL != folder_line) && strncmp(command_token, "copy", commandlen) == 0) {\r\nfolder_offset += (gint) (folder_next_token - folder_line);\r\nfolder_line = folder_next_token;\r\nfolder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen), &folder_next_token);\r\nif (folder_tokenlen != 0)\r\nproto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);\r\n}\r\nif (session_state->ssl_requested) {\r\nif (!is_request && strncmp(tokenbuf, "ok", tokenlen) == 0) {\r\nssl_starttls_ack(ssl_handle, pinfo, imap_handle);\r\nif (session_state->ssl_heur_tries_left > 0) {\r\nsession_state->ssl_heur_tries_left = 0;\r\n}\r\n}\r\nsession_state->ssl_requested = FALSE;\r\n}\r\nif (is_request && commandlen > 0 &&\r\nstrncmp(command_token, "starttls", commandlen) == 0) {\r\nsession_state->ssl_requested = TRUE;\r\n}\r\n}\r\nif (linelen != 0) {\r\nproto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request : hf_imap_response, tvb, offset, linelen, ENC_ASCII|ENC_NA);\r\n}\r\n}\r\noffset = next_offset;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_imap(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_imap_isrequest,\r\n{ "Request", "imap.isrequest",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if IMAP request, FALSE otherwise", HFILL }\r\n},\r\n{ &hf_imap_line,\r\n{ "Line", "imap.line",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\n"A line of an IMAP message", HFILL }\r\n},\r\n{ &hf_imap_request,\r\n{ "Request", "imap.request",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\n"Remainder of request line", HFILL }\r\n},\r\n{ &hf_imap_request_tag,\r\n{ "Request Tag", "imap.request_tag",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\n"First token of request line", HFILL }\r\n},\r\n{ &hf_imap_response,\r\n{ "Response", "imap.response",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\n"Remainder of response line", HFILL }\r\n},\r\n{ &hf_imap_response_tag,\r\n{ "Response Tag", "imap.response_tag",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\n"First token of response line", HFILL }\r\n},\r\n{ &hf_imap_request_command,\r\n{ "Request Command", "imap.request.command",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\n"Request command name", HFILL }\r\n},\r\n{ &hf_imap_response_status,\r\n{ "Response Status", "imap.response.status",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\n"Response status code", HFILL }\r\n},\r\n{ &hf_imap_request_folder,\r\n{ "Request Folder", "imap.request.folder",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\n"Request command folder", HFILL }\r\n},\r\n{ &hf_imap_request_uid,\r\n{ "Request isUID", "imap.request.command.uid",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Request command uid", HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_imap,\r\n&ett_imap_reqresp,\r\n};\r\nmodule_t *imap_module;\r\nproto_imap = proto_register_protocol("Internet Message Access Protocol", "IMAP", "imap");\r\nimap_handle = register_dissector("imap", dissect_imap, proto_imap);\r\nproto_register_field_array(proto_imap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nimap_module = prefs_register_protocol(proto_imap, NULL);\r\nprefs_register_bool_preference(imap_module, "ssl_heuristic",\r\n"Use heuristic detection for TLS",\r\n"Whether to use heuristics for post-STARTTLS detection of encrypted IMAP conversations",\r\n&imap_ssl_heuristic);\r\n}\r\nvoid\r\nproto_reg_handoff_imap(void)\r\n{\r\ndissector_add_uint("tcp.port", TCP_PORT_IMAP, imap_handle);\r\nssl_dissector_add(TCP_PORT_SSL_IMAP, imap_handle);\r\nssl_handle = find_dissector("ssl");\r\n}
