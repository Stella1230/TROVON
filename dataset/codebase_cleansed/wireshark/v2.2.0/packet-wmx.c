proto_item *add_tlv_subtree(tlv_info_t *self, proto_tree *tree, int hfindex, tvbuff_t *tvb, gint start, const guint encoding)\r\n{\r\nheader_field_info *hf;\r\nproto_tree *tlv_tree;\r\nproto_item *tlv_item;\r\ngint tlv_value_length, tlv_val_offset;\r\nguint8 size_of_tlv_length_field;\r\nguint8 tlv_type;\r\nif (get_tlv_type(self) < 0)\r\nreturn tree;\r\ntlv_val_offset = get_tlv_value_offset(self);\r\ntlv_value_length = get_tlv_length(self);\r\nsize_of_tlv_length_field = get_tlv_size_of_length(self);\r\ntlv_type = get_tlv_type(self);\r\nhf = proto_registrar_get_nth(hfindex);\r\ntlv_tree = proto_tree_add_subtree(tree, tvb, start, tlv_value_length+tlv_val_offset, ett_tlv[tlv_type], NULL, hf->name);\r\nproto_tree_add_uint(tlv_tree, hf_tlv_type, tvb, start, 1, tlv_type);\r\nif (size_of_tlv_length_field > 0)\r\n{\r\nproto_tree_add_uint(tlv_tree, hf_tlv_length_size, tvb, start+1, 1, size_of_tlv_length_field);\r\nproto_tree_add_uint(tlv_tree, hf_tlv_length, tvb, start+2, size_of_tlv_length_field, tlv_value_length);\r\n} else {\r\nproto_tree_add_uint(tlv_tree, hf_tlv_length, tvb, start+1, 1, tlv_value_length);\r\n}\r\ntlv_item = proto_tree_add_item(tlv_tree, hfindex, tvb, start+tlv_val_offset, tlv_value_length, encoding);\r\nreturn tlv_item;\r\n}\r\nproto_tree *add_tlv_subtree_no_item(tlv_info_t *self, proto_tree *tree, int hfindex, tvbuff_t *tvb, gint start)\r\n{\r\nheader_field_info *hf;\r\nproto_tree *tlv_tree;\r\ngint tlv_value_length, tlv_val_offset;\r\nguint8 size_of_tlv_length_field;\r\nguint8 tlv_type;\r\nif (get_tlv_type(self) < 0)\r\nreturn tree;\r\ntlv_val_offset = get_tlv_value_offset(self);\r\ntlv_value_length = get_tlv_length(self);\r\nsize_of_tlv_length_field = get_tlv_size_of_length(self);\r\ntlv_type = get_tlv_type(self);\r\nhf = proto_registrar_get_nth(hfindex);\r\ntlv_tree = proto_tree_add_subtree(tree, tvb, start, tlv_value_length+tlv_val_offset, ett_tlv[tlv_type], NULL, hf->name);\r\nproto_tree_add_uint(tlv_tree, hf_tlv_type, tvb, start, 1, tlv_type);\r\nif (size_of_tlv_length_field > 0)\r\n{\r\nproto_tree_add_uint(tlv_tree, hf_tlv_length_size, tvb, start+1, 1, size_of_tlv_length_field);\r\nproto_tree_add_uint(tlv_tree, hf_tlv_length, tvb, start+2, size_of_tlv_length_field, tlv_value_length);\r\n} else {\r\nproto_tree_add_uint(tlv_tree, hf_tlv_length, tvb, start+1, 1, tlv_value_length);\r\n}\r\nreturn tlv_tree;\r\n}\r\nproto_tree *add_protocol_subtree(tlv_info_t *self, gint idx, proto_tree *tree, int hfindex, tvbuff_t *tvb, gint start, gint length _U_, const char *label)\r\n{\r\nproto_tree *tlv_tree;\r\nproto_item *tlv_item;\r\ngint tlv_value_length, tlv_val_offset;\r\nguint8 size_of_tlv_length_field;\r\nguint8 tlv_type;\r\nguint32 tlv_value;\r\nconst gchar *hex_fmt;\r\nif (get_tlv_type(self) < 0)\r\nreturn tree;\r\ntlv_val_offset = get_tlv_value_offset(self);\r\ntlv_value_length = get_tlv_length(self);\r\nsize_of_tlv_length_field = get_tlv_size_of_length(self);\r\ntlv_type = get_tlv_type(self);\r\ntlv_item = proto_tree_add_protocol_format(tree, hfindex, tvb, start, tlv_value_length+tlv_val_offset, "%s (%u byte(s))", label, tlv_value_length);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_tlv[tlv_type]);\r\nproto_tree_add_uint(tlv_tree, hf_tlv_type, tvb, start, 1, tlv_type);\r\nif (size_of_tlv_length_field > 0)\r\n{\r\nproto_tree_add_uint(tlv_tree, hf_tlv_length_size, tvb, start+1, 1, size_of_tlv_length_field);\r\nproto_tree_add_uint(tlv_tree, hf_tlv_length, tvb, start+2, size_of_tlv_length_field, tlv_value_length);\r\n} else {\r\nproto_tree_add_uint(tlv_tree, hf_tlv_length, tvb, start+1, 1, tlv_value_length);\r\n}\r\nswitch (tlv_value_length)\r\n{\r\ncase 1:\r\ntlv_value = tvb_get_guint8(tvb, start+tlv_val_offset);\r\nhex_fmt = tlv_val_1byte;\r\nbreak;\r\ncase 2:\r\ntlv_value = tvb_get_ntohs(tvb, start+tlv_val_offset);\r\nhex_fmt = tlv_val_2byte;\r\nbreak;\r\ncase 3:\r\ntlv_value = tvb_get_ntoh24(tvb, start+tlv_val_offset);\r\nhex_fmt = tlv_val_3byte;\r\nbreak;\r\ncase 4:\r\ntlv_value = tvb_get_ntohl(tvb, start+tlv_val_offset);\r\nhex_fmt = tlv_val_4byte;\r\nbreak;\r\ndefault:\r\ntlv_value = tvb_get_ntohl(tvb, start+tlv_val_offset);\r\nhex_fmt = tlv_val_5byte;\r\nbreak;\r\n}\r\ntlv_tree = proto_tree_add_subtree_format(tlv_tree, tvb, start+tlv_val_offset, tlv_value_length, idx, NULL, hex_fmt, label, tlv_value);\r\nreturn tlv_tree;\r\n}\r\nstatic int dissect_wimax(tvbuff_t *tvb _U_, packet_info *pinfo, proto_tree *tree _U_, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "WiMax");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nreturn tvb_captured_length(tvb);\r\n}\r\ngboolean is_down_link(packet_info *pinfo)\r\n{\r\nif (pinfo->p2p_dir == P2P_DIR_RECV)\r\nreturn TRUE;\r\nif (pinfo->p2p_dir == P2P_DIR_UNKNOWN)\r\nif(bs_address.len && !cmp_address(&bs_address, &pinfo->src))\r\nreturn TRUE;\r\nreturn FALSE;\r\n}\r\nvoid proto_register_wimax(void)\r\n{\r\nint i;\r\nmodule_t *wimax_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tlv_type, { "TLV type", "wmx.tlv_type", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_tlv_length, { "TLV length", "wmx.tlv_length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_tlv_length_size, { "Size of TLV length field", "wmx.tlv_length_size", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n};\r\ngint *ett_reg[MAX_NUM_TLVS];\r\nproto_wimax = proto_register_protocol (\r\n"WiMax Protocol",\r\n"WiMax (wmx)",\r\n"wmx"\r\n);\r\nproto_register_field_array(proto_wimax, hf, array_length(hf));\r\nfor (i = 0; i < MAX_NUM_TLVS; i++)\r\n{\r\nett_tlv[i] = -1;\r\nett_reg[i] = &ett_tlv[i];\r\n}\r\nproto_register_subtree_array(ett_reg, array_length(ett_reg));\r\nregister_dissector("wmx", dissect_wimax, proto_wimax);\r\nwimax_module = prefs_register_protocol(proto_wimax, NULL);\r\nprefs_register_uint_preference(wimax_module, "basic_cid_max",\r\n"Maximum Basic CID",\r\n"Set the maximum Basic CID"\r\n" used in the Wimax decoder"\r\n" (if other than the default of 320)."\r\n" Note: The maximum Primary CID is"\r\n" double the maximum Basic CID.",\r\n10, &global_cid_max_basic);\r\nprefs_register_bool_preference(wimax_module, "corrigendum_2_version",\r\n"Corrigendum 2 Version",\r\n"Set to TRUE to use the Corrigendum"\r\n" 2 version of Wimax message decoding."\r\n" Set to FALSE to use the 802.16e-2005"\r\n" version.",\r\n&include_cor2_changes);\r\nprefs_register_obsolete_preference(wimax_module, "wimax.basic_cid_max");\r\nprefs_register_obsolete_preference(wimax_module, "wimax.corrigendum_2_version");\r\n}
