static gchar *\r\ntvb_atalkid_to_str(tvbuff_t *tvb, gint offset)\r\n{\r\ngint node;\r\ngchar *cur;\r\ncur=(gchar *)wmem_alloc(wmem_packet_scope(), 16);\r\nnode=tvb_get_guint8(tvb, offset+1)<<8|tvb_get_guint8(tvb, offset+2);\r\ng_snprintf(cur, 16, "%d.%d",node,tvb_get_guint8(tvb, offset+3));\r\nreturn cur;\r\n}\r\nstatic const gchar *\r\ntvb_aarphrdaddr_to_str(tvbuff_t *tvb, gint offset, int ad_len, guint16 type)\r\n{\r\nif (AARP_HW_IS_ETHER(type, ad_len)) {\r\nreturn tvb_ether_to_str(tvb, offset);\r\n}\r\nreturn tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, ad_len);\r\n}\r\nstatic gchar *\r\ntvb_aarpproaddr_to_str(tvbuff_t *tvb, gint offset, int ad_len, guint16 type)\r\n{\r\nif (AARP_PRO_IS_ATALK(type, ad_len)) {\r\nreturn tvb_atalkid_to_str(tvb, offset);\r\n}\r\nreturn tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, ad_len);\r\n}\r\nstatic int\r\ndissect_aarp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nguint16 ar_hrd;\r\nguint16 ar_pro;\r\nguint8 ar_hln;\r\nguint8 ar_pln;\r\nguint16 ar_op;\r\nproto_tree *aarp_tree;\r\nproto_item *ti;\r\nconst gchar *op_str;\r\nint sha_offset, spa_offset, tha_offset, tpa_offset;\r\nconst gchar *sha_str, *spa_str, *tpa_str;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "AARP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nar_hrd = tvb_get_ntohs(tvb, AR_HRD);\r\nar_pro = tvb_get_ntohs(tvb, AR_PRO);\r\nar_hln = tvb_get_guint8(tvb, AR_HLN);\r\nar_pln = tvb_get_guint8(tvb, AR_PLN);\r\nar_op = tvb_get_ntohs(tvb, AR_OP);\r\nsha_offset = MIN_AARP_HEADER_SIZE;\r\nspa_offset = sha_offset + ar_hln;\r\ntha_offset = spa_offset + ar_pln;\r\ntpa_offset = tha_offset + ar_hln;\r\nsha_str = tvb_aarphrdaddr_to_str(tvb, sha_offset, ar_hln, ar_hrd);\r\nspa_str = tvb_aarpproaddr_to_str(tvb, spa_offset, ar_pln, ar_pro);\r\n#if 0\r\ntha_str = tvb_aarphrdaddr_to_str(tvb, tha_offset, ar_hln, ar_hrd);\r\n#endif\r\ntpa_str = tvb_aarpproaddr_to_str(tvb, tpa_offset, ar_pln, ar_pro);\r\nswitch (ar_op) {\r\ncase AARP_REQUEST:\r\ncase AARP_REQUEST_SWAPPED:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Who has %s? Tell %s", tpa_str, spa_str);\r\nbreak;\r\ncase AARP_REPLY:\r\ncase AARP_REPLY_SWAPPED:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s is at %s", spa_str, sha_str);\r\nbreak;\r\ncase AARP_PROBE:\r\ncase AARP_PROBE_SWAPPED:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Is there a %s", tpa_str);\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unknown AARP opcode 0x%04x", ar_op);\r\nbreak;\r\n}\r\nif (tree) {\r\nif ((op_str = try_val_to_str(ar_op, op_vals)))\r\nti = proto_tree_add_protocol_format(tree, proto_aarp, tvb, 0,\r\nMIN_AARP_HEADER_SIZE + 2*ar_hln +\r\n2*ar_pln, "AppleTalk Address Resolution Protocol (%s)", op_str);\r\nelse\r\nti = proto_tree_add_protocol_format(tree, proto_aarp, tvb, 0,\r\nMIN_AARP_HEADER_SIZE + 2*ar_hln +\r\n2*ar_pln,\r\n"AppleTalk Address Resolution Protocol (opcode 0x%04x)", ar_op);\r\naarp_tree = proto_item_add_subtree(ti, ett_aarp);\r\nproto_tree_add_uint(aarp_tree, hf_aarp_hard_type, tvb, AR_HRD, 2,\r\nar_hrd);\r\nproto_tree_add_uint(aarp_tree, hf_aarp_proto_type, tvb, AR_PRO, 2,\r\nar_pro);\r\nproto_tree_add_uint(aarp_tree, hf_aarp_hard_size, tvb, AR_HLN, 1,\r\nar_hln);\r\nproto_tree_add_uint(aarp_tree, hf_aarp_proto_size, tvb, AR_PLN, 1,\r\nar_pln);\r\nproto_tree_add_uint(aarp_tree, hf_aarp_opcode, tvb, AR_OP, 2,\r\nar_op);\r\nif (ar_hln != 0) {\r\nproto_tree_add_item(aarp_tree,\r\nAARP_HW_IS_ETHER(ar_hrd, ar_hln) ? hf_aarp_src_hw_mac : hf_aarp_src_hw,\r\ntvb, sha_offset, ar_hln, ENC_NA);\r\n}\r\nif (ar_pln != 0) {\r\nif (AARP_PRO_IS_ATALK(ar_pro, ar_pln)) {\r\nproto_tree_add_bytes_format_value(aarp_tree, hf_aarp_src_proto_id, tvb,\r\nspa_offset, ar_pln, NULL,\r\n"%s", spa_str);\r\n} else {\r\nproto_tree_add_bytes_format_value(aarp_tree, hf_aarp_src_proto, tvb,\r\nspa_offset, ar_pln, NULL,\r\n"%s", spa_str);\r\n}\r\n}\r\nif (ar_hln != 0) {\r\nproto_tree_add_item(aarp_tree,\r\nAARP_HW_IS_ETHER(ar_hrd, ar_hln) ? hf_aarp_dst_hw_mac : hf_aarp_dst_hw,\r\ntvb, tha_offset, ar_hln, ENC_NA);\r\n}\r\nif (ar_pln != 0) {\r\nif (AARP_PRO_IS_ATALK(ar_pro, ar_pln)) {\r\nproto_tree_add_bytes_format_value(aarp_tree, hf_aarp_dst_proto_id, tvb,\r\ntpa_offset, ar_pln,\r\nNULL, "%s", tpa_str);\r\n} else {\r\nproto_tree_add_bytes_format_value(aarp_tree, hf_aarp_dst_proto, tvb,\r\ntpa_offset, ar_pln,\r\nNULL, "%s", tpa_str);\r\n}\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_aarp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_aarp_hard_type,\r\n{ "Hardware type", "aarp.hard.type",\r\nFT_UINT16, BASE_HEX, VALS(hrd_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_proto_type,\r\n{ "Protocol type", "aarp.proto.type",\r\nFT_UINT16, BASE_HEX, VALS(etype_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_hard_size,\r\n{ "Hardware size", "aarp.hard.size",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_proto_size,\r\n{ "Protocol size", "aarp.proto.size",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_opcode,\r\n{ "Opcode", "aarp.opcode",\r\nFT_UINT16, BASE_DEC, VALS(op_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_src_hw,\r\n{ "Sender hardware address", "aarp.src.hw",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_src_hw_mac,\r\n{ "Sender MAC address", "aarp.src.hw_mac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_src_proto,\r\n{ "Sender protocol address", "aarp.src.proto",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_src_proto_id,\r\n{ "Sender ID", "aarp.src.proto_id",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_dst_hw,\r\n{ "Target hardware address", "aarp.dst.hw",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_dst_hw_mac,\r\n{ "Target MAC address", "aarp.dst.hw_mac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_dst_proto,\r\n{ "Target protocol address", "aarp.dst.proto",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_aarp_dst_proto_id,\r\n{ "Target ID", "aarp.dst.proto_id",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_aarp,\r\n};\r\nproto_aarp = proto_register_protocol("Appletalk Address Resolution Protocol",\r\n"AARP",\r\n"aarp");\r\nproto_register_field_array(proto_aarp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_aarp(void)\r\n{\r\ndissector_handle_t aarp_handle;\r\naarp_handle = create_dissector_handle(dissect_aarp, proto_aarp);\r\ndissector_add_uint("ethertype", ETHERTYPE_AARP, aarp_handle);\r\ndissector_add_uint("chdlc.protocol", ETHERTYPE_AARP, aarp_handle);\r\n}
