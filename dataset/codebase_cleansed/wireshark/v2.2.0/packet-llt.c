static int\r\ndissect_llt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *llt_tree;\r\nguint8 message_type;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "LLT");\r\nmessage_type = tvb_get_guint8(tvb, 3);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Message type: %s", val_to_str(message_type, message_type_vs, "Unknown (0x%02x)"));\r\nti = proto_tree_add_item(tree, proto_llt, tvb, 0, -1, ENC_NA);\r\nllt_tree = proto_item_add_subtree(ti, ett_llt);\r\nproto_tree_add_item(llt_tree, hf_llt_cluster_num, tvb, 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(llt_tree, hf_llt_message_type, tvb, 3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(llt_tree, hf_llt_node_id, tvb, 7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(llt_tree, hf_llt_sequence_num, tvb, 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(llt_tree, hf_llt_message_time, tvb, 40, 4, ENC_BIG_ENDIAN);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_llt(void)\r\n{\r\nmodule_t *llt_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_llt_cluster_num, { "Cluster number", "llt.cluster_num",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Cluster number that this node belongs to", HFILL } },\r\n{ &hf_llt_message_type, { "Message type", "llt.message_type",\r\nFT_UINT8, BASE_HEX, VALS(message_type_vs), 0,\r\n"Type of LLT message contained in this frame", HFILL } },\r\n{ &hf_llt_node_id, { "Node ID", "llt.node_id",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Number identifying this node within the cluster", HFILL } },\r\n{ &hf_llt_sequence_num, { "Sequence number", "llt.sequence_num",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Sequence number of this frame", HFILL } },\r\n{ &hf_llt_message_time, { "Message time", "llt.message_time",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\n"Number of ticks since this node was last rebooted", HFILL } }\r\n};\r\nstatic gint *ett[] = {\r\n&ett_llt,\r\n};\r\nproto_llt = proto_register_protocol("Veritas Low Latency Transport (LLT)", "LLT", "llt");\r\nproto_register_field_array(proto_llt, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nllt_module = prefs_register_protocol(proto_llt, proto_reg_handoff_llt);\r\nprefs_register_uint_preference(llt_module, "alternate_ethertype", "Alternate ethertype value (in hex)",\r\n"Dissect this ethertype as LLT traffic in addition to the default, 0xCAFE.",\r\n16, &preference_alternate_ethertype);\r\n}\r\nvoid\r\nproto_reg_handoff_llt(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic dissector_handle_t llt_handle;\r\nstatic guint preference_alternate_ethertype_last;\r\nif (!initialized) {\r\nllt_handle = create_dissector_handle(dissect_llt, proto_llt);\r\ndissector_add_uint("ethertype", ETHERTYPE_LLT, llt_handle);\r\ninitialized = TRUE;\r\n} else {\r\nif (preference_alternate_ethertype_last != 0x0) {\r\ndissector_delete_uint("ethertype", preference_alternate_ethertype_last, llt_handle);\r\n}\r\n}\r\npreference_alternate_ethertype_last = preference_alternate_ethertype;\r\nif (preference_alternate_ethertype != 0x0) {\r\ndissector_add_uint("ethertype", preference_alternate_ethertype, llt_handle);\r\n}\r\n}
