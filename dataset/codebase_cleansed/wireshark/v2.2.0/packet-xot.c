static guint get_xot_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nguint16 plen;\r\nint remain = tvb_captured_length_remaining(tvb, offset);\r\nif ( remain < XOT_HEADER_LENGTH){\r\nreturn remain;\r\n}\r\nplen = tvb_get_ntohs(tvb, offset + 2);\r\nreturn XOT_HEADER_LENGTH + plen;\r\n}\r\nstatic guint get_xot_pdu_len_mult(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nint offset_before = offset;\r\nint offset_next = offset + XOT_HEADER_LENGTH + X25_MIN_HEADER_LENGTH;\r\nint tvb_len;\r\nwhile (tvb_len = tvb_captured_length_remaining(tvb, offset), tvb_len>0){\r\nguint16 plen = 0;\r\nint modulo;\r\nguint16 bytes0_1;\r\nguint8 pkt_type;\r\ngboolean m_bit_set;\r\nint offset_x25 = offset + XOT_HEADER_LENGTH;\r\noffset_next = offset_x25 + X25_MIN_HEADER_LENGTH;\r\nif (tvb_len < XOT_HEADER_LENGTH) {\r\nreturn offset_next-offset_before;\r\n}\r\nplen = get_xot_pdu_len(pinfo, tvb, offset, NULL);\r\noffset_next = offset + plen;\r\nif (tvb_len < plen){\r\nreturn offset_next-offset_before;\r\n}\r\nbytes0_1 = tvb_get_ntohs(tvb, offset_x25+0);\r\npkt_type = tvb_get_guint8(tvb, offset_x25+2);\r\nif (offset == offset_before && !PACKET_IS_DATA(pkt_type)) {\r\nreturn offset_next-offset_before;\r\n}\r\nif (PACKET_IS_DATA(pkt_type)){\r\nmodulo = ((bytes0_1 & 0x2000) ? 128 : 8);\r\nif (modulo == 8) {\r\nm_bit_set = pkt_type & X25_MBIT_MOD8;\r\n} else {\r\nm_bit_set = tvb_get_guint8(tvb, offset_x25+3) & X25_MBIT_MOD128;\r\n}\r\nif (!m_bit_set){\r\nreturn offset_next-offset_before;\r\n}\r\n}\r\noffset = offset_next;\r\noffset_next += XOT_HEADER_LENGTH + X25_MIN_HEADER_LENGTH;\r\n}\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn offset_next - offset_before;\r\n}\r\nstatic int dissect_xot_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nguint16 version;\r\nguint16 plen;\r\nguint8 pkt_type;\r\nproto_item *ti = NULL;\r\nproto_tree *xot_tree = NULL;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "XOT");\r\nversion = tvb_get_ntohs(tvb, offset + 0);\r\nplen = tvb_get_ntohs(tvb, offset + 2);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "XOT Version = %u, size = %u",\r\nversion, plen);\r\nif (offset == 0 &&\r\ntvb_reported_length_remaining(tvb, offset) > XOT_HEADER_LENGTH + plen )\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " TotX25: %d",\r\ntvb_reported_length_remaining(tvb, offset));\r\nif (tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_xot, tvb, offset, XOT_HEADER_LENGTH,\r\n"X.25 over TCP");\r\nxot_tree = proto_item_add_subtree(ti, ett_xot);\r\nproto_tree_add_uint(xot_tree, hf_xot_version, tvb, offset, 2, version);\r\nproto_tree_add_uint(xot_tree, hf_xot_length, tvb, offset + 2, 2, plen);\r\n}\r\noffset += XOT_HEADER_LENGTH;\r\nif (plen >= X25_MIN_HEADER_LENGTH) {\r\npkt_type = tvb_get_guint8(tvb, offset + 2);\r\nif (pkt_type == XOT_PVC_SETUP) {\r\nguint init_itf_name_len, resp_itf_name_len, pkt_size;\r\ngint hdr_offset = offset;\r\ncol_set_str(pinfo->cinfo, COL_INFO, "XOT PVC Setup");\r\nproto_item_set_len(ti, XOT_HEADER_LENGTH + plen);\r\nproto_tree_add_item(xot_tree, hf_x25_gfi, tvb, hdr_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(xot_tree, hf_x25_lcn, tvb, hdr_offset, 2, ENC_BIG_ENDIAN);\r\nhdr_offset += 2;\r\nproto_tree_add_item(xot_tree, hf_x25_type, tvb, hdr_offset, 1, ENC_BIG_ENDIAN);\r\nhdr_offset += 1;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_version, tvb, hdr_offset, 1, ENC_BIG_ENDIAN);\r\nhdr_offset += 1;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_status, tvb, hdr_offset, 1, ENC_BIG_ENDIAN);\r\nhdr_offset += 1;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_init_itf_name_len, tvb, hdr_offset, 1, ENC_BIG_ENDIAN);\r\ninit_itf_name_len = tvb_get_guint8(tvb, hdr_offset);\r\nhdr_offset += 1;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_init_lcn, tvb, hdr_offset, 2, ENC_BIG_ENDIAN);\r\nhdr_offset += 2;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_resp_itf_name_len, tvb, hdr_offset, 1, ENC_BIG_ENDIAN);\r\nresp_itf_name_len = tvb_get_guint8(tvb, hdr_offset);\r\nhdr_offset += 1;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_resp_lcn, tvb, hdr_offset, 2, ENC_BIG_ENDIAN);\r\nhdr_offset += 2;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_send_inc_window, tvb, hdr_offset, 1, ENC_BIG_ENDIAN);\r\nhdr_offset += 1;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_send_out_window, tvb, hdr_offset, 1, ENC_BIG_ENDIAN);\r\nhdr_offset += 1;\r\npkt_size = 1 << tvb_get_guint8(tvb, hdr_offset);\r\nproto_tree_add_uint(xot_tree, hf_xot_pvc_send_inc_pkt_size, tvb, hdr_offset, 1, pkt_size);\r\nhdr_offset += 1;\r\npkt_size = 1 << tvb_get_guint8(tvb, hdr_offset);\r\nproto_tree_add_uint(xot_tree, hf_xot_pvc_send_out_pkt_size, tvb, hdr_offset, 1, pkt_size);\r\nhdr_offset += 1;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_init_itf_name, tvb, hdr_offset, init_itf_name_len, ENC_ASCII|ENC_NA);\r\nhdr_offset += init_itf_name_len;\r\nproto_tree_add_item(xot_tree, hf_xot_pvc_resp_itf_name, tvb, hdr_offset, resp_itf_name_len, ENC_ASCII|ENC_NA);\r\n} else {\r\nnext_tvb = tvb_new_subset(tvb, offset,\r\nMIN(plen, tvb_captured_length_remaining(tvb, offset)), plen);\r\ncall_dissector(x25_handle, next_tvb, pinfo, tree);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_xot_mult(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nint offset = 0;\r\nint len = get_xot_pdu_len_mult(pinfo, tvb, offset, NULL);\r\ntvbuff_t *next_tvb;\r\nint offset_max = offset+MIN(len,tvb_captured_length_remaining(tvb, offset));\r\nproto_item *ti;\r\nproto_tree *xot_tree;\r\nif (tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_xot, tvb, offset, offset_max-offset,\r\n"X.25 over TCP - X.25 Sequence");\r\nxot_tree = proto_item_add_subtree(ti, ett_xot);\r\nproto_tree_add_uint(xot_tree, hf_xot_length, tvb, offset, offset_max, len);\r\n}\r\nwhile (offset <= offset_max - XOT_HEADER_LENGTH){\r\nint plen = get_xot_pdu_len(pinfo, tvb, offset, NULL);\r\nnext_tvb = tvb_new_subset(tvb, offset,plen, plen);\r\ndissect_xot_pdu(next_tvb, pinfo, tree, data);\r\noffset += plen;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_xot_tcp_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nint tvb_len = tvb_captured_length(tvb);\r\nint len = 0;\r\nif (tvb_len >= 2 && tvb_get_ntohs(tvb,0) != XOT_VERSION) {\r\nreturn 0;\r\n}\r\nif (!x25_desegment || !xot_desegment){\r\ntcp_dissect_pdus(tvb, pinfo, tree, xot_desegment,\r\nXOT_HEADER_LENGTH,\r\nget_xot_pdu_len,\r\ndissect_xot_pdu, data);\r\nlen=get_xot_pdu_len(pinfo, tvb, 0, NULL);\r\n} else {\r\ntcp_dissect_pdus(tvb, pinfo, tree, xot_desegment,\r\nXOT_HEADER_LENGTH,\r\nget_xot_pdu_len_mult,\r\ndissect_xot_mult, data);\r\nlen=get_xot_pdu_len_mult(pinfo, tvb, 0, NULL);\r\n}\r\nif (len < XOT_HEADER_LENGTH) {\r\nlen = 0;\r\n} else if (tvb_len < XOT_HEADER_LENGTH) {\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nlen=tvb_len - XOT_HEADER_LENGTH;\r\n} else if (tvb_len < len) {\r\nif (x25_desegment){\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\n} else {\r\npinfo->desegment_len = len - tvb_len;\r\n}\r\nlen=tvb_len - len;\r\n}\r\nreturn len;\r\n}\r\nvoid\r\nproto_register_xot(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_xot_version,\r\n{ "Version", "xot.version", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Version of X.25 over TCP protocol", HFILL }},\r\n{ &hf_xot_length,\r\n{ "Length", "xot.length", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Length of X.25 over TCP packet", HFILL }},\r\n{ &hf_x25_gfi,\r\n{ "GFI", "x25.gfi", FT_UINT16, BASE_DEC,\r\nNULL, 0xF000, "General Format Identifier", HFILL }},\r\n{ &hf_x25_lcn,\r\n{ "Logical Channel", "x25.lcn", FT_UINT16, BASE_DEC,\r\nNULL, 0x0FFF, "Logical Channel Number", HFILL }},\r\n{ &hf_x25_type,\r\n{ "Packet Type", "x25.type", FT_UINT8, BASE_HEX,\r\nVALS(vals_x25_type), 0x0, NULL, HFILL }},\r\n{ &hf_xot_pvc_version,\r\n{ "Version", "xot.pvc.version", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_xot_pvc_status,\r\n{ "Status", "xot.pvc.status", FT_UINT8, BASE_HEX,\r\nVALS(xot_pvc_status_vals), 0, NULL, HFILL }},\r\n{ &hf_xot_pvc_init_itf_name_len,\r\n{ "Initiator interface name length", "xot.pvc.init_itf_name_len", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_xot_pvc_init_lcn,\r\n{ "Initiator LCN", "xot.pvc.init_lcn", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Initiator Logical Channel Number", HFILL }},\r\n{ &hf_xot_pvc_resp_itf_name_len,\r\n{ "Responder interface name length", "xot.pvc.resp_itf_name_len", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_xot_pvc_resp_lcn,\r\n{ "Responder LCN", "xot.pvc.resp_lcn", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Responder Logical Channel Number", HFILL }},\r\n{ &hf_xot_pvc_send_inc_window,\r\n{ "Sender incoming window", "xot.pvc.send_inc_window", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_xot_pvc_send_out_window,\r\n{ "Sender outgoing window", "xot.pvc.send_out_window", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_xot_pvc_send_inc_pkt_size,\r\n{ "Sender incoming packet size", "xot.pvc.send_inc_pkt_size", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_xot_pvc_send_out_pkt_size,\r\n{ "Sender outgoing packet size", "xot.pvc.send_out_pkt_size", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_xot_pvc_init_itf_name,\r\n{ "Initiator interface name", "xot.pvc.init_itf_name", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_xot_pvc_resp_itf_name,\r\n{ "Responder interface name", "xot.pvc.resp_itf_name", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_xot\r\n};\r\nmodule_t *xot_module;\r\nproto_xot = proto_register_protocol("X.25 over TCP", "XOT", "xot");\r\nproto_register_field_array(proto_xot, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nxot_handle = register_dissector("xot", dissect_xot_tcp_heur, proto_xot);\r\nxot_module = prefs_register_protocol(proto_xot, NULL);\r\nprefs_register_bool_preference(xot_module, "desegment",\r\n"Reassemble X.25-over-TCP messages spanning multiple TCP segments",\r\n"Whether the X.25-over-TCP dissector should reassemble messages spanning multiple TCP segments. "\r\n"To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings",\r\n&xot_desegment);\r\nprefs_register_bool_preference(xot_module, "x25_desegment",\r\n"Reassemble X.25 packets with More flag to enable safe X.25 reassembly",\r\n"Whether the X.25-over-TCP dissector should reassemble all X.25 packets before calling the X25 dissector. "\r\n"If the TCP packets arrive out-of-order, the X.25 reassembly can otherwise fail. "\r\n"To use this option, you should also enable \"Reassemble X.25-over-TCP messages spanning multiple TCP segments\", \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings and \"Reassemble fragmented X.25 packets\" in the X.25 protocol settings.",\r\n&x25_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_xot(void)\r\n{\r\ndissector_add_uint("tcp.port", TCP_PORT_XOT, xot_handle);\r\nx25_handle = find_dissector_add_dependency("x.25", proto_xot);\r\n}
