static void\r\nsip_init_hash(sipstat_t *sp)\r\n{\r\nint i;\r\nsp->hash_responses = g_hash_table_new(g_int_hash, g_int_equal);\r\nfor (i=0; vals_status_code[i].strptr; i++)\r\n{\r\ngint *key = g_new (gint, 1);\r\nsip_response_code_t *sc = g_new (sip_response_code_t, 1);\r\n*key = vals_status_code[i].value;\r\nsc->packets = 0;\r\nsc->response_code = *key;\r\nsc->name = vals_status_code[i].strptr;\r\nsc->sp = sp;\r\ng_hash_table_insert(sc->sp->hash_responses, key, sc);\r\n}\r\nsp->hash_requests = g_hash_table_new(g_str_hash, g_str_equal);\r\n}\r\nstatic void\r\nsip_draw_hash_requests( gchar *key _U_, sip_request_method_t *data, gchar *format)\r\n{\r\nif (data->packets == 0)\r\nreturn;\r\nprintf( format, data->response, data->packets);\r\n}\r\nstatic void\r\nsip_draw_hash_responses( gint *key _U_ , sip_response_code_t *data, char *format)\r\n{\r\nif (data == NULL) {\r\ng_warning("C'est quoi ce borderl key=%d\n", *key);\r\nexit(EXIT_FAILURE);\r\n}\r\nif (data->packets == 0)\r\nreturn;\r\nprintf(format, data->response_code, data->name, data->packets );\r\n}\r\nstatic void\r\nsip_reset_hash_responses(gchar *key _U_ , sip_response_code_t *data, gpointer ptr _U_ )\r\n{\r\ndata->packets = 0;\r\n}\r\nstatic void\r\nsip_reset_hash_requests(gchar *key _U_ , sip_request_method_t *data, gpointer ptr _U_ )\r\n{\r\ndata->packets = 0;\r\n}\r\nstatic void\r\nsipstat_reset(void *psp )\r\n{\r\nsipstat_t *sp = (sipstat_t *)psp;\r\nif (sp) {\r\nsp->packets = 0;\r\nsp->resent_packets = 0;\r\nsp->average_setup_time = 0;\r\nsp->max_setup_time = 0;\r\nsp->min_setup_time = 0;\r\nsp->no_of_completed_calls = 0;\r\nsp->total_setup_time = 0;\r\ng_hash_table_foreach( sp->hash_responses, (GHFunc)sip_reset_hash_responses, NULL);\r\ng_hash_table_foreach( sp->hash_requests, (GHFunc)sip_reset_hash_requests, NULL);\r\n}\r\n}\r\nstatic int\r\nsipstat_packet(void *psp, packet_info *pinfo _U_, epan_dissect_t *edt _U_, const void *pri)\r\n{\r\nconst sip_info_value_t *value = (const sip_info_value_t *)pri;\r\nsipstat_t *sp = (sipstat_t *)psp;\r\nsp->packets++;\r\nif (value->setup_time) {\r\nsp->no_of_completed_calls++;\r\nif ( sp->total_setup_time == 0 ) {\r\nsp->average_setup_time = value->setup_time;\r\nsp->total_setup_time = value->setup_time;\r\nsp->max_setup_time = value->setup_time;\r\nsp->min_setup_time = value->setup_time;\r\n}else{\r\nsp->total_setup_time = sp->total_setup_time + value->setup_time;\r\nif (sp->max_setup_time < value->setup_time) {\r\nsp->max_setup_time = value->setup_time;\r\n}\r\nif (sp->min_setup_time > value->setup_time) {\r\nsp->min_setup_time = value->setup_time;\r\n}\r\nsp->average_setup_time = (guint32)(sp->total_setup_time / sp->no_of_completed_calls);\r\n}\r\n}\r\nif (value->resend)\r\n{\r\nsp->resent_packets++;\r\n}\r\nif (value->response_code != 0)\r\n{\r\nguint *key = g_new(guint, 1);\r\nsip_response_code_t *sc;\r\n*key = value->response_code;\r\nsc = (sip_response_code_t *)g_hash_table_lookup(sp->hash_responses, key);\r\nif (sc == NULL)\r\n{\r\nint i = value->response_code;\r\nif ((i < 100) || (i >= 700))\r\n{\r\nreturn 0;\r\n}\r\nelse if (i < 200)\r\n{\r\n*key = 199;\r\n}\r\nelse if (i < 300)\r\n{\r\n*key = 299;\r\n}\r\nelse if (i < 400)\r\n{\r\n*key = 399;\r\n}\r\nelse if (i < 500)\r\n{\r\n*key = 499;\r\n}\r\nelse if (i < 600)\r\n{\r\n*key = 599;\r\n}\r\nelse\r\n{\r\n*key = 699;\r\n}\r\nsc = (sip_response_code_t *)g_hash_table_lookup(sp->hash_responses, key);\r\nif (sc == NULL)\r\n{\r\nreturn 0;\r\n}\r\n}\r\nsc->packets++;\r\n}\r\nelse if (value->request_method)\r\n{\r\nsip_request_method_t *sc;\r\nsc = (sip_request_method_t *)g_hash_table_lookup(sp->hash_requests, value->request_method);\r\nif (sc == NULL)\r\n{\r\nsc = g_new(sip_request_method_t, 1);\r\nsc->response = g_strdup(value->request_method);\r\nsc->packets = 1;\r\nsc->sp = sp;\r\ng_hash_table_insert(sp->hash_requests, sc->response, sc);\r\n}\r\nelse\r\n{\r\nsc->packets++;\r\n}\r\n}\r\nelse\r\n{\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void\r\nsipstat_draw(void *psp )\r\n{\r\nsipstat_t *sp = (sipstat_t *)psp;\r\nprintf("\n");\r\nprintf("===================================================================\n");\r\nif (sp->filter == NULL)\r\nprintf("SIP Statistics\n");\r\nelse\r\nprintf("SIP Statistics with filter %s\n", sp->filter);\r\nprintf("\nNumber of SIP messages: %u", sp->packets);\r\nprintf("\nNumber of resent SIP messages: %u\n", sp->resent_packets);\r\nprintf( "\n* SIP Status Codes in reply packets\n");\r\ng_hash_table_foreach(sp->hash_responses, (GHFunc)sip_draw_hash_responses,\r\n(gpointer)" SIP %3d %-15s : %5d Packets\n");\r\nprintf("\n* List of SIP Request methods\n");\r\ng_hash_table_foreach(sp->hash_requests, (GHFunc)sip_draw_hash_requests,\r\n(gpointer)" %-15s : %5d Packets\n");\r\nprintf( "\n* Average setup time %u ms\n Min %u ms\n Max %u ms\n", sp->average_setup_time, sp->min_setup_time, sp->max_setup_time);\r\nprintf("===================================================================\n");\r\n}\r\nstatic void\r\nsipstat_init(const char *opt_arg, void *userdata _U_)\r\n{\r\nsipstat_t *sp;\r\nconst char *filter = NULL;\r\nGString *error_string;\r\nif (strncmp (opt_arg, "sip,stat,", 9) == 0) {\r\nfilter = opt_arg+9;\r\n} else {\r\nfilter = NULL;\r\n}\r\nsp = g_new0(sipstat_t, 1);\r\nif (filter) {\r\nsp->filter = g_strdup(filter);\r\n} else {\r\nsp->filter = NULL;\r\n}\r\nerror_string = register_tap_listener(\r\n"sip",\r\nsp,\r\nfilter,\r\n0,\r\nsipstat_reset,\r\nsipstat_packet,\r\nsipstat_draw);\r\nif (error_string) {\r\ng_free(sp->filter);\r\ng_free(sp);\r\nfprintf (stderr, "tshark: Couldn't register sip,stat tap: %s\n",\r\nerror_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\nsp->packets = 0;\r\nsp->resent_packets = 0;\r\nsip_init_hash(sp);\r\n}\r\nvoid\r\nregister_tap_listener_sipstat(void)\r\n{\r\nregister_stat_tap_ui(&sipstat_ui, NULL);\r\n}
