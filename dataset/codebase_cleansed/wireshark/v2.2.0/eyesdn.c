static gboolean esc_read(FILE_T fh, guint8 *buf, int len, int *err, gchar **err_info)\r\n{\r\nint i;\r\nint value;\r\nfor(i=0; i<len; i++) {\r\nvalue=file_getc(fh);\r\nif(value==-1) {\r\n*err=file_error(fh, err_info);\r\nif(*err==0)\r\n*err=WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nif(value==0xff) {\r\n*err=WTAP_ERR_BAD_FILE;\r\n*err_info=g_strdup("eyesdn: No flag character seen in frame");\r\nreturn FALSE;\r\n}\r\nif(value==0xfe) {\r\nvalue=file_getc(fh);\r\nif(value==-1) {\r\n*err=file_error(fh, err_info);\r\nif(*err==0)\r\n*err=WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nvalue+=2;\r\n}\r\nbuf[i]=value;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint64 eyesdn_seek_next_packet(wtap *wth, int *err, gchar **err_info)\r\n{\r\nint byte;\r\ngint64 cur_off;\r\nwhile ((byte = file_getc(wth->fh)) != EOF) {\r\nif (byte == 0xff) {\r\ncur_off = file_tell(wth->fh);\r\nif (cur_off == -1) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nreturn cur_off;\r\n}\r\n}\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nwtap_open_return_val eyesdn_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar magic[EYESDN_HDR_MAGIC_SIZE];\r\nif (!wtap_read_bytes(wth->fh, &magic, sizeof magic, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(magic, eyesdn_hdr_magic, EYESDN_HDR_MAGIC_SIZE) != 0)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_EYESDN;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = eyesdn_read;\r\nwth->subtype_seek_read = eyesdn_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean eyesdn_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\ngint64 offset;\r\noffset = eyesdn_seek_next_packet(wth, err, err_info);\r\nif (offset < 1)\r\nreturn FALSE;\r\n*data_offset = offset;\r\nreturn read_eyesdn_rec(wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info);\r\n}\r\nstatic gboolean\r\neyesdn_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nreturn read_eyesdn_rec(wth->random_fh, phdr, buf, err, err_info);\r\n}\r\nstatic gboolean\r\nread_eyesdn_rec(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf, int *err,\r\ngchar **err_info)\r\n{\r\nunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nguint8 hdr[EYESDN_HDR_LENGTH];\r\ntime_t secs;\r\nint usecs;\r\nint pkt_len;\r\nguint8 channel, direction;\r\nguint8 *pd;\r\nif (!esc_read(fh, hdr, EYESDN_HDR_LENGTH, err, err_info))\r\nreturn FALSE;\r\nusecs = pntoh24(&hdr[0]);\r\n#ifdef TV64BITS\r\nsecs = hdr[3];\r\n#else\r\nsecs = 0;\r\n#endif\r\nsecs = (secs << 8) | hdr[4];\r\nsecs = (secs << 8) | hdr[5];\r\nsecs = (secs << 8) | hdr[6];\r\nsecs = (secs << 8) | hdr[7];\r\nchannel = hdr[8];\r\ndirection = hdr[9];\r\npkt_len = pntoh16(&hdr[10]);\r\nswitch(direction >> 1) {\r\ndefault:\r\ncase EYESDN_ENCAP_ISDN:\r\npseudo_header->isdn.uton = direction & 1;\r\npseudo_header->isdn.channel = channel;\r\nif(channel) {\r\nphdr->pkt_encap = WTAP_ENCAP_ISDN;\r\npseudo_header->isdn.uton=!pseudo_header->isdn.uton;\r\n} else {\r\nphdr->pkt_encap = WTAP_ENCAP_ISDN;\r\n}\r\nbreak;\r\ncase EYESDN_ENCAP_MSG:\r\nphdr->pkt_encap = WTAP_ENCAP_LAYER1_EVENT;\r\npseudo_header->l1event.uton = (direction & 1);\r\nbreak;\r\ncase EYESDN_ENCAP_LAPB:\r\nphdr->pkt_encap = WTAP_ENCAP_LAPB;\r\npseudo_header->x25.flags = (direction & 1) ? 0 : 0x80;\r\nbreak;\r\ncase EYESDN_ENCAP_ATM: {\r\n#define CELL_LEN 53\r\nunsigned char cell[CELL_LEN];\r\ngint64 cur_off;\r\nif(pkt_len != CELL_LEN) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf(\r\n"eyesdn: ATM cell has a length != 53 (%u)",\r\npkt_len);\r\nreturn FALSE;\r\n}\r\ncur_off = file_tell(fh);\r\nif (!esc_read(fh, cell, CELL_LEN, err, err_info))\r\nreturn FALSE;\r\nif (file_seek(fh, cur_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nphdr->pkt_encap = WTAP_ENCAP_ATM_PDUS_UNTRUNCATED;\r\npseudo_header->atm.flags=ATM_RAW_CELL;\r\npseudo_header->atm.aal=AAL_UNKNOWN;\r\npseudo_header->atm.type=TRAF_UMTS_FP;\r\npseudo_header->atm.subtype=TRAF_ST_UNKNOWN;\r\npseudo_header->atm.vpi=((cell[0]&0xf)<<4) + (cell[0]&0xf);\r\npseudo_header->atm.vci=((cell[0]&0xf)<<4) + cell[0];\r\npseudo_header->atm.channel=direction & 1;\r\n}\r\nbreak;\r\ncase EYESDN_ENCAP_MTP2:\r\npseudo_header->mtp2.sent = direction & 1;\r\npseudo_header->mtp2.annex_a_used = MTP2_ANNEX_A_USED_UNKNOWN;\r\npseudo_header->mtp2.link_number = channel;\r\nphdr->pkt_encap = WTAP_ENCAP_MTP2_WITH_PHDR;\r\nbreak;\r\ncase EYESDN_ENCAP_DPNSS:\r\npseudo_header->isdn.uton = direction & 1;\r\npseudo_header->isdn.channel = channel;\r\nphdr->pkt_encap = WTAP_ENCAP_DPNSS;\r\nbreak;\r\ncase EYESDN_ENCAP_DASS2:\r\npseudo_header->isdn.uton = direction & 1;\r\npseudo_header->isdn.channel = channel;\r\nphdr->pkt_encap = WTAP_ENCAP_DPNSS;\r\nbreak;\r\ncase EYESDN_ENCAP_BACNET:\r\npseudo_header->isdn.uton = direction & 1;\r\npseudo_header->isdn.channel = channel;\r\nphdr->pkt_encap = WTAP_ENCAP_BACNET_MS_TP_WITH_PHDR;\r\nbreak;\r\ncase EYESDN_ENCAP_V5_EF:\r\npseudo_header->isdn.uton = direction & 1;\r\npseudo_header->isdn.channel = channel;\r\nphdr->pkt_encap = WTAP_ENCAP_V5_EF;\r\nbreak;\r\n}\r\nif(pkt_len > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("eyesdn: File has %u-byte packet, bigger than maximum of %u",\r\npkt_len, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->ts.secs = secs;\r\nphdr->ts.nsecs = usecs * 1000;\r\nphdr->caplen = pkt_len;\r\nphdr->len = pkt_len;\r\nws_buffer_assure_space(buf, pkt_len);\r\npd = ws_buffer_start_ptr(buf);\r\nif (!esc_read(fh, pd, pkt_len, err, err_info))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nesc_write(wtap_dumper *wdh, const guint8 *buf, int len, int *err)\r\n{\r\nint i;\r\nguint8 byte;\r\nstatic const guint8 esc = 0xfe;\r\nfor(i=0; i<len; i++) {\r\nbyte=buf[i];\r\nif(byte == 0xff || byte == 0xfe) {\r\nif (!wtap_dump_file_write(wdh, &esc, sizeof esc, err))\r\nreturn FALSE;\r\nbyte-=2;\r\n}\r\nif (!wtap_dump_file_write(wdh, &byte, sizeof byte, err))\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\ngboolean eyesdn_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nwdh->subtype_write=eyesdn_dump;\r\nif (!wtap_dump_file_write(wdh, eyesdn_hdr_magic,\r\nEYESDN_HDR_MAGIC_SIZE, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += EYESDN_HDR_MAGIC_SIZE;\r\n*err=0;\r\nreturn TRUE;\r\n}\r\nint eyesdn_dump_can_write_encap(int encap)\r\n{\r\nswitch (encap) {\r\ncase WTAP_ENCAP_ISDN:\r\ncase WTAP_ENCAP_LAYER1_EVENT:\r\ncase WTAP_ENCAP_DPNSS:\r\ncase WTAP_ENCAP_ATM_PDUS_UNTRUNCATED:\r\ncase WTAP_ENCAP_LAPB:\r\ncase WTAP_ENCAP_MTP2_WITH_PHDR:\r\ncase WTAP_ENCAP_BACNET_MS_TP_WITH_PHDR:\r\ncase WTAP_ENCAP_PER_PACKET:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\nstatic gboolean eyesdn_dump(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nstatic const guint8 start_flag = 0xff;\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nguint8 buf[EYESDN_HDR_LENGTH];\r\nint usecs;\r\ntime_t secs;\r\nint channel;\r\nint origin;\r\nint protocol;\r\nint size;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen > 65535) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nusecs=phdr->ts.nsecs/1000;\r\nsecs=phdr->ts.secs;\r\nsize=phdr->caplen;\r\norigin = pseudo_header->isdn.uton;\r\nchannel = pseudo_header->isdn.channel;\r\nswitch(phdr->pkt_encap) {\r\ncase WTAP_ENCAP_ISDN:\r\nprotocol=EYESDN_ENCAP_ISDN;\r\nbreak;\r\ncase WTAP_ENCAP_LAYER1_EVENT:\r\nprotocol=EYESDN_ENCAP_MSG;\r\nbreak;\r\ncase WTAP_ENCAP_DPNSS:\r\nprotocol=EYESDN_ENCAP_DPNSS;\r\nbreak;\r\n#if 0\r\ncase WTAP_ENCAP_DASS2:\r\nprotocol=EYESDN_ENCAP_DASS2;\r\nbreak;\r\n#endif\r\ncase WTAP_ENCAP_ATM_PDUS_UNTRUNCATED:\r\nprotocol=EYESDN_ENCAP_ATM;\r\nchannel=0x80;\r\nbreak;\r\ncase WTAP_ENCAP_LAPB:\r\nprotocol=EYESDN_ENCAP_LAPB;\r\nbreak;\r\ncase WTAP_ENCAP_MTP2_WITH_PHDR:\r\nprotocol=EYESDN_ENCAP_MTP2;\r\nbreak;\r\ncase WTAP_ENCAP_BACNET_MS_TP_WITH_PHDR:\r\nprotocol=EYESDN_ENCAP_BACNET;\r\nbreak;\r\ncase WTAP_ENCAP_V5_EF:\r\nprotocol=EYESDN_ENCAP_V5_EF;\r\nbreak;\r\ndefault:\r\n*err=WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn FALSE;\r\n}\r\nphton24(&buf[0], usecs);\r\nbuf[3] = (guint8)0;\r\nbuf[4] = (guint8)(0xff & (secs >> 24));\r\nbuf[5] = (guint8)(0xff & (secs >> 16));\r\nbuf[6] = (guint8)(0xff & (secs >> 8));\r\nbuf[7] = (guint8)(0xff & (secs >> 0));\r\nbuf[8] = (guint8) channel;\r\nbuf[9] = (guint8) (origin?1:0) + (protocol << 1);\r\nphtons(&buf[10], size);\r\nif (!wtap_dump_file_write(wdh, &start_flag, sizeof start_flag, err))\r\nreturn FALSE;\r\nif (!esc_write(wdh, buf, 12, err))\r\nreturn FALSE;\r\nif (!esc_write(wdh, pd, size, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}
