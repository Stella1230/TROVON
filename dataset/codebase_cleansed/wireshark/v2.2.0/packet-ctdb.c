static int dissect_control_get_recmaster_reply(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, guint32 status, int endianess _U_)\r\n{\r\nproto_tree_add_uint(tree, hf_ctdb_recmaster, tvb, 0, 0, status);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " RecMaster:%d", status);\r\nreturn offset;\r\n}\r\nstatic int dissect_control_get_recmode_reply(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, guint32 status, int endianess _U_)\r\n{\r\nproto_tree_add_uint(tree, hf_ctdb_recmode, tvb, 0, 0, status);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " RecMode:%s",\r\nval_to_str(status, recmode_vals, "Unknown:%d"));\r\nreturn offset;\r\n}\r\nstatic int dissect_control_get_nodemap_reply(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, guint32 status _U_, int endianess)\r\n{\r\nguint32 num_nodes;\r\nproto_item *item;\r\nitem = proto_tree_add_item(tree, hf_ctdb_num_nodes, tvb, offset, 4, endianess);\r\nif(endianess){\r\nnum_nodes=tvb_get_letohl(tvb, offset);\r\n} else {\r\nnum_nodes=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nif (num_nodes > CTDB_MAX_NODES) {\r\nexpert_add_info_format(pinfo, item, &ei_ctdb_too_many_nodes, "Too many nodes (%u). Stopping dissection.", num_nodes);\r\nreturn offset;\r\n}\r\nwhile(num_nodes--){\r\nproto_tree_add_item(tree, hf_ctdb_vnn, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_node_flags, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_node_ip, tvb, offset+4, 4, ENC_BIG_ENDIAN);\r\noffset+=16;\r\n}\r\nreturn offset;\r\n}\r\nstatic int dissect_control_process_exist_request(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, guint32 status _U_, int endianess)\r\n{\r\nguint32 pid;\r\nproto_tree_add_item(tree, hf_ctdb_pid, tvb, offset, 4, endianess);\r\nif(endianess){\r\npid=tvb_get_letohl(tvb, offset);\r\n} else {\r\npid=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " pid:%d", pid);\r\nreturn offset;\r\n}\r\nstatic int dissect_control_process_exist_reply(packet_info *pinfo _U_, proto_tree *tree, tvbuff_t *tvb, int offset, guint32 status, int endianess _U_)\r\n{\r\nproto_tree_add_boolean(tree, hf_ctdb_process_exists, tvb, offset, 4, status);\r\nreturn offset;\r\n}\r\nstatic control_dissector find_control_dissector(guint32 opcode, gboolean is_request)\r\n{\r\ncontrol_dissector_array_t *cd=control_dissectors;\r\nwhile(cd){\r\nif((!cd->opcode)&&(!cd->request_dissector)&&(!cd->reply_dissector)){\r\nbreak;\r\n}\r\nif(opcode==cd->opcode){\r\nif(is_request){\r\nreturn cd->request_dissector;\r\n} else {\r\nreturn cd->reply_dissector;\r\n}\r\n}\r\ncd++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nctdb_display_trans(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, ctdb_trans_t *ctdb_trans)\r\n{\r\nproto_item *item;\r\nif(ctdb_trans->request_in!=pinfo->num){\r\nitem=proto_tree_add_uint(tree, hf_ctdb_request_in, tvb, 0, 0, ctdb_trans->request_in);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif( (ctdb_trans->response_in!=0)\r\n&&(ctdb_trans->response_in!=pinfo->num) ){\r\nitem=proto_tree_add_uint(tree, hf_ctdb_response_in, tvb, 0, 0, ctdb_trans->response_in);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif(pinfo->num==ctdb_trans->response_in){\r\nnstime_t ns;\r\nnstime_delta(&ns, &pinfo->abs_ts, &ctdb_trans->req_time);\r\nitem=proto_tree_add_time(tree, hf_ctdb_time, tvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\n}\r\nstatic void\r\nctdb_display_control(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, ctdb_control_t *ctdb_control)\r\n{\r\nproto_item *item;\r\nif(ctdb_control->request_in!=pinfo->num){\r\nitem=proto_tree_add_uint(tree, hf_ctdb_request_in, tvb, 0, 0, ctdb_control->request_in);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif( (ctdb_control->response_in!=0)\r\n&&(ctdb_control->response_in!=pinfo->num) ){\r\nitem=proto_tree_add_uint(tree, hf_ctdb_response_in, tvb, 0, 0, ctdb_control->response_in);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\nif(pinfo->num==ctdb_control->response_in){\r\nnstime_t ns;\r\nnstime_delta(&ns, &pinfo->abs_ts, &ctdb_control->req_time);\r\nitem=proto_tree_add_time(tree, hf_ctdb_time, tvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\n}\r\nstatic guint32\r\nctdb_hash(tvbuff_t *tvb, int offset, guint32 len)\r\n{\r\nguint32 value;\r\nguint32 i;\r\nfor(value=0x238F13AF*len, i=0; i < len; i++)\r\nvalue=(value+(tvb_get_guint8(tvb, offset+i) << (i*5 % 24)));\r\nreturn (1103515243 * value + 12345);\r\n}\r\nstatic int\r\ndissect_ctdb_key(proto_tree *tree, tvbuff_t *tvb, int offset, guint32 keylen, guint32 *key_hash, int endianess)\r\n{\r\nguint32 keyhash;\r\nproto_item *key_item=NULL;\r\nproto_item *key_tree=NULL;\r\nif(tree){\r\nkey_item=proto_tree_add_item(tree, hf_ctdb_key, tvb, offset, keylen, endianess);\r\nkey_tree=proto_item_add_subtree(key_item, ett_ctdb_key);\r\n}\r\nkeyhash=ctdb_hash(tvb, offset, keylen);\r\nproto_item_append_text(key_item, " (Hash:0x%08x)", keyhash);\r\nkey_item=proto_tree_add_uint(key_tree, hf_ctdb_keyhash, tvb, 0, 0, keyhash);\r\nPROTO_ITEM_SET_GENERATED(key_item);\r\noffset+=keylen;\r\nif(key_hash){\r\n*key_hash=keyhash;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ctdb_reply_call(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, int endianess)\r\n{\r\nguint32 datalen;\r\nproto_tree_add_item(tree, hf_ctdb_status, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_datalen, tvb, offset, 4, endianess);\r\nif(endianess){\r\ndatalen=tvb_get_letohl(tvb, offset);\r\n} else {\r\ndatalen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_data, tvb, offset, datalen, endianess);\r\noffset+=datalen;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ctdb_reply_dmaster(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, guint32 reqid, guint32 dst, int endianess)\r\n{\r\nguint32 datalen, keylen;\r\nwmem_tree_key_t tkey[3];\r\nctdb_trans_t *ctdb_trans;\r\nproto_tree_add_item(tree, hf_ctdb_dbid, tvb, offset, 4, endianess);\r\noffset+=4;\r\noffset=(offset+7)&0xfffff8;\r\nproto_tree_add_item(tree, hf_ctdb_rsn, tvb, offset, 8, endianess);\r\noffset+=8;\r\nproto_tree_add_item(tree, hf_ctdb_keylen, tvb, offset, 4, endianess);\r\nif(endianess){\r\nkeylen=tvb_get_letohl(tvb, offset);\r\n} else {\r\nkeylen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_datalen, tvb, offset, 4, endianess);\r\nif(endianess){\r\ndatalen=tvb_get_letohl(tvb, offset);\r\n} else {\r\ndatalen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\noffset=dissect_ctdb_key(tree, tvb, offset, keylen, NULL, endianess);\r\nproto_tree_add_item(tree, hf_ctdb_data, tvb, offset, datalen, endianess);\r\noffset+=datalen;\r\ntkey[0].length=1;\r\ntkey[0].key=&reqid;\r\ntkey[1].length=1;\r\ntkey[1].key=&dst;\r\ntkey[2].length=0;\r\nctdb_trans=(ctdb_trans_t *)wmem_tree_lookup32_array(ctdb_transactions, &tkey[0]);\r\nif(ctdb_trans){\r\nctdb_trans->response_in=pinfo->num;\r\nctdb_display_trans(pinfo, tree, tvb, ctdb_trans);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ctdb_req_dmaster(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, guint32 reqid, int endianess)\r\n{\r\nguint32 keylen, datalen, dmaster;\r\nwmem_tree_key_t tkey[3];\r\nctdb_trans_t *ctdb_trans;\r\nproto_tree_add_item(tree, hf_ctdb_dbid, tvb, offset, 4, endianess);\r\noffset+=4;\r\noffset=(offset+7)&0xfffff8;\r\nproto_tree_add_item(tree, hf_ctdb_rsn, tvb, offset, 8, endianess);\r\noffset+=8;\r\nproto_tree_add_item(tree, hf_ctdb_dmaster, tvb, offset, 4, endianess);\r\nif(endianess){\r\ndmaster=tvb_get_letohl(tvb, offset);\r\n} else {\r\ndmaster=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_ctdb_keylen, tvb, offset, 4, endianess);\r\nif(endianess){\r\nkeylen=tvb_get_letohl(tvb, offset);\r\n} else {\r\nkeylen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_datalen, tvb, offset, 4, endianess);\r\nif(endianess){\r\ndatalen=tvb_get_letohl(tvb, offset);\r\n} else {\r\ndatalen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\noffset=dissect_ctdb_key(tree, tvb, offset, keylen, NULL, endianess);\r\nproto_tree_add_item(tree, hf_ctdb_data, tvb, offset, datalen, endianess);\r\noffset+=datalen;\r\ntkey[0].length=1;\r\ntkey[0].key=&reqid;\r\ntkey[1].length=1;\r\ntkey[1].key=&dmaster;\r\ntkey[2].length=0;\r\nctdb_trans=(ctdb_trans_t *)wmem_tree_lookup32_array(ctdb_transactions, &tkey[0]);\r\nif(ctdb_trans){\r\nctdb_display_trans(pinfo, tree, tvb, ctdb_trans);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ctdb_req_control(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, guint32 reqid, guint32 src, guint32 dst, int endianess)\r\n{\r\nguint32 datalen;\r\nguint32 opcode;\r\nctdb_control_t *ctdb_control;\r\ncontrol_dissector cd;\r\nint data_offset;\r\nproto_tree_add_item(tree, hf_ctdb_ctrl_opcode, tvb, offset, 4, endianess);\r\nif(endianess){\r\nopcode=tvb_get_letohl(tvb, offset);\r\n} else {\r\nopcode=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s Request %d->%d",\r\nval_to_str(opcode, ctrl_opcode_vals, "Unknown:%d"),\r\nsrc, dst);\r\noffset=(offset+7)&0xfffff8;\r\nproto_tree_add_item(tree, hf_ctdb_srvid, tvb, offset, 8, endianess);\r\noffset+=8;\r\nproto_tree_add_item(tree, hf_ctdb_clientid, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_ctrl_flags, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_datalen, tvb, offset, 4, endianess);\r\nif(endianess){\r\ndatalen=tvb_get_letohl(tvb, offset);\r\n} else {\r\ndatalen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\ndata_offset=offset;\r\nif (datalen) {\r\nproto_tree_add_item(tree, hf_ctdb_data, tvb, offset, datalen, endianess);\r\noffset+=datalen;\r\n}\r\nif(!pinfo->fd->flags.visited){\r\nwmem_tree_key_t tkey[4];\r\nctdb_control=wmem_new(wmem_file_scope(), ctdb_control_t);\r\nctdb_control->opcode=opcode;\r\nctdb_control->request_in=pinfo->num;\r\nctdb_control->response_in=0;\r\nctdb_control->req_time=pinfo->abs_ts;\r\ntkey[0].length=1;\r\ntkey[0].key=&reqid;\r\ntkey[1].length=1;\r\ntkey[1].key=&src;\r\ntkey[2].length=1;\r\ntkey[2].key=&dst;\r\ntkey[3].length=0;\r\nwmem_tree_insert32_array(ctdb_controls, &tkey[0], ctdb_control);\r\n} else {\r\nwmem_tree_key_t tkey[4];\r\ntkey[0].length=1;\r\ntkey[0].key=&reqid;\r\ntkey[1].length=1;\r\ntkey[1].key=&src;\r\ntkey[2].length=1;\r\ntkey[2].key=&dst;\r\ntkey[3].length=0;\r\nctdb_control=(ctdb_control_t *)wmem_tree_lookup32_array(ctdb_controls, &tkey[0]);\r\n}\r\ncd=find_control_dissector(ctdb_control->opcode, TRUE);\r\nif (cd) {\r\ncd(pinfo, tree, tvb, data_offset, 0, endianess);\r\n}\r\nctdb_display_control(pinfo, tree, tvb, ctdb_control);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ctdb_reply_control(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, guint32 reqid, guint32 src, guint32 dst, int endianess)\r\n{\r\nctdb_control_t *ctdb_control;\r\nwmem_tree_key_t tkey[4];\r\nproto_item *item;\r\nguint32 datalen, errorlen, status;\r\nint data_offset;\r\ncontrol_dissector cd;\r\ntkey[0].length=1;\r\ntkey[0].key=&reqid;\r\ntkey[1].length=1;\r\ntkey[1].key=&dst;\r\ntkey[2].length=1;\r\ntkey[2].key=&src;\r\ntkey[3].length=0;\r\nctdb_control=(ctdb_control_t *)wmem_tree_lookup32_array(ctdb_controls, &tkey[0]);\r\nif(!ctdb_control){\r\nreturn offset;\r\n}\r\nif(!pinfo->fd->flags.visited){\r\nctdb_control->response_in = pinfo->num;\r\n}\r\nitem=proto_tree_add_uint(tree, hf_ctdb_ctrl_opcode, tvb, 0, 0, ctdb_control->opcode);\r\nPROTO_ITEM_SET_GENERATED(item);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s Reply %d->%d",\r\nval_to_str(ctdb_control->opcode, ctrl_opcode_vals, "Unknown:%d"),\r\nsrc, dst);\r\nproto_tree_add_item(tree, hf_ctdb_status, tvb, offset, 4, endianess);\r\nif(endianess){\r\nstatus=tvb_get_letohl(tvb, offset);\r\n} else {\r\nstatus=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_datalen, tvb, offset, 4, endianess);\r\nif(endianess){\r\ndatalen=tvb_get_letohl(tvb, offset);\r\n} else {\r\ndatalen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_errorlen, tvb, offset, 4, endianess);\r\nif(endianess){\r\nerrorlen=tvb_get_letohl(tvb, offset);\r\n} else {\r\nerrorlen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\ndata_offset=offset;\r\nif (datalen) {\r\nproto_tree_add_item(tree, hf_ctdb_data, tvb, offset, datalen, endianess);\r\noffset+=datalen;\r\n}\r\nif (errorlen) {\r\nproto_tree_add_item(tree, hf_ctdb_error, tvb, offset, errorlen, endianess);\r\noffset+=errorlen;\r\n}\r\ncd=find_control_dissector(ctdb_control->opcode, FALSE);\r\nif (cd) {\r\ncd(pinfo, tree, tvb, data_offset, status, endianess);\r\n}\r\nctdb_display_control(pinfo, tree, tvb, ctdb_control);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ctdb_req_call(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, guint32 reqid, guint32 caller, int endianess)\r\n{\r\nguint32 flags, keyhash;\r\nguint32 keylen, datalen;\r\nctdb_trans_t *ctdb_trans=NULL;\r\nproto_tree_add_item(tree, hf_ctdb_flags_immediate, tvb, offset, 4, endianess);\r\nif(endianess){\r\nflags=tvb_get_letohl(tvb, offset);\r\n} else {\r\nflags=tvb_get_ntohl(tvb, offset);\r\n}\r\nif(flags&0x00000001){\r\ncol_append_str(pinfo->cinfo, COL_INFO, " IMMEDIATE");\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_dbid, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_callid, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_hopcount, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_keylen, tvb, offset, 4, endianess);\r\nif(endianess){\r\nkeylen=tvb_get_letohl(tvb, offset);\r\n} else {\r\nkeylen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_datalen, tvb, offset, 4, endianess);\r\nif(endianess){\r\ndatalen=tvb_get_letohl(tvb, offset);\r\n} else {\r\ndatalen=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\noffset=dissect_ctdb_key(tree, tvb, offset, keylen, &keyhash, endianess);\r\nproto_tree_add_item(tree, hf_ctdb_data, tvb, offset, datalen, endianess);\r\noffset+=datalen;\r\nif(!pinfo->fd->flags.visited){\r\nwmem_tree_key_t tkey[3];\r\nctdb_trans=wmem_new(wmem_file_scope(), ctdb_trans_t);\r\nctdb_trans->key_hash=keyhash;\r\nctdb_trans->request_in=pinfo->num;\r\nctdb_trans->response_in=0;\r\nctdb_trans->req_time=pinfo->abs_ts;\r\ntkey[0].length=1;\r\ntkey[0].key=&reqid;\r\ntkey[1].length=1;\r\ntkey[1].key=&caller;\r\ntkey[2].length=0;\r\nwmem_tree_insert32_array(ctdb_transactions, &tkey[0], ctdb_trans);\r\n} else {\r\nwmem_tree_key_t tkey[3];\r\ntkey[0].length=1;\r\ntkey[0].key=&reqid;\r\ntkey[1].length=1;\r\ntkey[1].key=&caller;\r\ntkey[2].length=0;\r\nctdb_trans=(ctdb_trans_t *)wmem_tree_lookup32_array(ctdb_transactions, &tkey[0]);\r\n}\r\nif(ctdb_trans){\r\nctdb_display_trans(pinfo, tree, tvb, ctdb_trans);\r\n}\r\nreturn offset;\r\n}\r\nstatic gboolean\r\ndissect_ctdb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data _U_)\r\n{\r\nproto_tree *tree=NULL;\r\nproto_item *item=NULL;\r\nint offset=0;\r\nguint32 opcode, src, dst, reqid;\r\nint endianess;\r\nif(tvb_captured_length(tvb)<8){\r\nreturn FALSE;\r\n}\r\nswitch(tvb_get_letohl(tvb, offset+4)){\r\ncase 0x42445443:\r\nendianess=FALSE;\r\nbreak;\r\ncase 0x43544442:\r\nendianess=TRUE;\r\nbreak;\r\ndefault:\r\nreturn FALSE;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CTDB");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif(parent_tree){\r\nitem=proto_tree_add_item(parent_tree, proto_ctdb, tvb, offset,\r\n-1, endianess);\r\ntree=proto_item_add_subtree(item, ett_ctdb);\r\n}\r\nproto_tree_add_item(tree, hf_ctdb_length, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_magic, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_version, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_generation, tvb, offset, 4, endianess);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_opcode, tvb, offset, 4, endianess);\r\nif(endianess){\r\nopcode=tvb_get_letohl(tvb, offset);\r\n} else {\r\nopcode=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_dst, tvb, offset, 4, endianess);\r\nif(endianess){\r\ndst=tvb_get_letohl(tvb, offset);\r\n} else {\r\ndst=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_src, tvb, offset, 4, endianess);\r\nif(endianess){\r\nsrc=tvb_get_letohl(tvb, offset);\r\n} else {\r\nsrc=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_ctdb_id, tvb, offset, 4, endianess);\r\nif(endianess){\r\nreqid=tvb_get_letohl(tvb, offset);\r\n} else {\r\nreqid=tvb_get_ntohl(tvb, offset);\r\n}\r\noffset+=4;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s %d->%d",\r\nval_to_str(opcode, ctdb_opcodes, "Unknown:%d"),\r\nsrc, dst);\r\nswitch(opcode){\r\ncase CTDB_REQ_CALL:\r\ndissect_ctdb_req_call(tvb, offset, pinfo, tree, reqid, src, endianess);\r\nbreak;\r\ncase CTDB_REPLY_CALL:\r\ndissect_ctdb_reply_call(tvb, offset, pinfo, tree, endianess);\r\nbreak;\r\ncase CTDB_REPLY_DMASTER:\r\ndissect_ctdb_reply_dmaster(tvb, offset, pinfo, tree, reqid, dst, endianess);\r\nbreak;\r\ncase CTDB_REQ_DMASTER:\r\ndissect_ctdb_req_dmaster(tvb, offset, pinfo, tree, reqid, endianess);\r\nbreak;\r\ncase CTDB_REPLY_ERROR:\r\nbreak;\r\ncase CTDB_REQ_MESSAGE:\r\nbreak;\r\ncase CTDB_REQ_CONTROL:\r\ndissect_ctdb_req_control(tvb, offset, pinfo, tree, reqid, src, dst, endianess);\r\nbreak;\r\ncase CTDB_REPLY_CONTROL:\r\ndissect_ctdb_reply_control(tvb, offset, pinfo, tree, reqid, src, dst, endianess);\r\nbreak;\r\n};\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_ctdb(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ctdb_length, {\r\n"Length", "ctdb.len", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "Size of CTDB PDU", HFILL }},\r\n{ &hf_ctdb_dst, {\r\n"Destination", "ctdb.dst", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_src, {\r\n"Source", "ctdb.src", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_id, {\r\n"Id", "ctdb.id", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "Transaction ID", HFILL }},\r\n{ &hf_ctdb_opcode, {\r\n"Opcode", "ctdb.opcode", FT_UINT32, BASE_DEC,\r\nVALS(ctdb_opcodes), 0x0, "CTDB command opcode", HFILL }},\r\n{ &hf_ctdb_flags_immediate, {\r\n"Immediate", "ctdb.immediate", FT_BOOLEAN, 32,\r\nTFS(&flags_immediate_tfs), 0x00000001, "Force migration of DMASTER?", HFILL }},\r\n{ &hf_ctdb_dbid, {\r\n"DB Id", "ctdb.dbid", FT_UINT32, BASE_HEX,\r\nVALS(ctdb_dbid_vals), 0x0, "Database ID", HFILL }},\r\n{ &hf_ctdb_callid, {\r\n"Call Id", "ctdb.callid", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_status, {\r\n"Status", "ctdb.status", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_datalen, {\r\n"Data Length", "ctdb.datalen", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_errorlen, {\r\n"Error Length", "ctdb.errorlen", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_keylen, {\r\n"Key Length", "ctdb.keylen", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_magic, {\r\n"Magic", "ctdb.magic", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_version, {\r\n"Version", "ctdb.version", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_dmaster, {\r\n"Dmaster", "ctdb.dmaster", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_generation, {\r\n"Generation", "ctdb.generation", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_key, {\r\n"Key", "ctdb.key", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_keyhash, {\r\n"KeyHash", "ctdb.keyhash", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_data, {\r\n"Data", "ctdb.data", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_error, {\r\n"Error", "ctdb.error", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_request_in, {\r\n"Request In", "ctdb.request_in", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_response_in, {\r\n"Response In", "ctdb.response_in", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_time, {\r\n"Time since request", "ctdb.time", FT_RELATIVE_TIME, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_hopcount, {\r\n"Hopcount", "ctdb.hopcount", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_rsn, {\r\n"RSN", "ctdb.rsn", FT_UINT64, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_ctrl_opcode, {\r\n"CTRL Opcode", "ctdb.ctrl_opcode", FT_UINT32, BASE_DEC,\r\nVALS(ctrl_opcode_vals), 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_srvid, {\r\n"SrvId", "ctdb.srvid", FT_UINT64, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_clientid, {\r\n"ClientId", "ctdb.clientid", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_ctrl_flags, {\r\n"CTRL Flags", "ctdb.ctrl_flags", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_recmaster, {\r\n"Recovery Master", "ctdb.recmaster", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_recmode, {\r\n"Recovery Mode", "ctdb.recmode", FT_UINT32, BASE_DEC,\r\nVALS(recmode_vals), 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_num_nodes, {\r\n"Num Nodes", "ctdb.num_nodes", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_vnn, {\r\n"VNN", "ctdb.vnn", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_node_flags, {\r\n"Node Flags", "ctdb.node_flags", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_node_ip, {\r\n"Node IP", "ctdb.node_ip", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_pid, {\r\n"PID", "ctdb.pid", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_ctdb_process_exists, {\r\n"Process Exists", "ctdb.process_exists", FT_BOOLEAN, 32,\r\nTFS(&process_exists_tfs), 0x01, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ctdb,\r\n&ett_ctdb_key,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ctdb_too_many_nodes, { "ctdb.too_many_nodes", PI_UNDECODED, PI_WARN, "Too many nodes", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ctdb;\r\nproto_ctdb = proto_register_protocol("Cluster TDB", "CTDB", "ctdb");\r\nproto_register_field_array(proto_ctdb, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ctdb = expert_register_protocol(proto_ctdb);\r\nexpert_register_field_array(expert_ctdb, ei, array_length(ei));\r\nctdb_transactions = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\nctdb_controls = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n}\r\nvoid\r\nproto_reg_handoff_ctdb(void)\r\n{\r\ndissector_handle_t ctdb_handle;\r\nctdb_handle = create_dissector_handle(dissect_ctdb, proto_ctdb);\r\ndissector_add_for_decode_as("tcp.port", ctdb_handle);\r\nheur_dissector_add("tcp", dissect_ctdb, "Cluster TDB over TCP", "ctdb_tcp", proto_ctdb, HEURISTIC_ENABLE);\r\n}
