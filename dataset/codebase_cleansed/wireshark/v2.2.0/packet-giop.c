static GList *insert_in_comp_req_list(GList *list, guint32 fn, guint32 reqid, const gchar * op, giop_sub_handle_t *sh, address *addr, guint32 port ) {\r\ncomp_req_list_entry_t *entry;\r\nentry = wmem_new(wmem_file_scope(), comp_req_list_entry_t);\r\nentry->fn = fn;\r\nentry->reqid = reqid;\r\nentry->subh = sh;\r\nentry->operation = wmem_strdup(wmem_file_scope(), op);\r\nentry->repoid = NULL;\r\nentry->srcport = port ;\r\ncopy_address_wmem (wmem_file_scope (), &entry->src, addr) ;\r\nreturn g_list_append (list, entry);\r\n}\r\nstatic comp_req_list_entry_t * find_fn_in_list(guint32 fn) {\r\nGList *element;\r\ncomp_req_list_entry_t *entry_ptr;\r\nelement = g_list_last(giop_complete_request_list);\r\nwhile (element) {\r\nentry_ptr = (comp_req_list_entry_t *)element->data;\r\nif (entry_ptr->fn == fn) {\r\nreturn entry_ptr;\r\n}\r\nelement = g_list_previous(element);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void add_sub_handle_repoid_to_comp_req_list(guint32 fn, giop_sub_handle_t *sh, gchar *repoid ) {\r\ncomp_req_list_entry_t * entry = NULL;\r\nentry = find_fn_in_list(fn);\r\nif (entry) {\r\nentry->subh = sh;\r\nentry->repoid = g_strdup(repoid);\r\n}\r\n}\r\nstatic gint complete_reply_equal_fn(gconstpointer v, gconstpointer w) {\r\nconst struct complete_reply_hash_key *mk1 = (const struct complete_reply_hash_key *)v;\r\nconst struct complete_reply_hash_key *mk2 = (const struct complete_reply_hash_key *)w;\r\nif (mk1->fn == mk2->fn) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic guint32 complete_reply_hash_fn(gconstpointer v) {\r\nguint32 val;\r\nconst struct complete_reply_hash_key *key = (const struct complete_reply_hash_key *)v;\r\nval = key->fn;\r\nreturn val;\r\n}\r\nstatic void insert_in_complete_reply_hash(guint32 fn, guint32 mfn) {\r\nstruct complete_reply_hash_key key, *new_key;\r\nstruct complete_reply_hash_val *val = NULL;\r\nkey.fn = fn;\r\nval = (struct complete_reply_hash_val *)g_hash_table_lookup(giop_complete_reply_hash, &key);\r\nif (val) {\r\nreturn;\r\n}\r\nnew_key = wmem_new(wmem_file_scope(), struct complete_reply_hash_key);\r\nnew_key->fn = fn;\r\nval = wmem_new(wmem_file_scope(), struct complete_reply_hash_val);\r\nval->mfn = mfn;\r\ng_hash_table_insert(giop_complete_reply_hash, new_key, val);\r\n}\r\nstatic guint32 get_mfn_from_fn(guint32 fn) {\r\nstruct complete_reply_hash_key key;\r\nstruct complete_reply_hash_val *val = NULL;\r\nguint32 mfn = fn;\r\nkey.fn = fn;\r\nval = (struct complete_reply_hash_val *)g_hash_table_lookup(giop_complete_reply_hash, &key);\r\nif (val) {\r\nmfn = val->mfn;\r\n}\r\nreturn mfn;\r\n}\r\nstatic guint32 get_mfn_from_fn_and_reqid(guint32 fn, guint32 reqid, address *addr, guint32 pnum) {\r\nGList *element;\r\ncomp_req_list_entry_t *entry_ptr = NULL;\r\nelement = g_list_last(giop_complete_request_list);\r\nwhile (element) {\r\nentry_ptr = (comp_req_list_entry_t *)element->data;\r\nif (entry_ptr->reqid == reqid && cmp_address (&entry_ptr->src, addr) == 0 && entry_ptr->srcport == pnum) {\r\nreturn entry_ptr->fn;\r\n}\r\nelement = g_list_previous(element);\r\n}\r\nreturn fn;\r\n}\r\nstatic gint giop_hash_module_equal(gconstpointer v, gconstpointer w) {\r\nconst struct giop_module_key *mk1 = (const struct giop_module_key *)v;\r\nconst struct giop_module_key *mk2 = (const struct giop_module_key *)w;\r\nif (strcmp(mk1->module, mk2->module) == 0) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic guint32 giop_hash_module_hash(gconstpointer v) {\r\nint i, len;\r\nguint32 val = 0;\r\nconst struct giop_module_key *key = (const struct giop_module_key *)v;\r\nlen = (int)strlen(key->module);\r\nfor (i=0; i<len; i++) {\r\nval += (guint8) key->module[i];\r\n}\r\nreturn val;\r\n}\r\nvoid register_giop_user_module(giop_sub_dissector_t *sub, const gchar *name, const gchar *module, int sub_proto) {\r\nstruct giop_module_key module_key, *new_module_key;\r\nstruct giop_module_val *module_val;\r\nmodule_key.module = module;\r\nmodule_val = (struct giop_module_val *)g_hash_table_lookup(giop_module_hash, &module_key);\r\nif (module_val) {\r\nreturn;\r\n}\r\n#if DEBUG\r\nprintf("giop:register_module: Adding Module %s to module hash \n", module);\r\nprintf("giop:register_module: Module sub dissector name is %s \n", name);\r\n#endif\r\nnew_module_key = (struct giop_module_key *)wmem_alloc(wmem_epan_scope(), sizeof(struct giop_module_key));\r\nnew_module_key->module = module;\r\nmodule_val = (struct giop_module_val *)wmem_alloc(wmem_epan_scope(), sizeof(struct giop_module_val));\r\nmodule_val->subh = (giop_sub_handle_t *)wmem_alloc(wmem_epan_scope(), sizeof (giop_sub_handle_t));\r\nmodule_val->subh->sub_name = name;\r\nmodule_val->subh->sub_fn = sub;\r\nmodule_val->subh->sub_proto = find_protocol_by_id(sub_proto);\r\ng_hash_table_insert(giop_module_hash, new_module_key, module_val);\r\n}\r\nstatic gint giop_hash_objkey_equal(gconstpointer v, gconstpointer w) {\r\nconst struct giop_object_key *v1 = (const struct giop_object_key *)v;\r\nconst struct giop_object_key *v2 = (const struct giop_object_key *)w;\r\nif (v1->objkey_len != v2->objkey_len)\r\nreturn 0;\r\nif (memcmp(v1->objkey, v2->objkey, v1->objkey_len) == 0) {\r\nreturn 1;\r\n}\r\n#if DEBUG\r\nprintf("giop:giop_hash_objkey_equal: Objkey's DO NOT match");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic guint32 giop_hash_objkey_hash(gconstpointer v) {\r\nconst struct giop_object_key *key = (const struct giop_object_key *)v;\r\nguint32 i;\r\nguint32 val = 0;\r\n#if DEBUG\r\nprintf("giop:hash_objkey: Key length = %u \n", key->objkey_len );\r\n#endif\r\nfor (i=0; i< key->objkey_len; i++) {\r\nval += (guint8) key->objkey[i];\r\n}\r\nreturn val;\r\n}\r\nstatic void insert_in_objkey_hash(GHashTable *hash, const gchar *obj, guint32 len, const gchar *repoid, ior_src_t src) {\r\nstruct giop_object_key objkey_key, *new_objkey_key;\r\nstruct giop_object_val *objkey_val;\r\nobjkey_key.objkey_len = len;\r\nobjkey_key.objkey = obj;\r\nobjkey_val = (struct giop_object_val *)g_hash_table_lookup(hash, &objkey_key);\r\nif (objkey_val) {\r\ng_hash_table_remove(hash, &objkey_key);\r\n}\r\nnew_objkey_key = wmem_new(wmem_file_scope(), struct giop_object_key);\r\nnew_objkey_key->objkey_len = len;\r\nnew_objkey_key->objkey = (guint8 *) wmem_memdup(wmem_file_scope(), obj, len);\r\nobjkey_val = wmem_new(wmem_file_scope(), struct giop_object_val);\r\nobjkey_val->repo_id = wmem_strdup(wmem_file_scope(), repoid);\r\nobjkey_val->src = src;\r\n#if DEBUG\r\nprintf("giop: ******* Inserting Objkey with RepoID = %s and key length = %u into hash \n",\r\nobjkey_val->repo_id, new_objkey_key->objkey_len);\r\n#endif\r\ng_hash_table_insert(hash, new_objkey_key, objkey_val);\r\n}\r\nstatic guint32 string_to_IOR(guchar *in, guint32 in_len, guint8 **out) {\r\ngint8 tmpval_lsb;\r\ngint8 tmpval_msb;\r\ngint8 tmpval;\r\nguint32 i;\r\n*out = wmem_alloc0_array(wmem_packet_scope(), guint8, in_len);\r\nif (*out == NULL) {\r\nreturn 0;\r\n}\r\nfor (i=4; i<in_len-1; i+=2) {\r\nif ( g_ascii_isxdigit(in[i]) && g_ascii_isxdigit(in[i+1]) ) {\r\nif ( (tmpval_msb = ws_xton(in[i])) < 0 ) {\r\nreport_failure("giop: Invalid value in IOR %i", tmpval_msb);\r\n}\r\nif ( (tmpval_lsb = ws_xton(in[i+1])) < 0 ) {\r\nreport_failure("giop: Invalid value in IOR %i", tmpval_lsb);\r\n}\r\ntmpval = tmpval_msb << 4;\r\ntmpval += tmpval_lsb;\r\n(*out)[(i-4)/2] = (guint8) tmpval;\r\n}\r\nelse {\r\nbreak;\r\n}\r\n}\r\nreturn (i-4)/2;\r\n}\r\nstatic int giop_getline(FILE *fp, gchar *line, int maxlen) {\r\nif (fgets(line, maxlen, fp) == NULL)\r\nreturn 0;\r\nelse\r\nreturn (int)strlen(line);\r\n}\r\nstatic void read_IOR_strings_from_file(const gchar *name, int max_iorlen) {\r\nguchar *buf;\r\nint len;\r\nint ior_val_len;\r\nFILE *fp;\r\nguint8 *out;\r\ntvbuff_t *tvb;\r\nguint32 my_offset = 0;\r\ngboolean stream_is_big_endian;\r\nfp = ws_fopen(name, "r");\r\nif (fp == NULL) {\r\nif (errno == EACCES)\r\nreport_open_failure(name, errno, FALSE);\r\nreturn;\r\n}\r\nbuf = (guchar *)wmem_alloc0(wmem_packet_scope(), max_iorlen+1);\r\nwhile ((len = giop_getline(fp, buf, max_iorlen+1)) > 0) {\r\nmy_offset = 0;\r\nior_val_len = string_to_IOR(buf, len, &out);\r\nif (ior_val_len>0) {\r\ntvb = tvb_new_real_data(out, ior_val_len, ior_val_len);\r\nstream_is_big_endian = !get_CDR_octet(tvb, &my_offset);\r\ndecode_IOR(tvb, NULL, NULL, &my_offset, 0, stream_is_big_endian);\r\ntvb_free(tvb);\r\n}\r\n}\r\nfclose(fp);\r\n}\r\nstatic void giop_init(void) {\r\ngiop_objkey_hash = g_hash_table_new(giop_hash_objkey_hash, giop_hash_objkey_equal);\r\ngiop_complete_reply_hash = g_hash_table_new(complete_reply_hash_fn, complete_reply_equal_fn);\r\ngiop_complete_request_list = NULL;\r\nread_IOR_strings_from_file(giop_ior_file, 600);\r\nreassembly_table_init(&giop_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void giop_cleanup(void) {\r\nreassembly_table_destroy(&giop_reassembly_table);\r\ng_hash_table_destroy(giop_objkey_hash);\r\ng_hash_table_destroy(giop_complete_reply_hash);\r\ng_list_free(giop_complete_request_list);\r\n}\r\nvoid register_giop_user(giop_sub_dissector_t *sub, const gchar *name, int sub_proto) {\r\ngiop_sub_handle_t *subh;\r\nsubh = (giop_sub_handle_t *)wmem_alloc(wmem_epan_scope(), sizeof (giop_sub_handle_t));\r\nsubh->sub_name = name;\r\nsubh->sub_fn = sub;\r\nsubh->sub_proto = find_protocol_by_id(sub_proto);\r\ngiop_sub_list = g_slist_append (giop_sub_list, subh);\r\n}\r\nstatic gchar * get_repoid_from_objkey(GHashTable *hash, const guint8 *obj, guint32 len) {\r\nstruct giop_object_key objkey_key;\r\nstruct giop_object_val *objkey_val;\r\nobjkey_key.objkey_len = len;\r\nobjkey_key.objkey = obj;\r\nobjkey_val = (struct giop_object_val *)g_hash_table_lookup(hash, &objkey_key);\r\nif (objkey_val) {\r\n#if DEBUG\r\nprintf("Lookup of object key returns RepoId = %s \n", objkey_val->repo_id );\r\n#endif\r\nreturn objkey_val->repo_id;\r\n}\r\n#if DEBUG\r\nprintf("FAILED Lookup of object key \n" );\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic gchar * get_modname_from_repoid(gchar *repoid) {\r\ngchar *modname;\r\ngchar c = 'a';\r\nguint8 stop_mod = 0;\r\nconst guint8 start_mod = 4;\r\nint i;\r\nif (g_ascii_strncasecmp("IDL:", repoid, 4))\r\nreturn NULL;\r\nfor (i=4; c != '\0'; i++) {\r\nc = repoid[i];\r\nstop_mod = i;\r\nif (c == ':' )\r\nbreak;\r\n}\r\nmodname = g_strndup(repoid+4, stop_mod - start_mod);\r\nreturn modname;\r\n}\r\nstatic void display_module_hash(gpointer key, gpointer val, gpointer user_data) {\r\nstruct giop_module_val *mv = (struct giop_module_val *) val;\r\nstruct giop_module_key *mk = (struct giop_module_key *) key;\r\nprintf("giop:module: Key = (%s) , Val = (%s) \n", mk->module, mv->subh->sub_name);\r\nreturn;\r\n}\r\nstatic void display_complete_reply_hash(gpointer key, gpointer val, gpointer user_data) {\r\nstruct complete_reply_hash_val *mv = (struct complete_reply_hash_val *) val;\r\nstruct complete_reply_hash_key *mk = (struct complete_reply_hash_key *) key;\r\nprintf("giop:complete_reply: FN (key) = %8u , MFN (val) = %8u \n", mk->fn, mv->mfn);\r\nreturn;\r\n}\r\nstatic void display_objkey_hash(gpointer key, gpointer val, gpointer user_data) {\r\nguint32 i;\r\nstruct giop_object_val *mv = (struct giop_object_val *) val;\r\nstruct giop_object_key *mk = (struct giop_object_key *) key;\r\nprintf("giop:objkey: Key->objkey_len = %u, Key->objkey ", mk->objkey_len);\r\nfor (i=0; i<mk->objkey_len; i++) {\r\nprintf("%.2x ", mk->objkey[i]);\r\n}\r\nif (mv->src == 0) {\r\nprintf(", Repo ID = %s \n", mv->repo_id);\r\n}\r\nelse {\r\nprintf(", Repo ID = %s , (file) \n", mv->repo_id);\r\n}\r\nreturn;\r\n}\r\nstatic void display_heuristic_user_list() {\r\nint i;\r\nint len;\r\ngiop_sub_handle_t *subh;\r\nlen = g_slist_length(giop_sub_list);\r\nif (len == 0)\r\nreturn;\r\nfor (i=0; i<len; i++) {\r\nsubh = ( giop_sub_handle_t *) g_slist_nth_data(giop_sub_list, i);\r\nprintf("giop:heuristic_user: Element = %i, Val (user) = %s \n", i, subh->sub_name);\r\n}\r\n}\r\nstatic void display_complete_request_list() {\r\nint i;\r\nint len;\r\ncomp_req_list_entry_t *entry;\r\nlen = g_list_length(giop_complete_request_list);\r\nif (len == 0)\r\nreturn;\r\nfor (i=0; i<len; i++) {\r\nentry = (comp_req_list_entry_t *) g_list_nth_data(giop_complete_request_list, i);\r\nprintf("giop:Index = %8i , FN = %8i, reqid = %8u , operation = %20s , repoid = %30s \n", i, entry->fn,\r\nentry->reqid, entry->operation, entry->repoid);\r\n}\r\n}\r\nstatic void giop_dump_collection(collection_data_t collection_type) {\r\nswitch (collection_type) {\r\ncase cd_heuristic_users:\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+-------------- Heuristic User (Begin) --------+ \n");\r\nprintf("+----------------------------------------------+ \n");\r\ndisplay_heuristic_user_list();\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+-------------- Heuristic User (End) ----------+ \n");\r\nprintf("+----------------------------------------------+ \n");\r\nbreak;\r\ncase cd_complete_request_list:\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+------------- Complete Request List (Begin) --+ \n");\r\nprintf("+----------------------------------------------+ \n");\r\ndisplay_complete_request_list();\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+------------ Complete Request List (End) -----+ \n");\r\nprintf("+----------------------------------------------+ \n");\r\nbreak;\r\ncase cd_module_hash:\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+-------------- Module (Begin) ----------------+ \n");\r\nprintf("+----------------------------------------------+ \n");\r\ng_hash_table_foreach(giop_module_hash, display_module_hash, NULL);\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+-------------- Module ( End) -----------------+ \n");\r\nprintf("+----------------------------------------------+ \n\n");\r\nbreak;\r\ncase cd_objkey_hash:\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+-------------- Objkey (Begin) ----------------+ \n");\r\nprintf("+----------------------------------------------+ \n");\r\ng_hash_table_foreach(giop_objkey_hash, display_objkey_hash, NULL);\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+-------------- Objkey (End) ------------------+ \n");\r\nprintf("+----------------------------------------------+ \n\n");\r\nbreak;\r\ncase cd_complete_reply_hash:\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+-------------- Complete_Reply_Hash (Begin) ---+ \n");\r\nprintf("+----------------------------------------------+ \n");\r\ng_hash_table_foreach(giop_complete_reply_hash, display_complete_reply_hash, NULL);\r\nprintf("+----------------------------------------------+ \n");\r\nprintf("+------------- Complete_Reply_Hash (End) ------+ \n");\r\nprintf("+----------------------------------------------+ \n");\r\nbreak;\r\ndefault:\r\nprintf("giop: giop_dump_collection: Unknown type \n");\r\n}\r\n}\r\nstatic gboolean try_heuristic_giop_dissector(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 *offset,\r\nMessageHeader *header, const gchar *operation ) {\r\nint i, len;\r\ngboolean res = FALSE;\r\ngiop_sub_handle_t *subh;\r\nconst char *saved_proto;\r\nlen = g_slist_length(giop_sub_list);\r\nif (len == 0)\r\nreturn FALSE;\r\n{\r\nguint32 message_size;\r\ngboolean stream_is_big_endian = is_big_endian (header);\r\nif (stream_is_big_endian)\r\nmessage_size = pntoh32 (&header->message_size);\r\nelse\r\nmessage_size = pletoh32 (&header->message_size);\r\nif (*offset > message_size)\r\nreturn FALSE;\r\n}\r\nsaved_proto = pinfo->current_proto;\r\nfor (i=0; i<len; i++) {\r\nsubh = (giop_sub_handle_t *) g_slist_nth_data(giop_sub_list, i);\r\nif (proto_is_protocol_enabled(subh->sub_proto)) {\r\npinfo->current_proto =\r\nproto_get_protocol_short_name(subh->sub_proto);\r\nres = (subh->sub_fn)(tvb, pinfo, tree, offset, header, operation, NULL);\r\nif (res) {\r\npinfo->current_proto = saved_proto;\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\ncol_set_str (pinfo->cinfo, COL_PROTOCOL, "GIOP");\r\npinfo->current_proto = saved_proto;\r\nreturn res;\r\n}\r\nstatic gboolean try_explicit_giop_dissector(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset,\r\nMessageHeader *header, const gchar *operation, gchar *repoid ) {\r\ngiop_sub_handle_t *subdiss;\r\ngboolean res = FALSE;\r\ngchar *modname;\r\nstruct giop_module_key module_key;\r\nstruct giop_module_val *module_val;\r\nconst char *saved_proto;\r\nmodname = get_modname_from_repoid(repoid);\r\nif (modname == NULL) {\r\nreturn res;\r\n}\r\nmodule_key.module = modname;\r\nmodule_val = (struct giop_module_val *)g_hash_table_lookup(giop_module_hash, &module_key);\r\nif (module_val == NULL) {\r\nreturn res;\r\n}\r\nsubdiss = (giop_sub_handle_t *) module_val->subh;\r\nif (subdiss) {\r\nif (!pinfo->fd->flags.visited)\r\nadd_sub_handle_repoid_to_comp_req_list(pinfo->num, subdiss, repoid);\r\nif (tvb_offset_exists(tvb, *offset)) {\r\n#if DEBUG\r\nprintf("giop:try_explicit_dissector calling sub = %s with module = (%s) \n", subdiss->sub_name , modname);\r\n#endif\r\nif (proto_is_protocol_enabled(subdiss->sub_proto)) {\r\nsaved_proto = pinfo->current_proto;\r\npinfo->current_proto =\r\nproto_get_protocol_short_name(subdiss->sub_proto);\r\nres = (subdiss->sub_fn)(tvb, pinfo, tree, offset, header, operation, modname);\r\npinfo->current_proto = saved_proto;\r\n}\r\n}\r\n}\r\nreturn res;\r\n}\r\ngchar *make_printable_string (const gchar *in, guint32 len) {\r\nguint32 i;\r\ngchar *print_string;\r\nprint_string = (gchar * )wmem_alloc0(wmem_packet_scope(), len + 1);\r\nmemcpy(print_string, in, len);\r\nfor (i=0; i < len; i++) {\r\nif ( !g_ascii_isprint( (unsigned char)print_string[i] ) )\r\nprint_string[i] = '.';\r\n}\r\nreturn print_string;\r\n}\r\ngboolean is_big_endian (MessageHeader * header) {\r\ngboolean big_endian = FALSE;\r\nswitch (header->GIOP_version.minor) {\r\ncase 2:\r\ncase 1:\r\nif (header->flags & GIOP_MESSAGE_FLAGS_ENDIANNESS)\r\nbig_endian = FALSE;\r\nelse\r\nbig_endian = TRUE;\r\nbreak;\r\ncase 0:\r\nif (header->flags)\r\nbig_endian = FALSE;\r\nelse\r\nbig_endian = TRUE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn big_endian;\r\n}\r\nstatic void set_new_alignment(int *offset, int delta, int alignment) {\r\nwhile ( ( (*offset + delta) % alignment) != 0)\r\n++(*offset);\r\n}\r\nstatic void dissect_data_for_typecode(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nproto_item *item, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary,\r\nMessageHeader * header, guint32 data_type ) {\r\ngboolean my_boolean;\r\ngint8 s_octet1;\r\nguint8 u_octet1;\r\ngint16 s_octet2;\r\nguint16 u_octet2;\r\ngint32 s_octet4;\r\nguint32 u_octet4;\r\ngint64 s_octet8;\r\nguint64 u_octet8;\r\ngdouble my_double;\r\ngfloat my_float;\r\nconst gchar *buf = NULL;\r\nswitch (data_type) {\r\ncase tk_null:\r\nbreak;\r\ncase tk_void:\r\nbreak;\r\ncase tk_short:\r\ns_octet2 = get_CDR_short(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_int(tree, hf_giop_type_short, tvb, *offset-2, 2, s_octet2);\r\nbreak;\r\ncase tk_long:\r\ns_octet4 = get_CDR_long(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_int(tree, hf_giop_type_long, tvb, *offset-4, 4, s_octet4);\r\nbreak;\r\ncase tk_ushort:\r\nu_octet2 = get_CDR_ushort(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_type_ushort, tvb, *offset-2, 2, u_octet2);\r\nbreak;\r\ncase tk_ulong:\r\nu_octet4 = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_type_ulong, tvb, *offset-4, 4, u_octet4);\r\nbreak;\r\ncase tk_float:\r\nmy_float = get_CDR_float(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_float(tree, hf_giop_type_float, tvb, *offset-4, 4, my_float);\r\nbreak;\r\ncase tk_double:\r\nmy_double = get_CDR_double(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_double(tree, hf_giop_type_double, tvb, *offset-8, 8, my_double);\r\nbreak;\r\ncase tk_boolean:\r\nmy_boolean = get_CDR_boolean(tvb, offset);\r\nproto_tree_add_boolean(tree, hf_giop_type_boolean, tvb, *offset-1, 1, my_boolean);\r\nbreak;\r\ncase tk_char:\r\nu_octet1 = get_CDR_char(tvb, offset);\r\nproto_tree_add_uint(tree, hf_giop_type_char, tvb, *offset-1, 1, u_octet1);\r\nbreak;\r\ncase tk_octet:\r\nu_octet1 = get_CDR_octet(tvb, offset);\r\nproto_tree_add_uint(tree, hf_giop_type_octet, tvb, *offset-1, 1, u_octet1);\r\nbreak;\r\ncase tk_any:\r\nget_CDR_any(tvb, pinfo, tree, item, offset, stream_is_big_endian, boundary, header);\r\nbreak;\r\ncase tk_TypeCode:\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, stream_is_big_endian, boundary, header);\r\nbreak;\r\ncase tk_Principal:\r\nbreak;\r\ncase tk_objref:\r\nbreak;\r\ncase tk_struct:\r\nbreak;\r\ncase tk_union:\r\nbreak;\r\ncase tk_enum:\r\nu_octet4 = get_CDR_enum(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_type_enum, tvb, *offset-4, 4, u_octet4);\r\nbreak;\r\ncase tk_string:\r\nu_octet4 = get_CDR_string(tvb, &buf, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_string_length, tvb,\r\n*offset-u_octet4-4, 4, u_octet4);\r\nif (u_octet4 > 0) {\r\nproto_tree_add_string(tree, hf_giop_type_string, tvb,\r\n*offset-u_octet4, u_octet4, buf);\r\n}\r\nbreak;\r\ncase tk_sequence:\r\nbreak;\r\ncase tk_array:\r\nbreak;\r\ncase tk_alias:\r\nbreak;\r\ncase tk_except:\r\nbreak;\r\ncase tk_longlong:\r\ns_octet8 = get_CDR_long_long(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_int64(tree, hf_giop_type_longlong, tvb, *offset-8, 8, s_octet8);\r\nbreak;\r\ncase tk_ulonglong:\r\nu_octet8 = get_CDR_ulong_long(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint64(tree, hf_giop_type_ulonglong, tvb, *offset-8, 8, u_octet8);\r\nbreak;\r\ncase tk_longdouble:\r\nbreak;\r\ncase tk_wchar:\r\ns_octet1 = get_CDR_wchar(tvb, &buf, offset, header);\r\nif (tree) {\r\nif (s_octet1 < 0) {\r\nproto_tree_add_string(tree, hf_giop_type_string, tvb,\r\n*offset+s_octet1, (-s_octet1), buf);\r\n} else {\r\nproto_tree_add_uint(tree, hf_giop_string_length, tvb,\r\n*offset-s_octet1-1, 1, s_octet1);\r\nproto_tree_add_string(tree, hf_giop_type_string, tvb,\r\n*offset-s_octet1, s_octet1, buf);\r\n}\r\n}\r\nbreak;\r\ncase tk_wstring:\r\nu_octet4 = get_CDR_wstring(tvb, &buf, offset, stream_is_big_endian, boundary, header);\r\nif (tree) {\r\nproto_tree_add_uint(tree, hf_giop_string_length, tvb,\r\n*offset-u_octet4-4, 4, u_octet4);\r\nproto_tree_add_string(tree, hf_giop_type_string, tvb,\r\n*offset-u_octet4, u_octet4, buf);\r\n}\r\nbreak;\r\ncase tk_fixed:\r\nbreak;\r\ncase tk_value:\r\nbreak;\r\ncase tk_value_box:\r\nbreak;\r\ncase tk_native:\r\nbreak;\r\ncase tk_abstract_interface:\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, item, &ei_giop_unknown_typecode_datatype, "Unknown typecode data type %u", data_type);\r\nbreak;\r\n}\r\n}\r\nstatic void dissect_typecode_string_param(tvbuff_t *tvb, proto_tree *tree, gint *offset,\r\ngboolean new_stream_is_big_endian, guint32 new_boundary, int hf_id ) {\r\nguint32 u_octet4;\r\nconst gchar *buf;\r\nu_octet4 = get_CDR_string(tvb, &buf, offset, new_stream_is_big_endian, new_boundary);\r\nproto_tree_add_uint(tree, hf_giop_string_length, tvb,\r\n*offset-u_octet4-4, 4, u_octet4);\r\nif (u_octet4 > 0) {\r\nproto_tree_add_string(tree, hf_id, tvb, *offset-u_octet4, u_octet4, buf);\r\n}\r\n}\r\nstatic void dissect_tk_objref_params(tvbuff_t *tvb, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\n}\r\nstatic void dissect_tk_struct_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary,\r\nMessageHeader * header ) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nguint32 count;\r\nguint32 i;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\ncount = get_CDR_ulong(tvb, offset, new_stream_is_big_endian, new_boundary);\r\nif (tree) {\r\nproto_tree_add_uint(tree, hf_giop_typecode_count, tvb,\r\n*offset-(int)sizeof(count), 4, count);\r\n}\r\nfor (i=0; i< count; i++) {\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_member_name);\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\n}\r\n}\r\nstatic void dissect_tk_union_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item* item,\r\ngint *offset, gboolean stream_is_big_endian, guint32 boundary,\r\nMessageHeader * header) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nguint32 TCKind;\r\ngint32 s_octet4;\r\nguint32 count;\r\nguint32 i;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\nTCKind = get_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\ns_octet4 = get_CDR_long(tvb, offset, new_stream_is_big_endian, new_boundary);\r\nproto_tree_add_int(tree, hf_giop_typecode_default_used, tvb,\r\n*offset-4, 4, s_octet4);\r\ncount = get_CDR_ulong(tvb, offset, new_stream_is_big_endian, new_boundary);\r\nproto_tree_add_uint(tree, hf_giop_typecode_count, tvb, *offset-4, 4, count);\r\nfor (i=0; i< count; i++) {\r\ndissect_data_for_typecode(tvb, pinfo, tree, item, offset, new_stream_is_big_endian, new_boundary, header, TCKind );\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_member_name);\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\n}\r\n}\r\nstatic void dissect_tk_enum_params(tvbuff_t *tvb, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nguint32 count;\r\nguint32 i;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\ncount = get_CDR_ulong(tvb, offset, new_stream_is_big_endian, new_boundary);\r\nproto_tree_add_uint(tree, hf_giop_typecode_count, tvb,\r\n*offset-4, 4, count);\r\nfor (i=0; i< count; i++) {\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_member_name);\r\n}\r\n}\r\nstatic void dissect_tk_sequence_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary,\r\nMessageHeader * header) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nguint32 u_octet4;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\nu_octet4 = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_typecode_max_length, tvb,\r\n*offset-4, 4, u_octet4);\r\n}\r\nstatic void dissect_tk_array_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary,\r\nMessageHeader * header) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nguint32 u_octet4;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\nu_octet4 = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_typecode_length, tvb,\r\n*offset-4, 4, u_octet4);\r\n}\r\nstatic void dissect_tk_alias_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary,\r\nMessageHeader * header) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\n}\r\nstatic void dissect_tk_except_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary,\r\nMessageHeader * header) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nguint32 count;\r\nguint32 i;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\ncount = get_CDR_ulong(tvb, offset, new_stream_is_big_endian, new_boundary);\r\nif (tree) {\r\nproto_tree_add_uint(tree, hf_giop_typecode_count, tvb,\r\n*offset-(int)sizeof(count), 4, count);\r\n}\r\nfor (i=0; i< count; i++) {\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_member_name);\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\n}\r\n}\r\nstatic void dissect_tk_value_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary,\r\nMessageHeader * header) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\ngint16 s_octet2;\r\nguint32 count;\r\nguint32 i;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\ns_octet2 = get_CDR_short(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_int(tree, hf_giop_typecode_ValueModifier, tvb,\r\n*offset-2, 2, s_octet2);\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\ncount = get_CDR_ulong(tvb, offset, new_stream_is_big_endian, new_boundary);\r\nproto_tree_add_uint(tree, hf_giop_typecode_count, tvb,\r\n*offset-4, 4, count);\r\nfor (i=0; i< count; i++) {\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_member_name);\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\ns_octet2 = get_CDR_short(tvb, offset, stream_is_big_endian, boundary);\r\nif (tree) {\r\nproto_tree_add_int(tree, hf_giop_typecode_Visibility, tvb,\r\n*offset-(int)sizeof(s_octet2), 2, s_octet2);\r\n}\r\n}\r\n}\r\nstatic void dissect_tk_value_box_params(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary,\r\nMessageHeader * header) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\nget_CDR_typeCode(tvb, pinfo, tree, offset, new_stream_is_big_endian, new_boundary, header);\r\n}\r\nstatic void dissect_tk_native_params(tvbuff_t *tvb, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\n}\r\nstatic void dissect_tk_abstract_interface_params(tvbuff_t *tvb, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian, guint32 boundary) {\r\nguint32 new_boundary;\r\ngboolean new_stream_is_big_endian;\r\nget_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_stream_is_big_endian, &new_boundary);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_repoid);\r\ndissect_typecode_string_param(tvb, tree, offset, new_stream_is_big_endian, new_boundary,\r\nhf_giop_typecode_name);\r\n}\r\nguint32 get_CDR_encap_info(tvbuff_t *tvb, proto_tree *tree, gint *offset,\r\ngboolean old_stream_is_big_endian, guint32 old_boundary,\r\ngboolean *new_stream_is_big_endian_ptr, guint32 *new_boundary_ptr ) {\r\nguint32 seqlen;\r\nguint8 giop_endianness;\r\nseqlen = get_CDR_ulong(tvb, offset, old_stream_is_big_endian, old_boundary);\r\nproto_tree_add_uint(tree, hf_giop_sequence_length, tvb,\r\n*offset-(int)sizeof(seqlen), 4, seqlen);\r\nif (seqlen == 0) {\r\n*new_boundary_ptr = old_boundary;\r\n*new_stream_is_big_endian_ptr = old_stream_is_big_endian;\r\nreturn seqlen;\r\n}\r\n*new_boundary_ptr = *offset;\r\ngiop_endianness = get_CDR_octet(tvb, offset);\r\n*new_stream_is_big_endian_ptr = ! giop_endianness;\r\nproto_tree_add_uint(tree, hf_giop_endianness, tvb,\r\n*offset-1, 1, giop_endianness);\r\nreturn seqlen;\r\n}\r\nvoid get_CDR_any(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_item *item,\r\ngint *offset, gboolean stream_is_big_endian, int boundary,\r\nMessageHeader * header ) {\r\nguint32 TCKind;\r\nTCKind = get_CDR_typeCode(tvb, pinfo, tree, offset, stream_is_big_endian, boundary, header );\r\ndissect_data_for_typecode(tvb, pinfo, tree, item, offset, stream_is_big_endian, boundary, header, TCKind );\r\n}\r\ngboolean get_CDR_boolean(tvbuff_t *tvb, int *offset) {\r\nguint8 val;\r\nval = tvb_get_guint8(tvb, *offset);\r\n(*offset)++;\r\nreturn val;\r\n}\r\nguint8 get_CDR_char(tvbuff_t *tvb, int *offset) {\r\nguint8 val;\r\nval = tvb_get_guint8(tvb, *offset);\r\n(*offset)++;\r\nreturn val;\r\n}\r\ngdouble get_CDR_double(tvbuff_t *tvb, int *offset, gboolean stream_is_big_endian, int boundary) {\r\ngdouble val;\r\nwhile ( ( (*offset + boundary) % 8) != 0)\r\n++(*offset);\r\nval = (stream_is_big_endian) ? tvb_get_ntohieee_double (tvb, *offset) :\r\ntvb_get_letohieee_double (tvb, *offset);\r\n*offset += 8;\r\nreturn val;\r\n}\r\nguint32 get_CDR_enum(tvbuff_t *tvb, int *offset, gboolean stream_is_big_endian, int boundary) {\r\nreturn get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary );\r\n}\r\nvoid get_CDR_fixed(tvbuff_t *tvb, packet_info *pinfo, proto_item *item, gchar **seq,\r\ngint *offset, guint32 digits, gint32 scale) {\r\nguint8 sign;\r\nguint32 i ;\r\nguint32 slen;\r\nguint32 sindex = 0;\r\ngchar *tmpbuf;\r\nguint8 tval;\r\n#if DEBUG\r\nprintf("giop:get_CDR_fixed() called , digits = %u, scale = %u \n", digits, scale);\r\n#endif\r\nif (scale <0) {\r\nslen = digits - scale;\r\n} else {\r\nslen = digits;\r\n}\r\n#if DEBUG\r\nprintf("giop:get_CDR_fixed(): slen = %.2x \n", slen);\r\n#endif\r\ntmpbuf = (gchar *)wmem_alloc0(wmem_packet_scope(), slen);\r\nif (!(digits & 0x01)) {\r\ntval = get_CDR_octet(tvb, offset);\r\n#if DEBUG\r\nprintf("giop:get_CDR_fixed():even: octet = %.2x \n", tval);\r\n#endif\r\ntmpbuf[sindex] = (tval & 0x0f) + 0x30;\r\nsindex++;\r\n}\r\nif (digits>2) {\r\nfor (i=0; i< ((digits-1)/2 ); i++) {\r\ntval = get_CDR_octet(tvb, offset);\r\n#if DEBUG\r\nprintf("giop:get_CDR_fixed():odd: octet = %.2x \n", tval);\r\n#endif\r\ntmpbuf[sindex] = ((tval & 0xf0) >> 4) + 0x30;\r\nsindex++;\r\ntmpbuf[sindex] = (tval & 0x0f) + 0x30;\r\nsindex++;\r\n}\r\n}\r\n#if DEBUG\r\nprintf("giop:get_CDR_fixed(): before last digit \n");\r\n#endif\r\ntval = get_CDR_octet(tvb, offset);\r\n#if DEBUG\r\nprintf("giop:get_CDR_fixed(): octet = %.2x \n", tval);\r\n#endif\r\ntmpbuf[sindex] = (( tval & 0xf0)>> 4) + 0x30;\r\nsindex++;\r\nsign = tval & 0x0f;\r\nsindex = 0;\r\n*seq = wmem_alloc0_array(wmem_packet_scope(), gchar, slen + 3);\r\n#if DEBUG\r\nprintf("giop:get_CDR_fixed(): sign = %.2x \n", sign);\r\n#endif\r\nswitch (sign) {\r\ncase 0x0c:\r\n(*seq)[sindex] = '+';\r\nbreak;\r\ncase 0x0d:\r\n(*seq)[sindex] = '-';\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, item, &ei_giop_unknown_sign_value,\r\n"Unknown sign value in fixed type %u", sign);\r\n(*seq)[sindex] = '*';\r\nbreak;\r\n}\r\nsindex++;\r\nif (scale>0) {\r\nfor (i=0; i<digits-scale; i++) {\r\n(*seq)[sindex] = tmpbuf[i];\r\nsindex++;\r\n}\r\n(*seq)[sindex] = '.';\r\nsindex++;\r\nfor (i=digits-scale; i<digits; i++) {\r\n(*seq)[sindex] = tmpbuf[i];\r\nsindex++;\r\n}\r\n(*seq)[sindex] = '\0';\r\n} else {\r\nfor (i=0; i<digits-scale; i++) {\r\nif (i<digits) {\r\n(*seq)[sindex] = tmpbuf[i];\r\n} else {\r\n(*seq)[sindex] = '0';\r\n}\r\nsindex++;\r\n}\r\n(*seq)[sindex] = '\0';\r\n}\r\n#if DEBUG\r\nprintf("giop:get_CDR_fixed(): value = %s \n", *seq);\r\n#endif\r\nreturn;\r\n}\r\ngfloat get_CDR_float(tvbuff_t *tvb, int *offset, gboolean stream_is_big_endian, int boundary) {\r\ngfloat val;\r\nwhile ( ( (*offset + boundary) % 4) != 0)\r\n++(*offset);\r\nval = (stream_is_big_endian) ? tvb_get_ntohieee_float (tvb, *offset) :\r\ntvb_get_letohieee_float (tvb, *offset);\r\n*offset += 4;\r\nreturn val;\r\n}\r\nvoid get_CDR_interface(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset,\r\ngboolean stream_is_big_endian, int boundary) {\r\ndecode_IOR(tvb, pinfo, tree, offset, boundary, stream_is_big_endian);\r\nreturn;\r\n}\r\ngint32 get_CDR_long(tvbuff_t *tvb, int *offset, gboolean stream_is_big_endian, int boundary) {\r\ngint32 val;\r\nwhile ( ( (*offset + boundary) % 4) != 0)\r\n++(*offset);\r\nval = (stream_is_big_endian) ? tvb_get_ntohl (tvb, *offset) :\r\ntvb_get_letohl (tvb, *offset);\r\n*offset += 4;\r\nreturn val;\r\n}\r\ngint64 get_CDR_long_long(tvbuff_t *tvb, int *offset, gboolean stream_is_big_endian, int boundary) {\r\ngint64 val;\r\nwhile ( ( (*offset + boundary) % 8) != 0)\r\n++(*offset);\r\nval = (stream_is_big_endian) ? tvb_get_ntoh64 (tvb, *offset) :\r\ntvb_get_letoh64 (tvb, *offset);\r\n*offset += 8;\r\nreturn val;\r\n}\r\nvoid get_CDR_object(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset,\r\ngboolean stream_is_big_endian, int boundary) {\r\ndecode_IOR(tvb, pinfo, tree, offset, boundary, stream_is_big_endian);\r\nreturn;\r\n}\r\nguint8 get_CDR_octet(tvbuff_t *tvb, int *offset) {\r\nguint8 val;\r\nval = tvb_get_guint8(tvb, *offset);\r\n(*offset)++;\r\nreturn val;\r\n}\r\nvoid get_CDR_octet_seq(tvbuff_t *tvb, const gchar **seq, int *offset, guint32 len) {\r\nguint8 *seq_buf;\r\ntvb_ensure_bytes_exist(tvb, *offset, len);\r\nseq_buf = wmem_alloc0_array(wmem_packet_scope(), gchar, len + 1);\r\ntvb_memcpy( tvb, seq_buf, *offset, len);\r\n*seq = seq_buf;\r\n*offset += len;\r\n}\r\ngint16 get_CDR_short(tvbuff_t *tvb, int *offset, gboolean stream_is_big_endian, int boundary) {\r\ngint16 val;\r\nwhile ( ( (*offset + boundary) % 2) != 0)\r\n++(*offset);\r\nval = (stream_is_big_endian) ? tvb_get_ntohs (tvb, *offset) :\r\ntvb_get_letohs (tvb, *offset);\r\n*offset += 2;\r\nreturn val;\r\n}\r\nvoid\r\ngiop_add_CDR_string(proto_tree *tree, tvbuff_t *tvb, int *offset,\r\ngboolean stream_is_big_endian, int boundary, int hf)\r\n{\r\nguint32 u_octet4;\r\nconst gchar *seq = NULL;\r\nu_octet4 = get_CDR_string(tvb, &seq, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_string(tree, hf, tvb, *offset-u_octet4, u_octet4, (u_octet4 > 0) ? seq : "");\r\n}\r\nguint32 get_CDR_string(tvbuff_t *tvb, const gchar **seq, int *offset, gboolean stream_is_big_endian,\r\nint boundary ) {\r\nguint32 slength;\r\ngint reported_length;\r\nslength = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\n#if 0\r\n(*offset)++;\r\n#endif\r\nreported_length = tvb_reported_length_remaining(tvb, *offset-4);\r\nif (slength > (guint32)reported_length) {\r\nget_CDR_octet_seq(tvb, seq, offset, reported_length);\r\nreturn reported_length;\r\n}\r\nelse if (slength > 0) {\r\nget_CDR_octet_seq(tvb, seq, offset, slength);\r\nif ((*seq)[slength-1] == '\0') {\r\nslength--;\r\n}\r\n} else {\r\n*seq = wmem_strdup(wmem_packet_scope(), "");\r\n}\r\nreturn slength;\r\n}\r\nguint32 get_CDR_typeCode(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree,\r\ngint *offset, gboolean stream_is_big_endian,\r\nint boundary, MessageHeader * header ) {\r\nguint32 val;\r\ngint16 s_octet2;\r\nguint16 u_octet2;\r\nguint32 u_octet4;\r\nproto_item *ti;\r\nval = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nti = proto_tree_add_uint(tree, hf_giop_TCKind, tvb, *offset-4, 4, val);\r\nswitch (val) {\r\ncase tk_null:\r\nbreak;\r\ncase tk_void:\r\nbreak;\r\ncase tk_short:\r\nbreak;\r\ncase tk_long:\r\nbreak;\r\ncase tk_ushort:\r\nbreak;\r\ncase tk_ulong:\r\nbreak;\r\ncase tk_float:\r\nbreak;\r\ncase tk_double:\r\nbreak;\r\ncase tk_boolean:\r\nbreak;\r\ncase tk_char:\r\nbreak;\r\ncase tk_octet:\r\nbreak;\r\ncase tk_any:\r\nbreak;\r\ncase tk_TypeCode:\r\nbreak;\r\ncase tk_Principal:\r\nbreak;\r\ncase tk_objref:\r\ndissect_tk_objref_params(tvb, tree, offset, stream_is_big_endian, boundary);\r\nbreak;\r\ncase tk_struct:\r\ndissect_tk_struct_params(tvb, pinfo, tree, offset, stream_is_big_endian, boundary, header );\r\nbreak;\r\ncase tk_union:\r\ndissect_tk_union_params(tvb, pinfo, tree, ti, offset, stream_is_big_endian, boundary, header );\r\nbreak;\r\ncase tk_enum:\r\ndissect_tk_enum_params(tvb, tree, offset, stream_is_big_endian, boundary);\r\nbreak;\r\ncase tk_string:\r\nu_octet4 = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nif (tree) {\r\nproto_tree_add_uint(tree, hf_giop_typecode_max_length, tvb,\r\n*offset-(int)sizeof(u_octet4), 4, u_octet4);\r\n}\r\nbreak;\r\ncase tk_sequence:\r\ndissect_tk_sequence_params(tvb, pinfo, tree, offset, stream_is_big_endian, boundary, header );\r\nbreak;\r\ncase tk_array:\r\ndissect_tk_array_params(tvb, pinfo, tree, offset, stream_is_big_endian, boundary, header );\r\nbreak;\r\ncase tk_alias:\r\ndissect_tk_alias_params(tvb, pinfo, tree, offset, stream_is_big_endian, boundary, header );\r\nbreak;\r\ncase tk_except:\r\ndissect_tk_except_params(tvb, pinfo, tree, offset, stream_is_big_endian, boundary, header );\r\nbreak;\r\ncase tk_longlong:\r\nbreak;\r\ncase tk_ulonglong:\r\nbreak;\r\ncase tk_longdouble:\r\nbreak;\r\ncase tk_wchar:\r\nbreak;\r\ncase tk_wstring:\r\nu_octet4 = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nif (tree) {\r\nproto_tree_add_uint(tree, hf_giop_typecode_max_length, tvb,\r\n*offset-(int)sizeof(u_octet4), 4, u_octet4);\r\n}\r\nbreak;\r\ncase tk_fixed:\r\nu_octet2 = get_CDR_ushort(tvb, offset, stream_is_big_endian, boundary);\r\nif (tree) {\r\nproto_tree_add_uint(tree, hf_giop_typecode_digits, tvb,\r\n*offset-(int)sizeof(u_octet2), 2, u_octet2);\r\n}\r\ns_octet2 = get_CDR_short(tvb, offset, stream_is_big_endian, boundary);\r\nif (tree) {\r\nproto_tree_add_int(tree, hf_giop_typecode_scale, tvb,\r\n*offset-(int)sizeof(s_octet2), 2, s_octet2);\r\n}\r\nbreak;\r\ncase tk_value:\r\ndissect_tk_value_params(tvb, pinfo, tree, offset, stream_is_big_endian, boundary, header );\r\nbreak;\r\ncase tk_value_box:\r\ndissect_tk_value_box_params(tvb, pinfo, tree, offset, stream_is_big_endian, boundary, header );\r\nbreak;\r\ncase tk_native:\r\ndissect_tk_native_params(tvb, tree, offset, stream_is_big_endian, boundary);\r\nbreak;\r\ncase tk_abstract_interface:\r\ndissect_tk_abstract_interface_params(tvb, tree, offset, stream_is_big_endian, boundary );\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, ti, &ei_giop_unknown_tckind, "Unknown TCKind %u", val);\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nguint32 get_CDR_ulong(tvbuff_t *tvb, int *offset, gboolean stream_is_big_endian, int boundary) {\r\nguint32 val;\r\nwhile ( ( (*offset + boundary) % 4) != 0)\r\n++(*offset);\r\nval = (stream_is_big_endian) ? tvb_get_ntohl (tvb, *offset) :\r\ntvb_get_letohl (tvb, *offset);\r\n*offset += 4;\r\nreturn val;\r\n}\r\nguint64 get_CDR_ulong_long(tvbuff_t *tvb, int *offset, gboolean stream_is_big_endian, int boundary) {\r\nguint64 val;\r\nwhile ( ( (*offset + boundary) % 8) != 0)\r\n++(*offset);\r\nval = (stream_is_big_endian) ? tvb_get_ntoh64 (tvb, *offset) :\r\ntvb_get_letoh64 (tvb, *offset);\r\n*offset += 8;\r\nreturn val;\r\n}\r\nguint16 get_CDR_ushort(tvbuff_t *tvb, int *offset, gboolean stream_is_big_endian, int boundary) {\r\nguint16 val;\r\nwhile ( ( (*offset + boundary) % 2) != 0)\r\n++(*offset);\r\nval = (stream_is_big_endian) ? tvb_get_ntohs (tvb, *offset) :\r\ntvb_get_letohs (tvb, *offset);\r\n*offset += 2;\r\nreturn val;\r\n}\r\ngint get_CDR_wchar(tvbuff_t *tvb, const gchar **seq, int *offset, MessageHeader * header) {\r\ngint slength;\r\nconst gchar *raw_wstring;\r\n*seq = NULL;\r\nslength = 2;\r\nif (header->GIOP_version.minor > 1)\r\nslength = get_CDR_octet(tvb, offset);\r\nif (slength > 0) {\r\nget_CDR_octet_seq(tvb, &raw_wstring, offset, slength);\r\n*seq = make_printable_string(raw_wstring, slength);\r\n}\r\nif (header->GIOP_version.minor < 2)\r\nslength = -slength;\r\nreturn slength;\r\n}\r\nguint32 get_CDR_wstring(tvbuff_t *tvb, const gchar **seq, int *offset, gboolean stream_is_big_endian,\r\nint boundary, MessageHeader * header) {\r\nguint32 slength;\r\ngint reported_length;\r\nconst gchar *raw_wstring;\r\n*seq = NULL;\r\nslength = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\n#ifdef DEBUG\r\nif (slength>200) {\r\nfprintf(stderr, "giop:get_CDR_wstring, length %u > 200, truncating to 5 \n", slength);\r\nslength = 5;\r\n}\r\n#endif\r\nif (header->GIOP_version.minor < 2) {\r\n#if 0\r\n(*offset)++;\r\n#endif\r\nslength = slength * 2;\r\n}\r\nreported_length = tvb_reported_length_remaining(tvb, *offset-4);\r\nif (slength > (guint32)reported_length) {\r\nslength = reported_length;\r\n}\r\nif (slength > 0) {\r\nget_CDR_octet_seq(tvb, &raw_wstring, offset, slength);\r\n*seq = make_printable_string(raw_wstring, slength);\r\n}\r\nreturn slength;\r\n}\r\nstatic void\r\ndissect_target_address(tvbuff_t * tvb, packet_info *pinfo, int *offset, proto_tree * tree,\r\ngboolean stream_is_big_endian, guint32 *object_key_len,\r\nconst gchar **object_key_val)\r\n{\r\nguint16 discriminant;\r\nconst gchar *object_key = NULL;\r\nguint32 len = 0;\r\nguint32 u_octet4;\r\nproto_item* ti;\r\ndiscriminant = get_CDR_ushort(tvb, offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nproto_tree_add_uint (tree, hf_giop_target_address_discriminant, tvb, *offset -2, 2, discriminant);\r\nswitch (discriminant)\r\n{\r\ncase 0:\r\nlen = get_CDR_ulong(tvb, offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nti = proto_tree_add_uint (tree, hf_giop_target_address_key_addr_len, tvb, *offset -4, 4, len);\r\nif (len > (guint32)tvb_reported_length_remaining(tvb, *offset-4)) {\r\nexpert_add_info_format(pinfo, ti, &ei_giop_length_too_big, "KeyAddr key length bigger than packet size");\r\nreturn;\r\n}\r\nif (len > 0) {\r\nget_CDR_octet_seq(tvb, &object_key, offset, len);\r\nproto_tree_add_string(tree, hf_giop_target_address_key_addr, tvb, *offset - len,\r\nlen, make_printable_string( object_key, len ));\r\nif (object_key_len) {\r\n*object_key_len = len;\r\n}\r\nif (object_key_val) {\r\n*object_key_val = object_key;\r\n}\r\n}\r\nbreak;\r\ncase 1:\r\ndecode_TaggedProfile(tvb, pinfo, tree, offset, GIOP_HEADER_SIZE,\r\nstream_is_big_endian, NULL);\r\nbreak;\r\ncase 2:\r\nu_octet4 = get_CDR_ulong(tvb, offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nproto_tree_add_uint (tree, hf_giop_target_address_ref_addr_len, tvb, *offset -4, 4, u_octet4);\r\ndecode_IOR(tvb, pinfo, tree, offset, GIOP_HEADER_SIZE, stream_is_big_endian);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void decode_CodeSetServiceContext(tvbuff_t *tvb, proto_tree *tree,\r\nint *offset, gboolean stream_is_be,\r\nguint32 boundary) {\r\nguint32 code_set_id;\r\ncode_set_id = get_CDR_ulong(tvb, offset, stream_is_be, -((gint32) boundary) );\r\nproto_tree_add_uint(tree, hf_giop_char_data, tvb, *offset - 4, 4, code_set_id);\r\ncode_set_id = get_CDR_ulong(tvb, offset, stream_is_be, -((gint32) boundary) );\r\nproto_tree_add_uint(tree, hf_giop_wchar_data, tvb, *offset - 4, 4, code_set_id);\r\n}\r\nstatic void decode_RTCorbaPriority(tvbuff_t *tvb, proto_tree *tree, int *offset,\r\ngboolean stream_is_be, guint32 boundary) {\r\ngint16 rtpriority;\r\nrtpriority = get_CDR_short(tvb, offset, stream_is_be, -((gint32) boundary) );\r\nproto_tree_add_uint(tree, hf_giop_rt_corba_priority, tvb, *offset - 2, 2, rtpriority);\r\n}\r\nstatic void decode_UnknownServiceContext(tvbuff_t *tvb, proto_tree *tree,\r\nint *offset, gboolean stream_is_be _U_,\r\nguint32 boundary _U_,\r\nguint32 context_data_len) {\r\nconst gchar *context_data;\r\nif (context_data_len == 0)\r\nreturn;\r\nget_CDR_octet_seq(tvb, &context_data, offset, context_data_len);\r\nproto_tree_add_string(tree, hf_giop_context_data, tvb, *offset - context_data_len ,\r\ncontext_data_len, make_printable_string( context_data, context_data_len));\r\n}\r\nstatic void decode_ServiceContextList(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *ptree, int *offset,\r\ngboolean stream_is_be, guint32 boundary) {\r\nguint32 seqlen;\r\nguint32 context_data_len;\r\nproto_tree *tree;\r\nproto_item *tf;\r\nproto_item *sc_item;\r\nproto_tree *sc_tree;\r\nguint32 context_id;\r\nguint32 i;\r\nguint32 vscid;\r\nguint32 scid;\r\ngboolean encapsulation_is_be;\r\nguint32 encapsulation_boundary;\r\nint temp_offset;\r\nint start_offset = *offset;\r\nint dissected_len;\r\ntree = proto_tree_add_subtree(ptree, tvb, *offset, -1, ett_giop_scl, &tf, "ServiceContextList");\r\nseqlen = get_CDR_ulong(tvb, offset, stream_is_be, boundary);\r\nproto_tree_add_uint(tree, hf_giop_sequence_length, tvb,\r\n*offset-(int)sizeof(seqlen), 4, seqlen);\r\nif (seqlen == 0) {\r\nif (*offset-start_offset > 0) {\r\nproto_item_set_len(tf, *offset - start_offset);\r\n}\r\nreturn;\r\n}\r\nfor (i=0; i<seqlen; i++) {\r\ncontext_id = get_CDR_ulong(tvb, offset, stream_is_be, boundary);\r\nsc_item = proto_tree_add_item(tree, hf_giop_iiop_sc, tvb, *offset-4, -1, ENC_NA);\r\nsc_tree = proto_item_add_subtree (sc_item, ett_giop_sc);\r\nvscid = (context_id & 0xffffff00) >> 8;\r\nscid = context_id & 0x000000ff;\r\nproto_tree_add_uint(sc_tree, hf_giop_iiop_sc_vscid, tvb,\r\n*offset-4, 4, vscid);\r\nif (vscid == 0)\r\n{\r\nproto_tree_add_uint(sc_tree, hf_giop_iiop_sc_omg_scid, tvb,\r\n*offset-4, 4, scid);\r\n}\r\nelse\r\n{\r\nproto_tree_add_uint(sc_tree, hf_giop_iiop_sc_vendor_scid, tvb,\r\n*offset-4, 4, scid);\r\n}\r\ntemp_offset = *offset;\r\ncontext_data_len = get_CDR_encap_info(tvb, sc_tree, offset,\r\nstream_is_be, boundary,\r\n&encapsulation_is_be,\r\n&encapsulation_boundary);\r\nif (context_data_len != 0)\r\n{\r\nif ( vscid != 0)\r\n{\r\ndecode_UnknownServiceContext(tvb, sc_tree, offset, encapsulation_is_be,\r\nencapsulation_boundary,\r\ncontext_data_len - 1);\r\n}\r\nelse\r\n{\r\nswitch (scid)\r\n{\r\ncase 0x01:\r\ndecode_CodeSetServiceContext(tvb, sc_tree, offset,\r\nencapsulation_is_be,\r\nencapsulation_boundary);\r\nbreak;\r\ncase 0x0a:\r\ndecode_RTCorbaPriority(tvb, sc_tree, offset,\r\nencapsulation_is_be, encapsulation_boundary);\r\nbreak;\r\ndefault:\r\ndecode_UnknownServiceContext(tvb, sc_tree, offset,\r\nencapsulation_is_be,\r\nencapsulation_boundary,\r\ncontext_data_len - 1);\r\nbreak;\r\n}\r\n}\r\n}\r\ndissected_len = *offset - (temp_offset + 4);\r\nif ((guint32)dissected_len > context_data_len)\r\n{\r\n*offset = temp_offset + 4 + context_data_len;\r\n}\r\nelse if ((guint32)dissected_len < context_data_len)\r\n{\r\ntvb_ensure_bytes_exist(tvb, *offset, context_data_len - dissected_len);\r\n*offset = temp_offset + 4 + context_data_len;\r\n}\r\nproto_item_set_end(sc_item, tvb, *offset);\r\n}\r\nproto_item_set_len(tf, *offset - start_offset);\r\n}\r\nstatic void\r\ndissect_reply_body (tvbuff_t *tvb, guint offset, packet_info *pinfo,\r\nproto_tree *tree, gboolean stream_is_big_endian,\r\nguint32 reply_status, MessageHeader *header, proto_tree *giop_tree) {\r\nguint sequence_length;\r\ngboolean exres = FALSE;\r\ngint reply_body_length;\r\ncomp_req_list_entry_t *entry = NULL;\r\nguint32 mfn;\r\nswitch (reply_status)\r\n{\r\ncase SYSTEM_EXCEPTION:\r\ndecode_SystemExceptionReplyBody (tvb, tree, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nbreak;\r\ncase USER_EXCEPTION:\r\nsequence_length = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nproto_tree_add_uint(tree, hf_giop_exception_len, tvb, offset-4, 4,\r\nsequence_length);\r\nif (sequence_length != 0 && sequence_length < ITEM_LABEL_LENGTH)\r\n{\r\nheader->exception_id = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &sequence_length, ENC_ASCII);\r\nproto_tree_add_string(tree, hf_giop_exception_id, tvb, offset,\r\nsequence_length, header->exception_id);\r\noffset += sequence_length;\r\n}\r\ncase NO_EXCEPTION:\r\nmfn = get_mfn_from_fn(pinfo->num);\r\nif (mfn == pinfo->num)\r\nreturn;\r\nentry = find_fn_in_list(mfn);\r\nif (!entry)\r\nreturn;\r\nif (!strcmp(giop_op_resolve, entry->operation)) {\r\ndecode_IOR(tvb, pinfo, tree, &offset, GIOP_HEADER_SIZE, stream_is_big_endian);\r\nreturn;\r\n}\r\nif (entry->repoid) {\r\nexres = try_explicit_giop_dissector(tvb, pinfo, giop_tree, &offset, header, entry->operation, entry->repoid );\r\n}\r\nif (! exres) {\r\nexres = try_heuristic_giop_dissector(tvb, pinfo, giop_tree, &offset, header, entry->operation);\r\n}\r\nif (!exres && !strcmp(giop_op_is_a, entry->operation)) {\r\nproto_tree_add_boolean(tree, hf_giop_type_id_match, tvb, offset - 1, 1,\r\nget_CDR_boolean(tvb, &offset));\r\n}\r\nif (! exres) {\r\ngint stub_length = tvb_reported_length_remaining(tvb, offset);\r\nif (stub_length >0)\r\nproto_tree_add_item(tree, hf_giop_stub_data, tvb,\r\noffset, stub_length, ENC_NA);\r\n}\r\nbreak;\r\ncase LOCATION_FORWARD:\r\ndecode_IOR(tvb, pinfo, tree, &offset, GIOP_HEADER_SIZE, stream_is_big_endian);\r\nbreak;\r\ncase LOCATION_FORWARD_PERM:\r\ndecode_IOR(tvb, pinfo, tree, &offset, GIOP_HEADER_SIZE, stream_is_big_endian);\r\nbreak;\r\ncase NEEDS_ADDRESSING_MODE: {\r\nguint16 addr_disp;\r\naddr_disp = get_CDR_ushort(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nproto_tree_add_uint (tree, hf_giop_address_disp, tvb, offset-2, 2, addr_disp);\r\nbreak;\r\n}\r\ndefault:\r\nreply_body_length = tvb_reported_length_remaining(tvb, offset);\r\nif (reply_body_length >0)\r\nproto_tree_add_item(tree, hf_giop_reply_body, tvb,\r\noffset, reply_body_length, ENC_NA);\r\nbreak;\r\n}\r\n}\r\nstatic void dissect_giop_reply (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,\r\nMessageHeader * header,\r\ngboolean stream_is_big_endian) {\r\nguint32 offset = 0;\r\nguint32 request_id;\r\nguint32 reply_status;\r\nproto_tree *reply_tree;\r\nguint32 mfn;\r\nreply_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_giop_reply, NULL, "General Inter-ORB Protocol Reply");\r\ndecode_ServiceContextList(tvb, pinfo, reply_tree, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nrequest_id = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " id=%u", request_id );\r\nproto_tree_add_uint(reply_tree, hf_giop_req_id, tvb, offset-4, 4, request_id);\r\nreply_status = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ": %s",\r\nval_to_str(reply_status, reply_status_types, "Unknown (%u)"));\r\nproto_tree_add_uint(reply_tree, hf_giop_reply_status, tvb,\r\noffset-4, 4, reply_status);\r\nif (! pinfo->fd->flags.visited) {\r\nmfn = get_mfn_from_fn_and_reqid(pinfo->num, request_id, &pinfo->dst, pinfo->destport);\r\nif (mfn != pinfo->num) {\r\ninsert_in_complete_reply_hash(pinfo->num, mfn);\r\n}\r\n}\r\nheader->req_id = request_id;\r\nheader->rep_status = reply_status;\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\ndissect_reply_body(tvb, offset, pinfo, reply_tree, stream_is_big_endian,\r\nreply_status, header, tree);\r\n}\r\nstatic void dissect_giop_reply_1_2 (tvbuff_t * tvb, packet_info * pinfo,\r\nproto_tree * tree,\r\nMessageHeader * header,\r\ngboolean stream_is_big_endian) {\r\nguint offset = 0;\r\nguint32 request_id;\r\nguint32 reply_status;\r\nproto_tree *reply_tree;\r\nguint32 mfn;\r\nreply_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_giop_reply, NULL, "General Inter-ORB Protocol Reply");\r\nrequest_id = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " id=%u", request_id);\r\nproto_tree_add_uint (reply_tree, hf_giop_req_id, tvb, offset-4, 4, request_id);\r\nreply_status = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ": %s",\r\nval_to_str(reply_status, reply_status_types, "Unknown (%u)"));\r\nproto_tree_add_uint(reply_tree, hf_giop_reply_status, tvb,\r\noffset-4, 4, reply_status);\r\ndecode_ServiceContextList(tvb, pinfo, reply_tree, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nset_new_alignment(&offset, GIOP_HEADER_SIZE, 8);\r\nif (! pinfo->fd->flags.visited) {\r\nmfn = get_mfn_from_fn_and_reqid(pinfo->num, request_id, &pinfo->dst, pinfo->destport);\r\nif (mfn != pinfo->num) {\r\ninsert_in_complete_reply_hash(pinfo->num, mfn);\r\n}\r\n}\r\nheader->req_id = request_id;\r\nheader->rep_status = reply_status;\r\ndissect_reply_body(tvb, offset, pinfo, reply_tree, stream_is_big_endian,\r\nreply_status, header, tree);\r\n}\r\nstatic void dissect_giop_cancel_request (tvbuff_t * tvb, packet_info * pinfo,\r\nproto_tree * tree,\r\ngboolean stream_is_big_endian) {\r\nguint offset = 0;\r\nguint32 request_id;\r\nproto_tree *cancel_request_tree;\r\ncancel_request_tree = proto_tree_add_subtree(tree, tvb, offset, -1,\r\nett_giop_cancel_request, NULL, "General Inter-ORB Protocol CancelRequest");\r\nrequest_id = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " id=%u", request_id);\r\nproto_tree_add_uint (cancel_request_tree, hf_giop_req_id, tvb, offset-4, 4, request_id);\r\n}\r\nstatic void\r\ndissect_giop_request_1_1 (tvbuff_t * tvb, packet_info * pinfo,\r\nproto_tree * tree,\r\nMessageHeader * header, gboolean stream_is_big_endian)\r\n{\r\nguint32 offset = 0;\r\nguint32 request_id;\r\nguint32 len = 0;\r\nguint32 objkey_len = 0;\r\nconst gchar *objkey = NULL;\r\ngboolean exres = FALSE;\r\nconst gchar *operation;\r\nconst gchar *requesting_principal;\r\nguint8 response_expected;\r\nconst gchar *reserved;\r\ngchar miop[4];\r\nproto_tree *request_tree;\r\nproto_item *tf;\r\ngchar *repoid;\r\nrequest_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_giop_request, &tf, "General Inter-ORB Protocol Request");\r\ndecode_ServiceContextList(tvb, pinfo, request_tree, &offset, stream_is_big_endian, 0);\r\nrequest_id = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " id=%u", request_id);\r\nproto_tree_add_uint (request_tree, hf_giop_req_id, tvb, offset-4, 4, request_id);\r\nresponse_expected = tvb_get_guint8( tvb, offset );\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (%s)",\r\nresponse_expected ? "two-way" : "one-way");\r\nproto_tree_add_item(request_tree, hf_giop_rsp_expected, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif ( header->GIOP_version.minor > 0)\r\n{\r\nget_CDR_octet_seq( tvb, &reserved, &offset, 3);\r\nproto_tree_add_item(request_tree, hf_giop_reserved, tvb, offset-3, 3, ENC_NA);\r\n}\r\nmiop[0] = get_CDR_octet (tvb, &offset);\r\nmiop[1] = get_CDR_octet (tvb, &offset);\r\nmiop[2] = get_CDR_octet (tvb, &offset);\r\nmiop[3] = get_CDR_octet (tvb, &offset);\r\nif (miop[0] == 'M' && miop[1] == 'I' && miop[2] == 'O' && miop[3] == 'P')\r\n{\r\nproto_tree_add_string(request_tree, hf_giop_message_magic, tvb, offset - 4, 4, "MIOP");\r\ndecode_TaggedProfile (tvb, pinfo, request_tree, &offset, GIOP_HEADER_SIZE,\r\nstream_is_big_endian, NULL);\r\n}\r\nelse\r\n{\r\noffset -= 4;\r\nobjkey_len = get_CDR_ulong (tvb, &offset, stream_is_big_endian,\r\nGIOP_HEADER_SIZE);\r\ntf = proto_tree_add_uint (request_tree, hf_giop_objekt_key_len, tvb, offset-4, 4, objkey_len);\r\nif (objkey_len > (guint32)tvb_reported_length_remaining(tvb, offset-4)) {\r\nexpert_add_info_format(pinfo, tf, &ei_giop_length_too_big, "Object key length bigger than packet size");\r\nreturn;\r\n}\r\nif (objkey_len > 0)\r\n{\r\nget_CDR_octet_seq(tvb, &objkey, &offset, objkey_len);\r\nproto_tree_add_item(request_tree, hf_giop_objekt_key, tvb,\r\noffset - objkey_len, objkey_len, ENC_NA);\r\n}\r\n}\r\nlen = get_CDR_string(tvb, &operation, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nproto_tree_add_uint (request_tree, hf_giop_req_operation_len, tvb, offset - 4 - len, 4, len);\r\nif ( len > 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ": op=%s", format_text(operation, (size_t)len));\r\nproto_tree_add_string(request_tree, hf_giop_req_operation, tvb, offset - len, len, operation);\r\n}\r\nlen = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ntf = proto_tree_add_uint (request_tree, hf_giop_req_principal_len, tvb, offset - 4, 4, len);\r\nif (len > (guint32)tvb_reported_length_remaining(tvb, offset-4)) {\r\nexpert_add_info_format(pinfo, tf, &ei_giop_length_too_big, "Requesting Principal length bigger than packet size");\r\nreturn;\r\n}\r\nif ( len > 0)\r\n{\r\nget_CDR_octet_seq(tvb, &requesting_principal, &offset, len);\r\nproto_tree_add_string(request_tree, hf_giop_req_principal, tvb, offset - len, len,\r\nmake_printable_string(requesting_principal, len));\r\n}\r\nif (! pinfo->fd->flags.visited)\r\ngiop_complete_request_list = insert_in_comp_req_list(giop_complete_request_list, pinfo->num,\r\nrequest_id, operation, NULL, &pinfo->src, pinfo->srcport);\r\nheader->req_id = request_id;\r\nrepoid = get_repoid_from_objkey(giop_objkey_hash, objkey, objkey_len);\r\nif (repoid) {\r\nexres = try_explicit_giop_dissector(tvb, pinfo, tree, &offset, header, operation, repoid);\r\n}\r\nif (! exres) {\r\nexres = try_heuristic_giop_dissector(tvb, pinfo, tree, &offset, header, operation);\r\n}\r\nif (!exres && !strcmp(giop_op_is_a, operation) && request_tree) {\r\nconst gchar *type_id;\r\nlen = get_CDR_string(tvb, &type_id, &offset, stream_is_big_endian, 0);\r\nproto_tree_add_uint (request_tree, hf_giop_type_id_len, tvb, offset - 4 - len, 4, len);\r\nproto_tree_add_string(request_tree, hf_giop_type_id, tvb, offset - len, len, type_id);\r\n}\r\nif (! exres) {\r\ngint stub_length = tvb_reported_length_remaining(tvb, offset);\r\nproto_tree_add_item(request_tree, hf_giop_stub_data, tvb,\r\noffset, stub_length, ENC_NA);\r\n}\r\n}\r\nstatic void\r\ndissect_giop_request_1_2 (tvbuff_t * tvb, packet_info * pinfo,\r\nproto_tree * tree,\r\nMessageHeader * header, gboolean stream_is_big_endian)\r\n{\r\nguint32 offset = 0;\r\nguint32 request_id;\r\nguint32 len = 0;\r\nconst gchar *reserved;\r\nconst gchar *operation = NULL;\r\nproto_tree *request_tree;\r\ngboolean exres = FALSE;\r\nguint32 objkey_len = 0;\r\nconst gchar *objkey = NULL;\r\ngchar *repoid = NULL;\r\nrequest_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_giop_request, NULL, "General Inter-ORB Protocol Request");\r\nrequest_id = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nheader->req_id = request_id;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " id=%u", request_id);\r\nproto_tree_add_uint (request_tree, hf_giop_req_id, tvb, offset-4, 4, request_id);\r\nproto_tree_add_item(request_tree, hf_giop_response_flag, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nget_CDR_octet_seq( tvb, &reserved, &offset, 3);\r\nproto_tree_add_item(request_tree, hf_giop_reserved, tvb, offset-3, 3, ENC_NA);\r\ndissect_target_address(tvb, pinfo, &offset, request_tree, stream_is_big_endian,\r\n&objkey_len, &objkey);\r\nif (objkey) {\r\nrepoid = get_repoid_from_objkey(giop_objkey_hash, objkey, objkey_len);\r\n}\r\nlen = get_CDR_string(tvb, &operation, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nproto_tree_add_uint (request_tree, hf_giop_req_operation_len, tvb, offset - 4 - len, 4, len);\r\nif ( len > 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ": op=%s", format_text(operation, (size_t)len));\r\nproto_tree_add_string(request_tree, hf_giop_req_operation, tvb, offset - len, len, operation);\r\n}\r\ndecode_ServiceContextList(tvb, pinfo, request_tree, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nif (tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\nset_new_alignment(&offset, GIOP_HEADER_SIZE, 8);\r\n}\r\nif (! pinfo->fd->flags.visited)\r\ngiop_complete_request_list = insert_in_comp_req_list(giop_complete_request_list, pinfo->num,\r\nrequest_id, operation, NULL, &pinfo->src, pinfo->srcport);\r\nif (repoid) {\r\nexres = try_explicit_giop_dissector(tvb, pinfo, tree, &offset, header, operation, repoid);\r\n}\r\nif (! exres) {\r\nexres = try_heuristic_giop_dissector(tvb, pinfo, tree, &offset, header, operation);\r\n}\r\nif (!exres && !strcmp(giop_op_is_a, operation) && request_tree) {\r\nconst gchar *type_id;\r\nlen = get_CDR_string(tvb, &type_id, &offset, stream_is_big_endian, 0);\r\nproto_tree_add_uint (request_tree, hf_giop_type_id_len, tvb, offset - 4 - len, 4, len);\r\nproto_tree_add_string(request_tree, hf_giop_type_id, tvb, offset - len, len, type_id);\r\n}\r\nif (! exres) {\r\ngint stub_length = tvb_reported_length_remaining(tvb, offset);\r\nif (stub_length > 0)\r\nproto_tree_add_item(request_tree, hf_giop_stub_data, tvb,\r\noffset, stub_length, ENC_NA);\r\n}\r\n}\r\nstatic void\r\ndissect_giop_locate_request( tvbuff_t * tvb, packet_info * pinfo,\r\nproto_tree * tree, MessageHeader * header,\r\ngboolean stream_is_big_endian)\r\n{\r\nguint32 offset = 0;\r\nguint32 request_id;\r\nguint32 len = 0;\r\nproto_tree *locate_request_tree;\r\nproto_item *tf;\r\nlocate_request_tree = proto_tree_add_subtree(tree, tvb, offset, -1,\r\nett_giop_locate_request, &tf, "General Inter-ORB Locate Request");\r\nrequest_id = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " id=%u op=LocateRequest", request_id);\r\nproto_tree_add_uint (locate_request_tree, hf_giop_req_id, tvb, offset-4, 4, request_id);\r\nif (header->GIOP_version.minor < 2)\r\n{\r\nlen = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nproto_tree_add_uint (locate_request_tree, hf_giop_objekt_key_len, tvb, offset-4, 4, len);\r\nif (len > (guint32)tvb_reported_length_remaining(tvb, offset-4)) {\r\nexpert_add_info_format(pinfo, tf, &ei_giop_length_too_big, "Object key length bigger than packet size");\r\nreturn;\r\n}\r\nif (len > 0) {\r\nproto_tree_add_item(locate_request_tree, hf_giop_objekt_key, tvb, offset-len, len, ENC_NA);\r\n}\r\n}\r\nelse\r\n{\r\ndissect_target_address(tvb, pinfo, &offset, locate_request_tree,\r\nstream_is_big_endian, NULL, NULL);\r\n}\r\n}\r\nstatic void\r\ndissect_giop_locate_reply( tvbuff_t * tvb, packet_info * pinfo,\r\nproto_tree * tree, MessageHeader * header,\r\ngboolean stream_is_big_endian)\r\n{\r\nguint32 offset = 0;\r\nguint32 request_id;\r\nguint32 locate_status;\r\nguint16 addr_disp;\r\nproto_tree *locate_reply_tree;\r\nlocate_reply_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_giop_locate_reply, NULL, "General Inter-ORB Locate Reply");\r\nrequest_id = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " id=%u", request_id);\r\nproto_tree_add_uint (locate_reply_tree, hf_giop_req_id, tvb, offset-4, 4, request_id);\r\nlocate_status = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nproto_tree_add_uint (locate_reply_tree, hf_giop_locale_status, tvb, offset-4, 4, locate_status);\r\nif (header->GIOP_version.minor > 1) {\r\nwhile ( ( (offset + GIOP_HEADER_SIZE) % 8) != 0)\r\n++(offset);\r\n}\r\nswitch (locate_status) {\r\ncase OBJECT_FORWARD:\r\ncase OBJECT_FORWARD_PERM:\r\ndecode_IOR(tvb, pinfo, locate_reply_tree, &offset, GIOP_HEADER_SIZE, stream_is_big_endian);\r\nbreak;\r\ncase LOC_SYSTEM_EXCEPTION:\r\ndecode_SystemExceptionReplyBody (tvb, tree, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nbreak;\r\ncase LOC_NEEDS_ADDRESSING_MODE:\r\naddr_disp = get_CDR_ushort(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nproto_tree_add_uint (tree, hf_giop_addressing_disposition, tvb, offset-2, 2, addr_disp);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndissect_giop_fragment( tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree,\r\ngboolean stream_is_big_endian)\r\n{\r\nguint32 offset = 0;\r\nguint32 request_id;\r\nproto_tree *fragment_tree;\r\nfragment_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_giop_fragment, NULL, "General Inter-ORB Fragment");\r\nrequest_id = get_CDR_ulong(tvb, &offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " id=%u", request_id);\r\nproto_tree_add_uint (fragment_tree, hf_giop_req_id, tvb, offset-4, 4, request_id);\r\n}\r\nstatic int dissect_giop_common (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_) {\r\nguint offset = 0;\r\nMessageHeader header;\r\ntvbuff_t *payload_tvb;\r\nproto_tree *giop_tree, *header_tree, *header_version_tree;\r\nproto_item *ti, *version_item;\r\nguint message_size;\r\ngboolean stream_is_big_endian;\r\nconversation_t *conversation;\r\nguint8 message_type;\r\ngiop_conv_info_t *giop_info;\r\n#if DEBUG\r\ngiop_dump_collection(cd_module_hash);\r\ngiop_dump_collection(cd_objkey_hash);\r\ngiop_dump_collection(cd_heuristic_users);\r\ngiop_dump_collection(cd_complete_reply_hash);\r\ngiop_dump_collection(cd_complete_request_list);\r\n#endif\r\nheader.exception_id = NULL;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "GIOP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item (tree, proto_giop, tvb, 0, -1, ENC_NA);\r\ngiop_tree = proto_item_add_subtree (ti, ett_giop);\r\ntvb_memcpy (tvb, (guint8 *)&header, 0, GIOP_HEADER_SIZE );\r\nstream_is_big_endian = is_big_endian (&header);\r\nheader_tree = proto_tree_add_subtree(giop_tree, tvb, offset, GIOP_HEADER_SIZE, ett_giop_header, NULL, "GIOP Header");\r\nproto_tree_add_item(header_tree, hf_giop_message_magic, tvb, 0, 4, ENC_NA|ENC_ASCII);\r\nheader_version_tree = proto_tree_add_subtree_format(header_tree, tvb, 4, 2, ett_giop_header_version, &version_item,\r\n"Version: %u.%u", header.GIOP_version.major, header.GIOP_version.minor);\r\nproto_tree_add_item(header_version_tree, hf_giop_message_major_version, tvb, 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(header_version_tree, hf_giop_message_minor_version, tvb, 5, 1, ENC_BIG_ENDIAN);\r\nif ((header.GIOP_version.major != GIOP_MAJOR) ||\r\n(header.GIOP_version.minor > GIOP_MINOR))\r\n{\r\ncol_add_fstr (pinfo->cinfo, COL_INFO, "Version %u.%u",\r\nheader.GIOP_version.major, header.GIOP_version.minor);\r\nexpert_add_info_format(pinfo, version_item, &ei_giop_version_not_supported, "Version %u.%u not supported",\r\nheader.GIOP_version.major, header.GIOP_version.minor);\r\npayload_tvb = tvb_new_subset_remaining (tvb, GIOP_HEADER_SIZE);\r\ncall_data_dissector(payload_tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nswitch (header.GIOP_version.minor)\r\n{\r\ncase 2:\r\ncase 1:\r\nti = proto_tree_add_bitmask(header_version_tree, tvb, 6,\r\nhf_giop_message_flags, ett_giop_message_flags,\r\ngiop_message_flags, ENC_BIG_ENDIAN);\r\nif ((header.flags & GIOP_MESSAGE_FLAGS_ENDIANNESS) == 0)\r\nproto_item_append_text(ti, ", (Big Endian)");\r\nbreak;\r\ncase 0:\r\nproto_tree_add_boolean(header_tree, hf_giop_message_flags_little_endian, tvb, 6, 1, stream_is_big_endian ? 0 : 1);\r\nbreak;\r\n}\r\nproto_tree_add_item(header_tree, hf_giop_message_type, tvb, 7, 1, ENC_BIG_ENDIAN);\r\nif (stream_is_big_endian)\r\n{\r\nmessage_size = tvb_get_ntohl(tvb, 8);\r\n}\r\nelse\r\n{\r\nmessage_size = tvb_get_letohl(tvb, 8);\r\n}\r\ncol_add_fstr (pinfo->cinfo, COL_INFO, "GIOP %u.%u %s, s=%u",\r\nheader.GIOP_version.major, header.GIOP_version.minor,\r\nval_to_str(header.message_type, giop_message_types, "Unknown message type (0x%02x)"),\r\nmessage_size);\r\nti = proto_tree_add_uint(header_tree, hf_giop_message_size, tvb, 8, 4, message_size);\r\nif (message_size > giop_max_message_size)\r\n{\r\nexpert_add_info_format(pinfo, ti, &ei_giop_message_size_too_big,\r\n"Message size %u is too big, perhaps it's an endian issue?", message_size);\r\nreturn 8;\r\n}\r\nif (message_size == 0) {\r\nreturn 8;\r\n}\r\nif (header.flags & GIOP_MESSAGE_FLAGS_ZIOP_ENABLED)\r\n{\r\ngint rem_len;\r\nrem_len = tvb_captured_length_remaining(tvb, GIOP_HEADER_SIZE);\r\nif (rem_len <= 0)\r\nreturn 8;\r\npayload_tvb = tvb_child_uncompress(tvb, tvb, GIOP_HEADER_SIZE, rem_len);\r\nif (payload_tvb) {\r\nadd_new_data_source (pinfo, payload_tvb, "decompressed Content");\r\n} else {\r\nreturn 8;\r\n}\r\n} else {\r\npayload_tvb = tvb_new_subset_remaining (tvb, GIOP_HEADER_SIZE);\r\n}\r\nif(giop_reassemble) {\r\nfragment_head *fd_head = NULL;\r\ntvbuff_t *reassembled_tvb;\r\nguint frag_offset = 0;\r\nheader.req_id = get_CDR_ulong(payload_tvb, &frag_offset, stream_is_big_endian, GIOP_HEADER_SIZE);\r\nif(header.message_type != Fragment)\r\nfrag_offset = 0;\r\nfd_head = fragment_add_seq_next(&giop_reassembly_table,\r\npayload_tvb, frag_offset, pinfo,\r\nheader.req_id, NULL,\r\ntvb_captured_length_remaining(payload_tvb, frag_offset),\r\nheader.flags & GIOP_MESSAGE_FLAGS_FRAGMENT);\r\nreassembled_tvb = process_reassembled_data(payload_tvb, frag_offset, pinfo, "Reassembled GIOP",\r\nfd_head, &giop_frag_items, NULL, tree);\r\nif(reassembled_tvb != NULL)\r\npayload_tvb = reassembled_tvb;\r\nconversation = find_or_create_conversation(pinfo);\r\ngiop_info = (giop_conv_info_t *)conversation_get_proto_data(conversation, proto_giop);\r\nif(giop_info == NULL) {\r\ngiop_info = wmem_new0(wmem_file_scope(), giop_conv_info_t);\r\ngiop_info->optypes = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\r\nconversation_add_proto_data(conversation, proto_giop, giop_info);\r\n}\r\nif(header.message_type != Fragment) {\r\nwmem_map_insert(giop_info->optypes, GUINT_TO_POINTER(header.req_id), GUINT_TO_POINTER((guint)header.message_type));\r\n} else if (!(header.flags & GIOP_MESSAGE_FLAGS_FRAGMENT)) {\r\nmessage_type = (guint8)GPOINTER_TO_UINT(wmem_map_lookup(giop_info->optypes, GUINT_TO_POINTER(header.req_id)));\r\nheader.message_type = message_type;\r\nheader.message_size = tvb_captured_length_remaining(payload_tvb, 0);\r\n}\r\n}\r\nswitch (header.message_type)\r\n{\r\ncase Request:\r\nif (header.GIOP_version.minor < 2)\r\n{\r\ndissect_giop_request_1_1 (payload_tvb, pinfo, tree,\r\n&header, stream_is_big_endian);\r\n}\r\nelse\r\n{\r\ndissect_giop_request_1_2 (payload_tvb, pinfo, tree,\r\n&header, stream_is_big_endian);\r\n}\r\nbreak;\r\ncase Reply:\r\nif (header.GIOP_version.minor < 2)\r\n{\r\ndissect_giop_reply (payload_tvb, pinfo, tree, &header,\r\nstream_is_big_endian);\r\n}\r\nelse\r\n{\r\ndissect_giop_reply_1_2 (payload_tvb, pinfo, tree,\r\n&header, stream_is_big_endian);\r\n}\r\nbreak;\r\ncase CancelRequest:\r\ndissect_giop_cancel_request(payload_tvb, pinfo, tree,\r\nstream_is_big_endian);\r\nbreak;\r\ncase LocateRequest:\r\ndissect_giop_locate_request(payload_tvb, pinfo, tree, &header,\r\nstream_is_big_endian);\r\nbreak;\r\ncase LocateReply:\r\ndissect_giop_locate_reply(payload_tvb, pinfo, tree, &header,\r\nstream_is_big_endian);\r\nbreak;\r\ncase Fragment:\r\ndissect_giop_fragment(payload_tvb, pinfo, tree,\r\nstream_is_big_endian);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_giop_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nMessageHeader header;\r\nguint message_size;\r\nif (tvb_reported_length_remaining(tvb, offset) < GIOP_HEADER_SIZE)\r\nreturn 0;\r\nif (tvb_get_ntohl(tvb, 0 + offset) != GIOP_MAGIC_NUMBER)\r\nreturn 0;\r\nheader.GIOP_version.minor = tvb_get_guint8(tvb, 5 + offset);\r\nheader.flags = tvb_get_guint8(tvb, 6 + offset);\r\nif (is_big_endian (&header))\r\nmessage_size = tvb_get_ntohl(tvb, 8 + offset);\r\nelse\r\nmessage_size = tvb_get_letohl(tvb, 8 + offset);\r\nif (message_size > giop_max_message_size)\r\nreturn GIOP_HEADER_SIZE;\r\nreturn message_size + GIOP_HEADER_SIZE;\r\n}\r\ngboolean dissect_giop(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {\r\nreturn dissect_giop_heur(tvb, pinfo, tree, NULL);\r\n}\r\nstatic int\r\ndissect_giop_tcp (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data) {\r\nif (tvb_get_ntohl(tvb, 0) != GIOP_MAGIC_NUMBER) {\r\nif ( tvb_memeql(tvb, 0, ZIOP_MAGIC , 4) == 0)\r\nif (!dissect_ziop_heur(tvb, pinfo, tree, NULL))\r\nreturn 0;\r\nreturn tvb_captured_length(tvb);\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, tree, giop_desegment, GIOP_HEADER_SIZE,\r\nget_giop_pdu_len, dissect_giop_common, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_giop_heur (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * data) {\r\nguint tot_len;\r\nconversation_t *conversation;\r\ntot_len = tvb_captured_length(tvb);\r\nif (tot_len < GIOP_HEADER_SIZE)\r\n{\r\nreturn FALSE;\r\n}\r\nif (tvb_get_ntohl(tvb, 0) != GIOP_MAGIC_NUMBER)\r\nreturn FALSE;\r\nif ( pinfo->ptype == PT_TCP )\r\n{\r\nif (!pinfo->fd->flags.visited)\r\n{\r\nconversation = find_or_create_conversation(pinfo);\r\nconversation_set_dissector(conversation, giop_tcp_handle);\r\n}\r\ndissect_giop_tcp (tvb, pinfo, tree, data);\r\n}\r\nelse\r\n{\r\ndissect_giop_common (tvb, pinfo, tree, data);\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_giop (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_giop_message_magic,\r\n{ "Magic", "giop.magic",\r\nFT_STRING, BASE_NONE, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_giop_message_major_version,\r\n{ "Major Version", "giop.major_version",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_giop_message_minor_version,\r\n{ "Minor Version", "giop.minor_version",\r\nFT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_giop_message_flags,\r\n{ "Message Flags", "giop.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x00, NULL, HFILL }\r\n},\r\n{ &hf_giop_message_flags_ziop_enabled,\r\n{ "ZIOP Enabled", "giop.flags.ziop_enabled",\r\nFT_BOOLEAN, 8, NULL, GIOP_MESSAGE_FLAGS_ZIOP_ENABLED, NULL, HFILL }\r\n},\r\n{ &hf_giop_message_flags_ziop_supported,\r\n{ "ZIOP Supported", "giop.flags.ziop_supported",\r\nFT_BOOLEAN, 8, NULL, GIOP_MESSAGE_FLAGS_ZIOP_SUPPORTED, NULL, HFILL }\r\n},\r\n{ &hf_giop_message_flags_fragment,\r\n{ "Fragment", "giop.flags.fragment",\r\nFT_BOOLEAN, 8, NULL, GIOP_MESSAGE_FLAGS_FRAGMENT, NULL, HFILL }\r\n},\r\n{ &hf_giop_message_flags_little_endian,\r\n{ "Little Endian", "giop.flags.little_endian",\r\nFT_BOOLEAN, 8, NULL, GIOP_MESSAGE_FLAGS_ENDIANNESS, NULL, HFILL }\r\n},\r\n{ &hf_giop_message_type,\r\n{ "Message type", "giop.type",\r\nFT_UINT8, BASE_DEC, VALS(giop_message_types), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_message_size,\r\n{ "Message size", "giop.len",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_repoid,\r\n{ "Repository ID", "giop.repoid",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_string_length,\r\n{ "String Length", "giop.strlen",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_sequence_length,\r\n{ "Sequence Length", "giop.seqlen",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_profile_id,\r\n{ "Profile ID", "giop.profid",\r\nFT_UINT32, BASE_DEC, VALS(profile_id_vals), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_id,\r\n{ "IOR::type_id", "giop.typeid",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_id_match,\r\n{ "Type Id", "giop.typeid.match",\r\nFT_BOOLEAN, BASE_NONE, TFS(&tfs_matched_not_matched), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_id_len,\r\n{ "Type Id length", "giop.typeid_len",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_iiop_v_maj,\r\n{ "IIOP Major Version", "giop.iiop_vmaj",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n}\r\n,\r\n{ &hf_giop_iiop_v_min,\r\n{ "IIOP Minor Version", "giop.iiop_vmin",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_giop_compressed,\r\n{ "ZIOP", "giop.compressed",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_giop_endianness,\r\n{ "Endianness", "giop.endianness",\r\nFT_UINT8, BASE_DEC, VALS(giop_endianness_vals), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_locale_status,\r\n{ "Locate status", "giop.locale_status",\r\nFT_UINT32, BASE_DEC, VALS(giop_locate_status_types), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_addressing_disposition,\r\n{ "Addressing Disposition", "giop.addressing_disposition",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_profile_data,\r\n{ "Profile Data", "giop.profile_data",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_component_data,\r\n{ "Component Data", "giop.component_data",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_rt_corba_priority,\r\n{ "RTCorbaPriority", "giop.rt_corba_priority",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_target_address_discriminant,\r\n{ "TargetAddress", "giop.target_address.discriminant",\r\nFT_UINT16, BASE_DEC, VALS(target_address_discriminant_vals), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_target_address_key_addr_len,\r\n{ "Key Address Length", "giop.target_address.key_addr_len",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_target_address_key_addr,\r\n{ "Key Address", "giop.target_address.key_addr",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_target_address_ref_addr_len,\r\n{ "Reference Address Length", "giop.target_address.ref_addr_len",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_context_data,\r\n{ "Context Data", "giop.context_data",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_char_data,\r\n{ "char data", "giop.char_data",\r\nFT_UINT32, BASE_DEC | BASE_EXT_STRING, &giop_code_set_vals_ext, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_wchar_data,\r\n{ "wchar data", "giop.wchar_data",\r\nFT_UINT32, BASE_DEC | BASE_EXT_STRING, &giop_code_set_vals_ext, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_IIOP_tag,\r\n{ "IIOP Component TAG", "giop.iioptag",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_giop_IOR_tag,\r\n{ "IOR Profile TAG", "giop.iortag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_giop_TCKind,\r\n{ "TypeCode enum", "giop.TCKind",\r\nFT_UINT32, BASE_DEC, VALS(tckind_vals), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_count,\r\n{ "TypeCode count", "giop.tccount",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_default_used,\r\n{ "default_used", "giop.tcdefault_used",\r\nFT_INT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_digits,\r\n{ "Digits", "giop.tcdigits",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_length,\r\n{ "Length", "giop.tclength",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_max_length,\r\n{ "Maximum length", "giop.tcmaxlen",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_member_name,\r\n{ "TypeCode member name", "giop.tcmemname",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_name,\r\n{ "TypeCode name", "giop.tcname",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_scale,\r\n{ "Scale", "giop.tcscale",\r\nFT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_ValueModifier,\r\n{ "ValueModifier", "giop.tcValueModifier",\r\nFT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_typecode_Visibility,\r\n{ "Visibility", "giop.tcVisibility",\r\nFT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_boolean,\r\n{ "TypeCode boolean data", "giop.tcboolean",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_char,\r\n{ "TypeCode char data", "giop.tcchar",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_double,\r\n{ "TypeCode double data", "giop.tcdouble",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_enum,\r\n{ "TypeCode enum data", "giop.tcenumdata",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_float,\r\n{ "TypeCode float data", "giop.tcfloat",\r\nFT_FLOAT, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_long,\r\n{ "TypeCode long data", "giop.tclongdata",\r\nFT_INT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_longlong,\r\n{ "TypeCode longlong data", "giop.tclonglongdata",\r\nFT_INT64, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_ulonglong,\r\n{ "TypeCode ulonglong data", "giop.tculonglongdata",\r\nFT_UINT64, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_octet,\r\n{ "TypeCode octet data", "giop.tcoctet",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_short,\r\n{ "TypeCode short data", "giop.tcshortdata",\r\nFT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_string,\r\n{ "TypeCode string data", "giop.tcstring",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_ulong,\r\n{ "TypeCode ulong data", "giop.tculongdata",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_type_ushort,\r\n{ "TypeCode ushort data", "giop.tcushortdata",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_iiop_host,\r\n{ "IIOP::Profile_host", "giop.iiop.host",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_iiop_port,\r\n{ "IIOP::Profile_port", "giop.iiop.port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_iiop_sc,\r\n{ "ServiceContext", "giop.iiop.sc",\r\nFT_NONE, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_giop_iiop_sc_vscid,\r\n{ "VSCID", "giop.iiop.sc.vscid",\r\nFT_UINT32, BASE_HEX, NULL, 0xffffff00, NULL, HFILL }\r\n},\r\n{ &hf_giop_iiop_sc_omg_scid,\r\n{ "SCID", "giop.iiop.sc.scid",\r\nFT_UINT32, BASE_HEX, VALS(service_context_ids), 0x000000ff, NULL, HFILL }\r\n},\r\n{ &hf_giop_iiop_sc_vendor_scid,\r\n{ "SCID", "giop.iiop.sc.scid",\r\nFT_UINT32, BASE_HEX, NULL, 0x000000ff, NULL, HFILL }\r\n},\r\n{ &hf_giop_req_id,\r\n{ "Request id", "giop.request_id",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_giop_req_operation_len,\r\n{ "Operation length", "giop.request_op_len",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_giop_req_operation,\r\n{ "Request operation", "giop.request_op",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_req_principal_len,\r\n{ "Requesting Principal Length", "giop.request_principal_len",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL }\r\n},\r\n{ &hf_giop_req_principal,\r\n{ "Requesting Principal", "giop.request_principal",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_reply_status,\r\n{ "Reply status", "giop.replystatus",\r\nFT_UINT32, BASE_DEC, VALS(reply_status_types), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_exception_len,\r\n{ "Exception length", "giop.exceptionid_len",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_exception_id,\r\n{ "Exception id", "giop.exceptionid",\r\nFT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_objekt_key,\r\n{ "Object Key", "giop.objektkey",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_objekt_key_len,\r\n{ "Object Key length", "giop.objektkey_len",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_rsp_expected,\r\n{ "Response expected", "giop.rsp_expected",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_response_flag,\r\n{ "Response flags", "giop.response_flag",\r\nFT_UINT8, BASE_DEC, VALS(response_flags_vals), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_reserved,\r\n{ "Reserved", "giop.reserved",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_stub_data,\r\n{ "Stub data", "giop.stub_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_address_disp,\r\n{ "Addressing Disposition", "giop.address_disposition",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_minor_code_value,\r\n{ "Minor code value", "giop.minor_code_value",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_completion_status,\r\n{ "Completion Status", "giop.completion_status",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_reply_body,\r\n{ "Reply body", "giop.reply_body",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_giop_fragment_overlap,\r\n{ "Fragment overlap", "giop.fragment.overlap",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0, "Fragment overlaps with other fragments", HFILL }},\r\n{ &hf_giop_fragment_overlap_conflict,\r\n{ "Conflicting data in fragment overlap", "giop.fragment.overlap.conflict", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Overlapping fragments contained conflicting data", HFILL }},\r\n{ &hf_giop_fragment_multiple_tails,\r\n{ "Multiple tail fragments found", "giop.fragment.multipletails", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Several tails were found when reassembling the packet", HFILL }},\r\n{ &hf_giop_fragment_too_long_fragment,\r\n{ "Fragment too long", "giop.fragment.toolongfragment", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Fragment contained data past end of packet", HFILL }},\r\n{ &hf_giop_fragment_error,\r\n{ "Reassembly error", "giop.fragment.error", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"Reassembly error due to illegal fragments", HFILL }},\r\n{ &hf_giop_fragment_count,\r\n{ "Fragment count", "giop.fragment.count", FT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_giop_fragment,\r\n{ "GIOP Fragment", "giop.fragment", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_giop_fragments,\r\n{ "GIOP Fragments", "giop.fragments", FT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_giop_reassembled_in,\r\n{ "Reassembled GIOP in frame", "giop.reassembled_in", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"This GIOP packet is reassembled in this frame", HFILL }},\r\n{ &hf_giop_reassembled_length,\r\n{ "Reassembled GIOP length", "giop.reassembled.length", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The total length of the reassembled payload", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_giop,\r\n&ett_giop_header,\r\n&ett_giop_header_version,\r\n&ett_giop_message_flags,\r\n&ett_giop_reply,\r\n&ett_giop_request,\r\n&ett_giop_cancel_request,\r\n&ett_giop_locate_request,\r\n&ett_giop_locate_reply,\r\n&ett_giop_fragment,\r\n&ett_giop_scl,\r\n&ett_giop_sc,\r\n&ett_giop_ior,\r\n&ett_giop_fragment_,\r\n&ett_giop_fragments,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_giop_unknown_typecode_datatype, { "giop.unknown_typecode_datatype", PI_PROTOCOL, PI_WARN, "Unknown typecode data type", EXPFILL }},\r\n{ &ei_giop_unknown_sign_value, { "giop.unknown_sign_value", PI_PROTOCOL, PI_WARN, "Unknown sign value in fixed type", EXPFILL }},\r\n{ &ei_giop_unknown_tckind, { "giop.unknown_tckind", PI_PROTOCOL, PI_WARN, "Unknown TCKind", EXPFILL }},\r\n{ &ei_giop_length_too_big, { "giop.length_too_big", PI_MALFORMED, PI_ERROR, "length bigger than packet size", EXPFILL }},\r\n{ &ei_giop_version_not_supported, { "giop.version_not_supported", PI_PROTOCOL, PI_WARN, "Version not supported", EXPFILL }},\r\n{ &ei_giop_message_size_too_big, { "giop.message_size_too_big", PI_PROTOCOL, PI_WARN, "Message size is too big", EXPFILL }},\r\n{ &ei_giop_invalid_v_minor, { "giop.invalid_v_minor", PI_PROTOCOL, PI_WARN, "Invalid v_minor value", EXPFILL }},\r\n};\r\nmodule_t *giop_module;\r\nexpert_module_t* expert_giop;\r\nproto_giop = proto_register_protocol("General Inter-ORB Protocol", "GIOP", "giop");\r\ngiop_tcp_handle = register_dissector("giop", dissect_giop_tcp, proto_giop);\r\nproto_register_field_array (proto_giop, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nexpert_giop = expert_register_protocol(proto_giop);\r\nexpert_register_field_array(expert_giop, ei, array_length(ei));\r\nregister_init_routine( &giop_init);\r\nregister_cleanup_routine( &giop_cleanup);\r\ngiop_tap = register_tap(GIOP_TAP_NAME);\r\ngiop_module = prefs_register_protocol(proto_giop, NULL);\r\nprefs_register_bool_preference(giop_module, "desegment_giop_messages",\r\n"Reassemble GIOP messages spanning multiple TCP segments",\r\n"Whether the GIOP dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&giop_desegment);\r\nprefs_register_bool_preference(giop_module, "reassemble",\r\n"Reassemble fragmented GIOP messages",\r\n"Whether fragmented GIOP messages should be reassembled",\r\n&giop_reassemble);\r\nprefs_register_uint_preference(giop_module, "max_message_size",\r\n"Maximum allowed message size",\r\n"Maximum allowed message size in bytes (default=10485760)",\r\n10, &giop_max_message_size);\r\nprefs_register_filename_preference(giop_module, "ior_txt", "Stringified IORs",\r\n"File containing stringified IORs, one per line.", &giop_ior_file);\r\ngiop_module_hash = g_hash_table_new(giop_hash_module_hash, giop_hash_module_equal);\r\n}\r\nvoid proto_reg_handoff_giop (void) {\r\nheur_dissector_add("tcp", dissect_giop_heur, "GIOP over TCP", "giop_tcp", proto_giop, HEURISTIC_ENABLE);\r\nheur_dissector_add("udp", dissect_giop_heur, "DIOP (GIOP/UDP)", "giop_udp", proto_giop, HEURISTIC_ENABLE);\r\ndissector_add_for_decode_as("tcp.port", giop_tcp_handle);\r\n}\r\nstatic void decode_IOR(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ptree, int *offset,\r\nguint32 boundary, gboolean stream_is_big_endian) {\r\nguint32 seqlen_p;\r\nguint32 u_octet4;\r\nproto_tree *tree;\r\nconst gchar *repobuf;\r\nguint32 i;\r\ntree = proto_tree_add_subtree(ptree, tvb, *offset, -1, ett_giop_ior, NULL, "IOR");\r\nu_octet4 = get_CDR_string(tvb, &repobuf, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_string_length, tvb,\r\n*offset-u_octet4-(int)sizeof(u_octet4), 4, u_octet4);\r\nif (u_octet4 > 0) {\r\nproto_tree_add_string(tree, hf_giop_type_id, tvb,\r\n*offset-u_octet4, u_octet4, repobuf);\r\n}\r\nseqlen_p = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_sequence_length, tvb,\r\n*offset-(int)sizeof(seqlen_p), 4, seqlen_p);\r\nfor (i=0; i< seqlen_p; i++) {\r\ndecode_TaggedProfile(tvb, pinfo, tree, offset, boundary, stream_is_big_endian, repobuf);\r\n}\r\n}\r\nstatic void decode_TaggedProfile(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset,\r\nguint32 boundary, gboolean stream_is_big_endian, const gchar *repobuf) {\r\nguint32 seqlen_pd;\r\nguint32 pidtag;\r\nconst gchar *profile_data;\r\nguint32 new_boundary;\r\ngboolean new_big_endianness;\r\nproto_item *ti;\r\npidtag = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nti = proto_tree_add_uint(tree, hf_giop_profile_id, tvb,\r\n*offset-(int)sizeof(pidtag), 4, pidtag);\r\nseqlen_pd = get_CDR_encap_info(tvb, tree, offset,\r\nstream_is_big_endian, boundary,\r\n&new_big_endianness, &new_boundary);\r\nif (seqlen_pd == 0)\r\nreturn;\r\nswitch (pidtag) {\r\ncase IOP_TAG_INTERNET_IOP:\r\ndecode_IIOP_IOR_profile(tvb, pinfo, tree, offset, new_boundary, new_big_endianness, repobuf, TRUE);\r\nbreak;\r\ndefault:\r\nif (seqlen_pd-1 > (guint32)tvb_reported_length_remaining(tvb, *offset-4)) {\r\nexpert_add_info_format(pinfo, ti, &ei_giop_length_too_big, "Profile data bigger than packet size");\r\nbreak;\r\n}\r\nget_CDR_octet_seq(tvb, &profile_data, offset, seqlen_pd -1);\r\nproto_tree_add_string(tree, hf_giop_profile_data, tvb, *offset -seqlen_pd + 1, seqlen_pd - 1,\r\nmake_printable_string( profile_data, seqlen_pd -1));\r\nbreak;\r\n}\r\n}\r\nstatic void decode_IIOP_IOR_profile(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int *offset,\r\nguint32 boundary, gboolean stream_is_big_endian,\r\nconst gchar *repo_id_buf,\r\ngboolean store_flag) {\r\nguint32 i;\r\nguint8 v_major, v_minor;\r\nconst gchar *buf;\r\nguint32 u_octet4;\r\nguint16 u_octet2;\r\nguint32 seqlen;\r\nguint32 seqlen1;\r\nconst gchar *objkey;\r\nproto_item *ti, *ti_minor;\r\nv_major = get_CDR_octet(tvb, offset);\r\nv_minor = get_CDR_octet(tvb, offset);\r\nproto_tree_add_uint(tree, hf_giop_iiop_v_maj, tvb,\r\n*offset-2, 1, v_major );\r\nti_minor = proto_tree_add_uint(tree, hf_giop_iiop_v_min, tvb,\r\n*offset-1, 1, v_minor );\r\nu_octet4 = get_CDR_string(tvb, &buf, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_string_length, tvb,\r\n*offset-u_octet4-4, 4, u_octet4);\r\nif (u_octet4 > 0) {\r\nproto_tree_add_string(tree, hf_giop_iiop_host, tvb,\r\n*offset-u_octet4, u_octet4, buf);\r\n}\r\nu_octet2 = get_CDR_ushort(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_iiop_port, tvb,\r\n*offset-2, 2, u_octet2);\r\nseqlen = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nti = proto_tree_add_uint(tree, hf_giop_sequence_length, tvb,\r\n*offset-4, 4, seqlen);\r\nif (seqlen > (guint32)tvb_reported_length_remaining(tvb, *offset-4)) {\r\nexpert_add_info_format(pinfo, ti, &ei_giop_length_too_big, "Sequence length bigger than packet size");\r\nreturn;\r\n}\r\nif (seqlen > 0) {\r\nget_CDR_octet_seq(tvb, &objkey, offset, seqlen);\r\nif (repo_id_buf) {\r\nif (pinfo) {\r\nif (!pinfo->fd->flags.visited)\r\ninsert_in_objkey_hash(giop_objkey_hash, objkey, seqlen, repo_id_buf, ior_src_req_res);\r\n}\r\nelse {\r\nif (store_flag)\r\ninsert_in_objkey_hash(giop_objkey_hash, objkey, seqlen, repo_id_buf, ior_src_file);\r\n}\r\n}\r\nproto_tree_add_item(tree, hf_giop_objekt_key, tvb, *offset -seqlen, seqlen, ENC_NA);\r\n}\r\nswitch (v_minor) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nseqlen = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_sequence_length, tvb,\r\n*offset-4, 4, seqlen);\r\nfor (i=0; i< seqlen; i++) {\r\nu_octet4 = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_IIOP_tag, tvb, *offset-4, 4, u_octet4);\r\nseqlen1 = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nti = proto_tree_add_uint(tree, hf_giop_sequence_length, tvb,\r\n*offset-4, 4, seqlen1);\r\nif (seqlen1 > (guint32)tvb_reported_length_remaining(tvb, *offset-4)) {\r\nexpert_add_info_format(pinfo, ti, &ei_giop_length_too_big, "Sequence length bigger than packet size");\r\nreturn;\r\n}\r\nif (seqlen1 > 0) {\r\nget_CDR_octet_seq(tvb, &buf, offset, seqlen1);\r\nproto_tree_add_string(tree, hf_giop_component_data, tvb, *offset -seqlen1, seqlen1,\r\nmake_printable_string(buf, seqlen1));\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, ti_minor, &ei_giop_invalid_v_minor, "Invalid v_minor value = %u", v_minor);\r\nbreak;\r\n}\r\n}\r\nstatic void decode_SystemExceptionReplyBody (tvbuff_t *tvb, proto_tree *tree, gint *offset,\r\ngboolean stream_is_big_endian,\r\nguint32 boundary) {\r\nguint32 length;\r\nguint32 minor_code_value;\r\nguint32 completion_status;\r\nconst gchar *buf;\r\nlength = get_CDR_string(tvb, &buf, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_exception_len, tvb, *offset-4, 4, length);\r\nif (length > 0)\r\nproto_tree_add_string(tree, hf_giop_exception_id, tvb,\r\n*offset - length, length, buf);\r\nminor_code_value = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\ncompletion_status = get_CDR_ulong(tvb, offset, stream_is_big_endian, boundary);\r\nproto_tree_add_uint(tree, hf_giop_minor_code_value, tvb, *offset-8, 4, minor_code_value);\r\nproto_tree_add_uint(tree, hf_giop_completion_status, tvb, *offset-4, 4, completion_status);\r\n}
