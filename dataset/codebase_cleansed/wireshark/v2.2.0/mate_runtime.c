static gboolean destroy_mate_pdus(gpointer k _U_, gpointer v, gpointer p _U_) {\r\nmate_pdu* pdu = (mate_pdu*) v;\r\nif (pdu->avpl) delete_avpl(pdu->avpl,TRUE);\r\ng_slice_free(mate_max_size, (mate_max_size *)pdu);\r\nreturn TRUE;\r\n}\r\nstatic gboolean destroy_mate_gops(gpointer k _U_, gpointer v, gpointer p _U_) {\r\nmate_gop* gop = (mate_gop*) v;\r\nif (gop->avpl) delete_avpl(gop->avpl,TRUE);\r\nif (gop->gop_key) {\r\nif (g_hash_table_lookup(gop->cfg->gop_index,gop->gop_key) == gop) {\r\ng_hash_table_remove(gop->cfg->gop_index,gop->gop_key);\r\n}\r\ng_free(gop->gop_key);\r\n}\r\ng_slice_free(mate_max_size,(mate_max_size*)gop);\r\nreturn TRUE;\r\n}\r\nstatic gboolean destroy_mate_gogs(gpointer k _U_, gpointer v, gpointer p _U_) {\r\nmate_gog* gog = (mate_gog*) v;\r\nif (gog->avpl) delete_avpl(gog->avpl,TRUE);\r\nif (gog->gog_keys) {\r\ngog_remove_keys(gog);\r\ng_ptr_array_free(gog->gog_keys,FALSE);\r\n}\r\ng_slice_free(mate_max_size,(mate_max_size*)gog);\r\nreturn TRUE;\r\n}\r\nstatic gboolean return_true(gpointer k _U_, gpointer v _U_, gpointer p _U_) {\r\nreturn TRUE;\r\n}\r\nstatic void destroy_pdus_in_cfg(gpointer k _U_, gpointer v, gpointer p _U_) {\r\nmate_cfg_pdu* c = (mate_cfg_pdu *)v;\r\ng_hash_table_foreach_remove(c->items,destroy_mate_pdus,NULL);\r\nc->last_id = 0;\r\n}\r\nstatic void destroy_gops_in_cfg(gpointer k _U_, gpointer v, gpointer p _U_) {\r\nmate_cfg_gop* c = (mate_cfg_gop *)v;\r\ng_hash_table_foreach_remove(c->gop_index,return_true,NULL);\r\ng_hash_table_destroy(c->gop_index);\r\nc->gop_index = g_hash_table_new(g_str_hash,g_str_equal);\r\ng_hash_table_foreach_remove(c->gog_index,return_true,NULL);\r\ng_hash_table_destroy(c->gog_index);\r\nc->gog_index = g_hash_table_new(g_str_hash,g_str_equal);\r\ng_hash_table_foreach_remove(c->items,destroy_mate_gops,NULL);\r\nc->last_id = 0;\r\n}\r\nstatic void destroy_gogs_in_cfg(gpointer k _U_, gpointer v, gpointer p _U_) {\r\nmate_cfg_gog* c = (mate_cfg_gog *)v;\r\ng_hash_table_foreach_remove(c->items,destroy_mate_gogs,NULL);\r\nc->last_id = 0;\r\n}\r\nvoid initialize_mate_runtime(void) {\r\ndbg_print (dbg,5,dbg_facility,"initialize_mate: entering");\r\nif (( mc = mate_cfg() )) {\r\nif (rd == NULL ) {\r\nrd = (mate_runtime_data *)g_malloc(sizeof(mate_runtime_data));\r\n} else {\r\ng_hash_table_foreach(mc->pducfgs,destroy_pdus_in_cfg,NULL);\r\ng_hash_table_foreach(mc->gopcfgs,destroy_gops_in_cfg,NULL);\r\ng_hash_table_foreach(mc->gogcfgs,destroy_gogs_in_cfg,NULL);\r\ng_hash_table_destroy(rd->frames);\r\n}\r\nrd->current_items = 0;\r\nrd->now = -1.0f;\r\nrd->highest_analyzed_frame = 0;\r\nrd->frames = g_hash_table_new(g_direct_hash,g_direct_equal);\r\ndbg_pdu = &(mc->dbg_pdu_lvl);\r\ndbg_gop = &(mc->dbg_gop_lvl);\r\ndbg_gog = &(mc->dbg_gog_lvl);\r\ndbg = &(mc->dbg_lvl);\r\ndbg_facility = mc->dbg_facility;\r\ndbg_print(dbg, 1, dbg_facility, "starting mate");\r\n} else {\r\nrd = NULL;\r\n}\r\n}\r\nstatic mate_gop* new_gop(mate_cfg_gop* cfg, mate_pdu* pdu, gchar* key) {\r\nmate_gop* gop = (mate_gop*)g_slice_new(mate_max_size);\r\ngop->id = ++(cfg->last_id);\r\ngop->cfg = cfg;\r\ndbg_print(dbg_gop, 1, dbg_facility, "new_gop: %s: ``%s:%d''", key, gop->cfg->name, gop->id);\r\ngop->gop_key = key;\r\ngop->avpl = new_avpl(cfg->name);\r\ngop->last_n = 0;\r\ngop->gog = NULL;\r\ngop->next = NULL;\r\ngop->expiration = cfg->expiration > 0.0 ? cfg->expiration + rd->now : (float) -1.0 ;\r\ngop->idle_expiration = cfg->idle_timeout > 0.0 ? cfg->idle_timeout + rd->now : (float) -1.0 ;\r\ngop->time_to_die = cfg->lifetime > 0.0 ? cfg->lifetime + rd->now : (float) -1.0 ;\r\ngop->time_to_timeout = 0.0f;\r\ngop->last_time = gop->start_time = rd->now;\r\ngop->release_time = 0.0f;\r\ngop->num_of_pdus = 0;\r\ngop->num_of_after_release_pdus = 0;\r\ngop->pdus = pdu;\r\ngop->last_pdu = pdu;\r\ngop->released = FALSE;\r\npdu->gop = gop;\r\npdu->next = NULL;\r\npdu->is_start = TRUE;\r\npdu->time_in_gop = 0.0f;\r\ng_hash_table_insert(cfg->gop_index,gop->gop_key,gop);\r\nreturn gop;\r\n}\r\nstatic void adopt_gop(mate_gog* gog, mate_gop* gop) {\r\ndbg_print (dbg_gog,5,dbg_facility,"adopt_gop: gog=%p gop=%p",(void*)gog,(void*)gop);\r\ngop->gog = gog;\r\ngop->next = NULL;\r\nif (gop->cfg->start) {\r\ngog->num_of_counting_gops++;\r\n}\r\ngog->num_of_gops++;\r\nif (gog->last_gop) {\r\ngog->last_gop->next = gop;\r\n}\r\ngog->last_gop = gop;\r\nif (! gog->gops ) {\r\ngog->gops = gop;\r\n}\r\n}\r\nstatic mate_gog* new_gog(mate_cfg_gog* cfg, mate_gop* gop) {\r\nmate_gog* gog = (mate_gog*)g_slice_new(mate_max_size);\r\ngog->id = ++(cfg->last_id);\r\ngog->cfg = cfg;\r\ndbg_print (dbg_gog,1,dbg_facility,"new_gog: %s:%u for %s:%u",gog->cfg->name,gog->id,gop->cfg->name,gop->id);\r\ngog->avpl = new_avpl(cfg->name);\r\ngog->last_n = 0;\r\ngog->expiration = 0.0f;\r\ngog->idle_expiration = 0.0f;\r\ngog->start_time = rd->now;\r\ngog->release_time = 0.0f;\r\ngog->last_time = 0.0f;\r\ngog->gops = NULL;\r\ngog->last_gop = NULL;\r\ngog->num_of_gops = 0;\r\ngog->num_of_counting_gops = 0;\r\ngog->num_of_released_gops = 0;\r\ngog->gog_keys = g_ptr_array_new();\r\nadopt_gop(gog,gop);\r\nreturn gog;\r\n}\r\nstatic void apply_transforms(GPtrArray* transforms, AVPL* avpl) {\r\nAVPL_Transf* transform = NULL;\r\nguint i;\r\nfor (i = 0; i < transforms->len; i++) {\r\ntransform = (AVPL_Transf *)g_ptr_array_index(transforms,i);\r\navpl_transform(avpl, transform);\r\n}\r\n}\r\nstatic void apply_extras(AVPL* from, AVPL* to, AVPL* extras) {\r\nAVPL* our_extras = new_avpl_loose_match("",from, extras, FALSE) ;\r\nif (our_extras) {\r\nmerge_avpl(to,our_extras,TRUE);\r\ndelete_avpl(our_extras,FALSE);\r\n}\r\n}\r\nstatic void gog_remove_keys (mate_gog* gog) {\r\ngogkey* gog_key;\r\nwhile (gog->gog_keys->len) {\r\ngog_key = (gogkey *)g_ptr_array_remove_index_fast(gog->gog_keys,0);\r\nif (g_hash_table_lookup(gog_key->cfg->gog_index,gog_key->key) == gog) {\r\ng_hash_table_remove(gog_key->cfg->gog_index,gog_key->key);\r\n}\r\ng_free(gog_key->key);\r\ng_free(gog_key);\r\n}\r\n}\r\nstatic void reanalyze_gop(mate_gop* gop) {\r\nLoAL* gog_keys = NULL;\r\nAVPL* curr_gogkey = NULL;\r\nmate_cfg_gop* gop_cfg = NULL;\r\nvoid* cookie = NULL;\r\nAVPL* gogkey_match = NULL;\r\nmate_gog* gog = gop->gog;\r\ngogkey* gog_key;\r\nif ( ! gog ) return;\r\ngog->last_time = rd->now;\r\ndbg_print (dbg_gog,1,dbg_facility,"reanalyze_gop: %s:%d",gop->cfg->name,gop->id);\r\napply_extras(gop->avpl,gog->avpl,gog->cfg->extra);\r\nif (gog->last_n != gog->avpl->len) {\r\ndbg_print (dbg_gog,2,dbg_facility,"reanalyze_gop: gog has new attributes let's look for new keys");\r\ngog_keys = gog->cfg->keys;\r\nwhile (( curr_gogkey = get_next_avpl(gog_keys,&cookie) )) {\r\ngop_cfg = (mate_cfg_gop *)g_hash_table_lookup(mc->gopcfgs,curr_gogkey->name);\r\nif (( gogkey_match = new_avpl_exact_match(gop_cfg->name,gog->avpl,curr_gogkey,FALSE) )) {\r\ngog_key = (gogkey *)g_malloc(sizeof(gogkey));\r\ngog_key->key = avpl_to_str(gogkey_match);\r\ndelete_avpl(gogkey_match,FALSE);\r\ngog_key->cfg = gop_cfg;\r\nif (g_hash_table_lookup(gop_cfg->gog_index,gog_key->key)) {\r\ng_free(gog_key->key);\r\ng_free(gog_key);\r\ngog_key = NULL;\r\n}\r\nif (! gog_key ) {\r\n} else {\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: new key for gog=%s:%d : %s",gog->cfg->name,gog->id,gog_key->key);\r\ng_ptr_array_add(gog->gog_keys,gog_key);\r\ng_hash_table_insert(gog_key->cfg->gog_index,gog_key->key,gog);\r\n}\r\n}\r\n}\r\ngog->last_n = gog->avpl->len;\r\n}\r\nif (gog->num_of_released_gops == gog->num_of_counting_gops) {\r\ngog->released = TRUE;\r\ngog->expiration = gog->cfg->expiration + rd->now;\r\n} else {\r\ngog->released = FALSE;\r\n}\r\n}\r\nstatic void analyze_gop(mate_gop* gop) {\r\nmate_cfg_gog* cfg = NULL;\r\nLoAL* gog_keys = NULL;\r\nAVPL* curr_gogkey = NULL;\r\nvoid* cookie = NULL;\r\nAVPL* gogkey_match = NULL;\r\nmate_gog* gog = NULL;\r\ngchar* key = NULL;\r\nif ( ! gop->gog ) {\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: no gog");\r\ngog_keys = (LoAL *)g_hash_table_lookup(mc->gogs_by_gopname,gop->cfg->name);\r\nif ( ! gog_keys ) {\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: no gog_keys for this gop");\r\nreturn;\r\n}\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: got gog_keys: %s",gog_keys->name) ;\r\nwhile (( curr_gogkey = get_next_avpl(gog_keys,&cookie) )) {\r\nif (( gogkey_match = new_avpl_exact_match(gop->cfg->name,gop->avpl,curr_gogkey,TRUE) )) {\r\nkey = avpl_to_str(gogkey_match);\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: got gogkey_match: %s",key);\r\nif (( gog = (mate_gog *)g_hash_table_lookup(gop->cfg->gog_index,key) )) {\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: got already a matching gog");\r\nif (gog->num_of_counting_gops == gog->num_of_released_gops && gog->expiration < rd->now) {\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: this is a new gog, not the old one, let's create it");\r\ngog_remove_keys(gog);\r\nnew_gog(gog->cfg,gop);\r\nbreak;\r\n} else {\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: this is our gog");\r\nif (! gop->gog ) adopt_gop(gog,gop);\r\nbreak;\r\n}\r\n} else {\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: no such gog in hash, let's create a new %s",curr_gogkey->name);\r\ncfg = (mate_cfg_gog *)g_hash_table_lookup(mc->gogcfgs,curr_gogkey->name);\r\nif (cfg) {\r\ngog = new_gog(cfg,gop);\r\ngog->num_of_gops = 1;\r\nif (gop->cfg->start) {\r\ngog->num_of_counting_gops = 1;\r\n}\r\n} else {\r\ndbg_print (dbg_gog,0,dbg_facility,"analyze_gop: no such gog_cfg: %s",curr_gogkey->name);\r\n}\r\nbreak;\r\n}\r\ng_assert_not_reached();\r\n}\r\ndbg_print (dbg_gog,1,dbg_facility,"analyze_gop: no gogkey_match: %s",key);\r\n}\r\ng_free(key);\r\nkey = NULL;\r\nif (gogkey_match) delete_avpl(gogkey_match,TRUE);\r\nreanalyze_gop(gop);\r\n}\r\n}\r\nstatic void analyze_pdu(mate_pdu* pdu) {\r\nmate_cfg_gop* cfg = NULL;\r\nmate_gop* gop = NULL;\r\ngchar* gop_key;\r\ngchar* orig_gop_key = NULL;\r\nAVPL* candidate_start = NULL;\r\nAVPL* candidate_stop = NULL;\r\nAVPL* is_start = NULL;\r\nAVPL* is_stop = NULL;\r\nAVPL* gopkey_match = NULL;\r\nLoAL* gog_keys = NULL;\r\nAVPL* curr_gogkey = NULL;\r\nvoid* cookie = NULL;\r\nAVPL* gogkey_match = NULL;\r\ngchar* gogkey_str = NULL;\r\ndbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: %s",pdu->cfg->name);\r\nif (! (cfg = (mate_cfg_gop *)g_hash_table_lookup(mc->gops_by_pduname,pdu->cfg->name)) )\r\nreturn;\r\nif ((gopkey_match = new_avpl_exact_match("gop_key_match",pdu->avpl,cfg->key, TRUE))) {\r\ngop_key = avpl_to_str(gopkey_match);\r\ng_hash_table_lookup_extended(cfg->gop_index,(gconstpointer)gop_key,(gpointer *)&orig_gop_key,(gpointer *)&gop);\r\nif ( gop ) {\r\ng_free(gop_key);\r\nif ( ! gop->released &&\r\n( ( gop->cfg->lifetime > 0.0 && gop->time_to_die >= rd->now) ||\r\n( gop->cfg->idle_timeout > 0.0 && gop->time_to_timeout >= rd->now) ) ) {\r\ndbg_print (dbg_gop,4,dbg_facility,"analyze_pdu: expiring released gop");\r\ngop->released = TRUE;\r\nif (gop->gog && gop->cfg->start) gop->gog->num_of_released_gops++;\r\n}\r\ngop_key = orig_gop_key;\r\ndbg_print (dbg_gop,2,dbg_facility,"analyze_pdu: got gop: %s",gop_key);\r\nif (( candidate_start = cfg->start )) {\r\ndbg_print (dbg_gop,2,dbg_facility,"analyze_pdu: got candidate start");\r\nif (( is_start = new_avpl_exact_match("",pdu->avpl, candidate_start, FALSE) )) {\r\ndelete_avpl(is_start,FALSE);\r\nif ( gop->released ) {\r\ndbg_print (dbg_gop,3,dbg_facility,"analyze_pdu: start on released gop, let's create a new gop");\r\ng_hash_table_remove(cfg->gop_index,gop_key);\r\ngop->gop_key = NULL;\r\ngop = new_gop(cfg,pdu,gop_key);\r\ng_hash_table_insert(cfg->gop_index,gop_key,gop);\r\n} else {\r\ndbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: duplicate start on gop");\r\n}\r\n}\r\n}\r\npdu->gop = gop;\r\nif (gop->last_pdu) gop->last_pdu->next = pdu;\r\ngop->last_pdu = pdu;\r\npdu->next = NULL;\r\npdu->time_in_gop = rd->now - gop->start_time;\r\nif (gop->released) pdu->after_release = TRUE;\r\n} else {\r\ndbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: no gop already");\r\nif ( ! cfg->start ) {\r\napply_extras(pdu->avpl,gopkey_match,cfg->extra);\r\ngog_keys = (LoAL *)g_hash_table_lookup(mc->gogs_by_gopname,cfg->name);\r\nif (gog_keys) {\r\nwhile (( curr_gogkey = get_next_avpl(gog_keys,&cookie) )) {\r\nif (( gogkey_match = new_avpl_exact_match(cfg->name,gopkey_match,curr_gogkey,FALSE) )) {\r\ngogkey_str = avpl_to_str(gogkey_match);\r\nif (g_hash_table_lookup(cfg->gog_index,gogkey_str)) {\r\ngop = new_gop(cfg,pdu,gop_key);\r\ng_hash_table_insert(cfg->gop_index,gop_key,gop);\r\ndelete_avpl(gogkey_match,FALSE);\r\ng_free(gogkey_str);\r\nbreak;\r\n} else {\r\ndelete_avpl(gogkey_match,FALSE);\r\ng_free(gogkey_str);\r\n}\r\n}\r\n}\r\nif ( ! gop ) {\r\ng_free(gop_key);\r\ndelete_avpl(gopkey_match,TRUE);\r\nreturn;\r\n}\r\n} else {\r\ng_free(gop_key);\r\ndelete_avpl(gopkey_match,TRUE);\r\nreturn;\r\n}\r\n} else {\r\ncandidate_start = cfg->start;\r\nif (( is_start = new_avpl_exact_match("",pdu->avpl, candidate_start, FALSE) )) {\r\ndelete_avpl(is_start,FALSE);\r\ngop = new_gop(cfg,pdu,gop_key);\r\n} else {\r\ng_free(gop_key);\r\nreturn;\r\n}\r\npdu->gop = gop;\r\n}\r\n}\r\nif (gop->last_pdu) gop->last_pdu->next = pdu;\r\ngop->last_pdu = pdu;\r\npdu->next = NULL;\r\npdu->time_in_gop = rd->now - gop->start_time;\r\ngop->num_of_pdus++;\r\ngop->time_to_timeout = cfg->idle_timeout > 0.0 ? cfg->idle_timeout + rd->now : (float) -1.0 ;\r\ndbg_print (dbg_gop,4,dbg_facility,"analyze_pdu: merge with key");\r\nmerge_avpl(gop->avpl,gopkey_match,TRUE);\r\ndelete_avpl(gopkey_match,TRUE);\r\ndbg_print (dbg_gop,4,dbg_facility,"analyze_pdu: apply extras");\r\napply_extras(pdu->avpl,gop->avpl,gop->cfg->extra);\r\ngop->last_time = pdu->rel_time;\r\nif ( ! gop->released) {\r\ncandidate_stop = cfg->stop;\r\nif (candidate_stop) {\r\nis_stop = new_avpl_exact_match("",pdu->avpl, candidate_stop,FALSE);\r\n} else {\r\nis_stop = new_avpl("");\r\n}\r\nif(is_stop) {\r\ndbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: is a `stop");\r\ndelete_avpl(is_stop,FALSE);\r\nif (! gop->released) {\r\ngop->released = TRUE;\r\ngop->release_time = pdu->rel_time;\r\nif (gop->gog && gop->cfg->start) gop->gog->num_of_released_gops++;\r\n}\r\npdu->is_stop = TRUE;\r\n}\r\n}\r\nif (gop->last_n != gop->avpl->len) apply_transforms(gop->cfg->transforms,gop->avpl);\r\ngop->last_n = gop->avpl->len;\r\nif (gop->gog) {\r\nreanalyze_gop(gop);\r\n} else {\r\nanalyze_gop(gop);\r\n}\r\n} else {\r\ndbg_print (dbg_gop,4,dbg_facility,"analyze_pdu: no match for this pdu");\r\npdu->gop = NULL;\r\n}\r\n}\r\nstatic void get_pdu_fields(gpointer k, gpointer v, gpointer p) {\r\nint hfid = *((int*) k);\r\ngchar* name = (gchar*) v;\r\ntmp_pdu_data* data = (tmp_pdu_data*) p;\r\nGPtrArray* fis;\r\nfield_info* fi;\r\nguint i,j;\r\nmate_range* curr_range;\r\nguint start;\r\nguint end;\r\nAVP* avp;\r\ngchar* s;\r\nfis = proto_get_finfo_ptr_array(data->tree, hfid);\r\nif (fis) {\r\nfor (i = 0; i < fis->len; i++) {\r\nfi = (field_info*) g_ptr_array_index(fis,i);\r\nstart = fi->start;\r\nend = fi->start + fi->length;\r\ndbg_print(dbg_pdu,5,dbg_facility,"get_pdu_fields: found field %i-%i",start,end);\r\nfor (j = 0; j < data->ranges->len; j++) {\r\ncurr_range = (mate_range*) g_ptr_array_index(data->ranges,j);\r\nif (curr_range->end >= end && curr_range->start <= start) {\r\navp = new_avp_from_finfo(name, fi);\r\nif (*dbg_pdu > 4) {\r\ns = avp_to_str(avp);\r\ndbg_print(dbg_pdu,0,dbg_facility,"get_pdu_fields: got %s",s);\r\ng_free(s);\r\n}\r\nif (! insert_avp(data->pdu->avpl,avp) ) {\r\ndelete_avp(avp);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic mate_pdu* new_pdu(mate_cfg_pdu* cfg, guint32 framenum, field_info* proto, proto_tree* tree) {\r\nmate_pdu* pdu = (mate_pdu*)g_slice_new(mate_max_size);\r\nfield_info* cfi;\r\nGPtrArray* ptrs;\r\nmate_range* range;\r\nmate_range* proto_range;\r\ntmp_pdu_data data;\r\nguint i,j;\r\ngint min_dist;\r\nfield_info* range_fi;\r\ngint32 last_start;\r\ngint32 first_end;\r\ngint32 curr_end;\r\nint hfid;\r\ndbg_print (dbg_pdu,1,dbg_facility,"new_pdu: type=%s framenum=%i",cfg->name,framenum);\r\npdu->id = ++(cfg->last_id);\r\npdu->cfg = cfg;\r\npdu->avpl = new_avpl(cfg->name);\r\npdu->frame = framenum;\r\npdu->next_in_frame = NULL;\r\npdu->rel_time = rd->now;\r\npdu->gop = NULL;\r\npdu->next = NULL;\r\npdu->time_in_gop = -1.0f;\r\npdu->first = FALSE;\r\npdu->is_start = FALSE;\r\npdu->is_stop = FALSE;\r\npdu->after_release = FALSE;\r\ndata.ranges = g_ptr_array_new();\r\ndata.pdu = pdu;\r\ndata.tree = tree;\r\nproto_range = (mate_range *)g_malloc(sizeof(mate_range));\r\nproto_range->start = proto->start;\r\nproto_range->end = proto->start + proto->length;\r\ng_ptr_array_add(data.ranges,proto_range);\r\ndbg_print(dbg_pdu,3,dbg_facility,"new_pdu: proto range %u-%u",proto_range->start,proto_range->end);\r\nlast_start = proto_range->start;\r\nfor (i = cfg->transport_ranges->len; i--; ) {\r\nhfid = *((int*)g_ptr_array_index(cfg->transport_ranges,i));\r\nptrs = proto_get_finfo_ptr_array(tree, hfid);\r\nmin_dist = 99999;\r\nrange_fi = NULL;\r\nif (ptrs) {\r\nfor (j=0; j < ptrs->len; j++) {\r\ncfi = (field_info*) g_ptr_array_index(ptrs,j);\r\nif (cfi->start < last_start && min_dist >= (last_start - cfi->start) ) {\r\nrange_fi = cfi;\r\nmin_dist = last_start - cfi->start;\r\n}\r\n}\r\nif ( range_fi ) {\r\nrange = (mate_range *)g_malloc(sizeof(*range));\r\nrange->start = range_fi->start;\r\nrange->end = range_fi->start + range_fi->length;\r\ng_ptr_array_add(data.ranges,range);\r\nlast_start = range_fi->start;\r\ndbg_print(dbg_pdu,3,dbg_facility,"new_pdu: transport(%i) range %i-%i",hfid,range->start,range->end);\r\n} else {\r\ndbg_print(dbg_pdu,6,dbg_facility,"new_pdu: transport(%i) missed",hfid);\r\n}\r\n}\r\n}\r\nif (cfg->payload_ranges) {\r\nfirst_end = proto_range->end;\r\nfor (i = 0 ; i < cfg->payload_ranges->len; i++) {\r\nhfid = *((int*)g_ptr_array_index(cfg->payload_ranges,i));\r\nptrs = proto_get_finfo_ptr_array(tree, hfid);\r\nmin_dist = 99999;\r\nrange_fi = NULL;\r\nif (ptrs) {\r\nfor (j=0; j < ptrs->len; j++) {\r\ncfi = (field_info*) g_ptr_array_index(ptrs,j);\r\ncurr_end = cfi->start + cfi->length;\r\nif (curr_end > first_end && min_dist >= (curr_end - first_end) ) {\r\nrange_fi = cfi;\r\nmin_dist = curr_end - first_end;\r\n}\r\n}\r\nif ( range_fi ) {\r\nrange = (mate_range *)g_malloc(sizeof(*range));\r\nrange->start = range_fi->start;\r\nrange->end = range_fi->start + range_fi->length;\r\ng_ptr_array_add(data.ranges,range);\r\ndbg_print(dbg_pdu,3,dbg_facility,"new_pdu: payload(%i) range %i-%i",hfid,range->start,range->end);\r\n} else {\r\ndbg_print(dbg_pdu,5,dbg_facility,"new_pdu: payload(%i) missed",hfid);\r\n}\r\n}\r\n}\r\n}\r\ng_hash_table_foreach(cfg->hfids_attr,get_pdu_fields,&data);\r\napply_transforms(pdu->cfg->transforms,pdu->avpl);\r\ng_ptr_array_foreach(data.ranges, (GFunc)g_free, NULL);\r\ng_ptr_array_free(data.ranges,TRUE);\r\nreturn pdu;\r\n}\r\nextern void mate_analyze_frame(packet_info *pinfo, proto_tree* tree) {\r\nmate_cfg_pdu* cfg;\r\nGPtrArray* protos;\r\nfield_info* proto;\r\nguint i,j;\r\nAVPL* criterium_match;\r\nmate_pdu* pdu = NULL;\r\nmate_pdu* last = NULL;\r\nrd->now = (float) nstime_to_sec(&pinfo->rel_ts);\r\nif ( proto_tracking_interesting_fields(tree)\r\n&& rd->highest_analyzed_frame < pinfo->num ) {\r\nfor ( i = 0; i < mc->pducfglist->len; i++ ) {\r\ncfg = (mate_cfg_pdu *)g_ptr_array_index(mc->pducfglist,i);\r\ndbg_print (dbg_pdu,4,dbg_facility,"mate_analyze_frame: trying to extract: %s",cfg->name);\r\nprotos = proto_get_finfo_ptr_array(tree, cfg->hfid_proto);\r\nif (protos) {\r\npdu = NULL;\r\nfor (j = 0; j < protos->len; j++) {\r\ndbg_print (dbg_pdu,3,dbg_facility,"mate_analyze_frame: found matching proto, extracting: %s",cfg->name);\r\nproto = (field_info*) g_ptr_array_index(protos,j);\r\npdu = new_pdu(cfg, pinfo->num, proto, tree);\r\nif (cfg->criterium) {\r\ncriterium_match = new_avpl_from_match(cfg->criterium_match_mode,"",pdu->avpl,cfg->criterium,FALSE);\r\nif (criterium_match) {\r\ndelete_avpl(criterium_match,FALSE);\r\n}\r\nif ( (criterium_match && cfg->criterium_accept_mode == REJECT_MODE )\r\n|| ( ! criterium_match && cfg->criterium_accept_mode == ACCEPT_MODE )) {\r\ndelete_avpl(pdu->avpl,TRUE);\r\ng_slice_free(mate_max_size,(mate_max_size*)pdu);\r\npdu = NULL;\r\ncontinue;\r\n}\r\n}\r\nanalyze_pdu(pdu);\r\nif ( ! pdu->gop && cfg->drop_unassigned) {\r\ndelete_avpl(pdu->avpl,TRUE);\r\ng_slice_free(mate_max_size,(mate_max_size*)pdu);\r\npdu = NULL;\r\ncontinue;\r\n}\r\nif ( cfg->discard ) {\r\ndelete_avpl(pdu->avpl,TRUE);\r\npdu->avpl = NULL;\r\n}\r\nif (!last) {\r\ng_hash_table_insert(rd->frames,GINT_TO_POINTER(pinfo->num),pdu);\r\nlast = pdu;\r\n} else {\r\nlast->next_in_frame = pdu;\r\nlast = pdu;\r\n}\r\n}\r\nif ( pdu && cfg->last_extracted ) break;\r\n}\r\n}\r\nrd->highest_analyzed_frame = pinfo->num;\r\n}\r\n}\r\nextern mate_pdu* mate_get_pdus(guint32 framenum) {\r\nif (rd) {\r\nreturn (mate_pdu*) g_hash_table_lookup(rd->frames,GUINT_TO_POINTER(framenum));\r\n} else {\r\nreturn NULL;\r\n}\r\n}
