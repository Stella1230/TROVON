static int\r\ndissect_comrej(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nguint16 reason;\r\nreason = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_btamp_rej_reason, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nswitch (reason) {\r\ncase 0x0000:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_discoverrequest(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_btamp_mtu, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_btamp_extfeatures, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_controller_entry(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, guint16 idx)\r\n{\r\nproto_item *ti_controller_entry;\r\nproto_tree *btamp_controller_entry_tree;\r\nti_controller_entry = proto_tree_add_none_format(tree,\r\nhf_btamp_controllers, tvb,\r\noffset, 3,\r\n"Entry: %u", idx);\r\nbtamp_controller_entry_tree = proto_item_add_subtree(ti_controller_entry, ett_btamp_controller_entry);\r\nproto_tree_add_item(btamp_controller_entry_tree, hf_btamp_controller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(btamp_controller_entry_tree, hf_btamp_controller_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(btamp_controller_entry_tree, hf_btamp_controller_status, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_discoverresponse(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint16 length;\r\nguint16 idx = 1;\r\nproto_item *ti_controller_list;\r\nproto_tree *btamp_controller_list_tree;\r\nproto_tree_add_item(tree, hf_btamp_mtu, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_btamp_extfeatures, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nlength = tvb_reported_length_remaining(tvb, offset);\r\nti_controller_list = proto_tree_add_none_format(tree,\r\nhf_btamp_controller_list, tvb,\r\noffset, length,\r\n"Controller list");\r\nbtamp_controller_list_tree = proto_item_add_subtree(ti_controller_list, ett_btamp_controller_list);\r\nwhile (tvb_reported_length_remaining(tvb, offset) >= 3) {\r\noffset = dissect_controller_entry(tvb, offset, pinfo, btamp_controller_list_tree, idx);\r\nidx += 1;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_changenotify(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint16 length;\r\nguint16 idx = 1;\r\nproto_item *ti_controller_list;\r\nproto_tree *btamp_controller_list_tree;\r\nlength = tvb_reported_length_remaining(tvb, offset);\r\nti_controller_list = proto_tree_add_none_format(tree,\r\nhf_btamp_controller_list, tvb,\r\noffset, length,\r\n"Controller list");\r\nbtamp_controller_list_tree = proto_item_add_subtree(ti_controller_list, ett_btamp_controller_list);\r\nwhile (tvb_reported_length_remaining(tvb, offset) >= 3) {\r\noffset = dissect_controller_entry(tvb, offset, pinfo, btamp_controller_list_tree, idx);\r\nidx += 1;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_changeresponse(tvbuff_t *tvb _U_, int offset, packet_info *pinfo _U_, proto_tree *tree _U_)\r\n{\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_getinforequest(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_btamp_controller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_getinforesponse(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_item *ti_controller;\r\nproto_tree *btamp_controller_tree;\r\nproto_tree_add_item(tree, hf_btamp_controller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btamp_status, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btamp_total_bw, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_btamp_max_guaran_bw, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_btamp_min_latency, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nti_controller = proto_tree_add_none_format(tree,\r\nhf_btamp_pal_caps_mask, tvb,\r\noffset, 2,\r\n"PAL Capabilities");\r\nbtamp_controller_tree = proto_item_add_subtree(ti_controller, ett_btamp_caps);\r\nproto_tree_add_item(btamp_controller_tree, hf_btamp_pal_caps_guaranteed, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_btamp_amp_assoc_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_getampassocrequest(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_btamp_controller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_ampassoc(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_btamp_amp_assoc, tvb, offset, tvb_reported_length_remaining(tvb, offset), ENC_NA);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic int\r\ndissect_getampassocresponse(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_btamp_controller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btamp_status, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\noffset = dissect_ampassoc(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_createphysicalrequest(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_btamp_lcontroller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btamp_rcontroller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\noffset = dissect_ampassoc(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_createphysicalresponse(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_btamp_lcontroller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btamp_rcontroller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btamp_status, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_discphysicalchanrequest(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_btamp_lcontroller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btamp_rcontroller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_discphysicalchanresponse(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_item(tree, hf_btamp_lcontroller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btamp_rcontroller_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_btamp_controller_status, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_btamp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nint offset = 0;\r\nproto_item *ti;\r\nproto_tree *btamp_tree;\r\nguint16 length;\r\nproto_item *ti_command;\r\nproto_tree *btamp_cmd_tree;\r\nguint8 cmd_code;\r\nguint16 cmd_length;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "AMP");\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");\r\nbreak;\r\n}\r\nti = proto_tree_add_item(tree, proto_btamp, tvb, offset, -1, ENC_NA);\r\nbtamp_tree = proto_item_add_subtree(ti, ett_btamp);\r\nlength = tvb_reported_length_remaining(tvb, offset);\r\nti_command = proto_tree_add_none_format(btamp_tree,\r\nhf_btamp_command, tvb,\r\noffset, length,\r\n"Command: ");\r\nbtamp_cmd_tree = proto_item_add_subtree(ti_command, ett_btamp_cmd);\r\ncmd_code = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(btamp_cmd_tree, hf_btamp_cmd_code, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(btamp_cmd_tree, hf_btamp_cmd_ident, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\ncmd_length = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(btamp_cmd_tree, hf_btamp_cmd_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_item_set_len(ti_command, cmd_length+4);\r\noffset += 2;\r\nswitch(cmd_code) {\r\ncase 0x01:\r\noffset = dissect_comrej(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x02:\r\noffset = dissect_discoverrequest(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x03:\r\noffset = dissect_discoverresponse(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x04:\r\noffset = dissect_changenotify(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x05:\r\noffset = dissect_changeresponse(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x06:\r\noffset = dissect_getinforequest(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x07:\r\noffset = dissect_getinforesponse(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x08:\r\noffset = dissect_getampassocrequest(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x09:\r\noffset = dissect_getampassocresponse(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x0A:\r\noffset = dissect_createphysicalrequest(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x0B:\r\noffset = dissect_createphysicalresponse(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x0c:\r\noffset = dissect_discphysicalchanrequest(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ncase 0x0d:\r\noffset = dissect_discphysicalchanresponse(tvb, offset, pinfo, btamp_cmd_tree);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(btamp_cmd_tree, hf_btamp_cmd_data, tvb, offset, -1, ENC_NA);\r\noffset = tvb_reported_length(tvb);\r\nbreak;\r\n}\r\nproto_item_append_text(ti_command, "%s", val_to_str(cmd_code, command_code_vals, "Unknown PDU (%u)"));\r\ncol_append_str(pinfo->cinfo, COL_INFO, val_to_str(cmd_code, command_code_vals, "Unknown PDU (%u)"));\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_btamp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_btamp_command,\r\n{ "Command", "btamp.command",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\n"L2CAP Command", HFILL }\r\n},\r\n{ &hf_btamp_cmd_code,\r\n{ "Command Code", "btamp.cmd_code",\r\nFT_UINT8, BASE_HEX, VALS(command_code_vals), 0x0,\r\n"L2CAP Command Code", HFILL }\r\n},\r\n{ &hf_btamp_cmd_ident,\r\n{ "Command Identifier", "btamp.cmd_ident",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"L2CAP Command Identifier", HFILL }\r\n},\r\n{ &hf_btamp_cmd_length,\r\n{ "Command Length", "btamp.cmd_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"L2CAP Command Length", HFILL }\r\n},\r\n{ &hf_btamp_cmd_data,\r\n{ "Command Data", "btamp.cmd_data",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\n"L2CAP Command Data", HFILL }\r\n},\r\n{ &hf_btamp_rej_reason,\r\n{ "Reason", "btamp.rej_reason",\r\nFT_UINT16, BASE_HEX, VALS(reason_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_mtu,\r\n{ "MPS/MTU", "btamp.mps",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"MPS/MTU Size", HFILL }\r\n},\r\n{ &hf_btamp_extfeatures,\r\n{ "Extended Features", "btamp.extfeatures",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Extended Features Mask", HFILL }\r\n},\r\n{ &hf_btamp_controllers,\r\n{ "Controller entry", "btamp.ctrl_entry",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_controller_list,\r\n{ "Controller list", "btamp.ctrl_list",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_lcontroller_id,\r\n{ "Local Controller ID", "btamp.lctrl_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_rcontroller_id,\r\n{ "Remote Controller ID", "btamp.rctrl_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_controller_id,\r\n{ "Controller ID", "btamp.ctrl_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_controller_type,\r\n{ "Controller Type", "btamp.ctrl_type",\r\nFT_UINT8, BASE_DEC, VALS(controller_type_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_controller_status,\r\n{ "Controller Status", "btamp.ctrl_status",\r\nFT_UINT8, BASE_DEC, VALS(controller_status_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_status,\r\n{ "Status", "btamp.status",\r\nFT_UINT8, BASE_DEC, VALS(status_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_btamp_create_status,\r\n{ "Status", "btamp.create_status",\r\nFT_UINT8, BASE_DEC, VALS(create_status_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_disc_status,\r\n{ "Status", "btamp.disc_status",\r\nFT_UINT8, BASE_DEC, VALS(disc_status_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_btamp_pal_caps_mask,\r\n{ "PAL Capabilities Mask", "btamp.pal_caps_mask",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_pal_caps_guaranteed,\r\n{ "Guaranteed Service type", "btamp.guaranteed_type",\r\nFT_BOOLEAN, 16, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_total_bw,\r\n{ "Total Bandwidth", "btamp.total_bw",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_max_guaran_bw,\r\n{ "Max Guaranteed Bandwidth", "btamp.max_guaran_bw",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_min_latency,\r\n{ "Minimum latency", "btamp.min_latency",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_amp_assoc_size,\r\n{ "Assoc Size", "btamp.assoc_size",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btamp_amp_assoc,\r\n{ "Assoc", "btamp.assoc",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btamp,\r\n&ett_btamp_cmd,\r\n&ett_btamp_caps,\r\n&ett_btamp_controller_entry,\r\n&ett_btamp_controller_list,\r\n};\r\nproto_btamp = proto_register_protocol("Bluetooth AMP Packet", "BT AMP", "btamp");\r\nbtamp_handle = register_dissector("btamp", dissect_btamp, proto_btamp);\r\nproto_register_field_array(proto_btamp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_btamp(void)\r\n{\r\ndissector_add_uint("btl2cap.cid", BTL2CAP_FIXED_CID_AMP_MAN, btamp_handle);\r\n}
