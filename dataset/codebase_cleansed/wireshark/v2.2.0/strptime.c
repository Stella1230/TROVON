static struct tm *\r\nlocaltime_r (t, tp)\r\nconst time_t *t;\r\nstruct tm *tp;\r\n{\r\nstruct tm *l = localtime (t);\r\nif (! l)\r\nreturn 0;\r\n*tp = *l;\r\nreturn tp;\r\n}\r\nstatic void\r\nday_of_the_week (struct tm *tm)\r\n{\r\nint corr_year = 1900 + tm->tm_year - (tm->tm_mon < 2);\r\nint wday = (-473\r\n+ (365 * (tm->tm_year - 70))\r\n+ (corr_year / 4)\r\n- ((corr_year / 4) / 25) + ((corr_year / 4) % 25 < 0)\r\n+ (((corr_year / 4) / 25) / 4)\r\n+ __mon_yday[0][tm->tm_mon]\r\n+ tm->tm_mday - 1);\r\ntm->tm_wday = ((wday % 7) + 7) % 7;\r\n}\r\nstatic void\r\nday_of_the_year (struct tm *tm)\r\n{\r\ntm->tm_yday = (__mon_yday[__isleap (1900 + tm->tm_year)][tm->tm_mon]\r\n+ (tm->tm_mday - 1));\r\n}\r\nstatic char *\r\n#ifdef _LIBC\r\ninternal_function\r\n#endif\r\nstrptime_internal (rp, fmt, tm, decided, era_cnt)\r\nconst char *rp;\r\nconst char *fmt;\r\nstruct tm *tm;\r\nenum locale_status *decided;\r\nint era_cnt;\r\n{\r\nconst char *rp_backup;\r\nint cnt;\r\nint val;\r\nint have_I, is_pm;\r\nint century, want_century;\r\nint want_era;\r\nint have_wday, want_xday;\r\nint have_yday;\r\nint have_mon, have_mday;\r\n#ifdef _NL_CURRENT\r\nsize_t num_eras;\r\n#endif\r\nstruct era_entry *era;\r\nhave_I = is_pm = 0;\r\ncentury = -1;\r\nwant_century = 0;\r\nwant_era = 0;\r\nera = NULL;\r\nhave_wday = want_xday = have_yday = have_mon = have_mday = 0;\r\nwhile (*fmt != '\0')\r\n{\r\nif (isspace (*fmt))\r\n{\r\nwhile (isspace (*rp))\r\n++rp;\r\n++fmt;\r\ncontinue;\r\n}\r\nif (*fmt != '%')\r\n{\r\nmatch_char (*fmt++, *rp++);\r\ncontinue;\r\n}\r\n++fmt;\r\n#ifndef _NL_CURRENT\r\nstart_over:\r\n#endif\r\nrp_backup = rp;\r\nswitch (*fmt++)\r\n{\r\ncase '%':\r\nmatch_char ('%', *rp++);\r\nbreak;\r\ncase 'a':\r\ncase 'A':\r\nfor (cnt = 0; cnt < 7; ++cnt)\r\n{\r\n#ifdef _NL_CURRENT\r\nif (*decided !=raw)\r\n{\r\nif (match_string (_NL_CURRENT (LC_TIME, DAY_1 + cnt), rp))\r\n{\r\nif (*decided == not\r\n&& strcmp (_NL_CURRENT (LC_TIME, DAY_1 + cnt),\r\nweekday_name[cnt]))\r\n*decided = loc;\r\nbreak;\r\n}\r\nif (match_string (_NL_CURRENT (LC_TIME, ABDAY_1 + cnt), rp))\r\n{\r\nif (*decided == not\r\n&& strcmp (_NL_CURRENT (LC_TIME, ABDAY_1 + cnt),\r\nab_weekday_name[cnt]))\r\n*decided = loc;\r\nbreak;\r\n}\r\n}\r\n#endif\r\nif (*decided != loc\r\n&& (match_string (weekday_name[cnt], rp)\r\n|| match_string (ab_weekday_name[cnt], rp)))\r\n{\r\n*decided = raw;\r\nbreak;\r\n}\r\n}\r\nif (cnt == 7)\r\nreturn NULL;\r\ntm->tm_wday = cnt;\r\nhave_wday = 1;\r\nbreak;\r\ncase 'b':\r\ncase 'B':\r\ncase 'h':\r\nfor (cnt = 0; cnt < 12; ++cnt)\r\n{\r\n#ifdef _NL_CURRENT\r\nif (*decided !=raw)\r\n{\r\nif (match_string (_NL_CURRENT (LC_TIME, MON_1 + cnt), rp))\r\n{\r\nif (*decided == not\r\n&& strcmp (_NL_CURRENT (LC_TIME, MON_1 + cnt),\r\nmonth_name[cnt]))\r\n*decided = loc;\r\nbreak;\r\n}\r\nif (match_string (_NL_CURRENT (LC_TIME, ABMON_1 + cnt), rp))\r\n{\r\nif (*decided == not\r\n&& strcmp (_NL_CURRENT (LC_TIME, ABMON_1 + cnt),\r\nab_month_name[cnt]))\r\n*decided = loc;\r\nbreak;\r\n}\r\n}\r\n#endif\r\nif (match_string (month_name[cnt], rp)\r\n|| match_string (ab_month_name[cnt], rp))\r\n{\r\n*decided = raw;\r\nbreak;\r\n}\r\n}\r\nif (cnt == 12)\r\nreturn NULL;\r\ntm->tm_mon = cnt;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'c':\r\n#ifdef _NL_CURRENT\r\nif (*decided != raw)\r\n{\r\nif (!recursive (_NL_CURRENT (LC_TIME, D_T_FMT)))\r\n{\r\nif (*decided == loc)\r\nreturn NULL;\r\nelse\r\nrp = rp_backup;\r\n}\r\nelse\r\n{\r\nif (*decided == not &&\r\nstrcmp (_NL_CURRENT (LC_TIME, D_T_FMT), HERE_D_T_FMT))\r\n*decided = loc;\r\nwant_xday = 1;\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\n#endif\r\nif (!recursive (HERE_D_T_FMT))\r\nreturn NULL;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'C':\r\n#ifdef _NL_CURRENT\r\nmatch_century:\r\n#endif\r\nget_number (0, 99, 2);\r\ncentury = val;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'd':\r\ncase 'e':\r\nget_number (1, 31, 2);\r\ntm->tm_mday = val;\r\nhave_mday = 1;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'F':\r\nif (!recursive ("%Y-%m-%d"))\r\nreturn NULL;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'x':\r\n#ifdef _NL_CURRENT\r\nif (*decided != raw)\r\n{\r\nif (!recursive (_NL_CURRENT (LC_TIME, D_FMT)))\r\n{\r\nif (*decided == loc)\r\nreturn NULL;\r\nelse\r\nrp = rp_backup;\r\n}\r\nelse\r\n{\r\nif (*decided == not\r\n&& strcmp (_NL_CURRENT (LC_TIME, D_FMT), HERE_D_FMT))\r\n*decided = loc;\r\nwant_xday = 1;\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\n#endif\r\ncase 'D':\r\nif (!recursive (HERE_D_FMT))\r\nreturn NULL;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'k':\r\ncase 'H':\r\nget_number (0, 23, 2);\r\ntm->tm_hour = val;\r\nhave_I = 0;\r\nbreak;\r\ncase 'I':\r\nget_number (1, 12, 2);\r\ntm->tm_hour = val % 12;\r\nhave_I = 1;\r\nbreak;\r\ncase 'j':\r\nget_number (1, 366, 3);\r\ntm->tm_yday = val - 1;\r\nhave_yday = 1;\r\nbreak;\r\ncase 'm':\r\nget_number (1, 12, 2);\r\ntm->tm_mon = val - 1;\r\nhave_mon = 1;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'M':\r\nget_number (0, 59, 2);\r\ntm->tm_min = val;\r\nbreak;\r\ncase 'n':\r\ncase 't':\r\nwhile (isspace (*rp))\r\n++rp;\r\nbreak;\r\ncase 'p':\r\n#ifdef _NL_CURRENT\r\nif (*decided != raw)\r\n{\r\nif (match_string (_NL_CURRENT (LC_TIME, AM_STR), rp))\r\n{\r\nif (strcmp (_NL_CURRENT (LC_TIME, AM_STR), HERE_AM_STR))\r\n*decided = loc;\r\nbreak;\r\n}\r\nif (match_string (_NL_CURRENT (LC_TIME, PM_STR), rp))\r\n{\r\nif (strcmp (_NL_CURRENT (LC_TIME, PM_STR), HERE_PM_STR))\r\n*decided = loc;\r\nis_pm = 1;\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\n#endif\r\nif (!match_string (HERE_AM_STR, rp)) {\r\nif (match_string (HERE_PM_STR, rp))\r\nis_pm = 1;\r\nelse\r\nreturn NULL;\r\n}\r\nbreak;\r\ncase 'r':\r\n#ifdef _NL_CURRENT\r\nif (*decided != raw)\r\n{\r\nif (!recursive (_NL_CURRENT (LC_TIME, T_FMT_AMPM)))\r\n{\r\nif (*decided == loc)\r\nreturn NULL;\r\nelse\r\nrp = rp_backup;\r\n}\r\nelse\r\n{\r\nif (*decided == not &&\r\nstrcmp (_NL_CURRENT (LC_TIME, T_FMT_AMPM),\r\nHERE_T_FMT_AMPM))\r\n*decided = loc;\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\n#endif\r\nif (!recursive (HERE_T_FMT_AMPM))\r\nreturn NULL;\r\nbreak;\r\ncase 'R':\r\nif (!recursive ("%H:%M"))\r\nreturn NULL;\r\nbreak;\r\ncase 's':\r\n{\r\ntime_t secs = 0;\r\nif (*rp < '0' || *rp > '9')\r\nreturn NULL;\r\ndo\r\n{\r\nsecs *= 10;\r\nsecs += *rp++ - '0';\r\n}\r\nwhile (*rp >= '0' && *rp <= '9');\r\nif (localtime_r (&secs, tm) == NULL)\r\nreturn NULL;\r\n}\r\nbreak;\r\ncase 'S':\r\nget_number (0, 61, 2);\r\ntm->tm_sec = val;\r\nbreak;\r\ncase 'X':\r\n#ifdef _NL_CURRENT\r\nif (*decided != raw)\r\n{\r\nif (!recursive (_NL_CURRENT (LC_TIME, T_FMT)))\r\n{\r\nif (*decided == loc)\r\nreturn NULL;\r\nelse\r\nrp = rp_backup;\r\n}\r\nelse\r\n{\r\nif (strcmp (_NL_CURRENT (LC_TIME, T_FMT), HERE_T_FMT))\r\n*decided = loc;\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\n#endif\r\ncase 'T':\r\nif (!recursive (HERE_T_FMT))\r\nreturn NULL;\r\nbreak;\r\ncase 'u':\r\nget_number (1, 7, 1);\r\ntm->tm_wday = val % 7;\r\nhave_wday = 1;\r\nbreak;\r\ncase 'g':\r\nget_number (0, 99, 2);\r\nbreak;\r\ncase 'G':\r\nif (*rp < '0' || *rp > '9')\r\nreturn NULL;\r\ndo\r\n++rp;\r\nwhile (*rp >= '0' && *rp <= '9');\r\nbreak;\r\ncase 'U':\r\ncase 'V':\r\ncase 'W':\r\nget_number (0, 53, 2);\r\nbreak;\r\ncase 'w':\r\nget_number (0, 6, 1);\r\ntm->tm_wday = val;\r\nhave_wday = 1;\r\nbreak;\r\ncase 'y':\r\n#ifdef _NL_CURRENT\r\nmatch_year_in_century:\r\n#endif\r\nget_number (0, 99, 2);\r\ntm->tm_year = val >= 69 ? val : val + 100;\r\nwant_century = 1;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'Y':\r\nget_number (0, 9999, 4);\r\ntm->tm_year = val - 1900;\r\nwant_century = 0;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'Z':\r\nbreak;\r\ncase 'E':\r\n#ifdef _NL_CURRENT\r\nswitch (*fmt++)\r\n{\r\ncase 'c':\r\nif (*decided != raw)\r\n{\r\nconst char *fmt = _NL_CURRENT (LC_TIME, ERA_D_T_FMT);\r\nif (*fmt == '\0')\r\nfmt = _NL_CURRENT (LC_TIME, D_T_FMT);\r\nif (!recursive (fmt))\r\n{\r\nif (*decided == loc)\r\nreturn NULL;\r\nelse\r\nrp = rp_backup;\r\n}\r\nelse\r\n{\r\nif (strcmp (fmt, HERE_D_T_FMT))\r\n*decided = loc;\r\nwant_xday = 1;\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\nif (!recursive (HERE_D_T_FMT))\r\nreturn NULL;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'C':\r\nif (*decided != raw)\r\n{\r\nif (era_cnt >= 0)\r\n{\r\nera = _nl_select_era_entry (era_cnt);\r\nif (match_string (era->era_name, rp))\r\n{\r\n*decided = loc;\r\nbreak;\r\n}\r\nelse\r\nreturn NULL;\r\n}\r\nelse\r\n{\r\nnum_eras = _NL_CURRENT_WORD (LC_TIME,\r\n_NL_TIME_ERA_NUM_ENTRIES);\r\nfor (era_cnt = 0; era_cnt < (int) num_eras;\r\n++era_cnt, rp = rp_backup)\r\n{\r\nera = _nl_select_era_entry (era_cnt);\r\nif (match_string (era->era_name, rp))\r\n{\r\n*decided = loc;\r\nbreak;\r\n}\r\n}\r\nif (era_cnt == (int) num_eras)\r\n{\r\nera_cnt = -1;\r\nif (*decided == loc)\r\nreturn NULL;\r\n}\r\nelse\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\ngoto match_century;\r\ncase 'y':\r\nif (*decided == raw)\r\ngoto match_year_in_century;\r\nget_number(0, 9999, 4);\r\ntm->tm_year = val;\r\nwant_era = 1;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'Y':\r\nif (*decided != raw)\r\n{\r\nnum_eras = _NL_CURRENT_WORD (LC_TIME,\r\n_NL_TIME_ERA_NUM_ENTRIES);\r\nfor (era_cnt = 0; era_cnt < (int) num_eras;\r\n++era_cnt, rp = rp_backup)\r\n{\r\nera = _nl_select_era_entry (era_cnt);\r\nif (recursive (era->era_format))\r\nbreak;\r\n}\r\nif (era_cnt == (int) num_eras)\r\n{\r\nera_cnt = -1;\r\nif (*decided == loc)\r\nreturn NULL;\r\nelse\r\nrp = rp_backup;\r\n}\r\nelse\r\n{\r\n*decided = loc;\r\nera_cnt = -1;\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\nget_number (0, 9999, 4);\r\ntm->tm_year = val - 1900;\r\nwant_century = 0;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'x':\r\nif (*decided != raw)\r\n{\r\nconst char *fmt = _NL_CURRENT (LC_TIME, ERA_D_FMT);\r\nif (*fmt == '\0')\r\nfmt = _NL_CURRENT (LC_TIME, D_FMT);\r\nif (!recursive (fmt))\r\n{\r\nif (*decided == loc)\r\nreturn NULL;\r\nelse\r\nrp = rp_backup;\r\n}\r\nelse\r\n{\r\nif (strcmp (fmt, HERE_D_FMT))\r\n*decided = loc;\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\nif (!recursive (HERE_D_FMT))\r\nreturn NULL;\r\nbreak;\r\ncase 'X':\r\nif (*decided != raw)\r\n{\r\nconst char *fmt = _NL_CURRENT (LC_TIME, ERA_T_FMT);\r\nif (*fmt == '\0')\r\nfmt = _NL_CURRENT (LC_TIME, T_FMT);\r\nif (!recursive (fmt))\r\n{\r\nif (*decided == loc)\r\nreturn NULL;\r\nelse\r\nrp = rp_backup;\r\n}\r\nelse\r\n{\r\nif (strcmp (fmt, HERE_T_FMT))\r\n*decided = loc;\r\nbreak;\r\n}\r\n*decided = raw;\r\n}\r\nif (!recursive (HERE_T_FMT))\r\nreturn NULL;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nbreak;\r\n#else\r\nif (*fmt != 'c' && *fmt != 'C' && *fmt != 'y' && *fmt != 'Y'\r\n&& *fmt != 'x' && *fmt != 'X')\r\nreturn NULL;\r\ngoto start_over;\r\n#endif\r\ncase 'O':\r\nswitch (*fmt++)\r\n{\r\ncase 'd':\r\ncase 'e':\r\nget_alt_number (1, 31, 2);\r\ntm->tm_mday = val;\r\nhave_mday = 1;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'H':\r\nget_alt_number (0, 23, 2);\r\ntm->tm_hour = val;\r\nhave_I = 0;\r\nbreak;\r\ncase 'I':\r\nget_alt_number (1, 12, 2);\r\ntm->tm_hour = val - 1;\r\nhave_I = 1;\r\nbreak;\r\ncase 'm':\r\nget_alt_number (1, 12, 2);\r\ntm->tm_mon = val - 1;\r\nhave_mon = 1;\r\nwant_xday = 1;\r\nbreak;\r\ncase 'M':\r\nget_alt_number (0, 59, 2);\r\ntm->tm_min = val;\r\nbreak;\r\ncase 'S':\r\nget_alt_number (0, 61, 2);\r\ntm->tm_sec = val;\r\nbreak;\r\ncase 'U':\r\ncase 'V':\r\ncase 'W':\r\nget_alt_number (0, 53, 2);\r\nbreak;\r\ncase 'w':\r\nget_alt_number (0, 6, 1);\r\ntm->tm_wday = val;\r\nhave_wday = 1;\r\nbreak;\r\ncase 'y':\r\nget_alt_number (0, 99, 2);\r\ntm->tm_year = val >= 69 ? val : val + 100;\r\nwant_xday = 1;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nif (have_I && is_pm)\r\ntm->tm_hour += 12;\r\nif (century != -1)\r\n{\r\nif (want_century)\r\ntm->tm_year = tm->tm_year % 100 + (century - 19) * 100;\r\nelse\r\ntm->tm_year = (century - 19) * 100;\r\n}\r\n#ifdef _NL_CURRENT\r\nif (era_cnt != -1)\r\n{\r\nera = _nl_select_era_entry(era_cnt);\r\nif (want_era)\r\ntm->tm_year = (era->start_date[0]\r\n+ ((tm->tm_year - era->offset)\r\n* era->absolute_direction));\r\nelse\r\ntm->tm_year = era->start_date[0];\r\n}\r\nelse\r\n#endif\r\nif (want_era)\r\nreturn NULL;\r\nif (want_xday && !have_wday)\r\n{\r\nif ( !(have_mon && have_mday) && have_yday)\r\n{\r\nint t_mon = 0;\r\nwhile (__mon_yday[__isleap(1900 + tm->tm_year)][t_mon] <= tm->tm_yday)\r\nt_mon++;\r\nif (!have_mon)\r\ntm->tm_mon = t_mon - 1;\r\nif (!have_mday)\r\ntm->tm_mday =\r\n(tm->tm_yday\r\n- __mon_yday[__isleap(1900 + tm->tm_year)][t_mon - 1] + 1);\r\n}\r\nday_of_the_week (tm);\r\n}\r\nif (want_xday && !have_yday)\r\nday_of_the_year (tm);\r\nreturn (char *) rp;\r\n}\r\nchar *\r\nstrptime (buf, format, tm)\r\nconst char *buf;\r\nconst char *format;\r\nstruct tm *tm;\r\n{\r\nenum locale_status decided;\r\n#ifdef _NL_CURRENT\r\ndecided = not;\r\n#else\r\ndecided = raw;\r\n#endif\r\nreturn strptime_internal (buf, format, tm, &decided, -1);\r\n}
