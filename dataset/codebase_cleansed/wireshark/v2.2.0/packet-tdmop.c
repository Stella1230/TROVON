static int dissect_tdmop(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint8 dchannel_data[MAX_DCHANNEL_LEN];\r\nguint dchannel_len;\r\nguint8 flags;\r\ngint offset;\r\nproto_item *ti;\r\nproto_tree *tdmop_tree;\r\nguint32 dstch;\r\nguint32 srcch;\r\nflags = tvb_get_guint8(tvb, 4);\r\noffset = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TDMoP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (flags & TDMOP_FLAG_LOST_REQUEST)\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Lost Request");\r\n}\r\ndstch = tvb_get_guint8(tvb, offset + 2);\r\nsrcch = tvb_get_guint8(tvb, offset + 3);\r\npinfo->destport = dstch;\r\npinfo->srcport = srcch;\r\npinfo->ptype = PT_TDMOP;\r\nti = proto_tree_add_item(tree, proto_tdmop, tvb, 0, -1, ENC_NA);\r\ntdmop_tree = proto_item_add_subtree(ti, ett_tdmop);\r\nproto_tree_add_item(tdmop_tree, hf_tdmop_TransferID, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tdmop_tree, hf_tdmop_DstCh, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tdmop_tree, hf_tdmop_SrcCh, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tdmop_tree, hf_tdmop_Flags, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tdmop_tree, hf_tdmop_Flags_no_data, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tdmop_tree, hf_tdmop_Flags_lost_request, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tdmop_tree, hf_tdmop_Flags_remote_no_data, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tdmop_tree, hf_tdmop_Flags_compressed, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(tdmop_tree, hd_tdmop_SrcDst, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tdmop_tree, hd_tdmop_SeqNum, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tdmop_tree, hd_tdmop_LastRecv, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tdmop_tree, hd_tdmop_Delay, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tdmop_tree, hd_tdmop_Reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nif ((flags & TDMOP_FLAG_NO_DATA)==0)\r\n{\r\ngint len;\r\ngint blockid;\r\ndchannel_len=0;\r\nlen=tvb_captured_length_remaining(tvb, 0);\r\nproto_tree_add_item(tdmop_tree, hf_tdmop_payload, tvb, offset, -1, ENC_NA);\r\nblockid=0;\r\nwhile (offset<len)\r\n{\r\nproto_tree *currentblock = proto_tree_add_subtree_format(tdmop_tree, tvb, 0, 0, ett_tdmop_channel, 0, "Block %d", blockid);\r\nguint32 mask;\r\ngint i;\r\ngint j;\r\nblockid++;\r\nmask = pref_tdmop_mask;\r\nif (flags&TDMOP_FLAG_COMPRESSED)\r\n{\r\nmask = tvb_get_letohl(tvb,offset);\r\nmask = ((mask >> 16) & 0xFFFF)|((mask & 0xFFFF) << 16);\r\nproto_tree_add_uint_format_value(currentblock, hf_tdmop_Compression_mask, tvb, offset, 4, mask, "%08X", mask);\r\noffset+=4;\r\n}\r\nfor (i=0; i<32; i++)\r\n{\r\nif (mask & (1UL<<i))\r\n{\r\nproto_tree *subtree;\r\ntvbuff_t *cdata;\r\nsubtree = proto_tree_add_subtree_format(currentblock, tvb, 0, 0, ett_tdmop_channel, 0, "Channel %d", i);\r\ncdata = tvb_new_subset_length(tvb, offset, 4);\r\nif (i==pref_tdmop_d_channel)\r\n{\r\nif (dchannel_len + 4 < MAX_DCHANNEL_LEN)\r\n{\r\nfor (j = 0; j < 4; j++)\r\n{\r\ndchannel_data[dchannel_len+j]=reverse_map[tvb_get_guint8(cdata, j)];\r\n}\r\ndchannel_len += 4;\r\n}\r\n} else\r\n{\r\ncall_data_dissector(cdata, pinfo, subtree);\r\n}\r\noffset += 4;\r\n}\r\n}\r\n}\r\nif (dchannel_len>0)\r\n{\r\nguint8 *buff = (guint8 *)g_memdup(dchannel_data, dchannel_len);\r\ntvbuff_t *new_tvb;\r\nnew_tvb = tvb_new_child_real_data(tvb, buff, dchannel_len, dchannel_len);\r\ntvb_set_free_cb(new_tvb, g_free);\r\ncall_dissector(lapd_handle, new_tvb, pinfo, tree);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_tdmop(void)\r\n{\r\nmodule_t *tdmop_module;\r\nstatic hf_register_info hf[] =\r\n{\r\n{\r\n&hf_tdmop_TransferID,\r\n{ "TDMoP Transfer ID", "tdmop.transferid",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hf_tdmop_DstCh,\r\n{ "TDMoP Dst Ch", "tdmop.dstch",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hf_tdmop_SrcCh,\r\n{ "TDMoP Src Ch", "tdmop.srcch",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hf_tdmop_Flags,\r\n{ "TDMoP Flags", "tdmop.flags",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hf_tdmop_Flags_lost_request,\r\n{ "TDMoP Lost Request Flag", "tdmop.flags.lostrequest",\r\nFT_BOOLEAN, 8,\r\nNULL, TDMOP_FLAG_LOST_REQUEST,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hf_tdmop_Flags_no_data,\r\n{ "TDMoP No data flag", "tdmop.flags.nodata",\r\nFT_BOOLEAN, 8,\r\nNULL, TDMOP_FLAG_NO_DATA,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hf_tdmop_Flags_remote_no_data,\r\n{ "TDMoP No data received from remote side flag", "tdmop.flags.remotenodata",\r\nFT_BOOLEAN, 8,\r\nNULL, TDMOP_FLAG_REMOTE_NO_DATA,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hf_tdmop_Flags_compressed,\r\n{ "TDMoP compressed framed", "tdmop.flags.compressed",\r\nFT_BOOLEAN, 8,\r\nNULL, TDMOP_FLAG_COMPRESSED,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hd_tdmop_SrcDst,\r\n{ "TDMoP Short SrcDst", "tdmop.srcdst",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hd_tdmop_SeqNum,\r\n{ "TDMoP Sequence number", "tdmop.seqnum",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hd_tdmop_LastRecv,\r\n{ "TDMoP Last Received number", "tdmop.recvnumber",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hd_tdmop_Delay,\r\n{ "TDMoP Delay", "tdmop.delay",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hd_tdmop_Reserved,\r\n{ "TDMoP Reserved", "tdmop.reserved",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hf_tdmop_payload,\r\n{ "TDMoP Payload", "tdmop.payload",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{\r\n&hf_tdmop_Compression_mask,\r\n{ "TDMoP Compression mask", "tdmop.cmask",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL}\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tdmop,\r\n&ett_tdmop_channel\r\n};\r\nproto_tdmop = proto_register_protocol (\r\n"TDMoP protocol",\r\n"TDMoP",\r\n"tdmop"\r\n);\r\nproto_register_field_array(proto_tdmop, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ntdmop_module = prefs_register_protocol(proto_tdmop, proto_reg_handoff_tdmop);\r\nprefs_register_uint_preference(tdmop_module, "d_channel",\r\n"TDMoP D-Channel",\r\n"The TDMoD channel that contains the D-Channel.",\r\n10, &pref_tdmop_d_channel);\r\nprefs_register_uint_preference(tdmop_module, "ts_mask",\r\n"TDMoP default timeslot mask",\r\n"The bitmask of channels in uncompressed TDMoP frame",\r\n16, &pref_tdmop_mask);\r\nprefs_register_uint_preference(tdmop_module, "ethertype",\r\n"Ethertype for TDMoP stream(Usually 0808)",\r\n"The ethertype assigned to TDMoP (without IP/UDP) stream",\r\n16, &pref_tdmop_ethertype);\r\nprefs_register_uint_preference(tdmop_module, "udpport",\r\n"UDP Port of TDMoP stream(Usually 41000)",\r\n"The udp port assigned to TDMoP stream",\r\n10, &pref_tdmop_udpport);\r\n}\r\nvoid proto_reg_handoff_tdmop(void)\r\n{\r\nstatic dissector_handle_t tdmop_handle;\r\nstatic gboolean init = FALSE;\r\nstatic guint32 current_tdmop_ethertype;\r\nstatic guint32 current_tdmop_udpport;\r\nif (!init)\r\n{\r\ntdmop_handle = create_dissector_handle(dissect_tdmop, proto_tdmop);\r\nif (pref_tdmop_udpport) {\r\ndissector_add_uint("udp.port", pref_tdmop_udpport, tdmop_handle);\r\n}\r\nif (pref_tdmop_ethertype) {\r\ndissector_add_uint("ethertype", pref_tdmop_ethertype, tdmop_handle);\r\n}\r\nlapd_handle = find_dissector_add_dependency("lapd-bitstream", proto_tdmop);\r\ncurrent_tdmop_ethertype = pref_tdmop_ethertype;\r\ncurrent_tdmop_udpport = pref_tdmop_udpport;\r\ninit = TRUE;\r\n}\r\nif (current_tdmop_ethertype != pref_tdmop_ethertype)\r\n{\r\ndissector_delete_uint("ethertype", current_tdmop_ethertype, tdmop_handle);\r\nif (pref_tdmop_ethertype) {\r\ndissector_add_uint("ethertype", pref_tdmop_ethertype, tdmop_handle);\r\n}\r\ncurrent_tdmop_ethertype = pref_tdmop_ethertype;\r\n}\r\nif (current_tdmop_udpport != pref_tdmop_udpport)\r\n{\r\ndissector_delete_uint("udp.port", current_tdmop_udpport, tdmop_handle);\r\nif (pref_tdmop_udpport) {\r\ndissector_add_uint("udp.port", pref_tdmop_udpport, tdmop_handle);\r\n}\r\ncurrent_tdmop_udpport = pref_tdmop_udpport;\r\n}\r\n}
