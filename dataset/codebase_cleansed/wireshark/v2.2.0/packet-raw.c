static gboolean\r\ncapture_raw(const guchar *pd, int offset _U_, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\r\n{\r\nif (BYTES_ARE_IN_FRAME(0,len,2) && pd[0] == 0xff && pd[1] == 0x03) {\r\nreturn capture_ppp_hdlc(pd, 0, len, cpinfo, pseudo_header);\r\n}\r\nelse if (BYTES_ARE_IN_FRAME(0,len,8) && pd[6] == 0xff && pd[7] == 0x03) {\r\nreturn capture_ppp_hdlc(pd, 6, len, cpinfo, pseudo_header);\r\n}\r\nelse if (BYTES_ARE_IN_FRAME(0,len,3) && pd[1] == 0xff && pd[2] == 0x03) {\r\nreturn capture_ppp_hdlc(pd, 1, len, cpinfo, pseudo_header);\r\n}\r\nelse if (BYTES_ARE_IN_FRAME(0,len,10) && memcmp(pd, zeroes, 10) == 0) {\r\nreturn capture_ip(pd, 10, len, cpinfo, pseudo_header);\r\n}\r\nelse {\r\nif (BYTES_ARE_IN_FRAME(0,len,1)) {\r\nswitch (pd[0] & 0xF0) {\r\ncase 0x40:\r\nreturn capture_ip(pd, 0, len, cpinfo, pseudo_header);\r\n#if 0\r\ncase 0x60:\r\nreturn capture_ipv6(pd, 0, len, cpinfo, pseudo_header);\r\n#endif\r\n}\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic int\r\ndissect_raw(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Raw packet data");\r\nproto_tree_add_item(tree, proto_raw, tvb, 0, tvb_captured_length(tvb), ENC_NA);\r\nif (tvb_get_ntohs(tvb, 0) == 0xff03) {\r\ncall_dissector(ppp_hdlc_handle, tvb, pinfo, tree);\r\n}\r\nelse if (tvb_get_ntohs(tvb, 6) == 0xff03) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, 6);\r\ncall_dissector(ppp_hdlc_handle, next_tvb, pinfo, tree);\r\n}\r\nelse if (tvb_get_ntohs(tvb, 1) == 0xff03) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, 1);\r\ncall_dissector(ppp_hdlc_handle, next_tvb, pinfo, tree);\r\n}\r\nelse if (tvb_memeql(tvb, 0, zeroes,10) == 0) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, 10);\r\ncall_dissector(ip_handle, next_tvb, pinfo, tree);\r\n}\r\nelse {\r\nswitch (tvb_get_guint8(tvb, 0) & 0xF0) {\r\ncase 0x40:\r\ncall_dissector(ip_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase 0x60:\r\ncall_dissector(ipv6_handle, tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\ncall_data_dissector(tvb, pinfo, tree);\r\nbreak;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_raw(void)\r\n{\r\nstatic gint *ett[] = {\r\n&ett_raw,\r\n};\r\nproto_raw = proto_register_protocol("Raw packet data", "Raw", "raw");\r\nproto_register_subtree_array(ett, array_length(ett));\r\nraw_handle = register_dissector("raw_ip", dissect_raw, proto_raw);\r\n}\r\nvoid\r\nproto_reg_handoff_raw(void)\r\n{\r\nip_handle = find_dissector_add_dependency("ip", proto_raw);\r\nipv6_handle = find_dissector_add_dependency("ipv6", proto_raw);\r\nppp_hdlc_handle = find_dissector_add_dependency("ppp_hdlc", proto_raw);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_RAW_IP, raw_handle);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_RAW_IP, capture_raw, proto_raw);\r\n}
