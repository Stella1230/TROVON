gssize lzxpress_decompress(const guint8 *input,\r\nguint32 input_size,\r\nguint8 *output,\r\nguint32 max_output_size)\r\n{\r\nguint32 output_index, input_index;\r\nguint32 indicator, indicator_bit;\r\nguint32 length;\r\nguint32 offset;\r\nguint32 nibble_index;\r\noutput_index = 0;\r\ninput_index = 0;\r\nindicator = 0;\r\nindicator_bit = 0;\r\nnibble_index = 0;\r\ndo {\r\nif (indicator_bit == 0) {\r\nindicator = PULL_LE_UINT32(input, input_index);\r\ninput_index += (guint32)sizeof(guint32);\r\nindicator_bit = 32;\r\n}\r\nindicator_bit--;\r\nif (((indicator >> indicator_bit) & 1) == 0) {\r\noutput[output_index] = input[input_index];\r\ninput_index += (guint32)sizeof(guint8);\r\noutput_index += (guint32)sizeof(guint8);\r\n} else {\r\nlength = PULL_LE_UINT16(input, input_index);\r\ninput_index += (guint32)sizeof(guint16);\r\noffset = length / 8;\r\nlength = length % 8;\r\nif (length == 7) {\r\nif (nibble_index == 0) {\r\nnibble_index = input_index;\r\nlength = input[input_index] % 16;\r\ninput_index += (guint32)sizeof(guint8);\r\n} else {\r\nlength = input[nibble_index] / 16;\r\nnibble_index = 0;\r\n}\r\nif (length == 15) {\r\nlength = input[input_index];\r\ninput_index += (guint32)sizeof(guint8);\r\nif (length == 255) {\r\nlength = PULL_LE_UINT16(input, input_index);\r\ninput_index += (guint32)sizeof(guint16);\r\nlength -= (15 + 7);\r\n}\r\nlength += 15;\r\n}\r\nlength += 7;\r\n}\r\nlength += 3;\r\ndo {\r\nif ((output_index >= max_output_size) || ((offset + 1) > output_index)) break;\r\noutput[output_index] = output[output_index - offset - 1];\r\noutput_index += (guint32)sizeof(guint8);\r\nlength -= (guint32)sizeof(guint8);\r\n} while (length != 0);\r\n}\r\n} while ((output_index < max_output_size) && (input_index < (input_size)));\r\nreturn output_index;\r\n}
