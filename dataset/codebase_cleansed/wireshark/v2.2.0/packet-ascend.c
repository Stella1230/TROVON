static int\r\ndissect_ascend(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *fh_tree;\r\nproto_item *ti, *hidden_item;\r\nunion wtap_pseudo_header *pseudo_header = pinfo->pseudo_header;\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Lucent/Ascend packet trace");\r\nswitch (pseudo_header->ascend.type) {\r\ncase ASCEND_PFX_WDS_X:\r\npinfo->p2p_dir = P2P_DIR_SENT;\r\nbreak;\r\ncase ASCEND_PFX_WDS_R:\r\npinfo->p2p_dir = P2P_DIR_RECV;\r\nbreak;\r\n}\r\nif(tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_ascend, tvb, 0, 0,\r\n"Lucent/Ascend packet trace");\r\nfh_tree = proto_item_add_subtree(ti, ett_raw);\r\nproto_tree_add_uint(fh_tree, hf_link_type, tvb, 0, 0,\r\npseudo_header->ascend.type);\r\nif (pseudo_header->ascend.type == ASCEND_PFX_WDD) {\r\nproto_tree_add_string(fh_tree, hf_called_number, tvb, 0, 0,\r\npseudo_header->ascend.call_num);\r\nproto_tree_add_uint(fh_tree, hf_chunk, tvb, 0, 0,\r\npseudo_header->ascend.chunk);\r\nhidden_item = proto_tree_add_uint(fh_tree, hf_session_id, tvb, 0, 0, 0);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\n} else {\r\nproto_tree_add_string(fh_tree, hf_user_name, tvb, 0, 0,\r\npseudo_header->ascend.user);\r\nproto_tree_add_uint(fh_tree, hf_session_id, tvb, 0, 0,\r\npseudo_header->ascend.sess);\r\nhidden_item = proto_tree_add_uint(fh_tree, hf_chunk, tvb, 0, 0, 0);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\n}\r\nproto_tree_add_uint(fh_tree, hf_task, tvb, 0, 0, pseudo_header->ascend.task);\r\n}\r\nswitch (pseudo_header->ascend.type) {\r\ncase ASCEND_PFX_WDS_X:\r\ncase ASCEND_PFX_WDS_R:\r\ncall_dissector(ppp_hdlc_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase ASCEND_PFX_WDD:\r\ncall_dissector(eth_withoutfcs_handle, tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ascend(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_link_type,\r\n{ "Link type", "ascend.type", FT_UINT32, BASE_DEC, VALS(encaps_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_session_id,\r\n{ "Session ID", "ascend.sess", FT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_called_number,\r\n{ "Called number", "ascend.number", FT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_chunk,\r\n{ "WDD Chunk", "ascend.chunk", FT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_task,\r\n{ "Task", "ascend.task", FT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_user_name,\r\n{ "User name", "ascend.user", FT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_raw,\r\n};\r\nproto_ascend = proto_register_protocol("Lucent/Ascend debug output",\r\n"Lucent/Ascend", "ascend");\r\nproto_register_field_array(proto_ascend, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_ascend(void)\r\n{\r\ndissector_handle_t ascend_handle;\r\neth_withoutfcs_handle = find_dissector_add_dependency("eth_withoutfcs", proto_ascend);\r\nppp_hdlc_handle = find_dissector_add_dependency("ppp_hdlc", proto_ascend);\r\nascend_handle = create_dissector_handle(dissect_ascend, proto_ascend);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_ASCEND, ascend_handle);\r\n}
