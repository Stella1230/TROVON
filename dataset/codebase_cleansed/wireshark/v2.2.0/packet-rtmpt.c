static void rtmpt_debug(const char *fmt, ...)\r\n{\r\nva_list args;\r\nva_start(args, fmt);\r\nvprintf(fmt, args);\r\n}\r\nstatic void rtmpt_debug(const char *fmt, ...){ (void)fmt; }\r\nstatic gint rtmpt_basic_header_length(gint id)\r\n{\r\nswitch (id & 0x3f) {\r\ncase 0: return 2;\r\ncase 1: return 3;\r\ndefault: return 1;\r\n}\r\n}\r\nstatic gint rtmpt_message_header_length(gint id)\r\n{\r\nswitch ((id>>6) & 3) {\r\ncase 0: return 11;\r\ncase 1: return 7;\r\ncase 2: return 3;\r\ndefault: return 0;\r\n}\r\n}\r\nstatic gint\r\nrtmpt_get_amf_length(tvbuff_t *tvb, gint offset)\r\n{\r\nguint8 iObjType;\r\ngint remain = tvb_reported_length_remaining(tvb, offset);\r\nguint32 depth = 0;\r\ngint itemlen = 0;\r\ngint rv = 0;\r\nwhile (rv == 0 || depth > 0) {\r\nif (depth > 0) {\r\nif (remain-rv < 2)\r\nreturn remain;\r\nitemlen = tvb_get_ntohs(tvb, offset+rv) + 2;\r\nif (remain-rv<itemlen+1)\r\nreturn remain;\r\nrv += itemlen;\r\n}\r\nif (remain-rv < 1)\r\nreturn remain;\r\niObjType = tvb_get_guint8(tvb, offset+rv);\r\nif (depth > 0 && itemlen == 2 && iObjType == AMF0_END_OF_OBJECT) {\r\nrv++;\r\ndepth--;\r\ncontinue;\r\n}\r\nswitch (iObjType) {\r\ncase AMF0_NUMBER:\r\nitemlen = 9;\r\nbreak;\r\ncase AMF0_BOOLEAN:\r\nitemlen = 2;\r\nbreak;\r\ncase AMF0_STRING:\r\nif (remain-rv < 3)\r\nreturn remain;\r\nitemlen = tvb_get_ntohs(tvb, offset+rv+1) + 3;\r\nbreak;\r\ncase AMF0_NULL:\r\ncase AMF0_UNDEFINED:\r\ncase AMF0_UNSUPPORTED:\r\nitemlen= 1;\r\nbreak;\r\ncase AMF0_DATE:\r\nitemlen = 11;\r\nbreak;\r\ncase AMF0_LONG_STRING:\r\ncase AMF0_XML:\r\nif (remain-rv < 5)\r\nreturn remain;\r\nitemlen = tvb_get_ntohl(tvb, offset+rv+1) + 5;\r\nbreak;\r\ncase AMF0_INT64:\r\nitemlen = 9;\r\nbreak;\r\ncase AMF0_OBJECT:\r\nitemlen = 1;\r\ndepth++;\r\nbreak;\r\ncase AMF0_ECMA_ARRAY:\r\nitemlen = 5;\r\ndepth++;\r\nbreak;\r\ndefault:\r\nreturn remain;\r\n}\r\nif (remain-rv < itemlen)\r\nreturn remain;\r\nrv += itemlen;\r\n}\r\nreturn rv;\r\n}\r\nstatic gchar *\r\nrtmpt_get_amf_param(tvbuff_t *tvb, gint offset, gint param, const gchar *prop)\r\n{\r\nguint32 remain = tvb_reported_length_remaining(tvb, offset);\r\nguint32 itemlen;\r\nguint32 iStringLength;\r\nwhile (remain > 0 && param > 0) {\r\nitemlen = rtmpt_get_amf_length(tvb, offset);\r\noffset += itemlen;\r\nremain -= itemlen;\r\nparam--;\r\n}\r\nif (remain > 0 && param == 0) {\r\nguint8 iObjType = tvb_get_guint8(tvb, offset);\r\nif (!prop && iObjType == AMF0_STRING && remain >= 3) {\r\niStringLength = tvb_get_ntohs(tvb, offset+1);\r\nif (remain >= iStringLength+3) {\r\nreturn tvb_get_string_enc(wmem_packet_scope(), tvb, offset+3, iStringLength, ENC_ASCII);\r\n}\r\n}\r\nif (prop && iObjType == AMF0_OBJECT) {\r\noffset++;\r\nremain--;\r\nwhile (remain > 2) {\r\nguint32 iPropLength = tvb_get_ntohs(tvb, offset);\r\nif (remain < 2+iPropLength+3)\r\nbreak;\r\nif (tvb_strneql(tvb, offset+2, prop, strlen(prop)) == 0) {\r\nif (tvb_get_guint8(tvb, offset+2+iPropLength) != AMF0_STRING)\r\nbreak;\r\niStringLength = tvb_get_ntohs(tvb, offset+2+iPropLength+1);\r\nif (remain < 2+iPropLength+3+iStringLength)\r\nbreak;\r\nreturn tvb_get_string_enc(wmem_packet_scope(), tvb, offset+2+iPropLength+3, iStringLength, ENC_ASCII);\r\n}\r\nitemlen = rtmpt_get_amf_length(tvb, offset+2+iPropLength);\r\noffset += 2+iPropLength+itemlen;\r\nremain -= 2+iPropLength+itemlen;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic guint32\r\nrtmpt_get_amf_txid(tvbuff_t *tvb, gint offset)\r\n{\r\nguint32 remain = tvb_reported_length_remaining(tvb, offset);\r\nif (remain > 0) {\r\nguint32 itemlen = rtmpt_get_amf_length(tvb, offset);\r\nif (remain<itemlen)\r\nreturn 0;\r\noffset += itemlen;\r\nremain -= itemlen;\r\n}\r\nif (remain >= 9) {\r\nguint8 iObjType = tvb_get_guint8(tvb, offset);\r\nif (iObjType == AMF0_NUMBER) {\r\nreturn (guint32)tvb_get_ntohieee_double(tvb, offset+1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic gchar *\r\nrtmpt_get_packet_desc(tvbuff_t *tvb, guint32 offset, guint32 remain, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp, gint *deschasopcode)\r\n{\r\nif (tp->cmd == RTMPT_TYPE_CHUNK_SIZE || tp->cmd == RTMPT_TYPE_ABORT_MESSAGE ||\r\ntp->cmd == RTMPT_TYPE_ACKNOWLEDGEMENT || tp->cmd == RTMPT_TYPE_WINDOW) {\r\nif (tp->len >= 4 && remain >= 4) {\r\n*deschasopcode = TRUE;\r\nreturn wmem_strdup_printf(wmem_packet_scope(), "%s %d",\r\nval_to_str(tp->cmd, rtmpt_opcode_vals, "Unknown (0x%01x)"),\r\ntvb_get_ntohl(tvb, offset));\r\n}\r\n} else if (tp->cmd == RTMPT_TYPE_PEER_BANDWIDTH) {\r\nif (tp->len >= 5 && remain >= 5) {\r\n*deschasopcode = TRUE;\r\nreturn wmem_strdup_printf(wmem_packet_scope(), "%s %d,%s",\r\nval_to_str(tp->cmd, rtmpt_opcode_vals, "Unknown (0x%01x)"),\r\ntvb_get_ntohl(tvb, offset),\r\nval_to_str(tvb_get_guint8(tvb, offset+4), rtmpt_limit_vals, "Unknown (%d)"));\r\n}\r\n} else if (tp->cmd == RTMPT_TYPE_UCM) {\r\nguint16 iUCM = -1;\r\nconst gchar *sFunc;\r\nconst gchar *sParam = "";\r\nif (tp->len < 2 || remain < 2)\r\nreturn NULL;\r\niUCM = tvb_get_ntohs(tvb, offset);\r\nsFunc = try_val_to_str(iUCM, rtmpt_ucm_vals);\r\nif (sFunc == NULL) {\r\n*deschasopcode = TRUE;\r\nsFunc = wmem_strdup_printf(wmem_packet_scope(), "User Control Message 0x%01x", iUCM);\r\n}\r\nif (iUCM == RTMPT_UCM_STREAM_BEGIN || iUCM == RTMPT_UCM_STREAM_EOF ||\r\niUCM == RTMPT_UCM_STREAM_DRY || iUCM == RTMPT_UCM_STREAM_ISRECORDED) {\r\nif (tp->len >= 6 && remain >= 6) {\r\nsParam = wmem_strdup_printf(wmem_packet_scope(), " %d", tvb_get_ntohl(tvb, offset+2));\r\n}\r\n} else if (iUCM == RTMPT_UCM_SET_BUFFER) {\r\nif (tp->len >= 10 && remain >= 10) {\r\nsParam = wmem_strdup_printf(wmem_packet_scope(), " %d,%dms",\r\ntvb_get_ntohl(tvb, offset+2),\r\ntvb_get_ntohl(tvb, offset+6));\r\n}\r\n}\r\nreturn wmem_strdup_printf(wmem_packet_scope(), "%s%s", sFunc, sParam);\r\n} else if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||\r\ntp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\r\nguint32 slen = 0;\r\nguint32 soff = 0;\r\ngchar *sFunc = NULL;\r\ngchar *sParam = NULL;\r\nif (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\r\nsoff = 1;\r\n}\r\nif (tp->len >= 3+soff && remain >= 3+soff) {\r\nslen = tvb_get_ntohs(tvb, offset+1+soff);\r\n}\r\nif (slen > 0) {\r\nsFunc = tvb_get_string_enc(wmem_packet_scope(), tvb, offset+3+soff, slen, ENC_ASCII);\r\nRTMPT_DEBUG("got function call '%s'\n", sFunc);\r\nif (strcmp(sFunc, "connect") == 0) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 2, "app");\r\n} else if (strcmp(sFunc, "play") == 0) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\r\n} else if (strcmp(sFunc, "play2") == 0) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 3, "streamName");\r\n} else if (strcmp(sFunc, "releaseStream") == 0) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\r\n} else if (strcmp(sFunc, "FCPublish") == 0) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\r\n} else if (strcmp(sFunc, "publish") == 0) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\r\n} else if (strcmp(sFunc, "onStatus") == 0) {\r\nif (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 3, "code");\r\n} else {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 1, "code");\r\n}\r\n} else if (strcmp(sFunc, "onPlayStatus") == 0) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 1, "code");\r\n} else if (strcmp(sFunc, "_result") == 0) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 3, "code");\r\ntp->isresponse = TRUE;\r\n} else if (strcmp(sFunc, "_error") == 0) {\r\nsParam = rtmpt_get_amf_param(tvb, offset+soff, 3, "code");\r\ntp->isresponse = TRUE;\r\n}\r\nif (tp->txid != 0 && tp->otherframe == 0) {\r\ntp->otherframe = GPOINTER_TO_INT(wmem_tree_lookup32(rconv->txids[cdir^1], tp->txid));\r\nif (tp->otherframe) {\r\nRTMPT_DEBUG("got otherframe=%d\n", tp->otherframe);\r\n}\r\n}\r\n}\r\nif (sFunc) {\r\nif (sParam) {\r\nreturn wmem_strdup_printf(wmem_packet_scope(), "%s('%s')", sFunc, sParam);\r\n} else {\r\nreturn wmem_strdup_printf(wmem_packet_scope(), "%s()", sFunc);\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\ndissect_rtmpt_body_scm(tvbuff_t *tvb, gint offset, proto_tree *rtmpt_tree, guint scm)\r\n{\r\nswitch (scm) {\r\ncase RTMPT_TYPE_CHUNK_SIZE:\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_scm_chunksize, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase RTMPT_TYPE_ABORT_MESSAGE:\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_scm_csid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase RTMPT_TYPE_ACKNOWLEDGEMENT:\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_scm_seq, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase RTMPT_TYPE_UCM:\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_ucm_eventtype, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase RTMPT_TYPE_WINDOW:\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_scm_was, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase RTMPT_TYPE_PEER_BANDWIDTH:\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_scm_was, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_scm_limittype, tvb, offset+4, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\n}\r\nstatic gint\r\ndissect_amf0_property_list(tvbuff_t *tvb, gint offset, proto_tree *tree, guint *countp, gboolean *amf3_encoding)\r\n{\r\nproto_item *prop_ti;\r\nproto_tree *prop_tree;\r\nproto_tree *name_tree;\r\nguint iStringLength;\r\ngchar *iStringValue;\r\nguint count = 0;\r\nfor (;;) {\r\niStringLength = tvb_get_ntohs(tvb, offset);\r\nif (iStringLength == 0 &&\r\ntvb_get_guint8(tvb, offset + 2) == AMF0_END_OF_OBJECT)\r\nbreak;\r\ncount++;\r\niStringValue = tvb_get_string_enc(wmem_packet_scope(), tvb, offset + 2, iStringLength, ENC_ASCII);\r\nprop_tree = proto_tree_add_subtree_format(tree, tvb, offset, -1,\r\nett_amf_property, &prop_ti, "Property '%s'",\r\niStringValue);\r\nname_tree = proto_tree_add_subtree_format(prop_tree, tvb,\r\noffset, 2+iStringLength,\r\nett_amf_string, NULL, "Name: %s", iStringValue);\r\nproto_tree_add_uint(name_tree, hf_amf_stringlength, tvb, offset, 2, iStringLength);\r\noffset += 2;\r\nproto_tree_add_item(name_tree, hf_amf_string, tvb, offset, iStringLength, ENC_UTF_8|ENC_NA);\r\noffset += iStringLength;\r\noffset = dissect_amf0_value_type(tvb, offset, prop_tree, amf3_encoding, prop_ti);\r\nproto_item_set_end(prop_ti, tvb, offset);\r\n}\r\nproto_tree_add_item(tree, hf_amf_end_of_object_marker, tvb, offset, 3, ENC_NA);\r\noffset += 3;\r\n*countp = count;\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_amf0_value_type(tvbuff_t *tvb, gint offset, proto_tree *tree, gboolean *amf3_encoding, proto_item *parent_ti)\r\n{\r\nguint8 iObjType;\r\nproto_item *ti;\r\nproto_tree *val_tree;\r\ngint iValueOffset = offset;\r\nguint32 iIntegerValue;\r\ndouble iDoubleValue;\r\ngboolean iBooleanValue;\r\nguint iStringLength;\r\ngchar *iStringValue;\r\nguint iArrayLength;\r\nguint i;\r\nnstime_t t;\r\ngint64 iInteger64Value;\r\nguint count;\r\niObjType = tvb_get_guint8(tvb, offset);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " %s",\r\nval_to_str_const(iObjType, amf0_type_vals, "Unknown"));\r\nswitch (iObjType) {\r\ncase AMF0_OBJECT:\r\nti = proto_tree_add_item(tree, hf_amf_object, tvb, offset, -1, ENC_NA);\r\nval_tree = proto_item_add_subtree(ti, ett_amf_value);\r\nbreak;\r\ncase AMF0_ECMA_ARRAY:\r\nti = proto_tree_add_item(tree, hf_amf_ecmaarray, tvb, offset, -1, ENC_NA);\r\nval_tree = proto_item_add_subtree(ti, ett_amf_value);\r\nbreak;\r\ncase AMF0_STRICT_ARRAY:\r\nti = proto_tree_add_item(tree, hf_amf_strictarray, tvb, offset, -1, ENC_NA);\r\nval_tree = proto_item_add_subtree(ti, ett_amf_value);\r\nbreak;\r\ndefault:\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_amf_value, &ti,\r\nval_to_str_const(iObjType, amf0_type_vals, "Unknown"));\r\nbreak;\r\n}\r\nproto_tree_add_uint(val_tree, hf_amf_amf0_type, tvb, iValueOffset, 1, iObjType);\r\niValueOffset++;\r\nswitch (iObjType) {\r\ncase AMF0_NUMBER:\r\niDoubleValue = tvb_get_ntohieee_double(tvb, iValueOffset);\r\nproto_tree_add_double(val_tree, hf_amf_number, tvb, iValueOffset, 8, iDoubleValue);\r\niValueOffset += 8;\r\nproto_item_append_text(ti, " %." G_STRINGIFY(DBL_DIG) "g", iDoubleValue);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " %." G_STRINGIFY(DBL_DIG) "g", iDoubleValue);\r\nbreak;\r\ncase AMF0_BOOLEAN:\r\niBooleanValue = tvb_get_guint8(tvb, iValueOffset);\r\nproto_tree_add_boolean(val_tree, hf_amf_boolean, tvb, iValueOffset, 1, iBooleanValue);\r\niValueOffset += 1;\r\nproto_item_append_text(ti, iBooleanValue ? " true" : " false");\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, iBooleanValue ? " true" : " false");\r\nbreak;\r\ncase AMF0_STRING:\r\niStringLength = tvb_get_ntohs(tvb, iValueOffset);\r\nproto_tree_add_uint(val_tree, hf_amf_stringlength, tvb, iValueOffset, 2, iStringLength);\r\niValueOffset += 2;\r\niStringValue = tvb_get_string_enc(wmem_packet_scope(), tvb, iValueOffset, iStringLength, ENC_UTF_8|ENC_NA);\r\nif (iStringLength != 0)\r\nproto_tree_add_string(val_tree, hf_amf_string, tvb, iValueOffset, iStringLength, iStringValue);\r\niValueOffset += iStringLength;\r\nproto_item_append_text(ti, " '%s'", iStringValue);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " '%s'", iStringValue);\r\nbreak;\r\ncase AMF0_OBJECT:\r\niValueOffset = dissect_amf0_property_list(tvb, iValueOffset, val_tree, &count, amf3_encoding);\r\nproto_item_append_text(ti, " (%u items)", count);\r\nbreak;\r\ncase AMF0_NULL:\r\ncase AMF0_UNDEFINED:\r\nbreak;\r\ncase AMF0_REFERENCE:\r\niIntegerValue = tvb_get_ntohs(tvb, iValueOffset);\r\nproto_tree_add_uint(val_tree, hf_amf_object_reference, tvb, iValueOffset, 2, iIntegerValue);\r\niValueOffset += 2;\r\nproto_item_append_text(ti, " %d", iIntegerValue);\r\nbreak;\r\ncase AMF0_ECMA_ARRAY:\r\niArrayLength = tvb_get_ntohl(tvb, iValueOffset);\r\nproto_tree_add_uint(val_tree, hf_amf_arraylength, tvb, iValueOffset, 4, iArrayLength);\r\niValueOffset += 4;\r\niValueOffset = dissect_amf0_property_list(tvb, iValueOffset, val_tree, &count, amf3_encoding);\r\nproto_item_append_text(ti, " (%u items)", count);\r\nbreak;\r\ncase AMF0_END_OF_OBJECT:\r\nproto_tree_add_item(tree, hf_amf_end_of_object_marker, tvb, iValueOffset, 3, ENC_NA);\r\niValueOffset += 3;\r\nbreak;\r\ncase AMF0_STRICT_ARRAY:\r\niArrayLength = tvb_get_ntohl(tvb, iValueOffset);\r\nproto_tree_add_uint(val_tree, hf_amf_arraylength, tvb, iValueOffset, 4, iArrayLength);\r\niValueOffset += 4;\r\nfor (i = 0; i < iArrayLength; i++)\r\niValueOffset = dissect_amf0_value_type(tvb, iValueOffset, val_tree, amf3_encoding, NULL);\r\nproto_item_append_text(ti, " (%u items)", iArrayLength);\r\nbreak;\r\ncase AMF0_DATE:\r\niDoubleValue = tvb_get_ntohieee_double(tvb, iValueOffset);\r\nt.secs = (time_t)(iDoubleValue/1000);\r\nt.nsecs = (int)((iDoubleValue - 1000*(double)t.secs) * 1000000);\r\nproto_tree_add_time(val_tree, hf_amf_date, tvb, iValueOffset, 8, &t);\r\niValueOffset += 8;\r\nproto_item_append_text(ti, " %s", abs_time_to_str(wmem_packet_scope(), &t, ABSOLUTE_TIME_LOCAL, TRUE));\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " %s", abs_time_to_str(wmem_packet_scope(), &t, ABSOLUTE_TIME_LOCAL, TRUE));\r\niValueOffset += 2;\r\nbreak;\r\ncase AMF0_LONG_STRING:\r\ncase AMF0_XML:\r\niStringLength = tvb_get_ntohl(tvb, iValueOffset);\r\nproto_tree_add_uint(val_tree, hf_amf_stringlength, tvb, iValueOffset, 2, iStringLength);\r\niValueOffset += 4;\r\niStringValue = tvb_get_string_enc(wmem_packet_scope(), tvb, iValueOffset, iStringLength, ENC_UTF_8|ENC_NA);\r\nif (iStringLength != 0)\r\nproto_tree_add_string(val_tree, (iObjType == AMF0_XML) ? hf_amf_xml_doc : hf_amf_longstring, tvb, iValueOffset, iStringLength, iStringValue);\r\niValueOffset += iStringLength;\r\nproto_item_append_text(ti, " '%s'", iStringValue);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " '%s'", iStringValue);\r\nbreak;\r\ncase AMF0_UNSUPPORTED:\r\nbreak;\r\ncase AMF0_TYPED_OBJECT:\r\niStringLength = tvb_get_ntohs(tvb, iValueOffset);\r\nproto_tree_add_uint(val_tree, hf_amf_stringlength, tvb, iValueOffset, 2, iStringLength);\r\niValueOffset += 2;\r\niStringValue = tvb_get_string_enc(wmem_packet_scope(), tvb, iValueOffset, iStringLength, ENC_UTF_8|ENC_NA);\r\nproto_tree_add_string(val_tree, hf_amf_string, tvb, iValueOffset, iStringLength, iStringValue);\r\niValueOffset += iStringLength;\r\niValueOffset = dissect_amf0_property_list(tvb, iValueOffset, val_tree, &count, amf3_encoding);\r\nbreak;\r\ncase AMF0_AMF3_MARKER:\r\n*amf3_encoding = TRUE;\r\nbreak;\r\ncase AMF0_INT64:\r\niInteger64Value = tvb_get_ntoh64(tvb, iValueOffset);\r\nproto_tree_add_int64(val_tree, hf_amf_int64, tvb, iValueOffset, 8, iInteger64Value);\r\niValueOffset += 8;\r\nproto_item_append_text(ti," %" G_GINT64_MODIFIER "d", iInteger64Value);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti," %" G_GINT64_MODIFIER "d", iInteger64Value);\r\nbreak;\r\ndefault:\r\niValueOffset = tvb_reported_length(tvb);\r\nbreak;\r\n}\r\nproto_item_set_end(ti, tvb, iValueOffset);\r\nreturn iValueOffset;\r\n}\r\nstatic guint32\r\namf_get_u29(tvbuff_t *tvb, int offset, guint *lenp)\r\n{\r\nguint len = 0;\r\nguint8 iByte;\r\nguint32 iValue;\r\niByte = tvb_get_guint8(tvb, offset);\r\niValue = (iByte & 0x7F);\r\noffset++;\r\nlen++;\r\nif (!(iByte & 0x80)) {\r\n*lenp = len;\r\nreturn iValue;\r\n}\r\niByte = tvb_get_guint8(tvb, offset);\r\niValue = (iValue << 7) | (iByte & 0x7F);\r\noffset++;\r\nlen++;\r\nif (!(iByte & 0x80)) {\r\n*lenp = len;\r\nreturn iValue;\r\n}\r\niByte = tvb_get_guint8(tvb, offset);\r\niValue = (iValue << 7) | (iByte & 0x7F);\r\noffset++;\r\nlen++;\r\nif (!(iByte & 0x80)) {\r\n*lenp = len;\r\nreturn iValue;\r\n}\r\niByte = tvb_get_guint8(tvb, offset);\r\niValue = (iValue << 8) | iByte;\r\nlen++;\r\n*lenp = len;\r\nreturn iValue;\r\n}\r\nstatic gint\r\ndissect_amf3_value_type(tvbuff_t *tvb, gint offset, proto_tree *tree, proto_item *parent_ti)\r\n{\r\nguint8 iObjType;\r\nproto_item *ti;\r\nproto_tree *val_tree;\r\ngint iValueOffset = offset;\r\nguint iValueLength;\r\nguint32 iIntegerValue;\r\ndouble iDoubleValue;\r\nguint iStringLength;\r\ngchar *iStringValue;\r\nguint iArrayLength;\r\nproto_item *subval_ti;\r\nproto_tree *subval_tree;\r\nguint i;\r\ngboolean iTypeIsDynamic;\r\nguint iTraitCount;\r\nproto_item *traits_ti;\r\nproto_tree *traits_tree;\r\nproto_tree *name_tree;\r\nproto_tree *member_tree;\r\nguint8 *iByteArrayValue;\r\niObjType = tvb_get_guint8(tvb, offset);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " %s",\r\nval_to_str_const(iObjType, amf3_type_vals, "Unknown"));\r\nswitch (iObjType) {\r\ncase AMF3_ARRAY:\r\nti = proto_tree_add_item(tree, hf_amf_array, tvb, offset, -1, ENC_NA);\r\nval_tree = proto_item_add_subtree(ti, ett_amf_value);\r\nbreak;\r\ncase AMF3_OBJECT:\r\nti = proto_tree_add_item(tree, hf_amf_object, tvb, offset, -1, ENC_NA);\r\nval_tree = proto_item_add_subtree(ti, ett_amf_value);\r\nbreak;\r\ndefault:\r\nval_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_amf_value, &ti,\r\nval_to_str_const(iObjType, amf3_type_vals, "Unknown"));\r\nbreak;\r\n}\r\nproto_tree_add_uint(val_tree, hf_amf_amf3_type, tvb, iValueOffset, 1, iObjType);\r\niValueOffset++;\r\nswitch (iObjType) {\r\ncase AMF3_UNDEFINED:\r\ncase AMF3_NULL:\r\nbreak;\r\ncase AMF3_FALSE:\r\nproto_tree_add_boolean(val_tree, hf_amf_boolean, tvb, 0, 0, FALSE);\r\nproto_item_append_text(ti, " false");\r\nbreak;\r\ncase AMF3_TRUE:\r\nproto_tree_add_boolean(val_tree, hf_amf_boolean, tvb, 0, 0, TRUE);\r\nproto_item_append_text(ti, " true");\r\nbreak;\r\ncase AMF3_INTEGER:\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nproto_tree_add_uint(val_tree, hf_amf_integer, tvb, iValueOffset, iValueLength, iIntegerValue);\r\nproto_item_append_text(ti, " %u", iIntegerValue);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " %u", iIntegerValue);\r\niValueOffset += iValueLength;\r\nbreak;\r\ncase AMF3_DOUBLE:\r\niDoubleValue = tvb_get_ntohieee_double(tvb, iValueOffset);\r\nproto_tree_add_double(val_tree, hf_amf_number, tvb, iValueOffset, 8, iDoubleValue);\r\niValueOffset += 8;\r\nproto_item_append_text(ti, " %." G_STRINGIFY(DBL_DIG) "g", iDoubleValue);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " %." G_STRINGIFY(DBL_DIG) "g", iDoubleValue);\r\nbreak;\r\ncase AMF3_STRING:\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\niStringLength = iIntegerValue >> 1;\r\nproto_tree_add_uint(val_tree, hf_amf_stringlength, tvb, iValueOffset, iValueLength, iStringLength);\r\niValueOffset += iValueLength;\r\niStringValue = tvb_get_string_enc(wmem_packet_scope(), tvb, iValueOffset, iStringLength, ENC_UTF_8|ENC_NA);\r\nif (iStringLength != 0)\r\nproto_tree_add_string(val_tree, hf_amf_string, tvb, iValueOffset, iStringLength, iStringValue);\r\niValueOffset += iStringLength;\r\nproto_item_append_text(ti, " '%s'", iStringValue);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " '%s'", iStringValue);\r\n} else {\r\nproto_tree_add_uint(val_tree, hf_amf_string_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\niValueOffset += iValueLength;\r\nproto_item_append_text(ti, " reference %u", iIntegerValue >> 1);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " reference %u", iIntegerValue >> 1);\r\n}\r\nbreak;\r\ncase AMF3_DATE:\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\nnstime_t t;\r\niValueOffset += iValueLength;\r\niDoubleValue = tvb_get_ntohieee_double(tvb, iValueOffset);\r\nt.secs = (time_t)(iDoubleValue/1000);\r\nt.nsecs = (int)((iDoubleValue - 1000*(double)t.secs) * 1000000);\r\nproto_tree_add_time(val_tree, hf_amf_date, tvb, iValueOffset, 8, &t);\r\niValueOffset += 8;\r\nproto_item_append_text(ti, "%s", abs_time_to_str(wmem_packet_scope(), &t, ABSOLUTE_TIME_LOCAL, TRUE));\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, "%s", abs_time_to_str(wmem_packet_scope(), &t, ABSOLUTE_TIME_LOCAL, TRUE));\r\n} else {\r\nproto_tree_add_uint(val_tree, hf_amf_object_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\niValueOffset += iValueLength;\r\nproto_item_append_text(ti, " object reference %u", iIntegerValue >> 1);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " object reference %u", iIntegerValue >> 1);\r\n}\r\nbreak;\r\ncase AMF3_ARRAY:\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\niArrayLength = iIntegerValue >> 1;\r\nproto_tree_add_uint(val_tree, hf_amf_arraydenselength, tvb, iValueOffset, iValueLength, iArrayLength);\r\niValueOffset += iValueLength;\r\nfor (;;) {\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\niStringLength = iIntegerValue >> 1;\r\nif (iStringLength == 0) {\r\nproto_tree_add_item(val_tree, hf_amf_end_of_associative_part, tvb, iValueOffset, iValueLength, ENC_NA);\r\niValueOffset += iValueLength;\r\nbreak;\r\n}\r\niStringValue = tvb_get_string_enc(wmem_packet_scope(), tvb, iValueOffset+iValueLength, iStringLength, ENC_UTF_8|ENC_NA);\r\nsubval_tree = proto_tree_add_subtree(val_tree, tvb, iValueOffset, iStringLength,\r\nett_amf_array_element, &subval_ti, iStringValue);\r\nproto_tree_add_uint(subval_tree, hf_amf_stringlength, tvb, iValueOffset, iValueLength, iStringLength);\r\niValueOffset += iValueLength;\r\nproto_tree_add_string(subval_tree, hf_amf_string, tvb, iValueOffset, iStringLength, iStringValue);\r\n} else {\r\nsubval_tree = proto_tree_add_subtree_format(val_tree, tvb, iValueOffset, iValueLength,\r\nett_amf_array_element, &subval_ti, "Reference %u:", iIntegerValue >> 1);\r\nproto_tree_add_uint(subval_tree, hf_amf_string_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\n}\r\niObjType = tvb_get_guint8(tvb, offset);\r\nproto_item_append_text(subval_ti, "%s",\r\nval_to_str_const(iObjType, amf3_type_vals, "Unknown"));\r\niValueOffset = dissect_amf3_value_type(tvb, iValueOffset, subval_tree, subval_ti);\r\n}\r\nfor (i = 0; i < iArrayLength; i++)\r\niValueOffset = dissect_amf3_value_type(tvb, iValueOffset, val_tree, NULL);\r\nproto_item_set_end(ti, tvb, iValueOffset);\r\n} else {\r\nproto_tree_add_uint(val_tree, hf_amf_object_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\nproto_item_append_text(ti, " reference %u", iIntegerValue >> 1);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " reference %u", iIntegerValue >> 1);\r\n}\r\nbreak;\r\ncase AMF3_OBJECT:\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\nif (iIntegerValue & 0x00000002) {\r\nif (iIntegerValue & 0x00000004) {\r\niValueOffset += iValueLength;\r\n} else {\r\niTypeIsDynamic = (iIntegerValue & 0x00000008) ? TRUE : FALSE;\r\niTraitCount = iIntegerValue >> 4;\r\nproto_tree_add_uint(val_tree, hf_amf_traitcount, tvb, iValueOffset, iValueLength, iTraitCount);\r\niValueOffset += iValueLength;\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\niStringLength = iIntegerValue >> 1;\r\niStringValue = tvb_get_string_enc(wmem_packet_scope(), tvb, iValueOffset+iValueLength, iStringLength, ENC_UTF_8|ENC_NA);\r\ntraits_tree = proto_tree_add_subtree_format(val_tree, tvb, iValueOffset, -1,\r\nett_amf_traits, &traits_ti, "Traits for class %s (%u member names)", iStringValue, iTraitCount);\r\nname_tree = proto_tree_add_subtree_format(traits_tree, tvb,\r\niValueOffset,\r\niValueLength+iStringLength,\r\nett_amf_string, NULL, "Class name: %s",\r\niStringValue);\r\nproto_tree_add_uint(name_tree, hf_amf_classnamelength, tvb, iValueOffset, iValueLength, iStringLength);\r\niValueOffset += iValueLength;\r\nproto_tree_add_string(name_tree, hf_amf_classname, tvb, iValueOffset, iStringLength, iStringValue);\r\niValueOffset += iStringLength;\r\n} else {\r\ntraits_tree = proto_tree_add_subtree_format(val_tree, tvb, iValueOffset, iValueLength,\r\nett_amf_traits, &traits_ti, "Traits for class (reference %u for name)", iIntegerValue >> 1);\r\nproto_tree_add_uint(traits_tree, hf_amf_string_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\niValueOffset += iValueLength;\r\n}\r\nfor (i = 0; i < iTraitCount; i++) {\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\niStringLength = iIntegerValue >> 1;\r\niStringValue = tvb_get_string_enc(wmem_packet_scope(), tvb, iValueOffset+iValueLength, iStringLength, ENC_UTF_8|ENC_NA);\r\nmember_tree = proto_tree_add_subtree_format(traits_tree, tvb, iValueOffset, iValueLength+iStringLength,\r\nett_amf_trait_member, NULL, "Member '%s'", iStringValue);\r\nproto_tree_add_uint(member_tree, hf_amf_membernamelength, tvb, iValueOffset, iValueLength, iStringLength);\r\niValueOffset += iValueLength;\r\nproto_tree_add_string(member_tree, hf_amf_membername, tvb, iValueOffset, iStringLength, iStringValue);\r\niValueOffset += iStringLength;\r\n} else {\r\nproto_tree_add_uint(traits_tree, hf_amf_string_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\niValueOffset += iValueLength;\r\n}\r\n}\r\nfor (i = 0; i < iTraitCount; i++)\r\niValueOffset = dissect_amf3_value_type(tvb, iValueOffset, traits_tree, NULL);\r\nif (iTypeIsDynamic) {\r\nfor (;;) {\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\niStringLength = iIntegerValue >> 1;\r\nif (iStringLength == 0) {\r\nproto_tree_add_item(traits_tree, hf_amf_end_of_dynamic_members, tvb, iValueOffset, iValueLength, ENC_NA);\r\niValueOffset += iValueLength;\r\nbreak;\r\n}\r\niStringValue = tvb_get_string_enc(wmem_packet_scope(), tvb, iValueOffset+iValueLength, iStringLength, ENC_UTF_8|ENC_NA);\r\nsubval_tree = proto_tree_add_subtree_format(traits_tree, tvb, iValueOffset, -1,\r\nett_amf_array_element, &subval_ti, "%s:", iStringValue);\r\nname_tree = proto_tree_add_subtree_format(subval_tree, tvb,\r\niValueOffset,\r\niValueLength+iStringLength,\r\nett_amf_string, NULL, "Member name: %s",\r\niStringValue);\r\nproto_tree_add_uint(name_tree, hf_amf_membernamelength, tvb, iValueOffset, iValueLength, iStringLength);\r\niValueOffset += iValueLength;\r\nproto_tree_add_string(name_tree, hf_amf_membername, tvb, iValueOffset, iStringLength, iStringValue);\r\niValueOffset += iStringLength;\r\n} else {\r\nsubval_tree = proto_tree_add_subtree_format(traits_tree, tvb, iValueOffset, iValueLength,\r\nett_amf_array_element, &subval_ti, "Reference %u:", iIntegerValue >> 1);\r\nproto_tree_add_uint(subval_tree, hf_amf_string_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\niValueOffset += iValueLength;\r\n}\r\niValueOffset = dissect_amf3_value_type(tvb, iValueOffset, subval_tree, subval_ti);\r\nproto_item_set_end(subval_ti, tvb, iValueOffset);\r\n}\r\n}\r\nproto_item_set_end(traits_ti, tvb, iValueOffset);\r\n}\r\n} else {\r\nproto_tree_add_uint(val_tree, hf_amf_trait_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 2);\r\niValueOffset += iValueLength;\r\n}\r\n} else {\r\nproto_tree_add_uint(val_tree, hf_amf_object_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\nproto_item_append_text(ti, " reference %u", iIntegerValue >> 1);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " reference %u", iIntegerValue >> 1);\r\n}\r\nbreak;\r\ncase AMF3_XML:\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\niStringLength = iIntegerValue >> 1;\r\nproto_tree_add_uint(val_tree, hf_amf_xmllength, tvb, iValueOffset, iValueLength, iStringLength);\r\niValueOffset += iValueLength;\r\nproto_tree_add_item(val_tree, hf_amf_xml, tvb, iValueOffset, iStringLength, ENC_UTF_8|ENC_NA);\r\n} else {\r\nproto_tree_add_uint(val_tree, hf_amf_object_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\nproto_item_append_text(ti, " reference %u", iIntegerValue >> 1);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " reference %u", iIntegerValue >> 1);\r\n}\r\nbreak;\r\ncase AMF3_BYTEARRAY:\r\niIntegerValue = amf_get_u29(tvb, iValueOffset, &iValueLength);\r\nif (iIntegerValue & 0x00000001) {\r\niArrayLength = iIntegerValue >> 1;\r\nproto_tree_add_uint(val_tree, hf_amf_bytearraylength, tvb, iValueOffset, iValueLength, iArrayLength);\r\niValueOffset += iValueLength;\r\niByteArrayValue = (guint8 *)tvb_memdup(wmem_packet_scope(), tvb, iValueOffset, iArrayLength);\r\nproto_tree_add_bytes(val_tree, hf_amf_bytearray, tvb, iValueOffset, iArrayLength, iByteArrayValue);\r\nproto_item_append_text(ti, " %s", bytes_to_str(wmem_packet_scope(), iByteArrayValue, iArrayLength));\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " %s", bytes_to_str(wmem_packet_scope(), iByteArrayValue, iArrayLength));\r\n} else {\r\nproto_tree_add_uint(val_tree, hf_amf_object_reference, tvb, iValueOffset, iValueLength, iIntegerValue >> 1);\r\nproto_item_append_text(ti, " reference %u", iIntegerValue >> 1);\r\nif (parent_ti != NULL)\r\nproto_item_append_text(parent_ti, " reference %u", iIntegerValue >> 1);\r\n}\r\nbreak;\r\ndefault:\r\niValueOffset = tvb_reported_length(tvb);\r\nbreak;\r\n}\r\nproto_item_set_end(ti, tvb, iValueOffset);\r\nreturn iValueOffset;\r\n}\r\nstatic gint\r\ndissect_rtmpt_body_command(tvbuff_t *tvb, gint offset, proto_tree *rtmpt_tree, gboolean amf3)\r\n{\r\ngboolean amf3_encoding = FALSE;\r\nif (amf3) {\r\noffset++;\r\n}\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0)\r\n{\r\nif (amf3_encoding)\r\noffset = dissect_amf3_value_type(tvb, offset, rtmpt_tree, NULL);\r\nelse\r\noffset = dissect_amf0_value_type(tvb, offset, rtmpt_tree, &amf3_encoding, NULL);\r\n}\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_rtmpt_body_audio(tvbuff_t *tvb, gint offset, proto_tree *rtmpt_tree)\r\n{\r\nguint8 iCtl;\r\nproto_item *ai;\r\nproto_tree *at;\r\niCtl = tvb_get_guint8(tvb, offset);\r\nai = proto_tree_add_uint_format(rtmpt_tree, hf_rtmpt_audio_control, tvb, offset, 1, iCtl,\r\n"Control: 0x%02x (%s %s %s %s)", iCtl,\r\nval_to_str_const((iCtl & 0xf0)>>4, rtmpt_audio_codecs, "Unknown codec"),\r\nval_to_str_const((iCtl & 0x0c)>>2, rtmpt_audio_rates, "Unknown rate"),\r\nval_to_str_const((iCtl & 0x02)>>1, rtmpt_audio_sizes, "Unknown sample size"),\r\nval_to_str_const(iCtl & 0x01, rtmpt_audio_types, "Unknown channel count"));\r\nat = proto_item_add_subtree(ai, ett_rtmpt_audio_control);\r\nproto_tree_add_uint(at, hf_rtmpt_audio_format, tvb, offset, 1, iCtl);\r\nproto_tree_add_uint(at, hf_rtmpt_audio_rate, tvb, offset, 1, iCtl);\r\nproto_tree_add_uint(at, hf_rtmpt_audio_size, tvb, offset, 1, iCtl);\r\nproto_tree_add_uint(at, hf_rtmpt_audio_type, tvb, offset, 1, iCtl);\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_audio_data, tvb, offset+1, -1, ENC_NA);\r\n}\r\nstatic void\r\ndissect_rtmpt_body_video(tvbuff_t *tvb, gint offset, proto_tree *rtmpt_tree)\r\n{\r\nguint8 iCtl;\r\nproto_item *vi;\r\nproto_tree *vt;\r\niCtl = tvb_get_guint8(tvb, offset);\r\nvi = proto_tree_add_uint_format(rtmpt_tree, hf_rtmpt_video_control, tvb, offset, 1, iCtl,\r\n"Control: 0x%02x (%s %s)", iCtl,\r\nval_to_str_const((iCtl & 0xf0)>>4, rtmpt_video_types, "Unknown frame type"),\r\nval_to_str_const(iCtl & 0x0f, rtmpt_video_codecs, "Unknown codec"));\r\nvt = proto_item_add_subtree(vi, ett_rtmpt_video_control);\r\nproto_tree_add_uint(vt, hf_rtmpt_video_type, tvb, offset, 1, iCtl);\r\nproto_tree_add_uint(vt, hf_rtmpt_video_format, tvb, offset, 1, iCtl);\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_video_data, tvb, offset+1, -1, ENC_NA);\r\n}\r\nstatic void\r\ndissect_rtmpt_body_aggregate(tvbuff_t *tvb, gint offset, proto_tree *rtmpt_tree)\r\n{\r\nproto_tree *tag_tree;\r\nproto_tree *data_tree;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nguint8 iTagType;\r\nguint iDataSize;\r\niTagType = tvb_get_guint8(tvb, offset + 0);\r\niDataSize = tvb_get_ntoh24(tvb, offset + 1);\r\ntag_tree = proto_tree_add_subtree(rtmpt_tree, tvb, offset, 11+iDataSize+4, ett_rtmpt_tag, NULL,\r\nval_to_str_const(iTagType, rtmpt_tag_vals, "Unknown Tag"));\r\nproto_tree_add_item(tag_tree, hf_rtmpt_tag_type, tvb, offset+0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tag_tree, hf_rtmpt_tag_datasize, tvb, offset+1, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tag_tree, hf_rtmpt_tag_timestamp, tvb, offset+4, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tag_tree, hf_rtmpt_tag_ets, tvb, offset+7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tag_tree, hf_rtmpt_tag_streamid, tvb, offset+8, 3, ENC_BIG_ENDIAN);\r\ndata_tree = proto_tree_add_subtree(tag_tree, tvb, offset+11, iDataSize, ett_rtmpt_tag_data, NULL, "Data");\r\nswitch (iTagType) {\r\ncase 8:\r\ndissect_rtmpt_body_audio(tvb, offset + 11, data_tree);\r\nbreak;\r\ncase 9:\r\ndissect_rtmpt_body_video(tvb, offset + 11, data_tree);\r\nbreak;\r\ncase 18:\r\ndissect_rtmpt_body_command(tvb, offset + 11, data_tree, FALSE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nproto_tree_add_item(tag_tree, hf_rtmpt_tag_tagsize, tvb, offset+11+iDataSize, 4, ENC_BIG_ENDIAN);\r\noffset += 11 + iDataSize + 4;\r\n}\r\n}\r\nstatic void\r\ndissect_rtmpt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp)\r\n{\r\ngint offset = 0;\r\ngchar *sDesc = NULL;\r\ngint deschasopcode = FALSE;\r\ngboolean haveETS = FALSE;\r\nguint32 iBodyOffset = 0;\r\nguint32 iBodyRemain = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RTMP");\r\nRTMPT_DEBUG("Dissect: frame=%u visited=%d len=%d tree=%p\n",\r\npinfo->num, pinfo->fd->flags.visited,\r\ntvb_reported_length_remaining(tvb, offset), tree);\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tvb_reported_length_remaining(tvb, offset) < 1) return;\r\nif (tp->id <= RTMPT_ID_MAX) {\r\nif (tp->fmt < 3\r\n&& tvb_reported_length_remaining(tvb, offset) >= tp->bhlen+3\r\n&& tvb_get_ntoh24(tvb, offset+tp->bhlen) == 0xffffff) {\r\nhaveETS = TRUE;\r\n}\r\niBodyOffset = offset + tp->bhlen + tp->mhlen;\r\niBodyRemain = tvb_reported_length_remaining(tvb, iBodyOffset);\r\nif (tp->cmd == RTMPT_TYPE_CHUNK_SIZE && tp->len >= 4 && iBodyRemain >= 4) {\r\nguint32 newchunksize = tvb_get_ntohl(tvb, iBodyOffset);\r\nif (newchunksize < rtmpt_max_packet_size) {\r\nwmem_tree_insert32(rconv->chunksize[cdir], tp->lastseq, GINT_TO_POINTER(newchunksize));\r\n}\r\n}\r\nif (!PINFO_FD_VISITED(pinfo)) {\r\nif (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||\r\ntp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\r\nguint32 soff = 0;\r\nif (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\r\nsoff = 1;\r\n}\r\ntp->txid = rtmpt_get_amf_txid(tvb, iBodyOffset+soff);\r\nif (tp->txid != 0) {\r\nRTMPT_DEBUG("got txid=%d\n", tp->txid);\r\nwmem_tree_insert32(rconv->txids[cdir], tp->txid, GINT_TO_POINTER(pinfo->num));\r\n}\r\n}\r\n}\r\n}\r\nif (tp->id <= RTMPT_ID_MAX)\r\n{\r\nsDesc = rtmpt_get_packet_desc(tvb, iBodyOffset, iBodyRemain, rconv, cdir, tp, &deschasopcode);\r\n}\r\nif (tp->id>RTMPT_ID_MAX) {\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, "|", "%s",\r\nval_to_str(tp->id, rtmpt_handshake_vals, "Unknown (0x%01x)"));\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\n} else if (sDesc) {\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, "|", "%s", sDesc);\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\n} else {\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, "|", "%s",\r\nval_to_str(tp->cmd, rtmpt_opcode_vals, "Unknown (0x%01x)"));\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\n}\r\nif (tree)\r\n{\r\nproto_tree *rtmpt_tree = NULL;\r\nproto_tree *rtmptroot_tree = NULL;\r\nproto_item *ti;\r\nti = proto_tree_add_item(tree, proto_rtmpt, tvb, offset, -1, ENC_NA);\r\nif (tp->id > RTMPT_ID_MAX) {\r\nproto_item_append_text(ti, " (%s)",\r\nval_to_str(tp->id, rtmpt_handshake_vals, "Unknown (0x%01x)"));\r\nrtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt);\r\nrtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_handshake, NULL,\r\nval_to_str(tp->id, rtmpt_handshake_vals, "Unknown (0x%01x)"));\r\nif (tp->id == RTMPT_TYPE_HANDSHAKE_1)\r\n{\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c0, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c1, tvb, 1, 1536, ENC_NA);\r\n}\r\nelse if (tp->id == RTMPT_TYPE_HANDSHAKE_2)\r\n{\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s0, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s1, tvb, 1, 1536, ENC_NA);\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s2, tvb, 1537, 1536, ENC_NA);\r\n}\r\nelse if (tp->id == RTMPT_TYPE_HANDSHAKE_3)\r\n{\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c2, tvb, 0, 1536, ENC_NA);\r\n}\r\nreturn;\r\n}\r\nif (sDesc && deschasopcode) {\r\nproto_item_append_text(ti, " (%s)", sDesc);\r\n} else if (sDesc) {\r\nproto_item_append_text(ti, " (%s %s)",\r\nval_to_str(tp->cmd, rtmpt_opcode_vals, "Unknown (0x%01x)"), sDesc);\r\n} else {\r\nproto_item_append_text(ti, " (%s)",\r\nval_to_str(tp->cmd, rtmpt_opcode_vals, "Unknown (0x%01x)"));\r\n}\r\nrtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt);\r\nif (tp->otherframe != 0) {\r\nproto_tree_add_uint(rtmptroot_tree,\r\ntp->isresponse ? hf_rtmpt_function_response : hf_rtmpt_function_call,\r\ntvb, offset, tp->bhlen+tp->mhlen+tp->len,\r\ntp->otherframe);\r\n}\r\nrtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, tp->bhlen+tp->mhlen, ett_rtmpt_header, NULL, RTMPT_TEXT_RTMP_HEADER);\r\nif (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_format, tvb, offset + 0, 1, ENC_BIG_ENDIAN);\r\nif (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_csid, tvb, offset + 0, tp->bhlen, ENC_BIG_ENDIAN);\r\nif (tp->fmt <= 2) {\r\nif (tp->fmt > 0) {\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp_delta, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN);\r\n}\r\nif (haveETS) {\r\nproto_tree_add_item(rtmpt_tree, hf_rtmpt_header_ets, tvb, offset + tp->bhlen + tp->mhlen - 4, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nif ((tp->fmt>0 && !haveETS) || tp->fmt == 3) {\r\nproto_tree_add_uint_format_value(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 0, tp->ts, "%d (calculated)", tp->ts);\r\n}\r\nif (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_body_size, tvb, offset + tp->bhlen + 3, 3, ENC_BIG_ENDIAN);\r\nif (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_typeid, tvb, offset + tp->bhlen + 6, 1, ENC_BIG_ENDIAN);\r\nif (tp->fmt <= 0) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_streamid, tvb, offset + tp->bhlen + 7, 4, ENC_LITTLE_ENDIAN);\r\nif (tp->len == 0) return;\r\noffset = iBodyOffset;\r\nrtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_body, NULL, RTMPT_TEXT_RTMP_BODY);\r\nswitch (tp->cmd) {\r\ncase RTMPT_TYPE_CHUNK_SIZE:\r\ncase RTMPT_TYPE_ABORT_MESSAGE:\r\ncase RTMPT_TYPE_ACKNOWLEDGEMENT:\r\ncase RTMPT_TYPE_UCM:\r\ncase RTMPT_TYPE_WINDOW:\r\ncase RTMPT_TYPE_PEER_BANDWIDTH:\r\ndissect_rtmpt_body_scm(tvb, offset, rtmpt_tree, tp->cmd);\r\nbreak;\r\ncase RTMPT_TYPE_COMMAND_AMF0:\r\ncase RTMPT_TYPE_DATA_AMF0:\r\ndissect_rtmpt_body_command(tvb, offset, rtmpt_tree, FALSE);\r\nbreak;\r\ncase RTMPT_TYPE_COMMAND_AMF3:\r\ncase RTMPT_TYPE_DATA_AMF3:\r\ndissect_rtmpt_body_command(tvb, offset, rtmpt_tree, TRUE);\r\nbreak;\r\ncase RTMPT_TYPE_AUDIO_DATA:\r\ndissect_rtmpt_body_audio(tvb, offset, rtmpt_tree);\r\nbreak;\r\ncase RTMPT_TYPE_VIDEO_DATA:\r\ndissect_rtmpt_body_video(tvb, offset, rtmpt_tree);\r\nbreak;\r\ncase RTMPT_TYPE_AGGREGATE:\r\ndissect_rtmpt_body_aggregate(tvb, offset, rtmpt_tree);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq)\r\n{\r\nint offset = 0;\r\nint remain;\r\nint want;\r\nguint8 header_type;\r\nint basic_hlen;\r\nint message_hlen;\r\nguint32 id;\r\nguint32 ts = 0;\r\nguint32 tsd = 0;\r\nint body_len;\r\nguint8 cmd;\r\nguint32 src;\r\nint chunk_size;\r\nrtmpt_frag_t *tf;\r\nrtmpt_id_t *ti;\r\nrtmpt_packet_t *tp;\r\ntvbuff_t *pktbuf;\r\nremain = tvb_reported_length(tvb);\r\nif (!remain)\r\nreturn;\r\nRTMPT_DEBUG("Segment: cdir=%d seq=%d-%d\n", cdir, seq, seq+remain-1);\r\nif (pinfo->fd->flags.visited) {\r\nwmem_stack_t *packets;\r\npackets = wmem_stack_new(wmem_packet_scope());\r\nwmem_stack_push(packets, 0);\r\ntp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1);\r\nwhile (tp && tp->lastseq >= seq) {\r\nwmem_stack_push(packets, tp);\r\ntp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->lastseq-1);\r\n}\r\nwhile ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) {\r\nif (tp->resident) {\r\npktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\r\nadd_new_data_source(pinfo, pktbuf, "Unchunked RTMP");\r\n} else {\r\npktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\r\n}\r\ndissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\r\n}\r\nreturn;\r\n}\r\nwhile (remain>0) {\r\ntf = NULL;\r\nti = NULL;\r\ntp = NULL;\r\nif (offset == 0) {\r\ntf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1);\r\nif (tf) {\r\nRTMPT_DEBUG(" tf seq=%d lseq=%d h=%d l=%d\n", tf->seq, tf->lastseq, tf->have, tf->len);\r\nif (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) {\r\ntf = NULL;\r\n} else if (!tf->ishdr) {\r\nti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id);\r\nif (ti) {\r\ntp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\r\n}\r\nif (tp && tp->chunkwant) {\r\ngoto unchunk;\r\n}\r\ntf = NULL;\r\nti = NULL;\r\ntp = NULL;\r\n}\r\nif (tf) {\r\nwant = tf->len - tf->have;\r\nif (remain<want)\r\nwant = remain;\r\ntvb_memcpy(tvb, tf->saved.d+tf->have, offset, want);\r\nid = tf->saved.d[0];\r\nheader_type = (id>>6) & 3;\r\nbasic_hlen = rtmpt_basic_header_length(id);\r\nif ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) {\r\nif (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) {\r\ntf->len += 4;\r\n}\r\n}\r\ntf->have += want;\r\ntf->lastseq = seq+want-1;\r\nremain -= want;\r\noffset += want;\r\nif (tf->have < tf->len) {\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nif (!tf) {\r\nid = tvb_get_guint8(tvb, offset);\r\nif (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) {\r\nheader_type = 4;\r\nbasic_hlen = 1;\r\nmessage_hlen = 0;\r\nid = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2;\r\n} else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) {\r\nheader_type = 4;\r\nbasic_hlen = 0;\r\nmessage_hlen = 0;\r\nid = RTMPT_TYPE_HANDSHAKE_3;\r\n} else {\r\nheader_type = (id>>6) & 3;\r\nbasic_hlen = rtmpt_basic_header_length(id);\r\nmessage_hlen = rtmpt_message_header_length(id);\r\nif ((header_type < 3) && (remain >= (basic_hlen+3))) {\r\nif (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) {\r\nmessage_hlen += 4;\r\n}\r\n}\r\nif (remain < (basic_hlen+message_hlen)) {\r\ntf = wmem_new(wmem_file_scope(), rtmpt_frag_t);\r\ntf->ishdr = 1;\r\ntf->seq = seq + offset;\r\ntf->lastseq = tf->seq + remain - 1;\r\ntf->len = basic_hlen + message_hlen;\r\ntvb_memcpy(tvb, tf->saved.d, offset, remain);\r\ntf->have = remain;\r\nwmem_tree_insert32(rconv->frags[cdir], seq+offset, tf);\r\nreturn;\r\n}\r\nid = id & 0x3f;\r\nif (id == 0)\r\nid = tvb_get_guint8(tvb, offset+1) + 64;\r\nelse if (id == 1)\r\nid = tvb_get_letohs(tvb, offset+1) + 64;\r\n}\r\n} else {\r\nid = tf->saved.d[0];\r\nheader_type = (id>>6) & 3;\r\nbasic_hlen = rtmpt_basic_header_length(id);\r\nmessage_hlen = tf->len - basic_hlen;\r\nid = id & 0x3f;\r\nif (id == 0)\r\nid = tf->saved.d[1] + 64;\r\nelse if (id == 1)\r\nid = pletoh16(tf->saved.d+1) + 64;\r\n}\r\nif (id <= RTMPT_ID_MAX)\r\nti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id);\r\nif (ti)\r\ntp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\r\nif (header_type == 0)\r\nsrc = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7);\r\nelse if (ti)\r\nsrc = ti->src;\r\nelse src = 0;\r\nif (header_type < 2)\r\ncmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6);\r\nelse if (ti)\r\ncmd = ti->cmd;\r\nelse\r\ncmd = 0;\r\nif (id > RTMPT_ID_MAX) {\r\nif (id == RTMPT_TYPE_HANDSHAKE_1)\r\nchunk_size = body_len = 1536;\r\nelse if (id == RTMPT_TYPE_HANDSHAKE_2)\r\nchunk_size = body_len = 3072;\r\nelse\r\nchunk_size = body_len = 1536;\r\n} else {\r\nchunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1));\r\nif (!chunk_size)\r\nchunk_size = RTMPT_DEFAULT_CHUNK_SIZE;\r\nif (header_type < 2)\r\nbody_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3);\r\nelse if (ti)\r\nbody_len = ti->len;\r\nelse\r\nbody_len = chunk_size;\r\nif (body_len > (gint)rtmpt_max_packet_size) {\r\nreturn;\r\n}\r\n}\r\nif (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) {\r\nRTMPT_DEBUG("New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n",\r\ncdir, seq+offset,\r\nti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\r\nif (!ti) {\r\nti = wmem_new(wmem_file_scope(), rtmpt_id_t);\r\nti->packets = wmem_tree_new(wmem_file_scope());\r\nti->ts = 0;\r\nti->tsd = 0;\r\nwmem_tree_insert32(rconv->ids[cdir], id, ti);\r\n}\r\nif (header_type == 0) {\r\nts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\r\nif (ts == 0xffffff) {\r\nts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11);\r\n}\r\ntsd = ts - ti->ts;\r\n} else if (header_type < 3) {\r\ntsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\r\nif (tsd == 0xffffff) {\r\nts = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4);\r\ntsd = ti->tsd;\r\n} else {\r\nts = ti->ts + tsd;\r\n}\r\n} else {\r\nts = ti->ts + ti->tsd;\r\ntsd = ti->tsd;\r\n}\r\ntp = wmem_new(wmem_file_scope(), rtmpt_packet_t);\r\ntp->seq = tp->lastseq = tf ? tf->seq : seq+offset;\r\ntp->have = 0;\r\ntp->want = basic_hlen + message_hlen + body_len;\r\ntp->chunkwant = 0;\r\ntp->chunkhave = 0;\r\ntp->bhlen = basic_hlen;\r\ntp->mhlen = message_hlen;\r\ntp->fmt = header_type;\r\ntp->id = id;\r\ntp->ts = ts;\r\ntp->len = body_len;\r\nif (id > RTMPT_ID_MAX)\r\ntp->cmd = id;\r\nelse\r\ntp->cmd = cmd & 0x7f;\r\ntp->src = src;\r\ntp->txid = 0;\r\ntp->isresponse = FALSE;\r\ntp->otherframe = 0;\r\nti->ts = ts;\r\nti->tsd = tsd;\r\nti->len = body_len;\r\nti->cmd = cmd;\r\nti->src = src;\r\nwmem_tree_insert32(ti->packets, tp->seq, tp);\r\nif (!tf && body_len <= chunk_size && tp->want <= remain) {\r\ntp->resident = FALSE;\r\ntp->data.offset = offset;\r\ntp->lastseq = seq+offset+tp->want-1;\r\ntp->have = tp->want;\r\nwmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\r\npktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\r\ndissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\r\noffset += tp->want;\r\nremain -= tp->want;\r\ncontinue;\r\n} else {\r\ntp->resident = TRUE;\r\ntp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len);\r\nif (tf && tf->ishdr) {\r\nmemcpy(tp->data.p, tf->saved.d, tf->len);\r\n} else {\r\ntvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen);\r\noffset += basic_hlen + message_hlen;\r\nremain -= basic_hlen + message_hlen;\r\n}\r\ntp->lastseq = seq+offset-1;\r\ntp->have = basic_hlen + message_hlen;\r\nif (tp->have == tp->want) {\r\nwmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\r\npktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\r\nadd_new_data_source(pinfo, pktbuf, "Unchunked RTMP");\r\ndissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\r\ncontinue;\r\n}\r\ntp->chunkwant = chunk_size;\r\nif (tp->chunkwant > tp->want-tp->have)\r\ntp->chunkwant = tp->want - tp->have;\r\n}\r\n} else {\r\nRTMPT_DEBUG("Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n",\r\ncdir, seq+offset,\r\nti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\r\ntp->chunkwant = chunk_size;\r\nif (tp->chunkwant > tp->want-tp->have)\r\ntp->chunkwant = tp->want - tp->have;\r\noffset += basic_hlen + message_hlen;\r\nremain -= basic_hlen + message_hlen;\r\n}\r\ntf = NULL;\r\nunchunk:\r\nwant = tp->chunkwant - tp->chunkhave;\r\nif (want > remain)\r\nwant = remain;\r\nRTMPT_DEBUG(" cw=%d ch=%d r=%d w=%d\n", tp->chunkwant, tp->chunkhave, remain, want);\r\ntvb_memcpy(tvb, tp->data.p+tp->have, offset, want);\r\nif (tf) {\r\ntf->have += want;\r\ntf->lastseq = seq+offset+want-1;\r\n}\r\ntp->lastseq = seq+offset+want-1;\r\ntp->have += want;\r\ntp->chunkhave += want;\r\noffset += want;\r\nremain -= want;\r\nif (tp->chunkhave == tp->chunkwant) {\r\ntp->chunkhave = 0;\r\ntp->chunkwant = 0;\r\n}\r\nif (tp->have == tp->want) {\r\nwmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\r\npktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\r\nadd_new_data_source(pinfo, pktbuf, "Unchunked RTMP");\r\ndissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\r\n} else if (tp->chunkhave < tp->chunkwant) {\r\nrtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t);\r\ntf2->ishdr = 0;\r\ntf2->seq = seq + offset - want;\r\ntf2->lastseq = tf2->seq + remain - 1 + want;\r\ntf2->have = tp->chunkhave;\r\ntf2->len = tp->chunkwant;\r\ntf2->saved.id = tp->id;\r\nRTMPT_DEBUG(" inserting tf @ %d\n", seq+offset-want-1);\r\nwmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2);\r\n}\r\n}\r\n}\r\nstatic rtmpt_conv_t *\r\nrtmpt_init_rconv(conversation_t *conv)\r\n{\r\nrtmpt_conv_t *rconv = wmem_new(wmem_file_scope(), rtmpt_conv_t);\r\nconversation_add_proto_data(conv, proto_rtmpt, rconv);\r\nrconv->seqs[0] = wmem_tree_new(wmem_file_scope());\r\nrconv->seqs[1] = wmem_tree_new(wmem_file_scope());\r\nrconv->frags[0] = wmem_tree_new(wmem_file_scope());\r\nrconv->frags[1] = wmem_tree_new(wmem_file_scope());\r\nrconv->ids[0] = wmem_tree_new(wmem_file_scope());\r\nrconv->ids[1] = wmem_tree_new(wmem_file_scope());\r\nrconv->packets[0] = wmem_tree_new(wmem_file_scope());\r\nrconv->packets[1] = wmem_tree_new(wmem_file_scope());\r\nrconv->chunksize[0] = wmem_tree_new(wmem_file_scope());\r\nrconv->chunksize[1] = wmem_tree_new(wmem_file_scope());\r\nrconv->txids[0] = wmem_tree_new(wmem_file_scope());\r\nrconv->txids[1] = wmem_tree_new(wmem_file_scope());\r\nreturn rconv;\r\n}\r\nstatic int\r\ndissect_rtmpt_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nconversation_t *conv;\r\nrtmpt_conv_t *rconv;\r\nint cdir;\r\nstruct tcpinfo *tcpinfo;\r\nif (data == NULL) {\r\nreturn 0;\r\n}\r\ntcpinfo = (struct tcpinfo*)data;\r\nconv = find_or_create_conversation(pinfo);\r\nrconv = (rtmpt_conv_t*)conversation_get_proto_data(conv, proto_rtmpt);\r\nif (!rconv) {\r\nrconv = rtmpt_init_rconv(conv);\r\n}\r\ncdir = (addresses_equal(&conv->key_ptr->addr1, &pinfo->src) &&\r\naddresses_equal(&conv->key_ptr->addr2, &pinfo->dst) &&\r\nconv->key_ptr->port1 == pinfo->srcport &&\r\nconv->key_ptr->port2 == pinfo->destport) ? 0 : 1;\r\ndissect_rtmpt_common(tvb, pinfo, tree, rconv, cdir, tcpinfo->seq, tcpinfo->lastackseq);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic int\r\ndissect_rtmpt_http(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nconversation_t *conv;\r\nrtmpt_conv_t *rconv;\r\nint cdir;\r\nguint32 seq;\r\nguint32 lastackseq;\r\nguint32 offset;\r\ngint remain;\r\noffset = 0;\r\nremain = tvb_reported_length_remaining(tvb, 0);\r\ncdir = pinfo->srcport == pinfo->match_uint;\r\nif (cdir) {\r\nconv = find_conversation(pinfo->num, &pinfo->dst, &pinfo->src, pinfo->ptype, 0, pinfo->srcport, 0);\r\nif (!conv) {\r\nRTMPT_DEBUG("RTMPT new conversation\n");\r\nconv = conversation_new(pinfo->num, &pinfo->dst, &pinfo->src, pinfo->ptype, 0, pinfo->srcport, 0);\r\n}\r\n} else {\r\nconv = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst, pinfo->ptype, 0, pinfo->destport, 0);\r\nif (!conv) {\r\nRTMPT_DEBUG("RTMPT new conversation\n");\r\nconv = conversation_new(pinfo->num, &pinfo->src, &pinfo->dst, pinfo->ptype, 0, pinfo->destport, 0);\r\n}\r\n}\r\nrconv = (rtmpt_conv_t*)conversation_get_proto_data(conv, proto_rtmpt);\r\nif (!rconv) {\r\nrconv = rtmpt_init_rconv(conv);\r\n}\r\nlastackseq = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->seqs[cdir ^ 1], pinfo->num))+1;\r\nif (cdir == 1 && lastackseq < 2 && remain == 17) {\r\noffset += 17;\r\nremain -= 17;\r\n} else if (cdir || remain == 1) {\r\noffset++;\r\nremain--;\r\n}\r\nseq = GPOINTER_TO_INT(wmem_tree_lookup32(rconv->seqs[cdir], pinfo->num));\r\nif (seq == 0) {\r\nseq = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->seqs[cdir], pinfo->num));\r\nseq += remain;\r\nwmem_tree_insert32(rconv->seqs[cdir], pinfo->num, GINT_TO_POINTER(seq));\r\n}\r\nseq -= remain-1;\r\nRTMPT_DEBUG("RTMPT f=%d cdir=%d seq=%d lastackseq=%d len=%d\n", pinfo->num, cdir, seq, lastackseq, remain);\r\nif (remain < 1)\r\nreturn offset;\r\nif (offset > 0) {\r\ntvbuff_t *tvbrtmp = tvb_new_subset_length(tvb, offset, remain);\r\ndissect_rtmpt_common(tvbrtmp, pinfo, tree, rconv, cdir, seq, lastackseq);\r\n} else {\r\ndissect_rtmpt_common(tvb, pinfo, tree, rconv, cdir, seq, lastackseq);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_rtmpt_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nconversation_t *conversation;\r\nif (tvb_reported_length(tvb) >= 12)\r\n{\r\nstruct tcpinfo *tcpinfo = (struct tcpinfo *)data;\r\nif (tcpinfo->lastackseq == RTMPT_HANDSHAKE_OFFSET_2\r\n&& tcpinfo->seq == RTMPT_HANDSHAKE_OFFSET_1\r\n&& tvb_get_guint8(tvb, 0) == RTMPT_MAGIC)\r\n{\r\nconversation = find_or_create_conversation(pinfo);\r\nconversation_set_dissector(conversation, rtmpt_tcp_handle);\r\ndissect_rtmpt_tcp(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic int\r\ndissect_amf(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *amf_tree, *headers_tree, *messages_tree;\r\nint offset;\r\nguint header_count, message_count, i;\r\nguint string_length;\r\nguint header_length, message_length;\r\ngboolean amf3_encoding = FALSE;\r\nti = proto_tree_add_item(tree, proto_amf, tvb, 0, -1, ENC_NA);\r\namf_tree = proto_item_add_subtree(ti, ett_amf);\r\noffset = 0;\r\nproto_tree_add_item(amf_tree, hf_amf_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nheader_count = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(amf_tree, hf_amf_header_count, tvb, offset, 2, header_count);\r\noffset += 2;\r\nif (header_count != 0) {\r\nheaders_tree = proto_tree_add_subtree(amf_tree, tvb, offset, -1, ett_amf_headers, NULL, "Headers");\r\nfor (i = 0; i < header_count; i++) {\r\nstring_length = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(headers_tree, hf_amf_header_name, tvb, offset, 2, ENC_UTF_8|ENC_BIG_ENDIAN);\r\noffset += 2 + string_length;\r\nproto_tree_add_item(headers_tree, hf_amf_header_must_understand, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nheader_length = tvb_get_ntohl(tvb, offset);\r\nif (header_length == 0xFFFFFFFF)\r\nproto_tree_add_uint_format_value(headers_tree, hf_amf_header_length, tvb, offset, 4, header_length, "Unknown");\r\nelse\r\nproto_tree_add_uint(headers_tree, hf_amf_header_length, tvb, offset, 4, header_length);\r\noffset += 4;\r\nif (amf3_encoding)\r\noffset = dissect_amf3_value_type(tvb, offset, headers_tree, NULL);\r\nelse\r\noffset = dissect_amf0_value_type(tvb, offset, headers_tree, &amf3_encoding, NULL);\r\n}\r\n}\r\nmessage_count = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(amf_tree, hf_amf_message_count, tvb, offset, 2, message_count);\r\noffset += 2;\r\nif (message_count != 0) {\r\nmessages_tree = proto_tree_add_subtree(amf_tree, tvb, offset, -1, ett_amf_messages, NULL, "Messages");\r\nfor (i = 0; i < message_count; i++) {\r\nstring_length = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(messages_tree, hf_amf_message_target_uri, tvb, offset, 2, ENC_UTF_8|ENC_BIG_ENDIAN);\r\noffset += 2 + string_length;\r\nstring_length = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(messages_tree, hf_amf_message_response_uri, tvb, offset, 2, ENC_UTF_8|ENC_BIG_ENDIAN);\r\noffset += 2 + string_length;\r\nmessage_length = tvb_get_ntohl(tvb, offset);\r\nif (message_length == 0xFFFFFFFF)\r\nproto_tree_add_uint_format_value(messages_tree, hf_amf_message_length, tvb, offset, 4, message_length, "Unknown");\r\nelse\r\nproto_tree_add_uint(messages_tree, hf_amf_message_length, tvb, offset, 4, message_length);\r\noffset += 4;\r\noffset = dissect_rtmpt_body_command(tvb, offset, messages_tree, FALSE);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_rtmpt(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_rtmpt_handshake_c0,\r\n{ "Protocol version", "rtmpt.handshake.c0", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "RTMPT Handshake C0", HFILL }},\r\n{ &hf_rtmpt_handshake_s0,\r\n{ "Protocol version", "rtmpt.handshake.s0", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "RTMPT Handshake S0", HFILL }},\r\n{ &hf_rtmpt_handshake_c1,\r\n{ "Handshake data", "rtmpt.handshake.c1", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "RTMPT Handshake C1", HFILL }},\r\n{ &hf_rtmpt_handshake_s1,\r\n{ "Handshake data", "rtmpt.handshake.s1", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "RTMPT Handshake S1", HFILL }},\r\n{ &hf_rtmpt_handshake_c2,\r\n{ "Handshake data", "rtmpt.handshake.c2", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "RTMPT Handshake C2", HFILL }},\r\n{ &hf_rtmpt_handshake_s2,\r\n{ "Handshake data", "rtmpt.handshake.s2", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "RTMPT Handshake S2", HFILL }},\r\n{ &hf_rtmpt_header_format,\r\n{ "Format", "rtmpt.header.format", FT_UINT8, BASE_DEC,\r\nNULL, 0xC0, "RTMPT Basic Header format", HFILL }},\r\n{ &hf_rtmpt_header_csid,\r\n{ "Chunk Stream ID", "rtmpt.header.csid", FT_UINT8, BASE_DEC,\r\nNULL, 0x3F, "RTMPT Basic Header chunk stream ID", HFILL }},\r\n{ &hf_rtmpt_header_timestamp,\r\n{ "Timestamp", "rtmpt.header.timestamp", FT_UINT24, BASE_DEC,\r\nNULL, 0x0, "RTMPT Message Header timestamp", HFILL }},\r\n{ &hf_rtmpt_header_timestamp_delta,\r\n{ "Timestamp delta", "rtmpt.header.timestampdelta", FT_UINT24, BASE_DEC,\r\nNULL, 0x0, "RTMPT Message Header timestamp delta", HFILL }},\r\n{ &hf_rtmpt_header_body_size,\r\n{ "Body size", "rtmpt.header.bodysize", FT_UINT24, BASE_DEC,\r\nNULL, 0x0, "RTMPT Message Header body size", HFILL }},\r\n{ &hf_rtmpt_header_typeid,\r\n{ "Type ID", "rtmpt.header.typeid", FT_UINT8, BASE_HEX,\r\nVALS(rtmpt_opcode_vals), 0x0, "RTMPT Message Header type ID", HFILL }},\r\n{ &hf_rtmpt_header_streamid,\r\n{ "Stream ID", "rtmpt.header.streamid", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "RTMPT Header stream ID", HFILL }},\r\n{ &hf_rtmpt_header_ets,\r\n{ "Extended timestamp", "rtmpt.header.ets", FT_UINT24, BASE_DEC,\r\nNULL, 0x0, "RTMPT Message Header extended timestamp", HFILL }},\r\n{ &hf_rtmpt_scm_chunksize,\r\n{ "Chunk size", "rtmpt.scm.chunksize", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "RTMPT SCM chunk size", HFILL }},\r\n{ &hf_rtmpt_scm_csid,\r\n{ "Chunk stream ID", "rtmpt.scm.csid", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "RTMPT SCM chunk stream ID", HFILL }},\r\n{ &hf_rtmpt_scm_seq,\r\n{ "Sequence number", "rtmpt.scm.seq", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "RTMPT SCM acknowledgement sequence number", HFILL }},\r\n{ &hf_rtmpt_scm_was,\r\n{ "Window acknowledgement size", "rtmpt.scm.was", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "RTMPT SCM window acknowledgement size", HFILL }},\r\n{ &hf_rtmpt_scm_limittype,\r\n{ "Limit type", "rtmpt.scm.limittype", FT_UINT8, BASE_DEC,\r\nVALS(rtmpt_limit_vals), 0x0, "RTMPT SCM window acknowledgement size", HFILL }},\r\n{ &hf_rtmpt_ucm_eventtype,\r\n{ "Event type", "rtmpt.ucm.eventtype", FT_UINT16, BASE_DEC,\r\nVALS(rtmpt_ucm_vals), 0x0, "RTMPT UCM event type", HFILL }},\r\n{ &hf_rtmpt_function_call,\r\n{ "Response to this call in frame", "rtmpt.function.call", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "RTMPT function call", HFILL }},\r\n{ &hf_rtmpt_function_response,\r\n{ "Call for this response in frame", "rtmpt.function.response", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "RTMPT function response", HFILL }},\r\n{ &hf_rtmpt_audio_control,\r\n{ "Audio control", "rtmpt.audio.control", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, "RTMPT Audio control", HFILL }},\r\n{ &hf_rtmpt_audio_format,\r\n{ "Format", "rtmpt.audio.format", FT_UINT8, BASE_DEC,\r\nVALS(rtmpt_audio_codecs), 0xf0, "RTMPT Audio format", HFILL }},\r\n{ &hf_rtmpt_audio_rate,\r\n{ "Sample rate", "rtmpt.audio.rate", FT_UINT8, BASE_DEC,\r\nVALS(rtmpt_audio_rates), 0x0c, "RTMPT Audio sample rate", HFILL }},\r\n{ &hf_rtmpt_audio_size,\r\n{ "Sample size", "rtmpt.audio.size", FT_UINT8, BASE_DEC,\r\nVALS(rtmpt_audio_sizes), 0x02, "RTMPT Audio sample size", HFILL }},\r\n{ &hf_rtmpt_audio_type,\r\n{ "Channels", "rtmpt.audio.type", FT_UINT8, BASE_DEC,\r\nVALS(rtmpt_audio_types), 0x01, "RTMPT Audio channel count", HFILL }},\r\n{ &hf_rtmpt_audio_data,\r\n{ "Audio data", "rtmpt.audio.data", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "RTMPT Audio data", HFILL }},\r\n{ &hf_rtmpt_video_control,\r\n{ "Video control", "rtmpt.video.control", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, "RTMPT Video control", HFILL }},\r\n{ &hf_rtmpt_video_type,\r\n{ "Type", "rtmpt.video.type", FT_UINT8, BASE_DEC,\r\nVALS(rtmpt_video_types), 0xf0, "RTMPT Video type", HFILL }},\r\n{ &hf_rtmpt_video_format,\r\n{ "Format", "rtmpt.video.format", FT_UINT8, BASE_DEC,\r\nVALS(rtmpt_video_codecs), 0x0f, "RTMPT Video format", HFILL }},\r\n{ &hf_rtmpt_video_data,\r\n{ "Video data", "rtmpt.video.data", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "RTMPT Video data", HFILL }},\r\n{ &hf_rtmpt_tag_type,\r\n{ "Type", "rtmpt.tag.type", FT_UINT8, BASE_DEC,\r\nVALS(rtmpt_tag_vals), 0x0, "RTMPT Aggregate tag type", HFILL }},\r\n{ &hf_rtmpt_tag_datasize,\r\n{ "Data size", "rtmpt.tag.datasize", FT_UINT24, BASE_DEC,\r\nNULL, 0x0, "RTMPT Aggregate tag data size", HFILL }},\r\n{ &hf_rtmpt_tag_timestamp,\r\n{ "Timestamp", "rtmpt.tag.timestamp", FT_UINT24, BASE_DEC,\r\nNULL, 0x0, "RTMPT Aggregate tag timestamp", HFILL }},\r\n{ &hf_rtmpt_tag_ets,\r\n{ "Timestamp Extended", "rtmpt.tag.ets", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "RTMPT Aggregate tag timestamp extended", HFILL }},\r\n{ &hf_rtmpt_tag_streamid,\r\n{ "Stream ID", "rtmpt.tag.streamid", FT_UINT24, BASE_DEC,\r\nNULL, 0x0, "RTMPT Aggregate tag stream ID", HFILL }},\r\n{ &hf_rtmpt_tag_tagsize,\r\n{ "Previous tag size", "rtmpt.tag.tagsize", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "RTMPT Aggregate previous tag size", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_rtmpt,\r\n&ett_rtmpt_handshake,\r\n&ett_rtmpt_header,\r\n&ett_rtmpt_body,\r\n&ett_rtmpt_ucm,\r\n&ett_rtmpt_audio_control,\r\n&ett_rtmpt_video_control,\r\n&ett_rtmpt_tag,\r\n&ett_rtmpt_tag_data\r\n};\r\nmodule_t *rtmpt_module;\r\nproto_rtmpt = proto_register_protocol("Real Time Messaging Protocol", "RTMPT", "rtmpt");\r\nproto_register_field_array(proto_rtmpt, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nrtmpt_module = prefs_register_protocol(proto_rtmpt, NULL);\r\nprefs_register_bool_preference(rtmpt_module, "desegment",\r\n"Reassemble RTMPT messages spanning multiple TCP segments",\r\n"Whether the RTMPT dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\""\r\n" in the TCP protocol settings.",\r\n&rtmpt_desegment);\r\nprefs_register_uint_preference(rtmpt_module, "max_packet_size",\r\n"Maximum packet size",\r\n"The largest acceptable packet size for reassembly",\r\n10, &rtmpt_max_packet_size);\r\n}\r\nvoid\r\nproto_register_amf(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_amf_version,\r\n{ "AMF version", "amf.version", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_header_count,\r\n{ "Header count", "amf.header_count", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_header_name,\r\n{ "Name", "amf.header.name", FT_UINT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_header_must_understand,\r\n{ "Must understand", "amf.header.must_understand", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_header_length,\r\n{ "Length", "amf.header.length", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n#if 0\r\n{ &hf_amf_header_value_type,\r\n{ "Value type", "amf.header.value_type", FT_UINT32, BASE_HEX,\r\nVALS(rtmpt_type_vals), 0x0, NULL, HFILL }},\r\n#endif\r\n{ &hf_amf_message_count,\r\n{ "Message count", "amf.message_count", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_message_target_uri,\r\n{ "Target URI", "amf.message.target_uri", FT_UINT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_message_response_uri,\r\n{ "Response URI", "amf.message.response_uri", FT_UINT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_message_length,\r\n{ "Length", "amf.message.length", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_amf0_type,\r\n{ "AMF0 type", "amf.amf0_type", FT_UINT8, BASE_HEX,\r\nVALS(amf0_type_vals), 0x0, NULL, HFILL }},\r\n{ &hf_amf_amf3_type,\r\n{ "AMF3 type", "amf.amf3_type", FT_UINT8, BASE_HEX,\r\nVALS(amf3_type_vals), 0x0, NULL, HFILL }},\r\n{ &hf_amf_number,\r\n{ "Number", "amf.number", FT_DOUBLE, BASE_NONE,\r\nNULL, 0x0, "AMF number", HFILL }},\r\n{ &hf_amf_integer,\r\n{ "Integer", "amf.integer", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "RTMPT AMF3 integer", HFILL }},\r\n{ &hf_amf_boolean,\r\n{ "Boolean", "amf.boolean", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "AMF boolean", HFILL }},\r\n{ &hf_amf_stringlength,\r\n{ "String length", "amf.stringlength", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF string length", HFILL }},\r\n{ &hf_amf_string,\r\n{ "String", "amf.string", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "AMF string", HFILL }},\r\n{ &hf_amf_string_reference,\r\n{ "String reference", "amf.string_reference", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "RTMPT AMF3 string reference", HFILL }},\r\n{ &hf_amf_object_reference,\r\n{ "Object reference", "amf.object_reference", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF object reference", HFILL }},\r\n{ &hf_amf_date,\r\n{ "Date", "amf.date", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0x0, "AMF date", HFILL }},\r\n#if 0\r\n{ &hf_amf_longstringlength,\r\n{ "String length", "amf.longstringlength", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF long string length", HFILL }},\r\n#endif\r\n{ &hf_amf_longstring,\r\n{ "Long string", "amf.longstring", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "AMF long string", HFILL }},\r\n{ &hf_amf_xml_doc,\r\n{ "XML document", "amf.xml_doc", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "AMF XML document", HFILL }},\r\n{ &hf_amf_xmllength,\r\n{ "XML text length", "amf.xmllength", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF E4X XML length", HFILL }},\r\n{ &hf_amf_xml,\r\n{ "XML", "amf.xml", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "AMF E4X XML", HFILL }},\r\n{ &hf_amf_int64,\r\n{ "Int64", "amf.int64", FT_INT64, BASE_DEC,\r\nNULL, 0x0, "AMF int64", HFILL }},\r\n{ &hf_amf_bytearraylength,\r\n{ "ByteArray length", "amf.bytearraylength", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "RTMPT AMF3 ByteArray length", HFILL }},\r\n{ &hf_amf_bytearray,\r\n{ "ByteArray", "amf.bytearray", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "RTMPT AMF3 ByteArray", HFILL }},\r\n{ &hf_amf_object,\r\n{ "Object", "amf.object", FT_NONE, BASE_NONE,\r\nNULL, 0x0, "AMF object", HFILL }},\r\n{ &hf_amf_traitcount,\r\n{ "Trait count", "amf.traitcount", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF count of traits for an object", HFILL }},\r\n{ &hf_amf_classnamelength,\r\n{ "Class name length", "amf.classnamelength", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF class name length", HFILL }},\r\n{ &hf_amf_classname,\r\n{ "Class name", "amf.classname", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "AMF class name", HFILL }},\r\n{ &hf_amf_membernamelength,\r\n{ "Member name length", "amf.membernamelength", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF member name length", HFILL }},\r\n{ &hf_amf_membername,\r\n{ "Member name", "amf.membername", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "AMF member name", HFILL }},\r\n{ &hf_amf_trait_reference,\r\n{ "Trait reference", "amf.trait_reference", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF trait reference", HFILL }},\r\n{ &hf_amf_ecmaarray,\r\n{ "ECMA array", "amf.ecmaarray", FT_NONE, BASE_NONE,\r\nNULL, 0x0, "AMF ECMA array", HFILL }},\r\n{ &hf_amf_strictarray,\r\n{ "Strict array", "amf.strictarray", FT_NONE, BASE_NONE,\r\nNULL, 0x0, "AMF strict array", HFILL }},\r\n{ &hf_amf_array,\r\n{ "Array", "amf.array", FT_NONE, BASE_NONE,\r\nNULL, 0x0, "RTMPT AMF3 array", HFILL }},\r\n{ &hf_amf_arraylength,\r\n{ "Array length", "amf.arraylength", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF array length", HFILL }},\r\n{ &hf_amf_arraydenselength,\r\n{ "Length of dense portion", "amf.arraydenselength", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "AMF length of dense portion of array", HFILL }},\r\n{ &hf_amf_end_of_object_marker,\r\n{ "End Of Object Marker", "amf.end_of_object_marker", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_end_of_associative_part,\r\n{ "End of associative part", "amf.end_of_associative_part", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_amf_end_of_dynamic_members,\r\n{ "End Of dynamic members", "amf.end_of_dynamic_members", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_amf,\r\n&ett_amf_headers,\r\n&ett_amf_messages,\r\n&ett_amf_value,\r\n&ett_amf_property,\r\n&ett_amf_string,\r\n&ett_amf_array_element,\r\n&ett_amf_traits,\r\n&ett_amf_trait_member,\r\n};\r\nproto_amf = proto_register_protocol("Action Message Format", "AMF", "amf");\r\nproto_register_field_array(proto_amf, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_rtmpt(void)\r\n{\r\ndissector_handle_t amf_handle;\r\nheur_dissector_add("tcp", dissect_rtmpt_heur, "RTMPT over TCP", "rtmpt_tcp", proto_rtmpt, HEURISTIC_DISABLE);\r\nrtmpt_tcp_handle = create_dissector_handle(dissect_rtmpt_tcp, proto_rtmpt);\r\ndissector_add_uint("tcp.port", RTMP_PORT, rtmpt_tcp_handle);\r\nrtmpt_http_handle = create_dissector_handle(dissect_rtmpt_http, proto_rtmpt);\r\ndissector_add_string("media_type", "application/x-fcs", rtmpt_http_handle);\r\namf_handle = create_dissector_handle(dissect_amf, proto_amf);\r\ndissector_add_string("media_type", "application/x-amf", amf_handle);\r\n}
