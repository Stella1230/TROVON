static void\r\nadd_unix_interface_ifinfo(if_info_t *if_info, const char *name,\r\nconst char *description _U_)\r\n{\r\nCFStringRef name_CFString;\r\nCFArrayRef interfaces;\r\nCFIndex num_interfaces;\r\nCFIndex i;\r\nSCNetworkInterfaceRef interface;\r\nCFStringRef bsdname_CFString;\r\nCFStringRef friendly_name_CFString;\r\nCFStringRef interface_type_CFString;\r\ninterfaces = SCNetworkInterfaceCopyAll();\r\nif (interfaces == NULL) {\r\nreturn;\r\n}\r\nname_CFString = CFStringCreateWithCString(kCFAllocatorDefault,\r\nname, kCFStringEncodingUTF8);\r\nif (name_CFString == NULL) {\r\nCFRelease(interfaces);\r\nreturn;\r\n}\r\nnum_interfaces = CFArrayGetCount(interfaces);\r\nfor (i = 0; i < num_interfaces; i++) {\r\ninterface = (SCNetworkInterfaceRef)CFArrayGetValueAtIndex(interfaces, i);\r\nbsdname_CFString = SCNetworkInterfaceGetBSDName(interface);\r\nif (bsdname_CFString == NULL) {\r\ncontinue;\r\n}\r\nif (CFStringCompare(name_CFString, bsdname_CFString, 0) == 0) {\r\nfriendly_name_CFString = SCNetworkInterfaceGetLocalizedDisplayName(interface);\r\nif (friendly_name_CFString != NULL)\r\nif_info->friendly_name = CFString_to_C_string(friendly_name_CFString);\r\ninterface_type_CFString = SCNetworkInterfaceGetInterfaceType(interface);\r\nif (CFStringCompare(interface_type_CFString,\r\nkSCNetworkInterfaceTypeIEEE80211, 0) == kCFCompareEqualTo)\r\nif_info->type = IF_WIRELESS;\r\nelse if (CFStringCompare(interface_type_CFString,\r\nkSCNetworkInterfaceTypeBluetooth, 0) == kCFCompareEqualTo)\r\nif_info->type = IF_BLUETOOTH;\r\nelse if (CFStringCompare(interface_type_CFString,\r\nkSCNetworkInterfaceTypeModem, 0) == kCFCompareEqualTo)\r\nif_info->type = IF_DIALUP;\r\nelse if (CFStringCompare(interface_type_CFString,\r\nkSCNetworkInterfaceTypePPP, 0) == kCFCompareEqualTo)\r\nif_info->type = IF_DIALUP;\r\nelse if (CFStringCompare(interface_type_CFString,\r\nkSCNetworkInterfaceTypeWWAN, 0) == kCFCompareEqualTo)\r\nif_info->type = IF_DIALUP;\r\nelse\r\nif_info->type = IF_WIRED;\r\nbreak;\r\n}\r\n}\r\nCFRelease(interfaces);\r\nCFRelease(name_CFString);\r\n}\r\nstatic void\r\nadd_unix_interface_ifinfo(if_info_t *if_info, const char *name,\r\nconst char *description _U_)\r\n{\r\nchar *wireless_path;\r\nws_statb64 statb;\r\nwireless_path = g_strdup_printf("/sys/class/net/%s/wireless", name);\r\nif (wireless_path != NULL) {\r\nif (ws_stat64(wireless_path, &statb) == 0)\r\nif_info->type = IF_WIRELESS;\r\ng_free(wireless_path);\r\n}\r\nif (if_info->type == IF_WIRED) {\r\nif (strstr(name, "bluetooth") != NULL) {\r\nif_info->type = IF_BLUETOOTH;\r\n} else if (strstr(name, "usbmon") != NULL)\r\nif_info->type = IF_USB;\r\n}\r\n}\r\nvoid\r\nadd_unix_interface_ifinfo(if_info_t *if_info, const char *name _U_,\r\nconst char *description)\r\n{\r\nif_info->friendly_name = g_strdup(description);\r\n}\r\nif_info_t *\r\nif_info_new(const char *name, const char *description, gboolean loopback)\r\n{\r\nif_info_t *if_info;\r\n#ifdef _WIN32\r\nconst char *guid_text;\r\nGUID guid;\r\n#endif\r\nif_info = (if_info_t *)g_malloc(sizeof (if_info_t));\r\nif_info->name = g_strdup(name);\r\nif_info->friendly_name = NULL;\r\nif_info->vendor_description = NULL;\r\nif_info->type = IF_WIRED;\r\n#ifdef HAVE_EXTCAP\r\nif_info->extcap = g_strdup("");\r\n#endif\r\n#ifdef _WIN32\r\nif (description && (strstr(description, "generic dialup") != NULL ||\r\nstrstr(description, "PPP/SLIP") != NULL)) {\r\nif_info->type = IF_DIALUP;\r\n} else if (description && (strstr(description, "Wireless") != NULL ||\r\nstrstr(description,"802.11") != NULL)) {\r\nif_info->type = IF_WIRELESS;\r\n} else if (description && strstr(description, "AirPcap") != NULL ||\r\nstrstr(name, "airpcap") != NULL) {\r\nif_info->type = IF_AIRPCAP;\r\n} else if (description && strstr(description, "Bluetooth") != NULL ) {\r\nif_info->type = IF_BLUETOOTH;\r\n} else if (description && strstr(description, "VMware") != NULL) {\r\nif_info->type = IF_VIRTUAL;\r\n}\r\nif (strncmp("\\Device\\NPF_", name, 12) == 0)\r\nguid_text = name + 12;\r\nelse\r\nguid_text = name;\r\nif (parse_as_guid(guid_text, &guid)) {\r\nif_info->friendly_name = get_interface_friendly_name_from_device_guid(&guid);\r\nif_info->vendor_description = g_strdup(description);\r\n} else {\r\nif_info->friendly_name = g_strdup(description);\r\nif_info->vendor_description = NULL;\r\n}\r\n#else\r\nadd_unix_interface_ifinfo(if_info, name, description);\r\nif (if_info->type == IF_WIRED) {\r\nif (g_ascii_strncasecmp(name, "vmnet", 5) == 0)\r\nif_info->type = IF_VIRTUAL;\r\nelse if (g_ascii_strncasecmp(name, "vmxnet", 6) == 0)\r\nif_info->type = IF_VIRTUAL;\r\n}\r\nif (if_info->friendly_name == NULL) {\r\nif (loopback)\r\nif_info->friendly_name = g_strdup("Loopback");\r\n}\r\nif_info->vendor_description = NULL;\r\n#endif\r\nif_info->loopback = loopback;\r\nif_info->addrs = NULL;\r\nreturn if_info;\r\n}\r\nvoid\r\nif_info_add_address(if_info_t *if_info, struct sockaddr *addr)\r\n{\r\nif_addr_t *if_addr;\r\nstruct sockaddr_in *ai;\r\nstruct sockaddr_in6 *ai6;\r\nswitch (addr->sa_family) {\r\ncase AF_INET:\r\nai = (struct sockaddr_in *)(void *)addr;\r\nif_addr = (if_addr_t *)g_malloc(sizeof(*if_addr));\r\nif_addr->ifat_type = IF_AT_IPv4;\r\nif_addr->addr.ip4_addr =\r\n*((guint32 *)&(ai->sin_addr.s_addr));\r\nif_info->addrs = g_slist_append(if_info->addrs, if_addr);\r\nbreak;\r\ncase AF_INET6:\r\nai6 = (struct sockaddr_in6 *)(void *)addr;\r\nif_addr = (if_addr_t *)g_malloc(sizeof(*if_addr));\r\nif_addr->ifat_type = IF_AT_IPv6;\r\nmemcpy((void *)&if_addr->addr.ip6_addr,\r\n(void *)&ai6->sin6_addr.s6_addr,\r\nsizeof if_addr->addr.ip6_addr);\r\nif_info->addrs = g_slist_append(if_info->addrs, if_addr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nif_info_ip(if_info_t *if_info, pcap_if_t *d)\r\n{\r\npcap_addr_t *a;\r\nfor (a = d->addresses; a != NULL; a = a->next) {\r\nif (a->addr != NULL)\r\nif_info_add_address(if_info, a->addr);\r\n}\r\n}\r\nGList *\r\nget_interface_list_findalldevs_ex(const char *source,\r\nstruct pcap_rmtauth *auth,\r\nint *err, char **err_str)\r\n{\r\nGList *il = NULL;\r\npcap_if_t *alldevs, *dev;\r\nif_info_t *if_info;\r\nchar errbuf[PCAP_ERRBUF_SIZE*4];\r\nif (pcap_findalldevs_ex((char *)source, auth, &alldevs, errbuf) == -1) {\r\n*err = CANT_GET_INTERFACE_LIST;\r\nif (err_str != NULL)\r\n*err_str = cant_get_if_list_error_message(errbuf);\r\nreturn NULL;\r\n}\r\nif (alldevs == NULL) {\r\n*err = 0;\r\nif (err_str != NULL)\r\n*err_str = NULL;\r\nreturn NULL;\r\n}\r\nfor (dev = alldevs; dev != NULL; dev = dev->next) {\r\nif_info = if_info_new(dev->name, dev->description,\r\n(dev->flags & PCAP_IF_LOOPBACK) ? TRUE : FALSE);\r\nil = g_list_append(il, if_info);\r\nif_info_ip(if_info, dev);\r\n}\r\npcap_freealldevs(alldevs);\r\nreturn il;\r\n}\r\nGList *\r\nget_interface_list_findalldevs(int *err, char **err_str)\r\n{\r\nGList *il = NULL;\r\npcap_if_t *alldevs, *dev;\r\nif_info_t *if_info;\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\nif (pcap_findalldevs(&alldevs, errbuf) == -1) {\r\n*err = CANT_GET_INTERFACE_LIST;\r\nif (err_str != NULL)\r\n*err_str = cant_get_if_list_error_message(errbuf);\r\nreturn NULL;\r\n}\r\nif (alldevs == NULL) {\r\n*err = 0;\r\nif (err_str != NULL)\r\n*err_str = NULL;\r\nreturn NULL;\r\n}\r\nfor (dev = alldevs; dev != NULL; dev = dev->next) {\r\nif_info = if_info_new(dev->name, dev->description,\r\n(dev->flags & PCAP_IF_LOOPBACK) ? TRUE : FALSE);\r\nil = g_list_append(il, if_info);\r\nif_info_ip(if_info, dev);\r\n}\r\npcap_freealldevs(alldevs);\r\nreturn il;\r\n}\r\nstatic void\r\nfree_if_info_addr_cb(gpointer addr, gpointer user_data _U_)\r\n{\r\ng_free(addr);\r\n}\r\nstatic void\r\nfree_if_cb(gpointer data, gpointer user_data _U_)\r\n{\r\nif_info_t *if_info = (if_info_t *)data;\r\ng_free(if_info->name);\r\ng_free(if_info->friendly_name);\r\ng_free(if_info->vendor_description);\r\n#ifdef HAVE_EXTCAP\r\ng_free(if_info->extcap);\r\n#endif\r\ng_slist_foreach(if_info->addrs, free_if_info_addr_cb, NULL);\r\ng_slist_free(if_info->addrs);\r\ng_free(if_info);\r\n}\r\nvoid\r\nfree_interface_list(GList *if_list)\r\n{\r\ng_list_foreach(if_list, free_if_cb, NULL);\r\ng_list_free(if_list);\r\n}\r\nstatic int\r\npcap_datalink_name_to_val(const char *name)\r\n{\r\nint i;\r\nfor (i = 0; dlt_choices[i].name != NULL; i++) {\r\nif (g_ascii_strcasecmp(dlt_choices[i].name + sizeof("DLT_") - 1,\r\nname) == 0)\r\nreturn (dlt_choices[i].dlt);\r\n}\r\nreturn (-1);\r\n}\r\nstatic const char *\r\npcap_datalink_val_to_name(int dlt)\r\n{\r\nint i;\r\nfor (i = 0; dlt_choices[i].name != NULL; i++) {\r\nif (dlt_choices[i].dlt == dlt)\r\nreturn (dlt_choices[i].name + sizeof("DLT_") - 1);\r\n}\r\nreturn (NULL);\r\n}\r\nconst char *\r\npcap_datalink_val_to_description(int dlt)\r\n{\r\nint i;\r\nfor (i = 0; dlt_choices[i].name != NULL; i++) {\r\nif (dlt_choices[i].dlt == dlt)\r\nreturn (dlt_choices[i].description);\r\n}\r\nreturn (NULL);\r\n}\r\nstatic void\r\nfree_linktype_cb(gpointer data, gpointer user_data _U_)\r\n{\r\ndata_link_info_t *linktype_info = (data_link_info_t *)data;\r\ng_free(linktype_info->name);\r\ng_free(linktype_info->description);\r\ng_free(linktype_info);\r\n}\r\nvoid\r\nfree_if_capabilities(if_capabilities_t *caps)\r\n{\r\ng_list_foreach(caps->data_link_types, free_linktype_cb, NULL);\r\ng_list_free(caps->data_link_types);\r\ng_free(caps);\r\n}\r\nconst char *\r\nlinktype_val_to_name(int dlt)\r\n{\r\nreturn pcap_datalink_val_to_name(dlt);\r\n}\r\nint\r\nlinktype_name_to_val(const char *linktype)\r\n{\r\nreturn pcap_datalink_name_to_val(linktype);\r\n}\r\nint\r\nget_pcap_datalink(pcap_t *pch, const char *devicename\r\n#ifndef _AIX\r\n_U_)\r\ngboolean\r\nset_pcap_datalink(pcap_t *pcap_h, int datalink, char *name,\r\nchar *errmsg, size_t errmsg_len,\r\nchar *secondary_errmsg, size_t secondary_errmsg_len)\r\n{\r\nchar *set_datalink_err_str;\r\nif (datalink == -1)\r\nreturn TRUE;\r\n#ifdef HAVE_PCAP_SET_DATALINK\r\nif (pcap_set_datalink(pcap_h, datalink) == 0)\r\nreturn TRUE;\r\nset_datalink_err_str = pcap_geterr(pcap_h);\r\n#else\r\nif (get_pcap_datalink(pcap_h, name) == datalink)\r\nreturn TRUE;\r\nset_datalink_err_str =\r\n"That DLT isn't one of the DLTs supported by this device";\r\n#endif\r\ng_snprintf(errmsg, (gulong) errmsg_len, "Unable to set data link type on interface '%s' (%s).",\r\nname, set_datalink_err_str);\r\nif (strstr(set_datalink_err_str, "is not one of the DLTs supported by this device") == NULL)\r\ng_snprintf(secondary_errmsg, (gulong) secondary_errmsg_len, please_report);\r\nelse\r\nsecondary_errmsg[0] = '\0';\r\nreturn FALSE;\r\n}\r\nstatic data_link_info_t *\r\ncreate_data_link_info(int dlt)\r\n{\r\ndata_link_info_t *data_link_info;\r\nconst char *text;\r\ndata_link_info = (data_link_info_t *)g_malloc(sizeof (data_link_info_t));\r\ndata_link_info->dlt = dlt;\r\ntext = pcap_datalink_val_to_name(dlt);\r\nif (text != NULL)\r\ndata_link_info->name = g_strdup(text);\r\nelse\r\ndata_link_info->name = g_strdup_printf("DLT %d", dlt);\r\ntext = pcap_datalink_val_to_description(dlt);\r\nif (text != NULL)\r\ndata_link_info->description = g_strdup(text);\r\nelse\r\ndata_link_info->description = NULL;\r\nreturn data_link_info;\r\n}\r\nstatic GList *\r\nget_data_link_types(pcap_t *pch, interface_options *interface_opts,\r\nchar **err_str)\r\n{\r\nGList *data_link_types;\r\nint deflt;\r\n#ifdef HAVE_PCAP_LIST_DATALINKS\r\nint *linktypes;\r\nint i, nlt;\r\n#endif\r\ndata_link_info_t *data_link_info;\r\ndeflt = get_pcap_datalink(pch, interface_opts->name);\r\n#ifdef HAVE_PCAP_LIST_DATALINKS\r\nnlt = pcap_list_datalinks(pch, &linktypes);\r\nif (nlt < 0) {\r\npcap_close(pch);\r\nif (err_str != NULL) {\r\nif (nlt == PCAP_ERROR)\r\n*err_str = g_strdup_printf("pcap_list_datalinks() failed: %s",\r\npcap_geterr(pch));\r\nelse\r\n*err_str = g_strdup(pcap_statustostr(nlt));\r\n}\r\nreturn NULL;\r\n}\r\ndata_link_types = NULL;\r\nfor (i = 0; i < nlt; i++) {\r\ndata_link_info = create_data_link_info(linktypes[i]);\r\nif (linktypes[i] == deflt)\r\ndata_link_types = g_list_prepend(data_link_types,\r\ndata_link_info);\r\nelse\r\ndata_link_types = g_list_append(data_link_types,\r\ndata_link_info);\r\n}\r\n#ifdef HAVE_PCAP_FREE_DATALINKS\r\npcap_free_datalinks(linktypes);\r\n#else\r\n#ifndef _WIN32\r\n#define xx_free free\r\nxx_free(linktypes);\r\n#endif\r\n#endif\r\n#else\r\ndata_link_info = create_data_link_info(deflt);\r\ndata_link_types = g_list_append(data_link_types, data_link_info);\r\n#endif\r\nif (err_str != NULL)\r\n*err_str = NULL;\r\nreturn data_link_types;\r\n}\r\nstatic gboolean\r\nis_linux_bonding_device(const char *ifname)\r\n{\r\nint fd;\r\nstruct ifreq ifr;\r\nifbond ifb;\r\nfd = socket(PF_INET, SOCK_DGRAM, 0);\r\nif (fd == -1)\r\nreturn FALSE;\r\nmemset(&ifr, 0, sizeof ifr);\r\ng_strlcpy(ifr.ifr_name, ifname, sizeof ifr.ifr_name);\r\nmemset(&ifb, 0, sizeof ifb);\r\nifr.ifr_data = (caddr_t)&ifb;\r\n#if defined(SIOCBONDINFOQUERY)\r\nif (ioctl(fd, SIOCBONDINFOQUERY, &ifr) == 0) {\r\nclose(fd);\r\nreturn TRUE;\r\n}\r\n#else\r\nif (ioctl(fd, BOND_INFO_QUERY_OLD, &ifr) == 0) {\r\nclose(fd);\r\nreturn TRUE;\r\n}\r\n#endif\r\nclose(fd);\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nis_linux_bonding_device(const char *ifname _U_)\r\n{\r\nreturn FALSE;\r\n}\r\nif_capabilities_t *\r\nget_if_capabilities_pcap_create(interface_options *interface_opts,\r\nchar **err_str)\r\n{\r\nif_capabilities_t *caps;\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\npcap_t *pch;\r\nint status;\r\ncaps = (if_capabilities_t *)g_malloc(sizeof *caps);\r\npch = pcap_create(interface_opts->name, errbuf);\r\nif (pch == NULL) {\r\nif (err_str != NULL)\r\n*err_str = g_strdup(errbuf);\r\ng_free(caps);\r\nreturn NULL;\r\n}\r\nif (is_linux_bonding_device(interface_opts->name)) {\r\nstatus = 0;\r\n} else {\r\nstatus = pcap_can_set_rfmon(pch);\r\n}\r\nif (status < 0) {\r\nif (status == PCAP_ERROR)\r\n*err_str = g_strdup_printf("pcap_can_set_rfmon() failed: %s",\r\npcap_geterr(pch));\r\nelse\r\n*err_str = g_strdup(pcap_statustostr(status));\r\npcap_close(pch);\r\ng_free(caps);\r\nreturn NULL;\r\n}\r\nif (status == 0)\r\ncaps->can_set_rfmon = FALSE;\r\nelse if (status == 1) {\r\ncaps->can_set_rfmon = TRUE;\r\nif (interface_opts->monitor_mode)\r\npcap_set_rfmon(pch, 1);\r\n} else {\r\nif (err_str != NULL) {\r\n*err_str = g_strdup_printf("pcap_can_set_rfmon() returned %d",\r\nstatus);\r\n}\r\npcap_close(pch);\r\ng_free(caps);\r\nreturn NULL;\r\n}\r\nstatus = pcap_activate(pch);\r\nif (status < 0) {\r\nif (err_str != NULL) {\r\nif (status == PCAP_ERROR)\r\n*err_str = g_strdup_printf("pcap_activate() failed: %s",\r\npcap_geterr(pch));\r\nelse\r\n*err_str = g_strdup(pcap_statustostr(status));\r\n}\r\npcap_close(pch);\r\ng_free(caps);\r\nreturn NULL;\r\n}\r\ncaps->data_link_types = get_data_link_types(pch, interface_opts,\r\nerr_str);\r\nif (caps->data_link_types == NULL) {\r\npcap_close(pch);\r\ng_free(caps);\r\nreturn NULL;\r\n}\r\npcap_close(pch);\r\nif (err_str != NULL)\r\n*err_str = NULL;\r\nreturn caps;\r\n}\r\nif_capabilities_t *\r\nget_if_capabilities_pcap_open_live(interface_options *interface_opts,\r\nchar **err_str)\r\n{\r\nif_capabilities_t *caps;\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\npcap_t *pch;\r\ncaps = (if_capabilities_t *)g_malloc(sizeof *caps);\r\npch = pcap_open_live(interface_opts->name, MIN_PACKET_SIZE, 0, 0,\r\nerrbuf);\r\ncaps->can_set_rfmon = FALSE;\r\nif (pch == NULL) {\r\nif (err_str != NULL)\r\n*err_str = g_strdup(errbuf[0] == '\0' ? "Unknown error (pcap bug; actual error cause not reported)" : errbuf);\r\ng_free(caps);\r\nreturn NULL;\r\n}\r\ncaps->data_link_types = get_data_link_types(pch, interface_opts,\r\nerr_str);\r\nif (caps->data_link_types == NULL) {\r\npcap_close(pch);\r\ng_free(caps);\r\nreturn NULL;\r\n}\r\npcap_close(pch);\r\nif (err_str != NULL)\r\n*err_str = NULL;\r\nreturn caps;\r\n}\r\nif_capabilities_t *\r\nget_if_capabilities(interface_options *interface_opts, char **err_str)\r\n{\r\n#if defined(HAVE_PCAP_OPEN) && defined(HAVE_PCAP_REMOTE)\r\nif_capabilities_t *caps;\r\nchar errbuf[PCAP_ERRBUF_SIZE];\r\npcap_t *pch;\r\nint deflt;\r\ndata_link_info_t *data_link_info;\r\nif (strncmp (interface_opts->name, "rpcap://", 8) == 0) {\r\nstruct pcap_rmtauth auth;\r\ncaps = (if_capabilities_t *)g_malloc(sizeof *caps);\r\nauth.type = interface_opts->auth_type == CAPTURE_AUTH_PWD ?\r\nRPCAP_RMTAUTH_PWD : RPCAP_RMTAUTH_NULL;\r\nauth.username = interface_opts->auth_username;\r\nauth.password = interface_opts->auth_password;\r\nerrbuf[0] = '\0';\r\npch = pcap_open(interface_opts->name, MIN_PACKET_SIZE, 0, 0, &auth,\r\nerrbuf);\r\nif (pch == NULL) {\r\nif (err_str != NULL)\r\n*err_str = g_strdup(errbuf[0] == '\0' ? "Unknown error (pcap bug; actual error cause not reported)" : errbuf);\r\ng_free(caps);\r\nreturn NULL;\r\n}\r\ndeflt = get_pcap_datalink(pch, interface_opts->name);\r\ndata_link_info = create_data_link_info(deflt);\r\ncaps->data_link_types = g_list_append(caps->data_link_types,\r\ndata_link_info);\r\npcap_close(pch);\r\nif (err_str != NULL)\r\n*err_str = NULL;\r\nreturn caps;\r\n}\r\n#endif\r\nreturn get_if_capabilities_local(interface_opts, err_str);\r\n}
