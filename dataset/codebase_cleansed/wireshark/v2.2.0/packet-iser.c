static int dissect_packet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\ntvbuff_t *next_tvb;\r\nproto_item *ti;\r\nproto_tree *iser_tree;\r\nguint offset = 0;\r\nguint8 flags = tvb_get_guint8(tvb, 0);\r\nguint8 vers;\r\nguint8 opcode = flags & ISER_OPCODE_MASK;\r\nswitch (opcode) {\r\ncase ISER_ISCSI_CTRL:\r\nswitch (flags & ISER_SPECIFIC_MASK) {\r\ncase 0:\r\ncase ISER_WSV:\r\ncase ISER_RSV:\r\ncase ISER_RSV|ISER_WSV:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISER_HELLO:\r\ncase ISER_HELLORPLY:\r\nvers = tvb_get_guint8(tvb, 1);\r\nif ((vers & 0xf) != 10)\r\nreturn 0;\r\nif (((vers >> 4) & 0x0f) != 10)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "iSER");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nswitch (opcode) {\r\ncase ISER_HELLO:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "iSER Hello");\r\nbreak;\r\ncase ISER_HELLORPLY:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "iSER HelloRply");\r\nbreak;\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_iser, tvb, 0, ISER_HDR_SZ, ENC_NA);\r\niser_tree = proto_item_add_subtree(ti, ett_iser);\r\nswitch (opcode) {\r\ncase ISER_ISCSI_CTRL:\r\nproto_tree_add_bitmask(iser_tree, tvb, offset, hf_iser_flags,\r\nett_iser_flags, flags_fields, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(iser_tree, hf_iser_write_stag, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(iser_tree, hf_iser_write_va, tvb,\r\noffset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(iser_tree, hf_iser_read_stag, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(iser_tree, hf_iser_read_va, tvb,\r\noffset, 8, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase ISER_HELLO:\r\nproto_tree_add_bitmask(iser_tree, tvb, offset, hf_iser_flags,\r\nett_iser_flags, hello_flags_fields, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(iser_tree, hf_iser_ird, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase ISER_HELLORPLY:\r\nproto_tree_add_bitmask(iser_tree, tvb, offset, hf_iser_flags,\r\nett_iser_flags, hellorply_flags_fields, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(iser_tree, hf_iser_ord, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\n}\r\nif (opcode == ISER_ISCSI_CTRL) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, ISER_HDR_SZ);\r\ncall_dissector(iscsi_handler, next_tvb, pinfo, tree);\r\n}\r\nreturn ISER_HDR_SZ;\r\n}\r\nstatic int\r\ndissect_iser(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nconversation_t *conv;\r\nconversation_infiniband_data *convo_data = NULL;\r\nif (tvb_reported_length(tvb) < ISER_ISCSI_HDR_SZ)\r\nreturn 0;\r\nif (gPREF_MAN_EN) {\r\nif ( (addresses_equal(&pinfo->src, &manual_addr[0]) &&\r\naddresses_equal(&pinfo->dst, &manual_addr[1]) &&\r\n(pinfo->srcport == 0xffffffff || pinfo->srcport == gPREF_QP[0]) &&\r\n(pinfo->destport == 0xffffffff || pinfo->destport == gPREF_QP[1])) ||\r\n(addresses_equal(&pinfo->src, &manual_addr[1]) &&\r\naddresses_equal(&pinfo->dst, &manual_addr[0]) &&\r\n(pinfo->srcport == 0xffffffff || pinfo->srcport == gPREF_QP[1]) &&\r\n(pinfo->destport == 0xffffffff || pinfo->destport == gPREF_QP[0])) )\r\nreturn dissect_packet(tvb, pinfo, tree);\r\n}\r\nconv = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,\r\nPT_IBQP, pinfo->srcport, pinfo->destport, 0);\r\nif (!conv) {\r\nconv = find_conversation(pinfo->num, &pinfo->dst, &pinfo->dst,\r\nPT_IBQP, pinfo->destport, pinfo->destport, NO_ADDR_B|NO_PORT_B);\r\nif (!conv)\r\nreturn 0;\r\n}\r\nconvo_data = (conversation_infiniband_data *)conversation_get_proto_data(conv, proto_ib);\r\nif (!convo_data)\r\nreturn 0;\r\nif ((convo_data->service_id & SID_MASK) != SID_ULP_TCP)\r\nreturn 0;\r\nif (!(value_is_in_range(gPORT_RANGE, (guint32)(convo_data->service_id & SID_PORT_MASK))))\r\nreturn 0;\r\nreturn dissect_packet(tvb, pinfo, tree);\r\n}\r\nvoid\r\nproto_register_iser(void)\r\n{\r\nmodule_t *iser_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_iser_flags,\r\n{ "Flags", "iser.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{ &hf_iser_opcode_f,\r\n{ "Opcode", "iser.flags.opcode",\r\nFT_UINT8, BASE_HEX, VALS(iser_flags_opcode),\r\nISER_OPCODE_MASK, NULL, HFILL}\r\n},\r\n{ &hf_iser_RSV_f,\r\n{ "RSV", "iser.flags.rsv",\r\nFT_BOOLEAN, 8, NULL, ISER_RSV, "Read STag Valid", HFILL}\r\n},\r\n{ &hf_iser_WSV_f,\r\n{ "WSV", "iser.flags.wsv",\r\nFT_BOOLEAN, 8, NULL, ISER_WSV, "Write STag Valid", HFILL}\r\n},\r\n{ &hf_iser_REJ_f,\r\n{ "REJ", "iser.flags.rej",\r\nFT_BOOLEAN, 8, NULL, ISER_REJ, "Target reject connection", HFILL}\r\n},\r\n{ &hf_iser_write_stag,\r\n{ "Write STag", "iser.write_stag",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{ &hf_iser_write_va,\r\n{ "Write Base Offset", "iser.write_base_offset",\r\nFT_UINT64, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{ &hf_iser_read_stag,\r\n{ "Read STag", "iser.read_stag",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{ &hf_iser_read_va,\r\n{ "Read Base Offset", "iser.read_base_offset",\r\nFT_UINT64, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{ &hf_iser_ird,\r\n{ "iSER-IRD", "iser.ird",\r\nFT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n},\r\n{ &hf_iser_ord,\r\n{ "iSER-ORD", "iser.ord",\r\nFT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL}\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_iser,\r\n&ett_iser_flags\r\n};\r\nproto_iser = proto_register_protocol (\r\n"iSCSI Extensions for RDMA",\r\n"iSER",\r\n"iser"\r\n);\r\nproto_register_field_array(proto_iser, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\niser_module = prefs_register_protocol(proto_iser, proto_reg_handoff_iser);\r\nprefs_register_bool_preference(iser_module, "manual_en", "Enable manual settings",\r\n"Check to treat all traffic between the configured source/destination as iSER",\r\n&gPREF_MAN_EN);\r\nprefs_register_static_text_preference(iser_module, "addr_a", "Address A",\r\n"Side A of the manually-configured connection");\r\nprefs_register_enum_preference(iser_module, "addr_a_type", "Address Type",\r\n"Type of address specified", &gPREF_TYPE[0], pref_address_types, FALSE);\r\nprefs_register_string_preference(iser_module, "addr_a_id", "ID",\r\n"LID/GID of address A", &gPREF_ID[0]);\r\nprefs_register_uint_preference(iser_module, "addr_a_qp", "QP Number",\r\n"QP Number for address A", 10, &gPREF_QP[0]);\r\nprefs_register_static_text_preference(iser_module, "addr_b", "Address B",\r\n"Side B of the manually-configured connection");\r\nprefs_register_enum_preference(iser_module, "addr_b_type", "Address Type",\r\n"Type of address specified", &gPREF_TYPE[1], pref_address_types, FALSE);\r\nprefs_register_string_preference(iser_module, "addr_b_id", "ID",\r\n"LID/GID of address B", &gPREF_ID[1]);\r\nprefs_register_uint_preference(iser_module, "addr_b_qp", "QP Number",\r\n"QP Number for address B", 10, &gPREF_QP[1]);\r\nrange_convert_str(&gPORT_RANGE, TCP_PORT_ISER_RANGE, MAX_TCP_PORT);\r\nprefs_register_range_preference(iser_module,\r\n"target_ports",\r\n"Target Ports Range",\r\n"Range of iSER target ports"\r\n"(default " TCP_PORT_ISER_RANGE ")",\r\n&gPORT_RANGE, MAX_TCP_PORT);\r\n}\r\nvoid\r\nproto_reg_handoff_iser(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nif (!initialized) {\r\ncreate_dissector_handle(dissect_iser, proto_iser);\r\nheur_dissector_add("infiniband.payload", dissect_iser, "iSER Infiniband", "iser_infiniband", proto_iser, HEURISTIC_ENABLE);\r\nheur_dissector_add("infiniband.mad.cm.private", dissect_iser, "iSER in PrivateData of CM packets", "iser_ib_private", proto_iser, HEURISTIC_ENABLE);\r\nmanual_addr_data[0] = wmem_alloc(wmem_epan_scope(), GID_SIZE);\r\nmanual_addr_data[1] = wmem_alloc(wmem_epan_scope(), GID_SIZE);\r\niscsi_handler = find_dissector_add_dependency("iscsi", proto_iser);\r\nib_handler = find_dissector_add_dependency("infiniband", proto_iser);\r\nproto_ib = dissector_handle_get_protocol_index(ib_handler);\r\ninitialized = TRUE;\r\n}\r\nif (gPREF_MAN_EN) {\r\ngboolean error_occured = FALSE;\r\nchar *not_parsed;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nif (gPREF_TYPE[i] == 0) {\r\nerrno = 0;\r\n*((guint16*)manual_addr_data[i]) = (guint16)strtoul(gPREF_ID[i], &not_parsed, 0);\r\nif (errno || *not_parsed != '\0') {\r\nerror_occured = TRUE;\r\n} else {\r\nset_address(&manual_addr[i], AT_IB, sizeof(guint16), manual_addr_data[i]);\r\n}\r\n} else {\r\nif (!str_to_ip6(gPREF_ID[i], manual_addr_data[i]) ) {\r\nerror_occured = TRUE;\r\n} else {\r\nset_address(&manual_addr[i], AT_IB, GID_SIZE, manual_addr_data[i]);\r\n}\r\n}\r\nif (error_occured) {\r\ngPREF_MAN_EN = FALSE;\r\nbreak;\r\n}\r\n}\r\n}\r\n}
