static void\r\nopenvpn_reassemble_init(void)\r\n{\r\nreassembly_table_init(&msg_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\nopenvpn_reassemble_cleanup(void)\r\n{\r\nreassembly_table_destroy(&msg_reassembly_table);\r\n}\r\nstatic gboolean\r\ncheck_for_valid_hmac(guint32 hmac)\r\n{\r\ngint c = 0;\r\nif ((hmac & 0x000000FF) == 0x00000000) {\r\nc++;\r\n}\r\nif ((hmac & 0x0000FF00) == 0x00000000) {\r\nc++;\r\n}\r\nif ((hmac & 0x00FF0000) == 0x00000000) {\r\nc++;\r\n}\r\nif ((hmac & 0xFF000000) == 0x00000000) {\r\nc++;\r\n}\r\nif (c > 1) {\r\nreturn FALSE;\r\n} else {\r\nreturn TRUE;\r\n}\r\n}\r\nstatic int\r\ndissect_openvpn_msg_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *openvpn_tree, proto_tree *parent_tree, gint offset)\r\n{\r\ngboolean tls_auth;\r\nguint openvpn_keyid;\r\nguint openvpn_opcode;\r\nguint32 msg_mpid = -1;\r\nguint32 msg_sessionid = -1;\r\nguint8 openvpn_predict_tlsauth_arraylength;\r\nproto_item *ti2;\r\nproto_tree *packetarray_tree, *type_tree;\r\nguint32 msg_length_remaining;\r\ngboolean msg_lastframe;\r\nfragment_head *frag_msg;\r\ntvbuff_t *new_tvb;\r\ngboolean save_fragmented;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PSNAME);\r\ncol_clear(pinfo->cinfo,COL_INFO);\r\nopenvpn_opcode = tvb_get_bits8(tvb, offset*8, 5);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "MessageType: %s",\r\nval_to_str_const(openvpn_opcode, openvpn_message_types, "Unknown Messagetype"));\r\nopenvpn_keyid = tvb_get_bits8(tvb, offset*8 + 5, 3);\r\nproto_item_append_text(parent_tree, ", Opcode: %s, Key ID: %d",\r\nval_to_str(openvpn_opcode, openvpn_message_types, "Unknown (0x%02x)"),\r\nopenvpn_keyid);\r\nti2 = proto_tree_add_item(openvpn_tree, hf_openvpn_pdu_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti2, " [opcode/key_id]");\r\ntype_tree = proto_item_add_subtree(ti2, ett_openvpn_type);\r\nproto_tree_add_item(type_tree, hf_openvpn_opcode, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(type_tree, hf_openvpn_keyid, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (openvpn_opcode == P_DATA_V2) {\r\nproto_tree_add_item(openvpn_tree, hf_openvpn_peerid, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\n} else if (openvpn_opcode != P_DATA_V1) {\r\nmsg_sessionid = tvb_get_bits32(tvb, offset*8+32, 32, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(openvpn_tree, hf_openvpn_sessionid, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nopenvpn_predict_tlsauth_arraylength = tvb_get_guint8(tvb, offset);\r\nif (pref_tls_auth_override == FALSE) {\r\nif ((openvpn_opcode != P_DATA_V1)\r\n&& (openvpn_predict_tlsauth_arraylength > 0)\r\n&& check_for_valid_hmac(tvb_get_ntohl(tvb, offset))) {\r\ntls_auth = TRUE;\r\n} else {\r\ntls_auth = FALSE;\r\n}\r\n} else {\r\ntls_auth = pref_tls_auth;\r\n}\r\nif (tls_auth == TRUE) {\r\nproto_tree_add_item(openvpn_tree, hf_openvpn_hmac, tvb, offset, tls_auth_hmac_size, ENC_NA);\r\noffset += tls_auth_hmac_size;\r\nif (tvb_reported_length_remaining(tvb, offset) >= 8) {\r\nproto_tree_add_item(openvpn_tree, hf_openvpn_pid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (pref_long_format) {\r\nproto_tree_add_item(openvpn_tree, hf_openvpn_net_time, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\n}\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) >= 1) {\r\ngint pid_arraylength = tvb_get_guint8(tvb, offset);\r\ngint i;\r\nproto_tree_add_item(openvpn_tree, hf_openvpn_mpid_arraylength, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (pid_arraylength > 0) {\r\npacketarray_tree = proto_tree_add_subtree(openvpn_tree, tvb, offset, 0, ett_openvpn_packetarray, NULL, "Packet-ID Array");\r\nfor (i = 0; i < pid_arraylength; i++) {\r\nproto_tree_add_item(packetarray_tree, hf_openvpn_mpid_arrayelement, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) >= 8) {\r\nproto_tree_add_item(openvpn_tree, hf_openvpn_rsessionid, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\n}\r\n}\r\n}\r\nif (openvpn_opcode != P_ACK_V1) {\r\nif (tvb_reported_length_remaining(tvb, offset) >= 4) {\r\nmsg_mpid = tvb_get_bits32(tvb, offset*8, 32, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(openvpn_tree, hf_openvpn_mpid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\n}\r\n}\r\nmsg_length_remaining = tvb_reported_length_remaining(tvb, offset);\r\nif (msg_length_remaining == 0) {\r\nreturn tvb_captured_length(tvb);\r\n}\r\nif (openvpn_opcode != P_CONTROL_V1) {\r\nproto_tree *data_tree;\r\ndata_tree = proto_tree_add_subtree_format(openvpn_tree, tvb, offset, -1,\r\nett_openvpn_data, NULL, "Data (%d bytes)",\r\ntvb_captured_length_remaining(tvb, offset));\r\nproto_tree_add_item(data_tree, hf_openvpn_data, tvb, offset, -1, ENC_NA);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nif (msg_length_remaining == 100) {\r\nmsg_lastframe = FALSE;\r\n} else {\r\nmsg_lastframe = TRUE;\r\n}\r\nsave_fragmented = pinfo->fragmented;\r\npinfo->fragmented = TRUE;\r\nfrag_msg = fragment_add_seq_next(\r\n&msg_reassembly_table,\r\ntvb,\r\noffset,\r\npinfo,\r\nmsg_sessionid,\r\nNULL,\r\nmsg_length_remaining,\r\n!(msg_lastframe));\r\nif ((frag_msg == NULL) || (frag_msg->next != NULL)) {\r\nproto_tree *data_tree;\r\ndata_tree = proto_tree_add_subtree_format(openvpn_tree, tvb, offset, -1,\r\nett_openvpn_data, NULL, "Message fragment (%d bytes)",\r\ntvb_captured_length_remaining(tvb, offset));\r\nproto_tree_add_item(data_tree, hf_openvpn_fragment_bytes, tvb, offset, -1, ENC_NA);\r\n}\r\nnew_tvb = NULL;\r\nif (frag_msg) {\r\nif (msg_lastframe) {\r\nnew_tvb = process_reassembled_data(tvb, offset, pinfo, "Reassembled Message",\r\nfrag_msg, &openvpn_frag_items, NULL, openvpn_tree);\r\nif (frag_msg->next != NULL) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " (Message Reassembled ");\r\n}\r\n} else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (Message fragment %d) ", msg_mpid);\r\nif (pinfo->num != frag_msg->reassembled_in) {\r\nproto_tree_add_uint(openvpn_tree, hf_openvpn_reassembled_in,\r\ntvb, 0, 0, frag_msg->reassembled_in);\r\n}\r\n}\r\n}\r\npinfo->fragmented = save_fragmented;\r\nif (new_tvb) {\r\ncall_dissector(ssl_handle, new_tvb, pinfo, parent_tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic guint\r\nget_msg_length(packet_info *pinfo _U_, tvbuff_t *tvb, gint offset, void *data _U_)\r\n{\r\nreturn (guint)tvb_get_ntohs(tvb, offset) + 2;\r\n}\r\nstatic int\r\ndissect_openvpn_msg_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *openvpn_tree;\r\nti = proto_tree_add_item(tree, proto_openvpn, tvb, 0, -1, ENC_NA);\r\nopenvpn_tree = proto_item_add_subtree(ti, ett_openvpn);\r\nproto_tree_add_item(openvpn_tree, hf_openvpn_plen, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nreturn dissect_openvpn_msg_common(tvb, pinfo, openvpn_tree, tree, 2);\r\n}\r\nstatic int\r\ndissect_openvpn_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus( tvb, pinfo, tree,\r\nTRUE,\r\n2,\r\nget_msg_length,\r\ndissect_openvpn_msg_tcp, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_openvpn_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *openvpn_tree;\r\nti = proto_tree_add_item(tree, proto_openvpn, tvb, 0, -1, ENC_NA);\r\nopenvpn_tree = proto_item_add_subtree(ti, ett_openvpn);\r\nreturn dissect_openvpn_msg_common(tvb, pinfo, openvpn_tree, tree, 0);\r\n}\r\nvoid\r\nproto_register_openvpn(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_openvpn_plen,\r\n{ "Packet Length", "openvpn.plen",\r\nFT_UINT16, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_pdu_type,\r\n{ "Type", "openvpn.type",\r\nFT_UINT8, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_opcode,\r\n{ "Opcode", "openvpn.opcode",\r\nFT_UINT8, BASE_HEX,\r\nVALS(openvpn_message_types), P_OPCODE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_keyid,\r\n{ "Key ID", "openvpn.keyid",\r\nFT_UINT8, BASE_DEC,\r\nNULL, P_KEY_ID_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_peerid,\r\n{ "Peer ID", "openvpn.peerid",\r\nFT_UINT24, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_sessionid,\r\n{ "Session ID", "openvpn.sessionid",\r\nFT_UINT64, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_hmac,\r\n{ "HMAC", "openvpn.hmac",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_pid,\r\n{ "Packet-ID", "openvpn.pid",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_net_time,\r\n{ "Net Time", "openvpn.net_time",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_rsessionid,\r\n{ "Remote Session ID", "openvpn.rsessionid",\r\nFT_UINT64, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_mpid,\r\n{ "Message Packet-ID", "openvpn.mpid",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_mpid_arraylength,\r\n{ "Message Packet-ID Array Length", "openvpn.mpidarraylength",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_mpid_arrayelement,\r\n{ "Message Packet-ID Array Element", "openvpn.mpidarrayelement",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_data,\r\n{ "Data", "openvpn.data",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_fragment_bytes,\r\n{ "Fragment bytes", "openvpn.fragment_bytes",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_fragments,\r\n{ "Message fragments", "openvpn.fragments",\r\nFT_NONE, BASE_NONE,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_fragment,\r\n{ "Message fragment", "openvpn.fragment",\r\nFT_FRAMENUM, BASE_NONE,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_fragment_overlap,\r\n{ "Message fragment overlap", "openvpn.fragment.overlap",\r\nFT_BOOLEAN, 0,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_fragment_overlap_conflicts,\r\n{ "Message fragment overlapping with conflicting data", "openvpn.fragment.overlap.conflicts",\r\nFT_BOOLEAN, 0,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_fragment_multiple_tails,\r\n{ "Message has multiple tail fragments", "openvpn.fragment.multiple_tails",\r\nFT_BOOLEAN, 0,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_fragment_too_long_fragment,\r\n{ "Message fragment too long", "openvpn.fragment.too_long_fragment",\r\nFT_BOOLEAN, 0,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_fragment_error,\r\n{ "Message defragmentation error", "openvpn.fragment.error",\r\nFT_FRAMENUM, BASE_NONE,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_fragment_count,\r\n{ "Message fragment count", "openvpn.fragment.count",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_reassembled_in,\r\n{ "Reassembled message in frame", "openvpn.reassembled.in",\r\nFT_FRAMENUM, BASE_NONE,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_openvpn_reassembled_length,\r\n{"Reassembled message length", "openvpn.reassembled.length",\r\nFT_UINT32, BASE_DEC,\r\nNULL, 0x00,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_openvpn,\r\n&ett_openvpn_type,\r\n&ett_openvpn_data,\r\n&ett_openvpn_packetarray,\r\n&ett_openvpn_fragment,\r\n&ett_openvpn_fragments\r\n};\r\nmodule_t *openvpn_module;\r\nproto_openvpn = proto_register_protocol (\r\nPNAME,\r\nPSNAME,\r\nPFNAME\r\n);\r\nproto_register_field_array(proto_openvpn, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nopenvpn_udp_handle = register_dissector("openvpn.udp", dissect_openvpn_udp, proto_openvpn);\r\nopenvpn_tcp_handle = register_dissector("openvpn.tcp", dissect_openvpn_tcp, proto_openvpn);\r\nregister_init_routine(&openvpn_reassemble_init);\r\nregister_cleanup_routine(&openvpn_reassemble_cleanup);\r\nopenvpn_module = prefs_register_protocol(proto_openvpn, proto_reg_handoff_openvpn);\r\nprefs_register_uint_preference(openvpn_module,\r\n"tcp.port",\r\n"OpenVPN TCP Port",\r\n"TCP Port of the OpenVPN tunnel",\r\n10, &pref_tcp_port);\r\nprefs_register_uint_preference(openvpn_module,\r\n"udp.port",\r\n"OpenVPN UDP Port",\r\n"UDP Port of the OpenVPN tunnel",\r\n10, &pref_udp_port);\r\nprefs_register_bool_preference(openvpn_module,\r\n"tls_auth_detection_override",\r\n"override tls-auth detection",\r\n"If tls-auth detection fails, you can choose to override detection and set tls-auth yourself",\r\n&pref_tls_auth_override);\r\nprefs_register_bool_preference(openvpn_module,\r\n"tls_auth",\r\n"--tls-auth used?",\r\n"If the parameter --tls-auth is used, the following preferences must also be defined.",\r\n&pref_tls_auth);\r\nprefs_register_uint_preference(openvpn_module,\r\n"tls_auth_hmac_size",\r\n"size of the HMAC header in bytes",\r\n"If the parameter --tls-auth is used, a HMAC header is being inserted.\n"\r\n"The default HMAC algorithm is SHA-1 which generates a 160 bit HMAC,"\r\n" therefore 20 bytes should be ok.\n"\r\n"The value must be between 20 (160 bits) and 64 (512 bits).",\r\n10, &tls_auth_hmac_size);\r\nprefs_register_bool_preference(openvpn_module,\r\n"long_format",\r\n"packet-id for replay protection includes optional time_t timestamp?",\r\n"If the parameter --tls-auth is used, an additional packet-id for replay protection"\r\n" is inserted after the HMAC signature."\r\n" This field can either be 4 bytes or 8 bytes including an optional time_t timestamp long.\n"\r\n" This option is only evaluated if tls_auth_hmac_size > 0.\n"\r\n" The default value is TRUE.",\r\n&pref_long_format);\r\n}\r\nvoid\r\nproto_reg_handoff_openvpn(void)\r\n{\r\nstatic guint tcp_port;\r\nstatic guint udp_port;\r\nstatic gboolean initialized = FALSE;\r\nif (! initialized) {\r\nssl_handle = find_dissector_add_dependency("ssl", proto_openvpn);\r\ninitialized = TRUE;\r\n} else {\r\nif (tcp_port > 0)\r\ndissector_delete_uint("tcp.port", tcp_port, openvpn_tcp_handle);\r\nif (udp_port > 0)\r\ndissector_delete_uint("udp.port", udp_port, openvpn_udp_handle);\r\n}\r\ntcp_port = pref_tcp_port;\r\nudp_port = pref_udp_port;\r\nif (tcp_port > 0)\r\ndissector_add_uint("tcp.port", tcp_port, openvpn_tcp_handle);\r\nif (udp_port > 0)\r\ndissector_add_uint("udp.port", udp_port, openvpn_udp_handle);\r\n}
