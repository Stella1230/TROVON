static int\r\ndissect_rquota(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_item *lock_item = NULL;\r\nproto_tree *lock_tree = NULL;\r\nlock_item = proto_tree_add_item(tree, hf_rquota_rquota, tvb,\r\noffset, -1, ENC_NA);\r\nlock_tree = proto_item_add_subtree(lock_item, ett_rquota_rquota);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_rquota_bsize, offset);\r\noffset = dissect_rpc_bool(tvb, lock_tree,\r\nhf_rquota_active, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_rquota_bhardlimit, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_rquota_bsoftlimit, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_rquota_curblocks, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_rquota_fhardlimit, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_rquota_fsoftlimit, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_rquota_curfiles, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_rquota_btimeleft, offset);\r\noffset = dissect_rpc_uint32(tvb, lock_tree,\r\nhf_rquota_ftimeleft, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_getquota_result(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\ngint32 status;\r\nint offset = 0;\r\nstatus = tvb_get_ntohl(tvb, offset);\r\noffset = dissect_rpc_uint32(tvb, tree,\r\nhf_rquota_status, offset);\r\nif (status==Q_OK) {\r\noffset = dissect_rquota(tvb, offset, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_getquota_call(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree,\r\nhf_rquota_pathp, offset, NULL);\r\noffset = dissect_rpc_uint32(tvb, tree,\r\nhf_rquota_uid, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_getquota2_call(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\noffset = dissect_rpc_string(tvb, tree,\r\nhf_rquota_pathp, offset, NULL);\r\noffset = dissect_rpc_uint32(tvb, tree,\r\nhf_rquota_type, offset);\r\noffset = dissect_rpc_uint32(tvb, tree,\r\nhf_rquota_id, offset);\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_rquota(void)\r\n{\r\nstatic struct true_false_string tfs_active = { "Quota is ACTIVE", "Quota is NOT active" };\r\nstatic hf_register_info hf[] = {\r\n{ &hf_rquota_procedure_v1, {\r\n"V1 Procedure", "rquota.procedure_v1", FT_UINT32, BASE_DEC,\r\nVALS(rquota1_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_rquota_procedure_v2, {\r\n"V2 Procedure", "rquota.procedure_v2", FT_UINT32, BASE_DEC,\r\nVALS(rquota2_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_rquota_uid, {\r\n"uid", "rquota.uid", FT_UINT32, BASE_DEC,\r\nNULL, 0, "User ID", HFILL }},\r\n{ &hf_rquota_type, {\r\n"type", "rquota.type", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rquota_id, {\r\n"id", "rquota.id", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rquota_pathp, {\r\n"pathp", "rquota.pathp", FT_STRING, BASE_NONE,\r\nNULL, 0, "Filesystem of interest", HFILL }},\r\n{ &hf_rquota_status, {\r\n"status", "rquota.status", FT_UINT32, BASE_DEC,\r\nVALS(names_rquota_status), 0, "Status code", HFILL }},\r\n{ &hf_rquota_rquota, {\r\n"rquota", "rquota.rquota", FT_NONE, BASE_NONE,\r\nNULL, 0, "Rquota structure", HFILL }},\r\n{ &hf_rquota_bsize, {\r\n"bsize", "rquota.bsize", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Block size", HFILL }},\r\n{ &hf_rquota_active, {\r\n"active", "rquota.active", FT_BOOLEAN, BASE_NONE,\r\nTFS(&tfs_active), 0x0, "Indicates whether quota is active", HFILL }},\r\n{ &hf_rquota_bhardlimit, {\r\n"bhardlimit", "rquota.bhardlimit", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Hard limit for blocks", HFILL }},\r\n{ &hf_rquota_bsoftlimit, {\r\n"bsoftlimit", "rquota.bsoftlimit", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Soft limit for blocks", HFILL }},\r\n{ &hf_rquota_curblocks, {\r\n"curblocks", "rquota.curblocks", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Current block count", HFILL }},\r\n{ &hf_rquota_fhardlimit, {\r\n"fhardlimit", "rquota.fhardlimit", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Hard limit on allocated files", HFILL }},\r\n{ &hf_rquota_fsoftlimit, {\r\n"fsoftlimit", "rquota.fsoftlimit", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Soft limit of allocated files", HFILL }},\r\n{ &hf_rquota_curfiles, {\r\n"curfiles", "rquota.curfiles", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Current # allocated files", HFILL }},\r\n{ &hf_rquota_btimeleft, {\r\n"btimeleft", "rquota.btimeleft", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Time left for excessive disk use", HFILL }},\r\n{ &hf_rquota_ftimeleft, {\r\n"ftimeleft", "rquota.ftimeleft", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Time left for excessive files", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_rquota,\r\n&ett_rquota_rquota,\r\n};\r\nproto_rquota = proto_register_protocol("Remote Quota",\r\n"RQUOTA", "rquota");\r\nproto_register_field_array(proto_rquota, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_rquota(void)\r\n{\r\nrpc_init_prog(proto_rquota, RQUOTA_PROGRAM, ett_rquota,\r\nG_N_ELEMENTS(rquota_vers_info), rquota_vers_info);\r\n}
