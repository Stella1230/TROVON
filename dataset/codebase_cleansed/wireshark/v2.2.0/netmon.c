wtap_open_return_val netmon_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar magic[MAGIC_SIZE];\r\nstruct netmon_hdr hdr;\r\nint file_type;\r\nstruct tm tm;\r\nguint32 frame_table_offset;\r\nguint32 frame_table_length;\r\nguint32 frame_table_size;\r\nguint32 *frame_table;\r\n#ifdef WORDS_BIGENDIAN\r\nunsigned int i;\r\n#endif\r\nnetmon_t *netmon;\r\nif (!wtap_read_bytes(wth->fh, magic, MAGIC_SIZE, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(magic, netmon_1_x_magic, MAGIC_SIZE) != 0 &&\r\nmemcmp(magic, netmon_2_x_magic, MAGIC_SIZE) != 0) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &hdr, sizeof hdr, err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nswitch (hdr.ver_major) {\r\ncase 1:\r\nfile_type = WTAP_FILE_TYPE_SUBTYPE_NETMON_1_x;\r\nbreak;\r\ncase 2:\r\nfile_type = WTAP_FILE_TYPE_SUBTYPE_NETMON_2_x;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netmon: major version %u unsupported", hdr.ver_major);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nhdr.network = pletoh16(&hdr.network);\r\nif (hdr.network >= NUM_NETMON_ENCAPS\r\n|| netmon_encap[hdr.network] == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netmon: network type %u unknown or unsupported",\r\nhdr.network);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nwth->file_type_subtype = file_type;\r\nnetmon = (netmon_t *)g_malloc(sizeof(netmon_t));\r\nwth->priv = (void *)netmon;\r\nwth->subtype_read = netmon_read;\r\nwth->subtype_seek_read = netmon_seek_read;\r\nwth->subtype_sequential_close = netmon_sequential_close;\r\nif((hdr.ver_major == 2 && hdr.ver_minor >= 1) || hdr.ver_major > 2)\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\nelse\r\nwth->file_encap = netmon_encap[hdr.network];\r\nwth->snapshot_length = 0;\r\ntm.tm_year = pletoh16(&hdr.ts_year) - 1900;\r\ntm.tm_mon = pletoh16(&hdr.ts_month) - 1;\r\ntm.tm_mday = pletoh16(&hdr.ts_day);\r\ntm.tm_hour = pletoh16(&hdr.ts_hour);\r\ntm.tm_min = pletoh16(&hdr.ts_min);\r\ntm.tm_sec = pletoh16(&hdr.ts_sec);\r\ntm.tm_isdst = -1;\r\nnetmon->start_secs = mktime(&tm);\r\nnetmon->start_nsecs = pletoh16(&hdr.ts_msec)*1000000;\r\nnetmon->version_major = hdr.ver_major;\r\nnetmon->version_minor = hdr.ver_minor;\r\nnetmon->frame_table_size = 0;\r\nnetmon->frame_table = NULL;\r\nframe_table_offset = pletoh32(&hdr.frametableoffset);\r\nframe_table_length = pletoh32(&hdr.frametablelength);\r\nframe_table_size = frame_table_length / (guint32)sizeof (guint32);\r\nif ((frame_table_size * sizeof (guint32)) != frame_table_length) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("netmon: frame table length is %u, which is not a multiple of the size of an entry",\r\nframe_table_length);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (frame_table_size == 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("netmon: frame table length is %u, which means it's less than one entry in size",\r\nframe_table_length);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (frame_table_size > 512*1024*1024) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("netmon: frame table length is %u, which is larger than we support",\r\nframe_table_length);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (file_seek(wth->fh, frame_table_offset, SEEK_SET, err) == -1) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nframe_table = (guint32 *)g_try_malloc(frame_table_length);\r\nif (frame_table_length != 0 && frame_table == NULL) {\r\n*err = ENOMEM;\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (!wtap_read_bytes(wth->fh, frame_table, frame_table_length,\r\nerr, err_info)) {\r\ng_free(frame_table);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nnetmon->frame_table_size = frame_table_size;\r\nnetmon->frame_table = frame_table;\r\n#ifdef WORDS_BIGENDIAN\r\nfor (i = 0; i < frame_table_size; i++)\r\nframe_table[i] = pletoh32(&frame_table[i]);\r\n#endif\r\nnetmon->current_frame = 0;\r\nswitch (netmon->version_major) {\r\ncase 1:\r\nwth->file_tsprec = WTAP_TSPREC_MSEC;\r\nbreak;\r\ncase 2:\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nbreak;\r\n}\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic void\r\nnetmon_set_pseudo_header_info(struct wtap_pkthdr *phdr, Buffer *buf)\r\n{\r\nswitch (phdr->pkt_encap) {\r\ncase WTAP_ENCAP_ATM_PDUS:\r\natm_guess_traffic_type(phdr, ws_buffer_start_ptr(buf));\r\nbreak;\r\ncase WTAP_ENCAP_ETHERNET:\r\nphdr->pseudo_header.eth.fcs_len = 0;\r\nbreak;\r\ncase WTAP_ENCAP_IEEE_802_11_NETMON:\r\nmemset(&phdr->pseudo_header.ieee_802_11, 0, sizeof(phdr->pseudo_header.ieee_802_11));\r\nphdr->pseudo_header.ieee_802_11.fcs_len = -2;\r\nphdr->pseudo_header.ieee_802_11.decrypted = FALSE;\r\nphdr->pseudo_header.ieee_802_11.datapad = FALSE;\r\nphdr->pseudo_header.ieee_802_11.phy = PHDR_802_11_PHY_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nstatic process_record_retval\r\nnetmon_process_record(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nnetmon_t *netmon = (netmon_t *)wth->priv;\r\nint hdr_size = 0;\r\nunion {\r\nstruct netmonrec_1_x_hdr hdr_1_x;\r\nstruct netmonrec_2_x_hdr hdr_2_x;\r\n} hdr;\r\ngint64 delta = 0;\r\ngint64 t;\r\ntime_t secs;\r\nint nsecs;\r\nguint32 packet_size = 0;\r\nguint32 orig_size = 0;\r\nint trlr_size;\r\nunion {\r\nstruct netmonrec_2_1_trlr trlr_2_1;\r\nstruct netmonrec_2_2_trlr trlr_2_2;\r\nstruct netmonrec_2_3_trlr trlr_2_3;\r\n} trlr;\r\nguint16 network;\r\nint pkt_encap;\r\nswitch (netmon->version_major) {\r\ncase 1:\r\nhdr_size = sizeof (struct netmonrec_1_x_hdr);\r\nbreak;\r\ncase 2:\r\nhdr_size = sizeof (struct netmonrec_2_x_hdr);\r\nbreak;\r\n}\r\nif (!wtap_read_bytes_or_eof(fh, &hdr, hdr_size, err, err_info))\r\nreturn FAILURE;\r\nswitch (netmon->version_major) {\r\ncase 1:\r\norig_size = pletoh16(&hdr.hdr_1_x.orig_len);\r\npacket_size = pletoh16(&hdr.hdr_1_x.incl_len);\r\nbreak;\r\ncase 2:\r\norig_size = pletoh32(&hdr.hdr_2_x.orig_len);\r\npacket_size = pletoh32(&hdr.hdr_2_x.incl_len);\r\nbreak;\r\n}\r\nif (packet_size > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("netmon: File has %u-byte packet, bigger than maximum of %u",\r\npacket_size, WTAP_MAX_PACKET_SIZE);\r\nreturn FAILURE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_ATM_PDUS:\r\nif (packet_size < sizeof (struct netmon_atm_hdr)) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("netmon: ATM file has a %u-byte packet, too small to have even an ATM pseudo-header",\r\npacket_size);\r\nreturn FAILURE;\r\n}\r\nif (!netmon_read_atm_pseudoheader(fh, &phdr->pseudo_header,\r\nerr, err_info))\r\nreturn FAILURE;\r\norig_size -= (guint)sizeof (struct netmon_atm_hdr);\r\npacket_size -= (guint)sizeof (struct netmon_atm_hdr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (netmon->version_major) {\r\ncase 1:\r\ndelta = ((gint64)pletoh32(&hdr.hdr_1_x.ts_delta))*1000000;\r\nbreak;\r\ncase 2:\r\ndelta = pletoh64(&hdr.hdr_2_x.ts_delta)*10;\r\ndelta *= 100;\r\nbreak;\r\n}\r\nsecs = 0;\r\nt = netmon->start_nsecs + delta;\r\nwhile (t < 0) {\r\nt += 1000000000;\r\nsecs--;\r\n}\r\nsecs += (time_t)(t/1000000000);\r\nnsecs = (int)(t%1000000000);\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nphdr->ts.secs = netmon->start_secs + secs;\r\nphdr->ts.nsecs = nsecs;\r\nphdr->caplen = packet_size;\r\nphdr->len = orig_size;\r\nif (!wtap_read_packet_bytes(fh, buf, phdr->caplen, err, err_info))\r\nreturn FAILURE;\r\nif ((netmon->version_major == 2 && netmon->version_minor >= 1) ||\r\nnetmon->version_major > 2) {\r\nif (netmon->version_major > 2) {\r\ntrlr_size = (int)sizeof (struct netmonrec_2_3_trlr);\r\n} else {\r\nswitch (netmon->version_minor) {\r\ncase 1:\r\ntrlr_size = (int)sizeof (struct netmonrec_2_1_trlr);\r\nbreak;\r\ncase 2:\r\ntrlr_size = (int)sizeof (struct netmonrec_2_2_trlr);\r\nbreak;\r\ndefault:\r\ntrlr_size = (int)sizeof (struct netmonrec_2_3_trlr);\r\nbreak;\r\n}\r\n}\r\nif (!wtap_read_bytes(fh, &trlr, trlr_size, err, err_info))\r\nreturn FAILURE;\r\nnetwork = pletoh16(trlr.trlr_2_1.network);\r\nif ((network & 0xF000) == NETMON_NET_PCAP_BASE) {\r\nnetwork &= 0x0FFF;\r\npkt_encap = wtap_pcap_encap_to_wtap_encap(network);\r\nif (pkt_encap == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netmon: converted pcap network type %u unknown or unsupported",\r\nnetwork);\r\nreturn FAILURE;\r\n}\r\n} else if (network < NUM_NETMON_ENCAPS) {\r\npkt_encap = netmon_encap[network];\r\nif (pkt_encap == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netmon: network type %u unknown or unsupported",\r\nnetwork);\r\nreturn FAILURE;\r\n}\r\n} else {\r\nswitch (network) {\r\ncase NETMON_NET_NETEVENT:\r\nreturn RETRY;\r\ncase NETMON_NET_NETWORK_INFO_EX:\r\nreturn RETRY;\r\ncase NETMON_NET_PAYLOAD_HEADER:\r\nreturn RETRY;\r\ncase NETMON_NET_NETWORK_INFO:\r\nreturn RETRY;\r\ncase NETMON_NET_DNS_CACHE:\r\nreturn RETRY;\r\ncase NETMON_NET_NETMON_FILTER:\r\nreturn RETRY;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("netmon: network type %u unknown or unsupported",\r\nnetwork);\r\nreturn FAILURE;\r\n}\r\n}\r\nphdr->pkt_encap = pkt_encap;\r\nif (netmon->version_major > 2 || netmon->version_minor > 2) {\r\nguint64 d;\r\nd = pletoh64(trlr.trlr_2_3.utc_timestamp);\r\nif (!filetime_to_nstime(&phdr->ts, d)) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("netmon: time stamp outside supported range");\r\nreturn FAILURE;\r\n}\r\n}\r\n}\r\nnetmon_set_pseudo_header_info(phdr, buf);\r\nreturn SUCCESS;\r\n}\r\nstatic gboolean netmon_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\nnetmon_t *netmon = (netmon_t *)wth->priv;\r\ngint64 rec_offset;\r\nfor (;;) {\r\nif (netmon->current_frame >= netmon->frame_table_size) {\r\ng_free(netmon->frame_table);\r\nnetmon->frame_table = NULL;\r\n*err = 0;\r\nreturn FALSE;\r\n}\r\nrec_offset = netmon->frame_table[netmon->current_frame];\r\nif (file_tell(wth->fh) != rec_offset) {\r\nif (file_seek(wth->fh, rec_offset, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\n}\r\nnetmon->current_frame++;\r\n*data_offset = file_tell(wth->fh);\r\nswitch (netmon_process_record(wth, wth->fh, &wth->phdr,\r\nwth->frame_buffer, err, err_info)) {\r\ncase RETRY:\r\ncontinue;\r\ncase SUCCESS:\r\nreturn TRUE;\r\ncase FAILURE:\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nstatic gboolean\r\nnetmon_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nswitch (netmon_process_record(wth, wth->random_fh, phdr, buf, err,\r\nerr_info)) {\r\ndefault:\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("netmon: saw metadata in netmon_seek_read");\r\nreturn FALSE;\r\ncase SUCCESS:\r\nreturn TRUE;\r\ncase FAILURE:\r\nreturn FALSE;\r\n}\r\n}\r\nstatic gboolean\r\nnetmon_read_atm_pseudoheader(FILE_T fh, union wtap_pseudo_header *pseudo_header,\r\nint *err, gchar **err_info)\r\n{\r\nstruct netmon_atm_hdr atm_phdr;\r\nguint16 vpi, vci;\r\nif (!wtap_read_bytes(fh, &atm_phdr, sizeof (struct netmon_atm_hdr),\r\nerr, err_info))\r\nreturn FALSE;\r\nvpi = g_ntohs(atm_phdr.vpi);\r\nvci = g_ntohs(atm_phdr.vci);\r\npseudo_header->atm.vpi = vpi;\r\npseudo_header->atm.vci = vci;\r\npseudo_header->atm.flags = 0;\r\npseudo_header->atm.channel = 0;\r\npseudo_header->atm.cells = 0;\r\npseudo_header->atm.aal5t_u2u = 0;\r\npseudo_header->atm.aal5t_len = 0;\r\npseudo_header->atm.aal5t_chksum = 0;\r\nreturn TRUE;\r\n}\r\nstatic void\r\nnetmon_sequential_close(wtap *wth)\r\n{\r\nnetmon_t *netmon = (netmon_t *)wth->priv;\r\nif (netmon->frame_table != NULL) {\r\ng_free(netmon->frame_table);\r\nnetmon->frame_table = NULL;\r\n}\r\n}\r\nint netmon_dump_can_write_encap_1_x(int encap)\r\n{\r\nif (encap < 0 || (unsigned) encap >= NUM_WTAP_ENCAPS || wtap_encap[encap] == -1)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\nint netmon_dump_can_write_encap_2_x(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn 0;\r\nif (encap < 0 || (unsigned) encap >= NUM_WTAP_ENCAPS || wtap_encap[encap] == -1)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\ngboolean netmon_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nnetmon_dump_t *netmon;\r\nif (wtap_dump_file_seek(wdh, CAPTUREFILE_HEADER_SIZE, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nwdh->subtype_write = netmon_dump;\r\nwdh->subtype_finish = netmon_dump_finish;\r\nnetmon = (netmon_dump_t *)g_malloc(sizeof(netmon_dump_t));\r\nwdh->priv = (void *)netmon;\r\nnetmon->frame_table_offset = CAPTUREFILE_HEADER_SIZE;\r\nnetmon->got_first_record_time = FALSE;\r\nnetmon->frame_table = NULL;\r\nnetmon->frame_table_index = 0;\r\nnetmon->frame_table_size = 0;\r\nnetmon->no_more_room = FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean netmon_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nnetmon_dump_t *netmon = (netmon_dump_t *)wdh->priv;\r\nstruct netmonrec_1_x_hdr rec_1_x_hdr;\r\nstruct netmonrec_2_x_hdr rec_2_x_hdr;\r\nvoid *hdrp;\r\nsize_t rec_size;\r\nstruct netmonrec_2_1_trlr rec_2_x_trlr;\r\nsize_t hdr_size;\r\nstruct netmon_atm_hdr atm_hdr;\r\nint atm_hdrsize;\r\ngint64 secs;\r\ngint32 nsecs;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nswitch (wdh->file_type_subtype) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETMON_1_x:\r\nif (phdr->caplen > 65535) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETMON_2_x:\r\nif (phdr->caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNWRITABLE_FILE_TYPE;\r\nreturn FALSE;\r\n}\r\nif (wdh->encap == WTAP_ENCAP_PER_PACKET) {\r\nif (phdr->pkt_encap < 0 ||\r\n(unsigned) phdr->pkt_encap >= NUM_WTAP_ENCAPS ||\r\nwtap_encap[phdr->pkt_encap] == -1) {\r\n*err = WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn FALSE;\r\n}\r\nphtoles(rec_2_x_trlr.network, wtap_encap[phdr->pkt_encap]);\r\n}\r\nif (netmon->no_more_room) {\r\n*err = EFBIG;\r\nreturn FALSE;\r\n}\r\nif (!netmon->got_first_record_time) {\r\nnetmon->first_record_time.secs = phdr->ts.secs;\r\nnetmon->first_record_time.nsecs =\r\n(phdr->ts.nsecs/1000000)*1000000;\r\nnetmon->got_first_record_time = TRUE;\r\n}\r\nif (wdh->encap == WTAP_ENCAP_ATM_PDUS)\r\natm_hdrsize = sizeof (struct netmon_atm_hdr);\r\nelse\r\natm_hdrsize = 0;\r\nsecs = (gint64)(phdr->ts.secs - netmon->first_record_time.secs);\r\nnsecs = phdr->ts.nsecs - netmon->first_record_time.nsecs;\r\nwhile (nsecs < 0) {\r\nnsecs += 1000000000;\r\nsecs--;\r\n}\r\nswitch (wdh->file_type_subtype) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETMON_1_x:\r\nrec_1_x_hdr.ts_delta = GUINT32_TO_LE(secs*1000 + (nsecs + 500000)/1000000);\r\nrec_1_x_hdr.orig_len = GUINT16_TO_LE(phdr->len + atm_hdrsize);\r\nrec_1_x_hdr.incl_len = GUINT16_TO_LE(phdr->caplen + atm_hdrsize);\r\nhdrp = &rec_1_x_hdr;\r\nhdr_size = sizeof rec_1_x_hdr;\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETMON_2_x:\r\nrec_2_x_hdr.ts_delta = GUINT64_TO_LE(secs*1000000 + (nsecs + 500)/1000);\r\nrec_2_x_hdr.orig_len = GUINT32_TO_LE(phdr->len + atm_hdrsize);\r\nrec_2_x_hdr.incl_len = GUINT32_TO_LE(phdr->caplen + atm_hdrsize);\r\nhdrp = &rec_2_x_hdr;\r\nhdr_size = sizeof rec_2_x_hdr;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNWRITABLE_FILE_TYPE;\r\nreturn FALSE;\r\n}\r\nrec_size = 0;\r\nif (!wtap_dump_file_write(wdh, hdrp, hdr_size, err))\r\nreturn FALSE;\r\nrec_size += hdr_size;\r\nif (wdh->encap == WTAP_ENCAP_ATM_PDUS) {\r\nmemset(&atm_hdr.dest, 0, sizeof atm_hdr.dest);\r\nmemset(&atm_hdr.src, 0, sizeof atm_hdr.src);\r\natm_hdr.vpi = g_htons(pseudo_header->atm.vpi);\r\natm_hdr.vci = g_htons(pseudo_header->atm.vci);\r\nif (!wtap_dump_file_write(wdh, &atm_hdr, sizeof atm_hdr, err))\r\nreturn FALSE;\r\nrec_size += sizeof atm_hdr;\r\n}\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\nrec_size += phdr->caplen;\r\nif (wdh->encap == WTAP_ENCAP_PER_PACKET) {\r\nif (!wtap_dump_file_write(wdh, &rec_2_x_trlr,\r\nsizeof rec_2_x_trlr, err))\r\nreturn FALSE;\r\nrec_size += sizeof rec_2_x_trlr;\r\n}\r\nif (netmon->frame_table_size == 0) {\r\nnetmon->frame_table = (guint32 *)g_malloc(1024 * sizeof *netmon->frame_table);\r\nnetmon->frame_table_size = 1024;\r\n} else {\r\nif (netmon->frame_table_index >= netmon->frame_table_size) {\r\nnetmon->frame_table_size *= 2;\r\nnetmon->frame_table = (guint32 *)g_realloc(netmon->frame_table,\r\nnetmon->frame_table_size * sizeof *netmon->frame_table);\r\n}\r\n}\r\nnetmon->frame_table[netmon->frame_table_index] =\r\nGUINT32_TO_LE(netmon->frame_table_offset);\r\nif ((guint64)netmon->frame_table_offset + rec_size > G_MAXUINT32) {\r\nnetmon->no_more_room = TRUE;\r\n}\r\nnetmon->frame_table_index++;\r\nnetmon->frame_table_offset += (guint32) rec_size;\r\nreturn TRUE;\r\n}\r\nstatic gboolean netmon_dump_finish(wtap_dumper *wdh, int *err)\r\n{\r\nnetmon_dump_t *netmon = (netmon_dump_t *)wdh->priv;\r\nsize_t n_to_write;\r\nstruct netmon_hdr file_hdr;\r\nconst char *magicp;\r\nsize_t magic_size;\r\nstruct tm *tm;\r\nn_to_write = netmon->frame_table_index * sizeof *netmon->frame_table;\r\nif (!wtap_dump_file_write(wdh, netmon->frame_table, n_to_write, err))\r\nreturn FALSE;\r\nif (wtap_dump_file_seek(wdh, 0, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nmemset(&file_hdr, '\0', sizeof file_hdr);\r\nswitch (wdh->file_type_subtype) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETMON_1_x:\r\nmagicp = netmon_1_x_magic;\r\nmagic_size = sizeof netmon_1_x_magic;\r\nfile_hdr.ver_major = 1;\r\nfile_hdr.ver_minor = 1;\r\nbreak;\r\ncase WTAP_FILE_TYPE_SUBTYPE_NETMON_2_x:\r\nmagicp = netmon_2_x_magic;\r\nmagic_size = sizeof netmon_2_x_magic;\r\nfile_hdr.ver_major = 2;\r\nfile_hdr.ver_minor =\r\n(wdh->encap == WTAP_ENCAP_PER_PACKET) ? 1 : 0;\r\nbreak;\r\ndefault:\r\nif (err != NULL)\r\n*err = WTAP_ERR_UNWRITABLE_FILE_TYPE;\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, magicp, magic_size, err))\r\nreturn FALSE;\r\nif (wdh->encap == WTAP_ENCAP_PER_PACKET) {\r\nfile_hdr.network = GUINT16_TO_LE(1);\r\n} else\r\nfile_hdr.network = GUINT16_TO_LE(wtap_encap[wdh->encap]);\r\ntm = localtime(&netmon->first_record_time.secs);\r\nif (tm != NULL) {\r\nfile_hdr.ts_year = GUINT16_TO_LE(1900 + tm->tm_year);\r\nfile_hdr.ts_month = GUINT16_TO_LE(tm->tm_mon + 1);\r\nfile_hdr.ts_dow = GUINT16_TO_LE(tm->tm_wday);\r\nfile_hdr.ts_day = GUINT16_TO_LE(tm->tm_mday);\r\nfile_hdr.ts_hour = GUINT16_TO_LE(tm->tm_hour);\r\nfile_hdr.ts_min = GUINT16_TO_LE(tm->tm_min);\r\nfile_hdr.ts_sec = GUINT16_TO_LE(tm->tm_sec);\r\n} else {\r\nfile_hdr.ts_year = GUINT16_TO_LE(1900 + 0);\r\nfile_hdr.ts_month = GUINT16_TO_LE(0 + 1);\r\nfile_hdr.ts_dow = GUINT16_TO_LE(0);\r\nfile_hdr.ts_day = GUINT16_TO_LE(0);\r\nfile_hdr.ts_hour = GUINT16_TO_LE(0);\r\nfile_hdr.ts_min = GUINT16_TO_LE(0);\r\nfile_hdr.ts_sec = GUINT16_TO_LE(0);\r\n}\r\nfile_hdr.ts_msec = GUINT16_TO_LE(netmon->first_record_time.nsecs/1000000);\r\nfile_hdr.frametableoffset = GUINT32_TO_LE(netmon->frame_table_offset);\r\nfile_hdr.frametablelength =\r\nGUINT32_TO_LE(netmon->frame_table_index * sizeof *netmon->frame_table);\r\nif (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}
