static guint\r\nget_nbd_tcp_pdu_len(packet_info *pinfo, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint32 magic, type, packet;\r\nconversation_t *conversation;\r\nnbd_conv_info_t *nbd_info;\r\nnbd_transaction_t *nbd_trans=NULL;\r\nwmem_tree_key_t hkey[3];\r\nguint32 handle[2];\r\nmagic=tvb_get_ntohl(tvb, offset);\r\nswitch(magic){\r\ncase NBD_REQUEST_MAGIC:\r\ntype=tvb_get_ntohl(tvb, offset+4);\r\nswitch(type){\r\ncase NBD_CMD_WRITE:\r\nreturn tvb_get_ntohl(tvb, offset+24)+28;\r\ndefault:\r\nreturn 28;\r\n}\r\ncase NBD_RESPONSE_MAGIC:\r\nconversation = find_conversation(pinfo->num,\r\n&pinfo->src, &pinfo->dst,\r\npinfo->ptype,\r\npinfo->srcport, pinfo->destport, 0);\r\nif (conversation == NULL) {\r\nreturn tvb_captured_length(tvb);\r\n}\r\nnbd_info = (nbd_conv_info_t *)conversation_get_proto_data(conversation, proto_nbd);\r\nif (!nbd_info) {\r\nreturn tvb_captured_length(tvb);\r\n}\r\nif(!pinfo->fd->flags.visited){\r\nhandle[0]=tvb_get_ntohl(tvb, offset+8);\r\nhandle[1]=tvb_get_ntohl(tvb, offset+12);\r\nhkey[0].length=2;\r\nhkey[0].key=handle;\r\nhkey[1].length=0;\r\nnbd_trans=(nbd_transaction_t *)wmem_tree_lookup32_array(nbd_info->unacked_pdus, hkey);\r\nif(!nbd_trans){\r\nreturn tvb_captured_length(tvb);\r\n}\r\n} else {\r\nhandle[0]=tvb_get_ntohl(tvb, offset+8);\r\nhandle[1]=tvb_get_ntohl(tvb, offset+12);\r\npacket=pinfo->num;\r\nhkey[0].length=1;\r\nhkey[0].key=&packet;\r\nhkey[1].length=2;\r\nhkey[1].key=handle;\r\nhkey[2].length=0;\r\nnbd_trans=(nbd_transaction_t *)wmem_tree_lookup32_array(nbd_info->acked_pdus, hkey);\r\nif(!nbd_trans){\r\nreturn tvb_captured_length(tvb);\r\n}\r\n}\r\nif(nbd_trans->type==NBD_CMD_READ){\r\nreturn 16+nbd_trans->datalen;\r\n} else {\r\nreturn 16;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ndissect_nbd_tcp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\r\n{\r\nguint32 magic, error, packet;\r\nguint32 handle[2];\r\nguint64 from;\r\nint offset=0;\r\nproto_tree *tree=NULL;\r\nproto_item *item=NULL;\r\nconversation_t *conversation;\r\nnbd_conv_info_t *nbd_info;\r\nnbd_transaction_t *nbd_trans=NULL;\r\nwmem_tree_key_t hkey[3];\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NBD");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nitem = proto_tree_add_item(parent_tree, proto_nbd, tvb, 0, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_nbd);\r\nmagic=tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_nbd_magic, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nswitch(magic){\r\ncase NBD_REQUEST_MAGIC:\r\ncase NBD_RESPONSE_MAGIC:\r\nhandle[0]=tvb_get_ntohl(tvb, offset+4);\r\nhandle[1]=tvb_get_ntohl(tvb, offset+8);\r\nbreak;\r\ndefault:\r\nreturn 4;\r\n}\r\nconversation = find_or_create_conversation(pinfo);\r\nnbd_info = (nbd_conv_info_t *)conversation_get_proto_data(conversation, proto_nbd);\r\nif (!nbd_info) {\r\nnbd_info = wmem_new(wmem_file_scope(), nbd_conv_info_t);\r\nnbd_info->unacked_pdus = wmem_tree_new(wmem_file_scope());\r\nnbd_info->acked_pdus = wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(conversation, proto_nbd, nbd_info);\r\n}\r\nif(!pinfo->fd->flags.visited){\r\nif(magic==NBD_REQUEST_MAGIC){\r\nnbd_trans=wmem_new(wmem_file_scope(), nbd_transaction_t);\r\nnbd_trans->req_frame=pinfo->num;\r\nnbd_trans->rep_frame=0;\r\nnbd_trans->req_time=pinfo->abs_ts;\r\nnbd_trans->type=tvb_get_ntohl(tvb, offset);\r\nnbd_trans->datalen=tvb_get_ntohl(tvb, offset+20);\r\nhkey[0].length=2;\r\nhkey[0].key=handle;\r\nhkey[1].length=0;\r\nwmem_tree_insert32_array(nbd_info->unacked_pdus, hkey, (void *)nbd_trans);\r\n} else if(magic==NBD_RESPONSE_MAGIC){\r\nhkey[0].length=2;\r\nhkey[0].key=handle;\r\nhkey[1].length=0;\r\nnbd_trans=(nbd_transaction_t *)wmem_tree_lookup32_array(nbd_info->unacked_pdus, hkey);\r\nif(nbd_trans){\r\nnbd_trans->rep_frame=pinfo->num;\r\nhkey[0].length=1;\r\nhkey[0].key=&nbd_trans->rep_frame;\r\nhkey[1].length=2;\r\nhkey[1].key=handle;\r\nhkey[2].length=0;\r\nwmem_tree_insert32_array(nbd_info->acked_pdus, hkey, (void *)nbd_trans);\r\nhkey[0].length=1;\r\nhkey[0].key=&nbd_trans->req_frame;\r\nhkey[1].length=2;\r\nhkey[1].key=handle;\r\nhkey[2].length=0;\r\nwmem_tree_insert32_array(nbd_info->acked_pdus, hkey, (void *)nbd_trans);\r\n}\r\n}\r\n} else {\r\npacket=pinfo->num;\r\nhkey[0].length=1;\r\nhkey[0].key=&packet;\r\nhkey[1].length=2;\r\nhkey[1].key=handle;\r\nhkey[2].length=0;\r\nnbd_trans=(nbd_transaction_t *)wmem_tree_lookup32_array(nbd_info->acked_pdus, hkey);\r\n}\r\nif( (magic==NBD_RESPONSE_MAGIC)\r\n&& (nbd_trans)\r\n&& (pinfo->num<nbd_trans->req_frame) ){\r\nnbd_trans=NULL;\r\n}\r\nif(!nbd_trans){\r\nnbd_trans=wmem_new(wmem_packet_scope(), nbd_transaction_t);\r\nnbd_trans->req_frame=0;\r\nnbd_trans->rep_frame=0;\r\nnbd_trans->req_time=pinfo->abs_ts;\r\nnbd_trans->type=0xff;\r\nnbd_trans->datalen=0;\r\n}\r\nif(magic==NBD_REQUEST_MAGIC){\r\nif(nbd_trans->rep_frame){\r\nproto_item *it;\r\nit=proto_tree_add_uint(tree, hf_nbd_response_in, tvb, 0, 0, nbd_trans->rep_frame);\r\nPROTO_ITEM_SET_GENERATED(it);\r\n}\r\n} else if(magic==NBD_RESPONSE_MAGIC){\r\nif(nbd_trans->req_frame){\r\nproto_item *it;\r\nnstime_t ns;\r\nit=proto_tree_add_uint(tree, hf_nbd_response_to, tvb, 0, 0, nbd_trans->req_frame);\r\nPROTO_ITEM_SET_GENERATED(it);\r\nnstime_delta(&ns, &pinfo->abs_ts, &nbd_trans->req_time);\r\nit=proto_tree_add_time(tree, hf_nbd_time, tvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED(it);\r\n}\r\n}\r\nswitch(magic){\r\ncase NBD_REQUEST_MAGIC:\r\nproto_tree_add_item(tree, hf_nbd_type, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_nbd_handle, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset+=8;\r\nfrom=tvb_get_ntoh64(tvb, offset);\r\nproto_tree_add_item(tree, hf_nbd_from, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset+=8;\r\nproto_tree_add_item(tree, hf_nbd_len, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nswitch(nbd_trans->type){\r\ncase NBD_CMD_WRITE:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Write Request Offset:0x%" G_GINT64_MODIFIER "x Length:%d", from, nbd_trans->datalen);\r\nbreak;\r\ncase NBD_CMD_READ:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Read Request Offset:0x%" G_GINT64_MODIFIER "x Length:%d", from, nbd_trans->datalen);\r\nbreak;\r\ncase NBD_CMD_DISC:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Disconnect Request");\r\nbreak;\r\n}\r\nif(nbd_trans->type==NBD_CMD_WRITE){\r\nproto_tree_add_item(tree, hf_nbd_data, tvb, offset, nbd_trans->datalen, ENC_NA);\r\n}\r\nbreak;\r\ncase NBD_RESPONSE_MAGIC:\r\nitem=proto_tree_add_uint(tree, hf_nbd_type, tvb, 0, 0, nbd_trans->type);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nerror=tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_nbd_error, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(tree, hf_nbd_handle, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset+=8;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s Response Error:%d", (nbd_trans->type==NBD_CMD_WRITE)?"Write":"Read", error);\r\nif(nbd_trans->type==NBD_CMD_READ){\r\nproto_tree_add_item(tree, hf_nbd_data, tvb, offset, nbd_trans->datalen, ENC_NA);\r\n}\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_nbd_tcp_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nguint32 magic, type;\r\nif(tvb_captured_length(tvb)<4){\r\nreturn FALSE;\r\n}\r\nmagic=tvb_get_ntohl(tvb, 0);\r\nswitch(magic){\r\ncase NBD_REQUEST_MAGIC:\r\nif(tvb_captured_length(tvb)<28){\r\nreturn FALSE;\r\n}\r\ntype=tvb_get_ntohl(tvb, 4);\r\nswitch(type){\r\ncase NBD_CMD_READ:\r\ncase NBD_CMD_WRITE:\r\ncase NBD_CMD_DISC:\r\nbreak;\r\ndefault:\r\nreturn FALSE;\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, tree, nbd_desegment, 28, get_nbd_tcp_pdu_len, dissect_nbd_tcp_pdu, data);\r\nreturn TRUE;\r\ncase NBD_RESPONSE_MAGIC:\r\nif(tvb_captured_length(tvb)<16){\r\nreturn FALSE;\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, tree, nbd_desegment, 16, get_nbd_tcp_pdu_len, dissect_nbd_tcp_pdu, data);\r\nreturn TRUE;\r\ndefault:\r\nbreak;\r\n}\r\nreturn FALSE;\r\n}\r\nvoid proto_register_nbd(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_nbd_magic,\r\n{ "Magic", "nbd.magic", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbd_type,\r\n{ "Type", "nbd.type", FT_UINT32, BASE_DEC,\r\nVALS(nbd_type_vals), 0x0, NULL, HFILL }},\r\n{ &hf_nbd_error,\r\n{ "Error", "nbd.error", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbd_len,\r\n{ "Length", "nbd.len", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbd_handle,\r\n{ "Handle", "nbd.handle", FT_UINT64, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbd_from,\r\n{ "From", "nbd.from", FT_UINT64, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbd_response_in,\r\n{ "Response In", "nbd.response_in", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "The response to this NBD request is in this frame", HFILL }},\r\n{ &hf_nbd_response_to,\r\n{ "Request In", "nbd.response_to", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "This is a response to the NBD request in this frame", HFILL }},\r\n{ &hf_nbd_time,\r\n{ "Time", "nbd.time", FT_RELATIVE_TIME, BASE_NONE,\r\nNULL, 0x0, "The time between the Call and the Reply", HFILL }},\r\n{ &hf_nbd_data,\r\n{ "Data", "nbd.data", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_nbd,\r\n};\r\nmodule_t *nbd_module;\r\nproto_nbd = proto_register_protocol("Network Block Device",\r\n"NBD", "nbd");\r\nproto_register_field_array(proto_nbd, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nnbd_module = prefs_register_protocol(proto_nbd, NULL);\r\nprefs_register_bool_preference(nbd_module, "desegment_nbd_messages",\r\n"Reassemble NBD messages spanning multiple TCP segments",\r\n"Whether the NBD dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings",\r\n&nbd_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_nbd(void)\r\n{\r\nheur_dissector_add("tcp", dissect_nbd_tcp_heur, "NBD over TCP", "nbd_tcp", proto_nbd, HEURISTIC_ENABLE);\r\n}
