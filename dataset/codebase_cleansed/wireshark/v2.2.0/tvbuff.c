tvbuff_t *\r\ntvb_new(const struct tvb_ops *ops)\r\n{\r\ntvbuff_t *tvb;\r\ngsize size = ops->tvb_size;\r\ng_assert(size >= sizeof(*tvb));\r\ntvb = (tvbuff_t *) g_slice_alloc(size);\r\ntvb->next = NULL;\r\ntvb->ops = ops;\r\ntvb->initialized = FALSE;\r\ntvb->flags = 0;\r\ntvb->length = 0;\r\ntvb->reported_length = 0;\r\ntvb->real_data = NULL;\r\ntvb->raw_offset = -1;\r\ntvb->ds_tvb = NULL;\r\nreturn tvb;\r\n}\r\nstatic void\r\ntvb_free_internal(tvbuff_t *tvb)\r\n{\r\ngsize size;\r\nDISSECTOR_ASSERT(tvb);\r\nif (tvb->ops->tvb_free)\r\ntvb->ops->tvb_free(tvb);\r\nsize = tvb->ops->tvb_size;\r\ng_slice_free1(size, tvb);\r\n}\r\nvoid\r\ntvb_free(tvbuff_t *tvb)\r\n{\r\ntvb_free_chain(tvb);\r\n}\r\nvoid\r\ntvb_free_chain(tvbuff_t *tvb)\r\n{\r\ntvbuff_t *next_tvb;\r\nDISSECTOR_ASSERT(tvb);\r\nwhile (tvb) {\r\nnext_tvb = tvb->next;\r\ntvb_free_internal(tvb);\r\ntvb = next_tvb;\r\n}\r\n}\r\ntvbuff_t *\r\ntvb_new_chain(tvbuff_t *parent, tvbuff_t *backing)\r\n{\r\ntvbuff_t *tvb = tvb_new_proxy(backing);\r\ntvb_add_to_chain(parent, tvb);\r\nreturn tvb;\r\n}\r\nvoid\r\ntvb_add_to_chain(tvbuff_t *parent, tvbuff_t *child)\r\n{\r\ntvbuff_t *tmp = child;\r\nDISSECTOR_ASSERT(parent);\r\nDISSECTOR_ASSERT(child);\r\nwhile (child) {\r\ntmp = child;\r\nchild = child->next;\r\ntmp->next = parent->next;\r\nparent->next = tmp;\r\n}\r\n}\r\nstatic inline int\r\nvalidate_offset(const tvbuff_t *tvb, const guint abs_offset)\r\n{\r\nif (G_LIKELY(abs_offset <= tvb->length))\r\nreturn 0;\r\nelse if (abs_offset <= tvb->reported_length)\r\nreturn BoundsError;\r\nelse if (tvb->flags & TVBUFF_FRAGMENT)\r\nreturn FragmentBoundsError;\r\nelse\r\nreturn ReportedBoundsError;\r\n}\r\nstatic inline int\r\ncompute_offset(const tvbuff_t *tvb, const gint offset, guint *offset_ptr)\r\n{\r\nif (offset >= 0) {\r\nif ((guint) offset <= tvb->length) {\r\n*offset_ptr = offset;\r\n} else if ((guint) offset <= tvb->reported_length) {\r\nreturn BoundsError;\r\n} else if (tvb->flags & TVBUFF_FRAGMENT) {\r\nreturn FragmentBoundsError;\r\n} else {\r\nreturn ReportedBoundsError;\r\n}\r\n}\r\nelse {\r\nif ((guint) -offset <= tvb->length) {\r\n*offset_ptr = tvb->length + offset;\r\n} else if ((guint) -offset <= tvb->reported_length) {\r\nreturn BoundsError;\r\n} else if (tvb->flags & TVBUFF_FRAGMENT) {\r\nreturn FragmentBoundsError;\r\n} else {\r\nreturn ReportedBoundsError;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int\r\ncompute_offset_and_remaining(const tvbuff_t *tvb, const gint offset, guint *offset_ptr, guint *rem_len)\r\n{\r\nint exception;\r\nexception = compute_offset(tvb, offset, offset_ptr);\r\nif (!exception)\r\n*rem_len = tvb->length - *offset_ptr;\r\nreturn exception;\r\n}\r\nstatic inline int\r\ncheck_offset_length_no_exception(const tvbuff_t *tvb,\r\nconst gint offset, gint const length_val,\r\nguint *offset_ptr, guint *length_ptr)\r\n{\r\nguint end_offset;\r\nint exception;\r\nDISSECTOR_ASSERT(offset_ptr);\r\nDISSECTOR_ASSERT(length_ptr);\r\nexception = compute_offset(tvb, offset, offset_ptr);\r\nif (exception)\r\nreturn exception;\r\nif (length_val < -1) {\r\nreturn BoundsError;\r\n}\r\nif (length_val == -1)\r\n*length_ptr = tvb->length - *offset_ptr;\r\nelse\r\n*length_ptr = length_val;\r\nend_offset = *offset_ptr + *length_ptr;\r\nif (end_offset < *offset_ptr)\r\nreturn BoundsError;\r\nreturn validate_offset(tvb, end_offset);\r\n}\r\nstatic inline void\r\ncheck_offset_length(const tvbuff_t *tvb,\r\nconst gint offset, gint const length_val,\r\nguint *offset_ptr, guint *length_ptr)\r\n{\r\nint exception;\r\nexception = check_offset_length_no_exception(tvb, offset, length_val, offset_ptr, length_ptr);\r\nif (exception)\r\nTHROW(exception);\r\n}\r\nvoid\r\ntvb_check_offset_length(const tvbuff_t *tvb,\r\nconst gint offset, gint const length_val,\r\nguint *offset_ptr, guint *length_ptr)\r\n{\r\ncheck_offset_length(tvb, offset, length_val, offset_ptr, length_ptr);\r\n}\r\ntvbuff_t *\r\ntvb_new_octet_aligned(tvbuff_t *tvb, guint32 bit_offset, gint32 no_of_bits)\r\n{\r\ntvbuff_t *sub_tvb = NULL;\r\nguint32 byte_offset;\r\ngint32 datalen, i;\r\nguint8 left, right, remaining_bits, *buf;\r\nconst guint8 *data;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nbyte_offset = bit_offset >> 3;\r\nleft = bit_offset % 8;\r\nright = 8 - left;\r\nif (no_of_bits == -1) {\r\ndatalen = _tvb_captured_length_remaining(tvb, byte_offset);\r\nremaining_bits = 0;\r\n} else {\r\ndatalen = no_of_bits >> 3;\r\nremaining_bits = no_of_bits % 8;\r\nif (remaining_bits) {\r\ndatalen++;\r\n}\r\n}\r\nif ((left == 0) && (remaining_bits == 0)) {\r\nreturn tvb_new_subset(tvb, byte_offset, datalen, datalen);\r\n}\r\nDISSECTOR_ASSERT(datalen>0);\r\nif (_tvb_captured_length_remaining(tvb, byte_offset) > datalen) {\r\ndata = ensure_contiguous(tvb, byte_offset, datalen + 1);\r\nbuf = (guint8 *)g_malloc(datalen);\r\nfor (i = 0; i < datalen; i++)\r\nbuf[i] = (data[i] << left) | (data[i+1] >> right);\r\n} else {\r\ndata = ensure_contiguous(tvb, byte_offset, datalen);\r\nbuf = (guint8 *)g_malloc(datalen);\r\nfor (i = 0; i < (datalen-1); i++)\r\nbuf[i] = (data[i] << left) | (data[i+1] >> right);\r\nbuf[datalen-1] = data[datalen-1] << left;\r\n}\r\nbuf[datalen-1] &= left_aligned_bitmask[remaining_bits];\r\nsub_tvb = tvb_new_child_real_data(tvb, buf, datalen, datalen);\r\ntvb_set_free_cb(sub_tvb, g_free);\r\nreturn sub_tvb;\r\n}\r\nstatic tvbuff_t *\r\ntvb_generic_clone_offset_len(tvbuff_t *tvb, guint offset, guint len)\r\n{\r\ntvbuff_t *cloned_tvb;\r\nguint8 *data;\r\nDISSECTOR_ASSERT(tvb_bytes_exist(tvb, offset, len));\r\ndata = (guint8 *) g_malloc(len);\r\ntvb_memcpy(tvb, data, offset, len);\r\ncloned_tvb = tvb_new_real_data(data, len, len);\r\ntvb_set_free_cb(cloned_tvb, g_free);\r\nreturn cloned_tvb;\r\n}\r\ntvbuff_t *\r\ntvb_clone_offset_len(tvbuff_t *tvb, guint offset, guint len)\r\n{\r\nif (tvb->ops->tvb_clone) {\r\ntvbuff_t *cloned_tvb;\r\ncloned_tvb = tvb->ops->tvb_clone(tvb, offset, len);\r\nif (cloned_tvb)\r\nreturn cloned_tvb;\r\n}\r\nreturn tvb_generic_clone_offset_len(tvb, offset, len);\r\n}\r\ntvbuff_t *\r\ntvb_clone(tvbuff_t *tvb)\r\n{\r\nreturn tvb_clone_offset_len(tvb, 0, tvb->length);\r\n}\r\nguint\r\ntvb_captured_length(const tvbuff_t *tvb)\r\n{\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nreturn tvb->length;\r\n}\r\nstatic inline gint\r\n_tvb_captured_length_remaining(const tvbuff_t *tvb, const gint offset)\r\n{\r\nguint abs_offset, rem_length;\r\nint exception;\r\nexception = compute_offset_and_remaining(tvb, offset, &abs_offset, &rem_length);\r\nif (exception)\r\nreturn 0;\r\nreturn rem_length;\r\n}\r\ngint\r\ntvb_captured_length_remaining(const tvbuff_t *tvb, const gint offset)\r\n{\r\nguint abs_offset, rem_length;\r\nint exception;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nexception = compute_offset_and_remaining(tvb, offset, &abs_offset, &rem_length);\r\nif (exception)\r\nreturn 0;\r\nreturn rem_length;\r\n}\r\nguint\r\ntvb_ensure_captured_length_remaining(const tvbuff_t *tvb, const gint offset)\r\n{\r\nguint abs_offset = 0, rem_length = 0;\r\nint exception;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nexception = compute_offset_and_remaining(tvb, offset, &abs_offset, &rem_length);\r\nif (exception)\r\nTHROW(exception);\r\nif (rem_length == 0) {\r\nif (abs_offset >= tvb->reported_length) {\r\nif (tvb->flags & TVBUFF_FRAGMENT) {\r\nTHROW(FragmentBoundsError);\r\n} else {\r\nTHROW(ReportedBoundsError);\r\n}\r\n} else\r\nTHROW(BoundsError);\r\n}\r\nreturn rem_length;\r\n}\r\ngboolean\r\ntvb_bytes_exist(const tvbuff_t *tvb, const gint offset, const gint length)\r\n{\r\nguint abs_offset, abs_length;\r\nint exception;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nexception = check_offset_length_no_exception(tvb, offset, length, &abs_offset, &abs_length);\r\nif (exception)\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nvoid\r\ntvb_ensure_bytes_exist64(const tvbuff_t *tvb, const gint offset, const guint64 length)\r\n{\r\nif (length > G_MAXINT) {\r\nTHROW(ReportedBoundsError);\r\n}\r\ntvb_ensure_bytes_exist(tvb, offset, (gint)length);\r\n}\r\nvoid\r\ntvb_ensure_bytes_exist(const tvbuff_t *tvb, const gint offset, const gint length)\r\n{\r\nguint real_offset, end_offset;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nif (length < 0) {\r\nTHROW(ReportedBoundsError);\r\n}\r\nif (offset >= 0) {\r\nif ((guint) offset <= tvb->length) {\r\nreal_offset = offset;\r\n} else if ((guint) offset <= tvb->reported_length) {\r\nTHROW(BoundsError);\r\n} else if (tvb->flags & TVBUFF_FRAGMENT) {\r\nTHROW(FragmentBoundsError);\r\n} else {\r\nTHROW(ReportedBoundsError);\r\n}\r\n}\r\nelse {\r\nif ((guint) -offset <= tvb->length) {\r\nreal_offset = tvb->length + offset;\r\n} else if ((guint) -offset <= tvb->reported_length) {\r\nTHROW(BoundsError);\r\n} else if (tvb->flags & TVBUFF_FRAGMENT) {\r\nTHROW(FragmentBoundsError);\r\n} else {\r\nTHROW(ReportedBoundsError);\r\n}\r\n}\r\nend_offset = real_offset + length;\r\nif (end_offset < real_offset)\r\nTHROW(BoundsError);\r\nif (G_LIKELY(end_offset <= tvb->length))\r\nreturn;\r\nelse if (end_offset <= tvb->reported_length)\r\nTHROW(BoundsError);\r\nelse if (tvb->flags & TVBUFF_FRAGMENT)\r\nTHROW(FragmentBoundsError);\r\nelse\r\nTHROW(ReportedBoundsError);\r\n}\r\ngboolean\r\ntvb_offset_exists(const tvbuff_t *tvb, const gint offset)\r\n{\r\nguint abs_offset;\r\nint exception;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nexception = compute_offset(tvb, offset, &abs_offset);\r\nif (exception)\r\nreturn FALSE;\r\nif (abs_offset < tvb->length) {\r\nreturn TRUE;\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\n}\r\nguint\r\ntvb_reported_length(const tvbuff_t *tvb)\r\n{\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nreturn tvb->reported_length;\r\n}\r\ngint\r\ntvb_reported_length_remaining(const tvbuff_t *tvb, const gint offset)\r\n{\r\nguint abs_offset;\r\nint exception;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nexception = compute_offset(tvb, offset, &abs_offset);\r\nif (exception)\r\nreturn 0;\r\nif (tvb->reported_length >= abs_offset)\r\nreturn tvb->reported_length - abs_offset;\r\nelse\r\nreturn 0;\r\n}\r\nvoid\r\ntvb_set_reported_length(tvbuff_t *tvb, const guint reported_length)\r\n{\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nif (reported_length > tvb->reported_length)\r\nTHROW(ReportedBoundsError);\r\ntvb->reported_length = reported_length;\r\nif (reported_length < tvb->length)\r\ntvb->length = reported_length;\r\n}\r\nguint\r\ntvb_offset_from_real_beginning_counter(const tvbuff_t *tvb, const guint counter)\r\n{\r\nif (tvb->ops->tvb_offset)\r\nreturn tvb->ops->tvb_offset(tvb, counter);\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nreturn 0;\r\n}\r\nguint\r\ntvb_offset_from_real_beginning(const tvbuff_t *tvb)\r\n{\r\nreturn tvb_offset_from_real_beginning_counter(tvb, 0);\r\n}\r\nstatic inline const guint8*\r\nensure_contiguous_no_exception(tvbuff_t *tvb, const gint offset, const gint length, int *pexception)\r\n{\r\nguint abs_offset = 0, abs_length = 0;\r\nint exception;\r\nexception = check_offset_length_no_exception(tvb, offset, length, &abs_offset, &abs_length);\r\nif (exception) {\r\nif (pexception)\r\n*pexception = exception;\r\nreturn NULL;\r\n}\r\nif (tvb->real_data)\r\nreturn tvb->real_data + abs_offset;\r\nif (tvb->ops->tvb_get_ptr)\r\nreturn tvb->ops->tvb_get_ptr(tvb, abs_offset, abs_length);\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nreturn NULL;\r\n}\r\nstatic inline const guint8*\r\nensure_contiguous(tvbuff_t *tvb, const gint offset, const gint length)\r\n{\r\nint exception = 0;\r\nconst guint8 *p;\r\np = ensure_contiguous_no_exception(tvb, offset, length, &exception);\r\nif (p == NULL) {\r\nDISSECTOR_ASSERT(exception > 0);\r\nTHROW(exception);\r\n}\r\nreturn p;\r\n}\r\nstatic inline const guint8*\r\nfast_ensure_contiguous(tvbuff_t *tvb, const gint offset, const guint length)\r\n{\r\nguint end_offset;\r\nguint u_offset;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nDISSECTOR_ASSERT(length <= 8);\r\nif (offset < 0 || !tvb->real_data) {\r\nreturn ensure_contiguous(tvb, offset, length);\r\n}\r\nu_offset = offset;\r\nend_offset = u_offset + length;\r\nif (end_offset <= tvb->length) {\r\nreturn tvb->real_data + u_offset;\r\n}\r\nif (end_offset > tvb->reported_length) {\r\nif (tvb->flags & TVBUFF_FRAGMENT) {\r\nTHROW(FragmentBoundsError);\r\n} else {\r\nTHROW(ReportedBoundsError);\r\n}\r\n}\r\nTHROW(BoundsError);\r\nreturn NULL;\r\n}\r\nvoid *\r\ntvb_memcpy(tvbuff_t *tvb, void *target, const gint offset, size_t length)\r\n{\r\nguint abs_offset = 0, abs_length = 0;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nDISSECTOR_ASSERT(length <= 0x7FFFFFFF);\r\ncheck_offset_length(tvb, offset, (gint) length, &abs_offset, &abs_length);\r\nif (tvb->real_data) {\r\nreturn memcpy(target, tvb->real_data + abs_offset, abs_length);\r\n}\r\nif (tvb->ops->tvb_memcpy)\r\nreturn tvb->ops->tvb_memcpy(tvb, target, abs_offset, abs_length);\r\nif (length != 0) {\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\n}\r\nreturn NULL;\r\n}\r\nvoid *\r\ntvb_memdup(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, size_t length)\r\n{\r\nguint abs_offset = 0, abs_length = 0;\r\nvoid *duped;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\ncheck_offset_length(tvb, offset, (gint) length, &abs_offset, &abs_length);\r\nduped = wmem_alloc(scope, abs_length);\r\nreturn tvb_memcpy(tvb, duped, abs_offset, abs_length);\r\n}\r\nconst guint8*\r\ntvb_get_ptr(tvbuff_t *tvb, const gint offset, const gint length)\r\n{\r\nreturn ensure_contiguous(tvb, offset, length);\r\n}\r\nguint8\r\ntvb_get_guint8(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, sizeof(guint8));\r\nreturn *ptr;\r\n}\r\nguint16\r\ntvb_get_ntohs(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, sizeof(guint16));\r\nreturn pntoh16(ptr);\r\n}\r\nguint32\r\ntvb_get_ntoh24(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, 3);\r\nreturn pntoh24(ptr);\r\n}\r\nguint32\r\ntvb_get_ntohl(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32));\r\nreturn pntoh32(ptr);\r\n}\r\nguint64\r\ntvb_get_ntoh40(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, 5);\r\nreturn pntoh40(ptr);\r\n}\r\ngint64\r\ntvb_get_ntohi40(tvbuff_t *tvb, const gint offset)\r\n{\r\nguint64 ret;\r\nret = ws_sign_ext64(tvb_get_ntoh40(tvb, offset), 40);\r\nreturn (gint64)ret;\r\n}\r\nguint64\r\ntvb_get_ntoh48(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, 6);\r\nreturn pntoh48(ptr);\r\n}\r\ngint64\r\ntvb_get_ntohi48(tvbuff_t *tvb, const gint offset)\r\n{\r\nguint64 ret;\r\nret = ws_sign_ext64(tvb_get_ntoh48(tvb, offset), 48);\r\nreturn (gint64)ret;\r\n}\r\nguint64\r\ntvb_get_ntoh56(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, 7);\r\nreturn pntoh56(ptr);\r\n}\r\ngint64\r\ntvb_get_ntohi56(tvbuff_t *tvb, const gint offset)\r\n{\r\nguint64 ret;\r\nret = ws_sign_ext64(tvb_get_ntoh56(tvb, offset), 56);\r\nreturn (gint64)ret;\r\n}\r\nguint64\r\ntvb_get_ntoh64(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, sizeof(guint64));\r\nreturn pntoh64(ptr);\r\n}\r\nguint16\r\ntvb_get_guint16(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letohs(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntohs(tvb, offset);\r\n}\r\n}\r\nguint32\r\ntvb_get_guint24(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letoh24(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntoh24(tvb, offset);\r\n}\r\n}\r\nguint32\r\ntvb_get_guint32(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letohl(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntohl(tvb, offset);\r\n}\r\n}\r\nguint64\r\ntvb_get_guint40(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letoh40(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntoh40(tvb, offset);\r\n}\r\n}\r\ngint64\r\ntvb_get_gint40(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letohi40(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntohi40(tvb, offset);\r\n}\r\n}\r\nguint64\r\ntvb_get_guint48(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letoh48(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntoh48(tvb, offset);\r\n}\r\n}\r\ngint64\r\ntvb_get_gint48(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letohi48(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntohi48(tvb, offset);\r\n}\r\n}\r\nguint64\r\ntvb_get_guint56(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letoh56(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntoh56(tvb, offset);\r\n}\r\n}\r\ngint64\r\ntvb_get_gint56(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letohi56(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntohi56(tvb, offset);\r\n}\r\n}\r\nguint64\r\ntvb_get_guint64(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letoh64(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntoh64(tvb, offset);\r\n}\r\n}\r\ngfloat\r\ntvb_get_ieee_float(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letohieee_float(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntohieee_float(tvb, offset);\r\n}\r\n}\r\ngdouble\r\ntvb_get_ieee_double(tvbuff_t *tvb, const gint offset, const guint encoding) {\r\nif (encoding & ENC_LITTLE_ENDIAN) {\r\nreturn tvb_get_letohieee_double(tvb, offset);\r\n} else {\r\nreturn tvb_get_ntohieee_double(tvb, offset);\r\n}\r\n}\r\nstatic int\r\nieee_float_is_zero(const guint32 w)\r\n{\r\nreturn ((w & ~IEEE_SP_SIGN_MASK) == 0);\r\n}\r\nstatic gfloat\r\nget_ieee_float(const guint32 w)\r\n{\r\nlong sign;\r\nlong exponent;\r\nlong mantissa;\r\nsign = w & IEEE_SP_SIGN_MASK;\r\nexponent = w & IEEE_SP_EXPONENT_MASK;\r\nmantissa = w & IEEE_SP_MANTISSA_MASK;\r\nif (ieee_float_is_zero(w)) {\r\nreturn 0.0;\r\n}\r\n#if 0\r\nif (IEEE_SP_INFINITY == exponent) {\r\nreturn (sign? MINUS_INFINITY: PLUS_INFINITY);\r\n}\r\n#endif\r\nexponent = ((exponent >> IEEE_SP_MANTISSA_WIDTH) - IEEE_SP_BIAS) -\r\nIEEE_SP_MANTISSA_WIDTH;\r\nmantissa |= IEEE_SP_IMPLIED_BIT;\r\nif (sign)\r\nreturn -mantissa * pow(2, exponent);\r\nelse\r\nreturn mantissa * pow(2, exponent);\r\n}\r\nstatic int\r\nieee_double_is_zero(const guint64 w)\r\n{\r\nreturn ((w & ~IEEE_SP_SIGN_MASK) == 0);\r\n}\r\nstatic gdouble\r\nget_ieee_double(const guint64 w)\r\n{\r\ngint64 sign;\r\ngint64 exponent;\r\ngint64 mantissa;\r\nsign = w & IEEE_DP_SIGN_MASK;\r\nexponent = w & IEEE_DP_EXPONENT_MASK;\r\nmantissa = w & IEEE_DP_MANTISSA_MASK;\r\nif (ieee_double_is_zero(w)) {\r\nreturn 0.0;\r\n}\r\n#if 0\r\nif (IEEE_DP_INFINITY == exponent) {\r\nreturn (sign? MINUS_INFINITY: PLUS_INFINITY);\r\n}\r\n#endif\r\nexponent = ((exponent >> IEEE_DP_MANTISSA_WIDTH) - IEEE_DP_BIAS) -\r\nIEEE_DP_MANTISSA_WIDTH;\r\nmantissa |= IEEE_DP_IMPLIED_BIT;\r\nif (sign)\r\nreturn -mantissa * pow(2, exponent);\r\nelse\r\nreturn mantissa * pow(2, exponent);\r\n}\r\ngfloat\r\ntvb_get_ntohieee_float(tvbuff_t *tvb, const int offset)\r\n{\r\n#if defined(vax)\r\nreturn get_ieee_float(tvb_get_ntohl(tvb, offset));\r\n#else\r\nunion {\r\ngfloat f;\r\nguint32 w;\r\n} ieee_fp_union;\r\nieee_fp_union.w = tvb_get_ntohl(tvb, offset);\r\nreturn ieee_fp_union.f;\r\n#endif\r\n}\r\ngdouble\r\ntvb_get_ntohieee_double(tvbuff_t *tvb, const int offset)\r\n{\r\n#if defined(vax)\r\nunion {\r\nguint32 w[2];\r\nguint64 dw;\r\n} ieee_fp_union;\r\n#else\r\nunion {\r\ngdouble d;\r\nguint32 w[2];\r\n} ieee_fp_union;\r\n#endif\r\n#ifdef WORDS_BIGENDIAN\r\nieee_fp_union.w[0] = tvb_get_ntohl(tvb, offset);\r\nieee_fp_union.w[1] = tvb_get_ntohl(tvb, offset+4);\r\n#else\r\nieee_fp_union.w[0] = tvb_get_ntohl(tvb, offset+4);\r\nieee_fp_union.w[1] = tvb_get_ntohl(tvb, offset);\r\n#endif\r\n#if defined(vax)\r\nreturn get_ieee_double(ieee_fp_union.dw);\r\n#else\r\nreturn ieee_fp_union.d;\r\n#endif\r\n}\r\nguint16\r\ntvb_get_letohs(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, sizeof(guint16));\r\nreturn pletoh16(ptr);\r\n}\r\nguint32\r\ntvb_get_letoh24(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, 3);\r\nreturn pletoh24(ptr);\r\n}\r\nguint32\r\ntvb_get_letohl(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32));\r\nreturn pletoh32(ptr);\r\n}\r\nguint64\r\ntvb_get_letoh40(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, 5);\r\nreturn pletoh40(ptr);\r\n}\r\ngint64\r\ntvb_get_letohi40(tvbuff_t *tvb, const gint offset)\r\n{\r\nguint64 ret;\r\nret = ws_sign_ext64(tvb_get_letoh40(tvb, offset), 40);\r\nreturn (gint64)ret;\r\n}\r\nguint64\r\ntvb_get_letoh48(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, 6);\r\nreturn pletoh48(ptr);\r\n}\r\ngint64\r\ntvb_get_letohi48(tvbuff_t *tvb, const gint offset)\r\n{\r\nguint64 ret;\r\nret = ws_sign_ext64(tvb_get_letoh48(tvb, offset), 48);\r\nreturn (gint64)ret;\r\n}\r\nguint64\r\ntvb_get_letoh56(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, 7);\r\nreturn pletoh56(ptr);\r\n}\r\ngint64\r\ntvb_get_letohi56(tvbuff_t *tvb, const gint offset)\r\n{\r\nguint64 ret;\r\nret = ws_sign_ext64(tvb_get_letoh56(tvb, offset), 56);\r\nreturn (gint64)ret;\r\n}\r\nguint64\r\ntvb_get_letoh64(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nptr = fast_ensure_contiguous(tvb, offset, sizeof(guint64));\r\nreturn pletoh64(ptr);\r\n}\r\ngfloat\r\ntvb_get_letohieee_float(tvbuff_t *tvb, const int offset)\r\n{\r\n#if defined(vax)\r\nreturn get_ieee_float(tvb_get_letohl(tvb, offset));\r\n#else\r\nunion {\r\ngfloat f;\r\nguint32 w;\r\n} ieee_fp_union;\r\nieee_fp_union.w = tvb_get_letohl(tvb, offset);\r\nreturn ieee_fp_union.f;\r\n#endif\r\n}\r\ngdouble\r\ntvb_get_letohieee_double(tvbuff_t *tvb, const int offset)\r\n{\r\n#if defined(vax)\r\nunion {\r\nguint32 w[2];\r\nguint64 dw;\r\n} ieee_fp_union;\r\n#else\r\nunion {\r\ngdouble d;\r\nguint32 w[2];\r\n} ieee_fp_union;\r\n#endif\r\n#ifdef WORDS_BIGENDIAN\r\nieee_fp_union.w[0] = tvb_get_letohl(tvb, offset+4);\r\nieee_fp_union.w[1] = tvb_get_letohl(tvb, offset);\r\n#else\r\nieee_fp_union.w[0] = tvb_get_letohl(tvb, offset);\r\nieee_fp_union.w[1] = tvb_get_letohl(tvb, offset+4);\r\n#endif\r\n#if defined(vax)\r\nreturn get_ieee_double(ieee_fp_union.dw);\r\n#else\r\nreturn ieee_fp_union.d;\r\n#endif\r\n}\r\nstatic inline void\r\nvalidate_single_byte_ascii_encoding(const guint encoding)\r\n{\r\nconst guint enc = encoding & ~ENC_STR_MASK;\r\nswitch (enc) {\r\ncase ENC_UTF_16:\r\ncase ENC_UCS_2:\r\ncase ENC_UCS_4:\r\ncase ENC_3GPP_TS_23_038_7BITS:\r\ncase ENC_EBCDIC:\r\nREPORT_DISSECTOR_BUG("Invalid string encoding type passed to tvb_get_string_XXX");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (enc == 0)\r\nREPORT_DISSECTOR_BUG("No string encoding type passed to tvb_get_string_XXX");\r\n}\r\nGByteArray*\r\ntvb_get_string_bytes(tvbuff_t *tvb, const gint offset, const gint length,\r\nconst guint encoding, GByteArray *bytes, gint *endoff)\r\n{\r\nconst gchar *ptr = (gchar*) tvb_get_raw_string(wmem_packet_scope(), tvb, offset, length);\r\nconst gchar *begin = ptr;\r\nconst gchar *end = NULL;\r\nGByteArray *retval = NULL;\r\nerrno = EDOM;\r\nvalidate_single_byte_ascii_encoding(encoding);\r\nif (endoff) *endoff = 0;\r\nwhile (*begin == ' ') begin++;\r\nif (*begin && bytes) {\r\nif (hex_str_to_bytes_encoding(begin, bytes, &end, encoding, FALSE)) {\r\nif (bytes->len > 0) {\r\nif (endoff) *endoff = offset + (gint)(end - ptr);\r\nerrno = 0;\r\nretval = bytes;\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nnstime_t*\r\ntvb_get_string_time(tvbuff_t *tvb, const gint offset, const gint length,\r\nconst guint encoding, nstime_t *ns, gint *endoff)\r\n{\r\nconst gchar *begin = (gchar*) tvb_get_raw_string(wmem_packet_scope(), tvb, offset, length);\r\nconst gchar *ptr = begin;\r\nconst gchar *end = NULL;\r\nstruct tm tm;\r\nnstime_t* retval = NULL;\r\nchar sign = '+';\r\nint off_hr = 0;\r\nint off_min = 0;\r\nint num_chars = 0;\r\ngboolean matched = FALSE;\r\nerrno = EDOM;\r\nvalidate_single_byte_ascii_encoding(encoding);\r\nDISSECTOR_ASSERT(ns);\r\nmemset(&tm, 0, sizeof(tm));\r\ntm.tm_isdst = -1;\r\nns->secs = 0;\r\nns->nsecs = 0;\r\nwhile (*ptr == ' ') ptr++;\r\nif (*ptr) {\r\nif ((encoding & ENC_ISO_8601_DATE_TIME) == ENC_ISO_8601_DATE_TIME) {\r\nif (sscanf(ptr, "%d-%d-%d%*c%d:%d:%d%c%d:%d%n",\r\n&tm.tm_year,\r\n&tm.tm_mon,\r\n&tm.tm_mday,\r\n&tm.tm_hour,\r\n&tm.tm_min,\r\n&tm.tm_sec,\r\n&sign,\r\n&off_hr,\r\n&off_min,\r\n&num_chars) >= 9)\r\n{\r\nmatched = TRUE;\r\n}\r\nelse if (sscanf(ptr, "%d-%d-%d%*c%d:%d%c%d:%d%n",\r\n&tm.tm_year,\r\n&tm.tm_mon,\r\n&tm.tm_mday,\r\n&tm.tm_hour,\r\n&tm.tm_min,\r\n&sign,\r\n&off_hr,\r\n&off_min,\r\n&num_chars) >= 8)\r\n{\r\nmatched = TRUE;\r\n}\r\nelse if (sscanf(ptr, "%d-%d-%d%*c%d:%d:%dZ%n",\r\n&tm.tm_year,\r\n&tm.tm_mon,\r\n&tm.tm_mday,\r\n&tm.tm_hour,\r\n&tm.tm_min,\r\n&tm.tm_sec,\r\n&num_chars) >= 6)\r\n{\r\nmatched = TRUE;\r\noff_hr = 0;\r\noff_min = 0;\r\n}\r\nelse if (sscanf(ptr, "%d-%d-%d%*c%d:%dZ%n",\r\n&tm.tm_year,\r\n&tm.tm_mon,\r\n&tm.tm_mday,\r\n&tm.tm_hour,\r\n&tm.tm_min,\r\n&num_chars) >= 5)\r\n{\r\nmatched = TRUE;\r\noff_hr = 0;\r\noff_min = 0;\r\n}\r\nif (matched) {\r\nerrno = 0;\r\nend = ptr + num_chars;\r\ntm.tm_mon--;\r\nif (tm.tm_year > 1900) tm.tm_year -= 1900;\r\nif (sign == '-') off_hr = -off_hr;\r\n}\r\n}\r\nelse if (encoding & ENC_ISO_8601_DATE) {\r\nif (sscanf(ptr, "%d-%d-%d%n",\r\n&tm.tm_year,\r\n&tm.tm_mon,\r\n&tm.tm_mday,\r\n&num_chars) >= 3)\r\n{\r\nerrno = 0;\r\nend = ptr + num_chars;\r\ntm.tm_mon--;\r\nif (tm.tm_year > 1900) tm.tm_year -= 1900;\r\n}\r\n}\r\nelse if (encoding & ENC_ISO_8601_TIME) {\r\nif (sscanf(ptr, "%d:%d:%d%n",\r\n&tm.tm_hour,\r\n&tm.tm_min,\r\n&tm.tm_sec,\r\n&num_chars) >= 2)\r\n{\r\ntime_t time_now = time(NULL);\r\nstruct tm *tm_now = gmtime(&time_now);\r\ntm.tm_year = tm_now->tm_year;\r\ntm.tm_mon = tm_now->tm_mon;\r\ntm.tm_mday = tm_now->tm_mday;\r\nend = ptr + num_chars;\r\nerrno = 0;\r\n}\r\n}\r\nelse if (encoding & ENC_RFC_822 || encoding & ENC_RFC_1123) {\r\nif (encoding & ENC_RFC_822) {\r\nend = strptime(ptr, "%a, %d %b %y %H:%M:%S", &tm);\r\nif (!end) end = strptime(ptr, "%a, %d %b %y %H:%M", &tm);\r\nif (!end) end = strptime(ptr, "%d %b %y %H:%M:%S", &tm);\r\nif (!end) end = strptime(ptr, "%d %b %y %H:%M", &tm);\r\n}\r\nelse if (encoding & ENC_RFC_1123) {\r\nend = strptime(ptr, "%a, %d %b %Y %H:%M:%S", &tm);\r\nif (!end) end = strptime(ptr, "%a, %d %b %Y %H:%M", &tm);\r\nif (!end) end = strptime(ptr, "%d %b %Y %H:%M:%S", &tm);\r\nif (!end) end = strptime(ptr, "%d %b %Y %H:%M", &tm);\r\n}\r\nif (end) {\r\nerrno = 0;\r\nif (*end == ' ') end++;\r\nif (g_ascii_strncasecmp(end, "UT", 2) == 0)\r\n{\r\nend += 2;\r\n}\r\nelse if (g_ascii_strncasecmp(end, "GMT", 3) == 0)\r\n{\r\nend += 3;\r\n}\r\nelse if (sscanf(end, "%c%2d%2d%n",\r\n&sign,\r\n&off_hr,\r\n&off_min,\r\n&num_chars) < 3)\r\n{\r\nerrno = ERANGE;\r\n}\r\nif (sign == '-') off_hr = -off_hr;\r\n}\r\n}\r\n}\r\nif (errno == 0) {\r\nns->secs = mktime_utc (&tm);\r\nif (off_hr > 0)\r\nns->secs += (off_hr * 3600) + (off_min * 60);\r\nelse if (off_hr < 0)\r\nns->secs -= ((-off_hr) * 3600) + (off_min * 60);\r\nretval = ns;\r\nif (endoff)\r\n*endoff = (gint)(offset + (end - begin));\r\n}\r\nreturn retval;\r\n}\r\nguint32\r\ntvb_get_ipv4(tvbuff_t *tvb, const gint offset)\r\n{\r\nconst guint8 *ptr;\r\nguint32 addr;\r\nptr = fast_ensure_contiguous(tvb, offset, sizeof(guint32));\r\nmemcpy(&addr, ptr, sizeof addr);\r\nreturn addr;\r\n}\r\nvoid\r\ntvb_get_ipv6(tvbuff_t *tvb, const gint offset, struct e_in6_addr *addr)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous(tvb, offset, sizeof(*addr));\r\nmemcpy(addr, ptr, sizeof *addr);\r\n}\r\nvoid\r\ntvb_get_ntohguid(tvbuff_t *tvb, const gint offset, e_guid_t *guid)\r\n{\r\nconst guint8 *ptr = ensure_contiguous(tvb, offset, GUID_LEN);\r\nguid->data1 = pntoh32(ptr + 0);\r\nguid->data2 = pntoh16(ptr + 4);\r\nguid->data3 = pntoh16(ptr + 6);\r\nmemcpy(guid->data4, ptr + 8, sizeof guid->data4);\r\n}\r\nvoid\r\ntvb_get_letohguid(tvbuff_t *tvb, const gint offset, e_guid_t *guid)\r\n{\r\nconst guint8 *ptr = ensure_contiguous(tvb, offset, GUID_LEN);\r\nguid->data1 = pletoh32(ptr + 0);\r\nguid->data2 = pletoh16(ptr + 4);\r\nguid->data3 = pletoh16(ptr + 6);\r\nmemcpy(guid->data4, ptr + 8, sizeof guid->data4);\r\n}\r\nvoid\r\ntvb_get_guid(tvbuff_t *tvb, const gint offset, e_guid_t *guid, const guint encoding)\r\n{\r\nif (encoding) {\r\ntvb_get_letohguid(tvb, offset, guid);\r\n} else {\r\ntvb_get_ntohguid(tvb, offset, guid);\r\n}\r\n}\r\nguint8\r\ntvb_get_bits8(tvbuff_t *tvb, guint bit_offset, const gint no_of_bits)\r\n{\r\nreturn (guint8)_tvb_get_bits64(tvb, bit_offset, no_of_bits);\r\n}\r\nguint16\r\ntvb_get_bits16(tvbuff_t *tvb, guint bit_offset, const gint no_of_bits,const guint encoding _U_)\r\n{\r\nreturn (guint16)_tvb_get_bits64(tvb, bit_offset, no_of_bits);\r\n}\r\nguint32\r\ntvb_get_bits32(tvbuff_t *tvb, guint bit_offset, const gint no_of_bits, const guint encoding _U_)\r\n{\r\nreturn (guint32)_tvb_get_bits64(tvb, bit_offset, no_of_bits);\r\n}\r\nguint64\r\ntvb_get_bits64(tvbuff_t *tvb, guint bit_offset, const gint no_of_bits, const guint encoding _U_)\r\n{\r\nreturn _tvb_get_bits64(tvb, bit_offset, no_of_bits);\r\n}\r\nstatic guint64\r\n_tvb_get_bits64(tvbuff_t *tvb, guint bit_offset, const gint total_no_of_bits)\r\n{\r\nguint64 value;\r\nguint octet_offset = bit_offset >> 3;\r\nguint8 required_bits_in_first_octet = 8 - (bit_offset % 8);\r\nif(required_bits_in_first_octet > total_no_of_bits)\r\n{\r\nguint8 right_shift = required_bits_in_first_octet - total_no_of_bits;\r\nvalue = (tvb_get_guint8(tvb, octet_offset) >> right_shift) & bit_mask8[total_no_of_bits % 8];\r\n}\r\nelse\r\n{\r\nguint8 remaining_bit_length = total_no_of_bits;\r\nvalue = 0;\r\nrequired_bits_in_first_octet %= 8;\r\nif(required_bits_in_first_octet != 0)\r\n{\r\nvalue = tvb_get_guint8(tvb, octet_offset) & bit_mask8[required_bits_in_first_octet];\r\nremaining_bit_length -= required_bits_in_first_octet;\r\noctet_offset ++;\r\n}\r\nwhile (remaining_bit_length > 7)\r\n{\r\nswitch (remaining_bit_length >> 4)\r\n{\r\ncase 0:\r\nvalue <<= 8;\r\nvalue += tvb_get_guint8(tvb, octet_offset);\r\nremaining_bit_length -= 8;\r\noctet_offset ++;\r\nbreak;\r\ncase 1:\r\nvalue <<= 16;\r\nvalue += tvb_get_ntohs(tvb, octet_offset);\r\nremaining_bit_length -= 16;\r\noctet_offset += 2;\r\nbreak;\r\ncase 2:\r\ncase 3:\r\nvalue <<= 32;\r\nvalue += tvb_get_ntohl(tvb, octet_offset);\r\nremaining_bit_length -= 32;\r\noctet_offset += 4;\r\nbreak;\r\ndefault:\r\nvalue = tvb_get_ntoh64(tvb, octet_offset);\r\nremaining_bit_length -= 64;\r\noctet_offset += 8;\r\nbreak;\r\n}\r\n}\r\nif(remaining_bit_length)\r\n{\r\nvalue <<= remaining_bit_length;\r\nvalue += (tvb_get_guint8(tvb, octet_offset) >> (8 - remaining_bit_length));\r\n}\r\n}\r\nreturn value;\r\n}\r\nguint32\r\ntvb_get_bits(tvbuff_t *tvb, const guint bit_offset, const gint no_of_bits, const guint encoding _U_)\r\n{\r\nreturn (guint32)_tvb_get_bits64(tvb, bit_offset, no_of_bits);\r\n}\r\nstatic gint\r\ntvb_find_guint8_generic(tvbuff_t *tvb, guint abs_offset, guint limit, guint8 needle)\r\n{\r\nconst guint8 *ptr;\r\nconst guint8 *result;\r\nptr = ensure_contiguous(tvb, abs_offset, limit);\r\nresult = (const guint8 *) memchr(ptr, needle, limit);\r\nif (!result)\r\nreturn -1;\r\nreturn (gint) ((result - ptr) + abs_offset);\r\n}\r\ngint\r\ntvb_find_guint8(tvbuff_t *tvb, const gint offset, const gint maxlength, const guint8 needle)\r\n{\r\nconst guint8 *result;\r\nguint abs_offset = 0;\r\nguint limit = 0;\r\nint exception;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nexception = compute_offset_and_remaining(tvb, offset, &abs_offset, &limit);\r\nif (exception)\r\nTHROW(exception);\r\nif (maxlength >= 0 && limit > (guint) maxlength) {\r\nlimit = (guint) maxlength;\r\n}\r\nif (tvb->real_data) {\r\nresult = (const guint8 *)memchr(tvb->real_data + abs_offset, needle, limit);\r\nif (result == NULL) {\r\nreturn -1;\r\n}\r\nelse {\r\nreturn (gint) (result - tvb->real_data);\r\n}\r\n}\r\nif (tvb->ops->tvb_find_guint8)\r\nreturn tvb->ops->tvb_find_guint8(tvb, abs_offset, limit, needle);\r\nreturn tvb_find_guint8_generic(tvb, offset, limit, needle);\r\n}\r\nstatic inline gint\r\ntvb_ws_mempbrk_guint8_generic(tvbuff_t *tvb, guint abs_offset, guint limit, const ws_mempbrk_pattern* pattern, guchar *found_needle)\r\n{\r\nconst guint8 *ptr;\r\nconst guint8 *result;\r\nptr = ensure_contiguous(tvb, abs_offset, limit);\r\nresult = ws_mempbrk_exec(ptr, limit, pattern, found_needle);\r\nif (!result)\r\nreturn -1;\r\nreturn (gint) ((result - ptr) + abs_offset);\r\n}\r\ngint\r\ntvb_ws_mempbrk_pattern_guint8(tvbuff_t *tvb, const gint offset, const gint maxlength,\r\nconst ws_mempbrk_pattern* pattern, guchar *found_needle)\r\n{\r\nconst guint8 *result;\r\nguint abs_offset = 0;\r\nguint limit = 0;\r\nint exception;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nexception = compute_offset_and_remaining(tvb, offset, &abs_offset, &limit);\r\nif (exception)\r\nTHROW(exception);\r\nif (limit > (guint) maxlength) {\r\nlimit = maxlength;\r\n}\r\nif (tvb->real_data) {\r\nresult = ws_mempbrk_exec(tvb->real_data + abs_offset, limit, pattern, found_needle);\r\nif (result == NULL) {\r\nreturn -1;\r\n}\r\nelse {\r\nreturn (gint) (result - tvb->real_data);\r\n}\r\n}\r\nif (tvb->ops->tvb_ws_mempbrk_pattern_guint8)\r\nreturn tvb->ops->tvb_ws_mempbrk_pattern_guint8(tvb, abs_offset, limit, pattern, found_needle);\r\nreturn tvb_ws_mempbrk_guint8_generic(tvb, abs_offset, limit, pattern, found_needle);\r\n}\r\nguint\r\ntvb_strsize(tvbuff_t *tvb, const gint offset)\r\n{\r\nguint abs_offset = 0, junk_length;\r\ngint nul_offset;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\ncheck_offset_length(tvb, offset, 0, &abs_offset, &junk_length);\r\nnul_offset = tvb_find_guint8(tvb, abs_offset, -1, 0);\r\nif (nul_offset == -1) {\r\nif (tvb->length < tvb->reported_length) {\r\nTHROW(BoundsError);\r\n} else {\r\nif (tvb->flags & TVBUFF_FRAGMENT) {\r\nTHROW(FragmentBoundsError);\r\n} else {\r\nTHROW(ReportedBoundsError);\r\n}\r\n}\r\n}\r\nreturn (nul_offset - abs_offset) + 1;\r\n}\r\nguint\r\ntvb_unicode_strsize(tvbuff_t *tvb, const gint offset)\r\n{\r\nguint i = 0;\r\ngunichar2 uchar;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\ndo {\r\nuchar = tvb_get_ntohs(tvb, offset + i);\r\ni += 2;\r\n} while(uchar != 0);\r\nreturn i;\r\n}\r\ngint\r\ntvb_strnlen(tvbuff_t *tvb, const gint offset, const guint maxlength)\r\n{\r\ngint result_offset;\r\nguint abs_offset = 0, junk_length;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\ncheck_offset_length(tvb, offset, 0, &abs_offset, &junk_length);\r\nresult_offset = tvb_find_guint8(tvb, abs_offset, maxlength, 0);\r\nif (result_offset == -1) {\r\nreturn -1;\r\n}\r\nelse {\r\nreturn result_offset - abs_offset;\r\n}\r\n}\r\ngint\r\ntvb_strneql(tvbuff_t *tvb, const gint offset, const gchar *str, const size_t size)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous_no_exception(tvb, offset, (gint)size, NULL);\r\nif (ptr) {\r\nint cmp = strncmp((const char *)ptr, str, size);\r\nreturn (cmp == 0 ? 0 : -1);\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\ngint\r\ntvb_strncaseeql(tvbuff_t *tvb, const gint offset, const gchar *str, const size_t size)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous_no_exception(tvb, offset, (gint)size, NULL);\r\nif (ptr) {\r\nint cmp = g_ascii_strncasecmp((const char *)ptr, str, size);\r\nreturn (cmp == 0 ? 0 : -1);\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\ngint\r\ntvb_memeql(tvbuff_t *tvb, const gint offset, const guint8 *str, size_t size)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous_no_exception(tvb, offset, (gint) size, NULL);\r\nif (ptr) {\r\nint cmp = memcmp(ptr, str, size);\r\nreturn (cmp == 0 ? 0 : -1);\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\ngchar *\r\ntvb_format_text(tvbuff_t *tvb, const gint offset, const gint size)\r\n{\r\nconst guint8 *ptr;\r\ngint len;\r\nlen = (size > 0) ? size : 0;\r\nptr = ensure_contiguous(tvb, offset, size);\r\nreturn format_text(ptr, len);\r\n}\r\ngchar *\r\ntvb_format_text_wsp(tvbuff_t *tvb, const gint offset, const gint size)\r\n{\r\nconst guint8 *ptr;\r\ngint len;\r\nlen = (size > 0) ? size : 0;\r\nptr = ensure_contiguous(tvb, offset, size);\r\nreturn format_text_wsp(ptr, len);\r\n}\r\ngchar *\r\ntvb_format_stringzpad(tvbuff_t *tvb, const gint offset, const gint size)\r\n{\r\nconst guint8 *ptr, *p;\r\ngint len;\r\ngint stringlen;\r\nlen = (size > 0) ? size : 0;\r\nptr = ensure_contiguous(tvb, offset, size);\r\nfor (p = ptr, stringlen = 0; stringlen < len && *p != '\0'; p++, stringlen++)\r\n;\r\nreturn format_text(ptr, stringlen);\r\n}\r\ngchar *\r\ntvb_format_stringzpad_wsp(tvbuff_t *tvb, const gint offset, const gint size)\r\n{\r\nconst guint8 *ptr, *p;\r\ngint len;\r\ngint stringlen;\r\nlen = (size > 0) ? size : 0;\r\nptr = ensure_contiguous(tvb, offset, size);\r\nfor (p = ptr, stringlen = 0; stringlen < len && *p != '\0'; p++, stringlen++)\r\n;\r\nreturn format_text_wsp(ptr, stringlen);\r\n}\r\nstatic guint8 *\r\ntvb_get_ascii_string(wmem_allocator_t *scope, tvbuff_t *tvb, gint offset, gint length)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous(tvb, offset, length);\r\nreturn get_ascii_string(scope, ptr, length);\r\n}\r\nstatic guint8 *\r\ntvb_get_utf_8_string(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, const gint length)\r\n{\r\nguint8 *strbuf;\r\ntvb_ensure_bytes_exist(tvb, offset, length);\r\nstrbuf = (guint8 *)wmem_alloc(scope, length + 1);\r\ntvb_memcpy(tvb, strbuf, offset, length);\r\nstrbuf[length] = '\0';\r\nreturn strbuf;\r\n}\r\nstatic inline guint8 *\r\ntvb_get_raw_string(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, const gint length)\r\n{\r\nguint8 *strbuf;\r\ngint abs_length = length;\r\nDISSECTOR_ASSERT(offset >= 0);\r\nDISSECTOR_ASSERT(abs_length >= -1);\r\nif (abs_length < 0)\r\nabs_length = tvb->length - offset;\r\ntvb_ensure_bytes_exist(tvb, offset, abs_length);\r\nstrbuf = (guint8 *)wmem_alloc(scope, abs_length + 1);\r\ntvb_memcpy(tvb, strbuf, offset, abs_length);\r\nstrbuf[abs_length] = '\0';\r\nreturn strbuf;\r\n}\r\nstatic guint8 *\r\ntvb_get_string_8859_1(wmem_allocator_t *scope, tvbuff_t *tvb, gint offset, gint length)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous(tvb, offset, length);\r\nreturn get_8859_1_string(scope, ptr, length);\r\n}\r\nstatic guint8 *\r\ntvb_get_string_unichar2(wmem_allocator_t *scope, tvbuff_t *tvb, gint offset, gint length, const gunichar2 table[0x80])\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous(tvb, offset, length);\r\nreturn get_unichar2_string(scope, ptr, length, table);\r\n}\r\nstatic guint8 *\r\ntvb_get_ucs_2_string(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, gint length, const guint encoding)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous(tvb, offset, length);\r\nreturn get_ucs_2_string(scope, ptr, length, encoding);\r\n}\r\nstatic guint8 *\r\ntvb_get_utf_16_string(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, gint length, const guint encoding)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous(tvb, offset, length);\r\nreturn get_utf_16_string(scope, ptr, length, encoding);\r\n}\r\nstatic gchar *\r\ntvb_get_ucs_4_string(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, gint length, const guint encoding)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous(tvb, offset, length);\r\nreturn get_ucs_4_string(scope, ptr, length, encoding);\r\n}\r\ngchar *\r\ntvb_get_ts_23_038_7bits_string(wmem_allocator_t *scope, tvbuff_t *tvb,\r\nconst gint bit_offset, gint no_of_chars)\r\n{\r\ngint in_offset = bit_offset >> 3;\r\ngint length = ((no_of_chars + 1) * 7 + (bit_offset & 0x07)) >> 3;\r\nconst guint8 *ptr;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nptr = ensure_contiguous(tvb, in_offset, length);\r\nreturn get_ts_23_038_7bits_string(scope, ptr, bit_offset, no_of_chars);\r\n}\r\ngchar *\r\ntvb_get_ascii_7bits_string(wmem_allocator_t *scope, tvbuff_t *tvb,\r\nconst gint bit_offset, gint no_of_chars)\r\n{\r\ngint in_offset = bit_offset >> 3;\r\ngint length = ((no_of_chars + 1) * 7 + (bit_offset & 0x07)) >> 3;\r\nconst guint8 *ptr;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nptr = ensure_contiguous(tvb, in_offset, length);\r\nreturn get_ascii_7bits_string(scope, ptr, bit_offset, no_of_chars);\r\n}\r\nstatic guint8 *\r\ntvb_get_ebcdic_string(wmem_allocator_t *scope, tvbuff_t *tvb, gint offset, gint length)\r\n{\r\nconst guint8 *ptr;\r\nptr = ensure_contiguous(tvb, offset, length);\r\nreturn get_ebcdic_string(scope, ptr, length);\r\n}\r\nguint8 *\r\ntvb_get_string_enc(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset,\r\nconst gint length, const guint encoding)\r\n{\r\nguint8 *strptr;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nif (length < 0) {\r\nTHROW(ReportedBoundsError);\r\n}\r\nswitch (encoding & ENC_CHARENCODING_MASK) {\r\ncase ENC_ASCII:\r\ndefault:\r\nstrptr = tvb_get_ascii_string(scope, tvb, offset, length);\r\nbreak;\r\ncase ENC_UTF_8:\r\nstrptr = tvb_get_utf_8_string(scope, tvb, offset, length);\r\nbreak;\r\ncase ENC_UTF_16:\r\nstrptr = tvb_get_utf_16_string(scope, tvb, offset, length,\r\nencoding & ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase ENC_UCS_2:\r\nstrptr = tvb_get_ucs_2_string(scope, tvb, offset, length,\r\nencoding & ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase ENC_UCS_4:\r\nstrptr = tvb_get_ucs_4_string(scope, tvb, offset, length,\r\nencoding & ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase ENC_ISO_8859_1:\r\nstrptr = tvb_get_string_8859_1(scope, tvb, offset, length);\r\nbreak;\r\ncase ENC_ISO_8859_2:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_2);\r\nbreak;\r\ncase ENC_ISO_8859_3:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_3);\r\nbreak;\r\ncase ENC_ISO_8859_4:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_4);\r\nbreak;\r\ncase ENC_ISO_8859_5:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_5);\r\nbreak;\r\ncase ENC_ISO_8859_6:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_6);\r\nbreak;\r\ncase ENC_ISO_8859_7:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_7);\r\nbreak;\r\ncase ENC_ISO_8859_8:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_8);\r\nbreak;\r\ncase ENC_ISO_8859_9:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_9);\r\nbreak;\r\ncase ENC_ISO_8859_10:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_10);\r\nbreak;\r\ncase ENC_ISO_8859_11:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_11);\r\nbreak;\r\ncase ENC_ISO_8859_13:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_13);\r\nbreak;\r\ncase ENC_ISO_8859_14:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_14);\r\nbreak;\r\ncase ENC_ISO_8859_15:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_15);\r\nbreak;\r\ncase ENC_ISO_8859_16:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_iso_8859_16);\r\nbreak;\r\ncase ENC_WINDOWS_1250:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_cp1250);\r\nbreak;\r\ncase ENC_MAC_ROMAN:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_mac_roman);\r\nbreak;\r\ncase ENC_CP437:\r\nstrptr = tvb_get_string_unichar2(scope, tvb, offset, length, charset_table_cp437);\r\nbreak;\r\ncase ENC_3GPP_TS_23_038_7BITS:\r\n{\r\ngint bit_offset = offset << 3;\r\ngint no_of_chars = (length << 3) / 7;\r\nstrptr = tvb_get_ts_23_038_7bits_string(scope, tvb, bit_offset, no_of_chars);\r\n}\r\nbreak;\r\ncase ENC_ASCII_7BITS:\r\n{\r\ngint bit_offset = offset << 3;\r\ngint no_of_chars = (length << 3) / 7;\r\nstrptr = tvb_get_ascii_7bits_string(scope, tvb, bit_offset, no_of_chars);\r\n}\r\nbreak;\r\ncase ENC_EBCDIC:\r\nstrptr = tvb_get_ebcdic_string(scope, tvb, offset, length);\r\nbreak;\r\n}\r\nreturn strptr;\r\n}\r\nguint8 *\r\ntvb_get_stringzpad(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset,\r\nconst gint length, const guint encoding)\r\n{\r\nreturn tvb_get_string_enc(scope, tvb, offset, length, encoding);\r\n}\r\nstatic guint8 *\r\ntvb_get_ascii_stringz(wmem_allocator_t *scope, tvbuff_t *tvb, gint offset, gint *lengthp)\r\n{\r\nguint size;\r\nconst guint8 *ptr;\r\nsize = tvb_strsize(tvb, offset);\r\nptr = ensure_contiguous(tvb, offset, size);\r\nif (lengthp)\r\n*lengthp = size;\r\nreturn get_ascii_string(scope, ptr, size);\r\n}\r\nstatic guint8 *\r\ntvb_get_utf_8_stringz(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, gint *lengthp)\r\n{\r\nguint size;\r\nguint8 *strptr;\r\nsize = tvb_strsize(tvb, offset);\r\nstrptr = (guint8 *)wmem_alloc(scope, size);\r\ntvb_memcpy(tvb, strptr, offset, size);\r\nif (lengthp)\r\n*lengthp = size;\r\nreturn strptr;\r\n}\r\nstatic guint8 *\r\ntvb_get_stringz_8859_1(wmem_allocator_t *scope, tvbuff_t *tvb, gint offset, gint *lengthp)\r\n{\r\nguint size;\r\nconst guint8 *ptr;\r\nsize = tvb_strsize(tvb, offset);\r\nptr = ensure_contiguous(tvb, offset, size);\r\nif (lengthp)\r\n*lengthp = size;\r\nreturn get_8859_1_string(scope, ptr, size);\r\n}\r\nstatic guint8 *\r\ntvb_get_stringz_unichar2(wmem_allocator_t *scope, tvbuff_t *tvb, gint offset, gint *lengthp, const gunichar2 table[0x80])\r\n{\r\nguint size;\r\nconst guint8 *ptr;\r\nsize = tvb_strsize(tvb, offset);\r\nptr = ensure_contiguous(tvb, offset, size);\r\nif (lengthp)\r\n*lengthp = size;\r\nreturn get_unichar2_string(scope, ptr, size, table);\r\n}\r\nconst guint8 *\r\ntvb_get_const_stringz(tvbuff_t *tvb, const gint offset, gint *lengthp)\r\n{\r\nguint size;\r\nconst guint8 *strptr;\r\nsize = tvb_strsize(tvb, offset);\r\nstrptr = ensure_contiguous(tvb, offset, size);\r\nif (lengthp)\r\n*lengthp = size;\r\nreturn strptr;\r\n}\r\nstatic gchar *\r\ntvb_get_ucs_2_stringz(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, gint *lengthp, const guint encoding)\r\n{\r\ngint size;\r\nconst guint8 *ptr;\r\nsize = tvb_unicode_strsize(tvb, offset);\r\nptr = ensure_contiguous(tvb, offset, size);\r\nif (lengthp)\r\n*lengthp = size;\r\nreturn get_ucs_2_string(scope, ptr, size, encoding);\r\n}\r\nstatic gchar *\r\ntvb_get_utf_16_stringz(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, gint *lengthp, const guint encoding)\r\n{\r\ngint size;\r\nconst guint8 *ptr;\r\nsize = tvb_unicode_strsize(tvb, offset);\r\nptr = ensure_contiguous(tvb, offset, size);\r\nif (lengthp)\r\n*lengthp = size;\r\nreturn get_utf_16_string(scope, ptr, size, encoding);\r\n}\r\nstatic gchar *\r\ntvb_get_ucs_4_stringz(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, gint *lengthp, const guint encoding)\r\n{\r\ngint size;\r\ngunichar uchar;\r\nconst guint8 *ptr;\r\nsize = 0;\r\ndo {\r\nuchar = tvb_get_ntohl(tvb, offset + size);\r\nsize += 4;\r\n} while(uchar != 0);\r\nptr = ensure_contiguous(tvb, offset, size);\r\nif (lengthp)\r\n*lengthp = size;\r\nreturn get_ucs_4_string(scope, ptr, size, encoding);\r\n}\r\nstatic guint8 *\r\ntvb_get_ebcdic_stringz(wmem_allocator_t *scope, tvbuff_t *tvb, gint offset, gint *lengthp)\r\n{\r\nguint size;\r\nconst guint8 *ptr;\r\nsize = tvb_strsize(tvb, offset);\r\nptr = ensure_contiguous(tvb, offset, size);\r\nif (lengthp)\r\n*lengthp = size;\r\nreturn get_ebcdic_string(scope, ptr, size);\r\n}\r\nguint8 *\r\ntvb_get_stringz_enc(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, gint *lengthp, const guint encoding)\r\n{\r\nguint8 *strptr;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nswitch (encoding & ENC_CHARENCODING_MASK) {\r\ncase ENC_ASCII:\r\ndefault:\r\nstrptr = tvb_get_ascii_stringz(scope, tvb, offset, lengthp);\r\nbreak;\r\ncase ENC_UTF_8:\r\nstrptr = tvb_get_utf_8_stringz(scope, tvb, offset, lengthp);\r\nbreak;\r\ncase ENC_UTF_16:\r\nstrptr = tvb_get_utf_16_stringz(scope, tvb, offset, lengthp,\r\nencoding & ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase ENC_UCS_2:\r\nstrptr = tvb_get_ucs_2_stringz(scope, tvb, offset, lengthp,\r\nencoding & ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase ENC_UCS_4:\r\nstrptr = tvb_get_ucs_4_stringz(scope, tvb, offset, lengthp,\r\nencoding & ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase ENC_ISO_8859_1:\r\nstrptr = tvb_get_stringz_8859_1(scope, tvb, offset, lengthp);\r\nbreak;\r\ncase ENC_ISO_8859_2:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_2);\r\nbreak;\r\ncase ENC_ISO_8859_3:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_3);\r\nbreak;\r\ncase ENC_ISO_8859_4:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_4);\r\nbreak;\r\ncase ENC_ISO_8859_5:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_5);\r\nbreak;\r\ncase ENC_ISO_8859_6:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_6);\r\nbreak;\r\ncase ENC_ISO_8859_7:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_7);\r\nbreak;\r\ncase ENC_ISO_8859_8:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_8);\r\nbreak;\r\ncase ENC_ISO_8859_9:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_9);\r\nbreak;\r\ncase ENC_ISO_8859_10:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_10);\r\nbreak;\r\ncase ENC_ISO_8859_11:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_11);\r\nbreak;\r\ncase ENC_ISO_8859_13:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_13);\r\nbreak;\r\ncase ENC_ISO_8859_14:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_14);\r\nbreak;\r\ncase ENC_ISO_8859_15:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_15);\r\nbreak;\r\ncase ENC_ISO_8859_16:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_iso_8859_16);\r\nbreak;\r\ncase ENC_WINDOWS_1250:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_cp1250);\r\nbreak;\r\ncase ENC_MAC_ROMAN:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_mac_roman);\r\nbreak;\r\ncase ENC_CP437:\r\nstrptr = tvb_get_stringz_unichar2(scope, tvb, offset, lengthp, charset_table_cp437);\r\nbreak;\r\ncase ENC_3GPP_TS_23_038_7BITS:\r\nREPORT_DISSECTOR_BUG("TS 23.038 7bits has no null character and doesn't support null-terminated strings");\r\nbreak;\r\ncase ENC_ASCII_7BITS:\r\nREPORT_DISSECTOR_BUG("tvb_get_stringz_enc function with ENC_ASCII_7BITS not implemented yet");\r\nbreak;\r\ncase ENC_EBCDIC:\r\nstrptr = tvb_get_ebcdic_stringz(scope, tvb, offset, lengthp);\r\nbreak;\r\n}\r\nreturn strptr;\r\n}\r\nstatic gint\r\n_tvb_get_nstringz(tvbuff_t *tvb, const gint offset, const guint bufsize, guint8* buffer, gint *bytes_copied)\r\n{\r\ngint stringlen;\r\nguint abs_offset = 0;\r\ngint limit, len = 0;\r\ngboolean decreased_max = FALSE;\r\ncheck_offset_length(tvb, offset, -1, &abs_offset, &len);\r\nDISSECTOR_ASSERT(bufsize != 0);\r\nif (bufsize == 1) {\r\nbuffer[0] = 0;\r\n*bytes_copied = 1;\r\nreturn 0;\r\n}\r\nif (len == 0) {\r\nTHROW(ReportedBoundsError);\r\n}\r\nDISSECTOR_ASSERT(len != -1);\r\nDISSECTOR_ASSERT(bufsize <= G_MAXINT);\r\nif ((guint)len < bufsize) {\r\nlimit = len;\r\ndecreased_max = TRUE;\r\n}\r\nelse {\r\nlimit = bufsize;\r\n}\r\nstringlen = tvb_strnlen(tvb, abs_offset, limit - 1);\r\nif (stringlen == -1) {\r\ntvb_memcpy(tvb, buffer, abs_offset, limit);\r\nif (decreased_max) {\r\nbuffer[limit] = 0;\r\n*bytes_copied = limit + 1;\r\n}\r\nelse {\r\n*bytes_copied = limit;\r\n}\r\nreturn -1;\r\n}\r\ntvb_memcpy(tvb, buffer, abs_offset, stringlen + 1);\r\n*bytes_copied = stringlen + 1;\r\nreturn stringlen;\r\n}\r\ngint\r\ntvb_get_nstringz(tvbuff_t *tvb, const gint offset, const guint bufsize, guint8 *buffer)\r\n{\r\ngint bytes_copied;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nreturn _tvb_get_nstringz(tvb, offset, bufsize, buffer, &bytes_copied);\r\n}\r\ngint\r\ntvb_get_nstringz0(tvbuff_t *tvb, const gint offset, const guint bufsize, guint8* buffer)\r\n{\r\ngint len, bytes_copied;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nlen = _tvb_get_nstringz(tvb, offset, bufsize, buffer, &bytes_copied);\r\nif (len == -1) {\r\nbuffer[bufsize - 1] = 0;\r\nreturn bytes_copied - 1;\r\n}\r\nelse {\r\nreturn len;\r\n}\r\n}\r\ngint\r\ntvb_find_line_end(tvbuff_t *tvb, const gint offset, int len, gint *next_offset, const gboolean desegment)\r\n{\r\ngint eob_offset;\r\ngint eol_offset;\r\nint linelen;\r\nguchar found_needle = 0;\r\nstatic gboolean compiled = FALSE;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nif (len == -1) {\r\nlen = _tvb_captured_length_remaining(tvb, offset);\r\n}\r\neob_offset = offset + len;\r\nif (!compiled) {\r\nws_mempbrk_compile(&pbrk_crlf, "\r\n");\r\ncompiled = TRUE;\r\n}\r\neol_offset = tvb_ws_mempbrk_pattern_guint8(tvb, offset, len, &pbrk_crlf, &found_needle);\r\nif (eol_offset == -1) {\r\nif (desegment) {\r\nreturn -1;\r\n} else {\r\nlinelen = eob_offset - offset;\r\nif (next_offset)\r\n*next_offset = eob_offset;\r\n}\r\n} else {\r\nlinelen = eol_offset - offset;\r\nif (found_needle == '\r') {\r\nif (eol_offset + 1 >= eob_offset) {\r\nif (desegment) {\r\nreturn -1;\r\n}\r\n} else {\r\nif (tvb_get_guint8(tvb, eol_offset + 1) == '\n') {\r\neol_offset++;\r\n}\r\n}\r\n}\r\nif (next_offset)\r\n*next_offset = eol_offset + 1;\r\n}\r\nreturn linelen;\r\n}\r\ngint\r\ntvb_find_line_end_unquoted(tvbuff_t *tvb, const gint offset, int len, gint *next_offset)\r\n{\r\ngint cur_offset, char_offset;\r\ngboolean is_quoted;\r\nguchar c = 0;\r\ngint eob_offset;\r\nint linelen;\r\nstatic gboolean compiled = FALSE;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nif (len == -1)\r\nlen = _tvb_captured_length_remaining(tvb, offset);\r\nif (!compiled) {\r\nws_mempbrk_compile(&pbrk_crlf_dquote, "\r\n\"");\r\ncompiled = TRUE;\r\n}\r\neob_offset = offset + len;\r\ncur_offset = offset;\r\nis_quoted = FALSE;\r\nfor (;;) {\r\nif (is_quoted) {\r\nchar_offset = tvb_find_guint8(tvb, cur_offset, len,\r\n'"');\r\n} else {\r\nchar_offset = tvb_ws_mempbrk_pattern_guint8(tvb, cur_offset, len, &pbrk_crlf_dquote, &c);\r\n}\r\nif (char_offset == -1) {\r\nlinelen = eob_offset - offset;\r\nif (next_offset)\r\n*next_offset = eob_offset;\r\nbreak;\r\n}\r\nif (is_quoted) {\r\nis_quoted = FALSE;\r\n} else {\r\nif (c == '"') {\r\nis_quoted = TRUE;\r\n} else {\r\nlinelen = char_offset - offset;\r\nif (c == '\r') {\r\nif (char_offset + 1 < eob_offset &&\r\ntvb_get_guint8(tvb, char_offset + 1)\r\n== '\n') {\r\nchar_offset++;\r\n}\r\n}\r\nif (next_offset)\r\n*next_offset = char_offset + 1;\r\nbreak;\r\n}\r\n}\r\ncur_offset = char_offset + 1;\r\nif (cur_offset >= eob_offset) {\r\nlinelen = eob_offset - offset;\r\nif (next_offset)\r\n*next_offset = eob_offset;\r\nbreak;\r\n}\r\n}\r\nreturn linelen;\r\n}\r\ngint\r\ntvb_skip_wsp(tvbuff_t *tvb, const gint offset, const gint maxlength)\r\n{\r\ngint counter = offset;\r\ngint end, tvb_len;\r\nguint8 tempchar;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\ntvb_len = tvb->length;\r\nend = offset + maxlength;\r\nif (end >= tvb_len)\r\n{\r\nend = tvb_len;\r\n}\r\nfor (counter = offset;\r\ncounter < end &&\r\n((tempchar = tvb_get_guint8(tvb,counter)) == ' ' ||\r\ntempchar == '\t' || tempchar == '\r' || tempchar == '\n');\r\ncounter++);\r\nreturn (counter);\r\n}\r\ngint\r\ntvb_skip_wsp_return(tvbuff_t *tvb, const gint offset) {\r\ngint counter = offset;\r\nguint8 tempchar;\r\nfor(counter = offset; counter > 0 &&\r\n((tempchar = tvb_get_guint8(tvb,counter)) == ' ' ||\r\ntempchar == '\t' || tempchar == '\n' || tempchar == '\r'); counter--);\r\ncounter++;\r\nreturn (counter);\r\n}\r\nint\r\ntvb_skip_guint8(tvbuff_t *tvb, int offset, const int maxlength, const guint8 ch)\r\n{\r\nint end, tvb_len;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\ntvb_len = tvb->length;\r\nend = offset + maxlength;\r\nif (end >= tvb_len)\r\nend = tvb_len;\r\nwhile (offset < end) {\r\nguint8 tempch = tvb_get_guint8(tvb, offset);\r\nif (tempch != ch)\r\nbreak;\r\noffset++;\r\n}\r\nreturn offset;\r\n}\r\ngchar *\r\ntvb_bytes_to_str_punct(wmem_allocator_t *scope, tvbuff_t *tvb, const gint offset, const gint len, const gchar punct)\r\n{\r\nreturn bytestring_to_str(scope, ensure_contiguous(tvb, offset, len), len, punct);\r\n}\r\nconst gchar *\r\ntvb_bcd_dig_to_wmem_packet_str(tvbuff_t *tvb, const gint offset, const gint len, dgt_set_t *dgt, gboolean skip_first)\r\n{\r\nint length;\r\nguint8 octet;\r\nint i = 0;\r\nchar *digit_str;\r\ngint t_offset = offset;\r\nDISSECTOR_ASSERT(tvb && tvb->initialized);\r\nif (!dgt)\r\ndgt = &Dgt1_9_bcd;\r\nif (len == -1) {\r\nlength = tvb->length;\r\nif (length < offset) {\r\nreturn "";\r\n}\r\n} else {\r\nlength = offset + len;\r\n}\r\ndigit_str = (char *)wmem_alloc(wmem_packet_scope(), (length - offset)*2+1);\r\nwhile (t_offset < length) {\r\noctet = tvb_get_guint8(tvb,t_offset);\r\nif (!skip_first) {\r\ndigit_str[i] = dgt->out[octet & 0x0f];\r\ni++;\r\n}\r\nskip_first = FALSE;\r\noctet = octet >> 4;\r\nif (t_offset == length - 1 && octet == 0x0f) {\r\nbreak;\r\n}\r\ndigit_str[i] = dgt->out[octet & 0x0f];\r\ni++;\r\nt_offset++;\r\n}\r\ndigit_str[i]= '\0';\r\nreturn digit_str;\r\n}\r\ngchar *tvb_bytes_to_str(wmem_allocator_t *allocator, tvbuff_t *tvb,\r\nconst gint offset, const gint len)\r\n{\r\nreturn bytes_to_str(allocator, ensure_contiguous(tvb, offset, len), len);\r\n}\r\ngint\r\ntvb_find_tvb(tvbuff_t *haystack_tvb, tvbuff_t *needle_tvb, const gint haystack_offset)\r\n{\r\nguint haystack_abs_offset = 0, haystack_abs_length = 0;\r\nconst guint8 *haystack_data;\r\nconst guint8 *needle_data;\r\nconst guint needle_len = needle_tvb->length;\r\nconst guint8 *location;\r\nDISSECTOR_ASSERT(haystack_tvb && haystack_tvb->initialized);\r\nif (haystack_tvb->length < 1 || needle_tvb->length < 1) {\r\nreturn -1;\r\n}\r\nhaystack_data = ensure_contiguous(haystack_tvb, 0, -1);\r\nneedle_data = ensure_contiguous(needle_tvb, 0, -1);\r\ncheck_offset_length(haystack_tvb, haystack_offset, -1,\r\n&haystack_abs_offset, &haystack_abs_length);\r\nlocation = epan_memmem(haystack_data + haystack_abs_offset, haystack_abs_length,\r\nneedle_data, needle_len);\r\nif (location) {\r\nreturn (gint) (location - haystack_data);\r\n}\r\nreturn -1;\r\n}\r\ngint\r\ntvb_raw_offset(tvbuff_t *tvb)\r\n{\r\nreturn ((tvb->raw_offset==-1) ? (tvb->raw_offset = tvb_offset_from_real_beginning(tvb)) : tvb->raw_offset);\r\n}\r\nvoid\r\ntvb_set_fragment(tvbuff_t *tvb)\r\n{\r\ntvb->flags |= TVBUFF_FRAGMENT;\r\n}\r\nstruct tvbuff *\r\ntvb_get_ds_tvb(tvbuff_t *tvb)\r\n{\r\nreturn(tvb->ds_tvb);\r\n}
