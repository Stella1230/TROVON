static gboolean\r\nwrite_to_file(FILE* pfile, const guint8* data, size_t data_length,\r\nguint64 *bytes_written, int *err)\r\n{\r\nsize_t nwritten;\r\nnwritten = fwrite(data, data_length, 1, pfile);\r\nif (nwritten != 1) {\r\nif (ferror(pfile)) {\r\n*err = errno;\r\n} else {\r\n*err = 0;\r\n}\r\nreturn FALSE;\r\n}\r\n(*bytes_written) += data_length;\r\nreturn TRUE;\r\n}\r\ngboolean\r\nlibpcap_write_file_header(FILE* pfile, int linktype, int snaplen, gboolean ts_nsecs, guint64 *bytes_written, int *err)\r\n{\r\nstruct pcap_hdr file_hdr;\r\nfile_hdr.magic = ts_nsecs ? PCAP_NSEC_MAGIC : PCAP_MAGIC;\r\nfile_hdr.version_major = 2;\r\nfile_hdr.version_minor = 4;\r\nfile_hdr.thiszone = 0;\r\nfile_hdr.sigfigs = 0;\r\nfile_hdr.snaplen = snaplen;\r\nfile_hdr.network = linktype;\r\nreturn write_to_file(pfile, (const guint8*)&file_hdr, sizeof(file_hdr), bytes_written, err);\r\n}\r\ngboolean\r\nlibpcap_write_packet(FILE* pfile,\r\ntime_t sec, guint32 usec,\r\nguint32 caplen, guint32 len,\r\nconst guint8 *pd,\r\nguint64 *bytes_written, int *err)\r\n{\r\nstruct pcaprec_hdr rec_hdr;\r\nrec_hdr.ts_sec = (guint32)sec;\r\nrec_hdr.ts_usec = usec;\r\nrec_hdr.incl_len = caplen;\r\nrec_hdr.orig_len = len;\r\nif (!write_to_file(pfile, (const guint8*)&rec_hdr, sizeof(rec_hdr), bytes_written, err))\r\nreturn FALSE;\r\nreturn write_to_file(pfile, pd, caplen, bytes_written, err);\r\n}\r\nstatic guint32\r\npcapng_count_string_option(const char *option_value)\r\n{\r\nif ((option_value != NULL) && (strlen(option_value) > 0) && (strlen(option_value) < G_MAXUINT16)) {\r\nreturn (guint32)(sizeof(struct option) +\r\n(guint16)ADD_PADDING(strlen(option_value)));\r\n}\r\nreturn 0;\r\n}\r\nstatic gboolean\r\npcapng_write_string_option(FILE* pfile,\r\nguint16 option_type, const char *option_value,\r\nguint64 *bytes_written, int *err)\r\n{\r\nsize_t option_value_length;\r\nstruct option option;\r\nconst guint32 padding = 0;\r\nif (option_value == NULL)\r\nreturn TRUE;\r\noption_value_length = strlen(option_value);\r\nif ((option_value_length > 0) && (option_value_length < G_MAXUINT16)) {\r\noption.type = option_type;\r\noption.value_length = (guint16)option_value_length;\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)option_value, (int) option_value_length, bytes_written, err))\r\nreturn FALSE;\r\nif (option_value_length % 4) {\r\nif (!write_to_file(pfile, (const guint8*)&padding, 4 - option_value_length % 4, bytes_written, err))\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\ngboolean\r\npcapng_write_session_header_block(FILE* pfile,\r\nconst char *comment,\r\nconst char *hw,\r\nconst char *os,\r\nconst char *appname,\r\nguint64 section_length,\r\nguint64 *bytes_written,\r\nint *err)\r\n{\r\nstruct shb shb;\r\nstruct option option;\r\nguint32 block_total_length;\r\nguint32 options_length;\r\nblock_total_length = sizeof(struct shb) +\r\nsizeof(guint32);\r\noptions_length = 0;\r\noptions_length += pcapng_count_string_option(comment);\r\noptions_length += pcapng_count_string_option(hw);\r\noptions_length += pcapng_count_string_option(os);\r\noptions_length += pcapng_count_string_option(appname);\r\nif (options_length != 0) {\r\noptions_length += (guint32)sizeof(struct option);\r\n}\r\nblock_total_length += options_length;\r\nshb.block_type = SECTION_HEADER_BLOCK_TYPE;\r\nshb.block_total_length = block_total_length;\r\nshb.byte_order_magic = PCAPNG_MAGIC;\r\nshb.major_version = PCAPNG_MAJOR_VERSION;\r\nshb.minor_version = PCAPNG_MINOR_VERSION;\r\nshb.section_length = section_length;\r\nif (!write_to_file(pfile, (const guint8*)&shb, sizeof(struct shb), bytes_written, err))\r\nreturn FALSE;\r\nif (!pcapng_write_string_option(pfile, OPT_COMMENT, comment,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (!pcapng_write_string_option(pfile, SHB_HARDWARE, hw,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (!pcapng_write_string_option(pfile, SHB_OS, os,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (!pcapng_write_string_option(pfile, SHB_USERAPPL, appname,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (options_length != 0) {\r\noption.type = OPT_ENDOFOPT;\r\noption.value_length = 0;\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nreturn write_to_file(pfile, (const guint8*)&block_total_length, sizeof(guint32), bytes_written, err);\r\n}\r\ngboolean\r\npcapng_write_interface_description_block(FILE* pfile,\r\nconst char *comment,\r\nconst char *name,\r\nconst char *descr,\r\nconst char *filter,\r\nconst char *os,\r\nint link_type,\r\nint snap_len,\r\nguint64 *bytes_written,\r\nguint64 if_speed,\r\nguint8 tsresol,\r\nint *err)\r\n{\r\nstruct idb idb;\r\nstruct option option;\r\nguint32 block_total_length;\r\nguint32 options_length;\r\nconst guint32 padding = 0;\r\nblock_total_length = (guint32)(sizeof(struct idb) + sizeof(guint32));\r\noptions_length = 0;\r\noptions_length += pcapng_count_string_option(comment);\r\noptions_length += pcapng_count_string_option(name);\r\noptions_length += pcapng_count_string_option(descr);\r\nif (if_speed != 0) {\r\noptions_length += (guint32)(sizeof(struct option) +\r\nsizeof(guint64));\r\n}\r\nif (tsresol != 0) {\r\noptions_length += (guint32)(sizeof(struct option) +\r\nsizeof(struct option));\r\n}\r\nif ((filter != NULL) && (strlen(filter) > 0) && (strlen(filter) < G_MAXUINT16)) {\r\noptions_length += (guint32)(sizeof(struct option) +\r\n(guint16)(ADD_PADDING(strlen(filter)+ 1)));\r\n}\r\noptions_length += pcapng_count_string_option(os);\r\nif (options_length != 0) {\r\noptions_length += (guint32)sizeof(struct option);\r\n}\r\nblock_total_length += options_length;\r\nidb.block_type = INTERFACE_DESCRIPTION_BLOCK_TYPE;\r\nidb.block_total_length = block_total_length;\r\nidb.link_type = link_type;\r\nidb.reserved = 0;\r\nidb.snap_len = snap_len;\r\nif (!write_to_file(pfile, (const guint8*)&idb, sizeof(struct idb), bytes_written, err))\r\nreturn FALSE;\r\nif (!pcapng_write_string_option(pfile, OPT_COMMENT, comment,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (!pcapng_write_string_option(pfile, IDB_NAME, name,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (!pcapng_write_string_option(pfile, IDB_DESCRIPTION, descr,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (if_speed != 0) {\r\noption.type = IDB_IF_SPEED;\r\noption.value_length = sizeof(guint64);\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&if_speed, sizeof(guint64), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nif (tsresol != 0) {\r\noption.type = IDB_TSRESOL;\r\noption.value_length = sizeof(guint8);\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&tsresol, sizeof(guint8), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&padding, 3, bytes_written, err))\r\nreturn FALSE;\r\n}\r\nif ((filter != NULL) && (strlen(filter) > 0) && (strlen(filter) < G_MAXUINT16 - 1)) {\r\noption.type = IDB_FILTER;\r\noption.value_length = (guint16)(strlen(filter) + 1 );\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&padding, 1, bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)filter, (int) strlen(filter), bytes_written, err))\r\nreturn FALSE;\r\nif ((strlen(filter) + 1) % 4) {\r\nif (!write_to_file(pfile, (const guint8*)&padding, 4 - (strlen(filter) + 1) % 4, bytes_written, err))\r\nreturn FALSE;\r\n}\r\n}\r\nif (!pcapng_write_string_option(pfile, IDB_OS, os,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (options_length != 0) {\r\noption.type = OPT_ENDOFOPT;\r\noption.value_length = 0;\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nreturn write_to_file(pfile, (const guint8*)&block_total_length, sizeof(guint32), bytes_written, err);\r\n}\r\ngboolean\r\npcapng_write_enhanced_packet_block(FILE* pfile,\r\nconst char *comment,\r\ntime_t sec, guint32 usec,\r\nguint32 caplen, guint32 len,\r\nguint32 interface_id,\r\nguint ts_mul,\r\nconst guint8 *pd,\r\nguint32 flags,\r\nguint64 *bytes_written,\r\nint *err)\r\n{\r\nstruct epb epb;\r\nstruct option option;\r\nguint32 block_total_length;\r\nguint64 timestamp;\r\nguint32 options_length;\r\nconst guint32 padding = 0;\r\nblock_total_length = (guint32)(sizeof(struct epb) +\r\nADD_PADDING(caplen) +\r\nsizeof(guint32));\r\noptions_length = 0;\r\noptions_length += pcapng_count_string_option(comment);\r\nif (flags != 0) {\r\noptions_length += (guint32)(sizeof(struct option) +\r\nsizeof(guint32));\r\n}\r\nif (options_length != 0) {\r\noptions_length += (guint32)sizeof(struct option);\r\n}\r\nblock_total_length += options_length;\r\ntimestamp = (guint64)sec * ts_mul + (guint64)usec;\r\nepb.block_type = ENHANCED_PACKET_BLOCK_TYPE;\r\nepb.block_total_length = block_total_length;\r\nepb.interface_id = interface_id;\r\nepb.timestamp_high = (guint32)((timestamp>>32) & 0xffffffff);\r\nepb.timestamp_low = (guint32)(timestamp & 0xffffffff);\r\nepb.captured_len = caplen;\r\nepb.packet_len = len;\r\nif (!write_to_file(pfile, (const guint8*)&epb, sizeof(struct epb), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, pd, caplen, bytes_written, err))\r\nreturn FALSE;\r\nif (caplen % 4) {\r\nif (!write_to_file(pfile, (const guint8*)&padding, 4 - caplen % 4, bytes_written, err))\r\nreturn FALSE;\r\n}\r\nif (!pcapng_write_string_option(pfile, OPT_COMMENT, comment,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (flags != 0) {\r\noption.type = EPB_FLAGS;\r\noption.value_length = sizeof(guint32);\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&flags, sizeof(guint32), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nif (options_length != 0) {\r\noption.type = OPT_ENDOFOPT;\r\noption.value_length = 0;\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nreturn write_to_file(pfile, (const guint8*)&block_total_length, sizeof(guint32), bytes_written, err);\r\n}\r\ngboolean\r\npcapng_write_interface_statistics_block(FILE* pfile,\r\nguint32 interface_id,\r\nguint64 *bytes_written,\r\nconst char *comment,\r\nguint64 isb_starttime,\r\nguint64 isb_endtime,\r\nguint64 isb_ifrecv,\r\nguint64 isb_ifdrop,\r\nint *err)\r\n{\r\nstruct isb isb;\r\n#ifdef _WIN32\r\nFILETIME now;\r\n#else\r\nstruct timeval now;\r\n#endif\r\nstruct option option;\r\nguint32 block_total_length;\r\nguint32 options_length;\r\nguint64 timestamp;\r\n#ifdef _WIN32\r\nGetSystemTimeAsFileTime(&now);\r\ntimestamp = (((guint64)(guint32)now.dwHighDateTime) << 32) +\r\n(guint32)now.dwLowDateTime;\r\ntimestamp /= 10;\r\ntimestamp -= G_GUINT64_CONSTANT(11644473600000000);\r\n#else\r\ngettimeofday(&now, NULL);\r\ntimestamp = (guint64)(now.tv_sec) * 1000000 +\r\n(guint64)(now.tv_usec);\r\n#endif\r\nblock_total_length = (guint32)(sizeof(struct isb) + sizeof(guint32));\r\noptions_length = 0;\r\nif (isb_ifrecv != G_MAXUINT64) {\r\noptions_length += (guint32)(sizeof(struct option) +\r\nsizeof(guint64));\r\n}\r\nif (isb_ifdrop != G_MAXUINT64) {\r\noptions_length += (guint32)(sizeof(struct option) +\r\nsizeof(guint64));\r\n}\r\noptions_length += pcapng_count_string_option(comment);\r\nif (isb_starttime !=0) {\r\noptions_length += (guint32)(sizeof(struct option) +\r\nsizeof(guint64));\r\n}\r\nif (isb_endtime !=0) {\r\noptions_length += (guint32)(sizeof(struct option) +\r\nsizeof(guint64));\r\n}\r\nif (options_length != 0) {\r\noptions_length += (guint32)sizeof(struct option);\r\n}\r\nblock_total_length += options_length;\r\nisb.block_type = INTERFACE_STATISTICS_BLOCK_TYPE;\r\nisb.block_total_length = block_total_length;\r\nisb.interface_id = interface_id;\r\nisb.timestamp_high = (guint32)((timestamp>>32) & 0xffffffff);\r\nisb.timestamp_low = (guint32)(timestamp & 0xffffffff);\r\nif (!write_to_file(pfile, (const guint8*)&isb, sizeof(struct isb), bytes_written, err))\r\nreturn FALSE;\r\nif (!pcapng_write_string_option(pfile, OPT_COMMENT, comment,\r\nbytes_written, err))\r\nreturn FALSE;\r\nif (isb_starttime !=0) {\r\nguint32 high, low;\r\noption.type = ISB_STARTTIME;\r\noption.value_length = sizeof(guint64);\r\nhigh = (guint32)((isb_starttime>>32) & 0xffffffff);\r\nlow = (guint32)(isb_starttime & 0xffffffff);\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&high, sizeof(guint32), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&low, sizeof(guint32), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nif (isb_endtime !=0) {\r\nguint32 high, low;\r\noption.type = ISB_ENDTIME;\r\noption.value_length = sizeof(guint64);\r\nhigh = (guint32)((isb_endtime>>32) & 0xffffffff);\r\nlow = (guint32)(isb_endtime & 0xffffffff);\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&high, sizeof(guint32), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&low, sizeof(guint32), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nif (isb_ifrecv != G_MAXUINT64) {\r\noption.type = ISB_IFRECV;\r\noption.value_length = sizeof(guint64);\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&isb_ifrecv, sizeof(guint64), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nif (isb_ifdrop != G_MAXUINT64) {\r\noption.type = ISB_IFDROP;\r\noption.value_length = sizeof(guint64);\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\nif (!write_to_file(pfile, (const guint8*)&isb_ifdrop, sizeof(guint64), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nif (options_length != 0) {\r\noption.type = OPT_ENDOFOPT;\r\noption.value_length = 0;\r\nif (!write_to_file(pfile, (const guint8*)&option, sizeof(struct option), bytes_written, err))\r\nreturn FALSE;\r\n}\r\nreturn write_to_file(pfile, (const guint8*)&block_total_length, sizeof(guint32), bytes_written, err);\r\n}
