static int\r\nmpeg_resync(FILE_T fh, int *err)\r\n{\r\ngint64 offset = file_tell(fh);\r\nint count = 0;\r\nint byte = file_getc(fh);\r\nwhile (byte != EOF) {\r\nif (byte == 0xff && count > 0) {\r\nbyte = file_getc(fh);\r\nif (byte != EOF && (byte & 0xe0) == 0xe0)\r\nbreak;\r\n} else\r\nbyte = file_getc(fh);\r\ncount++;\r\n}\r\nif (file_seek(fh, offset, SEEK_SET, err) == -1)\r\nreturn 0;\r\nreturn count;\r\n}\r\nstatic gboolean\r\nmpeg_read_packet(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\ngboolean is_random, int *err, gchar **err_info)\r\n{\r\nmpeg_t *mpeg = (mpeg_t *)wth->priv;\r\nguint32 n;\r\nunsigned int packet_size;\r\nnstime_t ts = mpeg->now;\r\nif (!wtap_read_bytes_or_eof(fh, &n, sizeof n, err, err_info))\r\nreturn FALSE;\r\nif (file_seek(fh, -(gint64)(sizeof n), SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\nn = g_ntohl(n);\r\nif (PES_VALID(n)) {\r\ngint64 offset = file_tell(fh);\r\nguint8 stream;\r\nif (!file_skip(fh, 3, err))\r\nreturn FALSE;\r\nif (!wtap_read_bytes(fh, &stream, sizeof stream, err, err_info))\r\nreturn FALSE;\r\nif (stream == 0xba) {\r\nguint32 pack1;\r\nguint32 pack0;\r\nguint64 pack;\r\nguint8 stuffing;\r\nif (!wtap_read_bytes(fh, &pack1, sizeof pack1, err, err_info))\r\nreturn FALSE;\r\nif (!wtap_read_bytes(fh, &pack0, sizeof pack0, err, err_info))\r\nreturn FALSE;\r\npack = (guint64)g_ntohl(pack1) << 32 | g_ntohl(pack0);\r\nswitch (pack >> 62) {\r\ncase 1:\r\nif (!file_skip(fh, 1, err))\r\nreturn FALSE;\r\nif (!wtap_read_bytes(fh, &stuffing,\r\nsizeof stuffing, err, err_info))\r\nreturn FALSE;\r\nstuffing &= 0x07;\r\npacket_size = 14 + stuffing;\r\nif (!is_random) {\r\nguint64 bytes = pack >> 16;\r\nguint64 ts_val =\r\n(bytes >> 43 & 0x0007) << 30 |\r\n(bytes >> 27 & 0x7fff) << 15 |\r\n(bytes >> 11 & 0x7fff) << 0;\r\nguint ext = (guint)((bytes >> 1) & 0x1ff);\r\nguint64 cr = 300 * ts_val + ext;\r\nguint rem = (guint)(cr % SCRHZ);\r\nmpeg->now.secs\r\n= mpeg->t0 + (time_t)(cr / SCRHZ);\r\nmpeg->now.nsecs\r\n= (int)(G_GINT64_CONSTANT(1000000000) * rem / SCRHZ);\r\n}\r\nts = mpeg->now;\r\nbreak;\r\ndefault:\r\npacket_size = 12;\r\n}\r\n} else {\r\nguint16 length;\r\nif (!wtap_read_bytes(fh, &length, sizeof length, err, err_info))\r\nreturn FALSE;\r\nlength = g_ntohs(length);\r\npacket_size = 6 + length;\r\n}\r\nif (file_seek(fh, offset, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\n} else {\r\nstruct mpa mpa;\r\nMPA_UNMARSHAL(&mpa, n);\r\nif (MPA_VALID(&mpa)) {\r\npacket_size = MPA_BYTES(&mpa);\r\nif (!is_random) {\r\nmpeg->now.nsecs += MPA_DURATION_NS(&mpa);\r\nif (mpeg->now.nsecs >= 1000000000) {\r\nmpeg->now.secs++;\r\nmpeg->now.nsecs -= 1000000000;\r\n}\r\n}\r\n} else {\r\npacket_size = mpeg_resync(fh, err);\r\nif (packet_size == 0)\r\nreturn FALSE;\r\n}\r\n}\r\nif (!wtap_read_packet_bytes(fh, buf, packet_size, err, err_info))\r\nreturn FALSE;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nif (!is_random) {\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->ts = ts;\r\n}\r\nphdr->caplen = packet_size;\r\nphdr->len = packet_size;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nmpeg_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nreturn mpeg_read_packet(wth, wth->fh, &wth->phdr, wth->frame_buffer,\r\nFALSE, err, err_info);\r\n}\r\nstatic gboolean\r\nmpeg_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!mpeg_read_packet(wth, wth->random_fh, phdr, buf, TRUE, err,\r\nerr_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nwtap_open_return_val\r\nmpeg_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar magic_buf[16];\r\nstruct _mpeg_magic* m;\r\nmpeg_t *mpeg;\r\nif (!wtap_read_bytes(wth->fh, magic_buf, sizeof magic_buf,\r\nerr, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nfor (m=magic; m->match; m++) {\r\nif (memcmp(magic_buf, m->match, m->len) == 0)\r\ngoto good_magic;\r\n}\r\nreturn WTAP_OPEN_NOT_MINE;\r\ngood_magic:\r\nif (file_seek(wth->fh, 0, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_MPEG;\r\nwth->file_encap = WTAP_ENCAP_MPEG;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nwth->subtype_read = mpeg_read;\r\nwth->subtype_seek_read = mpeg_seek_read;\r\nwth->snapshot_length = 0;\r\nmpeg = (mpeg_t *)g_malloc(sizeof(mpeg_t));\r\nwth->priv = (void *)mpeg;\r\nmpeg->now.secs = 0;\r\nmpeg->now.nsecs = 0;\r\nmpeg->t0 = mpeg->now.secs;\r\nreturn WTAP_OPEN_MINE;\r\n}
