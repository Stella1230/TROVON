static void\r\niscsi_dissect_TargetAddress(packet_info *pinfo, proto_tree *tree _U_,char *val)\r\n{\r\naddress *addr = NULL;\r\nint port;\r\nchar *value = wmem_strdup(wmem_packet_scope(), val);\r\nchar *p = NULL, *pgt = NULL;\r\nif (value[0] == '[') {\r\np = strchr(value, ']');\r\nif (p != NULL) {\r\n*p = 0;\r\np += 2;\r\npgt = strchr(p, ',');\r\nif (pgt != NULL) {\r\n*pgt++ = 0;\r\n}\r\n}\r\n} else {\r\nint i0,i1,i2,i3;\r\nif (sscanf(value, "%d.%d.%d.%d", &i0,&i1,&i2,&i3) == 4) {\r\np = strchr(value, ':');\r\nif (p != NULL) {\r\nchar *addr_data;\r\n*p++ = 0;\r\npgt = strchr(p, ',');\r\nif (pgt != NULL) {\r\n*pgt++ = 0;\r\n}\r\naddr_data = (char *) wmem_alloc(wmem_packet_scope(), 4);\r\naddr_data[0] = i0;\r\naddr_data[1] = i1;\r\naddr_data[2] = i2;\r\naddr_data[3] = i3;\r\naddr = wmem_new(wmem_packet_scope(), address);\r\naddr->type = AT_IPv4;\r\naddr->len = 4;\r\naddr->data = addr_data;\r\nport = atoi(p);\r\n}\r\n}\r\n}\r\nif (addr && !pinfo->fd->flags.visited) {\r\nconversation_t *conv;\r\nconv = conversation_new(pinfo->num, addr, addr, PT_TCP, port, port, NO_ADDR2|NO_PORT2);\r\nif (conv == NULL) {\r\nreturn;\r\n}\r\nconversation_set_dissector(conv, iscsi_handle);\r\n}\r\n}\r\nstatic gint\r\naddTextKeys(packet_info *pinfo, proto_tree *tt, tvbuff_t *tvb, gint offset, guint32 text_len) {\r\nconst gint limit = offset + text_len;\r\nwhile(offset < limit) {\r\nchar *key = NULL, *value = NULL;\r\ngint len = tvb_strnlen(tvb, offset, limit - offset);\r\nif(len == -1) {\r\nlen = limit - offset;\r\n} else {\r\nlen = len + 1;\r\n}\r\nkey = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, len, ENC_ASCII);\r\nif (key == NULL) {\r\nbreak;\r\n}\r\nvalue = strchr(key, '=');\r\nif (value == NULL) {\r\nbreak;\r\n}\r\n*value++ = 0;\r\nif (!strcmp(key, "TargetAddress")) {\r\niscsi_dissect_TargetAddress(pinfo, tt, value);\r\n}\r\nproto_tree_add_item(tt, hf_iscsi_KeyValue, tvb, offset, len, ENC_ASCII|ENC_NA);\r\noffset += len;\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\nhandleHeaderDigest(iscsi_session_t *iscsi_session, proto_item *ti, tvbuff_t *tvb, guint offset, int headerLen) {\r\nint available_bytes = tvb_captured_length_remaining(tvb, offset);\r\nswitch(iscsi_session->header_digest){\r\ncase ISCSI_DIGEST_CRC32:\r\nif(available_bytes >= (headerLen + 4)) {\r\nguint32 crc = ~crc32c_tvb_offset_calculate(tvb, offset, headerLen, CRC32C_PRELOAD);\r\nguint32 sent = tvb_get_ntohl(tvb, offset + headerLen);\r\nif(crc == sent) {\r\nproto_tree_add_uint_format_value(ti, hf_iscsi_HeaderDigest32, tvb, offset + headerLen, 4, sent, "0x%08x (Good CRC32)", sent);\r\n} else {\r\nproto_tree_add_uint_format_value(ti, hf_iscsi_HeaderDigest32, tvb, offset + headerLen, 4, sent, "0x%08x (Bad CRC32, should be 0x%08x)", sent, crc);\r\n}\r\n}\r\nreturn offset + headerLen + 4;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset + headerLen;\r\n}\r\nstatic gint\r\nhandleDataDigest(iscsi_session_t *iscsi_session, proto_item *ti, tvbuff_t *tvb, guint offset, int dataLen) {\r\nint available_bytes = tvb_captured_length_remaining(tvb, offset);\r\nif (dataLen > 0) {\r\nswitch (iscsi_session->data_digest){\r\ncase ISCSI_DIGEST_CRC32:\r\nif(available_bytes >= (dataLen + 4)) {\r\nguint32 crc = ~crc32c_tvb_offset_calculate(tvb, offset, dataLen, CRC32C_PRELOAD);\r\nguint32 sent = tvb_get_ntohl(tvb, offset + dataLen);\r\nif(crc == sent) {\r\nproto_tree_add_uint_format_value(ti, hf_iscsi_DataDigest32, tvb, offset + dataLen, 4, sent, "0x%08x (Good CRC32)", sent);\r\n}\r\nelse {\r\nproto_tree_add_uint_format_value(ti, hf_iscsi_DataDigest32, tvb, offset + dataLen, 4, sent, "0x%08x (Bad CRC32, should be 0x%08x)", sent, crc);\r\n}\r\n}\r\nreturn offset + dataLen + 4;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn offset + dataLen;\r\n}\r\nstatic int\r\nhandleDataSegment(iscsi_session_t *iscsi_session, proto_item *ti, tvbuff_t *tvb, guint offset, guint dataSegmentLen, guint endOffset, int hf_id) {\r\nif(endOffset > offset) {\r\nint dataOffset = offset;\r\nint dataLen = MIN(dataSegmentLen, endOffset - offset);\r\nif(dataLen > 0) {\r\nproto_tree_add_item(ti, hf_id, tvb, offset, dataLen, ENC_NA);\r\noffset += dataLen;\r\n}\r\nif(offset < endOffset && (offset & 3) != 0) {\r\nint padding = 4 - (offset & 3);\r\nproto_tree_add_item(ti, hf_iscsi_Padding, tvb, offset, padding, ENC_NA);\r\noffset += padding;\r\n}\r\nif(dataSegmentLen > 0 && offset < endOffset)\r\noffset = handleDataDigest(iscsi_session, ti, tvb, dataOffset, offset - dataOffset);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nhandleDataSegmentAsTextKeys(iscsi_session_t *iscsi_session, packet_info *pinfo, proto_item *ti, tvbuff_t *tvb, guint offset, guint dataSegmentLen, guint endOffset, int digestsActive) {\r\nif(endOffset > offset) {\r\nint dataOffset = offset;\r\nint textLen = MIN(dataSegmentLen, endOffset - offset);\r\nif(textLen > 0) {\r\nproto_tree *tt = proto_tree_add_subtree(ti, tvb, offset, textLen,\r\nett_iscsi_KeyValues, NULL, "Key/Value Pairs");\r\noffset = addTextKeys(pinfo, tt, tvb, offset, textLen);\r\n}\r\nif(offset < endOffset && (offset & 3) != 0) {\r\nint padding = 4 - (offset & 3);\r\nproto_tree_add_item(ti, hf_iscsi_Padding, tvb, offset, padding, ENC_NA);\r\noffset += padding;\r\n}\r\nif(digestsActive && dataSegmentLen > 0 && offset < endOffset)\r\noffset = handleDataDigest(iscsi_session, ti, tvb, dataOffset, offset - dataOffset);\r\n}\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_iscsi_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset, guint8 opcode, const char *opcode_str, guint32 data_segment_len, iscsi_session_t *iscsi_session, conversation_t *conversation) {\r\nguint original_offset = offset;\r\nproto_tree *ti = NULL;\r\nguint8 scsi_status = 0;\r\ngboolean S_bit=FALSE;\r\ngboolean A_bit=FALSE;\r\nguint cdb_offset = offset + 32;\r\nguint end_offset = offset + tvb_captured_length_remaining(tvb, offset);\r\niscsi_conv_data_t *cdata = NULL;\r\nint paddedDataSegmentLength = data_segment_len;\r\nguint16 lun=0xffff;\r\nguint immediate_data_length=0;\r\nguint immediate_data_offset=0;\r\nitl_nexus_t *itl=NULL;\r\nguint ahs_cdb_length=0;\r\nguint ahs_cdb_offset=0;\r\nguint32 data_offset=0;\r\nwmem_tree_key_t key[3];\r\nguint32 itt;\r\nif(paddedDataSegmentLength & 3)\r\npaddedDataSegmentLength += 4 - (paddedDataSegmentLength & 3);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "iSCSI");\r\nitt = tvb_get_ntohl(tvb, offset+16);\r\nkey[0].length = 1;\r\nkey[0].key = &itt;\r\nkey[1].length = 1;\r\nkey[1].key = &pinfo->num;\r\nkey[2].length = 0;\r\nkey[2].key = NULL;\r\nif (!PINFO_FD_VISITED(pinfo)) {\r\nif (opcode == ISCSI_OPCODE_SCSI_COMMAND) {\r\ncdata = wmem_new(wmem_file_scope(), iscsi_conv_data_t);\r\ncdata->itlq.lun = 0xffff;\r\ncdata->itlq.scsi_opcode = 0xffff;\r\ncdata->itlq.task_flags = 0;\r\ncdata->itlq.data_length = 0;\r\ncdata->itlq.bidir_data_length = 0;\r\ncdata->itlq.fc_time = pinfo->abs_ts;\r\ncdata->itlq.first_exchange_frame = 0;\r\ncdata->itlq.last_exchange_frame = 0;\r\ncdata->itlq.flags = 0;\r\ncdata->itlq.alloc_len = 0;\r\ncdata->itlq.extra_data = NULL;\r\ncdata->data_in_frame = 0;\r\ncdata->data_out_frame = 0;\r\ncdata->itt = itt;\r\nwmem_tree_insert32_array(iscsi_session->itlq, key, (void *)cdata);\r\n} else {\r\ncdata = (iscsi_conv_data_t *)wmem_tree_lookup32_array_le(iscsi_session->itlq, key);\r\nif (cdata && (cdata->itt != itt)) {\r\ncdata = NULL;\r\n}\r\n}\r\n} else {\r\ncdata = (iscsi_conv_data_t *)wmem_tree_lookup32_array_le(iscsi_session->itlq, key);\r\nif (cdata && (cdata->itt != itt)) {\r\ncdata = NULL;\r\n}\r\n}\r\nif(!cdata) {\r\ncdata = wmem_new(wmem_packet_scope(), iscsi_conv_data_t);\r\ncdata->itlq.lun = 0xffff;\r\ncdata->itlq.scsi_opcode = 0xffff;\r\ncdata->itlq.task_flags = 0;\r\ncdata->itlq.data_length = 0;\r\ncdata->itlq.bidir_data_length = 0;\r\ncdata->itlq.fc_time = pinfo->abs_ts;\r\ncdata->itlq.first_exchange_frame = 0;\r\ncdata->itlq.last_exchange_frame = 0;\r\ncdata->itlq.flags = 0;\r\ncdata->itlq.alloc_len = 0;\r\ncdata->itlq.extra_data = NULL;\r\ncdata->data_in_frame = 0;\r\ncdata->data_out_frame = 0;\r\ncdata->itt = itt;\r\n}\r\nif (opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\r\nopcode == ISCSI_OPCODE_SCSI_DATA_IN) {\r\nscsi_status = tvb_get_guint8 (tvb, offset+3);\r\n}\r\nif ((opcode == ISCSI_OPCODE_SCSI_RESPONSE) ||\r\n(opcode == ISCSI_OPCODE_SCSI_DATA_IN) ||\r\n(opcode == ISCSI_OPCODE_SCSI_DATA_OUT)) {\r\nswitch(opcode){\r\ncase ISCSI_OPCODE_SCSI_RESPONSE:\r\ncdata->itlq.last_exchange_frame=pinfo->num;\r\nbreak;\r\ncase ISCSI_OPCODE_SCSI_DATA_IN:\r\nif(tvb_get_guint8(tvb, offset+1)&ISCSI_SCSI_DATA_FLAG_S){\r\ncdata->itlq.last_exchange_frame=pinfo->num;\r\n}\r\ncdata->data_in_frame=pinfo->num;\r\nbreak;\r\ncase ISCSI_OPCODE_SCSI_DATA_OUT:\r\ncdata->data_out_frame=pinfo->num;\r\nbreak;\r\n}\r\n} else if (opcode == ISCSI_OPCODE_SCSI_COMMAND) {\r\nif(tvb_get_guint8(tvb, offset+8)&0x40){\r\nlun=tvb_get_guint8(tvb,offset+8)&0x3f;\r\nlun<<=8;\r\nlun|=tvb_get_guint8(tvb,offset+9);\r\n} else {\r\nlun=tvb_get_guint8(tvb,offset+9);\r\n}\r\ncdata->itlq.lun=lun;\r\ncdata->itlq.first_exchange_frame=pinfo->num;\r\nitl=(itl_nexus_t *)wmem_map_lookup(iscsi_session->itl, GUINT_TO_POINTER((gulong)lun));\r\nif(!itl){\r\nitl=wmem_new(wmem_file_scope(), itl_nexus_t);\r\nitl->cmdset=0xff;\r\nitl->conversation=conversation;\r\nwmem_map_insert(iscsi_session->itl, GUINT_TO_POINTER((gulong)lun), itl);\r\n}\r\n}\r\nif(!itl){\r\nitl=(itl_nexus_t *)wmem_map_lookup(iscsi_session->itl, GUINT_TO_POINTER((gulong)cdata->itlq.lun));\r\n}\r\nif (opcode != ISCSI_OPCODE_SCSI_COMMAND) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, opcode_str);\r\nif (opcode == ISCSI_OPCODE_SCSI_RESPONSE ||\r\n(opcode == ISCSI_OPCODE_SCSI_DATA_IN &&\r\n(tvb_get_guint8(tvb, offset + 1) & ISCSI_SCSI_DATA_FLAG_S))) {\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " (%s)",\r\nval_to_str (scsi_status, scsi_status_val, "0x%x"));\r\n}\r\nelse if (opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\r\nguint16 login_status = tvb_get_ntohs(tvb, offset+36);\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " (%s)",\r\nval_to_str (login_status, iscsi_login_status, "0x%x"));\r\n}\r\nelse if (opcode == ISCSI_OPCODE_LOGOUT_COMMAND) {\r\nguint8 logoutReason;\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\r\nlogoutReason = tvb_get_guint8(tvb, offset+11);\r\n} else if(iscsi_protocol_version >= ISCSI_PROTOCOL_DRAFT13) {\r\nlogoutReason = tvb_get_guint8(tvb, offset+1) & 0x7f;\r\n}\r\nelse {\r\nlogoutReason = tvb_get_guint8(tvb, offset+23);\r\n}\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " (%s)",\r\nval_to_str (logoutReason, iscsi_logout_reasons, "0x%x"));\r\n}\r\nelse if (opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION) {\r\nguint8 tmf = tvb_get_guint8(tvb, offset + 1) & 0x7f;\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " (%s)",\r\nval_to_str (tmf, iscsi_task_management_functions, "0x%x"));\r\n}\r\nelse if (opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE) {\r\nguint8 resp = tvb_get_guint8(tvb, offset + 2);\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " (%s)",\r\nval_to_str (resp, iscsi_task_management_responses, "0x%x"));\r\n}\r\nelse if (opcode == ISCSI_OPCODE_REJECT) {\r\nguint8 reason = tvb_get_guint8(tvb, offset + 2);\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " (%s)",\r\nval_to_str (reason, iscsi_reject_reasons, "0x%x"));\r\n}\r\nelse if (opcode == ISCSI_OPCODE_ASYNC_MESSAGE) {\r\nguint8 asyncEvent = tvb_get_guint8(tvb, offset + 36);\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " (%s)",\r\nval_to_str (asyncEvent, iscsi_asyncevents, "0x%x"));\r\n}\r\n}\r\nif (tree) {\r\nproto_item *tp;\r\ntp = proto_tree_add_protocol_format(tree, proto_iscsi, tvb,\r\noffset, -1, "iSCSI (%s)",\r\nopcode_str);\r\nti = proto_item_add_subtree(tp, ett_iscsi);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_Opcode, tvb,\r\noffset + 0, 1, opcode);\r\nif((opcode & TARGET_OPCODE_BIT) == 0) {\r\ngint b = tvb_get_guint8(tvb, offset + 0);\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\r\nif(opcode != ISCSI_OPCODE_SCSI_DATA_OUT &&\r\nopcode != ISCSI_OPCODE_LOGOUT_COMMAND &&\r\nopcode != ISCSI_OPCODE_SNACK_REQUEST)\r\nproto_tree_add_boolean(ti, hf_iscsi_X, tvb, offset + 0, 1, b);\r\n}\r\nif(opcode != ISCSI_OPCODE_SCSI_DATA_OUT &&\r\nopcode != ISCSI_OPCODE_LOGIN_COMMAND &&\r\nopcode != ISCSI_OPCODE_SNACK_REQUEST)\r\nproto_tree_add_boolean(ti, hf_iscsi_I, tvb, offset + 0, 1, b);\r\n}\r\nif(opcode == ISCSI_OPCODE_NOP_OUT) {\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_TargetTransferTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_CmdSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpStatSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\noffset = handleDataSegment(iscsi_session, ti, tvb, offset, data_segment_len, end_offset, hf_iscsi_ping_data);\r\n} else if(opcode == ISCSI_OPCODE_NOP_IN) {\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_TargetTransferTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\noffset = handleDataSegment(iscsi_session, ti, tvb, offset, data_segment_len, end_offset, hf_iscsi_ping_data);\r\n} else if(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\r\nguint32 ahsLen = tvb_get_guint8(tvb, offset + 4) * 4;\r\n{\r\ngint b = tvb_get_guint8(tvb, offset + 1);\r\nstatic const int * flags[] = {\r\n&hf_iscsi_SCSICommand_F,\r\n&hf_iscsi_SCSICommand_R,\r\n&hf_iscsi_SCSICommand_W,\r\n&hf_iscsi_SCSICommand_Attr,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(tree, tvb, offset + 1, hf_iscsi_Flags, ett_iscsi_Flags, flags, ENC_NA);\r\nif(b&0x40){\r\ncdata->itlq.task_flags|=SCSI_DATA_READ;\r\n}\r\nif(b&0x20){\r\ncdata->itlq.task_flags|=SCSI_DATA_WRITE;\r\n}\r\n}\r\nif(iscsi_protocol_version < ISCSI_PROTOCOL_DRAFT12) {\r\nproto_tree_add_item(ti, hf_iscsi_SCSICommand_CRN, tvb, offset + 3, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpectedDataTransferLength, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\ncdata->itlq.data_length=tvb_get_ntohl(tvb, offset+20);\r\nproto_tree_add_item(ti, hf_iscsi_CmdSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpStatSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nif(ahsLen > 0) {\r\nguint ahs_offset=offset+48;\r\nguint16 ahs_length=0;\r\nguint8 ahs_type=0;\r\nwhile(ahs_offset<(offset+48+ahsLen)){\r\nahs_length=tvb_get_ntohs(tvb, ahs_offset);\r\nproto_tree_add_item(ti, hf_iscsi_AHS_length, tvb, ahs_offset, 2, ENC_BIG_ENDIAN);\r\nahs_offset+=2;\r\nahs_type=tvb_get_guint8(tvb, ahs_offset);\r\nproto_tree_add_item(ti, hf_iscsi_AHS_type, tvb, ahs_offset, 1, ENC_BIG_ENDIAN);\r\nahs_offset++;\r\nswitch(ahs_type){\r\ncase 0x01:\r\nahs_cdb_offset=ahs_offset+1;\r\nahs_cdb_length=ahs_length-1;\r\nproto_tree_add_item(ti, hf_iscsi_AHS_extended_cdb, tvb, ahs_cdb_offset, ahs_cdb_length, ENC_NA);\r\nahs_offset+=ahs_length;\r\nbreak;\r\ncase 0x02:\r\nahs_offset++;\r\nproto_tree_add_item(ti, hf_iscsi_AHS_read_data_length, tvb, ahs_offset, 4, ENC_BIG_ENDIAN);\r\ncdata->itlq.bidir_data_length=tvb_get_ntohl(tvb, ahs_offset);\r\nahs_offset+=4;\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(ti, hf_iscsi_AHS_blob, tvb, ahs_offset, ahs_length, ENC_NA);\r\nahs_offset+=ahs_length;\r\n}\r\nif(ahs_offset & 3){\r\nahs_offset=(ahs_offset+3) & ~3;\r\n}\r\n}\r\n}\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48 + ahsLen);\r\nimmediate_data_offset=offset;\r\noffset = handleDataSegment(iscsi_session, ti, tvb, offset, data_segment_len, end_offset, hf_iscsi_immediate_data);\r\nimmediate_data_length=offset-immediate_data_offset;\r\n} else if(opcode == ISCSI_OPCODE_SCSI_RESPONSE) {\r\nstatic const int * flags[] = {\r\n&hf_iscsi_SCSIResponse_o,\r\n&hf_iscsi_SCSIResponse_u,\r\n&hf_iscsi_SCSIResponse_O,\r\n&hf_iscsi_SCSIResponse_U,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(tree, tvb, offset + 1, hf_iscsi_Flags, ett_iscsi_Flags, flags, ENC_NA);\r\nproto_tree_add_item(ti, hf_iscsi_SCSIResponse_Response, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_SCSIResponse_Status, tvb, offset + 3, 1, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version <= ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_SCSIResponse_ResidualCount, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpDataSN, tvb, offset + 36, 4, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version <= ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_SCSIResponse_BidiReadResidualCount, tvb, offset + 44, 4, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(ti, hf_iscsi_SCSIResponse_BidiReadResidualCount, tvb, offset + 40, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_SCSIResponse_ResidualCount, tvb, offset + 44, 4, ENC_BIG_ENDIAN);\r\n}\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\nhandleDataDigest(iscsi_session, ti, tvb, offset, paddedDataSegmentLength);\r\n} else if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION) {\r\nproto_tree_add_item(ti, hf_iscsi_TaskManagementFunction_Function, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\n}\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_TaskManagementFunction_ReferencedTaskTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_CmdSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpStatSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_RefCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\n} else if(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE) {\r\nproto_tree_add_item(ti, hf_iscsi_TaskManagementFunction_Response, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version <= ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version < ISCSI_PROTOCOL_DRAFT12) {\r\nproto_tree_add_item(ti, hf_iscsi_TaskManagementFunction_ReferencedTaskTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\n} else if(opcode == ISCSI_OPCODE_LOGIN_COMMAND) {\r\nint digestsActive = 0;\r\n{\r\ngint b = tvb_get_guint8(tvb, offset + 1);\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\r\nif((b & CSG_MASK) >= ISCSI_CSG_OPERATIONAL_NEGOTIATION)\r\ndigestsActive = 1;\r\n}\r\n#if 0\r\nproto_item *tf = proto_tree_add_uint(ti, hf_iscsi_Flags, tvb, offset + 1, 1, b);\r\nproto_tree *tt = proto_item_add_subtree(tf, ett_iscsi_Flags);\r\n#endif\r\nproto_tree_add_boolean(ti, hf_iscsi_Login_T, tvb, offset + 1, 1, b);\r\nif(iscsi_protocol_version >= ISCSI_PROTOCOL_DRAFT13) {\r\nproto_tree_add_boolean(ti, hf_iscsi_Login_C, tvb, offset + 1, 1, b);\r\n}\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\r\nproto_tree_add_boolean(ti, hf_iscsi_Login_X, tvb, offset + 1, 1, b);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_Login_CSG, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nif(b&0x80){\r\nproto_tree_add_item(ti, hf_iscsi_Login_NSG, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_VersionMax, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_VersionMin, tvb, offset + 3, 1, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\r\nproto_tree_add_item(ti, hf_iscsi_CID, tvb, offset + 8, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ISID8, tvb, offset + 12, 2, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_item *tf = proto_tree_add_item(ti, hf_iscsi_ISID, tvb, offset + 8, 6, ENC_NA);\r\nproto_tree *tt = proto_item_add_subtree(tf, ett_iscsi_ISID);\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(tt, hf_iscsi_ISID_Type, tvb, offset + 8, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_NamingAuthority, tvb, offset + 9, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_Qualifier, tvb, offset + 12, 2, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(tt, hf_iscsi_ISID_t, tvb, offset + 8, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_a, tvb, offset + 8, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_b, tvb, offset + 9, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_c, tvb, offset + 11, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_d, tvb, offset + 12, 2, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nif(iscsi_protocol_version < ISCSI_PROTOCOL_DRAFT12) {\r\nproto_tree_add_item(ti, hf_iscsi_TSID, tvb, offset + 14, 2, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(ti, hf_iscsi_TSIH, tvb, offset + 14, 2, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT08) {\r\nproto_tree_add_item(ti, hf_iscsi_CID, tvb, offset + 20, 2, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_CmdSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpStatSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nif(digestsActive){\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\n} else {\r\noffset += 48;\r\n}\r\noffset = handleDataSegmentAsTextKeys(iscsi_session, pinfo, ti, tvb, offset, data_segment_len, end_offset, digestsActive);\r\n} else if(opcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\r\nint digestsActive = 0;\r\n{\r\ngint b = tvb_get_guint8(tvb, offset + 1);\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\r\nif((b & CSG_MASK) >= ISCSI_CSG_OPERATIONAL_NEGOTIATION)\r\ndigestsActive = 1;\r\n}\r\n#if 0\r\nproto_item *tf = proto_tree_add_uint(ti, hf_iscsi_Flags, tvb, offset + 1, 1, b);\r\nproto_tree *tt = proto_item_add_subtree(tf, ett_iscsi_Flags);\r\n#endif\r\nproto_tree_add_boolean(ti, hf_iscsi_Login_T, tvb, offset + 1, 1, b);\r\nif(iscsi_protocol_version >= ISCSI_PROTOCOL_DRAFT13) {\r\nproto_tree_add_boolean(ti, hf_iscsi_Login_C, tvb, offset + 1, 1, b);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_Login_CSG, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nif(b&0x80){\r\nproto_tree_add_item(ti, hf_iscsi_Login_NSG, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_VersionMax, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_VersionActive, tvb, offset + 3, 1, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\r\nproto_tree_add_item(ti, hf_iscsi_ISID8, tvb, offset + 12, 2, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_item *tf = proto_tree_add_item(ti, hf_iscsi_ISID, tvb, offset + 8, 6, ENC_NA);\r\nproto_tree *tt = proto_item_add_subtree(tf, ett_iscsi_ISID);\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(tt, hf_iscsi_ISID_Type, tvb, offset + 8, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_NamingAuthority, tvb, offset + 9, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_Qualifier, tvb, offset + 12, 2, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(tt, hf_iscsi_ISID_t, tvb, offset + 8, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_a, tvb, offset + 8, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_b, tvb, offset + 9, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_c, tvb, offset + 11, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tt, hf_iscsi_ISID_d, tvb, offset + 12, 2, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nif(iscsi_protocol_version < ISCSI_PROTOCOL_DRAFT12) {\r\nproto_tree_add_item(ti, hf_iscsi_TSID, tvb, offset + 14, 2, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(ti, hf_iscsi_TSIH, tvb, offset + 14, 2, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_Login_Status, tvb, offset + 36, 2, ENC_BIG_ENDIAN);\r\nif(digestsActive){\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\n} else {\r\noffset += 48;\r\n}\r\noffset = handleDataSegmentAsTextKeys(iscsi_session, pinfo, ti, tvb, offset, data_segment_len, end_offset, digestsActive);\r\n} else if(opcode == ISCSI_OPCODE_TEXT_COMMAND) {\r\n{\r\ngint b = tvb_get_guint8(tvb, offset + 1);\r\nproto_item *tf = proto_tree_add_uint(ti, hf_iscsi_Flags, tvb, offset + 1, 1, b);\r\nproto_tree *tt = proto_item_add_subtree(tf, ett_iscsi_Flags);\r\nproto_tree_add_boolean(tt, hf_iscsi_Text_F, tvb, offset + 1, 1, b);\r\nif(iscsi_protocol_version >= ISCSI_PROTOCOL_DRAFT13) {\r\nproto_tree_add_boolean(tt, hf_iscsi_Text_C, tvb, offset + 1, 1, b);\r\n}\r\n}\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_TargetTransferTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_CmdSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpStatSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\noffset = handleDataSegmentAsTextKeys(iscsi_session, pinfo, ti, tvb, offset, data_segment_len, end_offset, TRUE);\r\n} else if(opcode == ISCSI_OPCODE_TEXT_RESPONSE) {\r\n{\r\ngint b = tvb_get_guint8(tvb, offset + 1);\r\nproto_item *tf = proto_tree_add_uint(ti, hf_iscsi_Flags, tvb, offset + 1, 1, b);\r\nproto_tree *tt = proto_item_add_subtree(tf, ett_iscsi_Flags);\r\nproto_tree_add_boolean(tt, hf_iscsi_Text_F, tvb, offset + 1, 1, b);\r\nif(iscsi_protocol_version >= ISCSI_PROTOCOL_DRAFT13) {\r\nproto_tree_add_boolean(tt, hf_iscsi_Text_C, tvb, offset + 1, 1, b);\r\n}\r\n}\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_TargetTransferTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\noffset = handleDataSegmentAsTextKeys(iscsi_session, pinfo, ti, tvb, offset, data_segment_len, end_offset, TRUE);\r\n} else if(opcode == ISCSI_OPCODE_SCSI_DATA_OUT) {\r\nstatic const int * flags[] = {\r\n&hf_iscsi_SCSIData_F,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(tree, tvb, offset + 1, hf_iscsi_Flags, ett_iscsi_Flags, flags, ENC_NA);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_TargetTransferTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpStatSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_DataSN, tvb, offset + 36, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_BufferOffset, tvb, offset + 40, 4, ENC_BIG_ENDIAN);\r\ndata_offset=tvb_get_ntohl(tvb, offset+40);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\nhandleDataDigest(iscsi_session, ti, tvb, offset, paddedDataSegmentLength);\r\n} else if(opcode == ISCSI_OPCODE_SCSI_DATA_IN) {\r\n{\r\nconst int * scsi_data_in[] = {\r\n&hf_iscsi_SCSIData_F,\r\n&hf_iscsi_SCSIData_O,\r\n&hf_iscsi_SCSIData_U,\r\n&hf_iscsi_SCSIData_S,\r\nNULL\r\n};\r\nconst int * scsi_data_in_draft08[] = {\r\n&hf_iscsi_SCSIData_F,\r\n&hf_iscsi_SCSIData_A,\r\n&hf_iscsi_SCSIData_O,\r\n&hf_iscsi_SCSIData_U,\r\n&hf_iscsi_SCSIData_S,\r\nNULL\r\n};\r\ngint b;\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT08) {\r\nproto_tree_add_bitmask_with_flags(ti, tvb, offset+1, hf_iscsi_Flags,\r\nett_iscsi_Flags, scsi_data_in_draft08, ENC_NA, BMT_NO_APPEND);\r\n} else {\r\nproto_tree_add_bitmask_with_flags(ti, tvb, offset+1, hf_iscsi_Flags,\r\nett_iscsi_Flags, scsi_data_in, ENC_NA, BMT_NO_APPEND);\r\n}\r\nb = tvb_get_guint8(tvb, offset + 1);\r\nif(b&ISCSI_SCSI_DATA_FLAG_S){\r\nS_bit=TRUE;\r\n}\r\nif(b&ISCSI_SCSI_DATA_FLAG_A){\r\nA_bit=TRUE;\r\n}\r\n}\r\nif(S_bit){\r\nproto_tree_add_item(ti, hf_iscsi_SCSIResponse_Status, tvb, offset + 3, 1, ENC_BIG_ENDIAN);\r\n}\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\ncdata->itlq.data_length=tvb_get_ntoh24(tvb, offset + 5);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nif (A_bit) {\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\n}\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version <= ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_SCSIData_ResidualCount, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nif (A_bit) {\r\nproto_tree_add_item(ti, hf_iscsi_TargetTransferTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_DataSN, tvb, offset + 36, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_BufferOffset, tvb, offset + 40, 4, ENC_BIG_ENDIAN);\r\ndata_offset=tvb_get_ntohl(tvb, offset+40);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_SCSIData_ResidualCount, tvb, offset + 44, 4, ENC_BIG_ENDIAN);\r\n}\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\nhandleDataDigest(iscsi_session, ti, tvb, offset, paddedDataSegmentLength);\r\n} else if(opcode == ISCSI_OPCODE_LOGOUT_COMMAND) {\r\nif(iscsi_protocol_version >= ISCSI_PROTOCOL_DRAFT13) {\r\nproto_tree_add_item(ti, hf_iscsi_Logout_Reason, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\n}\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\n}\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\r\nproto_tree_add_item(ti, hf_iscsi_CID, tvb, offset + 8, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_Logout_Reason, tvb, offset + 11, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT08) {\r\nproto_tree_add_item(ti, hf_iscsi_CID, tvb, offset + 20, 2, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version < ISCSI_PROTOCOL_DRAFT13) {\r\nproto_tree_add_item(ti, hf_iscsi_Logout_Reason, tvb, offset + 23, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_CmdSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpStatSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\n} else if(opcode == ISCSI_OPCODE_LOGOUT_RESPONSE) {\r\nproto_tree_add_item(ti, hf_iscsi_Logout_Response, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_Time2Wait, tvb, offset + 40, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_Time2Retain, tvb, offset + 42, 2, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\n} else if(opcode == ISCSI_OPCODE_SNACK_REQUEST) {\r\n{\r\n#if 0\r\ngint b = tvb_get_guint8(tvb, offset + 1);\r\nproto_item *tf = proto_tree_add_uint(ti, hf_iscsi_Flags, tvb, offset + 1, 1, b);\r\nproto_tree *tt = proto_item_add_subtree(tf, ett_iscsi_Flags);\r\n#endif\r\nproto_tree_add_item(ti, hf_iscsi_snack_type, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\n}\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version <= ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_BegRun, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_RunLength, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpStatSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpDataSN, tvb, offset + 36, 4, ENC_BIG_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(ti, hf_iscsi_TargetTransferTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpStatSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_BegRun, tvb, offset + 40, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_RunLength, tvb, offset + 44, 4, ENC_BIG_ENDIAN);\r\n}\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\n} else if(opcode == ISCSI_OPCODE_R2T) {\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\n}\r\nproto_tree_add_item(ti, hf_iscsi_InitiatorTaskTag, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_TargetTransferTag, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_R2TSN, tvb, offset + 36, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_BufferOffset, tvb, offset + 40, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_DesiredDataLength, tvb, offset + 44, 4, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\n} else if(opcode == ISCSI_OPCODE_ASYNC_MESSAGE) {\r\nint dsl, snsl;\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\ndsl=tvb_get_ntoh24(tvb, offset+5);\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\ndissect_scsi_lun(ti, tvb, offset + 8);\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_AsyncEvent, tvb, offset + 36, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_EventVendorCode, tvb, offset + 37, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_Parameter1, tvb, offset + 38, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_Parameter2, tvb, offset + 40, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_Parameter3, tvb, offset + 42, 2, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\nif(dsl){\r\nsnsl=tvb_get_ntohs(tvb, offset);\r\noffset+=2;\r\nif(snsl){\r\ntvbuff_t *data_tvb;\r\nint tvb_len, tvb_rlen;\r\ntvb_len=tvb_captured_length_remaining(tvb, offset);\r\nif(tvb_len>snsl)\r\ntvb_len=snsl;\r\ntvb_rlen=tvb_reported_length_remaining(tvb, offset);\r\nif(tvb_rlen>snsl)\r\ntvb_rlen=snsl;\r\ndata_tvb=tvb_new_subset(tvb, offset, tvb_len, tvb_rlen);\r\ndissect_scsi_snsinfo (data_tvb, pinfo, tree, 0,\r\ntvb_len,\r\n&cdata->itlq, itl);\r\noffset+=snsl;\r\n}\r\nif((end_offset-offset)>0){\r\nproto_tree_add_item(ti, hf_iscsi_async_event_data, tvb, offset, end_offset-offset, ENC_NA);\r\n}\r\n}\r\noffset=end_offset;\r\n} else if(opcode == ISCSI_OPCODE_REJECT) {\r\nproto_tree *tt;\r\nint next_opcode;\r\nconst char *next_opcode_str;\r\nproto_tree_add_item(ti, hf_iscsi_Reject_Reason, tvb, offset + 2, 1, ENC_BIG_ENDIAN);\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\nproto_tree_add_item(ti, hf_iscsi_StatSN, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_ExpCmdSN, tvb, offset + 28, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_MaxCmdSN, tvb, offset + 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ti, hf_iscsi_DataSN, tvb, offset + 36, 4, ENC_BIG_ENDIAN);\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\nnext_opcode = tvb_get_guint8(tvb, offset) & 0x3f;\r\nnext_opcode_str = try_val_to_str(next_opcode, iscsi_opcodes);\r\ntt = proto_tree_add_subtree(ti, tvb, offset, -1, ett_iscsi_RejectHeader, NULL, "Rejected Header");\r\ndissect_iscsi_pdu(tvb, pinfo, tt, offset, next_opcode, next_opcode_str, 0, iscsi_session, conversation);\r\n} else if(opcode == ISCSI_OPCODE_VENDOR_SPECIFIC_I0 ||\r\nopcode == ISCSI_OPCODE_VENDOR_SPECIFIC_I1 ||\r\nopcode == ISCSI_OPCODE_VENDOR_SPECIFIC_I2 ||\r\nopcode == ISCSI_OPCODE_VENDOR_SPECIFIC_T0 ||\r\nopcode == ISCSI_OPCODE_VENDOR_SPECIFIC_T1 ||\r\nopcode == ISCSI_OPCODE_VENDOR_SPECIFIC_T2) {\r\nif(iscsi_protocol_version > ISCSI_PROTOCOL_DRAFT09) {\r\nproto_tree_add_item(ti, hf_iscsi_TotalAHSLength, tvb, offset + 4, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_uint(ti, hf_iscsi_DataSegmentLength, tvb, offset + 5, 3, tvb_get_ntoh24(tvb, offset + 5));\r\noffset = handleHeaderDigest(iscsi_session, ti, tvb, offset, 48);\r\noffset = handleDataSegment(iscsi_session, ti, tvb, offset, data_segment_len, end_offset, hf_iscsi_vendor_specific_data);\r\n}\r\nswitch(opcode){\r\ncase ISCSI_OPCODE_SCSI_RESPONSE:\r\nif (cdata->itlq.first_exchange_frame){\r\nnstime_t delta_time;\r\nproto_tree_add_uint(ti, hf_iscsi_request_frame, tvb, 0, 0, cdata->itlq.first_exchange_frame);\r\nnstime_delta(&delta_time, &pinfo->abs_ts, &cdata->itlq.fc_time);\r\nproto_tree_add_time(ti, hf_iscsi_time, tvb, 0, 0, &delta_time);\r\n}\r\nif (cdata->data_in_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_data_in_frame, tvb, 0, 0, cdata->data_in_frame);\r\nif (cdata->data_out_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_data_out_frame, tvb, 0, 0, cdata->data_out_frame);\r\nbreak;\r\ncase ISCSI_OPCODE_SCSI_DATA_IN:\r\nif(!S_bit){\r\nif (cdata->itlq.first_exchange_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_request_frame, tvb, 0, 0, cdata->itlq.first_exchange_frame);\r\nif (cdata->itlq.last_exchange_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_response_frame, tvb, 0, 0, cdata->itlq.last_exchange_frame);\r\n} else {\r\nif (cdata->itlq.first_exchange_frame){\r\nnstime_t delta_time;\r\nproto_tree_add_uint(ti, hf_iscsi_request_frame, tvb, 0, 0, cdata->itlq.first_exchange_frame);\r\nnstime_delta(&delta_time, &pinfo->abs_ts, &cdata->itlq.fc_time);\r\nproto_tree_add_time(ti, hf_iscsi_time, tvb, 0, 0, &delta_time);\r\n}\r\n}\r\nif (cdata->data_out_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_data_out_frame, tvb, 0, 0, cdata->data_out_frame);\r\nbreak;\r\ncase ISCSI_OPCODE_SCSI_DATA_OUT:\r\nif (cdata->itlq.first_exchange_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_request_frame, tvb, 0, 0, cdata->itlq.first_exchange_frame);\r\nif (cdata->data_in_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_data_in_frame, tvb, 0, 0, cdata->data_in_frame);\r\nif (cdata->itlq.last_exchange_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_response_frame, tvb, 0, 0, cdata->itlq.last_exchange_frame);\r\nbreak;\r\ncase ISCSI_OPCODE_SCSI_COMMAND:\r\nif (cdata->data_in_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_data_in_frame, tvb, 0, 0, cdata->data_in_frame);\r\nif (cdata->data_out_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_data_out_frame, tvb, 0, 0, cdata->data_out_frame);\r\nif (cdata->itlq.last_exchange_frame)\r\nproto_tree_add_uint(ti, hf_iscsi_response_frame, tvb, 0, 0, cdata->itlq.last_exchange_frame);\r\nbreak;\r\n}\r\nproto_item_set_len(ti, offset - original_offset);\r\nif((opcode & ((iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08)?\r\n~(X_BIT | I_BIT) :\r\n~I_BIT)) == ISCSI_OPCODE_SCSI_COMMAND) {\r\ntvbuff_t *cdb_tvb, *data_tvb;\r\nint tvb_len, tvb_rlen;\r\ntvb_len=tvb_captured_length_remaining(tvb, cdb_offset);\r\ntvb_rlen=tvb_reported_length_remaining(tvb, cdb_offset);\r\nif(ahs_cdb_length && ahs_cdb_length<1024){\r\nguint8 *cdb_buf;\r\ncdb_buf=(guint8 *)wmem_alloc(pinfo->pool, 16+ahs_cdb_length);\r\ntvb_memcpy(tvb, cdb_buf, cdb_offset, 16);\r\ntvb_memcpy(tvb, cdb_buf+16, ahs_cdb_offset, ahs_cdb_length);\r\ncdb_tvb = tvb_new_child_real_data(tvb, cdb_buf,\r\nahs_cdb_length+16,\r\nahs_cdb_length+16);\r\nadd_new_data_source(pinfo, cdb_tvb, "CDB+AHS");\r\n} else {\r\nif(tvb_len>16){\r\ntvb_len=16;\r\n}\r\nif(tvb_rlen>16){\r\ntvb_rlen=16;\r\n}\r\ncdb_tvb=tvb_new_subset(tvb, cdb_offset, tvb_len, tvb_rlen);\r\n}\r\ndissect_scsi_cdb(cdb_tvb, pinfo, tree, SCSI_DEV_UNKNOWN, &cdata->itlq, itl);\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nif(immediate_data_length){\r\ntvb_len=tvb_captured_length_remaining(tvb, immediate_data_offset);\r\nif(tvb_len>(int)immediate_data_length)\r\ntvb_len=immediate_data_length;\r\ntvb_rlen=tvb_reported_length_remaining(tvb, immediate_data_offset);\r\nif(tvb_rlen>(int)immediate_data_length)\r\ntvb_rlen=immediate_data_length;\r\ndata_tvb=tvb_new_subset(tvb, immediate_data_offset, tvb_len, tvb_rlen);\r\ndissect_scsi_payload (data_tvb, pinfo, tree,\r\nTRUE,\r\n&cdata->itlq, itl,\r\n0);\r\n}\r\n}\r\nelse if (opcode == ISCSI_OPCODE_SCSI_RESPONSE) {\r\nif (scsi_status == 0x2) {\r\nif((end_offset - offset) >= 2) {\r\nint senseLen = tvb_get_ntohs(tvb, offset);\r\nif(ti != NULL)\r\nproto_tree_add_item(ti, hf_iscsi_SenseLength, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif(senseLen > 0){\r\ntvbuff_t *data_tvb;\r\nint tvb_len, tvb_rlen;\r\ntvb_len=tvb_captured_length_remaining(tvb, offset);\r\nif(tvb_len>senseLen)\r\ntvb_len=senseLen;\r\ntvb_rlen=tvb_reported_length_remaining(tvb, offset);\r\nif(tvb_rlen>senseLen)\r\ntvb_rlen=senseLen;\r\ndata_tvb=tvb_new_subset(tvb, offset, tvb_len, tvb_rlen);\r\ndissect_scsi_snsinfo (data_tvb, pinfo, tree, 0,\r\ntvb_len,\r\n&cdata->itlq, itl);\r\n}\r\n}\r\n}\r\nelse {\r\ndissect_scsi_rsp(tvb, pinfo, tree, &cdata->itlq, itl, scsi_status);\r\n}\r\n}\r\nelse if ((opcode == ISCSI_OPCODE_SCSI_DATA_IN) ||\r\n(opcode == ISCSI_OPCODE_SCSI_DATA_OUT)) {\r\ntvbuff_t *data_tvb;\r\nint tvb_len, tvb_rlen;\r\ntvb_len=tvb_captured_length_remaining(tvb, offset);\r\nif(tvb_len>(int)data_segment_len)\r\ntvb_len=data_segment_len;\r\ntvb_rlen=tvb_reported_length_remaining(tvb, offset);\r\nif(tvb_rlen>(int)data_segment_len)\r\ntvb_rlen=data_segment_len;\r\ndata_tvb=tvb_new_subset(tvb, offset, tvb_len, tvb_rlen);\r\ndissect_scsi_payload (data_tvb, pinfo, tree,\r\n(opcode==ISCSI_OPCODE_SCSI_DATA_OUT),\r\n&cdata->itlq, itl,\r\ndata_offset);\r\n}\r\nif(S_bit){\r\ndissect_scsi_rsp(tvb, pinfo, tree, &cdata->itlq, itl, scsi_status);\r\n}\r\n}\r\nstatic int\r\ndissect_iscsi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean check_port) {\r\nguint offset = 0;\r\nguint32 available_bytes = tvb_captured_length(tvb);\r\nint digestsActive = 1;\r\nconversation_t *conversation = NULL;\r\niscsi_session_t *iscsi_session=NULL;\r\nguint8 opcode, tmpbyte;\r\nif (available_bytes < 48) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn -1;\r\n}\r\nopcode = tvb_get_guint8(tvb, offset + 0);\r\nopcode &= OPCODE_MASK;\r\nswitch(opcode){\r\ncase ISCSI_OPCODE_NOP_IN:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+1)!=0x80){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_NOP_OUT:\r\nif(tvb_get_guint8(tvb, offset+0)&0x80){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+1)!=0x80){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+2)||tvb_get_guint8(tvb, offset+3)){\r\nreturn 0;\r\n}\r\nif(!tvb_get_letohl(tvb,offset+16) || !tvb_get_letohl(tvb,offset+20)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+32)\r\n|| tvb_get_letohl(tvb,offset+36)\r\n|| tvb_get_letohl(tvb,offset+40)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_LOGIN_COMMAND:\r\nif((tvb_get_guint8(tvb, offset+0)&0xc0)!=0x40){\r\nreturn 0;\r\n}\r\ntmpbyte=tvb_get_guint8(tvb, offset+1);\r\nswitch(tmpbyte&0xf0){\r\ncase 0x80:\r\ncase 0x40:\r\ncase 0x00:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif(((tmpbyte & 0x03) == 0x02)\r\n|| ((tmpbyte & 0x0c) == 0x08)) {\r\nreturn 0;\r\n}\r\nif(tmpbyte&0x80){\r\nif(!(tmpbyte&0x03)){\r\nreturn 0;\r\n}\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_LOGIN_RESPONSE:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\ntmpbyte=tvb_get_guint8(tvb, offset+1);\r\nswitch(tmpbyte&0xf0){\r\ncase 0x80:\r\ncase 0x40:\r\ncase 0x00:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif(((tmpbyte & 0x03) == 0x02)\r\n|| ((tmpbyte & 0x0c) == 0x08)) {\r\nreturn 0;\r\n}\r\nif(tmpbyte&0x80){\r\nif(!(tmpbyte&0x03)){\r\nreturn 0;\r\n}\r\n}\r\nif(tvb_get_letohl(tvb,offset+20)\r\n|| tvb_get_letohl(tvb,offset+40)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohs(tvb,offset+38)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION:\r\nif(tvb_get_guint8(tvb, offset+0)&0x80){\r\nreturn 0;\r\n}\r\ntmpbyte=tvb_get_guint8(tvb, offset+1);\r\nif(!(tmpbyte&0x80)){\r\nreturn 0;\r\n}\r\nif(!try_val_to_str(tmpbyte&0x7f, iscsi_task_management_functions)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohs(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+4)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+1)!=0x80){\r\nreturn 0;\r\n}\r\ntmpbyte=tvb_get_guint8(tvb,offset+2);\r\nif(tmpbyte>6 && tmpbyte<255){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb,offset+3)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+4)\r\n|| tvb_get_letohl(tvb,offset+8)\r\n|| tvb_get_letohl(tvb,offset+12)\r\n|| tvb_get_letohl(tvb,offset+20)\r\n|| tvb_get_letohl(tvb,offset+36)\r\n|| tvb_get_letohl(tvb,offset+40)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_LOGOUT_COMMAND:\r\nif(tvb_get_guint8(tvb, offset+0)&0x80){\r\nreturn 0;\r\n}\r\ntmpbyte=tvb_get_guint8(tvb, offset+1);\r\nif(!(tmpbyte&0x80)){\r\nreturn 0;\r\n}\r\nif(!try_val_to_str(tmpbyte&0x7f, iscsi_logout_reasons)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohs(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+4)\r\n|| tvb_get_letohl(tvb,offset+8)\r\n|| tvb_get_letohl(tvb,offset+12)\r\n|| tvb_get_letohl(tvb,offset+32)\r\n|| tvb_get_letohl(tvb,offset+36)\r\n|| tvb_get_letohl(tvb,offset+40)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_SNACK_REQUEST:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\ntmpbyte=tvb_get_guint8(tvb, offset+1);\r\nif((tmpbyte&0xf0)!=0x80){\r\nreturn 0;\r\n}\r\nif(!try_val_to_str(tmpbyte&0x0f, iscsi_snack_types)){\r\nreturn 0;\r\n}\r\nswitch(tmpbyte&0x0f){\r\ncase 1:\r\ncase 2:\r\nif(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase 3:\r\nif(tvb_get_letohl(tvb,offset+20)==0xffffffff){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+20)==0){\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nif(tvb_get_letohs(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+24)\r\n|| tvb_get_letohl(tvb,offset+32)\r\n|| tvb_get_letohl(tvb,offset+36)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_R2T:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+1)!=0x80){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohs(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+4)){\r\nreturn 0;\r\n}\r\nif(!tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_REJECT:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+1)!=0x80){\r\nreturn 0;\r\n}\r\nif(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_reject_reasons)){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+3)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+8)\r\n|| tvb_get_letohl(tvb,offset+12)\r\n|| tvb_get_letohl(tvb,offset+20)\r\n|| tvb_get_letohl(tvb,offset+40)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_TEXT_COMMAND:\r\nif(tvb_get_guint8(tvb, offset+0)&0x80){\r\nreturn 0;\r\n}\r\nswitch(tvb_get_guint8(tvb,offset+1)){\r\ncase 0x80:\r\ncase 0x40:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif(tvb_get_letohs(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+32)\r\n|| tvb_get_letohl(tvb,offset+36)\r\n|| tvb_get_letohl(tvb,offset+40)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_TEXT_RESPONSE:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\nswitch(tvb_get_guint8(tvb,offset+1)){\r\ncase 0x80:\r\ncase 0x40:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif(tvb_get_letohs(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+36)\r\n|| tvb_get_letohl(tvb,offset+40)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_SCSI_COMMAND:\r\nif(tvb_get_guint8(tvb, offset+0)&0x80){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+1)&0x18){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohs(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nif(tvb_get_ntohl(tvb,offset+20)){\r\nif(!(tvb_get_guint8(tvb, offset+1)&0x60)){\r\nreturn 0;\r\n}\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_SCSI_RESPONSE:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\ntmpbyte=tvb_get_guint8(tvb,offset+1);\r\nif(!(tmpbyte&0x80)){\r\nreturn 0;\r\n}\r\nif(tmpbyte&0x61){\r\nreturn 0;\r\n}\r\nif(!try_val_to_str(tvb_get_guint8(tvb,offset+3), scsi_status_val)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+8)\r\n|| tvb_get_letohl(tvb,offset+12)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_ASYNC_MESSAGE:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+1)!=0x80){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohs(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+20)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+16)!=0xffffffff){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_LOGOUT_RESPONSE:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb, offset+1)!=0x80){\r\nreturn 0;\r\n}\r\nif(!try_val_to_str(tvb_get_guint8(tvb,offset+2), iscsi_logout_response)){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb,offset+3)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+4)\r\n|| tvb_get_letohl(tvb,offset+8)\r\n|| tvb_get_letohl(tvb,offset+12)\r\n|| tvb_get_letohl(tvb,offset+20)\r\n|| tvb_get_letohl(tvb,offset+36)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_SCSI_DATA_OUT:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb,offset+1)&0x7f){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohs(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nif(tvb_get_letohl(tvb,offset+24)\r\n|| tvb_get_letohl(tvb,offset+32)\r\n|| tvb_get_letohl(tvb,offset+44)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_SCSI_DATA_IN:\r\nif(tvb_get_guint8(tvb, offset+0)&0xc0){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb,offset+1)&0x38){\r\nreturn 0;\r\n}\r\nif(tvb_get_guint8(tvb,offset+2)){\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ISCSI_OPCODE_VENDOR_SPECIFIC_I0:\r\ncase ISCSI_OPCODE_VENDOR_SPECIFIC_I1:\r\ncase ISCSI_OPCODE_VENDOR_SPECIFIC_I2:\r\ncase ISCSI_OPCODE_VENDOR_SPECIFIC_T0:\r\ncase ISCSI_OPCODE_VENDOR_SPECIFIC_T1:\r\ncase ISCSI_OPCODE_VENDOR_SPECIFIC_T2:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nwhile(available_bytes >= 48 || (iscsi_desegment && available_bytes >= 8)) {\r\nconst char *opcode_str = NULL;\r\nguint32 data_segment_len;\r\nguint32 pduLen = 48;\r\nguint8 secondPduByte = tvb_get_guint8(tvb, offset + 1);\r\nint badPdu = FALSE;\r\nguint8 ahsLen=0;\r\nguint32 data_segment_offset, data_segment_len_padded;\r\nopcode = tvb_get_guint8(tvb, offset + 0);\r\nopcode &= OPCODE_MASK;\r\nopcode_str = try_val_to_str(opcode, iscsi_opcodes);\r\nif(opcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION ||\r\nopcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\r\nopcode == ISCSI_OPCODE_R2T ||\r\nopcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\r\nopcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\r\nopcode == ISCSI_OPCODE_SNACK_REQUEST)\r\ndata_segment_len = 0;\r\nelse\r\ndata_segment_len = tvb_get_ntohl(tvb, offset + 4) & 0x00ffffff;\r\nif(opcode_str == NULL) {\r\nbadPdu = TRUE;\r\n}\r\nif(!badPdu && check_port) {\r\nbadPdu = TRUE;\r\nif ((opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->srcport)) {\r\nbadPdu = FALSE;\r\n}\r\nif (!(opcode & TARGET_OPCODE_BIT) && value_is_in_range(global_iscsi_port_range, pinfo->destport)) {\r\nbadPdu = FALSE;\r\n}\r\nif ((opcode & TARGET_OPCODE_BIT) && pinfo->srcport == iscsi_system_port) {\r\nbadPdu = FALSE;\r\n}\r\nif (!(opcode & TARGET_OPCODE_BIT) && pinfo->destport == iscsi_system_port) {\r\nbadPdu = FALSE;\r\n}\r\n}\r\nif(!badPdu && enable_bogosity_filter) {\r\nif(data_segment_len > bogus_pdu_data_length_threshold) {\r\nbadPdu = TRUE;\r\n}\r\nelse if(demand_good_f_bit &&\r\n!(secondPduByte & 0x80) &&\r\n(opcode == ISCSI_OPCODE_NOP_OUT ||\r\nopcode == ISCSI_OPCODE_NOP_IN ||\r\nopcode == ISCSI_OPCODE_LOGOUT_COMMAND ||\r\nopcode == ISCSI_OPCODE_LOGOUT_RESPONSE ||\r\nopcode == ISCSI_OPCODE_SCSI_RESPONSE ||\r\nopcode == ISCSI_OPCODE_TASK_MANAGEMENT_FUNCTION_RESPONSE ||\r\nopcode == ISCSI_OPCODE_R2T ||\r\nopcode == ISCSI_OPCODE_ASYNC_MESSAGE ||\r\nopcode == ISCSI_OPCODE_SNACK_REQUEST ||\r\nopcode == ISCSI_OPCODE_REJECT)) {\r\nbadPdu = TRUE;\r\n} else if(opcode==ISCSI_OPCODE_NOP_OUT) {\r\nif(tvb_get_ntohl(tvb, offset+20)==0){\r\nbadPdu = TRUE;\r\n}\r\n}\r\n}\r\nif(badPdu) {\r\nreturn offset;\r\n}\r\nif(opcode == ISCSI_OPCODE_LOGIN_COMMAND ||\r\nopcode == ISCSI_OPCODE_LOGIN_RESPONSE) {\r\nif(iscsi_protocol_version == ISCSI_PROTOCOL_DRAFT08) {\r\nif((secondPduByte & CSG_MASK) < ISCSI_CSG_OPERATIONAL_NEGOTIATION) {\r\ndigestsActive = 0;\r\n}\r\n} else {\r\ndigestsActive = 0;\r\n}\r\n}\r\nif(opcode == ISCSI_OPCODE_SCSI_COMMAND) {\r\nahsLen = tvb_get_guint8(tvb, offset + 4);\r\npduLen += ahsLen * 4;\r\n}\r\ndata_segment_offset = pduLen;\r\ndata_segment_len_padded = data_segment_len;\r\nif((data_segment_len_padded & 3) != 0)\r\ndata_segment_len_padded += 4 - (data_segment_len_padded & 3);\r\npduLen += data_segment_len_padded;\r\nconversation = find_or_create_conversation(pinfo);\r\niscsi_session=(iscsi_session_t *)conversation_get_proto_data(conversation, proto_iscsi);\r\nif(!iscsi_session){\r\niscsi_session = wmem_new(wmem_file_scope(), iscsi_session_t);\r\niscsi_session->header_digest = ISCSI_DIGEST_AUTO;\r\niscsi_session->data_digest = ISCSI_DIGEST_AUTO;\r\niscsi_session->itlq = wmem_tree_new(wmem_file_scope());\r\niscsi_session->itl = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\r\nconversation_add_proto_data(conversation, proto_iscsi, iscsi_session);\r\nconversation_set_dissector(conversation, iscsi_handle);\r\n}\r\nif (digestsActive && (available_bytes >= (guint32) (48+4+ahsLen*4)) &&\r\n(iscsi_session->header_digest == ISCSI_DIGEST_AUTO)) {\r\nguint32 crc;\r\ncrc= ~crc32c_tvb_offset_calculate(tvb, offset, 48+ahsLen*4, CRC32C_PRELOAD);\r\nif(crc==tvb_get_ntohl(tvb,48+ahsLen*4)){\r\niscsi_session->header_digest = ISCSI_DIGEST_CRC32;\r\n} else {\r\niscsi_session->header_digest = ISCSI_DIGEST_NONE;\r\n}\r\n}\r\nif(digestsActive){\r\nswitch(iscsi_session->header_digest){\r\ncase ISCSI_DIGEST_CRC32:\r\npduLen += 4;\r\ndata_segment_offset += 4;\r\nbreak;\r\ncase ISCSI_DIGEST_NONE:\r\nbreak;\r\ncase ISCSI_DIGEST_AUTO:\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\n}\r\n}\r\nif (digestsActive &&\r\n(available_bytes >= data_segment_offset + data_segment_len_padded + 4) &&\r\n(iscsi_session->data_digest == ISCSI_DIGEST_AUTO)) {\r\nguint32 crc;\r\ncrc = ~crc32c_tvb_offset_calculate(tvb, data_segment_offset, data_segment_len_padded, CRC32C_PRELOAD);\r\nif (crc == tvb_get_ntohl(tvb, data_segment_offset + data_segment_len_padded)) {\r\niscsi_session->data_digest = ISCSI_DIGEST_CRC32;\r\n} else {\r\niscsi_session->data_digest = ISCSI_DIGEST_NONE;\r\n}\r\n}\r\nif (digestsActive && data_segment_len > 0) {\r\nswitch (iscsi_session->data_digest) {\r\ncase ISCSI_DIGEST_CRC32:\r\npduLen += 4;\r\nbreak;\r\ncase ISCSI_DIGEST_NONE:\r\nbreak;\r\ncase ISCSI_DIGEST_AUTO:\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\n}\r\n}\r\nif(iscsi_desegment && pinfo->can_desegment) {\r\nif(pduLen > available_bytes) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = pduLen - available_bytes;\r\nreturn -1;\r\n}\r\n}\r\nif(!pinfo->fd->flags.visited){\r\nif(pduLen>(guint32)tvb_reported_length_remaining(tvb, offset)){\r\npinfo->want_pdu_tracking=2;\r\npinfo->bytes_until_next_pdu=pduLen-tvb_reported_length_remaining(tvb, offset);\r\n}\r\n}\r\nif (offset == 0)\r\ncol_set_str(pinfo->cinfo, COL_INFO, "");\r\nelse\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", ");\r\ndissect_iscsi_pdu(tvb, pinfo, tree, offset, opcode, opcode_str, data_segment_len, iscsi_session, conversation);\r\nif(pduLen > available_bytes)\r\npduLen = available_bytes;\r\noffset += pduLen;\r\navailable_bytes -= pduLen;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_iscsi_handle(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_) {\r\nreturn dissect_iscsi(tvb, pinfo, tree, FALSE);\r\n}\r\nstatic gboolean\r\ndissect_iscsi_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_) {\r\nguint32 available_bytes = tvb_captured_length(tvb);\r\nif (available_bytes < 48 ){\r\nreturn FALSE;\r\n}\r\nreturn dissect_iscsi(tvb, pinfo, tree, TRUE) != 0;\r\n}\r\nvoid\r\nproto_register_iscsi(void)\r\n{\r\nmodule_t *iscsi_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_iscsi_request_frame,\r\n{ "Request in", "iscsi.request_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0,\r\n"The request to this transaction is in this frame", HFILL }},\r\n{ &hf_iscsi_time,\r\n{ "Time from request", "iscsi.time",\r\nFT_RELATIVE_TIME, BASE_NONE, NULL, 0,\r\n"Time between the Command and the Response", HFILL }},\r\n{ &hf_iscsi_data_in_frame,\r\n{ "Data In in", "iscsi.data_in_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0,\r\n"The Data In for this transaction is in this frame", HFILL }},\r\n{ &hf_iscsi_data_out_frame,\r\n{ "Data Out in", "iscsi.data_out_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0,\r\n"The Data Out for this transaction is in this frame", HFILL }},\r\n{ &hf_iscsi_response_frame,\r\n{ "Response in", "iscsi.response_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0,\r\n"The response to this transaction is in this frame", HFILL }},\r\n{ &hf_iscsi_AHS_length,\r\n{ "AHS Length", "iscsi.ahs.length",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Length of Additional header segment", HFILL }\r\n},\r\n{ &hf_iscsi_AHS_read_data_length,\r\n{ "Bidirectional Read Data Length", "iscsi.ahs.bidir.length",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_iscsi_AHS_type,\r\n{ "AHS Type", "iscsi.ahs.type",\r\nFT_UINT8, BASE_DEC, VALS(ahs_type_vals), 0,\r\n"Type of Additional header segment", HFILL }\r\n},\r\n{ &hf_iscsi_AHS_extended_cdb,\r\n{ "AHS Extended CDB", "iscsi.ahs.extended_cdb",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_iscsi_AHS_blob,\r\n{ "Unknown AHS blob", "iscsi.ahs.unknown_blob",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_iscsi_Padding,\r\n{ "Padding", "iscsi.padding",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Padding to 4 byte boundary", HFILL }\r\n},\r\n{ &hf_iscsi_ping_data,\r\n{ "PingData", "iscsi.pingdata",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Ping Data", HFILL }\r\n},\r\n{ &hf_iscsi_immediate_data,\r\n{ "ImmediateData", "iscsi.immediatedata",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Immediate Data", HFILL }\r\n},\r\n{ &hf_iscsi_async_event_data,\r\n{ "AsyncEventData", "iscsi.asynceventdata",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Async Event Data", HFILL }\r\n},\r\n{ &hf_iscsi_vendor_specific_data,\r\n{ "VendorSpecificData", "iscsi.vendorspecificdata",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Vendor Specific Data", HFILL }\r\n},\r\n{ &hf_iscsi_HeaderDigest32,\r\n{ "HeaderDigest", "iscsi.headerdigest32",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Header Digest", HFILL }\r\n},\r\n{ &hf_iscsi_DataDigest32,\r\n{ "DataDigest", "iscsi.datadigest32",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Data Digest", HFILL }\r\n},\r\n{ &hf_iscsi_Opcode,\r\n{ "Opcode", "iscsi.opcode",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_opcodes), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_iscsi_X,\r\n{ "X", "iscsi.X",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_X), 0x80,\r\n"Command Retry", HFILL }\r\n},\r\n{ &hf_iscsi_I,\r\n{ "I", "iscsi.I",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_I), 0x40,\r\n"Immediate delivery", HFILL }\r\n},\r\n{ &hf_iscsi_Flags,\r\n{ "Flags", "iscsi.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Opcode specific flags", HFILL }\r\n},\r\n{ &hf_iscsi_SCSICommand_F,\r\n{ "F", "iscsi.scsicommand.F",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80,\r\n"PDU completes command", HFILL }\r\n},\r\n{ &hf_iscsi_SCSICommand_R,\r\n{ "R", "iscsi.scsicommand.R",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_R), 0x40,\r\n"Command reads from SCSI target", HFILL }\r\n},\r\n{ &hf_iscsi_SCSICommand_W,\r\n{ "W", "iscsi.scsicommand.W",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_W), 0x20,\r\n"Command writes to SCSI target", HFILL }\r\n},\r\n{ &hf_iscsi_SCSICommand_Attr,\r\n{ "Attr", "iscsi.scsicommand.attr",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_scsicommand_taskattrs), 0x07,\r\n"SCSI task attributes", HFILL }\r\n},\r\n{ &hf_iscsi_SCSICommand_CRN,\r\n{ "CRN", "iscsi.scsicommand.crn",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"SCSI command reference number", HFILL }\r\n},\r\n{ &hf_iscsi_DataSegmentLength,\r\n{ "DataSegmentLength", "iscsi.datasegmentlength",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0,\r\n"Data segment length (bytes)", HFILL }\r\n},\r\n{ &hf_iscsi_TotalAHSLength,\r\n{ "TotalAHSLength", "iscsi.totalahslength",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Total additional header segment length (4 byte words)", HFILL }\r\n},\r\n{ &hf_iscsi_InitiatorTaskTag,\r\n{ "InitiatorTaskTag", "iscsi.initiatortasktag",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Initiator's task tag", HFILL }\r\n},\r\n{ &hf_iscsi_ExpectedDataTransferLength,\r\n{ "ExpectedDataTransferLength", "iscsi.scsicommand.expecteddatatransferlength",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Expected length of data transfer", HFILL }\r\n},\r\n{ &hf_iscsi_CmdSN,\r\n{ "CmdSN", "iscsi.cmdsn",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Sequence number for this command", HFILL }\r\n},\r\n{ &hf_iscsi_ExpStatSN,\r\n{ "ExpStatSN", "iscsi.expstatsn",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Next expected status sequence number", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIResponse_ResidualCount,\r\n{ "ResidualCount", "iscsi.scsiresponse.residualcount",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Residual count", HFILL }\r\n},\r\n{ &hf_iscsi_StatSN,\r\n{ "StatSN", "iscsi.statsn",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Status sequence number", HFILL }\r\n},\r\n{ &hf_iscsi_ExpCmdSN,\r\n{ "ExpCmdSN", "iscsi.expcmdsn",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Next expected command sequence number", HFILL }\r\n},\r\n{ &hf_iscsi_MaxCmdSN,\r\n{ "MaxCmdSN", "iscsi.maxcmdsn",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Maximum acceptable command sequence number", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIResponse_o,\r\n{ "o", "iscsi.scsiresponse.o",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_o), 0x10,\r\n"Bi-directional read residual overflow", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIResponse_u,\r\n{ "u", "iscsi.scsiresponse.u",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_u), 0x08,\r\n"Bi-directional read residual underflow", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIResponse_O,\r\n{ "O", "iscsi.scsiresponse.O",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_O), 0x04,\r\n"Residual overflow", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIResponse_U,\r\n{ "U", "iscsi.scsiresponse.U",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_U), 0x02,\r\n"Residual underflow", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIResponse_Status,\r\n{ "Status", "iscsi.scsiresponse.status",\r\nFT_UINT8, BASE_HEX, VALS(scsi_status_val), 0,\r\n"SCSI command status value", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIResponse_Response,\r\n{ "Response", "iscsi.scsiresponse.response",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_scsi_responses), 0,\r\n"SCSI command response value", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIResponse_BidiReadResidualCount,\r\n{ "BidiReadResidualCount", "iscsi.scsiresponse.bidireadresidualcount",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Bi-directional read residual count", HFILL }\r\n},\r\n{ &hf_iscsi_SenseLength,\r\n{ "SenseLength", "iscsi.scsiresponse.senselength",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Sense data length", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIData_F,\r\n{ "F", "iscsi.scsidata.F",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_F), ISCSI_SCSI_DATA_FLAG_F,\r\n"Final PDU", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIData_A,\r\n{ "A", "iscsi.scsidata.A",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_A), ISCSI_SCSI_DATA_FLAG_A,\r\n"Acknowledge Requested", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIData_S,\r\n{ "S", "iscsi.scsidata.S",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_S), ISCSI_SCSI_DATA_FLAG_S,\r\n"PDU Contains SCSI command status", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIData_U,\r\n{ "U", "iscsi.scsidata.U",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_U), ISCSI_SCSI_DATA_FLAG_U,\r\n"Residual underflow", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIData_O,\r\n{ "O", "iscsi.scsidata.O",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_O), ISCSI_SCSI_DATA_FLAG_O,\r\n"Residual overflow", HFILL }\r\n},\r\n{ &hf_iscsi_TargetTransferTag,\r\n{ "TargetTransferTag", "iscsi.targettransfertag",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Target transfer tag", HFILL }\r\n},\r\n{ &hf_iscsi_BufferOffset,\r\n{ "BufferOffset", "iscsi.bufferOffset",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Buffer offset", HFILL }\r\n},\r\n{ &hf_iscsi_SCSIData_ResidualCount,\r\n{ "ResidualCount", "iscsi.scsidata.readresidualcount",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Residual count", HFILL }\r\n},\r\n{ &hf_iscsi_DataSN,\r\n{ "DataSN", "iscsi.datasn",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Data sequence number", HFILL }\r\n},\r\n{ &hf_iscsi_VersionMax,\r\n{ "VersionMax", "iscsi.versionmax",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Maximum supported protocol version", HFILL }\r\n},\r\n{ &hf_iscsi_VersionMin,\r\n{ "VersionMin", "iscsi.versionmin",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Minimum supported protocol version", HFILL }\r\n},\r\n{ &hf_iscsi_VersionActive,\r\n{ "VersionActive", "iscsi.versionactive",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Negotiated protocol version", HFILL }\r\n},\r\n{ &hf_iscsi_CID,\r\n{ "CID", "iscsi.cid",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Connection identifier", HFILL }\r\n},\r\n{ &hf_iscsi_ISID8,\r\n{ "ISID", "iscsi.isid8",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Initiator part of session identifier", HFILL }\r\n},\r\n{ &hf_iscsi_ISID,\r\n{ "ISID", "iscsi.isid",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\n"Initiator part of session identifier", HFILL }\r\n},\r\n{ &hf_iscsi_ISID_Type,\r\n{ "ISID_Type", "iscsi.isid.type",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0,\r\n"Initiator part of session identifier - type", HFILL }\r\n},\r\n{ &hf_iscsi_ISID_NamingAuthority,\r\n{ "ISID_NamingAuthority", "iscsi.isid.namingauthority",\r\nFT_UINT24, BASE_HEX, NULL, 0,\r\n"Initiator part of session identifier - naming authority", HFILL }\r\n},\r\n{ &hf_iscsi_ISID_Qualifier,\r\n{ "ISID_Qualifier", "iscsi.isid.qualifier",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Initiator part of session identifier - qualifier", HFILL }\r\n},\r\n{ &hf_iscsi_ISID_t,\r\n{ "ISID_t", "iscsi.isid.t",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0xc0,\r\n"Initiator part of session identifier - t", HFILL }\r\n},\r\n{ &hf_iscsi_ISID_a,\r\n{ "ISID_a", "iscsi.isid.a",\r\nFT_UINT8, BASE_HEX, NULL, 0x3f,\r\n"Initiator part of session identifier - a", HFILL }\r\n},\r\n{ &hf_iscsi_ISID_b,\r\n{ "ISID_b", "iscsi.isid.b",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Initiator part of session identifier - b", HFILL }\r\n},\r\n{ &hf_iscsi_ISID_c,\r\n{ "ISID_c", "iscsi.isid.c",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Initiator part of session identifier - c", HFILL }\r\n},\r\n{ &hf_iscsi_ISID_d,\r\n{ "ISID_d", "iscsi.isid.d",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Initiator part of session identifier - d", HFILL }\r\n},\r\n{ &hf_iscsi_TSID,\r\n{ "TSID", "iscsi.tsid",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Target part of session identifier", HFILL }\r\n},\r\n{ &hf_iscsi_TSIH,\r\n{ "TSIH", "iscsi.tsih",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Target session identifying handle", HFILL }\r\n},\r\n{ &hf_iscsi_Login_T,\r\n{ "T", "iscsi.login.T",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_T), 0x80,\r\n"Transit to next login stage", HFILL }\r\n},\r\n{ &hf_iscsi_Login_C,\r\n{ "C", "iscsi.login.C",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40,\r\n"Text incomplete", HFILL }\r\n},\r\n{ &hf_iscsi_Login_X,\r\n{ "X", "iscsi.login.X",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_login_X), 0x40,\r\n"Restart Connection", HFILL }\r\n},\r\n{ &hf_iscsi_Login_CSG,\r\n{ "CSG", "iscsi.login.csg",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_login_stage), CSG_MASK,\r\n"Current stage", HFILL }\r\n},\r\n{ &hf_iscsi_Login_NSG,\r\n{ "NSG", "iscsi.login.nsg",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_login_stage), NSG_MASK,\r\n"Next stage", HFILL }\r\n},\r\n{ &hf_iscsi_Login_Status,\r\n{ "Status", "iscsi.login.status",\r\nFT_UINT16, BASE_HEX, VALS(iscsi_login_status), 0,\r\n"Status class and detail", HFILL }\r\n},\r\n{ &hf_iscsi_KeyValue,\r\n{ "KeyValue", "iscsi.keyvalue",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\n"Key/value pair", HFILL }\r\n},\r\n{ &hf_iscsi_Text_F,\r\n{ "F", "iscsi.text.F",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80,\r\n"Final PDU in text sequence", HFILL }\r\n},\r\n{ &hf_iscsi_Text_C,\r\n{ "C", "iscsi.text.C",\r\nFT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40,\r\n"Text incomplete", HFILL }\r\n},\r\n{ &hf_iscsi_ExpDataSN,\r\n{ "ExpDataSN", "iscsi.expdatasn",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Next expected data sequence number", HFILL }\r\n},\r\n{ &hf_iscsi_R2TSN,\r\n{ "R2TSN", "iscsi.r2tsn",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"R2T PDU Number", HFILL }\r\n},\r\n{ &hf_iscsi_TaskManagementFunction_Response,\r\n{ "Response", "iscsi.taskmanfun.response",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_task_management_responses), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_iscsi_TaskManagementFunction_ReferencedTaskTag,\r\n{ "ReferencedTaskTag", "iscsi.taskmanfun.referencedtasktag",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Referenced task tag", HFILL }\r\n},\r\n{ &hf_iscsi_RefCmdSN,\r\n{ "RefCmdSN", "iscsi.refcmdsn",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Command sequence number for command to be aborted", HFILL }\r\n},\r\n{ &hf_iscsi_TaskManagementFunction_Function,\r\n{ "Function", "iscsi.taskmanfun.function",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_task_management_functions), 0x7F,\r\n"Requested task function", HFILL }\r\n},\r\n{ &hf_iscsi_Logout_Reason,\r\n{ "Reason", "iscsi.logout.reason",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_logout_reasons), 0x7F,\r\n"Reason for logout", HFILL }\r\n},\r\n{ &hf_iscsi_Logout_Response,\r\n{ "Response", "iscsi.logout.response",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_logout_response), 0,\r\n"Logout response", HFILL }\r\n},\r\n{ &hf_iscsi_Time2Wait,\r\n{ "Time2Wait", "iscsi.time2wait",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_iscsi_Time2Retain,\r\n{ "Time2Retain", "iscsi.time2retain",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_iscsi_DesiredDataLength,\r\n{ "DesiredDataLength", "iscsi.desireddatalength",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Desired data length (bytes)", HFILL }\r\n},\r\n{ &hf_iscsi_AsyncEvent,\r\n{ "AsyncEvent", "iscsi.asyncevent",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_asyncevents), 0,\r\n"Async event type", HFILL }\r\n},\r\n{ &hf_iscsi_EventVendorCode,\r\n{ "EventVendorCode", "iscsi.eventvendorcode",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\n"Event vendor code", HFILL }\r\n},\r\n{ &hf_iscsi_Parameter1,\r\n{ "Parameter1", "iscsi.parameter1",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Parameter 1", HFILL }\r\n},\r\n{ &hf_iscsi_Parameter2,\r\n{ "Parameter2", "iscsi.parameter2",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Parameter 2", HFILL }\r\n},\r\n{ &hf_iscsi_Parameter3,\r\n{ "Parameter3", "iscsi.parameter3",\r\nFT_UINT16, BASE_HEX, NULL, 0,\r\n"Parameter 3", HFILL }\r\n},\r\n{ &hf_iscsi_Reject_Reason,\r\n{ "Reason", "iscsi.reject.reason",\r\nFT_UINT8, BASE_HEX, VALS(iscsi_reject_reasons), 0,\r\n"Reason for command rejection", HFILL }\r\n},\r\n{ &hf_iscsi_snack_type,\r\n{ "S", "iscsi.snack.type",\r\nFT_UINT8, BASE_DEC, VALS(iscsi_snack_types), 0x0f,\r\n"Type of SNACK requested", HFILL }\r\n},\r\n{ &hf_iscsi_BegRun,\r\n{ "BegRun", "iscsi.snack.begrun",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"First missed DataSN or StatSN", HFILL }\r\n},\r\n{ &hf_iscsi_RunLength,\r\n{ "RunLength", "iscsi.snack.runlength",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Number of additional missing status PDUs in this run", HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_iscsi,\r\n&ett_iscsi_KeyValues,\r\n&ett_iscsi_CDB,\r\n&ett_iscsi_Flags,\r\n&ett_iscsi_RejectHeader,\r\n&ett_iscsi_lun,\r\n&ett_iscsi_ISID,\r\n};\r\nproto_iscsi = proto_register_protocol("iSCSI", "iSCSI", "iscsi");\r\niscsi_handle = register_dissector("iscsi", dissect_iscsi_handle, proto_iscsi);\r\nproto_register_field_array(proto_iscsi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\niscsi_module = prefs_register_protocol(proto_iscsi, NULL);\r\nprefs_register_enum_preference(iscsi_module,\r\n"protocol_version",\r\n"Protocol version",\r\n"The iSCSI protocol version",\r\n&iscsi_protocol_version,\r\niscsi_protocol_versions,\r\nFALSE);\r\nprefs_register_bool_preference(iscsi_module,\r\n"desegment_iscsi_messages",\r\n"Reassemble iSCSI messages\nspanning multiple TCP segments",\r\n"Whether the iSCSI dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&iscsi_desegment);\r\nprefs_register_bool_preference(iscsi_module,\r\n"bogus_pdu_filter",\r\n"Enable bogus pdu filter",\r\n"When enabled, packets that appear bogus are ignored",\r\n&enable_bogosity_filter);\r\nprefs_register_bool_preference(iscsi_module,\r\n"demand_good_f_bit",\r\n"Ignore packets with bad F bit",\r\n"Ignore packets that haven't set the F bit when they should have",\r\n&demand_good_f_bit);\r\nprefs_register_uint_preference(iscsi_module,\r\n"bogus_pdu_max_data_len",\r\n"Bogus pdu max data length threshold",\r\n"Treat packets whose data segment length is greater than this value as bogus",\r\n10,\r\n&bogus_pdu_data_length_threshold);\r\nrange_convert_str(&global_iscsi_port_range, TCP_PORT_ISCSI_RANGE, MAX_TCP_PORT);\r\nprefs_register_range_preference(iscsi_module,\r\n"target_ports",\r\n"Target Ports Range",\r\n"Range of iSCSI target ports"\r\n"(default " TCP_PORT_ISCSI_RANGE ")",\r\n&global_iscsi_port_range, MAX_TCP_PORT);\r\nprefs_register_uint_preference(iscsi_module,\r\n"target_system_port",\r\n"Target system port",\r\n"System port number of iSCSI target",\r\n10,\r\n&iscsi_system_port);\r\nprefs_register_obsolete_preference(iscsi_module,\r\n"version_03_compatible");\r\nprefs_register_obsolete_preference(iscsi_module,\r\n"bogus_pdu_max_digest_padding");\r\nprefs_register_obsolete_preference(iscsi_module,\r\n"header_digest_is_crc32c");\r\nprefs_register_obsolete_preference(iscsi_module,\r\n"header_digest_size");\r\nprefs_register_obsolete_preference(iscsi_module,\r\n"enable_header_digests");\r\nprefs_register_obsolete_preference(iscsi_module,\r\n"data_digest_is_crc32c");\r\nprefs_register_obsolete_preference(iscsi_module,\r\n"data_digest_size");\r\nprefs_register_obsolete_preference(iscsi_module,\r\n"enable_data_digests");\r\n}\r\nvoid\r\nproto_reg_handoff_iscsi(void)\r\n{\r\nheur_dissector_add("tcp", dissect_iscsi_heur, "iSCSI over TCP", "iscsi_tcp", proto_iscsi, HEURISTIC_ENABLE);\r\ndissector_add_for_decode_as("tcp.port", iscsi_handle);\r\n}
