static guint16\r\nde_bmaple_apdu(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)\r\n{\r\nguint32 curr_offset;\r\nguint8 apdu_protocol_id;\r\ntvbuff_t *APDU_tvb;\r\ncurr_offset = offset;\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_apdu, tvb, curr_offset, len, ENC_NA);\r\napdu_protocol_id = tvb_get_guint8(tvb,curr_offset);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_apdu_protocol_id, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nswitch(apdu_protocol_id){\r\ncase 1:\r\nAPDU_tvb = tvb_new_subset_length(tvb, curr_offset+1, len-1);\r\nif(gsm_bsslap_handle)\r\ncall_dissector(gsm_bsslap_handle, APDU_tvb, pinfo, g_tree);\r\nbreak;\r\ncase 2:\r\nbreak;\r\ncase 3:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncurr_offset += len;\r\nEXTRANEOUS_DATA_CHECK(len, curr_offset - offset, pinfo, &ei_gsm_a_bssmap_le_extraneous_data);\r\nreturn(curr_offset - offset);\r\n}\r\nstatic guint16\r\nde_bmaple_decihp_keys(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)\r\n{\r\ngint bit_offset;\r\nbit_offset = (offset<<3);\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_spare, tvb, bit_offset, 7, ENC_BIG_ENDIAN);\r\nbit_offset += 7;\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_ciphering_key_flag, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset++;\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_current_deciphering_key_value, tvb, bit_offset, 56, ENC_NA);\r\nbit_offset += 56;\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_next_deciphering_key_value, tvb, bit_offset, 56, ENC_NA);\r\nreturn(len);\r\n}\r\nstatic guint16\r\nde_bmaple_req_gps_ass_data(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)\r\n{\r\nguint32 curr_offset;\r\ncurr_offset = offset;\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_acq_ass, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_ref_time, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_ref_loc, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_dgps_corr, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_nav_mod, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_iono_mod, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_utc_mod, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_almanac, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\ncurr_offset++;\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_ephemeris_ext_chk, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_ephemeris_ext, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_real_time_int, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\ncurr_offset++;\r\nproto_tree_add_expert_format(tree, pinfo, &ei_gsm_a_bssmap_le_not_decoded_yet, tvb, curr_offset, len-2, "Satellite related data Not decoded yet");\r\nreturn(len);\r\n}\r\nstatic guint16\r\nde_bmaple_cause(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)\r\n{\r\nguint32 curr_offset;\r\ncurr_offset = offset;\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_lcs_cause_value, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\ncurr_offset++;\r\nif (len == 2)\r\n{\r\nproto_tree_add_item(tree, hf_gsm_bssmap_le_diagnostic_value, tvb, curr_offset, 1, ENC_BIG_ENDIAN);\r\ncurr_offset++;\r\n}\r\nreturn(curr_offset - offset);\r\n}\r\nstatic guint16\r\nde_bmaple_client(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)\r\n{\r\nguint32 curr_offset;\r\nguint8 bitCount;\r\nbitCount = offset<<3;\r\ncurr_offset = offset;\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_client_category, tvb, bitCount, 4, ENC_BIG_ENDIAN);\r\nbitCount = bitCount + 4;\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_client_subtype, tvb, bitCount, 4, ENC_BIG_ENDIAN);\r\ncurr_offset++;\r\nreturn(curr_offset - offset);\r\n}\r\nstatic guint16\r\nde_bmaple_lcs_qos(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)\r\n{\r\nguint64 verticalCoordIndicator, velocityRequested, horizontalAccuracyIndicator, verticalAccuracyIndicator;\r\nguint16 bitCount;\r\nbitCount = offset << 3;\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_spare, tvb, bitCount, 6, ENC_BIG_ENDIAN);\r\nbitCount = bitCount + 6;\r\nproto_tree_add_bits_ret_val(tree, hf_gsm_bssmap_le_velocity_requested, tvb, bitCount, 1, &velocityRequested, ENC_BIG_ENDIAN);\r\nbitCount++;\r\nproto_tree_add_bits_ret_val(tree, hf_gsm_bssmap_le_vertical_coordinate_indicator, tvb, bitCount, 1, &verticalCoordIndicator, ENC_BIG_ENDIAN);\r\nbitCount++;\r\nproto_tree_add_bits_ret_val(tree, hf_gsm_bssmap_le_horizontal_accuracy_indicator, tvb, bitCount, 1, &horizontalAccuracyIndicator, ENC_BIG_ENDIAN);\r\nbitCount++;\r\nif(horizontalAccuracyIndicator == 1)\r\n{\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_horizontal_accuracy, tvb, bitCount, 7, ENC_BIG_ENDIAN);\r\nbitCount = bitCount + 7;\r\n}\r\nelse\r\n{\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_spare, tvb, bitCount, 7, ENC_BIG_ENDIAN);\r\nbitCount = bitCount + 7;\r\n}\r\nproto_tree_add_bits_ret_val(tree, hf_gsm_bssmap_le_vertical_accuracy_indicator, tvb, bitCount, 1, &verticalAccuracyIndicator, ENC_BIG_ENDIAN);\r\nbitCount++;\r\nif(verticalAccuracyIndicator == 1)\r\n{\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_vertical_accuracy, tvb, bitCount, 7, ENC_BIG_ENDIAN);\r\nbitCount = bitCount + 7;\r\n}\r\nelse\r\n{\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_spare, tvb, bitCount, 7, ENC_BIG_ENDIAN);\r\nbitCount = bitCount + 7;\r\n}\r\nproto_tree_add_bits_item(tree, hf_gsm_bssmap_le_response_time_category, tvb, bitCount, 2, ENC_BIG_ENDIAN);\r\nreturn(len);\r\n}\r\nstatic guint16\r\nde_bmaple_pos_dta(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)\r\n{\r\ntvbuff_t *data_tvb;\r\nguint32 curr_offset;\r\ncurr_offset = offset;\r\ndata_tvb = tvb_new_subset_length(tvb, curr_offset, len);\r\ndissect_geographical_description(data_tvb, pinfo, tree);\r\nreturn(len);\r\n}\r\nstatic guint16\r\nbe_lcs_capability(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_gsm_a_bssmap_le_not_decoded_yet, tvb, offset, len);\r\nreturn len;\r\n}\r\nstatic guint16\r\nbe_packet_meas_rep(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_gsm_a_bssmap_le_not_decoded_yet, tvb, offset, len);\r\nreturn len;\r\n}\r\nstatic guint16\r\nbe_measured_cell_identity(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset, guint len, gchar *add_string _U_, int string_len _U_)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_gsm_a_bssmap_le_not_decoded_yet, tvb, offset, len);\r\nreturn len;\r\n}\r\nstatic void\r\nbssmap_le_perf_loc_request(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len)\r\n{\r\nguint32 curr_offset;\r\nguint32 consumed;\r\nguint curr_len;\r\ncurr_offset = offset;\r\ncurr_len = len;\r\nELEM_MAND_TLV(BSSMAP_LE_LOCATION_TYPE, GSM_A_PDU_TYPE_BSSMAP, BE_LOC_TYPE, NULL, ei_gsm_a_bssmap_le_missing_mandatory_element)\r\nELEM_MAND_TLV(BSSMAP_LE_CELL_IDENTIFIER, GSM_A_PDU_TYPE_BSSMAP, BE_CELL_ID, NULL, ei_gsm_a_bssmap_le_missing_mandatory_element);\r\nELEM_OPT_TLV(BSSMAP_LE_CLASSMARK_INFORMATION_TYPE_3, GSM_A_PDU_TYPE_BSSMAP, BE_CM_INFO_3, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_LCS_CLIENT_TYPE, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_LCS_CLIENT_TYPE, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_CHOSEN_CHANNEL, GSM_A_PDU_TYPE_BSSMAP, BE_CHOSEN_CHAN, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_LCS_PRIORITY, GSM_A_PDU_TYPE_BSSMAP, BE_LCS_PRIO, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_LCS_QOS, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_LCSQOS, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_REQUESTED_GPS_ASSISTANCE_DATA, GSM_A_PDU_TYPE_BSSMAP, BE_GPS_ASSIST_DATA, NULL);\r\nELEM_MAND_TELV(BSSMAP_LE_APDU, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_APDU, NULL, ei_gsm_a_bssmap_le_missing_mandatory_element);\r\nELEM_OPT_TLV(BSSMAP_LE_LCS_CAPABILITY, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_LCS_CAPABILITY, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_PACKET_MEASUREMENT_REPORT, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_PACKET_MEAS_REP, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_CELL_IDENTITY_LIST, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_MEAS_CELL_ID, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_IMSI, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_IMSI, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_IMEI, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_IMEI, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_GANSS_LOCATION_TYPE, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_GANSS_LOC_TYPE, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_REQUESTED_GANSS_ASSISTANCE_DATA, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_REQ_GNSS_ASSIST_D, NULL);\r\nEXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_bssmap_le_extraneous_data);\r\n}\r\nstatic void\r\nbssmap_le_perf_loc_resp(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len)\r\n{\r\nguint32 curr_offset;\r\nguint32 consumed;\r\nguint curr_len;\r\ncurr_offset = offset;\r\ncurr_len = len;\r\nELEM_OPT_TLV(BSSMAP_LE_GEOGRAPHIC_LOCATION, BSSAP_PDU_TYPE_BSSMAP, BE_LOC_EST, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_POSITIONING_DATA, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_POS_DATA, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_DECIPHERING_KEYS, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_DECIPH_KEYS, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_LCS_CAUSE, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_LCS_CAUSE, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_VELOCITY_DATA, BSSAP_PDU_TYPE_BSSMAP, BE_VEL_EST, NULL);\r\nELEM_OPT_TLV(BSSMAP_LE_GANSS_POSITIONING_DATA, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_GANSS_POS_DATA, NULL);\r\nEXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_bssmap_le_extraneous_data);\r\n}\r\nstatic void\r\nbssmap_le_connection_oriented(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len)\r\n{\r\nguint32 curr_offset;\r\nguint32 consumed;\r\nguint curr_len;\r\ncurr_offset = offset;\r\ncurr_len = len;\r\nELEM_MAND_TELV(BSSMAP_LE_APDU, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_APDU, NULL, ei_gsm_a_bssmap_le_missing_mandatory_element);\r\nELEM_OPT_TLV(BSSMAP_LE_SEGMENTATION, BSSAP_PDU_TYPE_BSSMAP, BE_SEG, NULL);\r\nEXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_bssmap_le_extraneous_data);\r\n}\r\nstatic void\r\nbssmap_le_perf_loc_info(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo _U_, guint32 offset, guint len)\r\n{\r\nguint32 curr_offset;\r\nguint32 consumed;\r\nguint curr_len;\r\ncurr_offset = offset;\r\ncurr_len = len;\r\nELEM_MAND_TLV(BSSMAP_LE_CELL_IDENTIFIER, GSM_A_PDU_TYPE_BSSMAP, BE_CELL_ID, NULL, ei_gsm_a_bssmap_le_missing_mandatory_element);\r\nELEM_MAND_TELV(BSSMAP_LE_APDU, GSM_PDU_TYPE_BSSMAP_LE, DE_BMAPLE_APDU, NULL, ei_gsm_a_bssmap_le_missing_mandatory_element);\r\nEXTRANEOUS_DATA_CHECK(curr_len, 0, pinfo, &ei_gsm_a_bssmap_le_extraneous_data);\r\n}\r\nstatic int\r\ndissect_bssmap_le(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nstatic gsm_a_tap_rec_t tap_rec[4];\r\nstatic gsm_a_tap_rec_t *tap_p;\r\nstatic guint tap_current=0;\r\nguint8 oct;\r\nguint32 offset, saved_offset;\r\nguint32 len;\r\ngint idx;\r\nproto_item *bssmap_le_item = NULL;\r\nproto_tree *bssmap_le_tree = NULL;\r\nconst gchar *str;\r\nsccp_msg_info_t *sccp_msg_p = (sccp_msg_info_t *)data;\r\nif (!(sccp_msg_p && sccp_msg_p->data.co.assoc)) {\r\nsccp_msg_p = NULL;\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO, "(BSSMAP LE) ");\r\ntap_current++;\r\nif (tap_current >= 4)\r\n{\r\ntap_current = 0;\r\n}\r\ntap_p = &tap_rec[tap_current];\r\noffset = 0;\r\nsaved_offset = offset;\r\ng_tree = tree;\r\nlen = tvb_reported_length(tvb);\r\noct = tvb_get_guint8(tvb, offset++);\r\nstr = try_val_to_str_idx((guint32) oct, gsm_bssmap_le_msg_strings, &idx);\r\nif (sccp_msg_p && !sccp_msg_p->data.co.label) {\r\nsccp_msg_p->data.co.label = wmem_strdup(wmem_file_scope(),\r\nval_to_str((guint32) oct,\r\ngsm_bssmap_le_msg_strings, "BSSMAP LE(0x%02x)"));\r\n}\r\nif (str == NULL)\r\n{\r\nbssmap_le_item =\r\nproto_tree_add_protocol_format(tree, proto_bssmap_le, tvb, 0, len,\r\n"Lb - I/F BSSMAP LE - Unknown BSSMAP Message Type (0x%02x)",\r\noct);\r\nbssmap_le_tree = proto_item_add_subtree(bssmap_le_item, ett_bssmap_le_msg);\r\n}\r\nelse\r\n{\r\nbssmap_le_item =\r\nproto_tree_add_protocol_format(tree, proto_bssmap_le, tvb, 0, -1,\r\n"Lb - I/F BSSMAP LE - %s",\r\nstr);\r\nbssmap_le_tree = proto_item_add_subtree(bssmap_le_item, ett_gsm_bssmap_le_msg[idx]);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ", str);\r\nproto_tree_add_uint_format(bssmap_le_tree, hf_gsm_bssmap_le_msg_type,\r\ntvb, saved_offset, 1, oct, "Message Type %s",str);\r\n}\r\ntap_p->pdu_type = BSSAP_PDU_TYPE_BSSMAP;\r\ntap_p->message_type = oct;\r\ntap_queue_packet(gsm_a_tap, pinfo, tap_p);\r\nif (str == NULL) return len;\r\nif (offset >= len) return len;\r\nif (bssmap_le_msg_fcn[idx] == NULL)\r\n{\r\nproto_tree_add_item(bssmap_le_tree, hf_gsm_bssmap_le_message_elements, tvb, offset, len - offset, ENC_NA);\r\n}\r\nelse\r\n{\r\n(*bssmap_le_msg_fcn[idx])(tvb, bssmap_le_tree, pinfo, offset, len - offset);\r\n}\r\nreturn len;\r\n}\r\nvoid\r\nproto_register_gsm_bssmap_le(void)\r\n{\r\nguint i;\r\nguint last_offset;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_gsm_bssmap_le_msg_type,\r\n{ "BSSMAP LE Message Type", "gsm_bssmap_le.msgtype",\r\nFT_UINT8, BASE_HEX, VALS(gsm_bssmap_le_msg_strings), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_elem_id,\r\n{ "Element ID", "gsm_bssmap_le.elem_id",\r\nFT_UINT8, BASE_HEX, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_apdu_protocol_id,\r\n{ "Protocol ID", "gsm_bssmap_le.apdu_protocol_id",\r\nFT_UINT8, BASE_DEC, VALS(gsm_apdu_protocol_id_strings), 0x0,\r\n"APDU embedded protocol id", HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_spare,\r\n{ "Spare", "gsm_bssmap_le.spare",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_ciphering_key_flag,\r\n{ "Ciphering Key Flag", "gsm_bssmap_le.decipheringKeys.flag",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_current_deciphering_key_value,\r\n{ "Current Deciphering Key Value", "gsm_bssmap_le.decipheringKeys.current",\r\nFT_UINT64, BASE_HEX, NULL, 0x0, NULL,\r\nHFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_next_deciphering_key_value,\r\n{ "Next Deciphering Key Value", "gsm_bssmap_le.decipheringKeys.next",\r\nFT_UINT64, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_acq_ass,\r\n{ "Acquisition Assistance", "gsm_bssmap_le.acq_ass",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_ref_time,\r\n{ "Reference Time", "gsm_bssmap_le.ref_time",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_ref_loc,\r\n{ "Reference Location", "gsm_bssmap_le.ref_loc",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_dgps_corr,\r\n{ "DGPS Corrections", "gsm_bssmap_le.gps_corr",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_nav_mod,\r\n{ "Navigation Model", "gsm_bssmap_le.nav_mod",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_iono_mod,\r\n{ "Ionospheric Model", "gsm_bssmap_le.iono_mod",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_utc_mod,\r\n{ "UTC Model", "gsm_bssmap_le.utc_mod",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_almanac,\r\n{ "Almanac", "gsm_bssmap_le.almanac",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_ephemeris_ext_chk,\r\n{ "Ephemeris Extension Check", "gsm_bssmap_le.ephemeris_ext_chk",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_ephemeris_ext,\r\n{ "Ephemeris Extension", "gsm_bssmap_le.ephemeris_ext",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_real_time_int,\r\n{ "Real-Time Integrity", "gsm_bssmap_le.real_time_int",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_gsm_bssmap_le_lcs_cause_value,\r\n{ "Cause Value", "gsm_bssmap_le.lcsCauseValue",\r\nFT_UINT8, BASE_HEX, VALS(bssmap_le_lcs_cause_values), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_diagnostic_value,\r\n{ "Diagnostic Value", "gsm_bssmap_le.diagnosticValue",\r\nFT_UINT8, BASE_HEX, VALS(bssmap_le_position_method_failure_diagnostic_vals), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_client_category,\r\n{ "Client Category", "gsm_bssmap_le.lcsClientType.clientCategory",\r\nFT_UINT8, BASE_HEX, VALS(bssmap_le_client_category), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_client_subtype,\r\n{ "Client Subtype", "gsm_bssmap_le.lcsClientType.clientSubtype",\r\nFT_UINT8, BASE_HEX, VALS(bssmap_le_client_subtype), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_velocity_requested,\r\n{ "Velocity Requested", "gsm_bssmap_le.lcsQos.velocityRequested",\r\nFT_UINT8, BASE_HEX, VALS(bssmap_le_velocity_requested_vals), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_vertical_coordinate_indicator,\r\n{ "Vertical Coordinate Indicator", "gsm_bssmap_le.lcsQos.verticalCoordinateIndicator",\r\nFT_UINT8, BASE_HEX, VALS(bssmap_le_vertical_coordinate_indicator_vals), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_horizontal_accuracy_indicator,\r\n{ "Horizontal Accuracy Indicator", "gsm_bssmap_le.lcsQos.horizontalAccuracyIndicator",\r\nFT_UINT8, BASE_HEX, VALS(bssmap_le_horizontal_accuracy_indicator_vals), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_horizontal_accuracy,\r\n{ "Horizontal Accuracy", "gsm_bssmap_le.lcsQos.horizontalAccuracy",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_vertical_accuracy,\r\n{ "Vertical Accuracy", "gsm_bssmap_le.lcsQos.verticalAccuracy",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_vertical_accuracy_indicator,\r\n{ "Vertical Accuracy Indicator", "gsm_bssmap_le.lcsQos.verticalAccuracyIndicator",\r\nFT_UINT8, BASE_HEX, VALS(bssmap_le_vertical_accuracy_indicator_vals), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_response_time_category,\r\n{ "Response Time Category", "gsm_bssmap_le.lcsQos.responseTimeCategory",\r\nFT_UINT8, BASE_HEX, VALS(bssmap_le_response_time_definitions_vals), 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_apdu,\r\n{ "APDU", "gsm_bssmap_le.apdu",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_bssmap_le_message_elements,\r\n{ "Message Elements", "gsm_bssmap_le.message_elements",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n};\r\nexpert_module_t* expert_gsm_a_bssmap_le;\r\nstatic ei_register_info ei[] = {\r\n{ &ei_gsm_a_bssmap_le_not_decoded_yet, { "gsm_bssmap_le.not_decoded_yet", PI_UNDECODED, PI_WARN, "Not decoded yet", EXPFILL }},\r\n{ &ei_gsm_a_bssmap_le_extraneous_data, { "gsm_bssmap_le.extraneous_data", PI_PROTOCOL, PI_NOTE, "Extraneous Data, dissector bug or later version spec(report to wireshark.org)", EXPFILL }},\r\n{ &ei_gsm_a_bssmap_le_missing_mandatory_element, { "gsm_bssmap_le.missing_mandatory_element", PI_PROTOCOL, PI_WARN, "Missing Mandatory element, rest of dissection is suspect", EXPFILL }},\r\n};\r\n#define NUM_INDIVIDUAL_ELEMS 1\r\ngint *ett[NUM_INDIVIDUAL_ELEMS + NUM_GSM_BSSMAP_LE_MSG +\r\nNUM_GSM_BSSMAP_LE_ELEM];\r\nett[0] = &ett_bssmap_le_msg;\r\nlast_offset = NUM_INDIVIDUAL_ELEMS;\r\nfor (i=0; i < NUM_GSM_BSSMAP_LE_MSG; i++, last_offset++)\r\n{\r\nett_gsm_bssmap_le_msg[i] = -1;\r\nett[last_offset] = &ett_gsm_bssmap_le_msg[i];\r\n}\r\nfor (i=0; i < NUM_GSM_BSSMAP_LE_ELEM; i++, last_offset++)\r\n{\r\nett_gsm_bssmap_le_elem[i] = -1;\r\nett[last_offset] = &ett_gsm_bssmap_le_elem[i];\r\n}\r\nproto_bssmap_le =\r\nproto_register_protocol("Lb-I/F BSSMAP LE", "GSM BSSMAP LE", "gsm_bssmap_le");\r\nproto_register_field_array(proto_bssmap_le, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_gsm_a_bssmap_le = expert_register_protocol(proto_bssmap_le);\r\nexpert_register_field_array(expert_gsm_a_bssmap_le, ei, array_length(ei));\r\nregister_dissector("gsm_bssmap_le", dissect_bssmap_le, proto_bssmap_le);\r\n}\r\nvoid\r\nproto_reg_handoff_gsm_bssmap_le(void)\r\n{\r\ndissector_handle_t bssmap_le_handle;\r\nbssmap_le_handle = find_dissector("gsm_bssmap_le");\r\ndissector_add_uint("bssap.pdu_type", BSSAP_PDU_TYPE_BSSMAP, bssmap_le_handle);\r\ngsm_bsslap_handle = find_dissector_add_dependency("gsm_bsslap", proto_bssmap_le);\r\n}
