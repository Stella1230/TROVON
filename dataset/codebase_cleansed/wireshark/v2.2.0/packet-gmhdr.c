static void\r\ndissect_gmtlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *gmhdr_tree, guint offset, guint16 length)\r\n{\r\nproto_tree *ti;\r\nproto_tree *srcport_tree;\r\nguint16 fl;\r\nwhile (length > 1) {\r\nguint16 tl = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nlength -= 2;\r\nfl = tl & 0xff;\r\nswitch (tl >> 8) {\r\ncase GMHDR_FTYPE_SRCPORT_G: {\r\nguint16 pid;\r\nguint32 tv = tvb_get_ntohl(tvb, offset) >> 8;\r\nif (fl != 3) {\r\nexpert_add_info_format(pinfo, gmhdr_tree, &ei_gmhdr_field_length_invalid, "Field length %u invalid", fl);\r\nbreak;\r\n}\r\nti = proto_tree_add_item(gmhdr_tree, hf_gmhdr_srcport_g, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nsrcport_tree = proto_item_add_subtree(ti, ett_srcport);\r\nproto_tree_add_item(srcport_tree, hf_gmhdr_srcport_g_plfm, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(srcport_tree, hf_gmhdr_srcport_g_gid, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(srcport_tree, hf_gmhdr_srcport_g_bid, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nti = proto_tree_add_item(srcport_tree, hf_gmhdr_srcport_g_pid, tvb, offset, fl, ENC_BIG_ENDIAN);\r\npid = ((tv & GMHDR_SRCPORT_G_PID_MASK) >> GMHDR_SRCPORT_G_PID_SHFT) - 24;\r\nif (pid >= 1 && pid <= 4) {\r\nproto_item_append_text(ti, " (g%d)", pid);\r\n}\r\nbreak;\r\n}\r\ncase GMHDR_FTYPE_PKTSIZE:\r\nif (fl != 2) {\r\nexpert_add_info_format(pinfo, gmhdr_tree, &ei_gmhdr_field_length_invalid, "Field length %u invalid", fl);\r\nbreak;\r\n}\r\nproto_tree_add_item(gmhdr_tree, hf_gmhdr_pktsize, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase GMHDR_FTYPE_TIMESTAMP_LOCAL:\r\ncase GMHDR_FTYPE_TIMESTAMP_NTP:\r\ncase GMHDR_FTYPE_TIMESTAMP_GPS:\r\ncase GMHDR_FTYPE_TIMESTAMP_1588:\r\nif (fl != 8) {\r\nexpert_add_info_format(pinfo, gmhdr_tree, &ei_gmhdr_field_length_invalid, "Field length %u invalid", fl);\r\nbreak;\r\n}\r\nti = proto_tree_add_item(gmhdr_tree, hf_gmhdr_timestamp, tvb, offset, fl, ENC_TIME_TIMESPEC|ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, "; Source: %s", val_to_str_const(tl>>8, gmhdr_ftype_timestamp, "Unknown"));\r\nbreak;\r\ncase GMHDR_FTYPE_FCS: {\r\nif (fl != 4) {\r\nexpert_add_info_format(pinfo, gmhdr_tree, &ei_gmhdr_field_length_invalid, "Field length %u invalid", fl);\r\nbreak;\r\n}\r\nti = proto_tree_add_item(gmhdr_tree, hf_gmhdr_origcrc, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, ", CRC (Not Verified)");\r\nbreak;\r\n}\r\ncase GMHDR_FTYPE_SRCPORT_H: {\r\nif (fl != 4) {\r\nexpert_add_info_format(pinfo, gmhdr_tree, &ei_gmhdr_field_length_invalid, "Field length %u invalid", fl);\r\nbreak;\r\n}\r\nti = proto_tree_add_item(gmhdr_tree, hf_gmhdr_srcport_h, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nsrcport_tree = proto_item_add_subtree(ti, ett_srcport);\r\nproto_tree_add_item(srcport_tree, hf_gmhdr_srcport_h_plfm, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(srcport_tree, hf_gmhdr_srcport_h_gid, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(srcport_tree, hf_gmhdr_srcport_h_bid, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(srcport_tree, hf_gmhdr_srcport_h_sid, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(srcport_tree, hf_gmhdr_srcport_h_pid, tvb, offset, fl, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\ndefault:\r\nti = proto_tree_add_item(gmhdr_tree, hf_gmhdr_generic, tvb, offset, fl, ENC_NA);\r\nproto_item_append_text(ti, " [Id: %u, Length: %u]", tl >> 8, fl);\r\nbreak;\r\n}\r\noffset += fl;\r\nlength -= fl;\r\n}\r\n}\r\nstatic int\r\ndissect_gmhdr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *ti;\r\ngint16 length;\r\nguint16 encap_proto;\r\ngboolean is_802_2;\r\nproto_tree *gmhdr_tree = NULL;\r\nguint offset = 0;\r\nlength = tvb_get_guint8(tvb, offset);\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_gmhdr, tvb, offset, length, ENC_NA);\r\nif (gmhdr_summary_in_tree) {\r\nproto_item_append_text(ti, ", Length: %u", length);\r\n}\r\ngmhdr_tree = proto_item_add_subtree(ti, ett_gmhdr);\r\ndissect_gmtlv(tvb, pinfo, gmhdr_tree, offset+1, length-1);\r\n}\r\noffset += length;\r\nencap_proto = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nif (encap_proto <= IEEE_802_3_MAX_LEN) {\r\nis_802_2 = TRUE;\r\nif (tvb_captured_length_remaining(tvb, offset) >= 2) {\r\nif (tvb_get_ntohs(tvb, offset) == 0xffff) {\r\nis_802_2 = FALSE;\r\n}\r\n}\r\ndissect_802_3(encap_proto, is_802_2, tvb, offset, pinfo, tree, gmhdr_tree,\r\nhf_gmhdr_len, hf_gmhdr_trailer, &ei_gmhdr_len, 0);\r\n} else {\r\nethertype_data_t ethertype_data;\r\nethertype_data.etype = encap_proto;\r\nethertype_data.offset_after_ethertype = offset;\r\nethertype_data.fh_tree = gmhdr_tree;\r\nethertype_data.etype_id = hf_gmhdr_etype;\r\nethertype_data.trailer_id = hf_gmhdr_trailer;\r\nethertype_data.fcs_len = 0;\r\ncall_dissector_with_data(ethertype_handle, tvb, pinfo, tree, &ethertype_data);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_gmtimestamp_trailer(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *ti;\r\nguint tvblen, trailer_len = 18;\r\nproto_tree *gmtrailer_tree = NULL;\r\nguint offset = 0;\r\nguint32 orig_crc, new_crc, comp_crc;\r\nguint16 port_num;\r\nnstime_t gmtimev;\r\nstruct tm *tm = NULL;\r\nif ( ! gmhdr_decode_timestamp_trailer)\r\nreturn 0;\r\ntvblen = tvb_captured_length(tvb);\r\nif (tvblen < trailer_len)\r\nreturn 0;\r\norig_crc = tvb_get_ntohl(tvb, offset);\r\nnew_crc = tvb_get_ntohl(tvb, tvblen - 4);\r\ncomp_crc = CRC32C_SWAP(crc32_ccitt_tvb_seed(tvb, 14, CRC32C_SWAP(~orig_crc)));\r\nif (comp_crc != new_crc)\r\nreturn 0;\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_gmtrailer, tvb, offset, trailer_len - 4, ENC_NA);\r\nif (gmtrailer_summary_in_tree) {\r\noffset += 4;\r\nport_num = tvb_get_ntohs(tvb, offset);\r\nproto_item_append_text(ti, ", Port: %d, Timestamp: ", port_num);\r\noffset += 2;\r\ngmtimev.secs = tvb_get_ntohl(tvb, offset);\r\noffset += 4;\r\ngmtimev.nsecs = tvb_get_ntohl(tvb, offset);\r\ntm = localtime(&gmtimev.secs);\r\nif (tm)\r\nproto_item_append_text(ti, "%d:%02d:%02d.%09d", tm->tm_hour, tm->tm_min, tm->tm_sec, gmtimev.nsecs);\r\nelse\r\nproto_item_append_text(ti, "<Not representable>");\r\n}\r\noffset = 0;\r\ngmtrailer_tree = proto_item_add_subtree(ti, ett_gmtrailer);\r\nproto_tree_add_item(gmtrailer_tree, hf_gmtrailer_origcrc, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(gmtrailer_tree, hf_gmtrailer_portid, tvb, offset+4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(gmtrailer_tree, hf_gmtrailer_timestamp, tvb, offset+6, 8, ENC_TIME_TIMESPEC|ENC_BIG_ENDIAN);\r\n}\r\nreturn 14;\r\n}\r\nstatic int\r\ndissect_gmtrailer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *ti;\r\nguint tvblen, length;\r\nproto_tree *gmhdr_tree = NULL;\r\nguint offset;\r\nguint16 cksum, comp_cksum, extra_trailer;\r\ntvblen = tvb_captured_length(tvb);\r\nif (tvblen < 5)\r\nreturn 0;\r\nextra_trailer = 0;\r\nif (tvb_get_ntohs(tvb, tvblen-4) != ETHERTYPE_GIGAMON) {\r\nif (tvblen < 10){\r\nreturn 0;\r\n}\r\nif (tvb_get_ntohs(tvb, tvblen-8) == ETHERTYPE_GIGAMON) {\r\nextra_trailer = 4;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nlength = tvb_get_guint8(tvb, tvblen-extra_trailer-5);\r\nif ((tvblen-extra_trailer-5) != length)\r\nreturn 0;\r\noffset = tvblen - extra_trailer - 5 - length;\r\ncksum = tvb_get_ntohs(tvb, tvblen-extra_trailer-2);\r\n{\r\nvec_t vec;\r\nSET_CKSUM_VEC_TVB(vec, tvb, offset, length + 3);\r\ncomp_cksum = in_cksum(&vec, 1);\r\nif (pntoh16(&comp_cksum) != cksum) {\r\nreturn 0;\r\n}\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_gmhdr, tvb, offset, length + 5, ENC_NA);\r\nif (gmhdr_summary_in_tree) {\r\nproto_item_append_text(ti, ", Length: %u, Checksum: 0x%x", length, cksum);\r\n}\r\ngmhdr_tree = proto_item_add_subtree(ti, ett_gmhdr);\r\ndissect_gmtlv(tvb, pinfo, gmhdr_tree, offset, length);\r\nif (extra_trailer) {\r\nproto_tree_add_item(tree, hf_gmhdr_trailer, tvb, length + 5, extra_trailer, ENC_NA);\r\n}\r\n}\r\nreturn tvblen;\r\n}\r\nvoid\r\nproto_register_gmhdr(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_gmhdr_srcport_g, {\r\n"Src Port", "gmhdr.srcport_g", FT_UINT24, BASE_HEX,\r\nNULL, 0, "Original Source Port", HFILL }},\r\n{ &hf_gmhdr_srcport_g_plfm, {\r\n"Platform Id", "gmhdr.srcport_g_plfm", FT_UINT24, BASE_DEC,\r\nVALS(gmhdr_plfm_str), GMHDR_SRCPORT_G_PLFM_MASK, "Original Platform Id", HFILL }},\r\n{ &hf_gmhdr_srcport_g_gid, {\r\n"Group Id", "gmhdr.srcport_g_gid", FT_UINT24, BASE_DEC,\r\nNULL, GMHDR_SRCPORT_G_GID_MASK, "Original Source Group Id", HFILL }},\r\n{ &hf_gmhdr_srcport_g_bid, {\r\n"Box Id", "gmhdr.srcport_g_bid", FT_UINT24, BASE_DEC,\r\nNULL, GMHDR_SRCPORT_G_BID_MASK, "Original Source Box Id", HFILL }},\r\n{ &hf_gmhdr_srcport_g_pid, {\r\n"Port Id", "gmhdr.srcport_g_pid", FT_UINT24, BASE_DEC,\r\nNULL, GMHDR_SRCPORT_G_PID_MASK, "Original Source Port Id", HFILL }},\r\n{ &hf_gmhdr_pktsize, {\r\n"Original Packet Size", "gmhdr.pktsize", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_gmhdr_timestamp, {\r\n"Time Stamp", "gmhdr.timestamp", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_gmhdr_generic, {\r\n"Generic Field", "gmhdr.generic", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_gmhdr_etype, {\r\n"Type", "gmhdr.etype", FT_UINT16, BASE_HEX,\r\nVALS(etype_vals), 0x0, "Ethertype", HFILL }},\r\n{ &hf_gmhdr_len, {\r\n"Length", "gmhdr.len", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_gmhdr_origcrc, {\r\n"Original CRC", "gmhdr.crc", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "Original Packet CRC", HFILL }},\r\n{ &hf_gmhdr_srcport_h, {\r\n"Src Port", "gmhdr.srcport", FT_UINT32, BASE_HEX,\r\nNULL, 0, "Original Source Port", HFILL }},\r\n{ &hf_gmhdr_srcport_h_plfm, {\r\n"Platform Id", "gmhdr.srcport_plfm", FT_UINT32, BASE_DEC,\r\nVALS(gmhdr_plfm_str), GMHDR_SRCPORT_H_PLFM_MASK, "Original Platform Id", HFILL }},\r\n{ &hf_gmhdr_srcport_h_gid, {\r\n"Group Id", "gmhdr.srcport_gid", FT_UINT32, BASE_DEC,\r\nNULL, GMHDR_SRCPORT_H_GID_MASK, "Original Source Group Id", HFILL }},\r\n{ &hf_gmhdr_srcport_h_bid, {\r\n"Box Id", "gmhdr.srcport_bid", FT_UINT32, BASE_DEC,\r\nNULL, GMHDR_SRCPORT_H_BID_MASK, "Original Source Box Id", HFILL }},\r\n{ &hf_gmhdr_srcport_h_sid, {\r\n"Slot Id", "gmhdr.srcport_sid", FT_UINT32, BASE_DEC,\r\nNULL, GMHDR_SRCPORT_H_SID_MASK, "Original Source Slot Id", HFILL }},\r\n{ &hf_gmhdr_srcport_h_pid, {\r\n"Port Id", "gmhdr.srcport_pid", FT_UINT32, BASE_DEC,\r\nNULL, GMHDR_SRCPORT_H_PID_MASK, "Original Source Port Id", HFILL }},\r\n{ &hf_gmhdr_trailer, {\r\n"Trailer", "gmhdr.trailer", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "GMHDR Trailer", HFILL }},\r\n};\r\nstatic hf_register_info gmtrailer_hf[] = {\r\n{ &hf_gmtrailer_origcrc, {\r\n"Original CRC", "gmtrailer.crc", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "Original Packet CRC", HFILL }},\r\n{ &hf_gmtrailer_portid, {\r\n"Src Port", "gmtrailer.portid", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, "Origin Source Port", HFILL }},\r\n{ &hf_gmtrailer_timestamp, {\r\n"Time Stamp", "gmtrailer.timestamp", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_gmhdr,\r\n&ett_srcport\r\n};\r\nstatic gint *gmtrailer_ett[] = {\r\n&ett_gmtrailer,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_gmhdr_field_length_invalid, { "gmhdr.field_length_invalid", PI_MALFORMED, PI_ERROR, "Field length invalid", EXPFILL }},\r\n{ &ei_gmhdr_len, { "gmhdr.len.past_end", PI_MALFORMED, PI_ERROR, "Length field value goes past the end of the payload", EXPFILL }},\r\n};\r\nmodule_t *gmhdr_module;\r\nmodule_t *gmtrailer_module;\r\nexpert_module_t* expert_gmhdr;\r\nproto_gmhdr = proto_register_protocol("Gigamon Header", "GMHDR", "gmhdr");\r\nproto_register_field_array(proto_gmhdr, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_gmhdr = expert_register_protocol(proto_gmhdr);\r\nexpert_register_field_array(expert_gmhdr, ei, array_length(ei));\r\nproto_gmtrailer = proto_register_protocol("Gigamon Trailer", "GMTRAILER", "gmtrailer");\r\nproto_register_field_array(proto_gmtrailer, gmtrailer_hf, array_length(gmtrailer_hf));\r\nproto_register_subtree_array(gmtrailer_ett, array_length(gmtrailer_ett));\r\ngmhdr_module = prefs_register_protocol(proto_gmhdr, NULL);\r\nprefs_register_bool_preference(gmhdr_module, "summary_in_tree",\r\n"Show Gigamon header summary in protocol tree",\r\n"Whether the Gigamon header summary line should be shown in the protocol tree",\r\n&gmhdr_summary_in_tree);\r\ngmtrailer_module = prefs_register_protocol(proto_gmtrailer, NULL);\r\nprefs_register_bool_preference(gmtrailer_module, "summary_in_tree",\r\n"Show Gigamon Trailer summary in protocol tree",\r\n"Whether the Gigamon Trailer summary line should be shown in the protocol tree",\r\n&gmtrailer_summary_in_tree);\r\nprefs_register_bool_preference(gmtrailer_module, "decode_trailer_timestamp",\r\n"Decode Gigamon HW timestamp and source id in trailer",\r\n"Whether the Gigamon trailer containing HW timestamp, source id and original CRC should be decoded",\r\n&gmhdr_decode_timestamp_trailer);\r\n}\r\nvoid\r\nproto_reg_handoff_gmhdr(void)\r\n{\r\ndissector_handle_t gmhdr_handle;\r\nethertype_handle = find_dissector_add_dependency("ethertype", proto_gmhdr);\r\ngmhdr_handle = create_dissector_handle(dissect_gmhdr, proto_gmhdr);\r\ndissector_add_uint("ethertype", ETHERTYPE_GIGAMON, gmhdr_handle);\r\nheur_dissector_add("eth.trailer", dissect_gmtrailer, "Gigamon Ethernet header", "gmhdr_eth", proto_gmhdr, HEURISTIC_ENABLE);\r\nheur_dissector_add("eth.trailer", dissect_gmtimestamp_trailer, "Gigamon Ethernet trailer", "gmtrailer_eth", proto_gmtrailer, HEURISTIC_ENABLE);\r\n}
