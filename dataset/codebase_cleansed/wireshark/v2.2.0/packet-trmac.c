static int\r\nsv_text(tvbuff_t *tvb, int svoff, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint sv_length, sv_id;\r\nguint16 beacon_type, ring;\r\nguint32 error_report_timer_value;\r\nproto_tree *sv_tree, *sv_subtree;\r\nproto_item *sv_item, *len_item, *ti;\r\nguchar errors[6];\r\nsv_tree = proto_tree_add_subtree(tree, tvb, svoff+0, 1, ett_tr_sv, &sv_item, "Subvector");\r\nsv_length = tvb_get_guint8(tvb, svoff+0);\r\nlen_item = proto_tree_add_item(sv_tree, hf_trmac_sv_len, tvb, svoff+0, 1, ENC_BIG_ENDIAN);\r\nif (sv_length < 2) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Invalid subvector: length < 2");\r\nreturn 0;\r\n}\r\nsv_id = tvb_get_guint8(tvb, svoff+1);\r\nproto_tree_add_item(sv_tree, hf_trmac_sv_id, tvb, svoff+1, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item, " (%s)", val_to_str_ext(sv_id, &subvector_vs_ext, "Unknown subvector ID 0x%02X"));\r\nswitch(sv_id) {\r\ncase 0x01:\r\nif (sv_length != 4) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4");\r\nbreak;\r\n}\r\nbeacon_type = tvb_get_ntohs(tvb, svoff+2);\r\nproto_tree_add_item(sv_tree, hf_trmac_beacon_type, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": %s", val_to_str(beacon_type, beacon_vs, "Illegal value: %d"));\r\nbreak;\r\ncase 0x02:\r\nif (sv_length != 8) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 8");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_naun, tvb, svoff+2, sv_length-2, ENC_NA);\r\nproto_item_append_text(sv_item, ": %s",\r\ntvb_ether_to_str(tvb, svoff+2));\r\nbreak;\r\ncase 0x03:\r\nif (sv_length != 4) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4");\r\nbreak;\r\n}\r\nring = tvb_get_ntohs(tvb, svoff+2);\r\nproto_tree_add_item(sv_tree, hf_trmac_local_ring_number, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": 0x%04X (%d)", ring, ring);\r\nbreak;\r\ncase 0x04:\r\nif (sv_length != 6) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 6");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_assign_physical_drop_number, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": 0x%08X", tvb_get_ntohl(tvb, svoff+2) );\r\nbreak;\r\ncase 0x05:\r\nif (sv_length != 4) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4");\r\nbreak;\r\n}\r\nerror_report_timer_value = 10 * tvb_get_ntohs(tvb, svoff+2);\r\nproto_tree_add_uint_format_value(sv_tree, hf_trmac_error_report_timer_value, tvb, svoff+2, sv_length-2,\r\nerror_report_timer_value, "%u ms", error_report_timer_value );\r\nproto_item_append_text(sv_item,\r\n": %u ms", error_report_timer_value );\r\nbreak;\r\ncase 0x06:\r\nif (sv_length != 4) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_authorized_function_classes, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": %04X", tvb_get_ntohs(tvb, svoff+2) );\r\nbreak;\r\ncase 0x07:\r\nif (sv_length != 4) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_authorized_access_priority, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": %04X", tvb_get_ntohs(tvb, svoff+2) );\r\nbreak;\r\ncase 0x09:\r\nif (sv_length != 4) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_correlator, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": %04X", tvb_get_ntohs(tvb, svoff+2) );\r\nbreak;\r\ncase 0x0A:\r\nif (sv_length != 8) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 8");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_sa_of_last_amp_or_smp_frame, tvb, svoff+2, sv_length-2, ENC_NA);\r\nproto_item_append_text(sv_item,\r\n": %s",\r\ntvb_ether_to_str(tvb, svoff+2));\r\nbreak;\r\ncase 0x0B:\r\nif (sv_length != 6) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 6");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_physical_drop_number, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": 0x%08X", tvb_get_ntohl(tvb, svoff+2) );\r\nbreak;\r\ncase 0x20:\r\nif (sv_length != 4 && sv_length != 6) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4 and != 6");\r\nbreak;\r\n}\r\nif (sv_length == 4) {\r\nproto_tree_add_uint_format_value(sv_tree, hf_trmac_response_code32, tvb, svoff+2, sv_length-2,\r\ntvb_get_ntohl(tvb, svoff+2), "0x%04X 0x%02X 0x%02x",\r\ntvb_get_ntohs(tvb, svoff+2), tvb_get_guint8(tvb, svoff+4), tvb_get_guint8(tvb, svoff+5));\r\nproto_item_append_text(sv_item,\r\n": 0x%04X 0x%02X 0x%02x",\r\ntvb_get_ntohs(tvb, svoff+2),\r\ntvb_get_guint8(tvb, svoff+4),\r\ntvb_get_guint8(tvb, svoff+5));\r\n} else {\r\nproto_tree_add_uint64_format_value(sv_tree, hf_trmac_response_code48, tvb, svoff+2, sv_length-2,\r\ntvb_get_ntoh48(tvb, svoff+2), "0x%04X 0x%02X 0x%06X",\r\ntvb_get_ntohs(tvb, svoff+2),\r\ntvb_get_guint8(tvb, svoff+4),\r\ntvb_get_ntoh24(tvb, svoff+5));\r\nproto_item_append_text(sv_item,\r\n": 0x%04X 0x%02X 0x%06X",\r\ntvb_get_ntohs(tvb, svoff+2),\r\ntvb_get_guint8(tvb, svoff+4),\r\ntvb_get_ntoh24(tvb, svoff+5));\r\n}\r\nbreak;\r\ncase 0x21:\r\nif (sv_length != 4) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_individual_address_count, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": %u", tvb_get_ntohs(tvb, svoff+2) );\r\nbreak;\r\ncase 0x22:\r\nproto_tree_add_item(sv_tree, hf_trmac_product_instance_id, tvb, svoff+2, sv_length-2, ENC_NA);\r\nbreak;\r\ncase 0x23:\r\nproto_tree_add_item(sv_tree, hf_trmac_ring_station_version_number, tvb, svoff+2, sv_length-2, ENC_NA);\r\nbreak;\r\ncase 0x26:\r\nproto_tree_add_item(sv_tree, hf_trmac_wrap_data, tvb, svoff+2, sv_length-2, ENC_NA);\r\nbreak;\r\ncase 0x27:\r\nproto_tree_add_item(sv_tree, hf_trmac_frame_forward, tvb, svoff+2, sv_length-2, ENC_NA);\r\nbreak;\r\ncase 0x28:\r\nif (sv_length != 8) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 8");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_station_identifier, tvb, svoff+2, sv_length-2, ENC_NA);\r\nproto_item_append_text(sv_item,\r\n": %s",\r\ntvb_ether_to_str(tvb, svoff+2));\r\nbreak;\r\ncase 0x29:\r\nproto_tree_add_item(sv_tree, hf_trmac_ring_station_status, tvb, svoff+2, sv_length-2, ENC_NA);\r\nbreak;\r\ncase 0x2A:\r\nif (sv_length != 4) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_transmit_status_code, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": %04X", tvb_get_ntohs(tvb, svoff+2) );\r\nbreak;\r\ncase 0x2B:\r\nif (sv_length != 6 && sv_length != 8) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 6 and != 8");\r\nbreak;\r\n}\r\nif (sv_length == 6) {\r\nproto_tree_add_item(sv_tree, hf_trmac_group_address32, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": %08X", tvb_get_ntohl(tvb, svoff+2) );\r\n} else {\r\nproto_tree_add_item(sv_tree, hf_trmac_group_address_ether, tvb, svoff+2, sv_length-2, ENC_NA);\r\nproto_item_append_text(sv_item,\r\n": %s",\r\ntvb_ether_to_str(tvb, svoff+2));\r\n}\r\nbreak;\r\ncase 0x2C:\r\nif (sv_length != 6) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 6");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_functional_addresses, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": %08X", tvb_get_ntohl(tvb, svoff+2) );\r\nbreak;\r\ncase 0x2D:\r\nif (sv_length != 8) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 8");\r\nbreak;\r\n}\r\ntvb_memcpy(tvb, errors, svoff+2, 6);\r\nti = proto_tree_add_uint(sv_tree, hf_trmac_errors_iso, tvb, svoff+2, sv_length-2,\r\nerrors[0] + errors[1] + errors[2] + errors[3] + errors[4]);\r\nsv_subtree = proto_item_add_subtree(ti, ett_tr_ierr_cnt);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_line, tvb, svoff+2, 1, errors[0]);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_internal, tvb, svoff+3, 1, errors[1]);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_burst, tvb, svoff+4, 1, errors[2]);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_ac, tvb, svoff+5, 1, errors[3]);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_abort, tvb, svoff+6, 1, errors[4]);\r\nbreak;\r\ncase 0x2E:\r\nif (sv_length != 8) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 8");\r\nbreak;\r\n}\r\ntvb_memcpy(tvb, errors, svoff+2, 6);\r\nti = proto_tree_add_uint(sv_tree, hf_trmac_errors_noniso, tvb, svoff+2, sv_length-2,\r\nerrors[0] + errors[1] + errors[2] + errors[3] + errors[4]);\r\nsv_subtree = proto_item_add_subtree(ti, ett_tr_nerr_cnt);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_lost, tvb, svoff+2, 1, errors[0]);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_congestion, tvb, svoff+3, 1, errors[1]);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_fc, tvb, svoff+4, 1, errors[2]);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_freq, tvb, svoff+5, 1, errors[3]);\r\nproto_tree_add_uint(sv_subtree, hf_trmac_errors_token, tvb, svoff+6, 1, errors[4]);\r\nbreak;\r\ncase 0x30:\r\nif (sv_length != 4) {\r\nexpert_add_info_format(pinfo, len_item, &ei_trmac_sv_len,\r\n"Subvector length is != 4");\r\nbreak;\r\n}\r\nproto_tree_add_item(sv_tree, hf_trmac_error_code, tvb, svoff+2, sv_length-2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(sv_item,\r\n": %04X", tvb_get_ntohs(tvb, svoff+2) );\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(sv_tree, hf_trmac_unknown_subvector, tvb, svoff+2, sv_length-2, ENC_NA);\r\nbreak;\r\n}\r\nreturn sv_length;\r\n}\r\nstatic int\r\ndissect_trmac(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *mac_tree = NULL;\r\nproto_item *ti;\r\nint mv_length, sv_offset, sv_additional;\r\nguint8 mv_val;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TR MAC");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nmv_val = tvb_get_guint8(tvb, 3);\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_ext(mv_val, &major_vector_vs_ext, "Unknown Major Vector: %u"));\r\nif (tree) {\r\nmv_length = tvb_get_ntohs(tvb, 0);\r\nti = proto_tree_add_item(tree, proto_trmac, tvb, 0, mv_length, ENC_NA);\r\nmac_tree = proto_item_add_subtree(ti, ett_tr_mac);\r\nproto_tree_add_uint(mac_tree, hf_trmac_mv, tvb, 3, 1, mv_val);\r\nproto_tree_add_uint_format_value(mac_tree, hf_trmac_length, tvb, 0, 2, mv_length,\r\n"%d bytes", mv_length);\r\nproto_tree_add_uint(mac_tree, hf_trmac_srcclass, tvb, 2, 1, tvb_get_guint8(tvb, 2) & 0x0f);\r\nproto_tree_add_uint(mac_tree, hf_trmac_dstclass, tvb, 2, 1, tvb_get_guint8(tvb, 2) >> 4 );\r\nsv_offset = 4;\r\nwhile (sv_offset < mv_length) {\r\nsv_additional = sv_text(tvb, sv_offset, pinfo, mac_tree);\r\nif (sv_additional > 0)\r\nsv_offset += sv_additional;\r\nelse\r\nbreak;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_trmac(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_trmac_mv,\r\n{ "Major Vector", "trmac.mvec", FT_UINT8, BASE_HEX|BASE_EXT_STRING, &major_vector_vs_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_length,\r\n{ "Total Length", "trmac.length", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_srcclass,\r\n{ "Source Class", "trmac.srcclass", FT_UINT8, BASE_HEX, VALS(classes_vs), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_dstclass,\r\n{ "Destination Class", "trmac.dstclass", FT_UINT8, BASE_HEX, VALS(classes_vs), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_sv_len,\r\n{ "Subvector Length", "trmac.svec.len", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_sv_id,\r\n{ "Subvector Identifier", "trmac.svec.id", FT_UINT8, BASE_HEX|BASE_EXT_STRING, &subvector_vs_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_iso,\r\n{ "Isolating Errors", "trmac.errors.iso", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_line,\r\n{ "Line Errors", "trmac.errors.line", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_internal,\r\n{ "Internal Errors", "trmac.errors.internal", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_burst,\r\n{ "Burst Errors", "trmac.errors.burst", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_ac,\r\n{ "A/C Errors", "trmac.errors.ac", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_abort,\r\n{ "Abort Delimiter Transmitted Errors", "trmac.errors.abort", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_noniso,\r\n{ "Non-Isolating Errors", "trmac.errors.noniso", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_lost,\r\n{ "Lost Frame Errors", "trmac.errors.lost", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_congestion,\r\n{ "Receiver Congestion Errors", "trmac.errors.congestion", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_fc,\r\n{ "Frame-Copied Errors", "trmac.errors.fc", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_freq,\r\n{ "Frequency Errors", "trmac.errors.freq", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_errors_token,\r\n{ "Token Errors", "trmac.errors.token", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_naun,\r\n{ "Upstream Neighbor's Address", "trmac.naun", FT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_beacon_type,\r\n{ "Beacon Type", "trmac.beacon_type", FT_UINT16, BASE_DEC, VALS(beacon_vs), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_local_ring_number,\r\n{ "Local Ring Number", "trmac.local_ring_number", FT_UINT16, BASE_HEX_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_assign_physical_drop_number,\r\n{ "Assign Physical Drop Number", "trmac.assign_physical_drop_number", FT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_error_report_timer_value,\r\n{ "Error Report Timer Value", "trmac.error_report_timer_value", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_authorized_function_classes,\r\n{ "Authorized Function Classes", "trmac.authorized_function_classes", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_authorized_access_priority,\r\n{ "Authorized Access Priority", "trmac.authorized_access_priority", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_correlator,\r\n{ "Correlator", "trmac.correlator", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_sa_of_last_amp_or_smp_frame,\r\n{ "SA of Last AMP or SMP Frame", "trmac.sa_of_last_amp_or_smp_frame", FT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_physical_drop_number,\r\n{ "Physical Drop Number", "trmac.physical_drop_number", FT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_individual_address_count,\r\n{ "Individual Address Count", "trmac.individual_address_count", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_station_identifier,\r\n{ "Station Identifier", "trmac.station_identifier", FT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_transmit_status_code,\r\n{ "Transmit Status Code", "trmac.transmit_status_code", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_group_address32,\r\n{ "Group Address", "trmac.group_addres32s", FT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_group_address_ether,\r\n{ "Group Address", "trmac.group_address_ether", FT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_functional_addresses,\r\n{ "Functional Addresses", "trmac.functional_addresses", FT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_error_code,\r\n{ "Error Code", "trmac.error_code", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_trmac_response_code32, { "Response Code", "trmac.response_code", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_trmac_response_code48, { "Response Code", "trmac.response_code48", FT_UINT64, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_trmac_product_instance_id, { "Product Instance ID", "trmac.product_instance_id", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_trmac_ring_station_version_number, { "Ring Station Version Number", "trmac.ring_station_version_number", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_trmac_wrap_data, { "Wrap Data", "trmac.wrap_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_trmac_frame_forward, { "Frame Forward", "trmac.frame_forward", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_trmac_ring_station_status, { "Ring Station Status", "trmac.ring_station_status", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_trmac_unknown_subvector, { "Unknown Subvector", "trmac.unknown_subvector", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tr_mac,\r\n&ett_tr_sv,\r\n&ett_tr_ierr_cnt,\r\n&ett_tr_nerr_cnt,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_trmac_sv_len, { "trmac.svec.len.invalid", PI_MALFORMED, PI_ERROR, "Invalid length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_trmac;\r\nproto_trmac = proto_register_protocol("Token-Ring Media Access Control", "TR MAC", "trmac");\r\nproto_register_field_array(proto_trmac, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_trmac = expert_register_protocol(proto_trmac);\r\nexpert_register_field_array(expert_trmac, ei, array_length(ei));\r\nregister_dissector("trmac", dissect_trmac, proto_trmac);\r\n}
