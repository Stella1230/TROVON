void dissect_extended_tlv(proto_tree *reg_req_tree, gint tlv_type, tvbuff_t *tvb, guint tlv_offset, guint tlv_len, packet_info *pinfo, guint offset, gint proto_registry)\r\n{\r\nproto_item *tlv_item;\r\nproto_tree *tlv_tree;\r\nguint tvb_len;\r\ntlv_info_t tlv_info;\r\nguint tlv_end;\r\nguint length;\r\nguint nblocks;\r\ntvb_len = tvb_reported_length(tvb);\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\n#ifdef WIMAX_16E_2005\r\nswitch (tlv_type) {\r\ncase REG_ARQ_PARAMETERS:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_mac_mgmt_msg_reg_req_decoder, reg_req_tree, proto_registry, tvb, offset, tlv_len, "ARQ Service Flow Encodings");\r\nwimax_service_flow_encodings_decoder(tvb_new_subset_length(tvb, tlv_offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase REG_SS_MGMT_SUPPORT:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_ss_mgmt_support, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_IP_MGMT_MODE:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_ip_mgmt_mode, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_IP_VERSION:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_ip_version, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_UL_TRANSPORT_CIDS_SUPPORTED:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_ul_cids, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_POWER_SAVING_CLASS_CAPABILITY:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_power_saving_class_capability, tvb, offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_mac_mgmt_msg_reg_req_decoder);\r\nproto_tree_add_item(tlv_tree, hf_reg_power_saving_class_type_i, tvb, tlv_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_power_saving_class_type_ii, tvb, tlv_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_power_saving_class_type_iii, tvb, tlv_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_multi_active_power_saving_classes, tvb, tlv_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_total_power_saving_class_instances, tvb, tlv_offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_power_saving_class_reserved, tvb, tlv_offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_IP_PHS_SDU_ENCAP:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_ip_phs_sdu_encap, tvb, offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_mac_mgmt_msg_reg_req_decoder);\r\n#ifdef WIMAX_16E_2005\r\nif (tlv_len == 2){\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_atm_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv4_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv6_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_802_3_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_802_1q_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv4_802_3_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv6_802_3_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv4_802_1q_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv6_802_1q_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_packet_8023_ethernet_and_rohc_header_compression_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_packet_8023_ethernet_and_ecrtp_header_compression_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_packet_ip_rohc_header_compression_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_packet_ip_ecrtp_header_compression_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_rsvd_2, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\n} else if(tlv_len == 4){\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_atm_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv4_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv6_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_802_3_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_802_1q_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv4_802_3_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv6_802_3_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv4_802_1q_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_ipv6_802_1q_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_packet_8023_ethernet_and_rohc_header_compression_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_packet_8023_ethernet_and_ecrtp_header_compression_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_packet_ip_rohc_header_compression_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_packet_ip_ecrtp_header_compression_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_encap_rsvd_4, tvb, tlv_offset, tlv_len, ENC_BIG_ENDIAN);\r\n}\r\n#endif\r\nbreak;\r\ncase REG_MAX_CLASSIFIERS_SUPPORTED:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_max_classifiers, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_PHS_SUPPORT:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_phs, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_ARQ_SUPPORT:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_arq, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_DSX_FLOW_CONTROL:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_dsx_flow_control, tvb, offset, ENC_BIG_ENDIAN);\r\nif (tvb_get_guint8(tvb, tlv_offset) == 0) {\r\nproto_item_append_text(tlv_item, " (no limit)");\r\n}\r\nbreak;\r\ncase REG_MAC_CRC_SUPPORT:\r\nif (!include_cor2_changes) {\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_mac_crc_support, tvb, offset, ENC_NA);\r\n} else {\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_tlv_type, tvb, offset, ENC_NA);\r\n}\r\nbreak;\r\ncase REG_MCA_FLOW_CONTROL:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_mca_flow_control, tvb, offset, ENC_BIG_ENDIAN);\r\nif (tvb_get_guint8(tvb, tlv_offset) == 0) {\r\nproto_item_append_text(tlv_item, " (no limit)");\r\n}\r\nbreak;\r\ncase REG_MCAST_POLLING_CIDS:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_mcast_polling_cids, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_NUM_DL_TRANS_CID:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_num_dl_trans_cid, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_MAC_ADDRESS:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_mac_address, tvb, offset, ENC_NA);\r\nbreak;\r\ncase REG_TLV_T_20_MAX_MAC_DATA_PER_FRAME_SUPPORT:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_mac_mgmt_msg_reg_req_decoder, reg_req_tree, proto_registry, tvb, offset, tlv_len, "Maximum MAC level data per frame");\r\ntlv_end = tlv_offset + tlv_len;\r\nwhile ( tlv_offset < tlv_end )\r\n{\r\ninit_tlv_info(&tlv_info, tvb, tlv_offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\nlength = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || length > MAX_TLV_LEN || length < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "REG-REQ TLV error");\r\nproto_tree_add_item(reg_req_tree, hf_reg_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_offset += get_tlv_value_offset(&tlv_info);\r\nnblocks = tvb_get_ntohs(tvb, tlv_offset);\r\nswitch (tlv_type)\r\n{\r\ncase REG_TLV_T_20_1_MAX_MAC_LEVEL_DATA_PER_DL_FRAME:\r\ntlv_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_reg_tlv_t_20_1_max_mac_level_data_per_dl_frame, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nif ( nblocks == 0 )\r\n{\r\nproto_item_append_text(tlv_item, " (Unlimited bytes)");\r\n} else {\r\nproto_item_append_text(tlv_item, " (%d bytes)", 256 * nblocks);\r\n}\r\nbreak;\r\ncase REG_TLV_T_20_2_MAX_MAC_LEVEL_DATA_PER_UL_FRAME:\r\ntlv_item = add_tlv_subtree(&tlv_info, tlv_tree, hf_reg_tlv_t_20_2_max_mac_level_data_per_ul_frame, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_BIG_ENDIAN);\r\nif ( nblocks == 0 )\r\n{\r\nproto_item_append_text(tlv_item, " (Unlimited bytes)");\r\n} else {\r\nproto_item_append_text(tlv_item, " (%d bytes)", 256 * nblocks);\r\n}\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, tlv_tree, hf_reg_invalid_tlv, tvb, tlv_offset-get_tlv_value_offset(&tlv_info), ENC_NA);\r\nbreak;\r\n}\r\ntlv_offset += length;\r\n}\r\nbreak;\r\ncase REG_TLV_T_21_PACKING_SUPPORT:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_21_packing_support, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_22_MAC_EXTENDED_RTPS_SUPPORT:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_22_mac_extended_rtps_support, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_23_MAX_NUM_BURSTS_TRANSMITTED_CONCURRENTLY_TO_THE_MS:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_23_max_num_bursts_concurrently_to_the_ms, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_26_METHOD_FOR_ALLOCATING_IP_ADDR_SECONDARY_MGMNT_CONNECTION:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_26_method_alloc_ip_addr_secondary_mgmnt_conn, tvb, offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_mac_mgmt_msg_reg_req_decoder);\r\nproto_tree_add_item(tlv_tree, hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_dhcp, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_mobile_ipv4, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_dhcpv6, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_ipv6, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_rsvd, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_27_HANDOVER_SUPPORTED:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_27_handover_supported, tvb, offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_mac_mgmt_msg_reg_req_decoder);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_27_handover_fbss_mdho_ho_disable, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_27_handover_fbss_mdho_dl_rf_monitoring_maps, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_27_handover_mdho_dl_monitoring_single_map, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_27_handover_mdho_dl_monitoring_maps, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_27_handover_mdho_ul_multiple, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_27_handover_reserved, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_29_HO_PROCESS_OPTIMIZATION_MS_TIMER:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_29_ho_process_opt_ms_timer, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_31_MOBILITY_FEATURES_SUPPORTED:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_31_mobility_features_supported, tvb, offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_mac_mgmt_msg_reg_req_decoder);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_31_mobility_handover, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_31_mobility_sleep_mode, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_31_mobility_idle_mode, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_40_ARQ_ACK_TYPE:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_40_arq_ack_type, tvb, offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_mac_mgmt_msg_reg_req_decoder);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_40_arq_ack_type_selective_ack_entry, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_40_arq_ack_type_cumulative_ack_entry, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_40_arq_ack_type_cumulative_with_selective_ack_entry, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_40_arq_ack_type_cumulative_ack_with_block_sequence_ack, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_40_arq_ack_type_reserved, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_41_MS_HO_CONNECTIONS_PARAM_PROCESSING_TIME:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_41_ho_connections_param_processing_time, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_42_MS_HO_TEK_PROCESSING_TIME:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_42_ho_tek_processing_time, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_TLV_T_43_MAC_HEADER_AND_EXTENDED_SUBHEADER_SUPPORT:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_43_mac_header_ext_header_support, tvb, offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_mac_mgmt_msg_reg_req_decoder);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_bandwidth_request_ul_tx_power_report_header_support, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_bandwidth_request_cinr_report_header_support, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_cqich_allocation_request_header_support, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_phy_channel_report_header_support, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_bandwidth_request_ul_sleep_control_header_support, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_sn_report_header_support, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_feedback_header_support, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_sdu_sn_extended_subheader_support_and_parameter, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_sdu_sn_parameter, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_dl_sleep_control_extended_subheader, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_feedback_request_extended_subheader, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_mimo_mode_feedback_extended_subheader, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_ul_tx_power_report_extended_subheader, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_mini_feedback_extended_subheader, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_sn_request_extended_subheader, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_pdu_sn_short_extended_subheader, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_pdu_sn_long_extended_subheader, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_tlv_t_43_reserved, tvb, tlv_offset, 3, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_REQ_BS_SWITCHING_TIMER:\r\ntlv_item = add_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_req_bs_switching_timer, tvb, offset, ENC_BIG_ENDIAN);\r\ntlv_tree = proto_item_add_subtree(tlv_item, ett_mac_mgmt_msg_reg_req_decoder);\r\nproto_tree_add_item(tlv_tree, hf_reg_req_min_time_for_intra_fa, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tlv_tree, hf_reg_req_min_time_for_inter_fa, tvb, tlv_offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase VENDOR_SPECIFIC_INFO:\r\ncase VENDOR_ID_ENCODING:\r\ncase CURRENT_TX_POWER:\r\ncase MAC_VERSION_ENCODING:\r\ncase CMAC_TUPLE:\r\nwimax_common_tlv_encoding_decoder(tvb_new_subset_remaining(tvb, offset), pinfo, reg_req_tree);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, proto_registry, tvb, offset, ENC_NA);\r\nbreak;\r\n}\r\n#endif\r\n}\r\nstatic int dissect_mac_mgmt_msg_reg_req_decoder(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint offset = 0;\r\nguint tlv_offset;\r\nguint tvb_len;\r\nproto_item *reg_req_item = NULL;\r\nproto_tree *reg_req_tree = NULL;\r\nproto_tree *tlv_tree = NULL;\r\ngboolean hmac_found = FALSE;\r\ntlv_info_t tlv_info;\r\ngint tlv_type;\r\ngint tlv_len;\r\n{\r\ntvb_len = tvb_reported_length(tvb);\r\nreg_req_item = proto_tree_add_protocol_format(tree, proto_mac_mgmt_msg_reg_req_decoder, tvb, offset, tvb_len, "MAC Management Message, REG-REQ");\r\nreg_req_tree = proto_item_add_subtree(reg_req_item, ett_mac_mgmt_msg_reg_req_decoder);\r\nwhile(offset < tvb_len)\r\n{\r\ninit_tlv_info(&tlv_info, tvb, offset);\r\ntlv_type = get_tlv_type(&tlv_info);\r\ntlv_len = get_tlv_length(&tlv_info);\r\nif(tlv_type == -1 || tlv_len > MAX_TLV_LEN || tlv_len < 1)\r\n{\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "REG-REQ TLV error");\r\nproto_tree_add_item(reg_req_tree, hf_reg_invalid_tlv, tvb, offset, (tvb_len - offset), ENC_NA);\r\nbreak;\r\n}\r\ntlv_offset = offset + get_tlv_value_offset(&tlv_info);\r\nswitch (tlv_type) {\r\ncase REG_ARQ_PARAMETERS:\r\ncase REG_SS_MGMT_SUPPORT:\r\ncase REG_IP_MGMT_MODE:\r\ncase REG_IP_VERSION:\r\ncase REG_UL_TRANSPORT_CIDS_SUPPORTED:\r\ncase REG_IP_PHS_SDU_ENCAP:\r\ncase REG_MAX_CLASSIFIERS_SUPPORTED:\r\ncase REG_PHS_SUPPORT:\r\ncase REG_ARQ_SUPPORT:\r\ncase REG_DSX_FLOW_CONTROL:\r\ncase REG_MAC_CRC_SUPPORT:\r\ncase REG_MCA_FLOW_CONTROL:\r\ncase REG_MCAST_POLLING_CIDS:\r\ncase REG_NUM_DL_TRANS_CID:\r\ncase REG_MAC_ADDRESS:\r\n#ifdef WIMAX_16E_2005\r\ncase REG_TLV_T_20_MAX_MAC_DATA_PER_FRAME_SUPPORT:\r\ncase REG_TLV_T_21_PACKING_SUPPORT:\r\ncase REG_TLV_T_22_MAC_EXTENDED_RTPS_SUPPORT:\r\ncase REG_TLV_T_23_MAX_NUM_BURSTS_TRANSMITTED_CONCURRENTLY_TO_THE_MS:\r\ncase REG_TLV_T_26_METHOD_FOR_ALLOCATING_IP_ADDR_SECONDARY_MGMNT_CONNECTION:\r\ncase REG_TLV_T_27_HANDOVER_SUPPORTED:\r\ncase REG_TLV_T_29_HO_PROCESS_OPTIMIZATION_MS_TIMER:\r\ncase REG_TLV_T_31_MOBILITY_FEATURES_SUPPORTED:\r\ncase REG_TLV_T_40_ARQ_ACK_TYPE:\r\ncase REG_TLV_T_41_MS_HO_CONNECTIONS_PARAM_PROCESSING_TIME:\r\ncase REG_TLV_T_42_MS_HO_TEK_PROCESSING_TIME:\r\ncase REG_TLV_T_43_MAC_HEADER_AND_EXTENDED_SUBHEADER_SUPPORT:\r\ncase REG_REQ_BS_SWITCHING_TIMER:\r\ncase REG_POWER_SAVING_CLASS_CAPABILITY:\r\n#endif\r\ndissect_extended_tlv(reg_req_tree, tlv_type, tvb, tlv_offset, tlv_len, pinfo, offset, proto_mac_mgmt_msg_reg_req_decoder);\r\nbreak;\r\ncase REG_REQ_SECONDARY_MGMT_CID:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_req_secondary_mgmt_cid, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_REQ_TLV_T_32_SLEEP_MODE_RECOVERY_TIME:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_req_tlv_t_32_sleep_mode_recovery_time, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_REQ_TLV_T_33_MS_PREV_IP_ADDR:\r\nif ( tlv_len == 4 ) {\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_ms_previous_ip_address_v4, tvb, offset, ENC_BIG_ENDIAN);\r\n} else if ( tlv_len == 16 ) {\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_ms_previous_ip_address_v6, tvb, offset, ENC_NA);\r\n}\r\nbreak;\r\ncase REG_TLV_T_37_IDLE_MODE_TIMEOUT:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_idle_mode_timeout, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_REQ_TLV_T_45_MS_PERIODIC_RANGING_TIMER_INFO:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_req_tlv_t_45_ms_periodic_ranging_timer, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase REG_HANDOVER_INDICATION_READINESS_TIMER:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_reg_tlv_t_46_handover_indication_readiness_timer, tvb, offset, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase DSx_UPLINK_FLOW:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_mac_mgmt_msg_reg_req_decoder, reg_req_tree, proto_mac_mgmt_msg_reg_req_decoder, tvb, offset, tlv_len, "Uplink Service Flow Encodings");\r\nwimax_service_flow_encodings_decoder(tvb_new_subset_length(tvb, tlv_offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase DSx_DOWNLINK_FLOW:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_mac_mgmt_msg_reg_req_decoder, reg_req_tree, proto_mac_mgmt_msg_reg_req_decoder, tvb, offset, tlv_len, "Downlink Service Flow Encodings");\r\nwimax_service_flow_encodings_decoder(tvb_new_subset_length(tvb, tlv_offset, tlv_len), pinfo, tlv_tree);\r\nbreak;\r\ncase HMAC_TUPLE:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_mac_mgmt_msg_reg_req_decoder, reg_req_tree, proto_mac_mgmt_msg_reg_req_decoder, tvb, offset, tlv_len, "HMAC Tuple");\r\nwimax_hmac_tuple_decoder(tlv_tree, tvb, tlv_offset, tlv_len);\r\nhmac_found = TRUE;\r\nbreak;\r\ncase CMAC_TUPLE:\r\ntlv_tree = add_protocol_subtree(&tlv_info, ett_mac_mgmt_msg_reg_req_decoder, reg_req_tree, proto_mac_mgmt_msg_reg_req_decoder, tvb, offset, tlv_len, "CMAC Tuple");\r\nwimax_cmac_tuple_decoder(tlv_tree, tvb, tlv_offset, tlv_len);\r\nbreak;\r\ndefault:\r\nadd_tlv_subtree(&tlv_info, reg_req_tree, hf_tlv_type, tvb, offset, ENC_NA);\r\nbreak;\r\n}\r\noffset = tlv_len + tlv_offset;\r\n}\r\nif (!hmac_found)\r\nproto_item_append_text(reg_req_tree, " (HMAC Tuple is missing !)");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_mac_mgmt_msg_reg_req(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n{\r\n&hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_dhcp,\r\n{\r\n"DHCP", "wmx.reg.alloc_sec_mgmt_dhcp",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x01, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_dhcpv6,\r\n{\r\n"DHCPv6", "wmx.reg.alloc_sec_mgmt_dhcpv6",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x04, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_ipv6,\r\n{\r\n"IPv6 Stateless Address Autoconfiguration", "wmx.reg.alloc_sec_mgmt_ipv6",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x08, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_mobile_ipv4,\r\n{\r\n"Mobile IPv4", "wmx.reg.alloc_sec_mgmt_mobile_ipv4",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x02, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_method_for_allocating_ip_addr_sec_mgmt_conn_rsvd,\r\n{\r\n"Reserved", "wmx.reg.alloc_sec_mgmt_rsvd",\r\nFT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_arq,\r\n{\r\n"ARQ support", "wmx.reg.arq",\r\nFT_BOOLEAN, BASE_NONE, TFS(&tfs_supported), 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_40_arq_ack_type_cumulative_ack_entry,\r\n{\r\n"Cumulative ACK entry", "wmx.reg.arq_ack_type_cumulative_ack_entry",\r\nFT_UINT8, BASE_DEC, NULL, 0x2, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_40_arq_ack_type_cumulative_ack_with_block_sequence_ack,\r\n{\r\n"Cumulative ACK with Block Sequence ACK", "wmx.reg.arq_ack_type_cumulative_ack_with_block_sequence_ack",\r\nFT_UINT8, BASE_DEC, NULL, 0x8, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_40_arq_ack_type_cumulative_with_selective_ack_entry,\r\n{\r\n"Cumulative with Selective ACK entry", "wmx.reg.arq_ack_type_cumulative_with_selective_ack_entry",\r\nFT_UINT8, BASE_DEC, NULL, 0x4, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_40_arq_ack_type_reserved,\r\n{\r\n"Reserved", "wmx.reg.arq_ack_type_reserved",\r\nFT_UINT8, BASE_DEC, NULL, 0xf0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_40_arq_ack_type_selective_ack_entry,\r\n{\r\n"Selective ACK entry", "wmx.reg.arq_ack_type_selective_ack_entry",\r\nFT_UINT8, BASE_DEC, NULL, 0x1, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_bandwidth_request_cinr_report_header_support,\r\n{\r\n"Bandwidth request and CINR report header support", "wmx.reg.bandwidth_request_cinr_report_header_support",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x2, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_bandwidth_request_ul_sleep_control_header_support,\r\n{\r\n"Bandwidth request and uplink sleep control header support", "wmx.reg.bandwidth_request_ul_sleep_control_header_support",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x10, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_cqich_allocation_request_header_support,\r\n{\r\n"CQICH Allocation Request header support", "wmx.reg.cqich_allocation_request_header_support",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x4, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_dl_sleep_control_extended_subheader,\r\n{\r\n"Downlink sleep control extended subheader", "wmx.reg.dl_sleep_control_extended_subheader",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x800, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_dsx_flow_control,\r\n{\r\n"DSx flow control", "wmx.reg.dsx_flow_control",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_802_1q_2,\r\n{\r\n"Packet, 802.1Q VLAN", "wmx.reg.encap_802_1q",\r\nFT_UINT16, BASE_HEX, NULL, 0x0010, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_802_3_2,\r\n{\r\n"Packet, 802.3/Ethernet", "wmx.reg.encap_802_3",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000008, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_atm_2,\r\n{\r\n"ATM", "wmx.reg.encap_atm",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000001, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv4_2,\r\n{\r\n"Packet, IPv4", "wmx.reg.encap_ipv4",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000002, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv6_2,\r\n{\r\n"Packet, IPv6", "wmx.reg.encap_ipv6",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000004, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv4_802_1q_2,\r\n{\r\n"Packet, IPv4 over 802.1Q VLAN", "wmx.reg.encap_ipv4_802_1q",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000080, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv4_802_3_2,\r\n{\r\n"Packet, IPv4 over 802.3/Ethernet", "wmx.reg.encap_ipv4_802_3",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000020, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv6_802_1q_2,\r\n{\r\n"Packet, IPv6 over 802.1Q VLAN", "wmx.reg.encap_ipv6_802_1q",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000100, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv6_802_3_2,\r\n{\r\n"Packet, IPv6 over 802.3/Ethernet", "wmx.reg.encap_ipv6_802_3",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000040, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_packet_8023_ethernet_and_ecrtp_header_compression_2,\r\n{\r\n"Packet, 802.3/Ethernet (with optional 802.1Q VLAN tags) and ECRTP header compression", "wmx.reg.encap_packet_802_3_ethernet_and_ecrtp_header_compression",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000400, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_packet_8023_ethernet_and_rohc_header_compression_2,\r\n{\r\n"Packet, 802.3/Ethernet (with optional 802.1Q VLAN tags) and ROHC header compression", "wmx.reg.encap_packet_802_3_ethernet_and_rohc_header_compression",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000200, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_packet_ip_ecrtp_header_compression_2,\r\n{\r\n"Packet, IP (v4 or v6) with ECRTP header compression", "wmx.reg.encap_packet_ip_ecrtp_header_compression",\r\nFT_UINT16, BASE_HEX, NULL, 0x00001000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_packet_ip_rohc_header_compression_2,\r\n{\r\n"Packet, IP (v4 or v6) with ROHC header compression", "wmx.reg.encap_packet_ip_rohc_header_compression",\r\nFT_UINT16, BASE_HEX, NULL, 0x00000800, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_rsvd_2,\r\n{\r\n"Reserved", "wmx.reg.encap_rsvd",\r\nFT_UINT16, BASE_HEX, NULL, 0x0000E000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_802_1q_4,\r\n{\r\n"Packet, 802.1Q VLAN", "wmx.reg.encap_802_1q",\r\nFT_UINT32, BASE_HEX, NULL, 0x0010, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_802_3_4,\r\n{\r\n"Packet, 802.3/Ethernet", "wmx.reg.encap_802_3",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000008, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_atm_4,\r\n{\r\n"ATM", "wmx.reg.encap_atm",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000001, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv4_4,\r\n{\r\n"Packet, IPv4", "wmx.reg.encap_ipv4",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000002, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv4_802_1q_4,\r\n{\r\n"Packet, IPv4 over 802.1Q VLAN", "wmx.reg.encap_ipv4_802_1q",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000080, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv4_802_3_4,\r\n{\r\n"Packet, IPv4 over 802.3/Ethernet", "wmx.reg.encap_ipv4_802_3",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000020, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv6_4,\r\n{\r\n"Packet, IPv6", "wmx.reg.encap_ipv6",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000004, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv6_802_1q_4,\r\n{\r\n"Packet, IPv6 over 802.1Q VLAN", "wmx.reg.encap_ipv6_802_1q",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000100, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_ipv6_802_3_4,\r\n{\r\n"Packet, IPv6 over 802.3/Ethernet", "wmx.reg.encap_ipv6_802_3",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000040, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_packet_8023_ethernet_and_ecrtp_header_compression_4,\r\n{\r\n"Packet, 802.3/Ethernet (with optional 802.1Q VLAN tags) and ECRTP header compression", "wmx.reg.encap_packet_802_3_ethernet_and_ecrtp_header_compression",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000400, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_packet_8023_ethernet_and_rohc_header_compression_4,\r\n{\r\n"Packet, 802.3/Ethernet (with optional 802.1Q VLAN tags) and ROHC header compression", "wmx.reg.encap_packet_802_3_ethernet_and_rohc_header_compression",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000200, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_packet_ip_ecrtp_header_compression_4,\r\n{\r\n"Packet, IP (v4 or v6) with ECRTP header compression", "wmx.reg.encap_packet_ip_ecrtp_header_compression",\r\nFT_UINT32, BASE_HEX, NULL, 0x00001000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_packet_ip_rohc_header_compression_4,\r\n{\r\n"Packet, IP (v4 or v6) with ROHC header compression", "wmx.reg.encap_packet_ip_rohc_header_compression",\r\nFT_UINT32, BASE_HEX, NULL, 0x00000800, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_encap_rsvd_4,\r\n{\r\n"Reserved", "wmx.reg.encap_rsvd",\r\nFT_UINT32, BASE_HEX, NULL, 0xFFFFE000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_22_mac_extended_rtps_support,\r\n{\r\n"MAC extended rtPS support", "wmx.reg.ext_rtps_support",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x01, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_27_handover_fbss_mdho_dl_rf_monitoring_maps,\r\n{\r\n"FBSS/MDHO DL RF Combining with monitoring MAPs from active BSs", "wmx.reg.fbss_mdho_dl_rf_combining",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x02, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_bandwidth_request_ul_tx_power_report_header_support,\r\n{\r\n"Bandwidth request and UL Tx Power Report header support",\r\n"wimax.reg.bandwidth_request_ul_tx_pwr_report_header_support",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x1, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_27_handover_fbss_mdho_ho_disable,\r\n{\r\n"MDHO/FBSS HO. BS ignore all other bits when set to 1", "wmx.reg.fbss_mdho_ho_disable",\r\nFT_BOOLEAN, 8, TFS(&tfs_reg_fbss_mdho_ho_disable), 0x01, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_feedback_header_support,\r\n{\r\n"Feedback header support", "wmx.reg.feedback_header_support",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x40, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_feedback_request_extended_subheader,\r\n{\r\n"Feedback request extended subheader", "wmx.reg.feedback_request_extended_subheader",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x1000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_46_handover_indication_readiness_timer,\r\n{\r\n"Handover indication readiness timer", "wmx.reg.handover_indication_readiness_timer",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_27_handover_reserved,\r\n{\r\n"Reserved", "wmx.reg.handover_reserved",\r\nFT_UINT8, BASE_DEC, NULL, 0xE0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_41_ho_connections_param_processing_time,\r\n{\r\n"MS HO connections parameters processing time", "wmx.reg.ho_connections_param_processing_time",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_29_ho_process_opt_ms_timer,\r\n{\r\n"HO Process Optimization MS Timer", "wmx.reg.ho_process_opt_ms_timer",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_42_ho_tek_processing_time,\r\n{\r\n"MS HO TEK processing time", "wmx.reg.ho_tek_processing_time",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_idle_mode_timeout,\r\n{\r\n"Idle Mode Timeout", "wmx.reg.idle_mode_timeout",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_ip_mgmt_mode,\r\n{\r\n"IP management mode", "wmx.reg.ip_mgmt_mode",\r\nFT_BOOLEAN, BASE_NONE, TFS(&tfs_reg_ip_mgmt_mode), 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_ip_version,\r\n{\r\n"IP version", "wmx.reg.ip_version",\r\nFT_UINT8, BASE_HEX, VALS(vals_reg_ip_version), 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_mac_address,\r\n{\r\n"MAC Address of the SS", "wmx.reg.mac_address",\r\nFT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_mac_crc_support,\r\n{\r\n"MAC CRC", "wmx.reg.mac_crc_support",\r\nFT_BOOLEAN, BASE_NONE, TFS(&tfs_mac_crc_support), 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_max_classifiers,\r\n{\r\n"Maximum number of classification rules", "wmx.reg.max_classifiers",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_23_max_num_bursts_concurrently_to_the_ms,\r\n{\r\n"Maximum number of bursts transmitted concurrently to the MS", "wmx.reg.max_num_bursts_to_ms",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_mca_flow_control,\r\n{\r\n"MCA flow control", "wmx.reg.mca_flow_control",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_mcast_polling_cids,\r\n{\r\n"Multicast polling group CID support", "wmx.reg.mcast_polling_cids",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_27_handover_mdho_ul_multiple,\r\n{\r\n"MDHO UL Multiple transmission", "wmx.reg.mdh_ul_multiple",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x10, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_27_handover_mdho_dl_monitoring_maps,\r\n{\r\n"MDHO DL soft combining with monitoring MAPs from active BSs", "wmx.reg.mdho_dl_monitor_maps",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x08, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_27_handover_mdho_dl_monitoring_single_map,\r\n{\r\n"MDHO DL soft Combining with monitoring single MAP from anchor BS", "wmx.reg.mdho_dl_monitor_single_map",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x04, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_mimo_mode_feedback_extended_subheader,\r\n{\r\n"MIMO mode feedback request extended subheader", "wmx.reg.mimo_mode_feedback_request_extended_subheader",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x2000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_mini_feedback_extended_subheader,\r\n{\r\n"Mini-feedback extended subheader", "wmx.reg.mini_feedback_extended_subheader",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x8000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_31_mobility_handover,\r\n{\r\n"Mobility (handover)", "wmx.reg.mobility_handover",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x01, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_31_mobility_idle_mode,\r\n{\r\n"Idle mode", "wmx.reg.mobility_idle_mode",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x04, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_31_mobility_sleep_mode,\r\n{\r\n"Sleep mode", "wmx.reg.mobility_sleep_mode",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x02, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_num_dl_trans_cid,\r\n{\r\n"Number of Downlink transport CIDs the SS can support", "wmx.reg.dl_cids_supported",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_21_packing_support,\r\n{\r\n"Packing support", "wmx.reg.packing.support",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x01, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_pdu_sn_long_extended_subheader,\r\n{\r\n"PDU SN (long) extended subheader", "wmx.reg.pdu_sn_long_extended_subheader",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x40000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_pdu_sn_short_extended_subheader,\r\n{\r\n"PDU SN (short) extended subheader", "wmx.reg.pdu_sn_short_extended_subheader",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x20000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_phs,\r\n{\r\n"PHS support", "wmx.reg.phs",\r\nFT_UINT8, BASE_DEC, VALS(vals_reg_phs_support), 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_phy_channel_report_header_support,\r\n{\r\n"PHY channel report header support", "wmx.reg.phy_channel_report_header_support",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x8, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_reserved,\r\n{\r\n"Reserved", "wmx.reg.reserved",\r\nFT_UINT24, BASE_DEC, NULL, 0xf80000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_sdu_sn_extended_subheader_support_and_parameter,\r\n{\r\n"SDU_SN extended subheader support", "wmx.reg.sdu_sn_extended_subheader_support",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x80, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_sdu_sn_parameter,\r\n{\r\n"SDU_SN parameter", "wmx.reg.sdu_sn_parameter",\r\nFT_UINT24, BASE_DEC, NULL, 0x700, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_sn_report_header_support,\r\n{\r\n"SN report header support", "wmx.reg.sn_report_header_support",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x20, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_sn_request_extended_subheader,\r\n{\r\n"SN request extended subheader", "wmx.reg.sn_request_extended_subheader",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x10000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_ss_mgmt_support,\r\n{\r\n"SS management support", "wmx.reg.ss_mgmt_support",\r\nFT_BOOLEAN, BASE_NONE, TFS(&tfs_reg_ss_mgmt_support), 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_ul_cids,\r\n{\r\n"Number of Uplink transport CIDs the SS can support", "wmx.reg.ul_cids_supported",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_ul_tx_power_report_extended_subheader,\r\n{\r\n"UL Tx power report extended subheader", "wmx.reg.ul_tx_power_report_extended_subheader",\r\nFT_UINT24, BASE_DEC, VALS(tfs_support), 0x4000, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_tlv_type,\r\n{\r\n"Unknown TLV Type", "wmx.reg.unknown_tlv_type",\r\nFT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_invalid_tlv,\r\n{\r\n"Invalid TLV", "wmx.reg_req.invalid_tlv",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_20_1_max_mac_level_data_per_dl_frame,\r\n{\r\n"Maximum MAC level DL data per frame", "wmx.reg_req.max_mac_dl_data",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_20_2_max_mac_level_data_per_ul_frame,\r\n{\r\n"Maximum MAC level UL data per frame", "wmx.reg_req.max_mac_ul_data",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_req_min_time_for_inter_fa,\r\n{\r\n"Minimum time for inter-FA HO, default=3", "wmx.reg_req.min_time_for_inter_fa",\r\nFT_UINT8, BASE_HEX, NULL, 0xF0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_req_min_time_for_intra_fa,\r\n{\r\n"Minimum time for intra-FA HO, default=2", "wmx.reg_req.min_time_for_intra_fa",\r\nFT_UINT8, BASE_HEX, NULL, 0x0F, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_req_tlv_t_45_ms_periodic_ranging_timer,\r\n{\r\n"MS periodic ranging timer information", "wmx.reg_req.ms_periodic_ranging_timer_info",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_ms_previous_ip_address_v4,\r\n{\r\n"MS Previous IP address", "wmx.reg_req.ms_prev_ip_addr_v4",\r\nFT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_ms_previous_ip_address_v6,\r\n{\r\n"MS Previous IP address", "wmx.reg_req.ms_prev_ip_addr_v6",\r\nFT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_req_secondary_mgmt_cid,\r\n{\r\n"Secondary Management CID", "wmx.reg_req.secondary_mgmt_cid",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_req_tlv_t_32_sleep_mode_recovery_time,\r\n{\r\n"Frames required for the MS to switch from sleep to awake-mode", "wmx.reg_req.sleep_recovery",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_power_saving_class_type_i,\r\n{\r\n"Power saving class type I supported", "wmx.reg.power_saving_class_type_i",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x01, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_power_saving_class_type_ii,\r\n{\r\n"Power saving class type II supported", "wmx.reg.power_saving_class_type_ii",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x02, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_power_saving_class_type_iii,\r\n{\r\n"Power saving class type III supported", "wmx.reg.power_saving_class_type_iii",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x04, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_multi_active_power_saving_classes,\r\n{\r\n"Multiple active power saving classes supported", "wmx.reg.multi_active_power_saving_classes",\r\nFT_BOOLEAN, 8, TFS(&tfs_supported), 0x08, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_total_power_saving_class_instances,\r\n{\r\n"Total number of power saving class instances of all", "wmx.reg_req.total_power_saving_class_instances",\r\nFT_UINT16, BASE_DEC, NULL, 0x1F0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_power_saving_class_reserved,\r\n{\r\n"Reserved", "wmx.reg.reserved",\r\nFT_UINT16, BASE_DEC, NULL, 0xFE00, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_power_saving_class_capability,\r\n{\r\n"Power saving class capability", "wmx.reg.power_saving_class_capability",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_ip_phs_sdu_encap,\r\n{\r\n"Classification/PHS options and SDU encapsulation support", "wmx.reg.ip_phs_sdu_encap",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_26_method_alloc_ip_addr_secondary_mgmnt_conn,\r\n{\r\n"Method for allocating IP address for the secondary management connection", "wmx.reg.method_alloc_ip_addr_secondary_mgmnt_conn",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_27_handover_supported,\r\n{\r\n"Handover Support", "wmx.reg.handover_supported",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_31_mobility_features_supported,\r\n{\r\n"Mobility Features Supported", "wmx.reg.mobility_features_supported",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_40_arq_ack_type,\r\n{\r\n"ARQ ACK Type", "wmx.reg.arq_ack_type",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_tlv_t_43_mac_header_ext_header_support,\r\n{\r\n"MAC header and extended subheader support", "wmx.reg.mac_header_ext_header_support",\r\nFT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{\r\n&hf_reg_req_bs_switching_timer,\r\n{\r\n"BS switching timer", "wmx.reg.bs_switching_timer",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n};\r\nstatic gint *ett[] =\r\n{\r\n&ett_mac_mgmt_msg_reg_req_decoder\r\n};\r\nproto_mac_mgmt_msg_reg_req_decoder = proto_register_protocol (\r\n"WiMax REG-REQ Messages",\r\n"WiMax REG-REQ",\r\n"wmx.reg_req"\r\n);\r\nproto_register_field_array(proto_mac_mgmt_msg_reg_req_decoder, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid proto_reg_handoff_mac_mgmt_msg_reg_req(void)\r\n{\r\ndissector_handle_t reg_req_handle;\r\nreg_req_handle = create_dissector_handle(dissect_mac_mgmt_msg_reg_req_decoder, proto_mac_mgmt_msg_reg_req_decoder);\r\ndissector_add_uint("wmx.mgmtmsg", MAC_MGMT_MSG_REG_REQ, reg_req_handle);\r\n}
