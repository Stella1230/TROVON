static gchar get_priority(const guint8 priority) {\r\nstatic gchar priorities[] = "??VDIWEFS";\r\nif (priority >= (guint8) sizeof(priorities))\r\nreturn '?';\r\nreturn priorities[priority];\r\n}\r\nstatic gint buffered_detect_version(const guint8 *pd)\r\n{\r\nconst struct logger_entry *log_entry;\r\nconst struct logger_entry_v2 *log_entry_v2;\r\ngint version;\r\nconst guint8 *msg_payload = NULL;\r\nguint8 *msg_part;\r\nguint8 *msg_end;\r\nguint16 msg_len;\r\nlog_entry = (const struct logger_entry *)(const void *) pd;\r\nlog_entry_v2 = (const struct logger_entry_v2 *)(const void *) pd;\r\nif (log_entry->len < 3)\r\nreturn -1;\r\nif (log_entry->len > LOGGER_ENTRY_MAX_PAYLOAD)\r\nreturn -1;\r\nfor (version = 1; version <= 2; ++version) {\r\nif (version == 1) {\r\nmsg_payload = (const guint8 *) (log_entry + 1);\r\n} else if (version == 2) {\r\nmsg_payload = (const guint8 *) (log_entry_v2 + 1);\r\nif (log_entry_v2->hdr_size != sizeof(*log_entry_v2))\r\ncontinue;\r\n}\r\nif (get_priority(msg_payload[0]) == '?')\r\ncontinue;\r\nmsg_part = (guint8 *) memchr(msg_payload, '\0', log_entry->len - 1);\r\nif (msg_part == NULL)\r\ncontinue;\r\n++msg_part;\r\nmsg_len = (guint16)(log_entry->len - (msg_part - msg_payload));\r\nmsg_end = (guint8 *) memchr(msg_part, '\0', msg_len);\r\nif (msg_end && (msg_payload + log_entry->len - 1 != msg_end))\r\ncontinue;\r\nreturn version;\r\n}\r\nreturn -1;\r\n}\r\nstatic gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,\r\ngint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,\r\nconst gchar *log)\r\n{\r\ngchar time_buffer[15];\r\ntime_t datetime;\r\ndatetime = (time_t) seconds;\r\nswitch (dumper->type) {\r\ncase WTAP_ENCAP_LOGCAT_BRIEF:\r\nreturn g_strdup_printf("%c/%-8s(%5i): %s\n",\r\npriority, tag, pid, log);\r\ncase WTAP_ENCAP_LOGCAT_PROCESS:\r\nreturn g_strdup_printf("%c(%5i) %s (%s)\n",\r\npriority, pid, log, "");\r\ncase WTAP_ENCAP_LOGCAT_TAG:\r\nreturn g_strdup_printf("%c/%-8s: %s\n",\r\npriority, tag, log);\r\ncase WTAP_ENCAP_LOGCAT_THREAD:\r\nreturn g_strdup_printf("%c(%5i:%5i) %s\n",\r\npriority, pid, tid, log);\r\ncase WTAP_ENCAP_LOGCAT_TIME:\r\nstrftime(time_buffer, sizeof(time_buffer), "%m-%d %H:%M:%S",\r\ngmtime(&datetime));\r\nreturn g_strdup_printf("%s.%03i %c/%-8s(%5i): %s\n",\r\ntime_buffer, milliseconds, priority, tag, pid, log);\r\ncase WTAP_ENCAP_LOGCAT_THREADTIME:\r\nstrftime(time_buffer, sizeof(time_buffer), "%m-%d %H:%M:%S",\r\ngmtime(&datetime));\r\nreturn g_strdup_printf("%s.%03i %5i %5i %c %-8s: %s\n",\r\ntime_buffer, milliseconds, pid, tid, priority, tag, log);\r\ncase WTAP_ENCAP_LOGCAT_LONG:\r\nstrftime(time_buffer, sizeof(time_buffer), "%m-%d %H:%M:%S",\r\ngmtime(&datetime));\r\nreturn g_strdup_printf("[ %s.%03i %5i:%5i %c/%-8s ]\n%s\n\n",\r\ntime_buffer, milliseconds, pid, tid, priority, tag, log);\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic void get_time(gchar *string, struct wtap_pkthdr *phdr) {\r\ngint ms;\r\nstruct tm date;\r\ntime_t seconds;\r\nif (6 == sscanf(string, "%d-%d %d:%d:%d.%d", &date.tm_mon, &date.tm_mday, &date.tm_hour,\r\n&date.tm_min, &date.tm_sec, &ms)) {\r\ndate.tm_year = 70;\r\ndate.tm_mon -= 1;\r\nseconds = mktime(&date);\r\nphdr->ts.secs = (time_t) seconds;\r\nphdr->ts.nsecs = (int) (ms * 1e6);\r\nphdr->presence_flags = WTAP_HAS_TS;\r\n} else {\r\nphdr->presence_flags = 0;\r\nphdr->ts.secs = (time_t) 0;\r\nphdr->ts.nsecs = (int) 0;\r\n}\r\n}\r\nstatic gboolean logcat_text_read_packet(FILE_T fh, struct wtap_pkthdr *phdr,\r\nBuffer *buf, gint file_type) {\r\ngint8 *pd;\r\ngchar cbuff[WTAP_MAX_PACKET_SIZE];\r\ngchar *ret = NULL;\r\ndo {\r\nret = file_gets(cbuff, WTAP_MAX_PACKET_SIZE, fh);\r\n} while (NULL != ret && 3 > strlen(cbuff) && !file_eof(fh));\r\nif (NULL == ret || 3 > strlen(cbuff)) {\r\nreturn FALSE;\r\n}\r\nif (WTAP_FILE_TYPE_SUBTYPE_LOGCAT_LONG == file_type &&\r\n!g_regex_match_simple(SPECIAL_STRING, cbuff, (GRegexCompileFlags)((gint) G_REGEX_ANCHORED | (gint) G_REGEX_RAW), G_REGEX_MATCH_NOTEMPTY)) {\r\ngint64 file_off = 0;\r\ngchar lbuff[WTAP_MAX_PACKET_SIZE];\r\nint err;\r\ngchar *ret2 = NULL;\r\nfile_off = file_tell(fh);\r\nret2 = file_gets(lbuff,WTAP_MAX_PACKET_SIZE, fh);\r\nwhile (NULL != ret2 && 2 < strlen(lbuff) && !file_eof(fh)) {\r\ng_strlcat(cbuff,lbuff,WTAP_MAX_PACKET_SIZE);\r\nfile_off = file_tell(fh);\r\nret2 = file_gets(lbuff,WTAP_MAX_PACKET_SIZE, fh);\r\n}\r\nif(NULL == ret2 || 2 < strlen(lbuff)) {\r\nreturn FALSE;\r\n}\r\nfile_seek(fh,file_off,SEEK_SET,&err);\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->caplen = (guint32)strlen(cbuff);\r\nphdr->len = phdr->caplen;\r\nws_buffer_assure_space(buf, phdr->caplen + 1);\r\npd = ws_buffer_start_ptr(buf);\r\nif ((WTAP_FILE_TYPE_SUBTYPE_LOGCAT_TIME == file_type\r\n|| WTAP_FILE_TYPE_SUBTYPE_LOGCAT_THREADTIME == file_type\r\n|| WTAP_FILE_TYPE_SUBTYPE_LOGCAT_LONG == file_type)\r\n&& '-' != cbuff[0]) {\r\nif (WTAP_FILE_TYPE_SUBTYPE_LOGCAT_LONG == file_type) {\r\nget_time(cbuff+2, phdr);\r\n} else {\r\nget_time(cbuff, phdr);\r\n}\r\n} else {\r\nphdr->presence_flags = 0;\r\nphdr->ts.secs = (time_t) 0;\r\nphdr->ts.nsecs = (int) 0;\r\n}\r\nmemcpy(pd, cbuff, phdr->caplen + 1);\r\nreturn TRUE;\r\n}\r\nstatic gboolean logcat_text_read(wtap *wth, int *err _U_ , gchar **err_info _U_,\r\ngint64 *data_offset) {\r\n*data_offset = file_tell(wth->fh);\r\nreturn logcat_text_read_packet(wth->fh, &wth->phdr, wth->frame_buffer,\r\nwth->file_type_subtype);\r\n}\r\nstatic gboolean logcat_text_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info _U_) {\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!logcat_text_read_packet(wth->random_fh, phdr, buf,\r\nwth->file_type_subtype)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nwtap_open_return_val logcat_text_open(wtap *wth, int *err, gchar **err_info _U_) {\r\ngchar cbuff[WTAP_MAX_PACKET_SIZE];\r\ngchar *ret = NULL;\r\nif (file_seek(wth->fh, 0, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\ndo {\r\nret = file_gets(cbuff, WTAP_MAX_PACKET_SIZE, wth->fh);\r\n} while (NULL != ret && !file_eof(wth->fh)\r\n&& ((3 > strlen(cbuff))\r\n|| g_regex_match_simple(SPECIAL_STRING, cbuff, (GRegexCompileFlags)((gint) G_REGEX_ANCHORED | (gint) G_REGEX_RAW),\r\nG_REGEX_MATCH_NOTEMPTY)));\r\nif (g_regex_match_simple(BRIEF_STRING, cbuff, (GRegexCompileFlags)((gint) G_REGEX_ANCHORED | (gint) G_REGEX_RAW),\r\nG_REGEX_MATCH_NOTEMPTY)) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT_BRIEF;\r\nwth->file_encap = WTAP_ENCAP_LOGCAT_BRIEF;\r\n} else if (g_regex_match_simple(TAG_STRING, cbuff, (GRegexCompileFlags)((gint) G_REGEX_ANCHORED | (gint) G_REGEX_RAW),\r\nG_REGEX_MATCH_NOTEMPTY)) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT_TAG;\r\nwth->file_encap = WTAP_ENCAP_LOGCAT_TAG;\r\n} else if (g_regex_match_simple(PROCESS_STRING, cbuff, (GRegexCompileFlags)((gint) G_REGEX_ANCHORED | (gint) G_REGEX_RAW),\r\nG_REGEX_MATCH_NOTEMPTY)) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT_PROCESS;\r\nwth->file_encap = WTAP_ENCAP_LOGCAT_PROCESS;\r\n} else if (g_regex_match_simple(TIME_STRING, cbuff, (GRegexCompileFlags)((gint) G_REGEX_ANCHORED | (gint) G_REGEX_RAW),\r\nG_REGEX_MATCH_NOTEMPTY)) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT_TIME;\r\nwth->file_encap = WTAP_ENCAP_LOGCAT_TIME;\r\n} else if (g_regex_match_simple(THREAD_STRING, cbuff, (GRegexCompileFlags)((gint) G_REGEX_ANCHORED | (gint) G_REGEX_RAW),\r\nG_REGEX_MATCH_NOTEMPTY)) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT_THREAD;\r\nwth->file_encap = WTAP_ENCAP_LOGCAT_THREAD;\r\n} else if (g_regex_match_simple(THREADTIME_STRING, cbuff, (GRegexCompileFlags)((gint) G_REGEX_ANCHORED | (gint) G_REGEX_RAW),\r\nG_REGEX_MATCH_NOTEMPTY)) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT_THREADTIME;\r\nwth->file_encap = WTAP_ENCAP_LOGCAT_THREADTIME;\r\n} else if (g_regex_match_simple(LONG_STRING, cbuff, (GRegexCompileFlags)((gint) G_REGEX_ANCHORED | (gint) G_REGEX_RAW),\r\nG_REGEX_MATCH_NOTEMPTY)) {\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT_LONG;\r\nwth->file_encap = WTAP_ENCAP_LOGCAT_LONG;\r\n} else {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (file_seek(wth->fh, 0, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = logcat_text_read;\r\nwth->subtype_seek_read = logcat_text_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nint logcat_text_brief_dump_can_write_encap(int encap) {\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nswitch (encap) {\r\ncase WTAP_ENCAP_LOGCAT:\r\ncase WTAP_ENCAP_LOGCAT_BRIEF:\r\ncase WTAP_ENCAP_WIRESHARK_UPPER_PDU:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\nint logcat_text_process_dump_can_write_encap(int encap) {\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nswitch (encap) {\r\ncase WTAP_ENCAP_LOGCAT:\r\ncase WTAP_ENCAP_LOGCAT_PROCESS:\r\ncase WTAP_ENCAP_WIRESHARK_UPPER_PDU:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\nint logcat_text_tag_dump_can_write_encap(int encap) {\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nswitch (encap) {\r\ncase WTAP_ENCAP_LOGCAT:\r\ncase WTAP_ENCAP_LOGCAT_TAG:\r\ncase WTAP_ENCAP_WIRESHARK_UPPER_PDU:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\nint logcat_text_time_dump_can_write_encap(int encap) {\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nswitch (encap) {\r\ncase WTAP_ENCAP_LOGCAT:\r\ncase WTAP_ENCAP_LOGCAT_TIME:\r\ncase WTAP_ENCAP_WIRESHARK_UPPER_PDU:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\nint logcat_text_thread_dump_can_write_encap(int encap) {\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nswitch (encap) {\r\ncase WTAP_ENCAP_LOGCAT:\r\ncase WTAP_ENCAP_LOGCAT_THREAD:\r\ncase WTAP_ENCAP_WIRESHARK_UPPER_PDU:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\nint logcat_text_threadtime_dump_can_write_encap(int encap) {\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nswitch (encap) {\r\ncase WTAP_ENCAP_LOGCAT:\r\ncase WTAP_ENCAP_LOGCAT_THREADTIME:\r\ncase WTAP_ENCAP_WIRESHARK_UPPER_PDU:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\nint logcat_text_long_dump_can_write_encap(int encap) {\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nswitch (encap) {\r\ncase WTAP_ENCAP_LOGCAT:\r\ncase WTAP_ENCAP_LOGCAT_LONG:\r\ncase WTAP_ENCAP_WIRESHARK_UPPER_PDU:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\nstatic gboolean logcat_text_dump_text(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info)\r\n{\r\ngchar *buf;\r\ngint length;\r\ngchar priority;\r\nconst struct logger_entry *log_entry;\r\nconst struct logger_entry_v2 *log_entry_v2;\r\ngint payload_length;\r\nconst gchar *tag;\r\ngint32 pid;\r\ngint32 tid;\r\ngint32 seconds;\r\ngint32 milliseconds;\r\nconst guint8 *msg_payload = NULL;\r\nconst gchar *msg_begin;\r\ngint msg_pre_skip;\r\ngchar *log;\r\ngchar *log_part;\r\ngchar *log_next;\r\ngint logcat_version;\r\nconst struct dumper_t *dumper = (const struct dumper_t *) wdh->priv;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nswitch (wdh->encap) {\r\ncase WTAP_ENCAP_WIRESHARK_UPPER_PDU:\r\n{\r\ngint skipped_length;\r\nskipped_length = logcat_exported_pdu_length(pd);\r\npd += skipped_length;\r\nif (!wtap_dump_file_write(wdh, (const gchar*) pd, phdr->caplen - skipped_length, err)) {\r\nreturn FALSE;\r\n}\r\n}\r\nbreak;\r\ncase WTAP_ENCAP_LOGCAT:\r\nif (wdh->encap == WTAP_ENCAP_WIRESHARK_UPPER_PDU) {\r\ngint skipped_length;\r\nskipped_length = logcat_exported_pdu_length(pd);\r\npd += skipped_length;\r\nlogcat_version = buffered_detect_version(pd);\r\n} else {\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nlogcat_version = pseudo_header->logcat.version;\r\n}\r\nlog_entry = (const struct logger_entry *)(const void *) pd;\r\nlog_entry_v2 = (const struct logger_entry_v2 *)(const void *) pd;\r\npayload_length = GINT32_FROM_LE(log_entry->len);\r\npid = GINT32_FROM_LE(log_entry->pid);\r\ntid = GINT32_FROM_LE(log_entry->tid);\r\nseconds = GINT32_FROM_LE(log_entry->sec);\r\nmilliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;\r\nif (logcat_version == 1) {\r\nmsg_payload = (const guint8 *) (log_entry + 1);\r\npriority = get_priority(msg_payload[0]);\r\ntag = msg_payload + 1;\r\nmsg_pre_skip = 1 + (gint) strlen(tag) + 1;\r\nmsg_begin = msg_payload + msg_pre_skip;\r\n} else if (logcat_version == 2) {\r\nmsg_payload = (const guint8 *) (log_entry_v2 + 1);\r\npriority = get_priority(msg_payload[0]);\r\ntag = msg_payload + 1;\r\nmsg_pre_skip = 1 + (gint) strlen(tag) + 1;\r\nmsg_begin = msg_payload + msg_pre_skip;\r\n} else {\r\n*err = WTAP_ERR_UNWRITABLE_REC_DATA;\r\n*err_info = g_strdup_printf("logcat: version %d isn't supported",\r\nlogcat_version);\r\nreturn FALSE;\r\n}\r\nlog = g_strndup(msg_begin, payload_length - msg_pre_skip);\r\nlog_next = log;\r\ndo {\r\nlog_part = log_next;\r\nif (dumper->type == WTAP_ENCAP_LOGCAT_LONG) {\r\nlog_next = NULL;\r\n} else {\r\nlog_next = strchr(log_part, '\n');\r\nif (log_next != NULL) {\r\n*log_next = '\0';\r\n++log_next;\r\nif (*log_next == '\0') {\r\nlog_next = NULL;\r\n}\r\n}\r\n}\r\nbuf = logcat_log(dumper, seconds, milliseconds, pid, tid, priority, tag, log_part);\r\nif (!buf) {\r\ng_free(log);\r\nreturn FALSE;\r\n}\r\nlength = (guint32) strlen(buf);\r\nif (!wtap_dump_file_write(wdh, buf, length, err)) {\r\ng_free(log);\r\nreturn FALSE;\r\n}\r\nwdh->bytes_dumped += length;\r\n} while (log_next != NULL );\r\ng_free(log);\r\nbreak;\r\ncase WTAP_ENCAP_LOGCAT_BRIEF:\r\ncase WTAP_ENCAP_LOGCAT_TAG:\r\ncase WTAP_ENCAP_LOGCAT_PROCESS:\r\ncase WTAP_ENCAP_LOGCAT_TIME:\r\ncase WTAP_ENCAP_LOGCAT_THREAD:\r\ncase WTAP_ENCAP_LOGCAT_THREADTIME:\r\ncase WTAP_ENCAP_LOGCAT_LONG:\r\nif (dumper->type == wdh->encap) {\r\nif (!wtap_dump_file_write(wdh, (const gchar*) pd, phdr->caplen, err)) {\r\nreturn FALSE;\r\n}\r\n} else {\r\n*err = WTAP_ERR_UNWRITABLE_FILE_TYPE;\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean logcat_text_dump_open(wtap_dumper *wdh, guint dump_type, int *err _U_) {\r\nstruct dumper_t *dumper;\r\ndumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));\r\ndumper->type = dump_type;\r\nwdh->priv = dumper;\r\nwdh->subtype_write = logcat_text_dump_text;\r\nreturn TRUE;\r\n}\r\ngboolean logcat_text_brief_dump_open(wtap_dumper *wdh, int *err) {\r\nreturn logcat_text_dump_open(wdh, WTAP_ENCAP_LOGCAT_BRIEF, err);\r\n}\r\ngboolean logcat_text_process_dump_open(wtap_dumper *wdh, int *err) {\r\nreturn logcat_text_dump_open(wdh, WTAP_ENCAP_LOGCAT_PROCESS, err);\r\n}\r\ngboolean logcat_text_tag_dump_open(wtap_dumper *wdh, int *err) {\r\nreturn logcat_text_dump_open(wdh, WTAP_ENCAP_LOGCAT_TAG, err);\r\n}\r\ngboolean logcat_text_time_dump_open(wtap_dumper *wdh, int *err) {\r\nreturn logcat_text_dump_open(wdh, WTAP_ENCAP_LOGCAT_TIME, err);\r\n}\r\ngboolean logcat_text_thread_dump_open(wtap_dumper *wdh, int *err) {\r\nreturn logcat_text_dump_open(wdh, WTAP_ENCAP_LOGCAT_THREAD, err);\r\n}\r\ngboolean logcat_text_threadtime_dump_open(wtap_dumper *wdh, int *err) {\r\nreturn logcat_text_dump_open(wdh, WTAP_ENCAP_LOGCAT_THREADTIME, err);\r\n}\r\ngboolean logcat_text_long_dump_open(wtap_dumper *wdh, int *err) {\r\nreturn logcat_text_dump_open(wdh, WTAP_ENCAP_LOGCAT_LONG, err);\r\n}
