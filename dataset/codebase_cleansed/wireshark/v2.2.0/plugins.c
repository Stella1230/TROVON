void\r\nadd_plugin_type(const char *type, plugin_callback callback)\r\n{\r\nplugin_type *new_type;\r\nstatic guint type_val;\r\nif (type_val >= 32) {\r\nreport_failure("At most 32 plugin types can be supported, so the plugin type '%s' won't be supported.",\r\ntype);\r\nreturn;\r\n}\r\nnew_type = (plugin_type *)g_malloc(sizeof (plugin_type));\r\nnew_type->type = type;\r\nnew_type->callback = callback;\r\nnew_type->type_val = type_val;\r\nplugin_types = g_slist_append(plugin_types, new_type);\r\ntype_val++;\r\n}\r\nstatic int\r\nadd_plugin(plugin *new_plug)\r\n{\r\nplugin *pt_plug;\r\npt_plug = plugin_list;\r\nif (!pt_plug)\r\n{\r\nplugin_list = new_plug;\r\n}\r\nelse\r\n{\r\nwhile (1)\r\n{\r\nif (strcmp(pt_plug->name, new_plug->name) == 0 &&\r\nstrcmp(pt_plug->version, new_plug->version) == 0)\r\n{\r\nreturn EEXIST;\r\n}\r\nif (pt_plug->next == NULL)\r\nbreak;\r\npt_plug = pt_plug->next;\r\n}\r\npt_plug->next = new_plug;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncall_plugin_callback(gpointer data, gpointer user_data)\r\n{\r\nplugin_type *type = (plugin_type *)data;\r\nplugin *new_plug = (plugin *)user_data;\r\nif ((*type->callback)(new_plug->handle)) {\r\nnew_plug->types |= 1 << type->type_val;\r\n}\r\n}\r\nstatic void\r\nplugins_scan_dir(const char *dirname)\r\n{\r\n#define FILENAME_LEN 1024\r\nWS_DIR *dir;\r\nWS_DIRENT *file;\r\nconst char *name;\r\ngchar filename[FILENAME_LEN];\r\nGModule *handle;\r\ngpointer gp;\r\nplugin *new_plug;\r\ngchar *dot;\r\nint cr;\r\nif ((dir = ws_dir_open(dirname, 0, NULL)) != NULL)\r\n{\r\nwhile ((file = ws_dir_read_name(dir)) != NULL)\r\n{\r\nname = ws_dir_get_name(file);\r\ndot = strrchr(name, '.');\r\nif (dot == NULL || strcmp(dot+1, G_MODULE_SUFFIX) != 0)\r\ncontinue;\r\ng_snprintf(filename, FILENAME_LEN, "%s" G_DIR_SEPARATOR_S "%s",\r\ndirname, name);\r\nif ((handle = g_module_open(filename, G_MODULE_BIND_LOCAL)) == NULL)\r\n{\r\nreport_failure("Couldn't load module %s: %s", filename,\r\ng_module_error());\r\ncontinue;\r\n}\r\nif (!g_module_symbol(handle, "version", &gp))\r\n{\r\nreport_failure("The plugin %s has no version symbol", name);\r\ng_module_close(handle);\r\ncontinue;\r\n}\r\nnew_plug = (plugin *)g_malloc(sizeof(plugin));\r\nnew_plug->handle = handle;\r\nnew_plug->name = g_strdup(name);\r\nnew_plug->version = (char *)gp;\r\nnew_plug->types = 0;\r\nnew_plug->next = NULL;\r\ng_slist_foreach(plugin_types, call_plugin_callback, new_plug);\r\nif (new_plug->types == 0)\r\n{\r\nreport_failure("The plugin '%s' has no registration routines",\r\nname);\r\ng_module_close(handle);\r\ng_free(new_plug->name);\r\ng_free(new_plug);\r\ncontinue;\r\n}\r\ncr = add_plugin(new_plug);\r\nif (cr != 0)\r\n{\r\ng_assert(cr == EEXIST);\r\nfprintf(stderr, "The plugin '%s' version %s "\r\n"was found in multiple directories.\n",\r\nnew_plug->name, new_plug->version);\r\ng_module_close(handle);\r\ng_free(new_plug->name);\r\ng_free(new_plug);\r\ncontinue;\r\n}\r\n}\r\nws_dir_close(dir);\r\n}\r\n}\r\nvoid\r\nscan_plugins(void)\r\n{\r\nconst char *plugin_dir;\r\nconst char *name;\r\nchar *plugin_dir_path;\r\nchar *plugins_pers_dir;\r\nWS_DIR *dir;\r\nWS_DIRENT *file;\r\nif (plugin_list == NULL)\r\n{\r\nplugin_dir = get_plugin_dir();\r\nif (running_in_build_directory())\r\n{\r\nif ((dir = ws_dir_open(plugin_dir, 0, NULL)) != NULL)\r\n{\r\nplugins_scan_dir(plugin_dir);\r\nwhile ((file = ws_dir_read_name(dir)) != NULL)\r\n{\r\nname = ws_dir_get_name(file);\r\nif (strcmp(name, ".") == 0 || strcmp(name, "..") == 0)\r\ncontinue;\r\nplugin_dir_path = g_strdup_printf(\r\n"%s" G_DIR_SEPARATOR_S "%s" G_DIR_SEPARATOR_S ".libs",\r\nplugin_dir, name);\r\nif (test_for_directory(plugin_dir_path) != EISDIR) {\r\ng_free(plugin_dir_path);\r\nplugin_dir_path = g_strdup_printf("%s" G_DIR_SEPARATOR_S "%s",\r\nplugin_dir, name);\r\n}\r\nplugins_scan_dir(plugin_dir_path);\r\ng_free(plugin_dir_path);\r\n}\r\nws_dir_close(dir);\r\n}\r\n}\r\nelse\r\nplugins_scan_dir(plugin_dir);\r\nif (!started_with_special_privs())\r\n{\r\nplugins_pers_dir = get_plugins_pers_dir();\r\nplugins_scan_dir(plugins_pers_dir);\r\ng_free(plugins_pers_dir);\r\n}\r\n}\r\n}\r\nstatic void\r\nadd_plugin_type_description(gpointer data, gpointer user_data)\r\n{\r\nplugin_type *type = (plugin_type *)data;\r\ntype_callback_info *info = (type_callback_info *)user_data;\r\nif (info->pt_plug->types & (1 << type->type_val)) {\r\ng_string_append_printf(info->types, "%s%s", info->sep, type->type);\r\ninfo->sep = ", ";\r\n}\r\n}\r\nWS_DLL_PUBLIC void\r\nplugins_get_descriptions(plugin_description_callback callback, void *user_data)\r\n{\r\ntype_callback_info info;\r\ninfo.types = NULL;\r\nfor (info.pt_plug = plugin_list; info.pt_plug != NULL;\r\ninfo.pt_plug = info.pt_plug->next)\r\n{\r\ninfo.sep = "";\r\ninfo.types = g_string_new("");\r\ng_slist_foreach(plugin_types, add_plugin_type_description, &info);\r\ncallback(info.pt_plug->name, info.pt_plug->version, info.types->str,\r\ng_module_name(info.pt_plug->handle), user_data);\r\ng_string_free(info.types, TRUE);\r\n}\r\n}\r\nstatic void\r\nprint_plugin_description(const char *name, const char *version,\r\nconst char *description, const char *filename,\r\nvoid *user_data _U_)\r\n{\r\nprintf("%s\t%s\t%s\t%s\n", name, version, description, filename);\r\n}\r\nvoid\r\nplugins_dump_all(void)\r\n{\r\nplugins_get_descriptions(print_plugin_description, NULL);\r\n}
