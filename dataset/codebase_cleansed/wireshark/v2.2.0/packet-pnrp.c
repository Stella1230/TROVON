static int dissect_pnrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ngint offset;\r\ngint padding_bytes;\r\nguint8 message_type;\r\nguint16 field_type;\r\nguint16 data_length;\r\nproto_item *ti;\r\nproto_tree *pnrp_tree;\r\nproto_item *pnrp_header_item;\r\nproto_tree *pnrp_header_tree;\r\nproto_item *pnrp_message_tree = NULL;\r\nguint32 msg_id;\r\ndata_length = tvb_captured_length(tvb);\r\nif (data_length < 12+8 )\r\n{\r\nreturn 0;\r\n}\r\nif (tvb_get_ntohs(tvb,0) != PNRP_HEADER )\r\n{\r\nreturn 0;\r\n}\r\nif (tvb_get_ntohs(tvb,2) != 0x000C) {\r\nreturn 0;\r\n}\r\nif (tvb_get_guint8(tvb,4) != 0x51) {\r\nreturn 0;\r\n}\r\noffset= 0;\r\nmessage_type = tvb_get_guint8(tvb,7);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PNRP");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "PNRP %s Message ",\r\nval_to_str(message_type, messageType, "Unknown (0x%02x)"));\r\nti = proto_tree_add_item(tree, proto_pnrp, tvb, 0, -1, ENC_NA);\r\nproto_item_append_text(ti, ", Message Type %s",\r\nval_to_str(message_type, messageType, "Unknown (0x%02x)"));\r\npnrp_tree = proto_item_add_subtree(ti, ett_pnrp);\r\npnrp_header_item = proto_tree_add_item(pnrp_tree, hf_pnrp_header, tvb, offset,12,ENC_NA);\r\npnrp_header_tree = proto_item_add_subtree(pnrp_header_item, ett_pnrp_header);\r\nproto_tree_add_item(pnrp_header_tree,hf_pnrp_header_fieldID,tvb,offset,2,ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pnrp_header_tree,hf_pnrp_header_length,tvb,offset,2,ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pnrp_header_tree,hf_pnrp_header_ident,tvb,offset,1,ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(pnrp_header_tree,hf_pnrp_header_versionMajor,tvb,offset,1,ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(pnrp_header_tree,hf_pnrp_header_versionMinor,tvb,offset,1,ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(pnrp_header_tree,hf_pnrp_header_messageType,tvb,offset,1,ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item_ret_uint(pnrp_header_tree,hf_pnrp_header_messageID,tvb,offset,4,ENC_BIG_ENDIAN,&msg_id);\r\noffset += 4;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nfield_type = tvb_get_ntohs(tvb,offset );\r\ndata_length = tvb_get_ntohs(tvb,offset + 2);\r\nif (data_length < 4) {\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree_format(pnrp_tree, tvb, offset, 4, ett_pnrp_message, NULL,\r\n"Message with invalid length %u (< 4)", data_length);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\n}\r\noffset += 4;\r\nbreak;\r\n}\r\nswitch (field_type) {\r\ncase PNRP_HEADER_ACKED:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Message ACK ID: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_headerack, tvb, offset + 4, data_length -4, ENC_BIG_ENDIAN);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase VALIDATE_PNRP_ID:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Validate PNRP ID: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\ndissect_pnrp_ids(tvb,offset+4,data_length-4,pnrp_message_tree);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase FLAGS_FIELD:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Flags Field: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\n}\r\nswitch (message_type) {\r\ncase INQUIRE:\r\nproto_tree_add_bitmask(pnrp_message_tree, tvb, offset+4, hf_pnrp_message_inquire_flags, ett_pnrp_message_inquire_flags, inquire_flags, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + 6, 2, ENC_NA);\r\noffset += data_length+2;\r\nbreak;\r\ncase ACK:\r\nproto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_ack_flags_reserved, tvb, (offset + 4)*8, 15, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_ack_flags_Nbit, tvb,((offset + 4)*8)+15, 1, ENC_BIG_ENDIAN);\r\noffset += data_length;\r\nbreak;\r\ncase AUTHORITY:\r\nproto_tree_add_bitmask(pnrp_message_tree, tvb, offset+4, hf_pnrp_message_authority_flags, ett_pnrp_message_authority_flags, authority_flags, ENC_BIG_ENDIAN);\r\nif(tvb_reported_length_remaining(tvb, offset+data_length)==0)\r\n{\r\noffset += data_length;\r\n}\r\nelse {\r\npadding_bytes = 2;\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + 6, padding_bytes, ENC_NA);\r\noffset += data_length+2;\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_flags, tvb, offset + 4, data_length -4, ENC_BIG_ENDIAN);\r\noffset += data_length;\r\nbreak;\r\n}\r\nbreak;\r\ncase FLOOD_CONTROLS:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Flood Control: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_flood_flags_reserved1, tvb, (offset + 4)*8, 15, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(pnrp_message_tree, hf_pnrp_message_flood_flags_Dbit, tvb,((offset + 4)*8)+15, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved8, tvb, offset + 6, 1, ENC_NA);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + 7, 1, ENC_NA);\r\n}\r\noffset += data_length+1;\r\nbreak;\r\ncase SOLICIT_CONTROLS:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Solicit Controls: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved8, tvb, offset + 4, 1, ENC_NA);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_solicitType, tvb, offset + 5, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved16, tvb, offset + 6, 2, ENC_LITTLE_ENDIAN);\r\n}\r\noffset += data_length +2;\r\nbreak;\r\ncase LOOKUP_CONTROLS:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Lookup Control: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(pnrp_message_tree, tvb, offset+4, hf_pnrp_message_lookupControls_flags, ett_pnrp_message_lookupControls_flags, lookupControls_flags, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_lookupControls_precision, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_lookupControls_resolveCriteria, tvb, offset + 8, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_lookupControls_reasonCode, tvb, offset + 9, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_reserved16, tvb, offset + 10, 2, ENC_LITTLE_ENDIAN);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase TARGET_PNRP_ID:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Target PNRP ID: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\ndissect_pnrp_ids(tvb, offset+4, data_length-4, pnrp_message_tree);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase EXTENDED_PAYLOAD:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Extended Payload: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase PNRP_ID_ARRAY:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "PNRP ID Array: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_idArray_NumEntries, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_idArray_Length, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ElementFieldType, tvb, offset + 8, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_idarray_Entrylength, tvb, offset + 10, 2, ENC_BIG_ENDIAN);\r\ndissect_pnrp_ids(tvb,offset+12,data_length-12,pnrp_message_tree);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase CERT_CHAIN:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "CERT Chain: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_certChain, tvb, offset + 4, data_length-4, ENC_NA);\r\n}\r\npadding_bytes = 0;\r\nwhile (data_length%4 != 0 &&tvb_reported_length_remaining(tvb, offset+data_length)>0) {\r\ndata_length++;\r\npadding_bytes++;\r\n}\r\nif (0<padding_bytes) {\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + data_length-padding_bytes, padding_bytes, ENC_NA);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase CLASSIFIER:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Classifier: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_unicodeCount, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_arrayLength, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset+8 , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_entryLength, tvb, offset + 10, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_classifier_string, tvb, offset + 12, tvb_get_ntohs(tvb,offset+6)-8, ENC_UTF_16|ENC_BIG_ENDIAN);\r\n}\r\npadding_bytes = 0;\r\nwhile (data_length%4 != 0 &&tvb_reported_length_remaining(tvb, offset+data_length)>0) {\r\ndata_length++;\r\npadding_bytes++;\r\n}\r\nif (0<padding_bytes) {\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + data_length-padding_bytes, padding_bytes, ENC_NA);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase HASHED_NONCE:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Hashed Nonce: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_hashednonce, tvb, offset + 4, data_length-4, ENC_NA);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase NONCE:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Nonce: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_nonce, tvb, offset + 4, data_length-4, ENC_NA);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase SPLIT_CONTROLS:\r\n{\r\nfragment_head *frag_data;\r\ntvbuff_t *frag_tvb;\r\nguint32 buffer_len, frag_offset, remaining_len;\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Split controls: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item_ret_uint(pnrp_message_tree, hf_pnrp_message_splitControls_authorityBuffer,\r\ntvb, offset + 4, 2, ENC_BIG_ENDIAN, &buffer_len);\r\nproto_tree_add_item_ret_uint(pnrp_message_tree, hf_pnrp_message_offset,\r\ntvb, offset + 6, 2, ENC_BIG_ENDIAN, &frag_offset);\r\noffset += data_length;\r\nremaining_len = tvb_reported_length_remaining(tvb, offset);\r\nfrag_data = fragment_add_check(&pnrp_reassembly_table, tvb, offset, pinfo,\r\nmsg_id, NULL, frag_offset, remaining_len,\r\n(buffer_len != (frag_offset + remaining_len)));\r\nfrag_tvb = process_reassembled_data(tvb, offset, pinfo, "Reassembled PNRP message",\r\nfrag_data, &pnrp_frag_items, NULL, pnrp_message_tree);\r\nif (frag_tvb) {\r\ntvb = frag_tvb;\r\noffset = 0;\r\n} else {\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_fragmented_payload, tvb, offset, -1, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " [Fragmented message]");\r\nreturn tvb_captured_length(tvb);\r\n}\r\nbreak;\r\n}\r\ncase ROUTING_ENTRY:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Routing Entry: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\ndissect_route_entry(tvb,offset+4, tvb_get_ntohs(tvb,offset+2)-4, pnrp_message_tree);\r\n}\r\npadding_bytes = 0;\r\nwhile (data_length%4 != 0 &&tvb_reported_length_remaining(tvb, offset+data_length)>0) {\r\ndata_length++;\r\npadding_bytes++;\r\n}\r\nif (0<padding_bytes) {\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_padding, tvb, offset + data_length-padding_bytes, padding_bytes, ENC_NA);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase VALIDATE_CPA:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Validate CPA: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\ndissect_encodedCPA_structure(tvb, offset+4, data_length-4, pnrp_message_tree);\r\n}\r\noffset += data_length;\r\nbreak;\r\ncase IPV6_ENDPOINT_ARRAY:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "IPv6 Endpoint Array: ");\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ipv6EndpointArray_NumberOfEntries, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ipv6EndpointArray_ArrayLength, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset+8 , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_ipv6EndpointArray_EntryLength, tvb, offset + 10, 2, ENC_BIG_ENDIAN);\r\ndissect_ipv6_endpoint_structure(tvb, offset+12, tvb_get_ntohs(tvb,offset+6)-8,pnrp_message_tree);\r\n}\r\noffset += data_length;\r\nbreak;\r\ndefault:\r\nif (tree) {\r\npnrp_message_tree = proto_tree_add_subtree_format(pnrp_tree, tvb, offset,\r\ndata_length, ett_pnrp_message, NULL, "Type: %s, length: %u",\r\nval_to_str(field_type, fieldID, "Unknown (0x%04x)"), data_length);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_type, tvb, offset , 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nif(data_length > 4)\r\n{\r\nproto_tree_add_item(pnrp_message_tree, hf_pnrp_message_data, tvb, offset + 4, data_length -4, ENC_NA);\r\n}\r\nelse {\r\nreturn 0;\r\n}\r\n}\r\noffset += data_length;\r\nbreak;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic void dissect_pnrp_ids(tvbuff_t *tvb, gint offset, gint length, proto_tree *tree)\r\n{\r\nwhile (32 <=length) {\r\nproto_tree_add_item(tree, hf_pnrp_message_pnrpID, tvb, offset, 32, ENC_NA);\r\nlength -= 32;\r\noffset += 32;\r\n}\r\n}\r\nstatic void dissect_route_entry(tvbuff_t *tvb, gint offset, gint length, proto_tree *tree)\r\n{\r\ngint tmp_offset;\r\nif (0 <= tvb_reported_length_remaining(tvb, offset+length)) {\r\ntmp_offset = 0;\r\nproto_tree_add_item(tree, hf_pnrp_message_pnrpID, tvb, offset+tmp_offset, 32, ENC_NA);\r\ntmp_offset +=32;\r\nproto_tree_add_item(tree,hf_pnrp_header_versionMajor,tvb,offset+tmp_offset,1,ENC_BIG_ENDIAN);\r\ntmp_offset += 1;\r\nproto_tree_add_item(tree,hf_pnrp_header_versionMinor,tvb,offset+tmp_offset,1,ENC_BIG_ENDIAN);\r\ntmp_offset +=1;\r\nproto_tree_add_item(tree,hf_pnrp_message_routeEntry_portNumber,tvb,offset+tmp_offset,2,ENC_BIG_ENDIAN);\r\ntmp_offset +=2;\r\nproto_tree_add_item(tree,hf_pnrp_message_routeEntry_flags,tvb,offset+tmp_offset,1,ENC_BIG_ENDIAN);\r\ntmp_offset +=1;\r\nproto_tree_add_item(tree,hf_pnrp_message_routeEntry_addressCount,tvb,offset+tmp_offset,1,ENC_BIG_ENDIAN);\r\ntmp_offset +=1;\r\ndissect_ipv6_address(tvb, offset+tmp_offset, length -tmp_offset, tree);\r\n}\r\n}\r\nstatic void dissect_ipv6_endpoint_structure(tvbuff_t *tvb, gint offset, gint length, proto_tree *tree)\r\n{\r\nwhile (0 <= tvb_reported_length_remaining(tvb, offset+18) && 18 <=length) {\r\nproto_tree_add_item(tree, hf_pnrp_message_port_number, tvb, offset, 2, ENC_BIG_ENDIAN);\r\ndissect_ipv6_address(tvb, offset+2,16,tree);\r\noffset += 18;\r\nlength -= 18;\r\n}\r\n}\r\nstatic void dissect_ipv6_address(tvbuff_t *tvb, gint offset, gint length, proto_tree *tree)\r\n{\r\nwhile (0 <= tvb_reported_length_remaining(tvb, offset+16) && 16 <=length) {\r\nproto_tree_add_item(tree, hf_pnrp_message_ipv6, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\nlength -= 16;\r\n}\r\n}\r\nstatic void dissect_encodedCPA_structure(tvbuff_t *tvb, gint offset, gint length, proto_tree *tree)\r\n{\r\nif (0 <= tvb_reported_length_remaining(tvb, offset+length)) {\r\nguint8 flagsField;\r\nproto_item *pnrp_encodedCPA_tree = NULL;\r\nproto_item *pnrp_encodedCPA_item = NULL;\r\npnrp_encodedCPA_item = proto_tree_add_item(tree, hf_pnrp_encodedCPA, tvb, offset,length,ENC_NA);\r\npnrp_encodedCPA_tree = proto_item_add_subtree(pnrp_encodedCPA_item, ett_pnrp_message_encodedCPA);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_minorVersion, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_majorVersion, tvb, offset+3, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_header_versionMinor, tvb, offset+4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_header_versionMajor, tvb, offset+5, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(pnrp_encodedCPA_tree, tvb, offset+6, hf_pnrp_encodedCPA_flags, ett_pnrp_message_encodedCPA_flags, encodedCPA_flags, ENC_BIG_ENDIAN);\r\nflagsField = tvb_get_guint8(tvb,offset+6);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_reserved8, tvb, offset + 7, 1, ENC_NA);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_notAfter, tvb, offset+8, 8, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_serviceLocation, tvb, offset+16, 16, ENC_NA);\r\noffset +=32;\r\nif ((flagsField & FLAGS_ENCODED_CPA_R)==0x00) {\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_message_nonce, tvb, offset, 16, ENC_NA);\r\noffset +=16;\r\n}\r\nif (flagsField & FLAGS_ENCODED_CPA_A) {\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_binaryAuthority, tvb, offset, 20, ENC_NA);\r\noffset +=20;\r\n}\r\nif (flagsField & FLAGS_ENCODED_CPA_C) {\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_classifiertHash, tvb, offset, 20, ENC_NA);\r\noffset +=20;\r\n}\r\nif (flagsField & FLAGS_ENCODED_CPA_F) {\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_friendlyName_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_friendlyName, tvb, offset+2, tvb_get_letohs(tvb,offset), ENC_ASCII|ENC_NA);\r\noffset +=tvb_get_letohs(tvb,offset)+2;\r\n}\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_number_of_service_addresses, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_service_address_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\ndissect_ipv6_endpoint_structure(tvb, offset,tvb_get_letohs(tvb,offset-4)*tvb_get_letohs(tvb,offset-2) , pnrp_encodedCPA_tree);\r\noffset += tvb_get_letohs(tvb,offset-4)*tvb_get_letohs(tvb,offset-2);\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_number_of_payload_structures, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pnrp_encodedCPA_tree, hf_pnrp_encodedCPA_total_bytes_of_payload, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\ndissect_payload_structure(tvb,offset, tvb_get_letohs(tvb,offset-2)-4,pnrp_encodedCPA_tree);\r\noffset += tvb_get_letohs(tvb,offset-2)-4;\r\ndissect_publicKey_structure(tvb, offset,tvb_get_letohs(tvb,offset),pnrp_encodedCPA_tree);\r\noffset += tvb_get_letohs(tvb,offset);\r\ndissect_signature_structure(tvb, offset,tvb_get_letohs(tvb,offset),pnrp_encodedCPA_tree);\r\n}\r\n}\r\nstatic void dissect_payload_structure(tvbuff_t *tvb, gint offset, gint length, proto_tree *tree)\r\n{\r\nguint16 lengthOfData;\r\nproto_item *pnrp_payload_tree;\r\nif (0>=length )\r\nreturn;\r\npnrp_payload_tree = proto_tree_add_subtree(tree, tvb, offset, length, ett_pnrp_message_payloadStructure, NULL, "Payload Structure");\r\nproto_tree_add_item(pnrp_payload_tree, hf_pnrp_payload_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nlengthOfData = tvb_get_letohs(tvb,offset);\r\nproto_tree_add_item(pnrp_payload_tree, hf_pnrp_length_of_data, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nwhile (0 <= tvb_reported_length_remaining(tvb, offset+20)&& 20 <= lengthOfData) {\r\ndissect_ipv6_address(tvb, offset, 16, pnrp_payload_tree);\r\noffset += 16;\r\nproto_tree_add_item(pnrp_payload_tree, hf_pnrp_payload_port, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pnrp_payload_tree, hf_pnrp_payload_iana_proto, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nlengthOfData -=20;\r\n}\r\n}\r\nstatic void dissect_publicKey_structure(tvbuff_t *tvb, gint offset, gint length, proto_tree *tree)\r\n{\r\nguint16 objIDLength;\r\nguint16 cbDataLength;\r\nproto_tree *pnrp_publicKey_tree;\r\nif (0 < length && 0 <= tvb_reported_length_remaining(tvb, offset+length)) {\r\npnrp_publicKey_tree = proto_tree_add_subtree(tree, tvb, offset, length, ett_pnrp_message_publicKeyStructure, NULL, "CPA Public Key Structure");\r\nproto_tree_add_item(pnrp_publicKey_tree, hf_pnrp_publicKey_length_of_structure, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nobjIDLength = tvb_get_letohs(tvb,offset);\r\nproto_tree_add_item(pnrp_publicKey_tree, hf_pnrp_publicKey_size_of_algorithm_oid, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pnrp_publicKey_tree, hf_pnrp_publicKey_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset +=2;\r\ncbDataLength = tvb_get_letohs(tvb,offset);\r\nproto_tree_add_item(pnrp_publicKey_tree, hf_pnrp_publicKey_size_of_cbdata, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pnrp_publicKey_tree, hf_pnrp_publicKey_unused_bits, tvb, offset, 1, ENC_NA);\r\noffset +=1;\r\nproto_tree_add_item(pnrp_publicKey_tree, hf_pnrp_publicKey_objID, tvb, offset, objIDLength, ENC_ASCII|ENC_NA);\r\noffset += objIDLength;\r\nproto_tree_add_item(pnrp_publicKey_tree, hf_pnrp_publicKey_publicKeyData, tvb, offset, cbDataLength, ENC_ASCII|ENC_NA);\r\n}\r\n}\r\nstatic void dissect_signature_structure(tvbuff_t *tvb, gint offset, gint length, proto_tree *tree)\r\n{\r\nguint16 signatureLength;\r\nproto_tree *pnrp_signature_tree;\r\nif (0 < length && 0 <= tvb_reported_length_remaining(tvb, offset+length)) {\r\npnrp_signature_tree = proto_tree_add_subtree(tree, tvb, offset, length, ett_pnrp_message_signatureStructure, NULL, "Signature Structure");\r\nproto_tree_add_item(pnrp_signature_tree, hf_pnrp_signature_structure_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset +=2;\r\nsignatureLength = tvb_get_letohs(tvb,offset);\r\nproto_tree_add_item(pnrp_signature_tree, hf_pnrp_signature_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(pnrp_signature_tree, hf_pnrp_signature_hash_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(pnrp_signature_tree, hf_pnrp_signature_signatureData, tvb, offset, signatureLength, ENC_NA);\r\n}\r\n}\r\nstatic void pnrp_reassembly_init(void)\r\n{\r\nreassembly_table_init(&pnrp_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void pnrp_reassembly_cleanup(void)\r\n{\r\nreassembly_table_destroy(&pnrp_reassembly_table);\r\n}\r\nvoid proto_register_pnrp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pnrp_header,\r\n{ "Header", "pnrp.header", FT_NONE, BASE_NONE, NULL, 0x0,\r\n"PNRP Header", HFILL }},\r\n{ &hf_pnrp_header_fieldID,\r\n{ "Header FieldID", "pnrp.header.fieldID", FT_UINT16, BASE_HEX, VALS(fieldID), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_header_length,\r\n{ "Header length", "pnrp.header.length", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_header_ident,\r\n{ "Ident", "pnrp.ident", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_header_versionMajor,\r\n{ "Version Major", "pnrp.vMajor", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_header_versionMinor,\r\n{ "Version Minor", "pnrp.vMinor", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_header_messageType,\r\n{ "Message Type", "pnrp.messageType", FT_UINT8, BASE_DEC, VALS(messageType), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_header_messageID,\r\n{ "Message ID", "pnrp.header.messageID", FT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_type,\r\n{ "Segment Type", "pnrp.segment.type", FT_UINT16, BASE_HEX, VALS(fieldID), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_length,\r\n{ "Segment length", "pnrp.segment.length", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Message length", HFILL }},\r\n{ &hf_pnrp_message_headerack,\r\n{ "ACKed Header ID", "pnrp.segment.headerAck", FT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_pnrpID,\r\n{ "PNRP ID", "pnrp.segment.pnrpID", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_inquire_flags,\r\n{ "Flags", "pnrp.segment.inquire.flags", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_inquire_flags_reserved1,\r\n{ "Reserved 1", "pnrp.segment.inquire.flags.reserved1", FT_UINT16, BASE_HEX, NULL, FLAGS_INQUIRE_RESERVED1,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_inquire_flags_Abit,\r\n{ "CPA should (a)ppear in response", "pnrp.segment.inquire.flags.Abit", FT_UINT16, BASE_HEX, NULL, FLAGS_INQUIRE_A,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_inquire_flags_Xbit,\r\n{ "E(X)tended Payload sent in Authority response", "pnrp.segment.inquire.flags.Xbit", FT_UINT16, BASE_HEX, NULL, FLAGS_INQUIRE_X,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_inquire_flags_Cbit,\r\n{ "(C)ertificate Chain sent in Authority response", "pnrp.segment.inquire.flags.Cbit", FT_UINT16, BASE_HEX, NULL, FLAGS_INQUIRE_C,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_inquire_flags_reserved2,\r\n{ "Reserved 2", "pnrp.segment.inquire.flags.reserved2", FT_UINT16, BASE_HEX, NULL, FLAGS_INQUIRE_RESERVED2,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_padding,\r\n{ "Padding", "pnrp.padding", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_classifier_unicodeCount,\r\n{ "Number of Unicode Characters", "pnrp.segment.classifier.unicodeCount", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_classifier_arrayLength,\r\n{ "Array Length", "pnrp.segment.classifier.arrayLength", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_classifier_entryLength,\r\n{ "Entry Length", "pnrp.segment.classifier.entryLength", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_classifier_string,\r\n{ "Classifier", "pnrp.segment.classifier.string", FT_STRING, STR_UNICODE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_ack_flags_reserved,\r\n{ "Reserved", "pnrp.segment.ack.flags.reserved", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_ack_flags_Nbit,\r\n{ "(N)ot found Bit", "pnrp.segment.ack.flags.Nbit", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_authority_flags,\r\n{ "Flags", "pnrp.segment.authority.flags", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_authority_flags_reserved1,\r\n{ "Reserved 1", "pnrp.segment.authority.flags.reserved1", FT_UINT16, BASE_HEX, NULL, FLAGS_AUTHORITY_RESERVED1,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_authority_flags_Lbit,\r\n{ "(L)eaf Set", "pnrp.segment.authority.flags.Lbit", FT_UINT16, BASE_HEX, NULL, FLAGS_AUTHORITY_L,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_authority_flags_reserved2,\r\n{ "Reserved 2", "pnrp.segment.authority.flags.reserved2", FT_UINT16, BASE_HEX, NULL, FLAGS_AUTHORITY_RESERVED2,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_authority_flags_Bbit,\r\n{ "(B)usy", "pnrp.segment.authority.flags.Bbit", FT_UINT16, BASE_HEX, NULL, FLAGS_AUTHORITY_B,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_authority_flags_reserved3,\r\n{ "Reserved 3", "pnrp.segment.authority.flags.reserved3", FT_UINT16, BASE_HEX, NULL, FLAGS_AUTHORITY_RESERVED3,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_authority_flags_Nbit,\r\n{ "(N)ot found", "pnrp.segment.authority.flags.Nbit", FT_UINT16, BASE_HEX, NULL, FLAGS_AUTHORITY_N,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_flood_flags_reserved1,\r\n{ "Reserved", "pnrp.segment.flood.flags.reserved", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_flood_flags_Dbit,\r\n{ "(D)on't send ACK", "pnrp.segment.flood.flags.Dbit", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_splitControls_authorityBuffer,\r\n{ "Authority Buffer Size", "pnrp.segment.splitControls.authorityBuffer", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_ipv6EndpointArray_NumberOfEntries,\r\n{ "Number of Entries", "pnrp.segment.ipv6EndpointArray.NumberOfEntries", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_ipv6EndpointArray_ArrayLength,\r\n{ "Array Length", "pnrp.segment.ipv6EndpointArray.ArrayLength", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_ipv6EndpointArray_EntryLength,\r\n{ "Entry Length", "pnrp.segment.ipv6EndpointArray.EntryLength", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA,\r\n{ "Encoded CPA structure", "pnrp.encodedCPA", FT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_length,\r\n{ "Length", "pnrp.encodedCPA.length", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_majorVersion,\r\n{ "CPA Major Version", "pnrp.encodedCPA.vMajor", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_minorVersion,\r\n{ "CPA Minor Version", "pnrp.encodedCPA.vMinor", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_flags,\r\n{ "Flags", "pnrp.encodedCPA.flags", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_flags_reserved,\r\n{ "Reserved", "pnrp.encodedCPA.flags.reserved", FT_UINT8, BASE_HEX, NULL, FLAGS_ENCODED_CPA_RESERVED,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_flags_Xbit,\r\n{ "CPA has E(X)tended Payload", "pnrp.encodedCPA.flags.xbit", FT_UINT8, BASE_HEX, NULL, FLAGS_ENCODED_CPA_X,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_flags_Fbit,\r\n{ "CPA contains (F)riendly Name", "pnrp.encodedCPA.flags.fbit", FT_UINT8, BASE_HEX, NULL, FLAGS_ENCODED_CPA_F,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_flags_Cbit,\r\n{ "CPA contains (C)lassifier Hash", "pnrp.encodedCPA.flags.cbit", FT_UINT8, BASE_HEX, NULL, FLAGS_ENCODED_CPA_C,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_flags_Abit,\r\n{ "CPA contains Binary (A)uthority field", "pnrp.encodedCPA.flags.abit", FT_UINT8, BASE_HEX, NULL, FLAGS_ENCODED_CPA_A,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_flags_Ubit,\r\n{ "Friendly Name in (U)TF-8", "pnrp.encodedCPA.flags.ubit", FT_UINT8, BASE_HEX, NULL, FLAGS_ENCODED_CPA_U,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_flags_Rbit,\r\n{ "This is a (r)evoke CPA", "pnrp.encodedCPA.flags.rbit", FT_UINT8, BASE_HEX, NULL, FLAGS_ENCODED_CPA_R,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_notAfter,\r\n{ "CPA expiration Date", "pnrp.encodedCPA.expirationDate", FT_UINT64,BASE_DEC, NULL, 0x0,\r\n"CPA expiration Date since January 1, 1601 UTC", HFILL }},\r\n{ &hf_pnrp_encodedCPA_serviceLocation,\r\n{ "Service Location", "pnrp.encodedCPA.serviceLocation", FT_BYTES,BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_binaryAuthority,\r\n{ "Binary Authority", "pnrp.encodedCPA.binaryAuthority", FT_BYTES,BASE_NONE, NULL, 0x0,\r\n"SHA-1 Hash of PublicKey Data field", HFILL }},\r\n{ &hf_pnrp_encodedCPA_classifiertHash,\r\n{ "Classifiert Hash", "pnrp.encodedCPA.classifierHash", FT_BYTES,BASE_NONE, NULL, 0x0,\r\n"SHA-1 Hash of the classifier text", HFILL }},\r\n{ &hf_pnrp_encodedCPA_friendlyName,\r\n{ "Friendly Name of PNRP ID", "pnrp.encodedCPA.friendlyName", FT_STRING,BASE_NONE, NULL, 0x0,\r\n"A human-readable label identifying the PNRP ID", HFILL }},\r\n{ &hf_pnrp_message_lookupControls_flags,\r\n{ "Flags", "pnrp.lookupControls.flags", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_lookupControls_flags_reserved,\r\n{ "Reserved", "pnrp.lookupControls.flags.reserved", FT_UINT16, BASE_HEX, NULL, FLAGS_LOOKUPCONTROLS_RESERVED,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_lookupControls_flags_Abit,\r\n{ "A bit", "pnrp.lookupControls.flags.Abit", FT_UINT16, BASE_HEX, NULL, FLAGS_LOOKUPCONTROLS_A,\r\n"Sender is willing to accept returned nodes that are not closer to the target ID than the Validate PNRP ID", HFILL }},\r\n{ &hf_pnrp_message_lookupControls_flags_0bit,\r\n{ "0 bit - reserved", "pnrp.lookupControls.flags.0bit", FT_UINT16, BASE_HEX, NULL, FLAGS_LOOKUPCONTROLS_0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_lookupControls_precision,\r\n{ "Precision", "pnrp.lookupControls.precision", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Precision - Number of significant bits to match", HFILL }},\r\n{ &hf_pnrp_message_lookupControls_resolveCriteria,\r\n{ "Resolve Criteria", "pnrp.lookupControls.resolveCriteria", FT_UINT8, BASE_HEX, VALS(resolveCriteria), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_lookupControls_reasonCode,\r\n{ "Reason Code", "pnrp.lookupControls.reasonCode", FT_UINT8, BASE_HEX, VALS(reasonCode), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_publicKey_objID,\r\n{ "Public Key Object Identifier", "pnrp.publicKey.objID", FT_STRING,BASE_NONE, NULL, 0x0,\r\n"An ASN.1-encoded object identifier (OID) indicating the public key format", HFILL }},\r\n{ &hf_pnrp_publicKey_publicKeyData,\r\n{ "Public Key Data", "pnrp.publicKey.publicKeyData", FT_STRING,BASE_NONE, NULL, 0x0,\r\n"An ASN.1-encoded 1024-bit RSA public key", HFILL }},\r\n{ &hf_pnrp_signature_signatureData,\r\n{ "Signature", "pnrp.signature.data", FT_BYTES,BASE_NONE, NULL, 0x0,\r\n"Signature created when signing the CPA", HFILL }},\r\n{ &hf_pnrp_message_routeEntry_portNumber,\r\n{ "Port Number", "pnrp.segment.routeEntry.portNumber", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_routeEntry_flags,\r\n{ "Flags", "pnrp.segment.routeEntry.flags", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_routeEntry_addressCount,\r\n{ "Address Count", "pnrp.segment.routeEntry.addressCount", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_nonce,\r\n{ "Nonce", "pnrp.segment.nonce", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_hashednonce,\r\n{ "Hashed Nonce", "pnrp.segment.hashednonce", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_idArray_NumEntries,\r\n{ "Number of Entries", "pnrp.segment.idArray.NumEnries", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_idArray_Length,\r\n{ "Length of Array", "pnrp.segment.idArray.Length", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_ElementFieldType,\r\n{ "Type of Array Entry", "pnrp.segment.ElementFieldType", FT_UINT16, BASE_HEX, VALS(fieldID), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_idarray_Entrylength,\r\n{ "Length of each Array Entry", "pnrp.segment.idArray.Entrylength", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_certChain,\r\n{ "Certificate Chain", "pnrp.segment.certChain", FT_BYTES,BASE_NONE, NULL, 0x0,\r\n"A Certificate Chain, containing the public key used to sign the CPA and its Certificate Chain", HFILL }},\r\n{ &hf_pnrp_message_solicitType,\r\n{ "Solicit Type", "pnrp.segment.solicitType", FT_UINT8, BASE_DEC, VALS(solicitType), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_ipv6,\r\n{ "IPv6 Address","pnrp.segment.ipv6Address",FT_IPv6, BASE_NONE, NULL, 0x0,NULL,HFILL}},\r\n{ &hf_pnrp_fragments,\r\n{ "Fragments", "pnrp.segment.splitControls.fragments", FT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_fragment,\r\n{ "Fragment", "pnrp.segment.splitControls.fragment", FT_FRAMENUM, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_fragment_overlap,\r\n{ "Fragment Overlap", "pnrp.segment.splitControls.fragment_overlap", FT_BOOLEAN, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_fragment_overlap_conflict,\r\n{ "Fragment Overlap Conflict", "pnrp.segment.splitControls.fragment_overlap_conflict", FT_BOOLEAN, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_fragment_multiple_tails,\r\n{ "Fragment Multiple Tails", "pnrp.segment.splitControls.fragment_multiple_tails", FT_BOOLEAN, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_fragment_too_long_fragment,\r\n{ "Too Long Fragment", "pnrp.segment.splitControls.fragment_too_long_fragment", FT_BOOLEAN, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_fragment_error,\r\n{ "Fragment Error", "pnrp.segment.splitControls.fragment_error", FT_FRAMENUM, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_fragment_count,\r\n{ "Fragment Count", "pnrp.segment.splitControls.fragment_count", FT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_reassembled_in,\r\n{ "Reassembled In", "pnrp.segment.splitControls.reassembled_in", FT_FRAMENUM, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_reassembled_length,\r\n{ "Reassembled Length", "pnrp.segment.splitControls.reassembled_length", FT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_reassembled_data,\r\n{ "Reassembled Data", "pnrp.segment.splitControls.reassembled_data", FT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_fragmented_payload,\r\n{ "Fragmented Payload", "pnrp.segment.splitControls.fragmented_payload", FT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }},\r\n{ &hf_pnrp_message_flags, { "Flags", "pnrp.segment.flags", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_reserved8, { "Reserved", "pnrp.reserved", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_reserved16, { "Reserved", "pnrp.reserved", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_message_offset, { "Offset", "pnrp.segment.offset", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_message_data, { "Data", "pnrp.segment.data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_message_port_number, { "Port Number", "pnrp.segment.port_number", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_friendlyName_length, { "Length of Friendly name", "pnrp.encodedCPA.friendlyName.length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_number_of_service_addresses, { "Number of Service Addresses", "pnrp.encodedCPA.number_of_service_addresses", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_service_address_length, { "Service Address Length", "pnrp.encodedCPA.service_address_length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_number_of_payload_structures, { "Number of Payload Structures", "pnrp.encodedCPA.number_of_payload_structures", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_encodedCPA_total_bytes_of_payload, { "Total Bytes of Payload", "pnrp.encodedCPA.total_bytes_of_payload", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_payload_type, { "Payload Type", "pnrp.payload.type", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_length_of_data, { "Length of Data", "pnrp.payload.length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_payload_port, { "Port Number", "pnrp.payload.port", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_payload_iana_proto, { "IANA Protocol Number", "pnrp.payload.iana_proto", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_publicKey_length_of_structure, { "Length of Structure", "pnrp.publicKey.structure_length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_publicKey_size_of_algorithm_oid, { "Size of Algorithm OID", "pnrp.publicKey.algorithm_oid_size", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_publicKey_reserved, { "Reserved", "pnrp.publicKey.reserved", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_publicKey_size_of_cbdata, { "Size of cbData", "pnrp.publicKey.cbdata_size", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_publicKey_unused_bits, { "Unused Bits", "pnrp.publicKey.unused_bits", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_signature_structure_length, { "Length of Structure", "pnrp.signature.structure_length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_signature_length, { "Length of Signature", "pnrp.signature.length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_pnrp_signature_hash_id, { "Hash Algorithm Identifier", "pnrp.signature.hash_id", FT_UINT32, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pnrp,\r\n&ett_pnrp_header,\r\n&ett_pnrp_message,\r\n&ett_pnrp_message_inquire_flags,\r\n&ett_pnrp_message_authority_flags,\r\n&ett_pnrp_message_encodedCPA,\r\n&ett_pnrp_message_encodedCPA_flags,\r\n&ett_pnrp_message_payloadStructure,\r\n&ett_pnrp_message_publicKeyStructure,\r\n&ett_pnrp_message_signatureStructure,\r\n&ett_pnrp_message_lookupControls_flags,\r\n&ett_pnrp_fragment,\r\n&ett_pnrp_fragments\r\n};\r\nproto_pnrp = proto_register_protocol(PROTONAME,PROTOSHORTNAME,PROTOABBREV);\r\nproto_register_field_array(proto_pnrp,hf,array_length(hf));\r\nproto_register_subtree_array (ett, array_length(ett));\r\nregister_init_routine(pnrp_reassembly_init);\r\nregister_cleanup_routine(pnrp_reassembly_cleanup);\r\n}\r\nvoid proto_reg_handoff_pnrp(void)\r\n{\r\ndissector_handle_t pnrp_handle;\r\npnrp_handle = create_dissector_handle(dissect_pnrp, proto_pnrp);\r\ndissector_add_uint("udp.port",PNRP_PORT,pnrp_handle);\r\n}
