const guchar *\r\nfind_line_end(const guchar *data, const guchar *dataend, const guchar **eol)\r\n{\r\nconst guchar *lineend;\r\nlineend = (guchar *)memchr(data, '\n', dataend - data);\r\nif (lineend == NULL) {\r\nlineend = dataend;\r\n*eol = dataend;\r\n} else {\r\nif (lineend > data) {\r\nif (*(lineend - 1) == '\r') {\r\n*eol = lineend - 1;\r\n} else {\r\n*eol = lineend;\r\nif (lineend < (dataend - 1) && *(lineend + 1) == '\r') {\r\nlineend++;\r\n}\r\n}\r\n} else {\r\n*eol = lineend;\r\n}\r\nlineend++;\r\n}\r\nreturn lineend;\r\n}\r\nint\r\nget_token_len(const guchar *linep, const guchar *lineend,\r\nconst guchar **next_token)\r\n{\r\nconst guchar *tokenp;\r\nint token_len;\r\ntokenp = linep;\r\nwhile (linep < lineend && *linep != ' ' && *linep != '\r' && *linep != '\n')\r\nlinep++;\r\ntoken_len = (int) (linep - tokenp);\r\nwhile (linep < lineend && *linep == ' ')\r\nlinep++;\r\n*next_token = linep;\r\nreturn token_len;\r\n}\r\ngchar *\r\nformat_text(const guchar *string, size_t len)\r\n{\r\nstatic gchar *fmtbuf[3];\r\nstatic int fmtbuf_len[3];\r\nstatic int idx;\r\nint column;\r\nconst guchar *stringend = string + len;\r\nguchar c;\r\nint i;\r\nidx = (idx + 1) % 3;\r\nif (fmtbuf[idx] == NULL) {\r\nfmtbuf[idx] = (gchar *)g_malloc(INITIAL_FMTBUF_SIZE);\r\nfmtbuf_len[idx] = INITIAL_FMTBUF_SIZE;\r\n}\r\ncolumn = 0;\r\nwhile (string < stringend) {\r\nif (column+3+1 >= fmtbuf_len[idx]) {\r\nfmtbuf_len[idx] = fmtbuf_len[idx] * 2;\r\nfmtbuf[idx] = (gchar *)g_realloc(fmtbuf[idx], fmtbuf_len[idx]);\r\n}\r\nc = *string++;\r\nif (g_ascii_isprint(c)) {\r\nfmtbuf[idx][column] = c;\r\ncolumn++;\r\n} else {\r\nfmtbuf[idx][column] = '\\';\r\ncolumn++;\r\nswitch (c) {\r\ncase '\a':\r\nfmtbuf[idx][column] = 'a';\r\ncolumn++;\r\nbreak;\r\ncase '\b':\r\nfmtbuf[idx][column] = 'b';\r\ncolumn++;\r\nbreak;\r\ncase '\f':\r\nfmtbuf[idx][column] = 'f';\r\ncolumn++;\r\nbreak;\r\ncase '\n':\r\nfmtbuf[idx][column] = 'n';\r\ncolumn++;\r\nbreak;\r\ncase '\r':\r\nfmtbuf[idx][column] = 'r';\r\ncolumn++;\r\nbreak;\r\ncase '\t':\r\nfmtbuf[idx][column] = 't';\r\ncolumn++;\r\nbreak;\r\ncase '\v':\r\nfmtbuf[idx][column] = 'v';\r\ncolumn++;\r\nbreak;\r\ndefault:\r\ni = (c>>6)&03;\r\nfmtbuf[idx][column] = i + '0';\r\ncolumn++;\r\ni = (c>>3)&07;\r\nfmtbuf[idx][column] = i + '0';\r\ncolumn++;\r\ni = (c>>0)&07;\r\nfmtbuf[idx][column] = i + '0';\r\ncolumn++;\r\nbreak;\r\n}\r\n}\r\n}\r\nfmtbuf[idx][column] = '\0';\r\nreturn fmtbuf[idx];\r\n}\r\ngchar *\r\nformat_text_wsp(const guchar *string, size_t len)\r\n{\r\nstatic gchar *fmtbuf[3];\r\nstatic int fmtbuf_len[3];\r\nstatic int idx;\r\nint column;\r\nconst guchar *stringend = string + len;\r\nguchar c;\r\nint i;\r\nidx = (idx + 1) % 3;\r\nif (fmtbuf[idx] == NULL) {\r\nfmtbuf[idx] = (gchar *)g_malloc(INITIAL_FMTBUF_SIZE);\r\nfmtbuf_len[idx] = INITIAL_FMTBUF_SIZE;\r\n}\r\ncolumn = 0;\r\nwhile (string < stringend) {\r\nif (column+3+1 >= fmtbuf_len[idx]) {\r\nfmtbuf_len[idx] = fmtbuf_len[idx] * 2;\r\nfmtbuf[idx] = (gchar *)g_realloc(fmtbuf[idx], fmtbuf_len[idx]);\r\n}\r\nc = *string++;\r\nif (g_ascii_isprint(c)) {\r\nfmtbuf[idx][column] = c;\r\ncolumn++;\r\n} else if (g_ascii_isspace(c)) {\r\nfmtbuf[idx][column] = ' ';\r\ncolumn++;\r\n} else {\r\nfmtbuf[idx][column] = '\\';\r\ncolumn++;\r\nswitch (c) {\r\ncase '\a':\r\nfmtbuf[idx][column] = 'a';\r\ncolumn++;\r\nbreak;\r\ncase '\b':\r\nfmtbuf[idx][column] = 'b';\r\ncolumn++;\r\nbreak;\r\ncase '\f':\r\nfmtbuf[idx][column] = 'f';\r\ncolumn++;\r\nbreak;\r\ncase '\n':\r\nfmtbuf[idx][column] = 'n';\r\ncolumn++;\r\nbreak;\r\ncase '\r':\r\nfmtbuf[idx][column] = 'r';\r\ncolumn++;\r\nbreak;\r\ncase '\t':\r\nfmtbuf[idx][column] = 't';\r\ncolumn++;\r\nbreak;\r\ncase '\v':\r\nfmtbuf[idx][column] = 'v';\r\ncolumn++;\r\nbreak;\r\ndefault:\r\ni = (c>>6)&03;\r\nfmtbuf[idx][column] = i + '0';\r\ncolumn++;\r\ni = (c>>3)&07;\r\nfmtbuf[idx][column] = i + '0';\r\ncolumn++;\r\ni = (c>>0)&07;\r\nfmtbuf[idx][column] = i + '0';\r\ncolumn++;\r\nbreak;\r\n}\r\n}\r\n}\r\nfmtbuf[idx][column] = '\0';\r\nreturn fmtbuf[idx];\r\n}\r\ngchar *\r\nformat_text_chr(const guchar *string, const size_t len, const guchar chr)\r\n{\r\nstatic gchar *fmtbuf[3];\r\nstatic int fmtbuf_len[3];\r\nstatic int idx;\r\nint column;\r\nconst guchar *stringend = string + len;\r\nguchar c;\r\nidx = (idx + 1) % 3;\r\nif (fmtbuf[idx] == NULL) {\r\nfmtbuf[idx] = (gchar *)g_malloc(INITIAL_FMTBUF_SIZE);\r\nfmtbuf_len[idx] = INITIAL_FMTBUF_SIZE;\r\n}\r\ncolumn = 0;\r\nwhile (string < stringend)\r\n{\r\nif (column+1 >= fmtbuf_len[idx])\r\n{\r\nfmtbuf_len[idx] = fmtbuf_len[idx] * 2;\r\nfmtbuf[idx] = (gchar *)g_realloc(fmtbuf[idx], fmtbuf_len[idx]);\r\n}\r\nc = *string++;\r\nif (g_ascii_isprint(c))\r\n{\r\nfmtbuf[idx][column] = c;\r\ncolumn++;\r\n}\r\nelse if (g_ascii_isspace(c))\r\n{\r\nfmtbuf[idx][column] = ' ';\r\ncolumn++;\r\n}\r\nelse\r\n{\r\nfmtbuf[idx][column] = chr;\r\ncolumn++;\r\n}\r\n}\r\nfmtbuf[idx][column] = '\0';\r\nreturn fmtbuf[idx];\r\n}\r\nstatic gboolean\r\nis_byte_sep(guint8 c)\r\n{\r\nreturn (c == '-' || c == ':' || c == '.');\r\n}\r\ngboolean\r\nhex_str_to_bytes(const char *hex_str, GByteArray *bytes, gboolean force_separators)\r\n{\r\nguint8 val;\r\nconst gchar *p, *q, *r, *s, *punct;\r\nchar four_digits_first_half[3];\r\nchar four_digits_second_half[3];\r\nchar two_digits[3];\r\nchar one_digit[2];\r\nif (! hex_str || ! bytes) {\r\nreturn FALSE;\r\n}\r\ng_byte_array_set_size(bytes, 0);\r\np = hex_str;\r\nwhile (*p) {\r\nq = p+1;\r\nr = p+2;\r\ns = p+3;\r\nif (*q && *r && *s\r\n&& g_ascii_isxdigit(*p) && g_ascii_isxdigit(*q) &&\r\ng_ascii_isxdigit(*r) && g_ascii_isxdigit(*s)) {\r\nfour_digits_first_half[0] = *p;\r\nfour_digits_first_half[1] = *q;\r\nfour_digits_first_half[2] = '\0';\r\nfour_digits_second_half[0] = *r;\r\nfour_digits_second_half[1] = *s;\r\nfour_digits_second_half[2] = '\0';\r\nval = (guint8) strtoul(four_digits_first_half, NULL, 16);\r\ng_byte_array_append(bytes, &val, 1);\r\nval = (guint8) strtoul(four_digits_second_half, NULL, 16);\r\ng_byte_array_append(bytes, &val, 1);\r\npunct = s + 1;\r\nif (*punct) {\r\nif (is_byte_sep(*punct)) {\r\np = punct + 1;\r\ncontinue;\r\n}\r\nelse if (force_separators) {\r\nreturn FALSE;\r\n}\r\n}\r\np = punct;\r\ncontinue;\r\n}\r\nelse if (*q && g_ascii_isxdigit(*p) && g_ascii_isxdigit(*q)) {\r\ntwo_digits[0] = *p;\r\ntwo_digits[1] = *q;\r\ntwo_digits[2] = '\0';\r\nval = (guint8) strtoul(two_digits, NULL, 16);\r\ng_byte_array_append(bytes, &val, 1);\r\npunct = q + 1;\r\nif (*punct) {\r\nif (is_byte_sep(*punct)) {\r\np = punct + 1;\r\ncontinue;\r\n}\r\nelse if (force_separators) {\r\nreturn FALSE;\r\n}\r\n}\r\np = punct;\r\ncontinue;\r\n}\r\nelse if (*q && g_ascii_isxdigit(*p) && is_byte_sep(*q)) {\r\none_digit[0] = *p;\r\none_digit[1] = '\0';\r\nval = (guint8) strtoul(one_digit, NULL, 16);\r\ng_byte_array_append(bytes, &val, 1);\r\np = q + 1;\r\ncontinue;\r\n}\r\nelse if (!*q && g_ascii_isxdigit(*p)) {\r\none_digit[0] = *p;\r\none_digit[1] = '\0';\r\nval = (guint8) strtoul(one_digit, NULL, 16);\r\ng_byte_array_append(bytes, &val, 1);\r\np = q;\r\ncontinue;\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic inline gchar\r\nget_valid_byte_sep(gchar c, const guint encoding)\r\n{\r\ngchar retval = -1;\r\nswitch (c) {\r\ncase ':':\r\nif (encoding & ENC_SEP_COLON)\r\nretval = c;\r\nbreak;\r\ncase '-':\r\nif (encoding & ENC_SEP_DASH)\r\nretval = c;\r\nbreak;\r\ncase '.':\r\nif (encoding & ENC_SEP_DOT)\r\nretval = c;\r\nbreak;\r\ncase ' ':\r\nif (encoding & ENC_SEP_SPACE)\r\nretval = c;\r\nbreak;\r\ncase '\0':\r\nretval = 0;\r\nbreak;\r\ndefault:\r\nif (g_ascii_isxdigit(c) && (encoding & ENC_SEP_NONE))\r\nretval = 0;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\ngboolean\r\nhex_str_to_bytes_encoding(const gchar *hex_str, GByteArray *bytes, const gchar **endptr,\r\nconst guint encoding, const gboolean fail_if_partial)\r\n{\r\ngint8 c, d;\r\nguint8 val;\r\nconst gchar *end = hex_str;\r\ngboolean retval = FALSE;\r\ngchar sep = -1;\r\nstatic const gint8 str_to_nibble[256] = {\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,\r\n-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\r\n-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\r\n};\r\nif (bytes && *end && g_ascii_isxdigit(*end) && g_ascii_isxdigit(*(end+1))) {\r\nretval = TRUE;\r\nsep = get_valid_byte_sep(*(end+2), encoding);\r\nwhile (*end) {\r\nc = str_to_nibble[(guchar)*end];\r\nif (c < 0) {\r\nif (fail_if_partial) retval = FALSE;\r\nbreak;\r\n}\r\n++end;\r\nd = str_to_nibble[(guchar)*end];\r\nif (d < 0) {\r\nif (fail_if_partial) retval = FALSE;\r\nbreak;\r\n}\r\nval = ((guint8)c * 16) + d;\r\ng_byte_array_append(bytes, &val, 1);\r\n++end;\r\nif (sep > 0 && *end == sep && str_to_nibble[(guchar)*(end+1)] > -1) {\r\n++end;\r\n} else if (sep != 0 && *end) {\r\nif (fail_if_partial) retval = FALSE;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!retval) {\r\nif (bytes) g_byte_array_set_size(bytes, 0);\r\nend = hex_str;\r\n}\r\nif (endptr) *endptr = end;\r\nreturn retval;\r\n}\r\ngboolean\r\nuri_str_to_bytes(const char *uri_str, GByteArray *bytes)\r\n{\r\nguint8 val;\r\nconst gchar *p;\r\ngchar hex_digit[HEX_DIGIT_BUF_LEN];\r\ng_byte_array_set_size(bytes, 0);\r\nif (! uri_str) {\r\nreturn FALSE;\r\n}\r\np = uri_str;\r\nwhile (*p) {\r\nif (!g_ascii_isprint(*p))\r\nreturn FALSE;\r\nif (*p == '%') {\r\np++;\r\nif (*p == '\0') return FALSE;\r\nhex_digit[0] = *p;\r\np++;\r\nif (*p == '\0') return FALSE;\r\nhex_digit[1] = *p;\r\nhex_digit[2] = '\0';\r\nif (! g_ascii_isxdigit(hex_digit[0]) || ! g_ascii_isxdigit(hex_digit[1]))\r\nreturn FALSE;\r\nval = (guint8) strtoul(hex_digit, NULL, 16);\r\ng_byte_array_append(bytes, &val, 1);\r\n} else {\r\ng_byte_array_append(bytes, (const guint8 *) p, 1);\r\n}\r\np++;\r\n}\r\nreturn TRUE;\r\n}\r\nconst gchar *\r\nformat_uri(const GByteArray *bytes, const gchar *reserved_chars)\r\n{\r\nstatic gchar *fmtbuf[3];\r\nstatic guint fmtbuf_len[3];\r\nstatic guint idx;\r\nstatic const guchar *reserved_def = ":/?#[]@!$&'()*+,;= ";\r\nconst guchar *reserved = reserved_def;\r\nguint8 c;\r\nguint column, i;\r\ngboolean is_reserved = FALSE;\r\nif (! bytes)\r\nreturn "";\r\nidx = (idx + 1) % 3;\r\nif (reserved_chars)\r\nreserved = reserved_chars;\r\nif (fmtbuf[idx] == NULL) {\r\nfmtbuf[idx] = (gchar *)g_malloc(INITIAL_FMTBUF_SIZE);\r\nfmtbuf_len[idx] = INITIAL_FMTBUF_SIZE;\r\n}\r\nfor (column = 0; column < bytes->len; column++) {\r\nif (column+2+1 >= fmtbuf_len[idx]) {\r\nfmtbuf_len[idx] = fmtbuf_len[idx] * 2;\r\nfmtbuf[idx] = (gchar *)g_realloc(fmtbuf[idx], fmtbuf_len[idx]);\r\n}\r\nc = bytes->data[column];\r\nif (!g_ascii_isprint(c) || c == '%') {\r\nis_reserved = TRUE;\r\n}\r\nfor (i = 0; reserved[i]; i++) {\r\nif (c == reserved[i])\r\nis_reserved = TRUE;\r\n}\r\nif (!is_reserved) {\r\nfmtbuf[idx][column] = c;\r\n} else {\r\nfmtbuf[idx][column] = '%';\r\ncolumn++;\r\nfmtbuf[idx][column] = hex[c >> 4];\r\ncolumn++;\r\nfmtbuf[idx][column] = hex[c & 0xF];\r\n}\r\n}\r\nfmtbuf[idx][column] = '\0';\r\nreturn fmtbuf[idx];\r\n}\r\nGByteArray *\r\nbyte_array_dup(const GByteArray *ba)\r\n{\r\nGByteArray *new_ba;\r\nif (!ba)\r\nreturn NULL;\r\nnew_ba = g_byte_array_new();\r\ng_byte_array_append(new_ba, ba->data, ba->len);\r\nreturn new_ba;\r\n}\r\ngboolean\r\noid_str_to_bytes(const char *oid_str, GByteArray *bytes)\r\n{\r\nreturn rel_oid_str_to_bytes(oid_str, bytes, TRUE);\r\n}\r\ngboolean\r\nrel_oid_str_to_bytes(const char *oid_str, GByteArray *bytes, gboolean is_absolute)\r\n{\r\nguint32 subid0, subid, sicnt, i;\r\nconst char *p, *dot;\r\nguint8 buf[SUBID_BUF_LEN];\r\ng_byte_array_set_size(bytes, 0);\r\np = oid_str;\r\ndot = NULL;\r\nwhile (*p) {\r\nif (!g_ascii_isdigit(*p) && (*p != '.')) return FALSE;\r\nif (*p == '.') {\r\nif (p == oid_str && is_absolute) return FALSE;\r\nif (!*(p+1)) return FALSE;\r\nif ((p-1) == dot) return FALSE;\r\ndot = p;\r\n}\r\np++;\r\n}\r\nif (!dot) return FALSE;\r\np = oid_str;\r\nsicnt = is_absolute ? 0 : 2;\r\nif (!is_absolute) p++;\r\nsubid0 = 0;\r\nwhile (*p) {\r\nsubid = 0;\r\nwhile (g_ascii_isdigit(*p)) {\r\nsubid *= 10;\r\nsubid += *p - '0';\r\np++;\r\n}\r\nif (sicnt == 0) {\r\nsubid0 = subid;\r\nif (subid0 > 2) return FALSE;\r\n} else if (sicnt == 1) {\r\nif ((subid0 < 2) && (subid > 39)) return FALSE;\r\nsubid += 40 * subid0;\r\n}\r\nif (sicnt) {\r\ni = SUBID_BUF_LEN;\r\ndo {\r\ni--;\r\nbuf[i] = 0x80 | (subid % 0x80);\r\nsubid >>= 7;\r\n} while (subid && i);\r\nbuf[SUBID_BUF_LEN-1] &= 0x7F;\r\ng_byte_array_append(bytes, buf + i, SUBID_BUF_LEN - i);\r\n}\r\nsicnt++;\r\nif (*p) p++;\r\n}\r\nreturn TRUE;\r\n}\r\ngboolean\r\nbyte_array_equal(GByteArray *ba1, GByteArray *ba2)\r\n{\r\nif (!ba1 || !ba2)\r\nreturn FALSE;\r\nif (ba1->len != ba2->len)\r\nreturn FALSE;\r\nif (memcmp(ba1->data, ba2->data, ba1->len) != 0)\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\ngchar *\r\nxml_escape(const gchar *unescaped)\r\n{\r\nGString *buffer = g_string_sized_new(128);\r\nconst gchar *p;\r\ngchar c;\r\np = unescaped;\r\nwhile ( (c = *p++) ) {\r\nswitch (c) {\r\ncase '<':\r\ng_string_append(buffer, "&lt;");\r\nbreak;\r\ncase '>':\r\ng_string_append(buffer, "&gt;");\r\nbreak;\r\ncase '&':\r\ng_string_append(buffer, "&amp;");\r\nbreak;\r\ncase '\'':\r\ng_string_append(buffer, "&#x27;");\r\nbreak;\r\ncase '"':\r\ng_string_append(buffer, "&quot;");\r\nbreak;\r\ndefault:\r\ng_string_append_c(buffer, c);\r\nbreak;\r\n}\r\n}\r\nreturn g_string_free(buffer, FALSE);\r\n}\r\nconst guint8 *\r\nepan_memmem(const guint8 *haystack, guint haystack_len,\r\nconst guint8 *needle, guint needle_len)\r\n{\r\nconst guint8 *begin;\r\nconst guint8 *const last_possible = haystack + haystack_len - needle_len;\r\nif (needle_len == 0) {\r\nreturn NULL;\r\n}\r\nif (needle_len > haystack_len) {\r\nreturn NULL;\r\n}\r\nfor (begin = haystack ; begin <= last_possible; ++begin) {\r\nif (begin[0] == needle[0] &&\r\n!memcmp(&begin[1], needle + 1,\r\nneedle_len - 1)) {\r\nreturn begin;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nguint8 *\r\nconvert_string_to_hex(const char *string, size_t *nbytes)\r\n{\r\nsize_t n_bytes;\r\nconst char *p;\r\ngchar c;\r\nguint8 *bytes, *q, byte_val;\r\nn_bytes = 0;\r\np = &string[0];\r\nfor (;;) {\r\nc = *p++;\r\nif (c == '\0')\r\nbreak;\r\nif (g_ascii_isspace(c))\r\ncontinue;\r\nif (c==':' || c=='.' || c=='-')\r\ncontinue;\r\nif (!g_ascii_isxdigit(c)) {\r\nreturn NULL;\r\n}\r\nc = *p++;\r\nif (!g_ascii_isxdigit(c))\r\nreturn NULL;\r\nn_bytes++;\r\n}\r\nif (n_bytes == 0) {\r\nreturn NULL;\r\n}\r\nbytes = (guint8 *)g_malloc(n_bytes);\r\np = &string[0];\r\nq = &bytes[0];\r\nfor (;;) {\r\nc = *p++;\r\nif (c == '\0')\r\nbreak;\r\nif (g_ascii_isspace(c))\r\ncontinue;\r\nif (c==':' || c=='.' || c=='-')\r\ncontinue;\r\nbyte_val = ws_xton(c);\r\nbyte_val <<= 4;\r\nc = *p++;\r\nbyte_val |= ws_xton(c);\r\n*q++ = byte_val;\r\n}\r\n*nbytes = n_bytes;\r\nreturn bytes;\r\n}\r\nchar *\r\nconvert_string_case(const char *string, gboolean case_insensitive)\r\n{\r\nif (case_insensitive) {\r\nreturn g_utf8_strup(string, -1);\r\n} else {\r\nreturn g_strdup(string);\r\n}\r\n}\r\nconst char *\r\nepan_strcasestr(const char *haystack, const char *needle)\r\n{\r\ngsize hlen = strlen(haystack);\r\ngsize nlen = strlen(needle);\r\nwhile (hlen-- >= nlen) {\r\nif (!g_ascii_strncasecmp(haystack, needle, nlen))\r\nreturn haystack;\r\nhaystack++;\r\n}\r\nreturn NULL;\r\n}\r\nconst char *\r\nstring_or_null(const char *string)\r\n{\r\nif (string)\r\nreturn string;\r\nreturn "[NULL]";\r\n}\r\nint\r\nescape_string_len(const char *string)\r\n{\r\nconst char *p;\r\ngchar c;\r\nint repr_len;\r\nrepr_len = 0;\r\nfor (p = string; (c = *p) != '\0'; p++) {\r\nif (c == '\\' || c == '"') {\r\nrepr_len += 2;\r\n}\r\nelse if (!g_ascii_isprint(c)) {\r\nrepr_len += 4;\r\n}\r\nelse {\r\nrepr_len++;\r\n}\r\n}\r\nreturn repr_len + 2;\r\n}\r\nchar *\r\nescape_string(char *buf, const char *string)\r\n{\r\nconst gchar *p;\r\ngchar c;\r\nchar *bufp;\r\nchar hexbuf[3];\r\nbufp = buf;\r\n*bufp++ = '"';\r\nfor (p = string; (c = *p) != '\0'; p++) {\r\nif (c == '\\' || c == '"') {\r\n*bufp++ = '\\';\r\n*bufp++ = c;\r\n}\r\nelse if (!g_ascii_isprint(c)) {\r\ng_snprintf(hexbuf,sizeof(hexbuf), "%02x", (unsigned char) c);\r\n*bufp++ = '\\';\r\n*bufp++ = 'x';\r\n*bufp++ = hexbuf[0];\r\n*bufp++ = hexbuf[1];\r\n}\r\nelse {\r\n*bufp++ = c;\r\n}\r\n}\r\n*bufp++ = '"';\r\n*bufp = '\0';\r\nreturn buf;\r\n}\r\nstatic gunichar\r\nchar_def_ia5_alphabet_decode(unsigned char value)\r\n{\r\nif (value < GN_CHAR_ALPHABET_SIZE) {\r\nreturn IA5_default_alphabet[value];\r\n}\r\nelse {\r\nreturn '?';\r\n}\r\n}\r\nvoid\r\nIA5_7BIT_decode(unsigned char * dest, const unsigned char* src, int len)\r\n{\r\nint i, j;\r\ngunichar buf;\r\nfor (i = 0, j = 0; j < len; j++) {\r\nbuf = char_def_ia5_alphabet_decode(src[j]);\r\ni += g_unichar_to_utf8(buf,&(dest[i]));\r\n}\r\ndest[i]=0;\r\nreturn;\r\n}\r\ngchar*\r\nws_strdup_escape_char (const gchar *str, const gchar chr)\r\n{\r\nconst gchar *p;\r\ngchar *q, *new_str;\r\nif(!str)\r\nreturn NULL;\r\np = str;\r\nq = new_str = (gchar *)g_malloc (strlen(str) * 2 + 1);\r\nwhile(*p != 0) {\r\nif(*p == chr)\r\n*q++ = chr;\r\n*q++ = *p++;\r\n}\r\n*q = '\0';\r\nreturn new_str;\r\n}\r\ngchar*\r\nws_strdup_unescape_char (const gchar *str, const char chr)\r\n{\r\nconst gchar *p;\r\ngchar *q, *new_str;\r\nif(!str)\r\nreturn NULL;\r\np = str;\r\nq = new_str = (gchar *)g_malloc (strlen(str) + 1);\r\nwhile(*p != 0) {\r\n*q++ = *p;\r\nif ((*p == chr) && (*(p+1) == chr))\r\np += 2;\r\nelse\r\np++;\r\n}\r\n*q = '\0';\r\nreturn new_str;\r\n}\r\ngchar *\r\nstring_replace(const gchar* str, const gchar *old_val, const gchar *new_val)\r\n{\r\ngchar **str_parts;\r\ngchar *new_str;\r\nif (!str || !old_val) {\r\nreturn NULL;\r\n}\r\nstr_parts = g_strsplit(str, old_val, 0);\r\nnew_str = g_strjoinv(new_val, str_parts);\r\ng_strfreev(str_parts);\r\nreturn new_str;\r\n}
