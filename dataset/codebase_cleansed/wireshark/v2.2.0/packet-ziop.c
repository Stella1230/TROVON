static int\r\ndissect_ziop (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_) {\r\nguint offset = 0;\r\nguint8 giop_version_major, giop_version_minor, message_type;\r\nproto_tree *ziop_tree = NULL;\r\nproto_item *ti;\r\nguint8 flags;\r\nguint byte_order;\r\nconst char *label = "none";\r\nif (tvb_reported_length(tvb) < 7)\r\nreturn 0;\r\ncol_set_str (pinfo->cinfo, COL_PROTOCOL, ZIOP_MAGIC);\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item (tree, proto_ziop, tvb, 0, -1, ENC_NA);\r\nziop_tree = proto_item_add_subtree (ti, ett_ziop);\r\nproto_tree_add_item(ziop_tree, hf_ziop_magic, tvb, offset, 4, ENC_ASCII|ENC_NA);\r\noffset += 4;\r\nproto_tree_add_item(ziop_tree, hf_ziop_giop_version_major, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ngiop_version_major = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nproto_tree_add_item(ziop_tree, hf_ziop_giop_version_minor, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ngiop_version_minor = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nif ( (giop_version_major < 1) ||\r\n(giop_version_minor < 2) )\r\n{\r\ncol_add_fstr (pinfo->cinfo, COL_INFO, "Version %u.%u",\r\ngiop_version_major, giop_version_minor);\r\nexpert_add_info_format(pinfo, ti, &ei_ziop_version,\r\n"Version %u.%u not supported",\r\ngiop_version_major,\r\ngiop_version_minor);\r\ncall_data_dissector(tvb, pinfo, tree);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nflags = tvb_get_guint8(tvb, offset);\r\nbyte_order = (flags & 0x01) ? ENC_LITTLE_ENDIAN : ENC_BIG_ENDIAN;\r\nif (flags & 0x01) {\r\nlabel = "little-endian";\r\n}\r\nproto_tree_add_uint_format_value(ziop_tree, hf_ziop_flags, tvb, offset, 1,\r\nflags, "0x%02x (%s)", flags, label);\r\noffset++;\r\nproto_tree_add_item(ziop_tree, hf_ziop_message_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nmessage_type = tvb_get_guint8(tvb, offset);\r\noffset++;\r\ncol_add_fstr (pinfo->cinfo, COL_INFO, "ZIOP %u.%u %s",\r\ngiop_version_major,\r\ngiop_version_minor,\r\nval_to_str(message_type, giop_message_types,\r\n"Unknown message type (0x%02x)")\r\n);\r\nproto_tree_add_item(ziop_tree, hf_ziop_message_size, tvb, offset, 4, byte_order);\r\noffset += 4;\r\nproto_tree_add_item(ziop_tree, hf_ziop_compressor_id, tvb, offset, 2, byte_order);\r\noffset += 4;\r\nproto_tree_add_item(ziop_tree, hf_ziop_original_length, tvb, offset, 4, byte_order);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic guint\r\nget_ziop_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint8 flags;\r\nguint message_size;\r\ngboolean stream_is_big_endian;\r\nif ( tvb_memeql(tvb, 0, ZIOP_MAGIC, 4) != 0)\r\nreturn 0;\r\nflags = tvb_get_guint8(tvb, offset + 6);\r\nstream_is_big_endian = ((flags & 0x1) == 0);\r\nif (stream_is_big_endian)\r\nmessage_size = tvb_get_ntohl(tvb, offset + 8);\r\nelse\r\nmessage_size = tvb_get_letohl(tvb, offset + 8);\r\nreturn message_size + ZIOP_HEADER_SIZE;\r\n}\r\nstatic int\r\ndissect_ziop_tcp (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data)\r\n{\r\nif ( tvb_memeql(tvb, 0, ZIOP_MAGIC, 4) != 0)\r\n{\r\nif (tvb_get_ntohl(tvb, 0) == GIOP_MAGIC_NUMBER)\r\n{\r\ndissect_giop(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nreturn 0;\r\n}\r\ntcp_dissect_pdus(tvb, pinfo, tree, ziop_desegment, ZIOP_HEADER_SIZE,\r\nget_ziop_pdu_len, dissect_ziop, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\ngboolean\r\ndissect_ziop_heur (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * data)\r\n{\r\nguint tot_len;\r\nconversation_t *conversation;\r\ntot_len = tvb_captured_length(tvb);\r\nif (tot_len < ZIOP_HEADER_SIZE)\r\n{\r\nreturn FALSE;\r\n}\r\nif ( tvb_memeql(tvb, 0, ZIOP_MAGIC, 4) != 0)\r\n{\r\nreturn FALSE;\r\n}\r\nif ( pinfo->ptype == PT_TCP )\r\n{\r\nif (!pinfo->fd->flags.visited)\r\n{\r\nconversation = find_or_create_conversation(pinfo);\r\nconversation_set_dissector(conversation, ziop_tcp_handle);\r\n}\r\ndissect_ziop_tcp (tvb, pinfo, tree, data);\r\n}\r\nelse\r\n{\r\ndissect_ziop (tvb, pinfo, tree, data);\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_ziop (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ziop_magic,\r\n{ "Header magic", "ziop.magic", FT_STRING, BASE_NONE, NULL, 0x0,\r\n"ZIOPHeader magic", HFILL }},\r\n{ &hf_ziop_giop_version_major,\r\n{ "Header major version", "ziop.giop_version_major", FT_UINT8, BASE_OCT, NULL, 0x0,\r\n"ZIOPHeader giop_major_version", HFILL }},\r\n{ &hf_ziop_giop_version_minor,\r\n{ "Header minor version", "ziop.giop_version_minor", FT_UINT8, BASE_OCT, NULL, 0x0,\r\n"ZIOPHeader giop_minor_version", HFILL }},\r\n{ &hf_ziop_flags,\r\n{ "Header flags", "ziop.flags", FT_UINT8, BASE_OCT, NULL, 0x0,\r\n"ZIOPHeader flags", HFILL }},\r\n{ &hf_ziop_message_type,\r\n{ "Header type", "ziop.message_type", FT_UINT8, BASE_OCT, VALS(giop_message_types), 0x0,\r\n"ZIOPHeader message_type", HFILL }},\r\n{ &hf_ziop_message_size,\r\n{ "Header size", "ziop.message_size", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"ZIOPHeader message_size", HFILL }},\r\n{ &hf_ziop_compressor_id,\r\n{ "Header compressor id", "ziop.compressor_id", FT_UINT16, BASE_DEC, VALS(ziop_compressor_ids), 0x0,\r\n"ZIOPHeader compressor_id", HFILL }},\r\n{ &hf_ziop_original_length,\r\n{ "Header original length", "ziop.original_length", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"ZIOP original_length", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ziop\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ziop_version, { "ziop.version_not_supported", PI_PROTOCOL, PI_WARN, "Version not supported", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ziop;\r\nproto_ziop = proto_register_protocol("Zipped Inter-ORB Protocol", "ZIOP",\r\n"ziop");\r\nproto_register_field_array (proto_ziop, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nexpert_ziop = expert_register_protocol(proto_ziop);\r\nexpert_register_field_array(expert_ziop, ei, array_length(ei));\r\nregister_dissector("ziop", dissect_ziop, proto_ziop);\r\n}\r\nvoid\r\nproto_reg_handoff_ziop (void)\r\n{\r\nziop_tcp_handle = create_dissector_handle(dissect_ziop_tcp, proto_ziop);\r\ndissector_add_for_decode_as("udp.port", ziop_tcp_handle);\r\nheur_dissector_add("tcp", dissect_ziop_heur, "ZIOP over TCP", "ziop_tcp", proto_ziop, HEURISTIC_ENABLE);\r\n}
