static gboolean\r\ntapall_tcpip_packet(void *pct, packet_info *pinfo, epan_dissect_t *edt _U_, const void *vip)\r\n{\r\ntcp_scan_t *ts = (tcp_scan_t *)pct;\r\nstruct tcp_graph *tg = ts->tg;\r\nconst struct tcpheader *tcphdr = (const struct tcpheader *)vip;\r\nif (tg->stream == tcphdr->th_stream\r\n&& (tg->src_address.type == AT_NONE || tg->dst_address.type == AT_NONE)) {\r\ncopy_address(&tg->src_address, &tcphdr->ip_dst);\r\ntg->src_port = tcphdr->th_dport;\r\ncopy_address(&tg->dst_address, &tcphdr->ip_src);\r\ntg->dst_port = tcphdr->th_sport;\r\n}\r\nif (compare_headers(&tg->src_address, &tg->dst_address,\r\ntg->src_port, tg->dst_port,\r\n&tcphdr->ip_src, &tcphdr->ip_dst,\r\ntcphdr->th_sport, tcphdr->th_dport,\r\nts->direction)\r\n&& tg->stream == tcphdr->th_stream)\r\n{\r\nstruct segment *segment = (struct segment *)g_malloc(sizeof(struct segment));\r\nsegment->next = NULL;\r\nsegment->num = pinfo->num;\r\nsegment->rel_secs = (guint32)pinfo->rel_ts.secs;\r\nsegment->rel_usecs = pinfo->rel_ts.nsecs/1000;\r\nsegment->th_seq = tcphdr->th_seq;\r\nsegment->th_ack = tcphdr->th_ack;\r\nsegment->th_win = tcphdr->th_win;\r\nsegment->th_flags = tcphdr->th_flags;\r\nsegment->th_sport = tcphdr->th_sport;\r\nsegment->th_dport = tcphdr->th_dport;\r\nsegment->th_seglen = tcphdr->th_seglen;\r\ncopy_address(&segment->ip_src, &tcphdr->ip_src);\r\ncopy_address(&segment->ip_dst, &tcphdr->ip_dst);\r\nsegment->num_sack_ranges = MIN(MAX_TCP_SACK_RANGES, tcphdr->num_sack_ranges);\r\nif (segment->num_sack_ranges > 0) {\r\nmemcpy(&segment->sack_left_edge, &tcphdr->sack_left_edge, sizeof(segment->sack_left_edge));\r\nmemcpy(&segment->sack_right_edge, &tcphdr->sack_right_edge, sizeof(segment->sack_right_edge));\r\n}\r\nif (ts->tg->segments) {\r\nts->last->next = segment;\r\n} else {\r\nts->tg->segments = segment;\r\n}\r\nts->last = segment;\r\n}\r\nreturn FALSE;\r\n}\r\nvoid\r\ngraph_segment_list_get(capture_file *cf, struct tcp_graph *tg, gboolean stream_known)\r\n{\r\nstruct segment current;\r\nGString *error_string;\r\ntcp_scan_t ts;\r\ng_log(NULL, G_LOG_LEVEL_DEBUG, "graph_segment_list_get()");\r\nif (!cf || !tg) return;\r\nif (!stream_known) {\r\nstruct tcpheader *header = select_tcpip_session(cf, &current);\r\nif (!header) return;\r\nif (tg->type == GRAPH_THROUGHPUT)\r\nts.direction = COMPARE_CURR_DIR;\r\nelse\r\nts.direction = COMPARE_ANY_DIR;\r\ncopy_address(&tg->src_address, &current.ip_src);\r\ntg->src_port = current.th_sport;\r\ncopy_address(&tg->dst_address, &current.ip_dst);\r\ntg->dst_port = current.th_dport;\r\ntg->stream = header->th_stream;\r\n}\r\nelse {\r\nts.direction = COMPARE_ANY_DIR;\r\n}\r\nts.current = &current;\r\nts.tg = tg;\r\nts.last = NULL;\r\nerror_string = register_tap_listener("tcp", &ts, "tcp", 0, NULL, tapall_tcpip_packet, NULL);\r\nif (error_string) {\r\nfprintf(stderr, "wireshark: Couldn't register tcp_graph tap: %s\n",\r\nerror_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\ncf_retap_packets(cf);\r\nremove_tap_listener(&ts);\r\n}\r\nvoid\r\ngraph_segment_list_free(struct tcp_graph *tg)\r\n{\r\nstruct segment *segment;\r\nwhile (tg->segments) {\r\nsegment = tg->segments->next;\r\ng_free(tg->segments);\r\ntg->segments = segment;\r\n}\r\ntg->segments = NULL;\r\n}\r\nint\r\ncompare_headers(address *saddr1, address *daddr1, guint16 sport1, guint16 dport1, const address *saddr2, const address *daddr2, guint16 sport2, guint16 dport2, int dir)\r\n{\r\nint dir1, dir2;\r\ndir1 = ((!(cmp_address(saddr1, saddr2))) &&\r\n(!(cmp_address(daddr1, daddr2))) &&\r\n(sport1==sport2) &&\r\n(dport1==dport2));\r\nif (dir == COMPARE_CURR_DIR) {\r\nreturn dir1;\r\n} else {\r\ndir2 = ((!(cmp_address(saddr1, daddr2))) &&\r\n(!(cmp_address(daddr1, saddr2))) &&\r\n(sport1 == dport2) &&\r\n(dport1 == sport2));\r\nreturn dir1 || dir2;\r\n}\r\n}\r\nint\r\nget_num_dsegs(struct tcp_graph *tg)\r\n{\r\nint count;\r\nstruct segment *tmp;\r\nfor (tmp=tg->segments, count=0; tmp; tmp=tmp->next) {\r\nif (compare_headers(&tg->src_address, &tg->dst_address,\r\ntg->src_port, tg->dst_port,\r\n&tmp->ip_src, &tmp->ip_dst,\r\ntmp->th_sport, tmp->th_dport,\r\nCOMPARE_CURR_DIR)) {\r\ncount++;\r\n}\r\n}\r\nreturn count;\r\n}\r\nint\r\nget_num_acks(struct tcp_graph *tg, int *num_sack_ranges)\r\n{\r\nint count;\r\nstruct segment *tmp;\r\nfor (tmp = tg->segments, count=0; tmp; tmp = tmp->next) {\r\nif (!compare_headers(&tg->src_address, &tg->dst_address,\r\ntg->src_port, tg->dst_port,\r\n&tmp->ip_src, &tmp->ip_dst,\r\ntmp->th_sport, tmp->th_dport,\r\nCOMPARE_CURR_DIR)) {\r\ncount++;\r\n*num_sack_ranges += tmp->num_sack_ranges;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic gboolean\r\ntap_tcpip_packet(void *pct, packet_info *pinfo _U_, epan_dissect_t *edt _U_, const void *vip)\r\n{\r\nint n;\r\ngboolean is_unique = TRUE;\r\nth_t *th = (th_t *)pct;\r\nconst struct tcpheader *header = (const struct tcpheader *)vip;\r\nfor (n=0; n < th->num_hdrs; n++) {\r\nstruct tcpheader *stored = th->tcphdrs[n];\r\nif (compare_headers(&stored->ip_src, &stored->ip_dst,\r\nstored->th_sport, stored->th_dport,\r\n&header->ip_src, &header->ip_dst,\r\nheader->th_sport, stored->th_dport,\r\nCOMPARE_CURR_DIR))\r\n{\r\nis_unique = FALSE;\r\nbreak;\r\n}\r\n}\r\nif (is_unique && (th->num_hdrs < MAX_SUPPORTED_TCP_HEADERS)) {\r\nth->tcphdrs[th->num_hdrs] = (struct tcpheader *)g_malloc(sizeof(struct tcpheader));\r\n*(th->tcphdrs[th->num_hdrs]) = *header;\r\ncopy_address(&th->tcphdrs[th->num_hdrs]->ip_src, &header->ip_src);\r\ncopy_address(&th->tcphdrs[th->num_hdrs]->ip_dst, &header->ip_dst);\r\nth->num_hdrs++;\r\n}\r\nreturn FALSE;\r\n}\r\nstruct tcpheader *\r\nselect_tcpip_session(capture_file *cf, struct segment *hdrs)\r\n{\r\nframe_data *fdata;\r\nepan_dissect_t edt;\r\ndfilter_t *sfcode;\r\ngchar *err_msg;\r\nGString *error_string;\r\nnstime_t rel_ts;\r\nth_t th = {0, {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}};\r\nif (!cf || !hdrs)\r\nreturn NULL;\r\nfdata = cf->current_frame;\r\nif (!dfilter_compile("tcp", &sfcode, &err_msg)) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", err_msg);\r\ng_free(err_msg);\r\nreturn NULL;\r\n}\r\nif (!cf_read_record(cf, fdata))\r\nreturn NULL;\r\nerror_string=register_tap_listener("tcp", &th, NULL, 0, NULL, tap_tcpip_packet, NULL);\r\nif (error_string) {\r\nfprintf(stderr, "wireshark: Couldn't register tcp_graph tap: %s\n",\r\nerror_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\nepan_dissect_init(&edt, cf->epan, TRUE, FALSE);\r\nepan_dissect_prime_dfilter(&edt, sfcode);\r\nepan_dissect_run_with_taps(&edt, cf->cd_t, &cf->phdr, frame_tvbuff_new_buffer(fdata, &cf->buf), fdata, NULL);\r\nrel_ts = edt.pi.rel_ts;\r\nepan_dissect_cleanup(&edt);\r\nremove_tap_listener(&th);\r\nif (th.num_hdrs == 0) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Selected packet isn't a TCP segment or is truncated");\r\nreturn NULL;\r\n}\r\nif (th.num_hdrs > 1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"The selected packet has more than one TCP unique conversation "\r\n"in it.");\r\nreturn NULL;\r\n}\r\nhdrs->num = fdata->num;\r\nhdrs->rel_secs = (guint32) rel_ts.secs;\r\nhdrs->rel_usecs = rel_ts.nsecs/1000;\r\nhdrs->th_seq = th.tcphdrs[0]->th_seq;\r\nhdrs->th_ack = th.tcphdrs[0]->th_ack;\r\nhdrs->th_win = th.tcphdrs[0]->th_win;\r\nhdrs->th_flags = th.tcphdrs[0]->th_flags;\r\nhdrs->th_sport = th.tcphdrs[0]->th_sport;\r\nhdrs->th_dport = th.tcphdrs[0]->th_dport;\r\nhdrs->th_seglen = th.tcphdrs[0]->th_seglen;\r\ncopy_address(&hdrs->ip_src, &th.tcphdrs[0]->ip_src);\r\ncopy_address(&hdrs->ip_dst, &th.tcphdrs[0]->ip_dst);\r\nreturn th.tcphdrs[0];\r\n}\r\nint rtt_is_retrans(struct unack *list, unsigned int seqno)\r\n{\r\nstruct unack *u;\r\nfor (u=list; u; u=u->next) {\r\nif (u->seqno == seqno)\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstruct unack *rtt_get_new_unack(double time_val, unsigned int seqno)\r\n{\r\nstruct unack *u;\r\nu = (struct unack * )g_malloc(sizeof(struct unack));\r\nu->next = NULL;\r\nu->time = time_val;\r\nu->seqno = seqno;\r\nreturn u;\r\n}\r\nvoid rtt_put_unack_on_list(struct unack **l, struct unack *new_unack)\r\n{\r\nstruct unack *u, *list = *l;\r\nfor (u=list; u; u=u->next) {\r\nif (!u->next)\r\nbreak;\r\n}\r\nif (u)\r\nu->next = new_unack;\r\nelse\r\n*l = new_unack;\r\n}\r\nvoid rtt_delete_unack_from_list(struct unack **l, struct unack *dead)\r\n{\r\nstruct unack *u, *list = *l;\r\nif (!dead || !list)\r\nreturn;\r\nif (dead == list) {\r\n*l = list->next;\r\ng_free(list);\r\n} else {\r\nfor (u=list; u; u=u->next) {\r\nif (u->next == dead) {\r\nu->next = u->next->next;\r\ng_free(dead);\r\nbreak;\r\n}\r\n}\r\n}\r\n}
