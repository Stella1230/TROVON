static int ishex_str(const char* string, guint size)\r\n{\r\nchar_cond(g_ascii_isxdigit(*c));\r\n}\r\nstatic int isnum_str(const char* string, unsigned int size)\r\n{\r\nchar_cond( g_ascii_isdigit(*c) );\r\n}\r\nstatic int isalspec_str(const char* string, unsigned int size)\r\n{\r\nchar_cond(g_ascii_isalpha(*c) || g_ascii_isspace(*c) || g_ascii_ispunct(*c));\r\n}\r\nstatic int isalpha_str(const char* string, unsigned int size)\r\n{\r\nchar_cond( g_ascii_isalpha(*c));\r\n}\r\nstatic int isalnum_str(const char* string, unsigned int size)\r\n{\r\nchar_cond( g_ascii_isalnum(*c));\r\n}\r\nstatic int isalnumspec_str(const char* string, unsigned int size)\r\n{\r\nchar_cond(g_ascii_isalnum(*c) || g_ascii_isspace(*c) || g_ascii_ispunct(*c));\r\n}\r\nstatic int isnumspec_str(const char* string, unsigned int size)\r\n{\r\nchar_cond(g_ascii_isdigit(*c) || g_ascii_isspace(*c) || g_ascii_ispunct(*c));\r\n}\r\nstatic int isspec_str(const char* string, unsigned int size)\r\n{\r\nchar_cond(g_ascii_isspace(*c) || g_ascii_ispunct(*c));\r\n}\r\nstatic gboolean isstrtype_ok( int type, const char* string, unsigned int size)\r\n{\r\nswitch(type)\r\n{\r\ncase ISO_TA:\r\nreturn isalpha_str(string, size);\r\ncase ISO_TN:\r\nreturn isnum_str(string, size);\r\ncase ISO_TXN:\r\nreturn ishex_str(string, size);\r\ncase ISO_TS:\r\nreturn isspec_str(string, size);\r\ncase ISO_TAS:\r\nreturn isalspec_str(string, size);\r\ncase ISO_TAN:\r\nreturn isalnum_str(string, size);\r\ncase ISO_TANS:\r\nreturn isalnumspec_str(string, size);\r\ncase ISO_TNS:\r\nreturn isnumspec_str(string, size);\r\ncase ISO_TB:\r\nreturn ishex_str(string, size);\r\ncase ISO_TZ:\r\nif(charset_pref == ASCII_CHARSET)\r\nreturn isalnumspec_str(string, size);\r\nelse\r\nreturn ishex_str(string, size);\r\n}\r\nreturn 0;\r\n}\r\nstatic guint get_iso8583_msg_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nconst guint enc = (len_byte_order == BIGEND)?ENC_BIG_ENDIAN:ENC_LITTLE_ENDIAN;\r\niso8583_len = tvb_get_guint16(tvb, offset, enc) + 2;\r\nreturn iso8583_len;\r\n}\r\nstatic gchar* bin2hex(const guint8 *bin, enum bin2hex_enum type, guint32 len)\r\n{\r\ngchar* ret;\r\nguint8 ch;\r\nconst guint8* str = bin;\r\nguint32 size = len;\r\ngchar* buff;\r\nret = (gchar *)wmem_alloc(wmem_packet_scope(), size + 1);\r\nbuff = ret;\r\nif(type == TYPE_BCD)\r\n{\r\nif(size % 2)\r\n{\r\nch = *str & 0x0f;\r\n*buff = NIBBLE_2_ASCHEX(ch);\r\nstr++;\r\nsize--;\r\n}\r\nsize = len/=2;\r\n}\r\nwhile(size-- > 0)\r\n{\r\nch = (*str >> 4) & 0x0f;\r\n*buff = NIBBLE_2_ASCHEX(ch);\r\nch = *str & 0x0f;\r\n*buff = NIBBLE_2_ASCHEX(ch);\r\nstr++;\r\n}\r\n*buff = '\0';\r\nreturn ret;\r\n}\r\nstatic guint64 hex2bin(const char* hexstr, int len)\r\n{\r\nchar nibble;\r\nint i;\r\nguint64 bin= 0;\r\nfor(i=0; i< len && i<16; i++)\r\n{\r\nnibble = hexstr[i];\r\nbin <<= 4;\r\nif (g_ascii_isdigit(nibble))\r\nbin |= nibble - 48;\r\nelse\r\nbin |= g_ascii_toupper(nibble) - 55;\r\n}\r\nreturn bin;\r\n}\r\nstatic gchar *get_bit(guint ind, tvbuff_t *tvb, gint *off_set, proto_tree *tree, proto_item **exp, gint *length )\r\n{\r\ngchar aux[1024];\r\ngchar* ret=NULL;\r\ngint len;\r\ngint offset = *off_set;\r\ngboolean str_input = FALSE;\r\nif(data_array[ind].varlen == 0)\r\nlen = data_array[ind].maxsize;\r\nelse\r\n{\r\nlen = data_array[ind].varlen;\r\nswitch(charset_pref)\r\n{\r\ncase ASCII_CHARSET:\r\n{\r\ngchar* sizestr;\r\nchecksize(len);\r\nsizestr = (gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, offset,\r\nlen , ENC_ASCII);\r\nif(!isnum_str(sizestr,len))\r\n{\r\nreturn NULL;\r\n}\r\noffset+=len;\r\nlen = atoi(sizestr);\r\nbreak;\r\n}\r\ncase NUM_NIBBLE_CHARSET:\r\n{\r\ngint sizestr =0;\r\ngchar* tmp;\r\nif(len%2)\r\nlen++;\r\ntvb_memcpy(tvb, aux, offset, len);\r\ntmp = aux;\r\nchecksize((len/2));\r\noffset+=len/2;\r\nwhile(len > 0)\r\n{\r\nsizestr = sizestr*100 + (((guint8)(*tmp)>>4) & 0x0f)*10 +\r\n(((guint8)(*tmp)) & 0x0f);\r\nlen-=2;\r\ntmp++;\r\n}\r\nlen = sizestr;\r\nbreak;\r\n}\r\n}\r\n}\r\n*off_set = offset;\r\nif(len > 0)\r\n{\r\nif((guint)len > data_array[ind].maxsize)\r\nreturn NULL;\r\nif(data_array[ind].type == ISO_TN || data_array[ind].type == ISO_TXN)\r\n{\r\nif(charset_pref == ASCII_CHARSET)\r\n{\r\nchecksize(len);\r\nret = (gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, offset,\r\nlen , ENC_ASCII);\r\n*length = len;\r\n}\r\nelse if(charset_pref == NUM_NIBBLE_CHARSET)\r\n{\r\ngint tlen = (len%2)? len/2 + 1 : len/2;\r\nchecksize(tlen);\r\ntvb_memcpy(tvb, aux, offset, tlen);\r\nif((ret = bin2hex((guint8 *)aux, TYPE_BCD, len)) == NULL)\r\nreturn NULL;\r\n*length = (gint)strlen(ret);\r\nlen = tlen;\r\nstr_input = TRUE;\r\n}\r\n}\r\nelse if(data_array[ind].type == ISO_TB || data_array[ind].type == ISO_TZ)\r\n{\r\nif( bin_encode_pref == BIN_ASCII_ENC)\r\n{\r\nif(data_array[ind].type == ISO_TB)\r\nlen*=2;\r\n*length = len;\r\nchecksize(len);\r\nret = (gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, offset,\r\nlen, ENC_ASCII);\r\n}\r\nelse\r\n{\r\nchecksize(len);\r\ntvb_memcpy(tvb, aux, offset, len);\r\nif((ret = bin2hex((guint8 *)aux, TYPE_BIN, len)) == NULL)\r\nreturn NULL;\r\n*length = (gint)strlen(ret);\r\nstr_input = TRUE;\r\n}\r\n}\r\nelse\r\n{\r\nchecksize(len);\r\nret = (gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, offset,\r\nlen , ENC_ASCII);\r\n*length = len;\r\n}\r\nif(str_input && tree != NULL)\r\n*exp = proto_tree_add_string(tree, iso8583_data_bit[ind], tvb, offset, len, ret);\r\nelse if (tree != NULL)\r\n*exp = proto_tree_add_item(tree, iso8583_data_bit[ind], tvb,\r\noffset, len, ENC_ASCII);\r\n*off_set = offset + len;\r\n}\r\nelse\r\n{\r\n*length = 0;\r\nret = "";\r\n}\r\nreturn ret;\r\n}\r\nstatic int get_bitmap(tvbuff_t *tvb, guint64* bitmap, gint offset, gint* nbitmaps)\r\n{\r\ngchar* hexbit;\r\ngint i;\r\ngboolean isbreak = FALSE;\r\n*nbitmaps=0;\r\nfor(i=0; i<2; i++)\r\n{\r\nif(bin_encode_pref == BIN_BIN_ENC)\r\n{\r\nif((offset -2 + 8) > iso8583_len)\r\nreturn -1;\r\n(*nbitmaps)++;\r\nbitmap[i] = tvb_get_bits64(tvb, offset*8, 64, ENC_BIG_ENDIAN);\r\noffset+= BM_LEN;\r\n}\r\nelse\r\n{\r\ngint len = BM_LEN*2;\r\nif((offset -2 + len) > iso8583_len)\r\nreturn -1;\r\n(*nbitmaps)++;\r\nhexbit = (gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, len , ENC_ASCII);\r\noffset+= len;\r\nif(!ishex_str(hexbit, len))\r\nreturn 0;\r\nbitmap[i] = hex2bin(hexbit, len);\r\n}\r\nif(! (bitmap[i] & (((guint64)1) << 63)))\r\n{\r\nisbreak = TRUE;\r\nbreak;\r\n}\r\n}\r\nif(!isbreak)\r\n(*nbitmaps)++;\r\nreturn 0;\r\n}\r\nstatic int dissect_databits(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nint offset, int nofbitmaps, guint64 *bitmap)\r\n{\r\nproto_item *exp;\r\ngint nofbits = nofbitmaps*64, i;\r\nguint64 bit;\r\ngchar* cod;\r\ngint len;\r\nif(!pinfo)\r\nreturn 0;\r\nfor(i=0; i < nofbits; i++)\r\n{\r\nexp = NULL;\r\nbit = i%64;\r\nif( !bit)\r\ncontinue;\r\nif(bitmap[i/64] & (((guint64)1)<< (63 -bit)))\r\n{\r\ncod = get_bit(i, tvb, &offset, tree, &exp, &len);\r\nif(cod == NULL || ! isstrtype_ok(data_array[i].type, cod, len ))\r\n{\r\nif(!exp)\r\nexp = proto_tree_add_string(tree, iso8583_data_bit[i], tvb, offset, 0, "");\r\nexpert_add_info(pinfo, exp, &ei_iso8583_MALFORMED);\r\nreturn offset;\r\n}\r\nif( i == 2 || i == 69)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s. cod: %s", ((i==2)?"Proc":"Net"), cod);\r\ncontinue;\r\n}\r\nif(exp)\r\n{\r\n}\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int dissect_iso8583_msg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nproto_item *ti, *exp;\r\nproto_tree *iso8583_tree;\r\nguint offset = 0;\r\nint len = 0;\r\ngchar *msg_type, *msg_bitmap;\r\ngchar aux[24];\r\nguint64 bitmap[3]= {0,0,0};\r\nint nofbitmaps=0;\r\nguint ret;\r\nif (tvb_reported_length(tvb) < iso8583_MIN_LENGTH)\r\n{\r\nreturn 0;\r\n}\r\nif(charset_pref == ASCII_CHARSET)\r\n{\r\nlen = 4;\r\nmsg_type = (gchar*) tvb_get_string_enc(wmem_packet_scope(), tvb, 2, len, ENC_ASCII);\r\n}\r\nelse\r\n{\r\nlen = 2;\r\ntvb_memcpy(tvb, aux, 2, len);\r\nif((msg_type = bin2hex((guint8 *)aux, TYPE_BCD, len*2)) == NULL)\r\nreturn 0;\r\n}\r\nif(strlen(msg_type) == 4 && !isnum_str(msg_type,4))\r\n{\r\nreturn 0;\r\n}\r\nif(bin_encode_pref == BIN_BIN_ENC)\r\nmsg_bitmap = (gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, 6, BM_LEN*2 , ENC_ASCII);\r\nelse\r\n{\r\ntvb_memcpy(tvb, aux, 6, BM_LEN);\r\nif((msg_bitmap = bin2hex((guint8 *)aux, TYPE_BCD, BM_LEN)) == NULL)\r\nreturn 0;\r\n}\r\nif(strlen(msg_bitmap) == 16 && !ishex_str(msg_bitmap, BM_LEN*2))\r\n{\r\nreturn 0;\r\n}\r\nif(msg_type[0] == '0')\r\ndata_array = iso_1987;\r\nelse if (msg_type[0] == '1')\r\ndata_array = iso_1993;\r\nelse\r\n{\r\nreturn 0;\r\n}\r\ncol_clear(pinfo->cinfo, COL_PROTOCOL);\r\ncol_add_fstr(pinfo->cinfo, COL_PROTOCOL, "ISO 8583-1%s",\r\nval_to_str((guint)msg_type[0], packetversionnames, " Unknown VERSION"));\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Type %s - %s", msg_type,\r\nval_to_str((guint)msg_type[1], packettypenames, "Unknown type"));\r\nti = proto_tree_add_item(tree, proto_iso8583, tvb, 0, -1, ENC_NA);\r\nproto_item_append_text(ti, ": Type %s - %s", msg_type,\r\nval_to_str((guint)msg_type[1], packettypenames, "Unknown type"));\r\niso8583_tree = proto_item_add_subtree(ti, ett_iso8583);\r\nlen=2;\r\nproto_tree_add_item(iso8583_tree, hf_iso8583_len, tvb,\r\noffset, len, (len_byte_order == BIGEND)?ENC_BIG_ENDIAN:ENC_LITTLE_ENDIAN);\r\noffset += len;\r\nif(charset_pref == ASCII_CHARSET)\r\n{\r\nlen=4;\r\nproto_tree_add_item(iso8583_tree, hf_iso8583_mti, tvb,\r\noffset, len, ENC_ASCII | ENC_NA);\r\n}\r\nelse\r\n{\r\nlen=2;\r\nproto_tree_add_string(iso8583_tree, hf_iso8583_mti, tvb, offset, len, msg_type);\r\n}\r\noffset+=len;\r\nget_bitmap(tvb, bitmap, offset, &nofbitmaps);\r\nif(nofbitmaps == 0)\r\n{\r\nexpert_add_info(pinfo, ti, &ei_iso8583_MALFORMED);\r\nreturn offset;\r\n}\r\nif(bin_encode_pref == BIN_ASCII_ENC)\r\n{\r\nlen = BM_LEN*2;\r\nexp = proto_tree_add_item(iso8583_tree, hf_iso8583_bitmap1, tvb,\r\noffset, len, ENC_ASCII|ENC_NA);\r\nif(!ishex_str((gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, len , ENC_ASCII), len))\r\n{\r\nexpert_add_info(pinfo, exp, &ei_iso8583_MALFORMED);\r\nreturn offset + len;\r\n}\r\n}\r\nelse\r\n{\r\ngchar* hexstr;\r\nlen = BM_LEN;\r\nhexstr = tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, len);\r\nexp = proto_tree_add_string(iso8583_tree, hf_iso8583_bitmap1, tvb, offset, len, hexstr);\r\n}\r\noffset+=len;\r\nif(nofbitmaps > 1)\r\n{\r\nif(bin_encode_pref == BIN_ASCII_ENC)\r\n{\r\nexp = proto_tree_add_item(iso8583_tree, hf_iso8583_bitmap2, tvb,\r\noffset, len, ENC_ASCII|ENC_NA);\r\nif(!ishex_str((gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, len , ENC_ASCII), len))\r\n{\r\nexpert_add_info(pinfo, exp, &ei_iso8583_MALFORMED);\r\nreturn offset + len;\r\n}\r\n}\r\nelse\r\n{\r\ngchar* hexstr = tvb_bytes_to_str(wmem_packet_scope(), tvb, offset, len);\r\nexp = proto_tree_add_string(iso8583_tree, hf_iso8583_bitmap2, tvb, offset, len, hexstr);\r\n}\r\noffset+=len;\r\n}\r\nif(nofbitmaps > 2)\r\n{\r\nexpert_add_info(pinfo, exp, &ei_iso8583_MALFORMED);\r\nreturn offset;\r\n}\r\nret = dissect_databits(tvb, pinfo, iso8583_tree, offset, nofbitmaps, bitmap);\r\nreturn ret;\r\n}\r\nstatic int dissect_iso8583(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nvoid *data _U_)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, FRAME_HEADER_LEN, get_iso8583_msg_len, dissect_iso8583_msg, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_iso8583(void)\r\n{\r\nmodule_t *iso8583_module;\r\nexpert_module_t *expert_iso8583;\r\nint i;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_iso8583_len,\r\n{ "Message length", "iso8583.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Message length field", HFILL }\r\n},\r\n{ &hf_iso8583_mti,\r\n{ "MTI", "iso8583.mti",\r\nFT_STRING, STR_ASCII, NULL , 0,\r\n"Message Type Idicator (MTI)", HFILL }\r\n},\r\n{ &hf_iso8583_bitmap1,\r\n{ "Bitmap 1", "iso8583.map1",\r\nFT_STRING, STR_ASCII, NULL , 0,\r\n"First Bitmap (hex representation)", HFILL }\r\n},\r\n{ &hf_iso8583_bitmap2,\r\n{ "Bitmap 2", "iso8583.map2",\r\nFT_STRING, STR_ASCII, NULL , 0,\r\n"Second Bitmap (hex representation)", HFILL }\r\n}\r\n};\r\nstatic hf_register_info hf_data[128];\r\nstatic const char *hf_data_blurb[128] = {\r\n"Second Bit map present",\r\n"Primary account number (PAN)",\r\n"Processing code",\r\n"Amount, transaction",\r\n"Amount, settlement",\r\n"Amount, cardholder billing",\r\n"Transmission date &amp",\r\n"Amount, cardholder billing fee",\r\n"Conversion rate, settlement",\r\n"Conversion rate, cardholder billing",\r\n"System trace audit number",\r\n"Time, local transaction (hhmmss)",\r\n"Date, local transaction (MMDD)",\r\n"Date, expiration",\r\n"Date, settlement",\r\n"Date, conversion",\r\n"Date, capture",\r\n"Merchant type",\r\n"Acquiring institution country code",\r\n"PAN extended, country code",\r\n"Forwarding institution. country code",\r\n"Point of service entry mode",\r\n"Application PAN sequence number",\r\n"Function code (ISO 8583:1993)/Network International identifier (NII)",\r\n"Point of service condition code",\r\n"Point of service capture code",\r\n"Authorizing identification response length",\r\n"Amount, transaction fee",\r\n"Amount, settlement fee",\r\n"Amount, transaction processing fee",\r\n"Amount, settlement processing fee",\r\n"Acquiring institution identification code",\r\n"Forwarding institution identification code",\r\n"Primary account number, extended",\r\n"Track 2 data",\r\n"Track 3 data",\r\n"Retrieval reference number",\r\n"Authorization identification response",\r\n"Response code",\r\n"Service restriction code",\r\n"Card acceptor terminal identification",\r\n"Card acceptor identification code",\r\n"Card acceptor name/location (1-23 address 24-36 city 37-38 state 39-40 country)",\r\n"Additional response data",\r\n"Track 1 data",\r\n"Additional data - ISO",\r\n"Additional data - national",\r\n"Additional data - private",\r\n"Currency code, transaction",\r\n"Currency code, settlement",\r\n"Currency code, cardholder billing",\r\n"Personal identification number data",\r\n"Security related control information",\r\n"Additional amounts",\r\n"Reserved ISO",\r\n"Reserved ISO",\r\n"Reserved national",\r\n"Reserved national",\r\n"Reserved national",\r\n"Reserved national",\r\n"Reserved private",\r\n"Reserved private",\r\n"Reserved private",\r\n"Message authentication code (MAC)",\r\n"Third Bitmap, extended",\r\n"Settlement code",\r\n"Extended payment code",\r\n"Receiving institution country code",\r\n"Settlement institution country code",\r\n"Network management information code",\r\n"Message number",\r\n"Message number, last",\r\n"Date, action (YYMMDD)",\r\n"Credits, number",\r\n"Credits, reversal number",\r\n"Debits, number",\r\n"Debits, reversal number",\r\n"Transfer number",\r\n"Transfer, reversal number",\r\n"Inquiries number",\r\n"Authorizations, number",\r\n"Credits, processing fee amount",\r\n"Credits, transaction fee amount",\r\n"Debits, processing fee amount",\r\n"Debits, transaction fee amount",\r\n"Credits, amount",\r\n"Credits, reversal amount",\r\n"Debits, amount",\r\n"Debits, reversal amount",\r\n"Original data elements",\r\n"File update code",\r\n"File security code",\r\n"Response indicator",\r\n"Service indicator",\r\n"Replacement amounts",\r\n"Message security code",\r\n"Amount, net settlement",\r\n"Payee",\r\n"Settlement institution identification code",\r\n"Receiving institution identification code",\r\n"File name",\r\n"Account identification 1",\r\n"Account identification 2",\r\n"Transaction description",\r\n"Reserved for ISO use",\r\n"Reserved for ISO use",\r\n"Reserved for ISO use",\r\n"Reserved for ISO use",\r\n"Reserved for ISO use",\r\n"Reserved for ISO use",\r\n"Reserved for ISO use",\r\n"Reserved for national use",\r\n"Reserved for national use",\r\n"Reserved for national use",\r\n"Reserved for national use",\r\n"Reserved for national use",\r\n"Reserved for national use",\r\n"Reserved for national use",\r\n"Reserved for national use",\r\n"Reserved for private use",\r\n"Reserved for private use",\r\n"Reserved for private use",\r\n"Reserved for private use",\r\n"Reserved for private use",\r\n"Reserved for private use",\r\n"Reserved for private use",\r\n"Reserved for private use",\r\n"Message authentication code"\r\n};\r\nstatic gint *ett[] = {\r\n&ett_iso8583\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_iso8583_MALFORMED,\r\n{ "iso8583.MALFORMED", PI_MALFORMED, PI_ERROR,\r\n"MALFORMED", EXPFILL }\r\n}\r\n};\r\nproto_iso8583 = proto_register_protocol("ISO 8583-1", "ISO 8583", "iso8583");\r\nproto_register_field_array(proto_iso8583, hf, array_length(hf));\r\nfor (i = 0; i < 128; i++) {\r\nHFILL_INIT(hf_data[i]);\r\nhf_data[i].p_id = &iso8583_data_bit[i];\r\nhf_data[i].hfinfo.name = wmem_strdup_printf(wmem_epan_scope(), "Bit %d", i + 1);\r\nhf_data[i].hfinfo.abbrev = wmem_strdup_printf(wmem_epan_scope(), "iso8583.bit%d", i + 1);\r\nif(! i%64 )\r\n{\r\nhf_data[i].hfinfo.type = FT_BOOLEAN;\r\nhf_data[i].hfinfo.display = 8;\r\n}\r\nelse\r\n{\r\nhf_data[i].hfinfo.type = FT_STRING;\r\nhf_data[i].hfinfo.display = STR_ASCII;\r\n}\r\nhf_data[i].hfinfo.strings = NULL;\r\nhf_data[i].hfinfo.bitmask = 0;\r\nhf_data[i].hfinfo.blurb = hf_data_blurb[i];\r\n}\r\nproto_register_field_array(proto_iso8583, hf_data, array_length(hf_data));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_iso8583 = expert_register_protocol(proto_iso8583);\r\nexpert_register_field_array(expert_iso8583, ei, array_length(ei));\r\niso8583_module = prefs_register_protocol(proto_iso8583,\r\nproto_reg_handoff_iso8583);\r\nprefs_register_enum_preference(iso8583_module, "len_endian",\r\n"Length field endian",\r\n"Endian of the length field. Big endian or Little endian",\r\n&len_byte_order,\r\nenumendians, TRUE);\r\nprefs_register_uint_preference(iso8583_module, "tcp.port",\r\n"iso8583 TCP Port",\r\n" iso8583 TCP port",\r\n10, &tcp_port_pref);\r\nprefs_register_enum_preference(iso8583_module, "charset",\r\n"Charset for numbers",\r\n" charset for numbers",\r\n&charset_pref, enum_charset, TRUE);\r\nprefs_register_enum_preference(iso8583_module, "binencode",\r\n"Binary encode",\r\n" binary data representation",\r\n&bin_encode_pref, enum_bin_encode, TRUE);\r\n}\r\nvoid proto_reg_handoff_iso8583(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic dissector_handle_t iso8583_handle;\r\nstatic int current_port;\r\nif (!initialized) {\r\niso8583_handle = create_dissector_handle(dissect_iso8583,\r\nproto_iso8583);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", current_port, iso8583_handle);\r\n}\r\ncurrent_port = tcp_port_pref;\r\ndissector_add_uint("tcp.port", current_port, iso8583_handle);\r\n}
