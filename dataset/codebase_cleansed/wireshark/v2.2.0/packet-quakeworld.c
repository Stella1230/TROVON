static const char *\r\nCOM_Parse (const char *data)\r\n{\r\nint c;\r\nint len;\r\nlen = 0;\r\ncom_token[0] = '\0';\r\ncom_token_start = 0;\r\ncom_token_length = 0;\r\nif (data == NULL)\r\nreturn NULL;\r\nskipwhite:\r\nwhile (TRUE) {\r\nc = *data;\r\nif (c == '\0')\r\nreturn NULL;\r\nif ((c != ' ') && (!g_ascii_iscntrl(c)))\r\nbreak;\r\ndata++;\r\ncom_token_start++;\r\n}\r\nif ((c=='/') && (data[1]=='/')) {\r\nwhile (*data && *data != '\n'){\r\ndata++;\r\ncom_token_start++;\r\n}\r\ngoto skipwhite;\r\n}\r\nif (c == '\"') {\r\ndata++;\r\ncom_token_start++;\r\nwhile (TRUE) {\r\nc = *data++;\r\nif ((c=='\"') || (c=='\0')) {\r\ncom_token[len] = '\0';\r\nreturn data;\r\n}\r\ncom_token[len] = c;\r\nlen++;\r\ncom_token_length++;\r\n}\r\n}\r\ndo {\r\ncom_token[len] = c;\r\ndata++;\r\nlen++;\r\ncom_token_length++;\r\nc = *data;\r\n} while (( c != ' ') && (!g_ascii_iscntrl(c)));\r\ncom_token[len] = '\0';\r\nreturn data;\r\n}\r\nstatic int\r\nCmd_Argc(void)\r\n{\r\nreturn cmd_argc;\r\n}\r\nstatic const char*\r\nCmd_Argv(int arg)\r\n{\r\nif ( arg >= cmd_argc )\r\nreturn cmd_null_string;\r\nreturn cmd_argv[arg];\r\n}\r\nstatic int\r\nCmd_Argv_start(int arg)\r\n{\r\nif ( arg >= cmd_argc )\r\nreturn 0;\r\nreturn cmd_argv_start[arg];\r\n}\r\nstatic int\r\nCmd_Argv_length(int arg)\r\n{\r\nif ( arg >= cmd_argc )\r\nreturn 0;\r\nreturn cmd_argv_length[arg];\r\n}\r\nstatic void\r\nCmd_TokenizeString(const char* text)\r\n{\r\nint start;\r\ncmd_argc = 0;\r\nstart = 0;\r\nwhile (TRUE) {\r\nwhile (*text && *text <= ' ' && *text != '\n') {\r\ntext++;\r\nstart++;\r\n}\r\nif (*text == '\n') {\r\ntext++;\r\nbreak;\r\n}\r\nif (!*text)\r\nreturn;\r\ntext = COM_Parse (text);\r\nif (!text)\r\nreturn;\r\nif (cmd_argc < MAX_ARGS) {\r\ncmd_argv[cmd_argc] = wmem_strdup(wmem_packet_scope(), com_token);\r\ncmd_argv_start[cmd_argc] = start + com_token_start;\r\ncmd_argv_length[cmd_argc] = com_token_length;\r\ncmd_argc++;\r\n}\r\nstart += com_token_start + com_token_length;\r\n}\r\n}\r\nstatic void\r\ndissect_id_infostring(tvbuff_t *tvb, proto_tree* tree,\r\nint offset, char* infostring,\r\ngint ett_key_value, int hf_key_value, int hf_key, int hf_value)\r\n{\r\nchar *newpos = infostring;\r\ngboolean end_of_info = FALSE;\r\nwhile(!end_of_info) {\r\nchar* keypos;\r\nchar* valuepos;\r\nint keylength;\r\nchar* keyvaluesep;\r\nint valuelength;\r\nchar* valueend;\r\nkeypos = newpos;\r\nif (*keypos == '\0') break;\r\nif (*keypos == '\\') keypos++;\r\nfor (keylength = 0\r\n;\r\n*(keypos + keylength) != '\\' &&\r\n*(keypos + keylength) != '\0'\r\n;\r\nkeylength++) ;\r\nkeyvaluesep = keypos + keylength;\r\nif (*keyvaluesep == '\0') break;\r\nvaluepos = keyvaluesep+1;\r\nfor (valuelength = 0\r\n;\r\n*(valuepos + valuelength) != '\\' &&\r\n*(valuepos + valuelength) != '\0'\r\n;\r\nvaluelength++) ;\r\nvalueend = valuepos + valuelength;\r\nif (*valueend == '\0') {\r\nend_of_info = TRUE;\r\n}\r\n*(keyvaluesep) = '=';\r\n*(valueend) = '\0';\r\nif (tree) {\r\nproto_item* sub_item;\r\nproto_tree* sub_tree;\r\nsub_item = proto_tree_add_string(tree,\r\nhf_key_value,\r\ntvb,\r\noffset + (gint)(keypos-infostring),\r\nkeylength + 1 + valuelength, keypos);\r\nsub_tree = proto_item_add_subtree(\r\nsub_item,\r\nett_key_value);\r\n*(keyvaluesep) = '\0';\r\nproto_tree_add_string(sub_tree,\r\nhf_key,\r\ntvb,\r\noffset + (gint)(keypos-infostring),\r\nkeylength, keypos);\r\nproto_tree_add_string(sub_tree,\r\nhf_value,\r\ntvb,\r\noffset + (gint)(valuepos-infostring),\r\nvaluelength, valuepos);\r\n}\r\nnewpos = valueend + 1;\r\n}\r\n}\r\nstatic void\r\ndissect_quakeworld_ConnectionlessPacket(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, int direction)\r\n{\r\nproto_tree *cl_tree;\r\nproto_tree *text_tree = NULL;\r\nguint8 *text;\r\nint len;\r\nint offset;\r\nguint32 marker;\r\nint command_len;\r\nconst char *command = "";\r\ngboolean command_finished = FALSE;\r\nmarker = tvb_get_ntohl(tvb, 0);\r\ncl_tree = proto_tree_add_subtree(tree, tvb, 0, -1, ett_quakeworld_connectionless, NULL, "Connectionless");\r\nproto_tree_add_uint(cl_tree, hf_quakeworld_connectionless_marker,\r\ntvb, 0, 4, marker);\r\noffset = 4;\r\ntext = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &len, ENC_ASCII|ENC_NA);\r\nif (cl_tree) {\r\nproto_item *text_item;\r\ntext_item = proto_tree_add_string(cl_tree, hf_quakeworld_connectionless_text,\r\ntvb, offset, len, text);\r\ntext_tree = proto_item_add_subtree(text_item, ett_quakeworld_connectionless_text);\r\n}\r\nif (direction == DIR_C2S) {\r\nconst char *c;\r\nCmd_TokenizeString(text);\r\nc = Cmd_Argv(0);\r\nif (strcmp(c,"ping") == 0) {\r\ncommand = "Ping";\r\ncommand_len = 4;\r\n} else if (strcmp(c,"status") == 0) {\r\ncommand = "Status";\r\ncommand_len = 6;\r\n} else if (strcmp(c,"log") == 0) {\r\ncommand = "Log";\r\ncommand_len = 3;\r\n} else if (strcmp(c,"connect") == 0) {\r\nint version;\r\nint qport;\r\nint challenge;\r\nconst char *infostring;\r\nproto_tree *argument_tree = NULL;\r\ncommand = "Connect";\r\ncommand_len = Cmd_Argv_length(0);\r\nif (text_tree) {\r\nproto_item *argument_item;\r\nproto_tree_add_string(text_tree, hf_quakeworld_connectionless_command,\r\ntvb, offset, command_len, command);\r\nargument_item = proto_tree_add_string(text_tree,\r\nhf_quakeworld_connectionless_arguments,\r\ntvb, offset + Cmd_Argv_start(1), len + 1 - Cmd_Argv_start(1),\r\ntext + Cmd_Argv_start(1));\r\nargument_tree = proto_item_add_subtree(argument_item,\r\nett_quakeworld_connectionless_arguments);\r\ncommand_finished=TRUE;\r\n}\r\nversion = atoi(Cmd_Argv(1));\r\nqport = atoi(Cmd_Argv(2));\r\nchallenge = atoi(Cmd_Argv(3));\r\ninfostring = Cmd_Argv(4);\r\nif (argument_tree) {\r\nproto_item *info_item;\r\nproto_tree *info_tree;\r\nproto_tree_add_uint(argument_tree,\r\nhf_quakeworld_connectionless_connect_version,\r\ntvb,\r\noffset + Cmd_Argv_start(1),\r\nCmd_Argv_length(1), version);\r\nproto_tree_add_uint(argument_tree,\r\nhf_quakeworld_connectionless_connect_qport,\r\ntvb,\r\noffset + Cmd_Argv_start(2),\r\nCmd_Argv_length(2), qport);\r\nproto_tree_add_int(argument_tree,\r\nhf_quakeworld_connectionless_connect_challenge,\r\ntvb,\r\noffset + Cmd_Argv_start(3),\r\nCmd_Argv_length(3), challenge);\r\ninfo_item = proto_tree_add_string(argument_tree,\r\nhf_quakeworld_connectionless_connect_infostring,\r\ntvb,\r\noffset + Cmd_Argv_start(4),\r\nCmd_Argv_length(4), infostring);\r\ninfo_tree = proto_item_add_subtree(\r\ninfo_item, ett_quakeworld_connectionless_connect_infostring);\r\ndissect_id_infostring(tvb, info_tree, offset + Cmd_Argv_start(4),\r\nwmem_strdup(wmem_packet_scope(), infostring),\r\nett_quakeworld_connectionless_connect_infostring_key_value,\r\nhf_quakeworld_connectionless_connect_infostring_key_value,\r\nhf_quakeworld_connectionless_connect_infostring_key,\r\nhf_quakeworld_connectionless_connect_infostring_value);\r\n}\r\n} else if (strcmp(c,"getchallenge") == 0) {\r\ncommand = "Get Challenge";\r\ncommand_len = Cmd_Argv_length(0);\r\n} else if (strcmp(c,"rcon") == 0) {\r\nconst char* password;\r\nint i;\r\nchar remaining[MAX_TEXT_SIZE+1];\r\nproto_tree *argument_tree = NULL;\r\ncommand = "Remote Command";\r\ncommand_len = Cmd_Argv_length(0);\r\nif (text_tree) {\r\nproto_item *argument_item;\r\nproto_tree_add_string(text_tree, hf_quakeworld_connectionless_command,\r\ntvb, offset, command_len, command);\r\nargument_item = proto_tree_add_string(text_tree,\r\nhf_quakeworld_connectionless_arguments,\r\ntvb, offset + Cmd_Argv_start(1), len - Cmd_Argv_start(1),\r\ntext + Cmd_Argv_start(1));\r\nargument_tree = proto_item_add_subtree(argument_item,\r\nett_quakeworld_connectionless_arguments);\r\ncommand_finished=TRUE;\r\n}\r\npassword = Cmd_Argv(1);\r\nif (argument_tree) {\r\nproto_tree_add_string(argument_tree,\r\nhf_quakeworld_connectionless_rcon_password,\r\ntvb,\r\noffset + Cmd_Argv_start(1),\r\nCmd_Argv_length(1), password);\r\n}\r\nremaining[0] = '\0';\r\nfor (i=2; i<Cmd_Argc() ; i++) {\r\ng_strlcat (remaining, Cmd_Argv(i), MAX_TEXT_SIZE+1);\r\ng_strlcat (remaining, " ", MAX_TEXT_SIZE+1);\r\n}\r\nif (text_tree) {\r\nproto_tree_add_string(argument_tree,\r\nhf_quakeworld_connectionless_rcon_command,\r\ntvb, offset + Cmd_Argv_start(2),\r\nCmd_Argv_start(Cmd_Argc()-1) + Cmd_Argv_length(Cmd_Argc()-1) -\r\nCmd_Argv_start(2),\r\nremaining);\r\n}\r\n} else if (c[0]==A2A_PING && ( c[1]=='\0' || c[1]=='\n')) {\r\ncommand = "Ping";\r\ncommand_len = 1;\r\n} else if (c[0]==A2A_ACK && ( c[1]=='\0' || c[1]=='\n')) {\r\ncommand = "Ack";\r\ncommand_len = 1;\r\n} else {\r\ncommand = "Unknown";\r\ncommand_len = len - 1;\r\n}\r\n}\r\nelse {\r\nif (text[0] == S2C_CONNECTION) {\r\ncommand = "Connected";\r\ncommand_len = 1;\r\n} else if (text[0] == A2C_CLIENT_COMMAND) {\r\ncommand = "Client Command";\r\ncommand_len = 1;\r\n} else if (text[0] == A2C_PRINT) {\r\ncommand = "Print";\r\ncommand_len = 1;\r\n} else if (text[0] == A2A_PING) {\r\ncommand = "Ping";\r\ncommand_len = 1;\r\n} else if (text[0] == S2C_CHALLENGE) {\r\ncommand = "Challenge";\r\ncommand_len = 1;\r\n} else {\r\ncommand = "Unknown";\r\ncommand_len = len - 1;\r\n}\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s", command);\r\nif (!command_finished) {\r\nproto_tree_add_string(text_tree, hf_quakeworld_connectionless_command,\r\ntvb, offset, command_len, command);\r\n}\r\n}\r\nstatic void\r\ndissect_quakeworld_client_commands(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\ncall_data_dissector(tvb, pinfo, tree);\r\n}\r\nstatic void\r\ndissect_quakeworld_server_commands(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree)\r\n{\r\ncall_data_dissector(tvb, pinfo, tree);\r\n}\r\nstatic void\r\ndissect_quakeworld_GamePacket(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, int direction)\r\n{\r\nproto_tree *game_tree = NULL;\r\nguint32 seq1;\r\nguint32 seq2;\r\nint rel1;\r\nint rel2;\r\nint offset;\r\nguint rest_length;\r\ndirection = (pinfo->destport == gbl_quakeworldServerPort) ?\r\nDIR_C2S : DIR_S2C;\r\ngame_tree = proto_tree_add_subtree(tree, tvb, 0, -1, ett_quakeworld_game, NULL, "Game");\r\noffset = 0;\r\nseq1 = tvb_get_letohl(tvb, offset);\r\nrel1 = seq1 & 0x80000000 ? 1 : 0;\r\nseq1 &= ~0x80000000;\r\nif (game_tree) {\r\nproto_tree *seq1_tree = proto_tree_add_subtree_format(game_tree,\r\ntvb, offset, 4, ett_quakeworld_game_seq1, NULL, "Current Sequence: %u (%s)",\r\nseq1, val_to_str(rel1,names_reliable,"%u"));\r\nproto_tree_add_uint(seq1_tree, hf_quakeworld_game_seq1,\r\ntvb, offset, 4, seq1);\r\nproto_tree_add_boolean(seq1_tree, hf_quakeworld_game_rel1,\r\ntvb, offset+3, 1, rel1);\r\n}\r\noffset += 4;\r\nseq2 = tvb_get_letohl(tvb, offset);\r\nrel2 = seq2 & 0x80000000 ? 1 : 0;\r\nseq2 &= ~0x80000000;\r\nif (game_tree) {\r\nproto_tree *seq2_tree = proto_tree_add_subtree_format(game_tree,\r\ntvb, offset, 4, ett_quakeworld_game_seq2, NULL, "Acknowledge Sequence: %u (%s)",\r\nseq2, val_to_str(rel2,names_reliable,"%u"));\r\nproto_tree_add_uint(seq2_tree, hf_quakeworld_game_seq2, tvb, offset, 4, seq2);\r\nproto_tree_add_boolean(seq2_tree, hf_quakeworld_game_rel2, tvb, offset+3, 1, rel2);\r\n}\r\noffset += 4;\r\nif (direction == DIR_C2S) {\r\nguint16 qport = tvb_get_letohs(tvb, offset);\r\nif (game_tree) {\r\nproto_tree_add_uint(game_tree, hf_quakeworld_game_qport, tvb, offset, 2, qport);\r\n}\r\noffset +=2;\r\n}\r\nrest_length = tvb_reported_length(tvb) - offset;\r\nif (rest_length) {\r\ntvbuff_t *next_tvb = tvb_new_subset_remaining(tvb, offset);\r\nproto_tree *c_tree;\r\nif (direction == DIR_C2S) {\r\nc_tree = proto_tree_add_subtree(game_tree, next_tvb,\r\n0, -1, ett_quakeworld_game_clc, NULL, "Client Commands");\r\ndissect_quakeworld_client_commands(next_tvb, pinfo, c_tree);\r\n}\r\nelse {\r\nc_tree = proto_tree_add_subtree(game_tree, next_tvb,\r\n0, -1, ett_quakeworld_game_svc, NULL, "Server Commands");\r\ndissect_quakeworld_server_commands(next_tvb, pinfo, c_tree);\r\n}\r\n}\r\n}\r\nstatic int\r\ndissect_quakeworld(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *quakeworld_tree = NULL;\r\nint direction;\r\ndirection = (pinfo->destport == gbl_quakeworldServerPort) ?\r\nDIR_C2S : DIR_S2C;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "QUAKEWORLD");\r\ncol_add_str(pinfo->cinfo, COL_INFO, val_to_str(direction,\r\nnames_direction, "%u"));\r\nif (tree) {\r\nproto_item *quakeworld_item;\r\nquakeworld_item = proto_tree_add_item(tree, proto_quakeworld,\r\ntvb, 0, -1, ENC_NA);\r\nquakeworld_tree = proto_item_add_subtree(quakeworld_item, ett_quakeworld);\r\nproto_tree_add_uint_format(quakeworld_tree,\r\ndirection == DIR_S2C ?\r\nhf_quakeworld_s2c :\r\nhf_quakeworld_c2s,\r\ntvb, 0, 0, 1,\r\n"Direction: %s", val_to_str(direction, names_direction, "%u"));\r\n}\r\nif (tvb_get_ntohl(tvb, 0) == 0xffffffff) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Connectionless");\r\nproto_tree_add_uint_format(quakeworld_tree,\r\nhf_quakeworld_connectionless,\r\ntvb, 0, 0, 1,\r\n"Type: Connectionless");\r\ndissect_quakeworld_ConnectionlessPacket(\r\ntvb, pinfo, quakeworld_tree, direction);\r\n}\r\nelse {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Game");\r\nproto_tree_add_uint_format(quakeworld_tree,\r\nhf_quakeworld_game,\r\ntvb, 0, 0, 1,\r\n"Type: Game");\r\ndissect_quakeworld_GamePacket(\r\ntvb, pinfo, quakeworld_tree, direction);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_quakeworld(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_quakeworld_c2s,\r\n{ "Client to Server", "quakeworld.c2s",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quakeworld_s2c,\r\n{ "Server to Client", "quakeworld.s2c",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quakeworld_connectionless,\r\n{ "Connectionless", "quakeworld.connectionless",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quakeworld_game,\r\n{ "Game", "quakeworld.game",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quakeworld_connectionless_marker,\r\n{ "Marker", "quakeworld.connectionless.marker",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quakeworld_connectionless_text,\r\n{ "Text", "quakeworld.connectionless.text",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quakeworld_connectionless_command,\r\n{ "Command", "quakeworld.connectionless.command",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quakeworld_connectionless_arguments,\r\n{ "Arguments", "quakeworld.connectionless.arguments",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quakeworld_connectionless_connect_version,\r\n{ "Version", "quakeworld.connectionless.connect.version",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Protocol Version", HFILL }},\r\n{ &hf_quakeworld_connectionless_connect_qport,\r\n{ "QPort", "quakeworld.connectionless.connect.qport",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"QPort of the client", HFILL }},\r\n{ &hf_quakeworld_connectionless_connect_challenge,\r\n{ "Challenge", "quakeworld.connectionless.connect.challenge",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\n"Challenge from the server", HFILL }},\r\n{ &hf_quakeworld_connectionless_connect_infostring,\r\n{ "Infostring", "quakeworld.connectionless.connect.infostring",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Infostring with additional variables", HFILL }},\r\n{ &hf_quakeworld_connectionless_connect_infostring_key_value,\r\n{ "Key/Value", "quakeworld.connectionless.connect.infostring.key_value",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Key and Value", HFILL }},\r\n{ &hf_quakeworld_connectionless_connect_infostring_key,\r\n{ "Key", "quakeworld.connectionless.connect.infostring.key",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Infostring Key", HFILL }},\r\n{ &hf_quakeworld_connectionless_connect_infostring_value,\r\n{ "Value", "quakeworld.connectionless.connect.infostring.value",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Infostring Value", HFILL }},\r\n{ &hf_quakeworld_connectionless_rcon_password,\r\n{ "Password", "quakeworld.connectionless.rcon.password",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Rcon Password", HFILL }},\r\n{ &hf_quakeworld_connectionless_rcon_command,\r\n{ "Command", "quakeworld.connectionless.rcon.command",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_quakeworld_game_seq1,\r\n{ "Sequence Number", "quakeworld.game.seq1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Sequence number of the current packet", HFILL }},\r\n{ &hf_quakeworld_game_rel1,\r\n{ "Reliable", "quakeworld.game.rel1",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Packet is reliable and may be retransmitted", HFILL }},\r\n{ &hf_quakeworld_game_seq2,\r\n{ "Sequence Number", "quakeworld.game.seq2",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Sequence number of the last received packet", HFILL }},\r\n{ &hf_quakeworld_game_rel2,\r\n{ "Reliable", "quakeworld.game.rel2",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Packet was reliable and may be retransmitted", HFILL }},\r\n{ &hf_quakeworld_game_qport,\r\n{ "QPort", "quakeworld.game.qport",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"QuakeWorld Client Port", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_quakeworld,\r\n&ett_quakeworld_connectionless,\r\n&ett_quakeworld_connectionless_text,\r\n&ett_quakeworld_connectionless_arguments,\r\n&ett_quakeworld_connectionless_connect_infostring,\r\n&ett_quakeworld_connectionless_connect_infostring_key_value,\r\n&ett_quakeworld_game,\r\n&ett_quakeworld_game_seq1,\r\n&ett_quakeworld_game_seq2,\r\n&ett_quakeworld_game_clc,\r\n&ett_quakeworld_game_svc\r\n};\r\nmodule_t *quakeworld_module;\r\nproto_quakeworld = proto_register_protocol("QuakeWorld Network Protocol",\r\n"QUAKEWORLD", "quakeworld");\r\nproto_register_field_array(proto_quakeworld, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nquakeworld_module = prefs_register_protocol(proto_quakeworld,\r\nproto_reg_handoff_quakeworld);\r\nprefs_register_uint_preference(quakeworld_module, "udp.port",\r\n"QuakeWorld Server UDP Port",\r\n"Set the UDP port for the QuakeWorld Server",\r\n10, &gbl_quakeworldServerPort);\r\n}\r\nvoid\r\nproto_reg_handoff_quakeworld(void)\r\n{\r\nstatic gboolean Initialized=FALSE;\r\nstatic dissector_handle_t quakeworld_handle;\r\nstatic guint ServerPort;\r\nif (!Initialized) {\r\nquakeworld_handle = create_dissector_handle(dissect_quakeworld,\r\nproto_quakeworld);\r\nInitialized=TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", ServerPort, quakeworld_handle);\r\n}\r\nServerPort=gbl_quakeworldServerPort;\r\ndissector_add_uint("udp.port", gbl_quakeworldServerPort, quakeworld_handle);\r\n}
