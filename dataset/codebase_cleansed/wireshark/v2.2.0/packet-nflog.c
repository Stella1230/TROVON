static int\r\ndissect_nflog(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nconst int start_tlv_offset = 4;\r\nproto_tree *nflog_tree = NULL;\r\nproto_item *ti;\r\nint offset = 0;\r\ntvbuff_t *next_tvb = NULL;\r\nint aftype;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NFLOG");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\naftype = tvb_get_guint8(tvb, 0);\r\nif (proto_field_is_referenced(tree, hfi_nflog->id)) {\r\nti = proto_tree_add_item(tree, hfi_nflog, tvb, 0, -1, ENC_NA);\r\nnflog_tree = proto_item_add_subtree(ti, ett_nflog);\r\nproto_tree_add_item(nflog_tree, &hfi_nflog_family, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(nflog_tree, &hfi_nflog_version, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(nflog_tree, &hfi_nflog_resid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\noffset = start_tlv_offset;\r\nwhile (tvb_reported_length_remaining(tvb, offset) >= 4) {\r\nguint16 tlv_len = tvb_get_h_guint16(tvb, offset + 0);\r\nguint16 tlv_type;\r\nguint16 value_len;\r\nproto_tree *tlv_tree;\r\nif (tlv_len < 4)\r\nreturn offset;\r\nvalue_len = tlv_len - 4;\r\ntlv_type = (tvb_get_h_guint16(tvb, offset + 2) & 0x7fff);\r\nif (nflog_tree) {\r\ngboolean handled = FALSE;\r\nti = proto_tree_add_bytes_format(nflog_tree, hfi_nflog_tlv.id,\r\ntvb, offset, tlv_len, NULL,\r\n"TLV Type: %s (%u), Length: %u",\r\nval_to_str_const(tlv_type, nflog_tlv_vals, "Unknown"),\r\ntlv_type, tlv_len);\r\ntlv_tree = proto_item_add_subtree(ti, ett_nflog_tlv);\r\nproto_tree_add_item(tlv_tree, &hfi_nflog_tlv_length, tvb, offset + 0, 2, ENC_HOST_ENDIAN);\r\nproto_tree_add_item(tlv_tree, &hfi_nflog_tlv_type, tvb, offset + 2, 2, ENC_HOST_ENDIAN);\r\nswitch (tlv_type) {\r\ncase WS_NFULA_PAYLOAD:\r\nhandled = TRUE;\r\nbreak;\r\ncase WS_NFULA_PREFIX:\r\nif (value_len >= 1) {\r\nproto_tree_add_item(tlv_tree, &hfi_nflog_tlv_prefix,\r\ntvb, offset + 4, value_len, ENC_NA);\r\nhandled = TRUE;\r\n}\r\nbreak;\r\ncase WS_NFULA_UID:\r\nif (value_len == 4) {\r\nproto_tree_add_item(tlv_tree, &hfi_nflog_tlv_uid,\r\ntvb, offset + 4, value_len, ENC_BIG_ENDIAN);\r\nhandled = TRUE;\r\n}\r\nbreak;\r\ncase WS_NFULA_GID:\r\nif (value_len == 4) {\r\nproto_tree_add_item(tlv_tree, &hfi_nflog_tlv_gid,\r\ntvb, offset + 4, value_len, ENC_BIG_ENDIAN);\r\nhandled = TRUE;\r\n}\r\nbreak;\r\ncase WS_NFULA_TIMESTAMP:\r\nif (value_len == 16) {\r\nnstime_t ts;\r\nts.secs = (time_t)tvb_get_ntoh64(tvb, offset + 4);\r\nts.nsecs = (int)tvb_get_ntoh64(tvb, offset + 12);\r\nproto_tree_add_time(tlv_tree, &hfi_nflog_tlv_timestamp,\r\ntvb, offset + 4, value_len, &ts);\r\nhandled = TRUE;\r\n}\r\nbreak;\r\n}\r\nif (!handled)\r\nproto_tree_add_item(tlv_tree, &hfi_nflog_tlv_unknown,\r\ntvb, offset + 4, value_len, ENC_NA);\r\n}\r\nif (tlv_type == WS_NFULA_PAYLOAD)\r\nnext_tvb = tvb_new_subset_length(tvb, offset + 4, value_len);\r\noffset += ((tlv_len + 3) & ~3);\r\n}\r\nif (next_tvb) {\r\nswitch (aftype) {\r\ncase LINUX_AF_INET:\r\ncall_dissector(ip_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ncase LINUX_AF_INET6:\r\ncall_dissector(ip6_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\nbreak;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_nflog(void)\r\n{\r\n#ifndef HAVE_HFI_SECTION_INIT\r\nstatic header_field_info *hfi[] = {\r\n&hfi_nflog_family,\r\n&hfi_nflog_version,\r\n&hfi_nflog_resid,\r\n&hfi_nflog_tlv,\r\n&hfi_nflog_tlv_length,\r\n&hfi_nflog_tlv_type,\r\n&hfi_nflog_tlv_prefix,\r\n&hfi_nflog_tlv_uid,\r\n&hfi_nflog_tlv_gid,\r\n&hfi_nflog_tlv_timestamp,\r\n&hfi_nflog_tlv_unknown,\r\n};\r\n#endif\r\nstatic gint *ett[] = {\r\n&ett_nflog,\r\n&ett_nflog_tlv\r\n};\r\nint proto_nflog;\r\nproto_nflog = proto_register_protocol("Linux Netfilter NFLOG", "NFLOG", "nflog");\r\nhfi_nflog = proto_registrar_get_nth(proto_nflog);\r\nregister_dissector("nflog", dissect_nflog, proto_nflog);\r\nproto_register_fields(proto_nflog, hfi, array_length(hfi));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_nflog(void)\r\n{\r\ndissector_handle_t nflog_handle;\r\nip_handle = find_dissector_add_dependency("ip", hfi_nflog->id);\r\nip6_handle = find_dissector_add_dependency("ipv6", hfi_nflog->id);\r\nnflog_handle = find_dissector("nflog");\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_NFLOG, nflog_handle);\r\n}
