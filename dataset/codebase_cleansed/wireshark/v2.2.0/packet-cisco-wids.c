static int\r\ndissect_cwids(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ntvbuff_t *wlan_tvb;\r\nproto_tree *ti, *cwids_tree;\r\nvolatile int offset = 0;\r\nguint16 capturelen;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CWIDS");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Cwids: ");\r\ncwids_tree = NULL;\r\nwhile(tvb_reported_length_remaining(tvb, offset) > 0) {\r\nstruct ieee_802_11_phdr phdr;\r\nti = proto_tree_add_item(tree, proto_cwids, tvb, offset, 28, ENC_NA);\r\ncwids_tree = proto_item_add_subtree(ti, ett_cwids);\r\nmemset(&phdr, 0, sizeof(phdr));\r\nphdr.fcs_len = 0;\r\nphdr.decrypted = FALSE;\r\nphdr.datapad = FALSE;\r\nphdr.phy = PHDR_802_11_PHY_UNKNOWN;\r\nproto_tree_add_item(cwids_tree, hf_cwids_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cwids_tree, hf_cwids_timestamp, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(cwids_tree, hf_cwids_unknown1, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nphdr.has_channel = TRUE;\r\nphdr.channel = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(cwids_tree, hf_cwids_channel, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(cwids_tree, hf_cwids_unknown2, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(cwids_tree, hf_cwids_reallength, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\ncapturelen = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(cwids_tree, hf_cwids_capturelen, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cwids_tree, hf_cwids_unknown3, tvb, offset, 8, ENC_NA);\r\noffset += 8;\r\nwlan_tvb = tvb_new_subset_length(tvb, offset, capturelen);\r\nTRY {\r\ncall_dissector_with_data(ieee80211_radio_handle, wlan_tvb, pinfo, tree, &phdr);\r\n} CATCH_BOUNDS_ERRORS {\r\nshow_exception(wlan_tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);\r\nexpert_add_info(pinfo, ti, &ie_ieee80211_subpacket);\r\n} ENDTRY;\r\noffset += capturelen;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_cwids(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_cwids_version,\r\n{ "Capture Version", "cwids.version", FT_UINT16, BASE_DEC, NULL,\r\n0x0, "Version or format of record", HFILL }},\r\n{ &hf_cwids_timestamp,\r\n{ "Timestamp [us]", "cwids.timestamp", FT_BYTES, BASE_NONE, NULL,\r\n0x0, NULL, HFILL }},\r\n{ &hf_cwids_unknown1,\r\n{ "Unknown1", "cwids.unknown1", FT_BYTES, BASE_NONE, NULL,\r\n0x0, "1st Unknown block", HFILL }},\r\n{ &hf_cwids_channel,\r\n{ "Channel", "cwids.channel", FT_UINT8, BASE_DEC, NULL,\r\n0x0, "Channel for this capture", HFILL }},\r\n{ &hf_cwids_unknown2,\r\n{ "Unknown2", "cwids.unknown2", FT_BYTES, BASE_NONE, NULL,\r\n0x0, "2nd Unknown block", HFILL }},\r\n{ &hf_cwids_reallength,\r\n{ "Original length", "cwids.reallen", FT_UINT16, BASE_DEC, NULL,\r\n0x0, "Original num bytes in frame", HFILL }},\r\n{ &hf_cwids_capturelen,\r\n{ "Capture length", "cwids.caplen", FT_UINT16, BASE_DEC, NULL,\r\n0x0, "Captured bytes in record", HFILL }},\r\n{ &hf_cwids_unknown3,\r\n{ "Unknown3", "cwids.unknown3", FT_BYTES, BASE_NONE, NULL,\r\n0x0, "3rd Unknown block", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_cwids,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ie_ieee80211_subpacket, { "cwids.ieee80211_malformed", PI_MALFORMED, PI_ERROR, "Malformed or short IEEE80211 subpacket", EXPFILL }},\r\n};\r\nmodule_t *cwids_module;\r\nexpert_module_t* expert_cwids;\r\nproto_cwids = proto_register_protocol("Cisco Wireless IDS Captures", "CWIDS", "cwids");\r\nproto_register_field_array(proto_cwids, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_cwids = expert_register_protocol(proto_cwids);\r\nexpert_register_field_array(expert_cwids, ei, array_length(ei));\r\ncwids_module = prefs_register_protocol(proto_cwids, proto_reg_handoff_cwids);\r\nprefs_register_uint_preference(cwids_module, "udp.port",\r\n"CWIDS port",\r\n"Set the destination UDP port Cisco wireless IDS messages",\r\n10, &global_udp_port);\r\n}\r\nvoid\r\nproto_reg_handoff_cwids(void)\r\n{\r\nstatic dissector_handle_t cwids_handle;\r\nstatic guint saved_udp_port;\r\nstatic gboolean initialized = FALSE;\r\nif (!initialized) {\r\ncwids_handle = create_dissector_handle(dissect_cwids, proto_cwids);\r\ndissector_add_for_decode_as("udp.port", cwids_handle);\r\nieee80211_radio_handle = find_dissector_add_dependency("wlan_noqos_radio", proto_cwids);\r\ninitialized = TRUE;\r\n} else {\r\nif (saved_udp_port != 0) {\r\ndissector_delete_uint("udp.port", saved_udp_port, cwids_handle);\r\n}\r\n}\r\nif (global_udp_port != 0) {\r\ndissector_add_uint("udp.port", global_udp_port, cwids_handle);\r\n}\r\nsaved_udp_port = global_udp_port;\r\n}
