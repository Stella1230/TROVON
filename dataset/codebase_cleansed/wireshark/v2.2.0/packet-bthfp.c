static guint32 get_uint_parameter(guint8 *parameter_stream, gint parameter_length)\r\n{\r\nguint32 value;\r\nguint8 *val;\r\nval = (guint8 *) wmem_alloc(wmem_packet_scope(), parameter_length + 1);\r\nmemcpy(val, parameter_stream, parameter_length);\r\nval[parameter_length] = '\0';\r\nvalue = (guint32) g_ascii_strtoull(val, NULL, 10);\r\nreturn value;\r\n}\r\nstatic gboolean check_biev(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_bind(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_ACTION || type == TYPE_READ || type == TYPE_TEST)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_bac(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_bcs(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_bcc(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION_SIMPLY) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_bia(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_binp(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_bldn(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION_SIMPLY) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_bvra(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_brsf(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_nrec(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_vgs(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_vgm(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_bsir(gint role, guint16 type) {\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_btrh(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_READ || type == TYPE_ACTION)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_only_ag_role(gint role, guint16 type) {\r\nif (role == ROLE_AG && type == TYPE_RESPONSE_ACK) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_only_hs_role(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION_SIMPLY) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_ccwa(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_ACTION || type == TYPE_READ || type == TYPE_TEST)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_chld(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_ACTION || type == TYPE_TEST)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_chup(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_ACTION_SIMPLY || type == TYPE_TEST)) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_clcc(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_ACTION_SIMPLY || type == TYPE_TEST)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_cind(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_READ || type == TYPE_TEST)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_cmer(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_ACTION || type == TYPE_READ || type == TYPE_TEST)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_cops(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_ACTION || type == TYPE_READ)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_cmee(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_cme(gint role, guint16 type) {\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_clip(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_ACTION || type == TYPE_READ || type == TYPE_TEST)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_ciev(gint role, guint16 type) {\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_vts(gint role, guint16 type) {\r\nif (role == ROLE_HS && (type == TYPE_ACTION || type == TYPE_TEST)) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean check_cnum(gint role, guint16 type) {\r\nif (role == ROLE_HS && type == TYPE_ACTION_SIMPLY) return TRUE;\r\nif (role == ROLE_AG && type == TYPE_RESPONSE) return TRUE;\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\ndissect_brsf_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION) ||\r\n(role == ROLE_AG && type == TYPE_RESPONSE))) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nif (role == ROLE_HS) {\r\nstatic const int * hs[] = {\r\n&hf_brsf_hs_ec_nr_function,\r\n&hf_brsf_hs_call_waiting_or_tree_way,\r\n&hf_brsf_hs_cli_presentation,\r\n&hf_brsf_hs_voice_recognition_activation,\r\n&hf_brsf_hs_remote_volume_control,\r\n&hf_brsf_hs_enhanced_call_status,\r\n&hf_brsf_hs_enhanced_call_control,\r\n&hf_brsf_hs_codec_negotiation,\r\n&hf_brsf_hs_hf_indicators,\r\n&hf_brsf_hs_esco_s4_t2_settings_support,\r\n&hf_brsf_hs_reserved,\r\nNULL\r\n};\r\npitem = proto_tree_add_bitmask_value_with_flags(tree, tvb, offset, hf_brsf_hs, ett_bthfp_brsf_hf, hs, value, BMT_NO_APPEND);\r\nif (value >> 8) {\r\nexpert_add_info(pinfo, pitem, &ei_brfs_hs_reserved_bits);\r\n}\r\n} else {\r\nstatic const int * ag[] = {\r\n&hf_brsf_ag_three_way_calling,\r\n&hf_brsf_ag_ec_nr_function,\r\n&hf_brsf_ag_voice_recognition_function,\r\n&hf_brsf_ag_inband_ring_tone,\r\n&hf_brsf_ag_attach_number_to_voice_tag,\r\n&hf_brsf_ag_ability_to_reject_a_call,\r\n&hf_brsf_ag_enhanced_call_status,\r\n&hf_brsf_ag_enhanced_call_control,\r\n&hf_brsf_ag_extended_error_result_codes,\r\n&hf_brsf_ag_codec_negotiation,\r\n&hf_brsf_ag_hf_indicators,\r\n&hf_brsf_ag_esco_s4_t2_settings_support,\r\n&hf_brsf_ag_reserved,\r\nNULL\r\n};\r\npitem = proto_tree_add_bitmask_value_with_flags(tree, tvb, offset, hf_brsf_ag, ett_bthfp_brsf_ag, ag, value, BMT_NO_APPEND);\r\nif (value >> 10) {\r\nexpert_add_info(pinfo, pitem, &ei_brfs_ag_reserved_bits);\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_vgs_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION) ||\r\n(role == ROLE_AG && type == TYPE_RESPONSE))) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_vgs, tvb, offset, parameter_length, value);\r\nproto_item_append_text(pitem, "/15");\r\nif (value > 15) {\r\nexpert_add_info(pinfo, pitem, &ei_vgs_gain);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_vgm_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION) ||\r\n(role == ROLE_AG && type == TYPE_RESPONSE))) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_vgm, tvb, offset, parameter_length, value);\r\nproto_item_append_text(pitem, "/15");\r\nif (value > 15) {\r\nexpert_add_info(pinfo, pitem, &ei_vgm_gain);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_nrec_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION) ||\r\n(role == ROLE_AG && type == TYPE_RESPONSE))) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_nrec, tvb, offset, parameter_length, value);\r\nif (value != 0) {\r\nexpert_add_info(pinfo, pitem, &ei_nrec);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_bvra_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION) ||\r\n(role == ROLE_AG && type == TYPE_RESPONSE))) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_bvra_vrect, tvb, offset, parameter_length, value);\r\nif (value > 1) {\r\nexpert_add_info(pinfo, pitem, &ei_bvra);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_bcs_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!check_bcs(role, type)) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_bcs_codec, tvb, offset, parameter_length, value);\r\nif (value < 1 || value > 2) {\r\nexpert_add_info(pinfo, pitem, &ei_bcs);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_bac_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number _U_, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!check_bac(role, type)) {\r\nreturn FALSE;\r\n}\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_bac_codec, tvb, offset, parameter_length, value);\r\nif (value < 1 || value > 2) {\r\nexpert_add_info(pinfo, pitem, &ei_bac);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_bind_parameter(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nguint32 value;\r\nif (!check_bind(role, type)) return FALSE;\r\nif (parameter_number < 20) {\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_bind_parameter, tvb, offset,\r\nparameter_length, value);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gint\r\ndissect_biev_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!check_biev(role, type)) return FALSE;\r\nif (parameter_number == 0) {\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_biev_assigned_number, tvb, offset,\r\nparameter_length, value);\r\nif (value > 65535) {\r\nexpert_add_info(pinfo, pitem, &ei_biev_assigned_number);\r\n} else if (value > 1) {\r\nexpert_add_info(pinfo, pitem, &ei_biev_assigned_number_no);\r\n}\r\n} else if (parameter_number == 1) {\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_biev_value, tvb, offset,\r\nparameter_length, value);\r\n} else return FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_no_parameter(tvbuff_t *tvb _U_, packet_info *pinfo _U_, proto_tree *tree _U_,\r\ngint offset _U_, gint role _U_, guint16 type _U_, guint8 *parameter_stream _U_,\r\nguint parameter_number _U_, gint parameter_length _U_, void **data _U_)\r\n{\r\nreturn FALSE;\r\n}\r\nstatic gint\r\ndissect_bsir_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!(role == ROLE_AG && type == TYPE_RESPONSE)) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_bsir, tvb, offset, parameter_length, value);\r\nif (value > 1) {\r\nexpert_add_info(pinfo, pitem, &ei_bsir);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_btrh_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION) ||\r\n(role == ROLE_AG && type == TYPE_RESPONSE))) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_btrh, tvb, offset, parameter_length, value);\r\nif (value != 0) {\r\nexpert_add_info(pinfo, pitem, &ei_btrh);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_binp_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION) ||\r\n(role == ROLE_AG && type == TYPE_RESPONSE))) {\r\nreturn FALSE;\r\n}\r\nif (role == ROLE_HS && type == TYPE_ACTION) {\r\nif (parameter_number == 0) {\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_binp_request, tvb, offset,\r\nparameter_length, value);\r\nif (value != 1) {\r\nexpert_add_info(pinfo, pitem, &ei_binp);\r\n}\r\n} else return FALSE;\r\n} else {\r\nproto_tree_add_item(tree, hf_binp_response, tvb, offset,\r\nparameter_length, ENC_NA | ENC_ASCII);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_bia_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION))) return FALSE;\r\nif (parameter_number > 19) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_bia_indicator[parameter_number], tvb,\r\noffset, parameter_length, value);\r\nif (value > 1) {\r\nexpert_add_info(pinfo, pitem, &ei_bia);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_cind_parameter(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream _U_,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nif (!check_cind(role, type)) return FALSE;\r\nif (parameter_number > 19) return FALSE;\r\nproto_tree_add_item(tree, hf_indicator[parameter_number], tvb, offset,\r\nparameter_length, ENC_NA | ENC_ASCII);\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_chld_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nguint32 value;\r\nif (!check_chld(role, type)) return FALSE;\r\nif (role == ROLE_HS && type == TYPE_ACTION && parameter_number == 0) {\r\nvalue = get_uint_parameter(parameter_stream, 1);\r\nif (parameter_length >= 2) {\r\nif (tvb_get_guint8(tvb, offset + 1) == 'x') {\r\nif (value == 1)\r\nproto_tree_add_item(tree, hf_chld_mode_1x, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nelse if (value == 2)\r\nproto_tree_add_item(tree, hf_chld_mode_2x, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\n}\r\nif (tvb_get_guint8(tvb, offset + 1) != 'x' || value > 4) {\r\nproto_tree_add_expert(tree, pinfo, &ei_chld_mode, tvb, offset, parameter_length);\r\n}\r\n}\r\nproto_tree_add_uint(tree, hf_chld_mode, tvb, offset, parameter_length, value);\r\nreturn TRUE;\r\n}\r\nproto_tree_add_item(tree, hf_chld_supported_modes, tvb, offset,\r\nparameter_length, ENC_NA | ENC_ASCII);\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_ccwa_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!check_ccwa(role, type)) return FALSE;\r\nif (role == ROLE_HS && parameter_number > 2) return FALSE;\r\nif (role == ROLE_AG && parameter_number > 7) return FALSE;\r\nif (role == ROLE_HS) switch (parameter_number) {\r\ncase 0:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_ccwa_show_result_code, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 1:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_ccwa_mode, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 2:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_ccwa_class, tvb, offset, parameter_length, value);\r\nbreak;\r\n}\r\nif (role == ROLE_AG) switch (parameter_number) {\r\ncase 0:\r\nproto_tree_add_item(tree, hf_at_number, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 1:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_at_type, tvb, offset, parameter_length, value);\r\nif (value < 128 || value > 175)\r\nexpert_add_info(pinfo, pitem, &ei_at_type);\r\nbreak;\r\ncase 2:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_ccwa_class, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 3:\r\nproto_tree_add_item(tree, hf_at_alpha, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 4:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_at_cli_validity, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 5:\r\nproto_tree_add_item(tree, hf_at_subaddress, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 6:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_at_subaddress_type, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 7:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_at_priority, tvb, offset, parameter_length, value);\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_cmer_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION))) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 4) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nswitch (parameter_number) {\r\ncase 0:\r\npitem = proto_tree_add_uint(tree, hf_cmer_mode, tvb, offset, parameter_length, value);\r\nif (value != 3)\r\nexpert_add_info(pinfo, pitem, &ei_cmer_mode);\r\nbreak;\r\ncase 1:\r\npitem = proto_tree_add_uint(tree, hf_cmer_keyp, tvb, offset, parameter_length, value);\r\nif (value != 0)\r\nexpert_add_info(pinfo, pitem, &ei_cmer_keyp);\r\nbreak;\r\ncase 2:\r\npitem = proto_tree_add_uint(tree, hf_cmer_disp, tvb, offset, parameter_length, value);\r\nif (value != 0)\r\nexpert_add_info(pinfo, pitem, &ei_cmer_disp);\r\nbreak;\r\ncase 3:\r\npitem = proto_tree_add_uint(tree, hf_cmer_ind, tvb, offset, parameter_length, value);\r\nif (value > 1)\r\nexpert_add_info(pinfo, pitem, &ei_cmer_ind);\r\nbreak;\r\ncase 4:\r\npitem = proto_tree_add_uint(tree, hf_cmer_bfr, tvb, offset, parameter_length, value);\r\nif (value != 0)\r\nexpert_add_info(pinfo, pitem, &ei_cmer_btr);\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_clip_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!check_clip(role, type))\r\nreturn FALSE;\r\nif (role == ROLE_HS && type == TYPE_ACTION && parameter_number > 1)\r\nreturn FALSE;\r\nelse if (role == ROLE_AG && parameter_number > 5)\r\nreturn FALSE;\r\nif (role == ROLE_HS && type == TYPE_ACTION) switch (parameter_number) {\r\ncase 0:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_clip_mode, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 1:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_clip_status, tvb, offset, parameter_length, value);\r\nbreak;\r\n} else {\r\nswitch (parameter_number) {\r\ncase 0:\r\nproto_tree_add_item(tree, hf_at_number, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 1:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_at_type, tvb, offset, parameter_length, value);\r\nif (value < 128 || value > 175)\r\nexpert_add_info(pinfo, pitem, &ei_at_type);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(tree, hf_at_subaddress, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 3:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_at_subaddress_type, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 4:\r\nproto_tree_add_item(tree, hf_at_alpha, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 5:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_at_cli_validity, tvb, offset, parameter_length, value);\r\nbreak;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_cmee_parameter(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nguint32 value;\r\nif (!(role == ROLE_HS && type == TYPE_ACTION)) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_cmee, tvb, offset, parameter_length, value);\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_cops_parameter(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nguint32 value;\r\nif (!((role == ROLE_HS && (type == TYPE_ACTION || type == TYPE_READ)) ||\r\n(role == ROLE_AG && type == TYPE_RESPONSE))) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 3) return FALSE;\r\nswitch (parameter_number) {\r\ncase 0:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_cops_mode, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 1:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_cops_format, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(tree, hf_cops_operator, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 3:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_cops_act, tvb, offset, parameter_length, value);\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_clcc_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!((role == ROLE_HS && type == TYPE_ACTION_SIMPLY) ||\r\n(role == ROLE_AG && type == TYPE_RESPONSE))) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 8) return FALSE;\r\nswitch (parameter_number) {\r\ncase 0:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_clcc_id, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 1:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_clcc_dir, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 2:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_clcc_stat, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 3:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_clcc_mode, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 4:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_clcc_mpty, tvb, offset, parameter_length, value);\r\nbreak;\r\ncase 5:\r\nproto_tree_add_item(tree, hf_at_number, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 6:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_at_type, tvb, offset, parameter_length, value);\r\nif (value < 128 || value > 175)\r\nexpert_add_info(pinfo, pitem, &ei_at_type);\r\nbreak;\r\ncase 7:\r\nproto_tree_add_item(tree, hf_at_alpha, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 8:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_at_priority, tvb, offset, parameter_length, value);\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_cme_error_parameter(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nguint32 value;\r\nif (!(role == ROLE_AG && type == TYPE_RESPONSE)) {\r\nreturn FALSE;\r\n}\r\nif (parameter_number > 0) return FALSE;\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_cme_error, tvb, offset, parameter_length, value);\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_cnum_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!(role == ROLE_AG && type == TYPE_RESPONSE)) return TRUE;\r\nif (parameter_number > 5) return FALSE;\r\nswitch (parameter_number) {\r\ncase 0:\r\npitem = proto_tree_add_item(tree, hf_at_alpha, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nif (parameter_length > 0)\r\nexpert_add_info(pinfo, pitem, &ei_parameter_blank);\r\nbreak;\r\ncase 1:\r\nproto_tree_add_item(tree, hf_at_number, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nbreak;\r\ncase 2:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_at_type, tvb, offset, parameter_length, value);\r\nif (value < 128 || value > 175)\r\nexpert_add_info(pinfo, pitem, &ei_at_type);\r\nbreak;\r\ncase 3:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_cnum_speed, tvb, offset, parameter_length, value);\r\nif (parameter_length > 0)\r\nexpert_add_info(pinfo, pitem, &ei_parameter_blank);\r\nbreak;\r\ncase 4:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_cnum_service, tvb, offset, parameter_length, value);\r\nif (value > 5)\r\nexpert_add_info(pinfo, pitem, &ei_cnum_service);\r\nbreak;\r\ncase 5:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\npitem = proto_tree_add_uint(tree, hf_cnum_itc, tvb, offset, parameter_length, value);\r\nif (value > 1)\r\nexpert_add_info(pinfo, pitem, &ei_cnum_itc);\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_vts_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data _U_)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nif (!(role == ROLE_HS && type == TYPE_ACTION)) return TRUE;\r\nif (parameter_number > 1) return FALSE;\r\nswitch (parameter_number) {\r\ncase 0:\r\npitem = proto_tree_add_item(tree, hf_vts_dtmf, tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\nif (parameter_length != 1)\r\nexpert_add_info(pinfo, pitem, &ei_vts_dtmf);\r\nbreak;\r\ncase 1:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_vts_duration, tvb, offset, parameter_length, value);\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_ciev_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, gint role, guint16 type, guint8 *parameter_stream,\r\nguint parameter_number, gint parameter_length, void **data)\r\n{\r\nguint32 value;\r\nguint indicator_index;\r\nif (!(role == ROLE_AG && type == TYPE_RESPONSE)) return TRUE;\r\nif (parameter_number > 1) return FALSE;\r\nswitch (parameter_number) {\r\ncase 0:\r\nvalue = get_uint_parameter(parameter_stream, parameter_length);\r\nproto_tree_add_uint(tree, hf_ciev_indicator_index, tvb, offset, parameter_length, value);\r\n*data = wmem_alloc(wmem_packet_scope(), sizeof(guint));\r\n*((guint *) *data) = value;\r\nbreak;\r\ncase 1:\r\nindicator_index = *((guint *) *data) - 1;\r\nif (indicator_index > 19) {\r\nproto_tree_add_expert(tree, pinfo, &ei_ciev_indicator, tvb, offset, parameter_length);\r\n} else {\r\nproto_tree_add_item(tree, hf_indicator[indicator_index], tvb, offset, parameter_length, ENC_NA | ENC_ASCII);\r\n}\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gint\r\ndissect_at_command(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint offset, guint32 role, gint command_number)\r\n{\r\nproto_item *pitem;\r\nproto_tree *command_item = NULL;\r\nproto_item *command_tree = NULL;\r\nproto_tree *parameters_item = NULL;\r\nproto_item *parameters_tree = NULL;\r\nguint8 *col_str = NULL;\r\nguint8 *at_stream;\r\nguint8 *at_command = NULL;\r\ngint i_char = 0;\r\nguint i_char_fix = 0;\r\ngint length;\r\nconst at_cmd_t *i_at_cmd;\r\ngint parameter_length;\r\nguint parameter_number = 0;\r\ngint first_parameter_offset = offset;\r\ngint last_parameter_offset = offset;\r\nguint16 type = TYPE_UNKNOWN;\r\nguint32 brackets;\r\ngboolean quotation;\r\ngboolean next;\r\nvoid *data;\r\nlength = tvb_reported_length_remaining(tvb, offset);\r\nif (length <= 0)\r\nreturn tvb_reported_length(tvb);\r\nif (!command_number) {\r\nproto_tree_add_item(tree, hf_data, tvb, offset, length, ENC_NA | ENC_ASCII);\r\ncol_str = (guint8 *) wmem_alloc(wmem_packet_scope(), length + 1);\r\ntvb_memcpy(tvb, col_str, offset, length);\r\ncol_str[length] = '\0';\r\n}\r\nat_stream = (guint8 *) wmem_alloc(wmem_packet_scope(), length + 1);\r\ntvb_memcpy(tvb, at_stream, offset, length);\r\nat_stream[length] = '\0';\r\nwhile (at_stream[i_char]) {\r\nat_stream[i_char] = g_ascii_toupper(at_stream[i_char]);\r\nif (!command_number) {\r\ncol_str[i_char] = g_ascii_toupper(col_str[i_char]);\r\nif (!g_ascii_isgraph(col_str[i_char])) col_str[i_char] = ' ';\r\n}\r\ni_char += 1;\r\n}\r\nif (!command_number) col_append_fstr(pinfo->cinfo, COL_INFO, "%s", col_str);\r\nif (role == ROLE_HS) {\r\nif (command_number) {\r\nat_command = at_stream;\r\ni_char = 0;\r\n} else {\r\nat_command = g_strstr_len(at_stream, length, "AT");\r\nif (at_command) {\r\ncommand_item = proto_tree_add_none_format(tree, hf_command, tvb,\r\noffset, 0, "Command %u", command_number);\r\ncommand_tree = proto_item_add_subtree(command_item, ett_bthfp_command);\r\ni_char = (guint) (at_command - at_stream);\r\nif (i_char) {\r\nproto_tree_add_item(command_tree, hf_at_ignored, tvb, offset,\r\ni_char, ENC_NA | ENC_ASCII);\r\noffset += i_char;\r\n}\r\nproto_tree_add_item(command_tree, hf_at_command_line_prefix,\r\ntvb, offset, 2, ENC_NA | ENC_ASCII);\r\noffset += 2;\r\ni_char += 2;\r\nat_command = at_stream;\r\nat_command += i_char;\r\nlength -= i_char;\r\ni_char_fix += i_char;\r\ni_char = 0;\r\n}\r\n}\r\n} else if (at_stream[0] == '\r' && at_stream[1] == '\n') {\r\ncommand_item = proto_tree_add_none_format(tree, hf_command, tvb,\r\noffset, 0, "Command %u", command_number);\r\ncommand_tree = proto_item_add_subtree(command_item, ett_bthfp_command);\r\nat_command = at_stream;\r\ni_char = 0;\r\nwhile (i_char <= length &&\r\n(at_command[i_char] == '\r' || at_command[i_char] == '\n' ||\r\nat_command[i_char] == ' ' || at_command[i_char] == '\t')) {\r\ni_char += 1;\r\n}\r\noffset += i_char;\r\nat_command += i_char;\r\nlength -= i_char;\r\ni_char_fix += i_char;\r\ni_char = 0;\r\n}\r\nif (at_command) {\r\nwhile (i_char < length &&\r\n(at_command[i_char] != '\r' && at_command[i_char] != '=' &&\r\nat_command[i_char] != ';' && at_command[i_char] != '?' &&\r\nat_command[i_char] != ':')) {\r\ni_char += 1;\r\n}\r\ni_at_cmd = at_cmds;\r\nif (at_command[0] == '\r') {\r\npitem = proto_tree_add_item(command_tree, hf_at_cmd, tvb, offset - 2,\r\n2, ENC_NA | ENC_ASCII);\r\ni_at_cmd = NULL;\r\n} else {\r\npitem = NULL;\r\nwhile (i_at_cmd->name) {\r\nif (g_str_has_prefix(&at_command[0], i_at_cmd->name)) {\r\npitem = proto_tree_add_item(command_tree, hf_at_cmd, tvb, offset,\r\n(gint) strlen(i_at_cmd->name), ENC_NA | ENC_ASCII);\r\nproto_item_append_text(pitem, " (%s)", i_at_cmd->long_name);\r\nbreak;\r\n}\r\ni_at_cmd += 1;\r\n}\r\nif (!pitem) {\r\npitem = proto_tree_add_item(command_tree, hf_at_cmd, tvb, offset,\r\ni_char, ENC_NA | ENC_ASCII);\r\n}\r\n}\r\nif (i_at_cmd && i_at_cmd->name == NULL) {\r\nchar *name;\r\nname = (char *) wmem_alloc(wmem_packet_scope(), i_char + 2);\r\ng_strlcpy(name, at_command, i_char + 1);\r\nname[i_char + 1] = '\0';\r\nproto_item_append_text(command_item, ": %s (Unknown)", name);\r\nproto_item_append_text(pitem, " (Unknown - Non-Standard HFP Command)");\r\nexpert_add_info(pinfo, pitem, &ei_non_mandatory_command);\r\n} else if (i_at_cmd == NULL) {\r\nproto_item_append_text(command_item, ": AT");\r\n} else {\r\nproto_item_append_text(command_item, ": %s", i_at_cmd->name);\r\n}\r\noffset += i_char;\r\nif (i_at_cmd && g_strcmp0(i_at_cmd->name, "D")) {\r\nif (length >= 2 && at_command[i_char] == '=' && at_command[i_char + 1] == '?') {\r\ntype = at_command[i_char] << 8 | at_command[i_char + 1];\r\nproto_tree_add_uint(command_tree, hf_at_cmd_type, tvb, offset, 2, type);\r\noffset += 2;\r\ni_char += 2;\r\n} else if (role == ROLE_AG && length >= 2 && at_command[i_char] == '\r' && at_command[i_char + 1] == '\n') {\r\ntype = at_command[i_char] << 8 | at_command[i_char + 1];\r\nproto_tree_add_uint(command_tree, hf_at_cmd_type, tvb, offset, 2, type);\r\noffset += 2;\r\ni_char += 2;\r\n} else if (length >= 1 && (at_command[i_char] == '=' ||\r\nat_command[i_char] == '\r' ||\r\nat_command[i_char] == ':' ||\r\nat_command[i_char] == '?')) {\r\ntype = at_command[i_char];\r\nproto_tree_add_uint(command_tree, hf_at_cmd_type, tvb, offset, 1, type);\r\noffset += 1;\r\ni_char += 1;\r\n}\r\n}\r\nif (i_at_cmd && i_at_cmd->check_command && !i_at_cmd->check_command(role, type)) {\r\nexpert_add_info(pinfo, command_item, &ei_invalid_usage);\r\n}\r\nparameters_item = proto_tree_add_none_format(command_tree, hf_parameters, tvb,\r\noffset, 0, "Parameters");\r\nparameters_tree = proto_item_add_subtree(parameters_item, ett_bthfp_parameters);\r\ndata = NULL;\r\nwhile (i_char < length) {\r\nwhile (at_command[i_char] == ' ' || at_command[i_char] == '\t') {\r\noffset += 1;\r\ni_char += 1;\r\n}\r\nparameter_length = 0;\r\nbrackets = 0;\r\nquotation = FALSE;\r\nnext = FALSE;\r\nif (at_command[i_char + parameter_length] != '\r') {\r\nwhile (i_char + parameter_length < length &&\r\nat_command[i_char + parameter_length] != '\r') {\r\nif (at_command[i_char + parameter_length] == ';') {\r\nnext = TRUE;\r\nbreak;\r\n}\r\nif (at_command[i_char + parameter_length] == '"') {\r\nquotation = quotation ? FALSE : TRUE;\r\n}\r\nif (quotation == TRUE) {\r\nparameter_length += 1;\r\ncontinue;\r\n}\r\nif (at_command[i_char + parameter_length] == '(') {\r\nbrackets += 1;\r\n}\r\nif (at_command[i_char + parameter_length] == ')') {\r\nbrackets -= 1;\r\n}\r\nif (brackets == 0 && at_command[i_char + parameter_length] == ',') {\r\nbreak;\r\n}\r\nparameter_length += 1;\r\n}\r\nfirst_parameter_offset = offset;\r\nif (type == TYPE_ACTION || type == TYPE_RESPONSE) {\r\nif (i_at_cmd && (i_at_cmd->dissect_parameter != NULL &&\r\n!i_at_cmd->dissect_parameter(tvb, pinfo, parameters_tree, offset, role,\r\ntype, &at_command[i_char], parameter_number, parameter_length, &data) )) {\r\npitem = proto_tree_add_item(parameters_tree,\r\nhf_unknown_parameter, tvb, offset,\r\nparameter_length, ENC_NA | ENC_ASCII);\r\nexpert_add_info(pinfo, pitem, &ei_unknown_parameter);\r\n} else if (i_at_cmd && i_at_cmd->dissect_parameter == NULL) {\r\nproto_tree_add_item(parameters_tree, hf_parameter, tvb, offset,\r\nparameter_length, ENC_NA | ENC_ASCII);\r\n}\r\n}\r\n}\r\nif (type != TYPE_ACTION_SIMPLY && type != TYPE_RESPONSE_ACK && type != TYPE_TEST && type != TYPE_READ)\r\nparameter_number += 1;\r\ni_char += parameter_length;\r\noffset += parameter_length;\r\nlast_parameter_offset = offset;\r\nif (role == ROLE_AG &&\r\ni_char + 1 <= length &&\r\nat_command[i_char] == '\r' &&\r\nat_command[i_char + 1] == '\n') {\r\noffset += 2;\r\ni_char += 2;\r\nbreak;\r\n} else if (at_command[i_char] == ',' ||\r\nat_command[i_char] == '\r' ||\r\nat_command[i_char] == ';') {\r\ni_char += 1;\r\noffset += 1;\r\n}\r\nif (next) break;\r\n}\r\ni_char += i_char_fix;\r\nproto_item_set_len(command_item, i_char);\r\n} else {\r\nlength = tvb_reported_length_remaining(tvb, offset);\r\nif (length < 0)\r\nlength = 0;\r\noffset += length;\r\n}\r\nif (parameter_number > 0 && last_parameter_offset - first_parameter_offset > 0)\r\nproto_item_set_len(parameters_item, last_parameter_offset - first_parameter_offset);\r\nelse\r\nproto_item_append_text(parameters_item, ": No");\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_bthfp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *main_item;\r\nproto_tree *main_tree;\r\nproto_item *pitem;\r\ngint offset = 0;\r\nguint32 role = ROLE_UNKNOWN;\r\nwmem_tree_key_t key[10];\r\nguint32 interface_id;\r\nguint32 adapter_id;\r\nguint32 chandle;\r\nguint32 dlci;\r\nguint32 frame_number;\r\nguint32 direction;\r\nguint32 bd_addr_oui;\r\nguint32 bd_addr_id;\r\nfragment_t *fragment;\r\nfragment_t *previous_fragment;\r\nfragment_t *i_fragment;\r\nguint8 *at_stream;\r\ngint length;\r\ngint command_number;\r\ngint i_length;\r\ntvbuff_t *reassembled_tvb = NULL;\r\nguint reassemble_start_offset = 0;\r\nguint reassemble_end_offset = 0;\r\ngint previous_proto;\r\nprevious_proto = (GPOINTER_TO_INT(wmem_list_frame_data(wmem_list_frame_prev(wmem_list_tail(pinfo->layers)))));\r\nif (data && previous_proto == proto_btrfcomm) {\r\nbtrfcomm_data_t *rfcomm_data;\r\nrfcomm_data = (btrfcomm_data_t *) data;\r\ninterface_id = rfcomm_data->interface_id;\r\nadapter_id = rfcomm_data->adapter_id;\r\nchandle = rfcomm_data->chandle;\r\ndlci = rfcomm_data->dlci;\r\ndirection = (rfcomm_data->is_local_psm) ? P2P_DIR_SENT : P2P_DIR_RECV;\r\nif (direction == P2P_DIR_RECV) {\r\nbd_addr_oui = rfcomm_data->remote_bd_addr_oui;\r\nbd_addr_id = rfcomm_data->remote_bd_addr_id;\r\n} else {\r\nbd_addr_oui = 0;\r\nbd_addr_id = 0;\r\n}\r\n} else {\r\ninterface_id = HCI_INTERFACE_DEFAULT;\r\nadapter_id = HCI_ADAPTER_DEFAULT;\r\nchandle = 0;\r\ndlci = 0;\r\ndirection = P2P_DIR_UNKNOWN;\r\nbd_addr_oui = 0;\r\nbd_addr_id = 0;\r\n}\r\nmain_item = proto_tree_add_item(tree, proto_bthfp, tvb, 0, tvb_captured_length(tvb), ENC_NA);\r\nmain_tree = proto_item_add_subtree(main_item, ett_bthfp);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HFP");\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");\r\nbreak;\r\n}\r\nif ((hfp_role == ROLE_AG && pinfo->p2p_dir == P2P_DIR_SENT) ||\r\n(hfp_role == ROLE_HS && pinfo->p2p_dir == P2P_DIR_RECV)) {\r\nrole = ROLE_AG;\r\n} else if (hfp_role != ROLE_UNKNOWN) {\r\nrole = ROLE_HS;\r\n}\r\nif (role == ROLE_UNKNOWN) {\r\nguint32 sdp_psm;\r\nguint32 service_type;\r\nguint32 service_channel;\r\nservice_info_t *service_info;\r\nsdp_psm = SDP_PSM_DEFAULT;\r\nservice_type = BTSDP_RFCOMM_PROTOCOL_UUID;\r\nservice_channel = dlci >> 1;\r\nframe_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &sdp_psm;\r\nkey[3].length = 1;\r\nkey[3].key = &direction;\r\nkey[4].length = 1;\r\nkey[4].key = &bd_addr_oui;\r\nkey[5].length = 1;\r\nkey[5].key = &bd_addr_id;\r\nkey[6].length = 1;\r\nkey[6].key = &service_type;\r\nkey[7].length = 1;\r\nkey[7].key = &service_channel;\r\nkey[8].length = 1;\r\nkey[8].key = &frame_number;\r\nkey[9].length = 0;\r\nkey[9].key = NULL;\r\nservice_info = btsdp_get_service_info(key);\r\nif (service_info && service_info->interface_id == interface_id &&\r\nservice_info->adapter_id == adapter_id &&\r\nservice_info->sdp_psm == SDP_PSM_DEFAULT &&\r\n((service_info->direction == P2P_DIR_RECV &&\r\nservice_info->bd_addr_oui == bd_addr_oui &&\r\nservice_info->bd_addr_id == bd_addr_id) ||\r\n(service_info->direction != P2P_DIR_RECV &&\r\nservice_info->bd_addr_oui == 0 &&\r\nservice_info->bd_addr_id == 0)) &&\r\nservice_info->type == BTSDP_RFCOMM_PROTOCOL_UUID &&\r\nservice_info->channel == (dlci >> 1)) {\r\nif ((service_info->uuid.bt_uuid == BTSDP_HFP_GW_SERVICE_UUID && service_info->direction == P2P_DIR_RECV && pinfo->p2p_dir == P2P_DIR_SENT) ||\r\n(service_info->uuid.bt_uuid == BTSDP_HFP_GW_SERVICE_UUID && service_info->direction == P2P_DIR_SENT && pinfo->p2p_dir == P2P_DIR_RECV) ||\r\n(service_info->uuid.bt_uuid == BTSDP_HFP_SERVICE_UUID && service_info->direction == P2P_DIR_RECV && pinfo->p2p_dir == P2P_DIR_RECV) ||\r\n(service_info->uuid.bt_uuid == BTSDP_HFP_SERVICE_UUID && service_info->direction == P2P_DIR_SENT && pinfo->p2p_dir == P2P_DIR_SENT)) {\r\nrole = ROLE_HS;\r\n} else {\r\nrole = ROLE_AG;\r\n}\r\n}\r\n}\r\npitem = proto_tree_add_uint(main_tree, hf_role, tvb, 0, 0, role);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nif (role == ROLE_UNKNOWN) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Data: %s",\r\ntvb_format_text(tvb, 0, tvb_reported_length(tvb)));\r\nproto_tree_add_item(main_tree, hf_data, tvb, 0, tvb_captured_length(tvb), ENC_NA | ENC_ASCII);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nif (!pinfo->fd->flags.visited) {\r\nframe_number = pinfo->num - 1;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &dlci;\r\nkey[4].length = 1;\r\nkey[4].key = &role;\r\nkey[5].length = 1;\r\nkey[5].key = &frame_number;\r\nkey[6].length = 0;\r\nkey[6].key = NULL;\r\nprevious_fragment = (fragment_t *) wmem_tree_lookup32_array_le(fragments, key);\r\nif (!(previous_fragment && previous_fragment->interface_id == interface_id &&\r\nprevious_fragment->adapter_id == adapter_id &&\r\nprevious_fragment->chandle == chandle &&\r\nprevious_fragment->dlci == dlci &&\r\nprevious_fragment->role == role &&\r\nprevious_fragment->reassemble_state != REASSEMBLE_DONE)) {\r\nprevious_fragment = NULL;\r\n}\r\nframe_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &dlci;\r\nkey[4].length = 1;\r\nkey[4].key = &role;\r\nkey[5].length = 1;\r\nkey[5].key = &frame_number;\r\nkey[6].length = 0;\r\nkey[6].key = NULL;\r\nfragment = wmem_new(wmem_file_scope(), fragment_t);\r\nfragment->interface_id = interface_id;\r\nfragment->adapter_id = adapter_id;\r\nfragment->chandle = chandle;\r\nfragment->dlci = dlci;\r\nfragment->role = role;\r\nfragment->idx = previous_fragment ? previous_fragment->idx + previous_fragment->length : 0;\r\nfragment->reassemble_state = REASSEMBLE_FRAGMENT;\r\nfragment->length = tvb_reported_length(tvb);\r\nfragment->data = (guint8 *) wmem_alloc(wmem_file_scope(), fragment->length);\r\nfragment->previous_fragment = previous_fragment;\r\ntvb_memcpy(tvb, fragment->data, offset, fragment->length);\r\nwmem_tree_insert32_array(fragments, key, fragment);\r\nlength = tvb_reported_length(tvb);\r\nat_stream = tvb_get_string_enc(wmem_packet_scope(), tvb, 0, length, ENC_ASCII);\r\nreassemble_start_offset = 0;\r\nfor (i_length = 0; i_length < length; i_length += 1) {\r\nif (!((role == ROLE_HS && at_stream[i_length] == '\r') ||\r\n(role == ROLE_AG && at_stream[i_length] == '\n'))) {\r\ncontinue;\r\n}\r\nif (role == ROLE_HS && at_stream[i_length] == '\r') {\r\nreassemble_start_offset = i_length + 1;\r\nif (reassemble_end_offset == 0) reassemble_end_offset = i_length + 1;\r\n}\r\nif (role == ROLE_AG && at_stream[i_length] == '\n') {\r\nreassemble_start_offset = i_length + 1;\r\n}\r\nframe_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &dlci;\r\nkey[4].length = 1;\r\nkey[4].key = &role;\r\nkey[5].length = 1;\r\nkey[5].key = &frame_number;\r\nkey[6].length = 0;\r\nkey[6].key = NULL;\r\nfragment = (fragment_t *) wmem_tree_lookup32_array_le(fragments, key);\r\nif (fragment && fragment->interface_id == interface_id &&\r\nfragment->adapter_id == adapter_id &&\r\nfragment->chandle == chandle &&\r\nfragment->dlci == dlci &&\r\nfragment->role == role) {\r\ni_fragment = fragment;\r\nwhile (i_fragment && i_fragment->idx > 0) {\r\ni_fragment = i_fragment->previous_fragment;\r\n}\r\nif (i_length + 1 == length &&\r\nrole == ROLE_HS &&\r\nat_stream[i_length] == '\r') {\r\nfragment->reassemble_state = REASSEMBLE_DONE;\r\n} else if (i_length + 1 == length &&\r\nrole == ROLE_AG &&\r\ni_length >= 4 &&\r\nat_stream[i_length] == '\n' &&\r\nat_stream[i_length - 1] == '\r' &&\r\nat_stream[0] == '\r' &&\r\nat_stream[1] == '\n') {\r\nfragment->reassemble_state = REASSEMBLE_DONE;\r\n} else if (i_length + 1 == length &&\r\nrole == ROLE_AG &&\r\ni_length >= 2 &&\r\nat_stream[i_length] == '\n' &&\r\nat_stream[i_length - 1] == '\r' &&\r\ni_fragment &&\r\ni_fragment->reassemble_state == REASSEMBLE_FRAGMENT &&\r\ni_fragment->length >= 2 &&\r\ni_fragment->data[0] == '\r' &&\r\ni_fragment->data[1] == '\n') {\r\nfragment->reassemble_state = REASSEMBLE_DONE;\r\n} else if (role == ROLE_HS) {\r\n}\r\nfragment->reassemble_start_offset = reassemble_start_offset;\r\nfragment->reassemble_end_offset = reassemble_end_offset;\r\n}\r\n}\r\n}\r\nframe_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &dlci;\r\nkey[4].length = 1;\r\nkey[4].key = &role;\r\nkey[5].length = 1;\r\nkey[5].key = &frame_number;\r\nkey[6].length = 0;\r\nkey[6].key = NULL;\r\nfragment = (fragment_t *) wmem_tree_lookup32_array_le(fragments, key);\r\nif (fragment && fragment->interface_id == interface_id &&\r\nfragment->adapter_id == adapter_id &&\r\nfragment->chandle == chandle &&\r\nfragment->dlci == dlci &&\r\nfragment->role == role &&\r\nfragment->reassemble_state != REASSEMBLE_FRAGMENT) {\r\nguint8 *at_data;\r\nguint i_data_offset;\r\ni_data_offset = fragment->idx + fragment->length;\r\nat_data = (guint8 *) wmem_alloc(pinfo->pool, fragment->idx + fragment->length);\r\ni_fragment = fragment;\r\nif (i_fragment && i_fragment->reassemble_state == REASSEMBLE_PARTIALLY) {\r\ni_data_offset -= i_fragment->reassemble_end_offset;\r\nmemcpy(at_data + i_data_offset, i_fragment->data, i_fragment->reassemble_end_offset);\r\ni_fragment = i_fragment->previous_fragment;\r\n}\r\nif (i_fragment) {\r\nwhile (i_fragment && i_fragment->idx > 0) {\r\ni_data_offset -= i_fragment->length;\r\nmemcpy(at_data + i_data_offset, i_fragment->data, i_fragment->length);\r\ni_fragment = i_fragment->previous_fragment;\r\n}\r\nif (i_fragment && i_fragment->reassemble_state == REASSEMBLE_PARTIALLY) {\r\ni_data_offset -= (i_fragment->length - i_fragment->reassemble_start_offset);\r\nmemcpy(at_data + i_data_offset, i_fragment->data + i_fragment->reassemble_start_offset,\r\ni_fragment->length - i_fragment->reassemble_start_offset);\r\n} else if (i_fragment) {\r\ni_data_offset -= i_fragment->length;\r\nmemcpy(at_data + i_data_offset, i_fragment->data, i_fragment->length);\r\n}\r\n}\r\nif (fragment->idx > 0 && fragment->length > 0) {\r\nproto_tree_add_item(main_tree, hf_fragment, tvb, offset,\r\ntvb_captured_length_remaining(tvb, offset), ENC_ASCII | ENC_NA);\r\nreassembled_tvb = tvb_new_child_real_data(tvb, at_data,\r\nfragment->idx + fragment->length, fragment->idx + fragment->length);\r\nadd_new_data_source(pinfo, reassembled_tvb, "Reassembled HFP");\r\n}\r\ncommand_number = 0;\r\nif (reassembled_tvb) {\r\nguint reassembled_offset = 0;\r\nwhile (tvb_reported_length(reassembled_tvb) > reassembled_offset) {\r\nreassembled_offset = dissect_at_command(reassembled_tvb,\r\npinfo, main_tree, reassembled_offset, role, command_number);\r\ncommand_number += 1;\r\n}\r\noffset = tvb_captured_length(tvb);\r\n} else {\r\nwhile (tvb_reported_length(tvb) > (guint) offset) {\r\noffset = dissect_at_command(tvb, pinfo, main_tree, offset, role, command_number);\r\ncommand_number += 1;\r\n}\r\n}\r\n} else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Fragment: %s",\r\ntvb_format_text_wsp(tvb, offset, tvb_captured_length_remaining(tvb, offset)));\r\npitem = proto_tree_add_item(main_tree, hf_fragmented, tvb, 0, 0, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nproto_tree_add_item(main_tree, hf_fragment, tvb, offset,\r\ntvb_captured_length_remaining(tvb, offset), ENC_ASCII | ENC_NA);\r\noffset = tvb_captured_length(tvb);\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_bthfp(void)\r\n{\r\nmodule_t *module;\r\nexpert_module_t *expert_bthfp;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_command,\r\n{ "Command", "bthfp.command",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_parameters,\r\n{ "Parameters", "bthfp.parameters",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_data,\r\n{ "AT Stream", "bthfp.data",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_fragment,\r\n{ "Fragment", "bthfp.fragment",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_fragmented,\r\n{ "Fragmented", "bthfp.fragmented",\r\nFT_NONE, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_ignored,\r\n{ "Ignored", "bthfp.ignored",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_cmd,\r\n{ "Command", "bthfp.at_cmd",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_cmd_type,\r\n{ "Type", "bthfp.at_cmd.type",\r\nFT_UINT16, BASE_HEX, VALS(at_cmd_type_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_command_line_prefix,\r\n{ "Command Line Prefix", "bthfp.command_line_prefix",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_parameter,\r\n{ "Parameter", "bthfp.parameter",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_unknown_parameter,\r\n{ "Unknown Parameter", "bthfp.unknown_parameter",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_role,\r\n{ "Role", "bthfp.role",\r\nFT_UINT8, BASE_DEC, VALS(role_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs,\r\n{ "HS supported features bitmask", "bthfp.brsf.hs.features",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_ec_nr_function,\r\n{ "EC and/or NR function", "bthfp.brsf.hs.ec_nr_function",\r\nFT_BOOLEAN, 32, NULL, 0x00000001,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_call_waiting_or_tree_way,\r\n{ "Call waiting or 3-way calling", "bthfp.brsf.hs.call_waiting_or_tree_way",\r\nFT_BOOLEAN, 32, NULL, 0x00000002,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_cli_presentation,\r\n{ "CLI Presentation", "bthfp.brsf.hs.cli_presentation",\r\nFT_BOOLEAN, 32, NULL, 0x00000004,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_voice_recognition_activation,\r\n{ "Voice Recognition Activation", "bthfp.brsf.hs.voice_recognition_activation",\r\nFT_BOOLEAN, 32, NULL, 0x00000008,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_remote_volume_control,\r\n{ "Remote Volume Control", "bthfp.brsf.hs.remote_volume_control",\r\nFT_BOOLEAN, 32, NULL, 0x00000010,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_enhanced_call_status,\r\n{ "Enhanced Call Status", "bthfp.brsf.hs.enhanced_call_status",\r\nFT_BOOLEAN, 32, NULL, 0x00000020,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_enhanced_call_control,\r\n{ "Enhanced Call Control", "bthfp.brsf.hs.enhanced_call_control",\r\nFT_BOOLEAN, 32, NULL, 0x00000040,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_codec_negotiation,\r\n{ "Codec Negotiation", "bthfp.brsf.hs.codec_negotiation",\r\nFT_BOOLEAN, 32, NULL, 0x00000080,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_hf_indicators,\r\n{ "HF Indicators", "bthfp.brsf.hs.hf_indicators",\r\nFT_BOOLEAN, 32, NULL, 0x00000100,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_esco_s4_t2_settings_support,\r\n{ "eSCO S4 (and T2) Settings Support","bthfp.brsf.hs.esco_s4_t2_settings_support",\r\nFT_BOOLEAN, 32, NULL, 0x00000200,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_hs_reserved,\r\n{ "Reserved", "bthfp.brsf.hs.reserved",\r\nFT_UINT32, BASE_HEX, NULL, 0xFFFFFC00,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag,\r\n{ "AG supported features bitmask", "bthfp.brsf.ag.features",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_three_way_calling,\r\n{ "Three Way Calling", "bthfp.brsf.ag.three_way_calling",\r\nFT_BOOLEAN, 32, NULL, 0x00000001,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_ec_nr_function,\r\n{ "EC and/or NR function", "bthfp.brsf.ag.ec_nr_function",\r\nFT_BOOLEAN, 32, NULL, 0x00000002,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_voice_recognition_function,\r\n{ "Voice Recognition Function", "bthfp.brsf.ag.voice_recognition_function",\r\nFT_BOOLEAN, 32, NULL, 0x00000004,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_inband_ring_tone,\r\n{ "In-band Ring Tone", "bthfp.brsf.ag.inband_ring_tone",\r\nFT_BOOLEAN, 32, NULL, 0x00000008,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_attach_number_to_voice_tag,\r\n{ "Attach Number to Voice Tag", "bthfp.brsf.ag.attach_number_to_voice_tag",\r\nFT_BOOLEAN, 32, NULL, 0x00000010,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_ability_to_reject_a_call,\r\n{ "Ability to Reject a Call", "bthfp.brsf.ag.ability_to_reject_a_call",\r\nFT_BOOLEAN, 32, NULL, 0x00000020,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_enhanced_call_status,\r\n{ "Enhanced Call Status", "bthfp.brsf.ag.enhanced_call_status",\r\nFT_BOOLEAN, 32, NULL, 0x00000040,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_enhanced_call_control,\r\n{ "Enhanced Call Control", "bthfp.brsf.ag.enhanced_call_control",\r\nFT_BOOLEAN, 32, NULL, 0x00000080,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_extended_error_result_codes,\r\n{ "Extended Error Result Codes", "bthfp.brsf.ag.extended_error_result_codes",\r\nFT_BOOLEAN, 32, NULL, 0x00000100,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_codec_negotiation,\r\n{ "Codec Negotiation", "bthfp.brsf.ag.codec_negotiation",\r\nFT_BOOLEAN, 32, NULL, 0x00000200,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_hf_indicators,\r\n{ "HF Indicators", "bthfp.brsf.ag.hf_indicators",\r\nFT_BOOLEAN, 32, NULL, 0x00000400,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_esco_s4_t2_settings_support,\r\n{ "eSCO S4 (and T2) Settings Support","bthfp.brsf.ag.esco_s4_t2_settings_support",\r\nFT_BOOLEAN, 32, NULL, 0x00000800,\r\nNULL, HFILL}\r\n},\r\n{ &hf_brsf_ag_reserved,\r\n{ "Reserved", "bthfp.brsf.ag.reserved",\r\nFT_UINT32, BASE_HEX, NULL, 0xFFFFF000,\r\nNULL, HFILL}\r\n},\r\n{ &hf_vgs,\r\n{ "Gain", "bthfp.vgs",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_vgm,\r\n{ "Gain", "bthfp.vgm",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_nrec,\r\n{ "Noise Reduction", "bthfp.nrec",\r\nFT_UINT8, BASE_DEC, VALS(nrec_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bvra_vrect,\r\n{ "Voice Recognition", "bthfp.bvra.vrect",\r\nFT_UINT8, BASE_DEC, VALS(bvra_vrect_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bsir,\r\n{ "Feature", "bthfp.bsir",\r\nFT_UINT8, BASE_DEC, VALS(bsir_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_btrh,\r\n{ "Feature", "bthfp.btrh",\r\nFT_UINT8, BASE_DEC, VALS(btrh_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cmer_mode,\r\n{ "Mode", "bthfp.cmer.mode",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cmer_keyp,\r\n{ "Keypad", "bthfp.cmer.keyp",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cmer_disp,\r\n{ "Display", "bthfp.cmer.disp",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cmer_ind,\r\n{ "Indicator", "bthfp.cmer.ind",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cmer_bfr,\r\n{ "Buffer", "bthfp.cmer.bfr",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bac_codec,\r\n{ "Codec", "bthfp.bac.codec",\r\nFT_UINT8, BASE_DEC, VALS(codecs_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bcs_codec,\r\n{ "Codec", "bthfp.bcs.codec",\r\nFT_UINT8, BASE_DEC, VALS(codecs_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_binp_request,\r\n{ "Request", "bthfp.binp.request",\r\nFT_UINT8, BASE_DEC, VALS(binp_request_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_binp_response,\r\n{ "Response", "bthfp.binp.response",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cme_error,\r\n{ "CME Error", "bthfp.cme_error",\r\nFT_UINT8, BASE_DEC, VALS(cme_error_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cmee,\r\n{ "Mode", "bthfp.cmee",\r\nFT_UINT8, BASE_DEC, VALS(cmee_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_chld_mode,\r\n{ "Mode", "bthfp.chld.mode_value",\r\nFT_UINT8, BASE_DEC, VALS(chld_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_chld_mode_1x,\r\n{ "Mode: Releases specified active call only", "bthfp.chld.mode",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_chld_mode_2x,\r\n{ "Mode: Request private consultation mode with specified call - place all calls on hold EXCEPT the call indicated by x", "bthfp.chld.mode",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_chld_supported_modes,\r\n{ "Supported Modes", "bthfp.chld.supported_modes",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ciev_indicator_index,\r\n{ "Indicator Index", "bthfp.ciev.indicator_index",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_vts_dtmf,\r\n{ "DTMF", "bthfp.vts.dtmf",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_vts_duration,\r\n{ "Duration", "bthfp.vts.duration",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cops_mode,\r\n{ "Mode", "bthfp.cops.mode",\r\nFT_UINT8, BASE_DEC, VALS(cops_mode_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cops_format,\r\n{ "Format", "bthfp.cops.format",\r\nFT_UINT8, BASE_DEC, VALS(cops_format_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cops_operator,\r\n{ "Operator", "bthfp.cops.operator",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cops_act,\r\n{ "AcT", "bthfp.cops.act",\r\nFT_UINT8, BASE_DEC, VALS(cops_act_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_clip_mode,\r\n{ "Mode", "bthfp.clip.mode",\r\nFT_UINT8, BASE_DEC, VALS(clip_mode_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_clip_status,\r\n{ "Status", "bthfp.clip.status",\r\nFT_UINT8, BASE_DEC, VALS(clip_status_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_number,\r\n{ "Number", "bthfp.at.number",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_type,\r\n{ "Number", "bthfp.at.type",\r\nFT_UINT8, BASE_DEC | BASE_RANGE_STRING, RVALS(at_type_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_subaddress,\r\n{ "Subaddress", "bthfp.at.subaddress",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_subaddress_type,\r\n{ "Subaddress Type", "bthfp.at.subaddress_type",\r\nFT_UINT8, BASE_DEC | BASE_RANGE_STRING, RVALS(at_type_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cnum_speed,\r\n{ "Speed", "bthfp.cnum.speed",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING, &csd_data_rate_vals_ext, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cnum_service,\r\n{ "Service", "bthfp.cnum.service",\r\nFT_UINT8, BASE_DEC, VALS(cnum_service_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_cnum_itc,\r\n{ "Information Transfer Capability", "bthfp.cnum.itc",\r\nFT_UINT8, BASE_DEC, VALS(cnum_itc_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_alpha,\r\n{ "Alpha", "bthfp.at.alpha",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_cli_validity,\r\n{ "CLI Validity", "bthfp.at.cli_validity",\r\nFT_UINT8, BASE_DEC, VALS(cli_validity_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_at_priority,\r\n{ "Priority", "bthfp.at.priority",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_clcc_id,\r\n{ "ID", "bthfp.clcc.id",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_clcc_dir,\r\n{ "Direction", "bthfp.clcc.dir",\r\nFT_UINT32, BASE_DEC, VALS(clcc_dir_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_clcc_stat,\r\n{ "State", "bthfp.clcc.stat",\r\nFT_UINT32, BASE_DEC, VALS(clcc_stat_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_clcc_mode,\r\n{ "Mode", "bthfp.clcc.mode",\r\nFT_UINT32, BASE_DEC, VALS(clcc_mode_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_clcc_mpty,\r\n{ "Mpty", "bthfp.clcc.mpty",\r\nFT_UINT32, BASE_DEC, VALS(clcc_mpty_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ccwa_show_result_code,\r\n{ "Show Result Code Presentation Status", "bthfp.ccwa.presentaion_status",\r\nFT_UINT32, BASE_DEC, VALS(ccwa_show_result_code_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ccwa_mode,\r\n{ "Mode", "bthfp.ccwa.mode",\r\nFT_UINT32, BASE_DEC, VALS(ccwa_mode_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_ccwa_class,\r\n{ "Class", "bthfp.ccwa.class",\r\nFT_UINT32, BASE_DEC, VALS(ccwa_class_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_biev_assigned_number,\r\n{ "Assigned Number", "bthfp.biev.assigned_number",\r\nFT_UINT16, BASE_DEC, VALS(biev_assigned_number_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bind_parameter,\r\n{ "Parameter", "bthfp.bind.parameter",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_biev_value,\r\n{ "Value", "bthfp.biev.value",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[0],\r\n{ "Indicator 1", "bthfp.bia.indicator.1",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[1],\r\n{ "Indicator 2", "bthfp.bia.indicator.2",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[2],\r\n{ "Indicator 3", "bthfp.bia.indicator.3",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[3],\r\n{ "Indicator 4", "bthfp.bia.indicator.4",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[4],\r\n{ "Indicator 5", "bthfp.bia.indicator.5",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[5],\r\n{ "Indicator 6", "bthfp.bia.indicator.6",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[6],\r\n{ "Indicator 7", "bthfp.bia.indicator.7",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[7],\r\n{ "Indicator 8", "bthfp.bia.indicator.8",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[8],\r\n{ "Indicator 9", "bthfp.bia.indicator.9",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[9],\r\n{ "Indicator 10", "bthfp.bia.indicator.10",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[10],\r\n{ "Indicator 11", "bthfp.bia.indicator.11",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[11],\r\n{ "Indicator 12", "bthfp.bia.indicator.12",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[12],\r\n{ "Indicator 13", "bthfp.bia.indicator.13",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[13],\r\n{ "Indicator 14", "bthfp.bia.indicator.14",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[14],\r\n{ "Indicator 15", "bthfp.bia.indicator.15",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[15],\r\n{ "Indicator 16", "bthfp.bia.indicator.16",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[16],\r\n{ "Indicator 17", "bthfp.bia.indicator.17",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[17],\r\n{ "Indicator 18", "bthfp.bia.indicator.18",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[18],\r\n{ "Indicator 19", "bthfp.bia.indicator.19",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_bia_indicator[19],\r\n{ "Indicator 20", "bthfp.bia.indicator.20",\r\nFT_UINT8, BASE_DEC, VALS(indicator_vals), 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[0],\r\n{ "Indicator 1", "bthfp.indicator.1",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[1],\r\n{ "Indicator 2", "bthfp.indicator.2",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[2],\r\n{ "Indicator 3", "bthfp.indicator.3",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[3],\r\n{ "Indicator 4", "bthfp.indicator.4",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[4],\r\n{ "Indicator 5", "bthfp.indicator.5",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[5],\r\n{ "Indicator 6", "bthfp.indicator.6",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[6],\r\n{ "Indicator 7", "bthfp.indicator.7",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[7],\r\n{ "Indicator 8", "bthfp.indicator.8",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[8],\r\n{ "Indicator 9", "bthfp.indicator.9",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[9],\r\n{ "Indicator 10", "bthfp.indicator.10",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[10],\r\n{ "Indicator 11", "bthfp.indicator.11",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[11],\r\n{ "Indicator 12", "bthfp.indicator.12",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[12],\r\n{ "Indicator 13", "bthfp.indicator.13",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[13],\r\n{ "Indicator 14", "bthfp.indicator.14",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[14],\r\n{ "Indicator 15", "bthfp.indicator.15",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[15],\r\n{ "Indicator 16", "bthfp.indicator.16",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[16],\r\n{ "Indicator 17", "bthfp.indicator.17",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[17],\r\n{ "Indicator 18", "bthfp.indicator.18",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[18],\r\n{ "Indicator 19", "bthfp.indicator.19",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_indicator[19],\r\n{ "Indicator 20", "bthfp.indicator.20",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL}\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_non_mandatory_command, { "bthfp.expert.non_mandatory_command", PI_PROTOCOL, PI_NOTE, "Non-mandatory command in HFP", EXPFILL }},\r\n{ &ei_invalid_usage, { "bthfp.expert.invalid_usage", PI_PROTOCOL, PI_WARN, "Non mandatory type or command in this role", EXPFILL }},\r\n{ &ei_unknown_parameter, { "bthfp.expert.unknown_parameter", PI_PROTOCOL, PI_WARN, "Unknown parameter", EXPFILL }},\r\n{ &ei_brfs_hs_reserved_bits, { "bthfp.expert.brsf.hs.reserved_bits", PI_PROTOCOL, PI_WARN, "The reserved bits [8-31] shall be initialized to Zero", EXPFILL }},\r\n{ &ei_brfs_ag_reserved_bits, { "bthfp.expert.brsf.ag.reserved_bits", PI_PROTOCOL, PI_WARN, "The reserved bits [10-31] shall be initialized to Zero", EXPFILL }},\r\n{ &ei_vgm_gain, { "bthfp.expert.vgm", PI_PROTOCOL, PI_WARN, "Gain of microphone exceeds range 0-15", EXPFILL }},\r\n{ &ei_vgs_gain, { "bthfp.expert.vgs", PI_PROTOCOL, PI_WARN, "Gain of speaker exceeds range 0-15", EXPFILL }},\r\n{ &ei_nrec, { "bthfp.expert.nrec", PI_PROTOCOL, PI_WARN, "Only 0 is valid", EXPFILL }},\r\n{ &ei_bvra, { "bthfp.expert.bvra", PI_PROTOCOL, PI_WARN, "Only 0-1 is valid", EXPFILL }},\r\n{ &ei_bcs, { "bthfp.expert.bcs", PI_PROTOCOL, PI_NOTE, "Reserved value", EXPFILL }},\r\n{ &ei_bac, { "bthfp.expert.bac", PI_PROTOCOL, PI_NOTE, "Reserved value", EXPFILL }},\r\n{ &ei_bsir, { "bthfp.expert.bsir", PI_PROTOCOL, PI_WARN, "Only 0-1 is valid", EXPFILL }},\r\n{ &ei_btrh, { "bthfp.expert.btrh", PI_PROTOCOL, PI_WARN, "Only 0-2 is valid", EXPFILL }},\r\n{ &ei_binp, { "bthfp.expert.binp", PI_PROTOCOL, PI_WARN, "Only 1 is valid", EXPFILL }},\r\n{ &ei_bia, { "bthfp.expert.bia", PI_PROTOCOL, PI_WARN, "Only 0-1 is valid", EXPFILL }},\r\n{ &ei_biev_assigned_number, { "bthfp.expert.biev.assigned_number", PI_PROTOCOL, PI_WARN, "Only 0-65535 is valid", EXPFILL }},\r\n{ &ei_biev_assigned_number_no, { "bthfp.expert.biev.assigned_number.not_assigned", PI_PROTOCOL, PI_WARN, "Value is unknown for Assign Numbers", EXPFILL }},\r\n{ &ei_cmer_mode, { "bthfp.expert.cmer.mode", PI_PROTOCOL, PI_NOTE, "Only 3 is valid for HFP", EXPFILL }},\r\n{ &ei_cmer_disp, { "bthfp.expert.cmer.disp", PI_PROTOCOL, PI_WARN, "Value is ignored for HFP", EXPFILL }},\r\n{ &ei_cmer_keyp, { "bthfp.expert.cmer.keyp", PI_PROTOCOL, PI_WARN, "Value is ignored for HFP", EXPFILL }},\r\n{ &ei_cmer_ind, { "bthfp.expert.cmer.ind", PI_PROTOCOL, PI_NOTE, "Only 0-1 is valid for HFP", EXPFILL }},\r\n{ &ei_cmer_btr, { "bthfp.expert.cmer.btr", PI_PROTOCOL, PI_WARN, "Value is ignored for HFP", EXPFILL }},\r\n{ &ei_chld_mode, { "bthfp.expert.chld.mode", PI_PROTOCOL, PI_WARN, "Invalid value for HFP", EXPFILL }},\r\n{ &ei_ciev_indicator, { "bthfp.expert.ciev.indicator", PI_PROTOCOL, PI_WARN, "Unknown indicator", EXPFILL }},\r\n{ &ei_vts_dtmf, { "bthfp.expert.vts.dtmf", PI_PROTOCOL, PI_WARN, "DTMF should be single character", EXPFILL }},\r\n{ &ei_at_type, { "bthfp.expert.at.type", PI_PROTOCOL, PI_WARN, "Unknown type value", EXPFILL }},\r\n{ &ei_parameter_blank, { "bthfp.expert.parameter_blank", PI_PROTOCOL, PI_WARN, "Should be blank for HFP", EXPFILL }},\r\n{ &ei_cnum_service, { "bthfp.expert.cnum.service", PI_PROTOCOL, PI_WARN, "Only 0-5 is valid", EXPFILL }},\r\n{ &ei_cnum_itc, { "bthfp.expert.cnum.itc", PI_PROTOCOL, PI_WARN, "Only 0-1 is valid", EXPFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_bthfp,\r\n&ett_bthfp_brsf_hf,\r\n&ett_bthfp_brsf_ag,\r\n&ett_bthfp_command,\r\n&ett_bthfp_parameters\r\n};\r\nfragments = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\nproto_bthfp = proto_register_protocol("Bluetooth HFP Profile", "BT HFP", "bthfp");\r\nbthfp_handle = register_dissector("bthfp", dissect_bthfp, proto_bthfp);\r\nproto_register_field_array(proto_bthfp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nmodule = prefs_register_protocol(proto_bthfp, NULL);\r\nprefs_register_static_text_preference(module, "hfp.version",\r\n"Bluetooth Profile HFP version: 1.7",\r\n"Version of profile supported by this dissector.");\r\nprefs_register_enum_preference(module, "hfp.hfp_role",\r\n"Force treat packets as AG or HS role",\r\n"Force treat packets as AG or HS role",\r\n&hfp_role, pref_hfp_role, TRUE);\r\nexpert_bthfp = expert_register_protocol(proto_bthfp);\r\nexpert_register_field_array(expert_bthfp, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_bthfp(void)\r\n{\r\ndissector_add_string("bluetooth.uuid", "111e", bthfp_handle);\r\ndissector_add_string("bluetooth.uuid", "111f", bthfp_handle);\r\ndissector_add_for_decode_as("btrfcomm.dlci", bthfp_handle);\r\n}
