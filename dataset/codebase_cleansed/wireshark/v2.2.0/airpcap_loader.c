static gchar *\r\ncant_get_airpcap_if_list_error_message(const char *err_str)\r\n{\r\nreturn g_strdup_printf("Can't get list of Wireless interfaces: %s", err_str);\r\n}\r\ngboolean\r\nairpcap_if_store_cur_config_as_adapter_default(PAirpcapHandle ah)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapStoreCurConfigAsAdapterDefault(ah);\r\n}\r\nPAirpcapHandle\r\nairpcap_if_open(gchar * name, gchar * err)\r\n{\r\nif (!AirpcapLoaded) return NULL;\r\nif (name == NULL) return NULL;\r\nreturn g_PAirpcapOpen(name,err);\r\n}\r\nvoid\r\nairpcap_if_close(PAirpcapHandle handle)\r\n{\r\nif (!AirpcapLoaded) return;\r\ng_PAirpcapClose(handle);\r\n}\r\nint\r\nairpcap_get_dll_state(void)\r\n{\r\nreturn AirpcapVersion;\r\n}\r\ngboolean\r\nairpcap_if_turn_led_on(PAirpcapHandle AdapterHandle, guint LedNumber)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapTurnLedOn(AdapterHandle,LedNumber);\r\n}\r\ngboolean\r\nairpcap_if_turn_led_off(PAirpcapHandle AdapterHandle, guint LedNumber)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapTurnLedOff(AdapterHandle,LedNumber);\r\n}\r\ngboolean\r\nairpcap_if_get_device_channel(PAirpcapHandle ah, guint * ch)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapGetDeviceChannel(ah,ch);\r\n}\r\ngboolean\r\nairpcap_if_get_device_supported_channels(PAirpcapHandle ah, AirpcapChannelInfo **cInfo, guint * nInfo)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nif (airpcap_get_dll_state() == AIRPCAP_DLL_OLD) {\r\n*nInfo = num_legacy_channels;\r\n*cInfo = (AirpcapChannelInfo*)&LegacyChannels;\r\nreturn TRUE;\r\n} else if (airpcap_get_dll_state() == AIRPCAP_DLL_OK) {\r\nreturn g_PAirpcapGetDeviceSupportedChannels(ah, cInfo, nInfo);\r\n}\r\nreturn FALSE;\r\n}\r\nDot11Channel*\r\nairpcap_if_get_device_supported_channels_array(PAirpcapHandle ah, guint * pNumSupportedChannels)\r\n{\r\nAirpcapChannelInfo *chanInfo;\r\nguint i=0, j=0, numInfo = 0;\r\nif (!AirpcapLoaded)\r\nreturn NULL;\r\nif (airpcap_if_get_device_supported_channels(ah, &chanInfo, &numInfo) == FALSE)\r\nreturn NULL;\r\nnumSupportedChannels = 0;\r\nif (numInfo == 0)\r\nreturn NULL;\r\npSupportedChannels = (Dot11Channel *)g_malloc(numInfo * (sizeof *pSupportedChannels));\r\nfor (i = 0; i < numInfo; i++)\r\n{\r\nguint supportedChannel = G_MAXUINT;\r\nfor (j = 0; j < numSupportedChannels; j++)\r\n{\r\nif (pSupportedChannels[j].Frequency == chanInfo[i].Frequency)\r\n{\r\nsupportedChannel = j;\r\nbreak;\r\n}\r\n}\r\nif (supportedChannel == G_MAXUINT)\r\n{\r\npSupportedChannels[numSupportedChannels].Frequency = chanInfo[i].Frequency;\r\nswitch(chanInfo[i].ExtChannel)\r\n{\r\ncase -1:\r\npSupportedChannels[numSupportedChannels].Flags = FLAG_CAN_BE_LOW;\r\nbreak;\r\ncase +1:\r\npSupportedChannels[numSupportedChannels].Flags = FLAG_CAN_BE_HIGH;\r\nbreak;\r\ncase 0:\r\ndefault:\r\npSupportedChannels[numSupportedChannels].Flags = 0;\r\n}\r\npSupportedChannels[numSupportedChannels].Flags |=\r\nFREQ_IS_BG(pSupportedChannels[numSupportedChannels].Frequency) ?\r\nFLAG_IS_BG_CHANNEL : FLAG_IS_A_CHANNEL;\r\npSupportedChannels[numSupportedChannels].Channel =\r\nieee80211_mhz_to_chan(pSupportedChannels[numSupportedChannels].Frequency);\r\nnumSupportedChannels++;\r\n}\r\nelse\r\n{\r\nswitch(chanInfo[i].ExtChannel)\r\n{\r\ncase -1:\r\npSupportedChannels[supportedChannel].Flags |= FLAG_CAN_BE_LOW;\r\nbreak;\r\ncase +1:\r\npSupportedChannels[supportedChannel].Flags |= FLAG_CAN_BE_HIGH;\r\nbreak;\r\ncase 0:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nif (numSupportedChannels < 1)\r\nreturn NULL;\r\nfor (i = 0 ; i < numSupportedChannels - 1; i++)\r\n{\r\nfor (j = i + 1; j < numSupportedChannels; j++)\r\n{\r\nif (pSupportedChannels[i].Frequency > pSupportedChannels[j].Frequency)\r\n{\r\nDot11Channel temp = pSupportedChannels[i];\r\npSupportedChannels[i] = pSupportedChannels[j];\r\npSupportedChannels[j] = temp;\r\n}\r\n}\r\n}\r\n*pNumSupportedChannels = numSupportedChannels;\r\nreturn pSupportedChannels;\r\n}\r\ngboolean\r\nairpcap_if_set_device_channel(PAirpcapHandle ah, guint ch)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapSetDeviceChannel(ah,ch);\r\n}\r\ngboolean\r\nairpcap_if_set_device_channel_ex(PAirpcapHandle ah, AirpcapChannelInfo ChannelInfo)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nif (airpcap_get_dll_state() == AIRPCAP_DLL_OLD){\r\ngint channel = 0;\r\nchannel = ieee80211_mhz_to_chan(ChannelInfo.Frequency);\r\nif (channel < 0){\r\nreturn FALSE;\r\n} else {\r\nreturn airpcap_if_set_device_channel(ah, channel);\r\n}\r\n} else if (airpcap_get_dll_state() == AIRPCAP_DLL_OK){\r\nreturn g_PAirpcapSetDeviceChannelEx (ah, ChannelInfo);\r\n}\r\nreturn FALSE;\r\n}\r\ngboolean\r\nairpcap_if_get_device_channel_ex(PAirpcapHandle ah, PAirpcapChannelInfo pChannelInfo)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\npChannelInfo->Frequency = 0;\r\npChannelInfo->ExtChannel = 0;\r\npChannelInfo->Reserved[0] = 0;\r\npChannelInfo->Reserved[1] = 0;\r\npChannelInfo->Reserved[2] = 0;\r\nif (airpcap_get_dll_state() == AIRPCAP_DLL_OLD){\r\nguint channel = 0;\r\nguint chan_freq = 0;\r\nif (!airpcap_if_get_device_channel(ah, &channel)) return FALSE;\r\nchan_freq = ieee80211_chan_to_mhz(channel, TRUE);\r\nif (chan_freq == 0) return FALSE;\r\npChannelInfo->Frequency = chan_freq;\r\nreturn TRUE;\r\n} else if (airpcap_get_dll_state() == AIRPCAP_DLL_OK){\r\nreturn g_PAirpcapGetDeviceChannelEx (ah, pChannelInfo);\r\n}\r\nreturn FALSE;\r\n}\r\ngboolean\r\nairpcap_if_get_link_type(PAirpcapHandle ah, PAirpcapLinkType lt)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapGetLinkType(ah,lt);\r\n}\r\ngboolean\r\nairpcap_if_set_link_type(PAirpcapHandle ah, AirpcapLinkType lt)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapSetLinkType(ah,lt);\r\n}\r\ngboolean\r\nairpcap_if_get_fcs_presence(PAirpcapHandle ah, gboolean * fcs)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapGetFcsPresence(ah,fcs);\r\n}\r\ngboolean\r\nairpcap_if_set_fcs_presence(PAirpcapHandle ah, gboolean fcs)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapSetFcsPresence(ah,fcs);\r\n}\r\ngboolean\r\nairpcap_if_get_decryption_state(PAirpcapHandle ah, PAirpcapDecryptionState PEnable)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapGetDecryptionState(ah,PEnable);\r\n}\r\ngboolean\r\nairpcap_if_set_decryption_state(PAirpcapHandle ah, AirpcapDecryptionState Enable)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapSetDecryptionState(ah,Enable);\r\n}\r\ngboolean\r\nairpcap_if_get_driver_decryption_state(PAirpcapHandle ah, PAirpcapDecryptionState PEnable)\r\n{\r\nif (!AirpcapLoaded || (g_PAirpcapGetDriverDecryptionState==NULL)) return FALSE;\r\nreturn g_PAirpcapGetDriverDecryptionState(ah,PEnable);\r\n}\r\ngboolean\r\nairpcap_if_set_driver_decryption_state(PAirpcapHandle ah, AirpcapDecryptionState Enable)\r\n{\r\nif (!AirpcapLoaded || (g_PAirpcapSetDriverDecryptionState==NULL)) return FALSE;\r\nreturn g_PAirpcapSetDriverDecryptionState(ah,Enable);\r\n}\r\ngboolean\r\nairpcap_if_get_fcs_validation(PAirpcapHandle ah, PAirpcapValidationType val)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapGetFcsValidation(ah,val);\r\n}\r\ngboolean\r\nairpcap_if_set_fcs_validation(PAirpcapHandle ah, AirpcapValidationType val)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapSetFcsValidation(ah,val);\r\n}\r\ngboolean\r\nairpcap_if_set_device_keys(PAirpcapHandle AdapterHandle, PAirpcapKeysCollection KeysCollection)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapSetDeviceKeys(AdapterHandle,KeysCollection);\r\n}\r\ngboolean\r\nairpcap_if_get_device_keys(PAirpcapHandle AdapterHandle, PAirpcapKeysCollection KeysCollection, guint * PKeysCollectionSize)\r\n{\r\nif (!AirpcapLoaded) return FALSE;\r\nreturn g_PAirpcapGetDeviceKeys(AdapterHandle,KeysCollection,PKeysCollectionSize);\r\n}\r\ngboolean\r\nairpcap_if_set_driver_keys(PAirpcapHandle AdapterHandle, PAirpcapKeysCollection KeysCollection)\r\n{\r\nif (!AirpcapLoaded || (g_PAirpcapSetDriverKeys==NULL)) return FALSE;\r\nreturn g_PAirpcapSetDriverKeys(AdapterHandle,KeysCollection);\r\n}\r\ngboolean\r\nairpcap_if_get_driver_keys(PAirpcapHandle AdapterHandle, PAirpcapKeysCollection KeysCollection, guint * PKeysCollectionSize)\r\n{\r\nif (!AirpcapLoaded || (g_PAirpcapGetDriverKeys==NULL)) return FALSE;\r\nreturn g_PAirpcapGetDriverKeys(AdapterHandle,KeysCollection,PKeysCollectionSize);\r\n}\r\nairpcap_if_info_t *\r\nairpcap_if_info_new(char *name, char *description)\r\n{\r\nPAirpcapHandle ad;\r\ngchar ebuf[AIRPCAP_ERRBUF_SIZE];\r\nairpcap_if_info_t *if_info = NULL;\r\nad = airpcap_if_open(name, ebuf);\r\nif (ad)\r\n{\r\nif_info = (airpcap_if_info_t *)g_malloc0(sizeof (airpcap_if_info_t));\r\nif_info->name = g_strdup(name);\r\nif (description == NULL){\r\nif_info->description = NULL;\r\n}else{\r\nif_info->description = g_strdup(description);\r\n}\r\nif_info->ip_addr = NULL;\r\nif_info->loopback = FALSE;\r\nairpcap_if_get_fcs_validation(ad,&(if_info->CrcValidationOn));\r\nairpcap_if_get_fcs_presence(ad,&(if_info->IsFcsPresent));\r\nairpcap_if_get_link_type(ad,&(if_info->linkType));\r\nairpcap_if_get_device_channel_ex(ad,&(if_info->channelInfo));\r\nif_info->pSupportedChannels = airpcap_if_get_device_supported_channels_array(ad, &(if_info->numSupportedChannels));\r\nairpcap_if_turn_led_on(ad, 0);\r\nairpcap_if_get_decryption_state(ad, &(if_info->DecryptionOn));\r\nif_info->led = TRUE;\r\nif_info->blinking = FALSE;\r\nif_info->saved = TRUE;\r\nif (airpcap_if_load_keys(ad,if_info))\r\n{\r\nairpcap_if_close(ad);\r\n}\r\n}\r\nreturn if_info;\r\n}\r\nairpcap_if_info_t*\r\nairpcap_driver_fake_if_info_new(void)\r\n{\r\nPAirpcapHandle ad;\r\ngchar ebuf[AIRPCAP_ERRBUF_SIZE];\r\nairpcap_if_info_t *if_info = NULL;\r\nairpcap_if_info_t *fake_if_info = NULL;\r\nif (g_airpcap_if_list == NULL)\r\nreturn NULL;\r\nif_info = (airpcap_if_info_t *)g_list_nth_data(g_airpcap_if_list,0);\r\nif (if_info == NULL)\r\nreturn NULL;\r\nad = airpcap_if_open(if_info->name, ebuf);\r\nif (ad)\r\n{\r\nfake_if_info = (airpcap_if_info_t *)g_malloc(sizeof (airpcap_if_info_t));\r\nfake_if_info->name = g_strdup(if_info->name);\r\nfake_if_info->description = g_strdup(if_info->description);\r\nfake_if_info->loopback = FALSE;\r\nfake_if_info->ip_addr = NULL;\r\nairpcap_if_get_driver_decryption_state(ad, &(fake_if_info->DecryptionOn));\r\nairpcap_if_get_fcs_validation(ad,&(fake_if_info->CrcValidationOn));\r\nairpcap_if_get_fcs_presence(ad,&(fake_if_info->IsFcsPresent));\r\nairpcap_if_get_link_type(ad,&(fake_if_info->linkType));\r\nairpcap_if_get_device_channel_ex(ad,&(fake_if_info->channelInfo));\r\nairpcap_if_turn_led_on(ad, 0);\r\nfake_if_info->led = TRUE;\r\nfake_if_info->blinking = FALSE;\r\nfake_if_info->saved = TRUE;\r\nif (airpcap_if_load_driver_keys(ad,fake_if_info))\r\n{\r\nairpcap_if_close(ad);\r\n}\r\n}\r\nreturn fake_if_info;\r\n}\r\nvoid\r\nairpcap_if_info_print(airpcap_if_info_t* if_info)\r\n{\r\nguint i;\r\nif (if_info == NULL)\r\n{\r\ng_print("\nWARNING : AirPcap Interface pointer is NULL!\n");\r\nreturn;\r\n}\r\ng_print("\n----------------- AirPcap Interface \n");\r\ng_print(" NAME: %s\n",if_info->name);\r\ng_print(" DESCRIPTION: %s\n",if_info->description);\r\ng_print(" BLINKING: %s\n",if_info->blinking ? "TRUE" : "FALSE");\r\ng_print(" channelInfo.Frequency: %u\n",if_info->channelInfo.Frequency);\r\ng_print(" channelInfo.ExtChannel: %d\n",if_info->channelInfo.ExtChannel);\r\ng_print(" CRCVALIDATION: %s\n",if_info->CrcValidationOn ? "ON" : "OFF");\r\ng_print(" DECRYPTION: %s\n",if_info->DecryptionOn ? "ON" : "OFF");\r\ng_print(" IP ADDR: %s\n",if_info->ip_addr!=NULL ? "NOT NULL" : "NULL");\r\ng_print(" FCSPRESENT: %s\n",if_info->IsFcsPresent ? "TRUE" : "FALSE");\r\ng_print(" KEYSCOLLECTION: %s\n",if_info->keysCollection!=NULL ? "NOT NULL" : "NULL");\r\ng_print(" KEYSCOLLECTIONSIZE: %u\n",if_info->keysCollectionSize);\r\ng_print(" LED: %s\n",if_info->led ? "ON" : "OFF");\r\ng_print(" LINKTYPE: %d\n",if_info->linkType);\r\ng_print(" LOOPBACK: %s\n",if_info->loopback ? "YES" : "NO");\r\ng_print(" (GTK) TAG: %d\n",if_info->tag);\r\ng_print("SUPPORTED CHANNELS POINTER: %p\n",if_info->pSupportedChannels);\r\ng_print(" NUM SUPPORTED CHANNELS: %u\n",if_info->numSupportedChannels);\r\nfor(i=0; i<(if_info->numSupportedChannels); i++){\r\ng_print("\n SUPPORTED CHANNEL #%u\n",i+1);\r\ng_print(" CHANNEL: %u\n",if_info->pSupportedChannels[i].Channel);\r\ng_print(" FREQUENCY: %u\n",if_info->pSupportedChannels[i].Frequency);\r\ng_print(" FLAGS: %u\n",if_info->pSupportedChannels[i].Flags);\r\n}\r\ng_print("\n\n");\r\n}\r\ngboolean\r\nairpcap_if_load_keys(PAirpcapHandle ad, airpcap_if_info_t *if_info)\r\n{\r\nif (!if_info) return FALSE;\r\nif_info->keysCollectionSize = 0;\r\nif_info->keysCollection = NULL;\r\nif (!airpcap_if_get_device_keys(ad, NULL, &(if_info->keysCollectionSize)))\r\n{\r\nif (if_info->keysCollectionSize == 0)\r\n{\r\nif_info->keysCollection = NULL;\r\nairpcap_if_close(ad);\r\nreturn FALSE;\r\n}\r\nif_info->keysCollection = (PAirpcapKeysCollection)g_malloc(if_info->keysCollectionSize);\r\nif (!if_info->keysCollection)\r\n{\r\nif_info->keysCollectionSize = 0;\r\nif_info->keysCollection = NULL;\r\nairpcap_if_close(ad);\r\nreturn FALSE;\r\n}\r\nairpcap_if_get_device_keys(ad, if_info->keysCollection, &(if_info->keysCollectionSize));\r\nreturn TRUE;\r\n}\r\nairpcap_if_close(ad);\r\nreturn FALSE;\r\n}\r\ngboolean\r\nairpcap_if_load_driver_keys(PAirpcapHandle ad, airpcap_if_info_t *if_info)\r\n{\r\nif_info->keysCollectionSize = 0;\r\nif_info->keysCollection = NULL;\r\nif (!airpcap_if_get_driver_keys(ad, NULL, &(if_info->keysCollectionSize)))\r\n{\r\nif (if_info->keysCollectionSize == 0)\r\n{\r\nif_info->keysCollection = NULL;\r\nairpcap_if_close(ad);\r\nreturn FALSE;\r\n}\r\nif_info->keysCollection = (PAirpcapKeysCollection)g_malloc(if_info->keysCollectionSize);\r\nif (!if_info->keysCollection)\r\n{\r\nif_info->keysCollectionSize = 0;\r\nif_info->keysCollection = NULL;\r\nairpcap_if_close(ad);\r\nreturn FALSE;\r\n}\r\nairpcap_if_get_driver_keys(ad, if_info->keysCollection, &(if_info->keysCollectionSize));\r\nreturn TRUE;\r\n}\r\nairpcap_if_close(ad);\r\nreturn FALSE;\r\n}\r\nvoid\r\nairpcap_if_save_keys(PAirpcapHandle ad, airpcap_if_info_t *if_info)\r\n{\r\nif (!if_info || !AirpcapLoaded) return;\r\nif (if_info->keysCollection != NULL)\r\ng_PAirpcapSetDeviceKeys(ad,if_info->keysCollection);\r\n}\r\nvoid\r\nairpcap_if_save_driver_keys(PAirpcapHandle ad, airpcap_if_info_t *if_info)\r\n{\r\nif (if_info->keysCollection != NULL)\r\nairpcap_if_set_driver_keys(ad,if_info->keysCollection);\r\n}\r\nstatic void\r\nfree_airpcap_if_cb(gpointer data, gpointer user_data _U_)\r\n{\r\nairpcap_if_info_t *if_info = (airpcap_if_info_t *)data;\r\nif (NULL == if_info)\r\nreturn;\r\nif (if_info->name != NULL)\r\ng_free(if_info->name);\r\nif (if_info->description != NULL)\r\ng_free(if_info->description);\r\nif (if_info->keysCollection != NULL)\r\n{\r\ng_free(if_info->keysCollection);\r\nif_info->keysCollection = NULL;\r\n}\r\nif (if_info->ip_addr != NULL)\r\ng_slist_free(if_info->ip_addr);\r\ng_free(if_info);\r\n}\r\nvoid\r\nfree_airpcap_interface_list(GList *if_list)\r\n{\r\ng_list_foreach(if_list, free_airpcap_if_cb, NULL);\r\ng_list_free(if_list);\r\n}\r\nGList*\r\nget_airpcap_interface_list(int *err, char **err_str)\r\n{\r\nGList *il = NULL;\r\nairpcap_if_info_t *if_info;\r\nint n_adapts;\r\nAirpcapDeviceDescription *devsList, *adListEntry;\r\nchar errbuf[AIRPCAP_ERRBUF_SIZE];\r\n*err = 0;\r\nif (!AirpcapLoaded)\r\n{\r\n*err = AIRPCAP_NOT_LOADED;\r\nreturn il;\r\n}\r\nif (!g_PAirpcapGetDeviceList(&devsList, errbuf))\r\n{\r\n*err = CANT_GET_AIRPCAP_INTERFACE_LIST;\r\nif (err_str != NULL)\r\n*err_str = cant_get_airpcap_if_list_error_message(errbuf);\r\nreturn il;\r\n}\r\nadListEntry = devsList;\r\nn_adapts = 0;\r\nwhile(adListEntry)\r\n{\r\nn_adapts++;\r\nadListEntry = adListEntry->next;\r\n}\r\nif (n_adapts == 0)\r\n{\r\ng_PAirpcapFreeDeviceList(devsList);\r\n*err = NO_AIRPCAP_INTERFACES_FOUND;\r\nif (err_str != NULL)\r\n*err_str = NULL;\r\nreturn il;\r\n}\r\nadListEntry = devsList;\r\nwhile(adListEntry)\r\n{\r\nif_info = airpcap_if_info_new(adListEntry->Name, adListEntry->Description);\r\nif (if_info != NULL){\r\nil = g_list_append(il, if_info);\r\n}\r\nadListEntry = adListEntry->next;\r\n}\r\ng_PAirpcapFreeDeviceList(devsList);\r\nreturn il;\r\n}\r\nairpcap_if_info_t* get_airpcap_if_from_name(GList* if_list, const gchar* name)\r\n{\r\nGList* curr;\r\nairpcap_if_info_t* if_info;\r\nfor (curr = g_list_first(if_list); curr; curr = g_list_next(curr)) {\r\nif_info = (airpcap_if_info_t *)curr->data;\r\nif (if_info && (g_ascii_strcasecmp(if_info->name, name) == 0)) {\r\nreturn (if_info);\r\n}\r\nif (strlen(if_info->name) > 4 && (g_ascii_strcasecmp(if_info->name + 4, name) == 0)) {\r\nreturn (if_info);\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nvoid\r\nairpcap_if_clear_decryption_settings(airpcap_if_info_t* info_if)\r\n{\r\nif (info_if != NULL)\r\n{\r\nif (info_if->keysCollection != NULL)\r\n{\r\ng_free(info_if->keysCollection);\r\ninfo_if->keysCollection = NULL;\r\n}\r\ninfo_if->keysCollectionSize = 0;\r\ninfo_if->DecryptionOn = AIRPCAP_DECRYPTION_OFF;\r\ninfo_if->saved = FALSE;\r\n}\r\n}\r\ngchar*\r\nairpcap_get_if_string_number(airpcap_if_info_t* if_info)\r\n{\r\ngchar* number;\r\nguint n;\r\nint a;\r\na = sscanf(if_info->name,AIRPCAP_DEVICE_NUMBER_EXTRACT_STRING,&n);\r\nif (a == 0)\r\n{\r\nif (g_ascii_strcasecmp(if_info->name,AIRPCAP_DEVICE_ANY_EXTRACT_STRING)!=0)\r\nnumber = g_strdup("??");\r\nelse\r\nnumber = g_strdup(AIRPCAP_CHANNEL_ANY_NAME);\r\n}\r\nelse\r\n{\r\nnumber = g_strdup_printf("%.2u",n);\r\n}\r\nreturn number;\r\n}\r\ngchar*\r\nairpcap_get_if_string_number_from_description(gchar* description)\r\n{\r\ngchar* number;\r\ngchar* pointer;\r\nnumber = (gchar*)g_malloc(sizeof(gchar)*3);\r\npointer = g_strrstr(description,"#\0");\r\nnumber[0] = *(pointer+1);\r\nnumber[1] = *(pointer+2);\r\nnumber[2] = '\0';\r\nreturn number;\r\n}\r\nvoid\r\nairpcap_load_selected_if_configuration(airpcap_if_info_t* if_info)\r\n{\r\ngchar ebuf[AIRPCAP_ERRBUF_SIZE];\r\nPAirpcapHandle ad;\r\nif (if_info != NULL)\r\n{\r\nad = airpcap_if_open(if_info->name, ebuf);\r\nif (ad)\r\n{\r\nif (if_info->blinking)\r\n{\r\nif (!(if_info->led)) airpcap_if_turn_led_on(ad, 0);\r\n}\r\nairpcap_if_get_device_channel_ex(ad,&(if_info->channelInfo));\r\nairpcap_if_get_fcs_validation(ad,&(if_info->CrcValidationOn));\r\nairpcap_if_get_fcs_presence(ad,&(if_info->IsFcsPresent));\r\nairpcap_if_get_link_type(ad,&(if_info->linkType));\r\nairpcap_if_get_decryption_state(ad, &(if_info->DecryptionOn));\r\nif (airpcap_if_load_keys(ad,if_info))\r\nairpcap_if_close(ad);\r\nif_info->saved = TRUE;\r\n}\r\n#if 0\r\nelse\r\n{\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, " Error in opening adapter for %s",if_info->description);\r\n}\r\n#endif\r\n}\r\n}\r\nvoid\r\nairpcap_save_selected_if_configuration(airpcap_if_info_t* if_info)\r\n{\r\ngchar ebuf[AIRPCAP_ERRBUF_SIZE];\r\nPAirpcapHandle ad;\r\nif (if_info != NULL)\r\n{\r\nad = airpcap_if_open(if_info->name, ebuf);\r\nif (ad)\r\n{\r\nif (if_info->blinking)\r\n{\r\nif (!(if_info->led)) airpcap_if_turn_led_on(ad, 0);\r\n}\r\nairpcap_if_set_device_channel_ex(ad,if_info->channelInfo);\r\nairpcap_if_set_fcs_validation(ad,if_info->CrcValidationOn);\r\nairpcap_if_set_fcs_presence(ad,if_info->IsFcsPresent);\r\nairpcap_if_set_link_type(ad,if_info->linkType);\r\nairpcap_if_set_decryption_state(ad, if_info->DecryptionOn);\r\nairpcap_if_save_keys(ad,if_info);\r\nif (!airpcap_if_store_cur_config_as_adapter_default(ad))\r\n{\r\n#if 0\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "Cannot save Wireless configuration!!!\nRemember that in order to store the configuration in the registry you have to:\n\n- Close all the airpcap-based applications.\n- Be sure to have administrative privileges.");\r\n#endif\r\nif_info->saved = FALSE;\r\nairpcap_if_close(ad);\r\nreturn;\r\n}\r\nif_info->saved = TRUE;\r\nairpcap_if_close(ad);\r\n}\r\n#if 0\r\nelse\r\n{\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, " Error in opening adapter for %s",if_info->description);\r\n}\r\n#endif\r\n}\r\n}\r\nvoid\r\nairpcap_save_driver_if_configuration(airpcap_if_info_t* fake_if_info)\r\n{\r\ngchar ebuf[AIRPCAP_ERRBUF_SIZE];\r\nPAirpcapHandle ad;\r\nif (fake_if_info != NULL)\r\n{\r\nad = airpcap_if_open(fake_if_info->name, ebuf);\r\nif (ad)\r\n{\r\nairpcap_if_set_driver_decryption_state(ad, fake_if_info->DecryptionOn);\r\nairpcap_if_save_driver_keys(ad,fake_if_info);\r\nairpcap_if_close(ad);\r\n}\r\n#if 0\r\nelse\r\n{\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, " Error in opening adapter for %s",fake_if_info->description);\r\n}\r\n#endif\r\n}\r\nreturn;\r\n}\r\nvoid\r\nairpcap_if_info_free(airpcap_if_info_t *if_info)\r\n{\r\nif (if_info != NULL)\r\n{\r\nif (if_info->name != NULL)\r\ng_free(if_info->name);\r\nif (if_info->description != NULL)\r\ng_free(if_info->description);\r\nif (if_info->keysCollection != NULL)\r\n{\r\ng_free(if_info->keysCollection);\r\nif_info->keysCollection = NULL;\r\n}\r\nif (if_info->ip_addr != NULL)\r\n{\r\ng_slist_free(if_info->ip_addr);\r\nif_info->ip_addr = NULL;\r\n}\r\nif (if_info != NULL)\r\n{\r\ng_free(if_info);\r\n}\r\n}\r\n}\r\nint load_airpcap(void)\r\n{\r\n#ifdef _WIN32\r\ngboolean base_functions = TRUE;\r\ngboolean eleven_n_functions = TRUE;\r\nif ((AirpcapLib = ws_load_library("airpcap.dll")) == NULL)\r\n{\r\nAirpcapVersion = AIRPCAP_DLL_NOT_FOUND;\r\nreturn AirpcapVersion;\r\n}\r\nelse\r\n{\r\nif ((g_PAirpcapGetLastError = (AirpcapGetLastErrorHandler) GetProcAddress(AirpcapLib, "AirpcapGetLastError")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetDeviceList = (AirpcapGetDeviceListHandler) GetProcAddress(AirpcapLib, "AirpcapGetDeviceList")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapFreeDeviceList = (AirpcapFreeDeviceListHandler) GetProcAddress(AirpcapLib, "AirpcapFreeDeviceList")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapOpen = (AirpcapOpenHandler) GetProcAddress(AirpcapLib, "AirpcapOpen")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapClose = (AirpcapCloseHandler) GetProcAddress(AirpcapLib, "AirpcapClose")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetLinkType = (AirpcapGetLinkTypeHandler) GetProcAddress(AirpcapLib, "AirpcapGetLinkType")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetLinkType = (AirpcapSetLinkTypeHandler) GetProcAddress(AirpcapLib, "AirpcapSetLinkType")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetKernelBuffer = (AirpcapSetKernelBufferHandler) GetProcAddress(AirpcapLib, "AirpcapSetKernelBuffer")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetFilter = (AirpcapSetFilterHandler) GetProcAddress(AirpcapLib, "AirpcapSetFilter")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetMacAddress = (AirpcapGetMacAddressHandler) GetProcAddress(AirpcapLib, "AirpcapGetMacAddress")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetMinToCopy = (AirpcapSetMinToCopyHandler) GetProcAddress(AirpcapLib, "AirpcapSetMinToCopy")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetReadEvent = (AirpcapGetReadEventHandler) GetProcAddress(AirpcapLib, "AirpcapGetReadEvent")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapRead = (AirpcapReadHandler) GetProcAddress(AirpcapLib, "AirpcapRead")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetStats = (AirpcapGetStatsHandler) GetProcAddress(AirpcapLib, "AirpcapGetStats")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapTurnLedOn = (AirpcapTurnLedOnHandler) GetProcAddress(AirpcapLib, "AirpcapTurnLedOn")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapTurnLedOff = (AirpcapTurnLedOffHandler) GetProcAddress(AirpcapLib, "AirpcapTurnLedOff")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetDeviceChannel = (AirpcapGetDeviceChannelHandler) GetProcAddress(AirpcapLib, "AirpcapGetDeviceChannel")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetDeviceChannel = (AirpcapSetDeviceChannelHandler) GetProcAddress(AirpcapLib, "AirpcapSetDeviceChannel")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetFcsPresence = (AirpcapGetFcsPresenceHandler) GetProcAddress(AirpcapLib, "AirpcapGetFcsPresence")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetFcsPresence = (AirpcapSetFcsPresenceHandler) GetProcAddress(AirpcapLib, "AirpcapSetFcsPresence")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetFcsValidation = (AirpcapGetFcsValidationHandler) GetProcAddress(AirpcapLib, "AirpcapGetFcsValidation")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetFcsValidation = (AirpcapSetFcsValidationHandler) GetProcAddress(AirpcapLib, "AirpcapSetFcsValidation")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetDeviceKeys = (AirpcapGetDeviceKeysHandler) GetProcAddress(AirpcapLib, "AirpcapGetDeviceKeys")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetDeviceKeys = (AirpcapSetDeviceKeysHandler) GetProcAddress(AirpcapLib, "AirpcapSetDeviceKeys")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetDecryptionState = (AirpcapGetDecryptionStateHandler) GetProcAddress(AirpcapLib, "AirpcapGetDecryptionState")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetDecryptionState = (AirpcapSetDecryptionStateHandler) GetProcAddress(AirpcapLib, "AirpcapSetDecryptionState")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapStoreCurConfigAsAdapterDefault = (AirpcapStoreCurConfigAsAdapterDefaultHandler) GetProcAddress(AirpcapLib, "AirpcapStoreCurConfigAsAdapterDefault")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetVersion = (AirpcapGetVersionHandler) GetProcAddress(AirpcapLib, "AirpcapGetVersion")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetDriverDecryptionState = (AirpcapGetDriverDecryptionStateHandler) GetProcAddress(AirpcapLib, "AirpcapGetDriverDecryptionState")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetDriverDecryptionState = (AirpcapSetDriverDecryptionStateHandler) GetProcAddress(AirpcapLib, "AirpcapSetDriverDecryptionState")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapGetDriverKeys = (AirpcapGetDriverKeysHandler) GetProcAddress(AirpcapLib, "AirpcapGetDriverKeys")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetDriverKeys = (AirpcapSetDriverKeysHandler) GetProcAddress(AirpcapLib, "AirpcapSetDriverKeys")) == NULL) base_functions = FALSE;\r\nif ((g_PAirpcapSetDeviceChannelEx = (AirpcapSetDeviceChannelExHandler) GetProcAddress(AirpcapLib, "AirpcapSetDeviceChannelEx")) == NULL) eleven_n_functions = FALSE;\r\nif ((g_PAirpcapGetDeviceChannelEx = (AirpcapGetDeviceChannelExHandler) GetProcAddress(AirpcapLib, "AirpcapGetDeviceChannelEx")) == NULL) eleven_n_functions = FALSE;\r\nif ((g_PAirpcapGetDeviceSupportedChannels = (AirpcapGetDeviceSupportedChannelsHandler) GetProcAddress(AirpcapLib, "AirpcapGetDeviceSupportedChannels")) == NULL) eleven_n_functions = FALSE;\r\nif (base_functions && eleven_n_functions){\r\nAirpcapLoaded = TRUE;\r\nAirpcapVersion = AIRPCAP_DLL_OK;\r\n} else if (base_functions){\r\nAirpcapLoaded = TRUE;\r\nAirpcapVersion = AIRPCAP_DLL_OLD;\r\nreturn AIRPCAP_DLL_OK;\r\n}else{\r\nAirpcapLoaded = FALSE;\r\nAirpcapVersion = AIRPCAP_DLL_ERROR;\r\n}\r\n}\r\nreturn AirpcapVersion;\r\n#else\r\nreturn AIRPCAP_DLL_NOT_FOUND;\r\n#endif\r\n}\r\nvoid\r\nget_compiled_airpcap_version(GString *str)\r\n{\r\ng_string_append(str, "with AirPcap");\r\n}\r\nvoid\r\nget_runtime_airpcap_version(GString *str)\r\n{\r\nguint vmaj, vmin, vrev, build;\r\nif (AirpcapLoaded == FALSE) {\r\ng_string_append(str, "without AirPcap");\r\nreturn;\r\n}\r\ng_PAirpcapGetVersion(&vmaj, &vmin, &vrev, &build);\r\ng_string_append_printf(str, "with AirPcap %d.%d.%d build %d", vmaj, vmin,\r\nvrev, build);\r\n}
