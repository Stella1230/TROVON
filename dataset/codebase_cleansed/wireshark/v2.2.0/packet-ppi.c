static gboolean\r\ncapture_ppi(const guchar *pd, int offset _U_, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\r\n{\r\nguint32 dlt;\r\nguint ppi_len;\r\nppi_len = pletoh16(pd+2);\r\nif(ppi_len < PPI_V0_HEADER_LEN || !BYTES_ARE_IN_FRAME(0, len, ppi_len))\r\nreturn FALSE;\r\ndlt = pletoh32(pd+4);\r\nreturn try_capture_dissector("ppi", dlt, pd, ppi_len, len, cpinfo, pseudo_header);\r\n}\r\nstatic void\r\nptvcursor_add_invalid_check(ptvcursor_t *csr, int hf, gint len, guint64 invalid_val) {\r\nproto_item *ti;\r\nguint64 val = invalid_val;\r\nswitch (len) {\r\ncase 8:\r\nval = tvb_get_letoh64(ptvcursor_tvbuff(csr),\r\nptvcursor_current_offset(csr));\r\nbreak;\r\ncase 4:\r\nval = tvb_get_letohl(ptvcursor_tvbuff(csr),\r\nptvcursor_current_offset(csr));\r\nbreak;\r\ncase 2:\r\nval = tvb_get_letohs(ptvcursor_tvbuff(csr),\r\nptvcursor_current_offset(csr));\r\nbreak;\r\ncase 1:\r\nval = tvb_get_guint8(ptvcursor_tvbuff(csr),\r\nptvcursor_current_offset(csr));\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\n}\r\nti = ptvcursor_add(csr, hf, len, ENC_LITTLE_ENDIAN);\r\nif (val == invalid_val)\r\nproto_item_append_text(ti, " [invalid]");\r\n}\r\nstatic void\r\nadd_ppi_field_header(tvbuff_t *tvb, proto_tree *tree, int *offset)\r\n{\r\nptvcursor_t *csr;\r\ncsr = ptvcursor_new(tree, tvb, *offset);\r\nptvcursor_add(csr, hf_ppi_field_type, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add(csr, hf_ppi_field_len, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_free(csr);\r\n*offset=ptvcursor_current_offset(csr);\r\n}\r\nstatic void\r\ndissect_80211_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int data_len, struct ieee_802_11_phdr *phdr)\r\n{\r\nproto_tree *ftree;\r\nproto_item *ti;\r\nptvcursor_t *csr;\r\nguint64 tsft_raw;\r\nguint rate_raw;\r\nguint rate_kbps;\r\nguint32 common_flags;\r\nguint16 common_frequency;\r\nguint16 chan_flags;\r\ngint8 dbm_value;\r\ngchar *chan_str;\r\nftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11_common, NULL, "802.11-Common");\r\nadd_ppi_field_header(tvb, ftree, &offset);\r\ndata_len -= 4;\r\nif (data_len != PPI_80211_COMMON_LEN) {\r\nproto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, "Invalid length: %u", data_len);\r\nreturn;\r\n}\r\ncommon_flags = tvb_get_letohs(tvb, offset + 8);\r\nif (common_flags & DOT11_FLAG_HAVE_FCS)\r\nphdr->fcs_len = 4;\r\nelse\r\nphdr->fcs_len = 0;\r\ncsr = ptvcursor_new(ftree, tvb, offset);\r\ntsft_raw = tvb_get_letoh64(tvb, offset);\r\nif (tsft_raw != 0) {\r\nphdr->has_tsf_timestamp = TRUE;\r\nif (common_flags & DOT11_FLAG_TSF_TIMER_MS)\r\nphdr->tsf_timestamp = tsft_raw * 1000;\r\nelse\r\nphdr->tsf_timestamp = tsft_raw;\r\n}\r\nptvcursor_add_invalid_check(csr, hf_80211_common_tsft, 8, 0);\r\nptvcursor_add_with_subtree(csr, hf_80211_common_flags, 2, ENC_LITTLE_ENDIAN,\r\nett_dot11_common_flags);\r\nptvcursor_add_no_advance(csr, hf_80211_common_flags_fcs, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211_common_flags_tsft, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211_common_flags_fcs_valid, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add(csr, hf_80211_common_flags_phy_err, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_pop_subtree(csr);\r\nrate_raw = tvb_get_letohs(tvb, ptvcursor_current_offset(csr));\r\nif (rate_raw != 0) {\r\nphdr->has_data_rate = TRUE;\r\nphdr->data_rate = rate_raw;\r\n}\r\nrate_kbps = rate_raw * 500;\r\nti = proto_tree_add_uint_format(ftree, hf_80211_common_rate, tvb,\r\nptvcursor_current_offset(csr), 2, rate_kbps, "Rate: %.1f Mbps",\r\nrate_kbps / 1000.0);\r\nif (rate_kbps == 0)\r\nproto_item_append_text(ti, " [invalid]");\r\ncol_add_fstr(pinfo->cinfo, COL_TX_RATE, "%.1f Mbps", rate_kbps / 1000.0);\r\nptvcursor_advance(csr, 2);\r\ncommon_frequency = tvb_get_letohs(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\r\nif (common_frequency != 0) {\r\ngint calc_channel;\r\nphdr->has_frequency = TRUE;\r\nphdr->frequency = common_frequency;\r\ncalc_channel = ieee80211_mhz_to_chan(common_frequency);\r\nif (calc_channel != -1) {\r\nphdr->has_channel = TRUE;\r\nphdr->channel = calc_channel;\r\n}\r\n}\r\nchan_str = ieee80211_mhz_to_str(common_frequency);\r\nproto_tree_add_uint_format_value(ptvcursor_tree(csr), hf_80211_common_chan_freq, ptvcursor_tvbuff(csr),\r\nptvcursor_current_offset(csr), 2, common_frequency, "%s", chan_str);\r\ncol_add_fstr(pinfo->cinfo, COL_FREQ_CHAN, "%s", chan_str);\r\ng_free(chan_str);\r\nptvcursor_advance(csr, 2);\r\nmemset(&phdr->phy_info, 0, sizeof(phdr->phy_info));\r\nchan_flags = tvb_get_letohs(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\r\nswitch (chan_flags & IEEE80211_CHAN_ALLTURBO) {\r\ncase IEEE80211_CHAN_FHSS:\r\nphdr->phy = PHDR_802_11_PHY_11_FHSS;\r\nbreak;\r\ncase IEEE80211_CHAN_DSSS:\r\nphdr->phy = PHDR_802_11_PHY_11_DSSS;\r\nbreak;\r\ncase IEEE80211_CHAN_A:\r\nphdr->phy = PHDR_802_11_PHY_11A;\r\nphdr->phy_info.info_11a.has_turbo_type = TRUE;\r\nphdr->phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_NORMAL;\r\nbreak;\r\ncase IEEE80211_CHAN_B:\r\nphdr->phy = PHDR_802_11_PHY_11B;\r\nbreak;\r\ncase IEEE80211_CHAN_PUREG:\r\nphdr->phy = PHDR_802_11_PHY_11G;\r\nphdr->phy_info.info_11g.has_mode = TRUE;\r\nphdr->phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;\r\nbreak;\r\ncase IEEE80211_CHAN_G:\r\nphdr->phy = PHDR_802_11_PHY_11G;\r\nphdr->phy_info.info_11g.has_mode = TRUE;\r\nphdr->phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;\r\nbreak;\r\ncase IEEE80211_CHAN_108A:\r\nphdr->phy = PHDR_802_11_PHY_11A;\r\nphdr->phy_info.info_11a.has_turbo_type = TRUE;\r\nphdr->phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_DYNAMIC_TURBO;\r\nbreak;\r\ncase IEEE80211_CHAN_108PUREG:\r\nphdr->phy = PHDR_802_11_PHY_11G;\r\nphdr->phy_info.info_11g.has_mode = TRUE;\r\nphdr->phy_info.info_11g.mode = PHDR_802_11G_MODE_SUPER_G;\r\nbreak;\r\n}\r\nptvcursor_add_with_subtree(csr, hf_80211_common_chan_flags, 2, ENC_LITTLE_ENDIAN,\r\nett_dot11_common_channel_flags);\r\nptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_turbo, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_cck, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_ofdm, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_2ghz, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_5ghz, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_passive, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211_common_chan_flags_dynamic, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add(csr, hf_80211_common_chan_flags_gfsk, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_pop_subtree(csr);\r\nif (phdr->phy == PHDR_802_11_PHY_11_FHSS) {\r\nphdr->phy_info.info_11_fhss.has_hop_set = TRUE;\r\nphdr->phy_info.info_11_fhss.hop_set = tvb_get_guint8(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\r\n}\r\nptvcursor_add(csr, hf_80211_common_fhss_hopset, 1, ENC_LITTLE_ENDIAN);\r\nif (phdr->phy == PHDR_802_11_PHY_11_FHSS) {\r\nphdr->phy_info.info_11_fhss.has_hop_pattern = TRUE;\r\nphdr->phy_info.info_11_fhss.hop_pattern = tvb_get_guint8(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\r\n}\r\nptvcursor_add(csr, hf_80211_common_fhss_pattern, 1, ENC_LITTLE_ENDIAN);\r\ndbm_value = (gint8) tvb_get_guint8(tvb, ptvcursor_current_offset(csr));\r\nif (dbm_value != -128 && dbm_value != 0) {\r\ncol_add_fstr(pinfo->cinfo, COL_RSSI, "%d dBm", dbm_value);\r\nphdr->has_signal_dbm = TRUE;\r\nphdr->signal_dbm = dbm_value;\r\n}\r\nptvcursor_add_invalid_check(csr, hf_80211_common_dbm_antsignal, 1, 0x80);\r\ndbm_value = (gint8) tvb_get_guint8(tvb, ptvcursor_current_offset(csr));\r\nif (dbm_value != -128 && dbm_value != 0) {\r\nphdr->has_noise_dbm = TRUE;\r\nphdr->noise_dbm = dbm_value;\r\n}\r\nptvcursor_add_invalid_check(csr, hf_80211_common_dbm_antnoise, 1, 0x80);\r\nptvcursor_free(csr);\r\n}\r\nstatic void\r\ndissect_80211n_mac(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, int data_len, gboolean add_subtree, guint32 *n_mac_flags, guint32 *ampdu_id, struct ieee_802_11_phdr *phdr)\r\n{\r\nproto_tree *ftree = tree;\r\nptvcursor_t *csr;\r\nguint32 flags;\r\nphdr->phy = PHDR_802_11_PHY_11N;\r\nif (add_subtree) {\r\nftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11n_mac, NULL, "802.11n MAC");\r\nadd_ppi_field_header(tvb, ftree, &offset);\r\ndata_len -= 4;\r\n}\r\nif (data_len != PPI_80211N_MAC_LEN) {\r\nproto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, "Invalid length: %u", data_len);\r\nreturn;\r\n}\r\ncsr = ptvcursor_new(ftree, tvb, offset);\r\nflags = tvb_get_letohl(tvb, ptvcursor_current_offset(csr));\r\n*n_mac_flags = flags;\r\nphdr->phy_info.info_11n.has_short_gi = TRUE;\r\nphdr->phy_info.info_11n.has_greenfield = TRUE;\r\nphdr->phy_info.info_11n.short_gi = ((flags & DOT11N_FLAG_SHORT_GI) != 0);\r\nphdr->phy_info.info_11n.greenfield = ((flags & DOT11N_FLAG_GREENFIELD) != 0);\r\nif (DOT11N_IS_AGGREGATE(flags)) {\r\nphdr->has_aggregate_info = 1;\r\nphdr->aggregate_flags = 0;\r\nif (!(flags & DOT11N_FLAG_MORE_AGGREGATES))\r\nphdr->aggregate_flags |= PHDR_802_11_LAST_PART_OF_A_MPDU;\r\nif (flags & DOT11N_FLAG_AGG_CRC_ERROR)\r\nphdr->aggregate_flags |= PHDR_802_11_A_MPDU_DELIM_CRC_ERROR;\r\n}\r\nptvcursor_add_with_subtree(csr, hf_80211n_mac_flags, 4, ENC_LITTLE_ENDIAN,\r\nett_dot11n_mac_flags);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_flags_greenfield, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_flags_ht20_40, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_flags_rx_guard_interval, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_flags_duplicate_rx, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_flags_aggregate, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_flags_more_aggregates, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add(csr, hf_80211n_mac_flags_delimiter_crc_after, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_pop_subtree(csr);\r\nif (DOT11N_IS_AGGREGATE(flags)) {\r\n*ampdu_id = tvb_get_letohl(tvb, ptvcursor_current_offset(csr));\r\nphdr->aggregate_id = *ampdu_id;\r\n}\r\nptvcursor_add(csr, hf_80211n_mac_ampdu_id, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add(csr, hf_80211n_mac_num_delimiters, 1, ENC_LITTLE_ENDIAN);\r\nif (add_subtree) {\r\nptvcursor_add(csr, hf_80211n_mac_reserved, 3, ENC_LITTLE_ENDIAN);\r\n}\r\nptvcursor_free(csr);\r\n}\r\nstatic void\r\ndissect_80211n_mac_phy(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int data_len, guint32 *n_mac_flags, guint32 *ampdu_id, struct ieee_802_11_phdr *phdr)\r\n{\r\nproto_tree *ftree;\r\nproto_item *ti;\r\nptvcursor_t *csr;\r\nguint8 mcs;\r\nguint8 ness;\r\nguint16 ext_frequency;\r\ngchar *chan_str;\r\nftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_dot11n_mac_phy, NULL, "802.11n MAC+PHY");\r\nadd_ppi_field_header(tvb, ftree, &offset);\r\ndata_len -= 4;\r\nif (data_len != PPI_80211N_MAC_PHY_LEN) {\r\nproto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, "Invalid length: %u", data_len);\r\nreturn;\r\n}\r\ndissect_80211n_mac(tvb, pinfo, ftree, offset, PPI_80211N_MAC_LEN,\r\nFALSE, n_mac_flags, ampdu_id, phdr);\r\noffset += PPI_80211N_MAC_PHY_OFF;\r\ncsr = ptvcursor_new(ftree, tvb, offset);\r\nmcs = tvb_get_guint8(tvb, ptvcursor_current_offset(csr));\r\nif (mcs != 255) {\r\nphdr->phy_info.info_11n.has_mcs_index = TRUE;\r\nphdr->phy_info.info_11n.mcs_index = mcs;\r\n}\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_mcs, 1, 255);\r\nness = tvb_get_guint8(tvb, ptvcursor_current_offset(csr));\r\nphdr->phy_info.info_11n.has_ness = TRUE;\r\nphdr->phy_info.info_11n.ness = ness;\r\nti = ptvcursor_add(csr, hf_80211n_mac_phy_num_streams, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_get_guint8(tvb, ptvcursor_current_offset(csr) - 1) == 0)\r\nproto_item_append_text(ti, " (unknown)");\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_combined, 1, 255);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant0_ctl, 1, 255);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant1_ctl, 1, 255);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant2_ctl, 1, 255);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant3_ctl, 1, 255);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant0_ext, 1, 255);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant1_ext, 1, 255);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant2_ext, 1, 255);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_rssi_ant3_ext, 1, 255);\r\next_frequency = tvb_get_letohs(ptvcursor_tvbuff(csr), ptvcursor_current_offset(csr));\r\nchan_str = ieee80211_mhz_to_str(ext_frequency);\r\nproto_tree_add_uint_format(ptvcursor_tree(csr), hf_80211n_mac_phy_ext_chan_freq, ptvcursor_tvbuff(csr),\r\nptvcursor_current_offset(csr), 2, ext_frequency, "Ext. Channel frequency: %s", chan_str);\r\ng_free(chan_str);\r\nptvcursor_advance(csr, 2);\r\nptvcursor_add_with_subtree(csr, hf_80211n_mac_phy_ext_chan_flags, 2, ENC_LITTLE_ENDIAN,\r\nett_dot11n_mac_phy_ext_channel_flags);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_turbo, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_cck, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_ofdm, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_2ghz, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_5ghz, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_passive, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_80211n_mac_phy_ext_chan_flags_dynamic, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add(csr, hf_80211n_mac_phy_ext_chan_flags_gfsk, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_pop_subtree(csr);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant0signal, 1, 0x80);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant0noise, 1, 0x80);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant1signal, 1, 0x80);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant1noise, 1, 0x80);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant2signal, 1, 0x80);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant2noise, 1, 0x80);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant3signal, 1, 0x80);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_dbm_ant3noise, 1, 0x80);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm0, 4, 0);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm1, 4, 0);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm2, 4, 0);\r\nptvcursor_add_invalid_check(csr, hf_80211n_mac_phy_evm3, 4, 0);\r\nptvcursor_free(csr);\r\n}\r\nstatic void\r\ndissect_aggregation_extension(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, int data_len)\r\n{\r\nproto_tree *ftree;\r\nptvcursor_t *csr;\r\nftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_aggregation_extension, NULL, "Aggregation Extension");\r\nadd_ppi_field_header(tvb, ftree, &offset);\r\ndata_len -= 4;\r\nif (data_len != PPI_AGGREGATION_EXTENSION_LEN) {\r\nproto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, "Invalid length: %u", data_len);\r\nreturn;\r\n}\r\ncsr = ptvcursor_new(ftree, tvb, offset);\r\nptvcursor_add(csr, hf_aggregation_extension_interface_id, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_free(csr);\r\n}\r\nstatic void\r\ndissect_8023_extension(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, int data_len)\r\n{\r\nproto_tree *ftree;\r\nptvcursor_t *csr;\r\nftree = proto_tree_add_subtree(tree, tvb, offset, data_len, ett_8023_extension, NULL, "802.3 Extension");\r\nadd_ppi_field_header(tvb, ftree, &offset);\r\ndata_len -= 4;\r\nif (data_len != PPI_8023_EXTENSION_LEN) {\r\nproto_tree_add_expert_format(ftree, pinfo, &ei_ppi_invalid_length, tvb, offset, data_len, "Invalid length: %u", data_len);\r\nreturn;\r\n}\r\ncsr = ptvcursor_new(ftree, tvb, offset);\r\nptvcursor_add_with_subtree(csr, hf_8023_extension_flags, 4, ENC_LITTLE_ENDIAN, ett_8023_extension_flags);\r\nptvcursor_add(csr, hf_8023_extension_flags_fcs_present, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_pop_subtree(csr);\r\nptvcursor_add_with_subtree(csr, hf_8023_extension_errors, 4, ENC_LITTLE_ENDIAN, ett_8023_extension_errors);\r\nptvcursor_add_no_advance(csr, hf_8023_extension_errors_fcs, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_8023_extension_errors_sequence, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(csr, hf_8023_extension_errors_symbol, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_add(csr, hf_8023_extension_errors_data, 4, ENC_LITTLE_ENDIAN);\r\nptvcursor_pop_subtree(csr);\r\nptvcursor_free(csr);\r\n}\r\nstatic int\r\ndissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *ppi_tree = NULL, *ppi_flags_tree = NULL, *seg_tree = NULL, *ampdu_tree = NULL;\r\nproto_tree *agg_tree = NULL;\r\nproto_item *ti = NULL;\r\ntvbuff_t *next_tvb;\r\nint offset = 0;\r\nguint version, flags;\r\ngint tot_len, data_len;\r\nguint data_type;\r\nguint32 dlt;\r\nguint32 n_ext_flags = 0;\r\nguint32 ampdu_id = 0;\r\nfragment_head *fd_head = NULL;\r\nfragment_item *ft_fdh = NULL;\r\ngint mpdu_count = 0;\r\ngchar *mpdu_str;\r\ngboolean first_mpdu = TRUE;\r\nguint last_frame = 0;\r\ngint len_remain, ampdu_len = 0;\r\nstruct ieee_802_11_phdr phdr;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PPI");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nversion = tvb_get_guint8(tvb, offset);\r\nflags = tvb_get_guint8(tvb, offset + 1);\r\ntot_len = tvb_get_letohs(tvb, offset+2);\r\ndlt = tvb_get_letohl(tvb, offset+4);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "PPI version %u, %u bytes",\r\nversion, tot_len);\r\nif (tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_ppi,\r\ntvb, 0, tot_len, "PPI version %u, %u bytes", version, tot_len);\r\nppi_tree = proto_item_add_subtree(ti, ett_ppi_pph);\r\nproto_tree_add_item(ppi_tree, hf_ppi_head_version,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nti = proto_tree_add_item(ppi_tree, hf_ppi_head_flags,\r\ntvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nppi_flags_tree = proto_item_add_subtree(ti, ett_ppi_flags);\r\nproto_tree_add_item(ppi_flags_tree, hf_ppi_head_flag_alignment,\r\ntvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ppi_flags_tree, hf_ppi_head_flag_reserved,\r\ntvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ppi_tree, hf_ppi_head_len,\r\ntvb, offset + 2, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(ppi_tree, hf_ppi_head_dlt,\r\ntvb, offset + 4, 4, ENC_LITTLE_ENDIAN);\r\n}\r\ntot_len -= PPI_V0_HEADER_LEN;\r\noffset += 8;\r\nmemset(&phdr, 0, sizeof(phdr));\r\nphdr.fcs_len = -1;\r\nphdr.decrypted = FALSE;\r\nphdr.datapad = FALSE;\r\nphdr.phy = PHDR_802_11_PHY_UNKNOWN;\r\nwhile (tot_len > 0) {\r\ndata_type = tvb_get_letohs(tvb, offset);\r\ndata_len = tvb_get_letohs(tvb, offset + 2) + 4;\r\ntot_len -= data_len;\r\nswitch (data_type) {\r\ncase PPI_80211_COMMON:\r\ndissect_80211_common(tvb, pinfo, ppi_tree, offset, data_len, &phdr);\r\nbreak;\r\ncase PPI_80211N_MAC:\r\ndissect_80211n_mac(tvb, pinfo, ppi_tree, offset, data_len,\r\nTRUE, &n_ext_flags, &ampdu_id, &phdr);\r\nbreak;\r\ncase PPI_80211N_MAC_PHY:\r\ndissect_80211n_mac_phy(tvb, pinfo, ppi_tree, offset,\r\ndata_len, &n_ext_flags, &ampdu_id, &phdr);\r\nbreak;\r\ncase PPI_SPECTRUM_MAP:\r\nADD_BASIC_TAG(hf_spectrum_map);\r\nbreak;\r\ncase PPI_PROCESS_INFO:\r\nADD_BASIC_TAG(hf_process_info);\r\nbreak;\r\ncase PPI_CAPTURE_INFO:\r\nADD_BASIC_TAG(hf_capture_info);\r\nbreak;\r\ncase PPI_AGGREGATION_EXTENSION:\r\ndissect_aggregation_extension(tvb, pinfo, ppi_tree, offset, data_len);\r\nbreak;\r\ncase PPI_8023_EXTENSION:\r\ndissect_8023_extension(tvb, pinfo, ppi_tree, offset, data_len);\r\nbreak;\r\ncase PPI_GPS_INFO:\r\nif (ppi_gps_handle == NULL)\r\n{\r\nproto_tree_add_item(ppi_tree, hf_ppi_gps, tvb, offset, data_len, ENC_NA);\r\n}\r\nelse\r\n{\r\nnext_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\r\ncall_dissector(ppi_gps_handle, next_tvb, pinfo, ppi_tree);\r\n}\r\nbreak;\r\ncase PPI_VECTOR_INFO:\r\nif (ppi_vector_handle == NULL)\r\n{\r\nproto_tree_add_item(ppi_tree, hf_ppi_vector, tvb, offset, data_len, ENC_NA);\r\n}\r\nelse\r\n{\r\nnext_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\r\ncall_dissector(ppi_vector_handle, next_tvb, pinfo, ppi_tree);\r\n}\r\nbreak;\r\ncase PPI_SENSOR_INFO:\r\nif (ppi_sensor_handle == NULL)\r\n{\r\nproto_tree_add_item(ppi_tree, hf_ppi_harris, tvb, offset, data_len, ENC_NA);\r\n}\r\nelse\r\n{\r\nnext_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\r\ncall_dissector(ppi_sensor_handle, next_tvb, pinfo, ppi_tree);\r\n}\r\nbreak;\r\ncase PPI_ANTENNA_INFO:\r\nif (ppi_antenna_handle == NULL)\r\n{\r\nproto_tree_add_item(ppi_tree, hf_ppi_antenna, tvb, offset, data_len, ENC_NA);\r\n}\r\nelse\r\n{\r\nnext_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\r\ncall_dissector(ppi_antenna_handle, next_tvb, pinfo, ppi_tree);\r\n}\r\nbreak;\r\ncase FNET_PRIVATE:\r\nif (ppi_fnet_handle == NULL)\r\n{\r\nproto_tree_add_item(ppi_tree, hf_ppi_fnet, tvb, offset, data_len, ENC_NA);\r\n}\r\nelse\r\n{\r\nnext_tvb = tvb_new_subset(tvb, offset + 4, data_len - 4 , -1);\r\ncall_dissector(ppi_fnet_handle, next_tvb, pinfo, ppi_tree);\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(ppi_tree, hf_ppi_reserved, tvb, offset, data_len, ENC_NA);\r\n}\r\noffset += data_len;\r\nif (IS_PPI_FLAG_ALIGN(flags)){\r\noffset += PADDING4(offset);\r\n}\r\n}\r\nif (ppi_ampdu_reassemble && DOT11N_IS_AGGREGATE(n_ext_flags)) {\r\nlen_remain = tvb_captured_length_remaining(tvb, offset);\r\n#if 0\r\nif (DOT11N_MORE_AGGREGATES(n_ext_flags)) {\r\npad_len = PADDING4(len_remain);\r\n}\r\n#endif\r\npinfo->fragmented = TRUE;\r\nfd_head = fragment_get(&ampdu_reassembly_table, pinfo, ampdu_id, NULL);\r\nwhile (fd_head) {\r\nampdu_len += fd_head->len + PADDING4(fd_head->len) + 4;\r\nfd_head = fd_head->next;\r\n}\r\nif (ampdu_len > AGGREGATE_MAX) {\r\nproto_tree_add_expert_format(ppi_tree, pinfo, &ei_ppi_invalid_length, tvb, offset, -1, "Aggregate length greater than maximum (%u)", AGGREGATE_MAX);\r\nreturn offset;\r\n}\r\nfragment_add_seq_next(&ampdu_reassembly_table,\r\ntvb, offset, pinfo, ampdu_id, NULL, len_remain, TRUE);\r\npinfo->fragmented = TRUE;\r\nfd_head = fragment_get(&ampdu_reassembly_table, pinfo, ampdu_id, NULL);\r\nif (fd_head && tree) {\r\nft_fdh = fd_head;\r\nseg_tree = proto_tree_add_subtree_format(ppi_tree, tvb, offset, -1,\r\nett_ampdu_segments, &ti, "A-MPDU (%u bytes w/hdrs):", ampdu_len);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nwhile (ft_fdh) {\r\nif (ft_fdh->tvb_data && ft_fdh->len) {\r\nlast_frame = ft_fdh->frame;\r\nif (!first_mpdu)\r\nproto_item_append_text(ti, ",");\r\nfirst_mpdu = FALSE;\r\nproto_item_append_text(ti, " #%u(%u)",\r\nft_fdh->frame, ft_fdh->len);\r\nproto_tree_add_uint_format(seg_tree, hf_ampdu_segment,\r\ntvb, 0, 0, last_frame,\r\n"Frame: %u (%u byte%s)",\r\nlast_frame,\r\nft_fdh->len,\r\nplurality(ft_fdh->len, "", "s"));\r\n}\r\nft_fdh = ft_fdh->next;\r\n}\r\nif (last_frame && last_frame != pinfo->num)\r\nproto_tree_add_uint(seg_tree, hf_ampdu_reassembled_in,\r\ntvb, 0, 0, last_frame);\r\n}\r\nif (fd_head && !DOT11N_MORE_AGGREGATES(n_ext_flags)) {\r\nif (tree) {\r\nti = proto_tree_add_protocol_format(tree,\r\nproto_get_id_by_filter_name("wlan_aggregate"),\r\ntvb, 0, tot_len, "IEEE 802.11 Aggregate MPDU");\r\nagg_tree = proto_item_add_subtree(ti, ett_ampdu);\r\n}\r\nwhile (fd_head) {\r\nif (fd_head->tvb_data && fd_head->len) {\r\nmpdu_count++;\r\nmpdu_str = wmem_strdup_printf(wmem_packet_scope(), "MPDU #%d", mpdu_count);\r\nnext_tvb = tvb_new_chain(tvb, fd_head->tvb_data);\r\nadd_new_data_source(pinfo, next_tvb, mpdu_str);\r\nampdu_tree = proto_tree_add_subtree(agg_tree, next_tvb, 0, -1, ett_ampdu_segment, NULL, mpdu_str);\r\ncall_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, ampdu_tree, &phdr);\r\n}\r\nfd_head = fd_head->next;\r\n}\r\nproto_tree_add_uint(seg_tree, hf_ampdu_count, tvb, 0, 0, mpdu_count);\r\npinfo->fragmented=FALSE;\r\n} else {\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IEEE 802.11n");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Unreassembled A-MPDU data");\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nif (dlt == 105) {\r\ncall_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, tree, &phdr);\r\n} else {\r\ncall_dissector_with_data(pcap_pktdata_handle, next_tvb, pinfo, tree, &dlt);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\nampdu_reassemble_init(void)\r\n{\r\nreassembly_table_init(&ampdu_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\nampdu_reassemble_cleanup(void)\r\n{\r\nreassembly_table_destroy(&ampdu_reassembly_table);\r\n}\r\nvoid\r\nproto_register_ppi(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ppi_head_version,\r\n{ "Version", "ppi.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"PPI header format version", HFILL } },\r\n{ &hf_ppi_head_flags,\r\n{ "Flags", "ppi.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"PPI header flags", HFILL } },\r\n{ &hf_ppi_head_flag_alignment,\r\n{ "Alignment", "ppi.flags.alignment",\r\nFT_BOOLEAN, 8, TFS(&tfs_ppi_head_flag_alignment), 0x01,\r\n"PPI header flags - 32bit Alignment", HFILL } },\r\n{ &hf_ppi_head_flag_reserved,\r\n{ "Reserved", "ppi.flags.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0xFE,\r\n"PPI header flags - Reserved Flags", HFILL } },\r\n{ &hf_ppi_head_len,\r\n{ "Header length", "ppi.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Length of header including payload", HFILL } },\r\n{ &hf_ppi_head_dlt,\r\n{ "DLT", "ppi.dlt",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, "libpcap Data Link Type (DLT) of the payload", HFILL } },\r\n{ &hf_ppi_field_type,\r\n{ "Field type", "ppi.field_type",\r\nFT_UINT16, BASE_DEC, VALS(vs_ppi_field_type), 0x0, "PPI data field type", HFILL } },\r\n{ &hf_ppi_field_len,\r\n{ "Field length", "ppi.field_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, "PPI data field length", HFILL } },\r\n{ &hf_80211_common_tsft,\r\n{ "TSFT", "ppi.80211-common.tsft",\r\nFT_UINT64, BASE_DEC, NULL, 0x0, "PPI 802.11-Common Timing Synchronization Function Timer (TSFT)", HFILL } },\r\n{ &hf_80211_common_flags,\r\n{ "Flags", "ppi.80211-common.flags",\r\nFT_UINT16, BASE_HEX, NULL, 0x0, "PPI 802.11-Common Flags", HFILL } },\r\n{ &hf_80211_common_flags_fcs,\r\n{ "FCS present flag", "ppi.80211-common.flags.fcs",\r\nFT_BOOLEAN, 16, TFS(&tfs_present_absent), DOT11_FLAG_HAVE_FCS, "PPI 802.11-Common Frame Check Sequence (FCS) Present Flag", HFILL } },\r\n{ &hf_80211_common_flags_tsft,\r\n{ "TSFT flag", "ppi.80211-common.flags.tsft",\r\nFT_BOOLEAN, 16, TFS(&tfs_tsft_ms), DOT11_FLAG_TSF_TIMER_MS, "PPI 802.11-Common Timing Synchronization Function Timer (TSFT) msec/usec flag", HFILL } },\r\n{ &hf_80211_common_flags_fcs_valid,\r\n{ "FCS validity", "ppi.80211-common.flags.fcs-invalid",\r\nFT_BOOLEAN, 16, TFS(&tfs_invalid_valid), DOT11_FLAG_FCS_INVALID, "PPI 802.11-Common Frame Check Sequence (FCS) Validity flag", HFILL } },\r\n{ &hf_80211_common_flags_phy_err,\r\n{ "PHY error flag", "ppi.80211-common.flags.phy-err",\r\nFT_BOOLEAN, 16, TFS(&tfs_phy_error), DOT11_FLAG_PHY_ERROR, "PPI 802.11-Common Physical level (PHY) Error", HFILL } },\r\n{ &hf_80211_common_rate,\r\n{ "Data rate", "ppi.80211-common.rate",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, "PPI 802.11-Common Data Rate (x 500 Kbps)", HFILL } },\r\n{ &hf_80211_common_chan_freq,\r\n{ "Channel frequency", "ppi.80211-common.chan.freq",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"PPI 802.11-Common Channel Frequency", HFILL } },\r\n{ &hf_80211_common_chan_flags,\r\n{ "Channel flags", "ppi.80211-common.chan.flags",\r\nFT_UINT16, BASE_HEX, NULL, 0x0, "PPI 802.11-Common Channel Flags", HFILL } },\r\n{ &hf_80211_common_chan_flags_turbo,\r\n{ "Turbo", "ppi.80211-common.chan.flags.turbo",\r\nFT_BOOLEAN, 16, NULL, IEEE80211_CHAN_TURBO, "PPI 802.11-Common Channel Flags Turbo", HFILL } },\r\n{ &hf_80211_common_chan_flags_cck,\r\n{ "Complementary Code Keying (CCK)", "ppi.80211-common.chan.flags.cck",\r\nFT_BOOLEAN, 16, NULL, IEEE80211_CHAN_CCK, "PPI 802.11-Common Channel Flags Complementary Code Keying (CCK) Modulation", HFILL } },\r\n{ &hf_80211_common_chan_flags_ofdm,\r\n{ "Orthogonal Frequency-Division Multiplexing (OFDM)", "ppi.80211-common.chan.flags.ofdm",\r\nFT_BOOLEAN, 16, NULL, IEEE80211_CHAN_OFDM, "PPI 802.11-Common Channel Flags Orthogonal Frequency-Division Multiplexing (OFDM)", HFILL } },\r\n{ &hf_80211_common_chan_flags_2ghz,\r\n{ "2 GHz spectrum", "ppi.80211-common.chan.flags.2ghz",\r\nFT_BOOLEAN, 16, NULL, IEEE80211_CHAN_2GHZ, "PPI 802.11-Common Channel Flags 2 GHz spectrum", HFILL } },\r\n{ &hf_80211_common_chan_flags_5ghz,\r\n{ "5 GHz spectrum", "ppi.80211-common.chan.flags.5ghz",\r\nFT_BOOLEAN, 16, NULL, IEEE80211_CHAN_5GHZ, "PPI 802.11-Common Channel Flags 5 GHz spectrum", HFILL } },\r\n{ &hf_80211_common_chan_flags_passive,\r\n{ "Passive", "ppi.80211-common.chan.flags.passive",\r\nFT_BOOLEAN, 16, NULL, IEEE80211_CHAN_PASSIVE, "PPI 802.11-Common Channel Flags Passive", HFILL } },\r\n{ &hf_80211_common_chan_flags_dynamic,\r\n{ "Dynamic CCK-OFDM", "ppi.80211-common.chan.flags.dynamic",\r\nFT_BOOLEAN, 16, NULL, IEEE80211_CHAN_DYN, "PPI 802.11-Common Channel Flags Dynamic CCK-OFDM Channel", HFILL } },\r\n{ &hf_80211_common_chan_flags_gfsk,\r\n{ "Gaussian Frequency Shift Keying (GFSK)", "ppi.80211-common.chan.flags.gfsk",\r\nFT_BOOLEAN, 16, NULL, IEEE80211_CHAN_GFSK, "PPI 802.11-Common Channel Flags Gaussian Frequency Shift Keying (GFSK) Modulation", HFILL } },\r\n{ &hf_80211_common_fhss_hopset,\r\n{ "FHSS hopset", "ppi.80211-common.fhss.hopset",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, "PPI 802.11-Common Frequency-Hopping Spread Spectrum (FHSS) Hopset", HFILL } },\r\n{ &hf_80211_common_fhss_pattern,\r\n{ "FHSS pattern", "ppi.80211-common.fhss.pattern",\r\nFT_UINT8, BASE_HEX, NULL, 0x0, "PPI 802.11-Common Frequency-Hopping Spread Spectrum (FHSS) Pattern", HFILL } },\r\n{ &hf_80211_common_dbm_antsignal,\r\n{ "dBm antenna signal", "ppi.80211-common.dbm.antsignal",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11-Common dBm Antenna Signal", HFILL } },\r\n{ &hf_80211_common_dbm_antnoise,\r\n{ "dBm antenna noise", "ppi.80211-common.dbm.antnoise",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11-Common dBm Antenna Noise", HFILL } },\r\n{ &hf_80211n_mac_flags,\r\n{ "MAC flags", "ppi.80211n-mac.flags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, "PPI 802.11n MAC flags", HFILL } },\r\n{ &hf_80211n_mac_flags_greenfield,\r\n{ "Greenfield flag", "ppi.80211n-mac.flags.greenfield",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_GREENFIELD, "PPI 802.11n MAC Greenfield Flag", HFILL } },\r\n{ &hf_80211n_mac_flags_ht20_40,\r\n{ "HT20/HT40 flag", "ppi.80211n-mac.flags.ht20_40",\r\nFT_BOOLEAN, 32, TFS(&tfs_ht20_40), DOT11N_FLAG_HT40, "PPI 802.11n MAC HT20/HT40 Flag", HFILL } },\r\n{ &hf_80211n_mac_flags_rx_guard_interval,\r\n{ "RX Short Guard Interval (SGI) flag", "ppi.80211n-mac.flags.rx.short_guard_interval",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_SHORT_GI, "PPI 802.11n MAC RX Short Guard Interval (SGI) Flag", HFILL } },\r\n{ &hf_80211n_mac_flags_duplicate_rx,\r\n{ "Duplicate RX flag", "ppi.80211n-mac.flags.rx.duplicate",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_DUPLICATE_RX, "PPI 802.11n MAC Duplicate RX Flag", HFILL } },\r\n{ &hf_80211n_mac_flags_aggregate,\r\n{ "Aggregate flag", "ppi.80211n-mac.flags.agg",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_IS_AGGREGATE, "PPI 802.11 MAC Aggregate Flag", HFILL } },\r\n{ &hf_80211n_mac_flags_more_aggregates,\r\n{ "More aggregates flag", "ppi.80211n-mac.flags.more_agg",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_MORE_AGGREGATES, "PPI 802.11n MAC More Aggregates Flag", HFILL } },\r\n{ &hf_80211n_mac_flags_delimiter_crc_after,\r\n{ "A-MPDU Delimiter CRC error after this frame flag", "ppi.80211n-mac.flags.delim_crc_error_after",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), DOT11N_FLAG_AGG_CRC_ERROR, "PPI 802.11n MAC A-MPDU Delimiter CRC Error After This Frame Flag", HFILL } },\r\n{ &hf_80211n_mac_ampdu_id,\r\n{ "AMPDU-ID", "ppi.80211n-mac.ampdu_id",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, "PPI 802.11n MAC AMPDU-ID", HFILL } },\r\n{ &hf_80211n_mac_num_delimiters,\r\n{ "Num-Delimiters", "ppi.80211n-mac.num_delimiters",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC number of zero-length pad delimiters", HFILL } },\r\n{ &hf_80211n_mac_reserved,\r\n{ "Reserved", "ppi.80211n-mac.reserved",\r\nFT_UINT24, BASE_HEX, NULL, 0x0, "PPI 802.11n MAC Reserved", HFILL } },\r\n{ &hf_80211n_mac_phy_mcs,\r\n{ "MCS", "ppi.80211n-mac-phy.mcs",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Modulation Coding Scheme (MCS)", HFILL } },\r\n{ &hf_80211n_mac_phy_num_streams,\r\n{ "Number of spatial streams", "ppi.80211n-mac-phy.num_streams",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY number of spatial streams", HFILL } },\r\n{ &hf_80211n_mac_phy_rssi_combined,\r\n{ "RSSI combined", "ppi.80211n-mac-phy.rssi.combined",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Received Signal Strength Indication (RSSI) Combined", HFILL } },\r\n{ &hf_80211n_mac_phy_rssi_ant0_ctl,\r\n{ "Antenna 0 control RSSI", "ppi.80211n-mac-phy.rssi.ant0ctl",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Antenna 0 Control Channel Received Signal Strength Indication (RSSI)", HFILL } },\r\n{ &hf_80211n_mac_phy_rssi_ant1_ctl,\r\n{ "Antenna 1 control RSSI", "ppi.80211n-mac-phy.rssi.ant1ctl",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Antenna 1 Control Channel Received Signal Strength Indication (RSSI)", HFILL } },\r\n{ &hf_80211n_mac_phy_rssi_ant2_ctl,\r\n{ "Antenna 2 control RSSI", "ppi.80211n-mac-phy.rssi.ant2ctl",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Antenna 2 Control Channel Received Signal Strength Indication (RSSI)", HFILL } },\r\n{ &hf_80211n_mac_phy_rssi_ant3_ctl,\r\n{ "Antenna 3 control RSSI", "ppi.80211n-mac-phy.rssi.ant3ctl",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Antenna 3 Control Channel Received Signal Strength Indication (RSSI)", HFILL } },\r\n{ &hf_80211n_mac_phy_rssi_ant0_ext,\r\n{ "Antenna 0 extension RSSI", "ppi.80211n-mac-phy.rssi.ant0ext",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Antenna 0 Extension Channel Received Signal Strength Indication (RSSI)", HFILL } },\r\n{ &hf_80211n_mac_phy_rssi_ant1_ext,\r\n{ "Antenna 1 extension RSSI", "ppi.80211n-mac-phy.rssi.ant1ext",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Antenna 1 Extension Channel Received Signal Strength Indication (RSSI)", HFILL } },\r\n{ &hf_80211n_mac_phy_rssi_ant2_ext,\r\n{ "Antenna 2 extension RSSI", "ppi.80211n-mac-phy.rssi.ant2ext",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Antenna 2 Extension Channel Received Signal Strength Indication (RSSI)", HFILL } },\r\n{ &hf_80211n_mac_phy_rssi_ant3_ext,\r\n{ "Antenna 3 extension RSSI", "ppi.80211n-mac-phy.rssi.ant3ext",\r\nFT_UINT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Antenna 3 Extension Channel Received Signal Strength Indication (RSSI)", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_freq,\r\n{ "Extended channel frequency", "ppi.80211-mac-phy.ext-chan.freq",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Extended Channel Frequency", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_flags,\r\n{ "Channel flags", "ppi.80211-mac-phy.ext-chan.flags",\r\nFT_UINT16, BASE_HEX, NULL, 0x0, "PPI 802.11n MAC+PHY Channel Flags", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_flags_turbo,\r\n{ "Turbo", "ppi.80211-mac-phy.ext-chan.flags.turbo",\r\nFT_BOOLEAN, 16, NULL, 0x0010, "PPI 802.11n MAC+PHY Channel Flags Turbo", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_flags_cck,\r\n{ "Complementary Code Keying (CCK)", "ppi.80211-mac-phy.ext-chan.flags.cck",\r\nFT_BOOLEAN, 16, NULL, 0x0020, "PPI 802.11n MAC+PHY Channel Flags Complementary Code Keying (CCK) Modulation", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_flags_ofdm,\r\n{ "Orthogonal Frequency-Division Multiplexing (OFDM)", "ppi.80211-mac-phy.ext-chan.flags.ofdm",\r\nFT_BOOLEAN, 16, NULL, 0x0040, "PPI 802.11n MAC+PHY Channel Flags Orthogonal Frequency-Division Multiplexing (OFDM)", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_flags_2ghz,\r\n{ "2 GHz spectrum", "ppi.80211-mac-phy.ext-chan.flags.2ghz",\r\nFT_BOOLEAN, 16, NULL, 0x0080, "PPI 802.11n MAC+PHY Channel Flags 2 GHz spectrum", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_flags_5ghz,\r\n{ "5 GHz spectrum", "ppi.80211-mac-phy.ext-chan.flags.5ghz",\r\nFT_BOOLEAN, 16, NULL, 0x0100, "PPI 802.11n MAC+PHY Channel Flags 5 GHz spectrum", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_flags_passive,\r\n{ "Passive", "ppi.80211-mac-phy.ext-chan.flags.passive",\r\nFT_BOOLEAN, 16, NULL, 0x0200, "PPI 802.11n MAC+PHY Channel Flags Passive", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_flags_dynamic,\r\n{ "Dynamic CCK-OFDM", "ppi.80211-mac-phy.ext-chan.flags.dynamic",\r\nFT_BOOLEAN, 16, NULL, 0x0400, "PPI 802.11n MAC+PHY Channel Flags Dynamic CCK-OFDM Channel", HFILL } },\r\n{ &hf_80211n_mac_phy_ext_chan_flags_gfsk,\r\n{ "Gaussian Frequency Shift Keying (GFSK)", "ppi.80211-mac-phy.ext-chan.flags.gfsk",\r\nFT_BOOLEAN, 16, NULL, 0x0800, "PPI 802.11n MAC+PHY Channel Flags Gaussian Frequency Shift Keying (GFSK) Modulation", HFILL } },\r\n{ &hf_80211n_mac_phy_dbm_ant0signal,\r\n{ "dBm antenna 0 signal", "ppi.80211n-mac-phy.dbmant0.signal",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY dBm Antenna 0 Signal", HFILL } },\r\n{ &hf_80211n_mac_phy_dbm_ant0noise,\r\n{ "dBm antenna 0 noise", "ppi.80211n-mac-phy.dbmant0.noise",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY dBm Antenna 0 Noise", HFILL } },\r\n{ &hf_80211n_mac_phy_dbm_ant1signal,\r\n{ "dBm antenna 1 signal", "ppi.80211n-mac-phy.dbmant1.signal",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY dBm Antenna 1 Signal", HFILL } },\r\n{ &hf_80211n_mac_phy_dbm_ant1noise,\r\n{ "dBm antenna 1 noise", "ppi.80211n-mac-phy.dbmant1.noise",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY dBm Antenna 1 Noise", HFILL } },\r\n{ &hf_80211n_mac_phy_dbm_ant2signal,\r\n{ "dBm antenna 2 signal", "ppi.80211n-mac-phy.dbmant2.signal",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY dBm Antenna 2 Signal", HFILL } },\r\n{ &hf_80211n_mac_phy_dbm_ant2noise,\r\n{ "dBm antenna 2 noise", "ppi.80211n-mac-phy.dbmant2.noise",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY dBm Antenna 2 Noise", HFILL } },\r\n{ &hf_80211n_mac_phy_dbm_ant3signal,\r\n{ "dBm antenna 3 signal", "ppi.80211n-mac-phy.dbmant3.signal",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY dBm Antenna 3 Signal", HFILL } },\r\n{ &hf_80211n_mac_phy_dbm_ant3noise,\r\n{ "dBm antenna 3 noise", "ppi.80211n-mac-phy.dbmant3.noise",\r\nFT_INT8, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY dBm Antenna 3 Noise", HFILL } },\r\n{ &hf_80211n_mac_phy_evm0,\r\n{ "EVM-0", "ppi.80211n-mac-phy.evm0",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 0", HFILL } },\r\n{ &hf_80211n_mac_phy_evm1,\r\n{ "EVM-1", "ppi.80211n-mac-phy.evm1",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 1", HFILL } },\r\n{ &hf_80211n_mac_phy_evm2,\r\n{ "EVM-2", "ppi.80211n-mac-phy.evm2",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 2", HFILL } },\r\n{ &hf_80211n_mac_phy_evm3,\r\n{ "EVM-3", "ppi.80211n-mac-phy.evm3",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, "PPI 802.11n MAC+PHY Error Vector Magnitude (EVM) for chain 3", HFILL } },\r\n{ &hf_ampdu_segment,\r\n{ "A-MPDU", "ppi.80211n-mac.ampdu",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0, "802.11n Aggregated MAC Protocol Data Unit (A-MPDU)", HFILL }},\r\n#if 0\r\n{ &hf_ampdu_segments,\r\n{ "Reassembled A-MPDU", "ppi.80211n-mac.ampdu.reassembled",\r\nFT_NONE, BASE_NONE, NULL, 0x0, "Reassembled Aggregated MAC Protocol Data Unit (A-MPDU)", HFILL }},\r\n#endif\r\n{ &hf_ampdu_reassembled_in,\r\n{ "Reassembled A-MPDU in frame", "ppi.80211n-mac.ampdu.reassembled_in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"The A-MPDU that doesn't end in this segment is reassembled in this frame",\r\nHFILL }},\r\n{ &hf_ampdu_count,\r\n{ "MPDU count", "ppi.80211n-mac.ampdu.count",\r\nFT_UINT16, BASE_DEC, NULL, 0x0, "The number of aggregated MAC Protocol Data Units (MPDUs)", HFILL }},\r\n{ &hf_spectrum_map,\r\n{ "Radio spectrum map", "ppi.spectrum-map",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, "PPI Radio spectrum map", HFILL } },\r\n{ &hf_process_info,\r\n{ "Process information", "ppi.proc-info",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, "PPI Process information", HFILL } },\r\n{ &hf_capture_info,\r\n{ "Capture information", "ppi.cap-info",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, "PPI Capture information", HFILL } },\r\n{ &hf_aggregation_extension_interface_id,\r\n{ "Interface ID", "ppi.aggregation_extension.interface_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, "Zero-based index of the physical interface the packet was captured from", HFILL } },\r\n{ &hf_8023_extension_flags,\r\n{ "Flags", "ppi.8023_extension.flags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, "PPI 802.3 Extension Flags", HFILL } },\r\n{ &hf_8023_extension_flags_fcs_present,\r\n{ "FCS Present Flag", "ppi.8023_extension.flags.fcs_present",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0001, "FCS (4 bytes) is present at the end of the packet", HFILL } },\r\n{ &hf_8023_extension_errors,\r\n{ "Errors", "ppi.8023_extension.errors",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, "PPI 802.3 Extension Errors", HFILL } },\r\n{ &hf_8023_extension_errors_fcs,\r\n{ "FCS Error", "ppi.8023_extension.errors.fcs",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0001,\r\n"PPI 802.3 Extension FCS Error", HFILL } },\r\n{ &hf_8023_extension_errors_sequence,\r\n{ "Sequence Error", "ppi.8023_extension.errors.sequence",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0002,\r\n"PPI 802.3 Extension Sequence Error", HFILL } },\r\n{ &hf_8023_extension_errors_symbol,\r\n{ "Symbol Error", "ppi.8023_extension.errors.symbol",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0004,\r\n"PPI 802.3 Extension Symbol Error", HFILL } },\r\n{ &hf_8023_extension_errors_data,\r\n{ "Data Error", "ppi.8023_extension.errors.data",\r\nFT_BOOLEAN, 32, TFS(&tfs_true_false), 0x0008,\r\n"PPI 802.3 Extension Data Error", HFILL } },\r\n{ &hf_ppi_gps, { "GPS", "ppi.gps", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ppi_vector, { "VECTOR", "ppi.vector", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ppi_harris, { "HARRIS", "ppi.harris", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ppi_antenna, { "ANTENNA", "ppi.antenna", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ppi_fnet, { "FNET", "ppi.fnet", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ppi_reserved, { "Reserved", "ppi.reserved", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ppi_pph,\r\n&ett_ppi_flags,\r\n&ett_dot11_common,\r\n&ett_dot11_common_flags,\r\n&ett_dot11_common_channel_flags,\r\n&ett_dot11n_mac,\r\n&ett_dot11n_mac_flags,\r\n&ett_dot11n_mac_phy,\r\n&ett_dot11n_mac_phy_ext_channel_flags,\r\n&ett_ampdu_segments,\r\n&ett_ampdu,\r\n&ett_ampdu_segment,\r\n&ett_aggregation_extension,\r\n&ett_8023_extension,\r\n&ett_8023_extension_flags,\r\n&ett_8023_extension_errors\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ppi_invalid_length, { "ppi.invalid_length", PI_MALFORMED, PI_ERROR, "Invalid length", EXPFILL }},\r\n};\r\nmodule_t *ppi_module;\r\nexpert_module_t* expert_ppi;\r\nproto_ppi = proto_register_protocol("PPI Packet Header", "PPI", "ppi");\r\nproto_register_field_array(proto_ppi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ppi = expert_register_protocol(proto_ppi);\r\nexpert_register_field_array(expert_ppi, ei, array_length(ei));\r\nppi_handle = register_dissector("ppi", dissect_ppi, proto_ppi);\r\nregister_capture_dissector_table("ppi", "PPI");\r\nregister_init_routine(ampdu_reassemble_init);\r\nregister_cleanup_routine(ampdu_reassemble_cleanup);\r\nppi_module = prefs_register_protocol(proto_ppi, NULL);\r\nprefs_register_bool_preference(ppi_module, "reassemble",\r\n"Reassemble fragmented 802.11 A-MPDUs",\r\n"Whether fragmented 802.11 aggregated MPDUs should be reassembled",\r\n&ppi_ampdu_reassemble);\r\n}\r\nvoid\r\nproto_reg_handoff_ppi(void)\r\n{\r\nieee80211_radio_handle = find_dissector_add_dependency("wlan_radio", proto_ppi);\r\npcap_pktdata_handle = find_dissector_add_dependency("pcap_pktdata", proto_ppi);\r\nppi_gps_handle = find_dissector_add_dependency("ppi_gps", proto_ppi);\r\nppi_vector_handle = find_dissector_add_dependency("ppi_vector", proto_ppi);\r\nppi_sensor_handle = find_dissector_add_dependency("ppi_sensor", proto_ppi);\r\nppi_antenna_handle = find_dissector_add_dependency("ppi_antenna", proto_ppi);\r\nppi_fnet_handle = find_dissector_add_dependency("ppi_fnet", proto_ppi);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_PPI, ppi_handle);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_PPI, capture_ppi, proto_ppi);\r\n}
