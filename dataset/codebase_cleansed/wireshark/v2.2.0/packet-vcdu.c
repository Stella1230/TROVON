static gboolean\r\nvcdu_uat_data_update_cb(void *p, char **err) {\r\nuat_channel_t *ud = (uat_channel_t *)p;\r\nif (ud->channel >= 64) {\r\n*err = g_strdup("Channel must be between 0-63.");\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void\r\nvcdu_prefs_apply_cb(void)\r\n{\r\nguint i;\r\nif (num_channels_uat > 0)\r\n{\r\nmemset(bitstream_channels, 0, sizeof(bitstream_channels));\r\nfor (i = 0; i < num_channels_uat; i++)\r\n{\r\nbitstream_channels[uat_bitchannels[i].channel] = 1;\r\n}\r\n}\r\n}\r\nstatic const char *\r\nsmex_time_to_string (int pb5_days_since_midnight_9_10_oct_1995, int pb5_seconds, int pb5_milliseconds)\r\n{\r\nstatic int utcdiff = 0;\r\nnstime_t t;\r\nstatic int Days[2][13] =\r\n{\r\n{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },\r\n{ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }\r\n};\r\nint yr;\r\nint ix, days, month;\r\nif (0 == utcdiff)\r\n{\r\nfor (yr=1970; yr < 1995; ++yr)\r\n{\r\nutcdiff += (Leap(yr) ? 366 : 365) * 24 * 60 * 60;\r\n}\r\ndays = 0;\r\nix = (Leap(1995) ? 1 : 0);\r\nfor (month=1; month < 10; ++month)\r\n{\r\ndays += Days[ix][month];\r\n}\r\ndays += 9;\r\nutcdiff += days * 24 * 60 * 60;\r\n}\r\nt.secs = (pb5_days_since_midnight_9_10_oct_1995 * 86400) + pb5_seconds + utcdiff;\r\nt.nsecs = pb5_milliseconds*1000000;\r\nreturn abs_time_to_str(wmem_packet_scope(), &t, ABSOLUTE_TIME_DOY_UTC, TRUE);\r\n}\r\nstatic int\r\ndissect_vcdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\ngboolean ccsds_tree_added = FALSE;\r\nproto_item *smex_header;\r\nproto_tree *smex_tree;\r\nproto_tree *vcdu_tree;\r\nproto_item *vcdu_item;\r\nguint16 first_word;\r\nguint32 long_word;\r\nint vcid, pb5_days, pb5_seconds, pb5_milliseconds;\r\nconst char *time_string;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "VCDU");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Virtual Channel Data Unit");\r\nsmex_tree = proto_tree_add_subtree(tree, tvb, offset, SMEX_HEADER_LENGTH, ett_smex, &smex_header, "SMEX Header");\r\nproto_tree_add_item(smex_tree, hf_smex_gsc, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\noffset += 2;\r\nfirst_word = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(smex_tree, hf_smex_version, tvb, offset, 2, first_word);\r\nproto_tree_add_uint(smex_tree, hf_smex_framelen, tvb, offset, 2, first_word);\r\noffset += 2;\r\nproto_tree_add_item(smex_tree, hf_smex_rs_enable, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(smex_tree, hf_smex_rs_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(smex_tree, hf_smex_crc_enable, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(smex_tree, hf_smex_crc_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(smex_tree, hf_smex_mcs_enable, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(smex_tree, hf_smex_mcs_num_error, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(smex_tree, hf_smex_data_inv, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(smex_tree, hf_smex_frame_sync, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(smex_tree, hf_smex_data_dir, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(smex_tree, hf_smex_data_class, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nlong_word = tvb_get_ntohl(tvb, offset);\r\npb5_days = (long_word >> 17) & PB5_JULIAN_DAY_MASK;\r\npb5_seconds = (long_word & PB5_SECONDS_MASK);\r\nfirst_word = tvb_get_ntohs(tvb, offset+4);\r\npb5_milliseconds = (first_word & PB5_MILLISECONDS_MASK) >> 6;\r\nproto_tree_add_item(smex_tree, hf_smex_pb5, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(smex_tree, hf_smex_jday, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(smex_tree, hf_smex_seconds, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(smex_tree, hf_smex_msec, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\ntime_string = smex_time_to_string(pb5_days, pb5_seconds, pb5_milliseconds);\r\nproto_tree_add_string(smex_tree, hf_vcdu_ground_receipt_time, tvb, offset-6, 6, time_string);\r\nproto_item_set_end(smex_header, tvb, offset);\r\nvcdu_tree = proto_tree_add_subtree(tree, tvb, offset, VCDU_HEADER_LENGTH, ett_vcdu, &vcdu_item, "VCDU Header");\r\nfirst_word = tvb_get_ntohs(tvb, offset);\r\nvcid = first_word & 0x3f;\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_sp_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_vc_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_seq, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_replay, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nfirst_word = tvb_get_ntohs(tvb, offset);\r\nif (bitstream_channels[vcid])\r\n{\r\nguint16 new_ptr;\r\nnew_ptr = first_word & LBP_MASK;\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_lbp, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nswitch (new_ptr)\r\n{\r\ncase LBP_ALL_DATA:\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_bitream_all_data, tvb, 0, -1, ENC_NA);\r\nbreak;\r\ncase LBP_ALL_DATA_ANOMALY:\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_bitream_all_data_anomaly, tvb, 0, -1, ENC_NA);\r\nbreak;\r\ncase LBP_ALL_FILL:\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_bitream_all_fill, tvb, 0, -1, ENC_NA);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nguint16 new_ptr;\r\nnew_ptr = first_word & FHP_MASK;\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_fhp, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif (FHP_ALL_FILL == new_ptr)\r\n{\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_ccsds_all_fill, tvb, 0, -1, ENC_NA);\r\n}\r\nelse if (FHP_CONTINUATION == new_ptr)\r\n{\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_ccsds_continuation_packet, tvb, 0, -1, ENC_NA);\r\n}\r\nelse\r\n{\r\nint packet_boundary;\r\nint new_offset;\r\nnew_offset = offset + 2 + new_ptr;\r\npacket_boundary =\r\ntvb_reported_length(tvb) - VCDU_HEADER_LENGTH\r\n- CCSDS_PRIMARY_HEADER_LENGTH - CCSDS_SECONDARY_HEADER_LENGTH;\r\nwhile ( ((new_offset-offset+2) < packet_boundary) && ((new_offset-offset+2) >= 4) )\r\n{\r\nint ccsds_len;\r\ntvbuff_t *new_tvb;\r\nccsds_tree_added = TRUE;\r\nccsds_len = tvb_get_ntohs(tvb, new_offset+4);\r\nnew_tvb = tvb_new_subset_remaining(tvb, new_offset);\r\ncall_dissector(ccsds_handle, new_tvb, pinfo, vcdu_tree);\r\nnew_offset = new_offset + ccsds_len + 7;\r\n}\r\nif (! ccsds_tree_added)\r\n{\r\nproto_tree_add_expert(vcdu_tree, pinfo, &ei_vcdu_fhp_too_close_to_end_of_vcdu, tvb, 0, -1);\r\n}\r\n}\r\n}\r\nproto_item_set_end(vcdu_item, tvb, offset);\r\nif (! ccsds_tree_added)\r\n{\r\nproto_tree_add_item(vcdu_tree, hf_vcdu_data, tvb, offset, -1, ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_vcdu(void)\r\n{\r\nmodule_t *vcdu_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_smex_gsc,\r\n{ "Ground Sequence Counter", "vcdu.smex.gsc",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\n"SMEX Ground Sequence Counter", HFILL }\r\n},\r\n#if 0\r\n{ &hf_smex_unused,\r\n{ "Unused", "vcdu.smex.unused",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"SMEX Unused", HFILL }\r\n},\r\n#endif\r\n{ &hf_smex_version,\r\n{ "Version", "vcdu.smex.version",\r\nFT_UINT16, BASE_DEC, NULL, SMEX_VERSION,\r\n"SMEX Version", HFILL }\r\n},\r\n{ &hf_smex_framelen,\r\n{ "Frame Length", "vcdu.smex.frame_len",\r\nFT_UINT16, BASE_DEC, NULL, SMEX_FRAMELEN,\r\n"SMEX Frame Length", HFILL }\r\n},\r\n{ &hf_smex_rs_enable,\r\n{ "RS Enable", "vcdu.smex.rs_enable",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\n"SMEX RS Enable", HFILL }\r\n},\r\n{ &hf_smex_rs_error,\r\n{ "RS Error", "vcdu.smex.rs_error",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\n"SMEX RS Error", HFILL }\r\n},\r\n{ &hf_smex_crc_enable,\r\n{ "CRC Enable", "vcdu.smex.crc_enable",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\n"SMEX CRC Enable", HFILL }\r\n},\r\n{ &hf_smex_crc_error,\r\n{ "CRC Error", "vcdu.smex.crc_error",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\n"SMEX CRC Error", HFILL }\r\n},\r\n{ &hf_smex_mcs_enable,\r\n{ "MCS Enable", "vcdu.smex.mcs_enable",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\n"SMEX MCS Enable", HFILL }\r\n},\r\n{ &hf_smex_mcs_num_error,\r\n{ "MCS Number Error", "vcdu.smex.mcs_numerr",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\n"SMEX MCS Number Error", HFILL }\r\n},\r\n{ &hf_smex_data_inv,\r\n{ "Data Inversion", "vcdu.smex.data_inv",\r\nFT_UINT16, BASE_DEC, VALS(smex_data_inversion_type), 0x03,\r\n"SMEX Data Inversion", HFILL }\r\n},\r\n{ &hf_smex_frame_sync,\r\n{ "Frame Sync", "vcdu.smex.frame_sync",\r\nFT_UINT16, BASE_DEC, VALS(smex_frame_sync_mode), 0xc0,\r\n"SMEX Frame Sync Flag", HFILL }\r\n},\r\n{ &hf_smex_data_dir,\r\n{ "Data Direction", "vcdu.smex.data_dir",\r\nFT_UINT16, BASE_DEC, VALS(smex_data_direction), 0x20,\r\n"SMEX Data Direction flag", HFILL }\r\n},\r\n{ &hf_smex_data_class,\r\n{ "Data Class", "vcdu.smex.data_class",\r\nFT_UINT16, BASE_DEC, VALS(smex_data_class), 0x1f,\r\n"SMEX Data Class", HFILL }\r\n},\r\n{ &hf_smex_pb5,\r\n{ "PB5 Flag", "vcdu.smex.pb5",\r\nFT_UINT16, BASE_DEC, NULL, 0x8000,\r\n"SMEX PB5 Flag", HFILL }\r\n},\r\n{ &hf_smex_jday,\r\n{ "Julian Day", "vcdu.smex.jday",\r\nFT_UINT16, BASE_DEC, NULL, PB5_JULIAN_DAY_MASK,\r\n"SMEX Julian Day", HFILL }\r\n},\r\n{ &hf_smex_seconds,\r\n{ "Seconds", "vcdu.smex.seconds",\r\nFT_UINT24, BASE_DEC, NULL, PB5_SECONDS_MASK,\r\n"SMEX Seconds", HFILL }\r\n},\r\n{ &hf_smex_msec,\r\n{ "Milliseconds", "vcdu.smex.msec",\r\nFT_UINT16, BASE_DEC, NULL, PB5_MILLISECONDS_MASK,\r\n"SMEX Milliseconds", HFILL }\r\n},\r\n#if 0\r\n{ &hf_smex_spare,\r\n{ "Spare", "vcdu.smex.spare",\r\nFT_UINT16, BASE_DEC, NULL, 0x03f,\r\n"SMEX Spare", HFILL }\r\n},\r\n#endif\r\n{ &hf_vcdu_version,\r\n{ "Version", "vcdu.version",\r\nFT_UINT16, BASE_DEC, NULL, 0xc0,\r\n"VCDU Version", HFILL }\r\n},\r\n{ &hf_vcdu_sp_id,\r\n{ "Space Craft ID", "vcdu.spid",\r\nFT_UINT16, BASE_DEC, NULL, 0x3fc0,\r\n"VCDU Space Craft ID", HFILL }\r\n},\r\n{ &hf_vcdu_vc_id,\r\n{ "Virtual Channel ID", "vcdu.vcid",\r\nFT_UINT16, BASE_DEC, NULL, 0x3f,\r\n"VCDU Virtual Channel ID", HFILL }\r\n},\r\n{ &hf_vcdu_seq,\r\n{ "Sequence Count", "vcdu.seq",\r\nFT_UINT16, BASE_DEC, NULL, 0xffffff,\r\n"VCDU Sequence Count", HFILL }\r\n},\r\n{ &hf_vcdu_replay,\r\n{ "Replay Flag", "vcdu.replay",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\n"VCDU Replay Flag", HFILL }\r\n},\r\n{ &hf_vcdu_ground_receipt_time, { "Ground Receipt Time", "vcdu.ground_receipt_time", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_vcdu_bitream_all_data, { "Bitream ALL Data", "vcdu.bitream.all_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_vcdu_bitream_all_data_anomaly, { "Bitream ALL Data (Anomaly)", "vcdu.bitream.all_data_anomaly", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_vcdu_bitream_all_fill, { "Bitream ALL Fill", "vcdu.bitream.all_fill", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_vcdu_ccsds_all_fill, { "Ccsds ALL Fill", "vcdu.ccsds.all_fill", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_vcdu_ccsds_continuation_packet, { "Ccsds Continuation Packet", "vcdu.ccsds_continuation_packet", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_vcdu_data, { "Data", "vcdu.data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_vcdu_fhp,\r\n{ "First Header Pointer", "vcdu.fhp",\r\nFT_UINT16, BASE_DEC, NULL, FHP_MASK,\r\n"VCDU/MPDU First Header Pointer", HFILL }\r\n},\r\n{ &hf_vcdu_lbp,\r\n{ "Last Bit Pointer", "vcdu.lbp",\r\nFT_UINT16, BASE_DEC, NULL, LBP_MASK,\r\n"VCDU/BPDU Last Bit Pointer", HFILL }\r\n}\r\n};\r\nstatic uat_field_t vcdu_uat_flds[] = {\r\nUAT_FLD_DEC(uat_bitchannels, channel, "Bitstream Channel", "Bitstream Channel"),\r\nUAT_END_FIELDS\r\n};\r\nstatic gint *ett[] = {\r\n&ett_vcdu,\r\n&ett_smex,\r\n&ett_vcduh,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_vcdu_fhp_too_close_to_end_of_vcdu, { "vcdu.fhp_too_close_to_end_of_vcdu", PI_PROTOCOL, PI_WARN, "FHP too close to end of VCDU. Incomplete Hdr Info Available - Unable to format CCSDS Hdr(s).", EXPFILL }},\r\n};\r\nexpert_module_t* expert_vcdu;\r\nproto_vcdu = proto_register_protocol("VCDU", "VCDU", "vcdu");\r\nproto_register_field_array(proto_vcdu, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_vcdu = expert_register_protocol(proto_vcdu);\r\nexpert_register_field_array(expert_vcdu, ei, array_length(ei));\r\nvcdu_handle = register_dissector("vcdu", dissect_vcdu, proto_vcdu);\r\nvcdu_module = prefs_register_protocol(proto_vcdu, vcdu_prefs_apply_cb);\r\nvcdu_uat = uat_new("Bitstream Channel Table",\r\nsizeof(uat_channel_t),\r\n"vcdu_bitstream_channels",\r\nTRUE,\r\n&uat_bitchannels,\r\n&num_channels_uat,\r\nUAT_AFFECTS_DISSECTION,\r\nNULL,\r\nNULL,\r\nvcdu_uat_data_update_cb,\r\nNULL,\r\nNULL,\r\nvcdu_uat_flds);\r\nprefs_register_uat_preference(vcdu_module,\r\n"bitstream_channels",\r\n"Bitstream Channel Table",\r\n"Bitstream Channel Table",\r\nvcdu_uat);\r\n}\r\nvoid\r\nproto_reg_handoff_vcdu(void)\r\n{\r\ndissector_add_for_decode_as("udp.port", vcdu_handle);\r\nccsds_handle = find_dissector_add_dependency("ccsds", proto_vcdu);\r\n}
