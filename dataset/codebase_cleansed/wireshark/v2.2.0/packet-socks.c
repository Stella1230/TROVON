static const char *get_auth_method_name( guint Number){\r\nif ( Number == 0) return "No authentication";\r\nif ( Number == 1) return "GSSAPI";\r\nif ( Number == 2) return "Username/Password";\r\nif ( Number == 3) return "Chap";\r\nif (( Number >= 4) && ( Number <= 0x7f))return "IANA assigned";\r\nif (( Number >= 0x80) && ( Number <= 0xfe)) return "private method";\r\nif ( Number == 0xff) return "no acceptable method";\r\nreturn "Bad method number (not 0-0xff)";\r\n}\r\nstatic int display_address(tvbuff_t *tvb, int offset, proto_tree *tree) {\r\nint a_type = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item( tree, hf_socks_address_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nswitch (a_type)\r\n{\r\ncase 1:\r\nproto_tree_add_item( tree, hf_socks_ip_dst, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase 3:\r\n{\r\nguint8 len;\r\ngchar* str;\r\nlen = tvb_get_guint8(tvb, offset);\r\nstr = tvb_get_string_enc(wmem_packet_scope(), tvb, offset+1, len, ENC_ASCII);\r\nproto_tree_add_string(tree, hf_socks_remote_name, tvb, offset, len+1, str);\r\noffset += (len+1);\r\n}\r\nbreak;\r\ncase 4:\r\nproto_tree_add_item( tree, hf_socks_ip6_dst, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int get_address_v5(tvbuff_t *tvb, int offset,\r\nsocks_hash_entry_t *hash_info) {\r\nint a_type;\r\naddress addr;\r\na_type = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nswitch(a_type)\r\n{\r\ncase 1:\r\nif ( hash_info) {\r\nset_address_tvb(&addr, AT_IPv4, 4, tvb, offset);\r\ncopy_address_wmem(wmem_file_scope(), &hash_info->dst_addr, &addr);\r\n}\r\noffset += 4;\r\nbreak;\r\ncase 4:\r\nif ( hash_info) {\r\nset_address_tvb(&addr, AT_IPv6, 16, tvb, offset);\r\ncopy_address_wmem(wmem_file_scope(), &hash_info->dst_addr, &addr);\r\n}\r\noffset += 16;\r\nbreak;\r\ncase 3:\r\noffset += tvb_get_guint8(tvb, offset) + 1;\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nsocks_udp_dissector(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nint offset = 0;\r\nguint32 *ptr;\r\nsocks_hash_entry_t *hash_info;\r\nconversation_t *conversation;\r\nproto_tree *socks_tree;\r\nproto_item *ti;\r\nconversation = find_conversation( pinfo->num, &pinfo->src, &pinfo->dst, pinfo->ptype,\r\npinfo->srcport, pinfo->destport, 0);\r\nDISSECTOR_ASSERT( conversation);\r\nhash_info = (socks_hash_entry_t *)conversation_get_proto_data(conversation, proto_socks);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Socks");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Version: 5, UDP Associated packet");\r\nif ( tree) {\r\nti = proto_tree_add_protocol_format( tree, proto_socks, tvb, offset, -1, "Socks" );\r\nsocks_tree = proto_item_add_subtree(ti, ett_socks);\r\nproto_tree_add_item(socks_tree, hf_socks_reserved2, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(socks_tree, hf_socks_fragment_number, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset = display_address( tvb, offset, socks_tree);\r\nhash_info->udp_remote_port = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint( socks_tree, hf_socks_dstport, tvb,\r\noffset, 2, hash_info->udp_remote_port);\r\noffset += 2;\r\n}\r\nelse {\r\noffset += 3;\r\noffset = get_address_v5( tvb, offset, 0) + 2;\r\n}\r\nif ( pinfo->srcport == hash_info->port)\r\nptr = &pinfo->destport;\r\nelse\r\nptr = &pinfo->srcport;\r\n*ptr = hash_info->udp_remote_port;\r\ndecode_udp_ports( tvb, offset, pinfo, tree, pinfo->srcport, pinfo->destport, -1);\r\n*ptr = hash_info->udp_port;\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\nnew_udp_conversation( socks_hash_entry_t *hash_info, packet_info *pinfo){\r\nconversation_t *conversation = conversation_new( pinfo->num, &pinfo->src, &pinfo->dst, PT_UDP,\r\nhash_info->udp_port, hash_info->port, 0);\r\nDISSECTOR_ASSERT( conversation);\r\nconversation_add_proto_data(conversation, proto_socks, hash_info);\r\nconversation_set_dissector(conversation, socks_udp_handle);\r\n}\r\nstatic void\r\nsave_client_state(packet_info *pinfo, enum ClientState state)\r\n{\r\nsock_state_t* state_info = (sock_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_socks, 0);\r\nif ((state_info != NULL) && (state_info->client == clientNoInit)) {\r\nstate_info->client = state;\r\n}\r\n}\r\nstatic void\r\nsave_server_state(packet_info *pinfo, enum ServerState state)\r\n{\r\nsock_state_t* state_info = (sock_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_socks, 0);\r\nif ((state_info != NULL) && (state_info->server == serverNoInit)) {\r\nstate_info->server = state;\r\n}\r\n}\r\nstatic void\r\ndisplay_socks_v4(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, socks_hash_entry_t *hash_info, sock_state_t* state_info) {\r\nunsigned char ipaddr[4];\r\nguint str_len;\r\nif (state_info == NULL)\r\nreturn;\r\nif (hash_info->server_port == pinfo->destport) {\r\nswitch (state_info->client)\r\n{\r\ncase clientStart:\r\nproto_tree_add_item( tree, hf_socks_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item( tree, hf_socks_cmd, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item( tree, hf_socks_dstport, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\ntvb_memcpy(tvb, ipaddr, offset, 4);\r\nproto_tree_add_item( tree, hf_socks_ip_dst, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nstr_len = tvb_strsize(tvb, offset);\r\nproto_tree_add_item( tree, hf_socks_username, tvb, offset, str_len, ENC_ASCII|ENC_NA);\r\noffset += str_len;\r\nif ( ipaddr[0] == 0 && ipaddr[1] == 0 &&\r\nipaddr[2] == 0 && ipaddr[3] != 0) {\r\nstr_len = tvb_strsize(tvb, offset);\r\nproto_tree_add_item( tree, hf_v4a_dns_name, tvb, offset, str_len, ENC_ASCII|ENC_NA);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (state_info->server)\r\n{\r\ncase serverStart:\r\nproto_tree_add_item( tree, hf_socks_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item( tree, hf_socks_results_4, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item( tree, hf_socks_dstport, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item( tree, hf_socks_ip_dst, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nclient_display_socks_v5(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, socks_hash_entry_t *hash_info, sock_state_t* state_info) {\r\nunsigned int i;\r\nconst char *AuthMethodStr;\r\nsock_state_t new_state_info;\r\nif (state_info == NULL)\r\nreturn;\r\nproto_tree_add_item( tree, hf_socks_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (state_info->client == clientStart)\r\n{\r\nproto_tree *AuthTree;\r\nproto_item *ti;\r\nguint8 num_auth_methods, auth;\r\nAuthTree = proto_tree_add_subtree( tree, tvb, offset, -1, ett_socks_auth, &ti, "Client Authentication Methods");\r\nnum_auth_methods = tvb_get_guint8(tvb, offset);\r\nproto_item_set_len(ti, num_auth_methods+1);\r\nproto_tree_add_item( AuthTree, hf_client_auth_method_count, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nfor( i = 0; i < num_auth_methods; ++i) {\r\nauth = tvb_get_guint8( tvb, offset);\r\nAuthMethodStr = get_auth_method_name(auth);\r\nproto_tree_add_uint_format(AuthTree, hf_client_auth_method, tvb, offset, 1, auth,\r\n"Method[%u]: %u (%s)", i, auth, AuthMethodStr);\r\noffset += 1;\r\n}\r\nif ((num_auth_methods == 1) &&\r\n(tvb_bytes_exist(tvb, offset + 2, 1)) &&\r\n(tvb_get_guint8(tvb, offset + 2) == 0) &&\r\n(tvb_reported_length_remaining(tvb, offset + 2 + num_auth_methods) > 0)) {\r\nnew_state_info.client = clientV5Command;\r\nclient_display_socks_v5(tvb, offset, pinfo, tree, hash_info, &new_state_info);\r\n}\r\n}\r\nelse if (state_info->client == clientV5Command) {\r\nproto_tree_add_item( tree, hf_socks_cmd, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item( tree, hf_socks_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset = display_address(tvb, offset, tree);\r\nproto_tree_add_item( tree, hf_client_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\nelse if ((state_info->client == clientWaitForAuthReply) &&\r\n(state_info->server == serverInitReply)) {\r\nguint16 len;\r\ngchar* str;\r\nswitch(hash_info->authentication_method)\r\n{\r\ncase NO_AUTHENTICATION:\r\nbreak;\r\ncase USER_NAME_AUTHENTICATION:\r\nlen = tvb_get_guint8(tvb, offset);\r\nstr = tvb_get_string_enc(wmem_packet_scope(), tvb, offset+1, len, ENC_ASCII);\r\nproto_tree_add_string(tree, hf_socks_username, tvb, offset, len+1, str);\r\noffset += (len+1);\r\nlen = tvb_get_guint8(tvb, offset);\r\nstr = tvb_get_string_enc(wmem_packet_scope(), tvb, offset+1, len, ENC_ASCII);\r\nproto_tree_add_string(tree, hf_socks_password, tvb, offset, len+1, str);\r\nbreak;\r\ncase GSS_API_AUTHENTICATION:\r\nproto_tree_add_item( tree, hf_gssapi_command, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item( tree, hf_gssapi_length, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nlen = tvb_get_ntohs(tvb, offset+1);\r\nif (len > 0)\r\nproto_tree_add_item( tree, hf_gssapi_payload, tvb, offset+3, len, ENC_NA);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nserver_display_socks_v5(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree, socks_hash_entry_t *hash_info _U_, sock_state_t* state_info) {\r\nconst char *AuthMethodStr;\r\nguint8 auth, auth_status;\r\nproto_item *ti;\r\nif (state_info == NULL)\r\nreturn;\r\nproto_tree_add_item( tree, hf_socks_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nswitch(state_info->server)\r\n{\r\ncase serverStart:\r\nauth = tvb_get_guint8( tvb, offset);\r\nAuthMethodStr = get_auth_method_name(auth);\r\nproto_tree_add_uint_format_value(tree, hf_server_accepted_auth_method, tvb, offset, 1, auth,\r\n"0x%0x (%s)", auth, AuthMethodStr);\r\nbreak;\r\ncase serverUserReply:\r\nauth_status = tvb_get_guint8(tvb, offset);\r\nti = proto_tree_add_item(tree, hf_server_auth_status, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif(auth_status != 0)\r\nproto_item_append_text(ti, " (failure)");\r\nelse\r\nproto_item_append_text(ti, " (success)");\r\nbreak;\r\ncase serverGssApiReply:\r\nauth_status = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item( tree, hf_gssapi_command, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (auth_status != 0xFF) {\r\nguint16 len;\r\nproto_tree_add_item( tree, hf_gssapi_length, tvb, offset+1, 2, ENC_BIG_ENDIAN);\r\nlen = tvb_get_ntohs(tvb, offset+1);\r\nif (len > 0)\r\nproto_tree_add_item( tree, hf_gssapi_payload, tvb, offset+3, len, ENC_NA);\r\n}\r\nbreak;\r\ncase serverCommandReply:\r\nproto_tree_add_item( tree, hf_socks_results_5, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item( tree, hf_socks_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset = display_address(tvb, offset, tree);\r\nproto_tree_add_item( tree, hf_client_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase serverBindReply:\r\nproto_tree_add_item( tree, hf_socks_results_5, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item( tree, hf_socks_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset = display_address(tvb, offset, tree);\r\nproto_tree_add_item( tree, hf_server_remote_host_port, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nstate_machine_v4( socks_hash_entry_t *hash_info, tvbuff_t *tvb,\r\nint offset, packet_info *pinfo) {\r\naddress addr;\r\nif (hash_info->clientState != clientDone)\r\nsave_client_state(pinfo, hash_info->clientState);\r\nif (hash_info->serverState != serverDone)\r\nsave_server_state(pinfo, hash_info->serverState);\r\nif (hash_info->server_port == pinfo->destport) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Connect to server request");\r\nhash_info->command = tvb_get_guint8(tvb, offset + 1);\r\nif ( hash_info->command == CONNECT_COMMAND)\r\nhash_info->port = tvb_get_ntohs(tvb, offset + 2);\r\nset_address_tvb(&addr, AT_IPv4, 4, tvb, offset);\r\ncopy_address_wmem(wmem_file_scope(), &hash_info->dst_addr, &addr);\r\nhash_info->clientState = clientDone;\r\n}\r\nelse {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Connect Response");\r\nif (tvb_get_guint8(tvb, offset + 1) == 90)\r\nhash_info->serverState = serverDone;\r\nelse\r\nhash_info->serverState = serverError;\r\n}\r\n}\r\nstatic void\r\nclient_state_machine_v5( socks_hash_entry_t *hash_info, tvbuff_t *tvb,\r\nint offset, packet_info *pinfo, gboolean start_of_frame) {\r\nif (start_of_frame)\r\nsave_client_state(pinfo, hash_info->clientState);\r\nif (hash_info->clientState == clientStart)\r\n{\r\nguint8 num_auth_methods;\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Connect to server request");\r\nnum_auth_methods = tvb_get_guint8(tvb, offset + 1);\r\nif ((num_auth_methods == 0) ||\r\n((num_auth_methods == 1) &&\r\n(tvb_get_guint8(tvb, offset + 2) == 0))) {\r\nhash_info->clientState = clientV5Command;\r\nif (tvb_reported_length_remaining(tvb, offset + 2 + num_auth_methods) > 0) {\r\nclient_state_machine_v5(hash_info, tvb, offset + 2 + num_auth_methods, pinfo, FALSE);\r\n}\r\n} else {\r\nhash_info->clientState = clientWaitForAuthReply;\r\n}\r\n} else if ((hash_info->clientState == clientWaitForAuthReply) &&\r\n(hash_info->serverState == serverInitReply)) {\r\nswitch(hash_info->authentication_method)\r\n{\r\ncase NO_AUTHENTICATION:\r\nhash_info->clientState = clientV5Command;\r\nhash_info->serverState = serverCommandReply;\r\nbreak;\r\ncase USER_NAME_AUTHENTICATION:\r\nhash_info->clientState = clientV5Command;\r\nhash_info->serverState = serverUserReply;\r\nbreak;\r\ncase GSS_API_AUTHENTICATION:\r\nhash_info->clientState = clientV5Command;\r\nhash_info->serverState = serverGssApiReply;\r\nbreak;\r\ndefault:\r\nhash_info->clientState = clientError;\r\nbreak;\r\n}\r\n} else if (hash_info->clientState == clientV5Command) {\r\nhash_info->command = tvb_get_guint8(tvb, offset + 1);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Command Request - %s",\r\nval_to_str_const(hash_info->command, cmd_strings, "Unknown"));\r\noffset += 3;\r\noffset = get_address_v5(tvb, offset, hash_info);\r\nif (( hash_info->command == CONNECT_COMMAND) ||\r\n( hash_info->command == UDP_ASSOCIATE_COMMAND))\r\nhash_info->port = tvb_get_ntohs(tvb, offset);\r\nhash_info->clientState = clientDone;\r\n}\r\n}\r\nstatic void\r\nserver_state_machine_v5( socks_hash_entry_t *hash_info, tvbuff_t *tvb,\r\nint offset, packet_info *pinfo, gboolean start_of_frame) {\r\nif (start_of_frame)\r\nsave_server_state(pinfo, hash_info->serverState);\r\nswitch (hash_info->serverState) {\r\ncase serverStart:\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Connect to server response");\r\nhash_info->authentication_method = tvb_get_guint8(tvb, offset + 1);\r\nhash_info->serverState = serverInitReply;\r\nswitch (hash_info->authentication_method)\r\n{\r\ncase NO_AUTHENTICATION:\r\nhash_info->serverState = serverCommandReply;\r\nhash_info->clientState = clientV5Command;\r\nbreak;\r\ncase USER_NAME_AUTHENTICATION:\r\nhash_info->serverState = serverUserReply;\r\nbreak;\r\ncase GSS_API_AUTHENTICATION:\r\nhash_info->serverState = serverGssApiReply;\r\nbreak;\r\ndefault:\r\nhash_info->serverState = serverError;\r\nbreak;\r\n}\r\nbreak;\r\ncase serverUserReply:\r\ncol_append_str(pinfo->cinfo, COL_INFO, " User authentication reply");\r\nbreak;\r\ncase serverGssApiReply:\r\nif (tvb_get_guint8(tvb, offset+1) == 0xFF) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " GSSAPI Authentication failure");\r\nhash_info->serverState = serverError;\r\n} else {\r\ncol_append_str(pinfo->cinfo, COL_INFO, " GSSAPI Authentication reply");\r\nif (tvb_get_ntohs(tvb, offset+2) == 0)\r\nhash_info->serverState = serverCommandReply;\r\n}\r\nbreak;\r\ncase serverCommandReply:\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " Command Response - %s",\r\nval_to_str_const(hash_info->command, cmd_strings, "Unknown"));\r\nswitch(hash_info->command)\r\n{\r\ncase CONNECT_COMMAND:\r\ncase PING_COMMAND:\r\ncase TRACERT_COMMAND:\r\nhash_info->serverState = serverDone;\r\nbreak;\r\ncase BIND_COMMAND:\r\nhash_info->serverState = serverBindReply;\r\nif ((tvb_get_guint8(tvb, offset + 2) == 0) &&\r\n(tvb_reported_length_remaining(tvb, offset) > 5)) {\r\noffset = display_address(tvb, offset, NULL);\r\nclient_state_machine_v5(hash_info, tvb, offset, pinfo, FALSE);\r\n}\r\nbreak;\r\ncase UDP_ASSOCIATE_COMMAND:\r\noffset += 3;\r\noffset = get_address_v5(tvb, offset, hash_info);\r\nhash_info->udp_port = tvb_get_ntohs(tvb, offset);\r\nif (!pinfo->fd->flags.visited)\r\nnew_udp_conversation( hash_info, pinfo);\r\nbreak;\r\n}\r\nbreak;\r\ncase serverBindReply:\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Command Response: Bind remote host info");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndisplay_ping_and_tracert(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, socks_hash_entry_t *hash_info) {\r\nconst guchar *data, *dataend;\r\nconst guchar *lineend, *eol;\r\nint linelen;\r\nif ( pinfo->destport == TCP_PORT_SOCKS){\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", Terminate Request");\r\nproto_tree_add_item(tree, (hash_info->command == PING_COMMAND) ? hf_socks_ping_end_command : hf_socks_traceroute_end_command, tvb, offset, 1, ENC_NA);\r\n}\r\nelse {\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", Results");\r\nif ( tree){\r\nproto_tree_add_item(tree, (hash_info->command == PING_COMMAND) ? hf_socks_ping_results : hf_socks_traceroute_results, tvb, offset, -1, ENC_NA);\r\ndata = tvb_get_ptr(tvb, offset, -1);\r\ndataend = data + tvb_captured_length_remaining(tvb, offset);\r\nwhile (data < dataend) {\r\nlineend = find_line_end(data, dataend, &eol);\r\nlinelen = (int)(lineend - data);\r\nproto_tree_add_format_text( tree, tvb, offset, linelen);\r\noffset += linelen;\r\ndata = lineend;\r\n}\r\n}\r\n}\r\n}\r\nstatic void clear_in_socks_dissector_flag(void *s)\r\n{\r\nsock_state_t* state_info = (sock_state_t*)s;\r\nstate_info->in_socks_dissector_flag = 0;\r\n}\r\nstatic void call_next_dissector(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, proto_tree *socks_tree,\r\nsocks_hash_entry_t *hash_info, sock_state_t* state_info, struct tcpinfo *tcpinfo)\r\n{\r\nguint32 *ptr;\r\nguint16 save_can_desegment;\r\nstruct tcp_analysis *tcpd=NULL;\r\ntcpd=get_tcp_conversation_data(NULL,pinfo);\r\nif (( hash_info->command == PING_COMMAND) ||\r\n( hash_info->command == TRACERT_COMMAND))\r\ndisplay_ping_and_tracert(tvb, offset, pinfo, tree, hash_info);\r\nelse {\r\nif ( pinfo->destport == TCP_PORT_SOCKS)\r\nptr = &pinfo->destport;\r\nelse\r\nptr = &pinfo->srcport;\r\n*ptr = hash_info->port;\r\nstate_info->in_socks_dissector_flag = 1;\r\nCLEANUP_PUSH(clear_in_socks_dissector_flag, state_info);\r\nsave_can_desegment = pinfo->can_desegment;\r\npinfo->can_desegment = pinfo->saved_can_desegment;\r\ndissect_tcp_payload(tvb, pinfo, offset, tcpinfo->seq,\r\ntcpinfo->nxtseq, pinfo->srcport, pinfo->destport,\r\ntree, socks_tree, tcpd, tcpinfo);\r\npinfo->can_desegment = save_can_desegment;\r\nCLEANUP_CALL_AND_POP;\r\n*ptr = TCP_PORT_SOCKS;\r\n}\r\n}\r\nstatic int\r\ndissect_socks(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data) {\r\nint offset = 0;\r\nproto_tree *socks_tree = NULL;\r\nproto_item *ti;\r\nsocks_hash_entry_t *hash_info;\r\nconversation_t *conversation;\r\nsock_state_t* state_info;\r\nguint8 version;\r\nstruct tcpinfo *tcpinfo = (struct tcpinfo*)data;\r\nstate_info = (sock_state_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_socks, 0);\r\nif (state_info == NULL) {\r\nstate_info = wmem_new(wmem_file_scope(), sock_state_t);\r\nstate_info->in_socks_dissector_flag = 0;\r\nstate_info->client = clientNoInit;\r\nstate_info->server = serverNoInit;\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_socks, 0, state_info);\r\n}\r\nif (state_info->in_socks_dissector_flag)\r\nreturn 0;\r\nconversation = find_conversation(pinfo->num, &pinfo->src, &pinfo->dst,\r\npinfo->ptype, pinfo->srcport, pinfo->destport, 0);\r\nif (conversation == NULL) {\r\nversion = tvb_get_guint8(tvb, offset);\r\nif ((version != 4) && (version != 5))\r\nreturn 0;\r\nconversation = conversation_new(pinfo->num, &pinfo->src, &pinfo->dst,\r\npinfo->ptype, pinfo->srcport, pinfo->destport, 0);\r\n}\r\nhash_info = (socks_hash_entry_t *)conversation_get_proto_data(conversation,proto_socks);\r\nif (hash_info == NULL){\r\nhash_info = wmem_new0(wmem_file_scope(), socks_hash_entry_t);\r\nhash_info->start_done_frame = G_MAXINT;\r\nhash_info->clientState = clientStart;\r\nhash_info->serverState = serverStart;\r\nhash_info->server_port = pinfo->destport;\r\nhash_info->port = 0;\r\nhash_info->version = tvb_get_guint8(tvb, offset);\r\nconversation_add_proto_data(conversation, proto_socks, hash_info);\r\nconversation_set_dissector(conversation, socks_handle);\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Socks");\r\nif (( hash_info->version == 4) || ( hash_info->version == 5)){\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Version: %d",\r\nhash_info->version);\r\n}\r\nelse\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Unknown");\r\nif ( hash_info->command == PING_COMMAND)\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", Ping Req");\r\nif ( hash_info->command == TRACERT_COMMAND)\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", Traceroute Req");\r\nif ( hash_info->port != 0)\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Remote Port: %u",\r\nhash_info->port);\r\nif ((!pinfo->fd->flags.visited) &&\r\n(!((hash_info->clientState == clientDone) &&\r\n(hash_info->serverState == serverDone)))) {\r\nif (hash_info->server_port == pinfo->destport) {\r\nif ((hash_info->clientState != clientError) &&\r\n(hash_info->clientState != clientDone))\r\n{\r\nif ( hash_info->version == 4) {\r\nstate_machine_v4( hash_info, tvb, offset, pinfo);\r\n} else if ( hash_info->version == 5) {\r\nclient_state_machine_v5( hash_info, tvb, offset, pinfo, TRUE);\r\n}\r\n}\r\n} else {\r\nif ((hash_info->serverState != serverError) &&\r\n(hash_info->serverState != serverDone)) {\r\nif ( hash_info->version == 4) {\r\nstate_machine_v4( hash_info, tvb, offset, pinfo);\r\n} else if ( hash_info->version == 5) {\r\nserver_state_machine_v5( hash_info, tvb, offset, pinfo, TRUE);\r\n}\r\n}\r\n}\r\nif ((hash_info->clientState == clientDone) &&\r\n(hash_info->serverState == serverDone)) {\r\nhash_info->start_done_frame = pinfo->num;\r\n}\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item( tree, proto_socks, tvb, offset, -1, ENC_NA );\r\nsocks_tree = proto_item_add_subtree(ti, ett_socks);\r\nif (hash_info->server_port == pinfo->destport) {\r\nif ( hash_info->version == 4) {\r\ndisplay_socks_v4(tvb, offset, pinfo, socks_tree, hash_info, state_info);\r\n} else if ( hash_info->version == 5) {\r\nclient_display_socks_v5(tvb, offset, pinfo, socks_tree, hash_info, state_info);\r\n}\r\n} else {\r\nif ( hash_info->version == 4) {\r\ndisplay_socks_v4(tvb, offset, pinfo, socks_tree, hash_info, state_info);\r\n} else if ( hash_info->version == 5) {\r\nserver_display_socks_v5(tvb, offset, pinfo, socks_tree, hash_info, state_info);\r\n}\r\n}\r\nif ( pinfo->num > hash_info->start_done_frame){\r\nti = proto_tree_add_uint( socks_tree, hf_socks_cmd, tvb, offset, 0, hash_info->command);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nif (hash_info->dst_addr.type == AT_IPv4) {\r\nti = proto_tree_add_ipv4( socks_tree, hf_socks_ip_dst, tvb,\r\noffset, 0, *((const guint32*)hash_info->dst_addr.data));\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n} else if (hash_info->dst_addr.type == AT_IPv6) {\r\nti = proto_tree_add_ipv6( socks_tree, hf_socks_ip6_dst, tvb,\r\noffset, 0, (const struct e_in6_addr *)hash_info->dst_addr.data);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\nif (( hash_info->command != PING_COMMAND) &&\r\n( hash_info->command != TRACERT_COMMAND)){\r\nti = proto_tree_add_uint( socks_tree, hf_socks_dstport, tvb, offset, 0, hash_info->port);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\n}\r\n}\r\nif ( pinfo->num > hash_info->start_done_frame){\r\ncall_next_dissector(tvb, offset, pinfo, tree, socks_tree,\r\nhash_info, state_info, tcpinfo);\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_socks( void){\r\nstatic gint *ett[] = {\r\n&ett_socks,\r\n&ett_socks_auth,\r\n&ett_socks_name\r\n};\r\nstatic hf_register_info hf[] = {\r\n{ &hf_socks_ver,\r\n{ "Version", "socks.version", FT_UINT8, BASE_DEC, NULL,\r\n0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_ip_dst,\r\n{ "Remote Address", "socks.dst", FT_IPv4, BASE_NONE, NULL,\r\n0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_ip6_dst,\r\n{ "Remote Address(ipv6)", "socks.dstV6", FT_IPv6, BASE_NONE, NULL,\r\n0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_gssapi_payload,\r\n{ "GSSAPI data", "socks.gssapi.data", FT_BYTES, BASE_NONE, NULL,\r\n0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_gssapi_command,\r\n{ "SOCKS/GSSAPI command", "socks.gssapi.command", FT_UINT8, BASE_DEC,\r\nVALS(gssapi_command_table), 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_gssapi_length,\r\n{ "SOCKS/GSSAPI data length", "socks.gssapi.length", FT_UINT16, BASE_DEC, NULL,\r\n0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_v4a_dns_name,\r\n{ "SOCKS v4a Remote Domain Name", "socks.v4a_dns_name", FT_STRINGZ, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_dstport,\r\n{ "Remote Port", "socks.dstport", FT_UINT16,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_cmd,\r\n{ "Command", "socks.command", FT_UINT8,\r\nBASE_DEC, VALS(cmd_strings), 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_results_4,\r\n{ "Results(V4)", "socks.results", FT_UINT8,\r\nBASE_DEC, VALS(reply_table_v4), 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_results_5,\r\n{ "Results(V5)", "socks.results", FT_UINT8,\r\nBASE_DEC, VALS(reply_table_v5), 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_client_auth_method_count,\r\n{ "Authentication Method Count", "socks.auth_method_count", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_client_auth_method,\r\n{ "Method", "socks.auth_method", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_reserved,\r\n{ "Reserved", "socks.reserved", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_reserved2,\r\n{ "Reserved", "socks.reserved", FT_UINT16,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_client_port,\r\n{ "Port", "socks.port", FT_UINT16,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_server_accepted_auth_method,\r\n{ "Accepted Auth Method", "socks.auth_accepted_method", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_server_auth_status,\r\n{ "Status", "socks.auth_status", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_server_remote_host_port,\r\n{ "Remote Host Port", "socks.remote_host_port", FT_UINT16,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_username,\r\n{ "User name", "socks.username", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_password,\r\n{ "Password", "socks.password", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_remote_name,\r\n{ "Remote name", "socks.remote_name", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_address_type,\r\n{ "Address Type", "socks.address_type", FT_UINT8,\r\nBASE_DEC, VALS(address_type_table), 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_fragment_number,\r\n{ "Fragment Number", "socks.fragment_number", FT_UINT8,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_ping_end_command,\r\n{ "Ping: End command", "socks.ping_end_command", FT_NONE,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_ping_results,\r\n{ "Ping Results", "socks.ping_results", FT_NONE,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_traceroute_end_command,\r\n{ "Traceroute: End command", "socks.traceroute_end_command", FT_NONE,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n{ &hf_socks_traceroute_results,\r\n{ "Traceroute Results", "socks.traceroute_results", FT_NONE,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL\r\n}\r\n},\r\n};\r\nproto_socks = proto_register_protocol ( "Socks Protocol", "Socks", "socks");\r\nproto_register_field_array(proto_socks, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_socks(void) {\r\nsocks_udp_handle = create_dissector_handle(socks_udp_dissector, proto_socks);\r\nsocks_handle = create_dissector_handle(dissect_socks, proto_socks);\r\ndissector_add_uint("tcp.port", TCP_PORT_SOCKS, socks_handle);\r\n}
