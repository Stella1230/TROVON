wtap_open_return_val btsnoop_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar magic[sizeof btsnoop_magic];\r\nstruct btsnoop_hdr hdr;\r\nint file_encap=WTAP_ENCAP_UNKNOWN;\r\nif (!wtap_read_bytes(wth->fh, magic, sizeof magic, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(magic, btsnoop_magic, sizeof btsnoop_magic) != 0) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &hdr, sizeof hdr, err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nhdr.version = g_ntohl(hdr.version);\r\nif (hdr.version != 1) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("btsnoop: version %u unsupported", hdr.version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nhdr.datalink = g_ntohl(hdr.datalink);\r\nswitch (hdr.datalink) {\r\ncase KHciLoggerDatalinkTypeH1:\r\nfile_encap=WTAP_ENCAP_BLUETOOTH_HCI;\r\nbreak;\r\ncase KHciLoggerDatalinkTypeH4:\r\nfile_encap=WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR;\r\nbreak;\r\ncase KHciLoggerDatalinkTypeBCSP:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup("btsnoop: BCSP capture logs unsupported");\r\nreturn WTAP_OPEN_ERROR;\r\ncase KHciLoggerDatalinkTypeH5:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup("btsnoop: H5 capture logs unsupported");\r\nreturn WTAP_OPEN_ERROR;\r\ncase KHciLoggerDatalinkLinuxMonitor:\r\nfile_encap=WTAP_ENCAP_BLUETOOTH_LINUX_MONITOR;\r\nbreak;\r\ncase KHciLoggerDatalinkBlueZ5Simulator:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup("btsnoop: BlueZ 5 Simulator capture logs unsupported");\r\nreturn WTAP_OPEN_ERROR;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("btsnoop: datalink type %u unknown or unsupported", hdr.datalink);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nwth->subtype_read = btsnoop_read;\r\nwth->subtype_seek_read = btsnoop_seek_read;\r\nwth->file_encap = file_encap;\r\nwth->snapshot_length = 0;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_BTSNOOP;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean btsnoop_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nreturn btsnoop_read_record(wth, wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info);\r\n}\r\nstatic gboolean btsnoop_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nreturn btsnoop_read_record(wth, wth->random_fh, phdr, buf, err, err_info);\r\n}\r\nstatic gboolean btsnoop_read_record(wtap *wth, FILE_T fh,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nstruct btsnooprec_hdr hdr;\r\nguint32 packet_size;\r\nguint32 flags;\r\nguint32 orig_size;\r\ngint64 ts;\r\nif (!wtap_read_bytes_or_eof(fh, &hdr, sizeof hdr, err, err_info))\r\nreturn FALSE;\r\npacket_size = g_ntohl(hdr.incl_len);\r\norig_size = g_ntohl(hdr.orig_len);\r\nflags = g_ntohl(hdr.flags);\r\nif (packet_size > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("btsnoop: File has %u-byte packet, bigger than maximum of %u",\r\npacket_size, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nts = GINT64_FROM_BE(hdr.ts_usec);\r\nts -= KUnixTimeBase;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nphdr->ts.secs = (guint)(ts / 1000000);\r\nphdr->ts.nsecs = (guint)((ts % 1000000) * 1000);\r\nphdr->caplen = packet_size;\r\nphdr->len = orig_size;\r\nif(wth->file_encap == WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR)\r\n{\r\nphdr->pseudo_header.p2p.sent = (flags & KHciLoggerControllerToHost) ? FALSE : TRUE;\r\n} else if(wth->file_encap == WTAP_ENCAP_BLUETOOTH_HCI) {\r\nphdr->pseudo_header.bthci.sent = (flags & KHciLoggerControllerToHost) ? FALSE : TRUE;\r\nif(flags & KHciLoggerCommandOrEvent)\r\n{\r\nif(phdr->pseudo_header.bthci.sent)\r\n{\r\nphdr->pseudo_header.bthci.channel = BTHCI_CHANNEL_COMMAND;\r\n}\r\nelse\r\n{\r\nphdr->pseudo_header.bthci.channel = BTHCI_CHANNEL_EVENT;\r\n}\r\n}\r\nelse\r\n{\r\nphdr->pseudo_header.bthci.channel = BTHCI_CHANNEL_ACL;\r\n}\r\n} else if (wth->file_encap == WTAP_ENCAP_BLUETOOTH_LINUX_MONITOR) {\r\nphdr->pseudo_header.btmon.opcode = flags & 0xFFFF;\r\nphdr->pseudo_header.btmon.adapter_id = flags >> 16;\r\n}\r\nreturn wtap_read_packet_bytes(fh, buf, phdr->caplen, err, err_info);\r\n}\r\nint btsnoop_dump_can_write_encap(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (encap != WTAP_ENCAP_BLUETOOTH_H4_WITH_PHDR && encap != WTAP_ENCAP_BLUETOOTH_LINUX_MONITOR)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\nstatic guint8 btsnoop_lookup_flags(guint8 hci_type, gboolean sent, guint8 *flags)\r\n{\r\nguint8 i;\r\nfor (i=0; i < G_N_ELEMENTS(hci_flags); ++i)\r\n{\r\nif (hci_flags[i].hci_type == hci_type &&\r\nhci_flags[i].sent == sent)\r\n{\r\n*flags = hci_flags[i].flags;\r\nreturn TRUE;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean btsnoop_format_partial_rec_hdr(\r\nconst struct wtap_pkthdr *phdr,\r\nconst union wtap_pseudo_header *pseudo_header,\r\nconst guint8 *pd, int *err, gchar **err_info,\r\nstruct btsnooprec_hdr *rec_hdr)\r\n{\r\ngint64 ts_usec;\r\ngint64 nsecs;\r\nguint8 flags = 0;\r\nif (!btsnoop_lookup_flags(*pd, pseudo_header->p2p.sent, &flags)) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_DATA;\r\n*err_info = g_strdup_printf("btsnoop: hci_type 0x%02x for %s data isn't supported",\r\n*pd,\r\npseudo_header->p2p.sent ? "sent" : "received");\r\nreturn FALSE;\r\n}\r\nnsecs = phdr->ts.nsecs;\r\nts_usec = ((gint64) phdr->ts.secs * 1000000) + (nsecs / 1000);\r\nts_usec += KUnixTimeBase;\r\nrec_hdr->flags = GUINT32_TO_BE(flags);\r\nrec_hdr->cum_drops = GUINT32_TO_BE(0);\r\nrec_hdr->ts_usec = GINT64_TO_BE(ts_usec);\r\nreturn TRUE;\r\n}\r\nstatic gboolean btsnoop_dump_h1(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nstruct btsnooprec_hdr rec_hdr;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen-1 > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nif (!btsnoop_format_partial_rec_hdr(phdr, pseudo_header, pd, err, err_info,\r\n&rec_hdr))\r\nreturn FALSE;\r\nrec_hdr.incl_len = GUINT32_TO_BE(phdr->caplen-1);\r\nrec_hdr.orig_len = GUINT32_TO_BE(phdr->len-1);\r\nif (!wtap_dump_file_write(wdh, &rec_hdr, sizeof rec_hdr, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof rec_hdr;\r\n++pd;\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen-1, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += phdr->caplen-1;\r\nreturn TRUE;\r\n}\r\nstatic gboolean btsnoop_dump_h4(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nstruct btsnooprec_hdr rec_hdr;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nif (!btsnoop_format_partial_rec_hdr(phdr, pseudo_header, pd, err, err_info,\r\n&rec_hdr))\r\nreturn FALSE;\r\nrec_hdr.incl_len = GUINT32_TO_BE(phdr->caplen);\r\nrec_hdr.orig_len = GUINT32_TO_BE(phdr->len);\r\nif (!wtap_dump_file_write(wdh, &rec_hdr, sizeof rec_hdr, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof rec_hdr;\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += phdr->caplen;\r\nreturn TRUE;\r\n}\r\ngboolean btsnoop_dump_open_h1(wtap_dumper *wdh, int *err)\r\n{\r\nstruct btsnoop_hdr file_hdr;\r\nwdh->subtype_write = btsnoop_dump_h1;\r\nswitch (wdh->file_type_subtype) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_BTSNOOP:\r\nwdh->tsprecision = WTAP_TSPREC_USEC;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNWRITABLE_FILE_TYPE;\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, btsnoop_magic, sizeof btsnoop_magic, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof btsnoop_magic;\r\nfile_hdr.version = GUINT32_TO_BE(1);\r\nfile_hdr.datalink = GUINT32_TO_BE(KHciLoggerDatalinkTypeH1);\r\nif (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof file_hdr;\r\nreturn TRUE;\r\n}\r\ngboolean btsnoop_dump_open_h4(wtap_dumper *wdh, int *err)\r\n{\r\nstruct btsnoop_hdr file_hdr;\r\nwdh->subtype_write = btsnoop_dump_h4;\r\nswitch (wdh->file_type_subtype) {\r\ncase WTAP_FILE_TYPE_SUBTYPE_BTSNOOP:\r\nwdh->tsprecision = WTAP_TSPREC_USEC;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNWRITABLE_FILE_TYPE;\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, btsnoop_magic, sizeof btsnoop_magic, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof btsnoop_magic;\r\nfile_hdr.version = GUINT32_TO_BE(1);\r\nfile_hdr.datalink = GUINT32_TO_BE(KHciLoggerDatalinkTypeH4);\r\nif (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof file_hdr;\r\nreturn TRUE;\r\n}
