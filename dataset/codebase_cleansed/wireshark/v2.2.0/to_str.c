static inline char\r\nlow_nibble_of_octet_to_hex(guint8 oct)\r\n{\r\nstatic const gchar hex_digits[16] =\r\n{ '0', '1', '2', '3', '4', '5', '6', '7',\r\n'8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\r\nreturn hex_digits[oct & 0xF];\r\n}\r\nstatic inline char *\r\nbyte_to_hex(char *out, guint32 dword)\r\n{\r\n*out++ = low_nibble_of_octet_to_hex(dword >> 4);\r\n*out++ = low_nibble_of_octet_to_hex(dword);\r\nreturn out;\r\n}\r\nchar *\r\nword_to_hex(char *out, guint16 word)\r\n{\r\nout = byte_to_hex(out, word >> 8);\r\nout = byte_to_hex(out, word);\r\nreturn out;\r\n}\r\nchar *\r\nword_to_hex_punct(char *out, guint16 word, char punct)\r\n{\r\nout = byte_to_hex(out, word >> 8);\r\n*out++ = punct;\r\nout = byte_to_hex(out, word);\r\nreturn out;\r\n}\r\nchar *\r\nword_to_hex_npad(char *out, guint16 word)\r\n{\r\nif (word >= 0x1000)\r\n*out++ = low_nibble_of_octet_to_hex((guint8)(word >> 12));\r\nif (word >= 0x0100)\r\n*out++ = low_nibble_of_octet_to_hex((guint8)(word >> 8));\r\nif (word >= 0x0010)\r\n*out++ = low_nibble_of_octet_to_hex((guint8)(word >> 4));\r\n*out++ = low_nibble_of_octet_to_hex((guint8)(word >> 0));\r\nreturn out;\r\n}\r\nchar *\r\ndword_to_hex(char *out, guint32 dword)\r\n{\r\nout = word_to_hex(out, dword >> 16);\r\nout = word_to_hex(out, dword);\r\nreturn out;\r\n}\r\nchar *\r\ndword_to_hex_punct(char *out, guint32 dword, char punct)\r\n{\r\nout = word_to_hex_punct(out, dword >> 16, punct);\r\n*out++ = punct;\r\nout = word_to_hex_punct(out, dword, punct);\r\nreturn out;\r\n}\r\nchar *\r\nqword_to_hex(char *out, guint64 qword)\r\n{\r\nout = dword_to_hex(out, (guint32)(qword >> 32));\r\nout = dword_to_hex(out, (guint32)(qword & 0xffffffff));\r\nreturn out;\r\n}\r\nchar *\r\nqword_to_hex_punct(char *out, guint64 qword, char punct)\r\n{\r\nout = dword_to_hex_punct(out, (guint32)(qword >> 32), punct);\r\n*out++ = punct;\r\nout = dword_to_hex_punct(out, (guint32)(qword & 0xffffffff), punct);\r\nreturn out;\r\n}\r\nchar *\r\nbytes_to_hexstr(char *out, const guint8 *ad, guint32 len)\r\n{\r\nguint32 i;\r\nif (!ad)\r\nREPORT_DISSECTOR_BUG("Null pointer passed to bytes_to_hexstr()");\r\nfor (i = 0; i < len; i++)\r\nout = byte_to_hex(out, ad[i]);\r\nreturn out;\r\n}\r\nchar *\r\nbytes_to_hexstr_punct(char *out, const guint8 *ad, guint32 len, char punct)\r\n{\r\nguint32 i;\r\nif (!ad)\r\nREPORT_DISSECTOR_BUG("Null pointer passed to bytes_to_hexstr_punct()");\r\nout = byte_to_hex(out, ad[0]);\r\nfor (i = 1; i < len; i++) {\r\n*out++ = punct;\r\nout = byte_to_hex(out, ad[i]);\r\n}\r\nreturn out;\r\n}\r\ngchar *\r\nbytestring_to_str(wmem_allocator_t *scope, const guint8 *ad, const guint32 len, const char punct)\r\n{\r\ngchar *buf;\r\nguint32 buflen = len;\r\ngchar *buf_ptr;\r\nint truncated = 0;\r\nif (!punct)\r\nreturn bytes_to_str(scope, ad, len);\r\nif (!ad)\r\nREPORT_DISSECTOR_BUG("Null pointer passed to bytestring_to_str()");\r\nif (len == 0)\r\nreturn wmem_strdup(scope, "");\r\nbuf=(gchar *)wmem_alloc(scope, MAX_BYTE_STR_LEN+3+1);\r\nif (buflen > MAX_BYTE_STR_LEN/3) {\r\ntruncated = 1;\r\nbuflen = MAX_BYTE_STR_LEN/3;\r\n}\r\nbuf_ptr = bytes_to_hexstr_punct(buf, ad, buflen, punct);\r\nif (truncated) {\r\n*buf_ptr++ = punct;\r\nbuf_ptr = g_stpcpy(buf_ptr, "...");\r\n}\r\n*buf_ptr = '\0';\r\nreturn buf;\r\n}\r\nchar *\r\nbytes_to_str(wmem_allocator_t *scope, const guint8 *bd, int bd_len)\r\n{\r\ngchar *cur;\r\ngchar *cur_ptr;\r\nint truncated = 0;\r\nif (!bd)\r\nREPORT_DISSECTOR_BUG("Null pointer passed to bytes_to_str()");\r\ncur=(gchar *)wmem_alloc(scope, MAX_BYTE_STR_LEN+3+1);\r\nif (bd_len <= 0) { cur[0] = '\0'; return cur; }\r\nif (bd_len > MAX_BYTE_STR_LEN/2) {\r\ntruncated = 1;\r\nbd_len = MAX_BYTE_STR_LEN/2;\r\n}\r\ncur_ptr = bytes_to_hexstr(cur, bd, bd_len);\r\nif (truncated)\r\ncur_ptr = g_stpcpy(cur_ptr, "...");\r\n*cur_ptr = '\0';\r\nreturn cur;\r\n}\r\nstatic int\r\nguint32_to_str_buf_len(const guint32 u)\r\n{\r\nif (u >= 1000000000)return 10;\r\nif (u >= 100000000) return 9;\r\nif (u >= 10000000) return 8;\r\nif (u >= 1000000) return 7;\r\nif (u >= 100000) return 6;\r\nif (u >= 10000) return 5;\r\nif (u >= 1000) return 4;\r\nif (u >= 100) return 3;\r\nif (u >= 10) return 2;\r\nreturn 1;\r\n}\r\nstatic int\r\nguint64_to_str_buf_len(const guint64 u)\r\n{\r\nif (u >= G_GUINT64_CONSTANT(10000000000000000000)) return 20;\r\nif (u >= G_GUINT64_CONSTANT(1000000000000000000)) return 19;\r\nif (u >= G_GUINT64_CONSTANT(100000000000000000)) return 18;\r\nif (u >= G_GUINT64_CONSTANT(10000000000000000)) return 17;\r\nif (u >= G_GUINT64_CONSTANT(1000000000000000)) return 16;\r\nif (u >= G_GUINT64_CONSTANT(100000000000000)) return 15;\r\nif (u >= G_GUINT64_CONSTANT(10000000000000)) return 14;\r\nif (u >= G_GUINT64_CONSTANT(1000000000000)) return 13;\r\nif (u >= G_GUINT64_CONSTANT(100000000000)) return 12;\r\nif (u >= G_GUINT64_CONSTANT(10000000000)) return 11;\r\nif (u >= G_GUINT64_CONSTANT(1000000000)) return 10;\r\nif (u >= G_GUINT64_CONSTANT(100000000)) return 9;\r\nif (u >= G_GUINT64_CONSTANT(10000000)) return 8;\r\nif (u >= G_GUINT64_CONSTANT(1000000)) return 7;\r\nif (u >= G_GUINT64_CONSTANT(100000)) return 6;\r\nif (u >= G_GUINT64_CONSTANT(10000)) return 5;\r\nif (u >= G_GUINT64_CONSTANT(1000)) return 4;\r\nif (u >= G_GUINT64_CONSTANT(100)) return 3;\r\nif (u >= G_GUINT64_CONSTANT(10)) return 2;\r\nreturn 1;\r\n}\r\nvoid\r\nguint32_to_str_buf(guint32 u, gchar *buf, int buf_len)\r\n{\r\nint str_len = guint32_to_str_buf_len(u)+1;\r\ngchar *bp = &buf[str_len];\r\nif (buf_len < str_len) {\r\ng_strlcpy(buf, BUF_TOO_SMALL_ERR, buf_len);\r\nreturn;\r\n}\r\n*--bp = '\0';\r\nuint_to_str_back(bp, u);\r\n}\r\nvoid\r\nguint64_to_str_buf(guint64 u, gchar *buf, int buf_len)\r\n{\r\nint str_len = guint64_to_str_buf_len(u)+1;\r\ngchar *bp = &buf[str_len];\r\nif (buf_len < str_len) {\r\ng_strlcpy(buf, BUF_TOO_SMALL_ERR, buf_len);\r\nreturn;\r\n}\r\n*--bp = '\0';\r\nuint64_to_str_back(bp, u);\r\n}\r\nstatic const gchar *\r\nget_zonename(struct tm *tmp)\r\n{\r\n#if defined(HAVE_STRUCT_TM_TM_ZONE)\r\nreturn tmp->tm_zone;\r\n#else\r\nif ((tmp->tm_isdst != 0) && (tmp->tm_isdst != 1)) {\r\nreturn "???";\r\n}\r\n# if defined(HAVE_TZNAME)\r\nreturn tzname[tmp->tm_isdst];\r\n# elif defined(_WIN32)\r\n{\r\nstatic char *ws_tzname[2] = {NULL, NULL};\r\nif (ws_tzname[tmp->tm_isdst] == NULL) {\r\nws_tzname[tmp->tm_isdst] = g_locale_to_utf8(_tzname[tmp->tm_isdst], -1, NULL, NULL, NULL);\r\nif (ws_tzname[tmp->tm_isdst] == NULL) {\r\nws_tzname[tmp->tm_isdst] = "???";\r\n}\r\n}\r\nreturn ws_tzname[tmp->tm_isdst];\r\n}\r\n# else\r\nreturn tmp->tm_isdst ? "?DT" : "?ST";\r\n# endif\r\n#endif\r\n}\r\ngchar *\r\nabs_time_to_str(wmem_allocator_t *scope, const nstime_t *abs_time, const absolute_time_display_e fmt,\r\ngboolean show_zone)\r\n{\r\nstruct tm *tmp = NULL;\r\nconst char *zonename = "???";\r\ngchar *buf = NULL;\r\nswitch (fmt) {\r\ncase ABSOLUTE_TIME_UTC:\r\ncase ABSOLUTE_TIME_DOY_UTC:\r\ntmp = gmtime(&abs_time->secs);\r\nzonename = "UTC";\r\nbreak;\r\ncase ABSOLUTE_TIME_LOCAL:\r\ntmp = localtime(&abs_time->secs);\r\nif (tmp) {\r\nzonename = get_zonename(tmp);\r\n}\r\nbreak;\r\n}\r\nif (tmp) {\r\nswitch (fmt) {\r\ncase ABSOLUTE_TIME_DOY_UTC:\r\nif (show_zone) {\r\nbuf = wmem_strdup_printf(scope,\r\n"%04d/%03d:%02d:%02d:%02d.%09ld %s",\r\ntmp->tm_year + 1900,\r\ntmp->tm_yday + 1,\r\ntmp->tm_hour,\r\ntmp->tm_min,\r\ntmp->tm_sec,\r\n(long)abs_time->nsecs,\r\nzonename);\r\n} else {\r\nbuf = wmem_strdup_printf(scope,\r\n"%04d/%03d:%02d:%02d:%02d.%09ld",\r\ntmp->tm_year + 1900,\r\ntmp->tm_yday + 1,\r\ntmp->tm_hour,\r\ntmp->tm_min,\r\ntmp->tm_sec,\r\n(long)abs_time->nsecs);\r\n}\r\nbreak;\r\ncase ABSOLUTE_TIME_UTC:\r\ncase ABSOLUTE_TIME_LOCAL:\r\nif (show_zone) {\r\nbuf = wmem_strdup_printf(scope,\r\n"%s %2d, %d %02d:%02d:%02d.%09ld %s",\r\nmon_names[tmp->tm_mon],\r\ntmp->tm_mday,\r\ntmp->tm_year + 1900,\r\ntmp->tm_hour,\r\ntmp->tm_min,\r\ntmp->tm_sec,\r\n(long)abs_time->nsecs,\r\nzonename);\r\n} else {\r\nbuf = wmem_strdup_printf(scope,\r\n"%s %2d, %d %02d:%02d:%02d.%09ld",\r\nmon_names[tmp->tm_mon],\r\ntmp->tm_mday,\r\ntmp->tm_year + 1900,\r\ntmp->tm_hour,\r\ntmp->tm_min,\r\ntmp->tm_sec,\r\n(long)abs_time->nsecs);\r\n}\r\nbreak;\r\n}\r\n} else\r\nbuf = wmem_strdup(scope, "Not representable");\r\nreturn buf;\r\n}\r\ngchar *\r\nabs_time_secs_to_str(wmem_allocator_t *scope, const time_t abs_time, const absolute_time_display_e fmt,\r\ngboolean show_zone)\r\n{\r\nstruct tm *tmp = NULL;\r\nconst char *zonename = "???";\r\ngchar *buf = NULL;\r\nswitch (fmt) {\r\ncase ABSOLUTE_TIME_UTC:\r\ncase ABSOLUTE_TIME_DOY_UTC:\r\ntmp = gmtime(&abs_time);\r\nzonename = "UTC";\r\nbreak;\r\ncase ABSOLUTE_TIME_LOCAL:\r\ntmp = localtime(&abs_time);\r\nif (tmp) {\r\nzonename = get_zonename(tmp);\r\n}\r\nbreak;\r\n}\r\nif (tmp) {\r\nswitch (fmt) {\r\ncase ABSOLUTE_TIME_DOY_UTC:\r\nif (show_zone) {\r\nbuf = wmem_strdup_printf(scope,\r\n"%04d/%03d:%02d:%02d:%02d %s",\r\ntmp->tm_year + 1900,\r\ntmp->tm_yday + 1,\r\ntmp->tm_hour,\r\ntmp->tm_min,\r\ntmp->tm_sec,\r\nzonename);\r\n} else {\r\nbuf = wmem_strdup_printf(scope,\r\n"%04d/%03d:%02d:%02d:%02d",\r\ntmp->tm_year + 1900,\r\ntmp->tm_yday + 1,\r\ntmp->tm_hour,\r\ntmp->tm_min,\r\ntmp->tm_sec);\r\n}\r\nbreak;\r\ncase ABSOLUTE_TIME_UTC:\r\ncase ABSOLUTE_TIME_LOCAL:\r\nif (show_zone) {\r\nbuf = wmem_strdup_printf(scope,\r\n"%s %2d, %d %02d:%02d:%02d %s",\r\nmon_names[tmp->tm_mon],\r\ntmp->tm_mday,\r\ntmp->tm_year + 1900,\r\ntmp->tm_hour,\r\ntmp->tm_min,\r\ntmp->tm_sec,\r\nzonename);\r\n} else {\r\nbuf = wmem_strdup_printf(scope,\r\n"%s %2d, %d %02d:%02d:%02d",\r\nmon_names[tmp->tm_mon],\r\ntmp->tm_mday,\r\ntmp->tm_year + 1900,\r\ntmp->tm_hour,\r\ntmp->tm_min,\r\ntmp->tm_sec);\r\n}\r\nbreak;\r\n}\r\n} else\r\nbuf = wmem_strdup(scope, "Not representable");\r\nreturn buf;\r\n}\r\nvoid\r\ndisplay_epoch_time(gchar *buf, int buflen, const time_t sec, gint32 frac,\r\nconst to_str_time_res_t units)\r\n{\r\ndouble elapsed_secs;\r\nelapsed_secs = difftime(sec,(time_t)0);\r\nif (frac < 0) {\r\nfrac = -frac;\r\nif (elapsed_secs >= 0) {\r\nif (buflen < 1) {\r\nreturn;\r\n}\r\nbuf[0] = '-';\r\nbuf++;\r\nbuflen--;\r\n}\r\n}\r\nswitch (units) {\r\ncase TO_STR_TIME_RES_T_SECS:\r\ng_snprintf(buf, buflen, "%0.0f", elapsed_secs);\r\nbreak;\r\ncase TO_STR_TIME_RES_T_DSECS:\r\ng_snprintf(buf, buflen, "%0.0f.%01d", elapsed_secs, frac);\r\nbreak;\r\ncase TO_STR_TIME_RES_T_CSECS:\r\ng_snprintf(buf, buflen, "%0.0f.%02d", elapsed_secs, frac);\r\nbreak;\r\ncase TO_STR_TIME_RES_T_MSECS:\r\ng_snprintf(buf, buflen, "%0.0f.%03d", elapsed_secs, frac);\r\nbreak;\r\ncase TO_STR_TIME_RES_T_USECS:\r\ng_snprintf(buf, buflen, "%0.0f.%06d", elapsed_secs, frac);\r\nbreak;\r\ncase TO_STR_TIME_RES_T_NSECS:\r\ng_snprintf(buf, buflen, "%0.0f.%09d", elapsed_secs, frac);\r\nbreak;\r\n}\r\n}\r\nvoid\r\ndisplay_signed_time(gchar *buf, int buflen, const gint32 sec, gint32 frac,\r\nconst to_str_time_res_t units)\r\n{\r\ngint8 num_buf[16];\r\ngint8 *num_end = &num_buf[16];\r\ngint8 *num_ptr;\r\nint num_len;\r\nif (buflen < 1)\r\nreturn;\r\nif (frac < 0) {\r\nfrac = -frac;\r\nif (sec >= 0) {\r\nbuf[0] = '-';\r\nbuf++;\r\nbuflen--;\r\n}\r\n}\r\nnum_ptr = int_to_str_back(num_end, sec);\r\nnum_len = MIN((int) (num_end - num_ptr), buflen);\r\nmemcpy(buf, num_ptr, num_len);\r\nbuf += num_len;\r\nbuflen -= num_len;\r\nswitch (units) {\r\ncase TO_STR_TIME_RES_T_SECS:\r\ndefault:\r\nnum_ptr = NULL;\r\nbreak;\r\ncase TO_STR_TIME_RES_T_DSECS:\r\nnum_ptr = uint_to_str_back_len(num_end, frac, 1);\r\nbreak;\r\ncase TO_STR_TIME_RES_T_CSECS:\r\nnum_ptr = uint_to_str_back_len(num_end, frac, 2);\r\nbreak;\r\ncase TO_STR_TIME_RES_T_MSECS:\r\nnum_ptr = uint_to_str_back_len(num_end, frac, 3);\r\nbreak;\r\ncase TO_STR_TIME_RES_T_USECS:\r\nnum_ptr = uint_to_str_back_len(num_end, frac, 6);\r\nbreak;\r\ncase TO_STR_TIME_RES_T_NSECS:\r\nnum_ptr = uint_to_str_back_len(num_end, frac, 9);\r\nbreak;\r\n}\r\nif (num_ptr != NULL)\r\n{\r\n*(--num_ptr) = '.';\r\nnum_len = MIN((int) (num_end - num_ptr), buflen);\r\nmemcpy(buf, num_ptr, num_len);\r\nbuf += num_len;\r\nbuflen -= num_len;\r\n}\r\nif (buflen == 0)\r\nbuf--;\r\n*buf = '\0';\r\n}\r\nstatic void\r\nunsigned_time_secs_to_str_buf(guint32 time_val, const guint32 frac,\r\nconst gboolean is_nsecs, wmem_strbuf_t *buf)\r\n{\r\nint hours, mins, secs;\r\ngboolean do_comma = FALSE;\r\nsecs = time_val % 60;\r\ntime_val /= 60;\r\nmins = time_val % 60;\r\ntime_val /= 60;\r\nhours = time_val % 24;\r\ntime_val /= 24;\r\nif (time_val != 0) {\r\nwmem_strbuf_append_printf(buf, "%u day%s", time_val, PLURALIZE(time_val));\r\ndo_comma = TRUE;\r\n}\r\nif (hours != 0) {\r\nwmem_strbuf_append_printf(buf, "%s%u hour%s", COMMA(do_comma), hours, PLURALIZE(hours));\r\ndo_comma = TRUE;\r\n}\r\nif (mins != 0) {\r\nwmem_strbuf_append_printf(buf, "%s%u minute%s", COMMA(do_comma), mins, PLURALIZE(mins));\r\ndo_comma = TRUE;\r\n}\r\nif (secs != 0 || frac != 0) {\r\nif (frac != 0) {\r\nif (is_nsecs)\r\nwmem_strbuf_append_printf(buf, "%s%u.%09u seconds", COMMA(do_comma), secs, frac);\r\nelse\r\nwmem_strbuf_append_printf(buf, "%s%u.%03u seconds", COMMA(do_comma), secs, frac);\r\n} else\r\nwmem_strbuf_append_printf(buf, "%s%u second%s", COMMA(do_comma), secs, PLURALIZE(secs));\r\n}\r\n}\r\ngchar *\r\nunsigned_time_secs_to_str(wmem_allocator_t *scope, const guint32 time_val)\r\n{\r\nwmem_strbuf_t *buf;\r\nif (time_val == 0) {\r\nreturn wmem_strdup(scope, "0 seconds");\r\n}\r\nbuf = wmem_strbuf_sized_new(scope, TIME_SECS_LEN+1, TIME_SECS_LEN+1);\r\nunsigned_time_secs_to_str_buf(time_val, 0, FALSE, buf);\r\nreturn wmem_strbuf_finalize(buf);\r\n}\r\nstatic void\r\nsigned_time_secs_to_str_buf(gint32 time_val, const guint32 frac,\r\nconst gboolean is_nsecs, wmem_strbuf_t *buf)\r\n{\r\nif(time_val < 0){\r\nwmem_strbuf_append_printf(buf, "-");\r\nif(time_val == G_MININT32) {\r\nunsigned_time_secs_to_str_buf(G_MAXUINT32, frac,\r\nis_nsecs, buf);\r\n} else {\r\nunsigned_time_secs_to_str_buf(-time_val, frac,\r\nis_nsecs, buf);\r\n}\r\n} else\r\nunsigned_time_secs_to_str_buf(time_val, frac, is_nsecs, buf);\r\n}\r\ngchar *\r\nsigned_time_secs_to_str(wmem_allocator_t *scope, const gint32 time_val)\r\n{\r\nwmem_strbuf_t *buf;\r\nif (time_val == 0) {\r\nreturn wmem_strdup(scope, "0 seconds");\r\n}\r\nbuf = wmem_strbuf_sized_new(scope, TIME_SECS_LEN+1, TIME_SECS_LEN+1);\r\nsigned_time_secs_to_str_buf(time_val, 0, FALSE, buf);\r\nreturn wmem_strbuf_finalize(buf);\r\n}\r\ngchar *\r\nsigned_time_msecs_to_str(wmem_allocator_t *scope, gint32 time_val)\r\n{\r\nwmem_strbuf_t *buf;\r\nint msecs;\r\nif (time_val == 0) {\r\nreturn wmem_strdup(scope, "0 seconds");\r\n}\r\nbuf = wmem_strbuf_sized_new(scope, TIME_SECS_LEN+1+3+1, TIME_SECS_LEN+1+3+1);\r\nif (time_val<0) {\r\ntime_val= -time_val;\r\nmsecs = time_val % 1000;\r\ntime_val /= 1000;\r\ntime_val= -time_val;\r\n} else {\r\nmsecs = time_val % 1000;\r\ntime_val /= 1000;\r\n}\r\nsigned_time_secs_to_str_buf(time_val, msecs, FALSE, buf);\r\nreturn wmem_strbuf_finalize(buf);\r\n}\r\ngchar *\r\nrel_time_to_str(wmem_allocator_t *scope, const nstime_t *rel_time)\r\n{\r\nwmem_strbuf_t *buf;\r\ngint32 time_val;\r\ngint32 nsec;\r\ntime_val = (gint) rel_time->secs;\r\nnsec = rel_time->nsecs;\r\nif (time_val == 0 && nsec == 0) {\r\nreturn wmem_strdup(scope, "0.000000000 seconds");\r\n}\r\nbuf = wmem_strbuf_sized_new(scope, 1+TIME_SECS_LEN+1+6+1, 1+TIME_SECS_LEN+1+6+1);\r\nif (nsec < 0) {\r\nnsec = -nsec;\r\nwmem_strbuf_append_c(buf, '-');\r\ntime_val = (gint) -rel_time->secs;\r\n}\r\nsigned_time_secs_to_str_buf(time_val, nsec, TRUE, buf);\r\nreturn wmem_strbuf_finalize(buf);\r\n}\r\ngchar *\r\nrel_time_to_secs_str(wmem_allocator_t *scope, const nstime_t *rel_time)\r\n{\r\ngchar *buf;\r\nbuf=(gchar *)wmem_alloc(scope, REL_TIME_SECS_LEN);\r\ndisplay_signed_time(buf, REL_TIME_SECS_LEN, (gint32) rel_time->secs,\r\nrel_time->nsecs, TO_STR_TIME_RES_T_NSECS);\r\nreturn buf;\r\n}\r\nchar *\r\ndecode_bits_in_field(const guint bit_offset, const gint no_of_bits, const guint64 value)\r\n{\r\nguint64 mask = 0,tmp;\r\nchar *str;\r\nint bit, str_p = 0;\r\nint i;\r\nmask = 1;\r\nmask = mask << (no_of_bits-1);\r\nstr=(char *)wmem_alloc0(wmem_packet_scope(), 256+64);\r\nfor(bit=0;bit<((int)(bit_offset&0x07));bit++){\r\nif(bit&&(!(bit%4))){\r\nstr[str_p] = ' ';\r\nstr_p++;\r\n}\r\nstr[str_p] = '.';\r\nstr_p++;\r\n}\r\nfor(i=0;i<no_of_bits;i++){\r\nif(bit&&(!(bit%4))){\r\nstr[str_p] = ' ';\r\nstr_p++;\r\n}\r\nif(bit&&(!(bit%8))){\r\nstr[str_p] = ' ';\r\nstr_p++;\r\n}\r\nbit++;\r\ntmp = value & mask;\r\nif(tmp != 0){\r\nstr[str_p] = '1';\r\nstr_p++;\r\n} else {\r\nstr[str_p] = '0';\r\nstr_p++;\r\n}\r\nmask = mask>>1;\r\n}\r\nfor(;bit%8;bit++){\r\nif(bit&&(!(bit%4))){\r\nstr[str_p] = ' ';\r\nstr_p++;\r\n}\r\nstr[str_p] = '.';\r\nstr_p++;\r\n}\r\nreturn str;\r\n}\r\nvoid\r\nip_to_str_buf(const guint8 *ad, gchar *buf, const int buf_len)\r\n{\r\nregister gchar const *p;\r\nregister gchar *b=buf;\r\nif (buf_len < MAX_IP_STR_LEN) {\r\ng_strlcpy(buf, BUF_TOO_SMALL_ERR, buf_len);\r\nreturn;\r\n}\r\np=fast_strings[*ad++];\r\ndo {\r\n*b++=*p;\r\np++;\r\n} while(*p);\r\n*b++='.';\r\np=fast_strings[*ad++];\r\ndo {\r\n*b++=*p;\r\np++;\r\n} while(*p);\r\n*b++='.';\r\np=fast_strings[*ad++];\r\ndo {\r\n*b++=*p;\r\np++;\r\n} while(*p);\r\n*b++='.';\r\np=fast_strings[*ad];\r\ndo {\r\n*b++=*p;\r\np++;\r\n} while(*p);\r\n*b=0;\r\n}\r\nvoid\r\nip6_to_str_buf(const struct e_in6_addr *ad, gchar *buf, int buf_len)\r\n{\r\nif (buf_len < WS_INET6_ADDRSTRLEN) {\r\ng_strlcpy(buf, BUF_TOO_SMALL_ERR, buf_len);\r\nreturn;\r\n}\r\nws_inet_ntop6(ad, buf, buf_len);\r\n}\r\ngchar *\r\nguid_to_str(wmem_allocator_t *scope, const e_guid_t *guid)\r\n{\r\ngchar *buf;\r\nbuf=(gchar *)wmem_alloc(scope, GUID_STR_LEN);\r\nreturn guid_to_str_buf(guid, buf, GUID_STR_LEN);\r\n}\r\ngchar *\r\nguid_to_str_buf(const e_guid_t *guid, gchar *buf, int buf_len)\r\n{\r\nchar *tempptr = buf;\r\nif (buf_len < GUID_STR_LEN) {\r\ng_strlcpy(buf, BUF_TOO_SMALL_ERR, buf_len);\r\nreturn buf;\r\n}\r\ntempptr = dword_to_hex(tempptr, guid->data1);\r\n*tempptr++ = '-';\r\ntempptr = word_to_hex(tempptr, guid->data2);\r\n*tempptr++ = '-';\r\ntempptr = word_to_hex(tempptr, guid->data3);\r\n*tempptr++ = '-';\r\ntempptr = bytes_to_hexstr(tempptr, &guid->data4[0], 2);\r\n*tempptr++ = '-';\r\ntempptr = bytes_to_hexstr(tempptr, &guid->data4[2], 6);\r\n*tempptr = '\0';\r\nreturn buf;\r\n}\r\ngchar *\r\neui64_to_str(wmem_allocator_t *scope, const guint64 ad) {\r\ngchar *buf, *tmp;\r\nguint8 *p_eui64;\r\np_eui64=(guint8 *)wmem_alloc(NULL, 8);\r\nbuf=(gchar *)wmem_alloc(scope, EUI64_STR_LEN);\r\n*(guint64 *)(void *)(p_eui64) = pntoh64(&(ad));\r\ntmp = bytes_to_hexstr_punct(buf, p_eui64, 8, ':');\r\n*tmp = '\0';\r\nwmem_free(NULL, p_eui64);\r\nreturn buf;\r\n}\r\nconst gchar *\r\nport_type_to_str (port_type type)\r\n{\r\nswitch (type) {\r\ncase PT_NONE: return "NONE";\r\ncase PT_SCTP: return "SCTP";\r\ncase PT_TCP: return "TCP";\r\ncase PT_UDP: return "UDP";\r\ncase PT_DCCP: return "DCCP";\r\ncase PT_IPX: return "IPX";\r\ncase PT_NCP: return "NCP";\r\ncase PT_EXCHG: return "FC EXCHG";\r\ncase PT_DDP: return "DDP";\r\ncase PT_SBCCS: return "FICON SBCCS";\r\ncase PT_IDP: return "IDP";\r\ncase PT_TIPC: return "TIPC";\r\ncase PT_USB: return "USB";\r\ncase PT_I2C: return "I2C";\r\ncase PT_IBQP: return "IBQP";\r\ncase PT_BLUETOOTH: return "BLUETOOTH";\r\ncase PT_TDMOP: return "TDMOP";\r\ndefault: return "[Unknown]";\r\n}\r\n}\r\nchar *\r\noct_to_str_back(char *ptr, guint32 value)\r\n{\r\nwhile (value) {\r\n*(--ptr) = '0' + (value & 0x7);\r\nvalue >>= 3;\r\n}\r\n*(--ptr) = '0';\r\nreturn ptr;\r\n}\r\nchar *\r\noct64_to_str_back(char *ptr, guint64 value)\r\n{\r\nwhile (value) {\r\n*(--ptr) = '0' + (value & 0x7);\r\nvalue >>= 3;\r\n}\r\n*(--ptr) = '0';\r\nreturn ptr;\r\n}\r\nchar *\r\nhex_to_str_back(char *ptr, int len, guint32 value)\r\n{\r\ndo {\r\n*(--ptr) = low_nibble_of_octet_to_hex(value);\r\nvalue >>= 4;\r\nlen--;\r\n} while (value);\r\nwhile (len > 0) {\r\n*(--ptr) = '0';\r\nlen--;\r\n}\r\n*(--ptr) = 'x';\r\n*(--ptr) = '0';\r\nreturn ptr;\r\n}\r\nchar *\r\nhex64_to_str_back(char *ptr, int len, guint64 value)\r\n{\r\ndo {\r\n*(--ptr) = low_nibble_of_octet_to_hex(value & 0xF);\r\nvalue >>= 4;\r\nlen--;\r\n} while (value);\r\nwhile (len > 0) {\r\n*(--ptr) = '0';\r\nlen--;\r\n}\r\n*(--ptr) = 'x';\r\n*(--ptr) = '0';\r\nreturn ptr;\r\n}\r\nchar *\r\nuint_to_str_back(char *ptr, guint32 value)\r\n{\r\nchar const *p;\r\nif (value == 0)\r\n*(--ptr) = '0';\r\nwhile (value >= 10) {\r\np = fast_strings[100 + (value % 100)];\r\nvalue /= 100;\r\n*(--ptr) = p[2];\r\n*(--ptr) = p[1];\r\n}\r\nif (value)\r\n*(--ptr) = (value) | '0';\r\nreturn ptr;\r\n}\r\nchar *\r\nuint64_to_str_back(char *ptr, guint64 value)\r\n{\r\nchar const *p;\r\nif (value == 0)\r\n*(--ptr) = '0';\r\nwhile (value >= 10) {\r\np = fast_strings[100 + (value % 100)];\r\nvalue /= 100;\r\n*(--ptr) = p[2];\r\n*(--ptr) = p[1];\r\n}\r\nif (value)\r\n*(--ptr) = (value & 0xF) | '0';\r\nreturn ptr;\r\n}\r\nchar *\r\nuint_to_str_back_len(char *ptr, guint32 value, int len)\r\n{\r\nchar *new_ptr;\r\nnew_ptr = uint_to_str_back(ptr, value);\r\nlen -= (int)(ptr - new_ptr);\r\nwhile (len > 0)\r\n{\r\n*(--new_ptr) = '0';\r\nlen--;\r\n}\r\nreturn new_ptr;\r\n}\r\nchar *\r\nuint64_to_str_back_len(char *ptr, guint64 value, int len)\r\n{\r\nchar *new_ptr;\r\nnew_ptr = uint64_to_str_back(ptr, value);\r\nlen -= (int)(ptr - new_ptr);\r\nwhile (len > 0)\r\n{\r\n*(--new_ptr) = '0';\r\nlen--;\r\n}\r\nreturn new_ptr;\r\n}\r\nchar *\r\nint_to_str_back(char *ptr, gint32 value)\r\n{\r\nif (value < 0) {\r\nptr = uint_to_str_back(ptr, -value);\r\n*(--ptr) = '-';\r\n} else\r\nptr = uint_to_str_back(ptr, value);\r\nreturn ptr;\r\n}\r\nchar *\r\nint64_to_str_back(char *ptr, gint64 value)\r\n{\r\nif (value < 0) {\r\nptr = uint64_to_str_back(ptr, -value);\r\n*(--ptr) = '-';\r\n} else\r\nptr = uint64_to_str_back(ptr, value);\r\nreturn ptr;\r\n}
