static gboolean\r\ncapture_netbios(const guchar *pd _U_, int offset _U_, int len _U_, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\r\n{\r\ncapture_dissector_increment_count(cpinfo, proto_netbios);\r\nreturn TRUE;\r\n}\r\nint\r\nprocess_netbios_name(const guchar *name_ptr, char *name_ret, int name_ret_len)\r\n{\r\nint i;\r\nint name_type = *(name_ptr + NETBIOS_NAME_LEN - 1);\r\nguchar name_char;\r\nstatic const char hex_digits[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\r\nfor (i = 0; i < NETBIOS_NAME_LEN - 1; i++) {\r\nname_char = *name_ptr++;\r\nif (name_char >= ' ' && name_char <= '~') {\r\nif (--name_ret_len > 0)\r\n*name_ret++ = name_char;\r\n} else {\r\nif (--name_ret_len > 0)\r\n*name_ret++ = '<';\r\nif (--name_ret_len > 0)\r\n*name_ret++ = hex_digits[(name_char >> 4)];\r\nif (--name_ret_len > 0)\r\n*name_ret++ = hex_digits[(name_char & 0x0F)];\r\nif (--name_ret_len > 0)\r\n*name_ret++ = '>';\r\n}\r\n}\r\n*name_ret = '\0';\r\nname_ret--;\r\nfor (i = 0; i < NETBIOS_NAME_LEN - 1; i++) {\r\nif (*name_ret != ' ') {\r\n*(name_ret + 1) = 0;\r\nbreak;\r\n}\r\nname_ret--;\r\n}\r\nreturn name_type;\r\n}\r\nint\r\nget_netbios_name( tvbuff_t *tvb, int offset, char *name_ret, int name_ret_len)\r\n{\r\nreturn process_netbios_name( tvb_get_ptr( tvb, offset, NETBIOS_NAME_LEN ), name_ret, name_ret_len);\r\n}\r\nconst char *\r\nnetbios_name_type_descr(int name_type)\r\n{\r\nreturn val_to_str_ext_const(name_type, &nb_name_type_vals_ext, "Unknown");\r\n}\r\nvoid\r\nnetbios_add_name(const char* label, tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree *field_tree;\r\nchar name_str[(NETBIOS_NAME_LEN - 1)*4 + 1];\r\nint name_type;\r\nconst char *name_type_str;\r\nname_type = get_netbios_name( tvb, offset, name_str, (NETBIOS_NAME_LEN - 1)*4 + 1);\r\nname_type_str = netbios_name_type_descr(name_type);\r\nfield_tree = proto_tree_add_subtree_format( tree, tvb, offset, NETBIOS_NAME_LEN,\r\nett_netb_name, NULL, "%s: %s<%02x> (%s)", label, name_str, name_type, name_type_str);\r\nproto_tree_add_string_format( field_tree, hf_netb_nb_name, tvb, offset,\r\n15, name_str, "%s", name_str);\r\nproto_tree_add_uint_format( field_tree, hf_netb_nb_name_type, tvb, offset + 15, 1, name_type,\r\n"0x%02x (%s)", name_type, name_type_str);\r\n}\r\nstatic void\r\nnetbios_data_first_middle_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\nproto_tree *field_tree;\r\nproto_item *tf;\r\ntf = proto_tree_add_item(tree, hf_netb_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nfield_tree = proto_item_add_subtree(tf, ett_netb_flags);\r\nproto_tree_add_item( field_tree, hf_netb_flags_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item( field_tree, hf_netb_flags_ack_expected, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item( field_tree, hf_netb_flags_recv_cont_req, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nnetbios_data_only_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\nproto_tree *field_tree;\r\nproto_item *tf;\r\ntf = proto_tree_add_item(tree, hf_netb_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nfield_tree = proto_item_add_subtree(tf, ett_netb_flags);\r\nproto_tree_add_item( field_tree, hf_netb_flags_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item( field_tree, hf_netb_flags_ack_with_data, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item( field_tree, hf_netb_flags_ack_expected, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nnetbios_add_ses_confirm_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\nproto_tree *field_tree;\r\nproto_item *tf;\r\ntf = proto_tree_add_item(tree, hf_netb_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nfield_tree = proto_item_add_subtree( tf, ett_netb_flags);\r\nproto_tree_add_item( field_tree, hf_netb_flags_send_no_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item( field_tree, hf_netb_version, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nnetbios_add_session_init_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\nproto_tree *field_tree;\r\nproto_item *tf;\r\ntf = proto_tree_add_item(tree, hf_netb_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nfield_tree = proto_item_add_subtree(tf, ett_netb_flags);\r\nproto_tree_add_item( field_tree, hf_netb_flags_send_no_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item( field_tree, hf_netb_largest_frame, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item( field_tree, hf_netb_version, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nnetbios_no_receive_flags( tvbuff_t *tvb, proto_tree *tree, int offset)\r\n{\r\nproto_tree *field_tree;\r\nproto_item *tf;\r\ntf = proto_tree_add_item(tree, hf_netbios_no_receive_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nfield_tree = proto_item_add_subtree(tf, ett_netb_flags);\r\nproto_tree_add_item(field_tree, hf_netbios_no_receive_flags_send_no_ack, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nnb_xmit_corrl( tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item( tree, hf_netb_xmit_corrl, tvb, offset + NB_XMIT_CORL,\r\n2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nnb_resp_corrl( tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item( tree, hf_netb_resp_corrl, tvb, offset + NB_RESP_CORL,\r\n2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nnb_call_name_type( tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item( tree, hf_netb_call_name_type, tvb, offset + NB_CALL_NAME_TYPE,\r\n1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic guint8\r\nnb_local_session( tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nguint8 local_session = tvb_get_guint8( tvb, offset + NB_LOCAL_SES);\r\nproto_tree_add_uint( tree, hf_netb_local_ses_no, tvb, offset + NB_LOCAL_SES, 1,\r\nlocal_session);\r\nreturn local_session;\r\n}\r\nstatic guint8\r\nnb_remote_session( tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nguint8 remote_session = tvb_get_guint8( tvb, offset + NB_RMT_SES);\r\nproto_tree_add_uint( tree, hf_netb_remote_ses_no, tvb, offset + NB_RMT_SES, 1,\r\nremote_session);\r\nreturn remote_session;\r\n}\r\nstatic void\r\nnb_data1(int hf, tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item( tree, hf, tvb, offset + NB_DATA1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nnb_data2(int hf, tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_item( tree, hf, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\nnb_resync_indicator( tvbuff_t *tvb, int offset, proto_tree *tree, const char *cmd_str)\r\n{\r\nguint16 resync_indicator = tvb_get_letohs( tvb, offset + NB_DATA2);\r\nswitch (resync_indicator) {\r\ncase 0x0000:\r\nproto_tree_add_uint_format_value(tree, hf_netb_resync_indicator, tvb, offset + NB_DATA2, 2,\r\nresync_indicator, "No re-sync");\r\nbreak;\r\ncase 0x0001:\r\nproto_tree_add_uint_format_value(tree, hf_netb_resync_indicator, tvb, offset + NB_DATA2, 2,\r\nresync_indicator, "First '%s' following 'Receive Outstanding'", cmd_str);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_netb_resync_indicator, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\r\nbreak;\r\n}\r\n}\r\nstatic guint32\r\ndissect_netb_unknown( tvbuff_t *tvb, packet_info *pinfo, int offset, proto_tree *tree)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_netb_unknown_command_data, tvb, offset + NB_COMMAND + 1, -1);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_add_group_name( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnb_resp_corrl( tvb, offset, tree);\r\nnetbios_add_name("Group name to add", tvb, offset + NB_SENDER_NAME,\r\ntree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_add_name( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnb_resp_corrl( tvb, offset, tree);\r\nnetbios_add_name("Name to add", tvb, offset + NB_SENDER_NAME, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_name_in_conflict( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnetbios_add_name("Name In Conflict", tvb, offset + NB_RECVER_NAME,\r\ntree);\r\nnetbios_add_name("Sender's Name", tvb, offset + NB_SENDER_NAME, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_status_query( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nguint8 status_request = tvb_get_guint8( tvb, offset + NB_DATA1);\r\nswitch (status_request) {\r\ncase 0:\r\nproto_tree_add_uint_format_value(tree, hf_netb_status_request, tvb, offset + NB_DATA1, 1,\r\nstatus_request, "NetBIOS 1.x or 2.0");\r\nbreak;\r\ncase 1:\r\nproto_tree_add_uint_format_value(tree, hf_netb_status_request, tvb, offset + NB_DATA1, 1,\r\nstatus_request, "NetBIOS 2.1, initial status request");\r\nbreak;\r\ndefault:\r\nproto_tree_add_uint_format_value(tree, hf_netb_status_request, tvb, offset + NB_DATA1, 1,\r\nstatus_request, "NetBIOS 2.1, %u names received so far",\r\nstatus_request);\r\nbreak;\r\n}\r\nnb_data2( hf_netb_status_buffer_len, tvb, offset, tree);\r\nnb_resp_corrl( tvb, offset, tree);\r\nnetbios_add_name("Receiver's Name", tvb, offset + NB_RECVER_NAME, tree);\r\nnetbios_add_name("Sender's Name", tvb, offset + NB_SENDER_NAME, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_terminate_trace( tvbuff_t *tvb _U_, packet_info *pinfo _U_, int offset _U_, proto_tree *tree _U_)\r\n{\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_datagram( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnetbios_add_name("Receiver's Name", tvb, offset + NB_RECVER_NAME, tree);\r\nif (tvb_memeql(tvb, offset + NB_SENDER_NAME, zeroes, 10) == 0) {\r\nproto_tree_add_item(tree, hf_netb_datagram_mac,\r\ntvb, offset + NB_SENDER_NAME + 10, 6, ENC_NA );\r\n} else {\r\nnetbios_add_name("Sender's Name", tvb, offset + NB_SENDER_NAME,\r\ntree);\r\n}\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_datagram_bcast( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nif (tvb_memeql(tvb, offset + NB_SENDER_NAME, zeroes, 10) == 0) {\r\nproto_tree_add_item(tree, hf_netb_datagram_bcast_mac,\r\ntvb, offset + NB_SENDER_NAME + 10, 6, ENC_NA );\r\n} else {\r\nnetbios_add_name("Sender's Name", tvb, offset + NB_SENDER_NAME,\r\ntree);\r\n}\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_name_query( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nguint8 local_session_number = tvb_get_guint8( tvb, offset + NB_DATA2);\r\nif (local_session_number == 0) {\r\nproto_tree_add_uint_format_value( tree, hf_netb_local_session_no, tvb, offset + NB_DATA2, 1,\r\nlocal_session_number, "0 (FIND.NAME request)");\r\n} else {\r\nproto_tree_add_item( tree, hf_netb_local_session_no, tvb, offset + NB_DATA2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nnb_call_name_type( tvb, offset, tree);\r\nnb_resp_corrl( tvb, offset, tree);\r\nnetbios_add_name("Query Name", tvb, offset + NB_RECVER_NAME, tree);\r\nif (local_session_number != 0) {\r\nnetbios_add_name("Sender's Name", tvb, offset + NB_SENDER_NAME,\r\ntree);\r\n}\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_add_name_resp( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnb_data1( hf_netb_status, tvb, offset, tree);\r\nnb_data2( hf_netb_name_type, tvb, offset, tree);\r\nnb_xmit_corrl( tvb, offset, tree);\r\nnetbios_add_name("Name to be added", tvb, offset + NB_RECVER_NAME,\r\ntree);\r\nnetbios_add_name("Name to be added", tvb, offset + NB_SENDER_NAME,\r\ntree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_name_resp( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nguint8 local_session_number = tvb_get_guint8( tvb, offset + NB_DATA2);\r\nswitch (local_session_number) {\r\ncase 0x00:\r\nproto_tree_add_uint_format_value( tree, hf_netb_state_of_name, tvb, offset + NB_DATA2, 1,\r\nlocal_session_number, "No LISTEN pending, or FIND.NAME response");\r\nbreak;\r\ncase 0xFF:\r\nproto_tree_add_uint_format_value( tree, hf_netb_state_of_name, tvb, offset + NB_DATA2, 1,\r\nlocal_session_number, "LISTEN pending, but insufficient resources to establish session");\r\nbreak;\r\ndefault:\r\nproto_tree_add_item( tree, hf_netb_local_session_no, tvb, offset + NB_DATA2, 1, ENC_LITTLE_ENDIAN);\r\nbreak;\r\n}\r\nnb_call_name_type( tvb, offset, tree);\r\nnb_xmit_corrl( tvb, offset, tree);\r\nif (local_session_number != 0x00 && local_session_number != 0xFF)\r\nnb_resp_corrl(tvb, offset, tree);\r\nnetbios_add_name("Receiver's Name", tvb, offset + NB_RECVER_NAME, tree);\r\nif (local_session_number != 0x00 && local_session_number != 0xFF) {\r\nnetbios_add_name("Sender's Name", tvb, offset + NB_SENDER_NAME,\r\ntree);\r\n}\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_status_resp( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nguint8 status_response = tvb_get_guint8( tvb, offset + NB_DATA1);\r\nproto_item *td2;\r\nproto_tree *data2_tree;\r\nnb_call_name_type( tvb, offset, tree);\r\nif (status_response == 0) {\r\nproto_tree_add_uint_format_value(tree, hf_netb_status_response, tvb, offset + NB_DATA1, 1,\r\nstatus_response, "NetBIOS 1.x or 2.0");\r\n} else {\r\nproto_tree_add_uint_format_value(tree, hf_netb_status_response, tvb, offset + NB_DATA1, 1,\r\nstatus_response, "NetBIOS 2.1, %u names sent so far",\r\nstatus_response);\r\n}\r\ntd2 = proto_tree_add_item(tree, hf_netb_data2, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\r\ndata2_tree = proto_item_add_subtree(td2, ett_netb_status);\r\nproto_tree_add_item(data2_tree, hf_netb_data2_frame, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(data2_tree, hf_netb_data2_user, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(data2_tree, hf_netb_data2_status, tvb, offset + NB_DATA2, 2, ENC_LITTLE_ENDIAN);\r\nnb_xmit_corrl( tvb, offset, tree);\r\nnetbios_add_name("Receiver's Name", tvb, offset + NB_RECVER_NAME, tree);\r\nnetbios_add_name("Sender's Name", tvb, offset + NB_SENDER_NAME,\r\ntree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_data_ack( tvbuff_t* tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnb_xmit_corrl( tvb, offset, tree);\r\nnb_remote_session( tvb, offset, tree);\r\nnb_local_session( tvb, offset, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_data_first_middle( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nguint8 remote_session, local_session;\r\nnetbios_data_first_middle_flags( tvb, tree, offset + NB_FLAGS);\r\nnb_resync_indicator( tvb, offset, tree, "DATA FIRST MIDDLE");\r\nnb_xmit_corrl( tvb, offset, tree);\r\nnb_resp_corrl( tvb, offset, tree);\r\nremote_session = nb_remote_session( tvb, offset, tree);\r\nlocal_session = nb_local_session( tvb, offset, tree);\r\nreturn (remote_session << 8) + local_session;\r\n}\r\nstatic guint32\r\ndissect_netb_data_only_last( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nguint8 remote_session, local_session;\r\nnetbios_data_only_flags( tvb, tree, offset + NB_FLAGS);\r\nnb_resync_indicator( tvb, offset, tree, "DATA ONLY LAST");\r\nnb_xmit_corrl( tvb, offset, tree);\r\nnb_resp_corrl( tvb, offset, tree);\r\nremote_session = nb_remote_session( tvb, offset, tree);\r\nlocal_session = nb_local_session( tvb, offset, tree);\r\nreturn (remote_session << 8) + local_session;\r\n}\r\nstatic guint32\r\ndissect_netb_session_confirm( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnetbios_add_ses_confirm_flags( tvb, tree, offset + NB_FLAGS);\r\nnb_data2( hf_netb_max_data_recv_size, tvb, offset, tree);\r\nnb_xmit_corrl( tvb, offset, tree);\r\nnb_resp_corrl( tvb, offset, tree);\r\nnb_remote_session( tvb, offset, tree);\r\nnb_local_session( tvb, offset, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_session_end( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnb_data2( hf_netb_termination_indicator, tvb, offset, tree);\r\nnb_remote_session( tvb, offset, tree);\r\nnb_local_session( tvb, offset, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_session_init( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnetbios_add_session_init_flags( tvb, tree, offset + NB_FLAGS);\r\nnb_data2( hf_netb_max_data_recv_size, tvb, offset, tree);\r\nnb_resp_corrl( tvb, offset, tree);\r\nnb_xmit_corrl( tvb, offset, tree);\r\nnb_remote_session( tvb, offset, tree);\r\nnb_local_session( tvb, offset, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_no_receive( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnetbios_no_receive_flags( tvb, tree, offset + NB_FLAGS);\r\nnb_data2( hf_netb_num_data_bytes_accepted, tvb, offset, tree);\r\nnb_remote_session( tvb, offset, tree);\r\nnb_local_session( tvb, offset, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_receive_outstanding( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnb_data2( hf_netb_num_data_bytes_accepted, tvb, offset, tree);\r\nnb_remote_session( tvb, offset, tree);\r\nnb_local_session( tvb, offset, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_receive_continue( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnb_xmit_corrl( tvb, offset, tree);\r\nnb_remote_session( tvb, offset, tree);\r\nnb_local_session( tvb, offset, tree);\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_netb_session_alive( tvbuff_t *tvb, packet_info *pinfo _U_, int offset, proto_tree *tree)\r\n{\r\nnb_remote_session( tvb, offset, tree);\r\nnb_local_session( tvb, offset, tree);\r\nreturn 0;\r\n}\r\nstatic void\r\ndissect_netbios_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nheur_dtbl_entry_t *hdtbl_entry;\r\nif (!dissector_try_heuristic(netbios_heur_subdissector_list,\r\ntvb, pinfo, tree, &hdtbl_entry, NULL))\r\ncall_data_dissector(tvb, pinfo, tree);\r\n}\r\nstatic int\r\ndissect_netbios(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *netb_tree = NULL;\r\nproto_item *ti;\r\nguint16 hdr_len, command;\r\nconst char *command_name;\r\nchar name[(NETBIOS_NAME_LEN - 1)*4 + 1];\r\nint name_type;\r\nguint16 session_id;\r\ngboolean save_fragmented;\r\nint len;\r\nfragment_head *fd_head;\r\ntvbuff_t *next_tvb;\r\nint offset = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NetBIOS");\r\nif ( 0xefff != tvb_get_letohs(tvb, 2)){\r\n++offset;\r\nif ( 0xefff != tvb_get_letohs(tvb, 3)){\r\ncol_set_str( pinfo->cinfo, COL_INFO, "Bad packet, no 0xEFFF marker");\r\nreturn 3;\r\n}\r\n}\r\nhdr_len = tvb_get_letohs(tvb, offset + NB_LENGTH);\r\ncommand = tvb_get_guint8( tvb, offset + NB_COMMAND);\r\ncommand = MIN( command, sizeof( dissect_netb)/ sizeof(void *));\r\ncommand_name = val_to_str_ext(command, &cmd_vals_ext, "Unknown (0x%02x)");\r\nswitch ( command ) {\r\ncase NB_NAME_QUERY:\r\nname_type = get_netbios_name( tvb, offset + 12, name, (NETBIOS_NAME_LEN - 1)*4 + 1);\r\ncol_add_fstr( pinfo->cinfo, COL_INFO, "%s for %s<%02x>", command_name, name, name_type);\r\nbreak;\r\ncase NB_NAME_RESP:\r\ncase NB_ADD_NAME:\r\ncase NB_ADD_GROUP:\r\nname_type = get_netbios_name( tvb, offset + 28, name, (NETBIOS_NAME_LEN - 1)*4 + 1);\r\ncol_add_fstr( pinfo->cinfo, COL_INFO, "%s - %s<%02x>", command_name, name, name_type);\r\nbreak;\r\ndefault:\r\ncol_add_str( pinfo->cinfo, COL_INFO, command_name);\r\nbreak;\r\n}\r\nif ( tree) {\r\nti = proto_tree_add_item(tree, proto_netbios, tvb, 0, hdr_len, ENC_NA);\r\nnetb_tree = proto_item_add_subtree(ti, ett_netb);\r\nproto_tree_add_uint_format_value(netb_tree, hf_netb_hdr_len, tvb, offset, 2, hdr_len,\r\n"%d bytes", hdr_len);\r\nproto_tree_add_uint_format_value(netb_tree, hf_netb_delimiter, tvb, offset + 2, 2,\r\ntvb_get_letohs(tvb, offset + 2), "EFFF (NetBIOS)");\r\nproto_tree_add_uint(netb_tree, hf_netb_cmd, tvb, offset + NB_COMMAND, 1, command);\r\n}\r\nif ( command < sizeof( dissect_netb)/ sizeof(void *)) {\r\nsession_id = (dissect_netb[ command])( tvb, pinfo, offset, netb_tree);\r\noffset += hdr_len;\r\nsave_fragmented = pinfo->fragmented;\r\nswitch (command) {\r\ncase NB_DATAGRAM:\r\ncase NB_DATAGRAM_BCAST:\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ndissect_netbios_payload(next_tvb, pinfo, tree);\r\nbreak;\r\ncase NB_DATA_FIRST_MIDDLE:\r\ncase NB_DATA_ONLY_LAST:\r\nlen = tvb_reported_length_remaining(tvb, offset);\r\nif (netbios_defragment &&\r\ntvb_bytes_exist(tvb, offset, len)) {\r\nfd_head = fragment_add_seq_next(&netbios_reassembly_table,\r\ntvb, offset,\r\npinfo, session_id, NULL,\r\nlen, command == NB_DATA_FIRST_MIDDLE);\r\nif (fd_head != NULL) {\r\nif (fd_head->next != NULL) {\r\nnext_tvb = tvb_new_chain(tvb, fd_head->tvb_data);\r\nadd_new_data_source(pinfo,\r\nnext_tvb,\r\n"Reassembled NetBIOS");\r\nif (tree) {\r\nproto_item *frag_tree_item;\r\nshow_fragment_seq_tree(fd_head,\r\n&netbios_frag_items,\r\nnetb_tree, pinfo,\r\nnext_tvb, &frag_tree_item);\r\n}\r\n} else {\r\nnext_tvb = tvb_new_subset_remaining(tvb,\r\noffset);\r\n}\r\n} else {\r\nnext_tvb = NULL;\r\n}\r\n} else {\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\n}\r\nif (next_tvb != NULL)\r\ndissect_netbios_payload(next_tvb, pinfo, tree);\r\nelse {\r\nnext_tvb = tvb_new_subset_remaining (tvb, offset);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nbreak;\r\n}\r\npinfo->fragmented = save_fragmented;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\nnetbios_init(void)\r\n{\r\nreassembly_table_init(&netbios_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\nnetbios_cleanup(void)\r\n{\r\nreassembly_table_destroy(&netbios_reassembly_table);\r\n}\r\nvoid\r\nproto_register_netbios(void)\r\n{\r\nstatic gint *ett[] = {\r\n&ett_netb,\r\n&ett_netb_name,\r\n&ett_netb_flags,\r\n&ett_netb_status,\r\n&ett_netb_fragments,\r\n&ett_netb_fragment,\r\n};\r\nstatic hf_register_info hf_netb[] = {\r\n{ &hf_netb_cmd,\r\n{ "Command", "netbios.command", FT_UINT8, BASE_HEX | BASE_EXT_STRING,\r\n&cmd_vals_ext, 0x0, NULL, HFILL }},\r\n{ &hf_netb_hdr_len,\r\n{ "Length", "netbios.hdr_len", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "Header Length", HFILL }},\r\n{ &hf_netb_delimiter,\r\n{ "Delimiter", "netbios.delimiter", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_xmit_corrl,\r\n{ "Transmit Correlator", "netbios.xmit_corrl", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_resp_corrl,\r\n{ "Response Correlator", "netbios.resp_corrl", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_call_name_type,\r\n{ "Caller's Name Type", "netbios.call_name_type", FT_UINT8, BASE_HEX,\r\nVALS(name_types), 0x0, NULL, HFILL }},\r\n{ &hf_netb_nb_name_type,\r\n{ "NetBIOS Name Type", "netbios.nb_name_type", FT_UINT8, BASE_HEX |BASE_EXT_STRING,\r\n&nb_name_type_vals_ext, 0x0, NULL, HFILL }},\r\n{ &hf_netb_nb_name,\r\n{ "NetBIOS Name", "netbios.nb_name", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_version,\r\n{ "NetBIOS Version", "netbios.version", FT_BOOLEAN, 8,\r\nTFS( &netb_version_str), 0x01, NULL, HFILL }},\r\n{ &hf_netbios_no_receive_flags,\r\n{ "Flags", "netbios.no_receive_flags", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_netbios_no_receive_flags_send_no_ack,\r\n{ "SEND.NO.ACK data received", "netbios.no_receive_flags.send_no_ack", FT_BOOLEAN, 8,\r\nTFS( &tfs_no_yes), 0x02, NULL, HFILL }},\r\n{ &hf_netb_largest_frame,\r\n{ "Largest Frame", "netbios.largest_frame", FT_UINT8, BASE_DEC,\r\nVALS(max_frame_size_vals), 0x0E, NULL, HFILL }},\r\n{ &hf_netb_status_buffer_len,\r\n{ "Length of status buffer", "netbios.status_buffer_len", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_status,\r\n{ "Status", "netbios.status", FT_UINT8, BASE_DEC,\r\nVALS(status_vals), 0x0, NULL, HFILL }},\r\n{ &hf_netb_name_type,\r\n{ "Name type", "netbios.name_type", FT_UINT16, BASE_DEC,\r\nVALS(name_types), 0x0, NULL, HFILL }},\r\n{ &hf_netb_max_data_recv_size,\r\n{ "Maximum data receive size", "netbios.max_data_recv_size", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_termination_indicator,\r\n{ "Termination indicator", "netbios.termination_indicator", FT_UINT16, BASE_HEX,\r\nVALS(termination_indicator_vals), 0x0, NULL, HFILL }},\r\n{ &hf_netb_num_data_bytes_accepted,\r\n{ "Number of data bytes accepted", "netbios.num_data_bytes_accepted", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_local_ses_no,\r\n{ "Local Session No.", "netbios.local_session", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_remote_ses_no,\r\n{ "Remote Session No.", "netbios.remote_session", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_flags,\r\n{ "Flags", "netbios.flags", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_flags_send_no_ack,\r\n{ "Handle SEND.NO.ACK", "netbios.flags.send_no_ack", FT_BOOLEAN, 8,\r\nTFS( &tfs_yes_no), 0x80, NULL, HFILL }},\r\n{ &hf_netb_flags_ack,\r\n{ "Acknowledge", "netbios.flags.ack", FT_BOOLEAN, 8,\r\nTFS( &tfs_set_notset), 0x08, NULL, HFILL }},\r\n{ &hf_netb_flags_ack_with_data,\r\n{ "Acknowledge with data", "netbios.flags.ack_with_data", FT_BOOLEAN, 8,\r\nTFS( &flags_allowed), 0x04, NULL, HFILL }},\r\n{ &hf_netb_flags_ack_expected,\r\n{ "Acknowledge expected", "netbios.flags.ack_expected", FT_BOOLEAN, 8,\r\nTFS( &tfs_yes_no), 0x02, NULL, HFILL }},\r\n{ &hf_netb_flags_recv_cont_req,\r\n{ "RECEIVE_CONTINUE requested", "netbios.flags.recv_cont_req", FT_BOOLEAN, 8,\r\nTFS( &tfs_yes_no), 0x01, NULL, HFILL }},\r\n{ &hf_netb_data2,\r\n{ "DATA2 value", "netbios.data2", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_data2_frame,\r\n{ "Data length exceeds maximum frame size", "netbios.data2.frame", FT_BOOLEAN, 16,\r\nTFS(&tfs_yes_no), 0x8000, NULL, HFILL }},\r\n{ &hf_netb_data2_user,\r\n{ "Data length exceeds user's buffer", "netbios.data2.user", FT_BOOLEAN, 16,\r\nTFS(&tfs_yes_no), 0x4000, NULL, HFILL }},\r\n{ &hf_netb_data2_status,\r\n{ "Status data length", "netbios.data2.status", FT_UINT16, BASE_DEC,\r\nNULL, 0x3FFF, NULL, HFILL }},\r\n{ &hf_netb_datagram_mac,\r\n{ "Sender's MAC Address", "netbios.datagram_mac", FT_ETHER, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_datagram_bcast_mac,\r\n{ "Sender's Node Address", "netbios.datagram_bcast_mac", FT_ETHER, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_resync_indicator,\r\n{ "Re-sync indicator", "netbios.resync_indicator", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_status_request,\r\n{ "Status request", "netbios.status_request", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_local_session_no,\r\n{ "Local Session No.", "netbios.local_session_no", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_state_of_name,\r\n{ "State of name", "netbios.state_of_name", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_status_response,\r\n{ "Status response", "netbios.status_response", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_fragment_overlap,\r\n{ "Fragment overlap", "netbios.fragment.overlap", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "Fragment overlaps with other fragments", HFILL }},\r\n{ &hf_netb_fragment_overlap_conflict,\r\n{ "Conflicting data in fragment overlap", "netbios.fragment.overlap.conflict",\r\nFT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "Overlapping fragments contained conflicting data", HFILL }},\r\n{ &hf_netb_fragment_multiple_tails,\r\n{ "Multiple tail fragments found", "netbios.fragment.multipletails",\r\nFT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "Several tails were found when defragmenting the packet", HFILL }},\r\n{ &hf_netb_fragment_too_long_fragment,\r\n{ "Fragment too long", "netbios.fragment.toolongfragment", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "Fragment contained data past end of packet", HFILL }},\r\n{ &hf_netb_fragment_error,\r\n{ "Defragmentation error", "netbios.fragment.error", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "Defragmentation error due to illegal fragments", HFILL }},\r\n{ &hf_netb_fragment_count,\r\n{ "Fragment count", "netbios.fragment.count", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_fragment,\r\n{ "NetBIOS Fragment", "netbios.fragment", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_fragments,\r\n{ "NetBIOS Fragments", "netbios.fragments", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_netb_reassembled_length,\r\n{"Reassembled NetBIOS length", "netbios.reassembled.length", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "The total length of the reassembled payload", HFILL }},\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_netb_unknown_command_data, { "netbios.unknown_command_data", PI_UNDECODED, PI_WARN, "Unknown NetBIOS command data", EXPFILL }},\r\n};\r\nmodule_t *netbios_module;\r\nexpert_module_t* expert_netbios;\r\nproto_netbios = proto_register_protocol("NetBIOS", "NetBIOS", "netbios");\r\nproto_register_subtree_array(ett, array_length(ett));\r\nproto_register_field_array(proto_netbios, hf_netb, array_length(hf_netb));\r\nexpert_netbios = expert_register_protocol(proto_netbios);\r\nexpert_register_field_array(expert_netbios, ei, array_length(ei));\r\nnetbios_heur_subdissector_list = register_heur_dissector_list("netbios", proto_netbios);\r\nnetbios_module = prefs_register_protocol(proto_netbios, NULL);\r\nprefs_register_bool_preference(netbios_module, "defragment",\r\n"Reassemble fragmented NetBIOS messages spanning multiple frames",\r\n"Whether the NetBIOS dissector should defragment messages spanning multiple frames",\r\n&netbios_defragment);\r\nregister_init_routine(netbios_init);\r\nregister_cleanup_routine(netbios_cleanup);\r\n}\r\nvoid\r\nproto_reg_handoff_netbios(void)\r\n{\r\ndissector_handle_t netbios_handle;\r\nnetbios_handle = create_dissector_handle(dissect_netbios,\r\nproto_netbios);\r\ndissector_add_uint("llc.dsap", SAP_NETBIOS, netbios_handle);\r\nregister_capture_dissector("llc.dsap", SAP_NETBIOS, capture_netbios, proto_netbios);\r\n}
