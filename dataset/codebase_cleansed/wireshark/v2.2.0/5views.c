wtap_open_return_val\r\n_5views_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nt_5VW_Capture_Header Capture_Header;\r\nint encap = WTAP_ENCAP_UNKNOWN;\r\nif (!wtap_read_bytes(wth->fh, &Capture_Header.Info_Header,\r\nsizeof(t_5VW_Info_Header), err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif(Capture_Header.Info_Header.Signature != CST_5VW_INFO_HEADER_KEY)\r\n{\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nCapture_Header.Info_Header.Version =\r\npletoh32(&Capture_Header.Info_Header.Version);\r\nswitch (Capture_Header.Info_Header.Version) {\r\ncase CST_5VW_INFO_RECORD_VERSION:\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("5views: header version %u unsupported", Capture_Header.Info_Header.Version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nCapture_Header.Info_Header.FileType =\r\npletoh32(&Capture_Header.Info_Header.FileType);\r\nif((Capture_Header.Info_Header.FileType & CST_5VW_CAPTURE_FILE_TYPE_MASK) != CST_5VW_CAPTURE_FILEID)\r\n{\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("5views: file is not a capture file (filetype is %u)", Capture_Header.Info_Header.Version);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nswitch (Capture_Header.Info_Header.FileType) {\r\ncase CST_5VW_CAPTURE_ETH_FILEID:\r\nencap = WTAP_ENCAP_ETHERNET;\r\nbreak;\r\ndefault:\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("5views: network type %u unknown or unsupported",\r\nCapture_Header.Info_Header.FileType);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &Capture_Header.HeaderDateCreation,\r\nsizeof (t_5VW_Capture_Header) - sizeof(t_5VW_Info_Header), err, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_5VIEWS;\r\nwth->subtype_read = _5views_read;\r\nwth->subtype_seek_read = _5views_seek_read;\r\nwth->file_encap = encap;\r\nwth->snapshot_length = 0;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean\r\n_5views_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\r\n{\r\nt_5VW_TimeStamped_Header TimeStamped_Header;\r\ndo\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nif (!_5views_read_header(wth, wth->fh, &TimeStamped_Header,\r\n&wth->phdr, err, err_info))\r\nreturn FALSE;\r\nif (TimeStamped_Header.RecSubType == CST_5VW_FRAME_RECORD) {\r\nbreak;\r\n}\r\nif (file_seek(wth->fh, TimeStamped_Header.RecSize, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\n} while (1);\r\nif (wth->phdr.caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("5views: File has %u-byte packet, bigger than maximum of %u",\r\nwth->phdr.caplen, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nreturn wtap_read_packet_bytes(wth->fh, wth->frame_buffer,\r\nwth->phdr.caplen, err, err_info);\r\n}\r\nstatic gboolean\r\n_5views_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nt_5VW_TimeStamped_Header TimeStamped_Header;\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!_5views_read_header(wth, wth->random_fh, &TimeStamped_Header,\r\nphdr, err, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn wtap_read_packet_bytes(wth->random_fh, buf, phdr->caplen,\r\nerr, err_info);\r\n}\r\nstatic gboolean\r\n_5views_read_header(wtap *wth, FILE_T fh, t_5VW_TimeStamped_Header *hdr,\r\nstruct wtap_pkthdr *phdr, int *err, gchar **err_info)\r\n{\r\nif (!wtap_read_bytes_or_eof(fh, hdr, (unsigned int)sizeof(t_5VW_TimeStamped_Header),\r\nerr, err_info))\r\nreturn FALSE;\r\nhdr->Key = pletoh32(&hdr->Key);\r\nif (hdr->Key != CST_5VW_RECORDS_HEADER_KEY) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("5views: Time-stamped header has bad key value 0x%08X",\r\nhdr->Key);\r\nreturn FALSE;\r\n}\r\nhdr->RecSubType = pletoh32(&hdr->RecSubType);\r\nhdr->RecSize = pletoh32(&hdr->RecSize);\r\nhdr->Utc = pletoh32(&hdr->Utc);\r\nhdr->NanoSecondes = pletoh32(&hdr->NanoSecondes);\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->ts.secs = hdr->Utc;\r\nphdr->ts.nsecs = hdr->NanoSecondes;\r\nphdr->caplen = hdr->RecSize;\r\nphdr->len = hdr->RecSize;\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\nphdr->pseudo_header.eth.fcs_len = 0;\r\nbreak;\r\n}\r\nreturn TRUE;\r\n}\r\nint _5views_dump_can_write_encap(int encap)\r\n{\r\nif (encap == WTAP_ENCAP_PER_PACKET)\r\nreturn WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;\r\nif (encap < 0 || (unsigned int) encap >= NUM_WTAP_ENCAPS || wtap_encap[encap] == -1)\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn 0;\r\n}\r\ngboolean _5views_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\n_5views_dump_t *_5views;\r\nif (wtap_dump_file_seek(wdh, sizeof(t_5VW_Capture_Header), SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nwdh->subtype_write = _5views_dump;\r\nwdh->subtype_finish = _5views_dump_finish;\r\n_5views = (_5views_dump_t *)g_malloc(sizeof(_5views_dump_t));\r\nwdh->priv = (void *)_5views;\r\n_5views->nframes = 0;\r\nreturn TRUE;\r\n}\r\nstatic gboolean _5views_dump(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\n_5views_dump_t *_5views = (_5views_dump_t *)wdh->priv;\r\nt_5VW_TimeStamped_Header HeaderFrame;\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nHeaderFrame.Key = GUINT32_TO_LE(CST_5VW_RECORDS_HEADER_KEY);\r\nHeaderFrame.HeaderSize = GUINT16_TO_LE(sizeof(t_5VW_TimeStamped_Header));\r\nHeaderFrame.HeaderType = GUINT16_TO_LE(CST_5VW_TIMESTAMPED_HEADER_TYPE);\r\nHeaderFrame.RecType = GUINT32_TO_LE(CST_5VW_CAPTURES_RECORD | CST_5VW_SYSTEM_RECORD);\r\nHeaderFrame.RecSubType = GUINT32_TO_LE(CST_5VW_FRAME_RECORD);\r\nHeaderFrame.RecNb = GUINT32_TO_LE(1);\r\nHeaderFrame.Utc = GUINT32_TO_LE(phdr->ts.secs);\r\nHeaderFrame.NanoSecondes = GUINT32_TO_LE(phdr->ts.nsecs);\r\nHeaderFrame.RecSize = GUINT32_TO_LE(phdr->len);\r\nHeaderFrame.RecInfo = GUINT32_TO_LE(0);\r\nif (!wtap_dump_file_write(wdh, &HeaderFrame,\r\nsizeof(t_5VW_TimeStamped_Header), err))\r\nreturn FALSE;\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\n_5views->nframes ++;\r\nreturn TRUE;\r\n}\r\nstatic gboolean _5views_dump_finish(wtap_dumper *wdh, int *err)\r\n{\r\n_5views_dump_t *_5views = (_5views_dump_t *)wdh->priv;\r\nt_5VW_Capture_Header file_hdr;\r\nif (wtap_dump_file_seek(wdh, 0, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nfile_hdr.Info_Header.Signature = GUINT32_TO_LE(CST_5VW_INFO_HEADER_KEY);\r\nfile_hdr.Info_Header.Size = GUINT32_TO_LE(sizeof(t_5VW_Info_Header));\r\nfile_hdr.Info_Header.Version = GUINT32_TO_LE(CST_5VW_INFO_RECORD_VERSION);\r\nfile_hdr.Info_Header.DataSize = GUINT32_TO_LE(sizeof(t_5VW_Attributes_Header)\r\n+ sizeof(guint32)\r\n+ sizeof(t_5VW_Attributes_Header)\r\n+ sizeof(guint32));\r\nfile_hdr.Info_Header.FileType = GUINT32_TO_LE(wtap_encap[wdh->encap]);\r\nfile_hdr.Info_Header.Reserved[0] = 0;\r\nfile_hdr.Info_Header.Reserved[1] = 0;\r\nfile_hdr.Info_Header.Reserved[2] = 0;\r\nfile_hdr.HeaderDateCreation.Type = GUINT32_TO_LE(CST_5VW_IA_DATE_CREATION);\r\nfile_hdr.HeaderDateCreation.Size = GUINT16_TO_LE(sizeof(guint32));\r\nfile_hdr.HeaderDateCreation.Nb = GUINT16_TO_LE(1);\r\n#ifdef _WIN32\r\n_tzset();\r\n#endif\r\nfile_hdr.Time = GUINT32_TO_LE(time(NULL));\r\nfile_hdr.HeaderNbFrames.Type = GUINT32_TO_LE(CST_5VW_IA_CAP_INF_NB_TRAMES_STOCKEES);\r\nfile_hdr.HeaderNbFrames.Size = GUINT16_TO_LE(sizeof(guint32));\r\nfile_hdr.HeaderNbFrames.Nb = GUINT16_TO_LE(1);\r\nfile_hdr.TramesStockeesInFile = GUINT32_TO_LE(_5views->nframes);\r\nif (!wtap_dump_file_write(wdh, &file_hdr, sizeof(t_5VW_Capture_Header),\r\nerr))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}
