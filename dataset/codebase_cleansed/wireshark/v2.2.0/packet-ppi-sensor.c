static gdouble\r\nbase_10_expt(int power)\r\n{\r\ngdouble ret = 1;\r\nint provide_frac = 0;\r\nif (power == 0)\r\nreturn 1;\r\nif (power < 0)\r\n{\r\npower *= -1;\r\nprovide_frac = 1;\r\n}\r\nwhile (power > 0)\r\n{\r\nret = ret * 10;\r\npower--;\r\n}\r\nif (! provide_frac)\r\nreturn ret;\r\nelse\r\nreturn (1.0/ret);\r\n}\r\nstatic int\r\ndissect_ppi_sensor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nguint32 version;\r\nguint length;\r\nguint length_remaining;\r\nproto_tree *ppi_sensor_tree = NULL;\r\nproto_tree *pt, *my_pt;\r\nproto_item *version_item, *length_item;\r\nproto_tree *sensor_line;\r\nconst gchar *type_str = "Unknown sensor";\r\nconst gchar *unit_str = "Unknown unit";\r\nstatic const int * ppi_sensor_present_flags[] = {\r\n&hf_ppi_sensor_present_sensortype,\r\n&hf_ppi_sensor_present_scalefactor,\r\n&hf_ppi_sensor_present_val_x,\r\n&hf_ppi_sensor_present_val_y,\r\n&hf_ppi_sensor_present_val_z,\r\n&hf_ppi_sensor_present_val_t,\r\n&hf_ppi_sensor_present_val_e,\r\n&hf_ppi_sensor_present_descstr,\r\n&hf_ppi_sensor_present_appspecific_num,\r\n&hf_ppi_sensor_present_appspecific_data,\r\n&hf_ppi_sensor_present_ext,\r\nNULL\r\n};\r\nint bit;\r\nguint32 present, next_present;\r\nint offset = 0;\r\nguint16 sensortype =0;\r\ngchar scalefactor = 0;\r\ngdouble c_val=0;\r\nguint32 val_t=0;\r\nguint32 t_appspecific_num;\r\ngdouble curr_native_val;\r\ngchar* curr_str;\r\ncol_clear(pinfo->cinfo,COL_INFO);\r\nversion = tvb_get_guint8(tvb, offset);\r\nlength = tvb_get_letohs(tvb, offset+2);\r\npresent = tvb_get_letohl(tvb, offset+4);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "PPI Sensor info v%u, Length %u ",\r\nversion, length);\r\nsensor_line = proto_tree_add_protocol_format(tree, proto_ppi_sensor,\r\ntvb, 0, length, "PPI Sensor Header v%u, Length %u", version, length);\r\nppi_sensor_tree = proto_item_add_subtree(sensor_line, ett_ppi_sensor);\r\nversion_item = proto_tree_add_uint(ppi_sensor_tree, hf_ppi_sensor_version,\r\ntvb, offset, 1, version);\r\nproto_tree_add_item(ppi_sensor_tree, hf_ppi_sensor_pad,\r\ntvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nlength_item = proto_tree_add_uint(ppi_sensor_tree, hf_ppi_sensor_length,\r\ntvb, offset + 2, 2, length);\r\nif (! (version == 1 || version == 2) ) {\r\nexpert_add_info_format(pinfo, version_item, &ei_ppi_sensor_version, "Invalid version (got %d, expected 1 or 2)", version);\r\n}\r\nlength_remaining = length;\r\nif (length_remaining < PPI_GEOBASE_MIN_HEADER_LEN) {\r\nexpert_add_info_format(pinfo, length_item, &ei_ppi_sensor_length, "Invalid PPI-Sensor length - minimum length is 8");\r\nreturn 2;\r\n}\r\nif (length > PPI_SENSOR_MAXTAGLEN ) {\r\nexpert_add_info_format(pinfo, length_item, &ei_ppi_sensor_length, "Invalid PPI-Sensor length (got %d, %d max\n)", length, PPI_SENSOR_MAXTAGLEN);\r\nreturn 2;\r\n}\r\npt = proto_tree_add_bitmask(ppi_sensor_tree, tvb, offset + 4, hf_ppi_sensor_present, ett_ppi_sensor_present, ppi_sensor_present_flags, ENC_LITTLE_ENDIAN);\r\noffset += PPI_GEOBASE_MIN_HEADER_LEN;\r\nlength_remaining -= PPI_GEOBASE_MIN_HEADER_LEN;\r\nfor (; present; present = next_present) {\r\nnext_present = present & (present - 1);\r\nbit = BITNO_32(present ^ next_present);\r\nswitch (bit) {\r\ncase PPI_SENSOR_SENSORTYPE:\r\nif (length_remaining < 2)\r\nbreak;\r\nsensortype= tvb_get_letohs(tvb, offset);\r\ntype_str = val_to_str_const (sensortype, sensor_type_str, "Unknown Sensor type");\r\nunit_str = val_to_str_const (sensortype, sensor_unit_str, "Unknown Unit");\r\nif (tree) {\r\nmy_pt = proto_tree_add_uint(ppi_sensor_tree, hf_ppi_sensor_sensortype, tvb, offset , 2, sensortype);\r\nproto_item_append_text (my_pt, " %s", type_str);\r\nproto_item_set_text(sensor_line, "Sensor: %s", type_str);\r\n}\r\noffset+=2;\r\nlength_remaining-=2;\r\nbreak;\r\ncase PPI_SENSOR_SCALEFACTOR:\r\nif (length_remaining < 1)\r\nbreak;\r\nscalefactor = (gchar) tvb_get_guint8(tvb, offset);\r\nproto_tree_add_int(ppi_sensor_tree, hf_ppi_sensor_scalefactor, tvb, offset, 1, scalefactor);\r\noffset+=1;\r\nlength_remaining-=1;\r\nbreak;\r\ncase PPI_SENSOR_VAL_X:\r\nif (length_remaining < 4)\r\nbreak;\r\nval_t = tvb_get_letohl(tvb, offset);\r\nc_val = ppi_fixed6_4_to_gdouble(val_t);\r\nif (tree) {\r\nmy_pt = proto_tree_add_double(ppi_sensor_tree, hf_ppi_sensor_val_x, tvb, offset, 4, c_val);\r\nproto_item_append_text (my_pt, " %s", unit_str);\r\ncurr_native_val = c_val * base_10_expt(scalefactor);\r\nproto_item_set_text(sensor_line, "Sensor: %s %f %s", type_str, curr_native_val, unit_str);\r\n}\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_SENSOR_VAL_Y:\r\nif (length_remaining < 4)\r\nbreak;\r\nval_t = tvb_get_letohl(tvb, offset);\r\nc_val = ppi_fixed6_4_to_gdouble(val_t);\r\nif (tree) {\r\nmy_pt = proto_tree_add_double(ppi_sensor_tree, hf_ppi_sensor_val_y, tvb, offset, 4, c_val);\r\nproto_item_append_text (my_pt, " %s", unit_str);\r\ncurr_native_val = c_val * base_10_expt(scalefactor);\r\nproto_item_set_text(sensor_line, "Sensor: %s %f %s", type_str, curr_native_val, unit_str);\r\n}\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_SENSOR_VAL_Z:\r\nif (length_remaining < 4)\r\nbreak;\r\nval_t = tvb_get_letohl(tvb, offset);\r\nc_val = ppi_fixed6_4_to_gdouble(val_t);\r\nif (tree) {\r\nmy_pt = proto_tree_add_double(ppi_sensor_tree, hf_ppi_sensor_val_z, tvb, offset, 4, c_val);\r\nproto_item_append_text (my_pt, " %s", unit_str);\r\ncurr_native_val = c_val * base_10_expt(scalefactor);\r\nproto_item_set_text(sensor_line, "Sensor: %s %f %s", type_str, curr_native_val, unit_str);\r\n}\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_SENSOR_VAL_T:\r\nif (length_remaining < 4)\r\nbreak;\r\nval_t = tvb_get_letohl(tvb, offset);\r\nc_val = ppi_fixed6_4_to_gdouble(val_t);\r\nif (tree) {\r\nmy_pt = proto_tree_add_double(ppi_sensor_tree, hf_ppi_sensor_val_t, tvb, offset, 4, c_val);\r\nproto_item_append_text (my_pt, " %s", unit_str);\r\ncurr_native_val = c_val * base_10_expt(scalefactor);\r\nproto_item_set_text(sensor_line, "Sensor: %s %f %s", type_str, curr_native_val, unit_str);\r\n}\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_SENSOR_VAL_E:\r\nif (length_remaining < 4)\r\nbreak;\r\nval_t = tvb_get_letohl(tvb, offset);\r\nc_val = ppi_fixed6_4_to_gdouble(val_t);\r\nif (tree) {\r\nmy_pt = proto_tree_add_double(ppi_sensor_tree, hf_ppi_sensor_val_e, tvb, offset, 4, c_val);\r\nproto_item_append_text (my_pt, " %s", unit_str);\r\n}\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_SENSOR_DESCSTR:\r\nif (length_remaining < 32)\r\nbreak;\r\nif (tree)\r\n{\r\ncurr_str = tvb_format_stringzpad(tvb, offset, 32);\r\nproto_tree_add_string(ppi_sensor_tree, hf_ppi_sensor_descstr, tvb, offset, 32, curr_str);\r\nproto_item_append_text(sensor_line, " (%s)", curr_str);\r\n}\r\noffset+=32;\r\nlength_remaining-=32;\r\nbreak;\r\ncase PPI_SENSOR_APPID:\r\nif (length_remaining < 4)\r\nbreak;\r\nt_appspecific_num = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint(ppi_sensor_tree, hf_ppi_sensor_appspecific_num, tvb, offset, 4, t_appspecific_num);\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_SENSOR_APPDATA:\r\nif (length_remaining < 60)\r\nbreak;\r\nproto_tree_add_item(ppi_sensor_tree, hf_ppi_sensor_appspecific_data, tvb, offset, 60, ENC_NA);\r\noffset+=60;\r\nlength_remaining-=60;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, pt, &ei_ppi_sensor_present_bit, "Error: PPI-SENSOR: unknown bit (%d) set in present field.", bit);\r\nnext_present = 0;\r\ncontinue;\r\n}\r\n};\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ppi_sensor(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ppi_sensor_version,\r\n{ "Header revision", "ppi_sensor.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Version of ppi_sensor header format", HFILL } },\r\n{ &hf_ppi_sensor_pad,\r\n{ "Header pad", "ppi_sensor.pad",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Padding", HFILL } },\r\n{ &hf_ppi_sensor_length,\r\n{ "Header length", "ppi_sensor.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Length of header including version, pad, length and data fields", HFILL } },\r\n{ &hf_ppi_sensor_present,\r\n{ "Present", "ppi_sensor.present",\r\nFT_UINT32, BASE_HEX, NULL, 0x0, "Bitmask indicating which fields are present", HFILL } },\r\n#define PPI_SENSOR_MASK_SENSORTYPE 0x00000001\r\n#define PPI_SENSOR_MASK_SCALEFACTOR 0x00000002\r\n#define PPI_SENSOR_MASK_VAL_X 0x00000004\r\n#define PPI_SENSOR_MASK_VAL_Y 0x00000008\r\n#define PPI_SENSOR_MASK_VAL_Z 0x00000010\r\n#define PPI_SENSOR_MASK_VAL_T 0x00000020\r\n#define PPI_SENSOR_MASK_VAL_E 0x00000040\r\n#define PPI_SENSOR_MASK_SERIALNUM 0x04000000\r\n#define PPI_SENSOR_MASK_MODELSTR 0x08000000\r\n#define PPI_SENSOR_MASK_DESCSTR 0x10000000\r\n#define PPI_SENSOR_MASK_APPID 0x20000000\r\n#define PPI_SENSOR_MASK_APPDATA 0x40000000\r\n#define PPI_SENSOR_MASK_EXT 0x80000000\r\n{ &hf_ppi_sensor_present_sensortype,\r\n{ "sensortype", "ppi_sensor.present.sensortype",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_SENSORTYPE,\r\n"Specifies if the sensor type field is present", HFILL } },\r\n{ &hf_ppi_sensor_present_scalefactor,\r\n{ "scalefactor", "ppi_sensor.present.scalefactor",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_SCALEFACTOR,\r\n"Specifies if the sensor scale factor field is present", HFILL } },\r\n{ &hf_ppi_sensor_present_val_x,\r\n{ "val_x", "ppi_sensor.present.val_x",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_VAL_X,\r\n"Specifies if the sensor val_x field is present", HFILL } },\r\n{ &hf_ppi_sensor_present_val_y,\r\n{ "val_y", "ppi_sensor.present.val_y",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_VAL_Y,\r\n"Specifies if the sensor val_y field is present", HFILL } },\r\n{ &hf_ppi_sensor_present_val_z,\r\n{ "val_z", "ppi_sensor.present.val_z",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_VAL_Z,\r\n"Specifies if the BeamID field is present", HFILL } },\r\n{ &hf_ppi_sensor_present_val_t,\r\n{ "val_t", "ppi_sensor.present.val_t",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_VAL_T,\r\n"Specifies if the val_t field is present", HFILL } },\r\n{ &hf_ppi_sensor_present_val_e,\r\n{ "val_e", "ppi_sensor.present.val_e",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_VAL_E,\r\n"Specifies if the val_e field is present", HFILL } },\r\n{ &hf_ppi_sensor_present_descstr,\r\n{ "Description", "ppi_sensor.present.descr",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_DESCSTR,\r\n"Specifies if the description string is present", HFILL } },\r\n{ &hf_ppi_sensor_present_appspecific_num,\r\n{ "appid", "ppi_sensor.present.appid",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_APPID,\r\n"Specifies if the application specific field id is present", HFILL } },\r\n{ &hf_ppi_sensor_present_appspecific_data,\r\n{ "appdata", "ppi_sensor.present.appdata",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_APPDATA,\r\n"Specifies if the application specific data field is present", HFILL } },\r\n{ &hf_ppi_sensor_present_ext,\r\n{ "ext", "ppi_sensor.present.ext",\r\nFT_BOOLEAN, 32, NULL, PPI_SENSOR_MASK_EXT,\r\n"Specifies if there are any extensions to the header present", HFILL } },\r\n{ &hf_ppi_sensor_sensortype,\r\n{ "SensorType", "ppi_sensor.sensortype",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Type of sensor", HFILL } },\r\n{ &hf_ppi_sensor_scalefactor,\r\n{ "ScaleFactor", "ppi_sensor.scalefactor",\r\nFT_INT8, BASE_DEC, NULL, 0x0,\r\n"Scaling factor", HFILL } },\r\n{ &hf_ppi_sensor_val_x,\r\n{ "Val_X", "ppi_sensor.val_x",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Value in X-dimesion", HFILL } },\r\n{ &hf_ppi_sensor_val_y,\r\n{ "Val_Y", "ppi_sensor.val_y",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Value in Y-dimension", HFILL } },\r\n{ &hf_ppi_sensor_val_z,\r\n{ "Val_Z", "ppi_sensor.val_z",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Value in Z-dimension", HFILL } },\r\n{ &hf_ppi_sensor_val_t,\r\n{ "Val_T", "ppi_sensor.val_t",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Value total (dimensionless)", HFILL } },\r\n{ &hf_ppi_sensor_val_e,\r\n{ "Val_E", "ppi_sensor.val_e",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Margin of error", HFILL } },\r\n{ &hf_ppi_sensor_descstr,\r\n{ "Description", "ppi_sensor.descr",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } } ,\r\n{ &hf_ppi_sensor_appspecific_num,\r\n{ "Application Specific id", "ppi_sensor.appid",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Application-specific identifier", HFILL } },\r\n{ &hf_ppi_sensor_appspecific_data,\r\n{ "Application specific data", "ppi_sensor.appdata",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Application-specific data", HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ppi_sensor,\r\n&ett_ppi_sensor_present,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ppi_sensor_present_bit, { "ppi_sensor.present.unknown_bit", PI_PROTOCOL, PI_WARN, "Error: PPI-ANTENNA: unknown bit set in present field.", EXPFILL }},\r\n{ &ei_ppi_sensor_version, { "ppi_sensor.version.unsupported", PI_PROTOCOL, PI_WARN, "Invalid version", EXPFILL }},\r\n{ &ei_ppi_sensor_length, { "ppi_sensor.length.invalid", PI_MALFORMED, PI_ERROR, "Invalid length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ppi_sensor;\r\nproto_ppi_sensor = proto_register_protocol("PPI sensor decoder", "PPI sensor Decoder", "ppi_sensor");\r\nproto_register_field_array(proto_ppi_sensor, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ppi_sensor = expert_register_protocol(proto_ppi_sensor);\r\nexpert_register_field_array(expert_ppi_sensor, ei, array_length(ei));\r\nregister_dissector("ppi_sensor", dissect_ppi_sensor, proto_ppi_sensor);\r\n}
