static void\r\nredbackli_dissect_avp(guint8 avptype, guint8 avplen, tvbuff_t *tvb, gint offset, proto_tree *tree)\r\n{\r\nconst char *avpname;\r\nproto_tree *st = NULL;\r\navpname = val_to_str_const(avptype, avp_names, "Unknown");\r\nst = proto_tree_add_subtree_format(tree, tvb, offset, avplen+2, ett_redbackli, NULL, "%s AVP", avpname);\r\nproto_tree_add_uint(st, hf_redbackli_avptype, tvb, offset, 1, avptype);\r\nproto_tree_add_uint(st, hf_redbackli_avplen, tvb, offset+1, 1, avplen);\r\nif (!avplen)\r\nreturn;\r\nswitch (avptype) {\r\ncase(RB_AVP_SEQNO):\r\nproto_tree_add_item(st, hf_redbackli_seqno, tvb,\r\noffset+2, avplen, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase(RB_AVP_LIID):\r\nproto_tree_add_item(st, hf_redbackli_liid, tvb,\r\noffset+2, avplen, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase(RB_AVP_SESSID):\r\nproto_tree_add_item(st, hf_redbackli_sessid, tvb,\r\noffset+2, avplen, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase(RB_AVP_LABEL):\r\nproto_tree_add_item(st, hf_redbackli_label, tvb,\r\noffset+2, avplen, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase(RB_AVP_EOH):\r\nproto_tree_add_item(st, hf_redbackli_eohpad, tvb,\r\noffset+2, avplen, ENC_NA);\r\nbreak;\r\ncase(RB_AVP_DIR):\r\nproto_tree_add_item(st, hf_redbackli_dir, tvb,\r\noffset+2, avplen, ENC_NA);\r\nbreak;\r\ncase(RB_AVP_ACCTID):\r\nproto_tree_add_item(st, hf_redbackli_acctid, tvb,\r\noffset+2, avplen, ENC_NA);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(st, hf_redbackli_unknownavp, tvb,\r\noffset+2, avplen, ENC_NA);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nredbackli_dissect(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint8 avptype, avplen;\r\ngint len, offset = 0;\r\ngboolean eoh;\r\nproto_item *ti;\r\nproto_tree *redbackli_tree = NULL;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RBLI");\r\nti = proto_tree_add_item(tree, proto_redbackli,\r\ntvb, 0, -1, ENC_NA);\r\nredbackli_tree = proto_item_add_subtree(ti, ett_redbackli);\r\nlen = tvb_reported_length(tvb);\r\noffset = 0;\r\neoh = FALSE;\r\nwhile (!eoh && (len > 2)) {\r\navptype = tvb_get_guint8(tvb, offset+0);\r\navplen = tvb_get_guint8(tvb, offset+1);\r\nif ((len-2) < avplen)\r\nbreak;\r\nif (tree)\r\nredbackli_dissect_avp(avptype, avplen, tvb, offset, redbackli_tree);\r\nif (avptype == RB_AVP_EOH)\r\neoh = TRUE;\r\noffset += 2 + avplen;\r\nlen -= 2 + avplen;\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(ip_handle, next_tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\nredbackli_dissect_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ngint len, offset = 0;\r\ngboolean eoh = FALSE;\r\nguint8 avptype, avplen;\r\nguint32 avpfound = 0;\r\nlen = tvb_captured_length(tvb);\r\nif (len < MIN_REDBACKLI_SIZE)\r\nreturn FALSE;\r\nwhile ((len > 2) && !eoh) {\r\navptype = tvb_get_guint8(tvb, offset+0);\r\navplen = tvb_get_guint8(tvb, offset+1);\r\nswitch (avptype) {\r\ncase(RB_AVP_SEQNO):\r\ncase(RB_AVP_LIID):\r\ncase(RB_AVP_SESSID):\r\nif (avplen != 4)\r\nreturn FALSE;\r\navpfound |= 1<<avptype;\r\nbreak;\r\ncase(RB_AVP_EOH):\r\nif (avplen > 1 || offset == 0)\r\nreturn FALSE;\r\neoh = TRUE;\r\nbreak;\r\ncase(RB_AVP_LABEL):\r\ncase(RB_AVP_DIR):\r\ncase(RB_AVP_ACCTID):\r\nbreak;\r\ndefault:\r\nreturn FALSE;\r\n}\r\noffset += 2 + avplen;\r\nlen -= 2 + avplen;\r\n}\r\nif (!(avpfound & (1<<RB_AVP_SEQNO)))\r\nreturn FALSE;\r\nif (!(avpfound & (1<<RB_AVP_SESSID)))\r\nreturn FALSE;\r\nif (!(avpfound & (1<<RB_AVP_LIID)))\r\nreturn FALSE;\r\nredbackli_dissect(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nvoid proto_register_redbackli(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_redbackli_avptype,\r\n{ "AVP Type", "redbackli.avptype", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_redbackli_avplen,\r\n{ "AVP Length", "redbackli.avplen", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_redbackli_seqno,\r\n{ "Sequence No", "redbackli.seqno", FT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_redbackli_liid,\r\n{ "Lawful Intercept Id", "redbackli.liid", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"LI Identifier", HFILL }},\r\n{ &hf_redbackli_sessid,\r\n{ "Session Id", "redbackli.sessid", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Session Identifier", HFILL }},\r\n#if 0\r\n{ &hf_redbackli_dir,\r\n{ "Direction", "redbackli.dir", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n#else\r\n{ &hf_redbackli_dir,\r\n{ "Direction", "redbackli.dir", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n#endif\r\n{ &hf_redbackli_label,\r\n{ "Label", "redbackli.label", FT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_redbackli_acctid,\r\n{ "Acctid", "redbackli.acctid", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_redbackli_eohpad,\r\n{ "End of Header Padding", "redbackli.eohpad", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_redbackli_unknownavp,\r\n{ "Unknown AVP", "redbackli.unknownavp", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_redbackli\r\n};\r\nproto_redbackli = proto_register_protocol("Redback Lawful Intercept",\r\n"RedbackLI", "redbackli");\r\nproto_register_field_array(proto_redbackli, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("redbackli", redbackli_dissect, proto_redbackli);\r\n}\r\nvoid proto_reg_handoff_redbackli(void) {\r\ndissector_handle_t redbackli_handle;\r\nip_handle = find_dissector_add_dependency("ip", proto_redbackli);\r\nredbackli_handle = find_dissector("redbackli");\r\ndissector_add_for_decode_as("udp.port", redbackli_handle);\r\nheur_dissector_add("udp", redbackli_dissect_heur, "Redback Lawful Intercept over UDP", "redbackli_udp", proto_redbackli, HEURISTIC_ENABLE);\r\n}
