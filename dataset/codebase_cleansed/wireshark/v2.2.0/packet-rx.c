static int\r\ndissect_rx_response_encrypted(tvbuff_t *tvb, proto_tree *parent_tree, int offset)\r\n{\r\nproto_tree *tree;\r\nproto_item *item;\r\nint old_offset=offset;\r\nint i;\r\nguint32 callnumber;\r\nitem = proto_tree_add_item(parent_tree, hf_rx_encrypted, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_rx_encrypted);\r\n{\r\nnstime_t ts;\r\nts.secs = tvb_get_ntohl(tvb, offset);\r\nts.nsecs = 0;\r\nproto_tree_add_time(tree, hf_rx_epoch, tvb,\r\noffset, 4, &ts);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(tree, hf_rx_cid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_rx_securityindex, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nfor (i=0; i<RX_MAXCALLS; i++) {\r\ncallnumber = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(tree, hf_rx_callnumber, tvb,\r\noffset, 4, callnumber);\r\noffset += 4;\r\n}\r\nproto_tree_add_item(tree, hf_rx_inc_nonce, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_rx_level, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_rx_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, int offset, guint32 seq, guint32 callnumber)\r\n{\r\nproto_tree *tree;\r\nproto_item *item;\r\nguint32 version, tl;\r\nint old_offset=offset;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"RESPONSE "\r\n"Seq: %lu "\r\n"Call: %lu "\r\n"Source Port: %s "\r\n"Destination Port: %s ",\r\n(unsigned long)seq,\r\n(unsigned long)callnumber,\r\nudp_port_to_display(wmem_packet_scope(), pinfo->srcport),\r\nudp_port_to_display(wmem_packet_scope(), pinfo->destport)\r\n);\r\nitem = proto_tree_add_item(parent_tree, hf_rx_response, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_rx_response);\r\nversion = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(tree, hf_rx_version, tvb,\r\noffset, 4, version);\r\noffset += 4;\r\nif (version==2) {\r\noffset += 4;\r\noffset = dissect_rx_response_encrypted(tvb, tree, offset);\r\nproto_tree_add_item(tree, hf_rx_kvno, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ntl = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(tree, hf_rx_ticket_len, tvb,\r\noffset, 4, tl);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_rx_ticket, tvb, offset, tl, ENC_NA);\r\noffset += tl;\r\n}\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_rx_abort(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, int offset, guint32 seq, guint32 callnumber)\r\n{\r\nproto_tree *tree;\r\nproto_item *item;\r\nint old_offset=offset;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"ABORT "\r\n"Seq: %lu "\r\n"Call: %lu "\r\n"Source Port: %s "\r\n"Destination Port: %s ",\r\n(unsigned long)seq,\r\n(unsigned long)callnumber,\r\nudp_port_to_display(wmem_packet_scope(), pinfo->srcport),\r\nudp_port_to_display(wmem_packet_scope(), pinfo->destport)\r\n);\r\nitem = proto_tree_add_item(parent_tree, hf_rx_abort, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_rx_abort);\r\nproto_tree_add_item(tree, hf_rx_abortcode, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_rx_challenge(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, int offset, guint32 seq, guint32 callnumber)\r\n{\r\nproto_tree *tree;\r\nproto_item *item;\r\nguint32 version;\r\nint old_offset=offset;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"CHALLENGE "\r\n"Seq: %lu "\r\n"Call: %lu "\r\n"Source Port: %s "\r\n"Destination Port: %s ",\r\n(unsigned long)seq,\r\n(unsigned long)callnumber,\r\nudp_port_to_display(wmem_packet_scope(), pinfo->srcport),\r\nudp_port_to_display(wmem_packet_scope(), pinfo->destport)\r\n);\r\nitem = proto_tree_add_item(parent_tree, hf_rx_challenge, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_rx_challenge);\r\nversion = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(tree, hf_rx_version, tvb,\r\noffset, 4, version);\r\noffset += 4;\r\nif (version==2) {\r\nproto_tree_add_item(tree, hf_rx_nonce, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_rx_min_level, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_rx_acks(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, int offset, guint32 seq, guint32 callnumber)\r\n{\r\nproto_tree *tree;\r\nproto_item *item;\r\nguint8 num;\r\nint old_offset = offset;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"ACK "\r\n"Seq: %lu "\r\n"Call: %lu "\r\n"Source Port: %s "\r\n"Destination Port: %s ",\r\n(unsigned long)seq,\r\n(unsigned long)callnumber,\r\nudp_port_to_display(wmem_packet_scope(), pinfo->srcport),\r\nudp_port_to_display(wmem_packet_scope(), pinfo->destport)\r\n);\r\nitem = proto_tree_add_item(parent_tree, hf_rx_ack, tvb, offset, -1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_rx_ack);\r\nproto_tree_add_item(tree, hf_rx_bufferspace, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_rx_maxskew, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_rx_first_packet, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_rx_prev_packet, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_rx_serial, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_rx_reason, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nnum = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(tree, hf_rx_numacks, tvb, offset, 1, num);\r\noffset += 1;\r\nwhile(num--){\r\nproto_tree_add_item(tree, hf_rx_ack_type, tvb, offset, 1,\r\nENC_BIG_ENDIAN);\r\noffset += 1;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset)>3) {\r\noffset += 3;\r\nif (tvb_reported_length_remaining(tvb, offset) >= 4){\r\nproto_tree_add_item(tree, hf_rx_maxmtu, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) >= 4){\r\nproto_tree_add_item(tree, hf_rx_ifmtu, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) >= 4){\r\nproto_tree_add_item(tree, hf_rx_rwind, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) >= 4){\r\nproto_tree_add_item(tree, hf_rx_maxpackets, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\n}\r\nproto_item_set_len(item, offset-old_offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_rx_flags(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *parent_tree, int offset)\r\n{\r\nstatic const int * flags[] = {\r\n&hf_rx_flags_free_packet,\r\n&hf_rx_flags_more_packets,\r\n&hf_rx_flags_last_packet,\r\n&hf_rx_flags_request_ack,\r\n&hf_rx_flags_clientinit,\r\nNULL\r\n};\r\nrxinfo->flags = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_bitmask(parent_tree, tvb, offset, hf_rx_flags, ett_rx_flags, flags, ENC_NA);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_rx(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data _U_)\r\n{\r\nproto_tree *tree;\r\nproto_item *item;\r\nint offset = 0;\r\nstruct rxinfo rxinfo;\r\nguint8 type;\r\nnstime_t ts;\r\nguint32 seq, callnumber;\r\nguint16 serviceid;\r\nif (tvb_captured_length(tvb) < 28)\r\nreturn 0;\r\ntype = tvb_get_guint8(tvb, 20);\r\nif (type == 0 || type == 10 || type == 11 || type == 12 || type > 13)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RX");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nitem = proto_tree_add_protocol_format(parent_tree, proto_rx, tvb,\r\noffset, 28, "RX Protocol");\r\ntree = proto_item_add_subtree(item, ett_rx);\r\nrxinfo.epoch = tvb_get_ntohl(tvb, offset);\r\nts.secs = rxinfo.epoch;\r\nts.nsecs = 0;\r\nproto_tree_add_time(tree, hf_rx_epoch, tvb, offset, 4, &ts);\r\noffset += 4;\r\nrxinfo.cid = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_rx_cid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ncallnumber = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(tree, hf_rx_callnumber, tvb,\r\noffset, 4, callnumber);\r\noffset += 4;\r\nrxinfo.callnumber = callnumber;\r\nseq = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint(tree, hf_rx_seq, tvb,\r\noffset, 4, seq);\r\noffset += 4;\r\nrxinfo.seq = seq;\r\nproto_tree_add_item(tree, hf_rx_serial, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ntype = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(tree, hf_rx_type, tvb,\r\noffset, 1, type);\r\noffset += 1;\r\nrxinfo.type = type;\r\noffset = dissect_rx_flags(tvb, &rxinfo, tree, offset);\r\nproto_tree_add_item(tree, hf_rx_userstatus, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_rx_securityindex, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_rx_spare, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nserviceid = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint(tree, hf_rx_serviceid, tvb,\r\noffset, 2, serviceid);\r\noffset += 2;\r\nrxinfo.serviceid = serviceid;\r\nswitch (type) {\r\ncase RX_PACKET_TYPE_ACK:\r\ndissect_rx_acks(tvb, pinfo, tree, offset,\r\nseq, callnumber);\r\nbreak;\r\ncase RX_PACKET_TYPE_ACKALL:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"ACKALL "\r\n"Seq: %lu "\r\n"Call: %lu "\r\n"Source Port: %s "\r\n"Destination Port: %s ",\r\n(unsigned long)seq,\r\n(unsigned long)callnumber,\r\nudp_port_to_display(wmem_packet_scope(), pinfo->srcport),\r\nudp_port_to_display(wmem_packet_scope(), pinfo->destport)\r\n);\r\nbreak;\r\ncase RX_PACKET_TYPE_CHALLENGE:\r\ndissect_rx_challenge(tvb, pinfo, tree, offset, seq, callnumber);\r\nbreak;\r\ncase RX_PACKET_TYPE_RESPONSE:\r\ndissect_rx_response(tvb, pinfo, tree, offset, seq, callnumber);\r\nbreak;\r\ncase RX_PACKET_TYPE_DATA: {\r\ntvbuff_t *next_tvb;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector_with_data(afs_handle, next_tvb, pinfo, parent_tree, &rxinfo);\r\n};\r\nbreak;\r\ncase RX_PACKET_TYPE_ABORT:\r\ndissect_rx_abort(tvb, pinfo, tree, offset, seq, callnumber);\r\nbreak;\r\n}\r\nreturn(tvb_captured_length(tvb));\r\n}\r\nvoid\r\nproto_register_rx(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_rx_epoch, {\r\n"Epoch", "rx.epoch", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_cid, {\r\n"CID", "rx.cid", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_callnumber, {\r\n"Call Number", "rx.callnumber", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_seq, {\r\n"Sequence Number", "rx.seq", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_serial, {\r\n"Serial", "rx.serial", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_type, {\r\n"Type", "rx.type", FT_UINT8, BASE_DEC,\r\nVALS(rx_types), 0, NULL, HFILL }},\r\n{ &hf_rx_flags, {\r\n"Flags", "rx.flags", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_flags_clientinit, {\r\n"Client Initiated", "rx.flags.client_init", FT_BOOLEAN, 8,\r\nNULL, RX_CLIENT_INITIATED, NULL, HFILL }},\r\n{ &hf_rx_flags_request_ack, {\r\n"Request Ack", "rx.flags.request_ack", FT_BOOLEAN, 8,\r\nNULL, RX_REQUEST_ACK, NULL, HFILL }},\r\n{ &hf_rx_flags_last_packet, {\r\n"Last Packet", "rx.flags.last_packet", FT_BOOLEAN, 8,\r\nNULL, RX_LAST_PACKET, NULL, HFILL }},\r\n{ &hf_rx_flags_more_packets, {\r\n"More Packets", "rx.flags.more_packets", FT_BOOLEAN, 8,\r\nNULL, RX_MORE_PACKETS, NULL, HFILL }},\r\n{ &hf_rx_flags_free_packet, {\r\n"Free Packet", "rx.flags.free_packet", FT_BOOLEAN, 8,\r\nNULL, RX_FREE_PACKET, NULL, HFILL }},\r\n{ &hf_rx_userstatus, {\r\n"User Status", "rx.userstatus", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_securityindex, {\r\n"Security Index", "rx.securityindex", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_spare, {\r\n"Spare/Checksum", "rx.spare", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_serviceid, {\r\n"Service ID", "rx.serviceid", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_bufferspace, {\r\n"Bufferspace", "rx.bufferspace", FT_UINT16, BASE_DEC,\r\nNULL, 0, "Number Of Packets Available", HFILL }},\r\n{ &hf_rx_maxskew, {\r\n"Max Skew", "rx.maxskew", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_first_packet, {\r\n"First Packet", "rx.first", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_prev_packet, {\r\n"Prev Packet", "rx.prev", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Previous Packet", HFILL }},\r\n{ &hf_rx_reason, {\r\n"Reason", "rx.reason", FT_UINT8, BASE_DEC,\r\nVALS(rx_reason), 0, "Reason For This ACK", HFILL }},\r\n{ &hf_rx_numacks, {\r\n"Num ACKs", "rx.num_acks", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Number Of ACKs", HFILL }},\r\n{ &hf_rx_ack_type, {\r\n"ACK Type", "rx.ack_type", FT_UINT8, BASE_DEC,\r\nVALS(rx_ack_type), 0, "Type Of ACKs", HFILL }},\r\n{ &hf_rx_ack, {\r\n"ACK Packet", "rx.ack", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_challenge, {\r\n"CHALLENGE Packet", "rx.challenge", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_version, {\r\n"Version", "rx.version", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Version Of Challenge/Response", HFILL }},\r\n{ &hf_rx_nonce, {\r\n"Nonce", "rx.nonce", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_inc_nonce, {\r\n"Inc Nonce", "rx.inc_nonce", FT_UINT32, BASE_HEX,\r\nNULL, 0, "Incremented Nonce", HFILL }},\r\n{ &hf_rx_min_level, {\r\n"Min Level", "rx.min_level", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_level, {\r\n"Level", "rx.level", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_response, {\r\n"RESPONSE Packet", "rx.response", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_abort, {\r\n"ABORT Packet", "rx.abort", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_encrypted, {\r\n"Encrypted", "rx.encrypted", FT_NONE, BASE_NONE,\r\nNULL, 0, "Encrypted part of response packet", HFILL }},\r\n{ &hf_rx_kvno, {\r\n"kvno", "rx.kvno", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_ticket_len, {\r\n"Ticket len", "rx.ticket_len", FT_UINT32, BASE_DEC,\r\nNULL, 0, "Ticket Length", HFILL }},\r\n{ &hf_rx_ticket, {\r\n"ticket", "rx.ticket", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_ifmtu, {\r\n"Interface MTU", "rx.if_mtu", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_maxmtu, {\r\n"Max MTU", "rx.max_mtu", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_rwind, {\r\n"rwind", "rx.rwind", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_maxpackets, {\r\n"Max Packets", "rx.max_packets", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_rx_abortcode, {\r\n"Abort Code", "rx.abort_code", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_rx,\r\n&ett_rx_flags,\r\n&ett_rx_ack,\r\n&ett_rx_challenge,\r\n&ett_rx_response,\r\n&ett_rx_encrypted,\r\n&ett_rx_abort\r\n};\r\nproto_rx = proto_register_protocol("RX Protocol", "RX", "rx");\r\nproto_register_field_array(proto_rx, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_rx(void)\r\n{\r\ndissector_handle_t rx_handle;\r\nint port;\r\nafs_handle = find_dissector_add_dependency("afs", proto_rx);\r\nrx_handle = create_dissector_handle(dissect_rx, proto_rx);\r\nfor (port = UDP_PORT_RX_LOW; port <= UDP_PORT_RX_HIGH; port++)\r\ndissector_add_uint("udp.port", port, rx_handle);\r\ndissector_add_uint("udp.port", UDP_PORT_RX_AFS_BACKUPS, rx_handle);\r\n}
