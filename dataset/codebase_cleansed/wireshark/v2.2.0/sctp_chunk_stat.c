static void\r\nsctpstat_reset(void *phs)\r\n{\r\nsctpstat_t* sctp_stat = (sctpstat_t *)phs;\r\nsctp_ep_t* list = (sctp_ep_t*)sctp_stat->ep_list;\r\nsctp_ep_t* tmp = NULL;\r\nguint16 chunk_type;\r\nif(!list)\r\nreturn;\r\nfor(tmp = list; tmp ; tmp=tmp->next)\r\nfor(chunk_type = 0; chunk_type < 256; chunk_type++)\r\ntmp->chunk_count[chunk_type] = 0;\r\nsctp_stat->number_of_packets = 0;\r\n}\r\nstatic sctp_ep_t* alloc_sctp_ep(struct _sctp_info *si)\r\n{\r\nsctp_ep_t* ep;\r\nguint16 chunk_type;\r\nif(!si)\r\nreturn NULL;\r\nif (!(ep = (sctp_ep_t *)g_malloc(sizeof(sctp_ep_t))))\r\nreturn NULL;\r\ncopy_address(&ep->src,&si->ip_src);\r\ncopy_address(&ep->dst,&si->ip_dst);\r\nep->sport = si->sport;\r\nep->dport = si->dport;\r\nep->next = NULL;\r\nfor(chunk_type = 0; chunk_type < 256; chunk_type++)\r\nep->chunk_count[chunk_type] = 0;\r\nreturn ep;\r\n}\r\nstatic int\r\nsctpstat_packet(void *phs, packet_info *pinfo _U_, epan_dissect_t *edt _U_, const void *phi)\r\n{\r\nsctpstat_t *hs=(sctpstat_t *)phs;\r\nsctp_ep_t *tmp = NULL, *te = NULL;\r\nstruct _sctp_info *si = (struct _sctp_info *) phi;\r\nguint32 tvb_number;\r\nif (!hs)\r\nreturn (0);\r\nhs->number_of_packets++;\r\nif(!hs->ep_list) {\r\nhs->ep_list = alloc_sctp_ep(si);\r\nte = hs->ep_list;\r\n} else {\r\nfor(tmp=hs->ep_list ; tmp ; tmp=tmp->next) {\r\nif((!cmp_address(&tmp->src,&si->ip_src)) &&\r\n(!cmp_address(&tmp->dst,&si->ip_dst)) &&\r\n(tmp->sport == si->sport) &&\r\n(tmp->dport == si->dport)) {\r\nte = tmp;\r\nbreak;\r\n}\r\n}\r\nif(!te) {\r\nif ((te = alloc_sctp_ep(si))) {\r\nte->next = hs->ep_list;\r\nhs->ep_list = te;\r\n}\r\n}\r\n}\r\nif(!te)\r\nreturn (0);\r\nif (si->number_of_tvbs > 0) {\r\nfor(tvb_number = 0; tvb_number < si->number_of_tvbs; tvb_number++) {\r\nif (IS_SCTP_CHUNK_TYPE(CHUNK_TYPE(si->tvb[tvb_number])))\r\n(te->chunk_count[CHUNK_TYPE(si->tvb[tvb_number])])++;\r\nelse\r\n(te->chunk_count[OTHER_CHUNKS_INDEX])++;\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic void\r\nsctpstat_draw(void *phs)\r\n{\r\nsctpstat_t *hs=(sctpstat_t *)phs;\r\nsctp_ep_t* list = hs->ep_list, *tmp;\r\nGtkListStore *store;\r\nGtkTreeIter iter;\r\nchar *src_addr, *dst_addr;\r\nstore = GTK_LIST_STORE(gtk_tree_view_get_model(hs->table));\r\ngtk_list_store_clear(store);\r\nfor(tmp = list ; tmp ; tmp=tmp->next) {\r\nsrc_addr = (char*)address_to_str(NULL, &tmp->src);\r\ndst_addr = (char*)address_to_str(NULL, &tmp->dst);\r\ngtk_list_store_append(store, &iter);\r\ngtk_list_store_set(store, &iter,\r\n0, src_addr,\r\n1, tmp->sport,\r\n2, dst_addr,\r\n3, tmp->dport,\r\n4, tmp->chunk_count[SCTP_DATA_CHUNK_ID],\r\n5, tmp->chunk_count[SCTP_SACK_CHUNK_ID],\r\n6, tmp->chunk_count[SCTP_HEARTBEAT_CHUNK_ID],\r\n7, tmp->chunk_count[SCTP_HEARTBEAT_ACK_CHUNK_ID],\r\n8, tmp->chunk_count[SCTP_INIT_CHUNK_ID],\r\n9, tmp->chunk_count[SCTP_INIT_ACK_CHUNK_ID],\r\n10, tmp->chunk_count[SCTP_COOKIE_ECHO_CHUNK_ID],\r\n11, tmp->chunk_count[SCTP_COOKIE_ACK_CHUNK_ID],\r\n12, tmp->chunk_count[SCTP_ABORT_CHUNK_ID],\r\n13, tmp->chunk_count[SCTP_ERROR_CHUNK_ID],\r\n14, tmp->chunk_count[SCTP_NR_SACK_CHUNK_ID],\r\n15, tmp->chunk_count[SCTP_I_DATA_CHUNK_ID],\r\n16, tmp->chunk_count[SCTP_ASCONF_ACK_CHUNK_ID],\r\n17, tmp->chunk_count[SCTP_PKTDROP_CHUNK_ID],\r\n18, tmp->chunk_count[SCTP_FORWARD_TSN_CHUNK_ID],\r\n19, tmp->chunk_count[SCTP_ASCONF_CHUNK_ID],\r\n20, tmp->chunk_count[OTHER_CHUNKS_INDEX],\r\n-1\r\n);\r\nwmem_free(NULL, src_addr);\r\nwmem_free(NULL, dst_addr);\r\n}\r\n}\r\nstatic void\r\nwin_destroy_cb(GtkWindow *win _U_, gpointer data)\r\n{\r\nsctpstat_t *hs=(sctpstat_t *)data;\r\nremove_tap_listener(hs);\r\nif(hs->filter){\r\ng_free(hs->filter);\r\nhs->filter=NULL;\r\n}\r\ng_free(hs);\r\n}\r\nstatic void\r\nsctpstat_init(const char *opt_arg, void *userdata _U_)\r\n{\r\nsctpstat_t *hs;\r\nGString *error_string;\r\nGtkWidget *bbox;\r\nGtkWidget *close_bt;\r\nhs=(sctpstat_t *)g_malloc(sizeof(sctpstat_t));\r\nif(strncmp(opt_arg,"sctp,stat,",10) == 0){\r\nhs->filter=g_strdup(opt_arg+10);\r\n} else {\r\nhs->filter=NULL;\r\n}\r\nhs->ep_list = NULL;\r\nhs->number_of_packets = 0;\r\nsctpstat_reset(hs);\r\nhs->win = dlg_window_new("Wireshark: SCTP Chunk Statistics");\r\ngtk_window_set_destroy_with_parent (GTK_WINDOW(hs->win), TRUE);\r\ngtk_window_set_default_size(GTK_WINDOW(hs->win), 700, 250);\r\nhs->vbox=ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 3, FALSE);\r\ngtk_container_set_border_width(GTK_CONTAINER(hs->vbox), 12);\r\ninit_main_stat_window(hs->win, hs->vbox, "SCTP Chunk Counter", hs->filter);\r\nhs->scrolled_window = scrolled_window_new(NULL, NULL);\r\nhs->table = create_stat_table(hs->scrolled_window, hs->vbox, 20, titles);\r\nerror_string=register_tap_listener("sctp", hs, hs->filter, 0,\r\nsctpstat_reset,\r\nsctpstat_packet,\r\nsctpstat_draw);\r\nif(error_string){\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", error_string->str);\r\ng_string_free(error_string, TRUE);\r\ng_free(hs->filter);\r\ng_free(hs);\r\nreturn;\r\n}\r\nbbox = dlg_button_row_new(GTK_STOCK_CLOSE, NULL);\r\ngtk_box_pack_end(GTK_BOX(hs->vbox), bbox, FALSE, FALSE, 0);\r\nclose_bt = (GtkWidget *)g_object_get_data(G_OBJECT(bbox), GTK_STOCK_CLOSE);\r\nwindow_set_cancel_button(hs->win, close_bt, window_cancel_button_cb);\r\ng_signal_connect(hs->win, "delete_event", G_CALLBACK(window_delete_event_cb), NULL);\r\ng_signal_connect(hs->win, "destroy", G_CALLBACK(win_destroy_cb), hs);\r\ngtk_widget_show_all(hs->win);\r\nwindow_present(hs->win);\r\ncf_retap_packets(&cfile);\r\n}\r\nvoid\r\nregister_tap_listener_sctpstat(void)\r\n{\r\nregister_param_stat(&sctp_stat_dlg, "Chunk Counter",\r\nREGISTER_STAT_GROUP_TELEPHONY_SCTP);\r\n}
