static mpa_state_t *\r\ninit_mpa_state(void)\r\n{\r\nmpa_state_t *state;\r\nstate = (mpa_state_t *) wmem_alloc0(wmem_file_scope(), sizeof(mpa_state_t));\r\nstate->revision = -1;\r\nreturn state;\r\n}\r\nstatic mpa_state_t *\r\nget_mpa_state(conversation_t *conversation)\r\n{\r\nif (conversation) {\r\nreturn (mpa_state_t*) conversation_get_proto_data(conversation,\r\nproto_iwarp_mpa);\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nstatic guint32\r\nget_first_marker_offset(mpa_state_t *state, struct tcpinfo *tcpinfo,\r\nguint8 endpoint)\r\n{\r\nguint32 offset = 0;\r\nif (tcpinfo->seq > state->minfo[endpoint].seq) {\r\noffset = (tcpinfo->seq - state->minfo[endpoint].seq)\r\n% MPA_MARKER_INTERVAL;\r\n}\r\nif (tcpinfo->seq < state->minfo[endpoint].seq) {\r\noffset = state->minfo[endpoint].seq\r\n+ (TCP_MAX_SEQ - tcpinfo->seq) % MPA_MARKER_INTERVAL;\r\n}\r\nreturn (MPA_MARKER_INTERVAL - offset) % MPA_MARKER_INTERVAL;\r\n}\r\nstatic guint32\r\nfpdu_total_length(struct tcpinfo *tcpinfo)\r\n{\r\nguint32 size = 0;\r\nif (tcpinfo->seq < tcpinfo->nxtseq) {\r\nsize = tcpinfo->nxtseq - tcpinfo->seq;\r\n}\r\nif (tcpinfo->seq >= tcpinfo->nxtseq) {\r\nsize = tcpinfo->nxtseq + (TCP_MAX_SEQ - tcpinfo->seq);\r\n}\r\nreturn size;\r\n}\r\nstatic guint32\r\nnumber_of_markers(mpa_state_t *state, struct tcpinfo *tcpinfo, guint8 endpoint)\r\n{\r\nguint32 size;\r\nguint32 offset;\r\nsize = fpdu_total_length(tcpinfo);\r\noffset = get_first_marker_offset(state, tcpinfo, endpoint);\r\nif (offset < size) {\r\nreturn ((size - offset) / MPA_MARKER_INTERVAL)+1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic tvbuff_t *\r\nremove_markers(tvbuff_t *tvb, packet_info *pinfo, guint32 marker_offset,\r\nguint32 num_markers, guint32 orig_length)\r\n{\r\nguint8 *mfree_buff = NULL;\r\nguint32 mfree_buff_length, tot_copy, cur_copy;\r\nguint32 source_offset;\r\ntvbuff_t *mfree_tvb = NULL;\r\nDISSECTOR_ASSERT(num_markers > 0);\r\nDISSECTOR_ASSERT(orig_length > MPA_MARKER_LEN * num_markers);\r\nDISSECTOR_ASSERT(tvb_captured_length(tvb) == orig_length);\r\nmfree_buff_length = orig_length - (MPA_MARKER_LEN * num_markers);\r\nmfree_buff = (guint8 *)wmem_alloc(pinfo->pool, mfree_buff_length);\r\ntot_copy = 0;\r\nsource_offset = 0;\r\ncur_copy = marker_offset;\r\nwhile (tot_copy < mfree_buff_length) {\r\ntvb_memcpy(tvb, mfree_buff+tot_copy, source_offset, cur_copy);\r\ntot_copy += cur_copy;\r\nsource_offset += cur_copy + MPA_MARKER_LEN;\r\ncur_copy = MIN(MPA_MARKER_INTERVAL, (mfree_buff_length - tot_copy));\r\n}\r\nmfree_tvb = tvb_new_child_real_data(tvb, mfree_buff, mfree_buff_length,\r\nmfree_buff_length);\r\nadd_new_data_source(pinfo, mfree_tvb, "FPDU without Markers");\r\nreturn mfree_tvb;\r\n}\r\nstatic gboolean\r\nis_mpa_req(tvbuff_t *tvb, packet_info *pinfo)\r\n{\r\nconversation_t *conversation = NULL;\r\nmpa_state_t *state = NULL;\r\nguint8 mcrres;\r\nif (tvb_get_ntoh64(tvb, 0) != MPA_REQ_REP_FRAME\r\n|| tvb_get_ntoh64(tvb, 8) != MPA_ID_REQ_FRAME)\r\nreturn FALSE;\r\nconversation = find_or_create_conversation(pinfo);\r\nif (!get_mpa_state(conversation)) {\r\nstate = init_mpa_state();\r\nmcrres = tvb_get_guint8(tvb, 16);\r\nstate->ini_exp_m_res = mcrres & MPA_MARKER_FLAG;\r\nstate->crc = mcrres & MPA_CRC_FLAG;\r\nstate->revision = tvb_get_guint8(tvb, 17);\r\nstate->req_frame_num = pinfo->num;\r\nstate->minfo[MPA_INITIATOR].port = pinfo->srcport;\r\nstate->minfo[MPA_RESPONDER].port = pinfo->destport;\r\nconversation_add_proto_data(conversation, proto_iwarp_mpa, state);\r\nif (mcrres & MPA_RESERVED_FLAG)\r\nexpert_add_info(pinfo, NULL, &ei_mpa_res_field_not_set0);\r\nif (state->revision != 1)\r\nexpert_add_info(pinfo, NULL, &ei_mpa_rev_field_not_set1);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nis_mpa_rep(tvbuff_t *tvb, packet_info *pinfo)\r\n{\r\nconversation_t *conversation = NULL;\r\nmpa_state_t *state = NULL;\r\nguint8 mcrres;\r\nif (tvb_get_ntoh64(tvb, 0) != MPA_REQ_REP_FRAME\r\n|| tvb_get_ntoh64(tvb, 8) != MPA_ID_REP_FRAME) {\r\nreturn FALSE;\r\n}\r\nconversation = find_conversation(pinfo->num, &pinfo->src,\r\n&pinfo->dst, pinfo->ptype, pinfo->srcport,\r\npinfo->destport, 0);\r\nif (!conversation) {\r\nreturn FALSE;\r\n}\r\nstate = get_mpa_state(conversation);\r\nif (!state) {\r\nreturn FALSE;\r\n}\r\nif (!state->full_operation) {\r\nmcrres = tvb_get_guint8(tvb, 16);\r\nstate->res_exp_m_ini = mcrres & MPA_MARKER_FLAG;\r\nstate->crc = state->crc | (mcrres & MPA_CRC_FLAG);\r\nstate->rep_frame_num = pinfo->num;\r\nif (!(mcrres & MPA_REJECT_FLAG))\r\nstate->full_operation = TRUE;\r\nelse\r\nexpert_add_info(pinfo, NULL, &ei_mpa_reject_bit_responder);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nis_mpa_fpdu(packet_info *pinfo)\r\n{\r\nconversation_t *conversation = NULL;\r\nmpa_state_t *state = NULL;\r\nconversation = find_conversation(pinfo->num, &pinfo->src,\r\n&pinfo->dst, pinfo->ptype, pinfo->srcport,\r\npinfo->destport, 0);\r\nif (!conversation) {\r\nreturn FALSE;\r\n}\r\nstate = get_mpa_state(conversation);\r\nif (!state) {\r\nreturn FALSE;\r\n}\r\nif (!state->full_operation) {\r\nreturn FALSE;\r\n}\r\nif (pinfo->num == state->req_frame_num\r\n|| pinfo->num == state->rep_frame_num) {\r\nreturn FALSE;\r\n} else {\r\nreturn TRUE;\r\n}\r\n}\r\nstatic void\r\nmpa_packetlist(packet_info *pinfo, gint message_type)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MPA");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"%d > %d %s", pinfo->srcport, pinfo->destport,\r\nval_to_str(message_type, mpa_messages,\r\n"Unknown %d"));\r\n}\r\nstatic gboolean\r\ndissect_mpa_req_rep(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint message_type)\r\n{\r\nproto_tree *mpa_tree = NULL;\r\nproto_tree *mpa_header_tree = NULL;\r\nproto_item *mpa_item = NULL;\r\nproto_item *mpa_header_item = NULL;\r\nguint16 pd_length;\r\nguint32 offset = 0;\r\nmpa_packetlist(pinfo, message_type);\r\nif (tree) {\r\nmpa_item = proto_tree_add_item(tree, proto_iwarp_mpa, tvb, 0,\r\n-1, ENC_NA);\r\nmpa_tree = proto_item_add_subtree(mpa_item, ett_mpa);\r\nif (message_type == MPA_REQUEST_FRAME) {\r\nmpa_header_item = proto_tree_add_item(mpa_tree,\r\nhf_mpa_req, tvb, offset, -1, ENC_NA);\r\nmpa_header_tree = proto_item_add_subtree(\r\nmpa_header_item, ett_mpa);\r\nproto_tree_add_item(mpa_header_tree, hf_mpa_key_req,\r\ntvb, offset, MPA_REQ_REP_KEY_LEN, ENC_NA);\r\n}\r\nif (message_type == MPA_REPLY_FRAME) {\r\nmpa_header_item = proto_tree_add_item(mpa_tree,\r\nhf_mpa_rep, tvb, offset, -1, ENC_NA);\r\nmpa_header_tree = proto_item_add_subtree(\r\nmpa_header_item, ett_mpa);\r\nproto_tree_add_item(mpa_header_tree, hf_mpa_key_rep,\r\ntvb, offset, MPA_REQ_REP_KEY_LEN, ENC_NA);\r\n}\r\noffset += MPA_REQ_REP_KEY_LEN;\r\nproto_tree_add_item(mpa_header_tree, hf_mpa_flag_m, tvb,\r\noffset, MPA_REQ_REP_FLAG_LEN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mpa_header_tree, hf_mpa_flag_c, tvb,\r\noffset, MPA_REQ_REP_FLAG_LEN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mpa_header_tree, hf_mpa_flag_r, tvb,\r\noffset, MPA_REQ_REP_FLAG_LEN, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mpa_header_tree, hf_mpa_flag_res, tvb,\r\noffset, MPA_REQ_REP_FLAG_LEN, ENC_BIG_ENDIAN);\r\noffset += MPA_REQ_REP_FLAG_LEN;\r\nproto_tree_add_item(mpa_header_tree, hf_mpa_rev, tvb,\r\noffset, MPA_REQ_REP_REV_LEN, ENC_BIG_ENDIAN);\r\noffset += MPA_REQ_REP_REV_LEN;\r\npd_length = tvb_get_ntohs(tvb, offset);\r\nif (pd_length > MPA_MAX_PD_LENGTH) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_mpa_bad_length, tvb, offset, 2,\r\n"[PD length field indicates more 512 bytes of Private Data]");\r\nreturn FALSE;\r\n}\r\nproto_tree_add_uint_format_value(mpa_header_tree,\r\nhf_mpa_pd_length, tvb, offset,\r\nMPA_REQ_REP_PDLENGTH_LEN, pd_length, "%u bytes",\r\npd_length);\r\noffset += MPA_REQ_REP_PDLENGTH_LEN;\r\nif (pd_length) {\r\nproto_tree_add_item(mpa_header_tree,\r\nhf_mpa_private_data, tvb, offset,\r\npd_length, ENC_NA);\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic guint8\r\nfpdu_pad_length(guint16 ulpdu_length)\r\n{\r\nguint32 length = ulpdu_length + MPA_ULPDU_LENGTH_LEN;\r\nreturn (MPA_ALIGNMENT - (length % MPA_ALIGNMENT)) % MPA_ALIGNMENT;\r\n}\r\nstatic guint32\r\npad_offset(struct tcpinfo *tcpinfo, guint32 fpdu_total_len,\r\nguint8 pad_len)\r\n{\r\nif ((tcpinfo->nxtseq - MPA_CRC_LEN - MPA_MARKER_LEN) % MPA_MARKER_INTERVAL\r\n== 0) {\r\nreturn fpdu_total_len - MPA_CRC_LEN - MPA_MARKER_LEN - pad_len;\r\n} else {\r\nreturn fpdu_total_len - MPA_CRC_LEN - pad_len;\r\n}\r\n}\r\nstatic void\r\ndissect_fpdu_crc(tvbuff_t *tvb, proto_tree *tree, mpa_state_t *state,\r\nguint32 offset, guint32 length)\r\n{\r\nguint32 crc = 0;\r\nguint32 sent_crc = 0;\r\nif (state->crc) {\r\ncrc = ~crc32c_tvb_offset_calculate(tvb, 0, length, CRC32C_PRELOAD);\r\nsent_crc = tvb_get_ntohl(tvb, offset);\r\nif (crc == sent_crc) {\r\nproto_tree_add_uint_format_value(tree,\r\nhf_mpa_crc_check, tvb, offset, MPA_CRC_LEN,\r\nsent_crc, "0x%08x (Good CRC32)",\r\nsent_crc);\r\n} else {\r\nproto_tree_add_uint_format_value(tree,\r\nhf_mpa_crc_check, tvb, offset, MPA_CRC_LEN,\r\nsent_crc,\r\n"0x%08x (Bad CRC32, should be 0x%08x)",\r\nsent_crc, crc);\r\n}\r\n} else {\r\nproto_tree_add_item(tree, hf_mpa_crc, tvb, offset, MPA_CRC_LEN,\r\nENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_fpdu_markers(tvbuff_t *tvb, proto_tree *tree, mpa_state_t *state,\r\nstruct tcpinfo *tcpinfo, guint8 endpoint)\r\n{\r\nproto_tree *mpa_marker_tree;\r\nproto_item *mpa_marker_item;\r\nguint16 fpduptr;\r\nguint32 offset, i;\r\nmpa_marker_item = proto_tree_add_item(tree, hf_mpa_marker, tvb,\r\n0, -1, ENC_NA);\r\nmpa_marker_tree = proto_item_add_subtree(mpa_marker_item, ett_mpa);\r\noffset = get_first_marker_offset(state, tcpinfo, endpoint);\r\nfor (i=0; i<number_of_markers(state, tcpinfo, endpoint); i++) {\r\nproto_tree_add_item(mpa_marker_tree, hf_mpa_marker_res, tvb,\r\noffset, MPA_MARKER_RSVD_LEN, ENC_BIG_ENDIAN);\r\nfpduptr = (guint16) tvb_get_ntohs(tvb, offset+MPA_MARKER_RSVD_LEN);\r\nproto_tree_add_uint_format_value(mpa_marker_tree,\r\nhf_mpa_marker_fpduptr, tvb,\r\noffset+MPA_MARKER_RSVD_LEN, MPA_MARKER_FPDUPTR_LEN,\r\nfpduptr, "%u bytes", fpduptr);\r\noffset += MPA_MARKER_INTERVAL;\r\n}\r\n}\r\nstatic guint16\r\nexpected_ulpdu_length(mpa_state_t *state, struct tcpinfo *tcpinfo,\r\nguint8 endpoint)\r\n{\r\nguint32 length, pad_length, markers_length;\r\nlength = fpdu_total_length(tcpinfo);\r\nif (length <= MPA_CRC_LEN)\r\nreturn 0;\r\nlength -= MPA_CRC_LEN;\r\npad_length = (MPA_ALIGNMENT - (length % MPA_ALIGNMENT)) % MPA_ALIGNMENT;\r\nif (length <= pad_length)\r\nreturn 0;\r\nlength -= pad_length;\r\nif (state->minfo[endpoint].valid) {\r\nmarkers_length =\r\nnumber_of_markers(state, tcpinfo, endpoint) * MPA_MARKER_LEN;\r\nif (length <= markers_length)\r\nreturn 0;\r\nlength -= markers_length;\r\n}\r\nif (length <= MPA_ULPDU_LENGTH_LEN)\r\nreturn 0;\r\nlength -= MPA_ULPDU_LENGTH_LEN;\r\nreturn (guint16) length;\r\n}\r\nstatic guint16\r\ndissect_mpa_fpdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nmpa_state_t *state, struct tcpinfo *tcpinfo, guint8 endpoint)\r\n{\r\nproto_item *mpa_item = NULL;\r\nproto_item *mpa_header_item = NULL;\r\nproto_tree *mpa_tree = NULL;\r\nproto_tree *mpa_header_tree = NULL;\r\nguint8 pad_length;\r\nguint16 ulpdu_length, exp_ulpdu_length;\r\nguint32 offset, total_length;\r\nguint32 num_of_m = 0;\r\nif (state->minfo[endpoint].valid\r\n&& get_first_marker_offset(state, tcpinfo, endpoint) == 0) {\r\noffset = MPA_MARKER_LEN;\r\n} else {\r\noffset = 0;\r\n}\r\nulpdu_length = (guint16) tvb_get_ntohs(tvb, offset);\r\nmpa_packetlist(pinfo, MPA_FPDU);\r\nif (state->minfo[endpoint].valid) {\r\nnum_of_m = number_of_markers(state, tcpinfo, endpoint);\r\n}\r\nif (tree) {\r\npad_length = fpdu_pad_length(ulpdu_length);\r\nexp_ulpdu_length = expected_ulpdu_length(state, tcpinfo, endpoint);\r\nif (!exp_ulpdu_length || exp_ulpdu_length != (ulpdu_length + pad_length)) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_mpa_bad_length, tvb, offset,\r\nMPA_ULPDU_LENGTH_LEN,\r\n"[ULPDU length [%u] field does not contain the expected length[%u]]",\r\nexp_ulpdu_length, ulpdu_length + pad_length);\r\n}\r\nmpa_item = proto_tree_add_item(tree, proto_iwarp_mpa, tvb, 0,\r\n-1, ENC_NA);\r\nmpa_tree = proto_item_add_subtree(mpa_item, ett_mpa);\r\nmpa_header_item = proto_tree_add_item(mpa_tree, hf_mpa_fpdu,\r\ntvb, offset, -1, ENC_NA);\r\nmpa_header_tree = proto_item_add_subtree(mpa_header_item,\r\nett_mpa);\r\nproto_tree_add_uint_format_value(mpa_header_tree,\r\nhf_mpa_ulpdu_length, tvb, offset,\r\nMPA_ULPDU_LENGTH_LEN, ulpdu_length, "%u bytes",\r\nulpdu_length);\r\nif (state->minfo[endpoint].valid && num_of_m > 0) {\r\ntotal_length = fpdu_total_length(tcpinfo);\r\nif (pad_length > 0) {\r\nproto_tree_add_item(mpa_header_tree, hf_mpa_pad,\r\ntvb, pad_offset(tcpinfo,\r\ntotal_length,\r\npad_length),\r\npad_length, ENC_NA);\r\n}\r\ndissect_fpdu_crc(tvb, mpa_header_tree, state,\r\ntotal_length-MPA_CRC_LEN, num_of_m * MPA_MARKER_LEN +\r\nulpdu_length + pad_length + MPA_ULPDU_LENGTH_LEN);\r\ndissect_fpdu_markers(tvb, mpa_tree, state, tcpinfo, endpoint);\r\n} else {\r\noffset += MPA_ULPDU_LENGTH_LEN + ulpdu_length;\r\nif (pad_length > 0) {\r\nproto_tree_add_item(mpa_header_tree, hf_mpa_pad, tvb, offset,\r\npad_length, ENC_NA);\r\noffset += pad_length;\r\n}\r\ndissect_fpdu_crc(tvb, mpa_header_tree, state, offset,\r\nulpdu_length+pad_length+MPA_ULPDU_LENGTH_LEN);\r\n}\r\n}\r\nreturn ulpdu_length;\r\n}\r\nstatic gboolean\r\ndissect_iwarp_mpa(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\ntvbuff_t *next_tvb = NULL;\r\nconversation_t *conversation = NULL;\r\nmpa_state_t *state = NULL;\r\nstruct tcpinfo *tcpinfo;\r\nguint8 endpoint = 3;\r\nguint16 ulpdu_length = 0;\r\nif (data == NULL)\r\nreturn FALSE;\r\ntcpinfo = (struct tcpinfo *)data;\r\nif (tvb_captured_length(tvb) >= MPA_SMALLEST_FPDU_LEN && is_mpa_fpdu(pinfo)) {\r\nconversation = find_conversation(pinfo->num, &pinfo->src,\r\n&pinfo->dst, pinfo->ptype, pinfo->srcport, pinfo->destport, 0);\r\nstate = get_mpa_state(conversation);\r\nif (pinfo->srcport == state->minfo[MPA_INITIATOR].port) {\r\nendpoint = MPA_INITIATOR;\r\n} else if (pinfo->srcport == state->minfo[MPA_RESPONDER].port) {\r\nendpoint = MPA_RESPONDER;\r\n} else {\r\nREPORT_DISSECTOR_BUG("endpoint cannot be determined");\r\n}\r\nif ((state->ini_exp_m_res || state->res_exp_m_ini) && endpoint <= MPA_RESPONDER) {\r\nif (!state->minfo[endpoint].valid) {\r\nstate->minfo[endpoint].seq = tcpinfo->seq;\r\nstate->minfo[endpoint].valid = TRUE;\r\n}\r\n}\r\nulpdu_length = dissect_mpa_fpdu(tvb, pinfo, tree, state, tcpinfo,\r\nendpoint);\r\nif (!ulpdu_length)\r\nreturn FALSE;\r\nif (endpoint <= MPA_RESPONDER && state->minfo[endpoint].valid\r\n&& number_of_markers(state, tcpinfo, endpoint) > 0) {\r\nnext_tvb = tvb_new_subset_length(remove_markers(tvb, pinfo,\r\nget_first_marker_offset(state, tcpinfo, endpoint),\r\nnumber_of_markers(state, tcpinfo, endpoint),\r\nfpdu_total_length(tcpinfo)), MPA_ULPDU_LENGTH_LEN,\r\nulpdu_length);\r\n} else {\r\nnext_tvb = tvb_new_subset_length(tvb, MPA_ULPDU_LENGTH_LEN, ulpdu_length);\r\n}\r\nif (ddp_rdmap_handle) {\r\ncall_dissector(ddp_rdmap_handle, next_tvb, pinfo, tree);\r\n} else {\r\nREPORT_DISSECTOR_BUG("ddp_handle was null");\r\n}\r\nreturn TRUE;\r\n}\r\nif (tvb_captured_length(tvb) >= MPA_REQ_REP_FRAME_HEADER_LEN) {\r\nif (is_mpa_req(tvb, pinfo))\r\nreturn dissect_mpa_req_rep(tvb, pinfo, tree, MPA_REQUEST_FRAME);\r\nelse if (is_mpa_rep(tvb, pinfo))\r\nreturn dissect_mpa_req_rep(tvb, pinfo, tree, MPA_REPLY_FRAME);\r\n}\r\nreturn FALSE;\r\n}\r\nvoid proto_register_mpa(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_mpa_req, {\r\n"Request frame header", "iwarp_mpa.req",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_rep, {\r\n"Reply frame header", "iwarp_mpa.rep",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_fpdu, {\r\n"FPDU", "iwarp_mpa.fpdu",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_marker, {\r\n"Markers", "iwarp_mpa.markers",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_key_req, {\r\n"ID Req frame", "iwarp_mpa.key.req",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_key_rep, {\r\n"ID Rep frame", "iwarp_mpa.key.rep",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_flag_m, {\r\n"Marker flag", "iwarp_mpa.marker_flag",\r\nFT_BOOLEAN, 8, NULL, MPA_MARKER_FLAG,\r\nNULL, HFILL } },\r\n{ &hf_mpa_flag_c, {\r\n"CRC flag", "iwarp_mpa.crc_flag",\r\nFT_BOOLEAN, 8, NULL, MPA_CRC_FLAG,\r\nNULL, HFILL } },\r\n{ &hf_mpa_flag_r, {\r\n"Connection rejected flag",\r\n"iwarp_mpa.rej_flag", FT_BOOLEAN, 8, NULL, MPA_REJECT_FLAG,\r\nNULL, HFILL } },\r\n{ &hf_mpa_flag_res, {\r\n"Reserved", "iwarp_mpa.res",\r\nFT_UINT8, BASE_HEX, NULL, MPA_RESERVED_FLAG,\r\nNULL, HFILL } },\r\n{ &hf_mpa_rev, {\r\n"Revision", "iwarp_mpa.rev",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_pd_length, {\r\n"Private data length", "iwarp_mpa.pdlength",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_private_data, {\r\n"Private data", "iwarp_mpa.privatedata",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_ulpdu_length, {\r\n"ULPDU length", "iwarp_mpa.ulpdulength",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_pad, {\r\n"Padding", "iwarp_mpa.pad",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_crc, {\r\n"CRC", "iwarp_mpa.crc",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_crc_check, {\r\n"CRC check", "iwarp_mpa.crc_check",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_mpa_marker_res, {\r\n"Reserved", "iwarp_mpa.marker_res",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Marker: Reserved", HFILL } },\r\n{ &hf_mpa_marker_fpduptr, {\r\n"FPDU back pointer", "iwarp_mpa.marker_fpduptr",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Marker: FPDU Pointer", HFILL } }\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mpa,\r\n&ett_mpa_req,\r\n&ett_mpa_rep,\r\n&ett_mpa_fpdu,\r\n&ett_mpa_marker\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_mpa_res_field_not_set0, { "iwarp_mpa.res.not_set0", PI_REQUEST_CODE, PI_WARN, "Res field is NOT set to zero as required by RFC 5044", EXPFILL }},\r\n{ &ei_mpa_rev_field_not_set1, { "iwarp_mpa.rev.not_set1", PI_REQUEST_CODE, PI_WARN, "Rev field is NOT set to one as required by RFC 5044", EXPFILL }},\r\n{ &ei_mpa_reject_bit_responder, { "iwarp_mpa.reject_bit_responder", PI_RESPONSE_CODE, PI_NOTE, "Reject bit set by Responder", EXPFILL }},\r\n{ &ei_mpa_bad_length, { "iwarp_mpa.bad_length", PI_MALFORMED, PI_ERROR, "Bad length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_iwarp_mpa;\r\nproto_iwarp_mpa = proto_register_protocol(\r\n"iWARP Marker Protocol data unit Aligned framing",\r\n"IWARP_MPA", "iwarp_mpa");\r\nproto_register_field_array(proto_iwarp_mpa, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_iwarp_mpa = expert_register_protocol(proto_iwarp_mpa);\r\nexpert_register_field_array(expert_iwarp_mpa, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_mpa(void)\r\n{\r\nheur_dissector_add("tcp", dissect_iwarp_mpa, "IWARP_MPA over TCP", "iwarp_mpa_tcp", proto_iwarp_mpa, HEURISTIC_ENABLE);\r\nddp_rdmap_handle = find_dissector_add_dependency("iwarp_ddp_rdmap", proto_iwarp_mpa);\r\n}
