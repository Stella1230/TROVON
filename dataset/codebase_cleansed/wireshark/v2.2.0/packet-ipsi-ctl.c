static int dissect_ipsictl(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *ipsictl_tree;\r\nproto_tree *pdu_tree;\r\nproto_item *ti;\r\nint offset = 0;\r\nint loffset = 0;\r\nint llength = 0;\r\nint remaining_length;\r\nguint16 magic;\r\nguint16 length;\r\nguint16 type=0;\r\nguint16 sequence=0;\r\nint first_sequence=-1;\r\nint last_sequence=-1;\r\nguint16 field1=0;\r\nguint16 pdu=0;\r\nint haspdus=0;\r\nremaining_length=tvb_reported_length_remaining(tvb, offset);\r\nti = proto_tree_add_item(tree, proto_ipsictl, tvb, offset, remaining_length, ENC_NA);\r\nipsictl_tree = proto_item_add_subtree(ti, ett_ipsictl);\r\nmagic = tvb_get_ntohs(tvb, offset);\r\nif (magic == IPSICTL_PDU_MAGIC)\r\n{\r\nhaspdus=1;\r\n}\r\nwhile (haspdus &&\r\n((remaining_length=tvb_reported_length_remaining(tvb, offset)) > 6))\r\n{\r\nloffset = offset;\r\nmagic = tvb_get_ntohs(tvb, loffset); loffset+=2;\r\nlength = tvb_get_ntohs(tvb, loffset); loffset+=2;\r\nllength=length;\r\nremaining_length-=4;\r\nif (remaining_length>=2)\r\n{\r\ntype = tvb_get_ntohs(tvb, loffset); loffset+=2;\r\nremaining_length-=2;\r\nllength-=2;\r\n}\r\nif (remaining_length>=2)\r\n{\r\nsequence = tvb_get_ntohs(tvb, loffset); loffset+=2;\r\nremaining_length-=2;\r\nllength-=2;\r\nif (first_sequence==-1)\r\n{\r\nfirst_sequence=sequence;\r\n}else{\r\nlast_sequence=sequence;\r\n}\r\n}\r\nif (remaining_length>=2)\r\n{\r\nfield1 = tvb_get_ntohs(tvb, loffset);\r\nllength-=2;\r\n}\r\nti = proto_tree_add_uint(ipsictl_tree, hf_ipsictl_pdu, tvb,\r\noffset, (length+4), pdu);\r\npdu_tree = proto_item_add_subtree(ti, ett_ipsictl_pdu);\r\nloffset=offset;\r\nremaining_length=tvb_reported_length_remaining(tvb, offset);\r\nif (tree) {\r\nproto_tree_add_uint(pdu_tree, hf_ipsictl_magic, tvb, loffset, 2, magic);\r\n}\r\nloffset+=2; remaining_length-=2;\r\nif (tree) {\r\nproto_tree_add_uint(pdu_tree, hf_ipsictl_length, tvb, loffset, 2, length);\r\n}\r\nloffset+=2; remaining_length-=2;\r\nif (remaining_length>=2)\r\n{\r\nif (tree) {\r\nproto_tree_add_uint(pdu_tree, hf_ipsictl_type, tvb, loffset, 2, type);\r\n}\r\nloffset+=2; remaining_length-=2;\r\n}\r\nif (remaining_length>=2)\r\n{\r\nif (tree) {\r\nproto_tree_add_uint(pdu_tree, hf_ipsictl_sequence, tvb, loffset, 2, sequence);\r\n}\r\nloffset+=2; remaining_length-=2;\r\n}\r\nif (remaining_length>=2)\r\n{\r\nif (tree) {\r\nproto_tree_add_uint(pdu_tree, hf_ipsictl_field1, tvb, loffset, 2, field1);\r\n}\r\nloffset+=2; remaining_length-=2;\r\n}\r\nif (remaining_length>=2)\r\n{\r\nif (tree) {\r\nproto_tree_add_item(pdu_tree, hf_ipsictl_data, tvb, loffset, llength, ENC_NA);\r\n}\r\nloffset+=llength;\r\n}\r\noffset=loffset;\r\npdu++;\r\n}\r\nif (!haspdus)\r\n{\r\nproto_tree_add_item(ipsictl_tree, hf_ipsictl_data, tvb, offset, -1, ENC_NA);\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IPSICTL");\r\nif (haspdus)\r\n{\r\nif (last_sequence==-1)\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "PDUS=%d, Seq=0x%04x",\r\npdu,first_sequence);\r\n}else{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "PDUS=%d, Seq=0x%04x-0x%04x",\r\npdu,first_sequence,last_sequence);\r\n}\r\n}else{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Initialization");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_ipsictl(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipsictl_pdu,\r\n{ "PDU", "ipsictl.pdu",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"IPSICTL PDU", HFILL }},\r\n{ &hf_ipsictl_magic,\r\n{ "Magic", "ipsictl.magic",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"IPSICTL Magic", HFILL }},\r\n{ &hf_ipsictl_length,\r\n{ "Length", "ipsictl.length",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"IPSICTL Length", HFILL }},\r\n{ &hf_ipsictl_type,\r\n{ "Type", "ipsictl.type",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"IPSICTL Type", HFILL }},\r\n{ &hf_ipsictl_sequence,\r\n{ "Sequence", "ipsictl.sequence",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"IPSICTL Sequence", HFILL }},\r\n{ &hf_ipsictl_field1,\r\n{ "Field1", "ipsictl.field1",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"IPSICTL Field1", HFILL }},\r\n{ &hf_ipsictl_data,\r\n{ "Data", "ipsictl.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"IPSICTL data", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipsictl,\r\n&ett_ipsictl_pdu\r\n};\r\nproto_ipsictl = proto_register_protocol("IPSICTL", "IPSICTL", "ipsictl");\r\nproto_register_field_array(proto_ipsictl, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid proto_reg_handoff_ipsictl(void)\r\n{\r\ndissector_handle_t ipsictl_handle = NULL;\r\nipsictl_handle = create_dissector_handle(dissect_ipsictl, proto_ipsictl);\r\ndissector_add_uint("tcp.port", IPSICTL_PORT, ipsictl_handle);\r\n}
