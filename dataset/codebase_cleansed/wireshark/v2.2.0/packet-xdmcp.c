static gint xdmcp_add_string(proto_tree *tree, gint hf,\r\ntvbuff_t *tvb, gint offset)\r\n{\r\nchar *str;\r\nguint len;\r\nlen = tvb_get_ntohs(tvb, offset);\r\nstr = tvb_get_string_enc(wmem_packet_scope(), tvb, offset+2, len, ENC_ASCII);\r\nproto_tree_add_string(tree, hf, tvb, offset, len+2, str);\r\nreturn len+2;\r\n}\r\nstatic gint xdmcp_add_bytes(proto_tree *tree, gint hf_byte, gint hf_length,\r\ntvbuff_t *tvb, gint offset)\r\n{\r\nguint len;\r\nlen = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_byte, tvb, offset, len+2, ENC_NA);\r\nreturn len+2;\r\n}\r\nstatic gint xdmcp_add_authentication_names(proto_tree *tree,\r\ntvbuff_t *tvb, gint offset)\r\n{\r\nproto_tree *anames_tree;\r\nproto_item *anames_ti;\r\ngint anames_len, anames_start_offset;\r\nanames_start_offset = offset;\r\nanames_len = tvb_get_guint8(tvb, offset);\r\nanames_tree = proto_tree_add_subtree_format(tree, tvb,\r\nanames_start_offset, -1,\r\nett_xdmcp_authentication_names, &anames_ti, "Authentication names (%d)",\r\nanames_len);\r\nanames_len = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nwhile (anames_len > 0) {\r\noffset += xdmcp_add_string(anames_tree, hf_xdmcp_authentication_name,\r\ntvb, offset);\r\nanames_len--;\r\n}\r\nproto_item_set_len(anames_ti, offset - anames_start_offset);\r\nreturn offset - anames_start_offset;\r\n}\r\nstatic gint xdmcp_add_authorization_names(proto_tree *tree,\r\ntvbuff_t *tvb, gint offset)\r\n{\r\nproto_tree *anames_tree;\r\nproto_item *anames_ti;\r\ngint anames_len, anames_start_offset;\r\nanames_start_offset = offset;\r\nanames_len = tvb_get_guint8(tvb, offset);\r\nanames_tree = proto_tree_add_subtree_format(tree, tvb,\r\nanames_start_offset, -1,\r\nett_xdmcp_authorization_names, &anames_ti, "Authorization names (%d)",\r\nanames_len);\r\nanames_len = tvb_get_guint8(tvb, offset);\r\noffset++;\r\nwhile (anames_len > 0) {\r\noffset += xdmcp_add_string(anames_tree, hf_xdmcp_authorization_name,\r\ntvb, offset);\r\nanames_len--;\r\n}\r\nproto_item_set_len(anames_ti, offset - anames_start_offset);\r\nreturn offset - anames_start_offset;\r\n}\r\nstatic int dissect_xdmcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ngint version = -1, opcode = -1;\r\ngint offset = 0;\r\nproto_item *ti;\r\nproto_tree *xdmcp_tree = 0;\r\nversion = tvb_get_ntohs(tvb, offset);\r\nif (version != XDMCP_PROTOCOL_VERSION) {\r\nreturn offset;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "XDMCP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_xdmcp, tvb, offset, -1, ENC_NA);\r\nxdmcp_tree = proto_item_add_subtree(ti, ett_xdmcp);\r\nproto_tree_add_uint(xdmcp_tree, hf_xdmcp_version, tvb,\r\noffset, 2, version);\r\noffset += 2;\r\nopcode = tvb_get_ntohs(tvb, offset);\r\nif (tree) {\r\nproto_tree_add_uint(xdmcp_tree, hf_xdmcp_opcode, tvb,\r\noffset, 2, opcode);\r\n}\r\noffset += 2;\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(opcode, opcode_vals, "Unknown (0x%04x)"));\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_length, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nswitch (opcode) {\r\ncase XDMCP_FORWARD_QUERY:\r\n{\r\ngint alen, plen;\r\nalen = tvb_get_ntohs(tvb, offset);\r\nif (alen == 4) {\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_client_address_ipv4, tvb, offset+2, alen, ENC_BIG_ENDIAN);\r\noffset += 6;\r\n} else if (alen == 16) {\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_client_address_ipv6, tvb, offset+2, alen, ENC_NA);\r\noffset += 18;\r\n} else {\r\noffset += xdmcp_add_bytes(xdmcp_tree, hf_xdmcp_client_address_bytes, hf_xdmcp_client_address_bytes_len,\r\ntvb, offset);\r\n}\r\nplen = tvb_get_ntohs(tvb, offset);\r\nif (plen == 2) {\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_client_port_u16, tvb, offset+2, plen, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else {\r\noffset += xdmcp_add_bytes(xdmcp_tree, hf_xdmcp_client_port_bytes, hf_xdmcp_client_port_len,\r\ntvb, offset);\r\n}\r\n}\r\ncase XDMCP_BROADCAST_QUERY:\r\ncase XDMCP_QUERY:\r\ncase XDMCP_INDIRECT_QUERY:\r\noffset += xdmcp_add_authentication_names(xdmcp_tree, tvb, offset);\r\nbreak;\r\ncase XDMCP_WILLING:\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_authentication_name,\r\ntvb, offset);\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_hostname,\r\ntvb, offset);\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_status,\r\ntvb, offset);\r\nbreak;\r\ncase XDMCP_UNWILLING:\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_hostname,\r\ntvb, offset);\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_status,\r\ntvb, offset);\r\nbreak;\r\ncase XDMCP_REQUEST:\r\n{\r\nproto_tree *clist_tree;\r\nproto_item *clist_ti;\r\ngint ctypes_len, caddrs_len, n;\r\ngint ctypes_start_offset, caddrs_offset;\r\nti = proto_tree_add_item(xdmcp_tree, hf_xdmcp_display_number, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nctypes_len = tvb_get_guint8(tvb, offset);\r\nctypes_start_offset = offset;\r\ncaddrs_offset = offset + 1 + 2*ctypes_len;\r\ncaddrs_len = tvb_get_guint8(tvb, caddrs_offset);\r\nif (ctypes_len != caddrs_len) {\r\nexpert_add_info(pinfo, ti, &ei_xdmcp_conn_address_mismatch);\r\nreturn offset;\r\n}\r\nclist_tree = proto_tree_add_subtree_format(xdmcp_tree,\r\ntvb, ctypes_start_offset, -1,\r\nett_xdmcp_connections, &clist_ti, "Connections (%d)",\r\nctypes_len);\r\noffset++;\r\ncaddrs_offset++;\r\nn = 1;\r\nwhile (ctypes_len > 0) {\r\nproto_item *connection_ti;\r\nproto_tree *connection_tree;\r\ngint alen;\r\ngint ctype = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nalen = tvb_get_ntohs(tvb, caddrs_offset);\r\ncaddrs_offset += 2;\r\nconnection_tree = proto_tree_add_subtree_format(clist_tree, NULL, 0, 0,\r\nett_xdmcp_connection, &connection_ti, "Connection %d", n);\r\nproto_tree_add_item(connection_tree, hf_xdmcp_connection_type, tvb, offset-2, 2, ENC_BIG_ENDIAN);\r\nif ((ctype == 0) && (alen == 4)) {\r\nproto_tree_add_item(connection_tree, hf_xdmcp_connection_address_ipv4, tvb, caddrs_offset, alen, ENC_BIG_ENDIAN);\r\nproto_item_append_text(connection_ti, ": %s", tvb_ip_to_str(tvb, caddrs_offset));\r\n} else if ((ctype == 6) && (alen == 16)) {\r\nproto_tree_add_item(connection_tree, hf_xdmcp_connection_address_ipv6, tvb, caddrs_offset, alen, ENC_NA);\r\nproto_item_append_text(connection_ti, ": %s", tvb_ip6_to_str(tvb, caddrs_offset));\r\n} else {\r\nproto_tree_add_item(connection_tree, hf_xdmcp_connection_address_bytes, tvb, caddrs_offset, alen, ENC_NA);\r\n}\r\ncaddrs_offset += alen;\r\nctypes_len--;\r\nn++;\r\n}\r\noffset = caddrs_offset;\r\nproto_item_set_len(clist_ti, offset - ctypes_start_offset);\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_authentication_name,\r\ntvb, offset);\r\noffset += xdmcp_add_bytes(xdmcp_tree, hf_xdmcp_authentication_data, hf_xdmcp_authentication_data_len,\r\ntvb, offset);\r\noffset += xdmcp_add_authorization_names(xdmcp_tree, tvb, offset);\r\noffset += xdmcp_add_bytes(xdmcp_tree, hf_xdmcp_manufacturer_display_id, hf_xdmcp_manufacturer_display_id_len,\r\ntvb, offset);\r\nbreak;\r\n}\r\ncase XDMCP_ACCEPT:\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_session_id, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_authentication_name,\r\ntvb, offset);\r\noffset += xdmcp_add_bytes(xdmcp_tree, hf_xdmcp_authentication_data, hf_xdmcp_authentication_data_len,\r\ntvb, offset);\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_authorization_name,\r\ntvb, offset);\r\noffset += xdmcp_add_bytes(xdmcp_tree, hf_xdmcp_authorization_data, hf_xdmcp_authorization_data_len,\r\ntvb, offset);\r\nbreak;\r\ncase XDMCP_DECLINE:\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_status,\r\ntvb, offset);\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_authentication_name,\r\ntvb, offset);\r\noffset += xdmcp_add_bytes(xdmcp_tree, hf_xdmcp_authentication_data, hf_xdmcp_authentication_data_len,\r\ntvb, offset);\r\nbreak;\r\ncase XDMCP_MANAGE:\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_session_id, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_display_number, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\noffset += xdmcp_add_bytes(xdmcp_tree, hf_xdmcp_display_class, hf_xdmcp_display_class_len,\r\ntvb, offset);\r\nbreak;\r\ncase XDMCP_REFUSE:\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_session_id, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase XDMCP_FAILED:\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_session_id, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset += xdmcp_add_string(xdmcp_tree, hf_xdmcp_status,\r\ntvb, offset);\r\nbreak;\r\ncase XDMCP_KEEPALIVE:\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_display_number, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_session_id, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase XDMCP_ALIVE:\r\n{\r\nguint8 session_running = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint_format_value(xdmcp_tree, hf_xdmcp_session_running, tvb,\r\noffset, 1, session_running, "%s", session_running ? "Yes" : "No");\r\noffset++;\r\nproto_tree_add_item(xdmcp_tree, hf_xdmcp_session_id, tvb,\r\noffset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nvoid proto_register_xdmcp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_xdmcp_version,\r\n{ "Version", "xdmcp.version",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Protocol version", HFILL }\r\n},\r\n{ &hf_xdmcp_opcode,\r\n{ "Opcode", "xdmcp.opcode",\r\nFT_UINT16, BASE_HEX, VALS(opcode_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_length,\r\n{ "Message length", "xdmcp.length",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Length of the remaining message", HFILL }\r\n},\r\n{ &hf_xdmcp_authentication_name,\r\n{ "Authentication name", "xdmcp.authentication_name",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_authorization_name,\r\n{ "Authorization name", "xdmcp.authorization_name",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_hostname,\r\n{ "Hostname", "xdmcp.hostname",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_status,\r\n{ "Status", "xdmcp.status",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_session_id,\r\n{ "Session ID", "xdmcp.session_id",\r\nFT_UINT32, BASE_HEX, NULL, 0,\r\n"Session identifier", HFILL }\r\n},\r\n{ &hf_xdmcp_display_number,\r\n{ "Display number", "xdmcp.display_number",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_manufacturer_display_id_len,\r\n{ "Manufacturer display ID Length", "xdmcp.manufacturer_display_id_len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_manufacturer_display_id,\r\n{ "Manufacturer display ID", "xdmcp.manufacturer_display_id",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_display_class_len,\r\n{ "Display class Length", "xdmcp.display_class_len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_display_class,\r\n{ "Display class", "xdmcp.display_class",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_client_address_ipv4,\r\n{ "Client Address", "xdmcp.client_address_ipv4",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_client_address_ipv6,\r\n{ "Client Address", "xdmcp.client_address_ipv6",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_client_address_bytes,\r\n{ "Client Address", "xdmcp.client_address_bytes",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_client_address_bytes_len,\r\n{ "Client Address Length", "xdmcp.client_address_bytes_len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_client_port_len,\r\n{ "Client port Length", "xdmcp.client_port_len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_client_port_bytes,\r\n{ "Client port", "xdmcp.client_port_bytes",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_client_port_u16,\r\n{ "Client port", "xdmcp.client_port",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_authentication_data_len,\r\n{ "Authentication data Length", "xdmcp.authentication_data_len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_authentication_data,\r\n{ "Authentication data", "xdmcp.authentication_data",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_authorization_data_len,\r\n{ "Authorization data Length", "xdmcp.authorization_data_len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_authorization_data,\r\n{ "Authorization data", "xdmcp.authorization_data",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_connection_address_ipv4,\r\n{ "Address", "xdmcp.connection_address_ipv4",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_connection_address_ipv6,\r\n{ "Address", "xdmcp.connection_address_ipv6",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_connection_address_bytes,\r\n{ "Address", "xdmcp.connection_address_bytes",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_connection_type,\r\n{ "Type", "xdmcp.connection_type",\r\nFT_UINT16, BASE_HEX, VALS(family_vals), 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_xdmcp_session_running,\r\n{ "Session running", "xdmcp.session_running",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_xdmcp,\r\n&ett_xdmcp_authentication_names,\r\n&ett_xdmcp_authorization_names,\r\n&ett_xdmcp_connections,\r\n&ett_xdmcp_connection\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_xdmcp_conn_address_mismatch, { "xdmcp.conn_address_mismatch", PI_PROTOCOL, PI_WARN, "Error: Connection type/address arrays don't match", EXPFILL }},\r\n};\r\nexpert_module_t* expert_xdmcp;\r\nproto_xdmcp = proto_register_protocol("X Display Manager Control Protocol",\r\n"XDMCP", "xdmcp");\r\nproto_register_field_array(proto_xdmcp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_xdmcp = expert_register_protocol(proto_xdmcp);\r\nexpert_register_field_array(expert_xdmcp, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_xdmcp(void)\r\n{\r\ndissector_handle_t xdmcp_handle;\r\nxdmcp_handle = create_dissector_handle(dissect_xdmcp, proto_xdmcp);\r\ndissector_add_uint("udp.port", UDP_PORT_XDMCP, xdmcp_handle);\r\n}
