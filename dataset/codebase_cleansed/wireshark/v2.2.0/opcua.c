static guint get_opcua_message_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\ngint32 plen;\r\nplen = tvb_get_letohl(tvb, offset + 4);\r\nreturn plen;\r\n}\r\nstatic int dissect_opcua_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nFctParse pfctParse = NULL;\r\nenum MessageType msgtype = MSG_INVALID;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "OpcUa");\r\nif (tvb_memeql(tvb, 0, "HEL", 3) == 0)\r\n{\r\nmsgtype = MSG_HELLO;\r\npfctParse = parseHello;\r\n}\r\nelse if (tvb_memeql(tvb, 0, "ACK", 3) == 0)\r\n{\r\nmsgtype = MSG_ACKNOWLEDGE;\r\npfctParse = parseAcknowledge;\r\n}\r\nelse if (tvb_memeql(tvb, 0, "ERR", 3) == 0)\r\n{\r\nmsgtype = MSG_ERROR;\r\npfctParse = parseError;\r\n}\r\nelse if (tvb_memeql(tvb, 0, "MSG", 3) == 0)\r\n{\r\nmsgtype = MSG_MESSAGE;\r\npfctParse = parseMessage;\r\n}\r\nelse if (tvb_memeql(tvb, 0, "OPN", 3) == 0)\r\n{\r\nmsgtype = MSG_OPENSECURECHANNEL;\r\npfctParse = parseOpenSecureChannel;\r\n}\r\nelse if (tvb_memeql(tvb, 0, "CLO", 3) == 0)\r\n{\r\nmsgtype = MSG_CLOSESECURECHANNEL;\r\npfctParse = parseCloseSecureChannel;\r\n}\r\nelse\r\n{\r\nmsgtype = MSG_INVALID;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_INFO, g_szMessageTypes[msgtype]);\r\nif (pfctParse)\r\n{\r\ngint offset = 0;\r\nint iServiceId = -1;\r\ntvbuff_t *next_tvb = tvb;\r\ngboolean bParseService = TRUE;\r\ngboolean bIsLastFragment = FALSE;\r\nproto_item *ti = NULL;\r\nproto_tree *transport_tree = NULL;\r\nti = proto_tree_add_item(tree, proto_opcua, tvb, 0, -1, ENC_NA);\r\ntransport_tree = proto_item_add_subtree(ti, ett_opcua_transport);\r\nif (msgtype == MSG_MESSAGE)\r\n{\r\nguint8 chunkType = 0;\r\nguint32 opcua_seqid = 0;\r\nguint32 opcua_num = 0;\r\nguint32 opcua_seqnum = 0;\r\nfragment_head *frag_msg = NULL;\r\noffset = 3;\r\nchunkType = tvb_get_guint8(tvb, offset); offset += 1;\r\noffset += 4;\r\noffset += 4;\r\noffset += 4;\r\nopcua_num = tvb_get_letohl(tvb, offset); offset += 4;\r\nopcua_seqid = tvb_get_letohl(tvb, offset); offset += 4;\r\nfrag_msg = fragment_get(&opcua_reassembly_table, pinfo, opcua_seqid, NULL);\r\nif (frag_msg == NULL)\r\n{\r\nfrag_msg = fragment_get_reassembled_id(&opcua_reassembly_table, pinfo, opcua_seqid);\r\n}\r\nif (frag_msg != NULL || chunkType != 'F')\r\n{\r\ngboolean bSaveFragmented = pinfo->fragmented;\r\ngboolean bMoreFragments = TRUE;\r\ntvbuff_t *new_tvb = NULL;\r\npinfo->fragmented = TRUE;\r\nif (frag_msg == NULL)\r\n{\r\nopcua_seqnum = 0;\r\n}\r\nelse\r\n{\r\nwhile (frag_msg->next) {frag_msg = frag_msg->next;}\r\nopcua_seqnum = frag_msg->offset + 1;\r\nif (chunkType == 'F')\r\n{\r\nbMoreFragments = FALSE;\r\n}\r\n}\r\nfrag_msg = fragment_add_seq_check(&opcua_reassembly_table,\r\ntvb,\r\noffset,\r\npinfo,\r\nopcua_seqid,\r\nNULL,\r\nopcua_seqnum,\r\ntvb_captured_length_remaining(tvb, offset),\r\nbMoreFragments);\r\nnew_tvb = process_reassembled_data(tvb,\r\noffset,\r\npinfo,\r\n"Reassembled Message",\r\nfrag_msg,\r\n&opcua_frag_items,\r\nNULL,\r\ntransport_tree);\r\nif (new_tvb)\r\n{\r\nbIsLastFragment = TRUE;\r\n}\r\nelse\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (Message fragment %u)", opcua_num);\r\n}\r\nif (new_tvb)\r\n{\r\nnext_tvb = new_tvb;\r\n}\r\nelse\r\n{\r\nbParseService = FALSE;\r\nnext_tvb = tvb_new_subset_remaining(tvb, 0);\r\n}\r\npinfo->fragmented = bSaveFragmented;\r\n}\r\n}\r\noffset = 0;\r\niServiceId = (*pfctParse)(transport_tree, tvb, pinfo, &offset);\r\nif (msgtype == MSG_MESSAGE && bParseService)\r\n{\r\nif (bIsLastFragment != FALSE)\r\n{\r\noffset = 0;\r\n}\r\niServiceId = parseService(transport_tree, next_tvb, pinfo, &offset);\r\n}\r\nif (iServiceId != -1)\r\n{\r\nconst gchar *szServiceName = val_to_str((guint32)iServiceId, g_requesttypes, "ServiceId %d");\r\nif (bIsLastFragment == FALSE)\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s: %s", g_szMessageTypes[msgtype], szServiceName);\r\n}\r\nelse\r\n{\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s: %s (Message Reassembled)", g_szMessageTypes[msgtype], szServiceName);\r\n}\r\n}\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic int dissect_opcua(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, TRUE, FRAME_HEADER_LEN,\r\nget_opcua_message_len, dissect_opcua_message, data);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic void register_tcp_port(guint32 port)\r\n{\r\nif (port != 0)\r\ndissector_add_uint("tcp.port", port, opcua_handle);\r\n}\r\nstatic void unregister_tcp_port(guint32 port)\r\n{\r\nif (port != 0)\r\ndissector_delete_uint("tcp.port", port, opcua_handle);\r\n}\r\nstatic void\r\ninit_opcua(void)\r\n{\r\nreassembly_table_init(&opcua_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\ncleanup_opcua(void)\r\n{\r\nreassembly_table_destroy(&opcua_reassembly_table);\r\n}\r\nvoid proto_register_opcua(void)\r\n{\r\nchar *tmp;\r\nstatic hf_register_info hf[] =\r\n{\r\n{&hf_opcua_fragments, {"Message fragments", "opcua.fragments", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL}},\r\n{&hf_opcua_fragment, {"Message fragment", "opcua.fragment", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL}},\r\n{&hf_opcua_fragment_overlap, {"Message fragment overlap", "opcua.fragment.overlap", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL}},\r\n{&hf_opcua_fragment_overlap_conflicts, {"Message fragment overlapping with conflicting data", "opcua.fragment.overlap.conflicts", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL}},\r\n{&hf_opcua_fragment_multiple_tails, {"Message has multiple tail fragments", "opcua.fragment.multiple_tails", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL}},\r\n{&hf_opcua_fragment_too_long_fragment, {"Message fragment too long", "opcua.fragment.too_long_fragment", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL}},\r\n{&hf_opcua_fragment_error, {"Message defragmentation error", "opcua.fragment.error", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL}},\r\n{&hf_opcua_fragment_count, {"Message fragment count", "opcua.fragment.count", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL}},\r\n{&hf_opcua_reassembled_in, {"Reassembled in", "opcua.reassembled.in", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL}},\r\n{&hf_opcua_reassembled_length, {"Reassembled length", "opcua.reassembled.length", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL}}\r\n};\r\nstatic gint *ett[] =\r\n{\r\n&ett_opcua_extensionobject,\r\n&ett_opcua_nodeid,\r\n&ett_opcua_transport,\r\n&ett_opcua_fragment,\r\n&ett_opcua_fragments\r\n};\r\nmodule_t *opcua_module;\r\nproto_opcua = proto_register_protocol(\r\n"OpcUa Binary Protocol",\r\n"OpcUa",\r\n"opcua"\r\n);\r\nregisterTransportLayerTypes(proto_opcua);\r\nregisterSecurityLayerTypes(proto_opcua);\r\nregisterApplicationLayerTypes(proto_opcua);\r\nregisterSimpleTypes(proto_opcua);\r\nregisterEnumTypes(proto_opcua);\r\nregisterComplexTypes();\r\nregisterServiceTypes();\r\nregisterFieldTypes(proto_opcua);\r\nproto_register_subtree_array(ett, array_length(ett));\r\ntmp = g_strdup_printf("%d", OPCUA_PORT);\r\nrange_convert_str(&global_tcp_ports_opcua, tmp, 65535);\r\ng_free(tmp);\r\nproto_register_field_array(proto_opcua, hf, array_length(hf));\r\nregister_init_routine(&init_opcua);\r\nregister_cleanup_routine(&cleanup_opcua);\r\nopcua_module = prefs_register_protocol(proto_opcua, proto_reg_handoff_opcua);\r\nprefs_register_range_preference(opcua_module, "tcp_ports",\r\n"OPC UA TCP Ports",\r\n"The TCP ports for the OPC UA TCP Binary Protocol (comma separated list)",\r\n&global_tcp_ports_opcua, 65535);\r\n}\r\nvoid proto_reg_handoff_opcua(void)\r\n{\r\nstatic gboolean opcua_initialized = FALSE;\r\nstatic range_t *tcp_ports_opcua = NULL;\r\nif(!opcua_initialized)\r\n{\r\nopcua_handle = create_dissector_handle(dissect_opcua, proto_opcua);\r\nopcua_initialized = TRUE;\r\n}\r\nelse\r\n{\r\nif (tcp_ports_opcua != NULL)\r\n{\r\nrange_foreach(tcp_ports_opcua, unregister_tcp_port);\r\ng_free(tcp_ports_opcua);\r\n}\r\n}\r\ntcp_ports_opcua = range_copy(global_tcp_ports_opcua);\r\nrange_foreach(tcp_ports_opcua, register_tcp_port);\r\n}
