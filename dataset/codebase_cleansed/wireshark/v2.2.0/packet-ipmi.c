static ipmi_packet_data_t *\r\nget_packet_data(packet_info * pinfo)\r\n{\r\nipmi_packet_data_t * data;\r\nconversation_t * conv = find_or_create_conversation(pinfo);\r\ndata = (ipmi_packet_data_t *)\r\nconversation_get_proto_data(conv, proto_ipmi);\r\nif (!data) {\r\ndata = wmem_new0(wmem_file_scope(), ipmi_packet_data_t);\r\ndata->frame_tree = wmem_tree_new(wmem_file_scope());\r\ndata->request_list = wmem_list_new(wmem_file_scope());\r\nconversation_add_proto_data(conv, proto_ipmi, data);\r\n}\r\nif (pinfo->num != data->curr_frame_num) {\r\ndata->curr_level = 0;\r\ndata->next_level = 0;\r\n}\r\nreturn data;\r\n}\r\nstatic ipmi_frame_data_t *\r\nget_frame_data(ipmi_packet_data_t * data, guint32 frame_num)\r\n{\r\nipmi_frame_data_t * frame = (ipmi_frame_data_t *)\r\nwmem_tree_lookup32(data->frame_tree, frame_num);\r\nif (frame == NULL) {\r\nframe = wmem_new0(wmem_file_scope(), ipmi_frame_data_t);\r\nwmem_tree_insert32(data->frame_tree, frame_num, frame);\r\n}\r\nreturn frame;\r\n}\r\nstatic ipmi_request_t *\r\nget_matched_request(ipmi_packet_data_t * data, const ipmi_header_t * rs_hdr,\r\nguint flags)\r\n{\r\nwmem_list_frame_t * iter = wmem_list_head(data->request_list);\r\nipmi_header_t rq_hdr;\r\nrq_hdr.context = 0;\r\nrq_hdr.channel = data->curr_channel;\r\nrq_hdr.dir = rs_hdr->dir ^ 1;\r\nrq_hdr.session = rs_hdr->session;\r\nrq_hdr.rs_sa = rs_hdr->rq_sa;\r\nrq_hdr.rs_lun = rs_hdr->rq_lun;\r\nrq_hdr.netfn = rs_hdr->netfn & ~1;\r\nrq_hdr.rq_sa = rs_hdr->rs_sa;\r\nrq_hdr.rq_lun = rs_hdr->rs_lun;\r\nrq_hdr.rq_seq = rs_hdr->rq_seq;\r\nrq_hdr.cmd = rs_hdr->cmd;\r\n#ifdef DEBUG\r\nfprintf(stderr, "%d, %d: rq_hdr : {\n"\r\n"\tchannel=%d\n"\r\n"\tdir=%d\n"\r\n"\trs_sa=%x\n"\r\n"\trs_lun=%d\n"\r\n"\tnetfn=%x\n"\r\n"\trq_sa=%x\n"\r\n"\trq_lun=%d\n"\r\n"\trq_seq=%x\n"\r\n"\tcmd=%x\n}\n",\r\ndata->curr_frame_num, data->curr_level,\r\nrq_hdr.channel, rq_hdr.dir, rq_hdr.rs_sa, rq_hdr.rs_lun,\r\nrq_hdr.netfn, rq_hdr.rq_sa, rq_hdr.rq_lun, rq_hdr.rq_seq,\r\nrq_hdr.cmd);\r\n#endif\r\nwhile (iter) {\r\nipmi_request_t * rq = (ipmi_request_t *) wmem_list_frame_data(iter);\r\nif (rs_hdr->context == IPMI_E_GETMSG && !(flags & IPMI_D_TRG_SA)) {\r\nrq_hdr.rq_sa = rq->hdr.rq_sa;\r\n}\r\nif (!memcmp(&rq_hdr, &rq->hdr, sizeof(rq_hdr))) {\r\nreturn rq;\r\n}\r\niter = wmem_list_frame_next(iter);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nremove_old_requests(ipmi_packet_data_t * data, const nstime_t * curr_time)\r\n{\r\nwmem_list_frame_t * iter = wmem_list_head(data->request_list);\r\nwhile (iter) {\r\nipmi_request_t * rq = (ipmi_request_t *) wmem_list_frame_data(iter);\r\nipmi_frame_data_t * frame = get_frame_data(data, rq->frame_num);\r\nnstime_t delta;\r\nnstime_delta(&delta, curr_time, &frame->ts);\r\nif (nstime_to_msec(&delta) > response_after_req) {\r\nwmem_list_frame_t * del = iter;\r\niter = wmem_list_frame_next(iter);\r\nwmem_free(wmem_file_scope(), rq);\r\nwmem_list_remove_frame(data->request_list, del);\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nmatch_request_response(ipmi_packet_data_t * data, const ipmi_header_t * hdr,\r\nguint flags)\r\n{\r\nipmi_frame_data_t * rs_frame = data->curr_frame;\r\nipmi_cmd_data_t * rs_data = rs_frame->cmd_data[data->curr_level];\r\nif (!rs_data) {\r\nipmi_request_t * rq;\r\nrs_data = wmem_new0(wmem_file_scope(), ipmi_cmd_data_t);\r\nrq = get_matched_request(data, hdr, flags);\r\nif (rq) {\r\nipmi_frame_data_t * rq_frame =\r\nget_frame_data(data, rq->frame_num);\r\nipmi_cmd_data_t * rq_data = rq_frame->cmd_data[rq->nest_level];\r\nrq_data->matched_frame_num = data->curr_frame_num;\r\nrs_data->matched_frame_num = rq->frame_num;\r\nrs_data->saved_data[0] = rq_data->saved_data[0];\r\nrs_data->saved_data[1] = rq_data->saved_data[1];\r\nwmem_list_remove(data->request_list, rq);\r\nwmem_free(wmem_file_scope(), rq);\r\n}\r\nrs_frame->cmd_data[data->curr_level] = rs_data;\r\n}\r\n}\r\nstatic void\r\nadd_request(ipmi_packet_data_t * data, const ipmi_header_t * hdr)\r\n{\r\nipmi_frame_data_t * rq_frame = data->curr_frame;\r\nipmi_cmd_data_t * rq_data = rq_frame->cmd_data[data->curr_level];\r\nif (!rq_data) {\r\nipmi_request_t * rq;\r\nrq_data = wmem_new0(wmem_file_scope(), ipmi_cmd_data_t);\r\nrq_frame->cmd_data[data->curr_level] = rq_data;\r\nrq = wmem_new0(wmem_file_scope(), ipmi_request_t);\r\nmemcpy(&rq->hdr, hdr, sizeof(rq->hdr));\r\nrq->hdr.context = 0;\r\nrq->hdr.channel = data->curr_channel;\r\nrq->hdr.dir = data->curr_dir;\r\nrq->frame_num = data->curr_frame_num;\r\nrq->nest_level = data->curr_level;\r\nwmem_list_append(data->request_list, rq);\r\n#ifdef DEBUG\r\nfprintf(stderr, "%d, %d: hdr : {\n"\r\n"\tchannel=%d\n"\r\n"\tdir=%d\n"\r\n"\trs_sa=%x\n"\r\n"\trs_lun=%d\n"\r\n"\tnetfn=%x\n"\r\n"\trq_sa=%x\n"\r\n"\trq_lun=%d\n"\r\n"\trq_seq=%x\n"\r\n"\tcmd=%x\n}\n",\r\ndata->curr_frame_num, data->curr_level,\r\nrq->hdr.channel, rq->hdr.dir, rq->hdr.rs_sa, rq->hdr.rs_lun,\r\nrq->hdr.netfn, rq->hdr.rq_sa, rq->hdr.rq_lun, rq->hdr.rq_seq,\r\nrq->hdr.cmd);\r\n#endif\r\n}\r\n}\r\nstatic void\r\nadd_command_info(packet_info *pinfo, ipmi_cmd_t * cmd,\r\ngboolean resp, guint8 cc_val, const char * cc_str, gboolean broadcast)\r\n{\r\nif (resp) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Rsp, %s, %s (%02xh)",\r\ncmd->desc, cc_str, cc_val);\r\n} else {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Req, %s%s",\r\nbroadcast ? "Broadcast " : "", cmd->desc);\r\n}\r\n}\r\nstatic int\r\ndissect_ipmi_cmd(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint hf_parent_item, gint ett_tree, const ipmi_context_t * ctx)\r\n{\r\nipmi_packet_data_t * data;\r\nipmi_netfn_t * cmd_list;\r\nipmi_cmd_t * cmd;\r\nproto_item * ti;\r\nproto_tree * cmd_tree = NULL, * tmp_tree;\r\nguint8 prev_level, cc_val;\r\nguint offset, siglen, is_resp;\r\nconst char * cc_str, * netfn_str;\r\ndata = get_packet_data(pinfo);\r\nif (!data) {\r\nreturn 0;\r\n}\r\nsiglen = ipmi_getsiglen(ctx->hdr.netfn);\r\nis_resp = ctx->hdr.netfn & 1;\r\nif (tvb_captured_length(tvb) < ctx->hdr_len + siglen + is_resp\r\n+ !(ctx->flags & IPMI_D_NO_CKS)) {\r\nreturn call_data_dissector(tvb, pinfo, tree);\r\n}\r\nprev_level = data->curr_level;\r\ndata->curr_level = data->next_level;\r\ndata->next_level++;\r\nif (!data->curr_level) {\r\ndata->curr_frame = get_frame_data(data, pinfo->num);\r\ndata->curr_frame_num = pinfo->num;\r\nmemcpy(&data->curr_frame->ts, &pinfo->abs_ts, sizeof(nstime_t));\r\ndata->curr_channel = ctx->hdr.channel;\r\ndata->curr_dir = ctx->hdr.dir;\r\nremove_old_requests(data, &pinfo->abs_ts);\r\n}\r\nif (data->curr_level < MAX_NEST_LEVEL) {\r\nif (ctx->hdr.netfn & 1) {\r\nmatch_request_response(data, &ctx->hdr, ctx->flags);\r\n} else {\r\nadd_request(data, &ctx->hdr);\r\n}\r\n}\r\ncmd_list = ipmi_getnetfn(ctx->hdr.netfn,\r\ntvb_get_ptr(tvb, ctx->hdr_len + is_resp, siglen));\r\ncmd = ipmi_getcmd(cmd_list, ctx->hdr.cmd);\r\nif (is_resp) {\r\ncc_val = tvb_get_guint8(tvb, ctx->hdr_len);\r\ncc_str = ipmi_get_completion_code(cc_val, cmd);\r\n} else {\r\ncc_val = 0;\r\ncc_str = NULL;\r\n}\r\nif (!data->curr_level) {\r\nadd_command_info(pinfo, cmd, is_resp, cc_val, cc_str,\r\nctx->flags & IPMI_D_BROADCAST ? TRUE : FALSE);\r\n}\r\nif (tree) {\r\nif (!data->curr_level) {\r\nti = proto_tree_add_item(tree, hf_parent_item, tvb, 0, -1, ENC_NA);\r\ncmd_tree = proto_item_add_subtree(ti, ett_tree);\r\n} else {\r\nchar str[ITEM_LABEL_LENGTH];\r\nif (is_resp) {\r\ng_snprintf(str, ITEM_LABEL_LENGTH, "Rsp, %s, %s",\r\ncmd->desc, cc_str);\r\n} else {\r\ng_snprintf(str, ITEM_LABEL_LENGTH, "Req, %s", cmd->desc);\r\n}\r\nif (proto_registrar_get_ftype(hf_parent_item) == FT_STRING) {\r\nti = proto_tree_add_string(tree, hf_parent_item, tvb, 0, -1, str);\r\ncmd_tree = proto_item_add_subtree(ti, ett_tree);\r\n}\r\nelse\r\ncmd_tree = proto_tree_add_subtree(tree, tvb, 0, -1, ett_tree, NULL, str);\r\n}\r\nif (data->curr_level < MAX_NEST_LEVEL) {\r\nif (ctx->hdr.netfn & 1) {\r\nipmi_cmd_data_t * rs_data =\r\ndata->curr_frame->cmd_data[data->curr_level];\r\nif (rs_data->matched_frame_num) {\r\nnstime_t ns;\r\nti = proto_tree_add_uint(cmd_tree, hf_ipmi_response_to,\r\ntvb, 0, 0, rs_data->matched_frame_num);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nnstime_delta(&ns, &pinfo->abs_ts,\r\n&get_frame_data(data,\r\nrs_data->matched_frame_num)->ts);\r\nti = proto_tree_add_time(cmd_tree, hf_ipmi_response_time,\r\ntvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\n} else {\r\nipmi_cmd_data_t * rq_data =\r\ndata->curr_frame->cmd_data[data->curr_level];\r\nif (rq_data->matched_frame_num) {\r\nti = proto_tree_add_uint(cmd_tree, hf_ipmi_response_in,\r\ntvb, 0, 0, rq_data->matched_frame_num);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\n}\r\n}\r\noffset = 0;\r\nif (ctx->flags & IPMI_D_BROADCAST) {\r\noffset++;\r\n}\r\nif (ctx->flags & IPMI_D_SESSION_HANDLE) {\r\nproto_tree_add_item(cmd_tree, hf_ipmi_session_handle,\r\ntvb, offset++, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (ctx->flags & IPMI_D_TRG_SA) {\r\nproto_tree_add_item(cmd_tree, hf_ipmi_header_trg, tvb,\r\noffset++, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nnetfn_str = ipmi_getnetfnname(ctx->hdr.netfn, cmd_list);\r\ntmp_tree = proto_tree_add_subtree_format(cmd_tree, tvb, offset, 1,\r\nett_header_byte_1, NULL, "Target LUN: 0x%02x, NetFN: %s %s (0x%02x)",\r\nctx->hdr.rs_lun, netfn_str,\r\nis_resp ? "Response" : "Request", ctx->hdr.netfn);\r\nproto_tree_add_uint_format(tmp_tree, hf_ipmi_header_netfn, tvb,\r\noffset, 1, ctx->hdr.netfn << 2,\r\n"NetFn: %s %s (0x%02x)", netfn_str,\r\nis_resp ? "Response" : "Request", ctx->hdr.netfn);\r\nproto_tree_add_item(tmp_tree, hf_ipmi_header_trg_lun, tvb,\r\noffset++, 1, ENC_LITTLE_ENDIAN);\r\nif (!(ctx->flags & IPMI_D_NO_CKS)) {\r\nguint8 cks = tvb_get_guint8(tvb, offset);\r\nif (ctx->cks1) {\r\nguint8 correct = cks - ctx->cks1;\r\nproto_tree_add_uint_format_value(cmd_tree, hf_ipmi_header_crc,\r\ntvb, offset++, 1, cks,\r\n"0x%02x (incorrect, expected 0x%02x)", cks, correct);\r\n} else {\r\nproto_tree_add_uint_format_value(cmd_tree, hf_ipmi_header_crc,\r\ntvb, offset++, 1, cks,\r\n"0x%02x (correct)", cks);\r\n}\r\n}\r\nif (!(ctx->flags & IPMI_D_NO_RQ_SA)) {\r\nproto_tree_add_item(cmd_tree, hf_ipmi_header_src, tvb,\r\noffset++, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (!(ctx->flags & IPMI_D_NO_SEQ)) {\r\ntmp_tree = proto_tree_add_subtree_format(cmd_tree, tvb, offset, 1,\r\nett_header_byte_4, NULL, "%s: 0x%02x, SeqNo: 0x%02x",\r\n(ctx->flags & IPMI_D_TMODE) ? "Bridged" : "Source LUN",\r\nctx->hdr.rq_lun, ctx->hdr.rq_seq);\r\nif (ctx->flags & IPMI_D_TMODE) {\r\nproto_tree_add_item(tmp_tree, hf_ipmi_header_bridged,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n} else {\r\nproto_tree_add_item(tmp_tree, hf_ipmi_header_src_lun,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_tree_add_item(tmp_tree, hf_ipmi_header_sequence, tvb,\r\noffset++, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_tree_add_uint_format_value(cmd_tree, hf_ipmi_header_command,\r\ntvb, offset++, 1, ctx->hdr.cmd, "%s (0x%02x)",\r\ncmd->desc, ctx->hdr.cmd);\r\nif (is_resp) {\r\nproto_tree_add_uint_format_value(cmd_tree,\r\nhf_ipmi_header_completion, tvb, offset++, 1,\r\ncc_val, "%s (0x%02x)", cc_str, cc_val);\r\n}\r\nif (siglen) {\r\nti = proto_tree_add_item(cmd_tree, hf_ipmi_header_sig, tvb,\r\noffset, siglen, ENC_NA);\r\nproto_item_append_text(ti, " (%s)", netfn_str);\r\n}\r\n}\r\nif (tree || (cmd->flags & CMD_CALLRQ)) {\r\nguint data_len = tvb_captured_length(tvb)\r\n- ctx->hdr_len\r\n- siglen\r\n- (is_resp ? 1 : 0)\r\n- !(ctx->flags & IPMI_D_NO_CKS);\r\ntvbuff_t * data_tvb = tvb_new_subset_length(tvb,\r\nctx->hdr_len + siglen + (is_resp ? 1 : 0), data_len);\r\nipmi_cmd_handler_t hnd = is_resp ? cmd->parse_resp : cmd->parse_req;\r\nif (hnd && tvb_captured_length(data_tvb)) {\r\ntmp_tree = proto_tree_add_subtree(cmd_tree, data_tvb, 0, -1, ett_data, NULL, "Data");\r\ndata->curr_hdr = &ctx->hdr;\r\ndata->curr_ccode = cc_val;\r\nhnd(data_tvb, pinfo, tmp_tree);\r\n}\r\n}\r\nif (tree && !(ctx->flags & IPMI_D_NO_CKS)) {\r\nguint8 cks;\r\noffset = tvb_captured_length(tvb) - 1;\r\ncks = tvb_get_guint8(tvb, offset);\r\nif (ctx->cks2) {\r\nguint8 correct = cks - ctx->cks2;\r\nproto_tree_add_uint_format_value(cmd_tree, hf_ipmi_data_crc,\r\ntvb, offset, 1, cks,\r\n"0x%02x (incorrect, expected 0x%02x)", cks, correct);\r\n} else {\r\nproto_tree_add_uint_format_value(cmd_tree, hf_ipmi_data_crc,\r\ntvb, offset, 1, cks,\r\n"0x%02x (correct)", cks);\r\n}\r\n}\r\ndata->next_level = data->curr_level;\r\ndata->curr_level = prev_level;\r\nreturn tvb_captured_length(tvb);\r\n}\r\nconst ipmi_header_t * ipmi_get_hdr(packet_info * pinfo)\r\n{\r\nipmi_packet_data_t * data = get_packet_data(pinfo);\r\nreturn data->curr_hdr;\r\n}\r\nguint8 ipmi_get_ccode(packet_info * pinfo)\r\n{\r\nipmi_packet_data_t * data = get_packet_data(pinfo);\r\nreturn data->curr_ccode;\r\n}\r\nvoid ipmi_set_data(packet_info *pinfo, guint idx, guint32 value)\r\n{\r\nipmi_packet_data_t * data = get_packet_data(pinfo);\r\nif (data->curr_level >= MAX_NEST_LEVEL || idx >= NSAVED_DATA ) {\r\nreturn;\r\n}\r\ndata->curr_frame->cmd_data[data->curr_level]->saved_data[idx] = value;\r\n}\r\ngboolean ipmi_get_data(packet_info *pinfo, guint idx, guint32 * value)\r\n{\r\nipmi_packet_data_t * data = get_packet_data(pinfo);\r\nif (data->curr_level >= MAX_NEST_LEVEL || idx >= NSAVED_DATA ) {\r\nreturn FALSE;\r\n}\r\n*value = data->curr_frame->cmd_data[data->curr_level]->saved_data[idx];\r\nreturn TRUE;\r\n}\r\nstatic void\r\nget_len_binary(guint *clen, guint *blen, tvbuff_t *tvb _U_, guint offs _U_,\r\nguint len, gboolean len_is_bytes _U_)\r\n{\r\n*clen = len * 3;\r\n*blen = len;\r\n}\r\nstatic void\r\nparse_binary(char *p, tvbuff_t *tvb, guint offs, guint len)\r\n{\r\nstatic const char hex[] = "0123456789ABCDEF";\r\nguint8 v;\r\nguint i;\r\nfor (i = 0; i < len / 3; i++) {\r\nv = tvb_get_guint8(tvb, offs + i);\r\n*p++ = hex[v >> 4];\r\n*p++ = hex[v & 0xf];\r\n*p++ = ' ';\r\n}\r\nif (i) {\r\n*--p = '\0';\r\n}\r\n}\r\nstatic void\r\nget_len_bcdplus(guint *clen, guint *blen, tvbuff_t *tvb _U_, guint offs _U_,\r\nguint len, gboolean len_is_bytes)\r\n{\r\nif (len_is_bytes) {\r\n*clen = len * 2;\r\n*blen = len;\r\n} else {\r\n*blen = (len + 1) / 2;\r\n*clen = len;\r\n}\r\n}\r\nstatic void\r\nparse_bcdplus(char *p, tvbuff_t *tvb, guint offs, guint len)\r\n{\r\nstatic const char bcd[] = "0123456789 -.:,_";\r\nguint i, msk = 0xf0, shft = 4;\r\nguint8 v;\r\nfor (i = 0; i < len; i++) {\r\nv = (tvb_get_guint8(tvb, offs + i / 2) & msk) >> shft;\r\n*p++ = bcd[v];\r\nmsk ^= 0xff;\r\nshft = 4 - shft;\r\n}\r\n}\r\nstatic void\r\nget_len_6bit_ascii(guint *clen, guint *blen, tvbuff_t *tvb _U_, guint offs _U_,\r\nguint len, gboolean len_is_bytes)\r\n{\r\nif (len_is_bytes) {\r\n*clen = len * 4 / 3;\r\n*blen = len;\r\n} else {\r\n*blen = (len * 3 + 3) / 4;\r\n*clen = len;\r\n}\r\n}\r\nstatic void\r\nparse_6bit_ascii(char *p, tvbuff_t *tvb, guint offs, guint len)\r\n{\r\nguint32 v;\r\nguint i;\r\nfor (i = 0; i < len / 4; i++) {\r\nv = tvb_get_letoh24(tvb, offs + i * 3);\r\np[0] = ' ' + (v & 0x3f);\r\np[1] = ' ' + ((v >> 6) & 0x3f);\r\np[2] = ' ' + ((v >> 12) & 0x3f);\r\np[3] = ' ' + ((v >> 18) & 0x3f);\r\np += 4;\r\n}\r\noffs += len / 4;\r\nlen &= 0x3;\r\nswitch (len) {\r\ncase 3:\r\nv = (tvb_get_guint8(tvb, offs + 2) << 4) | (tvb_get_guint8(tvb, offs + 1) >> 4);\r\np[2] = ' ' + (v & 0x3f);\r\ncase 2:\r\nv = (tvb_get_guint8(tvb, offs + 1) << 2) | (tvb_get_guint8(tvb, offs) >> 6);\r\np[1] = ' ' + (v & 0x3f);\r\ncase 1:\r\nv = tvb_get_guint8(tvb, offs) & 0x3f;\r\np[0] = ' ' + (v & 0x3f);\r\n}\r\n}\r\nstatic void\r\nget_len_8bit_ascii(guint *clen, guint *blen, tvbuff_t *tvb, guint offs,\r\nguint len, gboolean len_is_bytes _U_)\r\n{\r\nguint i;\r\nguint8 ch;\r\n*blen = len;\r\n*clen = 0;\r\nfor (i = 0; i < len; i++) {\r\nch = tvb_get_guint8(tvb, offs + i);\r\n*clen += (ch >= 0x20 && ch <= 0x7f) ? 1 : 4;\r\n}\r\n}\r\nstatic void\r\nparse_8bit_ascii(char *p, tvbuff_t *tvb, guint offs, guint len)\r\n{\r\nguint8 ch;\r\nchar *pmax;\r\npmax = p + len;\r\nwhile (p < pmax) {\r\nch = tvb_get_guint8(tvb, offs++);\r\nif (ch >= 0x20 && ch <= 0x7f) {\r\n*p++ = ch;\r\n} else {\r\ng_snprintf(p, 5, "\\x%02x", ch);\r\np += 4;\r\n}\r\n}\r\n}\r\nstatic void\r\nget_len_unicode(guint *clen, guint *blen, tvbuff_t *tvb _U_, guint offs _U_,\r\nguint len _U_, gboolean len_is_bytes)\r\n{\r\nif (len_is_bytes) {\r\n*clen = len * 3;\r\n*blen = len;\r\n} else {\r\n*clen = len * 6;\r\n*blen = len * 2;\r\n}\r\n}\r\nstatic void\r\nparse_unicode(char *p, tvbuff_t *tvb, guint offs, guint len)\r\n{\r\nchar *pmax = p + len;\r\nguint8 ch0, ch1;\r\nwhile (p < pmax) {\r\nch0 = tvb_get_guint8(tvb, offs++);\r\nch1 = tvb_get_guint8(tvb, offs++);\r\ng_snprintf(p, 7, "\\U%02x%02x", ch0, ch1);\r\np += 6;\r\n}\r\n}\r\nvoid\r\nipmi_add_typelen(proto_tree *tree, int hf_string, int hf_type, int hf_length, tvbuff_t *tvb,\r\nguint offs, gboolean is_fru)\r\n{\r\nstatic struct ipmi_parse_typelen *fru_eng[4] = {\r\n&ptl_binary, &ptl_bcdplus, &ptl_6bit_ascii, &ptl_8bit_ascii\r\n};\r\nstatic struct ipmi_parse_typelen *fru_noneng[4] = {\r\n&ptl_binary, &ptl_bcdplus, &ptl_6bit_ascii, &ptl_unicode\r\n};\r\nstatic struct ipmi_parse_typelen *ipmi[4] = {\r\n&ptl_unicode, &ptl_bcdplus, &ptl_6bit_ascii, &ptl_8bit_ascii\r\n};\r\nstruct ipmi_parse_typelen *ptr;\r\nproto_tree *s_tree;\r\nguint type, msk, clen, blen, len;\r\nconst char *unit;\r\nchar *str;\r\nguint8 typelen;\r\ntypelen = tvb_get_guint8(tvb, offs);\r\ntype = typelen >> 6;\r\nif (is_fru) {\r\nmsk = 0x3f;\r\nptr = (fru_langcode_is_english ? fru_eng : fru_noneng)[type];\r\nunit = "bytes";\r\n} else {\r\nmsk = 0x1f;\r\nptr = ipmi[type];\r\nunit = "characters";\r\n}\r\nlen = typelen & msk;\r\nptr->get_len(&clen, &blen, tvb, offs + 1, len, is_fru);\r\nstr = (char *)wmem_alloc(wmem_packet_scope(), clen + 1);\r\nptr->parse(str, tvb, offs + 1, clen);\r\nstr[clen] = '\0';\r\ns_tree = proto_tree_add_subtree_format(tree, tvb, offs, 1, ett_typelen, NULL,\r\n"%s Type/Length byte: %s, %d %s", (proto_registrar_get_nth(hf_string))->name, ptr->desc, len, unit);\r\nproto_tree_add_uint_format_value(s_tree, hf_type, tvb, offs, 1, type, "%s (0x%02x)",\r\nptr->desc, type);\r\nproto_tree_add_uint_format_value(s_tree, hf_length, tvb, offs, 1, len, "%d %s",\r\nlen, unit);\r\nproto_tree_add_string_format_value(tree, hf_string, tvb, offs + 1, blen, str,\r\n"[%s] '%s'", ptr->desc, str);\r\n}\r\nvoid\r\nipmi_add_timestamp(proto_tree *tree, gint hf, tvbuff_t *tvb, guint offset)\r\n{\r\nguint32 ts = tvb_get_letohl(tvb, offset);\r\nif (ts == 0xffffffff) {\r\nproto_tree_add_uint_format_value(tree, hf, tvb, offset, 4,\r\nts, "Unspecified/Invalid");\r\n} else if (ts <= 0x20000000) {\r\nproto_tree_add_uint_format_value(tree, hf, tvb, offset, 4,\r\nts, "%s since SEL device's initialization",\r\nunsigned_time_secs_to_str(wmem_packet_scope(), ts));\r\n} else {\r\nproto_tree_add_uint_format_value(tree, hf, tvb, offset, 4,\r\nts, "%s", abs_time_secs_to_str(wmem_packet_scope(), ts, ABSOLUTE_TIME_UTC, TRUE));\r\n}\r\n}\r\nvoid\r\nipmi_add_guid(proto_tree *tree, gint hf, tvbuff_t *tvb, guint offset)\r\n{\r\ne_guid_t guid;\r\nint i;\r\nguid.data1 = tvb_get_letohl(tvb, offset + 12);\r\nguid.data2 = tvb_get_letohs(tvb, offset + 10);\r\nguid.data3 = tvb_get_letohs(tvb, offset + 8);\r\nfor (i = 0; i < 8; i++) {\r\nguid.data4[i] = tvb_get_guint8(tvb, offset + 7 - i);\r\n}\r\nproto_tree_add_guid(tree, hf, tvb, offset, 16, &guid);\r\n}\r\nstatic void\r\nipmi_netfn_setdesc(guint32 netfn, const char *desc, guint32 siglen)\r\n{\r\nstruct ipmi_netfn_root *inr;\r\ninr = &ipmi_cmd_tab[netfn >> 1];\r\ninr->desc = desc;\r\ninr->siglen = siglen;\r\n}\r\nvoid\r\nipmi_register_netfn_cmdtab(guint32 netfn, guint oem_selector,\r\nconst guint8 *sig, guint32 siglen, const char *desc,\r\nipmi_cmd_t *cmdtab, guint32 cmdtablen)\r\n{\r\nstruct ipmi_netfn_root *inr;\r\nipmi_netfn_t *inh;\r\nnetfn >>= 1;\r\nif (netfn >= IPMI_NETFN_MAX) {\r\nreturn;\r\n}\r\ninr = &ipmi_cmd_tab[netfn];\r\nif (inr->siglen != siglen) {\r\nreturn;\r\n}\r\ninh = (struct ipmi_netfn_handler *)g_malloc(sizeof(struct ipmi_netfn_handler));\r\ninh->desc = desc;\r\ninh->oem_selector = oem_selector;\r\ninh->sig = sig;\r\ninh->cmdtab = cmdtab;\r\ninh->cmdtablen = cmdtablen;\r\ninh->next = inr->list;\r\ninr->list = inh;\r\n}\r\nguint32\r\nipmi_getsiglen(guint32 netfn)\r\n{\r\nreturn ipmi_cmd_tab[netfn >> 1].siglen;\r\n}\r\nconst char *\r\nipmi_getnetfnname(guint32 netfn, ipmi_netfn_t *nf)\r\n{\r\nconst char *dn, *db;\r\ndn = ipmi_cmd_tab[netfn >> 1].desc ?\r\nipmi_cmd_tab[netfn >> 1].desc : "Reserved";\r\ndb = nf ? nf->desc : NULL;\r\nif (db) {\r\nreturn wmem_strdup_printf(wmem_packet_scope(), "%s (%s)", db, dn);\r\n} else {\r\nreturn dn;\r\n}\r\n}\r\nipmi_netfn_t *\r\nipmi_getnetfn(guint32 netfn, const guint8 *sig)\r\n{\r\nstruct ipmi_netfn_root *inr;\r\nipmi_netfn_t *inh;\r\ninr = &ipmi_cmd_tab[netfn >> 1];\r\nfor (inh = inr->list; inh; inh = inh->next) {\r\nif ((inh->oem_selector == selected_oem || inh->oem_selector == IPMI_OEM_NONE)\r\n&& (!inr->siglen || !memcmp(sig, inh->sig, inr->siglen))) {\r\nreturn inh;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nipmi_cmd_t *\r\nipmi_getcmd(ipmi_netfn_t *nf, guint32 cmd)\r\n{\r\nstatic ipmi_cmd_t ipmi_cmd_unknown = {\r\n0x00,\r\nipmi_notimpl,\r\nipmi_notimpl,\r\nNULL,\r\nNULL,\r\n"Unknown command",\r\n0\r\n};\r\nipmi_cmd_t *ic;\r\nsize_t i, len;\r\nif (nf) {\r\nlen = nf->cmdtablen;\r\nfor (ic = nf->cmdtab, i = 0; i < len; i++, ic++) {\r\nif (ic->cmd == cmd) {\r\nreturn ic;\r\n}\r\n}\r\n}\r\nreturn &ipmi_cmd_unknown;\r\n}\r\nvoid\r\nipmi_notimpl(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_impi_parser_not_implemented, tvb, 0, -1);\r\n}\r\nvoid\r\nipmi_fmt_10ms_1based(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%03d seconds", v / 100, (v % 100) * 10);\r\n}\r\nvoid\r\nipmi_fmt_500ms_0based(gchar *s, guint32 v)\r\n{\r\nipmi_fmt_500ms_1based(s, ++v);\r\n}\r\nvoid\r\nipmi_fmt_500ms_1based(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%03d seconds", v / 2, (v % 2) * 500);\r\n}\r\nvoid\r\nipmi_fmt_1s_0based(gchar *s, guint32 v)\r\n{\r\nipmi_fmt_1s_1based(s, ++v);\r\n}\r\nvoid\r\nipmi_fmt_1s_1based(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d seconds", v);\r\n}\r\nvoid\r\nipmi_fmt_2s_0based(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d seconds", (v + 1) * 2);\r\n}\r\nvoid\r\nipmi_fmt_5s_1based(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d seconds", v * 5);\r\n}\r\nvoid\r\nipmi_fmt_version(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d.%d", v & 0x0f, (v >> 4) & 0x0f);\r\n}\r\nvoid\r\nipmi_fmt_channel(gchar *s, guint32 v)\r\n{\r\nstatic const value_string chan_vals[] = {\r\n{ 0x00, "Primary IPMB (IPMB-0)" },\r\n{ 0x07, "IPMB-L" },\r\n{ 0x0e, "Current channel" },\r\n{ 0x0f, "System Interface" },\r\n{ 0, NULL }\r\n};\r\ngchar* tmp_str;\r\ntmp_str = val_to_str_wmem(NULL, v, chan_vals, "Channel #%d");\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%s (0x%02x)", tmp_str, v);\r\nwmem_free(NULL, tmp_str);\r\n}\r\nvoid\r\nipmi_fmt_udpport(gchar *s, guint32 v)\r\n{\r\ngchar* port_str = udp_port_to_display(NULL, v);\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%s (%d)", port_str, v);\r\nwmem_free(NULL, port_str);\r\n}\r\nvoid\r\nipmi_fmt_percent(gchar *s, guint32 v)\r\n{\r\ng_snprintf(s, ITEM_LABEL_LENGTH, "%d%%", v);\r\n}\r\nconst char *\r\nipmi_get_completion_code(guint8 completion, ipmi_cmd_t *cmd)\r\n{\r\nstatic const value_string std_completion_codes[] = {\r\n{ 0x00, "Command Completed Normally" },\r\n{ 0xc0, "Node Busy" },\r\n{ 0xc1, "Invalid Command" },\r\n{ 0xc2, "Command invalid for given LUN" },\r\n{ 0xc3, "Timeout while processing command, response unavailable" },\r\n{ 0xc4, "Out of space" },\r\n{ 0xc5, "Reservation Canceled or Invalid Reservation ID" },\r\n{ 0xc6, "Request data truncated" },\r\n{ 0xc7, "Request data length invalid" },\r\n{ 0xc8, "Request data field length limit exceeded" },\r\n{ 0xc9, "Parameter out of range" },\r\n{ 0xca, "Cannot return number of requested data bytes" },\r\n{ 0xcb, "Requested Sensor, data, or record not present" },\r\n{ 0xcc, "Invalid data field in Request" },\r\n{ 0xcd, "Command illegal for specified sensor or record type" },\r\n{ 0xce, "Command response could not be provided" },\r\n{ 0xcf, "Cannot execute duplicated request" },\r\n{ 0xd0, "Command response could not be provided: SDR Repository in update mode" },\r\n{ 0xd1, "Command response could not be provided: device in firmware update mode" },\r\n{ 0xd2, "Command response could not be provided: BMC initialization or initialization agent in progress" },\r\n{ 0xd3, "Destination unavailable" },\r\n{ 0xd4, "Cannot execute command: insufficient privilege level or other security-based restriction" },\r\n{ 0xd5, "Cannot execute command: command, or request parameter(s), not supported in present state" },\r\n{ 0xd6, "Cannot execute command: parameter is illegal because subfunction is disabled or unavailable" },\r\n{ 0xff, "Unspecified error" },\r\n{ 0, NULL }\r\n};\r\nconst char *res;\r\nif (completion >= 0x01 && completion <= 0x7e) {\r\nreturn "Device specific (OEM) completion code";\r\n}\r\nif (completion >= 0x80 && completion <= 0xbe) {\r\nif (cmd && cmd->cs_cc && (res = try_val_to_str(completion, cmd->cs_cc)) != NULL) {\r\nreturn res;\r\n}\r\nreturn "Standard command-specific code";\r\n}\r\nreturn val_to_str_const(completion, std_completion_codes, "Unknown");\r\n}\r\nstatic int\r\ndissect_tmode(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nipmi_dissect_arg_t * arg = (ipmi_dissect_arg_t *) data;\r\nipmi_context_t ctx;\r\nguint tvb_len = tvb_captured_length(tvb);\r\nguint8 tmp;\r\nif (tvb_len < 3) {\r\nreturn 0;\r\n}\r\nmemset(&ctx, 0, sizeof(ctx));\r\ntmp = tvb_get_guint8(tvb, 0);\r\nctx.hdr.netfn = tmp >> 2;\r\nctx.hdr.rq_lun = tmp & 3;\r\nctx.hdr.rs_lun = tmp & 3;\r\nctx.hdr.rq_seq = tvb_get_guint8(tvb, 1) >> 2;\r\nctx.hdr.cmd = tvb_get_guint8(tvb, 2);\r\nctx.flags = IPMI_D_TMODE|IPMI_D_NO_CKS|IPMI_D_NO_RQ_SA;\r\nctx.hdr_len = 3;\r\nctx.hdr.context = arg ? arg->context : IPMI_E_NONE;\r\nctx.hdr.channel = arg ? arg->channel : 0;\r\nctx.hdr.dir = arg ? arg->flags >> 7 : ctx.hdr.netfn & 1;\r\nif (ctx.hdr.context == IPMI_E_NONE) {\r\ncol_set_str(pinfo->cinfo, COL_DEF_SRC,\r\nctx.hdr.dir ? "Console" : "BMC");\r\ncol_set_str(pinfo->cinfo, COL_DEF_DST,\r\nctx.hdr.dir ? "BMC" : "Console");\r\n}\r\nreturn dissect_ipmi_cmd(tvb, pinfo, tree, proto_tmode, ett_ipmi, &ctx);\r\n}\r\nstatic int\r\ndissect_kcs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nipmi_dissect_arg_t * arg = (ipmi_dissect_arg_t *) data;\r\nipmi_context_t ctx;\r\nguint tvb_len = tvb_captured_length(tvb);\r\nguint8 tmp;\r\nif (tvb_len < 2) {\r\nreturn 0;\r\n}\r\nmemset(&ctx, 0, sizeof(ctx));\r\ntmp = tvb_get_guint8(tvb, 0);\r\nctx.hdr.netfn = tmp >> 2;\r\nctx.hdr.rq_lun = tmp & 3;\r\nctx.hdr.rs_lun = tmp & 3;\r\nctx.hdr.cmd = tvb_get_guint8(tvb, 1);\r\nctx.flags = IPMI_D_NO_CKS|IPMI_D_NO_RQ_SA|IPMI_D_NO_SEQ;\r\nctx.hdr_len = 2;\r\nctx.hdr.context = arg ? arg->context : 0;\r\nctx.hdr.channel = arg ? arg->channel : 0;\r\nctx.hdr.dir = arg ? arg->flags >> 7 : ctx.hdr.netfn & 1;\r\nif (ctx.hdr.context == IPMI_E_NONE) {\r\ncol_set_str(pinfo->cinfo, COL_DEF_SRC, ctx.hdr.dir ? "HOST" : "BMC");\r\ncol_set_str(pinfo->cinfo, COL_DEF_DST, ctx.hdr.dir ? "BMC" : "HOST");\r\n}\r\nreturn dissect_ipmi_cmd(tvb, pinfo, tree, proto_kcs, ett_ipmi, &ctx);\r\n}\r\nstatic guint8 calc_cks(guint8 start, tvbuff_t * tvb, guint off, guint len)\r\n{\r\nwhile (len--) {\r\nstart += tvb_get_guint8(tvb, off++);\r\n}\r\nreturn start;\r\n}\r\nstatic gboolean guess_imb_format(tvbuff_t *tvb, guint8 env,\r\nguint8 channel, guint * imb_flags, guint8 * cks1, guint8 * cks2)\r\n{\r\ngboolean check_bc = FALSE;\r\ngboolean check_sh = FALSE;\r\ngboolean check_sa = FALSE;\r\nguint tvb_len;\r\nguint sh_len;\r\nguint sa_len;\r\nguint rs_sa;\r\nif (message_format == MSGFMT_NONE) {\r\nreturn FALSE;\r\n} else if (message_format == MSGFMT_IPMB) {\r\n*imb_flags = IPMI_D_TRG_SA;\r\n} else if (message_format == MSGFMT_LAN) {\r\n*imb_flags = IPMI_D_TRG_SA|IPMI_D_SESSION_HANDLE;\r\n} else if (!channel) {\r\nif (env == IPMI_E_NONE) {\r\ncheck_bc = 1;\r\n*imb_flags = IPMI_D_TRG_SA;\r\n} else if (env != IPMI_E_GETMSG) {\r\n*imb_flags = IPMI_D_TRG_SA;\r\n} else {\r\n*imb_flags = 0;\r\n}\r\n} else if (channel == 15) {\r\n*imb_flags = IPMI_D_TRG_SA;\r\nif (env == IPMI_E_GETMSG) {\r\n*imb_flags |= IPMI_D_SESSION_HANDLE;\r\n}\r\n} else {\r\nif (env == IPMI_E_NONE) {\r\ncheck_bc = 1;\r\n*imb_flags = IPMI_D_TRG_SA;\r\n} else if (env == IPMI_E_SENDMSG_RQ) {\r\ncheck_sh = 1;\r\n*imb_flags = IPMI_D_TRG_SA;\r\n} else if (env == IPMI_E_SENDMSG_RS) {\r\n*imb_flags = IPMI_D_TRG_SA;\r\n} else {\r\ncheck_sh = 1;\r\ncheck_sa = 1;\r\n*imb_flags = 0;\r\n}\r\n}\r\ntvb_len = tvb_captured_length(tvb);\r\nif (check_bc\r\n&& tvb_len >= 8\r\n&& !tvb_get_guint8(tvb, 0)\r\n&& !calc_cks(0, tvb, 1, 3)\r\n&& !calc_cks(0, tvb, 4, tvb_len - 4)) {\r\n*imb_flags = IPMI_D_BROADCAST|IPMI_D_TRG_SA;\r\n*cks1 = 0;\r\n*cks2 = 0;\r\nreturn TRUE;\r\n}\r\nif (check_sh\r\n&& tvb_len >= 8\r\n&& !calc_cks(0, tvb, 1, 3)\r\n&& !calc_cks(0, tvb, 4, tvb_len - 4)) {\r\n*imb_flags = IPMI_D_SESSION_HANDLE|IPMI_D_TRG_SA;\r\n*cks1 = 0;\r\n*cks2 = 0;\r\nreturn TRUE;\r\n}\r\nif (check_sa\r\n&& tvb_len >= 7\r\n&& !calc_cks(0, tvb, 0, 3)\r\n&& !calc_cks(0, tvb, 3, tvb_len - 3)) {\r\n*imb_flags = IPMI_D_TRG_SA;\r\n*cks1 = 0;\r\n*cks2 = 0;\r\nreturn TRUE;\r\n}\r\nif (*imb_flags & IPMI_D_SESSION_HANDLE) {\r\nsh_len = 1;\r\nsa_len = 1;\r\nrs_sa = 0;\r\n} else if (*imb_flags & IPMI_D_TRG_SA) {\r\nsh_len = 0;\r\nsa_len = 1;\r\nrs_sa = 0;\r\n} else {\r\nsh_len = 0;\r\nsa_len = 0;\r\nrs_sa = 0x20;\r\n}\r\nif (tvb_len < 6 + sh_len + sa_len) {\r\nreturn FALSE;\r\n}\r\n*cks1 = calc_cks(rs_sa, tvb, sh_len, sa_len + 2);\r\n*cks2 = calc_cks(0, tvb, sh_len + sa_len + 2,\r\ntvb_len - sh_len - sa_len - 2);\r\nreturn TRUE;\r\n}\r\nint\r\ndo_dissect_ipmb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngint hf_parent_item, gint ett_tree, ipmi_dissect_arg_t * arg)\r\n{\r\nipmi_context_t ctx;\r\nguint offset = 0;\r\nguint8 tmp;\r\nmemset(&ctx, 0, sizeof(ctx));\r\nctx.hdr.context = arg ? arg->context : 0;\r\nctx.hdr.channel = arg ? arg->channel : 0;\r\nif (!guess_imb_format(tvb, ctx.hdr.context, ctx.hdr.channel,\r\n&ctx.flags, &ctx.cks1, &ctx.cks2)) {\r\nreturn 0;\r\n}\r\nif (ctx.flags & IPMI_D_BROADCAST) {\r\noffset++;\r\n}\r\nif (ctx.flags & IPMI_D_SESSION_HANDLE) {\r\nctx.hdr.session = tvb_get_guint8(tvb, offset++);\r\n}\r\nif (ctx.flags & IPMI_D_TRG_SA) {\r\nctx.hdr.rs_sa = tvb_get_guint8(tvb, offset++);\r\n} else {\r\nctx.hdr.rs_sa = 0x20;\r\n}\r\ntmp = tvb_get_guint8(tvb, offset++);\r\nctx.hdr.netfn = tmp >> 2;\r\nctx.hdr.rs_lun = tmp & 3;\r\noffset++;\r\nctx.hdr.rq_sa = tvb_get_guint8(tvb, offset++);\r\ntmp = tvb_get_guint8(tvb, offset++);\r\nctx.hdr.rq_seq = tmp >> 2;\r\nctx.hdr.rq_lun = tmp & 3;\r\nctx.hdr.cmd = tvb_get_guint8(tvb, offset++);\r\nctx.hdr_len = offset;\r\nctx.hdr.dir = arg ? arg->flags >> 7 : ctx.hdr.netfn & 1;\r\nif (ctx.hdr.context == IPMI_E_NONE) {\r\nguint red = arg ? (arg->flags & 0x40) : 0;\r\nif (!ctx.hdr.channel) {\r\ncol_add_fstr(pinfo->cinfo, COL_DEF_SRC,\r\n"0x%02x(%s)", ctx.hdr.rq_sa, red ? "IPMB-B" : "IPMB-A");\r\n} else {\r\ncol_add_fstr(pinfo->cinfo, COL_DEF_SRC,\r\n"0x%02x", ctx.hdr.rq_sa);\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_DEF_DST, "0x%02x", ctx.hdr.rs_sa);\r\n}\r\nreturn dissect_ipmi_cmd(tvb, pinfo, tree, hf_parent_item, ett_tree, &ctx);\r\n}\r\nstatic int\r\ndissect_ipmi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nreturn do_dissect_ipmb(tvb, pinfo, tree, proto_ipmb, ett_ipmi,\r\n(ipmi_dissect_arg_t *) data);\r\n}\r\nstatic int\r\ndissect_i2c_ipmi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nif (pinfo->pseudo_header->i2c.flags & 0x00000001) {\r\nreturn 0;\r\n}\r\nreturn do_dissect_ipmb(tvb, pinfo, tree, proto_ipmb, ett_ipmi,\r\n(ipmi_dissect_arg_t *) data);\r\n}\r\nvoid\r\nproto_register_ipmi(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipmi_session_handle, { "Session handle", "ipmi.session_handle", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_header_trg, { "Target Address", "ipmi.header.target", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_ipmi_header_trg_lun, { "Target LUN", "ipmi.header.trg_lun", FT_UINT8, BASE_HEX, NULL, 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_header_netfn, { "NetFN", "ipmi.header.netfn", FT_UINT8, BASE_HEX, NULL, 0xfc, NULL, HFILL }},\r\n{ &hf_ipmi_header_crc, { "Header Checksum", "ipmi.header.crc", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_header_src, { "Source Address", "ipmi.header.source", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_header_src_lun, { "Source LUN", "ipmi.header.src_lun", FT_UINT8, BASE_HEX, NULL, 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_header_bridged, { "Bridged", "ipmi.header.bridged", FT_UINT8, BASE_HEX, NULL, 0x03, NULL, HFILL }},\r\n{ &hf_ipmi_header_sequence, { "Sequence Number", "ipmi.header.sequence", FT_UINT8, BASE_HEX, NULL, 0xfc, NULL, HFILL }},\r\n{ &hf_ipmi_header_command, { "Command", "ipmi.header.command", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_header_completion, { "Completion Code", "ipmi.header.completion", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_header_sig, { "Signature", "ipmi.header.signature", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_data_crc, { "Data checksum", "ipmi.data.crc", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_response_to, { "Response to", "ipmi.response_to", FT_FRAMENUM, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_response_in, { "Response in", "ipmi.response_in", FT_FRAMENUM, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_ipmi_response_time, { "Responded in", "ipmi.response_time", FT_RELATIVE_TIME, BASE_NONE, NULL, 0, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipmi,\r\n&ett_header,\r\n&ett_header_byte_1,\r\n&ett_header_byte_4,\r\n&ett_data,\r\n&ett_typelen\r\n};\r\nstatic const enum_val_t msgfmt_vals[] = {\r\n{ "none", "None", MSGFMT_NONE },\r\n{ "ipmb", "IPMB", MSGFMT_IPMB },\r\n{ "lan", "Session-based (LAN, ...)", MSGFMT_LAN },\r\n{ "guess", "Use heuristics", MSGFMT_GUESS },\r\n{ NULL, NULL, 0 }\r\n};\r\nstatic const enum_val_t oemsel_vals[] = {\r\n{ "none", "None", IPMI_OEM_NONE },\r\n{ "pps", "Pigeon Point Systems", IPMI_OEM_PPS },\r\n{ NULL, NULL, 0 }\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_impi_parser_not_implemented, { "ipmi.parser_not_implemented", PI_UNDECODED, PI_WARN, "[PARSER NOT IMPLEMENTED]", EXPFILL }},\r\n};\r\nmodule_t *m;\r\nexpert_module_t* expert_ipmi;\r\nguint32 i;\r\nproto_ipmi = proto_register_protocol("Intelligent Platform Management Interface",\r\n"IPMI",\r\n"ipmi");\r\nproto_ipmb = proto_register_protocol("Intelligent Platform Management Bus",\r\n"IPMB",\r\n"ipmb");\r\nproto_kcs = proto_register_protocol("Keyboard Controller Style Interface",\r\n"KCS",\r\n"kcs");\r\nproto_tmode = proto_register_protocol("Serial Terminal Mode Interface",\r\n"TMode",\r\n"tmode");\r\nproto_register_field_array(proto_ipmi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ipmi = expert_register_protocol(proto_ipmi);\r\nexpert_register_field_array(expert_ipmi, ei, array_length(ei));\r\nipmi_netfn_setdesc(IPMI_CHASSIS_REQ, "Chassis", 0);\r\nipmi_netfn_setdesc(IPMI_BRIDGE_REQ, "Bridge", 0);\r\nipmi_netfn_setdesc(IPMI_SE_REQ, "Sensor/Event", 0);\r\nipmi_netfn_setdesc(IPMI_APP_REQ, "Application", 0);\r\nipmi_netfn_setdesc(IPMI_UPDATE_REQ, "Firmware Update", 0);\r\nipmi_netfn_setdesc(IPMI_STORAGE_REQ, "Storage", 0);\r\nipmi_netfn_setdesc(IPMI_TRANSPORT_REQ, "Transport", 0);\r\nipmi_netfn_setdesc(IPMI_GROUP_REQ, "Group", 1);\r\nipmi_netfn_setdesc(IPMI_OEM_REQ, "OEM/Group", 3);\r\nfor (i = 0x30; i < 0x40; i += 2) {\r\nipmi_netfn_setdesc(i, "OEM", 0);\r\n}\r\nregister_dissector("ipmi", dissect_ipmi, proto_ipmi);\r\nregister_dissector("ipmb", dissect_ipmi, proto_ipmb);\r\nregister_dissector("kcs", dissect_kcs, proto_kcs);\r\nregister_dissector("tmode", dissect_tmode, proto_tmode);\r\nm = prefs_register_protocol(proto_ipmi, NULL);\r\nprefs_register_bool_preference(m, "fru_langcode_is_english", "FRU Language Code is English",\r\n"FRU Language Code is English; strings are ASCII+LATIN1 (vs. Unicode)",\r\n&fru_langcode_is_english);\r\nprefs_register_uint_preference(m, "response_after_req", "Maximum delay of response message",\r\n"Do not search for responses coming after this timeout (milliseconds)",\r\n10, &response_after_req);\r\nprefs_register_uint_preference(m, "response_before_req", "Response ahead of request",\r\n"Allow for responses before requests (milliseconds)",\r\n10, &response_before_req);\r\nprefs_register_enum_preference(m, "msgfmt", "Format of embedded messages",\r\n"Format of messages embedded into Send/Get/Forward Message",\r\n&message_format, msgfmt_vals, FALSE);\r\nprefs_register_enum_preference(m, "selected_oem", "OEM commands parsed as",\r\n"Selects which OEM format is used for commands that IPMI does not define",\r\n&selected_oem, oemsel_vals, FALSE);\r\n}\r\nvoid proto_reg_handoff_ipmi(void)\r\n{\r\ndissector_handle_t ipmi_handle;\r\nipmi_handle = create_dissector_handle( dissect_i2c_ipmi, proto_ipmi );\r\ndissector_add_for_decode_as("i2c.message", ipmi_handle );\r\n}
