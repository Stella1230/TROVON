guint\r\npref_stash(pref_t *pref, gpointer unused _U_)\r\n{\r\nswitch (pref->type) {\r\ncase PREF_UINT:\r\npref->stashed_val.uint = *pref->varp.uint;\r\nbreak;\r\ncase PREF_BOOL:\r\npref->stashed_val.boolval = *pref->varp.boolp;\r\nbreak;\r\ncase PREF_ENUM:\r\npref->stashed_val.enumval = *pref->varp.enump;\r\nbreak;\r\ncase PREF_STRING:\r\ncase PREF_FILENAME:\r\ncase PREF_DIRNAME:\r\ng_free(pref->stashed_val.string);\r\npref->stashed_val.string = g_strdup(*pref->varp.string);\r\nbreak;\r\ncase PREF_RANGE:\r\ng_free(pref->stashed_val.range);\r\npref->stashed_val.range = range_copy(*pref->varp.range);\r\nbreak;\r\ncase PREF_COLOR:\r\npref->stashed_val.color = *pref->varp.colorp;\r\nbreak;\r\ncase PREF_STATIC_TEXT:\r\ncase PREF_UAT:\r\ncase PREF_CUSTOM:\r\nbreak;\r\ncase PREF_OBSOLETE:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nguint\r\npref_unstash(pref_t *pref, gpointer changed_p)\r\n{\r\ngboolean *pref_changed_p = (gboolean *)changed_p;\r\nswitch (pref->type) {\r\ncase PREF_UINT:\r\nif (*pref->varp.uint != pref->stashed_val.uint) {\r\n*pref_changed_p = TRUE;\r\n*pref->varp.uint = pref->stashed_val.uint;\r\n}\r\nbreak;\r\ncase PREF_BOOL:\r\nif (*pref->varp.boolp != pref->stashed_val.boolval) {\r\n*pref_changed_p = TRUE;\r\n*pref->varp.boolp = pref->stashed_val.boolval;\r\n}\r\nbreak;\r\ncase PREF_ENUM:\r\nif (*pref->varp.enump != pref->stashed_val.enumval) {\r\n*pref_changed_p = TRUE;\r\n*pref->varp.enump = pref->stashed_val.enumval;\r\n}\r\nbreak;\r\ncase PREF_STRING:\r\ncase PREF_FILENAME:\r\ncase PREF_DIRNAME:\r\nif (strcmp(*pref->varp.string, pref->stashed_val.string) != 0) {\r\n*pref_changed_p = TRUE;\r\ng_free(*pref->varp.string);\r\n*pref->varp.string = g_strdup(pref->stashed_val.string);\r\n}\r\nbreak;\r\ncase PREF_RANGE:\r\nif (!ranges_are_equal(*pref->varp.range, pref->stashed_val.range)) {\r\n*pref_changed_p = TRUE;\r\ng_free(*pref->varp.range);\r\n*pref->varp.range = range_copy(pref->stashed_val.range);\r\n}\r\nbreak;\r\ncase PREF_COLOR:\r\n*pref->varp.colorp = pref->stashed_val.color;\r\nbreak;\r\ncase PREF_STATIC_TEXT:\r\ncase PREF_UAT:\r\ncase PREF_CUSTOM:\r\nbreak;\r\ncase PREF_OBSOLETE:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nreset_stashed_pref(pref_t *pref) {\r\nswitch (pref->type) {\r\ncase PREF_UINT:\r\npref->stashed_val.uint = pref->default_val.uint;\r\nbreak;\r\ncase PREF_BOOL:\r\npref->stashed_val.boolval = pref->default_val.boolval;\r\nbreak;\r\ncase PREF_ENUM:\r\npref->stashed_val.enumval = pref->default_val.enumval;\r\nbreak;\r\ncase PREF_STRING:\r\ncase PREF_FILENAME:\r\ncase PREF_DIRNAME:\r\ng_free(pref->stashed_val.string);\r\npref->stashed_val.string = g_strdup(pref->default_val.string);\r\nbreak;\r\ncase PREF_RANGE:\r\ng_free(pref->stashed_val.range);\r\npref->stashed_val.range = range_copy(pref->default_val.range);\r\nbreak;\r\ncase PREF_COLOR:\r\nmemcpy(&pref->stashed_val.color, &pref->default_val.color, sizeof(color_t));\r\nbreak;\r\ncase PREF_STATIC_TEXT:\r\ncase PREF_UAT:\r\ncase PREF_CUSTOM:\r\nbreak;\r\ncase PREF_OBSOLETE:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\nguint\r\npref_clean_stash(pref_t *pref, gpointer unused _U_)\r\n{\r\nswitch (pref->type) {\r\ncase PREF_UINT:\r\nbreak;\r\ncase PREF_BOOL:\r\nbreak;\r\ncase PREF_ENUM:\r\nbreak;\r\ncase PREF_STRING:\r\ncase PREF_FILENAME:\r\ncase PREF_DIRNAME:\r\nif (pref->stashed_val.string != NULL) {\r\ng_free(pref->stashed_val.string);\r\npref->stashed_val.string = NULL;\r\n}\r\nbreak;\r\ncase PREF_RANGE:\r\nif (pref->stashed_val.range != NULL) {\r\ng_free(pref->stashed_val.range);\r\npref->stashed_val.range = NULL;\r\n}\r\nbreak;\r\ncase PREF_STATIC_TEXT:\r\ncase PREF_UAT:\r\ncase PREF_COLOR:\r\ncase PREF_CUSTOM:\r\nbreak;\r\ncase PREF_OBSOLETE:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nprefs_to_capture_opts(void)\r\n{\r\n#ifdef HAVE_LIBPCAP\r\nglobal_capture_opts.default_options.promisc_mode = prefs.capture_prom_mode;\r\nglobal_capture_opts.use_pcapng = prefs.capture_pcap_ng;\r\nglobal_capture_opts.show_info = prefs.capture_show_info;\r\nglobal_capture_opts.real_time_mode = prefs.capture_real_time;\r\nauto_scroll_live = prefs.capture_auto_scroll;\r\n#endif\r\n}\r\nvoid\r\nprefs_main_write(void)\r\n{\r\nint err;\r\nchar *pf_dir_path;\r\nchar *pf_path;\r\nif (create_persconffile_dir(&pf_dir_path) == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't create directory\n\"%s\"\nfor preferences file: %s.", pf_dir_path,\r\ng_strerror(errno));\r\ng_free(pf_dir_path);\r\n} else {\r\nerr = write_prefs(&pf_path);\r\nif (err != 0) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't open preferences file\n\"%s\": %s.", pf_path,\r\ng_strerror(err));\r\ng_free(pf_path);\r\n}\r\n}\r\n}\r\nstatic gboolean\r\nprefs_store_ext_helper(const char * module_name, const char *pref_name, const char *pref_value)\r\n{\r\nmodule_t * module = NULL;\r\npref_t * pref = NULL;\r\ngboolean pref_changed = TRUE;\r\nif ( ! prefs_is_registered_protocol(module_name))\r\nreturn FALSE;\r\nmodule = prefs_find_module(module_name);\r\nif ( ! module )\r\nreturn FALSE;\r\npref = prefs_find_preference(module, pref_name);\r\nif (!pref)\r\nreturn FALSE;\r\nif ( pref->type == PREF_STRING )\r\n{\r\ng_free((void *)pref->stashed_val.string);\r\npref->stashed_val.string = (gchar *) g_strdup(pref_value);\r\nif (strcmp(*pref->varp.string, pref->stashed_val.string) != 0)\r\n{\r\npref_changed = TRUE;\r\ng_free(*pref->varp.string);\r\n*pref->varp.string = g_strdup(pref->stashed_val.string);\r\n}\r\n}\r\nreturn pref_changed;\r\n}\r\ngboolean\r\nprefs_store_ext(const char * module_name, const char *pref_name, const char *pref_value)\r\n{\r\nif ( prefs_store_ext_helper(module_name, pref_name, pref_value) )\r\n{\r\nprefs_main_write();\r\nprefs_apply_all();\r\nprefs_to_capture_opts();\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\ngboolean\r\nprefs_store_ext_multiple(const char * module, GHashTable * pref_values)\r\n{\r\ngboolean pref_changed = FALSE;\r\nGList * keys = NULL;\r\nif ( ! prefs_is_registered_protocol(module))\r\nreturn pref_changed;\r\nkeys = g_hash_table_get_keys(pref_values);\r\nif ( ! keys )\r\nreturn pref_changed;\r\nwhile ( keys != NULL )\r\n{\r\ngchar * pref_name = (gchar *)keys->data;\r\ngchar * pref_value = (gchar *) g_hash_table_lookup(pref_values, keys->data);\r\nif ( pref_name && pref_value )\r\n{\r\nif ( prefs_store_ext_helper(module, pref_name, pref_value) )\r\npref_changed = TRUE;\r\n}\r\nkeys = g_list_next(keys);\r\n}\r\nif ( pref_changed )\r\n{\r\nprefs_main_write();\r\nprefs_apply_all();\r\nprefs_to_capture_opts();\r\n}\r\nreturn TRUE;\r\n}\r\ngint\r\ncolumn_prefs_add_custom(gint fmt, const gchar *title, const gchar *custom_fields, gint custom_occurrence)\r\n{\r\nGList *clp;\r\nfmt_data *cfmt, *last_cfmt;\r\ngint colnr;\r\ncfmt = (fmt_data *) g_malloc(sizeof(fmt_data));\r\ncfmt->title = g_strdup(title);\r\ncfmt->fmt = fmt;\r\ncfmt->custom_fields = g_strdup(custom_fields);\r\ncfmt->custom_occurrence = custom_occurrence;\r\ncfmt->resolved = TRUE;\r\ncolnr = g_list_length(prefs.col_list);\r\nif (custom_fields) {\r\ncfmt->visible = TRUE;\r\nclp = g_list_last(prefs.col_list);\r\nlast_cfmt = (fmt_data *) clp->data;\r\nif (last_cfmt->fmt == COL_INFO) {\r\ncolnr -= 1;\r\nprefs.col_list = g_list_insert(prefs.col_list, cfmt, colnr);\r\n} else {\r\nprefs.col_list = g_list_append(prefs.col_list, cfmt);\r\n}\r\n} else {\r\ncfmt->visible = FALSE;\r\nprefs.col_list = g_list_append(prefs.col_list, cfmt);\r\n}\r\nreturn colnr;\r\n}\r\nvoid\r\ncolumn_prefs_remove_link(GList *col_link)\r\n{\r\nfmt_data *cfmt;\r\nif (!col_link || !col_link->data) return;\r\ncfmt = (fmt_data *) col_link->data;\r\ng_free(cfmt->title);\r\ng_free(cfmt->custom_fields);\r\ng_free(cfmt);\r\nprefs.col_list = g_list_remove_link(prefs.col_list, col_link);\r\n}\r\nvoid\r\ncolumn_prefs_remove_nth(gint col)\r\n{\r\ncolumn_prefs_remove_link(g_list_nth(prefs.col_list, col));\r\n}
