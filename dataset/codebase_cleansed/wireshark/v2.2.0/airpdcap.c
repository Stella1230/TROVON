static INT\r\nAirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)\r\n{\r\nguint8 key_version;\r\nguint8 *key_data;\r\nguint8 *szEncryptedKey;\r\nguint16 key_bytes_len = 0;\r\nguint16 key_len;\r\nstatic AIRPDCAP_KEY_ITEM dummy_key;\r\nAIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\nkey_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);\r\nif (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\r\nkey_bytes_len = pntoh16(pEAPKey->key_length);\r\n}else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\r\nkey_bytes_len = pntoh16(pEAPKey->key_data_len);\r\nif (key_bytes_len < 16) {\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\n}\r\nif ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\r\n(eapol_len < sizeof(EAPOL_RSN_KEY)) ||\r\n(key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nkey_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\r\nszEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\r\nDEBUG_DUMP("Encrypted Broadcast key:", szEncryptedKey, key_bytes_len);\r\nDEBUG_DUMP("KeyIV:", pEAPKey->key_iv, 16);\r\nDEBUG_DUMP("decryption_key:", decryption_key, 16);\r\ntmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\nmemcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\nsa->next=tmp_sa;\r\nif (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){\r\nguint8 new_key[32];\r\nguint8 dummy[256];\r\nrc4_state_struct rc4_state;\r\nsa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\nmemcpy(new_key, pEAPKey->key_iv, 16);\r\nmemcpy(new_key+16, decryption_key, 16);\r\nDEBUG_DUMP("FullDecrKey:", new_key, 32);\r\ncrypt_rc4_init(&rc4_state, new_key, sizeof(new_key));\r\ncrypt_rc4(&rc4_state, dummy, 256);\r\ncrypt_rc4(&rc4_state, szEncryptedKey, key_bytes_len);\r\n} else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\r\nguint8 key_found;\r\nguint8 key_length;\r\nguint16 key_index;\r\nguint8 *decrypted_data;\r\ndecrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey, key_bytes_len);\r\nkey_found = FALSE;\r\nkey_index = 0;\r\nwhile(key_index < (key_bytes_len - 6) && !key_found){\r\nguint8 rsn_id;\r\nguint32 type;\r\nrsn_id = decrypted_data[key_index];\r\ntype = ((decrypted_data[key_index + 2] << 24) +\r\n(decrypted_data[key_index + 3] << 16) +\r\n(decrypted_data[key_index + 4] << 8) +\r\n(decrypted_data[key_index + 5]));\r\nif (rsn_id == 0xdd && type == 0x000fac01) {\r\nkey_found = TRUE;\r\n} else {\r\nkey_index += decrypted_data[key_index+1]+2;\r\n}\r\n}\r\nif (key_found){\r\nkey_length = decrypted_data[key_index+1] - 6;\r\nif (key_index+8 >= key_bytes_len ||\r\nkey_length > key_bytes_len - key_index - 8) {\r\ng_free(decrypted_data);\r\ng_free(szEncryptedKey);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nmemcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);\r\n} else {\r\ng_free(decrypted_data);\r\ng_free(szEncryptedKey);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nif (key_length == TKIP_GROUP_KEY_LEN)\r\nsa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;\r\nelse\r\nsa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\ng_free(decrypted_data);\r\n}\r\nkey_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;\r\nif (key_len > key_bytes_len) {\r\ng_free(szEncryptedKey);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nDEBUG_DUMP("Broadcast key:", szEncryptedKey, key_len);\r\nsa->key = &dummy_key;\r\nsa->validKey = TRUE;\r\nmemset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));\r\nmemcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);\r\ng_free(szEncryptedKey);\r\nreturn AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n}\r\nstatic PAIRPDCAP_SEC_ASSOCIATION\r\nAirPDcapGetSaPtr(\r\nPAIRPDCAP_CONTEXT ctx,\r\nAIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\nint sa_index;\r\nif ((sa_index=AirPDcapGetSa(ctx, id))==-1) {\r\nif ((sa_index=AirPDcapStoreSa(ctx, id))==-1) {\r\nreturn NULL;\r\n}\r\n}\r\nreturn &ctx->sa[sa_index];\r\n}\r\nstatic INT AirPDcapScanForKeys(\r\nPAIRPDCAP_CONTEXT ctx,\r\nconst guint8 *data,\r\nconst guint mac_header_len,\r\nconst guint tot_len,\r\nAIRPDCAP_SEC_ASSOCIATION_ID id\r\n)\r\n{\r\nconst UCHAR *addr;\r\nguint bodyLength;\r\nPAIRPDCAP_SEC_ASSOCIATION sta_sa;\r\nPAIRPDCAP_SEC_ASSOCIATION sa;\r\nguint offset = 0;\r\nconst guint8 dot1x_header[] = {\r\n0xAA,\r\n0xAA,\r\n0x03,\r\n0x00, 0x00, 0x00,\r\n0x88, 0x8E\r\n};\r\nconst guint8 bt_dot1x_header[] = {\r\n0xAA,\r\n0xAA,\r\n0x03,\r\n0x00, 0x19, 0x58,\r\n0x00, 0x03\r\n};\r\nconst guint8 tdls_header[] = {\r\n0xAA,\r\n0xAA,\r\n0x03,\r\n0x00, 0x00, 0x00,\r\n0x89, 0x0D,\r\n0x02,\r\n0X0C\r\n};\r\nconst EAPOL_RSN_KEY *pEAPKey;\r\n#ifdef _DEBUG\r\n#define MSGBUF_LEN 255\r\nCHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\nAIRPDCAP_DEBUG_TRACE_START("AirPDcapScanForKeys");\r\noffset = mac_header_len;\r\nif (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Authentication: EAPOL packet", AIRPDCAP_DEBUG_LEVEL_3);\r\noffset+=8;\r\nif (data[offset+1]!=3) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Not EAPOL-Key", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nbodyLength=pntoh16(data+offset+2);\r\nif (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "EAPOL body too short", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\noffset+=4;\r\npEAPKey = (const EAPOL_RSN_KEY *) (data+offset);\r\nif (\r\npEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&\r\npEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)\r\n{\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Not valid key descriptor type", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\noffset+=1;\r\nsa = AirPDcapGetSaPtr(ctx, &id);\r\nif (sa == NULL){\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "No SA for BSSID found", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nif (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)\r\nreturn AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\nif (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Message too short for Group Key", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nif (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||\r\nAIRPDCAP_EAP_ACK(data[offset+1])!=1 ||\r\nAIRPDCAP_EAP_MIC(data[offset]) != 1 ||\r\nAIRPDCAP_EAP_SEC(data[offset]) != 1){\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Key bitfields not correct for Group Key", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nmemcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\nsa = AirPDcapGetSaPtr(ctx, &id);\r\nif (sa == NULL){\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nif ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {\r\nmemcpy(id.sta, addr, AIRPDCAP_MAC_LEN);\r\n#ifdef _DEBUG\r\ng_snprintf(msgbuf, MSGBUF_LEN, "ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\t", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\n#endif\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n} else {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "SA not found", AIRPDCAP_DEBUG_LEVEL_5);\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nsta_sa = AirPDcapGetSaPtr(ctx, &id);\r\nif (sta_sa == NULL){\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nreturn (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));\r\n} else if (memcmp(data+offset, tdls_header, 10) == 0) {\r\nconst guint8 *initiator, *responder;\r\nguint8 action;\r\nguint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Authentication: TDLS Action Frame", AIRPDCAP_DEBUG_LEVEL_3);\r\noffset+=10;\r\naction = data[offset];\r\nif (action!=1 && action!=2) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Not Response nor confirm", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\noffset++;\r\nstatus=pntoh16(data+offset);\r\nif (status!=0) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "TDLS setup not successfull", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\noffset+=5;\r\nwhile(offset < (tot_len - 2)) {\r\nif (data[offset] == 48) {\r\noffset_rsne = offset;\r\n} else if (data[offset] == 55) {\r\noffset_fte = offset;\r\n} else if (data[offset] == 56) {\r\noffset_timeout = offset;\r\n} else if (data[offset] == 101) {\r\noffset_link = offset;\r\n}\r\nif (tot_len < offset + data[offset + 1] + 2) {\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\noffset += data[offset + 1] + 2;\r\n}\r\nif (offset_rsne == 0 || offset_fte == 0 ||\r\noffset_timeout == 0 || offset_link == 0)\r\n{\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Cannot Find all necessary IEs", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Found RSNE/Fast BSS/Timeout Interval/Link IEs", AIRPDCAP_DEBUG_LEVEL_3);\r\ninitiator = &data[offset_link + 8];\r\nresponder = &data[offset_link + 14];\r\nif (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\nmemcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);\r\nmemcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);\r\n} else {\r\nmemcpy(id.sta, responder, AIRPDCAP_MAC_LEN);\r\nmemcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);\r\n}\r\nsa = AirPDcapGetSaPtr(ctx, &id);\r\nif (sa == NULL){\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nif (sa->validKey) {\r\nif (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {\r\nreturn AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n} else {\r\nAIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\nmemcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\nsa->next=tmp_sa;\r\nsa->validKey = FALSE;\r\n}\r\n}\r\nif (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)\r\n== AIRPDCAP_RET_SUCCESS) {\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapScanForKeys");\r\nreturn AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n}\r\n} else {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapScanForKeys", "Skipping: not an EAPOL packet", AIRPDCAP_DEBUG_LEVEL_3);\r\n}\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapScanForKeys");\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nINT AirPDcapPacketProcess(\r\nPAIRPDCAP_CONTEXT ctx,\r\nconst guint8 *data,\r\nconst guint mac_header_len,\r\nconst guint tot_len,\r\nUCHAR *decrypt_data,\r\nguint *decrypt_len,\r\nPAIRPDCAP_KEY_ITEM key,\r\ngboolean scanHandshake)\r\n{\r\nAIRPDCAP_SEC_ASSOCIATION_ID id;\r\nUCHAR tmp_data[AIRPDCAP_MAX_CAPLEN];\r\nguint tmp_len;\r\n#ifdef _DEBUG\r\n#define MSGBUF_LEN 255\r\nCHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\nAIRPDCAP_DEBUG_TRACE_START("AirPDcapPacketProcess");\r\nif (ctx==NULL) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "NULL context", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapPacketProcess");\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nif (data==NULL || tot_len==0) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "NULL data or length=0", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapPacketProcess");\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nif (!((AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_DATA) ||\r\n(AIRPDCAP_TYPE(data[0])==AIRPDCAP_TYPE_MANAGEMENT &&\r\n(AIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DISASS ||\r\nAIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_DEAUTHENTICATION ||\r\nAIRPDCAP_SUBTYPE(data[0])==AIRPDCAP_SUBTYPE_ACTION)))) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "not data nor robust mgmt packet", AIRPDCAP_DEBUG_LEVEL_5);\r\nreturn AIRPDCAP_RET_NO_DATA;\r\n}\r\nif (tot_len < (UINT)(mac_header_len+AIRPDCAP_CRYPTED_DATA_MINLEN)) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "minimum length violated", AIRPDCAP_DEBUG_LEVEL_5);\r\nreturn AIRPDCAP_RET_WRONG_DATA_SIZE;\r\n}\r\nif (tot_len > AIRPDCAP_MAX_CAPLEN) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "length too large", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\nif (AirPDcapGetSaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data), &id) != AIRPDCAP_RET_SUCCESS) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "STA/BSSID not found", AIRPDCAP_DEBUG_LEVEL_5);\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nif (AIRPDCAP_WEP(data[1])==0) {\r\nif (scanHandshake) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "Unencrypted data", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn (AirPDcapScanForKeys(ctx, data, mac_header_len, tot_len, id));\r\n}\r\nreturn AIRPDCAP_RET_NO_DATA_ENCRYPTED;\r\n} else {\r\nPAIRPDCAP_SEC_ASSOCIATION sa;\r\nint offset = 0;\r\nsa = AirPDcapGetSaPtr(ctx, &id);\r\nif (sa == NULL){\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\noffset = mac_header_len;\r\nif (decrypt_data==NULL) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "no decrypt buffer, use local", AIRPDCAP_DEBUG_LEVEL_3);\r\ndecrypt_data=tmp_data;\r\ndecrypt_len=&tmp_len;\r\n}\r\n*decrypt_len = tot_len;\r\nmemcpy(decrypt_data, data, *decrypt_len);\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "Encrypted data", AIRPDCAP_DEBUG_LEVEL_3);\r\nif (AIRPDCAP_EXTIV(data[offset+3])==0) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "WEP encryption", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AirPDcapWepMng(ctx, decrypt_data, mac_header_len, decrypt_len, key, sa, offset);\r\n} else {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "TKIP or CCMP encryption", AIRPDCAP_DEBUG_LEVEL_3);\r\nif (AIRPDCAP_KEY_INDEX(data[offset+3])>=1){\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", "The key index >= 1. This is encrypted with a group key.", AIRPDCAP_DEBUG_LEVEL_3);\r\nmemcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\n#ifdef _DEBUG\r\ng_snprintf(msgbuf, MSGBUF_LEN, "ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\t", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapPacketProcess", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n#endif\r\nsa = AirPDcapGetSaPtr(ctx, &id);\r\nif (sa == NULL)\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nif (AirPDcapRsnaMng(decrypt_data, mac_header_len, decrypt_len, key, sa, offset) == AIRPDCAP_RET_SUCCESS) {\r\nif (scanHandshake) {\r\nreturn (AirPDcapScanForKeys(ctx, decrypt_data, mac_header_len, *decrypt_len, id));\r\n} else {\r\nreturn AIRPDCAP_RET_SUCCESS;\r\n}\r\n}\r\n}\r\n}\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\nINT AirPDcapSetKeys(\r\nPAIRPDCAP_CONTEXT ctx,\r\nAIRPDCAP_KEY_ITEM keys[],\r\nconst size_t keys_nr)\r\n{\r\nINT i;\r\nINT success;\r\nAIRPDCAP_DEBUG_TRACE_START("AirPDcapSetKeys");\r\nif (ctx==NULL || keys==NULL) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapSetKeys", "NULL context or NULL keys array", AIRPDCAP_DEBUG_LEVEL_3);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapSetKeys");\r\nreturn 0;\r\n}\r\nif (keys_nr>AIRPDCAP_MAX_KEYS_NR) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapSetKeys", "Keys number greater than maximum", AIRPDCAP_DEBUG_LEVEL_3);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapSetKeys");\r\nreturn 0;\r\n}\r\nAirPDcapInitContext(ctx);\r\nfor (i=0, success=0; i<(INT)keys_nr; i++) {\r\nif (AirPDcapValidateKey(keys+i)==TRUE) {\r\nif (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapSetKeys", "Set a WPA-PWD key", AIRPDCAP_DEBUG_LEVEL_4);\r\nAirPDcapRsnaPwd2Psk(keys[i].UserPwd.Passphrase, keys[i].UserPwd.Ssid, keys[i].UserPwd.SsidLen, keys[i].KeyData.Wpa.Psk);\r\n}\r\n#ifdef _DEBUG\r\nelse if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapSetKeys", "Set a WPA-PMK key", AIRPDCAP_DEBUG_LEVEL_4);\r\n} else if (keys[i].KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapSetKeys", "Set a WEP key", AIRPDCAP_DEBUG_LEVEL_4);\r\n} else {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapSetKeys", "Set a key", AIRPDCAP_DEBUG_LEVEL_4);\r\n}\r\n#endif\r\nmemcpy(&ctx->keys[success], &keys[i], sizeof(keys[i]));\r\nsuccess++;\r\n}\r\n}\r\nctx->keys_nr=success;\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapSetKeys");\r\nreturn success;\r\n}\r\nstatic void\r\nAirPDcapCleanKeys(\r\nPAIRPDCAP_CONTEXT ctx)\r\n{\r\nAIRPDCAP_DEBUG_TRACE_START("AirPDcapCleanKeys");\r\nif (ctx==NULL) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapCleanKeys", "NULL context", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapCleanKeys");\r\nreturn;\r\n}\r\nmemset(ctx->keys, 0, sizeof(AIRPDCAP_KEY_ITEM) * AIRPDCAP_MAX_KEYS_NR);\r\nctx->keys_nr=0;\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapCleanKeys", "Keys collection cleaned!", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapCleanKeys");\r\n}\r\nstatic void\r\nAirPDcapRecurseCleanSA(\r\nPAIRPDCAP_SEC_ASSOCIATION sa)\r\n{\r\nif (sa->next != NULL) {\r\nAirPDcapRecurseCleanSA(sa->next);\r\ng_free(sa->next);\r\nsa->next = NULL;\r\n}\r\n}\r\nstatic void\r\nAirPDcapCleanSecAssoc(\r\nPAIRPDCAP_CONTEXT ctx)\r\n{\r\nPAIRPDCAP_SEC_ASSOCIATION psa;\r\nint i;\r\nfor (psa = ctx->sa, i = 0; i < AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; i++, psa++) {\r\nAirPDcapRecurseCleanSA(psa);\r\n}\r\n}\r\nINT AirPDcapGetKeys(\r\nconst PAIRPDCAP_CONTEXT ctx,\r\nAIRPDCAP_KEY_ITEM keys[],\r\nconst size_t keys_nr)\r\n{\r\nUINT i;\r\nUINT j;\r\nAIRPDCAP_DEBUG_TRACE_START("AirPDcapGetKeys");\r\nif (ctx==NULL) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapGetKeys", "NULL context", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapGetKeys");\r\nreturn 0;\r\n} else if (keys==NULL) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapGetKeys", "NULL keys array", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapGetKeys");\r\nreturn (INT)ctx->keys_nr;\r\n} else {\r\nfor (i=0, j=0; i<ctx->keys_nr && i<keys_nr && i<AIRPDCAP_MAX_KEYS_NR; i++) {\r\nmemcpy(&keys[j], &ctx->keys[i], sizeof(keys[j]));\r\nj++;\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapGetKeys", "Got a key", AIRPDCAP_DEBUG_LEVEL_5);\r\n}\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapGetKeys");\r\nreturn j;\r\n}\r\n}\r\nINT AirPDcapSetLastSSID(\r\nPAIRPDCAP_CONTEXT ctx,\r\nCHAR *pkt_ssid,\r\nsize_t pkt_ssid_len)\r\n{\r\nif (!ctx || !pkt_ssid || pkt_ssid_len < 1 || pkt_ssid_len > WPA_SSID_MAX_SIZE)\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\nmemcpy(ctx->pkt_ssid, pkt_ssid, pkt_ssid_len);\r\nctx->pkt_ssid_len = pkt_ssid_len;\r\nreturn AIRPDCAP_RET_SUCCESS;\r\n}\r\nINT AirPDcapInitContext(\r\nPAIRPDCAP_CONTEXT ctx)\r\n{\r\nAIRPDCAP_DEBUG_TRACE_START("AirPDcapInitContext");\r\nif (ctx==NULL) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapInitContext", "NULL context", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapInitContext");\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\nAirPDcapCleanKeys(ctx);\r\nctx->first_free_index=0;\r\nctx->index=-1;\r\nctx->sa_index=-1;\r\nctx->pkt_ssid_len = 0;\r\nmemset(ctx->sa, 0, AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR * sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapInitContext", "Context initialized!", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapInitContext");\r\nreturn AIRPDCAP_RET_SUCCESS;\r\n}\r\nINT AirPDcapDestroyContext(\r\nPAIRPDCAP_CONTEXT ctx)\r\n{\r\nAIRPDCAP_DEBUG_TRACE_START("AirPDcapDestroyContext");\r\nif (ctx==NULL) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapDestroyContext", "NULL context", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapDestroyContext");\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\nAirPDcapCleanKeys(ctx);\r\nAirPDcapCleanSecAssoc(ctx);\r\nctx->first_free_index=0;\r\nctx->index=-1;\r\nctx->sa_index=-1;\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapDestroyContext", "Context destroyed!", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapDestroyContext");\r\nreturn AIRPDCAP_RET_SUCCESS;\r\n}\r\nstatic INT\r\nAirPDcapRsnaMng(\r\nUCHAR *decrypt_data,\r\nguint mac_header_len,\r\nguint *decrypt_len,\r\nPAIRPDCAP_KEY_ITEM key,\r\nAIRPDCAP_SEC_ASSOCIATION *sa,\r\nINT offset)\r\n{\r\nINT ret_value=1;\r\nUCHAR *try_data;\r\nguint try_data_len = *decrypt_len;\r\nif (*decrypt_len > try_data_len) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsnaMng", "Invalid decryption length", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\ntry_data=(UCHAR *)g_malloc(try_data_len);\r\nfor(; sa != NULL ;sa=sa->next) {\r\nif (sa->validKey==FALSE) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsnaMng", "Key not yet valid", AIRPDCAP_DEBUG_LEVEL_3);\r\ncontinue;\r\n}\r\nmemcpy(try_data, decrypt_data, *decrypt_len);\r\nif (sa->wpa.key_ver==1) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsnaMng", "TKIP", AIRPDCAP_DEBUG_LEVEL_3);\r\nDEBUG_DUMP("ptk", sa->wpa.ptk, 64);\r\nDEBUG_DUMP("ptk portion used", AIRPDCAP_GET_TK(sa->wpa.ptk), 16);\r\nret_value=AirPDcapTkipDecrypt(try_data+offset, *decrypt_len-offset, try_data+AIRPDCAP_TA_OFFSET, AIRPDCAP_GET_TK(sa->wpa.ptk));\r\nif (ret_value){\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsnaMng", "TKIP failed!", AIRPDCAP_DEBUG_LEVEL_3);\r\ncontinue;\r\n}\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsnaMng", "TKIP DECRYPTED!!!", AIRPDCAP_DEBUG_LEVEL_3);\r\n*decrypt_len-=12;\r\nbreak;\r\n} else {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsnaMng", "CCMP", AIRPDCAP_DEBUG_LEVEL_3);\r\nret_value=AirPDcapCcmpDecrypt(try_data, mac_header_len, (INT)*decrypt_len, AIRPDCAP_GET_TK(sa->wpa.ptk));\r\nif (ret_value)\r\ncontinue;\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsnaMng", "CCMP DECRYPTED!!!", AIRPDCAP_DEBUG_LEVEL_3);\r\n*decrypt_len-=8;\r\nbreak;\r\n}\r\n}\r\nif(sa == NULL) {\r\ng_free(try_data);\r\nreturn ret_value;\r\n}\r\nif (*decrypt_len > try_data_len || *decrypt_len < 8) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsnaMng", "Invalid decryption length", AIRPDCAP_DEBUG_LEVEL_3);\r\ng_free(try_data);\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\nmemcpy(decrypt_data, try_data, *decrypt_len);\r\ng_free(try_data);\r\ndecrypt_data[1]&=0xBF;\r\noffset = mac_header_len;\r\n*decrypt_len-=8;\r\nmemmove(decrypt_data+offset, decrypt_data+offset+8, *decrypt_len-offset);\r\nif (key!=NULL) {\r\nif (sa->key!=NULL)\r\nmemcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\r\nelse\r\nmemset(key, 0, sizeof(AIRPDCAP_KEY_ITEM));\r\nmemcpy(key->KeyData.Wpa.Ptk, sa->wpa.ptk, AIRPDCAP_WPA_PTK_LEN);\r\nif (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)\r\nkey->KeyType=AIRPDCAP_KEY_TYPE_TKIP;\r\nelse if (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP)\r\nkey->KeyType=AIRPDCAP_KEY_TYPE_CCMP;\r\n}\r\nreturn AIRPDCAP_RET_SUCCESS;\r\n}\r\nstatic INT\r\nAirPDcapWepMng(\r\nPAIRPDCAP_CONTEXT ctx,\r\nUCHAR *decrypt_data,\r\nguint mac_header_len,\r\nguint *decrypt_len,\r\nPAIRPDCAP_KEY_ITEM key,\r\nAIRPDCAP_SEC_ASSOCIATION *sa,\r\nINT offset)\r\n{\r\nUCHAR wep_key[AIRPDCAP_WEP_KEY_MAXLEN+AIRPDCAP_WEP_IVLEN];\r\nsize_t keylen;\r\nINT ret_value=1;\r\nINT key_index;\r\nAIRPDCAP_KEY_ITEM *tmp_key;\r\nUINT8 useCache=FALSE;\r\nUCHAR *try_data;\r\nguint try_data_len = *decrypt_len;\r\ntry_data = (UCHAR *)g_malloc(try_data_len);\r\nif (sa->key!=NULL)\r\nuseCache=TRUE;\r\nfor (key_index=0; key_index<(INT)ctx->keys_nr; key_index++) {\r\nif (!useCache) {\r\ntmp_key=&ctx->keys[key_index];\r\n} else {\r\nif (sa->key!=NULL && sa->key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapWepMng", "Try cached WEP key...", AIRPDCAP_DEBUG_LEVEL_3);\r\ntmp_key=sa->key;\r\n} else {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapWepMng", "Cached key is not valid, try another WEP key...", AIRPDCAP_DEBUG_LEVEL_3);\r\ntmp_key=&ctx->keys[key_index];\r\n}\r\n}\r\nif (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapWepMng", "Try WEP key...", AIRPDCAP_DEBUG_LEVEL_3);\r\nmemset(wep_key, 0, sizeof(wep_key));\r\nmemcpy(try_data, decrypt_data, *decrypt_len);\r\nmemcpy(wep_key, try_data+mac_header_len, AIRPDCAP_WEP_IVLEN);\r\nkeylen=tmp_key->KeyData.Wep.WepKeyLen;\r\nmemcpy(wep_key+AIRPDCAP_WEP_IVLEN, tmp_key->KeyData.Wep.WepKey, keylen);\r\nret_value=AirPDcapWepDecrypt(wep_key,\r\nkeylen+AIRPDCAP_WEP_IVLEN,\r\ntry_data + (mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN),\r\n*decrypt_len-(mac_header_len+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN+AIRPDCAP_CRC_LEN));\r\nif (ret_value == AIRPDCAP_RET_SUCCESS)\r\nmemcpy(decrypt_data, try_data, *decrypt_len);\r\n}\r\nif (!ret_value && tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WEP) {\r\nsa->key=tmp_key;\r\nif (key!=NULL) {\r\nmemcpy(key, sa->key, sizeof(AIRPDCAP_KEY_ITEM));\r\nkey->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\n}\r\nbreak;\r\n} else {\r\nif (useCache==TRUE) {\r\nuseCache=FALSE;\r\nkey_index--;\r\n}\r\n}\r\n}\r\ng_free(try_data);\r\nif (ret_value)\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapWepMng", "WEP DECRYPTED!!!", AIRPDCAP_DEBUG_LEVEL_3);\r\n*decrypt_len-=4;\r\nif (*decrypt_len < 4) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapWepMng", "Decryption length too short", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\ndecrypt_data[1]&=0xBF;\r\noffset = mac_header_len;\r\n*decrypt_len-=4;\r\nmemmove(decrypt_data+offset, decrypt_data+offset+AIRPDCAP_WEP_IVLEN+AIRPDCAP_WEP_KIDLEN, *decrypt_len-offset);\r\nreturn AIRPDCAP_RET_SUCCESS;\r\n}\r\nstatic INT\r\nAirPDcapRsna4WHandshake(\r\nPAIRPDCAP_CONTEXT ctx,\r\nconst UCHAR *data,\r\nAIRPDCAP_SEC_ASSOCIATION *sa,\r\nINT offset,\r\nconst guint tot_len)\r\n{\r\nAIRPDCAP_KEY_ITEM *tmp_key, *tmp_pkt_key, pkt_key;\r\nAIRPDCAP_SEC_ASSOCIATION *tmp_sa;\r\nINT key_index;\r\nINT ret_value=1;\r\nUCHAR useCache=FALSE;\r\nUCHAR eapol[AIRPDCAP_EAPOL_MAX_LEN];\r\nUSHORT eapol_len;\r\nif (sa->key!=NULL)\r\nuseCache=TRUE;\r\nif (AIRPDCAP_EAP_KEY(data[offset+1])!=1) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "Group/STAKey message (not used)", AIRPDCAP_DEBUG_LEVEL_5);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "4-way handshake...", AIRPDCAP_DEBUG_LEVEL_5);\r\nif (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\nAIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\nAIRPDCAP_EAP_MIC(data[offset])==0)\r\n{\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "4-way handshake message 1", AIRPDCAP_DEBUG_LEVEL_3);\r\nif( sa->handshake >= 2) {\r\ntmp_sa= g_new(AIRPDCAP_SEC_ASSOCIATION, 1);\r\nmemcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\nsa->validKey=FALSE;\r\nsa->next=tmp_sa;\r\n}\r\nmemcpy(sa->wpa.nonce, data+offset+12, 32);\r\nsa->wpa.key_ver=AIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]);\r\nsa->handshake=1;\r\nreturn AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n}\r\nif (AIRPDCAP_EAP_INST(data[offset+1])==0 &&\r\nAIRPDCAP_EAP_ACK(data[offset+1])==0 &&\r\nAIRPDCAP_EAP_MIC(data[offset])==1)\r\n{\r\nif (pntoh16(data+offset+92)) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "4-way handshake message 2", AIRPDCAP_DEBUG_LEVEL_3);\r\nfor (key_index=0; key_index<(INT)ctx->keys_nr || useCache; key_index++) {\r\nif (!useCache) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "Try WPA key...", AIRPDCAP_DEBUG_LEVEL_3);\r\ntmp_key=&ctx->keys[key_index];\r\n} else {\r\nif (sa->key!=NULL &&\r\n(sa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\nsa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\nsa->key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "Try cached WPA key...", AIRPDCAP_DEBUG_LEVEL_3);\r\ntmp_key=sa->key;\r\n} else {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "Cached key is of a wrong type, try WPA key...", AIRPDCAP_DEBUG_LEVEL_3);\r\ntmp_key=&ctx->keys[key_index];\r\n}\r\n}\r\nif (tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\ntmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\ntmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK)\r\n{\r\nif (tmp_key->KeyType == AIRPDCAP_KEY_TYPE_WPA_PWD && tmp_key->UserPwd.SsidLen == 0 && ctx->pkt_ssid_len > 0 && ctx->pkt_ssid_len <= AIRPDCAP_WPA_SSID_MAX_LEN) {\r\nmemcpy(&pkt_key, tmp_key, sizeof(pkt_key));\r\nmemcpy(&pkt_key.UserPwd.Ssid, ctx->pkt_ssid, ctx->pkt_ssid_len);\r\npkt_key.UserPwd.SsidLen = ctx->pkt_ssid_len;\r\nAirPDcapRsnaPwd2Psk(pkt_key.UserPwd.Passphrase, pkt_key.UserPwd.Ssid,\r\npkt_key.UserPwd.SsidLen, pkt_key.KeyData.Wpa.Psk);\r\ntmp_pkt_key = &pkt_key;\r\n} else {\r\ntmp_pkt_key = tmp_key;\r\n}\r\nAirPDcapRsnaPrfX(sa,\r\ntmp_pkt_key->KeyData.Wpa.Psk,\r\ndata+offset+12,\r\n512,\r\nsa->wpa.ptk);\r\neapol_len=pntoh16(data+offset-3)+4;\r\nmemcpy(eapol, &data[offset-5], (eapol_len<AIRPDCAP_EAPOL_MAX_LEN?eapol_len:AIRPDCAP_EAPOL_MAX_LEN));\r\nret_value=AirPDcapRsnaMicCheck(eapol,\r\neapol_len,\r\nsa->wpa.ptk,\r\nAIRPDCAP_EAP_KEY_DESCR_VER(data[offset+1]));\r\n}\r\nif (!ret_value &&\r\n(tmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PWD ||\r\ntmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PSK ||\r\ntmp_key->KeyType==AIRPDCAP_KEY_TYPE_WPA_PMK))\r\n{\r\nsa->key=tmp_key;\r\nbreak;\r\n} else {\r\nif (useCache==TRUE) {\r\nuseCache=FALSE;\r\nkey_index--;\r\n}\r\n}\r\n}\r\nif (ret_value) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "handshake step failed", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nsa->handshake=2;\r\nsa->validKey=TRUE;\r\nreturn AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n} else {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "4-way handshake message 4", AIRPDCAP_DEBUG_LEVEL_3);\r\nsa->handshake=4;\r\nreturn AIRPDCAP_RET_SUCCESS_HANDSHAKE;\r\n}\r\n}\r\nif (AIRPDCAP_EAP_ACK(data[offset+1])==1 &&\r\nAIRPDCAP_EAP_MIC(data[offset])==1)\r\n{\r\nconst EAPOL_RSN_KEY *pEAPKey;\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapRsna4WHandshake", "4-way handshake message 3", AIRPDCAP_DEBUG_LEVEL_3);\r\npEAPKey = (const EAPOL_RSN_KEY *)(&(data[offset-1]));\r\nif (pEAPKey->type == AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR){\r\nPAIRPDCAP_SEC_ASSOCIATION broadcast_sa;\r\nAIRPDCAP_SEC_ASSOCIATION_ID id;\r\nmemcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);\r\nmemcpy(id.bssid, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\nbroadcast_sa = AirPDcapGetSaPtr(ctx, &id);\r\nif (broadcast_sa == NULL){\r\nreturn AIRPDCAP_RET_REQ_DATA;\r\n}\r\nreturn (AirPDcapDecryptWPABroadcastKey(pEAPKey, sa->wpa.ptk+16, broadcast_sa, tot_len-offset+1));\r\n}\r\n}\r\nreturn AIRPDCAP_RET_NO_VALID_HANDSHAKE;\r\n}\r\nstatic INT\r\nAirPDcapRsnaMicCheck(\r\nUCHAR *eapol,\r\nUSHORT eapol_len,\r\nUCHAR KCK[AIRPDCAP_WPA_KCK_LEN],\r\nUSHORT key_ver)\r\n{\r\nUCHAR mic[AIRPDCAP_WPA_MICKEY_LEN];\r\nUCHAR c_mic[20];\r\nmemcpy(mic, eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, AIRPDCAP_WPA_MICKEY_LEN);\r\nmemset(eapol+AIRPDCAP_WPA_MICKEY_OFFSET+4, 0, AIRPDCAP_WPA_MICKEY_LEN);\r\nif (key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP) {\r\nmd5_hmac(eapol, eapol_len, KCK, AIRPDCAP_WPA_KCK_LEN, c_mic);\r\n} else if (key_ver==AIRPDCAP_WPA_KEY_VER_AES_CCMP) {\r\nsha1_hmac(KCK, AIRPDCAP_WPA_KCK_LEN, eapol, eapol_len, c_mic);\r\n} else\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\nreturn memcmp(mic, c_mic, AIRPDCAP_WPA_MICKEY_LEN);\r\n}\r\nstatic INT\r\nAirPDcapValidateKey(\r\nPAIRPDCAP_KEY_ITEM key)\r\n{\r\nsize_t len;\r\nUCHAR ret=TRUE;\r\nAIRPDCAP_DEBUG_TRACE_START("AirPDcapValidateKey");\r\nif (key==NULL) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapValidateKey", "NULL key", AIRPDCAP_DEBUG_LEVEL_5);\r\nAIRPDCAP_DEBUG_TRACE_START("AirPDcapValidateKey");\r\nreturn FALSE;\r\n}\r\nswitch (key->KeyType) {\r\ncase AIRPDCAP_KEY_TYPE_WEP:\r\nlen=key->KeyData.Wep.WepKeyLen;\r\nif (len<AIRPDCAP_WEP_KEY_MINLEN || len>AIRPDCAP_WEP_KEY_MAXLEN) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapValidateKey", "WEP key: key length not accepted", AIRPDCAP_DEBUG_LEVEL_5);\r\nret=FALSE;\r\n}\r\nbreak;\r\ncase AIRPDCAP_KEY_TYPE_WEP_40:\r\nkey->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_40_KEY_LEN;\r\nkey->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\nbreak;\r\ncase AIRPDCAP_KEY_TYPE_WEP_104:\r\nkey->KeyData.Wep.WepKeyLen=AIRPDCAP_WEP_104_KEY_LEN;\r\nkey->KeyType=AIRPDCAP_KEY_TYPE_WEP;\r\nbreak;\r\ncase AIRPDCAP_KEY_TYPE_WPA_PWD:\r\nlen=strlen(key->UserPwd.Passphrase);\r\nif (len<AIRPDCAP_WPA_PASSPHRASE_MIN_LEN || len>AIRPDCAP_WPA_PASSPHRASE_MAX_LEN) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapValidateKey", "WPA-PWD key: passphrase length not accepted", AIRPDCAP_DEBUG_LEVEL_5);\r\nret=FALSE;\r\n}\r\nlen=key->UserPwd.SsidLen;\r\nif (len>AIRPDCAP_WPA_SSID_MAX_LEN) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapValidateKey", "WPA-PWD key: ssid length not accepted", AIRPDCAP_DEBUG_LEVEL_5);\r\nret=FALSE;\r\n}\r\nbreak;\r\ncase AIRPDCAP_KEY_TYPE_WPA_PSK:\r\nbreak;\r\ncase AIRPDCAP_KEY_TYPE_WPA_PMK:\r\nbreak;\r\ndefault:\r\nret=FALSE;\r\n}\r\nAIRPDCAP_DEBUG_TRACE_END("AirPDcapValidateKey");\r\nreturn ret;\r\n}\r\nstatic INT\r\nAirPDcapGetSa(\r\nPAIRPDCAP_CONTEXT ctx,\r\nAIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\nINT sa_index;\r\nif (ctx->sa_index!=-1) {\r\nfor (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\r\nif (ctx->sa[sa_index].used) {\r\nif (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\r\nctx->index=sa_index;\r\nreturn sa_index;\r\n}\r\n}\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic INT\r\nAirPDcapStoreSa(\r\nPAIRPDCAP_CONTEXT ctx,\r\nAIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\nINT last_free;\r\nif (ctx->first_free_index>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\r\nreturn -1;\r\n}\r\nif (ctx->sa[ctx->first_free_index].used) {\r\nfor (last_free=ctx->first_free_index; last_free<AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR; last_free++)\r\nif (!ctx->sa[last_free].used)\r\nbreak;\r\nif (last_free>=AIRPDCAP_MAX_SEC_ASSOCIATIONS_NR) {\r\nreturn -1;\r\n}\r\nctx->first_free_index=last_free;\r\n}\r\nctx->index=ctx->first_free_index;\r\nmemset(ctx->sa+ctx->index, 0, sizeof(AIRPDCAP_SEC_ASSOCIATION));\r\nctx->sa[ctx->index].used=1;\r\nmemcpy(&(ctx->sa[ctx->index].saId), id, sizeof(AIRPDCAP_SEC_ASSOCIATION_ID));\r\nctx->first_free_index++;\r\nif (ctx->index > ctx->sa_index)\r\nctx->sa_index=ctx->index;\r\nreturn ctx->index;\r\n}\r\nstatic INT\r\nAirPDcapGetSaAddress(\r\nconst AIRPDCAP_MAC_FRAME_ADDR4 *frame,\r\nAIRPDCAP_SEC_ASSOCIATION_ID *id)\r\n{\r\n#ifdef _DEBUG\r\n#define MSGBUF_LEN 255\r\nCHAR msgbuf[MSGBUF_LEN];\r\n#endif\r\nif ((AIRPDCAP_TYPE(frame->fc[0])==AIRPDCAP_TYPE_DATA) &&\r\n(AIRPDCAP_DS_BITS(frame->fc[1]) == 0) &&\r\n(memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) != 0) &&\r\n(memcmp(frame->addr1, frame->addr3, AIRPDCAP_MAC_LEN) != 0)) {\r\nif (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0) {\r\nmemcpy(id->sta, frame->addr1, AIRPDCAP_MAC_LEN);\r\nmemcpy(id->bssid, frame->addr2, AIRPDCAP_MAC_LEN);\r\n} else {\r\nmemcpy(id->sta, frame->addr2, AIRPDCAP_MAC_LEN);\r\nmemcpy(id->bssid, frame->addr1, AIRPDCAP_MAC_LEN);\r\n}\r\n} else {\r\nconst UCHAR *addr;\r\nif ((addr = AirPDcapGetBssidAddress(frame)) != NULL) {\r\nmemcpy(id->bssid, addr, AIRPDCAP_MAC_LEN);\r\n} else {\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\nif ((addr = AirPDcapGetStaAddress(frame)) != NULL) {\r\nmemcpy(id->sta, addr, AIRPDCAP_MAC_LEN);\r\n} else {\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\n}\r\n#ifdef _DEBUG\r\ng_snprintf(msgbuf, MSGBUF_LEN, "BSSID_MAC: %02X.%02X.%02X.%02X.%02X.%02X\t",\r\nid->bssid[0],id->bssid[1],id->bssid[2],id->bssid[3],id->bssid[4],id->bssid[5]);\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapGetSaAddress", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\ng_snprintf(msgbuf, MSGBUF_LEN, "STA_MAC: %02X.%02X.%02X.%02X.%02X.%02X\t",\r\nid->sta[0],id->sta[1],id->sta[2],id->sta[3],id->sta[4],id->sta[5]);\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapGetSaAddress", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);\r\n#endif\r\nreturn AIRPDCAP_RET_SUCCESS;\r\n}\r\nstatic const UCHAR *\r\nAirPDcapGetStaAddress(\r\nconst AIRPDCAP_MAC_FRAME_ADDR4 *frame)\r\n{\r\nswitch(AIRPDCAP_DS_BITS(frame->fc[1])) {\r\ncase 0:\r\nif (memcmp(frame->addr2, frame->addr3, AIRPDCAP_MAC_LEN) == 0)\r\nreturn frame->addr1;\r\nelse\r\nreturn frame->addr2;\r\ncase 1:\r\nreturn frame->addr2;\r\ncase 2:\r\nreturn frame->addr1;\r\ncase 3:\r\nif (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) < 0)\r\nreturn frame->addr1;\r\nelse\r\nreturn frame->addr2;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic const UCHAR *\r\nAirPDcapGetBssidAddress(\r\nconst AIRPDCAP_MAC_FRAME_ADDR4 *frame)\r\n{\r\nswitch(AIRPDCAP_DS_BITS(frame->fc[1])) {\r\ncase 0:\r\nreturn frame->addr3;\r\ncase 1:\r\nreturn frame->addr1;\r\ncase 2:\r\nreturn frame->addr2;\r\ncase 3:\r\nif (memcmp(frame->addr1, frame->addr2, AIRPDCAP_MAC_LEN) > 0)\r\nreturn frame->addr1;\r\nelse\r\nreturn frame->addr2;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic void\r\nAirPDcapRsnaPrfX(\r\nAIRPDCAP_SEC_ASSOCIATION *sa,\r\nconst UCHAR pmk[32],\r\nconst UCHAR snonce[32],\r\nconst INT x,\r\nUCHAR *ptk)\r\n{\r\nUINT8 i;\r\nUCHAR R[100];\r\nINT offset=sizeof("Pairwise key expansion");\r\nUCHAR output[80];\r\nmemset(R, 0, 100);\r\nmemcpy(R, "Pairwise key expansion", offset);\r\nif (memcmp(sa->saId.sta, sa->saId.bssid, AIRPDCAP_MAC_LEN) < 0)\r\n{\r\nmemcpy(R + offset, sa->saId.sta, AIRPDCAP_MAC_LEN);\r\nmemcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\n}\r\nelse\r\n{\r\nmemcpy(R + offset, sa->saId.bssid, AIRPDCAP_MAC_LEN);\r\nmemcpy(R + offset+AIRPDCAP_MAC_LEN, sa->saId.sta, AIRPDCAP_MAC_LEN);\r\n}\r\noffset+=AIRPDCAP_MAC_LEN*2;\r\nif( memcmp(snonce, sa->wpa.nonce, 32) < 0 )\r\n{\r\nmemcpy(R + offset, snonce, 32);\r\nmemcpy(R + offset + 32, sa->wpa.nonce, 32);\r\n}\r\nelse\r\n{\r\nmemcpy(R + offset, sa->wpa.nonce, 32);\r\nmemcpy(R + offset + 32, snonce, 32);\r\n}\r\noffset+=32*2;\r\nfor(i = 0; i < (x+159)/160; i++)\r\n{\r\nR[offset] = i;\r\nsha1_hmac(pmk, 32, R, 100, &output[20 * i]);\r\n}\r\nmemcpy(ptk, output, x/8);\r\n}\r\nstatic INT\r\nAirPDcapRsnaPwd2PskStep(\r\nconst guint8 *ppBytes,\r\nconst guint ppLength,\r\nconst CHAR *ssid,\r\nconst size_t ssidLength,\r\nconst INT iterations,\r\nconst INT count,\r\nUCHAR *output)\r\n{\r\nUCHAR digest[MAX_SSID_LENGTH+4];\r\nUCHAR digest1[SHA1_DIGEST_LEN];\r\nINT i, j;\r\nif (ssidLength > MAX_SSID_LENGTH) {\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\nmemset(digest, 0, sizeof digest);\r\nmemset(digest1, 0, sizeof digest1);\r\nmemcpy(digest, ssid, ssidLength);\r\ndigest[ssidLength] = (UCHAR)((count>>24) & 0xff);\r\ndigest[ssidLength+1] = (UCHAR)((count>>16) & 0xff);\r\ndigest[ssidLength+2] = (UCHAR)((count>>8) & 0xff);\r\ndigest[ssidLength+3] = (UCHAR)(count & 0xff);\r\nsha1_hmac(ppBytes, ppLength, digest, (guint32) ssidLength+4, digest1);\r\nmemcpy(output, digest1, SHA1_DIGEST_LEN);\r\nfor (i = 1; i < iterations; i++) {\r\nsha1_hmac(ppBytes, ppLength, digest1, SHA1_DIGEST_LEN, digest);\r\nmemcpy(digest1, digest, SHA1_DIGEST_LEN);\r\nfor (j = 0; j < SHA1_DIGEST_LEN; j++) {\r\noutput[j] ^= digest[j];\r\n}\r\n}\r\nreturn AIRPDCAP_RET_SUCCESS;\r\n}\r\nstatic INT\r\nAirPDcapRsnaPwd2Psk(\r\nconst CHAR *passphrase,\r\nconst CHAR *ssid,\r\nconst size_t ssidLength,\r\nUCHAR *output)\r\n{\r\nUCHAR m_output[2*SHA1_DIGEST_LEN];\r\nGByteArray *pp_ba = g_byte_array_new();\r\nmemset(m_output, 0, 2*SHA1_DIGEST_LEN);\r\nif (!uri_str_to_bytes(passphrase, pp_ba)) {\r\ng_byte_array_free(pp_ba, TRUE);\r\nreturn 0;\r\n}\r\nAirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 1, m_output);\r\nAirPDcapRsnaPwd2PskStep(pp_ba->data, pp_ba->len, ssid, ssidLength, 4096, 2, &m_output[SHA1_DIGEST_LEN]);\r\nmemcpy(output, m_output, AIRPDCAP_WPA_PSK_LEN);\r\ng_byte_array_free(pp_ba, TRUE);\r\nreturn 0;\r\n}\r\ndecryption_key_t*\r\nparse_key_string(gchar* input_string, guint8 key_type)\r\n{\r\ngchar *key, *tmp_str;\r\ngchar *ssid;\r\nGString *key_string = NULL;\r\nGByteArray *ssid_ba = NULL, *key_ba;\r\ngboolean res;\r\ngchar **tokens;\r\nguint n = 0;\r\ndecryption_key_t *dk;\r\nif(input_string == NULL)\r\nreturn NULL;\r\nswitch(key_type)\r\n{\r\ncase AIRPDCAP_KEY_TYPE_WEP:\r\ncase AIRPDCAP_KEY_TYPE_WEP_40:\r\ncase AIRPDCAP_KEY_TYPE_WEP_104:\r\nkey_ba = g_byte_array_new();\r\nres = hex_str_to_bytes(input_string, key_ba, FALSE);\r\nif (res && key_ba->len > 0) {\r\ndk = (decryption_key_t *)g_malloc(sizeof(decryption_key_t));\r\ndk->type = AIRPDCAP_KEY_TYPE_WEP;\r\ntmp_str = bytes_to_str(NULL, key_ba->data, key_ba->len);\r\ndk->key = g_string_new(tmp_str);\r\ng_string_ascii_down(dk->key);\r\ndk->bits = key_ba->len * 8;\r\ndk->ssid = NULL;\r\nwmem_free(NULL, tmp_str);\r\ng_byte_array_free(key_ba, TRUE);\r\nreturn dk;\r\n}\r\ng_byte_array_free(key_ba, TRUE);\r\nreturn NULL;\r\ncase AIRPDCAP_KEY_TYPE_WPA_PWD:\r\ntokens = g_strsplit(input_string,":",0);\r\nwhile(tokens[n] != NULL)\r\nn++;\r\nif(n < 1)\r\n{\r\ng_strfreev(tokens);\r\nreturn NULL;\r\n}\r\nkey = g_strdup(tokens[0]);\r\nssid = NULL;\r\nif(n >= 2)\r\n{\r\nssid = g_strdup(tokens[1]);\r\n}\r\nkey_string = g_string_new(key);\r\nssid_ba = NULL;\r\nif( ((key_string->len) > WPA_KEY_MAX_CHAR_SIZE) || ((key_string->len) < WPA_KEY_MIN_CHAR_SIZE))\r\n{\r\ng_string_free(key_string, TRUE);\r\ng_free(key);\r\ng_free(ssid);\r\ng_strfreev(tokens);\r\nreturn NULL;\r\n}\r\nif(ssid != NULL)\r\n{\r\nssid_ba = g_byte_array_new();\r\nif (! uri_str_to_bytes(ssid, ssid_ba)) {\r\ng_string_free(key_string, TRUE);\r\ng_byte_array_free(ssid_ba, TRUE);\r\ng_free(key);\r\ng_free(ssid);\r\ng_strfreev(tokens);\r\nreturn NULL;\r\n}\r\nif(ssid_ba->len > WPA_SSID_MAX_CHAR_SIZE)\r\n{\r\ng_string_free(key_string, TRUE);\r\ng_byte_array_free(ssid_ba, TRUE);\r\ng_free(key);\r\ng_free(ssid);\r\ng_strfreev(tokens);\r\nreturn NULL;\r\n}\r\n}\r\ndk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\r\ndk->type = AIRPDCAP_KEY_TYPE_WPA_PWD;\r\ndk->key = g_string_new(key);\r\ndk->bits = 256;\r\ndk->ssid = byte_array_dup(ssid_ba);\r\ng_string_free(key_string, TRUE);\r\nif (ssid_ba != NULL)\r\ng_byte_array_free(ssid_ba, TRUE);\r\ng_free(key);\r\nif(ssid != NULL)\r\ng_free(ssid);\r\ng_strfreev(tokens);\r\nreturn dk;\r\ncase AIRPDCAP_KEY_TYPE_WPA_PSK:\r\nkey_ba = g_byte_array_new();\r\nres = hex_str_to_bytes(input_string, key_ba, FALSE);\r\nif(!res || ((key_ba->len) != WPA_PSK_KEY_SIZE))\r\n{\r\ng_byte_array_free(key_ba, TRUE);\r\nreturn NULL;\r\n}\r\ndk = (decryption_key_t*)g_malloc(sizeof(decryption_key_t));\r\ndk->type = AIRPDCAP_KEY_TYPE_WPA_PSK;\r\ndk->key = g_string_new(input_string);\r\ndk->bits = (guint) dk->key->len * 4;\r\ndk->ssid = NULL;\r\ng_byte_array_free(key_ba, TRUE);\r\nreturn dk;\r\n}\r\nreturn NULL;\r\n}\r\nvoid\r\nfree_key_string(decryption_key_t *dk)\r\n{\r\nif (dk->key)\r\ng_string_free(dk->key, TRUE);\r\nif (dk->ssid)\r\ng_byte_array_free(dk->ssid, TRUE);\r\ng_free(dk);\r\n}\r\ngchar*\r\nget_key_string(decryption_key_t* dk)\r\n{\r\ngchar* output_string = NULL;\r\nif(dk == NULL || dk->key == NULL)\r\nreturn NULL;\r\nswitch(dk->type) {\r\ncase AIRPDCAP_KEY_TYPE_WEP:\r\noutput_string = g_strdup(dk->key->str);\r\nbreak;\r\ncase AIRPDCAP_KEY_TYPE_WPA_PWD:\r\nif(dk->ssid == NULL)\r\noutput_string = g_strdup(dk->key->str);\r\nelse\r\noutput_string = g_strdup_printf("%s:%s",\r\ndk->key->str, format_uri(dk->ssid, ":"));\r\nbreak;\r\ncase AIRPDCAP_KEY_TYPE_WPA_PMK:\r\noutput_string = g_strdup(dk->key->str);\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nreturn output_string;\r\n}\r\nstatic INT\r\nAirPDcapTDLSDeriveKey(\r\nPAIRPDCAP_SEC_ASSOCIATION sa,\r\nconst guint8 *data,\r\nguint offset_rsne,\r\nguint offset_fte,\r\nguint offset_timeout,\r\nguint offset_link,\r\nguint8 action)\r\n{\r\nsha256_hmac_context sha_ctx;\r\naes_cmac_ctx aes_ctx;\r\nconst guint8 *snonce, *anonce, *initiator, *responder, *bssid;\r\nguint8 key_input[SHA256_DIGEST_LEN];\r\nguint8 mic[16], iter[2], length[2], seq_num = action + 1;\r\nanonce = &data[offset_fte + 20];\r\nsnonce = &data[offset_fte + 52];\r\nsha256_starts(&(sha_ctx.ctx));\r\nif (memcmp(anonce, snonce, AIRPDCAP_WPA_NONCE_LEN) < 0) {\r\nsha256_update(&(sha_ctx.ctx), anonce, AIRPDCAP_WPA_NONCE_LEN);\r\nsha256_update(&(sha_ctx.ctx), snonce, AIRPDCAP_WPA_NONCE_LEN);\r\n} else {\r\nsha256_update(&(sha_ctx.ctx), snonce, AIRPDCAP_WPA_NONCE_LEN);\r\nsha256_update(&(sha_ctx.ctx), anonce, AIRPDCAP_WPA_NONCE_LEN);\r\n}\r\nsha256_finish(&(sha_ctx.ctx), key_input);\r\nbssid = &data[offset_link + 2];\r\ninitiator = &data[offset_link + 8];\r\nresponder = &data[offset_link + 14];\r\nsha256_hmac_starts(&sha_ctx, key_input, SHA256_DIGEST_LEN);\r\niter[0] = 1;\r\niter[1] = 0;\r\nsha256_hmac_update(&sha_ctx, (const guint8 *)&iter, 2);\r\nsha256_hmac_update(&sha_ctx, "TDLS PMK", 8);\r\nif (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {\r\nsha256_hmac_update(&sha_ctx, initiator, AIRPDCAP_MAC_LEN);\r\nsha256_hmac_update(&sha_ctx, responder, AIRPDCAP_MAC_LEN);\r\n} else {\r\nsha256_hmac_update(&sha_ctx, responder, AIRPDCAP_MAC_LEN);\r\nsha256_hmac_update(&sha_ctx, initiator, AIRPDCAP_MAC_LEN);\r\n}\r\nsha256_hmac_update(&sha_ctx, bssid, AIRPDCAP_MAC_LEN);\r\nlength[0] = 256 & 0xff;\r\nlength[1] = (256 >> 8) & 0xff;\r\nsha256_hmac_update(&sha_ctx, (const guint8 *)&length, 2);\r\nsha256_hmac_finish(&sha_ctx, key_input);\r\naes_cmac_encrypt_starts(&aes_ctx, key_input, 16);\r\naes_cmac_encrypt_update(&aes_ctx, initiator, AIRPDCAP_MAC_LEN);\r\naes_cmac_encrypt_update(&aes_ctx, responder, AIRPDCAP_MAC_LEN);\r\naes_cmac_encrypt_update(&aes_ctx, &seq_num, 1);\r\naes_cmac_encrypt_update(&aes_ctx, &data[offset_link], data[offset_link + 1] + 2);\r\naes_cmac_encrypt_update(&aes_ctx, &data[offset_rsne], data[offset_rsne + 1] + 2);\r\naes_cmac_encrypt_update(&aes_ctx, &data[offset_timeout], data[offset_timeout + 1] + 2);\r\naes_cmac_encrypt_update(&aes_ctx, &data[offset_fte], 4);\r\nmemset(mic, 0, 16);\r\naes_cmac_encrypt_update(&aes_ctx, mic, 16);\r\naes_cmac_encrypt_update(&aes_ctx, &data[offset_fte + 20], data[offset_fte + 1] + 2 - 20);\r\naes_cmac_encrypt_finish(&aes_ctx, mic);\r\nif (memcmp(mic, &data[offset_fte + 4],16)) {\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapTDLSDeriveKey", "MIC verification failed", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_UNSUCCESS;\r\n}\r\nmemcpy(AIRPDCAP_GET_TK(sa->wpa.ptk), &key_input[16], 16);\r\nmemcpy(sa->wpa.nonce, snonce, AIRPDCAP_WPA_NONCE_LEN);\r\nsa->validKey = TRUE;\r\nsa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;\r\nAIRPDCAP_DEBUG_PRINT_LINE("AirPDcapTDLSDeriveKey", "MIC verified", AIRPDCAP_DEBUG_LEVEL_3);\r\nreturn AIRPDCAP_RET_SUCCESS;\r\n}
