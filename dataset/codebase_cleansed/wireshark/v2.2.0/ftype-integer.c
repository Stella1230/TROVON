static void\r\nint_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.uinteger = 0;\r\n}\r\nstatic void\r\nset_uinteger(fvalue_t *fv, guint32 value)\r\n{\r\nfv->value.uinteger = value;\r\n}\r\nstatic void\r\nset_sinteger(fvalue_t *fv, gint32 value)\r\n{\r\nfv->value.sinteger = value;\r\n}\r\nstatic guint32\r\nget_uinteger(fvalue_t *fv)\r\n{\r\nreturn fv->value.uinteger;\r\n}\r\nstatic gint32\r\nget_sinteger(fvalue_t *fv)\r\n{\r\nreturn fv->value.sinteger;\r\n}\r\nstatic gboolean\r\nuint_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg,\r\nguint32 max)\r\n{\r\nunsigned long value;\r\nchar *endptr;\r\nif (strchr (s, '-') && strtol(s, NULL, 0) < 0) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" too small for this field, minimum 0.", s);\r\nreturn FALSE;\r\n}\r\nerrno = 0;\r\nvalue = strtoul(s, &endptr, 0);\r\nif (errno == EINVAL || endptr == s || *endptr != '\0') {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid number.", s);\r\nreturn FALSE;\r\n}\r\nif (errno == ERANGE) {\r\nif (err_msg != NULL) {\r\nif (value == ULONG_MAX) {\r\n*err_msg = g_strdup_printf("\"%s\" causes an integer overflow.",\r\ns);\r\n}\r\nelse {\r\n*err_msg = g_strdup_printf("\"%s\" is not an integer.", s);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nif (value > max) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" too big for this field, maximum %u.", s, max);\r\nreturn FALSE;\r\n}\r\nfv->value.uinteger = (guint32)value;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nuint32_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn uint_from_unparsed (fv, s, allow_partial_value, err_msg, G_MAXUINT32);\r\n}\r\nstatic gboolean\r\nuint24_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn uint_from_unparsed (fv, s, allow_partial_value, err_msg, 0xFFFFFF);\r\n}\r\nstatic gboolean\r\nuint16_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn uint_from_unparsed (fv, s, allow_partial_value, err_msg, G_MAXUINT16);\r\n}\r\nstatic gboolean\r\nuint8_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn uint_from_unparsed (fv, s, allow_partial_value, err_msg, G_MAXUINT8);\r\n}\r\nstatic gboolean\r\nsint_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg,\r\ngint32 max, gint32 min)\r\n{\r\nlong value;\r\nchar *endptr;\r\nif (!strchr (s, '-') && strtoul(s, NULL, 0) > G_MAXINT32) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" causes an integer overflow.", s);\r\nreturn FALSE;\r\n}\r\nerrno = 0;\r\nvalue = strtol(s, &endptr, 0);\r\nif (errno == EINVAL || endptr == s || *endptr != '\0') {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid number.", s);\r\nreturn FALSE;\r\n}\r\nif (errno == ERANGE) {\r\nif (err_msg != NULL) {\r\nif (value == LONG_MAX) {\r\n*err_msg = g_strdup_printf("\"%s\" causes an integer overflow.", s);\r\n}\r\nelse if (value == LONG_MIN) {\r\n*err_msg = g_strdup_printf("\"%s\" causes an integer underflow.", s);\r\n}\r\nelse {\r\n*err_msg = g_strdup_printf("\"%s\" is not an integer.", s);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nif (value > max) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" too big for this field, maximum %d.",\r\ns, max);\r\nreturn FALSE;\r\n} else if (value < min) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" too small for this field, minimum %d.",\r\ns, min);\r\nreturn FALSE;\r\n}\r\nfv->value.sinteger = (gint32)value;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nsint32_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn sint_from_unparsed (fv, s, allow_partial_value, err_msg, G_MAXINT32, G_MININT32);\r\n}\r\nstatic gboolean\r\nsint24_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn sint_from_unparsed (fv, s, allow_partial_value, err_msg, 0x7FFFFF, -0x800000);\r\n}\r\nstatic gboolean\r\nsint16_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn sint_from_unparsed (fv, s, allow_partial_value, err_msg, G_MAXINT16, G_MININT16);\r\n}\r\nstatic gboolean\r\nsint8_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn sint_from_unparsed (fv, s, allow_partial_value, err_msg, G_MAXINT8, G_MININT8);\r\n}\r\nstatic int\r\ninteger_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn 11;\r\n}\r\nstatic void\r\ninteger_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size)\r\n{\r\nguint32 val;\r\nif (fv->value.sinteger < 0) {\r\n*buf++ = '-';\r\nval = -fv->value.sinteger;\r\n} else\r\nval = fv->value.sinteger;\r\nguint32_to_str_buf(val, buf, size);\r\n}\r\nstatic int\r\nuinteger_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn 10;\r\n}\r\nstatic void\r\nuinteger_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display, char *buf, unsigned int size)\r\n{\r\nif ((field_display == BASE_HEX) || (field_display == BASE_HEX_DEC))\r\n{\r\n*buf++ = '0';\r\n*buf++ = 'x';\r\nbuf = dword_to_hex(buf, fv->value.uinteger);\r\n*buf++ = '\0';\r\n}\r\nelse\r\n{\r\nguint32_to_str_buf(fv->value.uinteger, buf, size);\r\n}\r\n}\r\nstatic gboolean\r\nipxnet_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nguint32 val;\r\ngboolean known;\r\nif (uint32_from_unparsed(fv, s, TRUE, NULL)) {\r\nreturn TRUE;\r\n}\r\nval = get_ipxnet_addr(s, &known);\r\nif (known) {\r\nfv->value.uinteger = val;\r\nreturn TRUE;\r\n}\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid IPX network name or address.", s);\r\nreturn FALSE;\r\n}\r\nstatic int\r\nipxnet_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn 2+8;\r\n}\r\nstatic void\r\nipxnet_to_repr(fvalue_t *fv, ftrepr_t rtype, int field_display _U_, char *buf, unsigned int size)\r\n{\r\nuinteger_to_repr(fv, rtype, BASE_HEX, buf, size);\r\n}\r\nstatic gboolean\r\ncmp_eq(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger == b->value.uinteger;\r\n}\r\nstatic gboolean\r\ncmp_ne(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger != b->value.uinteger;\r\n}\r\nstatic gboolean\r\nu_cmp_gt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger > b->value.uinteger;\r\n}\r\nstatic gboolean\r\nu_cmp_ge(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger >= b->value.uinteger;\r\n}\r\nstatic gboolean\r\nu_cmp_lt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger < b->value.uinteger;\r\n}\r\nstatic gboolean\r\nu_cmp_le(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger <= b->value.uinteger;\r\n}\r\nstatic gboolean\r\ns_cmp_gt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.sinteger > b->value.sinteger;\r\n}\r\nstatic gboolean\r\ns_cmp_ge(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.sinteger >= b->value.sinteger;\r\n}\r\nstatic gboolean\r\ns_cmp_lt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.sinteger < b->value.sinteger;\r\n}\r\nstatic gboolean\r\ns_cmp_le(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.sinteger <= b->value.sinteger;\r\n}\r\nstatic gboolean\r\ncmp_bitwise_and(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ((a->value.uinteger & b->value.uinteger) != 0);\r\n}\r\nstatic void\r\nint64_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.sinteger64 = 0;\r\n}\r\nstatic void\r\nset_uinteger64(fvalue_t *fv, guint64 value)\r\n{\r\nfv->value.uinteger64 = value;\r\n}\r\nstatic void\r\nset_sinteger64(fvalue_t *fv, gint64 value)\r\n{\r\nfv->value.sinteger64 = value;\r\n}\r\nstatic guint64\r\nget_uinteger64(fvalue_t *fv)\r\n{\r\nreturn fv->value.uinteger64;\r\n}\r\nstatic gint64\r\nget_sinteger64(fvalue_t *fv)\r\n{\r\nreturn fv->value.sinteger64;\r\n}\r\nstatic gboolean\r\n_uint64_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg,\r\nguint64 max)\r\n{\r\nguint64 value;\r\nchar *endptr;\r\nif (strchr (s, '-') && g_ascii_strtoll(s, NULL, 0) < 0) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" causes an integer underflow.", s);\r\nreturn FALSE;\r\n}\r\nerrno = 0;\r\nvalue = g_ascii_strtoull(s, &endptr, 0);\r\nif (errno == EINVAL || endptr == s || *endptr != '\0') {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid number.", s);\r\nreturn FALSE;\r\n}\r\nif (errno == ERANGE) {\r\nif (err_msg != NULL) {\r\nif (value == G_MAXUINT64) {\r\n*err_msg = g_strdup_printf("\"%s\" causes an integer overflow.", s);\r\n}\r\nelse {\r\n*err_msg = g_strdup_printf("\"%s\" is not an integer.", s);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nif (value > max) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" too big for this field, maximum %" G_GINT64_MODIFIER "u.", s, max);\r\nreturn FALSE;\r\n}\r\nfv->value.uinteger64 = value;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nuint64_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn _uint64_from_unparsed (fv, s, allow_partial_value, err_msg, G_MAXUINT64);\r\n}\r\nstatic gboolean\r\nuint56_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn _uint64_from_unparsed (fv, s, allow_partial_value, err_msg, G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFF));\r\n}\r\nstatic gboolean\r\nuint48_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn _uint64_from_unparsed (fv, s, allow_partial_value, err_msg, G_GUINT64_CONSTANT(0xFFFFFFFFFFFF));\r\n}\r\nstatic gboolean\r\nuint40_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn _uint64_from_unparsed (fv, s, allow_partial_value, err_msg, G_GUINT64_CONSTANT(0xFFFFFFFFFF));\r\n}\r\nstatic gboolean\r\n_sint64_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg,\r\ngint64 max, gint64 min)\r\n{\r\ngint64 value;\r\nchar *endptr;\r\nif (!strchr (s, '-') && g_ascii_strtoull(s, NULL, 0) > G_MAXINT64) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" causes an integer overflow.", s);\r\nreturn FALSE;\r\n}\r\nerrno = 0;\r\nvalue = g_ascii_strtoll(s, &endptr, 0);\r\nif (errno == EINVAL || endptr == s || *endptr != '\0') {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid number.", s);\r\nreturn FALSE;\r\n}\r\nif (errno == ERANGE) {\r\nif (err_msg != NULL) {\r\nif (value == G_MAXINT64) {\r\n*err_msg = g_strdup_printf("\"%s\" causes an integer overflow.", s);\r\n}\r\nelse if (value == G_MININT64) {\r\n*err_msg = g_strdup_printf("\"%s\" causes an integer underflow.", s);\r\n}\r\nelse {\r\n*err_msg = g_strdup_printf("\"%s\" is not an integer.", s);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nif (value > max) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" too big for this field, maximum %" G_GINT64_MODIFIER "u.", s, max);\r\nreturn FALSE;\r\n} else if (value < min) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" too small for this field, maximum %" G_GINT64_MODIFIER "u.", s, max);\r\nreturn FALSE;\r\n}\r\nfv->value.sinteger64 = (guint64)value;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nsint64_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn _sint64_from_unparsed (fv, s, allow_partial_value, err_msg, G_MAXINT64, G_MININT64);\r\n}\r\nstatic gboolean\r\nsint56_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn _sint64_from_unparsed (fv, s, allow_partial_value, err_msg, G_GINT64_CONSTANT(0x7FFFFFFFFFFFFF), G_GINT64_CONSTANT(-0x80000000000000));\r\n}\r\nstatic gboolean\r\nsint48_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn _sint64_from_unparsed (fv, s, allow_partial_value, err_msg, G_GINT64_CONSTANT(0x7FFFFFFFFFFF), G_GINT64_CONSTANT(-0x800000000000));\r\n}\r\nstatic gboolean\r\nsint40_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nreturn _sint64_from_unparsed (fv, s, allow_partial_value, err_msg, G_GINT64_CONSTANT(0x7FFFFFFFFF), G_GINT64_CONSTANT(-0x8000000000));\r\n}\r\nstatic int\r\ninteger64_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn 20;\r\n}\r\nstatic void\r\ninteger64_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size)\r\n{\r\nguint64 val;\r\nif (fv->value.sinteger64 < 0) {\r\n*buf++ = '-';\r\nval = -fv->value.sinteger64;\r\n} else\r\nval = fv->value.sinteger64;\r\nguint64_to_str_buf(val, buf, size);\r\n}\r\nstatic int\r\nuinteger64_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn 20;\r\n}\r\nstatic void\r\nuinteger64_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display, char *buf, unsigned int size)\r\n{\r\nif ((field_display == BASE_HEX) || (field_display == BASE_HEX_DEC))\r\n{\r\n*buf++ = '0';\r\n*buf++ = 'x';\r\nbuf = qword_to_hex(buf, fv->value.uinteger64);\r\n*buf++ = '\0';\r\n}\r\nelse\r\n{\r\nguint64_to_str_buf(fv->value.uinteger64, buf, size);\r\n}\r\n}\r\nstatic gboolean\r\ncmp_eq64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger64 == b->value.uinteger64;\r\n}\r\nstatic gboolean\r\ncmp_ne64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger64 != b->value.uinteger64;\r\n}\r\nstatic gboolean\r\nu_cmp_gt64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger64 > b->value.uinteger64;\r\n}\r\nstatic gboolean\r\nu_cmp_ge64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger64 >= b->value.uinteger64;\r\n}\r\nstatic gboolean\r\nu_cmp_lt64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger64 < b->value.uinteger64;\r\n}\r\nstatic gboolean\r\nu_cmp_le64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger64 <= b->value.uinteger64;\r\n}\r\nstatic gboolean\r\ns_cmp_gt64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (gint64)a->value.sinteger64 > (gint64)b->value.sinteger64;\r\n}\r\nstatic gboolean\r\ns_cmp_ge64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (gint64)a->value.sinteger64 >= (gint64)b->value.sinteger64;\r\n}\r\nstatic gboolean\r\ns_cmp_lt64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (gint64)a->value.sinteger64 < (gint64)b->value.sinteger64;\r\n}\r\nstatic gboolean\r\ns_cmp_le64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (gint64)a->value.sinteger64 <= (gint64)b->value.sinteger64;\r\n}\r\nstatic gboolean\r\ncmp_bitwise_and64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ((a->value.uinteger64 & b->value.uinteger64) != 0);\r\n}\r\nstatic void\r\nboolean_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.uinteger64 = TRUE;\r\n}\r\nstatic int\r\nboolean_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn 1;\r\n}\r\nstatic void\r\nboolean_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size _U_)\r\n{\r\n*buf++ = (fv->value.uinteger64) ? '1' : '0';\r\n*buf = '\0';\r\n}\r\nstatic gboolean\r\nbool_eq(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nif (a->value.uinteger64) {\r\nif (b->value.uinteger64) {\r\nreturn TRUE;\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\n}\r\nelse {\r\nif (b->value.uinteger64) {\r\nreturn FALSE;\r\n}\r\nelse {\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\nstatic gboolean\r\nbool_ne(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (!bool_eq(a,b));\r\n}\r\nstatic gboolean\r\neui64_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nGByteArray *bytes;\r\ngboolean res;\r\nunion {\r\nguint64 value;\r\nguint8 bytes[8];\r\n} eui64;\r\nif (uint64_from_unparsed(fv, s, TRUE, NULL)) {\r\nreturn TRUE;\r\n}\r\nbytes = g_byte_array_new();\r\nres = hex_str_to_bytes(s, bytes, TRUE);\r\nif (!res || bytes->len != 8) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid EUI-64 address.", s);\r\ng_byte_array_free(bytes, TRUE);\r\nreturn FALSE;\r\n}\r\nmemcpy(eui64.bytes, bytes->data, 8);\r\ng_byte_array_free(bytes, TRUE);\r\nfv->value.integer64 = GUINT64_FROM_BE(eui64.value);\r\nreturn TRUE;\r\n}\r\nstatic int\r\neui64_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn EUI64_STR_LEN;\r\n}\r\nstatic void\r\neui64_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size)\r\n{\r\nunion {\r\nguint64 value;\r\nguint8 bytes[8];\r\n} eui64;\r\neui64.value = GUINT64_TO_BE(fv->value.integer64);\r\ng_snprintf(buf, size, "%.2x:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x",\r\neui64.bytes[0], eui64.bytes[1], eui64.bytes[2], eui64.bytes[3],\r\neui64.bytes[4], eui64.bytes[5], eui64.bytes[6], eui64.bytes[7]);\r\n}\r\nvoid\r\nftype_register_integers(void)\r\n{\r\nstatic ftype_t uint8_type = {\r\nFT_UINT8,\r\n"FT_UINT8",\r\n"Unsigned integer, 1 byte",\r\n1,\r\nint_fvalue_new,\r\nNULL,\r\nuint8_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint16_type = {\r\nFT_UINT16,\r\n"FT_UINT16",\r\n"Unsigned integer, 2 bytes",\r\n2,\r\nint_fvalue_new,\r\nNULL,\r\nuint16_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint24_type = {\r\nFT_UINT24,\r\n"FT_UINT24",\r\n"Unsigned integer, 3 bytes",\r\n3,\r\nint_fvalue_new,\r\nNULL,\r\nuint24_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint32_type = {\r\nFT_UINT32,\r\n"FT_UINT32",\r\n"Unsigned integer, 4 bytes",\r\n4,\r\nint_fvalue_new,\r\nNULL,\r\nuint32_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint40_type = {\r\nFT_UINT40,\r\n"FT_UINT40",\r\n"Unsigned integer, 5 bytes",\r\n5,\r\nint64_fvalue_new,\r\nNULL,\r\nuint40_from_unparsed,\r\nNULL,\r\nuinteger64_to_repr,\r\nuinteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger64,\r\nNULL,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\nu_cmp_gt64,\r\nu_cmp_ge64,\r\nu_cmp_lt64,\r\nu_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint48_type = {\r\nFT_UINT48,\r\n"FT_UINT48",\r\n"Unsigned integer, 6 bytes",\r\n6,\r\nint64_fvalue_new,\r\nNULL,\r\nuint48_from_unparsed,\r\nNULL,\r\nuinteger64_to_repr,\r\nuinteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger64,\r\nNULL,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\nu_cmp_gt64,\r\nu_cmp_ge64,\r\nu_cmp_lt64,\r\nu_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint56_type = {\r\nFT_UINT56,\r\n"FT_UINT56",\r\n"Unsigned integer, 7 bytes",\r\n7,\r\nint64_fvalue_new,\r\nNULL,\r\nuint56_from_unparsed,\r\nNULL,\r\nuinteger64_to_repr,\r\nuinteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger64,\r\nNULL,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\nu_cmp_gt64,\r\nu_cmp_ge64,\r\nu_cmp_lt64,\r\nu_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint64_type = {\r\nFT_UINT64,\r\n"FT_UINT64",\r\n"Unsigned integer, 8 bytes",\r\n8,\r\nint64_fvalue_new,\r\nNULL,\r\nuint64_from_unparsed,\r\nNULL,\r\nuinteger64_to_repr,\r\nuinteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger64,\r\nNULL,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\nu_cmp_gt64,\r\nu_cmp_ge64,\r\nu_cmp_lt64,\r\nu_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int8_type = {\r\nFT_INT8,\r\n"FT_INT8",\r\n"Signed integer, 1 byte",\r\n1,\r\nint_fvalue_new,\r\nNULL,\r\nsint8_from_unparsed,\r\nNULL,\r\ninteger_to_repr,\r\ninteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ns_cmp_gt,\r\ns_cmp_ge,\r\ns_cmp_lt,\r\ns_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int16_type = {\r\nFT_INT16,\r\n"FT_INT16",\r\n"Signed integer, 2 bytes",\r\n2,\r\nint_fvalue_new,\r\nNULL,\r\nsint16_from_unparsed,\r\nNULL,\r\ninteger_to_repr,\r\ninteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ns_cmp_gt,\r\ns_cmp_ge,\r\ns_cmp_lt,\r\ns_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int24_type = {\r\nFT_INT24,\r\n"FT_INT24",\r\n"Signed integer, 3 bytes",\r\n3,\r\nint_fvalue_new,\r\nNULL,\r\nsint24_from_unparsed,\r\nNULL,\r\ninteger_to_repr,\r\ninteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ns_cmp_gt,\r\ns_cmp_ge,\r\ns_cmp_lt,\r\ns_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int32_type = {\r\nFT_INT32,\r\n"FT_INT32",\r\n"Signed integer, 4 bytes",\r\n4,\r\nint_fvalue_new,\r\nNULL,\r\nsint32_from_unparsed,\r\nNULL,\r\ninteger_to_repr,\r\ninteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ns_cmp_gt,\r\ns_cmp_ge,\r\ns_cmp_lt,\r\ns_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int40_type = {\r\nFT_INT40,\r\n"FT_INT40",\r\n"Signed integer, 5 bytes",\r\n5,\r\nint64_fvalue_new,\r\nNULL,\r\nsint40_from_unparsed,\r\nNULL,\r\ninteger64_to_repr,\r\ninteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger64,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\ns_cmp_gt64,\r\ns_cmp_ge64,\r\ns_cmp_lt64,\r\ns_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int48_type = {\r\nFT_INT48,\r\n"FT_INT48",\r\n"Signed integer, 6 bytes",\r\n6,\r\nint64_fvalue_new,\r\nNULL,\r\nsint48_from_unparsed,\r\nNULL,\r\ninteger64_to_repr,\r\ninteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger64,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\ns_cmp_gt64,\r\ns_cmp_ge64,\r\ns_cmp_lt64,\r\ns_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int56_type = {\r\nFT_INT56,\r\n"FT_INT56",\r\n"Signed integer, 7 bytes",\r\n7,\r\nint64_fvalue_new,\r\nNULL,\r\nsint56_from_unparsed,\r\nNULL,\r\ninteger64_to_repr,\r\ninteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger64,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\ns_cmp_gt64,\r\ns_cmp_ge64,\r\ns_cmp_lt64,\r\ns_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int64_type = {\r\nFT_INT64,\r\n"FT_INT64",\r\n"Signed integer, 8 bytes",\r\n8,\r\nint64_fvalue_new,\r\nNULL,\r\nsint64_from_unparsed,\r\nNULL,\r\ninteger64_to_repr,\r\ninteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger64,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\ns_cmp_gt64,\r\ns_cmp_ge64,\r\ns_cmp_lt64,\r\ns_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t boolean_type = {\r\nFT_BOOLEAN,\r\n"FT_BOOLEAN",\r\n"Boolean",\r\n0,\r\nboolean_fvalue_new,\r\nNULL,\r\nuint64_from_unparsed,\r\nNULL,\r\nboolean_to_repr,\r\nboolean_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger64,\r\nNULL,\r\nNULL,\r\nbool_eq,\r\nbool_ne,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t ipxnet_type = {\r\nFT_IPXNET,\r\n"FT_IPXNET",\r\n"IPX network number",\r\n4,\r\nint_fvalue_new,\r\nNULL,\r\nipxnet_from_unparsed,\r\nNULL,\r\nipxnet_to_repr,\r\nipxnet_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t framenum_type = {\r\nFT_FRAMENUM,\r\n"FT_FRAMENUM",\r\n"Frame number",\r\n4,\r\nint_fvalue_new,\r\nNULL,\r\nuint32_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t eui64_type = {\r\nFT_EUI64,\r\n"FT_EUI64",\r\n"EUI64 address",\r\nFT_EUI64_LEN,\r\nint64_fvalue_new,\r\nNULL,\r\neui64_from_unparsed,\r\nNULL,\r\neui64_to_repr,\r\neui64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger64,\r\nNULL,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\nu_cmp_gt64,\r\nu_cmp_ge64,\r\nu_cmp_lt64,\r\nu_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nftype_register(FT_UINT8, &uint8_type);\r\nftype_register(FT_UINT16, &uint16_type);\r\nftype_register(FT_UINT24, &uint24_type);\r\nftype_register(FT_UINT32, &uint32_type);\r\nftype_register(FT_UINT40, &uint40_type);\r\nftype_register(FT_UINT48, &uint48_type);\r\nftype_register(FT_UINT56, &uint56_type);\r\nftype_register(FT_UINT64, &uint64_type);\r\nftype_register(FT_INT8, &int8_type);\r\nftype_register(FT_INT16, &int16_type);\r\nftype_register(FT_INT24, &int24_type);\r\nftype_register(FT_INT32, &int32_type);\r\nftype_register(FT_INT40, &int40_type);\r\nftype_register(FT_INT48, &int48_type);\r\nftype_register(FT_INT56, &int56_type);\r\nftype_register(FT_INT64, &int64_type);\r\nftype_register(FT_BOOLEAN, &boolean_type);\r\nftype_register(FT_IPXNET, &ipxnet_type);\r\nftype_register(FT_FRAMENUM, &framenum_type);\r\nftype_register(FT_EUI64, &eui64_type);\r\n}
