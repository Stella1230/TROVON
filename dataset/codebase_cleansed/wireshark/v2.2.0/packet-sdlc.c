static int\r\ndissect_sdlc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *sdlc_tree;\r\nproto_item *sdlc_ti;\r\nguint8 addr;\r\nguint16 control;\r\nint sdlc_header_len;\r\ngboolean is_response;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "SDLC");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\naddr = tvb_get_guint8(tvb, 0);\r\nsdlc_header_len = 1;\r\nif (pinfo->p2p_dir == P2P_DIR_SENT) {\r\nis_response = FALSE;\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "DCE");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "DTE");\r\n}\r\nelse {\r\nis_response = TRUE;\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "DTE");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "DCE");\r\n}\r\nsdlc_ti = proto_tree_add_item(tree, proto_sdlc, tvb, 0, -1,\r\nENC_NA);\r\nsdlc_tree = proto_item_add_subtree(sdlc_ti, ett_sdlc);\r\nproto_tree_add_uint(sdlc_tree, hf_sdlc_address, tvb, 0, 1,\r\naddr);\r\ncontrol = dissect_xdlc_control(tvb, 1, pinfo, sdlc_tree, hf_sdlc_control,\r\nett_sdlc_control, &sdlc_cf_items, NULL, NULL, NULL,\r\nis_response, FALSE, FALSE);\r\nsdlc_header_len += XDLC_CONTROL_LEN(control, FALSE);\r\nproto_item_set_len(sdlc_ti, sdlc_header_len);\r\nnext_tvb = tvb_new_subset_remaining(tvb, sdlc_header_len);\r\nif (XDLC_IS_INFORMATION(control)) {\r\ncall_dissector(sna_handle, next_tvb, pinfo, tree);\r\n} else\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_sdlc(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_sdlc_address,\r\n{ "Address Field", "sdlc.address", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, "Address", HFILL }},\r\n{ &hf_sdlc_control,\r\n{ "Control Field", "sdlc.control", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_sdlc_n_r,\r\n{ "N(R)", "sdlc.control.n_r", FT_UINT8, BASE_DEC,\r\nNULL, XDLC_N_R_MASK, NULL, HFILL }},\r\n{ &hf_sdlc_n_s,\r\n{ "N(S)", "sdlc.control.n_s", FT_UINT8, BASE_DEC,\r\nNULL, XDLC_N_S_MASK, NULL, HFILL }},\r\n{ &hf_sdlc_p,\r\n{ "Poll", "sdlc.control.p", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), XDLC_P_F, NULL, HFILL }},\r\n{ &hf_sdlc_f,\r\n{ "Final", "sdlc.control.f", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), XDLC_P_F, NULL, HFILL }},\r\n{ &hf_sdlc_s_ftype,\r\n{ "Supervisory frame type", "sdlc.control.s_ftype", FT_UINT8, BASE_HEX,\r\nVALS(stype_vals), XDLC_S_FTYPE_MASK, NULL, HFILL }},\r\n{ &hf_sdlc_u_modifier_cmd,\r\n{ "Command", "sdlc.control.u_modifier_cmd", FT_UINT8, BASE_HEX,\r\nVALS(modifier_vals_cmd), XDLC_U_MODIFIER_MASK, NULL, HFILL }},\r\n{ &hf_sdlc_u_modifier_resp,\r\n{ "Response", "sdlc.control.u_modifier_resp", FT_UINT8, BASE_HEX,\r\nVALS(modifier_vals_resp), XDLC_U_MODIFIER_MASK, NULL, HFILL }},\r\n{ &hf_sdlc_ftype_i,\r\n{ "Frame type", "sdlc.control.ftype", FT_UINT8, BASE_HEX,\r\nVALS(ftype_vals), XDLC_I_MASK, NULL, HFILL }},\r\n{ &hf_sdlc_ftype_s_u,\r\n{ "Frame type", "sdlc.control.ftype", FT_UINT8, BASE_HEX,\r\nVALS(ftype_vals), XDLC_S_U_MASK, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_sdlc,\r\n&ett_sdlc_control,\r\n};\r\nproto_sdlc = proto_register_protocol(\r\n"Synchronous Data Link Control (SDLC)", "SDLC", "sdlc");\r\nproto_register_field_array(proto_sdlc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_sdlc(void)\r\n{\r\ndissector_handle_t sdlc_handle;\r\nsna_handle = find_dissector_add_dependency("sna", proto_sdlc);\r\nsdlc_handle = create_dissector_handle(dissect_sdlc, proto_sdlc);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_SDLC, sdlc_handle);\r\n}
