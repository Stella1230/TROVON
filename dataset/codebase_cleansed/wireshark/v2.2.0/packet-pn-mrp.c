static int\r\ndissect_PNMRP_Common(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, proto_item *item _U_)\r\n{\r\nguint16 sequence_id;\r\ne_guid_t uuid;\r\noffset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_mrp_sequence_id, &sequence_id);\r\noffset = dissect_pn_uuid(tvb, offset, pinfo, tree, hf_pn_mrp_domain_uuid, &uuid);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_PNMRP_Link(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, proto_item *item _U_, guint8 type)\r\n{\r\nguint8 mac[6];\r\nguint16 port_role;\r\nguint16 interval;\r\nguint16 blocked;\r\nproto_item *sub_item;\r\noffset = dissect_pn_mac(tvb, offset, pinfo, tree, hf_pn_mrp_sa, mac);\r\noffset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_mrp_port_role, &port_role);\r\noffset = dissect_pn_uint16_ret_item(tvb, offset, pinfo, tree, hf_pn_mrp_interval, &interval, &sub_item);\r\nif (tree)\r\n{\r\nproto_item_append_text(sub_item,"Interval for next topology change event (in ms)");\r\nif (interval <0x07D1)\r\nproto_item_append_text(sub_item," Mandatory");\r\nelse\r\nproto_item_append_text(sub_item," Optional");\r\n}\r\noffset = dissect_pn_uint16_ret_item(tvb, offset, pinfo, tree, hf_pn_mrp_blocked, &blocked, &sub_item);\r\nif (tree)\r\n{\r\nif (blocked == 0)\r\nproto_item_append_text(sub_item," The MRC is not able to receive and forward frames to port in state blocked");\r\nelse\r\nif (blocked == 1)\r\nproto_item_append_text(sub_item," The MRC is able to receive and forward frames to port in state blocked");\r\nelse\r\nproto_item_append_text(sub_item," Reserved");\r\n}\r\noffset = dissect_pn_align4(tvb, offset, pinfo, tree);\r\nif(type == 4 )\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, "LinkDown");\r\nproto_item_append_text(item, "LinkDown");\r\n}\r\nelse\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, "LinkUp");\r\nproto_item_append_text(item, "LinkUp");\r\n}\r\nreturn offset;\r\n}\r\nstatic const char * mrp_Prio2msg(guint16 prio)\r\n{\r\nif (prio == 0x0000)\r\nreturn(" Highest priority redundancy manager");\r\nif ((prio >= 0x1000) && (prio <= 0x7000))\r\nreturn(" High priorities");\r\nif (prio == 0x8000)\r\nreturn(" Default priority for redundancy manager");\r\nif ((prio >= 0x8001) && (prio <= 0x8FFF))\r\nreturn(" Low priorities for redundancy manager");\r\nif ((prio >= 0x9000) && (prio <= 0x9FFF))\r\nreturn(" High priorities for redundancy manager (auto)");\r\nif (prio == 0xA000)\r\nreturn(" Default priority for redundancy manager (auto)");\r\nif ((prio >= 0xA001) && (prio <= 0xF000))\r\nreturn(" Low priorities for redundancy manager (auto)");\r\nif (prio ==0xFFFF)\r\nreturn(" Lowest priority for redundancy manager (auto)");\r\nreturn(" Reserved");\r\n}\r\nstatic int\r\ndissect_PNMRP_Test(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, proto_item *item _U_)\r\n{\r\nguint16 prio;\r\nguint8 mac[6];\r\nguint16 port_role;\r\nguint16 ring_state;\r\nguint16 transition;\r\nguint32 time_stamp;\r\nproto_item *sub_item;\r\noffset = dissect_pn_uint16_ret_item(tvb, offset, pinfo, tree, hf_pn_mrp_prio, &prio, &sub_item);\r\nif (tree)\r\nproto_item_append_text(sub_item, "%s", mrp_Prio2msg(prio));\r\noffset = dissect_pn_mac(tvb, offset, pinfo, tree, hf_pn_mrp_sa, mac);\r\noffset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_mrp_port_role, &port_role);\r\noffset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_mrp_ring_state, &ring_state);\r\noffset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_mrp_transition, &transition);\r\noffset = dissect_pn_uint32(tvb, offset, pinfo, tree, hf_pn_mrp_time_stamp, &time_stamp);\r\noffset = dissect_pn_align4(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_PNMRP_TopologyChange(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, proto_item *item _U_)\r\n{\r\nguint16 prio;\r\nguint8 mac[6];\r\nguint16 interval;\r\nproto_item *sub_item;\r\noffset = dissect_pn_uint16_ret_item(tvb, offset, pinfo, tree, hf_pn_mrp_prio, &prio, &sub_item);\r\nif (tree)\r\nproto_item_append_text(sub_item, "%s", mrp_Prio2msg(prio));\r\noffset = dissect_pn_mac(tvb, offset, pinfo, tree, hf_pn_mrp_sa, mac);\r\noffset = dissect_pn_uint16_ret_item(tvb, offset, pinfo, tree, hf_pn_mrp_interval, &interval, &sub_item);\r\nif (tree)\r\n{\r\nproto_item_append_text(sub_item," Interval for next topology change event (in ms) ");\r\nif (interval <0x07D1)\r\nproto_item_append_text(sub_item,"Mandatory");\r\nelse\r\nproto_item_append_text(sub_item,"Optional");\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_pn_ManuData(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree, guint32 length)\r\n{\r\nproto_tree_add_string_format(tree, hf_pn_manufacturer_data, tvb, offset, length, "data",\r\n"MRP_ManufacturerData: %d bytes", length);\r\nreturn offset + length;\r\n}\r\nstatic int\r\ndissect_PNMRP_Option(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, proto_item *item, guint8 length)\r\n{\r\nguint32 oui;\r\noffset = dissect_pn_oid(tvb, offset, pinfo,tree, hf_pn_mrp_oui, &oui);\r\nlength -= 3;\r\nswitch (oui)\r\n{\r\ncase OUI_SIEMENS:\r\nproto_item_append_text(item, "(SIEMENS)");\r\nif (length != 0) {\r\noffset = dissect_pn_ManuData(tvb, offset, pinfo, tree, length);\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO, "(Siemens)");\r\nbreak;\r\ndefault:\r\nproto_item_append_text(item, " (Unknown-OUI)");\r\noffset = dissect_pn_undecoded(tvb, offset, pinfo, tree, length);\r\n}\r\noffset = dissect_pn_align4(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_PNMRP_PDU(tvbuff_t *tvb, int offset,\r\npacket_info *pinfo, proto_tree *tree, proto_item *item)\r\n{\r\nguint16 version;\r\nguint8 type;\r\nguint8 length;\r\ngint i;\r\ntvbuff_t *new_tvb;\r\noffset = dissect_pn_uint16(tvb, offset, pinfo, tree, hf_pn_mrp_version, &version);\r\nnew_tvb = tvb_new_subset_remaining(tvb, offset);\r\noffset = 0;\r\nfor(i=0; tvb_reported_length_remaining(tvb, offset) > 0; i++) {\r\noffset = dissect_pn_uint8(new_tvb, offset, pinfo, tree, hf_pn_mrp_type, &type);\r\noffset = dissect_pn_uint8(new_tvb, offset, pinfo, tree, hf_pn_mrp_length, &length);\r\nif (i != 0) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", ");\r\nproto_item_append_text(item, ", ");\r\n} else {\r\nproto_item_append_text(item, " ");\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO, val_to_str_const(type, pn_mrp_block_type_vals, "Unknown TLVType 0x%x"));\r\nproto_item_append_text(item, "%s", val_to_str_const(type, pn_mrp_block_type_vals, "Unknown TLVType 0x%x"));\r\nswitch(type) {\r\ncase 0x00:\r\nreturn offset;\r\nbreak;\r\ncase 0x01:\r\noffset = dissect_PNMRP_Common(new_tvb, offset, pinfo, tree, item);\r\nbreak;\r\ncase 0x02:\r\noffset = dissect_PNMRP_Test(new_tvb, offset, pinfo, tree, item);\r\nbreak;\r\ncase 0x03:\r\noffset = dissect_PNMRP_TopologyChange(new_tvb, offset, pinfo, tree, item);\r\nbreak;\r\ncase 0x04:\r\ncase 0x05:\r\noffset = dissect_PNMRP_Link(new_tvb, offset, pinfo, tree, item, type);\r\nbreak;\r\ncase 0x7f:\r\noffset = dissect_PNMRP_Option(new_tvb, offset, pinfo, tree, item, length);\r\nbreak;\r\ndefault:\r\noffset = dissect_pn_undecoded(tvb, offset, pinfo, tree, length);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_PNMRP(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti = NULL;\r\nproto_tree *mrp_tree = NULL;\r\nguint32 offset = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "PN-MRP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree)\r\n{\r\nti = proto_tree_add_item(tree, proto_pn_mrp, tvb, offset, -1, ENC_NA);\r\nmrp_tree = proto_item_add_subtree(ti, ett_pn_mrp);\r\n}\r\ndissect_PNMRP_PDU(tvb, offset, pinfo, mrp_tree, ti);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_pn_mrp (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_pn_mrp_type,\r\n{ "MRP_TLVHeader.Type", "pn_mrp.type",\r\nFT_UINT8, BASE_HEX, VALS(pn_mrp_block_type_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_mrp_length,\r\n{ "MRP_TLVHeader.Length", "pn_mrp.length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_mrp_version,\r\n{ "MRP_Version", "pn_mrp.version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_mrp_sequence_id,\r\n{ "MRP_SequenceID", "pn_mrp.sequence_id",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Unique sequence number to each outstanding service request", HFILL }},\r\n{ &hf_pn_mrp_sa,\r\n{ "MRP_SA", "pn_mrp.sa",\r\nFT_ETHER, BASE_NONE, 0x0, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_mrp_prio,\r\n{ "MRP_Prio", "pn_mrp.prio",\r\nFT_UINT16, BASE_HEX, 0, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_mrp_port_role,\r\n{ "MRP_PortRole", "pn_mrp.port_role",\r\nFT_UINT16, BASE_HEX, VALS(pn_mrp_port_role_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_mrp_ring_state,\r\n{ "MRP_RingState", "pn_mrp.ring_state",\r\nFT_UINT16, BASE_HEX, VALS(pn_mrp_ring_state_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_mrp_interval,\r\n{ "MRP_Interval", "pn_mrp.interval",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Interval for next topology change event (in ms)", HFILL }},\r\n{ &hf_pn_mrp_transition,\r\n{ "MRP_Transition", "pn_mrp.transition",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Number of transitions between media redundancy lost and ok states", HFILL }},\r\n{ &hf_pn_mrp_time_stamp,\r\n{ "MRP_TimeStamp [ms]", "pn_mrp.time_stamp",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Actual counter value of 1ms counter", HFILL }},\r\n{ &hf_pn_mrp_blocked,\r\n{ "MRP_Blocked", "pn_mrp.blocked",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_manufacturer_data,\r\n{ "MRP_ManufacturerData", "pn_mrp.ManufacturerData",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_mrp_domain_uuid,\r\n{ "MRP_DomainUUID", "pn_mrp.domain_uuid",\r\nFT_GUID, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_pn_mrp_oui,\r\n{ "MRP_ManufacturerOUI", "pn_mrp.oui",\r\nFT_UINT24, BASE_HEX, VALS(pn_mrp_oui_vals), 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_pn_mrp\r\n};\r\nproto_pn_mrp = proto_register_protocol ("PROFINET MRP", "PN-MRP", "pn_mrp");\r\nproto_register_field_array (proto_pn_mrp, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\n}\r\nvoid\r\nproto_reg_handoff_pn_mrp (void)\r\n{\r\ndissector_handle_t mrp_handle;\r\nmrp_handle = create_dissector_handle(dissect_PNMRP,proto_pn_mrp);\r\ndissector_add_uint("ethertype", ETHERTYPE_MRP, mrp_handle);\r\n}
