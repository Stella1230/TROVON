static void\r\ngssapi_reassembly_init(void)\r\n{\r\nreassembly_table_init(&gssapi_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\ngssapi_reassembly_cleanup(void)\r\n{\r\nreassembly_table_destroy(&gssapi_reassembly_table);\r\n}\r\nstatic gint\r\ngssapi_oid_equal(gconstpointer k1, gconstpointer k2)\r\n{\r\nconst char *key1 = (const char *)k1;\r\nconst char *key2 = (const char *)k2;\r\nreturn strcmp(key1, key2) == 0;\r\n}\r\nstatic guint\r\ngssapi_oid_hash(gconstpointer k)\r\n{\r\nconst char *key = (const char *)k;\r\nguint hash = 0, i;\r\nfor (i = 0; key[i]; i++)\r\nhash += key[i];\r\nreturn hash;\r\n}\r\nvoid\r\ngssapi_init_oid(const char *oid, int proto, int ett, dissector_handle_t handle,\r\ndissector_handle_t wrap_handle, const gchar *comment)\r\n{\r\nchar *key = g_strdup(oid);\r\ngssapi_oid_value *value = (gssapi_oid_value *)g_malloc(sizeof(*value));\r\nvalue->proto = find_protocol_by_id(proto);\r\nvalue->ett = ett;\r\nvalue->handle = handle;\r\nvalue->wrap_handle = wrap_handle;\r\nvalue->comment = comment;\r\ng_hash_table_insert(gssapi_oids, key, value);\r\nregister_ber_oid_dissector_handle(key, handle, proto, comment);\r\n}\r\ngssapi_oid_value *\r\ngssapi_lookup_oid_str(const char *oid_key)\r\n{\r\ngssapi_oid_value *value;\r\nif(!oid_key){\r\nreturn NULL;\r\n}\r\nvalue = (gssapi_oid_value *)g_hash_table_lookup(gssapi_oids, oid_key);\r\nreturn value;\r\n}\r\nstatic int\r\ndissect_gssapi_work(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngboolean is_verifier, gssapi_encrypt_info_t* encrypt_info)\r\n{\r\nproto_item *volatile item;\r\nproto_tree *volatile subtree;\r\nvolatile int return_offset = 0;\r\ngssapi_conv_info_t *volatile gss_info;\r\ngssapi_oid_value *oidvalue;\r\ndissector_handle_t handle;\r\nconversation_t *conversation;\r\ntvbuff_t *oid_tvb;\r\nint len, start_offset, oid_start_offset;\r\nvolatile int offset;\r\ngint8 appclass;\r\ngboolean pc, ind_field;\r\ngint32 tag;\r\nguint32 len1;\r\nconst char *oid;\r\nfragment_head *fd_head=NULL;\r\ngssapi_frag_info_t *fi;\r\ntvbuff_t *volatile gss_tvb=NULL;\r\nasn1_ctx_t asn1_ctx;\r\nstart_offset=0;\r\noffset=0;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\r\nencrypt_info->gssapi_data_encrypted = FALSE;\r\nconversation = find_or_create_conversation(pinfo);\r\ngss_info = (gssapi_conv_info_t *)conversation_get_proto_data(conversation, proto_gssapi);\r\nif (!gss_info) {\r\ngss_info = wmem_new(wmem_file_scope(), gssapi_conv_info_t);\r\ngss_info->oid=NULL;\r\ngss_info->do_reassembly=FALSE;\r\ngss_info->frags=wmem_tree_new(wmem_file_scope());\r\nconversation_add_proto_data(conversation, proto_gssapi, gss_info);\r\n}\r\nitem = proto_tree_add_item(\r\ntree, proto_gssapi, tvb, offset, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(item, ett_gssapi);\r\nTRY {\r\ngss_tvb=tvb;\r\nif( (!pinfo->fd->flags.visited)\r\n&& (gss_info->do_reassembly)\r\n&& (gssapi_reassembly) ){\r\nfi=(gssapi_frag_info_t *)wmem_tree_lookup32(gss_info->frags, gss_info->first_frame);\r\nif(!fi){\r\ngoto done;\r\n}\r\nwmem_tree_insert32(gss_info->frags, pinfo->num, fi);\r\nfd_head=fragment_add(&gssapi_reassembly_table,\r\ntvb, 0, pinfo, fi->first_frame, NULL,\r\ngss_info->frag_offset,\r\ntvb_captured_length(tvb), TRUE);\r\ngss_info->frag_offset+=tvb_captured_length(tvb);\r\nif(!fd_head){\r\ngoto done;\r\n}\r\ngss_info->do_reassembly=FALSE;\r\nfi->reassembled_in=pinfo->num;\r\ngss_tvb=tvb_new_chain(tvb, fd_head->tvb_data);\r\nadd_new_data_source(pinfo, gss_tvb, "Reassembled GSSAPI");\r\n}\r\nif( (pinfo->fd->flags.visited)\r\n&& (gssapi_reassembly) ){\r\nfi=(gssapi_frag_info_t *)wmem_tree_lookup32(gss_info->frags, pinfo->num);\r\nif(fi){\r\nfd_head=fragment_get(&gssapi_reassembly_table,\r\npinfo, fi->first_frame, NULL);\r\nif(fd_head && (fd_head->flags&FD_DEFRAGMENTED)){\r\nif(pinfo->num==fi->reassembled_in){\r\nproto_item *frag_tree_item;\r\ngss_tvb=tvb_new_chain(tvb, fd_head->tvb_data);\r\nadd_new_data_source(pinfo, gss_tvb, "Reassembled GSSAPI");\r\nshow_fragment_tree(fd_head, &gssapi_frag_items, tree, pinfo, tvb, &frag_tree_item);\r\n} else {\r\nproto_item *it;\r\nit=proto_tree_add_uint(tree, hf_gssapi_reassembled_in, tvb, 0, 0, fi->reassembled_in);\r\nPROTO_ITEM_SET_GENERATED(it);\r\ngoto done;\r\n}\r\n}\r\n}\r\n}\r\noffset = get_ber_identifier(gss_tvb, offset, &appclass, &pc, &tag);\r\noffset = get_ber_length(gss_tvb, offset, &len1, &ind_field);\r\nif (!(appclass == BER_CLASS_APP && pc && tag == 0)) {\r\nif ((tvb_captured_length_remaining(gss_tvb, start_offset)>7) && (tvb_strneql(gss_tvb, start_offset, "NTLMSSP", 7) == 0)) {\r\nreturn_offset = call_dissector(ntlmssp_handle,\r\ntvb_new_subset_remaining(gss_tvb, start_offset),\r\npinfo, subtree);\r\ngoto done;\r\n}\r\nif ((tvb_captured_length_remaining(gss_tvb, start_offset)>16) &&\r\n((tvb_memeql(gss_tvb, start_offset, "\x01\x00\x00\x00", 4) == 0))) {\r\nreturn_offset = call_dissector(ntlmssp_payload_handle,\r\ntvb_new_subset_remaining(gss_tvb, start_offset),\r\npinfo, subtree);\r\nencrypt_info->gssapi_data_encrypted = TRUE;\r\ngoto done;\r\n}\r\nif ((tvb_captured_length_remaining(gss_tvb, start_offset)==16) &&\r\n((tvb_memeql(gss_tvb, start_offset, "\x01\x00\x00\x00", 4) == 0))) {\r\nif( is_verifier ) {\r\nreturn_offset = call_dissector(ntlmssp_verf_handle,\r\ntvb_new_subset_remaining(gss_tvb, start_offset),\r\npinfo, subtree);\r\n}\r\nelse if( encrypt_info->gssapi_encrypted_tvb ) {\r\nreturn_offset = call_dissector_with_data(ntlmssp_data_only_handle,\r\ntvb_new_subset_remaining(encrypt_info->gssapi_encrypted_tvb, 0),\r\npinfo, subtree, &encrypt_info->gssapi_decrypted_tvb);\r\nencrypt_info->gssapi_data_encrypted = TRUE;\r\n}\r\ngoto done;\r\n}\r\nif ((tvb_captured_length_remaining(gss_tvb, start_offset)>2) &&\r\n((tvb_memeql(gss_tvb, start_offset, "\04\x04", 2) == 0) ||\r\n(tvb_memeql(gss_tvb, start_offset, "\05\x04", 2) == 0))) {\r\nreturn_offset = call_dissector_with_data(spnego_krb5_wrap_handle,\r\ntvb_new_subset_remaining(gss_tvb, start_offset),\r\npinfo, subtree, encrypt_info);\r\ngoto done;\r\n}\r\noidvalue = (gssapi_oid_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_gssapi, 0);\r\nif (!oidvalue && !pinfo->fd->flags.visited)\r\n{\r\noidvalue = gss_info->oid;\r\nif (gss_info->oid)\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_gssapi, 0, gss_info->oid);\r\n}\r\nif (!oidvalue)\r\n{\r\nproto_tree_add_expert_format(subtree, pinfo, &ei_gssapi_unknown_header, gss_tvb, start_offset, 0,\r\n"Unknown header (class=%d, pc=%d, tag=%d)",\r\nappclass, pc, tag);\r\nreturn_offset = tvb_captured_length(gss_tvb);\r\ngoto done;\r\n} else {\r\ntvbuff_t *oid_tvb_local;\r\noid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset);\r\nif (is_verifier)\r\nhandle = oidvalue->wrap_handle;\r\nelse\r\nhandle = oidvalue->handle;\r\nlen = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info);\r\nif (len == 0)\r\nreturn_offset = tvb_captured_length(gss_tvb);\r\nelse\r\nreturn_offset = start_offset + len;\r\ngoto done;\r\n}\r\n}\r\noid_start_offset=offset;\r\noffset=dissect_ber_object_identifier_str(FALSE, &asn1_ctx, subtree, gss_tvb, offset, hf_gssapi_oid, &oid);\r\noidvalue = gssapi_lookup_oid_str(oid);\r\nif( (!pinfo->fd->flags.visited)\r\n&& (oidvalue)\r\n&& (tvb_captured_length(gss_tvb)==tvb_reported_length(gss_tvb))\r\n&& (len1>(guint32)tvb_captured_length_remaining(gss_tvb, oid_start_offset))\r\n&& (gssapi_reassembly) ){\r\nfi=wmem_new(wmem_file_scope(), gssapi_frag_info_t);\r\nfi->first_frame=pinfo->num;\r\nfi->reassembled_in=0;\r\nwmem_tree_insert32(gss_info->frags, pinfo->num, fi);\r\nfragment_add(&gssapi_reassembly_table,\r\ngss_tvb, 0, pinfo, pinfo->num, NULL,\r\n0, tvb_captured_length(gss_tvb), TRUE);\r\nfragment_set_tot_len(&gssapi_reassembly_table,\r\npinfo, pinfo->num, NULL, len1+oid_start_offset);\r\ngss_info->do_reassembly=TRUE;\r\ngss_info->first_frame=pinfo->num;\r\ngss_info->frag_offset=tvb_captured_length(gss_tvb);\r\ngoto done;\r\n}\r\nif ((oidvalue == NULL) ||\r\n!proto_is_protocol_enabled(oidvalue->proto)) {\r\nproto_tree_add_item(subtree, hf_gssapi_token_object, gss_tvb, oid_start_offset, -1, ENC_NA);\r\nreturn_offset = tvb_captured_length(gss_tvb);\r\ngoto done;\r\n}\r\nif(!gss_info->oid){\r\ngss_info->oid=oidvalue;\r\n}\r\nif (is_verifier) {\r\nhandle = oidvalue->wrap_handle;\r\nif (handle != NULL) {\r\noid_tvb = tvb_new_subset_remaining(gss_tvb, offset);\r\nlen = call_dissector_with_data(handle, oid_tvb, pinfo, subtree, encrypt_info);\r\nif (len == 0)\r\nreturn_offset = tvb_captured_length(gss_tvb);\r\nelse\r\nreturn_offset = offset + len;\r\n} else {\r\nproto_tree_add_item(subtree, hf_gssapi_auth_verifier, gss_tvb, offset, -1, ENC_NA);\r\nreturn_offset = tvb_captured_length(gss_tvb);\r\n}\r\n} else {\r\nhandle = oidvalue->handle;\r\nif (handle != NULL) {\r\noid_tvb = tvb_new_subset_remaining(gss_tvb, offset);\r\nlen = call_dissector_with_data(handle, oid_tvb, pinfo, subtree, encrypt_info);\r\nif (len == 0)\r\nreturn_offset = tvb_captured_length(gss_tvb);\r\nelse\r\nreturn_offset = offset + len;\r\n} else {\r\nproto_tree_add_item(subtree, hf_gssapi_auth_credentials, gss_tvb, offset, -1, ENC_NA);\r\nreturn_offset = tvb_captured_length(gss_tvb);\r\n}\r\n}\r\ndone:\r\n;\r\n} CATCH_NONFATAL_ERRORS {\r\nshow_exception(gss_tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);\r\n} ENDTRY;\r\nproto_item_set_len(item, return_offset);\r\nreturn return_offset;\r\n}\r\nstatic int\r\ndissect_gssapi_work_wrapper(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gssapi_encrypt_info_t* encrypt_info, gboolean is_verifier)\r\n{\r\nint ret;\r\ngssapi_encrypt_info_t pass_encrypt_info;\r\nif (encrypt_info != NULL)\r\n{\r\npass_encrypt_info = *encrypt_info;\r\n}\r\nelse\r\n{\r\nmemset(&pass_encrypt_info, 0, sizeof(pass_encrypt_info));\r\n}\r\nret = dissect_gssapi_work(tvb, pinfo, tree, is_verifier, &pass_encrypt_info);\r\nif (encrypt_info != NULL)\r\n{\r\n*encrypt_info = pass_encrypt_info;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ndissect_gssapi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nreturn dissect_gssapi_work_wrapper(tvb, pinfo, tree, (gssapi_encrypt_info_t*)data, FALSE);\r\n}\r\nstatic int\r\ndissect_gssapi_verf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nreturn dissect_gssapi_work_wrapper(tvb, pinfo, tree, (gssapi_encrypt_info_t*)data, TRUE);\r\n}\r\nvoid\r\nproto_register_gssapi(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_gssapi_oid,\r\n{ "OID", "gss-api.OID", FT_STRING, BASE_NONE,\r\nNULL, 0, "This is a GSS-API Object Identifier", HFILL }},\r\n{ &hf_gssapi_token_object,\r\n{ "Token object", "gss-api.token_object", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_gssapi_auth_verifier,\r\n{ "Authentication verifier", "gss-api.auth_verifier", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_gssapi_auth_credentials,\r\n{ "Authentication credentials", "gss-api.auth_credentials", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_gssapi_segment,\r\n{ "GSSAPI Segment", "gss-api.segment", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_gssapi_segments,\r\n{ "GSSAPI Segments", "gss-api.segment.segments", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_gssapi_segment_overlap,\r\n{ "Fragment overlap", "gss-api.segment.overlap", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "Fragment overlaps with other fragments", HFILL }},\r\n{ &hf_gssapi_segment_overlap_conflict,\r\n{ "Conflicting data in fragment overlap", "gss-api.segment.overlap.conflict", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "Overlapping fragments contained conflicting data", HFILL }},\r\n{ &hf_gssapi_segment_multiple_tails,\r\n{ "Multiple tail fragments found", "gss-api.segment.multipletails", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "Several tails were found when defragmenting the packet", HFILL }},\r\n{ &hf_gssapi_segment_too_long_fragment,\r\n{ "Fragment too long", "gss-api.segment.toolongfragment", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "Fragment contained data past end of packet", HFILL }},\r\n{ &hf_gssapi_segment_error,\r\n{ "Defragmentation error", "gss-api.segment.error", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "Defragmentation error due to illegal fragments", HFILL }},\r\n{ &hf_gssapi_segment_count,\r\n{ "Fragment count", "gss-api.segment.count", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL }},\r\n{ &hf_gssapi_reassembled_in,\r\n{ "Reassembled In", "gss-api.reassembled_in", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "The frame where this pdu is reassembled", HFILL }},\r\n{ &hf_gssapi_reassembled_length,\r\n{ "Reassembled GSSAPI length", "gss-api.reassembled.length", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "The total length of the reassembled payload", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_gssapi,\r\n&ett_gssapi_segment,\r\n&ett_gssapi_segments,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_gssapi_unknown_header, { "gssapi.unknown_header", PI_PROTOCOL, PI_WARN, "Unknown header", EXPFILL }},\r\n};\r\nmodule_t *gssapi_module;\r\nexpert_module_t *expert_gssapi;\r\nproto_gssapi = proto_register_protocol(\r\n"GSS-API Generic Security Service Application Program Interface",\r\n"GSS-API", "gss-api");\r\ngssapi_module = prefs_register_protocol(proto_gssapi, NULL);\r\nprefs_register_bool_preference(gssapi_module, "gssapi_reassembly",\r\n"Reassemble fragmented GSSAPI blobs",\r\n"Whether or not to try reassembling GSSAPI blobs spanning multiple (SMB/SessionSetup) PDUs",\r\n&gssapi_reassembly);\r\nproto_register_field_array(proto_gssapi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_gssapi = expert_register_protocol(proto_gssapi);\r\nexpert_register_field_array(expert_gssapi, ei, array_length(ei));\r\nregister_dissector("gssapi", dissect_gssapi, proto_gssapi);\r\nregister_dissector("gssapi_verf", dissect_gssapi_verf, proto_gssapi);\r\ngssapi_oids = g_hash_table_new(gssapi_oid_hash, gssapi_oid_equal);\r\nregister_init_routine(gssapi_reassembly_init);\r\nregister_cleanup_routine(gssapi_reassembly_cleanup);\r\n}\r\nstatic int\r\nwrap_dissect_gssapi(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di _U_, guint8 *drep _U_)\r\n{\r\ntvbuff_t *auth_tvb;\r\nauth_tvb = tvb_new_subset_remaining(tvb, offset);\r\ndissect_gssapi(auth_tvb, pinfo, tree, NULL);\r\nreturn tvb_captured_length_remaining(tvb, offset);\r\n}\r\nint\r\nwrap_dissect_gssapi_verf(tvbuff_t *tvb, int offset, packet_info *pinfo,\r\nproto_tree *tree, dcerpc_info *di _U_, guint8 *drep _U_)\r\n{\r\ntvbuff_t *auth_tvb;\r\nauth_tvb = tvb_new_subset_remaining(tvb, offset);\r\nreturn dissect_gssapi_verf(auth_tvb, pinfo, tree, NULL);\r\n}\r\ntvbuff_t *\r\nwrap_dissect_gssapi_payload(tvbuff_t *data_tvb, tvbuff_t *auth_tvb,\r\nint offset _U_, packet_info *pinfo,\r\ndcerpc_auth_info *auth_info _U_)\r\n{\r\ntvbuff_t *result;\r\ngssapi_encrypt_info_t gssapi_encrypt;\r\nmemset(&gssapi_encrypt, 0x0, sizeof(gssapi_encrypt_info_t));\r\nif((!auth_tvb)||(!data_tvb)){\r\nreturn NULL;\r\n}\r\ngssapi_encrypt.decrypt_gssapi_tvb=DECRYPT_GSSAPI_DCE;\r\ngssapi_encrypt.gssapi_encrypted_tvb=data_tvb;\r\ndissect_gssapi(auth_tvb, pinfo, NULL, &gssapi_encrypt);\r\nresult=gssapi_encrypt.gssapi_decrypted_tvb;\r\nreturn result;\r\n}\r\nvoid\r\nproto_reg_handoff_gssapi(void)\r\n{\r\ndissector_handle_t gssapi_handle;\r\nntlmssp_handle = find_dissector_add_dependency("ntlmssp", proto_gssapi);\r\nntlmssp_payload_handle = find_dissector_add_dependency("ntlmssp_payload", proto_gssapi);\r\nntlmssp_verf_handle = find_dissector_add_dependency("ntlmssp_verf", proto_gssapi);\r\nntlmssp_data_only_handle = find_dissector_add_dependency("ntlmssp_data_only", proto_gssapi);\r\nspnego_krb5_wrap_handle = find_dissector_add_dependency("spnego-krb5-wrap", proto_gssapi);\r\nregister_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_CONNECT,\r\nDCE_C_RPC_AUTHN_PROTOCOL_SPNEGO,\r\n&gssapi_auth_fns);\r\nregister_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_PKT_INTEGRITY,\r\nDCE_C_RPC_AUTHN_PROTOCOL_SPNEGO,\r\n&gssapi_auth_fns);\r\nregister_dcerpc_auth_subdissector(DCE_C_AUTHN_LEVEL_PKT_PRIVACY,\r\nDCE_C_RPC_AUTHN_PROTOCOL_SPNEGO,\r\n&gssapi_auth_fns);\r\ngssapi_handle = find_dissector("gssapi");\r\ndissector_add_string("dns.tsig.mac", "gss.microsoft.com", gssapi_handle);\r\n}
