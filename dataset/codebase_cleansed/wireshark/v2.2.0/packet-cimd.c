static void dissect_cimd_parameter(tvbuff_t *tvb, proto_tree *tree, gint pindex, gint startOffset, gint endOffset)\r\n{\r\nproto_tree *param_tree;\r\nparam_tree = proto_tree_add_subtree(tree, tvb, startOffset + 1, endOffset - (startOffset + 1),\r\n(*vals_hdr_PC[pindex].ett_p), NULL, cimd_vals_PC[pindex].strptr);\r\nproto_tree_add_item(param_tree, hf_cimd_pcode_indicator, tvb,\r\nstartOffset + 1, CIMD_PC_LENGTH, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(param_tree, (*vals_hdr_PC[pindex].hf_p), tvb,\r\nstartOffset + 1 + CIMD_PC_LENGTH + 1, endOffset - (startOffset + 1 + CIMD_PC_LENGTH + 1), ENC_ASCII|ENC_NA);\r\n}\r\nstatic void dissect_cimd_ud(tvbuff_t *tvb, proto_tree *tree, gint pindex, gint startOffset, gint endOffset)\r\n{\r\nproto_tree *param_tree;\r\ngchar *payloadText, *tmpBuffer, *tmpBuffer1;\r\nint loop,i,poz, bufPoz = 0, bufPoz1 = 0, size, size1, resch;\r\ngint g_offset, g_size;\r\ngchar token[4];\r\ngchar ch;\r\nstatic const char* mapping[128] = {\r\n"_Oa" , "_L-", "" , "_Y-", "_e`", "_e'", "_u`", "_i`", "_o`", "_C,",\r\n"" , "_O/", "_o/" , "" , "_A*", "_a*", "_gd", "_--", "_gf", "_gg", "_gl",\r\n"_go" , "_gp", "_gi" , "_gs", "_gt", "_gx", "_XX", "_AE", "_ae", "_ss", "_E'",\r\n"" , "" , "_qq" , "" , "_ox", "" , "" , "" , "" , "" , "" , "" , "" , "" , "", "",\r\n"" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "", "",\r\n"_!!" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "", "",\r\n"" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "_A\"", "_O\"", "_N~",\r\n"_U\"", "_so", "_??" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" ,\r\n"" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "" , "", "_a\"",\r\n"_o\"", "_n~", "_n\"","_a`"\r\n};\r\nparam_tree = proto_tree_add_subtree(tree, tvb,\r\nstartOffset + 1, endOffset - (startOffset + 1),\r\n(*vals_hdr_PC[pindex].ett_p), NULL, cimd_vals_PC[pindex].strptr\r\n);\r\nproto_tree_add_item(param_tree, hf_cimd_pcode_indicator, tvb,\r\nstartOffset + 1, CIMD_PC_LENGTH, ENC_ASCII|ENC_NA);\r\ng_offset = startOffset + 1 + CIMD_PC_LENGTH + 1;\r\ng_size = endOffset - g_offset;\r\npayloadText = tvb_format_text(tvb, g_offset, g_size);\r\nsize = (int)strlen(payloadText);\r\ntmpBuffer = (gchar*)wmem_alloc(wmem_packet_scope(), size+1);\r\nfor (loop = 0; loop < size; loop++)\r\n{\r\nif (payloadText[loop] == '_')\r\n{\r\nif (loop < size - 2)\r\n{\r\ntoken[0] = payloadText[loop++];\r\ntoken[1] = payloadText[loop++];\r\ntoken[2] = payloadText[loop];\r\ntoken[3] = '\0';\r\npoz = -1;\r\nfor (i = 0; i < 128; i++)\r\n{\r\nif (strcmp(token, mapping[i]) == 0)\r\n{\r\npoz = i;\r\nbreak;\r\n}\r\n}\r\nif (poz > 0)\r\n{\r\ntmpBuffer[bufPoz++] = poz;\r\n}\r\nelse\r\n{\r\ntmpBuffer[bufPoz++] = payloadText[loop-2];\r\ntmpBuffer[bufPoz++] = payloadText[loop-1];\r\ntmpBuffer[bufPoz++] = payloadText[loop];\r\n}\r\n}\r\nelse\r\n{\r\nif (loop < size) tmpBuffer[bufPoz++] = payloadText[loop++];\r\nif (loop < size) tmpBuffer[bufPoz++] = payloadText[loop++];\r\nif (loop < size) tmpBuffer[bufPoz++] = payloadText[loop++];\r\n}\r\n}\r\nelse\r\n{\r\ntmpBuffer[bufPoz++] = payloadText[loop];\r\n}\r\n}\r\ntmpBuffer[bufPoz] = '\0';\r\nsize1 = (int)strlen(tmpBuffer);\r\ntmpBuffer1 = (gchar*)wmem_alloc(wmem_packet_scope(), size1+1);\r\nfor (loop=0; loop<size1; loop++)\r\n{\r\nch = tmpBuffer[loop];\r\nswitch ((gint)ch)\r\n{\r\ncase 0x40: resch = 0x0040; break;\r\ncase 0x01: resch = 0x00A3; break;\r\ncase 0x02: resch = 0x0024; break;\r\ncase 0x03: resch = 0x00A5; break;\r\ncase 0x04: resch = 0x00E8; break;\r\ncase 0x05: resch = 0x00E9; break;\r\ncase 0x06: resch = 0x00F9; break;\r\ncase 0x07: resch = 0x00EC; break;\r\ncase 0x08: resch = 0x00F2; break;\r\ncase 0x09: resch = 0x00E7; break;\r\ncase 0x0B: resch = 0x00D8; break;\r\ncase 0x0C: resch = 0x00F8; break;\r\ncase 0x0E: resch = 0x00C5; break;\r\ncase 0x0F: resch = 0x00E5; break;\r\ncase 0x11: resch = 0x005F; break;\r\ncase 0x1C: resch = 0x00C6; break;\r\ncase 0x1D: resch = 0x00E6; break;\r\ncase 0x1E: resch = 0x00DF; break;\r\ncase 0x1F: resch = 0x00C9; break;\r\ncase 0x20: resch = 0x0020; break;\r\ncase 0x21: resch = 0x0021; break;\r\ncase 0x22: resch = 0x0022; break;\r\ncase 0x23: resch = 0x0023; break;\r\ncase 0xA4: resch = 0x00A4; break;\r\ncase 0x25: resch = 0x0025; break;\r\ncase 0x26: resch = 0x0026; break;\r\ncase 0x27: resch = 0x0027; break;\r\ncase 0x28: resch = 0x0028; break;\r\ncase 0x29: resch = 0x0029; break;\r\ncase 0x2A: resch = 0x002A; break;\r\ncase 0x2B: resch = 0x002B; break;\r\ncase 0x2C: resch = 0x002C; break;\r\ncase 0x2D: resch = 0x002D; break;\r\ncase 0x2E: resch = 0x002E; break;\r\ncase 0x2F: resch = 0x002F; break;\r\ncase 0x30: resch = 0x0030; break;\r\ncase 0x31: resch = 0x0031; break;\r\ncase 0x32: resch = 0x0032; break;\r\ncase 0x33: resch = 0x0033; break;\r\ncase 0x34: resch = 0x0034; break;\r\ncase 0x35: resch = 0x0035; break;\r\ncase 0x36: resch = 0x0036; break;\r\ncase 0x37: resch = 0x0037; break;\r\ncase 0x38: resch = 0x0038; break;\r\ncase 0x39: resch = 0x0039; break;\r\ncase 0x3A: resch = 0x003A; break;\r\ncase 0x3B: resch = 0x003B; break;\r\ncase 0x3C: resch = 0x003C; break;\r\ncase 0x3D: resch = 0x003D; break;\r\ncase 0x3E: resch = 0x003E; break;\r\ncase 0x3F: resch = 0x003F; break;\r\ncase 0x41: resch = 0x0041; break;\r\ncase 0x42: resch = 0x0042; break;\r\ncase 0x43: resch = 0x0043; break;\r\ncase 0x44: resch = 0x0044; break;\r\ncase 0x45: resch = 0x0045; break;\r\ncase 0x46: resch = 0x0046; break;\r\ncase 0x47: resch = 0x0047; break;\r\ncase 0x48: resch = 0x0048; break;\r\ncase 0x49: resch = 0x0049; break;\r\ncase 0x4A: resch = 0x004A; break;\r\ncase 0x4B: resch = 0x004B; break;\r\ncase 0x4C: resch = 0x004C; break;\r\ncase 0x4D: resch = 0x004D; break;\r\ncase 0x4E: resch = 0x004E; break;\r\ncase 0x4F: resch = 0x004F; break;\r\ncase 0x50: resch = 0x0050; break;\r\ncase 0x51: resch = 0x0051; break;\r\ncase 0x52: resch = 0x0052; break;\r\ncase 0x53: resch = 0x0053; break;\r\ncase 0x54: resch = 0x0054; break;\r\ncase 0x55: resch = 0x0055; break;\r\ncase 0x56: resch = 0x0056; break;\r\ncase 0x57: resch = 0x0057; break;\r\ncase 0x58: resch = 0x0058; break;\r\ncase 0x59: resch = 0x0059; break;\r\ncase 0x5A: resch = 0x005A; break;\r\ncase 0x5B: resch = 0x00C4; break;\r\ncase 0x5C: resch = 0x00D6; break;\r\ncase 0x5D: resch = 0x00D1; break;\r\ncase 0x5E: resch = 0x00DC; break;\r\ncase 0x5F: resch = 0x00A7; break;\r\ncase 0x60: resch = 0x00BF; break;\r\ncase 0x61: resch = 0x0061; break;\r\ncase 0x62: resch = 0x0062; break;\r\ncase 0x63: resch = 0x0063; break;\r\ncase 0x64: resch = 0x0064; break;\r\ncase 0x65: resch = 0x0065; break;\r\ncase 0x66: resch = 0x0066; break;\r\ncase 0x67: resch = 0x0067; break;\r\ncase 0x68: resch = 0x0068; break;\r\ncase 0x69: resch = 0x0069; break;\r\ncase 0x6A: resch = 0x006A; break;\r\ncase 0x6B: resch = 0x006B; break;\r\ncase 0x6C: resch = 0x006C; break;\r\ncase 0x6D: resch = 0x006D; break;\r\ncase 0x6E: resch = 0x006E; break;\r\ncase 0x6F: resch = 0x006F; break;\r\ncase 0x70: resch = 0x0070; break;\r\ncase 0x71: resch = 0x0071; break;\r\ncase 0x72: resch = 0x0072; break;\r\ncase 0x73: resch = 0x0073; break;\r\ncase 0x74: resch = 0x0074; break;\r\ncase 0x75: resch = 0x0075; break;\r\ncase 0x76: resch = 0x0076; break;\r\ncase 0x77: resch = 0x0077; break;\r\ncase 0x78: resch = 0x0078; break;\r\ncase 0x79: resch = 0x0079; break;\r\ncase 0x7A: resch = 0x007A; break;\r\ncase 0x7B: resch = 0x00E4; break;\r\ncase 0x7C: resch = 0x00F6; break;\r\ncase 0x7D: resch = 0x00F1; break;\r\ncase 0x7F: resch = 0x00E0; break;\r\ndefault:resch = ch; break;\r\n}\r\ntmpBuffer1[bufPoz1++] = (gchar)resch;\r\n}\r\ntmpBuffer1[bufPoz1] = '\0';\r\nproto_tree_add_string(param_tree, (*vals_hdr_PC[pindex].hf_p), tvb, g_offset, g_size, tmpBuffer1);\r\n}\r\nstatic void dissect_cimd_dcs(tvbuff_t *tvb, proto_tree *tree, gint pindex, gint startOffset, gint endOffset)\r\n{\r\nproto_tree *param_tree;\r\ngint offset;\r\nguint32 dcs;\r\nguint32 dcs_cg;\r\nparam_tree = proto_tree_add_subtree(tree, tvb,\r\nstartOffset + 1, endOffset - (startOffset + 1),\r\n(*vals_hdr_PC[pindex].ett_p), NULL, cimd_vals_PC[pindex].strptr\r\n);\r\nproto_tree_add_item(param_tree, hf_cimd_pcode_indicator, tvb,\r\nstartOffset + 1, CIMD_PC_LENGTH, ENC_ASCII|ENC_NA);\r\noffset = startOffset + 1 + CIMD_PC_LENGTH + 1;\r\ndcs = (guint32) strtoul(tvb_get_string_enc(wmem_packet_scope(), tvb, offset, endOffset - offset, ENC_ASCII), NULL, 10);\r\nproto_tree_add_uint(param_tree, (*vals_hdr_PC[pindex].hf_p), tvb, offset, endOffset - offset, dcs);\r\ndcs_cg = (dcs & 0xF0) >> 4;\r\nif (dcs_cg <= 0x07)\r\n{\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_coding_group_indicatorC0, tvb, offset, 1, dcs);\r\n}\r\nelse\r\n{\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_coding_group_indicatorF0, tvb, offset, 1, dcs);\r\n}\r\nif (dcs_cg <= 0x07)\r\n{\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_compressed_indicator, tvb, offset, 1, dcs);\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_message_class_meaning_indicator, tvb, offset, 1, dcs);\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_character_set_indicator0C, tvb, offset, 1, dcs);\r\nif (dcs & 0x10)\r\n{\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_message_class_indicator, tvb, offset, 1, dcs);\r\n}\r\n}\r\nelse if (dcs_cg >= 0x0C && dcs_cg <= 0x0E)\r\n{\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_indication_sense, tvb, offset, 1, dcs);\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_indication_type, tvb, offset, 1, dcs);\r\n}\r\nelse if (dcs_cg == 0x0F)\r\n{\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_character_set_indicator04, tvb, offset, 1, dcs);\r\nproto_tree_add_uint(param_tree, hf_cimd_dcs_message_class_indicator, tvb, offset, 1, dcs);\r\n}\r\n}\r\nstatic void dissect_cimd_error_code( tvbuff_t *tvb, proto_tree *tree, gint pindex, gint startOffset, gint endOffset )\r\n{\r\nproto_tree *param_tree;\r\nguint32 err_code;\r\nparam_tree = proto_tree_add_subtree(tree, tvb, startOffset + 1, endOffset - (startOffset + 1),\r\n(*vals_hdr_PC[pindex].ett_p), NULL, cimd_vals_PC[pindex].strptr);\r\nproto_tree_add_item(param_tree, hf_cimd_pcode_indicator, tvb, startOffset + 1, CIMD_PC_LENGTH, ENC_ASCII|ENC_NA);\r\nerr_code = (guint32) strtoul(tvb_get_string_enc(wmem_packet_scope(), tvb,\r\nstartOffset + 1 + CIMD_PC_LENGTH + 1, endOffset - (startOffset + 1 + CIMD_PC_LENGTH + 1), ENC_ASCII),\r\nNULL, 10);\r\nproto_tree_add_uint(param_tree, (*vals_hdr_PC[pindex].hf_p), tvb, startOffset + 1 + CIMD_PC_LENGTH + 1, endOffset - (startOffset + 1 + CIMD_PC_LENGTH + 1), err_code);\r\n}\r\nstatic void\r\ndissect_cimd_operation(tvbuff_t *tvb, proto_tree *tree, gint etxp, guint16 checksum, guint8 last1,guint8 OC, guint8 PN)\r\n{\r\nguint32 PC = 0;\r\ngint idx;\r\ngint offset = 0;\r\ngint endOffset = 0;\r\nproto_item *cimd_item;\r\nproto_tree *cimd_tree;\r\ncimd_item = proto_tree_add_item(tree, proto_cimd, tvb, 0, etxp + 1, ENC_NA);\r\ncimd_tree = proto_item_add_subtree(cimd_item, ett_cimd);\r\nproto_tree_add_uint(cimd_tree, hf_cimd_opcode_indicator, tvb, CIMD_OC_OFFSET, CIMD_OC_LENGTH, OC);\r\nproto_tree_add_uint(cimd_tree, hf_cimd_packet_number_indicator, tvb, CIMD_PN_OFFSET, CIMD_PN_LENGTH, PN);\r\noffset = CIMD_PN_OFFSET + CIMD_PN_LENGTH;\r\nwhile (offset < etxp && tvb_get_guint8(tvb, offset) == CIMD_DELIM)\r\n{\r\nendOffset = tvb_find_guint8(tvb, offset + 1, etxp, CIMD_DELIM);\r\nif (endOffset == -1)\r\nbreak;\r\nPC = (guint32) strtoul(tvb_get_string_enc(wmem_packet_scope(), tvb, offset + 1, CIMD_PC_LENGTH, ENC_ASCII), NULL, 10);\r\ntry_val_to_str_idx(PC, cimd_vals_PC, &idx);\r\nif (idx != -1 && tree)\r\n{\r\n(vals_hdr_PC[idx].diss)(tvb, cimd_tree, idx, offset, endOffset);\r\n}\r\noffset = endOffset;\r\n}\r\nif (last1 != CIMD_DELIM)\r\n{\r\nproto_tree_add_uint(cimd_tree, hf_cimd_checksum_indicator, tvb, etxp - 2, 2, checksum);\r\n}\r\n}\r\nstatic int\r\ndissect_cimd(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint8 OC;\r\nguint8 PN;\r\nguint16 checksum = 0;\r\nguint16 pkt_check = 0;\r\ngint etxp = 0;\r\ngint offset = 0;\r\ngboolean checksumIsValid = TRUE;\r\nguint8 last1, last2, last3;\r\netxp = tvb_find_guint8(tvb, CIMD_PN_OFFSET + CIMD_PN_LENGTH, -1, CIMD_ETX);\r\nif (etxp == -1) return 0;\r\nOC = (guint8)strtoul(tvb_get_string_enc(wmem_packet_scope(), tvb, CIMD_OC_OFFSET, CIMD_OC_LENGTH, ENC_ASCII), NULL, 10);\r\nPN = (guint8)strtoul(tvb_get_string_enc(wmem_packet_scope(), tvb, CIMD_PN_OFFSET, CIMD_PN_LENGTH, ENC_ASCII), NULL, 10);\r\nlast1 = tvb_get_guint8(tvb, etxp - 1);\r\nlast2 = tvb_get_guint8(tvb, etxp - 2);\r\nlast3 = tvb_get_guint8(tvb, etxp - 3);\r\nif (last1 == CIMD_DELIM) {\r\n} else if (last1 != CIMD_DELIM && last2 != CIMD_DELIM && last3 == CIMD_DELIM) {\r\nchecksum = (guint16)strtoul(tvb_get_string_enc(wmem_packet_scope(), tvb, etxp - 2, 2, ENC_ASCII), NULL, 16);\r\nfor (; offset < (etxp - 2); offset++)\r\n{\r\npkt_check += tvb_get_guint8(tvb, offset);\r\npkt_check &= 0xFF;\r\n}\r\nchecksumIsValid = (checksum == pkt_check);\r\n} else {\r\nchecksumIsValid = FALSE;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CIMD");\r\nif (checksumIsValid)\r\ncol_add_str(pinfo->cinfo, COL_INFO, val_to_str(OC, vals_hdr_OC, "Unknown (%d)"));\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s - %s", val_to_str(OC, vals_hdr_OC, "Unknown (%d)"), "invalid checksum");\r\ndissect_cimd_operation(tvb, tree, etxp, checksum, last1, OC, PN);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_cimd_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nint etxp;\r\nguint8 opcode = 0;\r\nif (tvb_captured_length(tvb) < CIMD_MIN_LENGTH)\r\nreturn FALSE;\r\nif (tvb_get_guint8(tvb, 0) != CIMD_STX)\r\nreturn FALSE;\r\netxp = tvb_find_guint8(tvb, CIMD_OC_OFFSET, -1, CIMD_ETX);\r\nif (etxp == -1)\r\n{\r\nreturn FALSE;\r\n}\r\nopcode = (guint8)strtoul(tvb_get_string_enc(wmem_packet_scope(), tvb, CIMD_OC_OFFSET, CIMD_OC_LENGTH, ENC_ASCII), NULL, 10);\r\nif (try_val_to_str(opcode, vals_hdr_OC) == NULL)\r\nreturn FALSE;\r\nif (tvb_get_guint8(tvb, CIMD_OC_OFFSET + CIMD_OC_LENGTH) != CIMD_COLON)\r\nreturn FALSE;\r\nif (tvb_get_guint8(tvb, CIMD_PN_OFFSET + CIMD_PN_LENGTH) != CIMD_DELIM)\r\nreturn FALSE;\r\ndissect_cimd(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_cimd(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_cimd_opcode_indicator,\r\n{ "Operation Code", "cimd.opcode",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_packet_number_indicator,\r\n{ "Packet Number", "cimd.pnumber",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_pcode_indicator,\r\n{ "Parameter Code", "cimd.pcode",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_checksum_indicator,\r\n{ "Checksum", "cimd.chksum",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_dcs_coding_group_indicatorC0,\r\n{ "DCS Coding Group", "cimd.dcs.cg",\r\nFT_UINT8, BASE_DEC, VALS(cimd_dcs_coding_groups), 0xC0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_dcs_coding_group_indicatorF0,\r\n{ "DCS Coding Group", "cimd.dcs.cg",\r\nFT_UINT8, BASE_DEC, VALS(cimd_dcs_coding_groups), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_dcs_compressed_indicator,\r\n{ "DCS Compressed Flag", "cimd.dcs.cf",\r\nFT_UINT8, BASE_DEC, VALS(cimd_dcs_compressed), 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_dcs_message_class_meaning_indicator,\r\n{ "DCS Message Class Meaning", "cimd.dcs.mcm",\r\nFT_UINT8, BASE_DEC, VALS(cimd_dcs_message_class_meaning), 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_dcs_message_class_indicator,\r\n{ "DCS Message Class", "cimd.dcs.mc",\r\nFT_UINT8, BASE_DEC, VALS(cimd_dcs_message_class), 0x03,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_dcs_character_set_indicator0C,\r\n{ "DCS Character Set", "cimd.dcs.chs",\r\nFT_UINT8, BASE_DEC, VALS(cimd_dcs_character_set), 0x0C,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_dcs_character_set_indicator04,\r\n{ "DCS Character Set", "cimd.dcs.chs",\r\nFT_UINT8, BASE_DEC, VALS(cimd_dcs_character_set), 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_dcs_indication_sense,\r\n{ "DCS Indication Sense", "cimd.dcs.is",\r\nFT_UINT8, BASE_DEC, VALS(cimd_dcs_indication_sense), 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cimd_dcs_indication_type,\r\n{ "DCS Indication Type", "cimd.dcs.it",\r\nFT_UINT8, BASE_DEC, VALS(cimd_dcs_indication_type), 0x03,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[0],\r\n{ "User Identity", "cimd.ui",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[1],\r\n{ "Password", "cimd.passwd",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[2],\r\n{ "Subaddress", "cimd.saddr",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[3],\r\n{ "Window Size", "cimd.ws",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[4],\r\n{ "Destination Address", "cimd.da",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[5],\r\n{ "Originating Address", "cimd.oa",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[6],\r\n{ "Originating IMSI", "cimd.oimsi",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[7],\r\n{ "Alphanumeric Originating Address", "cimd.aoi",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[8],\r\n{ "Originated Visited MSC Address", "cimd.ovma",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[9],\r\n{ "Data Coding Scheme", "cimd.dcs",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[10],\r\n{ "User Data Header", "cimd.udh",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[11],\r\n{ "User Data", "cimd.ud",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[12],\r\n{ "User Data Binary", "cimd.udb",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[13],\r\n{ "More Messages To Send", "cimd.mms",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[14],\r\n{ "Validity Period Relative", "cimd.vpr",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[15],\r\n{ "Validity Period Absolute", "cimd.vpa",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[16],\r\n{ "Protocol Identifier", "cimd.pi",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[17],\r\n{ "First Delivery Time Relative", "cimd.fdtr",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[18],\r\n{ "First Delivery Time Absolute", "cimd.fdta",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[19],\r\n{ "Reply Path", "cimd.rpath",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[20],\r\n{ "Status Report Request", "cimd.srr",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[21],\r\n{ "Cancel Enabled", "cimd.ce",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[22],\r\n{ "Cancel Mode", "cimd.cm",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[23],\r\n{ "Service Center Time Stamp", "cimd.scts",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[24],\r\n{ "Status Code", "cimd.stcode",\r\nFT_UINT8, BASE_DEC, VALS(cimd_status_code_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[25],\r\n{ "Status Error Code", "cimd.sterrcode",\r\nFT_UINT16, BASE_DEC|BASE_EXT_STRING, &cimd_status_error_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[26],\r\n{ "Discharge Time", "cimd.dt",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[27],\r\n{ "Tariff Class", "cimd.tclass",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[28],\r\n{ "Service Description", "cimd.sdes",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[29],\r\n{ "Message Count", "cimd.mcount",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[30],\r\n{ "Priority", "cimd.priority",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[31],\r\n{ "Delivery Request Mode", "cimd.drmode",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[32],\r\n{ "Service Center Address", "cimd.scaddr",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[33],\r\n{ "Get Parameter", "cimd.gpar",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[34],\r\n{ "SMS Center Time", "cimd.smsct",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[35],\r\n{ "Error Code Description", "cimd.errcode",\r\nFT_UINT16, BASE_DEC|BASE_EXT_STRING, &cimd_error_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_index[36],\r\n{ "Error Text", "cimd.errtext",\r\nFT_STRING, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n}\r\n};\r\ngint *ett[MAXPARAMSCOUNT + 1];\r\nint i;\r\nett[0] = &ett_cimd;\r\nfor(i=0;i<MAXPARAMSCOUNT;i++)\r\n{\r\nett_index[i] = -1;\r\nett[i + 1] = &(ett_index[i]);\r\nvals_hdr_PC[i].ett_p = &(ett_index[i]);\r\nvals_hdr_PC[i].hf_p = &(hf_index[i]);\r\nvals_hdr_PC[i].diss = cimd_pc_handles[i];\r\n};\r\nproto_cimd = proto_register_protocol("Computer Interface to Message Distribution", "CIMD", "cimd");\r\nproto_register_field_array(proto_cimd, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_cimd(void)\r\n{\r\ndissector_handle_t cimd_handle;\r\nheur_dissector_add("tcp", dissect_cimd_heur, "CIMD over TCP", "cimd_tcp", proto_cimd, HEURISTIC_ENABLE);\r\ncimd_handle = create_dissector_handle(dissect_cimd, proto_cimd);\r\ndissector_add_for_decode_as("tcp.port", cimd_handle);\r\n}
