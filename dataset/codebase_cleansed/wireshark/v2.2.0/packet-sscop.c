static void dissect_stat_list(proto_tree *tree, tvbuff_t *tvb,guint h) {\r\ngint n,i;\r\nif ((n = (tvb_reported_length(tvb))/4 - h)) {\r\ntree = proto_tree_add_subtree(tree,tvb,0,n*4,ett_stat,NULL,"SD List");\r\nfor (i = 0; i < n; i++) {\r\nproto_tree_add_item(tree, hf_sscop_stat_s, tvb, i*4 + 1,3,ENC_BIG_ENDIAN);\r\n}\r\n}\r\n}\r\nextern void\r\ndissect_sscop_and_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, dissector_handle_t payload_handle)\r\n{\r\nguint reported_length;\r\nproto_item *ti;\r\nproto_tree *sscop_tree = NULL;\r\nguint8 sscop_pdu_type;\r\nint pdu_len;\r\nint pad_len;\r\ntvbuff_t *next_tvb;\r\nreported_length = tvb_reported_length(tvb);\r\nsscop_pdu_type = tvb_get_guint8(tvb, SSCOP_PDU_TYPE);\r\nsscop_info.type = sscop_pdu_type & SSCOP_TYPE_MASK;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "SSCOP");\r\ncol_add_str(pinfo->cinfo, COL_INFO, val_to_str_ext(sscop_info.type, &sscop_type_vals_ext,\r\n"Unknown PDU type (0x%02x)"));\r\nswitch (sscop_info.type) {\r\ncase SSCOP_SD:\r\npad_len = (sscop_pdu_type >> 6) & 0x03;\r\npdu_len = 4;\r\nbreak;\r\ncase SSCOP_BGN:\r\ncase SSCOP_BGAK:\r\ncase SSCOP_BGREJ:\r\ncase SSCOP_END:\r\ncase SSCOP_RS:\r\n#if 0\r\ncase SSCOP_SDP:\r\n#endif\r\npad_len = (sscop_pdu_type >> 6) & 0x03;\r\nsscop_info.payload_len = pdu_len = 8;\r\nbreak;\r\ncase SSCOP_UD:\r\npad_len = (sscop_pdu_type >> 6) & 0x03;\r\nsscop_info.payload_len = pdu_len = 4;\r\nbreak;\r\ndefault:\r\npad_len = 0;\r\npdu_len = reported_length;\r\nsscop_info.payload_len = 0;\r\nbreak;\r\n}\r\nif (tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_sscop, tvb,\r\nreported_length - pdu_len,\r\npdu_len, "SSCOP");\r\nsscop_tree = proto_item_add_subtree(ti, ett_sscop);\r\nproto_tree_add_item(sscop_tree, hf_sscop_type, tvb, SSCOP_PDU_TYPE, 1,ENC_BIG_ENDIAN);\r\nswitch (sscop_info.type) {\r\ncase SSCOP_BGN:\r\ncase SSCOP_RS:\r\ncase SSCOP_ER:\r\nproto_tree_add_item(sscop_tree, hf_sscop_sq, tvb, SSCOP_N_SQ, 1,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sscop_tree, hf_sscop_mr, tvb, SSCOP_N_MR + 1, 3, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SSCOP_END:\r\nproto_tree_add_string(sscop_tree, hf_sscop_source, tvb, SSCOP_PDU_TYPE, 1,\r\n(sscop_pdu_type & SSCOP_S) ? "SSCOP" : "User");\r\nbreak;\r\ncase SSCOP_BGAK:\r\ncase SSCOP_RSAK:\r\nproto_tree_add_item(sscop_tree, hf_sscop_mr, tvb, SSCOP_N_MR + 1, 3, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SSCOP_ERAK:\r\nproto_tree_add_item(sscop_tree, hf_sscop_mr, tvb, SSCOP_N_MR + 1, 3, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SSCOP_SD:\r\nproto_tree_add_item(sscop_tree, hf_sscop_s, tvb, SSCOP_N_S + 1, 3, ENC_BIG_ENDIAN);\r\nbreak;\r\n#if 0\r\ncase SSCOP_SDP:\r\n#endif\r\ncase SSCOP_POLL:\r\nproto_tree_add_item(sscop_tree, hf_sscop_ps, tvb, SSCOP_N_PS + 1, 3,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sscop_tree, hf_sscop_s, tvb, SSCOP_N_S + 1, 3,ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SSCOP_STAT:\r\nproto_tree_add_item(sscop_tree, hf_sscop_ps, tvb, SSCOP_SS_N_PS + 1, 3,ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sscop_tree, hf_sscop_mr, tvb, SSCOP_SS_N_MR + 1, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sscop_tree, hf_sscop_r, tvb, SSCOP_SS_N_R + 1, 3,ENC_BIG_ENDIAN);\r\ndissect_stat_list(sscop_tree,tvb,3);\r\nbreak;\r\ncase SSCOP_USTAT:\r\nproto_tree_add_item(sscop_tree, hf_sscop_mr, tvb, SSCOP_SS_N_MR + 1, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sscop_tree, hf_sscop_r, tvb, SSCOP_SS_N_R + 1, 3,ENC_BIG_ENDIAN);\r\ndissect_stat_list(sscop_tree,tvb,2);\r\nbreak;\r\n}\r\n}\r\nswitch (sscop_info.type) {\r\ncase SSCOP_SD:\r\ncase SSCOP_UD:\r\ncase SSCOP_BGN:\r\ncase SSCOP_BGAK:\r\ncase SSCOP_BGREJ:\r\ncase SSCOP_END:\r\ncase SSCOP_RS:\r\n#if 0\r\ncase SSCOP_SDP:\r\n#endif\r\nif (tree) {\r\nproto_tree_add_uint(sscop_tree, hf_sscop_pad_length, tvb, SSCOP_PDU_TYPE, 1, pad_len);\r\n}\r\nreported_length -= (pdu_len + pad_len);\r\nif (reported_length != 0) {\r\nnext_tvb = tvb_new_subset_length(tvb, 0, reported_length);\r\nif (sscop_info.type == SSCOP_SD)\r\n{\r\ncall_dissector(payload_handle, next_tvb, pinfo, tree);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int dissect_sscop(tvbuff_t* tvb, packet_info* pinfo,proto_tree* tree, void* data _U_)\r\n{\r\nstruct _sscop_payload_info *p_sscop_info;\r\ndissector_handle_t subdissector;\r\np_sscop_info = (struct _sscop_payload_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_sscop, 0);\r\nif ( p_sscop_info\r\n&& ( subdissector = p_sscop_info->subdissector )\r\n&& ( subdissector == data_handle\r\n|| subdissector == q2931_handle\r\n|| subdissector == sscf_nni_handle\r\n|| subdissector == alcap_handle\r\n|| subdissector == nbap_handle) )\r\ndissect_sscop_and_payload(tvb,pinfo,tree,subdissector);\r\nelse\r\ndissect_sscop_and_payload(tvb,pinfo,tree,default_handle);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void initialize_handles_once(void) {\r\nstatic gboolean initialized = FALSE;\r\nif (!initialized) {\r\nq2931_handle = find_dissector("q2931");\r\ndata_handle = find_dissector("data");\r\nsscf_nni_handle = find_dissector("sscf-nni");\r\nalcap_handle = find_dissector("alcap");\r\nnbap_handle = find_dissector("nbap");\r\ninitialized = TRUE;\r\n}\r\n}\r\ngboolean sscop_allowed_subdissector(dissector_handle_t handle)\r\n{\r\ninitialize_handles_once();\r\nif (handle == q2931_handle || handle == data_handle\r\n|| handle == sscf_nni_handle || handle == alcap_handle\r\n|| handle == nbap_handle)\r\nreturn TRUE;\r\nreturn FALSE;\r\n}\r\nvoid\r\nproto_reg_handoff_sscop(void)\r\n{\r\nstatic gboolean prefs_initialized = FALSE;\r\nstatic range_t *udp_port_range;\r\nif (!prefs_initialized) {\r\ninitialize_handles_once();\r\nprefs_initialized = TRUE;\r\n} else {\r\ndissector_delete_uint_range("udp.port", udp_port_range, sscop_handle);\r\ng_free(udp_port_range);\r\n}\r\nudp_port_range = range_copy(global_udp_port_range);\r\ndissector_add_uint_range("udp.port", udp_port_range, sscop_handle);\r\ndissector_add_uint("atm.aal5.type", TRAF_SSCOP, sscop_handle);\r\nswitch(sscop_payload_dissector) {\r\ncase DATA_DISSECTOR: default_handle = data_handle; break;\r\ncase Q2931_DISSECTOR: default_handle = q2931_handle; break;\r\ncase SSCF_NNI_DISSECTOR: default_handle = sscf_nni_handle; break;\r\ncase ALCAP_DISSECTOR: default_handle = alcap_handle; break;\r\ncase NBAP_DISSECTOR: default_handle = nbap_handle; break;\r\n}\r\n}\r\nvoid\r\nproto_register_sscop(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_sscop_type, { "PDU Type", "sscop.type", FT_UINT8, BASE_HEX|BASE_EXT_STRING, &sscop_type_vals_ext, SSCOP_TYPE_MASK, NULL, HFILL }},\r\n{ &hf_sscop_sq, { "N(SQ)", "sscop.sq", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sscop_mr, { "N(MR)", "sscop.mr", FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sscop_s, { "N(S)", "sscop.s", FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sscop_ps, { "N(PS)", "sscop.ps", FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sscop_r, { "N(R)", "sscop.r", FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sscop_stat_s, { "N(S)", "sscop.stat.s", FT_UINT24, BASE_DEC, NULL, 0x0,NULL, HFILL }},\r\n{ &hf_sscop_pad_length, { "Pad length", "sscop.pad_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sscop_source, { "Source", "sscop.source", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n#if 0\r\n{ &hf_sscop_stat_count, { "Number of NACKed pdus", "sscop.stat.count", FT_UINT32, BASE_DEC, NULL, 0x0,NULL, HFILL }}\r\n#endif\r\n};\r\nstatic gint *ett[] = {\r\n&ett_sscop,\r\n&ett_stat\r\n};\r\nproto_sscop = proto_register_protocol("SSCOP", "SSCOP", "sscop");\r\nproto_register_field_array(proto_sscop, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nsscop_handle = register_dissector("sscop", dissect_sscop, proto_sscop);\r\nsscop_module = prefs_register_protocol(proto_sscop, proto_reg_handoff_sscop);\r\nglobal_udp_port_range = range_empty();\r\nprefs_register_range_preference(sscop_module, "udp.ports",\r\n"SSCOP UDP port range",\r\n"Set the UDP port for SSCOP messages encapsulated in UDP (0 to disable)",\r\n&global_udp_port_range, MAX_UDP_PORT);\r\nprefs_register_enum_preference(sscop_module, "payload",\r\n"SSCOP payload protocol",\r\n"SSCOP payload (dissector to call on SSCOP payload)",\r\n(gint *)&sscop_payload_dissector,\r\nsscop_payload_dissector_options, FALSE);\r\n}
