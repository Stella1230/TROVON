static gint\r\ndissect_hci_usb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *ttree = NULL;\r\nproto_tree *titem = NULL;\r\nproto_item *pitem = NULL;\r\ngint offset = 0;\r\nusb_conv_info_t *usb_conv_info;\r\ntvbuff_t *next_tvb = NULL;\r\nbluetooth_data_t *bluetooth_data;\r\ngint p2p_dir_save;\r\nguint32 session_id;\r\nfragment_head *reassembled;\r\nbluetooth_data = (bluetooth_data_t *) data;\r\nif (data == NULL)\r\nreturn 0;\r\nDISSECTOR_ASSERT(bluetooth_data->previous_protocol_data_type == BT_PD_USB_CONV_INFO);\r\nusb_conv_info = bluetooth_data->previous_protocol_data.usb_conv_info;\r\ntitem = proto_tree_add_item(tree, proto_hci_usb, tvb, offset, -1, ENC_NA);\r\nttree = proto_item_add_subtree(titem, ett_hci_usb);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HCI_USB");\r\np2p_dir_save = pinfo->p2p_dir;\r\npinfo->p2p_dir = (usb_conv_info->is_request) ? P2P_DIR_SENT : P2P_DIR_RECV;\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection");\r\nbreak;\r\n}\r\nif (usb_conv_info->is_setup) {\r\nproto_tree_add_item(ttree, hf_bthci_usb_setup_request, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ttree, hf_bthci_usb_setup_value, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ttree, hf_bthci_usb_setup_adapter_id, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ttree, hf_bthci_usb_setup_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nsession_id = usb_conv_info->bus_id << 16 | usb_conv_info->device_address << 8 | ((pinfo->p2p_dir == P2P_DIR_RECV) ? 1 : 0 ) << 7 | usb_conv_info->endpoint;\r\nbluetooth_data->adapter_id = usb_conv_info->bus_id << 8 | usb_conv_info->device_address;\r\nbluetooth_data->adapter_disconnect_in_frame = &max_disconnect_in_frame;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nif (!pinfo->fd->flags.visited && usb_conv_info->endpoint <= 0x02 &&\r\ntvb_captured_length(tvb) == tvb_reported_length(tvb)) {\r\nfragment_info_t *fragment_info;\r\nfragment_info = (fragment_info_t *) wmem_tree_lookup32(fragment_info_table, session_id);\r\nif (fragment_info == NULL) {\r\nfragment_info = (fragment_info_t *) wmem_new(wmem_file_scope(), fragment_info_t);\r\nfragment_info->fragment_id = 0;\r\nfragment_info->remaining_length = 0;\r\nwmem_tree_insert32(fragment_info_table, session_id, fragment_info);\r\n}\r\nif (fragment_info->fragment_id == 0) {\r\nswitch(usb_conv_info->endpoint)\r\n{\r\ncase 0:\r\nfragment_info->remaining_length = tvb_get_guint8(tvb, offset + 2) + 3;\r\nbreak;\r\ncase 1:\r\nfragment_info->remaining_length = tvb_get_guint8(tvb, offset + 1) + 2;\r\nbreak;\r\ncase 2:\r\nfragment_info->remaining_length = tvb_get_letohs(tvb, offset + 2) + 4;\r\nbreak;\r\n}\r\n}\r\nfragment_info->remaining_length -= tvb_reported_length_remaining(tvb, offset);\r\nfragment_add_seq_check(&hci_usb_reassembly_table,\r\ntvb, offset, pinfo, session_id, NULL,\r\nfragment_info->fragment_id, tvb_reported_length_remaining(tvb, offset), (fragment_info->remaining_length == 0) ? FALSE : TRUE);\r\nif (fragment_info->remaining_length > 0)\r\nfragment_info->fragment_id += 1;\r\nelse\r\nfragment_info->fragment_id = 0;\r\n}\r\nreassembled = fragment_get_reassembled_id(&hci_usb_reassembly_table, pinfo, session_id);\r\nif (reassembled && pinfo->num < reassembled->reassembled_in) {\r\npitem = proto_tree_add_item(ttree, hf_bthci_usb_packet_fragment, tvb, offset, -1, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\ncol_append_str(pinfo->cinfo, COL_INFO, " Fragment");\r\n} else if (reassembled && pinfo->num == reassembled->reassembled_in) {\r\npitem = proto_tree_add_item(ttree, hf_bthci_usb_packet_complete, tvb, offset, -1, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nif (reassembled->len > (guint) tvb_reported_length_remaining(tvb, offset)) {\r\nnext_tvb = process_reassembled_data(tvb, 0, pinfo,\r\n"Reassembled HCI_USB",\r\nreassembled, &hci_usb_msg_frag_items,\r\nNULL, ttree);\r\n}\r\nswitch(usb_conv_info->endpoint)\r\n{\r\ncase 0:\r\ncall_dissector_with_data(bthci_cmd_handle, next_tvb, pinfo, tree, bluetooth_data);\r\nbreak;\r\ncase 1:\r\ncall_dissector_with_data(bthci_evt_handle, next_tvb, pinfo, tree, bluetooth_data);\r\nbreak;\r\ncase 2:\r\ncall_dissector_with_data(bthci_acl_handle, next_tvb, pinfo, tree, bluetooth_data);\r\nbreak;\r\n}\r\n} else {\r\npitem = proto_tree_add_item(ttree, hf_bthci_usb_packet_unknown_fragment, tvb, offset, -1, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\n}\r\nif (usb_conv_info->endpoint == 0x03) {\r\ncall_dissector_with_data(bthci_sco_handle, next_tvb, pinfo, tree, bluetooth_data);\r\n} else if (usb_conv_info->endpoint > 0x03) {\r\nproto_tree_add_item(ttree, hf_bthci_usb_data, tvb, offset, -1, ENC_NA);\r\n}\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\npinfo->p2p_dir = p2p_dir_save;\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_hci_usb(void)\r\n{\r\nmodule_t *module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_msg_fragments,\r\n{ "Message fragments", "hci_usb.msg.fragments",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_msg_fragment,\r\n{ "Message fragment", "hci_usb.msg.fragment",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_msg_fragment_overlap,\r\n{ "Message fragment overlap", "hci_usb.msg.fragment.overlap",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_msg_fragment_overlap_conflicts,\r\n{ "Message fragment overlapping with conflicting data", "hci_usb.msg.fragment.overlap.conflicts",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_msg_fragment_multiple_tails,\r\n{ "Message has multiple tail fragments", "hci_usb.msg.fragment.multiple_tails",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_msg_fragment_too_long_fragment,\r\n{ "Message fragment too long", "hci_usb.msg.fragment.too_long_fragment",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_msg_fragment_error,\r\n{ "Message defragmentation error", "hci_usb.msg.fragment.error",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_msg_fragment_count,\r\n{ "Message fragment count", "hci_usb.msg.fragment.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_msg_reassembled_in,\r\n{ "Reassembled in", "hci_usb.msg.reassembled.in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_msg_reassembled_length,\r\n{ "Reassembled MP2T length", "hci_usb.msg.reassembled.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_usb_packet_fragment,\r\n{ "Packet Fragment", "hci_usb.packet.fragment",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_usb_packet_complete,\r\n{ "Packet Complete", "hci_usb.packet.complete",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_usb_packet_unknown_fragment,\r\n{ "Unknown Packet Fragment", "hci_usb.packet.unknown_fragment",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bthci_usb_setup_request,\r\n{ "bRequest", "hci_usb.setup.bRequest",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING, &request_vals_ext, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_bthci_usb_setup_value,\r\n{ "wValue", "hci_usb.setup.wValue",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_bthci_usb_setup_adapter_id,\r\n{ "Adapter ID", "hci_usb.setup.adapter_id",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_bthci_usb_setup_length,\r\n{ "wLength", "hci_usb.setup.wLength",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_bthci_usb_data,\r\n{ "Unknown Data", "hci_usb.data",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_hci_usb,\r\n&ett_hci_usb_msg_fragment,\r\n&ett_hci_usb_msg_fragments,\r\n};\r\nreassembly_table_init(&hci_usb_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\nfragment_info_table = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\nproto_hci_usb = proto_register_protocol("Bluetooth HCI USB Transport", "HCI_USB", "hci_usb");\r\nproto_register_field_array(proto_hci_usb, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nhci_usb_handle = register_dissector("hci_usb", dissect_hci_usb, proto_hci_usb);\r\nmodule = prefs_register_protocol(proto_hci_usb, NULL);\r\nprefs_register_static_text_preference(module, "bthci_usb.version",\r\n"Bluetooth HCI USB Transport from Core 4.0",\r\n"Version of protocol supported by this dissector.");\r\n}\r\nvoid\r\nproto_reg_handoff_hci_usb(void)\r\n{\r\nbthci_cmd_handle = find_dissector_add_dependency("bthci_cmd", proto_hci_usb);\r\nbthci_evt_handle = find_dissector_add_dependency("bthci_evt", proto_hci_usb);\r\nbthci_acl_handle = find_dissector_add_dependency("bthci_acl", proto_hci_usb);\r\nbthci_sco_handle = find_dissector_add_dependency("bthci_sco", proto_hci_usb);\r\n}
