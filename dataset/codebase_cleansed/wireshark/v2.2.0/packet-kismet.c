static int\r\ndissect_kismet(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * data _U_)\r\n{\r\ngboolean is_request;\r\ngboolean is_continuation;\r\nproto_tree *kismet_tree=NULL, *reqresp_tree=NULL;\r\nproto_item *ti;\r\nproto_item *tmp_item;\r\ngint offset = 0;\r\nconst guchar *line;\r\ngint next_offset;\r\nint linelen;\r\nint tokenlen;\r\nint i;\r\nconst guchar *next_token;\r\nlinelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nline = tvb_get_ptr(tvb, offset, linelen);\r\nif (linelen < 8) {\r\nreturn 0;\r\n} else {\r\nfor (i = 0; i < 8; ++i) {\r\nif (line[i] < 32 || line[i] > 128)\r\nreturn 0;\r\n}\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "kismet");\r\nif (pinfo->match_uint == pinfo->destport) {\r\nis_request = TRUE;\r\nis_continuation = FALSE;\r\n} else {\r\nis_request = FALSE;\r\nis_continuation = response_is_continuation (line);\r\n}\r\nif (is_continuation)\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Continuation");\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s: %s",\r\nis_request ? "Request" : "Response",\r\nformat_text(line, linelen));\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_kismet, tvb, offset, -1, ENC_NA);\r\nkismet_tree = proto_item_add_subtree(ti, ett_kismet);\r\n}\r\nif (is_continuation) {\r\ncall_data_dissector(tvb, pinfo, kismet_tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nif (is_request) {\r\ntmp_item = proto_tree_add_boolean(kismet_tree,\r\nhf_kismet_request, tvb, 0, 0, TRUE);\r\n} else {\r\ntmp_item = proto_tree_add_boolean(kismet_tree,\r\nhf_kismet_response, tvb, 0, 0, TRUE);\r\n}\r\nPROTO_ITEM_SET_GENERATED (tmp_item);\r\nwhile (tvb_offset_exists(tvb, offset)) {\r\nlinelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nif (linelen) {\r\nreqresp_tree = proto_tree_add_subtree(kismet_tree, tvb, offset,\r\nnext_offset - offset, ett_kismet_reqresp, NULL,\r\ntvb_format_text(tvb, offset,\r\nnext_offset - offset - 1));\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nif (tokenlen != 0) {\r\nguint8 *reqresp;\r\nreqresp = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_ASCII);\r\nif (is_request) {\r\n} else {\r\nif (!strncmp(reqresp, "*KISMET", 7)) {\r\noffset += (gint) (next_token - line);\r\nlinelen -= (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nproto_tree_add_string(reqresp_tree, hf_kismet_version, tvb, offset,\r\ntokenlen, format_text(line, tokenlen));\r\noffset += (gint) (next_token - line);\r\nlinelen -= (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nproto_tree_add_string(reqresp_tree, hf_kismet_start_time, tvb, offset,\r\ntokenlen, format_text(line, tokenlen));\r\noffset += (gint) (next_token - line);\r\nlinelen -= (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nproto_tree_add_string(reqresp_tree, hf_kismet_server_name, tvb, offset,\r\ntokenlen, format_text(line + 1, tokenlen - 2));\r\noffset += (gint) (next_token - line);\r\nlinelen -= (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nproto_tree_add_string(reqresp_tree, hf_kismet_build_revision, tvb, offset,\r\ntokenlen, format_text(line, tokenlen));\r\noffset += (gint) (next_token - line);\r\nlinelen -= (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nproto_tree_add_string(reqresp_tree, hf_kismet_unknown_field, tvb, offset,\r\ntokenlen, format_text(line, tokenlen));\r\noffset += (gint) (next_token - line);\r\nlinelen -= (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nproto_tree_add_string(reqresp_tree, hf_kismet_extended_version_string, tvb, offset,\r\ntokenlen, format_text(line, tokenlen));\r\n}\r\nif (!strncmp(reqresp, "*TIME", 5)) {\r\nnstime_t t;\r\nchar *ptr;\r\noffset += (gint) (next_token - line);\r\nlinelen -= (int) (next_token - line);\r\nline = next_token;\r\ntokenlen = get_token_len(line, line + linelen, &next_token);\r\nt.secs = atoi(format_text (line, tokenlen));\r\nt.nsecs = 0;\r\nptr = abs_time_secs_to_str(wmem_packet_scope(), t.secs, ABSOLUTE_TIME_LOCAL, TRUE);\r\nproto_tree_add_time_format_value(reqresp_tree, hf_kismet_time, tvb, offset, tokenlen, &t, "%s", ptr);\r\n}\r\n}\r\nline = next_token;\r\n}\r\n}\r\noffset = next_offset;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\nresponse_is_continuation(const guchar * data)\r\n{\r\nif (!strncmp(data, "*", 1))\r\nreturn FALSE;\r\nif (!strncmp(data, "!", 1))\r\nreturn FALSE;\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_kismet(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{&hf_kismet_response,\r\n{"Response", "kismet.response", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "TRUE if kismet response", HFILL}},\r\n{&hf_kismet_request,\r\n{"Request", "kismet.request", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "TRUE if kismet request", HFILL}},\r\n{&hf_kismet_version,\r\n{"Version", "kismet.version", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{&hf_kismet_start_time,\r\n{"Start time", "kismet.start_time", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{&hf_kismet_server_name,\r\n{"Server name", "kismet.server_name", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{&hf_kismet_build_revision,\r\n{"Build revision", "kismet.build_revision", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{&hf_kismet_unknown_field,\r\n{"Unknown field", "kismet.unknown_field", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{&hf_kismet_extended_version_string,\r\n{"Extended version string", "kismet.extended_version_string", FT_STRING, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{&hf_kismet_time,\r\n{"Time", "kismet.time", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0x0, NULL, HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_kismet,\r\n&ett_kismet_reqresp,\r\n};\r\nmodule_t *kismet_module;\r\nproto_kismet = proto_register_protocol("Kismet Client/Server Protocol", "Kismet", "kismet");\r\nproto_register_field_array(proto_kismet, hf, array_length (hf));\r\nproto_register_subtree_array(ett, array_length (ett));\r\nkismet_module = prefs_register_protocol(proto_kismet, proto_reg_handoff_kismet);\r\nprefs_register_uint_preference(kismet_module, "tcp.port",\r\n"Kismet Server TCP Port",\r\n"Set the port for Kismet Client/Server messages (if other"\r\n" than the default of 2501)", 10,\r\n&global_kismet_tcp_port);\r\n}\r\nvoid\r\nproto_reg_handoff_kismet(void)\r\n{\r\nstatic gboolean kismet_prefs_initialized = FALSE;\r\nstatic dissector_handle_t kismet_handle;\r\nstatic guint tcp_port;\r\nif (!kismet_prefs_initialized) {\r\nkismet_handle = create_dissector_handle(dissect_kismet, proto_kismet);\r\nkismet_prefs_initialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", tcp_port, kismet_handle);\r\n}\r\ntcp_port = global_kismet_tcp_port;\r\ndissector_add_uint("tcp.port", global_kismet_tcp_port, kismet_handle);\r\n}
