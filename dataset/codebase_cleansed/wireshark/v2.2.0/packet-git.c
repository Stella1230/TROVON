static gboolean get_packet_length(tvbuff_t *tvb, int offset,\r\nguint16 *length)\r\n{\r\nguint8 *lenstr;\r\nlenstr = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, 4, ENC_ASCII);\r\nreturn (sscanf(lenstr, "%hx", length) == 1);\r\n}\r\nstatic guint\r\nget_git_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint16 plen;\r\nif (!get_packet_length(tvb, offset, &plen))\r\nreturn 0;\r\nif (plen == 0) {\r\nreturn 4;\r\n}\r\nreturn plen;\r\n}\r\nstatic int\r\ndissect_git_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *git_tree;\r\nproto_item *ti;\r\nint offset = 0;\r\nguint16 plen;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PSNAME);\r\ncol_set_str(pinfo->cinfo, COL_INFO, PNAME);\r\nti = proto_tree_add_item(tree, proto_git, tvb, offset, -1, ENC_NA);\r\ngit_tree = proto_item_add_subtree(ti, ett_git);\r\nif (!get_packet_length(tvb, 0, &plen))\r\nreturn 0;\r\nif (plen == 0) {\r\nproto_tree_add_uint(git_tree, hf_git_packet_terminator, tvb, offset,\r\n4, plen);\r\nreturn 4;\r\n}\r\nif (git_tree)\r\n{\r\nproto_tree_add_uint(git_tree, hf_git_packet_len, tvb, offset,\r\n4, plen);\r\nproto_tree_add_item(git_tree, hf_git_packet_data, tvb, offset+4,\r\nplen-4, ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_git(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, git_desegment, 4, get_git_pdu_len,\r\ndissect_git_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_git(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_git_packet_len,\r\n{ "Packet length", "git.length", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL },\r\n},\r\n{ &hf_git_packet_data,\r\n{ "Packet data", "git.data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL },\r\n},\r\n{ &hf_git_packet_terminator,\r\n{ "Terminator packet", "git.terminator", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL },\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_git,\r\n};\r\nmodule_t *git_module;\r\nproto_git = proto_register_protocol(PNAME, PSNAME, PFNAME);\r\nproto_register_field_array(proto_git, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ngit_handle = register_dissector(PFNAME, dissect_git, proto_git);\r\ngit_module = prefs_register_protocol(proto_git, NULL);\r\nprefs_register_bool_preference(git_module, "desegment",\r\n"Reassemble GIT messages spanning multiple TCP segments",\r\n"Whether the GIT dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&git_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_git(void)\r\n{\r\ndissector_add_uint("tcp.port", TCP_PORT_GIT, git_handle);\r\n}
