static void t38_defragment_init(void)\r\n{\r\nreassembly_table_init(&data_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void t38_defragment_cleanup(void)\r\n{\r\nreassembly_table_destroy(&data_reassembly_table);\r\n}\r\nvoid t38_add_address(packet_info *pinfo,\r\naddress *addr, int port,\r\nint other_port,\r\nconst gchar *setup_method, guint32 setup_frame_number)\r\n{\r\naddress null_addr;\r\nconversation_t* p_conversation;\r\nt38_conv* p_conversation_data = NULL;\r\nif ((pinfo->fd->flags.visited) || (t38_udp_handle == NULL))\r\n{\r\nreturn;\r\n}\r\nclear_address(&null_addr);\r\np_conversation = find_conversation( setup_frame_number, addr, &null_addr, PT_UDP, port, other_port,\r\nNO_ADDR_B | (!other_port ? NO_PORT_B : 0));\r\nif ( !p_conversation || p_conversation->setup_frame != setup_frame_number) {\r\np_conversation = conversation_new( setup_frame_number, addr, &null_addr, PT_UDP,\r\n(guint32)port, (guint32)other_port,\r\nNO_ADDR2 | (!other_port ? NO_PORT2 : 0));\r\n}\r\nconversation_set_dissector(p_conversation, t38_udp_handle);\r\np_conversation_data = (t38_conv*)conversation_get_proto_data(p_conversation, proto_t38);\r\nif ( ! p_conversation_data ) {\r\np_conversation_data = wmem_new(wmem_file_scope(), t38_conv);\r\nconversation_add_proto_data(p_conversation, proto_t38, p_conversation_data);\r\n}\r\ng_strlcpy(p_conversation_data->setup_method, setup_method, MAX_T38_SETUP_METHOD_SIZE);\r\np_conversation_data->setup_frame_number = setup_frame_number;\r\np_conversation_data->src_t38_info.reass_ID = 0;\r\np_conversation_data->src_t38_info.reass_start_seqnum = -1;\r\np_conversation_data->src_t38_info.reass_data_type = 0;\r\np_conversation_data->src_t38_info.last_seqnum = -1;\r\np_conversation_data->src_t38_info.packet_lost = 0;\r\np_conversation_data->src_t38_info.burst_lost = 0;\r\np_conversation_data->src_t38_info.time_first_t4_data = 0;\r\np_conversation_data->src_t38_info.additional_hdlc_data_field_counter = 0;\r\np_conversation_data->src_t38_info.seqnum_prev_data_field = -1;\r\np_conversation_data->dst_t38_info.reass_ID = 0;\r\np_conversation_data->dst_t38_info.reass_start_seqnum = -1;\r\np_conversation_data->dst_t38_info.reass_data_type = 0;\r\np_conversation_data->dst_t38_info.last_seqnum = -1;\r\np_conversation_data->dst_t38_info.packet_lost = 0;\r\np_conversation_data->dst_t38_info.burst_lost = 0;\r\np_conversation_data->dst_t38_info.time_first_t4_data = 0;\r\np_conversation_data->dst_t38_info.additional_hdlc_data_field_counter = 0;\r\np_conversation_data->dst_t38_info.seqnum_prev_data_field = -1;\r\n}\r\nstatic fragment_head *\r\nforce_reassemble_seq(reassembly_table *table, packet_info *pinfo, guint32 id)\r\n{\r\nfragment_head *fd_head;\r\nfragment_item *fd_i;\r\nfragment_item *last_fd;\r\nguint32 dfpos, size, packet_lost, burst_lost, seq_num;\r\nguint8 *data;\r\nfd_head = fragment_get(table, pinfo, id, NULL);\r\nif (pinfo->fd->flags.visited) {\r\nif (fd_head != NULL && fd_head->flags & FD_DEFRAGMENTED) {\r\nreturn fd_head;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nif (fd_head==NULL){\r\nreturn NULL;\r\n}\r\npacket_lost = 0;\r\nburst_lost = 0;\r\nseq_num = 0;\r\nfor(fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\r\nif (seq_num != fd_i->offset) {\r\npacket_lost += fd_i->offset - seq_num;\r\nif ( (fd_i->offset - seq_num) > burst_lost ) {\r\nburst_lost = fd_i->offset - seq_num;\r\n}\r\n}\r\nseq_num = fd_i->offset + 1;\r\n}\r\nsize=0;\r\nlast_fd=NULL;\r\nfor(fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\r\nif(!last_fd || last_fd->offset!=fd_i->offset){\r\nsize+=fd_i->len;\r\n}\r\nlast_fd=fd_i;\r\n}\r\ndata = (guint8 *) g_malloc(size);\r\nfd_head->tvb_data = tvb_new_real_data(data, size, size);\r\nfd_head->len = size;\r\ndfpos = 0;\r\nlast_fd=NULL;\r\nfor (fd_i=fd_head->next;fd_i && fd_i->len + dfpos <= size;fd_i=fd_i->next) {\r\nif (fd_i->len) {\r\nif(!last_fd || last_fd->offset!=fd_i->offset){\r\ntvb_memcpy(fd_i->tvb_data, data+dfpos, 0, fd_i->len);\r\ndfpos += fd_i->len;\r\n} else {\r\nfd_i->flags |= FD_OVERLAP;\r\nfd_head->flags |= FD_OVERLAP;\r\nif( (last_fd->len!=fd_i->len)\r\n|| tvb_memeql(last_fd->tvb_data, 0, tvb_get_ptr(fd_i->tvb_data, 0, last_fd->len), last_fd->len) ){\r\nfd_i->flags |= FD_OVERLAPCONFLICT;\r\nfd_head->flags |= FD_OVERLAPCONFLICT;\r\n}\r\n}\r\n}\r\nlast_fd=fd_i;\r\n}\r\nfor (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\r\nif(fd_i->tvb_data){\r\ntvb_free(fd_i->tvb_data);\r\nfd_i->tvb_data=NULL;\r\n}\r\n}\r\nfd_head->flags |= FD_DEFRAGMENTED;\r\nfd_head->reassembled_in=pinfo->num;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (t4-data Reassembled: %d pack lost, %d pack burst lost)", packet_lost, burst_lost);\r\np_t38_packet_conv_info->packet_lost = packet_lost;\r\np_t38_packet_conv_info->burst_lost = burst_lost;\r\nreturn fd_head;\r\n}\r\nstatic void\r\ninit_t38_info_conv(packet_info *pinfo)\r\n{\r\nt38_info_current++;\r\nif (t38_info_current==MAX_T38_MESSAGES_IN_PACKET) {\r\nt38_info_current=0;\r\n}\r\nt38_info = &t38_info_arr[t38_info_current];\r\nt38_info->seq_num = 0;\r\nt38_info->type_msg = 0;\r\nt38_info->data_value = 0;\r\nt38_info->t30ind_value =0;\r\nt38_info->setup_frame_number = 0;\r\nt38_info->Data_Field_field_type_value = 0;\r\nt38_info->desc[0] = '\0';\r\nt38_info->desc_comment[0] = '\0';\r\nt38_info->time_first_t4_data = 0;\r\nt38_info->frame_num_first_t4_data = 0;\r\np_t38_packet_conv = NULL;\r\np_t38_conv = NULL;\r\np_t38_packet_conv = (t38_conv *)p_get_proto_data(wmem_file_scope(), pinfo, proto_t38, 0);\r\np_conv = find_conversation(pinfo->num, &pinfo->net_dst, &pinfo->net_src,\r\npinfo->ptype,\r\npinfo->destport, pinfo->srcport, NO_ADDR_B | NO_PORT_B);\r\nif (!p_conv) {\r\np_conv = conversation_new(pinfo->num, &pinfo->net_src, &pinfo->net_dst,\r\npinfo->ptype, pinfo->srcport, pinfo->destport, NO_ADDR_B | NO_PORT_B);\r\nconversation_set_dissector(p_conv, t38_udp_handle);\r\n}\r\np_t38_conv = (t38_conv *)conversation_get_proto_data(p_conv, proto_t38);\r\nif (!p_t38_conv) {\r\np_t38_conv = wmem_new(wmem_file_scope(), t38_conv);\r\np_t38_conv->setup_method[0] = '\0';\r\np_t38_conv->setup_frame_number = 0;\r\np_t38_conv->src_t38_info.reass_ID = 0;\r\np_t38_conv->src_t38_info.reass_start_seqnum = -1;\r\np_t38_conv->src_t38_info.reass_data_type = 0;\r\np_t38_conv->src_t38_info.last_seqnum = -1;\r\np_t38_conv->src_t38_info.packet_lost = 0;\r\np_t38_conv->src_t38_info.burst_lost = 0;\r\np_t38_conv->src_t38_info.time_first_t4_data = 0;\r\np_t38_conv->src_t38_info.additional_hdlc_data_field_counter = 0;\r\np_t38_conv->src_t38_info.seqnum_prev_data_field = -1;\r\np_t38_conv->dst_t38_info.reass_ID = 0;\r\np_t38_conv->dst_t38_info.reass_start_seqnum = -1;\r\np_t38_conv->dst_t38_info.reass_data_type = 0;\r\np_t38_conv->dst_t38_info.last_seqnum = -1;\r\np_t38_conv->dst_t38_info.packet_lost = 0;\r\np_t38_conv->dst_t38_info.burst_lost = 0;\r\np_t38_conv->dst_t38_info.time_first_t4_data = 0;\r\np_t38_conv->dst_t38_info.additional_hdlc_data_field_counter = 0;\r\np_t38_conv->dst_t38_info.seqnum_prev_data_field = -1;\r\nconversation_add_proto_data(p_conv, proto_t38, p_t38_conv);\r\n}\r\nif (!p_t38_packet_conv) {\r\np_t38_packet_conv = wmem_new(wmem_file_scope(), t38_conv);\r\ng_strlcpy(p_t38_packet_conv->setup_method, p_t38_conv->setup_method, MAX_T38_SETUP_METHOD_SIZE);\r\np_t38_packet_conv->setup_frame_number = p_t38_conv->setup_frame_number;\r\nmemcpy(&(p_t38_packet_conv->src_t38_info), &(p_t38_conv->src_t38_info), sizeof(t38_conv_info));\r\nmemcpy(&(p_t38_packet_conv->dst_t38_info), &(p_t38_conv->dst_t38_info), sizeof(t38_conv_info));\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_t38, 0, p_t38_packet_conv);\r\n}\r\nif (addresses_equal(&p_conv->key_ptr->addr1, &pinfo->net_src)) {\r\np_t38_conv_info = &(p_t38_conv->src_t38_info);\r\np_t38_packet_conv_info = &(p_t38_packet_conv->src_t38_info);\r\n} else {\r\np_t38_conv_info = &(p_t38_conv->dst_t38_info);\r\np_t38_packet_conv_info = &(p_t38_packet_conv->dst_t38_info);\r\n}\r\nt38_info->setup_frame_number = p_t38_packet_conv->setup_frame_number;\r\n}\r\nstatic int\r\ndissect_t38_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint8 octet1;\r\nproto_item *it;\r\nproto_tree *tr;\r\nguint32 offset=0;\r\nif (dissect_possible_rtpv2_packets_as_rtp){\r\noctet1 = tvb_get_guint8(tvb, offset);\r\nif (RTP_VERSION(octet1) == 2){\r\nreturn call_dissector(rtp_handle,tvb,pinfo,tree);\r\n}\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "T.38");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nprimary_part = TRUE;\r\nData_Field_item_num = 0;\r\nit=proto_tree_add_protocol_format(tree, proto_t38, tvb, 0, -1, "ITU-T Recommendation T.38");\r\ntr=proto_item_add_subtree(it, ett_t38);\r\ninit_t38_info_conv(pinfo);\r\nif (global_t38_show_setup_info) {\r\nshow_setup_info(tvb, tr, p_t38_packet_conv);\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO, "UDP: UDPTLPacket ");\r\noffset = dissect_UDPTLPacket_PDU(tvb, pinfo, tr, NULL);\r\nif (tvb_reported_length_remaining(tvb,offset)>0){\r\nproto_tree_add_expert_format(tr, pinfo, &ei_t38_malformed, tvb, offset, tvb_reported_length_remaining(tvb, offset),\r\n"[MALFORMED PACKET or wrong preference settings]");\r\ncol_append_str(pinfo->cinfo, COL_INFO, " [Malformed?]");\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_t38_tcp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *it;\r\nproto_tree *tr;\r\nguint32 offset=0;\r\ntvbuff_t *next_tvb;\r\nguint16 ifp_packet_number=1;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "T.38");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nprimary_part = TRUE;\r\nData_Field_item_num = 0;\r\nit=proto_tree_add_protocol_format(tree, proto_t38, tvb, 0, -1, "ITU-T Recommendation T.38");\r\ntr=proto_item_add_subtree(it, ett_t38);\r\ninit_t38_info_conv(pinfo);\r\nif (global_t38_show_setup_info) {\r\nshow_setup_info(tvb, tr, p_t38_packet_conv);\r\n}\r\ncol_append_str(pinfo->cinfo, COL_INFO, "TCP: IFPPacket");\r\nwhile(tvb_reported_length_remaining(tvb,offset)>0)\r\n{\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\noffset += dissect_IFPPacket_PDU(next_tvb, pinfo, tr, NULL);\r\nifp_packet_number++;\r\nif(tvb_reported_length_remaining(tvb,offset)>0){\r\nif(t38_tpkt_usage == T38_TPKT_ALWAYS){\r\nproto_tree_add_expert_format(tr, pinfo, &ei_t38_malformed, tvb, offset, tvb_reported_length_remaining(tvb, offset),\r\n"[MALFORMED PACKET or wrong preference settings]");\r\ncol_append_str(pinfo->cinfo, COL_INFO, " [Malformed?]");\r\nbreak;\r\n}else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " IFPPacket#%u",ifp_packet_number);\r\n}\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_t38_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nprimary_part = TRUE;\r\nif(t38_tpkt_usage == T38_TPKT_ALWAYS){\r\ndissect_tpkt_encap(tvb,pinfo,tree,t38_tpkt_reassembly,t38_tcp_pdu_handle);\r\n}\r\nelse if((t38_tpkt_usage == T38_TPKT_NEVER) || (is_tpkt(tvb,1) == -1)){\r\ndissect_t38_tcp_pdu(tvb, pinfo, tree, data);\r\n}\r\nelse {\r\ndissect_tpkt_encap(tvb,pinfo,tree,t38_tpkt_reassembly,t38_tcp_pdu_handle);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nshow_setup_info(tvbuff_t *tvb, proto_tree *tree, t38_conv *p_t38_conversation)\r\n{\r\nproto_tree *t38_setup_tree;\r\nproto_item *ti;\r\nif (!p_t38_conversation || p_t38_conversation->setup_frame_number == 0) {\r\nreturn;\r\n}\r\nti = proto_tree_add_string_format(tree, hf_t38_setup, tvb, 0, 0,\r\n"",\r\n"Stream setup by %s (frame %u)",\r\np_t38_conversation->setup_method,\r\np_t38_conversation->setup_frame_number);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nt38_setup_tree = proto_item_add_subtree(ti, ett_t38_setup);\r\nif (t38_setup_tree)\r\n{\r\nproto_item* item = proto_tree_add_uint(t38_setup_tree, hf_t38_setup_frame,\r\ntvb, 0, 0, p_t38_conversation->setup_frame_number);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nitem = proto_tree_add_string(t38_setup_tree, hf_t38_setup_method,\r\ntvb, 0, 0, p_t38_conversation->setup_method);\r\nPROTO_ITEM_SET_GENERATED(item);\r\n}\r\n}\r\nvoid\r\nproto_register_t38(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n#include "packet-t38-hfarr.c"\r\n{ &hf_t38_setup,\r\n{ "Stream setup", "t38.setup", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "Stream setup, method and frame number", HFILL }},\r\n{ &hf_t38_setup_frame,\r\n{ "Stream frame", "t38.setup-frame", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "Frame that set up this stream", HFILL }},\r\n{ &hf_t38_setup_method,\r\n{ "Stream Method", "t38.setup-method", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "Method used to set up this stream", HFILL }},\r\n{&hf_t38_fragments,\r\n{"Message fragments", "t38.fragments",\r\nFT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_t38_fragment,\r\n{"Message fragment", "t38.fragment",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_t38_fragment_overlap,\r\n{"Message fragment overlap", "t38.fragment.overlap",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{&hf_t38_fragment_overlap_conflicts,\r\n{"Message fragment overlapping with conflicting data",\r\n"t38.fragment.overlap.conflicts",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{&hf_t38_fragment_multiple_tails,\r\n{"Message has multiple tail fragments",\r\n"t38.fragment.multiple_tails",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{&hf_t38_fragment_too_long_fragment,\r\n{"Message fragment too long", "t38.fragment.too_long_fragment",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{&hf_t38_fragment_error,\r\n{"Message defragmentation error", "t38.fragment.error",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_t38_fragment_count,\r\n{"Message fragment count", "t38.fragment.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } },\r\n{&hf_t38_reassembled_in,\r\n{"Reassembled in", "t38.reassembled.in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{&hf_t38_reassembled_length,\r\n{"Reassembled T38 length", "t38.reassembled.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } },\r\n};\r\nstatic gint *ett[] =\r\n{\r\n&ett_t38,\r\n#include "packet-t38-ettarr.c"\r\n&ett_t38_setup,\r\n&ett_data_fragment,\r\n&ett_data_fragments\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_t38_malformed, { "t38.malformed", PI_MALFORMED, PI_ERROR, "Malformed packet", EXPFILL }},\r\n};\r\nmodule_t *t38_module;\r\nexpert_module_t* expert_t38;\r\nproto_t38 = proto_register_protocol("T.38", "T.38", "t38");\r\nproto_register_field_array(proto_t38, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_t38 = expert_register_protocol(proto_t38);\r\nexpert_register_field_array(expert_t38, ei, array_length(ei));\r\nregister_dissector("t38_udp", dissect_t38_udp, proto_t38);\r\nregister_init_routine(t38_defragment_init);\r\nregister_cleanup_routine(t38_defragment_cleanup);\r\nt38_tap = register_tap("t38");\r\nt38_module = prefs_register_protocol(proto_t38, proto_reg_handoff_t38);\r\nprefs_register_bool_preference(t38_module, "use_pre_corrigendum_asn1_specification",\r\n"Use the Pre-Corrigendum ASN.1 specification",\r\n"Whether the T.38 dissector should decode using the Pre-Corrigendum T.38 "\r\n"ASN.1 specification (1998).",\r\n&use_pre_corrigendum_asn1_specification);\r\nprefs_register_bool_preference(t38_module, "dissect_possible_rtpv2_packets_as_rtp",\r\n"Dissect possible RTP version 2 packets with RTP dissector",\r\n"Whether a UDP packet that looks like RTP version 2 packet will "\r\n"be dissected as RTP packet or T.38 packet. If enabled there is a risk that T.38 UDPTL "\r\n"packets with sequence number higher than 32767 may be dissected as RTP.",\r\n&dissect_possible_rtpv2_packets_as_rtp);\r\nprefs_register_obsolete_preference(t38_module, "tcp.port");\r\nprefs_register_obsolete_preference(t38_module, "udp.port");\r\nprefs_register_bool_preference(t38_module, "reassembly",\r\n"Reassemble T.38 PDUs over TPKT over TCP",\r\n"Whether the dissector should reassemble T.38 PDUs spanning multiple TCP segments "\r\n"when TPKT is used over TCP. "\r\n"To use this option, you must also enable \"Allow subdissectors to reassemble "\r\n"TCP streams\" in the TCP protocol settings.",\r\n&t38_tpkt_reassembly);\r\nprefs_register_enum_preference(t38_module, "tpkt_usage",\r\n"TPKT used over TCP",\r\n"Whether T.38 is used with TPKT for TCP",\r\n(gint *)&t38_tpkt_usage,t38_tpkt_options,FALSE);\r\nprefs_register_bool_preference(t38_module, "show_setup_info",\r\n"Show stream setup information",\r\n"Where available, show which protocol and frame caused "\r\n"this T.38 stream to be created",\r\n&global_t38_show_setup_info);\r\n}\r\nvoid\r\nproto_reg_handoff_t38(void)\r\n{\r\nstatic gboolean t38_prefs_initialized = FALSE;\r\nif (!t38_prefs_initialized) {\r\nt38_udp_handle=create_dissector_handle(dissect_t38_udp, proto_t38);\r\nt38_tcp_handle=create_dissector_handle(dissect_t38_tcp, proto_t38);\r\nt38_tcp_pdu_handle=create_dissector_handle(dissect_t38_tcp_pdu, proto_t38);\r\nrtp_handle = find_dissector_add_dependency("rtp", proto_t38);\r\nt30_hdlc_handle = find_dissector_add_dependency("t30.hdlc""rtp", proto_t38);\r\ndata_handle = find_dissector("data"
