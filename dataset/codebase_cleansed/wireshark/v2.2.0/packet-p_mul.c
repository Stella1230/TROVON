static const gchar *get_type (guint8 value)\r\n{\r\nreturn val_to_str_const (value, pdu_vals, "Unknown");\r\n}\r\nstatic guint16 checksum_acp142 (guint8 *buffer, gint len, gint offset)\r\n{\r\nguint16 c0 = 0, c1 = 0, ret, ctmp;\r\ngint16 cs;\r\nguint8 *hpp, *pls;\r\nif (len < offset+2) {\r\nreturn 0;\r\n}\r\nctmp = len - offset - 1;\r\npls = buffer + len;\r\nhpp = buffer;\r\nwhile (hpp < pls) {\r\nif ((c0 += *hpp++) > 254) { c0 -= 255; }\r\nif ((c1 += c0) > 254) { c1 -= 255; }\r\n}\r\nif ((cs = ((ctmp * c0) - c1) % 255) < 0) { cs += 255; }\r\nret = cs << 8;\r\nif ((cs = (c1 - ((ctmp + 1L) * c0)) % 255) < 0) { cs += 255; }\r\nret |= cs;\r\nreturn ret;\r\n}\r\nstatic guint p_mul_id_hash (gconstpointer k)\r\n{\r\nconst p_mul_id_key *p_mul = (const p_mul_id_key *)k;\r\nreturn p_mul->id;\r\n}\r\nstatic gint p_mul_id_hash_equal (gconstpointer k1, gconstpointer k2)\r\n{\r\nconst p_mul_id_key *p_mul1 = (const p_mul_id_key *)k1;\r\nconst p_mul_id_key *p_mul2 = (const p_mul_id_key *)k2;\r\nif (p_mul1->id != p_mul2->id)\r\nreturn 0;\r\nif (p_mul1->seq != p_mul2->seq)\r\nreturn 0;\r\nreturn (addresses_equal (&p_mul1->addr, &p_mul2->addr));\r\n}\r\nstatic p_mul_seq_val *lookup_seq_val (guint32 message_id, guint16 seq_no,\r\naddress *addr)\r\n{\r\np_mul_seq_val *pkg_data;\r\np_mul_id_key *p_mul_key = wmem_new(wmem_file_scope(), p_mul_id_key);\r\np_mul_key->id = message_id;\r\np_mul_key->seq = seq_no;\r\ncopy_address_wmem(wmem_file_scope(), &p_mul_key->addr, addr);\r\npkg_data = (p_mul_seq_val *) g_hash_table_lookup (p_mul_id_hash_table, p_mul_key);\r\nreturn pkg_data;\r\n}\r\nstatic void p_mul_id_value_destroy (p_mul_seq_val *pkg_data)\r\n{\r\nif (pkg_data->ack_data) {\r\ng_hash_table_destroy (pkg_data->ack_data);\r\n}\r\ng_free (pkg_data);\r\n}\r\nstatic void p_mul_package_data_destroy (GHashTable *pkg_list, gpointer user_data _U_)\r\n{\r\ng_hash_table_destroy (pkg_list);\r\n}\r\nstatic void copy_hashtable_data (gpointer key, p_mul_ack_data *ack_data1, GHashTable *table)\r\n{\r\np_mul_ack_data *ack_data2;\r\nack_data2 = wmem_new(wmem_file_scope(), p_mul_ack_data);\r\nack_data2->ack_id = ack_data1->ack_id;\r\nack_data2->ack_resend_count = ack_data1->ack_resend_count;\r\ng_hash_table_insert (table, key, ack_data2);\r\n}\r\nstatic p_mul_seq_val *register_p_mul_id (packet_info *pinfo, address *addr, guint32 dstIP,\r\nguint8 pdu_type, guint32 message_id,\r\nguint16 seq_no, gint no_missing)\r\n{\r\np_mul_seq_val *p_mul_data = NULL, *pkg_data = NULL;\r\np_mul_id_key *p_mul_key;\r\np_mul_ack_data *ack_data = NULL;\r\nnstime_t addr_time, prev_time;\r\nguint addr_id = 0, prev_id = 0;\r\nguint16 last_found_pdu = 0;\r\ngboolean missing_pdu = FALSE, need_set_address = FALSE;\r\nGHashTable *pkg_list;\r\nif (pinfo->flags.in_error_pkt) {\r\nreturn NULL;\r\n}\r\nnstime_set_zero(&addr_time);\r\nnstime_set_zero(&prev_time);\r\np_mul_key = wmem_new(wmem_file_scope(), p_mul_id_key);\r\nif (!pinfo->fd->flags.visited &&\r\n(pdu_type == Address_PDU || pdu_type == Data_PDU || pdu_type == Discard_Message_PDU))\r\n{\r\np_mul_key->id = message_id;\r\np_mul_key->seq = 0;\r\ncopy_address_wmem(wmem_file_scope(), &p_mul_key->addr, addr);\r\nneed_set_address = TRUE;\r\np_mul_data = (p_mul_seq_val *) g_hash_table_lookup (p_mul_id_hash_table, p_mul_key);\r\nif (p_mul_data) {\r\nlast_found_pdu = p_mul_data->last_found_pdu;\r\np_mul_data->last_found_pdu = seq_no;\r\naddr_id = p_mul_data->pdu_id;\r\naddr_time = p_mul_data->pdu_time;\r\np_mul_data->prev_pdu_id = pinfo->num;\r\np_mul_data->prev_pdu_time = pinfo->abs_ts;\r\nif (pdu_type == Data_PDU && p_mul_data->msg_resend_count == 0 && last_found_pdu != seq_no - 1) {\r\nmissing_pdu = TRUE;\r\n}\r\nif (last_found_pdu) {\r\np_mul_key->seq = last_found_pdu;\r\np_mul_data = (p_mul_seq_val *) g_hash_table_lookup (p_mul_id_hash_table, p_mul_key);\r\n}\r\nif (p_mul_data) {\r\nif (p_mul_data->prev_msg_id > 0) {\r\nprev_id = p_mul_data->prev_msg_id;\r\n} else {\r\nprev_id = p_mul_data->pdu_id;\r\n}\r\nprev_time = p_mul_data->pdu_time;\r\n}\r\n} else if (pdu_type == Address_PDU) {\r\naddr_id = pinfo->num;\r\naddr_time = pinfo->abs_ts;\r\n}\r\n}\r\npkg_list = (GHashTable *)p_get_proto_data(wmem_file_scope(), pinfo, proto_p_mul, 0);\r\nif (!pkg_list) {\r\npkg_list = g_hash_table_new (NULL, NULL);\r\np_mul_package_data_list = g_list_append (p_mul_package_data_list, pkg_list);\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_p_mul, 0, pkg_list);\r\n}\r\nif (!pinfo->fd->flags.visited) {\r\np_mul_key->id = message_id;\r\np_mul_key->seq = seq_no;\r\nif (!need_set_address) {\r\ncopy_address_wmem(wmem_file_scope(), &p_mul_key->addr, addr);\r\n}\r\np_mul_data = (p_mul_seq_val *) g_hash_table_lookup (p_mul_id_hash_table, p_mul_key);\r\nif (p_mul_data) {\r\nif (pdu_type == Ack_PDU) {\r\nif (no_missing == 0) {\r\nack_data = (p_mul_ack_data *)g_hash_table_lookup (p_mul_data->ack_data, GUINT_TO_POINTER(dstIP));\r\nif (!ack_data) {\r\nack_data = wmem_new0(wmem_file_scope(), p_mul_ack_data);\r\nack_data->ack_id = pinfo->num;\r\ng_hash_table_insert (p_mul_data->ack_data, GUINT_TO_POINTER(dstIP), ack_data);\r\n} else {\r\nack_data->ack_resend_count++;\r\n}\r\n}\r\n} else {\r\np_mul_data->msg_resend_count++;\r\np_mul_data->prev_msg_id = pinfo->num;\r\np_mul_data->prev_msg_time = p_mul_data->pdu_time;\r\np_mul_data->pdu_time = pinfo->abs_ts;\r\nif (pdu_type == Data_PDU) {\r\np_mul_data->prev_pdu_id = prev_id;\r\np_mul_data->prev_pdu_time = prev_time;\r\n}\r\n}\r\n} else {\r\nif (pdu_type == Ack_PDU) {\r\np_mul_data = wmem_new0(wmem_file_scope(), p_mul_seq_val);\r\n} else {\r\np_mul_data = (p_mul_seq_val *)g_malloc0(sizeof (p_mul_seq_val));\r\n}\r\np_mul_data->msg_type = pdu_type;\r\nif (pdu_type == Address_PDU || pdu_type == Ack_PDU) {\r\np_mul_data->ack_data = g_hash_table_new (NULL, NULL);\r\n}\r\nif (pdu_type == Ack_PDU) {\r\nack_data = wmem_new0(wmem_file_scope(), p_mul_ack_data);\r\nack_data->ack_id = pinfo->num;\r\ng_hash_table_insert (p_mul_data->ack_data, GUINT_TO_POINTER(dstIP), ack_data);\r\n} else {\r\np_mul_data->pdu_id = pinfo->num;\r\np_mul_data->pdu_time = pinfo->abs_ts;\r\np_mul_data->addr_id = addr_id;\r\np_mul_data->addr_time = addr_time;\r\np_mul_data->first_msg_time = pinfo->abs_ts;\r\nif (pdu_type == Data_PDU && !missing_pdu) {\r\np_mul_data->prev_pdu_id = prev_id;\r\np_mul_data->prev_pdu_time = prev_time;\r\n}\r\ng_hash_table_insert (p_mul_id_hash_table, p_mul_key, p_mul_data);\r\n}\r\n}\r\npkg_data = wmem_new(wmem_file_scope(), p_mul_seq_val);\r\n*pkg_data = *p_mul_data;\r\nif (p_mul_data->ack_data) {\r\npkg_data->ack_data = g_hash_table_new (NULL, NULL);\r\ng_hash_table_foreach (p_mul_data->ack_data, (GHFunc) copy_hashtable_data, pkg_data->ack_data);\r\n}\r\ng_hash_table_insert (pkg_list, GUINT_TO_POINTER(message_id), pkg_data);\r\n} else {\r\npkg_data = (p_mul_seq_val *)g_hash_table_lookup (pkg_list, GUINT_TO_POINTER(message_id));\r\n}\r\nDISSECTOR_ASSERT (pkg_data);\r\nreturn pkg_data;\r\n}\r\nstatic void add_ack_analysis (tvbuff_t *tvb, packet_info *pinfo, proto_tree *p_mul_tree,\r\ngint offset, guint8 pdu_type, address *src, address *dst,\r\nguint32 message_id, gint no_missing)\r\n{\r\nproto_tree *analysis_tree = NULL;\r\nproto_item *sa = NULL;\r\nproto_item *en = NULL;\r\np_mul_seq_val *pkg_data = NULL;\r\np_mul_ack_data *ack_data = NULL;\r\ngboolean item_added = FALSE;\r\nguint32 dstIp;\r\nnstime_t ns;\r\nif (pinfo->flags.in_error_pkt) {\r\nreturn;\r\n}\r\nif (pdu_type == Address_PDU) {\r\nanalysis_tree = proto_tree_add_subtree(p_mul_tree, tvb, 0, 0, ett_ack_analysis, &sa, "ACK analysis");\r\nPROTO_ITEM_SET_GENERATED (sa);\r\nif ((pkg_data = lookup_seq_val (message_id, 0, src)) == NULL) {\r\nreturn;\r\n}\r\nif (dst == NULL) {\r\nif (pkg_data->addr_id) {\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_acks_acked_addr_pdu_num, tvb,\r\n0, 0, pkg_data->addr_id);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nnstime_delta (&ns, &pinfo->abs_ts, &pkg_data->addr_time);\r\nen = proto_tree_add_time (analysis_tree, hf_analysis_total_time,\r\ntvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED (en);\r\n} else {\r\nproto_tree_add_expert(analysis_tree, pinfo, &ei_address_pdu_missing, tvb, offset, 0);\r\n}\r\nitem_added = TRUE;\r\n} else {\r\nmemcpy((guint8 *)&dstIp, dst->data, 4);\r\nif (pkg_data->ack_data) {\r\nack_data = (p_mul_ack_data *)g_hash_table_lookup (pkg_data->ack_data, GUINT_TO_POINTER(dstIp));\r\n}\r\nif (ack_data && ack_data->ack_id) {\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_ack_num, tvb,\r\n0, 0, ack_data->ack_id);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nitem_added = TRUE;\r\n} else if (!pkg_data->msg_resend_count) {\r\nen = proto_tree_add_item (analysis_tree,\r\nhf_analysis_ack_missing,\r\ntvb, offset, 0, ENC_NA);\r\nif (pinfo->fd->flags.visited) {\r\nexpert_add_info(pinfo, en, &ei_analysis_ack_missing);\r\nPROTO_ITEM_SET_GENERATED (en);\r\n}\r\nitem_added = TRUE;\r\n}\r\n}\r\nif (!item_added) {\r\nPROTO_ITEM_SET_HIDDEN (sa);\r\n}\r\n} else if (pdu_type == Ack_PDU) {\r\nanalysis_tree = proto_tree_add_subtree(p_mul_tree, tvb, 0, 0, ett_seq_ack_analysis, &sa, "SEQ/ACK analysis");\r\nPROTO_ITEM_SET_GENERATED (sa);\r\nmemcpy((guint8 *)&dstIp, dst->data, 4);\r\nif ((pkg_data = register_p_mul_id (pinfo, src, dstIp, pdu_type, message_id, 0, no_missing)) == NULL) {\r\nreturn;\r\n}\r\nif (pkg_data->ack_data) {\r\nack_data = (p_mul_ack_data *)g_hash_table_lookup (pkg_data->ack_data, GUINT_TO_POINTER(dstIp));\r\n}\r\nif (pkg_data->msg_type != Ack_PDU) {\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_acks_addr_pdu_num, tvb,\r\n0, 0, pkg_data->pdu_id);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nif (no_missing == 0) {\r\nnstime_delta (&ns, &pinfo->abs_ts, &pkg_data->first_msg_time);\r\nen = proto_tree_add_time (analysis_tree, hf_analysis_trans_time,\r\ntvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED (en);\r\n}\r\n} else {\r\nproto_tree_add_expert(analysis_tree, pinfo, &ei_address_pdu_missing, tvb, offset, 0);\r\n}\r\nif (pkg_data->msg_type != Ack_PDU && pkg_data->prev_pdu_id) {\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_last_pdu_num,\r\ntvb, 0, 0, pkg_data->prev_pdu_id);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nnstime_delta (&ns, &pinfo->abs_ts, &pkg_data->prev_pdu_time);\r\nen = proto_tree_add_time (analysis_tree, hf_analysis_ack_time,\r\ntvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED (en);\r\n}\r\nif (ack_data && ack_data->ack_resend_count) {\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_ack_dup_no,\r\ntvb, 0, 0, ack_data->ack_resend_count);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nexpert_add_info_format(pinfo, en, &ei_analysis_ack_dup_no, "Dup ACK #%d", ack_data->ack_resend_count);\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_ack_resend_from,\r\ntvb, 0, 0, ack_data->ack_id);\r\nPROTO_ITEM_SET_GENERATED (en);\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, "[Dup ACK %d#%d] ",\r\nack_data->ack_id, ack_data->ack_resend_count);\r\n}\r\n}\r\n}\r\nstatic p_mul_seq_val *add_seq_analysis (tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *p_mul_tree, address *src,\r\ngint offset,\r\nguint8 pdu_type, guint32 message_id,\r\nguint16 seq_no, gint no_missing)\r\n{\r\np_mul_seq_val *pkg_data;\r\nproto_tree *analysis_tree;\r\nproto_item *sa, *en = NULL, *eh = NULL;\r\ngboolean item_added = FALSE;\r\nnstime_t ns;\r\npkg_data = register_p_mul_id (pinfo, src, 0, pdu_type, message_id, seq_no,\r\nno_missing);\r\nif (!pkg_data) {\r\nreturn NULL;\r\n}\r\nanalysis_tree = proto_tree_add_subtree(p_mul_tree, tvb, 0, 0, ett_seq_analysis, &sa, "SEQ analysis");\r\nPROTO_ITEM_SET_GENERATED (sa);\r\nif (pdu_type == Data_PDU || pdu_type == Discard_Message_PDU) {\r\nif (pkg_data->addr_id) {\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_addr_pdu_num, tvb,\r\n0, 0, pkg_data->addr_id);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nnstime_delta (&ns, &pinfo->abs_ts, &pkg_data->addr_time);\r\nen = proto_tree_add_time (analysis_tree, hf_analysis_addr_pdu_time,\r\ntvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nif (pkg_data->prev_pdu_id == pkg_data->addr_id) {\r\nen = proto_tree_add_time (analysis_tree, hf_analysis_prev_pdu_time,\r\ntvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED (en);\r\n}\r\nitem_added = TRUE;\r\n} else if (!pkg_data->msg_resend_count) {\r\nproto_tree_add_expert(analysis_tree, pinfo, &ei_address_pdu_missing, tvb, offset, 0);\r\nitem_added = TRUE;\r\n}\r\n}\r\nif ((pdu_type == Data_PDU) && (pkg_data->prev_pdu_id != pkg_data->addr_id)) {\r\nif (pkg_data->prev_pdu_id) {\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_prev_pdu_num, tvb,\r\n0, 0, pkg_data->prev_pdu_id);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nnstime_delta (&ns, &pinfo->abs_ts, &pkg_data->prev_pdu_time);\r\nen = proto_tree_add_time (analysis_tree, hf_analysis_prev_pdu_time,\r\ntvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nitem_added = TRUE;\r\n} else if (!pkg_data->msg_resend_count) {\r\nproto_tree_add_expert(analysis_tree, pinfo, &ei_analysis_prev_pdu_missing, tvb, offset, 0);\r\nitem_added = TRUE;\r\n}\r\n}\r\nif ((pdu_type == Address_PDU) || (pdu_type == Data_PDU) ||\r\n(pdu_type == Discard_Message_PDU)) {\r\nif (pkg_data->msg_resend_count) {\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_retrans_no,\r\ntvb, 0, 0, pkg_data->msg_resend_count);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nen = proto_tree_add_uint (analysis_tree, hf_analysis_msg_resend_from,\r\ntvb, 0, 0, pkg_data->pdu_id);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nexpert_add_info_format(pinfo, en, &ei_analysis_retrans_no, "Retransmission #%d", pkg_data->msg_resend_count);\r\nnstime_delta (&ns, &pinfo->abs_ts, &pkg_data->prev_msg_time);\r\nen = proto_tree_add_time (analysis_tree, hf_analysis_retrans_time,\r\ntvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nnstime_delta (&ns, &pinfo->abs_ts, &pkg_data->first_msg_time);\r\neh = proto_tree_add_time (analysis_tree, hf_analysis_total_retrans_time,\r\ntvb, 0, 0, &ns);\r\nPROTO_ITEM_SET_GENERATED (eh);\r\nif (pkg_data->first_msg_time.secs == pkg_data->prev_msg_time.secs &&\r\npkg_data->first_msg_time.nsecs == pkg_data->prev_msg_time.nsecs) {\r\nPROTO_ITEM_SET_HIDDEN (eh);\r\n}\r\nitem_added = TRUE;\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, "[Retrans %d#%d] ",\r\npkg_data->pdu_id, pkg_data->msg_resend_count);\r\n}\r\n}\r\nif (!item_added) {\r\nPROTO_ITEM_SET_HIDDEN (sa);\r\n}\r\nreturn pkg_data;\r\n}\r\nstatic void dissect_reassembled_data (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nDISSECTOR_ASSERT(tvb != NULL);\r\nswitch (decode_option) {\r\ncase DECODE_BER:\r\ndissect_unknown_ber (pinfo, tvb, 0, tree);\r\nbreak;\r\ncase DECODE_CDT:\r\ndissect_cdt (tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\ncall_data_dissector(tvb, pinfo, tree);\r\nbreak;\r\n}\r\n}\r\nstatic int dissect_p_mul (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *p_mul_tree, *field_tree, *checksum_tree;\r\nproto_item *ti, *en, *len_en;\r\ngboolean save_fragmented;\r\nguint32 message_id = 0;\r\nguint16 no_dest = 0, count = 0, len, data_len = 0;\r\nguint16 checksum_calc, checksum_found;\r\nguint16 pdu_length, no_pdus = 0, seq_no = 0;\r\nguint8 pdu_type, *value, map = 0, fec_len;\r\ngint i, tot_no_missing = 0, no_missing = 0, offset = 0;\r\naddress src, dst;\r\nwmem_strbuf_t *message_id_list = NULL;\r\nnstime_t ts;\r\ngboolean fletcher = FALSE;\r\ncol_set_str (pinfo->cinfo, COL_PROTOCOL, "P_MUL");\r\ncol_clear (pinfo->cinfo, COL_INFO);\r\npdu_type = tvb_get_guint8 (tvb, offset + 3) & 0x3F;\r\nti = proto_tree_add_item (tree, proto_p_mul, tvb, offset, -1, ENC_NA);\r\nproto_item_append_text (ti, ", %s", get_type (pdu_type));\r\np_mul_tree = proto_item_add_subtree (ti, ett_p_mul);\r\npdu_length = tvb_get_ntohs (tvb, offset);\r\nlen_en = proto_tree_add_item (p_mul_tree, hf_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nswitch (pdu_type) {\r\ncase Data_PDU:\r\ncase Ack_PDU:\r\ncase Address_PDU:\r\ncase Discard_Message_PDU:\r\ncase Extra_Address_PDU:\r\ncase FEC_Address_PDU:\r\ncase Extra_FEC_Address_PDU:\r\nproto_tree_add_item (p_mul_tree, hf_priority, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item (p_mul_tree, hf_unused8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset += 1;\r\nen = proto_tree_add_uint_format (p_mul_tree, hf_pdu_type, tvb, offset, 1,\r\npdu_type, "PDU Type: %s (0x%02x)",\r\nget_type (pdu_type), pdu_type);\r\nfield_tree = proto_item_add_subtree (en, ett_pdu_type);\r\nif (pdu_type == Discard_Message_PDU) {\r\nexpert_add_info(pinfo, en, &ei_message_discarded);\r\n}\r\nswitch (pdu_type) {\r\ncase Address_PDU:\r\ncase Announce_PDU:\r\ncase Extra_Address_PDU:\r\ncase FEC_Address_PDU:\r\ncase Extra_FEC_Address_PDU:\r\nmap = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item (field_tree, hf_map_first, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (field_tree, hf_map_last, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif ((map & 0x80) || (map & 0x40)) {\r\nproto_item_append_text (en, ", %s / %s",\r\n(map & 0x80) ? "Not first" : "First",\r\n(map & 0x40) ? "Not last" : "Last");\r\n} else {\r\nproto_item_append_text (en, ", Only one PDU");\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item (field_tree, hf_map_unused, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nproto_tree_add_item (field_tree, hf_pdu_type_value, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nswitch (pdu_type) {\r\ncase Address_PDU:\r\ncase Extra_Address_PDU:\r\ncase FEC_Address_PDU:\r\ncase Extra_FEC_Address_PDU:\r\nno_pdus = tvb_get_ntohs (tvb, offset);\r\nseq_no = 0;\r\nproto_tree_add_item (p_mul_tree, hf_no_pdus, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text (ti, ", No PDUs: %u", no_pdus);\r\nbreak;\r\ncase Data_PDU:\r\nseq_no = tvb_get_ntohs (tvb, offset);\r\nproto_tree_add_item (p_mul_tree, hf_seq_no, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text (ti, ", Seq no: %u", seq_no);\r\nbreak;\r\ncase Announce_PDU:\r\ncount = tvb_get_ntohs (tvb, offset);\r\nproto_tree_add_item (p_mul_tree, hf_count_of_dest, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item (p_mul_tree, hf_unused16, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\noffset += 2;\r\nen = proto_tree_add_item (p_mul_tree, hf_checksum, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nchecksum_tree = proto_item_add_subtree (en, ett_checksum);\r\nlen = tvb_captured_length (tvb);\r\nvalue = (guint8 *)tvb_memdup (wmem_packet_scope(), tvb, 0, len);\r\nif (len >= offset+2) {\r\nvalue[offset] = 0;\r\nvalue[offset+1] = 0;\r\n}\r\nchecksum_found = tvb_get_ntohs (tvb, offset);\r\nchecksum_calc = g_ntohs (ip_checksum (value, len));\r\nif (checksum_calc != checksum_found) {\r\nguint16 checksum1 = checksum_acp142 (value, len, offset);\r\nif (checksum1 == checksum_found) {\r\nchecksum_calc = checksum1;\r\nfletcher = TRUE;\r\n}\r\n}\r\nif (checksum_calc == checksum_found) {\r\nif (fletcher) {\r\nproto_item_append_text (en, " [Fletcher algorithm]");\r\n}\r\nproto_item_append_text (en, " (correct)");\r\nen = proto_tree_add_boolean (checksum_tree, hf_checksum_good, tvb,\r\noffset, 2, TRUE);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nen = proto_tree_add_boolean (checksum_tree, hf_checksum_bad, tvb,\r\noffset, 2, FALSE);\r\nPROTO_ITEM_SET_GENERATED (en);\r\n} else {\r\nproto_item_append_text (en, " (incorrect, should be 0x%04x)", checksum_calc);\r\nexpert_add_info(pinfo, en, &ei_checksum_bad);\r\nen = proto_tree_add_boolean (checksum_tree, hf_checksum_good, tvb,\r\noffset, 2, FALSE);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nen = proto_tree_add_boolean (checksum_tree, hf_checksum_bad, tvb,\r\noffset, 2, TRUE);\r\nPROTO_ITEM_SET_GENERATED (en);\r\n}\r\noffset += 2;\r\nif (pdu_type == Ack_PDU) {\r\nset_address_tvb (&dst, AT_IPv4, 4, tvb, offset);\r\nproto_tree_add_item (p_mul_tree, hf_source_id_ack, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ncount = tvb_get_ntohs (tvb, offset);\r\nproto_tree_add_item (p_mul_tree, hf_ack_count, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n} else {\r\nset_address_tvb (&src, AT_IPv4, 4, tvb, offset);\r\nproto_tree_add_item (p_mul_tree, hf_source_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nmessage_id = tvb_get_ntohl (tvb, offset);\r\nif (use_relative_msgid) {\r\nif (message_id_offset == 0) {\r\nmessage_id_offset = message_id;\r\n}\r\nmessage_id -= message_id_offset;\r\nproto_tree_add_uint_format_value(p_mul_tree, hf_message_id, tvb, offset, 4,\r\nmessage_id, "%u (relative message id)", message_id);\r\n} else {\r\nproto_tree_add_item (p_mul_tree, hf_message_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\noffset += 4;\r\nproto_item_append_text (ti, ", MSID: %u", message_id);\r\n}\r\nif (pdu_type == Address_PDU || pdu_type == Announce_PDU ||\r\npdu_type == Extra_Address_PDU || pdu_type == FEC_Address_PDU ||\r\npdu_type == Extra_FEC_Address_PDU) {\r\nts.secs = tvb_get_ntohl (tvb, offset);\r\nts.nsecs = 0;\r\nproto_tree_add_time (p_mul_tree, hf_expiry_time, tvb, offset, 4, &ts);\r\noffset += 4;\r\n}\r\nif (pdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU) {\r\nfec_len = tvb_get_guint8 (tvb, offset);\r\nproto_tree_add_item (p_mul_tree, hf_fec_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item (p_mul_tree, hf_fec_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (fec_len > 0) {\r\nproto_tree_add_none_format (p_mul_tree, hf_fec_parameters, tvb, offset,\r\nfec_len, "FEC Parameters (%d byte%s)",\r\nfec_len, plurality (fec_len, "", "s"));\r\noffset += fec_len;\r\n}\r\n}\r\nswitch (pdu_type) {\r\ncase Address_PDU:\r\ncase Extra_Address_PDU:\r\ncase FEC_Address_PDU:\r\ncase Extra_FEC_Address_PDU:\r\nno_dest = tvb_get_ntohs (tvb, offset);\r\nproto_tree_add_item (p_mul_tree, hf_count_of_dest, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nlen = tvb_get_ntohs (tvb, offset);\r\nproto_tree_add_item (p_mul_tree, hf_length_of_res, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nfor (i = 0; i < no_dest; i++) {\r\nen = proto_tree_add_none_format (p_mul_tree, hf_dest_entry, tvb,\r\noffset, 8 + len,\r\n"Destination Entry #%d", i + 1);\r\nfield_tree = proto_item_add_subtree (en, ett_dest_entry);\r\nset_address_tvb (&dst, AT_IPv4, 4, tvb, offset);\r\nproto_tree_add_item (field_tree, hf_dest_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item (field_tree, hf_msg_seq_no, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (len > 0) {\r\nproto_tree_add_none_format (field_tree, hf_sym_key, tvb, offset,\r\nlen, "Symmetric Key (%d byte%s)",\r\nlen, plurality (len, "", "s"));\r\noffset += len;\r\n}\r\nif (use_seq_ack_analysis) {\r\nadd_ack_analysis (tvb, pinfo, field_tree, offset, pdu_type, &src, &dst,\r\nmessage_id, 0);\r\n}\r\n}\r\nif (no_dest == 0 && use_seq_ack_analysis) {\r\nadd_ack_analysis (tvb, pinfo, p_mul_tree, offset, pdu_type, &src, NULL,\r\nmessage_id, 0);\r\n}\r\nproto_item_append_text (ti, ", Count of Dest: %u", no_dest);\r\nbreak;\r\ncase Data_PDU:\r\ndata_len = tvb_captured_length_remaining (tvb, offset);\r\nproto_tree_add_none_format (p_mul_tree, hf_data_fragment, tvb, offset,\r\ndata_len, "Fragment %d of Data (%d byte%s)",\r\nseq_no, data_len,\r\nplurality (data_len, "", "s"));\r\nbreak;\r\ncase Ack_PDU:\r\nmessage_id_list = wmem_strbuf_new_label(wmem_packet_scope());\r\nfor (i = 0; i < count; i++) {\r\nlen = tvb_get_ntohs (tvb, offset);\r\nen = proto_tree_add_none_format (p_mul_tree, hf_ack_entry, tvb,\r\noffset, len,\r\n"Ack Info Entry #%d", i + 1);\r\nfield_tree = proto_item_add_subtree (en, ett_ack_entry);\r\nen = proto_tree_add_item (field_tree, hf_ack_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (len < 10) {\r\nproto_item_append_text (en, " (invalid length)");\r\nexpert_add_info(pinfo, en, &ei_ack_length);\r\n}\r\nset_address_tvb (&src, AT_IPv4, 4, tvb, offset);\r\nproto_tree_add_item (field_tree, hf_source_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nmessage_id = tvb_get_ntohl (tvb, offset);\r\nif (use_relative_msgid) {\r\nif (message_id_offset == 0) {\r\nmessage_id_offset = message_id;\r\n}\r\nmessage_id -= message_id_offset;\r\nproto_tree_add_uint_format_value(field_tree, hf_message_id, tvb, offset, 4,\r\nmessage_id, "%u (relative message id)", message_id);\r\n} else {\r\nproto_tree_add_item (field_tree, hf_message_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\noffset += 4;\r\nif (i == 0) {\r\nwmem_strbuf_append_printf (message_id_list, "%u", message_id);\r\n} else {\r\nwmem_strbuf_append_printf (message_id_list, ",%u", message_id);\r\n}\r\nif (len > 10) {\r\ngint num_seq_no = (len - 10) / 2;\r\nguint16 ack_seq_no, prev_ack_seq_no = 0;\r\nfor (no_missing = 0; no_missing < num_seq_no; no_missing++) {\r\nack_seq_no = tvb_get_ntohs (tvb, offset);\r\nif ((ack_seq_no != 0) && (no_missing < num_seq_no - 2) && tvb_get_ntohs (tvb, offset + 2) == 0) {\r\nguint16 end_seq_no = tvb_get_ntohs (tvb, offset + 4);\r\nen = proto_tree_add_bytes_format_value(field_tree, hf_miss_seq_range,\r\ntvb, offset, 6, NULL,\r\n"%d - %d",\r\nack_seq_no, end_seq_no);\r\nif (ack_seq_no >= end_seq_no) {\r\nproto_item_append_text (en, " (invalid)");\r\nexpert_add_info(pinfo, en, &ei_miss_seq_range);\r\n} else {\r\nproto_tree *missing_tree;\r\nguint16 sno;\r\nmissing_tree = proto_item_add_subtree (en, ett_range_entry);\r\nfor (sno = ack_seq_no; sno <= end_seq_no; sno++) {\r\nen = proto_tree_add_uint_format_value(missing_tree, hf_miss_seq_no,\r\ntvb, offset, 6, sno,\r\n"%d", sno);\r\nPROTO_ITEM_SET_GENERATED (en);\r\n}\r\ntot_no_missing += (end_seq_no - ack_seq_no + 1);\r\n}\r\noffset += 6;\r\nno_missing += 2;\r\nprev_ack_seq_no = end_seq_no;\r\n} else {\r\nen = proto_tree_add_item (field_tree, hf_miss_seq_no, tvb,offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (ack_seq_no == 0) {\r\nproto_item_append_text (en, " (invalid)");\r\nexpert_add_info(pinfo, en, &ei_miss_seq_no);\r\n} else if (ack_seq_no <= prev_ack_seq_no) {\r\nproto_item_append_text (en, " (end of list indicator)");\r\n} else {\r\ntot_no_missing++;\r\n}\r\nprev_ack_seq_no = ack_seq_no;\r\n}\r\n}\r\n}\r\nif (use_seq_ack_analysis) {\r\nadd_ack_analysis (tvb, pinfo, field_tree, offset, pdu_type, &src, &dst,\r\nmessage_id, no_missing);\r\n}\r\n}\r\nproto_item_append_text (ti, ", Count of Ack: %u", count);\r\nif (tvb_reported_length_remaining (tvb, offset) >= 8) {\r\nguint64 timestamp;\r\ntimestamp = tvb_get_ntoh64 (tvb, offset);\r\nproto_tree_add_uint64_format_value(p_mul_tree, hf_timestamp_option, tvb,\r\noffset, 8, timestamp,\r\n"%" G_GINT64_MODIFIER "d.%d second%s (%" G_GINT64_MODIFIER "u)",\r\ntimestamp / 10, (int) timestamp % 10,\r\n(timestamp == 10) ? "" : "s", timestamp);\r\noffset += 8;\r\n}\r\nif (tot_no_missing) {\r\nproto_item_append_text (ti, ", Missing seq numbers: %u", tot_no_missing);\r\nen = proto_tree_add_uint (p_mul_tree, hf_tot_miss_seq_no, tvb, 0, 0,\r\ntot_no_missing);\r\nPROTO_ITEM_SET_GENERATED (en);\r\nexpert_add_info_format(pinfo, en, &ei_tot_miss_seq_no, "Missing seq numbers: %d", tot_no_missing);\r\n}\r\nbreak;\r\ncase Discard_Message_PDU:\r\nseq_no = G_MAXUINT16;\r\nbreak;\r\ncase Announce_PDU:\r\nproto_tree_add_item (p_mul_tree, hf_ann_mc_group, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nfor (i = 0; i < count; i++) {\r\nproto_tree_add_item (p_mul_tree, hf_dest_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nbreak;\r\ncase Request_PDU:\r\ncase Reject_PDU:\r\ncase Release_PDU:\r\nproto_tree_add_item (p_mul_tree, hf_mc_group, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (use_seq_ack_analysis && (pdu_type <= Discard_Message_PDU) &&\r\n(pdu_type != Ack_PDU) && (pdu_type != Address_PDU || no_dest != 0))\r\n{\r\nadd_seq_analysis (tvb, pinfo, p_mul_tree, &src, offset, pdu_type,\r\nmessage_id, seq_no, tot_no_missing);\r\n}\r\nif (pdu_type == Address_PDU && no_dest == 0) {\r\ncol_append_str (pinfo->cinfo, COL_INFO, get_type (Ack_Ack_PDU));\r\n} else {\r\ncol_append_str (pinfo->cinfo, COL_INFO, get_type (pdu_type));\r\n}\r\nif (pdu_type == Address_PDU || pdu_type == Extra_Address_PDU ||\r\npdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU) {\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, ", No PDUs: %u", no_pdus);\r\n} else if (pdu_type == Data_PDU) {\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, ", Seq no: %u", seq_no);\r\n}\r\nif (pdu_type == Address_PDU || pdu_type == Extra_Address_PDU ||\r\npdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU) {\r\nif (no_dest > 0) {\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, ", Count of Dest: %u", no_dest);\r\n}\r\n} else if (pdu_type == Ack_PDU) {\r\nif (tot_no_missing) {\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, ", Missing seq numbers: %u",\r\ntot_no_missing);\r\n}\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, ", Count of Ack: %u", count);\r\n}\r\nif (pdu_type != Ack_PDU) {\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, ", MSID: %u", message_id);\r\n} else {\r\nif (message_id_list && wmem_strbuf_get_len(message_id_list) > 0) {\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, ", MSID: %s", wmem_strbuf_get_str(message_id_list));\r\n}\r\n}\r\nif (p_mul_reassemble) {\r\nsave_fragmented = pinfo->fragmented;\r\nif (pdu_type == Address_PDU && no_pdus > 0) {\r\nfragment_start_seq_check (&p_mul_reassembly_table,\r\npinfo, message_id, NULL, no_pdus - 1);\r\n} else if (pdu_type == Data_PDU) {\r\nfragment_head *frag_msg;\r\ntvbuff_t *new_tvb;\r\npinfo->fragmented = TRUE;\r\nfrag_msg = fragment_add_seq_check (&p_mul_reassembly_table,\r\ntvb, offset, pinfo, message_id, NULL,\r\nseq_no - 1, data_len, TRUE);\r\nnew_tvb = process_reassembled_data (tvb, offset, pinfo,\r\n"Reassembled P_MUL", frag_msg,\r\n&p_mul_frag_items, NULL, tree);\r\nif (frag_msg)\r\ncol_append_str (pinfo->cinfo, COL_INFO, " (Message Reassembled)");\r\nif (new_tvb) {\r\ndissect_reassembled_data (new_tvb, pinfo, tree);\r\n}\r\n}\r\npinfo->fragmented = save_fragmented;\r\n}\r\nproto_item_set_len (ti, offset);\r\nif (pdu_length != (offset + data_len)) {\r\nproto_item_append_text (len_en, " (incorrect, should be: %d)",\r\noffset + data_len);\r\nexpert_add_info(pinfo, len_en, &ei_length);\r\n} else if ((len = tvb_reported_length_remaining (tvb, pdu_length)) > 0) {\r\nproto_item_append_text (len_en, " (more data in packet: %d)", len);\r\nexpert_add_info(pinfo, len_en, &ei_more_data);\r\n}\r\nreturn offset;\r\n}\r\nstatic void p_mul_init_routine (void)\r\n{\r\nreassembly_table_init (&p_mul_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\nmessage_id_offset = 0;\r\np_mul_id_hash_table = g_hash_table_new_full (p_mul_id_hash, p_mul_id_hash_equal, NULL, (GDestroyNotify)p_mul_id_value_destroy);\r\np_mul_package_data_list = NULL;\r\n}\r\nstatic void p_mul_cleanup_routine (void)\r\n{\r\nreassembly_table_destroy(&p_mul_reassembly_table);\r\ng_hash_table_destroy(p_mul_id_hash_table);\r\ng_list_foreach(p_mul_package_data_list, (GFunc)p_mul_package_data_destroy, NULL);\r\ng_list_free(p_mul_package_data_list);\r\n}\r\nvoid proto_register_p_mul (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_length,\r\n{ "Length of PDU", "p_mul.length", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_priority,\r\n{ "Priority", "p_mul.priority", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_map_first,\r\n{ "First", "p_mul.first", FT_BOOLEAN, 8,\r\nTFS (&no_yes), 0x80, NULL, HFILL } },\r\n{ &hf_map_last,\r\n{ "Last", "p_mul.last", FT_BOOLEAN, 8,\r\nTFS (&no_yes), 0x40, NULL, HFILL } },\r\n{ &hf_map_unused,\r\n{ "MAP unused", "p_mul.unused", FT_UINT8, BASE_DEC,\r\nNULL, 0xC0, NULL, HFILL } },\r\n{ &hf_pdu_type,\r\n{ "PDU Type", "p_mul.pdu_type", FT_UINT8, BASE_DEC,\r\nVALS (pdu_vals), 0x3F, NULL, HFILL } },\r\n{ &hf_pdu_type_value,\r\n{ "PDU Type", "p_mul.pdu_type_value", FT_UINT8, BASE_DEC,\r\nVALS (pdu_vals), 0x3F, NULL, HFILL } },\r\n{ &hf_no_pdus,\r\n{ "Total Number of PDUs", "p_mul.no_pdus", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_seq_no,\r\n{ "Sequence Number of PDUs", "p_mul.seq_no", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_unused8,\r\n{ "Unused", "p_mul.unused", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_unused16,\r\n{ "Unused", "p_mul.unused", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_checksum,\r\n{ "Checksum", "p_mul.checksum", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_checksum_good,\r\n{ "Good", "p_mul.checksum_good", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "True: checksum matches packet content; False: doesn't match content or not checked", HFILL } },\r\n{ &hf_checksum_bad,\r\n{ "Bad", "p_mul.checksum_bad", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, "True: checksum doesn't match packet content; False: matches content or not checked", HFILL } },\r\n{ &hf_source_id_ack,\r\n{ "Source ID of Ack Sender", "p_mul.source_id_ack", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_source_id,\r\n{ "Source ID", "p_mul.source_id", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_message_id,\r\n{ "Message ID (MSID)", "p_mul.message_id", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "Message ID", HFILL } },\r\n{ &hf_expiry_time,\r\n{ "Expiry Time", "p_mul.expiry_time", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_mc_group,\r\n{ "Multicast Group", "p_mul.mc_group", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_ann_mc_group,\r\n{ "Announced Multicast Group", "p_mul.ann_mc_group", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_fec_len,\r\n{ "FEC Parameter Length", "p_mul.fec.length", FT_UINT8, BASE_DEC,\r\nNULL, 0x0, "Forward Error Correction Parameter Length", HFILL } },\r\n{ &hf_fec_id,\r\n{ "FEC ID", "p_mul.fec.id", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, "Forward Error Correction ID", HFILL } },\r\n{ &hf_fec_parameters,\r\n{ "FEC Parameters", "p_mul.fec.parameters", FT_NONE, BASE_NONE,\r\nNULL, 0x0, "Forward Error Correction Parameters", HFILL } },\r\n{ &hf_count_of_dest,\r\n{ "Count of Destination Entries", "p_mul.dest_count", FT_UINT16,BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_length_of_res,\r\n{ "Length of Reserved Field", "p_mul.reserved_length",FT_UINT16,BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_ack_count,\r\n{ "Count of Ack Info Entries", "p_mul.ack_count", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_ack_entry,\r\n{ "Ack Info Entry", "p_mul.ack_info_entry", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_ack_length,\r\n{ "Length of Ack Info Entry", "p_mul.ack_length", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_miss_seq_no,\r\n{ "Missing Data PDU Seq Number", "p_mul.missing_seq_no", FT_UINT16,\r\nBASE_DEC, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_miss_seq_range,\r\n{ "Missing Data PDU Seq Range", "p_mul.missing_seq_range", FT_BYTES,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_tot_miss_seq_no,\r\n{ "Total Number of Missing Data PDU Sequence Numbers",\r\n"p_mul.no_missing_seq_no", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_timestamp_option,\r\n{ "Timestamp", "p_mul.timestamp", FT_UINT64, BASE_DEC,\r\nNULL, 0x0, "Timestamp Option (in units of 100ms)", HFILL } },\r\n{ &hf_dest_entry,\r\n{ "Destination Entry", "p_mul.dest_entry", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_dest_id,\r\n{ "Destination ID", "p_mul.dest_id", FT_IPv4, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_msg_seq_no,\r\n{ "Message Sequence Number", "p_mul.msg_seq_no", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_sym_key,\r\n{ "Symmetric Key", "p_mul.sym_key", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_data_fragment,\r\n{ "Fragment of Data", "p_mul.data_fragment", FT_NONE, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_msg_fragments,\r\n{ "Message fragments", "p_mul.fragments", FT_NONE, BASE_NONE,\r\nNULL, 0x00, NULL, HFILL } },\r\n{ &hf_msg_fragment,\r\n{ "Message fragment", "p_mul.fragment", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x00, NULL, HFILL } },\r\n{ &hf_msg_fragment_overlap,\r\n{ "Message fragment overlap", "p_mul.fragment.overlap", FT_BOOLEAN,\r\nBASE_NONE, NULL, 0x0, NULL, HFILL } },\r\n{ &hf_msg_fragment_overlap_conflicts,\r\n{ "Message fragment overlapping with conflicting data",\r\n"p_mul.fragment.overlap.conflicts", FT_BOOLEAN, BASE_NONE, NULL,\r\n0x0, NULL, HFILL } },\r\n{ &hf_msg_fragment_multiple_tails,\r\n{ "Message has multiple tail fragments",\r\n"p_mul.fragment.multiple_tails", FT_BOOLEAN, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL } },\r\n{ &hf_msg_fragment_too_long_fragment,\r\n{ "Message fragment too long", "p_mul.fragment.too_long_fragment",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL,\r\nHFILL } },\r\n{ &hf_msg_fragment_error,\r\n{ "Message defragmentation error", "p_mul.fragment.error", FT_FRAMENUM,\r\nBASE_NONE, NULL, 0x00, NULL, HFILL } },\r\n{ &hf_msg_fragment_count,\r\n{ "Message fragment count", "p_mul.fragment.count", FT_UINT32, BASE_DEC,\r\nNULL, 0x00, NULL, HFILL } },\r\n{ &hf_msg_reassembled_in,\r\n{ "Reassembled in", "p_mul.reassembled.in", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x00, NULL, HFILL } },\r\n{ &hf_msg_reassembled_length,\r\n{ "Reassembled P_MUL length", "p_mul.reassembled.length", FT_UINT32, BASE_DEC,\r\nNULL, 0x00, NULL, HFILL } },\r\n{ &hf_analysis_ack_time,\r\n{ "Ack Time", "p_mul.analysis.ack_time", FT_RELATIVE_TIME, BASE_NONE,\r\nNULL, 0x0, "The time between the Last PDU and the Ack", HFILL } },\r\n{ &hf_analysis_trans_time,\r\n{ "Transfer Time", "p_mul.analysis.trans_time", FT_RELATIVE_TIME, BASE_NONE,\r\nNULL, 0x0, "The time between the first Address PDU and the Ack", HFILL } },\r\n{ &hf_analysis_retrans_time,\r\n{ "Retransmission Time", "p_mul.analysis.retrans_time", FT_RELATIVE_TIME, BASE_NONE,\r\nNULL, 0x0, "The time between the last PDU and this PDU", HFILL } },\r\n{ &hf_analysis_total_retrans_time,\r\n{ "Total Retransmission Time", "p_mul.analysis.total_retrans_time", FT_RELATIVE_TIME, BASE_NONE,\r\nNULL, 0x0, "The time between the first PDU and this PDU", HFILL } },\r\n{ &hf_analysis_addr_pdu_time,\r\n{ "Time since Address PDU", "p_mul.analysis.elapsed_time", FT_RELATIVE_TIME, BASE_NONE,\r\nNULL, 0x0, "The time between the Address PDU and this PDU", HFILL } },\r\n{ &hf_analysis_prev_pdu_time,\r\n{ "PDU Delay", "p_mul.analysis.pdu_delay", FT_RELATIVE_TIME, BASE_NONE,\r\nNULL, 0x0, "The time between the last PDU and this PDU", HFILL } },\r\n{ &hf_analysis_last_pdu_num,\r\n{ "Last Data PDU in", "p_mul.analysis.last_pdu_in", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "The last Data PDU found in this frame", HFILL } },\r\n{ &hf_analysis_addr_pdu_num,\r\n{ "Address PDU in", "p_mul.analysis.addr_pdu_in", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "The Address PDU is found in this frame", HFILL } },\r\n{ &hf_analysis_acks_addr_pdu_num,\r\n{ "This is an Ack to the Address PDU in", "p_mul.analysis.acks_addr_pdu_in", FT_FRAMENUM, BASE_NONE,\r\nFRAMENUM_TYPE(FT_FRAMENUM_ACK), 0x0, "The Address PDU is found in this frame", HFILL } },\r\n{ &hf_analysis_acks_acked_addr_pdu_num,\r\n{ "This is an Ack-Ack to the Address PDU in", "p_mul.analysis.acks_acked_addr_pdu_in", FT_FRAMENUM, BASE_NONE,\r\nFRAMENUM_TYPE(FT_FRAMENUM_DUP_ACK), 0x0, "The Address PDU is found in this frame", HFILL } },\r\n{ &hf_analysis_prev_pdu_num,\r\n{ "Previous PDU in", "p_mul.analysis.prev_pdu_in", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "The previous PDU is found in this frame", HFILL } },\r\n{ &hf_analysis_ack_num,\r\n{ "Ack PDU in", "p_mul.analysis.ack_in", FT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "This packet has an Ack in this frame", HFILL } },\r\n{ &hf_analysis_ack_missing,\r\n{ "Ack PDU missing", "p_mul.analysis.ack_missing", FT_NONE, BASE_NONE,\r\nNULL, 0x0, "The acknowledgement for this packet is missing", HFILL } },\r\n{ &hf_analysis_retrans_no,\r\n{ "Retransmission #", "p_mul.analysis.retrans_no", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "Retransmission count", HFILL } },\r\n{ &hf_analysis_ack_dup_no,\r\n{ "Duplicate ACK #", "p_mul.analysis.dup_ack_no", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "Duplicate Ack count", HFILL } },\r\n{ &hf_analysis_msg_resend_from,\r\n{ "Retransmission of Message in", "p_mul.analysis.msg_first_in",\r\nFT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "This Message was first sent in this frame", HFILL } },\r\n{ &hf_analysis_ack_resend_from,\r\n{ "Retransmission of Ack in", "p_mul.analysis.ack_first_in",\r\nFT_FRAMENUM, BASE_NONE,\r\nNULL, 0x0, "This Ack was first sent in this frame", HFILL } },\r\n{ &hf_analysis_total_time,\r\n{ "Total Time", "p_mul.analysis.total_time", FT_RELATIVE_TIME, BASE_NONE,\r\nNULL, 0x0, "The time between the first and the last Address PDU", HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_p_mul,\r\n&ett_pdu_type,\r\n&ett_dest_entry,\r\n&ett_ack_entry,\r\n&ett_range_entry,\r\n&ett_checksum,\r\n&ett_seq_analysis,\r\n&ett_ack_analysis,\r\n&ett_seq_ack_analysis,\r\n&ett_msg_fragment,\r\n&ett_msg_fragments\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_address_pdu_missing, { "p_mul.analysis.addr_pdu_missing", PI_SEQUENCE, PI_NOTE, "Address PDU missing", EXPFILL }},\r\n{ &ei_analysis_ack_missing, { "p_mul.analysis.ack_missing.expert", PI_SEQUENCE, PI_NOTE, "Ack PDU missing", EXPFILL }},\r\n{ &ei_analysis_ack_dup_no, { "p_mul.analysis.dup_ack_no.expert", PI_SEQUENCE, PI_NOTE, "Dup ACK #", EXPFILL }},\r\n{ &ei_analysis_prev_pdu_missing, { "p_mul.analysis.prev_pdu_missing", PI_SEQUENCE, PI_NOTE, "Previous PDU missing", EXPFILL }},\r\n{ &ei_analysis_retrans_no, { "p_mul.analysis.retrans_no.expert", PI_SEQUENCE, PI_NOTE, "Retransmission #", EXPFILL }},\r\n{ &ei_message_discarded, { "p_mul.message_discarded", PI_RESPONSE_CODE, PI_NOTE, "Message discarded", EXPFILL }},\r\n{ &ei_checksum_bad, { "p_mul.checksum_bad.expert", PI_CHECKSUM, PI_WARN, "Bad checksum", EXPFILL }},\r\n{ &ei_ack_length, { "p_mul.ack_length.invalid", PI_MALFORMED, PI_WARN, "Invalid ack info length", EXPFILL }},\r\n{ &ei_miss_seq_range, { "p_mul.missing_seq_range.invalid", PI_UNDECODED, PI_WARN, "Invalid missing sequence range", EXPFILL }},\r\n{ &ei_miss_seq_no, { "p_mul.missing_seq_no.invalid", PI_UNDECODED, PI_WARN, "Invalid missing seq number", EXPFILL }},\r\n{ &ei_tot_miss_seq_no, { "p_mul.no_missing_seq_no.expert", PI_RESPONSE_CODE, PI_NOTE, "Missing seq numbers", EXPFILL }},\r\n{ &ei_length, { "p_mul.length.invalid", PI_MALFORMED, PI_WARN, "Incorrect length field", EXPFILL }},\r\n{ &ei_more_data, { "p_mul.more_data", PI_MALFORMED, PI_WARN, "More data in packet", EXPFILL }},\r\n};\r\nmodule_t *p_mul_module;\r\nexpert_module_t* expert_p_mul;\r\nproto_p_mul = proto_register_protocol (PNAME, PSNAME, PFNAME);\r\np_mul_handle = register_dissector(PFNAME, dissect_p_mul, proto_p_mul);\r\nproto_register_field_array (proto_p_mul, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nexpert_p_mul = expert_register_protocol(proto_p_mul);\r\nexpert_register_field_array(expert_p_mul, ei, array_length(ei));\r\nregister_init_routine (&p_mul_init_routine);\r\nregister_cleanup_routine (&p_mul_cleanup_routine);\r\nrange_convert_str (&global_p_mul_port_range, DEFAULT_P_MUL_PORT_RANGE,\r\nMAX_UDP_PORT);\r\np_mul_module = prefs_register_protocol (proto_p_mul,\r\nproto_reg_handoff_p_mul);\r\nprefs_register_obsolete_preference (p_mul_module, "tport");\r\nprefs_register_obsolete_preference (p_mul_module, "rport");\r\nprefs_register_obsolete_preference (p_mul_module, "dport");\r\nprefs_register_obsolete_preference (p_mul_module, "aport");\r\nprefs_register_range_preference (p_mul_module, "udp_ports",\r\n"P_Mul port numbers",\r\n"Port numbers used for P_Mul traffic",\r\n&global_p_mul_port_range, MAX_UDP_PORT);\r\nprefs_register_bool_preference (p_mul_module, "reassemble",\r\n"Reassemble fragmented P_Mul packets",\r\n"Reassemble fragmented P_Mul packets",\r\n&p_mul_reassemble);\r\nprefs_register_bool_preference (p_mul_module, "relative_msgid",\r\n"Use relative Message ID",\r\n"Make the P_Mul dissector use relative"\r\n" message id number instead of absolute"\r\n" ones", &use_relative_msgid);\r\nprefs_register_bool_preference (p_mul_module, "seq_ack_analysis",\r\n"SEQ/ACK Analysis",\r\n"Calculate sequence/acknowledgement analysis",\r\n&use_seq_ack_analysis);\r\nprefs_register_enum_preference (p_mul_module, "decode",\r\n"Decode Data PDU as",\r\n"Type of content in Data_PDU",\r\n&decode_option, decode_options, FALSE);\r\n}\r\nvoid proto_reg_handoff_p_mul (void)\r\n{\r\nstatic gboolean p_mul_prefs_initialized = FALSE;\r\nstatic range_t *p_mul_port_range;\r\nif (!p_mul_prefs_initialized) {\r\np_mul_prefs_initialized = TRUE;\r\ndissector_add_uint ("s5066sis.ctl.appid", S5066_CLIENT_S4406_ANNEX_E_TMI_1_P_MUL, p_mul_handle);\r\n} else {\r\ndissector_delete_uint_range ("udp.port", p_mul_port_range, p_mul_handle);\r\ng_free (p_mul_port_range);\r\n}\r\np_mul_port_range = range_copy (global_p_mul_port_range);\r\ndissector_add_uint_range ("udp.port", p_mul_port_range, p_mul_handle);\r\n}
