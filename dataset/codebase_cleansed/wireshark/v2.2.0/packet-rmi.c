static int\r\ndissect_rmi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *rmi_tree;\r\ntvbuff_t *next_tvb;\r\ngint offset = 0;\r\ngint next_offset;\r\nint datalen;\r\nguint16 version, len, port;\r\nguint8 message, proto;\r\nrmi_type rmitype;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "RMI");\r\ndatalen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nrmitype = get_rmi_type(tvb, offset, datalen);\r\nswitch(rmitype) {\r\ncase RMI_OUTPUTSTREAM:\r\nversion = tvb_get_ntohs(tvb,4);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"JRMI, Version: %d, ", version);\r\nproto = tvb_get_guint8(tvb, 6);\r\ncol_append_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(proto, rmi_protocol_str,\r\n"Unknown protocol"));\r\nbreak;\r\ncase RMI_OUTPUTMESSAGE:\r\nmessage = tvb_get_guint8(tvb,0);\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\n"JRMI, ");\r\ncol_append_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(message, rmi_output_message_str,\r\n"Unknown message"));\r\nbreak;\r\ncase RMI_INPUTSTREAM:\r\nmessage = tvb_get_guint8(tvb,0);\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\n"JRMI, ");\r\ncol_append_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(message, rmi_input_message_str,\r\n"Unknown message"));\r\nbreak;\r\ncase SERIALIZATION_DATA:\r\nversion = tvb_get_ntohs(tvb,2);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Serialization data, Version: %d", version);\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Continuation");\r\nbreak;\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_rmi, tvb, 0, -1, ENC_NA);\r\nrmi_tree = proto_item_add_subtree(ti, ett_rmi);\r\nswitch(rmitype) {\r\ncase RMI_OUTPUTSTREAM:\r\nproto_tree_add_uint(rmi_tree, hf_rmi_magic,\r\ntvb, offset, 4, tvb_get_ntohl(tvb,0));\r\nproto_tree_add_item(rmi_tree, hf_rmi_version,\r\ntvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(rmi_tree, hf_rmi_protocol,\r\ntvb, offset + 6, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase RMI_INPUTSTREAM:\r\nmessage = tvb_get_guint8(tvb, 0);\r\nproto_tree_add_uint(rmi_tree, hf_rmi_inputmessage,\r\ntvb, offset, 1, message);\r\nif(message == RMI_INPUTSTREAM_MESSAGE_ACK) {\r\nproto_tree* endpoint_tree = proto_tree_add_subtree(rmi_tree, tvb, offset + 1, -1,\r\nett_rmi_endpoint_identifier, NULL, "EndPointIdentifier");\r\nlen = tvb_get_ntohs(tvb, 1);\r\nproto_tree_add_uint(endpoint_tree, hf_rmi_epid_length,\r\ntvb, offset + 1, 2, len);\r\nif (len > 0) {\r\nproto_tree_add_item(endpoint_tree, hf_rmi_epid_hostname,\r\ntvb, offset + 3, len, ENC_ASCII|ENC_NA);\r\n} else {\r\nproto_tree_add_string(endpoint_tree, hf_rmi_epid_hostname,\r\ntvb, offset + 3, len, "[Empty]");\r\n}\r\nport = tvb_get_ntohs(tvb, offset + len + 5);\r\nproto_tree_add_uint(endpoint_tree, hf_rmi_epid_port,\r\ntvb, offset + len + 5, 2, port);\r\n}\r\nif(message == RMI_INPUTSTREAM_MESSAGE_RETURNDATA) {\r\nproto_tree_add_bytes_format(rmi_tree, hf_rmi_serialization_data, tvb, offset + 1, -1,\r\nNULL, "Serialization Data");\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset + 1);\r\ndissect_ser(next_tvb, tree);\r\n}\r\nbreak;\r\ncase RMI_OUTPUTMESSAGE:\r\nmessage = tvb_get_guint8(tvb, 0);\r\nproto_tree_add_uint(rmi_tree, hf_rmi_outputmessage,\r\ntvb, offset, 1, message);\r\nif(message == RMI_OUTPUTSTREAM_MESSAGE_CALL) {\r\nproto_tree_add_bytes_format(rmi_tree, hf_rmi_serialization_data, tvb, offset + 1, -1,\r\nNULL, "Serialization Data");\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset + 1);\r\ndissect_ser(next_tvb, tree);\r\n}\r\nif(message == RMI_OUTPUTSTREAM_MESSAGE_DGCACK) {\r\nproto_tree_add_item(rmi_tree, hf_rmi_unique_identifier, tvb, offset + 1, -1, ENC_NA);\r\n}\r\nbreak;\r\ncase SERIALIZATION_DATA:\r\ndissect_ser(tvb, tree);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_ser(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *ser_tree;\r\ngint offset;\r\noffset = 0;\r\nif(tree) {\r\nti = proto_tree_add_item(tree, proto_ser, tvb, 0, -1, ENC_NA);\r\nser_tree = proto_item_add_subtree(ti, ett_ser);\r\nproto_tree_add_item(ser_tree, hf_ser_magic,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ser_tree, hf_ser_version,\r\ntvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic rmi_type\r\nget_rmi_type(tvbuff_t *tvb, gint offset, int datalen)\r\n{\r\nguint16 ser_magic;\r\nguchar data[4];\r\ntvb_memcpy(tvb, data, offset, (datalen > 4) ? 4 : datalen);\r\nif (datalen >= 2) {\r\nser_magic = data[0] << 8 | data[1];\r\nif (ser_magic == SER_STREAM_MAGIC) {\r\nreturn SERIALIZATION_DATA;\r\n}\r\n}\r\nif (datalen >= 4) {\r\nif(strncmp(data, RMI_MAGIC, 4) == 0) {\r\nreturn RMI_OUTPUTSTREAM;\r\n}\r\n}\r\nif (datalen >= 1) {\r\nif (data[0] == RMI_INPUTSTREAM_MESSAGE_ACK ||\r\ndata[0] == RMI_INPUTSTREAM_MESSAGE_NOTSUPPORTED ||\r\ndata[0] == RMI_INPUTSTREAM_MESSAGE_RETURNDATA ||\r\ndata[0] == RMI_INPUTSTREAM_MESSAGE_PINGACK) {\r\nreturn RMI_INPUTSTREAM;\r\n}\r\n}\r\nif (datalen >= 1) {\r\nif (data[0] == RMI_OUTPUTSTREAM_MESSAGE_CALL ||\r\ndata[0] == RMI_OUTPUTSTREAM_MESSAGE_PING ||\r\ndata[0] == RMI_OUTPUTSTREAM_MESSAGE_DGCACK) {\r\nreturn RMI_OUTPUTMESSAGE;\r\n}\r\n}\r\nreturn CONTINUATION;\r\n}\r\nvoid\r\nproto_register_rmi(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_rmi_magic,\r\n{ "Magic", "rmi.magic",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"RMI Header Magic", HFILL }},\r\n{ &hf_rmi_version,\r\n{ "Version", "rmi.version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"RMI Protocol Version", HFILL }},\r\n{ &hf_rmi_protocol,\r\n{ "Protocol","rmi.protocol",\r\nFT_UINT8, BASE_HEX, VALS(rmi_protocol_str), 0x0,\r\n"RMI Protocol Type", HFILL }},\r\n{ &hf_rmi_inputmessage,\r\n{ "Input Stream Message", "rmi.inputstream.message",\r\nFT_UINT8, BASE_HEX, VALS(rmi_input_message_str), 0x0,\r\n"RMI Inputstream Message Token", HFILL }},\r\n{ &hf_rmi_outputmessage,\r\n{ "Output Stream Message", "rmi.outputstream.message",\r\nFT_UINT8, BASE_HEX, VALS(rmi_output_message_str), 0x0,\r\n"RMI Outputstream Message token", HFILL }},\r\n{ &hf_rmi_epid_length,\r\n{ "Length", "rmi.endpoint_id.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"RMI Endpointidentifier Length", HFILL }},\r\n{ &hf_rmi_epid_hostname,\r\n{ "Hostname", "rmi.endpoint_id.hostname",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"RMI Endpointidentifier Hostname", HFILL }},\r\n{ &hf_rmi_epid_port,\r\n{ "Port", "rmi.endpoint_id.port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"RMI Endpointindentifier Port", HFILL }},\r\n{ &hf_rmi_serialization_data,\r\n{ "Serialization Data", "rmi.serialization_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_rmi_unique_identifier,\r\n{ "UniqueIdentifier", "rmi.unique_identifier",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_ser_magic,\r\n{ "Magic", "rmi.ser.magic",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Java Serialization Magic", HFILL }},\r\n{ &hf_ser_version,\r\n{ "Version", "rmi.ser.version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Java Serialization Version", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_rmi,\r\n&ett_rmi_magic,\r\n&ett_rmi_version,\r\n&ett_rmi_inputmessage,\r\n&ett_rmi_outputmessage,\r\n&ett_rmi_epid_length,\r\n&ett_rmi_epid_hostname,\r\n&ett_rmi_epid_port,\r\n&ett_ser,\r\n&ett_rmi_endpoint_identifier,\r\n};\r\nproto_rmi = proto_register_protocol("Java RMI", "RMI", "rmi");\r\nproto_ser = proto_register_protocol("Java Serialization", "Serialization",\r\n"serialization");\r\nproto_register_field_array(proto_rmi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_rmi(void)\r\n{\r\ndissector_handle_t rmi_handle;\r\nrmi_handle = create_dissector_handle(dissect_rmi, proto_rmi);\r\ndissector_add_uint("tcp.port", TCP_PORT_RMI, rmi_handle);\r\n}
