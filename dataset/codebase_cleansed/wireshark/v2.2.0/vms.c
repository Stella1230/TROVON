static long vms_seek_next_packet(wtap *wth, int *err, gchar **err_info)\r\n{\r\nlong cur_off;\r\nchar buf[VMS_LINE_LENGTH];\r\nwhile (1) {\r\ncur_off = file_tell(wth->fh);\r\nif (cur_off == -1) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\r\n*err = file_error(wth->fh, err_info);\r\nbreak;\r\n}\r\nif (strstr(buf, VMS_REC_MAGIC_STR1) ||\r\nstrstr(buf, VMS_REC_MAGIC_STR2) ||\r\nstrstr(buf, VMS_REC_MAGIC_STR2)) {\r\ng_strlcpy(hdr, buf,VMS_LINE_LENGTH);\r\nreturn cur_off;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic gboolean vms_check_file_type(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar buf[VMS_LINE_LENGTH];\r\nguint reclen, line;\r\ngint64 mpos;\r\nbuf[VMS_LINE_LENGTH-1] = '\0';\r\nfor (line = 0; line < VMS_HEADER_LINES_TO_CHECK; line++) {\r\nmpos = file_tell(wth->fh);\r\nif (mpos == -1) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn FALSE;\r\n}\r\nif (file_gets(buf, VMS_LINE_LENGTH, wth->fh) == NULL) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn FALSE;\r\n}\r\nreclen = (guint) strlen(buf);\r\nif (reclen < strlen(VMS_HDR_MAGIC_STR1) ||\r\nreclen < strlen(VMS_HDR_MAGIC_STR2) ||\r\nreclen < strlen(VMS_HDR_MAGIC_STR3)) {\r\ncontinue;\r\n}\r\nif (strstr(buf, VMS_HDR_MAGIC_STR1) ||\r\nstrstr(buf, VMS_HDR_MAGIC_STR2) ||\r\nstrstr(buf, VMS_HDR_MAGIC_STR3)) {\r\nif (file_seek(wth->fh, mpos, SEEK_SET, err) == -1) {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\n}\r\n*err = 0;\r\nreturn FALSE;\r\n}\r\nwtap_open_return_val vms_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nif (!vms_check_file_type(wth, err, err_info)) {\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nwth->file_encap = WTAP_ENCAP_RAW_IP;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_VMS;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = vms_read;\r\nwth->subtype_seek_read = vms_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_CSEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean vms_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\ngint64 offset = 0;\r\n#ifdef TCPIPTRACE_FRAGMENTS_HAVE_HEADER_LINE\r\noffset = vms_seek_next_packet(wth, err, err_info);\r\n#else\r\noffset = file_tell(wth->fh);\r\n#endif\r\nif (offset < 1) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn FALSE;\r\n}\r\n*data_offset = offset;\r\nreturn parse_vms_packet(wth->fh, &wth->phdr, wth->frame_buffer, err, err_info);\r\n}\r\nstatic gboolean\r\nvms_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off - 1, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!parse_vms_packet(wth->random_fh, phdr, buf, err, err_info)) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\nisdumpline( gchar *line )\r\n{\r\nint i, j;\r\nwhile (*line && !g_ascii_isalnum(*line))\r\nline++;\r\nfor (j=0; j<4; j++) {\r\nfor (i=0; i<8; i++, line++)\r\nif (! g_ascii_isxdigit(*line))\r\nreturn FALSE;\r\nfor (i=0; i<3; i++, line++)\r\nif (*line != ' ')\r\nreturn FALSE;\r\n}\r\nreturn g_ascii_isspace(*line);\r\n}\r\nstatic gboolean\r\nparse_vms_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nchar line[VMS_LINE_LENGTH + 1];\r\nint num_items_scanned;\r\nint pkt_len = 0;\r\nint pktnum;\r\nint csec = 101;\r\nstruct tm tm;\r\nchar mon[4] = {'J', 'A', 'N', 0};\r\ngchar *p;\r\nstatic const gchar months[] = "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC";\r\nint i;\r\nint offset = 0;\r\nguint8 *pd;\r\ntm.tm_year = 1970;\r\ntm.tm_mon = 0;\r\ntm.tm_mday = 1;\r\ntm.tm_hour = 1;\r\ntm.tm_min = 1;\r\ntm.tm_sec = 1;\r\ndo {\r\nif (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif ((*err == 0) && (csec != 101)) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nline[VMS_LINE_LENGTH] = '\0';\r\nif ((csec == 101) && (p = strstr(line, "packet ")) != NULL\r\n&& (! strstr(line, "could not save "))) {\r\nnum_items_scanned = sscanf(p,\r\n"packet %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d",\r\n&pktnum, &tm.tm_mday, mon,\r\n&tm.tm_year, &tm.tm_hour,\r\n&tm.tm_min, &tm.tm_sec, &csec);\r\nif (num_items_scanned != 8) {\r\nnum_items_scanned = sscanf(p,\r\n"packet seq # = %9d at %2d-%3s-%4d %2d:%2d:%2d.%9d",\r\n&pktnum, &tm.tm_mday, mon,\r\n&tm.tm_year, &tm.tm_hour,\r\n&tm.tm_min, &tm.tm_sec, &csec);\r\n}\r\nif (num_items_scanned != 8) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("vms: header line not valid");\r\nreturn FALSE;\r\n}\r\n}\r\nif ( (! pkt_len) && (p = strstr(line, "Length"))) {\r\np += sizeof("Length ");\r\nwhile (*p && ! g_ascii_isdigit(*p))\r\np++;\r\nif ( !*p ) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("vms: Length field not valid");\r\nreturn FALSE;\r\n}\r\npkt_len = atoi(p);\r\nbreak;\r\n}\r\n} while (! isdumpline(line));\r\nif (pkt_len > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("vms: File has %u-byte packet, bigger than maximum of %u",\r\npkt_len, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\np = strstr(months, mon);\r\nif (p)\r\ntm.tm_mon = (int) (p - months) / 3;\r\ntm.tm_year -= 1900;\r\ntm.tm_isdst = -1;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->ts.secs = mktime(&tm);\r\nphdr->ts.nsecs = csec * 10000000;\r\nphdr->caplen = pkt_len;\r\nphdr->len = pkt_len;\r\nws_buffer_assure_space(buf, pkt_len);\r\npd = ws_buffer_start_ptr(buf);\r\nfor (i = 0; i < pkt_len; i += 16) {\r\nif (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nline[VMS_LINE_LENGTH] = '\0';\r\nif (i == 0) {\r\nwhile (! isdumpline(line)) {\r\nif (file_gets(line, VMS_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nline[VMS_LINE_LENGTH] = '\0';\r\n}\r\nwhile (line[offset] && !g_ascii_isxdigit(line[offset]))\r\noffset++;\r\n}\r\nif (!parse_single_hex_dump_line(line, pd, i,\r\noffset, pkt_len - i)) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("vms: hex dump not valid");\r\nreturn FALSE;\r\n}\r\n}\r\nif (!file_gets(line, VMS_LINE_LENGTH, fh)) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nparse_single_hex_dump_line(char* rec, guint8 *buf, long byte_offset,\r\nint in_off, int remaining) {\r\nint i;\r\nchar *s;\r\nint value;\r\nstatic const int offsets[16] = {39,37,35,33,28,26,24,22,17,15,13,11,6,4,2,0};\r\nchar lbuf[3] = {0,0,0};\r\ns = rec;\r\nvalue = (int)strtoul(s + 45 + in_off, NULL, 16);\r\nif (value != byte_offset) {\r\nreturn FALSE;\r\n}\r\nif (remaining > 16)\r\nremaining = 16;\r\nfor (i = 0; i < remaining; i++) {\r\nlbuf[0] = rec[offsets[i] + in_off];\r\nlbuf[1] = rec[offsets[i] + 1 + in_off];\r\nbuf[byte_offset + i] = (guint8) strtoul(lbuf, NULL, 16);\r\n}\r\nreturn TRUE;\r\n}
