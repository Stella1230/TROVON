static int\r\ndissect_tacacs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *tacacs_tree;\r\nproto_item *ti;\r\nguint8 version,type,userlen,passlen;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TACACS");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nversion = tvb_get_guint8(tvb,0);\r\nif (version != 0) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "XTACACS");\r\n}\r\ntype = tvb_get_guint8(tvb,1);\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(type, tacacs_type_vals, "Unknown (0x%02x)"));\r\nif (tree)\r\n{\r\nti = proto_tree_add_protocol_format(tree, proto_tacacs,\r\ntvb, 0, -1, version==0?"TACACS":"XTACACS");\r\ntacacs_tree = proto_item_add_subtree(ti, ett_tacacs);\r\nproto_tree_add_uint(tacacs_tree, hf_tacacs_version, tvb, 0, 1, version);\r\nproto_tree_add_uint(tacacs_tree, hf_tacacs_type, tvb, 1, 1, type);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_nonce, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nif (version==0)\r\n{\r\nif (type!=TACACS_RESPONSE)\r\n{\r\nuserlen=tvb_get_guint8(tvb,4);\r\nproto_tree_add_uint(tacacs_tree, hf_tacacs_userlen, tvb, 4, 1, userlen);\r\npasslen=tvb_get_guint8(tvb,5);\r\nproto_tree_add_uint(tacacs_tree, hf_tacacs_passlen, tvb, 5, 1, passlen);\r\nproto_tree_add_item(tree, hf_tacacs_username, tvb, 6, userlen, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(tree, hf_tacacs_password, tvb, 6+userlen, passlen, ENC_ASCII|ENC_NA);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_response, tvb, 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_reason, tvb, 5, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nelse\r\n{\r\nuserlen=tvb_get_guint8(tvb,4);\r\nproto_tree_add_uint(tacacs_tree, hf_tacacs_userlen, tvb, 4, 1, userlen);\r\npasslen=tvb_get_guint8(tvb,5);\r\nproto_tree_add_uint(tacacs_tree, hf_tacacs_passlen, tvb, 5, 1, passlen);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_response, tvb, 6, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_reason, tvb, 7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_result1, tvb, 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_destaddr, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_destport, tvb, 16, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_line, tvb, 18, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_result2, tvb, 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tacacs_tree, hf_tacacs_result3, tvb, 24, 2, ENC_BIG_ENDIAN);\r\nif (type!=TACACS_RESPONSE)\r\n{\r\nproto_tree_add_item(tree, hf_tacacs_username, tvb, 26, userlen, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(tree, hf_tacacs_password, tvb, 26+userlen, passlen, ENC_ASCII|ENC_NA);\r\n}\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_tacacs(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tacacs_version,\r\n{ "Version", "tacacs.version",\r\nFT_UINT8, BASE_HEX, VALS(tacacs_version_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_type,\r\n{ "Type", "tacacs.type",\r\nFT_UINT8, BASE_DEC, VALS(tacacs_type_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_nonce,\r\n{ "Nonce", "tacacs.nonce",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_userlen,\r\n{ "Username length", "tacacs.userlen",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_passlen,\r\n{ "Password length", "tacacs.passlen",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_response,\r\n{ "Response", "tacacs.response",\r\nFT_UINT8, BASE_DEC, VALS(tacacs_resp_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_reason,\r\n{ "Reason", "tacacs.reason",\r\nFT_UINT8, BASE_DEC, VALS(tacacs_reason_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_result1,\r\n{ "Result 1", "tacacs.result1",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_destaddr,\r\n{ "Destination address", "tacacs.destaddr",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_destport,\r\n{ "Destination port", "tacacs.destport",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_line,\r\n{ "Line", "tacacs.line",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_result2,\r\n{ "Result 2", "tacacs.result2",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_result3,\r\n{ "Result 3", "tacacs.result3",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_username,\r\n{ "Username", "tacacs.username",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacacs_password,\r\n{ "Password", "tacacs.password",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tacacs,\r\n};\r\nproto_tacacs = proto_register_protocol("TACACS", "TACACS", "tacacs");\r\nproto_register_field_array(proto_tacacs, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_tacacs(void)\r\n{\r\ndissector_handle_t tacacs_handle;\r\ntacacs_handle = create_dissector_handle(dissect_tacacs, proto_tacacs);\r\ndissector_add_uint("udp.port", UDP_PORT_TACACS, tacacs_handle);\r\n}\r\nstatic gint\r\ntacplus_decrypted_tvb_setup( tvbuff_t *tvb, tvbuff_t **dst_tvb, packet_info *pinfo, guint32 len, guint8 version, const char *key )\r\n{\r\nguint8 *buff;\r\nguint8 session_id[4];\r\ntvb_memcpy(tvb, session_id, 4,4);\r\nbuff = (guint8 *)tvb_memdup(pinfo->pool, tvb, TAC_PLUS_HDR_SIZE, len);\r\nmd5_xor( buff, key, len, session_id,version, tvb_get_guint8(tvb,2) );\r\n*dst_tvb = tvb_new_child_real_data(tvb, buff, len, len );\r\nadd_new_data_source(pinfo, *dst_tvb, "TACACS+ Decrypted");\r\nreturn 0;\r\n}\r\nstatic void\r\ndissect_tacplus_args_list( tvbuff_t *tvb, proto_tree *tree, int data_off, int len_off, int arg_cnt )\r\n{\r\nint i;\r\nint len;\r\nguint8 *value;\r\nfor(i=0;i<arg_cnt;i++){\r\nlen=tvb_get_guint8(tvb,len_off+i);\r\nproto_tree_add_uint_format(tree, hf_tacplus_arg_length, tvb, len_off+i, 1, len,\r\n"Arg[%d] length: %d", i, len);\r\nvalue=tvb_get_string_enc(wmem_packet_scope(), tvb, data_off, len, ENC_ASCII|ENC_NA);\r\nproto_tree_add_string_format(tree, hf_tacplus_arg_value, tvb, data_off, len, value,\r\n"Arg[%d] value: %s", i, value);\r\ndata_off+=len;\r\n}\r\n}\r\nstatic int\r\nproto_tree_add_tacplus_common_fields( tvbuff_t *tvb, proto_tree *tree, int offset, int var_off )\r\n{\r\nint val;\r\nproto_tree_add_item(tree, hf_tacplus_privilege_level, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_tacplus_authentication_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_tacplus_service, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nval=tvb_get_guint8(tvb,offset);\r\nproto_tree_add_uint(tree, hf_tacplus_user_len, tvb, offset, 1, val);\r\nif( val ){\r\nproto_tree_add_item(tree, hf_tacplus_user, tvb, var_off, val, ENC_ASCII|ENC_NA);\r\nvar_off+=val;\r\n}\r\noffset++;\r\nval=tvb_get_guint8(tvb,offset);\r\nproto_tree_add_uint(tree, hf_tacplus_port_len, tvb, offset, 1, val);\r\nif( val ){\r\nproto_tree_add_item(tree, hf_tacplus_port, tvb, var_off, val, ENC_ASCII|ENC_NA);\r\nvar_off+=val;\r\n}\r\noffset++;\r\nval=tvb_get_guint8(tvb,offset);\r\nproto_tree_add_uint(tree, hf_tacplus_remote_address_len, tvb, offset, 1, val);\r\nif( val ){\r\nproto_tree_add_item(tree, hf_tacplus_remote_address, tvb, var_off, val, ENC_ASCII|ENC_NA);\r\nvar_off+=val;\r\n}\r\nreturn var_off;\r\n}\r\nstatic void\r\ndissect_tacplus_body_authen_req_login( tvbuff_t* tvb, proto_tree *tree, int var_off )\r\n{\r\nguint8 val;\r\nval=tvb_get_guint8( tvb, AUTHEN_S_DATA_LEN_OFF );\r\nswitch ( tvb_get_guint8(tvb, AUTHEN_S_AUTHEN_TYPE_OFF ) ) {\r\ncase TAC_PLUS_AUTHEN_TYPE_ASCII:\r\nproto_tree_add_item(tree, hf_tacplus_ascii_length, tvb, AUTHEN_S_DATA_LEN_OFF, 1, ENC_BIG_ENDIAN);\r\nif( val )\r\nproto_tree_add_item( tree, hf_tacplus_data, tvb, var_off, val, ENC_NA);\r\nbreak;\r\ncase TAC_PLUS_AUTHEN_TYPE_PAP:\r\nproto_tree_add_item(tree, hf_tacplus_password_length, tvb, AUTHEN_S_DATA_LEN_OFF, 1, ENC_BIG_ENDIAN);\r\nif( val ) {\r\nproto_tree_add_item(tree, hf_tacplus_auth_password, tvb, var_off, val, ENC_ASCII|ENC_NA);\r\n}\r\nbreak;\r\ncase TAC_PLUS_AUTHEN_TYPE_CHAP:\r\nproto_tree_add_item(tree, hf_tacplus_chap_data_length, tvb, AUTHEN_S_DATA_LEN_OFF, 1, ENC_BIG_ENDIAN);\r\nif( val ) {\r\nproto_tree *pt;\r\nguint8 chal_len=val-(1+16);\r\npt = proto_tree_add_subtree(tree, tvb, var_off, val, ett_tacplus_body_chap, NULL, "CHAP Data" );\r\nproto_tree_add_item(pt, hf_tacplus_chap_id, tvb, var_off, 1, ENC_BIG_ENDIAN);\r\nvar_off++;\r\nproto_tree_add_item(pt, hf_tacplus_chap_challenge, tvb, var_off, chal_len, ENC_ASCII|ENC_NA);\r\nvar_off+=chal_len;\r\nproto_tree_add_item(pt, hf_tacplus_chap_response, tvb, var_off, 16, ENC_ASCII|ENC_NA);\r\n}\r\nbreak;\r\ncase TAC_PLUS_AUTHEN_TYPE_MSCHAP:\r\nproto_tree_add_item(tree, hf_tacplus_mschap_data_length, tvb, AUTHEN_S_DATA_LEN_OFF, 1, ENC_BIG_ENDIAN);\r\nif( val ) {\r\nproto_tree *pt;\r\nguint8 chal_len=val-(1+49);\r\npt = proto_tree_add_subtree(tree, tvb, var_off, val, ett_tacplus_body_chap, NULL, "MSCHAP Data" );\r\nproto_tree_add_item(pt, hf_tacplus_mschap_id, tvb, var_off, 1, ENC_BIG_ENDIAN);\r\nvar_off++;\r\nproto_tree_add_item(pt, hf_tacplus_mschap_challenge, tvb, var_off, chal_len, ENC_ASCII|ENC_NA);\r\nvar_off+=chal_len;\r\nproto_tree_add_item(pt, hf_tacplus_mschap_response, tvb, var_off, 49, ENC_ASCII|ENC_NA);\r\n}\r\nbreak;\r\ncase TAC_PLUS_AUTHEN_TYPE_ARAP:\r\nproto_tree_add_item(tree, hf_tacplus_arap_data_length, tvb, AUTHEN_S_DATA_LEN_OFF, 1, ENC_BIG_ENDIAN);\r\nif( val ) {\r\nproto_tree *pt;\r\npt = proto_tree_add_subtree(tree, tvb, var_off, val, ett_tacplus_body_chap, NULL, "ARAP Data" );\r\nproto_tree_add_item(pt, hf_tacplus_arap_nas_challenge, tvb, var_off, 8, ENC_ASCII|ENC_NA);\r\nvar_off+=8;\r\nproto_tree_add_item(pt, hf_tacplus_arap_remote_challenge, tvb, var_off, 8, ENC_ASCII|ENC_NA);\r\nvar_off+=8;\r\nproto_tree_add_item(pt, hf_tacplus_arap_remote_response, tvb, var_off, 8, ENC_ASCII|ENC_NA);\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_tacplus_data_length, tvb, AUTHEN_S_DATA_LEN_OFF, 1, ENC_BIG_ENDIAN);\r\nif( val ){\r\nproto_tree_add_item( tree, hf_tacplus_data, tvb, var_off, val, ENC_NA);\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_tacplus_body_authen_req( tvbuff_t* tvb, proto_tree *tree )\r\n{\r\nguint8 val;\r\nint var_off=AUTHEN_S_VARDATA_OFF;\r\nval=tvb_get_guint8( tvb, AUTHEN_S_ACTION_OFF );\r\nproto_tree_add_item(tree, hf_tacplus_authen_action, tvb, AUTHEN_S_ACTION_OFF, 1, ENC_BIG_ENDIAN);\r\nvar_off=proto_tree_add_tacplus_common_fields( tvb, tree , AUTHEN_S_PRIV_LVL_OFF, AUTHEN_S_VARDATA_OFF );\r\nswitch( val ) {\r\ncase TAC_PLUS_AUTHEN_LOGIN:\r\ndissect_tacplus_body_authen_req_login( tvb, tree, var_off );\r\nbreak;\r\ncase TAC_PLUS_AUTHEN_SENDAUTH:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndissect_tacplus_body_authen_req_cont( tvbuff_t *tvb, proto_tree *tree )\r\n{\r\nint val;\r\nint var_off=AUTHEN_C_VARDATA_OFF;\r\nproto_item* ti;\r\nval=tvb_get_guint8( tvb, AUTHEN_C_FLAGS_OFF );\r\nti = proto_tree_add_item(tree, hf_tacplus_body_authen_req_cont_flags, tvb, AUTHEN_C_FLAGS_OFF, 1, ENC_BIG_ENDIAN);\r\nif (val&TAC_PLUS_CONTINUE_FLAG_ABORT)\r\nproto_item_append_text(ti, "(Abort)");\r\nval=tvb_get_ntohs( tvb, AUTHEN_C_USER_LEN_OFF );\r\nproto_tree_add_uint(tree, hf_tacplus_body_authen_req_cont_user_length, tvb, AUTHEN_C_USER_LEN_OFF, 2, val);\r\nif( val ){\r\nproto_tree_add_item(tree, hf_tacplus_body_authen_req_cont_user, tvb, var_off, val, ENC_ASCII|ENC_NA);\r\nvar_off+=val;\r\n}\r\nval=tvb_get_ntohs( tvb, AUTHEN_C_DATA_LEN_OFF );\r\nproto_tree_add_uint(tree, hf_tacplus_body_authen_req_cont_data_length, tvb, AUTHEN_C_DATA_LEN_OFF, 2, val);\r\nif( val ){\r\nproto_tree_add_item( tree, hf_tacplus_data, tvb, var_off, val, ENC_NA );\r\n}\r\n}\r\nstatic void\r\ndissect_tacplus_body_authen_rep( tvbuff_t *tvb, proto_tree *tree )\r\n{\r\nint val;\r\nint var_off=AUTHEN_R_VARDATA_OFF;\r\nproto_item* ti;\r\nproto_tree_add_item(tree, hf_tacplus_body_authen_rep_status, tvb, AUTHEN_R_STATUS_OFF, 1, ENC_BIG_ENDIAN);\r\nval=tvb_get_guint8( tvb, AUTHEN_R_FLAGS_OFF );\r\nti = proto_tree_add_item(tree, hf_tacplus_body_authen_rep_flags, tvb, AUTHEN_R_FLAGS_OFF, 1, ENC_BIG_ENDIAN);\r\nif (val&TAC_PLUS_REPLY_FLAG_NOECHO)\r\nproto_item_append_text(ti, "(NoEcho)");\r\nval=tvb_get_ntohs(tvb, AUTHEN_R_SRV_MSG_LEN_OFF );\r\nproto_tree_add_uint(tree, hf_tacplus_body_authen_rep_server_msg_len, tvb, AUTHEN_R_SRV_MSG_LEN_OFF, 2, val);\r\nif( val ) {\r\nproto_tree_add_item(tree, hf_tacplus_body_authen_rep_server_msg, tvb, var_off, val, ENC_ASCII|ENC_NA);\r\nvar_off+=val;\r\n}\r\nval=tvb_get_ntohs(tvb, AUTHEN_R_DATA_LEN_OFF );\r\nproto_tree_add_uint(tree, hf_tacplus_body_authen_rep_server_data_len, tvb, AUTHEN_R_DATA_LEN_OFF, 2, val);\r\nif( val ){\r\nproto_tree_add_item(tree, hf_tacplus_data, tvb, var_off, val, ENC_NA );\r\n}\r\n}\r\nstatic void\r\ndissect_tacplus_body_author_req( tvbuff_t* tvb, proto_tree *tree )\r\n{\r\nint val;\r\nint var_off;\r\nproto_tree_add_item(tree, hf_tacplus_body_author_req_auth_method, tvb, AUTHOR_Q_AUTH_METH_OFF, 1, ENC_BIG_ENDIAN);\r\nval = tvb_get_guint8( tvb, AUTHOR_Q_ARGC_OFF );\r\nvar_off=proto_tree_add_tacplus_common_fields( tvb, tree ,\r\nAUTHOR_Q_PRIV_LVL_OFF,\r\nAUTHOR_Q_VARDATA_OFF + val);\r\nproto_tree_add_item(tree, hf_tacplus_body_author_req_arg_count, tvb, AUTHOR_Q_ARGC_OFF, 1, ENC_BIG_ENDIAN);\r\ndissect_tacplus_args_list( tvb, tree, var_off, AUTHOR_Q_VARDATA_OFF, val );\r\n}\r\nstatic void\r\ndissect_tacplus_body_author_rep( tvbuff_t* tvb, proto_tree *tree )\r\n{\r\nint offset=AUTHOR_R_VARDATA_OFF;\r\nint val;\r\nproto_tree_add_item(tree, hf_tacplus_body_author_rep_auth_status, tvb, AUTHOR_R_STATUS_OFF, 1, ENC_BIG_ENDIAN);\r\nval=tvb_get_ntohs( tvb, AUTHOR_R_SRV_MSG_LEN_OFF );\r\noffset+=val;\r\nproto_tree_add_item(tree, hf_tacplus_body_author_rep_server_msg_len, tvb, AUTHOR_R_SRV_MSG_LEN_OFF, 2, ENC_BIG_ENDIAN);\r\nval=tvb_get_ntohs( tvb, AUTHOR_R_DATA_LEN_OFF );\r\noffset+=val;\r\nproto_tree_add_item(tree, hf_tacplus_body_author_rep_server_data_len, tvb, AUTHOR_R_DATA_LEN_OFF, 2, ENC_BIG_ENDIAN);\r\nval=tvb_get_guint8( tvb, AUTHOR_R_ARGC_OFF);\r\noffset+=val;\r\nproto_tree_add_item(tree, hf_tacplus_body_author_rep_arg_count, tvb, AUTHOR_R_ARGC_OFF, 1, ENC_BIG_ENDIAN);\r\ndissect_tacplus_args_list( tvb, tree, offset, AUTHOR_R_VARDATA_OFF, val );\r\n}\r\nstatic void\r\ndissect_tacplus_body_acct_req( tvbuff_t* tvb, proto_tree *tree )\r\n{\r\nint val, var_off;\r\nproto_item *tf;\r\nproto_tree *flags_tree;\r\ntf = proto_tree_add_item( tree, hf_tacplus_acct_flags, tvb, ACCT_Q_FLAGS_OFF, 1, ENC_BIG_ENDIAN);\r\nflags_tree = proto_item_add_subtree( tf, ett_tacplus_acct_flags );\r\nproto_tree_add_item(flags_tree, hf_tacplus_acct_flags_more, tvb, ACCT_Q_FLAGS_OFF, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_tacplus_acct_flags_start, tvb, ACCT_Q_FLAGS_OFF, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_tacplus_acct_flags_stop, tvb, ACCT_Q_FLAGS_OFF, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(flags_tree, hf_tacplus_acct_flags_watchdog, tvb, ACCT_Q_FLAGS_OFF, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_tacplus_acct_authen_method, tvb, ACCT_Q_METHOD_OFF, 1, ENC_BIG_ENDIAN);\r\nval=tvb_get_guint8( tvb, ACCT_Q_ARG_CNT_OFF );\r\nvar_off=proto_tree_add_tacplus_common_fields( tvb, tree ,\r\nACCT_Q_PRIV_LVL_OFF,\r\nACCT_Q_VARDATA_OFF+val\r\n);\r\nproto_tree_add_item(tree, hf_tacplus_acct_arg_count, tvb, ACCT_Q_ARG_CNT_OFF, 1, ENC_BIG_ENDIAN);\r\ndissect_tacplus_args_list( tvb, tree, var_off, ACCT_Q_VARDATA_OFF, val );\r\n}\r\nstatic void\r\ndissect_tacplus_body_acct_rep( tvbuff_t* tvb, proto_tree *tree )\r\n{\r\nint val, var_off=ACCT_Q_VARDATA_OFF;\r\nproto_tree_add_item(tree, hf_tacplus_body_acct_status, tvb, ACCT_R_STATUS_OFF, 1, ENC_BIG_ENDIAN);\r\nval=tvb_get_ntohs( tvb, ACCT_R_SRV_MSG_LEN_OFF );\r\nproto_tree_add_item(tree, hf_tacplus_body_acct_server_msg_len, tvb, ACCT_R_SRV_MSG_LEN_OFF, 2, ENC_BIG_ENDIAN);\r\nif( val ) {\r\nproto_tree_add_item(tree, hf_tacplus_body_acct_server_msg, tvb, var_off, val, ENC_ASCII|ENC_NA);\r\nvar_off+=val;\r\n}\r\nval=tvb_get_ntohs( tvb, ACCT_R_DATA_LEN_OFF );\r\nproto_tree_add_item(tree, hf_tacplus_body_acct_data_len, tvb, ACCT_R_DATA_LEN_OFF, 2, ENC_BIG_ENDIAN);\r\nif( val ) {\r\nproto_tree_add_item(tree, hf_tacplus_body_acct_data, tvb, var_off, val, ENC_ASCII|ENC_NA);\r\n}\r\n}\r\nstatic void\r\ndissect_tacplus_body(tvbuff_t * hdr_tvb, packet_info *pinfo, tvbuff_t * tvb, proto_tree * tree )\r\n{\r\nint type = tvb_get_guint8( hdr_tvb, H_TYPE_OFF );\r\nint seq_no = tvb_get_guint8( hdr_tvb, H_SEQ_NO_OFF );\r\nswitch (type) {\r\ncase TAC_PLUS_AUTHEN:\r\nif ( seq_no & 0x01) {\r\nif ( seq_no == 1 )\r\ndissect_tacplus_body_authen_req( tvb, tree );\r\nelse\r\ndissect_tacplus_body_authen_req_cont( tvb, tree );\r\n} else {\r\ndissect_tacplus_body_authen_rep( tvb, tree );\r\n}\r\nbreak;\r\ncase TAC_PLUS_AUTHOR:\r\nif ( seq_no & 0x01)\r\ndissect_tacplus_body_author_req( tvb, tree );\r\nelse\r\ndissect_tacplus_body_author_rep( tvb, tree );\r\nbreak;\r\ncase TAC_PLUS_ACCT:\r\nif ( seq_no & 0x01)\r\ndissect_tacplus_body_acct_req( tvb, tree );\r\nelse\r\ndissect_tacplus_body_acct_rep( tvb, tree );\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert( tree, pinfo, &ei_tacplus_bogus_data, tvb, 0, -1);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ntacplus_print_key_entry( gpointer data, gpointer user_data )\r\n{\r\ntacplus_key_entry *tacplus_data=(tacplus_key_entry *)data;\r\ngchar *s_str, *c_str;\r\ns_str = address_to_str( NULL, tacplus_data->s );\r\nc_str = address_to_str( NULL, tacplus_data->c );\r\nif( user_data ) {\r\nprintf("%s:%s=%s\n", s_str, c_str, tacplus_data->k );\r\n} else {\r\nprintf("%s:%s\n", s_str, c_str );\r\n}\r\nwmem_free(NULL, s_str);\r\nwmem_free(NULL, c_str);\r\n}\r\nstatic int\r\ncmp_conv_address( gconstpointer p1, gconstpointer p2 )\r\n{\r\nconst tacplus_key_entry *a1=(const tacplus_key_entry *)p1;\r\nconst tacplus_key_entry *a2=(const tacplus_key_entry *)p2;\r\ngint32 ret;\r\nret=cmp_address( a1->s, a2->s );\r\nif( !ret ) {\r\nret=cmp_address( a1->c, a2->c );\r\n} else {\r\n}\r\nreturn ret;\r\n}\r\nstatic const char*\r\nfind_key( address *srv, address *cln )\r\n{\r\ntacplus_key_entry data;\r\nGSList *match;\r\ndata.s=srv;\r\ndata.c=cln;\r\nmatch=g_slist_find_custom( tacplus_keys, (gpointer)&data, cmp_conv_address );\r\nif( match )\r\nreturn ((tacplus_key_entry*)match->data)->k;\r\nreturn (tacplus_keys?NULL:tacplus_opt_key);\r\n}\r\nstatic void\r\nmkipv4_address( address **addr, const char *str_addr )\r\n{\r\nint ret;\r\nchar *addr_data;\r\n*addr=(address *)g_malloc( sizeof(address) );\r\naddr_data=(char *)g_malloc( 4 );\r\nret = str_to_ip(str_addr, addr_data);\r\nif (ret)\r\nset_address(*addr, AT_IPv4, 4, addr_data);\r\nelse\r\nset_address(*addr, AT_STRINGZ, (int)strlen(ADDR_INVLD)+1, ADDR_INVLD);\r\n}\r\nstatic void\r\nparse_tuple( char *key_from_option )\r\n{\r\nchar *client,*key;\r\ntacplus_key_entry *tacplus_data=(tacplus_key_entry *)g_malloc( sizeof(tacplus_key_entry) );\r\nclient=strchr(key_from_option,'/');\r\nif(!client) {\r\ng_free(tacplus_data);\r\nreturn;\r\n}\r\n*client++='\0';\r\nkey=strchr(client,'=');\r\nif(!key) {\r\ng_free(tacplus_data);\r\nreturn;\r\n}\r\n*key++='\0';\r\nmkipv4_address( &tacplus_data->s, key_from_option );\r\nmkipv4_address( &tacplus_data->c, client );\r\ntacplus_data->k=g_strdup(key);\r\ntacplus_keys = g_slist_prepend( tacplus_keys, tacplus_data );\r\n}\r\nstatic\r\nvoid\r\nparse_tacplus_keys( const char *keys_from_option )\r\n{\r\nchar *key_copy,*s,*s1;\r\nif( tacplus_keys ) {\r\ng_slist_free( tacplus_keys );\r\ntacplus_keys=NULL;\r\n}\r\nif( !strchr( keys_from_option, '/' ) ){\r\nreturn ;\r\n}\r\nkey_copy=g_strdup(keys_from_option);\r\ns=key_copy;\r\nwhile(s){\r\nif( (s1=strchr( s, ' ' )) != NULL )\r\n*s1++='\0';\r\nparse_tuple( s );\r\ns=s1;\r\n}\r\ng_free( key_copy );\r\n#ifdef DEB_TACPLUS\r\ng_slist_foreach( tacplus_keys, tacplus_print_key_entry, GINT_TO_POINTER(1) );\r\n#endif\r\n}\r\nstatic int\r\ndissect_tacplus(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ntvbuff_t *new_tvb=NULL;\r\nproto_tree *tacplus_tree, *body_tree;\r\nproto_item *ti, *hidden_item;\r\nguint8 version,flags;\r\nproto_tree *flags_tree;\r\nproto_item *tf;\r\nproto_item *tmp_pi;\r\nguint32 len;\r\ngboolean request=( pinfo->destport == TCP_PORT_TACACS );\r\nconst char *key=NULL;\r\nlen = tvb_get_ntohl(tvb, 8);\r\nif(len > (guint)tvb_captured_length_remaining(tvb, 12) &&\r\npinfo->can_desegment && tacplus_preference_desegment) {\r\npinfo->desegment_offset = 0;\r\npinfo->desegment_len = len;\r\nreturn tvb_captured_length(tvb);\r\n}\r\nif( request ) {\r\nkey=find_key( &pinfo->dst, &pinfo->src );\r\n} else {\r\nkey=find_key( &pinfo->src, &pinfo->dst );\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TACACS+");\r\ncol_add_fstr( pinfo->cinfo, COL_INFO, "%s: %s",\r\nrequest ? "Q" : "R",\r\nval_to_str(tvb_get_guint8(tvb,1), tacplus_type_vals, "Unknown (0x%02x)"));\r\nif (tree)\r\n{\r\nti = proto_tree_add_item(tree, proto_tacplus, tvb, 0, -1, ENC_NA);\r\ntacplus_tree = proto_item_add_subtree(ti, ett_tacplus);\r\nif (pinfo->match_uint == pinfo->destport)\r\n{\r\nhidden_item = proto_tree_add_boolean(tacplus_tree,\r\nhf_tacplus_request, tvb, 0, 0, TRUE);\r\n}\r\nelse\r\n{\r\nhidden_item = proto_tree_add_boolean(tacplus_tree,\r\nhf_tacplus_response, tvb, 0, 0, TRUE);\r\n}\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nversion = tvb_get_guint8(tvb,0);\r\nproto_tree_add_uint_format_value(tacplus_tree, hf_tacplus_majvers, tvb, 0, 1,\r\nversion,\r\n"%s",\r\n(version&0xf0)==0xc0?"TACACS+":"Unknown Version");\r\nproto_tree_add_uint(tacplus_tree, hf_tacplus_minvers, tvb, 0, 1,\r\nversion&0xf);\r\nproto_tree_add_item(tacplus_tree, hf_tacplus_type, tvb, 1, 1,\r\nENC_BIG_ENDIAN);\r\nproto_tree_add_item(tacplus_tree, hf_tacplus_seqno, tvb, 2, 1,\r\nENC_BIG_ENDIAN);\r\nflags = tvb_get_guint8(tvb,3);\r\ntf = proto_tree_add_uint_format_value(tacplus_tree, hf_tacplus_flags,\r\ntvb, 3, 1, flags,\r\n"0x%02x (%s payload, %s)", flags,\r\n(flags&FLAGS_UNENCRYPTED) ? "Unencrypted" : "Encrypted",\r\n(flags&FLAGS_SINGLE) ? "Single connection" : "Multiple Connections" );\r\nflags_tree = proto_item_add_subtree(tf, ett_tacplus_flags);\r\nproto_tree_add_boolean(flags_tree, hf_tacplus_flags_payload_type,\r\ntvb, 3, 1, flags);\r\nproto_tree_add_boolean(flags_tree, hf_tacplus_flags_connection_type,\r\ntvb, 3, 1, flags);\r\nproto_tree_add_item(tacplus_tree, hf_tacplus_session_id, tvb, 4, 4,\r\nENC_BIG_ENDIAN);\r\ntmp_pi = proto_tree_add_uint(tacplus_tree, hf_tacplus_packet_len, tvb, 8, 4, len);\r\nif ((gint)len < 1) {\r\nexpert_add_info_format(pinfo, tmp_pi, &ei_tacplus_packet_len_invalid, "Invalid length: %u", len);\r\n}\r\nbody_tree = proto_tree_add_subtree_format(tacplus_tree, tvb, TAC_PLUS_HDR_SIZE, len,\r\nett_tacplus_body, NULL, "%s%s", ((flags&FLAGS_UNENCRYPTED)?"":"Encrypted "), request?"Request":"Reply" );\r\nif( flags&FLAGS_UNENCRYPTED ) {\r\nnew_tvb = tvb_new_subset_length( tvb, TAC_PLUS_HDR_SIZE, len );\r\n} else {\r\nnew_tvb=NULL;\r\nif( key && *key ){\r\ntacplus_decrypted_tvb_setup( tvb, &new_tvb, pinfo, len, version, key );\r\n}\r\n}\r\nif( new_tvb ) {\r\nif( !(flags&FLAGS_UNENCRYPTED) ){\r\nbody_tree = proto_tree_add_subtree_format(tacplus_tree, new_tvb, 0, len,\r\nett_tacplus_body, NULL, "Decrypted %s", request?"Request":"Reply" );\r\n}\r\ndissect_tacplus_body( tvb, pinfo, new_tvb, body_tree);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ntacplus_pref_cb(void)\r\n{\r\nparse_tacplus_keys( tacplus_opt_key );\r\n}\r\nvoid\r\nproto_register_tacplus(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tacplus_response,\r\n{ "Response", "tacplus.response",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if TACACS+ response", HFILL }},\r\n{ &hf_tacplus_request,\r\n{ "Request", "tacplus.request",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"TRUE if TACACS+ request", HFILL }},\r\n{ &hf_tacplus_majvers,\r\n{ "Major version", "tacplus.majvers",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Major version number", HFILL }},\r\n{ &hf_tacplus_minvers,\r\n{ "Minor version", "tacplus.minvers",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Minor version number", HFILL }},\r\n{ &hf_tacplus_type,\r\n{ "Type", "tacplus.type",\r\nFT_UINT8, BASE_DEC, VALS(tacplus_type_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_seqno,\r\n{ "Sequence number", "tacplus.seqno",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_flags,\r\n{ "Flags", "tacplus.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_flags_payload_type,\r\n{ "Unencrypted", "tacplus.flags.unencrypted",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), FLAGS_UNENCRYPTED,\r\n"Is payload unencrypted?", HFILL }},\r\n{ &hf_tacplus_flags_connection_type,\r\n{ "Single Connection", "tacplus.flags.singleconn",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), FLAGS_SINGLE,\r\n"Is this a single connection?", HFILL }},\r\n{ &hf_tacplus_acct_flags,\r\n{ "Flags", "tacplus.acct.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_acct_flags_more,\r\n{ "More", "tacplus.acct.flags.more",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), TAC_PLUS_ACCT_FLAG_MORE,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_acct_flags_start,\r\n{ "Start", "tacplus.acct.flags.start",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), TAC_PLUS_ACCT_FLAG_START,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_acct_flags_stop,\r\n{ "Stop", "tacplus.acct.flags.stop",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), TAC_PLUS_ACCT_FLAG_STOP,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_acct_flags_watchdog,\r\n{ "Watchdog", "tacplus.acct.flags.watchdog",\r\nFT_BOOLEAN, 8, TFS(&tfs_set_notset), TAC_PLUS_ACCT_FLAG_WATCHDOG,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_session_id,\r\n{ "Session ID", "tacplus.session_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_packet_len,\r\n{ "Packet length", "tacplus.packet_len",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_auth_password,\r\n{ "Password", "tacplus.auth_password",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_port,\r\n{ "Port", "tacplus.port",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_remote_address,\r\n{ "Remote Address", "tacplus.remote_address",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_chap_challenge,\r\n{ "Challenge", "tacplus.chap.challenge",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_chap_response,\r\n{ "Response", "tacplus.chap.response",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_mschap_challenge,\r\n{ "Challenge", "tacplus.mschap.challenge",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_mschap_response,\r\n{ "Response", "tacplus.mschap.response",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_arap_nas_challenge,\r\n{ "Nas Challenge", "tacplus.arap.nas_challenge",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_arap_remote_challenge,\r\n{ "Remote Challenge", "tacplus.arap.remote_challenge",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_arap_remote_response,\r\n{ "Remote Response", "tacplus.arap.remote_response",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_privilege_level,\r\n{ "Privilege Level", "tacplus.privilege_level",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_authentication_type,\r\n{ "Authentication type", "tacplus.authentication_type",\r\nFT_UINT8, BASE_DEC, VALS(tacplus_authen_type_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_service,\r\n{ "Service", "tacplus.service",\r\nFT_UINT8, BASE_DEC, VALS(tacplus_authen_service_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_user_len,\r\n{ "User len", "tacplus.user_len",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_user,\r\n{ "User", "tacplus.user",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_port_len,\r\n{ "Port len", "tacplus.port_len",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_remote_address_len,\r\n{ "Remaddr len", "tacplus.address_len",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_arg_length,\r\n{ "Length", "tacplus.arg_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_arg_value,\r\n{ "Value", "tacplus.arg_value",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_chap_id,\r\n{ "ID", "tacplus.chap.id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_mschap_id,\r\n{ "ID", "tacplus.mschap.id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_authen_action,\r\n{ "Action", "tacplus.authen_action",\r\nFT_UINT8, BASE_DEC, VALS(tacplus_authen_action_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_authen_req_cont_flags,\r\n{ "Flags", "tacplus.body_authen_req_cont.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_authen_req_cont_user_length,\r\n{ "User length", "tacplus.body_authen_req_cont.user_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_authen_req_cont_data_length,\r\n{ "Data length", "tacplus.body_authen_req_cont.data_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_authen_req_cont_user,\r\n{ "User", "tacplus.body_authen_req_cont.user",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_authen_rep_status,\r\n{ "Status", "tacplus.body_authen_rep.status",\r\nFT_UINT8, BASE_HEX, VALS(tacplus_reply_status_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_authen_rep_flags,\r\n{ "Flags", "tacplus.body_authen_rep.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_authen_rep_server_msg_len,\r\n{ "Server message length", "tacplus.body_authen_rep.server_msg_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_authen_rep_server_msg,\r\n{ "Server message", "tacplus.body_authen_rep.server_msg",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_authen_rep_server_data_len,\r\n{ "Data length", "tacplus.body_authen_rep_server.data_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_author_req_auth_method,\r\n{ "Auth Method", "tacplus.body_author_req.auth_method",\r\nFT_UINT8, BASE_HEX, VALS(tacplus_authen_method), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_author_req_arg_count,\r\n{ "Arg count", "tacplus.body_author_req.arg_count",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_author_rep_auth_status,\r\n{ "Auth Status", "tacplus.body_author_rep.auth_status",\r\nFT_UINT8, BASE_HEX, VALS(tacplus_author_status), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_author_rep_server_msg_len,\r\n{ "Server Msg length", "tacplus.body_author_rep_server.msg_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_author_rep_server_data_len,\r\n{ "Data length", "tacplus.body_author_rep_server.data_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_author_rep_arg_count,\r\n{ "Arg count", "tacplus.body_author_rep.arg_count",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_acct_authen_method,\r\n{ "Auth Method", "tacplus.acct.auth_method",\r\nFT_UINT8, BASE_HEX, VALS(tacplus_authen_method), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_acct_arg_count,\r\n{ "Arg count", "tacplus.acct.arg_count",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_acct_status,\r\n{ "Status", "tacplus.body_acct.status",\r\nFT_UINT8, BASE_HEX, VALS(tacplus_acct_status), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_acct_server_msg_len,\r\n{ "Server Msg length", "tacplus.body_acct.msg_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_acct_data_len,\r\n{ "Data length", "tacplus.body_acct.data_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_acct_server_msg,\r\n{ "Server message", "tacplus.body_acct.server_msg",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_body_acct_data,\r\n{ "Data", "tacplus.body_acct.data",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_data,\r\n{ "Data", "tacplus.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tacplus_ascii_length, { "ASCII Data Length", "tacplus.ascii_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_tacplus_password_length, { "Password Length", "tacplus.password_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_tacplus_chap_data_length, { "CHAP Data Length", "tacplus.chap_data_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_tacplus_mschap_data_length, { "MSCHAP Data Length", "tacplus.mschap_data_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_tacplus_arap_data_length, { "ARAP Data Length", "tacplus.arap_data_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_tacplus_data_length, { "Data", "tacplus.data_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tacplus,\r\n&ett_tacplus_flags,\r\n&ett_tacplus_acct_flags,\r\n&ett_tacplus_body,\r\n&ett_tacplus_body_chap,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_tacplus_packet_len_invalid, { "tacplus.packet_len.invalid", PI_PROTOCOL, PI_WARN, "Invalid length", EXPFILL }},\r\n{ &ei_tacplus_bogus_data, { "tacplus.bogus_data", PI_PROTOCOL, PI_WARN, "Bogus data", EXPFILL }},\r\n};\r\nmodule_t *tacplus_module;\r\nexpert_module_t* expert_tacplus;\r\nproto_tacplus = proto_register_protocol("TACACS+", "TACACS+", "tacplus");\r\nproto_register_field_array(proto_tacplus, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_tacplus = expert_register_protocol(proto_tacplus);\r\nexpert_register_field_array(expert_tacplus, ei, array_length(ei));\r\ntacplus_module = prefs_register_protocol (proto_tacplus, tacplus_pref_cb );\r\nprefs_register_bool_preference(tacplus_module, "desegment", "Reassemble TACACS+ messages spanning multiple TCP segments.", "Whether the TACACS+ dissector should reassemble messages spanning multiple TCP segments. To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.", &tacplus_preference_desegment);\r\nprefs_register_string_preference ( tacplus_module, "key",\r\n"TACACS+ Encryption Key", "TACACS+ Encryption Key", &tacplus_opt_key );\r\n}\r\nvoid\r\nproto_reg_handoff_tacplus(void)\r\n{\r\ndissector_handle_t tacplus_handle;\r\ntacplus_handle = create_dissector_handle(dissect_tacplus,\r\nproto_tacplus);\r\ndissector_add_uint("tcp.port", TCP_PORT_TACACS, tacplus_handle);\r\n}\r\nstatic void\r\nmd5_xor( guint8 *data, const char *key, int data_len, guint8 *session_id, guint8 version, guint8 seq_no )\r\n{\r\nint i,j;\r\nsize_t md5_len;\r\nmd5_byte_t *md5_buff;\r\nmd5_byte_t hash[MD5_LEN];\r\nmd5_byte_t *mdp;\r\nmd5_state_t mdcontext;\r\nmd5_len = 4 + strlen(key)\r\n+ sizeof(version) + sizeof(seq_no);\r\nmd5_buff = (md5_byte_t*)wmem_alloc(wmem_packet_scope(), md5_len+MD5_LEN);\r\nmdp = md5_buff;\r\nmemcpy(mdp, session_id, 4);\r\nmdp += 4 ;\r\nmemcpy(mdp, key, strlen(key));\r\nmdp += strlen(key);\r\n*mdp++ = version;\r\n*mdp++ = seq_no;\r\nmd5_init(&mdcontext);\r\nmd5_append(&mdcontext, md5_buff, md5_len);\r\nmd5_finish(&mdcontext,hash);\r\nmd5_len += MD5_LEN;\r\nfor (i = 0; i < data_len; i += 16) {\r\nfor (j = 0; j < 16; j++) {\r\nif ((i + j) >= data_len) {\r\ni = data_len+1;\r\nbreak;\r\n}\r\ndata[i + j] ^= hash[j];\r\n}\r\nmemcpy(mdp, hash, MD5_LEN);\r\nmd5_init(&mdcontext);\r\nmd5_append(&mdcontext, md5_buff, md5_len);\r\nmd5_finish(&mdcontext,hash);\r\n}\r\n}
