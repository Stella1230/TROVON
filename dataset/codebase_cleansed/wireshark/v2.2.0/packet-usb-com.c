static int\r\ndissect_usb_com_descriptor(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint8 offset = 0, type, subtype;\r\nproto_tree *subtree;\r\nproto_tree *subtree_capabilities;\r\nproto_item *subitem_capabilities;\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_usb_com, NULL, "COMMUNICATIONS DESCRIPTOR");\r\ndissect_usb_descriptor_header(subtree, tvb, offset, &usb_com_descriptor_type_vals_ext);\r\noffset += 2;\r\ntype = tvb_get_guint8(tvb, 1);\r\nswitch (type) {\r\ncase CS_INTERFACE:\r\nsubtype = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(subtree, hf_usb_com_descriptor_subtype, tvb, offset, 1, subtype);\r\noffset++;\r\nswitch (subtype) {\r\ncase 0x00:\r\nproto_tree_add_item(subtree, hf_usb_com_descriptor_cdc, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase 0x01:\r\nsubitem_capabilities = proto_tree_add_item(subtree, hf_usb_com_capabilities, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nsubtree_capabilities = proto_item_add_subtree(subitem_capabilities, ett_usb_com_capabilities);\r\nproto_tree_add_item(subtree_capabilities, hf_usb_com_descriptor_cm_capabilities_reserved, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree_capabilities, hf_usb_com_descriptor_cm_capabilities_call_management_over_data_class_interface, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree_capabilities, hf_usb_com_descriptor_cm_capabilities_call_management, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_usb_com_descriptor_cm_data_interface, tvb, 4, 1, ENC_LITTLE_ENDIAN);\r\noffset = 5;\r\nbreak;\r\ncase 0x02:\r\nsubitem_capabilities = proto_tree_add_item(subtree, hf_usb_com_capabilities, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nsubtree_capabilities = proto_item_add_subtree(subitem_capabilities, ett_usb_com_capabilities);\r\nproto_tree_add_item(subtree_capabilities, hf_usb_com_descriptor_acm_capabilities_reserved, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree_capabilities, hf_usb_com_descriptor_acm_capabilities_network_connection, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree_capabilities, hf_usb_com_descriptor_acm_capabilities_send_break, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree_capabilities, hf_usb_com_descriptor_acm_capabilities_line_and_state, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree_capabilities, hf_usb_com_descriptor_acm_capabilities_comm_features, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\noffset = 4;\r\nbreak;\r\ncase 0x06:\r\noffset = 3;\r\nproto_tree_add_item(subtree, hf_usb_com_descriptor_control_interface, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nwhile (tvb_reported_length_remaining(tvb,offset) > 0) {\r\nproto_tree_add_item(subtree, hf_usb_com_descriptor_subordinate_interface, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\n}\r\nbreak;\r\ncase 0x0f:\r\nproto_tree_add_item(subtree, hf_usb_com_descriptor_ecm_mac_address, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_bitmask_with_flags(subtree, tvb, offset, hf_usb_com_descriptor_ecm_eth_stats,\r\nett_usb_com_descriptor_ecm_eth_stats, ecm_eth_stats,\r\nENC_LITTLE_ENDIAN, BMT_NO_APPEND);\r\noffset += 4;\r\nproto_tree_add_item(subtree, hf_usb_com_descriptor_ecm_max_segment_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_bitmask_with_flags(subtree, tvb, offset, hf_usb_com_descriptor_ecm_nb_mc_filters,\r\nett_usb_com_descriptor_ecm_nb_mc_filters, ecm_nb_mc_filters,\r\nENC_LITTLE_ENDIAN, BMT_NO_APPEND);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_usb_com_descriptor_ecm_nb_power_filters, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nbreak;\r\ncase 0x1b:\r\ncase 0x1c:\r\noffset = call_dissector_only(mbim_descriptor_handle, tvb, pinfo, subtree, data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase CS_ENDPOINT:\r\ndefault:\r\nbreak;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_item(subtree, hf_usb_com_descriptor_payload, tvb, offset, -1, ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_usb_com_get_ntb_params(tvbuff_t *tvb, proto_tree *tree, gint base_offset)\r\n{\r\ngint offset = base_offset;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_bitmask(tree, tvb, offset, hf_usb_com_get_ntb_params_ntb_formats_supported, ett_usb_com_bitmap,\r\nusb_com_get_ntb_params_ntb_formats_supported_fields, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_ntb_in_max_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_ndp_in_divisor, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_ndp_in_payload_remainder, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_ndp_in_alignment, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_ntb_out_max_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_ndp_out_divisor, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_ndp_out_payload_remainder, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_ndp_out_alignment, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_usb_com_get_ntb_params_ntb_out_max_datagrams, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_com_ntb_input_size(tvbuff_t *tvb, proto_tree *tree, gint base_offset, gboolean is_set)\r\n{\r\ngint offset = base_offset;\r\nproto_tree_add_item(tree, is_set ? hf_usb_com_set_ntb_input_size_ntb_in_max_size :\r\nhf_usb_com_get_ntb_input_size_ntb_in_max_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_item(tree, is_set ? hf_usb_com_set_ntb_input_size_ntb_in_max_datagrams :\r\nhf_usb_com_get_ntb_input_size_ntb_in_max_datagrams, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, is_set ? hf_usb_com_set_ntb_input_size_reserved :\r\nhf_usb_com_get_ntb_input_size_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_usb_com_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nusb_conv_info_t *usb_conv_info = (usb_conv_info_t *)data;\r\nusb_trans_info_t *usb_trans_info;\r\nproto_tree *subtree;\r\nproto_item *ti;\r\ngint offset = 0;\r\ngboolean is_request;\r\nif (tvb_reported_length(tvb) == 0) {\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "USBCOM");\r\nti = proto_tree_add_item(tree, proto_usb_com, tvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_usb_com);\r\nif (usb_conv_info) {\r\nusb_trans_info = usb_conv_info->usb_trans_info;\r\nti = proto_tree_add_uint(subtree, hf_usb_com_control_subclass, tvb, 0, 0,\r\nusb_conv_info->interfaceSubclass);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nis_request = (pinfo->srcport==NO_ENDPOINT);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s %s",\r\nval_to_str_ext(usb_trans_info->setup.request, &usb_com_setup_request_vals_ext, "Unknown type %x"),\r\nis_request ? "Request" : "Response");\r\nif (is_request) {\r\nproto_tree_add_item(subtree, hf_usb_com_control_request_code, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(subtree, hf_usb_com_control_value, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_usb_com_control_index, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_usb_com_control_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n} else {\r\nti = proto_tree_add_uint(subtree, hf_usb_com_control_response_code, tvb, 0, 0,\r\nusb_trans_info->setup.request);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\nswitch (usb_trans_info->setup.request)\r\n{\r\ncase SEND_ENCAPSULATED_COMMAND:\r\nif ((usb_conv_info->interfaceSubclass == COM_SUBCLASS_MBIM) &&\r\n(USB_HEADER_IS_LINUX(usb_trans_info->header_type))) {\r\noffset = call_dissector_only(mbim_control_handle, tvb, pinfo, tree, usb_conv_info);\r\nbreak;\r\n}\r\ncase GET_ENCAPSULATED_RESPONSE:\r\nif ((usb_conv_info->interfaceSubclass == COM_SUBCLASS_MBIM) && !is_request) {\r\noffset = call_dissector_only(mbim_control_handle, tvb, pinfo, tree, usb_conv_info);\r\n}\r\nbreak;\r\ncase GET_NTB_PARAMETERS:\r\nif (!is_request) {\r\noffset = dissect_usb_com_get_ntb_params(tvb, subtree, offset);\r\n}\r\nbreak;\r\ncase GET_NET_ADDRESS:\r\nif (!is_request) {\r\nproto_tree_add_item(subtree, hf_usb_com_get_net_address_eui48, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\n}\r\nbreak;\r\ncase SET_NET_ADDRESS:\r\nif (is_request) {\r\nproto_tree_add_item(subtree, hf_usb_com_set_net_address_eui48, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\n}\r\nbreak;\r\ncase GET_NTB_FORMAT:\r\nif (!is_request) {\r\nproto_tree_add_item(subtree, hf_usb_com_get_ntb_format_ntb_format, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nbreak;\r\ncase SET_NTB_FORMAT:\r\nif (is_request) {\r\nproto_tree_add_item(subtree, hf_usb_com_set_ntb_format_ntb_format, tvb, offset-6, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nbreak;\r\ncase GET_NTB_INPUT_SIZE:\r\nif (!is_request) {\r\noffset = dissect_usb_com_ntb_input_size(tvb, subtree, offset, FALSE);\r\n}\r\nbreak;\r\ncase SET_NTB_INPUT_SIZE:\r\nif (!is_request) {\r\noffset = dissect_usb_com_ntb_input_size(tvb, subtree, offset, TRUE);\r\n}\r\nbreak;\r\ncase GET_MAX_DATAGRAM_SIZE:\r\nif (!is_request) {\r\nproto_tree_add_item(subtree, hf_usb_com_get_max_datagram_size_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nbreak;\r\ncase SET_MAX_DATAGRAM_SIZE:\r\nif (is_request) {\r\nproto_tree_add_item(subtree, hf_usb_com_set_max_datagram_size_size, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nbreak;\r\ncase GET_CRC_MODE:\r\nif (!is_request) {\r\nproto_tree_add_item(subtree, hf_usb_com_get_crc_mode_crc_mode, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nbreak;\r\ncase SET_CRC_MODE:\r\nif (is_request) {\r\nproto_tree_add_item(subtree, hf_usb_com_set_crc_mode_crc_mode, tvb, offset-6, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_item(subtree, hf_usb_com_control_payload, tvb, offset, -1, ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_usb_com_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nusb_conv_info_t *usb_conv_info = (usb_conv_info_t *)data;\r\nif (usb_conv_info) {\r\nswitch (usb_conv_info->interfaceProtocol)\r\n{\r\ncase 0x01:\r\ncase 0x02:\r\nreturn call_dissector_only(mbim_bulk_handle, tvb, pinfo, tree, NULL);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn call_dissector_only(eth_withoutfcs_handle, tvb, pinfo, tree, NULL);\r\n}\r\nstatic int\r\ndissect_usb_com_interrupt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *subtree;\r\nproto_item *it;\r\nguint32 notif_code;\r\ngint offset = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "USBCOM");\r\nit = proto_tree_add_item(tree, proto_usb_com, tvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(it, ett_usb_com);\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_request_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset++;\r\nproto_tree_add_item_ret_uint(subtree, hf_usb_com_interrupt_notif_code, tvb, offset, 1, ENC_LITTLE_ENDIAN, &notif_code);\r\noffset++;\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s", val_to_str(notif_code, usb_com_interrupt_notif_code_vals, "Unknown type %x"));\r\nswitch (notif_code) {\r\ncase NETWORK_CONNECTION:\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_value_nw_conn, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_index, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase RESPONSE_AVAILABLE:\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_value, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_index, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase CONNECTION_SPEED_CHANGE:\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_value, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_index, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_length, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nit = proto_tree_add_item(subtree, hf_usb_com_interrupt_dl_bitrate, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(it, " b/s");\r\noffset += 4;\r\nit = proto_tree_add_item(subtree, hf_usb_com_interrupt_ul_bitrate, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(it, " b/s");\r\noffset += 4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_item(subtree, hf_usb_com_interrupt_payload, tvb, offset, -1, ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_usb_com(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_usb_com_descriptor_subtype,\r\n{ "Descriptor Subtype", "usbcom.descriptor.subtype", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\r\n&usb_com_descriptor_subtype_vals_ext, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_cdc,\r\n{ "CDC", "usbcom.descriptor.cdc", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_payload,\r\n{ "Payload", "usbcom.descriptor.payload", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_control_subclass,\r\n{ "Subclass", "usbcom.control.subclass", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\r\n&ext_usb_com_subclass_vals, 0, NULL, HFILL }},\r\n{ &hf_usb_com_control_request_code,\r\n{ "Request Code", "usbcom.control.request_code", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\r\n&usb_com_setup_request_vals_ext, 0, NULL, HFILL }},\r\n{ &hf_usb_com_control_value,\r\n{ "Value", "usbcom.control.value", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_control_index,\r\n{ "Index", "usbcom.control.index", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_control_length,\r\n{ "Length", "usbcom.control.length", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_control_response_code,\r\n{ "Response Code", "usbcom.control.response_code", FT_UINT8, BASE_HEX|BASE_EXT_STRING,\r\n&usb_com_setup_request_vals_ext, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_length,\r\n{ "Length", "usbcom.control.get_ntb_params.length", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ntb_formats_supported,\r\n{ "NTB Formats Supported", "usbcom.control.get_ntb_params.ntb_formats_supported", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ntb_formats_supported_16bit,\r\n{ "16-bit NTB", "usbcom.control.get_ntb_params.ntb_formats_supported.16bit", FT_BOOLEAN, 16,\r\nTFS(&tfs_supported_not_supported), 0x0001, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ntb_formats_supported_32bit,\r\n{ "32-bit NTB", "usbcom.control.get_ntb_params.ntb_formats_supported.32bit", FT_BOOLEAN, 16,\r\nTFS(&tfs_supported_not_supported), 0x0002, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ntb_in_max_size,\r\n{ "NTB IN Max Size", "usbcom.control.get_ntb_params.ntb_in_max_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ndp_in_divisor,\r\n{ "NDP IN Divisor", "usbcom.control.get_ntb_params.ndp_in_divisor", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ndp_in_payload_remainder,\r\n{ "NDP IN Payload Remainder", "usbcom.control.get_ntb_params.ndp_in_payload_remainder", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ndp_in_alignment,\r\n{ "NDP IN Alignment", "usbcom.control.get_ntb_params.ndp_in_alignment", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_reserved,\r\n{ "Reserved", "usbcom.control.get_ntb_params.reserved", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ntb_out_max_size,\r\n{ "NTB OUT Max Size", "usbcom.control.get_ntb_params.ntb_out_max_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ndp_out_divisor,\r\n{ "NDP OUT Divisor", "usbcom.control.get_ntb_params.ndp_out_divisor", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ndp_out_payload_remainder,\r\n{ "NDP OUT Payload Remainder", "usbcom.control.get_ntb_params.ndp_out_payload_remainder", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ndp_out_alignment,\r\n{ "NDP OUT Alignment", "usbcom.control.get_ntb_params.ndp_out_alignment", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_params_ntb_out_max_datagrams,\r\n{ "NTB OUT Max Datagrams", "usbcom.control.get_ntb_params.ntb_out_max_datagrams", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_net_address_eui48,\r\n{ "EUI-48", "usbcom.control.get_net_address.eui48", FT_ETHER, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_set_net_address_eui48,\r\n{ "EUI-48", "usbcom.control.set_net_address.eui48", FT_ETHER, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_format_ntb_format,\r\n{ "NTB Format", "usbcom.control.get_net_address.ntb_format", FT_UINT16, BASE_HEX,\r\nVALS(usb_com_ntb_format_vals), 0, NULL, HFILL }},\r\n{ &hf_usb_com_set_ntb_format_ntb_format,\r\n{ "NTB Format", "usbcom.control.set_net_address.ntb_format", FT_UINT16, BASE_HEX,\r\nVALS(usb_com_ntb_format_vals), 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_input_size_ntb_in_max_size,\r\n{ "NTB IN Max Size", "usbcom.control.get_ntb_input_size.ntb_in_max_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_input_size_ntb_in_max_datagrams,\r\n{ "NTB IN Max Datagrams", "usbcom.control.get_ntb_input_size.ntb_in_max_datagrams", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_ntb_input_size_reserved,\r\n{ "Reserved", "usbcom.control.get_ntb_input_size.reserved", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_set_ntb_input_size_ntb_in_max_size,\r\n{ "NTB IN Max Size", "usbcom.control.set_ntb_input_size.ntb_in_max_size", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_set_ntb_input_size_ntb_in_max_datagrams,\r\n{ "NTB IN Max Datagrams", "usbcom.control.set_ntb_input_size.ntb_in_max_datagrams", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_set_ntb_input_size_reserved,\r\n{ "Reserved", "usbcom.control.set_ntb_input_size.reserved", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_max_datagram_size_size,\r\n{ "Max Datagram Size", "usbcom.control.get_max_datagram_size.size", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_set_max_datagram_size_size,\r\n{ "Max Datagram Size", "usbcom.control.set_max_datagram_size.size", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_get_crc_mode_crc_mode,\r\n{ "CRC Mode", "usbcom.control.get_crc_mode.crc_mode", FT_UINT16, BASE_HEX,\r\nVALS(usb_com_crc_mode_vals), 0, NULL, HFILL }},\r\n{ &hf_usb_com_set_crc_mode_crc_mode,\r\n{ "CRC Mode", "usbcom.control.set_crc_mode.crc_mode", FT_UINT16, BASE_HEX,\r\nVALS(usb_com_crc_mode_vals), 0, NULL, HFILL }},\r\n{ &hf_usb_com_control_payload,\r\n{ "Payload", "usbcom.control.payload", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_capabilities,\r\n{ "bmCapabilities", "usbcom.descriptor.capabilities", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_acm_capabilities_reserved,\r\n{ "Reserved", "usbcom.descriptor.acm.capabilities.reserved", FT_UINT8, BASE_HEX,\r\nNULL, 0xF0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_acm_capabilities_network_connection,\r\n{ "Network_Connection", "usbcom.descriptor.acm.capabilities.network_connection", FT_BOOLEAN, 8,\r\nTFS(&tfs_supported_not_supported), 0x08, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_acm_capabilities_send_break,\r\n{ "Send_Break", "usbcom.descriptor.acm.capabilities.network_connection", FT_BOOLEAN, 8,\r\nTFS(&tfs_supported_not_supported), 0x04, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_acm_capabilities_line_and_state,\r\n{ "Line Requests and State Notification", "usbcom.descriptor.acm.capabilities.line_and_state", FT_BOOLEAN, 8,\r\nTFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_acm_capabilities_comm_features,\r\n{ "Comm Features Combinations", "usbcom.descriptor.acm.capabilities.comm_features", FT_BOOLEAN, 8,\r\nTFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_control_interface,\r\n{ "Control Interface", "usbcom.descriptor.control_interface", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_subordinate_interface,\r\n{ "Subordinate Interface", "usbcom.descriptor.subordinate_interface", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_cm_capabilities_reserved,\r\n{ "Reserved", "usbcom.descriptor.cm.capabilities.reserved", FT_UINT8, BASE_HEX,\r\nNULL, 0xFC, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_cm_capabilities_call_management_over_data_class_interface,\r\n{ "Call Management over Data Class Interface", "usbcom.descriptor.cm.capabilities.call_management_over_data_class_interface", FT_BOOLEAN, 8,\r\nTFS(&tfs_supported_not_supported), 0x02, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_cm_capabilities_call_management,\r\n{ "Call Management", "usbcom.descriptor.cm.capabilities.call_management", FT_BOOLEAN, 8,\r\nTFS(&tfs_supported_not_supported), 0x01, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_cm_data_interface,\r\n{ "Data Interface", "usbcom.descriptor.cm.data_interface", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_mac_address,\r\n{ "MAC Address", "usbcom.descriptor.ecm.mac_address", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats,\r\n{ "Ethernet Statistics", "usbcom.descriptor.ecm.eth_stats", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_reserved,\r\n{ "Reserved", "usbcom.descriptor.ecm.eth_stats.reserved", FT_UINT32, BASE_HEX,\r\nNULL, 0xe0000000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_late_collisions,\r\n{ "XMIT Late Collisions", "usbcom.descriptor.ecm.eth_stats.xmit_late_collisions", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x10000000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_times_crs_lost,\r\n{ "XMIT TImes CRS Lost", "usbcom.descriptor.ecm.eth_stats.xmit_times_crs_lost", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x08000000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_heartbeat_failure,\r\n{ "XMIT Heartbeat Failure", "usbcom.descriptor.ecm.eth_stats.xmit_heartbeat_failure", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x04000000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_underrun,\r\n{ "XMIT Underrun", "usbcom.descriptor.ecm.eth_stats.xmit_underrun", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x02000000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_rcv_overrun,\r\n{ "RCV Overrun", "usbcom.descriptor.ecm.eth_stats.rcv_overrun", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x01000000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_max_collisions,\r\n{ "XMIT Max Collisions", "usbcom.descriptor.ecm.eth_stats.xmit_max_collisions", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00800000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_deferred,\r\n{ "XMIT Deferred", "usbcom.descriptor.ecm.eth_stats.xmit_deferred", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00400000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_more_collisions,\r\n{ "XMIT More Collisions", "usbcom.descriptor.ecm.eth_stats.xmit_more_collisions", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00200000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_one_collision,\r\n{ "XMIT One Collision", "usbcom.descriptor.ecm.eth_stats.xmit_one_collision", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00100000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_rcv_error_alignment,\r\n{ "RCV Error Alignment", "usbcom.descriptor.ecm.eth_stats.rcv_error_alignment", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00080000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_transmit_queue_length,\r\n{ "Transmit Queue Length", "usbcom.descriptor.ecm.eth_stats.transmit_queue_length", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00040000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_rcv_crc_error,\r\n{ "RCV CRC Error", "usbcom.descriptor.ecm.eth_stats.rcv_crc_error", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00020000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_broadcast_frames_rcv,\r\n{ "Broadcast Frames RCV", "usbcom.descriptor.ecm.eth_stats.broadcast_frames_rcv", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00010000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_broadcast_bytes_rcv,\r\n{ "Broadcast Bytes RCV", "usbcom.descriptor.ecm.eth_stats.broadcast_bytes_rcv", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00008000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_multicast_frames_rcv,\r\n{ "Multicast Frames RCV", "usbcom.descriptor.ecm.eth_stats.multicast_frames_rcv", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00004000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_multicast_bytes_rcv,\r\n{ "Multicast Bytes RCV", "usbcom.descriptor.ecm.eth_stats.multicast_bytes_rcv", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00002000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_directed_frames_rcv,\r\n{ "Directed Frames RCV", "usbcom.descriptor.ecm.eth_stats.directed_frames_rcv", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00001000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_directed_bytes_rcv,\r\n{ "Directed Bytes RCV", "usbcom.descriptor.ecm.eth_stats.directed_bytes_rcv", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000800, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_broadcast_frames_xmit,\r\n{ "Broadcast Frames XMIT", "usbcom.descriptor.ecm.eth_stats.broadcast_frames_xmit", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000400, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_broadcast_bytes_xmit,\r\n{ "Broadcast Bytes XMIT", "usbcom.descriptor.ecm.eth_stats.broadcast_bytes_xmit", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000200, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_multicast_frames_xmit,\r\n{ "Multicast Frames XMIT", "usbcom.descriptor.ecm.eth_stats.multicast_frames_xmit", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000100, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_multicast_bytes_xmit,\r\n{ "Multicast Bytes XMIT", "usbcom.descriptor.ecm.eth_stats.multicast_bytes_xmit", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000080, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_directed_frames_xmit,\r\n{ "Directed Frames XMIT", "usbcom.descriptor.ecm.eth_stats.directed_frames_xmit", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000040, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_directed_bytes_xmit,\r\n{ "Directed Bytes XMIT", "usbcom.descriptor.ecm.eth_stats.directed_bytes_xmit", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000020, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_rcv_no_buffer,\r\n{ "RCV No Buffer", "usbcom.descriptor.ecm.eth_stats.rcv_no_buffer", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000010, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_rcv_error,\r\n{ "RCV Error", "usbcom.descriptor.ecm.eth_stats.rcv_error", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000008, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_error,\r\n{ "XMIT Error", "usbcom.descriptor.ecm.eth_stats.xmit_error", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000004, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_rvc_ok,\r\n{ "RCV OK", "usbcom.descriptor.ecm.eth_stats.rvc_ok", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000002, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_eth_stats_xmit_ok,\r\n{ "XMIT OK", "usbcom.descriptor.ecm.eth_stats.xmit_ok", FT_BOOLEAN, 32,\r\nTFS(&tfs_supported_not_supported), 0x00000001, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_max_segment_size,\r\n{ "Max Segment Size", "usbcom.descriptor.ecm.max_segment_size", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_nb_mc_filters,\r\n{ "Number MC Filters", "usbcom.descriptor.ecm.nb_mc_filters", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_nb_mc_filters_mc_address_filtering,\r\n{ "Multicast Address Filtering", "usbcom.descriptor.ecm.nb_mc_filters.mc_address_filtering", FT_BOOLEAN, 16,\r\nTFS(&usb_com_ecm_mc_address_filtering), 0x8000, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_nb_mc_filters_nb_filters_supported,\r\n{ "Number of Multicast Address Filters Supported", "usbcom.descriptor.ecm.nb_mc_filters.nb_filters_supported", FT_UINT16, BASE_DEC,\r\nNULL, 0x7fff, NULL, HFILL }},\r\n{ &hf_usb_com_descriptor_ecm_nb_power_filters,\r\n{ "Number Power Filters", "usbcom.descriptor.ecm.nb_power_filters", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_interrupt_request_type,\r\n{ "Request Type", "usbcom.interrupt.request_type", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_interrupt_notif_code,\r\n{ "Notification Code", "usbcom.interrupt.notification_code", FT_UINT8, BASE_HEX,\r\nVALS(usb_com_interrupt_notif_code_vals), 0, NULL, HFILL }},\r\n{ &hf_usb_com_interrupt_value,\r\n{ "Value", "usbcom.interrupt.value", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_interrupt_value_nw_conn,\r\n{ "Value", "usbcom.interrupt.value", FT_UINT16, BASE_HEX,\r\nVALS(usb_com_interrupt_value_nw_conn_vals), 0, NULL, HFILL }},\r\n{ &hf_usb_com_interrupt_index,\r\n{ "Index", "usbcom.interrupt.index", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_interrupt_length,\r\n{ "Length", "usbcom.interrupt.length", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_interrupt_dl_bitrate,\r\n{ "DL Bitrate", "usbcom.interrupt.conn_speed_change.dl_bitrate", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_interrupt_ul_bitrate,\r\n{ "UL Bitrate", "usbcom.interrupt.conn_speed_change.ul_bitrate", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_usb_com_interrupt_payload,\r\n{ "Payload", "usbcom.interrupt.payload", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }}\r\n};\r\nstatic gint *usb_com_subtrees[] = {\r\n&ett_usb_com,\r\n&ett_usb_com_capabilities,\r\n&ett_usb_com_bitmap,\r\n&ett_usb_com_descriptor_ecm_eth_stats,\r\n&ett_usb_com_descriptor_ecm_nb_mc_filters\r\n};\r\nproto_usb_com = proto_register_protocol("USB Communications and CDC Control", "USBCOM", "usbcom");\r\nproto_register_field_array(proto_usb_com, hf, array_length(hf));\r\nproto_register_subtree_array(usb_com_subtrees, array_length(usb_com_subtrees));\r\n}\r\nvoid\r\nproto_reg_handoff_usb_com(void)\r\n{\r\ndissector_handle_t usb_com_descriptor_handle, usb_com_control_handle,\r\nusb_com_bulk_handle, usb_com_interrupt_handle;\r\nusb_com_descriptor_handle = create_dissector_handle(dissect_usb_com_descriptor, proto_usb_com);\r\ndissector_add_uint("usb.descriptor", IF_CLASS_COMMUNICATIONS, usb_com_descriptor_handle);\r\nusb_com_control_handle = create_dissector_handle(dissect_usb_com_control, proto_usb_com);\r\ndissector_add_uint("usb.control", IF_CLASS_COMMUNICATIONS, usb_com_control_handle);\r\nusb_com_bulk_handle = create_dissector_handle(dissect_usb_com_bulk, proto_usb_com);\r\ndissector_add_uint("usb.bulk", IF_CLASS_CDC_DATA, usb_com_bulk_handle);\r\nusb_com_interrupt_handle = create_dissector_handle(dissect_usb_com_interrupt, proto_usb_com);\r\ndissector_add_uint("usb.interrupt", IF_CLASS_COMMUNICATIONS, usb_com_interrupt_handle);\r\nmbim_control_handle = find_dissector_add_dependency("mbim.control", proto_usb_com);\r\nmbim_descriptor_handle = find_dissector_add_dependency("mbim.descriptor", proto_usb_com);\r\nmbim_bulk_handle = find_dissector_add_dependency("mbim.bulk", proto_usb_com);\r\neth_withoutfcs_handle = find_dissector_add_dependency("eth_withoutfcs", proto_usb_com);\r\n}
