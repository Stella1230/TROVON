static guint\r\nget_openflow_pdu_length(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nreturn tvb_get_ntohs(tvb, offset + 2);\r\n}\r\nstatic int\r\ndissect_openflow_tcp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nguint offset = 0;\r\nguint8 version;\r\nproto_item* ti;\r\nversion = tvb_get_guint8(tvb, 0);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "OpenFlow");\r\ncol_clear(pinfo->cinfo,COL_INFO);\r\nswitch(version){\r\ncase OFP_VERSION_1_0:\r\ncall_dissector(openflow_v1_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase OFP_VERSION_1_3:\r\ncall_dissector(openflow_v4_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase OFP_VERSION_1_4:\r\ncall_dissector(openflow_v5_handle, tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\nti = proto_tree_add_item(tree, hf_openflow_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, ti, &ei_openflow_version);\r\nbreak;\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nstatic int\r\ndissect_openflow(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, openflow_desegment, OFP_HEADER_LEN,\r\nget_openflow_pdu_length, dissect_openflow_tcp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_openflow_heur(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void *data)\r\n{\r\nconversation_t *conversation = NULL;\r\nif ((pinfo->destport != OFP_LEGACY_PORT) &&\r\n(pinfo->destport != OFP_LEGACY2_PORT) &&\r\n(pinfo->destport != OFP_IANA_PORT) &&\r\n(pinfo->destport != (guint32)g_openflow_port)) {\r\nreturn FALSE;\r\n}\r\nconversation = find_or_create_conversation(pinfo);\r\nconversation_set_dissector(conversation, openflow_handle);\r\ndissect_openflow(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_openflow(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_openflow_version,\r\n{ "Version", "openflow.version",\r\nFT_UINT8, BASE_HEX, VALS(openflow_version_values), 0x7f,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_openflow_version, { "openflow.version.unknown", PI_UNDECODED, PI_WARN, "Unsupported version not dissected", EXPFILL }},\r\n};\r\nmodule_t *openflow_module;\r\nexpert_module_t* expert_openflow;\r\nproto_openflow = proto_register_protocol("OpenFlow",\r\n"OpenFlow", "openflow");\r\nopenflow_handle = register_dissector("openflow", dissect_openflow, proto_openflow);\r\nproto_register_field_array(proto_openflow, hf, array_length(hf));\r\nexpert_openflow = expert_register_protocol(proto_openflow);\r\nexpert_register_field_array(expert_openflow, ei, array_length(ei));\r\nopenflow_module = prefs_register_protocol(proto_openflow, proto_reg_handoff_openflow);\r\nprefs_register_uint_preference(openflow_module, "tcp.port", "OpenFlow TCP port",\r\n"OpenFlow TCP port (6653 is the IANA assigned port)",\r\n10, &g_openflow_port);\r\nprefs_register_obsolete_preference(openflow_module, "heuristic");\r\nprefs_register_bool_preference(openflow_module, "desegment",\r\n"Reassemble OpenFlow messages spanning multiple TCP segments",\r\n"Whether the OpenFlow dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&openflow_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_openflow(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic int currentPort;\r\nif (!initialized) {\r\nheur_dissector_add("tcp", dissect_openflow_heur, "OpenFlow over TCP", "openflow_tcp", proto_openflow, HEURISTIC_ENABLE);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", currentPort, openflow_handle);\r\n}\r\ncurrentPort = g_openflow_port;\r\ndissector_add_uint("tcp.port", currentPort, openflow_handle);\r\nopenflow_v1_handle = find_dissector_add_dependency("openflow_v1", proto_openflow);\r\nopenflow_v4_handle = find_dissector_add_dependency("openflow_v4", proto_openflow);\r\nopenflow_v5_handle = find_dissector_add_dependency("openflow_v5", proto_openflow);\r\n}
