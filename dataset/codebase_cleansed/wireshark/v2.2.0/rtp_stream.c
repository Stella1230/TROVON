static void rtpstream_draw(void *ti_ptr)\r\n{\r\nrtpstream_tapinfo_t *tapinfo = (rtpstream_tapinfo_t *)ti_ptr;\r\nif (tapinfo && tapinfo->tap_draw) {\r\ntapinfo->tap_draw(tapinfo);\r\n}\r\nreturn;\r\n}\r\nvoid rtpstream_scan(rtpstream_tapinfo_t *tapinfo, capture_file *cap_file, const char *fstring)\r\n{\r\ngboolean was_registered;\r\nif (!tapinfo || !cap_file) {\r\nreturn;\r\n}\r\nwas_registered = tapinfo->is_registered;\r\nif (!tapinfo->is_registered)\r\nregister_tap_listener_rtp_stream(tapinfo, fstring);\r\ntapinfo->mode = TAP_ANALYSE;\r\ncf_retap_packets(cap_file);\r\nif (!was_registered)\r\nremove_tap_listener_rtp_stream(tapinfo);\r\n}\r\ngboolean rtpstream_save(rtpstream_tapinfo_t *tapinfo, capture_file *cap_file, rtp_stream_info_t* stream, const gchar *filename)\r\n{\r\ngboolean was_registered;\r\nif (!tapinfo) {\r\nreturn FALSE;\r\n}\r\nwas_registered = tapinfo->is_registered;\r\ntapinfo->save_file = ws_fopen(filename, "wb");\r\nif (tapinfo->save_file==NULL) {\r\nopen_failure_alert_box(filename, errno, TRUE);\r\nreturn FALSE;\r\n}\r\nrtp_write_header(stream, tapinfo->save_file);\r\nif (ferror(tapinfo->save_file)) {\r\nwrite_failure_alert_box(filename, errno);\r\nfclose(tapinfo->save_file);\r\nreturn FALSE;\r\n}\r\nif (!tapinfo->is_registered)\r\nregister_tap_listener_rtp_stream(tapinfo, NULL);\r\ntapinfo->mode = TAP_SAVE;\r\ntapinfo->filter_stream_fwd = stream;\r\ncf_retap_packets(cap_file);\r\ntapinfo->mode = TAP_ANALYSE;\r\nif (!was_registered)\r\nremove_tap_listener_rtp_stream(tapinfo);\r\nif (ferror(tapinfo->save_file)) {\r\nwrite_failure_alert_box(filename, errno);\r\nfclose(tapinfo->save_file);\r\nreturn FALSE;\r\n}\r\nif (fclose(tapinfo->save_file) == EOF) {\r\nwrite_failure_alert_box(filename, errno);\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\ngboolean rtp_stream_info_is_reverse(const rtp_stream_info_t *stream_a, rtp_stream_info_t *stream_b)\r\n{\r\nif (stream_a == NULL || stream_b == NULL)\r\nreturn FALSE;\r\nif ((addresses_equal(&(stream_a->src_addr), &(stream_b->dest_addr)))\r\n&& (stream_a->src_port == stream_b->dest_port)\r\n&& (addresses_equal(&(stream_a->dest_addr), &(stream_b->src_addr)))\r\n&& (stream_a->dest_port == stream_b->src_port))\r\nreturn TRUE;\r\nelse\r\nreturn FALSE;\r\n}\r\nvoid rtpstream_mark(rtpstream_tapinfo_t *tapinfo, capture_file *cap_file, rtp_stream_info_t* stream_fwd, rtp_stream_info_t* stream_rev)\r\n{\r\ngboolean was_registered;\r\nif (!tapinfo) {\r\nreturn;\r\n}\r\nwas_registered = tapinfo->is_registered;\r\nif (!tapinfo->is_registered)\r\nregister_tap_listener_rtp_stream(tapinfo, NULL);\r\ntapinfo->mode = TAP_MARK;\r\ntapinfo->filter_stream_fwd = stream_fwd;\r\ntapinfo->filter_stream_rev = stream_rev;\r\ncf_retap_packets(cap_file);\r\ntapinfo->mode = TAP_ANALYSE;\r\nif (!was_registered)\r\nremove_tap_listener_rtp_stream(tapinfo);\r\n}\r\nvoid\r\nremove_tap_listener_rtp_stream(rtpstream_tapinfo_t *tapinfo)\r\n{\r\nif (tapinfo && tapinfo->is_registered) {\r\nremove_tap_listener(tapinfo);\r\ntapinfo->is_registered = FALSE;\r\n}\r\n}\r\nvoid\r\nregister_tap_listener_rtp_stream(rtpstream_tapinfo_t *tapinfo, const char *fstring)\r\n{\r\nGString *error_string;\r\nif (!tapinfo) {\r\nreturn;\r\n}\r\nif (!tapinfo->is_registered) {\r\nerror_string = register_tap_listener("rtp", tapinfo,\r\nfstring, 0, rtpstream_reset_cb, rtpstream_packet,\r\nrtpstream_draw);\r\nif (error_string != NULL) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"%s", error_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\ntapinfo->is_registered = TRUE;\r\n}\r\n}
