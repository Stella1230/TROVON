static void\r\nbytes_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.bytes = NULL;\r\n}\r\nstatic void\r\nbytes_fvalue_free(fvalue_t *fv)\r\n{\r\nif (fv->value.bytes) {\r\ng_byte_array_free(fv->value.bytes, TRUE);\r\nfv->value.bytes=NULL;\r\n}\r\n}\r\nstatic void\r\nbytes_fvalue_set(fvalue_t *fv, GByteArray *value)\r\n{\r\nbytes_fvalue_free(fv);\r\nfv->value.bytes = value;\r\n}\r\nstatic int\r\nbytes_repr_len(fvalue_t *fv, ftrepr_t rtype, int field_display _U_)\r\n{\r\nif (fv->value.bytes->len == 0) {\r\nreturn (rtype == FTREPR_DFILTER) ? 2 : 0;\r\n} else {\r\nreturn fv->value.bytes->len * 3 - 1;\r\n}\r\n}\r\nstatic int\r\noid_repr_len(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn OID_REPR_LEN(fv);\r\n}\r\nstatic void\r\noid_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size _U_)\r\n{\r\nchar* oid_str = oid_encoded2string(NULL, fv->value.bytes->data,fv->value.bytes->len);\r\ng_strlcpy(buf,oid_str,OID_REPR_LEN(fv));\r\nwmem_free(NULL, oid_str);\r\n}\r\nstatic int\r\nrel_oid_repr_len(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_)\r\n{\r\nreturn REL_OID_REPR_LEN(fv);\r\n}\r\nstatic void\r\nrel_oid_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size _U_)\r\n{\r\nchar* oid_str = rel_oid_encoded2string(NULL, fv->value.bytes->data,fv->value.bytes->len);\r\n*buf++ = '.';\r\ng_strlcpy(buf,oid_str,REL_OID_REPR_LEN(fv));\r\nwmem_free(NULL, oid_str);\r\n}\r\nstatic void\r\nsystem_id_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, int field_display _U_, char *buf, unsigned int size)\r\n{\r\nprint_system_id_buf(fv->value.bytes->data,fv->value.bytes->len, buf, size);\r\n}\r\nstatic void\r\nbytes_to_repr(fvalue_t *fv, ftrepr_t rtype, int field_display, char *buf, unsigned int size _U_)\r\n{\r\nchar separator;\r\nswitch(FIELD_DISPLAY(field_display))\r\n{\r\ncase SEP_DOT:\r\nseparator = '.';\r\nbreak;\r\ncase SEP_DASH:\r\nseparator = '-';\r\nbreak;\r\ncase SEP_SPACE:\r\ncase SEP_COLON:\r\ncase BASE_NONE:\r\ndefault:\r\nseparator = ':';\r\nbreak;\r\n}\r\nif (fv->value.bytes->len) {\r\nbuf = bytes_to_hexstr_punct(buf, fv->value.bytes->data, fv->value.bytes->len, separator);\r\n}\r\nelse {\r\nif (rtype == FTREPR_DFILTER) {\r\n*buf++ = '"';\r\n*buf++ = '"';\r\n}\r\n}\r\n*buf = '\0';\r\n}\r\nstatic void\r\ncommon_fvalue_set(fvalue_t *fv, const guint8* data, guint len)\r\n{\r\nbytes_fvalue_free(fv);\r\nfv->value.bytes = g_byte_array_new();\r\ng_byte_array_append(fv->value.bytes, data, len);\r\n}\r\nstatic void\r\nax25_fvalue_set(fvalue_t *fv, const guint8 *value)\r\n{\r\ncommon_fvalue_set(fv, value, FT_AX25_ADDR_LEN);\r\n}\r\nstatic void\r\nvines_fvalue_set(fvalue_t *fv, const guint8 *value)\r\n{\r\ncommon_fvalue_set(fv, value, FT_VINES_ADDR_LEN);\r\n}\r\nstatic void\r\nether_fvalue_set(fvalue_t *fv, const guint8 *value)\r\n{\r\ncommon_fvalue_set(fv, value, FT_ETHER_LEN);\r\n}\r\nstatic void\r\nfcwwn_fvalue_set(fvalue_t *fv, const guint8 *value)\r\n{\r\ncommon_fvalue_set(fv, value, FT_FCWWN_LEN);\r\n}\r\nstatic void\r\noid_fvalue_set(fvalue_t *fv, GByteArray *value)\r\n{\r\nbytes_fvalue_free(fv);\r\nfv->value.bytes = value;\r\n}\r\nstatic void\r\nsystem_id_fvalue_set(fvalue_t *fv, GByteArray *value)\r\n{\r\nbytes_fvalue_free(fv);\r\nfv->value.bytes = value;\r\n}\r\nstatic gpointer\r\nvalue_get(fvalue_t *fv)\r\n{\r\nreturn fv->value.bytes->data;\r\n}\r\nstatic gboolean\r\nbytes_from_string(fvalue_t *fv, const char *s, gchar **err_msg _U_)\r\n{\r\nGByteArray *bytes;\r\nbytes = g_byte_array_new();\r\ng_byte_array_append(bytes, (const guint8 *)s, (guint)strlen(s));\r\nbytes_fvalue_free(fv);\r\nfv->value.bytes = bytes;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nbytes_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nGByteArray *bytes;\r\ngboolean res;\r\nbytes = g_byte_array_new();\r\nres = hex_str_to_bytes(s, bytes, TRUE);\r\nif (!res) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid byte string.", s);\r\ng_byte_array_free(bytes, TRUE);\r\nreturn FALSE;\r\n}\r\nbytes_fvalue_free(fv);\r\nfv->value.bytes = bytes;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nax25_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nif (bytes_from_unparsed(fv, s, TRUE, NULL)) {\r\nif (fv->value.bytes->len > FT_AX25_ADDR_LEN) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" contains too many bytes to be a valid AX.25 address.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nelse if (fv->value.bytes->len < FT_AX25_ADDR_LEN && !allow_partial_value) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" contains too few bytes to be a valid AX.25 address.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid AX.25 address.", s);\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nvines_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nif (bytes_from_unparsed(fv, s, TRUE, NULL)) {\r\nif (fv->value.bytes->len > FT_VINES_ADDR_LEN) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" contains too many bytes to be a valid Vines address.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nelse if (fv->value.bytes->len < FT_VINES_ADDR_LEN && !allow_partial_value) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" contains too few bytes to be a valid Vines address.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid Vines address.", s);\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nether_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, gchar **err_msg)\r\n{\r\nguint8 *mac;\r\nif (bytes_from_unparsed(fv, s, TRUE, NULL)) {\r\nif (fv->value.bytes->len > FT_ETHER_LEN) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" contains too many bytes to be a valid Ethernet address.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nelse if (fv->value.bytes->len < FT_ETHER_LEN && !allow_partial_value) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" contains too few bytes to be a valid Ethernet address.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nmac = get_ether_addr(s);\r\nif (!mac) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid hostname or Ethernet address.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nether_fvalue_set(fv, mac);\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\noid_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nGByteArray *bytes;\r\ngboolean res;\r\n#if 0\r\nif (bytes_from_unparsed(fv, s, TRUE, NULL)) {\r\nreturn TRUE;\r\n}\r\n#endif\r\nbytes = g_byte_array_new();\r\nres = oid_str_to_bytes(s, bytes);\r\nif (!res) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid OBJECT IDENTIFIER.", s);\r\ng_byte_array_free(bytes, TRUE);\r\nreturn FALSE;\r\n}\r\nbytes_fvalue_free(fv);\r\nfv->value.bytes = bytes;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nrel_oid_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nGByteArray *bytes;\r\ngboolean res;\r\nbytes = g_byte_array_new();\r\nres = rel_oid_str_to_bytes(s, bytes, FALSE);\r\nif (!res) {\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid RELATIVE-OID.", s);\r\ng_byte_array_free(bytes, TRUE);\r\nreturn FALSE;\r\n}\r\nbytes_fvalue_free(fv);\r\nfv->value.bytes = bytes;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nsystem_id_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nif (bytes_from_unparsed(fv, s, TRUE, NULL)) {\r\nif (fv->value.bytes->len > MAX_SYSTEMID_LEN) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" contains too many bytes to be a valid OSI System-ID.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid OSI System-ID.", s);\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nfcwwn_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, gchar **err_msg)\r\n{\r\nif (bytes_from_unparsed(fv, s, TRUE, NULL)) {\r\nif (fv->value.bytes->len > FT_FCWWN_LEN) {\r\nif (err_msg != NULL) {\r\n*err_msg = g_strdup_printf("\"%s\" contains too many bytes to be a valid FCWWN.",\r\ns);\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nif (err_msg != NULL)\r\n*err_msg = g_strdup_printf("\"%s\" is not a valid FCWWN.", s);\r\nreturn FALSE;\r\n}\r\nstatic guint\r\nlen(fvalue_t *fv)\r\n{\r\nreturn fv->value.bytes->len;\r\n}\r\nstatic void\r\nslice(fvalue_t *fv, GByteArray *bytes, guint offset, guint length)\r\n{\r\nguint8* data;\r\ndata = fv->value.bytes->data + offset;\r\ng_byte_array_append(bytes, data, length);\r\n}\r\nstatic gboolean\r\ncmp_eq(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nGByteArray *a = fv_a->value.bytes;\r\nGByteArray *b = fv_b->value.bytes;\r\nif (a->len != b->len) {\r\nreturn FALSE;\r\n}\r\nreturn (memcmp(a->data, b->data, a->len) == 0);\r\n}\r\nstatic gboolean\r\ncmp_ne(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nGByteArray *a = fv_a->value.bytes;\r\nGByteArray *b = fv_b->value.bytes;\r\nif (a->len != b->len) {\r\nreturn TRUE;\r\n}\r\nreturn (memcmp(a->data, b->data, a->len) != 0);\r\n}\r\nstatic gboolean\r\ncmp_gt(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nGByteArray *a = fv_a->value.bytes;\r\nGByteArray *b = fv_b->value.bytes;\r\nif (a->len > b->len) {\r\nreturn TRUE;\r\n}\r\nif (a->len < b->len) {\r\nreturn FALSE;\r\n}\r\nreturn (memcmp(a->data, b->data, a->len) > 0);\r\n}\r\nstatic gboolean\r\ncmp_ge(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nGByteArray *a = fv_a->value.bytes;\r\nGByteArray *b = fv_b->value.bytes;\r\nif (a->len > b->len) {\r\nreturn TRUE;\r\n}\r\nif (a->len < b->len) {\r\nreturn FALSE;\r\n}\r\nreturn (memcmp(a->data, b->data, a->len) >= 0);\r\n}\r\nstatic gboolean\r\ncmp_lt(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nGByteArray *a = fv_a->value.bytes;\r\nGByteArray *b = fv_b->value.bytes;\r\nif (a->len < b->len) {\r\nreturn TRUE;\r\n}\r\nif (a->len > b->len) {\r\nreturn FALSE;\r\n}\r\nreturn (memcmp(a->data, b->data, a->len) < 0);\r\n}\r\nstatic gboolean\r\ncmp_le(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nGByteArray *a = fv_a->value.bytes;\r\nGByteArray *b = fv_b->value.bytes;\r\nif (a->len < b->len) {\r\nreturn TRUE;\r\n}\r\nif (a->len > b->len) {\r\nreturn FALSE;\r\n}\r\nreturn (memcmp(a->data, b->data, a->len) <= 0);\r\n}\r\nstatic gboolean\r\ncmp_bitwise_and(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nGByteArray *a = fv_a->value.bytes;\r\nGByteArray *b = fv_b->value.bytes;\r\nguint i = 0;\r\nunsigned char *p_a, *p_b;\r\nif (b->len != a->len) {\r\nreturn FALSE;\r\n}\r\np_a = a->data;\r\np_b = b->data;\r\nwhile (i < b->len) {\r\nif (p_a[i] & p_b[i])\r\nreturn TRUE;\r\nelse\r\ni++;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\ncmp_contains(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nGByteArray *a = fv_a->value.bytes;\r\nGByteArray *b = fv_b->value.bytes;\r\nif (epan_memmem(a->data, a->len, b->data, b->len)) {\r\nreturn TRUE;\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\n}\r\nstatic gboolean\r\ncmp_matches(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nGByteArray *a = fv_a->value.bytes;\r\nGRegex *regex = fv_b->value.re;\r\nif (strcmp(fv_b->ftype->name, "FT_PCRE") != 0) {\r\nreturn FALSE;\r\n}\r\nif (! regex) {\r\nreturn FALSE;\r\n}\r\nreturn g_regex_match_full(\r\nregex,\r\n(char *)a->data,\r\n(int)a->len,\r\n0,\r\n(GRegexMatchFlags)0,\r\nNULL,\r\nNULL\r\n);\r\n}\r\nvoid\r\nftype_register_bytes(void)\r\n{\r\nstatic ftype_t bytes_type = {\r\nFT_BYTES,\r\n"FT_BYTES",\r\n"Sequence of bytes",\r\n0,\r\nbytes_fvalue_new,\r\nbytes_fvalue_free,\r\nbytes_from_unparsed,\r\nbytes_from_string,\r\nbytes_to_repr,\r\nbytes_repr_len,\r\nbytes_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\ncmp_contains,\r\nCMP_MATCHES,\r\nlen,\r\nslice,\r\n};\r\nstatic ftype_t uint_bytes_type = {\r\nFT_UINT_BYTES,\r\n"FT_UINT_BYTES",\r\n"Sequence of bytes",\r\n0,\r\nbytes_fvalue_new,\r\nbytes_fvalue_free,\r\nbytes_from_unparsed,\r\nNULL,\r\nbytes_to_repr,\r\nbytes_repr_len,\r\nbytes_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\ncmp_contains,\r\nNULL,\r\nlen,\r\nslice,\r\n};\r\nstatic ftype_t ax25_type = {\r\nFT_AX25,\r\n"FT_AX25",\r\n"AX.25 address",\r\nFT_AX25_ADDR_LEN,\r\nbytes_fvalue_new,\r\nbytes_fvalue_free,\r\nax25_from_unparsed,\r\nNULL,\r\nbytes_to_repr,\r\nbytes_repr_len,\r\nNULL,\r\nax25_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\ncmp_contains,\r\nCMP_MATCHES,\r\nlen,\r\nslice,\r\n};\r\nstatic ftype_t vines_type = {\r\nFT_VINES,\r\n"FT_VINES",\r\n"VINES address",\r\nFT_VINES_ADDR_LEN,\r\nbytes_fvalue_new,\r\nbytes_fvalue_free,\r\nvines_from_unparsed,\r\nNULL,\r\nbytes_to_repr,\r\nbytes_repr_len,\r\nNULL,\r\nvines_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\ncmp_contains,\r\nCMP_MATCHES,\r\nlen,\r\nslice,\r\n};\r\nstatic ftype_t ether_type = {\r\nFT_ETHER,\r\n"FT_ETHER",\r\n"Ethernet or other MAC address",\r\nFT_ETHER_LEN,\r\nbytes_fvalue_new,\r\nbytes_fvalue_free,\r\nether_from_unparsed,\r\nNULL,\r\nbytes_to_repr,\r\nbytes_repr_len,\r\nNULL,\r\nether_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\ncmp_contains,\r\nCMP_MATCHES,\r\nlen,\r\nslice,\r\n};\r\nstatic ftype_t oid_type = {\r\nFT_OID,\r\n"FT_OID",\r\n"ASN.1 object identifier",\r\n0,\r\nbytes_fvalue_new,\r\nbytes_fvalue_free,\r\noid_from_unparsed,\r\nNULL,\r\noid_to_repr,\r\noid_repr_len,\r\noid_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\ncmp_contains,\r\nNULL,\r\nlen,\r\nslice,\r\n};\r\nstatic ftype_t rel_oid_type = {\r\nFT_REL_OID,\r\n"FT_REL_OID",\r\n"ASN.1 relative object identifier",\r\n0,\r\nbytes_fvalue_new,\r\nbytes_fvalue_free,\r\nrel_oid_from_unparsed,\r\nNULL,\r\nrel_oid_to_repr,\r\nrel_oid_repr_len,\r\noid_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\ncmp_contains,\r\nNULL,\r\nlen,\r\nslice,\r\n};\r\nstatic ftype_t system_id_type = {\r\nFT_SYSTEM_ID,\r\n"FT_SYSTEM_ID",\r\n"OSI System-ID",\r\n0,\r\nbytes_fvalue_new,\r\nbytes_fvalue_free,\r\nsystem_id_from_unparsed,\r\nNULL,\r\nsystem_id_to_repr,\r\nbytes_repr_len,\r\nsystem_id_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\ncmp_contains,\r\nNULL,\r\nlen,\r\nslice,\r\n};\r\nstatic ftype_t fcwwn_type = {\r\nFT_FCWWN,\r\n"FT_FCWWN",\r\n"Fibre Channel WWN",\r\nFT_FCWWN_LEN,\r\nbytes_fvalue_new,\r\nbytes_fvalue_free,\r\nfcwwn_from_unparsed,\r\nNULL,\r\nbytes_to_repr,\r\nbytes_repr_len,\r\nNULL,\r\nfcwwn_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\ncmp_bitwise_and,\r\ncmp_contains,\r\nCMP_MATCHES,\r\nlen,\r\nslice,\r\n};\r\nftype_register(FT_BYTES, &bytes_type);\r\nftype_register(FT_UINT_BYTES, &uint_bytes_type);\r\nftype_register(FT_AX25, &ax25_type);\r\nftype_register(FT_VINES, &vines_type);\r\nftype_register(FT_ETHER, &ether_type);\r\nftype_register(FT_OID, &oid_type);\r\nftype_register(FT_REL_OID, &rel_oid_type);\r\nftype_register(FT_SYSTEM_ID, &system_id_type);\r\nftype_register(FT_FCWWN, &fcwwn_type);\r\n}
