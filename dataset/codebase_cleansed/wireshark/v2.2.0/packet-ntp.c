const char *\r\ntvb_mip6_fmt_ts(tvbuff_t *tvb, gint offset)\r\n{\r\nguint64 tempstmp;\r\nguint32 tempfrac;\r\ntime_t temptime;\r\nstruct tm *bd;\r\ndouble fractime;\r\nchar *buff;\r\ntempstmp = tvb_get_ntoh48(tvb, offset);\r\ntempfrac = tvb_get_ntohs(tvb, offset+6);\r\ntempfrac <<= 16;\r\nif ((tempstmp == 0) && (tempfrac == 0)) {\r\nreturn "NULL";\r\n}\r\ntemptime = (time_t)(tempstmp );\r\nbd = gmtime(&temptime);\r\nif(!bd){\r\nreturn "Not representable";\r\n}\r\nfractime = bd->tm_sec + tempfrac / NTP_FLOAT_DENOM;\r\nbuff = (char *)wmem_alloc(wmem_packet_scope(), NTP_TS_SIZE);\r\ng_snprintf(buff, NTP_TS_SIZE,\r\n"%s %2d, %d %02d:%02d:%07.4f UTC",\r\nmon_names[bd->tm_mon],\r\nbd->tm_mday,\r\nbd->tm_year + 1900,\r\nbd->tm_hour,\r\nbd->tm_min,\r\nfractime);\r\nreturn buff;\r\n}\r\nconst char *\r\ntvb_ntp_fmt_ts(tvbuff_t *tvb, gint offset)\r\n{\r\nguint32 tempstmp, tempfrac;\r\ntime_t temptime;\r\nstruct tm *bd;\r\ndouble fractime;\r\nchar *buff;\r\ntempstmp = tvb_get_ntohl(tvb, offset);\r\ntempfrac = tvb_get_ntohl(tvb, offset+4);\r\nif ((tempstmp == 0) && (tempfrac == 0)) {\r\nreturn "NULL";\r\n}\r\ntemptime = (time_t)(tempstmp - NTP_BASETIME);\r\nbd = gmtime(&temptime);\r\nif(!bd){\r\nreturn "Not representable";\r\n}\r\nfractime = bd->tm_sec + tempfrac / NTP_FLOAT_DENOM;\r\nbuff=(char *)wmem_alloc(wmem_packet_scope(), NTP_TS_SIZE);\r\ng_snprintf(buff, NTP_TS_SIZE,\r\n"%s %2d, %d %02d:%02d:%09.6f UTC",\r\nmon_names[bd->tm_mon],\r\nbd->tm_mday,\r\nbd->tm_year + 1900,\r\nbd->tm_hour,\r\nbd->tm_min,\r\nfractime);\r\nreturn buff;\r\n}\r\nconst char *\r\ntvb_ntp_fmt_ts_sec(tvbuff_t *tvb, gint offset)\r\n{\r\nguint32 tempstmp;\r\ntime_t temptime;\r\nstruct tm *bd;\r\nchar *buff;\r\ntempstmp = tvb_get_ntohl(tvb, offset);\r\nif (tempstmp == 0){\r\nreturn "NULL";\r\n}\r\ntemptime = (time_t)(tempstmp - NTP_BASETIME);\r\nbd = gmtime(&temptime);\r\nif (!bd){\r\nreturn "Not representable";\r\n}\r\nbuff = (char *)wmem_alloc(wmem_packet_scope(), NTP_TS_SIZE);\r\ng_snprintf(buff, NTP_TS_SIZE,\r\n"%s %2d, %d %02d:%02d:%02d UTC",\r\nmon_names[bd->tm_mon],\r\nbd->tm_mday,\r\nbd->tm_year + 1900,\r\nbd->tm_hour,\r\nbd->tm_min,\r\nbd->tm_sec);\r\nreturn buff;\r\n}\r\nvoid\r\nntp_to_nstime(tvbuff_t *tvb, gint offset, nstime_t *nstime)\r\n{\r\nguint32 tempstmp;\r\ntempstmp = tvb_get_ntohl(tvb, offset);\r\nif (tempstmp)\r\nnstime->secs = (time_t)(tempstmp - NTP_BASETIME);\r\nelse\r\nnstime->secs = (time_t)tempstmp;\r\nnstime->nsecs = (int)(tvb_get_ntohl(tvb, offset+4)/(NTP_FLOAT_DENOM/1000000000.0));\r\n}\r\nstatic int\r\ndissect_ntp_ext(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ntp_tree, int offset)\r\n{\r\nproto_tree *ext_tree, *flags_tree;\r\nproto_item *tf, *ext_item;\r\nguint16 extlen;\r\nint endoffset;\r\nguint8 flags;\r\nguint32 vallen, vallen_round, siglen;\r\nextlen = tvb_get_ntohs(tvb, offset+2);\r\ntf = proto_tree_add_item(ntp_tree, hf_ntp_ext, tvb, offset, extlen,\r\nENC_NA);\r\next_tree = proto_item_add_subtree(tf, ett_ntp_ext);\r\nif (extlen < 8) {\r\nexpert_add_info_format(pinfo, tf, &ei_ntp_ext, "Extension length %u < 8", extlen);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nif (extlen % 4) {\r\nexpert_add_info_format(pinfo, tf, &ei_ntp_ext, "Extension length %u isn't a multiple of 4",\r\nextlen);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nendoffset = offset + extlen;\r\nflags = tvb_get_guint8(tvb, offset);\r\ntf = proto_tree_add_uint(ext_tree, hf_ntp_ext_flags, tvb, offset, 1,\r\nflags);\r\nflags_tree = proto_item_add_subtree(tf, ett_ntp_ext_flags);\r\nproto_tree_add_uint(flags_tree, hf_ntp_ext_flags_r, tvb, offset, 1,\r\nflags);\r\nproto_tree_add_uint(flags_tree, hf_ntp_ext_flags_error, tvb, offset, 1,\r\nflags);\r\nproto_tree_add_uint(flags_tree, hf_ntp_ext_flags_vn, tvb, offset, 1,\r\nflags);\r\noffset += 1;\r\nproto_tree_add_item(ext_tree, hf_ntp_ext_op, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_uint(ext_tree, hf_ntp_ext_len, tvb, offset, 2, extlen);\r\noffset += 2;\r\nif ((flags & NTP_EXT_VN_MASK) != 2) {\r\nreturn endoffset;\r\n}\r\nproto_tree_add_item(ext_tree, hf_ntp_ext_associd, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (extlen < MAX_MAC_LEN) {\r\nreturn endoffset;\r\n}\r\nproto_tree_add_item(ext_tree, hf_ntp_ext_tstamp, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ext_tree, hf_ntp_ext_fstamp, tvb, offset, 4,\r\nENC_BIG_ENDIAN);\r\noffset += 4;\r\nvallen = tvb_get_ntohl(tvb, offset);\r\next_item = proto_tree_add_uint(ext_tree, hf_ntp_ext_vallen, tvb, offset, 4,\r\nvallen);\r\noffset += 4;\r\nvallen_round = (vallen + 3) & (-4);\r\nif (vallen != 0) {\r\nif ((guint32)(endoffset - offset) < vallen_round) {\r\nexpert_add_info_format(pinfo, ext_item, &ei_ntp_ext,\r\n"Value length makes value go past the end of the extension field");\r\nreturn endoffset;\r\n}\r\nproto_tree_add_item(ext_tree, hf_ntp_ext_val, tvb, offset,\r\nvallen, ENC_NA);\r\n}\r\noffset += vallen_round;\r\nsiglen = tvb_get_ntohl(tvb, offset);\r\next_item = proto_tree_add_uint(ext_tree, hf_ntp_ext_siglen, tvb, offset, 4,\r\nsiglen);\r\noffset += 4;\r\nif (siglen != 0) {\r\nif (offset + (int)siglen > endoffset) {\r\nexpert_add_info_format(pinfo, ext_item, &ei_ntp_ext,\r\n"Signature length makes value go past the end of the extension field");\r\nreturn endoffset;\r\n}\r\nproto_tree_add_item(ext_tree, hf_ntp_ext_sig, tvb,\r\noffset, siglen, ENC_NA);\r\n}\r\nreturn endoffset;\r\n}\r\nstatic void\r\ndissect_ntp_std(tvbuff_t *tvb, packet_info *pinfo, proto_tree *ntp_tree)\r\n{\r\nguint8 stratum;\r\nguint8 ppoll;\r\ngint8 precision;\r\ndouble rootdelay;\r\ndouble rootdispersion;\r\nguint32 refid_addr;\r\ngchar *buff;\r\nint i;\r\nint macofs;\r\ngint maclen;\r\nproto_tree_add_bitmask(ntp_tree, tvb, 0, hf_ntp_flags, ett_ntp_flags, ntp_header_fields, ENC_NA);\r\nproto_tree_add_item(ntp_tree, hf_ntp_stratum, tvb, 1, 1, ENC_NA);\r\nstratum = tvb_get_guint8(tvb, 1);\r\nppoll = tvb_get_guint8(tvb, 2);\r\nif ((ppoll >= 4) && (ppoll <= 17)) {\r\nproto_tree_add_uint_format_value(ntp_tree, hf_ntp_ppoll, tvb, 2, 1,\r\nppoll,\r\n"%u (%u sec)",\r\nppoll,\r\n1 << ppoll);\r\n} else {\r\nproto_tree_add_uint_format_value(ntp_tree, hf_ntp_ppoll, tvb, 2, 1,\r\nppoll,\r\n"invalid (%u)",\r\nppoll);\r\n}\r\nprecision = tvb_get_guint8(tvb, 3);\r\nproto_tree_add_int_format_value(ntp_tree, hf_ntp_precision, tvb, 3, 1,\r\nprecision,\r\n"%8.6f sec",\r\npow(2, precision));\r\nrootdelay = ((gint16)tvb_get_ntohs(tvb, 4)) +\r\n(tvb_get_ntohs(tvb, 6) / 65536.0);\r\nproto_tree_add_double_format_value(ntp_tree, hf_ntp_rootdelay, tvb, 4, 4,\r\nrootdelay,\r\n"%9.4f sec",\r\nrootdelay);\r\nrootdispersion = ((gint16)tvb_get_ntohs(tvb, 8)) +\r\n(tvb_get_ntohs(tvb, 10) / 65536.0);\r\nproto_tree_add_double_format_value(ntp_tree, hf_ntp_rootdispersion, tvb, 8, 4,\r\nrootdispersion,\r\n"%9.4f sec",\r\nrootdispersion);\r\nbuff = (gchar *)wmem_alloc(wmem_packet_scope(), NTP_TS_SIZE);\r\nif (stratum <= 1) {\r\ng_snprintf (buff, NTP_TS_SIZE, "Unidentified reference source '%.4s'",\r\ntvb_get_string_enc(wmem_packet_scope(), tvb, 12, 4, ENC_ASCII));\r\nfor (i = 0; primary_sources[i].id; i++) {\r\nif (tvb_memeql(tvb, 12, primary_sources[i].id, 4) == 0) {\r\ng_snprintf(buff, NTP_TS_SIZE, "%s",\r\nprimary_sources[i].data);\r\nbreak;\r\n}\r\n}\r\n} else {\r\nint buffpos;\r\nrefid_addr = tvb_get_ipv4(tvb, 12);\r\nbuffpos = g_snprintf(buff, NTP_TS_SIZE, "%s", get_hostname (refid_addr));\r\nif (buffpos >= NTP_TS_SIZE) {\r\nbuff[NTP_TS_SIZE-4]='.';\r\nbuff[NTP_TS_SIZE-3]='.';\r\nbuff[NTP_TS_SIZE-2]='.';\r\nbuff[NTP_TS_SIZE-1]=0;\r\n}\r\n}\r\nproto_tree_add_bytes_format_value(ntp_tree, hf_ntp_refid, tvb, 12, 4,\r\nNULL, "%s", buff);\r\nproto_tree_add_item(ntp_tree, hf_ntp_reftime, tvb, 16, 8, ENC_TIME_NTP|ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ntp_tree, hf_ntp_org, tvb, 24, 8, ENC_TIME_NTP|ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ntp_tree, hf_ntp_rec, tvb, 32, 8, ENC_TIME_NTP|ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ntp_tree, hf_ntp_xmt, tvb, 40, 8, ENC_TIME_NTP|ENC_BIG_ENDIAN);\r\nmacofs = 48;\r\nwhile (tvb_reported_length_remaining(tvb, macofs) > (gint)MAX_MAC_LEN)\r\nmacofs = dissect_ntp_ext(tvb, pinfo, ntp_tree, macofs);\r\nif (tvb_reported_length_remaining(tvb, macofs) >= 4)\r\nproto_tree_add_item(ntp_tree, hf_ntp_keyid, tvb, macofs, 4,\r\nENC_NA);\r\nmacofs += 4;\r\nmaclen = tvb_reported_length_remaining(tvb, macofs);\r\nif (maclen > 0)\r\nproto_tree_add_item(ntp_tree, hf_ntp_mac, tvb, macofs,\r\nmaclen, ENC_NA);\r\n}\r\nstatic void\r\ndissect_ntp_ctrl(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *ntp_tree)\r\n{\r\nguint8 flags2;\r\nproto_tree *data_tree, *item_tree, *auth_tree;\r\nproto_item *td, *ti;\r\nguint16 associd;\r\nguint16 datalen;\r\nguint16 data_offset;\r\nint length_remaining;\r\ntvbparse_t *tt;\r\ntvbparse_elem_t *element;\r\nstatic const int *ntpctrl_flags[] = {\r\n&hf_ntpctrl_flags2_r,\r\n&hf_ntpctrl_flags2_error,\r\n&hf_ntpctrl_flags2_more,\r\n&hf_ntpctrl_flags2_opcode,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(ntp_tree, tvb, 0, hf_ntp_flags, ett_ntp_flags, ntp_header_fields, ENC_NA);\r\nproto_tree_add_bitmask(ntp_tree, tvb, 1, hf_ntpctrl_flags2, ett_ntpctrl_flags2, ntpctrl_flags, ENC_NA);\r\nflags2 = tvb_get_guint8(tvb, 1);\r\nproto_tree_add_item(ntp_tree, hf_ntpctrl_sequence, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nassocid = tvb_get_ntohs(tvb, 6);\r\nif (flags2 & NTPCTRL_R_MASK) {\r\nif (flags2 & NTPCTRL_ERROR_MASK) {\r\nstatic const int *errorstatus[] = {\r\n&hf_ntpctrl_error_status_word,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(ntp_tree, tvb, 4, hf_ntpctrl_status, ett_ntpctrl_status, errorstatus, ENC_BIG_ENDIAN);\r\n} else {\r\nswitch (flags2 & NTPCTRL_OP_MASK) {\r\ncase NTPCTRL_OP_READSTAT:\r\ncase NTPCTRL_OP_READVAR:\r\ncase NTPCTRL_OP_WRITEVAR:\r\ncase NTPCTRL_OP_ASYNCMSG:\r\nif (associd)\r\nproto_tree_add_bitmask(ntp_tree, tvb, 4, hf_ntpctrl_status, ett_ntpctrl_status, peer_status_flags, ENC_BIG_ENDIAN);\r\nelse\r\n{\r\nstatic const int *systemstatus[] = {\r\n&hf_ntpctrl_sys_status_li,\r\n&hf_ntpctrl_sys_status_clksrc,\r\n&hf_ntpctrl_sys_status_count,\r\n&hf_ntpctrl_sys_status_code,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(ntp_tree, tvb, 4, hf_ntpctrl_status, ett_ntpctrl_status, systemstatus, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase NTPCTRL_OP_READCLOCK:\r\ncase NTPCTRL_OP_WRITECLOCK:\r\n{\r\nstatic const int *clockstatus[] = {\r\n&hf_ntpctrl_clk_status,\r\n&hf_ntpctrl_clk_status_code,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(ntp_tree, tvb, 4, hf_ntpctrl_status, ett_ntpctrl_status, clockstatus, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase NTPCTRL_OP_SETTRAP:\r\ncase NTPCTRL_OP_UNSETTRAP:\r\ndefault:\r\nproto_tree_add_item(ntp_tree, hf_ntpctrl_status, tvb, 4, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(ntp_tree, hf_ntpctrl_status, tvb, 4, 2, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item(ntp_tree, hf_ntpctrl_associd, tvb, 6, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ntp_tree, hf_ntpctrl_offset, tvb, 8, 2, ENC_BIG_ENDIAN);\r\ndatalen = tvb_get_ntohs(tvb, 10);\r\nproto_tree_add_uint(ntp_tree, hf_ntpctrl_count, tvb, 10, 2, datalen);\r\nif (datalen) {\r\ndata_offset = 12;\r\ntd = proto_tree_add_item(ntp_tree, hf_ntpctrl_data, tvb, data_offset, datalen, ENC_NA);\r\ndata_tree = proto_item_add_subtree(td, ett_ntpctrl_data);\r\nswitch(flags2 & NTPCTRL_OP_MASK) {\r\ncase NTPCTRL_OP_READSTAT:\r\nif (!associd) {\r\nwhile(datalen) {\r\nti = proto_tree_add_item(data_tree, hf_ntpctrl_item, tvb, data_offset, 4, ENC_NA);\r\nitem_tree = proto_item_add_subtree(ti, ett_ntpctrl_item);\r\nproto_tree_add_item(item_tree, hf_ntpctrl_associd, tvb, data_offset, 2, ENC_BIG_ENDIAN);\r\ndata_offset += 2;\r\nproto_tree_add_bitmask(ntp_tree, tvb, data_offset, hf_ntpctrl_status, ett_ntpctrl_status, peer_status_flags, ENC_BIG_ENDIAN);\r\ndata_offset += 2;\r\ndatalen -= 4;\r\n}\r\nbreak;\r\n}\r\ncase NTPCTRL_OP_READVAR:\r\ncase NTPCTRL_OP_WRITEVAR:\r\ncase NTPCTRL_OP_READCLOCK:\r\ncase NTPCTRL_OP_WRITECLOCK:\r\ntt = tvbparse_init(tvb, data_offset, datalen, NULL, want_ignore);\r\nwhile( (element = tvbparse_get(tt, want)) != NULL ) {\r\ntvbparse_tree_add_elem(data_tree, element);\r\n}\r\nbreak;\r\ncase NTPCTRL_OP_ASYNCMSG:\r\nproto_tree_add_item(data_tree, hf_ntpctrl_trapmsg, tvb, data_offset, datalen, ENC_ASCII|ENC_NA);\r\nbreak;\r\n}\r\n}\r\ndata_offset = 12+datalen;\r\nlength_remaining = tvb_reported_length_remaining(tvb, data_offset);\r\nif ((flags2 & NTPCTRL_R_MASK) == 0)\r\n{\r\nif (length_remaining > 0)\r\n{\r\nauth_tree = proto_tree_add_subtree(ntp_tree, tvb, data_offset, -1, ett_ntp_authenticator, NULL, "Authenticator");\r\nswitch (length_remaining)\r\n{\r\ncase 20:\r\nti = proto_tree_add_uint(auth_tree, hf_ntp_key_type, tvb, data_offset, 0, NTP_MD5_ALGO);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nproto_tree_add_item(auth_tree, hf_ntp_key_index, tvb, data_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(auth_tree, hf_ntp_key_signature, tvb, data_offset+4, 16, ENC_NA);\r\nbreak;\r\ncase 24:\r\nti = proto_tree_add_uint(auth_tree, hf_ntp_key_type, tvb, data_offset, 0, NTP_SHA_ALGO);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nproto_tree_add_item(auth_tree, hf_ntp_key_index, tvb, data_offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(auth_tree, hf_ntp_key_signature, tvb, data_offset+4, 20, ENC_NA);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\ninit_parser(void)\r\n{\r\ntvbparse_wanted_t *want_identifier = tvbparse_chars(-1, 1, 0,\r\n"abcdefghijklmnopqrstuvwxyz-_ABCDEFGHIJKLMNOPQRSTUVWXYZ.0123456789", NULL, NULL, NULL);\r\ntvbparse_wanted_t *want_equalsign = tvbparse_char(-1, "=", NULL, NULL, NULL);\r\ntvbparse_wanted_t *want_value = tvbparse_set_oneof(0, NULL, NULL, NULL,\r\ntvbparse_quoted(-1, NULL, NULL, tvbparse_shrink_token_cb, '\"', '\\'),\r\ntvbparse_quoted(-1, NULL, NULL, tvbparse_shrink_token_cb, '\'', '\\'),\r\ntvbparse_chars(-1, 1, 0, "abcdefghijklmnopqrstuvwxyz-_ABCDEFGHIJKLMNOPQRSTUVWXYZ.0123456789 ", NULL, NULL, NULL),\r\nNULL);\r\ntvbparse_wanted_t *want_comma = tvbparse_until(-1, NULL, NULL, NULL,\r\ntvbparse_char(-1, ",", NULL, NULL, NULL), TP_UNTIL_SPEND);\r\ntvbparse_wanted_t *want_assignment = tvbparse_set_seq(-1, NULL, NULL, NULL,\r\nwant_identifier,\r\nwant_equalsign,\r\ntvbparse_some(-1, 0, 1, NULL, NULL, NULL, want_value),\r\ntvbparse_some(-1, 0, 1, NULL, NULL, NULL, want_comma),\r\nNULL);\r\nwant_ignore = tvbparse_chars(-1, 1, 0, " \t\r\n", NULL, NULL, NULL);\r\nwant = tvbparse_set_oneof(-1, NULL, NULL, NULL,\r\nwant_assignment,\r\nwant_identifier,\r\nNULL);\r\n}\r\nstatic void\r\ndissect_ntp_priv(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *ntp_tree)\r\n{\r\nguint8 impl, reqcode;\r\nstatic const int *priv_flags[] = {\r\n&hf_ntppriv_flags_r,\r\n&hf_ntppriv_flags_more,\r\n&hf_ntp_flags_vn,\r\n&hf_ntp_flags_mode,\r\nNULL\r\n};\r\nstatic const int *auth_flags[] = {\r\n&hf_ntppriv_auth,\r\n&hf_ntppriv_seq,\r\nNULL\r\n};\r\nproto_tree_add_bitmask(ntp_tree, tvb, 0, hf_ntp_flags, ett_ntp_flags, priv_flags, ENC_NA);\r\nproto_tree_add_bitmask(ntp_tree, tvb, 0, hf_ntppriv_auth_seq, ett_ntppriv_auth_seq, auth_flags, ENC_NA);\r\nimpl = tvb_get_guint8(tvb, 2);\r\nproto_tree_add_uint(ntp_tree, hf_ntppriv_impl, tvb, 2, 1, impl);\r\nreqcode = tvb_get_guint8(tvb, 3);\r\nproto_tree_add_uint(ntp_tree, hf_ntppriv_reqcode, tvb, 3, 1, reqcode);\r\nif (impl == XNTPD && reqcode == MON_GETLIST_1) {\r\nguint16 numitems;\r\nguint16 itemsize;\r\nguint16 offset;\r\nguint i;\r\nguint32 v6_flag = 0;\r\nproto_item* monlist_item;\r\nproto_tree* monlist_item_tree;\r\nproto_tree_add_bits_item(ntp_tree, hf_ntppriv_errcode, tvb, 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(ntp_tree, hf_ntppriv_numitems, tvb, 36, 12, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(ntp_tree, hf_ntppriv_mbz, tvb, 48, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(ntp_tree, hf_ntppriv_itemsize, tvb, 52, 12, ENC_BIG_ENDIAN);\r\nnumitems = tvb_get_letohs(tvb, 5) & 0x0FFF;\r\nitemsize = tvb_get_letohs(tvb, 7) & 0x0FFF;\r\nfor (i = 0; i < numitems; i++) {\r\noffset = 8 + itemsize * i;\r\nmonlist_item = proto_tree_add_string_format(ntp_tree, hf_monlist_item, tvb, offset,\r\nitemsize, "Monlist Item", "Monlist item: address: %s:%u",\r\ntvb_ip_to_str(tvb, offset + 16), tvb_get_ntohs(tvb, offset + 28));\r\nmonlist_item_tree = proto_item_add_subtree(monlist_item, ett_monlist_item);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_avgint, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_lsint, tvb, offset + 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_restr, tvb, offset + 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_count, tvb, offset + 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_addr, tvb, offset + 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_daddr, tvb, offset + 20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_flags, tvb, offset + 24, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_port, tvb, offset + 28, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_mode, tvb, offset + 30, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_version, tvb, offset + 31, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item_ret_uint(monlist_item_tree, hf_ntppriv_v6_flag, tvb, offset + 32, 4, ENC_BIG_ENDIAN, &v6_flag);\r\nif (v6_flag != 0) {\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_addr6, tvb, offset + 36, 16, ENC_NA);\r\nproto_tree_add_item(monlist_item_tree, hf_ntppriv_daddr6, tvb, offset + 52, 16, ENC_NA);\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\ndissect_ntp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *ntp_tree;\r\nproto_item *ti = NULL;\r\nguint8 flags;\r\nvoid (*dissector)(tvbuff_t *, packet_info *, proto_tree *);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NTP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nflags = tvb_get_guint8(tvb, 0);\r\nswitch (flags & NTP_MODE_MASK) {\r\ndefault:\r\ndissector = dissect_ntp_std;\r\nbreak;\r\ncase NTP_MODE_CTRL:\r\ndissector = dissect_ntp_ctrl;\r\nbreak;\r\ncase NTP_MODE_PRIV:\r\ndissector = dissect_ntp_priv;\r\nbreak;\r\n}\r\nti = proto_tree_add_item(tree, proto_ntp, tvb, 0, -1, ENC_NA);\r\nntp_tree = proto_item_add_subtree(ti, ett_ntp);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s, %s",\r\nval_to_str_const((flags & NTP_VN_MASK) >> 3, ver_nums,\r\n"Unknown version"),\r\nval_to_str_const(flags & NTP_MODE_MASK, info_mode_types, "Unknown"));\r\nproto_item_append_text(ti, " (%s, %s)",\r\nval_to_str_const((flags & NTP_VN_MASK) >> 3, ver_nums,\r\n"Unknown version"),\r\nval_to_str_const(flags & NTP_MODE_MASK, info_mode_types, "Unknown"));\r\n(*dissector)(tvb, pinfo, ntp_tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ntp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ntp_flags, {\r\n"Flags", "ntp.flags", FT_UINT8, BASE_HEX,\r\nNULL, 0, "Flags (Leap/Version/Mode)", HFILL }},\r\n{ &hf_ntp_flags_li, {\r\n"Leap Indicator", "ntp.flags.li", FT_UINT8, BASE_DEC,\r\nVALS(li_types), NTP_LI_MASK, "Warning of an impending leap second to be inserted or deleted in the last minute of the current month", HFILL }},\r\n{ &hf_ntp_flags_vn, {\r\n"Version number", "ntp.flags.vn", FT_UINT8, BASE_DEC,\r\nVALS(ver_nums), NTP_VN_MASK, NULL, HFILL }},\r\n{ &hf_ntp_flags_mode, {\r\n"Mode", "ntp.flags.mode", FT_UINT8, BASE_DEC,\r\nVALS(mode_types), NTP_MODE_MASK, NULL, HFILL }},\r\n{ &hf_ntp_stratum, {\r\n"Peer Clock Stratum", "ntp.stratum", FT_UINT8, BASE_DEC|BASE_RANGE_STRING,\r\nRVALS(stratum_rvals), 0, NULL, HFILL }},\r\n{ &hf_ntp_ppoll, {\r\n"Peer Polling Interval", "ntp.ppoll", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Maximum interval between successive messages", HFILL }},\r\n{ &hf_ntp_precision, {\r\n"Peer Clock Precision", "ntp.precision", FT_INT8, BASE_DEC,\r\nNULL, 0, "The precision of the system clock", HFILL }},\r\n{ &hf_ntp_rootdelay, {\r\n"Root Delay", "ntp.rootdelay", FT_DOUBLE, BASE_NONE,\r\nNULL, 0, "Total round-trip delay to the reference clock", HFILL }},\r\n{ &hf_ntp_rootdispersion, {\r\n"Root Dispersion", "ntp.rootdispersion", FT_DOUBLE, BASE_NONE,\r\nNULL, 0, "Total dispersion to the reference clock", HFILL }},\r\n{ &hf_ntp_refid, {\r\n"Reference ID", "ntp.refid", FT_BYTES, BASE_NONE,\r\nNULL, 0, "Particular server or reference clock being used", HFILL }},\r\n{ &hf_ntp_reftime, {\r\n"Reference Timestamp", "ntp.reftime", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC,\r\nNULL, 0, "Time when the system clock was last set or corrected", HFILL }},\r\n{ &hf_ntp_org, {\r\n"Origin Timestamp", "ntp.org", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC,\r\nNULL, 0, "Time at the client when the request departed for the server", HFILL }},\r\n{ &hf_ntp_rec, {\r\n"Receive Timestamp", "ntp.rec", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC,\r\nNULL, 0, "Time at the server when the request arrived from the client", HFILL }},\r\n{ &hf_ntp_xmt, {\r\n"Transmit Timestamp", "ntp.xmt", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC,\r\nNULL, 0, "Time at the server when the response left for the client", HFILL }},\r\n{ &hf_ntp_keyid, {\r\n"Key ID", "ntp.keyid", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_mac, {\r\n"Message Authentication Code", "ntp.mac", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_key_type, {\r\n"Key type", "ntp.key_type", FT_UINT8, BASE_DEC,\r\nVALS(authentication_types), 0, "Authentication algorithm used", HFILL }},\r\n{ &hf_ntp_key_index, {\r\n"KeyIndex", "ntp.key_index", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_key_signature, {\r\n"Signature", "ntp.key_signature", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_ext, {\r\n"Extension", "ntp.ext", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_ext_flags, {\r\n"Flags", "ntp.ext.flags", FT_UINT8, BASE_HEX,\r\nNULL, 0, "Flags (Response/Error/Version)", HFILL }},\r\n{ &hf_ntp_ext_flags_r, {\r\n"Response bit", "ntp.ext.flags.r", FT_UINT8, BASE_DEC,\r\nVALS(ext_r_types), NTP_EXT_R_MASK, NULL, HFILL }},\r\n{ &hf_ntp_ext_flags_error, {\r\n"Error bit", "ntp.ext.flags.error", FT_UINT8, BASE_DEC,\r\nNULL, NTP_EXT_ERROR_MASK, NULL, HFILL }},\r\n{ &hf_ntp_ext_flags_vn, {\r\n"Version", "ntp.ext.flags.vn", FT_UINT8, BASE_DEC,\r\nNULL, NTP_EXT_VN_MASK, NULL, HFILL }},\r\n{ &hf_ntp_ext_op, {\r\n"Opcode", "ntp.ext.op", FT_UINT8, BASE_DEC,\r\nVALS(ext_op_types), 0, NULL, HFILL }},\r\n{ &hf_ntp_ext_len, {\r\n"Extension length", "ntp.ext.len", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_ext_associd, {\r\n"Association ID", "ntp.ext.associd", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_ext_tstamp, {\r\n"Timestamp", "ntp.ext.tstamp", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_ext_fstamp, {\r\n"File Timestamp", "ntp.ext.fstamp", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_ext_vallen, {\r\n"Value length", "ntp.ext.vallen", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_ext_val, {\r\n"Value", "ntp.ext.val", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_ext_siglen, {\r\n"Signature length", "ntp.ext.siglen", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntp_ext_sig, {\r\n"Signature", "ntp.ext.sig", FT_BYTES, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntpctrl_flags2, {\r\n"Flags 2", "ntp.ctrl.flags2", FT_UINT8, BASE_HEX,\r\nNULL, 0, "Flags (Response/Error/More/Opcode)", HFILL }},\r\n{ &hf_ntpctrl_flags2_r, {\r\n"Response bit", "ntp.ctrl.flags2.r", FT_UINT8, BASE_DEC,\r\nVALS(ctrl_r_types), NTPCTRL_R_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_flags2_error, {\r\n"Error bit", "ntp.ctrl.flags2.error", FT_UINT8, BASE_DEC,\r\nNULL, NTPCTRL_ERROR_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_flags2_more, {\r\n"More bit", "ntp.ctrl.flags2.more", FT_UINT8, BASE_DEC,\r\nNULL, NTPCTRL_MORE_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_flags2_opcode, {\r\n"Opcode", "ntp.ctrl.flags2.opcode", FT_UINT8, BASE_DEC,\r\nVALS(ctrl_op_types), NTPCTRL_OP_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_sequence, {\r\n"Sequence", "ntp.ctrl.sequence", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntpctrl_status, {\r\n"Status", "ntp.ctrl.status", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntpctrl_error_status_word, {\r\n"Error Status Word", "ntp.ctrl.err_status", FT_UINT16, BASE_DEC,\r\nVALS(ctrl_err_status_types), NTP_CTRL_ERRSTATUS_CODE_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_sys_status_li, {\r\n"Leap Indicator", "ntp.ctrl.sys_status.li", FT_UINT16, BASE_DEC,\r\nVALS(li_types), NTPCTRL_SYSSTATUS_LI_MASK, "Warning of an impending leap second to be inserted or deleted in the last minute of the current month", HFILL }},\r\n{ &hf_ntpctrl_sys_status_clksrc, {\r\n"Clock Source", "ntp.ctrl.sys_status.clksrc", FT_UINT16, BASE_DEC,\r\nVALS(ctrl_sys_status_clksource_types), NTPCTRL_SYSSTATUS_CLK_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_sys_status_count, {\r\n"System Event Counter", "ntp.ctrl.sys_status.count", FT_UINT16, BASE_DEC,\r\nNULL, NTPCTRL_SYSSTATUS_COUNT_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_sys_status_code, {\r\n"System Event Code", "ntp.ctrl.sys_status.code", FT_UINT16, BASE_DEC,\r\nVALS(ctrl_sys_status_event_types), NTPCTRL_SYSSTATUS_CODE_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_peer_status_b0, {\r\n"Peer Status", "ntp.ctrl.peer_status.config", FT_BOOLEAN, 16,\r\nTFS(&tfs_ctrl_peer_status_config), NTPCTRL_PEERSTATUS_CONFIG_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_peer_status_b1, {\r\n"Peer Status", "ntp.ctrl.peer_status.authenable", FT_BOOLEAN, 16,\r\nTFS(&tfs_ctrl_peer_status_authenable), NTPCTRL_PEERSTATUS_AUTHENABLE_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_peer_status_b2, {\r\n"Peer Status", "ntp.ctrl.peer_status.authentic", FT_BOOLEAN, 16,\r\nTFS(&tfs_ctrl_peer_status_authentic), NTPCTRL_PEERSTATUS_AUTHENTIC_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_peer_status_b3, {\r\n"Peer Status", "ntp.ctrl.peer_status.reach", FT_BOOLEAN, 16,\r\nTFS(&tfs_ctrl_peer_status_reach), NTPCTRL_PEERSTATUS_REACH_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_peer_status_b4, {\r\n"Peer Status: reserved", "ntp.ctrl.peer_status.reserved", FT_UINT16, BASE_DEC,\r\nNULL, NTPCTRL_PEERSTATUS_RESERVED_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_peer_status_selection, {\r\n"Peer Selection", "ntp.ctrl.peer_status.selection", FT_UINT16, BASE_DEC,\r\nVALS(ctrl_peer_status_selection_types), NTPCTRL_PEERSTATUS_SEL_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_peer_status_count, {\r\n"Peer Event Counter", "ntp.ctrl.peer_status.count", FT_UINT16, BASE_DEC,\r\nNULL, NTPCTRL_PEERSTATUS_COUNT_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_peer_status_code, {\r\n"Peer Event Code", "ntp.ctrl.peer_status.code", FT_UINT16, BASE_DEC,\r\nVALS(ctrl_peer_status_event_types), NTPCTRL_PEERSTATUS_CODE_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_clk_status, {\r\n"Clock Status", "ntp.ctrl.clock_status.status", FT_UINT16, BASE_DEC,\r\nVALS(ctrl_clk_status_types), NTPCTRL_CLKSTATUS_STATUS_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_clk_status_code, {\r\n"Clock Event Code", "ntp.ctrl.clock_status.code", FT_UINT16, BASE_DEC,\r\nNULL, NTPCTRL_CLKSTATUS_CODE_MASK, NULL, HFILL }},\r\n{ &hf_ntpctrl_data, {\r\n"Data", "ntp.ctrl.data", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntpctrl_item, {\r\n"Item", "ntp.ctrl.item", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntpctrl_associd, {\r\n"AssociationID", "ntp.ctrl.associd", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntpctrl_offset, {\r\n"Offset", "ntp.ctrl.offset", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntpctrl_count, {\r\n"Count", "ntp.ctrl.count", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntpctrl_trapmsg, {\r\n"Trap message", "ntp.ctrl.trapmsg", FT_STRING, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_flags_r, {\r\n"Response bit", "ntp.priv.flags.r", FT_UINT8, BASE_DEC,\r\nVALS(priv_r_types), NTPPRIV_R_MASK, NULL, HFILL }},\r\n{ &hf_ntppriv_flags_more, {\r\n"More bit", "ntp.priv.flags.more", FT_UINT8, BASE_DEC,\r\nNULL, NTPPRIV_MORE_MASK, NULL, HFILL }},\r\n{ &hf_ntppriv_auth_seq, {\r\n"Auth, sequence", "ntp.priv.auth_seq", FT_UINT8, BASE_DEC,\r\nNULL, 0, "Auth bit, sequence number", HFILL }},\r\n{ &hf_ntppriv_auth, {\r\n"Auth bit", "ntp.priv.auth", FT_UINT8, BASE_DEC,\r\nNULL, NTPPRIV_AUTH_MASK, NULL, HFILL }},\r\n{ &hf_ntppriv_seq, {\r\n"Sequence number", "ntp.priv.seq", FT_UINT8, BASE_DEC,\r\nNULL, NTPPRIV_SEQ_MASK, NULL, HFILL }},\r\n{ &hf_ntppriv_impl, {\r\n"Implementation", "ntp.priv.impl", FT_UINT8, BASE_DEC,\r\nVALS(priv_impl_types), 0, NULL, HFILL }},\r\n{ &hf_ntppriv_reqcode, {\r\n"Request code", "ntp.priv.reqcode", FT_UINT8, BASE_DEC | BASE_EXT_STRING,\r\n&priv_rc_types_ext, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_errcode, {\r\n"Err", "ntp.priv.err", FT_UINT8, BASE_HEX,\r\nVALS(err_values_types), 0, NULL, HFILL }},\r\n{ &hf_ntppriv_numitems, {\r\n"Number of data items", "ntp.priv.numitems", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_mbz, {\r\n"Reserved", "ntp.priv.reserved", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_monlist_item, {\r\n"Monlist item", "ntp.priv.monlist.item",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x00, NULL, HFILL }},\r\n{ &hf_ntppriv_itemsize, {\r\n"Size of data item", "ntp.priv.monlist.itemsize", FT_UINT16, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_avgint, {\r\n"avgint", "ntp.priv.monlist.avgint", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_lsint, {\r\n"lsint", "ntp.priv.monlist.lsint", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_restr, {\r\n"restr", "ntp.priv.monlist.restr", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_count, {\r\n"count", "ntp.priv.monlist.count", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_addr, {\r\n"remote address", "ntp.priv.monlist.remote_address", FT_IPv4, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_daddr, {\r\n"local address", "ntp.priv.monlist.local_address", FT_IPv4, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_flags, {\r\n"flags", "ntp.priv.monlist.flags", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_port, {\r\n"port", "ntp.priv.monlist.port", FT_UINT16, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_mode, {\r\n"mode", "ntp.priv.monlist.mode", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_version, {\r\n"version", "ntp.priv.monlist.version", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_v6_flag, {\r\n"ipv6", "ntp.priv.monlist.ipv6", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_addr6, {\r\n"ipv6 remote addr", "ntp.priv.monlist.addr6", FT_IPv6, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_ntppriv_daddr6, {\r\n"ipv6 local addr", "ntp.priv.monlist.daddr6", FT_IPv6, BASE_NONE,\r\nNULL, 0, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ntp,\r\n&ett_ntp_flags,\r\n&ett_ntp_ext,\r\n&ett_ntp_ext_flags,\r\n&ett_ntpctrl_flags2,\r\n&ett_ntpctrl_status,\r\n&ett_ntpctrl_data,\r\n&ett_ntpctrl_item,\r\n&ett_ntppriv_auth_seq,\r\n&ett_monlist_item,\r\n&ett_ntp_authenticator\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ntp_ext, { "ntp.ext.invalid_length", PI_PROTOCOL, PI_WARN, "Extension invalid length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ntp;\r\nproto_ntp = proto_register_protocol("Network Time Protocol", "NTP",\r\n"ntp");\r\nproto_register_field_array(proto_ntp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ntp = expert_register_protocol(proto_ntp);\r\nexpert_register_field_array(expert_ntp, ei, array_length(ei));\r\ninit_parser();\r\n}\r\nvoid\r\nproto_reg_handoff_ntp(void)\r\n{\r\ndissector_handle_t ntp_handle;\r\nntp_handle = create_dissector_handle(dissect_ntp, proto_ntp);\r\ndissector_add_uint("udp.port", UDP_PORT_NTP, ntp_handle);\r\ndissector_add_uint("tcp.port", TCP_PORT_NTP, ntp_handle);\r\n}
