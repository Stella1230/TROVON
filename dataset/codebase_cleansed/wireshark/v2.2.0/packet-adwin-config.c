static void\r\ndissect_UDPStatus(tvbuff_t *tvb, proto_tree *adwin_tree)\r\n{\r\nproto_tree *debug_tree;\r\nproto_item *dt;\r\nstatic const int * status_flags[] = {\r\n&hf_adwin_config_status_bootloader,\r\n&hf_adwin_config_status_reprogrammable,\r\n&hf_adwin_config_status_configurable,\r\n&hf_adwin_config_status_bootloader_boots,\r\n&hf_adwin_config_status_bootloader_reprogrammable,\r\n&hf_adwin_config_status_bootloader_receive,\r\n&hf_adwin_config_status_bootloader_reprogramming_done,\r\n&hf_adwin_config_status_eeprom_support,\r\nNULL\r\n};\r\nif (! adwin_tree)\r\nreturn;\r\ndt = proto_tree_add_item(adwin_tree, proto_adwin_config, tvb, 0, -1, ENC_NA);\r\ndebug_tree = proto_item_add_subtree(dt, ett_adwin_config_debug);\r\nproto_item_set_text(dt, "ADwin Debug information");\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_pattern, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_version, tvb, 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_bitmask(adwin_tree, tvb, 8, hf_adwin_config_status, ett_adwin_config_status, status_flags, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_server_version_beta, tvb, 12, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_server_version, tvb, 14, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_xilinx_version, tvb, 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_mac, tvb, 20, 6, ENC_NA);\r\nproto_tree_add_item(debug_tree, hf_adwin_config_unused, tvb, 26, 2, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_port16, tvb, 28, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_dhcp, tvb, 30, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_netmask_count, tvb, 31, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_gateway, tvb, 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(debug_tree, hf_adwin_config_unused, tvb, 36, 11, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_reply_broadcast, tvb, 47, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_scan_id, tvb, 48, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nstatic void\r\ndissect_UDPExtStatus(tvbuff_t *tvb, proto_tree *adwin_tree)\r\n{\r\nconst gchar *processor_type, *system_type;\r\nif (! adwin_tree)\r\nreturn;\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_mac, tvb, 0, 6, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 6, 2, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_pattern, tvb, 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_version, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_description, tvb, 16, 16, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_timerresets, tvb, 32, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_socketshutdowns, tvb, 36, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_disk_free, tvb, 40, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_disk_size, tvb, 44, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_date, tvb, 48, 8, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_revision, tvb, 56, 8, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_processor_type_raw, tvb, 64, 2, ENC_ASCII|ENC_NA);\r\nprocessor_type = tvb_get_string_enc(wmem_packet_scope(), tvb, 64, 2, ENC_ASCII|ENC_NA);\r\nprocessor_type = str_to_str(processor_type, processor_type_mapping, "Unknown (%s)");\r\nproto_tree_add_string(adwin_tree, hf_adwin_config_processor_type, tvb, 64, 2, processor_type);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_system_type_raw, tvb, 66, 2, ENC_ASCII|ENC_NA);\r\nsystem_type = tvb_get_string_enc(wmem_packet_scope(), tvb, 66, 2, ENC_ASCII|ENC_NA);\r\nsystem_type = str_to_str(system_type, system_type_mapping, "Unknown (%s)");\r\nproto_tree_add_string(adwin_tree, hf_adwin_config_system_type, tvb, 66, 2, system_type);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 68, 364, ENC_NA);\r\n}\r\nstatic void\r\ndissect_UDPMessage(tvbuff_t *tvb, proto_tree *adwin_tree)\r\n{\r\nconst gchar *processor_type, *system_type;\r\nif (! adwin_tree)\r\nreturn;\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_command, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_version, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_mac, tvb, 8, 6, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 14, 2, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_server_ip, tvb, 16, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 20, 4, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_netmask, tvb, 24, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 28, 4, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_gateway, tvb, 32, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 36, 4, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_dhcp, tvb, 40, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_port32, tvb, 44, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_password, tvb, 48, 10, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_bootloader, tvb, 58, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 59, 5, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_description, tvb, 64, 16, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_date, tvb, 80, 8, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_revision, tvb, 88, 8, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_processor_type_raw, tvb, 96, 2, ENC_ASCII|ENC_NA);\r\nprocessor_type = tvb_get_string_enc(wmem_packet_scope(), tvb, 96, 2, ENC_ASCII|ENC_NA);\r\nprocessor_type = str_to_str(processor_type, processor_type_mapping, "Unknown");\r\nproto_tree_add_string(adwin_tree, hf_adwin_config_processor_type, tvb, 96, 2, processor_type);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_system_type_raw, tvb, 98, 2, ENC_ASCII|ENC_NA);\r\nsystem_type = tvb_get_string_enc(wmem_packet_scope(), tvb, 98, 2, ENC_ASCII|ENC_NA);\r\nsystem_type = str_to_str(system_type, system_type_mapping, "Unknown");\r\nproto_tree_add_string(adwin_tree, hf_adwin_config_system_type, tvb, 98, 2, system_type);\r\n}\r\nstatic void\r\ndissect_UDPInitAck(tvbuff_t *tvb, proto_tree *adwin_tree)\r\n{\r\nif (! adwin_tree)\r\nreturn;\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_pattern, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_reboot, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_mac, tvb, 8, 6, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 14, 2, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 16, 80, ENC_NA);\r\n}\r\nstatic void\r\ndissect_UDPIXP425FlashUpdate(tvbuff_t *tvb, proto_tree *adwin_tree)\r\n{\r\nif (! adwin_tree)\r\nreturn;\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_pattern, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_version, tvb, 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_scan_id, tvb, 8, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_status, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_timeout, tvb, 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_filename, tvb, 20, 24, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_mac, tvb, 44, 6, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, 50, 42, ENC_NA);\r\n}\r\nstatic void\r\ndissect_UDPOut(tvbuff_t *tvb, proto_tree *adwin_tree)\r\n{\r\nif (! adwin_tree)\r\nreturn;\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_status, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_mac, tvb, 4, 6, ENC_NA);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_netmask, tvb, 10, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_gateway, tvb, 14, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_dhcp, tvb, 18, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_port16, tvb, 20, 2, ENC_BIG_ENDIAN);\r\n}\r\nstatic guint\r\nget_adwin_TCPUpdate_len(packet_info *pinfo _U_, tvbuff_t *tvb,\r\nint offset, void *data _U_)\r\n{\r\nreturn tvb_get_ntohl(tvb, offset);\r\n}\r\nstatic int\r\ndissect_TCPFlashUpdate(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *adwin_tree;\r\nproto_item *ti;\r\ngint length, offset;\r\nguint8 *filename;\r\nnstime_t tmp_time;\r\ntmp_time.nsecs = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ADwin Config");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "TCPFlashUpdate");\r\nti = proto_tree_add_item(tree, proto_adwin_config, tvb, 0, -1, ENC_NA);\r\nadwin_tree = proto_item_add_subtree(ti, ett_adwin_config);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_stream_length, tvb, 0, 4, ENC_BIG_ENDIAN);\r\noffset = 4;\r\nlength = tvb_strnlen(tvb, offset, -1) + 1;\r\nfilename = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, length, ENC_ASCII|ENC_NA);\r\nif (strncmp(filename, "eeprom_on", length) == 0) {\r\nproto_tree_add_boolean(adwin_tree, hf_adwin_config_eeprom_support, tvb, offset, length, TRUE);\r\nreturn offset+length;\r\n}\r\nif (strncmp(filename, "eeprom_off", length) == 0) {\r\nproto_tree_add_boolean(adwin_tree, hf_adwin_config_eeprom_support, tvb, offset, length, FALSE);\r\nreturn offset+length;\r\n}\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_filename, tvb, 4, length, ENC_ASCII|ENC_NA);\r\noffset += length;\r\nlength = tvb_strnlen(tvb, 4 + length, -1) + 1;\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_path, tvb, offset, length, ENC_ASCII|ENC_NA);\r\noffset += length;\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_filesize, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ntmp_time.secs = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_time(adwin_tree, hf_adwin_config_filetime, tvb, offset, 4, &tmp_time);\r\noffset += 4;\r\ntmp_time.secs = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_time(adwin_tree, hf_adwin_config_updatetime, tvb, offset, 4, &tmp_time);\r\noffset += 4;\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_unused, tvb, offset, 128, ENC_NA);\r\noffset += 128;\r\nlength = tvb_captured_length_remaining(tvb, offset);\r\nproto_tree_add_item(adwin_tree, hf_adwin_config_data, tvb, offset, length, ENC_NA);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\nis_adwin_mac_or_broadcast(address mac)\r\n{\r\nif (mac.type != AT_ETHER)\r\nreturn FALSE;\r\nif (mac.len != 6)\r\nreturn FALSE;\r\nif ((memcmp(mac.data, mac_iab_start, mac.len) >= 0) &&\r\n(memcmp(mac.data, mac_iab_end , mac.len) <= 0))\r\nreturn TRUE;\r\nif ((memcmp(mac.data, mac_oui_start, mac.len) >= 0) &&\r\n(memcmp(mac.data, mac_oui_end, mac.len) <= 0))\r\nreturn TRUE;\r\nif (memcmp(mac.data, mac_broadcast, mac.len) == 0)\r\nreturn TRUE;\r\nreturn FALSE;\r\n}\r\nstatic int\r\ndissect_adwin_config_udp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *adwin_config_tree;\r\nguint32 length;\r\nlength = tvb_reported_length(tvb);\r\nif (!(length == UDPStatusLENGTH\r\n|| length == UDPExtStatusLENGTH\r\n|| length == UDPMessageLENGTH\r\n|| length == UDPMessageLENGTH_wrong\r\n|| length == UDPInitAckLENGTH\r\n|| length == UDPIXP425FlashUpdateLENGTH\r\n|| length == UDPOutLENGTH))\r\nreturn 0;\r\nif (! (is_adwin_mac_or_broadcast(pinfo->dl_src) || is_adwin_mac_or_broadcast(pinfo->dl_dst)))\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ADwin Config");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_adwin_config, tvb, 0, -1, ENC_NA);\r\nadwin_config_tree = proto_item_add_subtree(ti, ett_adwin_config);\r\nswitch (length) {\r\ncase UDPStatusLENGTH:\r\ndissect_UDPStatus(tvb, adwin_config_tree);\r\nbreak;\r\ncase UDPExtStatusLENGTH:\r\ndissect_UDPExtStatus(tvb, adwin_config_tree);\r\nbreak;\r\ncase UDPMessageLENGTH:\r\ndissect_UDPMessage(tvb, adwin_config_tree);\r\nbreak;\r\ncase UDPMessageLENGTH_wrong:\r\ndissect_UDPMessage(tvb, adwin_config_tree);\r\nbreak;\r\ncase UDPInitAckLENGTH:\r\ndissect_UDPInitAck(tvb, adwin_config_tree);\r\nbreak;\r\ncase UDPIXP425FlashUpdateLENGTH:\r\ndissect_UDPIXP425FlashUpdate(tvb, adwin_config_tree);\r\nbreak;\r\ncase UDPOutLENGTH:\r\ndissect_UDPOut(tvb, adwin_config_tree);\r\nbreak;\r\ndefault:\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(length, length_mapping,\r\n"Unknown ADwin Configuration packet, length: %d"));\r\n}\r\nreturn (tvb_reported_length(tvb));\r\n}\r\nstatic int\r\ndissect_adwin_config_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nif(!(pinfo->srcport == ADWIN_CONFIGURATION_PORT\r\n|| pinfo->destport == ADWIN_CONFIGURATION_PORT))\r\nreturn 0;\r\nif (! (is_adwin_mac_or_broadcast(pinfo->dl_src) || is_adwin_mac_or_broadcast(pinfo->dl_dst)))\r\nreturn 0;\r\ntcp_dissect_pdus(tvb, pinfo, tree, 1, 4, get_adwin_TCPUpdate_len, dissect_TCPFlashUpdate, NULL);\r\nreturn (tvb_reported_length(tvb));\r\n}\r\nvoid\r\nproto_register_adwin_config(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_adwin_config_bootloader,\r\n{ "Enable Bootloader", "adwin_config.bootloader",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_command,\r\n{ "Command", "adwin_config.command",\r\nFT_UINT32, BASE_DEC, VALS(config_command_mapping), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_data,\r\n{ "Data", "adwin_config.data",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_date,\r\n{ "Date", "adwin_config.date",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_description,\r\n{ "Description", "adwin_config.description",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_dhcp,\r\n{ "DHCP enabled", "adwin_config.dhcp",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_filename,\r\n{ "File name", "adwin_config.filename",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_filesize,\r\n{ "File size", "adwin_config.filesize",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_filetime,\r\n{ "File time", "adwin_config.filetime",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_updatetime,\r\n{ "Update time", "adwin_config.updatetime",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_gateway,\r\n{ "Gateway IP", "adwin_config.gateway",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_mac,\r\n{ "MAC address", "adwin_config.mac",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_netmask,\r\n{ "Netmask", "adwin_config.netmask",\r\nFT_IPv4, BASE_NETMASK, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_netmask_count,\r\n{ "Netmask count", "adwin_config.netmask_count",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The number of binary ones in the netmask.", HFILL }\r\n},\r\n{ &hf_adwin_config_password,\r\n{ "Password", "adwin_config.password",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Password to set for ADwin system.", HFILL }\r\n},\r\n{ &hf_adwin_config_pattern,\r\n{ "Pattern", "adwin_config.pattern",\r\nFT_UINT32, BASE_HEX, VALS(pattern_mapping), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_path,\r\n{ "Path", "adwin_config.path",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_port16,\r\n{ "Port (16bit)", "adwin_config.port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"The server port on which the ADwin system is listening on (16bit).", HFILL }\r\n},\r\n{ &hf_adwin_config_port32,\r\n{ "Port (32bit)", "adwin_config.port",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The server port on which the ADwin system is listening on (32bit).", HFILL }\r\n},\r\n{ &hf_adwin_config_reboot,\r\n{ "Reboot", "adwin_config.reboot",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Number of system reboots.", HFILL }\r\n},\r\n{ &hf_adwin_config_scan_id,\r\n{ "Scan ID", "adwin_config.scan_id",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_reply_broadcast,\r\n{ "Reply with broadcast", "adwin_config.reply_broadcast",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"If this bit is set, the scanned system should reply with a broadcast.", HFILL }\r\n},\r\n{ &hf_adwin_config_revision,\r\n{ "Revision", "adwin_config.revision",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_processor_type_raw,\r\n{ "Processor Type (Raw value)", "adwin_config.processor_type_raw",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"The DSP processor type of the ADwin system, e.g. T9, T10 or T11.", HFILL }\r\n},\r\n{ &hf_adwin_config_system_type_raw,\r\n{ "System Type (Raw value)", "adwin_config.system_type_raw",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"The system type of the ADwin system, e.g. Gold, Pro or Light.", HFILL }\r\n},\r\n{ &hf_adwin_config_processor_type,\r\n{ "Processor Type", "adwin_config.processor_type",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_system_type,\r\n{ "System Type", "adwin_config.system_type",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_server_ip,\r\n{ "Server IP", "adwin_config.server_ip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"In scan replies, this is the current IP address of the ADwin system. In configuration packets, this is the new IP to be used by the ADwin system.", HFILL }\r\n},\r\n{ &hf_adwin_config_server_version,\r\n{ "Server version", "adwin_config.server_version",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The version number of the server program. This number represents the complete firmware version, e.g. 2.74.", HFILL }\r\n},\r\n{ &hf_adwin_config_server_version_beta,\r\n{ "server version (beta part)", "adwin_config.server_version_beta",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"A non-zero value of this field indicates a beta firmware version, where this number represents the current revision.", HFILL }\r\n},\r\n{ &hf_adwin_config_socketshutdowns,\r\n{ "Socket shutdowns", "adwin_config.socketshutdowns",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of socket errors that lead to a recreation of the socket (ethernet interface version 1 only).", HFILL }\r\n},\r\n{ &hf_adwin_config_status,\r\n{ "Status", "adwin_config.status",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_status_bootloader,\r\n{ "Status Bootloader", "adwin_config.status_bootloader",\r\nFT_BOOLEAN, 32, NULL, STATUS_WITH_BOOTLOADER,\r\n"Indicates if the ADwin system has bootloader capabilities.", HFILL }\r\n},\r\n{ &hf_adwin_config_status_reprogrammable,\r\n{ "Status Reprogrammable",\r\n"adwin_config.status_reprogrammable",\r\nFT_BOOLEAN, 32, NULL, STATUS_REPROGRAMMABLE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_status_configurable,\r\n{ "Status Configurable", "adwin_config.status_configurable",\r\nFT_BOOLEAN, 32, NULL, STATUS_CONFIGURABLE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_status_bootloader_boots,\r\n{ "Status Bootloader boots",\r\n"adwin_config.status_bootloader_boots",\r\nFT_BOOLEAN, 32, NULL, STATUS_BOOTLOADER_BOOTS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_status_bootloader_reprogrammable,\r\n{ "Status Bootloader reprogrammable",\r\n"adwin_config.status_bootloader_reprogrammable",\r\nFT_BOOLEAN, 32, NULL, STATUS_BOOTLOADER_REPROGRAMMABLE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_status_bootloader_receive,\r\n{ "Status Bootloader receive",\r\n"adwin_config.status_bootloader_receive",\r\nFT_BOOLEAN, 32, NULL, STATUS_BOOTLOADER_RECEIVES_DATA,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_status_bootloader_reprogramming_done,\r\n{ "Status Bootloader reprogramming done",\r\n"adwin_config.status_bootloader_reprogramming_done",\r\nFT_BOOLEAN, 32, NULL, STATUS_BOOTLOADER_REPROGRAMMING_DONE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_status_eeprom_support,\r\n{ "Status EEPROM Support",\r\n"adwin_config.status_eeprom_support",\r\nFT_BOOLEAN, 32, NULL, STATUS_WITH_EEPROM_SUPPORT,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_stream_length,\r\n{ "Stream length", "adwin_config.stream_length",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_eeprom_support,\r\n{ "EEPROM Support", "adwin_config.eeprom_support",\r\nFT_BOOLEAN, BASE_NONE, TFS(&tfs_enabled_disabled), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_timeout,\r\n{ "Timeout", "adwin_config.timeout",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_timerresets,\r\n{ "Timer resets", "adwin_config.timerresets",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Counter for resets of the timer (ethernet interface version 1 only).", HFILL }\r\n},\r\n{ &hf_adwin_config_disk_free,\r\n{ "Free disk space (kb)", "adwin_config.disk_free",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Free disk space in kb on flash (ethernet interface version 2 only).", HFILL }\r\n},\r\n{ &hf_adwin_config_disk_size,\r\n{ "Disk size (kb)", "adwin_config.disk_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Flash disk size in kb (ethernet interface version 2 only).", HFILL }\r\n},\r\n{ &hf_adwin_config_unused,\r\n{ "Unused", "adwin_config.unused",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_version,\r\n{ "Version", "adwin_config.version",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_adwin_config_xilinx_version,\r\n{ "XILINX Version", "adwin_config.xilinx_version",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Version of XILINX program", HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_adwin_config,\r\n&ett_adwin_config_status,\r\n&ett_adwin_config_debug,\r\n};\r\nproto_adwin_config =\r\nproto_register_protocol("ADwin configuration protocol",\r\n"ADwin-Config", "adwin_config");\r\nproto_register_field_array(proto_adwin_config, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_adwin_config(void)\r\n{\r\nheur_dissector_add("udp", dissect_adwin_config_udp, "ADwin-Config over UDP", "adwin_config_udp", proto_adwin_config, HEURISTIC_ENABLE);\r\nheur_dissector_add("tcp", dissect_adwin_config_tcp, "ADwin-Config over TCP", "adwin_config_tcp", proto_adwin_config, HEURISTIC_ENABLE);\r\n}
