static gint\r\ndissect_btavctp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *ti;\r\nproto_tree *btavctp_tree;\r\nproto_item *pitem;\r\nproto_item *ipid_item = NULL;\r\nbtavctp_data_t *avctp_data;\r\ntvbuff_t *next_tvb;\r\ngint offset = 0;\r\nguint packet_type;\r\nguint cr;\r\nguint pid = 0;\r\nguint transaction;\r\nguint number_of_packets = 0;\r\nguint length;\r\nguint i_frame;\r\ngboolean ipid = FALSE;\r\nguint32 interface_id;\r\nguint32 adapter_id;\r\nguint32 chandle;\r\nguint32 psm;\r\ngint previous_proto;\r\nprevious_proto = (GPOINTER_TO_INT(wmem_list_frame_data(wmem_list_frame_prev(wmem_list_tail(pinfo->layers)))));\r\nif (previous_proto == proto_btl2cap) {\r\nbtl2cap_data_t *l2cap_data;\r\nl2cap_data = (btl2cap_data_t *) data;\r\ninterface_id = l2cap_data->interface_id;\r\nadapter_id = l2cap_data->adapter_id;\r\nchandle = l2cap_data->chandle;\r\npsm = l2cap_data->psm;\r\n} else {\r\ninterface_id = HCI_INTERFACE_DEFAULT;\r\nadapter_id = HCI_ADAPTER_DEFAULT;\r\nchandle = 0;\r\npsm = 0;\r\n}\r\nti = proto_tree_add_item(tree, proto_btavctp, tvb, offset, tvb_captured_length_remaining(tvb, offset), ENC_NA);\r\nbtavctp_tree = proto_item_add_subtree(ti, ett_btavctp);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "AVCTP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");\r\nbreak;\r\n}\r\nproto_tree_add_item(btavctp_tree, hf_btavctp_transaction, tvb, offset, 1, ENC_BIG_ENDIAN);\r\npitem = proto_tree_add_item(btavctp_tree, hf_btavctp_packet_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(btavctp_tree, hf_btavctp_cr, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ntransaction = tvb_get_guint8(tvb, offset) >> 4;\r\npacket_type = (tvb_get_guint8(tvb, offset) & 0x0C) >> 2;\r\ncr = (tvb_get_guint8(tvb, offset) & 0x02) >> 1 ;\r\nif (packet_type == PACKET_TYPE_SINGLE || packet_type == PACKET_TYPE_START) {\r\nipid_item = proto_tree_add_item(btavctp_tree, hf_btavctp_ipid, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nipid = tvb_get_guint8(tvb, offset) & 0x01;\r\n} else {\r\nproto_tree_add_item(btavctp_tree, hf_btavctp_rfa, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset++;\r\nif (packet_type == PACKET_TYPE_START) {\r\nproto_tree_add_item(btavctp_tree, hf_btavctp_number_of_packets, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nnumber_of_packets = tvb_get_guint8(tvb, offset);\r\noffset++;\r\n}\r\nif (packet_type == PACKET_TYPE_SINGLE || packet_type == PACKET_TYPE_START) {\r\nproto_tree_add_item(btavctp_tree, hf_btavctp_pid, tvb, offset, 2, ENC_BIG_ENDIAN);\r\npid = tvb_get_ntohs(tvb, offset);\r\nif (p_get_proto_data(pinfo->pool, pinfo, proto_bluetooth, PROTO_DATA_BLUETOOTH_SERVICE_UUID ) == NULL) {\r\nguint8 *value_data;\r\nbluetooth_uuid_t uuid;\r\nuuid.size = 2;\r\nuuid.bt_uuid = pid;\r\nuuid.data[0] = pid >> 8;\r\nuuid.data[1] = pid & 0xFF;\r\nvalue_data = wmem_strdup(wmem_file_scope(), print_numeric_uuid(&uuid));\r\np_add_proto_data(pinfo->pool, pinfo, proto_bluetooth, PROTO_DATA_BLUETOOTH_SERVICE_UUID, value_data);\r\n}\r\noffset +=2;\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s - Transaction: %u, PacketType: %s",\r\nval_to_str_const(cr, cr_vals, "unknown CR"), transaction,\r\nval_to_str_const(packet_type, packet_type_vals, "unknown packet type"));\r\nif (ipid) {\r\nexpert_add_info(pinfo, ipid_item, &ei_btavctp_invalid_profile);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Invalid profile");\r\nif (tvb_captured_length_remaining(tvb, offset) == 0)\r\nreturn offset;\r\n}\r\navctp_data = wmem_new(wmem_packet_scope(), btavctp_data_t);\r\navctp_data->cr = cr;\r\navctp_data->interface_id = interface_id;\r\navctp_data->adapter_id = adapter_id;\r\navctp_data->chandle = chandle;\r\navctp_data->psm = psm;\r\nlength = tvb_reported_length_remaining(tvb, offset);\r\nnext_tvb = tvb_new_subset_length(tvb, offset, length);\r\nif (packet_type == PACKET_TYPE_SINGLE) {\r\nbluetooth_uuid_t uuid;\r\nuuid.size = 2;\r\nuuid.bt_uuid = pid;\r\nuuid.data[0] = pid >> 8;\r\nuuid.data[1] = pid & 0xFF;\r\nif (!dissector_try_string(bluetooth_uuid_table, print_numeric_uuid(&uuid), next_tvb, pinfo, tree, avctp_data)) {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\n} else {\r\nfragment_t *fragment;\r\nwmem_tree_key_t key[6];\r\nguint32 frame_number;\r\nframe_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &psm;\r\nkey[4].length = 1;\r\nkey[4].key = &frame_number;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nif (packet_type == PACKET_TYPE_START) {\r\nif (!pinfo->fd->flags.visited) {\r\nfragment = wmem_new(wmem_file_scope(), fragment_t);\r\nfragment->length = length;\r\nfragment->data = (guint8 *) wmem_alloc(wmem_file_scope(), fragment->length);\r\ntvb_memcpy(tvb, fragment->data, offset, fragment->length);\r\nfragments = wmem_new(wmem_file_scope(), fragments_t);\r\nfragments->number_of_packets = number_of_packets;\r\nfragments->pid = pid;\r\nfragments->count = 1;\r\nfragments->fragment = wmem_tree_new(wmem_file_scope());\r\nwmem_tree_insert32(fragments->fragment, fragments->count, fragment);\r\nfragments->interface_id = interface_id;\r\nfragments->adapter_id = adapter_id;\r\nfragments->chandle = chandle;\r\nfragments->psm = psm;\r\nwmem_tree_insert32_array(reassembling, key, fragments);\r\n} else {\r\nfragments = (fragments_t *)wmem_tree_lookup32_array_le(reassembling, key);\r\nif (!(fragments && fragments->interface_id == interface_id &&\r\nfragments->adapter_id == adapter_id &&\r\nfragments->chandle == chandle &&\r\nfragments->psm == psm))\r\nfragments = NULL;\r\n}\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n} else if (packet_type == PACKET_TYPE_CONTINUE) {\r\nfragments = (fragments_t *)wmem_tree_lookup32_array_le(reassembling, key);\r\nif (!(fragments && fragments->interface_id == interface_id &&\r\nfragments->adapter_id == adapter_id &&\r\nfragments->chandle == chandle &&\r\nfragments->psm == psm))\r\nfragments = NULL;\r\nif (!pinfo->fd->flags.visited && fragments != NULL) {\r\nfragment = wmem_new(wmem_file_scope(), fragment_t);\r\nfragment->length = length;\r\nfragment->data = (guint8 *) wmem_alloc(wmem_file_scope(), fragment->length);\r\ntvb_memcpy(tvb, fragment->data, offset, fragment->length);\r\nfragments->count++;\r\nwmem_tree_insert32(fragments->fragment, fragments->count, fragment);\r\nfragments->interface_id = interface_id;\r\nfragments->adapter_id = adapter_id;\r\nfragments->chandle = chandle;\r\nfragments->psm = psm;\r\nframe_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &psm;\r\nkey[4].length = 1;\r\nkey[4].key = &frame_number;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nwmem_tree_insert32_array(reassembling, key, fragments);\r\n}\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n} else if (packet_type == PACKET_TYPE_END) {\r\nguint i_length = 0;\r\nfragments = (fragments_t *)wmem_tree_lookup32_array_le(reassembling, key);\r\nif (!(fragments && fragments->interface_id == interface_id &&\r\nfragments->adapter_id == adapter_id &&\r\nfragments->chandle == chandle &&\r\nfragments->psm == psm))\r\nfragments = NULL;\r\nif (!pinfo->fd->flags.visited && fragments != NULL) {\r\nfragment = wmem_new(wmem_file_scope(), fragment_t);\r\nfragment->length = length;\r\nfragment->data = (guint8 *) wmem_alloc(wmem_file_scope(), fragment->length);\r\ntvb_memcpy(tvb, fragment->data, offset, fragment->length);\r\nfragments->count++;\r\nwmem_tree_insert32(fragments->fragment, fragments->count, fragment);\r\nfragments->interface_id = interface_id;\r\nfragments->adapter_id = adapter_id;\r\nfragments->chandle = chandle;\r\nfragments->psm = psm;\r\nframe_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &psm;\r\nkey[4].length = 1;\r\nkey[4].key = &frame_number;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nwmem_tree_insert32_array(reassembling, key, fragments);\r\n}\r\nlength = 0;\r\nif (!fragments || fragments->count != fragments->number_of_packets) {\r\nexpert_add_info(pinfo, pitem, &ei_btavctp_unexpected_frame);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n} else {\r\nguint8 *reassembled;\r\nbluetooth_uuid_t uuid;\r\nfor (i_frame = 1; i_frame <= fragments->count; ++i_frame) {\r\nfragment = (fragment_t *)wmem_tree_lookup32_le(fragments->fragment, i_frame);\r\nlength += fragment->length;\r\n}\r\nreassembled = (guint8 *) wmem_alloc(pinfo->pool, length);\r\nfor (i_frame = 1; i_frame <= fragments->count; ++i_frame) {\r\nfragment = (fragment_t *)wmem_tree_lookup32_le(fragments->fragment, i_frame);\r\nmemcpy(reassembled + i_length,\r\nfragment->data,\r\nfragment->length);\r\ni_length += fragment->length;\r\n}\r\nnext_tvb = tvb_new_child_real_data(tvb, reassembled, length, length);\r\nadd_new_data_source(pinfo, next_tvb, "Reassembled AVCTP");\r\nuuid.size = 2;\r\nuuid.bt_uuid = fragments->pid;\r\nuuid.data[0] = fragments->pid >> 8;\r\nuuid.data[1] = fragments->pid & 0xFF;\r\nif (!dissector_try_string(bluetooth_uuid_table, print_numeric_uuid(&uuid), next_tvb, pinfo, tree, avctp_data)) {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\n}\r\nfragments = NULL;\r\n} else {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_btavctp(void)\r\n{\r\nmodule_t *module;\r\nexpert_module_t* expert_btavctp;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_btavctp_transaction,\r\n{ "Transaction", "btavctp.transaction",\r\nFT_UINT8, BASE_HEX, NULL, 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavctp_packet_type,\r\n{ "Packet Type", "btavctp.packet_type",\r\nFT_UINT8, BASE_HEX, VALS(packet_type_vals), 0x0C,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavctp_cr,\r\n{ "C/R", "btavctp.cr",\r\nFT_UINT8, BASE_HEX, VALS(cr_vals), 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavctp_ipid,\r\n{ "IPID", "btavctp.ipid",\r\nFT_UINT8, BASE_HEX, VALS(ipid_vals), 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavctp_rfa,\r\n{ "RFA", "btavctp.rfa",\r\nFT_UINT8, BASE_HEX, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavctp_pid,\r\n{ "Profile Identifier", "btavctp.pid",\r\nFT_UINT16, BASE_HEX|BASE_EXT_STRING, &bluetooth_uuid_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavctp_number_of_packets,\r\n{ "Number of packets", "btavctp.nop",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btavctp\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_btavctp_unexpected_frame, { "btavctp.unexpected_frame", PI_PROTOCOL, PI_WARN, "Unexpected frame", EXPFILL }},\r\n{ &ei_btavctp_invalid_profile, { "btavctp.invalid_profile", PI_PROTOCOL, PI_NOTE, "Invalid Profile", EXPFILL }},\r\n};\r\nreassembling = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\nproto_btavctp = proto_register_protocol("Bluetooth AVCTP Protocol", "BT AVCTP", "btavctp");\r\nbtavctp_handle = register_dissector("btavctp", dissect_btavctp, proto_btavctp);\r\nproto_register_field_array(proto_btavctp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_btavctp = expert_register_protocol(proto_btavctp);\r\nexpert_register_field_array(expert_btavctp, ei, array_length(ei));\r\nmodule = prefs_register_protocol(proto_btavctp, NULL);\r\nprefs_register_static_text_preference(module, "avctp.version",\r\n"Bluetooth Protocol AVCTP version: 1.4",\r\n"Version of protocol supported by this dissector.");\r\n}\r\nvoid\r\nproto_reg_handoff_btavctp(void)\r\n{\r\ndissector_add_string("bluetooth.uuid", "17", btavctp_handle);\r\ndissector_add_uint("btl2cap.psm", BTL2CAP_PSM_AVCTP_CTRL, btavctp_handle);\r\ndissector_add_uint("btl2cap.psm", BTL2CAP_PSM_AVCTP_BRWS, btavctp_handle);\r\ndissector_add_for_decode_as("btl2cap.cid", btavctp_handle);\r\n}
