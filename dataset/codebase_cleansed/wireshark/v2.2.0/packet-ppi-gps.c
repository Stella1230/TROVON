static int\r\ndissect_ppi_gps(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nguint length;\r\ngint length_remaining;\r\nint offset = 0;\r\nproto_tree *ppi_gps_tree = NULL;\r\nproto_item *version_item, *length_item, *pt;\r\nproto_item *gps_line = NULL;\r\nstatic const int * ppi_gps_present_flags[] = {\r\n&hf_ppi_gps_present_gpsflags_flags,\r\n&hf_ppi_gps_present_lat,\r\n&hf_ppi_gps_present_lon,\r\n&hf_ppi_gps_present_alt,\r\n&hf_ppi_gps_present_alt_gnd,\r\n&hf_ppi_gps_present_gpstime,\r\n&hf_ppi_gps_present_fractime,\r\n&hf_ppi_gps_present_eph,\r\n&hf_ppi_gps_present_epv,\r\n&hf_ppi_gps_present_ept,\r\n&hf_ppi_gps_present_descr,\r\n&hf_ppi_gps_present_appspecific_num,\r\n&hf_ppi_gps_present_appspecific_data,\r\n&hf_ppi_gps_present_ext,\r\nNULL\r\n};\r\nstatic const int * ppi_antenna_gps_flags[] = {\r\n&hf_ppi_gps_gpsflags_flag0_nofix,\r\n&hf_ppi_gps_gpsflags_flag1_gpsfix,\r\n&hf_ppi_gps_gpsflags_flag2_diffgps,\r\n&hf_ppi_gps_gpsflags_flag3_PPS,\r\n&hf_ppi_gps_gpsflags_flag4_RTK,\r\n&hf_ppi_gps_gpsflags_flag5_floatRTK,\r\n&hf_ppi_gps_gpsflags_flag6_dead_reck,\r\n&hf_ppi_gps_gpsflags_flag7_manual,\r\n&hf_ppi_gps_gpsflags_flag8_sim,\r\nNULL\r\n};\r\nint bit;\r\nguint32 present, next_present;\r\nguint32 version;\r\ngdouble lat, lon, alt, alt_gnd;\r\nnstime_t gps_timestamp;\r\nint gps_time_size, already_processed_fractime;\r\ngdouble eph, epv, ept;\r\ngchar *curr_str;\r\nguint32 t_lat, t_lon, t_alt, t_alt_gnd;\r\nguint32 t_herr, t_verr, t_terr;\r\nguint32 t_appspecific_num;\r\ngps_timestamp.secs = gps_timestamp.nsecs = already_processed_fractime = 0;\r\ncol_clear(pinfo->cinfo,COL_INFO);\r\nversion = tvb_get_guint8(tvb, offset);\r\nlength = tvb_get_letohs(tvb, offset+2);\r\npresent = tvb_get_letohl(tvb, offset+4);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "PPI_GPS Capture v%u, Length %u", version, length);\r\ngps_line = proto_tree_add_protocol_format(tree, proto_ppi_gps, tvb, 0, length, "GPS:");\r\nppi_gps_tree = proto_item_add_subtree(gps_line, ett_ppi_gps);\r\nversion_item = proto_tree_add_uint(ppi_gps_tree, hf_ppi_gps_version, tvb, offset, 1, version);\r\nproto_tree_add_item(ppi_gps_tree, hf_ppi_gps_pad, tvb, offset + 1, 1, ENC_LITTLE_ENDIAN);\r\nlength_item = proto_tree_add_uint(ppi_gps_tree, hf_ppi_gps_length, tvb, offset + 2, 2, length);\r\nif (! (version == 1 || version == 2) ) {\r\nexpert_add_info_format(pinfo, version_item, &ei_ppi_gps_version, "Invalid version (got %d, expected 1 or 2)", version);\r\n}\r\nlength_remaining = length;\r\nif (length_remaining < PPI_GEOBASE_MIN_HEADER_LEN) {\r\nexpert_add_info_format(pinfo, length_item, &ei_ppi_gps_length, "Invalid PPI-GPS length - minimum length is 8");\r\nreturn 2;\r\n}\r\nif (length > PPI_GPS_MAXTAGLEN ) {\r\nexpert_add_info_format(pinfo, length_item, &ei_ppi_gps_length, "Invalid PPI-GPS length (got %d, %d max\n)", length, PPI_GPS_MAXTAGLEN);\r\nreturn 2;\r\n}\r\npt = proto_tree_add_bitmask(ppi_gps_tree, tvb, offset + 4, hf_ppi_gps_present, ett_ppi_gps_present, ppi_gps_present_flags, ENC_LITTLE_ENDIAN);\r\noffset += PPI_GEOBASE_MIN_HEADER_LEN;\r\nlength_remaining -= PPI_GEOBASE_MIN_HEADER_LEN;\r\nfor (; present; present = next_present) {\r\nnext_present = present & (present - 1);\r\nbit = BITNO_32(present ^ next_present);\r\nswitch (bit) {\r\ncase PPI_GEOTAG_GPSFLAGS:\r\nif (length_remaining < 4)\r\nbreak;\r\nproto_tree_add_bitmask(ppi_gps_tree, tvb, offset, hf_ppi_gps_gpsflags_flags, ett_ppi_gps_gpsflags_flags, ppi_antenna_gps_flags, ENC_LITTLE_ENDIAN);\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_GEOTAG_LAT:\r\nif (length_remaining < 4)\r\nbreak;\r\nt_lat = tvb_get_letohl(tvb, offset);\r\nlat = ppi_fixed3_7_to_gdouble(t_lat);\r\nif (tree)\r\n{\r\nproto_tree_add_double(ppi_gps_tree, hf_ppi_gps_lat, tvb, offset, 4, lat);\r\nproto_item_append_text(gps_line, " Lat:%f ", lat);\r\n}\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_GEOTAG_LON:\r\nif (length_remaining < 4)\r\nbreak;\r\nt_lon = tvb_get_letohl(tvb, offset);\r\nlon = ppi_fixed3_7_to_gdouble(t_lon);\r\nif (tree)\r\n{\r\nproto_tree_add_double(ppi_gps_tree, hf_ppi_gps_lon, tvb, offset, 4, lon);\r\nproto_item_append_text(gps_line, " Lon:%f ", lon);\r\n}\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_GEOTAG_ALT:\r\nif (length_remaining < 4)\r\nbreak;\r\nt_alt = tvb_get_letohl(tvb, offset);\r\nalt = ppi_fixed6_4_to_gdouble(t_alt);\r\nif (tree)\r\n{\r\nproto_tree_add_double(ppi_gps_tree, hf_ppi_gps_alt, tvb, offset, 4, alt);\r\nproto_item_append_text(gps_line, " Alt:%f ", alt);\r\n}\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_GEOTAG_ALT_G:\r\nif (length_remaining < 4)\r\nbreak;\r\nt_alt_gnd = tvb_get_letohl(tvb, offset);\r\nalt_gnd = ppi_fixed6_4_to_gdouble(t_alt_gnd);\r\nif (tree)\r\n{\r\nproto_tree_add_double(ppi_gps_tree, hf_ppi_gps_alt_gnd, tvb, offset, 4, alt_gnd);\r\nproto_item_append_text(gps_line, " Alt_g:%f ", alt_gnd);\r\n}\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_GEOTAG_GPSTIME:\r\nif (length_remaining < 4)\r\nbreak;\r\ngps_timestamp.secs = tvb_get_letohl(tvb, offset);\r\ngps_timestamp.nsecs = 0;\r\ngps_time_size = 4;\r\nif (length_remaining < 4 && (present & PPI_GPS_MASK_FRACTIME))\r\nbreak;\r\nelse if (present & PPI_GPS_MASK_FRACTIME) {\r\ngps_timestamp.nsecs = tvb_get_letohl(tvb, offset + 4);\r\nalready_processed_fractime = 1;\r\ngps_time_size = 8;\r\n}\r\nproto_tree_add_time(ppi_gps_tree, hf_ppi_gps_gpstime, tvb, offset, gps_time_size, &gps_timestamp);\r\noffset += gps_time_size;\r\nlength_remaining -= gps_time_size;\r\nbreak;\r\ncase PPI_GEOTAG_FRACTIONALTIME:\r\nif (length_remaining < 4)\r\nbreak;\r\nif (already_processed_fractime)\r\nbreak;\r\nbreak;\r\ncase PPI_GEOTAG_EPH:\r\nif (length_remaining < 4)\r\nbreak;\r\nt_herr = tvb_get_letohl(tvb, offset);\r\neph = ppi_fixed3_6_to_gdouble(t_herr);\r\nproto_tree_add_double(ppi_gps_tree, hf_ppi_gps_eph, tvb, offset, 4, eph);\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_GEOTAG_EPV:\r\nif (length_remaining < 4)\r\nbreak;\r\nt_verr = tvb_get_letohl(tvb, offset);\r\nepv = ppi_fixed3_6_to_gdouble(t_verr);\r\nproto_tree_add_double(ppi_gps_tree, hf_ppi_gps_epv, tvb, offset, 4, epv);\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_GEOTAG_EPT:\r\nif (length_remaining < 4)\r\nbreak;\r\nt_terr = tvb_get_letohl(tvb, offset);\r\nept = ppi_ns_counter_to_gdouble(t_terr);\r\nproto_tree_add_double(ppi_gps_tree, hf_ppi_gps_ept, tvb, offset, 4, ept);\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_GEOTAG_DESCRIPTIONSTR:\r\nif (length_remaining < 32)\r\nbreak;\r\nif (tree)\r\n{\r\ncurr_str = tvb_format_stringzpad(tvb, offset, 32);\r\nproto_tree_add_string(ppi_gps_tree, hf_ppi_gps_descstr, tvb, offset, 32, curr_str);\r\nproto_item_append_text(gps_line, " (%s)", curr_str);\r\n}\r\noffset+=32;\r\nlength_remaining-=32;\r\nbreak;\r\ncase PPI_GEOTAG_APPID:\r\nif (length_remaining < 4)\r\nbreak;\r\nt_appspecific_num = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint(ppi_gps_tree, hf_ppi_gps_appspecific_num, tvb, offset, 4, t_appspecific_num);\r\noffset+=4;\r\nlength_remaining-=4;\r\nbreak;\r\ncase PPI_GEOTAG_APPDATA:\r\nif (length_remaining < 60)\r\nbreak;\r\nproto_tree_add_item(ppi_gps_tree, hf_ppi_gps_appspecific_data, tvb, offset, 60, ENC_NA);\r\noffset+=60;\r\nlength_remaining-=60;\r\nbreak;\r\ndefault:\r\nnext_present = 0;\r\nexpert_add_info_format(pinfo, pt, &ei_ppi_gps_present_bit,\r\n"Error: PPI-GEOLOCATION-GPS: unknown bit (%d) set in present field.", bit);\r\ncontinue;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ppi_gps(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ppi_gps_version,\r\n{ "Header revision", "ppi_gps.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Version of ppi_gps header format", HFILL } },\r\n{ &hf_ppi_gps_pad,\r\n{ "Header pad", "ppi_gps.pad",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Padding", HFILL } },\r\n{ &hf_ppi_gps_length,\r\n{ "Header length", "ppi_gps.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Length of header including version, pad, length and data fields", HFILL } },\r\n{ &hf_ppi_gps_present,\r\n{ "Present", "ppi_gps.present",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Bitmask indicating which fields are present", HFILL } },\r\n{ &hf_ppi_gps_present_gpsflags_flags,\r\n{ "GPSFlags", "ppi_gps.present.gpsflagss",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_GPSFLAGS,\r\n"32-bit bitmask indicating type of GPS fix (GPS/INS/software/etc)", HFILL } },\r\n{ &hf_ppi_gps_present_lat,\r\n{ "Lat", "ppi_gps.present.lat",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_LAT,\r\n"Specifies if the latitude field is present", HFILL } },\r\n{ &hf_ppi_gps_present_lon,\r\n{ "Lon", "ppi_gps.present.lon",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_LON,\r\n"Specifies if the longitude field is present", HFILL } },\r\n{ &hf_ppi_gps_present_alt,\r\n{ "Alt", "ppi_gps.present.alt",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_ALT,\r\n"Specifies if the altitude field is present", HFILL } },\r\n{ &hf_ppi_gps_present_alt_gnd,\r\n{ "Alt-gnd", "ppi_gps.present.alt_gnd",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_ALT_G,\r\n"Specifies if the altitude-g field is present", HFILL } },\r\n{ &hf_ppi_gps_present_gpstime,\r\n{ "GPStime", "ppi_gps.present.gpstime",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_GPSTIME,\r\n"Specifies if the GPS time field is present", HFILL } },\r\n{ &hf_ppi_gps_present_fractime,\r\n{ "fractime", "ppi_gps.present.fractime",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_FRACTIME,\r\n"Specifies if the fractional time field is present", HFILL } },\r\n{ &hf_ppi_gps_present_eph,\r\n{ "error_h", "ppi_gps.present.eph",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_EPH,\r\n"Specifies if the horizontal error field is present (eph)", HFILL } },\r\n{ &hf_ppi_gps_present_epv,\r\n{ "error_v", "ppi_gps.present.epv",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_EPV,\r\n"Specifies if the vertical error field present (epv)", HFILL } },\r\n{ &hf_ppi_gps_present_ept,\r\n{ "error_t", "ppi_gps.present.ept",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_EPT,\r\n"Specifies if the estimated time error field is present (ept)", HFILL } },\r\n{ &hf_ppi_gps_present_descr,\r\n{ "Description", "ppi_gps.present.descr",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_DESCRSTR,\r\n"Specifies if the (ASCII) description is present", HFILL } },\r\n{ &hf_ppi_gps_present_appspecific_num,\r\n{ "AppId", "ppi_gps.present.appid",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_APPID,\r\n"Specifies if the application specific field id is present", HFILL } },\r\n{ &hf_ppi_gps_present_appspecific_data,\r\n{ "AppData", "ppi_gps.present.appdata",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_APPDATA,\r\n"Specifies if the application specific data field is present", HFILL } },\r\n{ &hf_ppi_gps_present_ext,\r\n{ "Ext", "ppi_gps.present.ext",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_MASK_EXT,\r\n"Specifies if there are any extensions to the header present", HFILL } },\r\n{ &hf_ppi_gps_gpsflags_flags,\r\n{ "GPSFlags", "ppi_gps.gpsflags",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\n"Bitmask indicating GPS/INS/manual fix", HFILL } },\r\n{ &hf_ppi_gps_lat,\r\n{ "Latitude", "ppi_gps.lat",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Latitude packet was received at", HFILL } },\r\n{ &hf_ppi_gps_lon,\r\n{ "Longitude", "ppi_gps.lon",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Longitude packet was received at", HFILL } },\r\n{ &hf_ppi_gps_alt,\r\n{ "Altitude", "ppi_gps.alt",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Altitude packet was received at", HFILL } },\r\n{ &hf_ppi_gps_alt_gnd,\r\n{ "Altitude_gnd", "ppi_gps.alt_gnd",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Altitude packet was received at (relative to ground)", HFILL } },\r\n{ &hf_ppi_gps_gpstime,\r\n{ "GPSTimestamp", "ppi_gps.gpstime",\r\nFT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0x0,\r\n"GPSTimestamp packet was received at", HFILL } },\r\n#if 0\r\n{ &hf_ppi_gps_fractime,\r\n{ "fractional Timestamp", "ppi_gps.fractime",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"fractional GPSTimestamp packet was received at", HFILL } },\r\n#endif\r\n{ &hf_ppi_gps_eph,\r\n{ "Horizontal Error (m)", "ppi_gps.eph",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Horizontal margin of error (meters)", HFILL } },\r\n{ &hf_ppi_gps_epv,\r\n{ "Vertical Error (m)", "ppi_gps.epv",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Vertical margin of error (meters)", HFILL } },\r\n{ &hf_ppi_gps_ept,\r\n{ "Time Error (s)", "ppi_gps.ept",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x0,\r\n"Time margin of error (secs)", HFILL } },\r\n{ &hf_ppi_gps_descstr,\r\n{ "Description", "ppi_gps.descr",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_appspecific_num,\r\n{ "Application Specific id", "ppi_gps.appid",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_appspecific_data,\r\n{ "Application specific data", "ppi_gps.appdata",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL } },\r\n#define PPI_GPS_GPSFLAGS_FLAG0_NOFIX 0x00000001\r\n#define PPI_GPS_GPSFLAGS_FLAG1_GPS 0x00000002\r\n#define PPI_GPS_GPSFLAGS_FLAG2_DIFFGPS 0x00000004\r\n#define PPI_GPS_GPSFLAGS_FLAG3_PPS 0x00000008\r\n#define PPI_GPS_GPSFLAGS_FLAG4_RTK 0x00000010\r\n#define PPI_GPS_GPSFLAGS_FLAG5_FLOATRTK 0x00000020\r\n#define PPI_GPS_GPSFLAGS_FLAG6_DEAD_RECK 0x00000040\r\n#define PPI_GPS_GPSFLAGS_FLAG7_MANUAL 0x00000080\r\n#define PPI_GPS_GPSFLAGS_FLAG8_SIM 0x00000100\r\n{ &hf_ppi_gps_gpsflags_flag0_nofix,\r\n{ "No fix available", "ppi_gps.gpsflagss.nofix",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_GPSFLAGS_FLAG0_NOFIX,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_gpsflags_flag1_gpsfix,\r\n{ "GPS provided fix", "ppi_gps.gpsflagss.gps",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_GPSFLAGS_FLAG1_GPS,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_gpsflags_flag2_diffgps,\r\n{ "Differential GPS provided fix", "ppi_gps.gpsflagss.diffgps",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_GPSFLAGS_FLAG2_DIFFGPS,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_gpsflags_flag3_PPS,\r\n{ "PPS fix", "ppi_gps.gpsflagss.pps",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_GPSFLAGS_FLAG3_PPS,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_gpsflags_flag4_RTK,\r\n{ "RTK fix", "ppi_gps.gpsflagss.rtk",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_GPSFLAGS_FLAG4_RTK,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_gpsflags_flag5_floatRTK,\r\n{ "floatRTK fix", "ppi_gps.gpsflagss.frtk",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_GPSFLAGS_FLAG5_FLOATRTK,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_gpsflags_flag6_dead_reck,\r\n{ "dead reckoning fix", "ppi_gps.gpsflagss.dead_reck",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_GPSFLAGS_FLAG6_DEAD_RECK,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_gpsflags_flag7_manual,\r\n{ "manual fix", "ppi_gps.gpsflagss.manual",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_GPSFLAGS_FLAG7_MANUAL,\r\nNULL, HFILL } },\r\n{ &hf_ppi_gps_gpsflags_flag8_sim,\r\n{ "simulated fix", "ppi_gps.gpsflagss.simulation",\r\nFT_BOOLEAN, 32, NULL, PPI_GPS_GPSFLAGS_FLAG8_SIM,\r\nNULL, HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ppi_gps,\r\n&ett_ppi_gps_present,\r\n&ett_ppi_gps_gpsflags_flags\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ppi_gps_present_bit, { "ppi_gps.present.unknown_bit", PI_PROTOCOL, PI_WARN, "Error: PPI-GEOLOCATION-GPS: unknown bit set in present field.", EXPFILL }},\r\n{ &ei_ppi_gps_version, { "ppi_gps.version.unsupported", PI_PROTOCOL, PI_WARN, "Invalid version", EXPFILL }},\r\n{ &ei_ppi_gps_length, { "ppi_gps.length.invalid", PI_MALFORMED, PI_ERROR, "Invalid length", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ppi_gps;\r\nproto_ppi_gps = proto_register_protocol("PPI Geotagging GPS tag decoder", "PPI GPS Decoder", "ppi_gps");\r\nproto_register_field_array(proto_ppi_gps, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ppi_gps = expert_register_protocol(proto_ppi_gps);\r\nexpert_register_field_array(expert_ppi_gps, ei, array_length(ei));\r\nregister_dissector("ppi_gps", dissect_ppi_gps, proto_ppi_gps);\r\n}
