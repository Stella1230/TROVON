static int wtap_file_read_pattern (wtap *wth, const char *pattern, int *err,\r\ngchar **err_info)\r\n{\r\nint c;\r\nconst char *cp;\r\ncp = pattern;\r\nwhile (*cp)\r\n{\r\nc = file_getc(wth->fh);\r\nif (c == EOF)\r\n{\r\n*err = file_error(wth->fh, err_info);\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nif (c == *cp)\r\ncp++;\r\nelse\r\n{\r\nif (c == pattern[0])\r\ncp = &pattern[1];\r\nelse\r\ncp = pattern;\r\n}\r\n}\r\nreturn (*cp == '\0' ? 1 : 0);\r\n}\r\nstatic int wtap_file_read_till_separator (wtap *wth, char *buffer, int buflen,\r\nconst char *separators, int *err,\r\ngchar **err_info)\r\n{\r\nint c;\r\nchar *cp;\r\nint i;\r\nfor (cp = buffer, i = 0; i < buflen; i++, cp++)\r\n{\r\nc = file_getc(wth->fh);\r\nif (c == EOF)\r\n{\r\n*err = file_error(wth->fh, err_info);\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nif (strchr (separators, c) != NULL)\r\n{\r\n*cp = '\0';\r\nbreak;\r\n}\r\nelse\r\n*cp = c;\r\n}\r\nreturn i;\r\n}\r\nstatic int wtap_file_read_number (wtap *wth, guint32 *num, int *err,\r\ngchar **err_info)\r\n{\r\nint ret;\r\nchar str_num[12];\r\nunsigned long value;\r\nchar *p;\r\nret = wtap_file_read_till_separator (wth, str_num, sizeof (str_num)-1, "<",\r\nerr, err_info);\r\nif (ret == 0 || ret == -1) {\r\nreturn ret;\r\n}\r\nvalue = strtoul (str_num, &p, 10);\r\nif (p == str_num || value > G_MAXUINT32)\r\nreturn 0;\r\n*num = (guint32)value;\r\nreturn 1;\r\n}\r\nwtap_open_return_val peektagged_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\npeektagged_section_header_t ap_hdr;\r\nint ret;\r\nguint32 fileVersion = 0;\r\nguint32 mediaType;\r\nguint32 mediaSubType = 0;\r\nint file_encap;\r\nstatic const int peektagged_encap[] = {\r\nWTAP_ENCAP_ETHERNET,\r\nWTAP_ENCAP_IEEE_802_11_WITH_RADIO,\r\nWTAP_ENCAP_IEEE_802_11_WITH_RADIO,\r\nWTAP_ENCAP_IEEE_802_11_WITH_RADIO\r\n};\r\n#define NUM_PEEKTAGGED_ENCAPS (sizeof peektagged_encap / sizeof peektagged_encap[0])\r\npeektagged_t *peektagged;\r\nif (!wtap_read_bytes(wth->fh, &ap_hdr, (int)sizeof(ap_hdr), err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp (ap_hdr.section_id, "\177ver", sizeof(ap_hdr.section_id)) != 0)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nret = wtap_file_read_pattern (wth, "<FileVersion>", err, err_info);\r\nif (ret == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nif (ret == 0) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nret = wtap_file_read_number (wth, &fileVersion, err, err_info);\r\nif (ret == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nif (ret == 0) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (fileVersion != 9) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("peektagged: version %u unsupported",\r\nfileVersion);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nret = wtap_file_read_pattern (wth, "<MediaType>", err, err_info);\r\nif (ret == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nif (ret == 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: <MediaType> tag not found");\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nret = wtap_file_read_number (wth, &mediaType, err, err_info);\r\nif (ret == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nif (ret == 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: <MediaType> value not found");\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nret = wtap_file_read_pattern (wth, "<MediaSubType>", err, err_info);\r\nif (ret == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nif (ret == 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: <MediaSubType> tag not found");\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nret = wtap_file_read_number (wth, &mediaSubType, err, err_info);\r\nif (ret == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nif (ret == 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: <MediaSubType> value not found");\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (mediaSubType >= NUM_PEEKTAGGED_ENCAPS\r\n|| peektagged_encap[mediaSubType] == WTAP_ENCAP_UNKNOWN) {\r\n*err = WTAP_ERR_UNSUPPORTED;\r\n*err_info = g_strdup_printf("peektagged: network type %u unknown or unsupported",\r\nmediaSubType);\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nret = wtap_file_read_pattern (wth, "pkts", err, err_info);\r\nif (ret == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nif (ret == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (file_seek (wth->fh, 8L, SEEK_CUR, err) == -1)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nfile_encap = peektagged_encap[mediaSubType];\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_PEEKTAGGED;\r\nwth->file_encap = file_encap;\r\nwth->subtype_read = peektagged_read;\r\nwth->subtype_seek_read = peektagged_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_NSEC;\r\npeektagged = (peektagged_t *)g_malloc(sizeof(peektagged_t));\r\nwth->priv = (void *)peektagged;\r\nswitch (mediaSubType) {\r\ncase PEEKTAGGED_NST_ETHERNET:\r\ncase PEEKTAGGED_NST_802_11:\r\ncase PEEKTAGGED_NST_802_11_2:\r\npeektagged->has_fcs = FALSE;\r\nbreak;\r\ncase PEEKTAGGED_NST_802_11_WITH_FCS:\r\npeektagged->has_fcs = TRUE;\r\nbreak;\r\n}\r\nwth->snapshot_length = 0;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic int\r\npeektagged_read_packet(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\npeektagged_t *peektagged = (peektagged_t *)wth->priv;\r\ngboolean read_a_tag = FALSE;\r\nguint8 tag_value[6];\r\nguint16 tag;\r\ngboolean saw_length = FALSE;\r\nguint32 length = 0;\r\nguint32 sliceLength = 0;\r\ngboolean saw_timestamp_lower = FALSE;\r\ngboolean saw_timestamp_upper = FALSE;\r\npeektagged_utime timestamp;\r\nguint32 ext_flags = 0;\r\ngboolean saw_data_rate_or_mcs_index = FALSE;\r\nguint32 data_rate_or_mcs_index = 0;\r\ngint channel;\r\nguint frequency;\r\nstruct ieee_802_11_phdr ieee_802_11;\r\nguint i;\r\nint skip_len = 0;\r\nguint64 t;\r\ntimestamp.upper = 0;\r\ntimestamp.lower = 0;\r\nmemset(&ieee_802_11, 0, sizeof ieee_802_11);\r\nieee_802_11.fcs_len = -1;\r\nieee_802_11.decrypted = FALSE;\r\nieee_802_11.datapad = FALSE;\r\nieee_802_11.phy = PHDR_802_11_PHY_UNKNOWN;\r\ndo {\r\nif (!wtap_read_bytes_or_eof(fh, tag_value, sizeof tag_value, err, err_info)) {\r\nif (*err == 0) {\r\nif (read_a_tag)\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn -1;\r\n}\r\nread_a_tag = TRUE;\r\ntag = pletoh16(&tag_value[0]);\r\nswitch (tag) {\r\ncase TAG_PEEKTAGGED_LENGTH:\r\nif (saw_length) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: record has two length fields");\r\nreturn -1;\r\n}\r\nlength = pletoh32(&tag_value[2]);\r\nsaw_length = TRUE;\r\nbreak;\r\ncase TAG_PEEKTAGGED_TIMESTAMP_LOWER:\r\nif (saw_timestamp_lower) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: record has two timestamp-lower fields");\r\nreturn -1;\r\n}\r\ntimestamp.lower = pletoh32(&tag_value[2]);\r\nsaw_timestamp_lower = TRUE;\r\nbreak;\r\ncase TAG_PEEKTAGGED_TIMESTAMP_UPPER:\r\nif (saw_timestamp_upper) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: record has two timestamp-upper fields");\r\nreturn -1;\r\n}\r\ntimestamp.upper = pletoh32(&tag_value[2]);\r\nsaw_timestamp_upper = TRUE;\r\nbreak;\r\ncase TAG_PEEKTAGGED_FLAGS_AND_STATUS:\r\nbreak;\r\ncase TAG_PEEKTAGGED_CHANNEL:\r\nieee_802_11.has_channel = TRUE;\r\nieee_802_11.channel = pletoh32(&tag_value[2]);\r\nbreak;\r\ncase TAG_PEEKTAGGED_DATA_RATE_OR_MCS_INDEX:\r\ndata_rate_or_mcs_index = pletoh32(&tag_value[2]);\r\nsaw_data_rate_or_mcs_index = TRUE;\r\nbreak;\r\ncase TAG_PEEKTAGGED_SIGNAL_PERC:\r\nieee_802_11.has_signal_percent = TRUE;\r\nieee_802_11.signal_percent = pletoh32(&tag_value[2]);\r\nbreak;\r\ncase TAG_PEEKTAGGED_SIGNAL_DBM:\r\nieee_802_11.has_signal_dbm = TRUE;\r\nieee_802_11.signal_dbm = pletoh32(&tag_value[2]);\r\nbreak;\r\ncase TAG_PEEKTAGGED_NOISE_PERC:\r\nieee_802_11.has_noise_percent = TRUE;\r\nieee_802_11.noise_percent = pletoh32(&tag_value[2]);\r\nbreak;\r\ncase TAG_PEEKTAGGED_NOISE_DBM:\r\nieee_802_11.has_noise_dbm = TRUE;\r\nieee_802_11.noise_dbm = pletoh32(&tag_value[2]);\r\nbreak;\r\ncase TAG_PEEKTAGGED_UNKNOWN_0x000A:\r\nbreak;\r\ncase TAG_PEEKTAGGED_CENTER_FREQUENCY:\r\nieee_802_11.has_frequency = TRUE;\r\nieee_802_11.frequency = pletoh32(&tag_value[2]);\r\nbreak;\r\ncase TAG_PEEKTAGGED_UNKNOWN_0x000E:\r\nbreak;\r\ncase TAG_PEEKTAGGED_UNKNOWN_0x000F:\r\nbreak;\r\ncase TAG_PEEKTAGGED_UNKNOWN_0x0010:\r\nbreak;\r\ncase TAG_PEEKTAGGED_UNKNOWN_0x0011:\r\nbreak;\r\ncase TAG_PEEKTAGGED_UNKNOWN_0x0012:\r\nbreak;\r\ncase TAG_PEEKTAGGED_UNKNOWN_0x0013:\r\nbreak;\r\ncase TAG_PEEKTAGGED_UNKNOWN_0x0014:\r\nbreak;\r\ncase TAG_PEEKTAGGED_EXT_FLAGS:\r\next_flags = pletoh32(&tag_value[2]);\r\nif (ext_flags & EXT_FLAG_802_11ac) {\r\nieee_802_11.phy = PHDR_802_11_PHY_11AC;\r\nfor (i = 0; i < 4; i++)\r\nieee_802_11.phy_info.info_11ac.nss[i] = 0;\r\nswitch (ext_flags & EXT_FLAGS_GI) {\r\ncase EXT_FLAG_HALF_GI:\r\nieee_802_11.phy_info.info_11ac.has_short_gi = TRUE;\r\nieee_802_11.phy_info.info_11ac.short_gi = 1;\r\nbreak;\r\ncase EXT_FLAG_FULL_GI:\r\nieee_802_11.phy_info.info_11ac.has_short_gi = TRUE;\r\nieee_802_11.phy_info.info_11ac.short_gi = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nieee_802_11.phy = PHDR_802_11_PHY_11N;\r\nswitch (ext_flags & EXT_FLAGS_BANDWIDTH) {\r\ncase 0:\r\nieee_802_11.phy_info.info_11n.has_bandwidth = TRUE;\r\nieee_802_11.phy_info.info_11n.bandwidth = PHDR_802_11_BANDWIDTH_20_MHZ;\r\nbreak;\r\ncase EXT_FLAG_20_MHZ_LOWER:\r\nieee_802_11.phy_info.info_11n.has_bandwidth = TRUE;\r\nieee_802_11.phy_info.info_11n.bandwidth = PHDR_802_11_BANDWIDTH_20_20L;\r\nbreak;\r\ncase EXT_FLAG_20_MHZ_UPPER:\r\nieee_802_11.phy_info.info_11n.has_bandwidth = TRUE;\r\nieee_802_11.phy_info.info_11n.bandwidth = PHDR_802_11_BANDWIDTH_20_20U;\r\nbreak;\r\ncase EXT_FLAG_40_MHZ:\r\nieee_802_11.phy_info.info_11n.has_bandwidth = TRUE;\r\nieee_802_11.phy_info.info_11n.bandwidth = PHDR_802_11_BANDWIDTH_40_MHZ;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (ext_flags & EXT_FLAGS_GI) {\r\ncase EXT_FLAG_HALF_GI:\r\nieee_802_11.phy_info.info_11n.has_short_gi = TRUE;\r\nieee_802_11.phy_info.info_11n.short_gi = 1;\r\nbreak;\r\ncase EXT_FLAG_FULL_GI:\r\nieee_802_11.phy_info.info_11n.has_short_gi = TRUE;\r\nieee_802_11.phy_info.info_11n.short_gi = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase TAG_PEEKTAGGED_SLICE_LENGTH:\r\nsliceLength = pletoh32(&tag_value[2]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} while (tag != TAG_PEEKTAGGED_SLICE_LENGTH);\r\nif (!saw_length) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: record has no length field");\r\nreturn -1;\r\n}\r\nif (!saw_timestamp_lower) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: record has no timestamp-lower field");\r\nreturn -1;\r\n}\r\nif (!saw_timestamp_upper) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: record has no timestamp-upper field");\r\nreturn -1;\r\n}\r\nif (sliceLength == 0)\r\nsliceLength = length;\r\nif (sliceLength > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("peektagged: File has %u-byte packet, bigger than maximum of %u",\r\nsliceLength, WTAP_MAX_PACKET_SIZE);\r\nreturn -1;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nphdr->len = length;\r\nphdr->caplen = sliceLength;\r\nt = (((guint64) timestamp.upper) << 32) + timestamp.lower;\r\nif (!nsfiletime_to_nstime(&phdr->ts, t)) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("peektagged: time stamp outside supported range");\r\nreturn -1;\r\n}\r\nswitch (wth->file_encap) {\r\ncase WTAP_ENCAP_IEEE_802_11_WITH_RADIO:\r\nif (saw_data_rate_or_mcs_index) {\r\nif (ext_flags & EXT_FLAG_MCS_INDEX_USED) {\r\nif (!(ext_flags & EXT_FLAG_802_11ac)) {\r\nieee_802_11.phy_info.info_11n.has_mcs_index = TRUE;\r\nieee_802_11.phy_info.info_11n.mcs_index = data_rate_or_mcs_index;\r\n}\r\n} else {\r\nieee_802_11.has_data_rate = TRUE;\r\nieee_802_11.data_rate = data_rate_or_mcs_index;\r\n}\r\n}\r\nif (ieee_802_11.has_frequency && !ieee_802_11.has_channel) {\r\nchannel = ieee80211_mhz_to_chan(ieee_802_11.frequency);\r\nif (channel != -1) {\r\nieee_802_11.has_channel = TRUE;\r\nieee_802_11.channel = channel;\r\n}\r\n} else if (ieee_802_11.has_channel && !ieee_802_11.has_frequency) {\r\nswitch (ieee_802_11.phy) {\r\ncase PHDR_802_11_PHY_11_DSSS:\r\ncase PHDR_802_11_PHY_11B:\r\ncase PHDR_802_11_PHY_11G:\r\nfrequency = ieee80211_chan_to_mhz(ieee_802_11.channel, TRUE);\r\nbreak;\r\ncase PHDR_802_11_PHY_11A:\r\nfrequency = ieee80211_chan_to_mhz(ieee_802_11.channel, FALSE);\r\nbreak;\r\ndefault:\r\nfrequency = 0;\r\nbreak;\r\n}\r\nif (frequency != 0) {\r\nieee_802_11.has_frequency = TRUE;\r\nieee_802_11.frequency = frequency;\r\n}\r\n}\r\nphdr->pseudo_header.ieee_802_11 = ieee_802_11;\r\nif (peektagged->has_fcs)\r\nphdr->pseudo_header.ieee_802_11.fcs_len = 4;\r\nelse {\r\nif (phdr->len < 4 || phdr->caplen < 4) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("peektagged: 802.11 packet has length < 4");\r\nreturn FALSE;\r\n}\r\nphdr->pseudo_header.ieee_802_11.fcs_len = 0;\r\nphdr->len -= 4;\r\nphdr->caplen -= 4;\r\nskip_len = 4;\r\n}\r\nphdr->pseudo_header.ieee_802_11.decrypted = FALSE;\r\nphdr->pseudo_header.ieee_802_11.datapad = FALSE;\r\nbreak;\r\ncase WTAP_ENCAP_ETHERNET:\r\nif (phdr->len < 4 || phdr->caplen < 4) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("peektagged: Ethernet packet has length < 4");\r\nreturn FALSE;\r\n}\r\nphdr->pseudo_header.eth.fcs_len = 0;\r\nphdr->len -= 4;\r\nphdr->caplen -= 4;\r\nskip_len = 4;\r\nbreak;\r\n}\r\nif (!wtap_read_packet_bytes(fh, buf, phdr->caplen, err, err_info))\r\nreturn -1;\r\nreturn skip_len;\r\n}\r\nstatic gboolean peektagged_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\nint skip_len;\r\n*data_offset = file_tell(wth->fh);\r\nskip_len = peektagged_read_packet(wth, wth->fh, &wth->phdr,\r\nwth->frame_buffer, err, err_info);\r\nif (skip_len == -1)\r\nreturn FALSE;\r\nif (skip_len != 0) {\r\nif (!file_skip(wth->fh, skip_len, err))\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\npeektagged_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (peektagged_read_packet(wth, wth->random_fh, phdr, buf, err, err_info) == -1) {\r\nif (*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}
