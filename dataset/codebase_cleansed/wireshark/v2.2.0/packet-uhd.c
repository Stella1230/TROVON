static int\r\ndissect_uhd(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint ind;\r\nproto_item *ti;\r\nproto_tree *uhd_tree;\r\nguint32 id;\r\nguint8 i2c_bytes;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "UHD");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nid = tvb_get_ntohl(tvb, 4);\r\ncol_add_str(pinfo->cinfo, COL_INFO, val_to_str(id, uhd_ids, "Unknown UHD message type '%c'"));\r\nif (tree == NULL)\r\nreturn tvb_captured_length(tvb);\r\nti = proto_tree_add_protocol_format(tree, proto_uhd, tvb, 0, 34, "UHD id = %c ", id);\r\nuhd_tree = proto_item_add_subtree(ti, ett_uhd);\r\nproto_tree_add_item(uhd_tree, hf_uhd_version, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(uhd_tree, hf_uhd_id, tvb, 4, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(uhd_tree, hf_uhd_seq, tvb, 8, 4, ENC_BIG_ENDIAN);\r\nswitch (id) {\r\ncase UMTRX_CTRL_ID_REQUEST:\r\ncase UMTRX_CTRL_ID_RESPONSE:\r\ncase USRP2_CTRL_ID_WAZZUP_BRO:\r\ncase USRP2_CTRL_ID_WAZZUP_DUDE:\r\nproto_tree_add_item(uhd_tree, hf_uhd_ip_addr, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase USRP2_CTRL_ID_TRANSACT_ME_SOME_SPI_BRO:\r\ncase USRP2_CTRL_ID_OMG_TRANSACTED_SPI_DUDE:\r\nproto_tree_add_item(uhd_tree, hf_uhd_spi_dev, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(uhd_tree, hf_uhd_spi_data, tvb, 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(uhd_tree, hf_uhd_spi_miso_edge, tvb, 20, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(uhd_tree, hf_uhd_spi_mosi_edge, tvb, 21, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(uhd_tree, hf_uhd_spi_num_bits, tvb, 22, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(uhd_tree, hf_uhd_spi_readback, tvb, 23, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase USRP2_CTRL_ID_DO_AN_I2C_READ_FOR_ME_BRO:\r\ncase USRP2_CTRL_ID_HERES_THE_I2C_DATA_DUDE:\r\ncase USRP2_CTRL_ID_WRITE_THESE_I2C_VALUES_BRO:\r\ncase USRP2_CTRL_ID_COOL_IM_DONE_I2C_WRITE_DUDE:\r\nproto_tree_add_item(uhd_tree, hf_uhd_i2c_addr, tvb, 12, 1, ENC_BIG_ENDIAN);\r\ni2c_bytes = tvb_get_guint8(tvb, 13);\r\nproto_tree_add_item(uhd_tree, hf_uhd_i2c_bytes, tvb, 13, 1, ENC_BIG_ENDIAN);\r\nfor (ind = 0; ind < i2c_bytes; ind++) {\r\nproto_tree_add_item(uhd_tree, hf_uhd_i2c_data, tvb, 14 + ind, 1, ENC_BIG_ENDIAN);\r\n}\r\nbreak;\r\ncase USRP2_CTRL_ID_GET_THIS_REGISTER_FOR_ME_BRO:\r\ncase USRP2_CTRL_ID_OMG_GOT_REGISTER_SO_BAD_DUDE:\r\nproto_tree_add_item(uhd_tree, hf_uhd_reg_addr, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(uhd_tree, hf_uhd_reg_data, tvb, 16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(uhd_tree, hf_uhd_reg_action, tvb, 20, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase USRP2_CTRL_ID_HOLLER_AT_ME_BRO:\r\ncase USRP2_CTRL_ID_HOLLER_BACK_DUDE:\r\ncase USRP2_CTRL_ID_HUH_WHAT:\r\ncase USRP2_CTRL_ID_PEACE_OUT:\r\nproto_tree_add_item(uhd_tree, hf_uhd_echo_len, tvb, 12, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_uhd(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_uhd_version, { "VERSION", "uhd.version",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_id, { "ID", "uhd.id",\r\nFT_UINT32, BASE_HEX, VALS(uhd_ids), 0, NULL, HFILL } },\r\n{ &hf_uhd_seq, { "SEQ", "uhd.seq",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_ip_addr, { "IP ADDR", "uhd.ip_addr",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,"", HFILL } },\r\n{ &hf_uhd_i2c_addr, { "I2C ADDR", "uhd.i2c_addr",\r\nFT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_i2c_bytes, { "I2C BYTES", "uhd.i2c_bytes",\r\nFT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_i2c_data, { "I2C DATA", "uhd.i2c_data",\r\nFT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_spi_dev, { "SPI DEV", "uhd.spi_dev",\r\nFT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_spi_data, { "SPI DATA", "uhd.spi_data",\r\nFT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_spi_miso_edge, { "SPI MISO EDGE", "uhd.spi_miso_edge",\r\nFT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_spi_mosi_edge, { "SPI MOSI EDGE", "uhd.spi_mosi_edge",\r\nFT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_spi_num_bits, { "SPI NUM BITS", "uhd.spi_num_bits",\r\nFT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_spi_readback, { "SPI READBACK", "uhd.spi_readback",\r\nFT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_reg_addr, { "REG ADDR", "uhd.reg_addr",\r\nFT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_reg_data, { "REG DATA", "uhd.reg_data",\r\nFT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_uhd_reg_action, { "REG ACTION", "uhd.reg_action",\r\nFT_UINT8, BASE_HEX, VALS(uhd_reg_actions), 0, NULL, HFILL } },\r\n{ &hf_uhd_echo_len, { "ECHO LEN", "uhd.echo_len",\r\nFT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } },\r\n};\r\nstatic gint *ett[] = {\r\n&ett_uhd\r\n};\r\nmodule_t *uhd_module;\r\nproto_uhd = proto_register_protocol("UHD", "UHD", "uhd");\r\nproto_register_field_array(proto_uhd, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nuhd_module = prefs_register_protocol(proto_uhd, proto_reg_handoff_uhd);\r\nprefs_register_uint_preference(uhd_module,\r\n"dissector_port",\r\n"Dissector UDP port",\r\n"The UDP port used by this dissector",\r\n10, &dissector_port_pref);\r\n}\r\nvoid\r\nproto_reg_handoff_uhd(void)\r\n{\r\nstatic gboolean uhd_prefs_initialized = FALSE;\r\nstatic dissector_handle_t uhd_handle;\r\nstatic gint dissector_port;\r\nif (!uhd_prefs_initialized) {\r\nuhd_handle = create_dissector_handle(dissect_uhd, proto_uhd);\r\nuhd_prefs_initialized = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", dissector_port, uhd_handle);\r\n}\r\ndissector_port = dissector_port_pref;\r\ndissector_add_uint("udp.port", dissector_port, uhd_handle);\r\n}
