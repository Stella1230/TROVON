static int\r\ndissect_lapb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *lapb_tree, *ti;\r\nguint16 control;\r\nint is_response;\r\nguint8 byte0;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "LAPB");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "DTE");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "DCE");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "DCE");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "DTE");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_SRC, "N/A");\r\ncol_set_str(pinfo->cinfo, COL_RES_DL_DST, "N/A");\r\nbreak;\r\n}\r\nbyte0 = tvb_get_guint8(tvb, 0);\r\nif (byte0 != 0x01 && byte0 != 0x03 && byte0 != 0x07 && byte0 != 0x0f)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Invalid LAPB frame");\r\nif (tree)\r\nproto_tree_add_protocol_format(tree, proto_lapb, tvb, 0, -1,\r\n"Invalid LAPB frame");\r\nreturn 1;\r\n}\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\nif (byte0 == 0x03)\r\nis_response = TRUE;\r\nelse\r\nis_response = FALSE;\r\nbreak;\r\ncase P2P_DIR_RECV:\r\nif (byte0 == 0x01)\r\nis_response = TRUE;\r\nelse\r\nis_response = FALSE;\r\nbreak;\r\ndefault:\r\nis_response = FALSE;\r\nbreak;\r\n}\r\nti = proto_tree_add_protocol_format(tree, proto_lapb, tvb, 0, 2,\r\n"LAPB");\r\nlapb_tree = proto_item_add_subtree(ti, ett_lapb);\r\nproto_tree_add_uint(lapb_tree, hf_lapb_address, tvb, 0, 1, byte0);\r\ncontrol = dissect_xdlc_control(tvb, 1, pinfo, lapb_tree, hf_lapb_control,\r\nett_lapb_control, &lapb_cf_items, NULL, NULL, NULL,\r\nis_response, FALSE, FALSE);\r\nif (XDLC_IS_INFORMATION(control)) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, 2);\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncase P2P_DIR_RECV:\r\ncall_dissector(x25_dir_handle, next_tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\ncall_dissector(x25_handle, next_tvb, pinfo, tree);\r\nbreak;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_lapb(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_lapb_address,\r\n{ "Address", "lapb.address", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_lapb_control,\r\n{ "Control Field", "lapb.control", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_lapb_n_r,\r\n{ "N(R)", "lapb.control.n_r", FT_UINT8, BASE_DEC,\r\nNULL, XDLC_N_R_MASK, NULL, HFILL }},\r\n{ &hf_lapb_n_s,\r\n{ "N(S)", "lapb.control.n_s", FT_UINT8, BASE_DEC,\r\nNULL, XDLC_N_S_MASK, NULL, HFILL }},\r\n{ &hf_lapb_p,\r\n{ "Poll", "lapb.control.p", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), XDLC_P_F, NULL, HFILL }},\r\n{ &hf_lapb_f,\r\n{ "Final", "lapb.control.f", FT_BOOLEAN, 8,\r\nTFS(&tfs_set_notset), XDLC_P_F, NULL, HFILL }},\r\n{ &hf_lapb_s_ftype,\r\n{ "Supervisory frame type", "lapb.control.s_ftype", FT_UINT8, BASE_HEX,\r\nVALS(stype_vals), XDLC_S_FTYPE_MASK, NULL, HFILL }},\r\n{ &hf_lapb_u_modifier_cmd,\r\n{ "Command", "lapb.control.u_modifier_cmd", FT_UINT8, BASE_HEX,\r\nVALS(modifier_vals_cmd), XDLC_U_MODIFIER_MASK, NULL, HFILL }},\r\n{ &hf_lapb_u_modifier_resp,\r\n{ "Response", "lapb.control.u_modifier_resp", FT_UINT8, BASE_HEX,\r\nVALS(modifier_vals_resp), XDLC_U_MODIFIER_MASK, NULL, HFILL }},\r\n{ &hf_lapb_ftype_i,\r\n{ "Frame type", "lapb.control.ftype", FT_UINT8, BASE_HEX,\r\nVALS(ftype_vals), XDLC_I_MASK, NULL, HFILL }},\r\n{ &hf_lapb_ftype_s_u,\r\n{ "Frame type", "lapb.control.ftype", FT_UINT8, BASE_HEX,\r\nVALS(ftype_vals), XDLC_S_U_MASK, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_lapb,\r\n&ett_lapb_control,\r\n};\r\nproto_lapb = proto_register_protocol("Link Access Procedure Balanced (LAPB)",\r\n"LAPB", "lapb");\r\nproto_register_field_array (proto_lapb, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("lapb", dissect_lapb, proto_lapb);\r\n}\r\nvoid\r\nproto_reg_handoff_lapb(void)\r\n{\r\ndissector_handle_t lapb_handle;\r\nx25_dir_handle = find_dissector_add_dependency("x.25_dir", proto_lapb);\r\nx25_handle = find_dissector_add_dependency("x.25", proto_lapb);\r\nlapb_handle = find_dissector("lapb");\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_LAPB, lapb_handle);\r\n}
