static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser,\r\njsmntok_t *tokens, size_t num_tokens) {\r\njsmntok_t *tok;\r\nif (parser->toknext >= num_tokens) {\r\nreturn NULL;\r\n}\r\ntok = &tokens[parser->toknext++];\r\ntok->start = tok->end = -1;\r\ntok->size = 0;\r\n#ifdef JSMN_PARENT_LINKS\r\ntok->parent = -1;\r\n#endif\r\nreturn tok;\r\n}\r\nstatic void jsmn_fill_token(jsmntok_t *token, jsmntype_t type,\r\nint start, int end) {\r\ntoken->type = type;\r\ntoken->start = start;\r\ntoken->end = end;\r\ntoken->size = 0;\r\n}\r\nstatic int jsmn_parse_primitive(jsmn_parser *parser, const char *js,\r\nsize_t len, jsmntok_t *tokens, size_t num_tokens) {\r\njsmntok_t *token;\r\nint start;\r\nstart = parser->pos;\r\nfor (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {\r\nswitch (js[parser->pos]) {\r\n#ifndef JSMN_STRICT\r\ncase ':':\r\n#endif\r\ncase '\t' : case '\r' : case '\n' : case ' ' :\r\ncase ',' : case ']' : case '}' :\r\ngoto found;\r\n}\r\nif (js[parser->pos] < 32 || js[parser->pos] >= 127) {\r\nparser->pos = start;\r\nreturn JSMN_ERROR_INVAL;\r\n}\r\n}\r\n#ifdef JSMN_STRICT\r\nparser->pos = start;\r\nreturn JSMN_ERROR_PART;\r\n#endif\r\nfound:\r\nif (tokens == NULL) {\r\nparser->pos--;\r\nreturn 0;\r\n}\r\ntoken = jsmn_alloc_token(parser, tokens, num_tokens);\r\nif (token == NULL) {\r\nparser->pos = start;\r\nreturn JSMN_ERROR_NOMEM;\r\n}\r\njsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);\r\n#ifdef JSMN_PARENT_LINKS\r\ntoken->parent = parser->toksuper;\r\n#endif\r\nparser->pos--;\r\nreturn 0;\r\n}\r\nstatic int jsmn_parse_string(jsmn_parser *parser, const char *js,\r\nsize_t len, jsmntok_t *tokens, size_t num_tokens) {\r\njsmntok_t *token;\r\nint start = parser->pos;\r\nparser->pos++;\r\nfor (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {\r\nchar c = js[parser->pos];\r\nif (c == '\"') {\r\nif (tokens == NULL) {\r\nreturn 0;\r\n}\r\ntoken = jsmn_alloc_token(parser, tokens, num_tokens);\r\nif (token == NULL) {\r\nparser->pos = start;\r\nreturn JSMN_ERROR_NOMEM;\r\n}\r\njsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);\r\n#ifdef JSMN_PARENT_LINKS\r\ntoken->parent = parser->toksuper;\r\n#endif\r\nreturn 0;\r\n}\r\nif (c == '\\' && parser->pos + 1 < len) {\r\nint i;\r\nparser->pos++;\r\nswitch (js[parser->pos]) {\r\ncase '\"': case '/' : case '\\' : case 'b' :\r\ncase 'f' : case 'r' : case 'n' : case 't' :\r\nbreak;\r\ncase 'u':\r\nparser->pos++;\r\nfor(i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0'; i++) {\r\nif(!((js[parser->pos] >= 48 && js[parser->pos] <= 57) ||\r\n(js[parser->pos] >= 65 && js[parser->pos] <= 70) ||\r\n(js[parser->pos] >= 97 && js[parser->pos] <= 102))) {\r\nparser->pos = start;\r\nreturn JSMN_ERROR_INVAL;\r\n}\r\nparser->pos++;\r\n}\r\nparser->pos--;\r\nbreak;\r\ndefault:\r\nparser->pos = start;\r\nreturn JSMN_ERROR_INVAL;\r\n}\r\n}\r\n}\r\nparser->pos = start;\r\nreturn JSMN_ERROR_PART;\r\n}\r\nint jsmn_parse(jsmn_parser *parser, const char *js, size_t len,\r\njsmntok_t *tokens, unsigned int num_tokens) {\r\nint r;\r\nint i;\r\njsmntok_t *token;\r\nint count = 0;\r\nfor (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {\r\nchar c;\r\njsmntype_t type;\r\nc = js[parser->pos];\r\nswitch (c) {\r\ncase '{': case '[':\r\ncount++;\r\nif (tokens == NULL) {\r\nbreak;\r\n}\r\ntoken = jsmn_alloc_token(parser, tokens, num_tokens);\r\nif (token == NULL)\r\nreturn JSMN_ERROR_NOMEM;\r\nif (parser->toksuper != -1) {\r\ntokens[parser->toksuper].size++;\r\n#ifdef JSMN_PARENT_LINKS\r\ntoken->parent = parser->toksuper;\r\n#endif\r\n}\r\ntoken->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);\r\ntoken->start = parser->pos;\r\nparser->toksuper = parser->toknext - 1;\r\nbreak;\r\ncase '}': case ']':\r\nif (tokens == NULL)\r\nbreak;\r\ntype = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);\r\n#ifdef JSMN_PARENT_LINKS\r\nif (parser->toknext < 1) {\r\nreturn JSMN_ERROR_INVAL;\r\n}\r\ntoken = &tokens[parser->toknext - 1];\r\nfor (;;) {\r\nif (token->start != -1 && token->end == -1) {\r\nif (token->type != type) {\r\nreturn JSMN_ERROR_INVAL;\r\n}\r\ntoken->end = parser->pos + 1;\r\nparser->toksuper = token->parent;\r\nbreak;\r\n}\r\nif (token->parent == -1) {\r\nbreak;\r\n}\r\ntoken = &tokens[token->parent];\r\n}\r\n#else\r\nfor (i = parser->toknext - 1; i >= 0; i--) {\r\ntoken = &tokens[i];\r\nif (token->start != -1 && token->end == -1) {\r\nif (token->type != type) {\r\nreturn JSMN_ERROR_INVAL;\r\n}\r\nparser->toksuper = -1;\r\ntoken->end = parser->pos + 1;\r\nbreak;\r\n}\r\n}\r\nif (i == -1) return JSMN_ERROR_INVAL;\r\nfor (; i >= 0; i--) {\r\ntoken = &tokens[i];\r\nif (token->start != -1 && token->end == -1) {\r\nparser->toksuper = i;\r\nbreak;\r\n}\r\n}\r\n#endif\r\nbreak;\r\ncase '\"':\r\nr = jsmn_parse_string(parser, js, len, tokens, num_tokens);\r\nif (r < 0) return r;\r\ncount++;\r\nif (parser->toksuper != -1 && tokens != NULL)\r\ntokens[parser->toksuper].size++;\r\nbreak;\r\ncase '\t' : case '\r' : case '\n' : case ' ':\r\nbreak;\r\ncase ':':\r\nparser->toksuper = parser->toknext - 1;\r\nbreak;\r\ncase ',':\r\nif (tokens != NULL && parser->toksuper != -1 &&\r\ntokens[parser->toksuper].type != JSMN_ARRAY &&\r\ntokens[parser->toksuper].type != JSMN_OBJECT) {\r\n#ifdef JSMN_PARENT_LINKS\r\nparser->toksuper = tokens[parser->toksuper].parent;\r\n#else\r\nfor (i = parser->toknext - 1; i >= 0; i--) {\r\nif (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {\r\nif (tokens[i].start != -1 && tokens[i].end == -1) {\r\nparser->toksuper = i;\r\nbreak;\r\n}\r\n}\r\n}\r\n#endif\r\n}\r\nbreak;\r\n#ifdef JSMN_STRICT\r\ncase '-': case '0': case '1' : case '2': case '3' : case '4':\r\ncase '5': case '6': case '7' : case '8': case '9':\r\ncase 't': case 'f': case 'n' :\r\nif (tokens != NULL && parser->toksuper != -1) {\r\njsmntok_t *t = &tokens[parser->toksuper];\r\nif (t->type == JSMN_OBJECT ||\r\n(t->type == JSMN_STRING && t->size != 0)) {\r\nreturn JSMN_ERROR_INVAL;\r\n}\r\n}\r\n#else\r\ndefault:\r\n#endif\r\nr = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);\r\nif (r < 0) return r;\r\ncount++;\r\nif (parser->toksuper != -1 && tokens != NULL)\r\ntokens[parser->toksuper].size++;\r\nbreak;\r\n#ifdef JSMN_STRICT\r\ndefault:\r\nreturn JSMN_ERROR_INVAL;\r\n#endif\r\n}\r\n}\r\nif (tokens != NULL) {\r\nfor (i = parser->toknext - 1; i >= 0; i--) {\r\nif (tokens[i].start != -1 && tokens[i].end == -1) {\r\nreturn JSMN_ERROR_PART;\r\n}\r\n}\r\n}\r\nreturn count;\r\n}\r\nvoid jsmn_init(jsmn_parser *parser) {\r\nparser->pos = 0;\r\nparser->toknext = 0;\r\nparser->toksuper = -1;\r\n}\r\ngboolean jsmn_is_json(const guint8* buf, const size_t len)\r\n{\r\nguint max_tokens = 1024;\r\njsmntok_t* t;\r\njsmn_parser p;\r\ngboolean ret = TRUE;\r\nint rcode;\r\nt = g_new0(jsmntok_t, max_tokens);\r\nif (!t)\r\nreturn FALSE;\r\njsmn_init(&p);\r\nrcode = jsmn_parse(&p, buf, len, t, max_tokens);\r\nif (rcode < 0) {\r\nswitch (rcode) {\r\ncase JSMN_ERROR_NOMEM:\r\ng_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_DEBUG, "jsmn: not enough tokens were provided");\r\nbreak;\r\ncase JSMN_ERROR_INVAL:\r\ng_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_DEBUG, "jsmn: invalid character inside JSON string");\r\nbreak;\r\ncase JSMN_ERROR_PART:\r\ng_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_DEBUG, "jsmn: the string is not a full JSON packet, "\r\n"more bytes expected");\r\nbreak;\r\ndefault:\r\ng_log(LOG_DOMAIN_MAIN, G_LOG_LEVEL_DEBUG, "jsmn: unexpected error");\r\nbreak;\r\n}\r\nret = FALSE;\r\n}\r\ng_free(t);\r\nreturn ret;\r\n}
