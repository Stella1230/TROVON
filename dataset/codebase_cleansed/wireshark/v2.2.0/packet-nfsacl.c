static int\r\ndissect_nfsacl_mask(tvbuff_t *tvb, int offset, proto_tree *tree)\r\n{\r\nproto_item *mask_item;\r\nproto_tree *mask_tree;\r\nif (tree)\r\n{\r\nmask_item = proto_tree_add_item(tree, hf_nfsacl_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nmask_tree = proto_item_add_subtree(mask_item, ett_nfsacl_mask);\r\nproto_tree_add_item(mask_tree, hf_nfsacl_mask_acl_entry, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mask_tree, hf_nfsacl_mask_acl_count, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mask_tree, hf_nfsacl_mask_default_acl_entry, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(mask_tree, hf_nfsacl_mask_default_acl_count, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl_aclent(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree* tree)\r\n{\r\nproto_item *entry_item = NULL;\r\nproto_tree *entry_tree = NULL;\r\nproto_item *perm_item = NULL;\r\nproto_tree *perm_tree = NULL;\r\nif (tree)\r\n{\r\nentry_item = proto_tree_add_item(tree, hf_nfsacl_aclent, tvb,\r\noffset + 0, -1, ENC_NA);\r\nentry_tree = proto_item_add_subtree(entry_item, ett_nfsacl_aclent);\r\n}\r\noffset = dissect_rpc_uint32(tvb, entry_tree, hf_nfsacl_aclent_type, offset);\r\noffset = dissect_rpc_uint32(tvb, entry_tree, hf_nfsacl_aclent_uid, offset);\r\nperm_item = proto_tree_add_item(entry_tree, hf_nfsacl_aclent_perm,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\nperm_tree = proto_item_add_subtree(perm_item, ett_nfsacl_aclent_perm);\r\nproto_tree_add_item(perm_tree, hf_nfsacl_aclent_perm_read, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(perm_tree, hf_nfsacl_aclent_perm_write, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(perm_tree, hf_nfsacl_aclent_perm_exec, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl_secattr(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\r\nproto_tree *tree)\r\n{\r\nguint32 aclcnt, dfaclcnt;\r\nguint32 i;\r\nproto_tree *entry_tree;\r\noffset = dissect_nfsacl_mask(tvb, offset, tree);\r\noffset = dissect_rpc_uint32(tvb, tree, hf_nfsacl_aclcnt, offset);\r\naclcnt = tvb_get_ntohl(tvb, offset);\r\nentry_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,\r\nett_nfsacl_aclent_entries, NULL, "Total ACL entries: %d", aclcnt);\r\noffset += 4;\r\nif (aclcnt > 0)\r\n{\r\nfor (i = 0; i < aclcnt; i++)\r\noffset = dissect_nfsacl_aclent(tvb, offset, pinfo, entry_tree);\r\n}\r\noffset = dissect_rpc_uint32(tvb, tree, hf_nfsacl_dfaclcnt, offset);\r\ndfaclcnt = tvb_get_ntohl(tvb, offset);\r\nentry_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4,\r\nett_nfsacl_aclent_entries, NULL, "Total default ACL entries: %d", dfaclcnt);\r\noffset += 4;\r\nif (dfaclcnt > 0)\r\n{\r\nfor (i = 0; i < dfaclcnt; i++)\r\noffset = dissect_nfsacl_aclent(tvb, offset, pinfo, entry_tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl2_getacl_call(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data)\r\n{\r\nint offset = 0;\r\noffset = dissect_fhandle(tvb, offset, pinfo, tree, "fhandle", NULL, (rpc_call_info_value*)data);\r\noffset = dissect_nfsacl_mask(tvb, offset, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl2_getacl_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nguint32 status;\r\nint offset = 0;\r\nproto_tree_add_item_ret_uint(tree, hf_nfs_status, tvb, offset, 4, ENC_BIG_ENDIAN, &status);\r\noffset += 4;\r\nif (status == ACL2_OK)\r\n{\r\noffset = dissect_nfs2_fattr(tvb, offset, tree, "attr");\r\noffset = dissect_nfsacl_secattr(tvb, offset, pinfo, tree);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl2_setacl_call(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data)\r\n{\r\nint offset = 0;\r\noffset = dissect_fhandle(tvb, offset, pinfo, tree, "fhandle", NULL, (rpc_call_info_value*)data);\r\noffset = dissect_nfsacl_secattr(tvb, offset, pinfo, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl2_setacl_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nguint32 status;\r\nint offset = 0;\r\nproto_tree_add_item_ret_uint(tree, hf_nfs_status, tvb, offset + 0, 4, ENC_BIG_ENDIAN, &status);\r\noffset += 4;\r\nif (status == ACL2_OK)\r\noffset = dissect_nfs2_fattr(tvb, offset, tree, "attr");\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl2_getattr_call(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data)\r\n{\r\nreturn dissect_fhandle(tvb, 0, pinfo, tree, "fhandle", NULL, (rpc_call_info_value*)data);\r\n}\r\nstatic int\r\ndissect_nfsacl2_getattr_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nreturn dissect_nfs2_fattr(tvb, 0, tree, "attr");\r\n}\r\nstatic int\r\ndissect_nfsacl2_access_call(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data)\r\n{\r\nguint32 *acc_request, amask;\r\nrpc_call_info_value *civ = (rpc_call_info_value*)data;\r\nint offset = 0;\r\noffset = dissect_fhandle(tvb, offset, pinfo, tree, "fhandle", NULL, civ);\r\namask = tvb_get_ntohl(tvb, offset);\r\nacc_request = (guint32 *)wmem_memdup(wmem_file_scope(), &amask, sizeof(guint32));\r\nciv->private_data = acc_request;\r\ndisplay_access_items(tvb, offset, pinfo, tree, amask, 'C', 3, NULL, "Check") ;\r\noffset+=4;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl2_access_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data)\r\n{\r\nguint32 status;\r\nint offset = 0;\r\nstatus = tvb_get_ntohl(tvb, offset + 0);\r\nproto_tree_add_uint(tree, hf_nfs_status, tvb, offset + 0, 4, status);\r\noffset += 4;\r\nif (status == ACL2_OK)\r\n{\r\noffset = dissect_nfs2_fattr(tvb, offset, tree, "attr");\r\noffset = dissect_access_reply(tvb, offset, pinfo, tree, 3, NULL, (rpc_call_info_value*)data);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl2_getxattrdir_call(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data)\r\n{\r\nint offset = 0;\r\noffset = dissect_fhandle(tvb, offset, pinfo, tree, "fhandle", NULL, (rpc_call_info_value*)data);\r\noffset = dissect_rpc_bool(tvb, tree, hf_nfsacl_create, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl2_getxattrdir_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data)\r\n{\r\nguint32 status;\r\nint offset = 0;\r\nstatus = tvb_get_ntohl(tvb, offset + 0);\r\nproto_tree_add_uint(tree, hf_nfs_status, tvb, offset + 0, 4, status);\r\noffset += 4;\r\nif (status == ACL2_OK)\r\n{\r\noffset = dissect_fhandle(tvb, offset, pinfo, tree, "fhandle", NULL, (rpc_call_info_value*)data);\r\noffset = dissect_nfs2_fattr(tvb, offset, tree, "attr");\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl3_getacl_call(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data)\r\n{\r\nint offset = 0;\r\noffset = dissect_nfs3_fh(tvb, offset, pinfo, tree, "fhandle", NULL, (rpc_call_info_value*)data);\r\noffset = dissect_nfsacl_mask(tvb, offset, tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl3_getacl_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nguint32 status;\r\nproto_item *entry_item;\r\nproto_tree *entry_tree;\r\nint offset = 0;\r\nproto_tree_add_item_ret_uint(tree, hf_nfs_status, tvb, offset, 4, ENC_BIG_ENDIAN, &status);\r\noffset += 4;\r\nentry_item = proto_tree_add_item(tree, hf_nfsacl_entry, tvb,\r\noffset + 0, -1, ENC_NA);\r\nentry_tree = proto_item_add_subtree(entry_item, ett_nfsacl_entry);\r\noffset = dissect_nfs3_post_op_attr(tvb, offset, pinfo, entry_tree, "attr");\r\nif (status != ACL3_OK)\r\nreturn offset;\r\noffset = dissect_nfsacl_secattr(tvb, offset, pinfo, entry_tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl3_setacl_call(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data)\r\n{\r\nproto_item *acl_item;\r\nproto_tree *acl_tree;\r\nint offset = 0;\r\noffset = dissect_nfs3_fh(tvb, offset, pinfo, tree, "fhandle", NULL, (rpc_call_info_value*)data);\r\nacl_item = proto_tree_add_item(tree, hf_nfsacl_entry, tvb, offset + 0,\r\n-1, ENC_NA);\r\nacl_tree = proto_item_add_subtree(acl_item, ett_nfsacl_entry);\r\noffset = dissect_nfsacl_secattr(tvb, offset, pinfo, acl_tree);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl3_setacl_reply(tvbuff_t *tvb, packet_info *pinfo _U_,\r\nproto_tree *tree, void* data _U_)\r\n{\r\nguint32 status;\r\nint offset = 0;\r\nproto_tree_add_item_ret_uint(tree, hf_nfs_status, tvb, offset, 4, ENC_BIG_ENDIAN, &status);\r\noffset += 4;\r\noffset = dissect_nfs3_post_op_attr(tvb, offset, pinfo, tree, "attr");\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl3_getxattrdir_call(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data)\r\n{\r\nint offset = 0;\r\noffset = dissect_nfs3_fh(tvb, offset, pinfo, tree, "fhandle", NULL, (rpc_call_info_value*)data);\r\noffset = dissect_rpc_bool(tvb, tree, hf_nfsacl_create, offset);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_nfsacl3_getxattrdir_reply(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data)\r\n{\r\nguint32 status;\r\nint offset = 0;\r\nproto_tree_add_item_ret_uint(tree, hf_nfs_status, tvb, offset, 4, ENC_BIG_ENDIAN, &status);\r\noffset += 4;\r\nif (status == ACL3_OK)\r\n{\r\noffset = dissect_nfs3_fh(tvb, offset, pinfo, tree, "fhandle", NULL, (rpc_call_info_value*)data);\r\noffset = dissect_nfs3_post_op_attr(tvb, offset, pinfo, tree, "attr");\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_nfsacl(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_nfsacl_mask, {\r\n"Mask", "nfsacl.mask", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_nfsacl_mask_acl_entry, {\r\n"ACL entry", "nfsacl.mask.acl_entry", FT_BOOLEAN, 32,\r\nTFS(&tfs_yes_no), 0x01, NULL, HFILL }},\r\n{ &hf_nfsacl_mask_acl_count, {\r\n"ACL count", "nfsacl.mask.acl_count", FT_BOOLEAN, 32,\r\nTFS(&tfs_yes_no), 0x02, NULL, HFILL }},\r\n{ &hf_nfsacl_mask_default_acl_entry, {\r\n"Default ACL entry", "nfsacl.mask.default_acl_entry", FT_BOOLEAN, 32,\r\nTFS(&tfs_yes_no), 0x04, NULL, HFILL }},\r\n{ &hf_nfsacl_mask_default_acl_count, {\r\n"Default ACL count", "nfsacl.mask.default_acl_count", FT_BOOLEAN, 32,\r\nTFS(&tfs_yes_no), 0x08, NULL, HFILL }},\r\n{ &hf_nfsacl_procedure_v1, {\r\n"V1 Procedure", "nfsacl.procedure_v1", FT_UINT32, BASE_DEC,\r\nVALS(nfsacl1_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_nfsacl_procedure_v2, {\r\n"V2 Procedure", "nfsacl.procedure_v2", FT_UINT32, BASE_DEC,\r\nVALS(nfsacl2_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_nfsacl_procedure_v3, {\r\n"V3 Procedure", "nfsacl.procedure_v3", FT_UINT32, BASE_DEC,\r\nVALS(nfsacl3_proc_vals), 0, NULL, HFILL }},\r\n{ &hf_nfsacl_entry, {\r\n"ACL", "nfsacl.acl", FT_NONE, BASE_NONE,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_nfsacl_aclcnt, {\r\n"ACL count", "nfsacl.aclcnt", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_nfsacl_dfaclcnt, {\r\n"Default ACL count", "nfsacl.dfaclcnt", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_nfsacl_aclent, {\r\n"ACL Entry", "nfsacl.aclent", FT_NONE, BASE_NONE,\r\nNULL, 0, "ACL", HFILL }},\r\n{ &hf_nfsacl_aclent_type, {\r\n"Type", "nfsacl.aclent.type", FT_UINT32, BASE_DEC,\r\nVALS(names_nfsacl_aclent_type), 0, NULL, HFILL }},\r\n{ &hf_nfsacl_aclent_uid, {\r\n"UID", "nfsacl.aclent.uid", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_nfsacl_aclent_perm, {\r\n"Permissions", "nfsacl.aclent.perm", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL }},\r\n{ &hf_nfsacl_aclent_perm_read, {\r\n"READ", "nfsacl.aclent.perm.read", FT_BOOLEAN, 32,\r\nTFS(&tfs_yes_no), NA_READ, NULL, HFILL }},\r\n{ &hf_nfsacl_aclent_perm_write, {\r\n"WRITE", "nfsacl.aclent.perm.write", FT_BOOLEAN, 32,\r\nTFS(&tfs_yes_no), NA_WRITE, NULL, HFILL }},\r\n{ &hf_nfsacl_aclent_perm_exec, {\r\n"EXEC", "nfsacl.aclent.perm.exec", FT_BOOLEAN, 32,\r\nTFS(&tfs_yes_no), NA_EXEC, NULL, HFILL }},\r\n{ &hf_nfsacl_create, {\r\n"create", "nfsacl.create", FT_BOOLEAN, BASE_NONE,\r\nTFS(&tfs_yes_no), 0x0, "Create?", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_nfsacl,\r\n&ett_nfsacl_mask,\r\n&ett_nfsacl_entry,\r\n&ett_nfsacl_aclent,\r\n&ett_nfsacl_aclent_perm,\r\n&ett_nfsacl_aclent_entries\r\n};\r\nproto_nfsacl = proto_register_protocol("NFSACL", "NFSACL", "nfsacl");\r\nproto_register_field_array(proto_nfsacl, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_nfsacl(void)\r\n{\r\nrpc_init_prog(proto_nfsacl, NFSACL_PROGRAM, ett_nfsacl,\r\nG_N_ELEMENTS(nfsacl_vers_info), nfsacl_vers_info);\r\n}
