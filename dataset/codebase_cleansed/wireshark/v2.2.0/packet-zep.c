static int dissect_zep(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ntvbuff_t *next_tvb;\r\nproto_item *proto_root, *pi;\r\nproto_tree *zep_tree;\r\nguint8 ieee_packet_len;\r\nguint8 zep_header_len;\r\nzep_info zep_data;\r\ndissector_handle_t next_dissector;\r\nif(strcmp(tvb_get_string_enc(wmem_packet_scope(), tvb, 0, 2, ENC_ASCII), ZEP_PREAMBLE)){\r\nreturn 0;\r\n}\r\nmemset(&zep_data, 0, sizeof(zep_data));\r\nzep_data.version = tvb_get_guint8(tvb, 2);\r\nif (zep_data.version == 1) {\r\nzep_header_len = ZEP_V1_HEADER_LEN;\r\nzep_data.type = 0;\r\nzep_data.channel_id = tvb_get_guint8(tvb, 3);\r\nzep_data.device_id = tvb_get_ntohs(tvb, 4);\r\nzep_data.lqi_mode = tvb_get_guint8(tvb, 6)?1:0;\r\nzep_data.lqi = tvb_get_guint8(tvb, 7);\r\nieee_packet_len = (tvb_get_guint8(tvb, ZEP_V1_HEADER_LEN - 1) & ZEP_LENGTH_MASK);\r\n}\r\nelse {\r\nzep_data.type = tvb_get_guint8(tvb, 3);\r\nif (zep_data.type == ZEP_V2_TYPE_ACK) {\r\nzep_header_len = ZEP_V2_ACK_LEN;\r\nzep_data.seqno = tvb_get_ntohl(tvb, 4);\r\nieee_packet_len = 0;\r\n}\r\nelse {\r\nzep_header_len = ZEP_V2_HEADER_LEN;\r\nzep_data.channel_id = tvb_get_guint8(tvb, 4);\r\nzep_data.device_id = tvb_get_ntohs(tvb, 5);\r\nzep_data.lqi_mode = tvb_get_guint8(tvb, 7)?1:0;\r\nzep_data.lqi = tvb_get_guint8(tvb, 8);\r\nntp_to_nstime(tvb, 9, &(zep_data.ntp_time));\r\nzep_data.seqno = tvb_get_ntohl(tvb, 17);\r\nieee_packet_len = (tvb_get_guint8(tvb, ZEP_V2_HEADER_LEN - 1) & ZEP_LENGTH_MASK);\r\n}\r\n}\r\n#if 0\r\nif (zep_data.ntp_time.secs && zep_data.ntp_time.nsecs) {\r\npinfo->abs_ts = zep_data.ntp_time;\r\n}\r\n#endif\r\nif(ieee_packet_len < tvb_reported_length(tvb)-zep_header_len){\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, (zep_data.version==1)?"ZEP":"ZEPv2");\r\nif (!((zep_data.version>=2) && (zep_data.type==ZEP_V2_TYPE_ACK)))\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Encapsulated ZigBee Packet [Channel]=%i [Length]=%i", zep_data.channel_id, ieee_packet_len);\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Ack, Sequence Number: %i", zep_data.seqno);\r\nif(tree){\r\nif (!((zep_data.version>=2) && (zep_data.type==ZEP_V2_TYPE_ACK))) {\r\nproto_root = proto_tree_add_protocol_format(tree, proto_zep, tvb, 0, zep_header_len, "ZigBee Encapsulation Protocol, Channel: %i, Length: %i", zep_data.channel_id, ieee_packet_len);\r\n}\r\nelse {\r\nproto_root = proto_tree_add_protocol_format(tree, proto_zep, tvb, 0, zep_header_len, "ZigBee Encapsulation Protocol, Ack");\r\n}\r\nzep_tree = proto_item_add_subtree(proto_root, ett_zep);\r\nproto_tree_add_item(zep_tree, hf_zep_protocol_id, tvb, 0, 2, ENC_NA|ENC_ASCII);\r\nif (zep_data.version==1) {\r\nproto_tree_add_uint(zep_tree, hf_zep_version, tvb, 2, 1, zep_data.version);\r\nproto_tree_add_uint(zep_tree, hf_zep_channel_id, tvb, 3, 1, zep_data.channel_id);\r\nproto_tree_add_uint(zep_tree, hf_zep_device_id, tvb, 4, 2, zep_data.device_id);\r\nproto_tree_add_boolean_format(zep_tree, hf_zep_lqi_mode, tvb, 6, 1, zep_data.lqi_mode, "LQI/CRC Mode: %s", zep_data.lqi_mode?"CRC":"LQI");\r\nif(!(zep_data.lqi_mode)){\r\nproto_tree_add_uint(zep_tree, hf_zep_lqi, tvb, 7, 1, zep_data.lqi);\r\n}\r\nproto_tree_add_item(zep_tree, hf_zep_reserved_field, tvb, 7+((zep_data.lqi_mode)?0:1), 7+((zep_data.lqi_mode)?1:0), ENC_NA);\r\n}\r\nelse {\r\nproto_tree_add_uint(zep_tree, hf_zep_version, tvb, 2, 1, zep_data.version);\r\nif (zep_data.type == ZEP_V2_TYPE_ACK) {\r\nproto_tree_add_uint_format_value(zep_tree, hf_zep_type, tvb, 3, 1, zep_data.type, "%i (Ack)", ZEP_V2_TYPE_ACK);\r\nproto_tree_add_uint(zep_tree, hf_zep_seqno, tvb, 4, 4, zep_data.seqno);\r\n}\r\nelse {\r\nproto_tree_add_uint_format_value(zep_tree, hf_zep_type, tvb, 3, 1, zep_data.type, "%i (%s)", zep_data.type, (zep_data.type==ZEP_V2_TYPE_DATA)?"Data":"Reserved");\r\nproto_tree_add_uint(zep_tree, hf_zep_channel_id, tvb, 4, 1, zep_data.channel_id);\r\nproto_tree_add_uint(zep_tree, hf_zep_device_id, tvb, 5, 2, zep_data.device_id);\r\nproto_tree_add_boolean_format(zep_tree, hf_zep_lqi_mode, tvb, 7, 1, zep_data.lqi_mode, "LQI/CRC Mode: %s", zep_data.lqi_mode?"CRC":"LQI");\r\nif(!(zep_data.lqi_mode)){\r\nproto_tree_add_uint(zep_tree, hf_zep_lqi, tvb, 8, 1, zep_data.lqi);\r\n}\r\npi = proto_tree_add_time(zep_tree, hf_zep_timestamp, tvb, 9, 8, &(zep_data.ntp_time));\r\nproto_item_append_text(pi, " (%ld.%09ds)", (long)zep_data.ntp_time.secs, zep_data.ntp_time.nsecs);\r\nproto_tree_add_uint(zep_tree, hf_zep_seqno, tvb, 17, 4, zep_data.seqno);\r\n}\r\n}\r\nif (!((zep_data.version==2) && (zep_data.type==ZEP_V2_TYPE_ACK)))\r\nproto_tree_add_uint_format_value(zep_tree, hf_zep_ieee_length, tvb, zep_header_len - 1, 1, ieee_packet_len, "%i %s", ieee_packet_len, (ieee_packet_len==1)?"Byte":"Bytes");\r\n}\r\nif (zep_data.lqi_mode) {\r\nnext_dissector = ieee802154_handle;\r\n}\r\nelse {\r\nnext_dissector = ieee802154_ccfcs_handle;\r\n}\r\nif (!next_dissector) {\r\nnext_dissector = data_handle;\r\n}\r\nif (!((zep_data.version>=2) && (zep_data.type==ZEP_V2_TYPE_ACK))) {\r\nnext_tvb = tvb_new_subset_length(tvb, zep_header_len, ieee_packet_len);\r\ncall_dissector(next_dissector, next_tvb, pinfo, tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_zep(void)\r\n{\r\nmodule_t *zep_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_zep_version,\r\n{ "Protocol Version", "zep.version", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The version of the sniffer.", HFILL }},\r\n{ &hf_zep_type,\r\n{ "Type", "zep.type", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_zep_channel_id,\r\n{ "Channel ID", "zep.channel_id", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The logical channel on which this packet was detected.", HFILL }},\r\n{ &hf_zep_device_id,\r\n{ "Device ID", "zep.device_id", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n"The ID of the device that detected this packet.", HFILL }},\r\n{ &hf_zep_lqi_mode,\r\n{ "LQI/CRC Mode", "zep.lqi_mode", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Determines what format the last two bytes of the MAC frame use.", HFILL }},\r\n{ &hf_zep_lqi,\r\n{ "Link Quality Indication", "zep.lqi", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_zep_timestamp,\r\n{ "Timestamp", "zep.time", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_zep_seqno,\r\n{ "Sequence Number", "zep.seqno", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_zep_ieee_length,\r\n{ "Length", "zep.length", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The length (in bytes) of the encapsulated IEEE 802.15.4 MAC frame.", HFILL }},\r\n{ &hf_zep_protocol_id,\r\n{ "Protocol ID String", "zep.protocol_id", FT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_zep_reserved_field,\r\n{ "Reserved Fields", "zep.reserved_field", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_zep\r\n};\r\nproto_zep = proto_register_protocol("ZigBee Encapsulation Protocol", "ZEP", "zep");\r\nproto_register_field_array(proto_zep, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nzep_module = prefs_register_protocol(proto_zep, proto_reg_handoff_zep);\r\nprefs_register_uint_preference(zep_module, "udp.port", "ZEP UDP port",\r\n"Set the port for ZEP Protocol\n"\r\n"Default port is 17754",\r\n10, &gPREF_zep_udp_port);\r\nzep_handle = register_dissector("zep", dissect_zep, proto_zep);\r\n}\r\nvoid proto_reg_handoff_zep(void)\r\n{\r\nstatic int lastPort;\r\nstatic gboolean inited = FALSE;\r\nif ( !inited) {\r\ndissector_handle_t h;\r\nif ( !(h = find_dissector("wpan")) ) {\r\nh = find_dissector("ieee802154");\r\n}\r\nieee802154_handle = h;\r\nif ( !(h = find_dissector("wpan_cc24xx")) ) {\r\nh = find_dissector("ieee802154_ccfcs");\r\n}\r\nieee802154_ccfcs_handle = h;\r\ndata_handle = find_dissector("data");\r\ninited = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", lastPort, zep_handle);\r\n}\r\ndissector_add_uint("udp.port", gPREF_zep_udp_port, zep_handle);\r\nlastPort = gPREF_zep_udp_port;\r\n}
