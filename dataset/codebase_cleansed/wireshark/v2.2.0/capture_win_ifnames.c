static int gethexdigit(const char *p)\r\n{\r\nif(*p >= '0' && *p <= '9'){\r\nreturn *p - '0';\r\n}else if(*p >= 'A' && *p <= 'F'){\r\nreturn *p - 'A' + 0xA;\r\n}else if(*p >= 'a' && *p <= 'f'){\r\nreturn *p - 'a' + 0xa;\r\n}else{\r\nreturn -1;\r\n}\r\n}\r\nstatic gboolean get8hexdigits(const char *p, DWORD *d)\r\n{\r\nint digit;\r\nDWORD val;\r\nint i;\r\nval = 0;\r\nfor(i = 0; i < 8; i++){\r\ndigit = gethexdigit(p++);\r\nif(digit == -1){\r\nreturn FALSE;\r\n}\r\nval = (val << 4) | digit;\r\n}\r\n*d = val;\r\nreturn TRUE;\r\n}\r\nstatic gboolean get4hexdigits(const char *p, WORD *w)\r\n{\r\nint digit;\r\nWORD val;\r\nint i;\r\nval = 0;\r\nfor(i = 0; i < 4; i++){\r\ndigit = gethexdigit(p++);\r\nif(digit == -1){\r\nreturn FALSE;\r\n}\r\nval = (val << 4) | digit;\r\n}\r\n*w = val;\r\nreturn TRUE;\r\n}\r\ngboolean\r\nparse_as_guid(const char *guid_text, GUID *guid)\r\n{\r\nint i;\r\nint digit1, digit2;\r\nif(*guid_text != '{'){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\nif(!get8hexdigits(guid_text, &guid->Data1)){\r\nreturn FALSE;\r\n}\r\nguid_text += 8;\r\nif(*guid_text != '-'){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\nif(!get4hexdigits(guid_text, &guid->Data2)){\r\nreturn FALSE;\r\n}\r\nguid_text += 4;\r\nif(*guid_text != '-'){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\nif(!get4hexdigits(guid_text, &guid->Data3)){\r\nreturn FALSE;\r\n}\r\nguid_text += 4;\r\nif(*guid_text != '-'){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\nfor(i = 0; i < 2; i++){\r\ndigit1 = gethexdigit(guid_text);\r\nif(digit1 == -1){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\ndigit2 = gethexdigit(guid_text);\r\nif(digit2 == -1){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\nguid->Data4[i] = (digit1 << 4)|(digit2);\r\n}\r\nif(*guid_text != '-'){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\nfor(i = 0; i < 6; i++){\r\ndigit1 = gethexdigit(guid_text);\r\nif(digit1 == -1){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\ndigit2 = gethexdigit(guid_text);\r\nif(digit2 == -1){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\nguid->Data4[i+2] = (digit1 << 4)|(digit2);\r\n}\r\nif(*guid_text != '}'){\r\nreturn FALSE;\r\n}\r\nguid_text++;\r\nif(*guid_text != '\0'){\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\ngboolean IsWindowsVistaOrLater()\r\n{\r\n#if (_MSC_VER >= 1800)\r\nOSVERSIONINFOEX osvi;\r\nDWORDLONG dwlConditionMask = 0;\r\nint op = VER_GREATER_EQUAL;\r\nSecureZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));\r\nosvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);\r\nosvi.dwMajorVersion = 6;\r\nVER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, op);\r\nreturn VerifyVersionInfo(&osvi, VER_MAJORVERSION, dwlConditionMask);\r\n#else\r\nOSVERSIONINFO osvi;\r\nSecureZeroMemory(&osvi, sizeof(OSVERSIONINFO));\r\nosvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\r\nif(GetVersionEx(&osvi)){\r\nreturn osvi.dwMajorVersion >= 6;\r\n}\r\nreturn FALSE;\r\n#endif\r\n}\r\nchar *\r\nget_interface_friendly_name_from_device_guid(__in GUID *guid)\r\n{\r\nHMODULE hIPHlpApi;\r\nHRESULT status;\r\nWCHAR wName[NDIS_IF_MAX_STRING_SIZE + 1];\r\nHRESULT hr;\r\ngboolean fallbackToUnpublishedApi=TRUE;\r\ngboolean haveInterfaceFriendlyName=FALSE;\r\nint size;\r\nchar *name;\r\nhIPHlpApi = LoadLibrary(TEXT("iphlpapi.dll"));\r\nif (hIPHlpApi == NULL) {\r\nreturn NULL;\r\n}\r\nif(IsWindowsVistaOrLater()){\r\ntypedef NETIO_STATUS (WINAPI *ProcAddr_CIG2L) (__in CONST GUID *InterfaceGuid, __out PNET_LUID InterfaceLuid);\r\ntypedef NETIO_STATUS (WINAPI *ProcAddr_CIL2A) ( __in CONST NET_LUID *InterfaceLuid,__out_ecount(Length) PWSTR InterfaceAlias, __in SIZE_T Length);\r\nProcAddr_CIG2L proc_ConvertInterfaceGuidToLuid=(ProcAddr_CIG2L) GetProcAddress(hIPHlpApi, "ConvertInterfaceGuidToLuid");\r\nif(proc_ConvertInterfaceGuidToLuid!=NULL){\r\nProcAddr_CIL2A Proc_ConvertInterfaceLuidToAlias=(ProcAddr_CIL2A) GetProcAddress(hIPHlpApi, "ConvertInterfaceLuidToAlias");\r\nif(Proc_ConvertInterfaceLuidToAlias!=NULL){\r\nNET_LUID InterfaceLuid;\r\nhr = proc_ConvertInterfaceGuidToLuid(guid, &InterfaceLuid);\r\nif(hr==NO_ERROR){\r\nhr = Proc_ConvertInterfaceLuidToAlias(&InterfaceLuid, wName, NDIS_IF_MAX_STRING_SIZE+1);\r\nif(hr==NO_ERROR){\r\nhaveInterfaceFriendlyName=TRUE;\r\n}else{\r\nfallbackToUnpublishedApi=FALSE;\r\n}\r\n}else{\r\nfallbackToUnpublishedApi=FALSE;\r\n}\r\n}\r\n}\r\n}\r\nif(fallbackToUnpublishedApi && !haveInterfaceFriendlyName){\r\ntypedef HRESULT (WINAPI *ProcAddr_nhGINFG) (__in GUID *InterfaceGuid, __out PCWSTR InterfaceAlias, __inout DWORD *LengthAddress, wchar_t *a4, wchar_t *a5);\r\nProcAddr_nhGINFG Proc_nhGetInterfaceNameFromGuid = NULL;\r\nProc_nhGetInterfaceNameFromGuid = (ProcAddr_nhGINFG) GetProcAddress(hIPHlpApi, "NhGetInterfaceNameFromGuid");\r\nif (Proc_nhGetInterfaceNameFromGuid!= NULL) {\r\nwchar_t *p4=NULL, *p5=NULL;\r\nDWORD NameSize;\r\nNameSize = sizeof(wName);\r\nstatus = Proc_nhGetInterfaceNameFromGuid(guid, wName, &NameSize, p4, p5);\r\nif(status==0){\r\nhaveInterfaceFriendlyName=TRUE;\r\n}\r\n}\r\n}\r\nFreeLibrary(hIPHlpApi);\r\nif(!haveInterfaceFriendlyName){\r\nreturn NULL;\r\n}\r\nsize=WideCharToMultiByte(CP_UTF8, 0, wName, -1, NULL, 0, NULL, NULL);\r\nname=(char *) g_malloc(size);\r\nif (name == NULL){\r\nreturn NULL;\r\n}\r\nsize=WideCharToMultiByte(CP_UTF8, 0, wName, -1, name, size, NULL, NULL);\r\nif(size==0){\r\ng_free(name);\r\nreturn NULL;\r\n}\r\nreturn name;\r\n}\r\nchar *\r\nget_windows_interface_friendly_name(const char *interface_devicename)\r\n{\r\nconst char* guid_text;\r\nGUID guid;\r\nif(strncmp("\\Device\\NPF_", interface_devicename, 12)==0){\r\nguid_text=interface_devicename+12;\r\n}else{\r\nguid_text=interface_devicename;\r\n}\r\nif (!parse_as_guid(guid_text, &guid)){\r\nreturn NULL;\r\n}\r\nreturn get_interface_friendly_name_from_device_guid(&guid);\r\n}
