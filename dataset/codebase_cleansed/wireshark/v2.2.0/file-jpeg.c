static void\r\nprocess_marker_segment(proto_tree *tree, tvbuff_t *tvb, guint32 len,\r\nguint16 marker, const char *marker_name)\r\n{\r\nproto_item *ti;\r\nproto_tree *subtree;\r\nif (!tree)\r\nreturn;\r\nti = proto_tree_add_item(tree, hf_marker_segment,\r\ntvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_marker_segment);\r\nproto_item_append_text(ti, ": %s (0x%04X)", marker_name, marker);\r\nproto_tree_add_item(subtree, hf_marker, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_len, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_bytes_format_value(subtree, hf_remain_seg_data, tvb, 4, -1, NULL, "%u bytes", len - 2);\r\n}\r\nstatic void\r\nprocess_sof_header(proto_tree *tree, tvbuff_t *tvb, guint32 len _U_,\r\nguint16 marker, const char *marker_name)\r\n{\r\nproto_item *ti;\r\nproto_tree *subtree;\r\nguint8 count;\r\nguint32 offset;\r\nif (!tree)\r\nreturn;\r\nti = proto_tree_add_item(tree, hf_sof_header,\r\ntvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_marker_segment);\r\nproto_item_append_text(ti, ": %s (0x%04X)", marker_name, marker);\r\nproto_tree_add_item(subtree, hf_marker, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_len, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sof_precision, tvb, 4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sof_lines, tvb, 5, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sof_samples_per_line, tvb, 7, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sof_nf, tvb, 9, 1, ENC_BIG_ENDIAN);\r\ncount = tvb_get_guint8(tvb, 9);\r\noffset = 10;\r\nwhile (count > 0) {\r\nproto_tree_add_item(subtree, hf_sof_c_i, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sof_h_i, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sof_v_i, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sof_tq_i, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\ncount--;\r\n}\r\n}\r\nstatic void\r\nprocess_sos_header(proto_tree *tree, tvbuff_t *tvb, guint32 len _U_,\r\nguint16 marker, const char *marker_name)\r\n{\r\nproto_item *ti;\r\nproto_tree *subtree;\r\nguint8 count;\r\nguint32 offset;\r\nif (!tree)\r\nreturn;\r\nti = proto_tree_add_item(tree, hf_sos_header,\r\ntvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_marker_segment);\r\nproto_item_append_text(ti, ": %s (0x%04X)", marker_name, marker);\r\nproto_tree_add_item(subtree, hf_marker, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_len, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sos_ns, tvb, 4, 1, ENC_BIG_ENDIAN);\r\ncount = tvb_get_guint8(tvb, 4);\r\noffset = 5;\r\nwhile (count > 0) {\r\nproto_tree_add_item(subtree, hf_sos_cs_j, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sos_td_j, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sos_ta_j, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\ncount--;\r\n}\r\nproto_tree_add_item(subtree, hf_sos_ss, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sos_se, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sos_ah, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_sos_al, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n;\r\n}\r\nstatic void\r\nprocess_comment_header(proto_tree *tree, tvbuff_t *tvb, guint32 len,\r\nguint16 marker, const char *marker_name)\r\n{\r\nproto_item *ti;\r\nproto_tree *subtree;\r\nif (!tree)\r\nreturn;\r\nti = proto_tree_add_item(tree, hf_comment_header,\r\ntvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_marker_segment);\r\nproto_item_append_text(ti, ": %s (0x%04X)", marker_name, marker);\r\nproto_tree_add_item(subtree, hf_marker, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_len, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_comment, tvb, 4, len-2, ENC_ASCII|ENC_NA);\r\n}\r\nstatic int\r\nprocess_app0_segment(proto_tree *tree, tvbuff_t *tvb, guint32 len,\r\nguint16 marker, const char *marker_name)\r\n{\r\nproto_item *ti;\r\nproto_tree *subtree;\r\nproto_tree *subtree_details = NULL;\r\nguint32 offset;\r\nchar *str;\r\ngint str_size;\r\nguint16 x, y;\r\nif (!tree)\r\nreturn 0;\r\nti = proto_tree_add_item(tree, hf_marker_segment,\r\ntvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_marker_segment);\r\nproto_item_append_text(ti, ": %s (0x%04X)", marker_name, marker);\r\nproto_tree_add_item(subtree, hf_marker, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_len, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nstr = tvb_get_stringz_enc(wmem_packet_scope(), tvb, 4, &str_size, ENC_ASCII);\r\nti = proto_tree_add_item(subtree, hf_identifier, tvb, 4, str_size, ENC_ASCII|ENC_NA);\r\nif (strcmp(str, "JFIF") == 0) {\r\nti = proto_tree_add_none_format(subtree, hf_version,\r\ntvb, 9, 2, "Version: %u.%u",\r\ntvb_get_guint8(tvb, 9),\r\ntvb_get_guint8(tvb, 10));\r\nsubtree_details = proto_item_add_subtree(ti, ett_details);\r\nproto_tree_add_item(subtree_details, hf_version_major,\r\ntvb, 9, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree_details, hf_version_minor,\r\ntvb, 10, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_units,\r\ntvb, 11, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_xdensity,\r\ntvb, 12, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_ydensity,\r\ntvb, 14, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_xthumbnail,\r\ntvb, 16, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_ythumbnail,\r\ntvb, 17, 1, ENC_BIG_ENDIAN);\r\nx = tvb_get_guint8(tvb, 16);\r\ny = tvb_get_guint8(tvb, 17);\r\nif (x || y) {\r\nproto_tree_add_item(subtree, hf_rgb,\r\ntvb, 18, 3 * (x * y), ENC_NA);\r\noffset = 18 + (3 * (x * y));\r\n} else {\r\noffset = 18;\r\n}\r\n}\r\nelse if (strcmp(str, "JFXX") == 0) {\r\nproto_tree_add_item(subtree, hf_extension_code,\r\ntvb, 9, 1, ENC_BIG_ENDIAN);\r\noffset = 10;\r\n}\r\nelse {\r\nproto_item_append_text(ti, " (unknown identifier)");\r\noffset = 4 + str_size;\r\nproto_tree_add_bytes_format_value(subtree, hf_remain_seg_data, tvb, offset, -1, NULL, "%u bytes", len - 2 - str_size);\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\nprocess_app1_segment(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 len,\r\nguint16 marker, const char *marker_name, gboolean show_first_identifier_not_jfif)\r\n{\r\nproto_item *ti;\r\nproto_tree *subtree;\r\nchar *str;\r\ngint str_size;\r\nint offset = 0;\r\nint tiff_start;\r\nti = proto_tree_add_item(tree, hf_marker_segment,\r\ntvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_marker_segment);\r\nproto_item_append_text(ti, ": %s (0x%04X)", marker_name, marker);\r\nproto_tree_add_item(subtree, hf_marker, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nstr = tvb_get_stringz_enc(wmem_packet_scope(), tvb, offset, &str_size, ENC_ASCII);\r\nti = proto_tree_add_item(subtree, hf_identifier, tvb, offset, str_size, ENC_ASCII|ENC_NA);\r\noffset += str_size;\r\nif (show_first_identifier_not_jfif && strcmp(str, "JFIF") != 0) {\r\nexpert_add_info(pinfo, ti, &ei_file_jpeg_first_identifier_not_jfif);\r\n}\r\nif (strcmp(str, "Exif") == 0) {\r\nint encoding;\r\nguint16 val_16;\r\nguint32 val_32, num_fields;\r\nproto_item* tiff_item;\r\noffset++;\r\ntiff_start = offset;\r\nval_16 = tvb_get_ntohs(tvb, offset);\r\nif (val_16 == 0x4949) {\r\nencoding = ENC_LITTLE_ENDIAN;\r\nproto_tree_add_uint_format_value(subtree, hf_endianness, tvb, offset, 2, val_16, "little endian");\r\n} else if (val_16 == 0x4D4D) {\r\nencoding = ENC_BIG_ENDIAN;\r\nproto_tree_add_uint_format_value(subtree, hf_endianness, tvb, offset, 2, val_16, "big endian");\r\n} else {\r\nproto_tree_add_uint_format_value(subtree, hf_endianness, tvb, offset, 2, val_16,\r\n"Incorrect encoding 0x%04x- skipping the remainder of this application marker", val_16);\r\nreturn offset;\r\n}\r\noffset += 2;\r\noffset += 2;\r\nval_32 = tvb_get_guint32(tvb, offset, encoding);\r\ntiff_item = proto_tree_add_uint_format_value(subtree, hf_start_ifd_offset, tvb, offset, 4, val_32, "%u bytes",\r\nval_32);\r\noffset += 4;\r\nif (val_32 + tiff_start < (guint32)offset) {\r\nexpert_add_info_format(pinfo, tiff_item, &ei_start_ifd_offset, " (bogus, should be >= %u)",\r\noffset- tiff_start);\r\nreturn offset;\r\n}\r\nif (val_32 + tiff_start > (guint32)offset) {\r\nproto_tree_add_bytes_format_value(subtree, hf_skipped_tiff_data, tvb, offset, val_32 + tiff_start - offset, NULL, "%u bytes",\r\nval_32 + tiff_start - offset);\r\n}\r\nfor (;;) {\r\noffset = val_32 + tiff_start;\r\nproto_tree_add_item_ret_uint(subtree, hf_ifd_num_fields, tvb, offset, 2, encoding, &num_fields);\r\noffset += 2;\r\nwhile (num_fields-- > 0) {\r\nproto_tree_add_item(subtree, hf_idf_tag, tvb, offset, 2, encoding);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_idf_type, tvb, offset, 2, encoding);\r\noffset += 2;\r\nproto_tree_add_item(subtree, hf_idf_count, tvb, offset, 4, encoding);\r\noffset += 4;\r\nproto_tree_add_item(subtree, hf_idf_offset, tvb, offset, 4, encoding);\r\noffset += 4;\r\n}\r\nval_32 = tvb_get_guint32(tvb, offset, encoding);\r\ntiff_item = proto_tree_add_uint_format_value(subtree, hf_next_ifd_offset, tvb, offset, 4, val_32, "%u bytes",\r\nval_32);\r\noffset += 4;\r\nif (val_32 != 0 &&\r\nval_32 + tiff_start < (guint32)offset) {\r\nexpert_add_info_format(pinfo, tiff_item, &ei_next_ifd_offset, " (bogus, should be >= %u)", offset + tiff_start);\r\nreturn offset;\r\n}\r\nif (val_32 == 0)\r\nbreak;\r\n}\r\n} else {\r\nproto_tree_add_bytes_format_value(subtree, hf_remain_seg_data, tvb, offset, -1, NULL, "%u bytes", len - 2 - str_size);\r\nproto_item_append_text(ti, " (Unknown identifier)");\r\n}\r\nreturn offset;\r\n}\r\nstatic void\r\nprocess_app2_segment(proto_tree *tree, tvbuff_t *tvb, guint32 len,\r\nguint16 marker, const char *marker_name)\r\n{\r\nproto_item *ti;\r\nproto_tree *subtree;\r\nchar *str;\r\ngint str_size;\r\nif (!tree)\r\nreturn;\r\nti = proto_tree_add_item(tree, hf_marker_segment,\r\ntvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_marker_segment);\r\nproto_item_append_text(ti, ": %s (0x%04X)", marker_name, marker);\r\nproto_tree_add_item(subtree, hf_marker, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(subtree, hf_len, tvb, 2, 2, ENC_BIG_ENDIAN);\r\nstr = tvb_get_stringz_enc(wmem_packet_scope(), tvb, 4, &str_size, ENC_ASCII);\r\nti = proto_tree_add_item(subtree, hf_identifier, tvb, 4, str_size, ENC_ASCII|ENC_NA);\r\nif (strcmp(str, "FPXR") == 0) {\r\nproto_tree_add_item(tree, hf_exif_flashpix_marker, tvb, 0, -1, ENC_NA);\r\n} else {\r\nproto_tree_add_bytes_format_value(subtree, hf_remain_seg_data, tvb, 4 + str_size, -1, NULL, "%u bytes", len - 2 - str_size);\r\nproto_item_append_text(ti, " (Unknown identifier)");\r\n}\r\n}\r\nstatic gint\r\ndissect_jfif(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *subtree;\r\nproto_item *ti;\r\ngint tvb_len = tvb_reported_length(tvb);\r\ngint32 start_entropy = 0;\r\ngint32 start_fill, start_marker;\r\ngboolean show_first_identifier_not_jfif = FALSE;\r\nif (tvb_len < 20)\r\nreturn 0;\r\nif (tvb_get_ntohs(tvb, 0) != MARKER_SOI)\r\nreturn 0;\r\nif (tvb_memeql(tvb, 6, "Exif", 5) == 0) {\r\nshow_first_identifier_not_jfif = TRUE;\r\n}\r\nelse if (tvb_memeql(tvb, 6, "JFIF", 5)) {\r\nreturn 0;\r\n}\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, " ", "(JPEG JFIF image)");\r\nti = proto_tree_add_item(tree, proto_jfif,\r\ntvb, 0, -1, ENC_NA);\r\nsubtree = proto_item_add_subtree(ti, ett_jfif);\r\nfor (; ; ) {\r\nconst char *str;\r\nguint16 marker;\r\nstart_fill = start_entropy;\r\nfor (; ; ) {\r\nstart_fill = tvb_find_guint8(tvb, start_fill, -1, 0xFF);\r\nif (start_fill == -1 || tvb_len - start_fill == 1\r\n|| tvb_get_guint8(tvb, start_fill + 1) != 0)\r\nbreak;\r\nstart_fill += 2;\r\n}\r\nif (start_fill == -1) start_fill = tvb_len;\r\nif (start_fill != start_entropy)\r\nproto_tree_add_item(subtree, hf_entropy_coded_segment, tvb, start_entropy, start_fill - start_entropy, ENC_NA);\r\nif (start_fill == tvb_len) break;\r\nstart_marker = start_fill;\r\nwhile (tvb_get_guint8(tvb, start_marker + 1) == 0xFF)\r\n++start_marker;\r\nif (start_marker != start_fill)\r\nproto_tree_add_item(subtree, hf_fill_bytes, tvb, start_fill, start_marker - start_fill, ENC_NA);\r\nmarker = tvb_get_ntohs(tvb, start_marker);\r\nstr = try_val_to_str(marker, vals_marker);\r\nif (str) {\r\nif (marker_has_length(marker)) {\r\nconst guint16 len = tvb_get_ntohs(tvb, start_marker + 2);\r\ntvbuff_t *tmp_tvb = tvb_new_subset_length(tvb, start_marker, 2 + len);\r\nswitch (marker) {\r\ncase MARKER_APP0:\r\nprocess_app0_segment(subtree, tmp_tvb, len, marker, str);\r\nbreak;\r\ncase MARKER_APP1:\r\nprocess_app1_segment(subtree, tmp_tvb, pinfo, len, marker, str, show_first_identifier_not_jfif);\r\nshow_first_identifier_not_jfif = FALSE;\r\nbreak;\r\ncase MARKER_APP2:\r\nprocess_app2_segment(subtree, tmp_tvb, len, marker, str);\r\nbreak;\r\ncase MARKER_SOF0:\r\ncase MARKER_SOF1:\r\ncase MARKER_SOF2:\r\ncase MARKER_SOF3:\r\ncase MARKER_SOF5:\r\ncase MARKER_SOF6:\r\ncase MARKER_SOF7:\r\ncase MARKER_SOF8:\r\ncase MARKER_SOF9:\r\ncase MARKER_SOF10:\r\ncase MARKER_SOF11:\r\ncase MARKER_SOF13:\r\ncase MARKER_SOF14:\r\ncase MARKER_SOF15:\r\nprocess_sof_header(subtree, tmp_tvb, len, marker, str);\r\nbreak;\r\ncase MARKER_SOS:\r\nprocess_sos_header(subtree, tmp_tvb, len, marker, str);\r\nbreak;\r\ncase MARKER_COM:\r\nprocess_comment_header(subtree, tmp_tvb, len, marker, str);\r\nbreak;\r\ndefault:\r\nprocess_marker_segment(subtree, tmp_tvb, len, marker, str);\r\nbreak;\r\n}\r\nstart_entropy = start_marker + 2 + len;\r\n} else {\r\nproto_tree_add_item(subtree, hf_marker,\r\ntvb, start_marker, 2, ENC_BIG_ENDIAN);\r\nstart_entropy = start_marker + 2;\r\n}\r\n} else {\r\nti = proto_tree_add_item(subtree, hf_marker,\r\ntvb, start_marker, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, " (Reserved)");\r\nreturn tvb_len;\r\n}\r\n}\r\nreturn tvb_len;\r\n}\r\nstatic gboolean\r\ndissect_jfif_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nreturn dissect_jfif(tvb, pinfo, tree, NULL) > 0;\r\n}\r\nvoid\r\nproto_register_jfif(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_marker,\r\n{ "Marker",\r\nIMG_JFIF ".marker",\r\nFT_UINT8, BASE_HEX, VALS(vals_marker), 0x00,\r\n"JFIF Marker",\r\nHFILL\r\n}\r\n},\r\n{ &hf_marker_segment,\r\n{ "Marker segment",\r\nIMG_JFIF ".marker_segment",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_len,\r\n{ "Length",\r\nIMG_JFIF ".length",\r\nFT_UINT16, BASE_DEC, 0, 0x00,\r\n"Length of segment (including length field)",\r\nHFILL\r\n}\r\n},\r\n{ &hf_identifier,\r\n{ "Identifier",\r\nIMG_JFIF ".identifier",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x00,\r\n"Identifier of the segment",\r\nHFILL\r\n}\r\n},\r\n{ &hf_version,\r\n{ "Version",\r\nIMG_JFIF ".version",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\n"JFIF Version",\r\nHFILL\r\n}\r\n},\r\n{ &hf_version_major,\r\n{ "Major Version",\r\nIMG_JFIF ".version.major",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"JFIF Major Version",\r\nHFILL\r\n}\r\n},\r\n{ &hf_version_minor,\r\n{ "Minor Version",\r\nIMG_JFIF ".version.minor",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"JFIF Minor Version",\r\nHFILL\r\n}\r\n},\r\n{ &hf_units,\r\n{ "Units",\r\nIMG_JFIF ".units",\r\nFT_UINT8, BASE_DEC, VALS(vals_units), 0x00,\r\n"Units used in this segment",\r\nHFILL\r\n}\r\n},\r\n{ &hf_xdensity,\r\n{ "Xdensity",\r\nIMG_JFIF ".Xdensity",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\n"Horizontal pixel density",\r\nHFILL\r\n}\r\n},\r\n{ &hf_ydensity,\r\n{ "Ydensity",\r\nIMG_JFIF ".Ydensity",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\n"Vertical pixel density",\r\nHFILL\r\n}\r\n},\r\n{ &hf_xthumbnail,\r\n{ "Xthumbnail",\r\nIMG_JFIF ".Xthumbnail",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\n"Thumbnail horizontal pixel count",\r\nHFILL\r\n}\r\n},\r\n{ &hf_ythumbnail,\r\n{ "Ythumbnail",\r\nIMG_JFIF ".Ythumbnail",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\n"Thumbnail vertical pixel count",\r\nHFILL\r\n}\r\n},\r\n{ &hf_rgb,\r\n{ "RGB values of thumbnail pixels",\r\nIMG_JFIF ".RGB",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\n"RGB values of the thumbnail pixels (24 bit per pixel, Xthumbnail x Ythumbnail pixels)",\r\nHFILL\r\n}\r\n},\r\n{ &hf_extension_code,\r\n{ "Extension code",\r\nIMG_JFIF ".extension.code",\r\nFT_UINT8, BASE_HEX, VALS(vals_extension_code), 0x00,\r\n"JFXX extension code for thumbnail encoding",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sof_header,\r\n{ "Start of Frame header",\r\nIMG_JFIF ".sof",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_sof_precision,\r\n{ "Sample Precision (bits)",\r\nIMG_JFIF ".sof.precision",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"Specifies the precision in bits for the samples of the components in the frame.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sof_lines,\r\n{ "Lines",\r\nIMG_JFIF ".sof.lines",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\n"Specifies the maximum number of lines in the source image.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sof_samples_per_line,\r\n{ "Samples per line",\r\nIMG_JFIF ".sof.samples_per_line",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\n"Specifies the maximum number of samples per line in the source image.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sof_nf,\r\n{ "Number of image components in frame",\r\nIMG_JFIF ".sof.nf",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"Specifies the number of source image components in the frame.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sof_c_i,\r\n{ "Component identifier",\r\nIMG_JFIF ".sof.c_i",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"Assigns a unique label to the ith component in the sequence of frame component specification parameters.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sof_h_i,\r\n{ "Horizontal sampling factor",\r\nIMG_JFIF ".sof.h_i",\r\nFT_UINT8, BASE_DEC, NULL, 0xF0,\r\n"Specifies the relationship between the component horizontal dimension and maximum image dimension X.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sof_v_i,\r\n{ "Vertical sampling factor",\r\nIMG_JFIF ".sof.v_i",\r\nFT_UINT8, BASE_DEC, NULL, 0x0F,\r\n"Specifies the relationship between the component vertical dimension and maximum image dimension Y.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sof_tq_i,\r\n{ "Quantization table destination selector",\r\nIMG_JFIF ".sof.tq_i",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"Specifies one of four possible quantization table destinations from which the quantization table to"\r\n" use for dequantization of DCT coefficients of component Ci is retrieved.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sos_header,\r\n{ "Start of Segment header",\r\nIMG_JFIF ".header.sos",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_sos_ns,\r\n{ "Number of image components in scan",\r\nIMG_JFIF ".sos.ns",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"Specifies the number of source image components in the scan.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sos_cs_j,\r\n{ "Scan component selector",\r\nIMG_JFIF ".sos.component_selector",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"Selects which of the Nf image components specified in the frame parameters shall be the jth"\r\n" component in the scan.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sos_td_j,\r\n{ "DC entropy coding table destination selector",\r\nIMG_JFIF ".sos.dc_entropy_selector",\r\nFT_UINT8, BASE_DEC, NULL, 0xF0,\r\n"Specifies one of four possible DC entropy coding table destinations from which the entropy"\r\n" table needed for decoding of the DC coefficients of component Csj is retrieved.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sos_ta_j,\r\n{ "AC entropy coding table destination selector",\r\nIMG_JFIF ".sos.ac_entropy_selector",\r\nFT_UINT8, BASE_DEC, NULL, 0x0F,\r\n"Specifies one of four possible AC entropy coding table destinations from which the entropy"\r\n" table needed for decoding of the AC coefficients of component Csj is retrieved.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sos_ss,\r\n{ "Start of spectral or predictor selection",\r\nIMG_JFIF ".sos.ss",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"In the DCT modes of operation, this parameter specifies the first DCT coefficient in"\r\n" each block in zig-zag order which shall be coded in the scan. This parameter shall"\r\n" be set to zero for the sequential DCT processes. In the lossless mode of operations"\r\n" this parameter is used to select the predictor.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sos_se,\r\n{ "End of spectral selection",\r\nIMG_JFIF ".sos.se",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"Specifies the last DCT coefficient in each block in zig-zag order which shall be coded"\r\n" in the scan. This parameter shall be set to 63 for the sequential DCT processes. In the"\r\n" lossless mode of operations this parameter has no meaning. It shall be set to zero.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sos_ah,\r\n{ "Successive approximation bit position high",\r\nIMG_JFIF ".sos.ah",\r\nFT_UINT8, BASE_DEC, NULL, 0xF0,\r\n"This parameter specifies the point transform used in the preceding scan (i.e. successive"\r\n" approximation bit position low in the preceding scan) for the band of coefficients"\r\n" specified by Ss and Se. This parameter shall be set to zero for the first scan of each"\r\n" band of coefficients. In the lossless mode of operations this parameter has no meaning."\r\n" It shall be set to zero.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_sos_al,\r\n{ "Successive approximation bit position low or point transform",\r\nIMG_JFIF ".sos.al",\r\nFT_UINT8, BASE_DEC, NULL, 0x0F,\r\n"In the DCT modes of operation this parameter specifies the point transform, i.e. bit"\r\n" position low, used before coding the band of coefficients specified by Ss and Se."\r\n" This parameter shall be set to zero for the sequential DCT processes. In the lossless"\r\n" mode of operations, this parameter specifies the point transform, Pt.",\r\nHFILL\r\n}\r\n},\r\n{ &hf_comment_header,\r\n{ "Comment header",\r\nIMG_JFIF ".header.comment",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_comment,\r\n{ "Comment",\r\nIMG_JFIF ".comment",\r\nFT_STRING, STR_ASCII, NULL, 0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_remain_seg_data,\r\n{ "Remaining segment data",\r\nIMG_JFIF ".remain_seg_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_endianness,\r\n{ "Endianness",\r\nIMG_JFIF ".endianness",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_start_ifd_offset,\r\n{ "Start offset of IFD starting from the TIFF header start",\r\nIMG_JFIF ".start_ifd_offset",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_next_ifd_offset,\r\n{ "Offset to next IFD from start of TIFF header",\r\nIMG_JFIF ".next_ifd_offset",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_exif_flashpix_marker,\r\n{ "Exif FlashPix APP2 application marker",\r\nIMG_JFIF ".exif_flashpix_marker",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_entropy_coded_segment,\r\n{ "Entropy-coded segment (dissection is not yet implemented)",\r\nIMG_JFIF ".entropy_coded_segment",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_fill_bytes,\r\n{ "Fill bytes",\r\nIMG_JFIF ".fill_bytes",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_skipped_tiff_data,\r\n{ "Skipped data between end of TIFF header and start of IFD",\r\nIMG_JFIF ".skipped_tiff_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_ifd_num_fields,\r\n{ "Number of fields in this IFD",\r\nIMG_JFIF ".ifd.num_fields",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_idf_tag,\r\n{ "Exif Tag",\r\nIMG_JFIF ".ifd.tag",\r\nFT_UINT16, BASE_DEC, VALS(vals_exif_tags), 0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_idf_type,\r\n{ "Type",\r\nIMG_JFIF ".ifd.type",\r\nFT_UINT16, BASE_DEC, VALS(vals_exif_types), 0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_idf_count,\r\n{ "Count",\r\nIMG_JFIF ".ifd.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_idf_offset,\r\n{ "Value offset from start of TIFF header",\r\nIMG_JFIF ".ifd.offset",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_jfif,\r\n&ett_marker_segment,\r\n&ett_details,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_file_jpeg_first_identifier_not_jfif,\r\n{ IMG_JFIF ".app0-identifier-not-jfif", PI_MALFORMED, PI_WARN,\r\n"Initial App0 segment with \"JFIF\" Identifier not found", EXPFILL }},\r\n{ &ei_start_ifd_offset,\r\n{ IMG_JFIF ".start_ifd_offset.invalid", PI_PROTOCOL, PI_WARN,\r\n"Invalid value", EXPFILL }},\r\n{ &ei_next_ifd_offset,\r\n{ IMG_JFIF ".next_ifd_offset.invalid", PI_PROTOCOL, PI_WARN,\r\n"Invalid value", EXPFILL }},\r\n};\r\nexpert_module_t* expert_jfif;\r\nproto_jfif = proto_register_protocol(\r\n"JPEG File Interchange Format",\r\n"JFIF (JPEG) image",\r\nIMG_JFIF\r\n);\r\nproto_register_field_array(proto_jfif, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_jfif = expert_register_protocol(proto_jfif);\r\nexpert_register_field_array(expert_jfif, ei, array_length(ei));\r\nregister_dissector(IMG_JFIF, dissect_jfif, proto_jfif);\r\n}\r\nvoid\r\nproto_reg_handoff_jfif(void)\r\n{\r\ndissector_handle_t jfif_handle = find_dissector(IMG_JFIF);\r\ndissector_add_string("media_type", "image/jfif", jfif_handle);\r\ndissector_add_string("media_type", "image/jpg", jfif_handle);\r\ndissector_add_string("media_type", "image/jpeg", jfif_handle);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_JPEG_JFIF, jfif_handle);\r\nheur_dissector_add("http", dissect_jfif_heur, "JPEG file in HTTP", "jfif_http", proto_jfif, HEURISTIC_ENABLE);\r\nheur_dissector_add("wtap_file", dissect_jfif_heur, "JPEG file", "jfif_wtap", proto_jfif, HEURISTIC_ENABLE);\r\n}
