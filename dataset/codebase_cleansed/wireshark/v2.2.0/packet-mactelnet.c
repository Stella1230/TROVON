static int\r\ndissect_mactelnet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *mactelnet_item;\r\nproto_tree *mactelnet_tree;\r\nproto_item *mactelnet_control_item;\r\nproto_tree *mactelnet_control_tree;\r\nint foundping = -1;\r\nint foundclient = -1;\r\nint foundserver = -1;\r\nguint16 type;\r\nif (tvb_captured_length(tvb) < 18)\r\nreturn 0;\r\ntype = tvb_get_guint8(tvb, 1);\r\nif ((type == 4) || (type == 5)) {\r\nfoundping = 1;\r\n} else {\r\nint i = 0;\r\nwhile (clienttypenames[i].strptr != NULL) {\r\nif (tvb_get_ntohs(tvb, 14) == clienttypenames[i].value) {\r\nfoundserver = i;\r\nbreak;\r\n}\r\nif (tvb_get_ntohs(tvb, 16) == clienttypenames[i].value) {\r\nfoundclient = i;\r\nbreak;\r\n}\r\ni++;\r\n}\r\n}\r\nif ((foundping < 0) && (foundclient < 0) && (foundserver < 0)) {\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PROTO_TAG_MACTELNET);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s > %s Direction: %s Type: %s",\r\ntvb_ether_to_str(tvb, 2),\r\ntvb_ether_to_str(tvb, 8),\r\n((foundclient >= 0) || (type == 4) ? "Client->Server" : "Server->Client" ),\r\nval_to_str(type, packettypenames, "Unknown Type:0x%02x")\r\n);\r\nif (tree) {\r\nguint32 offset = 0;\r\nmactelnet_item = proto_tree_add_item(tree, proto_mactelnet, tvb, 0, -1, ENC_NA);\r\nmactelnet_tree = proto_item_add_subtree(mactelnet_item, ett_mactelnet);\r\nproto_tree_add_item(mactelnet_tree, hf_mactelnet_protocolver, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(mactelnet_tree, hf_mactelnet_type, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(mactelnet_tree, hf_mactelnet_source_mac, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(mactelnet_tree, hf_mactelnet_destination_mac, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nif (foundserver >= 0) {\r\nproto_tree_add_item(mactelnet_tree, hf_mactelnet_session_id, tvb, offset+2, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(mactelnet_tree, hf_mactelnet_client_type, tvb, offset-2, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n} else if (foundclient >= 0) {\r\nproto_tree_add_item(mactelnet_tree, hf_mactelnet_session_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(mactelnet_tree, hf_mactelnet_client_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n} else if (foundping >= 0) {\r\noffset += 4;\r\n}\r\nif (foundping < 0) {\r\nproto_tree_add_item(mactelnet_tree, hf_mactelnet_databytes, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n}\r\nif (type == 1) {\r\nwhile(tvb_reported_length_remaining(tvb, offset) > 0) {\r\nif ((tvb_reported_length_remaining(tvb, offset) > 4) && (tvb_get_ntohl(tvb, offset) == control_packet)) {\r\nguint8 datatype;\r\nguint32 datalength;\r\nmactelnet_control_item = proto_tree_add_item(mactelnet_tree, hf_mactelnet_control, tvb, offset, -1, ENC_NA);\r\nmactelnet_control_tree = proto_item_add_subtree(mactelnet_control_item, ett_mactelnet);\r\nproto_tree_add_item(mactelnet_control_tree, hf_mactelnet_control_packet, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\ndatatype = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(mactelnet_control_tree, hf_mactelnet_datatype, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\ndatalength = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_item(mactelnet_control_tree, hf_mactelnet_control_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nswitch (datatype) {\r\ncase 1:\r\nproto_tree_add_item(mactelnet_control_tree, hf_mactelnet_control_encryption_key, tvb, offset, datalength, ENC_NA);\r\nbreak;\r\ncase 2:\r\nproto_tree_add_item(mactelnet_control_tree, hf_mactelnet_control_password, tvb, offset, datalength, ENC_NA);\r\nbreak;\r\ncase 3:\r\nproto_tree_add_item(mactelnet_control_tree, hf_mactelnet_control_username, tvb, offset, datalength, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase 4:\r\nproto_tree_add_item(mactelnet_control_tree, hf_mactelnet_control_terminal, tvb, offset, datalength, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase 5:\r\nproto_tree_add_item(mactelnet_control_tree, hf_mactelnet_control_width, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase 6:\r\nproto_tree_add_item(mactelnet_control_tree, hf_mactelnet_control_height, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase 9:\r\nbreak;\r\n}\r\nproto_item_set_len (mactelnet_control_item, datalength + 9);\r\noffset += datalength;\r\n} else {\r\ntvbuff_t *next_client = tvb_new_subset_remaining(tvb, offset);\r\nreturn call_data_dissector(next_client, pinfo, mactelnet_tree);\r\n}\r\n}\r\n} else if ((type == 4) || (type == 5)) {\r\ntvbuff_t *next_client = tvb_new_subset_remaining(tvb, offset);\r\nreturn call_data_dissector(next_client, pinfo, mactelnet_tree);\r\n}\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_mactelnet(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_mactelnet_control_packet,\r\n{ "Control Packet Magic Number", "mactelnet.control_packet",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_type,\r\n{ "Type", "mactelnet.type",\r\nFT_UINT8, BASE_DEC, VALS(packettypenames), 0x0,\r\n"Packet Type", HFILL }\r\n},\r\n{ &hf_mactelnet_protocolver,\r\n{ "Protocol Version", "mactelnet.protocol_version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_source_mac,\r\n{ "Source MAC", "mactelnet.source_mac",\r\nFT_ETHER, BASE_NONE, NULL , 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_destination_mac,\r\n{ "Destination MAC", "mactelnet.destination_mac",\r\nFT_ETHER, BASE_NONE, NULL , 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_session_id,\r\n{ "Session ID", "mactelnet.session_id",\r\nFT_UINT16, BASE_HEX, NULL , 0x0,\r\n"Session ID for this connection", HFILL }\r\n},\r\n{ &hf_mactelnet_client_type,\r\n{ "Client Type", "mactelnet.client_type",\r\nFT_UINT16, BASE_HEX, VALS(clienttypenames) , 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_databytes,\r\n{ "Session Data Bytes", "mactelnet.session_bytes",\r\nFT_UINT32, BASE_DEC, NULL , 0x0,\r\n"Session data bytes received", HFILL }\r\n},\r\n{ &hf_mactelnet_datatype,\r\n{ "Data Packet Type", "mactelnet.data_type",\r\nFT_UINT8, BASE_HEX, VALS(controlpackettypenames) , 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_control,\r\n{ "Control Packet", "mactelnet.control",\r\nFT_NONE, BASE_NONE, NULL , 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_control_length,\r\n{ "Control Data Length", "mactelnet.control_length",\r\nFT_UINT32, BASE_DEC, NULL , 0x0,\r\n"Control packet length", HFILL }\r\n},\r\n{ &hf_mactelnet_control_encryption_key,\r\n{ "Encryption Key", "mactelnet.control_encryptionkey",\r\nFT_BYTES, BASE_NONE, NULL , 0x0,\r\n"Login encryption key", HFILL }\r\n},\r\n{ &hf_mactelnet_control_password,\r\n{ "Password MD5", "mactelnet.control_password",\r\nFT_BYTES, BASE_NONE, NULL , 0x0,\r\n"Null padded MD5 password", HFILL }\r\n},\r\n{ &hf_mactelnet_control_username,\r\n{ "Username", "mactelnet.control_username",\r\nFT_STRING, BASE_NONE, NULL , 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_control_terminal,\r\n{ "Terminal Type", "mactelnet.control_terminaltype",\r\nFT_STRING, BASE_NONE, NULL , 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_control_width,\r\n{ "Terminal Width", "mactelnet.control_width",\r\nFT_UINT16, BASE_DEC, NULL , 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mactelnet_control_height,\r\n{ "Terminal Height", "mactelnet.control_height",\r\nFT_UINT16, BASE_DEC, NULL , 0x0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mactelnet,\r\n&ett_mactelnet_control,\r\n};\r\nmodule_t *mactelnet_module;\r\nproto_mactelnet = proto_register_protocol ("MikroTik MAC-Telnet Protocol", PROTO_TAG_MACTELNET, "mactelnet");\r\nproto_register_field_array (proto_mactelnet, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nmactelnet_module = prefs_register_protocol(proto_mactelnet, proto_reg_handoff_mactelnet);\r\nprefs_register_uint_preference(mactelnet_module, "port", "UDP Port",\r\n"MAC-Telnet UDP port if other than the default",\r\n10, &global_mactelnet_port);\r\n}\r\nvoid\r\nproto_reg_handoff_mactelnet(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic guint current_port;\r\nstatic dissector_handle_t mactelnet_handle;\r\nif (!initialized) {\r\nmactelnet_handle = create_dissector_handle(dissect_mactelnet, proto_mactelnet);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", current_port, mactelnet_handle);\r\n}\r\ncurrent_port = global_mactelnet_port;\r\ndissector_add_uint("udp.port", current_port, mactelnet_handle);\r\n}
