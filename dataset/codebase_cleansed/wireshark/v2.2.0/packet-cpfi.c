static void\r\ndissect_cpfi_header(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint32 word1;\r\n#if 0\r\nguint32 word2;\r\n#endif\r\nguint32 tda;\r\nguint32 src;\r\nguint8 src_instance = 0;\r\nguint8 src_board = 0;\r\nguint8 src_port = 0;\r\nguint32 dst;\r\nguint8 dst_instance = 0;\r\nguint8 dst_board = 0;\r\nguint8 dst_port = 0;\r\nproto_tree *extra_tree = NULL;\r\nif ( tree != NULL)\r\n{\r\nproto_item *extra_item;\r\nextra_item = proto_tree_add_protocol_format(tree, proto_cpfi, tvb, 0, -1, "Header");\r\nextra_tree = proto_item_add_subtree(extra_item, ett_cpfi_header);\r\n}\r\nword1 = tvb_get_ntohl (tvb, 0);\r\n#if 0\r\nword2 = tvb_get_ntohl (tvb, sizeof(word1));\r\n#endif\r\ntda = (word1 & CPFI_DEST_MASK) >> CPFI_DEST_SHIFT;\r\nif ( tda >= FIRST_TIO_CARD_ADDRESS )\r\n{\r\ng_strlcpy(src_str, " CPFI", sizeof(src_str));\r\nsrc = 0;\r\n}\r\nelse\r\n{\r\nconst guint8 *srcmac;\r\nDISSECTOR_ASSERT(pinfo->src.type == AT_ETHER);\r\nsrcmac = (const guint8 *)pinfo->src.data;\r\nsrc_instance = srcmac[2]-1;\r\nsrc_board = tda >> 4;\r\nsrc_port = tda & 0x0f;\r\nsrc = (1 << 24) + (src_instance << 16) + (src_board << 8) + src_port;\r\ng_snprintf(src_str, sizeof(src_str), "%u.%u.%u", src_instance, src_board, src_port);\r\n}\r\ntda = (word1 & CPFI_SOURCE_MASK) >> CPFI_SOURCE_SHIFT;\r\nif ( tda >= FIRST_TIO_CARD_ADDRESS )\r\n{\r\ng_strlcpy(dst_str, " CPFI", sizeof(dst_str));\r\ndst = 0;\r\n}\r\nelse\r\n{\r\nconst guint8 *dstmac;\r\nDISSECTOR_ASSERT(pinfo->dst.type == AT_ETHER);\r\ndstmac = (const guint8 *)pinfo->dst.data;\r\ndst_instance = dstmac[2]-1;\r\ndst_board = tda >> 4;\r\ndst_port = tda & 0x0f;\r\ndst = (1 << 24) + (dst_instance << 16) + (dst_board << 8) + dst_port;\r\ng_snprintf(dst_str, sizeof(dst_str), "%u.%u.%u", dst_instance, dst_board, dst_port);\r\n}\r\nif ( cpfi_arrow_moves && (dst < src) )\r\n{\r\nleft = dst_str;\r\narrow = r_to_l_arrow;\r\nright = src_str;\r\n}\r\nelse\r\n{\r\nleft = src_str;\r\narrow = l_to_r_arrow;\r\nright = dst_str;\r\n}\r\nif (extra_tree) {\r\nproto_item *hidden_item;\r\nif ( src != 0 )\r\n{\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_instance, tvb, 0, 1, &src_instance);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_src_instance, tvb, 0, 1, &src_instance);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_board, tvb, 0, 1, &src_board);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_src_board, tvb, 0, 1, &src_board);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_port, tvb, 0, 1, &src_port);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_src_port, tvb, 0, 1, &src_port);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\n}\r\nif ( dst != 0 )\r\n{\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_instance, tvb, 0, 1, &dst_instance);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_dst_instance, tvb, 0, 1, &dst_instance);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_board, tvb, 0, 1, &dst_board);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_dst_board, tvb, 0, 1, &dst_board);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_port, tvb, 0, 1, &dst_port);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_bytes(extra_tree, hf_cpfi_t_dst_port, tvb, 0, 1, &dst_port);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\n}\r\nproto_tree_add_item(extra_tree, hf_cpfi_word_one , tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(extra_tree, hf_cpfi_frame_type, tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(extra_tree, hf_cpfi_source , tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(extra_tree, hf_cpfi_dest , tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(extra_tree, hf_cpfi_SOF_type , tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(extra_tree, hf_cpfi_speed , tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(extra_tree, hf_cpfi_OPM_error , tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(extra_tree, hf_cpfi_from_LCM , tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(extra_tree, hf_cpfi_word_two , tvb, 4, 4, ENC_BIG_ENDIAN);\r\n};\r\n}\r\nstatic void\r\ndissect_cpfi_footer(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree *extra_tree = NULL;\r\nif ( tree != NULL)\r\n{\r\nproto_item *extra_item;\r\nextra_item = proto_tree_add_protocol_format(tree, proto_cpfi, tvb, 0, -1, "Footer");\r\nextra_tree = proto_item_add_subtree(extra_item, ett_cpfi_footer);\r\n}\r\nif (extra_tree) {\r\nproto_tree_add_item(extra_tree, hf_cpfi_CRC_32 , tvb, 0, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(extra_tree, hf_cpfi_EOF_type, tvb, 4, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic int\r\ndissect_cpfi(tvbuff_t *message_tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ntvbuff_t *header_tvb, *body_tvb, *footer_tvb;\r\nproto_item *cpfi_item = NULL;\r\nproto_tree *cpfi_tree = NULL;\r\ngint length, reported_length, body_length, reported_body_length;\r\nguint8 frame_type;\r\nfc_data_t fc_data;\r\nframe_type = (tvb_get_ntohl (message_tvb, 0) & CPFI_FRAME_TYPE_MASK) >> CPFI_FRAME_TYPE_SHIFT;\r\nif ( !((frame_type == 9) && fc_handle) )\r\nreturn 0;\r\nif (pinfo->dst.type != AT_ETHER || pinfo->src.type != AT_ETHER)\r\nreturn 0;\r\nlength = tvb_captured_length_remaining(message_tvb, 8);\r\nreported_length = tvb_reported_length_remaining(message_tvb, 8);\r\nif (reported_length < 8)\r\n{\r\nreturn 0;\r\n}\r\nreported_body_length = reported_length - 8;\r\nbody_length = length;\r\nif (body_length > reported_body_length)\r\nbody_length = reported_body_length;\r\nlength = tvb_captured_length_remaining(message_tvb, 8+body_length);\r\nif (length < 0)\r\n{\r\nreturn 0;\r\n}\r\nif (tree) {\r\ncpfi_item = proto_tree_add_item(tree, proto_cpfi, message_tvb, 0, -1, ENC_NA);\r\ncpfi_tree = proto_item_add_subtree(cpfi_item, ett_cpfi);\r\n}\r\nfc_data.sof_eof = 0;\r\nfc_data.sof_eof |= FC_DATA_SOF_FIRST_FRAME;\r\nfc_data.sof_eof |= FC_DATA_EOF_LAST_FRAME;\r\nfc_data.sof_eof |= FC_DATA_EOF_INVALID;\r\nheader_tvb = tvb_new_subset_length(message_tvb, 0, 8);\r\ndissect_cpfi_header(header_tvb, pinfo, cpfi_tree);\r\nbody_tvb = tvb_new_subset(message_tvb, 8, body_length, reported_body_length);\r\nfc_data.ethertype = 0;\r\ncall_dissector_with_data(fc_handle, body_tvb, pinfo, tree, &fc_data);\r\nproto_item_append_text(cpfi_item, direction_and_port_string, left, arrow, right);\r\ncol_prepend_fstr(pinfo->cinfo, COL_INFO, direction_and_port_string, left, arrow, right);\r\nfooter_tvb = tvb_new_subset(message_tvb, 8+body_length, length, 8);\r\ndissect_cpfi_footer(footer_tvb, cpfi_tree);\r\nreturn(tvb_reported_length(message_tvb));\r\n}\r\nvoid\r\nproto_register_cpfi(void)\r\n{\r\nmodule_t *cpfi_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_cpfi_word_one,\r\n{ "Word one", "cpfi.word_one",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_cpfi_word_two,\r\n{ "Word two", "cpfi.word_two",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_cpfi_frame_type,\r\n{ "FrmType", "cpfi.frmtype",\r\nFT_UINT32, BASE_HEX, NULL, CPFI_FRAME_TYPE_MASK,\r\n"Frame Type", HFILL}},\r\n{ &hf_cpfi_source,\r\n{ "srcTDA", "cpfi.srcTDA",\r\nFT_UINT32, BASE_HEX, NULL, CPFI_SOURCE_MASK,\r\n"Source TDA (10 bits)", HFILL}},\r\n{ &hf_cpfi_dest,\r\n{ "dstTDA", "cpfi.dstTDA",\r\nFT_UINT32, BASE_HEX, NULL, CPFI_DEST_MASK,\r\n"Source TDA (10 bits)", HFILL}},\r\n{ &hf_cpfi_SOF_type,\r\n{ "SOFtype", "cpfi.SOFtype",\r\nFT_UINT32, BASE_HEX, VALS(sof_type_vals), CPFI_SOF_TYPE_MASK,\r\n"SOF Type", HFILL}},\r\n{ &hf_cpfi_speed,\r\n{ "speed", "cpfi.speed",\r\nFT_UINT32, BASE_HEX, VALS(speed_vals), CPFI_SPEED_MASK,\r\n"SOF Type", HFILL}},\r\n{ &hf_cpfi_OPM_error,\r\n{ "OPMerror", "cpfi.OPMerror",\r\nFT_BOOLEAN, 32, NULL, CPFI_OPM_ERROR_MASK,\r\n"OPM Error?", HFILL}},\r\n{ &hf_cpfi_from_LCM,\r\n{ "fromLCM", "cpfi.fromLCM",\r\nFT_BOOLEAN, 32, NULL, CPFI_FROM_LCM_MASK,\r\n"from LCM?", HFILL}},\r\n{ &hf_cpfi_CRC_32,\r\n{ "CRC-32", "cpfi.crc-32",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}},\r\n{ &hf_cpfi_EOF_type,\r\n{ "EOFtype", "cpfi.EOFtype",\r\nFT_UINT32, BASE_HEX, VALS(eof_type_vals), CPFI_EOF_TYPE_MASK,\r\n"EOF Type", HFILL}},\r\n{ &hf_cpfi_t_instance,\r\n{ "Instance", "cpfi.instance",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_cpfi_t_src_instance,\r\n{ "Source Instance", "cpfi.src_instance",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_cpfi_t_dst_instance,\r\n{ "Destination Instance", "cpfi.dst_instance",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_cpfi_t_board,\r\n{ "Board", "cpfi.board",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_cpfi_t_src_board,\r\n{ "Source Board", "cpfi.src_board",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_cpfi_t_dst_board,\r\n{ "Destination Board", "cpfi.dst_board",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_cpfi_t_port,\r\n{ "Port", "cpfi.port",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_cpfi_t_src_port,\r\n{ "Source Port", "cpfi.src_port",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_cpfi_t_dst_port,\r\n{ "Destination Port", "cpfi.dst_port",\r\nFT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_cpfi,\r\n&ett_cpfi_header,\r\n&ett_cpfi_footer\r\n};\r\nproto_cpfi = proto_register_protocol("Cross Point Frame Injector", "CPFI", "cpfi");\r\nproto_register_field_array(proto_cpfi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\ncpfi_module = prefs_register_protocol(proto_cpfi, proto_reg_handoff_cpfi);\r\nprefs_register_uint_preference(cpfi_module, "udp.port", "CPFI UDP Port",\r\n"Set the port for CPFI messages (if other"\r\n" than the default of 5000)",\r\n10, &gbl_cpfi_udp_port);\r\nprefs_register_uint_preference(cpfi_module, "udp.port2", "InstanceToInstance UDP Port",\r\n"Set the port for InstanceToInstance messages (if other"\r\n" than the default of 5001)",\r\n10, &gbl_cpfi_ttot_udp_port);\r\nprefs_register_bool_preference(cpfi_module, "arrow_ctl",\r\n"Enable Active Arrow Control",\r\n"Control the way the '-->' is displayed."\r\n" When enabled, keeps the 'lowest valued' endpoint of the src-dest pair"\r\n" on the left, and the arrow moves to distinguish source from dest."\r\n" When disabled, keeps the arrow pointing right so the source of the frame"\r\n" is always on the left.",\r\n&cpfi_arrow_moves);\r\n}\r\nvoid\r\nproto_reg_handoff_cpfi(void)\r\n{\r\nstatic gboolean cpfi_init_complete = FALSE;\r\nstatic dissector_handle_t cpfi_handle;\r\nstatic guint cpfi_udp_port;\r\nstatic guint cpfi_ttot_udp_port;\r\nif ( !cpfi_init_complete )\r\n{\r\nfc_handle = find_dissector_add_dependency("fc", proto_cpfi);\r\ncpfi_handle = create_dissector_handle(dissect_cpfi, proto_cpfi);\r\ncpfi_init_complete = TRUE;\r\n}\r\nelse\r\n{\r\ndissector_delete_uint("udp.port", cpfi_udp_port, cpfi_handle);\r\ndissector_delete_uint("udp.port", cpfi_ttot_udp_port, cpfi_handle);\r\n}\r\ncpfi_udp_port = gbl_cpfi_udp_port;\r\ncpfi_ttot_udp_port = gbl_cpfi_ttot_udp_port;\r\ndissector_add_uint("udp.port", cpfi_udp_port, cpfi_handle);\r\ndissector_add_uint("udp.port", cpfi_ttot_udp_port, cpfi_handle);\r\n}
