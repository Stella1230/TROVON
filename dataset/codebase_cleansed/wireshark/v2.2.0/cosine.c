static gboolean empty_line(const gchar *line)\r\n{\r\nwhile (*line) {\r\nif (g_ascii_isspace(*line)) {\r\nline++;\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (*line == '\0')\r\nreturn TRUE;\r\nelse\r\nreturn FALSE;\r\n}\r\nstatic gint64 cosine_seek_next_packet(wtap *wth, int *err, gchar **err_info,\r\nchar *hdr)\r\n{\r\ngint64 cur_off;\r\nchar buf[COSINE_LINE_LENGTH];\r\nwhile (1) {\r\ncur_off = file_tell(wth->fh);\r\nif (cur_off == -1) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nif (file_gets(buf, sizeof(buf), wth->fh) == NULL) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn -1;\r\n}\r\nif (strstr(buf, COSINE_REC_MAGIC_STR1) ||\r\nstrstr(buf, COSINE_REC_MAGIC_STR2)) {\r\ng_strlcpy(hdr, buf, COSINE_LINE_LENGTH);\r\nreturn cur_off;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic gboolean cosine_check_file_type(wtap *wth, int *err, gchar **err_info)\r\n{\r\nchar buf[COSINE_LINE_LENGTH];\r\ngsize reclen;\r\nguint line;\r\nbuf[COSINE_LINE_LENGTH-1] = '\0';\r\nfor (line = 0; line < COSINE_HEADER_LINES_TO_CHECK; line++) {\r\nif (file_gets(buf, COSINE_LINE_LENGTH, wth->fh) == NULL) {\r\n*err = file_error(wth->fh, err_info);\r\nreturn FALSE;\r\n}\r\nreclen = strlen(buf);\r\nif (reclen < strlen(COSINE_HDR_MAGIC_STR1) ||\r\nreclen < strlen(COSINE_HDR_MAGIC_STR2)) {\r\ncontinue;\r\n}\r\nif (strstr(buf, COSINE_HDR_MAGIC_STR1) ||\r\nstrstr(buf, COSINE_HDR_MAGIC_STR2)) {\r\nreturn TRUE;\r\n}\r\n}\r\n*err = 0;\r\nreturn FALSE;\r\n}\r\nwtap_open_return_val cosine_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nif (!cosine_check_file_type(wth, err, err_info)) {\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (file_seek(wth->fh, 0L, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\nwth->file_encap = WTAP_ENCAP_COSINE;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_COSINE;\r\nwth->snapshot_length = 0;\r\nwth->subtype_read = cosine_read;\r\nwth->subtype_seek_read = cosine_seek_read;\r\nwth->file_tsprec = WTAP_TSPREC_CSEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\ngint64 offset;\r\nchar line[COSINE_LINE_LENGTH];\r\noffset = cosine_seek_next_packet(wth, err, err_info, line);\r\nif (offset < 0)\r\nreturn FALSE;\r\n*data_offset = offset;\r\nreturn parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,\r\nline, err, err_info);\r\n}\r\nstatic gboolean\r\ncosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nchar line[COSINE_LINE_LENGTH];\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {\r\n*err = file_error(wth->random_fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nreturn parse_cosine_packet(wth->random_fh, phdr, buf, line, err,\r\nerr_info);\r\n}\r\nstatic gboolean\r\nparse_cosine_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\nchar *line, int *err, gchar **err_info)\r\n{\r\nunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nint num_items_scanned;\r\nint yy, mm, dd, hr, min, sec, csec, pkt_len;\r\nint pro, off, pri, rm, error;\r\nguint code1, code2;\r\nchar if_name[COSINE_MAX_IF_NAME_LEN] = "", direction[6] = "";\r\nstruct tm tm;\r\nguint8 *pd;\r\nint i, hex_lines, n, caplen = 0;\r\nif (sscanf(line, "%4d-%2d-%2d,%2d:%2d:%2d.%9d:",\r\n&yy, &mm, &dd, &hr, &min, &sec, &csec) == 7) {\r\nnum_items_scanned = sscanf(line,\r\n"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]",\r\n&yy, &mm, &dd, &hr, &min, &sec, &csec,\r\ndirection, if_name, &pkt_len,\r\n&pro, &off, &pri, &rm, &error,\r\n&code1, &code2);\r\nif (num_items_scanned != 17) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("cosine: purported control blade line doesn't have code values");\r\nreturn FALSE;\r\n}\r\n} else {\r\nnum_items_scanned = sscanf(line,\r\n"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]",\r\ndirection, if_name, &pkt_len,\r\n&pro, &off, &pri, &rm, &error,\r\n&code1, &code2);\r\nif (num_items_scanned != 10) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("cosine: header line is neither control blade nor PE output");\r\nreturn FALSE;\r\n}\r\nyy = mm = dd = hr = min = sec = csec = 0;\r\n}\r\nif (pkt_len < 0) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("cosine: packet header has a negative packet length");\r\nreturn FALSE;\r\n}\r\nif (pkt_len > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("cosine: File has %u-byte packet, bigger than maximum of %u",\r\npkt_len, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\ntm.tm_year = yy - 1900;\r\ntm.tm_mon = mm - 1;\r\ntm.tm_mday = dd;\r\ntm.tm_hour = hr;\r\ntm.tm_min = min;\r\ntm.tm_sec = sec;\r\ntm.tm_isdst = -1;\r\nphdr->ts.secs = mktime(&tm);\r\nphdr->ts.nsecs = csec * 10000000;\r\nphdr->len = pkt_len;\r\nif (strncmp(if_name, "TEST:", 5) == 0) {\r\npseudo_header->cosine.encap = COSINE_ENCAP_TEST;\r\n} else if (strncmp(if_name, "PPoATM:", 7) == 0) {\r\npseudo_header->cosine.encap = COSINE_ENCAP_PPoATM;\r\n} else if (strncmp(if_name, "PPoFR:", 6) == 0) {\r\npseudo_header->cosine.encap = COSINE_ENCAP_PPoFR;\r\n} else if (strncmp(if_name, "ATM:", 4) == 0) {\r\npseudo_header->cosine.encap = COSINE_ENCAP_ATM;\r\n} else if (strncmp(if_name, "FR:", 3) == 0) {\r\npseudo_header->cosine.encap = COSINE_ENCAP_FR;\r\n} else if (strncmp(if_name, "HDLC:", 5) == 0) {\r\npseudo_header->cosine.encap = COSINE_ENCAP_HDLC;\r\n} else if (strncmp(if_name, "PPP:", 4) == 0) {\r\npseudo_header->cosine.encap = COSINE_ENCAP_PPP;\r\n} else if (strncmp(if_name, "ETH:", 4) == 0) {\r\npseudo_header->cosine.encap = COSINE_ENCAP_ETH;\r\n} else {\r\npseudo_header->cosine.encap = COSINE_ENCAP_UNKNOWN;\r\n}\r\nif (strncmp(direction, "l2-tx", 5) == 0) {\r\npseudo_header->cosine.direction = COSINE_DIR_TX;\r\n} else if (strncmp(direction, "l2-rx", 5) == 0) {\r\npseudo_header->cosine.direction = COSINE_DIR_RX;\r\n}\r\ng_strlcpy(pseudo_header->cosine.if_name, if_name,\r\nCOSINE_MAX_IF_NAME_LEN);\r\npseudo_header->cosine.pro = pro;\r\npseudo_header->cosine.off = off;\r\npseudo_header->cosine.pri = pri;\r\npseudo_header->cosine.rm = rm;\r\npseudo_header->cosine.err = error;\r\nws_buffer_assure_space(buf, pkt_len);\r\npd = ws_buffer_start_ptr(buf);\r\nhex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\r\nfor (i = 0; i < hex_lines; i++) {\r\nif (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {\r\n*err = file_error(fh, err_info);\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nif (empty_line(line)) {\r\nbreak;\r\n}\r\nif ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup("cosine: hex dump line doesn't have 16 numbers");\r\nreturn FALSE;\r\n}\r\ncaplen += n;\r\n}\r\nphdr->caplen = caplen;\r\nreturn TRUE;\r\n}\r\nstatic int\r\nparse_single_hex_dump_line(char* rec, guint8 *buf, guint byte_offset)\r\n{\r\nint num_items_scanned, i;\r\nunsigned int bytes[16];\r\nnum_items_scanned = sscanf(rec, "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",\r\n&bytes[0], &bytes[1], &bytes[2], &bytes[3],\r\n&bytes[4], &bytes[5], &bytes[6], &bytes[7],\r\n&bytes[8], &bytes[9], &bytes[10], &bytes[11],\r\n&bytes[12], &bytes[13], &bytes[14], &bytes[15]);\r\nif (num_items_scanned == 0)\r\nreturn -1;\r\nif (num_items_scanned > 16)\r\nnum_items_scanned = 16;\r\nfor (i=0; i<num_items_scanned; i++) {\r\nbuf[byte_offset + i] = (guint8)bytes[i];\r\n}\r\nreturn num_items_scanned;\r\n}
