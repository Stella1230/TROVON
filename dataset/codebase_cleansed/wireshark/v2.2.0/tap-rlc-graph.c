int compare_rlc_headers(guint16 ueid1, guint16 channelType1, guint16 channelId1, guint8 rlcMode1, guint8 direction1,\r\nguint16 ueid2, guint16 channelType2, guint16 channelId2, guint8 rlcMode2, guint8 direction2,\r\ngboolean frameIsControl)\r\n{\r\nif (!frameIsControl) {\r\nreturn (direction1 == direction2) &&\r\n(ueid1 == ueid2) &&\r\n(channelType1 == channelType2) &&\r\n(channelId1 == channelId2) &&\r\n(rlcMode1 == rlcMode2);\r\n}\r\nelse {\r\nif (frameIsControl && (rlcMode1 == RLC_AM_MODE) && (rlcMode2 == RLC_AM_MODE)) {\r\nreturn ((direction1 != direction2) &&\r\n(ueid1 == ueid2) &&\r\n(channelType1 == channelType2) &&\r\n(channelId1 == channelId2));\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\n}\r\n}\r\nstatic int\r\ntap_lte_rlc_packet(void *pct, packet_info *pinfo _U_, epan_dissect_t *edt _U_, const void *vip)\r\n{\r\nint n;\r\ngboolean is_unique = TRUE;\r\nth_t *th = (th_t *)pct;\r\nconst rlc_lte_tap_info *header = (const rlc_lte_tap_info*)vip;\r\nfor (n=0; n < th->num_hdrs; n++) {\r\nrlc_lte_tap_info *stored = th->rlchdrs[n];\r\nif (compare_rlc_headers(stored->ueid, stored->channelType, stored->channelId, stored->rlcMode, stored->direction,\r\nheader->ueid, header->channelType, header->channelId, header->rlcMode, header->direction,\r\nheader->isControlPDU)) {\r\nis_unique = FALSE;\r\nbreak;\r\n}\r\n}\r\nif (is_unique && (th->num_hdrs < MAX_SUPPORTED_CHANNELS)) {\r\nth->rlchdrs[th->num_hdrs] = g_new(rlc_lte_tap_info,1);\r\n*(th->rlchdrs[th->num_hdrs]) = *header;\r\nif (th->rlchdrs[th->num_hdrs]->isControlPDU) {\r\nth->rlchdrs[th->num_hdrs]->direction = !th->rlchdrs[th->num_hdrs]->direction;\r\n}\r\nth->num_hdrs++;\r\n}\r\nreturn 0;\r\n}\r\nrlc_lte_tap_info *select_rlc_lte_session(capture_file *cf,\r\nstruct rlc_segment *hdrs,\r\ngchar **err_msg)\r\n{\r\nframe_data *fdata;\r\nepan_dissect_t edt;\r\ndfilter_t *sfcode;\r\nGString *error_string;\r\nnstime_t rel_ts;\r\nth_t th = {0, {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}};\r\nif (cf->state == FILE_CLOSED) {\r\nreturn NULL;\r\n}\r\nfdata = cf->current_frame;\r\nif (!dfilter_compile("rlc-lte", &sfcode, err_msg)) {\r\nreturn NULL;\r\n}\r\nif (!cf_read_record(cf, fdata)) {\r\nreturn NULL;\r\n}\r\nerror_string = register_tap_listener("rlc-lte", &th, NULL, 0, NULL, tap_lte_rlc_packet, NULL);\r\nif (error_string){\r\nfprintf(stderr, "wireshark: Couldn't register rlc_lte_graph tap: %s\n",\r\nerror_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\nepan_dissect_init(&edt, cf->epan, TRUE, FALSE);\r\nepan_dissect_prime_dfilter(&edt, sfcode);\r\nepan_dissect_run_with_taps(&edt, cf->cd_t, &cf->phdr, frame_tvbuff_new_buffer(fdata, &cf->buf), fdata, NULL);\r\nrel_ts = edt.pi.rel_ts;\r\nepan_dissect_cleanup(&edt);\r\nremove_tap_listener(&th);\r\nif (th.num_hdrs == 0){\r\n*err_msg = g_strdup("Selected packet doesn't have an RLC PDU");\r\nreturn NULL;\r\n}\r\nif (th.num_hdrs>1){\r\n*err_msg = g_strdup("The selected packet has more than one LTE RLC channel in it.");\r\nreturn NULL;\r\n}\r\nhdrs->num = fdata->num;\r\nhdrs->rel_secs = (guint32) rel_ts.secs;\r\nhdrs->rel_usecs = rel_ts.nsecs/1000;\r\nhdrs->abs_secs = (guint32) fdata->abs_ts.secs;\r\nhdrs->abs_usecs = fdata->abs_ts.nsecs/1000;\r\nhdrs->ueid = th.rlchdrs[0]->ueid;\r\nhdrs->channelType = th.rlchdrs[0]->channelType;\r\nhdrs->channelId = th.rlchdrs[0]->channelId;\r\nhdrs->rlcMode = th.rlchdrs[0]->rlcMode;\r\nhdrs->isControlPDU = th.rlchdrs[0]->isControlPDU;\r\nhdrs->direction = !hdrs->isControlPDU ? th.rlchdrs[0]->direction : !th.rlchdrs[0]->direction;\r\nreturn th.rlchdrs[0];\r\n}\r\nint rlc_lte_tap_for_graph_data(void *pct, packet_info *pinfo, epan_dissect_t *edt _U_, const void *vip)\r\n{\r\nstruct rlc_graph *graph = (struct rlc_graph *)pct;\r\nconst rlc_lte_tap_info *rlchdr = (const rlc_lte_tap_info*)vip;\r\nif (compare_rlc_headers(graph->ueid, graph->channelType, graph->channelId, graph->rlcMode, graph->direction,\r\nrlchdr->ueid, rlchdr->channelType, rlchdr->channelId, rlchdr->rlcMode, rlchdr->direction,\r\nrlchdr->isControlPDU)) {\r\nstruct rlc_segment *segment = (struct rlc_segment *)g_malloc(sizeof(struct rlc_segment));\r\nsegment->next = NULL;\r\nsegment->num = pinfo->num;\r\nsegment->rel_secs = (guint32) pinfo->rel_ts.secs;\r\nsegment->rel_usecs = pinfo->rel_ts.nsecs/1000;\r\nsegment->abs_secs = (guint32) pinfo->abs_ts.secs;\r\nsegment->abs_usecs = pinfo->abs_ts.nsecs/1000;\r\nsegment->ueid = rlchdr->ueid;\r\nsegment->channelType = rlchdr->channelType;\r\nsegment->channelId = rlchdr->channelId;\r\nsegment->direction = rlchdr->direction;\r\nsegment->rlcMode = rlchdr->rlcMode;\r\nsegment->isControlPDU = rlchdr->isControlPDU;\r\nif (!rlchdr->isControlPDU) {\r\nsegment->SN = rlchdr->sequenceNumber;\r\nsegment->isResegmented = rlchdr->isResegmented;\r\nsegment->pduLength = rlchdr->pduLength;\r\n}\r\nelse {\r\ngint n;\r\nsegment->ACKNo = rlchdr->ACKNo;\r\nsegment->noOfNACKs = rlchdr->noOfNACKs;\r\nfor (n=0; n < rlchdr->noOfNACKs; n++) {\r\nsegment->NACKs[n] = rlchdr->NACKs[n];\r\n}\r\n}\r\nif (graph->segments) {\r\ngraph->last_segment->next = segment;\r\n} else {\r\ngraph->segments = segment;\r\n}\r\ngraph->last_segment = segment;\r\n}\r\nreturn 0;\r\n}\r\ngboolean rlc_graph_segment_list_get(capture_file *cf, struct rlc_graph *g, gboolean stream_known,\r\nchar **err_string)\r\n{\r\nstruct rlc_segment current;\r\nGString *error_string;\r\ng_log(NULL, G_LOG_LEVEL_DEBUG, "graph_segment_list_get()");\r\nif (!cf || !g) {\r\nreturn FALSE;\r\n}\r\nif (!stream_known) {\r\nstruct rlc_lte_tap_info *header = select_rlc_lte_session(cf, &current, err_string);\r\nif (!header) {\r\nreturn FALSE;\r\n}\r\ng->channelSet = TRUE;\r\ng->ueid = header->ueid;\r\ng->channelType = header->channelType;\r\ng->channelId = header->channelId;\r\ng->rlcMode = header->rlcMode;\r\ng->direction = header->direction;\r\n}\r\ng->last_segment = NULL;\r\nerror_string = register_tap_listener("rlc-lte", g, "rlc-lte", 0, NULL, rlc_lte_tap_for_graph_data, NULL);\r\nif (error_string) {\r\nfprintf(stderr, "wireshark: Couldn't register rlc_graph tap: %s\n",\r\nerror_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\ncf_retap_packets(cf);\r\nremove_tap_listener(g);\r\nif (g->last_segment == NULL) {\r\n*err_string = g_strdup("No packets found");\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nvoid rlc_graph_segment_list_free(struct rlc_graph * g)\r\n{\r\nstruct rlc_segment *segment;\r\nwhile (g->segments) {\r\nsegment = g->segments->next;\r\ng_free(g->segments);\r\ng->segments = segment;\r\n}\r\ng->segments = NULL;\r\n}
