static guint\r\nget_next_fcip_header_offset (tvbuff_t *tvb, packet_info *pinfo, gint offset)\r\n{\r\ngint bytes_remaining = tvb_reported_length_remaining (tvb, offset);\r\ngint frame_len;\r\nguint16 flen, flen1;\r\nfcip_eof_t eof, eofc;\r\nNXT_BYTE: while (bytes_remaining) {\r\nif (bytes_remaining < FCIP_ENCAP_HEADER_LEN) {\r\nif(fcip_desegment && pinfo->can_desegment) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn -2;\r\n}\r\n}\r\nif (tvb_memeql(tvb, offset, fcip_header_8_bytes, 8) != 0) {\r\noffset++;\r\nbytes_remaining--;\r\ngoto NXT_BYTE;\r\n}\r\nflen = (tvb_get_ntohs (tvb, offset+12)) & 0x03FF;\r\nframe_len = (tvb_get_ntohs (tvb, offset+12) & 0x03FF)*4;\r\nif ((flen < 15) || (flen > 545)) {\r\noffset++;\r\nbytes_remaining--;\r\ngoto NXT_BYTE;\r\n}\r\nflen1 = (tvb_get_ntohs (tvb, offset+14)) & 0x03FF;\r\nif ((flen & 0x03FF) != ((~flen1)&0x03FF)) {\r\noffset++;\r\nbytes_remaining--;\r\ngoto NXT_BYTE;\r\n}\r\nif (tvb_bytes_exist (tvb, offset+(frame_len-1)*4, 4)) {\r\neof = (fcip_eof_t)tvb_get_guint8 (tvb, offset+(frame_len-1)*4);\r\neofc = (fcip_eof_t)tvb_get_guint8 (tvb, offset+(frame_len-1)*4+2);\r\nif ((eof != FCIP_EOFn) && (eof != FCIP_EOFt) && (eof != FCIP_EOFrt)\r\n&& (eof != FCIP_EOFdt) && (eof != FCIP_EOFni) &&\r\n(eof != FCIP_EOFdti) && (eof != FCIP_EOFrti) &&\r\n(eof != FCIP_EOFa)) {\r\noffset++;\r\nbytes_remaining--;\r\ngoto NXT_BYTE;\r\n}\r\nif ((eof != ~eofc) ||\r\n(eof != tvb_get_guint8 (tvb, offset+(frame_len-1)*4+1)) ||\r\n(eofc != tvb_get_guint8 (tvb, offset+(frame_len-1)*4+3))) {\r\noffset++;\r\nbytes_remaining--;\r\ngoto NXT_BYTE;\r\n}\r\n}\r\nif ((tvb_get_guint8 (tvb, offset+9) != 0) ||\r\n(tvb_get_guint8 (tvb, offset+11) != 0xFF)) {\r\noffset++;\r\nbytes_remaining--;\r\ngoto NXT_BYTE;\r\n}\r\nif (bytes_remaining >= (frame_len)) {\r\nif (tvb_bytes_exist (tvb, offset+frame_len, 8)) {\r\nif (tvb_memeql (tvb, offset+frame_len, fcip_header_8_bytes,\r\n8) == 0) {\r\nreturn (offset);\r\n}\r\nelse {\r\noffset++;\r\nbytes_remaining--;\r\ngoto NXT_BYTE;\r\n}\r\n}\r\nelse {\r\nreturn (offset);\r\n}\r\n}\r\nelse {\r\nif(fcip_desegment && pinfo->can_desegment) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = frame_len - bytes_remaining;\r\nreturn -2;\r\n}\r\nelse {\r\nreturn (offset);\r\n}\r\n}\r\n}\r\nreturn (-1);\r\n}\r\nstatic void\r\ndissect_fcencap_header (tvbuff_t *tvb, proto_tree *tree, gint offset)\r\n{\r\nguint8 protocol = tvb_get_guint8 (tvb, offset);\r\nif (tree) {\r\nproto_tree_add_uint (tree, hf_fcip_protocol, tvb, offset, 1, protocol);\r\nproto_tree_add_item (tree, hf_fcip_version, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_protocol_c, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_version_c, tvb, offset+3, 1, ENC_BIG_ENDIAN);\r\nif (protocol == FCENCAP_PROTO_FCIP) {\r\nproto_tree_add_item (tree, hf_fcip_encap_word1, tvb, offset+4,\r\n4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_pflags_changed, tvb, offset+8,\r\n1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_pflags_special, tvb, offset+8,\r\n1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_pflags_c, tvb, offset+10, 1, ENC_BIG_ENDIAN);\r\n}\r\nproto_tree_add_item (tree, hf_fcip_flags, tvb, offset+12, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_framelen, tvb, offset+12, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_flags_c, tvb, offset+14, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_framelen_c, tvb, offset+14, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_tsec, tvb, offset+16, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_tusec, tvb, offset+20, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_encap_crc, tvb, offset+24, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_fcip_sf (tvbuff_t *tvb, proto_tree *tree, gint offset)\r\n{\r\nif (tree) {\r\nproto_tree_add_item (tree, hf_fcip_src_wwn, tvb, offset, 8, ENC_NA);\r\nproto_tree_add_item (tree, hf_fcip_src_entity_id, tvb, offset+8, 8,\r\nENC_NA);\r\nproto_tree_add_item (tree, hf_fcip_conn_nonce, tvb, offset+16, 8,\r\nENC_NA);\r\nproto_tree_add_item (tree, hf_fcip_conn_flags, tvb, offset+24, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_conn_code, tvb, offset+26, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (tree, hf_fcip_dst_wwn, tvb, offset+30, 8, ENC_NA);\r\nproto_tree_add_item (tree, hf_fcip_katov, tvb, offset+38, 4, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic gboolean\r\ndissect_fcip (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngboolean check_port)\r\n{\r\ngint offset = 0,\r\nstart = 0,\r\nframe_len = 0;\r\ngint bytes_remaining = tvb_captured_length (tvb);\r\nguint8 pflags, sof = 0, eof = 0;\r\nproto_item *ti;\r\nproto_tree *fcip_tree = NULL;\r\ntvbuff_t *next_tvb;\r\nfc_data_t fc_data;\r\nif (bytes_remaining < FCIP_ENCAP_HEADER_LEN) {\r\nreturn FALSE;\r\n}\r\nif (check_port &&\r\n((pinfo->srcport != fcip_port) && (pinfo->destport != fcip_port))) {\r\nreturn FALSE;\r\n}\r\nwhile (bytes_remaining > FCIP_ENCAP_HEADER_LEN) {\r\nif ((offset = get_next_fcip_header_offset (tvb, pinfo, offset)) == -1) {\r\nreturn FALSE;\r\n}\r\nelse if (offset == -2) {\r\nreturn (TRUE);\r\n}\r\nstart = offset;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FCIP");\r\nframe_len = (tvb_get_ntohs (tvb, offset+12) & 0x03FF)*4;\r\nif (bytes_remaining < frame_len) {\r\nif(fcip_desegment && pinfo->can_desegment) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = frame_len - bytes_remaining;\r\nreturn (TRUE);\r\n}\r\n}\r\npflags = tvb_get_guint8 (tvb, start+8);\r\nif (tree) {\r\nif (FCIP_IS_SF (pflags)) {\r\nti = proto_tree_add_protocol_format (tree, proto_fcip, tvb, 0,\r\nFCIP_ENCAP_HEADER_LEN,\r\n"FCIP");\r\n}\r\nelse if (tvb_bytes_exist (tvb, offset, offset+frame_len-4)) {\r\nsof = tvb_get_guint8 (tvb, offset+FCIP_ENCAP_HEADER_LEN);\r\neof = tvb_get_guint8 (tvb, offset+frame_len - 4);\r\nti = proto_tree_add_protocol_format (tree, proto_fcip, tvb, 0,\r\nFCIP_ENCAP_HEADER_LEN,\r\n"FCIP (%s/%s)",\r\nval_to_str (sof, fcip_sof_vals,\r\n"0x%x"),\r\nval_to_str (eof, fcip_eof_vals,\r\n"0x%x"));\r\n}\r\nelse {\r\nsof = tvb_get_guint8 (tvb, offset+FCIP_ENCAP_HEADER_LEN);\r\nti = proto_tree_add_protocol_format (tree, proto_fcip, tvb, 0,\r\nFCIP_ENCAP_HEADER_LEN,\r\n"FCIP (%s/%s)",\r\nval_to_str (sof, fcip_sof_vals,\r\n"0x%x"),\r\n"NA");\r\n}\r\nfcip_tree = proto_item_add_subtree (ti, ett_fcip);\r\ndissect_fcencap_header (tvb, fcip_tree, offset);\r\noffset += FCIP_ENCAP_HEADER_LEN;\r\nif (!FCIP_IS_SF (pflags)) {\r\nproto_tree_add_item (fcip_tree, hf_fcip_sof, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (fcip_tree, hf_fcip_sof_c, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\noffset += (frame_len-FCIP_ENCAP_HEADER_LEN-4);\r\nif (tvb_bytes_exist (tvb, offset, 4)) {\r\nproto_tree_add_item (fcip_tree, hf_fcip_eof, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item (fcip_tree, hf_fcip_eof_c, tvb, offset+2, 1, ENC_BIG_ENDIAN);\r\n}\r\n}\r\n}\r\nif (!FCIP_IS_SF(pflags)) {\r\nfc_data.sof_eof = 0;\r\nif (sof) {\r\nif ((sof == FCIP_SOFi3) || (sof == FCIP_SOFi2) || (sof == FCIP_SOFi4)) {\r\nfc_data.sof_eof = FC_DATA_SOF_FIRST_FRAME;\r\n}\r\nelse if (sof == FCIP_SOFf) {\r\nfc_data.sof_eof = FC_DATA_SOF_SOFF;\r\n}\r\nif (eof != FCIP_EOFn) {\r\nfc_data.sof_eof |= FC_DATA_EOF_LAST_FRAME;\r\n}\r\nelse if (eof != FCIP_EOFt) {\r\nfc_data.sof_eof |= FC_DATA_EOF_INVALID;\r\n}\r\n}\r\nnext_tvb = tvb_new_subset_remaining (tvb, FCIP_ENCAP_HEADER_LEN+4);\r\nif (fc_handle) {\r\nfc_data.ethertype = 0;\r\ncall_dissector_with_data(fc_handle, next_tvb, pinfo, tree, &fc_data);\r\n}\r\nelse {\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\n}\r\nelse {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Special Frame");\r\nif (FCIP_IS_CH (pflags)) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, "(Changed)");\r\n}\r\ndissect_fcip_sf (tvb, fcip_tree, offset+4);\r\n}\r\nbytes_remaining -= frame_len;\r\n}\r\nreturn (TRUE);\r\n}\r\nstatic int\r\ndissect_fcip_handle(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_fcip (tvb, pinfo, tree, FALSE);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic gboolean\r\ndissect_fcip_heur (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nreturn (dissect_fcip (tvb, pinfo, tree, TRUE));\r\n}\r\nvoid\r\nproto_register_fcip (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_fcip_protocol,\r\n{ "Protocol", "fcip.proto", FT_UINT8, BASE_DEC,\r\nVALS(fcencap_proto_vals), 0, NULL, HFILL }},\r\n{ &hf_fcip_protocol_c,\r\n{"Protocol (1's Complement)", "fcip.protoc", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_fcip_version,\r\n{"Version", "fcip.version", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_fcip_version_c,\r\n{"Version (1's Complement)", "fcip.versionc", FT_UINT8, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_fcip_encap_word1,\r\n{"FCIP Encapsulation Word1", "fcip.encap_word1", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_fcip_flags,\r\n{"Flags", "fcip.flags", FT_UINT8, BASE_HEX,\r\nNULL, 0xFC, NULL, HFILL}},\r\n{ &hf_fcip_flags_c,\r\n{"Flags (1's Complement)", "fcip.flagsc", FT_UINT8, BASE_HEX,\r\nNULL, 0xFC, NULL, HFILL}},\r\n{ &hf_fcip_framelen,\r\n{"Frame Length (in Words)", "fcip.framelen", FT_UINT16, BASE_DEC,\r\nNULL, 0x03FF, NULL, HFILL}},\r\n{ &hf_fcip_framelen_c,\r\n{"Frame Length (1's Complement)", "fcip.framelenc", FT_UINT16, BASE_DEC,\r\nNULL, 0x03FF, NULL, HFILL}},\r\n{ &hf_fcip_tsec,\r\n{"Time (secs)", "fcip.tsec", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_fcip_tusec,\r\n{"Time (fraction)", "fcip.tusec", FT_UINT32, BASE_DEC,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_fcip_encap_crc,\r\n{"CRC", "fcip.encap_crc", FT_UINT32, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_fcip_sof,\r\n{"SOF", "fcip.sof", FT_UINT8, BASE_HEX,\r\nVALS (fcip_sof_vals), 0, NULL, HFILL}},\r\n{ &hf_fcip_sof_c,\r\n{"SOF (1's Complement)", "fcip.sofc", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_fcip_eof,\r\n{"EOF", "fcip.eof", FT_UINT8, BASE_HEX,\r\nVALS (fcip_eof_vals), 0, NULL, HFILL}},\r\n{ &hf_fcip_eof_c,\r\n{"EOF (1's Complement)", "fcip.eofc", FT_UINT8, BASE_HEX,\r\nNULL, 0, NULL, HFILL}},\r\n{ &hf_fcip_pflags_changed,\r\n{"Changed Flag", "fcip.pflags.ch", FT_BOOLEAN, 8,\r\nNULL, 0x80, NULL, HFILL}},\r\n{ &hf_fcip_pflags_special,\r\n{"Special Frame Flag", "fcip.pflags.sf", FT_BOOLEAN, 8,\r\nNULL, 0x1, NULL, HFILL}},\r\n{ &hf_fcip_pflags_c,\r\n{"Pflags (1's Complement)", "fcip.pflagsc", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_fcip_src_wwn,\r\n{"Source Fabric WWN", "fcip.srcwwn", FT_FCWWN, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_fcip_dst_wwn,\r\n{"Destination Fabric WWN", "fcip.dstwwn", FT_FCWWN, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_fcip_src_entity_id,\r\n{"FC/FCIP Entity Id", "fcip.srcid", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_fcip_conn_flags,\r\n{"Connection Usage Flags", "fcip.connflags", FT_UINT8, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_fcip_conn_code,\r\n{"Connection Usage Code", "fcip.conncode", FT_UINT16, BASE_HEX,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_fcip_katov,\r\n{"K_A_TOV", "fcip.katov", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, NULL, HFILL}},\r\n{ &hf_fcip_conn_nonce,\r\n{"Connection Nonce", "fcip.nonce", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, NULL, HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_fcip,\r\n};\r\nmodule_t *fcip_module;\r\nproto_fcip = proto_register_protocol("FCIP", "Fibre Channel over IP", "fcip");\r\nproto_register_field_array(proto_fcip, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nfcip_module = prefs_register_protocol(proto_fcip, NULL);\r\nprefs_register_bool_preference(fcip_module,\r\n"desegment",\r\n"Reassemble FCIP messages spanning multiple TCP segments",\r\n"Whether the FCIP dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable"\r\n" \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&fcip_desegment);\r\nprefs_register_uint_preference(fcip_module,\r\n"target_port",\r\n"Target port",\r\n"Port number used for FCIP",\r\n10,\r\n&fcip_port);\r\n}\r\nvoid\r\nproto_reg_handoff_fcip (void)\r\n{\r\ndissector_handle_t fcip_handle;\r\nheur_dissector_add("tcp", dissect_fcip_heur, "FCIP over TCP", "fcip_tcp", proto_fcip, HEURISTIC_ENABLE);\r\nfcip_handle = create_dissector_handle(dissect_fcip_handle, proto_fcip);\r\ndissector_add_for_decode_as("tcp.port", fcip_handle);\r\nfc_handle = find_dissector_add_dependency("fc", proto_fcip);\r\n}
