wtap_open_return_val packetlogger_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\ngboolean little_endian = FALSE;\r\npacketlogger_header_t pl_hdr;\r\nguint8 type;\r\npacketlogger_t *packetlogger;\r\nif(!packetlogger_read_header(&pl_hdr, wth->fh, little_endian,\r\nerr, err_info)) {\r\nif (*err != 0 && *err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!wtap_read_bytes(wth->fh, &type, 1, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif ((pl_hdr.len & 0x0000FFFF) == 0 &&\r\n(pl_hdr.len & 0xFFFF0000) != 0) {\r\npl_hdr.len = ((pl_hdr.len >> 24) & 0xFF) |\r\n(((pl_hdr.len >> 16) & 0xFF) << 8);\r\nlittle_endian = TRUE;\r\n}\r\nif (!((8 <= pl_hdr.len) && (pl_hdr.len < 65536) &&\r\n(type < 0x04 || type == 0xFB || type == 0xFC || type == 0xFE || type == 0xFF)))\r\nreturn WTAP_OPEN_NOT_MINE;\r\nif (file_seek(wth->fh, 0, SEEK_SET, err) == -1)\r\nreturn WTAP_OPEN_ERROR;\r\npacketlogger = (packetlogger_t *)g_malloc(sizeof(packetlogger_t));\r\npacketlogger->little_endian = little_endian;\r\nwth->priv = (void *)packetlogger;\r\nwth->subtype_read = packetlogger_read;\r\nwth->subtype_seek_read = packetlogger_seek_read;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_PACKETLOGGER;\r\nwth->file_encap = WTAP_ENCAP_PACKETLOGGER;\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean\r\npacketlogger_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nreturn packetlogger_read_packet(wth, wth->fh, &wth->phdr,\r\nwth->frame_buffer, err, err_info);\r\n}\r\nstatic gboolean\r\npacketlogger_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nif(file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif(!packetlogger_read_packet(wth, wth->random_fh, phdr, buf, err, err_info)) {\r\nif(*err == 0)\r\n*err = WTAP_ERR_SHORT_READ;\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\npacketlogger_read_header(packetlogger_header_t *pl_hdr, FILE_T fh,\r\ngboolean little_endian, int *err, gchar **err_info)\r\n{\r\nif (!wtap_read_bytes_or_eof(fh, &pl_hdr->len, 4, err, err_info))\r\nreturn FALSE;\r\nif (!wtap_read_bytes(fh, &pl_hdr->ts_secs, 4, err, err_info))\r\nreturn FALSE;\r\nif (!wtap_read_bytes(fh, &pl_hdr->ts_usecs, 4, err, err_info))\r\nreturn FALSE;\r\nif (little_endian) {\r\npl_hdr->len = GUINT32_FROM_LE(pl_hdr->len);\r\npl_hdr->ts_secs = GUINT32_FROM_LE(pl_hdr->ts_secs);\r\npl_hdr->ts_usecs = GUINT32_FROM_LE(pl_hdr->ts_usecs);\r\n} else {\r\npl_hdr->len = GUINT32_FROM_BE(pl_hdr->len);\r\npl_hdr->ts_secs = GUINT32_FROM_BE(pl_hdr->ts_secs);\r\npl_hdr->ts_usecs = GUINT32_FROM_BE(pl_hdr->ts_usecs);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\npacketlogger_read_packet(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\npacketlogger_t *packetlogger = (packetlogger_t *)wth->priv;\r\npacketlogger_header_t pl_hdr;\r\nif(!packetlogger_read_header(&pl_hdr, fh, packetlogger->little_endian,\r\nerr, err_info))\r\nreturn FALSE;\r\nif (pl_hdr.len < 8) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("packetlogger: record length %u is too small", pl_hdr.len);\r\nreturn FALSE;\r\n}\r\nif (pl_hdr.len - 8 > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("packetlogger: File has %u-byte packet, bigger than maximum of %u",\r\npl_hdr.len - 8, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS;\r\nphdr->len = pl_hdr.len - 8;\r\nphdr->caplen = pl_hdr.len - 8;\r\nphdr->ts.secs = (time_t)pl_hdr.ts_secs;\r\nphdr->ts.nsecs = (int)(pl_hdr.ts_usecs * 1000);\r\nreturn wtap_read_packet_bytes(fh, buf, phdr->caplen, err, err_info);\r\n}
