static guint\r\nget_ipdc_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset, void *data _U_)\r\n{\r\nguint raw_len = (tvb_get_ntohs(tvb,offset+2) & 0x03FF);\r\nreturn raw_len + 4;\r\n}\r\nstatic int\r\ndissect_ipdc_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *ipdc_tree;\r\nproto_tree *tag_tree, *line_tree;\r\ntvbuff_t *q931_tvb;\r\nconst char *des;\r\nconst char *enum_val = "";\r\nchar tmp_tag_text[IPDC_STR_LEN + 1];\r\nconst value_string *val_ptr;\r\ngint hf_ptr;\r\nguint32 type;\r\nguint len;\r\nguint i;\r\nguint status;\r\ngshort tag;\r\nguint32 tmp_tag;\r\ngshort nr = tvb_get_guint8(tvb,0);\r\ngshort ns = tvb_get_guint8(tvb,1);\r\nguint payload_len = get_ipdc_pdu_len(pinfo,tvb,0,NULL);\r\ngshort trans_id_size;\r\nguint32 trans_id;\r\nguint16 message_code;\r\nguint16 offset;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IPDC");\r\nif (payload_len < 4)\r\nreturn 0;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "r=%u s=%u ", nr, ns);\r\nif (payload_len == 4) {\r\nti = proto_tree_add_item(tree, proto_ipdc, tvb, 0, -1, ENC_NA);\r\nipdc_tree = proto_item_add_subtree(ti, ett_ipdc);\r\nproto_tree_add_item(ipdc_tree, hf_ipdc_nr, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ipdc_tree, hf_ipdc_ns, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(ipdc_tree, hf_ipdc_payload_len, tvb, 2, 2,\r\npayload_len);\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nreturn 4;\r\n}\r\ntrans_id_size = TRANS_ID_SIZE_IPDC;\r\ntrans_id = tvb_get_ntohl(tvb,6);\r\nmessage_code = tvb_get_ntohs(tvb,6+trans_id_size);\r\noffset = 6 + trans_id_size + 2;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO,\r\n"TID=%x %s ",\r\ntrans_id,\r\nval_to_str_const(message_code, message_code_vals,\r\nTEXT_UNDEFINED));\r\nti = proto_tree_add_item(tree, proto_ipdc, tvb, 0, -1, ENC_NA);\r\nipdc_tree = proto_item_add_subtree(ti, ett_ipdc);\r\nproto_tree_add_item(ipdc_tree, hf_ipdc_nr, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ipdc_tree, hf_ipdc_ns, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(ipdc_tree, hf_ipdc_payload_len, tvb,\r\n2, 2, payload_len);\r\nproto_tree_add_item(ipdc_tree, hf_ipdc_protocol_id, tvb,\r\n4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ipdc_tree, hf_ipdc_trans_id_size, tvb,\r\n5, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(ipdc_tree, hf_ipdc_trans_id, tvb,\r\n6, trans_id_size, ENC_NA);\r\nproto_tree_add_item(ipdc_tree, hf_ipdc_message_code, tvb,\r\n6 + trans_id_size, 2, ENC_BIG_ENDIAN);\r\ntag_tree = proto_tree_add_subtree(ipdc_tree, tvb, offset, payload_len - offset,\r\nett_ipdc_tag, NULL, "IPDC tags");\r\nfor (;;) {\r\ntag = tvb_get_guint8(tvb, offset);\r\nif (tag == 0x0) {\r\nif (offset == payload_len - 1) {\r\nproto_tree_add_item(tag_tree, hf_ipdc_end_of_tags, tvb, offset, 1, ENC_NA);\r\n} else {\r\nproto_tree_add_item(tag_tree, hf_ipdc_data_trailing_end_of_tags, tvb, offset, 1, ENC_NA);\r\n}\r\nbreak;\r\n}\r\nlen = tvb_get_guint8(tvb,offset+1);\r\ndes = val_to_str_ext_const(tag, &tag_description_ext, TEXT_UNDEFINED);\r\nfor (i = 0; (ipdc_tag_types[i].tag != tag &&\r\nipdc_tag_types[i].type != IPDC_UNKNOWN); i++)\r\n;\r\ntype = ipdc_tag_types[i].type;\r\ntmp_tag = 0;\r\nswitch (type) {\r\ncase IPDC_ASCII:\r\nDISSECTOR_ASSERT(len<=IPDC_STR_LEN);\r\ntvb_memcpy(tvb, tmp_tag_text, offset+2, len);\r\ntmp_tag_text[len] = 0;\r\nproto_tree_add_string_format(tag_tree, hf_ipdc_ascii, tvb, offset,\r\nlen + 2, tmp_tag_text, "%s (0x%2.2x): %s", des, tag,\r\ntmp_tag_text);\r\nbreak;\r\ncase IPDC_UINT:\r\ncase IPDC_BYTE:\r\nfor (i = 0; i < len; i++)\r\ntmp_tag += tvb_get_guint8(tvb,\r\noffset + 2 + i) * (guint32)pow(256, len - (i + 1));\r\nif (len == 1)\r\nenum_val =\r\nval_to_str_ext_const(IPDC_TAG(tag) + tmp_tag,\r\n&tag_enum_type_ext, TEXT_UNDEFINED);\r\nif (len == 1 && strcmp(enum_val, TEXT_UNDEFINED) != 0) {\r\nproto_tree_add_uint_format(tag_tree, hf_ipdc_uint, tvb,\r\noffset, len + 2, tmp_tag,\r\n"%s (0x%2.2x): %s",\r\ndes, tag, enum_val);\r\n} else {\r\nproto_tree_add_uint_format(tag_tree, hf_ipdc_uint, tvb,\r\noffset, len + 2, tmp_tag,\r\n"%s (0x%2.2x): %u",\r\ndes, tag, tmp_tag);\r\n}\r\nbreak;\r\ncase IPDC_IPA:\r\nswitch (len) {\r\ncase 4:\r\nproto_tree_add_ipv4_format(tag_tree, hf_ipdc_ipv4, tvb,\r\noffset, len + 2, tvb_get_ntohl(tvb, offset + 2),\r\n"%s (0x%2.2x): %s",\r\ndes, tag, tvb_ip_to_str(tvb, offset + 2));\r\nbreak;\r\ncase 6:\r\nproto_tree_add_ipv4_format(tag_tree, hf_ipdc_ipv4, tvb,\r\noffset, len + 2, tvb_get_ntohl(tvb, offset + 2),\r\n"%s (0x%2.2x): %s:%u",\r\ndes, tag, tvb_ip_to_str(tvb, offset + 2), tvb_get_ntohs(tvb, offset + 6));\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert_format(tag_tree, pinfo, &ei_ipdc_ipv4, tvb, offset, len + 2, "%s (0x%2.2x): Invalid IP address length %u",\r\ndes, tag, len);\r\n}\r\nbreak;\r\ncase IPDC_LINESTATUS:\r\ncase IPDC_CHANNELSTATUS:\r\nline_tree = proto_tree_add_subtree_format(tag_tree, tvb, offset, len + 2, ett_ipdc_line_status, NULL, "%s (0x%2.2x)", des, tag);\r\nval_ptr = (type == IPDC_LINESTATUS) ? line_status_vals : channel_status_vals;\r\nhf_ptr = (type == IPDC_LINESTATUS) ? hf_ipdc_line_status : hf_ipdc_channel_status;\r\nfor (i = 0; i < len; i++) {\r\nstatus = tvb_get_guint8(tvb,offset+2+i);\r\nproto_tree_add_uint_format(line_tree, hf_ptr, tvb,\r\noffset + 2 + i, 1, status,\r\n"%s (0x%2.2x) %.2u: %u (%s)",\r\ndes, tag, i + 1, status,\r\nval_to_str_const(status,\r\nval_ptr,\r\nTEXT_UNDEFINED));\r\n}\r\nbreak;\r\ncase IPDC_Q931:\r\nq931_tvb =\r\ntvb_new_subset_length(tvb, offset+2, len);\r\ncall_dissector(q931_handle,q931_tvb,pinfo,tree);\r\nbreak;\r\ncase IPDC_ENCTYPE:\r\nproto_tree_add_uint_format(tag_tree, hf_ipdc_enctype, tvb,\r\noffset, len + 2, tvb_get_guint8(tvb,offset+2),\r\n"%s (0x%2.2x): %s",\r\ndes, tag, val_to_str_const(\r\ntvb_get_guint8(tvb,offset+2),\r\nencoding_type_vals,\r\nTEXT_UNDEFINED));\r\nif (len == 2) {\r\nproto_tree_add_uint_format(tag_tree, hf_ipdc_enctype, tvb,\r\noffset, len + 2, tvb_get_guint8(tvb,offset+3),\r\n"%s (0x%2.2x): %u",\r\ndes, tag, tvb_get_guint8(tvb,offset+3));\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_bytes_format(tag_tree, hf_ipdc_type_unknown, tvb, offset, len + 2, NULL, "0x%2.2x: %s", tag, des);\r\n}\r\noffset += len + 2;\r\n}\r\ncol_set_fence(pinfo->cinfo, COL_INFO);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_ipdc_tcp_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nreturn dissect_ipdc_common(tvb, pinfo, tree, data);\r\n}\r\nstatic int\r\ndissect_ipdc_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree, ipdc_desegment, 4,\r\nget_ipdc_pdu_len, dissect_ipdc_tcp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ipdc(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipdc_nr,\r\n{ "N(r)", "ipdc.nr",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Receive sequence number", HFILL }\r\n},\r\n{ &hf_ipdc_ns,\r\n{ "N(s)", "ipdc.ns",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Transmit sequence number", HFILL }\r\n},\r\n{ &hf_ipdc_payload_len,\r\n{ "Payload length", "ipdc.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_protocol_id,\r\n{ "Protocol ID", "ipdc.protocol_id",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_trans_id_size,\r\n{ "Transaction ID size", "ipdc.trans_id_size",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_trans_id,\r\n{ "Transaction ID", "ipdc.trans_id",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_message_code,\r\n{ "Message code", "ipdc.message_code",\r\nFT_UINT16, BASE_HEX, VALS(message_code_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_ascii,\r\n{ "ASCII value", "ipdc.ascii",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_uint,\r\n{ "Byte/UINT value", "ipdc.uint",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_ipv4,\r\n{ "IPv4 value", "ipdc.ipv4",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_line_status,\r\n{ "Line Status value", "ipdc.line_status",\r\nFT_UINT8, BASE_DEC, VALS(line_status_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_channel_status,\r\n{ "Channel Status value", "ipdc.channel_status",\r\nFT_UINT8, BASE_DEC, VALS(channel_status_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_enctype,\r\n{ "Enctype value", "ipdc.enctype",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_end_of_tags,\r\n{ "end of tags", "ipdc.end_of_tags",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_data_trailing_end_of_tags,\r\n{ "data trailing end of tags", "ipdc.data_trailing_end_of_tags",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ipdc_type_unknown,\r\n{ "Unknown type", "ipdc.type_unknown",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipdc,\r\n&ett_ipdc_tag,\r\n&ett_ipdc_line_status,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ipdc_ipv4, { "ipdc.ipv4.invalid_length", PI_PROTOCOL, PI_WARN, "Invalid IP address length", EXPFILL }},\r\n};\r\nmodule_t *ipdc_module;\r\nexpert_module_t* expert_ipdc;\r\nproto_ipdc = proto_register_protocol("IP Device Control (SS7 over IP)",\r\n"IPDC", "ipdc");\r\nproto_register_field_array(proto_ipdc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ipdc = expert_register_protocol(proto_ipdc);\r\nexpert_register_field_array(expert_ipdc, ei, array_length(ei));\r\nipdc_module = prefs_register_protocol(proto_ipdc, proto_reg_handoff_ipdc);\r\nprefs_register_bool_preference(ipdc_module, "desegment_ipdc_messages",\r\n"Reassemble IPDC messages spanning multiple TCP segments",\r\n"Whether the IPDC dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&ipdc_desegment);\r\nprefs_register_uint_preference(ipdc_module, "tcp.port",\r\n"IPDC monitoring port",\r\n"Set the IPDC monitoring port", 10,\r\n&ipdc_port_pref);\r\n}\r\nvoid\r\nproto_reg_handoff_ipdc(void)\r\n{\r\nstatic guint last_ipdc_port_pref = 0;\r\nstatic dissector_handle_t ipdc_tcp_handle = NULL;\r\nif (ipdc_tcp_handle) {\r\ndissector_delete_uint("tcp.port", last_ipdc_port_pref,\r\nipdc_tcp_handle);\r\n} else {\r\nipdc_tcp_handle =\r\ncreate_dissector_handle(dissect_ipdc_tcp, proto_ipdc);\r\nq931_handle = find_dissector_add_dependency("q931", proto_ipdc);\r\n}\r\nlast_ipdc_port_pref = ipdc_port_pref;\r\ndissector_add_uint("tcp.port", ipdc_port_pref, ipdc_tcp_handle);\r\n}
