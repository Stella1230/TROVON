guint32 get_aircraft_24_bit_address_from_nsap(\r\npacket_info *pinfo)\r\n{\r\nconst guint8* addr = NULL;\r\nguint32 ars =0;\r\nguint32 adr_prefix =0;\r\nif( (pinfo->src.type != get_osi_address_type()) ||\r\n(pinfo->dst.type != get_osi_address_type())) {\r\nreturn ars; }\r\nif( (pinfo->src.len != 20) ||\r\n(pinfo->dst.len != 20)) {\r\nreturn ars; }\r\naddr = (const guint8 *)pinfo->src.data;\r\nadr_prefix =\r\n((addr[0]<<24) |\r\n(addr[1]<<16) |\r\n(addr[2]<<8) |\r\naddr[3] );\r\nif((adr_prefix == 0x470027c1) ||\r\n(adr_prefix == 0x47002741)) {\r\nars = ((addr[8])<<16) |\r\n((addr[9])<<8) |\r\n(addr[10]);\r\n}\r\naddr = (const guint8 *)pinfo->dst.data;\r\nadr_prefix = ((addr[0]<<24) |\r\n(addr[1]<<16) |\r\n(addr[2]<<8) |\r\naddr[3] );\r\nif((adr_prefix == 0x470027c1) ||\r\n(adr_prefix == 0x47002741)) {\r\nars = ((addr[8])<<16) |\r\n((addr[9])<<8) |\r\n(addr[10]);\r\n}\r\nreturn ars;\r\n}\r\nint check_heur_msg_type(packet_info *pinfo _U_)\r\n{\r\nint t = no_msg;\r\nconst guint8* addr = NULL;\r\nguint32 adr_prefix =0;\r\nif( (pinfo->src.type != get_osi_address_type()) || (pinfo->dst.type != get_osi_address_type())) {\r\nreturn t; }\r\nif( (pinfo->src.len != 20) || (pinfo->dst.len != 20)) {\r\nreturn t; }\r\naddr = (const guint8 *)pinfo->src.data;\r\nadr_prefix = ((addr[0]<<24) | (addr[1]<<16) | (addr[2]<<8) | addr[3] );\r\nif((adr_prefix == 0x470027c1) || (adr_prefix == 0x47002741)) {\r\nt = dm;\r\n}\r\naddr = (const guint8 *)pinfo->dst.data;\r\nadr_prefix = ((addr[0]<<24) | (addr[1]<<16) | (addr[2]<<8) | addr[3] );\r\nif((adr_prefix == 0x470027c1) || (adr_prefix == 0x47002741)) {\r\nt = um;\r\n}\r\nreturn t;\r\n}\r\nwmem_tree_t *get_atn_conversation_tree(void){\r\nreturn atn_conversation_tree;\r\n}\r\natn_conversation_t * find_atn_conversation(\r\naddress *address1,\r\nguint16 clnp_ref1,\r\naddress *address2 )\r\n{\r\natn_conversation_t *cv = NULL;\r\nguint32 key = 0;\r\nguint32 tmp = 0;\r\ntmp = add_address_to_hash( tmp, address1);\r\nkey = (tmp << 16) | clnp_ref1 ;\r\ntmp = add_address_to_hash( tmp, address2);\r\nkey = (tmp << 24) | key ;\r\ncv = (atn_conversation_t *)\r\nwmem_tree_lookup32(get_atn_conversation_tree(),key);\r\nreturn cv;\r\n}\r\natn_conversation_t * create_atn_conversation(\r\naddress *address1,\r\nguint16 clnp_ref1,\r\naddress *address2,\r\natn_conversation_t *conversation)\r\n{\r\natn_conversation_t *cv = NULL;\r\nguint32 key = 0;\r\nguint32 tmp = 0;\r\ntmp = add_address_to_hash( tmp, address1);\r\nkey = (tmp << 16) | clnp_ref1 ;\r\ntmp = add_address_to_hash( tmp, address2);\r\nkey = (tmp << 24) | key ;\r\ncv = (atn_conversation_t *)\r\nwmem_tree_lookup32(\r\nget_atn_conversation_tree(),\r\nkey);\r\nif(cv) {\r\nreturn NULL; }\r\nwmem_tree_insert32(\r\nget_atn_conversation_tree(),\r\nkey,\r\n(void*)conversation);\r\nreturn conversation;\r\n}\r\nstatic int\r\ndissect_atn_ulcs(\r\ntvbuff_t *tvb,\r\npacket_info *pinfo,\r\nproto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nint offset = 0;\r\nproto_item *ti = NULL;\r\nproto_tree *atn_ulcs_tree = NULL;\r\nguint8 value_pres = 0;\r\nguint8 value_ses = 0;\r\nguint16 value_ses_pres = 0;\r\nroot_tree = tree;\r\nif ( (int)(intptr_t) data == FALSE )\r\n{\r\nti = proto_tree_add_item(\r\ntree,\r\nproto_atn_ulcs,\r\ntvb,\r\n0,\r\n0 ,\r\nENC_NA);\r\natn_ulcs_tree = proto_item_add_subtree(\r\nti,\r\nett_atn_ulcs);\r\ndissect_Fully_encoded_data_PDU(\r\ntvb,\r\npinfo,\r\natn_ulcs_tree, NULL);\r\nreturn offset +\r\ntvb_reported_length_remaining(tvb, offset ) ;\r\n}\r\nif ( (int)(intptr_t) data == TRUE )\r\n{\r\nvalue_ses_pres = tvb_get_ntohs(tvb, offset);\r\natn_ulcs_tree = proto_tree_add_subtree(\r\ntree, tvb, offset, 0,\r\nett_atn_ses, NULL, ATN_SES_PROTO );\r\nvalue_ses = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(atn_ulcs_tree,\r\nhf_atn_ses_type,\r\ntvb,\r\noffset,\r\n1,\r\nENC_BIG_ENDIAN );\r\nswitch(value_ses & SES_PDU_TYPE_MASK){\r\ncase SES_ATN_SRF:\r\ncase SES_ATN_SRFC:\r\nproto_tree_add_item(atn_ulcs_tree,\r\nhf_atn_ses_param_ind,\r\ntvb,\r\noffset,\r\n1,\r\nENC_BIG_ENDIAN );\r\nproto_tree_add_item(atn_ulcs_tree,\r\nhf_atn_ses_param_b2,\r\ntvb,\r\noffset,\r\n1,\r\nENC_BIG_ENDIAN );\r\nproto_tree_add_item(atn_ulcs_tree,\r\nhf_atn_ses_param_b1,\r\ntvb,\r\noffset,\r\n1,\r\nENC_BIG_ENDIAN );\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\noffset++;\r\natn_ulcs_tree = proto_tree_add_subtree(\r\ntree, tvb, offset, 0,\r\nett_atn_pres, NULL, ATN_PRES_PROTO );\r\nvalue_pres = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint_format(atn_ulcs_tree, hf_atn_pres_pdu_type,\r\ntvb,\r\noffset,\r\n1,\r\nvalue_ses_pres,\r\n"%s (0x%02x)",\r\nval_to_str( value_ses_pres & ATN_SES_PRES_MASK , atn_pres_vals, "?"),\r\nvalue_pres);\r\nswitch(value_ses & SES_PDU_TYPE_MASK){\r\ncase SES_ATN_SRF:\r\ncase SES_ATN_SRFC:\r\nproto_tree_add_item(\r\natn_ulcs_tree,\r\nhf_atn_pres_err,\r\ntvb,\r\noffset,\r\n1,\r\nENC_BIG_ENDIAN );\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\noffset++;\r\natn_ulcs_tree = proto_tree_add_subtree(\r\ntree, tvb, offset, 0,\r\nett_atn_acse, NULL, ATN_ACSE_PROTO );\r\ndissect_ACSE_apdu_PDU(\r\ntvb_new_subset_remaining(tvb, offset),\r\npinfo,\r\natn_ulcs_tree, NULL);\r\nreturn offset +\r\ntvb_reported_length_remaining(tvb, offset );\r\n}\r\nreturn offset;\r\n}\r\nstatic gboolean dissect_atn_ulcs_heur(\r\ntvbuff_t *tvb,\r\npacket_info *pinfo,\r\nproto_tree *tree,\r\nvoid *data _U_)\r\n{\r\nif (tvb_captured_length(tvb) < 2){\r\nreturn FALSE; }\r\nswitch( tvb_get_ntohs(tvb, 0) & 0xf8ff ){\r\ncase 0xe802:\r\ncase 0xf802:\r\ncase 0xf002:\r\ncase 0xd802:\r\ncase 0xe002:\r\ncase 0xe012:\r\ncase 0xe022:\r\ncase 0xe032:\r\ncase 0xe042:\r\ncase 0xe052:\r\ncase 0xe062:\r\ncase 0xe072:\r\ncase 0xa002:\r\ncase 0xa012:\r\ncase 0xa022:\r\ncase 0xa032:\r\ncase 0xa042:\r\ncase 0xa052:\r\ncase 0xa062:\r\ncase 0xa072:\r\ndissect_atn_ulcs(\r\ntvb,\r\npinfo,\r\ntree,\r\n(void*) TRUE);\r\nreturn TRUE;\r\ndefault:\r\nbreak;\r\n}\r\nswitch( tvb_get_ntohs(tvb, 0) & 0xfff0 ){\r\ncase 0x0020:\r\ncase 0x00a0:\r\ndissect_atn_ulcs(tvb, pinfo, tree, (void*) FALSE);\r\nreturn TRUE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn FALSE;\r\n}\r\nvoid proto_register_atn_ulcs (void)\r\n{\r\nstatic hf_register_info hf_atn_ulcs[] = {\r\n#include "packet-atn-ulcs-hfarr.c"\r\n{&hf_atn_ses_type,\r\n{ "SPDU Type",\r\n"atn-ulcs.ses.type",\r\nFT_UINT8,\r\nBASE_HEX,\r\nVALS(atn_ses_type),\r\n0xf8,\r\n"Indicates presence of session parameters",\r\nHFILL}},\r\n{&hf_atn_ses_param_ind,\r\n{ "SPDU Parameter Indication",\r\n"atn-ulcs.ses.parameter-indication",\r\nFT_UINT8,\r\nBASE_HEX,\r\nVALS(atn_ses_param_ind),\r\nSES_PARAM_IND_MASK,\r\n"Indicates presence of session parameters",\r\nHFILL}},\r\n{&hf_atn_ses_param_b1,\r\n{ "SRF Parameter B1",\r\n"atn-ulcs.ses.srf-b1",\r\nFT_UINT8,\r\nBASE_HEX,\r\nVALS(srf_b1),\r\n0x01,\r\n"Determines if transport connection reject is transient or persistent",\r\nHFILL}},\r\n{&hf_atn_ses_param_b2,\r\n{ "SRF Parameter B2",\r\n"atn-ulcs.ses.srf-b2",\r\nFT_UINT8,\r\nBASE_HEX,\r\nVALS(srf_b2),\r\n0x02,\r\n"Determines if transport connection is retained or released",\r\nHFILL}},\r\n{ &hf_atn_pres_err,\r\n{ "Error Code", "atn-ulcs.pres.cpr-error",\r\nFT_UINT8,\r\nBASE_HEX,\r\nVALS(atn_pres_err),\r\nPRES_CPR_ER_MASK,\r\nNULL,\r\nHFILL}},\r\n{ &hf_atn_pres_pdu_type,\r\n{ "PDU type", "atn-ulcs.pres.pdu_type",\r\nFT_UINT8,\r\nBASE_HEX,\r\nNULL,\r\nATN_SES_PRES_MASK,\r\nNULL,\r\nHFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n#include "packet-atn-ulcs-ettarr.c"\r\n&ett_atn_ses,\r\n&ett_atn_pres,\r\n&ett_atn_acse,\r\n&ett_atn_ulcs\r\n};\r\nproto_atn_ulcs = proto_register_protocol (\r\nATN_ULCS_PROTO ,\r\n"ATN-ULCS",\r\n"atn-ulcs");\r\nproto_register_field_array (\r\nproto_atn_ulcs,\r\nhf_atn_ulcs,\r\narray_length(hf_atn_ulcs));\r\nproto_register_subtree_array (\r\nett,\r\narray_length (ett));\r\nregister_dissector(\r\n"atn-ulcs",\r\ndissect_atn_ulcs,\r\nproto_atn_ulcs);\r\natn_ulcs_heur_subdissector_list = register_heur_dissector_list("atn-ulcs", proto_atn_ulcs);\r\naarq_data_tree = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\natn_conversation_tree = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n}\r\nvoid proto_reg_handoff_atn_ulcs(void)\r\n{\r\natn_cm_handle = find_dissector_add_dependency("atn-cm", proto_atn_ulcs);\r\natn_cpdlc_handle = find_dissector_add_dependency("atn-cpdlc", proto_atn_ulcs);\r\nheur_dissector_add(\r\n"cotp",\r\ndissect_atn_ulcs_heur,\r\n"ATN-ULCS over COTP",\r\n"atn-ucls_cotp",\r\nproto_atn_ulcs, HEURISTIC_ENABLE);\r\n}
