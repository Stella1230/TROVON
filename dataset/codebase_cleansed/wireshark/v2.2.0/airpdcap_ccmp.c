static void ccmp_init_blocks(\r\nrijndael_ctx *ctx,\r\nPAIRPDCAP_MAC_FRAME wh,\r\nUINT64 pn,\r\nsize_t dlen,\r\nUINT8 b0[AES_BLOCK_LEN],\r\nUINT8 aad[2 * AES_BLOCK_LEN],\r\nUINT8 a[AES_BLOCK_LEN],\r\nUINT8 b[AES_BLOCK_LEN])\r\n{\r\nUINT8 mgmt = (AIRPDCAP_TYPE(wh->fc[0]) == AIRPDCAP_TYPE_MANAGEMENT);\r\n#define IS_4ADDRESS(wh) \\r\n((wh->fc[1] & AIRPDCAP_FC1_DIR_MASK) == AIRPDCAP_FC1_DIR_DSTODS)\r\n#define IS_QOS_DATA(wh) AIRPDCAP_QOS_HAS_SEQ(wh)\r\nmemset(aad, 0, 2*AES_BLOCK_LEN);\r\nb0[0] = 0x59;\r\nAIRPDCAP_ADDR_COPY(b0 + 2, wh->addr2);\r\nb0[8] = (UINT8)(pn >> 40);\r\nb0[9] = (UINT8)(pn >> 32);\r\nb0[10] = (UINT8)(pn >> 24);\r\nb0[11] = (UINT8)(pn >> 16);\r\nb0[12] = (UINT8)(pn >> 8);\r\nb0[13] = (UINT8)(pn >> 0);\r\nb0[14] = (UINT8)((UINT8)(dlen >> 8) & 0xff);\r\nb0[15] = (UINT8)(dlen & 0xff);\r\naad[0] = 0;\r\nif (!mgmt)\r\naad[2] = (UINT8)(wh->fc[0] & 0x8f);\r\nelse\r\naad[2] = wh->fc[0];\r\naad[3] = (UINT8)(wh->fc[1] & 0xc7);\r\nmemcpy(aad + 4, &wh->addr1[0], 3 * AIRPDCAP_MAC_LEN);\r\naad[22] = (UINT8)(wh->seq[0] & AIRPDCAP_SEQ_FRAG_MASK);\r\naad[23] = 0;\r\nif (IS_4ADDRESS(wh)) {\r\nAIRPDCAP_ADDR_COPY(aad + 24,\r\n((PAIRPDCAP_MAC_FRAME_ADDR4)wh)->addr4);\r\nif (IS_QOS_DATA(wh)) {\r\nPAIRPDCAP_MAC_FRAME_ADDR4_QOS qwh4 =\r\n(PAIRPDCAP_MAC_FRAME_ADDR4_QOS) wh;\r\naad[30] = (UINT8)(qwh4->qos[0] & 0x0f);\r\naad[31] = 0;\r\nb0[1] = aad[30];\r\naad[1] = 22 + AIRPDCAP_MAC_LEN + 2;\r\n} else {\r\nmemset(&aad[30], 0, 2);\r\nb0[1] = 0;\r\naad[1] = 22 + AIRPDCAP_MAC_LEN;\r\n}\r\n} else {\r\nif (IS_QOS_DATA(wh)) {\r\nPAIRPDCAP_MAC_FRAME_QOS qwh =\r\n(PAIRPDCAP_MAC_FRAME_QOS) wh;\r\naad[24] = (UINT8)(qwh->qos[0] & 0x0f);\r\naad[25] = 0;\r\nb0[1] = aad[24];\r\naad[1] = 22 + 2;\r\n} else {\r\nmemset(&aad[24], 0, 2);\r\nb0[1] = 0;\r\naad[1] = 22;\r\n}\r\nif (mgmt)\r\nb0[1] |= 0x10;\r\nmemset(&aad[26], 0, 4);\r\n}\r\nrijndael_encrypt(ctx, b0, a);\r\nXOR_BLOCK(a, aad, AES_BLOCK_LEN);\r\nrijndael_encrypt(ctx, a, a);\r\nXOR_BLOCK(a, &aad[AES_BLOCK_LEN], AES_BLOCK_LEN);\r\nrijndael_encrypt(ctx, a, a);\r\nb0[0] &= 0x07;\r\nb0[14] = b0[15] = 0;\r\nrijndael_encrypt(ctx, b0, b);\r\n#undef IS_QOS_DATA\r\n#undef IS_4ADDRESS\r\n}\r\nINT AirPDcapCcmpDecrypt(\r\nUINT8 *m,\r\ngint mac_header_len,\r\nINT len,\r\nUCHAR TK1[16])\r\n{\r\nPAIRPDCAP_MAC_FRAME wh;\r\nUINT8 aad[2 * AES_BLOCK_LEN];\r\nUINT8 b0[AES_BLOCK_LEN], b[AES_BLOCK_LEN], a[AES_BLOCK_LEN];\r\nUINT8 mic[AES_BLOCK_LEN];\r\nsize_t data_len;\r\nUINT i;\r\nUINT8 *pos;\r\nUINT space;\r\nINT z = mac_header_len;\r\nrijndael_ctx key;\r\nUINT64 PN;\r\nUINT8 *ivp=m+z;\r\nPN = READ_6(ivp[0], ivp[1], ivp[4], ivp[5], ivp[6], ivp[7]);\r\nrijndael_set_key(&key, TK1, 128);\r\nwh = (PAIRPDCAP_MAC_FRAME )m;\r\ndata_len = len - (z + AIRPDCAP_CCMP_HEADER+AIRPDCAP_CCMP_TRAILER);\r\nif (data_len < 1)\r\nreturn 0;\r\nccmp_init_blocks(&key, wh, PN, data_len, b0, aad, a, b);\r\nmemcpy(mic, m+len-AIRPDCAP_CCMP_TRAILER, AIRPDCAP_CCMP_TRAILER);\r\nXOR_BLOCK(mic, b, AIRPDCAP_CCMP_TRAILER);\r\ni = 1;\r\npos = (UINT8 *)m + z + AIRPDCAP_CCMP_HEADER;\r\nspace = len - (z + AIRPDCAP_CCMP_HEADER);\r\nif (space > data_len)\r\nspace = (UINT)data_len;\r\nwhile (space >= AES_BLOCK_LEN) {\r\nCCMP_DECRYPT(i, b, b0, pos, a, AES_BLOCK_LEN);\r\npos += AES_BLOCK_LEN, space -= AES_BLOCK_LEN;\r\ni++;\r\n}\r\nif (space != 0)\r\nCCMP_DECRYPT(i, b, b0, pos, a, space);\r\nif (memcmp(mic, a, AIRPDCAP_CCMP_TRAILER) == 0) {\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}
