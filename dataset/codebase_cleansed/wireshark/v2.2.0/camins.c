static gboolean\r\nfind_next_pkt_dat_type_len(FILE_T fh,\r\nguint8 *dat_trans_type,\r\nguint16 *dat_len,\r\nint *err, gchar **err_info)\r\n{\r\nguint8 block[2];\r\nsize_read_t size_stat;\r\nif (!dat_trans_type || !dat_len)\r\nreturn FALSE;\r\nRESET_STAT_VALS;\r\ndo {\r\nif (!wtap_read_bytes_or_eof(fh, block, sizeof(block), err, err_info)) {\r\nRESET_STAT_VALS;\r\nreturn FALSE;\r\n}\r\nswitch (block[1]) {\r\ncase TRANS_READ_SIZE_LOW:\r\nif (*dat_trans_type != TRANS_CAM_HOST)\r\nRESET_STAT_VALS;\r\n*dat_trans_type = TRANS_CAM_HOST;\r\n*dat_len |= block[0];\r\nSIZE_ADD_LOW;\r\nbreak;\r\ncase TRANS_READ_SIZE_HIGH:\r\nif (*dat_trans_type != TRANS_CAM_HOST)\r\nRESET_STAT_VALS;\r\n*dat_trans_type = TRANS_CAM_HOST;\r\n*dat_len |= (block[0] << 8);\r\nSIZE_ADD_HIGH;\r\nbreak;\r\ncase TRANS_WRITE_SIZE_LOW:\r\nif (*dat_trans_type != TRANS_HOST_CAM)\r\nRESET_STAT_VALS;\r\n*dat_trans_type = TRANS_HOST_CAM;\r\n*dat_len |= block[0];\r\nSIZE_ADD_LOW;\r\nbreak;\r\ncase TRANS_WRITE_SIZE_HIGH:\r\nif (*dat_trans_type != TRANS_HOST_CAM)\r\nRESET_STAT_VALS;\r\n*dat_trans_type = TRANS_HOST_CAM;\r\n*dat_len |= (block[0] << 8);\r\nSIZE_ADD_HIGH;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} while (size_stat != SIZE_HAVE_ALL);\r\nreturn TRUE;\r\n}\r\nstatic gint\r\nread_packet_data(FILE_T fh, guint8 dat_trans_type, guint8 *buf, guint16 dat_len,\r\nint *err, gchar **err_info)\r\n{\r\nguint8 *p;\r\nguint8 block[2];\r\nguint16 bytes_count = 0;\r\nif (!buf)\r\nreturn -1;\r\np = buf;\r\nwhile (bytes_count < dat_len) {\r\nif (!wtap_read_bytes_or_eof(fh, block, sizeof(block), err, err_info))\r\nbreak;\r\nif (block[1] == dat_trans_type) {\r\n*p++ = block[0];\r\nbytes_count++;\r\n}\r\nelse if (IS_TRANS_SIZE(block[1])) {\r\nif (-1 == file_seek(fh, -(gint64)sizeof(block), SEEK_CUR, err))\r\nreturn -1;\r\nbreak;\r\n}\r\n}\r\nreturn bytes_count;\r\n}\r\nstatic gint\r\ncreate_pseudo_hdr(guint8 *buf, guint8 dat_trans_type, guint16 dat_len)\r\n{\r\nif (!buf)\r\nreturn -1;\r\nbuf[0] = DVB_CI_PSEUDO_HDR_VER;\r\nif (dat_trans_type==TRANS_CAM_HOST)\r\nbuf[1] = DVB_CI_PSEUDO_HDR_CAM_TO_HOST;\r\nelse if (dat_trans_type==TRANS_HOST_CAM)\r\nbuf[1] = DVB_CI_PSEUDO_HDR_HOST_TO_CAM;\r\nelse\r\nreturn -1;\r\nbuf[2] = (dat_len>>8) & 0xFF;\r\nbuf[3] = dat_len & 0xFF;\r\nreturn DVB_CI_PSEUDO_HDR_LEN;\r\n}\r\nstatic gboolean\r\ncamins_read_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nguint8 dat_trans_type;\r\nguint16 dat_len;\r\nguint8 *p;\r\ngint offset, bytes_read;\r\nif (!find_next_pkt_dat_type_len(fh, &dat_trans_type, &dat_len, err, err_info))\r\nreturn FALSE;\r\nws_buffer_assure_space(buf, DVB_CI_PSEUDO_HDR_LEN+dat_len);\r\np = ws_buffer_start_ptr(buf);\r\noffset = create_pseudo_hdr(p, dat_trans_type, dat_len);\r\nif (offset<0) {\r\n*err = WTAP_ERR_INTERNAL;\r\nreturn FALSE;\r\n}\r\nbytes_read = read_packet_data(fh, dat_trans_type,\r\n&p[offset], dat_len, err, err_info);\r\nif (bytes_read < 0)\r\nreturn FALSE;\r\noffset += bytes_read;\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->pkt_encap = WTAP_ENCAP_DVBCI;\r\nphdr->caplen = offset;\r\nphdr->len = offset;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ncamins_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nreturn camins_read_packet(wth->fh, &wth->phdr, wth->frame_buffer, err,\r\nerr_info);\r\n}\r\nstatic gboolean\r\ncamins_seek_read(wtap *wth, gint64 seek_off,\r\nstruct wtap_pkthdr *pkthdr, Buffer *buf, int *err, gchar **err_info)\r\n{\r\nif (-1 == file_seek(wth->random_fh, seek_off, SEEK_SET, err))\r\nreturn FALSE;\r\nreturn camins_read_packet(wth->random_fh, pkthdr, buf, err, err_info);\r\n}\r\nwtap_open_return_val camins_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nguint8 found_start_blocks = 0;\r\nguint8 count = 0;\r\nguint8 block[2];\r\ndo {\r\nif (!wtap_read_bytes(wth->fh, block, sizeof(block), err, err_info)) {\r\nif (*err == WTAP_ERR_SHORT_READ)\r\nbreak;\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nif (block[0]==0x00 && block[1] == 0xE1)\r\nfound_start_blocks++;\r\ncount++;\r\n} while (count<20);\r\nif (found_start_blocks < 2)\r\nreturn WTAP_OPEN_NOT_MINE;\r\nif (-1 == file_seek(wth->fh, 0, SEEK_SET, err))\r\nreturn WTAP_OPEN_ERROR;\r\nwth->file_encap = WTAP_ENCAP_DVBCI;\r\nwth->snapshot_length = 0;\r\nwth->file_tsprec = WTAP_TSPREC_MSEC;\r\nwth->priv = NULL;\r\nwth->subtype_read = camins_read;\r\nwth->subtype_seek_read = camins_seek_read;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_CAMINS;\r\n*err = 0;\r\nreturn WTAP_OPEN_MINE;\r\n}
