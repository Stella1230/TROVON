static void\r\nsctpstat_reset(void *phs)\r\n{\r\nsctpstat_t *sctp_stat = (sctpstat_t *)phs;\r\nsctp_ep_t *list = (sctp_ep_t *)sctp_stat->ep_list;\r\nsctp_ep_t *tmp = NULL;\r\nguint16 chunk_type;\r\nif (!list)\r\nreturn;\r\nfor (tmp = list; tmp; tmp = tmp->next)\r\nfor (chunk_type = 0; chunk_type < 256; chunk_type++)\r\ntmp->chunk_count[chunk_type] = 0;\r\nsctp_stat->number_of_packets = 0;\r\n}\r\nstatic sctp_ep_t *\r\nalloc_sctp_ep(const struct _sctp_info *si)\r\n{\r\nsctp_ep_t *ep;\r\nguint16 chunk_type;\r\nif (!si)\r\nreturn NULL;\r\nif (!(ep = g_new(sctp_ep_t, 1)))\r\nreturn NULL;\r\ncopy_address(&ep->src, &si->ip_src);\r\ncopy_address(&ep->dst, &si->ip_dst);\r\nep->sport = si->sport;\r\nep->dport = si->dport;\r\nep->next = NULL;\r\nfor (chunk_type = 0; chunk_type < 256; chunk_type++)\r\nep->chunk_count[chunk_type] = 0;\r\nreturn ep;\r\n}\r\nstatic int\r\nsctpstat_packet(void *phs, packet_info *pinfo _U_, epan_dissect_t *edt _U_, const void *phi)\r\n{\r\nsctpstat_t *hs = (sctpstat_t *)phs;\r\nsctp_ep_t *tmp = NULL, *te = NULL;\r\nconst struct _sctp_info *si = (const struct _sctp_info *)phi;\r\nguint32 tvb_number;\r\nguint8 chunk_type;\r\nif (!hs)\r\nreturn (0);\r\nhs->number_of_packets++;\r\nif (!hs->ep_list) {\r\nhs->ep_list = alloc_sctp_ep(si);\r\nte = hs->ep_list;\r\n} else {\r\nfor (tmp = hs->ep_list; tmp; tmp = tmp->next)\r\n{\r\nif ((!cmp_address(&tmp->src, &si->ip_src)) &&\r\n(!cmp_address(&tmp->dst, &si->ip_dst)) &&\r\n(tmp->sport == si->sport) &&\r\n(tmp->dport == si->dport))\r\n{\r\nte = tmp;\r\nbreak;\r\n}\r\n}\r\nif (!te) {\r\nif ((te = alloc_sctp_ep(si))) {\r\nte->next = hs->ep_list;\r\nhs->ep_list = te;\r\n}\r\n}\r\n}\r\nif (!te)\r\nreturn (0);\r\nif (si->number_of_tvbs > 0) {\r\nchunk_type = CHUNK_TYPE(si->tvb[0]);\r\nif ((chunk_type == SCTP_INIT_CHUNK_ID) ||\r\n(chunk_type == SCTP_INIT_ACK_CHUNK_ID)) {\r\nte->chunk_count[chunk_type]++;\r\n} else {\r\nfor (tvb_number = 0; tvb_number < si->number_of_tvbs; tvb_number++)\r\nte->chunk_count[CHUNK_TYPE(si->tvb[tvb_number])]++;\r\n}\r\n}\r\nreturn (1);\r\n}\r\nstatic void\r\nsctpstat_draw(void *phs)\r\n{\r\nsctpstat_t *hs = (sctpstat_t *)phs;\r\nsctp_ep_t *list = hs->ep_list, *tmp;\r\nchar *src_addr, *dst_addr;\r\nprintf("-------------------------------------------- SCTP Statistics --------------------------------------------------------------------------\n");\r\nprintf("| Total packets RX/TX %u\n", hs->number_of_packets);\r\nprintf("---------------------------------------------------------------------------------------------------------------------------------------\n");\r\nprintf("| Source IP |PortA| Dest. IP |PortB| DATA | SACK | HBEAT |HBEATACK| INIT | INITACK| COOKIE |COOKIACK| ABORT | ERROR |\n");\r\nprintf("---------------------------------------------------------------------------------------------------------------------------------------\n");\r\nfor (tmp = list; tmp; tmp = tmp->next) {\r\nsrc_addr = (char*)address_to_str(NULL, &tmp->src);\r\ndst_addr = (char*)address_to_str(NULL, &tmp->dst);\r\nprintf("|%15s|%5u|%15s|%5u|%8u|%8u|%8u|%8u|%8u|%8u|%8u|%8u|%8u|%8u|\n",\r\nsrc_addr, tmp->sport,\r\ndst_addr, tmp->dport,\r\ntmp->chunk_count[SCTP_DATA_CHUNK_ID],\r\ntmp->chunk_count[SCTP_SACK_CHUNK_ID],\r\ntmp->chunk_count[SCTP_HEARTBEAT_CHUNK_ID],\r\ntmp->chunk_count[SCTP_HEARTBEAT_ACK_CHUNK_ID],\r\ntmp->chunk_count[SCTP_INIT_CHUNK_ID],\r\ntmp->chunk_count[SCTP_INIT_ACK_CHUNK_ID],\r\ntmp->chunk_count[SCTP_COOKIE_ECHO_CHUNK_ID],\r\ntmp->chunk_count[SCTP_COOKIE_ACK_CHUNK_ID],\r\ntmp->chunk_count[SCTP_ABORT_CHUNK_ID],\r\ntmp->chunk_count[SCTP_ERROR_CHUNK_ID]);\r\nwmem_free(NULL, src_addr);\r\nwmem_free(NULL, dst_addr);\r\n}\r\nprintf("---------------------------------------------------------------------------------------------------------------------------------------\n");\r\n}\r\nstatic void\r\nsctpstat_init(const char *opt_arg, void *userdata _U_)\r\n{\r\nsctpstat_t *hs;\r\nGString *error_string;\r\nhs = (sctpstat_t *)g_malloc(sizeof(sctpstat_t));\r\nif (!strncmp(opt_arg, "sctp,stat,", 11)) {\r\nhs->filter = g_strdup(opt_arg+11);\r\n} else {\r\nhs->filter = NULL;\r\n}\r\nhs->ep_list = NULL;\r\nhs->number_of_packets = 0;\r\nsctpstat_reset(hs);\r\nerror_string = register_tap_listener("sctp", hs, hs->filter, 0, NULL, sctpstat_packet, sctpstat_draw);\r\nif (error_string) {\r\ng_free(hs->filter);\r\ng_free(hs);\r\nfprintf(stderr, "tshark: Couldn't register sctp,stat tap: %s\n",\r\nerror_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\n}\r\nvoid\r\nregister_tap_listener_sctpstat(void)\r\n{\r\nregister_stat_tap_ui(&sctpstat_ui, NULL);\r\n}
