WSLUA_FUNCTION wslua_get_version(lua_State* L) {\r\nconst gchar* str = VERSION;\r\nlua_pushstring(L,str);\r\nWSLUA_RETURN(1);\r\n}\r\nconst gchar* get_current_plugin_version(void) {\r\nreturn current_plugin_version ? current_plugin_version : "";\r\n}\r\nvoid clear_current_plugin_version(void) {\r\nif (current_plugin_version != NULL) {\r\ng_free(current_plugin_version);\r\ncurrent_plugin_version = NULL;\r\n}\r\n}\r\nWSLUA_FUNCTION wslua_set_plugin_info(lua_State* L) {\r\n#define WSLUA_ARG_set_plugin_info_TABLE 1\r\nif ( lua_istable(L,WSLUA_ARG_set_plugin_info_TABLE) ) {\r\nint top;\r\nlua_getfield(L, WSLUA_ARG_set_plugin_info_TABLE, "version");\r\ntop = lua_gettop(L);\r\nif (lua_isstring(L, top)) {\r\nclear_current_plugin_version();\r\ncurrent_plugin_version = g_strdup( luaL_checkstring(L, top) );\r\nlua_pop(L, 1);\r\n}\r\nelse {\r\nreturn luaL_error(L,"the Lua table must have a 'version' key entry with a string value");\r\n}\r\n} else {\r\nreturn luaL_error(L,"a Lua table with at least a 'version' string entry");\r\n}\r\nreturn 0;\r\n}\r\nWSLUA_FUNCTION wslua_format_date(lua_State* LS) {\r\n#define WSLUA_ARG_format_date_TIMESTAMP 1\r\nlua_Number timestamp = luaL_checknumber(LS,WSLUA_ARG_format_date_TIMESTAMP);\r\nnstime_t then;\r\ngchar* str;\r\nthen.secs = (guint32)(floor(timestamp));\r\nthen.nsecs = (guint32) ( (timestamp-(double)(then.secs))*1000000000);\r\nstr = abs_time_to_str(NULL, &then, ABSOLUTE_TIME_LOCAL, TRUE);\r\nlua_pushstring(LS,str);\r\nwmem_free(NULL, str);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_FUNCTION wslua_format_time(lua_State* LS) {\r\n#define WSLUA_ARG_format_time_TIMESTAMP 1\r\nlua_Number timestamp = luaL_checknumber(LS,WSLUA_ARG_format_time_TIMESTAMP);\r\nnstime_t then;\r\ngchar* str;\r\nthen.secs = (guint32)(floor(timestamp));\r\nthen.nsecs = (guint32) ( (timestamp-(double)(then.secs))*1000000000);\r\nstr = rel_time_to_str(NULL, &then);\r\nlua_pushstring(LS,str);\r\nwmem_free(NULL, str);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_FUNCTION wslua_report_failure(lua_State* LS) {\r\n#define WSLUA_ARG_report_failure_TEXT 1\r\nconst gchar* s = luaL_checkstring(LS,WSLUA_ARG_report_failure_TEXT);\r\nreport_failure("%s",s);\r\nreturn 0;\r\n}\r\nstatic int wslua_log(lua_State* L, GLogLevelFlags log_level) {\r\nGString* str = g_string_new("");\r\nint n = lua_gettop(L);\r\nint i;\r\nlua_getglobal(L, "tostring");\r\nfor (i=1; i<=n; i++) {\r\nconst char *s;\r\nlua_pushvalue(L, -1);\r\nlua_pushvalue(L, i);\r\nlua_call(L, 1, 1);\r\ns = lua_tostring(L, -1);\r\nif (s == NULL)\r\nreturn luaL_error(L, "`tostring' must return a string");\r\nif (i>1) g_string_append(str,"\t");\r\ng_string_append(str,s);\r\nlua_pop(L, 1);\r\n}\r\ng_log(LOG_DOMAIN_LUA, log_level, "%s\n", str->str);\r\ng_string_free(str,TRUE);\r\nreturn 0;\r\n}\r\nWSLUA_FUNCTION wslua_critical( lua_State* L ) {\r\nwslua_log(L,G_LOG_LEVEL_CRITICAL);\r\nreturn 0;\r\n}\r\nWSLUA_FUNCTION wslua_warn( lua_State* L ) {\r\nwslua_log(L,G_LOG_LEVEL_WARNING);\r\nreturn 0;\r\n}\r\nWSLUA_FUNCTION wslua_message( lua_State* L ) {\r\nwslua_log(L,G_LOG_LEVEL_MESSAGE);\r\nreturn 0;\r\n}\r\nWSLUA_FUNCTION wslua_info( lua_State* L ) {\r\nwslua_log(L,G_LOG_LEVEL_INFO);\r\nreturn 0;\r\n}\r\nWSLUA_FUNCTION wslua_debug( lua_State* L ) {\r\nwslua_log(L,G_LOG_LEVEL_DEBUG);\r\nreturn 0;\r\n}\r\nchar* wslua_get_actual_filename(const char* fname) {\r\nchar fname_clean[256];\r\nchar* f;\r\nchar* filename;\r\ng_strlcpy(fname_clean,fname,255);\r\nfname_clean[255] = '\0';\r\nfor(f = fname_clean; *f; f++) {\r\nswitch(*f) {\r\ncase '/': case '\\':\r\n*f = *(G_DIR_SEPARATOR_S);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif ( file_exists(fname_clean) ) {\r\nreturn g_strdup(fname_clean);\r\n}\r\nfilename = get_persconffile_path(fname_clean,FALSE);\r\nif ( file_exists(filename) ) {\r\nreturn filename;\r\n}\r\ng_free(filename);\r\nfilename = get_datafile_path(fname_clean);\r\nif ( file_exists(filename) ) {\r\nreturn filename;\r\n}\r\ng_free(filename);\r\nif (running_in_build_directory()) {\r\nfilename = g_strdup_printf("%s" G_DIR_SEPARATOR_S "epan" G_DIR_SEPARATOR_S "wslua"\r\nG_DIR_SEPARATOR_S "%s", get_datafile_dir(), fname_clean);\r\nif (( ! file_exists(filename))) {\r\ng_free(filename);\r\nfilename = g_strdup_printf("%s" G_DIR_SEPARATOR_S "%s",\r\nget_progfile_dir(), fname_clean);\r\n}\r\nif ( file_exists(filename) ) {\r\nreturn filename;\r\n}\r\ng_free(filename);\r\n}\r\nreturn NULL;\r\n}\r\nWSLUA_FUNCTION wslua_loadfile(lua_State* L) {\r\n#define WSLUA_ARG_loadfile_FILENAME 1\r\nconst char *given_fname = luaL_checkstring(L, WSLUA_ARG_loadfile_FILENAME);\r\nchar* filename;\r\nfilename = wslua_get_actual_filename(given_fname);\r\nif (!filename) {\r\nWSLUA_ARG_ERROR(loadfile,FILENAME,"file does not exist");\r\nreturn 0;\r\n}\r\nif (luaL_loadfile(L, filename) == 0) {\r\ng_free(filename);\r\nreturn 1;\r\n} else {\r\ng_free(filename);\r\nlua_pushnil(L);\r\nlua_insert(L, -2);\r\nreturn 2;\r\n}\r\n}\r\nWSLUA_FUNCTION wslua_dofile(lua_State* L) {\r\n#define WSLUA_ARG_dofile_FILENAME 1\r\nconst char *given_fname = luaL_checkstring(L, WSLUA_ARG_dofile_FILENAME);\r\nchar* filename = wslua_get_actual_filename(given_fname);\r\nint n;\r\nif (!filename) {\r\nWSLUA_ARG_ERROR(dofile,FILENAME,"file does not exist");\r\nreturn 0;\r\n}\r\nn = lua_gettop(L);\r\nif (luaL_loadfile(L, filename) != 0) lua_error(L);\r\ng_free(filename);\r\nlua_call(L, 0, LUA_MULTRET);\r\nreturn lua_gettop(L) - n;\r\n}\r\nstatic int statcmd_init_cb_error_handler(lua_State* L _U_) {\r\nreturn 0;\r\n}\r\nstatic void statcmd_init(const char *opt_arg, void* userdata) {\r\nstatcmd_t* sc = (statcmd_t *)userdata;\r\nlua_State* L = sc->L;\r\nlua_settop(L,0);\r\nlua_pushcfunction(L,statcmd_init_cb_error_handler);\r\nlua_rawgeti(L, LUA_REGISTRYINDEX, sc->func_ref);\r\nlua_pushstring(L,opt_arg);\r\nswitch ( lua_pcall(L,1,0,1) ) {\r\ncase 0:\r\nbreak;\r\ncase LUA_ERRRUN:\r\ng_warning("Runtime error while calling statcmd callback");\r\nbreak;\r\ncase LUA_ERRMEM:\r\ng_warning("Memory alloc error while calling statcmd callback");\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\nWSLUA_FUNCTION wslua_register_stat_cmd_arg(lua_State* L) {\r\n#define WSLUA_ARG_register_stat_cmd_arg_ARGUMENT 1\r\n#define WSLUA_OPTARG_register_stat_cmd_arg_ACTION 2\r\nconst char* arg = luaL_checkstring(L,WSLUA_ARG_register_stat_cmd_arg_ARGUMENT);\r\nstatcmd_t* sc = (statcmd_t *)g_malloc0(sizeof(statcmd_t));\r\nstat_tap_ui ui_info;\r\nsc->L = L;\r\nlua_pushvalue(L, WSLUA_OPTARG_register_stat_cmd_arg_ACTION);\r\nsc->func_ref = luaL_ref(L, LUA_REGISTRYINDEX);\r\nlua_remove(L,1);\r\nui_info.group = REGISTER_STAT_GROUP_UNSORTED;\r\nui_info.title = NULL;\r\nui_info.cli_string = arg;\r\nui_info.tap_init_cb = statcmd_init;\r\nui_info.nparams = 0;\r\nui_info.params = NULL;\r\nregister_stat_tap_ui(&ui_info, sc);\r\nreturn 0;\r\n}
