static void\r\nswap_mac_addr(guint8 *swapped_addr, tvbuff_t *tvb, gint offset)\r\n{\r\ntvb_memcpy(tvb, swapped_addr, offset, 6);\r\nbitswap_buf_inplace(swapped_addr, 6);\r\n}\r\nstatic const char* fddi_conv_get_filter_type(conv_item_t* conv, conv_filter_type_e filter)\r\n{\r\nif ((filter == CONV_FT_SRC_ADDRESS) && (conv->src_address.type == AT_ETHER))\r\nreturn "fddi.src";\r\nif ((filter == CONV_FT_DST_ADDRESS) && (conv->dst_address.type == AT_ETHER))\r\nreturn "fddi.dst";\r\nif ((filter == CONV_FT_ANY_ADDRESS) && (conv->src_address.type == AT_ETHER))\r\nreturn "fddi.addr";\r\nreturn CONV_FILTER_INVALID;\r\n}\r\nstatic int\r\nfddi_conversation_packet(void *pct, packet_info *pinfo, epan_dissect_t *edt _U_, const void *vip)\r\n{\r\nconv_hash_t *hash = (conv_hash_t*) pct;\r\nconst fddi_hdr *ehdr=(const fddi_hdr *)vip;\r\nadd_conversation_table_data(hash, &ehdr->src, &ehdr->dst, 0, 0, 1, pinfo->fd->pkt_len, &pinfo->rel_ts, &pinfo->abs_ts, &fddi_ct_dissector_info, PT_NONE);\r\nreturn 1;\r\n}\r\nstatic const char* fddi_host_get_filter_type(hostlist_talker_t* host, conv_filter_type_e filter)\r\n{\r\nif ((filter == CONV_FT_ANY_ADDRESS) && (host->myaddress.type == AT_ETHER))\r\nreturn "fddi.addr";\r\nreturn CONV_FILTER_INVALID;\r\n}\r\nstatic int\r\nfddi_hostlist_packet(void *pit, packet_info *pinfo, epan_dissect_t *edt _U_, const void *vip)\r\n{\r\nconv_hash_t *hash = (conv_hash_t*) pit;\r\nconst fddi_hdr *ehdr=(const fddi_hdr *)vip;\r\nadd_hostlist_table_data(hash, &ehdr->src, 0, TRUE, 1, pinfo->fd->pkt_len, &fddi_host_dissector_info, PT_NONE);\r\nadd_hostlist_table_data(hash, &ehdr->dst, 0, FALSE, 1, pinfo->fd->pkt_len, &fddi_host_dissector_info, PT_NONE);\r\nreturn 1;\r\n}\r\nstatic gboolean\r\ncapture_fddi(const guchar *pd, int offset, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header)\r\n{\r\nint fc;\r\nif (!BYTES_ARE_IN_FRAME(0, len, FDDI_HEADER_SIZE + FDDI_PADDING))\r\nreturn FALSE;\r\noffset = FDDI_PADDING + FDDI_HEADER_SIZE;\r\nfc = (int) pd[FDDI_P_FC+FDDI_PADDING];\r\nswitch (fc) {\r\ncase FDDI_FC_LLC_ASYNC + 0 :\r\ncase FDDI_FC_LLC_ASYNC + 1 :\r\ncase FDDI_FC_LLC_ASYNC + 2 :\r\ncase FDDI_FC_LLC_ASYNC + 3 :\r\ncase FDDI_FC_LLC_ASYNC + 4 :\r\ncase FDDI_FC_LLC_ASYNC + 5 :\r\ncase FDDI_FC_LLC_ASYNC + 6 :\r\ncase FDDI_FC_LLC_ASYNC + 7 :\r\ncase FDDI_FC_LLC_ASYNC + 8 :\r\ncase FDDI_FC_LLC_ASYNC + 9 :\r\ncase FDDI_FC_LLC_ASYNC + 10 :\r\ncase FDDI_FC_LLC_ASYNC + 11 :\r\ncase FDDI_FC_LLC_ASYNC + 12 :\r\ncase FDDI_FC_LLC_ASYNC + 13 :\r\ncase FDDI_FC_LLC_ASYNC + 14 :\r\ncase FDDI_FC_LLC_ASYNC + 15 :\r\nreturn capture_llc(pd, offset, len, cpinfo, pseudo_header);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic const gchar *\r\nfddifc_to_str(int fc)\r\n{\r\nstatic gchar strbuf[128+1];\r\nswitch (fc) {\r\ncase FDDI_FC_VOID:\r\nreturn "Void frame";\r\ncase FDDI_FC_NRT:\r\nreturn "Nonrestricted token";\r\ncase FDDI_FC_RT:\r\nreturn "Restricted token";\r\ncase FDDI_FC_SMT_INFO:\r\nreturn "SMT info";\r\ncase FDDI_FC_SMT_NSA:\r\nreturn "SMT Next station address";\r\ncase FDDI_FC_MAC_BEACON:\r\nreturn "MAC beacon";\r\ncase FDDI_FC_MAC_CLAIM:\r\nreturn "MAC claim token";\r\ndefault:\r\nswitch (fc & FDDI_FC_CLFF) {\r\ncase FDDI_FC_MAC:\r\ng_snprintf(strbuf, sizeof(strbuf), "MAC frame, control %x", fc & FDDI_FC_ZZZZ);\r\nreturn strbuf;\r\ncase FDDI_FC_SMT:\r\ng_snprintf(strbuf, sizeof(strbuf), "SMT frame, control %x", fc & FDDI_FC_ZZZZ);\r\nreturn strbuf;\r\ncase FDDI_FC_LLC_ASYNC:\r\nif (fc & FDDI_FC_ASYNC_R)\r\ng_snprintf(strbuf, sizeof(strbuf), "Async LLC frame, control %x", fc & FDDI_FC_ZZZZ);\r\nelse\r\ng_snprintf(strbuf, sizeof(strbuf), "Async LLC frame, priority %d",\r\nfc & FDDI_FC_ASYNC_PRI);\r\nreturn strbuf;\r\ncase FDDI_FC_LLC_SYNC:\r\nif (fc & FDDI_FC_ZZZZ) {\r\ng_snprintf(strbuf, sizeof(strbuf), "Sync LLC frame, control %x", fc & FDDI_FC_ZZZZ);\r\nreturn strbuf;\r\n} else\r\nreturn "Sync LLC frame";\r\ncase FDDI_FC_IMP_ASYNC:\r\ng_snprintf(strbuf, sizeof(strbuf), "Implementor async frame, control %x",\r\nfc & FDDI_FC_ZZZZ);\r\nreturn strbuf;\r\ncase FDDI_FC_IMP_SYNC:\r\ng_snprintf(strbuf, sizeof(strbuf), "Implementor sync frame, control %x",\r\nfc & FDDI_FC_ZZZZ);\r\nreturn strbuf;\r\ndefault:\r\nreturn "Unknown frame type";\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_fddi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngboolean bitswapped)\r\n{\r\nproto_tree *fh_tree = NULL;\r\nproto_item *ti, *hidden_item;\r\nconst gchar *fc_str;\r\nproto_tree *fc_tree;\r\nguchar *src = (guchar*)wmem_alloc(pinfo->pool, 6), *dst = (guchar*)wmem_alloc(pinfo->pool, 6);\r\nguchar src_swapped[6], dst_swapped[6];\r\ntvbuff_t *next_tvb;\r\nstatic fddi_hdr fddihdrs[4];\r\nstatic int fddihdr_num = 0;\r\nfddi_hdr *fddihdr;\r\nfddihdr_num++;\r\nif (fddihdr_num >= 4) {\r\nfddihdr_num = 0;\r\n}\r\nfddihdr = &fddihdrs[fddihdr_num];\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "FDDI");\r\nfddihdr->fc = tvb_get_guint8(tvb, FDDI_P_FC + FDDI_PADDING);\r\nfc_str = fddifc_to_str(fddihdr->fc);\r\ncol_add_str(pinfo->cinfo, COL_INFO, fc_str);\r\nif (tree) {\r\nti = proto_tree_add_protocol_format(tree, proto_fddi, tvb, 0, FDDI_HEADER_SIZE+FDDI_PADDING,\r\n"Fiber Distributed Data Interface, %s", fc_str);\r\nfh_tree = proto_item_add_subtree(ti, ett_fddi);\r\nti = proto_tree_add_uint_format_value(fh_tree, hf_fddi_fc, tvb, FDDI_P_FC + FDDI_PADDING, 1, fddihdr->fc,\r\n"0x%02x (%s)", fddihdr->fc, fc_str);\r\nfc_tree = proto_item_add_subtree(ti, ett_fddi_fc);\r\nproto_tree_add_uint(fc_tree, hf_fddi_fc_clf, tvb, FDDI_P_FC + FDDI_PADDING, 1, fddihdr->fc);\r\nswitch ((fddihdr->fc) & FDDI_FC_CLFF) {\r\ncase FDDI_FC_SMT:\r\nproto_tree_add_uint(fc_tree, hf_fddi_fc_smt_subtype, tvb, FDDI_P_FC + FDDI_PADDING, 1, fddihdr->fc);\r\nbreak;\r\ncase FDDI_FC_MAC:\r\nif (fddihdr->fc != FDDI_FC_RT)\r\nproto_tree_add_uint(fc_tree, hf_fddi_fc_mac_subtype, tvb, FDDI_P_FC + FDDI_PADDING, 1, fddihdr->fc);\r\nbreak;\r\ncase FDDI_FC_LLC_ASYNC:\r\nif (!((fddihdr->fc) & FDDI_FC_ASYNC_R))\r\nproto_tree_add_uint(fc_tree, hf_fddi_fc_prio, tvb, FDDI_P_FC + FDDI_PADDING, 1, fddihdr->fc);\r\nbreak;\r\n}\r\n}\r\nif (bitswapped)\r\nswap_mac_addr(dst, tvb, FDDI_P_DHOST + FDDI_PADDING);\r\nelse\r\ntvb_memcpy(tvb, dst, FDDI_P_DHOST + FDDI_PADDING, 6);\r\nswap_mac_addr(dst_swapped, tvb, FDDI_P_DHOST + FDDI_PADDING);\r\nset_address(&pinfo->dl_dst, AT_ETHER, 6, dst);\r\ncopy_address_shallow(&pinfo->dst, &pinfo->dl_dst);\r\ncopy_address_shallow(&fddihdr->dst, &pinfo->dl_dst);\r\nif (fh_tree) {\r\nproto_tree_add_ether(fh_tree, hf_fddi_dst, tvb, FDDI_P_DHOST + FDDI_PADDING, 6, dst);\r\nhidden_item = proto_tree_add_ether(fh_tree, hf_fddi_addr, tvb, FDDI_P_DHOST + FDDI_PADDING, 6, dst);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_ether(fh_tree, hf_fddi_dst, tvb, FDDI_P_DHOST + FDDI_PADDING, 6, dst_swapped);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_ether(fh_tree, hf_fddi_addr, tvb, FDDI_P_DHOST + FDDI_PADDING, 6, dst_swapped);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\n}\r\nif (bitswapped)\r\nswap_mac_addr(src, tvb, FDDI_P_SHOST + FDDI_PADDING);\r\nelse\r\ntvb_memcpy(tvb, src, FDDI_P_SHOST + FDDI_PADDING, 6);\r\nswap_mac_addr(src_swapped, tvb, FDDI_P_SHOST + FDDI_PADDING);\r\nset_address(&pinfo->dl_src, AT_ETHER, 6, src);\r\ncopy_address_shallow(&pinfo->src, &pinfo->dl_src);\r\ncopy_address_shallow(&fddihdr->src, &pinfo->dl_src);\r\nif (fh_tree) {\r\nproto_tree_add_ether(fh_tree, hf_fddi_src, tvb, FDDI_P_SHOST + FDDI_PADDING, 6, src);\r\nhidden_item = proto_tree_add_ether(fh_tree, hf_fddi_addr, tvb, FDDI_P_SHOST + FDDI_PADDING, 6, src);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_ether(fh_tree, hf_fddi_src, tvb, FDDI_P_SHOST + FDDI_PADDING, 6, src_swapped);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\nhidden_item = proto_tree_add_ether(fh_tree, hf_fddi_addr, tvb, FDDI_P_SHOST + FDDI_PADDING, 6, src_swapped);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, FDDI_HEADER_SIZE + FDDI_PADDING);\r\ntap_queue_packet(fddi_tap, pinfo, fddihdr);\r\nswitch (fddihdr->fc) {\r\ncase FDDI_FC_LLC_ASYNC + 0 :\r\ncase FDDI_FC_LLC_ASYNC + 1 :\r\ncase FDDI_FC_LLC_ASYNC + 2 :\r\ncase FDDI_FC_LLC_ASYNC + 3 :\r\ncase FDDI_FC_LLC_ASYNC + 4 :\r\ncase FDDI_FC_LLC_ASYNC + 5 :\r\ncase FDDI_FC_LLC_ASYNC + 6 :\r\ncase FDDI_FC_LLC_ASYNC + 7 :\r\ncase FDDI_FC_LLC_ASYNC + 8 :\r\ncase FDDI_FC_LLC_ASYNC + 9 :\r\ncase FDDI_FC_LLC_ASYNC + 10 :\r\ncase FDDI_FC_LLC_ASYNC + 11 :\r\ncase FDDI_FC_LLC_ASYNC + 12 :\r\ncase FDDI_FC_LLC_ASYNC + 13 :\r\ncase FDDI_FC_LLC_ASYNC + 14 :\r\ncase FDDI_FC_LLC_ASYNC + 15 :\r\ncall_dissector(llc_handle, next_tvb, pinfo, tree);\r\nreturn;\r\ndefault :\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\nreturn;\r\n}\r\n}\r\nstatic int\r\ndissect_fddi_bitswapped(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_fddi(tvb, pinfo, tree, TRUE);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_fddi_not_bitswapped(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_fddi(tvb, pinfo, tree, FALSE);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_fddi(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_fddi_fc,\r\n{ "Frame Control", "fddi.fc", FT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fddi_fc_clf,\r\n{ "Class/Length/Format", "fddi.fc.clf", FT_UINT8, BASE_HEX, VALS(clf_vals), FDDI_FC_CLFF,\r\nNULL, HFILL }},\r\n{ &hf_fddi_fc_prio,\r\n{ "Priority", "fddi.fc.prio", FT_UINT8, BASE_DEC, NULL, FDDI_FC_ASYNC_PRI,\r\nNULL, HFILL }},\r\n{ &hf_fddi_fc_smt_subtype,\r\n{ "SMT Subtype", "fddi.fc.smt_subtype", FT_UINT8, BASE_DEC, VALS(smt_subtype_vals), FDDI_FC_ZZZZ,\r\nNULL, HFILL }},\r\n{ &hf_fddi_fc_mac_subtype,\r\n{ "MAC Subtype", "fddi.fc.mac_subtype", FT_UINT8, BASE_DEC, VALS(mac_subtype_vals), FDDI_FC_ZZZZ,\r\nNULL, HFILL }},\r\n{ &hf_fddi_dst,\r\n{ "Destination", "fddi.dst", FT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Destination Hardware Address", HFILL }},\r\n{ &hf_fddi_src,\r\n{ "Source", "fddi.src", FT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_fddi_addr,\r\n{ "Source or Destination Address", "fddi.addr", FT_ETHER, BASE_NONE, NULL, 0x0,\r\n"Source or Destination Hardware Address", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_fddi,\r\n&ett_fddi_fc,\r\n};\r\nmodule_t *fddi_module;\r\nproto_fddi = proto_register_protocol("Fiber Distributed Data Interface",\r\n"FDDI", "fddi");\r\nproto_register_field_array(proto_fddi, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nfddi_handle = register_dissector("fddi", dissect_fddi_not_bitswapped, proto_fddi);\r\nfddi_bitswapped_handle = register_dissector("fddi_bitswapped", dissect_fddi_bitswapped, proto_fddi);\r\nfddi_module = prefs_register_protocol(proto_fddi, NULL);\r\nprefs_register_bool_preference(fddi_module, "padding",\r\n"Add 3-byte padding to all FDDI packets",\r\n"Whether the FDDI dissector should add 3-byte padding to all "\r\n"captured FDDI packets (useful with e.g. Tru64 UNIX tcpdump)",\r\n&fddi_padding);\r\nfddi_tap = register_tap("fddi");\r\nregister_conversation_table(proto_fddi, TRUE, fddi_conversation_packet, fddi_hostlist_packet);\r\n}\r\nvoid\r\nproto_reg_handoff_fddi(void)\r\n{\r\nllc_handle = find_dissector_add_dependency("llc", proto_fddi);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_FDDI_BITSWAPPED,\r\nfddi_bitswapped_handle);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_FDDI, capture_fddi, proto_fddi);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_FDDI_BITSWAPPED, capture_fddi, proto_fddi);\r\n}
