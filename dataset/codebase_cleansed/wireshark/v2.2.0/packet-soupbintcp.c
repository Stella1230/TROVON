static void\r\nformat_packet_type(\r\ngchar *buf,\r\nguint32 value)\r\n{\r\ngchar* tmp_str;\r\ntmp_str = val_to_str_wmem(NULL, value, pkt_type_val, "Unknown packet");\r\ng_snprintf(buf, ITEM_LABEL_LENGTH,\r\n"%s (%c)", tmp_str, (char)(value & 0xff));\r\nwmem_free(NULL, tmp_str);\r\n}\r\nstatic void\r\nformat_reject_code(\r\ngchar *buf,\r\nguint32 value)\r\n{\r\ngchar* tmp_str;\r\ntmp_str = val_to_str_wmem(NULL, value, reject_code_val, "Unknown reject code");\r\ng_snprintf(buf, ITEM_LABEL_LENGTH,\r\n"%s (%c)", tmp_str, (char)(value & 0xff));\r\nwmem_free(NULL, tmp_str);\r\n}\r\nstatic void\r\ndissect_soupbintcp_common(\r\ntvbuff_t *tvb,\r\npacket_info *pinfo,\r\nproto_tree *tree)\r\n{\r\nstruct conv_data *conv_data;\r\nstruct pdu_data *pdu_data;\r\nconst char *pkt_name;\r\nconst char *tmp_buf;\r\nproto_item *ti;\r\nproto_tree *soupbintcp_tree = NULL;\r\nconversation_t *conv = NULL;\r\nguint16 expected_len;\r\nguint8 pkt_type;\r\ngint offset = 0;\r\nguint this_seq = 0, next_seq, key;\r\nheur_dtbl_entry_t *hdtbl_entry;\r\nkey = (guint)tvb_raw_offset(tvb);\r\nexpected_len = tvb_get_ntohs(tvb, 0);\r\npkt_type = tvb_get_guint8(tvb, 2);\r\npkt_name = val_to_str(pkt_type, pkt_type_val, "Unknown (%u)");\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "SoupBinTCP");\r\ncol_add_str(pinfo->cinfo, COL_INFO, pkt_name);\r\nif (pkt_type == 'A' && !PINFO_FD_VISITED(pinfo)) {\r\ntmp_buf = tvb_get_string_enc(wmem_packet_scope(), tvb, 13, 20, ENC_ASCII);\r\nnext_seq = atoi(tmp_buf);\r\nconv = conversation_new(pinfo->num,\r\n&pinfo->src,\r\n&pinfo->dst,\r\npinfo->ptype,\r\npinfo->srcport,\r\npinfo->destport,\r\n0);\r\nconv_data = (struct conv_data *)wmem_alloc(wmem_file_scope(), sizeof(struct conv_data));\r\nconv_data->next_seq = next_seq;\r\nconversation_add_proto_data(conv, proto_soupbintcp, conv_data);\r\n}\r\nif (pkt_type == 'S') {\r\nif (!PINFO_FD_VISITED(pinfo)) {\r\nconv = find_conversation(pinfo->num,\r\n&pinfo->src,\r\n&pinfo->dst,\r\npinfo->ptype,\r\npinfo->srcport,\r\npinfo->destport,\r\n0);\r\nif (!conv) {\r\nthis_seq = 0;\r\n} else {\r\nconv_data = (struct conv_data *)conversation_get_proto_data(conv,\r\nproto_soupbintcp);\r\nif (conv_data) {\r\nthis_seq = conv_data->next_seq++;\r\n} else {\r\nthis_seq = 0;\r\n}\r\npdu_data = (struct pdu_data *)wmem_alloc(\r\nwmem_file_scope(),\r\nsizeof(struct pdu_data));\r\npdu_data->seq_num = this_seq;\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_soupbintcp, key, pdu_data);\r\n}\r\n} else {\r\npdu_data = (struct pdu_data *)p_get_proto_data(wmem_file_scope(), pinfo, proto_soupbintcp, key);\r\nif (pdu_data) {\r\nthis_seq = pdu_data->seq_num;\r\n} else {\r\nthis_seq = 0;\r\n}\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", SeqNum = %u", this_seq);\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item(tree,\r\nproto_soupbintcp,\r\ntvb, 0, -1, ENC_NA);\r\nsoupbintcp_tree = proto_item_add_subtree(ti, ett_soupbintcp);\r\nproto_item_append_text(ti, ", %s", pkt_name);\r\nproto_tree_add_item(soupbintcp_tree,\r\nhf_soupbintcp_packet_length,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(soupbintcp_tree,\r\nhf_soupbintcp_packet_type,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nswitch (pkt_type) {\r\ncase '+':\r\nproto_tree_add_item(soupbintcp_tree,\r\nhf_soupbintcp_text,\r\ntvb, offset, expected_len - 1, ENC_ASCII|ENC_NA);\r\nbreak;\r\ncase 'A':\r\nproto_tree_add_item(soupbintcp_tree,\r\nhf_soupbintcp_session,\r\ntvb, offset, 10, ENC_ASCII|ENC_NA);\r\noffset += 10;\r\ntmp_buf = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, 20, ENC_ASCII);\r\nproto_tree_add_string_format_value(soupbintcp_tree,\r\nhf_soupbintcp_next_seq_num,\r\ntvb, offset, 20,\r\n"X", "%d", atoi(tmp_buf));\r\nbreak;\r\ncase 'J':\r\nproto_tree_add_item(soupbintcp_tree,\r\nhf_soupbintcp_reject_code,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase 'U':\r\nbreak;\r\ncase 'S':\r\nproto_item_append_text(ti, ", SeqNum=%u", this_seq);\r\nproto_tree_add_string_format_value(soupbintcp_tree,\r\nhf_soupbintcp_seq_num,\r\ntvb, offset, 0,\r\n"X",\r\n"%u (Calculated)",\r\nthis_seq);\r\nbreak;\r\ncase 'L':\r\nproto_tree_add_item(soupbintcp_tree,\r\nhf_soupbintcp_username,\r\ntvb, offset, 6, ENC_ASCII|ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(soupbintcp_tree,\r\nhf_soupbintcp_password,\r\ntvb, offset, 10, ENC_ASCII|ENC_NA);\r\noffset += 10;\r\nproto_tree_add_item(soupbintcp_tree,\r\nhf_soupbintcp_session,\r\ntvb, offset, 10, ENC_ASCII|ENC_NA);\r\noffset += 10;\r\ntmp_buf = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, 20, ENC_ASCII);\r\nproto_tree_add_string_format_value(soupbintcp_tree,\r\nhf_soupbintcp_req_seq_num,\r\ntvb, offset, 20,\r\n"X", "%d", atoi(tmp_buf));\r\nbreak;\r\ncase 'H':\r\nbreak;\r\ncase 'O':\r\nbreak;\r\ncase 'R':\r\nbreak;\r\ncase 'Z':\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree,\r\nhf_soupbintcp_message,\r\ntvb, offset, -1, ENC_NA);\r\nbreak;\r\n}\r\n}\r\nif (pkt_type == 'S' || pkt_type == 'U') {\r\ntvbuff_t *sub_tvb;\r\nsub_tvb = tvb_new_subset_remaining(tvb, 3);\r\n#if 0\r\nif (try_conversation_dissector(&pinfo->dst, &pinfo->src, pinfo->ptype,\r\npinfo->srcport, pinfo->destport,\r\nsub_tvb, pinfo, tree, NULL)) {\r\nreturn;\r\n}\r\n#endif\r\nif (dissector_try_heuristic(heur_subdissector_list,\r\nsub_tvb,\r\npinfo,\r\ntree,\r\n&hdtbl_entry,\r\nNULL)) {\r\nreturn;\r\n}\r\nif (tree) {\r\nproto_tree_add_item(soupbintcp_tree,\r\nhf_soupbintcp_message,\r\nsub_tvb, 0, -1,\r\nENC_NA);\r\n}\r\n}\r\n}\r\nstatic guint\r\nget_soupbintcp_pdu_len(\r\npacket_info *pinfo _U_,\r\ntvbuff_t *tvb,\r\nint offset,\r\nvoid *data _U_)\r\n{\r\nreturn (guint)tvb_get_ntohs(tvb, offset) + 2;\r\n}\r\nstatic int\r\ndissect_soupbintcp_tcp_pdu(\r\ntvbuff_t *tvb,\r\npacket_info *pinfo,\r\nproto_tree *tree,\r\nvoid *data _U_)\r\n{\r\ndissect_soupbintcp_common(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_soupbintcp_tcp(\r\ntvbuff_t *tvb,\r\npacket_info *pinfo,\r\nproto_tree *tree,\r\nvoid *data)\r\n{\r\ntcp_dissect_pdus(tvb, pinfo, tree,\r\nsoupbintcp_desegment, 2,\r\nget_soupbintcp_pdu_len,\r\ndissect_soupbintcp_tcp_pdu, data);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\nsoupbintcp_prefs(void)\r\n{\r\ndissector_delete_uint_range("tcp.port", soupbintcp_range, soupbintcp_handle);\r\ng_free(soupbintcp_range);\r\nsoupbintcp_range = range_copy(global_soupbintcp_range);\r\ndissector_add_uint_range("tcp.port", soupbintcp_range, soupbintcp_handle);\r\n}\r\nvoid\r\nproto_register_soupbintcp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_soupbintcp_packet_length,\r\n{ "Packet Length", "soupbintcp.packet_length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Packet length, in bytes, NOT including these two bytes.",\r\nHFILL }},\r\n{ &hf_soupbintcp_packet_type,\r\n{ "Packet Type", "soupbintcp.packet_type",\r\nFT_UINT8, BASE_CUSTOM, CF_FUNC(format_packet_type), 0x0,\r\n"Message type code",\r\nHFILL }},\r\n{ &hf_soupbintcp_reject_code,\r\n{ "Login Reject Code", "soupbintcp.reject_code",\r\nFT_UINT8, BASE_CUSTOM, CF_FUNC(format_reject_code), 0x0,\r\n"Login reject reason code",\r\nHFILL }},\r\n{ &hf_soupbintcp_message,\r\n{ "Message", "soupbintcp.message",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Content of SoupBinTCP frame",\r\nHFILL }},\r\n{ &hf_soupbintcp_text,\r\n{ "Debug Text", "soupbintcp.text",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Free-form, human-readable text",\r\nHFILL }},\r\n{ &hf_soupbintcp_username,\r\n{ "User Name", "soupbintcp.username",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"User's login name",\r\nHFILL }},\r\n{ &hf_soupbintcp_password,\r\n{ "Password", "soupbintcp.password",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"User's login password",\r\nHFILL }},\r\n{ &hf_soupbintcp_session,\r\n{ "Session", "soupbintcp.session",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Session identifier, or send all spaces to log into the currently "\r\n"active session",\r\nHFILL }},\r\n{ &hf_soupbintcp_seq_num,\r\n{ "Sequence number", "soupbintcp.seq_num",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Calculated sequence number for this message",\r\nHFILL }},\r\n{ &hf_soupbintcp_next_seq_num,\r\n{ "Next sequence number", "soupbintcp.next_seq_num",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Sequence number of next Sequenced Data message to be delivered",\r\nHFILL }},\r\n{ &hf_soupbintcp_req_seq_num,\r\n{ "Requested sequence number", "soupbintcp.req_seq_num",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Request to begin (re)transmission of Sequenced Data at this "\r\n"sequence number, or, if zero, to begin transmission with the "\r\n"next message generated",\r\nHFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_soupbintcp\r\n};\r\nmodule_t *soupbintcp_module;\r\nproto_soupbintcp\r\n= proto_register_protocol("SoupBinTCP", "SoupBinTCP", "soupbintcp");\r\nproto_register_field_array(proto_soupbintcp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nsoupbintcp_module\r\n= prefs_register_protocol(proto_soupbintcp,\r\nsoupbintcp_prefs);\r\nprefs_register_bool_preference(\r\nsoupbintcp_module,\r\n"desegment",\r\n"Reassemble SoupBinTCP messages spanning multiple TCP segments",\r\n"Whether the SoupBinTCP dissector should reassemble messages "\r\n"spanning multiple TCP segments.",\r\n&soupbintcp_desegment);\r\nprefs_register_range_preference(\r\nsoupbintcp_module,\r\n"tcp.port",\r\n"TCP Ports",\r\n"TCP Ports range",\r\n&global_soupbintcp_range,\r\n65535);\r\nsoupbintcp_range = range_empty();\r\nheur_subdissector_list = register_heur_dissector_list("soupbintcp", proto_soupbintcp);\r\n}\r\nvoid\r\nproto_reg_handoff_soupbintcp(void)\r\n{\r\nsoupbintcp_handle = create_dissector_handle(dissect_soupbintcp_tcp,\r\nproto_soupbintcp);\r\ndissector_add_for_decode_as("tcp.port", soupbintcp_handle);\r\n}
