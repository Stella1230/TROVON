GList * current_profile_list(void) {\r\nreturn g_list_first(current_profiles);\r\n}\r\nGList * edited_profile_list(void) {\r\nreturn g_list_first(edited_profiles);\r\n}\r\nstatic GList *\r\nadd_profile_entry(GList *fl, const char *profilename, const char *reference, int status,\r\ngboolean is_global, gboolean from_global)\r\n{\r\nprofile_def *profile;\r\nprofile = (profile_def *) g_malloc0(sizeof(profile_def));\r\nprofile->name = g_strdup(profilename);\r\nprofile->reference = g_strdup(reference);\r\nprofile->status = status;\r\nprofile->is_global = is_global;\r\nprofile->from_global = from_global;\r\nreturn g_list_append(fl, profile);\r\n}\r\nstatic GList *\r\nremove_profile_entry(GList *fl, GList *fl_entry)\r\n{\r\nprofile_def *profile;\r\nprofile = (profile_def *) fl_entry->data;\r\ng_free(profile->name);\r\ng_free(profile->reference);\r\ng_free(profile);\r\nreturn g_list_remove_link(fl, fl_entry);\r\n}\r\nconst gchar *\r\nget_profile_parent (const gchar *profilename)\r\n{\r\nGList *fl_entry = g_list_first(edited_profiles);\r\nguint no_edited = g_list_length(edited_profiles);\r\nprofile_def *profile;\r\nguint i;\r\nif (fl_entry) {\r\nfor (i = 0; i < no_edited; i++) {\r\nwhile (fl_entry) {\r\nprofile = (profile_def *) fl_entry->data;\r\nif (strcmp (profile->name, profilename) == 0) {\r\nif ((profile->status == PROF_STAT_NEW) ||\r\n(profile->reference == NULL)) {\r\nreturn NULL;\r\n} else {\r\nprofilename = profile->reference;\r\n}\r\n}\r\nfl_entry = g_list_next(fl_entry);\r\n}\r\nfl_entry = g_list_first(edited_profiles);\r\n}\r\n}\r\nreturn profilename;\r\n}\r\nconst gchar *apply_profile_changes(void) {\r\nchar *pf_dir_path, *pf_dir_path2, *pf_filename;\r\nGList *fl1, *fl2;\r\nprofile_def *profile1, *profile2;\r\ngboolean found;\r\nconst gchar *err_msg;\r\nfl1 = edited_profile_list();\r\nwhile (fl1) {\r\nprofile1 = (profile_def *) fl1->data;\r\ng_strstrip(profile1->name);\r\nif ((err_msg = profile_name_is_valid(profile1->name)) != NULL) {\r\nreturn err_msg;\r\n}\r\nfl1 = g_list_next(fl1);\r\n}\r\nfl1 = edited_profile_list();\r\nwhile (fl1) {\r\nprofile1 = (profile_def *) fl1->data;\r\ng_strstrip(profile1->name);\r\nif (profile1->status == PROF_STAT_COPY) {\r\nif (create_persconffile_profile(profile1->name, &pf_dir_path) == -1) {\r\nerr_msg = g_strdup_printf("Can't create directory\n\"%s\":\n%s.",\r\npf_dir_path, g_strerror(errno));\r\ng_free(pf_dir_path);\r\nreturn err_msg;\r\n}\r\nprofile1->status = PROF_STAT_EXISTS;\r\nif (profile1->reference) {\r\nif (copy_persconffile_profile(profile1->name, profile1->reference, profile1->from_global,\r\n&pf_filename, &pf_dir_path, &pf_dir_path2) == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't copy file \"%s\" in directory\n\"%s\" to\n\"%s\":\n%s.",\r\npf_filename, pf_dir_path2, pf_dir_path, g_strerror(errno));\r\ng_free(pf_filename);\r\ng_free(pf_dir_path);\r\ng_free(pf_dir_path2);\r\n}\r\n}\r\ng_free (profile1->reference);\r\nprofile1->reference = g_strdup(profile1->name);\r\n}\r\nfl1 = g_list_next(fl1);\r\n}\r\nfl1 = edited_profile_list();\r\nwhile (fl1) {\r\nprofile1 = (profile_def *) fl1->data;\r\ng_strstrip(profile1->name);\r\nif (profile1->status == PROF_STAT_NEW) {\r\nif (strcmp(profile1->name, DEFAULT_PROFILE)!=0) {\r\nif (create_persconffile_profile(profile1->name, &pf_dir_path) == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't create directory\n\"%s\":\n%s.",\r\npf_dir_path, g_strerror(errno));\r\ng_free(pf_dir_path);\r\n}\r\nprofile1->status = PROF_STAT_EXISTS;\r\ng_free (profile1->reference);\r\nprofile1->reference = g_strdup(profile1->name);\r\n}\r\n} else if (profile1->status == PROF_STAT_CHANGED) {\r\nif (strcmp(profile1->reference, profile1->name)!=0) {\r\nif (rename_persconffile_profile(profile1->reference, profile1->name,\r\n&pf_dir_path, &pf_dir_path2) == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't rename directory\n\"%s\" to\n\"%s\":\n%s.",\r\npf_dir_path, pf_dir_path2, g_strerror(errno));\r\ng_free(pf_dir_path);\r\ng_free(pf_dir_path2);\r\n}\r\nprofile1->status = PROF_STAT_EXISTS;\r\ng_free (profile1->reference);\r\nprofile1->reference = g_strdup(profile1->name);\r\n}\r\n}\r\nfl1 = g_list_next(fl1);\r\n}\r\nfl1 = current_profile_list();\r\nwhile (fl1) {\r\nfound = FALSE;\r\nprofile1 = (profile_def *) fl1->data;\r\nfl2 = edited_profile_list();\r\nwhile (fl2) {\r\nprofile2 = (profile_def *) fl2->data;\r\nif (!profile2->is_global) {\r\nif (strcmp(profile1->name, profile2->name)==0) {\r\nfound = TRUE;\r\n} else if (strcmp(profile1->name, profile2->reference)==0) {\r\nfound = TRUE;\r\n}\r\n}\r\nfl2 = g_list_next(fl2);\r\n}\r\nif (!found) {\r\nif (delete_persconffile_profile(profile1->name, &pf_dir_path) == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't delete profile directory\n\"%s\":\n%s.",\r\npf_dir_path, g_strerror(errno));\r\ng_free(pf_dir_path);\r\n}\r\n}\r\nfl1 = g_list_next(fl1);\r\n}\r\ncopy_profile_list();\r\nreturn NULL;\r\n}\r\nGList *\r\nadd_to_profile_list(const char *name, const char *expression, int status,\r\ngboolean is_global, gboolean from_global)\r\n{\r\nedited_profiles = add_profile_entry(edited_profiles, name, expression, status,\r\nis_global, from_global);\r\nreturn g_list_last(edited_profiles);\r\n}\r\nvoid\r\nremove_from_profile_list(GList *fl_entry)\r\n{\r\nedited_profiles = remove_profile_entry(edited_profiles, fl_entry);\r\n}\r\nvoid\r\nempty_profile_list(gboolean edit_list)\r\n{\r\nGList **flpp;\r\nif (edit_list) {\r\nflpp = &edited_profiles;\r\nwhile(*flpp) {\r\n*flpp = remove_profile_entry(*flpp, g_list_first(*flpp));\r\n}\r\ng_assert(g_list_length(*flpp) == 0);\r\n}\r\nflpp = &current_profiles;\r\nwhile(*flpp) {\r\n*flpp = remove_profile_entry(*flpp, g_list_first(*flpp));\r\n}\r\ng_assert(g_list_length(*flpp) == 0);\r\n}\r\nvoid\r\ncopy_profile_list(void)\r\n{\r\nGList *flp_src;\r\nprofile_def *profile;\r\nflp_src = edited_profiles;\r\nempty_profile_list(FALSE);\r\nwhile(flp_src) {\r\nprofile = (profile_def *)(flp_src)->data;\r\ncurrent_profiles = add_profile_entry(current_profiles, profile->name,\r\nprofile->reference, profile->status,\r\nprofile->is_global, profile->from_global);\r\nflp_src = g_list_next(flp_src);\r\n}\r\n}\r\nvoid\r\ninit_profile_list(void)\r\n{\r\nWS_DIR *dir;\r\nWS_DIRENT *file;\r\nconst gchar *profiles_dir, *name;\r\ngchar *filename;\r\nempty_profile_list(TRUE);\r\nadd_to_profile_list(DEFAULT_PROFILE, DEFAULT_PROFILE, PROF_STAT_DEFAULT, FALSE, FALSE);\r\nprofiles_dir = get_profiles_dir();\r\nif ((dir = ws_dir_open(profiles_dir, 0, NULL)) != NULL) {\r\nwhile ((file = ws_dir_read_name(dir)) != NULL) {\r\nname = ws_dir_get_name(file);\r\nfilename = g_strdup_printf ("%s%s%s", profiles_dir, G_DIR_SEPARATOR_S, name);\r\nif (test_for_directory(filename) == EISDIR) {\r\nadd_to_profile_list(name, name, PROF_STAT_EXISTS, FALSE, FALSE);\r\n}\r\ng_free (filename);\r\n}\r\nws_dir_close (dir);\r\n}\r\nprofiles_dir = get_global_profiles_dir();\r\nif ((dir = ws_dir_open(profiles_dir, 0, NULL)) != NULL) {\r\nwhile ((file = ws_dir_read_name(dir)) != NULL) {\r\nname = ws_dir_get_name(file);\r\nfilename = g_strdup_printf ("%s%s%s", profiles_dir, G_DIR_SEPARATOR_S, name);\r\nif (test_for_directory(filename) == EISDIR) {\r\nadd_to_profile_list(name, name, PROF_STAT_EXISTS, TRUE, TRUE);\r\n}\r\ng_free (filename);\r\n}\r\nws_dir_close (dir);\r\n}\r\ncopy_profile_list ();\r\n}\r\ngchar *\r\nprofile_name_is_valid(const gchar *name)\r\n{\r\ngchar *reason = NULL;\r\ngchar *message;\r\n#ifdef _WIN32\r\nchar *invalid_dir_char = "\\/:*?\"<>|";\r\ngboolean invalid = FALSE;\r\nint i;\r\nfor (i = 0; i < 9; i++) {\r\nif (strchr(name, invalid_dir_char[i])) {\r\ninvalid = TRUE;\r\n}\r\n}\r\nif (name[0] == '.' || name[strlen(name)-1] == '.') {\r\ninvalid = TRUE;\r\n}\r\nif (invalid) {\r\nreason = g_strdup_printf("start or end with period (.), or contain any of the following characters:\n"\r\n" \\ / : * ? \" &lt; &gt; |");\r\n}\r\n#else\r\nif (strchr(name, '/')) {\r\nreason = g_strdup_printf("contain the '/' character.");\r\n}\r\n#endif\r\nif (reason) {\r\nmessage = g_strdup_printf("A profile name cannot %s\nProfiles unchanged.", reason);\r\ng_free(reason);\r\nreturn message;\r\n}\r\nreturn NULL;\r\n}\r\ngboolean delete_current_profile(void) {\r\nconst gchar *name = get_profile_name();\r\nchar *pf_dir_path;\r\nif (profile_exists(name, FALSE) && strcmp (name, DEFAULT_PROFILE) != 0) {\r\nif (delete_persconffile_profile(name, &pf_dir_path) == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't delete profile directory\n\"%s\":\n%s.",\r\npf_dir_path, g_strerror(errno));\r\ng_free(pf_dir_path);\r\n} else {\r\nreturn TRUE;\r\n}\r\n}\r\nreturn FALSE;\r\n}
