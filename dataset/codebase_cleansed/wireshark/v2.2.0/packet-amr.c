static int\r\ndissect_amr_nb_if1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nint offset = 0;\r\nguint8 octet;\r\nproto_item *ti;\r\nproto_tree_add_item(tree, hf_amr_nb_if1_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_amr_if1_fqi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noctet = (tvb_get_guint8(tvb,offset) & 0xf0) >> 4;\r\nif (octet == AMR_NB_SID) {\r\nti = proto_tree_add_item(tree, hf_amr_nb_if1_mode_req, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nif (tvb_get_guint8(tvb,offset+1) & 0x1f)\r\nexpert_add_info(pinfo, ti, &ei_amr_spare_bit_not0);\r\nproto_tree_add_item(tree, hf_amr_speech_data, tvb, offset+2, 5, ENC_NA);\r\nproto_tree_add_item(tree, hf_amr_if1_sti, tvb, offset+7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_amr_nb_if1_sti_mode_ind, tvb, offset+7, 1, ENC_BIG_ENDIAN);\r\nreturn offset+8;\r\n}\r\nproto_tree_add_item(tree, hf_amr_nb_if1_mode_ind, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nti = proto_tree_add_item(tree, hf_amr_nb_if1_mode_req, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (tvb_get_guint8(tvb,offset) & 0x1f)\r\nexpert_add_info(pinfo, ti, &ei_amr_spare_bit_not0);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_amr_speech_data, tvb, offset, -1, ENC_NA);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_amr_wb_if1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nint offset = 0;\r\nguint8 octet;\r\nproto_item *ti;\r\nproto_tree_add_item(tree, hf_amr_wb_if1_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nti = proto_tree_add_item(tree, hf_amr_if1_fqi, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif (tvb_get_guint8(tvb,offset) & 0x03)\r\nexpert_add_info(pinfo, ti, &ei_amr_spare_bit_not0);\r\noctet = (tvb_get_guint8(tvb,offset) & 0xf0) >> 4;\r\nif (octet == AMR_WB_SID) {\r\nproto_tree_add_item(tree, hf_amr_wb_if1_mode_req, tvb, offset+1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_amr_speech_data, tvb, offset+2, 4, ENC_NA);\r\nproto_tree_add_item(tree, hf_amr_if1_sti, tvb, offset+7, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_amr_wb_if1_sti_mode_ind, tvb, offset+7, 1, ENC_BIG_ENDIAN);\r\nreturn offset+8;\r\n}\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_amr_wb_if1_mode_ind, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_amr_wb_if1_mode_req, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_amr_speech_data, tvb, offset, -1, ENC_NA);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_amr_nb_if2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nint offset = 0;\r\nguint8 octet;\r\nproto_tree_add_item(tree, hf_amr_nb_if2_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noctet = tvb_get_guint8(tvb,offset) & 0x0f;\r\nif (octet == AMR_NB_SID) {\r\nproto_tree_add_item(tree, hf_amr_speech_data, tvb, offset+1, 3, ENC_NA);\r\nproto_tree_add_item(tree, hf_amr_if2_sti, tvb, offset+4, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_amr_nb_if2_sti_mode_ind, tvb, offset+5, 1, ENC_BIG_ENDIAN);\r\nreturn offset+6;\r\n}\r\nif (octet == AMR_NO_TRANS)\r\nreturn 1;\r\nproto_tree_add_item(tree, hf_amr_speech_data, tvb, offset+1, -1, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ",\r\nval_to_str_ext(octet, &amr_nb_codec_mode_request_vals_ext, "Unknown (%d)" ));\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_amr_wb_if2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) {\r\nint offset = 0;\r\nguint8 octet;\r\nproto_tree_add_item(tree, hf_amr_wb_if2_ft, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noctet = (tvb_get_guint8(tvb,offset) & 0xf0) >> 4;\r\nif (octet == AMR_WB_SID) {\r\nproto_tree_add_item(tree, hf_amr_speech_data, tvb, offset+1, 4, ENC_NA);\r\nproto_tree_add_item(tree, hf_amr_if2_sti, tvb, offset+5, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_amr_wb_if2_sti_mode_ind, tvb, offset+5, 1, ENC_BIG_ENDIAN);\r\nreturn offset+6;\r\n}\r\nif (octet == AMR_NO_TRANS)\r\nreturn 1;\r\nproto_tree_add_item(tree, hf_amr_speech_data, tvb, offset+1, -1, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ",\r\nval_to_str_ext(octet, &amr_wb_codec_mode_request_vals_ext, "Unknown (%d)" ));\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_amr_be(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint amr_mode) {\r\nproto_item *item;\r\nint ft;\r\nint bit_offset = 0;\r\nint bitcount;\r\nint bits_used_for_frames = 0;\r\nint bytes_needed_for_frames;\r\nguint8 f_bit, q_bit;\r\nunsigned char Framebits_NB[] = {95,103,118,134,148,159,204,244,39,43,38,37, 0, 0, 0, 0};\r\nunsigned int Framebits_WB[] = {132,177,253,285,317,365,397,461,477, 40, 0, 0, 0, 0, 0, 0,};\r\nbitcount = 3;\r\nif (amr_mode == AMR_NB)\r\nproto_tree_add_bits_item(tree, hf_amr_nb_cmr, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nelse\r\nproto_tree_add_bits_item(tree, hf_amr_wb_cmr, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nbit_offset += 4;\r\ndo {\r\nbitcount += 1;\r\nf_bit = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_amr_toc_f, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset += 1;\r\nft = tvb_get_bits8(tvb, bit_offset, 4);\r\nif (amr_mode == AMR_NB)\r\nitem = proto_tree_add_bits_item(tree, hf_amr_nb_toc_ft, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nelse\r\nitem = proto_tree_add_bits_item(tree, hf_amr_wb_toc_ft, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nbit_offset += 4;\r\nbitcount += 4;\r\nif (amr_mode == AMR_NB)\r\nbits_used_for_frames += Framebits_NB[ft];\r\nelse\r\nbits_used_for_frames += Framebits_WB[ft];\r\nq_bit = tvb_get_bits8(tvb, bit_offset, 1);\r\nproto_tree_add_bits_item(tree, hf_amr_toc_q, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset += 1;\r\nbitcount += 1;\r\nif (q_bit == 1)\r\nproto_item_append_text(item, " / Frame OK");\r\nelse\r\nproto_item_append_text(item, " / Frame damaged");\r\n} while ((f_bit == 1) && (tvb_reported_length_remaining(tvb, bitcount/8) > 2));\r\nif (bits_used_for_frames > 0)\r\nbytes_needed_for_frames = 1 + (bitcount+bits_used_for_frames)/8-bitcount/8;\r\nelse\r\nbytes_needed_for_frames = 0;\r\nif (tvb_reported_length_remaining(tvb, bitcount/8) < bytes_needed_for_frames) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_amr_not_enough_data_for_frames,\r\ntvb, bitcount/8, bytes_needed_for_frames,\r\n"Error: %d Bytes available, %d would be needed!",\r\ntvb_reported_length_remaining(tvb, bitcount/8),\r\nbytes_needed_for_frames);\r\n}\r\nelse {\r\nproto_tree_add_item(tree, hf_amr_frame_data, tvb, bitcount/8, bytes_needed_for_frames, ENC_NA);\r\n}\r\nbitcount += bits_used_for_frames;\r\nif (tvb_reported_length_remaining(tvb, (bitcount+8)/8) > 0) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_amr_superfluous_data, tvb, bitcount/8, tvb_reported_length_remaining(tvb, bitcount/8),\r\n"Error: %d Bytes remaining - should be 0!",tvb_reported_length_remaining(tvb, (bitcount+8)/8));\r\nif (bitcount%8 != 0) {\r\nif ( (1 << (8 -(bitcount%8)-1)) & tvb_get_guint8(tvb,bitcount/8) )\r\nproto_tree_add_expert(tree, pinfo, &ei_amr_padding_bits_correct, tvb, bitcount/8, 1);\r\nelse {\r\nproto_tree_add_expert(tree, pinfo, &ei_amr_padding_bits_not0, tvb,\r\nbitcount/8, 1);\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_amr_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint amr_mode)\r\n{\r\nint offset = 0;\r\nint bit_offset = 0;\r\nguint8 octet;\r\nproto_item *item;\r\ngboolean first_time;\r\nproto_item *ti;\r\nproto_tree *amr_tree, *toc_tree;\r\nti = proto_tree_add_item(tree, proto_amr, tvb, 0, -1, ENC_NA);\r\namr_tree = proto_item_add_subtree(ti, ett_amr);\r\nitem = proto_tree_add_uint(amr_tree, hf_amr_payload_decoded_as, tvb, offset, 4, amr_encoding_type);\r\nproto_item_set_len(item, tvb_reported_length(tvb));\r\nPROTO_ITEM_SET_GENERATED(item);\r\nswitch (amr_encoding_type) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ndissect_amr_be(tvb, pinfo, amr_tree, amr_mode);\r\nreturn;\r\ncase 2:\r\nif (amr_mode == AMR_NB)\r\ndissect_amr_nb_if1(tvb, pinfo, amr_tree, NULL);\r\nelse\r\ndissect_amr_wb_if1(tvb, pinfo, amr_tree, NULL);\r\nreturn;\r\ncase 3:\r\nif (amr_mode == AMR_NB)\r\ndissect_amr_nb_if2(tvb, pinfo, amr_tree, NULL);\r\nelse\r\ndissect_amr_wb_if2(tvb, pinfo, amr_tree, NULL);\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nif (amr_mode == AMR_NB)\r\nproto_tree_add_bits_item(amr_tree, hf_amr_nb_cmr, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nelse\r\nproto_tree_add_bits_item(amr_tree, hf_amr_wb_cmr, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nbit_offset += 4;\r\noctet = tvb_get_guint8(tvb,offset) & 0x0f;\r\nitem = proto_tree_add_item(amr_tree, hf_amr_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nif ( octet != 0 ) {\r\nexpert_add_info(pinfo, item, &ei_amr_reserved);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nreturn;\r\n}\r\noffset += 1;\r\nbit_offset += 4;\r\noctet = tvb_get_guint8(tvb,offset);\r\ntoc_tree = proto_tree_add_subtree(amr_tree, tvb, offset, -1, ett_amr_toc, NULL, "Payload Table of Contents");\r\nfirst_time = TRUE;\r\nwhile ((( octet& 0x80 ) == 0x80) || (first_time == TRUE)) {\r\nfirst_time = FALSE;\r\noctet = tvb_get_guint8(tvb,offset);\r\nproto_tree_add_bits_item(toc_tree, hf_amr_toc_f, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset += 1;\r\nif (amr_mode == AMR_NB)\r\nproto_tree_add_bits_item(toc_tree, hf_amr_nb_toc_ft, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nelse\r\nproto_tree_add_bits_item(toc_tree, hf_amr_wb_toc_ft, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\nbit_offset += 4;\r\nproto_tree_add_bits_item(toc_tree, hf_amr_toc_q, tvb, bit_offset, 1, ENC_BIG_ENDIAN);\r\nbit_offset += 1;\r\nbit_offset += 2;\r\noffset += 1;\r\n}\r\n}\r\nstatic int\r\ndissect_amr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "AMR");\r\ndissect_amr_common(tvb, pinfo, tree, pref_amr_mode);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_amr_wb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "AMR-WB");\r\ndissect_amr_common(tvb, pinfo, tree, AMR_WB);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic amr_capability_t *find_cap(const gchar *id) {\r\namr_capability_t *ftr = NULL;\r\namr_capability_t *f;\r\nfor (f=amr_capability_tab; f->id; f++) {\r\nif (!strcmp(id, f->id)) {\r\nftr = f;\r\nbreak;\r\n}\r\n}\r\nreturn ftr;\r\n}\r\nstatic int\r\ndissect_amr_name(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nasn1_ctx_t *actx;\r\nif (data == NULL)\r\nreturn 0;\r\nactx = get_asn1_ctx(data);\r\nDISSECTOR_ASSERT(actx != NULL);\r\nif (tree && (actx != NULL)) {\r\namr_capability_t *ftr;\r\nftr = find_cap(pinfo->match_string);\r\nif (ftr) {\r\nproto_item_append_text(actx->created_item, " - %s", ftr->name);\r\nproto_item_append_text(proto_item_get_parent(proto_tree_get_parent(tree)), ": %s", ftr->name);\r\n} else {\r\nproto_item_append_text(actx->created_item, " - unknown(%s)", pinfo->match_string);\r\n}\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_amr(void)\r\n{\r\nmodule_t *amr_module;\r\nexpert_module_t* expert_amr;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_amr_nb_cmr,\r\n{ "CMR", "amr.nb.cmr",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_nb_codec_mode_request_vals_ext, 0x0,\r\n"codec mode request", HFILL }\r\n},\r\n{ &hf_amr_wb_cmr,\r\n{ "CMR", "amr.wb.cmr",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_wb_codec_mode_request_vals_ext, 0x0,\r\n"codec mode request", HFILL }\r\n},\r\n{ &hf_amr_reserved,\r\n{ "Reserved", "amr.reserved",\r\nFT_UINT8, BASE_DEC, NULL, 0x0f,\r\n"Reserved bits", HFILL }\r\n},\r\n{ &hf_amr_payload_decoded_as,\r\n{ "Payload decoded as", "amr.payload_decoded_as",\r\nFT_UINT32, BASE_DEC, VALS(amr_encoding_type_value), 0x0,\r\n"Value of decoding preference", HFILL }\r\n},\r\n{ &hf_amr_toc_f,\r\n{ "F bit", "amr.toc.f",\r\nFT_BOOLEAN, BASE_NONE, TFS(&toc_f_bit_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_nb_toc_ft,\r\n{ "FT bits", "amr.nb.toc.ft",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_nb_codec_mode_vals_ext, 0x0,\r\n"Frame type index", HFILL }\r\n},\r\n{ &hf_amr_wb_toc_ft,\r\n{ "FT bits", "amr.wb.toc.ft",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_wb_codec_mode_vals_ext, 0x0,\r\n"Frame type index", HFILL }\r\n},\r\n{ &hf_amr_toc_q,\r\n{ "Q bit", "amr.toc.q",\r\nFT_BOOLEAN, BASE_NONE, TFS(&toc_q_bit_vals), 0x0,\r\n"Frame quality indicator bit", HFILL }\r\n},\r\n{ &hf_amr_speech_data,\r\n{ "Speech data", "amr.speech_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_frame_data,\r\n{ "Frame Data", "amr.frame_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_nb_if1_ft,\r\n{ "Frame Type", "amr.nb.if1.ft",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_nb_codec_mode_vals_ext, 0xf0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_wb_if1_ft,\r\n{ "Frame Type", "amr.wb.if1.ft",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_wb_codec_mode_vals_ext, 0xf0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_nb_if1_mode_req,\r\n{ "Mode Type request", "amr.nb.if1.modereq",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_nb_codec_mode_request_vals_ext, 0xe0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_wb_if1_mode_req,\r\n{ "Mode Type request", "amr.wb.if1.modereq",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_wb_codec_mode_request_vals_ext, 0x0f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_if1_sti,\r\n{ "SID Type Indicator", "amr.if1.sti",\r\nFT_BOOLEAN, 8, TFS(&amr_sti_vals), 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_nb_if1_sti_mode_ind,\r\n{ "Mode Type indication", "amr.nb.if1.stimodeind",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_nb_codec_mode_vals_ext, 0x0e,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_wb_if1_sti_mode_ind,\r\n{ "Mode Type indication", "amr.wb.if1.stimodeind",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_wb_codec_mode_vals_ext, 0x0f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_nb_if1_mode_ind,\r\n{ "Mode Type indication", "amr.nb.if1.modeind",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_nb_codec_mode_vals_ext, 0x07,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_wb_if1_mode_ind,\r\n{ "Mode Type indication", "amr.wb.if1.modeind",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_wb_codec_mode_vals_ext, 0xf0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_nb_if2_ft,\r\n{ "Frame Type", "amr.nb.if2.ft",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_nb_codec_mode_vals_ext, 0x0f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_wb_if2_ft,\r\n{ "Frame Type", "amr.wb.if2.ft",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_wb_codec_mode_vals_ext, 0xf0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_if2_sti,\r\n{ "SID Type Indicator", "amr.if2.sti",\r\nFT_BOOLEAN, 8, TFS(&amr_sti_vals), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_nb_if2_sti_mode_ind,\r\n{ "Mode Type indication", "amr.nb.if2.stimodeind",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_nb_codec_mode_vals_ext, 0x07,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_wb_if2_sti_mode_ind,\r\n{ "Mode Type indication", "amr.wb.if2.stimodeind",\r\nFT_UINT8, BASE_DEC|BASE_EXT_STRING, &amr_wb_codec_mode_vals_ext, 0x78,\r\nNULL, HFILL }\r\n},\r\n{ &hf_amr_if1_fqi,\r\n{ "FQI", "amr.fqi",\r\nFT_BOOLEAN, 8, TFS(&toc_q_bit_vals), 0x08,\r\n"Frame quality indicator bit", HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_amr,\r\n&ett_amr_toc,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_amr_spare_bit_not0, { "amr.spare_bit_not0", PI_PROTOCOL, PI_WARN, "Error:Spare bits not 0", EXPFILL }},\r\n{ &ei_amr_not_enough_data_for_frames, { "amr.not_enough_data_for_frames", PI_MALFORMED, PI_ERROR, "Not enough data for the frames according to TOC", EXPFILL }},\r\n{ &ei_amr_superfluous_data, { "amr.superfluous_data", PI_MALFORMED, PI_ERROR, "Superfluous data remaining", EXPFILL }},\r\n{ &ei_amr_padding_bits_not0, { "amr.padding_bits_not0", PI_MALFORMED, PI_ERROR, "Padding bits error - MUST be 0", EXPFILL }},\r\n{ &ei_amr_padding_bits_correct, { "amr.padding_bits_correct", PI_PROTOCOL, PI_NOTE, "Padding bits correct", EXPFILL }},\r\n{ &ei_amr_reserved, { "amr.reserved.not_zero", PI_PROTOCOL, PI_WARN, "Reserved != 0, wrongly encoded or not octet aligned. Decoding as bandwidth-efficient mode", EXPFILL }},\r\n};\r\nstatic const enum_val_t encoding_types[] = {\r\n{"RFC 3267 Byte aligned", "RFC 3267 octet aligned", 0},\r\n{"RFC 3267 Bandwidth-efficient", "RFC 3267 BW-efficient", 1},\r\n{"AMR IF1", "AMR IF1", 2},\r\n{"AMR IF2", "AMR IF2", 3},\r\n{NULL, NULL, -1}\r\n};\r\nstatic const enum_val_t modes[] = {\r\n{"AMR-NB", "Narrowband AMR", AMR_NB},\r\n{"AMR-WB", "Wideband AMR", AMR_WB},\r\n{NULL, NULL, -1}\r\n};\r\nproto_amr = proto_register_protocol("Adaptive Multi-Rate","AMR", "amr");\r\nproto_register_field_array(proto_amr, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_amr = expert_register_protocol(proto_amr);\r\nexpert_register_field_array(expert_amr, ei, array_length(ei));\r\namr_module = prefs_register_protocol(proto_amr, proto_reg_handoff_amr);\r\nprefs_register_uint_preference(amr_module, "dynamic.payload.type",\r\n"AMR dynamic payload type",\r\n"The dynamic payload type which will be interpreted as AMR"\r\n"; The value must be greater than 95",\r\n10,\r\n&temp_dynamic_payload_type);\r\nprefs_register_enum_preference(amr_module, "encoding.version",\r\n"Type of AMR encoding of the payload",\r\n"Type of AMR encoding of the payload",\r\n&amr_encoding_type, encoding_types, FALSE);\r\nprefs_register_enum_preference(amr_module, "mode",\r\n"The AMR mode",\r\n"The AMR mode",\r\n&pref_amr_mode, modes, AMR_NB);\r\namr_handle = register_dissector("amr", dissect_amr, proto_amr);\r\namr_wb_handle = register_dissector("amr-wb", dissect_amr_wb, proto_amr);\r\nregister_dissector("amr_if1_nb", dissect_amr_nb_if1, proto_amr);\r\nregister_dissector("amr_if1_wb", dissect_amr_wb_if1, proto_amr);\r\nregister_dissector("amr_if2_nb", dissect_amr_nb_if2, proto_amr);\r\nregister_dissector("amr_if2_wb", dissect_amr_wb_if2, proto_amr);\r\noid_add_from_string("G.722.2 (AMR-WB) audio capability","0.0.7.7222.1.0");\r\n}\r\nvoid\r\nproto_reg_handoff_amr(void)\r\n{\r\nstatic guint dynamic_payload_type;\r\nstatic gboolean amr_prefs_initialized = FALSE;\r\nif (!amr_prefs_initialized) {\r\ndissector_handle_t amr_name_handle;\r\namr_capability_t *ftr;\r\ndissector_add_string("rtp_dyn_payload_type","AMR", amr_handle);\r\ndissector_add_string("rtp_dyn_payload_type","AMR-WB", amr_wb_handle);\r\namr_name_handle = create_dissector_handle(dissect_amr_name, proto_amr);\r\nfor (ftr=amr_capability_tab; ftr->id; ftr++) {\r\nif (ftr->name)\r\ndissector_add_string("h245.gef.name", ftr->id, amr_name_handle);\r\nif (ftr->content_pdu)\r\ndissector_add_string("h245.gef.content", ftr->id,\r\ncreate_dissector_handle(ftr->content_pdu, proto_amr));\r\n}\r\namr_prefs_initialized = TRUE;\r\n} else {\r\nif ( dynamic_payload_type > 95 )\r\ndissector_delete_uint("rtp.pt", dynamic_payload_type, amr_handle);\r\n}\r\ndynamic_payload_type = temp_dynamic_payload_type;\r\nif ( dynamic_payload_type > 95 ) {\r\ndissector_add_uint("rtp.pt", dynamic_payload_type, amr_handle);\r\n}\r\n}
