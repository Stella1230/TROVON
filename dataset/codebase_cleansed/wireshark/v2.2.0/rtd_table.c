int get_rtd_proto_id(register_rtd_t* rtd)\r\n{\r\nif (!rtd) {\r\nreturn -1;\r\n}\r\nreturn rtd->proto_id;\r\n}\r\nconst char* get_rtd_tap_listener_name(register_rtd_t* rtd)\r\n{\r\nreturn rtd->tap_listen_str;\r\n}\r\ntap_packet_cb get_rtd_packet_func(register_rtd_t* rtd)\r\n{\r\nreturn rtd->rtd_func;\r\n}\r\nguint get_rtd_num_tables(register_rtd_t* rtd) {\r\nreturn rtd->num_tables;\r\n}\r\nconst value_string* get_rtd_value_string(register_rtd_t* rtd)\r\n{\r\nreturn rtd->vs_type;\r\n}\r\nstatic gint\r\ninsert_sorted_by_table_name(gconstpointer aparam, gconstpointer bparam)\r\n{\r\nconst register_rtd_t *a = (const register_rtd_t *)aparam;\r\nconst register_rtd_t *b = (const register_rtd_t *)bparam;\r\nreturn g_ascii_strcasecmp(proto_get_protocol_short_name(find_protocol_by_id(a->proto_id)), proto_get_protocol_short_name(find_protocol_by_id(b->proto_id)));\r\n}\r\nvoid\r\nregister_rtd_table(const int proto_id, const char* tap_listener, guint num_tables, guint num_timestats, const value_string* vs_type,\r\ntap_packet_cb rtd_packet_func, rtd_filter_check_cb filter_check_cb)\r\n{\r\nregister_rtd_t *table;\r\nDISSECTOR_ASSERT(rtd_packet_func);\r\ntable = g_new(register_rtd_t,1);\r\ntable->proto_id = proto_id;\r\nif (tap_listener != NULL)\r\ntable->tap_listen_str = tap_listener;\r\nelse\r\ntable->tap_listen_str = proto_get_protocol_filter_name(proto_id);\r\ntable->rtd_func = rtd_packet_func;\r\ntable->num_tables = num_tables;\r\ntable->num_timestats = num_timestats;\r\ntable->vs_type = vs_type;\r\ntable->filter_check = filter_check_cb;\r\nregistered_rtd_tables = g_slist_insert_sorted(registered_rtd_tables, table, insert_sorted_by_table_name);\r\n}\r\nvoid free_rtd_table(rtd_stat_table* table, rtd_gui_free_cb gui_callback, void *callback_data)\r\n{\r\nguint i;\r\nfor (i = 0; i < table->num_rtds; i++)\r\n{\r\ng_free(table->time_stats[i].rtd);\r\n}\r\ng_free(table->time_stats);\r\ntable->time_stats = NULL;\r\ntable->num_rtds = 0;\r\nif (gui_callback)\r\ngui_callback(table, callback_data);\r\n}\r\nvoid reset_rtd_table(rtd_stat_table* table, rtd_gui_reset_cb gui_callback, void *callback_data)\r\n{\r\nguint i = 0;\r\nfor (i = 0; i < table->num_rtds; i++)\r\nmemset(table->time_stats[i].rtd, 0, sizeof(timestat_t)*table->time_stats[i].num_timestat);\r\nif (gui_callback)\r\ngui_callback(table, callback_data);\r\n}\r\nregister_rtd_t* get_rtd_table_by_name(const char* name)\r\n{\r\nguint i, size = g_slist_length(registered_rtd_tables);\r\nregister_rtd_t* rtd;\r\nGSList *slist;\r\nfor (i = 0; i < size; i++) {\r\nslist = g_slist_nth(registered_rtd_tables, i);\r\nrtd = (register_rtd_t*)slist->data;\r\nif (strcmp(name, proto_get_protocol_filter_name(rtd->proto_id)) == 0)\r\nreturn rtd;\r\n}\r\nreturn NULL;\r\n}\r\ngchar* rtd_table_get_tap_string(register_rtd_t* rtd)\r\n{\r\nGString *cmd_str = g_string_new(proto_get_protocol_filter_name(rtd->proto_id));\r\ng_string_append(cmd_str, ",rtd");\r\nreturn g_string_free(cmd_str, FALSE);\r\n}\r\nvoid rtd_table_get_filter(register_rtd_t* rtd, const char *opt_arg, const char **filter, char** err)\r\n{\r\ngchar* cmd_str = rtd_table_get_tap_string(rtd);\r\nguint len = (guint) strlen(cmd_str);\r\n*filter=NULL;\r\n*err=NULL;\r\nif (!strncmp(opt_arg, cmd_str, len))\r\n{\r\nif (opt_arg[len] == ',')\r\n{\r\n*filter = opt_arg + len+1;\r\n}\r\n}\r\nif (rtd->filter_check)\r\nrtd->filter_check(opt_arg, filter, err);\r\ng_free(cmd_str);\r\n}\r\nvoid rtd_table_dissector_init(register_rtd_t* rtd, rtd_stat_table* table, rtd_gui_init_cb gui_callback, void *callback_data)\r\n{\r\nguint i;\r\ntable->num_rtds = rtd->num_tables;\r\ntable->time_stats = g_new0(rtd_timestat, rtd->num_tables);\r\nfor (i = 0; i < table->num_rtds; i++)\r\n{\r\ntable->time_stats[i].num_timestat = rtd->num_timestats;\r\ntable->time_stats[i].rtd = g_new0(timestat_t, rtd->num_timestats);\r\n}\r\nif (gui_callback)\r\ngui_callback(table, callback_data);\r\n}\r\nvoid rtd_table_iterate_tables(GFunc func, gpointer user_data)\r\n{\r\ng_slist_foreach(registered_rtd_tables, func, user_data);\r\n}
