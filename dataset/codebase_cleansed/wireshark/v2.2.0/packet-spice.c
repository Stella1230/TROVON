static guint32\r\ndissect_SpiceHead(tvbuff_t *tvb, proto_tree *tree, guint32 offset, const guint16 num)\r\n{\r\nproto_tree *SpiceHead_tree;\r\nSpiceHead_tree = proto_tree_add_subtree_format(tree, tvb, offset, sizeof_SpiceHead,\r\nett_SpiceHead, NULL, "Display Head #%u", num);\r\nproto_tree_add_item(SpiceHead_tree, hf_display_head_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(SpiceHead_tree, hf_display_head_surface_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(SpiceHead_tree, hf_display_head_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(SpiceHead_tree, hf_display_head_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(SpiceHead_tree, hf_display_head_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(SpiceHead_tree, hf_display_head_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(SpiceHead_tree, hf_display_head_flags, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_AgentMonitorConfig(tvbuff_t *tvb, proto_tree *tree, guint32 offset, const guint16 num)\r\n{\r\nproto_tree *subtree;\r\nsubtree = proto_tree_add_subtree_format(tree, tvb, offset, sizeof_AgentMonitorConfig,\r\nett_SpiceHead, NULL, "Monitor Config #%u", num);\r\nproto_tree_add_item(subtree, hf_agent_monitor_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(subtree, hf_agent_monitor_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(subtree, hf_agent_monitor_depth, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(subtree, hf_agent_monitor_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(subtree, hf_agent_monitor_y, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_Pixmap(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *Pixmap_tree;\r\nguint32 PixmapSize;\r\nguint32 strides, height, pallete_ptr;\r\nPixmap_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_Pixmap, &ti, "Pixmap");\r\nproto_tree_add_item(Pixmap_tree, hf_pixmap_format, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(Pixmap_tree, hf_pixmap_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(Pixmap_tree, hf_pixmap_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nheight = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(Pixmap_tree, hf_pixmap_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nstrides = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(Pixmap_tree, hf_pixmap_stride, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\npallete_ptr = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(Pixmap_tree, hf_pixmap_address, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nPixmapSize = height * strides;\r\nproto_item_set_len(ti, 18 + PixmapSize);\r\nproto_tree_add_bytes_format(Pixmap_tree, hf_spice_pixmap_pixels, tvb, offset, PixmapSize, NULL,\r\n"Pixmap pixels (%d bytes)", PixmapSize);\r\noffset += PixmapSize;\r\nproto_tree_add_bytes_format(Pixmap_tree, hf_spice_pallete, tvb, offset, 0, NULL, "Pallete (offset from message start - %u)", pallete_ptr);\r\nreturn PixmapSize + 18;\r\n}\r\nstatic guint8\r\ndissect_CursorHeader(tvbuff_t *tvb, proto_tree *tree, guint32 offset, guint16 *width, guint16 *height)\r\n{\r\nconst guint8 type = tvb_get_guint8(tvb, offset + 8);\r\n*width = tvb_get_letohs(tvb, offset + 8 + 1);\r\n*height = tvb_get_letohs(tvb, offset + 8 + 1 + 2);\r\nif (tree) {\r\nproto_tree *CursorHeader_tree;\r\nCursorHeader_tree = proto_tree_add_subtree(tree, tvb, offset, sizeof_CursorHeader, ett_cursor_header, NULL, "Cursor Header");\r\nproto_tree_add_item(CursorHeader_tree, hf_cursor_unique, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(CursorHeader_tree, hf_cursor_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(CursorHeader_tree, hf_cursor_width, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(CursorHeader_tree, hf_cursor_height, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(CursorHeader_tree, hf_cursor_hotspot_x, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(CursorHeader_tree, hf_cursor_hotspot_y, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nreturn type;\r\n}\r\nstatic guint32\r\ndissect_RedCursor(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *RedCursor_tree;\r\nguint8 type;\r\nguint16 height, width;\r\nguint32 init_offset = offset;\r\nconst guint16 flags = tvb_get_letohs(tvb, offset);\r\nguint32 data_size = 0;\r\nRedCursor_tree = proto_tree_add_subtree(tree, tvb, offset, 2, ett_RedCursor, &ti, "RedCursor");\r\nproto_tree_add_item(RedCursor_tree, hf_cursor_flags, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nif (flags == SPICE_CURSOR_FLAGS_NONE) {\r\nreturn 2;\r\n}\r\noffset += 2;\r\ntype = dissect_CursorHeader(tvb, RedCursor_tree, offset, &width, &height);\r\noffset += (int)sizeof_CursorHeader;\r\nif (((width == 0) || (height == 0)) || (flags == SPICE_CURSOR_FLAGS_FROM_CACHE)) {\r\nproto_item_set_len(ti, offset - init_offset);\r\nreturn (offset - init_offset);\r\n}\r\nswitch (type) {\r\ncase SPICE_CURSOR_TYPE_ALPHA:\r\ndata_size = (width << 2) * height;\r\nbreak;\r\ncase SPICE_CURSOR_TYPE_MONO:\r\ndata_size = (SPICE_ALIGN(width, 8) >> 2) * height;\r\nbreak;\r\ncase SPICE_CURSOR_TYPE_COLOR4:\r\ncase SPICE_CURSOR_TYPE_COLOR8:\r\ncase SPICE_CURSOR_TYPE_COLOR16:\r\ncase SPICE_CURSOR_TYPE_COLOR24:\r\ncase SPICE_CURSOR_TYPE_COLOR32:\r\nbreak;\r\ndefault:\r\ndata_size = 0;\r\nbreak;\r\n}\r\nif (data_size != 0) {\r\nproto_tree_add_item(RedCursor_tree, hf_spice_cursor_data, tvb, offset, data_size, ENC_NA);\r\n} else {\r\nproto_tree_add_item(RedCursor_tree, hf_spice_cursor_data, tvb, offset, -1, ENC_NA);\r\n}\r\noffset += data_size;\r\nreturn (offset - init_offset);\r\n}\r\nstatic guint8\r\ndissect_ImageDescriptor(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nconst guint8 type = tvb_get_guint8(tvb, offset + 8);\r\nif (tree) {\r\nproto_tree *ImageDescriptor_tree;\r\nImageDescriptor_tree = proto_tree_add_subtree(tree, tvb, offset, sizeof_ImageDescriptor, ett_imagedesc, NULL, "Image Descriptor");\r\nproto_tree_add_item(ImageDescriptor_tree, hf_image_desc_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(ImageDescriptor_tree, hf_image_desc_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ImageDescriptor_tree, hf_image_desc_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ImageDescriptor_tree, hf_image_desc_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ImageDescriptor_tree, hf_image_desc_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nreturn type;\r\n}\r\nstatic guint32\r\ndissect_ImageQuic(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nconst guint32 QuicSize = tvb_get_letohl(tvb, offset);\r\nif (tree) {\r\nproto_tree *ImageQuic_tree;\r\nImageQuic_tree = proto_tree_add_subtree(tree, tvb, offset, QuicSize + 4, ett_imageQuic, NULL, "QUIC Image");\r\nproto_tree_add_uint_format_value(ImageQuic_tree, hf_spice_quic_image_size, tvb, offset, 4, QuicSize, "%u bytes", QuicSize);\r\noffset += 4;\r\nproto_tree_add_item(ImageQuic_tree, hf_spice_quic_magic, tvb, offset, 4, ENC_ASCII|ENC_NA);\r\noffset += 4;\r\nproto_tree_add_item(ImageQuic_tree, hf_quic_major_version, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ImageQuic_tree, hf_quic_minor_version, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(ImageQuic_tree, hf_quic_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ImageQuic_tree, hf_quic_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(ImageQuic_tree, hf_quic_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_bytes_format(ImageQuic_tree, hf_spice_quic_compressed_image_data, tvb, offset, QuicSize - 20, NULL, "QUIC compressed image data (%u bytes)", QuicSize);\r\n}\r\nreturn QuicSize + 4;\r\n}\r\nstatic guint32\r\ndissect_ImageLZ_common_header(tvbuff_t *tvb, proto_tree *tree, const guint32 offset)\r\n{\r\nproto_tree_add_item(tree, hf_spice_lz_magic, tvb, offset, 4, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(tree, hf_LZ_major_version, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_LZ_minor_version, tvb, offset + 6, 2, ENC_BIG_ENDIAN);\r\nreturn 8;\r\n}\r\nstatic guint32\r\ndissect_ImageLZ_common(tvbuff_t *tvb, proto_tree *tree, guint32 offset, const gboolean IsLZ, const guint32 size)\r\n{\r\nguint8 type;\r\noffset += dissect_ImageLZ_common_header(tvb, tree, offset);\r\nif (IsLZ)\r\noffset +=3;\r\nproto_tree_add_item(tree, hf_LZ_RGB_type, tvb, offset, 1, ENC_NA);\r\ntype = tvb_get_guint8(tvb, offset);\r\noffset += 1;\r\nswitch (type & 0xf) {\r\ncase LZ_IMAGE_TYPE_RGB16:\r\ncase LZ_IMAGE_TYPE_RGB24:\r\ncase LZ_IMAGE_TYPE_RGB32:\r\nproto_tree_add_item(tree, hf_LZ_width, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_LZ_height, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_LZ_stride, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_LZ_RGB_dict_id, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_bytes_format(tree, hf_spice_lz_rgb_compressed_image_data, tvb, offset , size - 29, NULL, "LZ_RGB compressed image data (%u bytes)", size - 29);\r\nbreak;\r\ncase LZ_IMAGE_TYPE_RGBA:\r\noffset += 2;\r\nbreak;\r\ncase LZ_IMAGE_TYPE_XXXA:\r\nproto_tree_add_item(tree, hf_LZ_width, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_LZ_height, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_LZ_stride, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_spice_topdown_flag, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_spice_unknown_bytes, tvb, offset, 12, ENC_NA);\r\noffset += 8;\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_LZ_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_LZ_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_LZ_stride, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_LZ_RGB_dict_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_bytes_format(tree, hf_spice_lz_rgb_compressed_image_data, tvb, offset , size - 30, NULL, "LZ_RGB compressed image data (%u bytes)", size - 30);\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_ImageGLZ_RGB(tvbuff_t *tvb, proto_tree *tree, guint32 offset, const guint32 size)\r\n{\r\nproto_tree *GLZ_RGB_tree;\r\nguint32 GLZ_RGBSize;\r\nif (size == 0) {\r\nGLZ_RGBSize = tvb_get_letohl(tvb, offset);\r\nGLZ_RGB_tree = proto_tree_add_subtree(tree, tvb, offset, GLZ_RGBSize + 4, ett_GLZ_RGB, NULL, "GLZ_RGB Image");\r\nproto_tree_add_uint_format_value(GLZ_RGB_tree, hf_spice_glz_rgb_image_size, tvb, offset, 4, GLZ_RGBSize, "%u bytes", GLZ_RGBSize);\r\noffset += 4;\r\n} else {\r\nGLZ_RGBSize = size;\r\nGLZ_RGB_tree = proto_tree_add_subtree(tree, tvb, offset, GLZ_RGBSize, ett_GLZ_RGB, NULL, "GLZ_RGB Image");\r\n}\r\ndissect_ImageLZ_common(tvb, GLZ_RGB_tree, offset, FALSE, GLZ_RGBSize);\r\nreturn GLZ_RGBSize + 4;\r\n}\r\nstatic guint32\r\ndissect_ImageLZ_RGB(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nproto_tree *LZ_RGB_tree;\r\nconst guint32 LZ_RGBSize = tvb_get_letohl(tvb, offset);\r\nLZ_RGB_tree = proto_tree_add_subtree(tree, tvb, offset, LZ_RGBSize + 4, ett_LZ_RGB, NULL, "LZ_RGB Image");\r\nproto_tree_add_uint_format_value(LZ_RGB_tree, hf_spice_lz_rgb_image_size, tvb, offset, 4, LZ_RGBSize, "%u bytes", LZ_RGBSize);\r\noffset += 4;\r\ndissect_ImageLZ_common(tvb, LZ_RGB_tree, offset, TRUE, LZ_RGBSize);\r\nreturn LZ_RGBSize + 4;\r\n}\r\nstatic guint32\r\ndissect_ImageLZ_PLT(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nproto_tree *LZ_PLT_tree;\r\nguint32 LZ_PLTSize, pal_size;\r\nconst guint32 current_offset = offset;\r\nLZ_PLTSize = tvb_get_letohl(tvb, offset + 1);\r\nLZ_PLT_tree = proto_tree_add_subtree(tree, tvb, offset, (LZ_PLTSize - 2)+ 1 + 4 + 4 + 8 + 4 + 4 + 4 + 4 + 4, ett_LZ_PLT, NULL, "LZ_PLT Image");\r\nproto_tree_add_item(LZ_PLT_tree, hf_spice_lz_plt_flag, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_uint_format_value(LZ_PLT_tree, hf_spice_lz_plt_image_size, tvb, offset, 4, LZ_PLTSize, "%u bytes (2 extra bytes?)", LZ_PLTSize);\r\noffset += 4;\r\npal_size = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint_format_value(LZ_PLT_tree, hf_spice_pallete_offset, tvb, offset, 4, pal_size, "%u bytes", pal_size);\r\noffset += 4;\r\ndissect_ImageLZ_common_header(tvb, LZ_PLT_tree, offset);\r\noffset += 8;\r\nproto_tree_add_item(LZ_PLT_tree, hf_LZ_PLT_type, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(LZ_PLT_tree, hf_LZ_width, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(LZ_PLT_tree, hf_LZ_height, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(LZ_PLT_tree, hf_LZ_stride, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(LZ_PLT_tree, hf_spice_topdown_flag, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_bytes_format(LZ_PLT_tree, hf_spice_lz_plt_data, tvb, offset, (LZ_PLTSize - 2), NULL, "LZ_PLT data (%u bytes)", (LZ_PLTSize - 2));\r\noffset += (LZ_PLTSize - 2);\r\nreturn offset - current_offset;\r\n}\r\nstatic guint32\r\ndissect_ImageJPEG_Alpha(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset)\r\n{\r\nproto_tree *JPEG_tree;\r\ntvbuff_t *jpeg_tvb;\r\nguint32 JPEG_Size, Data_Size;\r\noffset += 1;\r\nJPEG_Size = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nData_Size = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nJPEG_tree = proto_tree_add_subtree_format(tree, tvb, offset - 9, Data_Size + 9,\r\nett_JPEG, NULL, "RGB JPEG Image, Alpha channel (%u bytes)", Data_Size);\r\njpeg_tvb = tvb_new_subset_length(tvb, offset, JPEG_Size);\r\ncall_dissector(jpeg_handle, jpeg_tvb, pinfo, JPEG_tree);\r\noffset += JPEG_Size;\r\ndissect_ImageLZ_common(tvb, tree, offset, TRUE, JPEG_Size);\r\nreturn Data_Size + 9;\r\n}\r\nstatic guint32\r\ndissect_ImageJPEG(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, const guint32 offset)\r\n{\r\nproto_tree *JPEG_tree;\r\ntvbuff_t *jpeg_tvb;\r\nconst guint32 JPEG_Size = tvb_get_letohl(tvb, offset);\r\nJPEG_tree = proto_tree_add_subtree_format(tree, tvb, offset, JPEG_Size + 4, ett_JPEG, NULL, "JPEG Image (%u bytes)", JPEG_Size);\r\njpeg_tvb = tvb_new_subset_length(tvb, offset + 4, JPEG_Size);\r\ncall_dissector(jpeg_handle, jpeg_tvb, pinfo, JPEG_tree);\r\nreturn JPEG_Size + 4;\r\n}\r\nstatic void\r\ndissect_ImageZLIB_GLZ_stream(tvbuff_t *tvb, proto_tree *ZLIB_GLZ_tree, packet_info *pinfo,\r\nguint32 offset, guint32 ZLIB_GLZSize, guint32 ZLIB_uncompSize)\r\n{\r\nproto_item *ti;\r\nproto_tree *Uncomp_tree;\r\ntvbuff_t *uncompressed_tvb;\r\nUncomp_tree = proto_tree_add_subtree_format(ZLIB_GLZ_tree, tvb, offset, ZLIB_GLZSize, ett_Uncomp_tree, &ti, "ZLIB stream (%u bytes)", ZLIB_GLZSize);\r\nuncompressed_tvb = tvb_child_uncompress(tvb, tvb, offset, ZLIB_GLZSize);\r\nif (uncompressed_tvb != NULL) {\r\nadd_new_data_source(pinfo, uncompressed_tvb, "Uncompressed GLZ stream");\r\ndissect_ImageGLZ_RGB(uncompressed_tvb, Uncomp_tree, 0, ZLIB_uncompSize);\r\n} else {\r\nexpert_add_info(pinfo, ti, &ei_spice_decompress_error);\r\n}\r\n}\r\nstatic void\r\ndissect_ImageZLIB_GLZ_stream(tvbuff_t *tvb, proto_tree *ZLIB_GLZ_tree, packet_info *pinfo _U_,\r\nguint32 offset, guint32 ZLIB_GLZSize, guint32 ZLIB_uncompSize _U_)\r\n{\r\nproto_tree_add_bytes_format(ZLIB_GLZ_tree, hf_spice_zlib_stream, tvb, offset, ZLIB_GLZSize, NULL, "ZLIB stream (%u bytes)", ZLIB_GLZSize);\r\n}\r\nstatic guint32\r\ndissect_ImageZLIB_GLZ(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *ZLIB_GLZ_tree;\r\nguint32 ZLIB_GLZSize, ZLIB_uncompSize;\r\nZLIB_uncompSize = tvb_get_letohl(tvb, offset);\r\nZLIB_GLZSize = tvb_get_letohl(tvb, offset + 4);\r\nif (tree) {\r\nZLIB_GLZ_tree = proto_tree_add_subtree(tree, tvb, offset, ZLIB_GLZSize + 8, ett_ZLIB_GLZ, NULL, "ZLIB over GLZ Image");\r\nti = proto_tree_add_item(ZLIB_GLZ_tree, hf_zlib_uncompress_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(ti, " bytes");\r\noffset += 4;\r\nti = proto_tree_add_item(ZLIB_GLZ_tree, hf_zlib_compress_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(ti, " bytes");\r\noffset += 4;\r\ndissect_ImageZLIB_GLZ_stream(tvb, ZLIB_GLZ_tree, pinfo, offset, ZLIB_GLZSize, ZLIB_uncompSize);\r\n}\r\nreturn ZLIB_GLZSize + 8;\r\n}\r\nstatic guint32\r\ndissect_Image(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, guint32 offset)\r\n{\r\nguint32 ImageSize = 0;\r\nconst guint8 type = dissect_ImageDescriptor(tvb, tree, offset);\r\noffset += (int)sizeof_ImageDescriptor;\r\nswitch (type) {\r\ncase SPICE_IMAGE_TYPE_BITMAP:\r\nImageSize = dissect_Pixmap(tvb, tree, offset);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_QUIC:\r\nImageSize = dissect_ImageQuic(tvb, tree, offset);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_LZ_PLT:\r\nImageSize = dissect_ImageLZ_PLT(tvb, tree, offset);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_LZ_RGB:\r\nImageSize = dissect_ImageLZ_RGB(tvb, tree, offset);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_GLZ_RGB:\r\nImageSize = dissect_ImageGLZ_RGB(tvb, tree, offset, 0);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_FROM_CACHE:\r\nproto_tree_add_item(tree, hf_spice_image_from_cache, tvb, offset, 0, ENC_NA);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_SURFACE:\r\nImageSize = 4;\r\nproto_tree_add_item(tree, hf_spice_surface_id, tvb, offset, ImageSize, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_JPEG:\r\nImageSize = dissect_ImageJPEG(tvb, tree, pinfo, offset);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_FROM_CACHE_LOSSLESS:\r\nproto_tree_add_item(tree, hf_spice_image_from_cache_lossless, tvb, offset, 0, ENC_NA);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_ZLIB_GLZ_RGB:\r\nImageSize = dissect_ImageZLIB_GLZ(tvb, tree, pinfo, offset);\r\nbreak;\r\ncase SPICE_IMAGE_TYPE_JPEG_ALPHA:\r\nImageSize = dissect_ImageJPEG_Alpha(tvb, tree, pinfo, offset);\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(tree, pinfo, &ei_spice_unknown_image_type, tvb, offset, -1);\r\n}\r\nreturn sizeof_ImageDescriptor + ImageSize;\r\n}\r\nstatic SpiceRect\r\ndissect_SpiceRect(tvbuff_t *tvb, proto_tree *tree, const guint32 offset, const gint32 id)\r\n{\r\nproto_tree *rect_tree;\r\nSpiceRect rect;\r\nrect.left = tvb_get_letohl(tvb, offset);\r\nrect.top = tvb_get_letohl(tvb, offset + 4);\r\nrect.right = tvb_get_letohl(tvb, offset + 8);\r\nrect.bottom = tvb_get_letohl(tvb, offset + 12);\r\nif (tree) {\r\nif (id != -1) {\r\nrect_tree = proto_tree_add_subtree_format(tree, tvb, offset, sizeof_SpiceRect, ett_rect, NULL,\r\n"RECT %u: (%u-%u, %u-%u)", id, rect.left, rect.top, rect.right, rect.bottom);\r\n} else {\r\nrect_tree = proto_tree_add_subtree_format(tree, tvb, offset, sizeof_SpiceRect, ett_rect, NULL,\r\n"RECT: (%u-%u, %u-%u)", rect.left, rect.top, rect.right, rect.bottom);\r\n}\r\nproto_tree_add_item(rect_tree, hf_rect_left, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(rect_tree, hf_rect_top, tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(rect_tree, hf_rect_right, tvb, offset + 8, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(rect_tree, hf_rect_bottom, tvb, offset + 12, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nreturn rect;\r\n}\r\nstatic guint32\r\nrect_is_empty(const SpiceRect r)\r\n{\r\nreturn r.top == r.bottom || r.left == r.right;\r\n}\r\nstatic guint32\r\ndissect_RectList(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nproto_tree *rectlist_tree;\r\nguint32 i;\r\nconst guint32 rectlist_size = tvb_get_letohl(tvb, offset);\r\nif (tree) {\r\nrectlist_tree = proto_tree_add_subtree_format(tree, tvb, offset, 4 + (rectlist_size * sizeof_SpiceRect),\r\nett_rectlist, NULL, "RectList (%d rects)", rectlist_size);\r\nproto_tree_add_item(rectlist_tree, hf_rectlist_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nfor (i = 0; i < rectlist_size; i++ ) {\r\ndissect_SpiceRect(tvb, rectlist_tree, offset, i);\r\noffset += (int)sizeof_SpiceRect;\r\n}\r\n}\r\nreturn (4 + (rectlist_size * sizeof_SpiceRect));\r\n}\r\nstatic guint8\r\ndissect_Clip(tvbuff_t *tvb, proto_tree *tree, const guint32 offset)\r\n{\r\nproto_tree *Clip_tree;\r\nconst guint8 type = tvb_get_guint8(tvb, offset);\r\nif (tree) {\r\nClip_tree = proto_tree_add_subtree(tree, tvb, offset, 1, ett_Clip, NULL, "SpiceClip");\r\nproto_tree_add_item(Clip_tree, hf_Clip_type, tvb, offset, sizeof_Clip, ENC_LITTLE_ENDIAN);\r\n}\r\nreturn type;\r\n}\r\nstatic proto_item*\r\ndissect_POINT32(tvbuff_t *tvb, proto_tree *tree, const guint32 offset)\r\n{\r\nproto_tree *point_tree;\r\nproto_item *ret_item;\r\npoint32_t point;\r\npoint.x = tvb_get_letohl(tvb, offset);\r\npoint.y = tvb_get_letohl(tvb, offset + 4);\r\npoint_tree = proto_tree_add_subtree_format(tree, tvb, offset, sizeof(point32_t), ett_point, &ret_item, "POINT (%u, %u)", point.x, point.y);\r\nproto_tree_add_item(point_tree, hf_point32_x, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(point_tree, hf_point32_y, tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);\r\nreturn ret_item;\r\n}\r\nstatic point16_t\r\ndissect_POINT16(tvbuff_t *tvb, proto_tree *tree, const guint32 offset)\r\n{\r\nproto_tree *point16_tree;\r\npoint16_t point16;\r\npoint16.x = tvb_get_letohs(tvb, offset);\r\npoint16.y = tvb_get_letohs(tvb, offset + 2);\r\nif (tree) {\r\npoint16_tree = proto_tree_add_subtree_format(tree, tvb, offset, sizeof(point16_t), ett_point16, NULL, "POINT16 (%u, %u)", point16.x, point16.y);\r\nproto_tree_add_item(point16_tree, hf_point16_x, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(point16_tree, hf_point16_y, tvb, offset + 2, 2, ENC_LITTLE_ENDIAN);\r\n}\r\nreturn point16;\r\n}\r\nstatic guint32\r\ndissect_Mask(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, guint32 offset)\r\n{\r\nproto_item *ti, *mask_item, *point_item;\r\nproto_tree *Mask_tree;\r\nguint32 bitmap;\r\nMask_tree = proto_tree_add_subtree(tree, tvb, offset, sizeof_Mask, ett_Mask, &ti, "Mask");\r\nmask_item = proto_tree_add_item(Mask_tree, hf_Mask_flag, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\npoint_item = dissect_POINT32(tvb, Mask_tree, offset);\r\noffset += (int)sizeof(point32_t);\r\nbitmap = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(Mask_tree, hf_ref_image, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif (bitmap != 0) {\r\nproto_item_set_len(ti, sizeof_Mask + sizeof_ImageDescriptor);\r\ndissect_ImageDescriptor(tvb, Mask_tree, offset);\r\nreturn sizeof_Mask + sizeof_ImageDescriptor;\r\n}\r\nexpert_add_info(pinfo, mask_item, &ei_spice_Mask_flag);\r\nexpert_add_info(pinfo, point_item, &ei_spice_Mask_point);\r\nreturn sizeof_Mask;\r\n}\r\nstatic guint32\r\ndissect_Brush(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, guint32 offset)\r\n{\r\nproto_tree *brush_tree;\r\nproto_item *ti;\r\nconst guint8 type = tvb_get_guint8(tvb, offset);\r\nti = proto_tree_add_item(tree, hf_brush_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nswitch (type) {\r\ncase SPICE_BRUSH_TYPE_SOLID:\r\nproto_item_set_len(ti, 5);\r\nbrush_tree = proto_item_add_subtree(ti, ett_brush);\r\noffset += 1;\r\nproto_tree_add_item(brush_tree, hf_brush_rgb, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nreturn 5;\r\ncase SPICE_BRUSH_TYPE_PATTERN:\r\nproto_item_set_len(ti, 17);\r\nbrush_tree = proto_item_add_subtree(ti, ett_brush);\r\nproto_tree_add_item(brush_tree, hf_brush_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(brush_tree, hf_ref_image, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ndissect_POINT32(tvb, brush_tree, offset);\r\nreturn (1 + 4 + 8);\r\ncase SPICE_BRUSH_TYPE_NONE:\r\nreturn 1;\r\ndefault:\r\nexpert_add_info(pinfo, ti, &ei_spice_brush_type);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic guint32\r\ndissect_DisplayBase(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *DisplayBase_tree;\r\nSpiceRect rect;\r\nguint8 clip_type;\r\nguint32 clip_size = 0;\r\nDisplayBase_tree = proto_tree_add_subtree(tree, tvb, offset, sizeof_DisplayBase, ett_DisplayBase, &ti, "SpiceMsgDisplayBase");\r\nproto_tree_add_item(DisplayBase_tree, hf_display_surface_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nrect = dissect_SpiceRect(tvb, DisplayBase_tree, offset, -1);\r\nproto_item_append_text(ti, " - SpiceRect box (%u-%u, %u-%u)",rect.left, rect.top, rect.right, rect.bottom);\r\noffset += (int)sizeof_SpiceRect;\r\nclip_type = dissect_Clip(tvb, DisplayBase_tree, offset);\r\noffset += (int)sizeof_Clip;\r\nif (clip_type == SPICE_CLIP_TYPE_RECTS) {\r\nclip_size = dissect_RectList(tvb, DisplayBase_tree, offset);\r\nproto_item_set_len(ti, sizeof_DisplayBase + clip_size);\r\nreturn sizeof_DisplayBase + clip_size;\r\n}\r\nreturn sizeof_DisplayBase;\r\n}\r\nstatic guint32\r\ndissect_SpiceResourceId(tvbuff_t *tvb, proto_tree *tree, guint32 offset, guint16 count)\r\n{\r\nproto_tree *resource_tree;\r\nresource_tree = proto_tree_add_subtree_format(tree, tvb, offset, sizeof_ResourceId,\r\nett_cursor_header, NULL, "Resource #%d", count);\r\nproto_tree_add_item(resource_tree, hf_resource_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(resource_tree, hf_resource_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\nreturn sizeof_ResourceId;\r\n}\r\nstatic const gchar* get_message_type_string(const guint16 message_type, const spice_conversation_t *spice_info,\r\nconst gboolean client_message)\r\n{\r\nif (message_type < SPICE_FIRST_AVAIL_MESSAGE) {\r\nif (client_message) {\r\nreturn val_to_str_const(message_type, spice_msgc_vs, "Unknown client message");\r\n} else {\r\nreturn val_to_str_const(message_type, spice_msg_vs, "Unknown server message");\r\n}\r\n}\r\nswitch (spice_info->channel_type) {\r\ncase SPICE_CHANNEL_MAIN:\r\nif (client_message) {\r\nreturn val_to_str_const(message_type, spice_msgc_main_vs, "Unknown main channel client message");\r\n} else {\r\nreturn val_to_str_const(message_type, spice_msg_main_vs, "Unknown main channel server message");\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_DISPLAY:\r\nif (client_message) {\r\nreturn val_to_str_const(message_type, spice_msgc_display_vs, "Unknown display channel client message");\r\n} else {\r\nreturn val_to_str_const(message_type, spice_msg_display_vs, "Unknown display channel server message");\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_INPUTS:\r\nif (client_message) {\r\nreturn val_to_str_const(message_type, spice_msgc_inputs_vs, "Unknown inputs channel client message");\r\n} else {\r\nreturn val_to_str_const(message_type, spice_msg_inputs_vs, "Unknown inputs channel server message");\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_CURSOR:\r\nif (client_message) {\r\nreturn val_to_str_const(message_type, NULL, "Unknown cursor channel client message");\r\n} else {\r\nreturn val_to_str_const(message_type, spice_msg_cursor_vs, "Unknown cursor channel server message");\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_PLAYBACK:\r\nreturn val_to_str_const(message_type, spice_msg_playback_vs, "Unknown playback channel server message");\r\nbreak;\r\ncase SPICE_CHANNEL_RECORD:\r\nif (client_message) {\r\nreturn val_to_str_const(message_type, spice_msgc_record_vs, "Unknown record channel client message");\r\n} else {\r\nreturn val_to_str_const(message_type, spice_msg_record_vs, "Unknown record channel server message");\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_TUNNEL:\r\nif (client_message) {\r\nreturn val_to_str_const(message_type, spice_msgc_tunnel_vs, "Unknown tunnel channel client message");\r\n} else {\r\nreturn val_to_str_const(message_type, spice_msg_tunnel_vs, "Unknown tunnel channel server message");\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_SMARTCARD:\r\nif (client_message) {\r\nreturn val_to_str_const(message_type, spice_msgc_smartcard_vs, "Unknown smartcard channel client message");\r\n} else {\r\nreturn val_to_str_const(message_type, spice_msg_smartcard_vs, "Unknown smartcard channel server message");\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_USBREDIR:\r\nif (client_message) {\r\nconst value_string *values = NULL;\r\nif (message_type < SPICE_MSG_END_SPICEVMC)\r\nvalues = spice_msg_spicevmc_vs;\r\nreturn val_to_str_const(message_type, values, "Unknown usbredir channel client message");\r\n} else {\r\nconst value_string *values = NULL;\r\nif (message_type < SPICE_MSGC_END_SPICEVMC)\r\nvalues = spice_msgc_spicevmc_vs;\r\nreturn val_to_str_const(message_type, values, "Unknown usbredir channel server message");\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn "Unknown message";\r\n}\r\nstatic void\r\ndissect_spice_mini_data_header(tvbuff_t *tvb, proto_tree *tree, const spice_conversation_t *spice_info,\r\nconst gboolean client_message, const guint16 message_type, guint32 offset)\r\n{\r\nproto_tree* subtree;\r\nif (tree) {\r\nsubtree = proto_tree_add_subtree_format(tree, tvb, offset, 2, ett_common_client_message, NULL,\r\n"Message type: %s (%d)", get_message_type_string(message_type, spice_info, client_message), message_type);\r\nproto_tree_add_item(subtree, hf_message_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_data_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_spice_data_header(tvbuff_t *tvb, proto_tree *tree, const spice_conversation_t *spice_info,\r\nconst gboolean client_message, const guint16 message_type, proto_item** msgtype_item, guint32 *sublist_size, guint32 offset)\r\n{\r\nproto_tree* subtree;\r\n*sublist_size = tvb_get_letohl(tvb, offset + 14);\r\nif (tree) {\r\nproto_tree_add_item(tree, hf_serial, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nsubtree = proto_tree_add_subtree_format(tree, tvb, offset, 2, ett_common_client_message, NULL,\r\n"Message type: %s (%d)", get_message_type_string(message_type, spice_info, client_message), message_type);\r\n*msgtype_item = proto_tree_add_item(subtree, hf_message_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_data_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_data_sublist, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic guint32\r\ndissect_spice_common_client_messages(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ncase SPICE_MSGC_ACK_SYNC:\r\nproto_tree_add_item(tree, hf_red_set_ack_generation, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSGC_ACK:\r\nbreak;\r\ncase SPICE_MSGC_PONG:\r\nproto_tree_add_item(tree, hf_red_ping_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_red_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown common client message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_common_server_messages(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item,\r\nguint32 offset, const guint32 total_message_size)\r\n{\r\nguint32 message_len;\r\nswitch (message_type) {\r\ncase SPICE_MSG_SET_ACK:\r\nproto_tree_add_item(tree, hf_red_set_ack_generation, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_red_set_ack_window, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_PING:\r\nproto_tree_add_item(tree, hf_red_ping_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_red_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nif (total_message_size > 12) {\r\nproto_tree_add_bytes_format(tree, hf_spice_ping_data, tvb, offset, total_message_size - 12,\r\nNULL, "PING DATA (%d bytes)", total_message_size - 12);\r\noffset += (total_message_size - 12);\r\n}\r\nbreak;\r\ncase SPICE_MSG_NOTIFY:\r\nproto_tree_add_item(tree, hf_red_timestamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(tree, hf_severity, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_visibility, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_notify_code, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nmessage_len = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_notify_message_len, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_notify_message, tvb, offset, message_len + 1, ENC_ASCII|ENC_NA);\r\noffset += (message_len + 1);\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown common server message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_record_client(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nproto_tree *record_tree;\r\nswitch (message_type) {\r\ncase SPICE_MSGC_RECORD_MODE:\r\nrecord_tree = proto_tree_add_subtree(tree, tvb, offset, 8, ett_record_client, NULL, "Client RECORD_MODE message");\r\nproto_tree_add_item(record_tree, hf_audio_timestamp, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(record_tree, hf_audio_mode, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown record client message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_display_client(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ncase SPICE_MSGC_DISPLAY_INIT:\r\nproto_tree_add_item(tree, hf_spice_display_init_cache_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_spice_display_init_cache_size, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(tree, hf_spice_display_init_glz_dict_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_spice_display_init_dict_window_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown display client message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_display_server(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nguint32 data_size, displayBaseLen;\r\nguint8 clip_type;\r\nguint16 count, i;\r\nSpiceRect r;\r\ntvbuff_t *jpeg_tvb;\r\nswitch (message_type) {\r\ncase SPICE_MSG_DISPLAY_MODE:\r\nproto_tree_add_item(tree, hf_spice_display_mode_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_spice_display_mode_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_spice_display_mode_depth, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_MARK:\r\nproto_tree_add_item(tree, hf_spice_display_mark_message, tvb, offset, 0, ENC_NA);\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_RESET:\r\nproto_tree_add_item(tree, hf_spice_display_reset_message, tvb, offset, 0, ENC_NA);\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_INVAL_LIST:\r\nproto_tree_add_item(tree, hf_display_inval_list_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\ncount = tvb_get_letohs(tvb, offset);\r\noffset += 2;\r\nfor (i = 0; i < count; i++) {\r\noffset += dissect_SpiceResourceId(tvb, tree, offset, i + 1);\r\n}\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_ALPHA_BLEND:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_ref_image, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ndissect_SpiceRect(tvb, tree, offset, -1);\r\noffset += (int)sizeof_SpiceRect;\r\ndata_size = dissect_Image(tvb, tree, pinfo, offset);\r\noffset += data_size;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_BLACKNESS:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\noffset += dissect_Mask(tvb, pinfo, tree, offset);\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_COPY_BITS:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\ndissect_POINT32(tvb, tree, offset);\r\noffset += (int)sizeof(point32_t);\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_WHITENESS:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\noffset += dissect_Mask(tvb, pinfo, tree, offset);\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_INVERS:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\noffset += dissect_Mask(tvb, pinfo, tree, offset);\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_FILL:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\ndata_size = dissect_Brush(tvb, pinfo, tree, offset);\r\noffset += data_size;\r\nproto_tree_add_item(tree, hf_display_rop_descriptor, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\noffset += dissect_Mask(tvb, pinfo, tree, offset);\r\nif (data_size != 5) {\r\noffset += dissect_Image(tvb, tree, pinfo, offset);\r\n}\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_TRANSPARENT:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\nproto_tree_add_item(tree, hf_ref_image, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ndissect_SpiceRect(tvb, tree, offset, -1);\r\noffset += (int)sizeof_SpiceRect;\r\nproto_tree_add_item(tree, hf_tranparent_src_color, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_tranparent_true_color, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ndata_size = dissect_Image(tvb, tree, pinfo, offset);\r\noffset += data_size;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_BLEND:\r\ncase SPICE_MSG_DISPLAY_DRAW_COPY:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\nproto_tree_add_item(tree, hf_ref_image, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ndissect_SpiceRect(tvb, tree, offset, -1);\r\noffset += (int)sizeof_SpiceRect;\r\nproto_tree_add_item(tree, hf_display_rop_descriptor, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_display_scale_mode, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\noffset += dissect_Mask(tvb, pinfo, tree, offset);\r\ndata_size = dissect_Image(tvb, tree, pinfo, offset);\r\noffset += data_size;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_ROP3:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\nproto_tree_add_item(tree, hf_ref_image, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ndissect_SpiceRect(tvb, tree, offset, -1);\r\noffset += (int)sizeof_SpiceRect;\r\ndata_size = dissect_Brush(tvb, pinfo, tree, offset);\r\noffset += data_size;\r\nproto_tree_add_item(tree, hf_spice_rop3, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_spice_scale_mode, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\noffset += dissect_Mask(tvb, pinfo, tree, offset);\r\ndata_size = dissect_Image(tvb, tree, pinfo, offset);\r\noffset += data_size;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_INVAL_ALL_PALETTES:\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_TEXT:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\nproto_tree_add_item(tree, hf_ref_string, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nr = dissect_SpiceRect(tvb, tree, offset, -1);\r\noffset += (int)sizeof_SpiceRect;\r\nif (!rect_is_empty(r)) {\r\ndata_size = dissect_Brush(tvb, pinfo, tree, offset);\r\noffset += data_size;\r\n}\r\nproto_tree_add_item(tree, hf_display_text_fore_mode, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_display_text_back_mode, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_num_glyphs, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_spice_glyph_flags, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_STROKE:\r\ndisplayBaseLen = dissect_DisplayBase(tvb, tree, offset);\r\noffset += displayBaseLen;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_STREAM_CLIP:\r\nproto_tree_add_item(tree, hf_display_stream_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nclip_type = dissect_Clip(tvb, tree, offset);\r\noffset += (int)sizeof_Clip;\r\nif (clip_type == SPICE_CLIP_TYPE_RECTS) {\r\noffset += dissect_RectList(tvb, tree, offset);\r\n}\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_STREAM_CREATE:\r\nproto_tree_add_item(tree, hf_display_surface_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_flags, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_display_stream_codec_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_display_stream_stamp, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(tree, hf_display_stream_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_src_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_src_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ndissect_SpiceRect(tvb, tree, offset, -1);\r\noffset += (int)sizeof_SpiceRect;\r\nclip_type = dissect_Clip(tvb, tree, offset);\r\noffset += (int)sizeof_Clip;\r\nif (clip_type == SPICE_CLIP_TYPE_RECTS) {\r\noffset += dissect_RectList(tvb, tree, offset);\r\n}\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_STREAM_DATA:\r\ndata_size = tvb_get_letohl(tvb, offset + 8);\r\nproto_tree_add_item(tree, hf_display_stream_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_multi_media_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_data_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_bytes_format(tree, hf_spice_stream_data, tvb, offset, data_size, NULL, "Stream data");\r\njpeg_tvb = tvb_new_subset_length(tvb, offset, data_size);\r\ncall_dissector(jpeg_handle, jpeg_tvb, pinfo, tree);\r\noffset += data_size;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_STREAM_DESTROY:\r\nproto_tree_add_item(tree, hf_display_stream_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_STREAM_DATA_SIZED:\r\nproto_tree_add_item(tree, hf_display_stream_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_multi_media_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ndissect_SpiceRect(tvb, tree, offset, -1);\r\noffset += (int)sizeof_SpiceRect;\r\nproto_tree_add_item(tree, hf_display_stream_data_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_STREAM_DESTROY_ALL:\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_SURFACE_CREATE:\r\nproto_tree_add_item(tree, hf_display_surface_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_surface_width, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_surface_height, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_surface_format, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_surface_flags, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_SURFACE_DESTROY:\r\nproto_tree_add_item(tree, hf_display_surface_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_MONITORS_CONFIG:\r\nproto_tree_add_item(tree, hf_display_monitor_config_count, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\ncount = tvb_get_letohs(tvb, offset);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_display_monitor_config_max_allowed, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nfor (i = 0; i < count; i++) {\r\noffset = dissect_SpiceHead(tvb, tree, offset, i);\r\n}\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_DRAW_COMPOSITE:\r\nbreak;\r\ncase SPICE_MSG_DISPLAY_STREAM_ACTIVATE_REPORT:\r\nproto_tree_add_item(tree, hf_display_stream_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_report_unique_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_report_max_window_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_stream_report_timeout, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown display server message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_playback_server(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item,\r\nguint32 message_size, spice_conversation_t *spice_info, guint32 offset)\r\n{\r\nguint8 num_channels, i;\r\nproto_tree* subtree;\r\nswitch (message_type) {\r\ncase SPICE_MSG_PLAYBACK_DATA:\r\nproto_tree_add_item(tree, hf_audio_timestamp, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_raw_data, tvb, offset, message_size - 4, ENC_NA);\r\noffset += (message_size - 4);\r\nbreak;\r\ncase SPICE_MSG_PLAYBACK_MODE:\r\nproto_tree_add_item(tree, hf_audio_timestamp, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nspice_info->playback_mode = tvb_get_letohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_audio_mode, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase SPICE_MSG_PLAYBACK_START:\r\nproto_tree_add_item(tree, hf_audio_channels, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_audio_format, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_audio_frequency, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_audio_timestamp, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_PLAYBACK_STOP:\r\nbreak;\r\ncase SPICE_MSG_PLAYBACK_VOLUME:\r\nnum_channels = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_audio_channels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, 2 * num_channels, ett_record_server, NULL, "Channel volume array");\r\nfor (i = 0; i < num_channels; i++) {\r\nproto_tree_add_item(subtree, hf_audio_volume, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nbreak;\r\ncase SPICE_MSG_PLAYBACK_MUTE:\r\nproto_tree_add_item(tree, hf_audio_mute, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nbreak;\r\ncase SPICE_MSG_PLAYBACK_LATENCY:\r\nproto_tree_add_item(tree, hf_audio_latency, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown playback server message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_cursor_server(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nguint32 RedCursorSize;\r\nswitch (message_type) {\r\ncase SPICE_MSG_CURSOR_INIT:\r\ndissect_POINT16(tvb, tree, offset);\r\noffset += (int)sizeof(point16_t);\r\nproto_tree_add_item(tree, hf_cursor_trail_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_cursor_trail_freq, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_cursor_trail_visible, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nRedCursorSize = dissect_RedCursor(tvb, tree, offset);\r\noffset += RedCursorSize;\r\nbreak;\r\ncase SPICE_MSG_CURSOR_RESET:\r\nbreak;\r\ncase SPICE_MSG_CURSOR_SET:\r\ndissect_POINT16(tvb, tree, offset);\r\noffset += (int)sizeof(point16_t);\r\noffset +=1;\r\nRedCursorSize = dissect_RedCursor(tvb, tree, offset);\r\noffset += RedCursorSize;\r\nbreak;\r\ncase SPICE_MSG_CURSOR_MOVE:\r\ndissect_POINT16(tvb, tree, offset);\r\noffset += (int)sizeof(point16_t);\r\nbreak;\r\ncase SPICE_MSG_CURSOR_HIDE:\r\nbreak;\r\ncase SPICE_MSG_CURSOR_TRAIL:\r\nproto_tree_add_item(tree, hf_cursor_trail_len, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_cursor_trail_freq, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase SPICE_MSG_CURSOR_INVAL_ONE:\r\nproto_tree_add_item(tree, hf_cursor_id, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nbreak;\r\ncase SPICE_MSG_CURSOR_INVAL_ALL:\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown cursor server message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_record_server(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nguint8 num_channels, i;\r\nproto_tree* subtree;\r\nswitch (message_type) {\r\ncase SPICE_MSG_RECORD_STOP:\r\nbreak;\r\ncase SPICE_MSG_RECORD_VOLUME:\r\nnum_channels = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_audio_channels, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, 2 * num_channels, ett_record_server, NULL, "Volume Array");\r\nfor (i = 0; i < num_channels; i++) {\r\nproto_tree_add_item(subtree, hf_audio_volume, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\n}\r\nbreak;\r\ncase SPICE_MSG_RECORD_MUTE:\r\nproto_tree_add_item(tree, hf_audio_mute, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown record server message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_agent_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint32 message_type, proto_item* msgtype_item, guint32 message_len, guint32 offset)\r\n{\r\nproto_tree *agent_tree;\r\nguint32 n_monitors = 0, i;\r\nswitch (message_type) {\r\ncase VD_AGENT_MOUSE_STATE:\r\ndissect_POINT32(tvb, tree, offset);\r\noffset += (int)sizeof(point32_t);\r\nproto_tree_add_item(tree, hf_button_state, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_mouse_display_id, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\ncase VD_AGENT_MONITORS_CONFIG:\r\nn_monitors = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_agent_num_monitors, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_vd_agent_monitors_config_flag_use_pos, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nfor (i = 0; i < n_monitors; i++) {\r\noffset = dissect_AgentMonitorConfig(tvb, tree, offset, i);\r\n}\r\nbreak;\r\ncase VD_AGENT_REPLY:\r\nproto_tree_add_item(tree, hf_vd_agent_reply_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_vd_agent_reply_error, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase VD_AGENT_CLIPBOARD:\r\nproto_tree_add_item(tree, hf_spice_vd_agent_clipboard_message, tvb, offset, message_len, ENC_NA);\r\noffset += message_len;\r\nbreak;\r\ncase VD_AGENT_DISPLAY_CONFIG:\r\nproto_tree_add_item(tree, hf_spice_vd_agent_display_config_message, tvb, offset, 4, ENC_NA);\r\noffset += 4;\r\nbreak;\r\ncase VD_AGENT_ANNOUNCE_CAPABILITIES:\r\nproto_tree_add_item(tree, hf_vd_agent_caps_request, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_vd_agent_cap_mouse_state, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_vd_agent_cap_monitors_config, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_vd_agent_cap_reply, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_vd_agent_cap_clipboard, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_vd_agent_cap_display_config, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_vd_agent_cap_clipboard_by_demand, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_vd_agent_cap_clipboard_selection, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_vd_agent_cap_sparse_monitors_config, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_vd_agent_cap_guest_lineend_lf, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_vd_agent_cap_guest_lineend_crlf, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase VD_AGENT_CLIPBOARD_GRAB:\r\nagent_tree = proto_tree_add_subtree(tree, tvb, offset, 4, ett_spice_agent, NULL, "VD_AGENT_CLIPBOARD_GRAB message");\r\nproto_tree_add_item(agent_tree, hf_agent_clipboard_selection, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(agent_tree, hf_spice_reserved, tvb, offset, 3, ENC_NA);\r\noffset += 3;\r\nbreak;\r\ncase VD_AGENT_CLIPBOARD_REQUEST:\r\nagent_tree = proto_tree_add_subtree(tree, tvb, offset, 8, ett_spice_agent, NULL, "VD_AGENT_CLIPBOARD_REQUEST message");\r\nproto_tree_add_item(agent_tree, hf_agent_clipboard_selection, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(agent_tree, hf_spice_reserved, tvb, offset, 3, ENC_NA);\r\noffset += 3;\r\nproto_tree_add_item(agent_tree, hf_agent_clipboard_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase VD_AGENT_CLIPBOARD_RELEASE:\r\nproto_tree_add_item(tree, hf_spice_vd_agent_clipboard_release_message, tvb, offset, 0, ENC_NA);\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown agent message (%u) - cannot dissect", message_type);\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_supported_mouse_modes(tvbuff_t *tvb, proto_tree *tree, guint32 offset, guint32 size)\r\n{\r\nproto_item* ti;\r\nproto_tree *sub_tree;\r\nint hf = hf_supported_mouse_modes;\r\nif (size == 2)\r\nhf = hf_supported_mouse_modes_flags;\r\nti = proto_tree_add_item(tree, hf, tvb, offset, size, ENC_LITTLE_ENDIAN);\r\nsub_tree = proto_item_add_subtree(ti, ett_main_client);\r\nproto_tree_add_item(sub_tree, hf_supported_mouse_modes_flag_client, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(sub_tree, hf_supported_mouse_modes_flag_server, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nreturn offset + size;\r\n}\r\nstatic guint32\r\ndissect_spice_main_server(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nguint32 num_channels, i, agent_msg_type, agent_msg_len, name_len, data_size;\r\nproto_tree *subtree = NULL;\r\nswitch (message_type) {\r\ncase SPICE_MSG_MAIN_MIGRATE_BEGIN:\r\ncase SPICE_MSG_MAIN_MIGRATE_SWITCH_HOST:\r\ncase SPICE_MSG_MAIN_MIGRATE_BEGIN_SEAMLESS:\r\nproto_tree_add_item(tree, hf_migrate_dest_port, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_migrate_dest_sport, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\ndata_size = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_raw_data, tvb, offset, data_size, ENC_NA);\r\noffset += data_size;\r\ndata_size = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_raw_data, tvb, offset, data_size, ENC_NA);\r\noffset += data_size;\r\nif (message_type == SPICE_MSG_MAIN_MIGRATE_BEGIN_SEAMLESS) {\r\nproto_tree_add_item(tree, hf_migrate_src_mig_version, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\n}\r\nbreak;\r\ncase SPICE_MSG_MAIN_MIGRATE_CANCEL:\r\nbreak;\r\ncase SPICE_MSG_MAIN_INIT:\r\nproto_tree_add_item(tree, hf_session_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_display_channels_hint, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\ndissect_supported_mouse_modes(tvb, tree, offset, 4);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_current_mouse_mode, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_agent_connected, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_agent_tokens, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_multi_media_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_ram_hint, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_MAIN_CHANNELS_LIST:\r\nnum_channels = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_main_num_channels, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nsubtree = proto_tree_add_subtree(tree, tvb, offset, 2 * num_channels, ett_main_client, NULL, "Channel Array");\r\nfor (i = 0; i < num_channels; i++ ) {\r\nproto_tree *subsubtree;\r\nsubsubtree = proto_tree_add_subtree_format(subtree, tvb, offset, 2, ett_main_client, NULL, "channels[%u]", i);\r\nproto_tree_add_item(subsubtree, hf_channel_type, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(subsubtree, hf_channel_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\n}\r\nbreak;\r\ncase SPICE_MSG_MAIN_MOUSE_MODE:\r\ndissect_supported_mouse_modes(tvb, tree, offset, 2);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_current_mouse_mode_flags, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase SPICE_MSG_MAIN_MULTI_MEDIA_TIME:\r\nproto_tree_add_item(tree, hf_multi_media_time, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_MAIN_AGENT_DISCONNECTED:\r\nproto_tree_add_item(tree, hf_error_code, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_MAIN_AGENT_DATA:\r\nproto_tree_add_item(tree, hf_agent_protocol, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_agent_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nagent_msg_type = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_agent_opaque, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(tree, hf_agent_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nagent_msg_len = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\noffset = dissect_spice_agent_message(tvb, pinfo, tree, agent_msg_type, msgtype_item, agent_msg_len, offset);\r\nbreak;\r\ncase SPICE_MSG_MAIN_AGENT_TOKEN:\r\ncase SPICE_MSG_MAIN_AGENT_CONNECTED_TOKENS:\r\nproto_tree_add_item(tree, hf_agent_token, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSG_MAIN_NAME:\r\nname_len = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_main_name_len, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_main_name, tvb, offset, name_len, ENC_ASCII|ENC_NA);\r\noffset += name_len;\r\nbreak;\r\ncase SPICE_MSG_MAIN_UUID:\r\nproto_tree_add_item(tree, hf_main_uuid, tvb, offset, 16, ENC_BIG_ENDIAN);\r\noffset += 16;\r\nbreak;\r\ncase SPICE_MSG_MAIN_MIGRATE_END:\r\nbreak;\r\ncase SPICE_MSG_MAIN_MIGRATE_DST_SEAMLESS_ACK:\r\nbreak;\r\ncase SPICE_MSG_MAIN_MIGRATE_DST_SEAMLESS_NACK:\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown main server message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_main_client(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nproto_tree *main_tree;\r\nguint32 agent_msg_type, agent_msg_len;\r\nswitch (message_type) {\r\ncase SPICE_MSGC_MAIN_MOUSE_MODE_REQUEST:\r\nproto_tree_add_item(tree, hf_current_mouse_mode_flags, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase SPICE_MSGC_MAIN_ATTACH_CHANNELS:\r\nbreak;\r\ncase SPICE_MSGC_MAIN_AGENT_START:\r\nmain_tree = proto_tree_add_subtree(tree, tvb, offset, 4, ett_main_client, NULL, "Client AGENT_START message");\r\nproto_tree_add_item(main_tree, hf_main_client_agent_tokens, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSGC_MAIN_AGENT_DATA:\r\nmain_tree = proto_tree_add_subtree(tree, tvb, offset, 24, ett_main_client, NULL, "Client AGENT_DATA message");\r\nproto_tree_add_item(main_tree, hf_agent_protocol, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(main_tree, hf_agent_type, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nagent_msg_type = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\nproto_tree_add_item(main_tree, hf_agent_opaque, tvb, offset, 8, ENC_LITTLE_ENDIAN);\r\noffset += 8;\r\nproto_tree_add_item(main_tree, hf_agent_size, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nagent_msg_len = tvb_get_letohl(tvb, offset);\r\noffset += 4;\r\noffset = dissect_spice_agent_message(tvb, pinfo, main_tree, agent_msg_type, msgtype_item, agent_msg_len, offset);\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown main client message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_spice_keyboard_modifiers(tvbuff_t *tvb, proto_tree *tree, guint32 offset)\r\n{\r\nproto_item *ti;\r\nproto_tree *subtree;\r\nti = proto_tree_add_item(tree, hf_keyboard_modifiers, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nsubtree = proto_item_add_subtree(ti, ett_link_caps);\r\nproto_tree_add_item(subtree, hf_keyboard_modifier_scroll_lock, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_keyboard_modifier_num_lock, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subtree, hf_keyboard_modifier_caps_lock, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nreturn 2;\r\n}\r\nstatic guint32\r\ndissect_spice_inputs_client(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nproto_tree *inputs_tree;\r\nswitch (message_type) {\r\ncase SPICE_MSGC_INPUTS_KEY_DOWN:\r\ninputs_tree = proto_tree_add_subtree(tree, tvb, offset, 4, ett_inputs_client, NULL, "Client KEY_DOWN message");\r\nproto_tree_add_item(inputs_tree, hf_keyboard_code, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSGC_INPUTS_KEY_UP:\r\ninputs_tree = proto_tree_add_subtree(tree, tvb, offset, 4, ett_inputs_client, NULL, "Client KEY_UP message");\r\nproto_tree_add_item(inputs_tree, hf_keyboard_code, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nbreak;\r\ncase SPICE_MSGC_INPUTS_KEY_MODIFIERS:\r\noffset += dissect_spice_keyboard_modifiers(tvb, tree, offset);\r\nbreak;\r\ncase SPICE_MSGC_INPUTS_MOUSE_POSITION:\r\ninputs_tree = proto_tree_add_subtree(tree, tvb, offset, sizeof(point32_t) + 3, ett_inputs_client, NULL, "Client MOUSE_POSITION message");\r\ndissect_POINT32(tvb, inputs_tree, offset);\r\noffset += (int)sizeof(point32_t);\r\nproto_tree_add_item(inputs_tree, hf_button_state, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(inputs_tree, hf_mouse_display_id, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nbreak;\r\ncase SPICE_MSGC_INPUTS_MOUSE_MOTION:\r\ninputs_tree = proto_tree_add_subtree(tree, tvb, offset, sizeof(point32_t) + 4, ett_inputs_client, NULL, "Client MOUSE_MOTION message");\r\ndissect_POINT32(tvb, inputs_tree, offset);\r\noffset += (int)sizeof(point32_t);\r\nproto_tree_add_item(inputs_tree, hf_button_state, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nbreak;\r\ncase SPICE_MSGC_INPUTS_MOUSE_PRESS:\r\ninputs_tree = proto_tree_add_subtree(tree, tvb, offset, 3, ett_inputs_client, NULL, "Client MOUSE_PRESS message");\r\nproto_tree_add_item(inputs_tree, hf_button_state, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(inputs_tree, hf_mouse_display_id, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\ncase SPICE_MSGC_INPUTS_MOUSE_RELEASE:\r\ninputs_tree = proto_tree_add_subtree(tree, tvb, offset, 3, ett_inputs_client, NULL, "Client MOUSE_RELEASE message");\r\nproto_tree_add_item(inputs_tree, hf_button_state, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(inputs_tree, hf_mouse_display_id, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown inputs client message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_inputs_server(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ncase SPICE_MSG_INPUTS_INIT:\r\noffset += dissect_spice_keyboard_modifiers(tvb, tree, offset);\r\nbreak;\r\ncase SPICE_MSG_INPUTS_KEY_MODIFIERS:\r\noffset += dissect_spice_keyboard_modifiers(tvb, tree, offset);\r\nbreak;\r\ncase SPICE_MSG_INPUTS_MOUSE_MOTION_ACK:\r\nproto_tree_add_item(tree, hf_spice_server_inputs_mouse_motion_ack_message, tvb, offset, 0, ENC_NA);\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown inputs server message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_tunnel_client(packet_info *pinfo, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_tunnel_server(packet_info *pinfo, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_smartcard_client(packet_info *pinfo, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_smartcard_server(packet_info *pinfo, const guint16 message_type, proto_item* msgtype_item, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_usbredir_client(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 message_size, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ncase SPICE_MSGC_SPICEVMC_DATA:\r\nproto_tree_add_item(tree, hf_raw_data, tvb, offset, message_size, ENC_NA);\r\noffset += message_size;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_usbredir_server(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 message_size, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ncase SPICE_MSG_SPICEVMC_DATA:\r\nproto_tree_add_item(tree, hf_raw_data, tvb, offset, message_size, ENC_NA);\r\noffset += message_size;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_port_client(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 message_size, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ncase SPICE_MSGC_SPICEVMC_DATA:\r\nproto_tree_add_item(tree, hf_raw_data, tvb, offset, message_size, ENC_NA);\r\noffset += message_size;\r\nbreak;\r\ncase SPICE_MSGC_PORT_EVENT:\r\nproto_tree_add_item(tree, hf_port_event, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_port_server(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, const guint16 message_type, proto_item* msgtype_item, guint32 message_size, guint32 offset)\r\n{\r\nswitch (message_type) {\r\ncase SPICE_MSG_SPICEVMC_DATA:\r\nproto_tree_add_item(tree, hf_raw_data, tvb, offset, message_size, ENC_NA);\r\noffset += message_size;\r\nbreak;\r\ncase SPICE_MSG_PORT_INIT:\r\n{\r\nguint32 size = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(tree, hf_spice_name_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_main_name, tvb, offset, size, ENC_ASCII|ENC_NA);\r\noffset += size;\r\nproto_tree_add_item(tree, hf_port_opened, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\n}\r\nbreak;\r\ncase SPICE_MSG_PORT_EVENT:\r\nproto_tree_add_item(tree, hf_port_event, tvb, offset, 1, ENC_LITTLE_ENDIAN);\r\noffset += 1;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_item, &ei_spice_unknown_message, "Unknown message - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_data_server_pdu(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, spice_conversation_t *spice_info, guint32 offset, const guint32 total_message_size)\r\n{\r\nproto_item *ti = NULL, *msg_ti=NULL, *msgtype_ti=NULL;\r\nproto_tree *data_header_tree, *message_tree;\r\nguint16 message_type;\r\nguint32 message_size, sublist_size, old_offset;\r\nguint32 header_size;\r\nif (spice_info->client_mini_header && spice_info->server_mini_header) {\r\nheader_size = sizeof_SpiceMiniDataHeader;\r\nmessage_type = tvb_get_letohs(tvb, offset);\r\nmessage_size = tvb_get_letohl(tvb, offset +2);\r\nmessage_tree = proto_tree_add_subtree_format(tree, tvb, offset, 0,\r\nett_message, &msg_ti, "%s (%d bytes)",\r\nget_message_type_string(message_type, spice_info, FALSE),\r\nmessage_size + header_size);\r\nti = proto_tree_add_item(message_tree, hf_data, tvb, offset, header_size, ENC_NA);\r\ndata_header_tree = proto_item_add_subtree(ti, ett_data);\r\ndissect_spice_mini_data_header(tvb, data_header_tree, spice_info, FALSE, message_type, offset);\r\nproto_item_set_len(msg_ti, message_size + header_size);\r\n} else {\r\nheader_size = sizeof_SpiceDataHeader;\r\nmessage_type = tvb_get_letohs(tvb, offset + 8);\r\nmessage_size = tvb_get_letohl(tvb, offset + 10);\r\nmessage_tree = proto_tree_add_subtree_format(tree, tvb, offset, 0,\r\nett_message, &msg_ti, "%s (%d bytes)",\r\nget_message_type_string(message_type, spice_info, FALSE),\r\nmessage_size + header_size);\r\nti = proto_tree_add_item(message_tree, hf_data, tvb, offset, header_size, ENC_NA);\r\ndata_header_tree = proto_item_add_subtree(ti, ett_data);\r\ndissect_spice_data_header(tvb, data_header_tree, spice_info, FALSE, message_type, &msgtype_ti, &sublist_size, offset);\r\n}\r\nproto_item_set_len(msg_ti, message_size + header_size);\r\noffset += header_size;\r\nold_offset = offset;\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, ", ", get_message_type_string(message_type, spice_info, FALSE));\r\nif (message_type < SPICE_FIRST_AVAIL_MESSAGE) {\r\noffset = dissect_spice_common_server_messages(tvb, pinfo, message_tree, message_type, msgtype_ti, offset, total_message_size - header_size);\r\nreturn offset;\r\n}\r\nswitch (spice_info->channel_type) {\r\ncase SPICE_CHANNEL_PLAYBACK:\r\noffset = dissect_spice_playback_server(tvb, pinfo, message_tree, message_type, msgtype_ti, message_size, spice_info, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_RECORD:\r\noffset = dissect_spice_record_server(tvb, pinfo, message_tree, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_MAIN:\r\noffset = dissect_spice_main_server(tvb, pinfo, message_tree, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_CURSOR:\r\noffset = dissect_spice_cursor_server(tvb, pinfo, message_tree, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_DISPLAY:\r\noffset = dissect_spice_display_server(tvb, message_tree, pinfo, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_INPUTS:\r\noffset = dissect_spice_inputs_server(tvb, pinfo, message_tree, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_TUNNEL:\r\noffset = dissect_spice_tunnel_server(pinfo, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_SMARTCARD:\r\noffset = dissect_spice_smartcard_server(pinfo, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_USBREDIR:\r\noffset = dissect_spice_usbredir_server(tvb, pinfo, message_tree, message_type, msgtype_ti, message_size, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_PORT:\r\noffset = dissect_spice_port_server(tvb, pinfo, message_tree, message_type, msgtype_ti, message_size, offset);\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_ti, &ei_spice_unknown_message, "Unknown server PDU - cannot dissect");\r\n}\r\nif ((offset - old_offset) != message_size) {\r\nproto_tree_add_expert_format(tree, pinfo, &ei_spice_not_dissected, tvb, offset, -1,\r\n"message type %s (%u) not fully dissected", get_message_type_string(message_type, spice_info, FALSE), message_type);\r\noffset = old_offset + message_size;\r\n}\r\nreturn offset;\r\n}\r\nstatic guint32\r\ndissect_spice_data_client_pdu(tvbuff_t *tvb, proto_tree *tree, packet_info *pinfo, spice_conversation_t *spice_info, guint32 offset)\r\n{\r\nproto_item *ti = NULL, *msgtype_ti = NULL;\r\nproto_tree *data_header_tree;\r\nguint16 message_type;\r\nguint32 message_size = 0, sublist_size;\r\nguint32 header_size;\r\nif (spice_info->client_mini_header && spice_info->server_mini_header) {\r\nheader_size = sizeof_SpiceMiniDataHeader;\r\nti = proto_tree_add_item(tree, hf_data, tvb, offset, header_size, ENC_NA);\r\ndata_header_tree = proto_item_add_subtree(ti, ett_data);\r\nmessage_type = tvb_get_letohs(tvb, offset);\r\nmessage_size = tvb_get_letohl(tvb, offset + 2);\r\ndissect_spice_mini_data_header(tvb, data_header_tree, spice_info, TRUE, message_type, offset);\r\n} else {\r\nheader_size = sizeof_SpiceDataHeader;\r\nti = proto_tree_add_item(tree, hf_data, tvb, offset, header_size, ENC_NA);\r\ndata_header_tree = proto_item_add_subtree(ti, ett_data);\r\nmessage_type = tvb_get_letohs(tvb, offset + 8);\r\nmessage_size = tvb_get_letohl(tvb, offset + 10);\r\ndissect_spice_data_header(tvb, data_header_tree, spice_info, TRUE, message_type, &msgtype_ti, &sublist_size, offset);\r\n}\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, ", ", get_message_type_string(message_type, spice_info, TRUE));\r\noffset += header_size;\r\nif (message_type < SPICE_FIRST_AVAIL_MESSAGE) {\r\nreturn dissect_spice_common_client_messages(tvb, pinfo, tree, message_type, msgtype_ti, offset);\r\n}\r\nswitch (spice_info->channel_type) {\r\ncase SPICE_CHANNEL_PLAYBACK:\r\nbreak;\r\ncase SPICE_CHANNEL_RECORD:\r\noffset = dissect_spice_record_client(tvb, pinfo, tree, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_MAIN:\r\noffset = dissect_spice_main_client(tvb, pinfo, tree, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_DISPLAY:\r\noffset = dissect_spice_display_client(tvb, pinfo, tree, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_INPUTS:\r\noffset = dissect_spice_inputs_client(tvb, pinfo, tree, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_TUNNEL:\r\noffset = dissect_spice_tunnel_client(pinfo, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_SMARTCARD:\r\noffset = dissect_spice_smartcard_client(pinfo, message_type, msgtype_ti, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_USBREDIR:\r\noffset = dissect_spice_usbredir_client(tvb, pinfo, tree, message_type, msgtype_ti, message_size, offset);\r\nbreak;\r\ncase SPICE_CHANNEL_PORT:\r\noffset = dissect_spice_port_client(tvb, pinfo, tree, message_type, msgtype_ti, message_size, offset);\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, msgtype_ti, &ei_spice_unknown_message, "Unknown client PDU - cannot dissect");\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_spice_link_common_header(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nif (tree) {\r\nproto_tree_add_item(tree, hf_spice_magic, tvb, 0, 4, ENC_ASCII|ENC_NA);\r\nproto_tree_add_item(tree, hf_major_version, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_minor_version, tvb, 8, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_message_size, tvb, 12, 4, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\nstatic void\r\ndissect_spice_common_capabilities(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, guint32 offset, const guint caps_len, spice_conversation_t *spice_info, gboolean is_client)\r\n{\r\nguint i;\r\nguint32 val;\r\nstatic const int * caps[] = {\r\n&hf_common_cap_auth_select,\r\n&hf_common_cap_auth_spice,\r\n&hf_common_cap_auth_sasl,\r\n&hf_common_cap_mini_header,\r\nNULL\r\n};\r\nfor(i = 0; i < caps_len; i++) {\r\nval = tvb_get_letohl(tvb, offset);\r\nswitch (i) {\r\ncase 0:\r\nif (is_client) {\r\nspice_info->client_auth = val;\r\n} else {\r\nspice_info->server_auth = val;\r\n}\r\nproto_tree_add_bitmask_list(tree, tvb, offset, 4, caps, ENC_LITTLE_ENDIAN);\r\nif (val & SPICE_COMMON_CAP_MINI_HEADER_MASK) {\r\nif (is_client) {\r\nspice_info->client_mini_header = TRUE;\r\n} else {\r\nspice_info->server_mini_header = TRUE;\r\n}\r\n}\r\noffset += 4;\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(tree, pinfo, &ei_spice_common_cap_unknown, tvb, offset, 4);\r\noffset += 4;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_spice_link_capabilities(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, guint32 offset, const guint caps_len, const spice_conversation_t *spice_info)\r\n{\r\nguint i;\r\nfor(i = 0; i < caps_len; i++) {\r\nswitch (spice_info->channel_type) {\r\ncase SPICE_CHANNEL_PLAYBACK:\r\n{\r\nconst int * playback[] = {\r\n&hf_common_cap_auth_select,\r\n&hf_common_cap_auth_spice,\r\nNULL\r\n};\r\nif (i != 0)\r\nreturn;\r\nproto_tree_add_bitmask_list(tree, tvb, offset, 4, playback, ENC_LITTLE_ENDIAN);\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_MAIN:\r\n{\r\nconst int * main_cap[] = {\r\n&hf_main_cap_semi_migrate,\r\n&hf_main_cap_vm_name_uuid,\r\n&hf_main_cap_agent_connected_tokens,\r\n&hf_main_cap_seamless_migrate,\r\nNULL\r\n};\r\nif (i != 0)\r\nreturn;\r\nproto_tree_add_bitmask_list(tree, tvb, offset, 4, main_cap, ENC_LITTLE_ENDIAN);\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_DISPLAY:\r\n{\r\nconst int * display_cap[] = {\r\n&hf_display_cap_sized_stream,\r\n&hf_display_cap_monitors_config,\r\n&hf_display_cap_composite,\r\n&hf_display_cap_a8_surface,\r\nNULL\r\n};\r\nif (i != 0)\r\nreturn;\r\nproto_tree_add_bitmask_list(tree, tvb, offset, 4, display_cap, ENC_LITTLE_ENDIAN);\r\n}\r\nbreak;\r\ncase SPICE_CHANNEL_INPUTS:\r\nproto_tree_add_item(tree, hf_inputs_cap, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase SPICE_CHANNEL_CURSOR:\r\nproto_tree_add_item(tree, hf_cursor_cap, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase SPICE_CHANNEL_RECORD:\r\n{\r\nconst int * record_cap[] = {\r\n&hf_record_cap_celt,\r\n&hf_record_cap_volume,\r\nNULL\r\n};\r\nif (i != 0)\r\nreturn;\r\nproto_tree_add_bitmask_list(tree, tvb, offset, 4, record_cap, ENC_LITTLE_ENDIAN);\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_expert(tree, pinfo, &ei_spice_unknown_channel, tvb, offset, -1);\r\nreturn;\r\n}\r\noffset += 4;\r\n}\r\n}\r\nstatic void\r\ndissect_spice_link_client_pdu(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, spice_conversation_t *spice_info)\r\n{\r\nguint32 offset;\r\nguint32 common_caps_len, channel_caps_len;\r\nproto_item *ti = NULL;\r\nproto_tree *link_header_tree = NULL;\r\nproto_tree *caps_tree = NULL;\r\nif (tree) {\r\nti = proto_tree_add_item(tree, hf_link_client, tvb, 0, sizeof_SpiceLinkHeader, ENC_NA);\r\nlink_header_tree = proto_item_add_subtree(ti, ett_link_client);\r\ndissect_spice_link_common_header(tvb, link_header_tree);\r\n}\r\noffset = sizeof_SpiceLinkHeader;\r\nif (spice_info->channel_type == SPICE_CHANNEL_NONE) {\r\nspice_info->channel_type = tvb_get_guint8(tvb, offset + 4);\r\n}\r\ncommon_caps_len = tvb_get_letohl(tvb, offset + 6);\r\nchannel_caps_len = tvb_get_letohl(tvb, offset + 10);\r\nproto_tree_add_item(tree, hf_conn_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_channel_type, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_channel_id, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(tree, hf_num_common_caps, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_num_channel_caps, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_caps_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\noffset += 4;\r\nif (common_caps_len > 0) {\r\ncaps_tree = proto_tree_add_subtree_format(tree, tvb, offset, common_caps_len * 4,\r\nett_link_caps, NULL, "Client Common Capabilities (%d bytes)",\r\ncommon_caps_len * 4);\r\ndissect_spice_common_capabilities(tvb, pinfo, caps_tree, offset, common_caps_len, spice_info, TRUE);\r\noffset += (common_caps_len * 4);\r\n}\r\nif (channel_caps_len > 0) {\r\ncaps_tree = proto_tree_add_subtree_format(tree, tvb, offset, channel_caps_len * 4,\r\nett_link_caps, NULL, "Client Channel-specific Capabilities (%d bytes)",\r\nchannel_caps_len * 4);\r\ndissect_spice_link_capabilities(tvb, pinfo, caps_tree, offset, channel_caps_len, spice_info);\r\n}\r\n}\r\nstatic void\r\ndissect_spice_link_server_pdu(tvbuff_t *tvb, packet_info* pinfo, proto_tree *tree, spice_conversation_t *spice_info)\r\n{\r\nguint32 offset;\r\nguint32 common_caps_len, channel_caps_len;\r\nproto_item *ti = NULL;\r\nproto_tree *link_tree = NULL;\r\nproto_tree *caps_tree = NULL;\r\nif (tree) {\r\nti = proto_tree_add_item(tree, hf_link_server, tvb, 0, sizeof_SpiceLinkHeader, ENC_NA);\r\nlink_tree = proto_item_add_subtree(ti, ett_link_server);\r\ndissect_spice_link_common_header(tvb, link_tree);\r\n}\r\noffset = sizeof_SpiceLinkHeader;\r\nif (tree) {\r\nproto_tree_add_item(tree, hf_error_code, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_bytes_format(tree, hf_spice_x509_subjectpublickeyinfo, tvb, offset + 4, SPICE_TICKET_PUBKEY_BYTES, NULL, "X.509 SubjectPublicKeyInfo (ASN.1)");\r\nproto_tree_add_item(tree, hf_num_common_caps, tvb, offset + 4 + SPICE_TICKET_PUBKEY_BYTES, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_num_channel_caps, tvb, offset + 8 + SPICE_TICKET_PUBKEY_BYTES, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_caps_offset, tvb, offset + 12 + SPICE_TICKET_PUBKEY_BYTES, 4, ENC_LITTLE_ENDIAN);\r\n}\r\ncommon_caps_len = tvb_get_letohl(tvb, offset + 4 + SPICE_TICKET_PUBKEY_BYTES);\r\nchannel_caps_len = tvb_get_letohl(tvb, offset + 8 + SPICE_TICKET_PUBKEY_BYTES);\r\noffset += (int)sizeof_SpiceLinkHeader + SPICE_TICKET_PUBKEY_BYTES;\r\nif (common_caps_len > 0) {\r\ncaps_tree = proto_tree_add_subtree_format(tree, tvb, offset, common_caps_len * 4,\r\nett_link_caps, NULL, "Common Capabilities (%d bytes)",\r\ncommon_caps_len * 4);\r\ndissect_spice_common_capabilities(tvb, pinfo, caps_tree, offset, common_caps_len, spice_info, FALSE);\r\noffset += (common_caps_len * 4);\r\n}\r\nif (channel_caps_len > 0) {\r\ncaps_tree = proto_tree_add_subtree_format(tree, tvb, offset, channel_caps_len * 4,\r\nett_link_caps, NULL, "Channel Capabilities (%d bytes)",\r\nchannel_caps_len * 4);\r\ndissect_spice_link_capabilities(tvb, pinfo, caps_tree, offset, channel_caps_len, spice_info);\r\n}\r\n}\r\nstatic int\r\ndissect_spice(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nconversation_t *conversation;\r\nspice_conversation_t *spice_info;\r\nspice_packet_t *per_packet_info;\r\nguint32 avail;\r\nguint32 pdu_len = 0;\r\nguint32 offset;\r\nproto_item *ti, *auth_item;\r\nproto_tree *spice_tree;\r\ngboolean client_sasl_list = FALSE;\r\nguint8 sasl_auth_result;\r\nconversation = find_or_create_conversation(pinfo);\r\nspice_info = (spice_conversation_t*)conversation_get_proto_data(conversation, proto_spice);\r\nif (!spice_info) {\r\nspice_info = wmem_new0(wmem_file_scope(), spice_conversation_t);\r\nspice_info->destport = pinfo->destport;\r\nspice_info->channel_type = SPICE_CHANNEL_NONE;\r\nspice_info->next_state = SPICE_LINK_CLIENT;\r\nspice_info->client_auth = 0;\r\nspice_info->server_auth = 0;\r\nspice_info->playback_mode = SPICE_AUDIO_DATA_MODE_INVALID;\r\nspice_info->client_mini_header = FALSE;\r\nspice_info->server_mini_header = FALSE;\r\nconversation_add_proto_data(conversation, proto_spice, spice_info);\r\nconversation_set_dissector(conversation, spice_handle);\r\n}\r\nper_packet_info = (spice_packet_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_spice, 0);\r\nif (!per_packet_info) {\r\nper_packet_info = wmem_new(wmem_file_scope(), spice_packet_t);\r\nper_packet_info->state = spice_info->next_state;\r\np_add_proto_data(wmem_file_scope(), pinfo, proto_spice, 0, per_packet_info);\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_PROTOCOL, "Spice %s", val_to_str_const(spice_info->channel_type,channel_types_vs, "Unknown"));\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncol_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(per_packet_info->state, state_name_vs, ""));\r\nti = proto_tree_add_item(tree, proto_spice, tvb, 0, -1, ENC_NA);\r\nspice_tree = proto_item_add_subtree(ti, ett_spice);\r\nswitch (per_packet_info->state) {\r\ncase SPICE_LINK_CLIENT:\r\navail = tvb_reported_length(tvb);\r\npdu_len = sizeof_SpiceLinkHeader;\r\nGET_PDU_FROM_OFFSET(0)\r\npdu_len = tvb_get_letohl(tvb, 12) + sizeof_SpiceLinkHeader;\r\nGET_PDU_FROM_OFFSET(0)\r\nproto_item_set_len(ti, pdu_len);\r\ndissect_spice_link_client_pdu(tvb, pinfo, spice_tree, spice_info);\r\ncol_add_fstr(pinfo->cinfo, COL_PROTOCOL,\r\n"Spice %s", val_to_str_const(spice_info->channel_type,channel_types_vs, "Unknown"));\r\nspice_info->next_state = SPICE_LINK_SERVER;\r\nreturn pdu_len;\r\nbreak;\r\ncase SPICE_LINK_SERVER:\r\navail = tvb_reported_length(tvb);\r\npdu_len = sizeof_SpiceLinkHeader;\r\nGET_PDU_FROM_OFFSET(0)\r\npdu_len = tvb_get_letohl(tvb, 12) + sizeof_SpiceLinkHeader;\r\nGET_PDU_FROM_OFFSET(0)\r\nproto_item_set_len(ti, pdu_len);\r\ndissect_spice_link_server_pdu(tvb, pinfo, spice_tree, spice_info);\r\nif (!(spice_info->server_auth & SPICE_COMMON_CAP_PROTOCOL_AUTH_SELECTION_MASK) ||\r\n!(spice_info->client_auth & SPICE_COMMON_CAP_PROTOCOL_AUTH_SELECTION_MASK)) {\r\nspice_info->next_state = SPICE_TICKET_CLIENT;\r\n} else {\r\nspice_info->next_state = SPICE_CLIENT_AUTH_SELECT;\r\n}\r\nreturn pdu_len;\r\nbreak;\r\ncase SPICE_CLIENT_AUTH_SELECT:\r\nif (spice_info->destport != pinfo->destport) {\r\nexpert_add_info(pinfo, ti, &ei_spice_expected_from_client);\r\nbreak;\r\n}\r\navail = tvb_reported_length(tvb);\r\npdu_len = 4;\r\nGET_PDU_FROM_OFFSET(0)\r\nproto_item_set_len(ti, 4);\r\nauth_item = proto_tree_add_item(spice_tree, hf_auth_select_client, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nspice_info->auth_selected = tvb_get_letohl(tvb, 0);\r\nswitch (spice_info->auth_selected) {\r\ncase SPICE_COMMON_CAP_AUTH_SPICE:\r\nspice_info->next_state = SPICE_TICKET_CLIENT;\r\nbreak;\r\ncase SPICE_COMMON_CAP_AUTH_SASL:\r\nspice_info->next_state = SPICE_SASL_INIT_FROM_SERVER;\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, auth_item, &ei_spice_auth_unknown);\r\nbreak;\r\n}\r\nreturn 4;\r\nbreak;\r\ncase SPICE_SASL_INIT_FROM_SERVER:\r\noffset = 0;\r\navail = tvb_reported_length_remaining(tvb, offset);\r\npdu_len = 4;\r\nGET_PDU_FROM_OFFSET(offset)\r\npdu_len = tvb_get_letohl(tvb, offset);\r\nproto_item_set_len(ti, 4);\r\nproto_tree_add_item(spice_tree, hf_spice_sasl_message_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\npdu_len += 4;\r\nGET_PDU_FROM_OFFSET(offset)\r\nproto_item_set_len(ti, pdu_len);\r\nproto_tree_add_uint(spice_tree, hf_spice_supported_authentication_mechanisms_list_length, tvb, offset, 4, pdu_len - 4);\r\noffset += 4;\r\nproto_tree_add_item(spice_tree, hf_spice_supported_authentication_mechanisms_list, tvb, offset, pdu_len - 4, ENC_NA|ENC_ASCII);\r\noffset += (pdu_len - 4);\r\nspice_info->next_state = SPICE_SASL_START_TO_SERVER;\r\nreturn offset;\r\ncase SPICE_SASL_START_TO_SERVER:\r\noffset = 0;\r\nwhile (offset < tvb_reported_length(tvb)) {\r\navail = tvb_reported_length_remaining(tvb, offset);\r\npdu_len = 4;\r\nGET_PDU_FROM_OFFSET(offset)\r\npdu_len = tvb_get_letohl(tvb, offset);\r\nproto_item_set_len(ti, 4);\r\nproto_tree_add_item(spice_tree, hf_spice_sasl_message_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nif (pdu_len == 0) {\r\nspice_info->next_state = SPICE_SASL_START_FROM_SERVER;\r\npdu_len = 4;\r\noffset += pdu_len;\r\n} else {\r\npdu_len += 4;\r\nGET_PDU_FROM_OFFSET(offset)\r\nproto_item_set_len(ti, pdu_len);\r\nif (client_sasl_list == FALSE) {\r\nclient_sasl_list = TRUE;\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Client selected SASL authentication mechanism (start to server)");\r\nproto_tree_add_uint(spice_tree, hf_spice_selected_authentication_mechanism_length, tvb, offset, 4, pdu_len - 4);\r\noffset += 4;\r\nproto_tree_add_item(spice_tree, hf_spice_selected_authentication_mechanism, tvb, offset, pdu_len - 4, ENC_NA|ENC_ASCII);\r\n} else {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Client out mechanism (start to server)");\r\nproto_tree_add_uint(spice_tree, hf_spice_client_out_mechanism_length, tvb, offset, 4, pdu_len - 4);\r\noffset += 4;\r\nproto_tree_add_item(spice_tree, hf_spice_selected_client_out_mechanism, tvb, offset, pdu_len - 4, ENC_NA|ENC_ASCII);\r\nspice_info->next_state = SPICE_SASL_START_FROM_SERVER;\r\n}\r\noffset += (pdu_len - 4);\r\n}\r\n}\r\nreturn pdu_len;\r\nbreak;\r\ncase SPICE_SASL_START_FROM_SERVER:\r\ncase SPICE_SASL_STEP_FROM_SERVER:\r\noffset = 0;\r\nwhile (offset < tvb_reported_length(tvb)) {\r\navail = tvb_reported_length_remaining(tvb, offset);\r\npdu_len = 4;\r\nGET_PDU_FROM_OFFSET(offset)\r\npdu_len = tvb_get_letohl(tvb, offset);\r\nproto_item_set_len(ti, 4 + pdu_len);\r\nproto_tree_add_item(spice_tree, hf_spice_sasl_message_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nif (pdu_len == 0) {\r\noffset += 4;\r\n} else {\r\npdu_len += 4;\r\nGET_PDU_FROM_OFFSET(offset)\r\noffset += 4;\r\nproto_tree_add_item(spice_tree, hf_spice_sasl_authentication_data, tvb, offset, pdu_len - 4, ENC_ASCII|ENC_NA);\r\noffset += (pdu_len - 4);\r\n}\r\n}\r\nif (per_packet_info->state == SPICE_SASL_START_FROM_SERVER) {\r\nspice_info->next_state = SPICE_SASL_START_FROM_SERVER_CONT;\r\n} else {\r\nspice_info->next_state = SPICE_SASL_STEP_FROM_SERVER_CONT;\r\n}\r\nreturn pdu_len;\r\nbreak;\r\ncase SPICE_SASL_START_FROM_SERVER_CONT:\r\ncase SPICE_SASL_STEP_FROM_SERVER_CONT:\r\noffset = 0;\r\navail = tvb_reported_length_remaining(tvb, offset);\r\nif (avail >= 1) {\r\nproto_item_set_len(ti, 1);\r\nsasl_auth_result = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(spice_tree, hf_spice_sasl_auth_result, tvb, offset, 1, ENC_NA);\r\nif (per_packet_info->state == SPICE_SASL_START_FROM_SERVER_CONT) {\r\nif (sasl_auth_result == 0) {\r\nspice_info->next_state = SPICE_SASL_STEP_TO_SERVER;\r\n} else {\r\nexpert_add_info_format(pinfo, ti, &ei_spice_sasl_auth_result, "SPICE_SASL_START_FROM_SERVER_CONT and sasl_auth_result is %d",\r\nsasl_auth_result);\r\n}\r\n} else {\r\nspice_info->next_state = SPICE_TICKET_SERVER;\r\n}\r\n}\r\nreturn 1;\r\nbreak;\r\ncase SPICE_SASL_STEP_TO_SERVER:\r\noffset = 0;\r\nwhile (offset < tvb_reported_length(tvb)) {\r\navail = tvb_reported_length_remaining(tvb, offset);\r\npdu_len = 4;\r\nGET_PDU_FROM_OFFSET(offset)\r\npdu_len = tvb_get_letohl(tvb, offset);\r\nproto_item_set_len(ti, 4);\r\nproto_tree_add_item(spice_tree, hf_spice_sasl_message_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nif (pdu_len == 0) {\r\ncol_set_str(pinfo->cinfo, COL_INFO, "SASL authentication from client (step to server)");\r\nspice_info->next_state = SPICE_SASL_STEP_FROM_SERVER;\r\npdu_len = 4;\r\noffset += pdu_len;\r\n} else {\r\npdu_len += 4;\r\nGET_PDU_FROM_OFFSET(offset)\r\nproto_item_set_len(ti, pdu_len);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Clientout (step to server)");\r\nproto_tree_add_uint(spice_tree, hf_spice_clientout_length, tvb, offset, 4, pdu_len - 4);\r\noffset += 4;\r\nproto_tree_add_item(spice_tree, hf_spice_clientout_list, tvb, offset, pdu_len - 4, ENC_NA|ENC_ASCII);\r\nspice_info->next_state = SPICE_SASL_STEP_FROM_SERVER;\r\noffset += (pdu_len - 4);\r\n}\r\n}\r\nreturn pdu_len;\r\nbreak;\r\ncase SPICE_SASL_DATA:\r\noffset = 0;\r\nwhile (offset < tvb_reported_length(tvb)) {\r\navail = tvb_reported_length_remaining(tvb, offset);\r\npdu_len = 4;\r\nGET_PDU_FROM_OFFSET(offset)\r\npdu_len = tvb_get_ntohl(tvb, offset);\r\nproto_item_set_len(ti, pdu_len);\r\nproto_tree_add_item(spice_tree, hf_spice_sasl_message_length, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nif (pdu_len == 0) {\r\nreturn 4;\r\n} else {\r\npdu_len += 4;\r\n}\r\nGET_PDU_FROM_OFFSET(offset)\r\nproto_item_set_len(ti, pdu_len);\r\ncol_add_fstr(pinfo->cinfo, COL_PROTOCOL,\r\n"Spice %s (SASL wrapped)", val_to_str_const(spice_info->channel_type,channel_types_vs, "Unknown"));\r\noffset += 4;\r\nproto_tree_add_bytes_format(spice_tree, hf_spice_sasl_data, tvb, offset, pdu_len - 4, NULL, "SASL data (%u bytes)", pdu_len - 4);\r\noffset += (pdu_len - 4);\r\n}\r\nreturn pdu_len;\r\nbreak;\r\ncase SPICE_DATA:\r\noffset = 0;\r\nwhile (offset < tvb_reported_length(tvb)) {\r\navail = tvb_reported_length_remaining(tvb, offset);\r\nif (spice_info->client_mini_header && spice_info->server_mini_header) {\r\npdu_len = sizeof_SpiceMiniDataHeader;\r\nGET_PDU_FROM_OFFSET(offset)\r\npdu_len = tvb_get_letohl(tvb, offset + 2);\r\npdu_len += sizeof_SpiceMiniDataHeader;\r\n} else {\r\npdu_len = sizeof_SpiceDataHeader;\r\nGET_PDU_FROM_OFFSET(offset)\r\npdu_len = tvb_get_letohl(tvb, offset + 10);\r\npdu_len += sizeof_SpiceDataHeader;\r\n}\r\nGET_PDU_FROM_OFFSET(offset)\r\nproto_item_set_len(ti, pdu_len);\r\nif (spice_info->destport == pinfo->destport) {\r\noffset = dissect_spice_data_client_pdu(tvb, spice_tree, pinfo, spice_info, offset);\r\n} else {\r\noffset = dissect_spice_data_server_pdu(tvb, spice_tree, pinfo, spice_info, offset, pdu_len);\r\n}\r\n}\r\nreturn offset;\r\nbreak;\r\ncase SPICE_TICKET_CLIENT:\r\nif (spice_info->destport != pinfo->destport)\r\nbreak;\r\navail = tvb_reported_length(tvb);\r\npdu_len = 128;\r\nGET_PDU_FROM_OFFSET(0)\r\nproto_item_set_len(ti, 128);\r\nproto_tree_add_item(spice_tree, hf_ticket_client, tvb, 0, 128, ENC_NA);\r\nspice_info->next_state = SPICE_TICKET_SERVER;\r\nreturn 128;\r\nbreak;\r\ncase SPICE_TICKET_SERVER:\r\nif (spice_info->destport != pinfo->srcport)\r\nbreak;\r\navail = tvb_reported_length(tvb);\r\npdu_len = 4;\r\nGET_PDU_FROM_OFFSET(0)\r\nproto_item_set_len(ti, 4);\r\nproto_tree_add_item(spice_tree, hf_ticket_server, tvb, 0, 4, ENC_LITTLE_ENDIAN);\r\nif (spice_info->auth_selected == SPICE_COMMON_CAP_AUTH_SASL) {\r\nspice_info->next_state = SPICE_SASL_DATA;\r\n} else {\r\nspice_info->next_state = SPICE_DATA;\r\n}\r\nreturn pdu_len;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic gboolean\r\ntest_spice_protocol(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nif ((tvb_reported_length(tvb) >= 4) && (tvb_get_ntohl(tvb, 0) == SPICE_MAGIC)) {\r\ndissect_spice(tvb, pinfo, tree, data);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nvoid\r\nproto_register_spice(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_link_client,\r\n{ "Link client header", "spice.link_client",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_link_server,\r\n{ "Link server header", "spice.link_server",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_magic,\r\n{ "SPICE MAGIC", "spice.magic",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_major_version,\r\n{ "Protocol major version", "spice.major_version",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_minor_version,\r\n{ "Protocol minor version", "spice.minor_version",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_message_size,\r\n{ "Message size", "spice.message_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_message_type,\r\n{ "Message type", "spice.message_type",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_conn_id,\r\n{ "Session ID", "spice.conn_id",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_channel_type,\r\n{ "Channel type", "spice.channel_type",\r\nFT_UINT8, BASE_DEC, VALS(channel_types_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_channel_id,\r\n{ "Channel ID", "spice.channel_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_num_common_caps,\r\n{ "Number of common capabilities", "spice.num_common_caps",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_num_channel_caps,\r\n{ "Number of channel capabilities", "spice.num_channel_caps",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_caps_offset,\r\n{ "Capabilities offset (bytes)", "spice.caps_offset",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_error_code,\r\n{ "spice ERROR", "spice.error_code",\r\nFT_UINT32, BASE_DEC, VALS(spice_link_err_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_serial,\r\n{ "Message serial number", "spice.serial",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_data,\r\n{ "Message header", "spice.message_header",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_data_size,\r\n{ "Message body size (bytes)", "spice.message_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_data_sublist,\r\n{ "Sub-list offset (bytes)", "spice.message_sublist",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ticket_client,\r\n{ "Ticket - client", "spice.ticket_client",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ticket_server,\r\n{ "Link result", "spice.ticket_server",\r\nFT_UINT32, BASE_DEC, VALS(spice_link_err_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_auth_select_client,\r\n{ "Authentication selected by client", "spice.auth_select_client",\r\nFT_UINT32, BASE_DEC, VALS(spice_auth_select_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_common_cap_auth_select,\r\n{ "Auth Selection", "spice.common_cap_auth_select",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_COMMON_CAP_PROTOCOL_AUTH_SELECTION_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_common_cap_auth_spice,\r\n{ "Auth Spice", "spice.common_cap_auth_spice",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_COMMON_CAP_AUTH_SPICE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_common_cap_auth_sasl,\r\n{ "Auth SASL", "spice.common_cap_auth_sasl",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_COMMON_CAP_AUTH_SASL_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_common_cap_mini_header,\r\n{ "Mini Header", "spice.common_cap_mini_header",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_COMMON_CAP_MINI_HEADER_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_record_cap_volume,\r\n{ "Volume record channel support", "spice.record_cap_volume",\r\nFT_BOOLEAN, 3, TFS(&tfs_set_notset), SPICE_RECORD_CAP_VOLUME_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_record_cap_celt,\r\n{ "CELT 0.5.1 record channel support", "spice.record_cap_celt",\r\nFT_BOOLEAN, 3, TFS(&tfs_set_notset), SPICE_RECORD_CAP_CELT_0_5_1_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_cap_sized_stream,\r\n{ "Sized stream display channel support", "spice.display_cap_sized_stream",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_DISPLAY_CAP_SIZED_STREAM_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_cap_monitors_config,\r\n{ "Monitors configuration display channel support", "spice.display_cap_monitors_config",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_DISPLAY_CAP_MONITORS_CONFIG_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_cap_composite,\r\n{ "Composite capability display channel support", "spice.display_cap_composite",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_DISPLAY_CAP_COMPOSITE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_cap_a8_surface,\r\n{ "A8 bitmap display channel support", "spice.display_cap_a8_surface",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_DISPLAY_CAP_A8_SURFACE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_cap,\r\n{ "Cursor channel capability", "spice.cursor_cap",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_inputs_cap,\r\n{ "Inputs channel capability", "spice.inputs_cap",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_main_num_channels,\r\n{ "Number of Channels", "spice.main_num_channels",\r\nFT_UINT32, 4, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_main_cap_semi_migrate,\r\n{ "Semi-seamless migration capability", "spice.main_cap_semi_migrate",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_MAIN_CAP_SEMI_SEAMLESS_MIGRATE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_main_cap_vm_name_uuid,\r\n{ "VM name and UUID messages capability", "spice.main_cap_vm_name_uuid",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_MAIN_CAP_VM_NAME_UUID_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_main_cap_agent_connected_tokens,\r\n{ "Agent connected tokens capability", "spice.main_cap_agent_connected_tokens",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_MAIN_CAP_AGENT_CONNECTED_TOKENS_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_main_cap_seamless_migrate,\r\n{ "Seamless migration capability", "spice.main_cap_seamless_migrate",\r\nFT_BOOLEAN, 4, TFS(&tfs_set_notset), SPICE_MAIN_CAP_SEAMLESS_MIGRATE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_audio_timestamp,\r\n{ "Timestamp", "spice.audio_timestamp",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_audio_mode,\r\n{ "Mode", "spice.audio_mode",\r\nFT_UINT16, BASE_DEC, VALS(playback_mode_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_audio_channels,\r\n{ "Channels", "spice.audio_channels",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_audio_format,\r\n{ "Format", "spice.audio_format",\r\nFT_UINT16, BASE_DEC, VALS(spice_audio_fmt_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_audio_frequency,\r\n{ "Frequency", "spice.audio_frequency",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_audio_volume,\r\n{ "Volume", "spice.audio_volume",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_audio_mute,\r\n{ "Mute", "spice.audio_mute",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_audio_latency,\r\n{ "Latency (ms)", "spice.audio_latency",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_red_set_ack_generation,\r\n{ "Set ACK generation", "spice.red_set_ack_generation",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_red_set_ack_window,\r\n{ "Set ACK window (messages)", "spice.red_set_ack_window",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_Clip_type,\r\n{ "Clip type", "spice.clip_type",\r\nFT_UINT8, BASE_DEC, VALS(spice_clip_type_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_Mask_flag,\r\n{ "Mask flag", "spice.mask_flag",\r\nFT_UINT8, BASE_DEC, VALS(spice_mask_flags_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_rop_descriptor,\r\n{ "ROP descriptor", "spice.display_rop_descriptor",\r\nFT_UINT16, BASE_HEX, VALS(spice_ropd_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_scale_mode,\r\n{ "Scale mode", "spice.scale_mode",\r\nFT_UINT8, BASE_DEC, VALS(spice_image_scale_mode_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_red_ping_id,\r\n{ "Ping ID", "spice.ping_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_red_timestamp,\r\n{ "timestamp", "spice.timestamp",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_display_mode_width,\r\n{ "Display Width", "spice.display_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_display_mode_height,\r\n{ "Display Height", "spice.display_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_display_mode_depth,\r\n{ "Color depth", "spice.display_depth",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_image_desc_id,\r\n{ "Image ID", "spice.image_id",\r\nFT_UINT64, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_image_desc_type,\r\n{ "Image type", "spice.image_type",\r\nFT_UINT8, BASE_DEC, VALS(spice_image_type_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_image_desc_flags,\r\n{ "Flags", "spice.image_flags",\r\nFT_UINT8, BASE_HEX, VALS(spice_image_flags_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_image_desc_width,\r\n{ "Width", "spice.image_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_image_desc_height,\r\n{ "Height", "spice.image_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_quic_width,\r\n{ "Width", "spice.quic_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_quic_type,\r\n{ "QUIC image type", "spice.quic_type",\r\nFT_UINT32, BASE_DEC, VALS(quic_type_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_quic_height,\r\n{ "Height", "spice.quic_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_quic_major_version,\r\n{ "QUIC major version", "spice.quic_major_version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_quic_minor_version,\r\n{ "QUIC minor version", "spice.quic_minor_version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_LZ_width,\r\n{ "Width", "spice.LZ_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_LZ_height,\r\n{ "Height", "spice.LZ_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_LZ_RGB_type,\r\n{ "Image type", "spice.LZ_RGB_type",\r\nFT_UINT8, BASE_DEC, VALS(LzImage_type_vs), 0xf,\r\nNULL, HFILL }\r\n},\r\n{ &hf_LZ_major_version,\r\n{ "LZ major version", "spice.LZ_major_version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_LZ_minor_version,\r\n{ "LZ minor version", "spice.LZ_minor_version",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_LZ_stride,\r\n{ "Stride", "spice.LZ_stride",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_LZ_RGB_dict_id,\r\n{ "LZ RGB Dictionary ID", "spice.LZ_RGB_dict_id",\r\nFT_UINT64, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_trail_len,\r\n{ "Cursor trail length", "spice.cursor_trail_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_trail_freq,\r\n{ "Cursor trail frequency", "spice.cursor_trail_freq",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_trail_visible,\r\n{ "Cursor trail visibility", "spice.cursor_trail_visible",\r\nFT_UINT8, BASE_DEC, VALS(cursor_visible_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_unique,\r\n{ "Cursor unique ID", "spice.cursor_unique",\r\nFT_UINT64, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_type,\r\n{ "Cursor type", "spice.cursor_type",\r\nFT_UINT8, BASE_HEX, VALS(spice_cursor_type_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_width,\r\n{ "Cursor width", "spice.cursor_width",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_height,\r\n{ "Cursor height", "spice.cursor_height",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_hotspot_x,\r\n{ "Cursor hotspot X", "spice.cursor_hotspot_x",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_hotspot_y,\r\n{ "Cursor hotspot Y", "spice.cursor_hotspot_y",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_flags,\r\n{ "Cursor flags", "spice.cursor_flags",\r\nFT_UINT16, BASE_HEX, VALS(spice_cursor_flags_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_cursor_id,\r\n{ "Cursor ID", "spice.cursor_id",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_display_init_cache_id,\r\n{ "Cache ID", "spice.display_init_cache_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_display_init_cache_size,\r\n{ "Cache size (pixels)", "spice.display_init_cache_size",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_display_init_glz_dict_id,\r\n{ "GLZ Dictionary ID", "spice.display_init_glz_dict_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_display_init_dict_window_size,\r\n{ "Dictionary window size", "spice.display_init_dict_window_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_brush_type,\r\n{ "Brush type", "spice.brush_type",\r\nFT_UINT8, BASE_DEC, VALS(spice_brush_type_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_brush_rgb,\r\n{ "Brush color", "spice.brush_rgb",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pixmap_width,\r\n{ "Pixmap width", "spice.pixmap_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pixmap_height,\r\n{ "Pixmap height", "spice.pixmap_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pixmap_stride,\r\n{ "Pixmap stride", "spice.pixmap_stride",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pixmap_address,\r\n{ "Pixmap palette pointer", "spice.pixmap_palette_address",\r\nFT_UINT32, BASE_HEX_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pixmap_format,\r\n{ "Pixmap format", "spice.pixmap_format",\r\nFT_UINT8, BASE_DEC, VALS(spice_bitmap_fmt_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_pixmap_flags,\r\n{ "Pixmap flags", "spice.pixmap_flags",\r\nFT_UINT8, BASE_HEX, VALS(spice_bitmap_flags_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_keyboard_modifiers,\r\n{ "Keyboard modifiers", "spice.keyboard_modifiers",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_keyboard_modifier_scroll_lock,\r\n{ "Scroll Lock", "spice.keyboard_modifier_scroll_lock",\r\nFT_BOOLEAN, 16, TFS(&tfs_set_notset), SPICE_KEYBOARD_MODIFIER_FLAGS_SCROLL_LOCK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_keyboard_modifier_num_lock,\r\n{ "Num Lock", "spice.keyboard_modifier_num_lock",\r\nFT_BOOLEAN, 16, TFS(&tfs_set_notset), SPICE_KEYBOARD_MODIFIER_FLAGS_NUM_LOCK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_keyboard_modifier_caps_lock,\r\n{ "Caps Lock", "spice.keyboard_modifier_caps_lock",\r\nFT_BOOLEAN, 16, TFS(&tfs_set_notset), SPICE_KEYBOARD_MODIFIER_FLAGS_CAPS_LOCK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_keyboard_code,\r\n{ "Key scan code", "spice.keyboard_key_code",\r\nFT_UINT32, BASE_DEC_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rectlist_size,\r\n{ "RectList size", "spice.rectlist_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_migrate_dest_port,\r\n{ "Migrate Dest Port", "spice.migrate_dest_port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_migrate_dest_sport,\r\n{ "Migrate Dest Secure Port", "spice.migrate_dest_sport",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_migrate_src_mig_version,\r\n{ "Migrate Source Migration Version", "spice.migrate_src_version",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_session_id,\r\n{ "Session ID", "spice.main_session_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_channels_hint,\r\n{ "Number of display channels", "spice.display_channels_hint",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_supported_mouse_modes,\r\n{ "Supported mouse modes", "spice.supported_mouse_modes",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_supported_mouse_modes_flags,\r\n{ "Supported mouse modes", "spice.supported_mouse_modes_flags",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_current_mouse_mode,\r\n{ "Current mouse mode", "spice.current_mouse_mode",\r\nFT_UINT32, BASE_HEX, VALS(spice_mouse_mode_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_supported_mouse_modes_flag_client,\r\n{ "Client mode", "spice.supported_mouse_modes_flag_client",\r\nFT_BOOLEAN, 2, TFS(&tfs_set_notset), SPICE_MOUSE_MODE_CLIENT,\r\nNULL, HFILL }\r\n},\r\n{ &hf_supported_mouse_modes_flag_server,\r\n{ "Server mode", "spice.supported_mouse_modes_flags_server",\r\nFT_BOOLEAN, 2, TFS(&tfs_set_notset), SPICE_MOUSE_MODE_SERVER,\r\nNULL, HFILL }\r\n},\r\n{ &hf_current_mouse_mode_flags,\r\n{ "Current mouse mode", "spice.current_mouse_mode_flags",\r\nFT_UINT16, BASE_HEX, VALS(spice_mouse_mode_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_connected,\r\n{ "Agent", "spice.agent",\r\nFT_UINT32, BASE_DEC, VALS(spice_agent_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_tokens,\r\n{ "Agent tokens", "spice.agent_tokens",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_multi_media_time,\r\n{ "Current server multimedia time", "spice.multimedia_time",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ram_hint,\r\n{ "RAM hint", "spice.ram_hint",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_button_state,\r\n{ "Mouse button state", "spice.button_state",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_mouse_display_id,\r\n{ "Mouse display ID", "spice.mouse_display_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_text_fore_mode,\r\n{ "Text foreground mode", "spice.draw_text_fore_mode",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_text_back_mode,\r\n{ "Text background mode", "spice.draw_text_back_mode",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_monitor_config_count,\r\n{ "Monitor count", "spice.monitor_config_count",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_monitor_config_max_allowed,\r\n{ "Max.allowed monitors", "spice.monitor_config_max_allowed",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_id,\r\n{ "Stream ID", "spice.display_stream_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_report_unique_id,\r\n{ "Unique ID", "spice.display_stream_report_unique_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_report_max_window_size,\r\n{ "Max window size", "spice.display_stream_report_max_window_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_report_timeout,\r\n{ "Timeout (ms)", "spice.display_stream_report_timeout",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_flags,\r\n{ "Stream flags", "spice.display_stream_flags",\r\nFT_UINT8, BASE_DEC, VALS(spice_stream_flags_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_codec_type,\r\n{ "Stream codec type", "spice.display_stream_codec_type",\r\nFT_UINT32, BASE_DEC, VALS(spice_video_codec_type_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_stamp,\r\n{ "Stream stamp", "spice.display_stream_stamp",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_data_size,\r\n{ "Stream data size", "spice.display_stream_data_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_width,\r\n{ "Stream width", "spice.stream_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_height,\r\n{ "Stream height", "spice.stream_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_src_width,\r\n{ "Stream source width", "spice.stream_src_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_stream_src_height,\r\n{ "Stream source height", "spice.stream_src_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_surface_id,\r\n{ "Surface ID", "spice.surface_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_surface_width,\r\n{ "Surface width", "spice.surface_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_surface_height,\r\n{ "Surface height", "spice.surface_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_surface_format,\r\n{ "Surface format", "spice.surface_format",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_surface_flags,\r\n{ "Surface flags", "spice.surface_flags",\r\nFT_UINT32, BASE_DEC, VALS(spice_surface_flags_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_tranparent_src_color,\r\n{ "Transparent source color", "spice.display_transparent_src_color",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_tranparent_true_color,\r\n{ "Transparent true color", "spice.display_transparent_true_color",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_main_client_agent_tokens,\r\n{ "Agent tokens", "spice.main_agent_tokens",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_protocol,\r\n{ "Agent Protocol version", "spice.main_agent_protocol",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_type,\r\n{ "Agent message type", "spice.agent_message_type",\r\nFT_UINT32, BASE_DEC, VALS(agent_message_type_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_opaque,\r\n{ "Agent Opaque", "spice.main_agent_opaque",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_size,\r\n{ "Agent message size", "spice.main_agent_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_token,\r\n{ "Agent token", "spice.main_agent_token",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_clipboard_selection,\r\n{ "Agent clipboard selection", "spice.main_agent_clipboard_selection",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_clipboard_type,\r\n{ "Agent clipboard type", "spice.main_agent_clipboard_type",\r\nFT_UINT32, BASE_DEC, VALS(agent_clipboard_type), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_LZ_PLT_type,\r\n{ "LZ_PLT image type", "spice.LZ_PLT_type",\r\nFT_UINT32, BASE_DEC, VALS(LzImage_type_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_sasl_auth_result,\r\n{ "Authentication result", "spice.sasl_auth_result",\r\nFT_UINT8, BASE_DEC, VALS(spice_sasl_auth_result_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_main_uuid,\r\n{ "UUID", "spice.main_uuid",\r\nFT_GUID, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_main_name_len,\r\n{ "Name length", "spice.main_name_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_main_name,\r\n{ "Name", "spice.main_name",\r\nFT_STRINGZ, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_head_id,\r\n{ "Head ID", "spice.display_head_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_head_surface_id,\r\n{ "Head surface ID", "spice.display_head_surface_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_head_width,\r\n{ "Head width", "spice.display_head_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_head_height,\r\n{ "Head height", "spice.display_head_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_head_x,\r\n{ "Head X coordinate", "spice.display_head_x",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_head_y,\r\n{ "Head Y coordinate", "spice.display_head_y",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_head_flags,\r\n{ "Head flags", "spice.display_head_flags",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_zlib_uncompress_size,\r\n{ "ZLIB stream uncompressed size", "spice.zlib_uncompress_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_zlib_compress_size,\r\n{ "ZLIB stream compressed size", "spice.zlib_compress_size",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rect_left,\r\n{ "left", "spice.rect.left",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rect_top,\r\n{ "top", "spice.rect.top",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rect_right,\r\n{ "right", "spice.rect.right",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_rect_bottom,\r\n{ "bottom", "spice.rect.bottom",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_point32_x,\r\n{ "x", "spice.point32.x",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_point32_y,\r\n{ "y", "spice.point32.y",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_point16_x,\r\n{ "x", "spice.point16.x",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_point16_y,\r\n{ "y", "spice.point16.y",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_severity,\r\n{ "Severity", "spice.notify_severity",\r\nFT_UINT32, BASE_DEC, VALS(spice_notify_severity_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_visibility,\r\n{ "Visibility", "spice.notify_visibility",\r\nFT_UINT32, BASE_DEC, VALS(spice_notify_visibility_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_notify_code,\r\n{ "error/warn/info code", "spice.notify_code",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_notify_message_len,\r\n{ "Message length", "spice.notify_message_length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_notify_message,\r\n{ "Message", "spice.notify_message",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_num_glyphs,\r\n{ "Number of glyphs", "spice.num_glyphs",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_port_opened,\r\n{ "Opened", "spice.port_opened",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_port_event,\r\n{ "Event", "spice.port_event",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_raw_data,\r\n{ "data", "spice.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_display_inval_list_count,\r\n{ "count", "spice.display_inval_list_count",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_resource_type,\r\n{ "Type", "spice.resource_type",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_resource_id,\r\n{ "id", "spice.resource_id",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ref_image,\r\n{ "Image address", "spice.ref_image",\r\nFT_UINT32, BASE_HEX_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ref_string,\r\n{ "String address", "spice.ref_string",\r\nFT_UINT32, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_num_monitors,\r\n{ "Number of monitors", "spice.agent_num_monitors",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_monitor_height,\r\n{ "Height", "spice.agent_monitor_height",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_monitor_width,\r\n{ "Width", "spice.agent_monitor_width",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_monitor_depth,\r\n{ "Depth", "spice.agent_monitor_depth",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_monitor_x,\r\n{ "x", "spice.agent_monitor_x",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_agent_monitor_y,\r\n{ "y", "spice.agent_monitor_y",\r\nFT_INT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_caps_request,\r\n{ "Request", "spice.vd_agent_caps_request",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_mouse_state,\r\n{ "Mouse State", "spice.vd_agent_cap_mouse_state",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_MOUSE_STATE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_monitors_config,\r\n{ "Monitors config", "spice.vd_agent_cap_monitors_config",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_MONITORS_CONFIG,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_reply,\r\n{ "Reply", "spice.vd_agent_cap_reply",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_REPLY,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_clipboard,\r\n{ "Clipboard", "spice.vd_agent_cap_clipboard",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_CLIPBOARD,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_display_config,\r\n{ "Display config", "spice.vd_agent_cap_display_config",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_DISPLAY_CONFIG,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_clipboard_by_demand,\r\n{ "Clipboard by demand", "spice.vd_agent_cap_clipboard_by_demand",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_CLIPBOARD_BY_DEMAND,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_clipboard_selection,\r\n{ "Clipboard selection", "spice.vd_agent_cap_clipboard_selection",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_CLIPBOARD_SELECTION,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_sparse_monitors_config,\r\n{ "Sparse monitors config", "spice.vd_agent_cap_sparse_monitors_config",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_SPARSE_MONITORS_CONFIG,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_guest_lineend_lf,\r\n{ "Guest line-end LF", "spice.vd_agent_cap_guest_lineend_lf",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_GUEST_LINEEND_LF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_cap_guest_lineend_crlf,\r\n{ "Guest line-end CRLF", "spice.vd_agent_cap_guest_lineend_crlf",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CAP_GUEST_LINEEND_CRLF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_monitors_config_flag_use_pos,\r\n{ "Use position", "spice.vd_agent_monitors_config_flag_use_pos",\r\nFT_BOOLEAN, 32, TFS(&tfs_set_notset), VD_AGENT_CONFIG_MONITORS_FLAG_USE_POS,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_reply_type,\r\n{ "Type", "spice.vd_agent_reply_type",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_vd_agent_reply_error,\r\n{ "Error", "spice.vd_agent_reply_error",\r\nFT_UINT32, BASE_DEC, VALS(vd_agent_reply_error_vs), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_spice_pixmap_pixels, { "Pixmap pixels", "spice.pixmap_pixels", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_pallete, { "Pallete", "spice.pallete", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_cursor_data, { "Cursor data", "spice.cursor_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_quic_image_size, { "QUIC image size", "spice.quic_image_size", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_quic_magic, { "QUIC magic", "spice.quic_magic", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_quic_compressed_image_data, { "QUIC compressed image data", "spice.quic_compressed_image_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_lz_magic, { "LZ magic", "spice.lz_magic", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_lz_rgb_compressed_image_data, { "LZ_RGB compressed image data", "spice.lz_rgb_compressed_image_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_topdown_flag, { "Topdown flag", "spice.topdown_flag", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_unknown_bytes, { "Unknown bytes", "spice.unknown_bytes", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n#if 0\r\n{ &hf_spice_lz_jpeg_image_size, { "LZ JPEG image size", "spice.lz_jpeg_image_size", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n#endif\r\n{ &hf_spice_glz_rgb_image_size, { "GLZ RGB image size", "spice.glz_rgb_image_size", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_lz_rgb_image_size, { "LZ RGB image size", "spice.lz_rgb_image_size", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_lz_plt_flag, { "LZ_PLT Flag", "spice.lz_plt_flag", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_lz_plt_image_size, { "LZ PLT image size", "spice.lz_plt_image_size", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_pallete_offset, { "pallete offset", "spice.pallete_offset", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_lz_plt_data, { "LZ_PLT data", "spice.lz_plt_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_zlib_stream, { "ZLIB stream", "spice.zlib_stream", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_image_from_cache, { "Image from Cache", "spice.image_from_cache", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_surface_id, { "Surface ID", "spice.surface_id", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_image_from_cache_lossless, { "Image from Cache - lossless", "spice.image_from_cache_lossless", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_ping_data, { "PING DATA", "spice.ping_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_display_mark_message, { "DISPLAY_MARK message", "spice.display_mark_message", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_display_reset_message, { "DISPLAY_RESET message", "spice.display_reset_message", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_rop3, { "ROP3", "spice.rop3", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_scale_mode, { "scale mode", "spice.scale_mode", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_glyph_flags, { "Glyph flags", "spice.glyph_flags", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_stream_data, { "Stream data", "spice.stream_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_vd_agent_clipboard_message, { "VD_AGENT_CLIPBOARD message", "spice.vd_agent_clipboard_message", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_vd_agent_display_config_message, { "VD_AGENT_DISPLAY_CONFIG message", "spice.vd_agent_display_config_message", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_reserved, { "Reserved", "spice.reserved", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_vd_agent_clipboard_release_message, { "VD_AGENT_CLIPBOARD_RELEASE message", "spice.vd_agent_clipboard_release_message", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_server_inputs_mouse_motion_ack_message, { "Server INPUTS_MOUSE_MOTION_ACK message", "spice.server_inputs_mouse_motion_ack_message", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_name_length, { "Name length (bytes)", "spice.name_length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_x509_subjectpublickeyinfo, { "X.509 SubjectPublicKeyInfo (ASN.1)", "spice.x509_subjectpublickeyinfo", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_sasl_message_length, { "SASL message length", "spice.sasl_message_length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_supported_authentication_mechanisms_list_length, { "Supported authentication mechanisms list length", "spice.supported_authentication_mechanisms_list_length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_supported_authentication_mechanisms_list, { "Supported authentication mechanisms list", "spice.supported_authentication_mechanisms_list", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_selected_authentication_mechanism_length, { "Selected authentication mechanism length", "spice.selected_authentication_mechanism_length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_selected_authentication_mechanism, { "Selected authentication mechanism", "spice.selected_authentication_mechanism", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_client_out_mechanism_length, { "Client out mechanism length", "spice.client_out_mechanism_length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_selected_client_out_mechanism, { "Selected client out mechanism", "spice.selected_client_out_mechanism", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_sasl_authentication_data, { "SASL authentication data", "spice.sasl_authentication_data", FT_STRINGZ, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_clientout_length, { "clientout length", "spice.clientout_length", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_clientout_list, { "clientout list", "spice.clientout_list", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_spice_sasl_data, { "SASL data", "spice.sasl_data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_spice,\r\n&ett_link_client,\r\n&ett_link_server,\r\n&ett_link_caps,\r\n&ett_ticket_client,\r\n&ett_auth_select_client,\r\n&ett_ticket_server,\r\n&ett_data,\r\n&ett_message,\r\n&ett_playback,\r\n&ett_common_server_message,\r\n&ett_common_client_message,\r\n&ett_display_client,\r\n&ett_display_server,\r\n&ett_point,\r\n&ett_point16,\r\n&ett_rect,\r\n&ett_DisplayBase,\r\n&ett_Clip,\r\n&ett_Mask,\r\n&ett_imagedesc,\r\n&ett_imageQuic,\r\n&ett_GLZ_RGB,\r\n&ett_LZ_RGB,\r\n&ett_ZLIB_GLZ,\r\n&ett_Uncomp_tree,\r\n&ett_LZ_JPEG,\r\n&ett_LZ_PLT,\r\n&ett_JPEG,\r\n&ett_cursor_header,\r\n&ett_RedCursor,\r\n&ett_cursor,\r\n&ett_spice_main,\r\n&ett_brush,\r\n&ett_pattern,\r\n&ett_Pixmap,\r\n&ett_SpiceHead,\r\n&ett_inputs_client,\r\n&ett_rectlist,\r\n&ett_inputs_server,\r\n&ett_record_client,\r\n&ett_record_server,\r\n&ett_main_client,\r\n&ett_spice_agent,\r\n&ett_cap_tree\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_spice_decompress_error, { "spice.decompress_error", PI_PROTOCOL, PI_WARN, "Error: Unable to decompress content", EXPFILL }},\r\n{ &ei_spice_unknown_message, { "spice.unknown_message", PI_UNDECODED, PI_WARN, "Unknown message - cannot dissect", EXPFILL }},\r\n{ &ei_spice_not_dissected, { "spice.not_dissected", PI_UNDECODED, PI_WARN, "Message not dissected", EXPFILL }},\r\n{ &ei_spice_auth_unknown, { "spice.auth_unknown", PI_PROTOCOL, PI_WARN, "Unknown authentication selected", EXPFILL }},\r\n{ &ei_spice_sasl_auth_result, { "spice.sasl_auth_result.expert", PI_PROTOCOL, PI_WARN, "Bad sasl_auth_result", EXPFILL }},\r\n{ &ei_spice_expected_from_client, { "spice.expected_from_client", PI_PROTOCOL, PI_WARN, "SPICE_CLIENT_AUTH_SELECT: packet from server - expected from client", EXPFILL }},\r\n{ &ei_spice_unknown_image_type, { "spice.unknown_image_type", PI_UNDECODED, PI_WARN, "Unknown image type - cannot dissect", EXPFILL }},\r\n{ &ei_spice_brush_type, { "spice.brush_type.invalid", PI_PROTOCOL, PI_WARN, "Invalid Brush type", EXPFILL }},\r\n{ &ei_spice_Mask_flag, { "spice.mask_flag.irrelevant", PI_PROTOCOL, PI_NOTE, "value irrelevant as bitmap address is 0", EXPFILL }},\r\n{ &ei_spice_Mask_point, { "spice.mask_point.irrelevant", PI_PROTOCOL, PI_NOTE, "value irrelevant as bitmap address is 0", EXPFILL }},\r\n{ &ei_spice_unknown_channel, { "spice.unknown_channel", PI_UNDECODED, PI_WARN, "Unknown channel - cannot dissect", EXPFILL }},\r\n{ &ei_spice_common_cap_unknown, { "spice.common_cap.unknown", PI_PROTOCOL, PI_WARN, "Unknown common capability", EXPFILL }},\r\n};\r\nexpert_module_t* expert_spice;\r\nproto_spice = proto_register_protocol("Spice protocol", "Spice", "spice");\r\nproto_register_field_array(proto_spice, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_spice = expert_register_protocol(proto_spice);\r\nexpert_register_field_array(expert_spice, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_spice(void)\r\n{\r\nspice_handle = create_dissector_handle(dissect_spice, proto_spice);\r\ndissector_add_for_decode_as("tcp.port", spice_handle);\r\nheur_dissector_add("tcp", test_spice_protocol, "Spice over TCP", "spice_tcp", proto_spice, HEURISTIC_ENABLE);\r\njpeg_handle = find_dissector_add_dependency("image-jfif", proto_spice);\r\n}
