static const char *\r\nget_sep_type(guint32 interface_id,\r\nguint32 adapter_id, guint32 chandle, guint32 direction, guint32 seid, guint32 frame_number)\r\n{\r\nwmem_tree_key_t key[6];\r\nwmem_tree_t *subtree;\r\nsep_entry_t *sep;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &direction;\r\nkey[4].length = 1;\r\nkey[4].key = &seid;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(sep_list, key);\r\nsep = (subtree) ? (sep_entry_t *) wmem_tree_lookup32_le(subtree, frame_number) : NULL;\r\nif (sep) {\r\nreturn val_to_str_const(sep->type, sep_type_vals, "unknown");\r\n}\r\nreturn "unknown";\r\n}\r\nstatic const char *\r\nget_sep_media_type(guint32 interface_id,\r\nguint32 adapter_id, guint32 chandle, guint32 direction, guint32 seid, guint32 frame_number)\r\n{\r\nwmem_tree_key_t key[6];\r\nwmem_tree_t *subtree;\r\nsep_entry_t *sep;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &direction;\r\nkey[4].length = 1;\r\nkey[4].key = &seid;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(sep_list, key);\r\nsep = (subtree) ? (sep_entry_t *) wmem_tree_lookup32_le(subtree, frame_number) : NULL;\r\nif (sep) {\r\nreturn val_to_str_const(sep->media_type, media_type_vals, "unknown");\r\n}\r\nreturn "unknown";\r\n}\r\nstatic gint\r\ndissect_sep(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset,\r\nguint32 interface_id, guint32 adapter_id, guint32 chandle)\r\n{\r\nproto_tree *sep_tree;\r\nproto_item *sep_item;\r\nguint i_sep = 1;\r\nguint media_type;\r\nguint type;\r\nguint seid;\r\nguint in_use;\r\nguint items;\r\nguint32 direction;\r\ndirection = (pinfo->p2p_dir == P2P_DIR_SENT) ? P2P_DIR_RECV : P2P_DIR_SENT;\r\nitems = tvb_reported_length_remaining(tvb, offset) / 2;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nseid = tvb_get_guint8(tvb, offset);\r\nin_use = seid & 0x02;\r\nseid = seid >> 2;\r\nmedia_type = tvb_get_guint8(tvb, offset + 1) >> 4;\r\ntype = (tvb_get_guint8(tvb, offset + 1) & 0x08) >> 3;\r\nsep_item = proto_tree_add_none_format(tree, hf_btavdtp_acp_sep, tvb, offset, 2, "ACP SEP [%u - %s %s] item %u/%u",\r\nseid, val_to_str_const(media_type, media_type_vals, "unknown"),\r\nval_to_str_const(type, sep_type_vals, "unknown"), i_sep, items);\r\nsep_tree = proto_item_add_subtree(sep_item, ett_btavdtp_sep);\r\nproto_tree_add_item(sep_tree, hf_btavdtp_sep_seid , tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(sep_tree, hf_btavdtp_sep_inuse, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(sep_tree, hf_btavdtp_sep_rfa0 , tvb, offset, 1, ENC_NA);\r\noffset+=1;\r\nproto_tree_add_item(sep_tree, hf_btavdtp_sep_media_type, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(sep_tree, hf_btavdtp_sep_type , tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(sep_tree, hf_btavdtp_sep_rfa1 , tvb, offset, 1, ENC_NA);\r\nif (!pinfo->fd->flags.visited) {\r\nsep_entry_t *sep_data;\r\nwmem_tree_key_t key[7];\r\nguint32 frame_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &direction;\r\nkey[4].length = 1;\r\nkey[4].key = &seid;\r\nkey[5].length = 1;\r\nkey[5].key = &frame_number;\r\nkey[6].length = 0;\r\nkey[6].key = NULL;\r\nsep_data = wmem_new(wmem_file_scope(), sep_entry_t);\r\nsep_data->seid = seid;\r\nsep_data->type = type;\r\nsep_data->media_type = media_type;\r\nsep_data->int_seid = 0;\r\nsep_data->codec = -1;\r\nsep_data->content_protection_type = 0;\r\nif (in_use) {\r\nsep_data->state = SEP_STATE_IN_USE;\r\n} else {\r\nsep_data->state = SEP_STATE_FREE;\r\n}\r\nwmem_tree_insert32_array(sep_list, key, sep_data);\r\n}\r\noffset += 1;\r\ni_sep += 1;\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - items: %u", items);\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_codec(tvbuff_t *tvb, packet_info *pinfo, proto_item *service_item, proto_tree *tree, gint offset,\r\nguint losc, gint media_type, gint media_codec_type, guint32 *vendor_id, guint16 *vendor_codec)\r\n{\r\nproto_item *pitem;\r\nguint32 value;\r\nguint8 *value8 = (guint8 *) &value;\r\nswitch(media_type) {\r\ncase MEDIA_TYPE_AUDIO:\r\nswitch(media_codec_type) {\r\ncase CODEC_SBC:\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_sampling_frequency_16000, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_sampling_frequency_32000, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_sampling_frequency_44100, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_sampling_frequency_48000, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_channel_mode_mono, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_channel_mode_dual_channel, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_channel_mode_stereo, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_channel_mode_joint_stereo, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_block_4, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_block_8, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_block_12, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_block_16, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_subbands_4, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_subbands_8, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_allocation_method_snr, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_sbc_allocation_method_loudness, tvb, offset + 1, 1, ENC_NA);\r\npitem = proto_tree_add_item(tree, hf_btavdtp_sbc_min_bitpool, tvb, offset + 2, 1, ENC_NA);\r\nvalue = tvb_get_guint8(tvb, offset + 2);\r\nif (value < 2 || value > 250) {\r\nexpert_add_info(pinfo, pitem, &ei_btavdtp_sbc_min_bitpool_out_of_range);\r\n}\r\npitem = proto_tree_add_item(tree, hf_btavdtp_sbc_max_bitpool, tvb, offset + 3, 1, ENC_NA);\r\nvalue = tvb_get_guint8(tvb, offset + 3);\r\nif (value < 2 || value > 250) {\r\nexpert_add_info(pinfo, pitem, &ei_btavdtp_sbc_max_bitpool_out_of_range);\r\n}\r\nvalue = tvb_get_h_guint32(tvb, offset);\r\nif (value) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (%s%s%s%s%s| %s%s%s%s%s| block: %s%s%s%s%s| subbands: %s%s%s| allocation: %s%s%s| bitpool: %u..%u)",\r\n(value8[0] & 0x80) ? "16000 " : "",\r\n(value8[0] & 0x40) ? "32000 " : "",\r\n(value8[0] & 0x20) ? "44100 " : "",\r\n(value8[0] & 0x10) ? "48000 " : "",\r\n(value8[0] & 0xF0) ? "" : "not set ",\r\n(value8[0] & 0x08) ? "Mono " : "",\r\n(value8[0] & 0x04) ? "DualChannel " : "",\r\n(value8[0] & 0x02) ? "Stereo " : "",\r\n(value8[0] & 0x01) ? "JointStereo " : "",\r\n(value8[0] & 0x0F) ? "" : "not set ",\r\n(value8[1] & 0x80) ? "4 " : "",\r\n(value8[1] & 0x40) ? "8 " : "",\r\n(value8[1] & 0x20) ? "12 " : "",\r\n(value8[1] & 0x10) ? "16 " : "",\r\n(value8[1] & 0xF0) ? "" : "not set ",\r\n(value8[1] & 0x08) ? "4 " : "",\r\n(value8[1] & 0x04) ? "8 " : "",\r\n(value8[1] & 0x0C) ? "" : "not set ",\r\n(value8[1] & 0x02) ? "SNR " : "",\r\n(value8[1] & 0x01) ? "Loudness " : "",\r\n(value8[0] & 0x03) ? "" : "not set ",\r\nvalue8[2],\r\nvalue8[3]);\r\nproto_item_append_text(service_item, " (%s%s%s%s%s| %s%s%s%s%s| block: %s%s%s%s%s| subbands: %s%s%s| allocation: %s%s%s| bitpool: %u..%u)",\r\n(value8[0] & 0x80) ? "16000 " : "",\r\n(value8[0] & 0x40) ? "32000 " : "",\r\n(value8[0] & 0x20) ? "44100 " : "",\r\n(value8[0] & 0x10) ? "48000 " : "",\r\n(value8[0] & 0xF0) ? "" : "not set ",\r\n(value8[0] & 0x08) ? "Mono " : "",\r\n(value8[0] & 0x04) ? "DualChannel " : "",\r\n(value8[0] & 0x02) ? "Stereo " : "",\r\n(value8[0] & 0x01) ? "JointStereo " : "",\r\n(value8[0] & 0x0F) ? "" : "not set ",\r\n(value8[1] & 0x80) ? "4 " : "",\r\n(value8[1] & 0x40) ? "8 " : "",\r\n(value8[1] & 0x20) ? "12 " : "",\r\n(value8[1] & 0x10) ? "16 " : "",\r\n(value8[1] & 0xF0) ? "" : "not set ",\r\n(value8[1] & 0x08) ? "4 " : "",\r\n(value8[1] & 0x04) ? "8 " : "",\r\n(value8[1] & 0x0C) ? "" : "not set ",\r\n(value8[1] & 0x02) ? "SNR " : "",\r\n(value8[1] & 0x01) ? "Loudness " : "",\r\n(value8[0] & 0x03) ? "" : "not set ",\r\nvalue8[2],\r\nvalue8[3]);\r\n} else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (none)");\r\nproto_item_append_text(service_item, " (none)");\r\n}\r\nbreak;\r\ncase CODEC_MPEG12_AUDIO:\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_layer_1, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_layer_2, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_layer_3, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_crc_protection, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_channel_mode_mono, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_channel_mode_dual_channel, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_channel_mode_stereo, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_channel_mode_joint_stereo, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_rfa, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_mpf_2, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_sampling_frequency_16000, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_sampling_frequency_22050, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_sampling_frequency_24000, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_sampling_frequency_32000, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_sampling_frequency_44100, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_sampling_frequency_48000, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_vbr_supported, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg12_bit_rate, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CODEC_MPEG24_AAC:\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_object_type_mpeg2_aac_lc, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_object_type_mpeg4_aac_lc, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_object_type_mpeg4_aac_ltp, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_object_type_mpeg4_aac_scalable, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_object_type_rfa, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_8000, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_11025, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_12000, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_16000, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_22050, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_24000, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_32000, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_44100, tvb, offset + 1, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_48000, tvb, offset + 2, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_64000, tvb, offset + 2, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_88200, tvb, offset + 2, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_sampling_frequency_96000, tvb, offset + 2, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_channels_1, tvb, offset + 2, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_channels_2, tvb, offset + 2, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_rfa, tvb, offset + 2, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_vbr_supported, tvb, offset + 3, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg24_bit_rate, tvb, offset + 3, 3, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase CODEC_ATRAC:\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_version, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_channel_mode_single_channel, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_channel_mode_dual_channel, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_channel_mode_joint_stereo, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_rfa1, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_rfa2, tvb, offset + 1, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_sampling_frequency_44100, tvb, offset + 1, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_sampling_frequency_48000, tvb, offset + 1, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_vbr_supported, tvb, offset + 3, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_bit_rate, tvb, offset + 3, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_maximum_sul, tvb, offset + 4, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_atrac_rfa3, tvb, offset + 6, 1, ENC_NA);\r\nbreak;\r\ncase CODEC_VENDOR:\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nif (vendor_id)\r\n*vendor_id = tvb_get_letohl(tvb, offset);\r\nif (vendor_codec)\r\n*vendor_codec = tvb_get_letohs(tvb, offset + 4);\r\nswitch (tvb_get_letohl(tvb, offset)) {\r\ncase 0x004F:\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_apt_codec_id, tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);\r\nvalue = tvb_get_letohs(tvb, offset + 4);\r\nif (value == 0x0001) {\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_aptx_sampling_frequency_16000, tvb, offset + 6, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_aptx_sampling_frequency_32000, tvb, offset + 6, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_aptx_sampling_frequency_44100, tvb, offset + 6, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_aptx_sampling_frequency_48000, tvb, offset + 6, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_aptx_channel_mode_mono, tvb, offset + 6, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_aptx_channel_mode_dual_channel, tvb, offset + 6, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_aptx_channel_mode_stereo, tvb, offset + 6, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_aptx_channel_mode_joint_stereo, tvb, offset + 6, 1, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (%s -",\r\nval_to_str_const(value, vendor_apt_codec_vals, "unknown codec"));\r\nproto_item_append_text(service_item, " (%s -",\r\nval_to_str_const(value, vendor_apt_codec_vals, "unknown codec"));\r\nvalue = tvb_get_guint8(tvb, offset + 6);\r\nif (value) {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s%s%s%s%s,%s%s%s%s%s)",\r\n(value & 0x80) ? " 16000" : "",\r\n(value & 0x40) ? " 32000" : "",\r\n(value & 0x20) ? " 44100" : "",\r\n(value & 0x10) ? " 48000" : "",\r\n(value & 0xF0) ? "" : "not set ",\r\n(value & 0x08) ? " Mono" : "",\r\n(value & 0x04) ? " DualChannel" : "",\r\n(value & 0x02) ? " Stereo" : "",\r\n(value & 0x01) ? " JointStereo" : "",\r\n(value & 0x0F) ? "" : "not set ");\r\nproto_item_append_text(service_item, "%s%s%s%s%s,%s%s%s%s%s)",\r\n(value & 0x80) ? " 16000" : "",\r\n(value & 0x40) ? " 32000" : "",\r\n(value & 0x20) ? " 44100" : "",\r\n(value & 0x10) ? " 48000" : "",\r\n(value & 0xF0) ? "" : "not set ",\r\n(value & 0x08) ? " Mono" : "",\r\n(value & 0x04) ? " DualChannel" : "",\r\n(value & 0x02) ? " Stereo" : "",\r\n(value & 0x01) ? " JointStereo" : "",\r\n(value & 0x0F) ? "" : "not set ");\r\n} else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " none)");\r\nproto_item_append_text(service_item, " none)");\r\n}\r\n} else {\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_value, tvb, offset + 6, losc - 6, ENC_NA);\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_codec_id, tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_value, tvb, offset + 6, losc - 6, ENC_NA);\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_btavdtp_data, tvb, offset, losc, ENC_NA);\r\n}\r\nbreak;\r\ncase MEDIA_TYPE_VIDEO:\r\nswitch(media_codec_type) {\r\ncase CODEC_H263_BASELINE:\r\ncase CODEC_H263_PROFILE_3:\r\ncase CODEC_H263_PROFILE_8:\r\nproto_tree_add_item(tree, hf_btavdtp_h263_level_10, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_h263_level_20, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_h263_level_30, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_h263_level_rfa, tvb, offset, 1, ENC_NA);\r\nbreak;\r\ncase CODEC_MPEG4_VSP:\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg4_level_0, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg4_level_1, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg4_level_2, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg4_level_3, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_btavdtp_mpeg4_level_rfa, tvb, offset, 1, ENC_NA);\r\nbreak;\r\ncase CODEC_VENDOR:\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_id, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_codec_id, tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(tree, hf_btavdtp_vendor_specific_value, tvb, offset + 6, losc - 6, ENC_NA);\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_btavdtp_data, tvb, offset, losc, ENC_NA);\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(tree, hf_btavdtp_data, tvb, offset, losc, ENC_NA);\r\n}\r\noffset += losc;\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_capabilities(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, gint offset, gint *codec,\r\ngint *content_protection_type, guint32 *vendor_id,\r\nguint16 *vendor_codec, guint32 *configuration_offset,\r\nguint8 *configuration_length)\r\n{\r\nproto_item *pitem = NULL;\r\nproto_item *ptree = NULL;\r\nproto_tree *capabilities_tree;\r\nproto_item *capabilities_item;\r\nproto_tree *service_tree = NULL;\r\nproto_item *service_item = NULL;\r\ngint service_category = 0;\r\ngint losc = 0;\r\ngint recovery_type = 0;\r\ngint maximum_recovery_window_size = 0;\r\ngint maximum_number_of_media_packet_in_parity_code = 0;\r\ngint media_type = 0;\r\ngint media_codec_type = 0;\r\ncapabilities_item = proto_tree_add_item(tree, hf_btavdtp_capabilities, tvb, offset, tvb_reported_length(tvb) - offset, ENC_NA);\r\ncapabilities_tree = proto_item_add_subtree(capabilities_item, ett_btavdtp_capabilities);\r\nif (codec)\r\n*codec = -1;\r\nif (vendor_id)\r\n*vendor_id = 0x003F;\r\nif (vendor_codec)\r\n*vendor_codec = 0;\r\nif (configuration_length)\r\n*configuration_length = 0;\r\nif (configuration_offset)\r\n*configuration_offset = 0;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nservice_category = tvb_get_guint8(tvb, offset);\r\nlosc = tvb_get_guint8(tvb, offset + 1);\r\nservice_item = proto_tree_add_none_format(capabilities_tree, hf_btavdtp_service, tvb, offset, 2 + losc, "Service: %s", val_to_str_const(service_category, service_category_vals, "RFD"));\r\nservice_tree = proto_item_add_subtree(service_item, ett_btavdtp_service);\r\nproto_tree_add_item(service_tree, hf_btavdtp_service_category, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(service_tree, hf_btavdtp_length_of_service_category, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nswitch (service_category) {\r\ncase SERVICE_CATEGORY_MEDIA_TRANSPORT:\r\ncase SERVICE_CATEGORY_REPORTING:\r\ncase SERVICE_CATEGORY_DELAY_REPORTING:\r\nbreak;\r\ncase SERVICE_CATEGORY_RECOVERY:\r\nrecovery_type = tvb_get_guint8(tvb, offset);\r\npitem = proto_tree_add_item(service_tree, hf_btavdtp_recovery_type, tvb, offset, 1, ENC_NA);\r\nproto_item_append_text(pitem, " (%s)", val_to_str_const(recovery_type, recovery_type_vals, "RFD"));\r\noffset += 1;\r\nlosc -= 1;\r\nmaximum_recovery_window_size = tvb_get_guint8(tvb, offset);\r\npitem = proto_tree_add_item(service_tree, hf_btavdtp_maximum_recovery_window_size, tvb, offset, 1, ENC_NA);\r\nif (maximum_recovery_window_size == 0x00) {\r\nproto_item_append_text(pitem, " (Forbidden)");\r\n} else if (maximum_recovery_window_size >= 0x18) {\r\nproto_item_append_text(pitem, " (Undocumented)");\r\n}\r\noffset += 1;\r\nlosc -= 1;\r\nmaximum_number_of_media_packet_in_parity_code = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(service_tree, hf_btavdtp_maximum_number_of_media_packet_in_parity_code, tvb, offset, 1, ENC_NA);\r\npitem = proto_tree_add_item(service_tree, hf_btavdtp_maximum_recovery_window_size, tvb, offset, 1, ENC_NA);\r\nif (maximum_number_of_media_packet_in_parity_code == 0x00) {\r\nproto_item_append_text(pitem, " (Forbidden)");\r\n} else if (maximum_number_of_media_packet_in_parity_code >= 0x18) {\r\nproto_item_append_text(pitem, " (Undocumented)");\r\n}\r\noffset += 1;\r\nlosc -= 1;\r\nbreak;\r\ncase SERVICE_CATEGORY_MEDIA_CODEC:\r\nif (configuration_length)\r\n*configuration_length = losc;\r\nif (configuration_offset)\r\n*configuration_offset = offset;\r\nmedia_type = tvb_get_guint8(tvb, offset) >> 4;\r\nproto_tree_add_item(service_tree, hf_btavdtp_media_codec_media_type, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(service_tree, hf_btavdtp_media_codec_rfa , tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nlosc -= 1;\r\nmedia_codec_type = tvb_get_guint8(tvb, offset);\r\nif (codec) {\r\n*codec = media_codec_type;\r\n}\r\nif (media_type == MEDIA_TYPE_AUDIO) {\r\nproto_tree_add_item(service_tree, hf_btavdtp_media_codec_audio_type, tvb, offset, 1, ENC_NA);\r\nproto_item_append_text(service_item, " - Audio %s",\r\nval_to_str_const(media_codec_type, media_codec_audio_type_vals, "unknown codec"));\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - Audio %s",\r\nval_to_str_const(media_codec_type, media_codec_audio_type_vals, "unknown codec"));\r\n} else if (media_type == MEDIA_TYPE_VIDEO) {\r\nproto_tree_add_item(service_tree, hf_btavdtp_media_codec_video_type, tvb, offset, 1, ENC_NA);\r\nproto_item_append_text(service_item, " - Video %s",\r\nval_to_str_const(media_codec_type, media_codec_video_type_vals, "unknown codec"));\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - Video %s",\r\nval_to_str_const(media_codec_type, media_codec_video_type_vals, "unknown codec"));\r\n} else {\r\nproto_tree_add_item(service_tree, hf_btavdtp_media_codec_unknown_type, tvb, offset, 1, ENC_NA);\r\nproto_item_append_text(service_item, " - Unknown 0x%02x", media_codec_type);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - Unknown 0x%02x", media_codec_type);\r\n}\r\noffset += 1;\r\nlosc -= 1;\r\noffset = dissect_codec(tvb, pinfo, service_item, service_tree,\r\noffset, losc, media_type, media_codec_type,\r\nvendor_id, vendor_codec);\r\nlosc = 0;\r\nbreak;\r\ncase SERVICE_CATEGORY_CONTENT_PROTECTION:\r\nproto_tree_add_item(service_tree, hf_btavdtp_content_protection_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);\r\nif (content_protection_type) {\r\n*content_protection_type = tvb_get_letohs(tvb, offset);\r\n}\r\nproto_item_append_text(service_item, " - %s",\r\nval_to_str_const(tvb_get_letohs(tvb, offset), content_protection_type_vals, "unknown"));\r\noffset += 2;\r\nlosc -= 2;\r\nif (losc > 0) {\r\nproto_tree_add_item(service_tree, hf_btavdtp_data, tvb, offset, losc, ENC_NA);\r\noffset += losc;\r\nlosc = 0;\r\n}\r\nbreak;\r\ncase SERVICE_CATEGORY_HEADER_COMPRESSION:\r\nproto_tree_add_item(service_tree, hf_btavdtp_header_compression_backch, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(service_tree, hf_btavdtp_header_compression_media, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(service_tree, hf_btavdtp_header_compression_recovery, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(service_tree, hf_btavdtp_header_compression_rfa, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nlosc -= 1;\r\nbreak;\r\ncase SERVICE_CATEGORY_MULTIPLEXING:\r\nproto_tree_add_item(service_tree, hf_btavdtp_multiplexing_fragmentation, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(service_tree, hf_btavdtp_multiplexing_rfa, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nlosc -= 1;\r\nif (losc >= 2) {\r\npitem = proto_tree_add_none_format(service_tree, hf_btavdtp_service_multiplexing_entry, tvb, offset, 1 + losc, "Entry: Media Transport Session");\r\nptree = proto_item_add_subtree(pitem, ett_btavdtp_service);\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_tsid, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_entry_rfa, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nlosc -= 1;\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_tcid, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_entry_rfa, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nlosc -= 1;\r\n}\r\nif (losc >= 2) {\r\npitem = proto_tree_add_none_format(service_tree, hf_btavdtp_service_multiplexing_entry, tvb, offset, 1 + losc, "Entry: Reporting Transport Session");\r\nptree = proto_item_add_subtree(pitem, ett_btavdtp_service);\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_tsid, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_entry_rfa, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nlosc -= 1;\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_tcid, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_entry_rfa, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nlosc -= 1;\r\n}\r\nif (losc >= 2) {\r\npitem = proto_tree_add_none_format(service_tree, hf_btavdtp_service_multiplexing_entry, tvb, offset, 1 + losc, "Entry: Recovery Transport Session");\r\nptree = proto_item_add_subtree(pitem, ett_btavdtp_service);\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_tsid, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_entry_rfa, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nlosc -= 1;\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_tcid, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(ptree, hf_btavdtp_multiplexing_entry_rfa, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nlosc -= 1;\r\n}\r\nbreak;\r\ndefault:\r\nproto_tree_add_item(service_tree, hf_btavdtp_data, tvb, offset, losc, ENC_NA);\r\noffset += losc;\r\nlosc = 0;\r\n}\r\nif (losc > 0) {\r\npitem = proto_tree_add_item(service_tree, hf_btavdtp_data, tvb, offset, losc, ENC_NA);\r\noffset += losc;\r\nexpert_add_info(pinfo, pitem, &ei_btavdtp_unexpected_losc_data);\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_seid(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset,\r\ngint seid_side, gint i_item, guint32 *sep_seid,\r\nguint32 interface_id, guint32 adapter_id, guint32 chandle,\r\nguint32 frame_number)\r\n{\r\nguint32 seid;\r\nproto_tree *seid_tree = NULL;\r\nproto_item *seid_item = NULL;\r\nguint32 direction;\r\nseid = tvb_get_guint8(tvb, offset) >> 2;\r\nif (sep_seid) {\r\n*sep_seid = seid;\r\n}\r\nif (seid_side == SEID_ACP) {\r\ndirection = pinfo->p2p_dir;\r\nseid_item = proto_tree_add_none_format(tree, hf_btavdtp_acp_seid_item, tvb, offset, 1,\r\n"ACP SEID [%u - %s %s]", seid,\r\nget_sep_media_type(interface_id, adapter_id, chandle, direction, seid, frame_number),\r\nget_sep_type(interface_id, adapter_id, chandle, direction, seid, frame_number));\r\nseid_tree = proto_item_add_subtree(seid_item, ett_btavdtp_sep);\r\nproto_tree_add_item(seid_tree, hf_btavdtp_acp_seid, tvb, offset, 1, ENC_NA);\r\nif (i_item > 0) proto_item_append_text(seid_item, " item %u", i_item);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - ACP SEID [%u - %s %s]",\r\nseid, get_sep_media_type(interface_id, adapter_id, chandle, direction, seid, frame_number),\r\nget_sep_type(interface_id, adapter_id, chandle, direction, seid, frame_number));\r\n} else {\r\ndirection = (pinfo->p2p_dir == P2P_DIR_SENT) ? P2P_DIR_RECV : P2P_DIR_SENT;\r\nseid_item = proto_tree_add_none_format(tree, hf_btavdtp_int_seid_item, tvb, offset, 1,\r\n"INT SEID [%u - %s %s]", seid,\r\nget_sep_media_type(interface_id, adapter_id, chandle, direction, seid, frame_number),\r\nget_sep_type(interface_id, adapter_id, chandle, direction, seid, frame_number));\r\nseid_tree = proto_item_add_subtree(seid_item, ett_btavdtp_sep);\r\nproto_tree_add_item(seid_tree, hf_btavdtp_int_seid, tvb, offset, 1, ENC_NA);\r\nif (i_item > 0) proto_item_append_text(seid_item, " item %u", i_item);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " - INT SEID [%u - %s %s]",\r\nseid, get_sep_media_type(interface_id, adapter_id, chandle, direction, seid, frame_number),\r\nget_sep_type(interface_id, adapter_id, chandle, direction, seid, frame_number));\r\n}\r\nproto_tree_add_item(seid_tree, hf_btavdtp_rfa_seid, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic gint\r\ndissect_btavdtp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *ti;\r\nproto_tree *btavdtp_tree = NULL;\r\nproto_tree *signal_tree = NULL;\r\nproto_item *signal_item = NULL;\r\nbtl2cap_data_t *l2cap_data;\r\ngint offset = 0;\r\ngint i_sep = 1;\r\ngint packet_type = 0;\r\ngint message_type = 0;\r\ngint signal_id = 0;\r\nguint delay;\r\nwmem_tree_t *subtree;\r\nwmem_tree_key_t key[8];\r\nchannels_info_t *channels_info;\r\nguint32 interface_id;\r\nguint32 adapter_id;\r\nguint32 chandle;\r\nguint32 psm;\r\nguint32 direction;\r\nguint32 cid;\r\nguint32 frame_number;\r\nsep_entry_t *sep;\r\ntvbuff_t *next_tvb;\r\nguint32 seid;\r\ngint codec = -1;\r\ngint content_protection_type = 0;\r\nguint32 configuration_offset;\r\nguint8 configuration_length;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "AVDTP");\r\ndirection = pinfo->p2p_dir;\r\nswitch (direction) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");\r\ngoto LABEL_data;\r\n}\r\nl2cap_data = (btl2cap_data_t *) data;\r\nDISSECTOR_ASSERT(l2cap_data);\r\ninterface_id = l2cap_data->interface_id;\r\nadapter_id = l2cap_data->adapter_id;\r\nchandle = l2cap_data->chandle;\r\npsm = l2cap_data->psm;\r\ncid = l2cap_data->cid;\r\nframe_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &psm;\r\nkey[4].length = 0;\r\nkey[4].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(channels, key);\r\nchannels_info = (subtree) ? (channels_info_t *) wmem_tree_lookup32_le(subtree, frame_number) : NULL;\r\nif (!(channels_info &&\r\n((*channels_info->adapter_disconnect_in_frame >= pinfo->num &&\r\n*channels_info->hci_disconnect_in_frame >= pinfo->num &&\r\n*channels_info->l2cap_disconnect_in_frame >= pinfo->num &&\r\nchannels_info->disconnect_in_frame >= pinfo->num) ||\r\n(*channels_info->adapter_disconnect_in_frame == 0 ||\r\n*channels_info->hci_disconnect_in_frame == 0 ||\r\n*channels_info->l2cap_disconnect_in_frame == 0 ||\r\nchannels_info->disconnect_in_frame == 0)))) {\r\nchannels_info = (channels_info_t *) wmem_new (wmem_file_scope(), channels_info_t);\r\nchannels_info->control_local_cid = l2cap_data->local_cid;\r\nchannels_info->control_remote_cid = l2cap_data->remote_cid;\r\nchannels_info->media_local_cid = BTL2CAP_UNKNOWN_CID;\r\nchannels_info->media_remote_cid = BTL2CAP_UNKNOWN_CID;\r\nchannels_info->disconnect_in_frame = max_disconnect_in_frame;\r\nchannels_info->l2cap_disconnect_in_frame = l2cap_data->disconnect_in_frame;\r\nchannels_info->hci_disconnect_in_frame = l2cap_data->hci_disconnect_in_frame;\r\nchannels_info->adapter_disconnect_in_frame = l2cap_data->adapter_disconnect_in_frame;\r\nchannels_info->sep = NULL;\r\nif (!pinfo->fd->flags.visited || (\r\n*channels_info->adapter_disconnect_in_frame == 0 ||\r\n*channels_info->hci_disconnect_in_frame == 0 ||\r\n*channels_info->l2cap_disconnect_in_frame == 0 ||\r\nchannels_info->disconnect_in_frame == 0)) {\r\nkey[4].length = 1;\r\nkey[4].key = &frame_number;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nchannels_info->stream_numbers = wmem_tree_new(wmem_file_scope());\r\nif (*channels_info->adapter_disconnect_in_frame > 0 &&\r\n*channels_info->hci_disconnect_in_frame > 0 &&\r\n*channels_info->l2cap_disconnect_in_frame > 0 &&\r\nchannels_info->disconnect_in_frame > 0) {\r\nwmem_tree_insert32_array(channels, key, channels_info);\r\n}\r\n} else {\r\nchannels_info->stream_numbers = NULL;\r\n}\r\n}\r\nif (!(l2cap_data->local_cid == channels_info->control_local_cid &&\r\nl2cap_data->remote_cid == channels_info->control_remote_cid) &&\r\n(channels_info->media_local_cid == BTL2CAP_UNKNOWN_CID ||\r\n(l2cap_data->local_cid == channels_info->media_local_cid &&\r\nl2cap_data->remote_cid == channels_info->media_remote_cid))) {\r\nif (!pinfo->fd->flags.visited && channels_info->media_local_cid == BTL2CAP_UNKNOWN_CID) {\r\nchannels_info->media_local_cid = l2cap_data->local_cid;\r\nchannels_info->media_remote_cid = l2cap_data->remote_cid;\r\n}\r\nif (!channels_info->sep) {\r\nti = proto_tree_add_item(tree, proto_btavdtp, tvb, offset, -1, ENC_NA);\r\nbtavdtp_tree = proto_item_add_subtree(ti, ett_btavdtp);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Media stream on cid=0x%04x", l2cap_data->cid);\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_data, tvb, offset, -1, ENC_NA);\r\n} else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Media stream ACP SEID [%u - %s %s]",\r\nchannels_info->sep->seid, get_sep_media_type(\r\ninterface_id, adapter_id, chandle, direction,\r\nchannels_info->sep->seid,\r\nframe_number),\r\nget_sep_type(interface_id, adapter_id, chandle, direction,\r\nchannels_info->sep->seid,\r\nframe_number));\r\nif (channels_info->sep->media_type == MEDIA_TYPE_AUDIO) {\r\nsep_data_t sep_data;\r\nmedia_stream_number_value_t *media_stream_number_value;\r\nmedia_packet_info_t *previous_media_packet_info;\r\nmedia_packet_info_t *current_media_packet_info;\r\nnstime_t first_abs_ts;\r\ngdouble cumulative_frame_duration;\r\ngdouble avrcp_song_position = -1.0;\r\nbtavrcp_song_position_data_t *song_position_data;\r\nsep_data.codec = channels_info->sep->codec;\r\nsep_data.vendor_id = channels_info->sep->vendor_id;\r\nsep_data.vendor_codec = channels_info->sep->vendor_codec;\r\nsep_data.acp_seid = channels_info->sep->seid;\r\nsep_data.int_seid = channels_info->sep->int_seid;\r\nsep_data.content_protection_type = channels_info->sep->content_protection_type;\r\nsep_data.stream_start_in_frame = 0;\r\nsep_data.stream_end_in_frame = 0;\r\nsep_data.configuration_length = channels_info->sep->configuration_length;\r\nsep_data.configuration = channels_info->sep->configuration;\r\nmedia_stream_number_value = (media_stream_number_value_t *) wmem_tree_lookup32_le(channels_info->stream_numbers, frame_number - 1);\r\nif (media_stream_number_value) {\r\nsep_data.stream_number = media_stream_number_value->stream_number;\r\nif (media_stream_number_value->stream_start_in_frame == 0)\r\nmedia_stream_number_value->stream_start_in_frame = pinfo->num;\r\nif (!pinfo->fd->flags.visited)\r\nmedia_stream_number_value->stream_end_in_frame = pinfo->num;\r\nsep_data.stream_start_in_frame = media_stream_number_value->stream_start_in_frame;\r\nsep_data.stream_end_in_frame = media_stream_number_value->stream_end_in_frame;\r\n} else {\r\nsep_data.stream_number = 1;\r\n}\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &cid;\r\nkey[4].length = 1;\r\nkey[4].key = &direction;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nkey[2].length = 0;\r\nkey[2].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(btavrcp_song_positions, key);\r\nsong_position_data = (subtree) ? (btavrcp_song_position_data_t *) wmem_tree_lookup32_le(subtree, frame_number) : NULL;\r\nif (song_position_data && (song_position_data->used_in_frame == 0 ||\r\nsong_position_data->used_in_frame == frame_number)) {\r\navrcp_song_position = song_position_data->song_position;\r\nif (!pinfo->fd->flags.visited)\r\nsong_position_data->used_in_frame = frame_number;\r\n}\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(media_packet_times, key);\r\nprevious_media_packet_info = (subtree) ? (media_packet_info_t *) wmem_tree_lookup32_le(subtree, frame_number - 1) : NULL;\r\nif (previous_media_packet_info && previous_media_packet_info->stream_number == sep_data.stream_number ) {\r\nsep_data.previous_media_packet_info = previous_media_packet_info;\r\nfirst_abs_ts = previous_media_packet_info->first_abs_ts;\r\ncumulative_frame_duration = previous_media_packet_info->cumulative_frame_duration;\r\nif (avrcp_song_position == -1.0)\r\navrcp_song_position = previous_media_packet_info->avrcp_song_position;\r\nelse\r\nprevious_media_packet_info->avrcp_song_position = avrcp_song_position;\r\n} else {\r\nif (avrcp_song_position == -1.0)\r\navrcp_song_position = 0.0;\r\nfirst_abs_ts = pinfo->abs_ts;\r\ncumulative_frame_duration = 0.0;\r\nsep_data.previous_media_packet_info = (media_packet_info_t *) wmem_new(wmem_epan_scope(), media_packet_info_t);\r\nsep_data.previous_media_packet_info->abs_ts = pinfo->abs_ts;\r\nsep_data.previous_media_packet_info->first_abs_ts = first_abs_ts;\r\nsep_data.previous_media_packet_info->cumulative_frame_duration = cumulative_frame_duration;\r\nsep_data.previous_media_packet_info->avrcp_song_position = avrcp_song_position;\r\nsep_data.previous_media_packet_info->stream_number = sep_data.stream_number;\r\n}\r\nif (!pinfo->fd->flags.visited) {\r\nkey[5].length = 1;\r\nkey[5].key = &frame_number;\r\nkey[6].length = 0;\r\nkey[6].key = NULL;\r\nif (avrcp_song_position == -1.0)\r\navrcp_song_position = 0.0;\r\ncurrent_media_packet_info = wmem_new(wmem_file_scope(), media_packet_info_t);\r\ncurrent_media_packet_info->abs_ts = pinfo->abs_ts;\r\ncurrent_media_packet_info->first_abs_ts = first_abs_ts;\r\ncurrent_media_packet_info->cumulative_frame_duration = cumulative_frame_duration;\r\ncurrent_media_packet_info->avrcp_song_position = avrcp_song_position;\r\ncurrent_media_packet_info->stream_number = sep_data.stream_number;\r\nwmem_tree_insert32_array(media_packet_times, key, current_media_packet_info);\r\n}\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(media_packet_times, key);\r\ncurrent_media_packet_info = (subtree) ? (media_packet_info_t *) wmem_tree_lookup32(subtree, frame_number) : NULL;\r\nif (current_media_packet_info)\r\nsep_data.current_media_packet_info = current_media_packet_info;\r\nelse\r\nsep_data.current_media_packet_info = NULL;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector_with_data(bta2dp_handle, next_tvb, pinfo, tree, &sep_data);\r\n} else if (channels_info->sep->media_type == MEDIA_TYPE_VIDEO) {\r\nsep_data_t sep_data;\r\nmedia_stream_number_value_t *media_stream_number_value;\r\nsep_data.codec = channels_info->sep->codec;\r\nsep_data.vendor_id = channels_info->sep->vendor_id;\r\nsep_data.vendor_codec = channels_info->sep->vendor_codec;\r\nsep_data.acp_seid = channels_info->sep->seid;\r\nsep_data.int_seid = channels_info->sep->int_seid;\r\nsep_data.content_protection_type = channels_info->sep->content_protection_type;\r\nsep_data.stream_start_in_frame = 0;\r\nsep_data.stream_end_in_frame = 0;\r\nsep_data.configuration_length = channels_info->sep->configuration_length;\r\nsep_data.configuration = channels_info->sep->configuration;\r\nmedia_stream_number_value = (media_stream_number_value_t *) wmem_tree_lookup32_le(channels_info->stream_numbers, frame_number - 1);\r\nif (media_stream_number_value) {\r\nsep_data.stream_number = media_stream_number_value->stream_number;\r\n} else {\r\nsep_data.stream_number = 1;\r\n}\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector_with_data(btvdp_handle, next_tvb, pinfo, tree, &sep_data);\r\n} else {\r\nti = proto_tree_add_item(tree, proto_btavdtp, tvb, offset, -1, ENC_NA);\r\nbtavdtp_tree = proto_item_add_subtree(ti, ett_btavdtp);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Media stream on cid=0x%04x", l2cap_data->cid);\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_data, tvb, offset, -1, ENC_NA);\r\n}\r\n}\r\nreturn tvb_reported_length(tvb);\r\n} else if (!(l2cap_data->local_cid == channels_info->control_local_cid &&\r\nl2cap_data->remote_cid == channels_info->control_remote_cid)) {\r\nti = proto_tree_add_item(tree, proto_btavdtp, tvb, offset, -1, ENC_NA);\r\nbtavdtp_tree = proto_item_add_subtree(ti, ett_btavdtp);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Unknown channel stream on cid=0x%04x", l2cap_data->cid);\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_data, tvb, offset, -1, ENC_NA);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nti = proto_tree_add_item(tree, proto_btavdtp, tvb, offset, -1, ENC_NA);\r\nbtavdtp_tree = proto_item_add_subtree(ti, ett_btavdtp);\r\nmessage_type = (tvb_get_guint8(tvb, offset) & AVDTP_MESSAGE_TYPE_MASK);\r\npacket_type = (tvb_get_guint8(tvb, offset) & AVDTP_PACKET_TYPE_MASK) >> 2;\r\nsignal_item = proto_tree_add_item(btavdtp_tree, hf_btavdtp_signal, tvb, offset,\r\n(packet_type == PACKET_TYPE_START) ? 3 : 2, ENC_NA);\r\nsignal_tree = proto_item_add_subtree(signal_item, ett_btavdtp_sep);\r\nproto_tree_add_item(signal_tree, hf_btavdtp_transaction, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(signal_tree, hf_btavdtp_packet_type, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(signal_tree, hf_btavdtp_message_type, tvb, offset, 1, ENC_NA);\r\nif (packet_type == PACKET_TYPE_START) {\r\noffset += 1;\r\nproto_tree_add_item(signal_tree, hf_btavdtp_number_of_signal_packets, tvb, offset, 1, ENC_NA);\r\n}\r\nif (packet_type == PACKET_TYPE_CONTINUE || packet_type == PACKET_TYPE_END) goto LABEL_data;\r\noffset += 1;\r\nproto_tree_add_item(signal_tree, hf_btavdtp_rfa0, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(signal_tree, hf_btavdtp_signal_id, tvb, offset, 1, ENC_NA);\r\nsignal_id = tvb_get_guint8(tvb, offset) & AVDTP_SIGNAL_ID_MASK;\r\nproto_item_append_text(signal_item, ": %s (%s)",\r\nval_to_str_const(signal_id, signal_id_vals, "Unknown signal"),\r\nval_to_str_const(message_type, message_type_vals, "Unknown message type"));\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s - %s",\r\nval_to_str_const(message_type, message_type_vals, "Unknown message type"),\r\nval_to_str_const(signal_id, signal_id_vals, "Unknown signal"));\r\noffset += 1;\r\nif (message_type != MESSAGE_TYPE_GENERAL_REJECT) switch (signal_id) {\r\ncase SIGNAL_ID_DISCOVER:\r\nif (message_type == MESSAGE_TYPE_COMMAND) break;\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\noffset = dissect_sep(tvb, pinfo, btavdtp_tree, offset,\r\ninterface_id, adapter_id, chandle);\r\nbreak;\r\ncase SIGNAL_ID_GET_CAPABILITIES:\r\ncase SIGNAL_ID_GET_ALL_CAPABILITIES:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, NULL, interface_id,\r\nadapter_id, chandle, frame_number);\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\noffset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, NULL, NULL, NULL, NULL, NULL, NULL);\r\nbreak;\r\ncase SIGNAL_ID_SET_CONFIGURATION:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\nguint32 int_seid;\r\nguint32 vendor_id;\r\nguint16 vendor_codec;\r\nguint32 reverse_direction;\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, &seid, interface_id,\r\nadapter_id, chandle, frame_number);\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_INT, 0, &int_seid, interface_id,\r\nadapter_id, chandle, frame_number);\r\noffset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset,\r\n&codec, &content_protection_type, &vendor_id,\r\n&vendor_codec, &configuration_offset, &configuration_length);\r\nif (!pinfo->fd->flags.visited) {\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &direction;\r\nkey[4].length = 1;\r\nkey[4].key = &seid;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(sep_list, key);\r\nsep = (subtree) ? (sep_entry_t *) wmem_tree_lookup32_le(subtree, frame_number) : NULL;\r\nif (sep) {\r\nsep->codec = codec;\r\nsep->vendor_id = vendor_id;\r\nsep->vendor_codec = vendor_codec;\r\nsep->content_protection_type = content_protection_type;\r\nsep->int_seid = int_seid;\r\nif (configuration_length > 0) {\r\nsep->configuration_length = configuration_length;\r\nsep->configuration = (guint8 *) tvb_memdup(wmem_file_scope(),\r\ntvb, configuration_offset, configuration_length);\r\n}\r\nif (direction == P2P_DIR_SENT)\r\nreverse_direction = P2P_DIR_RECV;\r\nelse if (direction == P2P_DIR_RECV)\r\nreverse_direction = P2P_DIR_SENT;\r\nelse\r\nreverse_direction = P2P_DIR_UNKNOWN;\r\nkey[3].length = 1;\r\nkey[3].key = &reverse_direction;\r\nkey[4].length = 1;\r\nkey[4].key = &int_seid;\r\nkey[5].length = 1;\r\nkey[5].key = &frame_number;\r\nkey[6].length = 0;\r\nkey[6].key = NULL;\r\nwmem_tree_insert32_array(sep_list, key, sep);\r\n}\r\n}\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_service_category, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase SIGNAL_ID_GET_CONFIGURATION:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, NULL, interface_id,\r\nadapter_id, chandle, frame_number);\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\noffset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset, NULL, NULL, NULL, NULL, NULL, NULL);\r\nbreak;\r\ncase SIGNAL_ID_RECONFIGURE:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\nguint32 vendor_id;\r\nguint16 vendor_codec;\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, &seid, interface_id,\r\nadapter_id, chandle, frame_number);\r\noffset = dissect_capabilities(tvb, pinfo, btavdtp_tree, offset,\r\n&codec, &content_protection_type, &vendor_id,\r\n&vendor_codec, &configuration_offset, &configuration_length);\r\nif (!pinfo->fd->flags.visited) {\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &direction;\r\nkey[4].length = 1;\r\nkey[4].key = &seid;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(sep_list, key);\r\nsep = (subtree) ? (sep_entry_t *) wmem_tree_lookup32_le(subtree, frame_number) : NULL;\r\nif (sep) {\r\nsep->codec = codec;\r\nsep->vendor_id = vendor_id;\r\nsep->vendor_codec = vendor_codec;\r\nsep->content_protection_type = content_protection_type;\r\nif (configuration_length > 0) {\r\nsep->configuration_length = configuration_length;\r\nsep->configuration = (guint8 *) tvb_memdup(wmem_file_scope(),\r\ntvb, configuration_offset, configuration_length);\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_service_category, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase SIGNAL_ID_OPEN:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, &seid, interface_id,\r\nadapter_id, chandle, frame_number);\r\nif (!pinfo->fd->flags.visited) {\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 1;\r\nkey[3].key = &direction;\r\nkey[4].length = 1;\r\nkey[4].key = &seid;\r\nkey[5].length = 0;\r\nkey[5].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(sep_list, key);\r\nsep = (subtree) ? (sep_entry_t *) wmem_tree_lookup32_le(subtree, frame_number) : NULL;\r\nif (sep) {\r\nsep->state = SEP_STATE_OPEN;\r\nkey[3].length = 1;\r\nkey[3].key = &frame_number;\r\nkey[4].length = 0;\r\nkey[4].key = NULL;\r\nwmem_tree_insert32_array(sep_open, key, sep);\r\n}\r\n}\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_ACCEPT && !pinfo->fd->flags.visited) {\r\nkey[0].length = 1;\r\nkey[0].key = &interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &adapter_id;\r\nkey[2].length = 1;\r\nkey[2].key = &chandle;\r\nkey[3].length = 0;\r\nkey[3].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(sep_open, key);\r\nsep = (subtree) ? (sep_entry_t *) wmem_tree_lookup32_le(subtree, frame_number) : NULL;\r\nif (sep && sep->state == SEP_STATE_OPEN) {\r\nsep->state = SEP_STATE_IN_USE;\r\nchannels_info->sep = sep;\r\n}\r\n}\r\nbreak;\r\ncase SIGNAL_ID_START:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\ni_sep = 1;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, i_sep, NULL,\r\ninterface_id, adapter_id, chandle, frame_number);\r\ni_sep += 1;\r\n}\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, NULL,\r\ninterface_id, adapter_id, chandle, frame_number);\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_ACCEPT && !pinfo->fd->flags.visited) {\r\nmedia_stream_number_value_t *media_stream_number_value;\r\nguint32 stream_number = 0;\r\nmedia_stream_number_value = (media_stream_number_value_t *) wmem_tree_lookup32_le(channels_info->stream_numbers, frame_number - 1);\r\n#if RTP_PLAYER_WORKAROUND == TRUE\r\n{\r\nmedia_stream_number_value_t *file_scope_stream_number_value;\r\nif (media_stream_number_value) {\r\nstream_number = media_stream_number_value->stream_number;\r\n} else {\r\nfile_scope_stream_number_value = (media_stream_number_value_t *) wmem_tree_lookup32_le(file_scope_stream_number, frame_number - 1);\r\nif (file_scope_stream_number_value)\r\nstream_number = file_scope_stream_number_value->stream_number + 1;\r\nelse\r\nstream_number = 0;\r\n}\r\nfile_scope_stream_number_value = wmem_new(wmem_file_scope(), media_stream_number_value_t);\r\nfile_scope_stream_number_value->stream_number = stream_number;\r\nwmem_tree_insert32(file_scope_stream_number, frame_number, file_scope_stream_number_value);\r\n}\r\n#else\r\nif (media_stream_number_value)\r\nstream_number = media_stream_number_value->stream_number;\r\nelse\r\nstream_number = 0;\r\n#endif\r\nmedia_stream_number_value = wmem_new(wmem_file_scope(), media_stream_number_value_t);\r\nmedia_stream_number_value->stream_number = stream_number + 1;\r\nmedia_stream_number_value->stream_start_in_frame = 0;\r\nmedia_stream_number_value->stream_end_in_frame = 0;\r\nwmem_tree_insert32(channels_info->stream_numbers, frame_number, media_stream_number_value);\r\n}\r\nbreak;\r\ncase SIGNAL_ID_CLOSE:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, NULL, interface_id,\r\nadapter_id, chandle, frame_number);\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\nif (!pinfo->fd->flags.visited && message_type == MESSAGE_TYPE_ACCEPT &&\r\nchannels_info->disconnect_in_frame > pinfo->num) {\r\nchannels_info->disconnect_in_frame = pinfo->num;\r\n}\r\nbreak;\r\ncase SIGNAL_ID_SUSPEND:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\ni_sep = 1;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, i_sep, NULL,\r\ninterface_id, adapter_id, chandle, frame_number);\r\ni_sep += 1;\r\n}\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, NULL, interface_id,\r\nadapter_id, chandle, frame_number);\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\nbreak;\r\ncase SIGNAL_ID_ABORT:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, NULL, interface_id,\r\nadapter_id, chandle, frame_number);\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\nif (!pinfo->fd->flags.visited && message_type == MESSAGE_TYPE_ACCEPT &&\r\nchannels_info->disconnect_in_frame > pinfo->num) {\r\nchannels_info->disconnect_in_frame = pinfo->num;\r\n}\r\nbreak;\r\ncase SIGNAL_ID_SECURITY_CONTROL:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, NULL, interface_id,\r\nadapter_id, chandle, frame_number);\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_data, tvb, offset, -1, ENC_NA);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_data, tvb, offset, -1, ENC_NA);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nbreak;\r\ncase SIGNAL_ID_DELAY_REPORT:\r\nif (message_type == MESSAGE_TYPE_COMMAND) {\r\nproto_item *pitem;\r\ndelay = tvb_get_ntohs(tvb, offset + 1);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "(%u.%u ms)", delay/10, delay%10);\r\noffset = dissect_seid(tvb, pinfo, btavdtp_tree, offset,\r\nSEID_ACP, 0, NULL,\r\ninterface_id, adapter_id, chandle, frame_number);\r\npitem = proto_tree_add_item(btavdtp_tree, hf_btavdtp_delay, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(pitem, " (1/10 ms)");\r\noffset += 2;\r\nbreak;\r\n}\r\nif (message_type == MESSAGE_TYPE_REJECT) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_error_code, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nLABEL_data:\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_item(btavdtp_tree, hf_btavdtp_data, tvb, offset, -1, ENC_NA);\r\n}\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_btavdtp(void)\r\n{\r\nmodule_t *module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_btavdtp_signal,\r\n{ "Signal", "btavdtp.signal",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_message_type,\r\n{ "Message Type", "btavdtp.message_type",\r\nFT_UINT8, BASE_HEX, VALS(message_type_vals), AVDTP_MESSAGE_TYPE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_packet_type,\r\n{ "Packet Type", "btavdtp.packet_type",\r\nFT_UINT8, BASE_HEX, VALS(packet_type_vals), AVDTP_PACKET_TYPE_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_transaction,\r\n{ "Transaction", "btavdtp.transaction",\r\nFT_UINT8, BASE_HEX, NULL, AVDTP_TRANSACTION_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_signal_id,\r\n{ "Signal", "btavdtp.signal_id",\r\nFT_UINT8, BASE_HEX, VALS(signal_id_vals), AVDTP_SIGNAL_ID_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_rfa0,\r\n{ "RFA", "btavdtp.rfa0",\r\nFT_UINT8, BASE_HEX, NULL, AVDTP_RFA0_MASK,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_number_of_signal_packets,\r\n{ "Number of signal packets", "btavdtp.num_signal_packets",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_error_code,\r\n{ "Error Code", "btavdtp.error_code",\r\nFT_UINT8, BASE_HEX, VALS(error_code_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sep_seid,\r\n{ "SEID", "btavdtp.sep_seid",\r\nFT_UINT8, BASE_DEC, NULL, 0xFC,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sep_inuse,\r\n{ "In Use", "btavdtp.sep_inuse",\r\nFT_UINT8, BASE_HEX, VALS(true_false), 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sep_rfa0,\r\n{ "RFA0", "btavdtp.sep_rfa0",\r\nFT_UINT8, BASE_HEX, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sep_media_type,\r\n{ "Media Type", "btavdtp.sep_media_type",\r\nFT_UINT8, BASE_HEX, VALS(media_type_vals), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sep_type,\r\n{ "Type", "btavdtp.sep_type",\r\nFT_UINT8, BASE_HEX, VALS(sep_type_vals), 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sep_rfa1,\r\n{ "RFA1", "btavdtp.sep_rfa1",\r\nFT_UINT8, BASE_HEX, NULL, 0x07,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_acp_sep,\r\n{ "ACP SEP", "btavdtp.acp_sep",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_acp_seid_item,\r\n{ "ACP SEID", "btavdtp.acp_seid_item",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_int_seid_item,\r\n{ "INT SEID", "btavdtp.int_seid_item",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_acp_seid,\r\n{ "ACP SEID", "btavdtp.acp_seid",\r\nFT_UINT8, BASE_DEC, NULL, 0xFC,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_int_seid,\r\n{ "INT SEID", "btavdtp.int_seid",\r\nFT_UINT8, BASE_DEC, NULL, 0xFC,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_rfa_seid,\r\n{ "RFA", "btavdtp.rfa_seid",\r\nFT_UINT8, BASE_HEX, NULL, 0x03,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_service_category,\r\n{ "Service Category", "btavdtp.service_category",\r\nFT_UINT8, BASE_HEX, VALS(service_category_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_length_of_service_category,\r\n{ "Length of Service Category", "btavdtp.length_of_service_category",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_delay,\r\n{ "Delay", "btavdtp.delay",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_recovery_type,\r\n{ "Service Category", "btavdtp.recovery_type",\r\nFT_UINT8, BASE_HEX, VALS(recovery_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_maximum_recovery_window_size,\r\n{ "Service Category", "btavdtp.maximum_recovery_window_size",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_maximum_number_of_media_packet_in_parity_code,\r\n{ "Service Category", "btavdtp.maximum_number_of_media_packet_in_parity_code",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_multiplexing_fragmentation,\r\n{ "Fragmentation", "btavdtp.multiplexing_fragmentation",\r\nFT_UINT8, BASE_HEX, VALS(true_false), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_multiplexing_rfa,\r\n{ "RFA", "btavdtp.multiplexing_rfa",\r\nFT_UINT8, BASE_HEX, NULL, 0x7F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_multiplexing_tsid,\r\n{ "TSID", "btavdtp.multiplexing_tsid",\r\nFT_UINT8, BASE_HEX, VALS(multiplexing_tsid_vals), 0xF8,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_multiplexing_tcid,\r\n{ "TCID", "btavdtp.multiplexing_tcid",\r\nFT_UINT8, BASE_HEX, VALS(multiplexing_tcid_vals), 0xF8,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_multiplexing_entry_rfa,\r\n{ "RFA", "btavdtp.multiplexing_entry_rfa",\r\nFT_UINT8, BASE_HEX, NULL, 0x07,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_header_compression_backch,\r\n{ "BackCh", "btavdtp.header_compression_backch",\r\nFT_UINT8, BASE_HEX, VALS(true_false), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_header_compression_media,\r\n{ "Media", "btavdtp.header_compression_media",\r\nFT_UINT8, BASE_HEX, VALS(true_false), 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_header_compression_recovery,\r\n{ "Recovery", "btavdtp.header_compression_recovery",\r\nFT_UINT8, BASE_HEX, VALS(true_false), 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_header_compression_rfa,\r\n{ "RFA", "btavdtp.header_compression_rfa",\r\nFT_UINT8, BASE_HEX, NULL, 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_content_protection_type,\r\n{ "Type", "btavdtp.content_protection_type",\r\nFT_UINT16, BASE_HEX, VALS(content_protection_type_vals), 0x0000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_media_codec_media_type,\r\n{ "Media Type", "btavdtp.media_codec_media_type",\r\nFT_UINT8, BASE_HEX, VALS(media_type_vals), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_media_codec_rfa,\r\n{ "RFA", "btavdtp.media_codec_rfa",\r\nFT_UINT8, BASE_HEX, NULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_media_codec_audio_type,\r\n{ "Media Codec Audio Type", "btavdtp.media_codec_audio_type",\r\nFT_UINT8, BASE_HEX, VALS(media_codec_audio_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_media_codec_video_type,\r\n{ "Media Codec Video Type", "btavdtp.media_codec_video_type",\r\nFT_UINT8, BASE_HEX, VALS(media_codec_video_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_media_codec_unknown_type,\r\n{ "Media Codec Unknown Type", "btavdtp.media_codec_unknown_type",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_sampling_frequency_16000,\r\n{ "Sampling Frequency 16000 Hz", "btavdtp.codec.sbc.sampling_frequency.16000",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_sampling_frequency_32000,\r\n{ "Sampling Frequency 32000 Hz", "btavdtp.codec.sbc.sampling_frequency.32000",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_sampling_frequency_44100,\r\n{ "Sampling Frequency 44100 Hz", "btavdtp.codec.sbc.sampling_frequency.44100",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_sampling_frequency_48000,\r\n{ "Sampling Frequency 48000 Hz", "btavdtp.codec.sbc.sampling_frequency.48000",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_channel_mode_mono,\r\n{ "Channel Mode Mono", "btavdtp.codec.sbc.channel_mode.mono",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_channel_mode_dual_channel,\r\n{ "Channel Mode Dual Channel", "btavdtp.codec.sbc.channel_mode.dual_channel",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_channel_mode_stereo,\r\n{ "Channel Mode Stereo", "btavdtp.codec.sbc.channel_mode.stereo",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_channel_mode_joint_stereo,\r\n{ "Channel Mode Joint Stereo", "btavdtp.codec.sbc.channel_mode.joint_stereo",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_block_4,\r\n{ "Block Length 4", "btavdtp.codec.sbc.block.4",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_block_8,\r\n{ "Block Length 8", "btavdtp.codec.sbc.block.8",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_block_12,\r\n{ "Block Length 12", "btavdtp.codec.sbc.block.12",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_block_16,\r\n{ "Block Length 16", "btavdtp.codec.sbc.block.16",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_subbands_4,\r\n{ "Subbands 4", "btavdtp.codec.sbc.subbands.4",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_subbands_8,\r\n{ "Subbands 8", "btavdtp.codec.sbc.subbands.8",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_allocation_method_snr,\r\n{ "Allocation Method SNR", "btavdtp.codec.sbc.allocation_method.snr",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_allocation_method_loudness,\r\n{ "Allocation Method Loudness", "btavdtp.codec.sbc.allocation_method.loudness",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_min_bitpool,\r\n{ "Minumum Bitpool", "btavdtp.codec.sbc.minimum_bitpool",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_sbc_max_bitpool,\r\n{ "Maximum Bitpool", "btavdtp.codec.sbc.maximum_bitpool",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_layer_1,\r\n{ "MP1", "btavdtp.codec.mpeg12.layer_1",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\n"MPEG Layer 1", HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_layer_2,\r\n{ "MP2", "btavdtp.codec.mpeg12.layer_2",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\n"MPEG Layer 2", HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_layer_3,\r\n{ "MP3", "btavdtp.codec.mpeg12.layer_3",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\n"MPEG Layer 3", HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_crc_protection,\r\n{ "CRC Protection", "btavdtp.codec.mpeg12.crc_protection",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_channel_mode_mono,\r\n{ "Channel Mode Mono", "btavdtp.codec.mpeg12.channel_mode.mono",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_channel_mode_dual_channel,\r\n{ "Channel Mode Dual Channel", "btavdtp.codec.mpeg12.channel_mode.dual_channel",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_channel_mode_stereo,\r\n{ "Channel Mode Stereo", "btavdtp.codec.mpeg12.channel_mode.stereo",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_channel_mode_joint_stereo,\r\n{ "Channel Mode Joint Stereo", "btavdtp.codec.mpeg12.channel_mode.joint_stereo",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_rfa,\r\n{ "RFA", "btavdtp.codec.mpeg12.rfa",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_mpf_2,\r\n{ "Media Payload Format 2", "btavdtp.codec.mpeg12.mpf_2",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_sampling_frequency_16000,\r\n{ "Sampling Frequency 16000 Hz", "btavdtp.codec.sbc.sampling_frequency.16000",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_sampling_frequency_22050,\r\n{ "Sampling Frequency 22050 Hz", "btavdtp.codec.sbc.sampling_frequency.22050",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_sampling_frequency_24000,\r\n{ "Sampling Frequency 24000 Hz", "btavdtp.codec.sbc.sampling_frequency.24000",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_sampling_frequency_32000,\r\n{ "Sampling Frequency 32000 Hz", "btavdtp.codec.sbc.sampling_frequency.32000",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_sampling_frequency_44100,\r\n{ "Sampling Frequency 44100 Hz", "btavdtp.codec.sbc.sampling_frequency.44100",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_sampling_frequency_48000,\r\n{ "Sampling Frequency 48000 Hz", "btavdtp.codec.sbc.sampling_frequency.48000",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_vbr_supported,\r\n{ "VBR Supported", "btavdtp.codec.mpeg12.vbr",\r\nFT_BOOLEAN, 16, NULL, 0x8000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg12_bit_rate,\r\n{ "Bit Rate", "btavdtp.codec.mpeg12.bit_rate",\r\nFT_UINT16, BASE_HEX, NULL, 0x7FFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_object_type_mpeg2_aac_lc,\r\n{ "MPEG2 ACC LC", "btavdtp.codec.mpeg24.object_type.mpeg2_aac_lc",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_object_type_mpeg4_aac_lc,\r\n{ "MPEG4 ACC LC", "btavdtp.codec.mpeg24.object_type.mpeg4_aac_lc",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_object_type_mpeg4_aac_ltp,\r\n{ "MPEG4 ACC LTP", "btavdtp.codec.mpeg24.object_type.mpeg4_aac_ltp",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_object_type_mpeg4_aac_scalable,\r\n{ "MPEG4 ACC Scalable", "btavdtp.codec.mpeg24.object_type.mpeg4_aac_scalable",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_object_type_rfa,\r\n{ "RFA", "btavdtp.codec.mpeg24.object_type.rfa",\r\nFT_UINT8, BASE_HEX, NULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_8000,\r\n{ "Sampling Frequency 8000 Hz", "btavdtp.codec.mpeg24.sampling_frequency.8000",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_11025,\r\n{ "Sampling Frequency 11025 Hz", "btavdtp.codec.mpeg24.sampling_frequency.11025",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_12000,\r\n{ "Sampling Frequency 12000 Hz", "btavdtp.codec.mpeg24.sampling_frequency.12000",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_16000,\r\n{ "Sampling Frequency 16000 Hz", "btavdtp.codec.mpeg24.sampling_frequency.16000",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_22050,\r\n{ "Sampling Frequency 22050 Hz", "btavdtp.codec.mpeg24.sampling_frequency.22050",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_24000,\r\n{ "Sampling Frequency 24000 Hz", "btavdtp.codec.mpeg24.sampling_frequency.24000",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_32000,\r\n{ "Sampling Frequency 32000 Hz", "btavdtp.codec.mpeg24.sampling_frequency.32000",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_44100,\r\n{ "Sampling Frequency 44100 Hz", "btavdtp.codec.mpeg24.sampling_frequency.44100",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_48000,\r\n{ "Sampling Frequency 48000 Hz", "btavdtp.codec.mpeg24.sampling_frequency.48000",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_64000,\r\n{ "Sampling Frequency 64000 Hz", "btavdtp.codec.mpeg24.sampling_frequency.64000",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_88200,\r\n{ "Sampling Frequency 88200 Hz", "btavdtp.codec.mpeg24.sampling_frequency.88200",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_sampling_frequency_96000,\r\n{ "Sampling Frequency 96000 Hz", "btavdtp.codec.mpeg24.sampling_frequency.96000",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_channels_1,\r\n{ "Channels 1", "btavdtp.codec.mpeg24.channels.1",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_channels_2,\r\n{ "Channels 2", "btavdtp.codec.mpeg24.channels.2",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_rfa,\r\n{ "RFA", "btavdtp.codec.mpeg24.rfa",\r\nFT_UINT8, BASE_HEX, NULL, 0x03,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_vbr_supported,\r\n{ "VBR Supported", "btavdtp.codec.mpeg24.vbr",\r\nFT_BOOLEAN, 24, NULL, 0x800000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg24_bit_rate,\r\n{ "Bit Rate", "btavdtp.codec.mpeg24.bit_rate",\r\nFT_UINT24, BASE_HEX, NULL, 0x7FFFFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_version,\r\n{ "Version", "btavdtp.codec.atrac.version",\r\nFT_UINT8, BASE_DEC, NULL, 0xE0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_channel_mode_single_channel,\r\n{ "Channel Mode Single Channel", "btavdtp.codec.atrac.channel_mode.single_channel",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_channel_mode_dual_channel,\r\n{ "Channel Mode Dual Channel", "btavdtp.codec.atrac.channel_mode.dual_channel",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_channel_mode_joint_stereo,\r\n{ "Channel Mode Joint Stereo", "btavdtp.codec.atrac.channel_mode.joint_stereo",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_rfa1,\r\n{ "RFA", "btavdtp.codec.atrac.rfa1",\r\nFT_UINT8, BASE_HEX, NULL, 0x03,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_rfa2,\r\n{ "RFA", "btavdtp.codec.atrac.rfa2",\r\nFT_UINT24, BASE_HEX, NULL, 0xC00000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_sampling_frequency_44100,\r\n{ "Sampling Frequency 44100 Hz", "btavdtp.codec.sbc.sampling_frequency.44100",\r\nFT_BOOLEAN, 24, NULL, 0x200000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_sampling_frequency_48000,\r\n{ "Sampling Frequency 48000 Hz", "btavdtp.codec.sbc.sampling_frequency.48000",\r\nFT_BOOLEAN, 24, NULL, 0x100000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_vbr_supported,\r\n{ "VBR Supported", "btavdtp.codec.atrac.vbr",\r\nFT_BOOLEAN, 24, NULL, 0x080000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_bit_rate,\r\n{ "Bit Rate", "btavdtp.codec.atrac.bit_rate",\r\nFT_UINT24, BASE_HEX, NULL, 0x07FFFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_maximum_sul,\r\n{ "Maximum SUL", "btavdtp.codec.atrac.maximum_sul",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"Sound Unit Length (SUL) is one of the parameters that determine bit rate of the audio stream.", HFILL }\r\n},\r\n{ &hf_btavdtp_atrac_rfa3,\r\n{ "RFA", "btavdtp.codec.atrac.rfa3",\r\nFT_UINT8, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_h263_level_10,\r\n{ "H264 Level 10", "btavdtp.codec.h264.level.10",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_h263_level_20,\r\n{ "H264 Level 20", "btavdtp.codec.h264.level.20",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_h263_level_30,\r\n{ "H264 Level 30", "btavdtp.codec.h264.level.30",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_h263_level_rfa,\r\n{ "H264 Level RFA", "btavdtp.codec.h264.level.rfa",\r\nFT_UINT8, BASE_HEX, NULL, 0x1F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg4_level_0,\r\n{ "MPEG Level 0", "btavdtp.codec.mpeg4.level.0",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg4_level_1,\r\n{ "MPEG Level 1", "btavdtp.codec.mpeg4.level.1",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg4_level_2,\r\n{ "MPEG Level 2", "btavdtp.codec.mpeg4.level.2",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg4_level_3,\r\n{ "MPEG4 Level 3", "btavdtp.codec.mpeg4.level.3",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_mpeg4_level_rfa,\r\n{ "MPEG4 Level RFA", "btavdtp.codec.mpeg4.level.rfa",\r\nFT_UINT8, BASE_HEX, NULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_id,\r\n{ "Vendor ID", "btavdtp.codec.vendor.vendor_id",\r\nFT_UINT32, BASE_HEX|BASE_EXT_STRING, &bluetooth_company_id_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_codec_id,\r\n{ "Codec", "btavdtp.codec.vendor.codec_id",\r\nFT_UINT16, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_value,\r\n{ "Value", "btavdtp.codec.vendor.value",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_apt_codec_id,\r\n{ "Codec", "btavdtp.codec.vendor.codec_id",\r\nFT_UINT16, BASE_HEX, VALS(vendor_apt_codec_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_aptx_sampling_frequency_16000,\r\n{ "Sampling Frequency 16000 Hz", "btavdtp.codec.aptx.sampling_frequency.16000",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_aptx_sampling_frequency_32000,\r\n{ "Sampling Frequency 32000 Hz", "btavdtp.codec.aptx.sampling_frequency.32000",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_aptx_sampling_frequency_44100,\r\n{ "Sampling Frequency 44100 Hz", "btavdtp.codec.aptx.sampling_frequency.44100",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_aptx_sampling_frequency_48000,\r\n{ "Sampling Frequency 48000 Hz", "btavdtp.codec.aptx.sampling_frequency.48000",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_aptx_channel_mode_mono,\r\n{ "Channel Mode Mono", "btavdtp.codec.aptx.channel_mode.mono",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_aptx_channel_mode_dual_channel,\r\n{ "Channel Mode Dual Channel", "btavdtp.codec.aptx.channel_mode.dual_channel",\r\nFT_BOOLEAN, 8, NULL, 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_aptx_channel_mode_stereo,\r\n{ "Channel Mode Stereo", "btavdtp.codec.aptx.channel_mode.stereo",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_vendor_specific_aptx_channel_mode_joint_stereo,\r\n{ "Channel Mode Joint Stereo", "btavdtp.codec.aptx.channel_mode.joint_stereo",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_capabilities,\r\n{ "Capabilities", "btavdtp.capabilities",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_service,\r\n{ "Service", "btavdtp.service",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_service_multiplexing_entry,\r\n{ "Entry", "btavdtp.service_multiplexing_entry",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btavdtp_data,\r\n{ "Data", "btavdtp.data",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btavdtp,\r\n&ett_btavdtp_sep,\r\n&ett_btavdtp_capabilities,\r\n&ett_btavdtp_service,\r\n};\r\nproto_btavdtp = proto_register_protocol("Bluetooth AVDTP Protocol", "BT AVDTP", "btavdtp");\r\nbtavdtp_handle = register_dissector("btavdtp", dissect_btavdtp, proto_btavdtp);\r\nproto_register_field_array(proto_btavdtp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nmodule = prefs_register_protocol(proto_btavdtp, NULL);\r\nprefs_register_static_text_preference(module, "avdtp.version",\r\n"Bluetooth Protocol AVDTP version: 1.3",\r\n"Version of protocol supported by this dissector.");\r\nchannels = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\nsep_list = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\nsep_open = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\nmedia_packet_times = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n#if RTP_PLAYER_WORKAROUND == TRUE\r\nfile_scope_stream_number = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n#endif\r\n}\r\nvoid\r\nproto_reg_handoff_btavdtp(void)\r\n{\r\ndissector_add_string("bluetooth.uuid", "19", btavdtp_handle);\r\ndissector_add_uint("btl2cap.psm", BTL2CAP_PSM_AVDTP, btavdtp_handle);\r\ndissector_add_for_decode_as("btl2cap.cid", btavdtp_handle);\r\n}\r\nstatic gint\r\ndissect_aptx(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *aptx_item;\r\nproto_tree *aptx_tree;\r\nproto_item *pitem;\r\nbta2dp_codec_info_t *info;\r\ngdouble cumulative_frame_duration = 0;\r\ninfo = (bta2dp_codec_info_t *) data;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "APT-X");\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ncase P2P_DIR_UNKNOWN:\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unknown direction %d ",\r\npinfo->p2p_dir);\r\nbreak;\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "APT-X");\r\naptx_item = proto_tree_add_item(tree, proto_aptx, tvb, 0, -1, ENC_NA);\r\naptx_tree = proto_item_add_subtree(aptx_item, ett_aptx);\r\nproto_tree_add_item(aptx_tree, hf_aptx_data, tvb, 0, -1, ENC_NA);\r\nif (info && info->configuration && info->configuration_length >= 9) {\r\ngboolean fail = FALSE;\r\ngdouble expected_speed_data;\r\ngdouble frame_duration;\r\ngdouble frame_length = 2 * 2 * 4;\r\ngint number_of_channels;\r\ngint frequency;\r\ngint sample_bits;\r\nswitch (info->configuration[8] >> 4) {\r\ncase 0x01:\r\nfrequency = 48000;\r\nbreak;\r\ncase 0x02:\r\nfrequency = 44100;\r\nbreak;\r\ncase 0x04:\r\nfrequency = 32000;\r\nbreak;\r\ncase 0x08:\r\nfrequency = 16000;\r\nbreak;\r\ndefault:\r\nfail = TRUE;\r\n}\r\nif (fail)\r\nreturn tvb_reported_length(tvb);\r\nswitch (info->configuration[8] & 0x0F) {\r\ncase 0x01:\r\ncase 0x02:\r\ncase 0x04:\r\nnumber_of_channels = 2;\r\nbreak;\r\ncase 0x08:\r\nnumber_of_channels = 1;\r\nbreak;\r\ndefault:\r\nfail = TRUE;\r\n}\r\nif (fail)\r\nreturn tvb_reported_length(tvb);\r\nsample_bits = 16;\r\nexpected_speed_data = frequency * (sample_bits / 8.0) * number_of_channels;\r\nframe_duration = (((double) frame_length / (double) expected_speed_data) * 1000.0);\r\ncumulative_frame_duration = (tvb_reported_length(tvb) / 4.0) * frame_duration;\r\npitem = proto_tree_add_double(aptx_tree, hf_aptx_cumulative_frame_duration, tvb, 0, 0, cumulative_frame_duration);\r\nproto_item_append_text(pitem, " ms");\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nif (info && info->previous_media_packet_info && info->current_media_packet_info) {\r\nnstime_t delta;\r\nnstime_delta(&delta, &pinfo->abs_ts, &info->previous_media_packet_info->abs_ts);\r\npitem = proto_tree_add_double(aptx_tree, hf_aptx_delta_time, tvb, 0, 0, nstime_to_msec(&delta));\r\nproto_item_append_text(pitem, " ms");\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\npitem = proto_tree_add_double(aptx_tree, hf_aptx_avrcp_song_position, tvb, 0, 0, info->previous_media_packet_info->avrcp_song_position);\r\nproto_item_append_text(pitem, " ms");\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nnstime_delta(&delta, &pinfo->abs_ts, &info->previous_media_packet_info->first_abs_ts);\r\npitem = proto_tree_add_double(aptx_tree, hf_aptx_delta_time_from_the_beginning, tvb, 0, 0, nstime_to_msec(&delta));\r\nproto_item_append_text(pitem, " ms");\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nif (!pinfo->fd->flags.visited)\r\ninfo->current_media_packet_info->cumulative_frame_duration += cumulative_frame_duration;\r\npitem = proto_tree_add_double(aptx_tree, hf_aptx_cumulative_duration, tvb, 0, 0, info->previous_media_packet_info->cumulative_frame_duration);\r\nproto_item_append_text(pitem, " ms");\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\npitem = proto_tree_add_double(aptx_tree, hf_aptx_diff, tvb, 0, 0, info->previous_media_packet_info->cumulative_frame_duration - nstime_to_msec(&delta));\r\nproto_item_append_text(pitem, " ms");\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\n}\r\n}\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_aptx(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_aptx_data,\r\n{ "Data", "aptx.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_aptx_cumulative_frame_duration,\r\n{ "Cumulative Frame Duration", "aptx.cumulative_frame_duration",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_aptx_delta_time,\r\n{ "Delta time", "aptx.delta_time",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_aptx_avrcp_song_position,\r\n{ "AVRCP Song Position", "aptx.avrcp_song_position",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_aptx_delta_time_from_the_beginning,\r\n{ "Delta time from the beginning", "aptx.delta_time_from_the_beginning",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_aptx_cumulative_duration,\r\n{ "Cumulative Music Duration", "aptx.cumulative_music_duration",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_aptx_diff,\r\n{ "Diff", "aptx.diff",\r\nFT_DOUBLE, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_aptx\r\n};\r\nproto_aptx = proto_register_protocol("APT-X Codec", "APT-X", "aptx");\r\nproto_register_field_array(proto_bta2dp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\naptx_handle = register_dissector("aptx", dissect_aptx, proto_aptx);\r\n}\r\nstatic gint\r\ndissect_bta2dp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *ti;\r\nproto_tree *bta2dp_tree;\r\nproto_item *pitem;\r\ngint offset = 0;\r\ndissector_handle_t codec_dissector = NULL;\r\nbta2dp_codec_info_t bta2dp_codec_info;\r\nsep_data_t sep_data;\r\ngboolean no_avdtp_session;\r\nno_avdtp_session = (proto_btavdtp != (gint) GPOINTER_TO_UINT(wmem_list_frame_data(\r\nwmem_list_frame_prev(wmem_list_tail(pinfo->layers)))));\r\nsep_data.codec = CODEC_SBC;\r\nsep_data.content_protection_type = 0;\r\nsep_data.acp_seid = 0;\r\nsep_data.int_seid = 0;\r\nsep_data.previous_media_packet_info = NULL;\r\nsep_data.current_media_packet_info = NULL;\r\nsep_data.stream_start_in_frame = 0;\r\nsep_data.stream_end_in_frame = 0;\r\nsep_data.stream_number = 1;\r\nsep_data.vendor_id = 0;\r\nsep_data.vendor_codec = 0;\r\nsep_data.configuration_length = 0;\r\nsep_data.configuration = NULL;\r\nif (force_a2dp_scms_t || force_a2dp_codec != CODEC_DEFAULT) {\r\nif (force_a2dp_scms_t)\r\nsep_data.content_protection_type = 2;\r\nelse if (data && !no_avdtp_session)\r\nsep_data.content_protection_type = ((sep_data_t *) data)->content_protection_type;\r\nif (force_a2dp_codec != CODEC_DEFAULT)\r\nsep_data.codec = force_a2dp_codec;\r\nelse if (data && !no_avdtp_session)\r\nsep_data.codec = ((sep_data_t *) data)->codec;\r\n} else {\r\nif (data && !no_avdtp_session)\r\nsep_data = *((sep_data_t *) data);\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "A2DP");\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ncase P2P_DIR_UNKNOWN:\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unknown direction %d ",\r\npinfo->p2p_dir);\r\nbreak;\r\n}\r\nti = proto_tree_add_item(tree, proto_bta2dp, tvb, offset, -1, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Audio stream - %s",\r\nval_to_str_const(sep_data.codec, media_codec_audio_type_vals, "unknown codec"));\r\nbta2dp_tree = proto_item_add_subtree(ti, ett_bta2dp);\r\npitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_acp_seid, tvb, 0, 0, sep_data.acp_seid);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\npitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_int_seid, tvb, 0, 0, sep_data.int_seid);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\npitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_codec, tvb, 0, 0, sep_data.codec);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nif (sep_data.codec == 0xFF) {\r\npitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_vendor_id, tvb, 0, 0, sep_data.vendor_id);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\npitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_vendor_codec_id, tvb, 0, 0, sep_data.vendor_codec);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nif (sep_data.vendor_id == 0x004F && sep_data.vendor_codec == 0x0001)\r\ncodec_dissector = aptx_handle;\r\n}\r\nif (sep_data.content_protection_type > 0) {\r\npitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_content_protection, tvb, 0, 0, sep_data.content_protection_type);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\n}\r\nif (sep_data.stream_start_in_frame > 0) {\r\npitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_stream_start_in_frame, tvb, 0, 0, sep_data.stream_start_in_frame);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\n}\r\nif (sep_data.stream_end_in_frame > 0) {\r\npitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_stream_end_in_frame, tvb, 0, 0, sep_data.stream_end_in_frame);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\n}\r\npitem = proto_tree_add_uint(bta2dp_tree, hf_bta2dp_stream_number, tvb, 0, 0, sep_data.stream_number);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nswitch (sep_data.codec) {\r\ncase CODEC_SBC:\r\ncodec_dissector = sbc_handle;\r\nbreak;\r\ncase CODEC_MPEG12_AUDIO:\r\ncodec_dissector = mp2t_handle;\r\nbreak;\r\ncase CODEC_MPEG24_AAC:\r\ncodec_dissector = mpeg_audio_handle;\r\nbreak;\r\ncase CODEC_ATRAC:\r\ncodec_dissector = atrac_handle;\r\nbreak;\r\ncase CODEC_APT_X:\r\ncodec_dissector = aptx_handle;\r\nbreak;\r\n}\r\nbta2dp_codec_info.codec_dissector = codec_dissector;\r\nbta2dp_codec_info.configuration_length = sep_data.configuration_length;\r\nbta2dp_codec_info.configuration = sep_data.configuration;\r\nbta2dp_codec_info.content_protection_type = sep_data.content_protection_type;\r\nbta2dp_codec_info.previous_media_packet_info = sep_data.previous_media_packet_info;\r\nbta2dp_codec_info.current_media_packet_info = sep_data.current_media_packet_info;\r\n#if RTP_PLAYER_WORKAROUND == TRUE\r\npinfo->srcport = sep_data.stream_number;\r\npinfo->destport = sep_data.stream_number;\r\n#endif\r\nif (bta2dp_codec_info.content_protection_type == 0 && codec_dissector == aptx_handle) {\r\ncall_dissector_with_data(aptx_handle, tvb, pinfo, tree, &bta2dp_codec_info);\r\n} else {\r\nbluetooth_add_address(pinfo, &pinfo->net_dst, sep_data.stream_number, "BT A2DP", pinfo->num, FALSE, &bta2dp_codec_info);\r\ncall_dissector(rtp_handle, tvb, pinfo, tree);\r\n}\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_bta2dp(void)\r\n{\r\nmodule_t *module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_bta2dp_acp_seid,\r\n{ "ACP SEID", "bta2dp.acp_seid",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_int_seid,\r\n{ "INT SEID", "bta2dp.int_seid",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_codec,\r\n{ "Codec", "bta2dp.codec",\r\nFT_UINT8, BASE_HEX, VALS(media_codec_audio_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_vendor_id,\r\n{ "Vendor ID", "bta2dp.codec.vendor.vendor_id",\r\nFT_UINT32, BASE_HEX|BASE_EXT_STRING, &bluetooth_company_id_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_vendor_codec_id,\r\n{ "Vendor Codec", "bta2dp.codec.vendor.codec_id",\r\nFT_UINT16, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_content_protection,\r\n{ "Content Protection", "bta2dp.content_protection",\r\nFT_UINT16, BASE_HEX, VALS(content_protection_type_vals), 0x0000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_stream_start_in_frame,\r\n{ "Stream Start in Frame", "bta2dp.stream_start_in_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_stream_end_in_frame,\r\n{ "Stream End in Frame", "bta2dp.stream_end_in_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_stream_number,\r\n{ "Stream Number", "bta2dp.stream_number",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_bta2dp\r\n};\r\nproto_bta2dp = proto_register_protocol("Bluetooth A2DP Profile", "BT A2DP", "bta2dp");\r\nproto_register_field_array(proto_bta2dp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nbta2dp_handle = register_dissector("bta2dp", dissect_bta2dp, proto_bta2dp);\r\nmodule = prefs_register_protocol(proto_bta2dp, NULL);\r\nprefs_register_static_text_preference(module, "a2dp.version",\r\n"Bluetooth Profile A2DP version: 1.3",\r\n"Version of profile supported by this dissector.");\r\nprefs_register_bool_preference(module, "a2dp.content_protection.scms_t",\r\n"Force SCMS-T decoding",\r\n"Force decoding stream as A2DP with Content Protection SCMS-T ",\r\n&force_a2dp_scms_t);\r\nprefs_register_enum_preference(module, "a2dp.codec",\r\n"Force codec",\r\n"Force decoding stream as A2DP with specified codec",\r\n&force_a2dp_codec, pref_a2dp_codec, FALSE);\r\n}\r\nvoid\r\nproto_reg_handoff_bta2dp(void)\r\n{\r\nsbc_handle = find_dissector_add_dependency("sbc", proto_bta2dp);\r\nmp2t_handle = find_dissector_add_dependency("mp2t", proto_bta2dp);\r\nmpeg_audio_handle = find_dissector_add_dependency("mpeg-audio", proto_bta2dp);\r\natrac_handle = find_dissector_add_dependency("atrac", proto_bta2dp);\r\nrtp_handle = find_dissector_add_dependency("rtp", proto_bta2dp);\r\ndissector_add_string("bluetooth.uuid", "110a", bta2dp_handle);\r\ndissector_add_string("bluetooth.uuid", "110b", bta2dp_handle);\r\ndissector_add_string("bluetooth.uuid", "110d", bta2dp_handle);\r\ndissector_add_for_decode_as("btl2cap.cid", bta2dp_handle);\r\n}\r\nstatic gint\r\ndissect_btvdp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_item *ti;\r\nproto_tree *btvdp_tree;\r\nproto_item *pitem;\r\ngint offset = 0;\r\ndissector_handle_t codec_dissector = NULL;\r\nbtvdp_codec_info_t btvdp_codec_info;\r\nsep_data_t sep_data;\r\ngboolean no_avdtp_session;\r\nno_avdtp_session = (proto_btavdtp != (gint) GPOINTER_TO_UINT(wmem_list_frame_data(\r\nwmem_list_frame_prev(wmem_list_tail(pinfo->layers)))));\r\nsep_data.codec = CODEC_H263_BASELINE;\r\nsep_data.content_protection_type = 0;\r\nsep_data.acp_seid = 0;\r\nsep_data.int_seid = 0;\r\nsep_data.previous_media_packet_info = NULL;\r\nsep_data.current_media_packet_info = NULL;\r\nsep_data.stream_start_in_frame = 0;\r\nsep_data.stream_end_in_frame = 0;\r\nsep_data.stream_number = 1;\r\nsep_data.vendor_id = 0;\r\nsep_data.vendor_codec = 0;\r\nsep_data.configuration_length = 0;\r\nsep_data.configuration = NULL;\r\nif (force_vdp_scms_t || force_vdp_codec) {\r\nif (force_vdp_scms_t)\r\nsep_data.content_protection_type = 2;\r\nelse if (data && !no_avdtp_session)\r\nsep_data.content_protection_type = ((sep_data_t *) data)->content_protection_type;\r\nif (force_vdp_codec)\r\nsep_data.codec = force_vdp_codec;\r\nelse if (data && !no_avdtp_session)\r\nsep_data.codec = ((sep_data_t *) data)->codec;\r\n} else {\r\nif (data && !no_avdtp_session)\r\nsep_data = *((sep_data_t *) data);\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "VDP");\r\nswitch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ncase P2P_DIR_UNKNOWN:\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unknown direction %d ",\r\npinfo->p2p_dir);\r\nbreak;\r\n}\r\nti = proto_tree_add_item(tree, proto_btvdp, tvb, offset, -1, ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Video stream - %s",\r\nval_to_str_const(sep_data.codec, media_codec_video_type_vals, "unknown codec"));\r\nbtvdp_tree = proto_item_add_subtree(ti, ett_btvdp);\r\npitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_acp_seid, tvb, 0, 0, sep_data.acp_seid);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\npitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_int_seid, tvb, 0, 0, sep_data.int_seid);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\npitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_codec, tvb, 0, 0, sep_data.codec);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nif (sep_data.codec == 0xFF) {\r\npitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_vendor_id, tvb, 0, 0, sep_data.vendor_id);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\npitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_vendor_codec_id, tvb, 0, 0, sep_data.vendor_codec);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\n}\r\nif (sep_data.content_protection_type > 0) {\r\npitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_content_protection, tvb, 0, 0, sep_data.content_protection_type);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\n}\r\nif (sep_data.stream_start_in_frame > 0) {\r\npitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_stream_start_in_frame, tvb, 0, 0, sep_data.stream_start_in_frame);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\n}\r\nif (sep_data.stream_end_in_frame > 0) {\r\npitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_stream_end_in_frame, tvb, 0, 0, sep_data.stream_end_in_frame);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\n}\r\npitem = proto_tree_add_uint(btvdp_tree, hf_btvdp_stream_number, tvb, 0, 0, sep_data.stream_number);\r\nPROTO_ITEM_SET_GENERATED(pitem);\r\nswitch (sep_data.codec) {\r\ncase CODEC_H263_BASELINE:\r\ncase CODEC_H263_PROFILE_3:\r\ncase CODEC_H263_PROFILE_8:\r\ncodec_dissector = h263_handle;\r\nbreak;\r\ncase CODEC_MPEG4_VSP:\r\ncodec_dissector = mp4v_es_handle;\r\nbreak;\r\n}\r\nbtvdp_codec_info.codec_dissector = codec_dissector;\r\nbtvdp_codec_info.content_protection_type = sep_data.content_protection_type;\r\n#if RTP_PLAYER_WORKAROUND == TRUE\r\npinfo->srcport = sep_data.stream_number;\r\npinfo->destport = sep_data.stream_number;\r\n#endif\r\nbluetooth_add_address(pinfo, &pinfo->net_dst, 0, "BT VDP", pinfo->num, TRUE, &btvdp_codec_info);\r\ncall_dissector(rtp_handle, tvb, pinfo, tree);\r\noffset += tvb_reported_length_remaining(tvb, offset);\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_btvdp(void)\r\n{\r\nmodule_t *module;\r\nexpert_module_t* expert_btavdtp;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_btvdp_acp_seid,\r\n{ "ACP SEID", "btvdp.acp_seid",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_int_seid,\r\n{ "INT SEID", "btvdp.int_seid",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_codec,\r\n{ "Codec", "btvdp.codec",\r\nFT_UINT8, BASE_HEX, VALS(media_codec_video_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_vendor_id,\r\n{ "Vendor ID", "btvdp.codec.vendor.vendor_id",\r\nFT_UINT32, BASE_HEX|BASE_EXT_STRING, &bluetooth_company_id_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_vendor_codec_id,\r\n{ "Vendor Codec", "btvdp.codec.vendor.codec_id",\r\nFT_UINT16, BASE_HEX, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_content_protection,\r\n{ "Content Protection", "btvdp.content_protection",\r\nFT_UINT16, BASE_HEX, VALS(content_protection_type_vals), 0x0000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_stream_start_in_frame,\r\n{ "Stream Start in Frame", "btvdp.stream_start_in_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_stream_end_in_frame,\r\n{ "Stream End in Frame", "btvdp.stream_end_in_frame",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_stream_number,\r\n{ "Stream Number", "btvdp.stream_number",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btvdp\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_btavdtp_sbc_min_bitpool_out_of_range, { "btavdtp.codec.sbc.minimum_bitpool.out_of_range", PI_PROTOCOL, PI_WARN, "Bitpool is out of range. Should be 2..250.", EXPFILL }},\r\n{ &ei_btavdtp_sbc_max_bitpool_out_of_range, { "btavdtp.codec.sbc.maximum_bitpool.out_of_range", PI_PROTOCOL, PI_WARN, "Bitpool is out of range. Should be 2..250.", EXPFILL }},\r\n{ &ei_btavdtp_unexpected_losc_data, { "btavdtp.unexpected_losc_data", PI_PROTOCOL, PI_WARN, "Unexpected losc data", EXPFILL }},\r\n};\r\nproto_btvdp = proto_register_protocol("Bluetooth VDP Profile", "BT VDP", "btvdp");\r\nbtvdp_handle = register_dissector("btvdp", dissect_btvdp, proto_btvdp);\r\nproto_register_field_array(proto_bta2dp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_btavdtp = expert_register_protocol(proto_btvdp);\r\nexpert_register_field_array(expert_btavdtp, ei, array_length(ei));\r\nmodule = prefs_register_protocol(proto_btvdp, NULL);\r\nprefs_register_static_text_preference(module, "vdp.version",\r\n"Bluetooth Profile VDP version: 1.1",\r\n"Version of profile supported by this dissector.");\r\nprefs_register_bool_preference(module, "vdp.content_protection.scms_t",\r\n"Force SCMS-T decoding",\r\n"Force decoding stream as VDP with Content Protection SCMS-T ",\r\n&force_vdp_scms_t);\r\nprefs_register_enum_preference(module, "vdp.codec",\r\n"Force codec",\r\n"Force decoding stream as VDP with specified codec",\r\n&force_vdp_codec, pref_vdp_codec, FALSE);\r\n}\r\nvoid\r\nproto_reg_handoff_btvdp(void)\r\n{\r\nh263_handle = find_dissector_add_dependency("h263", proto_btvdp);\r\nmp4v_es_handle = find_dissector_add_dependency("mp4v-es", proto_btvdp);\r\nrtp_handle = find_dissector_add_dependency("rtp", proto_btvdp);\r\ndissector_add_string("bluetooth.uuid", "1303", btvdp_handle);\r\ndissector_add_string("bluetooth.uuid", "1304", btvdp_handle);\r\ndissector_add_string("bluetooth.uuid", "1305", btvdp_handle);\r\ndissector_add_for_decode_as("btl2cap.cid", btvdp_handle);\r\n}\r\nstatic gint\r\ndissect_a2dp_cp_scms_t(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *main_item;\r\nproto_tree *main_tree;\r\ngint offset = 0;\r\nmain_item = proto_tree_add_item(tree, proto_bta2dp_cph_scms_t, tvb, offset, 1, ENC_NA);\r\nmain_tree = proto_item_add_subtree(main_item, ett_bta2dp_cph_scms_t);\r\nproto_tree_add_item(main_tree, hf_bta2dp_reserved , tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(main_tree, hf_bta2dp_cp_bit, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(main_tree, hf_bta2dp_l_bit , tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_bta2dp_content_protection_header_scms_t(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_bta2dp_l_bit,\r\n{ "L-bit", "bta2dp.content_protection_header.scms_t.l_bit",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_cp_bit,\r\n{ "Cp-bit", "bta2dp.content_protection_header.scms_t.cp_bit",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bta2dp_reserved,\r\n{ "Reserved", "bta2dp.content_protection_header.scms_t.reserved",\r\nFT_BOOLEAN, 8, NULL, 0xFC,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_bta2dp_cph_scms_t\r\n};\r\nproto_bta2dp_cph_scms_t = proto_register_protocol("Bluetooth A2DP Content Protection Header SCMS-T", "BT A2DP Content Protection Header SCMS-T", "bta2dp_content_protection_header_scms_t");\r\nproto_register_field_array(proto_bta2dp_cph_scms_t, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("bta2dp_content_protection_header_scms_t", dissect_a2dp_cp_scms_t, proto_bta2dp_cph_scms_t);\r\n}\r\nstatic gint\r\ndissect_vdp_cp_scms_t(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *main_item;\r\nproto_tree *main_tree;\r\ngint offset = 0;\r\nmain_item = proto_tree_add_item(tree, proto_btvdp_cph_scms_t, tvb, offset, 1, ENC_NA);\r\nmain_tree = proto_item_add_subtree(main_item, ett_btvdp_cph_scms_t);\r\nproto_tree_add_item(main_tree, hf_btvdp_reserved , tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(main_tree, hf_btvdp_cp_bit, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(main_tree, hf_btvdp_l_bit , tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_btvdp_content_protection_header_scms_t(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_btvdp_l_bit,\r\n{ "L-bit", "btvdp.content_protection_header.scms_t.l_bit",\r\nFT_BOOLEAN, 8, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_cp_bit,\r\n{ "Cp-bit", "btvdp.content_protection_header.scms_t.cp_bit",\r\nFT_BOOLEAN, 8, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btvdp_reserved,\r\n{ "Reserved", "btvdp.content_protection_header.scms_t.reserved",\r\nFT_BOOLEAN, 8, NULL, 0xFC,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btvdp_cph_scms_t\r\n};\r\nproto_btvdp_cph_scms_t = proto_register_protocol("Bluetooth VDP Content Protection Header SCMS-T", "BT VDP Content Protection Header SCMS-T", "btvdp_content_protection_header_scms_t");\r\nproto_register_field_array(proto_btvdp_cph_scms_t, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("btvdp_content_protection_header_scms_t", dissect_vdp_cp_scms_t, proto_btvdp_cph_scms_t);\r\n}
