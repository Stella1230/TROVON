static int\r\ndissect_distcc_dist(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint32 parameter)\r\n{\r\nproto_tree_add_uint_format(tree, hf_distcc_version, tvb, offset-12, 12, parameter, "DIST: %d", parameter);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "DIST:%d ", parameter);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_distcc_done(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint32 parameter)\r\n{\r\nproto_tree_add_uint_format(tree, hf_distcc_version, tvb, offset-12, 12, parameter, "DONE: %d", parameter);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "DONE:%d ", parameter);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_distcc_stat(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint32 parameter)\r\n{\r\nproto_tree_add_uint_format(tree, hf_distcc_stat, tvb, offset-12, 12, parameter, "STAT: %d", parameter);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "STAT:%d ", parameter);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_distcc_argc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint32 parameter)\r\n{\r\nproto_tree_add_uint(tree, hf_distcc_argc, tvb, offset-12, 12, parameter);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "ARGC:%d ", parameter);\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_distcc_argv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, gint parameter)\r\n{\r\nchar argv[256];\r\nint argv_len;\r\ngint len=parameter;\r\nproto_item* ti;\r\nCHECK_PDU_LEN("ARGV");\r\nDESEGMENT_TCP("ARGV");\r\nargv_len=len>255?255:len;\r\ntvb_memcpy(tvb, argv, offset, argv_len);\r\nargv[argv_len]=0;\r\nti = proto_tree_add_item(tree, hf_distcc_argv, tvb, offset, len, ENC_ASCII|ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "%s ", argv);\r\nif(len!=parameter){\r\nexpert_add_info_format(pinfo, ti, &ei_distcc_short_pdu, "[Short ARGV PDU]");\r\n}\r\nreturn offset+len;\r\n}\r\nstatic int\r\ndissect_distcc_serr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, gint parameter)\r\n{\r\nchar argv[256];\r\nint argv_len;\r\ngint len=parameter;\r\nproto_item* ti;\r\nCHECK_PDU_LEN("SERR");\r\nDESEGMENT_TCP("SERR");\r\nargv_len=len>255?255:len;\r\ntvb_memcpy(tvb, argv, offset, argv_len);\r\nargv[argv_len]=0;\r\nti = proto_tree_add_item(tree, hf_distcc_serr, tvb, offset, len, ENC_ASCII|ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "SERR:%s ", argv);\r\nif(len!=parameter){\r\nexpert_add_info_format(pinfo, ti, &ei_distcc_short_pdu, "[Short SERR PDU]");\r\n}\r\nreturn offset+len;\r\n}\r\nstatic int\r\ndissect_distcc_sout(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, gint parameter)\r\n{\r\nchar argv[256];\r\nint argv_len;\r\ngint len=parameter;\r\nproto_item* ti;\r\nCHECK_PDU_LEN("SOUT");\r\nDESEGMENT_TCP("SOUT");\r\nargv_len=len>255?255:len;\r\ntvb_memcpy(tvb, argv, offset, argv_len);\r\nargv[argv_len]=0;\r\nti = proto_tree_add_item(tree, hf_distcc_sout, tvb, offset, len, ENC_ASCII|ENC_NA);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "SOUT:%s ", argv);\r\nif(len!=parameter){\r\nexpert_add_info_format(pinfo, ti, &ei_distcc_short_pdu, "[Short SOUT PDU]");\r\n}\r\nreturn offset+len;\r\n}\r\nstatic int\r\ndissect_distcc_doti(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, gint parameter)\r\n{\r\ngint len=parameter;\r\nproto_item* ti;\r\nCHECK_PDU_LEN("DOTI");\r\nDESEGMENT_TCP("DOTI");\r\ncol_append_str(pinfo->cinfo, COL_INFO, "DOTI source ");\r\nti = proto_tree_add_item(tree, hf_distcc_doti_source, tvb, offset, len, ENC_ASCII|ENC_NA);\r\nif(len!=parameter){\r\nexpert_add_info_format(pinfo, ti, &ei_distcc_short_pdu, "[Short DOTI PDU]");\r\n}\r\nreturn offset+len;\r\n}\r\nstatic int\r\ndissect_distcc_doto(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, gint parameter)\r\n{\r\ngint len=parameter;\r\nproto_item* ti;\r\nCHECK_PDU_LEN("DOTO");\r\nDESEGMENT_TCP("DOTO");\r\ncol_append_str(pinfo->cinfo, COL_INFO, "DOTO object ");\r\nti = proto_tree_add_item(tree, hf_distcc_doto_object, tvb, offset, len, ENC_NA);\r\nif(len!=parameter){\r\nexpert_add_info_format(pinfo, ti, &ei_distcc_short_pdu, "[Short DOTO PDU]");\r\n}\r\nreturn offset+len;\r\n}\r\nstatic int\r\ndissect_distcc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\r\n{\r\nint offset=0;\r\nproto_tree *tree=NULL;\r\nproto_item *item=NULL;\r\nchar buf[13];\r\nguint32 parameter;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "DISTCC ");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (parent_tree) {\r\nitem = proto_tree_add_item(parent_tree, proto_distcc, tvb, offset,\r\n-1, ENC_NA);\r\ntree = proto_item_add_subtree(item, ett_distcc);\r\n}\r\nwhile (TRUE) {\r\ntvb_memcpy(tvb, buf, offset, 12);\r\nbuf[12] = '\0';\r\noffset+=12;\r\nif (sscanf(buf + 4, "%08x", &parameter) != 1)\r\nreturn offset;\r\nif(!strncmp(buf, "DIST", 4)){\r\noffset=dissect_distcc_dist(tvb, pinfo, tree, offset, parameter);\r\n} else if(!strncmp(buf, "ARGC", 4)){\r\noffset=dissect_distcc_argc(tvb, pinfo, tree, offset, parameter);\r\n} else if(!strncmp(buf, "ARGV", 4)){\r\noffset=dissect_distcc_argv(tvb, pinfo, tree, offset, parameter);\r\n} else if(!strncmp(buf, "DOTI", 4)){\r\noffset=dissect_distcc_doti(tvb, pinfo, tree, offset, parameter);\r\n} else if(!strncmp(buf, "DONE", 4)){\r\noffset=dissect_distcc_done(tvb, pinfo, tree, offset, parameter);\r\n} else if(!strncmp(buf, "STAT", 4)){\r\noffset=dissect_distcc_stat(tvb, pinfo, tree, offset, parameter);\r\n} else if(!strncmp(buf, "SERR", 4)){\r\noffset=dissect_distcc_serr(tvb, pinfo, tree, offset, parameter);\r\n} else if(!strncmp(buf, "SOUT", 4)){\r\noffset=dissect_distcc_sout(tvb, pinfo, tree, offset, parameter);\r\n} else if(!strncmp(buf, "DOTO", 4)){\r\noffset=dissect_distcc_doto(tvb, pinfo, tree, offset, parameter);\r\n} else {\r\ncall_data_dissector(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_distcc(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{&hf_distcc_version,\r\n{"DISTCC Version", "distcc.version",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{&hf_distcc_argc,\r\n{"ARGC", "distcc.argc",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, "Number of arguments", HFILL }\r\n},\r\n{&hf_distcc_argv,\r\n{"ARGV", "distcc.argv",\r\nFT_STRING, BASE_NONE, NULL, 0x0, "ARGV argument", HFILL }\r\n},\r\n{&hf_distcc_doti_source,\r\n{"Source", "distcc.doti_source",\r\nFT_STRING, BASE_NONE, NULL, 0x0, "DOTI Preprocessed Source File (.i)", HFILL }\r\n},\r\n{&hf_distcc_stat,\r\n{"Status", "distcc.status",\r\nFT_UINT32, BASE_DEC, NULL, 0x0, "Unix wait status for command completion", HFILL }\r\n},\r\n{&hf_distcc_serr,\r\n{"SERR", "distcc.serr",\r\nFT_STRING, BASE_NONE, NULL, 0x0, "STDERR output", HFILL }\r\n},\r\n{&hf_distcc_sout,\r\n{"SOUT", "distcc.sout",\r\nFT_STRING, BASE_NONE, NULL, 0x0, "STDOUT output", HFILL }\r\n},\r\n{&hf_distcc_doto_object,\r\n{"Object", "distcc.doto_object",\r\nFT_BYTES, BASE_NONE, NULL, 0x0, "DOTO Compiled object file (.o)", HFILL }\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_distcc,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_distcc_short_pdu, { "distcc.short_pdu", PI_MALFORMED, PI_ERROR, "Short PDU", EXPFILL }},\r\n};\r\nmodule_t *distcc_module;\r\nexpert_module_t* expert_distcc;\r\nproto_distcc = proto_register_protocol("Distcc Distributed Compiler", "DISTCC", "distcc");\r\nproto_register_field_array(proto_distcc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_distcc = expert_register_protocol(proto_distcc);\r\nexpert_register_field_array(expert_distcc, ei, array_length(ei));\r\ndistcc_module = prefs_register_protocol(proto_distcc,\r\nproto_reg_handoff_distcc);\r\nprefs_register_uint_preference(distcc_module, "tcp.port",\r\n"DISTCC TCP Port",\r\n"Set the TCP port for DISTCC messages",\r\n10,\r\n&glb_distcc_tcp_port);\r\nprefs_register_bool_preference(distcc_module, "desegment_distcc_over_tcp",\r\n"Reassemble DISTCC-over-TCP messages\nspanning multiple TCP segments",\r\n"Whether the DISTCC dissector should reassemble messages spanning multiple TCP segments."\r\n" To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&distcc_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_distcc(void)\r\n{\r\nstatic gboolean registered_dissector = FALSE;\r\nstatic int distcc_tcp_port;\r\nstatic dissector_handle_t distcc_handle;\r\nif (!registered_dissector) {\r\ndistcc_handle = create_dissector_handle(dissect_distcc,\r\nproto_distcc);\r\nregistered_dissector = TRUE;\r\n} else {\r\ndissector_delete_uint("tcp.port", distcc_tcp_port, distcc_handle);\r\n}\r\ndistcc_tcp_port = glb_distcc_tcp_port;\r\ndissector_add_uint("tcp.port", distcc_tcp_port, distcc_handle);\r\n}
