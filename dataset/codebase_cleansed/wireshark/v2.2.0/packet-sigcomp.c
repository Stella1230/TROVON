static void\r\nsigcomp_init_udvm(void) {\r\ngchar *partial_state_str;\r\nguint8 *sip_sdp_buff, *presence_buff;\r\nstate_buffer_table = g_hash_table_new_full(g_str_hash,\r\ng_str_equal,\r\ng_free,\r\ng_free);\r\nsip_sdp_buff = (guint8 *)g_malloc(SIP_SDP_STATE_LENGTH + 8);\r\npartial_state_str = bytes_to_str(NULL, sip_sdp_state_identifier, 6);\r\nmemset(sip_sdp_buff, 0, 8);\r\nsip_sdp_buff[0] = SIP_SDP_STATE_LENGTH >> 8;\r\nsip_sdp_buff[1] = SIP_SDP_STATE_LENGTH & 0xff;\r\nmemcpy(sip_sdp_buff+8, sip_sdp_static_dictionaty_for_sigcomp, SIP_SDP_STATE_LENGTH);\r\ng_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), sip_sdp_buff);\r\nwmem_free(NULL, partial_state_str);\r\npresence_buff = (guint8 *)g_malloc(PRESENCE_STATE_LENGTH + 8);\r\npartial_state_str = bytes_to_str(NULL, presence_state_identifier, 6);\r\nmemset(presence_buff, 0, 8);\r\npresence_buff[0] = PRESENCE_STATE_LENGTH >> 8;\r\npresence_buff[1] = PRESENCE_STATE_LENGTH & 0xff;\r\nmemcpy(presence_buff+8, presence_static_dictionary_for_sigcomp, PRESENCE_STATE_LENGTH);\r\ng_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), presence_buff);\r\nwmem_free(NULL, partial_state_str);\r\n}\r\nstatic void\r\nsigcomp_cleanup_udvm(void) {\r\ng_hash_table_destroy(state_buffer_table);\r\n}\r\nstatic int udvm_state_access(tvbuff_t *tvb, proto_tree *tree,guint8 *buff,guint16 p_id_start, guint16 p_id_length, guint16 state_begin, guint16 *state_length,\r\nguint16 *state_address, guint16 *state_instruction,\r\ngint hf_id)\r\n{\r\nint result_code = 0;\r\nguint32 n;\r\nguint16 k;\r\nguint16 buf_size_real;\r\nguint16 byte_copy_right;\r\nguint16 byte_copy_left;\r\nchar partial_state[STATE_BUFFER_SIZE];\r\nguint8 *state_buff;\r\ngchar *partial_state_str;\r\nif (( p_id_length < STATE_MIN_ACCESS_LEN ) || ( p_id_length > STATE_BUFFER_SIZE )) {\r\nresult_code = 1;\r\nreturn result_code;\r\n}\r\nn = 0;\r\nwhile ( n < p_id_length && n < STATE_BUFFER_SIZE && p_id_start + n < UDVM_MEMORY_SIZE ) {\r\npartial_state[n] = buff[p_id_start + n];\r\nn++;\r\n}\r\npartial_state_str = bytes_to_str(wmem_packet_scope(), partial_state, p_id_length);\r\nproto_tree_add_item(tree, hf_sigcomp_accessing_state, tvb, 0, -1, ENC_NA);\r\nproto_tree_add_string(tree,hf_id, tvb, 0, 0, partial_state_str);\r\nstate_buff = (guint8 *)g_hash_table_lookup(state_buffer_table, partial_state_str);\r\nif ( state_buff == NULL ) {\r\nresult_code = 2;\r\nreturn result_code;\r\n}\r\nbuf_size_real = (state_buff[0] << 8) | state_buff[1];\r\nif (*state_length == 0) {\r\n*state_length = buf_size_real;\r\n}\r\nif ( *state_address == 0 ) {\r\n*state_address = state_buff[2] << 8;\r\n*state_address = *state_address | state_buff[3];\r\n}\r\nif ( *state_instruction == 0 ) {\r\n*state_instruction = state_buff[4] << 8;\r\n*state_instruction = *state_instruction | state_buff[5];\r\n}\r\nif ((state_begin + *state_length) > buf_size_real) {\r\nreturn 3;\r\n}\r\nif (*state_length == 0 && state_begin != 0) {\r\nreturn 17;\r\n}\r\nn = state_begin + 8;\r\nk = *state_address;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nwhile ( (gint32) n < (state_begin + *state_length + 8) && n < UDVM_MEMORY_SIZE ) {\r\nbuff[k] = state_buff[n];\r\nk = ( k + 1 ) & 0xffff;\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\nn++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void udvm_state_create(guint8 *state_buff,guint8 *state_identifier,guint16 p_id_length) {\r\nchar partial_state[STATE_BUFFER_SIZE];\r\nguint i;\r\ngchar *partial_state_str;\r\ngchar *dummy_buff;\r\ni = 0;\r\nwhile ( i < p_id_length && i < STATE_BUFFER_SIZE ) {\r\npartial_state[i] = state_identifier[i];\r\ni++;\r\n}\r\npartial_state_str = bytes_to_str(NULL, partial_state, p_id_length);\r\ndummy_buff = (gchar *)g_hash_table_lookup(state_buffer_table, partial_state_str);\r\nif ( dummy_buff == NULL ) {\r\ng_hash_table_insert(state_buffer_table, g_strdup(partial_state_str), state_buff);\r\n} else {\r\ng_free(state_buff);\r\n}\r\nwmem_free(NULL, partial_state_str);\r\n}\r\nstatic void udvm_state_free(guint8 buff[] _U_,guint16 p_id_start _U_,guint16 p_id_length _U_) {\r\n}\r\nvoid udvm_state_free(guint8 buff[],guint16 p_id_start,guint16 p_id_length) {\r\nchar partial_state[STATE_BUFFER_SIZE];\r\nguint i;\r\ngchar *partial_state_str;\r\ngchar *dummy_buff;\r\ni = 0;\r\nwhile ( i < p_id_length && i < STATE_BUFFER_SIZE && p_id_start + i < UDVM_MEMORY_SIZE ) {\r\npartial_state[i] = buff[p_id_start + i];\r\ni++;\r\n}\r\npartial_state_str = bytes_to_str(NULL, partial_state, p_id_length);\r\ndummy_buff = g_hash_table_lookup(state_buffer_table, partial_state_str);\r\nif ( dummy_buff != NULL ) {\r\ng_hash_table_remove (state_buffer_table, partial_state_str);\r\ng_free(dummy_buff);\r\n}\r\nwmem_free(NULL, partial_state_str);\r\n}\r\nstatic int\r\ndecode_udvm_literal_operand(guint8 *buff,guint operand_address, guint16 *value)\r\n{\r\nguint bytecode;\r\nguint16 operand;\r\nguint test_bits;\r\nguint offset = operand_address;\r\nguint8 temp_data;\r\nbytecode = buff[operand_address];\r\ntest_bits = bytecode >> 7;\r\nif (test_bits == 1) {\r\ntest_bits = bytecode >> 6;\r\nif (test_bits == 2) {\r\ntemp_data = buff[operand_address] & 0x1f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\n*value = operand;\r\noffset = offset + 2;\r\n} else {\r\noffset ++;\r\ntemp_data = buff[operand_address] & 0x1f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\n*value = operand;\r\noffset = offset + 2;\r\n}\r\n} else {\r\noperand = ( bytecode & 0x7f);\r\n*value = operand;\r\noffset ++;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_udvm_reference_operand_memory(guint8 *buff,guint operand_address, guint16 *value,guint *result_dest)\r\n{\r\nguint bytecode;\r\nguint16 operand;\r\nguint offset = operand_address;\r\nguint test_bits;\r\nguint8 temp_data;\r\nguint16 temp_data16;\r\nbytecode = buff[operand_address];\r\ntest_bits = bytecode >> 7;\r\nif (test_bits == 1) {\r\ntest_bits = bytecode >> 6;\r\nif (test_bits == 2) {\r\ntemp_data = buff[operand_address] & 0x3f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\noperand = (operand * 2);\r\n*result_dest = operand;\r\ntemp_data16 = buff[operand] << 8;\r\ntemp_data16 = temp_data16 | buff[(operand+1) & 0xffff];\r\n*value = temp_data16;\r\noffset = offset + 2;\r\n} else {\r\noperand_address++;\r\noperand = buff[operand_address] << 8;\r\noperand = operand | buff[(operand_address + 1) & 0xffff];\r\n*result_dest = operand;\r\ntemp_data16 = buff[operand] << 8;\r\ntemp_data16 = temp_data16 | buff[(operand+1) & 0xffff];\r\n*value = temp_data16;\r\noffset = offset + 3;\r\n}\r\n} else {\r\noperand = ( bytecode & 0x7f);\r\noperand = (operand * 2);\r\n*result_dest = operand;\r\ntemp_data16 = buff[operand] << 8;\r\ntemp_data16 = temp_data16 | buff[(operand+1) & 0xffff];\r\n*value = temp_data16;\r\noffset ++;\r\n}\r\nif (offset >= UDVM_MEMORY_SIZE || *result_dest >= UDVM_MEMORY_SIZE - 1 )\r\nreturn 0;\r\nreturn offset;\r\n}\r\nstatic int\r\ndecode_udvm_multitype_operand(guint8 *buff,guint operand_address, guint16 *value)\r\n{\r\nguint test_bits;\r\nguint bytecode;\r\nguint offset = operand_address;\r\nguint16 operand;\r\nguint32 result;\r\nguint8 temp_data;\r\nguint16 temp_data16;\r\nguint16 memmory_addr = 0;\r\n*value = 0;\r\nbytecode = buff[operand_address];\r\ntest_bits = ( bytecode & 0xc0 ) >> 6;\r\nswitch (test_bits ) {\r\ncase 0:\r\noperand = buff[operand_address];\r\n*value = operand;\r\noffset ++;\r\nbreak;\r\ncase 1:\r\nmemmory_addr = ( bytecode & 0x3f) * 2;\r\ntemp_data16 = buff[memmory_addr] << 8;\r\ntemp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];\r\n*value = temp_data16;\r\noffset ++;\r\nbreak;\r\ncase 2:\r\ntest_bits = ( bytecode & 0xe0 ) >> 5;\r\nif ( test_bits == 5 ) {\r\ntemp_data = buff[operand_address] & 0x1f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\n*value = operand;\r\noffset = offset + 2;\r\n} else {\r\ntest_bits = ( bytecode & 0xf0 ) >> 4;\r\nif ( test_bits == 9 ) {\r\ntemp_data = buff[operand_address] & 0x0f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\noperand = operand + 61440;\r\n*value = operand;\r\noffset = offset + 2;\r\n} else {\r\ntest_bits = ( bytecode & 0x08 ) >> 3;\r\nif ( test_bits == 1) {\r\nresult = 1 << ((buff[operand_address] & 0x07) + 8);\r\noperand = result & 0xffff;\r\n*value = operand;\r\noffset ++;\r\n} else {\r\ntest_bits = ( bytecode & 0x0e ) >> 1;\r\nif ( test_bits == 3 ) {\r\nresult = 1 << ((buff[operand_address] & 0x01) + 6);\r\noperand = result & 0xffff;\r\n*value = operand;\r\noffset ++;\r\n} else {\r\noffset ++;\r\ntemp_data16 = buff[(operand_address + 1) & 0xffff] << 8;\r\ntemp_data16 = temp_data16 | buff[(operand_address + 2) & 0xffff];\r\nif ( (bytecode & 0x01) == 1 ) {\r\nmemmory_addr = temp_data16;\r\ntemp_data16 = buff[memmory_addr] << 8;\r\ntemp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];\r\n}\r\n*value = temp_data16;\r\noffset = offset +2;\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ncase 3:\r\ntest_bits = ( bytecode & 0x20 ) >> 5;\r\nif ( test_bits == 1 ) {\r\noperand = ( buff[operand_address] & 0x1f) + 65504;\r\n*value = operand;\r\noffset ++;\r\n} else {\r\nmemmory_addr = buff[operand_address] & 0x1f;\r\nmemmory_addr = memmory_addr << 8;\r\nmemmory_addr = memmory_addr | buff[(operand_address + 1) & 0xffff];\r\ntemp_data16 = buff[memmory_addr] << 8;\r\ntemp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];\r\n*value = temp_data16;\r\noffset = offset +2;\r\n}\r\ndefault :\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndecode_udvm_address_operand(guint8 *buff,guint operand_address, guint16 *value,guint current_address)\r\n{\r\nguint32 result;\r\nguint16 value1;\r\nguint next_opreand_address;\r\nnext_opreand_address = decode_udvm_multitype_operand(buff, operand_address, &value1);\r\nresult = value1 & 0xffff;\r\nresult = result + current_address;\r\n*value = result & 0xffff;\r\nreturn next_opreand_address;\r\n}\r\nstatic int\r\ndecomp_dispatch_get_bits(\r\ntvbuff_t *message_tvb,\r\nproto_tree *udvm_tree,\r\nguint8 bit_order,\r\nguint8 *buff,\r\nguint16 *old_input_bit_order,\r\nguint16 *remaining_bits,\r\nguint16 *input_bits,\r\nguint *input_address,\r\nguint16 length,\r\nguint16 *result_code,\r\nguint msg_end,\r\ngboolean print_level_1)\r\n{\r\nguint16 input_bit_order;\r\nguint16 bits_still_required = length;\r\nguint16 value = 0;\r\nguint8 octet;\r\ngint extra_bytes_available = msg_end - *input_address;\r\ngint p_bit;\r\ngint prev_p_bit = *old_input_bit_order & 0x0001;\r\ngint bits_to_use = 0;\r\ninput_bit_order = buff[68] << 8;\r\ninput_bit_order = input_bit_order | buff[69];\r\n*result_code = 0;\r\np_bit = (input_bit_order & 0x0001) != 0;\r\nif (prev_p_bit != p_bit)\r\n{\r\n*remaining_bits = 0;\r\n*old_input_bit_order = input_bit_order;\r\n}\r\nif (*remaining_bits + extra_bytes_available * 8 < length)\r\n{\r\n*result_code = 11;\r\nreturn 0xfbad;\r\n}\r\nwhile (bits_still_required > 0)\r\n{\r\nif (*remaining_bits == 0)\r\n{\r\noctet = tvb_get_guint8(message_tvb, *input_address);\r\nif (print_level_1 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_getting_value, message_tvb, *input_address, 1, octet,\r\n" Getting value: %u (0x%x) From Addr: %u", octet, octet, *input_address);\r\n}\r\n*input_address = *input_address + 1;\r\nif (p_bit != 0)\r\n{\r\noctet = reverse[octet];\r\n}\r\n*input_bits = octet;\r\n*remaining_bits = 8;\r\n}\r\nbits_to_use = bits_still_required < *remaining_bits ? bits_still_required : *remaining_bits;\r\nbits_still_required -= bits_to_use;\r\n*input_bits <<= bits_to_use;\r\nvalue = (value << bits_to_use)\r\n| ((*input_bits >> 8) & 0xFF);\r\n*remaining_bits -= bits_to_use;\r\n*input_bits &= 0x00FF;\r\n}\r\nif (bit_order != 0)\r\n{\r\nguint16 lsb = reverse[(value >> 8) & 0xFF];\r\nguint16 msb = reverse[value & 0xFF];\r\nvalue = ((msb << 8) | lsb) >> (16 - length);\r\n}\r\nreturn value;\r\n}\r\nstatic tvbuff_t*\r\ndecompress_sigcomp_message(tvbuff_t *bytecode_tvb, tvbuff_t *message_tvb, packet_info *pinfo,\r\nproto_tree *udvm_tree, gint udvm_mem_dest,\r\ngint print_flags, gint hf_id,\r\ngint header_len,\r\ngint byte_code_state_len, gint byte_code_id_len,\r\ngint udvm_start_ip)\r\n{\r\ntvbuff_t *decomp_tvb;\r\nguint8 *buff = (guint8 *)wmem_alloc0(wmem_packet_scope(), UDVM_MEMORY_SIZE);\r\nchar string[2];\r\nguint8 *out_buff;\r\nguint32 i = 0;\r\nguint16 n = 0;\r\nguint16 m = 0;\r\nguint16 x;\r\nguint k = 0;\r\nguint16 H;\r\nguint16 oldH;\r\nguint offset = 0;\r\nguint start_offset;\r\nguint result_dest;\r\nguint code_length = 0;\r\nguint8 current_instruction;\r\nguint current_address;\r\nguint operand_address;\r\nguint input_address;\r\nguint16 output_address = 0;\r\nguint next_operand_address;\r\nguint8 octet;\r\nguint8 msb;\r\nguint8 lsb;\r\nguint16 byte_copy_right;\r\nguint16 byte_copy_left;\r\nguint16 input_bit_order;\r\nguint16 stack_location;\r\nguint16 stack_fill;\r\nguint16 result;\r\nguint msg_end = tvb_reported_length_remaining(message_tvb, 0);\r\nguint16 result_code = 0;\r\nguint16 old_input_bit_order = 0;\r\nguint16 remaining_bits = 0;\r\nguint16 input_bits = 0;\r\nguint8 bit_order = 0;\r\ngboolean outside_huffman_boundaries = TRUE;\r\ngboolean print_in_loop = FALSE;\r\nguint16 instruction_address;\r\nguint8 no_of_state_create = 0;\r\nguint16 state_length_buff[5];\r\nguint16 state_address_buff[5];\r\nguint16 state_instruction_buff[5];\r\nguint16 state_minimum_access_length_buff[5];\r\nguint32 used_udvm_cycles = 0;\r\nguint cycles_per_bit;\r\nguint maximum_UDVM_cycles;\r\nguint8 *sha1buff;\r\nunsigned char sha1_digest_buf[STATE_BUFFER_SIZE];\r\nsha1_context ctx;\r\nproto_item *addr_item = NULL;\r\nguint16 length;\r\nguint16 at_address;\r\nguint16 destination;\r\nguint16 addr;\r\nguint16 value;\r\nguint16 p_id_start;\r\nguint16 p_id_length;\r\nguint16 state_begin;\r\nguint16 state_length;\r\nguint16 state_address;\r\nguint16 state_instruction;\r\nguint16 operand_1;\r\nguint16 operand_2;\r\nguint16 value_1;\r\nguint16 value_2;\r\nguint16 at_address_1;\r\nguint16 at_address_2;\r\nguint16 at_address_3;\r\nguint16 j;\r\nguint16 bits_n;\r\nguint16 lower_bound_n;\r\nguint16 upper_bound_n;\r\nguint16 uncompressed_n;\r\nguint16 position;\r\nguint16 ref_destination;\r\nguint16 multy_offset;\r\nguint16 output_start;\r\nguint16 output_length;\r\nguint16 minimum_access_length;\r\nguint16 state_retention_priority;\r\nguint16 requested_feedback_location;\r\nguint16 returned_parameters_location;\r\nguint16 start_value;\r\ngboolean print_level_1 = FALSE;\r\ngboolean print_level_2 = FALSE;\r\ngboolean print_level_3 = FALSE;\r\ngint show_instr_detail_level = 0;\r\nswitch ( print_flags ) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nprint_level_1 = TRUE;\r\nshow_instr_detail_level = 1;\r\nbreak;\r\ncase 2:\r\nprint_level_1 = TRUE;\r\nprint_level_2 = TRUE;\r\nshow_instr_detail_level = 1;\r\nbreak;\r\ncase 3:\r\nprint_level_1 = TRUE;\r\nprint_level_2 = TRUE;\r\nprint_level_3 = TRUE;\r\nshow_instr_detail_level = 2;\r\nbreak;\r\ndefault:\r\nprint_level_1 = TRUE;\r\nshow_instr_detail_level = 1;\r\nbreak;\r\n}\r\nbuff[0] = (UDVM_MEMORY_SIZE >> 8) & 0x00FF;\r\nbuff[1] = UDVM_MEMORY_SIZE & 0x00FF;\r\nbuff[2] = 0;\r\nbuff[3] = 16;\r\nbuff[4] = 0;\r\nbuff[5] = 1;\r\nbuff[6] = (byte_code_id_len >> 8) & 0x00FF;\r\nbuff[7] = byte_code_id_len & 0x00FF;\r\nbuff[8] = (byte_code_state_len >> 8) & 0x00FF;\r\nbuff[9] = byte_code_state_len & 0x00FF;\r\ncode_length = tvb_reported_length_remaining(bytecode_tvb, 0);\r\ncycles_per_bit = buff[2] << 8;\r\ncycles_per_bit = cycles_per_bit | buff[3];\r\nmaximum_UDVM_cycles = (( 8 * (header_len + msg_end) ) + 1000) * cycles_per_bit;\r\nproto_tree_add_uint(udvm_tree, hf_sigcomp_message_length, bytecode_tvb, offset, 1, msg_end);\r\nproto_tree_add_uint(udvm_tree, hf_sigcomp_byte_code_length, bytecode_tvb, offset, 1, code_length);\r\nproto_tree_add_uint(udvm_tree, hf_sigcomp_max_udvm_cycles, bytecode_tvb, offset, 1, maximum_UDVM_cycles);\r\ni = udvm_mem_dest;\r\nif ( print_level_3 )\r\nproto_tree_add_uint(udvm_tree, hf_sigcomp_load_bytecode_into_udvm_start, bytecode_tvb, offset, 1, i);\r\nwhile ( code_length > offset && i < UDVM_MEMORY_SIZE ) {\r\nbuff[i] = tvb_get_guint8(bytecode_tvb, offset);\r\nif ( print_level_3 )\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_instruction_code, bytecode_tvb, offset, 1, buff[i],\r\n" Addr: %u Instruction code(0x%02x) ", i, buff[i]);\r\ni++;\r\noffset++;\r\n}\r\ncurrent_address = udvm_start_ip;\r\ninput_address = 0;\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_udvm_execution_stated, bytecode_tvb, offset, 1, current_address,\r\n"UDVM EXECUTION STARTED at Address: %u Message size %u", current_address, msg_end);\r\nout_buff = (guint8 *)g_malloc(UDVM_MEMORY_SIZE);\r\noffset = 0;\r\nexecute_next_instruction:\r\nif ( used_udvm_cycles > maximum_UDVM_cycles ) {\r\nresult_code = 15;\r\ngoto decompression_failure;\r\n}\r\nused_udvm_cycles++;\r\ncurrent_instruction = buff[current_address & 0xffff];\r\nif (show_instr_detail_level == 2 ) {\r\naddr_item = proto_tree_add_uint_format(udvm_tree, hf_sigcomp_current_instruction, bytecode_tvb, offset, 1, current_instruction,\r\n"Addr: %u ## %s(%d)", current_address,\r\nval_to_str_ext_const(current_instruction, &udvm_instruction_code_vals_ext, "INVALID INSTRUCTION"),\r\ncurrent_instruction);\r\n}\r\noffset++;\r\nswitch ( current_instruction ) {\r\ncase SIGCOMP_INSTR_DECOMPRESSION_FAILURE:\r\nif ( result_code == 0 )\r\nresult_code = 9;\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_decompression_failure, NULL, 0, 0,\r\ncurrent_address, "Addr: %u ## DECOMPRESSION-FAILURE(0)",\r\ncurrent_address);\r\nproto_tree_add_uint(udvm_tree, hf_sigcomp_wireshark_udvm_diagnostic, NULL, 0, 0, result_code);\r\nif ( output_address > 0 ) {\r\ndecomp_tvb = tvb_new_child_real_data(message_tvb, out_buff,output_address,output_address);\r\ntvb_set_free_cb( decomp_tvb, g_free );\r\nadd_new_data_source(pinfo, decomp_tvb, "Decompressed SigComp message(Incomplete)");\r\nproto_tree_add_expert(udvm_tree, pinfo, &ei_sigcomp_sigcomp_message_decompression_failure, decomp_tvb, 0, -1);\r\nreturn decomp_tvb;\r\n}\r\ng_free(out_buff);\r\nreturn NULL;\r\nbreak;\r\ncase SIGCOMP_INSTR_AND:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (operand_1, operand_2)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_2, bytecode_tvb, offset, (next_operand_address-operand_address), operand_2,\r\n"Addr: %u operand_2 %u", operand_address, operand_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## AND (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 & operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_OR:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (operand_1, operand_2)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_2, bytecode_tvb, offset, (next_operand_address-operand_address), operand_2,\r\n"Addr: %u operand_2 %u", operand_address, operand_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## OR (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 | operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_NOT:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " ($operand_1)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## NOT (operand_1=%u)",\r\ncurrent_address, operand_1);\r\n}\r\nresult = operand_1 ^ 0xffff;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_LSHIFT:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " ($operand_1, operand_2)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_2, bytecode_tvb, offset, (next_operand_address-operand_address), operand_2,\r\n"Addr: %u operand_2 %u", operand_address, operand_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## LSHIFT (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 << operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_RSHIFT:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (operand_1, operand_2)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_2, bytecode_tvb, offset, (next_operand_address-operand_address), operand_2,\r\n"Addr: %u operand_2 %u", operand_address, operand_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## RSHIFT (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 >> operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_ADD:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (operand_1, operand_2)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_2, bytecode_tvb, offset, (next_operand_address-operand_address), operand_2,\r\n"Addr: %u operand_2 %u", operand_address, operand_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## ADD (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 + operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\ncase SIGCOMP_INSTR_SUBTRACT:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (operand_1, operand_2)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_2, bytecode_tvb, offset, (next_operand_address-operand_address), operand_2,\r\n"Addr: %u operand_2 %u", operand_address, operand_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## SUBTRACT (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 - operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_MULTIPLY:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (operand_1, operand_2)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_2, bytecode_tvb, offset, (next_operand_address-operand_address), operand_2,\r\n"Addr: %u operand_2 %u", operand_address, operand_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## MULTIPLY (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nif ( operand_2 == 0) {\r\nresult_code = 4;\r\ngoto decompression_failure;\r\n}\r\nresult = operand_1 * operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_DIVIDE:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (operand_1, operand_2)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_2, bytecode_tvb, offset, (next_operand_address-operand_address), operand_2,\r\n"Addr: %u operand_2 %u", operand_address, operand_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## DIVIDE (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nif ( operand_2 == 0) {\r\nresult_code = 4;\r\ngoto decompression_failure;\r\n}\r\nresult = operand_1 / operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_REMAINDER:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (operand_1, operand_2)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &operand_1, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_1, bytecode_tvb, offset, (next_operand_address-operand_address), operand_1,\r\n"Addr: %u operand_1 %u", operand_address, operand_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_operand_2, bytecode_tvb, offset, (next_operand_address-operand_address), operand_2,\r\n"Addr: %u operand_2 %u", operand_address, operand_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## REMAINDER (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nif ( operand_2 == 0) {\r\nresult_code = 4;\r\ngoto decompression_failure;\r\n}\r\nresult = operand_1 - operand_2 * (operand_1 / operand_2);\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading result %u at %u", result, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_SORT_ASCENDING:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (start, n, k))");\r\n}\r\nproto_tree_add_expert(udvm_tree, pinfo, &ei_sigcomp_execution_of_this_instruction_is_not_implemented, bytecode_tvb, 0, -1);\r\nbreak;\r\ncase SIGCOMP_INSTR_SORT_DESCENDING:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (start, n, k))");\r\n}\r\nproto_tree_add_expert(udvm_tree, pinfo, &ei_sigcomp_execution_of_this_instruction_is_not_implemented, bytecode_tvb, 0, -1);\r\nbreak;\r\ncase SIGCOMP_INSTR_SHA_1:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (position, length, destination)");\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);\r\nif (print_level_1 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_position, bytecode_tvb, offset, (next_operand_address-operand_address), position,\r\n"Addr: %u position %u", operand_address, position);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (print_level_1 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_length, bytecode_tvb, offset, (next_operand_address-operand_address), length,\r\n"Addr: %u Length %u", operand_address, length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &ref_destination, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (print_level_1 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_ref_dest, bytecode_tvb, offset, (next_operand_address-operand_address), ref_destination,\r\n"Addr: %u $destination %u", operand_address, ref_destination);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nused_udvm_cycles = used_udvm_cycles + length;\r\nn = 0;\r\nk = position;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, message_tvb, 0, -1,\r\nNULL, "byte_copy_right = %u", byte_copy_right);\r\n}\r\nsha1_starts( &ctx );\r\nwhile (n<length) {\r\nguint16 handle_now = length;\r\nif ( k < byte_copy_right && byte_copy_right <= k + (length-n) ) {\r\nhandle_now = byte_copy_right - position;\r\n}\r\nif (k + handle_now >= UDVM_MEMORY_SIZE)\r\ngoto decompression_failure;\r\nsha1_update( &ctx, &buff[k], handle_now );\r\nk = ( k + handle_now ) & 0xffff;\r\nn = ( n + handle_now ) & 0xffff;\r\nif ( k >= byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\n}\r\nsha1_finish( &ctx, sha1_digest_buf );\r\nk = ref_destination;\r\nfor ( n=0; n< STATE_BUFFER_SIZE; n++ ) {\r\nbuff[k] = sha1_digest_buf[n];\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\n}\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_with_length(udvm_tree, hf_sigcomp_calculated_sha_1, message_tvb, 0, -1,\r\nsha1_digest_buf, STATE_BUFFER_SIZE);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_LOAD:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (%%address, %%value)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_address, bytecode_tvb, offset, (next_operand_address-operand_address), addr,\r\n"Addr: %u Address %u", operand_address, addr);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);\r\nif (show_instr_detail_level == 2)\r\n{\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_value, bytecode_tvb, offset, (next_operand_address-operand_address), value,\r\n"Addr: %u Value %u", operand_address, value);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nlsb = value & 0xff;\r\nmsb = value >> 8;\r\nbuff[addr] = msb;\r\nbuff[(addr + 1) & 0xffff] = lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## LOAD (%%address=%u, %%value=%u)",\r\ncurrent_address, addr, value);\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n" Loading bytes at %u Value %u 0x%x", addr, value, value);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_MULTILOAD:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (%%address, #n, value_0, ..., value_n-1)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_address, bytecode_tvb, offset, (next_operand_address-operand_address), addr,\r\n"Addr: %u Address %u", operand_address, addr);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_literal_num, bytecode_tvb, offset, (next_operand_address-operand_address), n,\r\n"Addr: %u n %u", operand_address, n);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## MULTILOAD (%%address=%u, #n=%u, value_0, ..., value_%d)",\r\ncurrent_address, addr, n, n-1);\r\n}\r\noperand_address = next_operand_address;\r\nused_udvm_cycles = used_udvm_cycles + n;\r\nwhile ( n > 0) {\r\nn = n - 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);\r\nlsb = value & 0xff;\r\nmsb = value >> 8;\r\nif (addr >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[addr] = msb;\r\nbuff[(addr + 1) & 0xffff] = lsb;\r\nlength = next_operand_address - operand_address;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, bytecode_tvb, 0, -1,\r\n"Addr: %u Value %5u - Loading bytes at %5u Value %5u 0x%x", operand_address, value, addr, value, value);\r\n}\r\naddr = addr + 2;\r\noperand_address = next_operand_address;\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_PUSH:\r\nif (show_instr_detail_level == 2) {\r\nproto_item_append_text(addr_item, " (value)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);\r\nif (show_instr_detail_level == 2) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_value, bytecode_tvb, offset, (next_operand_address-operand_address), value,\r\n"Addr: %u Value %u", operand_address, value);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## PUSH (value=%u)",\r\ncurrent_address, value);\r\n}\r\ncurrent_address = next_operand_address;\r\nstack_location = (buff[70] << 8) | buff[71];\r\nstack_fill = (buff[stack_location] << 8)\r\n| buff[(stack_location+1) & 0xFFFF];\r\naddr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;\r\nif (addr >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[addr] = (value >> 8) & 0x00FF;\r\nbuff[(addr+1) & 0xFFFF] = value & 0x00FF;\r\nif (stack_location >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nstack_fill = (stack_fill + 1) & 0xFFFF;\r\nbuff[stack_location] = (stack_fill >> 8) & 0x00FF;\r\nbuff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_POP:\r\nif (show_instr_detail_level == 2) {\r\nproto_item_append_text(addr_item, " (value)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_address, bytecode_tvb, offset, (next_operand_address-operand_address), destination,\r\n"Addr: %u Value %u", operand_address, destination);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## POP (address=%u)",\r\ncurrent_address, destination);\r\n}\r\ncurrent_address = next_operand_address;\r\nstack_location = (buff[70] << 8) | buff[71];\r\nstack_fill = (buff[stack_location] << 8)\r\n| buff[(stack_location+1) & 0xFFFF];\r\nif (stack_fill == 0)\r\n{\r\nresult_code = 16;\r\ngoto decompression_failure;\r\n}\r\nif (stack_location >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nstack_fill = (stack_fill - 1) & 0xFFFF;\r\nbuff[stack_location] = (stack_fill >> 8) & 0x00FF;\r\nbuff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;\r\naddr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;\r\nif (addr >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nvalue = (buff[addr] << 8)\r\n| buff[(addr+1) & 0xFFFF];\r\nif (destination >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[destination] = (value >> 8) & 0x00FF;\r\nbuff[(destination+1) & 0xFFFF] = value & 0x00FF;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_COPY:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (position, length, destination)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_position, bytecode_tvb, offset, (next_operand_address-operand_address), position,\r\n"Addr: %u position %u", operand_address, position);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_length, bytecode_tvb, offset, (next_operand_address-operand_address), length,\r\n"Addr: %u Length %u", operand_address, length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_ref_dest, bytecode_tvb, offset, (next_operand_address-operand_address), destination,\r\n"Addr: %u Destination %u", operand_address, destination);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## COPY (position=%u, length=%u, destination=%u)",\r\ncurrent_address, position, length, destination);\r\n}\r\ncurrent_address = next_operand_address;\r\nn = 0;\r\nk = destination;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, message_tvb, input_address, 1,\r\nNULL, " byte_copy_right = %u", byte_copy_right);\r\n}\r\nwhile ( n < length ) {\r\nbuff[k] = buff[position];\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_copying_value, message_tvb, input_address, 1,\r\nbuff[position], " Copying value: %u (0x%x) to Addr: %u",\r\nbuff[position], buff[position], k);\r\n}\r\nposition = ( position + 1 ) & 0xffff;\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\nif ( position == byte_copy_right ) {\r\nposition = byte_copy_left;\r\n}\r\n}\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_COPY_LITERAL:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (position, length, $destination)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_position, bytecode_tvb, offset, (next_operand_address-operand_address), position,\r\n"Addr: %u position %u", operand_address, position);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_length, bytecode_tvb, offset, (next_operand_address-operand_address), length,\r\n"Addr: %u Length %u", operand_address, length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &ref_destination, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_ref_dest, bytecode_tvb, offset, (next_operand_address-operand_address), ref_destination,\r\n"Addr: %u destination %u", operand_address, ref_destination);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## COPY-LITERAL (position=%u, length=%u, $destination=%u)",\r\ncurrent_address, position, length, ref_destination);\r\n}\r\ncurrent_address = next_operand_address;\r\nn = 0;\r\nk = ref_destination;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, message_tvb, input_address, 1,\r\nNULL, " byte_copy_right = %u", byte_copy_right);\r\n}\r\nwhile ( n < length ) {\r\nbuff[k] = buff[position];\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_copying_value, message_tvb, input_address, 1,\r\nbuff[position], " Copying value: %u (0x%x) to Addr: %u",\r\nbuff[position], buff[position], k);\r\n}\r\nposition = ( position + 1 ) & 0xffff;\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\nif ( position == byte_copy_right ) {\r\nposition = byte_copy_left;\r\n}\r\n}\r\nbuff[result_dest] = k >> 8;\r\nbuff[(result_dest + 1) & 0xffff] = k & 0x00ff;\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_COPY_OFFSET:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (offset, length, $destination)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &multy_offset);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_offset, bytecode_tvb, offset, (next_operand_address-operand_address), multy_offset,\r\n"Addr: %u offset %u", operand_address, multy_offset);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_length, bytecode_tvb, offset, (next_operand_address-operand_address), length,\r\n"Addr: %u Length %u", operand_address, length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = dissect_udvm_reference_operand_memory(buff, operand_address, &ref_destination, &result_dest);\r\nif (next_operand_address < operand_address)\r\ngoto decompression_failure;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_ref_dest, bytecode_tvb, offset, (next_operand_address-operand_address), ref_destination,\r\n"Addr: %u $destination %u", operand_address, ref_destination);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## COPY-OFFSET (offset=%u, length=%u, $destination=%u)",\r\ncurrent_address, multy_offset, length, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nfor (position = ref_destination, i = 0; i < multy_offset; i++)\r\n{\r\nif ( position == byte_copy_left )\r\n{\r\nposition = (byte_copy_right - 1) & 0xffff;\r\n}\r\nelse\r\n{\r\nposition = (position - 1) & 0xffff;\r\n}\r\n}\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, message_tvb, input_address, 1,\r\nNULL, " byte_copy_left = %u byte_copy_right = %u position= %u",\r\nbyte_copy_left, byte_copy_right, position);\r\n}\r\nn = 0;\r\nk = ref_destination;\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, message_tvb, input_address, 1, NULL,\r\n" byte_copy_left = %u byte_copy_right = %u", byte_copy_left, byte_copy_right);\r\n}\r\nwhile ( n < length ) {\r\nbuff[k] = buff[position];\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_copying_value, message_tvb, input_address, 1,\r\nbuff[position], " Copying value: %5u (0x%x) from Addr: %u to Addr: %u",\r\nbuff[position], buff[position],(position), k);\r\n}\r\nn++;\r\nk = ( k + 1 ) & 0xffff;\r\nposition = ( position + 1 ) & 0xffff;\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\nif ( position == byte_copy_right ) {\r\nposition = byte_copy_left;\r\n}\r\n}\r\nbuff[result_dest] = k >> 8;\r\nbuff[result_dest + 1] = k & 0x00ff;\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_MEMSET:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (address, length, start_value, offset)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_address, bytecode_tvb, offset, (next_operand_address-operand_address), addr,\r\n"Addr: %u Address %u", operand_address, addr);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_length, bytecode_tvb, offset, (next_operand_address-operand_address), length,\r\n"Addr: %u Length %u", operand_address, length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &start_value);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_start_value, bytecode_tvb, offset, (next_operand_address-operand_address), start_value,\r\n"Addr: %u start_value %u", operand_address, start_value);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &multy_offset);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_offset, bytecode_tvb, offset, (next_operand_address-operand_address), multy_offset,\r\n"Addr: %u offset %u", operand_address, multy_offset);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## MEMSET (address=%u, length=%u, start_value=%u, offset=%u)",\r\ncurrent_address, addr, length, start_value, multy_offset);\r\n}\r\ncurrent_address = next_operand_address;\r\nn = 0;\r\nk = addr;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, message_tvb, input_address, 1, NULL,\r\n" byte_copy_left = %u byte_copy_right = %u", byte_copy_left, byte_copy_right);\r\n}\r\nwhile ( n < length ) {\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\nbuff[k] = (start_value + ( n * multy_offset)) & 0xff;\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_storing_value, message_tvb, input_address, 1,\r\nbuff[k], " Storing value: %u (0x%x) at Addr: %u",\r\nbuff[k], buff[k], k);\r\n}\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_JUMP:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (@address)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address,\r\n"Addr: %u @Address %u", operand_address, at_address);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## JUMP (@address=%u)",\r\ncurrent_address, at_address);\r\n}\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_COMPARE:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (value_1, value_2, @address_1, @address_2, @address_3)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value_1);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_value, bytecode_tvb, offset, (next_operand_address-operand_address), value_1,\r\n"Addr: %u Value %u", operand_address, value_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value_2);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_value, bytecode_tvb, offset, (next_operand_address-operand_address), value_2,\r\n"Addr: %u Value %u", operand_address, value_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_1);\r\nat_address_1 = ( current_address + at_address_1) & 0xffff;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address_1,\r\n"Addr: %u @Address %u", operand_address, at_address_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_2);\r\nat_address_2 = ( current_address + at_address_2) & 0xffff;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address_2,\r\n"Addr: %u @Address %u", operand_address, at_address_2);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_3);\r\nat_address_3 = ( current_address + at_address_3) & 0xffff;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address_3,\r\n"Addr: %u @Address %u", operand_address, at_address_3);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## COMPARE (value_1=%u, value_2=%u, @address_1=%u, @address_2=%u, @address_3=%u)",\r\ncurrent_address, value_1, value_2, at_address_1, at_address_2, at_address_3);\r\n}\r\nif ( value_1 < value_2 )\r\ncurrent_address = at_address_1;\r\nif ( value_1 == value_2 )\r\ncurrent_address = at_address_2;\r\nif ( value_1 > value_2 )\r\ncurrent_address = at_address_3;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_CALL:\r\nif (show_instr_detail_level == 2) {\r\nproto_item_append_text(addr_item, " (@address) (PUSH addr )");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address,\r\n"Addr: %u @Address %u", operand_address, at_address);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## CALL (@address=%u)",\r\ncurrent_address, at_address);\r\n}\r\ncurrent_address = next_operand_address;\r\nstack_location = (buff[70] << 8) | buff[71];\r\nstack_fill = (buff[stack_location] << 8)\r\n| buff[(stack_location+1) & 0xFFFF];\r\naddr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;\r\nif (addr >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[addr] = (current_address >> 8) & 0x00FF;\r\nbuff[(addr+1) & 0xFFFF] = current_address & 0x00FF;\r\nstack_fill = (stack_fill + 1) & 0xFFFF;\r\nif (stack_location >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[stack_location] = (stack_fill >> 8) & 0x00FF;\r\nbuff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_RETURN:\r\nstack_location = (buff[70] << 8) | buff[71];\r\nstack_fill = (buff[stack_location] << 8)\r\n| buff[(stack_location+1) & 0xFFFF];\r\nif (stack_fill == 0)\r\n{\r\nresult_code = 16;\r\ngoto decompression_failure;\r\n}\r\nstack_fill = (stack_fill - 1) & 0xFFFF;\r\nif (stack_location >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[stack_location] = (stack_fill >> 8) & 0x00FF;\r\nbuff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;\r\naddr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;\r\nat_address = (buff[addr] << 8)\r\n| buff[(addr+1) & 0xFFFF];\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_SWITCH:\r\ninstruction_address = current_address;\r\nif (show_instr_detail_level == 2) {\r\nproto_item_append_text(addr_item, " (#n, j, @address_0, @address_1, ... , @address_n-1))");\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_literal_num, bytecode_tvb, offset, (next_operand_address-operand_address), n,\r\n"Addr: %u n %u", operand_address, n);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &j);\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_j, bytecode_tvb, offset, (next_operand_address-operand_address), j,\r\n"Addr: %u j %u", operand_address, j);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nm = 0;\r\nwhile ( m < n ) {\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_1);\r\nat_address_1 = ( instruction_address + at_address_1) & 0xffff;\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address_1,\r\n"Addr: %u @Address %u", operand_address, at_address_1);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif ( j == m ) {\r\ncurrent_address = at_address_1;\r\n}\r\noperand_address = next_operand_address;\r\nm++;\r\n}\r\nif ( ( j == n ) || ( j > n )) {\r\nresult_code = 5;\r\ngoto decompression_failure;\r\n}\r\nif ( current_address > UDVM_MEMORY_SIZE ) {\r\nresult_code = 6;\r\ngoto decompression_failure;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + n;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_CRC:\r\nif (show_instr_detail_level == 2) {\r\nproto_item_append_text(addr_item, " (value, position, length, @address)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_value, bytecode_tvb, offset, (next_operand_address-operand_address), value,\r\n"Addr: %u Value %u", operand_address, value);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_position, bytecode_tvb, offset, (next_operand_address-operand_address), position,\r\n"Addr: %u position %u", operand_address, position);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_length, bytecode_tvb, offset, (next_operand_address-operand_address), length,\r\n"Addr: %u Length %u", operand_address, length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address);\r\nat_address = ( current_address + at_address) & 0xffff;\r\nif (print_level_2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address,\r\n"Addr: %u @Address %u", operand_address, at_address);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nused_udvm_cycles = used_udvm_cycles + length;\r\nn = 0;\r\nk = position;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nresult = 0;\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, message_tvb, 0, -1,\r\nNULL, "byte_copy_right = %u", byte_copy_right);\r\n}\r\nwhile (n<length) {\r\nguint16 handle_now = length - n;\r\nif ( k < byte_copy_right && byte_copy_right <= k + (length-n) ) {\r\nhandle_now = byte_copy_right - k;\r\n}\r\nif (k + handle_now >= UDVM_MEMORY_SIZE)\r\ngoto decompression_failure;\r\nresult = crc16_ccitt_seed(&buff[k], handle_now, (guint16) (result ^ 0xffff));\r\nk = ( k + handle_now ) & 0xffff;\r\nn = ( n + handle_now ) & 0xffff;\r\nif ( k >= byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\n}\r\nresult = result ^ 0xffff;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Calculated CRC %u", result);\r\n}\r\nif (result != value) {\r\ncurrent_address = at_address;\r\n}\r\nelse {\r\ncurrent_address = next_operand_address;\r\n}\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_INPUT_BYTES:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " length, destination, @address)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_length, bytecode_tvb, offset, (next_operand_address-operand_address), length,\r\n"Addr: %u Length %u", operand_address, length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_destination, bytecode_tvb, offset, (next_operand_address-operand_address), destination,\r\n"Addr: %u Destination %u", operand_address, destination);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address);\r\nat_address = ( current_address + at_address) & 0xffff;\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address,\r\n"Addr: %u @Address %u", operand_address, at_address);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## INPUT-BYTES length=%u, destination=%u, @address=%u)",\r\ncurrent_address, length, destination, at_address);\r\n}\r\nn = 0;\r\nk = destination;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_1 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, message_tvb, input_address, 1,\r\nNULL, " byte_copy_right = %u", byte_copy_right);\r\n}\r\nremaining_bits = 0;\r\ninput_bits=0;\r\nwhile ( n < length ) {\r\nif (input_address > ( msg_end - 1)) {\r\ncurrent_address = at_address;\r\nresult_code = 14;\r\ngoto execute_next_instruction;\r\n}\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\noctet = tvb_get_guint8(message_tvb, input_address);\r\nbuff[k] = octet;\r\nif (print_level_1 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_loading_value, message_tvb, input_address, 1,\r\noctet, " Loading value: %u (0x%x) at Addr: %u", octet, octet, k);\r\n}\r\ninput_address++;\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_INPUT_BITS:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (length, destination, @address)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_length, bytecode_tvb, offset, (next_operand_address-operand_address), length,\r\n"Addr: %u length %u", operand_address, length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_destination, bytecode_tvb, offset, (next_operand_address-operand_address), destination,\r\n"Addr: %u Destination %u", operand_address, destination);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address,\r\n"Addr: %u @Address %u", operand_address, at_address);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## INPUT-BITS length=%u, destination=%u, @address=%u)",\r\ncurrent_address, length, destination, at_address);\r\n}\r\ncurrent_address = next_operand_address;\r\ninput_bit_order = buff[68] << 8;\r\ninput_bit_order = input_bit_order | buff[69];\r\nif ( length > 16 ) {\r\nresult_code = 7;\r\ngoto decompression_failure;\r\n}\r\nif ( input_bit_order > 7 ) {\r\nresult_code = 8;\r\ngoto decompression_failure;\r\n}\r\nbit_order = ( input_bit_order & 0x0004 ) >> 2;\r\nvalue = decomp_dispatch_get_bits( message_tvb, udvm_tree, bit_order,\r\nbuff, &old_input_bit_order, &remaining_bits,\r\n&input_bits, &input_address, length, &result_code, msg_end, print_level_1);\r\nif ( result_code == 11 ) {\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\n}\r\nmsb = value >> 8;\r\nlsb = value & 0x00ff;\r\nif (destination >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[destination] = msb;\r\nbuff[(destination + 1) & 0xffff]=lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_loading_result, message_tvb, input_address, 1,\r\n" Loading value: %u (0x%x) at Addr: %u, remaining_bits: %u", value, value, destination, remaining_bits);\r\n}\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_INPUT_HUFFMAN:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (destination, @address, #n, bits_1, lower_bound_1,upper_bound_1, uncompressed_1, ... , bits_n, lower_bound_n,upper_bound_n, uncompressed_n)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_destination, bytecode_tvb, offset, (next_operand_address-operand_address), destination,\r\n"Addr: %u Destination %u", operand_address, destination);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_at_address, bytecode_tvb, offset, (next_operand_address-operand_address), at_address,\r\n"Addr: %u @Address %u", operand_address, at_address);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_literal_num, bytecode_tvb, offset, (next_operand_address-operand_address), n,\r\n"Addr: %u n %u", operand_address, n);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## INPUT-HUFFMAN (destination=%u, @address=%u, #n=%u, bits_1, lower_1,upper_1, unc_1, ... , bits_%d, lower_%d,upper_%d, unc_%d)",\r\ncurrent_address, destination, at_address, n, n, n, n, n);\r\n}\r\nused_udvm_cycles = used_udvm_cycles + n;\r\ninput_bit_order = buff[68] << 8;\r\ninput_bit_order = input_bit_order | buff[69];\r\nbit_order = ( input_bit_order & 0x0002 ) >> 1;\r\nj = 1;\r\nH = 0;\r\nm = n;\r\noutside_huffman_boundaries = TRUE;\r\nprint_in_loop = print_level_3;\r\nwhile ( m > 0 ) {\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &bits_n);\r\nif (print_in_loop ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_bits, bytecode_tvb, offset, (next_operand_address-operand_address), bits_n,\r\n"Addr: %u bits_n %u", operand_address, bits_n);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &lower_bound_n);\r\nif (print_in_loop ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_lower_bound, bytecode_tvb, offset, (next_operand_address-operand_address), lower_bound_n,\r\n"Addr: %u lower_bound_n %u", operand_address, lower_bound_n);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &upper_bound_n);\r\nif (print_in_loop ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_upper_bound, bytecode_tvb, offset, (next_operand_address-operand_address), upper_bound_n,\r\n"Addr: %u upper_bound_n %u", operand_address, upper_bound_n);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &uncompressed_n);\r\nif (print_in_loop ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_uncompressed, bytecode_tvb, offset, (next_operand_address-operand_address), uncompressed_n,\r\n"Addr: %u uncompressed_n %u", operand_address, uncompressed_n);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nif ( outside_huffman_boundaries ) {\r\nk = decomp_dispatch_get_bits( message_tvb, udvm_tree, bit_order,\r\nbuff, &old_input_bit_order, &remaining_bits,\r\n&input_bits, &input_address, bits_n, &result_code, msg_end, print_level_1);\r\nif ( result_code == 11 ) {\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\n}\r\noldH = H;\r\nH = (H << bits_n) | k;\r\nif (print_level_3 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_set_hu, bytecode_tvb, 0, -1, NULL,\r\n" Set H(%u) := H(%u) * 2^bits_j(%u) + k(%u)",\r\nH ,oldH, 1<<bits_n,k);\r\n}\r\nif ((H < lower_bound_n) || (H > upper_bound_n)) {\r\noutside_huffman_boundaries = TRUE;\r\n} else {\r\noutside_huffman_boundaries = FALSE;\r\nprint_in_loop = FALSE;\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_set_hu, bytecode_tvb, 0, -1, NULL,\r\n" H(%u) = H(%u) + uncompressed_n(%u) - lower_bound_n(%u)",\r\n(H + uncompressed_n - lower_bound_n ),H, uncompressed_n, lower_bound_n);\r\n}\r\nH = H + uncompressed_n - lower_bound_n;\r\nmsb = H >> 8;\r\nlsb = H & 0x00ff;\r\nif (destination >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[destination] = msb;\r\nbuff[(destination + 1) & 0xffff]=lsb;\r\nif (print_level_1 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_loading_h, message_tvb, input_address, 1, H,\r\n" Loading H: %u (0x%x) at Addr: %u,j = %u remaining_bits: %u",\r\nH, H, destination,( n - m + 1 ), remaining_bits);\r\n}\r\n}\r\n}\r\nm = m - 1;\r\n}\r\nif ( outside_huffman_boundaries ) {\r\nresult_code = 10;\r\ngoto decompression_failure;\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_STATE_ACCESS:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (partial_identifier_start, partial_identifier_length,state_begin, state_length, state_address, state_instruction)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_start);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_partial_identifier_start, bytecode_tvb, offset, (next_operand_address-operand_address), p_id_start,\r\n"Addr: %u partial_identifier_start %u", operand_address, p_id_start);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_partial_identifier_length, bytecode_tvb, offset, (next_operand_address-operand_address), p_id_length,\r\n"Addr: %u partial_identifier_length %u", operand_address, p_id_length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_begin);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_state_begin, bytecode_tvb, offset, (next_operand_address-operand_address), state_begin,\r\n"Addr: %u state_begin %u", operand_address, state_begin);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_length, bytecode_tvb, offset, (next_operand_address-operand_address), state_length,\r\n"Addr: %u state_length %u", operand_address, state_length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_address, bytecode_tvb, offset, (next_operand_address-operand_address), state_address,\r\n"Addr: %u state_address %u", operand_address, state_address);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_instr, bytecode_tvb, offset, (next_operand_address-operand_address), state_instruction,\r\n"Addr: %u state_instruction %u", operand_address, state_instruction);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## STATE-ACCESS(31) (partial_identifier_start=%u, partial_identifier_length=%u,state_begin=%u, state_length=%u, state_address=%u, state_instruction=%u)",\r\ncurrent_address, p_id_start, p_id_length, state_begin, state_length, state_address, state_instruction);\r\n}\r\ncurrent_address = next_operand_address;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, message_tvb, input_address, 1, NULL,\r\n" byte_copy_right = %u, byte_copy_left = %u", byte_copy_right,byte_copy_left);\r\n}\r\nresult_code = udvm_state_access(message_tvb, udvm_tree, buff, p_id_start, p_id_length, state_begin, &state_length,\r\n&state_address, &state_instruction, hf_id);\r\nif ( result_code != 0 ) {\r\ngoto decompression_failure;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + state_length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_STATE_CREATE:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (state_length, state_address, state_instruction,minimum_access_length, state_retention_priority)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_length, bytecode_tvb, offset, (next_operand_address-operand_address), state_length,\r\n"Addr: %u state_length %u", operand_address, state_length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_address, bytecode_tvb, offset, (next_operand_address-operand_address), state_address,\r\n"Addr: %u state_address %u", operand_address, state_address);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_instr, bytecode_tvb, offset, (next_operand_address-operand_address), state_instruction,\r\n"Addr: %u state_instruction %u", operand_address, state_instruction);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &minimum_access_length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_min_acc_len, bytecode_tvb, offset, (next_operand_address-operand_address), minimum_access_length,\r\n"Addr: %u minimum_access_length %u", operand_address, minimum_access_length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_retention_priority);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_ret_pri, bytecode_tvb, offset, (next_operand_address-operand_address), state_retention_priority,\r\n"Addr: %u state_retention_priority %u", operand_address, state_retention_priority);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## STATE-CREATE(32) (state_length=%u, state_address=%u, state_instruction=%u,minimum_access_length=%u, state_retention_priority=%u)",\r\ncurrent_address, state_length, state_address, state_instruction,minimum_access_length, state_retention_priority);\r\n}\r\ncurrent_address = next_operand_address;\r\nno_of_state_create++;\r\nif ( no_of_state_create > 4 ) {\r\nresult_code = 12;\r\ngoto decompression_failure;\r\n}\r\nif (( minimum_access_length < 6 ) || ( minimum_access_length > STATE_BUFFER_SIZE )) {\r\nresult_code = 1;\r\ngoto decompression_failure;\r\n}\r\nif ( state_retention_priority == 65535 ) {\r\nresult_code = 13;\r\ngoto decompression_failure;\r\n}\r\nstate_length_buff[no_of_state_create] = state_length;\r\nstate_address_buff[no_of_state_create] = state_address;\r\nstate_instruction_buff[no_of_state_create] = state_instruction;\r\nstate_minimum_access_length_buff[no_of_state_create] = minimum_access_length;\r\nused_udvm_cycles = used_udvm_cycles + state_length;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nn = 0;\r\nk = state_address;\r\nwhile ( n < state_length ) {\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\nstring[0]= buff[k];\r\nstring[1]= '\0';\r\nif (print_level_3 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_state_value, bytecode_tvb, 0, 0, buff[k],\r\n" Addr: %5u State value: %u (0x%x) ASCII(%s)",\r\nk,buff[k],buff[k],format_text(string, 1));\r\n}\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\n}\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_STATE_FREE:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (partial_identifier_start, partial_identifier_length)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_start);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_partial_identifier_start, bytecode_tvb, offset, (next_operand_address-operand_address), p_id_start,\r\n"Addr: %u partial_identifier_start %u", operand_address, p_id_start);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_partial_identifier_length, bytecode_tvb, offset, (next_operand_address-operand_address), p_id_length,\r\n"Addr: %u partial_identifier_length %u", operand_address, p_id_length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## STATE-FREE (partial_identifier_start=%u, partial_identifier_length=%u)",\r\ncurrent_address, p_id_start, p_id_length);\r\n}\r\ncurrent_address = next_operand_address;\r\nudvm_state_free(buff,p_id_start,p_id_length);\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_OUTPUT:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (output_start, output_length)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &output_start);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_output_start, bytecode_tvb, offset, (next_operand_address-operand_address), output_start,\r\n"Addr: %u output_start %u", operand_address, output_start);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &output_length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_output_length, bytecode_tvb, offset, (next_operand_address-operand_address), output_length,\r\n"Addr: %u output_length %u", operand_address, output_length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## OUTPUT (output_start=%u, output_length=%u)",\r\ncurrent_address, output_start, output_length);\r\n}\r\ncurrent_address = next_operand_address;\r\nn = 0;\r\nk = output_start;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_3 ) {\r\nproto_tree_add_bytes_format(udvm_tree, hf_sigcomp_byte_copy, bytecode_tvb, 0, -1,\r\nNULL, " byte_copy_right = %u", byte_copy_right);\r\n}\r\nwhile ( n < output_length ) {\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\nout_buff[output_address] = buff[k];\r\nstring[0]= buff[k];\r\nstring[1]= '\0';\r\nif (print_level_3 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_sigcomp_output_value, bytecode_tvb, 0, -1, buff[k],\r\n" Output value: %u (0x%x) ASCII(%s) from Addr: %u ,output to dispatcher position %u",\r\nbuff[k],buff[k],format_text(string,1), k,output_address);\r\n}\r\nk = ( k + 1 ) & 0xffff;\r\noutput_address ++;\r\nn++;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + output_length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_END_MESSAGE:\r\nif (show_instr_detail_level == 2 ) {\r\nproto_item_append_text(addr_item, " (requested_feedback_location,state_instruction, minimum_access_length,state_retention_priority)");\r\n}\r\nstart_offset = offset;\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &requested_feedback_location);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_req_feedback_loc, bytecode_tvb, offset, (next_operand_address-operand_address), requested_feedback_location,\r\n"Addr: %u requested_feedback_location %u",\r\noperand_address, requested_feedback_location);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &returned_parameters_location);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_ret_param_loc, bytecode_tvb, offset, (next_operand_address-operand_address), returned_parameters_location,\r\n"Addr: %u returned_parameters_location %u", operand_address, returned_parameters_location);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_length, bytecode_tvb, offset, (next_operand_address-operand_address), state_length,\r\n"Addr: %u state_length %u", operand_address, state_length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_address, bytecode_tvb, offset, (next_operand_address-operand_address), state_address,\r\n"Addr: %u state_address %u", operand_address, state_address);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_instr, bytecode_tvb, offset, (next_operand_address-operand_address), state_instruction,\r\n"Addr: %u state_instruction %u", operand_address, state_instruction);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &minimum_access_length);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_min_acc_len, bytecode_tvb, offset, (next_operand_address-operand_address), minimum_access_length,\r\n"Addr: %u minimum_access_length %u", operand_address, minimum_access_length);\r\n}\r\noffset += (next_operand_address-operand_address);\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_retention_priority);\r\nif (show_instr_detail_level == 2 ) {\r\nproto_tree_add_uint_format(udvm_tree, hf_udvm_state_ret_pri, bytecode_tvb, offset, (next_operand_address-operand_address), state_retention_priority,\r\n"Addr: %u state_retention_priority %u", operand_address, state_retention_priority);\r\n}\r\noffset += (next_operand_address-operand_address);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_none_format(udvm_tree, hf_sigcomp_decompress_instruction, bytecode_tvb, start_offset, offset-start_offset,\r\n"Addr: %u ## END-MESSAGE (requested_feedback_location=%u, returned_parameters_location=%u, state_length=%u, state_address=%u, state_instruction=%u, minimum_access_length=%u, state_retention_priority=%u)",\r\ncurrent_address, requested_feedback_location, returned_parameters_location, state_length, state_address, state_instruction, minimum_access_length,state_retention_priority);\r\n}\r\nno_of_state_create++;\r\nif ( no_of_state_create > 4 ) {\r\nresult_code = 12;\r\ngoto decompression_failure;\r\n}\r\nstate_length_buff[no_of_state_create] = state_length;\r\nstate_address_buff[no_of_state_create] = state_address;\r\nstate_instruction_buff[no_of_state_create] = state_instruction;\r\nstate_minimum_access_length_buff[no_of_state_create] = minimum_access_length;\r\nproto_tree_add_uint(udvm_tree, hf_sigcomp_num_state_create, bytecode_tvb, 0, 0, no_of_state_create);\r\nif ( no_of_state_create != 0 ) {\r\nmemset(sha1_digest_buf, 0, STATE_BUFFER_SIZE);\r\nn = 1;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nwhile ( n < no_of_state_create + 1 ) {\r\nsha1buff = (guint8 *)g_malloc(state_length_buff[n]+8);\r\nsha1buff[0] = state_length_buff[n] >> 8;\r\nsha1buff[1] = state_length_buff[n] & 0xff;\r\nsha1buff[2] = state_address_buff[n] >> 8;\r\nsha1buff[3] = state_address_buff[n] & 0xff;\r\nsha1buff[4] = state_instruction_buff[n] >> 8;\r\nsha1buff[5] = state_instruction_buff[n] & 0xff;\r\nsha1buff[6] = state_minimum_access_length_buff[n] >> 8;\r\nsha1buff[7] = state_minimum_access_length_buff[n] & 0xff;\r\nif (print_level_3 ) {\r\nproto_tree_add_bytes_with_length(udvm_tree, hf_sigcomp_sha1buff, bytecode_tvb, 0, -1, sha1buff, 8);\r\n}\r\nk = state_address_buff[n];\r\nfor ( x=0; x < state_length_buff[n]; x++)\r\n{\r\nif ( k == byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\nsha1buff[8+x] = buff[k];\r\nk = ( k + 1 ) & 0xffff;\r\n}\r\nsha1_starts( &ctx );\r\nsha1_update( &ctx, (guint8 *) sha1buff, state_length_buff[n] + 8);\r\nsha1_finish( &ctx, sha1_digest_buf );\r\nif (print_level_3 ) {\r\nproto_tree_add_bytes_with_length(udvm_tree, hf_sigcomp_sha1_digest, bytecode_tvb, 0, -1, sha1_digest_buf, STATE_BUFFER_SIZE);\r\n}\r\n#if 0\r\nudvm_state_create(sha1buff, sha1_digest_buf, state_minimum_access_length_buff[n]);\r\n#endif\r\nudvm_state_create(sha1buff, sha1_digest_buf, STATE_MIN_ACCESS_LEN);\r\nproto_tree_add_item(udvm_tree, hf_sigcomp_creating_state, bytecode_tvb, 0, -1, ENC_NA);\r\nproto_tree_add_string(udvm_tree,hf_id, bytecode_tvb, 0, 0, bytes_to_str(wmem_packet_scope(), sha1_digest_buf, STATE_MIN_ACCESS_LEN));\r\nn++;\r\n}\r\n}\r\ndecomp_tvb = tvb_new_child_real_data(message_tvb, out_buff,output_address,output_address);\r\ntvb_set_free_cb( decomp_tvb, g_free );\r\nadd_new_data_source(pinfo, decomp_tvb, "Decompressed SigComp message");\r\nproto_tree_add_item(udvm_tree, hf_sigcomp_sigcomp_message_decompressed, decomp_tvb, 0, -1, ENC_NA);\r\nused_udvm_cycles += state_length;\r\nproto_tree_add_uint(udvm_tree, hf_sigcomp_max_udvm_cycles, bytecode_tvb, 0, 0, maximum_UDVM_cycles);\r\nproto_tree_add_uint(udvm_tree, hf_sigcomp_used_udvm_cycles, bytecode_tvb, 0, 0, used_udvm_cycles);\r\nreturn decomp_tvb;\r\nbreak;\r\ndefault:\r\nexpert_add_info_format(pinfo, addr_item, &ei_sigcomp_invalid_instruction,\r\n"Addr %u Invalid instruction: %u (0x%x)", current_address,current_instruction,current_instruction);\r\nbreak;\r\n}\r\ng_free(out_buff);\r\nreturn NULL;\r\ndecompression_failure:\r\nproto_tree_add_expert_format(udvm_tree, pinfo, &ei_sigcomp_decompression_failure, bytecode_tvb, 0, -1,\r\n"DECOMPRESSION FAILURE: %s", val_to_str(result_code, result_code_vals,"Unknown (%u)"));\r\ng_free(out_buff);\r\nreturn NULL;\r\n}\r\nstatic int\r\ndissect_sigcomp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *_data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *sigcomp_tree;\r\ntvbuff_t *unescaped_tvb;\r\nguint8 *buff;\r\nint offset = 0;\r\nint length;\r\nguint8 octet;\r\nguint16 data;\r\nint i;\r\nint n;\r\ngboolean end_off_message;\r\ntop_tree = tree;\r\ndata = tvb_get_ntohs(tvb, offset);\r\nif (data == 0xffff) {\r\noffset = offset + 2;\r\noctet = tvb_get_guint8(tvb,offset);\r\n} else {\r\noctet = tvb_get_guint8(tvb,offset);\r\n}\r\nif ((octet & 0xf8) != 0xf8)\r\nreturn offset;\r\nlength = tvb_reported_length_remaining(tvb, offset);\r\nfor (i=0; i<(length-1); ++i) {\r\ndata = tvb_get_ntohs(tvb, offset+i);\r\nif (0xffff == data) break;\r\n}\r\nif (i >= (length-1)) {\r\nif (pinfo->can_desegment || pinfo->saved_can_desegment) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len=DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn -1;\r\n}\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "SIGCOMP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nlength = tvb_captured_length_remaining(tvb,offset);\r\ntry_again:\r\nti = proto_tree_add_item(tree, proto_sigcomp, tvb, 0, -1, ENC_NA);\r\nsigcomp_tree = proto_item_add_subtree(ti, ett_sigcomp);\r\ni=0;\r\nend_off_message = FALSE;\r\nbuff = (guint8 *)wmem_alloc(pinfo->pool, length-offset);\r\nif (udvm_print_detail_level>2)\r\nproto_tree_add_item(sigcomp_tree, hf_sigcomp_starting_to_remove_escape_digits, tvb, offset, -1, ENC_NA);\r\nwhile ((offset < length) && (end_off_message == FALSE)) {\r\noctet = tvb_get_guint8(tvb,offset);\r\nif ( octet == 0xff ) {\r\nif ( offset +1 >= length ) {\r\noffset++;\r\ncontinue;\r\n}\r\nif (udvm_print_detail_level>2)\r\nproto_tree_add_none_format(sigcomp_tree, hf_sigcomp_escape_digit_found, tvb, offset, 2,\r\n" Escape digit found (0xFF)");\r\noctet = tvb_get_guint8(tvb, offset+1);\r\nif ( octet == 0) {\r\nbuff[i] = 0xff;\r\noffset = offset +2;\r\ni++;\r\ncontinue;\r\n}\r\nif ((octet > 0x7f) && (octet < 0xff )) {\r\nif (udvm_print_detail_level>2)\r\nproto_tree_add_none_format(sigcomp_tree, hf_sigcomp_illegal_escape_code, tvb, offset, 2,\r\n" Illegal escape code");\r\noffset += tvb_captured_length_remaining(tvb,offset);\r\nreturn offset;\r\n}\r\nif ( octet == 0xff) {\r\nif (udvm_print_detail_level>2)\r\nproto_tree_add_none_format(sigcomp_tree, hf_sigcomp_end_of_sigcomp_message_indication_found, tvb, offset, 2,\r\n" End of SigComp message indication found (0xFFFF)");\r\nend_off_message = TRUE;\r\noffset = offset+2;\r\ncontinue;\r\n}\r\nbuff[i] = 0xff;\r\nif (udvm_print_detail_level>2)\r\nproto_tree_add_uint_format(sigcomp_tree, hf_sigcomp_addr_value, tvb, offset, 1, buff[i],\r\n" Addr: %u tvb value(0x%0x) ", i, buff[i]);\r\ni++;\r\noffset = offset+2;\r\nif (udvm_print_detail_level>2)\r\nproto_tree_add_bytes_format(sigcomp_tree, hf_sigcomp_copying_bytes_literally, tvb, offset, octet,\r\nNULL, " Copying %u bytes literally",octet);\r\nif ( offset+octet >= length)\r\noctet = length - offset;\r\nfor ( n=0; n < octet; n++ ) {\r\nbuff[i] = tvb_get_guint8(tvb, offset);\r\nif (udvm_print_detail_level>2)\r\nproto_tree_add_uint_format(sigcomp_tree, hf_sigcomp_addr_value, tvb, offset, 1, buff[i],\r\n" Addr: %u tvb value(0x%0x) ", i, buff[i]);\r\ni++;\r\noffset++;\r\n}\r\ncontinue;\r\n}\r\nbuff[i] = octet;\r\nif (udvm_print_detail_level>2)\r\nproto_tree_add_uint_format(sigcomp_tree, hf_sigcomp_addr_value, tvb, offset, 1, buff[i],\r\n" Addr: %u tvb value(0x%0x) ", i, buff[i]);\r\ni++;\r\noffset++;\r\n}\r\nunescaped_tvb = tvb_new_child_real_data(tvb, buff,i,i);\r\nadd_new_data_source(pinfo, unescaped_tvb, "Unescaped Data handed to the SigComp dissector");\r\nproto_tree_add_item(sigcomp_tree, hf_sigcomp_data_for_sigcomp_dissector, unescaped_tvb, 0, -1, ENC_NA);\r\nif (end_off_message == TRUE) {\r\ndissect_sigcomp_common(unescaped_tvb, pinfo, sigcomp_tree);\r\n} else {\r\nproto_tree_add_expert(sigcomp_tree, pinfo, &ei_sigcomp_tcp_fragment, unescaped_tvb, 0, -1);\r\n}\r\nif ( offset < length) {\r\ngoto try_again;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_sigcomp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *sigcomp_tree;\r\ngint offset = 0;\r\ngint8 octet;\r\nif ( pinfo->ptype == PT_TCP )\r\nreturn dissect_sigcomp_tcp(tvb, pinfo, tree, NULL);\r\noctet = tvb_get_guint8(tvb, offset);\r\nif ((octet & 0xf8) != 0xf8)\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "SIGCOMP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ntop_tree = tree;\r\nti = proto_tree_add_item(tree, proto_sigcomp, tvb, 0, -1, ENC_NA);\r\nsigcomp_tree = proto_item_add_subtree(ti, ett_sigcomp);\r\nreturn dissect_sigcomp_common(tvb, pinfo, sigcomp_tree);\r\n}\r\nstatic int\r\ndissect_sigcomp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sigcomp_tree)\r\n{\r\ntvbuff_t *udvm_tvb, *msg_tvb, *udvm2_tvb;\r\ntvbuff_t *decomp_tvb = NULL;\r\nproto_item *udvm_bytecode_item, *udvm_exe_item;\r\nproto_tree *sigcomp_udvm_tree, *sigcomp_udvm_exe_tree;\r\ngint offset = 0;\r\ngint bytecode_offset;\r\nguint16 partial_state_len;\r\nguint octet;\r\nguint8 returned_feedback_field[128];\r\nguint8 partial_state[12];\r\nguint tbit;\r\nguint16 len = 0;\r\nguint16 bytecode_len = 0;\r\nguint destination;\r\ngint msg_len = 0;\r\nguint8 *buff;\r\nguint16 p_id_start;\r\nguint8 i;\r\nguint16 state_begin;\r\nguint16 state_length;\r\nguint16 state_address;\r\nguint16 state_instruction;\r\nguint16 result_code;\r\ngchar *partial_state_str;\r\nguint8 nack_version;\r\noctet = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_t_bit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\ntbit = ( octet & 0x04)>>2;\r\npartial_state_len = octet & 0x03;\r\noffset ++;\r\nif ( partial_state_len != 0 ) {\r\npartial_state_len = partial_state_len * 3 + 3;\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Msg format 1");\r\nif ( tbit == 1 ) {\r\nlen = 1;\r\noctet = tvb_get_guint8(tvb, offset);\r\nif ( (octet & 0x80) != 0 ) {\r\nlen = octet & 0x7f;\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_returned_feedback_item_len,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\ntvb_memcpy(tvb,returned_feedback_field,offset, len);\r\n} else {\r\nreturned_feedback_field[0] = tvb_get_guint8(tvb, offset) & 0x7f;\r\n}\r\nproto_tree_add_bytes(sigcomp_tree,hf_sigcomp_returned_feedback_item,\r\ntvb, offset, len, returned_feedback_field);\r\noffset = offset + len;\r\n}\r\ntvb_memcpy(tvb, partial_state, offset, partial_state_len);\r\npartial_state_str = bytes_to_str(wmem_packet_scope(), partial_state, partial_state_len);\r\nproto_tree_add_string(sigcomp_tree,hf_sigcomp_partial_state,\r\ntvb, offset, partial_state_len, partial_state_str);\r\noffset = offset + partial_state_len;\r\nmsg_len = tvb_reported_length_remaining(tvb, offset);\r\nif (msg_len>0) {\r\nproto_item *ti;\r\nti = proto_tree_add_uint(sigcomp_tree, hf_sigcomp_remaining_message_bytes, tvb,\r\noffset, 0, msg_len);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\nif ( decompress ) {\r\nmsg_tvb = tvb_new_subset_length(tvb, offset, msg_len);\r\nbuff = (guint8 *)wmem_alloc0(pinfo->pool, UDVM_MEMORY_SIZE);\r\np_id_start = 0;\r\nstate_begin = 0;\r\nstate_length = 0;\r\nstate_address = 0;\r\nstate_instruction =0;\r\ni = 0;\r\nwhile ( i < partial_state_len ) {\r\nbuff[i] = partial_state[i];\r\ni++;\r\n}\r\n#if 0\r\nresult_code = udvm_state_access(tvb, sigcomp_tree, buff, p_id_start, partial_state_len, state_begin, &state_length,\r\n&state_address, &state_instruction, hf_sigcomp_partial_state);\r\n#endif\r\nresult_code = udvm_state_access(tvb, sigcomp_tree, buff, p_id_start, STATE_MIN_ACCESS_LEN, state_begin, &state_length,\r\n&state_address, &state_instruction, hf_sigcomp_partial_state);\r\nif ( result_code != 0 ) {\r\nproto_tree_add_expert_format(sigcomp_tree, pinfo, &ei_sigcomp_failed_to_access_state_wireshark_udvm_diagnostic, tvb, 0, -1,\r\n"Failed to Access state Wireshark UDVM diagnostic: %s", val_to_str(result_code, result_code_vals,"Unknown (%u)"));\r\nreturn tvb_captured_length(tvb);\r\n}\r\nudvm_tvb = tvb_new_child_real_data(tvb, buff,state_length+state_address,state_length+state_address);\r\nadd_new_data_source(pinfo, udvm_tvb, "State/ExecutionTrace");\r\nudvm2_tvb = tvb_new_subset_length(udvm_tvb, state_address, state_length);\r\nudvm_exe_item = proto_tree_add_item(sigcomp_tree, hf_udvm_execution_trace,\r\nudvm2_tvb, 0, state_length,\r\nENC_NA);\r\nsigcomp_udvm_exe_tree = proto_item_add_subtree( udvm_exe_item, ett_sigcomp_udvm_exe);\r\ndecomp_tvb = decompress_sigcomp_message(udvm2_tvb, msg_tvb, pinfo,\r\nsigcomp_udvm_exe_tree, state_address,\r\nudvm_print_detail_level, hf_sigcomp_partial_state,\r\noffset, state_length, partial_state_len, state_instruction);\r\nif ( decomp_tvb ) {\r\nproto_item *ti;\r\nguint32 compression_ratio =\r\n(guint32)(((float)tvb_reported_length(decomp_tvb) / (float)tvb_reported_length(tvb)) * 100);\r\nti = proto_tree_add_uint(sigcomp_tree, hf_sigcomp_compression_ratio, decomp_tvb,\r\n0, 0, compression_ratio);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nif ( display_raw_txt )\r\ntvb_raw_text_add(decomp_tvb, top_tree);\r\ncol_append_str(pinfo->cinfo, COL_PROTOCOL, "/");\r\ncol_set_fence(pinfo->cinfo,COL_PROTOCOL);\r\ncall_dissector(sip_handle, decomp_tvb, pinfo, top_tree);\r\n}\r\n}\r\n}\r\nelse{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Msg format 2");\r\nif ( tbit == 1 ) {\r\nlen = 1;\r\noctet = tvb_get_guint8(tvb, offset);\r\nif ( (octet & 0x80) != 0 ) {\r\nlen = octet & 0x7f;\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_returned_feedback_item_len,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\n}\r\ntvb_memcpy(tvb,returned_feedback_field,offset, len);\r\nproto_tree_add_bytes(sigcomp_tree,hf_sigcomp_returned_feedback_item,\r\ntvb, offset, len, returned_feedback_field);\r\noffset = offset + len;\r\n}\r\nlen = tvb_get_ntohs(tvb, offset) >> 4;\r\nnack_version = tvb_get_guint8(tvb, offset+1) & 0x0f;\r\nif ((len == 0) && (nack_version == 1)) {\r\nproto_item *reason_ti;\r\nguint8 opcode;\r\noffset++;\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_nack_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\noctet = tvb_get_guint8(tvb, offset);\r\nreason_ti = proto_tree_add_item(sigcomp_tree,hf_sigcomp_nack_reason_code, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nopcode = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_nack_failed_op_code, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nexpert_add_info_format(pinfo, reason_ti, &ei_sigcomp_nack_failed_op_code,\r\n"SigComp NACK (reason=%s, opcode=%s)",\r\nval_to_str_ext_const(octet, &sigcomp_nack_reason_code_vals_ext, "Unknown"),\r\nval_to_str_ext_const(opcode, &udvm_instruction_code_vals_ext, "Unknown"));\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_nack_pc, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset = offset +2;\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_nack_sha1, tvb, offset, SHA1_DIGEST_LEN, ENC_NA);\r\noffset = offset +SHA1_DIGEST_LEN;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " NACK reason=%s, opcode=%s",\r\nval_to_str_ext_const(octet, &sigcomp_nack_reason_code_vals_ext, "Unknown"),\r\nval_to_str_ext_const(opcode, &udvm_instruction_code_vals_ext, "Unknown"));\r\nswitch ( octet) {\r\ncase SIGCOMP_NACK_STATE_NOT_FOUND:\r\ncase SIGCOMP_NACK_ID_NOT_UNIQUE:\r\ncase SIGCOMP_NACK_STATE_TOO_SHORT:\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_nack_state_id, tvb, offset, -1, ENC_NA);\r\nbreak;\r\ncase SIGCOMP_NACK_CYCLES_EXHAUSTED:\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_nack_cycles_per_bit, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SIGCOMP_NACK_BYTECODES_TOO_LARGE:\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_nack_memory_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\noctet = tvb_get_guint8(tvb, (offset + 1));\r\ndestination = (octet & 0x0f);\r\nif ( destination != 0 )\r\ndestination = 64 + ( destination * 64 );\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_code_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(sigcomp_tree,hf_sigcomp_destination, tvb, (offset+ 1), 1, ENC_BIG_ENDIAN);\r\noffset = offset +2;\r\nbytecode_len = len;\r\nbytecode_offset = offset;\r\nudvm_bytecode_item = proto_tree_add_item(sigcomp_tree, hf_sigcomp_udvm_bytecode, tvb,\r\nbytecode_offset, bytecode_len, ENC_NA);\r\nproto_item_append_text(udvm_bytecode_item,\r\n" %u (0x%x) bytes", bytecode_len, bytecode_len);\r\nsigcomp_udvm_tree = proto_item_add_subtree( udvm_bytecode_item, ett_sigcomp_udvm);\r\nudvm_tvb = tvb_new_subset_length(tvb, offset, len);\r\nif ( dissect_udvm_code )\r\ndissect_udvm_bytecode(udvm_tvb, pinfo, sigcomp_udvm_tree, destination);\r\noffset = offset + len;\r\nmsg_len = tvb_reported_length_remaining(tvb, offset);\r\nif (msg_len>0) {\r\nproto_item *ti = proto_tree_add_item(sigcomp_tree, hf_sigcomp_remaining_sigcomp_message, tvb, offset, -1, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\n}\r\nif ( decompress ) {\r\nmsg_tvb = tvb_new_subset_length(tvb, offset, msg_len);\r\nudvm_exe_item = proto_tree_add_item(sigcomp_tree, hf_udvm_execution_trace,\r\ntvb, bytecode_offset, bytecode_len,\r\nENC_NA);\r\nsigcomp_udvm_exe_tree = proto_item_add_subtree( udvm_exe_item, ett_sigcomp_udvm_exe);\r\ndecomp_tvb = decompress_sigcomp_message(udvm_tvb, msg_tvb, pinfo,\r\nsigcomp_udvm_exe_tree, destination,\r\nudvm_print_detail_level, hf_sigcomp_partial_state,\r\noffset, 0, 0, destination);\r\nif ( decomp_tvb ) {\r\nproto_item *ti;\r\nguint32 compression_ratio =\r\n(guint32)(((float)tvb_reported_length(decomp_tvb) / (float)tvb_reported_length(tvb)) * 100);\r\nti = proto_tree_add_uint(sigcomp_tree, hf_sigcomp_compression_ratio, decomp_tvb,\r\n0, 0, compression_ratio);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nif ( display_raw_txt )\r\ntvb_raw_text_add(decomp_tvb, top_tree);\r\ncol_append_str(pinfo->cinfo, COL_PROTOCOL, "/");\r\ncol_set_fence(pinfo->cinfo,COL_PROTOCOL);\r\ncall_dissector(sip_handle, decomp_tvb, pinfo, top_tree);\r\n}\r\n}\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_udvm_bytecode(tvbuff_t *udvm_tvb, packet_info* pinfo, proto_tree *sigcomp_udvm_tree,guint start_address)\r\n{\r\nguint instruction;\r\ngint offset = 0;\r\ngint start_offset = 0;\r\ngint len;\r\ngint n;\r\nguint instruction_no = 0;\r\nguint16 value = 0;\r\nproto_item *item, *item2;\r\nguint UDVM_address = start_address;\r\ngboolean is_memory_address;\r\nguint16 msg_length = tvb_reported_length_remaining(udvm_tvb, offset);\r\nwhile (msg_length > offset) {\r\ninstruction = tvb_get_guint8(udvm_tvb, offset);\r\ninstruction_no ++;\r\nUDVM_address = start_address + offset;\r\nitem = proto_tree_add_uint_format(sigcomp_udvm_tree, hf_sigcomp_udvm_instruction, udvm_tvb, offset, 1,\r\ninstruction_no, "######### UDVM instruction %u at UDVM-address %u (0x%x) #########",\r\ninstruction_no,UDVM_address,UDVM_address);\r\nPROTO_ITEM_SET_GENERATED(item);\r\nproto_tree_add_item(sigcomp_udvm_tree, hf_sigcomp_udvm_instr, udvm_tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset ++;\r\nswitch ( instruction ) {\r\ncase SIGCOMP_INSTR_AND:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_OR:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_NOT:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_LSHIFT:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_RSHIFT:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_ADD:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_SUBTRACT:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_MULTIPLY:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_DIVIDE:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_REMAINDER:\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_1,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_operand_2,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_SORT_ASCENDING:\r\noffset = offset + tvb_reported_length_remaining(udvm_tvb, offset);\r\nbreak;\r\ncase SIGCOMP_INSTR_SORT_DESCENDING:\r\noffset = offset + tvb_reported_length_remaining(udvm_tvb, offset);\r\nbreak;\r\ncase SIGCOMP_INSTR_SHA_1:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_position,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_ref_dest,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_LOAD:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_address,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_MULTILOAD:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_address,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_literal_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_num,\r\nudvm_tvb, start_offset, len, value);\r\nn = value;\r\nwhile ( n > 0) {\r\nn = n -1;\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_PUSH:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_POP:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_address,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_COPY:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_position,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_ref_dest,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_COPY_LITERAL:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_position,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_ref_dest,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_COPY_OFFSET:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_offset,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_offset,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_reference_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_ref_dest,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_MEMSET:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_address,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_start_value,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_offset,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_JUMP:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_COMPARE:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_CALL:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_RETURN:\r\nbreak;\r\ncase SIGCOMP_INSTR_SWITCH:\r\noffset = dissect_udvm_literal_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_num,\r\nudvm_tvb, start_offset, len, value);\r\nn = value;\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_j,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_j,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nwhile ( n > 0) {\r\nn = n -1;\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_CRC:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_value,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_value,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_position,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_INPUT_BYTES:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_destination,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_destination,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_INPUT_BITS:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_length,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_destination,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_destination,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_INPUT_HUFFMAN:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_destination,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_destination,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nvalue = ( value + UDVM_address ) & 0xffff;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_at_address,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_literal_operand(udvm_tvb, sigcomp_udvm_tree, offset, &start_offset, &value);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_num,\r\nudvm_tvb, start_offset, len, value);\r\nn = value;\r\nwhile ( n > 0) {\r\nn = n -1;\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_bits,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_lower_bound,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_upper_bound,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, FALSE,&start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_uncompressed,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_STATE_ACCESS:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value ,&is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_partial_identifier_start,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value ,&is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_partial_identifier_length,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_state_begin,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value ,&is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_instr,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_STATE_CREATE:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_instr,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_min_acc_len,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_ret_pri,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_STATE_FREE:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_partial_identifier_start,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_partial_identifier_length,\r\nudvm_tvb, start_offset, len, value);\r\nbreak;\r\ncase SIGCOMP_INSTR_OUTPUT:\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_addr_output_start,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_output_start,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_output_length_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_output_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\nbreak;\r\ncase SIGCOMP_INSTR_END_MESSAGE:\r\nif ((msg_length-1) < offset) {\r\nproto_tree_add_expert(sigcomp_udvm_tree, pinfo, &ei_sigcomp_all_remaining_parameters_zero, udvm_tvb, 0, -1);\r\nreturn;\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_req_feedback_loc,\r\nudvm_tvb, start_offset, len, value);\r\nif ((msg_length-1) < offset) {\r\nproto_tree_add_expert(sigcomp_udvm_tree, pinfo, &ei_sigcomp_all_remaining_parameters_zero, udvm_tvb, offset-1, -1);\r\nreturn;\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_ret_param_loc,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_length,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nif ( is_memory_address ) {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address_addr,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_address,\r\nudvm_tvb, start_offset, len, value);\r\n}\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_instr,\r\nudvm_tvb, start_offset, len, value);\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_min_acc_len,\r\nudvm_tvb, start_offset, len, value);\r\nif ( tvb_reported_length_remaining(udvm_tvb, offset) != 0 ) {\r\noffset = dissect_udvm_multitype_operand(udvm_tvb, sigcomp_udvm_tree, offset, TRUE, &start_offset, &value, &is_memory_address);\r\nlen = offset - start_offset;\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_state_ret_pri,\r\nudvm_tvb, start_offset, len, value);\r\n} else {\r\nitem2 = proto_tree_add_uint_format_value(sigcomp_udvm_tree, hf_udvm_state_ret_pri, udvm_tvb, offset, 1, 0,\r\n"0 (Not in the uploaded code as UDVM buffer initialized to Zero");\r\nPROTO_ITEM_SET_GENERATED(item2);\r\n}\r\nif ( tvb_reported_length_remaining(udvm_tvb, offset) != 0 ) {\r\nlen = tvb_reported_length_remaining(udvm_tvb, offset);\r\nUDVM_address = start_address + offset;\r\nproto_tree_add_bytes_format(sigcomp_udvm_tree, hf_sigcomp_remaining_bytes, udvm_tvb, offset, len, NULL,\r\n"Remaining %u bytes starting at UDVM addr %u (0x%x)- State information ?",len, UDVM_address, UDVM_address);\r\n}\r\noffset = offset + tvb_reported_length_remaining(udvm_tvb, offset);\r\nbreak;\r\ndefault:\r\noffset = offset + tvb_reported_length_remaining(udvm_tvb, offset);\r\nbreak;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int\r\ndissect_udvm_literal_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,\r\ngint offset, gint *start_offset, guint16 *value)\r\n{\r\nguint bytecode;\r\nguint16 operand;\r\nguint test_bits;\r\nguint display_bytecode;\r\nbytecode = tvb_get_guint8(udvm_tvb, offset);\r\ntest_bits = bytecode >> 7;\r\nif (test_bits == 1) {\r\ntest_bits = bytecode >> 6;\r\nif (test_bits == 2) {\r\ndisplay_bytecode = bytecode & 0xc0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = tvb_get_ntohs(udvm_tvb, offset) & 0x3fff;\r\n*value = operand;\r\n*start_offset = offset;\r\noffset = offset + 2;\r\n} else {\r\ndisplay_bytecode = bytecode & 0xc0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noffset ++;\r\noperand = tvb_get_ntohs(udvm_tvb, offset);\r\n*value = operand;\r\n*start_offset = offset;\r\noffset = offset + 2;\r\n}\r\n} else {\r\ndisplay_bytecode = bytecode & 0xc0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_literal_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = ( bytecode & 0x7f);\r\n*value = operand;\r\n*start_offset = offset;\r\noffset ++;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_udvm_reference_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,\r\ngint offset, gint *start_offset, guint16 *value)\r\n{\r\nguint bytecode;\r\nguint16 operand;\r\nguint test_bits;\r\nguint display_bytecode;\r\nbytecode = tvb_get_guint8(udvm_tvb, offset);\r\ntest_bits = bytecode >> 7;\r\nif (test_bits == 1) {\r\ntest_bits = bytecode >> 6;\r\nif (test_bits == 2) {\r\ndisplay_bytecode = bytecode & 0xc0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_reference_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = tvb_get_ntohs(udvm_tvb, offset) & 0x3fff;\r\n*value = (operand * 2);\r\n*start_offset = offset;\r\noffset = offset + 2;\r\n} else {\r\ndisplay_bytecode = bytecode & 0xc0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_reference_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noffset ++;\r\noperand = tvb_get_ntohs(udvm_tvb, offset);\r\n*value = operand;\r\n*start_offset = offset;\r\noffset = offset + 2;\r\n}\r\n} else {\r\ndisplay_bytecode = bytecode & 0xc0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_reference_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = ( bytecode & 0x7f);\r\n*value = (operand * 2);\r\n*start_offset = offset;\r\noffset ++;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_udvm_multitype_operand(tvbuff_t *udvm_tvb, proto_tree *sigcomp_udvm_tree,\r\ngint offset, gboolean is_addr _U_, gint *start_offset, guint16 *value, gboolean *is_memory_address )\r\n{\r\nguint bytecode;\r\nguint display_bytecode;\r\nguint16 operand;\r\nguint32 result;\r\nguint test_bits;\r\n*is_memory_address = FALSE;\r\nbytecode = tvb_get_guint8(udvm_tvb, offset);\r\ntest_bits = ( bytecode & 0xc0 ) >> 6;\r\nswitch (test_bits ) {\r\ncase 0:\r\ndisplay_bytecode = bytecode & 0xc0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_multitype_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = ( bytecode & 0x3f);\r\n*value = operand;\r\n*start_offset = offset;\r\noffset ++;\r\nbreak;\r\ncase 1:\r\ndisplay_bytecode = bytecode & 0xc0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_multitype_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = ( bytecode & 0x3f) * 2;\r\n*is_memory_address = TRUE;\r\n*value = operand;\r\n*start_offset = offset;\r\noffset ++;\r\nbreak;\r\ncase 2:\r\ntest_bits = ( bytecode & 0xe0 ) >> 5;\r\nif ( test_bits == 5 ) {\r\ndisplay_bytecode = bytecode & 0xe0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_multitype_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = tvb_get_ntohs(udvm_tvb, offset) & 0x1fff;\r\n*value = operand;\r\n*start_offset = offset;\r\noffset = offset + 2;\r\n} else {\r\ntest_bits = ( bytecode & 0xf0 ) >> 4;\r\nif ( test_bits == 9 ) {\r\ndisplay_bytecode = bytecode & 0xf0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_multitype_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = (tvb_get_ntohs(udvm_tvb, offset) & 0x0fff) + 61440;\r\n*start_offset = offset;\r\n*value = operand;\r\noffset = offset + 2;\r\n} else {\r\ntest_bits = ( bytecode & 0x08 ) >> 3;\r\nif ( test_bits == 1) {\r\ndisplay_bytecode = bytecode & 0xf8;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_multitype_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\nresult = (guint32)pow(2,( bytecode & 0x07) + 8);\r\noperand = result & 0xffff;\r\n*start_offset = offset;\r\n*value = operand;\r\noffset ++;\r\n} else {\r\ntest_bits = ( bytecode & 0x0e ) >> 1;\r\nif ( test_bits == 3 ) {\r\ndisplay_bytecode = bytecode & 0xfe;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_multitype_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\nresult = (guint32)pow(2,( bytecode & 0x01) + 6);\r\noperand = result & 0xffff;\r\n*start_offset = offset;\r\n*value = operand;\r\noffset ++;\r\n} else {\r\ndisplay_bytecode = bytecode;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_multitype_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\nif ( (bytecode & 0x01) == 1 )\r\n*is_memory_address = TRUE;\r\noffset ++;\r\noperand = tvb_get_ntohs(udvm_tvb, offset);\r\n*value = operand;\r\n*start_offset = offset;\r\noffset = offset +2;\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ncase 3:\r\ntest_bits = ( bytecode & 0x20 ) >> 5;\r\nif ( test_bits == 1 ) {\r\ndisplay_bytecode = bytecode & 0xe0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_multitype_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = ( bytecode & 0x1f) + 65504;\r\n*start_offset = offset;\r\n*value = operand;\r\noffset ++;\r\n} else {\r\ndisplay_bytecode = bytecode & 0xe0;\r\nif ( display_udvm_bytecode )\r\nproto_tree_add_uint(sigcomp_udvm_tree, hf_udvm_multitype_bytecode,\r\nudvm_tvb, offset, 1, display_bytecode);\r\noperand = (tvb_get_ntohs(udvm_tvb, offset) & 0x1fff);\r\n*is_memory_address = TRUE;\r\n*start_offset = offset;\r\n*value = operand;\r\noffset = offset +2;\r\n}\r\ndefault :\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic void\r\ntvb_raw_text_add(tvbuff_t *tvb, proto_tree *tree)\r\n{\r\nproto_tree *raw_tree = NULL;\r\nproto_item *ti = NULL;\r\nint offset, next_offset, linelen;\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_raw_sigcomp, tvb, 0, -1, ENC_NA);\r\nraw_tree = proto_item_add_subtree(ti, ett_raw_text);\r\n}\r\noffset = 0;\r\nwhile (tvb_offset_exists(tvb, offset)) {\r\ntvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\r\nlinelen = next_offset - offset;\r\nproto_tree_add_format_text(raw_tree, tvb, offset, linelen);\r\noffset = next_offset;\r\n}\r\n}\r\nvoid\r\nproto_register_sigcomp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_sigcomp_t_bit,\r\n{ "T bit", "sigcomp.t.bit",\r\nFT_UINT8, BASE_DEC, NULL, 0x04,\r\n"Sigcomp T bit", HFILL }\r\n},\r\n{ &hf_sigcomp_len,\r\n{ "Partial state id length","sigcomp.length",\r\nFT_UINT8, BASE_HEX, VALS(length_encoding_vals), 0x03,\r\n"Sigcomp length", HFILL }\r\n},\r\n{ &hf_sigcomp_returned_feedback_item,\r\n{ "Returned_feedback item", "sigcomp.returned.feedback.item",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Returned feedback item", HFILL }\r\n},\r\n{ &hf_sigcomp_partial_state,\r\n{ "Partial state identifier", "sigcomp.partial.state.identifier",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_remaining_message_bytes,\r\n{ "Remaining SigComp message bytes", "sigcomp.remaining-bytes",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Number of bytes remaining in message", HFILL }\r\n},\r\n{ &hf_sigcomp_compression_ratio,\r\n{ "Compression ratio (%)", "sigcomp.compression-ratio",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Compression ratio (decompressed / compressed) %", HFILL }\r\n},\r\n{ &hf_sigcomp_returned_feedback_item_len,\r\n{ "Returned feedback item length", "sigcomp.returned.feedback.item.len",\r\nFT_UINT8, BASE_DEC, NULL, 0x7f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_code_len,\r\n{ "Code length","sigcomp.code.len",\r\nFT_UINT16, BASE_HEX, NULL, 0xfff0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_destination,\r\n{ "Destination","sigcomp.destination",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING, &destination_address_encoding_vals_ext, 0xf,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_udvm_bytecode,\r\n{ "Uploaded UDVM bytecode","sigcomp.udvm.byte-code",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_udvm_instr,\r\n{ "UDVM instruction code","sigcomp.udvm.instr",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING, &udvm_instruction_code_vals_ext, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_udvm_execution_trace,\r\n{ "UDVM execution trace","sigcomp.udvm.execution-trace",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_udvm_multitype_bytecode,\r\n{ "UDVM bytecode", "sigcomp.udvm.multyt.bytecode",\r\nFT_UINT8, BASE_HEX, VALS(display_bytecode_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_udvm_reference_bytecode,\r\n{ "UDVM bytecode", "sigcomp.udvm.ref.bytecode",\r\nFT_UINT8, BASE_HEX, VALS(display_ref_bytecode_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_udvm_literal_bytecode,\r\n{ "UDVM bytecode", "sigcomp.udvm.lit.bytecode",\r\nFT_UINT8, BASE_HEX, VALS(display_lit_bytecode_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n#if 0\r\n{ &hf_udvm_operand,\r\n{ "UDVM operand", "sigcomp.udvm.operand",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n#endif\r\n{ &hf_udvm_length,\r\n{ "%Length", "sigcomp.udvm.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Length", HFILL }\r\n},\r\n{ &hf_udvm_addr_length,\r\n{ "%Length[memory address]", "sigcomp.udvm.addr.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Length", HFILL }\r\n},\r\n{ &hf_udvm_destination,\r\n{ "%Destination", "sigcomp.udvm.destination",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Destination", HFILL }\r\n},\r\n{ &hf_udvm_addr_destination,\r\n{ "%Destination[memory address]", "sigcomp.udvm.addr.destination",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Destination", HFILL }\r\n},\r\n{ &hf_udvm_at_address,\r\n{ "@Address(mem_add_of_inst + D) mod 2^16)", "sigcomp.udvm.at.address",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Address", HFILL }\r\n},\r\n{ &hf_udvm_address,\r\n{ "%Address", "sigcomp.udvm.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Address", HFILL }\r\n},\r\n{ &hf_udvm_literal_num,\r\n{ "#n", "sigcomp.udvm.literal-num",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Literal number", HFILL }\r\n},\r\n{ &hf_udvm_value,\r\n{ "%Value", "sigcomp.udvm.value",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Value", HFILL }\r\n},\r\n{ &hf_udvm_addr_value,\r\n{ "%Value[memory address]", "sigcomp.udvm.value",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Value", HFILL }\r\n},\r\n{ &hf_partial_identifier_start,\r\n{ "%Partial identifier start", "sigcomp.udvm.partial.identifier.start",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Partial identifier start", HFILL }\r\n},\r\n{ &hf_partial_identifier_length,\r\n{ "%Partial identifier length", "sigcomp.udvm.partial.identifier.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Partial identifier length", HFILL }\r\n},\r\n{ &hf_state_begin,\r\n{ "%State begin", "sigcomp.udvm.state.begin",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"State begin", HFILL }\r\n},\r\n{ &hf_udvm_state_length,\r\n{ "%State length", "sigcomp.udvm.state.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"State length", HFILL }\r\n},\r\n{ &hf_udvm_state_length_addr,\r\n{ "%State length[memory address]", "sigcomp.udvm.state.length.addr",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"State length", HFILL }\r\n},\r\n{ &hf_udvm_state_address,\r\n{ "%State address", "sigcomp.udvm.start.address",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"State address", HFILL }\r\n},\r\n{ &hf_udvm_state_address_addr,\r\n{ "%State address[memory address]", "sigcomp.udvm.start.address.addr",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"State address", HFILL }\r\n},\r\n{ &hf_udvm_state_instr,\r\n{ "%State instruction", "sigcomp.udvm.start.instr",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"State instruction", HFILL }\r\n},\r\n{ &hf_udvm_operand_1,\r\n{ "$Operand 1[memory address]", "sigcomp.udvm.operand.1",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Reference $ Operand 1", HFILL }\r\n},\r\n{ &hf_udvm_operand_2,\r\n{ "%Operand 2", "sigcomp.udvm.operand.2",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Operand 2", HFILL }\r\n},\r\n{ &hf_udvm_operand_2_addr,\r\n{ "%Operand 2[memory address]", "sigcomp.udvm.operand.2.addr",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Operand 2", HFILL }\r\n},\r\n{ &hf_udvm_j,\r\n{ "%j", "sigcomp.udvm.j",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"j", HFILL }\r\n},\r\n{ &hf_udvm_addr_j,\r\n{ "%j[memory address]", "sigcomp.udvm.addr.j",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"j", HFILL }\r\n},\r\n{ &hf_udvm_output_start,\r\n{ "%Output_start", "sigcomp.output.start",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Output start", HFILL }\r\n},\r\n{ &hf_udvm_addr_output_start,\r\n{ "%Output_start[memory address]", "sigcomp.addr.output.start",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Output start", HFILL }\r\n},\r\n{ &hf_udvm_output_length,\r\n{ "%Output_length", "sigcomp.output.length",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Output length", HFILL }\r\n},\r\n{ &hf_udvm_output_length_addr,\r\n{ "%Output_length[memory address]", "sigcomp.output.length.addr",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Output length", HFILL }\r\n},\r\n{ &hf_udvm_req_feedback_loc,\r\n{ "%Requested feedback location", "sigcomp.req.feedback.loc",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Requested feedback location", HFILL }\r\n},\r\n{ &hf_udvm_min_acc_len,\r\n{ "%Minimum access length", "sigcomp.min.acc.len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Minimum access length", HFILL }\r\n},\r\n{ &hf_udvm_state_ret_pri,\r\n{ "%State retention priority", "sigcomp.udvm.state.ret.pri",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"State retention priority", HFILL }\r\n},\r\n{ &hf_udvm_ret_param_loc,\r\n{ "%Returned parameters location", "sigcomp.ret.param.loc",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Returned parameters location", HFILL }\r\n},\r\n{ &hf_udvm_position,\r\n{ "%Position", "sigcomp.udvm.position",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Position", HFILL }\r\n},\r\n{ &hf_udvm_ref_dest,\r\n{ "$Destination[memory address]", "sigcomp.udvm.ref.destination",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"(reference)Destination", HFILL }\r\n},\r\n{ &hf_udvm_bits,\r\n{ "%Bits", "sigcomp.udvm.bits",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Bits", HFILL }\r\n},\r\n{ &hf_udvm_lower_bound,\r\n{ "%Lower bound", "sigcomp.udvm.lower.bound",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Lower_bound", HFILL }\r\n},\r\n{ &hf_udvm_upper_bound,\r\n{ "%Upper bound", "sigcomp.udvm.upper.bound",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Upper bound", HFILL }\r\n},\r\n{ &hf_udvm_uncompressed,\r\n{ "%Uncompressed", "sigcomp.udvm.uncompressed",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Uncompressed", HFILL }\r\n},\r\n{ &hf_udvm_start_value,\r\n{ "%Start value", "sigcomp.udvm.start.value",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Start value", HFILL }\r\n},\r\n{ &hf_udvm_offset,\r\n{ "%Offset", "sigcomp.udvm.offset",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Offset", HFILL }\r\n},\r\n{ &hf_udvm_addr_offset,\r\n{ "%Offset[memory address]", "sigcomp.udvm.addr.offset",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Offset", HFILL }\r\n},\r\n{ &hf_sigcomp_nack_ver,\r\n{ "NACK Version", "sigcomp.nack.ver",\r\nFT_UINT8, BASE_DEC, NULL, 0x0f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_nack_reason_code,\r\n{ "Reason Code", "sigcomp.nack.reason",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING, &sigcomp_nack_reason_code_vals_ext, 0x0,\r\n"NACK Reason Code", HFILL }\r\n},\r\n{ &hf_sigcomp_nack_failed_op_code,\r\n{ "OPCODE of failed instruction", "sigcomp.nack.failed_op_code",\r\nFT_UINT8, BASE_DEC | BASE_EXT_STRING, &udvm_instruction_code_vals_ext, 0x0,\r\n"NACK OPCODE of failed instruction", HFILL }\r\n},\r\n{ &hf_sigcomp_nack_pc,\r\n{ "PC of failed instruction", "sigcomp.nack.pc",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"NACK PC of failed instruction", HFILL }\r\n},\r\n{ &hf_sigcomp_nack_sha1,\r\n{ "SHA-1 Hash of failed message", "sigcomp.nack.sha1",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"NACK SHA-1 Hash of failed message", HFILL }\r\n},\r\n{ &hf_sigcomp_nack_state_id,\r\n{ "State ID (6 - 20 bytes)", "sigcomp.nack.state_id",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"NACK State ID (6 - 20 bytes)", HFILL }\r\n},\r\n{ &hf_sigcomp_nack_cycles_per_bit,\r\n{ "Cycles Per Bit", "sigcomp.nack.cycles_per_bit",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"NACK Cycles Per Bit", HFILL }\r\n},\r\n{ &hf_sigcomp_nack_memory_size,\r\n{ "Memory size", "sigcomp.memory_size",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_decompress_instruction,\r\n{ "Instruction", "sigcomp.decompress_instruction",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_loading_result,\r\n{ "Loading result", "sigcomp.loading_result",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_byte_copy,\r\n{ "byte copy", "sigcomp.byte_copy",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_sigcomp_accessing_state, { "### Accessing state ###", "sigcomp.accessing_state", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_getting_value, { "Getting value", "sigcomp.getting_value", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_load_bytecode_into_udvm_start, { "Load bytecode into UDVM starting at", "sigcomp.load_bytecode_into_udvm_start", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_instruction_code, { "Instruction code", "sigcomp.instruction_code", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_current_instruction, { "Addr", "sigcomp.current_instruction", FT_UINT8, BASE_DEC|BASE_EXT_STRING, &udvm_instruction_code_vals_ext, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_decompression_failure, { "DECOMPRESSION-FAILURE", "sigcomp.decompression_failure", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_wireshark_udvm_diagnostic, { "Wireshark UDVM diagnostic", "sigcomp.wireshark_udvm_diagnostic", FT_UINT32, BASE_DEC, VALS(result_code_vals), 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_calculated_sha_1, { "Calculated SHA-1", "sigcomp.calculated_sha_1", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_copying_value, { "Copying value", "sigcomp.copying_value", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_storing_value, { "Storing value", "sigcomp.storing_value", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_loading_value, { "Loading value", "sigcomp.loading_value", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_set_hu, { "Set Hu", "sigcomp.set_hu", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_loading_h, { "Loading H", "sigcomp.loading_h", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_state_value, { "Addr", "sigcomp.state_value", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_output_value, { "Output value", "sigcomp.output_value", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_num_state_create, { "no_of_state_create", "sigcomp.num_state_create", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_sha1_digest, { "SHA1 digest", "sigcomp.sha1_digest", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_creating_state, { "### Creating state ###", "sigcomp.creating_state", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_sigcomp_message_decompressed, { "SigComp message Decompressed", "sigcomp.message_decompressed", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_starting_to_remove_escape_digits, { "Starting to remove escape digits", "sigcomp.starting_to_remove_escape_digits", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_escape_digit_found, { "Escape digit found", "sigcomp.escape_digit_found", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_illegal_escape_code, { "Illegal escape code", "sigcomp.illegal_escape_code", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_end_of_sigcomp_message_indication_found, { "End of SigComp message indication found", "sigcomp.end_of_sigcomp_message_indication_found", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_addr_value, { "Addr", "sigcomp.addr", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_copying_bytes_literally, { "Copying bytes literally", "sigcomp.copying_bytes_literally", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_data_for_sigcomp_dissector, { "Data handed to the Sigcomp dissector", "sigcomp.data_for_sigcomp_dissector", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_remaining_sigcomp_message, { "Remaining SigComp message", "sigcomp.remaining_sigcomp_message", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_sha1buff, { "sha1buff", "sigcomp.sha1buff", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_udvm_instruction, { "UDVM instruction", "sigcomp.udvm_instruction", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_remaining_bytes, { "Remaining bytes", "sigcomp.remaining_bytes", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_max_udvm_cycles, { "maximum_UDVM_cycles", "sigcomp.max_udvm_cycles", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_used_udvm_cycles, { "used_udvm_cycles", "sigcomp.used_udvm_cycles", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_udvm_execution_stated, { "UDVM EXECUTION STARTED", "sigcomp.udvm_execution_stated", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_message_length, { "Message Length", "sigcomp.message_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_sigcomp_byte_code_length, { "Byte code length", "sigcomp.byte_code_length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_sigcomp,\r\n&ett_sigcomp_udvm,\r\n&ett_sigcomp_udvm_exe,\r\n};\r\nstatic gint *ett_raw[] = {\r\n&ett_raw_text,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_sigcomp_nack_failed_op_code, { "sigcomp.nack.failed_op_code.expert", PI_SEQUENCE, PI_WARN, "SigComp NACK", EXPFILL }},\r\n{ &ei_sigcomp_invalid_instruction, { "sigcomp.invalid_instruction", PI_PROTOCOL, PI_WARN, "Invalid instruction", EXPFILL }},\r\n{ &ei_sigcomp_sigcomp_message_decompression_failure, { "sigcomp.message_decompression_failure", PI_PROTOCOL, PI_WARN, "SigComp message Decompression failure", EXPFILL }},\r\n{ &ei_sigcomp_execution_of_this_instruction_is_not_implemented, { "sigcomp.execution_of_this_instruction_is_not_implemented", PI_UNDECODED, PI_WARN, "Execution of this instruction is NOT implemented", EXPFILL }},\r\n{ &ei_sigcomp_decompression_failure, { "sigcomp.decompression_failure_expert", PI_PROTOCOL, PI_WARN, "DECOMPRESSION FAILURE", EXPFILL }},\r\n{ &ei_sigcomp_tcp_fragment, { "sigcomp.tcp_fragment", PI_MALFORMED, PI_ERROR, "TCP Fragment", EXPFILL }},\r\n{ &ei_sigcomp_failed_to_access_state_wireshark_udvm_diagnostic, { "sigcomp.failed_to_access_state_wireshark_udvm_diagnostic", PI_PROTOCOL, PI_WARN, "Failed to Access state Wireshark UDVM diagnostic", EXPFILL }},\r\n{ &ei_sigcomp_all_remaining_parameters_zero, { "sigcomp.all_remaining_parameters", PI_PROTOCOL, PI_NOTE, "All remaining parameters = 0(Not in the uploaded code as UDVM buffer initialized to Zero", EXPFILL }},\r\n};\r\nmodule_t *sigcomp_module;\r\nexpert_module_t* expert_sigcomp;\r\nstatic const enum_val_t udvm_detail_vals[] = {\r\n{"no-printout", "No-Printout", 0},\r\n{"low-detail", "Low-detail", 1},\r\n{"medium-detail", "Medium-detail", 2},\r\n{"high-detail", "High-detail", 3},\r\n{NULL, NULL, -1}\r\n};\r\nproto_sigcomp = proto_register_protocol("Signaling Compression",\r\n"SIGCOMP", "sigcomp");\r\nproto_raw_sigcomp = proto_register_protocol("Decompressed SigComp message as raw text",\r\n"Raw_SigComp", "raw_sigcomp");\r\nregister_dissector("sigcomp", dissect_sigcomp, proto_sigcomp);\r\nproto_register_field_array(proto_sigcomp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nproto_register_subtree_array(ett_raw, array_length(ett_raw));\r\nexpert_sigcomp = expert_register_protocol(proto_sigcomp);\r\nexpert_register_field_array(expert_sigcomp, ei, array_length(ei));\r\nsigcomp_module = prefs_register_protocol(proto_sigcomp,\r\nproto_reg_handoff_sigcomp);\r\nprefs_register_uint_preference(sigcomp_module, "udp.port",\r\n"Sigcomp UDP Port 1",\r\n"Set UDP port 1 for SigComp messages",\r\n10,\r\n&SigCompUDPPort1);\r\nprefs_register_uint_preference(sigcomp_module, "udp.port2",\r\n"Sigcomp UDP Port 2",\r\n"Set UDP port 2 for SigComp messages",\r\n10,\r\n&SigCompUDPPort2);\r\nprefs_register_uint_preference(sigcomp_module, "tcp.port",\r\n"Sigcomp TCP Port 1",\r\n"Set TCP port 1 for SigComp messages",\r\n10,\r\n&SigCompTCPPort1);\r\nprefs_register_uint_preference(sigcomp_module, "tcp.port2",\r\n"Sigcomp TCP Port 2",\r\n"Set TCP port 2 for SigComp messages",\r\n10,\r\n&SigCompTCPPort2);\r\nprefs_register_bool_preference(sigcomp_module, "display.udvm.code",\r\n"Dissect the UDVM code",\r\n"Preference whether to Dissect the UDVM code or not",\r\n&dissect_udvm_code);\r\nprefs_register_bool_preference(sigcomp_module, "display.bytecode",\r\n"Display the bytecode of operands",\r\n"preference whether to display the bytecode in "\r\n"UDVM operands or not",\r\n&display_udvm_bytecode);\r\nprefs_register_bool_preference(sigcomp_module, "decomp.msg",\r\n"Decompress message",\r\n"preference whether to decompress message or not",\r\n&decompress);\r\nprefs_register_bool_preference(sigcomp_module, "display.decomp.msg.as.txt",\r\n"Displays the decompressed message as text",\r\n"preference whether to display the decompressed message "\r\n"as raw text or not",\r\n&display_raw_txt);\r\nprefs_register_enum_preference(sigcomp_module, "show.udvm.execution",\r\n"Level of detail of UDVM execution:",\r\n"'No-Printout' = UDVM executes silently, then increasing detail "\r\n"about execution of UDVM instructions; "\r\n"Warning! CPU intense at high detail",\r\n&udvm_print_detail_level, udvm_detail_vals, FALSE);\r\nregister_init_routine(&sigcomp_init_udvm);\r\nregister_cleanup_routine(&sigcomp_cleanup_udvm);\r\n}\r\nvoid\r\nproto_reg_handoff_sigcomp(void)\r\n{\r\nstatic dissector_handle_t sigcomp_handle;\r\nstatic dissector_handle_t sigcomp_tcp_handle;\r\nstatic gboolean Initialized = FALSE;\r\nstatic guint udp_port1;\r\nstatic guint udp_port2;\r\nstatic guint tcp_port1;\r\nstatic guint tcp_port2;\r\nif (!Initialized) {\r\nsigcomp_handle = find_dissector("sigcomp");\r\nsigcomp_tcp_handle = create_dissector_handle(dissect_sigcomp_tcp,proto_sigcomp);\r\nsip_handle = find_dissector_add_dependency("sip",proto_sigcomp);\r\nInitialized=TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", udp_port1, sigcomp_handle);\r\ndissector_delete_uint("udp.port", udp_port2, sigcomp_handle);\r\ndissector_delete_uint("tcp.port", tcp_port1, sigcomp_tcp_handle);\r\ndissector_delete_uint("tcp.port", tcp_port2, sigcomp_tcp_handle);\r\n}\r\nudp_port1 = SigCompUDPPort1;\r\nudp_port2 = SigCompUDPPort2;\r\ntcp_port1 = SigCompTCPPort1;\r\ntcp_port2 = SigCompTCPPort2;\r\ndissector_add_uint("udp.port", SigCompUDPPort1, sigcomp_handle);\r\ndissector_add_uint("udp.port", SigCompUDPPort2, sigcomp_handle);\r\ndissector_add_uint("tcp.port", SigCompTCPPort1, sigcomp_tcp_handle);\r\ndissector_add_uint("tcp.port", SigCompTCPPort2, sigcomp_tcp_handle);\r\n}
