static void\r\nfree_col_width_info(recent_settings_t *rs)\r\n{\r\ncol_width_data *cfmt;\r\nwhile (rs->col_width_list != NULL) {\r\ncfmt = (col_width_data *)rs->col_width_list->data;\r\ng_free(cfmt->cfield);\r\ng_free(cfmt);\r\nrs->col_width_list = g_list_remove_link(rs->col_width_list, rs->col_width_list);\r\n}\r\ng_list_free(rs->col_width_list);\r\nrs->col_width_list = NULL;\r\n}\r\nstatic void\r\nwrite_recent_geom(gpointer key _U_, gpointer value, gpointer rfh)\r\n{\r\nwindow_geometry_t *geom = (window_geometry_t *)value;\r\nFILE *rf = (FILE *)rfh;\r\nfprintf(rf, "\n# Geometry and maximized state of %s window.\n", geom->key);\r\nfprintf(rf, "# Decimal integers.\n");\r\nfprintf(rf, RECENT_GUI_GEOMETRY "%s.x: %d\n", geom->key, geom->x);\r\nfprintf(rf, RECENT_GUI_GEOMETRY "%s.y: %d\n", geom->key, geom->y);\r\nfprintf(rf, RECENT_GUI_GEOMETRY "%s.width: %d\n", geom->key,\r\ngeom->width);\r\nfprintf(rf, RECENT_GUI_GEOMETRY "%s.height: %d\n", geom->key,\r\ngeom->height);\r\nfprintf(rf, "# TRUE or FALSE (case-insensitive).\n");\r\nfprintf(rf, RECENT_GUI_GEOMETRY "%s.maximized: %s\n", geom->key,\r\ngeom->maximized == TRUE ? "TRUE" : "FALSE");\r\n}\r\nvoid\r\nwindow_geom_save(const gchar *name, window_geometry_t *geom)\r\n{\r\ngchar *key;\r\nwindow_geometry_t *work;\r\nif (!window_geom_hash) {\r\nwindow_geom_hash = g_hash_table_new(g_str_hash, g_str_equal);\r\n}\r\nwork = (window_geometry_t *)g_hash_table_lookup(window_geom_hash, name);\r\nif (work) {\r\ng_hash_table_remove(window_geom_hash, name);\r\ng_free(work->key);\r\ng_free(work);\r\n}\r\nwork = (window_geometry_t *)g_malloc(sizeof(window_geometry_t));\r\n*work = *geom;\r\nkey = g_strdup(name);\r\nwork->key = key;\r\ng_hash_table_insert(window_geom_hash, key, work);\r\n}\r\ngboolean\r\nwindow_geom_load(const gchar *name,\r\nwindow_geometry_t *geom)\r\n{\r\nwindow_geometry_t *p;\r\nif (!window_geom_hash) {\r\nwindow_geom_hash = g_hash_table_new(g_str_hash, g_str_equal);\r\n}\r\np = (window_geometry_t *)g_hash_table_lookup(window_geom_hash, name);\r\nif (p) {\r\n*geom = *p;\r\nreturn TRUE;\r\n} else {\r\nreturn FALSE;\r\n}\r\n}\r\nstatic void\r\nparse_recent_boolean(const gchar *val_str, gboolean *valuep)\r\n{\r\nif (g_ascii_strcasecmp(val_str, "true") == 0) {\r\n*valuep = TRUE;\r\n}\r\nelse {\r\n*valuep = FALSE;\r\n}\r\n}\r\nstatic void\r\nwindow_geom_recent_read_pair(const char *name,\r\nconst char *key,\r\nconst char *value)\r\n{\r\nwindow_geometry_t geom;\r\nif (!window_geom_load(name, &geom)) {\r\ngeom.key = NULL;\r\ngeom.set_pos = FALSE;\r\ngeom.x = -1;\r\ngeom.y = -1;\r\ngeom.set_size = FALSE;\r\ngeom.width = -1;\r\ngeom.height = -1;\r\ngeom.set_maximized = FALSE;\r\ngeom.maximized = FALSE;\r\n}\r\nif (strcmp(key, "x") == 0) {\r\ngeom.x = (gint)strtol(value, NULL, 10);\r\ngeom.set_pos = TRUE;\r\n} else if (strcmp(key, "y") == 0) {\r\ngeom.y = (gint)strtol(value, NULL, 10);\r\ngeom.set_pos = TRUE;\r\n} else if (strcmp(key, "width") == 0) {\r\ngeom.width = (gint)strtol(value, NULL, 10);\r\ngeom.set_size = TRUE;\r\n} else if (strcmp(key, "height") == 0) {\r\ngeom.height = (gint)strtol(value, NULL, 10);\r\ngeom.set_size = TRUE;\r\n} else if (strcmp(key, "maximized") == 0) {\r\nparse_recent_boolean(value, &geom.maximized);\r\ngeom.set_maximized = TRUE;\r\n} else {\r\nreturn;\r\n}\r\nwindow_geom_save(name, &geom);\r\n}\r\nstatic void\r\nwindow_geom_recent_write_all(FILE *rf)\r\n{\r\nif (!window_geom_hash) {\r\nwindow_geom_hash = g_hash_table_new(g_str_hash, g_str_equal);\r\n}\r\ng_hash_table_foreach(window_geom_hash, write_recent_geom, rf);\r\n}\r\nGList *\r\nrecent_get_cfilter_list(const gchar *ifname)\r\n{\r\nif (ifname == NULL)\r\nreturn recent_cfilter_list;\r\nif (per_interface_cfilter_lists_hash == NULL) {\r\nreturn NULL;\r\n}\r\nreturn (GList *)g_hash_table_lookup(per_interface_cfilter_lists_hash, ifname);\r\n}\r\nvoid\r\nrecent_add_cfilter(const gchar *ifname, const gchar *s)\r\n{\r\nGList *cfilter_list;\r\nGList *li;\r\ngchar *li_filter, *newfilter = NULL;\r\nif (s[0] == '\0')\r\nreturn;\r\nif (ifname == NULL)\r\ncfilter_list = recent_cfilter_list;\r\nelse {\r\nif (per_interface_cfilter_lists_hash == NULL)\r\nper_interface_cfilter_lists_hash = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);\r\ncfilter_list = (GList *)g_hash_table_lookup(per_interface_cfilter_lists_hash, ifname);\r\n}\r\nli = g_list_first(cfilter_list);\r\nwhile (li) {\r\nli_filter = (char *)li->data;\r\nif (strcmp(s, li_filter) == 0) {\r\nnewfilter = li_filter;\r\ncfilter_list = g_list_remove(cfilter_list, li->data);\r\nbreak;\r\n}\r\nli = li->next;\r\n}\r\nif (newfilter == NULL) {\r\nnewfilter = g_strdup(s);\r\n}\r\ncfilter_list = g_list_append(cfilter_list, newfilter);\r\nif (ifname == NULL)\r\nrecent_cfilter_list = cfilter_list;\r\nelse\r\ng_hash_table_insert(per_interface_cfilter_lists_hash, g_strdup(ifname), cfilter_list);\r\n}\r\nint recent_get_remote_host_list_size(void)\r\n{\r\nreturn g_hash_table_size (remote_host_list);\r\n}\r\nvoid recent_add_remote_host(gchar *host, struct remote_host *rh)\r\n{\r\nif (remote_host_list == NULL) {\r\nremote_host_list = g_hash_table_new (g_str_hash, g_str_equal);\r\n}\r\ng_hash_table_insert (remote_host_list, g_strdup(host), rh);\r\n}\r\nstatic gboolean\r\nfree_remote_host (gpointer key _U_, gpointer value, gpointer user _U_)\r\n{\r\nstruct remote_host *rh = value;\r\ng_free (rh->r_host);\r\ng_free (rh->remote_port);\r\ng_free (rh->auth_username);\r\ng_free (rh->auth_password);\r\nreturn TRUE;\r\n}\r\nGHashTable *get_remote_host_list(void)\r\n{\r\nreturn remote_host_list;\r\n}\r\nstatic void\r\nrecent_print_remote_host (gpointer key _U_, gpointer value, gpointer user)\r\n{\r\nFILE *rf = user;\r\nstruct remote_host_info *ri = value;\r\nfprintf (rf, RECENT_KEY_REMOTE_HOST ": %s,%s,%d\n", ri->remote_host, ri->remote_port, ri->auth_type);\r\n}\r\nvoid\r\ncapture_remote_combo_recent_write_all(FILE *rf)\r\n{\r\nif (remote_host_list && g_hash_table_size (remote_host_list) > 0) {\r\ng_hash_table_foreach (remote_host_list, recent_print_remote_host, rf);\r\n}\r\n}\r\nvoid free_remote_host_list(void)\r\n{\r\ng_hash_table_foreach_remove(remote_host_list, free_remote_host, NULL);\r\n}\r\nstruct remote_host *\r\nrecent_get_remote_host(const gchar *host)\r\n{\r\nif (host == NULL)\r\nreturn NULL;\r\nif (remote_host_list == NULL) {\r\nreturn NULL;\r\n}\r\nreturn (struct remote_host *)g_hash_table_lookup(remote_host_list, host);\r\n}\r\ngboolean\r\ncapture_remote_combo_add_recent(const gchar *s)\r\n{\r\nGList *vals = prefs_get_string_list (s);\r\nGList *valp = vals;\r\ngint auth_type;\r\nchar *p;\r\nstruct remote_host *rh;\r\nif (valp == NULL)\r\nreturn FALSE;\r\nif (remote_host_list == NULL) {\r\nremote_host_list = g_hash_table_new (g_str_hash, g_str_equal);\r\n}\r\nrh = g_malloc (sizeof (*rh));\r\nrh->r_host = g_strdup (valp->data);\r\nif (strlen(rh->r_host) == 0) {\r\ng_free(rh->r_host);\r\ng_free(rh);\r\nreturn FALSE;\r\n}\r\nrh->auth_type = CAPTURE_AUTH_NULL;\r\nvalp = valp->next;\r\nif (valp) {\r\nrh->remote_port = g_strdup (valp->data);\r\nvalp = valp->next;\r\n} else {\r\nrh->remote_port = g_strdup ("");\r\n}\r\nif (valp) {\r\nauth_type = strtol(valp->data, &p, 0);\r\nif (p != valp->data && *p == '\0') {\r\nrh->auth_type = auth_type;\r\n}\r\n}\r\nrh->auth_username = g_strdup ("");\r\nrh->auth_password = g_strdup ("");\r\nprefs_clear_string_list(vals);\r\ng_hash_table_insert (remote_host_list, g_strdup(rh->r_host), rh);\r\nreturn TRUE;\r\n}\r\nstatic void\r\ncfilter_recent_write_all_list(FILE *rf, const gchar *ifname, GList *cfilter_list)\r\n{\r\nguint max_count = 0;\r\nGList *li;\r\nli = g_list_first(cfilter_list);\r\nwhile (li && (max_count++ <= cfilter_combo_max_recent) ) {\r\nif (li->data && strlen((const char *)li->data)) {\r\nif (ifname == NULL)\r\nfprintf (rf, RECENT_KEY_CAPTURE_FILTER ": %s\n", (char *)li->data);\r\nelse\r\nfprintf (rf, RECENT_KEY_CAPTURE_FILTER ".%s: %s\n", ifname, (char *)li->data);\r\n}\r\nli = li->next;\r\n}\r\n}\r\nstatic void\r\ncfilter_recent_write_all_hash_callback(gpointer key, gpointer value, gpointer user_data)\r\n{\r\ncfilter_recent_write_all_list((FILE *)user_data, (const gchar *)key, (GList *)value);\r\n}\r\nstatic void\r\ncfilter_recent_write_all(FILE *rf)\r\n{\r\ncfilter_recent_write_all_list(rf, NULL, recent_cfilter_list);\r\nif (per_interface_cfilter_lists_hash != NULL) {\r\ng_hash_table_foreach(per_interface_cfilter_lists_hash, cfilter_recent_write_all_hash_callback, (gpointer)rf);\r\n}\r\n}\r\nstatic void\r\nwrite_recent_boolean(FILE *rf, const char *description, const char *name,\r\ngboolean value)\r\n{\r\nfprintf(rf, "\n# %s.\n", description);\r\nfprintf(rf, "# TRUE or FALSE (case-insensitive).\n");\r\nfprintf(rf, "%s: %s\n", name, value == TRUE ? "TRUE" : "FALSE");\r\n}\r\nstatic void\r\nwrite_recent_enum(FILE *rf, const char *description, const char *name,\r\nconst value_string *values, guint value)\r\n{\r\nconst char *if_invalid = NULL;\r\nconst value_string *valp;\r\nfprintf(rf, "\n# %s.\n", description);\r\nfprintf(rf, "# One of: ");\r\nvalp = values;\r\nwhile (valp->strptr != NULL) {\r\nif (if_invalid == NULL)\r\nif_invalid = valp->strptr;\r\nfprintf(rf, "%s", valp->strptr);\r\nvalp++;\r\nif (valp->strptr != NULL)\r\nfprintf(rf, ", ");\r\n}\r\nfprintf(rf, "\n");\r\nfprintf(rf, "%s: %s\n", name,\r\nval_to_str(value, values, if_invalid != NULL ? if_invalid : "Unknown"));\r\n}\r\ngboolean\r\nwrite_recent(void)\r\n{\r\nchar *pf_dir_path;\r\nchar *rf_path;\r\nFILE *rf;\r\nchar *string_list;\r\nif (create_persconffile_dir(&pf_dir_path) == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't create directory\n\"%s\"\nfor recent file: %s.", pf_dir_path,\r\ng_strerror(errno));\r\ng_free(pf_dir_path);\r\nreturn FALSE;\r\n}\r\nrf_path = get_persconffile_path(RECENT_COMMON_FILE_NAME, FALSE);\r\nif ((rf = ws_fopen(rf_path, "w")) == NULL) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't open recent file\n\"%s\": %s.", rf_path,\r\ng_strerror(errno));\r\ng_free(rf_path);\r\nreturn FALSE;\r\n}\r\ng_free(rf_path);\r\nfputs("# Recent settings file for Wireshark " VERSION ".\n"\r\n"#\n"\r\n"# This file is regenerated each time Wireshark is quit.\n"\r\n"# So be careful, if you want to make manual changes here.\n"\r\n"\n"\r\n"######## Recent capture files (latest last), cannot be altered through command line ########\n"\r\n"\n", rf);\r\nmenu_recent_file_write_all(rf);\r\nfputs("\n"\r\n"######## Recent capture filters (latest last), cannot be altered through command line ########\n"\r\n"\n", rf);\r\ncfilter_recent_write_all(rf);\r\nfputs("\n"\r\n"######## Recent display filters (latest last), cannot be altered through command line ########\n"\r\n"\n", rf);\r\ndfilter_recent_combo_write_all(rf);\r\n#ifdef HAVE_PCAP_REMOTE\r\nfputs("\n"\r\n"######## Recent remote hosts, cannot be altered through command line ########\n"\r\n"\n", rf);\r\ncapture_remote_combo_recent_write_all(rf);\r\n#endif\r\nfprintf(rf, "\n# Main window geometry.\n");\r\nfprintf(rf, "# Decimal numbers.\n");\r\nfprintf(rf, RECENT_GUI_GEOMETRY_MAIN_X ": %d\n", recent.gui_geometry_main_x);\r\nfprintf(rf, RECENT_GUI_GEOMETRY_MAIN_Y ": %d\n", recent.gui_geometry_main_y);\r\nfprintf(rf, RECENT_GUI_GTK_GEOMETRY_MAIN_X ": %d\n", recent.gui_gtk_geometry_main_x);\r\nfprintf(rf, RECENT_GUI_GTK_GEOMETRY_MAIN_Y ": %d\n", recent.gui_gtk_geometry_main_y);\r\nfprintf(rf, RECENT_GUI_GEOMETRY_MAIN_WIDTH ": %d\n",\r\nrecent.gui_geometry_main_width);\r\nfprintf(rf, RECENT_GUI_GEOMETRY_MAIN_HEIGHT ": %d\n",\r\nrecent.gui_geometry_main_height);\r\nwrite_recent_boolean(rf, "Main window maximized",\r\nRECENT_GUI_GEOMETRY_MAIN_MAXIMIZED,\r\nrecent.gui_geometry_main_maximized);\r\nfprintf(rf, "\n# Statusbar left pane size.\n");\r\nfprintf(rf, "# Decimal number.\n");\r\nif (recent.gui_geometry_status_pane_left != 0) {\r\nfprintf(rf, RECENT_GUI_GEOMETRY_STATUS_PANE_LEFT ": %d\n",\r\nrecent.gui_geometry_status_pane_left);\r\n}\r\nfprintf(rf, "\n# Statusbar middle pane size.\n");\r\nfprintf(rf, "# Decimal number.\n");\r\nif (recent.gui_geometry_status_pane_right != 0) {\r\nfprintf(rf, RECENT_GUI_GEOMETRY_STATUS_PANE_RIGHT ": %d\n",\r\nrecent.gui_geometry_status_pane_right);\r\n}\r\nfprintf(rf, "\n# Last used Configuration Profile.\n");\r\nfprintf(rf, RECENT_LAST_USED_PROFILE ": %s\n", get_profile_name());\r\nfprintf(rf, "\n# WLAN statistics upper pane size.\n");\r\nfprintf(rf, "# Decimal number.\n");\r\nfprintf(rf, RECENT_GUI_GEOMETRY_WLAN_STATS_PANE ": %d\n",\r\nrecent.gui_geometry_wlan_stats_pane);\r\nwrite_recent_boolean(rf, "Warn if running with elevated permissions (e.g. as root)",\r\nRECENT_KEY_PRIVS_WARN_IF_ELEVATED,\r\nrecent.privs_warn_if_elevated);\r\nwrite_recent_boolean(rf, "Warn if npf.sys isn't loaded on Windows >= 6.0",\r\nRECENT_KEY_PRIVS_WARN_IF_NO_NPF,\r\nrecent.privs_warn_if_no_npf);\r\nwindow_geom_recent_write_all(rf);\r\nfprintf(rf, "\n# Custom colors.\n");\r\nfprintf(rf, "# List of custom colors selected in Qt color picker.\n");\r\nstring_list = join_string_list(recent.custom_colors);\r\nfprintf(rf, RECENT_GUI_CUSTOM_COLORS ": %s\n", string_list);\r\ng_free(string_list);\r\nfclose(rf);\r\nreturn TRUE;\r\n}\r\ngboolean\r\nwrite_profile_recent(void)\r\n{\r\nchar *pf_dir_path;\r\nchar *rf_path;\r\nchar *string_list;\r\nFILE *rf;\r\nif (create_persconffile_dir(&pf_dir_path) == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't create directory\n\"%s\"\nfor recent file: %s.", pf_dir_path,\r\ng_strerror(errno));\r\ng_free(pf_dir_path);\r\nreturn FALSE;\r\n}\r\nrf_path = get_persconffile_path(RECENT_FILE_NAME, TRUE);\r\nif ((rf = ws_fopen(rf_path, "w")) == NULL) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't open recent file\n\"%s\": %s.", rf_path,\r\ng_strerror(errno));\r\ng_free(rf_path);\r\nreturn FALSE;\r\n}\r\ng_free(rf_path);\r\nfputs("# Recent settings file for Wireshark " VERSION ".\n"\r\n"#\n"\r\n"# This file is regenerated each time Wireshark is quit\n"\r\n"# and when changing configuration profile.\n"\r\n"# So be careful, if you want to make manual changes here.\n"\r\n"\n", rf);\r\nwrite_recent_boolean(rf, "Main Toolbar show (hide)",\r\nRECENT_KEY_MAIN_TOOLBAR_SHOW,\r\nrecent.main_toolbar_show);\r\nwrite_recent_boolean(rf, "Filter Toolbar show (hide)",\r\nRECENT_KEY_FILTER_TOOLBAR_SHOW,\r\nrecent.filter_toolbar_show);\r\nwrite_recent_boolean(rf, "Wireless Settings Toolbar show (hide)",\r\nRECENT_KEY_WIRELESS_TOOLBAR_SHOW,\r\nrecent.wireless_toolbar_show);\r\n#ifdef HAVE_AIRPCAP\r\nwrite_recent_boolean(rf, "Show (hide) old AirPcap driver warning dialog box",\r\nRECENT_KEY_DRIVER_CHECK_SHOW,\r\nrecent.airpcap_driver_check_show);\r\n#endif\r\nwrite_recent_boolean(rf, "Packet list show (hide)",\r\nRECENT_KEY_PACKET_LIST_SHOW,\r\nrecent.packet_list_show);\r\nwrite_recent_boolean(rf, "Tree view show (hide)",\r\nRECENT_KEY_TREE_VIEW_SHOW,\r\nrecent.tree_view_show);\r\nwrite_recent_boolean(rf, "Byte view show (hide)",\r\nRECENT_KEY_BYTE_VIEW_SHOW,\r\nrecent.byte_view_show);\r\nwrite_recent_boolean(rf, "Statusbar show (hide)",\r\nRECENT_KEY_STATUSBAR_SHOW,\r\nrecent.statusbar_show);\r\nwrite_recent_boolean(rf, "Packet list colorize (hide)",\r\nRECENT_KEY_PACKET_LIST_COLORIZE,\r\nrecent.packet_list_colorize);\r\nwrite_recent_enum(rf, "Timestamp display format",\r\nRECENT_GUI_TIME_FORMAT, ts_type_values,\r\nrecent.gui_time_format);\r\nwrite_recent_enum(rf, "Timestamp display precision",\r\nRECENT_GUI_TIME_PRECISION, ts_precision_values,\r\nrecent.gui_time_precision);\r\nwrite_recent_enum(rf, "Seconds display format",\r\nRECENT_GUI_SECONDS_FORMAT, ts_seconds_values,\r\nrecent.gui_seconds_format);\r\nfprintf(rf, "\n# Zoom level.\n");\r\nfprintf(rf, "# A decimal number.\n");\r\nfprintf(rf, RECENT_GUI_ZOOM_LEVEL ": %d\n",\r\nrecent.gui_zoom_level);\r\nfprintf(rf, "\n# Bytes view.\n");\r\nfprintf(rf, "# A decimal number.\n");\r\nfprintf(rf, RECENT_GUI_BYTES_VIEW ": %d\n",\r\nrecent.gui_bytes_view);\r\nfprintf(rf, "\n# Main window upper (or leftmost) pane size.\n");\r\nfprintf(rf, "# Decimal number.\n");\r\nif (recent.gui_geometry_main_upper_pane != 0) {\r\nfprintf(rf, RECENT_GUI_GEOMETRY_MAIN_UPPER_PANE ": %d\n",\r\nrecent.gui_geometry_main_upper_pane);\r\n}\r\nfprintf(rf, "\n# Main window middle pane size.\n");\r\nfprintf(rf, "# Decimal number.\n");\r\nif (recent.gui_geometry_main_lower_pane != 0) {\r\nfprintf(rf, RECENT_GUI_GEOMETRY_MAIN_LOWER_PANE ": %d\n",\r\nrecent.gui_geometry_main_lower_pane);\r\n}\r\nfprintf(rf, "\n# Packet list column pixel widths.\n");\r\nfprintf(rf, "# Each pair of strings consists of a column format and its pixel width.\n");\r\npacket_list_recent_write_all(rf);\r\nfprintf(rf, "\n# Open conversation dialog tabs.\n");\r\nfprintf(rf, "# List of conversation names, e.g. \"TCP\", \"IPv6\".\n");\r\nstring_list = join_string_list(recent.conversation_tabs);\r\nfprintf(rf, RECENT_GUI_CONVERSATION_TABS ": %s\n", string_list);\r\ng_free(string_list);\r\nfprintf(rf, "\n# Open endpoint dialog tabs.\n");\r\nfprintf(rf, "# List of endpoint names, e.g. \"TCP\", \"IPv6\".\n");\r\nstring_list = join_string_list(recent.endpoint_tabs);\r\nfprintf(rf, RECENT_GUI_ENDPOINT_TABS ": %s\n", string_list);\r\ng_free(string_list);\r\nwrite_recent_boolean(rf, "For RLC stats, whether to use RLC PDUs found inside MAC frames",\r\nRECENT_GUI_RLC_PDUS_FROM_MAC_FRAMES,\r\nrecent.gui_rlc_use_pdus_from_mac);\r\nif (get_last_open_dir() != NULL) {\r\nfprintf(rf, "\n# Last directory navigated to in File Open dialog.\n");\r\nfprintf(rf, RECENT_GUI_FILEOPEN_REMEMBERED_DIR ": %s\n", get_last_open_dir());\r\n}\r\nfclose(rf);\r\nreturn TRUE;\r\n}\r\nstatic prefs_set_pref_e\r\nread_set_recent_common_pair_static(gchar *key, const gchar *value,\r\nvoid *private_data _U_,\r\ngboolean return_range_errors _U_)\r\n{\r\nlong num;\r\nchar *p;\r\nif (strcmp(key, RECENT_GUI_GEOMETRY_MAIN_MAXIMIZED) == 0) {\r\nparse_recent_boolean(value, &recent.gui_geometry_main_maximized);\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_MAIN_X) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_geometry_main_x = (gint)num;\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_MAIN_Y) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_geometry_main_y = (gint)num;\r\n} else if (strcmp(key, RECENT_GUI_GTK_GEOMETRY_MAIN_X) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_gtk_geometry_main_x = (gint)num;\r\n} else if (strcmp(key, RECENT_GUI_GTK_GEOMETRY_MAIN_Y) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_gtk_geometry_main_y = (gint)num;\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_MAIN_WIDTH) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nif (num <= 0)\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_geometry_main_width = (gint)num;\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_MAIN_HEIGHT) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nif (num <= 0)\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_geometry_main_height = (gint)num;\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_STATUS_PANE_RIGHT) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nif (num <= 0)\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_geometry_status_pane_right = (gint)num;\r\nrecent.has_gui_geometry_status_pane = TRUE;\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_STATUS_PANE_LEFT) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nif (num <= 0)\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_geometry_status_pane_left = (gint)num;\r\nrecent.has_gui_geometry_status_pane = TRUE;\r\n} else if (strcmp(key, RECENT_LAST_USED_PROFILE) == 0) {\r\nif ((strcmp(value, DEFAULT_PROFILE) != 0) && profile_exists (value, FALSE)) {\r\nset_profile_name (value);\r\n}\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_WLAN_STATS_PANE) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nif (num <= 0)\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_geometry_wlan_stats_pane = (gint)num;\r\n} else if (strncmp(key, RECENT_GUI_GEOMETRY, sizeof(RECENT_GUI_GEOMETRY)-1) == 0) {\r\nchar *win = &key[sizeof(RECENT_GUI_GEOMETRY)-1];\r\nchar *sub_key = strchr(win, '.');\r\nif (sub_key) {\r\n*sub_key = '\0';\r\nsub_key++;\r\nwindow_geom_recent_read_pair(win, sub_key, value);\r\n}\r\n} else if (strcmp(key, RECENT_KEY_PRIVS_WARN_IF_ELEVATED) == 0) {\r\nparse_recent_boolean(value, &recent.privs_warn_if_elevated);\r\n} else if (strcmp(key, RECENT_KEY_PRIVS_WARN_IF_NO_NPF) == 0) {\r\nparse_recent_boolean(value, &recent.privs_warn_if_no_npf);\r\n} else if (strcmp(key, RECENT_GUI_CUSTOM_COLORS) == 0) {\r\nrecent.custom_colors = prefs_get_string_list(value);\r\n}\r\nreturn PREFS_SET_OK;\r\n}\r\nstatic prefs_set_pref_e\r\nread_set_recent_pair_static(gchar *key, const gchar *value,\r\nvoid *private_data _U_,\r\ngboolean return_range_errors _U_)\r\n{\r\nlong num;\r\nchar *p;\r\nGList *col_l, *col_l_elt;\r\ncol_width_data *cfmt;\r\nconst gchar *cust_format = col_format_to_string(COL_CUSTOM);\r\nint cust_format_len = (int) strlen(cust_format);\r\nif (strcmp(key, RECENT_KEY_MAIN_TOOLBAR_SHOW) == 0) {\r\nparse_recent_boolean(value, &recent.main_toolbar_show);\r\n} else if (strcmp(key, RECENT_KEY_FILTER_TOOLBAR_SHOW) == 0) {\r\nparse_recent_boolean(value, &recent.filter_toolbar_show);\r\n} else if (strcmp(key, RECENT_KEY_WIRELESS_TOOLBAR_SHOW) == 0 || (strcmp(key, "gui.airpcap_toolbar_show") == 0)) {\r\nparse_recent_boolean(value, &recent.wireless_toolbar_show);\r\n} else if (strcmp(key, RECENT_KEY_DRIVER_CHECK_SHOW) == 0) {\r\nparse_recent_boolean(value, &recent.airpcap_driver_check_show);\r\n} else if (strcmp(key, RECENT_KEY_PACKET_LIST_SHOW) == 0) {\r\nparse_recent_boolean(value, &recent.packet_list_show);\r\n} else if (strcmp(key, RECENT_KEY_TREE_VIEW_SHOW) == 0) {\r\nparse_recent_boolean(value, &recent.tree_view_show);\r\n} else if (strcmp(key, RECENT_KEY_BYTE_VIEW_SHOW) == 0) {\r\nparse_recent_boolean(value, &recent.byte_view_show);\r\n} else if (strcmp(key, RECENT_KEY_STATUSBAR_SHOW) == 0) {\r\nparse_recent_boolean(value, &recent.statusbar_show);\r\n} else if (strcmp(key, RECENT_KEY_PACKET_LIST_COLORIZE) == 0) {\r\nparse_recent_boolean(value, &recent.packet_list_colorize);\r\n} else if (strcmp(key, RECENT_GUI_TIME_FORMAT) == 0) {\r\nrecent.gui_time_format =\r\n(ts_type)str_to_val(value, ts_type_values, TS_RELATIVE);\r\n} else if (strcmp(key, RECENT_GUI_TIME_PRECISION) == 0) {\r\nrecent.gui_time_precision =\r\n(ts_precision)str_to_val(value, ts_precision_values, TS_PREC_AUTO);\r\n} else if (strcmp(key, RECENT_GUI_SECONDS_FORMAT) == 0) {\r\nrecent.gui_seconds_format =\r\n(ts_seconds_type)str_to_val(value, ts_seconds_values, TS_SECONDS_DEFAULT);\r\n} else if (strcmp(key, RECENT_GUI_ZOOM_LEVEL) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_zoom_level = (gint)num;\r\n} else if (strcmp(key, RECENT_GUI_BYTES_VIEW) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_bytes_view = (bytes_view_type)num;\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_MAIN_MAXIMIZED) == 0) {\r\nparse_recent_boolean(value, &recent.gui_geometry_main_maximized);\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_MAIN_UPPER_PANE) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nif (num <= 0)\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_geometry_main_upper_pane = (gint)num;\r\nrecent.has_gui_geometry_main_upper_pane = TRUE;\r\n} else if (strcmp(key, RECENT_GUI_GEOMETRY_MAIN_LOWER_PANE) == 0) {\r\nnum = strtol(value, &p, 0);\r\nif (p == value || *p != '\0')\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nif (num <= 0)\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nrecent.gui_geometry_main_lower_pane = (gint)num;\r\nrecent.has_gui_geometry_main_lower_pane = TRUE;\r\n} else if (strcmp(key, RECENT_GUI_CONVERSATION_TABS) == 0) {\r\nrecent.conversation_tabs = prefs_get_string_list(value);\r\n} else if (strcmp(key, RECENT_GUI_ENDPOINT_TABS) == 0) {\r\nrecent.endpoint_tabs = prefs_get_string_list(value);\r\n} else if (strcmp(key, RECENT_GUI_RLC_PDUS_FROM_MAC_FRAMES) == 0) {\r\nparse_recent_boolean(value, &recent.gui_rlc_use_pdus_from_mac);\r\n} else if (strcmp(key, RECENT_KEY_COL_WIDTH) == 0) {\r\ncol_l = prefs_get_string_list(value);\r\nif (col_l == NULL)\r\nreturn PREFS_SET_SYNTAX_ERR;\r\nif ((g_list_length(col_l) % 2) != 0) {\r\nprefs_clear_string_list(col_l);\r\nreturn PREFS_SET_SYNTAX_ERR;\r\n}\r\ncol_l_elt = g_list_first(col_l);\r\nwhile (col_l_elt) {\r\nif (strcmp((const char *)col_l_elt->data, "") == 0) {\r\nprefs_clear_string_list(col_l);\r\nreturn PREFS_SET_SYNTAX_ERR;\r\n}\r\nif (strncmp((const char *)col_l_elt->data, cust_format, cust_format_len) != 0) {\r\nif (get_column_format_from_str((const gchar *)col_l_elt->data) == -1) {\r\nprefs_clear_string_list(col_l);\r\nreturn PREFS_SET_SYNTAX_ERR;\r\n}\r\n}\r\ncol_l_elt = col_l_elt->next;\r\ncol_l_elt = col_l_elt->next;\r\n}\r\nfree_col_width_info(&recent);\r\nrecent.col_width_list = NULL;\r\ncol_l_elt = g_list_first(col_l);\r\nwhile (col_l_elt) {\r\ngchar *fmt = g_strdup((const gchar *)col_l_elt->data);\r\ncfmt = (col_width_data *) g_malloc(sizeof(col_width_data));\r\nif (strncmp(fmt, cust_format, cust_format_len) != 0) {\r\ncfmt->cfmt = get_column_format_from_str(fmt);\r\ncfmt->cfield = NULL;\r\n} else {\r\ncfmt->cfmt = COL_CUSTOM;\r\ncfmt->cfield = g_strdup(&fmt[cust_format_len+1]);\r\n}\r\ng_free (fmt);\r\nif (cfmt->cfmt == -1) {\r\ng_free(cfmt->cfield);\r\ng_free(cfmt);\r\nreturn PREFS_SET_SYNTAX_ERR;\r\n}\r\ncol_l_elt = col_l_elt->next;\r\ncfmt->width = (gint)strtol((const char *)col_l_elt->data, &p, 0);\r\nif (p == col_l_elt->data || (*p != '\0' && *p != ':')) {\r\ng_free(cfmt->cfield);\r\ng_free(cfmt);\r\nreturn PREFS_SET_SYNTAX_ERR;\r\n}\r\nif (*p == ':') {\r\ncfmt->xalign = *(++p);\r\n} else {\r\ncfmt->xalign = COLUMN_XALIGN_DEFAULT;\r\n}\r\ncol_l_elt = col_l_elt->next;\r\nrecent.col_width_list = g_list_append(recent.col_width_list, cfmt);\r\n}\r\nprefs_clear_string_list(col_l);\r\n} else if (strcmp(key, RECENT_GUI_FILEOPEN_REMEMBERED_DIR) == 0) {\r\nif (recent.gui_fileopen_remembered_dir) {\r\ng_free (recent.gui_fileopen_remembered_dir);\r\n}\r\nrecent.gui_fileopen_remembered_dir = g_strdup(value);\r\n}\r\nreturn PREFS_SET_OK;\r\n}\r\nstatic prefs_set_pref_e\r\nread_set_recent_pair_dynamic(gchar *key, const gchar *value,\r\nvoid *private_data _U_,\r\ngboolean return_range_errors _U_)\r\n{\r\nif (!g_utf8_validate(value, -1, NULL)) {\r\nreturn PREFS_SET_SYNTAX_ERR;\r\n}\r\nif (strcmp(key, RECENT_KEY_CAPTURE_FILE) == 0) {\r\nadd_menu_recent_capture_file(value);\r\n} else if (strcmp(key, RECENT_KEY_DISPLAY_FILTER) == 0) {\r\ndfilter_combo_add_recent(value);\r\n} else if (strcmp(key, RECENT_KEY_CAPTURE_FILTER) == 0) {\r\nrecent_add_cfilter(NULL, value);\r\n} else if (g_str_has_prefix(key, RECENT_KEY_CAPTURE_FILTER ".")) {\r\nrecent_add_cfilter(strrchr(key, '.') + 1, value);\r\n#ifdef HAVE_PCAP_REMOTE\r\n} else if (strcmp(key, RECENT_KEY_REMOTE_HOST) == 0) {\r\ncapture_remote_combo_add_recent(value);\r\n#endif\r\n}\r\nreturn PREFS_SET_OK;\r\n}\r\nint\r\nrecent_set_arg(char *prefarg)\r\n{\r\ngchar *p, *colonp;\r\nint ret;\r\ncolonp = strchr(prefarg, ':');\r\nif (colonp == NULL)\r\nreturn PREFS_SET_SYNTAX_ERR;\r\np = colonp;\r\n*p++ = '\0';\r\nwhile (g_ascii_isspace(*p))\r\np++;\r\nif (*p == '\0') {\r\n*colonp = ':';\r\nreturn PREFS_SET_SYNTAX_ERR;\r\n}\r\nret = read_set_recent_pair_static(prefarg, p, NULL, TRUE);\r\n*colonp = ':';\r\nreturn ret;\r\n}\r\ngboolean\r\nrecent_read_static(char **rf_path_return, int *rf_errno_return)\r\n{\r\nchar *rf_path;\r\nFILE *rf;\r\nrecent.gui_geometry_main_x = 20;\r\nrecent.gui_geometry_main_y = 20;\r\nrecent.gui_gtk_geometry_main_x = 20;\r\nrecent.gui_gtk_geometry_main_y = 20;\r\nrecent.gui_geometry_main_width = DEF_WIDTH;\r\nrecent.gui_geometry_main_height = DEF_HEIGHT;\r\nrecent.gui_geometry_main_maximized= FALSE;\r\nrecent.gui_geometry_status_pane_left = (DEF_WIDTH/3);\r\nrecent.gui_geometry_status_pane_right = (DEF_WIDTH/3);\r\nrecent.gui_geometry_wlan_stats_pane = 200;\r\nrecent.privs_warn_if_elevated = TRUE;\r\nrecent.privs_warn_if_no_npf = TRUE;\r\nrecent.col_width_list = NULL;\r\nrecent.gui_fileopen_remembered_dir = NULL;\r\nrf_path = get_persconffile_path(RECENT_COMMON_FILE_NAME, FALSE);\r\n*rf_path_return = NULL;\r\nif ((rf = ws_fopen(rf_path, "r")) != NULL) {\r\nread_prefs_file(rf_path, rf, read_set_recent_common_pair_static, NULL);\r\nfclose(rf);\r\n} else {\r\nif (errno != ENOENT) {\r\n*rf_errno_return = errno;\r\n*rf_path_return = rf_path;\r\nreturn FALSE;\r\n}\r\n}\r\ng_free(rf_path);\r\nreturn TRUE;\r\n}\r\ngboolean\r\nrecent_read_profile_static(char **rf_path_return, int *rf_errno_return)\r\n{\r\nchar *rf_path, *rf_common_path;\r\nFILE *rf;\r\nrecent.main_toolbar_show = TRUE;\r\nrecent.filter_toolbar_show = TRUE;\r\nrecent.wireless_toolbar_show = FALSE;\r\nrecent.airpcap_driver_check_show = TRUE;\r\nrecent.packet_list_show = TRUE;\r\nrecent.tree_view_show = TRUE;\r\nrecent.byte_view_show = TRUE;\r\nrecent.statusbar_show = TRUE;\r\nrecent.packet_list_colorize = TRUE;\r\nrecent.gui_time_format = TS_RELATIVE;\r\nrecent.gui_time_precision = TS_PREC_AUTO;\r\nrecent.gui_seconds_format = TS_SECONDS_DEFAULT;\r\nrecent.gui_zoom_level = 0;\r\nrecent.gui_bytes_view = BYTES_HEX;\r\nrecent.gui_geometry_main_upper_pane = 0;\r\nrecent.gui_geometry_main_lower_pane = 0;\r\nrecent.has_gui_geometry_main_upper_pane = TRUE;\r\nrecent.has_gui_geometry_main_lower_pane = TRUE;\r\nrecent.has_gui_geometry_status_pane = TRUE;\r\nif (recent.col_width_list) {\r\nfree_col_width_info(&recent);\r\n}\r\nif (recent.gui_fileopen_remembered_dir) {\r\ng_free (recent.gui_fileopen_remembered_dir);\r\nrecent.gui_fileopen_remembered_dir = NULL;\r\n}\r\nrf_path = get_persconffile_path(RECENT_FILE_NAME, TRUE);\r\n*rf_path_return = NULL;\r\nif ((rf = ws_fopen(rf_path, "r")) != NULL) {\r\nread_prefs_file(rf_path, rf, read_set_recent_pair_static, NULL);\r\nfclose(rf);\r\nrf_common_path = get_persconffile_path(RECENT_COMMON_FILE_NAME, FALSE);\r\nif (!file_exists(rf_common_path)) {\r\nrf = ws_fopen(rf_path, "r");\r\nread_prefs_file(rf_path, rf, read_set_recent_common_pair_static, NULL);\r\nfclose(rf);\r\n}\r\ng_free(rf_common_path);\r\n} else {\r\nif (errno != ENOENT) {\r\n*rf_errno_return = errno;\r\n*rf_path_return = rf_path;\r\nreturn FALSE;\r\n}\r\n}\r\ng_free(rf_path);\r\nreturn TRUE;\r\n}\r\ngboolean\r\nrecent_read_dynamic(char **rf_path_return, int *rf_errno_return)\r\n{\r\nchar *rf_path;\r\nFILE *rf;\r\nrf_path = get_persconffile_path(RECENT_COMMON_FILE_NAME, FALSE);\r\nif (!file_exists (rf_path)) {\r\ng_free (rf_path);\r\nrf_path = get_persconffile_path(RECENT_FILE_NAME, FALSE);\r\n}\r\n*rf_path_return = NULL;\r\nif ((rf = ws_fopen(rf_path, "r")) != NULL) {\r\nread_prefs_file(rf_path, rf, read_set_recent_pair_dynamic, NULL);\r\n#if 0\r\ndfilter_combo_add_empty();\r\n#endif\r\nfclose(rf);\r\n} else {\r\nif (errno != ENOENT) {\r\n*rf_errno_return = errno;\r\n*rf_path_return = rf_path;\r\nreturn FALSE;\r\n}\r\n}\r\ng_free(rf_path);\r\nreturn TRUE;\r\n}\r\ngint\r\nrecent_get_column_width(gint col)\r\n{\r\nGList *col_l;\r\ncol_width_data *col_w;\r\ngint cfmt;\r\nconst gchar *cfield = NULL;\r\ncfmt = get_column_format(col);\r\nif (cfmt == COL_CUSTOM) {\r\ncfield = get_column_custom_fields(col);\r\n}\r\ncol_l = g_list_first(recent.col_width_list);\r\nwhile (col_l) {\r\ncol_w = (col_width_data *) col_l->data;\r\nif (col_w->cfmt == cfmt) {\r\nif (cfmt != COL_CUSTOM || strcmp (cfield, col_w->cfield) == 0) {\r\nreturn col_w->width;\r\n}\r\n}\r\ncol_l = col_l->next;\r\n}\r\nreturn -1;\r\n}\r\nvoid\r\nrecent_set_column_width(gint col, gint width)\r\n{\r\nGList *col_l;\r\ncol_width_data *col_w;\r\ngint cfmt;\r\nconst gchar *cfield = NULL;\r\ngboolean found = FALSE;\r\ncfmt = get_column_format(col);\r\nif (cfmt == COL_CUSTOM) {\r\ncfield = get_column_custom_fields(col);\r\n}\r\ncol_l = g_list_first(recent.col_width_list);\r\nwhile (col_l) {\r\ncol_w = (col_width_data *) col_l->data;\r\nif (col_w->cfmt == cfmt) {\r\nif (cfmt != COL_CUSTOM || strcmp (cfield, col_w->cfield) == 0) {\r\ncol_w->width = width;\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\ncol_l = col_l->next;\r\n}\r\nif (!found) {\r\ncol_w = (col_width_data *) g_malloc(sizeof(col_width_data));\r\ncol_w->cfmt = cfmt;\r\nif (cfield) {\r\ncol_w->cfield = g_strdup(cfield);\r\n} else {\r\ncol_w->cfield = NULL;\r\n}\r\ncol_w->width = width;\r\ncol_w->xalign = COLUMN_XALIGN_DEFAULT;\r\nrecent.col_width_list = g_list_append(recent.col_width_list, col_w);\r\n}\r\n}\r\ngchar\r\nrecent_get_column_xalign(gint col)\r\n{\r\nGList *col_l;\r\ncol_width_data *col_w;\r\ngint cfmt;\r\nconst gchar *cfield = NULL;\r\ncfmt = get_column_format(col);\r\nif (cfmt == COL_CUSTOM) {\r\ncfield = get_column_custom_fields(col);\r\n}\r\ncol_l = g_list_first(recent.col_width_list);\r\nwhile (col_l) {\r\ncol_w = (col_width_data *) col_l->data;\r\nif (col_w->cfmt == cfmt) {\r\nif (cfmt != COL_CUSTOM || strcmp (cfield, col_w->cfield) == 0) {\r\nreturn col_w->xalign;\r\n}\r\n}\r\ncol_l = col_l->next;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nrecent_set_column_xalign(gint col, gchar xalign)\r\n{\r\nGList *col_l;\r\ncol_width_data *col_w;\r\ngint cfmt;\r\nconst gchar *cfield = NULL;\r\ngboolean found = FALSE;\r\ncfmt = get_column_format(col);\r\nif (cfmt == COL_CUSTOM) {\r\ncfield = get_column_custom_fields(col);\r\n}\r\ncol_l = g_list_first(recent.col_width_list);\r\nwhile (col_l) {\r\ncol_w = (col_width_data *) col_l->data;\r\nif (col_w->cfmt == cfmt) {\r\nif (cfmt != COL_CUSTOM || strcmp (cfield, col_w->cfield) == 0) {\r\ncol_w->xalign = xalign;\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\ncol_l = col_l->next;\r\n}\r\nif (!found) {\r\ncol_w = (col_width_data *) g_malloc(sizeof(col_width_data));\r\ncol_w->cfmt = cfmt;\r\nif (cfield) {\r\ncol_w->cfield = g_strdup(cfield);\r\n} else {\r\ncol_w->cfield = NULL;\r\n}\r\ncol_w->width = 40;\r\ncol_w->xalign = xalign;\r\nrecent.col_width_list = g_list_append(recent.col_width_list, col_w);\r\n}\r\n}
