static gboolean\r\nis_armagetronad_packet(tvbuff_t * tvb)\r\n{\r\ngint offset = 0;\r\nwhile (tvb_captured_length_remaining(tvb, offset) > 2) {\r\ngint data_len = tvb_get_ntohs(tvb, offset + 4) * 2;\r\n#if 0\r\nif (!try_val_to_str(tvb_get_ntohs(tvb, offset), descriptors))\r\nreturn FALSE;\r\n#endif\r\nif (!tvb_bytes_exist(tvb, offset + 6, data_len))\r\nreturn FALSE;\r\noffset += 6 + data_len;\r\n}\r\nreturn tvb_captured_length_remaining(tvb, offset) == 2;\r\n}\r\nstatic void\r\nadd_message_data(tvbuff_t * tvb, gint offset, gint data_len, proto_tree * tree)\r\n{\r\ngchar *data = NULL;\r\ngchar tmp;\r\nint i;\r\nif (!tree)\r\nreturn;\r\ndata = (gchar *)tvb_memcpy(tvb, wmem_alloc(wmem_packet_scope(), data_len + 1), offset, data_len);\r\ndata[data_len] = '\0';\r\nfor (i = 0; i < data_len; i += 2) {\r\nif (!data[i])\r\ndata[i] = ' ';\r\nif (!data[i+1])\r\ndata[i+1] = ' ';\r\ntmp = data[i];\r\ndata[i] = data[i+1];\r\ndata[i+1] = tmp;\r\n}\r\nproto_tree_add_string(tree, hf_armagetronad_data, tvb, offset,\r\ndata_len, (gchar *) data);\r\n}\r\nstatic gint\r\nadd_message(tvbuff_t * tvb, gint offset, proto_tree * tree, wmem_strbuf_t * info)\r\n{\r\nguint16 descriptor_id, message_id;\r\ngint data_len;\r\nproto_item *msg;\r\nproto_tree *msg_tree;\r\nconst gchar *descriptor;\r\ndescriptor_id = tvb_get_ntohs(tvb, offset);\r\nmessage_id = tvb_get_ntohs(tvb, offset + 2);\r\ndata_len = tvb_get_ntohs(tvb, offset + 4) * 2;\r\ndescriptor = val_to_str(descriptor_id, descriptors, "Unknown (%u)");\r\nif (descriptor_id == ACK)\r\nmsg = proto_tree_add_none_format(tree,\r\nhf_armagetronad_msg_subtree,\r\ntvb, offset, data_len + 6,\r\n"ACK %d messages",\r\ndata_len / 2);\r\nelse\r\nmsg = proto_tree_add_none_format(tree,\r\nhf_armagetronad_msg_subtree,\r\ntvb, offset, data_len + 6,\r\n"Message 0x%04x [%s]",\r\nmessage_id, descriptor);\r\nmsg_tree = proto_item_add_subtree(msg, ett_message);\r\nproto_tree_add_item(msg_tree, hf_armagetronad_descriptor_id, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\nif (info)\r\nwmem_strbuf_append_printf(info, "%s, ", descriptor);\r\nproto_tree_add_item(msg_tree, hf_armagetronad_message_id, tvb,\r\noffset + 2, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(msg_tree, hf_armagetronad_data_len, tvb,\r\noffset + 4, 2, ENC_BIG_ENDIAN);\r\nadd_message_data(tvb, offset + 6, data_len, msg_tree);\r\nreturn data_len + 6;\r\n}\r\nstatic gint\r\ndissect_armagetronad(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void * data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *armagetronad_tree;\r\nguint16 sender;\r\ngint offset = 0;\r\nwmem_strbuf_t *info;\r\ngsize new_len;\r\nif (!is_armagetronad_packet(tvb))\r\nreturn 0;\r\ninfo = wmem_strbuf_new(wmem_packet_scope(), "");\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "Armagetronad");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nti = proto_tree_add_item(tree, proto_armagetronad, tvb, 0, -1, ENC_NA);\r\narmagetronad_tree = proto_item_add_subtree(ti, ett_armagetronad);\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 2)\r\noffset += add_message(tvb, offset, armagetronad_tree, info);\r\nsender = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(ti, hf_armagetronad_sender_id, tvb, offset, 2,\r\nENC_BIG_ENDIAN);\r\nnew_len = wmem_strbuf_get_len(info) - 2;\r\nif (new_len > 0)\r\nwmem_strbuf_truncate(info, new_len);\r\nelse\r\ninfo = wmem_strbuf_new(wmem_packet_scope(), "No message");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "[%s] from 0x%04x",\r\nwmem_strbuf_get_str(info), sender);\r\nreturn offset + 2;\r\n}\r\nvoid proto_register_armagetronad(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{&hf_armagetronad_descriptor_id,\r\n{"Descriptor", "armagetronad.descriptor_id",\r\nFT_UINT16, BASE_DEC, VALS(descriptors), 0x0,\r\n"The ID of the descriptor (the command)", HFILL}\r\n},\r\n{&hf_armagetronad_message_id,\r\n{"MessageID", "armagetronad.message_id",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"The ID of the message (to ack it)", HFILL}\r\n},\r\n{&hf_armagetronad_data_len,\r\n{"DataLen", "armagetronad.data_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"The length of the data (in shorts)", HFILL}\r\n},\r\n{&hf_armagetronad_data,\r\n{"Data", "armagetronad.data",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"The actual data (array of shorts in network order)", HFILL}\r\n},\r\n{&hf_armagetronad_sender_id,\r\n{"SenderID", "armagetronad.sender_id",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"The ID of the sender (0x0000 for the server)", HFILL}\r\n},\r\n{&hf_armagetronad_msg_subtree,\r\n{"Message", "armagetronad.message",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\n"A message", HFILL}\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_armagetronad,\r\n&ett_message\r\n};\r\nproto_armagetronad =\r\nproto_register_protocol("The Armagetron Advanced OpenGL Tron clone",\r\n"Armagetronad", "armagetronad");\r\nproto_register_field_array(proto_armagetronad, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("armagetronad", dissect_armagetronad,\r\nproto_armagetronad);\r\n}\r\nvoid proto_reg_handoff_armagetronad(void)\r\n{\r\ndissector_handle_t armagetronad_handle;\r\narmagetronad_handle = find_dissector("armagetronad");\r\ndissector_add_uint("udp.port", UDP_PORT_ARMAGETRONAD, armagetronad_handle);\r\ndissector_add_uint("udp.port", UDP_PORT_MASTER, armagetronad_handle);\r\n}
