static gint get_rx_pdu_length(guint32 channel_type)\r\n{\r\ngint len = 0;\r\nswitch(channel_type) {\r\ncase TETRA_CHAN_AACH:\r\nlen = 14;\r\nbreak;\r\ncase TETRA_CHAN_SCH_F:\r\nlen = 268;\r\nbreak;\r\ncase TETRA_CHAN_SCH_D:\r\nlen = 124; ;\r\nbreak;\r\ncase TETRA_CHAN_BSCH:\r\nlen = 60;\r\nbreak;\r\ncase TETRA_CHAN_BNCH:\r\nlen = 124;\r\nbreak;\r\ncase TETRA_CHAN_TCH_F:\r\nlen = 274;\r\nbreak;\r\ncase TETRA_CHAN_TCH_H:\r\nlen = 137;\r\nbreak;\r\ncase TETRA_CHAN_TCH_2_4:\r\nlen = 144;\r\nbreak;\r\ncase TETRA_CHAN_TCH_4_8:\r\nlen = 288;\r\nbreak;\r\ncase TETRA_CHAN_STCH:\r\nlen = 124;\r\nbreak;\r\ncase TETRA_CHAN_SCH_HU:\r\nlen = 92;\r\nbreak;\r\ndefault:\r\nlen = 0;\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nstatic gint get_tx_pdu_length(guint32 channel_type)\r\n{\r\ngint len = 0;\r\nswitch(channel_type) {\r\ncase TETRA_CHAN_AACH:\r\nlen = 14;\r\nbreak;\r\ncase TETRA_CHAN_SCH_F:\r\nlen = 268;\r\nbreak;\r\ncase TETRA_CHAN_SCH_D:\r\nlen = 124;\r\nbreak;\r\ncase TETRA_CHAN_BSCH:\r\nlen = 60;\r\nbreak;\r\ncase TETRA_CHAN_BNCH:\r\nlen = 124;\r\nbreak;\r\ncase TETRA_CHAN_TCH_F:\r\nlen = 274;\r\nbreak;\r\ncase TETRA_CHAN_TCH_H:\r\nlen = 137;\r\nbreak;\r\ncase TETRA_CHAN_TCH_2_4:\r\nlen = 144;\r\nbreak;\r\ncase TETRA_CHAN_TCH_4_8:\r\nlen = 288;\r\nbreak;\r\ncase TETRA_CHAN_STCH:\r\nlen = 124;\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nvoid tetra_dissect_pdu(int channel_type, int dir, tvbuff_t *pdu, proto_tree *tree, packet_info *pinfo)\r\n{\r\nproto_item *tetra_sub_item;\r\nproto_tree *tetra_sub_tree;\r\nguint8 p;\r\ntetra_sub_item = proto_tree_add_item(tree, hf_tetra_pdu,\r\npdu, 0, tvb_captured_length(pdu), ENC_NA);\r\ntetra_sub_tree = proto_item_add_subtree(tetra_sub_item, ett_tetra);\r\nswitch(channel_type) {\r\ncase TETRA_CHAN_AACH:\r\ndissect_AACH_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase TETRA_CHAN_SCH_F:\r\np = tvb_get_guint8(pdu, 0);\r\nswitch(p >> 6) {\r\ncase 0:\r\nif (dir == TETRA_DOWNLINK)\r\ndissect_MAC_RESOURCE_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nelse\r\ndissect_MAC_DATA_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase 1:\r\nif((p >> 5) == 3) {\r\nif (dir == TETRA_DOWNLINK)\r\ndissect_MAC_END_DOWNLINK_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nelse\r\ndissect_MAC_END_UPLINK_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\n} else\r\ndissect_MAC_FRAG_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase 2:\r\ndissect_MAC_ACCESS_DEFINE_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\n}\r\nbreak;\r\ncase TETRA_CHAN_SCH_D:\r\np = tvb_get_guint8(pdu, 0);\r\nswitch(p >> 6) {\r\ncase 0:\r\ndissect_MAC_RESOURCE_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase 1:\r\nif((p >> 5) == 3)\r\ndissect_MAC_END_DOWN111_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nelse\r\ndissect_MAC_FRAG120_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase 2:\r\ndissect_MAC_ACCESS_DEFINE_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\n}\r\nbreak;\r\ncase TETRA_CHAN_SCH_HU:\r\np = tvb_get_guint8(pdu, 0);\r\nswitch(p >> 7) {\r\ncase 0:\r\ndissect_MAC_ACCESS_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase 1:\r\ndissect_MAC_END_HU_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\n}\r\nbreak;\r\ncase TETRA_CHAN_BSCH:\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "BSCH");\r\ndissect_BSCH_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase TETRA_CHAN_BNCH:\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "BNCH");\r\ndissect_BNCH_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase TETRA_CHAN_STCH:\r\np = tvb_get_guint8(pdu, 0);\r\nswitch(p >> 6) {\r\ncase 0:\r\ndissect_MAC_RESOURCE_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase 1:\r\nif((p >> 5) == 3) {\r\nif (dir == TETRA_DOWNLINK)\r\ndissect_MAC_END_DOWN111_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nelse\r\ndissect_MAC_END_UP114_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\n} else\r\ndissect_MAC_FRAG120_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\ncase 2:\r\ndissect_MAC_ACCESS_DEFINE_PDU(pdu, pinfo, tetra_sub_tree, NULL);\r\nbreak;\r\n}\r\nbreak;\r\ncase TETRA_CHAN_TCH_F:\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, NULL, "Voice");\r\nbreak;\r\n}\r\n}\r\nstatic void dissect_tetra_UNITDATA_IND(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tetra_tree, int offset)\r\n{\r\nguint32 rxreg = 0;\r\nguint32 channels = 0, i;\r\nguint32 channel_type;\r\ngint pdu_offset = 0;\r\nproto_item *tetra_sub_item;\r\nproto_tree *tetra_header_tree = NULL;\r\ntvbuff_t *payload_tvb;\r\nrxreg = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint(tetra_tree, hf_tetra_len0, tvb, offset, 4, rxreg);\r\noffset += 4;\r\nrxreg = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint(tetra_tree, hf_tetra_rvstr, tvb, offset, 4, rxreg);\r\nchannels = rxreg & 0x3;\r\ntetra_sub_item = proto_tree_add_uint( tetra_tree, hf_tetra_channels, tvb, offset, 4, channels );\r\ntetra_header_tree = proto_item_add_subtree(tetra_sub_item, ett_tetra);\r\nif (channels > 3) {\r\nexpert_add_info(pinfo, tetra_sub_item, &ei_tetra_channels_incorrect);\r\nchannels = 3;\r\n}\r\npdu_offset = offset + 4;\r\nfor(i = 0; i < channels; i++) {\r\ngint byte_len, bits_len, remaining_bits;\r\ngint hf_channel[3];\r\nhf_channel[0] = hf_tetra_rxchannel1;\r\nhf_channel[1] = hf_tetra_rxchannel2;\r\nhf_channel[2] = hf_tetra_rxchannel3;\r\nchannel_type = (rxreg >> ((i + 1) * 4) ) & 0xf;\r\nproto_tree_add_uint( tetra_header_tree, hf_channel[i], tvb, offset, 4, channel_type);\r\nproto_tree_add_boolean( tetra_header_tree, hf_tetra_crc, tvb, offset, 4, !(rxreg >> (i + 2) & 0x01));\r\nbits_len = get_rx_pdu_length(channel_type);\r\nbyte_len = bits_len >> 3;\r\nremaining_bits = bits_len % 8;\r\nif ((remaining_bits)!=0)\r\nbyte_len++;\r\npayload_tvb = tvb_new_subset_length(tvb, pdu_offset, byte_len);\r\ntetra_dissect_pdu(channel_type, TETRA_UPLINK, payload_tvb, tetra_header_tree, pinfo);\r\nif ((remaining_bits)!=0)\r\nbyte_len--;\r\npdu_offset += byte_len;\r\n}\r\n}\r\nstatic void dissect_tetra_UNITDATA_REQ(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tetra_tree, int offset)\r\n{\r\nguint32 txreg = 0;\r\nguint32 channels = 0, i;\r\nguint32 channel_type;\r\ngint pdu_offset = 0;\r\nproto_item *tetra_sub_item = NULL;\r\nproto_tree *tetra_header_tree = NULL;\r\ntvbuff_t *payload_tvb;\r\ntxreg = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_uint(tetra_tree, hf_tetra_txreg, tvb, offset, 4, txreg);\r\nchannels = (txreg & 0x3) + 1;\r\ntetra_sub_item = proto_tree_add_uint( tetra_tree, hf_tetra_channels, tvb, offset, 4, channels );\r\ntetra_header_tree = proto_item_add_subtree(tetra_sub_item, ett_tetra);\r\ntxreg >>= 2;\r\nif(channels == 2)\r\ntxreg >>= 4;\r\nif (channels > 3) {\r\nexpert_add_info(pinfo, tetra_sub_item, &ei_tetra_channels_incorrect);\r\nchannels = 3;\r\n}\r\npdu_offset = offset + 4;\r\nfor(i = 0; i < channels; i++) {\r\ngint byte_len, bits_len, remaining_bits;\r\ngint hf_channel[3];\r\nhf_channel[0] = hf_tetra_channel1;\r\nhf_channel[1] = hf_tetra_channel2;\r\nhf_channel[2] = hf_tetra_channel3;\r\nchannel_type = txreg & 0xf;\r\nproto_tree_add_uint( tetra_header_tree, hf_channel[i], tvb, offset, 4, channel_type);\r\ntxreg >>= 4;\r\nbits_len = get_tx_pdu_length(channel_type);\r\nbyte_len = bits_len >> 3;\r\nremaining_bits = bits_len % 8;\r\nif ((remaining_bits)!=0)\r\nbyte_len++;\r\npayload_tvb = tvb_new_subset_length(tvb, pdu_offset, byte_len);\r\ntetra_dissect_pdu(channel_type, TETRA_DOWNLINK, payload_tvb, tetra_header_tree, pinfo);\r\npdu_offset += byte_len;\r\n}\r\n}\r\nstatic int\r\ndissect_tetra(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *tetra_item = NULL;\r\nproto_item *tetra_sub_item = NULL;\r\nproto_tree *tetra_tree = NULL;\r\nproto_tree *tetra_header_tree = NULL;\r\nguint16 type = 0;\r\nguint8 carriernumber = -1;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PROTO_TAG_tetra);\r\ncol_clear(pinfo->cinfo,COL_INFO);\r\ntype = tvb_get_guint8(tvb, 0);\r\nif(include_carrier_number) {\r\ncarriernumber = tvb_get_guint8(tvb, 1);\r\n}\r\nswitch(type) {\r\ncase 1:\r\nif(include_carrier_number)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Tetra-UNITDATA-REQ, Carrier: %d",\r\ncarriernumber);\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Tetra-UNITDATA-REQ");\r\nbreak;\r\ncase 2:\r\nif(include_carrier_number)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Tetra-UNITDATA-IND, Carrier: %d",\r\ncarriernumber);\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Tetra-UNITDATA-IND");\r\nbreak;\r\ncase 3:\r\nif(include_carrier_number)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MAC-Timer, Carrier: %d",\r\ncarriernumber);\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "MAC-Timer");\r\nbreak;\r\ncase 127:\r\nif(include_carrier_number)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Tetra-UNITDATA-IND Done, Carrier: %d",\r\ncarriernumber);\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Tetra-UNITDATA-IND Done");\r\nbreak;\r\ncase 128:\r\nif(include_carrier_number)\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Tetra-UNITDATA-REQ Done, Carrier: %d",\r\ncarriernumber);\r\nelse\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Tetra-UNITDATA-REQ Done");\r\nbreak;\r\ndefault:\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Unknown command: %d", type);\r\nbreak;\r\n}\r\n{\r\nguint32 offset = 0;\r\nguint32 txtimer = 0;\r\nguint32 tslot = 0;\r\ntetra_item = proto_tree_add_item(tree, proto_tetra, tvb, 0, -1, ENC_NA);\r\ntetra_tree = proto_item_add_subtree(tetra_item, ett_tetra);\r\noffset ++;\r\nif(include_carrier_number) {\r\nproto_tree_add_uint(tetra_tree, hf_tetra_carriernumber, tvb, offset, 1, carriernumber);\r\noffset ++;\r\n}\r\ntetra_sub_item = proto_tree_add_item( tetra_tree, hf_tetra_header, tvb, offset, -1, ENC_NA );\r\ntetra_header_tree = proto_item_add_subtree(tetra_sub_item, ett_tetra);\r\ntxtimer = tvb_get_letohl(tvb, offset);\r\ntetra_sub_item = proto_tree_add_item(tetra_header_tree, hf_tetra_timer, tvb, offset, 4, ENC_LITTLE_ENDIAN);\r\ntslot = ((txtimer & 0x7800) >> 11);\r\nif(tslot==4)\r\ntslot = 3;\r\nif(tslot==8)\r\ntslot = 4;\r\nproto_item_append_text(tetra_sub_item, " (Multiple frame: %d, Frame: %d, Slot: %d)",\r\ntxtimer & 0x3F, (txtimer & 0x7c0) >> 6,\r\ntslot);\r\noffset += 4;\r\nswitch(type) {\r\ncase 1:\r\ncase 128:\r\ndissect_tetra_UNITDATA_REQ(tvb, pinfo, tetra_header_tree, offset);\r\nbreak;\r\ncase 2:\r\ncase 127:\r\ndissect_tetra_UNITDATA_IND(tvb, pinfo, tetra_header_tree, offset);\r\nbreak;\r\ncase 3:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_reg_handoff_tetra(void)\r\n{\r\nstatic gboolean initialized=FALSE;\r\nif (!initialized) {\r\ntetra_handle = create_dissector_handle(dissect_tetra, proto_tetra);\r\ndissector_add_uint("udp.port", global_tetra_port, tetra_handle);\r\n}\r\n}\r\nvoid proto_register_tetra (void)\r\n{\r\nmodule_t *tetra_module;\r\nexpert_module_t* expert_tetra;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_tetra,\r\n{ "Data", "tetra.data", FT_NONE, BASE_NONE, NULL, 0x0,\r\n"tetra PDU", HFILL }},\r\n{ &hf_tetra_header,\r\n{ "Registers", "tetra.header", FT_NONE, BASE_NONE, NULL, 0x0,\r\n"TETRA Registers", HFILL }},\r\n{ &hf_tetra_channels,\r\n{ "Logical Channels", "tetra.channels", FT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The amount of logical channels", HFILL }},\r\n{ &hf_tetra_channel1,\r\n{ "Channel 1", "tetra.txchannel1", FT_UINT8, BASE_DEC, VALS(channeltypenames), 0x0,\r\n"Logical channels type", HFILL }},\r\n{ &hf_tetra_channel2,\r\n{ "Channel 2", "tetra.txchannel2", FT_UINT8, BASE_DEC, VALS(channeltypenames), 0x0,\r\n"Logical channels type", HFILL }},\r\n{ &hf_tetra_channel3,\r\n{ "Channel 3", "tetra.txchannel3", FT_UINT8, BASE_DEC, VALS(channeltypenames), 0x0,\r\n"Logical channels type", HFILL }},\r\n{ &hf_tetra_txreg,\r\n{ "TxR", "tetra.txreg", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"TX Register", HFILL }},\r\n{ &hf_tetra_rvstr,\r\n{ "RvSteR", "tetra.rvster", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Receive Status Register", HFILL }},\r\n{ &hf_tetra_carriernumber,\r\n{ "Carrier Number", "tetra.carrier", FT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_tetra_rxchannel1,\r\n{ "Channel 1", "tetra.rxchannel1", FT_UINT8, BASE_DEC, VALS(recvchanneltypenames), 0x0,\r\n"Logical channels type", HFILL }},\r\n{ &hf_tetra_rxchannel2,\r\n{ "Channel 2", "tetra.rxchannel2", FT_UINT8, BASE_DEC, VALS(recvchanneltypenames), 0x0,\r\n"Logical channels type", HFILL }},\r\n{ &hf_tetra_rxchannel3,\r\n{ "Channel 3", "tetra.rxchannel3", FT_UINT8, BASE_DEC, VALS(recvchanneltypenames), 0x0,\r\n"Logical channels type", HFILL }},\r\n{ &hf_tetra_timer,\r\n{ "Timer", "tetra.timer", FT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Timer Register", HFILL }},\r\n{ &hf_tetra_crc,\r\n{ "CRC", "tetra.crc", FT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"CRC result", HFILL }},\r\n{ &hf_tetra_len0,\r\n{ "Length", "tetra.len0", FT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Length of the PDU", HFILL }},\r\n{ &hf_tetra_pdu,\r\n{ "PDU", "tetra.pdu", FT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }} ,\r\n#include "packet-tetra-hfarr.c"\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tetra,\r\n&ett_tetra_header,\r\n&ett_tetra_length,\r\n&ett_tetra_txreg,\r\n&ett_tetra_text,\r\n#include "packet-tetra-ettarr.c"\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_tetra_channels_incorrect, { "tetra.channels.incorrect", PI_MALFORMED, PI_WARN, "Channel count incorrect, must be <= 3", EXPFILL }},\r\n};\r\nproto_tetra = proto_register_protocol("TETRA Protocol", "tetra", "tetra");\r\nproto_register_field_array (proto_tetra, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\nregister_dissector("tetra", dissect_tetra, proto_tetra);\r\nexpert_tetra = expert_register_protocol(proto_tetra);\r\nexpert_register_field_array(expert_tetra, ei, array_length(ei));\r\ntetra_module = prefs_register_protocol(proto_tetra, NULL);\r\nprefs_register_bool_preference(tetra_module, "include_carrier_number",\r\n"The data include carrier numbers",\r\n"Whether the captured data include carrier number",\r\n&include_carrier_number);\r\n}
