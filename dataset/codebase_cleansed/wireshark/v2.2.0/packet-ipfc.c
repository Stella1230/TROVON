static gboolean\r\ncapture_ipfc (const guchar *pd, int offset _U_, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\r\n{\r\nif (!BYTES_ARE_IN_FRAME(0, len, 16))\r\nreturn FALSE;\r\nreturn capture_llc(pd, 16, len, cpinfo, pseudo_header);\r\n}\r\nstatic int\r\ndissect_ipfc (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *ipfc_tree;\r\nint offset = 0;\r\ntvbuff_t *next_tvb;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "IP/FC");\r\nif (tree) {\r\nti = proto_tree_add_protocol_format (tree, proto_ipfc, tvb, offset, 16,\r\n"IP Over FC Network_Header");\r\nipfc_tree = proto_item_add_subtree (ti, ett_ipfc);\r\nproto_tree_add_item (ipfc_tree, hf_ipfc_network_da, tvb, offset, 8, ENC_NA);\r\nproto_tree_add_item (ipfc_tree, hf_ipfc_network_sa, tvb, offset+8, 8, ENC_NA);\r\n}\r\nnext_tvb = tvb_new_subset_remaining (tvb, 16);\r\ncall_dissector(llc_handle, next_tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ipfc (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ipfc_network_da,\r\n{"Network DA", "ipfc.nh.da", FT_FCWWN, BASE_NONE, NULL,\r\n0x0, NULL, HFILL}},\r\n{ &hf_ipfc_network_sa,\r\n{"Network SA", "ipfc.nh.sa", FT_FCWWN, BASE_NONE, NULL,\r\n0x0, NULL, HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ipfc,\r\n};\r\nproto_ipfc = proto_register_protocol("IP Over FC", "IPFC", "ipfc");\r\nproto_register_field_array(proto_ipfc, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_ipfc (void)\r\n{\r\ndissector_handle_t ipfc_handle;\r\nipfc_handle = create_dissector_handle (dissect_ipfc, proto_ipfc);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_IP_OVER_FC, ipfc_handle);\r\nllc_handle = find_dissector_add_dependency("llc", proto_ipfc);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_IP_OVER_FC, capture_ipfc, proto_ipfc);\r\n}
