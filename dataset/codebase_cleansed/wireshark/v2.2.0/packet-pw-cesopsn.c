static\r\nvoid dissect_pw_cesopsn( tvbuff_t * tvb_original\r\n,packet_info * pinfo\r\n,proto_tree * tree\r\n,pwc_demux_type_t demux)\r\n{\r\nconst int encaps_size = 4;\r\ngint packet_size;\r\ngint payload_size;\r\ngint padding_size;\r\nint properties;\r\npacket_size = tvb_reported_length_remaining(tvb_original, 0);\r\nif (packet_size < 4)\r\n{\r\nproto_item *item;\r\nitem = proto_tree_add_item(tree, proto, tvb_original, 0, -1, ENC_NA);\r\nexpert_add_info_format(pinfo, item, &ei_packet_size_too_small,\r\n"PW packet size (%d) is too small to carry sensible information"\r\n,(int)packet_size);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, shortname);\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Malformed: PW packet is too small");\r\nreturn;\r\n}\r\nswitch (demux)\r\n{\r\ncase PWC_DEMUX_MPLS:\r\nif (dissect_try_cw_first_nibble(tvb_original, pinfo, tree))\r\n{\r\nreturn;\r\n}\r\nbreak;\r\ncase PWC_DEMUX_UDP:\r\nbreak;\r\ndefault:\r\nDISSECTOR_ASSERT_NOT_REACHED();\r\nreturn;\r\n}\r\nproperties = PWC_PACKET_PROPERTIES_T_INITIALIZER;\r\nif (0 != (tvb_get_guint8(tvb_original, 0) & 0xf0 ))\r\n{\r\nproperties |= PWC_CW_BAD_BITS03;\r\n}\r\nif (0 != (tvb_get_guint8(tvb_original, 1) & 0xc0 ))\r\n{\r\nproperties |= PWC_CW_BAD_FRAG;\r\n}\r\n{\r\nint cw_len;\r\ngint payload_size_from_packet;\r\ncw_len = tvb_get_guint8(tvb_original, 1) & 0x3f;\r\npayload_size_from_packet = packet_size - encaps_size;\r\nif (cw_len != 0)\r\n{\r\ngint payload_size_from_cw;\r\npayload_size_from_cw = cw_len - encaps_size;\r\npayload_size = payload_size_from_packet;\r\npadding_size = 0;\r\nif (payload_size_from_cw < 0)\r\n{\r\nproperties |= PWC_CW_BAD_PAYLEN_LT_0;\r\n}\r\nelse if (payload_size_from_cw > payload_size_from_packet)\r\n{\r\nproperties |= PWC_CW_BAD_PAYLEN_GT_PACKET;\r\n}\r\nelse if (payload_size_from_packet >= 64)\r\n{\r\nproperties |= PWC_CW_BAD_LEN_MUST_BE_0;\r\n}\r\nelse\r\n{\r\npayload_size = payload_size_from_cw;\r\npadding_size = payload_size_from_packet - payload_size_from_cw;\r\n}\r\n}\r\nelse\r\n{\r\npayload_size = payload_size_from_packet;\r\npadding_size = 0;\r\n}\r\n}\r\n{\r\nguint8 cw_lm;\r\ncw_lm = tvb_get_guint8(tvb_original, 0) & 0x0b ;\r\nif (NULL == try_val_to_str(cw_lm, vals_cw_lm))\r\n{\r\nproperties |= PWC_CW_SUSPECT_LM;\r\n}\r\n{\r\nguint8 l_bit, m_bits;\r\nl_bit = (cw_lm & 0x08) >> 3;\r\nm_bits = (cw_lm & 0x03) >> 0;\r\nif ((l_bit == 0 && m_bits == 0x0)\r\n||(l_bit == 0 && m_bits == 0x2) )\r\n{\r\nif ((payload_size == 0) || ((payload_size % 8) != 0))\r\n{\r\nproperties |= PWC_PAY_SIZE_BAD;\r\n}\r\n}\r\nelse if (l_bit == 1 && m_bits == 0x0)\r\n{\r\n}\r\nelse\r\n{\r\n}\r\n}\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, shortname);\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (properties & PWC_ANYOF_CW_BAD)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_INFO, "CW:Bad, ");\r\n}\r\nelse if (properties & PWC_ANYOF_CW_SUSPECT)\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, "CW:Suspect, ");\r\n}\r\nif (properties & PWC_PAY_SIZE_BAD)\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, "Payload size:Bad, ");\r\n}\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "TDM octets:%d", (int)payload_size);\r\nif (padding_size != 0)\r\n{\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", Padding:%d", (int)padding_size);\r\n}\r\n{\r\nproto_item* item;\r\nitem = proto_tree_add_item(tree, proto, tvb_original, 0, -1, ENC_NA);\r\npwc_item_append_cw(item,tvb_get_ntohl(tvb_original, 0),TRUE);\r\npwc_item_append_text_n_items(item,(int)payload_size,"octet");\r\n{\r\nproto_tree* tree2;\r\ntree2 = proto_item_add_subtree(item, ett);\r\n{\r\ntvbuff_t* tvb;\r\nproto_item* item2;\r\ntvb = tvb_new_subset_length(tvb_original, 0, PWC_SIZEOF_CW);\r\nitem2 = proto_tree_add_item(tree2, hf_cw, tvb, 0, -1, ENC_NA);\r\npwc_item_append_cw(item2,tvb_get_ntohl(tvb, 0),FALSE);\r\n{\r\nproto_tree* tree3;\r\ntree3 = proto_item_add_subtree(item, ett);\r\n{\r\nproto_item* item3;\r\nif (properties & PWC_CW_BAD_BITS03)\r\n{\r\nitem3 = proto_tree_add_item(tree3, hf_cw_bits03, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nexpert_add_info(pinfo, item3, &ei_cw_bits03);\r\n}\r\nitem3 = proto_tree_add_item(tree3, hf_cw_lm, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nif (properties & PWC_CW_SUSPECT_LM)\r\n{\r\nexpert_add_info(pinfo, item3, &ei_cw_lm);\r\n}\r\nproto_tree_add_item(tree3, hf_cw_r, tvb, 0, 1, ENC_BIG_ENDIAN);\r\nitem3 = proto_tree_add_item(tree3, hf_cw_frg, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nif (properties & PWC_CW_BAD_FRAG)\r\n{\r\nexpert_add_info(pinfo, item3, &ei_cw_frg);\r\n}\r\nitem3 = proto_tree_add_item(tree3, hf_cw_len, tvb, 1, 1, ENC_BIG_ENDIAN);\r\nif (properties & PWC_CW_BAD_PAYLEN_LT_0)\r\n{\r\nexpert_add_info_format(pinfo, item3, &ei_pref_cw_len,\r\n"Bad Length: too small, must be > %d",\r\n(int)encaps_size);\r\n}\r\nif (properties & PWC_CW_BAD_PAYLEN_GT_PACKET)\r\n{\r\nexpert_add_info_format(pinfo, item3, &ei_pref_cw_len,\r\n"Bad Length: must be <= than PSN packet size (%d)",\r\n(int)packet_size);\r\n}\r\nif (properties & PWC_CW_BAD_LEN_MUST_BE_0)\r\n{\r\nexpert_add_info_format(pinfo, item3, &ei_pref_cw_len,\r\n"Bad Length: must be 0 if CESoPSN packet size (%d) is > 64",\r\n(int)packet_size);\r\n}\r\nproto_tree_add_item(tree3, hf_cw_seq, tvb, 2, 2, ENC_BIG_ENDIAN);\r\n}\r\n}\r\n}\r\n}\r\nif (payload_size == 0)\r\n{\r\nif (properties & PWC_PAY_SIZE_BAD)\r\n{\r\nexpert_add_info_format(pinfo, item, &ei_payload_size_invalid_error,\r\n"CESoPSN payload: none found. Size of payload must be <> 0");\r\n}\r\nelse\r\n{\r\nexpert_add_info_format(pinfo, item, &ei_payload_size_invalid_undecoded,\r\n"CESoPSN payload: omitted to conserve bandwidth");\r\n}\r\n}\r\nelse\r\n{\r\nproto_tree* tree2;\r\ntree2 = proto_item_add_subtree(item, ett);\r\n{\r\nproto_item* item2;\r\ntvbuff_t* tvb;\r\ntvb = tvb_new_subset_length(tvb_original, PWC_SIZEOF_CW, payload_size);\r\nitem2 = proto_tree_add_item(tree2, hf_payload, tvb, 0, -1, ENC_NA);\r\npwc_item_append_text_n_items(item2,(int)payload_size,"octet");\r\nif (properties & PWC_PAY_SIZE_BAD)\r\n{\r\nexpert_add_info_format(pinfo, item2, &ei_payload_size_invalid_error,\r\n"CESoPSN packet payload size must be multiple of 8");\r\n}\r\ntree2 = proto_item_add_subtree(item2, ett);\r\ncall_data_dissector(tvb, pinfo, tree2);\r\nitem2 = proto_tree_add_int(tree2, hf_payload_l, tvb, 0, 0\r\n,(int)payload_size);\r\nPROTO_ITEM_SET_HIDDEN(item2);\r\n}\r\n}\r\nif (padding_size > 0)\r\n{\r\nproto_tree* tree2;\r\ntree2 = proto_item_add_subtree(item, ett);\r\n{\r\ntvbuff_t* tvb;\r\ntvb = tvb_new_subset(tvb_original, PWC_SIZEOF_CW + payload_size, padding_size, -1);\r\ncall_dissector(pw_padding_handle, tvb, pinfo, tree2);\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic\r\nint dissect_pw_cesopsn_mpls( tvbuff_t * tvb_original, packet_info * pinfo, proto_tree * tree, void* data _U_)\r\n{\r\ndissect_pw_cesopsn(tvb_original,pinfo,tree,PWC_DEMUX_MPLS);\r\nreturn tvb_captured_length(tvb_original);\r\n}\r\nstatic\r\nint dissect_pw_cesopsn_udp( tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)\r\n{\r\ndissect_pw_cesopsn(tvb,pinfo,tree,PWC_DEMUX_UDP);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_pw_cesopsn(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_cw ,{"Control Word" ,"pwcesopsn.cw"\r\n,FT_NONE ,BASE_NONE ,NULL\r\n,0 ,NULL ,HFILL }},\r\n{&hf_cw_bits03,{"Bits 0 to 3" ,"pwcesopsn.cw.bits03"\r\n,FT_UINT8 ,BASE_DEC ,NULL\r\n,0xf0 ,NULL ,HFILL }},\r\n{ &hf_cw_lm, {"L+M bits" ,"pwcesopsn.cw.lm"\r\n,FT_UINT8 ,BASE_HEX ,VALS(vals_cw_lm)\r\n,0x0b ,NULL ,HFILL }},\r\n{&hf_cw_r, {"R bit: Local CE-bound IWF" ,"pwcesopsn.cw.rbit"\r\n,FT_UINT8 ,BASE_DEC ,VALS(pwc_vals_cw_r_bit)\r\n,0x04 ,NULL ,HFILL }},\r\n{&hf_cw_frg, {"Fragmentation" ,"pwcesopsn.cw.frag"\r\n,FT_UINT8 ,BASE_DEC ,VALS(pwc_vals_cw_frag)\r\n,0xc0 ,NULL ,HFILL }},\r\n{&hf_cw_len, {"Length" ,"pwcesopsn.cw.length"\r\n,FT_UINT8 ,BASE_DEC ,NULL\r\n,0x3f ,NULL ,HFILL }},\r\n{&hf_cw_seq, {"Sequence number" ,"pwcesopsn.cw.seqno"\r\n,FT_UINT16 ,BASE_DEC ,NULL\r\n,0 ,NULL ,HFILL }},\r\n{&hf_payload ,{"TDM payload" ,"pwcesopsn.payload"\r\n,FT_BYTES ,BASE_NONE ,NULL\r\n,0 ,NULL ,HFILL }},\r\n{&hf_payload_l ,{"TDM payload length" ,"pwcesopsn.payload.len"\r\n,FT_INT32 ,BASE_DEC ,NULL\r\n,0 ,NULL ,HFILL }}\r\n};\r\nstatic gint *ett_array[] = {\r\n&ett\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_packet_size_too_small, { "pwcesopsn.packet_size_too_small", PI_MALFORMED, PI_ERROR, "PW packet size is too small to carry sensible information", EXPFILL }},\r\n{ &ei_cw_bits03, { "pwcesopsn.cw.bits03.not_zero", PI_MALFORMED, PI_ERROR, "Bits 0..3 of Control Word must be 0", EXPFILL }},\r\n{ &ei_cw_lm, { "pwcesopsn.cw.lm.reserved", PI_UNDECODED, PI_WARN, "Reserved combination of L and Modifier bits", EXPFILL }},\r\n{ &ei_cw_frg, { "pwcesopsn.cw.frag.not_allowed", PI_MALFORMED, PI_ERROR, "Fragmentation of payload is not allowed for basic CESoPSN mode", EXPFILL }},\r\n{ &ei_pref_cw_len, { "pwcesopsn.cw.length.invalid", PI_MALFORMED, PI_ERROR, "Bad Length: too small", EXPFILL }},\r\n{ &ei_payload_size_invalid_error, { "pwcesopsn.payload.size_invalid", PI_MALFORMED, PI_ERROR, "CESoPSN payload size invalid", EXPFILL }},\r\n{ &ei_payload_size_invalid_undecoded, { "pwcesopsn.payload.undecoded", PI_UNDECODED, PI_NOTE, "CESoPSN payload: omitted to conserve bandwidth", EXPFILL }},\r\n};\r\nexpert_module_t* expert_pwcesopsn;\r\nproto = proto_register_protocol(pwc_longname_pw_cesopsn, shortname, "pwcesopsn");\r\nproto_register_field_array(proto, hf, array_length(hf));\r\nproto_register_subtree_array(ett_array, array_length(ett_array));\r\nexpert_pwcesopsn = expert_register_protocol(proto);\r\nexpert_register_field_array(expert_pwcesopsn, ei, array_length(ei));\r\nregister_dissector("pw_cesopsn_udp", dissect_pw_cesopsn_udp, proto);\r\n}\r\nvoid proto_reg_handoff_pw_cesopsn(void)\r\n{\r\ndissector_handle_t pw_cesopsn_mpls_handle;\r\npw_padding_handle = find_dissector_add_dependency("pw_padding", proto);\r\npw_cesopsn_mpls_handle = create_dissector_handle( dissect_pw_cesopsn_mpls, proto );\r\ndissector_add_for_decode_as("mpls.label", pw_cesopsn_mpls_handle);\r\ndissector_add_for_decode_as("udp.port", find_dissector("pw_cesopsn_udp"));\r\nreturn;\r\n}
