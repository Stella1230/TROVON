gboolean\r\ncapture_wlancap(const guchar *pd, int offset, int len, capture_packet_info_t *cpinfo, const union wtap_pseudo_header *pseudo_header _U_)\r\n{\r\nguint32 length;\r\nif (!BYTES_ARE_IN_FRAME(offset, len, sizeof(guint32)*2))\r\nreturn FALSE;\r\nlength = pntoh32(pd+sizeof(guint32));\r\nif (!BYTES_ARE_IN_FRAME(offset, len, length))\r\nreturn FALSE;\r\noffset += length;\r\nreturn capture_ieee80211(pd, offset, len, cpinfo, pseudo_header);\r\n}\r\nstatic int\r\ndissect_wlancap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_tree *wlan_tree = NULL;\r\nproto_item *ti;\r\ntvbuff_t *next_tvb;\r\nint offset;\r\nguint32 version;\r\nguint32 length;\r\nguint32 channel;\r\nguint frequency;\r\ngint calc_channel;\r\nguint32 datarate;\r\nguint32 ssi_type;\r\ngint32 dbm;\r\nguint32 antnoise;\r\nstruct ieee_802_11_phdr phdr;\r\nmemset(&phdr, 0, sizeof(phdr));\r\nphdr.fcs_len = -1;\r\nphdr.decrypted = FALSE;\r\nphdr.datapad = FALSE;\r\nphdr.phy = PHDR_802_11_PHY_UNKNOWN;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "WLAN");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\noffset = 0;\r\nversion = tvb_get_ntohl(tvb, offset) - WLANCAP_MAGIC_COOKIE_BASE;\r\nlength = tvb_get_ntohl(tvb, offset+4);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "AVS WLAN Capture v%x, Length %d",version, length);\r\nif (version > 2) {\r\ngoto skip;\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_wlancap, tvb, 0, length, ENC_NA);\r\nwlan_tree = proto_item_add_subtree(ti, ett_wlancap);\r\nproto_tree_add_item(wlan_tree, hf_wlancap_magic, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wlan_tree, hf_wlancap_version, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n}\r\noffset+=4;\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_length, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nphdr.has_tsf_timestamp = TRUE;\r\nphdr.tsf_timestamp = tvb_get_ntoh64(tvb, offset);\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_mactime, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset+=8;\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_hosttime, tvb, offset, 8, ENC_BIG_ENDIAN);\r\noffset+=8;\r\nswitch (tvb_get_ntohl(tvb, offset)) {\r\ncase 1:\r\nphdr.phy = PHDR_802_11_PHY_11_FHSS;\r\nbreak;\r\ncase 2:\r\nphdr.phy = PHDR_802_11_PHY_11_DSSS;\r\nbreak;\r\ncase 3:\r\nphdr.phy = PHDR_802_11_PHY_11_IR;\r\nbreak;\r\ncase 4:\r\nphdr.phy = PHDR_802_11_PHY_11B;\r\nbreak;\r\ncase 5:\r\nphdr.phy = PHDR_802_11_PHY_11B;\r\nbreak;\r\ncase 6:\r\nphdr.phy = PHDR_802_11_PHY_11G;\r\nbreak;\r\ncase 7:\r\nphdr.phy = PHDR_802_11_PHY_11A;\r\nbreak;\r\ncase 8:\r\nphdr.phy = PHDR_802_11_PHY_11A;\r\nbreak;\r\ncase 9:\r\nphdr.phy = PHDR_802_11_PHY_11G;\r\nbreak;\r\n}\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_phytype, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nif (phdr.phy == PHDR_802_11_PHY_11_FHSS) {\r\nphdr.phy_info.info_11_fhss.has_hop_set = TRUE;\r\nphdr.phy_info.info_11_fhss.hop_set = tvb_get_guint8(tvb, offset);\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_hop_set, tvb, offset, 1, ENC_NA);\r\nphdr.phy_info.info_11_fhss.has_hop_pattern = TRUE;\r\nphdr.phy_info.info_11_fhss.hop_pattern = tvb_get_guint8(tvb, offset + 1);\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_hop_pattern, tvb, offset + 1, 1, ENC_NA);\r\nphdr.phy_info.info_11_fhss.has_hop_index = TRUE;\r\nphdr.phy_info.info_11_fhss.hop_index = tvb_get_guint8(tvb, offset + 2);\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_hop_index, tvb, offset + 2, 1, ENC_NA);\r\n} else {\r\nchannel = tvb_get_ntohl(tvb, offset);\r\nif (channel < 256) {\r\ncol_add_fstr(pinfo->cinfo, COL_FREQ_CHAN, "%u", channel);\r\nphdr.has_channel = TRUE;\r\nphdr.channel = channel;\r\nif (tree)\r\nproto_tree_add_uint(wlan_tree, hf_wlancap_channel, tvb, offset, 4, channel);\r\nfrequency = ieee80211_chan_to_mhz(channel, (phdr.phy != PHDR_802_11_PHY_11A));\r\nif (frequency != 0) {\r\nphdr.has_frequency = TRUE;\r\nphdr.frequency = frequency;\r\n}\r\n} else if (channel < 10000) {\r\ncol_add_fstr(pinfo->cinfo, COL_FREQ_CHAN, "%u MHz", channel);\r\nphdr.has_frequency = TRUE;\r\nphdr.frequency = channel;\r\nif (tree)\r\nproto_tree_add_uint_format(wlan_tree, hf_wlancap_channel_frequency, tvb, offset,\r\n4, channel, "Frequency: %u MHz", channel);\r\ncalc_channel = ieee80211_mhz_to_chan(channel);\r\nif (calc_channel != -1) {\r\nphdr.has_channel = TRUE;\r\nphdr.channel = calc_channel;\r\n}\r\n} else {\r\ncol_add_fstr(pinfo->cinfo, COL_FREQ_CHAN, "%u KHz", channel);\r\nif (tree)\r\nproto_tree_add_uint_format(wlan_tree, hf_wlancap_channel_frequency, tvb, offset,\r\n4, channel, "Frequency: %u KHz", channel);\r\n}\r\n}\r\noffset+=4;\r\ndatarate = tvb_get_ntohl(tvb, offset);\r\nif (datarate < 100000) {\r\ndatarate *= 100000;\r\n}\r\ncol_add_fstr(pinfo->cinfo, COL_TX_RATE, "%u.%u",\r\ndatarate / 1000000,\r\n((datarate % 1000000) > 500000) ? 5 : 0);\r\nif (datarate != 0) {\r\nif ((datarate % 500000) == 0) {\r\nphdr.has_data_rate = TRUE;\r\nphdr.data_rate = datarate / 500000;\r\n}\r\n}\r\nif (tree) {\r\nproto_tree_add_uint64_format_value(wlan_tree, hf_wlancap_data_rate, tvb, offset, 4,\r\ndatarate,\r\n"%u.%u Mb/s",\r\ndatarate/1000000,\r\n((datarate % 1000000) > 500000) ? 5 : 0);\r\n}\r\noffset+=4;\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_antenna, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_priority, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nssi_type = tvb_get_ntohl(tvb, offset);\r\nif (tree)\r\nproto_tree_add_uint(wlan_tree, hf_wlancap_ssi_type, tvb, offset, 4, ssi_type);\r\noffset+=4;\r\nswitch (ssi_type) {\r\ncase SSI_NONE:\r\ndefault:\r\nbreak;\r\ncase SSI_NORM_RSSI:\r\ncol_add_fstr(pinfo->cinfo, COL_RSSI, "%u (norm)", tvb_get_ntohl(tvb, offset));\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_normrssi_antsignal, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SSI_DBM:\r\ndbm = tvb_get_ntohl(tvb, offset);\r\nphdr.has_signal_dbm = TRUE;\r\nphdr.signal_dbm = dbm;\r\ncol_add_fstr(pinfo->cinfo, COL_RSSI, "%d dBm", dbm);\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_dbm_antsignal, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SSI_RAW_RSSI:\r\ncol_add_fstr(pinfo->cinfo, COL_RSSI, "%u (raw)", tvb_get_ntohl(tvb, offset));\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_rawrssi_antsignal, tvb, offset, 4, ENC_BIG_ENDIAN);\r\nbreak;\r\n}\r\noffset+=4;\r\nantnoise = tvb_get_ntohl(tvb, offset);\r\nif (antnoise != 0xffffffff) {\r\nswitch (ssi_type) {\r\ncase SSI_NONE:\r\ndefault:\r\nbreak;\r\ncase SSI_NORM_RSSI:\r\nif (tree)\r\nproto_tree_add_uint(wlan_tree, hf_wlancap_normrssi_antnoise, tvb, offset, 4, antnoise);\r\nbreak;\r\ncase SSI_DBM:\r\nif (antnoise != 0) {\r\nphdr.has_noise_dbm = TRUE;\r\nphdr.noise_dbm = antnoise;\r\n}\r\nif (tree)\r\nproto_tree_add_int(wlan_tree, hf_wlancap_dbm_antnoise, tvb, offset, 4, antnoise);\r\nbreak;\r\ncase SSI_RAW_RSSI:\r\nif (tree)\r\nproto_tree_add_uint(wlan_tree, hf_wlancap_rawrssi_antnoise, tvb, offset, 4, antnoise);\r\nbreak;\r\n}\r\n}\r\noffset+=4;\r\nswitch (tvb_get_ntohl(tvb, offset)) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nswitch (phdr.phy) {\r\ncase PHDR_802_11_PHY_11B:\r\nphdr.phy_info.info_11b.has_short_preamble = TRUE;\r\nphdr.phy_info.info_11b.short_preamble = TRUE;\r\nbreak;\r\ncase PHDR_802_11_PHY_11G:\r\nphdr.phy_info.info_11g.has_short_preamble = TRUE;\r\nphdr.phy_info.info_11g.short_preamble = TRUE;\r\nbreak;\r\n}\r\nbreak;\r\ncase 2:\r\nswitch (phdr.phy) {\r\ncase PHDR_802_11_PHY_11B:\r\nphdr.phy_info.info_11b.has_short_preamble = TRUE;\r\nphdr.phy_info.info_11b.short_preamble = FALSE;\r\nbreak;\r\ncase PHDR_802_11_PHY_11G:\r\nphdr.phy_info.info_11g.has_short_preamble = TRUE;\r\nphdr.phy_info.info_11g.short_preamble = FALSE;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_preamble, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_encoding, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nif (version > 1) {\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_sequence, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_drops, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_receiver_addr, tvb, offset, 6, ENC_NA);\r\noffset+=6;\r\nif (tree)\r\nproto_tree_add_item(wlan_tree, hf_wlancap_padding, tvb, offset, 2, ENC_NA);\r\n}\r\nskip:\r\noffset = length;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, tree, (void *)&phdr);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid proto_register_ieee80211_wlancap(void)\r\n{\r\nproto_wlancap = proto_register_protocol("AVS WLAN Capture header",\r\n"AVS WLANCAP", "wlancap");\r\nproto_register_field_array(proto_wlancap, hf_wlancap,\r\narray_length(hf_wlancap));\r\nregister_dissector("wlancap", dissect_wlancap, proto_wlancap);\r\nwlancap_handle = create_dissector_handle(dissect_wlancap, proto_wlancap);\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_IEEE_802_11_AVS,\r\nwlancap_handle);\r\nproto_register_subtree_array(tree_array, array_length(tree_array));\r\n}\r\nvoid proto_reg_handoff_ieee80211_wlancap(void)\r\n{\r\nieee80211_radio_handle = find_dissector_add_dependency("wlan_radio", proto_wlancap);\r\nregister_capture_dissector("wtap_encap", WTAP_ENCAP_IEEE_802_11_AVS, capture_wlancap, proto_wlancap);\r\n}
