static void\r\nadd_rr_to_tree(proto_tree *rr_tree, tvbuff_t *tvb, int offset,\r\nconst char *name, int namelen,\r\nint type, int class_val,\r\nguint ttl, gushort data_len)\r\n{\r\nproto_tree_add_string(rr_tree, hf_nbns_name, tvb, offset+1, namelen-1, name);\r\noffset += namelen;\r\nproto_tree_add_uint(rr_tree, hf_nbns_type, tvb, offset, 2, type);\r\noffset += 2;\r\nproto_tree_add_uint(rr_tree, hf_nbns_class, tvb, offset, 2, class_val);\r\noffset += 2;\r\nproto_tree_add_uint_format_value(rr_tree, hf_nbns_ttl, tvb, offset, 4, ttl, "%s",\r\nsigned_time_secs_to_str(wmem_packet_scope(), ttl));\r\noffset += 4;\r\nproto_tree_add_uint(rr_tree, hf_nbns_data_length, tvb, offset, 2, data_len);\r\n}\r\nstatic int\r\nget_nbns_name(tvbuff_t *tvb, int offset, int nbns_data_offset,\r\nchar *name_ret, int name_ret_len, int *name_type_ret)\r\n{\r\nint name_len;\r\nconst guchar *name;\r\nconst guchar *nbname;\r\nchar *nbname_buf;\r\nconst guchar *pname;\r\nchar cname, cnbname;\r\nint name_type;\r\nchar *pname_ret;\r\nsize_t idx = 0;\r\nnbname_buf = (char *)wmem_alloc(wmem_packet_scope(), NBNAME_BUF_LEN);\r\nnbname = nbname_buf;\r\nname_len = get_dns_name(tvb, offset, 0, nbns_data_offset, &name);\r\npname = &name[0];\r\npname_ret = name_ret;\r\nfor (;;) {\r\ncname = *pname;\r\nif (cname == '\0')\r\nbreak;\r\nif (cname == '.')\r\nbreak;\r\nif (cname < 'A' || cname > 'Z') {\r\nnbname = "Illegal NetBIOS name (1st character not between A and Z in first-level encoding)";\r\ngoto bad;\r\n}\r\ncname -= 'A';\r\ncnbname = cname << 4;\r\npname++;\r\ncname = *pname;\r\nif (cname == '\0' || cname == '.') {\r\nnbname = "Illegal NetBIOS name (odd number of bytes)";\r\ngoto bad;\r\n}\r\nif (cname < 'A' || cname > 'Z') {\r\nnbname = "Illegal NetBIOS name (2nd character not between A and Z in first-level encoding)";\r\ngoto bad;\r\n}\r\ncname -= 'A';\r\ncnbname |= cname;\r\npname++;\r\nif (idx < NETBIOS_NAME_LEN) {\r\nnbname_buf[idx++] = cnbname;\r\n}\r\n}\r\nif (idx != NETBIOS_NAME_LEN) {\r\ng_snprintf(nbname_buf, NBNAME_BUF_LEN, "Illegal NetBIOS name (%lu bytes long)",\r\n(unsigned long)idx);\r\ngoto bad;\r\n}\r\nname_type = process_netbios_name(nbname, name_ret, name_ret_len);\r\npname_ret += MIN(strlen(name_ret), (size_t) name_ret_len);\r\npname_ret += MIN(name_ret_len-(pname_ret-name_ret),\r\ng_snprintf(pname_ret, name_ret_len-(gulong)(pname_ret-name_ret), "<%02x>", name_type));\r\nif (cname == '.') {\r\ng_snprintf(pname_ret, name_ret_len-(gulong)(pname_ret-name_ret), "%s", pname);\r\n}\r\nif (name_type_ret != NULL)\r\n*name_type_ret = name_type;\r\nreturn name_len;\r\nbad:\r\nif (name_type_ret != NULL)\r\n*name_type_ret = -1;\r\ng_snprintf(pname_ret, name_ret_len-(gulong)(pname_ret-name_ret), "%s", nbname);\r\nreturn name_len;\r\n}\r\nstatic int\r\nget_nbns_name_type_class(tvbuff_t *tvb, int offset, int nbns_data_offset,\r\nchar *name_ret, int *name_len_ret, int *name_type_ret,\r\nint *type_ret, int *class_ret)\r\n{\r\nint name_len;\r\nint type;\r\nint rr_class;\r\nname_len = get_nbns_name(tvb, offset, nbns_data_offset, name_ret,\r\n*name_len_ret, name_type_ret);\r\noffset += name_len;\r\ntype = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nrr_class = tvb_get_ntohs(tvb, offset);\r\n*type_ret = type;\r\n*class_ret = rr_class;\r\n*name_len_ret = name_len;\r\nreturn name_len + 4;\r\n}\r\nstatic void\r\nadd_name_and_type(proto_tree *tree, tvbuff_t *tvb, int offset, int len,\r\nint hf_tag, const char *name, int name_type)\r\n{\r\nif (name_type != -1) {\r\nproto_tree_add_string_format_value(tree, hf_tag, tvb, offset, len, name, "%s (%s)",\r\nname, netbios_name_type_descr(name_type));\r\n} else {\r\nproto_tree_add_string(tree, hf_tag, tvb, offset, len, name);\r\n}\r\n}\r\nstatic int\r\ndissect_nbns_query(tvbuff_t *tvb, int offset, int nbns_data_offset,\r\ncolumn_info *cinfo, proto_tree *nbns_tree)\r\n{\r\nint len;\r\nchar *name;\r\nint name_len;\r\nint name_type;\r\nint type;\r\nint dns_class;\r\nconst char *type_name;\r\nint data_offset;\r\nint data_start;\r\nproto_tree *q_tree;\r\nname = (char *)wmem_alloc(wmem_packet_scope(), MAX_NAME_LEN);\r\ndata_start = data_offset = offset;\r\nname_len = MAX_NAME_LEN;\r\nlen = get_nbns_name_type_class(tvb, offset, nbns_data_offset, name,\r\n&name_len, &name_type, &type, &dns_class);\r\ndata_offset += len;\r\ntype_name = val_to_str_const(type, nb_type_name_vals, "Unknown");\r\nif (cinfo != NULL)\r\ncol_append_fstr(cinfo, COL_INFO, " %s %s", type_name, name);\r\nif (nbns_tree != NULL) {\r\nq_tree = proto_tree_add_subtree_format(nbns_tree, tvb, offset, len,\r\nett_nbns_qd, NULL, "%s: type %s, class %s", name, type_name,\r\nval_to_str_const(dns_class, dns_classes, "Unknown"));\r\nadd_name_and_type(q_tree, tvb, offset, name_len, hf_nbns_name, name,\r\nname_type);\r\noffset += name_len;\r\nproto_tree_add_uint(q_tree, hf_nbns_type, tvb, offset, 2, type);\r\noffset += 2;\r\nproto_tree_add_uint(q_tree, hf_nbns_class, tvb, offset, 2, dns_class);\r\n}\r\nreturn data_offset - data_start;\r\n}\r\nstatic void\r\nnbns_add_nbns_flags(column_info *cinfo, proto_tree *nbns_tree, tvbuff_t *tvb, int offset, int is_wack)\r\n{\r\nguint16 flag;\r\nstatic const int * req_flags[] = {\r\n&hf_nbns_flags_response,\r\n&hf_nbns_flags_opcode,\r\n&hf_nbns_flags_truncated,\r\n&hf_nbns_flags_recdesired,\r\n&hf_nbns_flags_broadcast,\r\nNULL\r\n};\r\nstatic const int * resp_flags[] = {\r\n&hf_nbns_flags_response,\r\n&hf_nbns_flags_opcode,\r\n&hf_nbns_flags_authoritative,\r\n&hf_nbns_flags_truncated,\r\n&hf_nbns_flags_recdesired,\r\n&hf_nbns_flags_recavail,\r\n&hf_nbns_flags_broadcast,\r\n&hf_nbns_flags_rcode,\r\nNULL\r\n};\r\nstatic const int * resp_wack_flags[] = {\r\n&hf_nbns_flags_response,\r\n&hf_nbns_flags_opcode,\r\n&hf_nbns_flags_authoritative,\r\n&hf_nbns_flags_truncated,\r\n&hf_nbns_flags_recdesired,\r\n&hf_nbns_flags_recavail,\r\n&hf_nbns_flags_broadcast,\r\nNULL\r\n};\r\nflag = tvb_get_ntohs(tvb, offset);\r\nif (cinfo) {\r\nif (flag & F_RESPONSE && !is_wack) {\r\nif ((flag & F_RCODE))\r\ncol_append_fstr(cinfo, COL_INFO, ", %s",\r\nval_to_str_const(flag & F_RCODE, rcode_vals,\r\n"Unknown error"));\r\n}\r\n}\r\nif (!nbns_tree)\r\nreturn;\r\nif (flag & F_RESPONSE) {\r\nif (!is_wack) {\r\nproto_tree_add_bitmask(nbns_tree, tvb, offset, hf_nbns_flags, ett_nbns_flags, resp_flags, ENC_BIG_ENDIAN);\r\n} else {\r\nproto_tree_add_bitmask(nbns_tree, tvb, offset, hf_nbns_flags, ett_nbns_flags, resp_wack_flags, ENC_BIG_ENDIAN);\r\n}\r\n} else {\r\nproto_tree_add_bitmask(nbns_tree, tvb, offset, hf_nbns_flags, ett_nbns_flags, req_flags, ENC_BIG_ENDIAN);\r\n}\r\n}\r\nstatic void\r\nnbns_add_nb_flags(proto_tree *rr_tree, tvbuff_t *tvb, int offset)\r\n{\r\nproto_item *tf;\r\ngushort flag;\r\nstatic const int * flags[] = {\r\n&hf_nbns_nb_flags_group,\r\n&hf_nbns_nb_flags_ont,\r\nNULL\r\n};\r\ntf = proto_tree_add_bitmask(rr_tree, tvb, offset, hf_nbns_nb_flags, ett_nbns_nb_flags, flags, ENC_BIG_ENDIAN);\r\nflag = tvb_get_ntohs(tvb, offset);\r\nproto_item_append_text(tf, " (%s, %s)",\r\nval_to_str_const(flag & NB_FLAGS_ONT, nb_flags_ont_vals, "Unknown"),\r\n(flag & NB_FLAGS_G) ? "group" : "unique");\r\n}\r\nstatic void\r\nnbns_add_name_flags(proto_tree *rr_tree, tvbuff_t *tvb, int offset)\r\n{\r\nproto_item *tf;\r\ngushort flag;\r\nstatic const int * flags[] = {\r\n&hf_nbns_name_flags_group,\r\n&hf_nbns_name_flags_ont,\r\n&hf_nbns_name_flags_drg,\r\n&hf_nbns_name_flags_cnf,\r\n&hf_nbns_name_flags_act,\r\n&hf_nbns_name_flags_prm,\r\nNULL\r\n};\r\nif (!rr_tree)\r\nreturn;\r\nflag = tvb_get_ntohs(tvb, offset);\r\ntf = proto_tree_add_bitmask(rr_tree, tvb, offset, hf_nbns_name_flags, ett_nbns_name_flags, flags, ENC_BIG_ENDIAN);\r\nproto_item_append_text(tf, " (%s, %s",\r\nval_to_str_const(flag & NAME_FLAGS_ONT, name_flags_ont_vals, "Unknown"),\r\n(flag & NAME_FLAGS_G) ? "group" : "unique");\r\nif (flag & NAME_FLAGS_DRG)\r\nproto_item_append_text(tf, ", being deregistered");\r\nif (flag & NAME_FLAGS_CNF)\r\nproto_item_append_text(tf, ", in conflict");\r\nif (flag & NAME_FLAGS_ACT)\r\nproto_item_append_text(tf, ", active");\r\nif (flag & NAME_FLAGS_PRM)\r\nproto_item_append_text(tf, ", permanent node name");\r\nproto_item_append_text(tf, ")");\r\n}\r\nstatic int\r\ndissect_nbns_answer(tvbuff_t *tvb, packet_info *pinfo, int offset, int nbns_data_offset,\r\ncolumn_info *cinfo, proto_tree *nbns_tree, int opcode)\r\n{\r\nint len;\r\nchar *name;\r\nint name_len;\r\nint name_type;\r\nint type;\r\nint dns_class;\r\nconst char *class_name;\r\nconst char *type_name;\r\nint cur_offset;\r\nguint ttl;\r\ngushort data_len;\r\nproto_tree *rr_tree = NULL;\r\nchar *name_str;\r\nguint num_names;\r\nchar *nbname;\r\ncur_offset = offset;\r\nname = (char *)wmem_alloc(wmem_packet_scope(), MAX_NAME_LEN);\r\nname_str = (char *)wmem_alloc(wmem_packet_scope(), MAX_NAME_LEN);\r\nnbname = (char *)wmem_alloc(wmem_packet_scope(), 16+4+1);\r\nname_len = MAX_NAME_LEN;\r\nlen = get_nbns_name_type_class(tvb, offset, nbns_data_offset, name,\r\n&name_len, &name_type, &type, &dns_class);\r\ncur_offset += len;\r\ntype_name = val_to_str_const(type, nb_type_name_vals, "Unknown");\r\nclass_name = val_to_str_const(dns_class, dns_classes, "Unknown");\r\nttl = tvb_get_ntohl(tvb, cur_offset);\r\ncur_offset += 4;\r\ndata_len = tvb_get_ntohs(tvb, cur_offset);\r\ncur_offset += 2;\r\nswitch (type) {\r\ncase T_NB:\r\nif (cinfo != NULL) {\r\nif (opcode != OPCODE_WACK) {\r\ncol_append_fstr(cinfo, COL_INFO, " %s %s",\r\ntype_name,\r\ntvb_ip_to_str(tvb, cur_offset+2));\r\n}\r\n}\r\nif (nbns_tree) {\r\nrr_tree = proto_tree_add_subtree_format(nbns_tree, tvb, offset,\r\n(cur_offset - offset) + data_len,\r\nett_nbns_rr, NULL, "%s: type %s, class %s",\r\nname, type_name, class_name);\r\ng_strlcat(name, " (", MAX_NAME_LEN);\r\ng_strlcat(name, netbios_name_type_descr(name_type), MAX_NAME_LEN);\r\ng_strlcat(name, ")", MAX_NAME_LEN);\r\nadd_rr_to_tree(rr_tree, tvb, offset, name,\r\nname_len, type, dns_class, ttl, data_len);\r\n}\r\nwhile (data_len > 0) {\r\nif (opcode == OPCODE_WACK) {\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nnbns_add_nbns_flags(cinfo, rr_tree, tvb, cur_offset, 1);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\n} else {\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nnbns_add_nb_flags(rr_tree, tvb, cur_offset);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 4) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_addr, tvb, cur_offset, 4, ENC_BIG_ENDIAN);\r\ncur_offset += 4;\r\ndata_len -= 4;\r\n}\r\n}\r\nbreak;\r\ncase T_NBSTAT:\r\nif (cinfo != NULL)\r\ncol_append_fstr(cinfo, COL_INFO, " %s", type_name);\r\nif (nbns_tree) {\r\nrr_tree = proto_tree_add_subtree_format(nbns_tree, tvb, offset,\r\n(cur_offset - offset) + data_len,\r\nett_nbns_rr, NULL, "%s: type %s, class %s",\r\nname, type_name, class_name);\r\nadd_rr_to_tree(rr_tree, tvb, offset, name,\r\nname_len, type, dns_class, ttl, data_len);\r\n}\r\nif (data_len < 1) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nnum_names = tvb_get_guint8(tvb, cur_offset);\r\nproto_tree_add_item(rr_tree, hf_nbns_number_of_names, tvb, cur_offset, 1, ENC_BIG_ENDIAN);\r\ncur_offset += 1;\r\nwhile (num_names != 0) {\r\nif (data_len < NETBIOS_NAME_LEN) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\ngoto out;\r\n}\r\nif (rr_tree) {\r\ntvb_memcpy(tvb, (guint8 *)nbname, cur_offset,\r\nNETBIOS_NAME_LEN);\r\nname_type = process_netbios_name(nbname,\r\nname_str, name_len);\r\nproto_tree_add_string_format_value(rr_tree, hf_nbns_netbios_name, tvb, cur_offset,\r\nNETBIOS_NAME_LEN, name_str, "%s<%02x> (%s)",\r\nname_str, name_type,\r\nnetbios_name_type_descr(name_type));\r\n}\r\ncur_offset += NETBIOS_NAME_LEN;\r\ndata_len -= NETBIOS_NAME_LEN;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\ngoto out;\r\n}\r\nif (rr_tree) {\r\nnbns_add_name_flags(rr_tree, tvb, cur_offset);\r\n}\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nnum_names--;\r\n}\r\nif (data_len < 6) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_unit_id, tvb, cur_offset, 6, ENC_NA);\r\ncur_offset += 6;\r\ndata_len -= 6;\r\nif (data_len < 1) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_jumpers, tvb, cur_offset, 1, ENC_BIG_ENDIAN);\r\ncur_offset += 1;\r\ndata_len -= 1;\r\nif (data_len < 1) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_test_result, tvb, cur_offset, 1, ENC_BIG_ENDIAN);\r\ncur_offset += 1;\r\ndata_len -= 1;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_version_number, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_period_of_statistics, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_crcs, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_alignment_errors, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_collisions, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_send_aborts, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 4) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_good_sends, tvb, cur_offset, 4, ENC_BIG_ENDIAN);\r\ncur_offset += 4;\r\ndata_len -= 4;\r\nif (data_len < 4) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_good_receives, tvb, cur_offset, 4, ENC_BIG_ENDIAN);\r\ncur_offset += 4;\r\ndata_len -= 4;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_retransmits, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_no_resource_conditions, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_command_blocks, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_num_pending_sessions, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_max_num_pending_sessions, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_max_total_sessions_possible, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\ndata_len -= 2;\r\nif (data_len < 2) {\r\nproto_tree_add_expert(rr_tree, pinfo, &ei_nbns_incomplete_entry, tvb, cur_offset, data_len);\r\nbreak;\r\n}\r\nproto_tree_add_item(rr_tree, hf_nbns_session_data_packet_size, tvb, cur_offset, 2, ENC_BIG_ENDIAN);\r\ncur_offset += 2;\r\nout:\r\nbreak;\r\ndefault:\r\nif (cinfo != NULL)\r\ncol_append_fstr(cinfo, COL_INFO, " %s", type_name);\r\nif (nbns_tree) {\r\nrr_tree = proto_tree_add_subtree_format(nbns_tree, tvb, offset,\r\n(cur_offset - offset) + data_len,\r\nett_nbns_rr, NULL, "%s: type %s, class %s",\r\nname, type_name, class_name);\r\nadd_rr_to_tree(rr_tree, tvb, offset, name,\r\nname_len, type, dns_class, ttl, data_len);\r\nproto_tree_add_item(rr_tree, hf_nbns_data, tvb, cur_offset, data_len, ENC_NA);\r\n}\r\ncur_offset += data_len;\r\nbreak;\r\n}\r\nreturn cur_offset - offset;\r\n}\r\nstatic int\r\ndissect_query_records(tvbuff_t *tvb, int cur_off, int nbns_data_offset,\r\nint count, column_info *cinfo, proto_tree *nbns_tree)\r\n{\r\nint start_off, add_off;\r\nproto_tree *qatree;\r\nproto_item *ti;\r\nstart_off = cur_off;\r\nqatree = proto_tree_add_subtree(nbns_tree, tvb, start_off, -1, ett_nbns_qry, &ti, "Queries");\r\nwhile (count-- > 0) {\r\nadd_off = dissect_nbns_query(tvb, cur_off, nbns_data_offset,\r\ncinfo, qatree);\r\ncur_off += add_off;\r\n}\r\nproto_item_set_len(ti, cur_off - start_off);\r\nreturn cur_off - start_off;\r\n}\r\nstatic int\r\ndissect_answer_records(tvbuff_t *tvb, packet_info *pinfo, int cur_off, int nbns_data_offset,\r\nint count, column_info *cinfo, proto_tree *nbns_tree,\r\nint opcode, const char *name)\r\n{\r\nint start_off, add_off;\r\nproto_tree *qatree;\r\nproto_item *ti;\r\nstart_off = cur_off;\r\nqatree = proto_tree_add_subtree(nbns_tree, tvb, start_off, -1, ett_nbns_ans, &ti, name);\r\nwhile (count-- > 0) {\r\nadd_off = dissect_nbns_answer(tvb, pinfo, cur_off, nbns_data_offset,\r\ncinfo, qatree, opcode);\r\ncur_off += add_off;\r\n}\r\nproto_item_set_len(ti, cur_off - start_off);\r\nreturn cur_off - start_off;\r\n}\r\nstatic int\r\ndissect_nbns(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nint nbns_data_offset;\r\nproto_tree *nbns_tree = NULL;\r\nproto_item *ti;\r\nguint16 id, flags, opcode, quest, ans, auth, add;\r\nint cur_off;\r\nnbns_data_offset = offset;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NBNS");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nid = tvb_get_ntohs(tvb, offset + NBNS_ID);\r\nflags = tvb_get_ntohs(tvb, offset + NBNS_FLAGS);\r\nopcode = (guint16) ((flags & F_OPCODE) >> OPCODE_SHIFT);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s%s",\r\nval_to_str(opcode, opcode_vals, "Unknown operation (%u)"),\r\n(flags & F_RESPONSE) ? " response" : "");\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_nbns, tvb, offset, -1,\r\nENC_NA);\r\nnbns_tree = proto_item_add_subtree(ti, ett_nbns);\r\nproto_tree_add_uint(nbns_tree, hf_nbns_transaction_id, tvb,\r\noffset + NBNS_ID, 2, id);\r\n}\r\nnbns_add_nbns_flags(pinfo->cinfo, nbns_tree, tvb, offset + NBNS_FLAGS, 0);\r\nquest = tvb_get_ntohs(tvb, offset + NBNS_QUEST);\r\nif (tree) {\r\nproto_tree_add_uint(nbns_tree, hf_nbns_count_questions, tvb,\r\noffset + NBNS_QUEST, 2, quest);\r\n}\r\nans = tvb_get_ntohs(tvb, offset + NBNS_ANS);\r\nif (tree) {\r\nproto_tree_add_uint(nbns_tree, hf_nbns_count_answers, tvb,\r\noffset + NBNS_ANS, 2, ans);\r\n}\r\nauth = tvb_get_ntohs(tvb, offset + NBNS_AUTH);\r\nif (tree) {\r\nproto_tree_add_uint(nbns_tree, hf_nbns_count_auth_rr, tvb,\r\noffset + NBNS_AUTH, 2, auth);\r\n}\r\nadd = tvb_get_ntohs(tvb, offset + NBNS_ADD);\r\nif (tree) {\r\nproto_tree_add_uint(nbns_tree, hf_nbns_count_add_rr, tvb,\r\noffset + NBNS_ADD, 2, add);\r\n}\r\ncur_off = offset + NBNS_HDRLEN;\r\nif (quest > 0) {\r\ncur_off += dissect_query_records(tvb, cur_off,\r\nnbns_data_offset, quest,\r\n(!(flags & F_RESPONSE) ? pinfo->cinfo : NULL), nbns_tree);\r\n}\r\nif (ans > 0) {\r\ncur_off += dissect_answer_records(tvb, pinfo, cur_off,\r\nnbns_data_offset, ans,\r\n((flags & F_RESPONSE) ? pinfo->cinfo : NULL), nbns_tree,\r\nopcode, "Answers");\r\n}\r\nif (auth > 0)\r\ncur_off += dissect_answer_records(tvb, pinfo, cur_off,\r\nnbns_data_offset,\r\nauth, NULL, nbns_tree, opcode,\r\n"Authoritative nameservers");\r\nif (add > 0)\r\ndissect_answer_records(tvb, pinfo, cur_off,\r\nnbns_data_offset,\r\nadd, NULL, nbns_tree, opcode,\r\n"Additional records");\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_netbios_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nheur_dtbl_entry_t *hdtbl_entry;\r\nif (!dissector_try_heuristic(netbios_heur_subdissector_list,\r\ntvb, pinfo, tree, &hdtbl_entry, NULL))\r\ncall_data_dissector(tvb, pinfo, tree);\r\n}\r\nstatic int\r\ndissect_nbdgm(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nint offset = 0;\r\nproto_tree *nbdgm_tree = NULL;\r\nproto_item *ti = NULL;\r\nstruct nbdgm_header header;\r\nint flags;\r\ntvbuff_t *next_tvb;\r\nchar *name;\r\nint name_type;\r\nint len;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NBDS");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_nbdgm, tvb, offset, -1,\r\nENC_NA);\r\nnbdgm_tree = proto_item_add_subtree(ti, ett_nbdgm);\r\n}\r\nheader.msg_type = tvb_get_guint8(tvb, offset);\r\nif (tree) {\r\nproto_tree_add_uint(nbdgm_tree, hf_nbdgm_type, tvb,\r\noffset, 1,\r\nheader.msg_type);\r\n}\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(header.msg_type, nbds_msgtype_vals,\r\n"Unknown message type (0x%02X)"));\r\nflags = tvb_get_guint8(tvb, offset+1);\r\nheader.flags.more = flags & 1;\r\nheader.flags.first = (flags & 2) >> 1;\r\nheader.flags.node_type = (flags & 12) >> 2;\r\nif (tree) {\r\nproto_tree_add_boolean(nbdgm_tree, hf_nbdgm_fragment, tvb,\r\noffset+1, 1,\r\nheader.flags.more);\r\nproto_tree_add_boolean(nbdgm_tree, hf_nbdgm_first, tvb,\r\noffset+1, 1,\r\nheader.flags.first);\r\nproto_tree_add_uint(nbdgm_tree, hf_nbdgm_node_type, tvb,\r\noffset+1, 1,\r\nheader.flags.node_type);\r\n}\r\nheader.dgm_id = tvb_get_ntohs(tvb, offset+2);\r\nif (tree) {\r\nproto_tree_add_uint(nbdgm_tree, hf_nbdgm_datagram_id, tvb,\r\noffset+2, 2, header.dgm_id);\r\n}\r\nheader.src_ip = tvb_get_ipv4( tvb, offset+4);\r\nif (tree) {\r\nproto_tree_add_ipv4(nbdgm_tree, hf_nbdgm_src_ip, tvb,\r\noffset+4, 4, header.src_ip);\r\n}\r\nheader.src_port = tvb_get_ntohs(tvb, offset+8);\r\nif (tree) {\r\nproto_tree_add_uint(nbdgm_tree, hf_nbdgm_src_port, tvb,\r\noffset+8, 2, header.src_port);\r\n}\r\noffset += 10;\r\nswitch (header.msg_type) {\r\ncase NBDS_DIRECT_UNIQUE:\r\ncase NBDS_DIRECT_GROUP:\r\ncase NBDS_BROADCAST:\r\nif (tree) {\r\nheader.dgm_length = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint_format_value(nbdgm_tree, hf_nbdgm_datagram_length,\r\ntvb, offset, 2, header.dgm_length,\r\n"%u bytes", header.dgm_length);\r\n}\r\noffset += 2;\r\nif (tree) {\r\nheader.pkt_offset = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_uint_format_value(nbdgm_tree, hf_nbdgm_packet_offset,\r\ntvb, offset, 2, header.pkt_offset,\r\n"%u bytes", header.pkt_offset);\r\n}\r\noffset += 2;\r\nname = (char *)wmem_alloc(wmem_packet_scope(), MAX_NAME_LEN);\r\nlen = get_nbns_name(tvb, offset, offset, name, MAX_NAME_LEN, &name_type);\r\nif (tree) {\r\nadd_name_and_type(nbdgm_tree, tvb, offset, len,\r\nhf_nbdgm_source_name, name, name_type);\r\n}\r\noffset += len;\r\nlen = get_nbns_name(tvb, offset, offset, name, MAX_NAME_LEN, &name_type);\r\nif (tree) {\r\nadd_name_and_type(nbdgm_tree, tvb, offset, len,\r\nhf_nbdgm_destination_name, name, name_type);\r\n}\r\noffset += len;\r\nif (ti != NULL)\r\nproto_item_set_len(ti, offset);\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ndissect_netbios_payload(next_tvb, pinfo, tree);\r\nbreak;\r\ncase NBDS_ERROR:\r\nif (tree) {\r\nproto_tree_add_item(nbdgm_tree, hf_nbdgm_error_code, tvb, offset,\r\n1, ENC_BIG_ENDIAN);\r\n}\r\noffset += 1;\r\nif (ti != NULL)\r\nproto_item_set_len(ti, offset);\r\nbreak;\r\ncase NBDS_QUERY_REQUEST:\r\ncase NBDS_POS_QUERY_RESPONSE:\r\ncase NBDS_NEG_QUERY_RESPONSE:\r\nname = (char *)wmem_alloc(wmem_packet_scope(), MAX_NAME_LEN);\r\nlen = get_nbns_name(tvb, offset, offset, name, MAX_NAME_LEN, &name_type);\r\nif (tree) {\r\nadd_name_and_type(nbdgm_tree, tvb, offset, len,\r\nhf_nbdgm_destination_name, name, name_type);\r\n}\r\noffset += len;\r\nif (ti != NULL)\r\nproto_item_set_len(ti, offset);\r\nbreak;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic void\r\ndissect_nbss_packet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nint is_cifs)\r\n{\r\nint offset = 0;\r\nproto_tree *nbss_tree = NULL;\r\nproto_item *ti = NULL;\r\nguint8 msg_type;\r\nguint8 flags;\r\nguint32 length;\r\nint len;\r\nchar *name;\r\nint name_type;\r\nguint8 error_code;\r\ntvbuff_t *next_tvb;\r\nconst char *saved_proto;\r\nstatic const int * nbss_flags[] = {\r\n&hf_nbss_flags_e,\r\nNULL\r\n};\r\nname = (char *)wmem_alloc(wmem_packet_scope(), MAX_NAME_LEN);\r\nmsg_type = tvb_get_guint8(tvb, offset);\r\nti = proto_tree_add_item(tree, proto_nbss, tvb, offset, -1, ENC_NA);\r\nnbss_tree = proto_item_add_subtree(ti, ett_nbss);\r\nproto_tree_add_item(nbss_tree, hf_nbss_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nif (is_cifs) {\r\nproto_tree_add_item(nbss_tree, hf_nbss_cifs_length, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\n} else {\r\nflags = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_bitmask(nbss_tree, tvb, offset, hf_nbss_flags, ett_nbss_flags, nbss_flags, ENC_BIG_ENDIAN);\r\nlength = tvb_get_ntohs(tvb, offset + 1);\r\nif (flags & NBSS_FLAGS_E)\r\nlength += 0x10000;\r\nproto_tree_add_uint(nbss_tree, hf_nbss_length, tvb, offset, 3, length);\r\noffset += 3;\r\n}\r\nswitch (msg_type) {\r\ncase SESSION_REQUEST:\r\nlen = get_nbns_name(tvb, offset, offset, name, MAX_NAME_LEN, &name_type);\r\nif (tree)\r\nadd_name_and_type(nbss_tree, tvb, offset, len,\r\nhf_nbss_called_name, name, name_type);\r\noffset += len;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", to %s ", name);\r\nlen = get_nbns_name(tvb, offset, offset, name, MAX_NAME_LEN, &name_type);\r\nif (tree)\r\nadd_name_and_type(nbss_tree, tvb, offset, len,\r\nhf_nbss_calling_name, name, name_type);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "from %s", name);\r\nbreak;\r\ncase NEGATIVE_SESSION_RESPONSE:\r\nerror_code = tvb_get_guint8(tvb, offset);\r\nif (tree)\r\nproto_tree_add_uint(nbss_tree, hf_nbss_error_code, tvb, offset, 1,\r\nerror_code);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, ", %s",\r\nval_to_str(error_code, nbss_error_codes, "Unknown (%x)"));\r\nbreak;\r\ncase RETARGET_SESSION_RESPONSE:\r\nif (tree)\r\nproto_tree_add_item(nbss_tree, hf_nbss_retarget_ip_address,\r\ntvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (tree)\r\nproto_tree_add_item(nbss_tree, hf_nbss_retarget_port,\r\ntvb, offset, 2, ENC_BIG_ENDIAN);\r\nbreak;\r\ncase SESSION_MESSAGE:\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nsaved_proto = pinfo->current_proto;\r\nTRY {\r\ndissect_netbios_payload(next_tvb, pinfo, tree);\r\n}\r\nCATCH_NONFATAL_ERRORS {\r\nshow_exception(tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);\r\npinfo->current_proto = saved_proto;\r\n}\r\nENDTRY;\r\nbreak;\r\n}\r\n}\r\nstatic int\r\ndissect_continuation_packet(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_tree *nbss_tree;\r\nproto_item *ti;\r\ncol_set_str(pinfo->cinfo, COL_INFO, "NBSS Continuation Message");\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_nbss, tvb, 0, -1, ENC_NA);\r\nnbss_tree = proto_item_add_subtree(ti, ett_nbss);\r\nproto_tree_add_item(nbss_tree, hf_nbss_continuation_data, tvb, 0, -1, ENC_NA);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_nbss(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\r\n{\r\nstruct tcpinfo *tcpinfo;\r\nint offset = 0;\r\nguint length_remaining;\r\nguint plen;\r\nint max_data;\r\nguint8 msg_type;\r\nguint8 flags;\r\nguint32 length;\r\ngboolean is_cifs;\r\ntvbuff_t *next_tvb;\r\nif (data == NULL)\r\nreturn 0;\r\ntcpinfo = (struct tcpinfo *)data;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "NBSS");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nmax_data = tvb_captured_length(tvb);\r\nmsg_type = tvb_get_guint8(tvb, offset);\r\nif (pinfo->match_uint == TCP_PORT_CIFS) {\r\nis_cifs = TRUE;\r\n} else {\r\nis_cifs = FALSE;\r\n}\r\nif (!tcpinfo->is_reassembled) {\r\nif (max_data < 4) {\r\nreturn dissect_continuation_packet(tvb, pinfo, tree);\r\n}\r\nif (tvb_captured_length_remaining(tvb, offset) >= 8\r\n&& tvb_get_guint8(tvb,offset+0) == SESSION_MESSAGE\r\n&& tvb_get_guint8(tvb,offset+5) == 'S'\r\n&& tvb_get_guint8(tvb,offset+6) == 'M'\r\n&& tvb_get_guint8(tvb,offset+7) == 'B') {\r\nis_cifs = TRUE;\r\n} else {\r\nis_cifs = FALSE;\r\n}\r\nif (is_cifs) {\r\nflags = 0;\r\nlength = tvb_get_ntoh24(tvb, offset + 1);\r\n} else {\r\nflags = tvb_get_guint8(tvb, offset + 1);\r\nlength = tvb_get_ntohs(tvb, offset + 2);\r\nif (flags & NBSS_FLAGS_E)\r\nlength += 0x10000;\r\n}\r\nif ((flags & (~NBSS_FLAGS_E)) != 0) {\r\nreturn dissect_continuation_packet(tvb, pinfo, tree);\r\n}\r\nswitch (msg_type) {\r\ncase SESSION_MESSAGE:\r\nif (length == 0)\r\nreturn dissect_continuation_packet(tvb, pinfo, tree);\r\nbreak;\r\ncase SESSION_REQUEST:\r\nif (length < 2 || length > 256)\r\nreturn dissect_continuation_packet(tvb, pinfo, tree);\r\nbreak;\r\ncase POSITIVE_SESSION_RESPONSE:\r\nif (length != 0)\r\nreturn dissect_continuation_packet(tvb, pinfo, tree);\r\nbreak;\r\ncase NEGATIVE_SESSION_RESPONSE:\r\nif (length != 1)\r\nreturn dissect_continuation_packet(tvb, pinfo, tree);\r\nbreak;\r\ncase RETARGET_SESSION_RESPONSE:\r\nif (length != 6)\r\nreturn dissect_continuation_packet(tvb, pinfo, tree);\r\nbreak;\r\ncase SESSION_KEEP_ALIVE:\r\nif (length != 0)\r\nreturn dissect_continuation_packet(tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\nreturn dissect_continuation_packet(tvb, pinfo, tree);\r\n}\r\n}\r\ncol_add_str(pinfo->cinfo, COL_INFO,\r\nval_to_str(msg_type, message_types, "Unknown (%02x)"));\r\nwhile ((length_remaining = tvb_reported_length_remaining(tvb, offset)) > 0) {\r\nif (nbss_desegment && pinfo->can_desegment) {\r\nif (length_remaining < 4) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn tvb_captured_length(tvb);\r\n}\r\n}\r\nif (is_cifs) {\r\nlength = tvb_get_ntoh24(tvb, offset + 1);\r\n} else {\r\nflags = tvb_get_guint8(tvb, offset + 1);\r\nlength = tvb_get_ntohs(tvb, offset + 2);\r\nif (flags & NBSS_FLAGS_E)\r\nlength += 65536;\r\n}\r\nplen = length + 4;\r\nif(!pinfo->fd->flags.visited){\r\nif( ((int)plen>tvb_reported_length_remaining(tvb, offset))\r\n&&(tvb_captured_length_remaining(tvb, offset) >= 8)\r\n&&(tvb_get_guint8(tvb,offset+5) == 'S')\r\n&&(tvb_get_guint8(tvb,offset+6) == 'M')\r\n&&(tvb_get_guint8(tvb,offset+7) == 'B') ){\r\npinfo->want_pdu_tracking = 2;\r\npinfo->bytes_until_next_pdu = (length+4)-tvb_reported_length_remaining(tvb, offset);\r\n}\r\n}\r\nif (nbss_desegment && pinfo->can_desegment) {\r\nif (length_remaining < plen) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = plen - length_remaining;\r\nreturn tvb_captured_length(tvb);\r\n}\r\n}\r\nlength = length_remaining;\r\nif (length > plen)\r\nlength = plen;\r\nnext_tvb = tvb_new_subset(tvb, offset, length, plen);\r\ndissect_nbss_packet(next_tvb, pinfo, tree, is_cifs);\r\noffset += plen;\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_nbt(void)\r\n{\r\nstatic hf_register_info hf_nbns[] = {\r\n{ &hf_nbns_flags,\r\n{ "Flags", "nbns.flags",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbns_flags_response,\r\n{ "Response", "nbns.flags.response",\r\nFT_BOOLEAN, 16, TFS(&tfs_flags_response), F_RESPONSE,\r\n"Is the message a response?", HFILL }},\r\n{ &hf_nbns_flags_opcode,\r\n{ "Opcode", "nbns.flags.opcode",\r\nFT_UINT16, BASE_DEC, VALS(opcode_vals), F_OPCODE,\r\n"Operation code", HFILL }},\r\n{ &hf_nbns_flags_authoritative,\r\n{ "Authoritative", "nbns.flags.authoritative",\r\nFT_BOOLEAN, 16, TFS(&tfs_flags_authoritative), F_AUTHORITATIVE,\r\n"Is the server is an authority for the domain?", HFILL }},\r\n{ &hf_nbns_flags_truncated,\r\n{ "Truncated", "nbns.flags.truncated",\r\nFT_BOOLEAN, 16, TFS(&tfs_flags_truncated), F_TRUNCATED,\r\n"Is the message truncated?", HFILL }},\r\n{ &hf_nbns_flags_recdesired,\r\n{ "Recursion desired", "nbns.flags.recdesired",\r\nFT_BOOLEAN, 16, TFS(&tfs_flags_recdesired), F_RECDESIRED,\r\n"Do query recursively?", HFILL }},\r\n{ &hf_nbns_flags_recavail,\r\n{ "Recursion available", "nbns.flags.recavail",\r\nFT_BOOLEAN, 16, TFS(&tfs_flags_recavail), F_RECAVAIL,\r\n"Can the server do recursive queries?", HFILL }},\r\n{ &hf_nbns_flags_broadcast,\r\n{ "Broadcast", "nbns.flags.broadcast",\r\nFT_BOOLEAN, 16, TFS(&tfs_flags_broadcast), F_BROADCAST,\r\n"Is this a broadcast packet?", HFILL }},\r\n{ &hf_nbns_flags_rcode,\r\n{ "Reply code", "nbns.flags.rcode",\r\nFT_UINT16, BASE_DEC, VALS(rcode_vals), F_RCODE,\r\nNULL, HFILL }},\r\n{ &hf_nbns_transaction_id,\r\n{ "Transaction ID", "nbns.id",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Identification of transaction", HFILL }},\r\n{ &hf_nbns_count_questions,\r\n{ "Questions", "nbns.count.queries",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Number of queries in packet", HFILL }},\r\n{ &hf_nbns_count_answers,\r\n{ "Answer RRs", "nbns.count.answers",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Number of answers in packet", HFILL }},\r\n{ &hf_nbns_count_auth_rr,\r\n{ "Authority RRs", "nbns.count.auth_rr",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Number of authoritative records in packet", HFILL }},\r\n{ &hf_nbns_count_add_rr,\r\n{ "Additional RRs", "nbns.count.add_rr",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Number of additional records in packet", HFILL }},\r\n{ &hf_nbns_name_flags,\r\n{ "Name flags", "nbns.name_flags",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbns_name_flags_group,\r\n{ "Name type", "nbns.name_flags.group",\r\nFT_BOOLEAN, 16, TFS(&tfs_group_unique_name), NAME_FLAGS_G,\r\nNULL, HFILL }},\r\n{ &hf_nbns_name_flags_ont,\r\n{ "ONT", "nbns.name_flags.ont",\r\nFT_UINT16, BASE_DEC, VALS(name_flags_ont_vals), NAME_FLAGS_ONT,\r\nNULL, HFILL }},\r\n{ &hf_nbns_name_flags_drg,\r\n{ "Name is being deregistered", "nbns.name_flags.drg",\r\nFT_BOOLEAN, 16, TFS(&tfs_yes_no), NAME_FLAGS_DRG,\r\nNULL, HFILL }},\r\n{ &hf_nbns_name_flags_cnf,\r\n{ "Name is in conflict", "nbns.name_flags.cnf",\r\nFT_BOOLEAN, 16, TFS(&tfs_yes_no), NAME_FLAGS_CNF,\r\nNULL, HFILL }},\r\n{ &hf_nbns_name_flags_act,\r\n{ "Name is active", "nbns.name_flags.act",\r\nFT_BOOLEAN, 16, TFS(&tfs_yes_no), NAME_FLAGS_ACT,\r\nNULL, HFILL }},\r\n{ &hf_nbns_name_flags_prm,\r\n{ "Permanent node name", "nbns.name_flags.prm",\r\nFT_BOOLEAN, 16, TFS(&tfs_yes_no), NAME_FLAGS_PRM,\r\nNULL, HFILL }},\r\n{ &hf_nbns_nb_flags,\r\n{ "Name flags", "nbns.nb_flags",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbns_nb_flags_group,\r\n{ "Name type", "nbns.nb_flags.group",\r\nFT_BOOLEAN, 16, TFS(&tfs_group_unique_name), NB_FLAGS_G,\r\nNULL, HFILL }},\r\n{ &hf_nbns_nb_flags_ont,\r\n{ "ONT", "nbns.nb_flags.ont",\r\nFT_UINT16, BASE_DEC, VALS(nb_flags_ont_vals), NB_FLAGS_ONT,\r\nNULL, HFILL }},\r\n{ &hf_nbns_type,\r\n{ "Type", "nbns.type",\r\nFT_UINT16, BASE_DEC, VALS(nb_type_name_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbns_class,\r\n{ "Class", "nbns.class",\r\nFT_UINT16, BASE_DEC, VALS(dns_classes), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbns_name,\r\n{ "Name", "nbns.name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbns_addr, { "Addr", "nbns.addr", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_number_of_names, { "Number of names", "nbns.number_of_names", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_unit_id, { "Unit ID", "nbns.unit_id", FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_jumpers, { "Jumpers", "nbns.jumpers", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_test_result, { "Test result", "nbns.test_result", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_version_number, { "Version number", "nbns.version_number", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_period_of_statistics, { "Period of statistics", "nbns.period_of_statistics", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_crcs, { "Number of CRCs", "nbns.num_crcs", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_alignment_errors, { "Number of alignment errors", "nbns.num_alignment_errors", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_collisions, { "Number of collisions", "nbns.num_collisions", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_send_aborts, { "Number of send aborts", "nbns.num_send_aborts", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_good_sends, { "Number of good sends", "nbns.num_good_sends", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_good_receives, { "Number of good receives", "nbns.num_good_receives", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_retransmits, { "Number of retransmits", "nbns.numretransmits", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_no_resource_conditions, { "Number of no resource conditions", "nbns.num_no_resource_conditions", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_command_blocks, { "Number of command blocks", "nbns.numcommand_blocks", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_num_pending_sessions, { "Number of pending sessions", "nbns.numpending_sessions", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_max_num_pending_sessions, { "Max number of pending sessions", "nbns.max_num_pending_sessions", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_max_total_sessions_possible, { "Max total sessions possible", "nbns.max_total_sessions_possible", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_session_data_packet_size, { "Session data packet size", "nbns.session_data_packet_size", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_data, { "Data", "nbns.data", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_netbios_name, { "Name", "nbns.netbios_name", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_ttl, { "Time to live", "nbns.ttl", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{ &hf_nbns_data_length, { "Data length", "nbns.data_length", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n};\r\nstatic hf_register_info hf_nbdgm[] = {\r\n{ &hf_nbdgm_type,\r\n{ "Message Type", "nbdgm.type",\r\nFT_UINT8, BASE_DEC, VALS(nbds_msgtype_vals), 0x0,\r\n"NBDGM message type", HFILL }},\r\n{ &hf_nbdgm_fragment,\r\n{ "More fragments follow", "nbdgm.next",\r\nFT_BOOLEAN, BASE_NONE, TFS(&tfs_yes_no), 0x0,\r\n"TRUE if more fragments follow", HFILL }},\r\n{ &hf_nbdgm_first,\r\n{ "This is first fragment", "nbdgm.first",\r\nFT_BOOLEAN, BASE_NONE, TFS(&tfs_yes_no), 0x0,\r\n"TRUE if first fragment", HFILL }},\r\n{ &hf_nbdgm_node_type,\r\n{ "Node Type", "nbdgm.node_type",\r\nFT_UINT8, BASE_DEC, VALS(node_type_vals), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbdgm_datagram_id,\r\n{ "Datagram ID", "nbdgm.dgram_id",\r\nFT_UINT16, BASE_HEX, NULL, 0x0,\r\n"Datagram identifier", HFILL }},\r\n{ &hf_nbdgm_src_ip,\r\n{ "Source IP", "nbdgm.src.ip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"Source IPv4 address", HFILL }},\r\n{ &hf_nbdgm_src_port,\r\n{ "Source Port", "nbdgm.src.port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbdgm_datagram_length,\r\n{ "Datagram length", "nbdgm.dgram_len",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbdgm_packet_offset,\r\n{ "Packet offset", "nbdgm.pkt_offset",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbdgm_error_code,\r\n{ "Error code", "nbdgm.error_code",\r\nFT_UINT8, BASE_HEX, VALS(nbds_error_codes), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbdgm_source_name,\r\n{ "Source name", "nbdgm.source_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbdgm_destination_name,\r\n{ "Destination name", "nbdgm.destination_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic hf_register_info hf_nbss[] = {\r\n{ &hf_nbss_type,\r\n{ "Message Type", "nbss.type",\r\nFT_UINT8, BASE_HEX, VALS(message_types), 0x0,\r\n"NBSS message type", HFILL }},\r\n{ &hf_nbss_flags,\r\n{ "Flags", "nbss.flags",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\n"NBSS message flags", HFILL }},\r\n{ &hf_nbss_flags_e,\r\n{ "Extend", "nbss.flags.e",\r\nFT_BOOLEAN, 8, TFS(&tfs_nbss_flags_e), NBSS_FLAGS_E,\r\nNULL, HFILL }},\r\n{ &hf_nbss_length,\r\n{ "Length", "nbss.length",\r\nFT_UINT24, BASE_DEC, NULL, 0x0,\r\n"Length of trailer (payload) following this field in bytes", HFILL }},\r\n{ &hf_nbss_cifs_length,\r\n{ "Length", "nbss.length",\r\nFT_UINT24, BASE_DEC, NULL, 0x0,\r\n"Length trailer (payload) following this field in bytes", HFILL }},\r\n{ &hf_nbss_error_code,\r\n{ "Error code", "nbss.error_code",\r\nFT_UINT8, BASE_HEX, VALS(nbss_error_codes), 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbss_retarget_ip_address,\r\n{ "Retarget IP address", "nbss.retarget_ip_address",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbss_retarget_port,\r\n{ "Retarget port", "nbss.retarget_port",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbss_continuation_data,\r\n{ "Continuation data", "nbss.continuation_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbss_called_name,\r\n{ "Called name", "nbss.called_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_nbss_calling_name,\r\n{ "Calling name", "nbss.calling_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_nbns,\r\n&ett_nbns_qd,\r\n&ett_nbns_flags,\r\n&ett_nbns_nb_flags,\r\n&ett_nbns_name_flags,\r\n&ett_nbns_rr,\r\n&ett_nbns_qry,\r\n&ett_nbns_ans,\r\n&ett_nbdgm,\r\n&ett_nbss,\r\n&ett_nbss_flags,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_nbns_incomplete_entry, { "nbns.incomplete_entry", PI_MALFORMED, PI_ERROR, "incomplete entry", EXPFILL }},\r\n};\r\nmodule_t *nbss_module;\r\nexpert_module_t* expert_nbns;\r\nproto_nbns = proto_register_protocol("NetBIOS Name Service", "NBNS", "nbns");\r\nproto_register_field_array(proto_nbns, hf_nbns, array_length(hf_nbns));\r\nexpert_nbns = expert_register_protocol(proto_nbns);\r\nexpert_register_field_array(expert_nbns, ei, array_length(ei));\r\nproto_nbdgm = proto_register_protocol("NetBIOS Datagram Service",\r\n"NBDS", "nbdgm");\r\nproto_register_field_array(proto_nbdgm, hf_nbdgm, array_length(hf_nbdgm));\r\nproto_nbss = proto_register_protocol("NetBIOS Session Service",\r\n"NBSS", "nbss");\r\nproto_register_field_array(proto_nbss, hf_nbss, array_length(hf_nbss));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nnbss_module = prefs_register_protocol(proto_nbss, NULL);\r\nprefs_register_bool_preference(nbss_module, "desegment_nbss_commands",\r\n"Reassemble NBSS packets spanning multiple TCP segments",\r\n"Whether the NBSS dissector should reassemble packets spanning multiple TCP segments."\r\n" To use this option, you must also enable"\r\n" \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&nbss_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_nbt(void)\r\n{\r\ndissector_handle_t nbns_handle, nbdgm_handle, nbss_handle;\r\nnbns_handle = create_dissector_handle(dissect_nbns, proto_nbns);\r\ndissector_add_uint("udp.port", UDP_PORT_NBNS, nbns_handle);\r\nnbdgm_handle = create_dissector_handle(dissect_nbdgm, proto_nbdgm);\r\ndissector_add_uint("udp.port", UDP_PORT_NBDGM, nbdgm_handle);\r\nnbss_handle = create_dissector_handle(dissect_nbss, proto_nbss);\r\ndissector_add_uint("tcp.port", TCP_PORT_NBSS, nbss_handle);\r\ndissector_add_uint("tcp.port", TCP_PORT_CIFS, nbss_handle);\r\nnetbios_heur_subdissector_list = find_heur_dissector_list("netbios");\r\n}
