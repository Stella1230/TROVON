int\r\nis_tpkt(tvbuff_t *tvb, int min_len)\r\n{\r\nguint16 pkt_len;\r\nif (!proto_is_protocol_enabled(proto_tpkt_ptr))\r\nreturn -1;\r\nif (tvb_captured_length(tvb) < 4)\r\nreturn -1;\r\nif (!(tvb_get_guint8(tvb, 0) == 3 && tvb_get_guint8(tvb, 1) == 0))\r\nreturn -1;\r\npkt_len = tvb_get_ntohs(tvb, 2);\r\nif (pkt_len < 4 + min_len)\r\nreturn -1;\r\nreturn pkt_len;\r\n}\r\nguint16\r\nis_asciitpkt(tvbuff_t *tvb)\r\n{\r\nguint16 count;\r\nif (!proto_is_protocol_enabled(proto_tpkt_ptr))\r\nreturn -1;\r\nif (!tvb_bytes_exist(tvb, 0, 8))\r\nreturn -1;\r\nfor (count = 0; count <=7 ; count ++)\r\n{\r\nif(!g_ascii_isalnum(tvb_get_guint8(tvb,count)))\r\n{\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\nparseLengthText ( guint8* pTpktData )\r\n{\r\nint value = 0;\r\nconst guint8 * pData = pTpktData;\r\nint bitvalue = 0, count1 = 3;\r\nint count;\r\nfor (count = 0; count <= 3; count++)\r\n{\r\nif (('0' <= *(pData + count)) && (*(pData + count) <= '9'))\r\nbitvalue = *(pData + count) - 48;\r\nelse if (('a' <= *(pData + count)) && (*(pData + count) <= 'f' ))\r\nbitvalue = *(pData + count) - 87;\r\nelse if (('A' <= *(pData + count)) && (*(pData + count) <= 'F' ))\r\nbitvalue = *(pData + count) - 55;\r\nvalue += bitvalue << (4*count1);\r\ncount1--;\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nparseVersionText ( guint8* pTpktData )\r\n{\r\nint value = 0;\r\nguint8 * pData = pTpktData;\r\nint bitvalue = 0, count1 = 1;\r\nint count;\r\nfor (count = 0; count <= 1; count++)\r\n{\r\nif (('0' <= *(pData + count)) && (*(pData + count) <= '9'))\r\nbitvalue = *(pData + count) - 48;\r\nelse if (('a' <= *(pData + count)) && (*(pData + count) <= 'f' ))\r\nbitvalue = *(pData + count) - 87;\r\nelse if (('A' <= *(pData + count)) && (*(pData + count) <= 'F' ))\r\nbitvalue = *(pData + count) - 55;\r\nvalue += bitvalue << (4*count1);\r\ncount1--;\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nparseReservedText ( guint8* pTpktData )\r\n{\r\nint value = 0;\r\nguint8 * pData = pTpktData;\r\nint bitvalue = 0, count1 = 1;\r\nint count;\r\nfor (count = 0; count <= 1; count++)\r\n{\r\nif (('0' <= *(pData + count)) && (*(pData + count) <= '9'))\r\nbitvalue = *(pData + count) - 48;\r\nelse if (('a' <= *(pData + count)) && (*(pData + count) <= 'f' ))\r\nbitvalue = *(pData + count) - 87;\r\nelse if (('A' <= *(pData + count)) && (*(pData + count) <= 'F' ))\r\nbitvalue = *(pData + count) - 55;\r\nvalue += bitvalue << (4*count1);\r\ncount1--;\r\n}\r\nreturn value;\r\n}\r\nvoid\r\ndissect_asciitpkt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ndissector_handle_t subdissector_handle)\r\n{\r\nproto_item *ti = NULL;\r\nproto_tree *tpkt_tree = NULL;\r\nvolatile int offset = 0;\r\nint length_remaining;\r\nint data_len;\r\nvolatile int mgcp_packet_len = 0;\r\nint mgcp_version = 0;\r\nint mgcp_reserved = 0;\r\nvolatile int length;\r\ntvbuff_t *volatile next_tvb;\r\nconst char *saved_proto;\r\nguint8 string[4];\r\nif (tpkt_desegment)\r\ncol_set_str(pinfo->cinfo, COL_INFO, "");\r\nwhile (tvb_reported_length_remaining(tvb, offset) != 0) {\r\nif (tvb_get_guint8(tvb, offset) != 48) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TPKT");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Continuation");\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_tpkt, tvb,\r\noffset, -1, ENC_NA);\r\ntpkt_tree = proto_item_add_subtree(ti, ett_tpkt);\r\nproto_tree_add_item(tpkt_tree, hf_tpkt_continuation_data, tvb, offset, -1, ENC_NA);\r\n}\r\nreturn;\r\n}\r\nlength_remaining = tvb_captured_length_remaining(tvb, offset);\r\ntvb_memcpy(tvb, (guint8 *)string, offset, 2);\r\nmgcp_version = parseVersionText(string);\r\ntvb_memcpy(tvb, (guint8 *)string, offset +2, 2);\r\nmgcp_reserved = parseReservedText(string);\r\ntvb_memcpy(tvb, (guint8 *)string, offset + 4, 4);\r\nmgcp_packet_len = parseLengthText(string);\r\ndata_len = mgcp_packet_len;\r\nsaved_proto = pinfo->current_proto;\r\npinfo->current_proto = "TPKT";\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TPKT");\r\nif (!tpkt_desegment && !pinfo->fragmented) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"TPKT Data length = %u", data_len);\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_tpkt, tvb,\r\noffset, 8, ENC_NA);\r\ntpkt_tree = proto_item_add_subtree(ti, ett_tpkt);\r\nproto_item_set_text(ti, "TPKT");\r\nproto_tree_add_uint(tpkt_tree, hf_tpkt_version, tvb,\r\noffset, 2, mgcp_version);\r\nproto_tree_add_uint(tpkt_tree, hf_tpkt_reserved, tvb,\r\noffset + 2, 2, mgcp_reserved);\r\nproto_tree_add_uint(tpkt_tree, hf_tpkt_length, tvb,\r\noffset + 4, 4, mgcp_packet_len);\r\n}\r\npinfo->current_proto = saved_proto;\r\noffset += TEXT_LAYER_LENGTH;\r\nlength = length_remaining - TEXT_LAYER_LENGTH;\r\nif (length > data_len)\r\nlength = data_len;\r\nnext_tvb = tvb_new_subset(tvb, offset,length, data_len);\r\nTRY {\r\ncall_dissector(subdissector_handle, next_tvb, pinfo,\r\ntree);\r\n}\r\nCATCH_NONFATAL_ERRORS {\r\nshow_exception(tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);\r\n}\r\nENDTRY;\r\noffset += data_len;\r\n}\r\n}\r\nvoid\r\ndissect_tpkt_encap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\ngboolean desegment, dissector_handle_t subdissector_handle)\r\n{\r\nproto_item *ti = NULL;\r\nproto_tree *tpkt_tree = NULL;\r\nvolatile int offset = 0;\r\nint length_remaining;\r\nint data_len;\r\nvolatile int length;\r\ntvbuff_t *volatile next_tvb;\r\nconst char *saved_proto;\r\nif (desegment)\r\ncol_set_str(pinfo->cinfo, COL_INFO, "");\r\nwhile (tvb_reported_length_remaining(tvb, offset) != 0) {\r\nif (tvb_get_guint8(tvb, offset) != 3) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TPKT");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Continuation");\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_tpkt, tvb,\r\noffset, -1, ENC_NA);\r\ntpkt_tree = proto_item_add_subtree(ti, ett_tpkt);\r\nproto_tree_add_item(tpkt_tree, hf_tpkt_continuation_data, tvb, offset, -1, ENC_NA);\r\n}\r\nreturn;\r\n}\r\nlength_remaining = tvb_captured_length_remaining(tvb, offset);\r\nif (desegment && pinfo->can_desegment) {\r\nif (length_remaining < 4) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\r\nreturn;\r\n}\r\n}\r\ndata_len = tvb_get_ntohs(tvb, offset + 2);\r\nif (desegment && pinfo->can_desegment) {\r\nif (length_remaining < data_len) {\r\npinfo->desegment_offset = offset;\r\npinfo->desegment_len =\r\ndata_len - length_remaining;\r\nreturn;\r\n}\r\n}\r\nsaved_proto = pinfo->current_proto;\r\npinfo->current_proto = "TPKT";\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TPKT");\r\nif (!desegment && !pinfo->fragmented) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"TPKT Data length = %u", data_len);\r\n}\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_tpkt, tvb,\r\noffset, 4, ENC_NA);\r\ntpkt_tree = proto_item_add_subtree(ti, ett_tpkt);\r\nproto_item_set_text(ti, "TPKT");\r\nproto_tree_add_item(tpkt_tree, hf_tpkt_version, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, ", Version: 3");\r\nproto_tree_add_item(tpkt_tree, hf_tpkt_reserved, tvb,\r\noffset + 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(tpkt_tree, hf_tpkt_length, tvb,\r\noffset + 2, 2, data_len);\r\nproto_item_append_text(ti, ", Length: %u", data_len);\r\n}\r\npinfo->current_proto = saved_proto;\r\noffset += 4;\r\ndata_len -= 4;\r\nlength = length_remaining - 4;\r\nif (length > data_len)\r\nlength = data_len;\r\nnext_tvb = tvb_new_subset(tvb, offset, length, data_len);\r\nTRY {\r\ncall_dissector(subdissector_handle, next_tvb, pinfo,\r\ntree);\r\n}\r\nCATCH_NONFATAL_ERRORS {\r\nshow_exception(tvb, pinfo, tree, EXCEPT_CODE, GET_MESSAGE);\r\n}\r\nENDTRY;\r\noffset += length;\r\n}\r\n}\r\nstatic int\r\ndissect_tpkt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ndissect_tpkt_encap(tvb, pinfo, tree, tpkt_desegment, osi_tp_handle);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_tpkt(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{\r\n&hf_tpkt_version,\r\n{\r\n"Version",\r\n"tpkt.version",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\n"Version, only version 3 is defined", HFILL\r\n}\r\n},\r\n{\r\n&hf_tpkt_reserved,\r\n{\r\n"Reserved",\r\n"tpkt.reserved",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\n"Reserved, should be 0", HFILL\r\n}\r\n},\r\n{\r\n&hf_tpkt_length,\r\n{\r\n"Length",\r\n"tpkt.length",\r\nFT_UINT16,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\n"Length of data unit, including this header", HFILL\r\n}\r\n},\r\n{\r\n&hf_tpkt_continuation_data,\r\n{\r\n"Continuation data",\r\n"tpkt.continuation_data",\r\nFT_BYTES,\r\nBASE_NONE,\r\nNULL,\r\n0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n};\r\nstatic gint *ett[] =\r\n{\r\n&ett_tpkt,\r\n};\r\nmodule_t *tpkt_module;\r\nproto_tpkt = proto_register_protocol("TPKT - ISO on TCP - RFC1006", "TPKT", "tpkt");\r\nproto_tpkt_ptr = find_protocol_by_id(proto_tpkt);\r\nproto_register_field_array(proto_tpkt, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("tpkt", dissect_tpkt, proto_tpkt);\r\ntpkt_module = prefs_register_protocol(proto_tpkt, NULL);\r\nprefs_register_bool_preference(tpkt_module, "desegment",\r\n"Reassemble TPKT messages spanning multiple TCP segments",\r\n"Whether the TPKT dissector should reassemble messages spanning multiple TCP segments. "\r\n"To use this option, you must also enable \"Allow subdissectors to reassemble TCP streams\" in the TCP protocol settings.",\r\n&tpkt_desegment);\r\n}\r\nvoid\r\nproto_reg_handoff_tpkt(void)\r\n{\r\ndissector_handle_t tpkt_handle;\r\nosi_tp_handle = find_dissector("ositp");\r\ntpkt_handle = find_dissector("tpkt");\r\ndissector_add_uint("tcp.port", TCP_PORT_TPKT, tpkt_handle);\r\n}
