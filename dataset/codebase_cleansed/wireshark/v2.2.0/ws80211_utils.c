static inline struct nl_handle *nl_socket_alloc(void)\r\n{\r\nreturn nl_handle_alloc();\r\n}\r\nstatic inline void nl_socket_free(struct nl_sock *h)\r\n{\r\nnl_handle_destroy(h);\r\n}\r\nint ws80211_init(void)\r\n{\r\nint err;\r\n#ifdef HAVE_NL80211_SPLIT_WIPHY_DUMP\r\nint features = 0;\r\n#endif\r\nstruct nl80211_state *state = &nl_state;\r\nstate->nl_sock = nl_socket_alloc();\r\nif (!state->nl_sock) {\r\nfprintf(stderr, "Failed to allocate netlink socket.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (genl_connect(state->nl_sock)) {\r\nfprintf(stderr, "Failed to connect to generic netlink.\n");\r\nerr = -ENOLINK;\r\ngoto out_handle_destroy;\r\n}\r\nstate->nl80211_id = genl_ctrl_resolve(state->nl_sock, "nl80211");\r\nif (state->nl80211_id < 0) {\r\nfprintf(stderr, "nl80211 not found.\n");\r\nerr = -ENOENT;\r\ngoto out_handle_destroy;\r\n}\r\n#ifdef HAVE_NL80211_SPLIT_WIPHY_DUMP\r\nws80211_get_protocol_features(&features);\r\nif (features & NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP)\r\nstate->have_split_wiphy = TRUE;\r\n#endif\r\nreturn 0;\r\nout_handle_destroy:\r\nnl_socket_free(state->nl_sock);\r\nstate->nl_sock = 0;\r\nreturn err;\r\n}\r\nstatic int error_handler(struct sockaddr_nl *nla _U_, struct nlmsgerr *err,\r\nvoid *arg)\r\n{\r\nint *ret = (int *)arg;\r\n*ret = err->error;\r\nreturn NL_STOP;\r\n}\r\nstatic int finish_handler(struct nl_msg *msg _U_, void *arg)\r\n{\r\nint *ret = (int *)arg;\r\n*ret = 0;\r\nreturn NL_SKIP;\r\n}\r\nstatic int ack_handler(struct nl_msg *msg _U_, void *arg)\r\n{\r\nint *ret = (int *)arg;\r\n*ret = 0;\r\nreturn NL_STOP;\r\n}\r\nstatic int nl80211_do_cmd(struct nl_msg *msg, struct nl_cb *cb)\r\n{\r\nvolatile int err;\r\nif (!nl_state.nl_sock)\r\nreturn -ENOLINK;\r\nerr = nl_send_auto_complete(nl_state.nl_sock, msg);\r\nif (err < 0)\r\ngoto out;\r\nerr = 1;\r\nnl_cb_err(cb, NL_CB_CUSTOM, error_handler, (void *)&err);\r\nnl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, (void *)&err);\r\nnl_cb_set(cb, NL_CB_ACK, NL_CB_CUSTOM, ack_handler, (void *)&err);\r\nwhile (err > 0)\r\nnl_recvmsgs(nl_state.nl_sock, cb);\r\nout:\r\nnl_cb_put(cb);\r\nreturn err;\r\n}\r\nstatic struct ws80211_interface *\r\nget_interface_by_name(GArray *interfaces,\r\nchar* ifname)\r\n{\r\nunsigned int i;\r\nstruct ws80211_interface *iface;\r\nfor (i = 0; i < interfaces->len; i++) {\r\niface = g_array_index(interfaces, struct ws80211_interface *, i);\r\nif (!strcmp(iface->ifname, ifname))\r\nreturn iface;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int get_features_handler(struct nl_msg *msg, void *arg)\r\n{\r\nint *feat = (int*) arg;\r\nstruct nlattr *tb_msg[NL80211_ATTR_MAX + 1];\r\nstruct genlmsghdr *gnlh = (struct genlmsghdr *)nlmsg_data(nlmsg_hdr(msg));\r\nnla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),\r\ngenlmsg_attrlen(gnlh, 0), NULL);\r\nif (tb_msg[NL80211_ATTR_PROTOCOL_FEATURES])\r\n*feat = nla_get_u32(tb_msg[NL80211_ATTR_PROTOCOL_FEATURES]);\r\nreturn NL_SKIP;\r\n}\r\nstatic int ws80211_get_protocol_features(int* features)\r\n{\r\nstruct nl_msg *msg;\r\nstruct nl_cb *cb;\r\nint ret;\r\nmsg = nlmsg_alloc();\r\nif (!msg) {\r\nfprintf(stderr, "failed to allocate netlink message\n");\r\nreturn 2;\r\n}\r\ncb = nl_cb_alloc(NL_CB_DEFAULT);\r\ngenlmsg_put(msg, 0, 0, nl_state.nl80211_id, 0, 0,\r\nNL80211_CMD_GET_PROTOCOL_FEATURES, 0);\r\nnl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, get_features_handler, features);\r\nret = nl80211_do_cmd(msg, cb);\r\nnlmsg_free(msg);\r\nreturn ret;\r\n}\r\nstatic void parse_band_ht_capa(struct ws80211_interface *iface,\r\nstruct nlattr *tb)\r\n{\r\ngboolean ht40;\r\nif (!tb) return;\r\niface->channel_types |= 1 << WS80211_CHAN_HT20;\r\nht40 = !!(nla_get_u16(tb) & 0x02);\r\nif (ht40) {\r\niface->channel_types |= 1 << WS80211_CHAN_HT40MINUS;\r\niface->channel_types |= 1 << WS80211_CHAN_HT40PLUS;\r\n}\r\n}\r\nstatic void parse_band_vht_capa(struct ws80211_interface *iface,\r\nstruct nlattr *tb)\r\n{\r\nguint32 chan_capa;\r\nif (!tb) return;\r\nchan_capa = (nla_get_u32(tb) >> 2) & 3;\r\nif (chan_capa == 1) {\r\niface->channel_types |= 1 << WS80211_CHAN_VHT160;\r\n}\r\nif (chan_capa == 2) {\r\niface->channel_types |= 1 << WS80211_CHAN_VHT160;\r\niface->channel_types |= 1 << WS80211_CHAN_VHT80P80;\r\n}\r\niface->channel_types |= 1 << WS80211_CHAN_VHT80;\r\n}\r\nstatic void parse_supported_iftypes(struct ws80211_interface *iface,\r\nstruct nlattr *tb)\r\n{\r\nstruct nlattr *nl_mode;\r\nint rem_mode;\r\nif (!tb) return;\r\nnla_for_each_nested(nl_mode, tb, rem_mode) {\r\nif (nla_type(nl_mode) == NL80211_IFTYPE_MONITOR)\r\niface->cap_monitor = 1;\r\n}\r\n}\r\nstatic void parse_band_freqs(struct ws80211_interface *iface,\r\nstruct nlattr *tb)\r\n{\r\nstruct nlattr *nl_freq;\r\nstruct nlattr *tb_freq[NL80211_FREQUENCY_ATTR_MAX + 1];\r\nstatic struct nla_policy freq_policy[NL80211_FREQUENCY_ATTR_MAX + 1] = {\r\n{NLA_UNSPEC, 0, 0},\r\n{NLA_U32, 0, 0},\r\n{NLA_FLAG, 0, 0},\r\n{NLA_FLAG, 0, 0},\r\n{NLA_FLAG, 0, 0},\r\n{NLA_FLAG, 0, 0},\r\n{NLA_U32, 0, 0}\r\n};\r\nint rem_freq;\r\nif (!tb) return;\r\nnla_for_each_nested(nl_freq, tb, rem_freq) {\r\nuint32_t freq;\r\nnla_parse(tb_freq, NL80211_FREQUENCY_ATTR_MAX,\r\n(struct nlattr *)nla_data(nl_freq),\r\nnla_len(nl_freq), freq_policy);\r\nif (!tb_freq[NL80211_FREQUENCY_ATTR_FREQ])\r\ncontinue;\r\nif (tb_freq[NL80211_FREQUENCY_ATTR_DISABLED])\r\ncontinue;\r\nfreq = nla_get_u32(tb_freq[NL80211_FREQUENCY_ATTR_FREQ]);\r\ng_array_append_val(iface->frequencies, freq);\r\n}\r\n}\r\nstatic void parse_wiphy_bands(struct ws80211_interface *iface,\r\nstruct nlattr *tb)\r\n{\r\nstruct nlattr *nl_band;\r\nstruct nlattr *tb_band[NL80211_BAND_ATTR_MAX + 1];\r\nint bandidx = 1;\r\nint rem_band;\r\nif (!tb) return;\r\nnla_for_each_nested(nl_band, tb, rem_band) {\r\nbandidx++;\r\nnla_parse(tb_band, NL80211_BAND_ATTR_MAX,\r\n(struct nlattr *)nla_data(nl_band),\r\nnla_len(nl_band), NULL);\r\n#ifdef NL80211_BAND_ATTR_HT_CAPA\r\nparse_band_ht_capa(iface, tb_band[NL80211_BAND_ATTR_HT_CAPA]);\r\n#endif\r\n#ifdef HAVE_NL80211_VHT_CAPABILITY\r\nparse_band_vht_capa(iface, tb_band[NL80211_BAND_ATTR_VHT_CAPA]);\r\n#endif\r\nparse_band_freqs(iface, tb_band[NL80211_BAND_ATTR_FREQS]);\r\n}\r\n}\r\nstatic void parse_supported_commands(struct ws80211_interface *iface,\r\nstruct nlattr *tb)\r\n{\r\n#ifdef HAVE_NL80211_CMD_SET_CHANNEL\r\nint cmd;\r\nstruct nlattr *nl_cmd;\r\nif (!tb) return;\r\nnla_for_each_nested(nl_cmd, tb, cmd) {\r\nif(nla_get_u32(nl_cmd) == NL80211_CMD_SET_CHANNEL)\r\niface->can_set_freq = TRUE;\r\n}\r\n#else\r\niface->can_set_freq = TRUE;\r\n#endif\r\n}\r\nstatic int get_phys_handler(struct nl_msg *msg, void *arg)\r\n{\r\nstruct nlattr *tb_msg[NL80211_ATTR_MAX + 1];\r\nstruct genlmsghdr *gnlh = (struct genlmsghdr *)nlmsg_data(nlmsg_hdr(msg));\r\nstruct nliface_cookie *cookie = (struct nliface_cookie *)arg;\r\nstruct ws80211_interface *iface;\r\nchar* ifname;\r\nint added = 0;\r\nnla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),\r\ngenlmsg_attrlen(gnlh, 0), NULL);\r\nif (!tb_msg[NL80211_ATTR_WIPHY_NAME])\r\nreturn NL_SKIP;\r\nifname = g_strdup_printf("%s.mon", nla_get_string(tb_msg[NL80211_ATTR_WIPHY_NAME]));\r\niface = get_interface_by_name(cookie->interfaces, ifname);\r\nif (!iface) {\r\niface = (struct ws80211_interface *)g_malloc0(sizeof(*iface));\r\nif (!iface) {\r\ng_free(ifname);\r\nreturn NL_SKIP;\r\n}\r\nadded = 1;\r\niface->ifname = ifname;\r\niface->frequencies = g_array_new(FALSE, FALSE, sizeof(uint32_t));\r\niface->channel_types = 1 << WS80211_CHAN_NO_HT;\r\n} else {\r\ng_free(ifname);\r\n}\r\nparse_supported_iftypes(iface, tb_msg[NL80211_ATTR_SUPPORTED_IFTYPES]);\r\nparse_wiphy_bands(iface, tb_msg[NL80211_ATTR_WIPHY_BANDS]);\r\nparse_supported_commands(iface, tb_msg[NL80211_ATTR_SUPPORTED_COMMANDS]);\r\nif (added)\r\ng_array_append_val(cookie->interfaces, iface);\r\nreturn NL_SKIP;\r\n}\r\nstatic int ws80211_get_phys(GArray *interfaces)\r\n{\r\nstruct nliface_cookie cookie;\r\nstruct nl_msg *msg;\r\nstruct nl_cb *cb;\r\nint ret;\r\nmsg = nlmsg_alloc();\r\nif (!msg) {\r\nfprintf(stderr, "failed to allocate netlink message\n");\r\nreturn 2;\r\n}\r\ncb = nl_cb_alloc(NL_CB_DEFAULT);\r\ncookie.interfaces = interfaces;\r\ngenlmsg_put(msg, 0, 0, nl_state.nl80211_id, 0,\r\nNLM_F_DUMP, NL80211_CMD_GET_WIPHY, 0);\r\n#ifdef HAVE_NL80211_SPLIT_WIPHY_DUMP\r\nif (nl_state.have_split_wiphy) {\r\nNLA_PUT_FLAG(msg, NL80211_ATTR_SPLIT_WIPHY_DUMP);\r\n}\r\n#endif\r\nnl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, get_phys_handler, &cookie);\r\nret = nl80211_do_cmd(msg, cb);\r\nnlmsg_free(msg);\r\nreturn ret;\r\n#ifdef HAVE_NL80211_SPLIT_WIPHY_DUMP\r\nnla_put_failure:\r\nnlmsg_free(msg);\r\nfprintf(stderr, "building message failed\n");\r\nreturn -1;\r\n#endif\r\n}\r\nstatic int get_freq_wext(const char *ifname)\r\n{\r\nint fd;\r\nint ret = -1;\r\nstruct {\r\nchar name1[IFNAMSIZ];\r\n__s32 m;\r\n__s16 e;\r\n__u8 i;\r\n__u8 flags;\r\n} wrq;\r\nfd = socket(AF_INET, SOCK_DGRAM, 0);\r\nif (fd == -1)\r\nreturn -1;\r\ng_strlcpy(wrq.name1, ifname, IFNAMSIZ);\r\nif (ioctl(fd, 0x8B05, &wrq) == 0) {\r\nif (wrq.e == 6)\r\nret = wrq.m;\r\n}\r\nclose(fd);\r\nreturn ret;\r\n}\r\nstatic int get_iface_info_handler(struct nl_msg *msg, void *arg)\r\n{\r\nstruct genlmsghdr *gnlh = (struct genlmsghdr *)nlmsg_data(nlmsg_hdr(msg));\r\nstruct nlattr *tb_msg[NL80211_ATTR_MAX + 1];\r\nstruct __iface_info *iface_info = (struct __iface_info *)arg;\r\nnla_parse(tb_msg, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),\r\ngenlmsg_attrlen(gnlh, 0), NULL);\r\nif (tb_msg[NL80211_ATTR_IFTYPE]) {\r\niface_info->type = nla_get_u32(tb_msg[NL80211_ATTR_IFTYPE]);\r\n}\r\nif (tb_msg[NL80211_ATTR_WIPHY]) {\r\niface_info->phyidx = nla_get_u32(tb_msg[NL80211_ATTR_WIPHY]);\r\n}\r\nif (tb_msg[NL80211_ATTR_WIPHY_FREQ]) {\r\ngboolean found_ch_width = FALSE;\r\niface_info->pub->current_freq = nla_get_u32(tb_msg[NL80211_ATTR_WIPHY_FREQ]);\r\niface_info->pub->current_chan_type = WS80211_CHAN_NO_HT;\r\n#ifdef HAVE_NL80211_VHT_CAPABILITY\r\nif (tb_msg[NL80211_ATTR_CHANNEL_WIDTH]) {\r\nswitch (nla_get_u32(tb_msg[NL80211_ATTR_CHANNEL_WIDTH])) {\r\ncase NL80211_CHAN_WIDTH_80:\r\niface_info->pub->current_chan_type = WS80211_CHAN_VHT80;\r\nfound_ch_width = TRUE;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80P80:\r\niface_info->pub->current_chan_type = WS80211_CHAN_VHT80P80;\r\nfound_ch_width = TRUE;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_160:\r\niface_info->pub->current_chan_type = WS80211_CHAN_VHT160;\r\nfound_ch_width = TRUE;\r\nbreak;\r\n}\r\n}\r\nif (tb_msg[NL80211_ATTR_CENTER_FREQ1]) {\r\niface_info->pub->current_center_freq1 =\r\nnla_get_u32(tb_msg[NL80211_ATTR_CENTER_FREQ1]);\r\n}\r\nif (tb_msg[NL80211_ATTR_CENTER_FREQ2]) {\r\niface_info->pub->current_center_freq2 =\r\nnla_get_u32(tb_msg[NL80211_ATTR_CENTER_FREQ2]);\r\n}\r\n#endif\r\nif (!found_ch_width && tb_msg[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\r\nswitch (nla_get_u32(tb_msg[NL80211_ATTR_WIPHY_CHANNEL_TYPE])) {\r\ncase NL80211_CHAN_NO_HT:\r\niface_info->pub->current_chan_type = WS80211_CHAN_NO_HT;\r\nbreak;\r\ncase NL80211_CHAN_HT20:\r\niface_info->pub->current_chan_type = WS80211_CHAN_HT20;\r\nbreak;\r\ncase NL80211_CHAN_HT40MINUS:\r\niface_info->pub->current_chan_type = WS80211_CHAN_HT40MINUS;\r\nbreak;\r\ncase NL80211_CHAN_HT40PLUS:\r\niface_info->pub->current_chan_type = WS80211_CHAN_HT40PLUS;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn NL_SKIP;\r\n}\r\nstatic int __ws80211_get_iface_info(const char *name, struct __iface_info *iface_info)\r\n{\r\nint devidx;\r\nstruct nl_msg *msg;\r\nstruct nl_cb *cb;\r\nmsg = nlmsg_alloc();\r\nif (!msg) {\r\nfprintf(stderr, "failed to allocate netlink message\n");\r\nreturn 2;\r\n}\r\ncb = nl_cb_alloc(NL_CB_DEFAULT);\r\ndevidx = if_nametoindex(name);\r\ngenlmsg_put(msg, 0, 0, nl_state.nl80211_id, 0,\r\n0, NL80211_CMD_GET_INTERFACE, 0);\r\nNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, devidx);\r\nnl_cb_set(cb, NL_CB_VALID, NL_CB_CUSTOM, get_iface_info_handler, iface_info);\r\nif (nl80211_do_cmd(msg, cb)) {\r\nnlmsg_free(msg);\r\nreturn -1;\r\n}\r\nif (iface_info->pub->current_freq == -1)\r\niface_info->pub->current_freq = get_freq_wext(name);\r\nnlmsg_free(msg);\r\nreturn 0;\r\nnla_put_failure:\r\nnlmsg_free(msg);\r\nfprintf(stderr, "building message failed\n");\r\nreturn -1;\r\n}\r\nint ws80211_get_iface_info(const char *name, struct ws80211_iface_info *iface_info)\r\n{\r\nstruct __iface_info __iface_info;\r\nmemset(iface_info, 0, sizeof(*iface_info));\r\n__iface_info.pub = iface_info;\r\n__iface_info.type = -1;\r\n__iface_info.phyidx= -1;\r\n__iface_info.pub->current_freq = -1;\r\n__iface_info.pub->current_chan_type = WS80211_CHAN_NO_HT;\r\nreturn __ws80211_get_iface_info(name, &__iface_info);\r\n}\r\nstatic int ws80211_keep_only_monitor(GArray *interfaces)\r\n{\r\nunsigned int j;\r\nstruct ws80211_interface *iface;\r\nrestart:\r\nfor (j = 0; j < interfaces->len; j++) {\r\niface = g_array_index(interfaces, struct ws80211_interface *, j);\r\nif (!iface->cap_monitor) {\r\ng_array_remove_index(interfaces, j);\r\ng_array_free(iface->frequencies, TRUE);\r\ng_free(iface->ifname);\r\ng_free(iface);\r\ngoto restart;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ws80211_populate_devices(GArray *interfaces)\r\n{\r\nFILE *fh;\r\nchar line[200];\r\nchar *t;\r\ngchar *t2;\r\nchar *ret;\r\nint i;\r\nunsigned int j;\r\nstruct ws80211_iface_info pub = {-1, WS80211_CHAN_NO_HT, -1, -1, WS80211_FCS_ALL};\r\nstruct __iface_info iface_info;\r\nstruct ws80211_interface *iface;\r\nws80211_get_phys(interfaces);\r\nws80211_keep_only_monitor(interfaces);\r\nfh = g_fopen("/proc/net/dev", "r");\r\nif(!fh) {\r\nfprintf(stderr, "Cannot open /proc/net/dev");\r\nreturn -ENOENT;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nret = fgets(line, sizeof(line), fh);\r\nif (ret == NULL) {\r\nfprintf(stderr, "Error parsing /proc/net/dev");\r\nfclose(fh);\r\nreturn -1;\r\n}\r\n}\r\nwhile(fgets(line, sizeof(line), fh)) {\r\nt = index(line, ':');\r\nif (!t)\r\ncontinue;\r\n*t = 0;\r\nt = line;\r\nwhile (*t && *t == ' ')\r\nt++;\r\nmemset(&iface_info, 0, sizeof(iface_info));\r\niface_info.pub = &pub;\r\n__ws80211_get_iface_info(t, &iface_info);\r\nif (iface_info.type == NL80211_IFTYPE_MONITOR) {\r\nfor (j = 0; j < interfaces->len; j++) {\r\niface = g_array_index(interfaces, struct ws80211_interface *, j);\r\nt2 = g_strdup_printf("phy%d.mon", iface_info.phyidx);\r\nif (t2) {\r\nif (!strcmp(t2, iface->ifname)) {\r\ng_free(iface->ifname);\r\niface->ifname = g_strdup(t);\r\n}\r\ng_free(t2);\r\n}\r\n}\r\n}\r\n}\r\nfclose(fh);\r\nreturn 0;\r\n}\r\nstatic int ws80211_iface_up(const char *ifname)\r\n{\r\nint sock;\r\nstruct ifreq ifreq;\r\nsock = socket(AF_PACKET, SOCK_RAW, 0);\r\nif (sock == -1)\r\nreturn -1;\r\ng_strlcpy(ifreq.ifr_name, ifname, sizeof(ifreq.ifr_name));\r\nif (ioctl(sock, SIOCGIFFLAGS, &ifreq))\r\ngoto out_err;\r\nifreq.ifr_flags |= IFF_UP;\r\nif (ioctl(sock, SIOCSIFFLAGS, &ifreq))\r\ngoto out_err;\r\nclose(sock);\r\nreturn 0;\r\nout_err:\r\nclose(sock);\r\nreturn -1;\r\n}\r\nstatic int ws80211_create_on_demand_interface(const char *name)\r\n{\r\nint devidx, phyidx, err;\r\nstruct nl_msg *msg;\r\nstruct nl_cb *cb;\r\ndevidx = if_nametoindex(name);\r\nif (devidx)\r\nreturn ws80211_iface_up(name);\r\nif (sscanf(name, "phy%d.mon", &phyidx) != 1)\r\nreturn -EINVAL;\r\ncb = nl_cb_alloc(NL_CB_DEFAULT);\r\nmsg = nlmsg_alloc();\r\nif (!msg) {\r\nfprintf(stderr, "failed to allocate netlink message\n");\r\nreturn 2;\r\n}\r\ngenlmsg_put(msg, 0, 0, nl_state.nl80211_id, 0,\r\n0, NL80211_CMD_NEW_INTERFACE, 0);\r\nNLA_PUT_U32(msg, NL80211_ATTR_WIPHY, phyidx);\r\nNLA_PUT_STRING(msg, NL80211_ATTR_IFNAME, name);\r\nNLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, NL80211_IFTYPE_MONITOR);\r\nerr = nl80211_do_cmd(msg, cb);\r\nnlmsg_free(msg);\r\nif (err)\r\nreturn err;\r\nreturn ws80211_iface_up(name);\r\nnla_put_failure:\r\nnlmsg_free(msg);\r\nfprintf(stderr, "building message failed\n");\r\nreturn 2;\r\n}\r\nint ws80211_set_freq(const char *name, int freq, int chan_type, int _U_ center_freq, int _U_ center_freq2)\r\n{\r\nint devidx, err;\r\nstruct nl_msg *msg;\r\nstruct nl_cb *cb;\r\nerr = ws80211_create_on_demand_interface(name);\r\nif (err)\r\nreturn err;\r\nmsg = nlmsg_alloc();\r\nif (!msg) {\r\nfprintf(stderr, "failed to allocate netlink message\n");\r\nreturn 2;\r\n}\r\ncb = nl_cb_alloc(NL_CB_DEFAULT);\r\ndevidx = if_nametoindex(name);\r\n#ifdef HAVE_NL80211_CMD_SET_CHANNEL\r\ngenlmsg_put(msg, 0, 0, nl_state.nl80211_id, 0,\r\n0, NL80211_CMD_SET_CHANNEL, 0);\r\n#else\r\ngenlmsg_put(msg, 0, 0, nl_state.nl80211_id, 0,\r\n0, NL80211_CMD_SET_WIPHY, 0);\r\n#endif\r\nNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, devidx);\r\nNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, freq);\r\nswitch (chan_type) {\r\n#ifdef NL80211_BAND_ATTR_HT_CAPA\r\ncase WS80211_CHAN_NO_HT:\r\nNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, NL80211_CHAN_NO_HT);\r\nbreak;\r\ncase WS80211_CHAN_HT20:\r\nNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, NL80211_CHAN_HT20);\r\nbreak;\r\ncase WS80211_CHAN_HT40MINUS:\r\nNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, NL80211_CHAN_HT40MINUS);\r\nbreak;\r\ncase WS80211_CHAN_HT40PLUS:\r\nNLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE, NL80211_CHAN_HT40PLUS);\r\nbreak;\r\n#endif\r\n#ifdef HAVE_NL80211_VHT_CAPABILITY\r\ncase WS80211_CHAN_VHT80:\r\nNLA_PUT_U32(msg, NL80211_ATTR_CHANNEL_WIDTH, NL80211_CHAN_WIDTH_80);\r\nNLA_PUT_U32(msg, NL80211_ATTR_CENTER_FREQ1, center_freq);\r\nbreak;\r\ncase WS80211_CHAN_VHT80P80:\r\nNLA_PUT_U32(msg, NL80211_ATTR_CHANNEL_WIDTH, NL80211_CHAN_WIDTH_80P80);\r\nNLA_PUT_U32(msg, NL80211_ATTR_CENTER_FREQ1, center_freq);\r\nNLA_PUT_U32(msg, NL80211_ATTR_CENTER_FREQ2, center_freq2);\r\nbreak;\r\ncase WS80211_CHAN_VHT160:\r\nNLA_PUT_U32(msg, NL80211_ATTR_CHANNEL_WIDTH, NL80211_CHAN_WIDTH_160);\r\nNLA_PUT_U32(msg, NL80211_ATTR_CENTER_FREQ1, center_freq);\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nerr = nl80211_do_cmd(msg, cb);\r\nnlmsg_free(msg);\r\nreturn err;\r\nnla_put_failure:\r\nnlmsg_free(msg);\r\nfprintf(stderr, "building message failed\n");\r\nreturn 2;\r\n}\r\nGArray* ws80211_find_interfaces(void)\r\n{\r\nGArray *interfaces;\r\nif (!nl_state.nl_sock)\r\nreturn NULL;\r\ninterfaces = g_array_new(FALSE, FALSE, sizeof(struct ws80211_interface *));\r\nif (!interfaces)\r\nreturn NULL;\r\nif (ws80211_populate_devices(interfaces)) {\r\nws80211_free_interfaces(interfaces);\r\nreturn NULL;\r\n}\r\nreturn interfaces;\r\n}\r\nint\r\nws80211_str_to_chan_type(const gchar *s)\r\n{\r\nint ret = -1;\r\nif (!s)\r\nreturn -1;\r\nif (!strcmp(s, CHAN_NO_HT))\r\nret = WS80211_CHAN_NO_HT;\r\nif (!strcmp(s, CHAN_HT20))\r\nret = WS80211_CHAN_HT20;\r\nif (!strcmp(s, CHAN_HT40MINUS))\r\nret = WS80211_CHAN_HT40MINUS;\r\nif (!strcmp(s, CHAN_HT40PLUS))\r\nret = WS80211_CHAN_HT40PLUS;\r\nif (!strcmp(s, CHAN_VHT80))\r\nret = WS80211_CHAN_VHT80;\r\nif (!strcmp(s, CHAN_VHT80P80))\r\nret = WS80211_CHAN_VHT80P80;\r\nif (!strcmp(s, CHAN_VHT160))\r\nret = WS80211_CHAN_VHT160;\r\nreturn ret;\r\n}\r\nconst gchar\r\n*ws80211_chan_type_to_str(int type)\r\n{\r\nswitch (type) {\r\ncase WS80211_CHAN_NO_HT:\r\nreturn CHAN_NO_HT;\r\ncase WS80211_CHAN_HT20:\r\nreturn CHAN_HT20;\r\ncase WS80211_CHAN_HT40MINUS:\r\nreturn CHAN_HT40MINUS;\r\ncase WS80211_CHAN_HT40PLUS:\r\nreturn CHAN_HT40PLUS;\r\ncase WS80211_CHAN_VHT80:\r\nreturn CHAN_VHT80;\r\ncase WS80211_CHAN_VHT80P80:\r\nreturn CHAN_VHT80P80;\r\ncase WS80211_CHAN_VHT160:\r\nreturn CHAN_VHT160;\r\n}\r\nreturn NULL;\r\n}\r\ngboolean ws80211_has_fcs_filter(void)\r\n{\r\nreturn FALSE;\r\n}\r\nint ws80211_set_fcs_validation(const char *name _U_, enum ws80211_fcs_validation fcs_validation _U_)\r\n{\r\nreturn -1;\r\n}\r\nconst char *ws80211_get_helper_path(void) {\r\nif (g_file_test(network_manager_path, G_FILE_TEST_IS_EXECUTABLE)) {\r\nreturn network_manager_path;\r\n}\r\nreturn NULL;\r\n}\r\nint ws80211_init(void)\r\n{\r\nif (airpcap_get_dll_state() == AIRPCAP_DLL_OK) {\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nGArray* ws80211_find_interfaces(void)\r\n{\r\nGArray *interfaces;\r\nGList *airpcap_if_list, *cur_if;\r\nint err;\r\ngchar *err_str = NULL;\r\ninterfaces = g_array_new(FALSE, FALSE, sizeof(struct ws80211_interface *));\r\nif (!interfaces)\r\nreturn NULL;\r\nairpcap_if_list = get_airpcap_interface_list(&err, &err_str);\r\nif (airpcap_if_list == NULL || g_list_length(airpcap_if_list) == 0){\r\ng_free(err_str);\r\ng_array_free(interfaces, TRUE);\r\nreturn NULL;\r\n}\r\nfor (cur_if = airpcap_if_list; cur_if; cur_if = g_list_next(cur_if)) {\r\nstruct ws80211_interface *iface;\r\nairpcap_if_info_t *airpcap_if_info = (airpcap_if_info_t *) cur_if->data;\r\nchar *ifname;\r\nguint32 chan;\r\nguint32 i;\r\nif (!airpcap_if_info) continue;\r\nifname = airpcap_if_info->name;\r\nif (strlen(ifname) > 4 && g_str_has_prefix(ifname, airpcap_dev_prefix_)) ifname += 4;\r\niface = (struct ws80211_interface *)g_malloc0(sizeof(*iface));\r\niface->ifname = g_strdup(ifname);\r\niface->can_set_freq = TRUE;\r\niface->frequencies = g_array_new(FALSE, FALSE, sizeof(guint32));\r\niface->channel_types = 1 << WS80211_CHAN_NO_HT;\r\nfor (i = 0; i < airpcap_if_info->numSupportedChannels; i++) {\r\nif (airpcap_if_info->pSupportedChannels[i].Flags & FLAG_CAN_BE_HIGH) {\r\niface->channel_types |= 1 << WS80211_CHAN_HT40MINUS;\r\niface->channel_types |= 1 << WS80211_CHAN_HT40PLUS;\r\nbreak;\r\n}\r\n}\r\niface->cap_monitor = 1;\r\nfor (chan = 0; chan < airpcap_if_info->numSupportedChannels; chan++) {\r\ng_array_append_val(iface->frequencies, airpcap_if_info->pSupportedChannels[chan].Frequency);\r\n}\r\ng_array_append_val(interfaces, iface);\r\n}\r\nreturn interfaces;\r\n}\r\nint ws80211_get_iface_info(const char *name, struct ws80211_iface_info *iface_info)\r\n{\r\nGList *airpcap_if_list;\r\nint err;\r\ngchar *err_str = NULL;\r\nairpcap_if_info_t *airpcap_if_info;\r\nif (!iface_info) return -1;\r\nairpcap_if_list = get_airpcap_interface_list(&err, &err_str);\r\nif (airpcap_if_list == NULL || g_list_length(airpcap_if_list) == 0){\r\ng_free(err_str);\r\nreturn -1;\r\n}\r\nairpcap_if_info = get_airpcap_if_from_name(airpcap_if_list, name);\r\nif (!airpcap_if_info) {\r\nfree_airpcap_interface_list(airpcap_if_list);\r\nreturn -1;\r\n}\r\nmemset(iface_info, 0, sizeof(*iface_info));\r\niface_info->current_freq = airpcap_if_info->channelInfo.Frequency;\r\nswitch (airpcap_if_info->channelInfo.ExtChannel) {\r\ncase 0:\r\niface_info->current_chan_type = WS80211_CHAN_NO_HT;\r\nbreak;\r\ncase -1:\r\niface_info->current_chan_type = WS80211_CHAN_HT40MINUS;\r\nbreak;\r\ncase 1:\r\niface_info->current_chan_type = WS80211_CHAN_HT40PLUS;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nswitch (airpcap_if_info->CrcValidationOn) {\r\ncase AIRPCAP_VT_ACCEPT_CORRECT_FRAMES:\r\niface_info->current_fcs_validation = WS80211_FCS_VALID;\r\nbreak;\r\ncase AIRPCAP_VT_ACCEPT_CORRUPT_FRAMES:\r\niface_info->current_fcs_validation = WS80211_FCS_INVALID;\r\nbreak;\r\ndefault:\r\niface_info->current_fcs_validation = WS80211_FCS_ALL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint ws80211_set_freq(const char *name, int freq, int chan_type, int _U_ center_freq, int _U_ center_freq2)\r\n{\r\nGList *airpcap_if_list;\r\nint err;\r\ngchar *err_str = NULL;\r\nairpcap_if_info_t *airpcap_if_info;\r\ngchar err_buf[AIRPCAP_ERRBUF_SIZE];\r\nPAirpcapHandle adapter;\r\nint ret_val = -1;\r\nairpcap_if_list = get_airpcap_interface_list(&err, &err_str);\r\nif (airpcap_if_list == NULL || g_list_length(airpcap_if_list) == 0){\r\ng_free(err_str);\r\nreturn ret_val;\r\n}\r\nairpcap_if_info = get_airpcap_if_from_name(airpcap_if_list, name);\r\nif (!airpcap_if_info) {\r\nfree_airpcap_interface_list(airpcap_if_list);\r\nreturn ret_val;\r\n}\r\nadapter = airpcap_if_open(airpcap_if_info->name, err_buf);\r\nif (adapter) {\r\nairpcap_if_info->channelInfo.Frequency = freq;\r\nswitch (chan_type) {\r\ncase WS80211_CHAN_HT40MINUS:\r\nairpcap_if_info->channelInfo.ExtChannel = -1;\r\nbreak;\r\ncase WS80211_CHAN_HT40PLUS:\r\nairpcap_if_info->channelInfo.ExtChannel = 1;\r\nbreak;\r\ndefault:\r\nairpcap_if_info->channelInfo.ExtChannel = 0;\r\nbreak;\r\n}\r\nif (airpcap_if_set_device_channel_ex(adapter, airpcap_if_info->channelInfo)) {\r\nret_val = 0;\r\n}\r\nairpcap_if_close(adapter);\r\n}\r\nfree_airpcap_interface_list(airpcap_if_list);\r\nreturn ret_val;\r\n}\r\nint ws80211_str_to_chan_type(const gchar *s _U_)\r\n{\r\nreturn -1;\r\n}\r\nconst gchar *ws80211_chan_type_to_str(int type _U_)\r\n{\r\nreturn NULL;\r\n}\r\ngboolean ws80211_has_fcs_filter(void)\r\n{\r\nreturn TRUE;\r\n}\r\nint ws80211_set_fcs_validation(const char *name, enum ws80211_fcs_validation fcs_validation)\r\n{\r\nGList *airpcap_if_list;\r\nint err;\r\ngchar *err_str = NULL;\r\nairpcap_if_info_t *airpcap_if_info;\r\ngchar err_buf[AIRPCAP_ERRBUF_SIZE];\r\nPAirpcapHandle adapter;\r\nint ret_val = -1;\r\nairpcap_if_list = get_airpcap_interface_list(&err, &err_str);\r\nif (airpcap_if_list == NULL || g_list_length(airpcap_if_list) == 0){\r\ng_free(err_str);\r\nreturn ret_val;\r\n}\r\nairpcap_if_info = get_airpcap_if_from_name(airpcap_if_list, name);\r\nif (!airpcap_if_info) {\r\nfree_airpcap_interface_list(airpcap_if_list);\r\nreturn ret_val;\r\n}\r\nadapter = airpcap_if_open(airpcap_if_info->name, err_buf);\r\nif (adapter) {\r\nAirpcapValidationType val_type = AIRPCAP_VT_ACCEPT_EVERYTHING;\r\nswitch (fcs_validation) {\r\ncase WS80211_FCS_VALID:\r\nval_type = AIRPCAP_VT_ACCEPT_CORRECT_FRAMES;\r\nbreak;\r\ncase WS80211_FCS_INVALID:\r\nval_type = AIRPCAP_VT_ACCEPT_CORRUPT_FRAMES;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (airpcap_if_set_fcs_validation(adapter, val_type)) {\r\nairpcap_if_store_cur_config_as_adapter_default(adapter);\r\nret_val = 0;\r\n}\r\nairpcap_if_close(adapter);\r\n}\r\nfree_airpcap_interface_list(airpcap_if_list);\r\nreturn ret_val;\r\n}\r\nconst char *ws80211_get_helper_path(void)\r\n{\r\nHKEY h_key = NULL;\r\nif (!airpcap_conf_path && RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\AirPcap"), 0, KEY_QUERY_VALUE|KEY_WOW64_32KEY, &h_key) == ERROR_SUCCESS) {\r\nDWORD reg_ret;\r\nTCHAR airpcap_dir_utf16[MAX_PATH];\r\nDWORD ad_size = sizeof(airpcap_dir_utf16)/sizeof(TCHAR);\r\nreg_ret = RegQueryValueEx(h_key, NULL, NULL, NULL,\r\n(LPBYTE) &airpcap_dir_utf16, &ad_size);\r\nif (reg_ret == ERROR_SUCCESS) {\r\nairpcap_dir_utf16[ad_size-1] = L'\0';\r\ng_free(airpcap_conf_path);\r\nairpcap_conf_path = g_strdup_printf("%s\\AirpcapConf.exe", utf_16to8(airpcap_dir_utf16));\r\nif (!g_file_test(airpcap_conf_path, G_FILE_TEST_IS_EXECUTABLE)) {\r\ng_free(airpcap_conf_path);\r\nairpcap_conf_path = NULL;\r\n}\r\n}\r\n}\r\nreturn airpcap_conf_path;\r\n}\r\nint ws80211_init(void)\r\n{\r\nreturn -1;\r\n}\r\nGArray* ws80211_find_interfaces(void)\r\n{\r\nreturn NULL;\r\n}\r\nint ws80211_get_iface_info(const char *name _U_, struct ws80211_iface_info *iface_info _U_)\r\n{\r\nreturn -1;\r\n}\r\nint ws80211_set_freq(const char *name _U_, int freq _U_, int _U_ chan_type, int _U_ center_freq, int _U_ center_freq2)\r\n{\r\nreturn -1;\r\n}\r\nint ws80211_str_to_chan_type(const gchar *s _U_)\r\n{\r\nreturn -1;\r\n}\r\nconst gchar *ws80211_chan_type_to_str(int type _U_)\r\n{\r\nreturn NULL;\r\n}\r\ngboolean ws80211_has_fcs_filter(void)\r\n{\r\nreturn FALSE;\r\n}\r\nint ws80211_set_fcs_validation(const char *name _U_, enum ws80211_fcs_validation fcs_validation _U_)\r\n{\r\nreturn -1;\r\n}\r\nconst char *ws80211_get_helper_path(void) {\r\nreturn NULL;\r\n}\r\nvoid ws80211_free_interfaces(GArray *interfaces)\r\n{\r\nstruct ws80211_interface *iface;\r\nif (!interfaces)\r\nreturn;\r\nwhile (interfaces->len) {\r\niface = g_array_index(interfaces, struct ws80211_interface *, 0);\r\ng_array_remove_index(interfaces, 0);\r\ng_array_free(iface->frequencies, TRUE);\r\ng_free(iface->ifname);\r\ng_free(iface);\r\n}\r\ng_array_free(interfaces, TRUE);\r\n}
