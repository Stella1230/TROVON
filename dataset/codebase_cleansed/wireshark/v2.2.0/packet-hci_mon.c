static gint\r\ndissect_hci_mon(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nproto_tree *hci_mon_item;\r\nproto_item *hci_mon_tree;\r\nproto_item *sub_item;\r\ngint offset = 0;\r\nguint16 opcode;\r\nguint16 adapter_id;\r\nbluetooth_data_t *bluetooth_data;\r\ntvbuff_t *next_tvb;\r\nguint32 *adapter_disconnect_in_frame;\r\nwmem_tree_t *subtree;\r\nwmem_tree_key_t key[4];\r\nguint32 k_interface_id;\r\nguint32 k_adapter_id;\r\nguint32 k_frame_number;\r\nbluetooth_data = (bluetooth_data_t *) data;\r\nDISSECTOR_ASSERT(bluetooth_data->previous_protocol_data_type == BT_PD_BTMON);\r\nadapter_id = bluetooth_data->previous_protocol_data.btmon->adapter_id;\r\nopcode = bluetooth_data->previous_protocol_data.btmon->opcode;\r\nif (opcode == 0x00 || opcode == 0x01)\r\npinfo->p2p_dir = P2P_DIR_RECV;\r\nelse if (opcode % 2)\r\npinfo->p2p_dir = P2P_DIR_RECV;\r\nelse\r\npinfo->p2p_dir = P2P_DIR_SENT;\r\nhci_mon_item = proto_tree_add_item(tree, proto_hci_mon, tvb, offset, tvb_captured_length(tvb), ENC_NA);\r\nhci_mon_tree = proto_item_add_subtree(hci_mon_item, ett_hci_mon);\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HCI_MON");\r\nif (opcode == 0x00 || opcode == 0x01)\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Info ");\r\nelse switch (pinfo->p2p_dir) {\r\ncase P2P_DIR_SENT:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Sent ");\r\nbreak;\r\ncase P2P_DIR_RECV:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "Rcvd ");\r\nbreak;\r\ndefault:\r\ncol_set_str(pinfo->cinfo, COL_INFO, "UnknownDirection ");\r\nbreak;\r\n}\r\nsub_item = proto_tree_add_uint(hci_mon_tree, hf_adapter_id, tvb, offset, 0, adapter_id);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\nsub_item = proto_tree_add_uint(hci_mon_tree, hf_opcode, tvb, offset, 0, opcode);\r\nPROTO_ITEM_SET_GENERATED(sub_item);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, "Adapter Id: %u, Opcode: %s",\r\nadapter_id, val_to_str_ext_const(opcode, &hci_mon_opcode_vals_ext, "Unknown"));\r\nbluetooth_data->adapter_id = adapter_id;\r\nk_interface_id = bluetooth_data->interface_id;\r\nk_adapter_id = adapter_id;\r\nk_frame_number = pinfo->num;\r\nkey[0].length = 1;\r\nkey[0].key = &k_interface_id;\r\nkey[1].length = 1;\r\nkey[1].key = &k_adapter_id;\r\nif (!pinfo->fd->flags.visited && opcode == 0x01) {\r\nguint32 *disconnect_in_frame;\r\nkey[2].length = 1;\r\nkey[2].key = &k_frame_number;\r\nkey[3].length = 0;\r\nkey[3].key = NULL;\r\ndisconnect_in_frame = wmem_new(wmem_file_scope(), guint32);\r\nif (disconnect_in_frame) {\r\n*disconnect_in_frame = pinfo->num;\r\nwmem_tree_insert32_array(adapter_to_disconnect_in_frame, key, disconnect_in_frame);\r\n}\r\n}\r\nkey[2].length = 0;\r\nkey[2].key = NULL;\r\nsubtree = (wmem_tree_t *) wmem_tree_lookup32_array(adapter_to_disconnect_in_frame, key);\r\nadapter_disconnect_in_frame = (subtree) ? (guint32 *) wmem_tree_lookup32_le(subtree, k_frame_number) : NULL;\r\nif (adapter_disconnect_in_frame) {\r\nbluetooth_data->adapter_disconnect_in_frame = adapter_disconnect_in_frame;\r\n} else {\r\nbluetooth_data->adapter_disconnect_in_frame = &max_disconnect_in_frame;\r\n}\r\npinfo->ptype = PT_BLUETOOTH;\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nswitch(opcode) {\r\ncase 0x00:\r\nproto_tree_add_item(hci_mon_tree, hf_bus, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(hci_mon_tree, hf_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\noffset = dissect_bd_addr(hf_bd_addr, pinfo, hci_mon_tree, tvb, offset, TRUE, bluetooth_data->interface_id, bluetooth_data->adapter_id, NULL);\r\nproto_tree_add_item(hci_mon_tree, hf_name, tvb, offset, 8, ENC_NA | ENC_ASCII);\r\noffset += 8;\r\nbreak;\r\ncase 0x01:\r\nbreak;\r\ncase 0x02:\r\ncall_dissector_with_data(bthci_cmd_handle, next_tvb, pinfo, tree, bluetooth_data);\r\noffset = tvb_reported_length(tvb);\r\nbreak;\r\ncase 0x03:\r\ncall_dissector_with_data(bthci_evt_handle, next_tvb, pinfo, tree, bluetooth_data);\r\noffset = tvb_reported_length(tvb);\r\nbreak;\r\ncase 0x04:\r\ncase 0x05:\r\ncall_dissector_with_data(bthci_acl_handle, next_tvb, pinfo, tree, bluetooth_data);\r\noffset = tvb_reported_length(tvb);\r\nbreak;\r\ncase 0x06:\r\ncase 0x07:\r\ncall_dissector_with_data(bthci_sco_handle, next_tvb, pinfo, tree, bluetooth_data);\r\noffset = tvb_reported_length(tvb);\r\nbreak;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nproto_tree_add_expert(hci_mon_tree, pinfo, &ei_unknown_data, tvb, offset, tvb_reported_length_remaining(tvb, offset));\r\noffset = tvb_reported_length(tvb);\r\n}\r\nif (opcode == 0x01)\r\nreturn 1;\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_hci_mon(void)\r\n{\r\nmodule_t *module;\r\nexpert_module_t *expert_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_adapter_id,\r\n{ "Adapter ID", "hci_mon.adapter_id",\r\nFT_UINT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_opcode,\r\n{ "Opcode", "hci_mon.opcode",\r\nFT_UINT16, BASE_HEX | BASE_EXT_STRING, &hci_mon_opcode_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_type,\r\n{ "Type", "hci_mon.type",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING, &type_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bus,\r\n{ "Bus", "hci_mon.bus",\r\nFT_UINT8, BASE_HEX | BASE_EXT_STRING, &bus_vals_ext, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_bd_addr,\r\n{ "BD_ADDR", "hci_mon.bd_addr",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_name,\r\n{ "Adapter Name", "hci_mon.adapter_name",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n}\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_unknown_data, { "hci_mon.unknown_data", PI_PROTOCOL, PI_WARN, "Unknown data", EXPFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_hci_mon,\r\n};\r\nproto_hci_mon = proto_register_protocol("Bluetooth Linux Monitor Transport", "HCI_MON", "hci_mon");\r\nproto_register_field_array(proto_hci_mon, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nhci_mon_handle = register_dissector("hci_mon", dissect_hci_mon, proto_hci_mon);\r\nexpert_module = expert_register_protocol(proto_hci_mon);\r\nexpert_register_field_array(expert_module, ei, array_length(ei));\r\nadapter_to_disconnect_in_frame = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\nmodule = prefs_register_protocol(proto_hci_mon, NULL);\r\nprefs_register_static_text_preference(module, "bthci_mon.version",\r\n"Bluetooth Linux Monitor Transport introduced in BlueZ 5.x",\r\n"Version of protocol supported by this dissector.");\r\n}\r\nvoid\r\nproto_reg_handoff_hci_mon(void)\r\n{\r\nbthci_cmd_handle = find_dissector_add_dependency("bthci_cmd", proto_hci_mon);\r\nbthci_evt_handle = find_dissector_add_dependency("bthci_evt", proto_hci_mon);\r\nbthci_acl_handle = find_dissector_add_dependency("bthci_acl", proto_hci_mon);\r\nbthci_sco_handle = find_dissector_add_dependency("bthci_sco", proto_hci_mon);\r\ndissector_add_uint("bluetooth.encap", WTAP_ENCAP_BLUETOOTH_LINUX_MONITOR, hci_mon_handle);\r\n}
