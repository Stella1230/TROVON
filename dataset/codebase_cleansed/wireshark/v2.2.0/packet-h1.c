static gboolean dissect_h1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_tree *h1_tree, *block_tree;\r\nproto_item *h1_ti, *block_ti;\r\ngint offset = 0, offset_block_start;\r\nguint8 h1_len;\r\nguint8 block_type, block_len;\r\ntvbuff_t *next_tvb;\r\nif (tvb_captured_length(tvb) < 2) {\r\nreturn FALSE;\r\n}\r\nif (!(tvb_get_guint8(tvb, 0) == 'S' && tvb_get_guint8(tvb, 1) == '5')) {\r\nreturn FALSE;\r\n}\r\ncol_set_str (pinfo->cinfo, COL_PROTOCOL, "H1");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "S5: ");\r\nh1_ti = proto_tree_add_item(tree, proto_h1, tvb, offset, -1, ENC_NA);\r\nh1_tree = proto_item_add_subtree(h1_ti, ett_h1);\r\nproto_tree_add_item(h1_tree, hf_h1_header, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nh1_len = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(h1_tree, hf_h1_len, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_set_len(h1_ti, h1_len);\r\noffset++;\r\nwhile (offset < h1_len) {\r\noffset_block_start = offset;\r\nblock_type = tvb_get_guint8(tvb, offset);\r\nblock_len = tvb_get_guint8(tvb, offset+1);\r\nif (!try_val_to_str(block_type, block_type_vals)) {\r\nreturn FALSE;\r\n}\r\nif (block_len == 0) {\r\nbreak;\r\n}\r\nblock_tree = proto_tree_add_subtree_format(h1_tree,\r\ntvb, offset, -1, ett_block, &block_ti, "%s",\r\nval_to_str_const(block_type, block_type_vals, "Unknown block"));\r\nproto_tree_add_item(block_tree, hf_h1_block_type,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(block_tree, hf_h1_block_len,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_set_len(block_ti, block_len);\r\noffset++;\r\nswitch (block_type) {\r\ncase OPCODE_BLOCK:\r\nproto_tree_add_item(block_tree, hf_h1_opcode,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\ncol_append_str (pinfo->cinfo, COL_INFO,\r\nval_to_str (tvb_get_guint8(tvb, offset),\r\nopcode_vals, "Unknown Opcode (0x%2.2x)"));\r\nbreak;\r\ncase REQUEST_BLOCK:\r\nproto_tree_add_item(block_tree, hf_h1_org, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s",\r\nval_to_str (tvb_get_guint8(tvb, offset),\r\norg_vals,"Unknown Type (0x%2.2x)"));\r\noffset++;\r\nproto_tree_add_item(block_tree, hf_h1_dbnr, tvb,\r\noffset, 1, ENC_BIG_ENDIAN);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %d",\r\ntvb_get_guint8(tvb, offset));\r\noffset++;\r\nproto_tree_add_item(block_tree, hf_h1_dwnr, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " DW %d",\r\ntvb_get_ntohs(tvb, offset));\r\noffset += 2;\r\nproto_tree_add_item(block_tree, hf_h1_dlen, tvb,\r\noffset, 2, ENC_BIG_ENDIAN);\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " Count %d",\r\ntvb_get_ntohs(tvb, offset));\r\nbreak;\r\ncase RESPONSE_BLOCK:\r\nproto_tree_add_item(block_tree, hf_h1_response_value,\r\ntvb, offset, 1, ENC_BIG_ENDIAN);\r\ncol_append_fstr (pinfo->cinfo, COL_INFO, " %s",\r\nval_to_str (tvb_get_guint8(tvb, offset),\r\nreturncode_vals,"Unknown Returncode (0x%2.2x"));\r\nbreak;\r\n}\r\noffset = offset_block_start + block_len;\r\n}\r\nif (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_data_dissector(next_tvb, pinfo, tree);\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_register_h1 (void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{&hf_h1_header,\r\n{"H1-Header", "h1.header", FT_UINT16, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL }},\r\n{&hf_h1_len,\r\n{"Length indicator", "h1.len", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{&hf_h1_block_type,\r\n{"Block type", "h1.block_type", FT_UINT8, BASE_HEX, VALS(block_type_vals), 0x0,\r\nNULL, HFILL }},\r\n{&hf_h1_block_len,\r\n{"Block length", "h1.block_len", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_h1_opcode,\r\n{"Opcode", "h1.opcode", FT_UINT8, BASE_HEX, VALS (opcode_vals), 0x0,\r\nNULL, HFILL }},\r\n{&hf_h1_org,\r\n{"Memory type", "h1.org", FT_UINT8, BASE_HEX, VALS (org_vals), 0x0,\r\nNULL, HFILL }},\r\n{&hf_h1_dbnr,\r\n{"Memory block number", "h1.dbnr", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_h1_dwnr,\r\n{"Address within memory block", "h1.dwnr", FT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{&hf_h1_dlen,\r\n{"Length in words", "h1.dlen", FT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL }},\r\n{&hf_h1_response_value,\r\n{"Response value", "h1.resvalue", FT_UINT8, BASE_DEC,\r\nVALS (returncode_vals), 0x0, NULL, HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_h1,\r\n&ett_block,\r\n};\r\nproto_h1 = proto_register_protocol ("Sinec H1 Protocol", "H1", "h1");\r\nproto_register_field_array (proto_h1, hf, array_length (hf));\r\nproto_register_subtree_array (ett, array_length (ett));\r\n}\r\nvoid\r\nproto_reg_handoff_h1(void)\r\n{\r\nheur_dissector_add("cotp", dissect_h1,\r\n"Sinec H1 over COTP", "hi_cotp", proto_h1, HEURISTIC_ENABLE);\r\nheur_dissector_add("cotp_is", dissect_h1,\r\n"Sinec H1 over COTP (inactive subset)", "hi_cotp_is", proto_h1, HEURISTIC_ENABLE);\r\nheur_dissector_add("tcp", dissect_h1,\r\n"Sinec H1 over TCP", "hi_tcp", proto_h1, HEURISTIC_ENABLE);\r\n}
