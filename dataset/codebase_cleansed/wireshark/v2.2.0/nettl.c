wtap_open_return_val nettl_open(wtap *wth, int *err, gchar **err_info)\r\n{\r\nstruct nettl_file_hdr file_hdr;\r\nguint16 dummy[2];\r\nint subsys;\r\nnettl_t *nettl;\r\nmemset(&file_hdr, 0, sizeof(file_hdr));\r\nif (!wtap_read_bytes(wth->fh, file_hdr.magic, MAGIC_SIZE, err, err_info)) {\r\nif (*err != WTAP_ERR_SHORT_READ)\r\nreturn WTAP_OPEN_ERROR;\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (memcmp(file_hdr.magic, nettl_magic_hpux9, MAGIC_SIZE) &&\r\nmemcmp(file_hdr.magic, nettl_magic_hpux10, MAGIC_SIZE)) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nif (!wtap_read_bytes(wth->fh, file_hdr.file_name, FILE_HDR_SIZE - MAGIC_SIZE,\r\nerr, err_info))\r\nreturn WTAP_OPEN_ERROR;\r\nwth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_NETTL;\r\nnettl = g_new(nettl_t,1);\r\nwth->priv = (void *)nettl;\r\nif (file_hdr.os_vers[2] == '1' && file_hdr.os_vers[3] == '1')\r\nnettl->is_hpux_11 = TRUE;\r\nelse\r\nnettl->is_hpux_11 = FALSE;\r\nwth->subtype_read = nettl_read;\r\nwth->subtype_seek_read = nettl_seek_read;\r\nwth->snapshot_length = 0;\r\nif (!wtap_read_bytes_or_eof(wth->fh, dummy, 4, err, err_info)) {\r\nif (*err == 0) {\r\nreturn WTAP_OPEN_NOT_MINE;\r\n}\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nsubsys = g_ntohs(dummy[1]);\r\nswitch (subsys) {\r\ncase NETTL_SUBSYS_HPPB_FDDI :\r\ncase NETTL_SUBSYS_EISA_FDDI :\r\ncase NETTL_SUBSYS_PCI_FDDI :\r\ncase NETTL_SUBSYS_HSC_FDDI :\r\nwth->file_encap = WTAP_ENCAP_NETTL_FDDI;\r\nbreak;\r\ncase NETTL_SUBSYS_TOKEN :\r\ncase NETTL_SUBSYS_PCI_TR :\r\nwth->file_encap = WTAP_ENCAP_NETTL_TOKEN_RING;\r\nbreak;\r\ncase NETTL_SUBSYS_NS_LS_IP :\r\ncase NETTL_SUBSYS_NS_LS_LOOPBACK :\r\ncase NETTL_SUBSYS_NS_LS_TCP :\r\ncase NETTL_SUBSYS_NS_LS_UDP :\r\ncase NETTL_SUBSYS_NS_LS_IPV6 :\r\nwth->file_encap = WTAP_ENCAP_NETTL_RAW_IP;\r\nbreak;\r\ncase NETTL_SUBSYS_NS_LS_ICMP :\r\nwth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMP;\r\nbreak;\r\ncase NETTL_SUBSYS_NS_LS_ICMPV6 :\r\nwth->file_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;\r\nbreak;\r\ncase NETTL_SUBSYS_NS_LS_TELNET :\r\nwth->file_encap = WTAP_ENCAP_NETTL_RAW_TELNET;\r\nbreak;\r\ndefault:\r\nwth->file_encap = WTAP_ENCAP_NETTL_ETHERNET;\r\n}\r\nif (file_seek(wth->fh, FILE_HDR_SIZE, SEEK_SET, err) == -1) {\r\nreturn WTAP_OPEN_ERROR;\r\n}\r\nwth->file_tsprec = WTAP_TSPREC_USEC;\r\nreturn WTAP_OPEN_MINE;\r\n}\r\nstatic gboolean nettl_read(wtap *wth, int *err, gchar **err_info,\r\ngint64 *data_offset)\r\n{\r\n*data_offset = file_tell(wth->fh);\r\nif (!nettl_read_rec(wth, wth->fh, &wth->phdr, wth->frame_buffer,\r\nerr, err_info)) {\r\nreturn FALSE;\r\n}\r\nif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\r\nwth->file_encap = wth->phdr.pkt_encap;\r\nelse {\r\nif (wth->file_encap != wth->phdr.pkt_encap)\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nnettl_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,\r\nBuffer *buf, int *err, gchar **err_info)\r\n{\r\nif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)\r\nreturn FALSE;\r\nif (!nettl_read_rec(wth, wth->random_fh, phdr, buf, err, err_info)) {\r\nif (*err == 0) {\r\n*err = WTAP_ERR_SHORT_READ;\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nnettl_read_rec(wtap *wth, FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\r\nint *err, gchar **err_info)\r\n{\r\nunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nnettl_t *nettl = (nettl_t *)wth->priv;\r\ngboolean fddihack = FALSE;\r\nstruct nettlrec_hdr rec_hdr;\r\nguint16 hdr_len;\r\nstruct nettlrec_ns_ls_drv_eth_hdr drv_eth_hdr;\r\nguint32 length, caplen;\r\nint subsys;\r\nguint padlen;\r\nint datalen;\r\nguint8 dummyc[16];\r\nint bytes_to_read;\r\nguint8 *pd;\r\nif (!wtap_read_bytes_or_eof(fh, &rec_hdr.hdr_len, sizeof rec_hdr.hdr_len,\r\nerr, err_info))\r\nreturn FALSE;\r\nhdr_len = g_ntohs(rec_hdr.hdr_len);\r\nif (hdr_len < NETTL_REC_HDR_LEN) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("nettl: record header length %u too short",\r\nhdr_len);\r\nreturn FALSE;\r\n}\r\nif (!wtap_read_bytes(fh, &rec_hdr.subsys, NETTL_REC_HDR_LEN - 2,\r\nerr, err_info))\r\nreturn FALSE;\r\nsubsys = g_ntohs(rec_hdr.subsys);\r\nhdr_len -= NETTL_REC_HDR_LEN;\r\nif (file_seek(fh, hdr_len, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\nif ( (pntoh32(&rec_hdr.kind) & NETTL_HDR_PDU_MASK) == 0 ) {\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_IP;\r\nlength = pntoh32(&rec_hdr.length);\r\ncaplen = pntoh32(&rec_hdr.caplen);\r\npadlen = 0;\r\n} else switch (subsys) {\r\ncase NETTL_SUBSYS_LAN100 :\r\ncase NETTL_SUBSYS_EISA100BT :\r\ncase NETTL_SUBSYS_BASE100 :\r\ncase NETTL_SUBSYS_GSC100BT :\r\ncase NETTL_SUBSYS_PCI100BT :\r\ncase NETTL_SUBSYS_SPP100BT :\r\ncase NETTL_SUBSYS_100VG :\r\ncase NETTL_SUBSYS_GELAN :\r\ncase NETTL_SUBSYS_BTLAN :\r\ncase NETTL_SUBSYS_INTL100 :\r\ncase NETTL_SUBSYS_IGELAN :\r\ncase NETTL_SUBSYS_IETHER :\r\ncase NETTL_SUBSYS_IXGBE :\r\ncase NETTL_SUBSYS_HSSN :\r\ncase NETTL_SUBSYS_IGSSN :\r\ncase NETTL_SUBSYS_ICXGBE :\r\ncase NETTL_SUBSYS_IEXGBE :\r\ncase NETTL_SUBSYS_IOCXGBE :\r\ncase NETTL_SUBSYS_IQXGBE :\r\ncase NETTL_SUBSYS_HPPB_FDDI :\r\ncase NETTL_SUBSYS_EISA_FDDI :\r\ncase NETTL_SUBSYS_PCI_FDDI :\r\ncase NETTL_SUBSYS_HSC_FDDI :\r\ncase NETTL_SUBSYS_TOKEN :\r\ncase NETTL_SUBSYS_PCI_TR :\r\ncase NETTL_SUBSYS_NS_LS_IP :\r\ncase NETTL_SUBSYS_NS_LS_LOOPBACK :\r\ncase NETTL_SUBSYS_NS_LS_TCP :\r\ncase NETTL_SUBSYS_NS_LS_UDP :\r\ncase NETTL_SUBSYS_HP_APAPORT :\r\ncase NETTL_SUBSYS_HP_APALACP :\r\ncase NETTL_SUBSYS_NS_LS_IPV6 :\r\ncase NETTL_SUBSYS_NS_LS_ICMPV6 :\r\ncase NETTL_SUBSYS_NS_LS_ICMP :\r\ncase NETTL_SUBSYS_NS_LS_TELNET :\r\ncase NETTL_SUBSYS_NS_LS_SCTP :\r\nif( (subsys == NETTL_SUBSYS_NS_LS_IP)\r\n|| (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK)\r\n|| (subsys == NETTL_SUBSYS_NS_LS_UDP)\r\n|| (subsys == NETTL_SUBSYS_NS_LS_TCP)\r\n|| (subsys == NETTL_SUBSYS_NS_LS_SCTP)\r\n|| (subsys == NETTL_SUBSYS_NS_LS_IPV6)) {\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_IP;\r\n} else if (subsys == NETTL_SUBSYS_NS_LS_ICMP) {\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMP;\r\n} else if (subsys == NETTL_SUBSYS_NS_LS_ICMPV6) {\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_ICMPV6;\r\n} else if (subsys == NETTL_SUBSYS_NS_LS_TELNET) {\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_RAW_TELNET;\r\n} else if( (subsys == NETTL_SUBSYS_HPPB_FDDI)\r\n|| (subsys == NETTL_SUBSYS_EISA_FDDI)\r\n|| (subsys == NETTL_SUBSYS_PCI_FDDI)\r\n|| (subsys == NETTL_SUBSYS_HSC_FDDI) ) {\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_FDDI;\r\n} else if( (subsys == NETTL_SUBSYS_PCI_TR)\r\n|| (subsys == NETTL_SUBSYS_TOKEN) ) {\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_TOKEN_RING;\r\n} else {\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;\r\n}\r\nlength = pntoh32(&rec_hdr.length);\r\ncaplen = pntoh32(&rec_hdr.caplen);\r\nif (subsys == NETTL_SUBSYS_HPPB_FDDI) {\r\nif (pntoh32(&rec_hdr.kind) == NETTL_HDR_PDUIN) {\r\nfddihack=TRUE;\r\npadlen = 0;\r\n} else {\r\nif (!wtap_read_bytes(fh, dummyc, 9, err, err_info))\r\nreturn FALSE;\r\npadlen = (int)dummyc[8];\r\nif (file_seek(fh, padlen, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\npadlen += 9;\r\n}\r\n} else if ( (subsys == NETTL_SUBSYS_PCI_FDDI)\r\n|| (subsys == NETTL_SUBSYS_EISA_FDDI)\r\n|| (subsys == NETTL_SUBSYS_HSC_FDDI) ) {\r\nif (file_seek(fh, 3, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\npadlen = 3;\r\n} else if (subsys == NETTL_SUBSYS_NS_LS_LOOPBACK) {\r\nif (file_seek(fh, 26, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\npadlen = 26;\r\n} else if (subsys == NETTL_SUBSYS_NS_LS_SCTP) {\r\nif (file_seek(fh, 8, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\npadlen = 8;\r\n} else {\r\npadlen = 0;\r\n}\r\nbreak;\r\ncase NETTL_SUBSYS_NS_LS_DRIVER :\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;\r\nif (!wtap_read_bytes(fh, &drv_eth_hdr, NS_LS_DRV_ETH_HDR_LEN,\r\nerr, err_info))\r\nreturn FALSE;\r\nlength = pntoh16(&drv_eth_hdr.length);\r\ncaplen = pntoh16(&drv_eth_hdr.caplen);\r\nif (nettl->is_hpux_11) {\r\nif (file_seek(fh, 2, SEEK_CUR, err) == -1) return FALSE;\r\n}\r\npadlen = 0;\r\nbreak;\r\ncase NETTL_SUBSYS_SX25L2:\r\ncase NETTL_SUBSYS_SX25L3:\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_X25;\r\nlength = pntoh32(&rec_hdr.length);\r\ncaplen = pntoh32(&rec_hdr.caplen);\r\npadlen = 24;\r\nif (file_seek(fh, padlen, SEEK_CUR, err) == -1)\r\nreturn FALSE;\r\nbreak;\r\ndefault:\r\nwth->file_encap = WTAP_ENCAP_PER_PACKET;\r\nphdr->pkt_encap = WTAP_ENCAP_NETTL_ETHERNET;\r\nlength = pntoh32(&rec_hdr.length);\r\ncaplen = pntoh32(&rec_hdr.caplen);\r\npadlen = 0;\r\nbreak;\r\n}\r\nif (length < padlen) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("nettl: packet length %u in record header too short, less than %u",\r\nlength, padlen);\r\nreturn FALSE;\r\n}\r\nphdr->rec_type = REC_TYPE_PACKET;\r\nphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\r\nphdr->len = length - padlen;\r\nif (caplen < padlen) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("nettl: captured length %u in record header too short, less than %u",\r\ncaplen, padlen);\r\nreturn FALSE;\r\n}\r\ndatalen = caplen - padlen;\r\nphdr->caplen = datalen;\r\nphdr->ts.secs = pntoh32(&rec_hdr.sec);\r\nphdr->ts.nsecs = pntoh32(&rec_hdr.usec) * 1000;\r\npseudo_header->nettl.subsys = subsys;\r\npseudo_header->nettl.devid = pntoh32(&rec_hdr.devid);\r\npseudo_header->nettl.kind = pntoh32(&rec_hdr.kind);\r\npseudo_header->nettl.pid = pntoh32(&rec_hdr.pid);\r\npseudo_header->nettl.uid = pntoh16(&rec_hdr.uid);\r\nif (phdr->caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_BAD_FILE;\r\n*err_info = g_strdup_printf("nettl: File has %u-byte packet, bigger than maximum of %u",\r\nphdr->caplen, WTAP_MAX_PACKET_SIZE);\r\nreturn FALSE;\r\n}\r\nws_buffer_assure_space(buf, datalen);\r\npd = ws_buffer_start_ptr(buf);\r\nif (fddihack) {\r\nbytes_to_read = 15;\r\nif (bytes_to_read > datalen)\r\nbytes_to_read = datalen;\r\nif (!wtap_read_bytes(fh, pd, bytes_to_read, err, err_info))\r\nreturn FALSE;\r\ndatalen -= bytes_to_read;\r\nif (datalen == 0) {\r\nreturn TRUE;\r\n}\r\nif (pd[13] == 0xAA) {\r\nbytes_to_read = 3;\r\nif (bytes_to_read > datalen)\r\nbytes_to_read = datalen;\r\nif (!file_skip(fh, bytes_to_read, err))\r\nreturn FALSE;\r\ndatalen -= bytes_to_read;\r\nif (datalen == 0) {\r\nreturn TRUE;\r\n}\r\n}\r\nif (!wtap_read_bytes(fh, pd + 15, datalen, err, err_info))\r\nreturn FALSE;\r\n} else {\r\nif (!wtap_read_bytes(fh, pd, datalen, err, err_info))\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nint nettl_dump_can_write_encap(int encap)\r\n{\r\nswitch (encap) {\r\ncase WTAP_ENCAP_ETHERNET:\r\ncase WTAP_ENCAP_FDDI_BITSWAPPED:\r\ncase WTAP_ENCAP_TOKEN_RING:\r\ncase WTAP_ENCAP_NETTL_ETHERNET:\r\ncase WTAP_ENCAP_NETTL_FDDI:\r\ncase WTAP_ENCAP_NETTL_TOKEN_RING:\r\ncase WTAP_ENCAP_NETTL_RAW_IP:\r\ncase WTAP_ENCAP_NETTL_RAW_ICMP:\r\ncase WTAP_ENCAP_NETTL_RAW_ICMPV6:\r\ncase WTAP_ENCAP_NETTL_RAW_TELNET:\r\ncase WTAP_ENCAP_PER_PACKET:\r\ncase WTAP_ENCAP_UNKNOWN:\r\ncase WTAP_ENCAP_NETTL_UNKNOWN:\r\nreturn 0;\r\ndefault:\r\nreturn WTAP_ERR_UNWRITABLE_ENCAP;\r\n}\r\n}\r\ngboolean nettl_dump_open(wtap_dumper *wdh, int *err)\r\n{\r\nstruct nettl_file_hdr file_hdr;\r\nwdh->subtype_write = nettl_dump;\r\nmemset(&file_hdr,0,sizeof(file_hdr));\r\nmemcpy(file_hdr.magic,nettl_magic_hpux10,sizeof(file_hdr.magic));\r\ng_strlcpy(file_hdr.file_name,"/tmp/wireshark.TRC000",NETTL_FILENAME_SIZE);\r\ng_strlcpy(file_hdr.tz,"UTC",20);\r\ng_strlcpy(file_hdr.host_name,"",9);\r\ng_strlcpy(file_hdr.os_vers,"B.11.11",9);\r\nfile_hdr.os_v=0x55;\r\ng_strlcpy(file_hdr.model,"9000/800",11);\r\nfile_hdr.unknown=g_htons(0x406);\r\nif (!wtap_dump_file_write(wdh, &file_hdr, sizeof file_hdr, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof(file_hdr);\r\nreturn TRUE;\r\n}\r\nstatic gboolean nettl_dump(wtap_dumper *wdh,\r\nconst struct wtap_pkthdr *phdr,\r\nconst guint8 *pd, int *err, gchar **err_info _U_)\r\n{\r\nconst union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\r\nstruct nettlrec_hdr rec_hdr;\r\nguint8 dummyc[24];\r\nif (phdr->rec_type != REC_TYPE_PACKET) {\r\n*err = WTAP_ERR_UNWRITABLE_REC_TYPE;\r\nreturn FALSE;\r\n}\r\nif (phdr->caplen > WTAP_MAX_PACKET_SIZE) {\r\n*err = WTAP_ERR_PACKET_TOO_LARGE;\r\nreturn FALSE;\r\n}\r\nmemset(&rec_hdr,0,sizeof(rec_hdr));\r\nrec_hdr.hdr_len = g_htons(sizeof(rec_hdr) + 4);\r\nrec_hdr.kind = g_htonl(NETTL_HDR_PDUIN);\r\nrec_hdr.sec = g_htonl(phdr->ts.secs);\r\nrec_hdr.usec = g_htonl(phdr->ts.nsecs/1000);\r\nrec_hdr.caplen = g_htonl(phdr->caplen);\r\nrec_hdr.length = g_htonl(phdr->len);\r\nrec_hdr.devid = -1;\r\nrec_hdr.pid = -1;\r\nrec_hdr.uid = -1;\r\nswitch (phdr->pkt_encap) {\r\ncase WTAP_ENCAP_NETTL_FDDI:\r\nrec_hdr.caplen = g_htonl(phdr->caplen + 3);\r\nrec_hdr.length = g_htonl(phdr->len + 3);\r\ncase WTAP_ENCAP_NETTL_ETHERNET:\r\ncase WTAP_ENCAP_NETTL_TOKEN_RING:\r\ncase WTAP_ENCAP_NETTL_RAW_IP:\r\ncase WTAP_ENCAP_NETTL_RAW_ICMP:\r\ncase WTAP_ENCAP_NETTL_RAW_ICMPV6:\r\ncase WTAP_ENCAP_NETTL_RAW_TELNET:\r\ncase WTAP_ENCAP_NETTL_UNKNOWN:\r\nrec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);\r\nrec_hdr.devid = g_htonl(pseudo_header->nettl.devid);\r\nrec_hdr.kind = g_htonl(pseudo_header->nettl.kind);\r\nrec_hdr.pid = g_htonl(pseudo_header->nettl.pid);\r\nrec_hdr.uid = g_htons(pseudo_header->nettl.uid);\r\nbreak;\r\ncase WTAP_ENCAP_RAW_IP:\r\nrec_hdr.subsys = g_htons(NETTL_SUBSYS_NS_LS_IP);\r\nbreak;\r\ncase WTAP_ENCAP_ETHERNET:\r\nrec_hdr.subsys = g_htons(NETTL_SUBSYS_BTLAN);\r\nbreak;\r\ncase WTAP_ENCAP_FDDI_BITSWAPPED:\r\nrec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_FDDI);\r\nrec_hdr.caplen = g_htonl(phdr->caplen + 3);\r\nrec_hdr.length = g_htonl(phdr->len + 3);\r\nbreak;\r\ncase WTAP_ENCAP_TOKEN_RING:\r\nrec_hdr.subsys = g_htons(NETTL_SUBSYS_PCI_TR);\r\nbreak;\r\n#if 0\r\ncase WTAP_ENCAP_NETTL_X25:\r\nrec_hdr.caplen = g_htonl(phdr->caplen + 24);\r\nrec_hdr.length = g_htonl(phdr->len + 24);\r\nrec_hdr.subsys = g_htons(pseudo_header->nettl.subsys);\r\nrec_hdr.devid = g_htonl(pseudo_header->nettl.devid);\r\nrec_hdr.kind = g_htonl(pseudo_header->nettl.kind);\r\nrec_hdr.pid = g_htonl(pseudo_header->nettl.pid);\r\nrec_hdr.uid = g_htons(pseudo_header->nettl.uid);\r\nbreak;\r\n#endif\r\ndefault:\r\n*err = WTAP_ERR_UNWRITABLE_ENCAP;\r\nreturn FALSE;\r\n}\r\nif (!wtap_dump_file_write(wdh, &rec_hdr, sizeof(rec_hdr), err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += sizeof(rec_hdr);\r\nmemset(dummyc, 0, sizeof dummyc);\r\nif (!wtap_dump_file_write(wdh, dummyc, 4, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += 4;\r\nif ((phdr->pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED) ||\r\n(phdr->pkt_encap == WTAP_ENCAP_NETTL_FDDI)) {\r\nif (!wtap_dump_file_write(wdh, dummyc, 3, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += 3;\r\n}\r\nif (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\r\nreturn FALSE;\r\nwdh->bytes_dumped += phdr->caplen;\r\nreturn TRUE;\r\n}
