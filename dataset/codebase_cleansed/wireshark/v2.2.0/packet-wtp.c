static void\r\nwtp_defragment_init(void)\r\n{\r\nreassembly_table_init(&wtp_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\nwtp_defragment_cleanup(void)\r\n{\r\nreassembly_table_destroy(&wtp_reassembly_table);\r\n}\r\nstatic char retransmission_indicator(unsigned char octet)\r\n{\r\nswitch (pdu_type(octet)) {\r\ncase INVOKE:\r\ncase RESULT:\r\ncase ACK:\r\ncase SEGMENTED_INVOKE:\r\ncase SEGMENTED_RESULT:\r\ncase NEGATIVE_ACK:\r\nreturn octet & 0x01;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void\r\nwtp_handle_tpi(proto_tree *tree, tvbuff_t *tvb)\r\n{\r\nint offset = 0;\r\nunsigned char tByte;\r\nunsigned char tType;\r\nunsigned char tLen;\r\nproto_tree *subTree = NULL;\r\nproto_item *pi;\r\ntByte = tvb_get_guint8(tvb, offset++);\r\ntType = (tByte & 0x78) >> 3;\r\nif (tByte & 0x04)\r\ntLen = tvb_get_guint8(tvb, offset++);\r\nelse\r\ntLen = tByte & 0x03;\r\npi = proto_tree_add_uint(tree, hf_wtp_tpi_type,\r\ntvb, 0, tvb_captured_length(tvb), tType);\r\nsubTree = proto_item_add_subtree(pi, ett_tpilist);\r\nswitch (tType) {\r\ncase 0x00:\r\nbreak;\r\ncase 0x01:\r\nproto_tree_add_item(subTree, hf_wtp_tpi_info,\r\ntvb, offset, tLen, ENC_NA);\r\nbreak;\r\ncase 0x02:\r\nproto_tree_add_item(subTree, hf_wtp_tpi_opt,\r\ntvb, offset++, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(subTree, hf_wtp_tpi_optval,\r\ntvb, offset, tLen - 1, ENC_NA);\r\nbreak;\r\ncase 0x03:\r\nproto_tree_add_item(subTree, hf_wtp_tpi_psn,\r\ntvb, offset, 1, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase 0x04:\r\nbreak;\r\ncase 0x05:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nchar *szInfo;\r\nint offCur = 0;\r\ngint returned_length, str_index = 0;\r\nunsigned char b0;\r\nunsigned char fCon;\r\nunsigned char fRID;\r\nunsigned char fTTR = '\0';\r\nguint cbHeader = 0;\r\nguint vHeader = 0;\r\nint abortType = 0;\r\nproto_item *ti = NULL;\r\nproto_tree *wtp_tree = NULL;\r\nchar pdut;\r\nchar clsTransaction = 3;\r\nint numMissing = 0;\r\nint i;\r\ntvbuff_t *wsp_tvb = NULL;\r\nguint8 psn = 0;\r\nguint16 TID = 0;\r\nint dataOffset;\r\ngint dataLen;\r\n#define SZINFO_SIZE 256\r\nszInfo=(char *)wmem_alloc(wmem_packet_scope(), SZINFO_SIZE);\r\nb0 = tvb_get_guint8 (tvb, offCur + 0);\r\nif (b0 == 0) {\r\nguint c_fieldlen = 0;\r\nguint c_pdulen = 0;\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_wtp,\r\ntvb, offCur, 1, ENC_NA);\r\nwtp_tree = proto_item_add_subtree(ti, ett_wtp_sub_pdu_tree);\r\nproto_item_append_text(ti, ", PDU concatenation");\r\n}\r\noffCur = 1;\r\ni = 1;\r\nwhile (offCur < (int) tvb_reported_length(tvb)) {\r\ntvbuff_t *wtp_tvb;\r\nb0 = tvb_get_guint8(tvb, offCur + 0);\r\nif (b0 & 0x80) {\r\nc_fieldlen = 2;\r\nc_pdulen = ((b0 & 0x7f) << 8) | tvb_get_guint8(tvb, offCur + 1);\r\n} else {\r\nc_fieldlen = 1;\r\nc_pdulen = b0;\r\n}\r\nif (tree) {\r\nproto_tree_add_uint(wtp_tree, hf_wtp_header_sub_pdu_size,\r\ntvb, offCur, c_fieldlen, c_pdulen);\r\n}\r\nif (i > 1) {\r\ncol_append_str(pinfo->cinfo, COL_INFO, ", ");\r\n}\r\nwtp_tvb = tvb_new_subset_length(tvb, offCur + c_fieldlen, c_pdulen);\r\ndissect_wtp_common(wtp_tvb, pinfo, wtp_tree);\r\noffCur += c_fieldlen + c_pdulen;\r\ni++;\r\n}\r\nif (tree) {\r\nproto_item_append_text(ti, ", PDU count: %u", i);\r\n}\r\nreturn;\r\n}\r\nfCon = b0 & 0x80;\r\nfRID = retransmission_indicator(b0);\r\npdut = pdu_type(b0);\r\n#ifdef DEBUG\r\nprintf("WTP packet %u: tree = %p, pdu = %s (%u) length: %u\n",\r\npinfo->num, tree,\r\nval_to_str(pdut, vals_wtp_pdu_type, "Unknown PDU type 0x%x"),\r\npdut, tvb_captured_length(tvb));\r\n#endif\r\nreturned_length = g_snprintf(szInfo, SZINFO_SIZE, "WTP %s",\r\nval_to_str(pdut, vals_wtp_pdu_type, "Unknown PDU type 0x%x"));\r\nstr_index += MIN(returned_length, SZINFO_SIZE-str_index);\r\nswitch (pdut) {\r\ncase INVOKE:\r\nfTTR = transmission_trailer(b0);\r\nTID = tvb_get_ntohs(tvb, offCur + 1);\r\npsn = 0;\r\nclsTransaction = transaction_class(tvb_get_guint8(tvb, offCur + 3));\r\nreturned_length = g_snprintf(&szInfo[str_index], SZINFO_SIZE-str_index,\r\n" Class %d", clsTransaction);\r\nstr_index += MIN(returned_length, SZINFO_SIZE-str_index);\r\ncbHeader = 4;\r\nbreak;\r\ncase SEGMENTED_INVOKE:\r\ncase SEGMENTED_RESULT:\r\nfTTR = transmission_trailer(b0);\r\nTID = tvb_get_ntohs(tvb, offCur + 1);\r\npsn = tvb_get_guint8(tvb, offCur + 3);\r\nif (psn != 0) {\r\nreturned_length = g_snprintf(&szInfo[str_index], SZINFO_SIZE-str_index,\r\n" (%u)", psn);\r\nstr_index += MIN(returned_length, SZINFO_SIZE-str_index);\r\n}\r\ncbHeader = 4;\r\nbreak;\r\ncase ABORT:\r\ncbHeader = 4;\r\nbreak;\r\ncase RESULT:\r\nfTTR = transmission_trailer(b0);\r\nTID = tvb_get_ntohs(tvb, offCur + 1);\r\npsn = 0;\r\ncbHeader = 3;\r\nbreak;\r\ncase ACK:\r\ncbHeader = 3;\r\nbreak;\r\ncase NEGATIVE_ACK:\r\nnumMissing = tvb_get_guint8(tvb, offCur + 3);\r\ncbHeader = numMissing + 4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\nif (fRID) {\r\ng_snprintf(&szInfo[str_index], SZINFO_SIZE-str_index, " R" );\r\n};\r\nif (tree) {\r\n#ifdef DEBUG\r\nfprintf(stderr, "dissect_wtp: cbHeader = %d\n", cbHeader);\r\n#endif\r\nti = proto_tree_add_item(tree, proto_wtp, tvb, offCur, 0, ENC_NA);\r\n#ifdef DEBUG\r\nfprintf(stderr, "dissect_wtp: (7) Returned from proto_tree_add_item\n");\r\n#endif\r\nwtp_tree = proto_item_add_subtree(ti, ett_wtp);\r\n#ifdef DEBUG\r\nfprintf(stderr, "dissect_wtp: cbHeader = %d\n", cbHeader);\r\nfprintf(stderr, "dissect_wtp: offCur = %d\n", offCur);\r\n#endif\r\nproto_tree_add_item(\r\nwtp_tree,\r\nhf_wtp_header_flag_continue,\r\ntvb,\r\noffCur,\r\n1,\r\nb0\r\n);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_pdu_type, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nswitch(pdut) {\r\ncase INVOKE:\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_Trailer, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_RID, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID_response, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_Inv_version , tvb, offCur + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_Inv_flag_TIDNew, tvb, offCur + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_Inv_flag_UP, tvb, offCur + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_Inv_Reserved, tvb, offCur + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_Inv_TransactionClass, tvb, offCur + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(ti,\r\n", PDU: Invoke (%u)"\r\n", Transaction Class: %s (%u)",\r\nINVOKE,\r\nval_to_str_const(clsTransaction, vals_transaction_classes, "Undefined"),\r\nclsTransaction);\r\nbreak;\r\ncase RESULT:\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_Trailer, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_RID, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID_response, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, ", PDU: Result (%u)", RESULT);\r\nbreak;\r\ncase ACK:\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_Ack_flag_TVETOK, tvb, offCur, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_RID, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID_response, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_item_append_text(ti, ", PDU: ACK (%u)", ACK);\r\nbreak;\r\ncase ABORT:\r\nabortType = tvb_get_guint8 (tvb, offCur) & 0x07;\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_Abort_type , tvb, offCur , 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID_response, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nif (abortType == PROVIDER) {\r\nguint8 reason = tvb_get_guint8(tvb, offCur + 3);\r\nproto_tree_add_item( wtp_tree, hf_wtp_header_Abort_reason_provider , tvb, offCur + 3 , 1, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(ti,\r\n", PDU: Abort (%u)"\r\n", Type: Provider (%u)"\r\n", Reason: %s (%u)",\r\nABORT,\r\nPROVIDER,\r\nval_to_str_const(reason, vals_abort_reason_provider, "Undefined"),\r\nreason);\r\n}\r\nelse if (abortType == USER) {\r\nguint8 reason = tvb_get_guint8(tvb, offCur + 3);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_Abort_reason_user , tvb, offCur + 3 , 1, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(ti,\r\n", PDU: Abort (%u)"\r\n", Type: User (%u)"\r\n", Reason: %s (%u)",\r\nABORT,\r\nPROVIDER,\r\nval_to_str_ext_const(reason, &vals_wsp_reason_codes_ext, "Undefined"),\r\nreason);\r\n}\r\nbreak;\r\ncase SEGMENTED_INVOKE:\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_Trailer, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_RID, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID_response, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_sequence_number , tvb, offCur + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(ti,\r\n", PDU: Segmented Invoke (%u)"\r\n", Packet Sequence Number: %u",\r\nSEGMENTED_INVOKE, psn);\r\nbreak;\r\ncase SEGMENTED_RESULT:\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_Trailer, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_RID, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID_response, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_sequence_number , tvb, offCur + 3, 1, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(ti,\r\n", PDU: Segmented Result (%u)"\r\n", Packet Sequence Number: %u",\r\nSEGMENTED_RESULT, psn);\r\nbreak;\r\ncase NEGATIVE_ACK:\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_RID, tvb, offCur, 1, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID_response, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_flag_TID, tvb, offCur + 1, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_missing_packets , tvb, offCur + 3, 1, ENC_LITTLE_ENDIAN);\r\nfor (i = 0; i < numMissing; i++)\r\n{\r\nproto_tree_add_item(wtp_tree, hf_wtp_header_sequence_number, tvb, offCur + 4 + i, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nproto_item_append_text(ti,\r\n", PDU: Negative Ack (%u)"\r\n", Missing Packets: %u",\r\nNEGATIVE_ACK, numMissing);\r\nbreak;\r\ndefault:\r\nbreak;\r\n};\r\nif (fRID) {\r\nproto_item_append_text(ti, ", Retransmission");\r\n}\r\n} else {\r\n#ifdef DEBUG\r\nfprintf(stderr, "dissect_wtp: (4) tree was %p\n", tree);\r\n#endif\r\n}\r\nif (fCon) {\r\nguint8 tCon;\r\nguint8 tByte;\r\nguint tpiLen;\r\ntvbuff_t *tmp_tvb;\r\nvHeader = 0;\r\ndo {\r\ntByte = tvb_get_guint8(tvb, offCur + cbHeader + vHeader);\r\ntCon = tByte & 0x80;\r\nif (tByte & 0x04)\r\ntpiLen = 2 + tvb_get_guint8(tvb, offCur + cbHeader + vHeader + 1);\r\nelse\r\ntpiLen = 1 + (tByte & 0x03);\r\nif (tree)\r\n{\r\ntmp_tvb = tvb_new_subset_length(tvb, offCur + cbHeader + vHeader, tpiLen);\r\nwtp_handle_tpi(wtp_tree, tmp_tvb);\r\n}\r\nvHeader += tpiLen;\r\n} while (tCon);\r\n} else {\r\n}\r\nif (tree)\r\nproto_item_set_len(ti, cbHeader + vHeader);\r\n#ifdef DEBUG\r\nfprintf( stderr, "dissect_wtp: cbHeader = %d\n", cbHeader );\r\n#endif\r\ndataOffset = offCur + cbHeader + vHeader;\r\ndataLen = tvb_reported_length_remaining(tvb, dataOffset);\r\nif ((dataLen >= 0) &&\r\n! ((pdut==ACK) || (pdut==NEGATIVE_ACK) || (pdut==ABORT)))\r\n{\r\nif ( ( (pdut == SEGMENTED_INVOKE) || (pdut == SEGMENTED_RESULT)\r\n|| ( ((pdut == INVOKE) || (pdut == RESULT)) && (!fTTR) )\r\n) && tvb_bytes_exist(tvb, dataOffset, dataLen) )\r\n{\r\nfragment_head *fd_wtp = NULL;\r\nguint32 reassembled_in = 0;\r\ngboolean save_fragmented = pinfo->fragmented;\r\npinfo->fragmented = TRUE;\r\nfd_wtp = fragment_add_seq(&wtp_reassembly_table, tvb, dataOffset,\r\npinfo, TID, NULL, psn, dataLen, !fTTR, 0);\r\nwsp_tvb = process_reassembled_data(tvb, dataOffset, pinfo,\r\n"Reassembled WTP", fd_wtp, &wtp_frag_items,\r\nNULL, wtp_tree);\r\n#ifdef DEBUG\r\nprintf("WTP: Packet %u %s -> %d: wsp_tvb = %p, fd_wtp = %p, frame = %u\n",\r\npinfo->num,\r\nfd_wtp ? "Reassembled" : "Not reassembled",\r\nfd_wtp ? fd_wtp->reassembled_in : -1,\r\nwsp_tvb,\r\nfd_wtp\r\n);\r\n#endif\r\nif (fd_wtp) {\r\nreassembled_in = fd_wtp->reassembled_in;\r\nif (pinfo->num == reassembled_in) {\r\ncall_dissector(wsp_handle, wsp_tvb, pinfo, tree);\r\n} else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO,\r\n"%s (WTP payload reassembled in packet %u)",\r\nszInfo, fd_wtp->reassembled_in);\r\nproto_tree_add_item(wtp_tree, hf_wtp_payload, tvb, dataOffset, -1, ENC_NA);\r\n}\r\n} else {\r\ncol_append_fstr(pinfo->cinfo, COL_INFO,\r\n"%s (Unreassembled fragment %u)",\r\nszInfo, psn);\r\nproto_tree_add_item(wtp_tree, hf_wtp_payload, tvb, dataOffset, -1, ENC_NA);\r\n}\r\npinfo->fragmented = save_fragmented;\r\n}\r\nelse if ( ((pdut == INVOKE) || (pdut == RESULT)) && (fTTR) )\r\n{\r\nwsp_tvb = tvb_new_subset_remaining(tvb, dataOffset);\r\ncall_dissector(wsp_handle, wsp_tvb, pinfo, tree);\r\n}\r\nelse\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, szInfo);\r\n}\r\n}\r\nelse\r\n{\r\ncol_append_str(pinfo->cinfo, COL_INFO, szInfo);\r\n}\r\n}\r\nstatic int\r\ndissect_wtp_fromudp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "WTP+WSP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ndissect_wtp_common(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nstatic int\r\ndissect_wtp_fromwtls(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "WTLS+WTP+WSP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ndissect_wtp_common(tvb, pinfo, tree);\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_wtp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_wtp_header_sub_pdu_size,\r\n{ "Sub PDU size", "wtp.sub_pdu_size",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Size of Sub-PDU (bytes)", HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_flag_continue,\r\n{ "Continue Flag", "wtp.continue_flag",\r\nFT_BOOLEAN, 8, TFS( &continue_truth ), 0x80,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_pdu_type,\r\n{ "PDU Type", "wtp.pdu_type",\r\nFT_UINT8, BASE_HEX, VALS( vals_wtp_pdu_type ), 0x78,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_flag_Trailer,\r\n{ "Trailer Flags", "wtp.trailer_flags",\r\nFT_UINT8, BASE_HEX, VALS( vals_transaction_trailer ), 0x06,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_flag_RID,\r\n{ "Re-transmission Indicator", "wtp.RID",\r\nFT_BOOLEAN, 8, TFS( &RID_truth ), 0x01,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_flag_TID_response,\r\n{ "TID Response", "wtp.TID.response",\r\nFT_BOOLEAN, 16, TFS( &tid_response_truth ), 0x8000,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_flag_TID,\r\n{ "Transaction ID", "wtp.TID",\r\nFT_UINT16, BASE_HEX, NULL, 0x7FFF,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_Inv_version,\r\n{ "Version", "wtp.header.version",\r\nFT_UINT8, BASE_HEX, VALS( vals_version ), 0xC0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_Inv_flag_TIDNew,\r\n{ "TIDNew", "wtp.header.TIDNew",\r\nFT_BOOLEAN, 8, TFS( &TIDNew_truth ), 0x20,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_Inv_flag_UP,\r\n{ "U/P flag", "wtp.header.UP",\r\nFT_BOOLEAN, 8, TFS( &UP_truth ), 0x10,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_Inv_Reserved,\r\n{ "Reserved", "wtp.inv.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x0C,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_Inv_TransactionClass,\r\n{ "Transaction Class", "wtp.inv.transaction_class",\r\nFT_UINT8, BASE_HEX, VALS( vals_transaction_classes ), 0x03,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_Ack_flag_TVETOK,\r\n{ "Tve/Tok flag", "wtp.ack.tvetok",\r\nFT_BOOLEAN, 8, TFS( &TVETOK_truth ), 0x04,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_Abort_type,\r\n{ "Abort Type", "wtp.abort.type",\r\nFT_UINT8, BASE_HEX, VALS ( vals_abort_type ), 0x07,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_Abort_reason_provider,\r\n{ "Abort Reason", "wtp.abort.reason.provider",\r\nFT_UINT8, BASE_HEX, VALS ( vals_abort_reason_provider ), 0x00,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_Abort_reason_user,\r\n{ "Abort Reason", "wtp.abort.reason.user",\r\nFT_UINT8, BASE_HEX|BASE_EXT_STRING, &vals_wsp_reason_codes_ext, 0x00,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_sequence_number,\r\n{ "Packet Sequence Number", "wtp.header.sequence",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_header_missing_packets,\r\n{ "Missing Packets", "wtp.header.missing_packets",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_payload,\r\n{ "Payload", "wtp.payload",\r\nFT_BYTES, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL\r\n}\r\n},\r\n#if 0\r\n{ &hf_wtp_header_variable_part,\r\n{ "Header: Variable part", "wtp.header_variable_part",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"Variable part of the header", HFILL\r\n}\r\n},\r\n{ &hf_wtp_data,\r\n{ "Data", "wtp.header_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n#endif\r\n{ &hf_wtp_tpi_type,\r\n{ "TPI", "wtp.tpi",\r\nFT_UINT8, BASE_HEX, VALS(vals_tpi_type), 0x00,\r\n"Identification of the Transport Information Item", HFILL\r\n}\r\n},\r\n{ &hf_wtp_tpi_psn,\r\n{ "Packet sequence number", "wtp.tpi.psn",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\n"Sequence number of this packet", HFILL\r\n}\r\n},\r\n{ &hf_wtp_tpi_opt,\r\n{ "Option", "wtp.tpi.opt",\r\nFT_UINT8, BASE_HEX, VALS(vals_tpi_opt), 0x00,\r\n"The given option for this TPI", HFILL\r\n}\r\n},\r\n{ &hf_wtp_tpi_optval,\r\n{ "Option Value", "wtp.tpi.opt.val",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\n"The value that is supplied with this option", HFILL\r\n}\r\n},\r\n{ &hf_wtp_tpi_info,\r\n{ "Information", "wtp.tpi.info",\r\nFT_NONE, BASE_NONE, NULL, 0x00,\r\n"The information being send by this TPI", HFILL\r\n}\r\n},\r\n{ &hf_wtp_fragment_overlap,\r\n{ "Fragment overlap", "wtp.fragment.overlap",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Fragment overlaps with other fragments", HFILL\r\n}\r\n},\r\n{ &hf_wtp_fragment_overlap_conflict,\r\n{ "Conflicting data in fragment overlap", "wtp.fragment.overlap.conflict",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Overlapping fragments contained conflicting data", HFILL\r\n}\r\n},\r\n{ &hf_wtp_fragment_multiple_tails,\r\n{ "Multiple tail fragments found", "wtp.fragment.multipletails",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Several tails were found when defragmenting the packet", HFILL\r\n}\r\n},\r\n{ &hf_wtp_fragment_too_long_fragment,\r\n{ "Fragment too long", "wtp.fragment.toolongfragment",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Fragment contained data past end of packet", HFILL\r\n}\r\n},\r\n{ &hf_wtp_fragment_error,\r\n{ "Defragmentation error", "wtp.fragment.error",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"Defragmentation error due to illegal fragments", HFILL\r\n}\r\n},\r\n{ &hf_wtp_fragment_count,\r\n{ "Fragment count", "wtp.fragment.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_reassembled_in,\r\n{ "Reassembled in", "wtp.reassembled.in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"WTP fragments are reassembled in the given packet", HFILL\r\n}\r\n},\r\n{ &hf_wtp_reassembled_length,\r\n{ "Reassembled WTP length", "wtp.reassembled.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The total length of the reassembled payload", HFILL\r\n}\r\n},\r\n{ &hf_wtp_fragment,\r\n{ "WTP Fragment", "wtp.fragment",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_wtp_fragments,\r\n{ "WTP Fragments", "wtp.fragments",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_wtp,\r\n&ett_wtp_sub_pdu_tree,\r\n&ett_header,\r\n&ett_tpilist,\r\n&ett_wsp_fragments,\r\n&ett_wtp_fragment,\r\n};\r\nproto_wtp = proto_register_protocol(\r\n"Wireless Transaction Protocol",\r\n"WTP",\r\n"wtp"\r\n);\r\nproto_register_field_array(proto_wtp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nregister_dissector("wtp-wtls", dissect_wtp_fromwtls, proto_wtp);\r\nregister_dissector("wtp-udp", dissect_wtp_fromudp, proto_wtp);\r\nregister_init_routine(wtp_defragment_init);\r\nregister_cleanup_routine(wtp_defragment_cleanup);\r\n}\r\nvoid\r\nproto_reg_handoff_wtp(void)\r\n{\r\ndissector_handle_t wtp_fromudp_handle;\r\nwsp_handle = find_dissector_add_dependency("wsp-co", proto_wtp);\r\nwtp_fromudp_handle = find_dissector("wtp-udp");\r\ndissector_add_uint("udp.port", UDP_PORT_WTP_WSP, wtp_fromudp_handle);\r\ndissector_add_uint("gsm_sms_ud.udh.port", UDP_PORT_WTP_WSP, wtp_fromudp_handle);\r\ndissector_add_uint("gsm_sms.udh.port", UDP_PORT_WTP_WSP, wtp_fromudp_handle);\r\n}
