static void\r\nfor_req_pseudo_meas(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset = offset;\r\nSHORT_DATA_CHECK(len, 3);\r\nproto_tree_add_item(tree, hf_ansi_801_pref_resp_qual, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_num_fixes, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_t_betw_fixes, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_offset_req, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved_24_7, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_req_pilot_ph_meas(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nSHORT_DATA_CHECK(len, 3);\r\nsaved_offset = offset;\r\nproto_tree_add_item(tree, hf_ansi_801_pref_resp_qual, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_num_fixes, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_t_betw_fixes, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_offset_req, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_desired_pilot_phase_resolution, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved_24_7, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_req_loc_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nSHORT_DATA_CHECK(len, 3);\r\nsaved_offset = offset;\r\nproto_tree_add_item(tree, hf_ansi_801_pref_resp_qual, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_num_fixes, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_t_betw_fixes, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_for_req_loc_height_information, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_for_req_loc_clock_correction_for_gps_time, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_for_req_loc_velocity_information, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved24_3, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_req_time_off_meas(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint8 oct;\r\nguint32 saved_offset;\r\nSHORT_DATA_CHECK(len, 1);\r\nsaved_offset = offset;\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_ansi_801_use_action_time_indicator, tvb, offset, 1, ENC_NA);\r\nif (oct & 0x80)\r\n{\r\nproto_tree_add_item(tree, hf_ansi_801_action_time, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_01, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_7F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_req_cancel(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint8 oct;\r\nguint32 saved_offset;\r\nconst gchar *str = NULL;\r\nSHORT_DATA_CHECK(len, 1);\r\nsaved_offset = offset;\r\noct = tvb_get_guint8(tvb, offset);\r\nstr = val_to_str_const((oct & 0xf0) >> 4, for_req_type_strings, "Reserved");\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_cancellation_type, tvb, offset, 1,\r\noct, "(%u) %s", (oct & 0xf0) >> 4, str);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_0F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_reject(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint8 oct;\r\nguint32 saved_offset;\r\nconst gchar *str = NULL;\r\nsaved_offset = offset;\r\nSHORT_DATA_CHECK(len, 1);\r\noct = tvb_get_guint8(tvb, offset);\r\nstr = val_to_str_const((oct & 0xf0) >> 4, rev_req_type_strings, "Reserved");\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_reject_request_type, tvb, offset, 1, oct,\r\n"(%u) %s", (oct & 0xf0) >> 4, str);\r\nswitch ((oct & 0x0e) >> 1)\r\n{\r\ncase 0x00: str = "Capability not supported by the base station"; break;\r\ncase 0x01: str = "Capability normally supported by the base station but temporarily not available or not enabled"; break;\r\ndefault: str = "Reserved"; break;\r\n}\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_reject_reason, tvb, offset, 1, oct, "%s", str);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_01, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_pr_bs_cap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint8 oct;\r\nguint32 saved_offset;\r\nsaved_offset = offset;\r\nSHORT_DATA_CHECK(len, 2);\r\nproto_tree_add_item(tree, hf_ansi_801_bs_ls_rev, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_gps_capability_indicator, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_afltc_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\noct = tvb_get_guint8(tvb, offset);\r\nif (oct == 0x00)\r\n{\r\nproto_tree_add_uint_format(tree, hf_ansi_801_apdc_id, tvb, offset, 1, 0,\r\n"APDC_ID: Autonomous position determination capability indicator: None");\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(tree, hf_ansi_801_apdc_id, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_pr_gps_sense_ass(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nsaved_offset = offset;\r\nSHORT_DATA_CHECK(len, 4);\r\nproto_tree_add_item(tree, hf_ansi_801_ref_bit_num, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_num_dr_p, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_ansi_801_dr_size, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(tree, hf_ansi_801_part_num, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_total_parts, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_data_records, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_pr_gps_almanac(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset = offset;\r\nconst gint *fields[] = {\r\n&hf_ansi_801_num_sv_p32,\r\n&hf_ansi_801_week_num,\r\n&hf_ansi_801_toa,\r\n&hf_ansi_801_part_num32,\r\n&hf_ansi_801_total_parts32,\r\nNULL\r\n};\r\nSHORT_DATA_CHECK(len, 4);\r\nproto_tree_add_bitmask_list(tree, tvb, offset, 4, fields, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_pr_gps_nav_msg_bits(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset = offset;\r\nconst gint *fields[] = {\r\n&hf_ansi_801_num_sv_p16,\r\n&hf_ansi_801_part_num16,\r\n&hf_ansi_801_total_parts16,\r\nNULL\r\n};\r\nSHORT_DATA_CHECK(len, 2);\r\nproto_tree_add_bitmask_list(tree, tvb, offset, 2, fields, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\npr_loc_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 bit_offset, spare_bits;\r\nguint32 value;\r\nfloat fl_value;\r\nguint32 saved_offset;\r\nguint64 fix_type, velocity_incl, clock_incl, height_incl;\r\nconst gchar *str = NULL;\r\nSHORT_DATA_CHECK(len, 11);\r\nsaved_offset = offset;\r\nbit_offset = offset << 3;\r\nvalue = tvb_get_bits16(tvb, bit_offset, 14, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint_bits_format_value(tree, hf_ansi_801_time_ref_cdma, tvb, bit_offset, 14, value * 50,\r\n"%u frames (0x%04x)", value * 50, value);\r\nbit_offset += 14;\r\nvalue = tvb_get_bits32(tvb, bit_offset, 25, ENC_BIG_ENDIAN);\r\nfl_value = (float)(-90.0 + ((float)value * 180 / 33554432));\r\nproto_tree_add_float_bits_format_value(tree, hf_ansi_801_lat, tvb, bit_offset, 25, fl_value,\r\n"%.5f degrees %s (0x%08x)", fabs(fl_value), fl_value < 0 ? "South" : "North", value);\r\nbit_offset += 25;\r\nvalue = tvb_get_bits32(tvb, bit_offset, 26, ENC_BIG_ENDIAN);\r\nfl_value = (float)(-180.0 + ((float)value * 180 / 33554432));\r\nproto_tree_add_float_bits_format_value(tree, hf_ansi_801_long, tvb, bit_offset, 26, fl_value,\r\n"%.5f degrees %s (0x%08x)", fabs(fl_value), fl_value < 0 ? "West" : "East", value);\r\nbit_offset += 26;\r\nvalue = tvb_get_bits8(tvb, bit_offset, 4);\r\nfl_value = (float)(5.625 * value);\r\nproto_tree_add_float_bits_format_value(tree, hf_ansi_801_loc_uncrtnty_ang, tvb, bit_offset, 4, fl_value,\r\n"%.5f degrees (0x%02x)", fl_value, value);\r\nbit_offset += 4;\r\nvalue = tvb_get_bits8(tvb, bit_offset, 5);\r\nswitch (value)\r\n{\r\ncase 0x1e: str = "> 12288.00 meters"; break;\r\ncase 0x1f: str = "Not computable"; break;\r\ndefault:\r\nfl_value = (float)(0.5f * (1 << (value >> 1)));\r\nif (value & 0x01)\r\nfl_value *= 1.5f;\r\nstr = wmem_strdup_printf(wmem_packet_scope(), "%.2f meters", fl_value);\r\n}\r\nproto_tree_add_uint_bits_format_value(tree, hf_ansi_801_loc_uncrtnty_a, tvb, bit_offset, 5, value,\r\n"%s (0x%02x)", str, value);\r\nbit_offset += 5;\r\nvalue = tvb_get_bits8(tvb, bit_offset, 5);\r\nswitch (value)\r\n{\r\ncase 0x1e: str = "> 12288.00 meters"; break;\r\ncase 0x1f: str = "Not computable"; break;\r\ndefault:\r\nfl_value = (float)(0.5f * (1 << (value >> 1)));\r\nif (value & 0x01)\r\nfl_value *= 1.5f;\r\nstr = wmem_strdup_printf(wmem_packet_scope(), "%.2f meters", fl_value);\r\n}\r\nproto_tree_add_uint_bits_format_value(tree, hf_ansi_801_loc_uncrtnty_p, tvb, bit_offset, 5, value,\r\n"%s (0x%02x)", str, value);\r\nbit_offset += 5;\r\nproto_tree_add_bits_ret_val(tree, hf_ansi_801_fix_type, tvb, bit_offset++, 1, &fix_type, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_ret_val(tree, hf_ansi_801_velocity_incl, tvb, bit_offset++, 1, &velocity_incl, ENC_BIG_ENDIAN);\r\nif(velocity_incl)\r\n{\r\nvalue = tvb_get_bits16(tvb, bit_offset, 9, ENC_BIG_ENDIAN);\r\nfl_value = (float)(0.25 * value);\r\nproto_tree_add_float_bits_format_value(tree, hf_ansi_801_velocity_hor, tvb, bit_offset, 9, fl_value,\r\n"%.2f m/s (0x%04x)", fl_value, value);\r\nbit_offset += 9;\r\nvalue = tvb_get_bits16(tvb, bit_offset, 10, ENC_BIG_ENDIAN);\r\nfl_value = (float)value * 360 / 1024;\r\nproto_tree_add_float_bits_format_value(tree, hf_ansi_801_heading, tvb, bit_offset, 10, fl_value,\r\n"%.3f degrees (0x%04x)", fl_value, value);\r\nbit_offset += 10;\r\nif(fix_type)\r\n{\r\nvalue = tvb_get_bits8(tvb, bit_offset, 8);\r\nfl_value = (float)(-64 + 0.5 * value);\r\nproto_tree_add_float_bits_format_value(tree, hf_ansi_801_velocity_ver, tvb, bit_offset, 8, fl_value,\r\n"%.1f m/s (0x%02x)", fl_value, value);\r\nbit_offset += 8;\r\n}\r\n}\r\nproto_tree_add_bits_ret_val(tree, hf_ansi_801_clock_incl, tvb, bit_offset++, 1, &clock_incl, ENC_BIG_ENDIAN);\r\nif(clock_incl)\r\n{\r\nvalue = tvb_get_bits32(tvb, bit_offset, 18, ENC_BIG_ENDIAN);\r\nproto_tree_add_int_bits_format_value(tree, hf_ansi_801_clock_bias, tvb, bit_offset, 18, (gint32)value - 13000,\r\n"%d ns (0x%06x)", (gint32)value - 13000, value);\r\nbit_offset += 18;\r\nvalue = tvb_get_bits16(tvb, bit_offset, 16, ENC_BIG_ENDIAN);\r\nproto_tree_add_int_bits_format_value(tree, hf_ansi_801_clock_drift, tvb, bit_offset, 16, (gint16)value,\r\n"%d ppb (ns/s) (0x%04x)", (gint16)value, value);\r\nbit_offset += 16;\r\n}\r\nproto_tree_add_bits_ret_val(tree, hf_ansi_801_height_incl, tvb, bit_offset++, 1, &height_incl, ENC_BIG_ENDIAN);\r\nif(height_incl)\r\n{\r\nvalue = tvb_get_bits16(tvb, bit_offset, 14, ENC_BIG_ENDIAN);\r\nproto_tree_add_int_bits_format_value(tree, hf_ansi_801_height, tvb, bit_offset, 14, (gint32)value - 500,\r\n"%d m (0x%04x)", (gint32)value - 500, value);\r\nbit_offset += 14;\r\nvalue = tvb_get_bits8(tvb, bit_offset, 5);\r\nswitch (value)\r\n{\r\ncase 0x1e: str = "> 12288.00 meters"; break;\r\ncase 0x1f: str = "Not computable"; break;\r\ndefault:\r\nfl_value = (float)(0.5f * (1 << (value >> 1)));\r\nif (value & 0x01)\r\nfl_value *= 1.5f;\r\nstr = wmem_strdup_printf(wmem_packet_scope(), "%.2f meters", fl_value);\r\n}\r\nproto_tree_add_uint_bits_format_value(tree, hf_ansi_801_loc_uncrtnty_v, tvb, bit_offset, 5, value,\r\n"%s (0x%02x)", str, value);\r\nbit_offset += 5;\r\n}\r\nif(bit_offset & 0x07)\r\n{\r\nspare_bits = 8 - (bit_offset & 0x07);\r\nproto_tree_add_bits_item(tree, hf_ansi_801_reserved_bits, tvb, bit_offset, spare_bits, ENC_BIG_ENDIAN);\r\nbit_offset += spare_bits;\r\n}\r\noffset = bit_offset >> 3;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_pr_loc_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\npr_loc_response(tvb, pinfo, tree, len, offset);\r\n}\r\nstatic void\r\nfor_pr_gps_sat_health(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 bit_offset, spare_bits;\r\nguint32 i;\r\nguint32 saved_offset, num_bad_sv, bad_sv_prn_num;\r\nguint64 bad_sv_present;\r\nSHORT_DATA_CHECK(len, 1);\r\nsaved_offset = offset;\r\nbit_offset = offset << 3;\r\nproto_tree_add_bits_ret_val(tree, hf_ansi_801_bad_sv_present, tvb, bit_offset++, 1, &bad_sv_present, ENC_BIG_ENDIAN);\r\nif (bad_sv_present)\r\n{\r\nnum_bad_sv = tvb_get_bits8(tvb, bit_offset, 4) + 1;\r\nproto_tree_add_uint_bits_format_value(tree, hf_ansi_801_num_bad_sv, tvb, bit_offset, 4, num_bad_sv,\r\n"%u", num_bad_sv);\r\nbit_offset += 4;\r\nfor (i=0; i < num_bad_sv; i++)\r\n{\r\nbad_sv_prn_num = tvb_get_bits8(tvb, bit_offset, 5) + 1;\r\nproto_tree_add_uint_bits_format_value(tree, hf_ansi_801_bad_sv_prn_num, tvb, bit_offset, 5, bad_sv_prn_num,\r\n"%u", bad_sv_prn_num);\r\nbit_offset += 5;\r\n}\r\n}\r\nif(bit_offset & 0x07)\r\n{\r\nspare_bits = 8 - (bit_offset & 0x07);\r\nproto_tree_add_bits_item(tree, hf_ansi_801_reserved_bits, tvb, bit_offset, spare_bits, ENC_BIG_ENDIAN);\r\nbit_offset += spare_bits;\r\n}\r\noffset = bit_offset >> 3;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_req_gps_acq_ass(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nguint32 bit_offset;\r\nSHORT_DATA_CHECK(len, 1);\r\nsaved_offset = offset;\r\nbit_offset = offset << 3;\r\nproto_tree_add_bits_item(tree, hf_ansi_801_dopp_req, tvb, bit_offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(tree, hf_ansi_801_add_dopp_req, tvb, bit_offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(tree, hf_ansi_801_code_ph_par_req, tvb, bit_offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(tree, hf_ansi_801_az_el_req, tvb, bit_offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_bits_item(tree, hf_ansi_801_reserved_bits, tvb, bit_offset, 4, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_req_gps_loc_ass(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nSHORT_DATA_CHECK(len, 1);\r\nsaved_offset = offset;\r\nproto_tree_add_item(tree, hf_ansi_801_coordinate_type_requested, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_7F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_req_bs_alm(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nSHORT_DATA_CHECK(len, 1);\r\nsaved_offset = offset;\r\nproto_tree_add_item(tree, hf_ansi_801_extended_base_station_almanac, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_7F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_req_gps_ephemeris(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nSHORT_DATA_CHECK(len, 1);\r\nsaved_offset = offset;\r\nproto_tree_add_item(tree, hf_ansi_801_alpha_and_beta_parameters, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_7F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_req_gps_nav_msg_bits(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nSHORT_DATA_CHECK(len, 1);\r\nsaved_offset = offset;\r\nproto_tree_add_item(tree, hf_ansi_801_subframes_4_and_5, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_7F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_req_loc_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nSHORT_DATA_CHECK(len, 1);\r\nsaved_offset = offset;\r\nproto_tree_add_item(tree, hf_ansi_801_rev_req_loc_height_information, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_rev_req_loc_clock_correction_for_gps_time, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_rev_req_loc_velocity_information, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_1F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_req_gps_alm_correction(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nguint8 oct;\r\nSHORT_DATA_CHECK(len, 2);\r\nsaved_offset = offset;\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_time_of_almanac, tvb, offset, 1, oct,\r\n"%d (in units of 4096 seconds)", oct);\r\noffset++;\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_gps_week_number, tvb, offset, 1, oct,\r\n"%d (8 least significant bits)", oct);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_reject(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint8 oct;\r\nguint32 saved_offset;\r\nconst gchar *str = NULL;\r\nsaved_offset = offset;\r\nSHORT_DATA_CHECK(len, 1);\r\noct = tvb_get_guint8(tvb, offset);\r\nstr = val_to_str_const((oct & 0xf0) >> 4, for_req_type_strings, "Reserved");\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_reject_request_type, tvb, offset, 1, oct,\r\n"(%u) %s", (oct & 0xf0) >> 4, str);\r\nswitch ((oct & 0x0e) >> 1)\r\n{\r\ncase 0x00: str = "Capability not supported by the mobile station"; break;\r\ncase 0x01: str = "Capability normally supported by the mobile station but temporarily not available or not enabled"; break;\r\ndefault: str = "Reserved"; break;\r\n}\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_reject_reason, tvb, offset, 1,\r\noct, "%s", str);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_01, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_pr_ms_information(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 value;\r\nguint32 saved_offset;\r\nconst gchar *str = NULL;\r\nproto_item* ti;\r\nproto_tree *gps_tree, *loc_tree;\r\nsaved_offset = offset;\r\nSHORT_DATA_CHECK(len, 5);\r\nvalue = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_ansi_801_ms_ls_rev, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_ms_mode, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nswitch (value & 0x003f)\r\n{\r\ncase 0x00: str = "Full Chip Measurement Capability"; break;\r\ncase 0x01: str = "Half Chip Measurement Capability"; break;\r\ncase 0x02: str = "Quarter Chip Measurement Capability"; break;\r\ncase 0x03: str = "Eighth Chip Measurement Capability"; break;\r\ncase 0x04: str = "One Sixteenth Chip Measurement Capability"; break;\r\ndefault: str = "Reserved"; break;\r\n}\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_pilot_ph_cap, tvb, offset, 2,\r\nvalue, "(%u) %s", value & 0x3f, str);\r\noffset += 2;\r\nti = proto_tree_add_item(tree, hf_ansi_801_gps_acq_cap, tvb, offset, 3, ENC_BIG_ENDIAN);\r\ngps_tree = proto_item_add_subtree(ti, ett_gps);\r\nproto_tree_add_item(gps_tree, hf_ansi_801_reserved_24_F80000, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(gps_tree, hf_ansi_801_gps_autonomous_acquisition_capable, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(gps_tree, hf_ansi_801_gps_almanac_correction, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(gps_tree, hf_ansi_801_gps_navigation_message_bits, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(gps_tree, hf_ansi_801_gps_ephemeris, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(gps_tree, hf_ansi_801_gps_almanac, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(gps_tree, hf_ansi_801_gps_sensitivity_assistance, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(gps_tree, hf_ansi_801_gps_acquisition_assistance, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nti = proto_tree_add_item(tree, hf_ansi_801_loc_calc_cap, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nloc_tree = proto_item_add_subtree(ti, ett_loc);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_pre_programmed_location, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_reserved_24_700, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_hybrid_gps_and_aflt_lcc, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_autonomous_location_calculation_capable, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_lcc_using_gps_almanac_correction, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_lcc_using_gps_ephemeris_assistance, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_lcc_using_gps_almanac_assistance, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_aflt_lcc, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_lcc_using_location_assistance_cartesian, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(loc_tree, hf_ansi_801_lcc_capable_using_location_assistance_spherical, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_pr_loc_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\npr_loc_response(tvb, pinfo, tree, len, offset);\r\n}\r\nstatic void\r\nrev_pr_time_off_meas(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint32 saved_offset;\r\nsaved_offset = offset;\r\nSHORT_DATA_CHECK(len, 6);\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_time_ref_ms, tvb, offset, 3, tvb_get_ntoh24(tvb, offset),\r\n"The time of validity of the parameters reported in this response element.");\r\noffset += 3;\r\nproto_tree_add_item(tree, hf_ansi_801_ref_pn, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_mob_sys_t_offset, tvb, offset, 3, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved24_1, tvb, offset, 3, ENC_BIG_ENDIAN);\r\noffset += 3;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nrev_pr_can_ack(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint len, guint32 offset)\r\n{\r\nguint8 oct;\r\nguint32 saved_offset;\r\nconst gchar *str;\r\nsaved_offset = offset;\r\nSHORT_DATA_CHECK(len, 1);\r\noct = tvb_get_guint8(tvb, offset);\r\nstr = val_to_str_const((oct & 0xf0) >> 4, for_req_type_strings, "Reserved");\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_cancellation_type, tvb, offset, 1, oct,\r\n"(%u) %s", (oct & 0xf0) >> 4, str);\r\nproto_tree_add_item(tree, hf_ansi_801_no_outstanding_request_element, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_07, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nEXTRANEOUS_DATA_CHECK(len, offset - saved_offset);\r\n}\r\nstatic void\r\nfor_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 *offset_p, guint8 pd_msg_type)\r\n{\r\nguint32 offset;\r\nguint8 oct;\r\nconst gchar *str = NULL;\r\ngint idx;\r\nproto_tree *subtree;\r\nproto_item *item;\r\noffset = *offset_p;\r\noct = tvb_get_guint8(tvb, offset);\r\nif (pd_msg_type == 0x00)\r\n{\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_F0, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nstr = try_val_to_str_idx(oct & 0x0f, for_req_type_strings, &idx);\r\nif (str == NULL)\r\n{\r\nreturn;\r\n}\r\nitem = proto_tree_add_uint_format_value(tree, hf_ansi_801_for_req_type, tvb, offset, 1,\r\noct & 0x0f, "%s (%u)", str, oct & 0x0f);\r\n}\r\nelse\r\n{\r\nreturn;\r\n}\r\nsubtree = proto_item_add_subtree(item, ett_for_req_type[idx]);\r\noffset++;\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(subtree, hf_ansi_801_for_request_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif (oct > 0)\r\n{\r\nif (for_req_type_fcn[idx] != NULL)\r\n{\r\n(*for_req_type_fcn[idx])(tvb, pinfo, subtree, oct, offset);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(subtree, hf_ansi_801_data, tvb, offset, oct, ENC_NA);\r\n}\r\n}\r\n*offset_p = offset + oct;\r\n}\r\nstatic void\r\nfor_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 *offset_p)\r\n{\r\nguint32 offset;\r\nguint8 oct;\r\nconst gchar *str = NULL;\r\ngint idx;\r\nproto_tree *subtree;\r\nproto_item *item;\r\noffset = *offset_p;\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_E0, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_unsolicited_response_indicator, tvb, offset, 1, ENC_NA);\r\nstr = try_val_to_str_idx(oct & 0x0f, for_rsp_type_strings, &idx);\r\nif (str == NULL)\r\n{\r\nreturn;\r\n}\r\nitem = proto_tree_add_uint_format_value(tree, hf_ansi_801_for_rsp_type, tvb, offset, 1,\r\noct & 0x0f, "%s (%u)", str, oct & 0x0f);\r\nsubtree = proto_item_add_subtree(item, ett_for_rsp_type[idx]);\r\noffset++;\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(subtree, hf_ansi_801_for_response_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif (for_rsp_type_fcn[idx] != NULL)\r\n{\r\n(*for_rsp_type_fcn[idx])(tvb, pinfo, subtree, oct, offset);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(subtree, hf_ansi_801_data, tvb, offset, oct, ENC_NA);\r\n}\r\n*offset_p = offset + oct;\r\n}\r\nstatic void\r\nrev_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 *offset_p, guint8 pd_msg_type)\r\n{\r\nguint32 offset;\r\nguint8 oct;\r\nconst gchar *str = NULL;\r\ngint idx;\r\nproto_tree *subtree;\r\nproto_item *item;\r\noffset = *offset_p;\r\noct = tvb_get_guint8(tvb, offset);\r\nif (pd_msg_type == 0x00)\r\n{\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_F0, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nstr = try_val_to_str_idx(oct & 0x0f, rev_req_type_strings, &idx);\r\nif (str == NULL)\r\n{\r\nreturn;\r\n}\r\nitem = proto_tree_add_uint_format_value(tree, hf_ansi_801_rev_req_type, tvb, offset, 1,\r\noct & 0x0f, "%s (%u)", str, oct & 0x0f);\r\n}\r\nelse\r\n{\r\nreturn;\r\n}\r\nsubtree = proto_item_add_subtree(item, ett_rev_req_type[idx]);\r\noffset++;\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(subtree, hf_ansi_801_rev_request_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif (rev_req_type_fcn[idx] != NULL)\r\n{\r\n(*rev_req_type_fcn[idx])(tvb, pinfo, subtree, oct, offset);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(subtree, hf_ansi_801_data, tvb, offset, oct, ENC_NA);\r\n}\r\n*offset_p = offset + oct;\r\n}\r\nstatic void\r\nrev_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 *offset_p)\r\n{\r\nguint32 offset;\r\nguint8 oct;\r\nconst gchar *str = NULL;\r\ngint idx;\r\nproto_tree *subtree;\r\nproto_item *item;\r\noffset = *offset_p;\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(tree, hf_ansi_801_reserved8_E0, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_unsolicited_response_indicator, tvb, offset, 1, ENC_NA);\r\nstr = try_val_to_str_idx(oct & 0x0f, rev_rsp_type_strings, &idx);\r\nif (str == NULL)\r\n{\r\nreturn;\r\n}\r\nitem = proto_tree_add_uint_format_value(tree, hf_ansi_801_rev_rsp_type, tvb, offset, 1,\r\noct & 0x0f, "%s (%u)", str, oct & 0x0f);\r\nsubtree = proto_item_add_subtree(item, ett_rev_rsp_type[idx]);\r\noffset++;\r\noct = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_item(subtree, hf_ansi_801_rev_response_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nif (rev_rsp_type_fcn[idx] != NULL)\r\n{\r\n(*rev_rsp_type_fcn[idx])(tvb, pinfo, subtree, oct, offset);\r\n}\r\nelse\r\n{\r\nproto_tree_add_item(subtree, hf_ansi_801_data, tvb, offset, oct, ENC_NA);\r\n}\r\n*offset_p = offset + oct;\r\n}\r\nstatic void\r\ndissect_ansi_801_for_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint32 value;\r\nguint32 offset;\r\nguint8 oct, num_req, num_rsp, pd_msg_type;\r\nguint rem_len;\r\nconst gchar *str = NULL;\r\nproto_item *hidden_item;\r\noffset = 0;\r\nproto_tree_add_item(tree, hf_ansi_801_session_start, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_session_end, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_session_source, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_for_sess_tag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nhidden_item = proto_tree_add_item(tree, hf_ansi_801_sess_tag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\noffset++;\r\noct = tvb_get_guint8(tvb, offset);\r\npd_msg_type = oct;\r\nswitch (pd_msg_type)\r\n{\r\ncase 0x00: str = "Position Determination Data Message"; break;\r\ncase 0x01: str = "Position Determination Data Message"; break;\r\ncase 0xff: str = "Reserved"; break;\r\ndefault:\r\nif (pd_msg_type < 0xc0)\r\n{\r\nstr = "Reserved for future standardization";\r\n}\r\nelse\r\n{\r\nstr = "Available for manufacturer-specific Position Determination "\r\n"Data Message definition as specified in TSB-58";\r\n}\r\nbreak;\r\n}\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_pd_message_type, tvb, offset, 1, pd_msg_type,\r\n"%s (%u)", str, pd_msg_type);\r\noffset++;\r\nif ((pd_msg_type != 0x00) &&\r\n(pd_msg_type != 0x01))\r\n{\r\nproto_tree_add_item(tree, hf_ansi_801_proprietary_data, tvb, offset, -1, ENC_NA);\r\nreturn;\r\n}\r\nif (pd_msg_type == 0x01)\r\n{\r\nvalue = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_ansi_801_pd_message_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_regulatory_services_indicator, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nnum_req = value & 0x000f;\r\nproto_tree_add_item(tree, hf_ansi_801_for_message_number_requests16, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\noct = tvb_get_guint8(tvb, offset);\r\nnum_rsp = oct & 0xf0;\r\nproto_tree_add_item(tree, hf_ansi_801_for_message_number_responsesF0, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\n}\r\nelse\r\n{\r\noct = tvb_get_guint8(tvb, offset);\r\nnum_req = (oct & 0xf0) >> 4;\r\nnum_rsp = oct & 0x0f;\r\nproto_tree_add_item(tree, hf_ansi_801_for_message_number_requests8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_for_message_number_responses0F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\n}\r\noffset++;\r\nrem_len = tvb_reported_length_remaining(tvb, offset);\r\nwhile ((num_req > 0) &&\r\n(rem_len >= 2))\r\n{\r\nfor_request(tvb, pinfo, tree, &offset, pd_msg_type);\r\nrem_len = tvb_reported_length_remaining(tvb, offset);\r\nnum_req--;\r\n}\r\nif (num_req != 0)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_ansi_801_short_data, tvb, offset, -1);\r\nreturn;\r\n}\r\nwhile ((num_rsp > 0) &&\r\n(rem_len >= 2))\r\n{\r\nfor_response(tvb, pinfo, tree, &offset);\r\nrem_len = tvb_reported_length_remaining(tvb, offset);\r\nnum_rsp--;\r\n}\r\nif (num_rsp != 0)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_ansi_801_short_data, tvb, offset, -1);\r\nreturn;\r\n}\r\nif (rem_len > 0)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_ansi_801_extraneous_data, tvb, offset, rem_len);\r\n}\r\n}\r\nstatic void\r\ndissect_ansi_801_rev_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint32 value;\r\nguint32 offset;\r\nguint8 oct, num_req, num_rsp, pd_msg_type;\r\nguint rem_len;\r\nconst gchar *str = NULL;\r\nproto_item *hidden_item;\r\noffset = 0;\r\nproto_tree_add_item(tree, hf_ansi_801_session_start, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_session_end, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_session_source, tvb, offset, 1, ENC_NA);\r\nproto_tree_add_item(tree, hf_ansi_801_rev_sess_tag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nhidden_item = proto_tree_add_item(tree, hf_ansi_801_sess_tag, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nPROTO_ITEM_SET_HIDDEN(hidden_item);\r\noffset++;\r\noct = tvb_get_guint8(tvb, offset);\r\npd_msg_type = oct;\r\nswitch (pd_msg_type)\r\n{\r\ncase 0x00: str = "Position Determination Data Message"; break;\r\ncase 0x01: str = "Position Determination Data Message"; break;\r\ncase 0xff: str = "Reserved"; break;\r\ndefault:\r\nif (pd_msg_type < 0xc0)\r\n{\r\nstr = "Reserved for future standardization";\r\n}\r\nelse\r\n{\r\nstr = "Available for manufacturer-specific Position Determination "\r\n"Data Message definition as specified in TSB-58";\r\n}\r\nbreak;\r\n}\r\nproto_tree_add_uint_format_value(tree, hf_ansi_801_pd_message_type, tvb, offset, 1, pd_msg_type,\r\n"%s (%u)", str, pd_msg_type);\r\noffset++;\r\nif ((pd_msg_type != 0x00) &&\r\n(pd_msg_type != 0x01))\r\n{\r\nproto_tree_add_item(tree, hf_ansi_801_proprietary_data, tvb, offset, -1, ENC_NA);\r\nreturn;\r\n}\r\nif (pd_msg_type == 0x01)\r\n{\r\nvalue = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(tree, hf_ansi_801_pd_message_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_regulatory_services_indicator, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nnum_req = value & 0x000f;\r\nproto_tree_add_item(tree, hf_ansi_801_rev_message_number_requests16, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\noct = tvb_get_guint8(tvb, offset);\r\nnum_rsp = oct & 0xf0;\r\nproto_tree_add_item(tree, hf_ansi_801_rev_message_number_responsesF0, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\n}\r\nelse\r\n{\r\noct = tvb_get_guint8(tvb, offset);\r\nnum_req = (oct & 0xf0) >> 4;\r\nnum_rsp = oct & 0x0f;\r\nproto_tree_add_item(tree, hf_ansi_801_rev_message_number_requests8, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(tree, hf_ansi_801_rev_message_number_responses0F, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\n}\r\nrem_len = tvb_reported_length_remaining(tvb, offset);\r\nwhile ((num_req > 0) &&\r\n(rem_len >= 2))\r\n{\r\nrev_request(tvb, pinfo, tree, &offset, pd_msg_type);\r\nrem_len = tvb_reported_length_remaining(tvb, offset);\r\nnum_req--;\r\n}\r\nif (num_req != 0)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_ansi_801_short_data, tvb, offset, -1);\r\nreturn;\r\n}\r\nwhile ((num_rsp > 0) &&\r\n(rem_len >= 2))\r\n{\r\nrev_response(tvb, pinfo, tree, &offset);\r\nrem_len = tvb_reported_length_remaining(tvb, offset);\r\nnum_rsp--;\r\n}\r\nif (num_rsp != 0)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_ansi_801_short_data, tvb, offset, -1);\r\nreturn;\r\n}\r\nif (rem_len > 0)\r\n{\r\nproto_tree_add_expert(tree, pinfo, &ei_ansi_801_extraneous_data, tvb, offset, rem_len);\r\n}\r\n}\r\nstatic int\r\ndissect_ansi_801(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nproto_item *ansi_801_item;\r\nproto_tree *ansi_801_tree = NULL;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, ansi_proto_name_short);\r\nif (tree)\r\n{\r\nansi_801_item =\r\nproto_tree_add_protocol_format(tree, proto_ansi_801, tvb, 0, -1,\r\n"%s %s Link",\r\nansi_proto_name,\r\n(pinfo->match_uint == ANSI_801_FORWARD) ? "Forward" : "Reverse");\r\nansi_801_tree =\r\nproto_item_add_subtree(ansi_801_item, ett_ansi_801);\r\nif (pinfo->match_uint == ANSI_801_FORWARD)\r\n{\r\ndissect_ansi_801_for_message(tvb, pinfo, ansi_801_tree);\r\n}\r\nelse\r\n{\r\ndissect_ansi_801_rev_message(tvb, pinfo, ansi_801_tree);\r\n}\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_ansi_801(void)\r\n{\r\nguint i;\r\ngint last_offset;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ansi_801_for_req_type,\r\n{ "Forward Request Type", "ansi_801.for_req_type",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_rsp_type,\r\n{ "Forward Response Type", "ansi_801.for_rsp_type",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_req_type,\r\n{ "Reverse Request Type", "ansi_801.rev_req_type",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_rsp_type,\r\n{ "Reverse Response Type", "ansi_801.rev_rsp_type",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_sess_tag,\r\n{ "Forward Session Tag", "ansi_801.for_sess_tag",\r\nFT_UINT8, BASE_DEC, NULL, 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_sess_tag,\r\n{ "Reverse Session Tag", "ansi_801.rev_sess_tag",\r\nFT_UINT8, BASE_DEC, NULL, 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_sess_tag,\r\n{ "Session Tag", "ansi_801.sess_tag",\r\nFT_UINT8, BASE_DEC, NULL, 0x1f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_time_ref_cdma,\r\n{ "CDMA system time at the time the solution is valid (TIME_REF_CDMA)", "ansi_801.time_ref_cdma",\r\nFT_UINT32, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_lat,\r\n{ "Latitude (LAT)", "ansi_801.lat",\r\nFT_FLOAT, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_long,\r\n{ "Longitude (LONG)", "ansi_801.long",\r\nFT_FLOAT, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_loc_uncrtnty_ang,\r\n{ "Angle of axis with respect to True North for pos uncertainty (LOC_UNCRTNTY_ANG)", "ansi_801.loc_uncrtnty_ang",\r\nFT_FLOAT, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_loc_uncrtnty_a,\r\n{ "Std dev of axis along angle specified for pos uncertainty (LOC_UNCRTNTY_A)", "ansi_801.loc_uncrtnty_a",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_loc_uncrtnty_p,\r\n{ "Std dev of axis perpendicular to angle specified for pos uncertainty (LOC_UNCRTNTY_P)", "ansi_801.loc_uncrtnty_p",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_fix_type,\r\n{ "Fix type (FIX_TYPE)", "ansi_801.fix_type",\r\nFT_BOOLEAN, BASE_NONE, TFS(&ansi_801_fix_type_vals), 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_velocity_incl,\r\n{ "Velocity information included (VELOCITY_INCL)", "ansi_801.velocity_incl",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_velocity_hor,\r\n{ "Horizontal velocity magnitude (VELOCITY_HOR)", "ansi_801.velocity_hor",\r\nFT_FLOAT, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_heading,\r\n{ "Heading (HEADING)", "ansi_801.heading",\r\nFT_FLOAT, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_velocity_ver,\r\n{ "Vertical velocity (VELOCITY_VER)", "ansi_801.velocity_ver",\r\nFT_FLOAT, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_clock_incl,\r\n{ "Clock information included (CLOCK_INCL)", "ansi_801.clock_incl",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_clock_bias,\r\n{ "Clock bias (CLOCK_BIAS)", "ansi_801.clock_bias",\r\nFT_INT24, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_clock_drift,\r\n{ "Clock drift (CLOCK_DRIFT)", "ansi_801.clock_drift",\r\nFT_INT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_height_incl,\r\n{ "Height information included (HEIGHT_INCL)", "ansi_801.height_incl",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_height,\r\n{ "Height (HEIGHT)", "ansi_801.height",\r\nFT_INT16, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_loc_uncrtnty_v,\r\n{ "Std dev of vertical error for pos uncertainty (LOC_UNCRTNTY_V)", "ansi_801.loc_uncrtnty_v",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved_bits,\r\n{ "Reserved bit(s)","ansi_801.reerved_bits",\r\nFT_UINT8,BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_bad_sv_present,\r\n{ "Bad GPS satellites present (BAD_SV_PRESENT)", "ansi_801.bad_sv_present",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_num_bad_sv,\r\n{ "Number of bad GPS satellites (NUM_BAD_SV)", "ansi_801.num_bad_sv",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_bad_sv_prn_num,\r\n{ "Satellite PRN number (SV_PRN_NUM)", "ansi_801.bad_sv_prn_num",\r\nFT_UINT8, BASE_DEC, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_dopp_req,\r\n{ "Doppler (0th order) term requested (DOPP_REQ)", "ansi_801.dopp_req",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_add_dopp_req,\r\n{ "Additional Doppler terms requested (ADD_DOPP_REQ)", "ansi_801.add_dopp_req",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_code_ph_par_req,\r\n{ "Code phase parameters requested (CODE_PH_PAR_REQ)", "ansi_801.code_ph_par_req",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_az_el_req,\r\n{ "Azimuth and elevation angle requested (AZ_EL_REQ)", "ansi_801.az_el_req",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_pref_resp_qual,\r\n{ "Preferred response quality (PREF_RESP_QUAL)", "ansi_801.pref_resp_qual",\r\nFT_UINT24, BASE_DEC, NULL, 0xe00000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_num_fixes,\r\n{ "Number of fixes (NUM_FIXES)", "ansi_801.num_fixes",\r\nFT_UINT24, BASE_DEC, NULL, 0x1fe000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_t_betw_fixes,\r\n{ "Time between fixes (T_BETW_FIXES) (in seconds)", "ansi_801.t_betw_fixes",\r\nFT_UINT24, BASE_DEC, NULL, 0x001fe0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_offset_req,\r\n{ "Offset requested (OFFSET_REQ)", "ansi_801.offset_req",\r\nFT_BOOLEAN, 24, TFS(&tfs_requested_not_requested), 0x000010,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_desired_pilot_phase_resolution,\r\n{ "Desired pilot phase resolution", "ansi_801.desired_pilot_phase_resolution",\r\nFT_BOOLEAN, 24, TFS(&tfs_desired_pilot_phase_resolution), 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved_24_7,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT24, BASE_HEX, NULL, 0x07,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_req_loc_height_information,\r\n{ "Height information", "ansi_801.height_incl",\r\nFT_BOOLEAN, 24, TFS(&tfs_requested_not_requested), 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_req_loc_clock_correction_for_gps_time,\r\n{ "Clock correction for GPS time", "ansi_801.clock_correction_for_gps_time",\r\nFT_BOOLEAN, 24, TFS(&tfs_requested_not_requested), 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_req_loc_velocity_information,\r\n{ "Velocity information", "ansi_801.velocity_information",\r\nFT_BOOLEAN, 24, TFS(&tfs_requested_not_requested), 0x04,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved24_3,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT24, BASE_HEX, NULL, 0x03,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_use_action_time_indicator,\r\n{ "Use action time indicator", "ansi_801.use_action_time_indicator",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_action_time,\r\n{ "Action time", "ansi_801.action_time",\r\nFT_UINT8, BASE_DEC, NULL, 0x7E,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved8_7F,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x7F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_cancellation_type,\r\n{ "Cancellation Type", "ansi_801.cancellation_type",\r\nFT_UINT8, BASE_DEC, VALS(for_req_type_strings), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved8_0F,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reject_request_type,\r\n{ "Reject request type", "ansi_801.reject_request_type",\r\nFT_UINT8, BASE_DEC, VALS(rev_req_type_strings), 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reject_reason,\r\n{ "Reject reason", "ansi_801.reject_reason",\r\nFT_UINT8, BASE_DEC, NULL, 0x0E,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved8_01,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_bs_ls_rev,\r\n{ "BS_LS_REV", "ansi_801.bs_ls_rev",\r\nFT_UINT8, BASE_HEX, NULL, 0xfc,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_capability_indicator,\r\n{ "GPSC_ID: GPS capability indicator", "ansi_801.gps_capability_indicator",\r\nFT_UINT8, BASE_DEC, NULL, 0x02,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_afltc_id,\r\n{ "AFLTC_ID: Advanced forward link trilateration capability indicator", "ansi_801.afltc_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x01,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_apdc_id,\r\n{ "APDC_ID: Autonomous position determination capability indicator: Autonomous Location Technology Identifier", "ansi_801.apdc_id",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_ref_bit_num,\r\n{ "REF_BIT_NUM", "ansi_801.ref_bit_num",\r\nFT_UINT16, BASE_DEC, NULL, 0xffe0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_num_dr_p,\r\n{ "NUM_DR_P: Number of data records in this part", "ansi_801.num_dr_p",\r\nFT_UINT16, BASE_DEC, NULL, 0x001e,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_dr_size,\r\n{ "DR_SIZE: Data record size", "ansi_801.dr_size",\r\nFT_UINT24, BASE_DEC, NULL, 0x0001FE,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_part_num,\r\n{ "PART_NUM: The part number", "ansi_801.part_num",\r\nFT_UINT16, BASE_DEC, NULL, 0x01c0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_total_parts,\r\n{ "TOTAL_PARTS: Total number of parts", "ansi_801.total_parts",\r\nFT_UINT16, BASE_DEC, NULL, 0x38,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_data_records,\r\n{ "Data records", "ansi_801.data_records",\r\nFT_UINT16, BASE_DEC, NULL, 0x07,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_num_sv_p32,\r\n{ "NUM_SV_P: Number of satellites in this part", "ansi_801.num_sv_p",\r\nFT_UINT32, BASE_DEC, NULL, 0xfc000000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_week_num,\r\n{ "WEEK_NUM: The GPS week number of the almanac", "ansi_801.week_num",\r\nFT_UINT32, BASE_DEC, NULL, 0x03fc0000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_toa,\r\n{ "TOA: The reference time of the almanac", "ansi_801.toa",\r\nFT_UINT32, BASE_DEC, NULL, 0x0003fc00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_part_num32,\r\n{ "PART_NUM: The part number", "ansi_801.part_num",\r\nFT_UINT32, BASE_DEC, NULL, 0x000003e0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_total_parts32,\r\n{ "TOTAL_PARTS: The total number of parts", "ansi_801.total_parts",\r\nFT_UINT32, BASE_DEC, NULL, 0x0000001f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_num_sv_p16,\r\n{ "NUM_SV_P: Number of satellites in this part", "ansi_801.num_sv_p",\r\nFT_UINT16, BASE_DEC, NULL, 0xfc00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_part_num16,\r\n{ "PART_NUM: The part number", "ansi_801.part_num",\r\nFT_UINT16, BASE_DEC, NULL, 0x03e0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_total_parts16,\r\n{ "TOTAL_PARTS: The total number of parts", "ansi_801.total_parts",\r\nFT_UINT16, BASE_DEC, NULL, 0x001f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_coordinate_type_requested,\r\n{ "Coordinate type requested", "ansi_801.coordinate_type_requested",\r\nFT_BOOLEAN, 8, TFS(&tfs_spherical_cartesian), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_extended_base_station_almanac,\r\n{ "Extended base station almanac", "ansi_801.extended_base_station_almanac",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_alpha_and_beta_parameters,\r\n{ "Alpha and Beta parameters", "ansi_801.alpha_and_beta_parameters",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_subframes_4_and_5,\r\n{ "Subframes 4 and 5", "ansi_801.subframes_4_and_5",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_req_loc_height_information,\r\n{ "Height information", "ansi_801.height_information",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_req_loc_clock_correction_for_gps_time,\r\n{ "Clock correction for GPS time", "ansi_801.clock_correction_for_gps_time",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_req_loc_velocity_information,\r\n{ "Velocity information", "ansi_801.velocity_information",\r\nFT_BOOLEAN, 8, TFS(&tfs_requested_not_requested), 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved8_1F,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x1F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_ms_ls_rev,\r\n{ "MS_LS_REV", "ansi_801.ms_ls_rev",\r\nFT_UINT16, BASE_DEC, NULL, 0xfc00,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_ms_mode,\r\n{ "MS_MODE", "ansi_801.ms_mode",\r\nFT_UINT16, BASE_DEC, NULL, 0x03c0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_pilot_ph_cap,\r\n{ "PILOT_PH_CAP", "ansi_801.pilot_ph_cap",\r\nFT_UINT16, BASE_DEC, NULL, 0x003f,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_acq_cap,\r\n{ "GPS_ACQ_CAP", "ansi_801.gps_acq_cap",\r\nFT_UINT24, BASE_HEX, NULL, 0x000FFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved_24_F80000,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT24, BASE_HEX, NULL, 0xf80000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_autonomous_acquisition_capable,\r\n{ "GPS Autonomous Acquisition Capable", "ansi_801.gps_autonomous_acquisition_capable",\r\nFT_BOOLEAN, 24, NULL, 0x040000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_almanac_correction,\r\n{ "GPS Almanac Correction", "ansi_801.gps_almanac_correction",\r\nFT_BOOLEAN, 24, NULL, 0x020000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_navigation_message_bits,\r\n{ "GPS Navigation Message Bits", "ansi_801.gps_navigation_message_bits",\r\nFT_BOOLEAN, 24, NULL, 0x010000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_ephemeris,\r\n{ "GPS Ephemeris", "ansi_801.gps_ephemeris",\r\nFT_BOOLEAN, 24, NULL, 0x008000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_almanac,\r\n{ "GPS Almanac", "ansi_801.gps_almanac",\r\nFT_BOOLEAN, 24, NULL, 0x004000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_sensitivity_assistance,\r\n{ "GPS Sensitivity Assistance", "ansi_801.gps_sensitivity_assistance",\r\nFT_BOOLEAN, 24, NULL, 0x002000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_acquisition_assistance,\r\n{ "GPS Acquisition Assistance", "ansi_801.gps_acquisition_assistance",\r\nFT_BOOLEAN, 24, NULL, 0x001000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_loc_calc_cap,\r\n{ "LOC_CALC_CAP", "ansi_801.loc_calc_cap",\r\nFT_UINT24, BASE_HEX, NULL, 0x000FFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_pre_programmed_location,\r\n{ "Pre-programmed Location", "ansi_801.pre_programmed_location",\r\nFT_BOOLEAN, 24, NULL, 0x000800,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved_24_700,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT24, BASE_HEX, NULL, 0x000700,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_hybrid_gps_and_aflt_lcc,\r\n{ "Hybrid GPS and AFLT Location Calculation Capable", "ansi_801.hybrid_gps_and_aflt_lcc",\r\nFT_BOOLEAN, 24, NULL, 0x000080,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_autonomous_location_calculation_capable,\r\n{ "Autonomous Location Calculation Capable", "ansi_801.autonomous_lcc",\r\nFT_BOOLEAN, 24, NULL, 0x000040,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_lcc_using_gps_almanac_correction,\r\n{ "Location Calculation Capable using GPS Almanac Correction", "ansi_801.lcc_using_gps_almanac_correction",\r\nFT_BOOLEAN, 24, NULL, 0x000020,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_lcc_using_gps_ephemeris_assistance,\r\n{ "Location Calculation Capable using GPS Ephemeris Assistance", "ansi_801.lcc_using_gps_ephemeris_assistance",\r\nFT_BOOLEAN, 24, NULL, 0x000010,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_lcc_using_gps_almanac_assistance,\r\n{ "Location Calculation Capable using GPS Almanac Assistance", "ansi_801.lcc_using_gps_almanac_assistance",\r\nFT_BOOLEAN, 24, NULL, 0x000008,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_aflt_lcc,\r\n{ "Advanced Forward Link Trilateration (AFLT) Location Calculation Capable", "ansi_801.aflt_lcc",\r\nFT_BOOLEAN, 24, NULL, 0x000004,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_lcc_using_location_assistance_cartesian,\r\n{ "Location Calculation Capable using Location Assistance - Cartesian", "ansi_801.lcc_using_location_assistance.cartesian",\r\nFT_BOOLEAN, 24, NULL, 0x000002,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_lcc_capable_using_location_assistance_spherical,\r\n{ "Location Calculation Capable using Location Assistance - Spherical", "ansi_801.lcc_using_location_assistance.spherical",\r\nFT_BOOLEAN, 24, NULL, 0x000001,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_ref_pn,\r\n{ "REF_PN", "ansi_801.ref_pn",\r\nFT_UINT24, BASE_DEC, NULL, 0xff8000,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_mob_sys_t_offset,\r\n{ "MOB_SYS_T_OFFSET", "ansi_801.mob_sys_t_offset",\r\nFT_UINT24, BASE_DEC, NULL, 0x007ffe,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved24_1,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT24, BASE_HEX, NULL, 0x000001,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_no_outstanding_request_element,\r\n{ "No outstanding request element", "ansi_801.no_outstanding_request_element",\r\nFT_BOOLEAN, 8, NULL, 0x08,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved8_07,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0x07,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved8_F0,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_request_length,\r\n{ "Length", "ansi_801.for_request_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_reserved8_E0,\r\n{ "Reserved", "ansi_801.reserved",\r\nFT_UINT8, BASE_HEX, NULL, 0xE0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_unsolicited_response_indicator,\r\n{ "Unsolicited response indicator", "ansi_801.unsolicited_response_indicator",\r\nFT_BOOLEAN, 8, NULL, 0x10,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_response_length,\r\n{ "Length", "ansi_801.for_response_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_request_length,\r\n{ "Length", "ansi_801.rev_request_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_response_length,\r\n{ "Length", "ansi_801.rev_response_length",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_session_start,\r\n{ "Session Start", "ansi_801.session_start",\r\nFT_BOOLEAN, 8, NULL, 0x80,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_session_end,\r\n{ "Session End", "ansi_801.session_end",\r\nFT_BOOLEAN, 8, NULL, 0x40,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_session_source,\r\n{ "Session Source", "ansi_801.session_source",\r\nFT_BOOLEAN, 8, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_pd_message_type,\r\n{ "PD Message Type", "ansi_801.pd_message_type",\r\nFT_UINT8, BASE_DEC, NULL, 0xFF,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_pd_message_len,\r\n{ "PD Message Length", "ansi_801.pd_message_len",\r\nFT_UINT16, BASE_DEC, NULL, 0xffc0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_regulatory_services_indicator,\r\n{ "Regulatory Services Indicator", "ansi_801.regulatory_services_indicator",\r\nFT_UINT16, BASE_DEC, VALS(regulatory_services_indicator_vals), 0x0030,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_message_number_requests16,\r\n{ "Number Requests", "ansi_801.for_message_number_requests",\r\nFT_UINT16, BASE_DEC, NULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_message_number_responsesF0,\r\n{ "Number Responses", "ansi_801.for_message_number_responses",\r\nFT_UINT8, BASE_DEC, NULL, 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_message_number_requests8,\r\n{ "Number Requests", "ansi_801.for_message_number_requests",\r\nFT_UINT8, BASE_DEC, NULL, 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_for_message_number_responses0F,\r\n{ "Number Responses", "ansi_801.for_message_number_responses",\r\nFT_UINT8, BASE_DEC, NULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_message_number_requests16,\r\n{ "Number Requests", "ansi_801.rev_message_number_requests",\r\nFT_UINT16, BASE_DEC, NULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_message_number_responsesF0,\r\n{ "Number Responses", "ansi_801.rev_message_number_responses",\r\nFT_UINT8, BASE_DEC, NULL, 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_message_number_requests8,\r\n{ "Number Requests", "ansi_801.rev_message_number_requests",\r\nFT_UINT8, BASE_DEC, NULL, 0xF0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_rev_message_number_responses0F,\r\n{ "Number Responses", "ansi_801.rev_message_number_responses",\r\nFT_UINT8, BASE_DEC, NULL, 0x0F,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_data,\r\n{ "Data", "ansi_801.data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_proprietary_data,\r\n{ "Reserved/Proprietary/Future Data", "ansi_801.proprietary_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_time_ref_ms,\r\n{ "TIME_REF_MS", "ansi_801.time_ref_ms",\r\nFT_UINT24, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_time_of_almanac,\r\n{ "Time of almanac", "ansi_801.time_of_almanac",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ansi_801_gps_week_number,\r\n{ "GPS week number", "ansi_801.gps_week_number",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\n#define NUM_INDIVIDUAL_PARAMS 3\r\ngint *ett[NUM_INDIVIDUAL_PARAMS+NUM_FOR_REQ_TYPE+NUM_FOR_RSP_TYPE+NUM_REV_REQ_TYPE+NUM_REV_RSP_TYPE];\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ansi_801_extraneous_data, { "ansi_801.extraneous_data", PI_PROTOCOL, PI_NOTE, "Extraneous Data, dissector bug or later version spec(report to wireshark.org)", EXPFILL }},\r\n{ &ei_ansi_801_short_data, { "ansi_801.short_data", PI_PROTOCOL, PI_NOTE, "Short Data (?) - try checking decoder variant preference or dissector bug/later version spec (report to wireshark.org)", EXPFILL }},\r\n{ &ei_ansi_801_unexpected_length, { "ansi_801.unexpected_length", PI_PROTOCOL, PI_WARN, "Unexpected Data Length - try checking decoder variant preference or dissector bug/later version spec (report to wireshark.org)", EXPFILL }},\r\n};\r\nexpert_module_t* expert_ansi_801;\r\nett[0] = &ett_ansi_801;\r\nett[1] = &ett_gps;\r\nett[2] = &ett_loc;\r\nlast_offset = NUM_INDIVIDUAL_PARAMS;\r\nfor (i=0; i < NUM_FOR_REQ_TYPE; i++, last_offset++)\r\n{\r\nett_for_req_type[i] = -1;\r\nett[last_offset] = &ett_for_req_type[i];\r\n}\r\nfor (i=0; i < NUM_FOR_RSP_TYPE; i++, last_offset++)\r\n{\r\nett_for_rsp_type[i] = -1;\r\nett[last_offset] = &ett_for_rsp_type[i];\r\n}\r\nfor (i=0; i < NUM_REV_REQ_TYPE; i++, last_offset++)\r\n{\r\nett_rev_req_type[i] = -1;\r\nett[last_offset] = &ett_rev_req_type[i];\r\n}\r\nfor (i=0; i < NUM_REV_RSP_TYPE; i++, last_offset++)\r\n{\r\nett_rev_rsp_type[i] = -1;\r\nett[last_offset] = &ett_rev_rsp_type[i];\r\n}\r\nproto_ansi_801 =\r\nproto_register_protocol(ansi_proto_name, "ANSI IS-801 (Location Services (PLD))", "ansi_801");\r\nproto_register_field_array(proto_ansi_801, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_ansi_801 = expert_register_protocol(proto_ansi_801);\r\nexpert_register_field_array(expert_ansi_801, ei, array_length(ei));\r\nansi_801_handle = register_dissector("ansi_801", dissect_ansi_801, proto_ansi_801);\r\n}\r\nvoid\r\nproto_reg_handoff_ansi_801(void)\r\n{\r\ndissector_add_uint("ansi_map.pld", ANSI_801_FORWARD, ansi_801_handle);\r\ndissector_add_uint("ansi_map.pld", ANSI_801_REVERSE, ansi_801_handle);\r\ndissector_add_uint("ansi_a.pld", ANSI_801_FORWARD, ansi_801_handle);\r\ndissector_add_uint("ansi_a.pld", ANSI_801_REVERSE, ansi_801_handle);\r\n}
