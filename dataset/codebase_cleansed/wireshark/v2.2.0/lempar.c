void ParseTrace(FILE *TraceFILE, char *zTracePrompt){\r\nyyTraceFILE = TraceFILE;\r\nyyTracePrompt = zTracePrompt;\r\nif( yyTraceFILE==0 ) yyTracePrompt = 0;\r\nelse if( yyTracePrompt==0 ) yyTraceFILE = 0;\r\n}\r\nstatic void yyGrowStack(yyParser *p){\r\nint newSize;\r\nyyStackEntry *pNew;\r\nnewSize = p->yystksz*2 + 100;\r\npNew = realloc(p->yystack, newSize*sizeof(pNew[0]));\r\nif( pNew ){\r\np->yystack = pNew;\r\np->yystksz = newSize;\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE,"%sStack grows to %d entries!\n",\r\nyyTracePrompt, p->yystksz);\r\n}\r\n#endif\r\n}\r\n}\r\nvoid *ParseAlloc(void *(*mallocProc)(YYMALLOCARGTYPE)){\r\nyyParser *pParser;\r\npParser = (yyParser*)(*mallocProc)( (YYMALLOCARGTYPE)sizeof(yyParser) );\r\nif( pParser ){\r\npParser->yyidx = -1;\r\n#ifdef YYTRACKMAXSTACKDEPTH\r\npParser->yyidxMax = 0;\r\n#endif\r\n#if YYSTACKDEPTH<=0\r\npParser->yystack = NULL;\r\npParser->yystksz = 0;\r\nyyGrowStack(pParser);\r\n#endif\r\n}\r\nreturn pParser;\r\n}\r\nstatic void yy_destructor(\r\nyyParser *yypParser,\r\nYYCODETYPE yymajor,\r\nYYMINORTYPE *yypminor\r\n){\r\nParseARG_FETCH;\r\nswitch( yymajor ){\r\n%%\r\ndefault: break;\r\n}\r\n}\r\nstatic void yy_pop_parser_stack(yyParser *pParser){\r\nyyStackEntry *yytos;\r\nassert( pParser->yyidx>=0 );\r\nyytos = &pParser->yystack[pParser->yyidx--];\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE,"%sPopping %s\n",\r\nyyTracePrompt,\r\nyyTokenName[yytos->major]);\r\n}\r\n#endif\r\nyy_destructor(pParser, yytos->major, &yytos->minor);\r\n}\r\nvoid ParseFree(\r\nvoid *p,\r\nvoid (*freeProc)(void*)\r\n){\r\nyyParser *pParser = (yyParser*)p;\r\n#ifndef YYPARSEFREENEVERNULL\r\nif( pParser==0 ) return;\r\n#endif\r\nwhile( pParser->yyidx>=0 ) yy_pop_parser_stack(pParser);\r\n#if YYSTACKDEPTH<=0\r\nfree(pParser->yystack);\r\n#endif\r\n(*freeProc)((void*)pParser);\r\n}\r\nint ParseStackPeak(void *p){\r\nyyParser *pParser = (yyParser*)p;\r\nreturn pParser->yyidxMax;\r\n}\r\nstatic int yy_find_shift_action(\r\nyyParser *pParser,\r\nYYCODETYPE iLookAhead\r\n){\r\nint i;\r\nint stateno = pParser->yystack[pParser->yyidx].stateno;\r\nif( stateno>=YY_MIN_REDUCE ) return stateno;\r\nassert( stateno <= YY_SHIFT_COUNT );\r\ndo{\r\ni = yy_shift_ofst[stateno];\r\nif( i==YY_SHIFT_USE_DFLT ) return yy_default[stateno];\r\nassert( iLookAhead!=YYNOCODE );\r\ni += iLookAhead;\r\nif( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){\r\nif( iLookAhead>0 ){\r\n#ifdef YYFALLBACK\r\nYYCODETYPE iFallback;\r\nif( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0])\r\n&& (iFallback = yyFallback[iLookAhead])!=0 ){\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",\r\nyyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);\r\n}\r\n#endif\r\nassert( yyFallback[iFallback]==0 );\r\niLookAhead = iFallback;\r\ncontinue;\r\n}\r\n#endif\r\n#ifdef YYWILDCARD\r\n{\r\nint j = i - iLookAhead + YYWILDCARD;\r\nif(\r\n#if YY_SHIFT_MIN+YYWILDCARD<0\r\nj>=0 &&\r\n#endif\r\n#if YY_SHIFT_MAX+YYWILDCARD>=YY_ACTTAB_COUNT\r\nj<YY_ACTTAB_COUNT &&\r\n#endif\r\nyy_lookahead[j]==YYWILDCARD\r\n){\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",\r\nyyTracePrompt, yyTokenName[iLookAhead],\r\nyyTokenName[YYWILDCARD]);\r\n}\r\n#endif\r\nreturn yy_action[j];\r\n}\r\n}\r\n#endif\r\n}\r\nreturn yy_default[stateno];\r\n}else{\r\nreturn yy_action[i];\r\n}\r\n}while(1);\r\n}\r\nstatic int yy_find_reduce_action(\r\nint stateno,\r\nYYCODETYPE iLookAhead\r\n){\r\nint i;\r\n#ifdef YYERRORSYMBOL\r\nif( stateno>YY_REDUCE_COUNT ){\r\nreturn yy_default[stateno];\r\n}\r\n#else\r\nassert( stateno<=YY_REDUCE_COUNT );\r\n#endif\r\ni = yy_reduce_ofst[stateno];\r\nassert( i!=YY_REDUCE_USE_DFLT );\r\nassert( iLookAhead!=YYNOCODE );\r\ni += iLookAhead;\r\n#ifdef YYERRORSYMBOL\r\nif( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){\r\nreturn yy_default[stateno];\r\n}\r\n#else\r\nassert( i>=0 && i<YY_ACTTAB_COUNT );\r\nassert( yy_lookahead[i]==iLookAhead );\r\n#endif\r\nreturn yy_action[i];\r\n}\r\nstatic void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor _U_){\r\nParseARG_FETCH;\r\nyypParser->yyidx--;\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt);\r\n}\r\n#endif\r\nwhile( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);\r\n%%\r\nParseARG_STORE;\r\n}\r\nstatic void yyTraceShift(yyParser *yypParser, int yyNewState){\r\nif( yyTraceFILE ){\r\nif( yyNewState<YYNSTATE ){\r\nfprintf(yyTraceFILE,"%sShift '%s', go to state %d\n",\r\nyyTracePrompt,yyTokenName[yypParser->yystack[yypParser->yyidx].major],\r\nyyNewState);\r\n}else{\r\nfprintf(yyTraceFILE,"%sShift '%s'\n",\r\nyyTracePrompt,yyTokenName[yypParser->yystack[yypParser->yyidx].major]);\r\n}\r\n}\r\n}\r\nstatic void yy_shift(\r\nyyParser *yypParser,\r\nint yyNewState,\r\nint yyMajor,\r\nYYMINORTYPE *yypMinor\r\n){\r\nyyStackEntry *yytos;\r\nyypParser->yyidx++;\r\n#ifdef YYTRACKMAXSTACKDEPTH\r\nif( yypParser->yyidx>yypParser->yyidxMax ){\r\nyypParser->yyidxMax = yypParser->yyidx;\r\n}\r\n#endif\r\n#if YYSTACKDEPTH>0\r\nif( yypParser->yyidx>=YYSTACKDEPTH ){\r\nyyStackOverflow(yypParser, yypMinor);\r\nreturn;\r\n}\r\n#else\r\nif( yypParser->yyidx>=yypParser->yystksz ){\r\nyyGrowStack(yypParser);\r\nif( yypParser->yyidx>=yypParser->yystksz ){\r\nyyStackOverflow(yypParser, yypMinor);\r\nreturn;\r\n}\r\n}\r\n#endif\r\nyytos = &yypParser->yystack[yypParser->yyidx];\r\nyytos->stateno = (YYACTIONTYPE)yyNewState;\r\nyytos->major = (YYCODETYPE)yyMajor;\r\nyytos->minor = *yypMinor;\r\nyyTraceShift(yypParser, yyNewState);\r\n}\r\nstatic void yy_reduce(\r\nyyParser *yypParser,\r\nint yyruleno\r\n){\r\nint yygoto;\r\nint yyact;\r\nYYMINORTYPE yygotominor;\r\nyyStackEntry *yymsp;\r\nint yysize;\r\nParseARG_FETCH;\r\nyymsp = &yypParser->yystack[yypParser->yyidx];\r\n#ifndef NDEBUG\r\nif( yyTraceFILE && yyruleno>=0\r\n&& yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) ){\r\nyysize = yyRuleInfo[yyruleno].nrhs;\r\nfprintf(yyTraceFILE, "%sReduce [%s], go to state %d.\n", yyTracePrompt,\r\nyyRuleName[yyruleno], yymsp[-yysize].stateno);\r\n}\r\n#endif\r\nyygotominor = yyzerominor;\r\nswitch( yyruleno ){\r\n%%\r\n};\r\nassert( yyruleno>=0 && yyruleno<(int)(sizeof(yyRuleInfo)/sizeof(yyRuleInfo[0])) );\r\nyygoto = yyRuleInfo[yyruleno].lhs;\r\nyysize = yyRuleInfo[yyruleno].nrhs;\r\nyypParser->yyidx -= yysize;\r\nyyact = yy_find_reduce_action(yymsp[-yysize].stateno,(YYCODETYPE)yygoto);\r\nif( yyact <= YY_MAX_SHIFTREDUCE ){\r\nif( yyact>YY_MAX_SHIFT ) yyact += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;\r\nif( yysize ){\r\nyypParser->yyidx++;\r\nyymsp -= yysize-1;\r\nyymsp->stateno = (YYACTIONTYPE)yyact;\r\nyymsp->major = (YYCODETYPE)yygoto;\r\nyymsp->minor = yygotominor;\r\nyyTraceShift(yypParser, yyact);\r\n}else{\r\nyy_shift(yypParser,yyact,yygoto,&yygotominor);\r\n}\r\n}else{\r\nassert( yyact == YY_ACCEPT_ACTION );\r\nyy_accept(yypParser);\r\n}\r\n}\r\nstatic void yy_parse_failed(\r\nyyParser *yypParser\r\n){\r\nParseARG_FETCH;\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE,"%sFail!\n",yyTracePrompt);\r\n}\r\n#endif\r\nwhile( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);\r\n%%\r\nParseARG_STORE;\r\n}\r\nstatic void yy_syntax_error(\r\nyyParser *yypParser,\r\nint yymajor _U_,\r\nYYMINORTYPE yyminor\r\n){\r\nParseARG_FETCH;\r\n#define TOKEN (yyminor.yy0)\r\n%%\r\nParseARG_STORE;\r\n}\r\nstatic void yy_accept(\r\nyyParser *yypParser\r\n){\r\nParseARG_FETCH;\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt);\r\n}\r\n#endif\r\nwhile( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);\r\n%%\r\nParseARG_STORE;\r\n}\r\nvoid Parse(\r\nvoid *yyp,\r\nint yymajor,\r\nParseTOKENTYPE yyminor\r\nParseARG_PDECL\r\n){\r\nYYMINORTYPE yyminorunion;\r\nint yyact;\r\n#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)\r\nint yyendofinput;\r\n#endif\r\n#ifdef YYERRORSYMBOL\r\nint yyerrorhit = 0;\r\n#endif\r\nyyParser *yypParser;\r\nyypParser = (yyParser*)yyp;\r\nif( yypParser->yyidx<0 ){\r\n#if YYSTACKDEPTH<=0\r\nif( yypParser->yystksz <=0 ){\r\nyyminorunion = yyzerominor;\r\nyyStackOverflow(yypParser, &yyminorunion);\r\nreturn;\r\n}\r\n#endif\r\nyypParser->yyidx = 0;\r\nyypParser->yyerrcnt = -1;\r\nyypParser->yystack[0].stateno = 0;\r\nyypParser->yystack[0].major = 0;\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE,"%sInitialize. Empty stack. State 0\n",\r\nyyTracePrompt);\r\n}\r\n#endif\r\n}\r\nyyminorunion.yy0 = yyminor;\r\n#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)\r\nyyendofinput = (yymajor==0);\r\n#endif\r\nParseARG_STORE;\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE,"%sInput '%s'\n",yyTracePrompt,yyTokenName[yymajor]);\r\n}\r\n#endif\r\ndo{\r\nyyact = yy_find_shift_action(yypParser,(YYCODETYPE)yymajor);\r\nif( yyact <= YY_MAX_SHIFTREDUCE ){\r\nif( yyact > YY_MAX_SHIFT ) yyact += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;\r\nyy_shift(yypParser,yyact,yymajor,&yyminorunion);\r\nyypParser->yyerrcnt--;\r\nyymajor = YYNOCODE;\r\n}else if( yyact <= YY_MAX_REDUCE ){\r\nyy_reduce(yypParser,yyact-YY_MIN_REDUCE);\r\n}else{\r\nassert( yyact == YY_ERROR_ACTION );\r\n#ifdef YYERRORSYMBOL\r\nint yymx;\r\n#endif\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE,"%sSyntax Error!\n",yyTracePrompt);\r\n}\r\n#endif\r\n#ifdef YYERRORSYMBOL\r\nif( yypParser->yyerrcnt<0 ){\r\nyy_syntax_error(yypParser,yymajor,yyminorunion);\r\n}\r\nyymx = yypParser->yystack[yypParser->yyidx].major;\r\nif( yymx==YYERRORSYMBOL || yyerrorhit ){\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nfprintf(yyTraceFILE,"%sDiscard input token %s\n",\r\nyyTracePrompt,yyTokenName[yymajor]);\r\n}\r\n#endif\r\nyy_destructor(yypParser, (YYCODETYPE)yymajor,&yyminorunion);\r\nyymajor = YYNOCODE;\r\n}else{\r\nwhile(\r\nyypParser->yyidx >= 0 &&\r\nyymx != YYERRORSYMBOL &&\r\n(yyact = yy_find_reduce_action(\r\nyypParser->yystack[yypParser->yyidx].stateno,\r\nYYERRORSYMBOL)) >= YY_MIN_REDUCE\r\n){\r\nyy_pop_parser_stack(yypParser);\r\n}\r\nif( yypParser->yyidx < 0 || yymajor==0 ){\r\nyy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);\r\nyy_parse_failed(yypParser);\r\nyymajor = YYNOCODE;\r\n}else if( yymx!=YYERRORSYMBOL ){\r\nYYMINORTYPE u2;\r\nu2.YYERRSYMDT = 0;\r\nyy_shift(yypParser,yyact,YYERRORSYMBOL,&u2);\r\n}\r\n}\r\nyypParser->yyerrcnt = 3;\r\nyyerrorhit = 1;\r\n#elif defined(YYNOERRORRECOVERY)\r\nyy_syntax_error(yypParser,yymajor,yyminorunion);\r\nyy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);\r\nyymajor = YYNOCODE;\r\n#else\r\nif( yypParser->yyerrcnt<=0 ){\r\nyy_syntax_error(yypParser,yymajor,yyminorunion);\r\n}\r\nyypParser->yyerrcnt = 3;\r\nyy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);\r\nif( yyendofinput ){\r\nyy_parse_failed(yypParser);\r\n}\r\nyymajor = YYNOCODE;\r\n#endif\r\n}\r\n}while( yymajor!=YYNOCODE && yypParser->yyidx>=0 );\r\n#ifndef NDEBUG\r\nif( yyTraceFILE ){\r\nint i;\r\nfprintf(yyTraceFILE,"%sReturn. Stack=",yyTracePrompt);\r\nfor(i=1; i<=yypParser->yyidx; i++)\r\nfprintf(yyTraceFILE,"%c%s", i==1 ? '[' : ' ',\r\nyyTokenName[yypParser->yystack[i].major]);\r\nfprintf(yyTraceFILE,"]\n");\r\n}\r\n#endif\r\nreturn;\r\n}
