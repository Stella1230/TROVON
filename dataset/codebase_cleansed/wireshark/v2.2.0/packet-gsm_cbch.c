static void\r\ncbch_defragment_init(void)\r\n{\r\nreassembly_table_init(&cbch_block_reassembly_table,\r\n&addresses_reassembly_table_functions);\r\n}\r\nstatic void\r\ncbch_defragment_cleanup(void)\r\n{\r\nreassembly_table_destroy(&cbch_block_reassembly_table);\r\n}\r\nstatic void\r\ndissect_schedule_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree)\r\n{\r\nguint len, offset = 0;\r\nguint8 octet1, i, k = 0;\r\nguint8 sched_begin, sched_end, new_slots[48];\r\ngboolean valid_message = TRUE;\r\nguint16 other_slots[48];\r\nproto_item *item = NULL, *schedule_item = NULL;\r\nproto_tree *sched_tree = NULL, *sched_subtree = NULL;\r\nlen = tvb_reported_length(tvb);\r\ncol_append_str(pinfo->cinfo, COL_INFO, " CBCH Schedule Message ");\r\nschedule_item = proto_tree_add_protocol_format(top_tree, proto_cbch, tvb, 0, -1,\r\n"GSM CBCH Schedule Message");\r\nsched_tree = proto_item_add_subtree(schedule_item, ett_schedule_msg);\r\nproto_tree_add_item(sched_tree, hf_gsm_cbch_sched_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noctet1 = tvb_get_guint8(tvb, offset);\r\nif (0 == (octet1 & 0xC0))\r\n{\r\nproto_item* slot_item;\r\nsched_begin = octet1 & 0x3F;\r\nproto_tree_add_item(sched_tree, hf_gsm_cbch_sched_begin_slot, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nif ((sched_begin < 1) || (sched_begin > 48))\r\n{\r\nvalid_message = FALSE;\r\n}\r\nproto_tree_add_item(sched_tree, hf_gsm_cbch_sched_spare, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nsched_end = tvb_get_guint8(tvb, offset);\r\nslot_item = proto_tree_add_item(sched_tree, hf_gsm_cbch_sched_end_slot, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nif (sched_end < sched_begin)\r\n{\r\nexpert_add_info(pinfo, slot_item, &ei_gsm_cbch_sched_end_slot);\r\nvalid_message = FALSE;\r\n}\r\nif (valid_message)\r\n{\r\nmemset(&new_slots, 0xFF, sizeof(new_slots));\r\nmemset(&other_slots, 0xFF, sizeof(other_slots));\r\nfor (i=0; i<6; i++)\r\n{\r\nguint8 j;\r\noctet1 = tvb_get_guint8(tvb, offset++);\r\nfor (j=0; j<8; j++)\r\n{\r\nif (octet1 & (0x80>>j))\r\n{\r\nnew_slots[k++] = (i<<3) + j + 1;\r\n}\r\n}\r\n}\r\nsched_subtree = proto_tree_add_subtree_format(sched_tree, tvb, offset-6, 6, ett_schedule_new_msg, &item,\r\n"This schedule contains %d slots with new messages", k);\r\nfor (i=0; i<k; i++)\r\n{\r\nDISSECTOR_ASSERT(new_slots[i] <= 48);\r\noctet1 = tvb_get_guint8(tvb, offset);\r\nif ((octet1 & 0x80) == 0x80)\r\n{\r\nguint8 octet2;\r\nguint16 msg_id;\r\noctet2 = tvb_get_guint8(tvb, offset + 1);\r\nmsg_id = ((octet1 &0x7F) << 8) + octet2;\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 2, new_slots[i],\r\n"%d, Message ID: %d, First transmission of an SMSCB within the Schedule Period",\r\nnew_slots[i], msg_id);\r\noffset +=2;\r\nother_slots[new_slots[i] - 1] = msg_id;\r\n}\r\nelse if ((octet1 & 0xC0) == 0)\r\n{\r\nif (octet1 == 0)\r\n{\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],\r\n"%d, Repeat of non-existant slot %d",\r\nnew_slots[i], octet1);\r\n}\r\nelse if (octet1 < new_slots[i])\r\n{\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],\r\n"%d, Message ID: %d, Repeat of Slot %d",\r\nnew_slots[i], other_slots[octet1 - 1], octet1);\r\nother_slots[new_slots[i] - 1] = other_slots[octet1 - 1];\r\n}\r\nelse\r\n{\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],\r\n"%d, Apparent forward reference to slot %d",\r\nnew_slots[i], octet1);\r\n}\r\n}\r\nelse if (octet1 == 0x40)\r\n{\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],\r\n"%d Free Message Slot, optional reading", new_slots[i]);\r\nother_slots[new_slots[i] - 1] = 0xFFFE;\r\n}\r\nelse if (octet1 == 0x41)\r\n{\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, new_slots[i],\r\n"%d Free Message Slot, reading advised", new_slots[i]);\r\nother_slots[new_slots[i] - 1] = 0xFFFE;\r\n}\r\nelse\r\n{\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, new_slots[i],\r\n"%d reserved MDT: %x", new_slots[i], octet1);\r\nother_slots[new_slots[i] - 1] = 0xFFFE;\r\n}\r\n}\r\nproto_item_set_end(item, tvb, offset);\r\nsched_subtree = proto_tree_add_subtree(sched_tree, tvb, offset, 0,\r\nett_schedule_new_msg, &item, "Other message slots in this schedule");\r\nfor (k=0; offset < len; )\r\n{\r\nif (sched_end > 48)\r\nsched_end = 48;\r\nwhile ((k<sched_end) && (other_slots[k]!=0xFFFF))\r\n{\r\nk++;\r\n}\r\nif (k >= sched_end)\r\nbreak;\r\noctet1 = tvb_get_guint8(tvb, offset);\r\nif ((octet1 & 0x80) == 0x80)\r\n{\r\nif ((offset+1)<len)\r\n{\r\nguint8 octet2;\r\nguint16 msg_id;\r\noctet2 = tvb_get_guint8(tvb, offset + 1);\r\nmsg_id = ((octet1 &0x7F) << 8) + octet2;\r\nother_slots[k] = msg_id;\r\nk++;\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 2, k,\r\n"%d, Message: %d, First transmission of an SMSCB within the Schedule Period",\r\nk, msg_id);\r\noffset +=2;\r\n}\r\nelse\r\n{\r\n++k;\r\n}\r\n}\r\nelse if (octet1 && ((octet1 & 0xC0) == 0))\r\n{\r\nif (octet1 < k)\r\n{\r\nother_slots[k] = other_slots[octet1 - 1];\r\nk++;\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,\r\n"%d, Message ID: %d, Repeat of Slot %d",\r\nk, other_slots[octet1 - 1], octet1);\r\n}\r\nelse\r\n{\r\nk++;\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,\r\n"%d, Apparent forward reference to slot %d",\r\nk, octet1);\r\n}\r\n}\r\nelse if (octet1 == 0x40)\r\n{\r\nk++;\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,\r\n"%d Free Message Slot, optional reading", k);\r\n}\r\nelse if (octet1 == 0x41)\r\n{\r\nk++;\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset++, 1, k,\r\n"%d Free Message Slot, reading advised", k);\r\n}\r\nelse\r\n{\r\nk++;\r\nproto_tree_add_uint_format_value(sched_subtree, hf_gsm_cbch_slot, tvb, offset, 1, k,\r\n"%d reserved MDT: %x", k, octet1);\r\n}\r\n}\r\nproto_item_set_end(item, tvb, offset);\r\nproto_tree_add_item(sched_tree, hf_gsm_cbch_padding, tvb, offset, -1, ENC_NA);\r\n}\r\n}\r\n}\r\nstatic int\r\ndissect_cbch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\r\n{\r\nfragment_head *frag_data = NULL;\r\nguint8 octet, lb, lpd, seq_num;\r\nguint32 offset;\r\nproto_item *cbch_item, *lpd_item, *seq_item;\r\nproto_tree *cbch_tree;\r\ntvbuff_t *reass_tvb = NULL, *msg_tvb = NULL;\r\noffset = 0;\r\noctet = tvb_get_guint8(tvb, offset);\r\ncbch_item = proto_tree_add_protocol_format(tree, proto_cbch, tvb, 0, -1,\r\n"GSM CBCH - Block (0x%02x)", octet&3);\r\ncol_append_str(pinfo->cinfo, COL_PROTOCOL, " CBCH");\r\ncbch_tree = proto_item_add_subtree(cbch_item, ett_cbch_msg);\r\nproto_tree_add_uint(cbch_tree, hf_gsm_cbch_block, tvb, offset, 1, octet);\r\nproto_tree_add_uint(cbch_tree, hf_gsm_cbch_spare_bit, tvb, offset, 1, octet);\r\nlpd_item = proto_tree_add_uint(cbch_tree, hf_gsm_cbch_lpd, tvb, offset, 1, octet);\r\nproto_tree_add_uint(cbch_tree, hf_gsm_cbch_lb, tvb, offset, 1, octet);\r\nseq_item = proto_tree_add_uint(cbch_tree, hf_gsm_cbch_seq_num, tvb, offset, 1, octet);\r\nseq_num = octet & 0x0F;\r\nlpd = (octet & 0x60) >> 5;\r\nlb = (octet & 0x10) >> 4;\r\nif (lpd == 1)\r\n{\r\nswitch (seq_num)\r\n{\r\ncase 0x00:\r\ncase 0x08:\r\npinfo->fragmented = TRUE;\r\nfrag_data = fragment_add_seq_check(&cbch_block_reassembly_table,\r\ntvb, offset, pinfo, 0, NULL,\r\nseq_num & 0x03, CBCH_FRAGMENT_SIZE + 1, !lb);\r\nreass_tvb = process_reassembled_data(tvb, offset, pinfo, "Reassembled CBCH message",\r\nfrag_data, &cbch_frag_items, NULL, cbch_tree);\r\nbreak;\r\ncase 0x01:\r\ncase 0x02:\r\ncase 0x03:\r\npinfo->fragmented = TRUE;\r\noffset++;\r\nfrag_data = fragment_add_seq_check(&cbch_block_reassembly_table,\r\ntvb, offset, pinfo, 0, NULL,\r\nseq_num, CBCH_FRAGMENT_SIZE, !lb);\r\nreass_tvb = process_reassembled_data(tvb, offset, pinfo, "Reassembled CBCH message",\r\nfrag_data, &cbch_frag_items, NULL, cbch_tree);\r\nbreak;\r\ncase 0x0F:\r\nexpert_add_info(pinfo, seq_item, &ei_gsm_cbch_seq_num_null);\r\ncall_data_dissector(tvb, pinfo, cbch_tree);\r\nbreak;\r\ndefault:\r\nexpert_add_info(pinfo, seq_item, &ei_gsm_cbch_seq_num_reserved);\r\ncall_data_dissector(tvb, pinfo, cbch_tree);\r\nbreak;\r\n}\r\nif (reass_tvb)\r\n{\r\noffset = 0;\r\noctet = tvb_get_guint8(reass_tvb, offset++);\r\nmsg_tvb = tvb_new_subset_remaining(reass_tvb, offset);\r\nif (octet & 0x08)\r\n{\r\ndissect_schedule_message(msg_tvb, pinfo, tree);\r\n}\r\nelse\r\n{\r\ncall_dissector(cbs_handle, msg_tvb, pinfo, tree);\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nexpert_add_info(pinfo, lpd_item, &ei_gsm_cbch_lpd);\r\ncall_data_dissector(tvb, pinfo, cbch_tree);\r\n}\r\nreturn tvb_captured_length(tvb);\r\n}\r\nvoid\r\nproto_register_gsm_cbch(void)\r\n{\r\nstatic hf_register_info hf_smscb[] =\r\n{\r\n{ &hf_gsm_cbch_spare_bit,\r\n{ "GSM CBCH spare bit", "gsm_cbch.block_type.spare",\r\nFT_UINT8, BASE_HEX, NULL, 0x80,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_lpd,\r\n{ "GSM CBCH Link Protocol Discriminator", "gsm_cbch.block_type.lpd",\r\nFT_UINT8, BASE_DEC, VALS(block_type_lpd_strings), 0x60,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_lb,\r\n{ "GSM CBCH Last Block", "gsm_cbch.block_type.lb",\r\nFT_UINT8, BASE_DEC, NULL, 0x10,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_seq_num,\r\n{ "GSM CBCH Sequence Number", "gsm_cbch.block_type.seq_num",\r\nFT_UINT8, BASE_DEC, VALS(block_type_seq_num_values), 0x0F,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_sched_type,\r\n{ "GSM CBCH Schedule Type", "gsm_cbch.sched_type",\r\nFT_UINT8, BASE_DEC, VALS(sched_type_values), 0xC0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_sched_begin_slot,\r\n{ "GSM CBCH Schedule Begin slot", "gsm_cbch.schedule_begin",\r\nFT_UINT8, BASE_DEC|BASE_RANGE_STRING, RVALS(gsm_cbch_sched_begin_slot_rvals), 0x3F,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_sched_spare,\r\n{ "GSM CBCH Schedule Spare Bits", "gsm_cbch.sched_spare",\r\nFT_UINT8, BASE_DEC, NULL, 0xC0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_sched_end_slot,\r\n{ "GSM CBCH Schedule End Slot", "gsm_cbch.sched_end",\r\nFT_UINT8, BASE_DEC, NULL, 0x3F,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_slot,\r\n{ "Slot", "gsm_cbch.slot",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_padding,\r\n{ "Padding", "gsm_cbch.padding",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n{ &hf_gsm_cbch_block,\r\n{ "CBCH Block", "gsm_cbch.block",\r\nFT_UINT8, BASE_HEX, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n#if 0\r\n{ &hf_gsm_cbch_sched_msg_id,\r\n{ "GSM CBCH Schedule Message ID", "gsm_cbch.sched_msg_id",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL}\r\n},\r\n#endif\r\n{ &hf_cbch_fragment_overlap,\r\n{ "Fragment overlap",\r\n"gsm_cbch.fragment.overlap",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Fragment overlaps with other fragments", HFILL\r\n}\r\n},\r\n{ &hf_cbch_fragment_overlap_conflict,\r\n{ "Conflicting data in fragment overlap",\r\n"gsm_cbch.fragment.overlap.conflict",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Overlapping fragments contained conflicting data", HFILL\r\n}\r\n},\r\n{ &hf_cbch_fragment_multiple_tails,\r\n{ "Multiple tail fragments found",\r\n"gsm_cbch.fragment.multipletails",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Several tails were found when defragmenting the packet", HFILL\r\n}\r\n},\r\n{ &hf_cbch_fragment_too_long_fragment,\r\n{ "Fragment too long",\r\n"gsm_cbch.fragment.toolongfragment",\r\nFT_BOOLEAN, BASE_NONE, NULL, 0x0,\r\n"Fragment contained data past end of packet", HFILL\r\n}\r\n},\r\n{ &hf_cbch_fragment_error,\r\n{ "Defragmentation error",\r\n"gsm_cbch.fragment.error",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"Defragmentation error due to illegal fragments", HFILL\r\n}\r\n},\r\n{ &hf_cbch_fragment_count,\r\n{ "Fragmentation count",\r\n"gsm_cbch.fragment.count",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Count of CBCH Fragments", HFILL\r\n}\r\n},\r\n{ &hf_cbch_reassembled_in,\r\n{ "Reassembled in",\r\n"gsm_cbch.reassembled.in",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"CBCH fragments are reassembled in the given packet", HFILL\r\n}\r\n},\r\n{ &hf_cbch_reassembled_length,\r\n{ "Reassembled message length is one less than indicated here",\r\n"gsm_cbch.reassembled.length",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The total length of the reassembled message", HFILL\r\n}\r\n},\r\n{ &hf_cbch_fragment,\r\n{ "CBCH Fragment",\r\n"gsm_cbch.fragment",\r\nFT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_cbch_fragments,\r\n{ "CBCH Fragments",\r\n"gsm_cbch.fragments",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL\r\n}\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_cbch_msg,\r\n&ett_schedule_msg,\r\n&ett_schedule_new_msg,\r\n&ett_cbch_fragment,\r\n&ett_cbch_fragments,\r\n};\r\nexpert_module_t* expert_cbch;\r\nstatic ei_register_info ei[] = {\r\n{ &ei_gsm_cbch_sched_end_slot, { "gsm_cbch.sched_end.bad_range", PI_PROTOCOL, PI_WARN, "End Slot Number less than Begin Slot Number: ignoring message", EXPFILL }},\r\n{ &ei_gsm_cbch_seq_num_null, { "gsm_cbch.block_type.seq_num.null", PI_PROTOCOL, PI_NOTE, "NULL message", EXPFILL }},\r\n{ &ei_gsm_cbch_seq_num_reserved, { "gsm_cbch.block_type.seq_num.reserved", PI_PROTOCOL, PI_NOTE, "Reserved Sequence Number", EXPFILL }},\r\n{ &ei_gsm_cbch_lpd, { "gsm_cbch.block_type.lpd.invalid", PI_PROTOCOL, PI_WARN, "Invalid Link Protocol Discriminator", EXPFILL }},\r\n};\r\nproto_cbch = proto_register_protocol("GSM Cell Broadcast Channel", "GSM CBCH", "gsm_cbch");\r\nproto_register_field_array(proto_cbch, hf_smscb, array_length(hf_smscb));\r\nexpert_cbch = expert_register_protocol(proto_cbch);\r\nexpert_register_field_array(expert_cbch, ei, array_length(ei));\r\nregister_dissector("gsm_cbch", dissect_cbch, proto_cbch);\r\nregister_init_routine(cbch_defragment_init);\r\nregister_cleanup_routine(cbch_defragment_cleanup);\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_gsm_cbch(void)\r\n{\r\ncbs_handle = find_dissector_add_dependency("gsm_cbs", proto_cbch);\r\n}
