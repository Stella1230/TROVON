void\r\nmakeseg(char *eth1, char *eth2, char *ip1, char *ip2, char *p1, char *p2, int *s1, int *s2, char *flags, int len)\r\n{\r\nint i;\r\nprintf("2002/01/07 00:00:%02d.%06d\n", ts/1000000, ts%1000000);\r\nprintf("0000 %s %s 08 00\n", eth1, eth2);\r\nprintf("000e 45 00 %02x %02x 00 00 00 00 40 06 00 00 %s %s\n", (len+40)>>8, (len+40)&0xff, ip1, ip2);\r\nprintf("0022 %s %s %02x %02x %02x %02x %02x %02x %02x %02x 50 %s 80 00 00 00 00 00", p1, p2,\r\n((*s1)>>24)&0xff,\r\n((*s1)>>16)&0xff,\r\n((*s1)>>8)&0xff,\r\n((*s1))&0xff,\r\n((*s2)>>24)&0xff,\r\n((*s2)>>16)&0xff,\r\n((*s2)>>8)&0xff,\r\n((*s2))&0xff,\r\nflags );\r\nfor(i=0;i<(len<(snap_len-40)?len:snap_len-40);i++)printf(" 00");\r\nprintf("\n");\r\nprintf("\n");\r\n(*s1)+=len;\r\n}\r\nint next_ack_due()\r\n{\r\nint slot = next_slot;\r\nint ack_lost = 0, seg_lost = 0;\r\nif (next_slot == first_slot)\r\nreturn (((unsigned int)(1<<31)) - 1);\r\nwhile (seg_hist[slot].flags & (SEG_ACK_LOST || SEG_SEG_LOST)) {\r\nif (seg_hist[slot].flags & SEG_ACK_LOST)\r\nack_lost++;\r\nif (seg_hist[slot].flags & SEG_SEG_LOST)\r\nseg_lost++;\r\nslot = (slot + 1) % SEG_HIST_SIZE;\r\n}\r\nif (slot == next_slot)\r\nreturn (((unsigned int)(1<<31)) - 1);\r\nif (slot == first_slot && next_slot == ((first_slot + 1) % SEG_HIST_SIZE))\r\nreturn (seg_hist[first_slot].ts + ack_delay + jitter);\r\nif (seg_lost)\r\nreturn (seg_hist[slot].ts + ack_delay + jitter);\r\nif (ack_lost) {\r\nif (delayed_ack) {\r\nif (((first_slot + 1 + 2 * ack_lost) % SEG_HIST_SIZE) >= next_slot)\r\nreturn (((unsigned int)(1<<31)) - 1);\r\nelse\r\nreturn seg_hist[(first_slot + 1 + 2 * ack_lost) % SEG_HIST_SIZE].ts +\r\nack_delay + jitter;\r\n}\r\nelse\r\nreturn seg_hist[slot].ts + ack_delay + jitter;\r\n}\r\nelse {\r\nif (delayed_ack)\r\nreturn (seg_hist[(first_slot + 1)%SEG_HIST_SIZE].ts+ack_delay+jitter);\r\nelse\r\nreturn (seg_hist[first_slot].ts+ack_delay+jitter);\r\n}\r\n}\r\nint\r\ngen_next_ack(int force, int spacing)\r\n{\r\nint seq_to_ack, new_ts, data_acked;\r\nseq_to_ack = seg_hist[first_slot].seq_num + seg_hist[first_slot].len;\r\nused_win = used_win - seg_hist[first_slot].len;\r\ndata_acked = seg_hist[first_slot].len;\r\nnew_ts = seg_hist[first_slot].ts + ack_delay;\r\nfirst_slot = (first_slot + 1) % SEG_HIST_SIZE;\r\nif (delayed_ack && (first_slot != next_slot)) {\r\nseq_to_ack += seg_hist[first_slot].len;\r\nused_win = used_win - seg_hist[first_slot].len;\r\ndata_acked += seg_hist[first_slot].len;\r\nnew_ts = seg_hist[first_slot].ts + ack_delay;\r\nfirst_slot = (first_slot + 1) % SEG_HIST_SIZE;\r\n}\r\nif (new_ts + jitter <= ts)\r\nts++;\r\nelse\r\nts = new_ts + jitter;\r\njitter = (rand() % 10 - 5);\r\nmakeseg(eth_2, eth_1, ip_2, ip_1, port_2, port_1, &seq_2, &seq_to_ack, "10", 0);\r\nif (cwnd >= ssthresh)\r\ncwnd += (1460*data_acked)/cwnd;\r\nelse\r\ncwnd = cwnd + data_acked;\r\nif (verbose) fprintf(stderr, "Ack rcvd. ts: %d, data_acked: %d, cwnd: %d, window: %d\n",\r\nts, data_acked, cwnd, window);\r\nif (cwnd > window) cwnd = window;\r\n}\r\nvoid\r\nmakeackedrun(int len, int spacing, int ackdelay)\r\n{\r\nint next_ack_ts=0;\r\nif (verbose) fprintf(stderr, "makeackedrun: Len=%d, spacing=%d, ackdelay=%d\n",\r\nlen, spacing, ackdelay);\r\nwhile(len>0){\r\nint seglen, saved_seq;\r\nseglen=(len>1460)?1460:len;\r\nif (seglen > (cwnd - used_win)) seglen = cwnd - used_win;\r\nlen-=seglen;\r\nsaved_seq = seq_1;\r\nif (verbose) fprintf(stderr, "Sending segment. ts: %d, jitter: %d\n", ts, jitter);\r\nif(len){\r\nmakeseg(eth_1, eth_2, ip_1, ip_2, port_1, port_2, &seq_1, &seq_2, "10", seglen);\r\n} else {\r\nmakeseg(eth_1, eth_2, ip_1, ip_2, port_1, port_2, &seq_1, &seq_2, "18", seglen);\r\n}\r\nadd_seg_sent(saved_seq, seglen);\r\njitter = (rand()%10) - 5;\r\nif (verbose) fprintf(stderr, "used win: %d, cwnd: %d\n", used_win, cwnd);\r\nif ((next_ack_ts = next_ack_due()) < ts + spacing + jitter) {\r\nint old_ts = ts;\r\nif (verbose) fprintf(stderr, "Non forced ACK ...ts + spacing + jitter:%d, jitter: %d\n", ts + spacing + jitter, jitter);\r\ngen_next_ack(NO_FORCE_ACK, spacing);\r\nif (old_ts + spacing + jitter <= ts)\r\nts++;\r\nelse\r\nts = old_ts + spacing + jitter;\r\n} else if (used_win == cwnd) {\r\nif (verbose) fprintf(stderr, "Forced ACK ... \n");\r\ngen_next_ack(FORCE_ACK, spacing);\r\nts+=(spacing+jitter);\r\n}\r\nelse {\r\nts+=(spacing+jitter);\r\n}\r\nif (verbose) fprintf(stderr, "Next Ack Due: %d\n", next_ack_ts);\r\n}\r\n}\r\nvoid\r\nmakeackedrundroppedtail8kb(int len, int spacing, int ackdelay)\r\n{\r\nint old_seq1;\r\nint dropped_tail;\r\nint i;\r\nint num_dupes;\r\nif (verbose) fprintf(stderr, "makeackedrundroppedtail8kB: Len=%d, spacing=%d, ackdelay=%d\n",\r\nlen, spacing, ackdelay);\r\nold_seq1=seq_1;\r\nwhile(len>0){\r\nint seglen;\r\nseglen=(len>1460)?1460:len;\r\nlen-=seglen;\r\nif(seglen==1460){\r\nmakeseg(eth_1, eth_2, ip_1, ip_2, port_1, port_2, &seq_1, &seq_2, "10", seglen);\r\n} else {\r\nmakeseg(eth_1, eth_2, ip_1, ip_2, port_1, port_2, &seq_1, &seq_2, "18", seglen);\r\n}\r\nts+=spacing;\r\n}\r\nts+=ackdelay;\r\ni=0;\r\nnum_dupes=-1;\r\ndropped_tail=0;\r\nwhile(old_seq1!=seq_1){\r\nint ack_len;\r\nack_len=((seq_1-old_seq1)>2920)?2920:(seq_1-old_seq1);\r\ni++;\r\nif(i==6){\r\ndropped_tail=old_seq1;\r\n}\r\nold_seq1+=ack_len;\r\nif(i<6){\r\nmakeseg(eth_2, eth_1, ip_2, ip_1, port_2, port_1, &seq_2, &old_seq1, "10", 0);\r\n} else if (i==6) {\r\nmakeseg(eth_2, eth_1, ip_2, ip_1, port_2, port_1, &seq_2, &dropped_tail, "10", 0);\r\nnum_dupes+=2;\r\n} else {\r\nmakeseg(eth_2, eth_1, ip_2, ip_1, port_2, port_1, &seq_2, &dropped_tail, "10", 0);\r\nmakeseg(eth_2, eth_1, ip_2, ip_1, port_2, port_1, &seq_2, &dropped_tail, "10", 0);\r\nnum_dupes+=2;\r\n}\r\nts+=spacing/2;\r\n}\r\nif(!dropped_tail){\r\nreturn;\r\n}\r\nif(num_dupes<3){\r\nint seglen;\r\nts+=1000000;\r\nseglen=((seq_1-dropped_tail)>1460)?1460:(seq_1-dropped_tail);\r\nif(seglen==1460){\r\nmakeseg(eth_1, eth_2, ip_1, ip_2, port_1, port_2, &dropped_tail, &seq_2, "10", seglen);\r\n} else {\r\nmakeseg(eth_1, eth_2, ip_1, ip_2, port_1, port_2, &dropped_tail, &seq_2, "18", seglen);\r\n}\r\nts+=ackdelay;\r\nmakeseg(eth_2, eth_1, ip_2, ip_1, port_2, port_1, &seq_2, &seq_1, "10", 0);\r\nts+=spacing;\r\nreturn;\r\n}\r\nwhile(dropped_tail!=seq_1){\r\nint seglen;\r\nint ack;\r\nseglen=((seq_1-dropped_tail)>1460)?1460:(seq_1-dropped_tail);\r\nif(seglen==1460){\r\nmakeseg(eth_1, eth_2, ip_1, ip_2, port_1, port_2, &dropped_tail, &seq_2, "10", seglen);\r\n} else {\r\nmakeseg(eth_1, eth_2, ip_1, ip_2, port_1, port_2, &dropped_tail, &seq_2, "18", seglen);\r\n}\r\nts+=ackdelay;\r\nack=dropped_tail;\r\nmakeseg(eth_2, eth_1, ip_2, ip_1, port_2, port_1, &seq_2, &ack, "10", 0);\r\nts+=spacing;\r\n}\r\n}\r\nvoid usage()\r\n{\r\nfprintf(stderr, "Usage: mkcap [OPTIONS], where\n");\r\nfprintf(stderr, "\t-a <ack-delay> is the delay to an ACK (SRT)\n");\r\nfprintf(stderr, "\t-b <bytes-to-send> is the bytes to send on connection\n");\r\nfprintf(stderr, "\t-i <ip-addr-hex> is the sender IP address in hex\n");\r\nfprintf(stderr, "\t-I <ip-addr-hex> is the recipient IP address in hex\n");\r\nfprintf(stderr, "\t-n <ISN> is almost the ISN for the sender\n");\r\nfprintf(stderr, "\t-N <ISN> is almost the ISN for the recipient\n");\r\nfprintf(stderr, "\t-p <port-number-hex> is the port number for sender\n");\r\nfprintf(stderr, "\t-P <port-number-hex> is the port number for recipient\n");\r\nfprintf(stderr, "\t-s <send-spacing> is the send spacing\n");\r\nfprintf(stderr, "\t-w <window-size> is the window size\n");\r\n}\r\nint\r\nall_digits(char *str)\r\n{\r\nint i;\r\nif (!str || !(*str)) {\r\nreturn 0;\r\n}\r\nfor (i = 0; str[i]; i++) {\r\nif (!isdigit(str[i]))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid\r\nprocess_drop_list(char *drop_list)\r\n{\r\nint commas=0;\r\nchar *tok, *save;\r\nif (!drop_list || !(*drop_list)) {\r\nfprintf(stderr, "Strange drop list. NULL or an empty string. No drops!\n");\r\nreturn;\r\n}\r\nsave = (char *)g_strdup(drop_list);\r\nfor (tok=(char *)strtok(drop_list, ","); tok; tok=(char *)strtok(NULL, ",")) {\r\ncommas++;\r\n}\r\nseg_drop_count = (commas+1)/2;\r\ndrops = (seg_drop_t *)g_malloc(sizeof(seg_drop_t) * seg_drop_count);\r\nif (!drops) {\r\nfprintf(stderr, "Unable to allocate space for drops ... going without!\n");\r\nseg_drop_count = 0;\r\ng_free(save);\r\nreturn;\r\n}\r\ncommas = 0;\r\nfor (tok=(char *)strtok(save, ","); tok; tok=(char *)strtok(NULL, ",")) {\r\nint num = atoi(tok);\r\nif (!all_digits(tok)) {\r\nfprintf(stderr, "Error in segment offset or count. Not all digits: %s\n",\r\ntok);\r\nfprintf(stderr, "No packet drops being performed!\n");\r\ng_free(save);\r\ng_free(drops);\r\nseg_drop_count = 0; drops = NULL;\r\nreturn;\r\n}\r\nif (num == 0) num = 1;\r\nif (commas % 2)\r\ndrops[commas / 2].drop_seg_count = num;\r\nelse\r\ndrops[commas / 2].drop_seg_start = num;\r\n}\r\ng_free(save);\r\n}\r\nint\r\nmain(int argc, char *argv[])\r\n{\r\nint i;\r\nint len;\r\nint type;\r\nint cnt;\r\nextern char *optarg;\r\nextern int optind;\r\nint opt;\r\nwhile ((opt = getopt(argc, argv, "a:b:d:Di:I:j:l:n:N:p:P:r:s:vw:")) != EOF) {\r\nswitch (opt) {\r\ncase 'a':\r\nack_delay = atoi(optarg);\r\nbreak;\r\ncase 'b':\r\ntotal_bytes = atoi(optarg);\r\nbreak;\r\ncase 'd':\r\nprocess_drop_list(optarg);\r\nbreak;\r\ncase 'D':\r\ntcp_nodelay = (tcp_nodelay + 1) % 1;\r\nbreak;\r\ncase 'i':\r\nip_1 = optarg;\r\nbreak;\r\ncase 'I':\r\nip_2 = optarg;\r\nbreak;\r\ncase 'l':\r\nsnap_len = atoi(optarg);\r\nbreak;\r\ncase 'n':\r\nseq_1 = atoi(optarg);\r\nbreak;\r\ncase 'N':\r\nseq_2 = atoi(optarg);\r\nbreak;\r\ncase 'p':\r\nport_1 = optarg;\r\nbreak;\r\ncase 'P':\r\nport_2 = optarg;\r\nbreak;\r\ncase 'r':\r\nrun_type = atoi(optarg);\r\nbreak;\r\ncase 's':\r\nsend_spacing = atoi(optarg);\r\nbreak;\r\ncase 'v':\r\nverbose++;\r\nbreak;\r\ncase 'w':\r\nwindow = atoi(optarg);\r\nssthresh = window / 2;\r\nbreak;\r\ndefault:\r\nusage();\r\nbreak;\r\n}\r\n}\r\nif (verbose) fprintf(stderr, "IP1: %s, IP2: %s, P1: %s, P2: %s, Ack Delay: %d, Send Spacing: %d\n",\r\nip_1, ip_2, port_1, port_2, ack_delay, send_spacing);\r\nif (run_type == 0) {\r\nmakeackedrun(total_bytes, send_spacing, ack_delay);\r\n}\r\nelse {\r\nfor(cnt=0;cnt<200;cnt++){\r\ntype=rand()%150;\r\nif(type<75){\r\nint j;\r\nj=5+rand()%10;\r\nfor(i=0;i<j;i++){\r\nmakeackedrun(32768, send_spacing, ack_delay);\r\n}\r\n} else if(type<90) {\r\nint j;\r\nj=4+rand()%4;\r\nfor(i=0;i<j;i++){\r\nlen=100+rand()&0xfff;\r\nmakeackedrun(len, send_spacing, ack_delay);\r\n}\r\n} else {\r\nfor(i=0;i<5;i++){\r\nlen=100+rand()&0x3fff+0x1fff;\r\nmakeackedrun(len, send_spacing, ack_delay);\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}
