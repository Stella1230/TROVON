guint\r\npref_stash(pref_t *pref, gpointer unused _U_)\r\n{\r\nswitch (pref->type) {\r\ncase PREF_UINT:\r\npref->stashed_val.uint = *pref->varp.uint;\r\nbreak;\r\ncase PREF_BOOL:\r\npref->stashed_val.boolval = *pref->varp.boolp;\r\nbreak;\r\ncase PREF_ENUM:\r\npref->stashed_val.enumval = *pref->varp.enump;\r\nbreak;\r\ncase PREF_STRING:\r\ncase PREF_FILENAME:\r\ncase PREF_DIRNAME:\r\ng_free(pref->stashed_val.string);\r\npref->stashed_val.string = g_strdup(*pref->varp.string);\r\nbreak;\r\ncase PREF_RANGE:\r\ng_free(pref->stashed_val.range);\r\npref->stashed_val.range = range_copy(*pref->varp.range);\r\nbreak;\r\ncase PREF_COLOR:\r\npref->stashed_val.color = *pref->varp.colorp;\r\nbreak;\r\ncase PREF_STATIC_TEXT:\r\ncase PREF_UAT:\r\ncase PREF_CUSTOM:\r\nbreak;\r\ncase PREF_OBSOLETE:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nguint\r\npref_unstash(pref_t *pref, gpointer changed_p)\r\n{\r\ngboolean *pref_changed_p = (gboolean *)changed_p;\r\nswitch (pref->type) {\r\ncase PREF_UINT:\r\nif (*pref->varp.uint != pref->stashed_val.uint) {\r\n*pref_changed_p = TRUE;\r\n*pref->varp.uint = pref->stashed_val.uint;\r\n}\r\nbreak;\r\ncase PREF_BOOL:\r\nif (*pref->varp.boolp != pref->stashed_val.boolval) {\r\n*pref_changed_p = TRUE;\r\n*pref->varp.boolp = pref->stashed_val.boolval;\r\n}\r\nbreak;\r\ncase PREF_ENUM:\r\nif (*pref->varp.enump != pref->stashed_val.enumval) {\r\n*pref_changed_p = TRUE;\r\n*pref->varp.enump = pref->stashed_val.enumval;\r\n}\r\nbreak;\r\ncase PREF_STRING:\r\ncase PREF_FILENAME:\r\ncase PREF_DIRNAME:\r\nif (strcmp(*pref->varp.string, pref->stashed_val.string) != 0) {\r\n*pref_changed_p = TRUE;\r\ng_free((void *)*pref->varp.string);\r\n*pref->varp.string = g_strdup(pref->stashed_val.string);\r\n}\r\nbreak;\r\ncase PREF_RANGE:\r\nif (!ranges_are_equal(*pref->varp.range, pref->stashed_val.range)) {\r\n*pref_changed_p = TRUE;\r\ng_free(*pref->varp.range);\r\n*pref->varp.range = range_copy(pref->stashed_val.range);\r\n}\r\nbreak;\r\ncase PREF_COLOR:\r\n*pref->varp.colorp = pref->stashed_val.color;\r\nbreak;\r\ncase PREF_STATIC_TEXT:\r\ncase PREF_UAT:\r\ncase PREF_CUSTOM:\r\nbreak;\r\ncase PREF_OBSOLETE:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nreset_stashed_pref(pref_t *pref) {\r\nswitch (pref->type) {\r\ncase PREF_UINT:\r\npref->stashed_val.uint = pref->default_val.uint;\r\nbreak;\r\ncase PREF_BOOL:\r\npref->stashed_val.boolval = pref->default_val.boolval;\r\nbreak;\r\ncase PREF_ENUM:\r\npref->stashed_val.enumval = pref->default_val.enumval;\r\nbreak;\r\ncase PREF_STRING:\r\ncase PREF_FILENAME:\r\ncase PREF_DIRNAME:\r\ng_free(pref->stashed_val.string);\r\npref->stashed_val.string = g_strdup(pref->default_val.string);\r\nbreak;\r\ncase PREF_RANGE:\r\ng_free(pref->stashed_val.range);\r\npref->stashed_val.range = range_copy(pref->default_val.range);\r\nbreak;\r\ncase PREF_COLOR:\r\nmemcpy(&pref->stashed_val.color, &pref->default_val.color, sizeof(color_t));\r\nbreak;\r\ncase PREF_STATIC_TEXT:\r\ncase PREF_UAT:\r\ncase PREF_CUSTOM:\r\nbreak;\r\ncase PREF_OBSOLETE:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\nguint\r\npref_clean_stash(pref_t *pref, gpointer unused _U_)\r\n{\r\nswitch (pref->type) {\r\ncase PREF_UINT:\r\nbreak;\r\ncase PREF_BOOL:\r\nbreak;\r\ncase PREF_ENUM:\r\nbreak;\r\ncase PREF_STRING:\r\ncase PREF_FILENAME:\r\ncase PREF_DIRNAME:\r\nif (pref->stashed_val.string != NULL) {\r\ng_free(pref->stashed_val.string);\r\npref->stashed_val.string = NULL;\r\n}\r\nbreak;\r\ncase PREF_RANGE:\r\nif (pref->stashed_val.range != NULL) {\r\ng_free(pref->stashed_val.range);\r\npref->stashed_val.range = NULL;\r\n}\r\nbreak;\r\ncase PREF_STATIC_TEXT:\r\ncase PREF_UAT:\r\ncase PREF_COLOR:\r\ncase PREF_CUSTOM:\r\nbreak;\r\ncase PREF_OBSOLETE:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nprefs_to_capture_opts(void)\r\n{\r\n#ifdef HAVE_LIBPCAP\r\nglobal_capture_opts.default_options.promisc_mode = prefs.capture_prom_mode;\r\nglobal_capture_opts.use_pcapng = prefs.capture_pcap_ng;\r\nglobal_capture_opts.show_info = prefs.capture_show_info;\r\nglobal_capture_opts.real_time_mode = prefs.capture_real_time;\r\nauto_scroll_live = prefs.capture_auto_scroll;\r\n#endif\r\n}\r\nvoid\r\nprefs_main_write(void)\r\n{\r\nint err;\r\nchar *pf_dir_path;\r\nchar *pf_path;\r\nif (create_persconffile_dir(&pf_dir_path) == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't create directory\n\"%s\"\nfor preferences file: %s.", pf_dir_path,\r\ng_strerror(errno));\r\ng_free(pf_dir_path);\r\n} else {\r\nerr = write_prefs(&pf_path);\r\nif (err != 0) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't open preferences file\n\"%s\": %s.", pf_path,\r\ng_strerror(err));\r\ng_free(pf_path);\r\n}\r\n}\r\n}\r\nvoid\r\ncolumn_prefs_add_custom(gint fmt, const gchar *title, const gchar *custom_field, gint custom_occurrence)\r\n{\r\nGList *clp;\r\nfmt_data *cfmt, *last_cfmt;\r\ncfmt = (fmt_data *) g_malloc(sizeof(fmt_data));\r\ncfmt->title = g_strdup(title);\r\ncfmt->fmt = fmt;\r\ncfmt->custom_field = g_strdup(custom_field);\r\ncfmt->custom_occurrence = custom_occurrence;\r\ncfmt->resolved = TRUE;\r\nif (custom_field) {\r\ncfmt->visible = TRUE;\r\nclp = g_list_last(prefs.col_list);\r\nlast_cfmt = (fmt_data *) clp->data;\r\nif (last_cfmt->fmt == COL_INFO) {\r\nprefs.col_list = g_list_insert(prefs.col_list, cfmt, g_list_length(prefs.col_list)-1);\r\n} else {\r\nprefs.col_list = g_list_append(prefs.col_list, cfmt);\r\n}\r\n} else {\r\ncfmt->visible = FALSE;\r\nprefs.col_list = g_list_append(prefs.col_list, cfmt);\r\n}\r\n}\r\nvoid\r\ncolumn_prefs_remove_link(GList *col_link)\r\n{\r\nfmt_data *cfmt;\r\nif (!col_link || !col_link->data) return;\r\ncfmt = (fmt_data *) col_link->data;\r\ng_free(cfmt->title);\r\ng_free(cfmt->custom_field);\r\ng_free(cfmt);\r\nprefs.col_list = g_list_remove_link(prefs.col_list, col_link);\r\n}\r\nvoid\r\ncolumn_prefs_remove_nth(gint col)\r\n{\r\ncolumn_prefs_remove_link(g_list_nth(prefs.col_list, col));\r\n}
