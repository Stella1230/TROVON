int get_int_field (lua_State *L, const char* field)\r\n{\r\nint val;\r\nlua_getfield (L, -1, field);\r\nval = (int) lua_tointeger (L, -1);\r\nlua_pop (L, 1);\r\nreturn val;\r\n}\r\nvoid set_int_field (lua_State *L, const char* field, int val)\r\n{\r\nlua_pushinteger (L, val);\r\nlua_setfield (L, -2, field);\r\n}\r\nvoid *Lmalloc(lua_State *L, size_t size) {\r\nvoid *ud;\r\nlua_Alloc lalloc = lua_getallocf(L, &ud);\r\nreturn lalloc(ud, NULL, 0, size);\r\n}\r\nvoid *Lrealloc(lua_State *L, void *p, size_t osize, size_t nsize) {\r\nvoid *ud;\r\nlua_Alloc lalloc = lua_getallocf(L, &ud);\r\nreturn lalloc(ud, p, osize, nsize);\r\n}\r\nvoid Lfree(lua_State *L, void *p, size_t osize) {\r\nvoid *ud;\r\nlua_Alloc lalloc = lua_getallocf(L, &ud);\r\nlalloc(ud, p, osize, 0);\r\n}\r\nint get_flags (lua_State *L, const flag_pair **arrs) {\r\nconst flag_pair *p;\r\nconst flag_pair **pp;\r\nint nparams = lua_gettop(L);\r\nif(nparams == 0)\r\nlua_newtable(L);\r\nelse {\r\nif(!lua_istable(L, 1))\r\nluaL_argerror(L, 1, "not a table");\r\nif(nparams > 1)\r\nlua_pushvalue(L, 1);\r\n}\r\nfor(pp=arrs; *pp; ++pp) {\r\nfor(p=*pp; p->key; ++p) {\r\nlua_pushstring(L, p->key);\r\nlua_pushinteger(L, p->val);\r\nlua_rawset(L, -3);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nconst char *get_flag_key (const flag_pair *fp, int val) {\r\nfor (; fp->key; ++fp) {\r\nif (fp->val == val)\r\nreturn fp->key;\r\n}\r\nreturn NULL;\r\n}\r\nvoid freelist_init (TFreeList *fl) {\r\nfl->top = 0;\r\n}\r\nvoid freelist_add (TFreeList *fl, TBuffer *buf) {\r\nfl->list[fl->top++] = buf;\r\n}\r\nvoid freelist_free (TFreeList *fl) {\r\nwhile (fl->top > 0)\r\nbuffer_free (fl->list[--fl->top]);\r\n}\r\nvoid buffer_init (TBuffer *buf, size_t sz, lua_State *L, TFreeList *fl) {\r\nbuf->arr = (char *)Lmalloc(L, sz);\r\nif (!buf->arr) {\r\nfreelist_free (fl);\r\nluaL_error (L, "malloc failed");\r\nreturn;\r\n}\r\nbuf->size = sz;\r\nbuf->top = 0;\r\nbuf->L = L;\r\nbuf->freelist = fl;\r\nfreelist_add (fl, buf);\r\n}\r\nvoid buffer_free (TBuffer *buf) {\r\nLfree(buf->L, buf->arr, buf->size);\r\n}\r\nvoid buffer_clear (TBuffer *buf) {\r\nbuf->top = 0;\r\n}\r\nvoid buffer_pushresult (TBuffer *buf) {\r\nlua_pushlstring (buf->L, buf->arr, buf->top);\r\n}\r\nvoid buffer_addbuffer (TBuffer *trg, TBuffer *src) {\r\nbuffer_addlstring (trg, src->arr, src->top);\r\n}\r\nvoid buffer_addlstring (TBuffer *buf, const void *src, size_t sz) {\r\nsize_t newtop = buf->top + sz;\r\nif (newtop > buf->size) {\r\nchar *p = (char*) Lrealloc (buf->L, buf->arr, buf->size, 2 * newtop);\r\nif (!p) {\r\nfreelist_free (buf->freelist);\r\nluaL_error (buf->L, "realloc failed");\r\nreturn;\r\n}\r\nbuf->arr = p;\r\nbuf->size = 2 * newtop;\r\n}\r\nif (src)\r\nmemcpy (buf->arr + buf->top, src, sz);\r\nbuf->top = newtop;\r\n}\r\nvoid buffer_addvalue (TBuffer *buf, int stackpos) {\r\nsize_t len;\r\nconst char *p = lua_tolstring (buf->L, stackpos, &len);\r\nbuffer_addlstring (buf, p, len);\r\n}\r\nvoid bufferZ_addlstring (TBuffer *buf, const void *src, size_t len) {\r\nint n;\r\nsize_t header[2] = { ID_STRING };\r\nheader[1] = len;\r\nbuffer_addlstring (buf, header, sizeof (header));\r\nbuffer_addlstring (buf, src, len);\r\nn = (int)(len % N_ALIGN);\r\nif (n) buffer_addlstring (buf, NULL, N_ALIGN - n);\r\n}\r\nvoid bufferZ_addnum (TBuffer *buf, size_t num) {\r\nsize_t header[2] = { ID_NUMBER };\r\nheader[1] = num;\r\nbuffer_addlstring (buf, header, sizeof (header));\r\n}\r\nvoid bufferZ_putrepstring (TBuffer *BufRep, int reppos, int nsub) {\r\nchar dbuf[] = { 0, 0 };\r\nsize_t replen;\r\nconst char *p = lua_tolstring (BufRep->L, reppos, &replen);\r\nconst char *end = p + replen;\r\nBufRep->top = 0;\r\nwhile (p < end) {\r\nconst char *q;\r\nfor (q = p; q < end && *q != '%'; ++q)\r\n{}\r\nif (q != p)\r\nbufferZ_addlstring (BufRep, p, q - p);\r\nif (q < end) {\r\nif (++q < end) {\r\nif (isdigit (*q)) {\r\nint num;\r\n*dbuf = *q;\r\nnum = (int) strtol (dbuf, NULL, 10);\r\nif (num == 1 && nsub == 0)\r\nnum = 0;\r\nelse if (num > nsub) {\r\nfreelist_free (BufRep->freelist);\r\nluaL_error (BufRep->L, "invalid capture index");\r\nreturn;\r\n}\r\nbufferZ_addnum (BufRep, num);\r\n}\r\nelse bufferZ_addlstring (BufRep, q, 1);\r\n}\r\np = q + 1;\r\n}\r\nelse break;\r\n}\r\n}\r\nint bufferZ_next (TBuffer *buf, size_t *iter, size_t *num, const char **str) {\r\nif (*iter < buf->top) {\r\nsize_t *ptr_header = (size_t*)(void*)(buf->arr + *iter);\r\n*num = ptr_header[1];\r\n*iter += 2 * sizeof (size_t);\r\n*str = NULL;\r\nif (*ptr_header == ID_STRING) {\r\nint n;\r\n*str = buf->arr + *iter;\r\n*iter += *num;\r\nn = (int)(*iter % N_ALIGN);\r\nif (n) *iter += (N_ALIGN - n);\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint luaL_typerror (lua_State *L, int narg, const char *tname) {\r\nconst char *msg = lua_pushfstring(L, "%s expected, got %s",\r\ntname, luaL_typename(L, narg));\r\nreturn luaL_argerror(L, narg, msg);\r\n}
