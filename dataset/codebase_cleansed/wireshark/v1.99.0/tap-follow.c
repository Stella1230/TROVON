static void\r\nfollowExit(\r\nconst char * strp\r\n)\r\n{\r\nfprintf(stderr, "tshark: follow - %s\n", strp);\r\nexit(1);\r\n}\r\nstatic const char *\r\nfollowStrType(\r\nconst follow_t * fp\r\n)\r\n{\r\nswitch (fp->type)\r\n{\r\ncase type_TCP: return "tcp";\r\ncase type_UDP: return "udp";\r\ncase type_SSL: return "ssl";\r\n}\r\ng_assert_not_reached();\r\nreturn "<unknown-type>";\r\n}\r\nstatic const char *\r\nfollowStrMode(\r\nconst follow_t * fp\r\n)\r\n{\r\nswitch (fp->mode)\r\n{\r\ncase mode_HEX: return "hex";\r\ncase mode_ASCII: return "ascii";\r\ncase mode_RAW: return "raw";\r\n}\r\ng_assert_not_reached();\r\nreturn "<unknown-mode>";\r\n}\r\nstatic const char *\r\nfollowStrFilter(\r\nconst follow_t * fp\r\n)\r\n{\r\nstatic char filter[512];\r\nint len = 0;\r\nconst gchar * verp;\r\ngchar ip0[MAX_IP6_STR_LEN];\r\ngchar ip1[MAX_IP6_STR_LEN];\r\nif (fp->index != G_MAXUINT32)\r\n{\r\nswitch (fp->type)\r\n{\r\ncase type_TCP:\r\ncase type_SSL:\r\nlen = g_snprintf(filter, sizeof filter,\r\n"tcp.stream eq %d", fp->index);\r\nbreak;\r\ncase type_UDP:\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nverp = fp->addr[0].type == AT_IPv6 ? "v6" : "";\r\naddress_to_str_buf(&fp->addr[0], ip0, sizeof ip0);\r\naddress_to_str_buf(&fp->addr[1], ip1, sizeof ip1);\r\nswitch (fp->type)\r\n{\r\ncase type_TCP:\r\nlen = g_snprintf(filter, sizeof filter,\r\n"((ip%s.src eq %s and tcp.srcport eq %d) and "\r\n"(ip%s.dst eq %s and tcp.dstport eq %d))"\r\n" or "\r\n"((ip%s.src eq %s and tcp.srcport eq %d) and "\r\n"(ip%s.dst eq %s and tcp.dstport eq %d))",\r\nverp, ip0, fp->port[0],\r\nverp, ip1, fp->port[1],\r\nverp, ip1, fp->port[1],\r\nverp, ip0, fp->port[0]);\r\nbreak;\r\ncase type_UDP:\r\nlen = g_snprintf(filter, sizeof filter,\r\n"((ip%s.src eq %s and udp.srcport eq %d) and "\r\n"(ip%s.dst eq %s and udp.dstport eq %d))"\r\n" or "\r\n"((ip%s.src eq %s and udp.srcport eq %d) and "\r\n"(ip%s.dst eq %s and udp.dstport eq %d))",\r\nverp, ip0, fp->port[0],\r\nverp, ip1, fp->port[1],\r\nverp, ip1, fp->port[1],\r\nverp, ip0, fp->port[0]);\r\nbreak;\r\ncase type_SSL:\r\nbreak;\r\n}\r\n}\r\nif (len == 0)\r\n{\r\nfollowExit("Don't know how to create filter.");\r\n}\r\nif (len == sizeof filter)\r\n{\r\nfollowExit("Filter buffer overflow.");\r\n}\r\nreturn filter;\r\n}\r\nstatic void\r\nfollowFileClose(\r\nfollow_t * fp\r\n)\r\n{\r\nif (fp->filep != NULL)\r\n{\r\nfclose(fp->filep);\r\nfp->filep = NULL;\r\nif (fp->type == type_TCP)\r\n{\r\ndata_out_file = NULL;\r\n}\r\n}\r\nif (fp->filenamep != NULL)\r\n{\r\nws_unlink(fp->filenamep);\r\ng_free(fp->filenamep);\r\nfp->filenamep = NULL;\r\n}\r\n}\r\nstatic void\r\nfollowFileOpen(\r\nfollow_t * fp\r\n)\r\n{\r\nint fd;\r\nchar * tempfilep;\r\nif (fp->type == type_TCP && data_out_file != NULL)\r\n{\r\nfollowExit("Only one TCP stream can be followed at a time.");\r\n}\r\nfollowFileClose(fp);\r\nfd = create_tempfile(&tempfilep, "follow");\r\nif (fd == -1)\r\n{\r\nfollowExit("Error creating temp file.");\r\n}\r\nfp->filenamep = g_strdup(tempfilep);\r\nif (fp->filenamep == NULL)\r\n{\r\nws_close(fd);\r\nws_unlink(tempfilep);\r\nfollowExit("Error duping temp file name.");\r\n}\r\nfp->filep = fdopen(fd, "w+b");\r\nif (fp->filep == NULL)\r\n{\r\nws_close(fd);\r\nws_unlink(fp->filenamep);\r\ng_free(fp->filenamep);\r\nfp->filenamep = NULL;\r\nfollowExit("Error opening temp file stream.");\r\n}\r\nif (fp->type == type_TCP)\r\n{\r\ndata_out_file = fp->filep;\r\n}\r\n}\r\nstatic follow_t *\r\nfollowAlloc(\r\ntype_e type\r\n)\r\n{\r\nfollow_t * fp;\r\nfp = (follow_t *)g_malloc0(sizeof *fp);\r\nfp->type = type;\r\nSET_ADDRESS(&fp->addr[0], AT_NONE, 0, fp->addrBuf[0]);\r\nSET_ADDRESS(&fp->addr[1], AT_NONE, 0, fp->addrBuf[1]);\r\nreturn fp;\r\n}\r\nstatic void\r\nfollowFree(\r\nfollow_t * fp\r\n)\r\n{\r\nfollowFileClose(fp);\r\ng_free(fp);\r\n}\r\nstatic int\r\nfollowUdpPacket(\r\nvoid * contextp,\r\npacket_info * pip,\r\nepan_dissect_t * edp _U_,\r\nconst void * datap\r\n)\r\n{\r\nfollow_t * fp = (follow_t *)contextp;\r\nconst tvbuff_t * tvbp = (const tvbuff_t *)datap;\r\ntcp_stream_chunk sc;\r\nsize_t size;\r\nif (tvbp->length > 0)\r\n{\r\nmemcpy(sc.src_addr, pip->net_src.data, pip->net_src.len);\r\nsc.src_port = pip->srcport;\r\nsc.dlen = tvbp->length;\r\nsc.packet_num = pip->fd->num;\r\nsize = fwrite(&sc, 1, sizeof sc, fp->filep);\r\nif (sizeof sc != size)\r\n{\r\nfollowExit("Error writing stream chunk header.");\r\n}\r\nsize = fwrite(tvbp->real_data, 1, sc.dlen, fp->filep);\r\nif (sc.dlen != size)\r\n{\r\nfollowExit("Error writing stream chunk data.");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nfollowSslPacket(\r\nvoid * contextp,\r\npacket_info * pip,\r\nepan_dissect_t * edp _U_,\r\nconst void * datap\r\n)\r\n{\r\nfollow_t * fp = (follow_t *)contextp;\r\nSslPacketInfo * spip = (SslPacketInfo *)p_get_proto_data(wmem_file_scope(), pip, GPOINTER_TO_INT(datap), 0);\r\nSslDataInfo * sdip;\r\ngint length;\r\ntcp_stream_chunk sc;\r\nsize_t size;\r\nif (spip == NULL)\r\n{\r\nreturn 0;\r\n}\r\nif (fp->addr[0].type == AT_NONE)\r\n{\r\nmemcpy(fp->addrBuf[0], pip->net_src.data, pip->net_src.len);\r\nSET_ADDRESS(&fp->addr[0], pip->net_src.type, pip->net_src.len,\r\nfp->addrBuf[0]);\r\nfp->port[0] = pip->srcport;\r\nmemcpy(fp->addrBuf[1], pip->net_dst.data, pip->net_dst.len);\r\nSET_ADDRESS(&fp->addr[1], pip->net_dst.type, pip->net_dst.len,\r\nfp->addrBuf[1]);\r\nfp->port[1] = pip->destport;\r\n}\r\nfor (length = 0, sdip = spip->appl_data; sdip != NULL; sdip = sdip->next)\r\n{\r\nlength += sdip->plain_data.data_len;\r\n}\r\nif (length > 0)\r\n{\r\nmemcpy(sc.src_addr, pip->net_src.data, pip->net_src.len);\r\nsc.src_port = pip->srcport;\r\nsc.dlen = length;\r\nsc.packet_num = pip->fd->num;\r\nsize = fwrite(&sc, 1, sizeof sc, fp->filep);\r\nif (sizeof sc != size)\r\n{\r\nfollowExit("Error writing stream chunk header.");\r\n}\r\nfor (sdip = spip->appl_data; sdip != NULL; sdip = sdip->next)\r\n{\r\nif (sdip->plain_data.data_len > 0)\r\n{\r\nsize = fwrite(sdip->plain_data.data, 1, sdip->plain_data.data_len,\r\nfp->filep);\r\nif (sdip->plain_data.data_len != size)\r\n{\r\nfollowExit("Error writing stream chunk data.");\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nfollowPrintHex(\r\nconst char * prefixp,\r\nguint32 offset,\r\nvoid * datap,\r\nint len\r\n)\r\n{\r\nint ii;\r\nint jj;\r\nint kk;\r\nguint8 val;\r\nchar line[LINE_LEN + 1];\r\nfor (ii = 0, jj = 0, kk = 0; ii < len; )\r\n{\r\nif ((ii % BYTES_PER_LINE) == 0)\r\n{\r\ng_snprintf(line, LINE_LEN + 1, "%0*X", OFFSET_LEN, offset);\r\nmemset(line + HEX_START - OFFSET_SPACE, ' ',\r\nHEX_LEN + OFFSET_SPACE + HEX_SPACE);\r\njj = HEX_START;\r\nkk = ASCII_START;\r\n}\r\nval = ((guint8 *)datap)[ii];\r\nline[jj++] = bin2hex[val >> 4];\r\nline[jj++] = bin2hex[val & 0xf];\r\njj++;\r\nline[kk++] = val >= ' ' && val < 0x7f ? val : '.';\r\nif (++ii % BYTES_PER_LINE == BYTES_PER_LINE/2)\r\n{\r\nline[jj++] = ' ';\r\nline[kk++] = ' ';\r\n}\r\nif ((ii % BYTES_PER_LINE) == 0 || ii == len)\r\n{\r\nif (line[kk - 1] == ' ')\r\n{\r\nkk--;\r\n}\r\nline[kk] = 0;\r\nprintf("%s%s\n", prefixp, line);\r\noffset += BYTES_PER_LINE;\r\n}\r\n}\r\n}\r\nstatic void\r\nfollowDraw(\r\nvoid * contextp\r\n)\r\n{\r\nstatic const char separator[] =\r\n"===================================================================\n";\r\nfollow_t * fp = (follow_t *)contextp;\r\ntcp_stream_chunk sc;\r\nint node;\r\nconst address * addr[2];\r\nint port[2];\r\ngchar buf[MAX_IP6_STR_LEN];\r\nguint32 ii;\r\nguint32 jj;\r\nguint32 len;\r\nguint32 chunk;\r\nguint32 offset[2];\r\nguint8 bin[4096];\r\nchar data[(sizeof bin * 2) + 2];\r\ng_assert(sizeof bin % BYTES_PER_LINE == 0);\r\nif (fp->type == type_TCP)\r\n{\r\nstatic const guint8 ip_zero[MAX_IPADDR_LEN] = {0};\r\nfollow_stats_t stats;\r\naddress_type type;\r\nfollow_stats(&stats);\r\nif (stats.port[0] == 0 && stats.port[1] == 0 &&\r\nmemcmp(stats.ip_address[0], ip_zero, sizeof ip_zero) == 0 &&\r\nmemcmp(stats.ip_address[1], ip_zero, sizeof ip_zero) == 0)\r\n{\r\ntype = AT_NONE;\r\nlen = 0;\r\n}\r\nelse if (stats.is_ipv6)\r\n{\r\ntype = AT_IPv6;\r\nlen = 16;\r\n}\r\nelse\r\n{\r\ntype = AT_IPv4;\r\nlen = 4;\r\n}\r\nfor (node = 0; node < 2; node++)\r\n{\r\nmemcpy(fp->addrBuf[node], stats.ip_address[node], len);\r\nSET_ADDRESS(&fp->addr[node], type, len, fp->addrBuf[node]);\r\nfp->port[node] = stats.port[node];\r\n}\r\n}\r\nrewind(fp->filep);\r\nfor (chunk = 0;;)\r\n{\r\nlen = (guint32)fread(&sc, 1, sizeof sc, fp->filep);\r\nif (len != sizeof sc)\r\n{\r\nsc.dlen = 0;\r\nmemcpy(sc.src_addr, fp->addr[0].data, fp->addr[0].len) ;\r\nsc.src_port = fp->port[0];\r\nbreak;\r\n}\r\nif (sc.dlen > 0)\r\n{\r\nchunk++;\r\nbreak;\r\n}\r\n}\r\nif (memcmp(sc.src_addr, fp->addr[0].data, fp->addr[0].len) == 0 &&\r\nsc.src_port == fp->port[0])\r\n{\r\naddr[0] = &fp->addr[0];\r\nport[0] = fp->port[0];\r\naddr[1] = &fp->addr[1];\r\nport[1] = fp->port[1];\r\n}\r\nelse\r\n{\r\naddr[0] = &fp->addr[1];\r\nport[0] = fp->port[1];\r\naddr[1] = &fp->addr[0];\r\nport[1] = fp->port[0];\r\n}\r\nprintf("\n%s", separator);\r\nprintf("Follow: %s,%s\n", followStrType(fp), followStrMode(fp));\r\nprintf("Filter: %s\n", followStrFilter(fp));\r\nfor (node = 0; node < 2; node++)\r\n{\r\naddress_to_str_buf(addr[node], buf, sizeof buf);\r\nif (addr[node]->type == AT_IPv6)\r\n{\r\nprintf("Node %u: [%s]:%d\n", node, buf, port[node]);\r\n}\r\nelse\r\n{\r\nprintf("Node %u: %s:%d\n", node, buf, port[node]);\r\n}\r\n}\r\noffset[0] = offset[1] = 0;\r\nwhile (chunk <= fp->chunkMax)\r\n{\r\nnode = (memcmp(addr[0]->data, sc.src_addr, addr[0]->len) == 0 &&\r\nport[0] == sc.src_port) ? 0 : 1;\r\nif (chunk < fp->chunkMin)\r\n{\r\nwhile (sc.dlen > 0)\r\n{\r\nlen = sc.dlen < sizeof bin ? sc.dlen : (guint32)sizeof bin;\r\nsc.dlen -= len;\r\nif (fread(bin, 1, len, fp->filep) != len)\r\n{\r\nfollowExit("Error reading stream chunk data.");\r\n}\r\noffset[node] += len;\r\n}\r\n}\r\nelse\r\n{\r\nswitch (fp->mode)\r\n{\r\ncase mode_HEX:\r\nbreak;\r\ncase mode_ASCII:\r\nprintf("%s%d\n", node ? "\t" : "", sc.dlen);\r\nbreak;\r\ncase mode_RAW:\r\nif (node)\r\n{\r\nputchar('\t');\r\n}\r\nbreak;\r\n}\r\nwhile (sc.dlen > 0)\r\n{\r\nlen = sc.dlen < sizeof bin ? sc.dlen : (guint32)sizeof bin;\r\nsc.dlen -= len;\r\nif (fread(bin, 1, len, fp->filep) != len)\r\n{\r\nfollowExit("Error reading stream chunk data.");\r\n}\r\nswitch (fp->mode)\r\n{\r\ncase mode_HEX:\r\nfollowPrintHex(node ? "\t" : "", offset[node], bin, len);\r\nbreak;\r\ncase mode_ASCII:\r\nfor (ii = 0; ii < len; ii++)\r\n{\r\nswitch (bin[ii])\r\n{\r\ncase '\r':\r\ncase '\n':\r\ndata[ii] = bin[ii];\r\nbreak;\r\ndefault:\r\ndata[ii] = g_ascii_isprint(bin[ii]) ? bin[ii] : '.';\r\nbreak;\r\n}\r\n}\r\nif (sc.dlen == 0)\r\n{\r\ndata[ii++] = '\n';\r\n}\r\ndata[ii] = 0;\r\nprintf("%s", data);\r\nbreak;\r\ncase mode_RAW:\r\nfor (ii = 0, jj = 0; ii < len; ii++)\r\n{\r\ndata[jj++] = bin2hex[bin[ii] >> 4];\r\ndata[jj++] = bin2hex[bin[ii] & 0xf];\r\n}\r\nif (sc.dlen == 0)\r\n{\r\ndata[jj++] = '\n';\r\n}\r\ndata[jj] = 0;\r\nprintf("%s", data);\r\n}\r\noffset[node] += len;\r\n}\r\n}\r\nfor (;;)\r\n{\r\nlen = (guint32)fread(&sc, 1, sizeof sc, fp->filep);\r\nif (len != sizeof sc)\r\n{\r\nsc.dlen = 0;\r\ngoto done;\r\n}\r\nif (sc.dlen > 0)\r\n{\r\nchunk++;\r\nbreak;\r\n}\r\n}\r\n}\r\ndone:\r\nprintf("%s", separator);\r\nfollowFileClose(fp);\r\n}\r\nstatic gboolean\r\nfollowArgStrncmp(\r\nconst char ** opt_argp,\r\nconst char * strp\r\n)\r\n{\r\nint len = (guint32)strlen(strp);\r\nif (strncmp(*opt_argp, strp, len) == 0)\r\n{\r\n*opt_argp += len;\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void\r\nfollowArgMode(\r\nconst char ** opt_argp,\r\nfollow_t * fp\r\n)\r\n{\r\nif (followArgStrncmp(opt_argp, STR_HEX))\r\n{\r\nfp->mode = mode_HEX;\r\n}\r\nelse if (followArgStrncmp(opt_argp, STR_ASCII))\r\n{\r\nfp->mode = mode_ASCII;\r\n}\r\nelse if (followArgStrncmp(opt_argp, STR_RAW))\r\n{\r\nfp->mode = mode_RAW;\r\n}\r\nelse\r\n{\r\nfollowExit("Invalid display mode.");\r\n}\r\n}\r\nstatic void\r\nfollowArgFilter(\r\nconst char ** opt_argp,\r\nfollow_t * fp\r\n)\r\n{\r\n#define _STRING(s) # s\r\n#define STRING(s) _STRING(s)\r\n#define ADDR_CHARS 80\r\n#define ADDR_LEN (ADDR_CHARS + 1)\r\n#define ADDRv6_FMT ",[%" STRING(ADDR_CHARS) "[^]]]:%d%n"\r\n#define ADDRv4_FMT ",%" STRING(ADDR_CHARS) "[^:]:%d%n"\r\nint len;\r\nunsigned int ii;\r\nchar addr[ADDR_LEN];\r\nif (sscanf(*opt_argp, ",%u%n", &fp->index, &len) == 1 &&\r\n((*opt_argp)[len] == 0 || (*opt_argp)[len] == ','))\r\n{\r\n*opt_argp += len;\r\n}\r\nelse\r\n{\r\nfor (ii = 0; ii < sizeof fp->addr/sizeof *fp->addr; ii++)\r\n{\r\nif ((sscanf(*opt_argp, ADDRv6_FMT, addr, &fp->port[ii], &len) != 2 &&\r\nsscanf(*opt_argp, ADDRv4_FMT, addr, &fp->port[ii], &len) != 2) ||\r\nfp->port[ii] <= 0 || fp->port[ii] > G_MAXUINT16)\r\n{\r\nfollowExit("Invalid address:port pair.");\r\n}\r\nif (strcmp("ip6", host_ip_af(addr)) == 0)\r\n{\r\nif (!get_host_ipaddr6(addr, (struct e_in6_addr *)fp->addrBuf[ii]))\r\n{\r\nfollowExit("Can't get IPv6 address");\r\n}\r\nSET_ADDRESS(&fp->addr[ii], AT_IPv6, 16, fp->addrBuf[ii]);\r\n}\r\nelse\r\n{\r\nif (!get_host_ipaddr(addr, (guint32 *)fp->addrBuf[ii]))\r\n{\r\nfollowExit("Can't get IPv4 address");\r\n}\r\nSET_ADDRESS(&fp->addr[ii], AT_IPv4, 4, fp->addrBuf[ii]);\r\n}\r\n*opt_argp += len;\r\n}\r\nif (fp->addr[0].type != fp->addr[1].type)\r\n{\r\nfollowExit("Mismatched IP address types.");\r\n}\r\nfp->index = G_MAXUINT32;\r\n}\r\n}\r\nstatic void\r\nfollowArgRange(\r\nconst char ** opt_argp,\r\nfollow_t * fp\r\n)\r\n{\r\nint len;\r\nif (**opt_argp == 0)\r\n{\r\nfp->chunkMin = 1;\r\nfp->chunkMax = G_MAXUINT32;\r\n}\r\nelse\r\n{\r\nif (sscanf(*opt_argp, ",%u-%u%n", &fp->chunkMin, &fp->chunkMax, &len) == 2)\r\n{\r\n*opt_argp += len;\r\n}\r\nelse if (sscanf(*opt_argp, ",%u%n", &fp->chunkMin, &len) == 1)\r\n{\r\nfp->chunkMax = fp->chunkMin;\r\n*opt_argp += len;\r\n}\r\nelse\r\n{\r\nfollowExit("Invalid range.");\r\n}\r\nif (fp->chunkMin < 1 || fp->chunkMin > fp->chunkMax)\r\n{\r\nfollowExit("Invalid range value.");\r\n}\r\n}\r\n}\r\nstatic void\r\nfollowArgDone(\r\nconst char * opt_argp\r\n)\r\n{\r\nif (*opt_argp != 0)\r\n{\r\nfollowExit("Invalid parameter.");\r\n}\r\n}\r\nstatic void\r\nfollowTcp(\r\nconst char * opt_argp,\r\nvoid * userdata _U_\r\n)\r\n{\r\nfollow_t * fp;\r\nGString * errp;\r\nopt_argp += strlen(STR_FOLLOW_TCP);\r\nfp = followAlloc(type_TCP);\r\nfollowArgMode(&opt_argp, fp);\r\nfollowArgFilter(&opt_argp, fp);\r\nfollowArgRange(&opt_argp, fp);\r\nfollowArgDone(opt_argp);\r\nreset_tcp_reassembly();\r\nif (fp->index != G_MAXUINT32)\r\n{\r\nif (!follow_tcp_index(fp->index))\r\n{\r\nfollowExit("Can't follow tcp index.");\r\n}\r\n}\r\nelse\r\n{\r\nif (!follow_tcp_addr(&fp->addr[0], fp->port[0],\r\n&fp->addr[1], fp->port[1]))\r\n{\r\nfollowExit("Can't follow tcp address/port pairs.");\r\n}\r\n}\r\nfollowFileOpen(fp);\r\nerrp = register_tap_listener("frame", fp, NULL, 0,\r\nNULL, NULL, followDraw);\r\nif (errp != NULL)\r\n{\r\nfollowFree(fp);\r\ng_string_free(errp, TRUE);\r\nfollowExit("Error registering tcp tap listener.");\r\n}\r\n}\r\nstatic void\r\nfollowUdp(\r\nconst char * opt_argp,\r\nvoid * userdata _U_\r\n)\r\n{\r\nfollow_t * fp;\r\nGString * errp;\r\nopt_argp += strlen(STR_FOLLOW_UDP);\r\nfp = followAlloc(type_UDP);\r\nfollowArgMode(&opt_argp, fp);\r\nfollowArgFilter(&opt_argp, fp);\r\nfollowArgRange(&opt_argp, fp);\r\nfollowArgDone(opt_argp);\r\nif (fp->index != G_MAXUINT32)\r\n{\r\nfollowExit("UDP does not support index filters.");\r\n}\r\nfollowFileOpen(fp);\r\nerrp = register_tap_listener("udp_follow", fp, followStrFilter(fp), 0,\r\nNULL, followUdpPacket, followDraw);\r\nif (errp != NULL)\r\n{\r\nfollowFree(fp);\r\ng_string_free(errp, TRUE);\r\nfollowExit("Error registering udp tap listner.");\r\n}\r\n}\r\nstatic void\r\nfollowSsl(\r\nconst char * opt_argp,\r\nvoid * userdata _U_\r\n)\r\n{\r\nfollow_t * fp;\r\nGString * errp;\r\nopt_argp += strlen(STR_FOLLOW_SSL);\r\nfp = followAlloc(type_SSL);\r\nfollowArgMode(&opt_argp, fp);\r\nfollowArgFilter(&opt_argp, fp);\r\nfollowArgRange(&opt_argp, fp);\r\nfollowArgDone(opt_argp);\r\nif (fp->index == G_MAXUINT32)\r\n{\r\nfollowExit("SSL only supports index filters.");\r\n}\r\nfollowFileOpen(fp);\r\nerrp = register_tap_listener("ssl", fp, followStrFilter(fp), 0,\r\nNULL, followSslPacket, followDraw);\r\nif (errp != NULL)\r\n{\r\nfollowFree(fp);\r\ng_string_free(errp, TRUE);\r\nfollowExit("Error registering ssl tap listener.");\r\n}\r\n}\r\nvoid\r\nregister_tap_listener_follow(void)\r\n{\r\nregister_stat_cmd_arg(STR_FOLLOW_TCP, followTcp, NULL);\r\nregister_stat_cmd_arg(STR_FOLLOW_UDP, followUdp, NULL);\r\nregister_stat_cmd_arg(STR_FOLLOW_SSL, followSsl, NULL);\r\n}
