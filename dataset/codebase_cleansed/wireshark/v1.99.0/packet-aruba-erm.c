static int\r\ndissect_aruba_erm_pcap(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *aruba_erm_tree, gint offset)\r\n{\r\nnstime_t ts;\r\nts.secs = tvb_get_ntohl(tvb, 0);\r\nts.nsecs = tvb_get_ntohl(tvb,4)*1000;\r\nproto_tree_add_time(aruba_erm_tree, hf_aruba_erm_time, tvb, offset, 8,&ts);\r\noffset +=8;\r\nproto_tree_add_item(aruba_erm_tree, hf_aruba_erm_incl_len, tvb, 8, 4, ENC_BIG_ENDIAN);\r\noffset +=4;\r\nproto_tree_add_item(aruba_erm_tree, hf_aruba_erm_orig_len, tvb, 12, 4, ENC_BIG_ENDIAN);\r\noffset +=4;\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_aruba_erm_pcap_radio(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *aruba_erm_tree, gint offset)\r\n{\r\nproto_item *ti_data_rate;\r\nguint16 data_rate;\r\ndata_rate = tvb_get_ntohs(tvb, offset);\r\nproto_tree_add_item(aruba_erm_tree, hf_aruba_erm_data_rate, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nti_data_rate = proto_tree_add_float_format(aruba_erm_tree, hf_aruba_erm_data_rate_gen,\r\ntvb, 16, 2,\r\n(float)data_rate / 2,\r\n"Data Rate: %.1f Mb/s",\r\n(float)data_rate / 2);\r\nPROTO_ITEM_SET_GENERATED(ti_data_rate);\r\noffset += 2;\r\nproto_tree_add_item(aruba_erm_tree, hf_aruba_erm_channel, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nproto_tree_add_item(aruba_erm_tree, hf_aruba_erm_signal_strength, tvb, offset, 1, ENC_NA);\r\noffset += 1;\r\nreturn offset;\r\n}\r\nstatic void\r\ndissect_aruba_erm(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nproto_item *ti;\r\nproto_tree *aruba_erm_tree;\r\ntvbuff_t *eth_tvb;\r\nint offset = 0 ;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, PROTO_SHORT_NAME);\r\ncol_set_str(pinfo->cinfo, COL_INFO, PROTO_SHORT_NAME);\r\nti = proto_tree_add_item(tree, proto_aruba_erm, tvb, 0, 0, ENC_NA);\r\nproto_item_append_text(ti, ": %s", val_to_str(aruba_erm_type, aruba_erm_type_vals, "Unknown"));\r\naruba_erm_tree = proto_item_add_subtree(ti, ett_aruba_erm);\r\nswitch(aruba_erm_type){\r\ncase TYPE_PCAP:\r\noffset = dissect_aruba_erm_pcap(tvb, pinfo, aruba_erm_tree, offset);\r\nproto_item_set_len(ti, offset);\r\neth_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(ieee80211_handle, eth_tvb, pinfo, tree);\r\nbreak;\r\ncase TYPE_PEEK:\r\ncall_dissector(peek_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase TYPE_AIRMAGNET:\r\nproto_tree_add_expert(tree, pinfo, &ei_aruba_erm_airmagnet, tvb, offset, -1);\r\ncall_dissector(data_handle, tvb, pinfo, tree);\r\nbreak;\r\ncase TYPE_PCAPPLUSRADIO:\r\noffset = dissect_aruba_erm_pcap(tvb, pinfo, aruba_erm_tree, offset);\r\noffset = dissect_aruba_erm_pcap_radio(tvb, pinfo, aruba_erm_tree, offset);\r\nproto_item_set_len(ti, offset);\r\neth_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(ieee80211_handle, eth_tvb, pinfo, tree);\r\nbreak;\r\ncase TYPE_PPI:\r\ncall_dissector(ppi_handle, tvb, pinfo, tree);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid\r\nproto_register_aruba_erm(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_aruba_erm_time,\r\n{ "Packet Capture Timestamp", "aruba_erm.time", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL,\r\n0x00, NULL, HFILL }},\r\n{ &hf_aruba_erm_incl_len,\r\n{ "Packet Captured Length", "aruba_erm.incl_len", FT_UINT32, BASE_DEC, NULL,\r\n0x00, NULL, HFILL }},\r\n{ &hf_aruba_erm_orig_len,\r\n{ "Packet Length", "aruba_erm.orig_len", FT_UINT32, BASE_DEC, NULL,\r\n0x00, NULL, HFILL }},\r\n{ &hf_aruba_erm_data_rate,\r\n{ "Data Rate", "aruba_erm.data_rate", FT_UINT16, BASE_DEC, NULL,\r\n0x00, "Data rate (1/2 Mb/s)", HFILL }},\r\n{ &hf_aruba_erm_data_rate_gen,\r\n{ "Data Rate", "aruba_erm.data_rate_gen", FT_FLOAT, BASE_NONE, NULL,\r\n0x00, "Data rate (1/2 Mb/s)", HFILL }},\r\n{ &hf_aruba_erm_channel,\r\n{ "Channel", "aruba_erm.channel", FT_UINT8, BASE_DEC, NULL,\r\n0x00, "802.11 channel number that this frame was sent/received on", HFILL }},\r\n{ &hf_aruba_erm_signal_strength,\r\n{ "Signal Strength [percent]", "aruba_erm.signal_strength", FT_UINT8, BASE_DEC, NULL,\r\n0x00, "Signal strength (Percentage)", HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_aruba_erm,\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_aruba_erm_airmagnet, { "aruba_erm.airmagnet", PI_UNDECODED, PI_ERROR, "Airmagnet (type 2) is no yet supported (Please use other type)", EXPFILL }}\r\n};\r\nstatic const enum_val_t aruba_erm_types[] = {\r\n{ "pcap_type_0", "pcap (type 0)", TYPE_PCAP},\r\n{ "peek_type_1", "peek (type1)", TYPE_PEEK},\r\n{ "airmagnet_type_2", "airmagnet (type 2)", TYPE_AIRMAGNET},\r\n{ "pcapplusradio_type_3", "pcap+radio header (type 3)", TYPE_PCAPPLUSRADIO},\r\n{ "ppi_type_4", "ppi (type 4)", TYPE_PPI},\r\n{ NULL, NULL, -1}\r\n};\r\nmodule_t *aruba_erm_module;\r\nexpert_module_t* expert_aruba_erm;\r\nproto_aruba_erm = proto_register_protocol(PROTO_LONG_NAME, PROTO_SHORT_NAME, "aruba_erm");\r\nrange_convert_str (&global_aruba_erm_port_range, "0", MAX_UDP_PORT);\r\naruba_erm_module = prefs_register_protocol(proto_aruba_erm, proto_reg_handoff_aruba_erm);\r\nprefs_register_range_preference(aruba_erm_module, "udp.ports", "ARUBA_ERM UDP Port numbers",\r\n"Set the UDP port numbers (typically the range 5555 to 5560) used for ARUBA"\r\n" encapsulated remote mirroring frames;\n"\r\n"0 (default) means that the ARUBA_ERM dissector is not active\n",\r\n&global_aruba_erm_port_range, MAX_UDP_PORT);\r\nprefs_register_enum_preference(aruba_erm_module, "type.captured",\r\n"Type of formats for captured packets",\r\n"Type of formats for captured packets",\r\n&aruba_erm_type, aruba_erm_types, FALSE);\r\nproto_register_field_array(proto_aruba_erm, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_aruba_erm = expert_register_protocol(proto_aruba_erm);\r\nexpert_register_field_array(expert_aruba_erm, ei, array_length(ei));\r\n}\r\nvoid\r\nproto_reg_handoff_aruba_erm(void)\r\n{\r\nstatic range_t *aruba_erm_port_range;\r\nstatic range_t *aruba_erm_radio_port_range;\r\nstatic gboolean initialized = FALSE;\r\nif (!initialized) {\r\nieee80211_handle = find_dissector("wlan_withoutfcs");\r\nppi_handle = find_dissector("ppi");\r\npeek_handle = find_dissector("peekremote");\r\ndata_handle = find_dissector("data");\r\naruba_erm_handle = create_dissector_handle(dissect_aruba_erm, proto_aruba_erm);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint_range("udp.port", aruba_erm_port_range, aruba_erm_handle);\r\ng_free(aruba_erm_port_range);\r\ng_free(aruba_erm_radio_port_range);\r\n}\r\naruba_erm_port_range = range_copy(global_aruba_erm_port_range);\r\ndissector_add_uint_range("udp.port", aruba_erm_port_range, aruba_erm_handle);\r\n}
