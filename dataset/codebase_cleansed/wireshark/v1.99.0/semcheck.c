static gboolean\r\ncompatible_ftypes(ftenum_t a, ftenum_t b)\r\n{\r\nswitch (a) {\r\ncase FT_NONE:\r\ncase FT_PROTOCOL:\r\ncase FT_FLOAT:\r\ncase FT_DOUBLE:\r\ncase FT_ABSOLUTE_TIME:\r\ncase FT_RELATIVE_TIME:\r\ncase FT_IPv4:\r\ncase FT_IPv6:\r\ncase FT_IPXNET:\r\ncase FT_INT64:\r\ncase FT_UINT64:\r\ncase FT_EUI64:\r\nreturn a == b;\r\ncase FT_ETHER:\r\ncase FT_BYTES:\r\ncase FT_UINT_BYTES:\r\ncase FT_GUID:\r\ncase FT_OID:\r\ncase FT_AX25:\r\ncase FT_VINES:\r\ncase FT_REL_OID:\r\ncase FT_SYSTEM_ID:\r\nreturn (b == FT_ETHER || b == FT_BYTES || b == FT_UINT_BYTES || b == FT_GUID || b == FT_OID || b == FT_AX25 || b == FT_VINES || b == FT_REL_OID || b == FT_SYSTEM_ID);\r\ncase FT_BOOLEAN:\r\ncase FT_FRAMENUM:\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\nswitch (b) {\r\ncase FT_BOOLEAN:\r\ncase FT_FRAMENUM:\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\nreturn TRUE;\r\ndefault:\r\nreturn FALSE;\r\n}\r\ncase FT_STRING:\r\ncase FT_STRINGZ:\r\ncase FT_UINT_STRING:\r\ncase FT_STRINGZPAD:\r\nswitch (b) {\r\ncase FT_STRING:\r\ncase FT_STRINGZ:\r\ncase FT_UINT_STRING:\r\ncase FT_STRINGZPAD:\r\nreturn TRUE;\r\ndefault:\r\nreturn FALSE;\r\n}\r\ncase FT_PCRE:\r\ncase FT_NUM_TYPES:\r\ng_assert_not_reached();\r\n}\r\ng_assert_not_reached();\r\nreturn FALSE;\r\n}\r\nstatic fvalue_t*\r\nmk_uint32_fvalue(guint32 val)\r\n{\r\nfvalue_t *fv;\r\nfv = fvalue_new(FT_UINT32);\r\nfvalue_set_uinteger(fv, val);\r\nreturn fv;\r\n}\r\nstatic fvalue_t*\r\nmk_uint64_fvalue(guint64 val)\r\n{\r\nfvalue_t *fv;\r\nfv = fvalue_new(FT_UINT64);\r\nfvalue_set_integer64(fv, val);\r\nreturn fv;\r\n}\r\nstatic fvalue_t*\r\nmk_fvalue_from_val_string(header_field_info *hfinfo, char *s)\r\n{\r\nstatic const true_false_string default_tf = { "True", "False" };\r\nconst true_false_string *tf = &default_tf;\r\nswitch(hfinfo->type) {\r\ncase FT_NONE:\r\ncase FT_PROTOCOL:\r\ncase FT_FLOAT:\r\ncase FT_DOUBLE:\r\ncase FT_ABSOLUTE_TIME:\r\ncase FT_RELATIVE_TIME:\r\ncase FT_IPv4:\r\ncase FT_IPv6:\r\ncase FT_IPXNET:\r\ncase FT_AX25:\r\ncase FT_VINES:\r\ncase FT_ETHER:\r\ncase FT_BYTES:\r\ncase FT_UINT_BYTES:\r\ncase FT_STRING:\r\ncase FT_STRINGZ:\r\ncase FT_UINT_STRING:\r\ncase FT_STRINGZPAD:\r\ncase FT_EUI64:\r\ncase FT_PCRE:\r\ncase FT_GUID:\r\ncase FT_OID:\r\ncase FT_REL_OID:\r\ncase FT_SYSTEM_ID:\r\nreturn NULL;\r\ncase FT_BOOLEAN:\r\ncase FT_FRAMENUM:\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\ncase FT_UINT64:\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\ncase FT_INT64:\r\nbreak;\r\ncase FT_NUM_TYPES:\r\ng_assert_not_reached();\r\n}\r\nif (hfinfo->type == FT_BOOLEAN) {\r\nif (hfinfo->strings) {\r\ntf = (const true_false_string *)hfinfo->strings;\r\n}\r\nif (g_ascii_strcasecmp(s, tf->true_string) == 0) {\r\nreturn mk_uint32_fvalue(TRUE);\r\n}\r\nelse if (g_ascii_strcasecmp(s, tf->false_string) == 0) {\r\nreturn mk_uint32_fvalue(FALSE);\r\n}\r\nelse {\r\ndfilter_error_msg = NULL;\r\ndfilter_fail("\"%s\" cannot be found among the possible values for %s.",\r\ns, hfinfo->abbrev);\r\nreturn NULL;\r\n}\r\n}\r\nif (!hfinfo->strings) {\r\ndfilter_fail("%s cannot accept strings as values.",\r\nhfinfo->abbrev);\r\nreturn NULL;\r\n}\r\ndfilter_error_msg = NULL;\r\nif (hfinfo->display & BASE_RANGE_STRING) {\r\ndfilter_fail("\"%s\" cannot accept [range] strings as values.",\r\nhfinfo->abbrev);\r\n}\r\nelse if (hfinfo->display & BASE_VAL64_STRING) {\r\nconst val64_string *vals = (const val64_string *)hfinfo->strings;\r\nwhile (vals->strptr != NULL) {\r\nif (g_ascii_strcasecmp(s, vals->strptr) == 0) {\r\nreturn mk_uint64_fvalue(vals->value);\r\n}\r\nvals++;\r\n}\r\ndfilter_fail("\"%s\" cannot be found among the possible values for %s.",\r\ns, hfinfo->abbrev);\r\n}\r\nelse if (hfinfo->display == BASE_CUSTOM) {\r\ndfilter_fail("\"%s\" cannot accept [custom] strings as values.",\r\nhfinfo->abbrev);\r\n}\r\nelse {\r\nconst value_string *vals = (const value_string *)hfinfo->strings;\r\nif (hfinfo->display & BASE_EXT_STRING)\r\nvals = VALUE_STRING_EXT_VS_P((const value_string_ext *) vals);\r\nwhile (vals->strptr != NULL) {\r\nif (g_ascii_strcasecmp(s, vals->strptr) == 0) {\r\nreturn mk_uint32_fvalue(vals->value);\r\n}\r\nvals++;\r\n}\r\ndfilter_fail("\"%s\" cannot be found among the possible values for %s.",\r\ns, hfinfo->abbrev);\r\n}\r\nreturn NULL;\r\n}\r\nstatic gboolean\r\nis_bytes_type(enum ftenum type)\r\n{\r\nswitch(type) {\r\ncase FT_AX25:\r\ncase FT_VINES:\r\ncase FT_ETHER:\r\ncase FT_BYTES:\r\ncase FT_UINT_BYTES:\r\ncase FT_IPv6:\r\ncase FT_GUID:\r\ncase FT_OID:\r\ncase FT_REL_OID:\r\ncase FT_SYSTEM_ID:\r\nreturn TRUE;\r\ncase FT_NONE:\r\ncase FT_PROTOCOL:\r\ncase FT_FLOAT:\r\ncase FT_DOUBLE:\r\ncase FT_ABSOLUTE_TIME:\r\ncase FT_RELATIVE_TIME:\r\ncase FT_IPv4:\r\ncase FT_IPXNET:\r\ncase FT_STRING:\r\ncase FT_STRINGZ:\r\ncase FT_UINT_STRING:\r\ncase FT_STRINGZPAD:\r\ncase FT_BOOLEAN:\r\ncase FT_FRAMENUM:\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\ncase FT_UINT64:\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\ncase FT_INT64:\r\ncase FT_PCRE:\r\ncase FT_EUI64:\r\nreturn FALSE;\r\ncase FT_NUM_TYPES:\r\ng_assert_not_reached();\r\n}\r\ng_assert_not_reached();\r\nreturn FALSE;\r\n}\r\nstatic void\r\ncheck_exists(stnode_t *st_arg1)\r\n{\r\n#ifdef DEBUG_dfilter\r\nstatic guint i = 0;\r\n#endif\r\nDebugLog((" 4 check_exists() [%u]\n", i++));\r\nswitch (stnode_type_id(st_arg1)) {\r\ncase STTYPE_FIELD:\r\nbreak;\r\ncase STTYPE_STRING:\r\ncase STTYPE_UNPARSED:\r\ndfilter_fail("\"%s\" is neither a field nor a protocol name.",\r\n(char *)stnode_data(st_arg1));\r\nTHROW(TypeError);\r\nbreak;\r\ncase STTYPE_RANGE:\r\ndfilter_fail("You cannot test whether a range is present.");\r\nTHROW(TypeError);\r\nbreak;\r\ncase STTYPE_FUNCTION:\r\ndfilter_fail("You cannot test whether a function is present.");\r\nTHROW(TypeError);\r\nbreak;\r\ncase STTYPE_UNINITIALIZED:\r\ncase STTYPE_TEST:\r\ncase STTYPE_INTEGER:\r\ncase STTYPE_FVALUE:\r\ncase STTYPE_NUM_TYPES:\r\ng_assert_not_reached();\r\n}\r\n}\r\nstatic void\r\ncheck_drange_node_sanity(gpointer data, gpointer user_data)\r\n{\r\ndrange_node* drnode = (drange_node*)data;\r\nstruct check_drange_sanity_args *args = (struct check_drange_sanity_args*)user_data;\r\ngint start_offset, end_offset, length;\r\nstnode_t *entity;\r\nheader_field_info *hfinfo;\r\nswitch (drange_node_get_ending(drnode)) {\r\ncase DRANGE_NODE_END_T_LENGTH:\r\nlength = drange_node_get_length(drnode);\r\nif (length <= 0) {\r\nif (!args->err) {\r\nargs->err = TRUE;\r\nstart_offset = drange_node_get_start_offset(drnode);\r\nentity = sttype_range_entity(args->st);\r\nif (entity && stnode_type_id(entity) == STTYPE_FIELD) {\r\nhfinfo = (header_field_info *)stnode_data(entity);\r\ndfilter_fail("Range %d:%d specified for \"%s\" isn't valid, "\r\n"as length %d isn't positive",\r\nstart_offset, length,\r\nhfinfo->abbrev,\r\nlength);\r\n} else\r\ndfilter_fail("Range %d:%d isn't valid, "\r\n"as length %d isn't positive",\r\nstart_offset, length,\r\nlength);\r\n}\r\n}\r\nbreak;\r\ncase DRANGE_NODE_END_T_OFFSET:\r\nstart_offset = drange_node_get_start_offset(drnode);\r\nend_offset = drange_node_get_end_offset(drnode);\r\nif (start_offset > end_offset) {\r\nif (!args->err) {\r\nargs->err = TRUE;\r\nentity = sttype_range_entity(args->st);\r\nif (entity && stnode_type_id(entity) == STTYPE_FIELD) {\r\nhfinfo = (header_field_info *)stnode_data(entity);\r\ndfilter_fail("Range %d-%d specified for \"%s\" isn't valid, "\r\n"as %d is greater than %d",\r\nstart_offset, end_offset,\r\nhfinfo->abbrev,\r\nstart_offset, end_offset);\r\n} else\r\ndfilter_fail("Range %d-%d isn't valid, "\r\n"as %d is greater than %d",\r\nstart_offset, end_offset,\r\nstart_offset, end_offset);\r\n}\r\n}\r\nbreak;\r\ncase DRANGE_NODE_END_T_TO_THE_END:\r\nbreak;\r\ncase DRANGE_NODE_END_T_UNINITIALIZED:\r\ndefault:\r\ng_assert_not_reached();\r\n}\r\n}\r\nstatic void\r\ncheck_drange_sanity(stnode_t *st)\r\n{\r\nstruct check_drange_sanity_args args;\r\nargs.st = st;\r\nargs.err = FALSE;\r\ndrange_foreach_drange_node(sttype_range_drange(st),\r\ncheck_drange_node_sanity, &args);\r\nif (args.err) {\r\nTHROW(TypeError);\r\n}\r\n}\r\nstatic stnode_t *\r\nconvert_to_bytes(stnode_t *arg)\r\n{\r\nstnode_t *new_st;\r\ndrange_node *rn;\r\nnew_st = stnode_new(STTYPE_RANGE, NULL);\r\nrn = drange_node_new();\r\ndrange_node_set_start_offset(rn, 0);\r\ndrange_node_set_to_the_end(rn);\r\nsttype_range_set1(new_st, arg, rn);\r\nreturn new_st;\r\n}\r\nstatic void\r\ncheck_function(stnode_t *st_node)\r\n{\r\ndf_func_def_t *funcdef;\r\nGSList *params;\r\nguint iparam;\r\nguint nparams;\r\nfuncdef = sttype_function_funcdef(st_node);\r\nparams = sttype_function_params(st_node);\r\nnparams = g_slist_length(params);\r\nif (nparams < funcdef->min_nargs) {\r\ndfilter_fail("Function %s needs at least %u arguments.",\r\nfuncdef->name, funcdef->min_nargs);\r\nTHROW(TypeError);\r\n} else if (nparams > funcdef->max_nargs) {\r\ndfilter_fail("Function %s can only accept %u arguments.",\r\nfuncdef->name, funcdef->max_nargs);\r\nTHROW(TypeError);\r\n}\r\niparam = 0;\r\nwhile (params) {\r\nparams->data = check_param_entity((stnode_t *)params->data);\r\nfuncdef->semcheck_param_function(iparam, (stnode_t *)params->data);\r\nparams = params->next;\r\niparam++;\r\n}\r\n}\r\nstatic void\r\ncheck_relation_LHS_FIELD(const char *relation_string, FtypeCanFunc can_func,\r\ngboolean allow_partial_value,\r\nstnode_t *st_node, stnode_t *st_arg1, stnode_t *st_arg2)\r\n{\r\nstnode_t *new_st;\r\nsttype_id_t type2;\r\nheader_field_info *hfinfo1, *hfinfo2;\r\ndf_func_def_t *funcdef;\r\nftenum_t ftype1, ftype2;\r\nfvalue_t *fvalue;\r\nchar *s;\r\ntype2 = stnode_type_id(st_arg2);\r\nhfinfo1 = (header_field_info*)stnode_data(st_arg1);\r\nftype1 = hfinfo1->type;\r\nDebugLog((" 5 check_relation_LHS_FIELD(%s)\n", relation_string));\r\nif (!can_func(ftype1)) {\r\ndfilter_fail("%s (type=%s) cannot participate in '%s' comparison.",\r\nhfinfo1->abbrev, ftype_pretty_name(ftype1),\r\nrelation_string);\r\nTHROW(TypeError);\r\n}\r\nif (type2 == STTYPE_FIELD) {\r\nhfinfo2 = (header_field_info*)stnode_data(st_arg2);\r\nftype2 = hfinfo2->type;\r\nif (!compatible_ftypes(ftype1, ftype2)) {\r\ndfilter_fail("%s and %s are not of compatible types.",\r\nhfinfo1->abbrev, hfinfo2->abbrev);\r\nTHROW(TypeError);\r\n}\r\nif (!can_func(ftype2)) {\r\ndfilter_fail("%s (type=%s) cannot participate in specified comparison.",\r\nhfinfo2->abbrev, ftype_pretty_name(ftype2));\r\nTHROW(TypeError);\r\n}\r\n}\r\nelse if (type2 == STTYPE_STRING) {\r\ns = (char *)stnode_data(st_arg2);\r\nif (strcmp(relation_string, "matches") == 0) {\r\nfvalue = fvalue_from_string(FT_PCRE, s, dfilter_fail);\r\n} else {\r\nfvalue = fvalue_from_string(ftype1, s, dfilter_fail);\r\nif (!fvalue) {\r\nfvalue = mk_fvalue_from_val_string(hfinfo1, s);\r\n}\r\n}\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, st_arg1, new_st);\r\nstnode_free(st_arg2);\r\n}\r\nelse if (type2 == STTYPE_UNPARSED) {\r\ns = (char *)stnode_data(st_arg2);\r\nif (strcmp(relation_string, "matches") == 0) {\r\nfvalue = fvalue_from_unparsed(FT_PCRE, s, FALSE, dfilter_fail);\r\n} else {\r\ndo {\r\nfvalue = fvalue_from_unparsed(ftype1, s, allow_partial_value, dfilter_fail);\r\nif (!fvalue) {\r\nfvalue = mk_fvalue_from_val_string(hfinfo1, s);\r\n}\r\nif (!fvalue) {\r\nif (hfinfo1->same_name_prev_id != -1) {\r\nhfinfo1 = proto_registrar_get_nth(hfinfo1->same_name_prev_id);\r\nftype1 = hfinfo1->type;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n} while (!fvalue);\r\n}\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, st_arg1, new_st);\r\nstnode_free(st_arg2);\r\n}\r\nelse if (type2 == STTYPE_RANGE) {\r\ncheck_drange_sanity(st_arg2);\r\nif (!is_bytes_type(ftype1)) {\r\nif (!ftype_can_slice(ftype1)) {\r\ndfilter_fail("\"%s\" is a %s and cannot be converted into a sequence of bytes.",\r\nhfinfo1->abbrev,\r\nftype_pretty_name(ftype1));\r\nTHROW(TypeError);\r\n}\r\nnew_st = convert_to_bytes(st_arg1);\r\nsttype_test_set2_args(st_node, new_st, st_arg2);\r\n}\r\n}\r\nelse if (type2 == STTYPE_FUNCTION) {\r\nfuncdef = sttype_function_funcdef(st_arg2);\r\nftype2 = funcdef->retval_ftype;\r\nif (!compatible_ftypes(ftype1, ftype2)) {\r\ndfilter_fail("%s (type=%s) and return value of %s() (type=%s) are not of compatible types.",\r\nhfinfo1->abbrev, ftype_pretty_name(ftype1),\r\nfuncdef->name, ftype_pretty_name(ftype2));\r\nTHROW(TypeError);\r\n}\r\nif (!can_func(ftype2)) {\r\ndfilter_fail("return value of %s() (type=%s) cannot participate in specified comparison.",\r\nfuncdef->name, ftype_pretty_name(ftype2));\r\nTHROW(TypeError);\r\n}\r\ncheck_function(st_arg2);\r\n}\r\nelse {\r\ng_assert_not_reached();\r\n}\r\n}\r\nstatic void\r\ncheck_relation_LHS_STRING(const char* relation_string,\r\nFtypeCanFunc can_func, gboolean allow_partial_value _U_,\r\nstnode_t *st_node,\r\nstnode_t *st_arg1, stnode_t *st_arg2)\r\n{\r\nstnode_t *new_st;\r\nsttype_id_t type2;\r\nheader_field_info *hfinfo2;\r\ndf_func_def_t *funcdef;\r\nftenum_t ftype2;\r\nfvalue_t *fvalue;\r\nchar *s;\r\ntype2 = stnode_type_id(st_arg2);\r\nDebugLog((" 5 check_relation_LHS_STRING()\n"));\r\nif (type2 == STTYPE_FIELD) {\r\nhfinfo2 = (header_field_info*)stnode_data(st_arg2);\r\nftype2 = hfinfo2->type;\r\nif (!can_func(ftype2)) {\r\ndfilter_fail("%s (type=%s) cannot participate in '%s' comparison.",\r\nhfinfo2->abbrev, ftype_pretty_name(ftype2),\r\nrelation_string);\r\nTHROW(TypeError);\r\n}\r\ns = (char*)stnode_data(st_arg1);\r\nfvalue = fvalue_from_string(ftype2, s, dfilter_fail);\r\nif (!fvalue) {\r\nfvalue = mk_fvalue_from_val_string(hfinfo2, s);\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, new_st, st_arg2);\r\nstnode_free(st_arg1);\r\n}\r\nelse if (type2 == STTYPE_STRING || type2 == STTYPE_UNPARSED) {\r\ndfilter_fail("Neither \"%s\" nor \"%s\" are field or protocol names.",\r\n(char *)stnode_data(st_arg1),\r\n(char *)stnode_data(st_arg2));\r\nTHROW(TypeError);\r\n}\r\nelse if (type2 == STTYPE_RANGE) {\r\ncheck_drange_sanity(st_arg2);\r\ns = (char*)stnode_data(st_arg1);\r\nfvalue = fvalue_from_string(FT_BYTES, s, dfilter_fail);\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, new_st, st_arg2);\r\nstnode_free(st_arg1);\r\n}\r\nelse if (type2 == STTYPE_FUNCTION) {\r\nfuncdef = sttype_function_funcdef(st_arg2);\r\nftype2 = funcdef->retval_ftype;\r\nif (!can_func(ftype2)) {\r\ndfilter_fail("Return value of function %s (type=%s) cannot participate in '%s' comparison.",\r\nfuncdef->name, ftype_pretty_name(ftype2),\r\nrelation_string);\r\nTHROW(TypeError);\r\n}\r\ns = (char*)stnode_data(st_arg1);\r\nfvalue = fvalue_from_string(ftype2, s, dfilter_fail);\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\ncheck_function(st_arg2);\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, new_st, st_arg2);\r\nstnode_free(st_arg1);\r\n}\r\nelse {\r\ng_assert_not_reached();\r\n}\r\n}\r\nstatic void\r\ncheck_relation_LHS_UNPARSED(const char* relation_string,\r\nFtypeCanFunc can_func, gboolean allow_partial_value,\r\nstnode_t *st_node,\r\nstnode_t *st_arg1, stnode_t *st_arg2)\r\n{\r\nstnode_t *new_st;\r\nsttype_id_t type2;\r\nheader_field_info *hfinfo2;\r\ndf_func_def_t *funcdef;\r\nftenum_t ftype2;\r\nfvalue_t *fvalue;\r\nchar *s;\r\ntype2 = stnode_type_id(st_arg2);\r\nDebugLog((" 5 check_relation_LHS_UNPARSED()\n"));\r\nif (type2 == STTYPE_FIELD) {\r\nhfinfo2 = (header_field_info*)stnode_data(st_arg2);\r\nftype2 = hfinfo2->type;\r\nif (!can_func(ftype2)) {\r\ndfilter_fail("%s (type=%s) cannot participate in '%s' comparison.",\r\nhfinfo2->abbrev, ftype_pretty_name(ftype2),\r\nrelation_string);\r\nTHROW(TypeError);\r\n}\r\ns = (char*)stnode_data(st_arg1);\r\nfvalue = fvalue_from_unparsed(ftype2, s, allow_partial_value, dfilter_fail);\r\nif (!fvalue) {\r\nfvalue = mk_fvalue_from_val_string(hfinfo2, s);\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, new_st, st_arg2);\r\nstnode_free(st_arg1);\r\n}\r\nelse if (type2 == STTYPE_STRING || type2 == STTYPE_UNPARSED) {\r\ndfilter_fail("Neither \"%s\" nor \"%s\" are field or protocol names.",\r\n(char *)stnode_data(st_arg1),\r\n(char *)stnode_data(st_arg2));\r\nTHROW(TypeError);\r\n}\r\nelse if (type2 == STTYPE_RANGE) {\r\ncheck_drange_sanity(st_arg2);\r\ns = (char*)stnode_data(st_arg1);\r\nfvalue = fvalue_from_unparsed(FT_BYTES, s, allow_partial_value, dfilter_fail);\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, new_st, st_arg2);\r\nstnode_free(st_arg1);\r\n}\r\nelse if (type2 == STTYPE_FUNCTION) {\r\nfuncdef = sttype_function_funcdef(st_arg2);\r\nftype2 = funcdef->retval_ftype;\r\nif (!can_func(ftype2)) {\r\ndfilter_fail("return value of function %s() (type=%s) cannot participate in '%s' comparison.",\r\nfuncdef->name, ftype_pretty_name(ftype2), relation_string);\r\nTHROW(TypeError);\r\n}\r\ns = (char*)stnode_data(st_arg1);\r\nfvalue = fvalue_from_unparsed(ftype2, s, allow_partial_value, dfilter_fail);\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\ncheck_function(st_arg2);\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, new_st, st_arg2);\r\nstnode_free(st_arg1);\r\n}\r\nelse {\r\ng_assert_not_reached();\r\n}\r\n}\r\nstatic void\r\ncheck_relation_LHS_RANGE(const char *relation_string, FtypeCanFunc can_func _U_,\r\ngboolean allow_partial_value,\r\nstnode_t *st_node,\r\nstnode_t *st_arg1, stnode_t *st_arg2)\r\n{\r\nstnode_t *new_st;\r\nsttype_id_t type2;\r\nstnode_t *entity1;\r\nheader_field_info *hfinfo1, *hfinfo2;\r\nftenum_t ftype1, ftype2;\r\nfvalue_t *fvalue;\r\nchar *s;\r\nint len_range;\r\nDebugLog((" 5 check_relation_LHS_RANGE(%s)\n", relation_string));\r\ntype2 = stnode_type_id(st_arg2);\r\nentity1 = sttype_range_entity(st_arg1);\r\nif (entity1 && stnode_type_id(entity1) == STTYPE_FIELD) {\r\nhfinfo1 = (header_field_info *)stnode_data(entity1);\r\nftype1 = hfinfo1->type;\r\nif (!ftype_can_slice(ftype1)) {\r\ndfilter_fail("\"%s\" is a %s and cannot be sliced into a sequence of bytes.",\r\nhfinfo1->abbrev, ftype_pretty_name(ftype1));\r\nTHROW(TypeError);\r\n}\r\n} else if (entity1 && stnode_type_id(entity1) == STTYPE_FUNCTION) {\r\ndf_func_def_t *funcdef = sttype_function_funcdef(entity1);\r\nftype1 = funcdef->retval_ftype;\r\nif (!ftype_can_slice(ftype1)) {\r\ndfilter_fail("Return value of function \"%s\" is a %s and cannot be converted into a sequence of bytes.",\r\nfuncdef->name, ftype_pretty_name(ftype1));\r\nTHROW(TypeError);\r\n}\r\ncheck_function(entity1);\r\n} else {\r\ndfilter_fail("Range is not supported, details: " G_STRLOC " entity: %p of type %d",\r\nentity1, entity1 ? (int) stnode_type_id(entity1) : -1);\r\nTHROW(TypeError);\r\n}\r\ncheck_drange_sanity(st_arg1);\r\nif (type2 == STTYPE_FIELD) {\r\nDebugLog((" 5 check_relation_LHS_RANGE(type2 = STTYPE_FIELD)\n"));\r\nhfinfo2 = (header_field_info*)stnode_data(st_arg2);\r\nftype2 = hfinfo2->type;\r\nif (!is_bytes_type(ftype2)) {\r\nif (!ftype_can_slice(ftype2)) {\r\ndfilter_fail("\"%s\" is a %s and cannot be converted into a sequence of bytes.",\r\nhfinfo2->abbrev,\r\nftype_pretty_name(ftype2));\r\nTHROW(TypeError);\r\n}\r\nnew_st = convert_to_bytes(st_arg2);\r\nsttype_test_set2_args(st_node, st_arg1, new_st);\r\n}\r\n}\r\nelse if (type2 == STTYPE_STRING) {\r\nDebugLog((" 5 check_relation_LHS_RANGE(type2 = STTYPE_STRING)\n"));\r\ns = (char*)stnode_data(st_arg2);\r\nif (strcmp(relation_string, "matches") == 0) {\r\nfvalue = fvalue_from_string(FT_PCRE, s, dfilter_fail);\r\n} else {\r\nfvalue = fvalue_from_string(FT_BYTES, s, dfilter_fail);\r\n}\r\nif (!fvalue) {\r\nDebugLog((" 5 check_relation_LHS_RANGE(type2 = STTYPE_STRING): Could not convert from string!\n"));\r\nTHROW(TypeError);\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, st_arg1, new_st);\r\nstnode_free(st_arg2);\r\n}\r\nelse if (type2 == STTYPE_UNPARSED) {\r\nDebugLog((" 5 check_relation_LHS_RANGE(type2 = STTYPE_UNPARSED)\n"));\r\ns = (char*)stnode_data(st_arg2);\r\nlen_range = drange_get_total_length(sttype_range_drange(st_arg1));\r\nif (strcmp(relation_string, "matches") == 0) {\r\nfvalue = fvalue_from_unparsed(FT_PCRE, s, FALSE, dfilter_fail);\r\n}\r\nelse if (len_range == 1 && strlen(s) == 4 && strncmp(s, "0x", 2) == 0) {\r\nfvalue = fvalue_from_unparsed(FT_UINT8, s, allow_partial_value, dfilter_fail);\r\nif (fvalue) {\r\nFVALUE_FREE(fvalue);\r\nfvalue = fvalue_from_unparsed(FT_BYTES, s+2, allow_partial_value, dfilter_fail);\r\n}\r\n}\r\nelse {\r\nfvalue = fvalue_from_unparsed(FT_BYTES, s, allow_partial_value, dfilter_fail);\r\n}\r\nif (!fvalue) {\r\nDebugLog((" 5 check_relation_LHS_RANGE(type2 = STTYPE_UNPARSED): Could not convert from string!\n"));\r\nTHROW(TypeError);\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, st_arg1, new_st);\r\nstnode_free(st_arg2);\r\n}\r\nelse if (type2 == STTYPE_RANGE) {\r\nDebugLog((" 5 check_relation_LHS_RANGE(type2 = STTYPE_RANGE)\n"));\r\ncheck_drange_sanity(st_arg2);\r\n}\r\nelse if (type2 == STTYPE_FUNCTION) {\r\ndf_func_def_t *funcdef = sttype_function_funcdef(st_arg2);\r\nftype2 = funcdef->retval_ftype;\r\nif (!is_bytes_type(ftype2)) {\r\nif (!ftype_can_slice(ftype2)) {\r\ndfilter_fail("Return value of function \"%s\" is a %s and cannot be converted into a sequence of bytes.",\r\nfuncdef->name,\r\nftype_pretty_name(ftype2));\r\nTHROW(TypeError);\r\n}\r\nnew_st = convert_to_bytes(st_arg2);\r\nsttype_test_set2_args(st_node, st_arg1, new_st);\r\n}\r\ncheck_function(st_arg2);\r\n}\r\nelse {\r\ng_assert_not_reached();\r\n}\r\n}\r\nstatic stnode_t*\r\ncheck_param_entity(stnode_t *st_node)\r\n{\r\nsttype_id_t e_type;\r\nstnode_t *new_st;\r\nfvalue_t *fvalue;\r\nchar *s;\r\ne_type = stnode_type_id(st_node);\r\nif (e_type == STTYPE_UNPARSED) {\r\ns = (char*)stnode_data(st_node);\r\nfvalue = fvalue_from_unparsed(FT_STRING, s, FALSE, dfilter_fail);\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nstnode_free(st_node);\r\nreturn new_st;\r\n}\r\nreturn st_node;\r\n}\r\nstatic void\r\ncheck_relation_LHS_FUNCTION(const char *relation_string, FtypeCanFunc can_func,\r\ngboolean allow_partial_value,\r\nstnode_t *st_node, stnode_t *st_arg1, stnode_t *st_arg2)\r\n{\r\nstnode_t *new_st;\r\nsttype_id_t type2;\r\nheader_field_info *hfinfo2;\r\nftenum_t ftype1, ftype2;\r\nfvalue_t *fvalue;\r\nchar *s;\r\ndf_func_def_t *funcdef;\r\ndf_func_def_t *funcdef2;\r\ncheck_function(st_arg1);\r\ntype2 = stnode_type_id(st_arg2);\r\nfuncdef = sttype_function_funcdef(st_arg1);\r\nftype1 = funcdef->retval_ftype;\r\nsttype_function_params(st_arg1);\r\nDebugLog((" 5 check_relation_LHS_FUNCTION(%s)\n", relation_string));\r\nif (!can_func(ftype1)) {\r\ndfilter_fail("Function %s (type=%s) cannot participate in '%s' comparison.",\r\nfuncdef->name, ftype_pretty_name(ftype1),\r\nrelation_string);\r\nTHROW(TypeError);\r\n}\r\nif (type2 == STTYPE_FIELD) {\r\nhfinfo2 = (header_field_info*)stnode_data(st_arg2);\r\nftype2 = hfinfo2->type;\r\nif (!compatible_ftypes(ftype1, ftype2)) {\r\ndfilter_fail("Function %s and %s are not of compatible types.",\r\nfuncdef->name, hfinfo2->abbrev);\r\nTHROW(TypeError);\r\n}\r\nif (!can_func(ftype2)) {\r\ndfilter_fail("%s (type=%s) cannot participate in specified comparison.",\r\nhfinfo2->abbrev, ftype_pretty_name(ftype2));\r\nTHROW(TypeError);\r\n}\r\n}\r\nelse if (type2 == STTYPE_STRING) {\r\ns = (char*)stnode_data(st_arg2);\r\nif (strcmp(relation_string, "matches") == 0) {\r\nfvalue = fvalue_from_string(FT_PCRE, s, dfilter_fail);\r\n} else {\r\nfvalue = fvalue_from_string(ftype1, s, dfilter_fail);\r\n}\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, st_arg1, new_st);\r\nstnode_free(st_arg2);\r\n}\r\nelse if (type2 == STTYPE_UNPARSED) {\r\ns = (char*)stnode_data(st_arg2);\r\nif (strcmp(relation_string, "matches") == 0) {\r\nfvalue = fvalue_from_unparsed(FT_PCRE, s, FALSE, dfilter_fail);\r\n} else {\r\nfvalue = fvalue_from_unparsed(ftype1, s, allow_partial_value, dfilter_fail);\r\n}\r\nif (!fvalue) {\r\nTHROW(TypeError);\r\n}\r\nnew_st = stnode_new(STTYPE_FVALUE, fvalue);\r\nsttype_test_set2_args(st_node, st_arg1, new_st);\r\nstnode_free(st_arg2);\r\n}\r\nelse if (type2 == STTYPE_RANGE) {\r\ncheck_drange_sanity(st_arg2);\r\nif (!is_bytes_type(ftype1)) {\r\nif (!ftype_can_slice(ftype1)) {\r\ndfilter_fail("Function \"%s\" is a %s and cannot be converted into a sequence of bytes.",\r\nfuncdef->name,\r\nftype_pretty_name(ftype1));\r\nTHROW(TypeError);\r\n}\r\nnew_st = convert_to_bytes(st_arg1);\r\nsttype_test_set2_args(st_node, new_st, st_arg2);\r\n}\r\n}\r\nelse if (type2 == STTYPE_FUNCTION) {\r\nfuncdef2 = sttype_function_funcdef(st_arg2);\r\nftype2 = funcdef2->retval_ftype;\r\nif (!compatible_ftypes(ftype1, ftype2)) {\r\ndfilter_fail("Return values of function %s (type=%s) and function %s (type=%s) are not of compatible types.",\r\nfuncdef->name, ftype_pretty_name(ftype1), funcdef2->name, ftype_pretty_name(ftype2));\r\nTHROW(TypeError);\r\n}\r\nif (!can_func(ftype2)) {\r\ndfilter_fail("Return value of %s (type=%s) cannot participate in specified comparison.",\r\nfuncdef2->name, ftype_pretty_name(ftype2));\r\nTHROW(TypeError);\r\n}\r\ncheck_function(st_arg2);\r\n}\r\nelse {\r\ng_assert_not_reached();\r\n}\r\n}\r\nstatic void\r\ncheck_relation(const char *relation_string, gboolean allow_partial_value,\r\nFtypeCanFunc can_func, stnode_t *st_node,\r\nstnode_t *st_arg1, stnode_t *st_arg2)\r\n{\r\n#ifdef DEBUG_dfilter\r\nstatic guint i = 0;\r\n#endif\r\nheader_field_info *hfinfo;\r\nDebugLog((" 4 check_relation(\"%s\") [%u]\n", relation_string, i++));\r\nif (stnode_type_id(st_arg2) == STTYPE_FIELD) {\r\nhfinfo = (header_field_info*)stnode_data(st_arg2);\r\nif (hfinfo->type == FT_PROTOCOL) {\r\ndfilter_fail("Protocol (\"%s\") cannot appear on right-hand side of comparison.", hfinfo->abbrev);\r\nTHROW(TypeError);\r\n}\r\n}\r\nswitch (stnode_type_id(st_arg1)) {\r\ncase STTYPE_FIELD:\r\ncheck_relation_LHS_FIELD(relation_string, can_func,\r\nallow_partial_value, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase STTYPE_STRING:\r\ncheck_relation_LHS_STRING(relation_string, can_func,\r\nallow_partial_value, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase STTYPE_RANGE:\r\ncheck_relation_LHS_RANGE(relation_string, can_func,\r\nallow_partial_value, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase STTYPE_UNPARSED:\r\ncheck_relation_LHS_UNPARSED(relation_string, can_func,\r\nallow_partial_value, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase STTYPE_FUNCTION:\r\ncheck_relation_LHS_FUNCTION(relation_string, can_func,\r\nallow_partial_value, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase STTYPE_UNINITIALIZED:\r\ncase STTYPE_TEST:\r\ncase STTYPE_INTEGER:\r\ncase STTYPE_FVALUE:\r\ndefault:\r\ng_assert_not_reached();\r\n}\r\n}\r\nstatic void\r\ncheck_test(stnode_t *st_node, GPtrArray *deprecated)\r\n{\r\ntest_op_t st_op, st_arg_op;\r\nstnode_t *st_arg1, *st_arg2;\r\n#ifdef DEBUG_dfilter\r\nstatic guint i = 0;\r\n#endif\r\nDebugLog((" 3 check_test(stnode_t *st_node = %p) [%u]\n", st_node, i));\r\nsttype_test_get(st_node, &st_op, &st_arg1, &st_arg2);\r\nswitch (st_op) {\r\ncase TEST_OP_UNINITIALIZED:\r\ng_assert_not_reached();\r\nbreak;\r\ncase TEST_OP_EXISTS:\r\ncheck_exists(st_arg1);\r\nbreak;\r\ncase TEST_OP_NOT:\r\nsemcheck(st_arg1, deprecated);\r\nbreak;\r\ncase TEST_OP_AND:\r\ncase TEST_OP_OR:\r\nif (stnode_type_id(st_arg1) == STTYPE_TEST) {\r\nsttype_test_get(st_arg1, &st_arg_op, NULL, NULL);\r\nif (st_arg_op == TEST_OP_AND || st_arg_op == TEST_OP_OR) {\r\nif (st_op != st_arg_op && !st_arg1->inside_brackets)\r\ng_ptr_array_add(deprecated, g_strdup("suggest parentheses around '&&' within '||'"));\r\n}\r\n}\r\nif (stnode_type_id(st_arg2) == STTYPE_TEST) {\r\nsttype_test_get(st_arg2, &st_arg_op, NULL, NULL);\r\nif (st_arg_op == TEST_OP_AND || st_arg_op == TEST_OP_OR) {\r\nif (st_op != st_arg_op && !st_arg2->inside_brackets)\r\ng_ptr_array_add(deprecated, g_strdup("suggest parentheses around '&&' within '||'"));\r\n}\r\n}\r\nsemcheck(st_arg1, deprecated);\r\nsemcheck(st_arg2, deprecated);\r\nbreak;\r\ncase TEST_OP_EQ:\r\ncheck_relation("==", FALSE, ftype_can_eq, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_NE:\r\ncheck_relation("!=", FALSE, ftype_can_ne, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_GT:\r\ncheck_relation(">", FALSE, ftype_can_gt, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_GE:\r\ncheck_relation(">=", FALSE, ftype_can_ge, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_LT:\r\ncheck_relation("<", FALSE, ftype_can_lt, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_LE:\r\ncheck_relation("<=", FALSE, ftype_can_le, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_BITWISE_AND:\r\ncheck_relation("&", FALSE, ftype_can_bitwise_and, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_CONTAINS:\r\ncheck_relation("contains", TRUE, ftype_can_contains, st_node, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_MATCHES:\r\ncheck_relation("matches", TRUE, ftype_can_matches, st_node, st_arg1, st_arg2); break;\r\ndefault:\r\ng_assert_not_reached();\r\n}\r\nDebugLog((" 3 check_test(stnode_t *st_node = %p) [%u] - End\n", st_node, i++));\r\n}\r\nstatic void\r\nsemcheck(stnode_t *st_node, GPtrArray *deprecated)\r\n{\r\n#ifdef DEBUG_dfilter\r\nstatic guint i = 0;\r\n#endif\r\nDebugLog((" 2 semcheck(stnode_t *st_node = %p) [%u]\n", st_node, i++));\r\nswitch (stnode_type_id(st_node)) {\r\ncase STTYPE_TEST:\r\ncheck_test(st_node, deprecated);\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\n}\r\n}\r\ngboolean\r\ndfw_semcheck(dfwork_t *dfw, GPtrArray *deprecated)\r\n{\r\nvolatile gboolean ok_filter = TRUE;\r\n#ifdef DEBUG_dfilter\r\nstatic guint i = 0;\r\n#endif\r\nDebugLog(("1 dfw_semcheck(dfwork_t *dfw = %p) [%u]\n", dfw, i));\r\nTRY {\r\nsemcheck(dfw->st_root, deprecated);\r\n}\r\nCATCH(TypeError) {\r\nok_filter = FALSE;\r\n}\r\nENDTRY;\r\nDebugLog(("1 dfw_semcheck(dfwork_t *dfw = %p) [%u] - Returns %d\n",\r\ndfw, i++,ok_filter));\r\nreturn ok_filter;\r\n}
