static void\r\ndraw_sack_graph(struct sctp_udata *u_data)\r\n{\r\ntsn_t *sack;\r\nGList *list=NULL, *tlist;\r\nguint16 gap_start=0, gap_end=0, i, j, nr, dup_nr;\r\nguint8 type;\r\nguint32 tsnumber, dupx;\r\ngint xvalue, yvalue;\r\nGdkRGBA red_color = {1.0, 0.0, 0.0, 1.0};\r\nGdkRGBA green_color = {0.0, 1.0, 0.0, 1.0};\r\nGdkRGBA cyan_color = {0.0, 1.0, 1.0, 1.0};\r\nstruct sack_chunk_header *sack_header;\r\nstruct gaps *gap;\r\nguint32 diff;\r\nguint32 *dup_list;\r\ncairo_t * cr = NULL;\r\nif (u_data->dir==2)\r\n{\r\nlist = g_list_last(u_data->assoc->sack2);\r\nif (u_data->io->tmp==FALSE)\r\n{\r\nmin_tsn=u_data->assoc->min_tsn2;\r\nmax_tsn=u_data->assoc->max_tsn2;\r\n}\r\nelse\r\n{\r\nmin_tsn=u_data->assoc->min_tsn2+u_data->io->tmp_min_tsn2;\r\nmax_tsn=u_data->assoc->min_tsn2+u_data->io->tmp_max_tsn2;\r\n}\r\n}\r\nelse if (u_data->dir==1)\r\n{\r\nlist = g_list_last(u_data->assoc->sack1);\r\nif (u_data->io->tmp==FALSE)\r\n{\r\nmin_tsn=u_data->assoc->min_tsn1;\r\nmax_tsn=u_data->assoc->max_tsn1;\r\n}\r\nelse\r\n{\r\nmin_tsn=u_data->assoc->min_tsn1+u_data->io->tmp_min_tsn1;\r\nmax_tsn=u_data->assoc->min_tsn1+u_data->io->tmp_max_tsn1;\r\n}\r\n}\r\nwhile (list)\r\n{\r\nsack = (tsn_t*) (list->data);\r\ntlist = g_list_first(sack->tsns);\r\nwhile (tlist)\r\n{\r\ntype = ((struct chunk_header *)tlist->data)->type;\r\nif (type == SCTP_SACK_CHUNK_ID)\r\n{\r\ngIsSackChunkPresent = 1;\r\nsack_header =(struct sack_chunk_header *)tlist->data;\r\nnr=g_ntohs(sack_header->nr_of_gaps);\r\ntsnumber = g_ntohl(sack_header->cum_tsn_ack);\r\ndup_nr=g_ntohs(sack_header->nr_of_dups);\r\nif (sack->secs>=u_data->io->x1_tmp_sec)\r\n{\r\nif (nr>0)\r\n{\r\ngap = &sack_header->gaps[0];\r\nfor(i=0;i<nr; i++)\r\n{\r\ngap_start=g_ntohs(gap->start);\r\ngap_end = g_ntohs(gap->end);\r\nfor (j=gap_start; j<=gap_end; j++)\r\n{\r\nif (u_data->io->uoff)\r\ndiff = sack->secs - u_data->io->min_x;\r\nelse\r\ndiff=sack->secs*1000000+sack->usecs-u_data->io->min_x;\r\nxvalue = (guint32)(LEFT_BORDER+u_data->io->offset+u_data->io->x_interval*diff);\r\nyvalue = (guint32)(u_data->io->surface_height-BOTTOM_BORDER-POINT_SIZE-u_data->io->offset-((SUB_32(j+tsnumber,min_tsn))*u_data->io->y_interval));\r\nif (xvalue >= LEFT_BORDER+u_data->io->offset &&\r\nxvalue <= u_data->io->surface_width-RIGHT_BORDER+u_data->io->offset &&\r\nyvalue >= TOP_BORDER-u_data->io->offset-POINT_SIZE &&\r\nyvalue <= u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset) {\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ngdk_cairo_set_source_rgba (cr, &green_color);\r\ncairo_arc(cr,\r\nxvalue,\r\nyvalue,\r\nPOINT_SIZE,\r\n0,\r\n2 * G_PI);\r\ncairo_fill(cr);\r\ncairo_destroy(cr);\r\n}\r\n}\r\nif (i < nr-1)\r\ngap++;\r\n}\r\n}\r\nif (tsnumber>=min_tsn)\r\n{\r\nif (u_data->io->uoff)\r\ndiff = sack->secs - u_data->io->min_x;\r\nelse\r\ndiff=sack->secs*1000000+sack->usecs-u_data->io->min_x;\r\nxvalue = (guint32)(LEFT_BORDER+u_data->io->offset+u_data->io->x_interval*diff);\r\nyvalue = (guint32)(u_data->io->surface_height-BOTTOM_BORDER-POINT_SIZE -u_data->io->offset-((SUB_32(tsnumber,min_tsn))*u_data->io->y_interval));\r\nif (xvalue >= LEFT_BORDER+u_data->io->offset &&\r\nxvalue <= u_data->io->surface_width-RIGHT_BORDER+u_data->io->offset &&\r\nyvalue >= TOP_BORDER-u_data->io->offset-POINT_SIZE &&\r\nyvalue <= u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset)\r\n{\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ngdk_cairo_set_source_rgba (cr, &red_color);\r\ncairo_arc(cr,\r\nxvalue,\r\nyvalue,\r\nPOINT_SIZE,\r\n0,\r\n2 * G_PI);\r\ncairo_fill(cr);\r\ncairo_destroy(cr);\r\n}\r\n}\r\nif (dup_nr > 0)\r\n{\r\ndup_list = &sack_header->a_rwnd + 2 + nr;\r\nfor (i = 0; i < dup_nr; i++)\r\n{\r\ndupx = g_ntohl(dup_list[i]);\r\nif (dupx >= min_tsn)\r\n{\r\nif (u_data->io->uoff)\r\ndiff = sack->secs - u_data->io->min_x;\r\nelse\r\ndiff=sack->secs*1000000+sack->usecs-u_data->io->min_x;\r\nxvalue = (guint32)(LEFT_BORDER+u_data->io->offset+u_data->io->x_interval*diff);\r\nyvalue = (guint32)(u_data->io->surface_height-BOTTOM_BORDER-POINT_SIZE -u_data->io->offset-((SUB_32(dupx,min_tsn))*u_data->io->y_interval));\r\nif (xvalue >= LEFT_BORDER+u_data->io->offset &&\r\nxvalue <= u_data->io->surface_width-RIGHT_BORDER+u_data->io->offset &&\r\nyvalue >= TOP_BORDER-u_data->io->offset-POINT_SIZE &&\r\nyvalue <= u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset) {\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ngdk_cairo_set_source_rgba (cr, &cyan_color);\r\ncairo_arc(cr,\r\nxvalue,\r\nyvalue,\r\nPOINT_SIZE,\r\n0,\r\n2 * G_PI);\r\ncairo_fill(cr);\r\ncairo_destroy(cr);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\ntlist = g_list_next(tlist);\r\n}\r\nlist = g_list_previous(list);\r\n}\r\n}\r\nstatic void\r\ndraw_nr_sack_graph(struct sctp_udata *u_data)\r\n{\r\ntsn_t *sack;\r\nGList *list=NULL, *tlist;\r\nguint16 gap_start=0, gap_end=0, i, numberOf_gaps, numberOf_nr_gaps;\r\nguint8 type;\r\nguint32 tsnumber, j;\r\ngint xvalue, yvalue;\r\nGdkRGBA red_color = {1.0, 0.0, 0.0, 1.0};\r\nGdkRGBA green_color = {0.0, 1.0, 0.0, 1.0};\r\nGdkRGBA blue_color = {0.0, 0.0, 1.0, 1.0};\r\nstruct nr_sack_chunk_header *nr_sack_header;\r\nstruct gaps *nr_gap;\r\nguint32 diff;\r\nguint16 total_gaps = 0;\r\ncairo_t *cr = NULL;\r\nif (u_data->dir==2)\r\n{\r\nlist = g_list_last(u_data->assoc->sack2);\r\nif (u_data->io->tmp==FALSE)\r\n{\r\nmin_tsn=u_data->assoc->min_tsn2;\r\nmax_tsn=u_data->assoc->max_tsn2;\r\n}\r\nelse\r\n{\r\nmin_tsn=u_data->assoc->min_tsn2+u_data->io->tmp_min_tsn2;\r\nmax_tsn=u_data->assoc->min_tsn2+u_data->io->tmp_max_tsn2;\r\n}\r\n}\r\nelse if (u_data->dir==1)\r\n{\r\nlist = g_list_last(u_data->assoc->sack1);\r\nif (u_data->io->tmp==FALSE)\r\n{\r\nmin_tsn=u_data->assoc->min_tsn1;\r\nmax_tsn=u_data->assoc->max_tsn1;\r\n}\r\nelse\r\n{\r\nmin_tsn=u_data->assoc->min_tsn1+u_data->io->tmp_min_tsn1;\r\nmax_tsn=u_data->assoc->min_tsn1+u_data->io->tmp_max_tsn1;\r\n}\r\n}\r\nwhile (list)\r\n{\r\nsack = (tsn_t*) (list->data);\r\ntlist = g_list_first(sack->tsns);\r\nwhile (tlist)\r\n{\r\ntype = ((struct chunk_header *)tlist->data)->type;\r\nif (type == SCTP_NR_SACK_CHUNK_ID)\r\n{\r\ngIsNRSackChunkPresent = 1;\r\nnr_sack_header =(struct nr_sack_chunk_header *)tlist->data;\r\nnumberOf_nr_gaps=g_ntohs(nr_sack_header->nr_of_nr_gaps);\r\nnumberOf_gaps=g_ntohs(nr_sack_header->nr_of_gaps);\r\ntsnumber = g_ntohl(nr_sack_header->cum_tsn_ack);\r\ntotal_gaps = numberOf_gaps + numberOf_nr_gaps;\r\nif (sack->secs>=u_data->io->x1_tmp_sec)\r\n{\r\nif ( total_gaps > 0 )\r\n{\r\nnr_gap = &nr_sack_header->gaps[0];\r\nfor ( i=0; i < total_gaps; i++ )\r\n{\r\ngap_start=g_ntohs(nr_gap->start);\r\ngap_end = g_ntohs(nr_gap->end);\r\nfor ( j = gap_start; j <= gap_end; j++)\r\n{\r\nif (u_data->io->uoff)\r\ndiff = sack->secs - u_data->io->min_x;\r\nelse\r\ndiff=sack->secs*1000000+sack->usecs-u_data->io->min_x;\r\nxvalue = (guint32)(LEFT_BORDER+u_data->io->offset+u_data->io->x_interval*diff);\r\nyvalue = (guint32)(u_data->io->surface_height-BOTTOM_BORDER-POINT_SIZE-u_data->io->offset-((SUB_32(j+tsnumber,min_tsn))*u_data->io->y_interval));\r\nif (xvalue >= LEFT_BORDER+u_data->io->offset &&\r\nxvalue <= u_data->io->surface_width-RIGHT_BORDER+u_data->io->offset &&\r\nyvalue >= TOP_BORDER-u_data->io->offset-POINT_SIZE &&\r\nyvalue <= u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset)\r\n{\r\nif ( i >= numberOf_gaps)\r\n{\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ngdk_cairo_set_source_rgba (cr, &blue_color);\r\ncairo_arc(cr,\r\nxvalue,\r\nyvalue,\r\nPOINT_SIZE,\r\n0,\r\n2 * G_PI);\r\ncairo_stroke(cr);\r\ncairo_destroy(cr);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ngdk_cairo_set_source_rgba (cr, &green_color);\r\ncairo_arc(cr,\r\nxvalue,\r\nyvalue,\r\nPOINT_SIZE,\r\n0,\r\n2 * G_PI);\r\ncairo_fill(cr);\r\ncairo_destroy(cr);\r\n}\r\nelse\r\n{\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ngdk_cairo_set_source_rgba (cr, &green_color);\r\ncairo_arc(cr,\r\nxvalue,\r\nyvalue,\r\nPOINT_SIZE,\r\n0,\r\n2 * G_PI);\r\ncairo_fill(cr);\r\ncairo_destroy(cr);\r\n}\r\n}\r\n}\r\nif (i < total_gaps-1)\r\nnr_gap++;\r\n}\r\n}\r\nif (tsnumber>=min_tsn)\r\n{\r\nif (u_data->io->uoff)\r\ndiff = sack->secs - u_data->io->min_x;\r\nelse\r\ndiff=sack->secs*1000000+sack->usecs-u_data->io->min_x;\r\nxvalue = (guint32)(LEFT_BORDER+u_data->io->offset+u_data->io->x_interval*diff);\r\nyvalue = (guint32)(u_data->io->surface_height-BOTTOM_BORDER-POINT_SIZE -u_data->io->offset-((SUB_32(tsnumber,min_tsn))*u_data->io->y_interval));\r\nif (xvalue >= LEFT_BORDER+u_data->io->offset &&\r\nxvalue <= u_data->io->surface_width-RIGHT_BORDER+u_data->io->offset &&\r\nyvalue >= TOP_BORDER-u_data->io->offset-POINT_SIZE &&\r\nyvalue <= u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset) {\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ngdk_cairo_set_source_rgba (cr, &red_color);\r\ncairo_arc(cr,\r\nxvalue,\r\nyvalue,\r\nPOINT_SIZE,\r\n0,\r\n2 * G_PI);\r\ncairo_fill(cr);\r\ncairo_destroy(cr);\r\n}\r\n}\r\n}\r\n}\r\ntlist = g_list_next(tlist);\r\n}\r\nlist = g_list_previous(list);\r\n}\r\n}\r\nstatic void\r\ndraw_tsn_graph(struct sctp_udata *u_data)\r\n{\r\ntsn_t *tsn;\r\nGList *list=NULL, *tlist;\r\nguint8 type;\r\nguint32 tsnumber=0;\r\nguint32 min_secs=0, diff;\r\ngint xvalue, yvalue;\r\ncairo_t *cr = NULL;\r\nGdkRGBA black_color = {0.0, 0.0, 0.0, 1.0};\r\nGdkRGBA pink_color = {1.0, 0.6, 0.8, 1.0};\r\nif (u_data->dir == 1)\r\n{\r\nlist = g_list_last(u_data->assoc->tsn1);\r\nif (u_data->io->tmp == FALSE)\r\n{\r\nmin_tsn = u_data->assoc->min_tsn1;\r\nmax_tsn = u_data->assoc->max_tsn1;\r\n}\r\nelse\r\n{\r\nmin_tsn = u_data->assoc->min_tsn1 + u_data->io->tmp_min_tsn1;\r\nmax_tsn = u_data->assoc->min_tsn1 + u_data->io->tmp_max_tsn1;\r\n}\r\n}\r\nelse if (u_data->dir == 2)\r\n{\r\nlist = g_list_last(u_data->assoc->tsn2);\r\nif (u_data->io->tmp == FALSE)\r\n{\r\nmin_tsn = u_data->assoc->min_tsn2;\r\nmax_tsn = u_data->assoc->max_tsn2;\r\n}\r\nelse\r\n{\r\nmin_tsn = u_data->assoc->min_tsn2 + u_data->io->tmp_min_tsn2;\r\nmax_tsn = u_data->assoc->min_tsn2 + u_data->io->tmp_max_tsn2;\r\n}\r\n}\r\nwhile (list)\r\n{\r\ntsn = (tsn_t*) (list->data);\r\ntlist = g_list_first(tsn->tsns);\r\nwhile (tlist)\r\n{\r\ntype = ((struct chunk_header *)tlist->data)->type;\r\nif (type == SCTP_DATA_CHUNK_ID || type == SCTP_FORWARD_TSN_CHUNK_ID)\r\ntsnumber = g_ntohl(((struct data_chunk_header *)tlist->data)->tsn);\r\nif (tsnumber >= min_tsn && tsnumber <= max_tsn && tsn->secs >= min_secs)\r\n{\r\nif (u_data->io->uoff) {\r\ndiff = tsn->secs - u_data->io->min_x;\r\n} else {\r\ndiff = tsn->secs * 1000000 + tsn->usecs - u_data->io->min_x;\r\n}\r\nxvalue = (guint32)(LEFT_BORDER + u_data->io->offset + u_data->io->x_interval * diff);\r\nyvalue = (guint32)(u_data->io->surface_height - BOTTOM_BORDER - POINT_SIZE - u_data->io->offset - ((SUB_32(tsnumber,min_tsn))*u_data->io->y_interval));\r\nif (xvalue >= LEFT_BORDER+u_data->io->offset &&\r\nxvalue <= u_data->io->surface_width - RIGHT_BORDER + u_data->io->offset &&\r\nyvalue >= TOP_BORDER - u_data->io->offset - POINT_SIZE &&\r\nyvalue <= u_data->io->surface_height - BOTTOM_BORDER - u_data->io->offset) {\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\nif (type == SCTP_DATA_CHUNK_ID)\r\ngdk_cairo_set_source_rgba (cr, &black_color);\r\nelse\r\ngdk_cairo_set_source_rgba (cr, &pink_color);\r\ncairo_arc(cr,\r\nxvalue,\r\nyvalue,\r\nPOINT_SIZE,\r\n0,\r\n2 * G_PI);\r\ncairo_fill(cr);\r\ncairo_destroy(cr);\r\n}\r\n}\r\ntlist = g_list_next(tlist);\r\n}\r\nlist = g_list_previous(list);\r\n}\r\n}\r\nstatic void\r\nsctp_graph_draw(struct sctp_udata *u_data)\r\n{\r\nint length, lwidth;\r\nguint32 distance=5, i, e, sec, w, start, a, b, j;\r\ngint label_width, label_height;\r\nchar label_string[15];\r\ngfloat dis;\r\ngboolean write_label = FALSE;\r\nPangoLayout *layout;\r\nGtkAllocation widget_alloc;\r\ncairo_t *cr;\r\nif (u_data->io->x1_tmp_sec==0 && u_data->io->x1_tmp_usec==0)\r\nu_data->io->offset=0;\r\nelse\r\nu_data->io->offset=5;\r\nif (u_data->io->x2_tmp_sec - u_data->io->x1_tmp_sec > 1500)\r\n{\r\nu_data->io->min_x=u_data->io->x1_tmp_sec;\r\nu_data->io->max_x=u_data->io->x2_tmp_sec;\r\nu_data->io->uoff = TRUE;\r\n}\r\nelse\r\n{\r\nu_data->io->min_x=(guint32)(u_data->io->x1_tmp_sec*1000000.0+u_data->io->x1_tmp_usec);\r\nu_data->io->max_x=(guint32)(u_data->io->x2_tmp_sec*1000000.0+u_data->io->x2_tmp_usec);\r\nu_data->io->uoff = FALSE;\r\n}\r\nu_data->io->tmp_width=u_data->io->max_x-u_data->io->min_x;\r\nif (u_data->dir==1)\r\n{\r\nif (u_data->io->tmp==FALSE)\r\n{\r\nif (u_data->assoc->tsn1!=NULL || u_data->assoc->sack1!=NULL)\r\nu_data->io->max_y=u_data->io->tmp_max_tsn1 - u_data->io->tmp_min_tsn1;\r\nelse\r\nu_data->io->max_y= 0;\r\nu_data->io->min_y = 0;\r\n}\r\nelse\r\n{\r\nu_data->io->max_y = u_data->io->tmp_max_tsn1;\r\nu_data->io->min_y = u_data->io->tmp_min_tsn1;\r\n}\r\n}\r\nelse if (u_data->dir==2)\r\n{\r\nif (u_data->io->tmp==FALSE)\r\n{\r\nif (u_data->assoc->tsn2!=NULL || u_data->assoc->sack2!=NULL)\r\nu_data->io->max_y=u_data->io->tmp_max_tsn2 -u_data->io->tmp_min_tsn2;\r\nelse\r\nu_data->io->max_y= 0;\r\nu_data->io->min_y = 0;\r\n}\r\nelse\r\n{\r\nu_data->io->max_y = u_data->io->tmp_max_tsn2;\r\nu_data->io->min_y = u_data->io->tmp_min_tsn2;\r\n}\r\n}\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_set_source_rgb (cr, 1, 1, 1);\r\ngtk_widget_get_allocation(u_data->io->draw_area, &widget_alloc);\r\ncairo_rectangle (cr,\r\n0,\r\n0,\r\nwidget_alloc.width,\r\nwidget_alloc.height);\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_set_line_width (cr, 1.0);\r\ncairo_move_to(cr, LEFT_BORDER+u_data->io->offset+0.5, u_data->io->surface_height - BOTTOM_BORDER+0.5);\r\ncairo_line_to(cr, u_data->io->surface_width - RIGHT_BORDER + u_data->io->offset+0.5, u_data->io->surface_height - BOTTOM_BORDER+0.5);\r\ncairo_move_to(cr, u_data->io->surface_width - RIGHT_BORDER + u_data->io->offset+0.5, u_data->io->surface_height - BOTTOM_BORDER+0.5);\r\ncairo_line_to(cr, u_data->io->surface_width - RIGHT_BORDER + u_data->io->offset - 5+0.5, u_data->io->surface_height - BOTTOM_BORDER - 5+0.5);\r\ncairo_move_to(cr, u_data->io->surface_width - RIGHT_BORDER + u_data->io->offset + 0.5, u_data->io->surface_height - BOTTOM_BORDER + 0.5);\r\ncairo_line_to(cr, u_data->io->surface_width - RIGHT_BORDER + u_data->io->offset - 5.5, u_data->io->surface_height - BOTTOM_BORDER + 5.5);\r\ncairo_stroke(cr);\r\ncairo_destroy(cr);\r\nu_data->io->axis_width=u_data->io->surface_width-LEFT_BORDER-RIGHT_BORDER-u_data->io->offset;\r\nif(u_data->io->tmp_width>0){\r\nu_data->io->x_interval = (float)((u_data->io->axis_width*1.0)/u_data->io->tmp_width);\r\n} else {\r\nu_data->io->x_interval = (float)(u_data->io->axis_width);\r\n}\r\ne=0;\r\nif (u_data->io->x_interval<1)\r\n{\r\ndis=1/u_data->io->x_interval;\r\nwhile (dis >1)\r\n{\r\ndis/=10;\r\ne++;\r\n}\r\ndistance=1;\r\nfor (i=0; i<=e+1; i++)\r\ndistance*=10;\r\n}\r\nelse\r\ndistance=5;\r\ng_snprintf(label_string, sizeof(label_string), "%d", 0);\r\nmemcpy(label_string,(gchar *)g_locale_to_utf8(label_string, -1 , NULL, NULL, NULL), sizeof(label_string));\r\nlayout = gtk_widget_create_pango_layout(u_data->io->draw_area, label_string);\r\npango_layout_get_pixel_size(layout, &label_width, &label_height);\r\nif (u_data->io->x1_tmp_usec==0)\r\nsec=u_data->io->x1_tmp_sec;\r\nelse\r\nsec=u_data->io->x1_tmp_sec+1;\r\nif (u_data->io->offset!=0)\r\n{\r\ng_snprintf(label_string, sizeof(label_string), "%u", u_data->io->x1_tmp_sec);\r\nmemcpy(label_string,(gchar *)g_locale_to_utf8(label_string, -1 , NULL, NULL, NULL), sizeof(label_string));\r\npango_layout_set_text(layout, label_string, -1);\r\npango_layout_get_pixel_size(layout, &lwidth, NULL);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_move_to (cr,\r\nLEFT_BORDER-25,\r\nu_data->io->surface_height-BOTTOM_BORDER+20);\r\npango_cairo_show_layout (cr, layout);\r\ncairo_destroy (cr);\r\ncr = NULL;\r\n}\r\nw=(guint32)(500/(guint32)(distance*u_data->io->x_interval));\r\nif (w==0)\r\nw=1;\r\nif (w==4 || w==3 || w==2)\r\n{\r\nw=5;\r\na=distance/10;\r\nb = (guint32)((u_data->io->min_x/100000))%10;\r\n}\r\nelse\r\n{\r\na=distance/5;\r\nb=0;\r\n}\r\nif (!u_data->io->uoff)\r\n{\r\nif (a>=1000000)\r\n{\r\nstart=u_data->io->min_x/1000000*1000000;\r\nif (a==1000000)\r\nb = 0;\r\n}\r\nelse\r\n{\r\nstart=u_data->io->min_x/100000;\r\nif (start%2!=0)\r\nstart--;\r\nstart*=100000;\r\nb = (guint32)((start/100000))%10;\r\n}\r\n}\r\nelse\r\n{\r\nstart = u_data->io->min_x;\r\nif (start%2!=0)\r\nstart--;\r\nb = 0;\r\n}\r\nfor (i=start, j=b; i<=u_data->io->max_x; i+=a, j++)\r\n{\r\nif (!u_data->io->uoff)\r\nif (i>=u_data->io->min_x && i%1000000!=0)\r\n{\r\nlength=5;\r\ng_snprintf(label_string, sizeof(label_string), "%d", i%1000000);\r\nif (j%w==0)\r\n{\r\nlength=10;\r\nmemcpy(label_string,(gchar *)g_locale_to_utf8(label_string, -1 , NULL, NULL, NULL), sizeof(label_string));\r\npango_layout_set_text(layout, label_string, -1);\r\npango_layout_get_pixel_size(layout, &lwidth, NULL);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_move_to (cr,\r\nLEFT_BORDER+u_data->io->offset+(i-u_data->io->min_x)*u_data->io->x_interval-lwidth/2,\r\nu_data->io->surface_height-BOTTOM_BORDER+10);\r\npango_cairo_show_layout (cr, layout);\r\ncairo_destroy (cr);\r\ncr = NULL;\r\n}\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_set_line_width (cr, 1.0);\r\ncairo_move_to(cr,\r\nLEFT_BORDER + u_data->io->offset + (i - u_data->io->min_x) * u_data->io->x_interval + 0.5,\r\nu_data->io->surface_height - BOTTOM_BORDER + 0.5);\r\ncairo_line_to(cr,\r\nLEFT_BORDER + u_data->io->offset + (i - u_data->io->min_x) * u_data->io->x_interval + 0.5,\r\nu_data->io->surface_height - BOTTOM_BORDER + length + 0.5);\r\ncairo_stroke(cr);\r\ncairo_destroy(cr);\r\n}\r\nif (!u_data->io->uoff)\r\n{\r\nif (i%1000000==0 && j%w==0)\r\n{\r\nsec=i/1000000;\r\nwrite_label = TRUE;\r\n}\r\n}\r\nelse\r\n{\r\nif (j%w == 0)\r\n{\r\nsec = i;\r\nwrite_label = TRUE;\r\n}\r\n}\r\nif (write_label)\r\n{\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_set_line_width (cr, 1.0);\r\ncairo_move_to(cr,\r\nLEFT_BORDER + u_data->io->offset + (i - u_data->io->min_x) * u_data->io->x_interval + 0.5,\r\nu_data->io->surface_height - BOTTOM_BORDER + 0.5);\r\ncairo_line_to(cr,\r\nLEFT_BORDER + u_data->io->offset + (i - u_data->io->min_x) * u_data->io->x_interval + 0.5,\r\nu_data->io->surface_height - BOTTOM_BORDER + 10 + 0.5);\r\ncairo_stroke(cr);\r\ncairo_destroy(cr);\r\ng_snprintf(label_string, sizeof(label_string), "%d", sec);\r\nmemcpy(label_string,(gchar *)g_locale_to_utf8(label_string, -1 , NULL, NULL, NULL), sizeof(label_string));\r\npango_layout_set_text(layout, label_string, -1);\r\npango_layout_get_pixel_size(layout, &lwidth, NULL);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_move_to (cr,\r\nLEFT_BORDER+u_data->io->offset+(i-u_data->io->min_x)*u_data->io->x_interval-10,\r\nu_data->io->surface_height-BOTTOM_BORDER+20);\r\npango_cairo_show_layout (cr, layout);\r\ncairo_destroy (cr);\r\ncr = NULL;\r\nwrite_label = FALSE;\r\n}\r\n}\r\ng_strlcpy(label_string, "sec", sizeof(label_string));\r\nmemcpy(label_string,(gchar *)g_locale_to_utf8(label_string, -1 , NULL, NULL, NULL), sizeof(label_string));\r\npango_layout_set_text(layout, label_string, -1);\r\npango_layout_get_pixel_size(layout, &lwidth, NULL);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_move_to (cr,\r\nu_data->io->surface_width-RIGHT_BORDER-10,\r\nu_data->io->surface_height-BOTTOM_BORDER+30);\r\npango_cairo_show_layout (cr, layout);\r\ncairo_destroy (cr);\r\ncr = NULL;\r\ndistance=5;\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_set_line_width (cr, 1.0);\r\ncairo_move_to(cr, LEFT_BORDER + 0.5, TOP_BORDER - u_data->io->offset + 0.5);\r\ncairo_line_to(cr, LEFT_BORDER + 0.5, u_data->io->surface_height - BOTTOM_BORDER - u_data->io->offset + 0.5);\r\ncairo_move_to(cr, LEFT_BORDER + 0.5, TOP_BORDER - u_data->io->offset + 0.5);\r\ncairo_line_to(cr, LEFT_BORDER - 5 + 0.5, TOP_BORDER - u_data->io->offset + 5 + 0.5);\r\ncairo_move_to(cr, LEFT_BORDER + 0.5, TOP_BORDER - u_data->io->offset + 0.5);\r\ncairo_line_to(cr, LEFT_BORDER +5 + 0.5, TOP_BORDER - u_data->io->offset + 5 + 0.5);\r\ncairo_stroke(cr);\r\ncairo_destroy(cr);\r\nu_data->io->y_interval = (float)(((u_data->io->surface_height-TOP_BORDER-BOTTOM_BORDER)*1.0)/(u_data->io->max_y-u_data->io->min_y));\r\ne=0;\r\nif (u_data->io->y_interval<1)\r\n{\r\ndis=1/u_data->io->y_interval;\r\nwhile (dis >1)\r\n{\r\ndis/=10;\r\ne++;\r\n}\r\ndistance=1;\r\nfor (i=0; i<=e; i++)\r\ndistance=distance*10;\r\n}\r\nelse if (u_data->io->y_interval<2)\r\ndistance = 10;\r\nif (u_data->io->max_y>0)\r\n{\r\nfor (i=u_data->io->min_y/distance*distance; i<=u_data->io->max_y; i+=distance/5)\r\n{\r\nif (i>=u_data->io->min_y)\r\n{\r\nlength=5;\r\ng_snprintf(label_string, sizeof(label_string), "%d", i);\r\nif (i%distance==0 || (distance<=5 && u_data->io->y_interval>10))\r\n{\r\nlength=10;\r\nmemcpy(label_string,(gchar *)g_locale_to_utf8(label_string, -1 , NULL, NULL, NULL), sizeof(label_string));\r\npango_layout_set_text(layout, label_string, -1);\r\npango_layout_get_pixel_size(layout, &lwidth, NULL);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_move_to (cr,\r\nLEFT_BORDER-length-lwidth-5,\r\nu_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset-(i-u_data->io->min_y)*u_data->io->y_interval-POINT_SIZE);\r\npango_cairo_show_layout (cr, layout);\r\ncairo_destroy (cr);\r\ncr = NULL;\r\n}\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_set_line_width (cr, 1.0);\r\ncairo_move_to(cr,\r\nLEFT_BORDER - length + 0.5,\r\nu_data->io->surface_height - BOTTOM_BORDER - u_data->io->offset - (i - u_data->io->min_y) * u_data->io->y_interval + 0.5);\r\ncairo_line_to(cr,\r\nLEFT_BORDER + 0.5,\r\nu_data->io->surface_height - BOTTOM_BORDER - u_data->io->offset - (i - u_data->io->min_y) * u_data->io->y_interval + 0.5);\r\ncairo_stroke(cr);\r\ncairo_destroy(cr);\r\n}\r\n}\r\n}\r\nelse if ((u_data->dir==1 && u_data->assoc->n_array_tsn1==0) || (u_data->dir==2 && u_data->assoc->n_array_tsn2==0))\r\nsimple_dialog(ESD_TYPE_INFO, ESD_BTN_OK, "No Data Chunks sent");\r\ng_object_unref(G_OBJECT(layout));\r\n}\r\nstatic void\r\nupdateLabels(void)\r\n{\r\nif (gIsSackChunkPresent && gIsNRSackChunkPresent)\r\n{\r\nsimple_dialog(ESD_TYPE_INFO, ESD_BTN_OK, "This data set contains both SACK and NR SACK PDUs.");\r\ngtk_button_set_label( (GtkButton*) sack_bt, "Show both Sack and NR Sack");\r\n}\r\nelse if (gIsSackChunkPresent)\r\ngtk_button_set_label( (GtkButton*) sack_bt, "Show Only Sack");\r\nelse\r\ngtk_button_set_label( (GtkButton*) sack_bt, "Show Only NR Sack");\r\n}\r\nstatic void\r\nsctp_graph_redraw(struct sctp_udata *u_data)\r\n{\r\nsctp_graph_t *ios;\r\nGtkAllocation widget_alloc;\r\ncairo_t *cr;\r\nu_data->io->needs_redraw=TRUE;\r\nsctp_graph_draw(u_data);\r\nswitch (u_data->io->graph_type)\r\n{\r\ncase 0:\r\ngIsSackChunkPresent = 0;\r\ngIsNRSackChunkPresent = 0;\r\ndraw_sack_graph(u_data);\r\ndraw_nr_sack_graph(u_data);\r\ndraw_tsn_graph(u_data);\r\nbreak;\r\ncase 1:\r\ndraw_tsn_graph(u_data);\r\nbreak;\r\ncase 2:\r\ngIsSackChunkPresent = 0;\r\ngIsNRSackChunkPresent = 0;\r\ndraw_sack_graph(u_data);\r\ndraw_nr_sack_graph(u_data);\r\nbreak;\r\n}\r\nupdateLabels();\r\nios=(sctp_graph_t *)g_object_get_data(G_OBJECT(u_data->io->draw_area), "sctp_graph_t");\r\ng_assert(ios != NULL);\r\ncr = gdk_cairo_create (gtk_widget_get_window(u_data->io->draw_area));\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncairo_set_source_surface (cr, ios->surface, 0, 0);\r\n#else\r\ngdk_cairo_set_source_pixmap (cr, ios->pixmap, 0, 0);\r\n#endif\r\ngtk_widget_get_allocation(u_data->io->draw_area, &widget_alloc);\r\ncairo_rectangle (cr, 0, 0, widget_alloc.width, widget_alloc.height);\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\n}\r\nstatic void\r\non_sack_bt(GtkWidget *widget _U_, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data = (struct sctp_udata *)user_data;\r\nu_data->io->graph_type=2;\r\nsctp_graph_redraw(u_data);\r\n}\r\nstatic void\r\non_tsn_bt(GtkWidget *widget _U_, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data = (struct sctp_udata *)user_data;\r\nu_data->io->graph_type=1;\r\nsctp_graph_redraw(u_data);\r\n}\r\nstatic void\r\non_both_bt(GtkWidget *widget _U_, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data = (struct sctp_udata *)user_data;\r\nu_data->io->graph_type=0;\r\nsctp_graph_redraw(u_data);\r\n}\r\nstatic void\r\nsctp_graph_close_cb(GtkWidget* widget _U_, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data = (struct sctp_udata *)user_data;\r\ngtk_grab_remove(GTK_WIDGET(u_data->io->window));\r\ngtk_widget_destroy(GTK_WIDGET(u_data->io->window));\r\n}\r\nstatic gboolean\r\nconfigure_event(GtkWidget *widget, GdkEventConfigure *event _U_, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data = (struct sctp_udata *)user_data;\r\nGtkAllocation widget_alloc;\r\ncairo_t *cr;\r\ng_assert(u_data->io != NULL);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\nif(u_data->io->surface){\r\ncairo_surface_destroy (u_data->io->surface);\r\nu_data->io->surface=NULL;\r\n}\r\ngtk_widget_get_allocation(widget, &widget_alloc);\r\nu_data->io->surface = gdk_window_create_similar_surface (gtk_widget_get_window(widget),\r\nCAIRO_CONTENT_COLOR,\r\nwidget_alloc.width,\r\nwidget_alloc.height);\r\n#else\r\nif(u_data->io->pixmap){\r\ng_object_unref(u_data->io->pixmap);\r\nu_data->io->pixmap=NULL;\r\n}\r\ngtk_widget_get_allocation(widget, &widget_alloc);\r\nu_data->io->pixmap=gdk_pixmap_new(gtk_widget_get_window(widget),\r\nwidget_alloc.width,\r\nwidget_alloc.height,\r\n-1);\r\n#endif\r\nu_data->io->surface_width=widget_alloc.width;\r\nu_data->io->surface_height=widget_alloc.height;\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_rectangle (cr, 0, 0, widget_alloc.width, widget_alloc.height);\r\ncairo_set_source_rgb (cr, 1, 1, 1);\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\nsctp_graph_redraw(u_data);\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\ndraw_event(GtkWidget *widget, cairo_t *cr, gpointer user_data)\r\n{\r\nsctp_graph_t *ios = (sctp_graph_t *)user_data;\r\nGtkAllocation allocation;\r\ngtk_widget_get_allocation (widget, &allocation);\r\ncairo_set_source_surface (cr, ios->surface, 0, 0);\r\ncairo_rectangle (cr, 0, 0, allocation.width, allocation.width);\r\ncairo_fill (cr);\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nexpose_event(GtkWidget *widget, GdkEventExpose *event, gpointer user_data)\r\n{\r\nsctp_graph_t *ios = (sctp_graph_t *)user_data;\r\ncairo_t *cr;\r\ng_assert(ios != NULL);\r\ncr = gdk_cairo_create (gtk_widget_get_window(widget));\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncairo_set_source_surface (cr, ios->surface, 0, 0);\r\n#else\r\ngdk_cairo_set_source_pixmap (cr, ios->pixmap, 0, 0);\r\n#endif\r\ncairo_rectangle (cr, event->area.x, event->area.y, event->area.width, event->area.height);\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\nreturn FALSE;\r\n}\r\nstatic void\r\non_zoomin_bt (GtkWidget *widget _U_, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data = (struct sctp_udata *)user_data;\r\nsctp_min_max_t *tmp_minmax;\r\nif (u_data->io->rectangle_present==TRUE)\r\n{\r\ntmp_minmax = (sctp_min_max_t *)g_malloc(sizeof(sctp_min_max_t));\r\nu_data->io->tmp_min_tsn1=u_data->io->y1_tmp+u_data->io->min_y;\r\nu_data->io->tmp_max_tsn1=u_data->io->y2_tmp+1+u_data->io->min_y;\r\nu_data->io->tmp_min_tsn2=u_data->io->tmp_min_tsn1;\r\nu_data->io->tmp_max_tsn2=u_data->io->tmp_max_tsn1;\r\ntmp_minmax->tmp_min_secs=u_data->io->x1_tmp_sec;\r\ntmp_minmax->tmp_min_usecs= u_data->io->x1_tmp_usec;\r\ntmp_minmax->tmp_max_secs= u_data->io->x2_tmp_sec;\r\ntmp_minmax->tmp_max_usecs= u_data->io->x2_tmp_usec;\r\ntmp_minmax->tmp_min_tsn1=u_data->io->tmp_min_tsn1;\r\ntmp_minmax->tmp_max_tsn1=u_data->io->tmp_max_tsn1;\r\ntmp_minmax->tmp_min_tsn2=u_data->io->tmp_min_tsn2;\r\ntmp_minmax->tmp_max_tsn2=u_data->io->tmp_max_tsn2;\r\nu_data->assoc->min_max = g_slist_prepend(u_data->assoc->min_max, tmp_minmax);\r\nu_data->io->length = g_slist_length(u_data->assoc->min_max);\r\nu_data->io->tmp=TRUE;\r\nu_data->io->rectangle=FALSE;\r\nu_data->io->rectangle_present=FALSE;\r\ngtk_widget_set_sensitive(zoomout_bt, TRUE);\r\nsctp_graph_redraw(u_data);\r\n}\r\nelse\r\n{\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "Please draw a rectangle around the area you want to zoom in.");\r\n}\r\n}\r\nstatic void\r\nzoomin_bt_fcn (struct sctp_udata *u_data)\r\n{\r\nsctp_min_max_t *tmp_minmax;\r\ntmp_minmax = (sctp_min_max_t *)g_malloc(sizeof(sctp_min_max_t));\r\nu_data->io->tmp_min_tsn1=u_data->io->y1_tmp+u_data->io->min_y;\r\nu_data->io->tmp_max_tsn1=u_data->io->y2_tmp+1+u_data->io->min_y;\r\nu_data->io->tmp_min_tsn2=u_data->io->tmp_min_tsn1;\r\nu_data->io->tmp_max_tsn2=u_data->io->tmp_max_tsn1;\r\ntmp_minmax->tmp_min_secs=u_data->io->x1_tmp_sec;\r\ntmp_minmax->tmp_min_usecs= u_data->io->x1_tmp_usec;\r\ntmp_minmax->tmp_max_secs= u_data->io->x2_tmp_sec;\r\ntmp_minmax->tmp_max_usecs= u_data->io->x2_tmp_usec;\r\ntmp_minmax->tmp_min_tsn1=u_data->io->tmp_min_tsn1;\r\ntmp_minmax->tmp_max_tsn1=u_data->io->tmp_max_tsn1;\r\ntmp_minmax->tmp_min_tsn2=u_data->io->tmp_min_tsn2;\r\ntmp_minmax->tmp_max_tsn2=u_data->io->tmp_max_tsn2;\r\nu_data->assoc->min_max = g_slist_prepend(u_data->assoc->min_max, tmp_minmax);\r\nu_data->io->length = g_slist_length(u_data->assoc->min_max);\r\nu_data->io->tmp=TRUE;\r\nu_data->io->rectangle=FALSE;\r\nu_data->io->rectangle_present=FALSE;\r\ngtk_widget_set_sensitive(zoomout_bt, TRUE);\r\nsctp_graph_redraw(u_data);\r\n}\r\nstatic void\r\non_zoomout_bt (GtkWidget *widget _U_, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data = (struct sctp_udata *)user_data;\r\nsctp_min_max_t *tmp_minmax, *mm;\r\ngint l;\r\nl = g_slist_length(u_data->assoc->min_max);\r\nif (u_data->assoc->min_max!=NULL)\r\n{\r\nmm=(sctp_min_max_t *)((u_data->assoc->min_max)->data);\r\nu_data->assoc->min_max=g_slist_remove(u_data->assoc->min_max, mm);\r\ng_free(mm);\r\nif (l>2)\r\n{\r\ntmp_minmax = (sctp_min_max_t *)u_data->assoc->min_max->data;\r\nu_data->io->x1_tmp_sec=tmp_minmax->tmp_min_secs;\r\nu_data->io->x1_tmp_usec=tmp_minmax->tmp_min_usecs;\r\nu_data->io->x2_tmp_sec=tmp_minmax->tmp_max_secs;\r\nu_data->io->x2_tmp_usec=tmp_minmax->tmp_max_usecs;\r\nu_data->io->tmp_min_tsn1=tmp_minmax->tmp_min_tsn1;\r\nu_data->io->tmp_max_tsn1=tmp_minmax->tmp_max_tsn1;\r\nu_data->io->tmp_min_tsn2=tmp_minmax->tmp_min_tsn2;\r\nu_data->io->tmp_max_tsn2=tmp_minmax->tmp_max_tsn2;\r\nu_data->io->tmp=TRUE;\r\n}\r\nelse\r\n{\r\nu_data->io->x1_tmp_sec=u_data->assoc->min_secs;\r\nu_data->io->x1_tmp_usec=u_data->assoc->min_usecs;\r\nu_data->io->x2_tmp_sec=u_data->assoc->max_secs;\r\nu_data->io->x2_tmp_usec=u_data->assoc->max_usecs;\r\nu_data->io->tmp_min_tsn1=u_data->assoc->min_tsn1;\r\nu_data->io->tmp_max_tsn1=u_data->assoc->max_tsn1;\r\nu_data->io->tmp_min_tsn2=u_data->assoc->min_tsn2;\r\nu_data->io->tmp_max_tsn2=u_data->assoc->max_tsn2;\r\nu_data->io->tmp=FALSE;\r\n}\r\n}\r\nelse\r\n{\r\nu_data->io->x1_tmp_sec=u_data->assoc->min_secs;\r\nu_data->io->x1_tmp_usec=u_data->assoc->min_usecs;\r\nu_data->io->x2_tmp_sec=u_data->assoc->max_secs;\r\nu_data->io->x2_tmp_usec=u_data->assoc->max_usecs;\r\nu_data->io->tmp_min_tsn1=u_data->assoc->min_tsn1;\r\nu_data->io->tmp_max_tsn1=u_data->assoc->max_tsn1;\r\nu_data->io->tmp_min_tsn2=u_data->assoc->min_tsn2;\r\nu_data->io->tmp_max_tsn2=u_data->assoc->max_tsn2;\r\nu_data->io->tmp=FALSE;\r\n}\r\nif (g_slist_length(u_data->assoc->min_max)==1)\r\ngtk_widget_set_sensitive(zoomout_bt, FALSE);\r\nsctp_graph_redraw(u_data);\r\n}\r\nstatic gboolean\r\non_button_press_event (GtkWidget *widget _U_, GdkEventButton *event, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data = (struct sctp_udata *)user_data;\r\nsctp_graph_t *ios;\r\ncairo_t *cr;\r\nif (u_data->io->rectangle==TRUE)\r\n{\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_rectangle (cr,\r\nfloor(MIN(u_data->io->x_old,u_data->io->x_new)),\r\nfloor(MIN(u_data->io->y_old,u_data->io->y_new)),\r\nfloor(abs((int)(u_data->io->x_new-u_data->io->x_old))),\r\nfloor(abs((int)(u_data->io->y_new-u_data->io->y_old))));\r\ncairo_set_source_rgb (cr, 1, 1, 1);\r\ncairo_stroke (cr);\r\ncairo_destroy (cr);\r\nios=(sctp_graph_t *)g_object_get_data(G_OBJECT(u_data->io->draw_area), "sctp_graph_t");\r\ng_assert(ios != NULL);\r\ncr = gdk_cairo_create (gtk_widget_get_window(u_data->io->draw_area));\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncairo_set_source_surface (cr, ios->surface, 0, 0);\r\n#else\r\ngdk_cairo_set_source_pixmap (cr, ios->pixmap, 0, 0);\r\n#endif\r\ncairo_rectangle (cr, 0, 0, abs((int)(u_data->io->x_new-u_data->io->x_old)), abs((int)(u_data->io->y_new-u_data->io->y_old)));\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\nsctp_graph_redraw(u_data);\r\n}\r\nu_data->io->x_old=event->x;\r\nu_data->io->y_old=event->y;\r\nif (u_data->io->y_old>u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset-POINT_SIZE)\r\nu_data->io->y_old=u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset-POINT_SIZE;\r\nif (u_data->io->x_old<LEFT_BORDER+u_data->io->offset)\r\nu_data->io->x_old=LEFT_BORDER+u_data->io->offset;\r\nu_data->io->rectangle=FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\non_button_release_event (GtkWidget *widget _U_, GdkEventButton *event, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data = (struct sctp_udata *)user_data;\r\nsctp_graph_t *ios;\r\nguint32 helpx, helpy, x1_tmp, x2_tmp, y_value, t_size=0, s_size=0, i, y_tolerance;\r\ngint label_width, label_height;\r\ngdouble x_value, position, s_diff=0, t_diff=0, x_tolerance=0.0001;\r\ngint lwidth;\r\nchar label_string[30];\r\nGPtrArray *tsnlist = NULL, *sacklist=NULL;\r\nstruct tsn_sort *tsn, *sack=NULL;\r\ngboolean sack_found = FALSE;\r\nGtkAllocation widget_alloc;\r\nPangoLayout *layout;\r\ncairo_t *cr;\r\ng_snprintf(label_string, 15, "%d", 0);\r\nmemcpy(label_string,(gchar *)g_locale_to_utf8(label_string, -1 , NULL, NULL, NULL), 15);\r\nlayout = gtk_widget_create_pango_layout(u_data->io->draw_area, label_string);\r\npango_layout_get_pixel_size(layout, &label_width, &label_height);\r\nif (event->y>u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset)\r\nevent->y = u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset;\r\nif (event->x < LEFT_BORDER+u_data->io->offset)\r\nevent->x = LEFT_BORDER+u_data->io->offset;\r\nif (abs((int)(event->x-u_data->io->x_old))>10 || abs((int)(event->y-u_data->io->y_old))>10)\r\n{\r\nu_data->io->rect_x_min = (gint)floor(MIN(u_data->io->x_old,event->x));\r\nu_data->io->rect_x_max = (gint)ceil(MAX(u_data->io->x_old,event->x));\r\nu_data->io->rect_y_min = (gint)floor(MIN(u_data->io->y_old,event->y));\r\nu_data->io->rect_y_max = (gint)ceil(MAX(u_data->io->y_old,event->y))+POINT_SIZE;\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_rectangle (cr,\r\nu_data->io->rect_x_min+0.5,\r\nu_data->io->rect_y_min+0.5,\r\nu_data->io->rect_x_max - u_data->io->rect_x_min,\r\nu_data->io->rect_y_max - u_data->io->rect_y_min);\r\ncairo_set_line_width (cr, 1.0);\r\ncairo_stroke (cr);\r\ncairo_destroy (cr);\r\nios=(sctp_graph_t *)g_object_get_data(G_OBJECT(u_data->io->draw_area), "sctp_graph_t");\r\ng_assert(ios != NULL);\r\ncr = gdk_cairo_create (gtk_widget_get_window(u_data->io->draw_area));\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncairo_set_source_surface (cr, ios->surface, 0, 0);\r\n#else\r\ngdk_cairo_set_source_pixmap (cr, ios->pixmap, 0, 0);\r\n#endif\r\ngtk_widget_get_allocation(u_data->io->draw_area, &widget_alloc);\r\ncairo_rectangle (cr, 0, 0, widget_alloc.width, widget_alloc.height);\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\nx1_tmp=(unsigned int)floor(u_data->io->min_x+((u_data->io->x_old-LEFT_BORDER-u_data->io->offset)*u_data->io->tmp_width/u_data->io->axis_width));\r\nx2_tmp=(unsigned int)floor(u_data->io->min_x+((event->x-LEFT_BORDER-u_data->io->offset)*u_data->io->tmp_width/u_data->io->axis_width));\r\nhelpx=MIN(x1_tmp, x2_tmp);\r\nif (helpx==x2_tmp)\r\n{\r\nx2_tmp=x1_tmp;\r\nx1_tmp=helpx;\r\n}\r\nif (u_data->io->uoff)\r\n{\r\nif (x2_tmp - x1_tmp <= 1500)\r\nu_data->io->uoff = FALSE;\r\nu_data->io->x1_tmp_sec=(guint32)x1_tmp;\r\nu_data->io->x1_tmp_usec=0;\r\nu_data->io->x2_tmp_sec=(guint32)x2_tmp;\r\nu_data->io->x2_tmp_usec=0;\r\n}\r\nelse\r\n{\r\nu_data->io->x1_tmp_sec=(guint32)x1_tmp/1000000;\r\nu_data->io->x1_tmp_usec=x1_tmp%1000000;\r\nu_data->io->x2_tmp_sec=(guint32)x2_tmp/1000000;\r\nu_data->io->x2_tmp_usec=x2_tmp%1000000;\r\n}\r\nu_data->io->x1_akt_sec = u_data->io->x1_tmp_sec;\r\nu_data->io->x1_akt_usec = u_data->io->x1_tmp_usec;\r\nu_data->io->x2_akt_sec = u_data->io->x2_tmp_sec;\r\nu_data->io->x2_akt_usec = u_data->io->x2_tmp_usec;\r\nu_data->io->y1_tmp=(guint32)((u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset-u_data->io->y_old)/u_data->io->y_interval);\r\nu_data->io->y2_tmp=(guint32)((u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset-event->y)/u_data->io->y_interval);\r\nhelpy = MIN(u_data->io->y1_tmp, u_data->io->y2_tmp);\r\nu_data->io->y2_tmp = MAX(u_data->io->y1_tmp, u_data->io->y2_tmp);\r\nu_data->io->y1_tmp = helpy;\r\nu_data->io->x_new=event->x;\r\nu_data->io->y_new=event->y;\r\nu_data->io->rectangle=TRUE;\r\nu_data->io->rectangle_present=TRUE;\r\n}\r\nelse\r\n{\r\nif (u_data->io->rectangle_present==TRUE)\r\n{\r\nu_data->io->rectangle_present=FALSE;\r\nif (event->x >= u_data->io->rect_x_min && event->x <= u_data->io->rect_x_max &&\r\nevent->y >= u_data->io->rect_y_min && event->y <= u_data->io->rect_y_max)\r\nzoomin_bt_fcn(u_data);\r\nelse\r\n{\r\nu_data->io->x1_tmp_sec = u_data->io->x1_akt_sec;\r\nu_data->io->x1_tmp_usec = u_data->io->x1_akt_usec;\r\nu_data->io->x2_tmp_sec = u_data->io->x2_akt_sec;\r\nu_data->io->x2_tmp_usec = u_data->io->x2_akt_usec;\r\nsctp_graph_redraw(u_data);\r\n}\r\n}\r\nelse if (label_set)\r\n{\r\nlabel_set = FALSE;\r\nsctp_graph_redraw(u_data);\r\n}\r\nelse\r\n{\r\nx_value = ((event->x-LEFT_BORDER-u_data->io->offset) * ((u_data->io->x2_tmp_sec+u_data->io->x2_tmp_usec/1000000.0)-(u_data->io->x1_tmp_sec+u_data->io->x1_tmp_usec/1000000.0)) / (u_data->io->surface_width-LEFT_BORDER-RIGHT_BORDER-u_data->io->offset))+u_data->io->x1_tmp_sec+u_data->io->x1_tmp_usec/1000000.0;\r\ny_value = (gint)rint((u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset-event->y) * (max_tsn - min_tsn) / (u_data->io->surface_height-BOTTOM_BORDER-u_data->io->offset)) + min_tsn;\r\nif (u_data->dir == 1)\r\n{\r\ntsnlist = u_data->assoc->sort_tsn1;\r\nt_size = u_data->assoc->n_data_chunks_ep1;\r\nsacklist = u_data->assoc->sort_sack1;\r\ns_size = u_data->assoc->n_sack_chunks_ep1;\r\n}\r\nelse\r\n{\r\ntsnlist = u_data->assoc->sort_tsn2;\r\nt_size = u_data->assoc->n_data_chunks_ep2;\r\nsacklist = u_data->assoc->sort_sack2;\r\ns_size = u_data->assoc->n_sack_chunks_ep2;\r\n}\r\nx_tolerance = (gdouble)((u_data->io->tmp_width / u_data->io->axis_width*1.0))*5/1000000.0;\r\ny_tolerance = (guint32)(((u_data->io->max_y - u_data->io->min_y) / (u_data->io->surface_height-TOP_BORDER-BOTTOM_BORDER-u_data->io->offset)) * 2.0);\r\nif (y_tolerance==0)\r\ny_tolerance = 2;\r\nelse if (y_tolerance > 5)\r\ny_tolerance = 5;\r\nfor (i=0; i<s_size; i++)\r\n{\r\nsack = (struct tsn_sort*)(g_ptr_array_index(sacklist, i));\r\nif ((guint32)(sack->tsnumber - y_value)<y_tolerance)\r\n{\r\ns_diff = fabs((sack->secs+sack->usecs/1000000.0)- x_value);\r\nif (s_diff < x_tolerance)\r\nsack_found = TRUE;\r\nbreak;\r\n}\r\n}\r\nfor (i=0; i<t_size; i++)\r\n{\r\ntsn = (struct tsn_sort*)(g_ptr_array_index(tsnlist, i));\r\nif ((guint32)(tsn->tsnumber - y_value)<y_tolerance)\r\n{\r\nt_diff = fabs((tsn->secs+tsn->usecs/1000000.0)- x_value);\r\nif (sack_found && s_diff < t_diff)\r\n{\r\ncf_goto_frame(&cfile, sack->framenumber);\r\nx_value = sack->secs+sack->usecs/1000000.0;\r\ny_value = sack->tsnumber;\r\n}\r\nelse if (t_diff < x_tolerance)\r\n{\r\ncf_goto_frame(&cfile, tsn->framenumber);\r\nx_value = tsn->secs+tsn->usecs/1000000.0;\r\ny_value = tsn->tsnumber;\r\n}\r\nbreak;\r\n}\r\n}\r\ng_snprintf(label_string, sizeof(label_string), "(%.6lf, %u)", x_value, y_value);\r\nlabel_set = TRUE;\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_set_line_width (cr, 1.0);\r\ncairo_move_to(cr,\r\n(event->x-2)+0.5,\r\n(event->y)+0.5);\r\ncairo_line_to(cr,\r\n(event->x+2)+0.5,\r\n(event->y)+0.5);\r\ncairo_stroke(cr);\r\ncairo_destroy(cr);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_set_line_width (cr, 1.0);\r\ncairo_move_to(cr,\r\n(event->x)+0.5,\r\n(event->y-2)+0.5);\r\ncairo_line_to(cr,\r\n(event->x)+0.5,\r\n(event->y+2)+0.5);\r\ncairo_stroke(cr);\r\ncairo_destroy(cr);\r\nif (event->x+150>=u_data->io->surface_width)\r\nposition = event->x - 150;\r\nelse\r\nposition = event->x + 5;\r\nmemcpy(label_string,(gchar *)g_locale_to_utf8(label_string, -1 , NULL, NULL, NULL), 15);\r\npango_layout_set_text(layout, label_string, -1);\r\npango_layout_get_pixel_size(layout, &lwidth, NULL);\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncr = cairo_create (u_data->io->surface);\r\n#else\r\ncr = gdk_cairo_create (u_data->io->pixmap);\r\n#endif\r\ncairo_move_to (cr,\r\nposition,\r\nevent->y-10);\r\npango_cairo_show_layout (cr, layout);\r\ncairo_destroy (cr);\r\ncr = NULL;\r\nios=(sctp_graph_t *)g_object_get_data(G_OBJECT(u_data->io->draw_area), "sctp_graph_t");\r\ng_assert(ios != NULL);\r\ncr = gdk_cairo_create (gtk_widget_get_window(u_data->io->draw_area));\r\n#if GTK_CHECK_VERSION(2,22,0)\r\ncairo_set_source_surface (cr, ios->surface, 0, 0);\r\n#else\r\ngdk_cairo_set_source_pixmap (cr, ios->pixmap, 0, 0);\r\n#endif\r\ngtk_widget_get_allocation(u_data->io->draw_area, &widget_alloc);\r\ncairo_rectangle (cr, 0, 0, widget_alloc.width, widget_alloc.height);\r\ncairo_fill (cr);\r\ncairo_destroy (cr);\r\n}\r\n}\r\ng_object_unref(G_OBJECT(layout));\r\nreturn TRUE;\r\n}\r\nstatic void\r\ninit_sctp_graph_window(struct sctp_udata *u_data)\r\n{\r\nGtkWidget *vbox;\r\nGtkWidget *hbox;\r\nGtkWidget *bt_close, *tsn_bt, *both_bt, *zoomin_bt;\r\nu_data->io->window= dlg_window_new("WSCTP Graphics");\r\ngtk_window_set_destroy_with_parent (GTK_WINDOW(u_data->io->window), TRUE);\r\nvbox=ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 0, FALSE);\r\ngtk_container_add(GTK_CONTAINER(u_data->io->window), vbox);\r\ngtk_widget_show(vbox);\r\ncreate_draw_area(vbox, u_data);\r\nsctp_graph_set_title(u_data);\r\nhbox = gtk_button_box_new(GTK_ORIENTATION_HORIZONTAL);\r\ngtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\r\ngtk_container_set_border_width(GTK_CONTAINER(hbox), 10);\r\ngtk_button_box_set_layout(GTK_BUTTON_BOX (hbox), GTK_BUTTONBOX_SPREAD);\r\ngtk_box_set_spacing(GTK_BOX (hbox), 0);\r\ngtk_widget_show(hbox);\r\nsack_bt = gtk_button_new_with_label ("Show Only Sacks");\r\ngtk_box_pack_start(GTK_BOX(hbox), sack_bt, FALSE, FALSE, 0);\r\ngtk_widget_show(sack_bt);\r\ng_signal_connect(sack_bt, "clicked", G_CALLBACK(on_sack_bt), u_data);\r\ntsn_bt = gtk_button_new_with_label ("Show Only TSNs");\r\ngtk_box_pack_start(GTK_BOX(hbox), tsn_bt, FALSE, FALSE, 0);\r\ngtk_widget_show(tsn_bt);\r\ng_signal_connect(tsn_bt, "clicked", G_CALLBACK(on_tsn_bt), u_data);\r\nboth_bt = gtk_button_new_with_label ("Show both");\r\ngtk_box_pack_start(GTK_BOX(hbox), both_bt, FALSE, FALSE, 0);\r\ngtk_widget_show(both_bt);\r\ng_signal_connect(both_bt, "clicked", G_CALLBACK(on_both_bt), u_data);\r\nzoomin_bt = gtk_button_new_with_label ("Zoom in");\r\ngtk_box_pack_start(GTK_BOX(hbox), zoomin_bt, FALSE, FALSE, 0);\r\ngtk_widget_show(zoomin_bt);\r\ng_signal_connect(zoomin_bt, "clicked", G_CALLBACK(on_zoomin_bt), u_data);\r\ngtk_widget_set_tooltip_text(zoomin_bt, "Zoom in the area you have selected");\r\nzoomout_bt = gtk_button_new_with_label ("Zoom out");\r\ngtk_box_pack_start(GTK_BOX(hbox), zoomout_bt, FALSE, FALSE, 0);\r\ngtk_widget_show(zoomout_bt);\r\ng_signal_connect(zoomout_bt, "clicked", G_CALLBACK(on_zoomout_bt), u_data);\r\ngtk_widget_set_tooltip_text(zoomout_bt, "Zoom out one step");\r\ngtk_widget_set_sensitive(zoomout_bt, FALSE);\r\nbt_close = ws_gtk_button_new_from_stock(GTK_STOCK_CLOSE);\r\ngtk_box_pack_start(GTK_BOX(hbox), bt_close, FALSE, FALSE, 0);\r\ngtk_widget_show(bt_close);\r\ng_signal_connect(bt_close, "clicked", G_CALLBACK(sctp_graph_close_cb), u_data);\r\ng_signal_connect(u_data->io->draw_area,"button_press_event",G_CALLBACK(on_button_press_event), u_data);\r\ng_signal_connect(u_data->io->draw_area,"button_release_event",G_CALLBACK(on_button_release_event), u_data);\r\ngtk_widget_set_events(u_data->io->draw_area, GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_EXPOSURE_MASK);\r\ngtk_widget_show(u_data->io->window);\r\n}\r\nstatic void\r\nsctp_graph_set_title(struct sctp_udata *u_data)\r\n{\r\nchar *display_name;\r\nchar *title;\r\nif(!u_data->io->window)\r\n{\r\nreturn;\r\n}\r\ndisplay_name = cf_get_display_name(&cfile);\r\ntitle = g_strdup_printf("SCTP TSNs and Sacks over Time: %s Port1 %u Port2 %u Endpoint %u",\r\ndisplay_name, u_data->parent->assoc->port1, u_data->parent->assoc->port2, u_data->dir);\r\ng_free(display_name);\r\ngtk_window_set_title(GTK_WINDOW(u_data->io->window), title);\r\ng_free(title);\r\n}\r\nstatic void\r\ngtk_sctpgraph_init(struct sctp_udata *u_data)\r\n{\r\nsctp_graph_t *io;\r\nsctp_min_max_t* tmp_minmax;\r\nio=(sctp_graph_t *)g_malloc(sizeof(sctp_graph_t));\r\nio->needs_redraw=TRUE;\r\nio->x_interval=1000;\r\nio->window=NULL;\r\nio->draw_area=NULL;\r\n#if GTK_CHECK_VERSION(2,22,0)\r\nio->surface=NULL;\r\n#else\r\nio->pixmap=NULL;\r\n#endif\r\nio->surface_width=800;\r\nio->surface_height=600;\r\nio->graph_type=0;\r\nu_data->io=io;\r\nu_data->io->x1_tmp_sec=u_data->assoc->min_secs;\r\nu_data->io->x1_tmp_usec=u_data->assoc->min_usecs;\r\nu_data->io->x2_tmp_sec=u_data->assoc->max_secs;\r\nu_data->io->x2_tmp_usec=u_data->assoc->max_usecs;\r\nu_data->io->tmp_min_tsn1=u_data->assoc->min_tsn1;\r\nu_data->io->tmp_max_tsn1=u_data->assoc->max_tsn1;\r\nu_data->io->tmp_min_tsn2=u_data->assoc->min_tsn2;\r\nu_data->io->tmp_max_tsn2=u_data->assoc->max_tsn2;\r\nu_data->io->tmp=FALSE;\r\ntmp_minmax = (sctp_min_max_t *)g_malloc(sizeof(sctp_min_max_t));\r\ntmp_minmax->tmp_min_secs = u_data->assoc->min_secs;\r\ntmp_minmax->tmp_min_usecs=u_data->assoc->min_usecs;\r\ntmp_minmax->tmp_max_secs=u_data->assoc->max_secs;\r\ntmp_minmax->tmp_max_usecs=u_data->assoc->max_usecs;\r\ntmp_minmax->tmp_min_tsn2=u_data->assoc->min_tsn2;\r\ntmp_minmax->tmp_min_tsn1=u_data->assoc->min_tsn1;\r\ntmp_minmax->tmp_max_tsn1=u_data->assoc->max_tsn1;\r\ntmp_minmax->tmp_max_tsn2=u_data->assoc->max_tsn2;\r\nu_data->assoc->min_max = g_slist_prepend(u_data->assoc->min_max, tmp_minmax);\r\ninit_sctp_graph_window(u_data);\r\nsctp_graph_redraw(u_data);\r\n}\r\nstatic void\r\nquit(GObject *object _U_, gpointer user_data)\r\n{\r\nstruct sctp_udata *u_data=(struct sctp_udata *)user_data;\r\ndecrease_childcount(u_data->parent);\r\nremove_child(u_data, u_data->parent);\r\ng_free(u_data->io);\r\nu_data->assoc->min_max = NULL;\r\ng_free(u_data);\r\n}\r\nstatic void\r\ncreate_draw_area(GtkWidget *box, struct sctp_udata *u_data)\r\n{\r\nu_data->io->draw_area=gtk_drawing_area_new();\r\ng_object_set_data(G_OBJECT(u_data->io->draw_area), "sctp_graph_t", u_data->io);\r\ng_signal_connect(u_data->io->draw_area, "destroy", G_CALLBACK(quit), u_data);\r\ngtk_widget_set_size_request(u_data->io->draw_area, u_data->io->surface_width, u_data->io->surface_height);\r\n#if GTK_CHECK_VERSION(3,0,0)\r\ng_signal_connect(u_data->io->draw_area, "draw", G_CALLBACK(draw_event), u_data->io);\r\n#else\r\ng_signal_connect(u_data->io->draw_area, "expose_event", G_CALLBACK(expose_event), u_data->io);\r\n#endif\r\ng_signal_connect(u_data->io->draw_area, "configure_event", G_CALLBACK(configure_event), u_data);\r\ngtk_widget_show(u_data->io->draw_area);\r\ngtk_box_pack_start(GTK_BOX(box), u_data->io->draw_area, TRUE, TRUE, 0);\r\n}\r\nvoid\r\ncreate_graph(guint16 dir, struct sctp_analyse* userdata)\r\n{\r\nstruct sctp_udata *u_data;\r\nu_data=(struct sctp_udata *)g_malloc(sizeof(struct sctp_udata));\r\nu_data->assoc=userdata->assoc;\r\nu_data->io=NULL;\r\nu_data->dir = dir;\r\nu_data->parent = userdata;\r\nif ((u_data->dir==1 && u_data->assoc->n_array_tsn1==0)|| (u_data->dir==2 && u_data->assoc->n_array_tsn2==0))\r\nsimple_dialog(ESD_TYPE_INFO, ESD_BTN_OK, "No Data Chunks sent");\r\nelse\r\n{\r\nset_child(u_data, u_data->parent);\r\nincrease_childcount(u_data->parent);\r\ngtk_sctpgraph_init(u_data);\r\n}\r\n}\r\nstatic int\r\nrint (double x)\r\n{\r\nchar *buf;\r\nint i,dec,sig;\r\nbuf = _fcvt(x, 0, &dec, &sig);\r\ni = atoi(buf);\r\nif(sig == 1) {\r\ni = i * -1;\r\n}\r\nreturn(i);\r\n}
