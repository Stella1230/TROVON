static gboolean\r\ndissect_mpeg_audio_frame(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint32 h;\r\nstruct mpa mpa;\r\nint data_size = 0;\r\nasn1_ctx_t asn1_ctx;\r\nint offset = 0;\r\nstatic const char *version_names[] = { "1", "2", "2.5" };\r\nif (!tvb_bytes_exist(tvb, 0, 4))\r\nreturn FALSE;\r\nh = tvb_get_ntohl(tvb, 0);\r\nMPA_UNMARSHAL(&mpa, h);\r\nif (!MPA_SYNC_VALID(&mpa))\r\nreturn FALSE;\r\nif (!MPA_VERSION_VALID(&mpa))\r\nreturn FALSE;\r\nif (!MPA_LAYER_VALID(&mpa))\r\nreturn FALSE;\r\ncol_add_fstr(pinfo->cinfo, COL_PROTOCOL,\r\n"MPEG-%s", version_names[mpa_version(&mpa)]);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"Audio Layer %d", mpa_layer(&mpa) + 1);\r\nif (MPA_BITRATE_VALID(&mpa) && MPA_FREQUENCY_VALID(&mpa)) {\r\ndata_size = (int)(MPA_DATA_BYTES(&mpa) - sizeof mpa);\r\nSET_ADDRESS(&pinfo->src, AT_NONE, 0, NULL);\r\ncol_add_fstr(pinfo->cinfo, COL_DEF_SRC,\r\n"%d kb/s", mpa_bitrate(&mpa) / 1000);\r\nSET_ADDRESS(&pinfo->dst, AT_NONE, 0, NULL);\r\ncol_add_fstr(pinfo->cinfo, COL_DEF_DST,\r\n"%g kHz", mpa_frequency(&mpa) / (float)1000);\r\n}\r\nif (tree == NULL)\r\nreturn TRUE;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_PER, TRUE, pinfo);\r\noffset = dissect_mpeg_audio_Audio(tvb, offset, &asn1_ctx,\r\ntree, proto_mpeg_audio);\r\nif (data_size > 0) {\r\nunsigned int padding;\r\nproto_tree_add_item(tree, hf_mpeg_audio_data, tvb,\r\noffset / 8, data_size, ENC_NA);\r\noffset += data_size * 8;\r\npadding = mpa_padding(&mpa);\r\nif (padding > 0) {\r\nproto_tree_add_item(tree, hf_mpeg_audio_padbytes, tvb,\r\noffset / 8, padding, ENC_NA);\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void\r\ndissect_id3v1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nasn1_ctx_t asn1_ctx;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ID3v1");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree == NULL)\r\nreturn;\r\nasn1_ctx_init(&asn1_ctx, ASN1_ENC_PER, TRUE, pinfo);\r\ndissect_mpeg_audio_ID3v1(tvb, 0, &asn1_ctx,\r\ntree, hf_id3v1);\r\n}\r\nstatic void\r\ndissect_id3v2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "ID3v2");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nproto_tree_add_item(tree, hf_id3v2, tvb,\r\n0, -1, ENC_NA);\r\n}\r\nstatic gboolean\r\ndissect_mpeg_audio(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nint magic;\r\nif (!tvb_bytes_exist(tvb, 0, 3))\r\nreturn FALSE;\r\nmagic = tvb_get_ntoh24(tvb, 0);\r\nswitch (magic) {\r\ncase 0x544147:\r\ndissect_id3v1(tvb, pinfo, tree);\r\nreturn TRUE;\r\ncase 0x494433:\r\ndissect_id3v2(tvb, pinfo, tree);\r\nreturn TRUE;\r\ndefault:\r\nreturn dissect_mpeg_audio_frame(tvb, pinfo, tree);\r\n}\r\n}\r\nvoid\r\nproto_register_mpeg_audio(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n#include "packet-mpeg-audio-hfarr.c"\r\n{ &hf_mpeg_audio_data,\r\n{ "Data", "mpeg-audio.data",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_mpeg_audio_padbytes,\r\n{ "Padding", "mpeg-audio.padbytes",\r\nFT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_id3v1,\r\n{ "ID3v1", "mpeg-audio.id3v1",\r\nFT_NONE, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n{ &hf_id3v2,\r\n{ "ID3v2", "mpeg-audio.id3v2",\r\nFT_NONE, BASE_NONE, NULL, 0, NULL, HFILL }},\r\n};\r\nstatic gint *ett[] = {\r\n#include "packet-mpeg-audio-ettarr.c"\r\n};\r\nproto_mpeg_audio = proto_register_protocol(\r\n"Moving Picture Experts Group Audio", "MPEG Audio", "mpeg-audio");\r\nproto_register_field_array(proto_mpeg_audio, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_mpeg_audio(void)\r\n{\r\nheur_dissector_add("mpeg", dissect_mpeg_audio, proto_mpeg_audio);\r\n}
