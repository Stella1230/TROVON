static int\r\ndissect_cpha(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nint offset = 0;\r\nproto_item * ti;\r\nproto_item * nti;\r\nproto_tree * cpha_tree = NULL;\r\nproto_tree * ntree = NULL;\r\nguint16 opcode;\r\nguint16 magic_number;\r\nguint16 ha_version;\r\nif (tvb_length(tvb) < 4) {\r\nreturn 0;\r\n}\r\nmagic_number = tvb_get_ntohs(tvb, 0);\r\nha_version = tvb_get_ntohs(tvb, 2);\r\nif (magic_number != CPHA_MAGIC) {\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CPHA");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nopcode = tvb_get_ntohs(tvb, 6);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "CPHAv%d: %s",\r\nha_version, val_to_str(opcode, opcode_type_vals, "Unknown %d"));\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_cphap, tvb, offset, -1, ENC_NA);\r\ncpha_tree = proto_item_add_subtree(ti, ett_cphap);\r\n}\r\nif (tree) {\r\nproto_tree_add_item(cpha_tree, hf_magic_number, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cpha_tree, hf_cpha_protocol_ver, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cpha_tree, hf_cluster_number, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cpha_tree, hf_opcode, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cpha_tree, hf_src_if_num, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cpha_tree, hf_random_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cpha_tree, hf_src_machine_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cpha_tree, hf_dst_machine_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif(ha_version != 1) {\r\nproto_tree_add_item(cpha_tree, hf_policy_id, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cpha_tree, hf_filler, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nnti = proto_tree_add_item(cpha_tree, hf_payload, tvb, offset, -1, ENC_NA);\r\nproto_item_append_text(nti, " - %s", val_to_str(opcode, opcode_type_vals, "Unknown %d"));\r\nntree = proto_item_add_subtree(nti, ett_cphap);\r\nswitch(opcode) {\r\ncase 1: dissect_my_state(tvb, offset, ntree);\r\nbreak;\r\ncase 2: break;\r\ncase 3:\r\ncase 4: dissect_probe(tvb, offset, ntree);\r\nbreak;\r\ncase 5: break;\r\ncase 6: dissect_conf_reply(tvb, offset, ntree);\r\nbreak;\r\ncase 7: dissect_lb_conf(tvb, offset, ntree);\r\nbreak;\r\ncase 9: dissect_policy_change(tvb, offset, ntree);\r\nbreak;\r\ndefault: break;\r\n}\r\n}\r\nreturn tvb_length(tvb);\r\n}\r\nstatic int dissect_my_state(tvbuff_t * tvb, int offset, proto_tree * tree) {\r\nint i;\r\nproto_item * nti = NULL;\r\nproto_tree * ntree = NULL;\r\nguint16 report_code, id_num;\r\nproto_tree_add_item(tree, hf_id_num, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nid_num = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_report_code, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nreport_code = tvb_get_ntohs(tvb, offset);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_ha_mode, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_ha_time_unit, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (report_code & 1) {\r\nnti = proto_tree_add_item(tree, hf_machine_states, tvb, offset, id_num, ENC_NA);\r\nntree = proto_item_add_subtree(nti, ett_cphap);\r\nfor(i=0; i < id_num; i++) {\r\nnti = proto_tree_add_item(ntree, hf_state_node, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(nti, " (Nodes %d)", i);\r\noffset += 1;\r\n}\r\n}\r\nif (report_code & 2) {\r\nnti = proto_tree_add_item(tree, hf_interface_states, tvb, offset, 4, ENC_NA);\r\nntree = proto_item_add_subtree(nti, ett_cphap);\r\nproto_tree_add_item(ntree, hf_in_up_num, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ntree, hf_in_assumed_up_num, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ntree, hf_out_up_num, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(ntree, hf_out_assumed_up_num, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nfor(i=0; i < id_num; i++) {\r\nproto_tree_add_item(tree, hf_cluster_last_packet, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_item_append_text(nti, " (Cluster %d)", i);\r\noffset += 1;\r\n}\r\n}\r\nreturn offset;\r\n}\r\nstatic int dissect_lb_conf(tvbuff_t * tvb, int offset, proto_tree * tree) {\r\nproto_tree_add_item(tree, hf_slot_num, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_machine_num, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_seed, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_hash_len, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int dissect_policy_change(tvbuff_t * tvb, int offset, proto_tree * tree) {\r\nproto_tree_add_item(tree, hf_status, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int dissect_probe(tvbuff_t * tvb, int offset, proto_tree * tree) {\r\nproto_tree_add_item(tree, hf_ifn, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nstatic int dissect_conf_reply(tvbuff_t * tvb, int offset, proto_tree * tree) {\r\nproto_tree_add_item(tree, hf_num_reported_ifs, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(tree, hf_ethernet_add, tvb, offset, 6, ENC_NA);\r\noffset += 6;\r\nproto_tree_add_item(tree, hf_is_if_trusted, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(tree, hf_ip, tvb, offset, 4, ENC_NA);\r\noffset += 4;\r\nreturn offset;\r\n}\r\nvoid\r\nproto_register_cpha(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_magic_number,\r\n{ "Magic Number", "cpha.magic_number", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_cpha_protocol_ver,\r\n{ "Protocol Version", "cpha.version", FT_UINT16, BASE_DEC, VALS(ha_version_vals), 0x0, "CPHAP Version", HFILL}},\r\n{ &hf_cluster_number,\r\n{ "Cluster Number", "cpha.cluster_number", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_opcode,\r\n{ "HA OpCode", "cpha.opcode", FT_UINT16, BASE_DEC, VALS(opcode_type_vals), 0x0, NULL, HFILL}},\r\n{ &hf_payload,\r\n{ "Payload", "cpha.payload", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_src_if_num,\r\n{ "Source Interface", "cpha.src_if", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_random_id,\r\n{ "Random ID", "cpha.random_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_src_machine_id,\r\n{ "Source Machine ID", "cpha.src_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_dst_machine_id,\r\n{ "Destination Machine ID", "cpha.dst_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_policy_id,\r\n{ "Policy ID", "cpha.policy_id", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_filler,\r\n{ "Filler", "cpha.filler", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_id_num,\r\n{ "Number of IDs reported", "cpha.id_num", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_report_code,\r\n{ "Report code", "cpha.report_code", FT_UINT16, BASE_DEC, VALS(report_code_vals), 0x0, NULL, HFILL}},\r\n{ &hf_ha_mode,\r\n{ "HA mode", "cpha.ha_mode", FT_UINT16, BASE_DEC, VALS(ha_mode_vals), 0x0, NULL, HFILL}},\r\n{ &hf_ha_time_unit,\r\n{ "HA Time unit", "cpha.ha_time_unit", FT_UINT16, BASE_DEC, NULL, 0x0, "HA Time unit (ms)", HFILL}},\r\n{ &hf_machine_states,\r\n{ "Machines States", "cpha.machine_states", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_state_node,\r\n{ "State node", "cpha.state_node", FT_UINT8, BASE_DEC, VALS(state_vals), 0x0, NULL, HFILL}},\r\n{ &hf_interface_states,\r\n{ "Interface States", "cpha.interface_states", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_num_reported_ifs,\r\n{ "Reported Interfaces", "cpha.reported_ifs", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_ethernet_add,\r\n{ "Ethernet Address", "cpha.ethernet_addr", FT_ETHER, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_is_if_trusted,\r\n{ "Interface Trusted", "cpha.if_trusted", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_ip,\r\n{ "IP Address", "cpha.ip", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_slot_num,\r\n{ "Slot Number", "cpha.slot_num", FT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_machine_num,\r\n{ "Machine Number", "cpha.machine_num", FT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_seed,\r\n{ "Seed", "cpha.seed", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_hash_len,\r\n{ "Hash list length", "cpha.hash_len", FT_INT32, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_in_up_num,\r\n{ "Interfaces up in the Inbound", "cpha.in_up", FT_INT8, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_in_assumed_up_num,\r\n{ "Interfaces assumed up in the Inbound", "cpha.in_assume_up", FT_INT8, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_out_up_num,\r\n{ "Interfaces up in the Outbound", "cpha.out_up", FT_INT8, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_out_assumed_up_num,\r\n{ "Interfaces assumed up in the Outbound", "cpha.out_assume_up", FT_INT8, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n{ &hf_cluster_last_packet,\r\n{ "Last packet seen", "cpha.cluster_last_packet", FT_INT8, BASE_DEC, NULL, 0x0, "Time units ago", HFILL}},\r\n{ &hf_status,\r\n{ "Status", "cpha.status", FT_UINT32, BASE_DEC, VALS(status_vals), 0x0, NULL, HFILL}},\r\n{ &hf_ifn,\r\n{ "Interface Number", "cpha.ifn", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_cphap,\r\n};\r\nproto_cphap = proto_register_protocol("Check Point High Availability Protocol",\r\n"CPHA", "cpha");\r\nproto_register_field_array(proto_cphap, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_cpha(void)\r\n{\r\ndissector_handle_t cpha_handle;\r\ncpha_handle = new_create_dissector_handle(dissect_cpha, proto_cphap);\r\ndissector_add_uint("udp.port", UDP_PORT_CPHA, cpha_handle);\r\n}
