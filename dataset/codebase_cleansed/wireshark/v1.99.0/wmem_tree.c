static wmem_tree_node_t *\r\nnode_uncle(wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent, *grandparent;\r\nparent = node->parent;\r\nif (parent == NULL) {\r\nreturn NULL;\r\n}\r\ngrandparent = parent->parent;\r\nif (grandparent == NULL) {\r\nreturn NULL;\r\n}\r\nif (parent == grandparent->left) {\r\nreturn grandparent->right;\r\n}\r\nelse {\r\nreturn grandparent->left;\r\n}\r\n}\r\nstatic void\r\nrotate_left(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nif (node->parent) {\r\nif (node->parent->left == node) {\r\nnode->parent->left = node->right;\r\n}\r\nelse {\r\nnode->parent->right = node->right;\r\n}\r\n}\r\nelse {\r\ntree->root = node->right;\r\n}\r\nnode->right->parent = node->parent;\r\nnode->parent = node->right;\r\nnode->right = node->right->left;\r\nif (node->right) {\r\nnode->right->parent = node;\r\n}\r\nnode->parent->left = node;\r\n}\r\nstatic void\r\nrotate_right(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nif (node->parent) {\r\nif (node->parent->left == node) {\r\nnode->parent->left = node->left;\r\n}\r\nelse {\r\nnode->parent->right = node->left;\r\n}\r\n}\r\nelse {\r\ntree->root = node->left;\r\n}\r\nnode->left->parent = node->parent;\r\nnode->parent = node->left;\r\nnode->left = node->left->right;\r\nif (node->left) {\r\nnode->left->parent = node;\r\n}\r\nnode->parent->right = node;\r\n}\r\nstatic void\r\nrb_insert_case5(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent, *grandparent;\r\nparent = node->parent;\r\ngrandparent = parent->parent;\r\nparent->color = WMEM_NODE_COLOR_BLACK;\r\ngrandparent->color = WMEM_NODE_COLOR_RED;\r\nif (node == parent->left && parent == grandparent->left) {\r\nrotate_right(tree, grandparent);\r\n}\r\nelse {\r\nrotate_left(tree, grandparent);\r\n}\r\n}\r\nstatic void\r\nrb_insert_case4(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent, *grandparent;\r\nparent = node->parent;\r\ngrandparent = parent->parent;\r\nif (!grandparent) {\r\nreturn;\r\n}\r\nif (node == parent->right && parent == grandparent->left) {\r\nrotate_left(tree, parent);\r\nnode = node->left;\r\n}\r\nelse if (node == parent->left && parent == grandparent->right) {\r\nrotate_right(tree, parent);\r\nnode = node->right;\r\n}\r\nrb_insert_case5(tree, node);\r\n}\r\nstatic void\r\nrb_insert_case3(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent, *grandparent, *uncle;\r\nuncle = node_uncle(node);\r\nif (uncle && uncle->color == WMEM_NODE_COLOR_RED) {\r\nparent = node->parent;\r\ngrandparent = parent->parent;\r\nparent->color = WMEM_NODE_COLOR_BLACK;\r\nuncle->color = WMEM_NODE_COLOR_BLACK;\r\ngrandparent->color = WMEM_NODE_COLOR_RED;\r\nrb_insert_case1(tree, grandparent);\r\n}\r\nelse {\r\nrb_insert_case4(tree, node);\r\n}\r\n}\r\nstatic void\r\nrb_insert_case2(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nif (node->parent->color == WMEM_NODE_COLOR_RED) {\r\nrb_insert_case3(tree, node);\r\n}\r\n}\r\nstatic void\r\nrb_insert_case1(wmem_tree_t *tree, wmem_tree_node_t *node)\r\n{\r\nwmem_tree_node_t *parent = node->parent;\r\nif (parent == NULL) {\r\nnode->color = WMEM_NODE_COLOR_BLACK;\r\n}\r\nelse {\r\nrb_insert_case2(tree, node);\r\n}\r\n}\r\nwmem_tree_t *\r\nwmem_tree_new(wmem_allocator_t *allocator)\r\n{\r\nwmem_tree_t *tree;\r\ntree = wmem_new(allocator, wmem_tree_t);\r\ntree->master = allocator;\r\ntree->allocator = allocator;\r\ntree->root = NULL;\r\nreturn tree;\r\n}\r\nstatic gboolean\r\nwmem_tree_reset_cb(wmem_allocator_t *allocator _U_, wmem_cb_event_t event,\r\nvoid *user_data)\r\n{\r\nwmem_tree_t *tree = (wmem_tree_t *)user_data;\r\ntree->root = NULL;\r\nif (event == WMEM_CB_DESTROY_EVENT) {\r\nwmem_unregister_callback(tree->master, tree->master_cb_id);\r\nwmem_free(tree->master, tree);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nwmem_tree_destroy_cb(wmem_allocator_t *allocator _U_, wmem_cb_event_t event _U_,\r\nvoid *user_data)\r\n{\r\nwmem_tree_t *tree = (wmem_tree_t *)user_data;\r\nwmem_unregister_callback(tree->allocator, tree->slave_cb_id);\r\nreturn FALSE;\r\n}\r\nwmem_tree_t *\r\nwmem_tree_new_autoreset(wmem_allocator_t *master, wmem_allocator_t *slave)\r\n{\r\nwmem_tree_t *tree;\r\ntree = wmem_new(master, wmem_tree_t);\r\ntree->master = master;\r\ntree->allocator = slave;\r\ntree->root = NULL;\r\ntree->master_cb_id = wmem_register_callback(master, wmem_tree_destroy_cb,\r\ntree);\r\ntree->slave_cb_id = wmem_register_callback(slave, wmem_tree_reset_cb,\r\ntree);\r\nreturn tree;\r\n}\r\ngboolean\r\nwmem_tree_is_empty(wmem_tree_t *tree)\r\n{\r\nreturn tree->root == NULL;\r\n}\r\nstatic wmem_tree_node_t *\r\ncreate_node(wmem_allocator_t *allocator, wmem_tree_node_t *parent, guint32 key,\r\nvoid *data, wmem_node_color_t color, gboolean is_subtree)\r\n{\r\nwmem_tree_node_t *node;\r\nnode = wmem_new(allocator, wmem_tree_node_t);\r\nnode->left = NULL;\r\nnode->right = NULL;\r\nnode->parent = parent;\r\nnode->key32 = key;\r\nnode->data = data;\r\nnode->color = color;\r\nnode->is_subtree = is_subtree;\r\nreturn node;\r\n}\r\nstatic void *\r\nlookup_or_insert32(wmem_tree_t *tree, guint32 key,\r\nvoid*(*func)(void*), void* data, gboolean is_subtree, gboolean replace)\r\n{\r\nwmem_tree_node_t *node = tree->root;\r\nwmem_tree_node_t *new_node = NULL;\r\nif (!node) {\r\nnew_node = create_node(tree->allocator, NULL, key,\r\nCREATE_DATA(func, data), WMEM_NODE_COLOR_BLACK, is_subtree);\r\ntree->root = new_node;\r\nreturn new_node->data;\r\n}\r\nwhile (!new_node) {\r\nif (key == node->key32) {\r\nif (replace) {\r\nnode->data = CREATE_DATA(func, data);\r\n}\r\nreturn node->data;\r\n}\r\nelse if (key < node->key32) {\r\nif (node->left) {\r\nnode = node->left;\r\n}\r\nelse {\r\nnew_node = create_node(tree->allocator, node, key,\r\nCREATE_DATA(func, data), WMEM_NODE_COLOR_RED,\r\nis_subtree);\r\nnode->left = new_node;\r\n}\r\n}\r\nelse if (key > node->key32) {\r\nif (node->right) {\r\nnode = node->right;\r\n}\r\nelse {\r\nnew_node = create_node(tree->allocator, node, key,\r\nCREATE_DATA(func, data), WMEM_NODE_COLOR_RED,\r\nis_subtree);\r\nnode->right = new_node;\r\n}\r\n}\r\n}\r\nrb_insert_case1(tree, new_node);\r\nreturn new_node->data;\r\n}\r\nvoid\r\nwmem_tree_insert32(wmem_tree_t *tree, guint32 key, void *data)\r\n{\r\nlookup_or_insert32(tree, key, NULL, data, FALSE, TRUE);\r\n}\r\nvoid *\r\nwmem_tree_lookup32(wmem_tree_t *tree, guint32 key)\r\n{\r\nwmem_tree_node_t *node = tree->root;\r\nwhile (node) {\r\nif (key == node->key32) {\r\nreturn node->data;\r\n}\r\nelse if (key < node->key32) {\r\nnode = node->left;\r\n}\r\nelse if (key > node->key32) {\r\nnode = node->right;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid *\r\nwmem_tree_lookup32_le(wmem_tree_t *tree, guint32 key)\r\n{\r\nwmem_tree_node_t *node = tree->root;\r\nwhile (node) {\r\nif (key == node->key32) {\r\nreturn node->data;\r\n}\r\nelse if (key < node->key32) {\r\nif (node->left == NULL) {\r\nbreak;\r\n}\r\nnode = node->left;\r\n}\r\nelse if (key > node->key32) {\r\nif (node->right == NULL) {\r\nbreak;\r\n}\r\nnode = node->right;\r\n}\r\n}\r\nif (!node) {\r\nreturn NULL;\r\n}\r\nif (node->parent == NULL) {\r\nif (key > node->key32) {\r\nreturn node->data;\r\n} else {\r\nreturn NULL;\r\n}\r\n}\r\nif (node->key32 <= key) {\r\nreturn node->data;\r\n}\r\nelse if (node == node->parent->left) {\r\nwhile (node) {\r\nif (key > node->key32) {\r\nreturn node->data;\r\n}\r\nnode=node->parent;\r\n}\r\nreturn NULL;\r\n}\r\nelse {\r\nreturn node->parent->data;\r\n}\r\n}\r\nstatic guint32 *\r\npack_string(const gchar *key, guint32 *divx, guint32 flags)\r\n{\r\nguint32 *aligned = NULL;\r\nguint32 len = (guint32) strlen(key);\r\nguint32 i;\r\nguint32 tmp;\r\n*divx = (len+3)/4 + 1;\r\naligned = (guint32 *)wmem_alloc(NULL, *divx * sizeof (guint32));\r\ntmp = 0;\r\nfor (i = 0;i < len;i++) {\r\nunsigned char ch;\r\nch = (unsigned char)key[i];\r\nif (flags & WMEM_TREE_STRING_NOCASE) {\r\nif (isupper(ch)) {\r\nch = tolower(ch);\r\n}\r\n}\r\ntmp <<= 8;\r\ntmp |= ch;\r\nif (i%4 == 3) {\r\naligned[i/4] = tmp;\r\ntmp = 0;\r\n}\r\n}\r\nif (i%4 != 0) {\r\nwhile (i%4 != 0) {\r\ni++;\r\ntmp <<= 8;\r\n}\r\naligned[i/4-1] = tmp;\r\n}\r\naligned[*divx-1] = 0x00000001;\r\nreturn aligned;\r\n}\r\nvoid\r\nwmem_tree_insert_string(wmem_tree_t* tree, const gchar* k, void* v, guint32 flags)\r\n{\r\nwmem_tree_key_t key[2];\r\nguint32 *aligned;\r\nguint32 divx;\r\naligned = pack_string(k, &divx, flags);\r\nkey[0].length = divx;\r\nkey[0].key = aligned;\r\nkey[1].length = 0;\r\nkey[1].key = NULL;\r\nwmem_tree_insert32_array(tree, key, v);\r\nwmem_free(NULL, aligned);\r\n}\r\nvoid *\r\nwmem_tree_lookup_string(wmem_tree_t* tree, const gchar* k, guint32 flags)\r\n{\r\nwmem_tree_key_t key[2];\r\nguint32 *aligned;\r\nguint32 divx;\r\nvoid *ret;\r\naligned = pack_string(k, &divx, flags);\r\nkey[0].length = divx;\r\nkey[0].key = aligned;\r\nkey[1].length = 0;\r\nkey[1].key = NULL;\r\nret = wmem_tree_lookup32_array(tree, key);\r\nwmem_free(NULL, aligned);\r\nreturn ret;\r\n}\r\nstatic void *\r\ncreate_sub_tree(void* d)\r\n{\r\nreturn wmem_tree_new(((wmem_tree_t *)d)->allocator);\r\n}\r\nvoid\r\nwmem_tree_insert32_array(wmem_tree_t *tree, wmem_tree_key_t *key, void *data)\r\n{\r\nwmem_tree_t *insert_tree = NULL;\r\nwmem_tree_key_t *cur_key;\r\nguint32 i, insert_key32 = 0;\r\nfor (cur_key = key; cur_key->length > 0; cur_key++) {\r\nfor (i = 0; i < cur_key->length; i++) {\r\nif (!insert_tree) {\r\ninsert_tree = tree;\r\n} else {\r\ninsert_tree = (wmem_tree_t *)lookup_or_insert32(insert_tree,\r\ninsert_key32, create_sub_tree, tree, TRUE, FALSE);\r\n}\r\ninsert_key32 = cur_key->key[i];\r\n}\r\n}\r\ng_assert(insert_tree);\r\nwmem_tree_insert32(insert_tree, insert_key32, data);\r\n}\r\nstatic void *\r\nwmem_tree_lookup32_array_helper(wmem_tree_t *tree, wmem_tree_key_t *key,\r\nvoid*(*helper)(wmem_tree_t*, guint32))\r\n{\r\nwmem_tree_t *lookup_tree = NULL;\r\nwmem_tree_key_t *cur_key;\r\nguint32 i, lookup_key32 = 0;\r\nif (!tree || !key) {\r\nreturn NULL;\r\n}\r\nfor (cur_key = key; cur_key->length > 0; cur_key++) {\r\nfor (i = 0; i < cur_key->length; i++) {\r\nif (!lookup_tree) {\r\nlookup_tree = tree;\r\n}\r\nelse {\r\nlookup_tree =\r\n(wmem_tree_t *)(*helper)(lookup_tree, lookup_key32);\r\nif (!lookup_tree) {\r\nreturn NULL;\r\n}\r\n}\r\nlookup_key32 = cur_key->key[i];\r\n}\r\n}\r\ng_assert(lookup_tree);\r\nreturn (*helper)(lookup_tree, lookup_key32);\r\n}\r\nvoid *\r\nwmem_tree_lookup32_array(wmem_tree_t *tree, wmem_tree_key_t *key)\r\n{\r\nreturn wmem_tree_lookup32_array_helper(tree, key, wmem_tree_lookup32);\r\n}\r\nvoid *\r\nwmem_tree_lookup32_array_le(wmem_tree_t *tree, wmem_tree_key_t *key)\r\n{\r\nreturn wmem_tree_lookup32_array_helper(tree, key, wmem_tree_lookup32_le);\r\n}\r\nstatic gboolean\r\nwmem_tree_foreach_nodes(wmem_tree_node_t* node, wmem_foreach_func callback,\r\nvoid *user_data)\r\n{\r\ngboolean stop_traverse = FALSE;\r\nif (!node) {\r\nreturn FALSE;\r\n}\r\nif (node->left) {\r\nif (wmem_tree_foreach_nodes(node->left, callback, user_data)) {\r\nreturn TRUE;\r\n}\r\n}\r\nif (node->is_subtree == TRUE) {\r\nstop_traverse = wmem_tree_foreach((wmem_tree_t *)node->data,\r\ncallback, user_data);\r\n} else {\r\nstop_traverse = callback(node->data, user_data);\r\n}\r\nif (stop_traverse) {\r\nreturn TRUE;\r\n}\r\nif(node->right) {\r\nif (wmem_tree_foreach_nodes(node->right, callback, user_data)) {\r\nreturn TRUE;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\ngboolean\r\nwmem_tree_foreach(wmem_tree_t* tree, wmem_foreach_func callback,\r\nvoid *user_data)\r\n{\r\nif(!tree->root)\r\nreturn FALSE;\r\nreturn wmem_tree_foreach_nodes(tree->root, callback, user_data);\r\n}\r\nstatic void\r\nwmem_tree_print_nodes(const char *prefix, wmem_tree_node_t *node, guint32 level)\r\n{\r\nguint32 i;\r\nif (!node)\r\nreturn;\r\nfor (i=0; i<level; i++) {\r\nprintf(" ");\r\n}\r\nprintf("%sNODE:%p parent:%p left:%p right:%p colour:%s key:%u %s:%p\n",\r\nprefix,\r\n(void *)node, (void *)node->parent,\r\n(void *)node->left, (void *)node->right,\r\nnode->color?"Black":"Red", node->key32,\r\nnode->is_subtree?"tree":"data", node->data);\r\nif (node->left)\r\nwmem_tree_print_nodes("L-", node->left, level+1);\r\nif (node->right)\r\nwmem_tree_print_nodes("R-", node->right, level+1);\r\nif (node->is_subtree)\r\nwmem_print_subtree((wmem_tree_t *)node->data, level+1);\r\n}\r\nstatic void\r\nwmem_print_subtree(wmem_tree_t *tree, guint32 level)\r\n{\r\nguint32 i;\r\nif (!tree)\r\nreturn;\r\nfor (i=0; i<level; i++) {\r\nprintf(" ");\r\n}\r\nprintf("WMEM tree:%p root:%p\n", (void *)tree, (void *)tree->root);\r\nif (tree->root) {\r\nwmem_tree_print_nodes("Root-", tree->root, level);\r\n}\r\n}\r\nvoid\r\nwmem_print_tree(wmem_tree_t *tree)\r\n{\r\nwmem_print_subtree(tree, 0);\r\n}
