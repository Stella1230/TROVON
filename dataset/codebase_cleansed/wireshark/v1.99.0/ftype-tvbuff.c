static void\r\nvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.tvb = NULL;\r\nfv->tvb_is_private = FALSE;\r\n}\r\nstatic void\r\nvalue_free(fvalue_t *fv)\r\n{\r\nif (fv->value.tvb && fv->tvb_is_private) {\r\ntvb_free_chain(fv->value.tvb);\r\n}\r\n}\r\nstatic void\r\nvalue_set(fvalue_t *fv, tvbuff_t *value)\r\n{\r\nvalue_free(fv);\r\nfv->value.tvb = value;\r\n}\r\nstatic void\r\nfree_tvb_data(void *data)\r\n{\r\ng_free(data);\r\n}\r\nstatic gboolean\r\nval_from_string(fvalue_t *fv, const char *s, LogFunc logfunc _U_)\r\n{\r\ntvbuff_t *new_tvb;\r\nguint8 *private_data;\r\nvalue_free(fv);\r\nprivate_data = (guint8 *)g_memdup(s, (guint)strlen(s));\r\nnew_tvb = tvb_new_real_data(private_data,\r\n(guint)strlen(s), (gint)strlen(s));\r\ntvb_set_free_cb(new_tvb, free_tvb_data);\r\nfv->tvb_is_private = TRUE;\r\nfv->value.tvb = new_tvb;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nval_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, LogFunc logfunc)\r\n{\r\nfvalue_t *fv_bytes;\r\ntvbuff_t *new_tvb;\r\nguint8 *private_data;\r\nvalue_free(fv);\r\nfv_bytes = fvalue_from_unparsed(FT_BYTES, s, TRUE, NULL);\r\nif (fv_bytes) {\r\nprivate_data = (guint8 *)g_memdup(fv_bytes->value.bytes->data,\r\nfv_bytes->value.bytes->len);\r\nnew_tvb = tvb_new_real_data(private_data,\r\nfv_bytes->value.bytes->len,\r\nfv_bytes->value.bytes->len);\r\ntvb_set_free_cb(new_tvb, free_tvb_data);\r\nfv->tvb_is_private = TRUE;\r\nfv->value.tvb = new_tvb;\r\nreturn TRUE;\r\n}\r\nreturn val_from_string(fv, s, logfunc);\r\n}\r\nstatic int\r\nval_repr_len(fvalue_t *fv, ftrepr_t rtype)\r\n{\r\nvolatile guint length = 0;\r\nif (rtype != FTREPR_DFILTER) return -1;\r\nTRY {\r\nlength = tvb_length(fv->value.tvb) * 3 - 1;\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\nreturn (int) length;\r\n}\r\nstatic void\r\nval_to_repr(fvalue_t *fv, ftrepr_t rtype, char * volatile buf)\r\n{\r\nguint length;\r\nconst guint8 *c;\r\nunsigned int i;\r\ng_assert(rtype == FTREPR_DFILTER);\r\nTRY {\r\nlength = tvb_length(fv->value.tvb);\r\nc = tvb_get_ptr(fv->value.tvb, 0, length);\r\nfor (i = 0; i < length; i++) {\r\nif (i == 0) {\r\nsprintf((char *)buf, "%02x", *c++);\r\nbuf += 2;\r\n}\r\nelse {\r\nsprintf((char *)buf, ":%02x", *c++);\r\nbuf += 3;\r\n}\r\n}\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\n}\r\nstatic gpointer\r\nvalue_get(fvalue_t *fv)\r\n{\r\nreturn fv->value.tvb;\r\n}\r\nstatic guint\r\nlen(fvalue_t *fv)\r\n{\r\nvolatile guint length = 0;\r\nTRY {\r\nif (fv->value.tvb)\r\nlength = tvb_length(fv->value.tvb);\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\nreturn length;\r\n}\r\nstatic void\r\nslice(fvalue_t *fv, GByteArray *bytes, guint offset, guint length)\r\n{\r\nconst guint8* data;\r\nif (fv->value.tvb) {\r\nTRY {\r\ndata = tvb_get_ptr(fv->value.tvb, offset, length);\r\ng_byte_array_append(bytes, data, length);\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\n}\r\n}\r\nstatic gboolean\r\ncmp_eq(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\ntvbuff_t *a = fv_a->value.tvb;\r\ntvbuff_t *b = fv_b->value.tvb;\r\nvolatile gboolean eq = FALSE;\r\nTRY {\r\nguint a_len = tvb_length(a);\r\nif (a_len == tvb_length(b))\r\neq = (memcmp(tvb_get_ptr(a, 0, a_len), tvb_get_ptr(b, 0, a_len), a_len) == 0);\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\nreturn eq;\r\n}\r\nstatic gboolean\r\ncmp_ne(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\ntvbuff_t *a = fv_a->value.tvb;\r\ntvbuff_t *b = fv_b->value.tvb;\r\nvolatile gboolean ne = TRUE;\r\nTRY {\r\nguint a_len = tvb_length(a);\r\nif (a_len == tvb_length(b)) {\r\nne = (memcmp(tvb_get_ptr(a, 0, a_len), tvb_get_ptr(b, 0, a_len), a_len) != 0);\r\n}\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\nreturn ne;\r\n}\r\nstatic gboolean\r\ncmp_gt(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\ntvbuff_t *a = fv_a->value.tvb;\r\ntvbuff_t *b = fv_b->value.tvb;\r\nvolatile gboolean gt = FALSE;\r\nTRY {\r\nguint a_len = tvb_length(a);\r\nguint b_len = tvb_length(b);\r\nif (a_len > b_len) {\r\ngt = TRUE;\r\n} else if (a_len == b_len) {\r\ngt = (memcmp(tvb_get_ptr(a, 0, a_len), tvb_get_ptr(b, 0, a_len), a_len) > 0);\r\n}\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\nreturn gt;\r\n}\r\nstatic gboolean\r\ncmp_ge(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\ntvbuff_t *a = fv_a->value.tvb;\r\ntvbuff_t *b = fv_b->value.tvb;\r\nvolatile gboolean ge = FALSE;\r\nTRY {\r\nguint a_len = tvb_length(a);\r\nguint b_len = tvb_length(b);\r\nif (a_len > b_len) {\r\nge = TRUE;\r\n} else if (a_len == b_len) {\r\nge = (memcmp(tvb_get_ptr(a, 0, a_len), tvb_get_ptr(b, 0, a_len), a_len) >= 0);\r\n}\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\nreturn ge;\r\n}\r\nstatic gboolean\r\ncmp_lt(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\ntvbuff_t *a = fv_a->value.tvb;\r\ntvbuff_t *b = fv_b->value.tvb;\r\nvolatile gboolean lt = FALSE;\r\nTRY {\r\nguint a_len = tvb_length(a);\r\nguint b_len = tvb_length(b);\r\nif (a_len < b_len) {\r\nlt = TRUE;\r\n} else if (a_len == b_len) {\r\nlt = (memcmp(tvb_get_ptr(a, 0, a_len), tvb_get_ptr(b, 0, a_len), a_len) < 0);\r\n}\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\nreturn lt;\r\n}\r\nstatic gboolean\r\ncmp_le(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\ntvbuff_t *a = fv_a->value.tvb;\r\ntvbuff_t *b = fv_b->value.tvb;\r\nvolatile gboolean le = FALSE;\r\nTRY {\r\nguint a_len = tvb_length(a);\r\nguint b_len = tvb_length(b);\r\nif (a_len < b_len) {\r\nle = TRUE;\r\n} else if (a_len == b_len) {\r\nle = (memcmp(tvb_get_ptr(a, 0, a_len), tvb_get_ptr(b, 0, a_len), a_len) <= 0);\r\n}\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\nreturn le;\r\n}\r\nstatic gboolean\r\ncmp_contains(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\nvolatile gboolean contains = FALSE;\r\nTRY {\r\nif (tvb_find_tvb(fv_a->value.tvb, fv_b->value.tvb, 0) > -1) {\r\ncontains = TRUE;\r\n}\r\n}\r\nCATCH_ALL {\r\n}\r\nENDTRY;\r\nreturn contains;\r\n}\r\nstatic gboolean\r\ncmp_matches(const fvalue_t *fv_a, const fvalue_t *fv_b)\r\n{\r\ntvbuff_t *tvb = fv_a->value.tvb;\r\nGRegex *regex = fv_b->value.re;\r\nvolatile gboolean rc = FALSE;\r\nconst char *data = NULL;\r\nguint32 tvb_len;\r\nif (strcmp(fv_b->ftype->name, "FT_PCRE") != 0) {\r\nreturn FALSE;\r\n}\r\nif (! regex) {\r\nreturn FALSE;\r\n}\r\nTRY {\r\ntvb_len = tvb_length(tvb);\r\ndata = (const char *)tvb_get_ptr(tvb, 0, tvb_len);\r\nrc = g_regex_match_full(\r\nregex,\r\ndata,\r\ntvb_len,\r\n0,\r\n(GRegexMatchFlags)0,\r\nNULL,\r\nNULL\r\n);\r\n}\r\nCATCH_ALL {\r\nreturn FALSE;\r\n}\r\nENDTRY;\r\nreturn rc;\r\n}\r\nvoid\r\nftype_register_tvbuff(void)\r\n{\r\nstatic ftype_t protocol_type = {\r\nFT_PROTOCOL,\r\n"FT_PROTOCOL",\r\n"Protocol",\r\n0,\r\nvalue_new,\r\nvalue_free,\r\nval_from_unparsed,\r\nval_from_string,\r\nval_to_repr,\r\nval_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ncmp_gt,\r\ncmp_ge,\r\ncmp_lt,\r\ncmp_le,\r\nNULL,\r\ncmp_contains,\r\nCMP_MATCHES,\r\nlen,\r\nslice,\r\n};\r\nftype_register(FT_PROTOCOL, &protocol_type);\r\n}
