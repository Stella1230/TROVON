static void dissect_cnip (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\ntvbuff_t *next_tvb;\r\ngint offset;\r\ngint type, exth_len, pf_pcode;\r\nproto_tree *ti;\r\nproto_tree *cnip_tree;\r\nstatic const gint *pf_fields[] = {\r\n&hf_cnip_pf_sec,\r\n&hf_cnip_pf_pcode,\r\nNULL\r\n};\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CN/IP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ntype = tvb_get_guint8(tvb, 3);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,"Priority: %s Type: %s",\r\n(pinfo->destport == 1629 )? "urgent":"normal",\r\nval_to_str_const(type, type_tuple, "Unknown"));\r\nexth_len = tvb_get_guint8(tvb, 4);\r\npf_pcode = tvb_get_guint8(tvb, 5) & 0x1F;\r\noffset = 0;\r\nti = proto_tree_add_item(tree, proto_cnip, tvb, offset, -1, ENC_NA);\r\ncnip_tree = proto_item_add_subtree(ti, ett_cnip);\r\nproto_tree_add_item(cnip_tree, hf_cnip_len, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cnip_tree, hf_cnip_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(cnip_tree, hf_cnip_type, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(cnip_tree, hf_cnip_exth, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_bitmask(cnip_tree, tvb, offset,\r\nhf_cnip_pf, ett_pf, pf_fields, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(cnip_tree, hf_cnip_vcode, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cnip_tree, hf_cnip_sessid, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(cnip_tree, hf_cnip_seqno, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(cnip_tree, hf_cnip_tstamp, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\noffset += 4 * exth_len;\r\nproto_item_set_len(ti, offset);\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\nif (type == DATA_PACKET) {\r\nif (dissector_try_uint(cnip_dissector_table, pf_pcode, next_tvb, pinfo, tree))\r\nreturn;\r\n}\r\nelse {\r\nexpert_add_info_format(pinfo, cnip_tree, &ei_cnip_type_unknown,\r\n"This dissector doesn't yet decode packets of type %s (0x%x)",\r\nval_to_str_const(type, type_tuple, "Unknown"), type);\r\n}\r\ncall_dissector(data_handle, next_tvb, pinfo, tree);\r\n}\r\nvoid proto_register_cnip(void)\r\n{\r\nstatic hf_register_info hf[] =\r\n{\r\n{&hf_cnip_len,\r\n{"Packet length", "cnip.len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_ver,\r\n{"Version", "cnip.ver",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_type,\r\n{"Packet type", "cnip.type",\r\nFT_UINT8, BASE_HEX, VALS(type_tuple), 0,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_exth,\r\n{"Ext. Header Size", "cnip.exth",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_pf,\r\n{"Protocol Flags", "cnip.pf",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_pf_sec,\r\n{"Protocol Flags", "cnip.sec",\r\nFT_UINT8, BASE_DEC, NULL, 0x20,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_pf_pcode,\r\n{"Protocol Code", "cnip.protocol",\r\nFT_UINT8, BASE_DEC, NULL, 0x1F,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_vcode,\r\n{"Vendor Code", "cnip.vendorcode",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_sessid,\r\n{"Session ID", "cnip.sessid",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_seqno,\r\n{"Sequence Number", "cnip.seqno",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n},\r\n{&hf_cnip_tstamp,\r\n{"Time Stamp", "cnip.tstamp",\r\nFT_UINT32, BASE_DEC, NULL, 0,\r\nNULL, HFILL }\r\n}\r\n};\r\nstatic gint *ett[] =\r\n{\r\n&ett_cnip,\r\n&ett_pf\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_cnip_type_unknown, { "cnip.type.unknown", PI_UNDECODED, PI_WARN, "This dissector doesn't yet decode packets of type", EXPFILL }},\r\n};\r\nexpert_module_t* expert_cnip;\r\nproto_cnip = proto_register_protocol("Component Network over IP",\r\n"CN/IP", "cnip");\r\nproto_register_field_array(proto_cnip, hf, array_length (hf));\r\nproto_register_subtree_array(ett, array_length (ett));\r\nexpert_cnip = expert_register_protocol(proto_cnip);\r\nexpert_register_field_array(expert_cnip, ei, array_length(ei));\r\ncnip_dissector_table = register_dissector_table("cnip.protocol",\r\n"CN/IP Protocol", FT_UINT8, BASE_DEC);\r\n}\r\nvoid proto_reg_handoff_cnip(void)\r\n{\r\ndissector_handle_t cnip_handle;\r\ncnip_handle = create_dissector_handle(dissect_cnip, proto_cnip);\r\ndata_handle = find_dissector("data");\r\ndissector_add_uint ("udp.port", 1628, cnip_handle);\r\ndissector_add_uint ("udp.port", 1629, cnip_handle);\r\n}
