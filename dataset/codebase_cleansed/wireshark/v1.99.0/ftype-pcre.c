static void\r\ngregex_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.re = NULL;\r\n}\r\nstatic void\r\ngregex_fvalue_free(fvalue_t *fv)\r\n{\r\nif (fv->value.re) {\r\ng_regex_unref(fv->value.re);\r\nfv->value.re = NULL;\r\n}\r\n}\r\nstatic gboolean\r\nraw_flag_needed(const gchar *pattern)\r\n{\r\ngboolean found = FALSE;\r\nconst gchar *s = pattern;\r\nsize_t i, len;\r\nlen = strlen(s);\r\nfor (i = 0; i < len; i++) {\r\nif ((s[i] >= '\xAA' && s[i] <= '\xAF') ||\r\n(s[i] >= '\xBA' && s[i] <= '\xBF') ||\r\n(s[i] >= '\xCA' && s[i] <= '\xCF') ||\r\n(s[i] >= '\xDA' && s[i] <= '\xDF') ||\r\n(s[i] >= '\xEA' && s[i] <= '\xEF') ||\r\n(s[i] >= '\xFA' && s[i] <= '\xFF'))\r\n{\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic gboolean\r\nval_from_string(fvalue_t *fv, const char *pattern, LogFunc logfunc)\r\n{\r\nGError *regex_error = NULL;\r\nGRegexCompileFlags cflags = G_REGEX_OPTIMIZE;\r\nif (raw_flag_needed(pattern)) {\r\ncflags = (GRegexCompileFlags)(G_REGEX_OPTIMIZE | G_REGEX_RAW);\r\n}\r\ngregex_fvalue_free(fv);\r\nfv->value.re = g_regex_new(\r\npattern,\r\ncflags,\r\n(GRegexMatchFlags)0,\r\n&regex_error\r\n);\r\nif (regex_error) {\r\nif (logfunc) {\r\nlogfunc(regex_error->message);\r\n}\r\ng_error_free(regex_error);\r\nif (fv->value.re) {\r\ng_regex_unref(fv->value.re);\r\n}\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nval_from_unparsed(fvalue_t *fv, const char *pattern, gboolean allow_partial_value _U_, LogFunc logfunc)\r\n{\r\ng_assert(! allow_partial_value);\r\nreturn val_from_string(fv, pattern, logfunc);\r\n}\r\nstatic int\r\ngregex_repr_len(fvalue_t *fv, ftrepr_t rtype)\r\n{\r\ng_assert(rtype == FTREPR_DFILTER);\r\nreturn (int)strlen(g_regex_get_pattern(fv->value.re));\r\n}\r\nstatic void\r\ngregex_to_repr(fvalue_t *fv, ftrepr_t rtype, char *buf)\r\n{\r\ng_assert(rtype == FTREPR_DFILTER);\r\nstrcpy(buf, g_regex_get_pattern(fv->value.re));\r\n}\r\nstatic void\r\ngregex_fvalue_set(fvalue_t *fv, const char *value)\r\n{\r\ng_assert(value != NULL);\r\ngregex_fvalue_free(fv);\r\nval_from_unparsed(fv, value, FALSE, NULL);\r\n}\r\nstatic gpointer\r\ngregex_fvalue_get(fvalue_t *fv)\r\n{\r\nreturn fv->value.re;\r\n}\r\nvoid\r\nftype_register_pcre(void)\r\n{\r\nstatic ftype_t pcre_type = {\r\nFT_PCRE,\r\n"FT_PCRE",\r\n"Compiled Perl-Compatible Regular Expression (GRegex) object",\r\n0,\r\ngregex_fvalue_new,\r\ngregex_fvalue_free,\r\nval_from_unparsed,\r\nval_from_string,\r\ngregex_to_repr,\r\ngregex_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ngregex_fvalue_set,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\ngregex_fvalue_get,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nftype_register(FT_PCRE, &pcre_type);\r\n}
