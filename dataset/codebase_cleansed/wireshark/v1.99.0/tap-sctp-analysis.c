static\r\nvoid free_first(gpointer data, gpointer user_data _U_)\r\n{\r\ng_free(data);\r\n}\r\nstatic void tsn_free(gpointer data, gpointer user_data _U_)\r\n{\r\ntsn_t *tsn;\r\ntsn = (tsn_t *) data;\r\nif (tsn->tsns != NULL)\r\n{\r\ng_list_foreach(tsn->tsns, free_first, NULL);\r\ng_list_free(tsn->tsns);\r\ntsn->tsns=NULL;\r\n}\r\n}\r\nstatic void reset(void *arg)\r\n{\r\nsctp_allassocs_info_t *tapdata = (sctp_allassocs_info_t *)arg;\r\nGList* list;\r\nsctp_assoc_info_t * info;\r\nlist = g_list_first(tapdata->assoc_info_list);\r\nwhile (list)\r\n{\r\ninfo = (sctp_assoc_info_t *) (list->data);\r\nif (info->addr1 != NULL)\r\n{\r\ng_list_foreach(info->addr1, free_first, NULL);\r\ng_list_free(info->addr1);\r\ninfo->addr1 = NULL;\r\n}\r\nif (info->addr2 != NULL)\r\n{\r\ng_list_foreach(info->addr2,free_first, NULL);\r\ng_list_free(info->addr2);\r\ninfo->addr2 = NULL;\r\n}\r\nif (info->error_info_list != NULL)\r\n{\r\ng_list_foreach(info->error_info_list, free_first, NULL);\r\ng_list_free(info->error_info_list);\r\ninfo->error_info_list = NULL;\r\n}\r\nif (info->frame_numbers != NULL)\r\n{\r\ng_list_free(info->frame_numbers);\r\ninfo->frame_numbers = NULL;\r\n}\r\nif (info->tsn1 != NULL)\r\n{\r\ng_list_foreach(info->tsn1, tsn_free, NULL);\r\ng_list_free(info->tsn1);\r\ninfo->tsn1 = NULL;\r\n}\r\nif (info->tsn2 != NULL)\r\n{\r\ng_list_foreach(info->tsn2, tsn_free, NULL);\r\ng_list_free(info->tsn2);\r\ninfo->tsn2 = NULL;\r\n}\r\nif (info->sack1 != NULL)\r\n{\r\ng_list_foreach(info->sack1, tsn_free, NULL);\r\ng_list_free(info->sack1);\r\ninfo->sack1 = NULL;\r\n}\r\nif (info->sack2 != NULL)\r\n{\r\ng_list_foreach(info->sack2, tsn_free, NULL);\r\ng_list_free(info->sack2);\r\ninfo->sack2 = NULL;\r\n}\r\nif (info->sort_tsn1 != NULL)\r\ng_ptr_array_free(info->sort_tsn1, TRUE);\r\nif (info->sort_tsn2 != NULL)\r\ng_ptr_array_free(info->sort_tsn2, TRUE);\r\nif (info->sort_sack1 != NULL)\r\ng_ptr_array_free(info->sort_sack1, TRUE);\r\nif (info->sort_sack2 != NULL)\r\ng_ptr_array_free(info->sort_sack2, TRUE);\r\nif (info->min_max != NULL)\r\n{\r\ng_slist_foreach(info->min_max, free_first, NULL);\r\ninfo->min_max = NULL;\r\n}\r\ng_free(list->data);\r\nlist = g_list_next(list);\r\n}\r\ng_list_free(tapdata->assoc_info_list);\r\ntapdata->sum_tvbs = 0;\r\ntapdata->assoc_info_list = NULL;\r\n}\r\nstatic sctp_assoc_info_t *calc_checksum(const struct _sctp_info *check_data, sctp_assoc_info_t *data)\r\n{\r\ngboolean ok = FALSE;\r\nif (check_data->adler32_calculated)\r\n{\r\ndata->n_adler32_calculated++;\r\nif (check_data->adler32_correct)\r\ndata->n_adler32_correct++;\r\n}\r\nif (check_data->crc32c_calculated)\r\n{\r\ndata->n_crc32c_calculated++;\r\nif (check_data->crc32c_correct)\r\ndata->n_crc32c_correct++;\r\n}\r\nif (data->n_adler32_calculated > 0)\r\n{\r\nif ((float)(data->n_adler32_correct*1.0/data->n_adler32_calculated) > 0.5)\r\n{\r\ng_strlcpy(data->checksum_type,"ADLER32",8);\r\ndata->n_checksum_errors=(data->n_adler32_calculated-data->n_adler32_correct);\r\nok = TRUE;\r\n}\r\n}\r\nif (data->n_crc32c_calculated>0)\r\n{\r\nif ((float)(data->n_crc32c_correct*1.0/data->n_crc32c_calculated) > 0.5)\r\n{\r\ng_strlcpy(data->checksum_type,"CRC32C",8);\r\ndata->n_checksum_errors=data->n_crc32c_calculated-data->n_crc32c_correct;\r\nok = TRUE;\r\n}\r\n}\r\nif (!ok)\r\n{\r\ng_strlcpy(data->checksum_type,"UNKNOWN",8);\r\ndata->n_checksum_errors=0;\r\n}\r\nreturn(data);\r\n}\r\nstatic sctp_assoc_info_t * find_assoc(sctp_tmp_info_t * needle)\r\n{\r\nsctp_allassocs_info_t *assoc_info;\r\nsctp_assoc_info_t *info = NULL;\r\nGList* list;\r\nassoc_info = &sctp_tapinfo_struct;\r\nif ((list = g_list_last(assoc_info->assoc_info_list))!=NULL)\r\n{\r\nwhile (list)\r\n{\r\ninfo = (sctp_assoc_info_t*)(list->data);\r\nif (needle->assoc_id == info->assoc_id)\r\nreturn info;\r\nlist = g_list_previous(list);\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic sctp_assoc_info_t * add_chunk_count(address * vadd, sctp_assoc_info_t * info, guint32 direction, guint32 type)\r\n{\r\nGList *list;\r\naddress *v=NULL;\r\nsctp_addr_chunk *ch=NULL;\r\nguint8 * dat;\r\nint i;\r\nlist = g_list_first(info->addr_chunk_count);\r\nwhile (list)\r\n{\r\nch = (sctp_addr_chunk *)(list->data);\r\nif (ch->direction == direction)\r\n{\r\nv = (address *) (ch->addr);\r\nif (ADDRESSES_EQUAL(vadd, v))\r\n{\r\nif (IS_SCTP_CHUNK_TYPE(type))\r\nch->addr_count[type]++;\r\nelse\r\nch->addr_count[OTHER_CHUNKS_INDEX]++;\r\nreturn info;\r\n}\r\nelse\r\n{\r\nlist = g_list_next(list);\r\n}\r\n}\r\nelse\r\nlist = g_list_next(list);\r\n}\r\nch = (sctp_addr_chunk *)g_malloc(sizeof(sctp_addr_chunk));\r\nch->direction = direction;\r\nch->addr = (address *)g_malloc(sizeof(address));\r\nch->addr->type = vadd->type;\r\nch->addr->len = vadd->len;\r\ndat = (guint8 *)g_malloc(vadd->len);\r\nmemcpy(dat, vadd->data, vadd->len);\r\nch->addr->data = dat;\r\nfor (i=0; i < NUM_CHUNKS; i++)\r\nch->addr_count[i] = 0;\r\nif (IS_SCTP_CHUNK_TYPE(type))\r\nch->addr_count[type]++;\r\nelse\r\nch->addr_count[OTHER_CHUNKS_INDEX]++;\r\ninfo->addr_chunk_count = g_list_append(info->addr_chunk_count, ch);\r\nreturn info;\r\n}\r\nstatic sctp_assoc_info_t * add_address(address * vadd, sctp_assoc_info_t *info, guint16 direction)\r\n{\r\nGList *list;\r\naddress *v=NULL;\r\nif (direction == 1)\r\nlist = g_list_first(info->addr1);\r\nelse\r\nlist = g_list_first(info->addr2);\r\nwhile (list)\r\n{\r\nv = (address *) (list->data);\r\nif (ADDRESSES_EQUAL(vadd, v)) {\r\ng_free(vadd);\r\nreturn info;\r\n}\r\nlist = g_list_next(list);\r\n}\r\nif (direction == 1)\r\ninfo->addr1 = g_list_append(info->addr1, vadd);\r\nelse if (direction==2)\r\ninfo->addr2 = g_list_append(info->addr2, vadd);\r\nreturn info;\r\n}\r\nstatic int\r\npacket(void *tapdata _U_, packet_info *pinfo , epan_dissect_t *edt _U_ , const void *data)\r\n{\r\nconst struct _sctp_info *sctp_info = (const struct _sctp_info *) data;\r\nguint32 chunk_number = 0, tsnumber,framenumber;\r\nsctp_tmp_info_t tmp_info;\r\nsctp_assoc_info_t *info = NULL;\r\nsctp_error_info_t *error = NULL;\r\nguint16 type, length = 0;\r\naddress *store = NULL;\r\ntsn_t *tsn = NULL;\r\ntsn_t *sack = NULL;\r\nguint8 *t_s_n = NULL;\r\ngboolean sackchunk = FALSE;\r\ngboolean datachunk = FALSE;\r\ngboolean forwardchunk = FALSE;\r\nstruct tsn_sort *tsn_s;\r\nguint8* addr = NULL;\r\nint i;\r\nguint8 idx = 0;\r\nframenumber=pinfo->fd->num;\r\ntype = sctp_info->ip_src.type;\r\nif (type == AT_IPv4)\r\n{\r\ntmp_info.src.type = AT_IPv4;\r\ntmp_info.src.len = 4;\r\n}\r\nelse if (type == AT_IPv6)\r\n{\r\ntmp_info.src.type = AT_IPv6;\r\ntmp_info.src.len = 16;\r\n}\r\nelse\r\n{\r\ntmp_info.src.type = AT_NONE;\r\ntmp_info.src.len = 0;\r\n}\r\naddr = (guint8 *)g_malloc(tmp_info.src.len);\r\nmemcpy(addr, sctp_info->ip_src.data, tmp_info.src.len);\r\ntmp_info.src.data = addr;\r\ntype = sctp_info->ip_dst.type;\r\nif (type == AT_IPv4)\r\n{\r\ntmp_info.dst.type = AT_IPv4;\r\ntmp_info.dst.len = 4;\r\n}\r\nelse if (type == AT_IPv6)\r\n{\r\ntmp_info.dst.type = AT_IPv6;\r\ntmp_info.dst.len = 16;\r\n}\r\nelse\r\n{\r\ntmp_info.dst.type = AT_NONE;\r\ntmp_info.dst.len = 0;\r\n}\r\naddr = (guint8 *)g_malloc(tmp_info.dst.len);\r\nmemcpy(addr, sctp_info->ip_dst.data, tmp_info.dst.len);\r\ntmp_info.dst.data = addr;\r\ntmp_info.port1 = sctp_info->sport;\r\ntmp_info.port2 = sctp_info->dport;\r\nif (sctp_info->vtag_reflected)\r\n{\r\ntmp_info.verification_tag2 = sctp_info->verification_tag;\r\ntmp_info.verification_tag1 = 0;\r\n}\r\nelse\r\n{\r\ntmp_info.verification_tag1 = sctp_info->verification_tag;\r\ntmp_info.verification_tag2 = 0;\r\n}\r\ntmp_info.n_tvbs = 0;\r\nif (tvb_get_guint8(sctp_info->tvb[0],0) == SCTP_INIT_CHUNK_ID)\r\n{\r\ntmp_info.initiate_tag = tvb_get_ntohl(sctp_info->tvb[0], 4);\r\n}\r\nelse\r\n{\r\ntmp_info.initiate_tag = 0;\r\n}\r\ntmp_info.direction = sctp_info->direction;\r\ntmp_info.assoc_id = sctp_info->assoc_index;\r\ninfo = find_assoc(&tmp_info);\r\nif (!info)\r\n{\r\ntmp_info.n_tvbs = sctp_info->number_of_tvbs;\r\nsctp_tapinfo_struct.sum_tvbs+=sctp_info->number_of_tvbs;\r\nif (sctp_info->number_of_tvbs > 0)\r\n{\r\ninfo = (sctp_assoc_info_t *)g_malloc(sizeof(sctp_assoc_info_t));\r\nmemset(info, 0, sizeof(sctp_assoc_info_t));\r\ninfo->assoc_id = sctp_info->assoc_index;\r\ninfo->src.type = tmp_info.src.type;\r\ninfo->src.len = tmp_info.src.len;\r\naddr = (guint8 *)g_malloc(tmp_info.dst.len);\r\nmemcpy(addr,(tmp_info.src.data), tmp_info.src.len);\r\ninfo->src.data = addr;\r\ninfo->dst.type = tmp_info.dst.type;\r\ninfo->dst.len = tmp_info.dst.len;\r\naddr = (guint8 *)g_malloc(tmp_info.dst.len);\r\nmemcpy(addr, (tmp_info.dst.data), tmp_info.dst.len);\r\ninfo->dst.data = addr;\r\ninfo->port1 = tmp_info.port1;\r\ninfo->port2 = tmp_info.port2;\r\ninfo->verification_tag1 = tmp_info.verification_tag1;\r\ninfo->verification_tag2 = tmp_info.verification_tag2;\r\ninfo->initiate_tag = tmp_info.initiate_tag;\r\ninfo->n_tvbs = tmp_info.n_tvbs;\r\ninfo->init = FALSE;\r\ninfo->initack = FALSE;\r\ninfo->check_address = FALSE;\r\ninfo->direction = 0;\r\ninfo = calc_checksum(sctp_info, info);\r\ninfo->n_packets = 1;\r\ninfo->error_info_list = NULL;\r\ninfo->min_secs = 0xffffffff;\r\ninfo->min_usecs = 0xffffffff;\r\ninfo->max_secs = 0;\r\ninfo->max_usecs = 0;\r\ninfo->min_tsn2 = 0xFFFFFFFF;\r\ninfo->min_tsn1 = 0xffffffff;\r\ninfo->max_tsn1 = 0;\r\ninfo->max_tsn2 = 0;\r\ninfo->max_bytes1 = 0;\r\ninfo->max_bytes2 = 0;\r\ninfo->n_data_chunks = 0;\r\ninfo->n_data_bytes = 0;\r\ninfo->n_data_chunks_ep1 = 0;\r\ninfo->n_data_bytes_ep1 = 0;\r\ninfo->n_data_chunks_ep2 = 0;\r\ninfo->n_data_bytes_ep2 = 0;\r\ninfo->n_sack_chunks_ep1 = 0;\r\ninfo->n_sack_chunks_ep2 = 0;\r\ninfo->n_array_tsn1 = 0;\r\ninfo->n_array_tsn2 = 0;\r\ninfo->n_forward_chunks = 0;\r\ninfo->max_window1 = 0;\r\ninfo->max_window2 = 0;\r\ninfo->min_max = NULL;\r\ninfo->sort_tsn1 = g_ptr_array_new();\r\ninfo->sort_tsn2 = g_ptr_array_new();\r\ninfo->sort_sack1 = g_ptr_array_new();\r\ninfo->sort_sack2 = g_ptr_array_new();\r\nfor (i=0; i < NUM_CHUNKS; i++)\r\n{\r\ninfo->chunk_count[i] = 0;\r\ninfo->ep1_chunk_count[i] = 0;\r\ninfo->ep2_chunk_count[i] = 0;\r\n}\r\ninfo->addr_chunk_count = NULL;\r\nif (((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_INIT_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_INIT_ACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_DATA_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_SACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_NR_SACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_FORWARD_TSN_CHUNK_ID))\r\n{\r\ntsn = (tsn_t *)g_malloc(sizeof(tsn_t));\r\nsack = (tsn_t *)g_malloc(sizeof(tsn_t));\r\ntsn->tsns = NULL;\r\ntsn->first_tsn = 0;\r\nsack->tsns = NULL;\r\nsack->first_tsn = 0;\r\nsack->src.type=tsn->src.type = tmp_info.src.type;\r\nsack->src.len=tsn->src.len = tmp_info.src.len;\r\naddr = (guint8 *)g_malloc(tmp_info.src.len);\r\nmemcpy(addr, tmp_info.src.data, tmp_info.src.len);\r\ntsn->src.data = addr;\r\naddr = (guint8 *)g_malloc(tmp_info.src.len);\r\nmemcpy(addr, tmp_info.src.data, tmp_info.src.len);\r\nsack->src.data = addr;\r\nsack->dst.type = tsn->dst.type = tmp_info.dst.type;\r\nsack->dst.len =tsn->dst.len = tmp_info.dst.len;\r\naddr = (guint8 *)g_malloc(tmp_info.dst.len);\r\nmemcpy(addr, tmp_info.dst.data, tmp_info.dst.len);\r\ntsn->dst.data = addr;\r\naddr = (guint8 *)g_malloc(tmp_info.dst.len);\r\nmemcpy(addr, tmp_info.dst.data, tmp_info.dst.len);\r\nsack->dst.data = addr;\r\nsack->secs=tsn->secs = (guint32)pinfo->rel_ts.secs;\r\nsack->usecs=tsn->usecs = (guint32)pinfo->rel_ts.nsecs/1000;\r\nif (((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_DATA_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_SACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_NR_SACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_FORWARD_TSN_CHUNK_ID))\r\n{\r\nif (tsn->secs < info->min_secs)\r\n{\r\ninfo->min_secs = tsn->secs;\r\ninfo->min_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->min_secs && tsn->usecs < info->min_usecs)\r\ninfo->min_usecs = tsn->usecs;\r\nif (tsn->secs > info->max_secs)\r\n{\r\ninfo->max_secs = tsn->secs;\r\ninfo->max_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->max_secs && tsn->usecs > info->max_usecs)\r\ninfo->max_usecs = tsn->usecs;\r\n}\r\nsack->frame_number = tsn->frame_number = pinfo->fd->num;\r\n}\r\nif ((tvb_get_guint8(sctp_info->tvb[0],0) == SCTP_INIT_CHUNK_ID) || (tvb_get_guint8(sctp_info->tvb[0],0) == SCTP_INIT_ACK_CHUNK_ID))\r\n{\r\ninfo->min_tsn1 = tvb_get_ntohl(sctp_info->tvb[0],INIT_CHUNK_INITIAL_TSN_OFFSET);\r\ninfo->verification_tag2 = tvb_get_ntohl(sctp_info->tvb[0], INIT_CHUNK_INITIATE_TAG_OFFSET);\r\ninfo->instream1 = tvb_get_ntohs(sctp_info->tvb[0],INIT_CHUNK_NUMBER_OF_INBOUND_STREAMS_OFFSET);\r\ninfo->outstream1 = tvb_get_ntohs(sctp_info->tvb[0],INIT_CHUNK_NUMBER_OF_OUTBOUND_STREAMS_OFFSET);\r\ninfo->arwnd1 = tvb_get_ntohl(sctp_info->tvb[0], INIT_CHUNK_ADV_REC_WINDOW_CREDIT_OFFSET);\r\nfor (chunk_number = 1; chunk_number < sctp_info->number_of_tvbs; chunk_number++)\r\n{\r\ntype = tvb_get_ntohs(sctp_info->tvb[chunk_number],0);\r\nif (type == IPV4ADDRESS_PARAMETER_ID)\r\n{\r\nstore = (address *)g_malloc(sizeof (address));\r\nstore->type = AT_IPv4;\r\nstore->len = 4;\r\nstore->data = g_malloc(4);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (void *)store->data,IPV4_ADDRESS_OFFSET, 4);\r\ninfo = add_address(store, info, 1);\r\n}\r\nelse if (type == IPV6ADDRESS_PARAMETER_ID)\r\n{\r\nstore = (address *)g_malloc(sizeof (address));\r\nstore->type = AT_IPv6;\r\nstore->len = 16;\r\nstore->data = g_malloc(16);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (guint8 *)(store->data),IPV6_ADDRESS_OFFSET, IPV6_ADDRESS_LENGTH);\r\ninfo = add_address(store, info, 1);\r\n}\r\n}\r\nif (tvb_get_guint8(sctp_info->tvb[0],0) == SCTP_INIT_CHUNK_ID)\r\n{\r\ninfo->init = TRUE;\r\n}\r\nelse\r\n{\r\ninfo->initack_dir = 1;\r\ninfo->initack = TRUE;\r\n}\r\nidx = tvb_get_guint8(sctp_info->tvb[0],0);\r\nif (!IS_SCTP_CHUNK_TYPE(idx))\r\nidx = OTHER_CHUNKS_INDEX;\r\ninfo->chunk_count[idx]++;\r\ninfo->ep1_chunk_count[idx]++;\r\ninfo = add_chunk_count(&tmp_info.src, info, 1, idx);\r\n}\r\nelse\r\n{\r\nif (((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_INIT_CHUNK_ID) &&\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_INIT_ACK_CHUNK_ID) &&\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_DATA_CHUNK_ID) &&\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_SACK_CHUNK_ID) &&\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_NR_SACK_CHUNK_ID) &&\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_FORWARD_TSN_CHUNK_ID))\r\n{\r\ntsn = (tsn_t *)g_malloc(sizeof(tsn_t));\r\nsack = (tsn_t *)g_malloc(sizeof(tsn_t));\r\ntsn->tsns = NULL;\r\nsack->tsns = NULL;\r\ntsn->first_tsn = 0;\r\nsack->first_tsn = 0;\r\n}\r\nfor (chunk_number = 0; chunk_number < sctp_info->number_of_tvbs; chunk_number++)\r\n{\r\nidx = tvb_get_guint8(sctp_info->tvb[0],0);\r\nif (!IS_SCTP_CHUNK_TYPE(idx))\r\nidx = OTHER_CHUNKS_INDEX;\r\ninfo->chunk_count[idx]++;\r\ninfo->ep1_chunk_count[idx]++;\r\ninfo = add_chunk_count(&tmp_info.src, info, 1, idx);\r\nif ((tvb_get_guint8(sctp_info->tvb[chunk_number],0) == SCTP_DATA_CHUNK_ID))\r\n{\r\ndatachunk = TRUE;\r\nlength = tvb_get_ntohs(sctp_info->tvb[chunk_number], CHUNK_LENGTH_OFFSET)-DATA_CHUNK_HEADER_LENGTH;\r\ninfo->n_data_chunks++;\r\ninfo->n_data_bytes+=length;\r\ninfo->outstream1 = tvb_get_ntohs((sctp_info->tvb)[chunk_number], DATA_CHUNK_STREAM_ID_OFFSET)+1;\r\n}\r\nif ((tvb_get_guint8(sctp_info->tvb[chunk_number],0) == SCTP_FORWARD_TSN_CHUNK_ID))\r\n{\r\nforwardchunk = TRUE;\r\nlength = tvb_get_ntohs(sctp_info->tvb[chunk_number], CHUNK_LENGTH_OFFSET);\r\ninfo->n_forward_chunks++;\r\n}\r\nif (datachunk || forwardchunk)\r\n{\r\ntsnumber = tvb_get_ntohl((sctp_info->tvb)[chunk_number], DATA_CHUNK_TSN_OFFSET);\r\nif (tsnumber < info->min_tsn1)\r\ninfo->min_tsn1 = tsnumber;\r\nif (tsnumber > info->max_tsn1)\r\n{\r\nif (datachunk)\r\n{\r\ninfo->n_data_chunks_ep1++;\r\ninfo->n_data_bytes_ep1+=length;\r\n}\r\nelse\r\ninfo->n_forward_chunks_ep1++;\r\ninfo->max_tsn1 = tsnumber;\r\n}\r\nif (tsn->first_tsn == 0)\r\ntsn->first_tsn = tsnumber;\r\nif (datachunk)\r\n{\r\nt_s_n = (guint8 *)g_malloc(16);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (guint8 *)(t_s_n),0, 16);\r\n}\r\nelse\r\n{\r\nt_s_n = (guint8 *)g_malloc(length);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (guint8 *)(t_s_n),0, length);\r\n}\r\ntsn->tsns = g_list_append(tsn->tsns, t_s_n);\r\ntsn_s = (struct tsn_sort *)g_malloc(sizeof(struct tsn_sort));\r\ntsn_s->tsnumber = tsnumber;\r\ntsn_s->secs = tsn->secs = (guint32)pinfo->rel_ts.secs;\r\ntsn_s->usecs = tsn->usecs = (guint32)pinfo->rel_ts.nsecs/1000;\r\ntsn_s->offset = 0;\r\ntsn_s->framenumber = framenumber;\r\nif (datachunk)\r\ntsn_s->length = length-DATA_CHUNK_HEADER_LENGTH;\r\nelse\r\ntsn_s->length = length;\r\nif (tsn->secs < info->min_secs)\r\n{\r\ninfo->min_secs = tsn->secs;\r\ninfo->min_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->min_secs && tsn->usecs < info->min_usecs)\r\ninfo->min_usecs = tsn->usecs;\r\nif (tsn->secs > info->max_secs)\r\n{\r\ninfo->max_secs = tsn->secs;\r\ninfo->max_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->max_secs && tsn->usecs > info->max_usecs)\r\ninfo->max_usecs = tsn->usecs;\r\ng_ptr_array_add(info->sort_tsn1, tsn_s);\r\ninfo->n_array_tsn1++;\r\n}\r\nif ((tvb_get_guint8(sctp_info->tvb[chunk_number],0) == SCTP_SACK_CHUNK_ID) ||\r\n(tvb_get_guint8(sctp_info->tvb[chunk_number],0) == SCTP_NR_SACK_CHUNK_ID) )\r\n{\r\ntsnumber = tvb_get_ntohl((sctp_info->tvb)[chunk_number], SACK_CHUNK_CUMULATIVE_TSN_ACK_OFFSET);\r\nif (tsnumber < info->min_tsn2)\r\ninfo->min_tsn2 = tsnumber;\r\nif (tsnumber > info->max_tsn2)\r\ninfo->max_tsn2 = tsnumber;\r\nlength = tvb_get_ntohs(sctp_info->tvb[chunk_number], CHUNK_LENGTH_OFFSET);\r\nif (sack->first_tsn == 0)\r\nsack->first_tsn = tsnumber;\r\nt_s_n = (guint8 *)g_malloc(length);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (guint8 *)(t_s_n),0, length);\r\nsack->tsns = g_list_append(sack->tsns, t_s_n);\r\nsackchunk = TRUE;\r\ntsn_s = (struct tsn_sort *)g_malloc(sizeof(struct tsn_sort));\r\ntsn_s->tsnumber = tsnumber;\r\ntsn_s->secs = tsn->secs = (guint32)pinfo->rel_ts.secs;\r\ntsn_s->usecs = tsn->usecs = (guint32)pinfo->rel_ts.nsecs/1000;\r\ntsn_s->offset = 0;\r\ntsn_s->framenumber = framenumber;\r\ntsn_s->length = tvb_get_ntohl(sctp_info->tvb[chunk_number], SACK_CHUNK_ADV_REC_WINDOW_CREDIT_OFFSET);\r\nif (tsn_s->length > info->max_window1)\r\ninfo->max_window1 = tsn_s->length;\r\nif (tsn->secs < info->min_secs)\r\n{\r\ninfo->min_secs = tsn->secs;\r\ninfo->min_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->min_secs && tsn->usecs < info->min_usecs)\r\ninfo->min_usecs = tsn->usecs;\r\nif (tsn->secs > info->max_secs)\r\n{\r\ninfo->max_secs = tsn->secs;\r\ninfo->max_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->max_secs && tsn->usecs > info->max_usecs)\r\ninfo->max_usecs = tsn->usecs;\r\ng_ptr_array_add(info->sort_sack2, tsn_s);\r\ninfo->n_sack_chunks_ep2++;\r\n}\r\n}\r\n}\r\nif (info->verification_tag1 != 0 || info->verification_tag2 != 0)\r\n{\r\nstore = (address *)g_malloc(sizeof (address));\r\nstore->type = tmp_info.src.type;\r\nstore->len = tmp_info.src.len;\r\naddr = (guint8 *)g_malloc(tmp_info.src.len);\r\nmemcpy(addr,(tmp_info.src.data),tmp_info.src.len);\r\nstore->data = addr;\r\ninfo = add_address(store, info, 1);\r\nstore = (address *)g_malloc(sizeof (address));\r\nstore->type = tmp_info.dst.type;\r\nstore->len = tmp_info.dst.len;\r\naddr = (guint8 *)g_malloc(tmp_info.dst.len);\r\nmemcpy(addr,(tmp_info.dst.data),tmp_info.dst.len);\r\nstore->data = addr;\r\ninfo = add_address(store, info, 2);\r\ninfo->frame_numbers=g_list_prepend(info->frame_numbers,&(pinfo->fd->num));\r\nif (datachunk || forwardchunk)\r\ninfo->tsn1 = g_list_prepend(info->tsn1, tsn);\r\nif (sackchunk == TRUE)\r\ninfo->sack2 = g_list_prepend(info->sack2, sack);\r\nsctp_tapinfo_struct.assoc_info_list = g_list_append(sctp_tapinfo_struct.assoc_info_list, info);\r\n}\r\nelse\r\n{\r\nerror = (sctp_error_info_t *)g_malloc(sizeof(sctp_error_info_t));\r\nerror->frame_number = pinfo->fd->num;\r\nerror->chunk_info[0] = '\0';\r\nif ((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_INIT_CHUNK_ID)\r\ng_strlcpy(error->chunk_info, val_to_str(tvb_get_guint8(sctp_info->tvb[0],0),chunk_type_values,"Reserved"), 200);\r\nelse\r\nfor (chunk_number = 0; chunk_number < sctp_info->number_of_tvbs; chunk_number++)\r\ng_strlcat(error->chunk_info, val_to_str(tvb_get_guint8(sctp_info->tvb[chunk_number],0),chunk_type_values,"Reserved"), 200);\r\nerror->info_text = "INFOS";\r\ninfo->error_info_list = g_list_append(info->error_info_list, error);\r\n}\r\n}\r\n}\r\nelse\r\n{\r\ninfo->direction = sctp_info->direction;\r\nif (info->verification_tag1 == 0 && info->verification_tag2 != sctp_info->verification_tag) {\r\ninfo->verification_tag1 = sctp_info->verification_tag;\r\n} else if (info->verification_tag2 == 0 && info->verification_tag1 != sctp_info->verification_tag) {\r\ninfo->verification_tag2 = sctp_info->verification_tag;\r\n}\r\nif (((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_INIT_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_INIT_ACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_DATA_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_SACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_NR_SACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_FORWARD_TSN_CHUNK_ID))\r\n{\r\ntsn = (tsn_t *)g_malloc(sizeof(tsn_t));\r\nsack = (tsn_t *)g_malloc(sizeof(tsn_t));\r\ntsn->tsns = NULL;\r\ntsn->first_tsn = 0;\r\nsack->tsns = NULL;\r\nsack->first_tsn = 0;\r\nsack->src.type = tsn->src.type = tmp_info.src.type;\r\nsack->src.len = tsn->src.len = tmp_info.src.len;\r\naddr = (guint8 *)g_malloc(tmp_info.src.len);\r\nmemcpy(addr, tmp_info.src.data, tmp_info.src.len);\r\ntsn->src.data = addr;\r\naddr = (guint8 *)g_malloc(tmp_info.src.len);\r\nmemcpy(addr, tmp_info.src.data, tmp_info.src.len);\r\nsack->src.data = addr;\r\nsack->dst.type = tsn->dst.type = tmp_info.dst.type;\r\nsack->dst.len = tsn->dst.len = tmp_info.dst.len;\r\naddr = (guint8 *)g_malloc(tmp_info.dst.len);\r\nmemcpy(addr, tmp_info.dst.data, tmp_info.dst.len);\r\ntsn->dst.data = addr;\r\naddr = (guint8 *)g_malloc(tmp_info.dst.len);\r\nmemcpy(addr, tmp_info.dst.data, tmp_info.dst.len);\r\nsack->dst.data = addr;\r\nsack->secs=tsn->secs = (guint32)pinfo->rel_ts.secs;\r\nsack->usecs=tsn->usecs = (guint32)pinfo->rel_ts.nsecs/1000;\r\nif (((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_DATA_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_SACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_NR_SACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_FORWARD_TSN_CHUNK_ID))\r\n{\r\nif (tsn->secs < info->min_secs)\r\n{\r\ninfo->min_secs = tsn->secs;\r\ninfo->min_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->min_secs && tsn->usecs < info->min_usecs)\r\ninfo->min_usecs = tsn->usecs;\r\nif (tsn->secs > info->max_secs)\r\n{\r\ninfo->max_secs = tsn->secs;\r\ninfo->max_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->max_secs && tsn->usecs > info->max_usecs)\r\ninfo->max_usecs = tsn->usecs;\r\n}\r\nsack->frame_number = tsn->frame_number = pinfo->fd->num;\r\n}\r\ninfo->frame_numbers = g_list_prepend(info->frame_numbers,&(pinfo->fd->num));\r\nstore = (address *)g_malloc(sizeof (address));\r\nstore->type = tmp_info.src.type;\r\nstore->len = tmp_info.src.len;\r\naddr = (guint8 *)g_malloc(tmp_info.src.len);\r\nmemcpy(addr,(tmp_info.src.data),tmp_info.src.len);\r\nstore->data = addr;\r\nif (info->direction == 1)\r\ninfo = add_address(store, info, 1);\r\nelse if (info->direction == 2)\r\ninfo = add_address(store, info, 2);\r\nstore = (address *)g_malloc(sizeof (address));\r\nstore->type = tmp_info.dst.type;\r\nstore->len = tmp_info.dst.len;\r\naddr = (guint8 *)g_malloc(tmp_info.dst.len);\r\nmemcpy(addr,(tmp_info.dst.data),tmp_info.dst.len);\r\nstore->data = addr;\r\nif (info->direction == 1)\r\ninfo = add_address(store, info, 2);\r\nelse if (info->direction == 2)\r\ninfo = add_address(store, info, 1);\r\nif (((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_INIT_ACK_CHUNK_ID) ||\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_INIT_CHUNK_ID))\r\n{\r\ntsnumber = tvb_get_ntohl((sctp_info->tvb)[chunk_number], INIT_CHUNK_INITIAL_TSN_OFFSET);\r\nif (info->direction == 2)\r\n{\r\nif (tsnumber < info->min_tsn2)\r\ninfo->min_tsn2 = tsnumber;\r\nif (tsnumber > info->max_tsn2)\r\ninfo->max_tsn2 = tsnumber;\r\ninfo->instream2 = tvb_get_ntohs(sctp_info->tvb[0],INIT_CHUNK_NUMBER_OF_INBOUND_STREAMS_OFFSET);\r\ninfo->outstream2 = tvb_get_ntohs(sctp_info->tvb[0],INIT_CHUNK_NUMBER_OF_OUTBOUND_STREAMS_OFFSET);\r\ninfo->arwnd2 = tvb_get_ntohl(sctp_info->tvb[0],INIT_CHUNK_ADV_REC_WINDOW_CREDIT_OFFSET);\r\ninfo->tsn2 = g_list_prepend(info->tsn2, tsn);\r\n}\r\nelse if (info->direction == 1)\r\n{\r\nif (tsnumber < info->min_tsn1)\r\ninfo->min_tsn1 = tsnumber;\r\nif (tsnumber > info->max_tsn1)\r\ninfo->max_tsn1 = tsnumber;\r\ninfo->instream1 = tvb_get_ntohs(sctp_info->tvb[0],INIT_CHUNK_NUMBER_OF_INBOUND_STREAMS_OFFSET);\r\ninfo->outstream1 = tvb_get_ntohs(sctp_info->tvb[0],INIT_CHUNK_NUMBER_OF_OUTBOUND_STREAMS_OFFSET);\r\ninfo->arwnd1 = tvb_get_ntohl(sctp_info->tvb[0],INIT_CHUNK_ADV_REC_WINDOW_CREDIT_OFFSET);\r\ninfo->tsn1 = g_list_prepend(info->tsn1, tsn);\r\n}\r\nidx = tvb_get_guint8(sctp_info->tvb[0],0);\r\nif (!IS_SCTP_CHUNK_TYPE(idx))\r\nidx = OTHER_CHUNKS_INDEX;\r\ninfo->chunk_count[idx]++;\r\nif (info->direction == 1)\r\ninfo->ep1_chunk_count[idx]++;\r\nelse\r\ninfo->ep2_chunk_count[idx]++;\r\ninfo = add_chunk_count(&tmp_info.src, info, info->direction, idx);\r\nfor (chunk_number = 1; chunk_number < sctp_info->number_of_tvbs; chunk_number++)\r\n{\r\ntype = tvb_get_ntohs(sctp_info->tvb[chunk_number],0);\r\nif (type == IPV4ADDRESS_PARAMETER_ID)\r\n{\r\nstore = (address *)g_malloc(sizeof (address));\r\nstore->type = AT_IPv4;\r\nstore->len = 4;\r\nstore->data = g_malloc(4);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (guint8 *)(store->data),IPV4_ADDRESS_OFFSET, 4);\r\ninfo = add_address(store, info, info->direction);\r\n}\r\nelse if (type == IPV6ADDRESS_PARAMETER_ID)\r\n{\r\nstore = (address *)g_malloc(sizeof (address));\r\nstore->type = AT_IPv6;\r\nstore->len = 16;\r\nstore->data = g_malloc(16);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (guint8 *)(store->data),IPV6_ADDRESS_OFFSET, IPV6_ADDRESS_LENGTH);\r\ninfo = add_address(store, info, info->direction);\r\n}\r\n}\r\nif ((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_INIT_ACK_CHUNK_ID)\r\n{\r\ninfo->initack = TRUE;\r\ninfo->initack_dir = info->direction;\r\n}\r\nelse\r\nif ((tvb_get_guint8(sctp_info->tvb[0],0)) == SCTP_INIT_CHUNK_ID)\r\n{\r\ninfo->init = TRUE;\r\n}\r\n}\r\nelse\r\n{\r\nif (((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_INIT_ACK_CHUNK_ID) &&\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_DATA_CHUNK_ID) &&\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_SACK_CHUNK_ID) &&\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_NR_SACK_CHUNK_ID) &&\r\n((tvb_get_guint8(sctp_info->tvb[0],0)) != SCTP_FORWARD_TSN_CHUNK_ID))\r\n{\r\nsack = (tsn_t *)g_malloc(sizeof(tsn_t));\r\nsack->tsns = NULL;\r\nsack->first_tsn = 0;\r\ntsn = (tsn_t *)g_malloc(sizeof(tsn_t));\r\ntsn->tsns = NULL;\r\ntsn->first_tsn = 0;\r\n}\r\nfor (chunk_number = 0; chunk_number < sctp_info->number_of_tvbs; chunk_number++)\r\n{\r\nidx = tvb_get_guint8(sctp_info->tvb[chunk_number],0);\r\nif (!IS_SCTP_CHUNK_TYPE(idx))\r\nidx = OTHER_CHUNKS_INDEX;\r\ninfo->chunk_count[idx]++;\r\nif (info->direction == 1)\r\ninfo->ep1_chunk_count[idx]++;\r\nelse\r\ninfo->ep2_chunk_count[idx]++;\r\ninfo = add_chunk_count(&tmp_info.src, info,info->direction, idx);\r\nif (((tvb_get_guint8(sctp_info->tvb[chunk_number],0)) == SCTP_DATA_CHUNK_ID))\r\ndatachunk = TRUE;\r\nif (((tvb_get_guint8(sctp_info->tvb[chunk_number],0)) == SCTP_FORWARD_TSN_CHUNK_ID))\r\nforwardchunk = TRUE;\r\nif ((datachunk || forwardchunk) && tsn != NULL)\r\n{\r\ntsnumber = tvb_get_ntohl((sctp_info->tvb)[chunk_number], DATA_CHUNK_TSN_OFFSET);\r\nif (tsn->first_tsn == 0)\r\ntsn->first_tsn = tsnumber;\r\nif (datachunk)\r\n{\r\nt_s_n = (guint8 *)g_malloc(16);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (guint8 *)(t_s_n),0, 16);\r\nlength=tvb_get_ntohs(sctp_info->tvb[chunk_number], CHUNK_LENGTH_OFFSET)-DATA_CHUNK_HEADER_LENGTH;\r\ninfo->n_data_chunks++;\r\ninfo->n_data_bytes+=length;\r\n}\r\nelse\r\n{\r\nlength=tvb_get_ntohs(sctp_info->tvb[chunk_number], CHUNK_LENGTH_OFFSET);\r\nt_s_n = (guint8 *)g_malloc(length);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (guint8 *)(t_s_n),0, length);\r\ninfo->n_forward_chunks++;\r\n}\r\ntsn->tsns = g_list_append(tsn->tsns, t_s_n);\r\ntsn_s = (struct tsn_sort *)g_malloc(sizeof(struct tsn_sort));\r\ntsn_s->tsnumber = tsnumber;\r\ntsn_s->secs = tsn->secs = (guint32)pinfo->rel_ts.secs;\r\ntsn_s->usecs = tsn->usecs = (guint32)pinfo->rel_ts.nsecs/1000;\r\ntsn_s->offset = 0;\r\ntsn_s->framenumber = framenumber;\r\ntsn_s->length = length;\r\nif (tsn->secs < info->min_secs)\r\n{\r\ninfo->min_secs = tsn->secs;\r\ninfo->min_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->min_secs && tsn->usecs < info->min_usecs)\r\ninfo->min_usecs = tsn->usecs;\r\nif (tsn->secs > info->max_secs)\r\n{\r\ninfo->max_secs = tsn->secs;\r\ninfo->max_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->max_secs && tsn->usecs > info->max_usecs)\r\ninfo->max_usecs = tsn->usecs;\r\nif (info->direction == 1)\r\n{\r\nif(tsnumber < info->min_tsn1)\r\ninfo->min_tsn1 = tsnumber;\r\nif ((info->init == TRUE || (info->initack == TRUE && info->initack_dir == 1))&& tsnumber >= info->min_tsn1 && tsnumber <= info->max_tsn1)\r\n{\r\nif (datachunk)\r\n{\r\ninfo->n_data_chunks_ep1++;\r\ninfo->n_data_bytes_ep1 += length;\r\n}\r\nelse if (forwardchunk)\r\n{\r\ninfo->n_forward_chunks_ep1++;\r\n}\r\n}\r\nif(tsnumber > info->max_tsn1)\r\n{\r\ninfo->max_tsn1 = tsnumber;\r\nif (datachunk)\r\n{\r\ninfo->n_data_chunks_ep1++;\r\ninfo->n_data_bytes_ep1 += length;\r\n}\r\nelse if (forwardchunk)\r\n{\r\ninfo->n_forward_chunks_ep1++;\r\n}\r\n}\r\nif (datachunk)\r\n{\r\nif (info->init == FALSE)\r\ninfo->outstream1 = tvb_get_ntohs((sctp_info->tvb)[chunk_number], DATA_CHUNK_STREAM_ID_OFFSET)+1;\r\nif (info->initack == FALSE)\r\ninfo->instream2 = tvb_get_ntohs((sctp_info->tvb)[chunk_number], DATA_CHUNK_STREAM_ID_OFFSET)+1;\r\n}\r\ng_ptr_array_add(info->sort_tsn1, tsn_s);\r\ninfo->n_array_tsn1++;\r\n}\r\nelse if (info->direction == 2)\r\n{\r\nif(tsnumber < info->min_tsn2)\r\ninfo->min_tsn2 = tsnumber;\r\nif ((info->initack == TRUE && info->initack_dir == 2)&& tsnumber >= info->min_tsn2 && tsnumber <= info->max_tsn2)\r\n{\r\nif (datachunk)\r\n{\r\nlength = tvb_get_ntohs(sctp_info->tvb[chunk_number], CHUNK_LENGTH_OFFSET)-DATA_CHUNK_HEADER_LENGTH;\r\ninfo->n_data_chunks_ep2++;\r\ninfo->n_data_bytes_ep2+=length;\r\n}\r\nelse if (forwardchunk)\r\n{\r\ninfo->n_forward_chunks_ep2++;\r\n}\r\n}\r\nif(tsnumber > info->max_tsn2)\r\n{\r\ninfo->max_tsn2 = tsnumber;\r\nif (datachunk)\r\n{\r\nlength = tvb_get_ntohs(sctp_info->tvb[chunk_number], CHUNK_LENGTH_OFFSET)-DATA_CHUNK_HEADER_LENGTH;\r\ninfo->n_data_chunks_ep2++;\r\ninfo->n_data_bytes_ep2+=length;\r\n}\r\nelse if (forwardchunk)\r\n{\r\ninfo->n_forward_chunks_ep2++;\r\n}\r\n}\r\nif (datachunk)\r\n{\r\nif (info->init == FALSE)\r\ninfo->instream1 = tvb_get_ntohs((sctp_info->tvb)[chunk_number], DATA_CHUNK_STREAM_ID_OFFSET)+1;\r\nif (info->initack == FALSE)\r\ninfo->outstream2 = tvb_get_ntohs((sctp_info->tvb)[chunk_number], DATA_CHUNK_STREAM_ID_OFFSET)+1;\r\n}\r\ng_ptr_array_add(info->sort_tsn2, tsn_s);\r\ninfo->n_array_tsn2++;\r\n}\r\n}\r\nelse if (((tvb_get_guint8(sctp_info->tvb[chunk_number],0) == SCTP_SACK_CHUNK_ID) ||\r\n(tvb_get_guint8(sctp_info->tvb[chunk_number],0) == SCTP_NR_SACK_CHUNK_ID)) &&\r\nsack != NULL)\r\n{\r\ntsnumber = tvb_get_ntohl((sctp_info->tvb)[chunk_number], SACK_CHUNK_CUMULATIVE_TSN_ACK_OFFSET);\r\nlength = tvb_get_ntohs(sctp_info->tvb[chunk_number], CHUNK_LENGTH_OFFSET);\r\nif (sack->first_tsn == 0)\r\nsack->first_tsn = tsnumber;\r\nt_s_n = (guint8 *)g_malloc(length);\r\ntvb_memcpy(sctp_info->tvb[chunk_number], (guint8 *)(t_s_n),0, length);\r\nsack->tsns = g_list_append(sack->tsns, t_s_n);\r\nsackchunk = TRUE;\r\ntsn_s = (struct tsn_sort *)g_malloc(sizeof(struct tsn_sort));\r\ntsn_s->tsnumber = tsnumber;\r\ntsn_s->secs = tsn->secs = (guint32)pinfo->rel_ts.secs;\r\ntsn_s->usecs = tsn->usecs = (guint32)pinfo->rel_ts.nsecs/1000;\r\ntsn_s->offset = 0;\r\ntsn_s->framenumber = framenumber;\r\ntsn_s->length = tvb_get_ntohl(sctp_info->tvb[chunk_number], SACK_CHUNK_ADV_REC_WINDOW_CREDIT_OFFSET);\r\nif (tsn->secs < info->min_secs)\r\n{\r\ninfo->min_secs = tsn->secs;\r\ninfo->min_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->min_secs && tsn->usecs < info->min_usecs)\r\ninfo->min_usecs = tsn->usecs;\r\nif (tsn->secs > info->max_secs)\r\n{\r\ninfo->max_secs = tsn->secs;\r\ninfo->max_usecs = tsn->usecs;\r\n}\r\nelse if (tsn->secs == info->max_secs && tsn->usecs > info->max_usecs)\r\ninfo->max_usecs = tsn->usecs;\r\nif (info->direction == 2)\r\n{\r\nif(tsnumber < info->min_tsn1)\r\ninfo->min_tsn1 = tsnumber;\r\nif(tsnumber > info->max_tsn1)\r\ninfo->max_tsn1 = tsnumber;\r\nif (tsn_s->length > info->max_window1)\r\ninfo->max_window1 = tsn_s->length;\r\ng_ptr_array_add(info->sort_sack1, tsn_s);\r\ninfo->n_sack_chunks_ep1++;\r\n}\r\nelse if (info->direction == 1)\r\n{\r\nif(tsnumber < info->min_tsn2)\r\ninfo->min_tsn2 = tsnumber;\r\nif(tsnumber > info->max_tsn2)\r\ninfo->max_tsn2 = tsnumber;\r\nif (tsn_s->length > info->max_window2)\r\ninfo->max_window2 = tsn_s->length;\r\ng_ptr_array_add(info->sort_sack2, tsn_s);\r\ninfo->n_sack_chunks_ep2++;\r\n}\r\n}\r\n}\r\n}\r\nif (datachunk || forwardchunk)\r\n{\r\nif (info->direction == 1)\r\ninfo->tsn1 = g_list_prepend(info->tsn1, tsn);\r\nelse if (info->direction == 2)\r\ninfo->tsn2 = g_list_prepend(info->tsn2, tsn);\r\n}\r\nif (sackchunk == TRUE)\r\n{\r\nif (info->direction == 1)\r\ninfo->sack2 = g_list_prepend(info->sack2, sack);\r\nelse if(info->direction == 2)\r\ninfo->sack1 = g_list_prepend(info->sack1, sack);\r\n}\r\ninfo->n_tvbs += sctp_info->number_of_tvbs;\r\nsctp_tapinfo_struct.sum_tvbs += sctp_info->number_of_tvbs;\r\ninfo = calc_checksum(sctp_info, info);\r\ninfo->n_packets++;\r\n}\r\nreturn(1);\r\n}\r\nvoid\r\nremove_tap_listener_sctp_stat(void)\r\n{\r\nif (sctp_tapinfo_struct.is_registered) {\r\nremove_tap_listener(&sctp_tapinfo_struct);\r\nsctp_tapinfo_struct.is_registered = FALSE;\r\n}\r\n}\r\nvoid sctp_stat_scan(void)\r\n{\r\nif (!sctp_tapinfo_struct.is_registered)\r\nregister_tap_listener_sctp_stat();\r\n}\r\nconst sctp_allassocs_info_t* sctp_stat_get_info(void)\r\n{\r\nreturn &sctp_tapinfo_struct;\r\n}\r\nvoid\r\nregister_tap_listener_sctp_stat(void)\r\n{\r\nGString *error_string;\r\nif (!sctp_tapinfo_struct.is_registered)\r\n{\r\nif ((error_string = register_tap_listener("sctp", &sctp_tapinfo_struct, NULL, 0, reset, packet, NULL))) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "%s", error_string->str);\r\ng_string_free(error_string, TRUE);\r\nreturn;\r\n}\r\nsctp_tapinfo_struct.is_registered=TRUE;\r\n}\r\n}
