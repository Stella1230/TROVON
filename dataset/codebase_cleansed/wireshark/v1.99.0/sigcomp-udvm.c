tvbuff_t*\r\ndecompress_sigcomp_message(tvbuff_t *bytecode_tvb, tvbuff_t *message_tvb, packet_info *pinfo,\r\nproto_tree *udvm_tree, gint udvm_mem_dest,\r\ngint print_flags, gint hf_id,\r\ngint header_len,\r\ngint byte_code_state_len, gint byte_code_id_len,\r\ngint udvm_start_ip)\r\n{\r\ntvbuff_t *decomp_tvb;\r\nguint8 *buff = (guint8 *)ep_alloc0(UDVM_MEMORY_SIZE);\r\nchar string[2];\r\nguint8 *out_buff;\r\nguint32 i = 0;\r\nguint16 n = 0;\r\nguint16 m = 0;\r\nguint16 x;\r\nguint k = 0;\r\nguint16 H;\r\nguint16 oldH;\r\nguint offset = 0;\r\nguint result_dest;\r\nguint code_length =0;\r\nguint8 current_instruction;\r\nguint current_address;\r\nguint operand_address;\r\nguint input_address;\r\nguint16 output_address = 0;\r\nguint next_operand_address;\r\nguint8 octet;\r\nguint8 msb;\r\nguint8 lsb;\r\nguint16 byte_copy_right;\r\nguint16 byte_copy_left;\r\nguint16 input_bit_order;\r\nguint16 stack_location;\r\nguint16 stack_fill;\r\nguint16 result;\r\nguint msg_end = tvb_reported_length_remaining(message_tvb, 0);\r\nguint16 result_code = 0;\r\nguint16 old_input_bit_order = 0;\r\nguint16 remaining_bits = 0;\r\nguint16 input_bits = 0;\r\nguint8 bit_order = 0;\r\ngboolean outside_huffman_boundaries = TRUE;\r\ngboolean print_in_loop = FALSE;\r\nguint16 instruction_address;\r\nguint8 no_of_state_create = 0;\r\nguint16 state_length_buff[5];\r\nguint16 state_address_buff[5];\r\nguint16 state_instruction_buff[5];\r\nguint16 state_minimum_access_length_buff[5];\r\nguint32 used_udvm_cycles = 0;\r\nguint cycles_per_bit;\r\nguint maximum_UDVM_cycles;\r\nguint8 *sha1buff;\r\nunsigned char sha1_digest_buf[STATE_BUFFER_SIZE];\r\nsha1_context ctx;\r\nguint16 length;\r\nguint16 at_address;\r\nguint16 destination;\r\nguint16 addr;\r\nguint16 value;\r\nguint16 p_id_start;\r\nguint16 p_id_length;\r\nguint16 state_begin;\r\nguint16 state_length;\r\nguint16 state_address;\r\nguint16 state_instruction;\r\nguint16 operand_1;\r\nguint16 operand_2;\r\nguint16 value_1;\r\nguint16 value_2;\r\nguint16 at_address_1;\r\nguint16 at_address_2;\r\nguint16 at_address_3;\r\nguint16 j;\r\nguint16 bits_n;\r\nguint16 lower_bound_n;\r\nguint16 upper_bound_n;\r\nguint16 uncompressed_n;\r\nguint16 position;\r\nguint16 ref_destination;\r\nguint16 multy_offset;\r\nguint16 output_start;\r\nguint16 output_length;\r\nguint16 minimum_access_length;\r\nguint16 state_retention_priority;\r\nguint16 requested_feedback_location;\r\nguint16 returned_parameters_location;\r\nguint16 start_value;\r\nprint_level_1 = FALSE;\r\nprint_level_2 = FALSE;\r\nprint_level_3 = FALSE;\r\nshow_instr_detail_level = 0;\r\nswitch( print_flags ) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nprint_level_1 = TRUE;\r\nshow_instr_detail_level = 1;\r\nbreak;\r\ncase 2:\r\nprint_level_1 = TRUE;\r\nprint_level_2 = TRUE;\r\nshow_instr_detail_level = 1;\r\nbreak;\r\ncase 3:\r\nprint_level_1 = TRUE;\r\nprint_level_2 = TRUE;\r\nprint_level_3 = TRUE;\r\nshow_instr_detail_level = 2;\r\nbreak;\r\ndefault:\r\nprint_level_1 = TRUE;\r\nshow_instr_detail_level = 1;\r\nbreak;\r\n}\r\nbuff[0] = (UDVM_MEMORY_SIZE >> 8) & 0x00FF;\r\nbuff[1] = UDVM_MEMORY_SIZE & 0x00FF;\r\nbuff[2] = 0;\r\nbuff[3] = 16;\r\nbuff[4] = 0;\r\nbuff[5] = 1;\r\nbuff[6] = (byte_code_id_len >> 8) & 0x00FF;\r\nbuff[7] = byte_code_id_len & 0x00FF;\r\nbuff[8] = (byte_code_state_len >> 8) & 0x00FF;\r\nbuff[9] = byte_code_state_len & 0x00FF;\r\ncode_length = tvb_reported_length_remaining(bytecode_tvb, 0);\r\ncycles_per_bit = buff[2] << 8;\r\ncycles_per_bit = cycles_per_bit | buff[3];\r\nmaximum_UDVM_cycles = (( 8 * (header_len + msg_end) ) + 1000) * cycles_per_bit;\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"maximum_UDVM_cycles(%u) = (( 8 * msg_end(%u) ) + 1000) * cycles_per_bit(%u)",maximum_UDVM_cycles,msg_end,cycles_per_bit);\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"Message Length: %u,Byte code length: %u, Maximum UDVM cycles: %u",msg_end,code_length,maximum_UDVM_cycles);\r\ni = udvm_mem_dest;\r\nif ( print_level_3 )\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"Load bytecode into UDVM starting at %u",i);\r\nwhile ( code_length > offset && i < UDVM_MEMORY_SIZE ) {\r\nbuff[i] = tvb_get_guint8(bytecode_tvb, offset);\r\nif ( print_level_3 )\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,\r\n" Addr: %u Instruction code(0x%0x) ", i, buff[i]);\r\ni++;\r\noffset++;\r\n}\r\ncurrent_address = udvm_start_ip;\r\ninput_address = 0;\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, offset, 1,"UDVM EXECUTION STARTED at Address: %u Message size %u",\r\ncurrent_address, msg_end);\r\nout_buff = (guint8 *)g_malloc(UDVM_MEMORY_SIZE);\r\nexecute_next_instruction:\r\nif ( used_udvm_cycles > maximum_UDVM_cycles ){\r\nresult_code = 15;\r\ngoto decompression_failure;\r\n}\r\nused_udvm_cycles++;\r\ncurrent_instruction = buff[current_address & 0xffff];\r\nswitch ( current_instruction ) {\r\ncase SIGCOMP_INSTR_DECOMPRESSION_FAILURE:\r\nif ( result_code == 0 )\r\nresult_code = 9;\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## DECOMPRESSION-FAILURE(0)",\r\ncurrent_address);\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Wireshark UDVM diagnostic: %s.",\r\nval_to_str(result_code, result_code_vals,"Unknown (%u)"));\r\nif ( output_address > 0 ){\r\ndecomp_tvb = tvb_new_child_real_data(message_tvb, out_buff,output_address,output_address);\r\ntvb_set_free_cb( decomp_tvb, g_free );\r\nadd_new_data_source(pinfo, decomp_tvb, "Decompressed SigComp message(Incomplete)");\r\nproto_tree_add_text(udvm_tree, decomp_tvb, 0, -1,"SigComp message Decompression failure");\r\nreturn decomp_tvb;\r\n}\r\ng_free(out_buff);\r\nreturn NULL;\r\nbreak;\r\ncase SIGCOMP_INSTR_AND:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## AND(1) (operand_1, operand_2)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_2 %u",\r\noperand_address, operand_2);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## AND (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 & operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_OR:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## OR(2) (operand_1, operand_2)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_2 %u",\r\noperand_address, operand_2);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## OR (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 | operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_NOT:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## NOT(3) ($operand_1)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## NOT (operand_1=%u)",\r\ncurrent_address, operand_1);\r\n}\r\nresult = operand_1 ^ 0xffff;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_LSHIFT:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## LSHIFT(4) ($operand_1, operand_2)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_2 %u",\r\noperand_address, operand_2);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## LSHIFT (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 << operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_RSHIFT:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## RSHIFT(5) (operand_1, operand_2)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_2 %u",\r\noperand_address, operand_2);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## RSHIFT (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 >> operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_ADD:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## ADD(6) (operand_1, operand_2)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_2 %u",\r\noperand_address, operand_2);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## ADD (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 + operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\ncase SIGCOMP_INSTR_SUBTRACT:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## SUBTRACT(7) (operand_1, operand_2)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_2 %u",\r\noperand_address, operand_2);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## SUBTRACT (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nresult = operand_1 - operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_MULTIPLY:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ##MULTIPLY(8) (operand_1, operand_2)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_2 %u",\r\noperand_address, operand_2);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## MULTIPLY (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nif ( operand_2 == 0){\r\nresult_code = 4;\r\ngoto decompression_failure;\r\n}\r\nresult = operand_1 * operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_DIVIDE:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## DIVIDE(9) (operand_1, operand_2)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_2 %u",\r\noperand_address, operand_2);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## DIVIDE (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nif ( operand_2 == 0){\r\nresult_code = 4;\r\ngoto decompression_failure;\r\n}\r\nresult = operand_1 / operand_2;\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_REMAINDER:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## REMAINDER(10) (operand_1, operand_2)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &operand_1, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_1 %u",\r\noperand_address, operand_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &operand_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u operand_2 %u",\r\noperand_address, operand_2);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## REMAINDER (operand_1=%u, operand_2=%u)",\r\ncurrent_address, operand_1, operand_2);\r\n}\r\nif ( operand_2 == 0){\r\nresult_code = 4;\r\ngoto decompression_failure;\r\n}\r\nresult = operand_1 - operand_2 * (operand_1 / operand_2);\r\nlsb = result & 0xff;\r\nmsb = result >> 8;\r\nbuff[result_dest] = msb;\r\nbuff[(result_dest+1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading result %u at %u",\r\nresult, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_SORT_ASCENDING:\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## SORT-ASCENDING(11) (start, n, k))",\r\ncurrent_address);\r\n}\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Execution of this instruction is NOT implemented");\r\nbreak;\r\ncase SIGCOMP_INSTR_SORT_DESCENDING:\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## SORT-DESCENDING(12) (start, n, k))",\r\ncurrent_address);\r\n}\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Execution of this instruction is NOT implemented");\r\nbreak;\r\ncase SIGCOMP_INSTR_SHA_1:\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## SHA-1(13) (position, length, destination)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u position %u",\r\noperand_address, position);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Length %u",\r\noperand_address, length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &ref_destination, &result_dest);\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u $destination %u",\r\noperand_address, ref_destination);\r\n}\r\nused_udvm_cycles = used_udvm_cycles + length;\r\nn = 0;\r\nk = position;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, 0, -1,\r\n"byte_copy_right = %u", byte_copy_right);\r\n}\r\nsha1_starts( &ctx );\r\nwhile (n<length) {\r\nguint16 handle_now = length;\r\nif ( k < byte_copy_right && byte_copy_right <= k + (length-n) ){\r\nhandle_now = byte_copy_right - position;\r\n}\r\nif (k + handle_now >= UDVM_MEMORY_SIZE)\r\ngoto decompression_failure;\r\nsha1_update( &ctx, &buff[k], handle_now );\r\nk = ( k + handle_now ) & 0xffff;\r\nn = ( n + handle_now ) & 0xffff;\r\nif ( k >= byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\n}\r\nsha1_finish( &ctx, sha1_digest_buf );\r\nk = ref_destination;\r\nfor ( n=0; n< STATE_BUFFER_SIZE; n++ ) {\r\nbuff[k] = sha1_digest_buf[n];\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\nif ( k == byte_copy_right ){\r\nk = byte_copy_left;\r\n}\r\n}\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, 0, -1,\r\n"Calculated SHA-1: %s",\r\nbytes_to_ep_str(sha1_digest_buf, STATE_BUFFER_SIZE));\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_LOAD:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## LOAD(14) (%%address, %%value)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Address %u",\r\noperand_address, addr);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## LOAD (%%address=%u, %%value=%u)",\r\ncurrent_address, addr, value);\r\n}\r\nlsb = value & 0xff;\r\nmsb = value >> 8;\r\nbuff[addr] = msb;\r\nbuff[(addr + 1) & 0xffff] = lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Value %u",\r\noperand_address, value);\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Loading bytes at %u Value %u 0x%x",\r\naddr, value, value);\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_MULTILOAD:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## MULTILOAD(15) (%%address, #n, value_0, ..., value_n-1)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Address %u",\r\noperand_address, addr);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u n %u",\r\noperand_address, n);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## MULTILOAD (%%address=%u, #n=%u, value_0, ..., value_%d)",\r\ncurrent_address, addr, n, n-1);\r\n}\r\noperand_address = next_operand_address;\r\nused_udvm_cycles = used_udvm_cycles + n;\r\nwhile ( n > 0) {\r\nn = n - 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);\r\nlsb = value & 0xff;\r\nmsb = value >> 8;\r\nif (addr >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[addr] = msb;\r\nbuff[(addr + 1) & 0xffff] = lsb;\r\nlength = next_operand_address - operand_address;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1, "Addr: %u Value %5u - Loading bytes at %5u Value %5u 0x%x",\r\noperand_address, value, addr, value, value);\r\n}\r\naddr = addr + 2;\r\noperand_address = next_operand_address;\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_PUSH:\r\nif (show_instr_detail_level == 2){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## PUSH(16) (value)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);\r\nif (show_instr_detail_level == 2){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Value %u",\r\noperand_address, value);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## PUSH (value=%u)",\r\ncurrent_address, value);\r\n}\r\ncurrent_address = next_operand_address;\r\nstack_location = (buff[70] << 8) | buff[71];\r\nstack_fill = (buff[stack_location] << 8)\r\n| buff[(stack_location+1) & 0xFFFF];\r\naddr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;\r\nif (addr >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[addr] = (value >> 8) & 0x00FF;\r\nbuff[(addr+1) & 0xFFFF] = value & 0x00FF;\r\nif (stack_location >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nstack_fill = (stack_fill + 1) & 0xFFFF;\r\nbuff[stack_location] = (stack_fill >> 8) & 0x00FF;\r\nbuff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_POP:\r\nif (show_instr_detail_level == 2){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## POP(16) (value)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Value %u",\r\noperand_address, destination);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## POP (address=%u)",\r\ncurrent_address, destination);\r\n}\r\ncurrent_address = next_operand_address;\r\nstack_location = (buff[70] << 8) | buff[71];\r\nstack_fill = (buff[stack_location] << 8)\r\n| buff[(stack_location+1) & 0xFFFF];\r\nif (stack_fill == 0)\r\n{\r\nresult_code = 16;\r\ngoto decompression_failure;\r\n}\r\nif (stack_location >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nstack_fill = (stack_fill - 1) & 0xFFFF;\r\nbuff[stack_location] = (stack_fill >> 8) & 0x00FF;\r\nbuff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;\r\naddr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;\r\nif (addr >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nvalue = (buff[addr] << 8)\r\n| buff[(addr+1) & 0xFFFF];\r\nif (destination >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[destination] = (value >> 8) & 0x00FF;\r\nbuff[(destination+1) & 0xFFFF] = value & 0x00FF;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_COPY:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## COPY(18) (position, length, destination)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u position %u",\r\noperand_address, position);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Length %u",\r\noperand_address, length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Destination %u",\r\noperand_address, destination);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## COPY (position=%u, length=%u, destination=%u)",\r\ncurrent_address, position, length, destination);\r\n}\r\ncurrent_address = next_operand_address;\r\nn = 0;\r\nk = destination;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" byte_copy_right = %u", byte_copy_right);\r\n}\r\nwhile ( n < length ){\r\nbuff[k] = buff[position];\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" Copying value: %u (0x%x) to Addr: %u",\r\nbuff[position], buff[position], k);\r\n}\r\nposition = ( position + 1 ) & 0xffff;\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\nif ( k == byte_copy_right ){\r\nk = byte_copy_left;\r\n}\r\nif ( position == byte_copy_right ){\r\nposition = byte_copy_left;\r\n}\r\n}\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_COPY_LITERAL:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## COPY-LITERAL(19) (position, length, $destination)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u position %u",\r\noperand_address, position);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Length %u",\r\noperand_address, length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &ref_destination, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u destination %u",\r\noperand_address, ref_destination);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## COPY-LITERAL (position=%u, length=%u, $destination=%u)",\r\ncurrent_address, position, length, ref_destination);\r\n}\r\ncurrent_address = next_operand_address;\r\nn = 0;\r\nk = ref_destination;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" byte_copy_right = %u", byte_copy_right);\r\n}\r\nwhile ( n < length ){\r\nbuff[k] = buff[position];\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" Copying value: %u (0x%x) to Addr: %u",\r\nbuff[position], buff[position], k);\r\n}\r\nposition = ( position + 1 ) & 0xffff;\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\nif ( k == byte_copy_right ){\r\nk = byte_copy_left;\r\n}\r\nif ( position == byte_copy_right ){\r\nposition = byte_copy_left;\r\n}\r\n}\r\nbuff[result_dest] = k >> 8;\r\nbuff[(result_dest + 1) & 0xffff] = k & 0x00ff;\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_COPY_OFFSET:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## COPY-OFFSET(20) (offset, length, $destination)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &multy_offset);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u offset %u",\r\noperand_address, multy_offset);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Length %u",\r\noperand_address, length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = dissect_udvm_reference_operand(buff, operand_address, &ref_destination, &result_dest);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u $destination %u",\r\noperand_address, ref_destination);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## COPY-OFFSET (offset=%u, length=%u, $destination=%u)",\r\ncurrent_address, multy_offset, length, result_dest);\r\n}\r\ncurrent_address = next_operand_address;\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nfor (position = ref_destination, i = 0; i < multy_offset; i++)\r\n{\r\nif ( position == byte_copy_left )\r\n{\r\nposition = (byte_copy_right - 1) & 0xffff;\r\n}\r\nelse\r\n{\r\nposition = (position - 1) & 0xffff;\r\n}\r\n}\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" byte_copy_left = %u byte_copy_right = %u position= %u",\r\nbyte_copy_left, byte_copy_right, position);\r\n}\r\nn = 0;\r\nk = ref_destination;\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" byte_copy_left = %u byte_copy_right = %u", byte_copy_left, byte_copy_right);\r\n}\r\nwhile ( n < length ){\r\nbuff[k] = buff[position];\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" Copying value: %5u (0x%x) from Addr: %u to Addr: %u",\r\nbuff[position], buff[position],(position), k);\r\n}\r\nn++;\r\nk = ( k + 1 ) & 0xffff;\r\nposition = ( position + 1 ) & 0xffff;\r\nif ( k == byte_copy_right ){\r\nk = byte_copy_left;\r\n}\r\nif ( position == byte_copy_right ){\r\nposition = byte_copy_left;\r\n}\r\n}\r\nbuff[result_dest] = k >> 8;\r\nbuff[result_dest + 1] = k & 0x00ff;\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_MEMSET:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## MEMSET(21) (address, length, start_value, offset)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &addr);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Address %u",\r\noperand_address, addr);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Length %u",\r\noperand_address, length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &start_value);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u start_value %u",\r\noperand_address, start_value);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &multy_offset);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u offset %u",\r\noperand_address, multy_offset);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## MEMSET (address=%u, length=%u, start_value=%u, offset=%u)",\r\ncurrent_address, addr, length, start_value, multy_offset);\r\n}\r\ncurrent_address = next_operand_address;\r\nn = 0;\r\nk = addr;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" byte_copy_left = %u byte_copy_right = %u", byte_copy_left, byte_copy_right);\r\n}\r\nwhile ( n < length ){\r\nif ( k == byte_copy_right ){\r\nk = byte_copy_left;\r\n}\r\nbuff[k] = (start_value + ( n * multy_offset)) & 0xff;\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" Storing value: %u (0x%x) at Addr: %u",\r\nbuff[k], buff[k], k);\r\n}\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_JUMP:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## JUMP(22) (@address)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\ndecode_udvm_address_operand(buff,operand_address, &at_address, current_address);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## JUMP (@address=%u)",\r\ncurrent_address, at_address);\r\n}\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_COMPARE:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## COMPARE(23) (value_1, value_2, @address_1, @address_2, @address_3)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value_1);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Value %u",\r\noperand_address, value_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value_2);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Value %u",\r\noperand_address, value_2);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_1);\r\nat_address_1 = ( current_address + at_address_1) & 0xffff;\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address_1);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_2);\r\nat_address_2 = ( current_address + at_address_2) & 0xffff;\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address_2);\r\n}\r\noperand_address = next_operand_address;\r\ndecode_udvm_multitype_operand(buff, operand_address, &at_address_3);\r\nat_address_3 = ( current_address + at_address_3) & 0xffff;\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address_3);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## COMPARE (value_1=%u, value_2=%u, @address_1=%u, @address_2=%u, @address_3=%u)",\r\ncurrent_address, value_1, value_2, at_address_1, at_address_2, at_address_3);\r\n}\r\nif ( value_1 < value_2 )\r\ncurrent_address = at_address_1;\r\nif ( value_1 == value_2 )\r\ncurrent_address = at_address_2;\r\nif ( value_1 > value_2 )\r\ncurrent_address = at_address_3;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_CALL:\r\nif (show_instr_detail_level == 2){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## CALL(24) (@address) (PUSH addr )",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## CALL (@address=%u)",\r\ncurrent_address, at_address);\r\n}\r\ncurrent_address = next_operand_address;\r\nstack_location = (buff[70] << 8) | buff[71];\r\nstack_fill = (buff[stack_location] << 8)\r\n| buff[(stack_location+1) & 0xFFFF];\r\naddr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;\r\nif (addr >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[addr] = (current_address >> 8) & 0x00FF;\r\nbuff[(addr+1) & 0xFFFF] = current_address & 0x00FF;\r\nstack_fill = (stack_fill + 1) & 0xFFFF;\r\nif (stack_location >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[stack_location] = (stack_fill >> 8) & 0x00FF;\r\nbuff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_RETURN:\r\nif (print_level_1 || show_instr_detail_level == 1){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## POP(25) and return",\r\ncurrent_address);\r\n}\r\nstack_location = (buff[70] << 8) | buff[71];\r\nstack_fill = (buff[stack_location] << 8)\r\n| buff[(stack_location+1) & 0xFFFF];\r\nif (stack_fill == 0)\r\n{\r\nresult_code = 16;\r\ngoto decompression_failure;\r\n}\r\nstack_fill = (stack_fill - 1) & 0xFFFF;\r\nif (stack_location >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[stack_location] = (stack_fill >> 8) & 0x00FF;\r\nbuff[(stack_location+1) & 0xFFFF] = stack_fill & 0x00FF;\r\naddr = (stack_location + stack_fill * 2 + 2) & 0xFFFF;\r\nat_address = (buff[addr] << 8)\r\n| buff[(addr+1) & 0xFFFF];\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_SWITCH:\r\ninstruction_address = current_address;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## SWITCH (#n, j, @address_0, @address_1, ... , @address_n-1))",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u n %u",\r\noperand_address, n);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &j);\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u j %u",\r\noperand_address, j);\r\n}\r\noperand_address = next_operand_address;\r\nm = 0;\r\nwhile ( m < n ){\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address_1);\r\nat_address_1 = ( instruction_address + at_address_1) & 0xffff;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address_1);\r\n}\r\nif ( j == m ){\r\ncurrent_address = at_address_1;\r\n}\r\noperand_address = next_operand_address;\r\nm++;\r\n}\r\nif ( ( j == n ) || ( j > n )){\r\nresult_code = 5;\r\ngoto decompression_failure;\r\n}\r\nif ( current_address > UDVM_MEMORY_SIZE ){\r\nresult_code = 6;\r\ngoto decompression_failure;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + n;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_CRC:\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## CRC (value, position, length, @address)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &value);\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Value %u",\r\noperand_address, value);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &position);\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u position %u",\r\noperand_address, position);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Length %u",\r\noperand_address, length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address);\r\nat_address = ( current_address + at_address) & 0xffff;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address);\r\n}\r\nused_udvm_cycles = used_udvm_cycles + length;\r\nn = 0;\r\nk = position;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nresult = 0;\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, 0, -1,\r\n"byte_copy_right = %u", byte_copy_right);\r\n}\r\nwhile (n<length) {\r\nguint16 handle_now = length - n;\r\nif ( k < byte_copy_right && byte_copy_right <= k + (length-n) ){\r\nhandle_now = byte_copy_right - k;\r\n}\r\nif (k + handle_now >= UDVM_MEMORY_SIZE)\r\ngoto decompression_failure;\r\nresult = crc16_ccitt_seed(&buff[k], handle_now, (guint16) (result ^ 0xffff));\r\nk = ( k + handle_now ) & 0xffff;\r\nn = ( n + handle_now ) & 0xffff;\r\nif ( k >= byte_copy_right ) {\r\nk = byte_copy_left;\r\n}\r\n}\r\nresult = result ^ 0xffff;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1, "Calculated CRC %u", result);\r\n}\r\nif (result != value){\r\ncurrent_address = at_address;\r\n}\r\nelse {\r\ncurrent_address = next_operand_address;\r\n}\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_INPUT_BYTES:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## INPUT-BYTES(28) length, destination, @address)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Length %u",\r\noperand_address, length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Destination %u",\r\noperand_address, destination);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &at_address);\r\nat_address = ( current_address + at_address) & 0xffff;\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## INPUT-BYTES length=%u, destination=%u, @address=%u)",\r\ncurrent_address, length, destination, at_address);\r\n}\r\nn = 0;\r\nk = destination;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" byte_copy_right = %u", byte_copy_right);\r\n}\r\nremaining_bits = 0;\r\ninput_bits=0;\r\nwhile ( n < length ){\r\nif (input_address > ( msg_end - 1)){\r\ncurrent_address = at_address;\r\nresult_code = 14;\r\ngoto execute_next_instruction;\r\n}\r\nif ( k == byte_copy_right ){\r\nk = byte_copy_left;\r\n}\r\noctet = tvb_get_guint8(message_tvb, input_address);\r\nbuff[k] = octet;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" Loading value: %u (0x%x) at Addr: %u", octet, octet, k);\r\n}\r\ninput_address++;\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + length;\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_INPUT_BITS:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## INPUT-BITS(29) (length, destination, @address)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u length %u",\r\noperand_address, length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Destination %u",\r\noperand_address, destination);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## INPUT-BITS length=%u, destination=%u, @address=%u)",\r\ncurrent_address, length, destination, at_address);\r\n}\r\ncurrent_address = next_operand_address;\r\ninput_bit_order = buff[68] << 8;\r\ninput_bit_order = input_bit_order | buff[69];\r\nif ( length > 16 ){\r\nresult_code = 7;\r\ngoto decompression_failure;\r\n}\r\nif ( input_bit_order > 7 ){\r\nresult_code = 8;\r\ngoto decompression_failure;\r\n}\r\nbit_order = ( input_bit_order & 0x0004 ) >> 2;\r\nvalue = decomp_dispatch_get_bits( message_tvb, udvm_tree, bit_order,\r\nbuff, &old_input_bit_order, &remaining_bits,\r\n&input_bits, &input_address, length, &result_code, msg_end);\r\nif ( result_code == 11 ){\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\n}\r\nmsb = value >> 8;\r\nlsb = value & 0x00ff;\r\nif (destination >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[destination] = msb;\r\nbuff[(destination + 1) & 0xffff]=lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" Loading value: %u (0x%x) at Addr: %u, remaining_bits: %u", value, value, destination, remaining_bits);\r\n}\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_INPUT_HUFFMAN:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## INPUT-HUFFMAN (destination, @address, #n, bits_1, lower_bound_1,upper_bound_1, uncompressed_1, ... , bits_n, lower_bound_n,upper_bound_n, uncompressed_n)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &destination);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u Destination %u",\r\noperand_address, destination);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_address_operand(buff,operand_address, &at_address, current_address);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u @Address %u",\r\noperand_address, at_address);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_literal_operand(buff,operand_address, &n);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u n %u",\r\noperand_address, n);\r\n}\r\noperand_address = next_operand_address;\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## INPUT-HUFFMAN (destination=%u, @address=%u, #n=%u, bits_1, lower_1,upper_1, unc_1, ... , bits_%d, lower_%d,upper_%d, unc_%d)",\r\ncurrent_address, destination, at_address, n, n, n, n, n);\r\n}\r\nused_udvm_cycles = used_udvm_cycles + n;\r\ninput_bit_order = buff[68] << 8;\r\ninput_bit_order = input_bit_order | buff[69];\r\nbit_order = ( input_bit_order & 0x0002 ) >> 1;\r\nj = 1;\r\nH = 0;\r\nm = n;\r\noutside_huffman_boundaries = TRUE;\r\nprint_in_loop = print_level_3;\r\nwhile ( m > 0 ){\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &bits_n);\r\nif (print_in_loop ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u bits_n %u",\r\noperand_address, bits_n);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &lower_bound_n);\r\nif (print_in_loop ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u lower_bound_n %u",\r\noperand_address, lower_bound_n);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &upper_bound_n);\r\nif (print_in_loop ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u upper_bound_n %u",\r\noperand_address, upper_bound_n);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &uncompressed_n);\r\nif (print_in_loop ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u uncompressed_n %u",\r\noperand_address, uncompressed_n);\r\n}\r\noperand_address = next_operand_address;\r\nif ( outside_huffman_boundaries ) {\r\nk = decomp_dispatch_get_bits( message_tvb, udvm_tree, bit_order,\r\nbuff, &old_input_bit_order, &remaining_bits,\r\n&input_bits, &input_address, bits_n, &result_code, msg_end);\r\nif ( result_code == 11 ){\r\ncurrent_address = at_address;\r\ngoto execute_next_instruction;\r\n}\r\noldH = H;\r\nH = (H << bits_n) | k;\r\nif (print_level_3 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," Set H(%u) := H(%u) * 2^bits_j(%u) + k(%u)",\r\nH ,oldH, 1<<bits_n,k);\r\n}\r\nif ((H < lower_bound_n) || (H > upper_bound_n)){\r\noutside_huffman_boundaries = TRUE;\r\n}else{\r\noutside_huffman_boundaries = FALSE;\r\nprint_in_loop = FALSE;\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n" H(%u) = H(%u) + uncompressed_n(%u) - lower_bound_n(%u)",\r\n(H + uncompressed_n - lower_bound_n ),H, uncompressed_n, lower_bound_n);\r\n}\r\nH = H + uncompressed_n - lower_bound_n;\r\nmsb = H >> 8;\r\nlsb = H & 0x00ff;\r\nif (destination >= UDVM_MEMORY_SIZE - 1)\r\ngoto decompression_failure;\r\nbuff[destination] = msb;\r\nbuff[(destination + 1) & 0xffff]=lsb;\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" Loading H: %u (0x%x) at Addr: %u,j = %u remaining_bits: %u",\r\nH, H, destination,( n - m + 1 ), remaining_bits);\r\n}\r\n}\r\n}\r\nm = m - 1;\r\n}\r\nif ( outside_huffman_boundaries ) {\r\nresult_code = 10;\r\ngoto decompression_failure;\r\n}\r\ncurrent_address = next_operand_address;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_STATE_ACCESS:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## STATE-ACCESS(31) (partial_identifier_start, partial_identifier_length,state_begin, state_length, state_address, state_instruction)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_start);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u partial_identifier_start %u",\r\noperand_address, p_id_start);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u partial_identifier_length %u",\r\noperand_address, p_id_length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_begin);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_begin %u",\r\noperand_address, state_begin);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_length %u",\r\noperand_address, state_length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_address %u",\r\noperand_address, state_address);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_instruction %u",\r\noperand_address, state_instruction);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## STATE-ACCESS(31) (partial_identifier_start=%u, partial_identifier_length=%u,state_begin=%u, state_length=%u, state_address=%u, state_instruction=%u)",\r\ncurrent_address, p_id_start, p_id_length, state_begin, state_length, state_address, state_instruction);\r\n}\r\ncurrent_address = next_operand_address;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_2 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, input_address, 1,\r\n" byte_copy_right = %u, byte_copy_left = %u", byte_copy_right,byte_copy_left);\r\n}\r\nresult_code = udvm_state_access(message_tvb, udvm_tree, buff, p_id_start, p_id_length, state_begin, &state_length,\r\n&state_address, &state_instruction, hf_id);\r\nif ( result_code != 0 ){\r\ngoto decompression_failure;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + state_length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_STATE_CREATE:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## STATE-CREATE(32) (state_length, state_address, state_instruction,minimum_access_length, state_retention_priority)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_length %u",\r\noperand_address, state_length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_address %u",\r\noperand_address, state_address);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_instruction %u",\r\noperand_address, state_instruction);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &minimum_access_length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u minimum_access_length %u",\r\noperand_address, minimum_access_length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_retention_priority);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_retention_priority %u",\r\noperand_address, state_retention_priority);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## STATE-CREATE(32) (state_length=%u, state_address=%u, state_instruction=%u,minimum_access_length=%u, state_retention_priority=%u)",\r\ncurrent_address, state_length, state_address, state_instruction,minimum_access_length, state_retention_priority);\r\n}\r\ncurrent_address = next_operand_address;\r\nno_of_state_create++;\r\nif ( no_of_state_create > 4 ){\r\nresult_code = 12;\r\ngoto decompression_failure;\r\n}\r\nif (( minimum_access_length < 6 ) || ( minimum_access_length > STATE_BUFFER_SIZE )){\r\nresult_code = 1;\r\ngoto decompression_failure;\r\n}\r\nif ( state_retention_priority == 65535 ){\r\nresult_code = 13;\r\ngoto decompression_failure;\r\n}\r\nstate_length_buff[no_of_state_create] = state_length;\r\nstate_address_buff[no_of_state_create] = state_address;\r\nstate_instruction_buff[no_of_state_create] = state_instruction;\r\nstate_minimum_access_length_buff[no_of_state_create] = minimum_access_length;\r\nused_udvm_cycles = used_udvm_cycles + state_length;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nn = 0;\r\nk = state_address;\r\nwhile ( n < state_length ){\r\nif ( k == byte_copy_right ){\r\nk = byte_copy_left;\r\n}\r\nstring[0]= buff[k];\r\nstring[1]= '\0';\r\nif (print_level_3 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n" Addr: %5u State value: %u (0x%x) ASCII(%s)",\r\nk,buff[k],buff[k],format_text(string, 1));\r\n}\r\nk = ( k + 1 ) & 0xffff;\r\nn++;\r\n}\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_STATE_FREE:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## STATE-FREE (partial_identifier_start, partial_identifier_length)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_start);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u partial_identifier_start %u",\r\noperand_address, p_id_start);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &p_id_length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u partial_identifier_length %u",\r\noperand_address, p_id_length);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## STATE-FREE (partial_identifier_start=%u, partial_identifier_length=%u)",\r\ncurrent_address, p_id_start, p_id_length);\r\n}\r\ncurrent_address = next_operand_address;\r\nudvm_state_free(buff,p_id_start,p_id_length);\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_OUTPUT:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## OUTPUT(34) (output_start, output_length)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &output_start);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u output_start %u",\r\noperand_address, output_start);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &output_length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u output_length %u",\r\noperand_address, output_length);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## OUTPUT (output_start=%u, output_length=%u)",\r\ncurrent_address, output_start, output_length);\r\n}\r\ncurrent_address = next_operand_address;\r\nn = 0;\r\nk = output_start;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nif (print_level_3 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n" byte_copy_right = %u", byte_copy_right);\r\n}\r\nwhile ( n < output_length ){\r\nif ( k == byte_copy_right ){\r\nk = byte_copy_left;\r\n}\r\nout_buff[output_address] = buff[k];\r\nstring[0]= buff[k];\r\nstring[1]= '\0';\r\nif (print_level_3 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n" Output value: %u (0x%x) ASCII(%s) from Addr: %u ,output to dispatcher position %u",\r\nbuff[k],buff[k],format_text(string,1), k,output_address);\r\n}\r\nk = ( k + 1 ) & 0xffff;\r\noutput_address ++;\r\nn++;\r\n}\r\nused_udvm_cycles = used_udvm_cycles + output_length;\r\ngoto execute_next_instruction;\r\nbreak;\r\ncase SIGCOMP_INSTR_END_MESSAGE:\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## END-MESSAGE (requested_feedback_location,state_instruction, minimum_access_length,state_retention_priority)",\r\ncurrent_address);\r\n}\r\noperand_address = current_address + 1;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &requested_feedback_location);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u requested_feedback_location %u",\r\noperand_address, requested_feedback_location);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &returned_parameters_location);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u returned_parameters_location %u",\r\noperand_address, returned_parameters_location);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_length %u",\r\noperand_address, state_length);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_address);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_address %u",\r\noperand_address, state_address);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &state_instruction);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_instruction %u",\r\noperand_address, state_instruction);\r\n}\r\noperand_address = next_operand_address;\r\nnext_operand_address = decode_udvm_multitype_operand(buff, operand_address, &minimum_access_length);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u minimum_access_length %u",\r\noperand_address, minimum_access_length);\r\n}\r\noperand_address = next_operand_address;\r\ndecode_udvm_multitype_operand(buff, operand_address, &state_retention_priority);\r\nif (show_instr_detail_level == 2 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"Addr: %u state_retention_priority %u",\r\noperand_address, state_retention_priority);\r\n}\r\nif (show_instr_detail_level == 1)\r\n{\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,\r\n"Addr: %u ## END-MESSAGE (requested_feedback_location=%u, returned_parameters_location=%u, state_length=%u, state_address=%u, state_instruction=%u, minimum_access_length=%u, state_retention_priority=%u)",\r\ncurrent_address, requested_feedback_location, returned_parameters_location, state_length, state_address, state_instruction, minimum_access_length,state_retention_priority);\r\n}\r\nno_of_state_create++;\r\nif ( no_of_state_create > 4 ){\r\nresult_code = 12;\r\ngoto decompression_failure;\r\n}\r\nstate_length_buff[no_of_state_create] = state_length;\r\nstate_address_buff[no_of_state_create] = state_address;\r\nstate_instruction_buff[no_of_state_create] = state_instruction;\r\nstate_minimum_access_length_buff[no_of_state_create] = minimum_access_length;\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"no_of_state_create %u",no_of_state_create);\r\nif ( no_of_state_create != 0 ){\r\nmemset(sha1_digest_buf, 0, STATE_BUFFER_SIZE);\r\nn = 1;\r\nbyte_copy_right = buff[66] << 8;\r\nbyte_copy_right = byte_copy_right | buff[67];\r\nbyte_copy_left = buff[64] << 8;\r\nbyte_copy_left = byte_copy_left | buff[65];\r\nwhile ( n < no_of_state_create + 1 ){\r\nsha1buff = (guint8 *)g_malloc(state_length_buff[n]+8);\r\nsha1buff[0] = state_length_buff[n] >> 8;\r\nsha1buff[1] = state_length_buff[n] & 0xff;\r\nsha1buff[2] = state_address_buff[n] >> 8;\r\nsha1buff[3] = state_address_buff[n] & 0xff;\r\nsha1buff[4] = state_instruction_buff[n] >> 8;\r\nsha1buff[5] = state_instruction_buff[n] & 0xff;\r\nsha1buff[6] = state_minimum_access_length_buff[n] >> 8;\r\nsha1buff[7] = state_minimum_access_length_buff[n] & 0xff;\r\nif (print_level_3 ){\r\nfor( x=0; x < 8; x++){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"sha1buff %u 0x%x",\r\nx,sha1buff[x]);\r\n}\r\n}\r\nk = state_address_buff[n];\r\nfor( x=0; x < state_length_buff[n]; x++)\r\n{\r\nif ( k == byte_copy_right ){\r\nk = byte_copy_left;\r\n}\r\nsha1buff[8+x] = buff[k];\r\nk = ( k + 1 ) & 0xffff;\r\n}\r\nsha1_starts( &ctx );\r\nsha1_update( &ctx, (guint8 *) sha1buff, state_length_buff[n] + 8);\r\nsha1_finish( &ctx, sha1_digest_buf );\r\nif (print_level_3 ){\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"SHA1 digest %s",bytes_to_ep_str(sha1_digest_buf, STATE_BUFFER_SIZE));\r\n}\r\n#if 0\r\nudvm_state_create(sha1buff, sha1_digest_buf, state_minimum_access_length_buff[n]);\r\n#endif\r\nudvm_state_create(sha1buff, sha1_digest_buf, STATE_MIN_ACCESS_LEN);\r\nproto_tree_add_text(udvm_tree,bytecode_tvb, 0, -1,"### Creating state ###");\r\nproto_tree_add_string(udvm_tree,hf_id, bytecode_tvb, 0, 0, bytes_to_ep_str(sha1_digest_buf, state_minimum_access_length_buff[n]));\r\nn++;\r\n}\r\n}\r\ndecomp_tvb = tvb_new_child_real_data(message_tvb, out_buff,output_address,output_address);\r\ntvb_set_free_cb( decomp_tvb, g_free );\r\nadd_new_data_source(pinfo, decomp_tvb, "Decompressed SigComp message");\r\nused_udvm_cycles = used_udvm_cycles + state_length;\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"maximum_UDVM_cycles %u used_udvm_cycles %u",\r\nmaximum_UDVM_cycles, used_udvm_cycles);\r\nreturn decomp_tvb;\r\nbreak;\r\ndefault:\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1," ### Addr %u Invalid instruction: %u (0x%x)",\r\ncurrent_address,current_instruction,current_instruction);\r\nbreak;\r\n}\r\ng_free(out_buff);\r\nreturn NULL;\r\ndecompression_failure:\r\nproto_tree_add_text(udvm_tree, bytecode_tvb, 0, -1,"DECOMPRESSION FAILURE: %s",\r\nval_to_str(result_code, result_code_vals,"Unknown (%u)"));\r\ng_free(out_buff);\r\nTHROW(ReportedBoundsError);\r\nreturn NULL;\r\n}\r\nstatic int\r\ndecode_udvm_literal_operand(guint8 *buff,guint operand_address, guint16 *value)\r\n{\r\nguint bytecode;\r\nguint16 operand;\r\nguint test_bits;\r\nguint offset = operand_address;\r\nguint8 temp_data;\r\nbytecode = buff[operand_address];\r\ntest_bits = bytecode >> 7;\r\nif (test_bits == 1){\r\ntest_bits = bytecode >> 6;\r\nif (test_bits == 2){\r\ntemp_data = buff[operand_address] & 0x1f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\n*value = operand;\r\noffset = offset + 2;\r\n}else{\r\noffset ++;\r\ntemp_data = buff[operand_address] & 0x1f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\n*value = operand;\r\noffset = offset + 2;\r\n}\r\n}else{\r\noperand = ( bytecode & 0x7f);\r\n*value = operand;\r\noffset ++;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_udvm_reference_operand(guint8 *buff,guint operand_address, guint16 *value,guint *result_dest)\r\n{\r\nguint bytecode;\r\nguint16 operand;\r\nguint offset = operand_address;\r\nguint test_bits;\r\nguint8 temp_data;\r\nguint16 temp_data16;\r\nbytecode = buff[operand_address];\r\ntest_bits = bytecode >> 7;\r\nif (test_bits == 1){\r\ntest_bits = bytecode >> 6;\r\nif (test_bits == 2){\r\ntemp_data = buff[operand_address] & 0x3f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\noperand = (operand * 2);\r\n*result_dest = operand;\r\ntemp_data16 = buff[operand] << 8;\r\ntemp_data16 = temp_data16 | buff[(operand+1) & 0xffff];\r\n*value = temp_data16;\r\noffset = offset + 2;\r\n}else{\r\noperand_address++;\r\noperand = buff[operand_address] << 8;\r\noperand = operand | buff[(operand_address + 1) & 0xffff];\r\n*result_dest = operand;\r\ntemp_data16 = buff[operand] << 8;\r\ntemp_data16 = temp_data16 | buff[(operand+1) & 0xffff];\r\n*value = temp_data16;\r\noffset = offset + 3;\r\n}\r\n}else{\r\noperand = ( bytecode & 0x7f);\r\noperand = (operand * 2);\r\n*result_dest = operand;\r\ntemp_data16 = buff[operand] << 8;\r\ntemp_data16 = temp_data16 | buff[(operand+1) & 0xffff];\r\n*value = temp_data16;\r\noffset ++;\r\n}\r\nif (offset >= UDVM_MEMORY_SIZE || *result_dest >= UDVM_MEMORY_SIZE - 1 )\r\nTHROW(ReportedBoundsError);\r\nreturn offset;\r\n}\r\nstatic int\r\ndecode_udvm_multitype_operand(guint8 *buff,guint operand_address, guint16 *value)\r\n{\r\nguint test_bits;\r\nguint bytecode;\r\nguint offset = operand_address;\r\nguint16 operand;\r\nguint32 result;\r\nguint8 temp_data;\r\nguint16 temp_data16;\r\nguint16 memmory_addr = 0;\r\n*value = 0;\r\nbytecode = buff[operand_address];\r\ntest_bits = ( bytecode & 0xc0 ) >> 6;\r\nswitch (test_bits ){\r\ncase 0:\r\noperand = buff[operand_address];\r\n*value = operand;\r\noffset ++;\r\nbreak;\r\ncase 1:\r\nmemmory_addr = ( bytecode & 0x3f) * 2;\r\ntemp_data16 = buff[memmory_addr] << 8;\r\ntemp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];\r\n*value = temp_data16;\r\noffset ++;\r\nbreak;\r\ncase 2:\r\ntest_bits = ( bytecode & 0xe0 ) >> 5;\r\nif ( test_bits == 5 ){\r\ntemp_data = buff[operand_address] & 0x1f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\n*value = operand;\r\noffset = offset + 2;\r\n}else{\r\ntest_bits = ( bytecode & 0xf0 ) >> 4;\r\nif ( test_bits == 9 ){\r\ntemp_data = buff[operand_address] & 0x0f;\r\noperand = temp_data << 8;\r\ntemp_data = buff[(operand_address + 1) & 0xffff];\r\noperand = operand | temp_data;\r\noperand = operand + 61440;\r\n*value = operand;\r\noffset = offset + 2;\r\n}else{\r\ntest_bits = ( bytecode & 0x08 ) >> 3;\r\nif ( test_bits == 1){\r\nresult = 1 << ((buff[operand_address] & 0x07) + 8);\r\noperand = result & 0xffff;\r\n*value = operand;\r\noffset ++;\r\n}else{\r\ntest_bits = ( bytecode & 0x0e ) >> 1;\r\nif ( test_bits == 3 ){\r\nresult = 1 << ((buff[operand_address] & 0x01) + 6);\r\noperand = result & 0xffff;\r\n*value = operand;\r\noffset ++;\r\n}else{\r\noffset ++;\r\ntemp_data16 = buff[(operand_address + 1) & 0xffff] << 8;\r\ntemp_data16 = temp_data16 | buff[(operand_address + 2) & 0xffff];\r\nif ( (bytecode & 0x01) == 1 ){\r\nmemmory_addr = temp_data16;\r\ntemp_data16 = buff[memmory_addr] << 8;\r\ntemp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];\r\n}\r\n*value = temp_data16;\r\noffset = offset +2;\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ncase 3:\r\ntest_bits = ( bytecode & 0x20 ) >> 5;\r\nif ( test_bits == 1 ){\r\noperand = ( buff[operand_address] & 0x1f) + 65504;\r\n*value = operand;\r\noffset ++;\r\n}else{\r\nmemmory_addr = buff[operand_address] & 0x1f;\r\nmemmory_addr = memmory_addr << 8;\r\nmemmory_addr = memmory_addr | buff[(operand_address + 1) & 0xffff];\r\ntemp_data16 = buff[memmory_addr] << 8;\r\ntemp_data16 = temp_data16 | buff[(memmory_addr+1) & 0xffff];\r\n*value = temp_data16;\r\noffset = offset +2;\r\n}\r\ndefault :\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndecode_udvm_address_operand(guint8 *buff,guint operand_address, guint16 *value,guint current_address)\r\n{\r\nguint32 result;\r\nguint16 value1;\r\nguint next_opreand_address;\r\nnext_opreand_address = decode_udvm_multitype_operand(buff, operand_address, &value1);\r\nresult = value1 & 0xffff;\r\nresult = result + current_address;\r\n*value = result & 0xffff;\r\nreturn next_opreand_address;\r\n}\r\nstatic int\r\ndecomp_dispatch_get_bits(\r\ntvbuff_t *message_tvb,\r\nproto_tree *udvm_tree,\r\nguint8 bit_order,\r\nguint8 *buff,\r\nguint16 *old_input_bit_order,\r\nguint16 *remaining_bits,\r\nguint16 *input_bits,\r\nguint *input_address,\r\nguint16 length,\r\nguint16 *result_code,\r\nguint msg_end)\r\n{\r\nguint16 input_bit_order;\r\nguint16 bits_still_required = length;\r\nguint16 value = 0;\r\nguint8 octet;\r\ngint extra_bytes_available = msg_end - *input_address;\r\ngint p_bit;\r\ngint prev_p_bit = *old_input_bit_order & 0x0001;\r\ngint bits_to_use = 0;\r\ninput_bit_order = buff[68] << 8;\r\ninput_bit_order = input_bit_order | buff[69];\r\n*result_code = 0;\r\np_bit = (input_bit_order & 0x0001) != 0;\r\nif (prev_p_bit != p_bit)\r\n{\r\n*remaining_bits = 0;\r\n*old_input_bit_order = input_bit_order;\r\n}\r\nif (*remaining_bits + extra_bytes_available * 8 < length)\r\n{\r\n*result_code = 11;\r\nreturn 0xfbad;\r\n}\r\nwhile (bits_still_required > 0)\r\n{\r\nif (*remaining_bits == 0)\r\n{\r\noctet = tvb_get_guint8(message_tvb, *input_address);\r\nif (print_level_1 ){\r\nproto_tree_add_text(udvm_tree, message_tvb, *input_address , 1,\r\n" Getting value: %u (0x%x) From Addr: %u", octet, octet, *input_address);\r\n}\r\n*input_address = *input_address + 1;\r\nif (p_bit != 0)\r\n{\r\noctet = reverse[octet];\r\n}\r\n*input_bits = octet;\r\n*remaining_bits = 8;\r\n}\r\nbits_to_use = bits_still_required < *remaining_bits ? bits_still_required : *remaining_bits;\r\nbits_still_required -= bits_to_use;\r\n*input_bits <<= bits_to_use;\r\nvalue = (value << bits_to_use)\r\n| ((*input_bits >> 8) & 0xFF);\r\n*remaining_bits -= bits_to_use;\r\n*input_bits &= 0x00FF;\r\n}\r\nif (bit_order != 0)\r\n{\r\nguint16 lsb = reverse[(value >> 8) & 0xFF];\r\nguint16 msb = reverse[value & 0xFF];\r\nvalue = ((msb << 8) | lsb) >> (16 - length);\r\n}\r\nreturn value;\r\n}
