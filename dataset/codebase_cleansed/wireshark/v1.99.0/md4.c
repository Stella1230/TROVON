static guint32 F(guint32 X, guint32 Y, guint32 Z)\r\n{\r\nreturn (X&Y) | ((~X)&Z);\r\n}\r\nstatic guint32 G(guint32 X, guint32 Y, guint32 Z)\r\n{\r\nreturn (X&Y) | (X&Z) | (Y&Z);\r\n}\r\nstatic guint32 H(guint32 X, guint32 Y, guint32 Z)\r\n{\r\nreturn X^Y^Z;\r\n}\r\nstatic guint32 lshift(guint32 x, int s)\r\n{\r\nx &= 0xFFFFFFFF;\r\nreturn ((x<<s)&0xFFFFFFFF) | (x>>(32-s));\r\n}\r\nstatic void mdfour64(guint32 *M)\r\n{\r\nint j;\r\nguint32 AA, BB, CC, DD;\r\nguint32 X[16];\r\nfor (j=0;j<16;j++)\r\nX[j] = M[j];\r\nAA = A; BB = B; CC = C; DD = D;\r\nROUND1(A,B,C,D, 0, 3); ROUND1(D,A,B,C, 1, 7);\r\nROUND1(C,D,A,B, 2, 11); ROUND1(B,C,D,A, 3, 19);\r\nROUND1(A,B,C,D, 4, 3); ROUND1(D,A,B,C, 5, 7);\r\nROUND1(C,D,A,B, 6, 11); ROUND1(B,C,D,A, 7, 19);\r\nROUND1(A,B,C,D, 8, 3); ROUND1(D,A,B,C, 9, 7);\r\nROUND1(C,D,A,B, 10, 11); ROUND1(B,C,D,A, 11, 19);\r\nROUND1(A,B,C,D, 12, 3); ROUND1(D,A,B,C, 13, 7);\r\nROUND1(C,D,A,B, 14, 11); ROUND1(B,C,D,A, 15, 19);\r\nROUND2(A,B,C,D, 0, 3); ROUND2(D,A,B,C, 4, 5);\r\nROUND2(C,D,A,B, 8, 9); ROUND2(B,C,D,A, 12, 13);\r\nROUND2(A,B,C,D, 1, 3); ROUND2(D,A,B,C, 5, 5);\r\nROUND2(C,D,A,B, 9, 9); ROUND2(B,C,D,A, 13, 13);\r\nROUND2(A,B,C,D, 2, 3); ROUND2(D,A,B,C, 6, 5);\r\nROUND2(C,D,A,B, 10, 9); ROUND2(B,C,D,A, 14, 13);\r\nROUND2(A,B,C,D, 3, 3); ROUND2(D,A,B,C, 7, 5);\r\nROUND2(C,D,A,B, 11, 9); ROUND2(B,C,D,A, 15, 13);\r\nROUND3(A,B,C,D, 0, 3); ROUND3(D,A,B,C, 8, 9);\r\nROUND3(C,D,A,B, 4, 11); ROUND3(B,C,D,A, 12, 15);\r\nROUND3(A,B,C,D, 2, 3); ROUND3(D,A,B,C, 10, 9);\r\nROUND3(C,D,A,B, 6, 11); ROUND3(B,C,D,A, 14, 15);\r\nROUND3(A,B,C,D, 1, 3); ROUND3(D,A,B,C, 9, 9);\r\nROUND3(C,D,A,B, 5, 11); ROUND3(B,C,D,A, 13, 15);\r\nROUND3(A,B,C,D, 3, 3); ROUND3(D,A,B,C, 11, 9);\r\nROUND3(C,D,A,B, 7, 11); ROUND3(B,C,D,A, 15, 15);\r\nA += AA; B += BB; C += CC; D += DD;\r\nA &= 0xFFFFFFFF; B &= 0xFFFFFFFF;\r\nC &= 0xFFFFFFFF; D &= 0xFFFFFFFF;\r\nfor (j=0;j<16;j++)\r\nX[j] = 0;\r\n}\r\nstatic void copy64(guint32 *M, const unsigned char *in)\r\n{\r\nint i;\r\nfor (i=0;i<16;i++)\r\nM[i] = (in[i*4+3]<<24) | (in[i*4+2]<<16) |\r\n(in[i*4+1]<<8) | (in[i*4+0]<<0);\r\n}\r\nstatic void copy4(unsigned char *out, guint32 x)\r\n{\r\nout[0] = x&0xFF;\r\nout[1] = (x>>8)&0xFF;\r\nout[2] = (x>>16)&0xFF;\r\nout[3] = (x>>24)&0xFF;\r\n}\r\nvoid crypt_md4(unsigned char *out, const unsigned char *in, size_t n)\r\n{\r\nunsigned char buf[128];\r\nguint32 M[16];\r\nguint32 b = (guint32)(n * 8);\r\nint i;\r\nA = 0x67452301;\r\nB = 0xefcdab89;\r\nC = 0x98badcfe;\r\nD = 0x10325476;\r\nwhile (n > 64) {\r\ncopy64(M, in);\r\nmdfour64(M);\r\nin += 64;\r\nn -= 64;\r\n}\r\nfor (i=0;i<128;i++)\r\nbuf[i] = 0;\r\nmemcpy(buf, in, n);\r\nbuf[n] = 0x80;\r\nif (n <= 55) {\r\ncopy4(buf+56, b);\r\ncopy64(M, buf);\r\nmdfour64(M);\r\n} else {\r\ncopy4(buf+120, b);\r\ncopy64(M, buf);\r\nmdfour64(M);\r\ncopy64(M, buf+64);\r\nmdfour64(M);\r\n}\r\nfor (i=0;i<128;i++)\r\nbuf[i] = 0;\r\ncopy64(M, buf);\r\ncopy4(out, A);\r\ncopy4(out+4, B);\r\ncopy4(out+8, C);\r\ncopy4(out+12, D);\r\nA = B = C = D = 0;\r\n}
