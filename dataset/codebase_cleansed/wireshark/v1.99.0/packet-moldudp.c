static guint\r\ndissect_moldudp_msgblk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nguint offset, guint32 sequence)\r\n{\r\nproto_item *ti;\r\nproto_tree *blk_tree;\r\nguint16 msglen, real_msglen, whole_len;\r\nguint remaining;\r\nif (tvb_reported_length(tvb) - offset < MOLDUDP_MSGLEN_LEN)\r\nreturn 0;\r\nmsglen = tvb_get_letohs(tvb, offset);\r\nremaining = tvb_reported_length(tvb) - offset - MOLDUDP_MSGLEN_LEN;\r\nif (msglen == 0)\r\ncol_set_str(pinfo->cinfo, COL_INFO, "MoldUDP Messages (End Of Session)");\r\nif (tvb_reported_length(tvb) < (offset + MOLDUDP_MSGLEN_LEN))\r\nreal_msglen = 0;\r\nelse if (msglen <= remaining)\r\nreal_msglen = msglen;\r\nelse\r\nreal_msglen = remaining;\r\nwhole_len = real_msglen + MOLDUDP_MSGLEN_LEN;\r\nti = proto_tree_add_item(tree, hf_moldudp_msgblk,\r\ntvb, offset, whole_len, ENC_NA);\r\nblk_tree = proto_item_add_subtree(ti, ett_moldudp_msgblk);\r\nti = proto_tree_add_uint(blk_tree, hf_moldudp_msgseq,\r\ntvb, offset, 0, sequence);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nti = proto_tree_add_item(blk_tree, hf_moldudp_msglen,\r\ntvb, offset, MOLDUDP_MSGLEN_LEN, ENC_LITTLE_ENDIAN);\r\nif (msglen != real_msglen)\r\nexpert_add_info_format(pinfo, ti, &ei_moldudp_msglen_invalid,\r\n"Invalid Message Length (claimed %u, found %u)",\r\nmsglen, real_msglen);\r\noffset += MOLDUDP_MSGLEN_LEN;\r\nproto_tree_add_item(blk_tree, hf_moldudp_msgdata,\r\ntvb, offset, real_msglen, ENC_NA);\r\nreturn whole_len;\r\n}\r\nstatic int\r\ndissect_moldudp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *moldudp_tree;\r\nguint offset = 0;\r\nguint16 count, real_count = 0;\r\nguint32 sequence;\r\nif (tvb_reported_length(tvb) < (MOLDUDP_SESSION_LEN +\r\nMOLDUDP_SEQUENCE_LEN +\r\nMOLDUDP_COUNT_LEN))\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MoldUDP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ncount = tvb_get_letohs(tvb, MOLDUDP_SESSION_LEN + MOLDUDP_SEQUENCE_LEN);\r\nif (count == MOLDUDP_HEARTBEAT)\r\ncol_set_str(pinfo->cinfo, COL_INFO, "MoldUDP Heartbeat");\r\nelse\r\ncol_set_str(pinfo->cinfo, COL_INFO, "MoldUDP Messages");\r\nti = proto_tree_add_item(tree, proto_moldudp,\r\ntvb, offset, -1, ENC_NA);\r\nmoldudp_tree = proto_item_add_subtree(ti, ett_moldudp);\r\nproto_tree_add_item(moldudp_tree, hf_moldudp_session,\r\ntvb, offset, MOLDUDP_SESSION_LEN, ENC_ASCII|ENC_NA);\r\noffset += MOLDUDP_SESSION_LEN;\r\nsequence = tvb_get_letohl(tvb, offset);\r\nproto_tree_add_item(moldudp_tree, hf_moldudp_sequence,\r\ntvb, offset, MOLDUDP_SEQUENCE_LEN, ENC_LITTLE_ENDIAN);\r\noffset += MOLDUDP_SEQUENCE_LEN;\r\nti = proto_tree_add_item(moldudp_tree, hf_moldudp_count,\r\ntvb, offset, MOLDUDP_COUNT_LEN, ENC_LITTLE_ENDIAN);\r\noffset += MOLDUDP_COUNT_LEN;\r\nwhile (tvb_reported_length(tvb) >= offset + MOLDUDP_MSGLEN_LEN)\r\n{\r\noffset += dissect_moldudp_msgblk(tvb, pinfo, moldudp_tree,\r\noffset, sequence++);\r\nreal_count++;\r\n}\r\nif (real_count != count)\r\n{\r\nexpert_add_info_format(pinfo, ti, &ei_moldudp_count_invalid,\r\n"Invalid Message Count (claimed %u, found %u)",\r\ncount, real_count);\r\n}\r\nreturn tvb_length(tvb);\r\n}\r\nvoid\r\nproto_register_moldudp(void)\r\n{\r\nmodule_t *moldudp_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_moldudp_session,\r\n{ "Session", "moldudp.session", FT_STRING, BASE_NONE, NULL, 0,\r\n"The session to which this packet belongs.", HFILL }},\r\n{ &hf_moldudp_sequence,\r\n{ "Sequence", "moldudp.sequence", FT_UINT32, BASE_DEC, NULL, 0,\r\n"The sequence number of the first message in this packet.", HFILL }},\r\n{ &hf_moldudp_count,\r\n{ "Count", "moldudp.count", FT_UINT16, BASE_DEC, NULL, 0,\r\n"The number of messages contained in this packet.", HFILL }},\r\n{ &hf_moldudp_msgblk,\r\n{ "Message Block", "moldudp.msgblock", FT_NONE, BASE_NONE, NULL, 0,\r\n"A message.", HFILL }},\r\n{ &hf_moldudp_msglen,\r\n{ "Length", "moldudp.msglen", FT_UINT16, BASE_DEC, NULL, 0,\r\n"The length of this message.", HFILL }},\r\n{ &hf_moldudp_msgseq,\r\n{ "Sequence", "moldudp.msgseq", FT_UINT32, BASE_DEC, NULL, 0,\r\n"The sequence number of this message.", HFILL }},\r\n{ &hf_moldudp_msgdata,\r\n{ "Payload", "moldudp.msgdata", FT_BYTES, BASE_NONE, NULL, 0,\r\n"The payload data of this message.", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_moldudp,\r\n&ett_moldudp_msgblk\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_moldudp_msglen_invalid, { "moldudp.msglen.invalid", PI_MALFORMED, PI_ERROR, "Invalid Message Length", EXPFILL }},\r\n{ &ei_moldudp_count_invalid, { "moldudp.count.invalid", PI_MALFORMED, PI_ERROR, "Invalid Count", EXPFILL }},\r\n};\r\nexpert_module_t* expert_moldudp;\r\nproto_moldudp = proto_register_protocol("MoldUDP",\r\n"MoldUDP", "moldudp");\r\nproto_register_field_array(proto_moldudp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_moldudp = expert_register_protocol(proto_moldudp);\r\nexpert_register_field_array(expert_moldudp, ei, array_length(ei));\r\nmoldudp_module = prefs_register_protocol(proto_moldudp,\r\nproto_reg_handoff_moldudp);\r\nprefs_register_uint_preference(moldudp_module, "udp.port", "MoldUDP UDP Port",\r\n"MoldUDP UDP port to capture on.",\r\n10, &pf_moldudp_port);\r\n}\r\nvoid\r\nproto_reg_handoff_moldudp(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic dissector_handle_t moldudp_handle;\r\nstatic int currentPort;\r\nif (!initialized) {\r\nmoldudp_handle = new_create_dissector_handle(dissect_moldudp,\r\nproto_moldudp);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", currentPort, moldudp_handle);\r\n}\r\ncurrentPort = pf_moldudp_port;\r\ndissector_add_uint("udp.port", currentPort, moldudp_handle);\r\n}
