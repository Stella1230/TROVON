static void\r\ndiscard_existing_list (GList **flp)\r\n{\r\nGList *fl_ent;\r\nprotocol_def *prot;\r\nif (*flp != NULL) {\r\nfl_ent = g_list_first(*flp);\r\nwhile (fl_ent != NULL) {\r\nprot = (protocol_def *) fl_ent->data;\r\ng_free(prot->name);\r\ng_free(prot);\r\nfl_ent = fl_ent->next;\r\n}\r\ng_list_free(*flp);\r\n*flp = NULL;\r\n}\r\n}\r\nvoid\r\nread_disabled_protos_list(char **gpath_return, int *gopen_errno_return,\r\nint *gread_errno_return,\r\nchar **path_return, int *open_errno_return,\r\nint *read_errno_return)\r\n{\r\nint err;\r\nchar *gff_path, *ff_path;\r\nFILE *ff;\r\ngff_path = get_datafile_path(GLOBAL_PROTOCOLS_FILE_NAME);\r\ndiscard_existing_list (&global_disabled_protos);\r\n*gpath_return = NULL;\r\nif ((ff = ws_fopen(gff_path, "r")) != NULL) {\r\nerr = read_disabled_protos_list_file(gff_path, ff,\r\n&global_disabled_protos);\r\nif (err != 0) {\r\n*gopen_errno_return = 0;\r\n*gread_errno_return = err;\r\n*gpath_return = gff_path;\r\n} else\r\ng_free(gff_path);\r\nfclose(ff);\r\n} else {\r\nif (errno != ENOENT) {\r\n*gopen_errno_return = errno;\r\n*gread_errno_return = 0;\r\n*gpath_return = gff_path;\r\n} else\r\ng_free(gff_path);\r\n}\r\nff_path = get_persconffile_path(PROTOCOLS_FILE_NAME, TRUE);\r\ndiscard_existing_list (&disabled_protos);\r\n*path_return = NULL;\r\nif ((ff = ws_fopen(ff_path, "r")) != NULL) {\r\nerr = read_disabled_protos_list_file(ff_path, ff, &disabled_protos);\r\nif (err != 0) {\r\n*open_errno_return = 0;\r\n*read_errno_return = err;\r\n*path_return = ff_path;\r\n} else\r\ng_free(ff_path);\r\nfclose(ff);\r\n} else {\r\nif (errno != ENOENT) {\r\n*open_errno_return = errno;\r\n*read_errno_return = 0;\r\n*path_return = ff_path;\r\n} else\r\ng_free(ff_path);\r\n}\r\n}\r\nstatic int\r\nread_disabled_protos_list_file(const char *ff_path, FILE *ff,\r\nGList **flp)\r\n{\r\nprotocol_def *prot;\r\nint c;\r\nchar *prot_name;\r\nint prot_name_len;\r\nint prot_name_index;\r\nint line = 1;\r\nprot_name_len = INIT_BUF_SIZE;\r\nprot_name = (char *)g_malloc(prot_name_len + 1);\r\nfor (line = 1; ; line++) {\r\nwhile ((c = getc(ff)) != EOF && isspace(c)) {\r\nif (c == '\n') {\r\ncontinue;\r\n}\r\n}\r\nif (c == EOF) {\r\nif (ferror(ff))\r\ngoto error;\r\nelse\r\nbreak;\r\n}\r\nungetc(c, ff);\r\nprot_name_index = 0;\r\nfor (;;) {\r\nc = getc(ff);\r\nif (c == EOF)\r\nbreak;\r\nif (isspace(c))\r\nbreak;\r\nif (c == '#')\r\nbreak;\r\nif (prot_name_index >= prot_name_len) {\r\nprot_name_len *= 2;\r\nprot_name = (char *)g_realloc(prot_name, prot_name_len + 1);\r\n}\r\nprot_name[prot_name_index] = c;\r\nprot_name_index++;\r\n}\r\nif (isspace(c) && c != '\n') {\r\nwhile ((c = getc(ff)) != EOF && c != '\n' && isspace(c))\r\n;\r\nif (c != EOF && c != '\n' && c != '#') {\r\ng_warning("'%s' line %d has extra stuff after the protocol name.",\r\nff_path, line);\r\n}\r\n}\r\nif (c != EOF && c != '\n') {\r\nwhile ((c = getc(ff)) != EOF && c != '\n')\r\n;\r\n}\r\nif (c == EOF) {\r\nif (ferror(ff))\r\ngoto error;\r\nelse {\r\ng_warning("'%s' line %d doesn't have a newline.", ff_path,\r\nline);\r\n}\r\nbreak;\r\n}\r\nif (prot_name_index >= prot_name_len) {\r\nprot_name_len *= 2;\r\nprot_name = (char *)g_realloc(prot_name, prot_name_len + 1);\r\n}\r\nprot_name[prot_name_index] = '\0';\r\nprot = (protocol_def *) g_malloc(sizeof(protocol_def));\r\nprot->name = g_strdup(prot_name);\r\n*flp = g_list_append(*flp, prot);\r\n}\r\ng_free(prot_name);\r\nreturn 0;\r\nerror:\r\nreturn errno;\r\n}\r\nvoid\r\nset_disabled_protos_list(void)\r\n{\r\ngint i;\r\nGList *fl_ent;\r\nprotocol_def *prot;\r\nif (disabled_protos == NULL)\r\ngoto skip;\r\nfl_ent = g_list_first(disabled_protos);\r\nwhile (fl_ent != NULL) {\r\nprot = (protocol_def *) fl_ent->data;\r\ni = proto_get_id_by_filter_name(prot->name);\r\nif (i == -1) {\r\n} else {\r\nif (proto_can_toggle_protocol(i))\r\nproto_set_decoding(i, FALSE);\r\n}\r\nfl_ent = fl_ent->next;\r\n}\r\nskip:\r\nif (global_disabled_protos == NULL)\r\nreturn;\r\nfl_ent = g_list_first(global_disabled_protos);\r\nwhile (fl_ent != NULL) {\r\nprot = (protocol_def *) fl_ent->data;\r\ni = proto_get_id_by_filter_name(prot->name);\r\nif (i == -1) {\r\n} else {\r\nif (proto_can_toggle_protocol(i)) {\r\nproto_set_decoding(i, FALSE);\r\nproto_set_cant_toggle(i);\r\n}\r\n}\r\nfl_ent = fl_ent->next;\r\n}\r\n}\r\nvoid\r\nsave_disabled_protos_list(char **pref_path_return, int *errno_return)\r\n{\r\ngchar *ff_path, *ff_path_new;\r\nFILE *ff;\r\ngint i;\r\nprotocol_t *protocol;\r\nvoid *cookie;\r\n*pref_path_return = NULL;\r\nff_path = get_persconffile_path(PROTOCOLS_FILE_NAME, TRUE);\r\nff_path_new = g_strdup_printf("%s.new", ff_path);\r\nif ((ff = ws_fopen(ff_path_new, "w")) == NULL) {\r\n*pref_path_return = ff_path;\r\n*errno_return = errno;\r\ng_free(ff_path_new);\r\nreturn;\r\n}\r\nfor (i = proto_get_first_protocol(&cookie); i != -1;\r\ni = proto_get_next_protocol(&cookie)) {\r\nif (!proto_can_toggle_protocol(i)) {\r\ncontinue;\r\n}\r\nprotocol = find_protocol_by_id(i);\r\nif (proto_is_protocol_enabled(protocol)) {\r\ncontinue;\r\n}\r\nfprintf(ff, "%s\n", proto_get_protocol_filter_name(i));\r\n}\r\nif (fclose(ff) == EOF) {\r\n*pref_path_return = ff_path;\r\n*errno_return = errno;\r\nws_unlink(ff_path_new);\r\ng_free(ff_path_new);\r\nreturn;\r\n}\r\n#ifdef _WIN32\r\nif (ws_remove(ff_path) < 0 && errno != ENOENT) {\r\n*pref_path_return = ff_path;\r\n*errno_return = errno;\r\nws_unlink(ff_path_new);\r\ng_free(ff_path_new);\r\nreturn;\r\n}\r\n#endif\r\nif (ws_rename(ff_path_new, ff_path) < 0) {\r\n*pref_path_return = ff_path;\r\n*errno_return = errno;\r\nws_unlink(ff_path_new);\r\ng_free(ff_path_new);\r\nreturn;\r\n}\r\ng_free(ff_path_new);\r\ng_free(ff_path);\r\n}
