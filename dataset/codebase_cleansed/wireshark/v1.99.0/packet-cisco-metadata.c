static void\r\ndissect_cmd(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\nguint16 encap_proto;\r\nethertype_data_t ethertype_data;\r\nproto_tree *cmd_tree = NULL;\r\ngint offset = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "CMD");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree) {\r\nproto_item *ti = proto_tree_add_item(tree, proto_cmd, tvb, 0, 6, ENC_NA);\r\ncmd_tree = proto_item_add_subtree(ti, ett_cmd);\r\nproto_tree_add_item(cmd_tree, hf_cmd_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(cmd_tree, hf_cmd_length, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(cmd_tree, hf_cmd_options, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(cmd_tree, hf_cmd_sgt, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\nencap_proto = tvb_get_ntohs(tvb, 6);\r\n#if 0\r\nif (encap_proto <= IEEE_802_3_MAX_LEN) {\r\ngboolean is_802_2 = TRUE;\r\nif (tvb_length_remaining(tvb, 4) >= 2) {\r\nif (tvb_get_ntohs(tvb, 4) == 0xffff)\r\nis_802_2 = FALSE;\r\n}\r\ndissect_802_3(encap_proto, is_802_2, tvb, 4, pinfo, tree, cmd_tree, hf_eth_type, hf_cmd_trailer, 0);\r\n} else {\r\n#endif\r\nethertype_data.etype = encap_proto;\r\nethertype_data.offset_after_ethertype = 8;\r\nethertype_data.fh_tree = cmd_tree;\r\nethertype_data.etype_id = hf_eth_type;\r\nethertype_data.trailer_id = hf_cmd_trailer;\r\nethertype_data.fcs_len = 0;\r\ncall_dissector_with_data(ethertype_handle, tvb, pinfo, tree, &ethertype_data);\r\n}\r\nvoid\r\nproto_register_cmd(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_cmd_version,\r\n{ "Version", "cmd.version", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_cmd_length,\r\n{ "Length", "cmd.length", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_cmd_options,\r\n{ "Options", "cmd.options", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_cmd_sgt,\r\n{ "SGT", "cmd.sgt", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }\r\n},\r\n{ &hf_eth_type,\r\n{ "Type", "cmd.type", FT_UINT16, BASE_HEX, VALS(etype_vals), 0x0, NULL, HFILL }\r\n},\r\n{ &hf_cmd_trailer,\r\n{ "Trailer", "cmd.trailer", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_cmd\r\n};\r\nproto_cmd = proto_register_protocol("Cisco MetaData", "Cisco MetaData", "cmd");\r\nproto_register_field_array(proto_cmd, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_cmd(void)\r\n{\r\ndissector_handle_t cmd_handle;\r\nethertype_handle = find_dissector("ethertype");\r\ncmd_handle = create_dissector_handle(dissect_cmd, proto_cmd);\r\ndissector_add_uint("ethertype", ETHERTYPE_CMD, cmd_handle);\r\n}
