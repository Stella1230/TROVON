TreeItem* push_TreeItem(lua_State*L, TreeItem t) {\r\ng_ptr_array_add(outstanding_TreeItem,t);\r\nreturn pushTreeItem(L,t);\r\n}\r\nstatic proto_item *\r\ntry_add_packet_field(lua_State *L, TreeItem tree_item, TvbRange tvbr, const int hfid,\r\nconst ftenum_t type, const guint encoding, gint *ret_err)\r\n{\r\ngint err = 0;\r\nproto_item* item = NULL;\r\ngint endoff = 0;\r\nswitch(type) {\r\ncase FT_BYTES:\r\ncase FT_UINT_BYTES:\r\ncase FT_OID:\r\ncase FT_REL_OID:\r\ncase FT_SYSTEM_ID:\r\n{\r\nGByteArray *gba = g_byte_array_new();\r\nitem = proto_tree_add_bytes_item(tree_item->tree, hfid, tvbr->tvb->ws_tvb,\r\ntvbr->offset, tvbr->len, encoding,\r\ngba, &endoff, &err);\r\nif (err == 0) {\r\npushByteArray(L, gba);\r\nlua_pushinteger(L, endoff);\r\n}\r\n}\r\nbreak;\r\ncase FT_ABSOLUTE_TIME:\r\ncase FT_RELATIVE_TIME:\r\n{\r\nnstime_t *nstime = (nstime_t *) g_malloc0(sizeof(nstime_t));\r\nitem = proto_tree_add_time_item(tree_item->tree, hfid, tvbr->tvb->ws_tvb,\r\ntvbr->offset, tvbr->len, encoding,\r\nnstime, &endoff, &err);\r\nif (err == 0) {\r\npushNSTime(L,nstime);\r\nlua_pushinteger(L, endoff);\r\n}\r\n}\r\nbreak;\r\ncase FT_NONE:\r\ncase FT_PROTOCOL:\r\ndefault:\r\nitem = proto_tree_add_item(tree_item->tree, hfid, tvbr->tvb->ws_tvb, tvbr->offset, tvbr->len, encoding);\r\nlua_pushnil(L);\r\nlua_pushnil(L);\r\nbreak;\r\n}\r\nif (ret_err) *ret_err = err;\r\nreturn item;\r\n}\r\nWSLUA_METHOD TreeItem_add_packet_field(lua_State *L) {\r\n#define WSLUA_ARG_TreeItem_add_packet_field_PROTOFIELD 2\r\n#define WSLUA_OPTARG_TreeItem_add_packet_field_TVBRANGE 3\r\n#define WSLUA_ARG_TreeItem_add_packet_field_ENCODING 4\r\n#define WSLUA_OPTARG_TreeItem_add_packet_field_LABEL 5\r\nvolatile TvbRange tvbr;\r\nProtoField field;\r\nint hfid;\r\nvolatile int ett;\r\nftenum_t type;\r\nTreeItem tree_item = shiftTreeItem(L,1);\r\nguint encoding;\r\nproto_item* item = NULL;\r\nvolatile int nargs;\r\nvolatile gint err = 0;\r\nconst char *volatile error = NULL;\r\nif (!tree_item) {\r\nreturn luaL_error(L,"not a TreeItem!");\r\n}\r\nif (tree_item->expired) {\r\nluaL_error(L,"expired TreeItem");\r\nreturn 0;\r\n}\r\nif (! ( field = shiftProtoField(L,1) ) ) {\r\nluaL_error(L,"TreeField:add_packet_field not passed a ProtoField");\r\nreturn 0;\r\n}\r\nhfid = field->hfid;\r\ntype = field->type;\r\nett = field->ett;\r\ntvbr = shiftTvbRange(L,1);\r\nif (!tvbr) {\r\ntvbr = ep_new(struct _wslua_tvbrange);\r\ntvbr->tvb = ep_new(struct _wslua_tvb);\r\ntvbr->tvb->ws_tvb = lua_tvb;\r\ntvbr->offset = 0;\r\ntvbr->len = 0;\r\n}\r\nencoding = wslua_checkguint(L,1);\r\nlua_remove(L,1);\r\nnargs = lua_gettop(L);\r\nif (type == FT_STRINGZ) {\r\nswitch (encoding & ENC_CHARENCODING_MASK) {\r\ncase ENC_UTF_16:\r\ncase ENC_UCS_2:\r\ntvbr->len = tvb_unicode_strsize (tvbr->tvb->ws_tvb, tvbr->offset);\r\nbreak;\r\ndefault:\r\ntvbr->len = tvb_strsize (tvbr->tvb->ws_tvb, tvbr->offset);\r\nbreak;\r\n}\r\n}\r\nTRY {\r\ngint errx = 0;\r\nitem = try_add_packet_field(L, tree_item, tvbr, hfid, type, encoding, &errx);\r\nerr = errx;\r\n} CATCH_ALL {\r\nshow_exception(tvbr->tvb->ws_tvb, lua_pinfo, tree_item->tree, EXCEPT_CODE, GET_MESSAGE);\r\nerror = "Lua programming error";\r\n} ENDTRY;\r\nif (error) { WSLUA_ERROR(TreeItem_add_packet_field,error); }\r\nif (err != 0) {\r\nlua_pushnil(L);\r\nlua_pushnil(L);\r\n}\r\nwhile(nargs) {\r\nconst gchar* s;\r\ns = lua_tostring(L,1);\r\nif (s) proto_item_append_text(item, " %s", s);\r\nlua_remove(L,1);\r\nnargs--;\r\n}\r\ntree_item = (TreeItem)g_malloc(sizeof(struct _wslua_treeitem));\r\ntree_item->item = item;\r\ntree_item->tree = proto_item_add_subtree(item,ett > 0 ? ett : wslua_ett);\r\ntree_item->expired = FALSE;\r\nPUSH_TREEITEM(L,tree_item);\r\nlua_insert(L, 1);\r\nWSLUA_RETURN(3);\r\n}\r\nstatic int TreeItem_add_item_any(lua_State *L, gboolean little_endian) {\r\nTvbRange tvbr;\r\nProto proto;\r\nProtoField field;\r\nint hfid = -1;\r\nint ett = -1;\r\nftenum_t type = FT_NONE;\r\nTreeItem tree_item = shiftTreeItem(L,1);\r\nproto_item* item = NULL;\r\nif (!tree_item) {\r\nreturn luaL_error(L,"not a TreeItem!");\r\n}\r\nif (tree_item->expired) {\r\nluaL_error(L,"expired TreeItem");\r\nreturn 0;\r\n}\r\nif (! ( field = shiftProtoField(L,1) ) ) {\r\nif (( proto = shiftProto(L,1) )) {\r\nhfid = proto->hfid;\r\ntype = FT_PROTOCOL;\r\nett = proto->ett;\r\n}\r\n} else {\r\nhfid = field->hfid;\r\ntype = field->type;\r\nett = field->ett;\r\n}\r\ntvbr = shiftTvbRange(L,1);\r\nif (!tvbr) {\r\ntvbr = ep_new(struct _wslua_tvbrange);\r\ntvbr->tvb = ep_new(struct _wslua_tvb);\r\ntvbr->tvb->ws_tvb = lua_tvb;\r\ntvbr->offset = 0;\r\ntvbr->len = 0;\r\n}\r\nif (hfid > 0 ) {\r\nif (lua_gettop(L)) {\r\nswitch(type) {\r\ncase FT_PROTOCOL:\r\nitem = proto_tree_add_item(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,ENC_NA);\r\nlua_pushnumber(L,0);\r\nlua_insert(L,1);\r\nbreak;\r\ncase FT_BOOLEAN:\r\n{\r\nguint32 val = (guint32) (wslua_tointeger(L,1));\r\nitem = proto_tree_add_boolean(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,val);\r\n}\r\nbreak;\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\ncase FT_FRAMENUM:\r\nitem = proto_tree_add_uint(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,wslua_checkguint32(L,1));\r\nbreak;\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\nitem = proto_tree_add_int(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,wslua_checkguint32(L,1));\r\nbreak;\r\ncase FT_FLOAT:\r\nitem = proto_tree_add_float(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,(float)luaL_checknumber(L,1));\r\nbreak;\r\ncase FT_DOUBLE:\r\nitem = proto_tree_add_double(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,(double)luaL_checknumber(L,1));\r\nbreak;\r\ncase FT_ABSOLUTE_TIME:\r\ncase FT_RELATIVE_TIME:\r\nitem = proto_tree_add_time(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,checkNSTime(L,1));\r\nbreak;\r\ncase FT_STRING:\r\nitem = proto_tree_add_string(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,luaL_checkstring(L,1));\r\nbreak;\r\ncase FT_STRINGZ:\r\nitem = proto_tree_add_string(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvb_strsize (tvbr->tvb->ws_tvb, tvbr->offset),luaL_checkstring(L,1));\r\nbreak;\r\ncase FT_BYTES:\r\nitem = proto_tree_add_bytes(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len, (const guint8*) luaL_checkstring(L,1));\r\nbreak;\r\ncase FT_UINT64:\r\nitem = proto_tree_add_uint64(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,checkUInt64(L,1));\r\nbreak;\r\ncase FT_INT64:\r\nitem = proto_tree_add_int64(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,checkInt64(L,1));\r\nbreak;\r\ncase FT_IPv4:\r\nitem = proto_tree_add_ipv4(tree_item->tree,hfid,tvbr->tvb->ws_tvb,tvbr->offset,tvbr->len,*((const guint32*)(checkAddress(L,1)->data)));\r\nbreak;\r\ncase FT_ETHER:\r\ncase FT_UINT_BYTES:\r\ncase FT_IPv6:\r\ncase FT_IPXNET:\r\ncase FT_GUID:\r\ncase FT_OID:\r\ncase FT_REL_OID:\r\ncase FT_SYSTEM_ID:\r\ndefault:\r\nluaL_error(L,"FT_ not yet supported");\r\nreturn 0;\r\n}\r\nlua_remove(L,1);\r\n} else {\r\nif (type == FT_STRINGZ) tvbr->len = tvb_strsize (tvbr->tvb->ws_tvb, tvbr->offset);\r\nitem = proto_tree_add_item(tree_item->tree, hfid, tvbr->tvb->ws_tvb, tvbr->offset, tvbr->len, little_endian ? ENC_LITTLE_ENDIAN : ENC_BIG_ENDIAN);\r\n}\r\nif ( lua_gettop(L) ) {\r\nconst gchar* s = lua_tostring(L,1);\r\nif (s) proto_item_set_text(item,"%s",s);\r\nlua_remove(L,1);\r\n}\r\n} else {\r\nif (lua_gettop(L)) {\r\nconst gchar* s = lua_tostring(L,1);\r\nitem = proto_tree_add_text(tree_item->tree, tvbr->tvb->ws_tvb, tvbr->offset, tvbr->len,"%s",s);\r\nlua_remove(L,1);\r\n} else {\r\nluaL_error(L,"Tree item ProtoField/Protocol handle is invalid (ProtoField/Proto not registered?)");\r\n}\r\n}\r\nwhile(lua_gettop(L)) {\r\nconst gchar* s = lua_tostring(L,1);\r\nif (s) proto_item_append_text(item, " %s", s);\r\nlua_remove(L,1);\r\n}\r\ntree_item = (TreeItem)g_malloc(sizeof(struct _wslua_treeitem));\r\ntree_item->item = item;\r\ntree_item->tree = proto_item_add_subtree(item,ett > 0 ? ett : wslua_ett);\r\ntree_item->expired = FALSE;\r\nPUSH_TREEITEM(L,tree_item);\r\nreturn 1;\r\n}\r\nWSLUA_METHOD TreeItem_add(lua_State *L) {\r\n#define WSLUA_ARG_TreeItem_add_PROTOFIELD 2\r\n#define WSLUA_OPTARG_TreeItem_add_TVBRANGE 3\r\n#define WSLUA_OPTARG_TreeItem_add_VALUE 4\r\n#define WSLUA_OPTARG_TreeItem_add_LABEL 5\r\nWSLUA_RETURN(TreeItem_add_item_any(L,FALSE));\r\n}\r\nWSLUA_METHOD TreeItem_add_le(lua_State *L) {\r\n#define WSLUA_ARG_TreeItem_add_le_PROTOFIELD 2\r\n#define WSLUA_OPTARG_TreeItem_add_le_TVBRANGE 3\r\n#define WSLUA_OPTARG_TreeItem_add_le_VALUE 4\r\n#define WSLUA_OPTARG_TreeItem_add_le_LABEL 5\r\nWSLUA_RETURN(TreeItem_add_item_any(L,TRUE));\r\n}\r\nWSLUA_METHOD TreeItem_set_text(lua_State *L) {\r\n#define WSLUA_ARG_TreeItem_set_text_TEXT 2\r\nTreeItem ti = checkTreeItem(L,1);\r\nconst gchar* s = luaL_checkstring(L,WSLUA_ARG_TreeItem_set_text_TEXT);\r\nproto_item_set_text(ti->item,"%s",s);\r\nlua_pushvalue(L, 1);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD TreeItem_append_text(lua_State *L) {\r\n#define WSLUA_ARG_TreeItem_append_text_TEXT 2\r\nTreeItem ti = checkTreeItem(L,1);\r\nconst gchar* s = luaL_checkstring(L,WSLUA_ARG_TreeItem_append_text_TEXT);\r\nproto_item_append_text(ti->item,"%s",s);\r\nlua_pushvalue(L, 1);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD TreeItem_prepend_text(lua_State *L) {\r\n#define WSLUA_ARG_TreeItem_prepend_text_TEXT 2\r\nTreeItem ti = checkTreeItem(L,1);\r\nconst gchar* s = luaL_checkstring(L,WSLUA_ARG_TreeItem_prepend_text_TEXT);\r\nproto_item_prepend_text(ti->item,"%s",s);\r\nlua_pushvalue(L, 1);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD TreeItem_add_expert_info(lua_State *L) {\r\n#define WSLUA_OPTARG_TreeItem_add_expert_info_GROUP 2\r\n#define WSLUA_OPTARG_TreeItem_add_expert_info_SEVERITY 3\r\n#define WSLUA_OPTARG_TreeItem_add_expert_info_TEXT 4\r\nTreeItem ti = checkTreeItem(L,1);\r\nint group = luaL_optint(L,WSLUA_OPTARG_TreeItem_add_expert_info_GROUP,PI_DEBUG);\r\nint severity = luaL_optint(L,WSLUA_OPTARG_TreeItem_add_expert_info_SEVERITY,PI_CHAT);\r\nexpert_field* ei_info = wslua_get_expert_field(group, severity);\r\nconst gchar* str;\r\nif (lua_gettop(L) >= WSLUA_OPTARG_TreeItem_add_expert_info_TEXT) {\r\nstr = wslua_checkstring_only(L, WSLUA_OPTARG_TreeItem_add_expert_info_TEXT);\r\nexpert_add_info_format(lua_pinfo, ti->item, ei_info, "%s", str);\r\n} else {\r\nexpert_add_info(lua_pinfo, ti->item, ei_info);\r\n}\r\nlua_pushvalue(L, 1);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD TreeItem_add_proto_expert_info(lua_State *L) {\r\n#define WSLUA_ARG_TreeItem_add_proto_expert_info_EXPERT 2\r\n#define WSLUA_OPTARG_TreeItem_add_proto_expert_info_TEXT 3\r\nTreeItem ti = checkTreeItem(L,1);\r\nProtoExpert expert = checkProtoExpert(L,WSLUA_ARG_TreeItem_add_proto_expert_info_EXPERT);\r\nconst gchar* str;\r\nif (expert->ids.ei == EI_INIT_EI || expert->ids.hf == EI_INIT_HF) {\r\nluaL_error(L, "ProtoExpert is not registered");\r\nreturn 0;\r\n}\r\nif (lua_gettop(L) >= WSLUA_OPTARG_TreeItem_add_proto_expert_info_TEXT) {\r\nstr = wslua_checkstring_only(L, WSLUA_OPTARG_TreeItem_add_proto_expert_info_TEXT);\r\nexpert_add_info_format(lua_pinfo, ti->item, &expert->ids, "%s", str);\r\n} else {\r\nexpert_add_info(lua_pinfo, ti->item, &expert->ids);\r\n}\r\nlua_pushvalue(L, 1);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD TreeItem_add_tvb_expert_info(lua_State *L) {\r\n#define WSLUA_ARG_TreeItem_add_tvb_expert_info_EXPERT 2\r\n#define WSLUA_ARG_TreeItem_add_tvb_expert_info_TVB 3\r\n#define WSLUA_OPTARG_TreeItem_add_tvb_expert_info_TEXT 4\r\nTreeItem ti = checkTreeItem(L,1);\r\nProtoExpert expert = checkProtoExpert(L,WSLUA_ARG_TreeItem_add_proto_expert_info_EXPERT);\r\nTvbRange tvbr;\r\nconst gchar* str;\r\nif (expert->ids.ei == EI_INIT_EI || expert->ids.hf == EI_INIT_HF) {\r\nluaL_error(L, "ProtoExpert is not registered");\r\nreturn 0;\r\n}\r\ntvbr = shiftTvbRange(L,WSLUA_ARG_TreeItem_add_tvb_expert_info_TVB);\r\nif (!tvbr) {\r\ntvbr = ep_new(struct _wslua_tvbrange);\r\ntvbr->tvb = shiftTvb(L,WSLUA_ARG_TreeItem_add_tvb_expert_info_TVB);\r\nif (!tvbr->tvb) {\r\ntvbr->tvb = ep_new(struct _wslua_tvb);\r\n}\r\ntvbr->tvb->ws_tvb = lua_tvb;\r\ntvbr->offset = 0;\r\ntvbr->len = 0;\r\n}\r\nif (lua_gettop(L) >= WSLUA_OPTARG_TreeItem_add_proto_expert_info_TEXT) {\r\nstr = wslua_checkstring_only(L, WSLUA_OPTARG_TreeItem_add_proto_expert_info_TEXT);\r\nproto_tree_add_expert_format(ti->tree, lua_pinfo, &expert->ids,\r\ntvbr->tvb->ws_tvb, tvbr->offset, tvbr->len,\r\n"%s", str);\r\n} else {\r\nproto_tree_add_expert(ti->tree, lua_pinfo, &expert->ids,\r\ntvbr->tvb->ws_tvb, tvbr->offset, tvbr->len);\r\n}\r\nlua_pushvalue(L, 1);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD TreeItem_set_generated(lua_State *L) {\r\nTreeItem ti = checkTreeItem(L,1);\r\nPROTO_ITEM_SET_GENERATED(ti->item);\r\nlua_pushvalue(L, 1);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD TreeItem_set_hidden(lua_State *L) {\r\nTreeItem ti = checkTreeItem(L,1);\r\nPROTO_ITEM_SET_HIDDEN(ti->item);\r\nlua_pushvalue(L, 1);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD TreeItem_set_len(lua_State *L) {\r\n#define WSLUA_ARG_TreeItem_set_len_LEN 2\r\nTreeItem ti = checkTreeItem(L,1);\r\ngint len = luaL_checkint(L,WSLUA_ARG_TreeItem_set_len_LEN);\r\nproto_item_set_len(ti->item, len);\r\nlua_pushvalue(L, 1);\r\nWSLUA_RETURN(1);\r\n}\r\nstatic int TreeItem__gc(lua_State* L) {\r\nTreeItem ti = toTreeItem(L,1);\r\nif (!ti) return 0;\r\nif (!ti->expired)\r\nti->expired = TRUE;\r\nelse\r\ng_free(ti);\r\nreturn 0;\r\n}\r\nint TreeItem_register(lua_State *L) {\r\ngint* etts[] = { &wslua_ett };\r\nWSLUA_REGISTER_CLASS(TreeItem);\r\noutstanding_TreeItem = g_ptr_array_new();\r\nproto_register_subtree_array(etts,1);\r\nreturn 0;\r\n}
