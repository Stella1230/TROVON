gint\r\npacket_mpeg_sect_mjd_to_utc_time(tvbuff_t *tvb, gint offset, nstime_t *utc_time)\r\n{\r\ngint bcd_time_offset;\r\nguint8 hour, min, sec;\r\nif (!utc_time)\r\nreturn -1;\r\nnstime_set_zero(utc_time);\r\nutc_time->secs = (tvb_get_ntohs(tvb, offset) - 40587) * 86400;\r\nbcd_time_offset = offset+2;\r\nhour = MPEG_SECT_BCD44_TO_DEC(tvb_get_guint8(tvb, bcd_time_offset));\r\nmin = MPEG_SECT_BCD44_TO_DEC(tvb_get_guint8(tvb, bcd_time_offset+1));\r\nsec = MPEG_SECT_BCD44_TO_DEC(tvb_get_guint8(tvb, bcd_time_offset+2));\r\nif (hour>23 || min>59 || sec>59)\r\nreturn -1;\r\nutc_time->secs += hour*3600 + min*60 + sec;\r\nreturn 5;\r\n}\r\nguint\r\npacket_mpeg_sect_header(tvbuff_t *tvb, guint offset,\r\nproto_tree *tree, guint *sect_len, gboolean *ssi)\r\n{\r\nreturn packet_mpeg_sect_header_extra(tvb, offset, tree, sect_len,\r\nNULL, ssi, NULL);\r\n}\r\nguint\r\npacket_mpeg_sect_header_extra(tvbuff_t *tvb, guint offset, proto_tree *tree,\r\nguint *sect_len, guint *reserved, gboolean *ssi,\r\nproto_item **items)\r\n{\r\nguint tmp;\r\nguint len = 0;\r\nproto_item *pi[PACKET_MPEG_SECT_PI__SIZE];\r\ngint i;\r\nfor (i = 0; i < PACKET_MPEG_SECT_PI__SIZE; i++) {\r\npi[i] = NULL;\r\n}\r\nif (tree) {\r\npi[PACKET_MPEG_SECT_PI__TABLE_ID] =\r\nproto_tree_add_item(tree, hf_mpeg_sect_table_id,\r\ntvb, offset + len, 1, ENC_BIG_ENDIAN);\r\n}\r\nlen++;\r\nif (tree) {\r\npi[PACKET_MPEG_SECT_PI__SSI] =\r\nproto_tree_add_item(tree, hf_mpeg_sect_syntax_indicator,\r\ntvb, offset + len, 2, ENC_BIG_ENDIAN);\r\npi[PACKET_MPEG_SECT_PI__RESERVED] =\r\nproto_tree_add_item(tree, hf_mpeg_sect_reserved, tvb,\r\noffset + len, 2, ENC_BIG_ENDIAN);\r\npi[PACKET_MPEG_SECT_PI__LENGTH] =\r\nproto_tree_add_item(tree, hf_mpeg_sect_length, tvb,\r\noffset + len, 2, ENC_BIG_ENDIAN);\r\n}\r\ntmp = tvb_get_ntohs(tvb, offset + len);\r\nif (sect_len)\r\n*sect_len = MPEG_SECT_LENGTH_MASK & tmp;\r\nif (reserved)\r\n*reserved = (MPEG_SECT_RESERVED_MASK & tmp) >> 12;\r\nif (ssi)\r\n*ssi = (MPEG_SECT_SYNTAX_INDICATOR_MASK & tmp);\r\nif (items) {\r\nfor (i = 0; i < PACKET_MPEG_SECT_PI__SIZE; i++) {\r\nitems[i] = pi[i];\r\n}\r\n}\r\nlen += 2;\r\nreturn len;\r\n}\r\nguint\r\npacket_mpeg_sect_crc(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, guint start, guint end)\r\n{\r\nguint32 crc, calculated_crc;\r\nconst char *label;\r\ncrc = tvb_get_ntohl(tvb, end);\r\ncalculated_crc = crc;\r\nlabel = "Unverified";\r\nif (mpeg_sect_check_crc) {\r\nlabel = "Verified";\r\ncalculated_crc = crc32_mpeg2_tvb_offset(tvb, start, end);\r\n}\r\nif (calculated_crc == crc) {\r\nproto_tree_add_uint_format( tree, hf_mpeg_sect_crc, tvb,\r\nend, 4, crc, "CRC: 0x%08x [%s]", crc, label);\r\n} else {\r\nproto_item *msg_error;\r\nmsg_error = proto_tree_add_uint_format( tree, hf_mpeg_sect_crc, tvb,\r\nend, 4, crc,\r\n"CRC: 0x%08x [Failed Verification (Calculated: 0x%08x)]",\r\ncrc, calculated_crc );\r\nPROTO_ITEM_SET_GENERATED(msg_error);\r\nexpert_add_info( pinfo, msg_error, &ei_mpeg_sect_crc);\r\n}\r\nreturn 4;\r\n}\r\nstatic int\r\ndissect_mpeg_sect(tvbuff_t *tvb, packet_info *pinfo,\r\nproto_tree *tree, void *data _U_)\r\n{\r\ngint tvb_len;\r\ngint offset = 0;\r\nguint section_length = 0;\r\ngboolean syntax_indicator = FALSE;\r\nguint8 table_id;\r\nproto_item *ti;\r\nproto_tree *mpeg_sect_tree;\r\ntvb_len = (gint)tvb_reported_length(tvb);\r\nif (tvb_len<MPEG_SECT_MIN_LEN || tvb_len>MPEG_SECT_MAX_LEN)\r\nreturn 0;\r\ntable_id = tvb_get_guint8(tvb, offset);\r\nif (dissector_try_uint(mpeg_sect_tid_dissector_table, table_id, tvb, pinfo, tree))\r\nreturn tvb_len;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MPEG SECT");\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Table ID 0x%02x", table_id);\r\nti = proto_tree_add_item(tree, proto_mpeg_sect, tvb, offset, -1, ENC_NA);\r\nmpeg_sect_tree = proto_item_add_subtree(ti, ett_mpeg_sect);\r\nproto_item_append_text(ti, " Table_ID=0x%02x", table_id);\r\npacket_mpeg_sect_header(tvb, offset, mpeg_sect_tree,\r\n&section_length, &syntax_indicator);\r\nif (syntax_indicator)\r\npacket_mpeg_sect_crc(tvb, pinfo, mpeg_sect_tree, 0, (section_length-1));\r\nreturn tvb_len;\r\n}\r\nvoid\r\nproto_register_mpeg_sect(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_mpeg_sect_table_id, {\r\n"Table ID", "mpeg_sect.tid",\r\nFT_UINT8, BASE_HEX, VALS(mpeg_sect_table_id_vals), 0, NULL, HFILL\r\n} },\r\n{ &hf_mpeg_sect_syntax_indicator, {\r\n"Syntax indicator", "mpeg_sect.syntax_indicator",\r\nFT_UINT16, BASE_DEC, NULL, MPEG_SECT_SYNTAX_INDICATOR_MASK, NULL, HFILL\r\n} },\r\n{ &hf_mpeg_sect_reserved, {\r\n"Reserved", "mpeg_sect.reserved",\r\nFT_UINT16, BASE_HEX, NULL, MPEG_SECT_RESERVED_MASK, NULL, HFILL\r\n} },\r\n{ &hf_mpeg_sect_length, {\r\n"Length", "mpeg_sect.len",\r\nFT_UINT16, BASE_DEC, NULL, MPEG_SECT_LENGTH_MASK, NULL, HFILL\r\n} },\r\n{ &hf_mpeg_sect_crc, {\r\n"CRC 32", "mpeg_sect.crc",\r\nFT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL\r\n} }\r\n};\r\nstatic gint *ett[] = {\r\n&ett_mpeg_sect\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_mpeg_sect_crc, { "mpeg_sect.crc.invalid", PI_CHECKSUM, PI_WARN, "Invalid CRC", EXPFILL }},\r\n};\r\nmodule_t *mpeg_sect_module;\r\nexpert_module_t* expert_mpeg_sect;\r\nproto_mpeg_sect = proto_register_protocol("MPEG2 Section", "MPEG SECT", "mpeg_sect");\r\nnew_register_dissector("mpeg_sect", dissect_mpeg_sect, proto_mpeg_sect);\r\nproto_register_field_array(proto_mpeg_sect, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_mpeg_sect = expert_register_protocol(proto_mpeg_sect);\r\nexpert_register_field_array(expert_mpeg_sect, ei, array_length(ei));\r\nmpeg_sect_module = prefs_register_protocol(proto_mpeg_sect, NULL);\r\nprefs_register_bool_preference(mpeg_sect_module,\r\n"verify_crc",\r\n"Verify the section CRC",\r\n"Whether the section dissector should verify the CRC",\r\n&mpeg_sect_check_crc);\r\nmpeg_sect_tid_dissector_table = register_dissector_table("mpeg_sect.tid",\r\n"MPEG SECT Table ID",\r\nFT_UINT8, BASE_HEX);\r\n}
