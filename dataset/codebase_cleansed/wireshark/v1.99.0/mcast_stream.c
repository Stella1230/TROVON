static gint\r\nmcast_stream_info_cmp(gconstpointer aa, gconstpointer bb)\r\n{\r\nconst struct _mcast_stream_info* a = (const struct _mcast_stream_info *)aa;\r\nconst struct _mcast_stream_info* b = (const struct _mcast_stream_info *)bb;\r\nif (a==b)\r\nreturn 0;\r\nif (a==NULL || b==NULL)\r\nreturn 1;\r\nif (ADDRESSES_EQUAL(&(a->src_addr), &(b->src_addr))\r\n&& (a->src_port == b->src_port)\r\n&& ADDRESSES_EQUAL(&(a->dest_addr), &(b->dest_addr))\r\n&& (a->dest_port == b->dest_port))\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nvoid\r\nmcaststream_reset(mcaststream_tapinfo_t *tapinfo)\r\n{\r\nGList* list;\r\nlist = g_list_first(tapinfo->strinfo_list);\r\nwhile (list)\r\n{\r\ng_free(list->data);\r\nlist = g_list_next(list);\r\n}\r\ng_list_free(tapinfo->strinfo_list);\r\ntapinfo->strinfo_list = NULL;\r\ng_free(tapinfo->allstreams);\r\ntapinfo->allstreams = NULL;\r\ntapinfo->nstreams = 0;\r\ntapinfo->npackets = 0;\r\n++(tapinfo->launch_count);\r\nreturn;\r\n}\r\nstatic void\r\nmcaststream_reset_cb(void *arg)\r\n{\r\nmcaststream_reset((mcaststream_tapinfo_t *)arg);\r\n}\r\nstatic void\r\nmcaststream_draw(void *arg _U_)\r\n{\r\nmcaststream_dlg_update(the_tapinfo_struct.strinfo_list);\r\nreturn;\r\n}\r\nstatic int\r\nmcaststream_packet(void *arg, packet_info *pinfo, epan_dissect_t *edt _U_, const void *arg2 _U_)\r\n{\r\nmcaststream_tapinfo_t *tapinfo = (mcaststream_tapinfo_t *)arg;\r\nmcast_stream_info_t tmp_strinfo;\r\nmcast_stream_info_t *strinfo = NULL;\r\nGList* list;\r\nfloat deltatime;\r\nCOPY_ADDRESS(&(tmp_strinfo.src_addr), &(pinfo->src));\r\ntmp_strinfo.src_port = pinfo->srcport;\r\nCOPY_ADDRESS(&(tmp_strinfo.dest_addr), &(pinfo->dst));\r\ntmp_strinfo.dest_port = pinfo->destport;\r\nif ((pinfo->dl_dst.type != AT_ETHER) ||\r\n((g_ascii_strncasecmp("01005E", bytes_to_ep_str((const guint8 *)pinfo->dl_dst.data, pinfo->dl_dst.len), 6) != 0) &&\r\n(g_ascii_strncasecmp("3333", bytes_to_ep_str((const guint8 *)pinfo->dl_dst.data, pinfo->dl_dst.len), 4) != 0)) )\r\nreturn 0;\r\nlist = g_list_first(tapinfo->strinfo_list);\r\nwhile (list)\r\n{\r\nif (mcast_stream_info_cmp(&tmp_strinfo, (mcast_stream_info_t*)(list->data))==0)\r\n{\r\nstrinfo = (mcast_stream_info_t*)(list->data);\r\nbreak;\r\n}\r\nlist = g_list_next(list);\r\n}\r\nif (!strinfo) {\r\ntmp_strinfo.npackets = 0;\r\ntmp_strinfo.apackets = 0;\r\ntmp_strinfo.first_frame_num = pinfo->fd->num;\r\ntmp_strinfo.start_sec = (guint32) pinfo->fd->abs_ts.secs;\r\ntmp_strinfo.start_usec = pinfo->fd->abs_ts.nsecs/1000;\r\ntmp_strinfo.start_rel_sec = (guint32) pinfo->rel_ts.secs;\r\ntmp_strinfo.start_rel_usec = pinfo->rel_ts.nsecs/1000;\r\ntmp_strinfo.vlan_id = 0;\r\ntmp_strinfo.average_bw = 0;\r\ntmp_strinfo.total_bytes = 0;\r\ntmp_strinfo.element.buff = (struct timeval *)g_malloc(buffsize * sizeof(struct timeval));\r\ntmp_strinfo.element.first=0;\r\ntmp_strinfo.element.last=0;\r\ntmp_strinfo.element.burstsize=1;\r\ntmp_strinfo.element.topburstsize=1;\r\ntmp_strinfo.element.numbursts=0;\r\ntmp_strinfo.element.burststatus=0;\r\ntmp_strinfo.element.count=1;\r\ntmp_strinfo.element.buffusage=pinfo->fd->pkt_len;\r\ntmp_strinfo.element.topbuffusage=pinfo->fd->pkt_len;\r\ntmp_strinfo.element.numbuffalarms=0;\r\ntmp_strinfo.element.buffstatus=0;\r\ntmp_strinfo.element.maxbw=0;\r\nstrinfo = (mcast_stream_info_t *)g_malloc(sizeof(mcast_stream_info_t));\r\n*strinfo = tmp_strinfo;\r\ntapinfo->strinfo_list = g_list_append(tapinfo->strinfo_list, strinfo);\r\nstrinfo->element.buff = (struct timeval *)g_malloc(buffsize * sizeof(struct timeval));\r\nif (tapinfo->npackets == 0) {\r\ntapinfo->allstreams = (mcast_stream_info_t *)g_malloc(sizeof(mcast_stream_info_t));\r\ntapinfo->allstreams->element.buff =\r\n(struct timeval *)g_malloc(buffsize * sizeof(struct timeval));\r\ntapinfo->allstreams->start_rel_sec = (guint32) pinfo->rel_ts.secs;\r\ntapinfo->allstreams->start_rel_usec = pinfo->rel_ts.nsecs/1000;\r\ntapinfo->allstreams->total_bytes = 0;\r\ntapinfo->allstreams->element.first=0;\r\ntapinfo->allstreams->element.last=0;\r\ntapinfo->allstreams->element.burstsize=1;\r\ntapinfo->allstreams->element.topburstsize=1;\r\ntapinfo->allstreams->element.numbursts=0;\r\ntapinfo->allstreams->element.burststatus=0;\r\ntapinfo->allstreams->element.count=1;\r\ntapinfo->allstreams->element.buffusage=pinfo->fd->pkt_len;\r\ntapinfo->allstreams->element.topbuffusage=pinfo->fd->pkt_len;\r\ntapinfo->allstreams->element.numbuffalarms=0;\r\ntapinfo->allstreams->element.buffstatus=0;\r\ntapinfo->allstreams->element.maxbw=0;\r\n}\r\n}\r\nstrinfo->stop_rel_sec = (guint32) pinfo->rel_ts.secs;\r\nstrinfo->stop_rel_usec = pinfo->rel_ts.nsecs/1000;\r\ndeltatime = ((float)((strinfo->stop_rel_sec * 1000000 + strinfo->stop_rel_usec)\r\n- (strinfo->start_rel_sec*1000000 + strinfo->start_rel_usec)))/1000000;\r\nstrinfo->total_bytes = strinfo->total_bytes + pinfo->fd->pkt_len;\r\nif (deltatime > 0)\r\nstrinfo->average_bw = (((float)(strinfo->total_bytes*8) / deltatime) / 1000000);\r\n++(strinfo->npackets);\r\nstrinfo->apackets = (guint32) (strinfo->npackets / deltatime);\r\ntapinfo->allstreams->stop_rel_sec = (guint32) pinfo->rel_ts.secs;\r\ntapinfo->allstreams->stop_rel_usec = pinfo->rel_ts.nsecs/1000;\r\ndeltatime = ((float)((tapinfo->allstreams->stop_rel_sec * 1000000 + tapinfo->allstreams->stop_rel_usec)\r\n- (tapinfo->allstreams->start_rel_sec*1000000 + tapinfo->allstreams->start_rel_usec)))/1000000;\r\n++(tapinfo->npackets);\r\ntapinfo->allstreams->total_bytes = tapinfo->allstreams->total_bytes + pinfo->fd->pkt_len;\r\nif (deltatime > 0)\r\ntapinfo->allstreams->average_bw = (((float)(tapinfo->allstreams->total_bytes *8) / deltatime) / 1000000);\r\nslidingwindow(strinfo, pinfo);\r\nbuffusagecalc(strinfo, pinfo, mcast_stream_emptyspeed*1000);\r\nslidingwindow(tapinfo->allstreams, pinfo);\r\nbuffusagecalc(tapinfo->allstreams, pinfo, mcast_stream_cumulemptyspeed*1000);\r\nreturn 1;\r\n}\r\nvoid\r\nmcaststream_scan(void)\r\n{\r\ngboolean was_registered = the_tapinfo_struct.is_registered;\r\nif (!the_tapinfo_struct.is_registered)\r\nregister_tap_listener_mcast_stream();\r\ncf_retap_packets(&cfile);\r\nif (!was_registered)\r\nremove_tap_listener_mcast_stream();\r\n}\r\nconst mcaststream_tapinfo_t *\r\nmcaststream_get_info(void)\r\n{\r\nreturn &the_tapinfo_struct;\r\n}\r\nvoid\r\nremove_tap_listener_mcast_stream(void)\r\n{\r\nif (the_tapinfo_struct.is_registered) {\r\nremove_tap_listener(&the_tapinfo_struct);\r\nthe_tapinfo_struct.is_registered = FALSE;\r\n}\r\n}\r\nvoid\r\nregister_tap_listener_mcast_stream(void)\r\n{\r\nGString *error_string;\r\nif (!the_tapinfo_struct.is_registered) {\r\nerror_string = register_tap_listener("udp", &the_tapinfo_struct,\r\nNULL, 0, mcaststream_reset_cb, mcaststream_packet,\r\nmcaststream_draw);\r\nif (error_string != NULL) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"%s", error_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\nthe_tapinfo_struct.is_registered = TRUE;\r\n}\r\n}\r\nstatic guint16\r\ncomparetimes(struct timeval *t1, struct timeval *t2, guint16 burstint_lcl)\r\n{\r\nif(((t2->tv_sec - t1->tv_sec)*1000 + (t2->tv_usec - t1->tv_usec)/1000) > burstint_lcl){\r\nreturn 1;\r\n} else{\r\nreturn 0;\r\n}\r\n}\r\nstatic void\r\nbuffusagecalc(mcast_stream_info_t *strinfo, packet_info *pinfo, double emptyspeed_lcl)\r\n{\r\ntime_t sec=0;\r\ngint32 usec=0, cur, prev;\r\nstruct timeval *buffer;\r\ndouble timeelapsed;\r\nbuffer = strinfo->element.buff;\r\ncur = strinfo->element.last;\r\nif(cur == 0){\r\ncur = buffsize - 1;\r\nprev = cur - 1;\r\n} else if(cur == 1){\r\nprev = buffsize - 1;\r\ncur = 0;\r\n} else{\r\ncur=cur-1;\r\nprev=cur-1;\r\n}\r\nsec = buffer[cur].tv_sec - buffer[prev].tv_sec;\r\nusec = (gint32)buffer[cur].tv_usec - (gint32)buffer[prev].tv_usec;\r\ntimeelapsed = (double)usec/1000000 + (double)sec;\r\nstrinfo->element.buffusage+=pinfo->fd->pkt_len;\r\nstrinfo->element.buffusage-= (guint32) (timeelapsed * emptyspeed_lcl / 8);\r\nif(strinfo->element.buffusage < 0) strinfo->element.buffusage=0;\r\nif(strinfo->element.buffusage > strinfo->element.topbuffusage)\r\nstrinfo->element.topbuffusage = strinfo->element.buffusage;\r\nif((strinfo->element.buffusage >= mcast_stream_bufferalarm) && (strinfo->element.buffstatus == 0)){\r\nstrinfo->element.buffstatus = 1;\r\nstrinfo->element.numbuffalarms++;\r\n} else if(strinfo->element.buffusage < mcast_stream_bufferalarm){\r\nstrinfo->element.buffstatus = 0;\r\n}\r\nreturn;\r\n}\r\nstatic void\r\nslidingwindow(mcast_stream_info_t *strinfo, packet_info *pinfo)\r\n{\r\nstruct timeval *buffer;\r\ngint32 diff;\r\nbuffer = strinfo->element.buff;\r\ndiff = strinfo->element.last - strinfo->element.first;\r\nif(diff < 0) diff+=buffsize;\r\nif(diff >= (buffsize - 2)){\r\nfprintf(stderr, "Warning: capture buffer full\n");\r\nstrinfo->element.first++;\r\nif(strinfo->element.first >= buffsize) strinfo->element.first = strinfo->element.first % buffsize;\r\n}\r\nbuffer[strinfo->element.last].tv_sec = (guint32) pinfo->rel_ts.secs;\r\nbuffer[strinfo->element.last].tv_usec = pinfo->rel_ts.nsecs/1000;\r\nwhile(comparetimes((struct timeval *)&(buffer[strinfo->element.first]),\r\n(struct timeval *)&(buffer[strinfo->element.last]), mcast_stream_burstint)){\r\nstrinfo->element.first++;\r\nif(strinfo->element.first >= buffsize) strinfo->element.first = strinfo->element.first % buffsize;\r\ndiff--;\r\n}\r\nstrinfo->element.burstsize = diff;\r\nif(strinfo->element.burstsize > strinfo->element.topburstsize) {\r\nstrinfo->element.topburstsize = strinfo->element.burstsize;\r\nstrinfo->element.maxbw = (float)(strinfo->element.topburstsize) * 1000 / mcast_stream_burstint * pinfo->fd->pkt_len * 8 / 1000000;\r\n}\r\nstrinfo->element.last++;\r\nif(strinfo->element.last >= buffsize) strinfo->element.last = strinfo->element.last % buffsize;\r\nif((strinfo->element.burstsize >= mcast_stream_trigger) && (strinfo->element.burststatus == 0)){\r\nstrinfo->element.burststatus = 1;\r\nstrinfo->element.numbursts++;\r\n} else if(strinfo->element.burstsize < mcast_stream_trigger){\r\nstrinfo->element.burststatus = 0;\r\n}\r\nstrinfo->element.count++;\r\n}
