static int tap_packet_cb_error_handler(lua_State* L) {\r\nconst gchar* error = lua_tostring(L,1);\r\nstatic gchar* last_error = NULL;\r\nstatic int repeated = 0;\r\nstatic int next = 2;\r\nconst gchar* where = (lua_pinfo) ?\r\nep_strdup_printf("Lua: on packet %i Error During execution of Listener Packet Callback",lua_pinfo->fd->num) :\r\nep_strdup_printf("Lua: Error During execution of Listener Packet Callback") ;\r\nif (! last_error) {\r\nreport_failure("%s:\n%s",where,error);\r\nlast_error = g_strdup(error);\r\nrepeated = 0;\r\nnext = 2;\r\nreturn 0;\r\n}\r\nif (g_str_equal(last_error,error) ) {\r\nrepeated++;\r\nif ( repeated == next ) {\r\nreport_failure("%s happened %i times:\n %s",where,repeated,error);\r\nnext *= 2;\r\n}\r\n} else {\r\nreport_failure("%s happened %i times:\n %s",where,repeated,last_error);\r\ng_free(last_error);\r\nlast_error = g_strdup(error);\r\nrepeated = 0;\r\nnext = 2;\r\nreport_failure("%s:\n %s",where,error);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lua_tap_packet(void *tapdata, packet_info *pinfo, epan_dissect_t *edt, const void *data) {\r\nListener tap = (Listener)tapdata;\r\nint retval = 0;\r\nif (tap->packet_ref == LUA_NOREF) return 0;\r\nlua_settop(tap->L,0);\r\nlua_pushcfunction(tap->L,tap_packet_cb_error_handler);\r\nlua_rawgeti(tap->L, LUA_REGISTRYINDEX, tap->packet_ref);\r\npush_Pinfo(tap->L, pinfo);\r\npush_Tvb(tap->L, edt->tvb);\r\nif (tap->extractor) {\r\ntap->extractor(tap->L,data);\r\n} else {\r\nlua_pushnil(tap->L);\r\n}\r\nlua_pinfo = pinfo;\r\nlua_tvb = edt->tvb;\r\nlua_tree = (struct _wslua_treeitem *)g_malloc(sizeof(struct _wslua_treeitem));\r\nlua_tree->tree = edt->tree;\r\nlua_tree->item = NULL;\r\nlua_tree->expired = FALSE;\r\nswitch ( lua_pcall(tap->L,3,1,1) ) {\r\ncase 0:\r\nretval = luaL_optint(tap->L,-1,1);\r\nbreak;\r\ncase LUA_ERRRUN:\r\nbreak;\r\ncase LUA_ERRMEM:\r\ng_warning("Memory alloc error while calling listener tap callback packet");\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\nclear_outstanding_Pinfo();\r\nclear_outstanding_Tvb();\r\nlua_pinfo = NULL;\r\nlua_tvb = NULL;\r\nlua_tree = NULL;\r\nreturn retval;\r\n}\r\nstatic int tap_reset_cb_error_handler(lua_State* L) {\r\nconst gchar* error = lua_tostring(L,1);\r\nreport_failure("Lua: Error During execution of Listener init Callback:\n %s",error);\r\nreturn 1;\r\n}\r\nstatic void lua_tap_reset(void *tapdata) {\r\nListener tap = (Listener)tapdata;\r\nif (tap->reset_ref == LUA_NOREF) return;\r\nlua_pushcfunction(tap->L,tap_reset_cb_error_handler);\r\nlua_rawgeti(tap->L, LUA_REGISTRYINDEX, tap->reset_ref);\r\nswitch ( lua_pcall(tap->L,0,0,1) ) {\r\ncase 0:\r\nbreak;\r\ncase LUA_ERRRUN:\r\ng_warning("Runtime error while calling a listener's init()");\r\nbreak;\r\ncase LUA_ERRMEM:\r\ng_warning("Memory alloc error while calling a listener's init()");\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\nstatic void lua_tap_draw(void *tapdata) {\r\nListener tap = (Listener)tapdata;\r\nconst gchar* error;\r\nif (tap->draw_ref == LUA_NOREF) return;\r\nlua_pushcfunction(tap->L,tap_reset_cb_error_handler);\r\nlua_rawgeti(tap->L, LUA_REGISTRYINDEX, tap->draw_ref);\r\nswitch ( lua_pcall(tap->L,0,0,1) ) {\r\ncase 0:\r\nbreak;\r\ncase LUA_ERRRUN:\r\nerror = lua_tostring(tap->L,-1);\r\ng_warning("Runtime error while calling a listener's draw(): %s",error);\r\nbreak;\r\ncase LUA_ERRMEM:\r\ng_warning("Memory alloc error while calling a listener's draw()");\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\nWSLUA_CONSTRUCTOR Listener_new(lua_State* L) {\r\n#define WSLUA_OPTARG_Listener_new_TAP 1\r\n#define WSLUA_OPTARG_Listener_new_FILTER 2\r\n#define WSLUA_OPTARG_Listener_new_ALLFIELDS 3\r\nconst gchar* tap_type = luaL_optstring(L,WSLUA_OPTARG_Listener_new_TAP,"frame");\r\nconst gchar* filter = luaL_optstring(L,WSLUA_OPTARG_Listener_new_FILTER,NULL);\r\nconst gboolean all_fields = wslua_optbool(L, WSLUA_OPTARG_Listener_new_ALLFIELDS, FALSE);\r\nListener tap;\r\nGString* error;\r\ntap = (Listener)g_malloc(sizeof(struct _wslua_tap));\r\ntap->name = g_strdup(tap_type);\r\ntap->filter = filter ? g_strdup(filter) : NULL;\r\ntap->extractor = wslua_get_tap_extractor(tap_type);\r\ntap->L = L;\r\ntap->packet_ref = LUA_NOREF;\r\ntap->draw_ref = LUA_NOREF;\r\ntap->reset_ref = LUA_NOREF;\r\ntap->all_fields = all_fields;\r\nerror = register_tap_listener(tap_type, tap, tap->filter, TL_REQUIRES_PROTO_TREE, lua_tap_reset, lua_tap_packet, lua_tap_draw);\r\nif (error) {\r\ng_free(tap->filter);\r\ng_free(tap->name);\r\ng_free(tap);\r\nlua_pushfstring(L,"Error while registering tap:\n%s",error->str);\r\ng_string_free(error,TRUE);\r\nluaL_error(L,lua_tostring(L,-1));\r\n}\r\nif (all_fields) {\r\nepan_set_always_visible(TRUE);\r\n}\r\npushListener(L,tap);\r\nWSLUA_RETURN(1);\r\n}\r\nstatic gint\r\ncompare_dissector_key_name(gconstpointer dissector_a, gconstpointer dissector_b)\r\n{\r\nreturn strcmp((const char*)dissector_a, (const char*)dissector_b);\r\n}\r\nWSLUA_CONSTRUCTOR Listener_list (lua_State *L) {\r\nGList* list = get_tap_names();\r\nGList* elist = NULL;\r\nint i = 1;\r\nif (!list) return luaL_error(L,"Cannot retrieve tap name list");\r\nlist = g_list_sort(list, (GCompareFunc)compare_dissector_key_name);\r\nelist = g_list_first(list);\r\nlua_newtable(L);\r\nfor (i=1; elist; i++, elist = g_list_next(elist)) {\r\nlua_pushstring(L,(const char *) elist->data);\r\nlua_rawseti(L,1,i);\r\n}\r\ng_list_free(list);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METHOD Listener_remove(lua_State* L) {\r\nListener tap = checkListener(L,1);\r\nif (tap->all_fields) {\r\nepan_set_always_visible(FALSE);\r\ntap->all_fields = FALSE;\r\n}\r\nremove_tap_listener(tap);\r\nreturn 0;\r\n}\r\nWSLUA_METAMETHOD Listener__tostring(lua_State* L) {\r\nListener tap = checkListener(L,1);\r\ngchar* str;\r\nstr = ep_strdup_printf("Listener(%s) filter: %s",tap->name, tap->filter ? tap->filter : "NONE");\r\nlua_pushstring(L,str);\r\nreturn 1;\r\n}\r\nstatic int Listener__gc(lua_State* L _U_) {\r\nreturn 0;\r\n}\r\nint Listener_register(lua_State* L) {\r\nwslua_set_tap_enums(L);\r\nWSLUA_REGISTER_CLASS(Listener);\r\nWSLUA_REGISTER_ATTRIBUTES(Listener);\r\nreturn 0;\r\n}
