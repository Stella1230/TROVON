static void\r\nbase58_encode(guint32 value, char *str) {\r\nguint32 mod;\r\ngint i = 0;\r\ngint k;\r\ngchar reverse_str[BASE58_MAX_STR_SIZE] = {'\0'};\r\nwhile (value >= 58) {\r\nmod = value % 58;\r\nreverse_str[i] = BASE58_ALPHABET[mod];\r\nvalue = value / 58;\r\n++i;\r\n}\r\nreverse_str[i] = BASE58_ALPHABET[value];\r\nfor (k = 0; k <= i; k++) {\r\nstr[k] = reverse_str[i - k];\r\n}\r\nfor (; k < BASE58_MAX_STR_SIZE; k++) {\r\nstr[k] = '\0';\r\n}\r\n}\r\nstatic void\r\ndissect_tfp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) {\r\ngint byte_offset = 0;\r\ngint bit_offset = 48;\r\nguint8 hv_tfp_len;\r\nguint8 hv_tfp_fid;\r\nguint8 hv_tfp_seq;\r\ngchar tfp_uid_string[BASE58_MAX_STR_SIZE];\r\nbase58_encode(tvb_get_letohl(tvb, 0), &tfp_uid_string[0]);\r\nhv_tfp_len = tvb_get_guint8(tvb, byte_offset_len);\r\nhv_tfp_fid = tvb_get_guint8(tvb, byte_offset_fid);\r\nhv_tfp_seq = tvb_get_bits8(tvb, bit_offset, bit_count_tfp_seq);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO,\r\n"UID: %s, Len: %d, FID: %d, Seq: %d",\r\n&tfp_uid_string[0], hv_tfp_len, hv_tfp_fid, hv_tfp_seq);\r\nif (tree) {\r\nproto_tree *tfp_tree;\r\nproto_item *ti;\r\nti = proto_tree_add_protocol_format(tree, proto_tfp, tvb, 0, -1,\r\n"Tinkerforge Protocol, UID: %s, Len: %d, FID: %d, Seq: %d",\r\n&tfp_uid_string[0], hv_tfp_len, hv_tfp_fid, hv_tfp_seq);\r\ntfp_tree = proto_item_add_subtree(ti, ett_tfp);\r\nti = proto_tree_add_string_format_value(tfp_tree,\r\nhf_tfp_uid,\r\ntvb, byte_offset, byte_count_tfp_uid,\r\n&tfp_uid_string[0], "%s", &tfp_uid_string[0]);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nproto_tree_add_item(tfp_tree,\r\nhf_tfp_uid_numeric,\r\ntvb,\r\nbyte_offset,\r\nbyte_count_tfp_uid,\r\nENC_LITTLE_ENDIAN);\r\nbyte_offset += byte_count_tfp_uid;\r\nproto_tree_add_item(tfp_tree,\r\nhf_tfp_len,\r\ntvb,\r\nbyte_offset,\r\nbyte_count_tfp_len,\r\nENC_LITTLE_ENDIAN);\r\nbyte_offset += byte_count_tfp_len;\r\nproto_tree_add_item(tfp_tree,\r\nhf_tfp_fid,\r\ntvb,\r\nbyte_offset,\r\nbyte_count_tfp_fid,\r\nENC_LITTLE_ENDIAN);\r\nbyte_offset += byte_count_tfp_fid;\r\nproto_tree_add_bits_item(tfp_tree,\r\nhf_tfp_seq,\r\ntvb,\r\nbit_offset,\r\nbit_count_tfp_seq,\r\nENC_LITTLE_ENDIAN);\r\nbit_offset += bit_count_tfp_seq;\r\nproto_tree_add_bits_item(tfp_tree,\r\nhf_tfp_r,\r\ntvb,\r\nbit_offset,\r\nbit_count_tfp_r,\r\nENC_LITTLE_ENDIAN);\r\nbit_offset += bit_count_tfp_r;\r\nproto_tree_add_bits_item(tfp_tree,\r\nhf_tfp_a,\r\ntvb,\r\nbit_offset,\r\nbit_count_tfp_a,\r\nENC_LITTLE_ENDIAN);\r\nbit_offset += bit_count_tfp_a;\r\nproto_tree_add_bits_item(tfp_tree,\r\nhf_tfp_oo,\r\ntvb,\r\nbit_offset,\r\nbit_count_tfp_oo,\r\nENC_LITTLE_ENDIAN);\r\nbit_offset += bit_count_tfp_oo;\r\nproto_tree_add_bits_item(tfp_tree,\r\nhf_tfp_e,\r\ntvb,\r\nbit_offset,\r\nbit_count_tfp_e,\r\nENC_LITTLE_ENDIAN);\r\nbit_offset += bit_count_tfp_e;\r\nproto_tree_add_bits_item(tfp_tree,\r\nhf_tfp_future_use,\r\ntvb,\r\nbit_offset,\r\nbit_count_tfp_future_use,\r\nENC_LITTLE_ENDIAN);\r\nif ((tvb_reported_length(tvb)) > 8) {\r\nbyte_offset += byte_count_tfp_flags;\r\nproto_tree_add_item(tfp_tree, hf_tfp_payload, tvb, byte_offset, -1, ENC_NA);\r\n}\r\n}\r\n}\r\nstatic void\r\ndissect_tfp_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TFP over TCP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ndissect_tfp_common(tvb, pinfo, tree);\r\n}\r\nstatic gboolean\r\ndissect_tfp_bulk_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\r\n{\r\nusb_conv_info_t *usb_conv_info = (usb_conv_info_t *)data;\r\nif ((usb_conv_info != NULL) &&\r\n(usb_conv_info->deviceVendor == tfp_USB_VENDOR_ID) &&\r\n(usb_conv_info->deviceProduct == tfp_USB_PRODUCT_ID)) {\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "TFP over USB");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\ndissect_tfp_common(tvb, pinfo, tree);\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nvoid\r\nproto_register_tfp(void)\r\n{\r\nstatic hf_register_info hf_tfp[] = {\r\n{ &hf_tfp_uid,\r\n{ "UID (String)",\r\n"tfp.uid",\r\nFT_STRINGZ,\r\nBASE_NONE,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_uid_numeric,\r\n{ "UID (Numeric)",\r\n"tfp.uid_numeric",\r\nFT_UINT32,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_len,\r\n{ "Length",\r\n"tfp.len",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_fid,\r\n{ "Function ID",\r\n"tfp.fid",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_seq,\r\n{ "Sequence Number",\r\n"tfp.seq",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_r,\r\n{ "Response Expected",\r\n"tfp.r",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_a,\r\n{ "Authentication",\r\n"tfp.a",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_oo,\r\n{ "Other Options",\r\n"tfp.oo",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_e,\r\n{ "Error Code",\r\n"tfp.e",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_future_use,\r\n{ "Future Use",\r\n"tfp.future_use",\r\nFT_UINT8,\r\nBASE_DEC,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n},\r\n{ &hf_tfp_payload,\r\n{ "Payload",\r\n"tfp.payload",\r\nFT_BYTES,\r\nBASE_NONE,\r\nNULL,\r\n0x0,\r\nNULL,\r\nHFILL\r\n}\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_tfp\r\n};\r\nproto_tfp = proto_register_protocol (\r\n"Tinkerforge Protocol",\r\n"TFP",\r\n"tfp"\r\n);\r\nproto_register_field_array(proto_tfp, hf_tfp, array_length(hf_tfp));\r\nproto_register_subtree_array(ett, array_length(ett));\r\n}\r\nvoid\r\nproto_reg_handoff_tfp(void) {\r\ndissector_handle_t tfp_handle_tcp;\r\ntfp_handle_tcp = create_dissector_handle(dissect_tfp_tcp, proto_tfp);\r\ndissector_add_uint("tcp.port", tfp_PORT, tfp_handle_tcp);\r\nheur_dissector_add("usb.bulk", dissect_tfp_bulk_heur, proto_tfp);\r\n}
