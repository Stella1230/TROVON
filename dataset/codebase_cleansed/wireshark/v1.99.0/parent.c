static void parent_dbg(int level, const char* fmt, ...) {\r\nva_list ap;\r\nchar str[1024];\r\nif (level > dbg_level) return;\r\nva_start(ap,fmt);\r\ng_vsnprintf(str,1024,fmt,ap);\r\nva_end(ap);\r\nfprintf(stderr,"ParentDebug: level=%d msg='%s'\n",level,str);\r\nfflush(stderr);\r\n}\r\nextern void echld_set_parent_dbg_level(int lvl) {\r\n(dbg_level = lvl);\r\nif (lvl > 6) {\r\nechld_common_set_dbg(lvl,stderr,"parent");\r\n}\r\nPARENT_DBG((0,"Debug Level Set: %d",lvl));\r\n}\r\nstatic void parent_fatal(int exit_code, const char* fmt, ...) {\r\nva_list ap;\r\nchar str[1024];\r\nva_start(ap,fmt);\r\ng_vsnprintf(str,1024,fmt,ap);\r\nva_end(ap);\r\n#ifdef DEBUG_PARENT\r\nPARENT_DBG((0,"Fatal error: exit_code=%d str=%s",exit_code,str));\r\n#else\r\nfprintf(stderr,"Fatal error: exit_code=%d str=%s",exit_code,str);\r\n#endif\r\nkill(parent.dispatcher_pid,SIGTERM);\r\nexit(exit_code);\r\n}\r\nstatic void echld_cleanup(void) {\r\nPARENT_DBG((4,"echld_cleanup starting"));\r\nPARENT_DBG((3,"echld_cleanup done"));\r\n}\r\nstatic void parent_child_cleanup(echld_t* c) {\r\nPARENT_DBG((2,"cleanup chld_id=%d",c->chld_id));\r\nc->chld_id = -1;\r\nc->data = NULL;\r\nc->state = FREE;\r\ng_array_set_size(c->handlers,0);\r\ng_array_set_size(c->reqs,0);\r\n}\r\nvoid parent_reaper(int sig) {\r\nint pid;\r\nint status;\r\nif (sig == SIGCHLD) {\r\nPARENT_FATAL((3333,"Must be SIGCHLD!"));\r\n}\r\npid = waitpid(-1, &status, WNOHANG);\r\nPARENT_DBG((2,"SIGCHLD pid=%d",pid));\r\nif (pid == parent.dispatcher_pid) {\r\nif (! parent.closing) {\r\nsleep(120);\r\nPARENT_FATAL((DISPATCHER_DEAD,"Dispatcher process dead"));\r\n}\r\nreturn;\r\n} else {\r\nreturn;\r\n}\r\nreturn;\r\n}\r\nstatic echld_bool_t hello_cb(echld_msg_type_t type, enc_msg_t* msg_buff, void* ud) {\r\nechld_init_t* init = (echld_init_t*)ud;\r\nchar* err = NULL;\r\nint errnum = 0;\r\nif (init && init->dispatcher_hello_cb) {\r\nswitch(type) {\r\ncase ECHLD_ERROR:\r\nparent.dec->error(msg_buff, &errnum ,&err);\r\nbreak;\r\ncase ECHLD_TIMED_OUT:\r\nerr = g_strdup("timedout");\r\nbreak;\r\ndefault:\r\nerr = g_strdup_printf("Wrong MSG 'HELLO' expected, got '%s",TY(type));\r\nbreak;\r\ncase ECHLD_HELLO:\r\nbreak;\r\n}\r\ninit->dispatcher_hello_cb(ud,err);\r\nif (err) g_free(err);\r\n}\r\nreturn TRUE;\r\n}\r\nvoid echld_initialize(echld_init_t* init) {\r\nint from_disp[2];\r\nint to_disp[2];\r\nPARENT_DBG((1,"Echld Starting"));\r\nif (!init) {\r\nPARENT_FATAL((NO_INITIALIZER,"Missing Initializer"));\r\n}\r\nif (init->encoding != ECHLD_ENCODING_JSON) {\r\nPARENT_FATAL((UNIMPLEMENTED,"Only JSON implemented"));\r\n}\r\nif ( pipe(to_disp) ) {\r\nPARENT_FATAL((DISPATCHER_PIPE_FAILED,"Failed to open pipe to dispatcher"));\r\n} else if( pipe(from_disp) ) {\r\nPARENT_FATAL((DISPATCHER_PIPE_FAILED,"Failed to open pipe from dispatcher"));\r\n} else {\r\nint pid;\r\nint i;\r\nPARENT_DBG((3,"Pipes Opened fr[0]=%d fr[1]=%d to[0]=%d to[1]=%d",from_disp[0],from_disp[1],to_disp[0],to_disp[1]));\r\npid = fork();\r\nif ( pid < 0 ) {\r\nPARENT_FATAL((CANNOT_FORK,"Failed to fork() reason='%s'",strerror(errno)));\r\n} else if ( pid == 0) {\r\n#ifdef PARENT_THREADS\r\nreader_realloc_buf = child_realloc_buff;\r\n#endif\r\nechld_cleanup();\r\nif (init->after_fork_cb)\r\ninit->after_fork_cb(init->after_fork_cb_data);\r\nechld_dispatcher_start(to_disp,from_disp,init->argv0,init->main);\r\nPARENT_FATAL((SHOULD_HAVE_EXITED_BEFORE,"This shouldn't happen"));\r\n} else {\r\n#ifdef PARENT_THREADS\r\nreader_realloc_buf = parent_realloc_buff;\r\n#endif\r\nPARENT_DBG((3,"Dispatcher forked"));\r\nechld_get_all_codecs(NULL, NULL, &parent.enc, &parent.dec);\r\nparent.children = g_new0(echld_t,ECHLD_MAX_CHILDREN);\r\nparent.snd = g_byte_array_new();\r\nparent.dispatcher_fd = to_disp[1];\r\nparent.dispatcher_pid = pid;\r\nechld_init_reader(&(parent.reader),from_disp[0],4096);\r\nfor (i=0;i<ECHLD_MAX_CHILDREN;i++) {\r\nparent.children[i].chld_id = -1;\r\nparent.children[i].data = NULL;\r\nparent.children[i].state = FREE;\r\nparent.children[i].handlers = g_array_new(TRUE,TRUE,sizeof(hdlr_t));\r\nparent.children[i].reqs = g_array_new(TRUE,TRUE,sizeof(reqh_t));\r\n}\r\nparent.children[0].chld_id = 0;\r\nparent.children[0].state = IDLE;\r\nsignal(SIGCHLD,parent_reaper);\r\nif (init->dispatcher_hello_cb) echld_msgh(0, ECHLD_HELLO, hello_cb, init);\r\nPARENT_DBG((3,"Ready"));\r\n}\r\n}\r\n}\r\nextern echld_state_t echld_terminate(void) {\r\nparent.closing = TRUE;\r\nPARENT_SEND(NULL,0,ECHLD_CLOSE_CHILD,++reqh_ids);\r\ndo {;} while(sleep(1));\r\nechld_cleanup();\r\nclose(parent.dispatcher_fd);\r\nkill(parent.dispatcher_pid,SIGTERM);\r\nreturn TRUE;\r\n}\r\nstatic echld_t* get_child(int id) {\r\nint i;\r\nfor (i=0;i<ECHLD_MAX_CHILDREN;i++) {\r\nif (parent.children[i].chld_id == id) return &(parent.children[i]);\r\n};\r\nreturn NULL;\r\n}\r\nint reqh_id_idx(echld_t* c, int reqh_id) {\r\nint i;\r\nint imax = c->reqs->len;\r\nreqh_t* rr = (reqh_t*)c->reqs->data;\r\nfor(i=0; i < imax ; i++) {\r\nif (rr[i].reqh_id == reqh_id)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic echld_state_t reqh_snd(echld_t* c, echld_msg_type_t t, GByteArray* ba, echld_msg_cb_t resp_cb, void* cb_data) {\r\nint idx;\r\nreqh_t* r;\r\nint reqh_id = reqh_ids++;\r\nif (!c) {\r\nPARENT_DBG((1,"REQH_SND: No such child"));\r\nreturn 1;\r\n}\r\nidx = reqh_id_idx(c,-1);\r\nif (idx < 0) {\r\nreqh_t req;\r\nidx = c->reqs->len;\r\ng_array_append_val(c->reqs,req);\r\n}\r\nr = &(((reqh_t*)c->reqs->data)[idx]);\r\nr->reqh_id = reqh_id;\r\nr->cb = resp_cb;\r\nr->cb_data = cb_data;\r\ngettimeofday(&(r->tv),NULL);\r\nPARENT_DBG((4,"reqh_add: idx='%d'",idx));\r\nPARENT_DBG((3,"REQH_SND: type='%s' chld_id=%d reqh_id=%d",TY(t), c->chld_id,reqh_id));\r\nPARENT_SEND(ba,c->chld_id,t,reqh_id);\r\nif (ba) g_byte_array_free(ba,TRUE);\r\nreturn reqh_id;\r\n}\r\nextern echld_reqh_id_t echld_reqh(\r\nechld_chld_id_t child_id,\r\nechld_msg_type_t t,\r\nint usecs_timeout _U_,\r\nenc_msg_t* ba,\r\nechld_msg_cb_t resp_cb,\r\nvoid* cb_data) {\r\nreturn reqh_snd(get_child(child_id),t,ba,resp_cb,cb_data);\r\n}\r\nextern void* echld_reqh_get_data(int child_id, int reqh_id) {\r\nechld_t* c = get_child(child_id);\r\nint idx;\r\nif (!c) return NULL;\r\nidx = reqh_id_idx(c,reqh_id);\r\nif (idx >= 0)\r\nreturn g_array_index(c->reqs, reqh_t, idx).cb_data;\r\nelse\r\nreturn NULL;\r\n}\r\nextern echld_msg_cb_t echld_reqh_get_cb(int child_id, int reqh_id) {\r\nechld_t* c = get_child(child_id);\r\nint idx;\r\nif (!c) return NULL;\r\nidx = reqh_id_idx(c,reqh_id);\r\nif (idx >= 0)\r\nreturn g_array_index(c->reqs, reqh_t, idx).cb;\r\nelse\r\nreturn NULL;\r\n}\r\nextern gboolean echld_reqh_set_data(int child_id, int reqh_id, void* cb_data) {\r\nechld_t* c = get_child(child_id);\r\nint idx;\r\nif (!c) return FALSE;\r\nidx = reqh_id_idx(c,reqh_id);\r\nif (idx < 0) return FALSE;\r\ng_array_index(c->reqs, reqh_t, idx).cb_data = cb_data;\r\nreturn TRUE;\r\n}\r\nextern gboolean echld_reqh_set_cb(int child_id, int reqh_id, echld_msg_cb_t cb){\r\nechld_t* c = get_child(child_id);\r\nint idx;\r\nif (!c) return FALSE;\r\nidx = reqh_id_idx(c,reqh_id);\r\nif (idx < 0) return FALSE;\r\ng_array_index(c->reqs, reqh_t, idx).cb = cb;\r\nreturn TRUE;\r\n}\r\nextern gboolean echld_reqh_detach(int child_id, int reqh_id) {\r\nechld_t* c = get_child(child_id);\r\nint idx;\r\nif (!c) return FALSE;\r\nidx = reqh_id_idx(c,reqh_id);\r\nif (idx < 0) return FALSE;\r\ng_array_remove_index(c->reqs,idx);\r\nreturn TRUE;\r\n}\r\nstatic echld_bool_t parent_dead_child(echld_msg_type_t type, enc_msg_t* ba, void* data) {\r\nechld_t* c = (echld_t*)data;\r\nchar* s;\r\nif (type != ECHLD_CHILD_DEAD) {\r\nPARENT_DBG((1, "Must Be ECHLD_CHILD_DEAD"));\r\nreturn 1;\r\n}\r\nif ( parent.dec->child_dead(ba,&s) ) {\r\nPARENT_DBG((1,"Dead Child[%d]: %s",c->chld_id,s));\r\ng_free(s);\r\n}\r\nparent_child_cleanup(c);\r\nreturn 0;\r\n}\r\nstatic echld_bool_t parent_get_hello(echld_msg_type_t type, enc_msg_t* ba, void* data) {\r\nechld_t* c = (echld_t*)data;\r\nint err_id;\r\nchar* err = NULL;\r\nswitch (type) {\r\ncase ECHLD_HELLO:\r\nPARENT_DBG((1,"Child[%d]: =>IDLE",c->chld_id));\r\nc->state = IDLE;\r\nbreak;\r\ncase ECHLD_ERROR:\r\nparent.dec->error(ba,&err_id,&err);\r\nbreak;\r\ncase ECHLD_TIMED_OUT:\r\nerr = g_strdup("timedout");\r\nbreak;\r\ndefault:\r\nerr = g_strdup_printf("Wrong MSG 'HELLO' expected, got '%s",TY(type));\r\nbreak;\r\n}\r\nif (c->cb)\r\nc->cb(c->data,err);\r\nif (err) g_free(err);\r\nreturn TRUE;\r\n}\r\nint chld_cmp(const void *a, const void *b) {\r\nreturn ((echld_t*)b)->chld_id - ((echld_t*)a)->chld_id;\r\n}\r\nextern int echld_new(enc_msg_t* new_child_em, echld_new_cb_t cb, void* child_data) {\r\nechld_t* c = get_child(-1);\r\nif (!c) return -1;\r\nc->chld_id = (next_chld_id++);\r\nc->data = child_data;\r\nc->state = CREATING;\r\nc->cb = cb;\r\nPARENT_DBG((1,"Child[%d]: =>CREATING",c->chld_id));\r\nmsgh_attach(c,ECHLD_CHILD_DEAD, parent_dead_child , c);\r\nreqh_snd(c, ECHLD_NEW_CHILD, (GByteArray*)new_child_em, parent_get_hello, c);\r\nreturn c->chld_id;\r\n}\r\nextern void* echld_get_data(int child_id) {\r\nechld_t* c = get_child(child_id);\r\nreturn c ? c->data : NULL;\r\n}\r\nextern echld_state_t echld_set_data(echld_chld_id_t chld_id, void* data) {\r\nechld_t* c = get_child(chld_id);\r\nif (c) {\r\nc->data = data;\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nstatic int msgh_idx(echld_t* c, int msgh_id) {\r\nint i = 0;\r\nint imax = c->handlers->len;\r\nfor (i=0;i<imax;i++) {\r\nif (((hdlr_t*)(c->handlers->data))[i].id == msgh_id) return i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int msgh_attach(echld_t* c, echld_msg_type_t t, echld_msg_cb_t resp_cb, void* cb_data) {\r\nhdlr_t h;\r\nstatic int msgh_id = 1;\r\nh.id = msgh_id++;\r\nh.type = t;\r\nh.cb = resp_cb;\r\nh.cb_data = cb_data;\r\ng_array_append_val(c->handlers,h);\r\nreturn 0;\r\n}\r\nextern int echld_msgh(int child_id, echld_msg_type_t t, echld_msg_cb_t resp_cb, void* cb_data) {\r\nechld_t* c = get_child(child_id);\r\nif (c) return msgh_attach(c,t,resp_cb,cb_data);\r\nelse return -1;\r\n}\r\nstatic echld_state_t msgh_detach(echld_t* c, int msgh_id) {\r\nint idx = msgh_idx(c,msgh_id);\r\nif (idx < 0) return -1;\r\ng_array_remove_index(c->handlers,idx);\r\nreturn 1;\r\n}\r\nextern echld_state_t echld_msgh_detach(int child_id, int msgh_id) {\r\nechld_t* c = get_child(child_id);\r\nreturn msgh_detach(c,msgh_id);\r\n}\r\nstatic void* msgh_get_data(echld_t* c, int msgh_id) {\r\nint idx = msgh_idx(c,msgh_id);\r\nif (idx < 0) return NULL;\r\nreturn ((hdlr_t*)(c->handlers->data))[idx].cb_data;\r\n}\r\nextern void* echld_msgh_get_data(int child_id, int msgh_id) {\r\nechld_t* c = get_child(child_id);\r\nreturn msgh_get_data(c,msgh_id);\r\n}\r\nstatic echld_msg_cb_t msgh_get_cb(echld_t* c, int msgh_id) {\r\nint idx = msgh_idx(c,msgh_id);\r\nif (idx < 0) return NULL;\r\nreturn ((hdlr_t*)(c->handlers->data))[idx].cb;\r\n}\r\nextern echld_msg_cb_t echld_msgh_get_cb(int child_id, int msgh_id) {\r\nechld_t* c = get_child(child_id);\r\nreturn msgh_get_cb(c,msgh_id);\r\n}\r\nstatic echld_msg_type_t msgh_get_type(echld_t* c, int msgh_id) {\r\nint idx = msgh_idx(c,msgh_id);\r\nif (idx < 0) return EC_ACTUAL_ERROR;\r\nreturn ((hdlr_t*)(c->handlers->data))[idx].type;\r\n}\r\nextern echld_msg_type_t echld_msgh_get_type(int child_id, int msgh_id) {\r\nechld_t* c = get_child(child_id);\r\nreturn c ? msgh_get_type(c,msgh_id) : EC_ACTUAL_ERROR;\r\n}\r\nstatic echld_state_t msgh_get_all(echld_t* c, int msgh_id, echld_msg_type_t* t, echld_msg_cb_t* cb, void** data) {\r\nint idx = msgh_idx(c,msgh_id);\r\nhdlr_t* h;\r\nif (idx < 0) return -1;\r\nh = &(((hdlr_t*)(c->handlers->data))[idx]);\r\nif (t) *t = h->type;\r\nif (cb) *cb = h->cb;\r\nif (data) *data = h->cb_data;\r\nreturn 0;\r\n}\r\nextern gboolean echld_msgh_get_all(int child_id, int msgh_id, echld_msg_type_t* t, echld_msg_cb_t* cb, void** data) {\r\nechld_t* c = get_child(child_id);\r\nreturn c && msgh_get_all(c,msgh_id,t,cb,data);\r\n}\r\nstatic echld_state_t msgh_set_all(echld_t* c, int msgh_id, echld_msg_type_t t, echld_msg_cb_t cb, void* data) {\r\nint idx = msgh_idx(c,msgh_id);\r\nhdlr_t* h;\r\nif (idx < 0) return -1;\r\nh = &(((hdlr_t*)(c->handlers->data))[idx]);\r\nh->type = t;\r\nh->cb = cb;\r\nh->cb_data = data;\r\nreturn 0;\r\n}\r\nextern gboolean echld_msgh_set_all(int child_id, int msgh_id, echld_msg_type_t t, echld_msg_cb_t cb, void* data) {\r\nechld_t* c = get_child(child_id);\r\nreturn c ? msgh_set_all(c,msgh_id,t,cb,data) : FALSE;\r\n}\r\nstatic gboolean msgh_set_data(echld_t* c, int msgh_id, void* data) {\r\nint idx = msgh_idx(c,msgh_id);\r\nif (idx < 0) return FALSE;\r\n((hdlr_t*)(c->handlers->data))[idx].cb_data = data;\r\nreturn TRUE;\r\n}\r\nextern gboolean echld_msgh_set_data(int child_id, int msgh_id, void* data){\r\nechld_t* c = get_child(child_id);\r\nreturn c ? msgh_set_data(c,msgh_id,data) : FALSE;\r\n}\r\nextern gboolean msgh_set_cb(echld_t* c, int msgh_id, echld_msg_cb_t cb) {\r\nint idx = msgh_idx(c,msgh_id);\r\nif (idx < 0) return FALSE;\r\n((hdlr_t*)(c->handlers->data))[idx].cb = cb;\r\nreturn TRUE;\r\n}\r\nextern gboolean echld_msgh_set_cb(int child_id, int msgh_id, echld_msg_cb_t cb) {\r\nechld_t* c = get_child(child_id);\r\nreturn c ? msgh_set_cb(c,msgh_id,cb) : FALSE;\r\n}\r\nstatic gboolean msgh_set_type(echld_t* c, int msgh_id, echld_msg_type_t t) {\r\nint idx = msgh_idx(c,msgh_id);\r\nif (idx < 0) return FALSE;\r\n((hdlr_t*)(c->handlers->data))[idx].type = t;\r\nreturn TRUE;\r\n}\r\nextern gboolean echld_msgh_set_type(int child_id, int msgh_id, echld_msg_type_t t) {\r\nechld_t* c = get_child(child_id);\r\nreturn c ? msgh_set_type(c,msgh_id,t) : FALSE;\r\n}\r\nextern void echld_foreach_child(echld_iter_cb_t cb, void* cb_data) {\r\nint i;\r\nfor(i=0;i<ECHLD_MAX_CHILDREN;i++) {\r\nechld_t* c = &(parent.children[i]);\r\ncb(c->chld_id,c->data,cb_data);\r\n}\r\n}\r\nstatic reqh_t* get_req(echld_t* c, int reqh_id) {\r\nint idx = reqh_id_idx(c,reqh_id);\r\nif(idx < 0) return NULL;\r\nreturn ((reqh_t*)(c->reqs->data))+idx;\r\n}\r\nstatic hdlr_t* get_next_hdlr_for_type(echld_t* c, echld_msg_type_t t, int* cookie) {\r\nint imax = c->handlers->len;\r\nhdlr_t* r = NULL;\r\nfor (;(*cookie)<imax;(*cookie)++) {\r\nif (((hdlr_t*)(c->handlers->data))[*cookie].type == t) {\r\nr = &( ((hdlr_t*)(c->handlers->data))[*cookie] );\r\n(*cookie)++;\r\nbreak;\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic long parent_read_frame(guint8* b, size_t len, echld_chld_id_t chld_id, echld_msg_type_t t, echld_reqh_id_t reqh_id, void* data _U_) {\r\nechld_t* c = get_child(chld_id);\r\nGByteArray* ba = g_byte_array_new();\r\nPARENT_DBG((1,"MSG_IN<- ch=%d t='%s' rh=%d",chld_id,TY(t),reqh_id));\r\ng_byte_array_append(ba,b, (guint)len);\r\nif (c) {\r\nreqh_t* r = get_req(c, reqh_id);\r\nint i;\r\nhdlr_t* h;\r\ngboolean go_ahead = TRUE;\r\nif (r) {\r\nif (r->cb) {\r\ngo_ahead = r->cb(t,ba,r->cb_data);\r\n}\r\nr->reqh_id = -1;\r\nr->cb = NULL;\r\nr->cb_data = 0;\r\nr->tv.tv_sec = 0;\r\nr->tv.tv_usec = 0;\r\nPARENT_DBG((2,"handled by reqh_id=%d msg='%s'",reqh_id,go_ahead?"retrying":"done"));\r\n}\r\ni=0;\r\nwhile(go_ahead && ( h = get_next_hdlr_for_type(c,t,&i))) {\r\nif (h->cb)\r\ngo_ahead = h->cb(t,ba,h->cb_data);\r\nPARENT_DBG((2,"handled by t='%s' msgh_id=%d msg='%s'",TY(h->type), h->id,go_ahead?"retrying":"done"));\r\n}\r\n} else {\r\nPARENT_DBG((1,"parent_read_frame: No such child"));\r\n}\r\ng_byte_array_free(ba,TRUE);\r\nreturn 1;\r\n}\r\nextern int echld_fdset(fd_set* rfds, fd_set* efds) {\r\nFD_SET(parent.reader.fd, rfds);\r\nFD_SET(parent.reader.fd, efds);\r\nFD_SET(parent.dispatcher_fd, efds);\r\nreturn 2;\r\n}\r\nextern int echld_fd_read(fd_set* rfds, fd_set* efds) {\r\nint r_nfds=0;\r\nif (FD_ISSET(parent.reader.fd,efds) || FD_ISSET(parent.dispatcher_fd,efds) ) {\r\nPARENT_DBG((1,"parent errored"));\r\nreturn -1;\r\n}\r\nif (FD_ISSET(parent.reader.fd,rfds)) {\r\nPARENT_DBG((3,"reading from dispatcher"));\r\nechld_read_frame(&(parent.reader),parent_read_frame,&(parent));\r\n}\r\nreturn r_nfds;\r\n}\r\nextern int echld_select(int nfds _U_, fd_set* rfds, fd_set* wfds, fd_set* efds, struct timeval* timeout) {\r\nfd_set my_rfds, my_wfds, my_efds;\r\nint r_nfds;\r\nif (rfds == NULL) { rfds = &my_rfds; FD_ZERO(rfds); }\r\nif (wfds == NULL) { wfds = &my_wfds; FD_ZERO(wfds); }\r\nif (efds == NULL) { efds = &my_efds; FD_ZERO(efds); }\r\nechld_fdset(rfds,efds);\r\nPARENT_DBG((5,"Select()"));\r\nr_nfds = select(FD_SETSIZE, rfds, wfds, efds, timeout);\r\nechld_fd_read(rfds,efds);\r\nreturn r_nfds ;\r\n}\r\nextern echld_state_t echld_wait(struct timeval* timeout) {\r\nif ( echld_select(0, NULL, NULL, NULL, timeout) < 0) {\r\nreturn -1;\r\n} else {\r\nreturn ECHLD_OK;\r\n}\r\n}\r\nenc_msg_t* echld_new_child_params(void) {\r\nreturn (enc_msg_t*)g_byte_array_new();\r\n}\r\nenc_msg_t* echld_new_child_params_merge(enc_msg_t* em1, enc_msg_t* em2) {\r\nGByteArray* ba = g_byte_array_new();\r\nGByteArray* b1 = (GByteArray*)em1;\r\nGByteArray* b2 = (GByteArray*)em2;\r\ng_byte_array_append(ba,b1->data,b1->len);\r\ng_byte_array_append(ba,b2->data,b2->len);\r\nreturn (enc_msg_t*)ba;\r\n}\r\nchar* echld_new_child_params_str(enc_msg_t* em, const char* prefix, const char* postfix, int trunc_n, const char* fmt) {\r\nGByteArray* ba = (GByteArray*)em;\r\nGString* str = g_string_new(prefix);\r\nchar* p = (char*) ba->data;\r\nint tot_len = ba->len;\r\nlong rem = tot_len;\r\np[rem-1] = '\0';\r\nwhile(rem > 2) {\r\nchar* param = p;\r\nlong param_len = strlen(param)+1;\r\nchar* value = p + param_len;\r\nlong value_len;\r\nrem -= param_len;\r\nif (rem < 0) {\r\ng_string_free(str,TRUE);\r\nreturn NULL;\r\n}\r\nvalue_len = strlen(value)+1;\r\nrem -= value_len;\r\np = value + value_len;\r\nif (rem < 0) {\r\ng_string_free(str,TRUE);\r\nreturn NULL;\r\n}\r\ng_string_append_printf(str,fmt,param,value);\r\n}\r\ng_string_truncate(str, str->len - trunc_n);\r\ng_string_append(str,postfix);\r\np = str->str;\r\ng_string_free(str,FALSE);\r\nreturn p;\r\n}\r\nvoid echld_new_child_params_add_params(enc_msg_t* em, ...) {\r\nGByteArray* ba = (GByteArray*) em;\r\nva_list ap;\r\nva_start(ap,em);\r\ndo {\r\nchar* param_str = va_arg(ap, char*);\r\nif (param_str) {\r\nchar* val_str = va_arg(ap, char*);\r\ng_byte_array_append(ba, (guint8*) param_str, (guint)strlen(param_str)+1);\r\ng_byte_array_append(ba, (guint8*) val_str, (guint)strlen(val_str)+1);\r\ncontinue;\r\n}\r\nbreak;\r\n} while(1);\r\nva_end(ap);\r\n}
