static double getOlsrTime(guint8 timeval) {\r\nint high_bits, low_bits;\r\nhigh_bits = ((timeval & 0xF0) >> 4);\r\nlow_bits = (timeval & 0x0F);\r\nreturn ((G_GUINT64_CONSTANT(1) << low_bits) / 16.0) * (1 + (high_bits / 16.0));\r\n}\r\nstatic int dissect_olsr_tc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *olsr_tree, int offset, int message_end) {\r\nif (message_end - offset < 4) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for TC");\r\nreturn message_end;\r\n}\r\nproto_tree_add_item(olsr_tree, hf_olsr_ansn, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nwhile (offset < message_end) {\r\nif (message_end - offset < pinfo->src.len) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for last neighbor");\r\nreturn message_end;\r\n}\r\nif (pinfo->src.type == AT_IPv4) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_neighbor_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else if (pinfo->src.type == AT_IPv6) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_neighbor6_addr, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn message_end;\r\n}\r\nstatic int dissect_olsrorg_lq_tc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *olsr_tree, int offset, int message_end) {\r\nif (message_end - offset < 4) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for Olsr.org LQ-TC");\r\nreturn message_end;\r\n}\r\nproto_tree_add_item(olsr_tree, hf_olsr_ansn, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nwhile (offset < message_end) {\r\nproto_item *address_group;\r\nproto_tree *address_tree;\r\nguint8 lq, nlq;\r\nif (pinfo->src.type == AT_IPv4) {\r\nif (message_end - offset < 8) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for last entry (need 8 bytes)");\r\nreturn message_end;\r\n}\r\nlq = tvb_get_guint8(tvb, offset + 4);\r\nnlq = tvb_get_guint8(tvb, offset + 5);\r\naddress_group = proto_tree_add_bytes_format_value(olsr_tree, hf_olsr_neighbor, tvb, offset, 8,\r\nNULL, "%s (%d/%d)", tvb_ip_to_str(tvb, offset), lq, nlq);\r\naddress_tree = proto_item_add_subtree(address_group, ett_olsr_message_neigh);\r\nproto_tree_add_item(address_tree, hf_olsr_neighbor_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else if (pinfo->src.type == AT_IPv6) {\r\nif (message_end - offset < 20) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for last entry (need 20 bytes)");\r\nreturn message_end;\r\n}\r\nlq = tvb_get_guint8(tvb, offset + 16);\r\nnlq = tvb_get_guint8(tvb, offset + 17);\r\naddress_group = proto_tree_add_bytes_format_value(olsr_tree, hf_olsr_neighbor, tvb, offset, 20,\r\nNULL, "%s (%d/%d)", tvb_ip6_to_str(tvb, offset), lq, nlq);\r\naddress_tree = proto_item_add_subtree(address_group, ett_olsr_message_neigh);\r\nproto_tree_add_item(address_tree, hf_olsr_neighbor6_addr, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n} else {\r\nbreak;\r\n}\r\nproto_tree_add_item(address_tree, hf_olsrorg_lq, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(address_tree, hf_olsrorg_nlq, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nreturn message_end;\r\n}\r\nstatic int dissect_nrlolsr_tc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *olsr_tree, int offset, int message_end) {\r\nint field1Ptr, field2Ptr, saneEnd;\r\nif (message_end - offset < 4) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for NRLOLSR LQ-TC");\r\nreturn message_end;\r\n}\r\nproto_tree_add_item(olsr_tree, hf_olsr_ansn, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nfield1Ptr = offset + (message_end - offset) / (pinfo->src.len + 2) * (pinfo->src.len);\r\nfield2Ptr = offset + (message_end - offset) / (pinfo->src.len + 2) * (pinfo->src.len + 1);\r\nsaneEnd = message_end - ((message_end - offset) % (pinfo->src.len + 2));\r\nwhile (field2Ptr < saneEnd) {\r\nif (pinfo->src.type == AT_IPv4) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_neighbor_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else if (pinfo->src.type == AT_IPv6) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_neighbor6_addr, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n} else {\r\nbreak;\r\n}\r\nproto_tree_add_item(olsr_tree, hf_nrlolsr_f1, tvb, field1Ptr++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(olsr_tree, hf_nrlolsr_f2, tvb, field2Ptr++, 1, ENC_BIG_ENDIAN);\r\n}\r\nreturn message_end;\r\n}\r\nstatic int dissect_olsr_hello(tvbuff_t *tvb, packet_info *pinfo, proto_tree *olsr_tree, int offset, int message_end,\r\nint(*handleNeighbors)(tvbuff_t *, packet_info *, proto_tree *, int, int)) {\r\ndouble hTime;\r\nproto_item *ti;\r\nproto_tree *link_type_tree;\r\nguint16 message_size = 0;\r\nif (message_end - offset < 4) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for Hello");\r\nreturn message_end;\r\n}\r\noffset += 2;\r\nhTime = getOlsrTime(tvb_get_guint8(tvb, offset));\r\nproto_tree_add_double_format_value(olsr_tree, hf_olsr_htime, tvb, offset, 1, hTime,\r\n"%.3f (in seconds)", hTime);\r\noffset += 1;\r\nproto_tree_add_item(olsr_tree, hf_olsr_willingness, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nwhile (offset < message_end) {\r\nif (message_end - offset < 4) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for last Hello entry");\r\nreturn message_end;\r\n}\r\nti = proto_tree_add_item(olsr_tree, hf_olsr_link_type, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nlink_type_tree = proto_item_add_subtree(ti, ett_olsr_message_linktype);\r\noffset += 1;\r\nmessage_size = tvb_get_ntohs(tvb, offset);\r\nti = proto_tree_add_item(link_type_tree, hf_olsr_link_message_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (message_size < 4) {\r\nproto_item_append_string(ti, "(too short, must be >= 4)");\r\nreturn message_end;\r\n}\r\noffset = handleNeighbors(tvb, pinfo, link_type_tree, offset, offset + message_size - 4);\r\n}\r\nreturn message_end;\r\n}\r\nstatic int handle_olsr_hello_rfc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *olsr_tree, int offset,\r\nint link_message_end) {\r\nwhile (offset < link_message_end) {\r\nif (link_message_end - offset < pinfo->src.len) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, link_message_end - offset,\r\n"Not enough bytes for last Hello entry");\r\nreturn link_message_end;\r\n}\r\nif (pinfo->src.type == AT_IPv4) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_neighbor_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else if (pinfo->src.type == AT_IPv6) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_neighbor6_addr, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn link_message_end;\r\n}\r\nstatic int handle_olsr_hello_olsrorg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *olsr_tree, int offset,\r\nint link_message_end) {\r\nwhile (offset < link_message_end) {\r\nproto_item *address_group;\r\nproto_tree *address_tree;\r\nguint8 lq, nlq;\r\nif (link_message_end - offset < pinfo->src.len + 4) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, link_message_end - offset,\r\n"Not enough bytes for last Olsr.org LQ-Hello entry");\r\nreturn link_message_end;\r\n}\r\nif (pinfo->src.type == AT_IPv4) {\r\nlq = tvb_get_guint8(tvb, offset + 4);\r\nnlq = tvb_get_guint8(tvb, offset + 5);\r\naddress_group = proto_tree_add_bytes_format_value(olsr_tree, hf_olsr_neighbor, tvb, offset, 8,\r\nNULL, "%s (%d/%d)", tvb_ip_to_str(tvb, offset), lq, nlq);\r\naddress_tree = proto_item_add_subtree(address_group, ett_olsr_message_neigh);\r\nproto_tree_add_item(address_tree, hf_olsr_neighbor_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else if (pinfo->src.type == AT_IPv6) {\r\nlq = tvb_get_guint8(tvb, offset + 16);\r\nnlq = tvb_get_guint8(tvb, offset + 17);\r\naddress_group = proto_tree_add_bytes_format_value(olsr_tree, hf_olsr_neighbor, tvb, offset, 20,\r\nNULL, "%s (%d/%d)", tvb_ip6_to_str(tvb, offset), lq, nlq);\r\naddress_tree = proto_item_add_subtree(address_group, ett_olsr_message_neigh);\r\nproto_tree_add_item(address_tree, hf_olsr_neighbor6_addr, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n} else {\r\nbreak;\r\n}\r\nproto_tree_add_item(address_tree, hf_olsrorg_lq, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(address_tree, hf_olsrorg_nlq, tvb, offset++, 1, ENC_BIG_ENDIAN);\r\noffset += 2;\r\n}\r\nreturn link_message_end;\r\n}\r\nstatic int dissect_olsr_mid(tvbuff_t *tvb, packet_info *pinfo, proto_tree *olsr_tree, int offset, int message_end) {\r\nwhile (offset < message_end) {\r\nif (message_end - offset < pinfo->src.len) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for last MID entry");\r\nreturn message_end;\r\n}\r\nif (pinfo->src.type == AT_IPv4) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_interface_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else if (pinfo->src.type == AT_IPv6) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_interface6_addr, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn message_end;\r\n}\r\nstatic int dissect_olsr_hna(tvbuff_t *tvb, packet_info *pinfo, proto_tree *olsr_tree, int offset, int message_end) {\r\nwhile (offset < message_end) {\r\nif (message_end - offset < pinfo->src.len * 2) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for last HNA entry");\r\nreturn message_end;\r\n}\r\nif (pinfo->src.type == AT_IPv4) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_network_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nproto_tree_add_item(olsr_tree, hf_olsr_netmask, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else if (pinfo->src.type == AT_IPv6) {\r\nproto_tree_add_item(olsr_tree, hf_olsr_network6_addr, tvb, offset, 4, ENC_NA);\r\noffset += 16;\r\nproto_tree_add_item(olsr_tree, hf_olsr_netmask6, tvb, offset, 4, ENC_NA);\r\noffset += 16;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn message_end;\r\n}\r\nstatic int dissect_olsrorg_nameservice(tvbuff_t *tvb, packet_info *pinfo, proto_tree *olsr_tree, int offset,\r\nint message_end) {\r\nguint16 version, count;\r\nproto_item *olsr_ns_item, *ti;\r\nproto_tree *olsr_ns_tree;\r\nif (message_end - offset < 4) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for Olsr.org Nameservice message");\r\nreturn message_end;\r\n}\r\nversion = tvb_get_ntohs(tvb, offset);\r\nti = proto_tree_add_item(olsr_tree, hf_olsrorg_ns_version, tvb, offset, 2, ENC_BIG_ENDIAN);\r\ncount = tvb_get_ntohs(tvb, offset + 2);\r\nproto_tree_add_item(olsr_tree, hf_olsrorg_ns_count, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (version != 1) {\r\nexpert_add_info(pinfo, ti, &ei_olsrorg_ns_version);\r\nproto_tree_add_item(olsr_tree, hf_olsr_data, tvb, offset, message_end - offset, ENC_NA);\r\nreturn message_end;\r\n}\r\nwhile (offset < message_end && count-- > 0) {\r\nguint16 type, length;\r\nint total_length;\r\nif (message_end - offset < 20) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for last nameservice entry");\r\nreturn message_end;\r\n}\r\ntype = tvb_get_ntohs(tvb, offset);\r\nlength = tvb_get_ntohs(tvb, offset + 2);\r\ntotal_length = 4 + 16 + ((length - 1) | 3) + 1;\r\nolsr_ns_item = proto_tree_add_bytes_format_value(olsr_tree, hf_olsrorg_ns, tvb, offset, total_length,\r\nNULL, "%s (%d)", val_to_str_const(type, nameservice_type_vals, "UNKNOWN"), type);\r\nolsr_ns_tree = proto_item_add_subtree(olsr_ns_item, ett_olsr_message_ns);\r\nproto_tree_add_item(olsr_ns_tree, hf_olsrorg_ns_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_uint(olsr_ns_tree, hf_olsrorg_ns_length, tvb, offset + 2, 2, length);\r\nif (pinfo->src.type == AT_IPv4) {\r\nproto_tree_add_item(olsr_ns_tree, hf_olsrorg_ns_ip, tvb, offset + 4, 4, ENC_BIG_ENDIAN);\r\n} else if (pinfo->src.type == AT_IPv6) {\r\nproto_tree_add_item(olsr_ns_tree, hf_olsrorg_ns_ip6, tvb, offset + 4, 16, ENC_NA);\r\n} else {\r\nbreak;\r\n}\r\nif (message_end - offset < total_length) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, message_end - offset,\r\n"Not enough bytes for content of last nameservice entry");\r\nreturn message_end;\r\n}\r\nproto_tree_add_item(olsr_ns_tree, hf_olsrorg_ns_content, tvb, offset + 20, length, ENC_ASCII|ENC_NA);\r\noffset += 4 + 16 + ((length - 1) | 3) + 1;\r\n}\r\nreturn message_end;\r\n}\r\nstatic int dissect_olsr(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_) {\r\nproto_item *ti;\r\nproto_tree *olsr_tree;\r\nint offset, message_len, message_end;\r\nguint message_type;\r\ndouble vTime;\r\nguint16 packet_len;\r\nif (tvb_length(tvb) < 4) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "OLSR Packet, Length: %u Bytes (not enough data in packet)",\r\ntvb_length(tvb));\r\nreturn 0;\r\n}\r\npacket_len = tvb_get_ntohs(tvb, 0);\r\nif (packet_len > tvb_length(tvb)) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "OLSR Packet, Length: %u Bytes (not enough data in packet)", packet_len);\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "OLSR v1");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif ((pinfo->src.type != AT_IPv4) && (pinfo->src.type != AT_IPv6)) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "OLSR (unknown address type) Packet, Length: %u Bytes", packet_len);\r\nreturn 0;\r\n}\r\nif (pinfo->src.type == AT_IPv4) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "OLSR (IPv4) Packet, Length: %u Bytes", packet_len);\r\n} else if (pinfo->src.type == AT_IPv6) {\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "OLSR (IPv6) Packet, Length: %u Bytes", packet_len);\r\n}\r\nti = proto_tree_add_item(tree, proto_olsr, tvb, 0, -1, ENC_NA);\r\nolsr_tree = proto_item_add_subtree(ti, ett_olsr);\r\nproto_tree_add_item(olsr_tree, hf_olsr_packet_len, tvb, 0, 2, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(olsr_tree, hf_olsr_packet_seq_num, tvb, 2, 2, ENC_BIG_ENDIAN);\r\noffset = 4;\r\nwhile (offset < packet_len) {\r\nproto_item *message_item;\r\nproto_tree *message_tree;\r\nif (packet_len - offset < 4) {\r\nproto_tree_add_expert_format(olsr_tree, pinfo, &ei_olsr_not_enough_bytes, tvb, offset, packet_len - offset,\r\n"Message too short !");\r\nbreak;\r\n}\r\nmessage_type = tvb_get_guint8(tvb, offset);\r\nvTime = getOlsrTime(tvb_get_guint8(tvb, offset + 1));\r\nmessage_len = tvb_get_ntohs(tvb, offset + 2);\r\nmessage_item = proto_tree_add_bytes_format_value(olsr_tree, hf_olsr_message, tvb, offset, message_len,\r\nNULL, "%s (%d)", val_to_str_const(message_type, message_type_vals, "UNKNOWN"),\r\nmessage_type);\r\nmessage_tree = proto_item_add_subtree(message_item, ett_olsr_message[message_type]);\r\nproto_tree_add_uint(message_tree, hf_olsr_message_type, tvb, offset, 1, message_type);\r\noffset += 1;\r\nproto_tree_add_double_format_value(message_tree, hf_olsr_vtime, tvb, offset, 1, vTime,\r\n"%.3f (in seconds)", vTime);\r\noffset += 1;\r\nti = proto_tree_add_item(message_tree, hf_olsr_message_size, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nif (message_len < 8 + pinfo->src.len) {\r\nproto_item_append_text(ti, "(too short, must be >= %d)", 8 + pinfo->src.len);\r\nbreak;\r\n}\r\nmessage_end = offset + message_len - 4;\r\nif (message_end > packet_len) {\r\nproto_item_append_string(ti, "(not enough data for message)");\r\nbreak;\r\n}\r\nif (pinfo->src.type == AT_IPv4) {\r\nproto_tree_add_item(message_tree, hf_olsr_origin_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset += 4;\r\n} else if (pinfo->src.type == AT_IPv6) {\r\nproto_tree_add_item(message_tree, hf_olsr_origin6_addr, tvb, offset, 16, ENC_NA);\r\noffset += 16;\r\n} else {\r\nbreak;\r\n}\r\nproto_tree_add_item(message_tree, hf_olsr_ttl, tvb, offset, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_olsr_hop_count, tvb, offset + 1, 1, ENC_BIG_ENDIAN);\r\nproto_tree_add_item(message_tree, hf_olsr_message_seq_num, tvb, offset + 2, 2, ENC_BIG_ENDIAN);\r\noffset += 4;\r\nif (offset < message_end) {\r\nif (message_type == TC) {\r\ndissect_olsr_tc(tvb, pinfo, message_tree, offset, message_end);\r\n}\r\nelse if (message_type == HELLO) {\r\ndissect_olsr_hello(tvb, pinfo, message_tree, offset, message_end, &handle_olsr_hello_rfc);\r\n}\r\nelse if (message_type == MID) {\r\ndissect_olsr_mid(tvb, pinfo, message_tree, offset, message_end);\r\n}\r\nelse if (message_type == HNA) {\r\ndissect_olsr_hna(tvb, pinfo, message_tree, offset, message_end);\r\n}\r\nelse if (global_olsr_olsrorg && message_type == OLSR_ORG_LQ_HELLO) {\r\ndissect_olsr_hello(tvb, pinfo, message_tree, offset, message_end, &handle_olsr_hello_olsrorg);\r\n}\r\nelse if (global_olsr_olsrorg && message_type == OLSR_ORG_LQ_TC) {\r\ndissect_olsrorg_lq_tc(tvb, pinfo, message_tree, offset, message_end);\r\n}\r\nelse if (global_olsr_olsrorg && message_type == OLSR_ORG_NAMESERVICE) {\r\ndissect_olsrorg_nameservice(tvb, pinfo, message_tree, offset, message_end);\r\n}\r\nelse if (global_olsr_nrlolsr && message_type == NRLOLSR_TC_EXTRA) {\r\ndissect_nrlolsr_tc(tvb, pinfo, message_tree, offset, message_end);\r\n}\r\nelse {\r\nti = proto_tree_add_bytes_format(message_tree, hf_olsr_data, tvb, offset, message_len - 12,\r\nNULL, "Data (%u bytes)", message_len - 12);\r\nif ((message_len - 12) % 4) {\r\nexpert_add_info(pinfo, ti, &ei_olsr_data_misaligned);\r\nbreak;\r\n}\r\n}\r\n}\r\noffset = message_end;\r\n}\r\nreturn tvb_length(tvb);\r\n}\r\nvoid proto_register_olsr(void) {\r\nstatic hf_register_info hf[] = {\r\n{ &hf_olsr_packet_len,\r\n{ "Packet Length", "olsr.packet_len",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Packet Length in Bytes", HFILL\r\n}\r\n},\r\n{ &hf_olsr_packet_seq_num,\r\n{ "Packet Sequence Number", "olsr.packet_seq_num",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_message,\r\n{ "Message", "olsr.message",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_message_type,\r\n{ "Message Type", "olsr.message_type",\r\nFT_UINT8, BASE_DEC, VALS(message_type_vals), 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_message_size,\r\n{ "Message", "olsr.message_size",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Message Size in Bytes", HFILL\r\n}\r\n},\r\n{ &hf_olsr_message_seq_num,\r\n{ "Message Sequence Number", "olsr.message_seq_num",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_vtime,\r\n{ "Validity Time", "olsr.vtime",\r\nFT_DOUBLE, BASE_NONE, NULL, 0,\r\n"Validity Time in seconds", HFILL\r\n}\r\n},\r\n{ &hf_olsr_ansn,\r\n{ "Advertised Neighbor Sequence Number (ANSN)", "olsr.ansn",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_htime,\r\n{ "Hello Emission Interval", "olsr.htime",\r\nFT_DOUBLE, BASE_NONE, NULL, 0,\r\n"Hello emission interval in seconds", HFILL\r\n}\r\n},\r\n{ &hf_olsr_willingness,\r\n{ "Willingness to forward messages", "olsr.willingness",\r\nFT_UINT8, BASE_DEC, VALS(willingness_type_vals), 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_ttl,\r\n{ "TTL", "olsr.ttl",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Time to Live in hops", HFILL\r\n}\r\n},\r\n{ &hf_olsr_link_type,\r\n{ "Link Type", "olsr.link_type",\r\nFT_UINT8, BASE_DEC, VALS(link_type_vals), 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_link_message_size,\r\n{ "Link Message Size", "olsr.link_message_size",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Link Message Size in bytes", HFILL\r\n}\r\n},\r\n{ &hf_olsr_hop_count,\r\n{ "Hop Count", "olsr.hop_count",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_neighbor,\r\n{ "Neighbor Address", "olsr.neighbor",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_origin_addr,\r\n{ "Originator Address", "olsr.origin_addr",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_neighbor_addr,\r\n{ "Neighbor Address", "olsr.neighbor_addr",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_network_addr,\r\n{ "Network Address", "olsr.network_addr",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_interface_addr,\r\n{ "Interface Address", "olsr.interface_addr",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_netmask,\r\n{ "Netmask", "olsr.netmask",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n#if 0\r\n{ &hf_olsr_neighbor6,\r\n{ "Neighbor Address", "olsr.neighbor6",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n#endif\r\n{ &hf_olsr_origin6_addr,\r\n{ "Originator Address", "olsr.origin6_addr",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_neighbor6_addr,\r\n{ "Neighbor Address", "olsr.neighbor6_addr",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_network6_addr,\r\n{ "Network Address", "olsr.network6_addr",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_interface6_addr,\r\n{ "Interface Address", "olsr.interface6_addr",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_netmask6,\r\n{ "Netmask", "olsr.netmask6",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsr_data,\r\n{ "Data", "olsr.data",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_lq,\r\n{ "LQ", "olsr.lq",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Link quality", HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_nlq,\r\n{ "NLQ", "olsr.nlq",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\n"Neighbor link quality", HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_ns,\r\n{ "Nameservice", "olsr.ns",\r\nFT_BYTES, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_ns_version,\r\n{ "Version", "olsr.ns.version",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_ns_count,\r\n{ "Count", "olsr.ns.count",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\n"Number of nameservice messages", HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_ns_type,\r\n{ "Message Type", "olsr.ns.type",\r\nFT_UINT16, BASE_DEC, VALS(nameservice_type_vals), 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_ns_length,\r\n{ "Length", "olsr.ns.length",\r\nFT_UINT16, BASE_DEC, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_ns_ip,\r\n{ "Address", "olsr.ns.ip",\r\nFT_IPv4, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_ns_ip6,\r\n{ "Address", "olsr.ns.ip6",\r\nFT_IPv6, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_olsrorg_ns_content,\r\n{ "Content", "olsr.ns.content",\r\nFT_STRING, BASE_NONE, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_nrlolsr_f1,\r\n{ "NRL MINMAX", "olsr.nrl.minmax",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL\r\n}\r\n},\r\n{ &hf_nrlolsr_f2,\r\n{ "NRL SPF", "olsr.nrl.spf",\r\nFT_UINT8, BASE_DEC, NULL, 0,\r\nNULL, HFILL\r\n}\r\n}\r\n};\r\nstatic gint *ett_base[] = {\r\n&ett_olsr,\r\n&ett_olsr_message_linktype,\r\n&ett_olsr_message_neigh,\r\n&ett_olsr_message_neigh6,\r\n&ett_olsr_message_ns\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_olsr_not_enough_bytes, { "olsr.not_enough_bytes", PI_MALFORMED, PI_ERROR, "Not enough bytes for field", EXPFILL }},\r\n{ &ei_olsrorg_ns_version, { "olsr.ns.version.unknown", PI_PROTOCOL, PI_WARN, "Unknown nameservice protocol version", EXPFILL }},\r\n{ &ei_olsr_data_misaligned, { "olsr.data.misaligned", PI_PROTOCOL, PI_WARN, "Must be aligned on 32 bits", EXPFILL }},\r\n};\r\ngint *ett[array_length(ett_base) + (G_MAXUINT8+1)];\r\nmodule_t *olsr_module;\r\nexpert_module_t *expert_olsr;\r\nint i,j;\r\nmemcpy(ett, ett_base, sizeof(ett_base));\r\nj = array_length(ett_base);\r\nfor (i=0; i<G_MAXUINT8+1; i++) {\r\nett_olsr_message[i] = -1;\r\nett[j++] = &ett_olsr_message[i];\r\n}\r\nproto_olsr = proto_register_protocol("Optimized Link State Routing Protocol", "OLSR", "olsr");\r\nproto_register_field_array(proto_olsr, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_olsr = expert_register_protocol(proto_olsr);\r\nexpert_register_field_array(expert_olsr, ei, array_length(ei));\r\nolsr_module = prefs_register_protocol(proto_olsr, NULL);\r\nprefs_register_bool_preference(olsr_module, "ff_olsrorg",\r\n"Dissect olsr.org messages","Dissect custom olsr.org message types (compatible with rfc routing agents)",\r\n&global_olsr_olsrorg);\r\nprefs_register_bool_preference(olsr_module, "nrlolsr",\r\n"Dissect NRL-Olsr TC messages", "Dissect custom nrlolsr tc message (incompatible with rfc routing agents)",\r\n&global_olsr_nrlolsr);\r\n}\r\nvoid proto_reg_handoff_olsr(void) {\r\ndissector_handle_t olsr_handle;\r\nolsr_handle = new_create_dissector_handle(dissect_olsr, proto_olsr);\r\ndissector_add_uint("udp.port", UDP_PORT_OLSR, olsr_handle);\r\n}
