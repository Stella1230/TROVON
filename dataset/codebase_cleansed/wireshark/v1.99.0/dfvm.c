dfvm_insn_t*\r\ndfvm_insn_new(dfvm_opcode_t op)\r\n{\r\ndfvm_insn_t *insn;\r\ninsn = g_new(dfvm_insn_t, 1);\r\ninsn->op = op;\r\ninsn->arg1 = NULL;\r\ninsn->arg2 = NULL;\r\ninsn->arg3 = NULL;\r\ninsn->arg4 = NULL;\r\nreturn insn;\r\n}\r\nstatic void\r\ndfvm_value_free(dfvm_value_t *v)\r\n{\r\nswitch (v->type) {\r\ncase FVALUE:\r\nFVALUE_FREE(v->value.fvalue);\r\nbreak;\r\ncase DRANGE:\r\ndrange_free(v->value.drange);\r\nbreak;\r\ndefault:\r\n;\r\n}\r\ng_free(v);\r\n}\r\nvoid\r\ndfvm_insn_free(dfvm_insn_t *insn)\r\n{\r\nif (insn->arg1) {\r\ndfvm_value_free(insn->arg1);\r\n}\r\nif (insn->arg2) {\r\ndfvm_value_free(insn->arg2);\r\n}\r\nif (insn->arg3) {\r\ndfvm_value_free(insn->arg3);\r\n}\r\nif (insn->arg4) {\r\ndfvm_value_free(insn->arg4);\r\n}\r\ng_free(insn);\r\n}\r\ndfvm_value_t*\r\ndfvm_value_new(dfvm_value_type_t type)\r\n{\r\ndfvm_value_t *v;\r\nv = g_new(dfvm_value_t, 1);\r\nv->type = type;\r\nreturn v;\r\n}\r\nvoid\r\ndfvm_dump(FILE *f, dfilter_t *df)\r\n{\r\nint id, length;\r\ndfvm_insn_t *insn;\r\ndfvm_value_t *arg1;\r\ndfvm_value_t *arg2;\r\ndfvm_value_t *arg3;\r\ndfvm_value_t *arg4;\r\nchar *value_str;\r\nGSList *range_list;\r\ndrange_node *range_item;\r\nfprintf(f, "Constants:\n");\r\nlength = df->consts->len;\r\nfor (id = 0; id < length; id++) {\r\ninsn = (dfvm_insn_t *)g_ptr_array_index(df->consts, id);\r\narg1 = insn->arg1;\r\narg2 = insn->arg2;\r\nswitch (insn->op) {\r\ncase PUT_FVALUE:\r\nvalue_str = fvalue_to_string_repr(arg1->value.fvalue,\r\nFTREPR_DFILTER, NULL);\r\nfprintf(f, "%05d PUT_FVALUE\t%s <%s> -> reg#%u\n",\r\nid, value_str,\r\nfvalue_type_name(arg1->value.fvalue),\r\narg2->value.numeric);\r\ng_free(value_str);\r\nbreak;\r\ncase CHECK_EXISTS:\r\ncase READ_TREE:\r\ncase CALL_FUNCTION:\r\ncase MK_RANGE:\r\ncase ANY_EQ:\r\ncase ANY_NE:\r\ncase ANY_GT:\r\ncase ANY_GE:\r\ncase ANY_LT:\r\ncase ANY_LE:\r\ncase ANY_BITWISE_AND:\r\ncase ANY_CONTAINS:\r\ncase ANY_MATCHES:\r\ncase NOT:\r\ncase RETURN:\r\ncase IF_TRUE_GOTO:\r\ncase IF_FALSE_GOTO:\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\nfprintf(f, "\nInstructions:\n");\r\nlength = df->insns->len;\r\nfor (id = 0; id < length; id++) {\r\ninsn = (dfvm_insn_t *)g_ptr_array_index(df->insns, id);\r\narg1 = insn->arg1;\r\narg2 = insn->arg2;\r\narg3 = insn->arg3;\r\narg4 = insn->arg4;\r\nswitch (insn->op) {\r\ncase CHECK_EXISTS:\r\nfprintf(f, "%05d CHECK_EXISTS\t%s\n",\r\nid, arg1->value.hfinfo->abbrev);\r\nbreak;\r\ncase READ_TREE:\r\nfprintf(f, "%05d READ_TREE\t\t%s -> reg#%u\n",\r\nid, arg1->value.hfinfo->abbrev,\r\narg2->value.numeric);\r\nbreak;\r\ncase CALL_FUNCTION:\r\nfprintf(f, "%05d CALL_FUNCTION\t%s (",\r\nid, arg1->value.funcdef->name);\r\nif (arg3) {\r\nfprintf(f, "reg#%u", arg3->value.numeric);\r\n}\r\nif (arg4) {\r\nfprintf(f, ", reg#%u", arg4->value.numeric);\r\n}\r\nfprintf(f, ") --> reg#%u\n", arg2->value.numeric);\r\nbreak;\r\ncase PUT_FVALUE:\r\ng_assert_not_reached();\r\nbreak;\r\ncase MK_RANGE:\r\narg3 = insn->arg3;\r\nfprintf(f, "%05d MK_RANGE\t\treg#%u[",\r\nid,\r\narg1->value.numeric);\r\nfor (range_list = arg3->value.drange->range_list;\r\nrange_list != NULL;\r\nrange_list = range_list->next) {\r\nrange_item = (drange_node *)range_list->data;\r\nswitch (range_item->ending) {\r\ncase DRANGE_NODE_END_T_UNINITIALIZED:\r\nfprintf(f, "?");\r\nbreak;\r\ncase DRANGE_NODE_END_T_LENGTH:\r\nfprintf(f, "%d:%d",\r\nrange_item->start_offset,\r\nrange_item->length);\r\nbreak;\r\ncase DRANGE_NODE_END_T_OFFSET:\r\nfprintf(f, "%d-%d",\r\nrange_item->start_offset,\r\nrange_item->end_offset);\r\nbreak;\r\ncase DRANGE_NODE_END_T_TO_THE_END:\r\nfprintf(f, "%d:",\r\nrange_item->start_offset);\r\nbreak;\r\n}\r\nif (range_list->next != NULL)\r\nfprintf(f, ",");\r\n}\r\nfprintf(f, "] -> reg#%u\n",\r\narg2->value.numeric);\r\nbreak;\r\ncase ANY_EQ:\r\nfprintf(f, "%05d ANY_EQ\t\treg#%u == reg#%u\n",\r\nid, arg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_NE:\r\nfprintf(f, "%05d ANY_NE\t\treg#%u == reg#%u\n",\r\nid, arg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_GT:\r\nfprintf(f, "%05d ANY_GT\t\treg#%u == reg#%u\n",\r\nid, arg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_GE:\r\nfprintf(f, "%05d ANY_GE\t\treg#%u == reg#%u\n",\r\nid, arg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_LT:\r\nfprintf(f, "%05d ANY_LT\t\treg#%u == reg#%u\n",\r\nid, arg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_LE:\r\nfprintf(f, "%05d ANY_LE\t\treg#%u == reg#%u\n",\r\nid, arg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_BITWISE_AND:\r\nfprintf(f, "%05d ANY_BITWISE_AND\t\treg#%u == reg#%u\n",\r\nid, arg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_CONTAINS:\r\nfprintf(f, "%05d ANY_CONTAINS\treg#%u contains reg#%u\n",\r\nid, arg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_MATCHES:\r\nfprintf(f, "%05d ANY_MATCHES\treg#%u matches reg#%u\n",\r\nid, arg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase NOT:\r\nfprintf(f, "%05d NOT\n", id);\r\nbreak;\r\ncase RETURN:\r\nfprintf(f, "%05d RETURN\n", id);\r\nbreak;\r\ncase IF_TRUE_GOTO:\r\nfprintf(f, "%05d IF-TRUE-GOTO\t%d\n",\r\nid, arg1->value.numeric);\r\nbreak;\r\ncase IF_FALSE_GOTO:\r\nfprintf(f, "%05d IF-FALSE-GOTO\t%d\n",\r\nid, arg1->value.numeric);\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic gboolean\r\nread_tree(dfilter_t *df, proto_tree *tree, header_field_info *hfinfo, int reg)\r\n{\r\nGPtrArray *finfos;\r\nfield_info *finfo;\r\nint i, len;\r\nGList *fvalues = NULL;\r\ngboolean found_something = FALSE;\r\nif (df->attempted_load[reg]) {\r\nif (df->registers[reg]) {\r\nreturn TRUE;\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\n}\r\ndf->attempted_load[reg] = TRUE;\r\nwhile (hfinfo) {\r\nfinfos = proto_get_finfo_ptr_array(tree, hfinfo->id);\r\nif ((finfos == NULL) || (g_ptr_array_len(finfos) == 0)) {\r\nhfinfo = hfinfo->same_name_next;\r\ncontinue;\r\n}\r\nelse {\r\nfound_something = TRUE;\r\n}\r\nlen = finfos->len;\r\nfor (i = 0; i < len; i++) {\r\nfinfo = (field_info *)g_ptr_array_index(finfos, i);\r\nfvalues = g_list_prepend(fvalues, &finfo->value);\r\n}\r\nhfinfo = hfinfo->same_name_next;\r\n}\r\nif (!found_something) {\r\nreturn FALSE;\r\n}\r\ndf->registers[reg] = fvalues;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nput_fvalue(dfilter_t *df, fvalue_t *fv, int reg)\r\n{\r\ndf->registers[reg] = g_list_append(NULL, fv);\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nany_test(dfilter_t *df, FvalueCmpFunc cmp, int reg1, int reg2)\r\n{\r\nGList *list_a, *list_b;\r\nlist_a = df->registers[reg1];\r\nwhile (list_a) {\r\nlist_b = df->registers[reg2];\r\nwhile (list_b) {\r\nif (cmp((fvalue_t *)list_a->data, (fvalue_t *)list_b->data)) {\r\nreturn TRUE;\r\n}\r\nlist_b = g_list_next(list_b);\r\n}\r\nlist_a = g_list_next(list_a);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void\r\nfree_register_overhead(dfilter_t* df)\r\n{\r\nguint i;\r\nfor (i = 0; i < df->num_registers; i++) {\r\ndf->attempted_load[i] = FALSE;\r\nif (df->registers[i]) {\r\ng_list_free(df->registers[i]);\r\ndf->registers[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void\r\nmk_range(dfilter_t *df, int from_reg, int to_reg, drange_t *d_range)\r\n{\r\nGList *from_list, *to_list;\r\nfvalue_t *old_fv, *new_fv;\r\nto_list = NULL;\r\nfrom_list = df->registers[from_reg];\r\nwhile (from_list) {\r\nold_fv = (fvalue_t*)from_list->data;\r\nnew_fv = fvalue_slice(old_fv, d_range);\r\ng_assert(new_fv);\r\nto_list = g_list_append(to_list, new_fv);\r\nfrom_list = g_list_next(from_list);\r\n}\r\ndf->registers[to_reg] = to_list;\r\n}\r\ngboolean\r\ndfvm_apply(dfilter_t *df, proto_tree *tree)\r\n{\r\nint id, length;\r\ngboolean accum = TRUE;\r\ndfvm_insn_t *insn;\r\ndfvm_value_t *arg1;\r\ndfvm_value_t *arg2;\r\ndfvm_value_t *arg3 = NULL;\r\ndfvm_value_t *arg4 = NULL;\r\nheader_field_info *hfinfo;\r\nGList *param1;\r\nGList *param2;\r\ng_assert(tree);\r\nlength = df->insns->len;\r\nfor (id = 0; id < length; id++) {\r\nAGAIN:\r\ninsn = (dfvm_insn_t *)g_ptr_array_index(df->insns, id);\r\narg1 = insn->arg1;\r\narg2 = insn->arg2;\r\nswitch (insn->op) {\r\ncase CHECK_EXISTS:\r\nhfinfo = arg1->value.hfinfo;\r\nwhile(hfinfo) {\r\naccum = proto_check_for_protocol_or_field(tree,\r\nhfinfo->id);\r\nif (accum) {\r\nbreak;\r\n}\r\nelse {\r\nhfinfo = hfinfo->same_name_next;\r\n}\r\n}\r\nbreak;\r\ncase READ_TREE:\r\naccum = read_tree(df, tree,\r\narg1->value.hfinfo, arg2->value.numeric);\r\nbreak;\r\ncase CALL_FUNCTION:\r\narg3 = insn->arg3;\r\narg4 = insn->arg4;\r\nparam1 = NULL;\r\nparam2 = NULL;\r\nif (arg3) {\r\nparam1 = df->registers[arg3->value.numeric];\r\n}\r\nif (arg4) {\r\nparam2 = df->registers[arg4->value.numeric];\r\n}\r\naccum = arg1->value.funcdef->function(param1, param2,\r\n&df->registers[arg2->value.numeric]);\r\nbreak;\r\ncase MK_RANGE:\r\narg3 = insn->arg3;\r\nmk_range(df,\r\narg1->value.numeric, arg2->value.numeric,\r\narg3->value.drange);\r\nbreak;\r\ncase ANY_EQ:\r\naccum = any_test(df, fvalue_eq,\r\narg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_NE:\r\naccum = any_test(df, fvalue_ne,\r\narg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_GT:\r\naccum = any_test(df, fvalue_gt,\r\narg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_GE:\r\naccum = any_test(df, fvalue_ge,\r\narg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_LT:\r\naccum = any_test(df, fvalue_lt,\r\narg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_LE:\r\naccum = any_test(df, fvalue_le,\r\narg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_BITWISE_AND:\r\naccum = any_test(df, fvalue_bitwise_and,\r\narg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_CONTAINS:\r\naccum = any_test(df, fvalue_contains,\r\narg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase ANY_MATCHES:\r\naccum = any_test(df, fvalue_matches,\r\narg1->value.numeric, arg2->value.numeric);\r\nbreak;\r\ncase NOT:\r\naccum = !accum;\r\nbreak;\r\ncase RETURN:\r\nfree_register_overhead(df);\r\nreturn accum;\r\ncase IF_TRUE_GOTO:\r\nif (accum) {\r\nid = arg1->value.numeric;\r\ngoto AGAIN;\r\n}\r\nbreak;\r\ncase IF_FALSE_GOTO:\r\nif (!accum) {\r\nid = arg1->value.numeric;\r\ngoto AGAIN;\r\n}\r\nbreak;\r\ncase PUT_FVALUE:\r\n#if 0\r\naccum = put_fvalue(df,\r\narg1->value.fvalue, arg2->value.numeric);\r\nbreak;\r\n#endif\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\ng_assert_not_reached();\r\nreturn FALSE;\r\n}\r\nvoid\r\ndfvm_init_const(dfilter_t *df)\r\n{\r\nint id, length;\r\ndfvm_insn_t *insn;\r\ndfvm_value_t *arg1;\r\ndfvm_value_t *arg2;\r\nlength = df->consts->len;\r\nfor (id = 0; id < length; id++) {\r\ninsn = (dfvm_insn_t *)g_ptr_array_index(df->consts, id);\r\narg1 = insn->arg1;\r\narg2 = insn->arg2;\r\nswitch (insn->op) {\r\ncase PUT_FVALUE:\r\nput_fvalue(df,\r\narg1->value.fvalue, arg2->value.numeric);\r\nbreak;\r\ncase CHECK_EXISTS:\r\ncase READ_TREE:\r\ncase CALL_FUNCTION:\r\ncase MK_RANGE:\r\ncase ANY_EQ:\r\ncase ANY_NE:\r\ncase ANY_GT:\r\ncase ANY_GE:\r\ncase ANY_LT:\r\ncase ANY_LE:\r\ncase ANY_BITWISE_AND:\r\ncase ANY_CONTAINS:\r\ncase ANY_MATCHES:\r\ncase NOT:\r\ncase RETURN:\r\ncase IF_TRUE_GOTO:\r\ncase IF_FALSE_GOTO:\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\nreturn;\r\n}
