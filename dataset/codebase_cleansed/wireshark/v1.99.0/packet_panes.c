GtkWidget *\r\nget_notebook_bv_ptr(GtkWidget *nb_ptr)\r\n{\r\nint num;\r\nGtkWidget *bv_page;\r\nnum = gtk_notebook_get_current_page(GTK_NOTEBOOK(nb_ptr));\r\nbv_page = gtk_notebook_get_nth_page(GTK_NOTEBOOK(nb_ptr), num);\r\nif (bv_page)\r\nreturn gtk_bin_get_child(GTK_BIN(bv_page));\r\nelse\r\nreturn NULL;\r\n}\r\nconst guint8 *\r\nget_byte_view_data_and_length(GtkWidget *byte_view, guint *data_len)\r\n{\r\ntvbuff_t *byte_view_tvb;\r\nconst guint8 *data_ptr;\r\nbyte_view_tvb = (tvbuff_t *)g_object_get_data(G_OBJECT(byte_view), E_BYTE_VIEW_TVBUFF_KEY);\r\nif (byte_view_tvb == NULL)\r\nreturn NULL;\r\nif ((*data_len = tvb_length(byte_view_tvb))) {\r\ndata_ptr = tvb_get_ptr(byte_view_tvb, 0, -1);\r\nreturn data_ptr;\r\n} else\r\nreturn "";\r\n}\r\nvoid\r\nset_notebook_page(GtkWidget *nb_ptr, tvbuff_t *tvb)\r\n{\r\nint num;\r\nGtkWidget *bv_page, *bv;\r\ntvbuff_t *bv_tvb;\r\nfor (num = 0;\r\n(bv_page = gtk_notebook_get_nth_page(GTK_NOTEBOOK(nb_ptr), num)) != NULL;\r\nnum++) {\r\nbv = gtk_bin_get_child(GTK_BIN(bv_page));\r\nbv_tvb = (tvbuff_t *)g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_TVBUFF_KEY);\r\nif (bv_tvb == tvb) {\r\ngtk_notebook_set_current_page(GTK_NOTEBOOK(nb_ptr), num);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid\r\nredraw_packet_bytes(GtkWidget *nb, frame_data *fd, field_info *finfo)\r\n{\r\nGtkWidget *bv;\r\nconst guint8 *data;\r\nguint len;\r\nbv = get_notebook_bv_ptr(nb);\r\nif (bv != NULL) {\r\ndata = get_byte_view_data_and_length(bv, &len);\r\nif (data != NULL)\r\npacket_hex_print(bv, data, fd, finfo, len);\r\n}\r\n}\r\nvoid\r\nredraw_packet_bytes_all(void)\r\n{\r\nif (cfile.current_frame != NULL)\r\nredraw_packet_bytes( byte_nb_ptr_gbl, cfile.current_frame, cfile.finfo_selected);\r\nredraw_packet_bytes_packet_wins();\r\nif (cfile.current_frame != NULL) {\r\ncfile.current_row = -1;\r\ncf_goto_frame(&cfile, cfile.current_frame->num);\r\n}\r\n}\r\nstatic void\r\ncheck_expand_trees(GtkTreeView *tree_view, GtkTreeModel *model, GtkTreePath *path,\r\nGtkTreeIter *iter, gboolean scroll_it, gboolean expand_parent)\r\n{\r\nfield_info *fi;\r\ndo {\r\nGtkTreeIter child;\r\nif (gtk_tree_model_iter_children(model, &child, iter)) {\r\ngtk_tree_model_get(model, iter, 1, &fi, -1);\r\nif (tree_expanded(fi->tree_type)) {\r\nif (expand_parent)\r\ngtk_tree_view_expand_row(tree_view, path, FALSE);\r\nif (scroll_it)\r\ngtk_tree_view_scroll_to_cell(tree_view, path, NULL, TRUE, (prefs.gui_auto_scroll_percentage/100.0f), 0.0f);\r\ngtk_tree_path_down(path);\r\ncheck_expand_trees(tree_view, model, path, &child, scroll_it, TRUE);\r\ngtk_tree_path_up(path);\r\n}\r\n}\r\ngtk_tree_path_next(path);\r\n} while (gtk_tree_model_iter_next(model, iter));\r\n}\r\nstatic void\r\nexpand_tree(GtkTreeView *tree_view, GtkTreeIter *iter,\r\nGtkTreePath *path, gpointer user_data _U_)\r\n{\r\nfield_info *finfo;\r\nGtkTreeModel *model;\r\nmodel = gtk_tree_view_get_model(tree_view);\r\ngtk_tree_model_get(model, iter, 1, &finfo, -1);\r\ng_assert(finfo);\r\nif(prefs.gui_auto_scroll_on_expand)\r\ngtk_tree_view_scroll_to_cell(tree_view, path, NULL, TRUE, (prefs.gui_auto_scroll_percentage/100.0f), 0.0f);\r\nif (finfo->tree_type != -1)\r\ntree_expanded_set(finfo->tree_type, TRUE);\r\nif (finfo->tree_type != -1 && path) {\r\ng_signal_handlers_block_by_func(tree_view, expand_tree, NULL);\r\ncheck_expand_trees(tree_view, model, path, iter, FALSE, FALSE);\r\ng_signal_handlers_unblock_by_func(tree_view, expand_tree, NULL);\r\n}\r\n}\r\nstatic void\r\ncollapse_tree(GtkTreeView *tree_view, GtkTreeIter *iter,\r\nGtkTreePath *path _U_, gpointer user_data _U_)\r\n{\r\nfield_info *finfo;\r\nGtkTreeModel *model;\r\nmodel = gtk_tree_view_get_model(tree_view);\r\ngtk_tree_model_get(model, iter, 1, &finfo, -1);\r\ng_assert(finfo);\r\nif (finfo->tree_type != -1)\r\ntree_expanded_set(finfo->tree_type, FALSE);\r\n}\r\nstatic gboolean\r\nlookup_finfo(GtkTreeModel *model, GtkTreePath *path _U_, GtkTreeIter *iter,\r\ngpointer data)\r\n{\r\nfield_info *fi;\r\nstruct field_lookup_info *fli = (struct field_lookup_info *)data;\r\ngtk_tree_model_get(model, iter, 1, &fi, -1);\r\nif (fi == fli->fi) {\r\nfli->iter = *iter;\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nGtkTreePath\r\n*tree_find_by_field_info(GtkTreeView *tree_view, field_info *finfo)\r\n{\r\nGtkTreeModel *model;\r\nstruct field_lookup_info fli;\r\ng_assert(finfo != NULL);\r\nmodel = gtk_tree_view_get_model(tree_view);\r\nfli.fi = finfo;\r\ngtk_tree_model_foreach(model, lookup_finfo, &fli);\r\nreturn gtk_tree_model_get_path(model, &fli.iter);\r\n}\r\ngboolean\r\nbyte_view_select(GtkWidget *widget, GdkEventButton *event)\r\n{\r\nproto_tree *tree;\r\nGtkTreeView *tree_view;\r\nint byte = -1;\r\ntvbuff_t *tvb;\r\ntree = (proto_tree *)g_object_get_data(G_OBJECT(widget), E_BYTE_VIEW_TREE_PTR);\r\nif (tree == NULL) {\r\nreturn FALSE;\r\n}\r\ntree_view = GTK_TREE_VIEW(g_object_get_data(G_OBJECT(widget),\r\nE_BYTE_VIEW_TREE_VIEW_PTR));\r\nbyte = bytes_view_byte_from_xy(BYTES_VIEW(widget), (gint) event->x, (gint) event->y);\r\nif (byte == -1) {\r\nreturn FALSE;\r\n}\r\ntvb = (tvbuff_t *)g_object_get_data(G_OBJECT(widget), E_BYTE_VIEW_TVBUFF_KEY);\r\nreturn highlight_field(tvb, byte, tree_view, tree);\r\n}\r\ngboolean\r\nhighlight_field(tvbuff_t *tvb, gint byte, GtkTreeView *tree_view,\r\nproto_tree *tree)\r\n{\r\nGtkTreeModel *model = NULL;\r\nGtkTreePath *first_path = NULL, *path = NULL;\r\nGtkTreeIter parent;\r\nfield_info *finfo = NULL;\r\nmatch_data mdata;\r\nstruct field_lookup_info fli;\r\nif (cfile.search_in_progress && cfile.string && cfile.decode_data) {\r\nif (cf_find_string_protocol_tree(&cfile, tree, &mdata)) {\r\nfinfo = mdata.finfo;\r\n}\r\n} else {\r\nfinfo = proto_find_field_from_offset(tree, byte, tvb);\r\n}\r\nif (!finfo) {\r\nreturn FALSE;\r\n}\r\nmodel = gtk_tree_view_get_model(tree_view);\r\nfli.fi = finfo;\r\ngtk_tree_model_foreach(model, lookup_finfo, &fli);\r\nfirst_path = gtk_tree_model_get_path(model, &fli.iter);\r\ngtk_tree_view_expand_row(tree_view, first_path, FALSE);\r\nexpand_tree(tree_view, &fli.iter, NULL, NULL);\r\nwhile (gtk_tree_model_iter_parent(model, &parent, &fli.iter)) {\r\npath = gtk_tree_model_get_path(model, &parent);\r\ngtk_tree_view_expand_row(tree_view, path, FALSE);\r\nexpand_tree(tree_view, &parent, NULL, NULL);\r\nfli.iter = parent;\r\ngtk_tree_path_free(path);\r\n}\r\ngtk_tree_selection_select_path(gtk_tree_view_get_selection(tree_view),\r\nfirst_path);\r\nif (!cfile.search_in_progress) {\r\nif (cfile.hex || (cfile.string && cfile.packet_data)) {\r\nredraw_packet_bytes(byte_nb_ptr_gbl, cfile.current_frame, cfile.finfo_selected);\r\n}\r\n}\r\ngtk_tree_view_scroll_to_cell(tree_view, first_path, NULL, TRUE, 0.5f, 0.0f);\r\ngtk_tree_path_free(first_path);\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nbyte_view_button_press_cb(GtkWidget *widget, GdkEvent *event, gpointer data)\r\n{\r\nGdkEventButton *event_button = NULL;\r\nif(widget == NULL || event == NULL || data == NULL) {\r\nreturn FALSE;\r\n}\r\nif(event->type == GDK_BUTTON_PRESS) {\r\nevent_button = (GdkEventButton *) event;\r\nswitch(event_button->button) {\r\ncase 1:\r\nreturn byte_view_select(widget, event_button);\r\ncase 3:\r\nreturn popup_menu_handler(widget, event, data);\r\ndefault:\r\nreturn FALSE;\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nGtkWidget *\r\nbyte_view_new(void)\r\n{\r\nGtkWidget *byte_nb;\r\nbyte_nb = gtk_notebook_new();\r\ngtk_notebook_set_tab_pos(GTK_NOTEBOOK(byte_nb), GTK_POS_BOTTOM);\r\ngtk_notebook_set_show_border(GTK_NOTEBOOK(byte_nb), FALSE);\r\ngtk_notebook_set_scrollable(GTK_NOTEBOOK(byte_nb), TRUE);\r\ngtk_notebook_popup_enable(GTK_NOTEBOOK(byte_nb));\r\nadd_byte_tab(byte_nb, "", NULL, NULL, NULL);\r\nreturn byte_nb;\r\n}\r\nstatic void\r\nbyte_view_realize_cb(GtkWidget *bv, gpointer data _U_)\r\n{\r\nconst guint8 *byte_data;\r\nguint byte_len;\r\nbyte_data = get_byte_view_data_and_length(bv, &byte_len);\r\nif (byte_data == NULL) {\r\nreturn;\r\n}\r\npacket_hex_print(bv, byte_data, cfile.current_frame, NULL, byte_len);\r\n}\r\nGtkWidget *\r\nadd_byte_tab(GtkWidget *byte_nb, const char *name, tvbuff_t *tvb,\r\nproto_tree *tree, GtkWidget *tree_view)\r\n{\r\nGtkWidget *byte_view, *byte_scrollw, *label;\r\nbyte_scrollw = scrolled_window_new(NULL, NULL);\r\ngtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(byte_scrollw),\r\nGTK_SHADOW_IN);\r\nlabel = gtk_label_new(name);\r\ngtk_notebook_append_page(GTK_NOTEBOOK(byte_nb), byte_scrollw, label);\r\ngtk_widget_show(byte_scrollw);\r\nbyte_view = bytes_view_new();\r\nbytes_view_set_font(BYTES_VIEW(byte_view), user_font_get_regular());\r\ng_object_set_data(G_OBJECT(byte_view), E_BYTE_VIEW_TVBUFF_KEY, tvb);\r\ngtk_container_add(GTK_CONTAINER(byte_scrollw), byte_view);\r\ng_signal_connect(byte_view, "show", G_CALLBACK(byte_view_realize_cb), NULL);\r\ng_signal_connect(byte_view, "button_press_event", G_CALLBACK(byte_view_button_press_cb),\r\ng_object_get_data(G_OBJECT(popup_menu_object), PM_BYTES_VIEW_KEY));\r\ng_object_set_data(G_OBJECT(byte_view), E_BYTE_VIEW_TREE_PTR, tree);\r\ng_object_set_data(G_OBJECT(byte_view), E_BYTE_VIEW_TREE_VIEW_PTR, tree_view);\r\ngtk_widget_show(byte_view);\r\nif (!(gtk_notebook_page_num(GTK_NOTEBOOK(byte_nb), byte_scrollw)))\r\ngtk_notebook_set_show_tabs(GTK_NOTEBOOK(byte_nb), FALSE);\r\nelse\r\ngtk_notebook_set_show_tabs(GTK_NOTEBOOK(byte_nb), TRUE);\r\ngtk_notebook_set_current_page(GTK_NOTEBOOK(byte_nb),\r\ngtk_notebook_page_num(GTK_NOTEBOOK(byte_nb), byte_nb));\r\nreturn byte_view;\r\n}\r\nvoid\r\nadd_byte_views(epan_dissect_t *edt, GtkWidget *tree_view,\r\nGtkWidget *byte_nb_ptr)\r\n{\r\nGSList *src_le;\r\nstruct data_source *src;\r\nwhile (gtk_notebook_get_nth_page(GTK_NOTEBOOK(byte_nb_ptr), 0) != NULL)\r\ngtk_notebook_remove_page(GTK_NOTEBOOK(byte_nb_ptr), 0);\r\nfor (src_le = edt->pi.data_src; src_le != NULL; src_le = src_le->next) {\r\nsrc = (struct data_source *)src_le->data;\r\nadd_byte_tab(byte_nb_ptr, get_data_source_name(src), get_data_source_tvb(src), edt->tree,\r\ntree_view);\r\n}\r\ngtk_notebook_set_current_page(GTK_NOTEBOOK(byte_nb_ptr), 0);\r\n}\r\nstatic void\r\ncopy_hex_all_info(GString* copy_buffer, const guint8* data_p, int data_len, gboolean append_text)\r\n{\r\nconst int byte_line_length = 16;\r\nint i, j;\r\ngboolean end_of_line = TRUE;\r\nint byte_line_part_length;\r\nGString* hex_str;\r\nGString* char_str;\r\nhex_str = g_string_new("");\r\nchar_str= g_string_new("");\r\ni = 0;\r\nwhile (i<data_len) {\r\nif(end_of_line) {\r\ng_string_append_printf(hex_str,"%04x ",i);\r\n}\r\ng_string_append_printf(hex_str," %02x",*data_p);\r\nif(append_text) {\r\ng_string_append_printf(char_str,"%c",g_ascii_isprint(*data_p) ? *data_p : '.');\r\n}\r\n++data_p;\r\nbyte_line_part_length = (++i) % byte_line_length;\r\nif(i == data_len){\r\nfor(j = 0; append_text && (j < (byte_line_length - byte_line_part_length)); ++j) {\r\ng_string_append(hex_str," ");\r\n}\r\nend_of_line = TRUE;\r\n} else {\r\nend_of_line = (byte_line_part_length == 0 ? TRUE : FALSE);\r\n}\r\nif (end_of_line){\r\ng_string_append(copy_buffer, hex_str->str);\r\nif(append_text) {\r\ng_string_append_c(copy_buffer, ' ');\r\ng_string_append_c(copy_buffer, ' ');\r\ng_string_append(copy_buffer, char_str->str);\r\n}\r\ng_string_assign(char_str,"");\r\ng_string_assign(hex_str, "\n");\r\n}\r\n}\r\ng_string_free(hex_str, TRUE);\r\ng_string_free(char_str, TRUE);\r\n}\r\nstatic int\r\ncopy_hex_bytes_text_only(GString* copy_buffer, const guint8* data_p, int data_len _U_)\r\n{\r\ngchar to_append;\r\nif(g_ascii_isprint(*data_p)) {\r\nto_append = *data_p;\r\n} else if(*data_p==0x0a) {\r\nto_append = '\n';\r\n} else if(*data_p==0x09) {\r\nto_append = '\t';\r\n} else {\r\nreturn 1;\r\n}\r\ng_string_append_c(copy_buffer,to_append);\r\nreturn 1;\r\n}\r\nstatic\r\nint copy_hex_bytes_hex(GString* copy_buffer, const guint8* data_p, int data_len _U_)\r\n{\r\ng_string_append_printf(copy_buffer, "%02x", *data_p);\r\nreturn 1;\r\n}\r\nvoid\r\ncopy_hex_cb(GtkWidget * w _U_, gpointer data _U_, copy_data_type data_type)\r\n{\r\nGtkWidget *bv;\r\nguint len = 0;\r\nint bytes_consumed = 0;\r\nint flags;\r\nconst guint8* data_p;\r\nGString* copy_buffer = g_string_new("");\r\nbv = get_notebook_bv_ptr(byte_nb_ptr_gbl);\r\nif (bv == NULL) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "Could not find the corresponding text window.");\r\nreturn;\r\n}\r\ndata_p = get_byte_view_data_and_length(bv, &len);\r\ng_assert(data_p != NULL);\r\nflags = data_type & CD_FLAGSMASK;\r\ndata_type = (copy_data_type)(data_type & CD_TYPEMASK);\r\nif(flags & CD_FLAGS_SELECTEDONLY) {\r\nint start, end;\r\nstart = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_START_KEY));\r\nend = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_END_KEY));\r\nif(start >= 0 && end > start && (end - start <= (int)len)) {\r\nlen = end - start;\r\ndata_p += start;\r\n}\r\n}\r\nswitch(data_type) {\r\ncase(CD_ALLINFO):\r\ncopy_hex_all_info(copy_buffer, data_p, len, TRUE);\r\nbreak;\r\ncase(CD_HEXCOLUMNS):\r\ncopy_hex_all_info(copy_buffer, data_p, len, FALSE);\r\nbreak;\r\ncase(CD_BINARY):\r\ncopy_binary_to_clipboard(data_p,len);\r\nbreak;\r\ndefault:\r\nwhile (len > 0){\r\nswitch(data_type) {\r\ncase (CD_TEXTONLY):\r\nbytes_consumed = copy_hex_bytes_text_only(copy_buffer, data_p, len);\r\nbreak;\r\ncase (CD_HEX):\r\nbytes_consumed = copy_hex_bytes_hex(copy_buffer, data_p, len);\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\ng_assert(bytes_consumed>0);\r\ndata_p += bytes_consumed;\r\nlen -= bytes_consumed;\r\n}\r\nbreak;\r\n}\r\nif(copy_buffer->len > 0) {\r\ncopy_to_clipboard(copy_buffer);\r\n}\r\ng_string_free(copy_buffer, TRUE);\r\n}\r\nstatic gboolean\r\nsavehex_save_clicked_cb(gchar *file, int start, int end, const guint8 *data_p)\r\n{\r\nint fd;\r\nfd = ws_open(file, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0666);\r\nif (fd == -1) {\r\nopen_failure_alert_box(file, errno, TRUE);\r\nreturn FALSE;\r\n}\r\nif (ws_write(fd, data_p + start, end - start) < 0) {\r\nwrite_failure_alert_box(file, errno);\r\nws_close(fd);\r\nreturn FALSE;\r\n}\r\nif (ws_close(fd) < 0) {\r\nwrite_failure_alert_box(file, errno);\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\nsavehex_cb(GtkWidget * w _U_, gpointer data _U_)\r\n{\r\nwin32_export_raw_file(GDK_WINDOW_HWND(gtk_widget_get_window(top_level)), &cfile);\r\nreturn;\r\n}\r\nstatic char *\r\ngtk_export_raw_file(int start, int end)\r\n{\r\nGtkWidget *savehex_dlg;\r\ngchar *label;\r\nGtkWidget *dlg_lb;\r\nchar *pathname;\r\nsavehex_dlg = file_selection_new("Wireshark: Export Selected Packet Bytes", GTK_WINDOW(top_level), FILE_SELECTION_SAVE);\r\nlabel = g_strdup_printf("Will save %u %s of raw binary data to specified file.",\r\nend - start, plurality(end - start, "byte", "bytes"));\r\ndlg_lb = gtk_label_new(label);\r\ng_free(label);\r\nfile_selection_set_extra_widget(savehex_dlg, dlg_lb);\r\ngtk_widget_show(dlg_lb);\r\npathname = file_selection_run(savehex_dlg);\r\nif (pathname == NULL) {\r\nreturn NULL;\r\n}\r\nwindow_destroy(savehex_dlg);\r\nreturn pathname;\r\n}\r\nvoid\r\nsavehex_cb(GtkWidget * w _U_, gpointer data _U_)\r\n{\r\nint start, end;\r\nguint len;\r\nconst guint8 *data_p = NULL;\r\nGtkWidget *bv;\r\nchar *pathname;\r\nbv = get_notebook_bv_ptr(byte_nb_ptr_gbl);\r\nif (bv == NULL) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "Could not find the corresponding text window.");\r\nreturn;\r\n}\r\nstart = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_START_KEY));\r\nend = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_END_KEY));\r\ndata_p = get_byte_view_data_and_length(bv, &len);\r\nif (data_p == NULL || start == -1 || start > end) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "No data selected to save.");\r\nreturn;\r\n}\r\nfor (;;) {\r\npathname = gtk_export_raw_file(start, end);\r\nif (pathname == NULL) {\r\nbreak;\r\n}\r\nif (savehex_save_clicked_cb(pathname, start, end, data_p)) {\r\ng_free(pathname);\r\nbreak;\r\n}\r\ng_free(pathname);\r\n}\r\n}\r\nstatic void\r\npacket_hex_update(GtkWidget *bv, const guint8 *pd, int len, int bstart,\r\nint bend, guint32 bmask, int bmask_le,\r\nint astart, int aend,\r\nint pstart, int pend,\r\nint encoding)\r\n{\r\nbytes_view_set_encoding(BYTES_VIEW(bv), encoding);\r\nbytes_view_set_format(BYTES_VIEW(bv), recent.gui_bytes_view);\r\nbytes_view_set_data(BYTES_VIEW(bv), pd, len);\r\nbytes_view_set_highlight_style(BYTES_VIEW(bv), prefs.gui_hex_dump_highlight_style);\r\nbytes_view_set_highlight(BYTES_VIEW(bv), bstart, bend, bmask, bmask_le);\r\nbytes_view_set_highlight_extra(BYTES_VIEW(bv), BYTE_VIEW_HIGHLIGHT_APPENDIX, astart, aend);\r\nbytes_view_set_highlight_extra(BYTES_VIEW(bv), BYTE_VIEW_HIGHLIGHT_PROTOCOL, pstart, pend);\r\nif (bstart != -1 && bend != -1)\r\nbytes_view_scroll_to_byte(BYTES_VIEW(bv), bstart);\r\nbytes_view_refresh(BYTES_VIEW(bv));\r\n}\r\nstatic field_info *\r\nget_top_finfo(proto_node *node, field_info *finfo)\r\n{\r\nproto_node *child;\r\nfield_info *top;\r\nif (node == NULL)\r\nreturn NULL;\r\nif (PNODE_FINFO(node) == finfo) {\r\ntop = finfo;\r\nwhile (node && node->parent) {\r\nfield_info *fi;\r\nnode = node->parent;\r\nfi = PNODE_FINFO(node);\r\nif (fi && fi->ds_tvb == finfo->ds_tvb)\r\ntop = fi;\r\n}\r\nreturn top;\r\n}\r\nfor (child = node->first_child; child; child = child->next) {\r\ntop = get_top_finfo(child, finfo);\r\nif (top)\r\nreturn top;\r\n}\r\nreturn NULL;\r\n}\r\nvoid\r\npacket_hex_print(GtkWidget *bv, const guint8 *pd, frame_data *fd,\r\nfield_info *finfo, guint len)\r\n{\r\nint bstart = -1, bend = -1, blen = -1;\r\nguint32 bmask = 0x00; int bmask_le = 0;\r\nint astart = -1, aend = -1, alen = -1;\r\nint pstart = -1, pend = -1, plen = -1;\r\nif (finfo != NULL) {\r\nproto_tree *tree = (proto_tree *)g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_TREE_PTR);\r\nfield_info *top_finfo;\r\nif (cfile.search_in_progress && (cfile.hex || (cfile.string && cfile.packet_data))) {\r\nif (cfile.hex) {\r\nchar *p = cfile.sfilter;\r\nblen = 0;\r\nwhile (*p) {\r\nif (g_ascii_isxdigit(*p++))\r\nblen++;\r\n}\r\nblen = (blen + 1) / 2;\r\n} else {\r\nblen = (int)strlen(cfile.sfilter);\r\n}\r\nbstart = cfile.search_pos - (blen-1);\r\n} else {\r\nblen = finfo->length;\r\nbstart = finfo->start;\r\n}\r\nif (finfo->hfinfo) bmask = finfo->hfinfo->bitmask;\r\nastart = finfo->appendix_start;\r\nalen = finfo->appendix_length;\r\ntop_finfo = get_top_finfo(tree, finfo);\r\nif (top_finfo) {\r\npstart = top_finfo->start;\r\nplen = top_finfo->length;\r\n}\r\nif (FI_GET_FLAG(finfo, FI_LITTLE_ENDIAN))\r\nbmask_le = 1;\r\nelse if (FI_GET_FLAG(finfo, FI_BIG_ENDIAN))\r\nbmask_le = 0;\r\nelse {\r\nbmask = 0x00;\r\n}\r\nif (bmask == 0x00) {\r\nint bito = FI_GET_BITS_OFFSET(finfo);\r\nint bitc = FI_GET_BITS_SIZE(finfo);\r\nint bitt = bito + bitc;\r\nif (bitt > 0 && bitt < 32) {\r\nbmask = ((1 << bitc) - 1) << ((8-bitt) & 7);\r\nbmask_le = 0;\r\n}\r\n}\r\n}\r\nif (pstart >= 0 && plen > 0 && (guint)pstart < len)\r\npend = pstart + plen;\r\nif (bstart >= 0 && blen > 0 && (guint)bstart < len)\r\nbend = bstart + blen;\r\nif (astart >= 0 && alen > 0 && (guint)astart < len)\r\naend = astart + alen;\r\nif (bend == -1 && aend != -1) {\r\nbstart = astart;\r\nbmask = 0x00;\r\nbend = aend;\r\nastart = aend = -1;\r\n}\r\nif (aend != -1 && (guint)aend > len) aend = len;\r\nif (bend != -1 && (guint)bend > len) bend = len;\r\nif (pend != -1 && (guint)pend > len) pend = len;\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_START_KEY, GINT_TO_POINTER(bstart));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_END_KEY, GINT_TO_POINTER(bend));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_MASK_KEY, GINT_TO_POINTER(bmask));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_MASKLE_KEY, GINT_TO_POINTER(bmask_le));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_APP_START_KEY, GINT_TO_POINTER(astart));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_APP_END_KEY, GINT_TO_POINTER(aend));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_PROTO_START_KEY, GINT_TO_POINTER(pstart));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_PROTO_END_KEY, GINT_TO_POINTER(pend));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_ENCODE_KEY,\r\nGUINT_TO_POINTER((guint)fd->flags.encoding));\r\nif (recent.gui_bytes_view != BYTES_BITS)\r\nbmask = 0x00;\r\npacket_hex_update(bv, pd, len, bstart, bend, bmask, bmask_le, astart, aend, pstart, pend, fd->flags.encoding);\r\n}\r\nvoid\r\npacket_hex_editor_print(GtkWidget *bv, const guint8 *pd, frame_data *fd, int offset, int bitoffset, guint len)\r\n{\r\nint bstart = offset, bend = (bstart != -1) ? offset+1 : -1;\r\nguint32 bmask=0; int bmask_le = 0;\r\nint astart = -1, aend = -1;\r\nint pstart = -1, pend = -1;\r\nswitch (recent.gui_bytes_view) {\r\ncase BYTES_HEX:\r\nbmask = (bitoffset == 0) ? 0xf0 : (bitoffset == 4) ? 0x0f : 0xff;\r\nbreak;\r\ncase BYTES_BITS:\r\nbmask = (1 << (7-bitoffset));\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_START_KEY, GINT_TO_POINTER(bstart));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_END_KEY, GINT_TO_POINTER(bend));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_MASK_KEY, GINT_TO_POINTER(bmask));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_MASKLE_KEY, GINT_TO_POINTER(bmask_le));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_APP_START_KEY, GINT_TO_POINTER(astart));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_APP_END_KEY, GINT_TO_POINTER(aend));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_ENCODE_KEY,\r\nGUINT_TO_POINTER((guint)fd->flags.encoding));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_PROTO_START_KEY, GINT_TO_POINTER(pstart));\r\ng_object_set_data(G_OBJECT(bv), E_BYTE_VIEW_PROTO_END_KEY, GINT_TO_POINTER(pend));\r\npacket_hex_update(bv, pd, len, bstart, bend, bmask, bmask_le, astart, aend, pstart, pend, fd->flags.encoding);\r\n}\r\nvoid\r\npacket_hex_reprint(GtkWidget *bv)\r\n{\r\nint start, end, mask, mask_le, encoding;\r\nint astart, aend;\r\nint pstart, pend;\r\nconst guint8 *data;\r\nguint len = 0;\r\nstart = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_START_KEY));\r\nend = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_END_KEY));\r\nmask = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_MASK_KEY));\r\nmask_le = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_MASKLE_KEY));\r\nastart = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_APP_START_KEY));\r\naend = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_APP_END_KEY));\r\npstart = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_PROTO_START_KEY));\r\npend = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_PROTO_END_KEY));\r\ndata = get_byte_view_data_and_length(bv, &len);\r\ng_assert(data != NULL);\r\nencoding = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(bv), E_BYTE_VIEW_ENCODE_KEY));\r\nif (recent.gui_bytes_view != BYTES_BITS)\r\nmask = 0x00;\r\npacket_hex_update(bv, data, len, start, end, mask, mask_le, astart, aend, pstart, pend, encoding);\r\n}\r\nstatic void\r\nremember_ptree_widget(GtkWidget *ptreew)\r\n{\r\nptree_widgets = g_list_append(ptree_widgets, ptreew);\r\ng_signal_connect(ptreew, "destroy", G_CALLBACK(forget_ptree_widget), NULL);\r\n}\r\nstatic void\r\nforget_ptree_widget(GtkWidget *ptreew, gpointer data _U_)\r\n{\r\nptree_widgets = g_list_remove(ptree_widgets, ptreew);\r\n}\r\nstatic void\r\nset_ptree_font_cb(gpointer data, gpointer user_data)\r\n{\r\n#if GTK_CHECK_VERSION(3,0,0)\r\ngtk_widget_override_font((GtkWidget *)data,\r\n(PangoFontDescription *)user_data);\r\n#else\r\ngtk_widget_modify_font((GtkWidget *)data,\r\n(PangoFontDescription *)user_data);\r\n#endif\r\n}\r\nvoid\r\nset_ptree_font_all(PangoFontDescription *font)\r\n{\r\ng_list_foreach(ptree_widgets, set_ptree_font_cb, font);\r\n}\r\nvoid proto_draw_colors_init(void)\r\n{\r\nif(colors_ok) {\r\nreturn;\r\n}\r\n#if 0\r\nget_color(&expert_color_chat);\r\nget_color(&expert_color_note);\r\nget_color(&expert_color_warn);\r\nget_color(&expert_color_error);\r\nget_color(&expert_color_foreground);\r\n#endif\r\nexpert_color_comment_str = gdk_color_to_string(&expert_color_comment);\r\nexpert_color_chat_str = gdk_color_to_string(&expert_color_chat);\r\nexpert_color_note_str = gdk_color_to_string(&expert_color_note);\r\nexpert_color_warn_str = gdk_color_to_string(&expert_color_warn);\r\nexpert_color_error_str = gdk_color_to_string(&expert_color_error);\r\nexpert_color_foreground_str = gdk_color_to_string(&expert_color_foreground);\r\n#if 0\r\nget_color(&hidden_proto_item);\r\n#endif\r\ncolors_ok = TRUE;\r\n}\r\nstatic void\r\ntree_cell_renderer(GtkTreeViewColumn *tree_column _U_, GtkCellRenderer *cell,\r\nGtkTreeModel *tree_model, GtkTreeIter *iter,\r\ngpointer data _U_)\r\n{\r\nfield_info *fi;\r\ngtk_tree_model_get(tree_model, iter, 1, &fi, -1);\r\nif(!colors_ok) {\r\nproto_draw_colors_init();\r\n}\r\ng_object_set (cell, "foreground-set", FALSE, NULL);\r\ng_object_set (cell, "background-set", FALSE, NULL);\r\ng_object_set (cell, "underline", PANGO_UNDERLINE_NONE, NULL);\r\ng_object_set (cell, "underline-set", FALSE, NULL);\r\nif(FI_GET_FLAG(fi, FI_GENERATED)) {\r\n}\r\nif(FI_GET_FLAG(fi, FI_HIDDEN)) {\r\ng_object_set (cell, "foreground-gdk", &hidden_proto_item, NULL);\r\ng_object_set (cell, "foreground-set", TRUE, NULL);\r\n}\r\nif (fi && fi->hfinfo) {\r\nif(fi->hfinfo->type == FT_PROTOCOL) {\r\ng_object_set (cell, "background", "gray90", NULL);\r\ng_object_set (cell, "background-set", TRUE, NULL);\r\ng_object_set (cell, "foreground", "black", NULL);\r\ng_object_set (cell, "foreground-set", TRUE, NULL);\r\n}\r\nif((fi->hfinfo->type == FT_FRAMENUM) ||\r\n(FI_GET_FLAG(fi, FI_URL) && IS_FT_STRING(fi->hfinfo->type))) {\r\nrender_as_url(cell);\r\n}\r\n}\r\nif(FI_GET_FLAG(fi, PI_SEVERITY_MASK)) {\r\nswitch(FI_GET_FLAG(fi, PI_SEVERITY_MASK)) {\r\ncase(PI_COMMENT):\r\ng_object_set (cell, "background-gdk", &expert_color_comment, NULL);\r\ng_object_set (cell, "background-set", TRUE, NULL);\r\nbreak;\r\ncase(PI_CHAT):\r\ng_object_set (cell, "background-gdk", &expert_color_chat, NULL);\r\ng_object_set (cell, "background-set", TRUE, NULL);\r\nbreak;\r\ncase(PI_NOTE):\r\ng_object_set (cell, "background-gdk", &expert_color_note, NULL);\r\ng_object_set (cell, "background-set", TRUE, NULL);\r\nbreak;\r\ncase(PI_WARN):\r\ng_object_set (cell, "background-gdk", &expert_color_warn, NULL);\r\ng_object_set (cell, "background-set", TRUE, NULL);\r\nbreak;\r\ncase(PI_ERROR):\r\ng_object_set (cell, "background-gdk", &expert_color_error, NULL);\r\ng_object_set (cell, "background-set", TRUE, NULL);\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\n}\r\ng_object_set (cell, "foreground", "black", NULL);\r\ng_object_set (cell, "foreground-set", TRUE, NULL);\r\n}\r\n}\r\nGtkWidget *\r\nproto_tree_view_new(GtkWidget **tree_view_p)\r\n{\r\nGtkWidget *tv_scrollw, *tree_view;\r\nProtoTreeModel *store;\r\nGtkCellRenderer *renderer;\r\nGtkTreeViewColumn *column;\r\ngint col_offset;\r\ntv_scrollw = scrolled_window_new(NULL, NULL);\r\ngtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(tv_scrollw),\r\nGTK_SHADOW_IN);\r\nstore = proto_tree_model_new(NULL, prefs.display_hidden_proto_items);\r\ntree_view = tree_view_new(GTK_TREE_MODEL(store));\r\ng_object_unref(G_OBJECT(store));\r\ngtk_tree_view_set_headers_visible(GTK_TREE_VIEW(tree_view), FALSE);\r\nrenderer = gtk_cell_renderer_text_new();\r\ng_object_set (renderer, "ypad", 0, NULL);\r\ncol_offset = gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(tree_view),\r\n-1, "Name", renderer,\r\n"text", 0, NULL);\r\ncolumn = gtk_tree_view_get_column(GTK_TREE_VIEW(tree_view),\r\ncol_offset - 1);\r\ngtk_tree_view_column_set_cell_data_func(column, renderer, tree_cell_renderer,\r\nNULL, NULL);\r\ngtk_tree_view_column_set_sizing(GTK_TREE_VIEW_COLUMN(column),\r\nGTK_TREE_VIEW_COLUMN_AUTOSIZE);\r\ng_signal_connect(tree_view, "row-expanded", G_CALLBACK(expand_tree), NULL);\r\ng_signal_connect(tree_view, "row-collapsed", G_CALLBACK(collapse_tree), NULL);\r\ngtk_container_add( GTK_CONTAINER(tv_scrollw), tree_view );\r\n#if GTK_CHECK_VERSION(3,0,0)\r\ngtk_widget_override_font(tree_view, user_font_get_regular());\r\n#else\r\ngtk_widget_modify_font(tree_view, user_font_get_regular());\r\n#endif\r\nremember_ptree_widget(tree_view);\r\n*tree_view_p = tree_view;\r\nreturn tv_scrollw;\r\n}\r\nvoid\r\nexpand_all_tree(proto_tree *protocol_tree _U_, GtkWidget *tree_view)\r\n{\r\nint i;\r\nfor(i=0; i < num_tree_types; i++)\r\ntree_expanded_set(i, TRUE);\r\ngtk_tree_view_expand_all(GTK_TREE_VIEW(tree_view));\r\n}\r\nvoid\r\ncollapse_all_tree(proto_tree *protocol_tree _U_, GtkWidget *tree_view)\r\n{\r\nint i;\r\nfor(i=0; i < num_tree_types; i++)\r\ntree_expanded_set(i, FALSE);\r\ngtk_tree_view_collapse_all(GTK_TREE_VIEW(tree_view));\r\n}\r\nstatic void\r\ntree_view_follow_link(field_info *fi)\r\n{\r\ngchar *url;\r\nif(fi->hfinfo->type == FT_FRAMENUM) {\r\ncf_goto_frame(&cfile, fi->value.value.uinteger);\r\n}\r\nif(FI_GET_FLAG(fi, FI_URL) && IS_FT_STRING(fi->hfinfo->type)) {\r\nurl = fvalue_to_string_repr(&fi->value, FTREPR_DISPLAY, NULL);\r\nif(url){\r\nbrowser_open_url(url);\r\ng_free(url);\r\n}\r\n}\r\n}\r\ngboolean\r\ntree_view_select(GtkWidget *widget, GdkEventButton *event)\r\n{\r\nGtkTreeSelection *sel;\r\nGtkTreePath *path;\r\nif (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(widget),\r\n(gint) (((GdkEventButton *)event)->x),\r\n(gint) (((GdkEventButton *)event)->y),\r\n&path, NULL, NULL, NULL))\r\n{\r\nsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(widget));\r\nif(event->type == GDK_2BUTTON_PRESS) {\r\nGtkTreeModel *model;\r\nGtkTreeIter iter;\r\nfield_info *fi;\r\nif(gtk_tree_selection_get_selected (sel, &model, &iter)) {\r\nif (event->state & GDK_SHIFT_MASK) {\r\nnew_packet_window(NULL, TRUE, FALSE);\r\n}\r\nelse {\r\ngtk_tree_model_get(model, &iter, 1, &fi, -1);\r\ntree_view_follow_link(fi);\r\n}\r\n}\r\n}\r\nelse if (((GdkEventButton *)event)->button != 1) {\r\ngtk_tree_selection_select_path(sel, path);\r\n}\r\n} else {\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\nproto_tree_draw_resolve(proto_tree *protocol_tree, GtkWidget *tree_view, const e_addr_resolve *resolv)\r\n{\r\nProtoTreeModel *model;\r\nGtkTreePath *path;\r\nGtkTreeIter iter;\r\nmodel = proto_tree_model_new(protocol_tree, prefs.display_hidden_proto_items);\r\nif (resolv)\r\nproto_tree_model_force_resolv(PROTO_TREE_MODEL(model), resolv);\r\ngtk_tree_view_set_model(GTK_TREE_VIEW(tree_view), GTK_TREE_MODEL(model));\r\ng_signal_handlers_block_by_func(tree_view, expand_tree, NULL);\r\npath = gtk_tree_path_new_first();\r\nif (gtk_tree_model_get_iter(GTK_TREE_MODEL(model), &iter, path))\r\ncheck_expand_trees(GTK_TREE_VIEW(tree_view), GTK_TREE_MODEL(model),\r\npath, &iter, prefs.gui_auto_scroll_on_expand, TRUE);\r\ngtk_tree_path_free(path);\r\ng_signal_handlers_unblock_by_func(tree_view, expand_tree, NULL);\r\ng_object_unref(G_OBJECT(model));\r\n}\r\nvoid\r\nproto_tree_draw(proto_tree *protocol_tree, GtkWidget *tree_view)\r\n{\r\nproto_tree_draw_resolve(protocol_tree, tree_view, NULL);\r\n}\r\nvoid\r\nselect_bytes_view (GtkWidget *w _U_, gpointer data _U_, gint view)\r\n{\r\nif (recent.gui_bytes_view != view) {\r\nrecent.gui_bytes_view = view;\r\nredraw_packet_bytes_all();\r\n}\r\n}
