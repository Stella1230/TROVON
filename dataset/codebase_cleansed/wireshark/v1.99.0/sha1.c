void sha1_starts( sha1_context *ctx )\r\n{\r\nctx->total[0] = 0;\r\nctx->total[1] = 0;\r\nctx->state[0] = 0x67452301;\r\nctx->state[1] = 0xEFCDAB89;\r\nctx->state[2] = 0x98BADCFE;\r\nctx->state[3] = 0x10325476;\r\nctx->state[4] = 0xC3D2E1F0;\r\n}\r\nstatic void sha1_process( sha1_context *ctx, const guint8 data[64] )\r\n{\r\nguint32 temp, W[16], A, B, C, D, E;\r\nGET_UINT32( W[0], data, 0 );\r\nGET_UINT32( W[1], data, 4 );\r\nGET_UINT32( W[2], data, 8 );\r\nGET_UINT32( W[3], data, 12 );\r\nGET_UINT32( W[4], data, 16 );\r\nGET_UINT32( W[5], data, 20 );\r\nGET_UINT32( W[6], data, 24 );\r\nGET_UINT32( W[7], data, 28 );\r\nGET_UINT32( W[8], data, 32 );\r\nGET_UINT32( W[9], data, 36 );\r\nGET_UINT32( W[10], data, 40 );\r\nGET_UINT32( W[11], data, 44 );\r\nGET_UINT32( W[12], data, 48 );\r\nGET_UINT32( W[13], data, 52 );\r\nGET_UINT32( W[14], data, 56 );\r\nGET_UINT32( W[15], data, 60 );\r\n#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))\r\n#define R(t) \\r\n( \\r\ntemp = W[(t - 3) & 0x0F] ^ W[(t - 8) & 0x0F] ^ \\r\nW[(t - 14) & 0x0F] ^ W[ t & 0x0F], \\r\n( W[t & 0x0F] = S(temp,1) ) \\r\n)\r\n#define P(a,b,c,d,e,x) \\r\n{ \\r\ne += S(a,5) + F(b,c,d) + K + x; b = S(b,30); \\r\n}\r\nA = ctx->state[0];\r\nB = ctx->state[1];\r\nC = ctx->state[2];\r\nD = ctx->state[3];\r\nE = ctx->state[4];\r\n#define F(x,y,z) (z ^ (x & (y ^ z)))\r\n#define K 0x5A827999\r\nP( A, B, C, D, E, W[0] );\r\nP( E, A, B, C, D, W[1] );\r\nP( D, E, A, B, C, W[2] );\r\nP( C, D, E, A, B, W[3] );\r\nP( B, C, D, E, A, W[4] );\r\nP( A, B, C, D, E, W[5] );\r\nP( E, A, B, C, D, W[6] );\r\nP( D, E, A, B, C, W[7] );\r\nP( C, D, E, A, B, W[8] );\r\nP( B, C, D, E, A, W[9] );\r\nP( A, B, C, D, E, W[10] );\r\nP( E, A, B, C, D, W[11] );\r\nP( D, E, A, B, C, W[12] );\r\nP( C, D, E, A, B, W[13] );\r\nP( B, C, D, E, A, W[14] );\r\nP( A, B, C, D, E, W[15] );\r\nP( E, A, B, C, D, R(16) );\r\nP( D, E, A, B, C, R(17) );\r\nP( C, D, E, A, B, R(18) );\r\nP( B, C, D, E, A, R(19) );\r\n#undef K\r\n#undef F\r\n#define F(x,y,z) (x ^ y ^ z)\r\n#define K 0x6ED9EBA1\r\nP( A, B, C, D, E, R(20) );\r\nP( E, A, B, C, D, R(21) );\r\nP( D, E, A, B, C, R(22) );\r\nP( C, D, E, A, B, R(23) );\r\nP( B, C, D, E, A, R(24) );\r\nP( A, B, C, D, E, R(25) );\r\nP( E, A, B, C, D, R(26) );\r\nP( D, E, A, B, C, R(27) );\r\nP( C, D, E, A, B, R(28) );\r\nP( B, C, D, E, A, R(29) );\r\nP( A, B, C, D, E, R(30) );\r\nP( E, A, B, C, D, R(31) );\r\nP( D, E, A, B, C, R(32) );\r\nP( C, D, E, A, B, R(33) );\r\nP( B, C, D, E, A, R(34) );\r\nP( A, B, C, D, E, R(35) );\r\nP( E, A, B, C, D, R(36) );\r\nP( D, E, A, B, C, R(37) );\r\nP( C, D, E, A, B, R(38) );\r\nP( B, C, D, E, A, R(39) );\r\n#undef K\r\n#undef F\r\n#define F(x,y,z) ((x & y) | (z & (x | y)))\r\n#define K 0x8F1BBCDC\r\nP( A, B, C, D, E, R(40) );\r\nP( E, A, B, C, D, R(41) );\r\nP( D, E, A, B, C, R(42) );\r\nP( C, D, E, A, B, R(43) );\r\nP( B, C, D, E, A, R(44) );\r\nP( A, B, C, D, E, R(45) );\r\nP( E, A, B, C, D, R(46) );\r\nP( D, E, A, B, C, R(47) );\r\nP( C, D, E, A, B, R(48) );\r\nP( B, C, D, E, A, R(49) );\r\nP( A, B, C, D, E, R(50) );\r\nP( E, A, B, C, D, R(51) );\r\nP( D, E, A, B, C, R(52) );\r\nP( C, D, E, A, B, R(53) );\r\nP( B, C, D, E, A, R(54) );\r\nP( A, B, C, D, E, R(55) );\r\nP( E, A, B, C, D, R(56) );\r\nP( D, E, A, B, C, R(57) );\r\nP( C, D, E, A, B, R(58) );\r\nP( B, C, D, E, A, R(59) );\r\n#undef K\r\n#undef F\r\n#define F(x,y,z) (x ^ y ^ z)\r\n#define K 0xCA62C1D6\r\nP( A, B, C, D, E, R(60) );\r\nP( E, A, B, C, D, R(61) );\r\nP( D, E, A, B, C, R(62) );\r\nP( C, D, E, A, B, R(63) );\r\nP( B, C, D, E, A, R(64) );\r\nP( A, B, C, D, E, R(65) );\r\nP( E, A, B, C, D, R(66) );\r\nP( D, E, A, B, C, R(67) );\r\nP( C, D, E, A, B, R(68) );\r\nP( B, C, D, E, A, R(69) );\r\nP( A, B, C, D, E, R(70) );\r\nP( E, A, B, C, D, R(71) );\r\nP( D, E, A, B, C, R(72) );\r\nP( C, D, E, A, B, R(73) );\r\nP( B, C, D, E, A, R(74) );\r\nP( A, B, C, D, E, R(75) );\r\nP( E, A, B, C, D, R(76) );\r\nP( D, E, A, B, C, R(77) );\r\nP( C, D, E, A, B, R(78) );\r\nP( B, C, D, E, A, R(79) );\r\n#undef K\r\n#undef F\r\nctx->state[0] += A;\r\nctx->state[1] += B;\r\nctx->state[2] += C;\r\nctx->state[3] += D;\r\nctx->state[4] += E;\r\n}\r\nvoid sha1_update( sha1_context *ctx, const guint8 *input, guint32 length )\r\n{\r\nguint32 left, fill;\r\nif( ! length ) return;\r\nleft = ctx->total[0] & 0x3F;\r\nfill = 64 - left;\r\nctx->total[0] += length;\r\nctx->total[0] &= 0xFFFFFFFF;\r\nif( ctx->total[0] < length )\r\nctx->total[1]++;\r\nif( left && length >= fill )\r\n{\r\nmemcpy( (void *) (ctx->buffer + left),\r\n(const void *) input, fill );\r\nsha1_process( ctx, ctx->buffer );\r\nlength -= fill;\r\ninput += fill;\r\nleft = 0;\r\n}\r\nwhile( length >= 64 )\r\n{\r\nsha1_process( ctx, input );\r\nlength -= 64;\r\ninput += 64;\r\n}\r\nif( length )\r\n{\r\nmemcpy( (void *) (ctx->buffer + left),\r\n(const void *) input, length );\r\n}\r\n}\r\nvoid sha1_finish( sha1_context *ctx, guint8 digest[20] )\r\n{\r\nguint32 last, padn;\r\nguint32 high, low;\r\nguint8 msglen[8];\r\nhigh = ( ctx->total[0] >> 29 )\r\n| ( ctx->total[1] << 3 );\r\nlow = ( ctx->total[0] << 3 );\r\nPUT_UINT32( high, msglen, 0 );\r\nPUT_UINT32( low, msglen, 4 );\r\nlast = ctx->total[0] & 0x3F;\r\npadn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );\r\nsha1_update( ctx, sha1_padding, padn );\r\nsha1_update( ctx, msglen, 8 );\r\nPUT_UINT32( ctx->state[0], digest, 0 );\r\nPUT_UINT32( ctx->state[1], digest, 4 );\r\nPUT_UINT32( ctx->state[2], digest, 8 );\r\nPUT_UINT32( ctx->state[3], digest, 12 );\r\nPUT_UINT32( ctx->state[4], digest, 16 );\r\n}\r\nvoid sha1_hmac_starts( sha1_hmac_context *hctx, const guint8 *key, guint32 keylen )\r\n{\r\nguint32 i;\r\nguint8 k_ipad[64];\r\nmemset( k_ipad, 0x36, 64 );\r\nmemset( hctx->k_opad, 0x5C, 64 );\r\nfor( i = 0; i < keylen; i++ )\r\n{\r\nif( i >= 64 ) break;\r\nk_ipad[i] ^= key[i];\r\nhctx->k_opad[i] ^= key[i];\r\n}\r\nsha1_starts( &hctx->ctx );\r\nsha1_update( &hctx->ctx, k_ipad, 64 );\r\n}\r\nvoid sha1_hmac_update( sha1_hmac_context *hctx, const guint8 *buf, guint32 buflen )\r\n{\r\nsha1_update( &hctx->ctx, buf, buflen );\r\n}\r\nvoid sha1_hmac_finish( sha1_hmac_context *hctx, guint8 digest[20] )\r\n{\r\nguint8 tmpbuf[20];\r\nsha1_finish( &hctx->ctx, tmpbuf );\r\nsha1_starts( &hctx->ctx );\r\nsha1_update( &hctx->ctx, hctx->k_opad, 64 );\r\nsha1_update( &hctx->ctx, tmpbuf, 20 );\r\nsha1_finish( &hctx->ctx, digest );\r\n}\r\nvoid sha1_hmac( const guint8 *key, guint32 keylen, const guint8 *buf, guint32 buflen,\r\nguint8 digest[20] )\r\n{\r\nsha1_hmac_context hctx;\r\nsha1_hmac_starts( &hctx, key, keylen );\r\nsha1_hmac_update( &hctx, buf, buflen );\r\nsha1_hmac_finish( &hctx, digest );\r\n}\r\nint main( int argc, char *argv[] )\r\n{\r\nFILE *f;\r\nint i, j;\r\nchar output[41];\r\nsha1_context ctx;\r\nunsigned char buf[1000];\r\nunsigned char sha1sum[20];\r\nif( argc < 2 )\r\n{\r\nprintf( "\n SHA-1 Validation Tests:\n\n" );\r\nfor( i = 0; i < 3; i++ )\r\n{\r\nprintf( " Test %d ", i + 1 );\r\nsha1_starts( &ctx );\r\nif( i < 2 )\r\n{\r\nsha1_update( &ctx, (guint8 *) msg[i],\r\nstrlen( msg[i] ) );\r\n}\r\nelse\r\n{\r\nmemset( buf, 'a', 1000 );\r\nfor( j = 0; j < 1000; j++ )\r\n{\r\nsha1_update( &ctx, (guint8 *) buf, 1000 );\r\n}\r\n}\r\nsha1_finish( &ctx, sha1sum );\r\nfor( j = 0; j < 20; j++ )\r\n{\r\ng_snprintf( output + j * 2, 41-j*2, "%02x", sha1sum[j] );\r\n}\r\nif( memcmp( output, val[i], 40 ) )\r\n{\r\nprintf( "failed!\n" );\r\nreturn( 1 );\r\n}\r\nprintf( "passed.\n" );\r\n}\r\nprintf( "\n" );\r\n}\r\nelse\r\n{\r\nif( ! ( f = ws_fopen( argv[1], "rb" ) ) )\r\n{\r\nprintf("fopen: %s", g_strerror(errno));\r\nreturn( 1 );\r\n}\r\nsha1_starts( &ctx );\r\nwhile( ( i = fread( buf, 1, sizeof( buf ), f ) ) > 0 )\r\n{\r\nsha1_update( &ctx, buf, i );\r\n}\r\nsha1_finish( &ctx, sha1sum );\r\nfor( j = 0; j < 20; j++ )\r\n{\r\nprintf( "%02x", sha1sum[j] );\r\n}\r\nprintf( " %s\n", argv[1] );\r\n}\r\nreturn( 0 );\r\n}
