WSLUA_CONSTRUCTOR Dir_make(lua_State* L) {\r\n#define WSLUA_ARG_Dir_make_NAME 1\r\nconst char *dir_path = luaL_checkstring(L, WSLUA_ARG_Dir_make_NAME);\r\nws_statb64 s_buf;\r\nint ret;\r\nif (ws_stat64(dir_path, &s_buf) != 0 && errno == ENOENT) {\r\nret = ws_mkdir(dir_path, 0755);\r\nif (ret == -1) {\r\nlua_pushnil(L);\r\n} else {\r\nlua_pushboolean(L, 1);\r\n}\r\n} else {\r\nlua_pushboolean(L, 0);\r\n}\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Dir_exists(lua_State* L) {\r\n#define WSLUA_ARG_Dir_exists_NAME 1\r\nconst char *dir_path = luaL_checkstring(L, WSLUA_ARG_Dir_exists_NAME);\r\nint ret;\r\nif ((ret = test_for_directory (dir_path)) == EISDIR) {\r\nlua_pushboolean(L, 1);\r\n} else {\r\nif (ret == 0) {\r\nlua_pushboolean(L, 0);\r\n} else {\r\nlua_pushnil(L);\r\n}\r\n}\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Dir_remove(lua_State* L) {\r\n#define WSLUA_ARG_Dir_remove_NAME 1\r\nconst char *dir_path = luaL_checkstring(L, WSLUA_ARG_Dir_remove_NAME);\r\nint ret;\r\nif (test_for_directory (dir_path) == EISDIR) {\r\nret = ws_remove(dir_path);\r\nif (ret != 0) {\r\nlua_pushnil(L);\r\n} else {\r\nlua_pushboolean(L, 1);\r\n}\r\n} else {\r\nlua_pushboolean(L, 0);\r\n}\r\nWSLUA_RETURN(1);\r\n}\r\nstatic int delete_directory(const char *directory) {\r\nWS_DIR *dir;\r\nWS_DIRENT *file;\r\ngchar *filename;\r\nint ret = 0;\r\nif ((dir = ws_dir_open(directory, 0, NULL)) != NULL) {\r\nwhile ((file = ws_dir_read_name(dir)) != NULL) {\r\nfilename = g_strdup_printf ("%s%s%s", directory, G_DIR_SEPARATOR_S,\r\nws_dir_get_name(file));\r\nif (test_for_directory(filename) != EISDIR) {\r\nret = ws_remove(filename);\r\n} else {\r\nret = delete_directory (filename);\r\n}\r\nif (ret != 0) {\r\nbreak;\r\n}\r\ng_free (filename);\r\n}\r\nws_dir_close(dir);\r\n}\r\nif (ret == 0) {\r\nret = ws_remove(directory);\r\n}\r\nreturn ret;\r\n}\r\nWSLUA_CONSTRUCTOR Dir_remove_all(lua_State* L) {\r\n#define WSLUA_ARG_Dir_remove_all_NAME 1\r\nconst char *dir_path = luaL_checkstring(L, WSLUA_ARG_Dir_remove_all_NAME);\r\nint ret;\r\nif (test_for_directory (dir_path) == EISDIR) {\r\nret = delete_directory(dir_path);\r\nif (ret != 0) {\r\nlua_pushnil(L);\r\n} else {\r\nlua_pushboolean(L, 1);\r\n}\r\n} else {\r\nlua_pushboolean(L, 0);\r\n}\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Dir_open(lua_State* L) {\r\n#define WSLUA_ARG_Dir_open_PATHNAME 1\r\n#define WSLUA_OPTARG_Dir_open_EXTENSION 2\r\nconst char* dirname = luaL_checkstring(L,WSLUA_ARG_Dir_open_PATHNAME);\r\nconst char* extension = luaL_optstring(L,WSLUA_OPTARG_Dir_open_EXTENSION,NULL);\r\nDir dir;\r\nchar* dirname_clean;\r\nif (!dirname) {\r\nWSLUA_ARG_ERROR(Dir_open,PATHNAME,"must be a string");\r\nreturn 0;\r\n}\r\ndirname_clean = wslua_get_actual_filename(dirname);\r\nif (!dirname_clean) {\r\nWSLUA_ARG_ERROR(Dir_open,PATHNAME,"directory does not exist");\r\nreturn 0;\r\n}\r\nif (!test_for_directory(dirname_clean)) {\r\ng_free(dirname_clean);\r\nWSLUA_ARG_ERROR(Dir_open,PATHNAME, "must be a directory");\r\nreturn 0;\r\n}\r\ndir = (Dir)g_malloc(sizeof(struct _wslua_dir));\r\ndir->dir = g_dir_open(dirname_clean, 0, dir->dummy);\r\ng_free(dirname_clean);\r\ndir->ext = extension ? g_strdup(extension) : NULL;\r\ndir->dummy = (GError **)g_malloc(sizeof(GError *));\r\n*(dir->dummy) = NULL;\r\nif (dir->dir == NULL) {\r\ng_free(dir->dummy);\r\ng_free(dir);\r\nWSLUA_ARG_ERROR(Dir_open,PATHNAME,"could not open directory");\r\nreturn 0;\r\n}\r\npushDir(L,dir);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_METAMETHOD Dir__call(lua_State* L) {\r\nDir dir = checkDir(L,1);\r\nconst gchar* file;\r\nconst gchar* filename;\r\nconst char* ext;\r\nif (!dir->dir) {\r\nreturn 0;\r\n}\r\nif ( ! ( file = g_dir_read_name(dir->dir ) )) {\r\ng_dir_close(dir->dir);\r\ndir->dir = NULL;\r\nreturn 0;\r\n}\r\nif ( ! dir->ext ) {\r\nlua_pushstring(L,file);\r\nreturn 1;\r\n}\r\ndo {\r\nfilename = file;\r\nif ( ( ext = strstr(filename,dir->ext)) && g_str_equal(ext,dir->ext) ) {\r\nlua_pushstring(L,filename);\r\nreturn 1;\r\n}\r\n} while(( file = g_dir_read_name(dir->dir) ));\r\ng_dir_close(dir->dir);\r\ndir->dir = NULL;\r\nreturn 0;\r\n}\r\nWSLUA_METHOD Dir_close(lua_State* L) {\r\nDir dir = checkDir(L,1);\r\nif (dir->dir) {\r\ng_dir_close(dir->dir);\r\ndir->dir = NULL;\r\n}\r\nreturn 0;\r\n}\r\nWSLUA_CONSTRUCTOR Dir_personal_config_path(lua_State* L) {\r\n#define WSLUA_OPTARG_personal_config_path_FILENAME 1\r\nconst char *fname = luaL_optstring(L, WSLUA_OPTARG_personal_config_path_FILENAME,"");\r\nchar* filename = get_persconffile_path(fname,FALSE);\r\nlua_pushstring(L,filename);\r\ng_free(filename);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Dir_global_config_path(lua_State* L) {\r\n#define WSLUA_OPTARG_global_config_path_FILENAME 1\r\nconst char *fname = luaL_optstring(L, WSLUA_OPTARG_global_config_path_FILENAME,"");\r\nchar* filename;\r\nif (running_in_build_directory()) {\r\nfilename = g_strdup_printf("%s" G_DIR_SEPARATOR_S "epan" G_DIR_SEPARATOR_S "wslua"\r\nG_DIR_SEPARATOR_S "%s", get_datafile_dir(), fname);\r\n} else {\r\nfilename = get_datafile_path(fname);\r\n}\r\nlua_pushstring(L,filename);\r\ng_free(filename);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Dir_personal_plugins_path(lua_State* L) {\r\nchar* filename = get_plugins_pers_dir();\r\nlua_pushstring(L,filename);\r\ng_free(filename);\r\nWSLUA_RETURN(1);\r\n}\r\nWSLUA_CONSTRUCTOR Dir_global_plugins_path(lua_State* L) {\r\nlua_pushstring(L, get_plugin_dir());\r\nWSLUA_RETURN(1);\r\n}\r\nstatic int Dir__gc(lua_State* L) {\r\nDir dir = toDir(L,1);\r\nif(!dir) return 0;\r\nif (dir->dir) {\r\ng_dir_close(dir->dir);\r\n}\r\ng_free(dir->dummy);\r\nif (dir->ext) g_free(dir->ext);\r\ng_free(dir);\r\nreturn 0;\r\n}\r\nint Dir_register(lua_State* L) {\r\nWSLUA_REGISTER_CLASS(Dir);\r\nreturn 0;\r\n}
