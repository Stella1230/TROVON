static void _fail(const char *file, int line, const char *msg) {\r\nfprintf(stderr, "!!! %s:%d fail(%s)\n", file, line, msg);\r\nabort();\r\n}\r\nstatic struct symbol *\r\nsymbols_push(void)\r\n{\r\nsymbols_lvl++;\r\nreturn symbols;\r\n}\r\nstatic void\r\nsymbols_pop(struct symbol *sym)\r\n{\r\n--symbols_lvl;\r\nwhile (symbols != sym) {\r\nstruct symbol *s = symbols;\r\nsymbols = symbols->next;\r\nfree(s);\r\n}\r\n}\r\nstatic unsigned int\r\nsymbol_hash(const char *str)\r\n{\r\nunsigned int hash = 5381;\r\nwhile (*str) {\r\nhash = ((hash << 5) + hash) + tolower(*str);\r\nstr++;\r\n}\r\nreturn hash;\r\n}\r\nstatic struct symbol *\r\nsymbol_find(const char *id, int type)\r\n{\r\nstruct symbol *sym;\r\nunsigned int hash;\r\nhash = symbol_hash(id);\r\nfor (sym = symbols; sym; sym = sym->next) {\r\nif (sym->hash == hash && !strcasecmp(sym->id, id)) {\r\nreturn sym;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct symbol *\r\nsymbol_add(const char *id, enum symbol_type type, void *data)\r\n{\r\nstruct symbol *sym;\r\nsym = symbol_find(id, SYMBOL_ANY);\r\nif (sym) {\r\nif (sym->lvl == symbols_lvl) {\r\nfprintf(stderr, "Error: symbol %s already added [type: %d]\n", id, sym->type);\r\nabort();\r\n} else\r\nfprintf(stderr, "Warning: symbol %s shadow another symbol [type: %d]\n", id, sym->type);\r\n}\r\nsym = xnew(struct symbol);\r\nsym->id = id;\r\nsym->hash = symbol_hash(id);\r\nsym->type = type;\r\nsym->lvl = symbols_lvl;\r\nsym->data = data;\r\nsym->next = symbols;\r\nsymbols = sym;\r\nreturn sym;\r\n}\r\nstatic struct ettinfo *\r\nett_add(npl_struct_t *st)\r\n{\r\nstruct ettinfo *new = xnew(struct ettinfo);\r\nnew->st = st;\r\nnew->next = etts;\r\netts = new;\r\nreturn new;\r\n}\r\nstatic const char *\r\nett_var(const struct ettinfo *ett)\r\n{\r\nstatic char ett_name[256];\r\nsnprintf(ett_name, sizeof(ett_name), "ett_%s", ett->st->id);\r\nreturn ett_name;\r\n}\r\nstatic struct hfinfo *\r\nhfi_add(struct _npl_statement_field *st, const struct parent_info *parent)\r\n{\r\nstruct hfinfo *new = xnew(struct hfinfo);\r\nnew->st = st;\r\nnew->parent = parent->id;\r\nnew->next = hfs;\r\nhfs = new;\r\nreturn new;\r\n}\r\nstatic size_t\r\nhfi_put_name(char *buf, size_t buflen, const char *str)\r\n{\r\nsize_t pos = 0;\r\nint i;\r\nint t = 0;\r\nint toldup = -1;\r\nfor (i = 0; str[i]; i++) {\r\nint tup = isupper(str[i]);\r\nif (toldup != tup && tup) {\r\nif (t > 0) {\r\nif (pos < buflen)\r\nbuf[pos++] = '_';\r\n}\r\nt++;\r\n}\r\ntoldup = tup;\r\nif (pos < buflen)\r\nbuf[pos++] = tolower(str[i]);\r\n}\r\nreturn pos;\r\n}\r\nstatic const char *\r\nhfi_var(const struct hfinfo *hfi)\r\n{\r\nstatic char hf_name[256];\r\nsize_t pos;\r\npos = snprintf(hf_name, sizeof(hf_name), "hf_field_");\r\nxassert(pos < sizeof(hf_name));\r\nif (hfi->parent) {\r\npos += hfi_put_name(hf_name + pos, sizeof(hf_name) - pos, hfi->parent);\r\nxassert(pos < sizeof(hf_name));\r\nhf_name[pos++] = '_';\r\nxassert(pos < sizeof(hf_name));\r\n}\r\npos += hfi_put_name(hf_name + pos, sizeof(hf_name) - pos, hfi->st->id);\r\nxassert(pos < sizeof(hf_name));\r\nhf_name[pos++] = '\0';\r\nreturn hf_name;\r\n}\r\nstatic const char *\r\nhfi_name(const struct hfinfo *hfi)\r\n{\r\nreturn hfi->st->id;\r\n}\r\nstatic const char *\r\nhfi_filter(const struct hfinfo *hfi)\r\n{\r\nstatic char filter_name[1024];\r\nsize_t pos;\r\npos = 0;\r\nif (hfi->parent) {\r\npos += hfi_put_name(filter_name + pos, sizeof(filter_name)-pos, hfi->parent);\r\nxassert(pos < sizeof(filter_name));\r\nfilter_name[pos++] = '.';\r\nxassert(pos < sizeof(filter_name));\r\n}\r\npos += hfi_put_name(filter_name + pos, sizeof(filter_name)-pos, hfi->st->id);\r\nxassert(pos < sizeof(filter_name));\r\nfilter_name[pos++] = '\0';\r\nxassert(pos < sizeof(filter_name));\r\nreturn filter_name;\r\n}\r\nstatic const char *\r\nhfi_type(const struct hfinfo *hfi)\r\n{\r\nif (hfi->hf_type)\r\nreturn hfi->hf_type;\r\nreturn "FT_BYTES";\r\n}\r\nstatic const char *\r\nhfi_display(const struct hfinfo *hfi)\r\n{\r\nreturn "BASE_NONE";\r\n}\r\nstatic unsigned int\r\nhfi_mask(const struct hfinfo *hfi)\r\n{\r\nreturn 0;\r\n}\r\nstatic int\r\ncount_expression_list(const npl_expression_list_t *exprs)\r\n{\r\nint c = 0;\r\nwhile (exprs) {\r\nc++;\r\nexprs = exprs->next;\r\n}\r\nreturn c;\r\n}\r\nstatic struct symbol *\r\nexpr_to_symbol(const npl_expression_t *e)\r\n{\r\nstruct symbol *sym = NULL;\r\nif (e->type == EXPRESSION_ID) {\r\nconst char *id = e->id.id;\r\nsym = symbol_find(id, SYMBOL_ANY);\r\nif (!sym) {\r\nfprintf(stderr, "can't find id: %s\n", id);\r\nabort();\r\n}\r\nif (sym->type == SYMBOL_EXPR) {\r\nstruct symbol *new_sym = expr_to_symbol(sym->data);\r\nif (new_sym)\r\nsym = new_sym;\r\n}\r\n}\r\nreturn sym;\r\n}\r\nstatic int\r\nexpr_to_const_int(const npl_expression_t *e, int *val)\r\n{\r\nstruct symbol *sym;\r\nif (e->type == EXPRESSION_INT) {\r\n*val = e->num.digit;\r\nreturn 1;\r\n}\r\nif (e->type == EXPRESSION_UNARY) {\r\nif (!expr_to_const_int(e->u.operand, val))\r\nreturn 0;\r\nswitch (e->u.operator) {\r\ncase OP1_MINUS:\r\n*val = -(*val);\r\nreturn 1;\r\ncase OP1_NEG:\r\n*val = ~(*val);\r\nreturn 1;\r\ncase OP1_NOT:\r\n*val = !(*val);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nsym = expr_to_symbol(e);\r\nif (sym && sym->type == SYMBOL_EXPR)\r\nreturn expr_to_const_int(sym->data, val);\r\nreturn 0;\r\n}\r\nstatic int\r\nexpr_to_const_str(const npl_expression_t *e, const char **val)\r\n{\r\nstruct symbol *sym;\r\nif (e->type == EXPRESSION_STR) {\r\n*val = e->str.str;\r\nreturn 1;\r\n}\r\nsym = expr_to_symbol(e);\r\nif (sym && sym->type == SYMBOL_EXPR)\r\nreturn expr_to_const_str(sym->data, val);\r\nreturn 0;\r\n}\r\nstatic const char *\r\ntype_to_ctype(const npl_type_t *t, int size)\r\n{\r\nswitch (t->type) {\r\ncase FIELD_DECIMAL:\r\nif (size == 4)\r\nreturn "float";\r\nif (size == 8)\r\nreturn "double";\r\nfprintf(stderr, "!!! decimal, size: %d\n", size);\r\nreturn NULL;\r\ncase FIELD_NUMBER:\r\nif (size == 1)\r\nreturn "gint8";\r\nif (size == 2)\r\nreturn "gint16";\r\nif (size == 3 || size == 4)\r\nreturn "gint32";\r\nif (size > 4 && size <= 8)\r\nreturn "gint64";\r\nfprintf(stderr, "!!! number, size: %d\n", size);\r\nreturn NULL;\r\ncase FIELD_UNSIGNED_NUMBER:\r\nif (size == 1)\r\nreturn "guint8";\r\nif (size == 2)\r\nreturn "guint16";\r\nif (size == 3 || size == 4)\r\nreturn "guint32";\r\nif (size > 4 && size <= 8)\r\nreturn "guint64";\r\nfprintf(stderr, "!!! number, size: %d\n", size);\r\nreturn NULL;\r\ncase FIELD_TIME:\r\nreturn "nstime_t";\r\n}\r\nfprintf(stderr, "!!! not handled, type: %d, size: %d\n", t->type, size);\r\nreturn NULL;\r\n}\r\nstatic const char *\r\ntype_to_tvb(const npl_type_t *t, int size, int endian)\r\n{\r\nswitch (t->type) {\r\ncase FIELD_DECIMAL:\r\nif (size == 4 && endian == NPL_ENDIAN_LE)\r\nreturn "tvb_get_letohieee_float";\r\nif (size == 4 && endian == NPL_ENDIAN_BE)\r\nreturn "tvb_get_ntohieee_float";\r\nif (size == 8 && endian == NPL_ENDIAN_LE)\r\nreturn "tvb_get_letohieee_double";\r\nif (size == 8 && endian == NPL_ENDIAN_BE)\r\nreturn "tvb_get_ntohieee_double";\r\nfprintf(stderr, "!!! decimal, size: %d, endian: %d\n", size, endian);\r\nreturn NULL;\r\ncase FIELD_UNSIGNED_NUMBER:\r\ncase FIELD_NUMBER:\r\nif (size == 1)\r\nreturn "tvb_get_guint8";\r\nif (size == 2 && endian == NPL_ENDIAN_LE)\r\nreturn "tvb_get_letohs";\r\nif (size == 2 && endian == NPL_ENDIAN_BE)\r\nreturn "tvb_get_ntohs";\r\nif (t->type == FIELD_UNSIGNED_NUMBER && size == 3 && endian == NPL_ENDIAN_LE)\r\nreturn "tvb_get_letoh24";\r\nif (t->type == FIELD_UNSIGNED_NUMBER && size == 3 && endian == NPL_ENDIAN_BE)\r\nreturn "tvb_get_ntoh24";\r\nif (size == 4 && endian == NPL_ENDIAN_LE)\r\nreturn "tvb_get_letohl";\r\nif (size == 4 && endian == NPL_ENDIAN_BE)\r\nreturn "tvb_get_ntohl";\r\nfprintf(stderr, "!!! number, size: %d, endian: %d\n", size, endian);\r\nreturn NULL;\r\n}\r\nfprintf(stderr, "!!! not handled, type: %d, size: %d, endian: %d\n", t->type, size, endian);\r\nreturn NULL;\r\n}\r\nstatic const char *\r\ntype_to_ft(const npl_type_t *t, int size)\r\n{\r\nswitch (t->type) {\r\ncase FIELD_DECIMAL:\r\nif (size == 4)\r\nreturn "FT_FLOAT";\r\nif (size == 8)\r\nreturn "FT_DOUBLE";\r\nfprintf(stderr, "!!! decimal, size: %d\n", size);\r\nreturn NULL;\r\ncase FIELD_NUMBER:\r\nif (size == 1)\r\nreturn "FT_INT8";\r\nif (size == 2)\r\nreturn "FT_INT16";\r\nif (size == 3)\r\nreturn "FT_INT24";\r\nif (size == 4)\r\nreturn "FT_INT32";\r\nif (size > 4 && size <= 8)\r\nreturn "FT_INT64";\r\nfprintf(stderr, "!!! number, size: %d\n", size);\r\nreturn NULL;\r\ncase FIELD_UNSIGNED_NUMBER:\r\nif (size == 1)\r\nreturn "FT_UINT8";\r\nif (size == 2)\r\nreturn "FT_UINT16";\r\nif (size == 3)\r\nreturn "FT_UINT24";\r\nif (size == 4)\r\nreturn "FT_UINT32";\r\nif (size > 4 && size <= 8)\r\nreturn "FT_UINT64";\r\nfprintf(stderr, "!!! number, size: %d\n", size);\r\nreturn NULL;\r\ncase FIELD_TIME:\r\nfprintf(stderr, "!!! time, size: %d\n", size);\r\nreturn "FT_ABSOLUTE_TIME";\r\n}\r\nfprintf(stderr, "!!! not handled, type: %d, size: %d\n", t->type, size);\r\nreturn NULL;\r\n}\r\nstatic const char *\r\nop1_to_str(npl_op1_t op)\r\n{\r\nswitch (op) {\r\ncase OP1_MINUS:\r\nreturn "-";\r\ncase OP1_NOT:\r\nreturn "!";\r\ncase OP1_NEG:\r\nreturn "~";\r\n}\r\nfprintf(stderr, "XXX op: %d\n", op);\r\nreturn "";\r\n}\r\nstatic const char *\r\nop2_to_str(npl_op2_t op)\r\n{\r\nswitch (op) {\r\ncase OP2_PLUS:\r\nreturn "+";\r\ncase OP2_MINUS:\r\nreturn "-";\r\ncase OP2_SHL:\r\nreturn "<<";\r\ncase OP2_SHR:\r\nreturn ">>";\r\ncase OP2_EQUAL:\r\nreturn "==";\r\ncase OP2_NOTEQUAL:\r\nreturn "!=";\r\ncase OP2_LOGIC_OR:\r\nreturn "||";\r\ncase OP2_LOGIC_AND:\r\nreturn "&&";\r\ncase OP2_OR:\r\nreturn "|";\r\ncase OP2_XOR:\r\nreturn "^";\r\ncase OP2_AND:\r\nreturn "&";\r\ncase OP2_GREATER:\r\nreturn ">";\r\ncase OP2_GEQUAL:\r\nreturn ">=";\r\ncase OP2_LESS:\r\nreturn "<";\r\ncase OP2_LEQUAL:\r\nreturn "<=";\r\n}\r\nfprintf(stderr, "XXX op: %d\n", op);\r\nreturn "";\r\n}\r\nstatic enum attr_flag\r\nresolve_attr_id(const char *id)\r\n{\r\nif (!strcasecmp(id, "property"))\r\nreturn ATTR_PROPERTY;\r\nif (!strcasecmp(id, "Global"))\r\nreturn ATTR_GLOBAL;\r\nif (!strcasecmp(id, "local"))\r\nreturn ATTR_LOCAL;\r\nif (!strcasecmp(id, "conversation"))\r\nreturn ATTR_CONV;\r\nif (!strcasecmp(id, "post"))\r\nreturn ATTR_POST;\r\nfprintf(stderr, ":: attr-id: %s\n", id);\r\nabort();\r\nreturn -1;\r\n}\r\nstatic int\r\nresolve_attr_expr(const struct _npl_expression *expr)\r\n{\r\nint flags = 0;\r\nswitch (expr->type) {\r\ncase EXPRESSION_ID:\r\nflags |= (int) resolve_attr_id(expr->id.id);\r\nbreak;\r\ncase EXPRESSION_FIELD:\r\nflags |= resolve_attr_expr(expr->fld.base);\r\nflags |= (int) resolve_attr_id(expr->fld.field);\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "resolve_attr_expr() %d\n", expr->type);\r\nbreak;\r\n}\r\nxassert(!((flags & ATTR_GLOBAL) && (flags & ATTR_LOCAL)));\r\nreturn flags;\r\n}\r\nstatic void\r\nresolve_attr_list(npl_attribute_list_t *attr)\r\n{\r\nwhile (attr) {\r\nstruct _npl_expression *expr;\r\nconst char *id = NULL;\r\nint flags = 0;\r\nif (attr->expr->type == EXPRESSION_BINARY && attr->expr->b.operator == OP2_ASSIGN) {\r\nexpr = attr->expr->b.operand1;\r\nattr->assign_expr = attr->expr->b.operand2;\r\n} else\r\nexpr = attr->expr;\r\nswitch (expr->type) {\r\ncase EXPRESSION_ID:\r\nid = expr->id.id;\r\nbreak;\r\ncase EXPRESSION_FIELD:\r\nflags = resolve_attr_expr(expr->fld.base);\r\nid = expr->fld.field;\r\nbreak;\r\ndefault:\r\nfprintf(stderr, "resolve_attr_list() expr: %d\n", expr->type);\r\nbreak;\r\n}\r\nattr->flags = flags;\r\nattr->resolved = id;\r\nattr = attr->next;\r\n}\r\n}\r\nstatic void\r\ngen_expr_field(FILE *f, struct _npl_statement_field *field)\r\n{\r\nxassert(field->generate_var || f == NULL);\r\nfield->generate_var = 1;\r\ngen_fprintf(f, "_field_%s", field->id);\r\n}\r\nstatic void\r\ngen_expr_type(FILE *f, npl_type_t *t)\r\n{\r\nint size = -1;\r\nint byte_order = -1;\r\nconst char *fetch_func;\r\nif (t->size && !expr_to_const_int(t->size, &size))\r\nfprintf(stderr, "!!! expr_to_const_int(size) failed for type: %s\n", t->id);\r\nif (t->byte_order && !expr_to_const_int(t->byte_order, &byte_order))\r\nfprintf(stderr, "!!! expr_to_const_int(byte_order) failed for type: %s\n", t->id);\r\nfetch_func = type_to_tvb(t, size, byte_order);\r\nif (fetch_func)\r\ngen_fprintf(f, "%s", fetch_func);\r\nelse\r\ngen_fprintf(f, "<<TYPE %s>>", t->id);\r\n}\r\nstatic void\r\ngen_expr_table(FILE *f, npl_table_t *t)\r\n{\r\ngen_fprintf(f, " format_table_%s ", t->id);\r\n}\r\nstatic struct symbol *\r\ngen_expr(FILE *f, npl_expression_t *e)\r\n{\r\nswitch (e->type) {\r\ncase EXPRESSION_ID:\r\n{\r\nstruct symbol *sym = symbol_find(e->id.id, SYMBOL_EXPR | SYMBOL_FIELD | SYMBOL_TYPE | SYMBOL_SIMPLE | SYMBOL_TABLE);\r\nif (!sym) {\r\nfprintf(stderr, "can't find id: %s\n", e->id.id);\r\nabort();\r\n}\r\nsym->is_used = 1;\r\nif (sym->type == SYMBOL_EXPR)\r\ngen_expr(f, sym->data);\r\nelse if (sym->type == SYMBOL_FIELD)\r\ngen_expr_field(f, sym->data);\r\nelse if (sym->type == SYMBOL_TYPE)\r\ngen_expr_type(f, sym->data);\r\nelse if (sym->type == SYMBOL_TABLE)\r\ngen_expr_table(f, sym->data);\r\nelse if (sym->type == SYMBOL_SIMPLE)\r\ngen_fprintf(f, "%s", (const char *) sym->data);\r\nelse {\r\nfprintf(stderr, "ID %s wrong type [%d]\n", sym->id, sym->type);\r\nabort();\r\n}\r\nreturn sym;\r\n}\r\ncase EXPRESSION_INT:\r\ngen_fprintf(f, " %d ", e->num.digit);\r\nreturn NULL;\r\ncase EXPRESSION_STR:\r\ngen_fprintf(f, " \"%s\" ", e->str.str);\r\nreturn NULL;\r\ncase EXPRESSION_UNARY:\r\ngen_fprintf(f, "(");\r\ngen_fprintf(f, "%s", op1_to_str(e->u.operator));\r\ngen_expr(f, e->u.operand);\r\ngen_fprintf(f, ")");\r\nreturn NULL;\r\ncase EXPRESSION_BINARY:\r\ngen_fprintf(f, "(");\r\ngen_expr(f, e->b.operand1);\r\ngen_fprintf(f, " %s ", op2_to_str(e->b.operator));\r\ngen_expr(f, e->b.operand2);\r\ngen_fprintf(f, ")");\r\nreturn NULL;\r\ncase EXPRESSION_CALL:\r\n{\r\nnpl_expression_list_t *arg;\r\nstruct symbol *sym;\r\nconst char *ind = "";\r\nsym = gen_expr(NULL, e->call.fn);\r\nif (!sym) {\r\nfprintf(stderr, "can't call no-symbol\n");\r\nabort();\r\n}\r\ngen_expr(f, e->call.fn);\r\ngen_fprintf(f, "(");\r\nfor (arg = e->call.args; arg; arg = arg->next) {\r\ngen_fprintf(f, "%s", ind);\r\ngen_expr(f, arg->expr);\r\nind = ", ";\r\n}\r\ngen_fprintf(f, ")");\r\nreturn NULL;\r\n}\r\ncase EXPRESSION_COND:\r\ngen_fprintf(f, "((");\r\ngen_expr(f, e->c.test_expr);\r\ngen_fprintf(f, ") ? ");\r\ngen_expr(f, e->c.true_expr);\r\ngen_fprintf(f, " : ");\r\ngen_expr(f, e->c.false_expr);\r\ngen_fprintf(f, ")");\r\nreturn NULL;\r\ncase EXPRESSION_FIELD:\r\n{\r\nstruct symbol *sym;\r\nsym = gen_expr(NULL, e->fld.base);\r\nif (!sym) {\r\nfprintf(stderr, "can't field no-symbol (accessing %s)\n", e->fld.field);\r\nabort();\r\n}\r\nif (sym->data == &property_e) {\r\ngen_fprintf(f, "<< PROPERTY %s>>", e->fld.field);\r\n} else if (sym->data == &local_e) {\r\ngen_fprintf(f, "_local_property_%s", e->fld.field);\r\n} else if (sym->data == &global_e) {\r\ngen_fprintf(f, "<< GLOBAL PROPERTY %s>>", e->fld.field);\r\n} else {\r\ngen_expr(f, e->fld.base);\r\ngen_fprintf(f, ".%s ", e->fld.field);\r\n}\r\nreturn NULL;\r\n}\r\n}\r\nif (e == &this_e)\r\ngen_fprintf(f, "<< this >>");\r\nelse if (e == &format_string_e)\r\ngen_fprintf(f, "<< FORMAT STRING >>");\r\nelse if (e == &is_value_none_e)\r\ngen_fprintf(f, "<< IS VALUE NONE >>");\r\nelse if (e == &property_e || e == &global_e || e == &local_e)\r\n{ }\r\nelse\r\nfprintf(stderr, "XXX expr->type: %d\n", e->type);\r\nreturn NULL;\r\n}\r\nstatic enum table_struct\r\ngen_table_struct(FILE *f, npl_table_t *t)\r\n{\r\nstruct npl_table_case *c;\r\nint all_int = 1;\r\nint all_str = 1;\r\nif (t->params.count > 1 || !t->switch_expr)\r\nreturn TABLE_FULL;\r\nfor (c = t->cases; c; c = c->next) {\r\nconst char *str;\r\nint val;\r\nif (!c->return_expr || !expr_to_const_str(c->return_expr, &str))\r\nreturn 0;\r\nif (all_int && !expr_to_const_int(&c->e, &val))\r\nall_int = 0;\r\nif (all_str && !expr_to_const_str(&c->e, &str))\r\nall_str = 0;\r\nif (!all_int && !all_str)\r\nreturn TABLE_FULL;\r\n}\r\nif (all_int) {\r\ngen_fprintf(f,\r\n"static const value_string %s_vals[] = {\n",\r\nt->id);\r\nif (f)\r\nfor (c = t->cases; c; c = c->next) {\r\nconst char *str;\r\nint val;\r\nif (!expr_to_const_str(c->return_expr, &str))\r\nfail("expr_to_const_str(str)");\r\nif (!expr_to_const_int(&c->e, &val))\r\nfail("expr_to_const_int(val)");\r\ngen_fprintf(f, "\t{ 0x%x, \"%s\" },\n", val, str);\r\n}\r\ngen_fprintf(f, "\t{ 0, NULL }\n");\r\ngen_fprintf(f, "};\n");\r\nreturn TABLE_VALUE_STRING;\r\n}\r\nif (all_str) {\r\ngen_fprintf(f,\r\n"static const string_string %s_vals[] = {\n",\r\nt->id);\r\nif (f)\r\nfor (c = t->cases; c; c = c->next) {\r\nconst char *str;\r\nconst char *val;\r\nif (!expr_to_const_str(c->return_expr, &str))\r\nfail("expr_to_const_str(str)");\r\nif (!expr_to_const_str(&c->e, &val))\r\nfail("expr_to_const_str(val)");\r\ngen_fprintf(f, "\t{ \"%s\", \"%s\" },\n", val, str);\r\n}\r\ngen_fprintf(f, "\t{ NULL, NULL }\n");\r\ngen_fprintf(f, "};\n");\r\nreturn TABLE_STRING_STRING;\r\n}\r\nreturn TABLE_FULL;\r\n}\r\nstatic void\r\ngen_table_func(FILE *f, npl_table_t *t)\r\n{\r\nstruct npl_table_case *c;\r\nif (t->switch_expr) {\r\ngen_fprintf(f, "\tswitch (");\r\ngen_expr(f, t->switch_expr);\r\ngen_fprintf(f, ") {\n");\r\nfor (c = t->cases; c; c = c->next) {\r\nagain1:\r\ngen_fprintf(f, "\t\tcase ");\r\ngen_expr(f, &c->e);\r\ngen_fprintf(f, ": ");\r\nif (!c->return_expr) {\r\nc = c->next;\r\nxassert(c != NULL);\r\ngen_fprintf(f, "\n");\r\ngoto again1;\r\n} else {\r\ngen_fprintf(f, "\n");\r\ngen_fprintf(f, "\t\t\treturn ");\r\ngen_expr(f, c->return_expr);\r\ngen_fprintf(f, ";\n");\r\n}\r\n}\r\ngen_fprintf(f, "\t}\n");\r\n} else {\r\nfor (c = t->cases; c; c = c->next) {\r\nif (c == t->cases)\r\ngen_fprintf(f, "\tif (");\r\nelse\r\ngen_fprintf(f, "\telse if (");\r\nagain2:\r\ngen_fprintf(f, "(");\r\ngen_expr(f, &c->e);\r\ngen_fprintf(f, ")");\r\nif (!c->return_expr) {\r\ngen_fprintf(f, " || ");\r\nc = c->next;\r\nxassert(c != NULL);\r\ngoto again2;\r\n} else {\r\ngen_fprintf(f, ")\n");\r\ngen_fprintf(f, "\t\treturn ");\r\ngen_expr(f, c->return_expr);\r\ngen_fprintf(f, ";\n");\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\ndecl_table(npl_table_t *t)\r\n{\r\nif (!t->sym)\r\nt->sym = symbol_add(t->id, SYMBOL_TABLE, t);\r\n}\r\nstatic void\r\ngen_table(FILE *f, npl_table_t *t)\r\n{\r\nstruct symbol *symroot;\r\nconst char *first_arg;\r\nenum table_struct type;\r\nt->sym->is_static = 1;\r\ngen_fprintf(f,\r\n"static const char *\n"\r\n"format_table_%s", t->id);\r\nsymroot = symbols_push();\r\ngen_fprintf(f, "(");\r\nif (t->params.count) {\r\nint i;\r\nfor (i = 0; i < t->params.count; i++) {\r\nif (i)\r\ngen_fprintf(f, ", ");\r\ngen_fprintf(f, "TYPE %s", t->params.args[i]);\r\nsymbol_add(t->params.args[i], SYMBOL_SIMPLE, t->params.args[i]);\r\n}\r\nfirst_arg = t->params.args[0];\r\n} else {\r\ngen_fprintf(f, "TYPE value");\r\nsymbol_add("value", SYMBOL_SIMPLE, "value");\r\nfirst_arg = "value";\r\n}\r\ngen_fprintf(f, ")\n{\n");\r\ntype = gen_table_struct(f, t);\r\nswitch (type) {\r\ncase TABLE_VALUE_STRING:\r\ngen_fprintf(f, "\n");\r\ngen_fprintf(f, "\tconst char *tmp = match_strval(%s_vals, %s);\n", t->id, first_arg);\r\ngen_fprintf(f, "\tif (tmp)\n\t\treturn tmp;\n");\r\nbreak;\r\ncase TABLE_STRING_STRING:\r\ngen_fprintf(f, "\tconst char *tmp = match_strstr(%s_vals, %s);\n", t->id, first_arg);\r\ngen_fprintf(f, "\tif (tmp)\n\t\treturn tmp;\n");\r\nbreak;\r\ncase TABLE_FULL:\r\ndefault:\r\ngen_table_func(f, t);\r\nbreak;\r\n}\r\nif (t->default_expr) {\r\ngen_fprintf(f, "\treturn ");\r\ngen_expr(f, t->default_expr);\r\ngen_fprintf(f, ";\n");\r\n} else\r\ngen_fprintf(f, "\treturn \"\";\n");\r\ngen_fprintf(f, "}\n\n");\r\nsymbols_pop(symroot);\r\n}\r\nstatic void\r\ngen_field_proto(FILE *f, struct _npl_statement_field *field, npl_protocol_t *p)\r\n{\r\ngen_fprintf(f, "\t << CALL PROTOCOL %s >>\n", p->id);\r\nfield->field_size = -1;\r\n}\r\nstatic void\r\ngen_field_struct(FILE *f, struct _npl_statement_field *field, npl_struct_t *s)\r\n{\r\ngen_fprintf(f, "\toffset = dissect_struct_%s(tvb, pinfo, tree, %s, offset);\n", s->tmpid, hfi_var(field->hfi));\r\nfield->hfi->hf_type = "FT_BYTES";\r\nfield->field_size = -1;\r\n}\r\nstatic void\r\ngen_field_size(FILE *f, struct symbol *sym_size, int size)\r\n{\r\nif (sym_size) {\r\nif (sym_size->type == SYMBOL_FIELD) {\r\ngen_fprintf(f, "_field_%s", sym_size->id);\r\n} else if (sym_size->type == SYMBOL_EXPR) {\r\ngen_fprintf(f, "(");\r\ngen_expr(f, sym_size->data);\r\ngen_fprintf(f, ") ");\r\n} else if (sym_size->type == SYMBOL_SIMPLE) {\r\ngen_fprintf(f, "%s ", (const char *) sym_size->data);\r\n} else {\r\nfprintf(stderr, "::: %s (%d)\n", sym_size->id, sym_size->type);\r\ngen_fprintf(f, "<<SYMBOL %s>>\n", sym_size->id);\r\n}\r\n} else {\r\ngen_fprintf(f, "%d", size);\r\n}\r\n}\r\nstatic void\r\ngen_field_type(FILE *f, struct _npl_statement_field *field, npl_type_t *t)\r\n{\r\nstruct symbol *symroot;\r\nint i;\r\nint size = -1;\r\nstruct symbol *size_sym = NULL;\r\nint byte_order = -1;\r\nnpl_expression_t *byte_order_expr;\r\nstruct symbol *byte_order_sym = NULL;\r\nnpl_expression_t *display_format;\r\nconst char *hf_type;\r\nnpl_expression_list_t *argv = field->params;\r\nint argc = count_expression_list(argv);\r\nif (t->params.count != argc) {\r\nfprintf(stderr, "%s: number of params != number of argc (%d != %d)\n", t->id, t->params.count, argc);\r\nabort();\r\n}\r\nsymroot = symbols_push();\r\nfor (i = 0; i < argc; i++) {\r\nsymbol_add(t->params.args[i], SYMBOL_EXPR, argv->expr);\r\nargv = argv->next;\r\n}\r\nxassert(t->size != NULL);\r\nif (!expr_to_const_int(t->size, &size)) {\r\nsize_sym = expr_to_symbol(t->size);\r\nif (!size_sym) {\r\nfprintf(stderr, "!!! expr_to_const_int, _symbol(size) failed for type: %s\n", t->id);\r\nabort();\r\n}\r\n}\r\nif (field->byte_order_attr)\r\nbyte_order_expr = field->byte_order_attr;\r\nelse if (t->byte_order)\r\nbyte_order_expr = t->byte_order;\r\nelse\r\nbyte_order_expr = NULL;\r\nif (field->format)\r\ndisplay_format = field->format;\r\nelse\r\ndisplay_format = t->display_format;\r\nif (byte_order_expr) {\r\nif (!expr_to_const_int(byte_order_expr, &byte_order)) {\r\nbyte_order_sym = expr_to_symbol(byte_order_expr);\r\nif (!byte_order_sym) {\r\nfprintf(stderr, "!!! expr_to_const_int, _symbol(byte_order) failed for type: %s\n", t->id);\r\nabort();\r\n}\r\n}\r\n}\r\nif (field->generate_var) {\r\nconst char *ctype = type_to_ctype(t, size);\r\nconst char *fetch_func = type_to_tvb(t, size, byte_order);\r\ngen_fprintf(f, "\t%s _field_%s = %s(tvb, offset);\n", ctype, field->id, fetch_func);\r\n}\r\nif (size_sym) {\r\nif (size_sym->type == SYMBOL_FIELD) {\r\nstruct _npl_statement_field *sym_field = size_sym->data;\r\nxassert(sym_field->generate_var || f == NULL);\r\nsym_field->generate_var = 1;\r\n} else\r\nfprintf(stderr, "::: %s (%d)\n", size_sym->id, size_sym->type);\r\nhf_type = NULL;\r\n} else\r\nhf_type = type_to_ft(t, size);\r\nfield->hfi->hf_type = hf_type;\r\nfield->field_size = size;\r\n#if 0\r\nif (display_format)\r\nfprintf(stderr, "XXX, format\n");\r\nelse\r\n#endif\r\ngen_fprintf(f, "\tproto_tree_add_item(tree, %s, tvb, offset, ", hfi_var(field->hfi));\r\ngen_field_size(f, size_sym, size);\r\ngen_fprintf(f, ", %s);\n",\r\n(byte_order == NPL_ENDIAN_LE) ? "ENC_LITTLE_ENDIAN" :\r\n(byte_order == NPL_ENDIAN_BE) ? "ENC_BIG_ENDIAN" :\r\n"ENC_NA");\r\ngen_fprintf(f, "\toffset += ");\r\ngen_field_size(f, size_sym, size);\r\ngen_fprintf(f, ";\n");\r\nsymbols_pop(symroot);\r\n}\r\nstatic void\r\ngen_statement_field(FILE *f, struct parent_info *parent, struct _npl_statement_field *field, npl_attribute_list_t *attr_list)\r\n{\r\nstruct symbol *sym;\r\nconst char *property_name = NULL;\r\nint property_flags = 0;\r\nsym = symbol_find(field->t_id, SYMBOL_STRUCT | SYMBOL_PROTO | SYMBOL_TYPE);\r\nif (!sym) {\r\nfprintf(stderr, "can't find: %s\n", field->t_id);\r\nabort();\r\n}\r\nsym->is_used = 1;\r\nif (!field->hfi && sym->type != SYMBOL_PROTO) {\r\nfield->hfi = hfi_add(field, parent);\r\nxassert(f == NULL);\r\n}\r\nsymbol_add(field->id, SYMBOL_FIELD, field);\r\nfield->byte_order_attr = parent->byte_order;\r\nwhile (attr_list) {\r\nconst char *attr_name = attr_list->resolved;\r\nnpl_expression_t *attr_expr = attr_list->assign_expr;\r\nint attr_flags = attr_list->flags;\r\nif (attr_name) {\r\nif (!strcasecmp(attr_name, "DataFieldByteOrder")) {\r\nxassert(attr_flags == 0);\r\nxassert(attr_expr != NULL);\r\nfield->byte_order_attr = attr_expr;\r\n} else if (attr_expr) {\r\nif (attr_flags & ATTR_LOCAL) {\r\ngen_fprintf(f, "\tTYPE _local_property_%s = ", attr_name);\r\ngen_expr(f, attr_expr);\r\ngen_fprintf(f, ";\n");\r\n} else {\r\ngen_fprintf(f, "<<PROPERTY(%d) %s = ", attr_flags, attr_name);\r\ngen_expr(f, attr_expr);\r\ngen_fprintf(f, ">>\n");\r\n}\r\n} else {\r\nxassert(property_name == NULL);\r\nproperty_name = attr_name;\r\nproperty_flags = attr_flags;\r\nfield->generate_var = 1;\r\n}\r\n} else\r\nfprintf(stderr, "!!! generating field attr: not resolved!\n");\r\nattr_list = attr_list->next;\r\n}\r\nif (sym->type == SYMBOL_STRUCT)\r\ngen_field_struct(f, field, sym->data);\r\nelse if (sym->type == SYMBOL_TYPE)\r\ngen_field_type(f, field, sym->data);\r\nelse if (sym->type == SYMBOL_PROTO)\r\ngen_field_proto(f, field, sym->data);\r\nelse {\r\nfprintf(stderr, "%s: wrong type [%d]\n", sym->id, sym->type);\r\nabort();\r\n}\r\nif (property_name) {\r\ngen_fprintf(f, "<<PROPERTY(%d) %s = FIELD %s>>\n", property_flags, property_name, field->id);\r\n}\r\n}\r\nstatic void\r\ngen_statement(FILE *f, struct parent_info *parent, npl_statement_t *st)\r\n{\r\nresolve_attr_list(st->attr_list);\r\nswitch (st->type) {\r\ncase STATEMENT_WHILE:\r\ngen_fprintf(f, "\twhile (");\r\ngen_expr(f, &st->w.expr);\r\ngen_fprintf(f, ") {\n");\r\nparent->cur_offset = -1;\r\ngen_statements(f, parent, st->w.sts);\r\ngen_fprintf(f, "\t}\n");\r\nreturn;\r\ncase STATEMENT_STRUCT:\r\nparent->cur_offset = -1;\r\ngen_struct(NULL, &st->s.data, NULL);\r\ngen_fprintf(f, "\toffset = dissect_struct_%s(tvb, pinfo, tree, hf_costam, offset);\n", st->s.data.tmpid);\r\nreturn;\r\ncase STATEMENT_FIELD:\r\ngen_statement_field(f, parent, &st->f, st->attr_list);\r\nif (parent->cur_offset != -1) {\r\nif (st->f.field_size != -1)\r\nparent->cur_offset += st->f.field_size;\r\nelse\r\nparent->cur_offset = -1;\r\n}\r\nreturn;\r\ncase STATEMENT_SWITCH:\r\n{\r\nstruct npl_switch_case *c = st->sw.data.cases;\r\nparent->cur_offset = -1;\r\nif (st->sw.data.switch_expr) {\r\ngen_fprintf(f, "\tswitch (");\r\ngen_expr(f, st->sw.data.switch_expr);\r\ngen_fprintf(f, ") {\n");\r\nwhile (c) {\r\ngen_fprintf(f, "\t\tcase ");\r\ngen_expr(f, &c->e);\r\ngen_fprintf(f, ":\n");\r\nif (c->st) {\r\ngen_fprintf(f, "\t\t");\r\ngen_statement(f, parent, c->st);\r\ngen_fprintf(f, "\t\t\tbreak;\n");\r\n}\r\nc = c->next;\r\n}\r\nif (st->sw.data.default_st) {\r\ngen_fprintf(f, "\t\tdefault:\n");\r\ngen_fprintf(f, "\t\t");\r\ngen_statement(f, parent, st->sw.data.default_st);\r\n}\r\ngen_fprintf(f, "\t}\n");\r\nreturn;\r\n}\r\nif (c) {\r\nnpl_statement_t *default_st = st->sw.data.default_st;\r\ngen_fprintf(f, "\t");\r\nwhile (c) {\r\nnpl_statement_t *case_st;\r\ngen_fprintf(f, "if (");\r\ngen_fprintf(f, "(");\r\ngen_expr(f, &c->e);\r\ngen_fprintf(f, ")");\r\ncase_st = c->st;\r\nc = c->next;\r\nwhile (c && !case_st) {\r\ncase_st = c->st;\r\ngen_fprintf(f, " || ");\r\ngen_fprintf(f, "(");\r\ngen_expr(f, &c->e);\r\ngen_fprintf(f, ")");\r\nc = c->next;\r\n}\r\nif (!case_st) {\r\ngen_fprintf(f, " || 1");\r\ncase_st = default_st;\r\ndefault_st = NULL;\r\n}\r\ngen_fprintf(f, ") {\n");\r\ngen_fprintf(f, "\t");\r\ngen_statement(f, parent, case_st);\r\ngen_fprintf(f, "\t} ");\r\nif (c || default_st)\r\ngen_fprintf(f, "else ");\r\n}\r\nif (default_st) {\r\ngen_fprintf(f, "{\n");\r\ngen_fprintf(f, "\t");\r\ngen_statement(f, parent, default_st);\r\ngen_fprintf(f, "\t}\n");\r\n}\r\n} else {\r\nif (st->sw.data.default_st)\r\ngen_statement(f, parent, st->sw.data.default_st);\r\n}\r\nreturn;\r\n}\r\n}\r\nfprintf(stderr, "gen_statement: %d\n", st->type);\r\n}\r\nstatic void\r\ngen_statements(FILE *f, struct parent_info *parent, struct _npl_statements *sts)\r\n{\r\nstruct symbol *symroot;\r\nsymroot = symbols_push();\r\nwhile (sts) {\r\ngen_statement(f, parent, &sts->st);\r\nsts = sts->next;\r\n}\r\nsymbols_pop(symroot);\r\n}\r\nstatic void\r\ndecl_protocol(npl_protocol_t *p)\r\n{\r\nif (!p->sym)\r\np->sym = symbol_add(p->id, SYMBOL_PROTO, p);\r\n}\r\nstatic void\r\ngen_protocol(FILE *f, npl_protocol_t *p, npl_attribute_list_t *attr_list)\r\n{\r\nstruct parent_info this;\r\nnpl_expression_t *byte_order_attr = NULL;\r\np->sym->is_static = 1;\r\ngen_fprintf(f,\r\n"static int\n"\r\n"dissect_%s(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void *data _U_)\n", p->id);\r\nxassert(p->params.count == 0);\r\ngen_fprintf(f, "{\n");\r\ngen_fprintf(f,\r\n"\tint offset = 0;\n"\r\n"\tproto_tree *tree = NULL;\n"\r\n"\tproto_item *ti = NULL;\n"\r\n"\n"\r\n);\r\nresolve_attr_list(attr_list);\r\nwhile (attr_list) {\r\nconst char *attr_name = attr_list->resolved;\r\nnpl_expression_t *attr_expr = attr_list->assign_expr;\r\nint flags = attr_list->flags;\r\nif (attr_name) {\r\nif (!strcasecmp(attr_name, "DataTypeByteOrder")) {\r\nxassert(flags == 0);\r\nxassert(attr_expr != NULL);\r\nbyte_order_attr = attr_expr;\r\n} else\r\nfprintf(stderr, "!!! generating protocol attr: %s not handled!\n", attr_name);\r\n} else\r\nfprintf(stderr, "!!! generating protocol attr: not resolved!\n");\r\nattr_list = attr_list->next;\r\n}\r\ngen_fprintf(f, "\tif (parent_tree) {\n");\r\nif (p->format) {\r\ngen_fprintf(f, "\t\tti = proto_tree_add_protocol_format(parent_tree, proto_%s, tvb, offset, -1, ", p->id);\r\ngen_fprintf(f, "\"TODO\"");\r\ngen_expr(stderr, p->format);\r\ngen_fprintf(f, ");\n");\r\n} else\r\ngen_fprintf(f, "\t\tti = proto_tree_add_item(parent_tree, proto_%s, tvb, offset, -1, ENC_NA);\n", p->id);\r\ngen_fprintf(f, "\t\ttree = proto_item_add_subtree(ti, ett_%s);\n", p->id);\r\ngen_fprintf(f, "\t}\n");\r\nmemset(&this, 0, sizeof(this));\r\nthis.id = p->id;\r\nthis.id = NULL;\r\nthis.byte_order = byte_order_attr;\r\ngen_statements(f, &this, p->sts);\r\ngen_fprintf(f, "\tproto_item_set_len(ti, offset);\n");\r\ngen_fprintf(f, "\treturn offset;\n");\r\ngen_fprintf(f, "}\n");\r\ngen_fprintf(f, "\n");\r\n}\r\nstatic void\r\ndecl_struct(npl_struct_t *s)\r\n{\r\nif (!s->sym && s->id) {\r\ns->tmpid = s->id;\r\ns->sym = symbol_add(s->id, SYMBOL_STRUCT, s);\r\n}\r\n}\r\nstatic void\r\ngen_struct(FILE *f, npl_struct_t *s, npl_attribute_list_t *attr_list)\r\n{\r\nconst char *id = s->tmpid;\r\nstruct parent_info this;\r\nif (!id)\r\nid = s->tmpid = s->id;\r\nif (!id) {\r\nstatic unsigned int _id = 0;\r\nchar tmp_id[32];\r\nsnprintf(tmp_id, sizeof(tmp_id), "_noname%u", ++_id);\r\nid = s->tmpid = xstrdup(tmp_id);\r\nxassert(f == NULL);\r\n}\r\nif (s->count_expr) {\r\nfprintf(stderr, "TODO: s->count_expr");\r\n}\r\nif (s->sym)\r\ns->sym->is_static = 1;\r\ngen_fprintf(f,\r\n"static int\n"\r\n"dissect_struct_%s(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, int hf_index%s, int offset)\n"\r\n"{\n", id, s->private ? " _U_" : "");\r\nif (!s->private) {\r\ngen_fprintf(f, "\tconst int org_offset = offset;\n");\r\ngen_fprintf(f, "\tproto_tree *tree = NULL;\n");\r\ngen_fprintf(f, "\tproto_item *ti = NULL;\n");\r\n} else\r\ngen_fprintf(f, "\tproto_tree *tree = parent_tree;\n");\r\ngen_fprintf(f,"\n");\r\nresolve_attr_list(attr_list);\r\nwhile (attr_list) {\r\nconst char *attr_name = attr_list->resolved;\r\nif (attr_name) {\r\nfprintf(stderr, "!!! generating struct attr: %s!\n", attr_name);\r\n} else\r\nfprintf(stderr, "!!! generating struct attr: not resolved!\n");\r\nattr_list = attr_list->next;\r\n}\r\nif (!s->private) {\r\nif (!s->ett)\r\ns->ett = ett_add(s);\r\ngen_fprintf(f,\r\n"\tif (parent_tree) {\n"\r\n"\t\tti = proto_tree_add_bytes_format_value(parent_tree, hf_index, tvb, offset, %d, NULL, \"%s\");\n"\r\n"\t\ttree = proto_item_add_subtree(ti, %s);\n"\r\n"\t}\n", s->struct_size, "", ett_var(s->ett));\r\n} else {\r\nif (s->format)\r\nfprintf(stderr, "s->private && s->format?\n");\r\n}\r\nmemset(&this, 0, sizeof(this));\r\nthis.id = s->id;\r\ngen_statements(f, &this, s->sts);\r\ns->struct_size = this.cur_offset;\r\nif (s->struct_size != -1) {\r\n}\r\nif (!s->private && s->struct_size == -1)\r\ngen_fprintf(f, "\tproto_item_set_len(ti, offset - org_offset);\n");\r\nif (s->struct_size == -1)\r\ns->struct_size = 0;\r\ngen_fprintf(f, "\treturn offset;\n");\r\ngen_fprintf(f, "}\n");\r\ngen_fprintf(f, "\n");\r\n}\r\nstatic void\r\ndecl_const(npl_const_t *c)\r\n{\r\nif (!c->sym)\r\nc->sym = symbol_add(c->id, SYMBOL_EXPR, &c->expr);\r\n}\r\nstatic void\r\ndecl_type(npl_type_t *t)\r\n{\r\nif (!t->sym)\r\nt->sym = symbol_add(t->id, SYMBOL_TYPE, t);\r\n}\r\nstatic void\r\nwalk_decl(FILE *f, npl_decl_t *d, int full_run)\r\n{\r\nswitch (d->type) {\r\ncase DECL_STRUCT:\r\ndecl_struct(&d->s.data);\r\nif (!full_run)\r\nreturn;\r\ngen_struct(f, &d->s.data, d->attr_list);\r\nreturn;\r\ncase DECL_TABLE:\r\nxassert(d->attr_list == NULL);\r\ndecl_table(&d->t.data);\r\nif (!full_run)\r\nreturn;\r\ngen_table(f, &d->t.data);\r\nreturn;\r\ncase DECL_PROTOCOL:\r\ndecl_protocol(&d->p.data);\r\nif (!full_run)\r\nreturn;\r\ngen_protocol(f, &d->p.data, d->attr_list);\r\nreturn;\r\ncase DECL_CONST:\r\nxassert(d->attr_list == NULL);\r\ndecl_const(&d->c.data);\r\nif (!full_run)\r\nreturn;\r\nreturn;\r\ncase DECL_TYPE:\r\nxassert(d->attr_list == NULL);\r\ndecl_type(&d->ty.data);\r\nif (!full_run)\r\nreturn;\r\nreturn;\r\ncase DECL_INCLUDE:\r\nxassert(d->attr_list == NULL);\r\nreturn;\r\n}\r\nfprintf(stderr, "gen_decl() type: %d\n", d->type);\r\n}\r\nstatic void\r\nwalk_code(FILE *f, npl_code_t *c, int full_run)\r\n{\r\nstruct _npl_decl_list *decl;\r\nfor (decl = c->decls; decl; decl = decl->next)\r\nwalk_decl(f, &decl->d, 0);\r\nif (!full_run)\r\nreturn;\r\nfor (decl = c->decls; decl; decl = decl->next)\r\nwalk_decl(f, &decl->d, full_run);\r\n}\r\nstatic void\r\nparse_includes(npl_code_t *c)\r\n{\r\nstruct _npl_decl_list *decl;\r\nfor (decl = c->decls; decl; decl = decl->next) {\r\nif (decl->d.type == DECL_INCLUDE) {\r\nconst char *filename = decl->d.i.file;\r\nFILE *f;\r\nnpl_code_t icode;\r\nint parse_ok;\r\nif (!(f = fopen(filename, "rb"))) {\r\nfprintf(stderr, "can't open: %s\n", filename);\r\nabort();\r\n}\r\nmemset(&icode, 0, sizeof(icode));\r\nparse_ok = npl_parse_file(&icode, f, filename);\r\nfclose(f);\r\nif (!parse_ok) {\r\nfprintf(stderr, "can't parse %s\n", filename);\r\nabort();\r\n}\r\nparse_includes(&icode);\r\nwalk_code(NULL, &icode, 0);\r\n}\r\n}\r\n}\r\nstatic void\r\ngen_vars(FILE *f)\r\n{\r\nstruct hfinfo *hfi;\r\nstruct ettinfo *ett;\r\nfor (hfi = hfs; hfi; hfi = hfi->next)\r\ngen_fprintf(f, "static int %s = -1;\n", hfi_var(hfi));\r\ngen_fprintf(f, "\n");\r\nfor (ett = etts; ett; ett = ett->next)\r\ngen_fprintf(f, "static int %s = -1;\n", ett_var(ett));\r\ngen_fprintf(f, "\n");\r\n}\r\nstatic void\r\ngen_proto_register(FILE *f, const char *proto_name)\r\n{\r\nstruct hfinfo *hfi;\r\nstruct ettinfo *ett;\r\ngen_fprintf(f,\r\n"void\n"\r\n"proto_register_%s(void)\n"\r\n"{\n", proto_name);\r\ngen_fprintf(f, "\tstatic hf_register_info hf[] = {\n");\r\nfor (hfi = hfs; hfi; hfi = hfi->next) {\r\ngen_fprintf(f,\r\n"\t\t{ &%s,\n"\r\n"\t\t\t{ \"%s\", \"%s.%s\", %s, %s, NULL, 0x%.2x, NULL, HFILL }\n"\r\n"\t\t},\n", hfi_var(hfi), hfi_name(hfi), proto_name, hfi_filter(hfi), hfi_type(hfi), hfi_display(hfi), hfi_mask(hfi) );\r\n}\r\ngen_fprintf(f, "\t};\n\n");\r\ngen_fprintf(f, "\tstatic gint *ett[] = {\n");\r\nfor (ett = etts; ett; ett = ett->next)\r\ngen_fprintf(f, "\t\t&%s,\n", ett_var(ett));\r\ngen_fprintf(f, "\t};\n\n");\r\ngen_fprintf(f, "\tproto_%s = proto_register_protocol(\"%s\", \"%s\", \"%s\");\n\n", proto_name, proto_name, proto_name, proto_name);\r\ngen_fprintf(f, "\tproto_register_field_array(proto_%s, hf, array_length(hf));\n", proto_name);\r\ngen_fprintf(f, "\tproto_register_subtree_array(ett, array_length(ett));\n");\r\ngen_fprintf(f, "}\n\n");\r\n}\r\nstatic void\r\ngen_proto_handoff(FILE *f, const char *proto_name)\r\n{\r\ngen_fprintf(f,\r\n"void\n"\r\n"proto_reg_handoff_%s(void)\n"\r\n"{\n", proto_name);\r\ngen_fprintf(f, "\tdissector_handle_t %s_handle = new_create_dissector_handle(dissect_%s, proto_%s);\n", proto_name, proto_name, proto_name);\r\n#if 0\r\ndissector_add_uint("REG", XXX, %s_handle);\r\nxml_handle = find_dissector("xml");\r\n#endif\r\ngen_fprintf(f, "}\n\n");\r\n}\r\nstatic const npl_protocol_t *\r\nget_protocol(npl_code_t *code)\r\n{\r\nstruct _npl_decl_list *decl;\r\nfor (decl = code->decls; decl; decl = decl->next) {\r\nif (decl->d.type == DECL_PROTOCOL)\r\nreturn &decl->d.p.data;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nmerge_code(npl_code_t *code, npl_code_t *subcode)\r\n{\r\nstruct _npl_decl_list **p = &code->decls;\r\nwhile (*p)\r\np = &(*p)->next;\r\n*p = subcode->decls;\r\n}\r\nstatic void\r\ncheck_code(npl_code_t *code)\r\n{\r\nparse_includes(code);\r\nwalk_code(NULL, code, 1);\r\n}\r\nstatic void\r\ngenerate_code(npl_code_t *code)\r\n{\r\nconst npl_protocol_t *proto = get_protocol(code);\r\nconst char *proto_name = (proto) ? proto->id : "noname";\r\nFILE *out;\r\nstruct symbol *sym;\r\nout = fopen("/tmp/npl.c", "w");\r\ngen_fprintf(out, "#include \"config.h\"\n");\r\ngen_fprintf(out, "#include <glib.h>\n");\r\ngen_fprintf(out, "#include <epan/packet.h>\n");\r\ngen_fprintf(out, "\n");\r\nfor (sym = symbols; sym; sym = sym->next) {\r\nconst char *sstatic = (sym->is_static) ? "static " : "";\r\nif (!sym->is_used)\r\ncontinue;\r\nswitch (sym->type) {\r\ncase SYMBOL_TABLE:\r\ngen_fprintf(out, "%sconst char *format_table_%s(...);\n", sstatic, sym->id);\r\nbreak;\r\ncase SYMBOL_STRUCT:\r\ngen_fprintf(out, "%sint dissect_struct_%s(tvbuff_t *, packet_info *, proto_tree *, int, int);\n", sstatic, sym->id);\r\nbreak;\r\ncase SYMBOL_PROTO:\r\ngen_fprintf(out, "%sint dissect_%s(tvbuff_t *, packet_info *, proto_tree *, void *);\n", sstatic, sym->id);\r\nbreak;\r\n}\r\n}\r\ngen_fprintf(out, "\n");\r\ngen_fprintf(out, "static int proto_%s = -1;\n", proto_name);\r\ngen_fprintf(out, "static int ett_%s = -1;\n", proto_name);\r\ngen_vars(out);\r\nwalk_code(out, code, 1);\r\ngen_proto_register(out, proto_name);\r\ngen_proto_handoff(out, proto_name);\r\nfclose(out);\r\n}\r\nint main(int argc, char **argv) {\r\nFILE *f;\r\nnpl_code_t code;\r\nint i;\r\nif (argc < 2) {\r\nfprintf(stderr, "usage: %s filename\n", argv[0]);\r\nreturn 1;\r\n}\r\nsymbol_add("FrameOffset", SYMBOL_SIMPLE, "offset");\r\nsymbol_add("FrameData", SYMBOL_SIMPLE, "tvb");\r\nsymbol_add("this", SYMBOL_EXPR, &this_e);\r\nsymbol_add("FormatString", SYMBOL_EXPR, &format_string_e);\r\nsymbol_add("IsValueNone", SYMBOL_EXPR, &is_value_none_e);\r\nsymbol_add("Property", SYMBOL_EXPR, &property_e);\r\nsymbol_add("Global", SYMBOL_EXPR, &global_e);\r\nsymbol_add("Local", SYMBOL_EXPR, &local_e);\r\nmemset(&code, 0, sizeof(code));\r\nfor (i = 1; i < argc; i++) {\r\nnpl_code_t mcode;\r\nint parse_ok;\r\nif (!(f = fopen(argv[i], "rb"))) {\r\nfprintf(stderr, "can't open: %s\n", argv[i]);\r\ncontinue;\r\nreturn 1;\r\n}\r\nmemset(&mcode, 0, sizeof(mcode));\r\nparse_ok = npl_parse_file(&mcode, f, argv[i]);\r\nfclose(f);\r\nif (!parse_ok) {\r\nfprintf(stderr, "can't parse: %s\n", argv[i]);\r\nreturn 1;\r\n}\r\nmerge_code(&code, &mcode);\r\n}\r\ncheck_code(&code);\r\ngenerate_code(&code);\r\nreturn 0;\r\n}
