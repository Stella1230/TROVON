static void common_dbg(int level, const char* fmt, ...) {\r\nva_list ap;\r\nchar str[1024];\r\nif (level > dbg_level) return;\r\nva_start(ap,fmt);\r\ng_vsnprintf(str,1024,fmt,ap);\r\nva_end(ap);\r\nif (dbg_fp) {\r\nfprintf(dbg_fp,"%s: level=%d msg='%s'\n",dbg_prefix,level,str);\r\nfflush(dbg_fp);\r\n}\r\n}\r\nextern void echld_common_set_dbg(int level, FILE* fp, const char* prefix) {\r\ndbg_prefix = prefix;\r\ndbg_level = level;\r\ndbg_fp = fp;\r\n}\r\nconst char* echld_state_str(child_state_t id) {\r\nint i = 0;\r\nfor (;st_map[i].str;i++) {\r\nif (id == st_map[i].id) return st_map[i].str;\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nconst char* echld_msg_type_str(echld_msg_type_t id) {\r\nint i = 0;\r\nfor (;t_map[i].str;i++) {\r\nif (id == t_map[i].type) return t_map[i].str;\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nstatic void child_realloc_buff(echld_reader_t* r, size_t needed) {\r\nsize_t a = r->actual_len;\r\nsize_t s = r->len;\r\nlong rp_off = r->rp - r->data;\r\nDBG((2,"REALLOC BUFF needed=%d",needed));\r\nif ( a < (s + needed) ) {\r\nguint8* data = r->data;\r\ndo {\r\na *= 2;\r\n} while( a < (s + needed) );\r\ndata = (guint8*)g_realloc(data,a);\r\nr->actual_len = a;\r\nr->len = s;\r\nr->data = data;\r\nr->wp = data + s;\r\nr->rp = data + rp_off;\r\n}\r\n}\r\nstatic void parent_realloc_buff(echld_reader_t* b, size_t needed) {\r\nchild_realloc_buff(b,needed);\r\n}\r\nvoid echld_reset_reader(echld_reader_t* r, int fd, size_t initial) {\r\nr->fd = fd;\r\nfcntl(fd, F_SETFL, O_NONBLOCK);\r\nif (r->data == NULL) {\r\nr->actual_len = initial;\r\nr->data =(guint8*) g_malloc0(initial);\r\nr->wp = r->data;\r\nr->rp = r->data;\r\nr->len = 0;\r\n} else {\r\nr->wp = r->data;\r\nr->rp = r->data;\r\nr->len = 0;\r\n}\r\n}\r\nvoid echld_init_reader(echld_reader_t* r, int fd, size_t initial) {\r\nechld_reset_reader(r,fd,initial);\r\n}\r\nvoid free_reader(echld_reader_t* r) {\r\nfree(r->data);\r\n}\r\nstatic long reader_readv(echld_reader_t* r, size_t len) {\r\nstruct iovec iov;\r\nlong nread;\r\nDBG((2,"READV needed=%d",len));\r\nif ( (r->actual_len - r->len) < len )\r\nreader_realloc_buff(r, len);\r\niov.iov_base = r->wp;\r\niov.iov_len = len;\r\nnread = readv(r->fd, &iov, 1);\r\nDBG((2,"READV nread=%d msg='%s'",nread, (nread<0) ? strerror(errno) : "-" ));\r\nif (nread >= 0) {\r\nr->wp += nread;\r\nr->len += nread;\r\n}\r\nif (errno == EAGAIN) return 0;\r\nreturn nread;\r\n}\r\nlong echld_read_frame(echld_reader_t* r, read_cb_t cb, void* cb_data) {\r\nDBG((4,"READ = echld_read_frame fd=%d",r->fd));\r\ndo {\r\nhdr_t* h = (hdr_t*)r->rp;\r\nlong nread;\r\nsize_t fr_len = 0;\r\nsize_t missing;\r\nDBG((5,"READ reader_len=%d",r->len));\r\nif ( r->len < ECHLD_HDR_LEN) {\r\ngoto incomplete_header;\r\n} else if ( ! reader_has_frame(r) ) {\r\ngoto incomplete_frame;\r\n}\r\nDBG((5,"READ we've got a frame! fr_len=%d ch=%d t='%c' rh=%d",fr_len, h->h.chld_id, HDR_TYPE(h), h->h.reqh_id));\r\ncb( &(r->rp[sizeof(hdr_t)]), HDR_LEN(h), h->h.chld_id, HDR_TYPE(h), h->h.reqh_id, cb_data);\r\nr->len = 0;\r\nr->wp = r->data;\r\nr->rp = r->data;\r\nDBG((5,"READ consumed frame!"));\r\ngoto again;\r\nincomplete_header:\r\nmissing = ECHLD_HDR_LEN - (r->len);\r\nDBG((5,"READ incomplete_header missing=%d",missing));\r\nnread = reader_readv(r,missing);\r\nif (nread < 0 && errno != EAGAIN) {\r\ngoto kaput;\r\n} else if (nread < (long)missing) {\r\ngoto again;\r\n} else {\r\ngoto incomplete_frame;\r\n}\r\nincomplete_frame:\r\nfr_len = HDR_LEN(h) + ECHLD_HDR_LEN;\r\nmissing = fr_len - r->len;\r\nDBG((5,"READ incomplete_frame fr_len=%d missing=%d",fr_len ,missing));\r\nif (missing) {\r\nnread = reader_readv(r,missing);\r\nif (nread < 0 && errno != EAGAIN) {\r\ngoto kaput;\r\n} else if (nread < (long)missing) {\r\ngoto again;\r\n}\r\n}\r\n} while(1);\r\nDBG((1,"READ incomplete_frame Cannot happen"));\r\nreturn 0;\r\nagain: return 1;\r\nkaput: return -1;\r\n}\r\nlong echld_write_frame(int fd, GByteArray* ba, guint16 chld_id, echld_msg_type_t type, guint16 reqh_id, void* data _U_) {\r\nhdr_t h;\r\nstruct iovec iov[2];\r\nint iov_cnt = 1;\r\nh.h.type_len = (type<<24) | ((ba?ba->len:0) & 0x00ffffff) ;\r\nh.h.chld_id = chld_id;\r\nh.h.reqh_id = reqh_id;\r\niov[0].iov_base = &h;\r\niov[0].iov_len = 8;\r\nif ( ba && ba->len > 0 ) {\r\niov[1].iov_base = ba->data;\r\niov[1].iov_len = ba->len;\r\niov_cnt++;\r\n}\r\nreturn (long) writev(fd, iov, iov_cnt);\r\n}\r\nparam_t* paramset_find (param_t* paramsets, char* name, char** err) {\r\nint i;\r\nfor (i = 0; paramsets[i].name != NULL;i++) {\r\nif (strcmp(name,paramsets[i].name) == 0 ) return &(paramsets[i]);\r\n}\r\n*err = g_strdup_printf("Could not find param='%s'",name);\r\nreturn NULL;\r\n}\r\nechld_bool_t paramset_apply_set (param_t* paramsets, char* name, char* val, char** err) {\r\nparam_t* p = paramset_find(paramsets,name,err);\r\nif ( !p ) return FALSE;\r\nif ( ! p->set ) {\r\n*err = g_strdup_printf("Cannot set RO param='%s'",name);\r\nreturn FALSE;\r\n}\r\nreturn p->set(val,err);\r\n}\r\nchar* paramset_apply_get (param_t* paramsets, char* name, char** err) {\r\nparam_t* p = paramset_find(paramsets,name,err);\r\nif ( !p ) return NULL;\r\nif ( ! p->get ) {\r\n*err = g_strdup_printf("Cannot get WO param='%s'",name);\r\nreturn NULL;\r\n}\r\nreturn p->get(err);\r\n}\r\nechld_bool_t paramset_apply_em(param_t* paramset, enc_msg_t* em, char** err) {\r\nGByteArray* ba = (GByteArray*)em;\r\nchar* p = (char*) ba->data;\r\nint tot_len = ba->len;\r\nlong rem = tot_len;\r\np[rem-1] = '\0';\r\nwhile(rem > 2) {\r\nchar* param = p;\r\nlong param_len = strlen(param)+1;\r\nchar* value = p + param_len;\r\nlong value_len;\r\nrem -= param_len;\r\nif (rem < 0) {\r\n*err = g_strdup_printf("Malformed msg param len invalid");\r\nreturn FALSE;\r\n}\r\nvalue_len = strlen(value)+1;\r\nrem -= value_len;\r\np = value + value_len;\r\nif (rem < 0) {\r\n*err = g_strdup_printf("Malformed msg value len invalid");\r\nreturn FALSE;\r\n}\r\nif (! paramset_apply_set(paramset,param,value,err))\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nchar* paramset_get_params_list(param_t* paramsets,const char* fmt) {\r\nparam_t* p = paramsets;\r\nGString* str = g_string_new("");\r\nchar* s;\r\nfor (;p->name;p++) {\r\ng_string_append_printf(str,fmt,\r\np->name,\r\n((p->get && p->set)?"rw":(p->get?"ro":"wo")),\r\np->desc);\r\n}\r\ns = str->str;\r\ng_string_free(str,FALSE);\r\nreturn s;\r\n}\r\nstatic enc_msg_t* str_enc(const char* s) {\r\nGByteArray* ba = g_byte_array_new();\r\ng_byte_array_append(ba,s,(guint)(strlen(s)+1));\r\nreturn (enc_msg_t*)ba;\r\n}\r\nstatic gboolean str_dec(guint8* b, size_t bs, char** text) {\r\nguint8* end = b+bs;\r\nb[bs-1] = '\0';\r\n*text = (char*)b;\r\nif (b+(strlen(b)+1) > end) return FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean str_deca(enc_msg_t* ba, char** text) {\r\nreturn str_dec(ba->data,ba->len,text);\r\n}\r\nstatic enc_msg_t* int_str_enc(int i, const char* s) {\r\nGByteArray* ba = g_byte_array_new();\r\ng_byte_array_append(ba,(guint8*)&i,sizeof(int));\r\ng_byte_array_append(ba,s,(guint)(strlen(s)+1));\r\nreturn (enc_msg_t*)ba;\r\n}\r\nstatic gboolean int_str_dec(guint8* b, size_t bs, int* ip, char** text) {\r\nguint8* end = b+bs;\r\nb[bs-1] = '\0';\r\nif ((sizeof(int)) > bs) return FALSE;\r\n*ip = *((int*)b);\r\nb += (sizeof(int));\r\n*text = (char*)b;\r\nif ((b += (strlen(b)+1)) > end) return FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean int_str_deca(enc_msg_t* ba, int* ip, char** text) {\r\nreturn int_str_dec(ba->data,ba->len,ip,text);\r\n}\r\nstatic enc_msg_t* int_enc(int i) {\r\nGByteArray* ba = g_byte_array_new();\r\ng_byte_array_append(ba,(guint8*)&i,sizeof(int));\r\nreturn (enc_msg_t*)ba;\r\n}\r\nstatic gboolean int_dec(guint8* b, size_t bs, int* ip) {\r\nif ((sizeof(int)) > bs) return FALSE;\r\n*ip = *((int*)b);\r\nreturn TRUE;\r\n}\r\nstatic gboolean int_deca(enc_msg_t* ba, int* ip) {\r\nreturn int_dec(ba->data,ba->len,ip);\r\n}\r\nstatic enc_msg_t* x2str_enc(const char* s1, const char* s2) {\r\nGByteArray* ba = g_byte_array_new();\r\ng_byte_array_append(ba,s1,(guint)(strlen(s1)+1));\r\ng_byte_array_append(ba,s2,(guint)(strlen(s2)+1));\r\nreturn (enc_msg_t*)ba;\r\n}\r\nstatic gboolean x2str_dec(guint8* b, size_t blen, char** str1, char** str2) {\r\nguint8* end = b+blen;\r\nb[blen-1] = '\0';\r\n*str1 = (char*)b;\r\nif ((b += (strlen(b)+1)) > end) return FALSE;\r\n*str2 = (char*)(b);\r\nif ((b += (strlen(b)+1)) > end) return FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean x2str_deca(enc_msg_t* ba, char** str1, char** str2) {\r\nreturn x2str_dec(ba->data,ba->len,str1,str2);\r\n}\r\nstatic gboolean int_3str_dec (guint8* b, size_t len, int* i, char** s1, char** s2, char** s3) {\r\nguint8* end = b+len;\r\nb[len-1] = '\0';\r\nif ((sizeof(int)) > len) return FALSE;\r\n*i = *((int*)b);\r\nb += sizeof(int);\r\n*s1 = (char*)b;\r\nif ((b += (strlen(b)+1)) > end) return FALSE;\r\n*s2 = (char*)(b);\r\nif ((b += (strlen(b)+1)) > end) return FALSE;\r\n*s3 = (char*)b;\r\nif ((b += (strlen(b)+1)) > end) return FALSE;\r\nreturn TRUE;\r\n}\r\nstatic enc_msg_t* int_3str_enc(int i, const char* s1, const char* s2, const char* s3) {\r\nGByteArray* ba = g_byte_array_new();\r\ng_byte_array_append(ba,(guint8*)&i,sizeof(int));\r\ng_byte_array_append(ba,s1,(guint)(strlen(s1)+1));\r\ng_byte_array_append(ba,s2,(guint)(strlen(s2)+1));\r\ng_byte_array_append(ba,s3,(guint)(strlen(s3)+1));\r\nreturn (enc_msg_t*)ba;\r\n}\r\nstatic gboolean int_3str_deca (enc_msg_t* e, int* i, char** s1, char** s2, char** s3) {\r\nreturn int_3str_dec(e->data,e->len,i,s1,s2,s3);\r\n}\r\nstatic gboolean x3str_dec (guint8* b, size_t len, char** s1, char** s2, char** s3) {\r\nguint8* end = b+len;\r\nb[len-1] = '\0';\r\n*s1 = (char*)b;\r\nif ((b += (strlen(b)+1)) > end) return FALSE;\r\n*s2 = (char*)(b);\r\nif ((b += (strlen(b)+1)) > end) return FALSE;\r\n*s3 = (char*)b;\r\nif ((b += (strlen(b)+1)) > end) return FALSE;\r\nreturn TRUE;\r\n}\r\nstatic gboolean x3str_deca (enc_msg_t* e, char** s1, char** s2, char** s3) {\r\nreturn x3str_dec(e->data,e->len,s1,s2,s3);\r\n}\r\nstatic enc_msg_t* x3str_enc(const char* s1, const char* s2, const char* s3) {\r\nGByteArray* ba = g_byte_array_new();\r\ng_byte_array_append(ba,s1,(guint)(strlen(s1)+1));\r\ng_byte_array_append(ba,s2,(guint)(strlen(s2)+1));\r\ng_byte_array_append(ba,s3,(guint)(strlen(s3)+1));\r\nreturn (enc_msg_t*)ba;\r\n}\r\nechld_parent_encoder_t* echld_get_encoder(void) {\r\nreturn &parent_encoder;\r\n}\r\nvoid echld_get_all_codecs( child_encoder_t **e, child_decoder_t **d, echld_parent_encoder_t **pe, parent_decoder_t** pd) {\r\ne && (*e = &child_encoder);\r\nd && (*d = &child_decoder);\r\npe && (*pe = &parent_encoder);\r\npd && (*pd = &parent_decoder);\r\n}\r\nstatic char* packet_summary_json(GByteArray* ba _U_) {\r\nreturn g_strdup("{type='packet_summary', packet_summary={}");\r\n}\r\nstatic char* tree_json(GByteArray* ba _U_) {\r\nreturn g_strdup("{type='tree', tree={}");\r\n}\r\nchar* tvb_json(GByteArray* ba _U_, tvb_t* tvb _U_, const char* name) {\r\nreturn g_strdup_printf("{type='buffer', buffer={name='%s', range='0-2', data=[0x12,0xff] }",name);\r\n}\r\nstatic char* error_json(GByteArray* ba) {\r\nchar* s = (char*)(ba->data + sizeof(int));\r\nint i = *((int*)s);\r\ns = g_strdup_printf("{type='error', error={errnum=%d, message='%s'}}",i,s);\r\nreturn s;\r\n}\r\nstatic char* child_dead_json(GByteArray* ba) {\r\nchar* s = (char*)(ba->data + sizeof(int));\r\nint i = *((int*)s);\r\ns = g_strdup_printf("{type='child_dead', child_dead={childnum=%d, message='%s'}}",i,s);\r\nreturn s;\r\n}\r\nstatic char* closing_json(GByteArray* ba) {\r\nchar* s = (char*)(ba->data);\r\ns = g_strdup_printf("{type='closing', closing={reason='%s'}}",s);\r\nreturn s;\r\n}\r\nstatic char* note_added_json(GByteArray* ba) {\r\nchar* s = (char*)(ba->data);\r\ns = g_strdup_printf("{ type='note_added', note_added={msg='%s'}}",s);\r\nreturn s;\r\n}\r\nstatic char* packet_list_json(GByteArray* ba _U_) {\r\nreturn g_strdup("{}");\r\n}\r\nstatic char* file_saved_json(GByteArray* ba) {\r\nchar* s = (char*)(ba->data);\r\ns = g_strdup_printf("{ type='file_saved', file_saved={msg='%s'}}",s);\r\nreturn s;\r\n}\r\nstatic char* param_set_json(GByteArray* ba) {\r\nchar* s1 = (char*)(ba->data);\r\nchar* s2 = ((char*)(ba->data)) + strlen(s1);\r\ns1 = g_strdup_printf("{type='param_set', param_set={param='%s' value='%s'}}",s1,s2);\r\nreturn s1;\r\n}\r\nstatic char* set_param_json(GByteArray* ba) {\r\nchar* s1 = (char*)(ba->data);\r\nchar* s2 = ((char*)(ba->data)) + strlen(s1);\r\ns1 = g_strdup_printf("{type='set_param', set_param={param='%s' value='%s'}}",s1,s2);\r\nreturn s1;\r\n}\r\nstatic char* get_param_json(GByteArray* ba) {\r\nchar* s1 = (char*)(ba->data);\r\ns1 = g_strdup_printf("{type='get_param', get_param={param='%s'}}",s1);\r\nreturn s1;\r\n}\r\nstatic char* file_opened_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* open_file_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* open_interface_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* interface_opened_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* notify_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* get_tree_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* get_sum_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* get_buffer_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* buffer_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* add_note_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* apply_filter_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* save_file_json(GByteArray* ba _U_) {\r\nreturn g_strdup("");\r\n}\r\nstatic char* decode_json(echld_msg_type_t type, enc_msg_t* m) {\r\nGByteArray* ba = (GByteArray*)m;\r\nswitch(type) {\r\ncase ECHLD_ERROR: return error_json(ba);\r\ncase ECHLD_TIMED_OUT: return g_strdup("{type='timed_out'}");\r\ncase ECHLD_NEW_CHILD: return g_strdup("{type='new_child'}");\r\ncase ECHLD_HELLO: return g_strdup("{type='helo'}");\r\ncase ECHLD_CHILD_DEAD: return child_dead_json(ba);\r\ncase ECHLD_CLOSE_CHILD: return g_strdup("{type='close_child'}");\r\ncase ECHLD_CLOSING: return closing_json(ba);\r\ncase ECHLD_SET_PARAM: return set_param_json(ba);\r\ncase ECHLD_GET_PARAM: return get_param_json(ba);\r\ncase ECHLD_PARAM: return param_set_json(ba);\r\ncase ECHLD_PING: return g_strdup("{type='ping'}");\r\ncase ECHLD_PONG: return g_strdup("{type='pong'}");\r\ncase ECHLD_OPEN_FILE: return open_file_json(ba);\r\ncase ECHLD_FILE_OPENED: return file_opened_json(ba);\r\ncase ECHLD_OPEN_INTERFACE: return open_interface_json(ba);\r\ncase ECHLD_INTERFACE_OPENED: return interface_opened_json(ba);\r\ncase ECHLD_START_CAPTURE: return g_strdup("{type='start_capture'}");\r\ncase ECHLD_CAPTURE_STARTED: return g_strdup("{type='capture_started'}");\r\ncase ECHLD_NOTIFY: return notify_json(ba);\r\ncase ECHLD_GET_SUM: return get_sum_json(ba);\r\ncase ECHLD_PACKET_SUM: return packet_summary_json(ba);\r\ncase ECHLD_GET_TREE: return get_tree_json(ba);\r\ncase ECHLD_TREE: return tree_json(ba);\r\ncase ECHLD_GET_BUFFER: return get_buffer_json(ba);\r\ncase ECHLD_BUFFER: return buffer_json(ba);\r\ncase ECHLD_EOF: return g_strdup("{type='eof'}");\r\ncase ECHLD_STOP_CAPTURE: return g_strdup("{type='stop_capture'}");\r\ncase ECHLD_CAPTURE_STOPPED: return g_strdup("{type='capture_stopped'}");\r\ncase ECHLD_ADD_NOTE: return add_note_json(ba);\r\ncase ECHLD_NOTE_ADDED: return note_added_json(ba);\r\ncase ECHLD_APPLY_FILTER: return apply_filter_json(ba);\r\ncase ECHLD_PACKET_LIST: return packet_list_json(ba);\r\ncase ECHLD_SAVE_FILE: return save_file_json(ba);\r\ncase ECHLD_FILE_SAVED: return file_saved_json(ba);\r\ncase EC_ACTUAL_ERROR: return g_strdup("{type='actual_error'}");\r\ndefault: break;\r\n}\r\nreturn NULL;\r\n}\r\nchar* echld_decode(echld_msg_type_t t, enc_msg_t* m ) {\r\nreturn decode_json(t,m);\r\n}\r\nextern void dummy_switch(echld_msg_type_t type) {\r\nswitch(type) {\r\ncase ECHLD_ERROR: break;\r\ncase ECHLD_TIMED_OUT: break;\r\ncase ECHLD_NEW_CHILD: break;\r\ncase ECHLD_HELLO: break;\r\ncase ECHLD_CHILD_DEAD: break;\r\ncase ECHLD_CLOSE_CHILD: break;\r\ncase ECHLD_CLOSING: break;\r\ncase ECHLD_SET_PARAM: break;\r\ncase ECHLD_GET_PARAM: break;\r\ncase ECHLD_PARAM: break;\r\ncase ECHLD_PING: break;\r\ncase ECHLD_PONG: break;\r\ncase ECHLD_OPEN_FILE: break;\r\ncase ECHLD_FILE_OPENED: break;\r\ncase ECHLD_OPEN_INTERFACE: break;\r\ncase ECHLD_INTERFACE_OPENED: break;\r\ncase ECHLD_START_CAPTURE: break;\r\ncase ECHLD_CAPTURE_STARTED: break;\r\ncase ECHLD_NOTIFY: break;\r\ncase ECHLD_GET_SUM: break;\r\ncase ECHLD_PACKET_SUM: break;\r\ncase ECHLD_GET_TREE: break;\r\ncase ECHLD_TREE: break;\r\ncase ECHLD_GET_BUFFER: break;\r\ncase ECHLD_BUFFER: break;\r\ncase ECHLD_EOF: break;\r\ncase ECHLD_STOP_CAPTURE: break;\r\ncase ECHLD_CAPTURE_STOPPED: break;\r\ncase ECHLD_ADD_NOTE: break;\r\ncase ECHLD_NOTE_ADDED: break;\r\ncase ECHLD_APPLY_FILTER: break;\r\ncase ECHLD_PACKET_LIST: break;\r\ncase ECHLD_SAVE_FILE: break;\r\ncase ECHLD_FILE_SAVED: break;\r\ncase EC_ACTUAL_ERROR: break;\r\n}\r\nswitch(type) {\r\ncase ECHLD_NEW_CHILD: break;\r\ncase ECHLD_CLOSE_CHILD: break;\r\ncase ECHLD_SET_PARAM: break;\r\ncase ECHLD_GET_PARAM: break;\r\ncase ECHLD_PING: break;\r\ncase ECHLD_OPEN_FILE: break;\r\ncase ECHLD_OPEN_INTERFACE: break;\r\ncase ECHLD_START_CAPTURE: break;\r\ncase ECHLD_GET_SUM: break;\r\ncase ECHLD_GET_TREE: break;\r\ncase ECHLD_GET_BUFFER: break;\r\ncase ECHLD_STOP_CAPTURE: break;\r\ncase ECHLD_ADD_NOTE: break;\r\ncase ECHLD_APPLY_FILTER: break;\r\ncase ECHLD_SAVE_FILE: break;\r\ncase ECHLD_ERROR: break;\r\ncase ECHLD_TIMED_OUT: break;\r\ncase ECHLD_HELLO: break;\r\ncase ECHLD_CHILD_DEAD: break;\r\ncase ECHLD_CLOSING: break;\r\ncase ECHLD_PARAM: break;\r\ncase ECHLD_PONG: break;\r\ncase ECHLD_FILE_OPENED: break;\r\ncase ECHLD_INTERFACE_OPENED: break;\r\ncase ECHLD_CAPTURE_STARTED: break;\r\ncase ECHLD_NOTIFY: break;\r\ncase ECHLD_PACKET_SUM: break;\r\ncase ECHLD_TREE: break;\r\ncase ECHLD_BUFFER: break;\r\ncase ECHLD_EOF: break;\r\ncase ECHLD_CAPTURE_STOPPED: break;\r\ncase ECHLD_NOTE_ADDED: break;\r\ncase ECHLD_PACKET_LIST: break;\r\ncase ECHLD_FILE_SAVED: break;\r\ncase EC_ACTUAL_ERROR: break;\r\n}\r\n}\r\nextern void unused_things(void) {\r\nunused = NULL;\r\n}
