range_t *range_empty(void)\r\n{\r\nrange_t *range;\r\nrange = (range_t *)g_malloc(RANGE_HDR_SIZE);\r\nrange->nranges = 0;\r\nreturn range;\r\n}\r\nconvert_ret_t\r\nrange_convert_str(range_t **rangep, const gchar *es, guint32 max_value)\r\n{\r\nreturn range_convert_str_work(rangep, es, max_value, TRUE);\r\n}\r\nconvert_ret_t\r\nrange_convert_str_work(range_t **rangep, const gchar *es, guint32 max_value,\r\ngboolean err_on_max)\r\n{\r\nrange_t *range;\r\nguint nranges;\r\nconst gchar *p;\r\nchar *endp;\r\ngchar c;\r\nguint i;\r\nguint32 tmp;\r\nunsigned long val;\r\nif ( (rangep == NULL) || (es == NULL) )\r\nreturn CVT_SYNTAX_ERROR;\r\nrange = (range_t *)g_malloc(RANGE_HDR_SIZE + sizeof (range_admin_t));\r\nrange->nranges = 0;\r\nnranges = 1;\r\np = es;\r\nfor (;;) {\r\nwhile ((c = *p) == ' ' || c == '\t')\r\np++;\r\nif (c == '\0')\r\nbreak;\r\nif (range->nranges >= nranges) {\r\nif (nranges == 1)\r\nnranges = 4;\r\nelse\r\nnranges += 4;\r\nrange = (range_t *)g_realloc(range, RANGE_HDR_SIZE +\r\nnranges*sizeof (range_admin_t));\r\n}\r\nif (c == '-') {\r\nrange->ranges[range->nranges].low = 1;\r\n} else if (isdigit((unsigned char)c)) {\r\nerrno = 0;\r\nval = strtoul(p, &endp, 10);\r\nif (p == endp) {\r\ng_free(range);\r\nreturn CVT_SYNTAX_ERROR;\r\n}\r\nif (errno == ERANGE || val > max_value) {\r\nif (err_on_max) {\r\ng_free(range);\r\nreturn CVT_NUMBER_TOO_BIG;\r\n} else {\r\nval = max_value;\r\n}\r\n}\r\np = endp;\r\nrange->ranges[range->nranges].low = (guint32)val;\r\nwhile ((c = *p) == ' ' || c == '\t')\r\np++;\r\n} else {\r\ng_free(range);\r\nreturn CVT_SYNTAX_ERROR;\r\n}\r\nif (c == '-') {\r\np++;\r\nwhile ((c = *p) == ' ' || c == '\t')\r\np++;\r\nif (c == ',' || c == '\0') {\r\nrange->ranges[range->nranges].high = max_value;\r\n} else if (isdigit((unsigned char)c)) {\r\nerrno = 0;\r\nval = strtoul(p, &endp, 10);\r\nif (p == endp) {\r\ng_free(range);\r\nreturn CVT_SYNTAX_ERROR;\r\n}\r\nif (errno == ERANGE || val > max_value) {\r\nif (err_on_max) {\r\ng_free(range);\r\nreturn CVT_NUMBER_TOO_BIG;\r\n} else {\r\nval = max_value;\r\n}\r\n}\r\np = endp;\r\nrange->ranges[range->nranges].high = (guint32)val;\r\nwhile ((c = *p) == ' ' || c == '\t')\r\np++;\r\n} else {\r\ng_free(range);\r\nreturn CVT_SYNTAX_ERROR;\r\n}\r\n} else if (c == ',' || c == '\0') {\r\nrange->ranges[range->nranges].high = range->ranges[range->nranges].low;\r\n} else {\r\ng_free(range);\r\nreturn CVT_SYNTAX_ERROR;\r\n}\r\nrange->nranges++;\r\nif (c == ',') {\r\np++;\r\n}\r\n}\r\nfor (i=0; i < range->nranges; i++) {\r\nif (range->ranges[i].low > range->ranges[i].high) {\r\ntmp = range->ranges[i].low;\r\nrange->ranges[i].low = range->ranges[i].high;\r\nrange->ranges[i].high = tmp;\r\n}\r\n}\r\n*rangep = range;\r\nreturn CVT_NO_ERROR;\r\n}\r\ngboolean\r\nvalue_is_in_range(range_t *range, guint32 val)\r\n{\r\nguint i;\r\nif (range) {\r\nfor (i=0; i < range->nranges; i++) {\r\nif (val >= range->ranges[i].low && val <= range->ranges[i].high)\r\nreturn TRUE;\r\n}\r\n}\r\nreturn(FALSE);\r\n}\r\ngboolean\r\nranges_are_equal(range_t *a, range_t *b)\r\n{\r\nguint i;\r\nif ( (a == NULL) || (b == NULL) )\r\nreturn FALSE;\r\nif (a->nranges != b->nranges)\r\nreturn FALSE;\r\nfor (i=0; i < a->nranges; i++) {\r\nif (a->ranges[i].low != b->ranges[i].low)\r\nreturn FALSE;\r\nif (a->ranges[i].high != b->ranges[i].high)\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nvoid\r\nrange_foreach(range_t *range, void (*callback)(guint32 val))\r\n{\r\nguint32 i, j;\r\nif (range && callback) {\r\nfor (i=0; i < range->nranges; i++) {\r\nfor (j = range->ranges[i].low; j <= range->ranges[i].high; j++)\r\ncallback(j);\r\n}\r\n}\r\n}\r\nchar *\r\nrange_convert_range(range_t *range)\r\n{\r\nguint32 i;\r\ngboolean prepend_comma = FALSE;\r\nemem_strbuf_t *strbuf;\r\nstrbuf=ep_strbuf_new(NULL);\r\nif (range) {\r\nfor (i=0; i < range->nranges; i++) {\r\nif (range->ranges[i].low == range->ranges[i].high) {\r\nep_strbuf_append_printf(strbuf, "%s%u", prepend_comma?",":"", range->ranges[i].low);\r\n} else {\r\nep_strbuf_append_printf(strbuf, "%s%u-%u", prepend_comma?",":"", range->ranges[i].low, range->ranges[i].high);\r\n}\r\nprepend_comma = TRUE;\r\n}\r\n}\r\nreturn strbuf->str;\r\n}\r\nrange_t *\r\nrange_copy(range_t *src)\r\n{\r\nrange_t *dst;\r\nsize_t range_size;\r\nif (src == NULL)\r\nreturn NULL;\r\nrange_size = RANGE_HDR_SIZE + src->nranges*sizeof (range_admin_t);\r\ndst = (range_t *)g_malloc(range_size);\r\nmemcpy(dst, src, range_size);\r\nreturn dst;\r\n}
