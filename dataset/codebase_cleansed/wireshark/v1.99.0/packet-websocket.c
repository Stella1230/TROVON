static tvbuff_t *\r\ntvb_unmasked(tvbuff_t *tvb, const guint offset, guint payload_length, const guint8 *masking_key)\r\n{\r\ngchar *data_unmask;\r\ntvbuff_t *tvb_unmask = NULL;\r\nguint i;\r\nconst guint8 *data_mask;\r\nguint unmasked_length = payload_length > MAX_UNMASKED_LEN ? MAX_UNMASKED_LEN : payload_length;\r\ndata_unmask = (gchar *)g_malloc(unmasked_length);\r\ndata_mask = tvb_get_ptr(tvb, offset, unmasked_length);\r\nfor(i=0; i < unmasked_length; i++) {\r\ndata_unmask[i] = data_mask[i] ^ masking_key[i%4];\r\n}\r\ntvb_unmask = tvb_new_real_data(data_unmask, unmasked_length, payload_length);\r\ntvb_set_free_cb(tvb_unmask, g_free);\r\nreturn tvb_unmask;\r\n}\r\nstatic int\r\ndissect_websocket_payload(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, proto_tree *ws_tree, guint8 opcode, guint payload_length, guint8 mask, const guint8* masking_key)\r\n{\r\nguint offset = 0;\r\nproto_item *ti_unmask, *ti;\r\ndissector_handle_t handle;\r\nproto_tree *pl_tree, *mask_tree = NULL;\r\ntvbuff_t *payload_tvb = NULL;\r\nheur_dtbl_entry_t *hdtbl_entry;\r\nti = proto_tree_add_item(ws_tree, hf_ws_payload, tvb, offset, payload_length, ENC_NA);\r\npl_tree = proto_item_add_subtree(ti, ett_ws_pl);\r\nif (mask) {\r\npayload_tvb = tvb_unmasked(tvb, offset, payload_length, masking_key);\r\ntvb_set_child_real_data_tvbuff(tvb, payload_tvb);\r\nadd_new_data_source(pinfo, payload_tvb, payload_length > tvb_captured_length(payload_tvb) ? "Unmasked Data (truncated)" : "Unmasked Data");\r\nti = proto_tree_add_item(ws_tree, hf_ws_payload_unmask, payload_tvb, offset, payload_length, ENC_NA);\r\nif (payload_length > tvb_captured_length(payload_tvb)) {\r\nproto_item_append_text(ti, " [truncated]");\r\n}\r\nmask_tree = proto_item_add_subtree(ti, ett_ws_mask);\r\n} else {\r\npayload_tvb = tvb_new_subset(tvb, offset, payload_length, -1);\r\n}\r\nhandle = dissector_get_uint_handle(port_subdissector_table, pinfo->match_uint);\r\nif (handle != NULL) {\r\ncall_dissector_only(handle, payload_tvb, pinfo, tree, NULL);\r\n} else {\r\ndissector_try_heuristic(heur_subdissector_list, payload_tvb, pinfo, tree, &hdtbl_entry, NULL);\r\n}\r\nswitch (opcode) {\r\ncase WS_CONTINUE:\r\nproto_tree_add_item(pl_tree, hf_ws_payload_continue, tvb, offset, payload_length, ENC_NA);\r\nbreak;\r\ncase WS_TEXT:\r\nif (mask) {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_text_mask, tvb, offset, payload_length, ENC_NA);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_text_unmask, payload_tvb, offset, payload_length, ENC_UTF_8|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(ti_unmask);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_text, payload_tvb, offset, payload_length, ENC_UTF_8|ENC_NA);\r\nPROTO_ITEM_SET_HIDDEN(ti_unmask);\r\n} else {\r\nconst gchar *saved_match_string = pinfo->match_string;\r\nvoid *save_private_data = pinfo->private_data;\r\npinfo->match_string = NULL;\r\npinfo->private_data = NULL;\r\nswitch (pref_text_type) {\r\ncase WEBSOCKET_TEXT:\r\ncall_dissector(text_lines_handle, payload_tvb, pinfo, pl_tree);\r\nbreak;\r\ncase WEBSOCKET_JSON:\r\ncall_dissector(json_handle, payload_tvb, pinfo, pl_tree);\r\nbreak;\r\ncase WEBSOCKET_SIP:\r\ncall_dissector(sip_handle, payload_tvb, pinfo, pl_tree);\r\nbreak;\r\ncase WEBSOCKET_NONE:\r\ndefault:\r\nproto_tree_add_item(pl_tree, hf_ws_payload_text, tvb, offset, payload_length, ENC_UTF_8|ENC_NA);\r\nbreak;\r\n}\r\npinfo->match_string = saved_match_string;\r\npinfo->private_data = save_private_data;\r\n}\r\noffset += payload_length;\r\nbreak;\r\ncase WS_BINARY:\r\nif (mask) {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_binary_mask, tvb, offset, payload_length, ENC_NA);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_binary_unmask, payload_tvb, offset, payload_length, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(ti_unmask);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_binary, payload_tvb, offset, payload_length, ENC_NA);\r\nPROTO_ITEM_SET_HIDDEN(ti_unmask);\r\n} else {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_binary, tvb, offset, payload_length, ENC_NA);\r\n}\r\noffset += payload_length;\r\nbreak;\r\ncase WS_CLOSE:\r\nif (mask) {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_close_mask, tvb, offset, payload_length, ENC_NA);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_close_unmask, payload_tvb, offset, payload_length, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(ti_unmask);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_close, payload_tvb, offset, payload_length, ENC_NA);\r\nPROTO_ITEM_SET_HIDDEN(ti_unmask);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_close_status_code, payload_tvb, offset, 2, ENC_BIG_ENDIAN);\r\nPROTO_ITEM_SET_GENERATED(ti_unmask);\r\nif (payload_length > 2) {\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_close_reason, payload_tvb, offset+2, payload_length-2, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(ti_unmask);\r\n}\r\n} else {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_close, tvb, offset, payload_length, ENC_NA);\r\nproto_tree_add_item(pl_tree, hf_ws_payload_close_status_code, tvb, offset, 2, ENC_BIG_ENDIAN);\r\nif (payload_length > 2) {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_close_reason, tvb, offset+2, payload_length-2, ENC_ASCII|ENC_NA);\r\n}\r\n}\r\noffset += payload_length;\r\nbreak;\r\ncase WS_PING:\r\nif (mask) {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_ping_mask, tvb, offset, payload_length, ENC_NA);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_ping_unmask, payload_tvb, offset, payload_length, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(ti_unmask);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_ping, payload_tvb, offset, payload_length, ENC_NA);\r\nPROTO_ITEM_SET_HIDDEN(ti_unmask);\r\n} else {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_ping, tvb, offset, payload_length, ENC_NA);\r\n}\r\noffset += payload_length;\r\nbreak;\r\ncase WS_PONG:\r\nif (mask) {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_pong_mask, tvb, offset, payload_length, ENC_NA);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_pong_unmask, payload_tvb, offset, payload_length, ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(ti_unmask);\r\nti_unmask = proto_tree_add_item(mask_tree, hf_ws_payload_pong, payload_tvb, offset, payload_length, ENC_NA);\r\nPROTO_ITEM_SET_HIDDEN(ti_unmask);\r\n} else {\r\nproto_tree_add_item(pl_tree, hf_ws_payload_pong, tvb, offset, payload_length, ENC_NA);\r\n}\r\noffset += payload_length;\r\nbreak;\r\ndefault:\r\nti = proto_tree_add_item(pl_tree, hf_ws_payload_unknown, tvb, offset, payload_length, ENC_NA);\r\nexpert_add_info_format(pinfo, ti, &ei_ws_payload_unknown, "Dissector for Websocket Opcode (%d)"\r\n" code not implemented, Contact Wireshark developers"\r\n" if you want this supported", opcode);\r\nbreak;\r\n}\r\nreturn offset;\r\n}\r\nstatic int\r\ndissect_websocket(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti, *ti_len;\r\nguint8 fin, opcode, mask;\r\nguint length, short_length, payload_length, recurse_length;\r\nguint payload_offset, mask_offset, recurse_offset;\r\nproto_tree *ws_tree = NULL;\r\nconst guint8 *masking_key = NULL;\r\ntvbuff_t *tvb_payload;\r\nlength = tvb_length(tvb);\r\nif (length < 2) {\r\npinfo->desegment_len = 2;\r\nreturn 0;\r\n}\r\nshort_length = tvb_get_guint8(tvb, 1) & MASK_WS_PAYLOAD_LEN;\r\nif (short_length == 126) {\r\nif (length < 2+2) {\r\npinfo->desegment_len = 2+2;\r\nreturn 0;\r\n}\r\npayload_length = tvb_get_ntohs(tvb, 2);\r\nmask_offset = 2+2;\r\n}\r\nelse if (short_length == 127) {\r\nif (length < 2+8) {\r\npinfo->desegment_len = 2+8;\r\nreturn 0;\r\n}\r\npayload_length = (guint)tvb_get_ntoh64(tvb, 2);\r\nmask_offset = 2+8;\r\n}\r\nelse{\r\npayload_length = short_length;\r\nmask_offset = 2;\r\n}\r\nmask = (tvb_get_guint8(tvb, 1) & MASK_WS_MASK) >> 4;\r\npayload_offset = mask_offset + (mask ? 4 : 0);\r\nif (payload_offset + payload_length < payload_length) {\r\npayload_length = tvb_reported_length_remaining(tvb, payload_offset);\r\n}\r\nif (length < payload_offset + payload_length) {\r\npinfo->desegment_len = payload_offset + payload_length - length;\r\nreturn 0;\r\n}\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "WebSocket");\r\ncol_set_str(pinfo->cinfo, COL_INFO, "WebSocket");\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_websocket, tvb, 0, payload_offset, ENC_NA);\r\nws_tree = proto_item_add_subtree(ti, ett_ws);\r\n}\r\nproto_tree_add_item(ws_tree, hf_ws_fin, tvb, 0, 1, ENC_NA);\r\nfin = (tvb_get_guint8(tvb, 0) & MASK_WS_FIN) >> 4;\r\nproto_tree_add_item(ws_tree, hf_ws_reserved, tvb, 0, 1, ENC_NA);\r\nproto_tree_add_item(ws_tree, hf_ws_opcode, tvb, 0, 1, ENC_NA);\r\nopcode = tvb_get_guint8(tvb, 0) & MASK_WS_OPCODE;\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " %s", val_to_str_const(opcode, ws_opcode_vals, "Unknown Opcode"));\r\ncol_append_str(pinfo->cinfo, COL_INFO, fin ? " [FIN]" : " ");\r\nproto_tree_add_item(ws_tree, hf_ws_mask, tvb, 1, 1, ENC_NA);\r\ncol_append_str(pinfo->cinfo, COL_INFO, mask ? " [MASKED]" : " ");\r\nti_len = proto_tree_add_item(ws_tree, hf_ws_payload_length, tvb, 1, 1, ENC_NA);\r\nif (short_length == 126) {\r\nproto_item_append_text(ti_len, " Extended Payload Length (16 bits)");\r\nproto_tree_add_item(ws_tree, hf_ws_payload_length_ext_16, tvb, 2, 2, ENC_BIG_ENDIAN);\r\n}\r\nelse if (short_length == 127) {\r\nproto_item_append_text(ti_len, " Extended Payload Length (64 bits)");\r\nproto_tree_add_item(ws_tree, hf_ws_payload_length_ext_64, tvb, 2, 8, ENC_BIG_ENDIAN);\r\n}\r\nif (mask) {\r\nproto_tree_add_item(ws_tree, hf_ws_masking_key, tvb, mask_offset, 4, ENC_NA);\r\nmasking_key = tvb_get_ptr(tvb, mask_offset, 4);\r\n}\r\ntvb_payload = tvb_new_subset_remaining(tvb, payload_offset);\r\ndissect_websocket_payload(tvb_payload, pinfo, tree, ws_tree, opcode, payload_length, mask, masking_key);\r\nrecurse_offset = payload_offset + payload_length;\r\nif (length > recurse_offset) {\r\nrecurse_length = dissect_websocket(tvb_new_subset_remaining(tvb, payload_offset+payload_length), pinfo, tree, data);\r\nif (pinfo->desegment_len) pinfo->desegment_offset += recurse_offset;\r\nreturn recurse_offset + recurse_length;\r\n}\r\nreturn recurse_offset;\r\n}\r\nvoid\r\nproto_register_websocket(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_ws_fin,\r\n{ "Fin", "websocket.fin",\r\nFT_BOOLEAN, 8, NULL, MASK_WS_FIN,\r\n"Indicates that this is the final fragment in a message", HFILL }\r\n},\r\n{ &hf_ws_reserved,\r\n{ "Reserved", "websocket.rsv",\r\nFT_UINT8, BASE_HEX, NULL, MASK_WS_RSV,\r\n"Must be zero", HFILL }\r\n},\r\n{ &hf_ws_opcode,\r\n{ "Opcode", "websocket.opcode",\r\nFT_UINT8, BASE_DEC, VALS(ws_opcode_vals), MASK_WS_OPCODE,\r\n"Defines the interpretation of the Payload data", HFILL }\r\n},\r\n{ &hf_ws_mask,\r\n{ "Mask", "websocket.mask",\r\nFT_BOOLEAN, 8, NULL, MASK_WS_MASK,\r\n"Defines whether the Payload data is masked", HFILL }\r\n},\r\n{ &hf_ws_payload_length,\r\n{ "Payload length", "websocket.payload_length",\r\nFT_UINT8, BASE_DEC, NULL, MASK_WS_PAYLOAD_LEN,\r\n"The length of the Payload data", HFILL }\r\n},\r\n{ &hf_ws_payload_length_ext_16,\r\n{ "Extended Payload length (16 bits)", "websocket.payload_length_ext_16",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"The length (16 bits) of the Payload data", HFILL }\r\n},\r\n{ &hf_ws_payload_length_ext_64,\r\n{ "Extended Payload length (64 bits)", "websocket.payload_length_ext_64",\r\nFT_UINT64, BASE_DEC, NULL, 0x0,\r\n"The length (64 bits) of the Payload data", HFILL }\r\n},\r\n{ &hf_ws_masking_key,\r\n{ "Masking-Key", "websocket.masking_key",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"All frames sent from the client to the server are masked by a 32-bit value that is contained within the frame", HFILL }\r\n},\r\n{ &hf_ws_payload,\r\n{ "Payload", "websocket.payload",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_unmask,\r\n{ "Unmask Payload", "websocket.payload.unmask",\r\nFT_NONE, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_continue,\r\n{ "Continue", "websocket.payload.continue",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_text,\r\n{ "Text", "websocket.payload.text",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_text_mask,\r\n{ "Text", "websocket.payload.text_mask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_text_unmask,\r\n{ "Text unmask", "websocket.payload.text_unmask",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_binary,\r\n{ "Binary", "websocket.payload.binary",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_binary_mask,\r\n{ "Binary", "websocket.payload.binary_mask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_binary_unmask,\r\n{ "Binary", "websocket.payload.binary_unmask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_close,\r\n{ "Close", "websocket.payload.close",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_close_mask,\r\n{ "Close", "websocket.payload.close_mask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_close_unmask,\r\n{ "Unmask Close", "websocket.payload.close_unmask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_close_status_code,\r\n{ "Close", "websocket.payload.close.status_code",\r\nFT_UINT16, BASE_DEC, VALS(ws_close_status_code_vals), 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_close_reason,\r\n{ "Reason", "websocket.payload.close.reason",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_ping,\r\n{ "Ping", "websocket.payload.ping",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_ping_mask,\r\n{ "Ping", "websocket.payload.ping_mask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_ping_unmask,\r\n{ "Ping", "websocket.payload.ping_unmask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_pong,\r\n{ "Pong", "websocket.payload.pong",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_pong_mask,\r\n{ "Pong", "websocket.payload.pong_mask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_pong_unmask,\r\n{ "Pong", "websocket.payload.pong_unmask",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_ws_payload_unknown,\r\n{ "Unknown", "websocket.payload.unknown",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_ws,\r\n&ett_ws_pl,\r\n&ett_ws_mask\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_ws_payload_unknown, { "websocket.payload.unknown.expert", PI_UNDECODED, PI_NOTE, "Dissector for Websocket Opcode", EXPFILL }},\r\n};\r\nstatic const enum_val_t text_types[] = {\r\n{"None", "No subdissection", WEBSOCKET_NONE},\r\n{"Line based text", "Line based text", WEBSOCKET_TEXT},\r\n{"As JSON", "As json", WEBSOCKET_JSON},\r\n{"As SIP", "As SIP", WEBSOCKET_SIP},\r\n{NULL, NULL, -1}\r\n};\r\nmodule_t *websocket_module;\r\nexpert_module_t* expert_websocket;\r\nproto_websocket = proto_register_protocol("WebSocket",\r\n"WebSocket", "websocket");\r\nregister_heur_dissector_list("ws", &heur_subdissector_list);\r\nport_subdissector_table = register_dissector_table("ws.port",\r\n"TCP port for protocols using WebSocket", FT_UINT16, BASE_DEC);\r\nproto_register_field_array(proto_websocket, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_websocket = expert_register_protocol(proto_websocket);\r\nexpert_register_field_array(expert_websocket, ei, array_length(ei));\r\nnew_register_dissector("websocket", dissect_websocket, proto_websocket);\r\nwebsocket_module = prefs_register_protocol(proto_websocket, proto_reg_handoff_websocket);\r\nprefs_register_enum_preference(websocket_module, "text_type",\r\n"Dissect websocket text as",\r\n"Select dissector for websocket text",\r\n&pref_text_type, text_types, WEBSOCKET_NONE);\r\n}\r\nvoid\r\nproto_reg_handoff_websocket(void)\r\n{\r\ntext_lines_handle = find_dissector("data-text-lines");\r\njson_handle = find_dissector("json");\r\nsip_handle = find_dissector("sip");\r\n}
