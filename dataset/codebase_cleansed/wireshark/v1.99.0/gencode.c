static void\r\ndfw_append_insn(dfwork_t *dfw, dfvm_insn_t *insn)\r\n{\r\ninsn->id = dfw->next_insn_id;\r\ndfw->next_insn_id++;\r\ng_ptr_array_add(dfw->insns, insn);\r\n}\r\nstatic void\r\ndfw_append_const(dfwork_t *dfw, dfvm_insn_t *insn)\r\n{\r\ninsn->id = dfw->next_const_id;\r\ndfw->next_const_id++;\r\ng_ptr_array_add(dfw->consts, insn);\r\n}\r\nstatic int\r\ndfw_append_read_tree(dfwork_t *dfw, header_field_info *hfinfo)\r\n{\r\ndfvm_insn_t *insn;\r\ndfvm_value_t *val1, *val2;\r\nint reg = -1;\r\ngboolean added_new_hfinfo = FALSE;\r\nwhile (hfinfo->same_name_prev_id != -1) {\r\nhfinfo = proto_registrar_get_nth(hfinfo->same_name_prev_id);\r\n}\r\nreg = GPOINTER_TO_INT(\r\ng_hash_table_lookup(dfw->loaded_fields, hfinfo));\r\nif (reg) {\r\nreg--;\r\n}\r\nelse {\r\nreg = dfw->next_register++;\r\ng_hash_table_insert(dfw->loaded_fields,\r\nhfinfo, GINT_TO_POINTER(reg + 1));\r\nadded_new_hfinfo = TRUE;\r\n}\r\ninsn = dfvm_insn_new(READ_TREE);\r\nval1 = dfvm_value_new(HFINFO);\r\nval1->value.hfinfo = hfinfo;\r\nval2 = dfvm_value_new(REGISTER);\r\nval2->value.numeric = reg;\r\ninsn->arg1 = val1;\r\ninsn->arg2 = val2;\r\ndfw_append_insn(dfw, insn);\r\nif (added_new_hfinfo) {\r\nwhile (hfinfo) {\r\ng_hash_table_insert(dfw->interesting_fields,\r\nGINT_TO_POINTER(hfinfo->id),\r\nGUINT_TO_POINTER(TRUE));\r\nhfinfo = hfinfo->same_name_next;\r\n}\r\n}\r\nreturn reg;\r\n}\r\nstatic int\r\ndfw_append_put_fvalue(dfwork_t *dfw, fvalue_t *fv)\r\n{\r\ndfvm_insn_t *insn;\r\ndfvm_value_t *val1, *val2;\r\nint reg;\r\ninsn = dfvm_insn_new(PUT_FVALUE);\r\nval1 = dfvm_value_new(FVALUE);\r\nval1->value.fvalue = fv;\r\nval2 = dfvm_value_new(REGISTER);\r\nreg = dfw->first_constant--;\r\nval2->value.numeric = reg;\r\ninsn->arg1 = val1;\r\ninsn->arg2 = val2;\r\ndfw_append_const(dfw, insn);\r\nreturn reg;\r\n}\r\nstatic int\r\ndfw_append_mk_range(dfwork_t *dfw, stnode_t *node, dfvm_value_t **p_jmp)\r\n{\r\nint hf_reg, reg;\r\nstnode_t *entity;\r\ndfvm_insn_t *insn;\r\ndfvm_value_t *val;\r\nentity = sttype_range_entity(node);\r\nhf_reg = gen_entity(dfw, entity, p_jmp);\r\ninsn = dfvm_insn_new(MK_RANGE);\r\nval = dfvm_value_new(REGISTER);\r\nval->value.numeric = hf_reg;\r\ninsn->arg1 = val;\r\nval = dfvm_value_new(REGISTER);\r\nreg =dfw->next_register++;\r\nval->value.numeric = reg;\r\ninsn->arg2 = val;\r\nval = dfvm_value_new(DRANGE);\r\nval->value.drange = sttype_range_drange(node);\r\ninsn->arg3 = val;\r\nsttype_range_remove_drange(node);\r\ndfw_append_insn(dfw, insn);\r\nreturn reg;\r\n}\r\nstatic int\r\ndfw_append_function(dfwork_t *dfw, stnode_t *node, dfvm_value_t **p_jmp)\r\n{\r\nGSList *params;\r\nint i, num_params, reg;\r\ndfvm_value_t **jmps;\r\ndfvm_insn_t *insn;\r\ndfvm_value_t *val1, *val2, *val;\r\nparams = sttype_function_params(node);\r\nnum_params = g_slist_length(params);\r\njmps = (dfvm_value_t **)g_malloc(num_params * sizeof(dfvm_value_t*));\r\ninsn = dfvm_insn_new(CALL_FUNCTION);\r\nval1 = dfvm_value_new(FUNCTION_DEF);\r\nval1->value.funcdef = sttype_function_funcdef(node);\r\ninsn->arg1 = val1;\r\nval2 = dfvm_value_new(REGISTER);\r\nval2->value.numeric = dfw->next_register++;\r\ninsn->arg2 = val2;\r\ninsn->arg3 = NULL;\r\ninsn->arg4 = NULL;\r\ni = 0;\r\nwhile (params) {\r\njmps[i] = NULL;\r\nreg = gen_entity(dfw, (stnode_t *)params->data, &jmps[i]);\r\nval = dfvm_value_new(REGISTER);\r\nval->value.numeric = reg;\r\nswitch(i) {\r\ncase 0:\r\ninsn->arg3 = val;\r\nbreak;\r\ncase 1:\r\ninsn->arg4 = val;\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\n}\r\nparams = params->next;\r\ni++;\r\n}\r\ndfw_append_insn(dfw, insn);\r\nfor (i = 0; i < num_params; i++) {\r\nif (jmps[i]) {\r\njmps[i]->value.numeric = dfw->next_insn_id;\r\n}\r\n}\r\ninsn = dfvm_insn_new(IF_FALSE_GOTO);\r\ng_assert(p_jmp);\r\n*p_jmp = dfvm_value_new(INSN_NUMBER);\r\ninsn->arg1 = *p_jmp;\r\ndfw_append_insn(dfw, insn);\r\ng_free(jmps);\r\nreturn val2->value.numeric;\r\n}\r\nstatic void\r\ngen_relation(dfwork_t *dfw, dfvm_opcode_t op, stnode_t *st_arg1, stnode_t *st_arg2)\r\n{\r\ndfvm_insn_t *insn;\r\ndfvm_value_t *val1, *val2;\r\ndfvm_value_t *jmp1 = NULL, *jmp2 = NULL;\r\nint reg1 = -1, reg2 = -1;\r\nreg1 = gen_entity(dfw, st_arg1, &jmp1);\r\nreg2 = gen_entity(dfw, st_arg2, &jmp2);\r\ninsn = dfvm_insn_new(op);\r\nval1 = dfvm_value_new(REGISTER);\r\nval1->value.numeric = reg1;\r\nval2 = dfvm_value_new(REGISTER);\r\nval2->value.numeric = reg2;\r\ninsn->arg1 = val1;\r\ninsn->arg2 = val2;\r\ndfw_append_insn(dfw, insn);\r\nif (jmp1) {\r\njmp1->value.numeric = dfw->next_insn_id;\r\n}\r\nif (jmp2) {\r\njmp2->value.numeric = dfw->next_insn_id;\r\n}\r\n}\r\nstatic int\r\ngen_entity(dfwork_t *dfw, stnode_t *st_arg, dfvm_value_t **p_jmp)\r\n{\r\nsttype_id_t e_type;\r\ndfvm_insn_t *insn;\r\nheader_field_info *hfinfo;\r\nint reg = -1;\r\ne_type = stnode_type_id(st_arg);\r\nif (e_type == STTYPE_FIELD) {\r\nhfinfo = (header_field_info*)stnode_data(st_arg);\r\nreg = dfw_append_read_tree(dfw, hfinfo);\r\ninsn = dfvm_insn_new(IF_FALSE_GOTO);\r\ng_assert(p_jmp);\r\n*p_jmp = dfvm_value_new(INSN_NUMBER);\r\ninsn->arg1 = *p_jmp;\r\ndfw_append_insn(dfw, insn);\r\n}\r\nelse if (e_type == STTYPE_FVALUE) {\r\nreg = dfw_append_put_fvalue(dfw, (fvalue_t *)stnode_data(st_arg));\r\n}\r\nelse if (e_type == STTYPE_RANGE) {\r\nreg = dfw_append_mk_range(dfw, st_arg, p_jmp);\r\n}\r\nelse if (e_type == STTYPE_FUNCTION) {\r\nreg = dfw_append_function(dfw, st_arg, p_jmp);\r\n}\r\nelse {\r\nprintf("sttype_id is %u\n", e_type);\r\ng_assert_not_reached();\r\n}\r\nreturn reg;\r\n}\r\nstatic void\r\ngen_test(dfwork_t *dfw, stnode_t *st_node)\r\n{\r\ntest_op_t st_op;\r\nstnode_t *st_arg1, *st_arg2;\r\ndfvm_value_t *val1;\r\ndfvm_insn_t *insn;\r\nheader_field_info *hfinfo;\r\nsttype_test_get(st_node, &st_op, &st_arg1, &st_arg2);\r\nswitch (st_op) {\r\ncase TEST_OP_UNINITIALIZED:\r\ng_assert_not_reached();\r\nbreak;\r\ncase TEST_OP_EXISTS:\r\nval1 = dfvm_value_new(HFINFO);\r\nhfinfo = (header_field_info*)stnode_data(st_arg1);\r\nwhile (hfinfo->same_name_prev_id != -1) {\r\nhfinfo = proto_registrar_get_nth(hfinfo->same_name_prev_id);\r\n}\r\nval1->value.hfinfo = hfinfo;\r\ninsn = dfvm_insn_new(CHECK_EXISTS);\r\ninsn->arg1 = val1;\r\ndfw_append_insn(dfw, insn);\r\nwhile (hfinfo) {\r\ng_hash_table_insert(dfw->interesting_fields,\r\nGINT_TO_POINTER(hfinfo->id),\r\nGUINT_TO_POINTER(TRUE));\r\nhfinfo = hfinfo->same_name_next;\r\n}\r\nbreak;\r\ncase TEST_OP_NOT:\r\ngencode(dfw, st_arg1);\r\ninsn = dfvm_insn_new(NOT);\r\ndfw_append_insn(dfw, insn);\r\nbreak;\r\ncase TEST_OP_AND:\r\ngencode(dfw, st_arg1);\r\ninsn = dfvm_insn_new(IF_FALSE_GOTO);\r\nval1 = dfvm_value_new(INSN_NUMBER);\r\ninsn->arg1 = val1;\r\ndfw_append_insn(dfw, insn);\r\ngencode(dfw, st_arg2);\r\nval1->value.numeric = dfw->next_insn_id;\r\nbreak;\r\ncase TEST_OP_OR:\r\ngencode(dfw, st_arg1);\r\ninsn = dfvm_insn_new(IF_TRUE_GOTO);\r\nval1 = dfvm_value_new(INSN_NUMBER);\r\ninsn->arg1 = val1;\r\ndfw_append_insn(dfw, insn);\r\ngencode(dfw, st_arg2);\r\nval1->value.numeric = dfw->next_insn_id;\r\nbreak;\r\ncase TEST_OP_EQ:\r\ngen_relation(dfw, ANY_EQ, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_NE:\r\ngen_relation(dfw, ANY_NE, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_GT:\r\ngen_relation(dfw, ANY_GT, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_GE:\r\ngen_relation(dfw, ANY_GE, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_LT:\r\ngen_relation(dfw, ANY_LT, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_LE:\r\ngen_relation(dfw, ANY_LE, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_BITWISE_AND:\r\ngen_relation(dfw, ANY_BITWISE_AND, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_CONTAINS:\r\ngen_relation(dfw, ANY_CONTAINS, st_arg1, st_arg2);\r\nbreak;\r\ncase TEST_OP_MATCHES:\r\ngen_relation(dfw, ANY_MATCHES, st_arg1, st_arg2);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ngencode(dfwork_t *dfw, stnode_t *st_node)\r\n{\r\nstnode_type_name(st_node);\r\nswitch (stnode_type_id(st_node)) {\r\ncase STTYPE_TEST:\r\ngen_test(dfw, st_node);\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\n}\r\n}\r\nvoid\r\ndfw_gencode(dfwork_t *dfw)\r\n{\r\nint id, id1, length;\r\ndfvm_insn_t *insn, *insn1, *prev;\r\ndfvm_value_t *arg1;\r\ndfw->insns = g_ptr_array_new();\r\ndfw->consts = g_ptr_array_new();\r\ndfw->loaded_fields = g_hash_table_new(g_direct_hash, g_direct_equal);\r\ndfw->interesting_fields = g_hash_table_new(g_direct_hash, g_direct_equal);\r\ngencode(dfw, dfw->st_root);\r\ndfw_append_insn(dfw, dfvm_insn_new(RETURN));\r\nlength = dfw->insns->len;\r\nfor (id = 0, prev = NULL; id < length; prev = insn, id++) {\r\ninsn = (dfvm_insn_t *)g_ptr_array_index(dfw->insns, id);\r\narg1 = insn->arg1;\r\nif (insn->op == IF_TRUE_GOTO || insn->op == IF_FALSE_GOTO) {\r\ndfvm_opcode_t revert = (insn->op == IF_FALSE_GOTO)?IF_TRUE_GOTO:IF_FALSE_GOTO;\r\nid1 = arg1->value.numeric;\r\ndo {\r\ninsn1 = (dfvm_insn_t*)g_ptr_array_index(dfw->insns, id1);\r\nif (insn1->op == revert) {\r\nid1 = id1 +1;\r\ncontinue;\r\n}\r\nelse if (insn1->op == READ_TREE && prev && prev->op == READ_TREE &&\r\nprev->arg2->value.numeric == insn1->arg2->value.numeric) {\r\nid1 = id1 +1;\r\ncontinue;\r\n}\r\nelse if (insn1->op != insn->op) {\r\narg1 = insn->arg1;\r\narg1->value.numeric = id1;\r\nbreak;\r\n}\r\narg1 = insn1->arg1;\r\nid1 = arg1->value.numeric;\r\n} while (1);\r\n}\r\n}\r\nif (dfw->first_constant == -1) {\r\ndfw->first_constant = dfw->next_register;\r\nreturn;\r\n}\r\nid = -dfw->first_constant -1;\r\ndfw->first_constant = dfw->next_register;\r\ndfw->next_register += id;\r\nlength = dfw->consts->len;\r\nfor (id = 0; id < length; id++) {\r\ninsn = (dfvm_insn_t *)g_ptr_array_index(dfw->consts, id);\r\nif (insn->arg2 && insn->arg2->type == REGISTER && (int)insn->arg2->value.numeric < 0 )\r\ninsn->arg2->value.numeric = dfw->first_constant - insn->arg2->value.numeric -1;\r\n}\r\nlength = dfw->insns->len;\r\nfor (id = 0; id < length; id++) {\r\ninsn = (dfvm_insn_t *)g_ptr_array_index(dfw->insns, id);\r\nif (insn->arg1 && insn->arg1->type == REGISTER && (int)insn->arg1->value.numeric < 0 )\r\ninsn->arg1->value.numeric = dfw->first_constant - insn->arg1->value.numeric -1;\r\nif (insn->arg2 && insn->arg2->type == REGISTER && (int)insn->arg2->value.numeric < 0 )\r\ninsn->arg2->value.numeric = dfw->first_constant - insn->arg2->value.numeric -1;\r\nif (insn->arg3 && insn->arg3->type == REGISTER && (int)insn->arg3->value.numeric < 0 )\r\ninsn->arg3->value.numeric = dfw->first_constant - insn->arg3->value.numeric -1;\r\nif (insn->arg4 && insn->arg4->type == REGISTER && (int)insn->arg4->value.numeric < 0 )\r\ninsn->arg4->value.numeric = dfw->first_constant - insn->arg4->value.numeric -1;\r\n}\r\n}\r\nstatic void\r\nget_hash_key(gpointer key, gpointer value _U_, gpointer user_data)\r\n{\r\nint field_id = GPOINTER_TO_INT(key);\r\nhash_key_iterator *hki = (hash_key_iterator *)user_data;\r\nhki->fields[hki->i] = field_id;\r\nhki->i++;\r\n}\r\nint*\r\ndfw_interesting_fields(dfwork_t *dfw, int *caller_num_fields)\r\n{\r\nint num_fields = g_hash_table_size(dfw->interesting_fields);\r\nhash_key_iterator hki;\r\nif (num_fields == 0) {\r\n*caller_num_fields = 0;\r\nreturn NULL;\r\n}\r\nhki.fields = g_new(int, num_fields);\r\nhki.i = 0;\r\ng_hash_table_foreach(dfw->interesting_fields, get_hash_key, &hki);\r\n*caller_num_fields = num_fields;\r\nreturn hki.fields;\r\n}
