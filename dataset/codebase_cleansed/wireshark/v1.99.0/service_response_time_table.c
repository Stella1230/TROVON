static void\r\nsrt_select_filter_cb(GtkWidget *widget _U_, gpointer callback_data, guint callback_action)\r\n{\r\nsrt_stat_table *rst = (srt_stat_table *)callback_data;\r\nchar *str = NULL;\r\nGtkTreeIter iter;\r\nGtkTreeModel *model;\r\nGtkTreeSelection *sel;\r\nint selection;\r\nif(rst->filter_string==NULL){\r\nreturn;\r\n}\r\nsel = gtk_tree_view_get_selection (GTK_TREE_VIEW(rst->table));\r\nif (!gtk_tree_selection_get_selected(sel, &model, &iter))\r\nreturn;\r\ngtk_tree_model_get (model, &iter, INDEX_COLUMN, &selection, -1);\r\nif(selection>=(int)rst->num_procs){\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK, "No procedure selected");\r\nreturn;\r\n}\r\nstr = g_strdup_printf("%s==%d", rst->filter_string, selection);\r\napply_selected_filter (callback_action, str);\r\ng_free(str);\r\n}\r\nstatic gboolean\r\nsrt_show_popup_menu_cb(void *widg _U_, GdkEvent *event, srt_stat_table *rst)\r\n{\r\nGdkEventButton *bevent = (GdkEventButton *)event;\r\nif(event->type==GDK_BUTTON_PRESS && bevent->button==3){\r\ngtk_menu_popup(GTK_MENU(rst->menu), NULL, NULL, NULL, NULL,\r\nbevent->button, bevent->time);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void\r\napply_as_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_and_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_AND_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_or_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_OR_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_and_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_AND_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\napply_as_or_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_MATCH(ACTYPE_OR_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_and_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_AND_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_or_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_OR_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_and_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_AND_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nprep_as_or_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_PREPARE(ACTYPE_OR_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_FRAME(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_FRAME(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_prev_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_PREVIOUS(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_prev_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_PREVIOUS(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_next_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_NEXT(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nfind_next_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_FIND_NEXT(ACTYPE_NOT_SELECTED, 0));\r\n}\r\nstatic void\r\ncolor_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_COLORIZE(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\ncolor_not_selected_cb(GtkWidget *widget, gpointer user_data)\r\n{\r\nsrt_select_filter_cb( widget , user_data, CALLBACK_COLORIZE(ACTYPE_SELECTED, 0));\r\n}\r\nstatic void\r\nsrt_create_popup_menu(srt_stat_table *rst)\r\n{\r\nGtkUIManager *ui_manager;\r\nGtkActionGroup *action_group;\r\nGError *error = NULL;\r\naction_group = gtk_action_group_new ("ServiceRespTFilterPopupActionGroup");\r\ngtk_action_group_add_actions (action_group,\r\n(GtkActionEntry *)service_resp_t__popup_entries,\r\nG_N_ELEMENTS(service_resp_t__popup_entries),\r\nrst);\r\nui_manager = gtk_ui_manager_new ();\r\ngtk_ui_manager_insert_action_group (ui_manager,\r\naction_group,\r\n0);\r\ngtk_ui_manager_add_ui_from_string (ui_manager,ui_desc_service_resp_t_filter_popup, -1, &error);\r\nif (error != NULL)\r\n{\r\nfprintf (stderr, "Warning: building service response time filter popup failed: %s\n",\r\nerror->message);\r\ng_error_free (error);\r\nerror = NULL;\r\n}\r\nrst->menu = gtk_ui_manager_get_widget(ui_manager, "/ServiceRespTFilterPopup");\r\ng_signal_connect(rst->table, "button_press_event", G_CALLBACK(srt_show_popup_menu_cb), rst);\r\n}\r\nstatic void\r\nsrt_time_func (GtkTreeViewColumn *column _U_,\r\nGtkCellRenderer *renderer,\r\nGtkTreeModel *model,\r\nGtkTreeIter *iter,\r\ngpointer user_data)\r\n{\r\ngchar *str;\r\nnstime_t *data;\r\ngint data_column = GPOINTER_TO_INT(user_data);\r\ngtk_tree_model_get(model, iter, data_column, &data, -1);\r\nif (!data) {\r\ng_object_set(renderer, "text", "", NULL);\r\nreturn;\r\n}\r\nstr = g_strdup_printf("%3d.%06d", (int)data->secs, (data->nsecs+500)/1000);\r\ng_object_set(renderer, "text", str, NULL);\r\ng_free(str);\r\n}\r\nstatic void\r\nsrt_avg_func (GtkTreeViewColumn *column _U_,\r\nGtkCellRenderer *renderer,\r\nGtkTreeModel *model,\r\nGtkTreeIter *iter,\r\ngpointer user_data)\r\n{\r\ngchar *str;\r\nguint64 td;\r\ngint data_column = GPOINTER_TO_INT(user_data);\r\ngtk_tree_model_get(model, iter, data_column, &td, -1);\r\nstr=g_strdup_printf("%3d.%06d",\r\n(int)(td/1000000), (int)(td%1000000));\r\ng_object_set(renderer, "text", str, NULL);\r\ng_free(str);\r\n}\r\nstatic gint\r\nsrt_time_sort_func(GtkTreeModel *model,\r\nGtkTreeIter *a,\r\nGtkTreeIter *b,\r\ngpointer user_data)\r\n{\r\nnstime_t *ns_a;\r\nnstime_t *ns_b;\r\ngint ret = 0;\r\ngint data_column = GPOINTER_TO_INT(user_data);\r\ngtk_tree_model_get(model, a, data_column, &ns_a, -1);\r\ngtk_tree_model_get(model, b, data_column, &ns_b, -1);\r\nif (ns_a == ns_b) {\r\nret = 0;\r\n}\r\nelse if (ns_a == NULL || ns_b == NULL) {\r\nret = (ns_a == NULL) ? -1 : 1;\r\n}\r\nelse {\r\nret = nstime_cmp(ns_a,ns_b);\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\ninit_srt_table(srt_stat_table *rst, int num_procs, GtkWidget *vbox, const char *filter_string)\r\n{\r\nint i;\r\nGtkListStore *store;\r\nGtkWidget *tree;\r\nGtkTreeViewColumn *column;\r\nGtkCellRenderer *renderer;\r\nGtkTreeSortable *sortable;\r\nGtkTreeSelection *sel;\r\nstatic const char *default_titles[] = { "Index", "Procedure", "Calls", "Min SRT", "Max SRT", "Avg SRT" };\r\nstore = gtk_list_store_new (N_COLUMNS,\r\nG_TYPE_INT,\r\nG_TYPE_STRING,\r\nG_TYPE_UINT,\r\nG_TYPE_POINTER,\r\nG_TYPE_POINTER,\r\nG_TYPE_UINT64);\r\ntree = gtk_tree_view_new_with_model (GTK_TREE_MODEL (store));\r\nrst->table = GTK_TREE_VIEW(tree);\r\nsortable = GTK_TREE_SORTABLE(store);\r\ng_object_unref (G_OBJECT (store));\r\nif(filter_string){\r\nrst->filter_string=g_strdup(filter_string);\r\n} else {\r\nrst->filter_string=NULL;\r\n}\r\nfor (i = 0; i < N_COLUMNS; i++) {\r\nrenderer = gtk_cell_renderer_text_new ();\r\nif (i != PROCEDURE_COLUMN) {\r\ng_object_set(G_OBJECT(renderer), "xalign", 1.0, NULL);\r\n}\r\ng_object_set(renderer, "ypad", 0, NULL);\r\nswitch (i) {\r\ncase MIN_SRT_COLUMN:\r\ncase MAX_SRT_COLUMN:\r\ncolumn = gtk_tree_view_column_new_with_attributes (default_titles[i], renderer, NULL);\r\ngtk_tree_view_column_set_cell_data_func(column, renderer, srt_time_func, GINT_TO_POINTER(i), NULL);\r\ngtk_tree_sortable_set_sort_func(sortable, i, srt_time_sort_func, GINT_TO_POINTER(i), NULL);\r\nbreak;\r\ncase AVG_SRT_COLUMN:\r\ncolumn = gtk_tree_view_column_new_with_attributes (default_titles[i], renderer, NULL);\r\ngtk_tree_view_column_set_cell_data_func(column, renderer, srt_avg_func, GINT_TO_POINTER(i), NULL);\r\nbreak;\r\ndefault:\r\ncolumn = gtk_tree_view_column_new_with_attributes (default_titles[i], renderer, "text",\r\ni, NULL);\r\nbreak;\r\n}\r\ngtk_tree_view_column_set_sort_column_id(column, i);\r\ngtk_tree_view_column_set_resizable(column, TRUE);\r\ngtk_tree_view_append_column (rst->table, column);\r\nif (i == CALLS_COLUMN) {\r\ngtk_tree_view_column_clicked(column);\r\ngtk_tree_view_column_clicked(column);\r\n}\r\n}\r\nrst->scrolled_window=scrolled_window_new(NULL, NULL);\r\ngtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(rst->scrolled_window),\r\nGTK_SHADOW_IN);\r\ngtk_container_add(GTK_CONTAINER(rst->scrolled_window), GTK_WIDGET (rst->table));\r\ngtk_box_pack_start(GTK_BOX(vbox), rst->scrolled_window, TRUE, TRUE, 0);\r\ngtk_tree_view_set_reorderable (rst->table, FALSE);\r\ngtk_tree_view_set_rules_hint(rst->table, TRUE);\r\ngtk_tree_view_set_headers_clickable(rst->table, TRUE);\r\ngtk_widget_show(rst->scrolled_window);\r\nrst->num_procs=num_procs;\r\nrst->procedures=(srt_procedure_t *)g_malloc(sizeof(srt_procedure_t)*num_procs);\r\nfor(i=0;i<num_procs;i++){\r\ntime_stat_init(&rst->procedures[i].stats);\r\nrst->procedures[i].index = 0;\r\nrst->procedures[i].procedure = NULL;\r\n}\r\nsel = gtk_tree_view_get_selection(GTK_TREE_VIEW(rst->table));\r\ngtk_tree_selection_set_mode(sel, GTK_SELECTION_SINGLE);\r\nif(rst->filter_string){\r\nsrt_create_popup_menu(rst);\r\n}\r\n}\r\nvoid\r\ninit_srt_table_row(srt_stat_table *rst, int indx, const char *procedure)\r\n{\r\nif(indx>=rst->num_procs){\r\nint old_num_procs=rst->num_procs;\r\nint i;\r\nrst->num_procs=indx+1;\r\nrst->procedures=(srt_procedure_t *)g_realloc(rst->procedures, sizeof(srt_procedure_t)*(rst->num_procs));\r\nfor(i=old_num_procs;i<rst->num_procs;i++){\r\ntime_stat_init(&rst->procedures[i].stats);\r\nrst->procedures[i].index = i;\r\nrst->procedures[i].procedure=NULL;\r\n}\r\n}\r\nrst->procedures[indx].index = indx;\r\nrst->procedures[indx].procedure=g_strdup(procedure);\r\n}\r\nvoid\r\nadd_srt_table_data(srt_stat_table *rst, int indx, const nstime_t *req_time, packet_info *pinfo)\r\n{\r\nsrt_procedure_t *rp;\r\nnstime_t t, delta;\r\ng_assert(indx >= 0 && indx < rst->num_procs);\r\nrp=&rst->procedures[indx];\r\nif (rp->stats.num==0){\r\nGtkListStore *store = GTK_LIST_STORE(gtk_tree_view_get_model(rst->table));\r\ngtk_list_store_append(store, &rp->iter);\r\ngtk_list_store_set(store, &rp->iter,\r\nINDEX_COLUMN, rp->index,\r\nPROCEDURE_COLUMN, rp->procedure,\r\nCALLS_COLUMN, rp->stats.num,\r\nMIN_SRT_COLUMN, NULL,\r\nMAX_SRT_COLUMN, NULL,\r\nAVG_SRT_COLUMN, (guint64)0,\r\n-1);\r\n}\r\nt=pinfo->fd->abs_ts;\r\nnstime_delta(&delta, &t, req_time);\r\ntime_stat_update(&rp->stats, &delta, pinfo);\r\n}\r\nvoid\r\ndraw_srt_table_data(srt_stat_table *rst)\r\n{\r\nint i;\r\nguint64 td;\r\nGtkListStore *store = GTK_LIST_STORE(gtk_tree_view_get_model(rst->table));\r\nfor(i=0;i<rst->num_procs;i++){\r\nif(rst->procedures[i].stats.num==0){\r\ncontinue;\r\n}\r\ntd = ((guint64)(rst->procedures[i].stats.tot.secs))*NANOSECS_PER_SEC + rst->procedures[i].stats.tot.nsecs;\r\ntd = ((td / rst->procedures[i].stats.num) + 500) / 1000;\r\ngtk_list_store_set(store, &rst->procedures[i].iter,\r\nCALLS_COLUMN, rst->procedures[i].stats.num,\r\nMIN_SRT_COLUMN, &rst->procedures[i].stats.min,\r\nMAX_SRT_COLUMN, &rst->procedures[i].stats.max,\r\nAVG_SRT_COLUMN, td,\r\n-1);\r\n}\r\n}\r\nvoid\r\nreset_srt_table_data(srt_stat_table *rst)\r\n{\r\nint i;\r\nGtkListStore *store;\r\nfor(i=0;i<rst->num_procs;i++){\r\ntime_stat_init(&rst->procedures[i].stats);\r\n}\r\nstore = GTK_LIST_STORE(gtk_tree_view_get_model(rst->table));\r\ngtk_list_store_clear(store);\r\n}\r\nvoid\r\nfree_srt_table_data(srt_stat_table *rst)\r\n{\r\nint i;\r\nfor(i=0;i<rst->num_procs;i++){\r\ng_free(rst->procedures[i].procedure);\r\nrst->procedures[i].procedure=NULL;\r\n}\r\ng_free(rst->filter_string);\r\nrst->filter_string=NULL;\r\ng_free(rst->procedures);\r\nrst->procedures=NULL;\r\nrst->num_procs=0;\r\n}
