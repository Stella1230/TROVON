static int\r\nssl_queue_packet_data(void *tapdata, packet_info *pinfo, epan_dissect_t *edt _U_, const void *ssl)\r\n{\r\nfollow_info_t * follow_info = (follow_info_t*) tapdata;\r\nSslDecryptedRecord * rec = NULL;\r\nSslDataInfo * appl_data = NULL;\r\nint proto_ssl = GPOINTER_TO_INT(ssl);\r\nSslPacketInfo * pi = NULL;\r\nshow_stream_t from = FROM_CLIENT;\r\npi = (SslPacketInfo*) p_get_proto_data(wmem_file_scope(), pinfo, proto_ssl, 0);\r\nif (!pi || !pi->appl_data) return 0;\r\nif (follow_info->client_port == 0) {\r\nfollow_info->client_port = pinfo->srcport;\r\nCOPY_ADDRESS(&follow_info->client_ip, &pinfo->src);\r\n}\r\nif (ADDRESSES_EQUAL(&follow_info->client_ip, &pinfo->src) &&\r\nfollow_info->client_port == pinfo->srcport) {\r\nfrom = FROM_CLIENT;\r\n} else {\r\nfrom = FROM_SERVER;\r\n}\r\nfor (appl_data = pi->appl_data; appl_data != NULL; appl_data = appl_data->next) {\r\nif (appl_data->seq < follow_info->bytes_written[from]) continue;\r\nrec = (SslDecryptedRecord*) g_malloc(sizeof(SslDecryptedRecord) + appl_data->plain_data.data_len);\r\nrec->is_from_server = from == FROM_SERVER;\r\nrec->data.data = (guchar*) (rec + 1);\r\nrec->data.data_len = appl_data->plain_data.data_len;\r\nmemcpy(rec->data.data, appl_data->plain_data.data, appl_data->plain_data.data_len);\r\nfollow_info->payload = g_list_append(follow_info->payload, rec);\r\nfollow_info->bytes_written[from] += rec->data.data_len;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nfollow_ssl_stream_cb(GtkWidget * w _U_, gpointer data _U_)\r\n{\r\nGtkWidget * filter_te;\r\nGtkWidget * filter_cm;\r\ngchar * follow_filter;\r\nconst gchar * previous_filter;\r\nint filter_out_filter_len;\r\nint previous_filter_len;\r\nconst char * hostname0;\r\nconst char * hostname1;\r\nconst char * port0;\r\nconst char * port1;\r\nconst char * client_hostname;\r\nconst char * server_hostname;\r\nconst char * client_port;\r\nconst char * server_port;\r\ngchar * server_to_client_string = NULL;\r\ngchar * client_to_server_string = NULL;\r\ngchar * both_directions_string = NULL;\r\nconst gchar * single_direction_format = NULL;\r\nfollow_stats_t stats;\r\nfollow_info_t * follow_info;\r\nGString * msg;\r\nif (!epan_dissect_packet_contains_field(cfile.edt, "ssl")) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Error following stream. Please make\n"\r\n"sure you have an SSL packet selected.");\r\nreturn;\r\n}\r\nfollow_info = g_new0(follow_info_t, 1);\r\nfollow_info->follow_type = FOLLOW_SSL;\r\nreset_tcp_reassembly();\r\nfollow_filter = build_follow_conv_filter(&cfile.edt->pi);\r\nif (!follow_filter)\r\n{\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Error creating filter for this stream.\n"\r\n"A network layer header is needed");\r\ng_free(follow_info);\r\nreturn;\r\n}\r\nfilter_cm = (GtkWidget *)g_object_get_data(G_OBJECT(top_level), E_DFILTER_CM_KEY);\r\nfilter_te = gtk_bin_get_child(GTK_BIN(filter_cm));\r\nfollow_info->filter_te = filter_te;\r\nprevious_filter =\r\n(const gchar *)gtk_entry_get_text(GTK_ENTRY(filter_te));\r\nprevious_filter_len = previous_filter?(int)strlen(previous_filter):0;\r\nfilter_out_filter_len = (int)strlen(follow_filter) + previous_filter_len + 16;\r\nfollow_info->filter_out_filter = (gchar *)g_malloc(filter_out_filter_len);\r\nif(previous_filter_len) {\r\ng_snprintf(follow_info->filter_out_filter, filter_out_filter_len,\r\n"%s and !(%s)", previous_filter, follow_filter);\r\n} else {\r\ng_snprintf(follow_info->filter_out_filter, filter_out_filter_len,\r\n"!(%s)", follow_filter);\r\n}\r\nmsg = register_tap_listener("ssl", follow_info, follow_filter, 0,\r\nNULL, ssl_queue_packet_data, NULL);\r\nif (msg)\r\n{\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't register ssl tap: %s\n",msg->str);\r\ng_free(follow_info->filter_out_filter);\r\ng_free(follow_info);\r\ng_free(follow_filter);\r\nreturn;\r\n}\r\ngtk_entry_set_text(GTK_ENTRY(filter_te), follow_filter);\r\nmain_filter_packets(&cfile, follow_filter, TRUE);\r\ng_free(follow_filter);\r\nremove_tap_listener(follow_info);\r\nfollow_stats(&stats);\r\nif (stats.is_ipv6) {\r\nstruct e_in6_addr ipaddr;\r\nmemcpy(&ipaddr, stats.ip_address[0], 16);\r\nhostname0 = get_hostname6(&ipaddr);\r\nmemcpy(&ipaddr, stats.ip_address[1], 16);\r\nhostname1 = get_hostname6(&ipaddr);\r\n} else {\r\nguint32 ipaddr;\r\nmemcpy(&ipaddr, stats.ip_address[0], 4);\r\nhostname0 = get_hostname(ipaddr);\r\nmemcpy(&ipaddr, stats.ip_address[1], 4);\r\nhostname1 = get_hostname(ipaddr);\r\n}\r\nport0 = ep_tcp_port_to_display(stats.port[0]);\r\nport1 = ep_tcp_port_to_display(stats.port[1]);\r\nfollow_info->is_ipv6 = stats.is_ipv6;\r\nboth_directions_string = g_strdup_printf("Entire conversation (%u bytes)", follow_info->bytes_written[0] + follow_info->bytes_written[1]);\r\nif ((follow_info->client_port == stats.port[0]) &&\r\n((stats.is_ipv6 && (memcmp(follow_info->client_ip.data, stats.ip_address[0], 16) == 0)) ||\r\n(!stats.is_ipv6 && (memcmp(follow_info->client_ip.data, stats.ip_address[0], 4) == 0)))) {\r\nserver_hostname = hostname0;\r\nserver_port = port0;\r\nclient_hostname = hostname1;\r\nclient_port = port1;\r\n} else {\r\nserver_hostname = hostname1;\r\nserver_port = port1;\r\nclient_hostname = hostname0;\r\nclient_port = port0;\r\n}\r\nsingle_direction_format = "%s:%s " UTF8_RIGHTWARDS_ARROW " %s:%s (%u bytes)";\r\nserver_to_client_string = g_strdup_printf(single_direction_format,\r\nserver_hostname, server_port,\r\nclient_hostname, client_port,\r\nfollow_info->bytes_written[0]);\r\nclient_to_server_string = g_strdup_printf(single_direction_format,\r\nclient_hostname, client_port,\r\nserver_hostname, server_port,\r\nfollow_info->bytes_written[1]);\r\nfollow_stream("Follow SSL Stream", follow_info, both_directions_string,\r\nserver_to_client_string, client_to_server_string);\r\ng_free(both_directions_string);\r\ng_free(server_to_client_string);\r\ng_free(client_to_server_string);\r\n}\r\nfrs_return_t\r\nfollow_read_ssl_stream(follow_info_t *follow_info,\r\ngboolean (*print_line_fcn_p)(char *, size_t, gboolean, void *),\r\nvoid *arg)\r\n{\r\nguint32 global_client_pos = 0, global_server_pos = 0;\r\nguint32 server_packet_count = 0;\r\nguint32 client_packet_count = 0;\r\nguint32 * global_pos;\r\nGList * cur;\r\nfrs_return_t frs_return;\r\nfor (cur = follow_info->payload; cur; cur = g_list_next(cur)) {\r\nSslDecryptedRecord * rec = (SslDecryptedRecord*) cur->data;\r\ngboolean include_rec = FALSE;\r\nif (rec->is_from_server) {\r\nglobal_pos = &global_server_pos;\r\ninclude_rec = (follow_info->show_stream == BOTH_HOSTS) ||\r\n(follow_info->show_stream == FROM_SERVER);\r\n} else {\r\nglobal_pos = &global_client_pos;\r\ninclude_rec = (follow_info->show_stream == BOTH_HOSTS) ||\r\n(follow_info->show_stream == FROM_CLIENT);\r\n}\r\nif (include_rec) {\r\nsize_t nchars = rec->data.data_len;\r\ngchar *buffer = (gchar *)g_memdup(rec->data.data, (guint) nchars);\r\nfrs_return = follow_show(follow_info, print_line_fcn_p, buffer, nchars,\r\nrec->is_from_server, arg, global_pos,\r\n&server_packet_count, &client_packet_count);\r\ng_free(buffer);\r\nif (frs_return == FRS_PRINT_ERROR)\r\nreturn frs_return;\r\n}\r\n}\r\nreturn FRS_OK;\r\n}
