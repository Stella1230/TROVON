static int\r\ndissect_kt_replication_wait(tvbuff_t *tvb, proto_tree *tree, gint offset)\r\n{\r\ngint new_offset;\r\nguint64 ts;\r\nnstime_t ns_ts;\r\nnew_offset = offset;\r\nproto_tree_add_item(tree, hf_kt_magic, tvb, new_offset, 1, ENC_BIG_ENDIAN);\r\nnew_offset++;\r\nts = tvb_get_ntoh64(tvb, new_offset);\r\nns_ts.secs = (time_t)(ts/1000000000);\r\nns_ts.nsecs = (int)(ts%1000000000);\r\nproto_tree_add_time(tree, hf_kt_ts, tvb, new_offset, 8, &ns_ts);\r\nnew_offset += 8;\r\nreturn new_offset;\r\n}\r\nstatic int\r\ndissect_kt_replication(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset)\r\n{\r\ngint new_offset;\r\nguint32 next32, size;\r\nguint64 ts;\r\nnstime_t ns_ts;\r\nproto_item *pi;\r\nnew_offset = offset;\r\nproto_tree_add_item(tree, hf_kt_magic, tvb, new_offset, 1, ENC_BIG_ENDIAN);\r\nnew_offset++;\r\nif (tvb_reported_length_remaining(tvb, new_offset) > 0) {\r\nnext32 = tvb_get_ntohl(tvb, new_offset);\r\nif (next32 <= 1) {\r\nproto_tree_add_item(tree, hf_kt_flags, tvb, new_offset, 4, ENC_BIG_ENDIAN);\r\nnew_offset += 4;\r\nproto_tree_add_item(tree, hf_kt_ts, tvb, new_offset, 8, ENC_BIG_ENDIAN);\r\nnew_offset += 8;\r\nproto_tree_add_item(tree, hf_kt_sid, tvb, new_offset, 2, ENC_BIG_ENDIAN);\r\nnew_offset += 2;\r\n} else {\r\nts = tvb_get_ntoh64(tvb, new_offset);\r\nns_ts.secs = (time_t)(ts/1000000000);\r\nns_ts.nsecs = (int)(ts%1000000000);\r\nproto_tree_add_time(tree, hf_kt_ts, tvb, new_offset, 8, &ns_ts);\r\nnew_offset += 8;\r\nsize = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(tree, hf_kt_size, tvb, new_offset, 4, size);\r\nnew_offset += 4;\r\nproto_tree_add_item(tree, hf_kt_log, tvb, new_offset, size, ENC_NA);\r\nnew_offset += size;\r\n}\r\n} else {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_RESPONSE);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ", "[response]");\r\n}\r\nreturn new_offset;\r\n}\r\nstatic int\r\ndissect_kt_set_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset)\r\n{\r\nguint32 next32, rnum, ksiz, vsiz;\r\ngint new_offset, rec_start_offset;\r\nproto_item *ti;\r\nproto_item *pi;\r\nproto_tree *rec_tree;\r\nnew_offset = offset;\r\nproto_tree_add_item(tree, hf_kt_magic, tvb, new_offset, 1, ENC_BIG_ENDIAN);\r\nnew_offset++;\r\nnext32 = tvb_get_ntohl(tvb, new_offset);\r\nif (tvb_reported_length_remaining(tvb, (new_offset + 4)) > 0) {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_REQUEST);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\nproto_tree_add_uint(tree, hf_kt_flags, tvb, new_offset, 4, next32);\r\nnew_offset += 4;\r\nrnum = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(tree, hf_kt_rnum, tvb, new_offset, 4, rnum);\r\nnew_offset += 4;\r\nwhile (rnum > 0) {\r\nti = proto_tree_add_item(tree, hf_kt_rec, tvb, new_offset, -1, ENC_NA);\r\nrec_tree = proto_item_add_subtree(ti, ett_kt_rec);\r\nrec_start_offset = new_offset;\r\nproto_tree_add_item(rec_tree, hf_kt_dbidx, tvb, new_offset, 2, ENC_BIG_ENDIAN);\r\nnew_offset += 2;\r\nksiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_ksiz, tvb, new_offset, 4, ksiz);\r\nnew_offset += 4;\r\nvsiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_vsiz, tvb, new_offset, 4, vsiz);\r\nnew_offset += 4;\r\nproto_tree_add_item(rec_tree, hf_kt_xt, tvb, new_offset, 8, ENC_BIG_ENDIAN);\r\nnew_offset += 8;\r\nproto_tree_add_item(rec_tree, hf_kt_key, tvb, new_offset, ksiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_key_str, tvb, new_offset, ksiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += ksiz;\r\nproto_tree_add_item(rec_tree, hf_kt_val, tvb, new_offset, vsiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_val_str, tvb, new_offset, vsiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += vsiz;\r\nproto_item_set_len(ti, new_offset - rec_start_offset);\r\nrnum--;\r\n}\r\n} else {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_RESPONSE);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ", "[response]");\r\nproto_tree_add_uint(tree, hf_kt_hits, tvb, new_offset, 4, next32);\r\nnew_offset += 4;\r\n}\r\nreturn new_offset;\r\n}\r\nstatic int\r\ndissect_kt_play_script(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset)\r\n{\r\nguint32 next32, rnum, ksiz, vsiz, nsiz;\r\ngint new_offset, rec_start_offset;\r\nproto_item *ti;\r\nproto_item *pi;\r\nproto_tree *rec_tree;\r\nnew_offset = offset;\r\nproto_tree_add_item(tree, hf_kt_magic, tvb, new_offset, 1, ENC_BIG_ENDIAN);\r\nnew_offset++;\r\nnext32 = tvb_get_ntohl(tvb, new_offset);\r\nif (next32 == 0) {\r\nif (tvb_reported_length_remaining(tvb, (new_offset + 4)) > 0) {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_REQUEST);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\nproto_tree_add_uint(tree, hf_kt_flags, tvb, new_offset, 4, next32);\r\nnew_offset += 4;\r\nnsiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(tree, hf_kt_nsiz, tvb, new_offset, 4, nsiz);\r\nnew_offset += 4;\r\nrnum = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(tree, hf_kt_rnum, tvb, new_offset, 4, rnum);\r\nnew_offset += 4;\r\nproto_tree_add_item(tree, hf_kt_name, tvb, new_offset, nsiz, ENC_ASCII|ENC_NA);\r\nnew_offset += nsiz;\r\nwhile (rnum > 0) {\r\nti = proto_tree_add_item(tree, hf_kt_rec, tvb, new_offset, -1, ENC_NA);\r\nrec_tree = proto_item_add_subtree(ti, ett_kt_rec);\r\nrec_start_offset = new_offset;\r\nksiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_ksiz, tvb, new_offset, 4, ksiz);\r\nnew_offset += 4;\r\nvsiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_vsiz, tvb, new_offset, 4, vsiz);\r\nnew_offset += 4;\r\nproto_tree_add_item(rec_tree, hf_kt_key, tvb, new_offset, ksiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_key_str, tvb, new_offset, ksiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += ksiz;\r\nproto_tree_add_item(rec_tree, hf_kt_val, tvb, new_offset, vsiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_val_str, tvb, new_offset, vsiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += vsiz;\r\nproto_item_set_len(ti, new_offset - rec_start_offset);\r\nrnum--;\r\n}\r\n} else {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_RESPONSE);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ", "[response]");\r\nproto_tree_add_uint(tree, hf_kt_rnum, tvb, new_offset, 4, next32);\r\nnew_offset += 4;\r\n}\r\n} else {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_RESPONSE);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ", "[response]");\r\nrnum = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(tree, hf_kt_hits, tvb, new_offset, 4, rnum);\r\nnew_offset += 4;\r\nwhile (rnum > 0) {\r\nti = proto_tree_add_item(tree, hf_kt_rec, tvb, new_offset, -1, ENC_NA);\r\nrec_tree = proto_item_add_subtree(ti, ett_kt_rec);\r\nrec_start_offset = new_offset;\r\nksiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_ksiz, tvb, new_offset, 4, ksiz);\r\nnew_offset += 4;\r\nvsiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_vsiz, tvb, new_offset, 4, vsiz);\r\nnew_offset += 4;\r\nproto_tree_add_item(rec_tree, hf_kt_key, tvb, new_offset, ksiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_key_str, tvb, new_offset, ksiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += ksiz;\r\nproto_tree_add_item(rec_tree, hf_kt_val, tvb, new_offset, vsiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_val_str, tvb, new_offset, vsiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += vsiz;\r\nproto_item_set_len(ti, new_offset - rec_start_offset);\r\nrnum--;\r\n}\r\n}\r\nreturn new_offset;\r\n}\r\nstatic int\r\ndissect_kt_get_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset)\r\n{\r\nguint32 next32, rnum, ksiz, vsiz;\r\nguint64 xt;\r\nnstime_t ts;\r\ngint new_offset, rec_start_offset;\r\nproto_item *ti;\r\nproto_item *pi;\r\nproto_tree *rec_tree;\r\nnew_offset = offset;\r\nproto_tree_add_item(tree, hf_kt_magic, tvb, new_offset, 1, ENC_BIG_ENDIAN);\r\nnew_offset++;\r\nnext32 = tvb_get_ntohl(tvb, new_offset);\r\nif (next32 == 0) {\r\nif (tvb_reported_length_remaining(tvb, (new_offset + 4)) > 0) {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_REQUEST);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\nproto_tree_add_uint(tree, hf_kt_flags, tvb, new_offset, 4, next32);\r\nnew_offset += 4;\r\nrnum = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(tree, hf_kt_rnum, tvb, new_offset, 4, rnum);\r\nnew_offset += 4;\r\nwhile (rnum > 0) {\r\nti = proto_tree_add_item(tree, hf_kt_rec, tvb, new_offset, -1, ENC_NA);\r\nrec_tree = proto_item_add_subtree(ti, ett_kt_rec);\r\nrec_start_offset = new_offset;\r\nproto_tree_add_item(rec_tree, hf_kt_dbidx, tvb, new_offset, 2, ENC_BIG_ENDIAN);\r\nnew_offset += 2;\r\nksiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_ksiz, tvb, new_offset, 4, ksiz);\r\nnew_offset += 4;\r\nproto_tree_add_item(rec_tree, hf_kt_key, tvb, new_offset, ksiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_key_str, tvb, new_offset, ksiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += ksiz;\r\nproto_item_set_len(ti, new_offset - rec_start_offset);\r\nrnum--;\r\n}\r\n} else {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_RESPONSE);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ", "[response]");\r\nproto_tree_add_uint(tree, hf_kt_hits, tvb, new_offset, 4, next32);\r\nnew_offset += 4;\r\n}\r\n} else {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_RESPONSE);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ", "[response]");\r\nrnum = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(tree, hf_kt_hits, tvb, new_offset, 4, rnum);\r\nnew_offset += 4;\r\nwhile (rnum > 0) {\r\nti = proto_tree_add_item(tree, hf_kt_rec, tvb, new_offset, -1, ENC_NA);\r\nrec_tree = proto_item_add_subtree(ti, ett_kt_rec);\r\nrec_start_offset = new_offset;\r\nproto_tree_add_item(rec_tree, hf_kt_dbidx, tvb, new_offset, 2, ENC_BIG_ENDIAN);\r\nnew_offset += 2;\r\nksiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_ksiz, tvb, new_offset, 4, ksiz);\r\nnew_offset += 4;\r\nvsiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_vsiz, tvb, new_offset, 4, vsiz);\r\nnew_offset += 4;\r\nxt = tvb_get_ntoh64(tvb, new_offset);\r\nts.secs = (time_t)(xt&0xFFFFFFFF);\r\nts.nsecs = 0;\r\nproto_tree_add_time(rec_tree, hf_kt_xt_resp, tvb, new_offset, 8, &ts);\r\nnew_offset += 8;\r\nproto_tree_add_item(rec_tree, hf_kt_key, tvb, new_offset, ksiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_key_str, tvb, new_offset, ksiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += ksiz;\r\nproto_tree_add_item(rec_tree, hf_kt_val, tvb, new_offset, vsiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_val_str, tvb, new_offset, vsiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += vsiz;\r\nproto_item_set_len(ti, new_offset - rec_start_offset);\r\nrnum--;\r\n}\r\n}\r\nreturn new_offset;\r\n}\r\nstatic int\r\ndissect_kt_remove_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset)\r\n{\r\nguint32 next32, rnum, ksiz;\r\ngint new_offset, rec_start_offset;\r\nproto_item *ti;\r\nproto_item *pi;\r\nproto_tree *rec_tree;\r\nnew_offset = offset;\r\nproto_tree_add_item(tree, hf_kt_magic, tvb, new_offset, 1, ENC_BIG_ENDIAN);\r\nnew_offset++;\r\nnext32 = tvb_get_ntohl(tvb, new_offset);\r\nif (tvb_reported_length_remaining(tvb, (new_offset + 4)) > 0) {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_REQUEST);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\nproto_tree_add_uint(tree, hf_kt_flags, tvb, new_offset, 4, next32);\r\nnew_offset += 4;\r\nrnum = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(tree, hf_kt_rnum, tvb, new_offset, 4, rnum);\r\nnew_offset += 4;\r\nwhile (rnum > 0) {\r\nti = proto_tree_add_item(tree, hf_kt_rec, tvb, new_offset, -1, ENC_NA);\r\nrec_tree = proto_item_add_subtree(ti, ett_kt_rec);\r\nrec_start_offset = new_offset;\r\nproto_tree_add_item(rec_tree, hf_kt_dbidx, tvb, new_offset, 2, ENC_BIG_ENDIAN);\r\nnew_offset += 2;\r\nksiz = tvb_get_ntohl(tvb, new_offset);\r\nproto_tree_add_uint(rec_tree, hf_kt_ksiz, tvb, new_offset, 4, ksiz);\r\nnew_offset += 4;\r\nproto_tree_add_item(rec_tree, hf_kt_key, tvb, new_offset, ksiz, ENC_NA);\r\nif (kt_present_key_val_as_ascii) {\r\npi = proto_tree_add_item(rec_tree, hf_kt_key_str, tvb, new_offset, ksiz, ENC_ASCII|ENC_NA);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\n}\r\nnew_offset += ksiz;\r\nproto_item_set_len(ti, new_offset - rec_start_offset);\r\nrnum--;\r\n}\r\n} else {\r\npi = proto_tree_add_uint(tree, hf_kt_type, tvb, offset, 1, KT_OPER_RESPONSE);\r\nPROTO_ITEM_SET_GENERATED(pi);\r\ncol_append_sep_str(pinfo->cinfo, COL_INFO, " ", "[response]");\r\nproto_tree_add_uint(tree, hf_kt_hits, tvb, new_offset, 4, next32);\r\nnew_offset += 4;\r\n}\r\nreturn new_offset;\r\n}\r\nstatic int\r\ndissect_kt_error(tvbuff_t *tvb, proto_tree *tree, gint offset)\r\n{\r\ngint new_offset;\r\nnew_offset = offset;\r\nproto_tree_add_item(tree, hf_kt_magic, tvb, new_offset, 1, ENC_BIG_ENDIAN);\r\nnew_offset++;\r\nreturn new_offset;\r\n}\r\nstatic void\r\ndissect_kt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\r\n{\r\ngint magic;\r\nproto_item *ti;\r\nproto_tree *kt_tree;\r\ngint offset, offset_start;\r\noffset = 0;\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\nmagic = tvb_get_guint8(tvb, offset);\r\nif (try_val_to_str(magic, kt_magic_vals) == NULL)\r\nreturn;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "KT");\r\ncol_set_str(pinfo->cinfo, COL_INFO, try_val_to_str(magic, kt_magic_vals));\r\nti = proto_tree_add_item(tree, proto_kt, tvb, offset, -1, ENC_NA);\r\nkt_tree = proto_item_add_subtree(ti, ett_kt);\r\noffset_start=offset;\r\nswitch (magic) {\r\ncase KT_MAGIC_REPL_WAIT:\r\noffset = dissect_kt_replication_wait(tvb, kt_tree, offset);\r\nbreak;\r\ncase KT_MAGIC_REPLICATION:\r\noffset = dissect_kt_replication(tvb, pinfo, kt_tree, offset);\r\nbreak;\r\ncase KT_MAGIC_PLAY_SCRIPT:\r\noffset = dissect_kt_play_script(tvb, pinfo, kt_tree, offset);\r\nbreak;\r\ncase KT_MAGIC_SET_BULK:\r\noffset = dissect_kt_set_bulk(tvb, pinfo, kt_tree, offset);\r\nbreak;\r\ncase KT_MAGIC_REMOVE_BULK:\r\noffset = dissect_kt_remove_bulk(tvb, pinfo, kt_tree, offset);\r\nbreak;\r\ncase KT_MAGIC_GET_BULK:\r\noffset = dissect_kt_get_bulk(tvb, pinfo, kt_tree, offset);\r\nbreak;\r\ncase KT_MAGIC_ERROR:\r\noffset = dissect_kt_error(tvb, kt_tree, offset);\r\nbreak;\r\n}\r\nproto_item_set_len(ti, offset-offset_start);\r\n}\r\n}\r\nvoid\r\nproto_register_kt(void)\r\n{\r\nmodule_t *kt_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_kt_magic,\r\n{ "magic", "kt.magic", FT_UINT8, BASE_HEX,\r\nVALS(kt_magic_vals), 0x0, "identifier", HFILL\r\n}\r\n},\r\n{ &hf_kt_type,\r\n{ "type", "kt.type", FT_UINT8, BASE_HEX,\r\nVALS(kt_oper_vals), 0x0, "request/response", HFILL\r\n}\r\n},\r\n{ &hf_kt_flags,\r\n{ "flags", "kt.flags", FT_UINT32, BASE_HEX,\r\nNULL, 0x0, "flags of bitwise-or", HFILL\r\n}\r\n},\r\n{ &hf_kt_rnum,\r\n{ "rnum", "kt.rnum", FT_UINT32, BASE_DEC, NULL, 0x0,\r\n"the number of records", HFILL\r\n}\r\n},\r\n{ &hf_kt_dbidx,\r\n{ "dbidx", "kt.dbidx", FT_UINT16,\r\nBASE_DEC, NULL, 0x0, "the index of the target database", HFILL\r\n}\r\n},\r\n{ &hf_kt_sid,\r\n{ "sid", "kt.sid", FT_UINT16, BASE_DEC,\r\nNULL, 0x0, "the server ID number", HFILL\r\n}\r\n},\r\n{ &hf_kt_ts,\r\n{ "ts", "kt.ts", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0x0, "the timestamp of the log", HFILL\r\n}\r\n},\r\n{ &hf_kt_xt,\r\n{ "xt", "kt.xt", FT_UINT64, BASE_DEC,\r\nNULL, 0x0, "the expiration time in seconds", HFILL\r\n}\r\n},\r\n{ &hf_kt_xt_resp,\r\n{ "xt", "kt.xt_resp", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\r\nNULL, 0x0, "the expiration time", HFILL\r\n}\r\n},\r\n{ &hf_kt_ksiz,\r\n{ "ksiz", "kt.ksiz", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "the size of the key",HFILL\r\n}\r\n},\r\n{ &hf_kt_vsiz,\r\n{ "vsiz", "kt.vsiz", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "the size of the value", HFILL\r\n}\r\n},\r\n{ &hf_kt_key,\r\n{ "key", "kt.key", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "the key", HFILL\r\n}\r\n},\r\n{ &hf_kt_val,\r\n{ "value", "kt.value", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "the value", HFILL\r\n}\r\n},\r\n{ &hf_kt_key_str,\r\n{ "key", "kt.key_str", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "ASCII representation of the key", HFILL\r\n}\r\n},\r\n{ &hf_kt_val_str,\r\n{ "value", "kt.value_str", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "ASCII representation of the value", HFILL\r\n}\r\n},\r\n{ &hf_kt_hits,\r\n{ "hits", "kt.hits", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "the number of records", HFILL\r\n}\r\n},\r\n{ &hf_kt_size,\r\n{ "size", "kt.size", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "the size of the replication log", HFILL\r\n}\r\n},\r\n{ &hf_kt_log,\r\n{ "log", "kt.log", FT_BYTES, BASE_NONE,\r\nNULL, 0x0, "the replication log", HFILL\r\n}\r\n},\r\n{ &hf_kt_nsiz,\r\n{ "nsiz", "kt.nsiz", FT_UINT32, BASE_DEC,\r\nNULL, 0x0, "the size of the procedure name", HFILL\r\n}\r\n},\r\n{ &hf_kt_name,\r\n{ "name", "kt.name", FT_STRING, BASE_NONE,\r\nNULL, 0x0, "the procedure name", HFILL\r\n}\r\n},\r\n{ &hf_kt_rec,\r\n{ "record", "kt.record", FT_NONE, BASE_NONE,\r\nNULL, 0x0, "a record", HFILL\r\n}\r\n}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_kt,\r\n&ett_kt_rec\r\n};\r\nproto_kt = proto_register_protocol("Kyoto Tycoon Protocol", "Kyoto Tycoon", "kt");\r\nregister_dissector("kt", dissect_kt, proto_kt);\r\nproto_register_field_array(proto_kt, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nkt_module = prefs_register_protocol(proto_kt, proto_reg_handoff_kt);\r\nrange_convert_str(&global_kt_tcp_port_range, DEFAULT_KT_PORT_RANGE, MAX_TCP_PORT);\r\nprefs_register_range_preference(kt_module, "tcp.ports", "Kyoto Tycoon TCP ports",\r\n"TCP ports to be decoded as Kyoto Tycoon (binary protocol) (default: "\r\nDEFAULT_KT_PORT_RANGE ")",\r\n&global_kt_tcp_port_range, MAX_TCP_PORT);\r\nprefs_register_bool_preference(kt_module, "present_key_val_as_ascii",\r\n"Attempt to also show ASCII string representation of keys and values",\r\n"KT allows binary values in keys and values. Attempt to show an ASCII representation anyway (which might be prematurely terminated by a NULL!",\r\n&kt_present_key_val_as_ascii);\r\n}\r\nvoid\r\nproto_reg_handoff_kt(void)\r\n{\r\nstatic gboolean Initialized = FALSE;\r\nstatic range_t *kt_tcp_port_range;\r\nif (!Initialized) {\r\nkt_handle = find_dissector("kt");\r\nInitialized = TRUE;\r\n}\r\nelse {\r\ndissector_delete_uint_range("tcp.port", kt_tcp_port_range, kt_handle);\r\ng_free(kt_tcp_port_range);\r\n}\r\nkt_tcp_port_range = range_copy(global_kt_tcp_port_range);\r\ndissector_add_uint_range("tcp.port", kt_tcp_port_range, kt_handle);\r\n}
