static void\r\nfollow_redraw(gpointer data, gpointer user_data _U_)\r\n{\r\nfollow_load_text((follow_info_t *)data);\r\n}\r\nvoid\r\nfollow_tcp_redraw_all(void)\r\n{\r\ng_list_foreach(follow_infos, follow_redraw, NULL);\r\n}\r\nvoid\r\nfollow_tcp_stream_cb(GtkWidget * w _U_, gpointer data _U_)\r\n{\r\nGtkWidget *filter_cm;\r\nGtkWidget *filter_te;\r\nint tmp_fd;\r\ngchar *follow_filter;\r\nconst gchar *previous_filter;\r\nint filter_out_filter_len;\r\nconst char *hostname0, *hostname1;\r\nchar *port0, *port1;\r\ngchar *server_to_client_string = NULL;\r\ngchar *client_to_server_string = NULL;\r\ngchar *both_directions_string = NULL;\r\nfollow_stats_t stats;\r\nfollow_info_t *follow_info;\r\ntcp_stream_chunk sc;\r\nsize_t nchars;\r\ngchar *data_out_filename;\r\nchar stream_window_title[256];\r\ngboolean is_tcp = FALSE;\r\nproto_get_frame_protocols(cfile.edt->pi.layers, NULL, &is_tcp, NULL, NULL, NULL);\r\nif (!is_tcp) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Error following stream. Please make\n"\r\n"sure you have a TCP packet selected.");\r\nreturn;\r\n}\r\nfollow_info = g_new0(follow_info_t, 1);\r\nfollow_info->follow_type = FOLLOW_TCP;\r\nreset_tcp_reassembly();\r\nfollow_filter = build_follow_conv_filter(&cfile.edt->pi);\r\nif (!follow_filter) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Error creating filter for this stream.\n"\r\n"A transport or network layer header is needed");\r\ng_free(follow_info);\r\nreturn;\r\n}\r\ntmp_fd = create_tempfile(&data_out_filename, "follow");\r\nfollow_info->data_out_filename = g_strdup(data_out_filename);\r\nif (tmp_fd == -1) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Could not create temporary file %s: %s",\r\nfollow_info->data_out_filename, g_strerror(errno));\r\ng_free(follow_info->data_out_filename);\r\ng_free(follow_info);\r\ng_free(follow_filter);\r\nreturn;\r\n}\r\ndata_out_file = fdopen(tmp_fd, "w+b");\r\nif (data_out_file == NULL) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Could not create temporary file %s: %s",\r\nfollow_info->data_out_filename, g_strerror(errno));\r\nws_close(tmp_fd);\r\nws_unlink(follow_info->data_out_filename);\r\ng_free(follow_info->data_out_filename);\r\ng_free(follow_info);\r\ng_free(follow_filter);\r\nreturn;\r\n}\r\nfilter_cm = (GtkWidget *)g_object_get_data(G_OBJECT(top_level), E_DFILTER_CM_KEY);\r\nfilter_te = gtk_bin_get_child(GTK_BIN(filter_cm));\r\nfollow_info->filter_te = filter_te;\r\nprevious_filter =\r\n(const gchar *)gtk_entry_get_text(GTK_ENTRY(filter_te));\r\nfilter_out_filter_len = (int)(strlen(follow_filter) + strlen(previous_filter) + 16);\r\nfollow_info->filter_out_filter = (gchar *)g_malloc(filter_out_filter_len);\r\nif(strlen(previous_filter)) {\r\ng_snprintf(follow_info->filter_out_filter, filter_out_filter_len,\r\n"%s and !(%s)", previous_filter, follow_filter);\r\n} else {\r\ng_snprintf(follow_info->filter_out_filter, filter_out_filter_len,\r\n"!(%s)", follow_filter);\r\n}\r\ngtk_entry_set_text(GTK_ENTRY(filter_te), follow_filter);\r\nmain_filter_packets(&cfile, follow_filter, TRUE);\r\nif (empty_tcp_stream) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"The packets in the capture file for that stream have no data.");\r\nws_close(tmp_fd);\r\nws_unlink(follow_info->data_out_filename);\r\ng_free(follow_info->data_out_filename);\r\ng_free(follow_info->filter_out_filter);\r\ng_free(follow_info);\r\nreturn;\r\n}\r\nrewind(data_out_file);\r\nnchars=fread(&sc, 1, sizeof(sc), data_out_file);\r\nif (nchars != sizeof(sc)) {\r\nif (ferror(data_out_file)) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Could not read from temporary file %s: %s",\r\nfollow_info->data_out_filename, g_strerror(errno));\r\n} else {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Short read from temporary file %s: expected %lu, got %lu",\r\nfollow_info->data_out_filename,\r\n(unsigned long)sizeof(sc),\r\n(unsigned long)nchars);\r\n}\r\nws_close(tmp_fd);\r\nws_unlink(follow_info->data_out_filename);\r\ng_free(follow_info->data_out_filename);\r\ng_free(follow_info->filter_out_filter);\r\ng_free(follow_info);\r\nreturn;\r\n}\r\nfclose(data_out_file);\r\nfollow_stats(&stats);\r\nif (stats.is_ipv6) {\r\nstruct e_in6_addr ipaddr;\r\nmemcpy(&ipaddr, stats.ip_address[0], 16);\r\nhostname0 = get_hostname6(&ipaddr);\r\nmemcpy(&ipaddr, stats.ip_address[1], 16);\r\nhostname1 = get_hostname6(&ipaddr);\r\n} else {\r\nguint32 ipaddr;\r\nmemcpy(&ipaddr, stats.ip_address[0], 4);\r\nhostname0 = get_hostname(ipaddr);\r\nmemcpy(&ipaddr, stats.ip_address[1], 4);\r\nhostname1 = get_hostname(ipaddr);\r\n}\r\nfollow_info->is_ipv6 = stats.is_ipv6;\r\nport0 = ep_tcp_port_to_display(stats.port[0]);\r\nport1 = ep_tcp_port_to_display(stats.port[1]);\r\nif ((sc.src_port == stats.port[0]) &&\r\n((stats.is_ipv6 && (memcmp(sc.src_addr, stats.ip_address[0], 16) == 0)) ||\r\n(!stats.is_ipv6 && (memcmp(sc.src_addr, stats.ip_address[0], 4) == 0)))) {\r\nserver_to_client_string =\r\ng_strdup_printf("%s:%s " UTF8_RIGHTWARDS_ARROW " %s:%s (%u bytes)",\r\nhostname0, port0,\r\nhostname1, port1,\r\nstats.bytes_written[0]);\r\n} else {\r\nserver_to_client_string =\r\ng_strdup_printf("%s:%s " UTF8_RIGHTWARDS_ARROW " %s:%s (%u bytes)",\r\nhostname1, port1,\r\nhostname0,port0,\r\nstats.bytes_written[0]);\r\n}\r\nif ((sc.src_port == stats.port[1]) &&\r\n((stats.is_ipv6 && (memcmp(sc.src_addr, stats.ip_address[1], 16) == 0)) ||\r\n(!stats.is_ipv6 && (memcmp(sc.src_addr, stats.ip_address[1], 4) == 0)))) {\r\nclient_to_server_string =\r\ng_strdup_printf("%s:%s " UTF8_RIGHTWARDS_ARROW " %s:%s (%u bytes)",\r\nhostname0, port0,\r\nhostname1, port1,\r\nstats.bytes_written[1]);\r\n} else {\r\nclient_to_server_string =\r\ng_strdup_printf("%s:%s " UTF8_RIGHTWARDS_ARROW " %s:%s (%u bytes)",\r\nhostname1, port1,\r\nhostname0, port0,\r\nstats.bytes_written[1]);\r\n}\r\nboth_directions_string = g_strdup_printf("Entire conversation (%u bytes)", stats.bytes_written[0] + stats.bytes_written[1]);\r\ng_snprintf(stream_window_title, 256, "Follow TCP Stream (%s)", follow_filter);\r\nfollow_stream(stream_window_title, follow_info, both_directions_string,\r\nserver_to_client_string, client_to_server_string);\r\ng_free(follow_filter);\r\ng_free(both_directions_string);\r\ng_free(server_to_client_string);\r\ng_free(client_to_server_string);\r\ndata_out_file = NULL;\r\n}\r\nfrs_return_t\r\nfollow_read_tcp_stream(follow_info_t *follow_info,\r\ngboolean (*print_line_fcn_p)(char *, size_t, gboolean, void *),\r\nvoid *arg)\r\n{\r\ntcp_stream_chunk sc;\r\nsize_t bcount;\r\nsize_t bytes_read;\r\nint iplen;\r\nguint8 client_addr[MAX_IPADDR_LEN];\r\nguint16 client_port = 0;\r\ngboolean is_server;\r\nguint32 global_client_pos = 0, global_server_pos = 0;\r\nguint32 server_packet_count = 0;\r\nguint32 client_packet_count = 0;\r\nguint32 *global_pos;\r\ngboolean skip;\r\nchar buffer[FLT_BUF_SIZE+1];\r\nsize_t nchars;\r\nfrs_return_t frs_return;\r\niplen = (follow_info->is_ipv6) ? 16 : 4;\r\ndata_out_file = ws_fopen(follow_info->data_out_filename, "rb");\r\nif (data_out_file == NULL) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Could not open temporary file %s: %s", follow_info->data_out_filename,\r\ng_strerror(errno));\r\nreturn FRS_OPEN_ERROR;\r\n}\r\nwhile ((nchars=fread(&sc, 1, sizeof(sc), data_out_file))) {\r\nif (nchars != sizeof(sc)) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Short read from temporary file %s: expected %lu, got %lu",\r\nfollow_info->data_out_filename,\r\n(unsigned long)sizeof(sc),\r\n(unsigned long)nchars);\r\nfclose(data_out_file);\r\ndata_out_file = NULL;\r\nreturn FRS_READ_ERROR;\r\n}\r\nif (client_port == 0) {\r\nmemcpy(client_addr, sc.src_addr, iplen);\r\nclient_port = sc.src_port;\r\n}\r\nskip = FALSE;\r\nif (memcmp(client_addr, sc.src_addr, iplen) == 0 &&\r\nclient_port == sc.src_port) {\r\nis_server = FALSE;\r\nglobal_pos = &global_client_pos;\r\nif (follow_info->show_stream == FROM_SERVER) {\r\nskip = TRUE;\r\n}\r\n}\r\nelse {\r\nis_server = TRUE;\r\nglobal_pos = &global_server_pos;\r\nif (follow_info->show_stream == FROM_CLIENT) {\r\nskip = TRUE;\r\n}\r\n}\r\nbytes_read = 0;\r\nwhile (bytes_read < sc.dlen) {\r\nbcount = ((sc.dlen-bytes_read) < FLT_BUF_SIZE) ? (sc.dlen-bytes_read) : FLT_BUF_SIZE;\r\nnchars = fread(buffer, 1, bcount, data_out_file);\r\nif (nchars == 0)\r\nbreak;\r\nbytes_read += nchars;\r\nif (!skip) {\r\nfrs_return = follow_show(follow_info, print_line_fcn_p, buffer,\r\nnchars, is_server, arg, global_pos,\r\n&server_packet_count,\r\n&client_packet_count);\r\nif(frs_return == FRS_PRINT_ERROR) {\r\nfclose(data_out_file);\r\ndata_out_file = NULL;\r\nreturn frs_return;\r\n}\r\n}\r\n}\r\n}\r\nif (ferror(data_out_file)) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Error reading temporary file %s: %s", follow_info->data_out_filename,\r\ng_strerror(errno));\r\nfclose(data_out_file);\r\ndata_out_file = NULL;\r\nreturn FRS_READ_ERROR;\r\n}\r\nfclose(data_out_file);\r\ndata_out_file = NULL;\r\nreturn FRS_OK;\r\n}
