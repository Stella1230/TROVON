static void\r\nbytes_view_init(BytesView *bv)\r\n{\r\n#ifdef WANT_PACKET_EDITOR\r\ngtk_widget_set_can_focus(GTK_WIDGET(bv), TRUE);\r\n#endif\r\nbv->context = NULL;\r\nbv->encoding = PACKET_CHAR_ENC_CHAR_ASCII;\r\nbv->format = BYTES_HEX;\r\nbv->per_line = 16;\r\nbv->use_digits = 4;\r\nbv->max_width = 0;\r\n}\r\nstatic void\r\nbytes_view_destroy(BytesView *bv)\r\n{\r\nif (bv->pd) {\r\ng_free(bv->pd);\r\nbv->pd = NULL;\r\n}\r\nif (bv->adj_tag) {\r\ng_source_remove(bv->adj_tag);\r\nbv->adj_tag = 0;\r\n}\r\nif (bv->vadj) {\r\ng_object_unref(G_OBJECT(bv->vadj));\r\nbv->vadj = NULL;\r\n}\r\nif (bv->hadj) {\r\ng_object_unref(G_OBJECT(bv->hadj));\r\nbv->hadj = NULL;\r\n}\r\nif (bv->font) {\r\npango_font_description_free(bv->font);\r\nbv->font = NULL;\r\n}\r\nif (bv->context) {\r\ng_object_unref(bv->context);\r\nbv->context = NULL;\r\n}\r\n}\r\nstatic void\r\nbytes_view_destroy_widget(GtkWidget *widget)\r\n{\r\nbytes_view_destroy(BYTES_VIEW(widget));\r\nGTK_WIDGET_CLASS(parent_class)->destroy(widget);\r\n}\r\nstatic void\r\nbytes_view_destroy_object(GtkObject *object)\r\n{\r\nbytes_view_destroy(BYTES_VIEW(object));\r\nif (GTK_OBJECT_CLASS(parent_class)->destroy)\r\n(*GTK_OBJECT_CLASS(parent_class)->destroy)(object);\r\n}\r\nstatic void\r\nbytes_view_ensure_layout(BytesView *bv)\r\n{\r\nif (bv->context == NULL) {\r\nbv->context = gtk_widget_get_pango_context(GTK_WIDGET(bv));\r\ng_object_ref(bv->context);\r\n{\r\nPangoLanguage *lang;\r\nPangoFontMetrics *metrics;\r\nlang = pango_context_get_language(bv->context);\r\nmetrics = pango_context_get_metrics(bv->context, bv->font, lang);\r\nbv->font_ascent = pango_font_metrics_get_ascent(metrics) / PANGO_SCALE;\r\nbv->font_descent = pango_font_metrics_get_descent(metrics) / PANGO_SCALE;\r\npango_font_metrics_unref(metrics);\r\nbv->fontsize = bv->font_ascent + bv->font_descent;\r\n}\r\ng_assert(bv->context);\r\nbytes_view_adjustment_set(bv);\r\n}\r\n}\r\nstatic void\r\nbytes_view_realize(GtkWidget *widget)\r\n{\r\nBytesView *bv;\r\nGdkWindowAttr attributes;\r\nGtkAllocation allocation;\r\nGdkWindow *win;\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\nGtkStyleContext *context;\r\n#endif\r\n_gtk_widget_set_realized_true(widget);\r\nbv = BYTES_VIEW(widget);\r\ngtk_widget_get_allocation(widget, &allocation);\r\nattributes.window_type = GDK_WINDOW_CHILD;\r\nattributes.x = allocation.x;\r\nattributes.y = allocation.y;\r\nattributes.width = allocation.width;\r\nattributes.height = allocation.height;\r\nattributes.wclass = GDK_INPUT_OUTPUT;\r\nattributes.visual = gtk_widget_get_visual(widget);\r\nattributes.event_mask = gtk_widget_get_events(widget) | GDK_EXPOSURE_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK;\r\n#if !GTK_CHECK_VERSION(3, 0, 0)\r\nattributes.colormap = gtk_widget_get_colormap(widget);\r\nwin = gdk_window_new(gtk_widget_get_parent_window(widget), &attributes, GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP);\r\n#else\r\nwin = gdk_window_new(gtk_widget_get_parent_window(widget), &attributes, GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL);\r\n#endif\r\ngtk_widget_set_window(widget, win);\r\n#if GTK_CHECK_VERSION(3, 8, 0)\r\ngtk_widget_register_window(widget, win);\r\n#else\r\ngdk_window_set_user_data(win, widget);\r\n#endif\r\n#if !GTK_CHECK_VERSION(3, 0, 0)\r\ngdk_window_set_back_pixmap(win, NULL, FALSE);\r\n#endif\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\ncontext = gtk_widget_get_style_context(widget);\r\ngtk_style_context_add_class(context, GTK_STYLE_CLASS_VIEW);\r\n#elif GTK_CHECK_VERSION(2, 20, 0)\r\ngtk_widget_style_attach(widget);\r\n#else\r\nwidget->style = gtk_style_attach(widget->style, win);\r\n#endif\r\nbytes_view_ensure_layout(bv);\r\n}\r\nstatic void\r\nbytes_view_unrealize(GtkWidget *widget)\r\n{\r\nBytesView *bv = BYTES_VIEW(widget);\r\nif (bv->context) {\r\ng_object_unref(bv->context);\r\nbv->context = NULL;\r\n}\r\n#if !GTK_CHECK_VERSION(3, 8, 0)\r\ngdk_window_set_user_data(gtk_widget_get_window(widget), NULL);\r\n#endif\r\nif (parent_class->unrealize)\r\n(*GTK_WIDGET_CLASS(parent_class)->unrealize)(widget);\r\n}\r\nstatic GtkAdjustment *\r\nbytes_view_ensure_vadj(BytesView *bv)\r\n{\r\nif (bv->vadj == NULL) {\r\nbytes_view_set_scroll_adjustments(bv, bv->hadj, bv->vadj);\r\ng_assert(bv->vadj != NULL);\r\n}\r\nreturn bv->vadj;\r\n}\r\nstatic GtkAdjustment *\r\nbytes_view_ensure_hadj(BytesView *bv)\r\n{\r\nif (bv->hadj == NULL) {\r\nbytes_view_set_scroll_adjustments(bv, bv->hadj, bv->vadj);\r\ng_assert(bv->hadj != NULL);\r\n}\r\nreturn bv->hadj;\r\n}\r\nstatic gboolean\r\nbytes_view_scroll(GtkWidget *widget, GdkEventScroll *event)\r\n{\r\nBytesView *bv = BYTES_VIEW(widget);\r\ngdouble new_value;\r\nif (event->direction == GDK_SCROLL_UP) {\r\nbytes_view_ensure_vadj(bv);\r\nnew_value = gtk_adjustment_get_value(bv->vadj) - (gtk_adjustment_get_page_increment(bv->vadj) / 10);\r\nif (new_value < gtk_adjustment_get_lower(bv->vadj))\r\nnew_value = gtk_adjustment_get_lower(bv->vadj);\r\ngtk_adjustment_set_value(bv->vadj, new_value);\r\n} else if (event->direction == GDK_SCROLL_DOWN) {\r\nbytes_view_ensure_vadj(bv);\r\nnew_value = gtk_adjustment_get_value(bv->vadj) + (gtk_adjustment_get_page_increment(bv->vadj) / 10);\r\nif (new_value > (gtk_adjustment_get_upper(bv->vadj) - gtk_adjustment_get_page_size(bv->vadj)))\r\nnew_value = gtk_adjustment_get_upper(bv->vadj) - gtk_adjustment_get_page_size(bv->vadj);\r\ngtk_adjustment_set_value(bv->vadj, new_value);\r\n}\r\nreturn FALSE;\r\n}\r\nstatic void\r\nbytes_view_allocate(GtkWidget *widget, GtkAllocation *allocation)\r\n{\r\ngtk_widget_set_allocation(widget, allocation);\r\nif (gtk_widget_get_realized(widget)) {\r\nBytesView *bv = BYTES_VIEW(widget);\r\ngdk_window_move_resize(gtk_widget_get_window(widget), allocation->x, allocation->y, allocation->width, allocation->height);\r\nbytes_view_adjustment_set(bv);\r\n}\r\n}\r\nstatic void\r\nbytes_view_get_preferred_width(GtkWidget *widget _U_, gint *minimum, gint *natural)\r\n{\r\n*minimum = *natural = 200;\r\n}\r\nstatic void\r\nbytes_view_get_preferred_height(GtkWidget *widget _U_, gint *minimum, gint *natural)\r\n{\r\n*minimum = *natural = 90;\r\n}\r\nstatic void\r\nbytes_view_size_request(GtkWidget *widget _U_, GtkRequisition *requisition)\r\n{\r\nrequisition->width = 200;\r\nrequisition->height = 90;\r\n}\r\nstatic GSList *\r\n_pango_runs_build(BytesView *bv, const char *str, int len)\r\n{\r\nGSList *runs = NULL;\r\nPangoAttrList *attrs;\r\nPangoAttrIterator *iter;\r\nGList *run_list;\r\nGList *tmp_list;\r\nattrs = pango_attr_list_new();\r\npango_attr_list_insert_before(attrs, pango_attr_font_desc_new(bv->font));\r\niter = pango_attr_list_get_iterator(attrs);\r\nrun_list = pango_itemize(bv->context, str, 0, len, attrs, iter);\r\nfor (tmp_list = run_list; tmp_list; tmp_list = tmp_list->next) {\r\nPangoLayoutRun *run = g_slice_new(PangoLayoutRun);\r\nPangoItem *run_item = (PangoItem *)tmp_list->data;\r\nrun->item = run_item;\r\nrun->glyphs = pango_glyph_string_new();\r\npango_shape(str + run_item->offset, run_item->length, &run_item->analysis, run->glyphs);\r\nruns = g_slist_prepend(runs, run);\r\n}\r\ng_list_free(run_list);\r\npango_attr_iterator_destroy(iter);\r\npango_attr_list_unref(attrs);\r\nreturn g_slist_reverse(runs);\r\n}\r\nstatic int\r\n_pango_glyph_string_to_pixels(PangoGlyphString *glyphs, PangoFont *font _U_)\r\n{\r\n#if PANGO_VERSION_MAJOR == 1 && PANGO_VERSION_MINOR >= 14\r\nreturn pango_glyph_string_get_width(glyphs) / PANGO_SCALE;\r\n#else\r\nPangoRectangle logical_rect;\r\npango_glyph_string_extents(glyphs, font, NULL, &logical_rect);\r\nreturn (logical_rect.width / PANGO_SCALE);\r\n#endif\r\n}\r\nstatic int\r\nxtext_draw_layout_line(cairo_t *cr, gint x, gint y, GSList *runs)\r\n{\r\nwhile (runs) {\r\nPangoLayoutRun *run = (PangoLayoutRun *)runs->data;\r\ncairo_move_to(cr, x, y);\r\npango_cairo_show_glyph_string(cr, run->item->analysis.font, run->glyphs);\r\nx += _pango_glyph_string_to_pixels(run->glyphs, run->item->analysis.font);\r\nruns = runs->next;\r\n}\r\nreturn x;\r\n}\r\nstatic int\r\n_pango_runs_width(GSList *runs)\r\n{\r\nint width = 0;\r\nwhile (runs) {\r\nPangoLayoutRun *run = (PangoLayoutRun *)runs->data;\r\nwidth += _pango_glyph_string_to_pixels(run->glyphs, run->item->analysis.font);\r\nruns = runs->next;\r\n}\r\nreturn width;\r\n}\r\nstatic void\r\n_pango_runs_free(GSList *runs)\r\n{\r\nGSList *list = runs;\r\nwhile (list) {\r\nPangoLayoutRun *run = (PangoLayoutRun *)list->data;\r\npango_item_free(run->item);\r\npango_glyph_string_free(run->glyphs);\r\ng_slice_free(PangoLayoutRun, run);\r\nlist = list->next;\r\n}\r\ng_slist_free(runs);\r\n}\r\nstatic int\r\nbytes_view_flush_render(BytesView *bv, void *data, int x, int y, const char *str, int len)\r\n{\r\ncairo_t *cr = (cairo_t *)data;\r\nGSList *line_runs;\r\nint str_width;\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\nGtkStyleContext *context;\r\nGdkRGBA bg_color, fg_color;\r\n#endif\r\nif (len < 1)\r\nreturn 0;\r\nline_runs = _pango_runs_build(bv, str, len);\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\ncontext = gtk_widget_get_style_context(GTK_WIDGET(bv));\r\n#endif\r\nif (bv->state == GTK_STATE_SELECTED || bv->state == GTK_STATE_INSENSITIVE) {\r\nstr_width = _pango_runs_width(line_runs);\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\ngtk_style_context_get_background_color(context, (GtkStateFlags)( (bv->state == GTK_STATE_SELECTED ? GTK_STATE_FLAG_FOCUSED : 0) | GTK_STATE_FLAG_SELECTED), &bg_color);\r\ngdk_cairo_set_source_rgba(cr, &bg_color);\r\n#else\r\ngdk_cairo_set_source_color(cr, &gtk_widget_get_style(GTK_WIDGET(bv))->base[bv->state]);\r\n#endif\r\ncairo_rectangle(cr, x, y - bv->font_ascent, str_width, bv->fontsize);\r\ncairo_fill(cr);\r\n}\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\ngtk_style_context_get_color(context, (GtkStateFlags)(GTK_STATE_FLAG_FOCUSED | (bv->state == GTK_STATE_SELECTED ? GTK_STATE_FLAG_SELECTED : GTK_STATE_FLAG_NORMAL)), &fg_color);\r\ngdk_cairo_set_source_rgba(cr, &fg_color);\r\n#else\r\ngdk_cairo_set_source_color(cr, &gtk_widget_get_style(GTK_WIDGET(bv))->text[bv->state]);\r\n#endif\r\nstr_width = xtext_draw_layout_line(cr, x, y, line_runs)-x;\r\n_pango_runs_free(line_runs);\r\nreturn str_width;\r\n}\r\nstatic int\r\n_pango_runs_find_index(GSList *runs, int x_pos, const char *str)\r\n{\r\nint start_pos = 0;\r\nwhile (runs) {\r\nPangoLayoutRun *run = (PangoLayoutRun *)runs->data;\r\nint width;\r\nwidth = _pango_glyph_string_to_pixels(run->glyphs, run->item->analysis.font);\r\nif (x_pos >= start_pos && x_pos < start_pos + width) {\r\ngboolean char_trailing;\r\nint pos;\r\npango_glyph_string_x_to_index(run->glyphs,\r\n(char *) str + run->item->offset, run->item->length,\r\n&run->item->analysis,\r\n(x_pos - start_pos) * PANGO_SCALE,\r\n&pos, &char_trailing);\r\nreturn run->item->offset + pos;\r\n}\r\nstart_pos += width;\r\nruns = runs->next;\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\nbytes_view_flush_pos(BytesView *bv, void *data, int x, int search_x, const char *str, int len)\r\n{\r\nint *pos_x = (int *)data;\r\nGSList *line_runs;\r\nint line_width;\r\nif (len < 1)\r\nreturn 0;\r\nline_runs = _pango_runs_build(bv, str, len);\r\nline_width = _pango_runs_width(line_runs);\r\nif (x <= search_x && x + line_width > search_x) {\r\nint off_x = search_x - x;\r\nint pos_run;\r\nif ((pos_run = _pango_runs_find_index(line_runs, off_x, str)) != -1)\r\n*pos_x = (-*pos_x) + pos_run;\r\nreturn -1;\r\n} else\r\n*pos_x -= len;\r\n_pango_runs_free(line_runs);\r\nreturn line_width;\r\n}\r\nstatic void\r\nbytes_view_render_state(BytesView *bv, int state)\r\n{\r\ng_assert(state == GTK_STATE_NORMAL || state == GTK_STATE_SELECTED || state == GTK_STATE_INSENSITIVE);\r\nif (bv->bold_highlight) {\r\npango_font_description_set_weight(bv->font,\r\n(state == GTK_STATE_SELECTED) ? PANGO_WEIGHT_BOLD : PANGO_WEIGHT_NORMAL);\r\nbv->state = GTK_STATE_NORMAL;\r\n} else\r\nbv->state = state;\r\n}\r\nstatic void\r\n_bytes_view_line_common(BytesView *bv, void *data, const int org_off, int xx, int arg1, bytes_view_line_cb flush)\r\n{\r\nstatic const guchar hexchars[16] = {\r\n'0', '1', '2', '3', '4', '5', '6', '7',\r\n'8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\r\nconst guint8 *pd = bv->pd;\r\nconst int len = bv->len;\r\nint state;\r\nchar str[128];\r\nint cur = 0;\r\nint off;\r\nguchar c;\r\nint byten;\r\nint j;\r\nint scroll_x;\r\nint dx;\r\ng_assert(org_off >= 0);\r\nscroll_x = (int) gtk_adjustment_get_value(bytes_view_ensure_hadj(bv));\r\nstate = GTK_STATE_NORMAL;\r\nbytes_view_render_state(bv, GTK_STATE_NORMAL);\r\nj = bv->use_digits;\r\ndo {\r\nj--;\r\nc = (org_off >> (j*4)) & 0xF;\r\nstr[cur++] = hexchars[c];\r\n} while (j != 0);\r\nstr[cur++] = ' ';\r\nstr[cur++] = ' ';\r\nfor (byten = 0, off = org_off; byten < bv->per_line; byten++) {\r\ngboolean byte_highlighted =\r\n(off >= bv->start[0] && off < bv->end[0]) ||\r\n(off >= bv->start[1] && off < bv->end[1]);\r\ngboolean proto_byte_highlighted =\r\n(off >= bv->start[2] && off < bv->end[2]);\r\nint state_cur = (off < len && byte_highlighted) ?\r\nGTK_STATE_SELECTED :\r\n(off < len && proto_byte_highlighted) ?\r\nGTK_STATE_INSENSITIVE :\r\nGTK_STATE_NORMAL;\r\nif (state_cur != state) {\r\nint space_now = (state_cur != GTK_STATE_NORMAL && state_cur != GTK_STATE_INSENSITIVE)\r\n|| state == GTK_STATE_NORMAL;\r\nif (space_now && byten) {\r\nstr[cur++] = ' ';\r\nif ((off % BYTE_VIEW_SEP) == 0)\r\nstr[cur++] = ' ';\r\n}\r\nif ((dx = flush(bv, data, xx - scroll_x, arg1, str, cur)) < 0)\r\nreturn;\r\nxx += dx;\r\ncur = 0;\r\nbytes_view_render_state(bv, state_cur);\r\nstate = state_cur;\r\nif (!space_now && byten) {\r\nstr[cur++] = ' ';\r\nif ((off % BYTE_VIEW_SEP) == 0)\r\nstr[cur++] = ' ';\r\n}\r\n} else if (byten) {\r\nstr[cur++] = ' ';\r\nif ((off % BYTE_VIEW_SEP) == 0)\r\nstr[cur++] = ' ';\r\n}\r\nif (off < len) {\r\nswitch (bv->format) {\r\ncase BYTES_HEX:\r\nstr[cur++] = hexchars[(pd[off] & 0xf0) >> 4];\r\nstr[cur++] = hexchars[pd[off] & 0x0f];\r\nbreak;\r\ncase BYTES_BITS:\r\nfor (j = 7; j >= 0; j--)\r\nstr[cur++] = (pd[off] & (1 << j)) ? '1' : '0';\r\nbreak;\r\n}\r\n} else {\r\nswitch (bv->format) {\r\ncase BYTES_HEX:\r\nstr[cur++] = ' ';\r\nstr[cur++] = ' ';\r\nbreak;\r\ncase BYTES_BITS:\r\nfor (j = 7; j >= 0; j--)\r\nstr[cur++] = ' ';\r\nbreak;\r\n}\r\n}\r\noff++;\r\n}\r\nif (state != GTK_STATE_NORMAL) {\r\nif ((dx = flush(bv, data, xx - scroll_x, arg1, str, cur)) < 0)\r\nreturn;\r\nxx += dx;\r\ncur = 0;\r\nbytes_view_render_state(bv, GTK_STATE_NORMAL);\r\nstate = GTK_STATE_NORMAL;\r\n}\r\nstr[cur++] = ' '; str[cur++] = ' '; str[cur++] = ' ';\r\nfor (byten = 0, off = org_off; byten < bv->per_line; byten++) {\r\ngboolean byte_highlighted =\r\n(off >= bv->start[0] && off < bv->end[0]) ||\r\n(off >= bv->start[1] && off < bv->end[1]);\r\ngboolean proto_byte_highlighted =\r\n(off >= bv->start[2] && off < bv->end[2]);\r\nint state_cur = (off < len && byte_highlighted) ?\r\nGTK_STATE_SELECTED :\r\n(off < len && proto_byte_highlighted) ?\r\nGTK_STATE_INSENSITIVE :\r\nGTK_STATE_NORMAL;\r\nif (state_cur != state) {\r\nint space_now = (state_cur != GTK_STATE_NORMAL && state_cur != GTK_STATE_INSENSITIVE)\r\n|| state == GTK_STATE_NORMAL;\r\nif (space_now && byten) {\r\nif ((off % BYTE_VIEW_SEP) == 0)\r\nstr[cur++] = ' ';\r\n}\r\nif ((dx = flush(bv, data, xx - scroll_x, arg1, str, cur)) < 0)\r\nreturn;\r\nxx += dx;\r\ncur = 0;\r\nbytes_view_render_state(bv, state_cur);\r\nstate = state_cur;\r\nif (!space_now && byten) {\r\nif ((off % BYTE_VIEW_SEP) == 0)\r\nstr[cur++] = ' ';\r\n}\r\n} else if (byten) {\r\nif ((off % BYTE_VIEW_SEP) == 0)\r\nstr[cur++] = ' ';\r\n}\r\nif (off < len) {\r\nc = (bv->encoding == PACKET_CHAR_ENC_CHAR_EBCDIC) ?\r\nEBCDIC_to_ASCII1(pd[off]) :\r\npd[off];\r\nstr[cur++] = g_ascii_isprint(c) ? c : '.';\r\n} else\r\nstr[cur++] = ' ';\r\noff++;\r\n}\r\nif (cur) {\r\nif ((dx = flush(bv, data, xx - scroll_x, arg1, str, cur)) < 0)\r\nreturn;\r\nxx += dx;\r\n}\r\nif (state != GTK_STATE_NORMAL) {\r\nbytes_view_render_state(bv, GTK_STATE_NORMAL);\r\n}\r\nif (bv->max_width < xx)\r\nbv->max_width = xx;\r\n}\r\nstatic void\r\n_bytes_view_render_line(BytesView *bv, cairo_t *cr, const int org_off, int yy)\r\n{\r\n_bytes_view_line_common(bv, cr, org_off, MARGIN, yy, bytes_view_flush_render);\r\n}\r\nstatic int\r\n_bytes_view_find_pos(BytesView *bv, const int org_off, int search_x)\r\n{\r\nint pos_x = 0;\r\n_bytes_view_line_common(bv, &pos_x, org_off, MARGIN, search_x, bytes_view_flush_pos);\r\nreturn pos_x;\r\n}\r\nstatic void\r\nbytes_view_render(BytesView *bv, cairo_t *cr, GdkRectangle *area)\r\n{\r\nconst int old_max_width = bv->max_width;\r\nint width, height;\r\nint y;\r\nint off;\r\nguint line, lines_max;\r\nguint lines_max_full;\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\nGtkStyleContext *context;\r\nGdkRGBA bg_color;\r\n#endif\r\nif (!gtk_widget_get_realized(GTK_WIDGET(bv)))\r\nreturn;\r\nbytes_view_ensure_layout(bv);\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\nwidth = gtk_widget_get_allocated_width(GTK_WIDGET(bv));\r\nheight = gtk_widget_get_allocated_height(GTK_WIDGET(bv));\r\n#elif GTK_CHECK_VERSION(2,24,0)\r\nwidth = gdk_window_get_width(gtk_widget_get_window(GTK_WIDGET(bv)));\r\nheight = gdk_window_get_height(gtk_widget_get_window(GTK_WIDGET(bv)));\r\n#else\r\ngdk_drawable_get_size(gtk_widget_get_window(GTK_WIDGET(bv)), &width, &height);\r\n#endif\r\nif (width < 32 + MARGIN || height < bv->fontsize)\r\nreturn;\r\nif (area) {\r\nline = area->y / bv->fontsize;\r\nlines_max = 1 + (area->y + area->height) / bv->fontsize;\r\n} else {\r\nline = 0;\r\nlines_max = (guint) -1;\r\n}\r\ny = (bv->fontsize * line);\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\ncontext = gtk_widget_get_style_context(GTK_WIDGET(bv));\r\ngtk_style_context_get_background_color(context, (GtkStateFlags)(GTK_STATE_FLAG_FOCUSED | GTK_STATE_FLAG_NORMAL), &bg_color);\r\ngdk_cairo_set_source_rgba(cr, &bg_color);\r\n#else\r\ngdk_cairo_set_source_color(cr, &gtk_widget_get_style(GTK_WIDGET(bv))->base[GTK_STATE_NORMAL]);\r\n#endif\r\nif (area)\r\ncairo_rectangle(cr, area->x, area->y, area->x + area->width, area->y + area->height);\r\nelse\r\ncairo_rectangle(cr, 0, 0, width, height);\r\ncairo_fill(cr);\r\nif (bv->pd) {\r\nguint real_line = line + (guint) gtk_adjustment_get_value(bytes_view_ensure_vadj(bv));\r\nlines_max_full = (height / bv->fontsize) + 1;\r\nif (lines_max_full < lines_max)\r\nlines_max = lines_max_full;\r\noff = real_line * bv->per_line;\r\nwhile (off < bv->len) {\r\n_bytes_view_render_line(bv, cr, off, y + bv->font_ascent);\r\nline++;\r\nif (line >= lines_max)\r\nbreak;\r\noff += bv->per_line;\r\ny += bv->fontsize;\r\n}\r\n}\r\nif (old_max_width != bv->max_width)\r\nbytes_view_adjustment_set(bv);\r\n}\r\nstatic void\r\nbytes_view_render_full(BytesView *bv)\r\n{\r\ncairo_t *cr;\r\nif (bv->adj_tag) {\r\ng_source_remove(bv->adj_tag);\r\nbv->adj_tag = 0;\r\n}\r\ncr = gdk_cairo_create(gtk_widget_get_window(GTK_WIDGET(bv)));\r\nbytes_view_render(bv, cr, NULL);\r\ncairo_destroy(cr);\r\n}\r\nstatic gboolean\r\nbytes_view_draw(GtkWidget *widget, cairo_t *cr)\r\n{\r\nGdkRectangle area;\r\ngdk_cairo_get_clip_rectangle(cr, &area);\r\nbytes_view_render(BYTES_VIEW(widget), cr, &area);\r\nreturn FALSE;\r\n}\r\nstatic gboolean\r\nbytes_view_expose(GtkWidget *widget, GdkEventExpose *event)\r\n{\r\nBytesView *bv = BYTES_VIEW(widget);\r\ncairo_t *cr;\r\ncr = gdk_cairo_create(gtk_widget_get_window(GTK_WIDGET(bv)));\r\ngdk_cairo_region(cr, event->region);\r\ncairo_clip(cr);\r\nbytes_view_render(bv, cr, &event->area);\r\ncairo_destroy(cr);\r\nreturn FALSE;\r\n}\r\nstatic void\r\n_gtk_adjustment_configure(GtkAdjustment *adj,\r\ngdouble value,\r\ngdouble lower,\r\ngdouble upper,\r\ngdouble step_increment,\r\ngdouble page_increment,\r\ngdouble page_size)\r\n{\r\nadj->value = value;\r\nadj->lower = lower;\r\nadj->upper = upper;\r\nadj->step_increment = step_increment;\r\nadj->page_increment = page_increment;\r\nadj->page_size = page_size;\r\ngtk_adjustment_changed(adj);\r\n}\r\nstatic void\r\nbytes_view_adjustment_set(BytesView *bv)\r\n{\r\nGtkAllocation allocation;\r\ndouble lower, upper, page_size, step_increment, page_increment, value;\r\nif (bv->vadj == NULL || bv->hadj == NULL)\r\nreturn;\r\nif (bv->context == NULL) {\r\nbytes_view_ensure_layout(bv);\r\nreturn;\r\n}\r\ngtk_widget_get_allocation(GTK_WIDGET(bv), &allocation);\r\nif (bv->vadj) {\r\nlower = 0;\r\nupper = (int) (bv->len / bv->per_line);\r\nif ((bv->len % bv->per_line))\r\nupper++;\r\npage_size = (allocation.height - bv->font_descent) / bv->fontsize;\r\npage_increment = page_size;\r\nstep_increment = 1;\r\nvalue = gtk_adjustment_get_value(bv->vadj);\r\nif (value > upper - page_size)\r\nvalue = upper - page_size;\r\nif (value < 0)\r\nvalue = 0;\r\n_gtk_adjustment_configure(bv->vadj, value, lower, upper, step_increment, page_increment, page_size);\r\n}\r\nif (bv->hadj) {\r\nlower = 0;\r\nupper = bv->max_width;\r\npage_size = allocation.width;\r\npage_increment = page_size;\r\nstep_increment = page_size / 10.0;\r\nvalue = gtk_adjustment_get_value(bv->hadj);\r\nif (value > upper - page_size)\r\nvalue = upper - page_size;\r\nif (value < 0)\r\nvalue = 0;\r\n_gtk_adjustment_configure(bv->hadj, value, lower, upper, step_increment, page_increment, page_size);\r\n}\r\n}\r\nstatic gint\r\nbytes_view_adjustment_timeout(BytesView *bv)\r\n{\r\nbv->adj_tag = 0;\r\nbytes_view_render_full(bv);\r\nreturn 0;\r\n}\r\nstatic void\r\nbytes_view_adjustment_changed(GtkAdjustment *adj, BytesView *bv)\r\n{\r\nif (adj && ((adj == bv->vadj) || (adj == bv->hadj))) {\r\nif (!bv->adj_tag)\r\nbv->adj_tag = g_timeout_add(REFRESH_TIMEOUT, (GSourceFunc) bytes_view_adjustment_timeout, bv);\r\n}\r\n}\r\nstatic void\r\nbytes_view_set_scroll_adjustments(BytesView *bv, GtkAdjustment *hadj, GtkAdjustment *vadj)\r\n{\r\ngboolean need_adjust = FALSE;\r\ng_return_if_fail(!hadj || GTK_IS_ADJUSTMENT(hadj));\r\ng_return_if_fail(!vadj || GTK_IS_ADJUSTMENT(vadj));\r\nif (!vadj)\r\nvadj = GTK_ADJUSTMENT(gtk_adjustment_new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0));\r\nif (!hadj)\r\nhadj = GTK_ADJUSTMENT(gtk_adjustment_new(0.0, 0.0, 0.0, 0.0, 0.0, 0.0));\r\nif (bv->vadj && (bv->vadj != vadj)) {\r\ng_signal_handlers_disconnect_by_func(bv->vadj, bytes_view_adjustment_changed, bv);\r\ng_object_unref(bv->vadj);\r\n}\r\nif (bv->vadj != vadj) {\r\nbv->vadj = vadj;\r\ng_object_ref_sink(bv->vadj);\r\ng_signal_connect(bv->vadj, "value-changed", G_CALLBACK(bytes_view_adjustment_changed), bv);\r\nneed_adjust = TRUE;\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\ng_object_notify(G_OBJECT(bv), "vadjustment");\r\n#endif\r\n}\r\nif (bv->hadj && (bv->hadj != hadj)) {\r\ng_signal_handlers_disconnect_by_func(bv->hadj, bytes_view_adjustment_changed, bv);\r\ng_object_unref(bv->hadj);\r\n}\r\nif (bv->hadj != hadj) {\r\nbv->hadj = hadj;\r\ng_object_ref_sink(bv->hadj);\r\ng_signal_connect(bv->hadj, "value-changed", G_CALLBACK(bytes_view_adjustment_changed), bv);\r\nneed_adjust = TRUE;\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\ng_object_notify(G_OBJECT(bv), "hadjustment");\r\n#endif\r\n}\r\nif (need_adjust)\r\nbytes_view_adjustment_set(bv);\r\n}\r\nstatic void\r\nbytes_view_set_property(GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)\r\n{\r\nBytesView *bv = BYTES_VIEW(object);\r\nswitch (prop_id) {\r\ncase PROP_HADJUSTMENT:\r\nbytes_view_set_scroll_adjustments(bv, (GtkAdjustment *)g_value_get_object(value), bv->vadj);\r\nbreak;\r\ncase PROP_VADJUSTMENT:\r\nbytes_view_set_scroll_adjustments(bv, bv->hadj, (GtkAdjustment *)g_value_get_object(value));\r\nbreak;\r\ncase PROP_HSCROLL_POLICY:\r\nbv->hscroll_policy = g_value_get_enum(value);\r\ngtk_widget_queue_resize(GTK_WIDGET(bv));\r\nbreak;\r\ncase PROP_VSCROLL_POLICY:\r\nbv->vscroll_policy = g_value_get_enum(value);\r\ngtk_widget_queue_resize(GTK_WIDGET(bv));\r\nbreak;\r\ndefault:\r\nG_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbytes_view_get_property(GObject *object, guint prop_id, GValue *value, GParamSpec *pspec)\r\n{\r\nBytesView *bv = BYTES_VIEW(object);\r\nswitch (prop_id) {\r\ncase PROP_HADJUSTMENT:\r\ng_value_set_object(value, bv->hadj);\r\nbreak;\r\ncase PROP_VADJUSTMENT:\r\ng_value_set_object(value, bv->vadj);\r\nbreak;\r\ncase PROP_HSCROLL_POLICY:\r\ng_value_set_enum(value, bv->hscroll_policy);\r\nbreak;\r\ncase PROP_VSCROLL_POLICY:\r\ng_value_set_enum(value, bv->vscroll_policy);\r\nbreak;\r\ndefault:\r\nG_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nbv_VOID__OBJECT_OBJECT(GClosure *closure, GValue *return_value _U_, guint n_params, const GValue *param_values, gpointer hint _U_, gpointer marshal_data)\r\n{\r\ntypedef void (*GMarshalFunc_VOID__OBJECT_OBJECT)(gpointer, gpointer, gpointer, gpointer);\r\nregister GMarshalFunc_VOID__OBJECT_OBJECT callback;\r\nregister GCClosure *cc = (GCClosure*) closure;\r\nregister gpointer data1, data2;\r\ng_return_if_fail(n_params == 3);\r\nif (G_CCLOSURE_SWAP_DATA(closure)) {\r\ndata1 = closure->data;\r\ndata2 = g_value_peek_pointer(param_values + 0);\r\n} else {\r\ndata1 = g_value_peek_pointer(param_values + 0);\r\ndata2 = closure->data;\r\n}\r\ncallback = (GMarshalFunc_VOID__OBJECT_OBJECT) (marshal_data ? marshal_data : cc->callback);\r\ncallback(data1, g_value_get_object(param_values + 1), g_value_get_object(param_values + 2), data2);\r\n}\r\nstatic void\r\nbytes_view_class_init(BytesViewClass *klass)\r\n{\r\n#if !GTK_CHECK_VERSION(3, 0, 0)\r\nGtkObjectClass *object_class;\r\n#endif\r\nGtkWidgetClass *widget_class;\r\nparent_class = (GtkWidgetClass *) g_type_class_peek_parent(klass);\r\n#if !GTK_CHECK_VERSION(3, 0, 0)\r\nobject_class = (GtkObjectClass *) klass;\r\n#endif\r\nwidget_class = (GtkWidgetClass *) klass;\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\nwidget_class->destroy = bytes_view_destroy_widget;\r\n#else\r\nobject_class->destroy = bytes_view_destroy_object;\r\n#endif\r\nwidget_class->realize = bytes_view_realize;\r\nwidget_class->unrealize = bytes_view_unrealize;\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\nwidget_class->get_preferred_width = bytes_view_get_preferred_width;\r\nwidget_class->get_preferred_height = bytes_view_get_preferred_height;\r\n#else\r\nwidget_class->size_request = bytes_view_size_request;\r\n#endif\r\nwidget_class->size_allocate = bytes_view_allocate;\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\nwidget_class->draw = bytes_view_draw;\r\n#else\r\nwidget_class->expose_event = bytes_view_expose;\r\n#endif\r\nwidget_class->scroll_event = bytes_view_scroll;\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\n{\r\nGObjectClass *gobject_class = G_OBJECT_CLASS(klass);\r\ngobject_class->set_property = bytes_view_set_property;\r\ngobject_class->get_property = bytes_view_get_property;\r\ng_object_class_override_property(gobject_class, PROP_HADJUSTMENT, "hadjustment");\r\ng_object_class_override_property(gobject_class, PROP_VADJUSTMENT, "vadjustment");\r\ng_object_class_override_property(gobject_class, PROP_HSCROLL_POLICY, "hscroll-policy");\r\ng_object_class_override_property(gobject_class, PROP_VSCROLL_POLICY, "vscroll-policy");\r\n}\r\n#else\r\nklass->set_scroll_adjustments = bytes_view_set_scroll_adjustments;\r\nwidget_class->set_scroll_adjustments_signal =\r\ng_signal_new(g_intern_static_string("set-scroll-adjustments"),\r\nG_OBJECT_CLASS_TYPE(object_class),\r\n(GSignalFlags)(G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION),\r\nG_STRUCT_OFFSET(BytesViewClass, set_scroll_adjustments),\r\nNULL, NULL,\r\nbv_VOID__OBJECT_OBJECT,\r\nG_TYPE_NONE, 2,\r\nGTK_TYPE_ADJUSTMENT,\r\nGTK_TYPE_ADJUSTMENT);\r\n#endif\r\n}\r\nGType\r\nbytes_view_get_type(void)\r\n{\r\nstatic GType bytes_view_gtype = 0;\r\nif (!bytes_view_gtype) {\r\nstatic const GTypeInfo bytes_view_info = {\r\nsizeof (BytesViewClass),\r\nNULL,\r\nNULL,\r\n(GClassInitFunc) bytes_view_class_init,\r\nNULL,\r\nNULL,\r\nsizeof(BytesView),\r\n0,\r\n(GInstanceInitFunc) bytes_view_init,\r\nNULL\r\n};\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\nstatic const GInterfaceInfo scrollable_info = {\r\nNULL,\r\nNULL,\r\nNULL\r\n};\r\n#endif\r\nbytes_view_gtype = g_type_register_static(GTK_TYPE_WIDGET,\r\n"BytesView",\r\n&bytes_view_info,\r\n(GTypeFlags)0);\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\ng_type_add_interface_static(bytes_view_gtype,\r\nGTK_TYPE_SCROLLABLE,\r\n&scrollable_info);\r\n#endif\r\n}\r\nreturn bytes_view_gtype;\r\n}\r\nint\r\nbytes_view_byte_from_xy(BytesView *bv, int x, int y)\r\n{\r\nstatic const int hex_pos_byte[70] = {\r\n-1, -1,\r\n0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3,\r\n4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7,\r\n-1,\r\n8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11,\r\n12, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15,\r\n-1, -1,\r\n0, 1, 2, 3, 4, 5, 6, 7,\r\n-1,\r\n8, 9, 10, 11, 12, 13, 14, 15\r\n};\r\nstatic const int bits_pos_byte[84] = {\r\n-1, -1,\r\n0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,\r\n2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,\r\n4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,\r\n6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n-1, -1,\r\n0, 1, 2, 3, 4, 5, 6, 7\r\n};\r\nint char_x, off_x = 1;\r\nint char_y, off_y;\r\nif (x < MARGIN)\r\nreturn -1;\r\nbytes_view_ensure_layout(bv);\r\nchar_y = (int) gtk_adjustment_get_value(bytes_view_ensure_vadj(bv)) + (y / bv->fontsize);\r\noff_y = char_y * bv->per_line;\r\nchar_x = _bytes_view_find_pos(bv, off_y, x);\r\nif ( char_x < bv->use_digits)\r\nreturn -1;\r\nchar_x -= bv->use_digits;\r\nswitch (bv->format) {\r\ncase BYTES_BITS:\r\ng_return_val_if_fail(char_x >= 0 && char_x < (int) G_N_ELEMENTS(bits_pos_byte), -1);\r\noff_x = bits_pos_byte[char_x];\r\nbreak;\r\ncase BYTES_HEX:\r\ng_return_val_if_fail(char_x >= 0 && char_x < (int) G_N_ELEMENTS(hex_pos_byte), -1);\r\noff_x = hex_pos_byte[char_x];\r\nbreak;\r\n}\r\nif (off_x == -1)\r\nreturn -1;\r\nreturn off_y + off_x;\r\n}\r\nvoid\r\nbytes_view_scroll_to_byte(BytesView *bv, int byte)\r\n{\r\nint line;\r\ng_return_if_fail(byte >= 0 && byte < bv->len);\r\nline = byte / bv->per_line;\r\nbytes_view_ensure_vadj(bv);\r\nif (line > gtk_adjustment_get_upper(bv->vadj) - gtk_adjustment_get_page_size(bv->vadj)) {\r\nline = (int)(gtk_adjustment_get_upper(bv->vadj) - gtk_adjustment_get_page_size(bv->vadj));\r\nif (line < 0)\r\nline = 0;\r\n}\r\ng_signal_handlers_block_by_func(bv->vadj, bytes_view_adjustment_changed, bv);\r\ngtk_adjustment_set_value(bv->vadj, line);\r\ng_signal_handlers_unblock_by_func(bv->vadj, bytes_view_adjustment_changed, bv);\r\n}\r\nvoid\r\nbytes_view_set_font(BytesView *bv, PangoFontDescription *font)\r\n{\r\nif (bv->font)\r\npango_font_description_free(bv->font);\r\n#if GTK_CHECK_VERSION(3, 0, 0)\r\ngtk_widget_override_font(GTK_WIDGET(bv), font);\r\n#else\r\ngtk_widget_modify_font(GTK_WIDGET(bv), font);\r\n#endif\r\nbv->font = pango_font_description_copy(font);\r\nbv->max_width = 0;\r\nif (bv->context) {\r\ng_object_unref(bv->context);\r\nbv->context = NULL;\r\nbytes_view_ensure_layout(bv);\r\n}\r\n}\r\nvoid\r\nbytes_view_set_data(BytesView *bv, const guint8 *data, int len)\r\n{\r\ng_free(bv->pd);\r\nbv->pd = (guint8 *)g_memdup(data, len);\r\nbv->len = len;\r\nif (((len - 1) & 0xF0000000) != 0)\r\nbv->use_digits = 8;\r\nelse if (((len - 1) & 0x0F000000) != 0)\r\nbv->use_digits = 7;\r\nelse if (((len - 1) & 0x00F00000) != 0)\r\nbv->use_digits = 6;\r\nelse if (((len - 1) & 0x000F0000) != 0)\r\nbv->use_digits = 5;\r\nelse\r\nbv->use_digits = 4;\r\nbytes_view_ensure_vadj(bv);\r\nbytes_view_adjustment_set(bv);\r\n}\r\nvoid\r\nbytes_view_set_encoding(BytesView *bv, int enc)\r\n{\r\ng_assert(enc == PACKET_CHAR_ENC_CHAR_ASCII || enc == PACKET_CHAR_ENC_CHAR_EBCDIC);\r\nbv->encoding = (packet_char_enc)enc;\r\n}\r\nvoid\r\nbytes_view_set_format(BytesView *bv, int format)\r\n{\r\ng_assert(format == BYTES_HEX || format == BYTES_BITS);\r\nbv->format = (bytes_view_type)format;\r\nswitch (format) {\r\ncase BYTES_BITS:\r\nbv->per_line = 8;\r\nbreak;\r\ncase BYTES_HEX:\r\nbv->per_line = 16;\r\nbreak;\r\n}\r\n}\r\nvoid\r\nbytes_view_set_highlight_style(BytesView *bv, gboolean inverse)\r\n{\r\nbv->bold_highlight = !inverse;\r\n}\r\nvoid\r\nbytes_view_set_highlight(BytesView *bv, int start, int end, guint32 mask _U_, int maskle _U_)\r\n{\r\nbv->start[0] = start;\r\nbv->end[0] = end;\r\n}\r\nvoid\r\nbytes_view_set_highlight_extra(BytesView *bv, int id, int start, int end)\r\n{\r\nbv->start[id] = start;\r\nbv->end[id] = end;\r\n}\r\nvoid\r\nbytes_view_refresh(BytesView *bv)\r\n{\r\ngtk_widget_queue_draw(GTK_WIDGET(bv));\r\n}\r\nGtkWidget *\r\nbytes_view_new(void)\r\n{\r\nGtkWidget *widget;\r\nwidget = (GtkWidget *) g_object_new(BYTES_VIEW_TYPE, NULL);\r\ng_assert(widget != NULL);\r\nreturn widget;\r\n}
