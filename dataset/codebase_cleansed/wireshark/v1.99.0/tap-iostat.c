static int\r\niostat_packet(void *arg, packet_info *pinfo, epan_dissect_t *edt, const void *dummy _U_)\r\n{\r\nio_stat_t *parent;\r\nio_stat_item_t *mit;\r\nio_stat_item_t *it;\r\nguint64 relative_time, rt;\r\nnstime_t *new_time;\r\nGPtrArray *gp;\r\nguint i;\r\nint ftype;\r\nmit = (io_stat_item_t *) arg;\r\nparent = mit->parent;\r\nif (pinfo->rel_ts.secs >= 0) {\r\nrelative_time = ((guint64)pinfo->rel_ts.secs * G_GUINT64_CONSTANT(1000000)) +\r\n((guint64)((pinfo->rel_ts.nsecs+500)/1000));\r\nlast_relative_time = relative_time;\r\n} else {\r\nrelative_time = last_relative_time;\r\n}\r\nif (mit->parent->start_time == 0) {\r\nmit->parent->start_time = pinfo->fd->abs_ts.secs - pinfo->rel_ts.secs;\r\n}\r\nit = mit->prev;\r\nrt = relative_time;\r\nwhile (rt >= it->time + parent->interval) {\r\nit->next = (io_stat_item_t *)g_malloc(sizeof(io_stat_item_t));\r\nit->next->prev = it;\r\nit->next->next = NULL;\r\nit = it->next;\r\nmit->prev = it;\r\nit->time = it->prev->time + parent->interval;\r\nit->frames = 0;\r\nit->counter = 0;\r\nit->float_counter = 0;\r\nit->double_counter = 0;\r\nit->num = 0;\r\nit->calc_type = it->prev->calc_type;\r\nit->hf_index = it->prev->hf_index;\r\nit->colnum = it->prev->colnum;\r\n}\r\nit->frames++;\r\nswitch(it->calc_type) {\r\ncase CALC_TYPE_FRAMES:\r\ncase CALC_TYPE_BYTES:\r\ncase CALC_TYPE_FRAMES_AND_BYTES:\r\nit->counter += pinfo->fd->pkt_len;\r\nbreak;\r\ncase CALC_TYPE_COUNT:\r\ngp=proto_get_finfo_ptr_array(edt->tree, it->hf_index);\r\nif(gp){\r\nit->counter += gp->len;\r\n}\r\nbreak;\r\ncase CALC_TYPE_SUM:\r\ngp=proto_get_finfo_ptr_array(edt->tree, it->hf_index);\r\nif(gp){\r\nguint64 val;\r\nfor(i=0;i<gp->len;i++){\r\nswitch(proto_registrar_get_ftype(it->hf_index)){\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\nit->counter += fvalue_get_uinteger(&((field_info *)gp->pdata[i])->value);\r\nbreak;\r\ncase FT_UINT64:\r\nit->counter += fvalue_get_integer64(&((field_info *)gp->pdata[i])->value);\r\nbreak;\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\nit->counter += fvalue_get_sinteger(&((field_info *)gp->pdata[i])->value);\r\nbreak;\r\ncase FT_INT64:\r\nit->counter += (gint64)fvalue_get_integer64(&((field_info *)gp->pdata[i])->value);\r\nbreak;\r\ncase FT_FLOAT:\r\nit->float_counter +=\r\n(gfloat)fvalue_get_floating(&((field_info *)gp->pdata[i])->value);\r\nbreak;\r\ncase FT_DOUBLE:\r\nit->double_counter += fvalue_get_floating(&((field_info *)gp->pdata[i])->value);\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nnew_time = (nstime_t *)fvalue_get(&((field_info *)gp->pdata[i])->value);\r\nval = ((guint64)new_time->secs * NANOSECS_PER_SEC) + (guint64)new_time->nsecs;\r\nit->counter += val;\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CALC_TYPE_MIN:\r\ngp=proto_get_finfo_ptr_array(edt->tree, it->hf_index);\r\nif(gp){\r\nguint64 val;\r\ngfloat float_val;\r\ngdouble double_val;\r\nftype=proto_registrar_get_ftype(it->hf_index);\r\nfor(i=0;i<gp->len;i++){\r\nswitch(ftype){\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\nval = fvalue_get_uinteger(&((field_info *)gp->pdata[i])->value);\r\nif ((it->frames==1 && i==0) || (val < it->counter)) {\r\nit->counter=val;\r\n}\r\nbreak;\r\ncase FT_UINT64:\r\nval = fvalue_get_integer64(&((field_info *)gp->pdata[i])->value);\r\nif((it->frames==1 && i==0) || (val < it->counter)){\r\nit->counter=val;\r\n}\r\nbreak;\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\nval = fvalue_get_sinteger(&((field_info *)gp->pdata[i])->value);\r\nif((it->frames==1 && i==0) || ((gint32)val < (gint32)it->counter)) {\r\nit->counter=val;\r\n}\r\nbreak;\r\ncase FT_INT64:\r\nval = fvalue_get_integer64(&((field_info *)gp->pdata[i])->value);\r\nif((it->frames==1 && i==0) || ((gint64)val < (gint64)it->counter)) {\r\nit->counter=val;\r\n}\r\nbreak;\r\ncase FT_FLOAT:\r\nfloat_val=(gfloat)fvalue_get_floating(&((field_info *)gp->pdata[i])->value);\r\nif((it->frames==1 && i==0) || (float_val < it->float_counter)) {\r\nit->float_counter=float_val;\r\n}\r\nbreak;\r\ncase FT_DOUBLE:\r\ndouble_val=fvalue_get_floating(&((field_info *)gp->pdata[i])->value);\r\nif((it->frames==1 && i==0) || (double_val < it->double_counter)) {\r\nit->double_counter=double_val;\r\n}\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nnew_time = (nstime_t *)fvalue_get(&((field_info *)gp->pdata[i])->value);\r\nval = ((guint64)new_time->secs * NANOSECS_PER_SEC) + (guint64)new_time->nsecs;\r\nif((it->frames==1 && i==0) || (val < it->counter)) {\r\nit->counter=val;\r\n}\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CALC_TYPE_MAX:\r\ngp=proto_get_finfo_ptr_array(edt->tree, it->hf_index);\r\nif(gp){\r\nguint64 val;\r\ngfloat float_val;\r\ngdouble double_val;\r\nftype=proto_registrar_get_ftype(it->hf_index);\r\nfor(i=0;i<gp->len;i++){\r\nswitch(ftype){\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\nval = fvalue_get_uinteger(&((field_info *)gp->pdata[i])->value);\r\nif(val > it->counter)\r\nit->counter=val;\r\nbreak;\r\ncase FT_UINT64:\r\nval = fvalue_get_integer64(&((field_info *)gp->pdata[i])->value);\r\nif(val > it->counter)\r\nit->counter=val;\r\nbreak;\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\nval = fvalue_get_sinteger(&((field_info *)gp->pdata[i])->value);\r\nif((gint32)val > (gint32)it->counter)\r\nit->counter=val;\r\nbreak;\r\ncase FT_INT64:\r\nval = fvalue_get_integer64(&((field_info *)gp->pdata[i])->value);\r\nif ((gint64)val > (gint64)it->counter)\r\nit->counter=val;\r\nbreak;\r\ncase FT_FLOAT:\r\nfloat_val = (gfloat)fvalue_get_floating(&((field_info *)gp->pdata[i])->value);\r\nif(float_val > it->float_counter)\r\nit->float_counter=float_val;\r\nbreak;\r\ncase FT_DOUBLE:\r\ndouble_val = fvalue_get_floating(&((field_info *)gp->pdata[i])->value);\r\nif(double_val > it->double_counter)\r\nit->double_counter=double_val;\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nnew_time = (nstime_t *)fvalue_get(&((field_info *)gp->pdata[i])->value);\r\nval = ((guint64)new_time->secs * NANOSECS_PER_SEC) + (guint64)new_time->nsecs;\r\nif (val>it->counter)\r\nit->counter=val;\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CALC_TYPE_AVG:\r\ngp=proto_get_finfo_ptr_array(edt->tree, it->hf_index);\r\nif(gp){\r\nguint64 val;\r\nftype=proto_registrar_get_ftype(it->hf_index);\r\nfor(i=0;i<gp->len;i++){\r\nit->num++;\r\nswitch(ftype) {\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\nval = fvalue_get_uinteger(&((field_info *)gp->pdata[i])->value);\r\nit->counter += val;\r\nbreak;\r\ncase FT_UINT64:\r\ncase FT_INT64:\r\nval = fvalue_get_integer64(&((field_info *)gp->pdata[i])->value);\r\nit->counter += val;\r\nbreak;\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\nval = fvalue_get_sinteger(&((field_info *)gp->pdata[i])->value);\r\nit->counter += val;\r\nbreak;\r\ncase FT_FLOAT:\r\nit->float_counter += (gfloat)fvalue_get_floating(&((field_info *)gp->pdata[i])->value);\r\nbreak;\r\ncase FT_DOUBLE:\r\nit->double_counter += fvalue_get_floating(&((field_info *)gp->pdata[i])->value);\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nnew_time = (nstime_t *)fvalue_get(&((field_info *)gp->pdata[i])->value);\r\nval = ((guint64)new_time->secs * NANOSECS_PER_SEC) + (guint64)new_time->nsecs;\r\nit->counter += val;\r\nbreak;\r\ndefault:\r\ng_assert_not_reached();\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CALC_TYPE_LOAD:\r\ngp = proto_get_finfo_ptr_array(edt->tree, it->hf_index);\r\nif (gp) {\r\nftype = proto_registrar_get_ftype(it->hf_index);\r\nif (ftype != FT_RELATIVE_TIME) {\r\nfprintf(stderr,\r\n"\ntshark: LOAD() is only supported for relative-time fields such as smb.time\n");\r\nexit(10);\r\n}\r\nfor(i=0;i<gp->len;i++){\r\nguint64 val;\r\nint tival;\r\nio_stat_item_t *pit;\r\nnew_time = (nstime_t *)fvalue_get(&((field_info *)gp->pdata[i])->value);\r\nval = ((guint64)new_time->secs*G_GUINT64_CONSTANT(1000000)) + (guint64)(new_time->nsecs/1000);\r\ntival = (int)(val % parent->interval);\r\nit->counter += tival;\r\nval -= tival;\r\npit = it->prev;\r\nwhile (val > 0) {\r\nif (val < (guint64)parent->interval) {\r\npit->counter += val;\r\nbreak;\r\n}\r\npit->counter += parent->interval;\r\nval -= parent->interval;\r\npit = pit->prev;\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\nswitch(it->calc_type) {\r\ncase CALC_TYPE_FRAMES:\r\ncase CALC_TYPE_FRAMES_AND_BYTES:\r\nparent->max_frame[it->colnum] =\r\nMAX(parent->max_frame[it->colnum], it->frames);\r\nif (it->calc_type==CALC_TYPE_FRAMES_AND_BYTES)\r\nparent->max_vals[it->colnum] =\r\nMAX(parent->max_vals[it->colnum], it->counter);\r\ncase CALC_TYPE_BYTES:\r\ncase CALC_TYPE_COUNT:\r\ncase CALC_TYPE_LOAD:\r\nparent->max_vals[it->colnum] = MAX(parent->max_vals[it->colnum], it->counter);\r\nbreak;\r\ncase CALC_TYPE_SUM:\r\ncase CALC_TYPE_MIN:\r\ncase CALC_TYPE_MAX:\r\nftype=proto_registrar_get_ftype(it->hf_index);\r\nswitch(ftype) {\r\ncase FT_FLOAT:\r\nparent->max_vals[it->colnum] =\r\nMAX(parent->max_vals[it->colnum], (guint64)(it->float_counter+0.5));\r\nbreak;\r\ncase FT_DOUBLE:\r\nparent->max_vals[it->colnum] =\r\nMAX(parent->max_vals[it->colnum],(guint64)(it->double_counter+0.5));\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nparent->max_vals[it->colnum] =\r\nMAX(parent->max_vals[it->colnum], it->counter);\r\nbreak;\r\ndefault:\r\nparent->max_vals[it->colnum] =\r\nMAX(parent->max_vals[it->colnum], it->counter);\r\nbreak;\r\n}\r\nbreak;\r\ncase CALC_TYPE_AVG:\r\nif (it->num==0)\r\nbreak;\r\nftype=proto_registrar_get_ftype(it->hf_index);\r\nswitch(ftype) {\r\ncase FT_FLOAT:\r\nparent->max_vals[it->colnum] =\r\nMAX(parent->max_vals[it->colnum], (guint64)it->float_counter/it->num);\r\nbreak;\r\ncase FT_DOUBLE:\r\nparent->max_vals[it->colnum] =\r\nMAX(parent->max_vals[it->colnum],(guint64)it->double_counter/it->num);\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nparent->max_vals[it->colnum] =\r\nMAX(parent->max_vals[it->colnum], ((it->counter/(guint64)it->num) + G_GUINT64_CONSTANT(500000000)) / NANOSECS_PER_SEC);\r\nbreak;\r\ndefault:\r\nparent->max_vals[it->colnum] =\r\nMAX(parent->max_vals[it->colnum], it->counter/it->num);\r\nbreak;\r\n}\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int\r\nmagnitude (guint64 val, int max_w)\r\n{\r\nint i, mag=0;\r\nfor (i=0; i<max_w; i++) {\r\nmag++;\r\nif ((val /= 10)==0)\r\nbreak;\r\n}\r\nreturn(mag);\r\n}\r\nstatic void\r\nprintcenter (const char *label, int lenval, int numpad)\r\n{\r\nint lenlab = (int) strlen(label), len;\r\nconst char spaces[]=" ", *spaces_ptr;\r\nlen = (int) (strlen(spaces)) - (((lenval-lenlab) / 2) + numpad);\r\nif (len > 0 && len < 6) {\r\nspaces_ptr = &spaces[len];\r\nif ((lenval-lenlab)%2==0) {\r\nprintf("%s%s%s|", spaces_ptr, label, spaces_ptr);\r\n} else {\r\nprintf("%s%s%s|", spaces_ptr-1, label, spaces_ptr);\r\n}\r\n} else if (len > 0 && len <= 15) {\r\nprintf("%s|", label);\r\n}\r\n}\r\nstatic void\r\niostat_draw(void *arg)\r\n{\r\nguint32 num;\r\nguint64 interval, duration, t, invl_end, dv;\r\nint i, j, k, num_cols, num_rows, dur_secs_orig, dur_nsecs_orig, dur_secs, dur_nsecs, dur_mag,\r\ninvl_mag, invl_prec, tabrow_w, borderlen, invl_col_w, numpad=1, namelen, len_filt, type,\r\nmaxfltr_w, ftype;\r\nint fr_mag;\r\nint val_mag;\r\nchar *spaces, *spaces_s, *filler_s=NULL, **fmts, *fmt=NULL;\r\nconst char *filter;\r\nstatic gchar dur_mag_s[3], invl_prec_s[3], fr_mag_s[3], val_mag_s[3], *invl_fmt, *full_fmt;\r\nio_stat_item_t *mit, **stat_cols, *item, **item_in_column;\r\ngboolean last_row=FALSE;\r\nio_stat_t *iot;\r\ncolumn_width *col_w;\r\nstruct tm *tm_time;\r\ntime_t the_time;\r\nmit = (io_stat_item_t *)arg;\r\niot = mit->parent;\r\nnum_cols = iot->num_cols;\r\ncol_w = (column_width *)g_malloc(sizeof(column_width) * num_cols);\r\nfmts = (char **)g_malloc(sizeof(char *) * num_cols);\r\nduration = ((guint64)cfile.elapsed_time.secs * G_GUINT64_CONSTANT(1000000)) +\r\n(guint64)((cfile.elapsed_time.nsecs + 500) / 1000);\r\nstat_cols = (io_stat_item_t **) g_malloc(sizeof(io_stat_item_t *) * num_cols);\r\nfor (j=0; j<num_cols; j++)\r\nstat_cols[j] = &iot->items[j];\r\nif (iot->interval > duration || iot->interval==G_MAXINT32) {\r\ninterval = duration;\r\niot->interval = G_MAXINT32;\r\n} else {\r\ninterval = iot->interval;\r\n}\r\ndur_secs = (int)(duration/G_GUINT64_CONSTANT(1000000));\r\ndur_secs_orig = dur_secs;\r\ndur_nsecs = (int)(duration%G_GUINT64_CONSTANT(1000000));\r\ndur_nsecs_orig = dur_nsecs;\r\ndur_mag = magnitude((guint64)dur_secs, 5);\r\ng_snprintf(dur_mag_s, 3, "%u", dur_mag);\r\ninvl_mag = magnitude(interval/G_GUINT64_CONSTANT(1000000), 5);\r\nif (interval==duration) {\r\nif (dur_mag >= 2)\r\ninvl_prec = 1;\r\nelse if (dur_mag==1)\r\ninvl_prec = 3;\r\nelse\r\ninvl_prec = 6;\r\nborderlen = 30 + dur_mag + (invl_prec==0 ? 0 : invl_prec+1);\r\n} else {\r\ninvl_prec = iot->invl_prec;\r\nborderlen = 24 + invl_mag + (invl_prec==0 ? 0 : invl_prec+1);\r\n}\r\ndv=1000000;\r\nfor (i=0; i<invl_prec; i++)\r\ndv /= 10;\r\nif ((duration%dv) > 5*(dv/10)) {\r\nduration += 5*(dv/10);\r\nduration = (duration/dv) * dv;\r\ndur_secs = (int)(duration/G_GUINT64_CONSTANT(1000000));\r\ndur_nsecs = (int)(duration%G_GUINT64_CONSTANT(1000000));\r\ndur_mag = magnitude((guint64)dur_secs, 5);\r\n}\r\nif (iot->interval==G_MAXINT32)\r\ninterval = duration;\r\nif (invl_prec==0)\r\ninvl_col_w = (2*dur_mag) + 8;\r\nelse\r\ninvl_col_w = (2*dur_mag) + (2*invl_prec) + 10;\r\nswitch (timestamp_get_type()) {\r\ncase TS_ABSOLUTE_WITH_YMD:\r\ncase TS_ABSOLUTE_WITH_YDOY:\r\ncase TS_UTC_WITH_YMD:\r\ncase TS_UTC_WITH_YDOY:\r\ninvl_col_w = MAX(invl_col_w, 23);\r\nbreak;\r\ndefault:\r\ninvl_col_w = MAX(invl_col_w, 12);\r\nbreak;\r\n}\r\nborderlen = MAX(borderlen, invl_col_w);\r\ntabrow_w = invl_col_w;\r\nfor (j=0; j<num_cols; j++) {\r\ntype = iot->items[j].calc_type;\r\nif (type==CALC_TYPE_FRAMES_AND_BYTES) {\r\nnamelen = 5;\r\n} else {\r\nnamelen = (int) strlen(calc_type_table[type].func_name);\r\n}\r\nif(type==CALC_TYPE_FRAMES\r\n|| type==CALC_TYPE_FRAMES_AND_BYTES) {\r\nfr_mag = magnitude(iot->max_frame[j], 15);\r\nfr_mag = MAX(6, fr_mag);\r\ncol_w[j].fr = fr_mag;\r\ntabrow_w += col_w[j].fr + 3;\r\ng_snprintf(fr_mag_s, 3, "%u", fr_mag);\r\nif (type==CALC_TYPE_FRAMES) {\r\nfmt = g_strconcat(" %", fr_mag_s, "u |", NULL);\r\n} else {\r\nval_mag = magnitude(iot->max_vals[j], 15);\r\nval_mag = MAX(5, val_mag);\r\ncol_w[j].val = val_mag;\r\ntabrow_w += (col_w[j].val + 3);\r\ng_snprintf(val_mag_s, 3, "%u", val_mag);\r\nfmt = g_strconcat(" %", fr_mag_s, "u |", " %", val_mag_s, G_GINT64_MODIFIER, "u |", NULL);\r\n}\r\nif (fmt)\r\nfmts[j] = fmt;\r\ncontinue;\r\n}\r\nswitch(type) {\r\ncase CALC_TYPE_BYTES:\r\ncase CALC_TYPE_COUNT:\r\nval_mag = magnitude(iot->max_vals[j], 15);\r\nval_mag = MAX(5, val_mag);\r\ncol_w[j].val = val_mag;\r\ng_snprintf(val_mag_s, 3, "%u", val_mag);\r\nfmt = g_strconcat(" %", val_mag_s, G_GINT64_MODIFIER, "u |", NULL);\r\nbreak;\r\ndefault:\r\nftype = proto_registrar_get_ftype(stat_cols[j]->hf_index);\r\nswitch (ftype) {\r\ncase FT_FLOAT:\r\ncase FT_DOUBLE:\r\nval_mag = magnitude(iot->max_vals[j], 15);\r\ng_snprintf(val_mag_s, 3, "%u", val_mag);\r\nfmt = g_strconcat(" %", val_mag_s, ".6f |", NULL);\r\ncol_w[j].val = val_mag + 7;\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nif (type==CALC_TYPE_LOAD) {\r\niot->max_vals[j] /= interval;\r\n} else if (type != CALC_TYPE_AVG) {\r\niot->max_vals[j] = (iot->max_vals[j] + G_GUINT64_CONSTANT(500000000)) / NANOSECS_PER_SEC;\r\n}\r\nval_mag = magnitude(iot->max_vals[j], 15);\r\ng_snprintf(val_mag_s, 3, "%u", val_mag);\r\nfmt = g_strconcat(" %", val_mag_s, "u.%06u |", NULL);\r\ncol_w[j].val = val_mag + 7;\r\nbreak;\r\ndefault:\r\nval_mag = magnitude(iot->max_vals[j], 15);\r\nval_mag = MAX(namelen, val_mag);\r\ncol_w[j].val = val_mag;\r\ng_snprintf(val_mag_s, 3, "%u", val_mag);\r\nswitch (ftype) {\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\ncase FT_UINT64:\r\nfmt = g_strconcat(" %", val_mag_s, G_GINT64_MODIFIER, "u |", NULL);\r\nbreak;\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\ncase FT_INT64:\r\nfmt = g_strconcat(" %", val_mag_s, G_GINT64_MODIFIER, "d |", NULL);\r\nbreak;\r\n}\r\n}\r\n}\r\ntabrow_w += col_w[j].val + 3;\r\nif (fmt)\r\nfmts[j] = fmt;\r\n}\r\nborderlen = MAX(borderlen, tabrow_w);\r\nmaxfltr_w = 0;\r\nfor(j=0; j<num_cols; j++) {\r\nif (iot->filters[j]) {\r\nk = (int) (strlen(iot->filters[j]) + 11);\r\nmaxfltr_w = MAX(maxfltr_w, k);\r\n} else {\r\nmaxfltr_w = MAX(maxfltr_w, 26);\r\n}\r\n}\r\nif (maxfltr_w > borderlen && borderlen < 102)\r\nborderlen = MIN(maxfltr_w, 102);\r\nif (borderlen-tabrow_w==1)\r\nborderlen++;\r\nprintf("\n");\r\nfor (i=0; i<borderlen; i++)\r\nprintf("=");\r\nspaces = (char*) g_malloc(borderlen+1);\r\nfor (i=0; i<borderlen; i++)\r\nspaces[i] = ' ';\r\nspaces[borderlen] = '\0';\r\nspaces_s = &spaces[16];\r\nprintf("\n| IO Statistics%s|\n", spaces_s);\r\nspaces_s = &spaces[2];\r\nprintf("|%s|\n", spaces_s);\r\nif (invl_prec==0) {\r\ninvl_fmt = g_strconcat("%", dur_mag_s, "u", NULL);\r\nfull_fmt = g_strconcat("| Duration: ", invl_fmt, ".%6u secs%s|\n", NULL);\r\nspaces_s = &spaces[25 + dur_mag];\r\nprintf(full_fmt, dur_secs_orig, dur_nsecs_orig, spaces_s);\r\ng_free(full_fmt);\r\nfull_fmt = g_strconcat("| Interval: ", invl_fmt, " secs%s|\n", NULL);\r\nspaces_s = &spaces[18 + dur_mag];\r\nprintf(full_fmt, (guint32)(interval/G_GUINT64_CONSTANT(1000000)), spaces_s);\r\n} else {\r\ng_snprintf(invl_prec_s, 3, "%u", invl_prec);\r\ninvl_fmt = g_strconcat("%", dur_mag_s, "u.%0", invl_prec_s, "u", NULL);\r\nfull_fmt = g_strconcat("| Duration: ", invl_fmt, " secs%s|\n", NULL);\r\nspaces_s = &spaces[19 + dur_mag + invl_prec];\r\nprintf(full_fmt, dur_secs, dur_nsecs/(int)dv, spaces_s);\r\ng_free(full_fmt);\r\nfull_fmt = g_strconcat("| Interval: ", invl_fmt, " secs%s|\n", NULL);\r\nspaces_s = &spaces[19 + dur_mag + invl_prec];\r\nprintf(full_fmt, (guint32)(interval/G_GUINT64_CONSTANT(1000000)),\r\n(guint32)((interval%G_GUINT64_CONSTANT(1000000))/dv), spaces_s);\r\n}\r\ng_free(full_fmt);\r\nspaces_s = &spaces[2];\r\nprintf("|%s|\n", spaces_s);\r\nprintf("| Col");\r\nfor(j=0; j<num_cols; j++){\r\nprintf((j==0 ? "%2u: " : "| %2u: "), j+1);\r\nif (!iot->filters[j] || (iot->filters[j]==0)) {\r\nspaces_s = &spaces[16 + 10];\r\nprintf("Frames and bytes%s|\n", spaces_s);\r\n} else {\r\nfilter = iot->filters[j];\r\nlen_filt = (int) strlen(filter);\r\nif (len_filt+11 <= borderlen) {\r\nprintf("%s", filter);\r\nif (len_filt+11 <= borderlen) {\r\nspaces_s = &spaces[len_filt + 10];\r\nprintf("%s", spaces_s);\r\n}\r\nprintf("|\n");\r\n} else {\r\ngchar *sfilter1, *sfilter2;\r\nconst gchar *pos;\r\ngsize len;\r\nint next_start, max_w=borderlen-11;\r\ndo {\r\nif (len_filt > max_w) {\r\nsfilter1 = g_strndup(filter, (gsize) max_w);\r\npos = g_strrstr(sfilter1, " ");\r\nif (pos) {\r\nlen = (gsize)(pos-sfilter1);\r\nnext_start = (int) len+1;\r\n} else {\r\nlen = (gsize) strlen(sfilter1);\r\nnext_start = (int)len;\r\n}\r\nsfilter2 = g_strndup(sfilter1, len);\r\nprintf("%s%s|\n", sfilter2, &spaces[len+10]);\r\ng_free(sfilter1);\r\ng_free(sfilter2);\r\nprintf("| ");\r\nfilter = &filter[next_start];\r\nlen_filt = (int) strlen(filter);\r\n} else {\r\nprintf("%s%s|\n", filter, &spaces[((int)strlen(filter))+10]);\r\nbreak;\r\n}\r\n} while (1);\r\n}\r\n}\r\n}\r\nprintf("|-");\r\nfor(i=0;i<borderlen-3;i++){\r\nprintf("-");\r\n}\r\nprintf("|\n");\r\nspaces_s = &spaces[borderlen-(invl_col_w-2)];\r\nprintf("|%s|", spaces_s);\r\nfor(j=0; j<num_cols; j++) {\r\nitem = stat_cols[j];\r\nif(item->calc_type==CALC_TYPE_FRAMES_AND_BYTES)\r\nspaces_s = &spaces[borderlen - (col_w[j].fr + col_w[j].val)] - 3;\r\nelse if (item->calc_type==CALC_TYPE_FRAMES)\r\nspaces_s = &spaces[borderlen - col_w[j].fr];\r\nelse\r\nspaces_s = &spaces[borderlen - col_w[j].val];\r\nprintf("%-2u%s|", j+1, spaces_s);\r\n}\r\nif (tabrow_w < borderlen) {\r\nfiller_s = &spaces[tabrow_w+1];\r\nprintf("%s|", filler_s);\r\n}\r\nk = 11;\r\nswitch (timestamp_get_type()) {\r\ncase TS_ABSOLUTE:\r\nprintf("\n| Time ");\r\nbreak;\r\ncase TS_ABSOLUTE_WITH_YMD:\r\ncase TS_ABSOLUTE_WITH_YDOY:\r\ncase TS_UTC_WITH_YMD:\r\ncase TS_UTC_WITH_YDOY:\r\nprintf("\n| Date and time");\r\nk = 16;\r\nbreak;\r\ncase TS_RELATIVE:\r\ncase TS_NOT_SET:\r\nprintf("\n| Interval");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspaces_s = &spaces[borderlen-(invl_col_w-k)];\r\nprintf("%s|", spaces_s);\r\nfor(j=0; j<num_cols; j++) {\r\ntype = stat_cols[j]->calc_type;\r\nif(type==CALC_TYPE_FRAMES) {\r\nprintcenter (calc_type_table[type].func_name, col_w[j].fr, numpad);\r\n} else if (type==CALC_TYPE_FRAMES_AND_BYTES) {\r\nprintcenter ("Frames", col_w[j].fr, numpad);\r\nprintcenter ("Bytes", col_w[j].val, numpad);\r\n} else {\r\nprintcenter (calc_type_table[type].func_name, col_w[j].val, numpad);\r\n}\r\n}\r\nif (filler_s)\r\nprintf("%s|", filler_s);\r\nprintf("\n|-");\r\nfor(i=0; i<tabrow_w-3; i++)\r\nprintf("-");\r\nprintf("|");\r\nif (tabrow_w < borderlen)\r\nprintf("%s|", &spaces[tabrow_w+1]);\r\nprintf("\n");\r\nt=0;\r\nif (invl_prec==0 && dur_mag==1)\r\nfull_fmt = g_strconcat("| ", invl_fmt, " <> ", invl_fmt, " |", NULL);\r\nelse\r\nfull_fmt = g_strconcat("| ", invl_fmt, " <> ", invl_fmt, " |", NULL);\r\nif (interval == 0 || duration == 0) {\r\nnum_rows = 0;\r\n} else {\r\nnum_rows = (int)(duration/interval) + ((int)(duration%interval) > 0 ? 1 : 0);\r\n}\r\nitem_in_column = (io_stat_item_t **) g_malloc(sizeof(io_stat_item_t *) * num_cols);\r\nfor (j=0; j<num_cols; j++) {\r\nitem_in_column[j] = stat_cols[j];\r\n}\r\nfor (i=0; i<num_rows; i++) {\r\nif (i==num_rows-1)\r\nlast_row = TRUE;\r\nif (!last_row) {\r\ninvl_end = t + interval;\r\n} else {\r\ninvl_end = duration;\r\n}\r\nthe_time = (time_t)(iot->start_time + (t/G_GUINT64_CONSTANT(1000000)));\r\nswitch (timestamp_get_type()) {\r\ncase TS_ABSOLUTE:\r\ntm_time = localtime(&the_time);\r\nprintf("| %02d:%02d:%02d |",\r\ntm_time->tm_hour,\r\ntm_time->tm_min,\r\ntm_time->tm_sec);\r\nbreak;\r\ncase TS_ABSOLUTE_WITH_YMD:\r\ntm_time = localtime(&the_time);\r\nprintf("| %04d-%02d-%02d %02d:%02d:%02d |",\r\ntm_time->tm_year + 1900,\r\ntm_time->tm_mon + 1,\r\ntm_time->tm_mday,\r\ntm_time->tm_hour,\r\ntm_time->tm_min,\r\ntm_time->tm_sec);\r\nbreak;\r\ncase TS_ABSOLUTE_WITH_YDOY:\r\ntm_time = localtime(&the_time);\r\nprintf("| %04d/%03d %02d:%02d:%02d |",\r\ntm_time->tm_year + 1900,\r\ntm_time->tm_yday + 1,\r\ntm_time->tm_hour,\r\ntm_time->tm_min,\r\ntm_time->tm_sec);\r\nbreak;\r\ncase TS_UTC:\r\ntm_time = gmtime(&the_time);\r\nprintf("| %02d:%02d:%02d |",\r\ntm_time->tm_hour,\r\ntm_time->tm_min,\r\ntm_time->tm_sec);\r\nbreak;\r\ncase TS_UTC_WITH_YMD:\r\ntm_time = gmtime(&the_time);\r\nprintf("| %04d-%02d-%02d %02d:%02d:%02d |",\r\ntm_time->tm_year + 1900,\r\ntm_time->tm_mon + 1,\r\ntm_time->tm_mday,\r\ntm_time->tm_hour,\r\ntm_time->tm_min,\r\ntm_time->tm_sec);\r\nbreak;\r\ncase TS_UTC_WITH_YDOY:\r\ntm_time = gmtime(&the_time);\r\nprintf("| %04d/%03d %02d:%02d:%02d |",\r\ntm_time->tm_year + 1900,\r\ntm_time->tm_yday + 1,\r\ntm_time->tm_hour,\r\ntm_time->tm_min,\r\ntm_time->tm_sec);\r\nbreak;\r\ncase TS_RELATIVE:\r\ncase TS_NOT_SET:\r\nif (invl_prec==0) {\r\nif(last_row) {\r\nint maxw;\r\nmaxw = dur_mag >= 3 ? dur_mag+1 : 3;\r\ng_free(full_fmt);\r\ng_snprintf(dur_mag_s, 3, "%u", maxw);\r\nfull_fmt = g_strconcat( dur_mag==1 ? "| " : "| ",\r\ninvl_fmt, " <> ", "%-",\r\ndur_mag_s, "s|", NULL);\r\nprintf(full_fmt, (guint32)(t/G_GUINT64_CONSTANT(1000000)), "Dur");\r\n} else {\r\nprintf(full_fmt, (guint32)(t/G_GUINT64_CONSTANT(1000000)),\r\n(guint32)(invl_end/G_GUINT64_CONSTANT(1000000)));\r\n}\r\n} else {\r\nprintf(full_fmt, (guint32)(t/G_GUINT64_CONSTANT(1000000)),\r\n(guint32)(t%G_GUINT64_CONSTANT(1000000) / dv),\r\n(guint32)(invl_end/G_GUINT64_CONSTANT(1000000)),\r\n(guint32)(invl_end%G_GUINT64_CONSTANT(1000000) / dv));\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (j=0; j<num_cols; j++) {\r\nfmt = fmts[j];\r\nitem = item_in_column[j];\r\nif (item) {\r\nswitch(item->calc_type) {\r\ncase CALC_TYPE_FRAMES:\r\nprintf(fmt, item->frames);\r\nbreak;\r\ncase CALC_TYPE_BYTES:\r\ncase CALC_TYPE_COUNT:\r\nprintf(fmt, item->counter);\r\nbreak;\r\ncase CALC_TYPE_FRAMES_AND_BYTES:\r\nprintf(fmt, item->frames, item->counter);\r\nbreak;\r\ncase CALC_TYPE_SUM:\r\ncase CALC_TYPE_MIN:\r\ncase CALC_TYPE_MAX:\r\nftype = proto_registrar_get_ftype(stat_cols[j]->hf_index);\r\nswitch(ftype){\r\ncase FT_FLOAT:\r\nprintf(fmt, item->float_counter);\r\nbreak;\r\ncase FT_DOUBLE:\r\nprintf(fmt, item->double_counter);\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nitem->counter = (item->counter + G_GUINT64_CONSTANT(500)) / G_GUINT64_CONSTANT(1000);\r\nprintf(fmt,\r\n(int)(item->counter/G_GUINT64_CONSTANT(1000000)),\r\n(int)(item->counter%G_GUINT64_CONSTANT(1000000)));\r\nbreak;\r\ndefault:\r\nprintf(fmt, item->counter);\r\nbreak;\r\n}\r\nbreak;\r\ncase CALC_TYPE_AVG:\r\nnum = item->num;\r\nif(num==0)\r\nnum=1;\r\nftype = proto_registrar_get_ftype(stat_cols[j]->hf_index);\r\nswitch(ftype){\r\ncase FT_FLOAT:\r\nprintf(fmt, item->float_counter/num);\r\nbreak;\r\ncase FT_DOUBLE:\r\nprintf(fmt, item->double_counter/num);\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nitem->counter = ((item->counter / (guint64)num) + G_GUINT64_CONSTANT(500)) / G_GUINT64_CONSTANT(1000);\r\nprintf(fmt,\r\n(int)(item->counter/G_GUINT64_CONSTANT(1000000)),\r\n(int)(item->counter%G_GUINT64_CONSTANT(1000000)));\r\nbreak;\r\ndefault:\r\nprintf(fmt, item->counter / (guint64)num);\r\nbreak;\r\n}\r\nbreak;\r\ncase CALC_TYPE_LOAD:\r\nftype = proto_registrar_get_ftype(stat_cols[j]->hf_index);\r\nswitch(ftype){\r\ncase FT_RELATIVE_TIME:\r\nif (!last_row) {\r\nprintf(fmt,\r\n(int) (item->counter/interval),\r\n(int)((item->counter%interval)*G_GUINT64_CONSTANT(1000000) / interval));\r\n} else {\r\nprintf(fmt,\r\n(int) (item->counter/(invl_end-t)),\r\n(int)((item->counter%(invl_end-t))*G_GUINT64_CONSTANT(1000000) / (invl_end-t)));\r\n}\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (last_row) {\r\nif (fmt)\r\ng_free(fmt);\r\n} else {\r\nitem_in_column[j] = item_in_column[j]->next;\r\n}\r\n} else {\r\nprintf(fmt, (guint64)0, (guint64)0);\r\n}\r\n}\r\nif (filler_s)\r\nprintf("%s|", filler_s);\r\nprintf("\n");\r\nt += interval;\r\n}\r\nfor(i=0;i<borderlen;i++){\r\nprintf("=");\r\n}\r\nprintf("\n");\r\ng_free(iot->items);\r\ng_free(iot->max_vals);\r\ng_free(iot->max_frame);\r\ng_free(iot);\r\ng_free(col_w);\r\ng_free(invl_fmt);\r\ng_free(full_fmt);\r\ng_free(fmts);\r\ng_free(spaces);\r\ng_free(stat_cols);\r\ng_free(item_in_column);\r\n}\r\nstatic void\r\nregister_io_tap(io_stat_t *io, int i, const char *filter)\r\n{\r\nGString *error_string;\r\nconst char *flt;\r\nint j;\r\nsize_t namelen;\r\nconst char *p, *parenp;\r\nchar *field;\r\nheader_field_info *hfi;\r\nio->items[i].prev=&io->items[i];\r\nio->items[i].next=NULL;\r\nio->items[i].parent=io;\r\nio->items[i].time=0;\r\nio->items[i].calc_type=CALC_TYPE_FRAMES_AND_BYTES;\r\nio->items[i].frames=0;\r\nio->items[i].counter=0;\r\nio->items[i].num=0;\r\nio->filters[i]=filter;\r\nflt=filter;\r\nfield=NULL;\r\nhfi=NULL;\r\nfor(j=0; calc_type_table[j].func_name; j++){\r\nnamelen=strlen(calc_type_table[j].func_name);\r\nif(filter && strncmp(filter, calc_type_table[j].func_name, namelen) == 0) {\r\nio->items[i].calc_type=calc_type_table[j].calc_type;\r\nio->items[i].colnum = i;\r\nif(*(filter+namelen)=='(') {\r\np=filter+namelen+1;\r\nparenp=strchr(p, ')');\r\nif(!parenp){\r\nfprintf(stderr,\r\n"\ntshark: Closing parenthesis missing from calculated expression.\n");\r\nexit(10);\r\n}\r\nif(io->items[i].calc_type==CALC_TYPE_FRAMES || io->items[i].calc_type==CALC_TYPE_BYTES){\r\nif(parenp!=p) {\r\nfprintf(stderr,\r\n"\ntshark: %s does not require or allow a field name within the parens.\n",\r\ncalc_type_table[j].func_name);\r\nexit(10);\r\n}\r\n} else {\r\nif(parenp==p) {\r\nfprintf(stderr, "\ntshark: You didn't specify a field name for %s(*).\n",\r\ncalc_type_table[j].func_name);\r\nexit(10);\r\n}\r\n}\r\nfield = (char *) g_malloc(parenp-p+1);\r\nmemcpy(field, p, parenp-p);\r\nfield[parenp-p] = '\0';\r\nflt=parenp + 1;\r\nif (io->items[i].calc_type==CALC_TYPE_FRAMES || io->items[i].calc_type==CALC_TYPE_BYTES)\r\nbreak;\r\nhfi=proto_registrar_get_byname(field);\r\nif(!hfi){\r\nfprintf(stderr, "\ntshark: There is no field named '%s'.\n",\r\nfield);\r\ng_free(field);\r\nexit(10);\r\n}\r\nio->items[i].hf_index=hfi->id;\r\nbreak;\r\n}\r\n} else {\r\nif (io->items[i].calc_type==CALC_TYPE_FRAMES || io->items[i].calc_type==CALC_TYPE_BYTES)\r\nflt="";\r\nio->items[i].colnum = i;\r\n}\r\n}\r\nif(hfi && !(io->items[i].calc_type==CALC_TYPE_BYTES ||\r\nio->items[i].calc_type==CALC_TYPE_FRAMES ||\r\nio->items[i].calc_type==CALC_TYPE_FRAMES_AND_BYTES)){\r\nswitch(hfi->type){\r\ncase FT_UINT8:\r\ncase FT_UINT16:\r\ncase FT_UINT24:\r\ncase FT_UINT32:\r\ncase FT_UINT64:\r\ncase FT_INT8:\r\ncase FT_INT16:\r\ncase FT_INT24:\r\ncase FT_INT32:\r\ncase FT_INT64:\r\nbreak;\r\ncase FT_FLOAT:\r\ncase FT_DOUBLE:\r\nswitch(io->items[i].calc_type){\r\ncase CALC_TYPE_SUM:\r\ncase CALC_TYPE_COUNT:\r\ncase CALC_TYPE_MAX:\r\ncase CALC_TYPE_MIN:\r\ncase CALC_TYPE_AVG:\r\nbreak;\r\ndefault:\r\nfprintf(stderr,\r\n"\ntshark: %s is a float field, so %s(*) calculations are not supported on it.",\r\nfield,\r\ncalc_type_table[j].func_name);\r\nexit(10);\r\n}\r\nbreak;\r\ncase FT_RELATIVE_TIME:\r\nswitch(io->items[i].calc_type){\r\ncase CALC_TYPE_SUM:\r\ncase CALC_TYPE_COUNT:\r\ncase CALC_TYPE_MAX:\r\ncase CALC_TYPE_MIN:\r\ncase CALC_TYPE_AVG:\r\ncase CALC_TYPE_LOAD:\r\nbreak;\r\ndefault:\r\nfprintf(stderr,\r\n"\ntshark: %s is a relative-time field, so %s(*) calculations are not supported on it.",\r\nfield,\r\ncalc_type_table[j].func_name);\r\nexit(10);\r\n}\r\nbreak;\r\ndefault:\r\nif(io->items[i].calc_type!=CALC_TYPE_COUNT){\r\nfprintf(stderr,\r\n"\ntshark: %s doesn't have integral values, so %s(*) "\r\n"calculations are not supported on it.\n",\r\nfield,\r\ncalc_type_table[j].func_name);\r\nexit(10);\r\n}\r\nbreak;\r\n}\r\ng_free(field);\r\n}\r\nerror_string=register_tap_listener("frame", &io->items[i], flt, TL_REQUIRES_PROTO_TREE, NULL,\r\niostat_packet, i?NULL:iostat_draw);\r\nif(error_string){\r\ng_free(io->items);\r\ng_free(io);\r\nfprintf(stderr, "\ntshark: Couldn't register io,stat tap: %s\n",\r\nerror_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\n}\r\nstatic void\r\niostat_init(const char *opt_arg, void* userdata _U_)\r\n{\r\ngdouble interval_float;\r\nguint32 idx=0;\r\nint i;\r\nio_stat_t *io;\r\nconst gchar *filters, *str, *pos;\r\nif ((*(opt_arg+(strlen(opt_arg)-1)) == ',') ||\r\n(sscanf(opt_arg, "io,stat,%lf%n", &interval_float, (int *)&idx) != 1) ||\r\n(idx < 8)) {\r\nfprintf(stderr, "\ntshark: invalid \"-z io,stat,<interval>[,<filter>][,<filter>]...\" argument\n");\r\nexit(1);\r\n}\r\nfilters=opt_arg+idx;\r\nif (*filters) {\r\nif (*filters != ',') {\r\n--filters;\r\nif (*filters != ',') {\r\nfprintf(stderr, "\ntshark: invalid \"-z io,stat,<interval>[,<filter>][,<filter>]...\" argument\n");\r\nexit(1);\r\n}\r\n}\r\n} else\r\nfilters=NULL;\r\nswitch (timestamp_get_type()) {\r\ncase TS_DELTA:\r\ncase TS_DELTA_DIS:\r\ncase TS_EPOCH:\r\nfprintf(stderr, "\ntshark: invalid -t operand. io,stat only supports -t <r|a|ad|adoy|u|ud|udoy>\n");\r\nexit(1);\r\ndefault:\r\nbreak;\r\n}\r\nio = (io_stat_t *) g_malloc(sizeof(io_stat_t));\r\nif (interval_float==0) {\r\nio->interval = G_MAXINT32;\r\nio->invl_prec = 0;\r\n} else {\r\nio->interval = (guint64)(interval_float * 1000000.0 + 0.5);\r\nio->invl_prec = 6;\r\nfor (i=10; i<10000000; i*=10) {\r\nif (io->interval%i > 0)\r\nbreak;\r\nio->invl_prec--;\r\n}\r\nif (io->invl_prec==0) {\r\nconst gchar *invl_start = opt_arg+8;\r\ngchar *intv_end;\r\nint invl_len;\r\nintv_end = g_strstr_len(invl_start, -1, ",");\r\ninvl_len = (int)(intv_end - invl_start);\r\ninvl_start = g_strstr_len(invl_start, invl_len, ".");\r\nif (invl_start != NULL) {\r\ninvl_len = (int)(intv_end - invl_start - 1);\r\nif (invl_len)\r\nio->invl_prec = MIN(invl_len, 6);\r\n}\r\n}\r\n}\r\nif (io->interval < 1){\r\nfprintf(stderr,\r\n"\ntshark: \"-z\" interval must be >=0.000001 seconds or \"0\" for the entire capture duration.\n");\r\nexit(10);\r\n}\r\nio->num_cols = 1;\r\nio->start_time=0;\r\nif (filters && (*filters != '\0')) {\r\nfilters++;\r\nstr = filters;\r\nwhile((str = strchr(str, ','))) {\r\nio->num_cols++;\r\nstr++;\r\n}\r\n}\r\nio->items = (io_stat_item_t *) g_malloc(sizeof(io_stat_item_t) * io->num_cols);\r\nio->filters = (const char **)g_malloc(sizeof(char *) * io->num_cols);\r\nio->max_vals = (guint64 *) g_malloc(sizeof(guint64) * io->num_cols);\r\nio->max_frame = (guint32 *) g_malloc(sizeof(guint32) * io->num_cols);\r\nfor (i=0; i<io->num_cols; i++) {\r\nio->max_vals[i] = 0;\r\nio->max_frame[i] = 0;\r\n}\r\nif((!filters) || (filters[0]==0)) {\r\nregister_io_tap(io, 0, NULL);\r\n} else {\r\ngchar *filter;\r\ni = 0;\r\nstr = filters;\r\ndo {\r\npos = (gchar*) strchr(str, ',');\r\nif(pos==str){\r\nregister_io_tap(io, i, NULL);\r\n} else if (pos==NULL) {\r\nstr = (const char*) g_strstrip((gchar*)str);\r\nfilter = g_strdup(str);\r\nif (*filter)\r\nregister_io_tap(io, i, filter);\r\nelse\r\nregister_io_tap(io, i, NULL);\r\n} else {\r\nfilter = (gchar *)g_malloc((pos-str)+1);\r\ng_strlcpy( filter, str, (gsize) ((pos-str)+1));\r\nfilter = g_strstrip(filter);\r\nregister_io_tap(io, i, (char *) filter);\r\n}\r\nstr = pos+1;\r\ni++;\r\n} while(pos);\r\n}\r\n}\r\nvoid\r\nregister_tap_listener_iostat(void)\r\n{\r\nregister_stat_cmd_arg("io,stat,", iostat_init, NULL);\r\n}
