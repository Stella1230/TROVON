static const char *\r\nbtle_rf_channel_type(guint8 rf_channel)\r\n{\r\nif (rf_channel <= 39) {\r\nswitch(rf_channel) {\r\ncase 0:\r\ncase 12:\r\ncase 39:\r\nreturn "Advertising channel";\r\ndefault:\r\nreturn "Data channel";\r\n}\r\n}\r\nreturn "Illegal channel";\r\n}\r\nstatic guint8\r\nbtle_rf_channel_index(guint8 rf_channel)\r\n{\r\nif (rf_channel <= 39) {\r\nif (rf_channel == 39) {\r\nreturn 39;\r\n}\r\nelse if (rf_channel >= 13) {\r\nreturn rf_channel - 2;\r\n}\r\nelse if (rf_channel == 12) {\r\nreturn 38;\r\n}\r\nelse if (rf_channel >= 1) {\r\nreturn rf_channel - 1;\r\n}\r\nelse {\r\nreturn 37;\r\n}\r\n}\r\nreturn (guint8) -1;\r\n}\r\nstatic gint\r\ndissect_btle_rf(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "BTLE RF");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nif (tree && (tvb_captured_length(tvb) >= BTLE_RF_OCTETS)) {\r\nproto_item *ti = NULL;\r\nproto_tree *btle_rf_tree = NULL;\r\nproto_tree *btle_rf_flags_tree = NULL;\r\ntvbuff_t *btle_tvb;\r\nbtle_context_t context;\r\nguint8 rf_channel = tvb_get_guint8(tvb, 0);\r\nguint8 aa_offenses = tvb_get_guint8(tvb, 3);\r\nguint16 flags = tvb_get_letohs(tvb, 8);\r\ncontext.aa_category = E_AA_NO_COMMENT;\r\ncontext.connection_info_valid = 0;\r\ncontext.crc_checked_at_capture = !!(flags & LE_CRC_CHECKED);\r\ncontext.crc_valid_at_capture = !!(flags & LE_CRC_VALID);\r\ncontext.mic_checked_at_capture = !!(flags & LE_MIC_CHECKED);\r\ncontext.mic_valid_at_capture = !!(flags & LE_MIC_VALID);\r\nti = proto_tree_add_item(tree, proto_btle_rf, tvb, 0, tvb_captured_length(tvb), ENC_NA);\r\nbtle_rf_tree = proto_item_add_subtree(ti, ett_btle_rf);\r\nti = proto_tree_add_item(btle_rf_tree, hf_btle_rf_channel, tvb, 0, 1, ENC_LITTLE_ENDIAN);\r\nproto_item_append_text(ti, ", %d MHz, %s %d", 2402+2*rf_channel,\r\nbtle_rf_channel_type(rf_channel),\r\nbtle_rf_channel_index(rf_channel));\r\nif (flags & LE_CHANNEL_ALIASED) {\r\nproto_item_append_text(ti, " [aliased]");\r\n}\r\nif (flags & LE_SIGPOWER_VALID) {\r\nproto_tree_add_item(btle_rf_tree, hf_btle_rf_signal_dbm, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(btle_rf_tree, hf_btle_rf_signed_byte_unused, tvb, 1, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (flags & LE_NOISEPOWER_VALID) {\r\nproto_tree_add_item(btle_rf_tree, hf_btle_rf_noise_dbm, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(btle_rf_tree, hf_btle_rf_signed_byte_unused, tvb, 2, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nif (flags & LE_REF_AA_VALID) {\r\nproto_tree_add_item(btle_rf_tree, hf_btle_rf_reference_access_address, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nelse {\r\nproto_tree_add_item(btle_rf_tree, hf_btle_rf_word_unused, tvb, 4, 4, ENC_LITTLE_ENDIAN);\r\n}\r\nif (flags & LE_AA_OFFENSES_VALID) {\r\nproto_tree_add_item(btle_rf_tree, hf_btle_rf_access_address_offenses, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\nif (aa_offenses > 0) {\r\nif (flags & LE_REF_AA_VALID) {\r\ncontext.aa_category = E_AA_BIT_ERRORS;\r\n}\r\nelse {\r\ncontext.aa_category = E_AA_ILLEGAL;\r\n}\r\n}\r\nelse if (flags & LE_REF_AA_VALID) {\r\ncontext.aa_category = E_AA_MATCHED;\r\n}\r\n}\r\nelse {\r\nproto_tree_add_item(btle_rf_tree, hf_btle_rf_unsigned_byte_unused, tvb, 3, 1, ENC_LITTLE_ENDIAN);\r\n}\r\nti = proto_tree_add_item(btle_rf_tree, hf_btle_rf_flags, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nbtle_rf_flags_tree = proto_item_add_subtree(ti, ett_btle_rf_flags);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_dewhitened_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_sigpower_valid_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_noisepower_valid_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_packet_decrypted_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_ref_aa_valid_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_aa_offenses_valid_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_channel_aliased_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_flags_rfu_1, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_crc_checked_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_crc_valid_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_mic_checked_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_mic_valid_flag, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nproto_tree_add_item(btle_rf_flags_tree, hf_btle_rf_flags_rfu_2, tvb, 8, 2, ENC_LITTLE_ENDIAN);\r\nbtle_tvb = tvb_new_subset_remaining(tvb, BTLE_RF_OCTETS);\r\nreturn BTLE_RF_OCTETS+call_dissector_with_data(btle_handle, btle_tvb, pinfo, tree, &context);\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nproto_register_btle_rf(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_btle_rf_signed_byte_unused,\r\n{ "Unused signed byte", "btle_rf.signed_byte_unused",\r\nFT_INT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_unsigned_byte_unused,\r\n{ "Unused unsigned byte", "btle_rf.unsigned_byte_unused",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_word_unused,\r\n{ "Unused word", "btle_rf.word_unused",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_channel,\r\n{ "RF Channel", "btle_rf.channel",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_signal_dbm,\r\n{ "Signal dBm", "btle_rf.signal_dbm",\r\nFT_INT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_noise_dbm,\r\n{ "Noise dBm", "btle_rf.noise_dbm",\r\nFT_INT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_access_address_offenses,\r\n{ "Access Address Offenses", "btle_rf.access_address_offenses",\r\nFT_UINT8, BASE_DEC,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_reference_access_address,\r\n{ "Reference Access Address", "btle_rf.reference_access_address",\r\nFT_UINT32, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_flags,\r\n{ "Flags", "btle_rf.flags",\r\nFT_UINT16, BASE_HEX,\r\nNULL, 0x0,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_dewhitened_flag,\r\n{ "Dewhitened", "btle_rf.flags.dewhitened",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_DEWHITENED,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_sigpower_valid_flag,\r\n{ "Signal Power Valid", "btle_rf.flags.signal_dbm_valid",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_SIGPOWER_VALID,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_noisepower_valid_flag,\r\n{ "Noise Power Valid", "btle_rf.flags.noise_dbm_valid",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_NOISEPOWER_VALID,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_packet_decrypted_flag,\r\n{ "Decrypted", "btle_rf.flags.decrypted",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_PACKET_DECRYPTED,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_ref_aa_valid_flag,\r\n{ "Reference Access Address Valid",\r\n"btle_rf.flags.reference_access_address_valid",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_REF_AA_VALID,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_aa_offenses_valid_flag,\r\n{ "Access Address Offenses Valid",\r\n"btle_rf.flags.access_address_offenses_valid",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_AA_OFFENSES_VALID,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_channel_aliased_flag,\r\n{ "Channel Aliased", "btle_rf.flags.channel_aliased",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_CHANNEL_ALIASED,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_flags_rfu_1,\r\n{ "RFU", "btle_rf.flags.rfu.1",\r\nFT_UINT16, BASE_DEC, NULL, 0x380,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_crc_checked_flag,\r\n{ "CRC Checked", "btle_rf.flags.crc_checked",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_CRC_CHECKED,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_crc_valid_flag,\r\n{ "CRC Valid", "btle_rf.flags.crc_valid",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_CRC_VALID,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_mic_checked_flag,\r\n{ "MIC Checked", "btle_rf.flags.mic_checked",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_MIC_CHECKED,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_mic_valid_flag,\r\n{ "MIC Valid", "btle_rf.flags.mic_valid",\r\nFT_BOOLEAN, 16,\r\nNULL, LE_MIC_VALID,\r\nNULL, HFILL }\r\n},\r\n{ &hf_btle_rf_flags_rfu_2,\r\n{ "RFU", "btle_rf.flags.rfu.2",\r\nFT_UINT16, BASE_DEC, NULL, 0xc000,\r\nNULL, HFILL }\r\n},\r\n};\r\nstatic gint *ett[] = {\r\n&ett_btle_rf,\r\n&ett_btle_rf_flags,\r\n};\r\nproto_btle_rf = proto_register_protocol("Bluetooth Low Energy RF Info",\r\n"BTLE RF", "btle_rf");\r\nproto_register_field_array(proto_btle_rf, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nbtle_rf_handle = new_register_dissector("btle_rf", dissect_btle_rf, proto_btle_rf);\r\n}\r\nvoid\r\nproto_reg_handoff_btle_rf(void)\r\n{\r\ndissector_add_uint("wtap_encap", WTAP_ENCAP_BLUETOOTH_LE_LL_WITH_PHDR, btle_rf_handle);\r\nbtle_handle = find_dissector("btle");\r\n}
