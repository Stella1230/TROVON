static struct action *Action_new(void){\r\nstatic struct action *freelist = NULL;\r\nstruct action *newaction;\r\nif( freelist==NULL ){\r\nint i;\r\nint amt = 100;\r\nfreelist = (struct action *)calloc(amt, sizeof(struct action));\r\nif( freelist==NULL ){\r\nfprintf(stderr,"Unable to allocate memory for a new parser action.");\r\nexit(1);\r\n}\r\nfor(i=0; i<amt-1; i++) freelist[i].next = &freelist[i+1];\r\nfreelist[amt-1].next = 0;\r\n}\r\nnewaction = freelist;\r\nfreelist = freelist->next;\r\nreturn newaction;\r\n}\r\nstatic int actioncmp(\r\nstruct action *ap1,\r\nstruct action *ap2\r\n){\r\nint rc;\r\nrc = ap1->sp->index - ap2->sp->index;\r\nif( rc==0 ){\r\nrc = (int)ap1->type - (int)ap2->type;\r\n}\r\nif( rc==0 && ap1->type==REDUCE ){\r\nrc = ap1->x.rp->index - ap2->x.rp->index;\r\n}\r\nif( rc==0 ){\r\nrc = (int) (ap2 - ap1);\r\n}\r\nreturn rc;\r\n}\r\nstatic struct action *Action_sort(\r\nstruct action *ap\r\n){\r\nap = (struct action *)msort((char *)ap,(char **)&ap->next,\r\n(int(*)(const char*,const char*))actioncmp);\r\nreturn ap;\r\n}\r\nstatic void Action_add(struct action **app, enum e_action type, struct symbol *sp, char *arg)\r\n{\r\nstruct action *newaction;\r\nnewaction = Action_new();\r\nnewaction->next = *app;\r\n*app = newaction;\r\nnewaction->type = type;\r\nnewaction->sp = sp;\r\nif( type==SHIFT ){\r\nnewaction->x.stp = (struct state *)arg;\r\n}else{\r\nnewaction->x.rp = (struct rule *)arg;\r\n}\r\n}\r\nstatic acttab *acttab_alloc(void){\r\nacttab *p = (acttab *) malloc( sizeof(*p) );\r\nif( p==0 ){\r\nfprintf(stderr,"Unable to allocate memory for a new acttab.");\r\nexit(1);\r\n}\r\nmemset(p, 0, sizeof(*p));\r\nreturn p;\r\n}\r\nstatic void acttab_action(acttab *p, int lookahead, int action){\r\nif( p->nLookahead>=p->nLookaheadAlloc ){\r\np->nLookaheadAlloc += 25;\r\np->aLookahead = (struct lookahead_action *) realloc( p->aLookahead,\r\nsizeof(p->aLookahead[0])*p->nLookaheadAlloc );\r\nif( p->aLookahead==0 ){\r\nfprintf(stderr,"malloc failed\n");\r\nexit(1);\r\n}\r\n}\r\nif( p->nLookahead==0 ){\r\np->mxLookahead = lookahead;\r\np->mnLookahead = lookahead;\r\np->mnAction = action;\r\n}else{\r\nif( p->mxLookahead<lookahead ) p->mxLookahead = lookahead;\r\nif( p->mnLookahead>lookahead ){\r\np->mnLookahead = lookahead;\r\np->mnAction = action;\r\n}\r\n}\r\np->aLookahead[p->nLookahead].lookahead = lookahead;\r\np->aLookahead[p->nLookahead].action = action;\r\np->nLookahead++;\r\n}\r\nstatic int acttab_insert(acttab *p){\r\nint i, j, k, n;\r\nassert( p->nLookahead>0 );\r\nn = p->mxLookahead + 1;\r\nif( p->nAction + n >= p->nActionAlloc ){\r\nint oldAlloc = p->nActionAlloc;\r\np->nActionAlloc = p->nAction + n + p->nActionAlloc + 20;\r\np->aAction = (struct lookahead_action *) realloc( p->aAction,\r\nsizeof(p->aAction[0])*p->nActionAlloc);\r\nif( p->aAction==0 ){\r\nfprintf(stderr,"malloc failed\n");\r\nexit(1);\r\n}\r\nfor(i=oldAlloc; i<p->nActionAlloc; i++){\r\np->aAction[i].lookahead = -1;\r\np->aAction[i].action = -1;\r\n}\r\n}\r\nfor(i=0; i<p->nAction+p->mnLookahead; i++){\r\nif( p->aAction[i].lookahead<0 ){\r\nfor(j=0; j<p->nLookahead; j++){\r\nk = p->aLookahead[j].lookahead - p->mnLookahead + i;\r\nif( k<0 ) break;\r\nif( p->aAction[k].lookahead>=0 ) break;\r\n}\r\nif( j<p->nLookahead ) continue;\r\nfor(j=0; j<p->nAction; j++){\r\nif( p->aAction[j].lookahead==j+p->mnLookahead-i ) break;\r\n}\r\nif( j==p->nAction ){\r\nbreak;\r\n}\r\n}else if( p->aAction[i].lookahead==p->mnLookahead ){\r\nif( p->aAction[i].action!=p->mnAction ) continue;\r\nfor(j=0; j<p->nLookahead; j++){\r\nk = p->aLookahead[j].lookahead - p->mnLookahead + i;\r\nif( k<0 || k>=p->nAction ) break;\r\nif( p->aLookahead[j].lookahead!=p->aAction[k].lookahead ) break;\r\nif( p->aLookahead[j].action!=p->aAction[k].action ) break;\r\n}\r\nif( j<p->nLookahead ) continue;\r\nn = 0;\r\nfor(j=0; j<p->nAction; j++){\r\nif( p->aAction[j].lookahead<0 ) continue;\r\nif( p->aAction[j].lookahead==j+p->mnLookahead-i ) n++;\r\n}\r\nif( n==p->nLookahead ){\r\nbreak;\r\n}\r\n}\r\n}\r\nfor(j=0; j<p->nLookahead; j++){\r\nk = p->aLookahead[j].lookahead - p->mnLookahead + i;\r\np->aAction[k] = p->aLookahead[j];\r\nif( k>=p->nAction ) p->nAction = k+1;\r\n}\r\np->nLookahead = 0;\r\nreturn i - p->mnLookahead;\r\n}\r\nvoid FindRulePrecedences(struct lemon *xp)\r\n{\r\nstruct rule *rp;\r\nfor(rp=xp->rule; rp; rp=rp->next){\r\nif( rp->precsym==0 ){\r\nint i, j;\r\nfor(i=0; i<rp->nrhs && rp->precsym==0; i++){\r\nstruct symbol *sp = rp->rhs[i];\r\nif( sp->type==MULTITERMINAL ){\r\nfor(j=0; j<sp->nsubsym; j++){\r\nif( sp->subsym[j]->prec>=0 ){\r\nrp->precsym = sp->subsym[j];\r\nbreak;\r\n}\r\n}\r\n}else if( sp->prec>=0 ){\r\nrp->precsym = rp->rhs[i];\r\n}\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid FindFirstSets(struct lemon *lemp)\r\n{\r\nint i, j;\r\nstruct rule *rp;\r\nint progress;\r\nfor(i=0; i<lemp->nsymbol; i++){\r\nlemp->symbols[i]->lambda = LEMON_FALSE;\r\n}\r\nfor(i=lemp->nterminal; i<lemp->nsymbol; i++){\r\nlemp->symbols[i]->firstset = SetNew();\r\n}\r\ndo{\r\nprogress = 0;\r\nfor(rp=lemp->rule; rp; rp=rp->next){\r\nif( rp->lhs->lambda ) continue;\r\nfor(i=0; i<rp->nrhs; i++){\r\nstruct symbol *sp = rp->rhs[i];\r\nif( sp->type!=TERMINAL || sp->lambda==LEMON_FALSE ) break;\r\n}\r\nif( i==rp->nrhs ){\r\nrp->lhs->lambda = LEMON_TRUE;\r\nprogress = 1;\r\n}\r\n}\r\n}while( progress );\r\ndo{\r\nstruct symbol *s1, *s2;\r\nprogress = 0;\r\nfor(rp=lemp->rule; rp; rp=rp->next){\r\ns1 = rp->lhs;\r\nfor(i=0; i<rp->nrhs; i++){\r\ns2 = rp->rhs[i];\r\nif( s2->type==TERMINAL ){\r\nprogress += SetAdd(s1->firstset,s2->index);\r\nbreak;\r\n}else if( s2->type==MULTITERMINAL ){\r\nfor(j=0; j<s2->nsubsym; j++){\r\nprogress += SetAdd(s1->firstset,s2->subsym[j]->index);\r\n}\r\nbreak;\r\n}else if( s1==s2 ){\r\nif( s1->lambda==LEMON_FALSE ) break;\r\n}else{\r\nprogress += SetUnion(s1->firstset,s2->firstset);\r\nif( s2->lambda==LEMON_FALSE ) break;\r\n}\r\n}\r\n}\r\n}while( progress );\r\nreturn;\r\n}\r\nvoid FindStates(struct lemon *lemp)\r\n{\r\nstruct symbol *sp;\r\nstruct rule *rp;\r\nConfiglist_init();\r\nif( lemp->start ){\r\nsp = Symbol_find(lemp->start);\r\nif( sp==0 ){\r\nErrorMsg(lemp->filename,0,\r\n"The specified start symbol \"%s\" is not \\r\nin a nonterminal of the grammar. \"%s\" will be used as the start \\r\nsymbol instead.",lemp->start,lemp->rule->lhs->name);\r\nlemp->errorcnt++;\r\nsp = lemp->rule->lhs;\r\n}\r\n}else{\r\nsp = lemp->rule->lhs;\r\n}\r\nfor(rp=lemp->rule; rp; rp=rp->next){\r\nint i;\r\nfor(i=0; i<rp->nrhs; i++){\r\nif( rp->rhs[i]==sp ){\r\nErrorMsg(lemp->filename,0,\r\n"The start symbol \"%s\" occurs on the \\r\nright-hand side of a rule. This will result in a parser which \\r\ndoes not work properly.",sp->name);\r\nlemp->errorcnt++;\r\n}\r\n}\r\n}\r\nfor(rp=sp->rule; rp; rp=rp->nextlhs){\r\nstruct config *newcfp;\r\nrp->lhsStart = 1;\r\nnewcfp = Configlist_addbasis(rp,0);\r\nSetAdd(newcfp->fws,0);\r\n}\r\n(void)getstate(lemp);\r\nreturn;\r\n}\r\nPRIVATE struct state *getstate(struct lemon *lemp)\r\n{\r\nstruct config *cfp, *bp;\r\nstruct state *stp;\r\nConfiglist_sortbasis();\r\nbp = Configlist_basis();\r\nstp = State_find(bp);\r\nif( stp ){\r\nstruct config *x, *y;\r\nfor(x=bp, y=stp->bp; x && y; x=x->bp, y=y->bp){\r\nPlink_copy(&y->bplp,x->bplp);\r\nPlink_delete(x->fplp);\r\nx->fplp = x->bplp = 0;\r\n}\r\ncfp = Configlist_return();\r\nConfiglist_eat(cfp);\r\n}else{\r\nConfiglist_closure(lemp);\r\nConfiglist_sort();\r\ncfp = Configlist_return();\r\nstp = State_new();\r\nMemoryCheck(stp);\r\nstp->bp = bp;\r\nstp->cfp = cfp;\r\nstp->statenum = lemp->nstate++;\r\nstp->ap = 0;\r\nState_insert(stp,stp->bp);\r\nbuildshifts(lemp,stp);\r\n}\r\nreturn stp;\r\n}\r\nstatic int same_symbol(struct symbol *a, struct symbol *b)\r\n{\r\nint i;\r\nif( a==b ) return 1;\r\nif( a->type!=MULTITERMINAL ) return 0;\r\nif( b->type!=MULTITERMINAL ) return 0;\r\nif( a->nsubsym!=b->nsubsym ) return 0;\r\nfor(i=0; i<a->nsubsym; i++){\r\nif( a->subsym[i]!=b->subsym[i] ) return 0;\r\n}\r\nreturn 1;\r\n}\r\nPRIVATE void buildshifts(struct lemon *lemp, struct state *stp)\r\n{\r\nstruct config *cfp;\r\nstruct config *bcfp;\r\nstruct config *newcfg;\r\nstruct symbol *sp;\r\nstruct symbol *bsp;\r\nstruct state *newstp;\r\nfor(cfp=stp->cfp; cfp; cfp=cfp->next) cfp->status = INCOMPLETE;\r\nfor(cfp=stp->cfp; cfp; cfp=cfp->next){\r\nif( cfp->status==COMPLETE ) continue;\r\nif( cfp->dot>=cfp->rp->nrhs ) continue;\r\nConfiglist_reset();\r\nsp = cfp->rp->rhs[cfp->dot];\r\nfor(bcfp=cfp; bcfp; bcfp=bcfp->next){\r\nif( bcfp->status==COMPLETE ) continue;\r\nif( bcfp->dot>=bcfp->rp->nrhs ) continue;\r\nbsp = bcfp->rp->rhs[bcfp->dot];\r\nif( !same_symbol(bsp,sp) ) continue;\r\nbcfp->status = COMPLETE;\r\nnewcfg = Configlist_addbasis(bcfp->rp,bcfp->dot+1);\r\nPlink_add(&newcfg->bplp,bcfp);\r\n}\r\nnewstp = getstate(lemp);\r\nif( sp->type==MULTITERMINAL ){\r\nint i;\r\nfor(i=0; i<sp->nsubsym; i++){\r\nAction_add(&stp->ap,SHIFT,sp->subsym[i],(char*)newstp);\r\n}\r\n}else{\r\nAction_add(&stp->ap,SHIFT,sp,(char *)newstp);\r\n}\r\n}\r\n}\r\nvoid FindLinks(struct lemon *lemp)\r\n{\r\nint i;\r\nstruct config *cfp, *other;\r\nstruct state *stp;\r\nstruct plink *plp;\r\nfor(i=0; i<lemp->nstate; i++){\r\nstp = lemp->sorted[i];\r\nfor(cfp=stp->cfp; cfp; cfp=cfp->next){\r\ncfp->stp = stp;\r\n}\r\n}\r\nfor(i=0; i<lemp->nstate; i++){\r\nstp = lemp->sorted[i];\r\nfor(cfp=stp->cfp; cfp; cfp=cfp->next){\r\nfor(plp=cfp->bplp; plp; plp=plp->next){\r\nother = plp->cfp;\r\nPlink_add(&other->fplp,cfp);\r\n}\r\n}\r\n}\r\n}\r\nvoid FindFollowSets(struct lemon *lemp)\r\n{\r\nint i;\r\nstruct config *cfp;\r\nstruct plink *plp;\r\nint progress;\r\nint change;\r\nfor(i=0; i<lemp->nstate; i++){\r\nfor(cfp=lemp->sorted[i]->cfp; cfp; cfp=cfp->next){\r\ncfp->status = INCOMPLETE;\r\n}\r\n}\r\ndo{\r\nprogress = 0;\r\nfor(i=0; i<lemp->nstate; i++){\r\nfor(cfp=lemp->sorted[i]->cfp; cfp; cfp=cfp->next){\r\nif( cfp->status==COMPLETE ) continue;\r\nfor(plp=cfp->fplp; plp; plp=plp->next){\r\nchange = SetUnion(plp->cfp->fws,cfp->fws);\r\nif( change ){\r\nplp->cfp->status = INCOMPLETE;\r\nprogress = 1;\r\n}\r\n}\r\ncfp->status = COMPLETE;\r\n}\r\n}\r\n}while( progress );\r\n}\r\nvoid FindActions(struct lemon *lemp)\r\n{\r\nint i,j;\r\nstruct config *cfp;\r\nstruct state *stp;\r\nstruct symbol *sp;\r\nstruct rule *rp;\r\nfor(i=0; i<lemp->nstate; i++){\r\nstp = lemp->sorted[i];\r\nfor(cfp=stp->cfp; cfp; cfp=cfp->next){\r\nif( cfp->rp->nrhs==cfp->dot ){\r\nfor(j=0; j<lemp->nterminal; j++){\r\nif( SetFind(cfp->fws,j) ){\r\nAction_add(&stp->ap,REDUCE,lemp->symbols[j],(char *)cfp->rp);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif( lemp->start ){\r\nsp = Symbol_find(lemp->start);\r\nif( sp==0 ) sp = lemp->rule->lhs;\r\n}else{\r\nsp = lemp->rule->lhs;\r\n}\r\nAction_add(&lemp->sorted[0]->ap,ACCEPT,sp,0);\r\nfor(i=0; i<lemp->nstate; i++){\r\nstruct action *ap, *nap;\r\nstp = lemp->sorted[i];\r\nstp->ap = Action_sort(stp->ap);\r\nfor(ap=stp->ap; ap && ap->next; ap=ap->next){\r\nfor(nap=ap->next; nap && nap->sp==ap->sp; nap=nap->next){\r\nlemp->nconflict += resolve_conflict(ap,nap);\r\n}\r\n}\r\n}\r\nfor(rp=lemp->rule; rp; rp=rp->next) rp->canReduce = LEMON_FALSE;\r\nfor(i=0; i<lemp->nstate; i++){\r\nstruct action *ap;\r\nfor(ap=lemp->sorted[i]->ap; ap; ap=ap->next){\r\nif( ap->type==REDUCE ) ap->x.rp->canReduce = LEMON_TRUE;\r\n}\r\n}\r\nfor(rp=lemp->rule; rp; rp=rp->next){\r\nif( rp->canReduce ) continue;\r\nErrorMsg(lemp->filename,rp->ruleline,"This rule can not be reduced.\n");\r\nlemp->errorcnt++;\r\n}\r\n}\r\nstatic int resolve_conflict(\r\nstruct action *apx,\r\nstruct action *apy)\r\n{\r\nstruct symbol *spx, *spy;\r\nint errcnt = 0;\r\nassert( apx->sp==apy->sp );\r\nif( apx->type==SHIFT && apy->type==SHIFT ){\r\napy->type = SSCONFLICT;\r\nerrcnt++;\r\n}\r\nif( apx->type==SHIFT && apy->type==REDUCE ){\r\nspx = apx->sp;\r\nspy = apy->x.rp->precsym;\r\nif( spy==0 || spx->prec<0 || spy->prec<0 ){\r\napy->type = SRCONFLICT;\r\nerrcnt++;\r\n}else if( spx->prec>spy->prec ){\r\napy->type = RD_RESOLVED;\r\n}else if( spx->prec<spy->prec ){\r\napx->type = SH_RESOLVED;\r\n}else if( spx->prec==spy->prec && spx->assoc==RIGHT ){\r\napy->type = RD_RESOLVED;\r\n}else if( spx->prec==spy->prec && spx->assoc==LEFT ){\r\napx->type = SH_RESOLVED;\r\n}else{\r\nassert( spx->prec==spy->prec && spx->assoc==NONE );\r\napy->type = SRCONFLICT;\r\nerrcnt++;\r\n}\r\n}else if( apx->type==REDUCE && apy->type==REDUCE ){\r\nspx = apx->x.rp->precsym;\r\nspy = apy->x.rp->precsym;\r\nif( spx==0 || spy==0 || spx->prec<0 ||\r\nspy->prec<0 || spx->prec==spy->prec ){\r\napy->type = RRCONFLICT;\r\nerrcnt++;\r\n}else if( spx->prec>spy->prec ){\r\napy->type = RD_RESOLVED;\r\n}else if( spx->prec<spy->prec ){\r\napx->type = RD_RESOLVED;\r\n}\r\n}else{\r\nassert(\r\napx->type==SH_RESOLVED ||\r\napx->type==RD_RESOLVED ||\r\napx->type==SSCONFLICT ||\r\napx->type==SRCONFLICT ||\r\napx->type==RRCONFLICT ||\r\napy->type==SH_RESOLVED ||\r\napy->type==RD_RESOLVED ||\r\napy->type==SSCONFLICT ||\r\napy->type==SRCONFLICT ||\r\napy->type==RRCONFLICT\r\n);\r\n}\r\nreturn errcnt;\r\n}\r\nPRIVATE struct config *newconfig(void){\r\nstruct config *newcfg;\r\nif( freelist==0 ){\r\nint i;\r\nint amt = 3;\r\nfreelist = (struct config *)calloc( amt, sizeof(struct config) );\r\nif( freelist==NULL ){\r\nfprintf(stderr,"Unable to allocate memory for a new configuration.");\r\nexit(1);\r\n}\r\nfor(i=0; i<amt-1; i++) freelist[i].next = &freelist[i+1];\r\nfreelist[amt-1].next = 0;\r\n}\r\nnewcfg = freelist;\r\nfreelist = freelist->next;\r\nreturn newcfg;\r\n}\r\nPRIVATE void deleteconfig(struct config *old)\r\n{\r\nold->next = freelist;\r\nfreelist = old;\r\n}\r\nvoid Configlist_init(void){\r\ncurrent = 0;\r\ncurrentend = &current;\r\nbasis = 0;\r\nbasisend = &basis;\r\nConfigtable_init();\r\nreturn;\r\n}\r\nvoid Configlist_reset(void){\r\ncurrent = 0;\r\ncurrentend = &current;\r\nbasis = 0;\r\nbasisend = &basis;\r\nConfigtable_clear(0);\r\nreturn;\r\n}\r\nstruct config *Configlist_add(\r\nstruct rule *rp,\r\nint dot)\r\n{\r\nstruct config *cfp, model;\r\nassert( currentend!=0 );\r\nmodel.rp = rp;\r\nmodel.dot = dot;\r\ncfp = Configtable_find(&model);\r\nif( cfp==0 ){\r\ncfp = newconfig();\r\ncfp->rp = rp;\r\ncfp->dot = dot;\r\ncfp->fws = SetNew();\r\ncfp->stp = 0;\r\ncfp->fplp = cfp->bplp = 0;\r\ncfp->next = 0;\r\ncfp->bp = 0;\r\n*currentend = cfp;\r\ncurrentend = &cfp->next;\r\nConfigtable_insert(cfp);\r\n}\r\nreturn cfp;\r\n}\r\nstruct config *Configlist_addbasis(struct rule *rp, int dot)\r\n{\r\nstruct config *cfp, model;\r\nassert( basisend!=0 );\r\nassert( currentend!=0 );\r\nmodel.rp = rp;\r\nmodel.dot = dot;\r\ncfp = Configtable_find(&model);\r\nif( cfp==0 ){\r\ncfp = newconfig();\r\ncfp->rp = rp;\r\ncfp->dot = dot;\r\ncfp->fws = SetNew();\r\ncfp->stp = 0;\r\ncfp->fplp = cfp->bplp = 0;\r\ncfp->next = 0;\r\ncfp->bp = 0;\r\n*currentend = cfp;\r\ncurrentend = &cfp->next;\r\n*basisend = cfp;\r\nbasisend = &cfp->bp;\r\nConfigtable_insert(cfp);\r\n}\r\nreturn cfp;\r\n}\r\nvoid Configlist_closure(struct lemon *lemp)\r\n{\r\nstruct config *cfp, *newcfp;\r\nstruct rule *rp, *newrp;\r\nstruct symbol *sp, *xsp;\r\nint i, dot;\r\nassert( currentend!=0 );\r\nfor(cfp=current; cfp; cfp=cfp->next){\r\nrp = cfp->rp;\r\ndot = cfp->dot;\r\nif( dot>=rp->nrhs ) continue;\r\nsp = rp->rhs[dot];\r\nif( sp->type==NONTERMINAL ){\r\nif( sp->rule==0 && sp!=lemp->errsym ){\r\nErrorMsg(lemp->filename,rp->line,"Nonterminal \"%s\" has no rules.",\r\nsp->name);\r\nlemp->errorcnt++;\r\n}\r\nfor(newrp=sp->rule; newrp; newrp=newrp->nextlhs){\r\nnewcfp = Configlist_add(newrp,0);\r\nfor(i=dot+1; i<rp->nrhs; i++){\r\nxsp = rp->rhs[i];\r\nif( xsp->type==TERMINAL ){\r\nSetAdd(newcfp->fws,xsp->index);\r\nbreak;\r\n}else if( xsp->type==MULTITERMINAL ){\r\nint k;\r\nfor(k=0; k<xsp->nsubsym; k++){\r\nSetAdd(newcfp->fws, xsp->subsym[k]->index);\r\n}\r\nbreak;\r\n}else{\r\nSetUnion(newcfp->fws,xsp->firstset);\r\nif( xsp->lambda==LEMON_FALSE ) break;\r\n}\r\n}\r\nif( i==rp->nrhs ) Plink_add(&cfp->fplp,newcfp);\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid Configlist_sort(void){\r\ncurrent = (struct config *)msort((char *)current,(char **)&(current->next),Configcmp);\r\ncurrentend = 0;\r\nreturn;\r\n}\r\nvoid Configlist_sortbasis(void){\r\nbasis = (struct config *)msort((char *)current,(char **)&(current->bp),Configcmp);\r\nbasisend = 0;\r\nreturn;\r\n}\r\nstruct config *Configlist_return(void){\r\nstruct config *old;\r\nold = current;\r\ncurrent = 0;\r\ncurrentend = 0;\r\nreturn old;\r\n}\r\nstruct config *Configlist_basis(void){\r\nstruct config *old;\r\nold = basis;\r\nbasis = 0;\r\nbasisend = 0;\r\nreturn old;\r\n}\r\nvoid Configlist_eat(struct config *cfp)\r\n{\r\nstruct config *nextcfp;\r\nfor(; cfp; cfp=nextcfp){\r\nnextcfp = cfp->next;\r\nassert( cfp->fplp==0 );\r\nassert( cfp->bplp==0 );\r\nif( cfp->fws ) SetFree(cfp->fws);\r\ndeleteconfig(cfp);\r\n}\r\nreturn;\r\n}\r\nstatic int findbreak(char *msg, int min, int max)\r\n{\r\nint i,spot;\r\nchar c;\r\nfor(i=spot=min; i<=max; i++){\r\nc = msg[i];\r\nif( c=='\t' ) msg[i] = ' ';\r\nif( c=='\n' ){ msg[i] = ' '; spot = i; break; }\r\nif( c==0 ){ spot = i; break; }\r\nif( c=='-' && i<max-1 ) spot = i+1;\r\nif( c==' ' ) spot = i;\r\n}\r\nreturn spot;\r\n}\r\nvoid ErrorMsg(const char *filename, int lineno, const char *format, ...)\r\n{\r\nchar errmsg[ERRMSGSIZE];\r\nchar prefix[PREFIXLIMIT+10];\r\nint errmsgsize;\r\nint prefixsize;\r\nint availablewidth;\r\nva_list ap;\r\nint end, restart, base;\r\nif( lineno>0 ){\r\nsprintf(prefix,"%.*s:%d: ",PREFIXLIMIT-10,filename,lineno);\r\n}else{\r\nsprintf(prefix,"%.*s: ",PREFIXLIMIT-10,filename);\r\n}\r\nprefixsize = lemonStrlen(prefix);\r\navailablewidth = LINEWIDTH - prefixsize;\r\nva_start(ap, format);\r\nvsprintf(errmsg,format,ap);\r\nva_end(ap);\r\nerrmsgsize = lemonStrlen(errmsg);\r\nwhile( errmsgsize>0 && errmsg[errmsgsize-1]=='\n' ){\r\nerrmsg[--errmsgsize] = 0;\r\n}\r\nbase = 0;\r\nwhile( errmsg[base]!=0 ){\r\nend = restart = findbreak(&errmsg[base],0,availablewidth);\r\nrestart += base;\r\nwhile( errmsg[restart]==' ' ) restart++;\r\nfprintf(stdout,"%s%.*s\n",prefix,end,&errmsg[base]);\r\nbase = restart;\r\n}\r\n}\r\nvoid memory_error(void){\r\nfprintf(stderr,"Out of memory. Aborting...\n");\r\nexit(1);\r\n}\r\nPRIVATE char*\r\nmake_basename(char* fullname)\r\n{\r\nchar *cp;\r\nchar *new_string;\r\ncp = strrchr(fullname, '/');\r\n#ifdef _WIN32\r\nif (!cp)\r\ncp = strrchr(fullname, '\\');\r\n#endif\r\nif (!cp) {\r\nnew_string = (char *) malloc( strlen(fullname) + 1 );\r\nstrcpy(new_string, fullname);\r\n}\r\nelse {\r\ncp++;\r\nnew_string = (char *) malloc( strlen(cp) + 1 );\r\nstrcpy(new_string, cp);\r\n}\r\nreturn new_string;\r\n}\r\nstatic void handle_D_option(char *z){\r\nchar **paz;\r\nnDefine++;\r\nazDefine = (char **) realloc(azDefine, sizeof(azDefine[0])*nDefine);\r\nif( azDefine==0 ){\r\nfprintf(stderr,"out of memory\n");\r\nexit(1);\r\n}\r\npaz = &azDefine[nDefine-1];\r\n*paz = (char *) malloc( lemonStrlen(z)+1 );\r\nif( *paz==0 ){\r\nfprintf(stderr,"out of memory\n");\r\nexit(1);\r\n}\r\nstrcpy(*paz, z);\r\nfor(z=*paz; *z && *z!='='; z++){}\r\n*z = 0;\r\n}\r\nint main(int argc _U_, char **argv)\r\n{\r\nstatic int version = 0;\r\nstatic int rpflag = 0;\r\nstatic int basisflag = 0;\r\nstatic int compress = 0;\r\nstatic int quiet = 0;\r\nstatic int statistics = 0;\r\nstatic int mhflag = 0;\r\nstatic char *outdirname = NULL;\r\nstatic char *templatename = NULL;\r\nstatic struct s_options options[] = {\r\n{OPT_FLAG, "b", (char*)&basisflag, "Print only the basis in report."},\r\n{OPT_FLAG, "c", (char*)&compress, "Don't compress the action table."},\r\n{OPT_STR, "d", (char*)&outdirname, "Output directory name."},\r\n{OPT_FSTR, "D", (char*)handle_D_option, "Define an %ifdef macro."},\r\n{OPT_FLAG, "g", (char*)&rpflag, "Print grammar without actions."},\r\n{OPT_FLAG, "m", (char*)&mhflag, "Output a makeheaders compatible file"},\r\n{OPT_FLAG, "q", (char*)&quiet, "(Quiet) Don't print the report file."},\r\n{OPT_FLAG, "s", (char*)&statistics,\r\n"Print parser stats to standard output."},\r\n{OPT_STR, "t", (char*)&templatename, "Template file to use."},\r\n{OPT_FLAG, "x", (char*)&version, "Print the version number."},\r\n{OPT_FLAG,0,0,0}\r\n};\r\nint i;\r\nstruct lemon lem;\r\noptinit(argv,options,stderr);\r\nif( version ){\r\nprintf("Lemon version 1.0\n"\r\n"Copyright 1991-1997 by D. Richard Hipp\n"\r\n"Freely distributable under the GNU Public License.\n"\r\n);\r\nexit(0);\r\n}\r\nif( optnargs()!=1 ){\r\nfprintf(stderr,"Exactly one filename argument is required.\n");\r\nexit(1);\r\n}\r\nmemset(&lem, 0, sizeof(lem));\r\nlem.errorcnt = 0;\r\nStrsafe_init();\r\nSymbol_init();\r\nState_init();\r\nlem.argv0 = argv[0];\r\nlem.filename = get_optarg(0);\r\nlem.basisflag = basisflag;\r\nSymbol_new("$");\r\nlem.errsym = Symbol_new("error");\r\nlem.outdirname = outdirname;\r\nlem.templatename = templatename;\r\nlem.basename = make_basename(lem.filename);\r\nParse(&lem);\r\nif( lem.errorcnt ) exit(lem.errorcnt);\r\nif( lem.nrule==0 ){\r\nfprintf(stderr,"Empty grammar.\n");\r\nexit(1);\r\n}\r\nlem.nsymbol = Symbol_count();\r\nSymbol_new("{default}");\r\nlem.symbols = Symbol_arrayof();\r\nfor(i=0; i<=lem.nsymbol; i++) lem.symbols[i]->index = i;\r\nqsort(lem.symbols,lem.nsymbol+1,sizeof(struct symbol*),\r\nSymbolcmpp);\r\nfor(i=0; i<=lem.nsymbol; i++) lem.symbols[i]->index = i;\r\nfor(i=1; safe_isupper(lem.symbols[i]->name[0]); i++);\r\nlem.nterminal = i;\r\nif( rpflag ){\r\nReprint(&lem);\r\n}else{\r\nSetSize(lem.nterminal+1);\r\nFindRulePrecedences(&lem);\r\nFindFirstSets(&lem);\r\nlem.nstate = 0;\r\nFindStates(&lem);\r\nlem.sorted = State_arrayof();\r\nFindLinks(&lem);\r\nFindFollowSets(&lem);\r\nFindActions(&lem);\r\nif( compress==0 ) CompressTables(&lem);\r\nResortStates(&lem);\r\nif( !quiet ) ReportOutput(&lem);\r\nReportTable(&lem, mhflag);\r\nif( !mhflag ) ReportHeader(&lem);\r\n}\r\nif( statistics ){\r\nprintf("Parser statistics: %d terminals, %d nonterminals, %d rules\n",\r\nlem.nterminal, lem.nsymbol - lem.nterminal, lem.nrule);\r\nprintf(" %d states, %d parser table entries, %d conflicts\n",\r\nlem.nstate, lem.tablesize, lem.nconflict);\r\n}\r\nif( lem.nconflict ){\r\nfprintf(stderr,"%d parsing conflicts.\n",lem.nconflict);\r\n}\r\nexit(lem.errorcnt + lem.nconflict);\r\nreturn (lem.errorcnt + lem.nconflict);\r\n}\r\nstatic char *merge( char *a, char *b, int (*cmp)(const char*,const char*),\r\nunsigned long offset\r\n){\r\nchar *ptr, *head;\r\nif( a==0 ){\r\nhead = b;\r\n}else if( b==0 ){\r\nhead = a;\r\n}else{\r\nif( (*cmp)(a,b)<=0 ){\r\nptr = a;\r\na = NEXT(a);\r\n}else{\r\nptr = b;\r\nb = NEXT(b);\r\n}\r\nhead = ptr;\r\nwhile( a && b ){\r\nif( (*cmp)(a,b)<=0 ){\r\nNEXT(ptr) = a;\r\nptr = a;\r\na = NEXT(a);\r\n}else{\r\nNEXT(ptr) = b;\r\nptr = b;\r\nb = NEXT(b);\r\n}\r\n}\r\nif( a ) NEXT(ptr) = a;\r\nelse NEXT(ptr) = b;\r\n}\r\nreturn head;\r\n}\r\nstatic char *msort(char *list, char **next, int (*cmp)(const char*,const char*))\r\n{\r\nunsigned long offset;\r\nchar *ep;\r\nchar *set[LISTSIZE];\r\nint i;\r\noffset = (unsigned long)next - (unsigned long)list;\r\nfor(i=0; i<LISTSIZE; i++) set[i] = 0;\r\nwhile( list ){\r\nep = list;\r\nlist = NEXT(list);\r\nNEXT(ep) = 0;\r\nfor(i=0; i<LISTSIZE-1 && set[i]!=0; i++){\r\nep = merge(ep,set[i],cmp,offset);\r\nset[i] = 0;\r\n}\r\nset[i] = ep;\r\n}\r\nep = 0;\r\nfor(i=0; i<LISTSIZE; i++) if( set[i] ) ep = merge(set[i],ep,cmp,offset);\r\nreturn ep;\r\n}\r\nstatic void errline(int n, int k, FILE *err)\r\n{\r\nint spcnt, i;\r\nif( argv[0] ) fprintf(err,"%s",argv[0]);\r\nspcnt = lemonStrlen(argv[0]) + 1;\r\nfor(i=1; i<n && argv[i]; i++){\r\nfprintf(err," %s",argv[i]);\r\nspcnt += lemonStrlen(argv[i])+1;\r\n}\r\nspcnt += k;\r\nfor(; argv[i]; i++) fprintf(err," %s",argv[i]);\r\nif( spcnt<20 ){\r\nfprintf(err,"\n%*s^-- here\n",spcnt,"");\r\n}else{\r\nfprintf(err,"\n%*shere --^\n",spcnt-7,"");\r\n}\r\n}\r\nstatic int argindex(int n)\r\n{\r\nint i;\r\nint dashdash = 0;\r\nif( argv!=0 && *argv!=0 ){\r\nfor(i=1; argv[i]; i++){\r\nif( dashdash || !ISOPT(argv[i]) ){\r\nif( n==0 ) return i;\r\nn--;\r\n}\r\nif( strcmp(argv[i],"--")==0 ) dashdash = 1;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int handleflags(int i, FILE *err)\r\n{\r\nint v;\r\nint errcnt = 0;\r\nint j;\r\nfor(j=0; op[j].label; j++){\r\nif( strncmp(&argv[i][1],op[j].label,lemonStrlen(op[j].label))==0 ) break;\r\n}\r\nv = argv[i][0]=='-' ? 1 : 0;\r\nif( op[j].label==0 ){\r\nif( err ){\r\nfprintf(err,"%sundefined option.\n",emsg);\r\nerrline(i,1,err);\r\n}\r\nerrcnt++;\r\n}else if( op[j].type==OPT_FLAG ){\r\n*((int*)op[j].arg) = v;\r\n}else if( op[j].type==OPT_FFLAG ){\r\n(*(void(*)(int))(op[j].arg))(v);\r\n}else if( op[j].type==OPT_FSTR ){\r\n(*(void(*)(char *))(op[j].arg))(&argv[i][2]);\r\n}else{\r\nif( err ){\r\nfprintf(err,"%smissing argument on switch.\n",emsg);\r\nerrline(i,1,err);\r\n}\r\nerrcnt++;\r\n}\r\nreturn errcnt;\r\n}\r\nstatic int handleswitch(int i, FILE *err)\r\n{\r\nlong lv = 0;\r\ndouble dv = 0.0;\r\nchar *sv = 0, *end;\r\nchar *cp = 0;\r\nint j;\r\nint errcnt = 0;\r\ncp = strchr(argv[i],'=');\r\nassert( cp!=0 );\r\n*cp = 0;\r\nfor(j=0; op[j].label; j++){\r\nif( strcmp(argv[i],op[j].label)==0 ) break;\r\n}\r\n*cp = '=';\r\nif( op[j].label==0 ){\r\nif( err ){\r\nfprintf(err,"%sundefined option.\n",emsg);\r\nerrline(i,0,err);\r\n}\r\nerrcnt++;\r\n}else{\r\ncp++;\r\nswitch( op[j].type ){\r\ncase OPT_FLAG:\r\ncase OPT_FFLAG:\r\nif( err ){\r\nfprintf(err,"%soption requires an argument.\n",emsg);\r\nerrline(i,0,err);\r\n}\r\nerrcnt++;\r\nbreak;\r\ncase OPT_DBL:\r\ncase OPT_FDBL:\r\ndv = strtod(cp,&end);\r\nif( *end ){\r\nif( err ){\r\nfprintf(err,"%sillegal character in floating-point argument.\n",emsg);\r\nerrline(i,(int)(end-argv[i]),err);\r\n}\r\nerrcnt++;\r\n}\r\nbreak;\r\ncase OPT_INT:\r\ncase OPT_FINT:\r\nlv = strtol(cp,&end,0);\r\nif( *end ){\r\nif( err ){\r\nfprintf(err,"%sillegal character in integer argument.\n",emsg);\r\nerrline(i,(int)(end-argv[i]),err);\r\n}\r\nerrcnt++;\r\n}\r\nbreak;\r\ncase OPT_STR:\r\ncase OPT_FSTR:\r\nsv = cp;\r\nbreak;\r\n}\r\nswitch( op[j].type ){\r\ncase OPT_FLAG:\r\ncase OPT_FFLAG:\r\nbreak;\r\ncase OPT_DBL:\r\n*(double*)(op[j].arg) = dv;\r\nbreak;\r\ncase OPT_FDBL:\r\n(*(void(*)(double))(op[j].arg))(dv);\r\nbreak;\r\ncase OPT_INT:\r\n*(int*)(op[j].arg) = (int)lv;\r\nbreak;\r\ncase OPT_FINT:\r\n(*(void(*)(int))(op[j].arg))((int)lv);\r\nbreak;\r\ncase OPT_STR:\r\n*(char**)(op[j].arg) = sv;\r\nbreak;\r\ncase OPT_FSTR:\r\n(*(void(*)(char *))(op[j].arg))(sv);\r\nbreak;\r\n}\r\n}\r\nreturn errcnt;\r\n}\r\nint optinit(char **a, struct s_options *o, FILE *err)\r\n{\r\nint errcnt = 0;\r\nargv = a;\r\nop = o;\r\nerrstream = err;\r\nif( argv && *argv && op ){\r\nint i;\r\nfor(i=1; argv[i]; i++){\r\nif( argv[i][0]=='+' || argv[i][0]=='-' ){\r\nerrcnt += handleflags(i,err);\r\n}else if( strchr(argv[i],'=') ){\r\nerrcnt += handleswitch(i,err);\r\n}\r\n}\r\n}\r\nif( errcnt>0 ){\r\nfprintf(err,"Valid command line options for \"%s\" are:\n",*a);\r\noptprint();\r\nexit(1);\r\n}\r\nreturn 0;\r\n}\r\nint optnargs(void){\r\nint cnt = 0;\r\nint dashdash = 0;\r\nint i;\r\nif( argv!=0 && argv[0]!=0 ){\r\nfor(i=1; argv[i]; i++){\r\nif( dashdash || !ISOPT(argv[i]) ) cnt++;\r\nif( strcmp(argv[i],"--")==0 ) dashdash = 1;\r\n}\r\n}\r\nreturn cnt;\r\n}\r\nchar *get_optarg(int n)\r\n{\r\nint i;\r\ni = argindex(n);\r\nreturn i>=0 ? argv[i] : 0;\r\n}\r\nvoid get_opterr(int n)\r\n{\r\nint i;\r\ni = argindex(n);\r\nif( i>=0 ) errline(i,0,errstream);\r\n}\r\nvoid optprint(void){\r\nint i;\r\nint max, len;\r\nmax = 0;\r\nfor(i=0; op[i].label; i++){\r\nlen = lemonStrlen(op[i].label) + 1;\r\nswitch( op[i].type ){\r\ncase OPT_FLAG:\r\ncase OPT_FFLAG:\r\nbreak;\r\ncase OPT_INT:\r\ncase OPT_FINT:\r\nlen += 9;\r\nbreak;\r\ncase OPT_DBL:\r\ncase OPT_FDBL:\r\nlen += 6;\r\nbreak;\r\ncase OPT_STR:\r\ncase OPT_FSTR:\r\nlen += 8;\r\nbreak;\r\n}\r\nif( len>max ) max = len;\r\n}\r\nfor(i=0; op[i].label; i++){\r\nswitch( op[i].type ){\r\ncase OPT_FLAG:\r\ncase OPT_FFLAG:\r\nfprintf(errstream," -%-*s %s\n",max,op[i].label,op[i].message);\r\nbreak;\r\ncase OPT_INT:\r\ncase OPT_FINT:\r\nfprintf(errstream," %s=<integer>%*s %s\n",op[i].label,\r\n(int)(max-lemonStrlen(op[i].label)-9),"",op[i].message);\r\nbreak;\r\ncase OPT_DBL:\r\ncase OPT_FDBL:\r\nfprintf(errstream," %s=<real>%*s %s\n",op[i].label,\r\n(int)(max-lemonStrlen(op[i].label)-6),"",op[i].message);\r\nbreak;\r\ncase OPT_STR:\r\ncase OPT_FSTR:\r\nfprintf(errstream," %s=<string>%*s %s\n",op[i].label,\r\n(int)(max-lemonStrlen(op[i].label)-8),"",op[i].message);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void parseonetoken(struct pstate *psp)\r\n{\r\nconst char *x;\r\nx = Strsafe(psp->tokenstart);\r\n#if 0\r\nprintf("%s:%d: Token=[%s] state=%d\n",psp->filename,psp->tokenlineno,\r\nx,psp->state);\r\n#endif\r\nswitch( psp->state ){\r\ncase INITIALIZE:\r\npsp->prevrule = 0;\r\npsp->preccounter = 0;\r\npsp->firstrule = psp->lastrule = 0;\r\npsp->gp->nrule = 0;\r\ncase WAITING_FOR_DECL_OR_RULE:\r\nif( x[0]=='%' ){\r\npsp->state = WAITING_FOR_DECL_KEYWORD;\r\n}else if( safe_islower(x[0]) ){\r\npsp->lhs = Symbol_new(x);\r\npsp->nrhs = 0;\r\npsp->lhsalias = 0;\r\npsp->state = WAITING_FOR_ARROW;\r\n}else if( x[0]=='{' ){\r\nif( psp->prevrule==0 ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"There is no prior rule upon which to attach the code \\r\nfragment which begins on this line.");\r\npsp->errorcnt++;\r\n}else if( psp->prevrule->code!=0 ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Code fragment beginning on this line is not the first \\r\nto follow the previous rule.");\r\npsp->errorcnt++;\r\n}else{\r\npsp->prevrule->line = psp->tokenlineno;\r\npsp->prevrule->code = &x[1];\r\n}\r\n}else if( x[0]=='[' ){\r\npsp->state = PRECEDENCE_MARK_1;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Token \"%s\" should be either \"%%\" or a nonterminal name.",\r\nx);\r\npsp->errorcnt++;\r\n}\r\nbreak;\r\ncase PRECEDENCE_MARK_1:\r\nif( !safe_isupper(x[0]) ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"The precedence symbol must be a terminal.");\r\npsp->errorcnt++;\r\n}else if( psp->prevrule==0 ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"There is no prior rule to assign precedence \"[%s]\".",x);\r\npsp->errorcnt++;\r\n}else if( psp->prevrule->precsym!=0 ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Precedence mark on this line is not the first \\r\nto follow the previous rule.");\r\npsp->errorcnt++;\r\n}else{\r\npsp->prevrule->precsym = Symbol_new(x);\r\n}\r\npsp->state = PRECEDENCE_MARK_2;\r\nbreak;\r\ncase PRECEDENCE_MARK_2:\r\nif( x[0]!=']' ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Missing \"]\" on precedence mark.");\r\npsp->errorcnt++;\r\n}\r\npsp->state = WAITING_FOR_DECL_OR_RULE;\r\nbreak;\r\ncase WAITING_FOR_ARROW:\r\nif( x[0]==':' && x[1]==':' && x[2]=='=' ){\r\npsp->state = IN_RHS;\r\n}else if( x[0]=='(' ){\r\npsp->state = LHS_ALIAS_1;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Expected to see a \":\" following the LHS symbol \"%s\".",\r\npsp->lhs->name);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_RULE_ERROR;\r\n}\r\nbreak;\r\ncase LHS_ALIAS_1:\r\nif( safe_isalpha(x[0]) ){\r\npsp->lhsalias = x;\r\npsp->state = LHS_ALIAS_2;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"\"%s\" is not a valid alias for the LHS \"%s\"\n",\r\nx,psp->lhs->name);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_RULE_ERROR;\r\n}\r\nbreak;\r\ncase LHS_ALIAS_2:\r\nif( x[0]==')' ){\r\npsp->state = LHS_ALIAS_3;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Missing \")\" following LHS alias name \"%s\".",psp->lhsalias);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_RULE_ERROR;\r\n}\r\nbreak;\r\ncase LHS_ALIAS_3:\r\nif( x[0]==':' && x[1]==':' && x[2]=='=' ){\r\npsp->state = IN_RHS;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Missing \"->\" following: \"%s(%s)\".",\r\npsp->lhs->name,psp->lhsalias);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_RULE_ERROR;\r\n}\r\nbreak;\r\ncase IN_RHS:\r\nif( x[0]=='.' ){\r\nstruct rule *rp;\r\nrp = (struct rule *)calloc( sizeof(struct rule) +\r\nsizeof(struct symbol*)*psp->nrhs + sizeof(char*)*psp->nrhs, 1);\r\nif( rp==NULL ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Can't allocate enough memory for this rule.");\r\npsp->errorcnt++;\r\npsp->prevrule = 0;\r\n}else{\r\nint i;\r\nrp->ruleline = psp->tokenlineno;\r\nrp->rhs = (struct symbol**)&rp[1];\r\nrp->rhsalias = (const char**)&(rp->rhs[psp->nrhs]);\r\nfor(i=0; i<psp->nrhs; i++){\r\nrp->rhs[i] = psp->rhs[i];\r\nrp->rhsalias[i] = psp->alias[i];\r\n}\r\nrp->lhs = psp->lhs;\r\nrp->lhsalias = psp->lhsalias;\r\nrp->nrhs = psp->nrhs;\r\nrp->code = 0;\r\nrp->precsym = 0;\r\nrp->index = psp->gp->nrule++;\r\nrp->nextlhs = rp->lhs->rule;\r\nrp->lhs->rule = rp;\r\nrp->next = 0;\r\nif( psp->firstrule==0 ){\r\npsp->firstrule = psp->lastrule = rp;\r\n}else{\r\npsp->lastrule->next = rp;\r\npsp->lastrule = rp;\r\n}\r\npsp->prevrule = rp;\r\n}\r\npsp->state = WAITING_FOR_DECL_OR_RULE;\r\n}else if( safe_isalpha(x[0]) ){\r\nif( psp->nrhs>=MAXRHS ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Too many symbols on RHS of rule beginning at \"%s\".",\r\nx);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_RULE_ERROR;\r\n}else{\r\npsp->rhs[psp->nrhs] = Symbol_new(x);\r\npsp->alias[psp->nrhs] = 0;\r\npsp->nrhs++;\r\n}\r\n}else if( (x[0]=='|' || x[0]=='/') && psp->nrhs>0 ){\r\nstruct symbol *msp = psp->rhs[psp->nrhs-1];\r\nif( msp->type!=MULTITERMINAL ){\r\nstruct symbol *origsp = msp;\r\nmsp = (struct symbol *) calloc(1,sizeof(*msp));\r\nif (msp == NULL) {\r\nfprintf(stderr, "Unable to allocate enough memory for MSP, exiting...\n");\r\nexit(1);\r\n}\r\nmemset(msp, 0, sizeof(*msp));\r\nmsp->type = MULTITERMINAL;\r\nmsp->nsubsym = 1;\r\nmsp->subsym = (struct symbol **) calloc(1,sizeof(struct symbol*));\r\nif (msp->subsym == NULL) {\r\nfprintf(stderr, "Unable to allocate enough memory for MSP->subsym, exiting...\n");\r\nexit(1);\r\n}\r\nmsp->subsym[0] = origsp;\r\nmsp->name = origsp->name;\r\npsp->rhs[psp->nrhs-1] = msp;\r\n}\r\nmsp->nsubsym++;\r\nmsp->subsym = (struct symbol **) realloc(msp->subsym,\r\nsizeof(struct symbol*)*msp->nsubsym);\r\nmsp->subsym[msp->nsubsym-1] = Symbol_new(&x[1]);\r\nif( safe_islower(x[1]) || safe_islower(msp->subsym[0]->name[0]) ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Cannot form a compound containing a non-terminal");\r\npsp->errorcnt++;\r\n}\r\n}else if( x[0]=='(' && psp->nrhs>0 ){\r\npsp->state = RHS_ALIAS_1;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Illegal character on RHS of rule: \"%s\".",x);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_RULE_ERROR;\r\n}\r\nbreak;\r\ncase RHS_ALIAS_1:\r\nif( safe_isalpha(x[0]) ){\r\npsp->alias[psp->nrhs-1] = x;\r\npsp->state = RHS_ALIAS_2;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"\"%s\" is not a valid alias for the RHS symbol \"%s\"\n",\r\nx,psp->rhs[psp->nrhs-1]->name);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_RULE_ERROR;\r\n}\r\nbreak;\r\ncase RHS_ALIAS_2:\r\nif( x[0]==')' ){\r\npsp->state = IN_RHS;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Missing \")\" following LHS alias name \"%s\".",psp->lhsalias);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_RULE_ERROR;\r\n}\r\nbreak;\r\ncase WAITING_FOR_DECL_KEYWORD:\r\nif( safe_isalpha(x[0]) ){\r\npsp->declkeyword = x;\r\npsp->declargslot = 0;\r\npsp->decllinenoslot = 0;\r\npsp->insertLineMacro = 1;\r\npsp->state = WAITING_FOR_DECL_ARG;\r\nif( strcmp(x,"name")==0 ){\r\npsp->declargslot = &(psp->gp->name);\r\npsp->insertLineMacro = 0;\r\n}else if( strcmp(x,"include")==0 ){\r\npsp->declargslot = &(psp->gp->include);\r\n}else if( strcmp(x,"code")==0 ){\r\npsp->declargslot = &(psp->gp->extracode);\r\n}else if( strcmp(x,"token_destructor")==0 ){\r\npsp->declargslot = &psp->gp->tokendest;\r\n}else if( strcmp(x,"default_destructor")==0 ){\r\npsp->declargslot = &psp->gp->vardest;\r\n}else if( strcmp(x,"token_prefix")==0 ){\r\npsp->declargslot = &psp->gp->tokenprefix;\r\npsp->insertLineMacro = 0;\r\n}else if( strcmp(x,"syntax_error")==0 ){\r\npsp->declargslot = &(psp->gp->error);\r\n}else if( strcmp(x,"parse_accept")==0 ){\r\npsp->declargslot = &(psp->gp->accept);\r\n}else if( strcmp(x,"parse_failure")==0 ){\r\npsp->declargslot = &(psp->gp->failure);\r\n}else if( strcmp(x,"stack_overflow")==0 ){\r\npsp->declargslot = &(psp->gp->overflow);\r\n}else if( strcmp(x,"extra_argument")==0 ){\r\npsp->declargslot = &(psp->gp->arg);\r\npsp->insertLineMacro = 0;\r\n}else if( strcmp(x,"token_type")==0 ){\r\npsp->declargslot = &(psp->gp->tokentype);\r\npsp->insertLineMacro = 0;\r\n}else if( strcmp(x,"default_type")==0 ){\r\npsp->declargslot = &(psp->gp->vartype);\r\npsp->insertLineMacro = 0;\r\n}else if( strcmp(x,"stack_size")==0 ){\r\npsp->declargslot = &(psp->gp->stacksize);\r\npsp->insertLineMacro = 0;\r\n}else if( strcmp(x,"start_symbol")==0 ){\r\npsp->declargslot = &(psp->gp->start);\r\npsp->insertLineMacro = 0;\r\n}else if( strcmp(x,"left")==0 ){\r\npsp->preccounter++;\r\npsp->declassoc = LEFT;\r\npsp->state = WAITING_FOR_PRECEDENCE_SYMBOL;\r\n}else if( strcmp(x,"right")==0 ){\r\npsp->preccounter++;\r\npsp->declassoc = RIGHT;\r\npsp->state = WAITING_FOR_PRECEDENCE_SYMBOL;\r\n}else if( strcmp(x,"nonassoc")==0 ){\r\npsp->preccounter++;\r\npsp->declassoc = NONE;\r\npsp->state = WAITING_FOR_PRECEDENCE_SYMBOL;\r\n}else if( strcmp(x,"destructor")==0 ){\r\npsp->state = WAITING_FOR_DESTRUCTOR_SYMBOL;\r\n}else if( strcmp(x,"type")==0 ){\r\npsp->state = WAITING_FOR_DATATYPE_SYMBOL;\r\n}else if( strcmp(x,"fallback")==0 ){\r\npsp->fallback = 0;\r\npsp->state = WAITING_FOR_FALLBACK_ID;\r\n}else if( strcmp(x,"wildcard")==0 ){\r\npsp->state = WAITING_FOR_WILDCARD_ID;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Unknown declaration keyword: \"%%%s\".",x);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_DECL_ERROR;\r\n}\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Illegal declaration keyword: \"%s\".",x);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_DECL_ERROR;\r\n}\r\nbreak;\r\ncase WAITING_FOR_DESTRUCTOR_SYMBOL:\r\nif( !safe_isalpha(x[0]) ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Symbol name missing after %%destructor keyword");\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_DECL_ERROR;\r\n}else{\r\nstruct symbol *sp = Symbol_new(x);\r\npsp->declargslot = &sp->destructor;\r\npsp->decllinenoslot = &sp->destLineno;\r\npsp->insertLineMacro = 1;\r\npsp->state = WAITING_FOR_DECL_ARG;\r\n}\r\nbreak;\r\ncase WAITING_FOR_DATATYPE_SYMBOL:\r\nif( !safe_isalpha(x[0]) ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Symbol name missing after %%destructor keyword");\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_DECL_ERROR;\r\n}else{\r\nstruct symbol *sp = Symbol_new(x);\r\npsp->declargslot = &sp->datatype;\r\npsp->insertLineMacro = 0;\r\npsp->state = WAITING_FOR_DECL_ARG;\r\n}\r\nbreak;\r\ncase WAITING_FOR_PRECEDENCE_SYMBOL:\r\nif( x[0]=='.' ){\r\npsp->state = WAITING_FOR_DECL_OR_RULE;\r\n}else if( safe_isupper(x[0]) ){\r\nstruct symbol *sp;\r\nsp = Symbol_new(x);\r\nif( sp->prec>=0 ){\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Symbol \"%s\" has already be given a precedence.",x);\r\npsp->errorcnt++;\r\n}else{\r\nsp->prec = psp->preccounter;\r\nsp->assoc = psp->declassoc;\r\n}\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Can't assign a precedence to \"%s\".",x);\r\npsp->errorcnt++;\r\n}\r\nbreak;\r\ncase WAITING_FOR_DECL_ARG:\r\nif( (x[0]=='{' || x[0]=='\"' || safe_isalnum(x[0])) ){\r\nconst char *zOld, *zNew;\r\nchar *zBuf, *z;\r\nint nOld, n, nLine, nNew, nBack;\r\nint addLineMacro;\r\nchar zLine[50];\r\nzNew = x;\r\nif( zNew[0]=='"' || zNew[0]=='{' ) zNew++;\r\nnNew = lemonStrlen(zNew);\r\nif( *psp->declargslot ){\r\nzOld = *psp->declargslot;\r\n}else{\r\nzOld = "";\r\n}\r\nnOld = lemonStrlen(zOld);\r\nn = nOld + nNew + 20;\r\naddLineMacro = psp->insertLineMacro &&\r\n(psp->decllinenoslot==0 || psp->decllinenoslot[0]!=0);\r\nif( addLineMacro ){\r\nfor(z=psp->filename, nBack=0; *z; z++){\r\nif( *z=='\\' ) nBack++;\r\n}\r\nsprintf(zLine, "#line %d ", psp->tokenlineno);\r\nnLine = lemonStrlen(zLine);\r\nn += nLine + lemonStrlen(psp->filename) + nBack;\r\n}\r\n*psp->declargslot = (char *) realloc(*psp->declargslot, n);\r\nzBuf = *psp->declargslot + nOld;\r\nif( addLineMacro ){\r\nif( nOld && zBuf[-1]!='\n' ){\r\n*(zBuf++) = '\n';\r\n}\r\nmemcpy(zBuf, zLine, nLine);\r\nzBuf += nLine;\r\n*(zBuf++) = '"';\r\nfor(z=psp->filename; *z; z++){\r\nif( *z=='\\' ){\r\n*(zBuf++) = '\\';\r\n}\r\n*(zBuf++) = *z;\r\n}\r\n*(zBuf++) = '"';\r\n*(zBuf++) = '\n';\r\n}\r\nif( psp->decllinenoslot && psp->decllinenoslot[0]==0 ){\r\npsp->decllinenoslot[0] = psp->tokenlineno;\r\n}\r\nmemcpy(zBuf, zNew, nNew);\r\nzBuf += nNew;\r\n*zBuf = 0;\r\npsp->state = WAITING_FOR_DECL_OR_RULE;\r\n}else{\r\nErrorMsg(psp->filename,psp->tokenlineno,\r\n"Illegal argument to %%%s: %s",psp->declkeyword,x);\r\npsp->errorcnt++;\r\npsp->state = RESYNC_AFTER_DECL_ERROR;\r\n}\r\nbreak;\r\ncase WAITING_FOR_FALLBACK_ID:\r\nif( x[0]=='.' ){\r\npsp->state = WAITING_FOR_DECL_OR_RULE;\r\n}else if( !safe_isupper(x[0]) ){\r\nErrorMsg(psp->filename, psp->tokenlineno,\r\n"%%fallback argument \"%s\" should be a token", x);\r\npsp->errorcnt++;\r\n}else{\r\nstruct symbol *sp = Symbol_new(x);\r\nif( psp->fallback==0 ){\r\npsp->fallback = sp;\r\n}else if( sp->fallback ){\r\nErrorMsg(psp->filename, psp->tokenlineno,\r\n"More than one fallback assigned to token %s", x);\r\npsp->errorcnt++;\r\n}else{\r\nsp->fallback = psp->fallback;\r\npsp->gp->has_fallback = 1;\r\n}\r\n}\r\nbreak;\r\ncase WAITING_FOR_WILDCARD_ID:\r\nif( x[0]=='.' ){\r\npsp->state = WAITING_FOR_DECL_OR_RULE;\r\n}else if( !isupper(x[0]) ){\r\nErrorMsg(psp->filename, psp->tokenlineno,\r\n"%%wildcard argument \"%s\" should be a token", x);\r\npsp->errorcnt++;\r\n}else{\r\nstruct symbol *sp = Symbol_new(x);\r\nif( psp->gp->wildcard==0 ){\r\npsp->gp->wildcard = sp;\r\n}else{\r\nErrorMsg(psp->filename, psp->tokenlineno,\r\n"Extra wildcard to token: %s", x);\r\npsp->errorcnt++;\r\n}\r\n}\r\nbreak;\r\ncase RESYNC_AFTER_RULE_ERROR:\r\ncase RESYNC_AFTER_DECL_ERROR:\r\nif( x[0]=='.' ) psp->state = WAITING_FOR_DECL_OR_RULE;\r\nif( x[0]=='%' ) psp->state = WAITING_FOR_DECL_KEYWORD;\r\nbreak;\r\n}\r\n}\r\nstatic void preprocess_input(char *z){\r\nint i, j, k, n;\r\nint exclude = 0;\r\nint start = 0;\r\nint lineno = 1;\r\nint start_lineno = 1;\r\nfor(i=0; z[i]; i++){\r\nif( z[i]=='\n' ) lineno++;\r\nif( z[i]!='%' || (i>0 && z[i-1]!='\n') ) continue;\r\nif( strncmp(&z[i],"%endif",6)==0 && safe_isspace(z[i+6]) ){\r\nif( exclude ){\r\nexclude--;\r\nif( exclude==0 ){\r\nfor(j=start; j<i; j++) if( z[j]!='\n' ) z[j] = ' ';\r\n}\r\n}\r\nfor(j=i; z[j] && z[j]!='\n'; j++) z[j] = ' ';\r\n}else if( (strncmp(&z[i],"%ifdef",6)==0 && safe_isspace(z[i+6]))\r\n|| (strncmp(&z[i],"%ifndef",7)==0 && safe_isspace(z[i+7])) ){\r\nif( exclude ){\r\nexclude++;\r\n}else{\r\nfor(j=i+7; safe_isspace(z[j]); j++){}\r\nfor(n=0; z[j+n] && !safe_isspace(z[j+n]); n++){}\r\nexclude = 1;\r\nfor(k=0; k<nDefine; k++){\r\nif( strncmp(azDefine[k],&z[j],n)==0 && lemonStrlen(azDefine[k])==n ){\r\nexclude = 0;\r\nbreak;\r\n}\r\n}\r\nif( z[i+3]=='n' ) exclude = !exclude;\r\nif( exclude ){\r\nstart = i;\r\nstart_lineno = lineno;\r\n}\r\n}\r\nfor(j=i; z[j] && z[j]!='\n'; j++) z[j] = ' ';\r\n}\r\n}\r\nif( exclude ){\r\nfprintf(stderr,"unterminated %%ifdef starting on line %d\n", start_lineno);\r\nexit(1);\r\n}\r\n}\r\nvoid Parse(struct lemon *gp)\r\n{\r\nstruct pstate ps;\r\nFILE *fp;\r\nchar *filebuf;\r\nlong filesize;\r\nint lineno;\r\nchar c;\r\nchar *cp, *nextcp;\r\nint startline = 0;\r\nmemset(&ps, '\0', sizeof(ps));\r\nps.gp = gp;\r\nps.filename = gp->filename;\r\nps.errorcnt = 0;\r\nps.state = INITIALIZE;\r\nps.prevrule = NULL;\r\nps.preccounter = 0;\r\nps.lastrule = NULL;\r\nps.firstrule = NULL;\r\nps.lhs = NULL;\r\nps.nrhs = 0;\r\nps.lhsalias = NULL;\r\nps.declkeyword = NULL;\r\nps.declargslot = NULL;\r\nps.declassoc = UNK;\r\nps.fallback = NULL;\r\nfp = fopen(ps.filename,"rb");\r\nif( fp==0 ){\r\nErrorMsg(ps.filename,0,"Can't open this file for reading.");\r\ngp->errorcnt++;\r\nreturn;\r\n}\r\nif ( fseek(fp,0,SEEK_END)!=0 || (filesize = ftell(fp))<0 ) {\r\nErrorMsg(ps.filename,0,"Can't determine the file size.");\r\ngp->errorcnt++;\r\nfclose(fp);\r\nreturn;\r\n}\r\nrewind(fp);\r\nfilebuf = (char *)malloc( filesize+1 );\r\nif( filebuf==0 ){\r\nErrorMsg(ps.filename,0,"Can't allocate %ld of memory to hold this file.",\r\nfilesize+1);\r\nfclose(fp);\r\ngp->errorcnt++;\r\nreturn;\r\n}\r\nif( fread(filebuf,1,(size_t)filesize,fp)!=(size_t)filesize ){\r\nErrorMsg(ps.filename,0,"Can't read in all %ld bytes of this file.",\r\nfilesize);\r\nfree(filebuf);\r\nfclose(fp);\r\ngp->errorcnt++;\r\nreturn;\r\n}\r\nfclose(fp);\r\nfilebuf[filesize] = 0;\r\npreprocess_input(filebuf);\r\nlineno = 1;\r\nfor(cp=filebuf; (c= *cp)!=0; ){\r\nif( c=='\n' ) lineno++;\r\nif( safe_isspace(c) ){ cp++; continue; }\r\nif( c=='/' && cp[1]=='/' ){\r\ncp+=2;\r\nwhile( (c= *cp)!=0 && c!='\n' ) cp++;\r\ncontinue;\r\n}\r\nif( c=='/' && cp[1]=='*' ){\r\ncp+=2;\r\nwhile( (c= *cp)!=0 && (c!='/' || cp[-1]!='*') ){\r\nif( c=='\n' ) lineno++;\r\ncp++;\r\n}\r\nif( c ) cp++;\r\ncontinue;\r\n}\r\nps.tokenstart = cp;\r\nps.tokenlineno = lineno;\r\nif( c=='\"' ){\r\ncp++;\r\nwhile( (c= *cp)!=0 && c!='\"' ){\r\nif( c=='\n' ) lineno++;\r\ncp++;\r\n}\r\nif( c==0 ){\r\nErrorMsg(ps.filename,startline,\r\n"String starting on this line is not terminated before the end of the file.");\r\nps.errorcnt++;\r\nnextcp = cp;\r\n}else{\r\nnextcp = cp+1;\r\n}\r\n}else if( c=='{' ){\r\nint level;\r\ncp++;\r\nfor(level=1; (c= *cp)!=0 && (level>1 || c!='}'); cp++){\r\nif( c=='\n' ) lineno++;\r\nelse if( c=='{' ) level++;\r\nelse if( c=='}' ) level--;\r\nelse if( c=='/' && cp[1]=='*' ){\r\nchar prevc;\r\ncp = &cp[2];\r\nprevc = 0;\r\nwhile( (c= *cp)!=0 && (c!='/' || prevc!='*') ){\r\nif( c=='\n' ) lineno++;\r\nprevc = c;\r\ncp++;\r\n}\r\n}else if( c=='/' && cp[1]=='/' ){\r\ncp = &cp[2];\r\nwhile( (c= *cp)!=0 && c!='\n' ) cp++;\r\nif( c ) lineno++;\r\n}else if( c=='\'' || c=='\"' ){\r\nchar startchar, prevc;\r\nstartchar = c;\r\nprevc = 0;\r\nfor(cp++; (c= *cp)!=0 && (c!=startchar || prevc=='\\'); cp++){\r\nif( c=='\n' ) lineno++;\r\nif( prevc=='\\' ) prevc = 0;\r\nelse prevc = c;\r\n}\r\n}\r\n}\r\nif( c==0 ){\r\nErrorMsg(ps.filename,ps.tokenlineno,\r\n"C code starting on this line is not terminated before the end of the file.");\r\nps.errorcnt++;\r\nnextcp = cp;\r\n}else{\r\nnextcp = cp+1;\r\n}\r\n}else if( safe_isalnum(c) ){\r\nwhile( (c= *cp)!=0 && (safe_isalnum(c) || c=='_') ) cp++;\r\nnextcp = cp;\r\n}else if( c==':' && cp[1]==':' && cp[2]=='=' ){\r\ncp += 3;\r\nnextcp = cp;\r\n}else if( (c=='/' || c=='|') && safe_isalpha(cp[1]) ){\r\ncp += 2;\r\nwhile( (c = *cp)!=0 && (safe_isalnum(c) || c=='_') ) cp++;\r\nnextcp = cp;\r\n}else{\r\ncp++;\r\nnextcp = cp;\r\n}\r\nc = *cp;\r\n*cp = 0;\r\nparseonetoken(&ps);\r\n*cp = c;\r\ncp = nextcp;\r\n}\r\nfree(filebuf);\r\ngp->rule = ps.firstrule;\r\ngp->errorcnt = ps.errorcnt;\r\n}\r\nstruct plink *Plink_new(void){\r\nstruct plink *newlink;\r\nif( plink_freelist==0 ){\r\nint i;\r\nint amt = 100;\r\nplink_freelist = (struct plink *)calloc( amt, sizeof(struct plink) );\r\nif( plink_freelist==NULL ){\r\nfprintf(stderr,\r\n"Unable to allocate memory for a new follow-set propagation link.\n");\r\nexit(1);\r\n}\r\nfor(i=0; i<amt-1; i++) plink_freelist[i].next = &plink_freelist[i+1];\r\nplink_freelist[amt-1].next = 0;\r\n}\r\nnewlink = plink_freelist;\r\nplink_freelist = plink_freelist->next;\r\nreturn newlink;\r\n}\r\nvoid Plink_add(struct plink **plpp, struct config *cfp)\r\n{\r\nstruct plink *newlink;\r\nnewlink = Plink_new();\r\nnewlink->next = *plpp;\r\n*plpp = newlink;\r\nnewlink->cfp = cfp;\r\n}\r\nvoid Plink_copy(struct plink **to, struct plink *from)\r\n{\r\nstruct plink *nextpl;\r\nwhile( from ){\r\nnextpl = from->next;\r\nfrom->next = *to;\r\n*to = from;\r\nfrom = nextpl;\r\n}\r\n}\r\nvoid Plink_delete(struct plink *plp)\r\n{\r\nstruct plink *nextpl;\r\nwhile( plp ){\r\nnextpl = plp->next;\r\nplp->next = plink_freelist;\r\nplink_freelist = plp;\r\nplp = nextpl;\r\n}\r\n}\r\nPRIVATE char *file_makename(char *pattern, const char *suffix)\r\n{\r\nchar *name;\r\nchar *cp;\r\nname = (char*)malloc( lemonStrlen(pattern) + strlen(suffix) + 5 );\r\nif( name==0 ){\r\nfprintf(stderr,"Can't allocate space for a filename.\n");\r\nexit(1);\r\n}\r\nstrcpy(name,pattern);\r\ncp = strrchr(name,'.');\r\nif( cp ) *cp = 0;\r\nstrcat(name,suffix);\r\nreturn name;\r\n}\r\nPRIVATE char *file_makename_using_basename(struct lemon *lemp, const char *suffix)\r\n{\r\nreturn file_makename(lemp->basename, suffix);\r\n}\r\nPRIVATE FILE *file_open(struct lemon *lemp, const char *suffix, const char *mode)\r\n{\r\nFILE *fp;\r\nchar *name;\r\nif( lemp->outname ) free(lemp->outname);\r\nname = file_makename_using_basename(lemp, suffix);\r\nif ( lemp->outdirname != NULL ) {\r\nlemp->outname = (char*)malloc( strlen(lemp->outdirname) + strlen(name) + 2);\r\nif ( lemp->outname == 0 ) {\r\nfprintf(stderr, "Can't allocate space for dir/filename");\r\nexit(1);\r\n}\r\nstrcpy(lemp->outname, lemp->outdirname);\r\n#ifdef __WIN32__\r\nstrcat(lemp->outname, "\\");\r\n#else\r\nstrcat(lemp->outname, "/");\r\n#endif\r\nstrcat(lemp->outname, name);\r\nfree(name);\r\n}\r\nelse {\r\nlemp->outname = name;\r\n}\r\nfp = fopen(lemp->outname,mode);\r\nif( fp==0 && *mode=='w' ){\r\nfprintf(stderr,"Can't open file \"%s\".\n",lemp->outname);\r\nlemp->errorcnt++;\r\nreturn 0;\r\n}\r\nreturn fp;\r\n}\r\nvoid Reprint(struct lemon *lemp)\r\n{\r\nstruct rule *rp;\r\nstruct symbol *sp;\r\nint i, j, maxlen, len, ncolumns, skip;\r\nprintf("// Reprint of input file \"%s\".\n// Symbols:\n",lemp->filename);\r\nmaxlen = 10;\r\nfor(i=0; i<lemp->nsymbol; i++){\r\nsp = lemp->symbols[i];\r\nlen = lemonStrlen(sp->name);\r\nif( len>maxlen ) maxlen = len;\r\n}\r\nncolumns = 76/(maxlen+5);\r\nif( ncolumns<1 ) ncolumns = 1;\r\nskip = (lemp->nsymbol + ncolumns - 1)/ncolumns;\r\nfor(i=0; i<skip; i++){\r\nprintf("//");\r\nfor(j=i; j<lemp->nsymbol; j+=skip){\r\nsp = lemp->symbols[j];\r\nassert( sp->index==j );\r\nprintf(" %3d %-*.*s",j,maxlen,maxlen,sp->name);\r\n}\r\nprintf("\n");\r\n}\r\nfor(rp=lemp->rule; rp; rp=rp->next){\r\nprintf("%s",rp->lhs->name);\r\nprintf(" ::=");\r\nfor(i=0; i<rp->nrhs; i++){\r\nsp = rp->rhs[i];\r\nprintf(" %s", sp->name);\r\nif( sp->type==MULTITERMINAL ){\r\nfor(j=1; j<sp->nsubsym; j++){\r\nprintf("|%s", sp->subsym[j]->name);\r\n}\r\n}\r\n}\r\nprintf(".");\r\nif( rp->precsym ) printf(" [%s]",rp->precsym->name);\r\nprintf("\n");\r\n}\r\n}\r\nPRIVATE void ConfigPrint(FILE *fp, struct config *cfp)\r\n{\r\nstruct rule *rp;\r\nstruct symbol *sp;\r\nint i, j;\r\nrp = cfp->rp;\r\nfprintf(fp,"%s ::=",rp->lhs->name);\r\nfor(i=0; i<=rp->nrhs; i++){\r\nif( i==cfp->dot ) fprintf(fp," *");\r\nif( i==rp->nrhs ) break;\r\nsp = rp->rhs[i];\r\nfprintf(fp," %s", sp->name);\r\nif( sp->type==MULTITERMINAL ){\r\nfor(j=1; j<sp->nsubsym; j++){\r\nfprintf(fp,"|%s",sp->subsym[j]->name);\r\n}\r\n}\r\n}\r\n}\r\nPRIVATE int PrintAction(struct action *ap, FILE *fp, int indent){\r\nint result = 1;\r\nswitch( ap->type ){\r\ncase SHIFT:\r\nfprintf(fp,"%*s shift %d",indent,ap->sp->name,ap->x.stp->statenum);\r\nbreak;\r\ncase REDUCE:\r\nfprintf(fp,"%*s reduce %d",indent,ap->sp->name,ap->x.rp->index);\r\nbreak;\r\ncase ACCEPT:\r\nfprintf(fp,"%*s accept",indent,ap->sp->name);\r\nbreak;\r\ncase ERROR:\r\nfprintf(fp,"%*s error",indent,ap->sp->name);\r\nbreak;\r\ncase SRCONFLICT:\r\ncase RRCONFLICT:\r\nfprintf(fp,"%*s reduce %-3d ** Parsing conflict **",\r\nindent,ap->sp->name,ap->x.rp->index);\r\nbreak;\r\ncase SSCONFLICT:\r\nfprintf(fp,"%*s shift %d ** Parsing conflict **",\r\nindent,ap->sp->name,ap->x.stp->statenum);\r\nbreak;\r\ncase SH_RESOLVED:\r\ncase RD_RESOLVED:\r\ncase NOT_USED:\r\nresult = 0;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nvoid ReportOutput(struct lemon *lemp)\r\n{\r\nint i;\r\nstruct state *stp;\r\nstruct config *cfp;\r\nstruct action *ap;\r\nFILE *fp;\r\nfp = file_open(lemp,".out","wb");\r\nif( fp==0 ) return;\r\nfor(i=0; i<lemp->nstate; i++){\r\nstp = lemp->sorted[i];\r\nfprintf(fp,"State %d:\n",stp->statenum);\r\nif( lemp->basisflag ) cfp=stp->bp;\r\nelse cfp=stp->cfp;\r\nwhile( cfp ){\r\nchar buf[20];\r\nif( cfp->dot==cfp->rp->nrhs ){\r\nsprintf(buf,"(%d)",cfp->rp->index);\r\nfprintf(fp," %5s ",buf);\r\n}else{\r\nfprintf(fp," ");\r\n}\r\nConfigPrint(fp,cfp);\r\nfprintf(fp,"\n");\r\n#if 0\r\nSetPrint(fp,cfp->fws,lemp);\r\nPlinkPrint(fp,cfp->fplp,"To ");\r\nPlinkPrint(fp,cfp->bplp,"From");\r\n#endif\r\nif( lemp->basisflag ) cfp=cfp->bp;\r\nelse cfp=cfp->next;\r\n}\r\nfprintf(fp,"\n");\r\nfor(ap=stp->ap; ap; ap=ap->next){\r\nif( PrintAction(ap,fp,30) ) fprintf(fp,"\n");\r\n}\r\nfprintf(fp,"\n");\r\n}\r\nfprintf(fp, "----------------------------------------------------\n");\r\nfprintf(fp, "Symbols:\n");\r\nfor(i=0; i<lemp->nsymbol; i++){\r\nint j;\r\nstruct symbol *sp;\r\nsp = lemp->symbols[i];\r\nfprintf(fp, " %3d: %s", i, sp->name);\r\nif( sp->type==NONTERMINAL ){\r\nfprintf(fp, ":");\r\nif( sp->lambda ){\r\nfprintf(fp, " <lambda>");\r\n}\r\nfor(j=0; j<lemp->nterminal; j++){\r\nif( sp->firstset && SetFind(sp->firstset, j) ){\r\nfprintf(fp, " %s", lemp->symbols[j]->name);\r\n}\r\n}\r\n}\r\nfprintf(fp, "\n");\r\n}\r\nfclose(fp);\r\nreturn;\r\n}\r\nPRIVATE char *pathsearch(char *argv0, char *name, int modemask)\r\n{\r\nconst char *pathlist,*cp;\r\nchar *path;\r\n#ifdef __WIN32__\r\ncp = strrchr(argv0,'\\');\r\n#else\r\ncp = strrchr(argv0,'/');\r\n#endif\r\nif( cp ){\r\npath = (char *)malloc( (cp - argv0) + lemonStrlen(name) + 2 );\r\nif( path ) sprintf(path,"%.*s/%s",(int)(cp - argv0),argv0,name);\r\n}else{\r\npathlist = getenv("PATH");\r\nif( pathlist==0 ) pathlist = ".:/bin:/usr/bin";\r\npath = (char *)malloc( lemonStrlen(pathlist)+strlen(name)+2 );\r\nif( path!=0 ){\r\nwhile( *pathlist ){\r\ncp = strchr(pathlist,':');\r\nif( cp==0 ) cp = &pathlist[strlen(pathlist)];\r\nsprintf(path,"%.*s/%s",(int)(cp - pathlist),pathlist,name);\r\nif( *cp==0 ) pathlist = "";\r\nelse pathlist = &cp[1];\r\nif( access(path,modemask)==0 ) break;\r\n}\r\n}\r\n}\r\nreturn path;\r\n}\r\nPRIVATE int compute_action(struct lemon *lemp, struct action *ap)\r\n{\r\nint act;\r\nswitch( ap->type ){\r\ncase SHIFT: act = ap->x.stp->statenum; break;\r\ncase REDUCE: act = ap->x.rp->index + lemp->nstate; break;\r\ncase ERROR: act = lemp->nstate + lemp->nrule; break;\r\ncase ACCEPT: act = lemp->nstate + lemp->nrule + 1; break;\r\ndefault: act = -1; break;\r\n}\r\nreturn act;\r\n}\r\nPRIVATE void tplt_xfer(const char *name, FILE *in, FILE *out, int *lineno)\r\n{\r\nint i, iStart;\r\nchar line[LINESIZE];\r\nwhile( fgets(line,LINESIZE,in) && (line[0]!='%' || line[1]!='%') ){\r\n(*lineno)++;\r\niStart = 0;\r\nif( name ){\r\nfor(i=0; i<LINESIZE && line[i]; i++){\r\nif( line[i]=='P' && i<(LINESIZE-5) && strncmp(&line[i],"Parse",5)==0\r\n&& (i==0 || !safe_isalpha(line[i-1]))\r\n){\r\nif( i>iStart ) fprintf(out,"%.*s",i-iStart,&line[iStart]);\r\nfprintf(out,"%s",name);\r\ni += 4;\r\niStart = i+1;\r\n}\r\n}\r\n}\r\nfprintf(out,"%s",&line[iStart]);\r\n}\r\n}\r\nPRIVATE FILE *tplt_open(struct lemon *lemp)\r\n{\r\nstatic char templatename[] = "lempar.c";\r\nchar buf[1000];\r\nFILE *in;\r\nchar *tpltname = NULL;\r\nchar *cp;\r\nif (lemp->templatename) {\r\ntpltname = strdup(lemp->templatename);\r\n} else {\r\ncp = strrchr(lemp->filename,'.');\r\nif( cp ){\r\nsprintf(buf,"%.*s.lt",(int)(cp - lemp->filename),lemp->filename);\r\n}else{\r\nsprintf(buf,"%s.lt",lemp->filename);\r\n}\r\nif( access(buf,004)==0 ){\r\ntpltname = buf;\r\n}else if( access(templatename,004)==0 ){\r\ntpltname = templatename;\r\n}else{\r\ntpltname = pathsearch(lemp->argv0,templatename,0);\r\n}\r\n}\r\nif( tpltname==NULL ){\r\nfprintf(stderr,"Can't find the parser driver template file \"%s\".\n",\r\ntemplatename);\r\nlemp->errorcnt++;\r\nreturn NULL;\r\n}\r\nin = fopen(tpltname,"rb");\r\nif( tpltname != buf )\r\nfree(tpltname);\r\nif( in==0 ){\r\nfprintf(stderr,"Can't open the template file \"%s\".\n",templatename);\r\nlemp->errorcnt++;\r\nreturn NULL;\r\n}\r\nreturn in;\r\n}\r\nPRIVATE void tplt_linedir(FILE *out, int lineno, char *filename)\r\n{\r\nfprintf(out,"#line %d \"",lineno);\r\nwhile( *filename ){\r\nif( *filename == '\\' ) putc('\\',out);\r\nputc(*filename,out);\r\nfilename++;\r\n}\r\nfprintf(out,"\"\n");\r\n}\r\nPRIVATE void tplt_print(FILE *out, struct lemon *lemp, char *str,\r\nint *lineno)\r\n{\r\nif( str==0 ) return;\r\n(*lineno)++;\r\nwhile( *str ){\r\nif( *str=='\n' ) (*lineno)++;\r\nputc(*str,out);\r\nstr++;\r\n}\r\nif( str[-1]!='\n' ){\r\nputc('\n',out);\r\n(*lineno)++;\r\n}\r\ntplt_linedir(out,*lineno+2,lemp->outname);\r\n(*lineno)+=2;\r\nreturn;\r\n}\r\nPRIVATE void emit_destructor_code(FILE *out, struct symbol *sp, struct lemon *lemp,\r\nint *lineno)\r\n{\r\nchar *cp = 0;\r\nint linecnt = 0;\r\nif( sp->type==TERMINAL ){\r\ncp = lemp->tokendest;\r\nif( cp==0 ) return;\r\nfprintf(out,"{\n"); (*lineno)++;\r\n}else if( sp->destructor ){\r\ncp = sp->destructor;\r\nfprintf(out,"{\n"); (*lineno)++;\r\ntplt_linedir(out,sp->destLineno,lemp->outname); (*lineno)++;\r\n}else if( lemp->vardest ){\r\ncp = lemp->vardest;\r\nif( cp==0 ) return;\r\nfprintf(out,"{\n"); (*lineno)++;\r\n}else{\r\nassert( 0 );\r\n}\r\nfor(; *cp; cp++){\r\nif( *cp=='$' && cp[1]=='$' ){\r\nfprintf(out,"(yypminor->yy%d)",sp->dtnum);\r\ncp++;\r\ncontinue;\r\n}\r\nif( *cp=='\n' ) linecnt++;\r\nfputc(*cp,out);\r\n}\r\n(*lineno) += 3 + linecnt;\r\nfprintf(out,"\n");\r\ntplt_linedir(out,*lineno,lemp->outname);\r\nfprintf(out,"}\n");\r\nreturn;\r\n}\r\nPRIVATE int has_destructor(struct symbol *sp, struct lemon *lemp)\r\n{\r\nint ret;\r\nif( sp->type==TERMINAL ){\r\nret = lemp->tokendest!=0;\r\n}else{\r\nret = lemp->vardest!=0 || sp->destructor!=0;\r\n}\r\nreturn ret;\r\n}\r\nPRIVATE char *append_str(const char *zText, int n, int p1, int p2){\r\nsize_t zTextLen;\r\nstatic char *z = 0;\r\nstatic size_t alloced = 0;\r\nstatic int used = 0;\r\nint c;\r\nchar zInt[40];\r\nif( zText==0 ){\r\nused = 0;\r\nreturn z;\r\n}\r\nif( n<=0 ){\r\nif( n<0 ){\r\nused += n;\r\nassert( used>=0 );\r\n}\r\nzTextLen = lemonStrlen(zText);\r\n} else\r\nzTextLen = n;\r\nif( zTextLen+sizeof(zInt)*2+used >= alloced ){\r\nalloced = zTextLen + sizeof(zInt)*2 + used + 200;\r\nz = (char *) realloc(z, alloced);\r\n}\r\nif( z==0 ) return NULL;\r\nwhile( zTextLen-- != 0 ){\r\nc = *(zText++);\r\nif( c=='%' && zTextLen!=0 && zText[0]=='d' ){\r\nsprintf(zInt, "%d", p1);\r\np1 = p2;\r\nstrcpy(&z[used], zInt);\r\nused += lemonStrlen(&z[used]);\r\nzText++;\r\nzTextLen--;\r\n}else{\r\nz[used++] = c;\r\n}\r\n}\r\nz[used] = 0;\r\nreturn z;\r\n}\r\nPRIVATE void translate_code(struct lemon *lemp, struct rule *rp){\r\nchar *cp, *xp;\r\nint i;\r\nchar lhsused = 0;\r\nchar used[MAXRHS];\r\nfor(i=0; i<rp->nrhs; i++) used[i] = 0;\r\nlhsused = 0;\r\nif (!rp->code) {\r\nstatic char newlinestr[2] = { '\n', '\0' };\r\nrp->code = newlinestr;\r\nrp->line = rp->ruleline;\r\n}\r\nappend_str(0,0,0,0);\r\nfor(cp=(char *)rp->code; *cp; cp++){\r\nif( safe_isalpha(*cp) && (cp==rp->code || (!safe_isalnum(cp[-1]) && cp[-1]!='_')) ){\r\nchar saved;\r\nfor(xp= &cp[1]; safe_isalnum(*xp) || *xp=='_'; xp++);\r\nsaved = *xp;\r\n*xp = 0;\r\nif( rp->lhsalias && strcmp(cp,rp->lhsalias)==0 ){\r\nappend_str("yygotominor.yy%d",0,rp->lhs->dtnum,0);\r\ncp = xp;\r\nlhsused = 1;\r\n}else{\r\nfor(i=0; i<rp->nrhs; i++){\r\nif( rp->rhsalias[i] && strcmp(cp,rp->rhsalias[i])==0 ){\r\nif( cp!=rp->code && cp[-1]=='@' ){\r\nappend_str("yymsp[%d].major",-1,i-rp->nrhs+1,0);\r\n}else{\r\nstruct symbol *sp = rp->rhs[i];\r\nint dtnum;\r\nif( sp->type==MULTITERMINAL ){\r\ndtnum = sp->subsym[0]->dtnum;\r\n}else{\r\ndtnum = sp->dtnum;\r\n}\r\nappend_str("yymsp[%d].minor.yy%d",0,i-rp->nrhs+1, dtnum);\r\n}\r\ncp = xp;\r\nused[i] = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\n*xp = saved;\r\n}\r\nappend_str(cp, 1, 0, 0);\r\n}\r\nif( rp->lhsalias && !lhsused ){\r\nErrorMsg(lemp->filename,rp->ruleline,\r\n"Label \"%s\" for \"%s(%s)\" is never used.",\r\nrp->lhsalias,rp->lhs->name,rp->lhsalias);\r\nlemp->errorcnt++;\r\n}\r\nfor(i=0; i<rp->nrhs; i++){\r\nif( rp->rhsalias[i] && !used[i] ){\r\nErrorMsg(lemp->filename,rp->ruleline,\r\n"Label %s for \"%s(%s)\" is never used.",\r\nrp->rhsalias[i],rp->rhs[i]->name,rp->rhsalias[i]);\r\nlemp->errorcnt++;\r\n}else if( rp->rhsalias[i]==0 ){\r\nif( has_destructor(rp->rhs[i],lemp) ){\r\nappend_str(" yy_destructor(yypParser,%d,&yymsp[%d].minor);\n", 0,\r\nrp->rhs[i]->index,i-rp->nrhs+1);\r\n}else{\r\n}\r\n}\r\n}\r\ncp = append_str(0,0,0,0);\r\nrp->code = Strsafe(cp?cp:"");\r\n}\r\nPRIVATE void emit_code(FILE *out, struct rule *rp, struct lemon *lemp,\r\nint *lineno)\r\n{\r\nconst char *cp;\r\nint linecnt = 0;\r\nif( rp->code ){\r\ntplt_linedir(out,rp->line,lemp->filename);\r\nfprintf(out,"{%s",rp->code);\r\nfor(cp=rp->code; *cp; cp++){\r\nif( *cp=='\n' ) linecnt++;\r\n}\r\n(*lineno) += 3 + linecnt;\r\nfprintf(out,"}\n");\r\ntplt_linedir(out,*lineno,lemp->outname);\r\n}\r\nreturn;\r\n}\r\nPRIVATE void print_stack_union(\r\nFILE *out,\r\nstruct lemon *lemp,\r\nint *plineno,\r\nint mhflag)\r\n{\r\nint lineno;\r\nchar **types;\r\nint arraysize;\r\nint maxdtlength;\r\nchar *stddt;\r\nint i,j;\r\nint hash;\r\nconst char *name;\r\narraysize = lemp->nsymbol * 2;\r\ntypes = (char**)calloc( arraysize, sizeof(char*) );\r\nif (types == NULL) {\r\nfprintf(stderr, "Unable to allocate enough memory for types\n");\r\nexit(1);\r\n}\r\nfor(i=0; i<arraysize; i++) types[i] = 0;\r\nmaxdtlength = 0;\r\nif( lemp->vartype ){\r\nmaxdtlength = lemonStrlen(lemp->vartype);\r\n}\r\nfor(i=0; i<lemp->nsymbol; i++){\r\nint len;\r\nstruct symbol *sp = lemp->symbols[i];\r\nif( sp->datatype==0 ) continue;\r\nlen = lemonStrlen(sp->datatype);\r\nif( len>maxdtlength ) maxdtlength = len;\r\n}\r\nstddt = (char*)malloc( maxdtlength*2 + 1 );\r\nif( types==0 || stddt==0 ){\r\nfprintf(stderr,"Out of memory.\n");\r\nexit(1);\r\n}\r\nfor(i=0; i<lemp->nsymbol; i++){\r\nstruct symbol *sp = lemp->symbols[i];\r\nchar *cp;\r\nif( sp==lemp->errsym ){\r\nsp->dtnum = arraysize+1;\r\ncontinue;\r\n}\r\nif( sp->type!=NONTERMINAL || (sp->datatype==0 && lemp->vartype==0) ){\r\nsp->dtnum = 0;\r\ncontinue;\r\n}\r\ncp = sp->datatype;\r\nif( cp==0 ) cp = lemp->vartype;\r\nj = 0;\r\nwhile( safe_isspace(*cp) ) cp++;\r\nwhile( *cp ) stddt[j++] = *cp++;\r\nwhile( j>0 && safe_isspace(stddt[j-1]) ) j--;\r\nstddt[j] = 0;\r\nif( strcmp(stddt, lemp->tokentype)==0 ){\r\nsp->dtnum = 0;\r\ncontinue;\r\n}\r\nhash = 0;\r\nfor(j=0; stddt[j]; j++){\r\nhash = hash*53 + stddt[j];\r\n}\r\nhash = (hash & 0x7fffffff)%arraysize;\r\nwhile( types[hash] ){\r\nif( strcmp(types[hash],stddt)==0 ){\r\nsp->dtnum = hash + 1;\r\nbreak;\r\n}\r\nhash++;\r\nif( hash>=arraysize ) hash = 0;\r\n}\r\nif( types[hash]==0 ){\r\nsp->dtnum = hash + 1;\r\ntypes[hash] = (char*)malloc( lemonStrlen(stddt)+1 );\r\nif( types[hash]==0 ){\r\nfprintf(stderr,"Out of memory.\n");\r\nexit(1);\r\n}\r\nstrcpy(types[hash],stddt);\r\n}\r\n}\r\nname = lemp->name ? lemp->name : "Parse";\r\nlineno = *plineno;\r\nif( mhflag ){ fprintf(out,"#if INTERFACE\n"); lineno++; }\r\nfprintf(out,"#define %sTOKENTYPE %s\n",name,\r\nlemp->tokentype?lemp->tokentype:"void*"); lineno++;\r\nif( mhflag ){ fprintf(out,"#endif\n"); lineno++; }\r\nfprintf(out,"typedef union {\n"); lineno++;\r\nfprintf(out," %sTOKENTYPE yy0;\n",name); lineno++;\r\nfor(i=0; i<arraysize; i++){\r\nif( types[i]==0 ) continue;\r\nfprintf(out," %s yy%d;\n",types[i],i+1); lineno++;\r\nfree(types[i]);\r\n}\r\nif( lemp->errsym->useCnt ){\r\nfprintf(out," int yy%d;\n",lemp->errsym->dtnum); lineno++;\r\n}\r\nfree(stddt);\r\nfree(types);\r\nfprintf(out,"} YYMINORTYPE;\n"); lineno++;\r\n*plineno = lineno;\r\n}\r\nstatic const char *minimum_size_type(int lwr, int upr){\r\nif( lwr>=0 ){\r\nif( upr<=255 ){\r\nreturn "unsigned char";\r\n}else if( upr<65535 ){\r\nreturn "unsigned short int";\r\n}else{\r\nreturn "unsigned int";\r\n}\r\n}else if( lwr>=-127 && upr<=127 ){\r\nreturn "signed char";\r\n}else if( lwr>=-32767 && upr<32767 ){\r\nreturn "short";\r\n}else{\r\nreturn "int";\r\n}\r\n}\r\nstatic const char *minimum_signed_size_type(int lwr, int upr){\r\nif( lwr>=-127 && upr<=127 ){\r\nreturn "signed char";\r\n}else if( lwr>=-32767 && upr<32767 ){\r\nreturn "short";\r\n}else{\r\nreturn "int";\r\n}\r\n}\r\nstatic int axset_compare(const void *a, const void *b){\r\nconst struct axset *p1 = (const struct axset*)a;\r\nconst struct axset *p2 = (const struct axset*)b;\r\nreturn p2->nAction - p1->nAction;\r\n}\r\nstatic void writeRuleText(FILE *out, struct rule *rp){\r\nint j;\r\nfprintf(out,"%s ::=", rp->lhs->name);\r\nfor(j=0; j<rp->nrhs; j++){\r\nstruct symbol *sp = rp->rhs[j];\r\nfprintf(out," %s", sp->name);\r\nif( sp->type==MULTITERMINAL ){\r\nint k;\r\nfor(k=1; k<sp->nsubsym; k++){\r\nfprintf(out,"|%s",sp->subsym[k]->name);\r\n}\r\n}\r\n}\r\n}\r\nvoid ReportTable(\r\nstruct lemon *lemp,\r\nint mhflag)\r\n{\r\nFILE *out, *in;\r\nchar line[LINESIZE];\r\nint lineno;\r\nstruct state *stp;\r\nstruct action *ap;\r\nstruct rule *rp;\r\nstruct acttab *pActtab;\r\nint i, j, n;\r\nconst char *name;\r\nint mnTknOfst, mxTknOfst;\r\nint mnNtOfst, mxNtOfst;\r\nstruct axset *ax;\r\nin = tplt_open(lemp);\r\nif( in==0 ) return;\r\nout = file_open(lemp,".c","wb");\r\nif( out==0 ){\r\nfclose(in);\r\nreturn;\r\n}\r\nlineno = 1;\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\ntplt_print(out,lemp,lemp->include,&lineno);\r\nif( mhflag ){\r\nchar *makename = file_makename_using_basename(lemp, ".h");\r\nfprintf(out,"#include \"%s\"\n", makename); lineno++;\r\nfree(makename);\r\n}\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\nif( mhflag ){\r\nconst char *prefix;\r\nfprintf(out,"#if INTERFACE\n"); lineno++;\r\nif( lemp->tokenprefix ) prefix = lemp->tokenprefix;\r\nelse prefix = "";\r\nfor(i=1; i<lemp->nterminal; i++){\r\nfprintf(out,"#define %s%-30s %2d\n",prefix,lemp->symbols[i]->name,i);\r\nlineno++;\r\n}\r\nfprintf(out,"#endif\n"); lineno++;\r\n}\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\nfprintf(out,"#define YYCODETYPE %s\n",\r\nminimum_signed_size_type(0, lemp->nsymbol+5)); lineno++;\r\nfprintf(out,"#define YYNOCODE %d\n",lemp->nsymbol+1); lineno++;\r\nfprintf(out,"#define YYACTIONTYPE %s\n",\r\nminimum_signed_size_type(0, lemp->nstate+lemp->nrule+5)); lineno++;\r\nif( lemp->wildcard ){\r\nfprintf(out,"#define YYWILDCARD %d\n",\r\nlemp->wildcard->index); lineno++;\r\n}\r\nprint_stack_union(out,lemp,&lineno,mhflag);\r\nfprintf(out, "#ifndef YYSTACKDEPTH\n"); lineno++;\r\nif( lemp->stacksize ){\r\nfprintf(out,"#define YYSTACKDEPTH %s\n",lemp->stacksize); lineno++;\r\n}else{\r\nfprintf(out,"#define YYSTACKDEPTH 100\n"); lineno++;\r\n}\r\nfprintf(out, "#endif\n"); lineno++;\r\nif( mhflag ){\r\nfprintf(out,"#if INTERFACE\n"); lineno++;\r\n}\r\nname = lemp->name ? lemp->name : "Parse";\r\nif( lemp->arg && lemp->arg[0] ){\r\ni = lemonStrlen(lemp->arg);\r\nwhile( i>=1 && safe_isspace(lemp->arg[i-1]) ) i--;\r\nwhile( i>=1 && (safe_isalnum(lemp->arg[i-1]) || lemp->arg[i-1]=='_') ) i--;\r\nfprintf(out,"#define %sARG_SDECL %s;\n",name,lemp->arg); lineno++;\r\nfprintf(out,"#define %sARG_PDECL ,%s\n",name,lemp->arg); lineno++;\r\nfprintf(out,"#define %sARG_FETCH %s = yypParser->%s\n",\r\nname,lemp->arg,&lemp->arg[i]); lineno++;\r\nfprintf(out,"#define %sARG_STORE yypParser->%s = %s\n",\r\nname,&lemp->arg[i],&lemp->arg[i]); lineno++;\r\n}else{\r\nfprintf(out,"#define %sARG_SDECL\n",name); lineno++;\r\nfprintf(out,"#define %sARG_PDECL\n",name); lineno++;\r\nfprintf(out,"#define %sARG_FETCH\n",name); lineno++;\r\nfprintf(out,"#define %sARG_STORE\n",name); lineno++;\r\n}\r\nif( mhflag ){\r\nfprintf(out,"#endif\n"); lineno++;\r\n}\r\nfprintf(out,"#define YYNSTATE %d\n",lemp->nstate); lineno++;\r\nfprintf(out,"#define YYNRULE %d\n",lemp->nrule); lineno++;\r\nif( lemp->errsym->useCnt ){\r\nfprintf(out,"#define YYERRORSYMBOL %d\n",lemp->errsym->index); lineno++;\r\nfprintf(out,"#define YYERRSYMDT yy%d\n",lemp->errsym->dtnum); lineno++;\r\n}\r\nif( lemp->has_fallback ){\r\nfprintf(out,"#define YYFALLBACK 1\n"); lineno++;\r\n}\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\nax = (struct axset *) calloc(lemp->nstate*2, sizeof(ax[0]));\r\nif( ax==NULL ){\r\nfprintf(stderr,"malloc failed\n");\r\nexit(1);\r\n}\r\nfor(i=0; i<lemp->nstate; i++){\r\nstp = lemp->sorted[i];\r\nax[i*2].stp = stp;\r\nax[i*2].isTkn = 1;\r\nax[i*2].nAction = stp->nTknAct;\r\nax[i*2+1].stp = stp;\r\nax[i*2+1].isTkn = 0;\r\nax[i*2+1].nAction = stp->nNtAct;\r\n}\r\nmxTknOfst = mnTknOfst = 0;\r\nmxNtOfst = mnNtOfst = 0;\r\nqsort(ax, lemp->nstate*2, sizeof(ax[0]), axset_compare);\r\npActtab = acttab_alloc();\r\nfor(i=0; i<lemp->nstate*2 && ax[i].nAction>0; i++){\r\nstp = ax[i].stp;\r\nif( ax[i].isTkn ){\r\nfor(ap=stp->ap; ap; ap=ap->next){\r\nint action;\r\nif( ap->sp->index>=lemp->nterminal ) continue;\r\naction = compute_action(lemp, ap);\r\nif( action<0 ) continue;\r\nacttab_action(pActtab, ap->sp->index, action);\r\n}\r\nstp->iTknOfst = acttab_insert(pActtab);\r\nif( stp->iTknOfst<mnTknOfst ) mnTknOfst = stp->iTknOfst;\r\nif( stp->iTknOfst>mxTknOfst ) mxTknOfst = stp->iTknOfst;\r\n}else{\r\nfor(ap=stp->ap; ap; ap=ap->next){\r\nint action;\r\nif( ap->sp->index<lemp->nterminal ) continue;\r\nif( ap->sp->index==lemp->nsymbol ) continue;\r\naction = compute_action(lemp, ap);\r\nif( action<0 ) continue;\r\nacttab_action(pActtab, ap->sp->index, action);\r\n}\r\nstp->iNtOfst = acttab_insert(pActtab);\r\nif( stp->iNtOfst<mnNtOfst ) mnNtOfst = stp->iNtOfst;\r\nif( stp->iNtOfst>mxNtOfst ) mxNtOfst = stp->iNtOfst;\r\n}\r\n}\r\nfree(ax);\r\nfprintf(out,"static const YYACTIONTYPE yy_action[] = {\n"); lineno++;\r\nn = acttab_size(pActtab);\r\nfor(i=j=0; i<n; i++){\r\nint action = acttab_yyaction(pActtab, i);\r\nif( action<0 ) action = lemp->nstate + lemp->nrule + 2;\r\nif( j==0 ) fprintf(out," /* %5d */ ", i);\r\nfprintf(out, " %4d,", action);\r\nif( j==9 || i==n-1 ){\r\nfprintf(out, "\n"); lineno++;\r\nj = 0;\r\n}else{\r\nj++;\r\n}\r\n}\r\nfprintf(out, "};\n"); lineno++;\r\nfprintf(out,"static const YYCODETYPE yy_lookahead[] = {\n"); lineno++;\r\nfor(i=j=0; i<n; i++){\r\nint la = acttab_yylookahead(pActtab, i);\r\nif( la<0 ) la = lemp->nsymbol;\r\nif( j==0 ) fprintf(out," /* %5d */ ", i);\r\nfprintf(out, " %4d,", la);\r\nif( j==9 || i==n-1 ){\r\nfprintf(out, "\n"); lineno++;\r\nj = 0;\r\n}else{\r\nj++;\r\n}\r\n}\r\nfprintf(out, "};\n"); lineno++;\r\nfprintf(out, "#define YY_SHIFT_USE_DFLT (%d)\n", mnTknOfst-1); lineno++;\r\nn = lemp->nstate;\r\nwhile( n>0 && lemp->sorted[n-1]->iTknOfst==NO_OFFSET ) n--;\r\nfprintf(out, "#define YY_SHIFT_MAX %d\n", n-1); lineno++;\r\nfprintf(out, "static const %s yy_shift_ofst[] = {\n",\r\nminimum_size_type(mnTknOfst-1, mxTknOfst)); lineno++;\r\nfor(i=j=0; i<n; i++){\r\nint ofst;\r\nstp = lemp->sorted[i];\r\nofst = stp->iTknOfst;\r\nif( ofst==NO_OFFSET ) ofst = mnTknOfst - 1;\r\nif( j==0 ) fprintf(out," /* %5d */ ", i);\r\nfprintf(out, " %4d,", ofst);\r\nif( j==9 || i==n-1 ){\r\nfprintf(out, "\n"); lineno++;\r\nj = 0;\r\n}else{\r\nj++;\r\n}\r\n}\r\nfprintf(out, "};\n"); lineno++;\r\nfprintf(out, "#define YY_REDUCE_USE_DFLT (%d)\n", mnNtOfst-1); lineno++;\r\nn = lemp->nstate;\r\nwhile( n>0 && lemp->sorted[n-1]->iNtOfst==NO_OFFSET ) n--;\r\nfprintf(out, "#define YY_REDUCE_MAX %d\n", n-1); lineno++;\r\nfprintf(out, "static const %s yy_reduce_ofst[] = {\n",\r\nminimum_size_type(mnNtOfst-1, mxNtOfst)); lineno++;\r\nfor(i=j=0; i<n; i++){\r\nint ofst;\r\nstp = lemp->sorted[i];\r\nofst = stp->iNtOfst;\r\nif( ofst==NO_OFFSET ) ofst = mnNtOfst - 1;\r\nif( j==0 ) fprintf(out," /* %5d */ ", i);\r\nfprintf(out, " %4d,", ofst);\r\nif( j==9 || i==n-1 ){\r\nfprintf(out, "\n"); lineno++;\r\nj = 0;\r\n}else{\r\nj++;\r\n}\r\n}\r\nfprintf(out, "};\n"); lineno++;\r\nfprintf(out, "static const YYACTIONTYPE yy_default[] = {\n"); lineno++;\r\nn = lemp->nstate;\r\nfor(i=j=0; i<n; i++){\r\nstp = lemp->sorted[i];\r\nif( j==0 ) fprintf(out," /* %5d */ ", i);\r\nfprintf(out, " %4d,", stp->iDflt);\r\nif( j==9 || i==n-1 ){\r\nfprintf(out, "\n"); lineno++;\r\nj = 0;\r\n}else{\r\nj++;\r\n}\r\n}\r\nfprintf(out, "};\n"); lineno++;\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\nif( lemp->has_fallback ){\r\nfor(i=0; i<lemp->nterminal; i++){\r\nstruct symbol *p = lemp->symbols[i];\r\nif( p->fallback==0 ){\r\nfprintf(out, " 0, /* %10s => nothing */\n", p->name);\r\n}else{\r\nfprintf(out, " %3d, /* %10s => %s */\n", p->fallback->index,\r\np->name, p->fallback->name);\r\n}\r\nlineno++;\r\n}\r\n}\r\ntplt_xfer(lemp->name, in, out, &lineno);\r\nfor(i=0; i<lemp->nsymbol; i++){\r\nsprintf(line,"\"%s\",",lemp->symbols[i]->name);\r\nfprintf(out," %-15s",line);\r\nif( (i&3)==3 ){ fprintf(out,"\n"); lineno++; }\r\n}\r\nif( (i&3)!=0 ){ fprintf(out,"\n"); lineno++; }\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\nfor(i=0, rp=lemp->rule; rp; rp=rp->next, i++){\r\nassert( rp->index==i );\r\nfprintf(out," /* %3d */ \"", i);\r\nwriteRuleText(out, rp);\r\nfprintf(out,"\",\n"); lineno++;\r\n}\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\nif( lemp->tokendest ){\r\nint once = 1;\r\nfor(i=0; i<lemp->nsymbol; i++){\r\nstruct symbol *sp = lemp->symbols[i];\r\nif( sp==0 || sp->type!=TERMINAL ) continue;\r\nif( once ){\r\nfprintf(out, " /* TERMINAL Destructor */\n"); lineno++;\r\nonce = 0;\r\n}\r\nfprintf(out," case %d: /* %s */\n",\r\nsp->index, sp->name); lineno++;\r\n}\r\nfor(i=0; i<lemp->nsymbol && lemp->symbols[i]->type!=TERMINAL; i++);\r\nif( i<lemp->nsymbol ){\r\nemit_destructor_code(out,lemp->symbols[i],lemp,&lineno);\r\n}\r\nfprintf(out," break;\n"); lineno++;\r\n}\r\nif( lemp->vardest ){\r\nstruct symbol *dflt_sp = 0;\r\nint once = 1;\r\nfor(i=0; i<lemp->nsymbol; i++){\r\nstruct symbol *sp = lemp->symbols[i];\r\nif( sp==0 || sp->type==TERMINAL ||\r\nsp->index<=0 || sp->destructor!=0 ) continue;\r\nif( once ){\r\nfprintf(out, " /* Default NON-TERMINAL Destructor */\n"); lineno++;\r\nonce = 0;\r\n}\r\nfprintf(out," case %d: /* %s */\n",\r\nsp->index, sp->name); lineno++;\r\ndflt_sp = sp;\r\n}\r\nif( dflt_sp!=0 ){\r\nemit_destructor_code(out,dflt_sp,lemp,&lineno);\r\nfprintf(out," break;\n"); lineno++;\r\n}\r\n}\r\nfor(i=0; i<lemp->nsymbol; i++){\r\nstruct symbol *sp = lemp->symbols[i];\r\nif( sp==0 || sp->type==TERMINAL || sp->destructor==0 ) continue;\r\nfprintf(out," case %d: /* %s */\n",\r\nsp->index, sp->name); lineno++;\r\nfor(j=i+1; j<lemp->nsymbol; j++){\r\nstruct symbol *sp2 = lemp->symbols[j];\r\nif( sp2 && sp2->type!=TERMINAL && sp2->destructor\r\n&& sp2->dtnum==sp->dtnum\r\n&& strcmp(sp->destructor,sp2->destructor)==0 ){\r\nfprintf(out," case %d: /* %s */\n",\r\nsp2->index, sp2->name); lineno++;\r\nsp2->destructor = 0;\r\n}\r\n}\r\nemit_destructor_code(out,lemp->symbols[i],lemp,&lineno);\r\nfprintf(out," break;\n"); lineno++;\r\n}\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\ntplt_print(out,lemp,lemp->overflow,&lineno);\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\nfor(rp=lemp->rule; rp; rp=rp->next){\r\nfprintf(out," { %d, %d },\n",rp->lhs->index,rp->nrhs); lineno++;\r\n}\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\nfor(rp=lemp->rule; rp; rp=rp->next){\r\ntranslate_code(lemp, rp);\r\n}\r\nfor(rp=lemp->rule; rp; rp=rp->next){\r\nstruct rule *rp2;\r\nif( rp->code==0 ) continue;\r\nfprintf(out," case %d: /* ", rp->index);\r\nwriteRuleText(out, rp);\r\nfprintf(out, " */\n"); lineno++;\r\nfor(rp2=rp->next; rp2; rp2=rp2->next){\r\nif( rp2->code==rp->code ){\r\nfprintf(out," case %d: /* ", rp2->index);\r\nwriteRuleText(out, rp2);\r\nfprintf(out," */\n"); lineno++;\r\nrp2->code = 0;\r\n}\r\n}\r\nemit_code(out,rp,lemp,&lineno);\r\nfprintf(out," break;\n"); lineno++;\r\n}\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\ntplt_print(out,lemp,lemp->failure,&lineno);\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\ntplt_print(out,lemp,lemp->error,&lineno);\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\ntplt_print(out,lemp,lemp->accept,&lineno);\r\ntplt_xfer(lemp->name,in,out,&lineno);\r\ntplt_print(out,lemp,lemp->extracode,&lineno);\r\nfclose(in);\r\nfclose(out);\r\nreturn;\r\n}\r\nvoid ReportHeader(struct lemon *lemp)\r\n{\r\nFILE *out, *in;\r\nconst char *prefix;\r\nchar line[LINESIZE];\r\nchar pattern[LINESIZE];\r\nint i;\r\nif( lemp->tokenprefix ) prefix = lemp->tokenprefix;\r\nelse prefix = "";\r\nin = file_open(lemp,".h","rb");\r\nif( in ){\r\nfor(i=1; i<lemp->nterminal && fgets(line,LINESIZE,in); i++){\r\nsprintf(pattern,"#define %s%-30s %2d\n",prefix,lemp->symbols[i]->name,i);\r\nif( strcmp(line,pattern) ) break;\r\n}\r\nfclose(in);\r\nif( i==lemp->nterminal ){\r\nreturn;\r\n}\r\n}\r\nout = file_open(lemp,".h","wb");\r\nif( out ){\r\nfor(i=1; i<lemp->nterminal; i++){\r\nfprintf(out,"#define %s%-30s %2d\n",prefix,lemp->symbols[i]->name,i);\r\n}\r\nfclose(out);\r\n}\r\nreturn;\r\n}\r\nvoid CompressTables(struct lemon *lemp)\r\n{\r\nstruct state *stp;\r\nstruct action *ap, *ap2;\r\nstruct rule *rp, *rp2, *rbest;\r\nint nbest, n;\r\nint i;\r\nint usesWildcard;\r\nfor(i=0; i<lemp->nstate; i++){\r\nstp = lemp->sorted[i];\r\nnbest = 0;\r\nrbest = 0;\r\nusesWildcard = 0;\r\nfor(ap=stp->ap; ap; ap=ap->next){\r\nif( ap->type==SHIFT && ap->sp==lemp->wildcard ){\r\nusesWildcard = 1;\r\n}\r\nif( ap->type!=REDUCE ) continue;\r\nrp = ap->x.rp;\r\nif( rp->lhsStart ) continue;\r\nif( rp==rbest ) continue;\r\nn = 1;\r\nfor(ap2=ap->next; ap2; ap2=ap2->next){\r\nif( ap2->type!=REDUCE ) continue;\r\nrp2 = ap2->x.rp;\r\nif( rp2==rbest ) continue;\r\nif( rp2==rp ) n++;\r\n}\r\nif( n>nbest ){\r\nnbest = n;\r\nrbest = rp;\r\n}\r\n}\r\nif( nbest<1 || usesWildcard ) continue;\r\nfor(ap=stp->ap; ap; ap=ap->next){\r\nif( ap->type==REDUCE && ap->x.rp==rbest ) break;\r\n}\r\nassert( ap );\r\nap->sp = Symbol_new("{default}");\r\nfor(ap=ap->next; ap; ap=ap->next){\r\nif( ap->type==REDUCE && ap->x.rp==rbest ) ap->type = NOT_USED;\r\n}\r\nstp->ap = Action_sort(stp->ap);\r\n}\r\n}\r\nstatic int stateResortCompare(const void *a, const void *b){\r\nconst struct state *pA = *(struct state *const *)a;\r\nconst struct state *pB = *(struct state *const *)b;\r\nint n;\r\nn = pB->nNtAct - pA->nNtAct;\r\nif( n==0 ){\r\nn = pB->nTknAct - pA->nTknAct;\r\n}\r\nreturn n;\r\n}\r\nvoid ResortStates(struct lemon *lemp)\r\n{\r\nint i;\r\nstruct state *stp;\r\nstruct action *ap;\r\nfor(i=0; i<lemp->nstate; i++){\r\nstp = lemp->sorted[i];\r\nstp->nTknAct = stp->nNtAct = 0;\r\nstp->iDflt = lemp->nstate + lemp->nrule;\r\nstp->iTknOfst = NO_OFFSET;\r\nstp->iNtOfst = NO_OFFSET;\r\nfor(ap=stp->ap; ap; ap=ap->next){\r\nif( compute_action(lemp,ap)>=0 ){\r\nif( ap->sp->index<lemp->nterminal ){\r\nstp->nTknAct++;\r\n}else if( ap->sp->index<lemp->nsymbol ){\r\nstp->nNtAct++;\r\n}else{\r\nstp->iDflt = compute_action(lemp, ap);\r\n}\r\n}\r\n}\r\n}\r\nqsort(&lemp->sorted[1], lemp->nstate-1, sizeof(lemp->sorted[0]),\r\nstateResortCompare);\r\nfor(i=0; i<lemp->nstate; i++){\r\nlemp->sorted[i]->statenum = i;\r\n}\r\n}\r\nvoid SetSize(int n)\r\n{\r\nsize = n+1;\r\n}\r\nchar *SetNew(void){\r\nchar *s;\r\ns = (char*)calloc( size, 1);\r\nif( s==NULL ){\r\nmemory_error();\r\n}\r\nreturn s;\r\n}\r\nvoid SetFree(char *s)\r\n{\r\nfree(s);\r\n}\r\nint SetAdd(char *s, int e)\r\n{\r\nint rv;\r\nassert( e>=0 && e<size );\r\nrv = s[e];\r\ns[e] = 1;\r\nreturn !rv;\r\n}\r\nint SetUnion(char *s1, char *s2)\r\n{\r\nint i, progress;\r\nprogress = 0;\r\nfor(i=0; i<size; i++){\r\nif( s2[i]==0 ) continue;\r\nif( s1[i]==0 ){\r\nprogress = 1;\r\ns1[i] = 1;\r\n}\r\n}\r\nreturn progress;\r\n}\r\nPRIVATE unsigned int strhash(const char *x)\r\n{\r\nunsigned int h = 0;\r\nwhile( *x) h = h*13 + *(x++);\r\nreturn h;\r\n}\r\nconst char *Strsafe(const char *y)\r\n{\r\nconst char *z;\r\nchar *cpy;\r\nif( y==0 ) return 0;\r\nz = Strsafe_find(y);\r\nif( z==0 && (cpy=(char *)malloc( lemonStrlen(y)+1 ))!=0 ){\r\nstrcpy(cpy,y);\r\nz = cpy;\r\nStrsafe_insert(z);\r\n}\r\nMemoryCheck(z);\r\nreturn z;\r\n}\r\nvoid Strsafe_init(void){\r\nif( x1a ) return;\r\nx1a = (struct s_x1*)malloc( sizeof(struct s_x1) );\r\nif( x1a ){\r\nx1a->size = 1024;\r\nx1a->count = 0;\r\nx1a->tbl = (x1node*)malloc(\r\n(sizeof(x1node) + sizeof(x1node*))*1024 );\r\nif( x1a->tbl==0 ){\r\nfree(x1a);\r\nx1a = 0;\r\n}else{\r\nint i;\r\nx1a->ht = (x1node**)&(x1a->tbl[1024]);\r\nfor(i=0; i<1024; i++) x1a->ht[i] = 0;\r\n}\r\n}\r\n}\r\nint Strsafe_insert(const char *data)\r\n{\r\nx1node *np;\r\nint h;\r\nint ph;\r\nif( x1a==0 ) return 0;\r\nph = strhash(data);\r\nh = ph & (x1a->size-1);\r\nnp = x1a->ht[h];\r\nwhile( np ){\r\nif( strcmp(np->data,data)==0 ){\r\nreturn 0;\r\n}\r\nnp = np->next;\r\n}\r\nif( x1a->count>=x1a->size ){\r\nint i,array_size;\r\nstruct s_x1 array;\r\narray.size = array_size = x1a->size*2;\r\narray.count = x1a->count;\r\narray.tbl = (x1node*)malloc(\r\n(sizeof(x1node) + sizeof(x1node*))*array_size );\r\nif( array.tbl==0 ) return 0;\r\narray.ht = (x1node**)&(array.tbl[array_size]);\r\nfor(i=0; i<array_size; i++) array.ht[i] = 0;\r\nfor(i=0; i<x1a->count; i++){\r\nx1node *oldnp, *newnp;\r\noldnp = &(x1a->tbl[i]);\r\nh = strhash(oldnp->data) & (array_size-1);\r\nnewnp = &(array.tbl[i]);\r\nif( array.ht[h] ) array.ht[h]->from = &(newnp->next);\r\nnewnp->next = array.ht[h];\r\nnewnp->data = oldnp->data;\r\nnewnp->from = &(array.ht[h]);\r\narray.ht[h] = newnp;\r\n}\r\nfree(x1a->tbl);\r\n*x1a = array;\r\n}\r\nh = ph & (x1a->size-1);\r\nnp = &(x1a->tbl[x1a->count++]);\r\nnp->data = data;\r\nif( x1a->ht[h] ) x1a->ht[h]->from = &(np->next);\r\nnp->next = x1a->ht[h];\r\nx1a->ht[h] = np;\r\nnp->from = &(x1a->ht[h]);\r\nreturn 1;\r\n}\r\nconst char *Strsafe_find(const char *key)\r\n{\r\nint h;\r\nx1node *np;\r\nif( x1a==0 ) return 0;\r\nh = strhash(key) & (x1a->size-1);\r\nnp = x1a->ht[h];\r\nwhile( np ){\r\nif( strcmp(np->data,key)==0 ) break;\r\nnp = np->next;\r\n}\r\nreturn np ? np->data : 0;\r\n}\r\nstruct symbol *Symbol_new(const char *x)\r\n{\r\nstruct symbol *sp;\r\nsp = Symbol_find(x);\r\nif( sp==0 ){\r\nsp = (struct symbol *)calloc(1, sizeof(struct symbol) );\r\nMemoryCheck(sp);\r\nsp->name = Strsafe(x);\r\nsp->type = safe_isupper(*x) ? TERMINAL : NONTERMINAL;\r\nsp->rule = 0;\r\nsp->fallback = 0;\r\nsp->prec = -1;\r\nsp->assoc = UNK;\r\nsp->firstset = 0;\r\nsp->lambda = LEMON_FALSE;\r\nsp->destructor = 0;\r\nsp->destLineno = 0;\r\nsp->datatype = 0;\r\nsp->useCnt = 0;\r\nSymbol_insert(sp,sp->name);\r\n}\r\nsp->useCnt++;\r\nreturn sp;\r\n}\r\nint Symbolcmpp(const void *a_arg, const void *b_arg){\r\nstruct symbol *const *a = (struct symbol *const *) a_arg;\r\nstruct symbol *const *b = (struct symbol *const *) b_arg;\r\nint i1 = (**a).index + 10000000*((**a).name[0]>'Z');\r\nint i2 = (**b).index + 10000000*((**b).name[0]>'Z');\r\nreturn i1-i2;\r\n}\r\nvoid Symbol_init(void){\r\nif( x2a ) return;\r\nx2a = (struct s_x2*)malloc( sizeof(struct s_x2) );\r\nif( x2a ){\r\nx2a->size = 128;\r\nx2a->count = 0;\r\nx2a->tbl = (x2node*)malloc(\r\n(sizeof(x2node) + sizeof(x2node*))*128 );\r\nif( x2a->tbl==0 ){\r\nfree(x2a);\r\nx2a = 0;\r\n}else{\r\nint i;\r\nx2a->ht = (x2node**)&(x2a->tbl[128]);\r\nfor(i=0; i<128; i++) x2a->ht[i] = 0;\r\n}\r\n}\r\n}\r\nint Symbol_insert(struct symbol *data, const char *key)\r\n{\r\nx2node *np;\r\nint h;\r\nint ph;\r\nif( x2a==0 ) return 0;\r\nph = strhash(key);\r\nh = ph & (x2a->size-1);\r\nnp = x2a->ht[h];\r\nwhile( np ){\r\nif( strcmp(np->key,key)==0 ){\r\nreturn 0;\r\n}\r\nnp = np->next;\r\n}\r\nif( x2a->count>=x2a->size ){\r\nint i,array_size;\r\nstruct s_x2 array;\r\narray.size = array_size = x2a->size*2;\r\narray.count = x2a->count;\r\narray.tbl = (x2node*)malloc(\r\n(sizeof(x2node) + sizeof(x2node*))*array_size );\r\nif( array.tbl==0 ) return 0;\r\narray.ht = (x2node**)&(array.tbl[array_size]);\r\nfor(i=0; i<array_size; i++) array.ht[i] = 0;\r\nfor(i=0; i<x2a->count; i++){\r\nx2node *oldnp, *newnp;\r\noldnp = &(x2a->tbl[i]);\r\nh = strhash(oldnp->key) & (array_size-1);\r\nnewnp = &(array.tbl[i]);\r\nif( array.ht[h] ) array.ht[h]->from = &(newnp->next);\r\nnewnp->next = array.ht[h];\r\nnewnp->key = oldnp->key;\r\nnewnp->data = oldnp->data;\r\nnewnp->from = &(array.ht[h]);\r\narray.ht[h] = newnp;\r\n}\r\nfree(x2a->tbl);\r\n*x2a = array;\r\n}\r\nh = ph & (x2a->size-1);\r\nnp = &(x2a->tbl[x2a->count++]);\r\nnp->key = key;\r\nnp->data = data;\r\nif( x2a->ht[h] ) x2a->ht[h]->from = &(np->next);\r\nnp->next = x2a->ht[h];\r\nx2a->ht[h] = np;\r\nnp->from = &(x2a->ht[h]);\r\nreturn 1;\r\n}\r\nstruct symbol *Symbol_find(const char *key)\r\n{\r\nint h;\r\nx2node *np;\r\nif( x2a==0 ) return 0;\r\nh = strhash(key) & (x2a->size-1);\r\nnp = x2a->ht[h];\r\nwhile( np ){\r\nif( strcmp(np->key,key)==0 ) break;\r\nnp = np->next;\r\n}\r\nreturn np ? np->data : 0;\r\n}\r\nstruct symbol *Symbol_Nth(int n)\r\n{\r\nstruct symbol *data;\r\nif( x2a && n>0 && n<=x2a->count ){\r\ndata = x2a->tbl[n-1].data;\r\n}else{\r\ndata = 0;\r\n}\r\nreturn data;\r\n}\r\nint Symbol_count(void)\r\n{\r\nreturn x2a ? x2a->count : 0;\r\n}\r\nstruct symbol **Symbol_arrayof(void)\r\n{\r\nstruct symbol **array;\r\nint i,array_size;\r\nif( x2a==0 ) return 0;\r\narray_size = x2a->count;\r\narray = (struct symbol **)calloc(array_size, sizeof(struct symbol *));\r\nif( array ){\r\nfor(i=0; i<array_size; i++) array[i] = x2a->tbl[i].data;\r\n}\r\nreturn array;\r\n}\r\nint Configcmp(const char *_a,const char *_b)\r\n{\r\nconst struct config *a = (const struct config *) _a;\r\nconst struct config *b = (const struct config *) _b;\r\nint x;\r\nx = a->rp->index - b->rp->index;\r\nif( x==0 ) x = a->dot - b->dot;\r\nreturn x;\r\n}\r\nPRIVATE int statecmp(struct config *a, struct config *b)\r\n{\r\nint rc;\r\nfor(rc=0; rc==0 && a && b; a=a->bp, b=b->bp){\r\nrc = a->rp->index - b->rp->index;\r\nif( rc==0 ) rc = a->dot - b->dot;\r\n}\r\nif( rc==0 ){\r\nif( a ) rc = 1;\r\nif( b ) rc = -1;\r\n}\r\nreturn rc;\r\n}\r\nPRIVATE int statehash(struct config *a)\r\n{\r\nint h=0;\r\nwhile( a ){\r\nh = h*571 + a->rp->index*37 + a->dot;\r\na = a->bp;\r\n}\r\nreturn h;\r\n}\r\nstruct state *State_new(void)\r\n{\r\nstruct state *newstate;\r\nnewstate = (struct state *)calloc(1, sizeof(struct state) );\r\nMemoryCheck(newstate);\r\nreturn newstate;\r\n}\r\nvoid State_init(void){\r\nif( x3a ) return;\r\nx3a = (struct s_x3*)malloc( sizeof(struct s_x3) );\r\nif( x3a ){\r\nx3a->size = 128;\r\nx3a->count = 0;\r\nx3a->tbl = (x3node*)malloc(\r\n(sizeof(x3node) + sizeof(x3node*))*128 );\r\nif( x3a->tbl==0 ){\r\nfree(x3a);\r\nx3a = 0;\r\n}else{\r\nint i;\r\nx3a->ht = (x3node**)&(x3a->tbl[128]);\r\nfor(i=0; i<128; i++) x3a->ht[i] = 0;\r\n}\r\n}\r\n}\r\nint State_insert(struct state *data, struct config *key)\r\n{\r\nx3node *np;\r\nint h;\r\nint ph;\r\nif( x3a==0 ) return 0;\r\nph = statehash(key);\r\nh = ph & (x3a->size-1);\r\nnp = x3a->ht[h];\r\nwhile( np ){\r\nif( statecmp(np->key,key)==0 ){\r\nreturn 0;\r\n}\r\nnp = np->next;\r\n}\r\nif( x3a->count>=x3a->size ){\r\nint i,array_size;\r\nstruct s_x3 array;\r\narray.size = array_size = x3a->size*2;\r\narray.count = x3a->count;\r\narray.tbl = (x3node*)malloc(\r\n(sizeof(x3node) + sizeof(x3node*))*array_size );\r\nif( array.tbl==0 ) return 0;\r\narray.ht = (x3node**)&(array.tbl[array_size]);\r\nfor(i=0; i<array_size; i++) array.ht[i] = 0;\r\nfor(i=0; i<x3a->count; i++){\r\nx3node *oldnp, *newnp;\r\noldnp = &(x3a->tbl[i]);\r\nh = statehash(oldnp->key) & (array_size-1);\r\nnewnp = &(array.tbl[i]);\r\nif( array.ht[h] ) array.ht[h]->from = &(newnp->next);\r\nnewnp->next = array.ht[h];\r\nnewnp->key = oldnp->key;\r\nnewnp->data = oldnp->data;\r\nnewnp->from = &(array.ht[h]);\r\narray.ht[h] = newnp;\r\n}\r\nfree(x3a->tbl);\r\n*x3a = array;\r\n}\r\nh = ph & (x3a->size-1);\r\nnp = &(x3a->tbl[x3a->count++]);\r\nnp->key = key;\r\nnp->data = data;\r\nif( x3a->ht[h] ) x3a->ht[h]->from = &(np->next);\r\nnp->next = x3a->ht[h];\r\nx3a->ht[h] = np;\r\nnp->from = &(x3a->ht[h]);\r\nreturn 1;\r\n}\r\nstruct state *State_find(struct config *key)\r\n{\r\nint h;\r\nx3node *np;\r\nif( x3a==0 ) return 0;\r\nh = statehash(key) & (x3a->size-1);\r\nnp = x3a->ht[h];\r\nwhile( np ){\r\nif( statecmp(np->key,key)==0 ) break;\r\nnp = np->next;\r\n}\r\nreturn np ? np->data : 0;\r\n}\r\nstruct state **State_arrayof(void)\r\n{\r\nstruct state **array;\r\nint i,array_size;\r\nif( x3a==0 ) return 0;\r\narray_size = x3a->count;\r\narray = (struct state **)malloc( sizeof(struct state *)*array_size );\r\nif( array ){\r\nfor(i=0; i<array_size; i++) array[i] = x3a->tbl[i].data;\r\n}\r\nreturn array;\r\n}\r\nPRIVATE int confighash(struct config *a)\r\n{\r\nint h=0;\r\nh = h*571 + a->rp->index*37 + a->dot;\r\nreturn h;\r\n}\r\nvoid Configtable_init(void){\r\nif( x4a ) return;\r\nx4a = (struct s_x4*)malloc( sizeof(struct s_x4) );\r\nif( x4a ){\r\nx4a->size = 64;\r\nx4a->count = 0;\r\nx4a->tbl = (x4node*)malloc(\r\n(sizeof(x4node) + sizeof(x4node*))*64 );\r\nif( x4a->tbl==0 ){\r\nfree(x4a);\r\nx4a = 0;\r\n}else{\r\nint i;\r\nx4a->ht = (x4node**)&(x4a->tbl[64]);\r\nfor(i=0; i<64; i++) x4a->ht[i] = 0;\r\n}\r\n}\r\n}\r\nint Configtable_insert(struct config *data)\r\n{\r\nx4node *np;\r\nint h;\r\nint ph;\r\nif( x4a==0 ) return 0;\r\nph = confighash(data);\r\nh = ph & (x4a->size-1);\r\nnp = x4a->ht[h];\r\nwhile( np ){\r\nif( Configcmp((const char *) np->data,(const char *) data)==0 ){\r\nreturn 0;\r\n}\r\nnp = np->next;\r\n}\r\nif( x4a->count>=x4a->size ){\r\nint i,array_size;\r\nstruct s_x4 array;\r\narray.size = array_size = x4a->size*2;\r\narray.count = x4a->count;\r\narray.tbl = (x4node*)malloc(\r\n(sizeof(x4node) + sizeof(x4node*))*array_size );\r\nif( array.tbl==0 ) return 0;\r\narray.ht = (x4node**)&(array.tbl[array_size]);\r\nfor(i=0; i<array_size; i++) array.ht[i] = 0;\r\nfor(i=0; i<x4a->count; i++){\r\nx4node *oldnp, *newnp;\r\noldnp = &(x4a->tbl[i]);\r\nh = confighash(oldnp->data) & (array_size-1);\r\nnewnp = &(array.tbl[i]);\r\nif( array.ht[h] ) array.ht[h]->from = &(newnp->next);\r\nnewnp->next = array.ht[h];\r\nnewnp->data = oldnp->data;\r\nnewnp->from = &(array.ht[h]);\r\narray.ht[h] = newnp;\r\n}\r\nfree(x4a->tbl);\r\n*x4a = array;\r\n}\r\nh = ph & (x4a->size-1);\r\nnp = &(x4a->tbl[x4a->count++]);\r\nnp->data = data;\r\nif( x4a->ht[h] ) x4a->ht[h]->from = &(np->next);\r\nnp->next = x4a->ht[h];\r\nx4a->ht[h] = np;\r\nnp->from = &(x4a->ht[h]);\r\nreturn 1;\r\n}\r\nstruct config *Configtable_find(struct config *key)\r\n{\r\nint h;\r\nx4node *np;\r\nif( x4a==0 ) return 0;\r\nh = confighash(key) & (x4a->size-1);\r\nnp = x4a->ht[h];\r\nwhile( np ){\r\nif( Configcmp((const char *) np->data,(const char *) key)==0 ) break;\r\nnp = np->next;\r\n}\r\nreturn np ? np->data : 0;\r\n}\r\nvoid Configtable_clear(int(*f)(struct config *))\r\n{\r\nint i;\r\nif( x4a==0 || x4a->count==0 ) return;\r\nif( f ) for(i=0; i<x4a->count; i++) (*f)(x4a->tbl[i].data);\r\nfor(i=0; i<x4a->size; i++) x4a->ht[i] = 0;\r\nx4a->count = 0;\r\nreturn;\r\n}
