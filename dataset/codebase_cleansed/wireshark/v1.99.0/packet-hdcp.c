static int\r\ndissect_hdcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nguint8 reg;\r\nproto_item *pi;\r\nptvcursor_t *cursor;\r\nproto_tree *hdcp_tree;\r\nhdcp_transaction_t *hdcp_trans;\r\nproto_item *it;\r\nguint64 a_ksv, b_ksv;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HDCP");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\npi = proto_tree_add_protocol_format(tree, proto_hdcp,\r\ntvb, 0, tvb_reported_length(tvb), "HDCP");\r\nhdcp_tree = proto_item_add_subtree(pi, ett_hdcp);\r\ncursor = ptvcursor_new(hdcp_tree, tvb, 0);\r\nif (pinfo->p2p_dir==P2P_DIR_SENT) {\r\nreg = tvb_get_guint8(tvb, ptvcursor_current_offset(cursor));\r\nptvcursor_add(cursor, hf_hdcp_reg, 1, ENC_LITTLE_ENDIAN);\r\nif (tvb_reported_length_remaining(tvb,\r\nptvcursor_current_offset(cursor)) == 0) {\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL, "request %s",\r\nval_to_str(reg, hdcp_reg, "unknown (0x%x)"));\r\nif (PINFO_FD_VISITED(pinfo)) {\r\nhdcp_trans = (hdcp_transaction_t *)wmem_tree_lookup32(\r\ntransactions, PINFO_FD_NUM(pinfo));\r\nif (hdcp_trans && hdcp_trans->rqst_frame==PINFO_FD_NUM(pinfo) &&\r\nhdcp_trans->resp_frame!=0) {\r\nit = proto_tree_add_uint_format(hdcp_tree, hf_hdcp_resp_in,\r\nNULL, 0, 0, hdcp_trans->resp_frame,\r\n"Request to get the content of register %s, "\r\n"response in frame %d",\r\nval_to_str_const(hdcp_trans->rqst_type,\r\nhdcp_reg, "unknown (0x%x)"),\r\nhdcp_trans->resp_frame);\r\nPROTO_ITEM_SET_GENERATED(it);\r\n}\r\n}\r\nelse {\r\nif (transactions) {\r\nhdcp_trans = wmem_new(wmem_file_scope(), hdcp_transaction_t);\r\nhdcp_trans->rqst_frame = PINFO_FD_NUM(pinfo);\r\nhdcp_trans->resp_frame = 0;\r\nhdcp_trans->rqst_type = reg;\r\nwmem_tree_insert32(transactions,\r\nhdcp_trans->rqst_frame, (void *)hdcp_trans);\r\n}\r\n}\r\n}\r\nelse {\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL, "send %s",\r\nval_to_str(reg, hdcp_reg, "unknown (0x%x)"));\r\nswitch (reg) {\r\ncase REG_AKSV:\r\na_ksv = tvb_get_letoh40(tvb,\r\nptvcursor_current_offset(cursor));\r\nproto_tree_add_uint64_format(hdcp_tree, hf_hdcp_a_ksv,\r\ntvb, ptvcursor_current_offset(cursor), 5,\r\na_ksv, "A_ksv 0x%010" G_GINT64_MODIFIER "x", a_ksv);\r\nptvcursor_advance(cursor, 5);\r\nbreak;\r\ncase REG_AN:\r\nptvcursor_add(cursor, hf_hdcp_an, 8, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nelse {\r\nif (transactions) {\r\nhdcp_trans = (hdcp_transaction_t *)wmem_tree_lookup32_le(\r\ntransactions, PINFO_FD_NUM(pinfo));\r\nif (hdcp_trans) {\r\nif (hdcp_trans->resp_frame==0) {\r\nhdcp_trans->resp_frame = PINFO_FD_NUM(pinfo);\r\n}\r\nif (hdcp_trans->resp_frame== PINFO_FD_NUM(pinfo)) {\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL, "send %s",\r\nval_to_str_const(hdcp_trans->rqst_type,\r\nhdcp_reg, "unknown (0x%x)"));\r\nit = proto_tree_add_uint_format(hdcp_tree, hf_hdcp_resp_to,\r\nNULL, 0, 0, hdcp_trans->rqst_frame,\r\n"Response to frame %d (content of register %s)",\r\nhdcp_trans->rqst_frame,\r\nval_to_str_const(hdcp_trans->rqst_type,\r\nhdcp_reg, "unknown (0x%x)"));\r\nPROTO_ITEM_SET_GENERATED(it);\r\nswitch (hdcp_trans->rqst_type) {\r\ncase REG_BKSV:\r\nb_ksv = tvb_get_letoh40(tvb,\r\nptvcursor_current_offset(cursor));\r\nproto_tree_add_uint64_format(hdcp_tree, hf_hdcp_b_ksv,\r\ntvb, ptvcursor_current_offset(cursor), 5,\r\nb_ksv, "B_ksv 0x%010" G_GINT64_MODIFIER "x",\r\nb_ksv);\r\nptvcursor_advance(cursor, 5);\r\nbreak;\r\ncase REG_BCAPS:\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_hdmi_reserved, 1, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_repeater, 1, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_ksv_fifo, 1, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_fast_trans, 1, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_features, 1, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_fast_reauth, 1, ENC_LITTLE_ENDIAN);\r\nbreak;\r\ncase REG_BSTATUS:\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_hdmi_mode, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_max_casc_exc, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_depth, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_max_devs_exc, 2, ENC_LITTLE_ENDIAN);\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_downstream, 2, ENC_LITTLE_ENDIAN);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!hdcp_trans || hdcp_trans->resp_frame!=PINFO_FD_NUM(pinfo)) {\r\nif (tvb_reported_length_remaining(\r\ntvb, ptvcursor_current_offset(cursor)) == 2) {\r\ncol_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL,\r\n"send link verification Ri'");\r\nptvcursor_add_no_advance(cursor,\r\nhf_hdcp_link_vfy, 2, ENC_LITTLE_ENDIAN);\r\n}\r\n}\r\n}\r\n}\r\nptvcursor_free(cursor);\r\nreturn tvb_reported_length(tvb);\r\n}\r\nvoid\r\nproto_register_hdcp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_hdcp_reg,\r\n{ "Register offset", "hdcp.reg", FT_UINT8, BASE_HEX,\r\nVALS(hdcp_reg), 0, NULL, HFILL } },\r\n{ &hf_hdcp_resp_in,\r\n{ "Response In", "hdcp.resp_in", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"The response to this request is in this frame", HFILL }},\r\n{ &hf_hdcp_resp_to,\r\n{ "Response To", "hdcp.resp_to", FT_FRAMENUM, BASE_NONE, NULL, 0x0,\r\n"This is the response to the request in this frame", HFILL }},\r\n{ &hf_hdcp_a_ksv,\r\n{ "Transmitter's key selection vector", "hdcp.a_ksv", FT_UINT64,\r\nBASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdcp_b_ksv,\r\n{ "Receiver's key selection vector", "hdcp.b_ksv", FT_UINT64,\r\nBASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdcp_an,\r\n{ "Random number for the session", "hdcp.an", FT_UINT64,\r\nBASE_HEX, NULL, 0, NULL, HFILL } },\r\n{ &hf_hdcp_hdmi_reserved,\r\n{ "HDMI reserved", "hdcp.hdmi_reserved", FT_UINT8, BASE_DEC,\r\nNULL, 0x80, NULL, HFILL } },\r\n{ &hf_hdcp_repeater,\r\n{ "Repeater", "hdcp.repeater", FT_UINT8, BASE_DEC,\r\nNULL, 0x40, NULL, HFILL } },\r\n{ &hf_hdcp_ksv_fifo,\r\n{ "KSV fifo ready", "hdcp.ksv_fifo", FT_UINT8, BASE_DEC,\r\nNULL, 0x20, NULL, HFILL } },\r\n{ &hf_hdcp_fast_trans,\r\n{ "Support for 400KHz transfers", "hdcp.fast_trans",\r\nFT_UINT8, BASE_DEC, NULL, 0x10, NULL, HFILL } },\r\n{ &hf_hdcp_features,\r\n{ "Support for additional features", "hdcp.features",\r\nFT_UINT8, BASE_DEC, NULL, 0x02, NULL, HFILL } },\r\n{ &hf_hdcp_fast_reauth,\r\n{ "Support for fast re-authentication", "hdcp.fast_reauth",\r\nFT_UINT8, BASE_DEC, NULL, 0x01, NULL, HFILL } },\r\n{ &hf_hdcp_hdmi_mode,\r\n{ "HDMI mode", "hdcp.hdmi_mode",\r\nFT_UINT16, BASE_DEC, NULL, 0x1000, NULL, HFILL } },\r\n{ &hf_hdcp_max_casc_exc,\r\n{ "Maximum cascading depth exceeded", "hdcp.max_casc_exc",\r\nFT_UINT16, BASE_DEC, NULL, 0x0800, NULL, HFILL } },\r\n{ &hf_hdcp_depth,\r\n{ "Repeater cascade depth", "hdcp.depth",\r\nFT_UINT16, BASE_DEC, NULL, 0x0700, NULL, HFILL } },\r\n{ &hf_hdcp_max_devs_exc,\r\n{ "Maximum number of devices exceeded", "hdcp.max_devs_exc",\r\nFT_UINT16, BASE_DEC, NULL, 0x0080, NULL, HFILL } },\r\n{ &hf_hdcp_downstream,\r\n{ "Number of downstream receivers", "hdcp.downstream",\r\nFT_UINT16, BASE_DEC, NULL, 0x007F, NULL, HFILL } },\r\n{ &hf_hdcp_link_vfy,\r\n{ "Link verification response Ri'", "hdcp.link_vfy",\r\nFT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL } }\r\n};\r\nstatic gint *ett[] = {\r\n&ett_hdcp\r\n};\r\nproto_hdcp = proto_register_protocol(\r\n"High bandwidth Digital Content Protection", "HDCP", "hdcp");\r\nproto_register_field_array(proto_hdcp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nnew_register_dissector("hdcp", dissect_hdcp, proto_hdcp);\r\ntransactions = wmem_tree_new_autoreset(wmem_epan_scope(), wmem_file_scope());\r\n}
