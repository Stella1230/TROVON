static void\r\nint_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.uinteger = 0;\r\n}\r\nstatic void\r\nset_uinteger(fvalue_t *fv, guint32 value)\r\n{\r\nfv->value.uinteger = value;\r\n}\r\nstatic void\r\nset_sinteger(fvalue_t *fv, gint32 value)\r\n{\r\nfv->value.sinteger = value;\r\n}\r\nstatic guint32\r\nget_uinteger(fvalue_t *fv)\r\n{\r\nreturn fv->value.uinteger;\r\n}\r\nstatic gint32\r\nget_sinteger(fvalue_t *fv)\r\n{\r\nreturn fv->value.sinteger;\r\n}\r\nstatic gboolean\r\nuint_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, LogFunc logfunc,\r\nguint32 max)\r\n{\r\nunsigned long value;\r\nchar *endptr;\r\nif (strchr (s, '-') && strtol(s, NULL, 0) < 0) {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" too small for this field, minimum 0.", s);\r\nreturn FALSE;\r\n}\r\nerrno = 0;\r\nvalue = strtoul(s, &endptr, 0);\r\nif (errno == EINVAL || endptr == s || *endptr != '\0') {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" is not a valid number.", s);\r\nreturn FALSE;\r\n}\r\nif (errno == ERANGE) {\r\nif (logfunc != NULL) {\r\nif (value == ULONG_MAX) {\r\nlogfunc("\"%s\" causes an integer overflow.",\r\ns);\r\n}\r\nelse {\r\nlogfunc("\"%s\" is not an integer.", s);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nif (value > max) {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" too big for this field, maximum %u.", s, max);\r\nreturn FALSE;\r\n}\r\nfv->value.uinteger = (guint32)value;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nuint32_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, LogFunc logfunc)\r\n{\r\nreturn uint_from_unparsed (fv, s, allow_partial_value, logfunc, G_MAXUINT32);\r\n}\r\nstatic gboolean\r\nuint24_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, LogFunc logfunc)\r\n{\r\nreturn uint_from_unparsed (fv, s, allow_partial_value, logfunc, 0xFFFFFF);\r\n}\r\nstatic gboolean\r\nuint16_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, LogFunc logfunc)\r\n{\r\nreturn uint_from_unparsed (fv, s, allow_partial_value, logfunc, G_MAXUINT16);\r\n}\r\nstatic gboolean\r\nuint8_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, LogFunc logfunc)\r\n{\r\nreturn uint_from_unparsed (fv, s, allow_partial_value, logfunc, G_MAXUINT8);\r\n}\r\nstatic gboolean\r\nsint_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, LogFunc logfunc,\r\ngint32 max, gint32 min)\r\n{\r\nlong value;\r\nchar *endptr;\r\nif (!strchr (s, '-') && strtoul(s, NULL, 0) > G_MAXINT32) {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" causes an integer overflow.", s);\r\nreturn FALSE;\r\n}\r\nerrno = 0;\r\nvalue = strtol(s, &endptr, 0);\r\nif (errno == EINVAL || endptr == s || *endptr != '\0') {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" is not a valid number.", s);\r\nreturn FALSE;\r\n}\r\nif (errno == ERANGE) {\r\nif (logfunc != NULL) {\r\nif (value == LONG_MAX) {\r\nlogfunc("\"%s\" causes an integer overflow.", s);\r\n}\r\nelse if (value == LONG_MIN) {\r\nlogfunc("\"%s\" causes an integer underflow.", s);\r\n}\r\nelse {\r\nlogfunc("\"%s\" is not an integer.", s);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nif (value > max) {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" too big for this field, maximum %d.",\r\ns, max);\r\nreturn FALSE;\r\n} else if (value < min) {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" too small for this field, minimum %d.",\r\ns, min);\r\nreturn FALSE;\r\n}\r\nfv->value.sinteger = (gint32)value;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nsint32_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, LogFunc logfunc)\r\n{\r\nreturn sint_from_unparsed (fv, s, allow_partial_value, logfunc, G_MAXINT32, G_MININT32);\r\n}\r\nstatic gboolean\r\nsint24_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, LogFunc logfunc)\r\n{\r\nreturn sint_from_unparsed (fv, s, allow_partial_value, logfunc, 0x7FFFFF, -0x800000);\r\n}\r\nstatic gboolean\r\nsint16_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, LogFunc logfunc)\r\n{\r\nreturn sint_from_unparsed (fv, s, allow_partial_value, logfunc, G_MAXINT16, G_MININT16);\r\n}\r\nstatic gboolean\r\nsint8_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value, LogFunc logfunc)\r\n{\r\nreturn sint_from_unparsed (fv, s, allow_partial_value, logfunc, G_MAXINT8, G_MININT8);\r\n}\r\nstatic int\r\ninteger_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_)\r\n{\r\nreturn 11;\r\n}\r\nstatic void\r\ninteger_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, char *buf)\r\n{\r\nguint32 val;\r\nif (fv->value.sinteger < 0) {\r\n*buf++ = '-';\r\nval = -fv->value.sinteger;\r\n} else\r\nval = fv->value.sinteger;\r\nguint32_to_str_buf(val, buf, 11);\r\n}\r\nstatic int\r\nuinteger_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_)\r\n{\r\nreturn 10;\r\n}\r\nstatic void\r\nuinteger_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, char *buf)\r\n{\r\nguint32_to_str_buf(fv->value.uinteger, buf, 11);\r\n}\r\nstatic gboolean\r\nipxnet_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, LogFunc logfunc)\r\n{\r\nguint32 val;\r\ngboolean known;\r\nif (uint32_from_unparsed(fv, s, TRUE, NULL)) {\r\nreturn TRUE;\r\n}\r\nval = get_ipxnet_addr(s, &known);\r\nif (known) {\r\nfv->value.uinteger = val;\r\nreturn TRUE;\r\n}\r\nlogfunc("\"%s\" is not a valid IPX network name or address.", s);\r\nreturn FALSE;\r\n}\r\nstatic int\r\nipxnet_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_)\r\n{\r\nreturn 2+8;\r\n}\r\nstatic void\r\nipxnet_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, char *buf)\r\n{\r\nsprintf(buf, "0x%08x", fv->value.uinteger);\r\n}\r\nstatic gboolean\r\ncmp_eq(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger == b->value.uinteger;\r\n}\r\nstatic gboolean\r\ncmp_ne(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger != b->value.uinteger;\r\n}\r\nstatic gboolean\r\nu_cmp_gt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger > b->value.uinteger;\r\n}\r\nstatic gboolean\r\nu_cmp_ge(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger >= b->value.uinteger;\r\n}\r\nstatic gboolean\r\nu_cmp_lt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger < b->value.uinteger;\r\n}\r\nstatic gboolean\r\nu_cmp_le(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.uinteger <= b->value.uinteger;\r\n}\r\nstatic gboolean\r\ns_cmp_gt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.sinteger > b->value.sinteger;\r\n}\r\nstatic gboolean\r\ns_cmp_ge(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.sinteger >= b->value.sinteger;\r\n}\r\nstatic gboolean\r\ns_cmp_lt(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.sinteger < b->value.sinteger;\r\n}\r\nstatic gboolean\r\ns_cmp_le(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.sinteger <= b->value.sinteger;\r\n}\r\nstatic gboolean\r\ncmp_bitwise_and(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ((a->value.uinteger & b->value.uinteger) != 0);\r\n}\r\nstatic void\r\nint64_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.integer64 = 0;\r\n}\r\nstatic void\r\nset_integer64(fvalue_t *fv, guint64 value)\r\n{\r\nfv->value.integer64 = value;\r\n}\r\nstatic guint64\r\nget_integer64(fvalue_t *fv)\r\n{\r\nreturn fv->value.integer64;\r\n}\r\nstatic gboolean\r\nuint64_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, LogFunc logfunc)\r\n{\r\nguint64 value;\r\nchar *endptr;\r\nif (strchr (s, '-') && g_ascii_strtoll(s, NULL, 0) < 0) {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" causes an integer underflow.", s);\r\nreturn FALSE;\r\n}\r\nerrno = 0;\r\nvalue = g_ascii_strtoull(s, &endptr, 0);\r\nif (errno == EINVAL || endptr == s || *endptr != '\0') {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" is not a valid number.", s);\r\nreturn FALSE;\r\n}\r\nif (errno == ERANGE) {\r\nif (logfunc != NULL) {\r\nif (value == G_MAXUINT64) {\r\nlogfunc("\"%s\" causes an integer overflow.", s);\r\n}\r\nelse {\r\nlogfunc("\"%s\" is not an integer.", s);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nfv->value.integer64 = value;\r\nreturn TRUE;\r\n}\r\nstatic gboolean\r\nsint64_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, LogFunc logfunc)\r\n{\r\ngint64 value;\r\nchar *endptr;\r\nif (!strchr (s, '-') && g_ascii_strtoull(s, NULL, 0) > G_MAXINT64) {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" causes an integer overflow.", s);\r\nreturn FALSE;\r\n}\r\nerrno = 0;\r\nvalue = g_ascii_strtoll(s, &endptr, 0);\r\nif (errno == EINVAL || endptr == s || *endptr != '\0') {\r\nif (logfunc != NULL)\r\nlogfunc("\"%s\" is not a valid number.", s);\r\nreturn FALSE;\r\n}\r\nif (errno == ERANGE) {\r\nif (logfunc != NULL) {\r\nif (value == G_MAXINT64) {\r\nlogfunc("\"%s\" causes an integer overflow.", s);\r\n}\r\nelse if (value == G_MININT64) {\r\nlogfunc("\"%s\" causes an integer underflow.", s);\r\n}\r\nelse {\r\nlogfunc("\"%s\" is not an integer.", s);\r\n}\r\n}\r\nreturn FALSE;\r\n}\r\nfv->value.integer64 = (guint64)value;\r\nreturn TRUE;\r\n}\r\nstatic int\r\ninteger64_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_)\r\n{\r\nreturn 20;\r\n}\r\nstatic void\r\ninteger64_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, char *buf)\r\n{\r\nsprintf(buf, "%" G_GINT64_MODIFIER "d", fv->value.integer64);\r\n}\r\nstatic int\r\nuinteger64_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_)\r\n{\r\nreturn 20;\r\n}\r\nstatic void\r\nuinteger64_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, char *buf)\r\n{\r\nsprintf(buf, "%" G_GINT64_MODIFIER "u", fv->value.integer64);\r\n}\r\nstatic gboolean\r\ncmp_eq64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.integer64 == b->value.integer64;\r\n}\r\nstatic gboolean\r\ncmp_ne64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.integer64 != b->value.integer64;\r\n}\r\nstatic gboolean\r\nu_cmp_gt64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.integer64 > b->value.integer64;\r\n}\r\nstatic gboolean\r\nu_cmp_ge64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.integer64 >= b->value.integer64;\r\n}\r\nstatic gboolean\r\nu_cmp_lt64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.integer64 < b->value.integer64;\r\n}\r\nstatic gboolean\r\nu_cmp_le64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn a->value.integer64 <= b->value.integer64;\r\n}\r\nstatic gboolean\r\ns_cmp_gt64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (gint64)a->value.integer64 > (gint64)b->value.integer64;\r\n}\r\nstatic gboolean\r\ns_cmp_ge64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (gint64)a->value.integer64 >= (gint64)b->value.integer64;\r\n}\r\nstatic gboolean\r\ns_cmp_lt64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (gint64)a->value.integer64 < (gint64)b->value.integer64;\r\n}\r\nstatic gboolean\r\ns_cmp_le64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (gint64)a->value.integer64 <= (gint64)b->value.integer64;\r\n}\r\nstatic gboolean\r\ncmp_bitwise_and64(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn ((a->value.integer64 & b->value.integer64) != 0);\r\n}\r\nstatic void\r\nboolean_fvalue_new(fvalue_t *fv)\r\n{\r\nfv->value.uinteger = TRUE;\r\n}\r\nstatic int\r\nboolean_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_)\r\n{\r\nreturn 1;\r\n}\r\nstatic void\r\nboolean_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, char *buf)\r\n{\r\n*buf++ = (fv->value.uinteger) ? '1' : '0';\r\n*buf = '\0';\r\n}\r\nstatic gboolean\r\nbool_eq(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nif (a->value.uinteger) {\r\nif (b->value.uinteger) {\r\nreturn TRUE;\r\n}\r\nelse {\r\nreturn FALSE;\r\n}\r\n}\r\nelse {\r\nif (b->value.uinteger) {\r\nreturn FALSE;\r\n}\r\nelse {\r\nreturn TRUE;\r\n}\r\n}\r\n}\r\nstatic gboolean\r\nbool_ne(const fvalue_t *a, const fvalue_t *b)\r\n{\r\nreturn (!bool_eq(a,b));\r\n}\r\nstatic gboolean\r\neui64_from_unparsed(fvalue_t *fv, const char *s, gboolean allow_partial_value _U_, LogFunc logfunc)\r\n{\r\nif (uint64_from_unparsed(fv, s, TRUE, NULL)) {\r\nreturn TRUE;\r\n}\r\nlogfunc("\"%s\" is not a valid EUI64 Address", s);\r\nreturn FALSE;\r\n}\r\nstatic int\r\neui64_repr_len(fvalue_t *fv _U_, ftrepr_t rtype _U_)\r\n{\r\nreturn 8*3-1;\r\n}\r\nstatic void\r\neui64_to_repr(fvalue_t *fv, ftrepr_t rtype _U_, char *buf)\r\n{\r\nguint8 *p_eui64 = (guint8 *)ep_alloc(8);\r\n*(guint64 *)(void *)(p_eui64) = pntoh64(&(fv->value.integer64));\r\ng_snprintf(buf, EUI64_STR_LEN, "%.2x:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x:%.2x",\r\np_eui64[0], p_eui64[1], p_eui64[2], p_eui64[3],\r\np_eui64[4], p_eui64[5], p_eui64[6], p_eui64[7] );\r\n}\r\nvoid\r\nftype_register_integers(void)\r\n{\r\nstatic ftype_t uint8_type = {\r\nFT_UINT8,\r\n"FT_UINT8",\r\n"Unsigned integer, 1 byte",\r\n1,\r\nint_fvalue_new,\r\nNULL,\r\nuint8_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint16_type = {\r\nFT_UINT16,\r\n"FT_UINT16",\r\n"Unsigned integer, 2 bytes",\r\n2,\r\nint_fvalue_new,\r\nNULL,\r\nuint16_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint24_type = {\r\nFT_UINT24,\r\n"FT_UINT24",\r\n"Unsigned integer, 3 bytes",\r\n3,\r\nint_fvalue_new,\r\nNULL,\r\nuint24_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint32_type = {\r\nFT_UINT32,\r\n"FT_UINT32",\r\n"Unsigned integer, 4 bytes",\r\n4,\r\nint_fvalue_new,\r\nNULL,\r\nuint32_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t uint64_type = {\r\nFT_UINT64,\r\n"FT_UINT64",\r\n"Unsigned integer, 8 bytes",\r\n8,\r\nint64_fvalue_new,\r\nNULL,\r\nuint64_from_unparsed,\r\nNULL,\r\nuinteger64_to_repr,\r\nuinteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_integer64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_integer64,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\nu_cmp_gt64,\r\nu_cmp_ge64,\r\nu_cmp_lt64,\r\nu_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int8_type = {\r\nFT_INT8,\r\n"FT_INT8",\r\n"Signed integer, 1 byte",\r\n1,\r\nint_fvalue_new,\r\nNULL,\r\nsint8_from_unparsed,\r\nNULL,\r\ninteger_to_repr,\r\ninteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ns_cmp_gt,\r\ns_cmp_ge,\r\ns_cmp_lt,\r\ns_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int16_type = {\r\nFT_INT16,\r\n"FT_INT16",\r\n"Signed integer, 2 bytes",\r\n2,\r\nint_fvalue_new,\r\nNULL,\r\nsint16_from_unparsed,\r\nNULL,\r\ninteger_to_repr,\r\ninteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ns_cmp_gt,\r\ns_cmp_ge,\r\ns_cmp_lt,\r\ns_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int24_type = {\r\nFT_INT24,\r\n"FT_INT24",\r\n"Signed integer, 3 bytes",\r\n3,\r\nint_fvalue_new,\r\nNULL,\r\nsint24_from_unparsed,\r\nNULL,\r\ninteger_to_repr,\r\ninteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ns_cmp_gt,\r\ns_cmp_ge,\r\ns_cmp_lt,\r\ns_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int32_type = {\r\nFT_INT32,\r\n"FT_INT32",\r\n"Signed integer, 4 bytes",\r\n4,\r\nint_fvalue_new,\r\nNULL,\r\nsint32_from_unparsed,\r\nNULL,\r\ninteger_to_repr,\r\ninteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_sinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_sinteger,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\ns_cmp_gt,\r\ns_cmp_ge,\r\ns_cmp_lt,\r\ns_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t int64_type = {\r\nFT_INT64,\r\n"FT_INT64",\r\n"Signed integer, 8 bytes",\r\n8,\r\nint64_fvalue_new,\r\nNULL,\r\nsint64_from_unparsed,\r\nNULL,\r\ninteger64_to_repr,\r\ninteger64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_integer64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_integer64,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\ns_cmp_gt64,\r\ns_cmp_ge64,\r\ns_cmp_lt64,\r\ns_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t boolean_type = {\r\nFT_BOOLEAN,\r\n"FT_BOOLEAN",\r\n"Boolean",\r\n0,\r\nboolean_fvalue_new,\r\nNULL,\r\nuint32_from_unparsed,\r\nNULL,\r\nboolean_to_repr,\r\nboolean_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nbool_eq,\r\nbool_ne,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t ipxnet_type = {\r\nFT_IPXNET,\r\n"FT_IPXNET",\r\n"IPX network number",\r\n4,\r\nint_fvalue_new,\r\nNULL,\r\nipxnet_from_unparsed,\r\nNULL,\r\nipxnet_to_repr,\r\nipxnet_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\ncmp_bitwise_and,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t framenum_type = {\r\nFT_FRAMENUM,\r\n"FT_FRAMENUM",\r\n"Frame number",\r\n4,\r\nint_fvalue_new,\r\nNULL,\r\nuint32_from_unparsed,\r\nNULL,\r\nuinteger_to_repr,\r\nuinteger_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_uinteger,\r\nNULL,\r\nNULL,\r\nNULL,\r\ncmp_eq,\r\ncmp_ne,\r\nu_cmp_gt,\r\nu_cmp_ge,\r\nu_cmp_lt,\r\nu_cmp_le,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nstatic ftype_t eui64_type = {\r\nFT_EUI64,\r\n"FT_EUI64",\r\n"EUI64 address",\r\nFT_EUI64_LEN,\r\nint64_fvalue_new,\r\nNULL,\r\neui64_from_unparsed,\r\nNULL,\r\neui64_to_repr,\r\neui64_repr_len,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nset_integer64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\nget_integer64,\r\nNULL,\r\ncmp_eq64,\r\ncmp_ne64,\r\nu_cmp_gt64,\r\nu_cmp_ge64,\r\nu_cmp_lt64,\r\nu_cmp_le64,\r\ncmp_bitwise_and64,\r\nNULL,\r\nNULL,\r\nNULL,\r\nNULL,\r\n};\r\nftype_register(FT_UINT8, &uint8_type);\r\nftype_register(FT_UINT16, &uint16_type);\r\nftype_register(FT_UINT24, &uint24_type);\r\nftype_register(FT_UINT32, &uint32_type);\r\nftype_register(FT_UINT64, &uint64_type);\r\nftype_register(FT_INT8, &int8_type);\r\nftype_register(FT_INT16, &int16_type);\r\nftype_register(FT_INT24, &int24_type);\r\nftype_register(FT_INT32, &int32_type);\r\nftype_register(FT_INT64, &int64_type);\r\nftype_register(FT_BOOLEAN, &boolean_type);\r\nftype_register(FT_IPXNET, &ipxnet_type);\r\nftype_register(FT_FRAMENUM, &framenum_type);\r\nftype_register(FT_EUI64, &eui64_type);\r\n}
