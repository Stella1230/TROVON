static int\r\ndissect_hsrp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\ntvbuff_t *next_tvb;\r\ngchar dst[16];\r\nif(pinfo->destport != UDP_PORT_HSRP && pinfo->destport != UDP_PORT_HSRP2_V6)\r\nreturn 0;\r\naddress_to_str_buf(&(pinfo->dst), dst, sizeof dst);\r\nif (pinfo->dst.type == AT_IPv4 && strcmp(dst,HSRP_DST_IP_ADDR) == 0) {\r\nguint8 opcode, state = 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HSRP");\r\nopcode = tvb_get_guint8(tvb, 1);\r\ncol_set_str(pinfo->cinfo, COL_INFO,\r\nval_to_str_const(opcode, hsrp_opcode_vals, "Unknown"));\r\nif (opcode < 3) {\r\nstate = tvb_get_guint8(tvb, 2);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (state %s)",\r\nval_to_str_const(state, hsrp_state_vals, "Unknown"));\r\n} else if (opcode == 3) {\r\nstate = tvb_get_guint8(tvb, 6);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (state %s)",\r\nval_to_str_const(state, hsrp_adv_state_vals, "Unknown"));\r\n}\r\nif (tree) {\r\nproto_item *ti;\r\nproto_tree *hsrp_tree;\r\ngint offset;\r\nguint8 hellotime, holdtime;\r\ngchar auth_buf[8 + 1];\r\noffset = 0;\r\nti = proto_tree_add_item(tree, proto_hsrp, tvb, offset, -1, ENC_NA);\r\nhsrp_tree = proto_item_add_subtree(ti, ett_hsrp);\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_uint(hsrp_tree, hf_hsrp_opcode, tvb, offset, 1, opcode);\r\noffset++;\r\nif (opcode < 3) {\r\nproto_tree_add_uint(hsrp_tree, hf_hsrp_state, tvb, offset, 1, state);\r\noffset++;\r\nhellotime = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint_format_value(hsrp_tree, hf_hsrp_hellotime, tvb, offset, 1, hellotime,\r\n"%sDefault (%u)",\r\n(hellotime == HSRP_DEFAULT_HELLOTIME) ? "" : "Non-",\r\nhellotime);\r\noffset++;\r\nholdtime = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint_format_value(hsrp_tree, hf_hsrp_holdtime, tvb, offset, 1, holdtime,\r\n"%sDefault (%u)",\r\n(holdtime == HSRP_DEFAULT_HOLDTIME) ? "" : "Non-",\r\nholdtime);\r\noffset++;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_priority, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_group, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\ntvb_memcpy(tvb, auth_buf, offset, 8);\r\nauth_buf[sizeof auth_buf - 1] = '\0';\r\nproto_tree_add_string_format_value(hsrp_tree, hf_hsrp_auth_data, tvb, offset, 8, auth_buf,\r\n"%sDefault (%s)",\r\n(tvb_strneql(tvb, offset, "cisco", strlen("cisco"))) == 0 ? "" : "Non-",\r\nauth_buf);\r\noffset += 8;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_virt_ip_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n} else if (opcode == 3) {\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_adv_type, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_adv_length, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_adv_state, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_adv_reserved1, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset += 1;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_adv_activegrp, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_adv_passivegrp, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset += 2;\r\nproto_tree_add_item(hsrp_tree, hf_hsrp_adv_reserved2, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n} else {\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(data_handle, next_tvb, pinfo, hsrp_tree);\r\n}\r\n}\r\n} else if ((pinfo->dst.type == AT_IPv4 && strcmp(dst,HSRP2_DST_IP_ADDR) == 0) ||\r\n(pinfo->dst.type == AT_IPv6 && pinfo->destport == UDP_PORT_HSRP2_V6)) {\r\nguint offset = 0, offset2;\r\nproto_item *ti = NULL;\r\nproto_tree *hsrp_tree = NULL;\r\nguint8 type,len;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "HSRPv2");\r\nif (tree) {\r\nti = proto_tree_add_item(tree, proto_hsrp, tvb, offset, -1, ENC_NA);\r\nhsrp_tree = proto_item_add_subtree(ti, ett_hsrp);\r\n}\r\nwhile (tvb_reported_length_remaining(tvb, offset) > 0) {\r\ntype = tvb_get_guint8(tvb, offset);\r\nlen = tvb_get_guint8(tvb, offset+1);\r\noffset2 = offset;\r\nif (type == 1 && len == 40) {\r\nguint8 opcode, state = 0, ipver;\r\nguint32 hellotime, holdtime;\r\nproto_tree *group_state_tlv;\r\nif (tree) {\r\nti = proto_tree_add_uint_format_value(hsrp_tree, hf_hsrp2_group_state_tlv, tvb, offset, 2, type,\r\n"Type=%d Len=%d", type, len);\r\n}\r\noffset+=2;\r\nopcode = tvb_get_guint8(tvb, offset+1);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "%s",\r\nval_to_str_const(opcode, hsrp2_opcode_vals, "Unknown"));\r\nstate = tvb_get_guint8(tvb, offset+2);\r\ncol_append_fstr(pinfo->cinfo, COL_INFO, " (state %s)",\r\nval_to_str_const(state, hsrp2_state_vals, "Unknown"));\r\nif (tree) {\r\ngroup_state_tlv = proto_item_add_subtree(ti, ett_hsrp2_group_state_tlv);\r\nproto_tree_add_item(group_state_tlv, hf_hsrp2_version, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\nproto_tree_add_uint(group_state_tlv, hf_hsrp2_opcode, tvb, offset, 1, opcode);\r\noffset++;\r\nproto_tree_add_uint(group_state_tlv, hf_hsrp2_state, tvb, offset, 1, state);\r\noffset++;\r\nipver = tvb_get_guint8(tvb, offset);\r\nproto_tree_add_uint(group_state_tlv, hf_hsrp2_ipversion, tvb, offset, 1, ipver);\r\noffset++;\r\nproto_tree_add_item(group_state_tlv, hf_hsrp2_group, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(group_state_tlv, hf_hsrp2_identifier, tvb, offset, 6, ENC_NA);\r\noffset+=6;\r\nproto_tree_add_item(group_state_tlv, hf_hsrp2_priority, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nhellotime = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint_format_value(group_state_tlv, hf_hsrp2_hellotime, tvb, offset, 4, hellotime,\r\n"%sDefault (%u)",\r\n(hellotime == HSRP2_DEFAULT_HELLOTIME) ? "" : "Non-",\r\nhellotime);\r\noffset+=4;\r\nholdtime = tvb_get_ntohl(tvb, offset);\r\nproto_tree_add_uint_format_value(group_state_tlv, hf_hsrp2_holdtime, tvb, offset, 4, holdtime,\r\n"%sDefault (%u)",\r\n(holdtime == HSRP2_DEFAULT_HOLDTIME) ? "" : "Non-",\r\nholdtime);\r\noffset+=4;\r\nif (ipver == 4) {\r\nproto_tree_add_item(group_state_tlv, hf_hsrp2_virt_ip_addr, tvb, offset, 4, ENC_BIG_ENDIAN);\r\n} else if (ipver == 6) {\r\nproto_tree_add_item(group_state_tlv, hf_hsrp2_virt_ip_addr_v6, tvb, offset, 16, ENC_NA);\r\n} else {\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(data_handle, next_tvb, pinfo, hsrp_tree);\r\nbreak;\r\n}\r\n}\r\n} else if (type == 2 && len == 4) {\r\nguint16 active,passive;\r\nactive = tvb_get_ntohs(tvb, offset+2);\r\npassive = tvb_get_ntohs(tvb, offset+4);\r\ncol_add_fstr(pinfo->cinfo, COL_INFO, "Interface State TLV (Act=%d Pass=%d)",active,passive);\r\nif (tree) {\r\nproto_tree *interface_state_tlv;\r\nti = proto_tree_add_uint_format_value(hsrp_tree, hf_hsrp2_interface_state_tlv, tvb, offset, 1, type,\r\n"Type=%d Len=%d", type, len);\r\noffset+=2;\r\ninterface_state_tlv = proto_item_add_subtree(ti, ett_hsrp2_interface_state_tlv);\r\nproto_tree_add_item(interface_state_tlv, hf_hsrp2_active_group, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(interface_state_tlv, hf_hsrp2_passive_group, tvb, offset, 2, ENC_BIG_ENDIAN);\r\n}\r\n} else if (type == 3 && len == 8) {\r\nif (tree) {\r\nproto_tree *text_auth_tlv;\r\ngchar auth_buf[8 + 1];\r\nti = proto_tree_add_uint_format_value(hsrp_tree, hf_hsrp2_text_auth_tlv, tvb, offset, 1, type,\r\n"Type=%d Len=%d", type, len);\r\noffset+=2;\r\ntext_auth_tlv = proto_item_add_subtree(ti, ett_hsrp2_text_auth_tlv);\r\ntvb_memcpy(tvb, auth_buf, offset, 8);\r\nauth_buf[sizeof auth_buf - 1] = '\0';\r\nproto_tree_add_string_format_value(text_auth_tlv, hf_hsrp2_auth_data, tvb, offset, 8, auth_buf,\r\n"%sDefault (%s)",\r\n(tvb_strneql(tvb, offset, "cisco", strlen("cisco"))) == 0 ? "" : "Non-",\r\nauth_buf);\r\n}\r\n} else if (type == 4 && len == 28) {\r\nif (tree) {\r\nproto_tree *md5_auth_tlv;\r\nti = proto_tree_add_uint_format_value(hsrp_tree, hf_hsrp2_md5_auth_tlv, tvb, offset, 1, type,\r\n"Type=%d Len=%d", type, len);\r\noffset+=2;\r\nmd5_auth_tlv = proto_item_add_subtree(ti, ett_hsrp2_md5_auth_tlv);\r\nproto_tree_add_item(md5_auth_tlv, hf_hsrp2_md5_algorithm, tvb, offset, 1, ENC_BIG_ENDIAN);\r\noffset++;\r\noffset++;\r\nproto_tree_add_item(md5_auth_tlv, hf_hsrp2_md5_flags, tvb, offset, 2, ENC_BIG_ENDIAN);\r\noffset+=2;\r\nproto_tree_add_item(md5_auth_tlv, hf_hsrp2_md5_ip_address, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(md5_auth_tlv, hf_hsrp2_md5_key_id, tvb, offset, 4, ENC_BIG_ENDIAN);\r\noffset+=4;\r\nproto_tree_add_item(md5_auth_tlv, hf_hsrp2_md5_auth_data, tvb, offset, 16, ENC_NA);\r\n}\r\n} else {\r\nif (tree) {\r\nnext_tvb = tvb_new_subset_remaining(tvb, offset);\r\ncall_dissector(data_handle, next_tvb, pinfo, hsrp_tree);\r\n}\r\nbreak;\r\n}\r\noffset = offset2+len+2;\r\n}\r\n}\r\nreturn tvb_length(tvb);\r\n}\r\nvoid proto_register_hsrp(void)\r\n{\r\nstatic hf_register_info hf[] = {\r\n{ &hf_hsrp_version,\r\n{ "Version", "hsrp.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The version of the HSRP messages", HFILL }},\r\n{ &hf_hsrp_opcode,\r\n{ "Op Code", "hsrp.opcode",\r\nFT_UINT8, BASE_DEC, VALS(hsrp_opcode_vals), 0x0,\r\n"The type of message contained in this packet", HFILL }},\r\n{ &hf_hsrp_state,\r\n{ "State", "hsrp.state",\r\nFT_UINT8, BASE_DEC, VALS(hsrp_state_vals), 0x0,\r\n"The current state of the router sending the message", HFILL }},\r\n{ &hf_hsrp_hellotime,\r\n{ "Hellotime", "hsrp.hellotime",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The approximate period between the Hello messages that the router sends", HFILL }},\r\n{ &hf_hsrp_holdtime,\r\n{ "Holdtime", "hsrp.holdtime",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Time that the current Hello message should be considered valid", HFILL }},\r\n{ &hf_hsrp_priority,\r\n{ "Priority", "hsrp.priority",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Used to elect the active and standby routers. Numerically higher priority wins vote", HFILL }},\r\n{ &hf_hsrp_group,\r\n{ "Group", "hsrp.group",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"This field identifies the standby group", HFILL }},\r\n{ &hf_hsrp_reserved,\r\n{ "Reserved", "hsrp.reserved",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_hsrp_auth_data,\r\n{ "Authentication Data", "hsrp.auth_data",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Contains a clear-text 8 character reused password", HFILL }},\r\n{ &hf_hsrp_virt_ip_addr,\r\n{ "Virtual IP Address", "hsrp.virt_ip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"The virtual IP address used by this group", HFILL }},\r\n{ &hf_hsrp_adv_type,\r\n{ "Adv type", "hsrp.adv.tlvtype",\r\nFT_UINT16, BASE_DEC, VALS(hsrp_adv_type_vals), 0x0,\r\n"Advertisement tlv type", HFILL }},\r\n{ &hf_hsrp_adv_length,\r\n{ "Adv length", "hsrp.adv.tlvlength",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Advertisement tlv length", HFILL }},\r\n{ &hf_hsrp_adv_state,\r\n{ "Adv state", "hsrp.adv.state",\r\nFT_UINT8, BASE_DEC, VALS(hsrp_adv_state_vals), 0x0,\r\n"Advertisement tlv length", HFILL }},\r\n{ &hf_hsrp_adv_reserved1,\r\n{ "Adv reserved1", "hsrp.adv.reserved1",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Advertisement tlv length", HFILL }},\r\n{ &hf_hsrp_adv_activegrp,\r\n{ "Adv active groups", "hsrp.adv.activegrp",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Advertisement active group count", HFILL }},\r\n{ &hf_hsrp_adv_passivegrp,\r\n{ "Adv passive groups", "hsrp.adv.passivegrp",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Advertisement passive group count", HFILL }},\r\n{ &hf_hsrp_adv_reserved2,\r\n{ "Adv reserved2", "hsrp.adv.reserved2",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Advertisement tlv length", HFILL }},\r\n{ &hf_hsrp2_version,\r\n{ "Version", "hsrp2.version",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"The version of the HSRP messages", HFILL }},\r\n{ &hf_hsrp2_opcode,\r\n{ "Op Code", "hsrp2.opcode",\r\nFT_UINT8, BASE_DEC, VALS(hsrp2_opcode_vals), 0x0,\r\n"The type of message contained in this packet", HFILL }},\r\n{ &hf_hsrp2_state,\r\n{ "State", "hsrp2.state",\r\nFT_UINT8, BASE_DEC, VALS(hsrp2_state_vals), 0x0,\r\n"The current state of the router sending the message", HFILL }},\r\n{ &hf_hsrp2_group_state_tlv,\r\n{ "Group State TLV", "hsrp2.group_state_tlv",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_hsrp2_interface_state_tlv,\r\n{ "Interface State TLV", "hsrp2.interface_state_tlv",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_hsrp2_text_auth_tlv,\r\n{ "Text Authentication TLV", "hsrp2.text_auth_tlv",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_hsrp2_md5_auth_tlv,\r\n{ "MD5 Authentication TLV", "hsrp2.md5_auth_tlv",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\nNULL, HFILL }},\r\n{ &hf_hsrp2_ipversion,\r\n{ "IP Ver.", "hsrp2.ipversion",\r\nFT_UINT8, BASE_DEC, VALS(hsrp2_ipversion_vals), 0x0,\r\n"The IP protocol version used in this hsrp message", HFILL }},\r\n{ &hf_hsrp2_group,\r\n{ "Group", "hsrp2.group",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"This field identifies the standby group", HFILL }},\r\n{ &hf_hsrp2_identifier,\r\n{ "Identifier", "hsrp2.identifier",\r\nFT_ETHER, BASE_NONE, NULL, 0x0,\r\n"BIA value of a sender interface", HFILL }},\r\n{ &hf_hsrp2_hellotime,\r\n{ "Hellotime", "hsrp2.hellotime",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"The approximate period between the Hello messages that the router sends", HFILL }},\r\n{ &hf_hsrp2_holdtime,\r\n{ "Holdtime", "hsrp2.holdtime",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Time that the current Hello message should be considered valid", HFILL }},\r\n{ &hf_hsrp2_priority,\r\n{ "Priority", "hsrp2.priority",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"Used to elect the active and standby routers. Numerically higher priority wins vote", HFILL }},\r\n{ &hf_hsrp2_auth_data,\r\n{ "Authentication Data", "hsrp2.auth_data",\r\nFT_STRING, BASE_NONE, NULL, 0x0,\r\n"Contains a clear-text 8 character reused password", HFILL }},\r\n{ &hf_hsrp2_virt_ip_addr,\r\n{ "Virtual IP Address", "hsrp2.virt_ip",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"The virtual IP address used by this group", HFILL }},\r\n{ &hf_hsrp2_virt_ip_addr_v6,\r\n{ "Virtual IPv6 Address", "hsrp2.virt_ip_v6",\r\nFT_IPv6, BASE_NONE, NULL, 0x0,\r\n"The virtual IPv6 address used by this group", HFILL }},\r\n{ &hf_hsrp2_active_group,\r\n{ "Active Groups", "hsrp2.active_groups",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Active group number which becomes the active router myself", HFILL }},\r\n{ &hf_hsrp2_passive_group,\r\n{ "Passive Groups", "hsrp2.passive_groups",\r\nFT_UINT16, BASE_DEC, NULL, 0x0,\r\n"Standby group number which doesn't become the active router myself", HFILL }},\r\n{ &hf_hsrp2_md5_algorithm,\r\n{ "MD5 Algorithm", "hsrp2.md5_algorithm",\r\nFT_UINT8, BASE_DEC, VALS(hsrp2_md5_algorithm_vals), 0x0,\r\n"Hash Algorithm used by this group", HFILL }},\r\n{ &hf_hsrp2_md5_flags,\r\n{ "MD5 Flags", "hsrp2.md5_flags",\r\nFT_UINT8, BASE_DEC, NULL, 0x0,\r\n"Undefined", HFILL }},\r\n{ &hf_hsrp2_md5_ip_address,\r\n{ "Sender's IP Address", "hsrp.md5_ip_address",\r\nFT_IPv4, BASE_NONE, NULL, 0x0,\r\n"IP Address of the sender interface", HFILL }},\r\n{ &hf_hsrp2_md5_key_id,\r\n{ "MD5 Key ID", "hsrp2.md5_key_id",\r\nFT_UINT32, BASE_DEC, NULL, 0x0,\r\n"This field contains Key chain ID", HFILL }},\r\n{ &hf_hsrp2_md5_auth_data,\r\n{ "MD5 Authentication Data", "hsrp2.md5_auth_data",\r\nFT_BYTES, BASE_NONE, NULL, 0x0,\r\n"MD5 digest string is contained.", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_hsrp,\r\n&ett_hsrp2_group_state_tlv,\r\n&ett_hsrp2_interface_state_tlv,\r\n&ett_hsrp2_text_auth_tlv,\r\n&ett_hsrp2_md5_auth_tlv\r\n};\r\nproto_hsrp = proto_register_protocol("Cisco Hot Standby Router Protocol",\r\n"HSRP", "hsrp");\r\nproto_register_field_array(proto_hsrp, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nreturn;\r\n}\r\nvoid\r\nproto_reg_handoff_hsrp(void)\r\n{\r\ndissector_handle_t hsrp_handle;\r\ndata_handle = find_dissector("data");\r\nhsrp_handle = new_create_dissector_handle(dissect_hsrp, proto_hsrp);\r\ndissector_add_uint("udp.port", UDP_PORT_HSRP, hsrp_handle);\r\ndissector_add_uint("udp.port", UDP_PORT_HSRP2_V6, hsrp_handle);\r\n}
