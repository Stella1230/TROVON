static guint\r\ndissect_moldudp64_msgblk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\r\nguint offset, guint64 sequence)\r\n{\r\nproto_item *ti;\r\nproto_tree *blk_tree;\r\nguint16 msglen, real_msglen, whole_len;\r\ngint remaining;\r\nif (tvb_length_remaining(tvb, offset) < MOLDUDP64_MSGLEN_LEN)\r\nreturn 0;\r\nmsglen = tvb_get_ntohs(tvb, offset);\r\nremaining = tvb_reported_length(tvb) - offset - MOLDUDP64_MSGLEN_LEN;\r\nif (remaining < 0)\r\nreal_msglen = 0;\r\nelse if (msglen <= remaining)\r\nreal_msglen = msglen;\r\nelse\r\nreal_msglen = remaining;\r\nwhole_len = real_msglen + MOLDUDP64_MSGLEN_LEN;\r\nti = proto_tree_add_item(tree, hf_moldudp64_msgblk,\r\ntvb, offset, whole_len, ENC_NA);\r\nblk_tree = proto_item_add_subtree(ti, ett_moldudp64_msgblk);\r\nti = proto_tree_add_uint64(blk_tree, hf_moldudp64_msgseq,\r\ntvb, offset, 0, sequence);\r\nPROTO_ITEM_SET_GENERATED(ti);\r\nti = proto_tree_add_item(blk_tree, hf_moldudp64_msglen,\r\ntvb, offset, MOLDUDP64_MSGLEN_LEN, ENC_BIG_ENDIAN);\r\nif (msglen != real_msglen)\r\nexpert_add_info_format(pinfo, ti, &ei_moldudp64_msglen_invalid,\r\n"Invalid Message Length (claimed %u, found %u)",\r\nmsglen, real_msglen);\r\noffset += MOLDUDP64_MSGLEN_LEN;\r\nproto_tree_add_item(blk_tree, hf_moldudp64_msgdata,\r\ntvb, offset, real_msglen, ENC_NA);\r\nreturn whole_len;\r\n}\r\nstatic int\r\ndissect_moldudp64(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\r\n{\r\nproto_item *ti;\r\nproto_tree *moldudp64_tree;\r\nguint offset = 0;\r\nguint16 count, real_count = 0;\r\nguint64 sequence;\r\nif (tvb_reported_length(tvb) < (MOLDUDP64_SESSION_LEN +\r\nMOLDUDP64_SEQUENCE_LEN +\r\nMOLDUDP64_COUNT_LEN))\r\nreturn 0;\r\ncol_set_str(pinfo->cinfo, COL_PROTOCOL, "MoldUDP64");\r\ncol_clear(pinfo->cinfo, COL_INFO);\r\nsequence = tvb_get_ntoh64(tvb, MOLDUDP64_SESSION_LEN);\r\ncount = tvb_get_ntohs(tvb, MOLDUDP64_SESSION_LEN + MOLDUDP64_SEQUENCE_LEN);\r\nif (count == MOLDUDP64_HEARTBEAT)\r\ncol_set_str(pinfo->cinfo, COL_INFO, "MoldUDP64 Heartbeat");\r\nelse if (count == MOLDUDP64_ENDOFSESS)\r\ncol_set_str(pinfo->cinfo, COL_INFO, "MoldUDP64 End Of Session");\r\nelse if (count > 0 && tvb_reported_length(tvb) == (MOLDUDP64_SESSION_LEN +\r\nMOLDUDP64_SEQUENCE_LEN +\r\nMOLDUDP64_COUNT_LEN))\r\ncol_set_str(pinfo->cinfo, COL_INFO, "MoldUDP64 Request");\r\nelse\r\ncol_set_str(pinfo->cinfo, COL_INFO, "MoldUDP64 Messages");\r\nti = proto_tree_add_item(tree, proto_moldudp64,\r\ntvb, offset, -1, ENC_NA);\r\nmoldudp64_tree = proto_item_add_subtree(ti, ett_moldudp64);\r\nproto_tree_add_item(moldudp64_tree, hf_moldudp64_session,\r\ntvb, offset, MOLDUDP64_SESSION_LEN, ENC_ASCII|ENC_NA);\r\noffset += MOLDUDP64_SESSION_LEN;\r\nproto_tree_add_item(moldudp64_tree, hf_moldudp64_sequence,\r\ntvb, offset, MOLDUDP64_SEQUENCE_LEN, ENC_BIG_ENDIAN);\r\noffset += MOLDUDP64_SEQUENCE_LEN;\r\nti = proto_tree_add_item(moldudp64_tree, hf_moldudp64_count,\r\ntvb, offset, MOLDUDP64_COUNT_LEN, ENC_BIG_ENDIAN);\r\noffset += MOLDUDP64_COUNT_LEN;\r\nwhile (tvb_reported_length(tvb) >= offset + MOLDUDP64_MSGLEN_LEN)\r\n{\r\noffset += dissect_moldudp64_msgblk(tvb, pinfo, moldudp64_tree,\r\noffset, sequence++);\r\nreal_count++;\r\n}\r\nif (count == MOLDUDP64_ENDOFSESS && real_count != 0)\r\n{\r\nexpert_add_info(pinfo, ti, &ei_moldudp64_end_of_session_extra);\r\n}\r\nelse if (count > 0 && real_count == 0)\r\n{\r\nexpert_add_info(pinfo, ti, &ei_moldudp64_request);\r\n}\r\nelse if (real_count != count)\r\n{\r\nexpert_add_info_format(pinfo, ti, &ei_moldudp64_count_invalid,\r\n"Invalid Message Count (claimed %u, found %u)",\r\ncount, real_count);\r\n}\r\nreturn tvb_length(tvb);\r\n}\r\nvoid\r\nproto_register_moldudp64(void)\r\n{\r\nmodule_t *moldudp64_module;\r\nstatic hf_register_info hf[] = {\r\n{ &hf_moldudp64_session,\r\n{ "Session", "moldudp64.session", FT_STRING, BASE_NONE, NULL, 0,\r\n"The session to which this packet belongs.", HFILL }},\r\n{ &hf_moldudp64_sequence,\r\n{ "Sequence", "moldudp64.sequence", FT_UINT64, BASE_DEC, NULL, 0,\r\n"The sequence number of the first message in this packet.", HFILL }},\r\n{ &hf_moldudp64_count,\r\n{ "Count", "moldudp64.count", FT_UINT16, BASE_DEC, NULL, 0,\r\n"The number of messages contained in this packet.", HFILL }},\r\n{ &hf_moldudp64_msgblk,\r\n{ "Message Block", "moldudp64.msgblock", FT_NONE, BASE_NONE, NULL, 0,\r\n"A message.", HFILL }},\r\n{ &hf_moldudp64_msglen,\r\n{ "Length", "moldudp64.msglen", FT_UINT16, BASE_DEC, NULL, 0,\r\n"The length of this message.", HFILL }},\r\n{ &hf_moldudp64_msgseq,\r\n{ "Sequence", "moldudp64.msgseq", FT_UINT64, BASE_DEC, NULL, 0,\r\n"The sequence number of this message.", HFILL }},\r\n{ &hf_moldudp64_msgdata,\r\n{ "Payload", "moldudp64.msgdata", FT_BYTES, BASE_NONE, NULL, 0,\r\n"The payload data of this message.", HFILL }}\r\n};\r\nstatic gint *ett[] = {\r\n&ett_moldudp64,\r\n&ett_moldudp64_msgblk\r\n};\r\nstatic ei_register_info ei[] = {\r\n{ &ei_moldudp64_msglen_invalid, { "moldudp64.msglen.invalid", PI_MALFORMED, PI_ERROR, "Invalid Message Length", EXPFILL }},\r\n{ &ei_moldudp64_end_of_session_extra, { "moldudp64.end_of_session_extra", PI_MALFORMED, PI_ERROR, "End Of Session packet with extra data.", EXPFILL }},\r\n{ &ei_moldudp64_count_invalid, { "moldudp64.count.invalid", PI_MALFORMED, PI_ERROR, "Invalid Message Count", EXPFILL }},\r\n{ &ei_moldudp64_request, { "moldudp64.request", PI_COMMENTS_GROUP, PI_COMMENT, "Number of Requested Messages", EXPFILL }},\r\n};\r\nexpert_module_t* expert_moldudp64;\r\nproto_moldudp64 = proto_register_protocol("MoldUDP64",\r\n"MoldUDP64", "moldudp64");\r\nproto_register_field_array(proto_moldudp64, hf, array_length(hf));\r\nproto_register_subtree_array(ett, array_length(ett));\r\nexpert_moldudp64 = expert_register_protocol(proto_moldudp64);\r\nexpert_register_field_array(expert_moldudp64, ei, array_length(ei));\r\nmoldudp64_module = prefs_register_protocol(proto_moldudp64,\r\nproto_reg_handoff_moldudp64);\r\nprefs_register_uint_preference(moldudp64_module, "udp.port", "MoldUDP64 UDP Port",\r\n"MoldUDP64 UDP port to dissect on.",\r\n10, &pf_moldudp64_port);\r\n}\r\nvoid\r\nproto_reg_handoff_moldudp64(void)\r\n{\r\nstatic gboolean initialized = FALSE;\r\nstatic dissector_handle_t moldudp64_handle;\r\nstatic int currentPort;\r\nif (!initialized) {\r\nmoldudp64_handle = new_create_dissector_handle(dissect_moldudp64,\r\nproto_moldudp64);\r\ninitialized = TRUE;\r\n} else {\r\ndissector_delete_uint("udp.port", currentPort, moldudp64_handle);\r\n}\r\ncurrentPort = pf_moldudp64_port;\r\ndissector_add_uint("udp.port", currentPort, moldudp64_handle);\r\n}
