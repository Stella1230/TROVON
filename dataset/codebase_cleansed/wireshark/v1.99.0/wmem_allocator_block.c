static int\r\nwmem_block_verify_block(wmem_block_hdr_t *block)\r\n{\r\nint total_free_space = 0;\r\nguint32 total_len;\r\nwmem_block_chunk_t *chunk;\r\nchunk = WMEM_BLOCK_TO_CHUNK(block);\r\ntotal_len = WMEM_BLOCK_HEADER_SIZE;\r\nif (chunk->jumbo) {\r\nreturn 0;\r\n}\r\ng_assert(chunk->prev == 0);\r\ndo {\r\ntotal_len += chunk->len;\r\ng_assert(chunk->len >= WMEM_CHUNK_HEADER_SIZE);\r\ng_assert(!chunk->jumbo);\r\nif (WMEM_CHUNK_NEXT(chunk)) {\r\ng_assert(chunk->len == WMEM_CHUNK_NEXT(chunk)->prev);\r\n}\r\nif (!chunk->used &&\r\nWMEM_CHUNK_DATA_LEN(chunk) >= sizeof(wmem_block_free_t)) {\r\ntotal_free_space += chunk->len;\r\nif (!chunk->last) {\r\ng_assert(WMEM_GET_FREE(chunk)->next);\r\ng_assert(WMEM_GET_FREE(chunk)->prev);\r\n}\r\n}\r\nchunk = WMEM_CHUNK_NEXT(chunk);\r\n} while (chunk);\r\ng_assert(total_len == WMEM_BLOCK_SIZE);\r\nreturn total_free_space;\r\n}\r\nstatic int\r\nwmem_block_verify_master_list(wmem_block_allocator_t *allocator)\r\n{\r\nwmem_block_chunk_t *cur;\r\nwmem_block_free_t *cur_free;\r\nint free_space = 0;\r\ncur = allocator->master_head;\r\nif (!cur) {\r\nreturn 0;\r\n}\r\ng_assert(WMEM_GET_FREE(cur)->prev == NULL);\r\nwhile (cur) {\r\nfree_space += cur->len;\r\ncur_free = WMEM_GET_FREE(cur);\r\ng_assert(! cur->used);\r\nif (cur_free->next) {\r\ng_assert(WMEM_GET_FREE(cur_free->next)->prev == cur);\r\n}\r\nif (cur != allocator->master_head) {\r\ng_assert(cur->len == WMEM_BLOCK_SIZE);\r\n}\r\ncur = cur_free->next;\r\n}\r\nreturn free_space;\r\n}\r\nstatic int\r\nwmem_block_verify_recycler(wmem_block_allocator_t *allocator)\r\n{\r\nwmem_block_chunk_t *cur;\r\nwmem_block_free_t *cur_free;\r\nint free_space = 0;\r\ncur = allocator->recycler_head;\r\nif (!cur) {\r\nreturn 0;\r\n}\r\ndo {\r\nfree_space += cur->len;\r\ncur_free = WMEM_GET_FREE(cur);\r\ng_assert(! cur->used);\r\ng_assert(cur_free->prev);\r\ng_assert(cur_free->next);\r\ng_assert(WMEM_GET_FREE(cur_free->prev)->next == cur);\r\ng_assert(WMEM_GET_FREE(cur_free->next)->prev == cur);\r\ncur = cur_free->next;\r\n} while (cur != allocator->recycler_head);\r\nreturn free_space;\r\n}\r\nvoid\r\nwmem_block_verify(wmem_allocator_t *allocator)\r\n{\r\nwmem_block_hdr_t *cur;\r\nwmem_block_allocator_t *private_allocator;\r\nint master_free, recycler_free, chunk_free = 0;\r\ng_assert(allocator->type == WMEM_ALLOCATOR_BLOCK);\r\nprivate_allocator = (wmem_block_allocator_t*) allocator->private_data;\r\nif (private_allocator->block_list == NULL) {\r\ng_assert(! private_allocator->master_head);\r\ng_assert(! private_allocator->recycler_head);\r\nreturn;\r\n}\r\nmaster_free = wmem_block_verify_master_list(private_allocator);\r\nrecycler_free = wmem_block_verify_recycler(private_allocator);\r\ncur = private_allocator->block_list;\r\ng_assert(cur->prev == NULL);\r\nwhile (cur) {\r\nif (cur->next) {\r\ng_assert(cur->next->prev == cur);\r\n}\r\nchunk_free += wmem_block_verify_block(cur);\r\ncur = cur->next;\r\n}\r\ng_assert(chunk_free == master_free + recycler_free);\r\n}\r\nstatic void\r\nwmem_block_cycle_recycler(wmem_block_allocator_t *allocator)\r\n{\r\nwmem_block_chunk_t *chunk;\r\nwmem_block_free_t *free_chunk;\r\nchunk = allocator->recycler_head;\r\nif (chunk == NULL) {\r\nreturn;\r\n}\r\nfree_chunk = WMEM_GET_FREE(chunk);\r\nif (free_chunk->next->len < chunk->len) {\r\nWMEM_GET_FREE(free_chunk->next)->prev = free_chunk->prev;\r\nWMEM_GET_FREE(free_chunk->prev)->next = free_chunk->next;\r\nfree_chunk->prev = free_chunk->next;\r\nfree_chunk->next = WMEM_GET_FREE(free_chunk->next)->next;\r\nWMEM_GET_FREE(free_chunk->next)->prev = chunk;\r\nWMEM_GET_FREE(free_chunk->prev)->next = chunk;\r\n}\r\nelse {\r\nallocator->recycler_head = free_chunk->next;\r\n}\r\n}\r\nstatic void\r\nwmem_block_add_to_recycler(wmem_block_allocator_t *allocator,\r\nwmem_block_chunk_t *chunk)\r\n{\r\nwmem_block_free_t *free_chunk;\r\nif (WMEM_CHUNK_DATA_LEN(chunk) < sizeof(wmem_block_free_t)) {\r\nreturn;\r\n}\r\nfree_chunk = WMEM_GET_FREE(chunk);\r\nif (! allocator->recycler_head) {\r\nfree_chunk->next = chunk;\r\nfree_chunk->prev = chunk;\r\nallocator->recycler_head = chunk;\r\n}\r\nelse {\r\nfree_chunk->next = allocator->recycler_head;\r\nfree_chunk->prev = WMEM_GET_FREE(allocator->recycler_head)->prev;\r\nWMEM_GET_FREE(free_chunk->next)->prev = chunk;\r\nWMEM_GET_FREE(free_chunk->prev)->next = chunk;\r\nif (chunk->len > allocator->recycler_head->len) {\r\nallocator->recycler_head = chunk;\r\n}\r\n}\r\n}\r\nstatic void\r\nwmem_block_remove_from_recycler(wmem_block_allocator_t *allocator,\r\nwmem_block_chunk_t *chunk)\r\n{\r\nwmem_block_free_t *free_chunk;\r\nfree_chunk = WMEM_GET_FREE(chunk);\r\nif (free_chunk->prev == chunk && free_chunk->next == chunk) {\r\nallocator->recycler_head = NULL;\r\n}\r\nelse {\r\nWMEM_GET_FREE(free_chunk->prev)->next = free_chunk->next;\r\nWMEM_GET_FREE(free_chunk->next)->prev = free_chunk->prev;\r\nif (allocator->recycler_head == chunk) {\r\nallocator->recycler_head = free_chunk->next;\r\n}\r\n}\r\n}\r\nstatic void\r\nwmem_block_push_master(wmem_block_allocator_t *allocator,\r\nwmem_block_chunk_t *chunk)\r\n{\r\nwmem_block_free_t *free_chunk;\r\nfree_chunk = WMEM_GET_FREE(chunk);\r\nfree_chunk->prev = NULL;\r\nfree_chunk->next = allocator->master_head;\r\nif (free_chunk->next) {\r\nWMEM_GET_FREE(free_chunk->next)->prev = chunk;\r\n}\r\nallocator->master_head = chunk;\r\n}\r\nstatic void\r\nwmem_block_pop_master(wmem_block_allocator_t *allocator)\r\n{\r\nwmem_block_chunk_t *chunk;\r\nwmem_block_free_t *free_chunk;\r\nchunk = allocator->master_head;\r\nfree_chunk = WMEM_GET_FREE(chunk);\r\nallocator->master_head = free_chunk->next;\r\nif (free_chunk->next) {\r\nWMEM_GET_FREE(free_chunk->next)->prev = NULL;\r\n}\r\n}\r\nstatic void\r\nwmem_block_merge_free(wmem_block_allocator_t *allocator,\r\nwmem_block_chunk_t *chunk)\r\n{\r\nwmem_block_chunk_t *tmp;\r\nwmem_block_chunk_t *left_free = NULL;\r\nwmem_block_chunk_t *right_free = NULL;\r\ntmp = WMEM_CHUNK_NEXT(chunk);\r\nif (tmp && !tmp->used) {\r\nif (WMEM_CHUNK_DATA_LEN(tmp) >= sizeof(wmem_block_free_t)) {\r\nright_free = tmp;\r\n}\r\nchunk->len += tmp->len;\r\nchunk->last = tmp->last;\r\n}\r\ntmp = WMEM_CHUNK_PREV(chunk);\r\nif (tmp && !tmp->used) {\r\nif (WMEM_CHUNK_DATA_LEN(tmp) >= sizeof(wmem_block_free_t)) {\r\nleft_free = tmp;\r\n}\r\ntmp->len += chunk->len;\r\ntmp->last = chunk->last;\r\nchunk = tmp;\r\n}\r\nif (!chunk->last) {\r\nWMEM_CHUNK_NEXT(chunk)->prev = chunk->len;\r\n}\r\nif (right_free && right_free == allocator->master_head) {\r\nwmem_block_free_t *moved;\r\nif (left_free) {\r\nwmem_block_remove_from_recycler(allocator, left_free);\r\n}\r\nmoved = WMEM_GET_FREE(chunk);\r\nmoved->prev = NULL;\r\nmoved->next = WMEM_GET_FREE(right_free)->next;\r\nallocator->master_head = chunk;\r\nif (moved->next) {\r\nWMEM_GET_FREE(moved->next)->prev = chunk;\r\n}\r\n}\r\nelse {\r\nif (right_free) {\r\nwmem_block_remove_from_recycler(allocator, right_free);\r\n}\r\nif (!left_free) {\r\nwmem_block_add_to_recycler(allocator, chunk);\r\n}\r\n}\r\n}\r\nstatic void\r\nwmem_block_split_free_chunk(wmem_block_allocator_t *allocator,\r\nwmem_block_chunk_t *chunk,\r\nconst size_t size)\r\n{\r\nwmem_block_chunk_t *extra;\r\nwmem_block_free_t *old_blk, *new_blk;\r\nsize_t aligned_size, available;\r\ngboolean last;\r\naligned_size = WMEM_ALIGN_SIZE(size) + WMEM_CHUNK_HEADER_SIZE;\r\nif (WMEM_CHUNK_DATA_LEN(chunk) < aligned_size + sizeof(wmem_block_free_t)) {\r\nif (chunk == allocator->master_head) {\r\nwmem_block_pop_master(allocator);\r\n}\r\nelse {\r\nwmem_block_remove_from_recycler(allocator, chunk);\r\n}\r\nreturn;\r\n}\r\nlast = chunk->last;\r\navailable = chunk->len - aligned_size;\r\nchunk->len = (guint32) aligned_size;\r\nchunk->last = FALSE;\r\nextra = WMEM_CHUNK_NEXT(chunk);\r\nold_blk = WMEM_GET_FREE(chunk);\r\nnew_blk = WMEM_GET_FREE(extra);\r\nif (allocator->master_head == chunk) {\r\nnew_blk->prev = old_blk->prev;\r\nnew_blk->next = old_blk->next;\r\nif (old_blk->next) {\r\nWMEM_GET_FREE(old_blk->next)->prev = extra;\r\n}\r\nallocator->master_head = extra;\r\n}\r\nelse {\r\nif (old_blk->prev == chunk) {\r\nnew_blk->prev = extra;\r\nnew_blk->next = extra;\r\n}\r\nelse {\r\nnew_blk->prev = old_blk->prev;\r\nnew_blk->next = old_blk->next;\r\nWMEM_GET_FREE(old_blk->prev)->next = extra;\r\nWMEM_GET_FREE(old_blk->next)->prev = extra;\r\n}\r\nif (allocator->recycler_head == chunk) {\r\nallocator->recycler_head = extra;\r\n}\r\n}\r\nextra->len = (guint32) available;\r\nextra->last = last;\r\nextra->prev = chunk->len;\r\nextra->used = FALSE;\r\nextra->jumbo = FALSE;\r\nif (!last) {\r\nWMEM_CHUNK_NEXT(extra)->prev = extra->len;\r\n}\r\n}\r\nstatic void\r\nwmem_block_split_used_chunk(wmem_block_allocator_t *allocator,\r\nwmem_block_chunk_t *chunk,\r\nconst size_t size)\r\n{\r\nwmem_block_chunk_t *extra;\r\nsize_t aligned_size, available;\r\ngboolean last;\r\naligned_size = WMEM_ALIGN_SIZE(size) + WMEM_CHUNK_HEADER_SIZE;\r\nif (aligned_size > WMEM_CHUNK_DATA_LEN(chunk)) {\r\nreturn;\r\n}\r\nlast = chunk->last;\r\navailable = chunk->len - aligned_size;\r\nchunk->len = (guint32) aligned_size;\r\nchunk->last = FALSE;\r\nextra = WMEM_CHUNK_NEXT(chunk);\r\nextra->len = (guint32) available;\r\nextra->last = last;\r\nextra->prev = chunk->len;\r\nextra->used = FALSE;\r\nextra->jumbo = FALSE;\r\nif (!last) {\r\nWMEM_CHUNK_NEXT(extra)->prev = extra->len;\r\n}\r\nwmem_block_merge_free(allocator, extra);\r\n}\r\nstatic void\r\nwmem_block_add_to_block_list(wmem_block_allocator_t *allocator,\r\nwmem_block_hdr_t *block)\r\n{\r\nblock->prev = NULL;\r\nblock->next = allocator->block_list;\r\nif (block->next) {\r\nblock->next->prev = block;\r\n}\r\nallocator->block_list = block;\r\n}\r\nstatic void\r\nwmem_block_remove_from_block_list(wmem_block_allocator_t *allocator,\r\nwmem_block_hdr_t *block)\r\n{\r\nif (block->prev) {\r\nblock->prev->next = block->next;\r\n}\r\nelse {\r\nallocator->block_list = block->next;\r\n}\r\nif (block->next) {\r\nblock->next->prev = block->prev;\r\n}\r\n}\r\nstatic void\r\nwmem_block_init_block(wmem_block_allocator_t *allocator,\r\nwmem_block_hdr_t *block)\r\n{\r\nwmem_block_chunk_t *chunk;\r\nchunk = WMEM_BLOCK_TO_CHUNK(block);\r\nchunk->used = FALSE;\r\nchunk->jumbo = FALSE;\r\nchunk->last = TRUE;\r\nchunk->prev = 0;\r\nchunk->len = WMEM_BLOCK_SIZE - WMEM_BLOCK_HEADER_SIZE;\r\nwmem_block_push_master(allocator, chunk);\r\n}\r\nstatic void\r\nwmem_block_new_block(wmem_block_allocator_t *allocator)\r\n{\r\nwmem_block_hdr_t *block;\r\nblock = (wmem_block_hdr_t *)wmem_alloc(NULL, WMEM_BLOCK_SIZE);\r\nwmem_block_add_to_block_list(allocator, block);\r\nwmem_block_init_block(allocator, block);\r\n}\r\nstatic void *\r\nwmem_block_alloc_jumbo(wmem_block_allocator_t *allocator, const size_t size)\r\n{\r\nwmem_block_hdr_t *block;\r\nwmem_block_chunk_t *chunk;\r\nblock = (wmem_block_hdr_t *) wmem_alloc(NULL, size\r\n+ WMEM_BLOCK_HEADER_SIZE\r\n+ WMEM_CHUNK_HEADER_SIZE);\r\nwmem_block_add_to_block_list(allocator, block);\r\nchunk = WMEM_BLOCK_TO_CHUNK(block);\r\nchunk->last = TRUE;\r\nchunk->used = TRUE;\r\nchunk->jumbo = TRUE;\r\nchunk->len = 0;\r\nchunk->prev = 0;\r\nreturn WMEM_CHUNK_TO_DATA(chunk);\r\n}\r\nstatic void\r\nwmem_block_free_jumbo(wmem_block_allocator_t *allocator,\r\nwmem_block_chunk_t *chunk)\r\n{\r\nwmem_block_hdr_t *block;\r\nblock = WMEM_CHUNK_TO_BLOCK(chunk);\r\nwmem_block_remove_from_block_list(allocator, block);\r\nwmem_free(NULL, block);\r\n}\r\nstatic void *\r\nwmem_block_realloc_jumbo(wmem_block_allocator_t *allocator,\r\nwmem_block_chunk_t *chunk,\r\nconst size_t size)\r\n{\r\nwmem_block_hdr_t *block;\r\nblock = WMEM_CHUNK_TO_BLOCK(chunk);\r\nblock = (wmem_block_hdr_t *) wmem_realloc(NULL, block, size\r\n+ WMEM_BLOCK_HEADER_SIZE\r\n+ WMEM_CHUNK_HEADER_SIZE);\r\nif (block->next) {\r\nblock->next->prev = block;\r\n}\r\nif (block->prev) {\r\nblock->prev->next = block;\r\n}\r\nelse {\r\nallocator->block_list = block;\r\n}\r\nreturn WMEM_CHUNK_TO_DATA(WMEM_BLOCK_TO_CHUNK(block));\r\n}\r\nstatic void *\r\nwmem_block_alloc(void *private_data, const size_t size)\r\n{\r\nwmem_block_allocator_t *allocator = (wmem_block_allocator_t*) private_data;\r\nwmem_block_chunk_t *chunk;\r\nif (size > WMEM_BLOCK_MAX_ALLOC_SIZE) {\r\nreturn wmem_block_alloc_jumbo(allocator, size);\r\n}\r\nif (allocator->recycler_head &&\r\nWMEM_CHUNK_DATA_LEN(allocator->recycler_head) >= size) {\r\nchunk = allocator->recycler_head;\r\n}\r\nelse {\r\nif (allocator->master_head &&\r\nWMEM_CHUNK_DATA_LEN(allocator->master_head) < size) {\r\nchunk = allocator->master_head;\r\nwmem_block_pop_master(allocator);\r\nwmem_block_add_to_recycler(allocator, chunk);\r\n}\r\nif (!allocator->master_head) {\r\nwmem_block_new_block(allocator);\r\n}\r\nchunk = allocator->master_head;\r\n}\r\nwmem_block_split_free_chunk(allocator, chunk, size);\r\nwmem_block_cycle_recycler(allocator);\r\nchunk->used = TRUE;\r\nreturn WMEM_CHUNK_TO_DATA(chunk);\r\n}\r\nstatic void\r\nwmem_block_free(void *private_data, void *ptr)\r\n{\r\nwmem_block_allocator_t *allocator = (wmem_block_allocator_t*) private_data;\r\nwmem_block_chunk_t *chunk;\r\nchunk = WMEM_DATA_TO_CHUNK(ptr);\r\nif (chunk->jumbo) {\r\nwmem_block_free_jumbo(allocator, chunk);\r\nreturn;\r\n}\r\nchunk->used = FALSE;\r\nwmem_block_merge_free(allocator, chunk);\r\nwmem_block_cycle_recycler(allocator);\r\n}\r\nstatic void *\r\nwmem_block_realloc(void *private_data, void *ptr, const size_t size)\r\n{\r\nwmem_block_allocator_t *allocator = (wmem_block_allocator_t*) private_data;\r\nwmem_block_chunk_t *chunk;\r\nchunk = WMEM_DATA_TO_CHUNK(ptr);\r\nif (chunk->jumbo) {\r\nreturn wmem_block_realloc_jumbo(allocator, chunk, size);\r\n}\r\nif (size > WMEM_CHUNK_DATA_LEN(chunk)) {\r\nwmem_block_chunk_t *tmp;\r\ntmp = WMEM_CHUNK_NEXT(chunk);\r\nif (tmp && (!tmp->used) &&\r\n(size < WMEM_CHUNK_DATA_LEN(chunk) + tmp->len)) {\r\nsize_t split_size;\r\nsplit_size = size - WMEM_CHUNK_DATA_LEN(chunk);\r\nif (split_size < WMEM_CHUNK_HEADER_SIZE) {\r\nsplit_size = 0;\r\n}\r\nelse {\r\nsplit_size -= WMEM_CHUNK_HEADER_SIZE;\r\n}\r\nwmem_block_split_free_chunk(allocator, tmp, split_size);\r\nchunk->len += tmp->len;\r\nchunk->last = tmp->last;\r\ntmp = WMEM_CHUNK_NEXT(chunk);\r\nif (tmp) {\r\ntmp->prev = chunk->len;\r\n}\r\nwmem_block_cycle_recycler(allocator);\r\nreturn ptr;\r\n}\r\nelse {\r\nvoid *newptr;\r\nnewptr = wmem_block_alloc(private_data, size);\r\nmemcpy(newptr, ptr, WMEM_CHUNK_DATA_LEN(chunk));\r\nwmem_block_free(private_data, ptr);\r\nreturn newptr;\r\n}\r\n}\r\nelse if (size < WMEM_CHUNK_DATA_LEN(chunk)) {\r\nwmem_block_split_used_chunk(allocator, chunk, size);\r\nwmem_block_cycle_recycler(allocator);\r\nreturn ptr;\r\n}\r\nreturn ptr;\r\n}\r\nstatic void\r\nwmem_block_free_all(void *private_data)\r\n{\r\nwmem_block_allocator_t *allocator = (wmem_block_allocator_t*) private_data;\r\nwmem_block_hdr_t *cur;\r\nwmem_block_chunk_t *chunk;\r\nallocator->master_head = NULL;\r\nallocator->recycler_head = NULL;\r\ncur = allocator->block_list;\r\nwhile (cur) {\r\nchunk = WMEM_BLOCK_TO_CHUNK(cur);\r\nif (chunk->jumbo) {\r\nwmem_block_remove_from_block_list(allocator, cur);\r\ncur = cur->next;\r\nwmem_free(NULL, WMEM_CHUNK_TO_BLOCK(chunk));\r\n}\r\nelse {\r\nwmem_block_init_block(allocator, cur);\r\ncur = cur->next;\r\n}\r\n}\r\n}\r\nstatic void\r\nwmem_block_gc(void *private_data)\r\n{\r\nwmem_block_allocator_t *allocator = (wmem_block_allocator_t*) private_data;\r\nwmem_block_hdr_t *cur, *next;\r\nwmem_block_chunk_t *chunk;\r\nwmem_block_free_t *free_chunk;\r\ncur = allocator->block_list;\r\nallocator->block_list = NULL;\r\nwhile (cur) {\r\nchunk = WMEM_BLOCK_TO_CHUNK(cur);\r\nnext = cur->next;\r\nif (!chunk->jumbo && !chunk->used && chunk->last) {\r\nfree_chunk = WMEM_GET_FREE(chunk);\r\nif (free_chunk->next) {\r\nWMEM_GET_FREE(free_chunk->next)->prev = free_chunk->prev;\r\n}\r\nif (free_chunk->prev) {\r\nWMEM_GET_FREE(free_chunk->prev)->next = free_chunk->next;\r\n}\r\nif (allocator->recycler_head == chunk) {\r\nif (free_chunk->next == chunk) {\r\nallocator->recycler_head = NULL;\r\n}\r\nelse {\r\nallocator->recycler_head = free_chunk->next;\r\n}\r\n}\r\nelse if (allocator->master_head == chunk) {\r\nallocator->master_head = free_chunk->next;\r\n}\r\nwmem_free(NULL, cur);\r\n}\r\nelse {\r\nwmem_block_add_to_block_list(allocator, cur);\r\n}\r\ncur = next;\r\n}\r\n}\r\nstatic void\r\nwmem_block_allocator_cleanup(void *private_data)\r\n{\r\nwmem_block_gc(private_data);\r\nwmem_free(NULL, private_data);\r\n}\r\nvoid\r\nwmem_block_allocator_init(wmem_allocator_t *allocator)\r\n{\r\nwmem_block_allocator_t *block_allocator;\r\nblock_allocator = wmem_new(NULL, wmem_block_allocator_t);\r\nallocator->alloc = &wmem_block_alloc;\r\nallocator->realloc = &wmem_block_realloc;\r\nallocator->free = &wmem_block_free;\r\nallocator->free_all = &wmem_block_free_all;\r\nallocator->gc = &wmem_block_gc;\r\nallocator->cleanup = &wmem_block_allocator_cleanup;\r\nallocator->private_data = (void*) block_allocator;\r\nblock_allocator->block_list = NULL;\r\nblock_allocator->master_head = NULL;\r\nblock_allocator->recycler_head = NULL;\r\n}
