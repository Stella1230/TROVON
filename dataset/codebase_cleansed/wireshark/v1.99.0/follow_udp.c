static int\r\nudp_queue_packet_data(void *tapdata, packet_info *pinfo,\r\nepan_dissect_t *edt _U_, const void *data)\r\n{\r\nfollow_record_t *follow_record;\r\nfollow_info_t *follow_info = (follow_info_t *)tapdata;\r\ntvbuff_t *next_tvb = (tvbuff_t *)data;\r\nfollow_record = g_new(follow_record_t,1);\r\nfollow_record->data = g_byte_array_sized_new(tvb_captured_length(next_tvb));\r\nfollow_record->data = g_byte_array_append(follow_record->data,\r\ntvb_get_ptr(next_tvb, 0, -1),\r\ntvb_captured_length(next_tvb));\r\nif (follow_info->client_port == 0) {\r\nfollow_info->client_port = pinfo->srcport;\r\nCOPY_ADDRESS(&follow_info->client_ip, &pinfo->src);\r\n}\r\nif (ADDRESSES_EQUAL(&follow_info->client_ip, &pinfo->src) && follow_info->client_port == pinfo->srcport)\r\nfollow_record->is_server = FALSE;\r\nelse\r\nfollow_record->is_server = TRUE;\r\nfollow_info->bytes_written[follow_record->is_server] += follow_record->data->len;\r\nfollow_info->payload = g_list_append(follow_info->payload, follow_record);\r\nreturn 0;\r\n}\r\nvoid\r\nfollow_udp_stream_cb(GtkWidget *w _U_, gpointer data _U_)\r\n{\r\nGtkWidget *filter_te, *filter_cm;\r\ngchar *follow_filter;\r\nconst gchar *previous_filter;\r\nint filter_out_filter_len, previous_filter_len;\r\nconst char *hostname0, *hostname1;\r\nchar *port0, *port1;\r\ngchar *server_to_client_string = NULL;\r\ngchar *client_to_server_string = NULL;\r\ngchar *both_directions_string = NULL;\r\nfollow_stats_t stats;\r\nfollow_info_t *follow_info;\r\nGString *msg;\r\ngboolean is_udp = FALSE;\r\nproto_get_frame_protocols(cfile.edt->pi.layers, NULL, NULL, &is_udp, NULL, NULL);\r\nif (!is_udp) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Error following stream. Please make\n"\r\n"sure you have a UDP packet selected.");\r\nreturn;\r\n}\r\nfollow_info = g_new0(follow_info_t, 1);\r\nfollow_info->follow_type = FOLLOW_UDP;\r\nfollow_filter = build_follow_conv_filter(&cfile.edt->pi);\r\nif (!follow_filter)\r\n{\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Error creating filter for this stream.\n"\r\n"A network layer header is needed");\r\ng_free(follow_info);\r\nreturn;\r\n}\r\nfilter_cm = (GtkWidget *)g_object_get_data(G_OBJECT(top_level), E_DFILTER_CM_KEY);\r\nfilter_te = gtk_bin_get_child(GTK_BIN(filter_cm));\r\nfollow_info->filter_te = filter_te;\r\nprevious_filter =\r\n(const gchar *)gtk_entry_get_text(GTK_ENTRY(filter_te));\r\nprevious_filter_len = previous_filter?(int)strlen(previous_filter):0;\r\nfilter_out_filter_len = (int)strlen(follow_filter) + previous_filter_len + 16;\r\nfollow_info->filter_out_filter = (gchar *)g_malloc(filter_out_filter_len);\r\nif(previous_filter_len) {\r\ng_snprintf(follow_info->filter_out_filter, filter_out_filter_len,\r\n"%s and !(%s)", previous_filter, follow_filter);\r\n} else {\r\ng_snprintf(follow_info->filter_out_filter, filter_out_filter_len,\r\n"!(%s)", follow_filter);\r\n}\r\nmsg = register_tap_listener("udp_follow", follow_info, follow_filter,\r\n0, NULL, udp_queue_packet_data, NULL);\r\nif (msg) {\r\nsimple_dialog(ESD_TYPE_ERROR, ESD_BTN_OK,\r\n"Can't register udp_follow tap: %s\n",\r\nmsg->str);\r\ng_free(follow_info->filter_out_filter);\r\ng_free(follow_info);\r\ng_free(follow_filter);\r\nreturn;\r\n}\r\ngtk_entry_set_text(GTK_ENTRY(filter_te), follow_filter);\r\nmain_filter_packets(&cfile, follow_filter, TRUE);\r\ng_free(follow_filter);\r\nremove_tap_listener(follow_info);\r\nfollow_stats(&stats);\r\nif (stats.is_ipv6) {\r\nstruct e_in6_addr ipaddr;\r\nmemcpy(&ipaddr, stats.ip_address[0], 16);\r\nhostname0 = get_hostname6(&ipaddr);\r\nmemcpy(&ipaddr, stats.ip_address[1], 16);\r\nhostname1 = get_hostname6(&ipaddr);\r\n} else {\r\nguint32 ipaddr;\r\nmemcpy(&ipaddr, stats.ip_address[0], 4);\r\nhostname0 = get_hostname(ipaddr);\r\nmemcpy(&ipaddr, stats.ip_address[1], 4);\r\nhostname1 = get_hostname(ipaddr);\r\n}\r\nport0 = ep_udp_port_to_display(stats.port[0]);\r\nport1 = ep_udp_port_to_display(stats.port[1]);\r\nfollow_info->is_ipv6 = stats.is_ipv6;\r\nboth_directions_string = g_strdup_printf("Entire conversation (%u bytes)", follow_info->bytes_written[0] + follow_info->bytes_written[1]);\r\nif ((follow_info->client_port == stats.port[0]) &&\r\n((stats.is_ipv6 && (memcmp(follow_info->client_ip.data, stats.ip_address[0], 16) == 0)) ||\r\n(!stats.is_ipv6 && (memcmp(follow_info->client_ip.data, stats.ip_address[0], 4) == 0)))) {\r\nserver_to_client_string =\r\ng_strdup_printf("%s:%s " UTF8_RIGHTWARDS_ARROW " %s:%s (%u bytes)",\r\nhostname0, port0,\r\nhostname1, port1,\r\nfollow_info->bytes_written[0]);\r\nclient_to_server_string =\r\ng_strdup_printf("%s:%s " UTF8_RIGHTWARDS_ARROW " %s:%s (%u bytes)",\r\nhostname1, port1,\r\nhostname0, port0,\r\nfollow_info->bytes_written[1]);\r\n} else {\r\nserver_to_client_string =\r\ng_strdup_printf("%s:%s " UTF8_RIGHTWARDS_ARROW " %s:%s (%u bytes)",\r\nhostname1, port1,\r\nhostname0, port0,\r\nfollow_info->bytes_written[0]);\r\nclient_to_server_string =\r\ng_strdup_printf("%s:%s " UTF8_RIGHTWARDS_ARROW " %s:%s (%u bytes)",\r\nhostname0, port0,\r\nhostname1, port1,\r\nfollow_info->bytes_written[1]);\r\n}\r\nfollow_stream("Follow UDP Stream", follow_info, both_directions_string,\r\nserver_to_client_string, client_to_server_string);\r\ng_free(both_directions_string);\r\ng_free(server_to_client_string);\r\ng_free(client_to_server_string);\r\n}\r\nfrs_return_t\r\nfollow_read_udp_stream(follow_info_t *follow_info,\r\ngboolean (*print_line_fcn_p)(char *, size_t, gboolean, void *),\r\nvoid *arg)\r\n{\r\nguint32 global_client_pos = 0, global_server_pos = 0;\r\nguint32 server_packet_count = 0;\r\nguint32 client_packet_count = 0;\r\nguint32 *global_pos;\r\ngboolean skip;\r\nGList* cur;\r\nfrs_return_t frs_return;\r\nfollow_record_t *follow_record;\r\nchar *buffer;\r\nfor (cur = follow_info->payload; cur; cur = g_list_next(cur)) {\r\nfollow_record = (follow_record_t *)cur->data;\r\nskip = FALSE;\r\nif (!follow_record->is_server) {\r\nglobal_pos = &global_client_pos;\r\nif(follow_info->show_stream == FROM_SERVER) {\r\nskip = TRUE;\r\n}\r\n} else {\r\nglobal_pos = &global_server_pos;\r\nif (follow_info->show_stream == FROM_CLIENT) {\r\nskip = TRUE;\r\n}\r\n}\r\nif (!skip) {\r\nbuffer = (char *)g_memdup(follow_record->data->data,\r\nfollow_record->data->len);\r\nfrs_return = follow_show(follow_info, print_line_fcn_p,\r\nbuffer,\r\nfollow_record->data->len,\r\nfollow_record->is_server, arg,\r\nglobal_pos,\r\n&server_packet_count,\r\n&client_packet_count);\r\ng_free(buffer);\r\nif(frs_return == FRS_PRINT_ERROR)\r\nreturn frs_return;\r\n}\r\n}\r\nreturn FRS_OK;\r\n}
