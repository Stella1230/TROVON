static gboolean\r\ncheck_for_tap_plugin(GModule *handle)\r\n{\r\ngpointer gp;\r\nvoid (*register_tap_listener_fn)(void);\r\ntap_plugin *plugin;\r\nif (!g_module_symbol(handle, "plugin_register_tap_listener", &gp)) {\r\nreturn FALSE;\r\n}\r\nregister_tap_listener_fn = (void (*)(void))gp;\r\nplugin = (tap_plugin *)g_malloc(sizeof (tap_plugin));\r\nplugin->register_tap_listener_fn = register_tap_listener_fn;\r\ntap_plugins = g_slist_append(tap_plugins, plugin);\r\nreturn TRUE;\r\n}\r\nvoid\r\nregister_tap_plugin_type(void)\r\n{\r\nadd_plugin_type("tap", check_for_tap_plugin);\r\n}\r\nstatic void\r\nregister_tap_plugin_listener(gpointer data, gpointer user_data _U_)\r\n{\r\ntap_plugin *plugin = (tap_plugin *)data;\r\n(plugin->register_tap_listener_fn)();\r\n}\r\nvoid\r\nregister_all_plugin_tap_listeners(void)\r\n{\r\ng_slist_foreach(tap_plugins, register_tap_plugin_listener, NULL);\r\n}\r\nvoid\r\ntap_init(void)\r\n{\r\ntap_packet_index=0;\r\n}\r\nint\r\nregister_tap(const char *name)\r\n{\r\ntap_dissector_t *td, *tdl;\r\nint i, tap_id;\r\nif(tap_dissector_list){\r\ntap_id=find_tap_id(name);\r\nif (tap_id)\r\nreturn tap_id;\r\n}\r\ntd=(tap_dissector_t *)g_malloc(sizeof(tap_dissector_t));\r\ntd->next=NULL;\r\ntd->name = g_strdup(name);\r\nif(!tap_dissector_list){\r\ntap_dissector_list=td;\r\ni=1;\r\n} else {\r\nfor(i=2,tdl=tap_dissector_list;tdl->next;i++,tdl=tdl->next)\r\n;\r\ntdl->next=td;\r\n}\r\nreturn i;\r\n}\r\nvoid\r\ntap_queue_packet(int tap_id, packet_info *pinfo, const void *tap_specific_data)\r\n{\r\ntap_packet_t *tpt;\r\nif(!tapping_is_active){\r\nreturn;\r\n}\r\nif(tap_packet_index >= TAP_PACKET_QUEUE_LEN){\r\ng_warning("Too many taps queued");\r\nreturn;\r\n}\r\ntpt=&tap_packet_array[tap_packet_index];\r\ntpt->tap_id=tap_id;\r\ntpt->pinfo=pinfo;\r\ntpt->tap_specific_data=tap_specific_data;\r\ntap_packet_index++;\r\n}\r\nvoid tap_build_interesting (epan_dissect_t *edt)\r\n{\r\ntap_listener_t *tl;\r\nif(!tap_listener_queue){\r\nreturn;\r\n}\r\nfor(tl=(tap_listener_t *)tap_listener_queue;tl;tl=tl->next){\r\nif(tl->code){\r\nepan_dissect_prime_dfilter(edt, tl->code);\r\n}\r\n}\r\n}\r\nvoid\r\ntap_queue_init(epan_dissect_t *edt)\r\n{\r\nif(!tap_listener_queue){\r\nreturn;\r\n}\r\ntapping_is_active=TRUE;\r\ntap_packet_index=0;\r\ntap_build_interesting (edt);\r\n}\r\nvoid\r\ntap_push_tapped_queue(epan_dissect_t *edt)\r\n{\r\ntap_packet_t *tp;\r\ntap_listener_t *tl;\r\nguint i;\r\nif(!tapping_is_active){\r\nreturn;\r\n}\r\ntapping_is_active=FALSE;\r\nif(!tap_packet_index){\r\nreturn;\r\n}\r\nfor(i=0;i<tap_packet_index;i++){\r\nfor(tl=(tap_listener_t *)tap_listener_queue;tl;tl=tl->next){\r\ntp=&tap_packet_array[i];\r\nif(tp->tap_id==tl->tap_id){\r\ngboolean passed=TRUE;\r\nif(tl->code){\r\npassed=dfilter_apply_edt(tl->code, edt);\r\n}\r\nif(passed && tl->packet){\r\ntl->needs_redraw|=tl->packet(tl->tapdata, tp->pinfo, edt, tp->tap_specific_data);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nconst void *\r\nfetch_tapped_data(int tap_id, int idx)\r\n{\r\ntap_packet_t *tp;\r\nguint i;\r\nif(!tapping_is_active){\r\nreturn NULL;\r\n}\r\nif(!tap_packet_index){\r\nreturn NULL;\r\n}\r\nfor(i=0;i<tap_packet_index;i++){\r\ntp=&tap_packet_array[i];\r\nif(tp->tap_id==tap_id){\r\nif(!idx--){\r\nreturn tp->tap_specific_data;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid\r\nreset_tap_listeners(void)\r\n{\r\ntap_listener_t *tl;\r\nfor(tl=(tap_listener_t *)tap_listener_queue;tl;tl=tl->next){\r\nif(tl->reset){\r\ntl->reset(tl->tapdata);\r\n}\r\ntl->needs_redraw=TRUE;\r\n}\r\n}\r\nvoid\r\ndraw_tap_listeners(gboolean draw_all)\r\n{\r\ntap_listener_t *tl;\r\nfor(tl=(tap_listener_t *)tap_listener_queue;tl;tl=tl->next){\r\nif(tl->needs_redraw || draw_all){\r\nif(tl->draw){\r\ntl->draw(tl->tapdata);\r\n}\r\n}\r\ntl->needs_redraw=FALSE;\r\n}\r\n}\r\nGList*\r\nget_tap_names(void)\r\n{\r\nGList *list = NULL;\r\ntap_dissector_t *td;\r\nfor(td=tap_dissector_list; td; td=td->next) {\r\nlist = g_list_prepend(list, td->name);\r\n}\r\nreturn g_list_reverse(list);\r\n}\r\nint\r\nfind_tap_id(const char *name)\r\n{\r\ntap_dissector_t *td;\r\nint i;\r\nfor(i=1,td=tap_dissector_list;td;i++,td=td->next) {\r\nif(!strcmp(td->name,name)){\r\nreturn i;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nGString *\r\nregister_tap_listener(const char *tapname, void *tapdata, const char *fstring,\r\nguint flags, tap_reset_cb reset, tap_packet_cb packet, tap_draw_cb draw)\r\n{\r\ntap_listener_t *tl;\r\nint tap_id;\r\nGString *error_string;\r\ntap_id=find_tap_id(tapname);\r\nif(!tap_id){\r\nerror_string = g_string_new("");\r\ng_string_printf(error_string, "Tap %s not found", tapname);\r\nreturn error_string;\r\n}\r\ntl=(tap_listener_t *)g_malloc(sizeof(tap_listener_t));\r\ntl->code=NULL;\r\ntl->needs_redraw=TRUE;\r\ntl->flags=flags;\r\nif(fstring){\r\nif(!dfilter_compile(fstring, &tl->code)){\r\nerror_string = g_string_new("");\r\ng_string_printf(error_string,\r\n"Filter \"%s\" is invalid - %s",\r\nfstring, dfilter_error_msg);\r\ng_free(tl);\r\nreturn error_string;\r\n}\r\n}\r\ntl->tap_id=tap_id;\r\ntl->tapdata=tapdata;\r\ntl->reset=reset;\r\ntl->packet=packet;\r\ntl->draw=draw;\r\ntl->next=(tap_listener_t *)tap_listener_queue;\r\ntap_listener_queue=tl;\r\nreturn NULL;\r\n}\r\nGString *\r\nset_tap_dfilter(void *tapdata, const char *fstring)\r\n{\r\ntap_listener_t *tl=NULL,*tl2;\r\nGString *error_string;\r\nif(!tap_listener_queue){\r\nreturn NULL;\r\n}\r\nif(tap_listener_queue->tapdata==tapdata){\r\ntl=(tap_listener_t *)tap_listener_queue;\r\n} else {\r\nfor(tl2=(tap_listener_t *)tap_listener_queue;tl2->next;tl2=tl2->next){\r\nif(tl2->next->tapdata==tapdata){\r\ntl=tl2->next;\r\nbreak;\r\n}\r\n}\r\n}\r\nif(tl){\r\nif(tl->code){\r\ndfilter_free(tl->code);\r\ntl->code=NULL;\r\n}\r\ntl->needs_redraw=TRUE;\r\nif(fstring){\r\nif(!dfilter_compile(fstring, &tl->code)){\r\nerror_string = g_string_new("");\r\ng_string_printf(error_string,\r\n"Filter \"%s\" is invalid - %s",\r\nfstring, dfilter_error_msg);\r\nreturn error_string;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid\r\nremove_tap_listener(void *tapdata)\r\n{\r\ntap_listener_t *tl=NULL,*tl2;\r\nif(!tap_listener_queue){\r\nreturn;\r\n}\r\nif(tap_listener_queue->tapdata==tapdata){\r\ntl=(tap_listener_t *)tap_listener_queue;\r\ntap_listener_queue=tap_listener_queue->next;\r\n} else {\r\nfor(tl2=(tap_listener_t *)tap_listener_queue;tl2->next;tl2=tl2->next){\r\nif(tl2->next->tapdata==tapdata){\r\ntl=tl2->next;\r\ntl2->next=tl2->next->next;\r\nbreak;\r\n}\r\n}\r\n}\r\nif(tl){\r\nif(tl->code){\r\ndfilter_free(tl->code);\r\n}\r\ng_free(tl);\r\n}\r\nreturn;\r\n}\r\ngboolean\r\ntap_listeners_require_dissection(void)\r\n{\r\nvolatile tap_listener_t *tap_queue = tap_listener_queue;\r\nwhile(tap_queue) {\r\nif(!(tap_queue->flags & TL_IS_DISSECTOR_HELPER))\r\nreturn TRUE;\r\ntap_queue = tap_queue->next;\r\n}\r\nreturn FALSE;\r\n}\r\ngboolean\r\nhave_tap_listener(int tap_id)\r\n{\r\nvolatile tap_listener_t *tap_queue = tap_listener_queue;\r\nwhile(tap_queue) {\r\nif(tap_queue->tap_id == tap_id)\r\nreturn TRUE;\r\ntap_queue = tap_queue->next;\r\n}\r\nreturn FALSE;\r\n}\r\ngboolean\r\nhave_filtering_tap_listeners(void)\r\n{\r\ntap_listener_t *tl;\r\nfor(tl=(tap_listener_t *)tap_listener_queue;tl;tl=tl->next){\r\nif(tl->code)\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nguint\r\nunion_of_tap_listener_flags(void)\r\n{\r\ntap_listener_t *tl;\r\nguint flags = 0;\r\nfor(tl=(tap_listener_t *)tap_listener_queue;tl;tl=tl->next){\r\nflags|=tl->flags;\r\n}\r\nreturn flags;\r\n}
