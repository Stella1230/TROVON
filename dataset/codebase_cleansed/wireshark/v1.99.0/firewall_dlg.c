void\r\nfirewall_rule_cb(GtkWidget *w _U_, gpointer data _U_)\r\n{\r\nGtkWidget *rule_w, *vbox, *txt_scrollw, *text;\r\nGtkWidget *label, *product_combo_box;\r\nGtkWidget *hbox, *button_hbox, *button;\r\nrule_info_t *rule_info;\r\npacket_info *pinfo = &cfile.edt->pi;\r\nguint i;\r\nrule_info = g_new0(rule_info_t, 1);\r\nCOPY_ADDRESS(&(rule_info->dl_src), &(pinfo->dl_src));\r\nCOPY_ADDRESS(&(rule_info->dl_dst), &(pinfo->dl_dst));\r\nCOPY_ADDRESS(&(rule_info->net_src), &(pinfo->net_src));\r\nCOPY_ADDRESS(&(rule_info->net_dst), &(pinfo->net_dst));\r\nrule_info->ptype = pinfo->ptype;\r\nrule_info->srcport = pinfo->srcport;\r\nrule_info->destport = pinfo->destport;\r\nrule_info->inbound = TRUE;\r\nrule_info->deny = TRUE;\r\nrule_info->product = 0;\r\nrule_w = dlg_window_new("Firewall ACL Rules");\r\ngtk_widget_set_name(rule_w, "Firewall ACL rule window");\r\ngtk_container_set_border_width(GTK_CONTAINER(rule_w), 6);\r\nvbox = ws_gtk_box_new(GTK_ORIENTATION_VERTICAL, 6, FALSE);\r\ngtk_container_add(GTK_CONTAINER(rule_w), vbox);\r\nhbox = ws_gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 1, FALSE);\r\ngtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);\r\nlabel = gtk_label_new("Product");\r\ngtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);\r\nproduct_combo_box = gtk_combo_box_text_new();\r\nfor (i = 0; i < NUM_PRODS; i++) {\r\ngtk_combo_box_text_append_text (GTK_COMBO_BOX_TEXT(product_combo_box), products[i].name);\r\n}\r\ng_object_set_data(G_OBJECT(product_combo_box), WS_RULE_INFO_KEY, rule_info);\r\ng_signal_connect(product_combo_box, "changed", G_CALLBACK(select_product), NULL);\r\ngtk_box_pack_start(GTK_BOX(hbox), product_combo_box, FALSE, FALSE, 5);\r\nlabel = gtk_label_new("Filter");\r\ngtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 10);\r\nrule_info->filter_combo_box = ws_combo_box_new_text_and_pointer();\r\ng_object_set_data(G_OBJECT(rule_info->filter_combo_box), WS_RULE_INFO_KEY, rule_info); \\r\ng_signal_connect(rule_info->filter_combo_box, "changed", G_CALLBACK(select_filter), NULL);\r\ngtk_box_pack_start(GTK_BOX(hbox), rule_info->filter_combo_box, FALSE, FALSE, 5);\r\nrule_info->inbound_cb = gtk_check_button_new_with_label("Inbound");\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(rule_info->inbound_cb),\r\nrule_info->inbound);\r\ngtk_box_pack_start(GTK_BOX(hbox), rule_info->inbound_cb, FALSE, FALSE, 10);\r\ng_signal_connect(rule_info->inbound_cb, "toggled", G_CALLBACK(toggle_inbound), rule_info);\r\nrule_info->deny_cb = gtk_check_button_new_with_label("Deny");\r\ngtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(rule_info->deny_cb),\r\nrule_info->deny);\r\ngtk_box_pack_start(GTK_BOX(hbox), rule_info->deny_cb, FALSE, FALSE, 10);\r\ng_signal_connect(rule_info->deny_cb, "toggled", G_CALLBACK(toggle_deny), rule_info);\r\ntxt_scrollw = scrolled_window_new(NULL, NULL);\r\ngtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(txt_scrollw),\r\nGTK_SHADOW_IN);\r\ngtk_box_pack_start(GTK_BOX(vbox), txt_scrollw, TRUE, TRUE, 0);\r\ntext = gtk_text_view_new();\r\ngtk_text_view_set_editable(GTK_TEXT_VIEW(text), FALSE);\r\ngtk_container_add(GTK_CONTAINER(txt_scrollw), text);\r\nrule_info->text = text;\r\nbutton_hbox = dlg_button_row_new(GTK_STOCK_HELP, GTK_STOCK_COPY, GTK_STOCK_SAVE, GTK_STOCK_CANCEL, NULL);\r\ngtk_box_pack_start(GTK_BOX(vbox), button_hbox, FALSE, FALSE, 0);\r\nbutton = (GtkWidget *)g_object_get_data(G_OBJECT(button_hbox), GTK_STOCK_COPY);\r\ng_signal_connect(button, "clicked", G_CALLBACK(firewall_copy_cmd_cb), rule_info);\r\ngtk_widget_set_tooltip_text(button, "Copy rule to clipboard");\r\nbutton = (GtkWidget *)g_object_get_data(G_OBJECT(button_hbox), GTK_STOCK_SAVE);\r\ng_signal_connect(button, "clicked", G_CALLBACK(firewall_save_as_cmd_cb), rule_info);\r\ngtk_widget_set_tooltip_text(button, "Save the rule as currently displayed");\r\nbutton = (GtkWidget *)g_object_get_data(G_OBJECT(button_hbox), GTK_STOCK_CANCEL);\r\ngtk_widget_set_tooltip_text(button, "Cancel the dialog");\r\nwindow_set_cancel_button(rule_w, button, window_cancel_button_cb);\r\nbutton = (GtkWidget *)g_object_get_data(G_OBJECT(button_hbox), GTK_STOCK_HELP);\r\ng_signal_connect(button, "clicked", G_CALLBACK(topic_cb), (gpointer)HELP_FIREWALL_DIALOG);\r\ng_object_set_data(G_OBJECT(rule_w), WS_RULE_INFO_KEY, rule_info);\r\ng_signal_connect(rule_w, "delete_event", G_CALLBACK(window_delete_event_cb), NULL);\r\ng_signal_connect(rule_w, "destroy", G_CALLBACK(firewall_destroy_cb), NULL);\r\ngtk_combo_box_set_active(GTK_COMBO_BOX(product_combo_box), 0);\r\ngtk_widget_show_all(rule_w);\r\nwindow_present(rule_w);\r\n}\r\nstatic void\r\nselect_product(GtkWidget *w, gpointer data _U_)\r\n{\r\nguint prod = gtk_combo_box_get_active(GTK_COMBO_BOX(w));\r\nrule_info_t *rule_info;\r\ngchar name[MAX_RULE_LEN], addr_str[MAX_RULE_LEN];\r\naddress *addr;\r\nrule_type_t rule_type = RT_NONE;\r\ngboolean sensitive = FALSE;\r\nrule_info =(rule_info_t *)g_object_get_data(G_OBJECT(w), WS_RULE_INFO_KEY);\r\nif (prod >= NUM_PRODS || !rule_info)\r\nreturn;\r\nrule_info->product = prod;\r\nws_combo_box_clear_text_and_pointer(GTK_COMBO_BOX(rule_info->filter_combo_box));\r\nif (products[prod].mac_func && rule_info->dl_src.type == AT_ETHER) {\r\naddr = &(rule_info->dl_src);\r\naddress_to_str_buf(addr, name, MAX_RULE_LEN);\r\nADD_TO_FILTER_MENU(RT_MAC_SRC);\r\naddr = &(rule_info->dl_dst);\r\naddress_to_str_buf(addr, name, MAX_RULE_LEN);\r\nADD_TO_FILTER_MENU(RT_MAC_DST);\r\n}\r\nif (products[prod].ipv4_func && rule_info->net_src.type == AT_IPv4) {\r\naddr = &(rule_info->net_src);\r\naddress_to_str_buf(addr, name, MAX_RULE_LEN);\r\nADD_TO_FILTER_MENU(RT_IPv4_SRC);\r\naddr = &(rule_info->net_dst);\r\naddress_to_str_buf(addr, name, MAX_RULE_LEN);\r\nADD_TO_FILTER_MENU(RT_IPv4_DST);\r\n}\r\nif (products[prod].port_func && (rule_info->ptype == PT_TCP || rule_info->ptype == PT_UDP)) {\r\ng_snprintf(name, MAX_RULE_LEN, "%s port %u", NAME_TCP_UDP,\r\nrule_info->srcport);\r\nADD_TO_FILTER_MENU(RT_PORT_SRC);\r\nif (rule_info->srcport != rule_info->destport) {\r\ng_snprintf(name, MAX_RULE_LEN, "%s port %u", NAME_TCP_UDP,\r\nrule_info->destport);\r\nADD_TO_FILTER_MENU(RT_PORT_DST);\r\n}\r\n}\r\nif (products[prod].ipv4_port_func && rule_info->net_src.type == AT_IPv4 &&\r\n(rule_info->ptype == PT_TCP || rule_info->ptype == PT_UDP)) {\r\naddr = &(rule_info->net_src);\r\naddress_to_str_buf(addr, addr_str, MAX_RULE_LEN);\r\ng_snprintf(name, MAX_RULE_LEN, "%s + %s port %u", addr_str,\r\nNAME_TCP_UDP, rule_info->srcport);\r\nADD_TO_FILTER_MENU(RT_IPv4_PORT_SRC);\r\naddr = &(rule_info->net_dst);\r\naddress_to_str_buf(addr, addr_str, MAX_RULE_LEN);\r\ng_snprintf(name, MAX_RULE_LEN, "%s + %s port %u", addr_str,\r\nNAME_TCP_UDP, rule_info->destport);\r\nADD_TO_FILTER_MENU(RT_IPv4_PORT_DST);\r\n}\r\nif (rule_type != RT_NONE) {\r\ngtk_combo_box_set_active(GTK_COMBO_BOX(rule_info->filter_combo_box), 0);\r\nsensitive = TRUE;\r\n} else {\r\nselect_filter(rule_info->filter_combo_box, NULL);\r\n}\r\ngtk_widget_set_sensitive(rule_info->filter_combo_box, sensitive);\r\ngtk_widget_set_sensitive(rule_info->inbound_cb, products[prod].does_inbound && sensitive);\r\ngtk_widget_set_sensitive(rule_info->deny_cb, sensitive);\r\n}\r\nstatic void\r\nselect_filter(GtkWidget *w, gpointer data _U_)\r\n{\r\nrule_type_t cur_type;\r\nrule_info_t *rule_info;\r\ngpointer ptr;\r\nrule_info = (rule_info_t *)g_object_get_data(G_OBJECT(w), WS_RULE_INFO_KEY);\r\nif (!rule_info)\r\nreturn;\r\nif (ws_combo_box_get_active_pointer(GTK_COMBO_BOX(w), &ptr))\r\ncur_type = (rule_type_t)GPOINTER_TO_UINT(ptr);\r\nelse\r\ncur_type = RT_NONE;\r\nif (cur_type >= NUM_RULE_TYPES)\r\nreturn;\r\nrule_info->rule_type = cur_type;\r\nset_rule_text(rule_info);\r\n}\r\nstatic void\r\ntoggle_inbound(GtkToggleButton *t, gpointer data)\r\n{\r\nrule_info_t *rule_info = (rule_info_t *) data;\r\nrule_info->inbound = gtk_toggle_button_get_active(t);\r\nset_rule_text(rule_info);\r\n}\r\nstatic void\r\ntoggle_deny(GtkToggleButton *t, gpointer data)\r\n{\r\nrule_info_t *rule_info = (rule_info_t *) data;\r\nrule_info->deny = gtk_toggle_button_get_active(t);\r\nset_rule_text(rule_info);\r\n}\r\nstatic void\r\nset_rule_text(rule_info_t *rule_info) {\r\nGString *rtxt = g_string_new("");\r\ngchar addr_str[MAX_RULE_LEN];\r\nrule_type_t rt = rule_info->rule_type;\r\nguint prod = rule_info->product;\r\naddress *addr = NULL;\r\nguint32 port = 0;\r\nsyntax_func rt_func = NULL;\r\nGtkTextBuffer *buf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(rule_info->text));\r\nif (prod < NUM_PRODS) {\r\ng_string_printf(rtxt, "%s %s\n", products[prod].comment_pfx, products[prod].name);\r\nswitch(rt) {\r\ncase RT_NONE:\r\ng_string_append_printf(rtxt, "%s Not supported", products[prod].comment_pfx);\r\nrt_func = sf_dummy;\r\nbreak;\r\ncase RT_MAC_SRC:\r\ncase RT_MAC_DST:\r\naddr = DL_ADDR;\r\naddress_to_str_buf(addr, addr_str, MAX_RULE_LEN);\r\nrt_func = products[prod].mac_func;\r\nbreak;\r\ncase RT_IPv4_SRC:\r\ncase RT_IPv4_DST:\r\naddr = NET_ADDR;\r\naddress_to_str_buf(addr, addr_str, MAX_RULE_LEN);\r\nrt_func = products[prod].ipv4_func;\r\nbreak;\r\ncase RT_PORT_SRC:\r\ncase RT_PORT_DST:\r\nport = NET_PORT;\r\nrt_func = products[prod].port_func;\r\nbreak;\r\ncase RT_IPv4_PORT_SRC:\r\ncase RT_IPv4_PORT_DST:\r\naddr = NET_ADDR;\r\naddress_to_str_buf(addr, addr_str, MAX_RULE_LEN);\r\nport = NET_PORT;\r\nrt_func = products[prod].ipv4_port_func;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (rt_func) {\r\nrt_func(rtxt, addr_str, port, rule_info->ptype, rule_info->inbound, rule_info->deny);\r\n} else {\r\ng_string_append_printf(rtxt, "ERROR: Unable to create rule");\r\n}\r\ngtk_text_buffer_set_text(buf, rtxt->str, (gint) rtxt->len);\r\ng_string_free(rtxt, TRUE);\r\n}\r\nstatic void sf_dummy(GString *rtxt _U_, gchar *addr _U_, guint32 port _U_, port_type ptype _U_, gboolean inbound _U_, gboolean deny _U_) {\r\n}\r\nstatic void sf_ipfw_mac(GString *rtxt, gchar *addr, guint32 port _U_, port_type ptype _U_, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "add %s MAC %s any %s",\r\nIPFW_DENY, addr, IPFW_IN);\r\n}\r\nstatic void sf_netfilter_mac(GString *rtxt, gchar *addr, guint32 port _U_, port_type ptype _U_, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "iptables -A %s --mac-source %s -j %s",\r\nNF_INPUT, addr, NF_DROP);\r\n}\r\nstatic void sf_ios_std_ipv4(GString *rtxt, gchar *addr, guint32 port _U_, port_type ptype _U_, gboolean inbound _U_, gboolean deny) {\r\ng_string_append_printf(rtxt, "access-list NUMBER %s host %s", IOS_DENY, addr);\r\n}\r\nstatic void sf_ios_ext_ipv4(GString *rtxt, gchar *addr, guint32 port _U_, port_type ptype _U_, gboolean inbound, gboolean deny) {\r\nif (inbound)\r\ng_string_append_printf(rtxt, "access-list NUMBER %s ip host %s any", IOS_DENY, addr);\r\nelse\r\ng_string_append_printf(rtxt, "access-list NUMBER %s ip any host %s", IOS_DENY, addr);\r\n}\r\nstatic void sf_ipfilter_ipv4(GString *rtxt, gchar *addr, guint32 port _U_, port_type ptype _U_, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "%s %s on le0 from %s to any",\r\nIPFILTER_DENY, IPFILTER_IN, addr);\r\n}\r\nstatic void sf_ipfw_ipv4(GString *rtxt, gchar *addr, guint32 port _U_, port_type ptype _U_, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "add %s ip from %s to any %s",\r\nIPFW_DENY, addr, IPFW_IN);\r\n}\r\nstatic void sf_netfilter_ipv4(GString *rtxt, gchar *addr, guint32 port _U_, port_type ptype _U_, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "iptables -A %s -i eth0 -d %s/32 -j %s",\r\nNF_INPUT, addr, NF_DROP);\r\n}\r\nstatic void sf_pf_ipv4(GString *rtxt, gchar *addr, guint32 port _U_, port_type ptype _U_, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "%s %s quick on $ext_if from %s to any",\r\nPF_DENY, PF_IN, addr);\r\n}\r\nstatic void sf_ios_ext_port(GString *rtxt, gchar *addr _U_, guint32 port, port_type ptype, gboolean inbound _U_, gboolean deny) {\r\ng_string_append_printf(rtxt, "access-list NUMBER %s %s any any eq %u",\r\nIOS_DENY, RT_TCP_UDP, port);\r\n}\r\nstatic void sf_ipfilter_port(GString *rtxt, gchar *addr _U_, guint32 port, port_type ptype _U_, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "%s %s on le0 proto %s from any to any port = %u",\r\nIPFILTER_DENY, IPFILTER_IN, RT_TCP_UDP, port);\r\n}\r\nstatic void sf_ipfw_port(GString *rtxt, gchar *addr _U_, guint32 port, port_type ptype, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "add %s %s from any to any %u %s",\r\nIPFW_DENY, RT_TCP_UDP, port, IPFW_IN);\r\n}\r\nstatic void sf_netfilter_port(GString *rtxt, gchar *addr _U_, guint32 port, port_type ptype, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "iptables -A %s -p %s --destination-port %u -j %s",\r\nNF_INPUT, RT_TCP_UDP, port, NF_DROP);\r\n}\r\nstatic void sf_pf_port(GString *rtxt, gchar *addr _U_, guint32 port, port_type ptype, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "%s %s quick on $ext_if proto %s from any to any port %u",\r\nPF_DENY, PF_IN, RT_TCP_UDP, port);\r\n}\r\nstatic void sf_netsh_port(GString *rtxt, gchar *addr _U_, guint32 port, port_type ptype, gboolean inbound _U_, gboolean deny) {\r\ng_string_append_printf(rtxt, "add portopening %s %u Wireshark %s",\r\nRT_TCP_UDP, port, NETSH_DENY);\r\n}\r\nstatic void sf_ios_ext_ipv4_port(GString *rtxt, gchar *addr, guint32 port _U_, port_type ptype _U_, gboolean inbound, gboolean deny) {\r\nif (inbound)\r\ng_string_append_printf(rtxt, "access-list NUMBER %s %s host %s any eq %u", IOS_DENY, RT_TCP_UDP, addr, port);\r\nelse\r\ng_string_append_printf(rtxt, "access-list NUMBER %s %s any host %s eq %u", IOS_DENY, RT_TCP_UDP, addr, port);\r\n}\r\nstatic void sf_ipfilter_ipv4_port(GString *rtxt, gchar *addr, guint32 port, port_type ptype, gboolean inbound, gboolean deny) {\r\nif (inbound)\r\ng_string_append_printf(rtxt, "%s %s on le0 proto %s from %s to any port = %u",\r\nIPFILTER_DENY, IPFILTER_IN, RT_TCP_UDP, addr, port);\r\nelse\r\ng_string_append_printf(rtxt, "%s %s on le0 proto %s from any to %s port = %u",\r\nIPFILTER_DENY, IPFILTER_IN, RT_TCP_UDP, addr, port);\r\n}\r\nstatic void sf_ipfw_ipv4_port(GString *rtxt, gchar *addr, guint32 port, port_type ptype, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "add %s %s from %s to any %u %s",\r\nIPFW_DENY, RT_TCP_UDP, addr, port, IPFW_IN);\r\n}\r\nstatic void sf_pf_ipv4_port(GString *rtxt, gchar *addr, guint32 port, port_type ptype, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "%s %s quick on $ext_if proto %s from %s to any port %u",\r\nPF_DENY, PF_IN, RT_TCP_UDP, addr, port);\r\n}\r\nstatic void sf_netfilter_ipv4_port(GString *rtxt, gchar *addr, guint32 port, port_type ptype, gboolean inbound, gboolean deny) {\r\ng_string_append_printf(rtxt, "iptables -A %s -p %s -d %s/32 --destination-port %u -j %s",\r\nNF_INPUT, RT_TCP_UDP, addr, port, NF_DROP);\r\n}\r\nstatic void sf_netsh_ipv4_port(GString *rtxt, gchar *addr, guint32 port, port_type ptype, gboolean inbound _U_, gboolean deny) {\r\ng_string_append_printf(rtxt, "add portopening %s %u Wireshark %s %s",\r\nRT_TCP_UDP, port, NETSH_DENY, addr);\r\n}\r\nstatic void\r\nfirewall_destroy_cb(GtkWidget *w, gpointer data _U_)\r\n{\r\nrule_info_t *rule_info;\r\nrule_info = (rule_info_t *)g_object_get_data(G_OBJECT(w), WS_RULE_INFO_KEY);\r\n#if 0\r\nforget_rule_info(rule_info);\r\n#endif\r\ng_free(rule_info);\r\ngtk_widget_destroy(w);\r\n}\r\nstatic void\r\nfirewall_copy_cmd_cb(GtkWidget *w _U_, gpointer data)\r\n{\r\nrule_info_t *rule_info = (rule_info_t *)data;\r\nGtkTextIter start, end;\r\nGtkTextBuffer *buf;\r\nbuf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(rule_info->text));\r\ngtk_text_buffer_get_start_iter(buf, &start);\r\ngtk_text_buffer_get_end_iter(buf, &end);\r\ngtk_text_buffer_select_range(buf, &start, &end);\r\ngtk_text_buffer_copy_clipboard(buf, gtk_clipboard_get(GDK_SELECTION_CLIPBOARD));\r\n}\r\nstatic gboolean\r\nfirewall_save_as_ok_cb(char *to_name, rule_info_t *rule_info)\r\n{\r\nFILE *fh;\r\ngchar *rule;\r\nGtkTextIter start, end;\r\nGtkTextBuffer *buf;\r\nfh = ws_fopen(to_name, "w");\r\nif (fh == NULL) {\r\nopen_failure_alert_box(to_name, errno, TRUE);\r\ng_free(to_name);\r\nreturn FALSE;\r\n}\r\nbuf = gtk_text_view_get_buffer(GTK_TEXT_VIEW(rule_info->text));\r\ngtk_text_buffer_get_start_iter(buf, &start);\r\ngtk_text_buffer_get_end_iter(buf, &end);\r\nrule = gtk_text_buffer_get_text(buf, &start, &end, FALSE);\r\nfputs(rule, fh);\r\nfclose(fh);\r\nreturn TRUE;\r\n}\r\nstatic char *\r\ngtk_firewall_save_as_file(GtkWidget *caller)\r\n{\r\nGtkWidget *new_win;\r\nchar *pathname;\r\nnew_win = file_selection_new("Wireshark: Save Firewall ACL Rule",\r\nGTK_WINDOW(caller),\r\nFILE_SELECTION_SAVE);\r\npathname = file_selection_run(new_win);\r\nif (pathname == NULL) {\r\nreturn NULL;\r\n}\r\nwindow_destroy(new_win);\r\nreturn pathname;\r\n}\r\nstatic void\r\nfirewall_save_as_cmd_cb(GtkWidget *w, gpointer data)\r\n{\r\nGtkWidget *caller = gtk_widget_get_toplevel(w);\r\nrule_info_t *rule_info = (rule_info_t *)data;\r\nchar *pathname;\r\nfor (;;) {\r\npathname = gtk_firewall_save_as_file(caller);\r\nif (pathname == NULL) {\r\nbreak;\r\n}\r\nif (firewall_save_as_ok_cb(pathname, rule_info)) {\r\ng_free(pathname);\r\nbreak;\r\n}\r\ng_free(pathname);\r\n}\r\n}
