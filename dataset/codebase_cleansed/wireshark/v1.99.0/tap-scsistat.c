static void\r\nscsistat_reset(void *prs)\r\n{\r\nscsistat_t *rs = (scsistat_t *)prs;\r\nguint32 i;\r\nfor(i = 0; i < MAX_PROCEDURES; i++) {\r\nrs->procedures[i].num = 0;\r\nrs->procedures[i].min.secs = 0;\r\nrs->procedures[i].min.nsecs = 0;\r\nrs->procedures[i].max.secs = 0;\r\nrs->procedures[i].max.nsecs = 0;\r\nrs->procedures[i].tot.secs = 0;\r\nrs->procedures[i].tot.nsecs = 0;\r\n}\r\n}\r\nstatic int\r\nscsistat_packet(void *prs, packet_info *pinfo, epan_dissect_t *edt _U_, const void *pri)\r\n{\r\nscsistat_t *rs = (scsistat_t *)prs;\r\nconst scsi_task_data_t *ri = (const scsi_task_data_t *)pri;\r\nnstime_t delta;\r\nscsi_procedure_t *rp;\r\nif(ri->type != SCSI_PDU_TYPE_RSP) {\r\nreturn 0;\r\n}\r\nif( (!ri->itl) || ((ri->itl->cmdset&SCSI_CMDSET_MASK) != rs->cmdset) ) {\r\nreturn 0;\r\n}\r\nif( (!ri->itlq) || (ri->itlq->scsi_opcode > 255) ) {\r\nreturn 0;\r\n}\r\nrp = &(rs->procedures[ri->itlq->scsi_opcode]);\r\nnstime_delta(&delta, &pinfo->fd->abs_ts, &ri->itlq->fc_time);\r\nif(rp->num == 0) {\r\nrp->max.secs = delta.secs;\r\nrp->max.nsecs = delta.nsecs;\r\n}\r\nif(rp->num == 0) {\r\nrp->min.secs = delta.secs;\r\nrp->min.nsecs = delta.nsecs;\r\n}\r\nif( (delta.secs < rp->min.secs)\r\n||( (delta.secs == rp->min.secs)\r\n&&(delta.nsecs < rp->min.nsecs) ) ) {\r\nrp->min.secs = delta.secs;\r\nrp->min.nsecs = delta.nsecs;\r\n}\r\nif( (delta.secs > rp->max.secs)\r\n||( (delta.secs == rp->max.secs)\r\n&&(delta.nsecs > rp->max.nsecs) ) ) {\r\nrp->max.secs = delta.secs;\r\nrp->max.nsecs= delta.nsecs;\r\n}\r\nrp->tot.secs += delta.secs;\r\nrp->tot.nsecs += delta.nsecs;\r\nif(rp->tot.nsecs > NANOSECS_PER_SEC) {\r\nrp->tot.nsecs -= NANOSECS_PER_SEC;\r\nrp->tot.secs++;\r\n}\r\nrp->num++;\r\nreturn 1;\r\n}\r\nstatic void\r\nscsistat_draw(void *prs)\r\n{\r\nscsistat_t *rs = (scsistat_t *)prs;\r\nguint32 i;\r\nguint64 td;\r\nprintf("\n");\r\nprintf("===========================================================\n");\r\nprintf("SCSI %s SRT Statistics:\n", rs->prog);\r\nprintf("Filter: %s\n", rs->filter?rs->filter:"");\r\nprintf("Procedure Calls Min SRT Max SRT Avg SRT\n");\r\nfor(i=0; i < MAX_PROCEDURES; i++) {\r\nif(rs->procedures[i].num == 0) {\r\ncontinue;\r\n}\r\ntd = ((guint64)(rs->procedures[i].tot.secs)) * NANOSECS_PER_SEC + rs->procedures[i].tot.nsecs;\r\ntd = ((td / rs->procedures[i].num) + 500) / 1000;\r\nprintf("%-19s %6d %3d.%06u %3d.%06u %3d.%06u \n",\r\nrs->procedures[i].proc,\r\nrs->procedures[i].num,\r\n(int)(rs->procedures[i].min.secs),\r\n(rs->procedures[i].min.nsecs+500)/1000,\r\n(int)(rs->procedures[i].max.secs),\r\n(rs->procedures[i].max.nsecs+500)/1000,\r\n(int)(td/1000000), (int)(td%1000000)\r\n);\r\n}\r\nprintf("===========================================================\n");\r\n}\r\nstatic void\r\nscsistat_init(const char *opt_arg, void* userdata _U_)\r\n{\r\nscsistat_t *rs;\r\nguint32 i;\r\nint program, pos;\r\nconst char *filter = NULL;\r\nGString *error_string;\r\npos = 0;\r\nif(sscanf(opt_arg, "scsi,srt,%d,%n", &program, &pos) == 1) {\r\nif(pos) {\r\nfilter = opt_arg+pos;\r\n} else {\r\nfilter = NULL;\r\n}\r\n} else {\r\nfprintf(stderr, "tshark: invalid \"-z scsi,srt,<cmdset>[,<filter>]\" argument\n");\r\nexit(1);\r\n}\r\nscsi_program = program;\r\nrs = g_new(scsistat_t,1);\r\nif(filter) {\r\nrs->filter = g_strdup(filter);\r\n} else {\r\nrs->filter = NULL;\r\n}\r\nrs->cmdset = program;\r\nswitch(program) {\r\ncase SCSI_DEV_SBC:\r\nrs->prog = "SBC (disk)";\r\nrs->cdbnames_ext = &scsi_sbc_vals_ext;\r\nbreak;\r\ncase SCSI_DEV_SSC:\r\nrs->prog = "SSC (tape)";\r\nrs->cdbnames_ext = &scsi_ssc_vals_ext;\r\nbreak;\r\ncase SCSI_DEV_CDROM:\r\nrs->prog = "MMC (cd/dvd)";\r\nrs->cdbnames_ext = &scsi_mmc_vals_ext;\r\nbreak;\r\ncase SCSI_DEV_SMC:\r\nrs->prog = "SMC (tape robot)";\r\nrs->cdbnames_ext = &scsi_smc_vals_ext;\r\nbreak;\r\ncase SCSI_DEV_OSD:\r\nrs->prog = "OSD (object based)";\r\nrs->cdbnames_ext = &scsi_osd_vals_ext;\r\nbreak;\r\ndefault:\r\nrs->cmdset = 0;\r\nrs->prog = "SBC (disk)";\r\nrs->cdbnames_ext = &scsi_sbc_vals_ext;\r\nbreak;\r\n}\r\nrs->procedures = g_new(scsi_procedure_t,MAX_PROCEDURES);\r\nfor(i=0; i < MAX_PROCEDURES; i++) {\r\nrs->procedures[i].proc = val_to_str_ext(i, rs->cdbnames_ext, "Unknown-0x%02x");\r\nrs->procedures[i].num = 0;\r\nrs->procedures[i].min.secs = 0;\r\nrs->procedures[i].min.nsecs = 0;\r\nrs->procedures[i].max.secs = 0;\r\nrs->procedures[i].max.nsecs = 0;\r\nrs->procedures[i].tot.secs = 0;\r\nrs->procedures[i].tot.nsecs = 0;\r\n}\r\nerror_string = register_tap_listener("scsi", rs, filter, 0, scsistat_reset, scsistat_packet, scsistat_draw);\r\nif(error_string) {\r\ng_free(rs->procedures);\r\ng_free(rs->filter);\r\ng_free(rs);\r\nfprintf(stderr, "tshark: Couldn't register scsi,srt tap: %s\n",\r\nerror_string->str);\r\ng_string_free(error_string, TRUE);\r\nexit(1);\r\n}\r\n}\r\nvoid\r\nregister_tap_listener_scsistat(void)\r\n{\r\nregister_stat_cmd_arg("scsi,srt,", scsistat_init, NULL);\r\n}
