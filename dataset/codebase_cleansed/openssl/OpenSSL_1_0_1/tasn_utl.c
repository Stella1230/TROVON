int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nint *sel = offset2ptr(*pval, it->utype);\r\nreturn *sel;\r\n}\r\nint asn1_set_choice_selector(ASN1_VALUE **pval, int value, const ASN1_ITEM *it)\r\n{\r\nint *sel, ret;\r\nsel = offset2ptr(*pval, it->utype);\r\nret = *sel;\r\n*sel = value;\r\nreturn ret;\r\n}\r\nint asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it)\r\n{\r\nconst ASN1_AUX *aux;\r\nint *lck, ret;\r\nif ((it->itype != ASN1_ITYPE_SEQUENCE)\r\n&& (it->itype != ASN1_ITYPE_NDEF_SEQUENCE))\r\nreturn 0;\r\naux = it->funcs;\r\nif (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT))\r\nreturn 0;\r\nlck = offset2ptr(*pval, aux->ref_offset);\r\nif (op == 0)\r\n{\r\n*lck = 1;\r\nreturn 1;\r\n}\r\nret = CRYPTO_add(lck, op, aux->ref_lock);\r\n#ifdef REF_PRINT\r\nfprintf(stderr, "%s: Reference Count: %d\n", it->sname, *lck);\r\n#endif\r\n#ifdef REF_CHECK\r\nif (ret < 0)\r\nfprintf(stderr, "%s, bad reference count\n", it->sname);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nconst ASN1_AUX *aux;\r\nif (!pval || !*pval)\r\nreturn NULL;\r\naux = it->funcs;\r\nif (!aux || !(aux->flags & ASN1_AFLG_ENCODING))\r\nreturn NULL;\r\nreturn offset2ptr(*pval, aux->enc_offset);\r\n}\r\nvoid asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nASN1_ENCODING *enc;\r\nenc = asn1_get_enc_ptr(pval, it);\r\nif (enc)\r\n{\r\nenc->enc = NULL;\r\nenc->len = 0;\r\nenc->modified = 1;\r\n}\r\n}\r\nvoid asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nASN1_ENCODING *enc;\r\nenc = asn1_get_enc_ptr(pval, it);\r\nif (enc)\r\n{\r\nif (enc->enc)\r\nOPENSSL_free(enc->enc);\r\nenc->enc = NULL;\r\nenc->len = 0;\r\nenc->modified = 1;\r\n}\r\n}\r\nint asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,\r\nconst ASN1_ITEM *it)\r\n{\r\nASN1_ENCODING *enc;\r\nenc = asn1_get_enc_ptr(pval, it);\r\nif (!enc)\r\nreturn 1;\r\nif (enc->enc)\r\nOPENSSL_free(enc->enc);\r\nenc->enc = OPENSSL_malloc(inlen);\r\nif (!enc->enc)\r\nreturn 0;\r\nmemcpy(enc->enc, in, inlen);\r\nenc->len = inlen;\r\nenc->modified = 0;\r\nreturn 1;\r\n}\r\nint asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,\r\nconst ASN1_ITEM *it)\r\n{\r\nASN1_ENCODING *enc;\r\nenc = asn1_get_enc_ptr(pval, it);\r\nif (!enc || enc->modified)\r\nreturn 0;\r\nif (out)\r\n{\r\nmemcpy(*out, enc->enc, enc->len);\r\n*out += enc->len;\r\n}\r\nif (len)\r\n*len = enc->len;\r\nreturn 1;\r\n}\r\nASN1_VALUE ** asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\r\n{\r\nASN1_VALUE **pvaltmp;\r\nif (tt->flags & ASN1_TFLG_COMBINE)\r\nreturn pval;\r\npvaltmp = offset2ptr(*pval, tt->offset);\r\nreturn pvaltmp;\r\n}\r\nconst ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,\r\nint nullerr)\r\n{\r\nconst ASN1_ADB *adb;\r\nconst ASN1_ADB_TABLE *atbl;\r\nlong selector;\r\nASN1_VALUE **sfld;\r\nint i;\r\nif (!(tt->flags & ASN1_TFLG_ADB_MASK))\r\nreturn tt;\r\nadb = ASN1_ADB_ptr(tt->item);\r\nsfld = offset2ptr(*pval, adb->offset);\r\nif (!sfld)\r\n{\r\nif (!adb->null_tt)\r\ngoto err;\r\nreturn adb->null_tt;\r\n}\r\nif (tt->flags & ASN1_TFLG_ADB_OID)\r\nselector = OBJ_obj2nid((ASN1_OBJECT *)*sfld);\r\nelse\r\nselector = ASN1_INTEGER_get((ASN1_INTEGER *)*sfld);\r\nfor (atbl = adb->tbl, i = 0; i < adb->tblcount; i++, atbl++)\r\nif (atbl->value == selector)\r\nreturn &atbl->tt;\r\nif (!adb->default_tt)\r\ngoto err;\r\nreturn adb->default_tt;\r\nerr:\r\nif (nullerr)\r\nASN1err(ASN1_F_ASN1_DO_ADB,\r\nASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);\r\nreturn NULL;\r\n}
