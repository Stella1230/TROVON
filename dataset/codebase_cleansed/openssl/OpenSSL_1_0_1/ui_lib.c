UI *UI_new(void)\r\n{\r\nreturn(UI_new_method(NULL));\r\n}\r\nUI *UI_new_method(const UI_METHOD *method)\r\n{\r\nUI *ret;\r\nret=(UI *)OPENSSL_malloc(sizeof(UI));\r\nif (ret == NULL)\r\n{\r\nUIerr(UI_F_UI_NEW_METHOD,ERR_R_MALLOC_FAILURE);\r\nreturn NULL;\r\n}\r\nif (method == NULL)\r\nret->meth=UI_get_default_method();\r\nelse\r\nret->meth=method;\r\nret->strings=NULL;\r\nret->user_data=NULL;\r\nret->flags=0;\r\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_UI, ret, &ret->ex_data);\r\nreturn ret;\r\n}\r\nstatic void free_string(UI_STRING *uis)\r\n{\r\nif (uis->flags & OUT_STRING_FREEABLE)\r\n{\r\nOPENSSL_free((char *)uis->out_string);\r\nswitch(uis->type)\r\n{\r\ncase UIT_BOOLEAN:\r\nOPENSSL_free((char *)uis->_.boolean_data.action_desc);\r\nOPENSSL_free((char *)uis->_.boolean_data.ok_chars);\r\nOPENSSL_free((char *)uis->_.boolean_data.cancel_chars);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nOPENSSL_free(uis);\r\n}\r\nvoid UI_free(UI *ui)\r\n{\r\nif (ui == NULL)\r\nreturn;\r\nsk_UI_STRING_pop_free(ui->strings,free_string);\r\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_UI, ui, &ui->ex_data);\r\nOPENSSL_free(ui);\r\n}\r\nstatic int allocate_string_stack(UI *ui)\r\n{\r\nif (ui->strings == NULL)\r\n{\r\nui->strings=sk_UI_STRING_new_null();\r\nif (ui->strings == NULL)\r\n{\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic UI_STRING *general_allocate_prompt(UI *ui, const char *prompt,\r\nint prompt_freeable, enum UI_string_types type, int input_flags,\r\nchar *result_buf)\r\n{\r\nUI_STRING *ret = NULL;\r\nif (prompt == NULL)\r\n{\r\nUIerr(UI_F_GENERAL_ALLOCATE_PROMPT,ERR_R_PASSED_NULL_PARAMETER);\r\n}\r\nelse if ((type == UIT_PROMPT || type == UIT_VERIFY\r\n|| type == UIT_BOOLEAN) && result_buf == NULL)\r\n{\r\nUIerr(UI_F_GENERAL_ALLOCATE_PROMPT,UI_R_NO_RESULT_BUFFER);\r\n}\r\nelse if ((ret = (UI_STRING *)OPENSSL_malloc(sizeof(UI_STRING))))\r\n{\r\nret->out_string=prompt;\r\nret->flags=prompt_freeable ? OUT_STRING_FREEABLE : 0;\r\nret->input_flags=input_flags;\r\nret->type=type;\r\nret->result_buf=result_buf;\r\n}\r\nreturn ret;\r\n}\r\nstatic int general_allocate_string(UI *ui, const char *prompt,\r\nint prompt_freeable, enum UI_string_types type, int input_flags,\r\nchar *result_buf, int minsize, int maxsize, const char *test_buf)\r\n{\r\nint ret = -1;\r\nUI_STRING *s = general_allocate_prompt(ui, prompt, prompt_freeable,\r\ntype, input_flags, result_buf);\r\nif (s)\r\n{\r\nif (allocate_string_stack(ui) >= 0)\r\n{\r\ns->_.string_data.result_minsize=minsize;\r\ns->_.string_data.result_maxsize=maxsize;\r\ns->_.string_data.test_buf=test_buf;\r\nret=sk_UI_STRING_push(ui->strings, s);\r\nif (ret <= 0) ret--;\r\n}\r\nelse\r\nfree_string(s);\r\n}\r\nreturn ret;\r\n}\r\nstatic int general_allocate_boolean(UI *ui,\r\nconst char *prompt, const char *action_desc,\r\nconst char *ok_chars, const char *cancel_chars,\r\nint prompt_freeable, enum UI_string_types type, int input_flags,\r\nchar *result_buf)\r\n{\r\nint ret = -1;\r\nUI_STRING *s;\r\nconst char *p;\r\nif (ok_chars == NULL)\r\n{\r\nUIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,ERR_R_PASSED_NULL_PARAMETER);\r\n}\r\nelse if (cancel_chars == NULL)\r\n{\r\nUIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,ERR_R_PASSED_NULL_PARAMETER);\r\n}\r\nelse\r\n{\r\nfor(p = ok_chars; *p; p++)\r\n{\r\nif (strchr(cancel_chars, *p))\r\n{\r\nUIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,\r\nUI_R_COMMON_OK_AND_CANCEL_CHARACTERS);\r\n}\r\n}\r\ns = general_allocate_prompt(ui, prompt, prompt_freeable,\r\ntype, input_flags, result_buf);\r\nif (s)\r\n{\r\nif (allocate_string_stack(ui) >= 0)\r\n{\r\ns->_.boolean_data.action_desc = action_desc;\r\ns->_.boolean_data.ok_chars = ok_chars;\r\ns->_.boolean_data.cancel_chars = cancel_chars;\r\nret=sk_UI_STRING_push(ui->strings, s);\r\nif (ret <= 0) ret--;\r\n}\r\nelse\r\nfree_string(s);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint UI_add_input_string(UI *ui, const char *prompt, int flags,\r\nchar *result_buf, int minsize, int maxsize)\r\n{\r\nreturn general_allocate_string(ui, prompt, 0,\r\nUIT_PROMPT, flags, result_buf, minsize, maxsize, NULL);\r\n}\r\nint UI_dup_input_string(UI *ui, const char *prompt, int flags,\r\nchar *result_buf, int minsize, int maxsize)\r\n{\r\nchar *prompt_copy=NULL;\r\nif (prompt)\r\n{\r\nprompt_copy=BUF_strdup(prompt);\r\nif (prompt_copy == NULL)\r\n{\r\nUIerr(UI_F_UI_DUP_INPUT_STRING,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\n}\r\nreturn general_allocate_string(ui, prompt_copy, 1,\r\nUIT_PROMPT, flags, result_buf, minsize, maxsize, NULL);\r\n}\r\nint UI_add_verify_string(UI *ui, const char *prompt, int flags,\r\nchar *result_buf, int minsize, int maxsize, const char *test_buf)\r\n{\r\nreturn general_allocate_string(ui, prompt, 0,\r\nUIT_VERIFY, flags, result_buf, minsize, maxsize, test_buf);\r\n}\r\nint UI_dup_verify_string(UI *ui, const char *prompt, int flags,\r\nchar *result_buf, int minsize, int maxsize, const char *test_buf)\r\n{\r\nchar *prompt_copy=NULL;\r\nif (prompt)\r\n{\r\nprompt_copy=BUF_strdup(prompt);\r\nif (prompt_copy == NULL)\r\n{\r\nUIerr(UI_F_UI_DUP_VERIFY_STRING,ERR_R_MALLOC_FAILURE);\r\nreturn -1;\r\n}\r\n}\r\nreturn general_allocate_string(ui, prompt_copy, 1,\r\nUIT_VERIFY, flags, result_buf, minsize, maxsize, test_buf);\r\n}\r\nint UI_add_input_boolean(UI *ui, const char *prompt, const char *action_desc,\r\nconst char *ok_chars, const char *cancel_chars,\r\nint flags, char *result_buf)\r\n{\r\nreturn general_allocate_boolean(ui, prompt, action_desc,\r\nok_chars, cancel_chars, 0, UIT_BOOLEAN, flags, result_buf);\r\n}\r\nint UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,\r\nconst char *ok_chars, const char *cancel_chars,\r\nint flags, char *result_buf)\r\n{\r\nchar *prompt_copy = NULL;\r\nchar *action_desc_copy = NULL;\r\nchar *ok_chars_copy = NULL;\r\nchar *cancel_chars_copy = NULL;\r\nif (prompt)\r\n{\r\nprompt_copy=BUF_strdup(prompt);\r\nif (prompt_copy == NULL)\r\n{\r\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\n}\r\nif (action_desc)\r\n{\r\naction_desc_copy=BUF_strdup(action_desc);\r\nif (action_desc_copy == NULL)\r\n{\r\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\n}\r\nif (ok_chars)\r\n{\r\nok_chars_copy=BUF_strdup(ok_chars);\r\nif (ok_chars_copy == NULL)\r\n{\r\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\n}\r\nif (cancel_chars)\r\n{\r\ncancel_chars_copy=BUF_strdup(cancel_chars);\r\nif (cancel_chars_copy == NULL)\r\n{\r\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\n}\r\nreturn general_allocate_boolean(ui, prompt_copy, action_desc_copy,\r\nok_chars_copy, cancel_chars_copy, 1, UIT_BOOLEAN, flags,\r\nresult_buf);\r\nerr:\r\nif (prompt_copy) OPENSSL_free(prompt_copy);\r\nif (action_desc_copy) OPENSSL_free(action_desc_copy);\r\nif (ok_chars_copy) OPENSSL_free(ok_chars_copy);\r\nif (cancel_chars_copy) OPENSSL_free(cancel_chars_copy);\r\nreturn -1;\r\n}\r\nint UI_add_info_string(UI *ui, const char *text)\r\n{\r\nreturn general_allocate_string(ui, text, 0, UIT_INFO, 0, NULL, 0, 0,\r\nNULL);\r\n}\r\nint UI_dup_info_string(UI *ui, const char *text)\r\n{\r\nchar *text_copy=NULL;\r\nif (text)\r\n{\r\ntext_copy=BUF_strdup(text);\r\nif (text_copy == NULL)\r\n{\r\nUIerr(UI_F_UI_DUP_INFO_STRING,ERR_R_MALLOC_FAILURE);\r\nreturn -1;\r\n}\r\n}\r\nreturn general_allocate_string(ui, text_copy, 1, UIT_INFO, 0, NULL,\r\n0, 0, NULL);\r\n}\r\nint UI_add_error_string(UI *ui, const char *text)\r\n{\r\nreturn general_allocate_string(ui, text, 0, UIT_ERROR, 0, NULL, 0, 0,\r\nNULL);\r\n}\r\nint UI_dup_error_string(UI *ui, const char *text)\r\n{\r\nchar *text_copy=NULL;\r\nif (text)\r\n{\r\ntext_copy=BUF_strdup(text);\r\nif (text_copy == NULL)\r\n{\r\nUIerr(UI_F_UI_DUP_ERROR_STRING,ERR_R_MALLOC_FAILURE);\r\nreturn -1;\r\n}\r\n}\r\nreturn general_allocate_string(ui, text_copy, 1, UIT_ERROR, 0, NULL,\r\n0, 0, NULL);\r\n}\r\nchar *UI_construct_prompt(UI *ui, const char *object_desc,\r\nconst char *object_name)\r\n{\r\nchar *prompt = NULL;\r\nif (ui->meth->ui_construct_prompt)\r\nprompt = ui->meth->ui_construct_prompt(ui,\r\nobject_desc, object_name);\r\nelse\r\n{\r\nchar prompt1[] = "Enter ";\r\nchar prompt2[] = " for ";\r\nchar prompt3[] = ":";\r\nint len = 0;\r\nif (object_desc == NULL)\r\nreturn NULL;\r\nlen = sizeof(prompt1) - 1 + strlen(object_desc);\r\nif (object_name)\r\nlen += sizeof(prompt2) - 1 + strlen(object_name);\r\nlen += sizeof(prompt3) - 1;\r\nprompt = (char *)OPENSSL_malloc(len + 1);\r\nBUF_strlcpy(prompt, prompt1, len + 1);\r\nBUF_strlcat(prompt, object_desc, len + 1);\r\nif (object_name)\r\n{\r\nBUF_strlcat(prompt, prompt2, len + 1);\r\nBUF_strlcat(prompt, object_name, len + 1);\r\n}\r\nBUF_strlcat(prompt, prompt3, len + 1);\r\n}\r\nreturn prompt;\r\n}\r\nvoid *UI_add_user_data(UI *ui, void *user_data)\r\n{\r\nvoid *old_data = ui->user_data;\r\nui->user_data = user_data;\r\nreturn old_data;\r\n}\r\nvoid *UI_get0_user_data(UI *ui)\r\n{\r\nreturn ui->user_data;\r\n}\r\nconst char *UI_get0_result(UI *ui, int i)\r\n{\r\nif (i < 0)\r\n{\r\nUIerr(UI_F_UI_GET0_RESULT,UI_R_INDEX_TOO_SMALL);\r\nreturn NULL;\r\n}\r\nif (i >= sk_UI_STRING_num(ui->strings))\r\n{\r\nUIerr(UI_F_UI_GET0_RESULT,UI_R_INDEX_TOO_LARGE);\r\nreturn NULL;\r\n}\r\nreturn UI_get0_result_string(sk_UI_STRING_value(ui->strings, i));\r\n}\r\nstatic int print_error(const char *str, size_t len, UI *ui)\r\n{\r\nUI_STRING uis;\r\nmemset(&uis, 0, sizeof(uis));\r\nuis.type = UIT_ERROR;\r\nuis.out_string = str;\r\nif (ui->meth->ui_write_string\r\n&& !ui->meth->ui_write_string(ui, &uis))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint UI_process(UI *ui)\r\n{\r\nint i, ok=0;\r\nif (ui->meth->ui_open_session && !ui->meth->ui_open_session(ui))\r\nreturn -1;\r\nif (ui->flags & UI_FLAG_PRINT_ERRORS)\r\nERR_print_errors_cb(\r\n(int (*)(const char *, size_t, void *))print_error,\r\n(void *)ui);\r\nfor(i=0; i<sk_UI_STRING_num(ui->strings); i++)\r\n{\r\nif (ui->meth->ui_write_string\r\n&& !ui->meth->ui_write_string(ui,\r\nsk_UI_STRING_value(ui->strings, i)))\r\n{\r\nok=-1;\r\ngoto err;\r\n}\r\n}\r\nif (ui->meth->ui_flush)\r\nswitch(ui->meth->ui_flush(ui))\r\n{\r\ncase -1:\r\nok = -2;\r\ngoto err;\r\ncase 0:\r\nok = -1;\r\ngoto err;\r\ndefault:\r\nok = 0;\r\nbreak;\r\n}\r\nfor(i=0; i<sk_UI_STRING_num(ui->strings); i++)\r\n{\r\nif (ui->meth->ui_read_string)\r\n{\r\nswitch(ui->meth->ui_read_string(ui,\r\nsk_UI_STRING_value(ui->strings, i)))\r\n{\r\ncase -1:\r\nok = -2;\r\ngoto err;\r\ncase 0:\r\nok = -1;\r\ngoto err;\r\ndefault:\r\nok = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nerr:\r\nif (ui->meth->ui_close_session && !ui->meth->ui_close_session(ui))\r\nreturn -1;\r\nreturn ok;\r\n}\r\nint UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f)(void))\r\n{\r\nif (ui == NULL)\r\n{\r\nUIerr(UI_F_UI_CTRL,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn -1;\r\n}\r\nswitch(cmd)\r\n{\r\ncase UI_CTRL_PRINT_ERRORS:\r\n{\r\nint save_flag = !!(ui->flags & UI_FLAG_PRINT_ERRORS);\r\nif (i)\r\nui->flags |= UI_FLAG_PRINT_ERRORS;\r\nelse\r\nui->flags &= ~UI_FLAG_PRINT_ERRORS;\r\nreturn save_flag;\r\n}\r\ncase UI_CTRL_IS_REDOABLE:\r\nreturn !!(ui->flags & UI_FLAG_REDOABLE);\r\ndefault:\r\nbreak;\r\n}\r\nUIerr(UI_F_UI_CTRL,UI_R_UNKNOWN_CONTROL_COMMAND);\r\nreturn -1;\r\n}\r\nint UI_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\r\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\r\n{\r\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_UI, argl, argp,\r\nnew_func, dup_func, free_func);\r\n}\r\nint UI_set_ex_data(UI *r, int idx, void *arg)\r\n{\r\nreturn(CRYPTO_set_ex_data(&r->ex_data,idx,arg));\r\n}\r\nvoid *UI_get_ex_data(UI *r, int idx)\r\n{\r\nreturn(CRYPTO_get_ex_data(&r->ex_data,idx));\r\n}\r\nvoid UI_set_default_method(const UI_METHOD *meth)\r\n{\r\ndefault_UI_meth=meth;\r\n}\r\nconst UI_METHOD *UI_get_default_method(void)\r\n{\r\nif (default_UI_meth == NULL)\r\n{\r\ndefault_UI_meth=UI_OpenSSL();\r\n}\r\nreturn default_UI_meth;\r\n}\r\nconst UI_METHOD *UI_get_method(UI *ui)\r\n{\r\nreturn ui->meth;\r\n}\r\nconst UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth)\r\n{\r\nui->meth=meth;\r\nreturn ui->meth;\r\n}\r\nUI_METHOD *UI_create_method(char *name)\r\n{\r\nUI_METHOD *ui_method = (UI_METHOD *)OPENSSL_malloc(sizeof(UI_METHOD));\r\nif (ui_method)\r\n{\r\nmemset(ui_method, 0, sizeof(*ui_method));\r\nui_method->name = BUF_strdup(name);\r\n}\r\nreturn ui_method;\r\n}\r\nvoid UI_destroy_method(UI_METHOD *ui_method)\r\n{\r\nOPENSSL_free(ui_method->name);\r\nui_method->name = NULL;\r\nOPENSSL_free(ui_method);\r\n}\r\nint UI_method_set_opener(UI_METHOD *method, int (*opener)(UI *ui))\r\n{\r\nif (method)\r\n{\r\nmethod->ui_open_session = opener;\r\nreturn 0;\r\n}\r\nelse\r\nreturn -1;\r\n}\r\nint UI_method_set_writer(UI_METHOD *method, int (*writer)(UI *ui, UI_STRING *uis))\r\n{\r\nif (method)\r\n{\r\nmethod->ui_write_string = writer;\r\nreturn 0;\r\n}\r\nelse\r\nreturn -1;\r\n}\r\nint UI_method_set_flusher(UI_METHOD *method, int (*flusher)(UI *ui))\r\n{\r\nif (method)\r\n{\r\nmethod->ui_flush = flusher;\r\nreturn 0;\r\n}\r\nelse\r\nreturn -1;\r\n}\r\nint UI_method_set_reader(UI_METHOD *method, int (*reader)(UI *ui, UI_STRING *uis))\r\n{\r\nif (method)\r\n{\r\nmethod->ui_read_string = reader;\r\nreturn 0;\r\n}\r\nelse\r\nreturn -1;\r\n}\r\nint UI_method_set_closer(UI_METHOD *method, int (*closer)(UI *ui))\r\n{\r\nif (method)\r\n{\r\nmethod->ui_close_session = closer;\r\nreturn 0;\r\n}\r\nelse\r\nreturn -1;\r\n}\r\nint UI_method_set_prompt_constructor(UI_METHOD *method, char *(*prompt_constructor)(UI* ui, const char* object_desc, const char* object_name))\r\n{\r\nif (method)\r\n{\r\nmethod->ui_construct_prompt = prompt_constructor;\r\nreturn 0;\r\n}\r\nelse\r\nreturn -1;\r\n}\r\nenum UI_string_types UI_get_string_type(UI_STRING *uis)\r\n{\r\nif (!uis)\r\nreturn UIT_NONE;\r\nreturn uis->type;\r\n}\r\nint UI_get_input_flags(UI_STRING *uis)\r\n{\r\nif (!uis)\r\nreturn 0;\r\nreturn uis->input_flags;\r\n}\r\nconst char *UI_get0_output_string(UI_STRING *uis)\r\n{\r\nif (!uis)\r\nreturn NULL;\r\nreturn uis->out_string;\r\n}\r\nconst char *UI_get0_action_string(UI_STRING *uis)\r\n{\r\nif (!uis)\r\nreturn NULL;\r\nswitch(uis->type)\r\n{\r\ncase UIT_PROMPT:\r\ncase UIT_BOOLEAN:\r\nreturn uis->_.boolean_data.action_desc;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nconst char *UI_get0_result_string(UI_STRING *uis)\r\n{\r\nif (!uis)\r\nreturn NULL;\r\nswitch(uis->type)\r\n{\r\ncase UIT_PROMPT:\r\ncase UIT_VERIFY:\r\nreturn uis->result_buf;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nconst char *UI_get0_test_string(UI_STRING *uis)\r\n{\r\nif (!uis)\r\nreturn NULL;\r\nswitch(uis->type)\r\n{\r\ncase UIT_VERIFY:\r\nreturn uis->_.string_data.test_buf;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nint UI_get_result_minsize(UI_STRING *uis)\r\n{\r\nif (!uis)\r\nreturn -1;\r\nswitch(uis->type)\r\n{\r\ncase UIT_PROMPT:\r\ncase UIT_VERIFY:\r\nreturn uis->_.string_data.result_minsize;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nint UI_get_result_maxsize(UI_STRING *uis)\r\n{\r\nif (!uis)\r\nreturn -1;\r\nswitch(uis->type)\r\n{\r\ncase UIT_PROMPT:\r\ncase UIT_VERIFY:\r\nreturn uis->_.string_data.result_maxsize;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nint UI_set_result(UI *ui, UI_STRING *uis, const char *result)\r\n{\r\nint l = strlen(result);\r\nui->flags &= ~UI_FLAG_REDOABLE;\r\nif (!uis)\r\nreturn -1;\r\nswitch (uis->type)\r\n{\r\ncase UIT_PROMPT:\r\ncase UIT_VERIFY:\r\n{\r\nchar number1[DECIMAL_SIZE(uis->_.string_data.result_minsize)+1];\r\nchar number2[DECIMAL_SIZE(uis->_.string_data.result_maxsize)+1];\r\nBIO_snprintf(number1, sizeof(number1), "%d",\r\nuis->_.string_data.result_minsize);\r\nBIO_snprintf(number2, sizeof(number2), "%d",\r\nuis->_.string_data.result_maxsize);\r\nif (l < uis->_.string_data.result_minsize)\r\n{\r\nui->flags |= UI_FLAG_REDOABLE;\r\nUIerr(UI_F_UI_SET_RESULT,UI_R_RESULT_TOO_SMALL);\r\nERR_add_error_data(5,"You must type in ",\r\nnumber1," to ",number2," characters");\r\nreturn -1;\r\n}\r\nif (l > uis->_.string_data.result_maxsize)\r\n{\r\nui->flags |= UI_FLAG_REDOABLE;\r\nUIerr(UI_F_UI_SET_RESULT,UI_R_RESULT_TOO_LARGE);\r\nERR_add_error_data(5,"You must type in ",\r\nnumber1," to ",number2," characters");\r\nreturn -1;\r\n}\r\n}\r\nif (!uis->result_buf)\r\n{\r\nUIerr(UI_F_UI_SET_RESULT,UI_R_NO_RESULT_BUFFER);\r\nreturn -1;\r\n}\r\nBUF_strlcpy(uis->result_buf, result,\r\nuis->_.string_data.result_maxsize + 1);\r\nbreak;\r\ncase UIT_BOOLEAN:\r\n{\r\nconst char *p;\r\nif (!uis->result_buf)\r\n{\r\nUIerr(UI_F_UI_SET_RESULT,UI_R_NO_RESULT_BUFFER);\r\nreturn -1;\r\n}\r\nuis->result_buf[0] = '\0';\r\nfor(p = result; *p; p++)\r\n{\r\nif (strchr(uis->_.boolean_data.ok_chars, *p))\r\n{\r\nuis->result_buf[0] =\r\nuis->_.boolean_data.ok_chars[0];\r\nbreak;\r\n}\r\nif (strchr(uis->_.boolean_data.cancel_chars, *p))\r\n{\r\nuis->result_buf[0] =\r\nuis->_.boolean_data.cancel_chars[0];\r\nbreak;\r\n}\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
