DSO_METHOD *DSO_METHOD_dl(void)\r\n{\r\nreturn NULL;\r\n}\r\nDSO_METHOD *DSO_METHOD_dl(void)\r\n{\r\nreturn(&dso_meth_dl);\r\n}\r\nstatic int dl_load(DSO *dso)\r\n{\r\nshl_t ptr = NULL;\r\nchar *filename= DSO_convert_filename(dso, NULL);\r\nif(filename == NULL)\r\n{\r\nDSOerr(DSO_F_DL_LOAD,DSO_R_NO_FILENAME);\r\ngoto err;\r\n}\r\nptr = shl_load(filename, BIND_IMMEDIATE |\r\n(dso->flags&DSO_FLAG_NO_NAME_TRANSLATION?0:DYNAMIC_PATH), 0L);\r\nif(ptr == NULL)\r\n{\r\nDSOerr(DSO_F_DL_LOAD,DSO_R_LOAD_FAILED);\r\nERR_add_error_data(4, "filename(", filename, "): ",\r\nstrerror(errno));\r\ngoto err;\r\n}\r\nif(!sk_push(dso->meth_data, (char *)ptr))\r\n{\r\nDSOerr(DSO_F_DL_LOAD,DSO_R_STACK_ERROR);\r\ngoto err;\r\n}\r\ndso->loaded_filename = filename;\r\nreturn(1);\r\nerr:\r\nif(filename != NULL)\r\nOPENSSL_free(filename);\r\nif(ptr != NULL)\r\nshl_unload(ptr);\r\nreturn(0);\r\n}\r\nstatic int dl_unload(DSO *dso)\r\n{\r\nshl_t ptr;\r\nif(dso == NULL)\r\n{\r\nDSOerr(DSO_F_DL_UNLOAD,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn(0);\r\n}\r\nif(sk_num(dso->meth_data) < 1)\r\nreturn(1);\r\nptr = (shl_t)sk_pop(dso->meth_data);\r\nif(ptr == NULL)\r\n{\r\nDSOerr(DSO_F_DL_UNLOAD,DSO_R_NULL_HANDLE);\r\nsk_push(dso->meth_data, (char *)ptr);\r\nreturn(0);\r\n}\r\nshl_unload(ptr);\r\nreturn(1);\r\n}\r\nstatic void *dl_bind_var(DSO *dso, const char *symname)\r\n{\r\nshl_t ptr;\r\nvoid *sym;\r\nif((dso == NULL) || (symname == NULL))\r\n{\r\nDSOerr(DSO_F_DL_BIND_VAR,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn(NULL);\r\n}\r\nif(sk_num(dso->meth_data) < 1)\r\n{\r\nDSOerr(DSO_F_DL_BIND_VAR,DSO_R_STACK_ERROR);\r\nreturn(NULL);\r\n}\r\nptr = (shl_t)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\r\nif(ptr == NULL)\r\n{\r\nDSOerr(DSO_F_DL_BIND_VAR,DSO_R_NULL_HANDLE);\r\nreturn(NULL);\r\n}\r\nif (shl_findsym(&ptr, symname, TYPE_UNDEFINED, &sym) < 0)\r\n{\r\nDSOerr(DSO_F_DL_BIND_VAR,DSO_R_SYM_FAILURE);\r\nERR_add_error_data(4, "symname(", symname, "): ",\r\nstrerror(errno));\r\nreturn(NULL);\r\n}\r\nreturn(sym);\r\n}\r\nstatic DSO_FUNC_TYPE dl_bind_func(DSO *dso, const char *symname)\r\n{\r\nshl_t ptr;\r\nvoid *sym;\r\nif((dso == NULL) || (symname == NULL))\r\n{\r\nDSOerr(DSO_F_DL_BIND_FUNC,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn(NULL);\r\n}\r\nif(sk_num(dso->meth_data) < 1)\r\n{\r\nDSOerr(DSO_F_DL_BIND_FUNC,DSO_R_STACK_ERROR);\r\nreturn(NULL);\r\n}\r\nptr = (shl_t)sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\r\nif(ptr == NULL)\r\n{\r\nDSOerr(DSO_F_DL_BIND_FUNC,DSO_R_NULL_HANDLE);\r\nreturn(NULL);\r\n}\r\nif (shl_findsym(&ptr, symname, TYPE_UNDEFINED, &sym) < 0)\r\n{\r\nDSOerr(DSO_F_DL_BIND_FUNC,DSO_R_SYM_FAILURE);\r\nERR_add_error_data(4, "symname(", symname, "): ",\r\nstrerror(errno));\r\nreturn(NULL);\r\n}\r\nreturn((DSO_FUNC_TYPE)sym);\r\n}\r\nstatic char *dl_merger(DSO *dso, const char *filespec1, const char *filespec2)\r\n{\r\nchar *merged;\r\nif(!filespec1 && !filespec2)\r\n{\r\nDSOerr(DSO_F_DL_MERGER,\r\nERR_R_PASSED_NULL_PARAMETER);\r\nreturn(NULL);\r\n}\r\nif (!filespec2 || filespec1[0] == '/')\r\n{\r\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\r\nif(!merged)\r\n{\r\nDSOerr(DSO_F_DL_MERGER,\r\nERR_R_MALLOC_FAILURE);\r\nreturn(NULL);\r\n}\r\nstrcpy(merged, filespec1);\r\n}\r\nelse if (!filespec1)\r\n{\r\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\r\nif(!merged)\r\n{\r\nDSOerr(DSO_F_DL_MERGER,\r\nERR_R_MALLOC_FAILURE);\r\nreturn(NULL);\r\n}\r\nstrcpy(merged, filespec2);\r\n}\r\nelse\r\n{\r\nint spec2len, len;\r\nspec2len = (filespec2 ? strlen(filespec2) : 0);\r\nlen = spec2len + (filespec1 ? strlen(filespec1) : 0);\r\nif(filespec2 && filespec2[spec2len - 1] == '/')\r\n{\r\nspec2len--;\r\nlen--;\r\n}\r\nmerged = OPENSSL_malloc(len + 2);\r\nif(!merged)\r\n{\r\nDSOerr(DSO_F_DL_MERGER,\r\nERR_R_MALLOC_FAILURE);\r\nreturn(NULL);\r\n}\r\nstrcpy(merged, filespec2);\r\nmerged[spec2len] = '/';\r\nstrcpy(&merged[spec2len + 1], filespec1);\r\n}\r\nreturn(merged);\r\n}\r\nstatic char *dl_name_converter(DSO *dso, const char *filename)\r\n{\r\nchar *translated;\r\nint len, rsize, transform;\r\nlen = strlen(filename);\r\nrsize = len + 1;\r\ntransform = (strstr(filename, "/") == NULL);\r\n{\r\nrsize += strlen(extension);\r\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\r\nrsize += 3;\r\n}\r\ntranslated = OPENSSL_malloc(rsize);\r\nif(translated == NULL)\r\n{\r\nDSOerr(DSO_F_DL_NAME_CONVERTER,\r\nDSO_R_NAME_TRANSLATION_FAILED);\r\nreturn(NULL);\r\n}\r\nif(transform)\r\n{\r\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\r\nsprintf(translated, "lib%s%s", filename, extension);\r\nelse\r\nsprintf(translated, "%s%s", filename, extension);\r\n}\r\nelse\r\nsprintf(translated, "%s", filename);\r\nreturn(translated);\r\n}\r\nstatic int dl_pathbyaddr(void *addr,char *path,int sz)\r\n{\r\nstruct shl_descriptor inf;\r\nint i,len;\r\nif (addr == NULL)\r\n{\r\nunion { int(*f)(void*,char*,int); void *p; } t =\r\n{ dl_pathbyaddr };\r\naddr = t.p;\r\n}\r\nfor (i=-1;shl_get_r(i,&inf)==0;i++)\r\n{\r\nif (((size_t)addr >= inf.tstart && (size_t)addr < inf.tend) ||\r\n((size_t)addr >= inf.dstart && (size_t)addr < inf.dend))\r\n{\r\nlen = (int)strlen(inf.filename);\r\nif (sz <= 0) return len+1;\r\nif (len >= sz) len=sz-1;\r\nmemcpy(path,inf.filename,len);\r\npath[len++] = 0;\r\nreturn len;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void *dl_globallookup(const char *name)\r\n{\r\nvoid *ret;\r\nshl_t h = NULL;\r\nreturn shl_findsym(&h,name,TYPE_UNDEFINED,&ret) ? NULL : ret;\r\n}
