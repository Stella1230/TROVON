X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method)\r\n{\r\nX509_LOOKUP *ret;\r\nret=(X509_LOOKUP *)OPENSSL_malloc(sizeof(X509_LOOKUP));\r\nif (ret == NULL) return NULL;\r\nret->init=0;\r\nret->skip=0;\r\nret->method=method;\r\nret->method_data=NULL;\r\nret->store_ctx=NULL;\r\nif ((method->new_item != NULL) && !method->new_item(ret))\r\n{\r\nOPENSSL_free(ret);\r\nreturn NULL;\r\n}\r\nreturn ret;\r\n}\r\nvoid X509_LOOKUP_free(X509_LOOKUP *ctx)\r\n{\r\nif (ctx == NULL) return;\r\nif ( (ctx->method != NULL) &&\r\n(ctx->method->free != NULL))\r\nctx->method->free(ctx);\r\nOPENSSL_free(ctx);\r\n}\r\nint X509_LOOKUP_init(X509_LOOKUP *ctx)\r\n{\r\nif (ctx->method == NULL) return 0;\r\nif (ctx->method->init != NULL)\r\nreturn ctx->method->init(ctx);\r\nelse\r\nreturn 1;\r\n}\r\nint X509_LOOKUP_shutdown(X509_LOOKUP *ctx)\r\n{\r\nif (ctx->method == NULL) return 0;\r\nif (ctx->method->shutdown != NULL)\r\nreturn ctx->method->shutdown(ctx);\r\nelse\r\nreturn 1;\r\n}\r\nint X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,\r\nchar **ret)\r\n{\r\nif (ctx->method == NULL) return -1;\r\nif (ctx->method->ctrl != NULL)\r\nreturn ctx->method->ctrl(ctx,cmd,argc,argl,ret);\r\nelse\r\nreturn 1;\r\n}\r\nint X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,\r\nX509_OBJECT *ret)\r\n{\r\nif ((ctx->method == NULL) || (ctx->method->get_by_subject == NULL))\r\nreturn X509_LU_FAIL;\r\nif (ctx->skip) return 0;\r\nreturn ctx->method->get_by_subject(ctx,type,name,ret);\r\n}\r\nint X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name,\r\nASN1_INTEGER *serial, X509_OBJECT *ret)\r\n{\r\nif ((ctx->method == NULL) ||\r\n(ctx->method->get_by_issuer_serial == NULL))\r\nreturn X509_LU_FAIL;\r\nreturn ctx->method->get_by_issuer_serial(ctx,type,name,serial,ret);\r\n}\r\nint X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type,\r\nunsigned char *bytes, int len, X509_OBJECT *ret)\r\n{\r\nif ((ctx->method == NULL) || (ctx->method->get_by_fingerprint == NULL))\r\nreturn X509_LU_FAIL;\r\nreturn ctx->method->get_by_fingerprint(ctx,type,bytes,len,ret);\r\n}\r\nint X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str, int len,\r\nX509_OBJECT *ret)\r\n{\r\nif ((ctx->method == NULL) || (ctx->method->get_by_alias == NULL))\r\nreturn X509_LU_FAIL;\r\nreturn ctx->method->get_by_alias(ctx,type,str,len,ret);\r\n}\r\nstatic int x509_object_cmp(const X509_OBJECT * const *a, const X509_OBJECT * const *b)\r\n{\r\nint ret;\r\nret=((*a)->type - (*b)->type);\r\nif (ret) return ret;\r\nswitch ((*a)->type)\r\n{\r\ncase X509_LU_X509:\r\nret=X509_subject_name_cmp((*a)->data.x509,(*b)->data.x509);\r\nbreak;\r\ncase X509_LU_CRL:\r\nret=X509_CRL_cmp((*a)->data.crl,(*b)->data.crl);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn ret;\r\n}\r\nX509_STORE *X509_STORE_new(void)\r\n{\r\nX509_STORE *ret;\r\nif ((ret=(X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL)\r\nreturn NULL;\r\nret->objs = sk_X509_OBJECT_new(x509_object_cmp);\r\nret->cache=1;\r\nret->get_cert_methods=sk_X509_LOOKUP_new_null();\r\nret->verify=0;\r\nret->verify_cb=0;\r\nif ((ret->param = X509_VERIFY_PARAM_new()) == NULL)\r\nreturn NULL;\r\nret->get_issuer = 0;\r\nret->check_issued = 0;\r\nret->check_revocation = 0;\r\nret->get_crl = 0;\r\nret->check_crl = 0;\r\nret->cert_crl = 0;\r\nret->lookup_certs = 0;\r\nret->lookup_crls = 0;\r\nret->cleanup = 0;\r\nif (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data))\r\n{\r\nsk_X509_OBJECT_free(ret->objs);\r\nOPENSSL_free(ret);\r\nreturn NULL;\r\n}\r\nret->references=1;\r\nreturn ret;\r\n}\r\nstatic void cleanup(X509_OBJECT *a)\r\n{\r\nif (a->type == X509_LU_X509)\r\n{\r\nX509_free(a->data.x509);\r\n}\r\nelse if (a->type == X509_LU_CRL)\r\n{\r\nX509_CRL_free(a->data.crl);\r\n}\r\nelse\r\n{\r\n}\r\nOPENSSL_free(a);\r\n}\r\nvoid X509_STORE_free(X509_STORE *vfy)\r\n{\r\nint i;\r\nSTACK_OF(X509_LOOKUP) *sk;\r\nX509_LOOKUP *lu;\r\nif (vfy == NULL)\r\nreturn;\r\nsk=vfy->get_cert_methods;\r\nfor (i=0; i<sk_X509_LOOKUP_num(sk); i++)\r\n{\r\nlu=sk_X509_LOOKUP_value(sk,i);\r\nX509_LOOKUP_shutdown(lu);\r\nX509_LOOKUP_free(lu);\r\n}\r\nsk_X509_LOOKUP_free(sk);\r\nsk_X509_OBJECT_pop_free(vfy->objs, cleanup);\r\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE, vfy, &vfy->ex_data);\r\nif (vfy->param)\r\nX509_VERIFY_PARAM_free(vfy->param);\r\nOPENSSL_free(vfy);\r\n}\r\nX509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)\r\n{\r\nint i;\r\nSTACK_OF(X509_LOOKUP) *sk;\r\nX509_LOOKUP *lu;\r\nsk=v->get_cert_methods;\r\nfor (i=0; i<sk_X509_LOOKUP_num(sk); i++)\r\n{\r\nlu=sk_X509_LOOKUP_value(sk,i);\r\nif (m == lu->method)\r\n{\r\nreturn lu;\r\n}\r\n}\r\nlu=X509_LOOKUP_new(m);\r\nif (lu == NULL)\r\nreturn NULL;\r\nelse\r\n{\r\nlu->store_ctx=v;\r\nif (sk_X509_LOOKUP_push(v->get_cert_methods,lu))\r\nreturn lu;\r\nelse\r\n{\r\nX509_LOOKUP_free(lu);\r\nreturn NULL;\r\n}\r\n}\r\n}\r\nint X509_STORE_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,\r\nX509_OBJECT *ret)\r\n{\r\nX509_STORE *ctx=vs->ctx;\r\nX509_LOOKUP *lu;\r\nX509_OBJECT stmp,*tmp;\r\nint i,j;\r\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\r\ntmp=X509_OBJECT_retrieve_by_subject(ctx->objs,type,name);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\r\nif (tmp == NULL || type == X509_LU_CRL)\r\n{\r\nfor (i=vs->current_method; i<sk_X509_LOOKUP_num(ctx->get_cert_methods); i++)\r\n{\r\nlu=sk_X509_LOOKUP_value(ctx->get_cert_methods,i);\r\nj=X509_LOOKUP_by_subject(lu,type,name,&stmp);\r\nif (j < 0)\r\n{\r\nvs->current_method=j;\r\nreturn j;\r\n}\r\nelse if (j)\r\n{\r\ntmp= &stmp;\r\nbreak;\r\n}\r\n}\r\nvs->current_method=0;\r\nif (tmp == NULL)\r\nreturn 0;\r\n}\r\nret->type=tmp->type;\r\nret->data.ptr=tmp->data.ptr;\r\nX509_OBJECT_up_ref_count(ret);\r\nreturn 1;\r\n}\r\nint X509_STORE_add_cert(X509_STORE *ctx, X509 *x)\r\n{\r\nX509_OBJECT *obj;\r\nint ret=1;\r\nif (x == NULL) return 0;\r\nobj=(X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));\r\nif (obj == NULL)\r\n{\r\nX509err(X509_F_X509_STORE_ADD_CERT,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nobj->type=X509_LU_X509;\r\nobj->data.x509=x;\r\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\r\nX509_OBJECT_up_ref_count(obj);\r\nif (X509_OBJECT_retrieve_match(ctx->objs, obj))\r\n{\r\nX509_OBJECT_free_contents(obj);\r\nOPENSSL_free(obj);\r\nX509err(X509_F_X509_STORE_ADD_CERT,X509_R_CERT_ALREADY_IN_HASH_TABLE);\r\nret=0;\r\n}\r\nelse sk_X509_OBJECT_push(ctx->objs, obj);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\r\nreturn ret;\r\n}\r\nint X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)\r\n{\r\nX509_OBJECT *obj;\r\nint ret=1;\r\nif (x == NULL) return 0;\r\nobj=(X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));\r\nif (obj == NULL)\r\n{\r\nX509err(X509_F_X509_STORE_ADD_CRL,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nobj->type=X509_LU_CRL;\r\nobj->data.crl=x;\r\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\r\nX509_OBJECT_up_ref_count(obj);\r\nif (X509_OBJECT_retrieve_match(ctx->objs, obj))\r\n{\r\nX509_OBJECT_free_contents(obj);\r\nOPENSSL_free(obj);\r\nX509err(X509_F_X509_STORE_ADD_CRL,X509_R_CERT_ALREADY_IN_HASH_TABLE);\r\nret=0;\r\n}\r\nelse sk_X509_OBJECT_push(ctx->objs, obj);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\r\nreturn ret;\r\n}\r\nvoid X509_OBJECT_up_ref_count(X509_OBJECT *a)\r\n{\r\nswitch (a->type)\r\n{\r\ncase X509_LU_X509:\r\nCRYPTO_add(&a->data.x509->references,1,CRYPTO_LOCK_X509);\r\nbreak;\r\ncase X509_LU_CRL:\r\nCRYPTO_add(&a->data.crl->references,1,CRYPTO_LOCK_X509_CRL);\r\nbreak;\r\n}\r\n}\r\nvoid X509_OBJECT_free_contents(X509_OBJECT *a)\r\n{\r\nswitch (a->type)\r\n{\r\ncase X509_LU_X509:\r\nX509_free(a->data.x509);\r\nbreak;\r\ncase X509_LU_CRL:\r\nX509_CRL_free(a->data.crl);\r\nbreak;\r\n}\r\n}\r\nint X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags)\r\n{\r\nreturn X509_VERIFY_PARAM_set_flags(ctx->param, flags);\r\n}\r\nint X509_STORE_set_depth(X509_STORE *ctx, int depth)\r\n{\r\nX509_VERIFY_PARAM_set_depth(ctx->param, depth);\r\nreturn 1;\r\n}\r\nint X509_STORE_set_purpose(X509_STORE *ctx, int purpose)\r\n{\r\nreturn X509_VERIFY_PARAM_set_purpose(ctx->param, purpose);\r\n}\r\nint X509_STORE_set_trust(X509_STORE *ctx, int trust)\r\n{\r\nreturn X509_VERIFY_PARAM_set_trust(ctx->param, trust);\r\n}\r\nint X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *param)\r\n{\r\nreturn X509_VERIFY_PARAM_set1(ctx->param, param);\r\n}\r\nvoid X509_STORE_set_verify_cb(X509_STORE *ctx,\r\nint (*verify_cb)(int, X509_STORE_CTX *))\r\n{\r\nctx->verify_cb = verify_cb;\r\n}
