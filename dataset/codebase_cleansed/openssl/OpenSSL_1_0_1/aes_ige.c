void AES_ige_encrypt(const unsigned char *in, unsigned char *out,\r\nsize_t length, const AES_KEY *key,\r\nunsigned char *ivec, const int enc)\r\n{\r\nsize_t n;\r\nsize_t len = length;\r\nOPENSSL_assert(in && out && key && ivec);\r\nOPENSSL_assert((AES_ENCRYPT == enc)||(AES_DECRYPT == enc));\r\nOPENSSL_assert((length%AES_BLOCK_SIZE) == 0);\r\nlen = length / AES_BLOCK_SIZE;\r\nif (AES_ENCRYPT == enc)\r\n{\r\nif (in != out &&\r\n(UNALIGNED_MEMOPS_ARE_FAST || ((size_t)in|(size_t)out|(size_t)ivec)%sizeof(long)==0))\r\n{\r\naes_block_t *ivp = (aes_block_t *)ivec;\r\naes_block_t *iv2p = (aes_block_t *)(ivec + AES_BLOCK_SIZE);\r\nwhile (len)\r\n{\r\naes_block_t *inp = (aes_block_t *)in;\r\naes_block_t *outp = (aes_block_t *)out;\r\nfor(n=0 ; n < N_WORDS; ++n)\r\noutp->data[n] = inp->data[n] ^ ivp->data[n];\r\nAES_encrypt((unsigned char *)outp->data, (unsigned char *)outp->data, key);\r\nfor(n=0 ; n < N_WORDS; ++n)\r\noutp->data[n] ^= iv2p->data[n];\r\nivp = outp;\r\niv2p = inp;\r\n--len;\r\nin += AES_BLOCK_SIZE;\r\nout += AES_BLOCK_SIZE;\r\n}\r\nmemcpy(ivec, ivp->data, AES_BLOCK_SIZE);\r\nmemcpy(ivec + AES_BLOCK_SIZE, iv2p->data, AES_BLOCK_SIZE);\r\n}\r\nelse\r\n{\r\naes_block_t tmp, tmp2;\r\naes_block_t iv;\r\naes_block_t iv2;\r\nload_block(iv, ivec);\r\nload_block(iv2, ivec + AES_BLOCK_SIZE);\r\nwhile (len)\r\n{\r\nload_block(tmp, in);\r\nfor(n=0 ; n < N_WORDS; ++n)\r\ntmp2.data[n] = tmp.data[n] ^ iv.data[n];\r\nAES_encrypt((unsigned char *)tmp2.data, (unsigned char *)tmp2.data, key);\r\nfor(n=0 ; n < N_WORDS; ++n)\r\ntmp2.data[n] ^= iv2.data[n];\r\nstore_block(out, tmp2);\r\niv = tmp2;\r\niv2 = tmp;\r\n--len;\r\nin += AES_BLOCK_SIZE;\r\nout += AES_BLOCK_SIZE;\r\n}\r\nmemcpy(ivec, iv.data, AES_BLOCK_SIZE);\r\nmemcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);\r\n}\r\n}\r\nelse\r\n{\r\nif (in != out &&\r\n(UNALIGNED_MEMOPS_ARE_FAST || ((size_t)in|(size_t)out|(size_t)ivec)%sizeof(long)==0))\r\n{\r\naes_block_t *ivp = (aes_block_t *)ivec;\r\naes_block_t *iv2p = (aes_block_t *)(ivec + AES_BLOCK_SIZE);\r\nwhile (len)\r\n{\r\naes_block_t tmp;\r\naes_block_t *inp = (aes_block_t *)in;\r\naes_block_t *outp = (aes_block_t *)out;\r\nfor(n=0 ; n < N_WORDS; ++n)\r\ntmp.data[n] = inp->data[n] ^ iv2p->data[n];\r\nAES_decrypt((unsigned char *)tmp.data, (unsigned char *)outp->data, key);\r\nfor(n=0 ; n < N_WORDS; ++n)\r\noutp->data[n] ^= ivp->data[n];\r\nivp = inp;\r\niv2p = outp;\r\n--len;\r\nin += AES_BLOCK_SIZE;\r\nout += AES_BLOCK_SIZE;\r\n}\r\nmemcpy(ivec, ivp->data, AES_BLOCK_SIZE);\r\nmemcpy(ivec + AES_BLOCK_SIZE, iv2p->data, AES_BLOCK_SIZE);\r\n}\r\nelse\r\n{\r\naes_block_t tmp, tmp2;\r\naes_block_t iv;\r\naes_block_t iv2;\r\nload_block(iv, ivec);\r\nload_block(iv2, ivec + AES_BLOCK_SIZE);\r\nwhile (len)\r\n{\r\nload_block(tmp, in);\r\ntmp2 = tmp;\r\nfor(n=0 ; n < N_WORDS; ++n)\r\ntmp.data[n] ^= iv2.data[n];\r\nAES_decrypt((unsigned char *)tmp.data, (unsigned char *)tmp.data, key);\r\nfor(n=0 ; n < N_WORDS; ++n)\r\ntmp.data[n] ^= iv.data[n];\r\nstore_block(out, tmp);\r\niv = tmp2;\r\niv2 = tmp;\r\n--len;\r\nin += AES_BLOCK_SIZE;\r\nout += AES_BLOCK_SIZE;\r\n}\r\nmemcpy(ivec, iv.data, AES_BLOCK_SIZE);\r\nmemcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);\r\n}\r\n}\r\n}\r\nvoid AES_bi_ige_encrypt(const unsigned char *in, unsigned char *out,\r\nsize_t length, const AES_KEY *key,\r\nconst AES_KEY *key2, const unsigned char *ivec,\r\nconst int enc)\r\n{\r\nsize_t n;\r\nsize_t len = length;\r\nunsigned char tmp[AES_BLOCK_SIZE];\r\nunsigned char tmp2[AES_BLOCK_SIZE];\r\nunsigned char tmp3[AES_BLOCK_SIZE];\r\nunsigned char prev[AES_BLOCK_SIZE];\r\nconst unsigned char *iv;\r\nconst unsigned char *iv2;\r\nOPENSSL_assert(in && out && key && ivec);\r\nOPENSSL_assert((AES_ENCRYPT == enc)||(AES_DECRYPT == enc));\r\nOPENSSL_assert((length%AES_BLOCK_SIZE) == 0);\r\nif (AES_ENCRYPT == enc)\r\n{\r\niv = ivec;\r\niv2 = ivec + AES_BLOCK_SIZE;\r\nwhile (len >= AES_BLOCK_SIZE)\r\n{\r\nfor(n=0 ; n < AES_BLOCK_SIZE ; ++n)\r\nout[n] = in[n] ^ iv[n];\r\nAES_encrypt(out, out, key);\r\nfor(n=0 ; n < AES_BLOCK_SIZE ; ++n)\r\nout[n] ^= iv2[n];\r\niv = out;\r\nmemcpy(prev, in, AES_BLOCK_SIZE);\r\niv2 = prev;\r\nlen -= AES_BLOCK_SIZE;\r\nin += AES_BLOCK_SIZE;\r\nout += AES_BLOCK_SIZE;\r\n}\r\niv = ivec + AES_BLOCK_SIZE*2;\r\niv2 = ivec + AES_BLOCK_SIZE*3;\r\nlen = length;\r\nwhile(len >= AES_BLOCK_SIZE)\r\n{\r\nout -= AES_BLOCK_SIZE;\r\nmemcpy(tmp, out, AES_BLOCK_SIZE);\r\nfor(n=0 ; n < AES_BLOCK_SIZE ; ++n)\r\nout[n] ^= iv[n];\r\nAES_encrypt(out, out, key);\r\nfor(n=0 ; n < AES_BLOCK_SIZE ; ++n)\r\nout[n] ^= iv2[n];\r\niv = out;\r\nmemcpy(prev, tmp, AES_BLOCK_SIZE);\r\niv2 = prev;\r\nlen -= AES_BLOCK_SIZE;\r\n}\r\n}\r\nelse\r\n{\r\niv = ivec + AES_BLOCK_SIZE*2;\r\niv2 = ivec + AES_BLOCK_SIZE*3;\r\nin += length;\r\nout += length;\r\nwhile (len >= AES_BLOCK_SIZE)\r\n{\r\nin -= AES_BLOCK_SIZE;\r\nout -= AES_BLOCK_SIZE;\r\nmemcpy(tmp, in, AES_BLOCK_SIZE);\r\nmemcpy(tmp2, in, AES_BLOCK_SIZE);\r\nfor(n=0 ; n < AES_BLOCK_SIZE ; ++n)\r\ntmp[n] ^= iv2[n];\r\nAES_decrypt(tmp, out, key);\r\nfor(n=0 ; n < AES_BLOCK_SIZE ; ++n)\r\nout[n] ^= iv[n];\r\nmemcpy(tmp3, tmp2, AES_BLOCK_SIZE);\r\niv = tmp3;\r\niv2 = out;\r\nlen -= AES_BLOCK_SIZE;\r\n}\r\niv = ivec;\r\niv2 = ivec + AES_BLOCK_SIZE;\r\nlen = length;\r\nwhile (len >= AES_BLOCK_SIZE)\r\n{\r\nmemcpy(tmp, out, AES_BLOCK_SIZE);\r\nmemcpy(tmp2, out, AES_BLOCK_SIZE);\r\nfor(n=0 ; n < AES_BLOCK_SIZE ; ++n)\r\ntmp[n] ^= iv2[n];\r\nAES_decrypt(tmp, out, key);\r\nfor(n=0 ; n < AES_BLOCK_SIZE ; ++n)\r\nout[n] ^= iv[n];\r\nmemcpy(tmp3, tmp2, AES_BLOCK_SIZE);\r\niv = tmp3;\r\niv2 = out;\r\nlen -= AES_BLOCK_SIZE;\r\nin += AES_BLOCK_SIZE;\r\nout += AES_BLOCK_SIZE;\r\n}\r\n}\r\n}
