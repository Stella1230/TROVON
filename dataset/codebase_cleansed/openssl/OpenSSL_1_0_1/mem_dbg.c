static void app_info_free(APP_INFO *inf)\r\n{\r\nif (--(inf->references) <= 0)\r\n{\r\nif (inf->next != NULL)\r\n{\r\napp_info_free(inf->next);\r\n}\r\nOPENSSL_free(inf);\r\n}\r\n}\r\nint CRYPTO_mem_ctrl(int mode)\r\n{\r\nint ret=mh_mode;\r\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\r\nswitch (mode)\r\n{\r\ncase CRYPTO_MEM_CHECK_ON:\r\nmh_mode = CRYPTO_MEM_CHECK_ON|CRYPTO_MEM_CHECK_ENABLE;\r\nnum_disable = 0;\r\nbreak;\r\ncase CRYPTO_MEM_CHECK_OFF:\r\nmh_mode = 0;\r\nnum_disable = 0;\r\nbreak;\r\ncase CRYPTO_MEM_CHECK_DISABLE:\r\nif (mh_mode & CRYPTO_MEM_CHECK_ON)\r\n{\r\nCRYPTO_THREADID cur;\r\nCRYPTO_THREADID_current(&cur);\r\nif (!num_disable || CRYPTO_THREADID_cmp(&disabling_threadid, &cur))\r\n{\r\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\r\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);\r\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\r\nmh_mode &= ~CRYPTO_MEM_CHECK_ENABLE;\r\nCRYPTO_THREADID_cpy(&disabling_threadid, &cur);\r\n}\r\nnum_disable++;\r\n}\r\nbreak;\r\ncase CRYPTO_MEM_CHECK_ENABLE:\r\nif (mh_mode & CRYPTO_MEM_CHECK_ON)\r\n{\r\nif (num_disable)\r\n{\r\nnum_disable--;\r\nif (num_disable == 0)\r\n{\r\nmh_mode|=CRYPTO_MEM_CHECK_ENABLE;\r\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\r\nreturn(ret);\r\n}\r\nint CRYPTO_is_mem_check_on(void)\r\n{\r\nint ret = 0;\r\nif (mh_mode & CRYPTO_MEM_CHECK_ON)\r\n{\r\nCRYPTO_THREADID cur;\r\nCRYPTO_THREADID_current(&cur);\r\nCRYPTO_r_lock(CRYPTO_LOCK_MALLOC);\r\nret = (mh_mode & CRYPTO_MEM_CHECK_ENABLE)\r\n|| CRYPTO_THREADID_cmp(&disabling_threadid, &cur);\r\nCRYPTO_r_unlock(CRYPTO_LOCK_MALLOC);\r\n}\r\nreturn(ret);\r\n}\r\nvoid CRYPTO_dbg_set_options(long bits)\r\n{\r\noptions = bits;\r\n}\r\nlong CRYPTO_dbg_get_options(void)\r\n{\r\nreturn options;\r\n}\r\nstatic int mem_cmp(const MEM *a, const MEM *b)\r\n{\r\n#ifdef _WIN64\r\nconst char *ap=(const char *)a->addr,\r\n*bp=(const char *)b->addr;\r\nif (ap==bp) return 0;\r\nelse if (ap>bp) return 1;\r\nelse return -1;\r\n#else\r\nreturn (const char *)a->addr - (const char *)b->addr;\r\n#endif\r\n}\r\nint CRYPTO_pop_info(void)\r\n{\r\nint ret=0;\r\nif (is_MemCheck_on())\r\n{\r\nMemCheck_off();\r\nret=(pop_info() != NULL);\r\nMemCheck_on();\r\n}\r\nreturn(ret);\r\n}\r\nint CRYPTO_remove_all_info(void)\r\n{\r\nint ret=0;\r\nif (is_MemCheck_on())\r\n{\r\nMemCheck_off();\r\nwhile(pop_info() != NULL)\r\nret++;\r\nMemCheck_on();\r\n}\r\nreturn(ret);\r\n}\r\nvoid CRYPTO_dbg_malloc(void *addr, int num, const char *file, int line,\r\nint before_p)\r\n{\r\nMEM *m,*mm;\r\nAPP_INFO tmp,*amim;\r\nswitch(before_p & 127)\r\n{\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nif (addr == NULL)\r\nbreak;\r\nif (is_MemCheck_on())\r\n{\r\nMemCheck_off();\r\nif ((m=(MEM *)OPENSSL_malloc(sizeof(MEM))) == NULL)\r\n{\r\nOPENSSL_free(addr);\r\nMemCheck_on();\r\nreturn;\r\n}\r\nif (mh == NULL)\r\n{\r\nif ((mh=lh_MEM_new()) == NULL)\r\n{\r\nOPENSSL_free(addr);\r\nOPENSSL_free(m);\r\naddr=NULL;\r\ngoto err;\r\n}\r\n}\r\nm->addr=addr;\r\nm->file=file;\r\nm->line=line;\r\nm->num=num;\r\nif (options & V_CRYPTO_MDEBUG_THREAD)\r\nCRYPTO_THREADID_current(&m->threadid);\r\nelse\r\nmemset(&m->threadid, 0, sizeof(m->threadid));\r\nif (order == break_order_num)\r\n{\r\nm->order=order;\r\n}\r\nm->order=order++;\r\n#ifdef LEVITTE_DEBUG_MEM\r\nfprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] %c 0x%p (%d)\n",\r\nm->order,\r\n(before_p & 128) ? '*' : '+',\r\nm->addr, m->num);\r\n#endif\r\nif (options & V_CRYPTO_MDEBUG_TIME)\r\nm->time=time(NULL);\r\nelse\r\nm->time=0;\r\nCRYPTO_THREADID_current(&tmp.threadid);\r\nm->app_info=NULL;\r\nif (amih != NULL\r\n&& (amim=lh_APP_INFO_retrieve(amih,&tmp)) != NULL)\r\n{\r\nm->app_info = amim;\r\namim->references++;\r\n}\r\nif ((mm=lh_MEM_insert(mh, m)) != NULL)\r\n{\r\nif (mm->app_info != NULL)\r\n{\r\nmm->app_info->references--;\r\n}\r\nOPENSSL_free(mm);\r\n}\r\nerr:\r\nMemCheck_on();\r\n}\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid CRYPTO_dbg_free(void *addr, int before_p)\r\n{\r\nMEM m,*mp;\r\nswitch(before_p)\r\n{\r\ncase 0:\r\nif (addr == NULL)\r\nbreak;\r\nif (is_MemCheck_on() && (mh != NULL))\r\n{\r\nMemCheck_off();\r\nm.addr=addr;\r\nmp=lh_MEM_delete(mh,&m);\r\nif (mp != NULL)\r\n{\r\n#ifdef LEVITTE_DEBUG_MEM\r\nfprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] - 0x%p (%d)\n",\r\nmp->order, mp->addr, mp->num);\r\n#endif\r\nif (mp->app_info != NULL)\r\napp_info_free(mp->app_info);\r\nOPENSSL_free(mp);\r\n}\r\nMemCheck_on();\r\n}\r\nbreak;\r\ncase 1:\r\nbreak;\r\n}\r\n}\r\nvoid CRYPTO_dbg_realloc(void *addr1, void *addr2, int num,\r\nconst char *file, int line, int before_p)\r\n{\r\nMEM m,*mp;\r\n#ifdef LEVITTE_DEBUG_MEM\r\nfprintf(stderr, "LEVITTE_DEBUG_MEM: --> CRYPTO_dbg_malloc(addr1 = %p, addr2 = %p, num = %d, file = \"%s\", line = %d, before_p = %d)\n",\r\naddr1, addr2, num, file, line, before_p);\r\n#endif\r\nswitch(before_p)\r\n{\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nif (addr2 == NULL)\r\nbreak;\r\nif (addr1 == NULL)\r\n{\r\nCRYPTO_dbg_malloc(addr2, num, file, line, 128 | before_p);\r\nbreak;\r\n}\r\nif (is_MemCheck_on())\r\n{\r\nMemCheck_off();\r\nm.addr=addr1;\r\nmp=lh_MEM_delete(mh,&m);\r\nif (mp != NULL)\r\n{\r\n#ifdef LEVITTE_DEBUG_MEM\r\nfprintf(stderr, "LEVITTE_DEBUG_MEM: [%5ld] * 0x%p (%d) -> 0x%p (%d)\n",\r\nmp->order,\r\nmp->addr, mp->num,\r\naddr2, num);\r\n#endif\r\nmp->addr=addr2;\r\nmp->num=num;\r\n(void)lh_MEM_insert(mh,mp);\r\n}\r\nMemCheck_on();\r\n}\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void print_leak_doall_arg(const MEM *m, MEM_LEAK *l)\r\n{\r\nchar buf[1024];\r\nchar *bufp = buf;\r\nAPP_INFO *amip;\r\nint ami_cnt;\r\nstruct tm *lcl = NULL;\r\nCRYPTO_THREADID ti;\r\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\r\nif(m->addr == (char *)l->bio)\r\nreturn;\r\nif (options & V_CRYPTO_MDEBUG_TIME)\r\n{\r\nlcl = localtime(&m->time);\r\nBIO_snprintf(bufp, BUF_REMAIN, "[%02d:%02d:%02d] ",\r\nlcl->tm_hour,lcl->tm_min,lcl->tm_sec);\r\nbufp += strlen(bufp);\r\n}\r\nBIO_snprintf(bufp, BUF_REMAIN, "%5lu file=%s, line=%d, ",\r\nm->order,m->file,m->line);\r\nbufp += strlen(bufp);\r\nif (options & V_CRYPTO_MDEBUG_THREAD)\r\n{\r\nBIO_snprintf(bufp, BUF_REMAIN, "thread=%lu, ",\r\nCRYPTO_THREADID_hash(&m->threadid));\r\nbufp += strlen(bufp);\r\n}\r\nBIO_snprintf(bufp, BUF_REMAIN, "number=%d, address=%08lX\n",\r\nm->num,(unsigned long)m->addr);\r\nbufp += strlen(bufp);\r\nBIO_puts(l->bio,buf);\r\nl->chunks++;\r\nl->bytes+=m->num;\r\namip=m->app_info;\r\nami_cnt=0;\r\nif (!amip)\r\nreturn;\r\nCRYPTO_THREADID_cpy(&ti, &amip->threadid);\r\ndo\r\n{\r\nint buf_len;\r\nint info_len;\r\nami_cnt++;\r\nmemset(buf,'>',ami_cnt);\r\nBIO_snprintf(buf + ami_cnt, sizeof buf - ami_cnt,\r\n" thread=%lu, file=%s, line=%d, info=\"",\r\nCRYPTO_THREADID_hash(&amip->threadid), amip->file,\r\namip->line);\r\nbuf_len=strlen(buf);\r\ninfo_len=strlen(amip->info);\r\nif (128 - buf_len - 3 < info_len)\r\n{\r\nmemcpy(buf + buf_len, amip->info, 128 - buf_len - 3);\r\nbuf_len = 128 - 3;\r\n}\r\nelse\r\n{\r\nBUF_strlcpy(buf + buf_len, amip->info,\r\nsizeof buf - buf_len);\r\nbuf_len = strlen(buf);\r\n}\r\nBIO_snprintf(buf + buf_len, sizeof buf - buf_len, "\"\n");\r\nBIO_puts(l->bio,buf);\r\namip = amip->next;\r\n}\r\nwhile(amip && !CRYPTO_THREADID_cmp(&amip->threadid, &ti));\r\n#ifdef LEVITTE_DEBUG_MEM\r\nif (amip)\r\n{\r\nfprintf(stderr, "Thread switch detected in backtrace!!!!\n");\r\nabort();\r\n}\r\n#endif\r\n}\r\nstatic void cb_leak_doall_arg(const MEM *m, PCRYPTO_MEM_LEAK_CB *cb)\r\n{\r\n(*cb)(m->order,m->file,m->line,m->num,m->addr);\r\n}
