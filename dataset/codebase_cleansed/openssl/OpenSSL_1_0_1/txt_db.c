TXT_DB *TXT_DB_read(BIO *in, int num)\r\n{\r\nTXT_DB *ret=NULL;\r\nint er=1;\r\nint esc=0;\r\nlong ln=0;\r\nint i,add,n;\r\nint size=BUFSIZE;\r\nint offset=0;\r\nchar *p,*f;\r\nOPENSSL_STRING *pp;\r\nBUF_MEM *buf=NULL;\r\nif ((buf=BUF_MEM_new()) == NULL) goto err;\r\nif (!BUF_MEM_grow(buf,size)) goto err;\r\nif ((ret=OPENSSL_malloc(sizeof(TXT_DB))) == NULL)\r\ngoto err;\r\nret->num_fields=num;\r\nret->index=NULL;\r\nret->qual=NULL;\r\nif ((ret->data=sk_OPENSSL_PSTRING_new_null()) == NULL)\r\ngoto err;\r\nif ((ret->index=OPENSSL_malloc(sizeof(*ret->index)*num)) == NULL)\r\ngoto err;\r\nif ((ret->qual=OPENSSL_malloc(sizeof(*(ret->qual))*num)) == NULL)\r\ngoto err;\r\nfor (i=0; i<num; i++)\r\n{\r\nret->index[i]=NULL;\r\nret->qual[i]=NULL;\r\n}\r\nadd=(num+1)*sizeof(char *);\r\nbuf->data[size-1]='\0';\r\noffset=0;\r\nfor (;;)\r\n{\r\nif (offset != 0)\r\n{\r\nsize+=BUFSIZE;\r\nif (!BUF_MEM_grow_clean(buf,size)) goto err;\r\n}\r\nbuf->data[offset]='\0';\r\nBIO_gets(in,&(buf->data[offset]),size-offset);\r\nln++;\r\nif (buf->data[offset] == '\0') break;\r\nif ((offset == 0) && (buf->data[0] == '#')) continue;\r\ni=strlen(&(buf->data[offset]));\r\noffset+=i;\r\nif (buf->data[offset-1] != '\n')\r\ncontinue;\r\nelse\r\n{\r\nbuf->data[offset-1]='\0';\r\nif (!(p=OPENSSL_malloc(add+offset))) goto err;\r\noffset=0;\r\n}\r\npp=(char **)p;\r\np+=add;\r\nn=0;\r\npp[n++]=p;\r\ni=0;\r\nf=buf->data;\r\nesc=0;\r\nfor (;;)\r\n{\r\nif (*f == '\0') break;\r\nif (*f == '\t')\r\n{\r\nif (esc)\r\np--;\r\nelse\r\n{\r\n*(p++)='\0';\r\nf++;\r\nif (n >= num) break;\r\npp[n++]=p;\r\ncontinue;\r\n}\r\n}\r\nesc=(*f == '\\');\r\n*(p++)= *(f++);\r\n}\r\n*(p++)='\0';\r\nif ((n != num) || (*f != '\0'))\r\n{\r\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\r\nfprintf(stderr,"wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)\n",ln,num,n,f);\r\n#endif\r\ner=2;\r\ngoto err;\r\n}\r\npp[n]=p;\r\nif (!sk_OPENSSL_PSTRING_push(ret->data,pp))\r\n{\r\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\r\nfprintf(stderr,"failure in sk_push\n");\r\n#endif\r\ner=2;\r\ngoto err;\r\n}\r\n}\r\ner=0;\r\nerr:\r\nBUF_MEM_free(buf);\r\nif (er)\r\n{\r\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\r\nif (er == 1) fprintf(stderr,"OPENSSL_malloc failure\n");\r\n#endif\r\nif (ret != NULL)\r\n{\r\nif (ret->data != NULL) sk_OPENSSL_PSTRING_free(ret->data);\r\nif (ret->index != NULL) OPENSSL_free(ret->index);\r\nif (ret->qual != NULL) OPENSSL_free(ret->qual);\r\nif (ret != NULL) OPENSSL_free(ret);\r\n}\r\nreturn(NULL);\r\n}\r\nelse\r\nreturn(ret);\r\n}\r\nOPENSSL_STRING *TXT_DB_get_by_index(TXT_DB *db, int idx, OPENSSL_STRING *value)\r\n{\r\nOPENSSL_STRING *ret;\r\nLHASH_OF(OPENSSL_STRING) *lh;\r\nif (idx >= db->num_fields)\r\n{\r\ndb->error=DB_ERROR_INDEX_OUT_OF_RANGE;\r\nreturn(NULL);\r\n}\r\nlh=db->index[idx];\r\nif (lh == NULL)\r\n{\r\ndb->error=DB_ERROR_NO_INDEX;\r\nreturn(NULL);\r\n}\r\nret=lh_OPENSSL_STRING_retrieve(lh,value);\r\ndb->error=DB_ERROR_OK;\r\nreturn(ret);\r\n}\r\nint TXT_DB_create_index(TXT_DB *db, int field, int (*qual)(OPENSSL_STRING *),\r\nLHASH_HASH_FN_TYPE hash, LHASH_COMP_FN_TYPE cmp)\r\n{\r\nLHASH_OF(OPENSSL_STRING) *idx;\r\nOPENSSL_STRING *r;\r\nint i,n;\r\nif (field >= db->num_fields)\r\n{\r\ndb->error=DB_ERROR_INDEX_OUT_OF_RANGE;\r\nreturn(0);\r\n}\r\nif ((idx=(LHASH_OF(OPENSSL_STRING) *)lh_new(hash,cmp)) == NULL)\r\n{\r\ndb->error=DB_ERROR_MALLOC;\r\nreturn(0);\r\n}\r\nn=sk_OPENSSL_PSTRING_num(db->data);\r\nfor (i=0; i<n; i++)\r\n{\r\nr=sk_OPENSSL_PSTRING_value(db->data,i);\r\nif ((qual != NULL) && (qual(r) == 0)) continue;\r\nif ((r=lh_OPENSSL_STRING_insert(idx,r)) != NULL)\r\n{\r\ndb->error=DB_ERROR_INDEX_CLASH;\r\ndb->arg1=sk_OPENSSL_PSTRING_find(db->data,r);\r\ndb->arg2=i;\r\nlh_OPENSSL_STRING_free(idx);\r\nreturn(0);\r\n}\r\n}\r\nif (db->index[field] != NULL) lh_OPENSSL_STRING_free(db->index[field]);\r\ndb->index[field]=idx;\r\ndb->qual[field]=qual;\r\nreturn(1);\r\n}\r\nlong TXT_DB_write(BIO *out, TXT_DB *db)\r\n{\r\nlong i,j,n,nn,l,tot=0;\r\nchar *p,**pp,*f;\r\nBUF_MEM *buf=NULL;\r\nlong ret= -1;\r\nif ((buf=BUF_MEM_new()) == NULL)\r\ngoto err;\r\nn=sk_OPENSSL_PSTRING_num(db->data);\r\nnn=db->num_fields;\r\nfor (i=0; i<n; i++)\r\n{\r\npp=sk_OPENSSL_PSTRING_value(db->data,i);\r\nl=0;\r\nfor (j=0; j<nn; j++)\r\n{\r\nif (pp[j] != NULL)\r\nl+=strlen(pp[j]);\r\n}\r\nif (!BUF_MEM_grow_clean(buf,(int)(l*2+nn))) goto err;\r\np=buf->data;\r\nfor (j=0; j<nn; j++)\r\n{\r\nf=pp[j];\r\nif (f != NULL)\r\nfor (;;)\r\n{\r\nif (*f == '\0') break;\r\nif (*f == '\t') *(p++)='\\';\r\n*(p++)= *(f++);\r\n}\r\n*(p++)='\t';\r\n}\r\np[-1]='\n';\r\nj=p-buf->data;\r\nif (BIO_write(out,buf->data,(int)j) != j)\r\ngoto err;\r\ntot+=j;\r\n}\r\nret=tot;\r\nerr:\r\nif (buf != NULL) BUF_MEM_free(buf);\r\nreturn(ret);\r\n}\r\nint TXT_DB_insert(TXT_DB *db, OPENSSL_STRING *row)\r\n{\r\nint i;\r\nOPENSSL_STRING *r;\r\nfor (i=0; i<db->num_fields; i++)\r\n{\r\nif (db->index[i] != NULL)\r\n{\r\nif ((db->qual[i] != NULL) &&\r\n(db->qual[i](row) == 0)) continue;\r\nr=lh_OPENSSL_STRING_retrieve(db->index[i],row);\r\nif (r != NULL)\r\n{\r\ndb->error=DB_ERROR_INDEX_CLASH;\r\ndb->arg1=i;\r\ndb->arg_row=r;\r\ngoto err;\r\n}\r\n}\r\n}\r\nif (!sk_OPENSSL_PSTRING_push(db->data,row))\r\n{\r\ndb->error=DB_ERROR_MALLOC;\r\ngoto err;\r\n}\r\nfor (i=0; i<db->num_fields; i++)\r\n{\r\nif (db->index[i] != NULL)\r\n{\r\nif ((db->qual[i] != NULL) &&\r\n(db->qual[i](row) == 0)) continue;\r\n(void)lh_OPENSSL_STRING_insert(db->index[i],row);\r\n}\r\n}\r\nreturn(1);\r\nerr:\r\nreturn(0);\r\n}\r\nvoid TXT_DB_free(TXT_DB *db)\r\n{\r\nint i,n;\r\nchar **p,*max;\r\nif(db == NULL)\r\nreturn;\r\nif (db->index != NULL)\r\n{\r\nfor (i=db->num_fields-1; i>=0; i--)\r\nif (db->index[i] != NULL) lh_OPENSSL_STRING_free(db->index[i]);\r\nOPENSSL_free(db->index);\r\n}\r\nif (db->qual != NULL)\r\nOPENSSL_free(db->qual);\r\nif (db->data != NULL)\r\n{\r\nfor (i=sk_OPENSSL_PSTRING_num(db->data)-1; i>=0; i--)\r\n{\r\np=sk_OPENSSL_PSTRING_value(db->data,i);\r\nmax=p[db->num_fields];\r\nif (max == NULL)\r\n{\r\nfor (n=0; n<db->num_fields; n++)\r\nif (p[n] != NULL) OPENSSL_free(p[n]);\r\n}\r\nelse\r\n{\r\nfor (n=0; n<db->num_fields; n++)\r\n{\r\nif (((p[n] < (char *)p) || (p[n] > max))\r\n&& (p[n] != NULL))\r\nOPENSSL_free(p[n]);\r\n}\r\n}\r\nOPENSSL_free(sk_OPENSSL_PSTRING_value(db->data,i));\r\n}\r\nsk_OPENSSL_PSTRING_free(db->data);\r\n}\r\nOPENSSL_free(db);\r\n}
