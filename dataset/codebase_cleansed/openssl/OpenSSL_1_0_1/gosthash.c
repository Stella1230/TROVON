static void swap_bytes (byte *w, byte *k)\r\n{\r\nint i,j;\r\nfor (i=0;i<4;i++)\r\nfor (j=0;j<8;j++)\r\nk[i+4*j]=w[8*i+j];\r\n}\r\nstatic void circle_xor8 (const byte *w, byte *k)\r\n{\r\nbyte buf[8];\r\nint i;\r\nmemcpy(buf,w,8);\r\nmemcpy(k,w+8,24);\r\nfor(i=0;i<8;i++)\r\nk[i+24]=buf[i]^k[i];\r\n}\r\nstatic void transform_3 (byte *data)\r\n{\r\nunsigned short int acc;\r\nacc=(data[0]^data[2]^data[4]^data[6]^data[24]^data[30])|\r\n((data[1]^data[3]^data[5]^data[7]^data[25]^data[31])<<8);\r\nmemmove(data,data+2,30);\r\ndata[30]=acc&0xff;\r\ndata[31]=acc>>8;\r\n}\r\nstatic int add_blocks(int n,byte *left, const byte *right)\r\n{\r\nint i;\r\nint carry=0;\r\nint sum;\r\nfor (i=0;i<n;i++)\r\n{\r\nsum=(int)left[i]+(int)right[i]+carry;\r\nleft[i]=sum & 0xff;\r\ncarry=sum>>8;\r\n}\r\nreturn carry;\r\n}\r\nstatic void xor_blocks (byte *result,const byte *a,const byte *b,size_t len)\r\n{\r\nsize_t i;\r\nfor (i=0;i<len;i++) result[i]=a[i]^b[i];\r\n}\r\nstatic int hash_step(gost_ctx *c,byte *H,const byte *M)\r\n{\r\nbyte U[32],W[32],V[32],S[32],Key[32];\r\nint i;\r\nxor_blocks(W,H,M,32);\r\nswap_bytes(W,Key);\r\ngost_enc_with_key(c,Key,H,S);\r\ncircle_xor8(H,U);\r\ncircle_xor8(M,V);\r\ncircle_xor8(V,V);\r\nxor_blocks(W,U,V,32);\r\nswap_bytes(W,Key);\r\ngost_enc_with_key(c,Key,H+8,S+8);\r\ncircle_xor8(U,U);\r\nU[31]=~U[31]; U[29]=~U[29]; U[28]=~U[28]; U[24]=~U[24];\r\nU[23]=~U[23]; U[20]=~U[20]; U[18]=~U[18]; U[17]=~U[17];\r\nU[14]=~U[14]; U[12]=~U[12]; U[10]=~U[10]; U[ 8]=~U[ 8];\r\nU[ 7]=~U[ 7]; U[ 5]=~U[ 5]; U[ 3]=~U[ 3]; U[ 1]=~U[ 1];\r\ncircle_xor8(V,V);\r\ncircle_xor8(V,V);\r\nxor_blocks(W,U,V,32);\r\nswap_bytes(W,Key);\r\ngost_enc_with_key(c,Key,H+16,S+16);\r\ncircle_xor8(U,U);\r\ncircle_xor8(V,V);\r\ncircle_xor8(V,V);\r\nxor_blocks(W,U,V,32);\r\nswap_bytes(W,Key);\r\ngost_enc_with_key(c,Key,H+24,S+24);\r\nfor (i=0;i<12;i++)\r\ntransform_3(S);\r\nxor_blocks(S,S,M,32);\r\ntransform_3(S);\r\nxor_blocks(S,S,H,32);\r\nfor (i=0;i<61;i++)\r\ntransform_3(S);\r\nmemcpy(H,S,32);\r\nreturn 1;\r\n}\r\nint init_gost_hash_ctx(gost_hash_ctx *ctx, const gost_subst_block *subst_block)\r\n{\r\nmemset(ctx,0,sizeof(gost_hash_ctx));\r\nctx->cipher_ctx = (gost_ctx *)MYALLOC(sizeof(gost_ctx));\r\nif (!ctx->cipher_ctx)\r\n{\r\nreturn 0;\r\n}\r\ngost_init(ctx->cipher_ctx,subst_block);\r\nreturn 1;\r\n}\r\nvoid done_gost_hash_ctx(gost_hash_ctx *ctx)\r\n{\r\nMYFREE(ctx->cipher_ctx);\r\n}\r\nint start_hash(gost_hash_ctx *ctx)\r\n{\r\nif (!ctx->cipher_ctx) return 0;\r\nmemset(&(ctx->H),0,32);\r\nmemset(&(ctx->S),0,32);\r\nctx->len = 0L;\r\nctx->left=0;\r\nreturn 1;\r\n}\r\nint hash_block(gost_hash_ctx *ctx,const byte *block, size_t length)\r\n{\r\nconst byte *curptr=block;\r\nconst byte *barrier=block+(length-32);\r\nif (ctx->left)\r\n{\r\nunsigned int add_bytes = 32-ctx->left;\r\nif (add_bytes>length)\r\n{\r\nadd_bytes = length;\r\n}\r\nmemcpy(&(ctx->remainder[ctx->left]),block,add_bytes);\r\nctx->left+=add_bytes;\r\nif (ctx->left<32)\r\n{\r\nreturn 1;\r\n}\r\ncurptr=block+add_bytes;\r\nhash_step(ctx->cipher_ctx,ctx->H,ctx->remainder);\r\nadd_blocks(32,ctx->S,ctx->remainder);\r\nctx->len+=32;\r\nctx->left=0;\r\n}\r\nwhile (curptr<=barrier)\r\n{\r\nhash_step(ctx->cipher_ctx,ctx->H,curptr);\r\nadd_blocks(32,ctx->S,curptr);\r\nctx->len+=32;\r\ncurptr+=32;\r\n}\r\nif (curptr!=block+length)\r\n{\r\nctx->left=block+length-curptr;\r\nmemcpy(ctx->remainder,curptr,ctx->left);\r\n}\r\nreturn 1;\r\n}\r\nint finish_hash(gost_hash_ctx *ctx,byte *hashval)\r\n{\r\nbyte buf[32];\r\nbyte H[32];\r\nbyte S[32];\r\nghosthash_len fin_len=ctx->len;\r\nbyte *bptr;\r\nmemcpy(H,ctx->H,32);\r\nmemcpy(S,ctx->S,32);\r\nif (ctx->left)\r\n{\r\nmemset(buf,0,32);\r\nmemcpy(buf,ctx->remainder,ctx->left);\r\nhash_step(ctx->cipher_ctx,H,buf);\r\nadd_blocks(32,S,buf);\r\nfin_len+=ctx->left;\r\n}\r\nmemset(buf,0,32);\r\nbptr=buf;\r\nfin_len<<=3;\r\nwhile(fin_len>0)\r\n{\r\n*(bptr++)=(byte)(fin_len&0xFF);\r\nfin_len>>=8;\r\n};\r\nhash_step(ctx->cipher_ctx,H,buf);\r\nhash_step(ctx->cipher_ctx,H,S);\r\nmemcpy(hashval,H,32);\r\nreturn 1;\r\n}
