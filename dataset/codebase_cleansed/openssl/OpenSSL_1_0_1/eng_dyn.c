static void int_free_str(char *s) { OPENSSL_free(s); }\r\nstatic void dynamic_data_ctx_free_func(void *parent, void *ptr,\r\nCRYPTO_EX_DATA *ad, int idx, long argl, void *argp)\r\n{\r\nif(ptr)\r\n{\r\ndynamic_data_ctx *ctx = (dynamic_data_ctx *)ptr;\r\nif(ctx->dynamic_dso)\r\nDSO_free(ctx->dynamic_dso);\r\nif(ctx->DYNAMIC_LIBNAME)\r\nOPENSSL_free((void*)ctx->DYNAMIC_LIBNAME);\r\nif(ctx->engine_id)\r\nOPENSSL_free((void*)ctx->engine_id);\r\nif(ctx->dirs)\r\nsk_OPENSSL_STRING_pop_free(ctx->dirs, int_free_str);\r\nOPENSSL_free(ctx);\r\n}\r\n}\r\nstatic int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx)\r\n{\r\ndynamic_data_ctx *c;\r\nc = OPENSSL_malloc(sizeof(dynamic_data_ctx));\r\nif(!c)\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nmemset(c, 0, sizeof(dynamic_data_ctx));\r\nc->dynamic_dso = NULL;\r\nc->v_check = NULL;\r\nc->bind_engine = NULL;\r\nc->DYNAMIC_LIBNAME = NULL;\r\nc->no_vcheck = 0;\r\nc->engine_id = NULL;\r\nc->list_add_value = 0;\r\nc->DYNAMIC_F1 = "v_check";\r\nc->DYNAMIC_F2 = "bind_engine";\r\nc->dir_load = 1;\r\nc->dirs = sk_OPENSSL_STRING_new_null();\r\nif(!c->dirs)\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX,ERR_R_MALLOC_FAILURE);\r\nOPENSSL_free(c);\r\nreturn 0;\r\n}\r\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\r\nif((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e,\r\ndynamic_ex_data_idx)) == NULL)\r\n{\r\nENGINE_set_ex_data(e, dynamic_ex_data_idx, c);\r\n*ctx = c;\r\nc = NULL;\r\n}\r\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\r\nif(c)\r\nOPENSSL_free(c);\r\nreturn 1;\r\n}\r\nstatic dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e)\r\n{\r\ndynamic_data_ctx *ctx;\r\nif(dynamic_ex_data_idx < 0)\r\n{\r\nint new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL,\r\ndynamic_data_ctx_free_func);\r\nif(new_idx == -1)\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX,ENGINE_R_NO_INDEX);\r\nreturn NULL;\r\n}\r\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\r\nif(dynamic_ex_data_idx < 0)\r\n{\r\ndynamic_ex_data_idx = new_idx;\r\nnew_idx = -1;\r\n}\r\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\r\n}\r\nctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx);\r\nif((ctx == NULL) && !dynamic_set_data_ctx(e, &ctx))\r\nreturn NULL;\r\nreturn ctx;\r\n}\r\nstatic ENGINE *engine_dynamic(void)\r\n{\r\nENGINE *ret = ENGINE_new();\r\nif(!ret)\r\nreturn NULL;\r\nif(!ENGINE_set_id(ret, engine_dynamic_id) ||\r\n!ENGINE_set_name(ret, engine_dynamic_name) ||\r\n!ENGINE_set_init_function(ret, dynamic_init) ||\r\n!ENGINE_set_finish_function(ret, dynamic_finish) ||\r\n!ENGINE_set_ctrl_function(ret, dynamic_ctrl) ||\r\n!ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) ||\r\n!ENGINE_set_cmd_defns(ret, dynamic_cmd_defns))\r\n{\r\nENGINE_free(ret);\r\nreturn NULL;\r\n}\r\nreturn ret;\r\n}\r\nvoid ENGINE_load_dynamic(void)\r\n{\r\nENGINE *toadd = engine_dynamic();\r\nif(!toadd) return;\r\nENGINE_add(toadd);\r\nENGINE_free(toadd);\r\nERR_clear_error();\r\n}\r\nstatic int dynamic_init(ENGINE *e)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dynamic_finish(ENGINE *e)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\r\n{\r\ndynamic_data_ctx *ctx = dynamic_get_data_ctx(e);\r\nint initialised;\r\nif(!ctx)\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,ENGINE_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\ninitialised = ((ctx->dynamic_dso == NULL) ? 0 : 1);\r\nif(initialised)\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\r\nENGINE_R_ALREADY_LOADED);\r\nreturn 0;\r\n}\r\nswitch(cmd)\r\n{\r\ncase DYNAMIC_CMD_SO_PATH:\r\nif(p && (strlen((const char *)p) < 1))\r\np = NULL;\r\nif(ctx->DYNAMIC_LIBNAME)\r\nOPENSSL_free((void*)ctx->DYNAMIC_LIBNAME);\r\nif(p)\r\nctx->DYNAMIC_LIBNAME = BUF_strdup(p);\r\nelse\r\nctx->DYNAMIC_LIBNAME = NULL;\r\nreturn (ctx->DYNAMIC_LIBNAME ? 1 : 0);\r\ncase DYNAMIC_CMD_NO_VCHECK:\r\nctx->no_vcheck = ((i == 0) ? 0 : 1);\r\nreturn 1;\r\ncase DYNAMIC_CMD_ID:\r\nif(p && (strlen((const char *)p) < 1))\r\np = NULL;\r\nif(ctx->engine_id)\r\nOPENSSL_free((void*)ctx->engine_id);\r\nif(p)\r\nctx->engine_id = BUF_strdup(p);\r\nelse\r\nctx->engine_id = NULL;\r\nreturn (ctx->engine_id ? 1 : 0);\r\ncase DYNAMIC_CMD_LIST_ADD:\r\nif((i < 0) || (i > 2))\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\r\nENGINE_R_INVALID_ARGUMENT);\r\nreturn 0;\r\n}\r\nctx->list_add_value = (int)i;\r\nreturn 1;\r\ncase DYNAMIC_CMD_LOAD:\r\nreturn dynamic_load(e, ctx);\r\ncase DYNAMIC_CMD_DIR_LOAD:\r\nif((i < 0) || (i > 2))\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\r\nENGINE_R_INVALID_ARGUMENT);\r\nreturn 0;\r\n}\r\nctx->dir_load = (int)i;\r\nreturn 1;\r\ncase DYNAMIC_CMD_DIR_ADD:\r\nif(!p || (strlen((const char *)p) < 1))\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\r\nENGINE_R_INVALID_ARGUMENT);\r\nreturn 0;\r\n}\r\n{\r\nchar *tmp_str = BUF_strdup(p);\r\nif(!tmp_str)\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,\r\nERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nsk_OPENSSL_STRING_insert(ctx->dirs, tmp_str, -1);\r\n}\r\nreturn 1;\r\ndefault:\r\nbreak;\r\n}\r\nENGINEerr(ENGINE_F_DYNAMIC_CTRL,ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);\r\nreturn 0;\r\n}\r\nstatic int int_load(dynamic_data_ctx *ctx)\r\n{\r\nint num, loop;\r\nif((ctx->dir_load != 2) && (DSO_load(ctx->dynamic_dso,\r\nctx->DYNAMIC_LIBNAME, NULL, 0)) != NULL)\r\nreturn 1;\r\nif(!ctx->dir_load || (num = sk_OPENSSL_STRING_num(ctx->dirs)) < 1)\r\nreturn 0;\r\nfor(loop = 0; loop < num; loop++)\r\n{\r\nconst char *s = sk_OPENSSL_STRING_value(ctx->dirs, loop);\r\nchar *merge = DSO_merge(ctx->dynamic_dso, ctx->DYNAMIC_LIBNAME, s);\r\nif(!merge)\r\nreturn 0;\r\nif(DSO_load(ctx->dynamic_dso, merge, NULL, 0))\r\n{\r\nOPENSSL_free(merge);\r\nreturn 1;\r\n}\r\nOPENSSL_free(merge);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)\r\n{\r\nENGINE cpy;\r\ndynamic_fns fns;\r\nif(!ctx->dynamic_dso)\r\nctx->dynamic_dso = DSO_new();\r\nif(!ctx->DYNAMIC_LIBNAME)\r\n{\r\nif(!ctx->engine_id)\r\nreturn 0;\r\nctx->DYNAMIC_LIBNAME =\r\nDSO_convert_filename(ctx->dynamic_dso, ctx->engine_id);\r\n}\r\nif(!int_load(ctx))\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\r\nENGINE_R_DSO_NOT_FOUND);\r\nDSO_free(ctx->dynamic_dso);\r\nctx->dynamic_dso = NULL;\r\nreturn 0;\r\n}\r\nif(!(ctx->bind_engine = (dynamic_bind_engine)DSO_bind_func(\r\nctx->dynamic_dso, ctx->DYNAMIC_F2)))\r\n{\r\nctx->bind_engine = NULL;\r\nDSO_free(ctx->dynamic_dso);\r\nctx->dynamic_dso = NULL;\r\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\r\nENGINE_R_DSO_FAILURE);\r\nreturn 0;\r\n}\r\nif(!ctx->no_vcheck)\r\n{\r\nunsigned long vcheck_res = 0;\r\nctx->v_check = (dynamic_v_check_fn)DSO_bind_func(\r\nctx->dynamic_dso, ctx->DYNAMIC_F1);\r\nif(ctx->v_check)\r\nvcheck_res = ctx->v_check(OSSL_DYNAMIC_VERSION);\r\nif(vcheck_res < OSSL_DYNAMIC_OLDEST)\r\n{\r\nctx->bind_engine = NULL;\r\nctx->v_check = NULL;\r\nDSO_free(ctx->dynamic_dso);\r\nctx->dynamic_dso = NULL;\r\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\r\nENGINE_R_VERSION_INCOMPATIBILITY);\r\nreturn 0;\r\n}\r\n}\r\nmemcpy(&cpy, e, sizeof(ENGINE));\r\nfns.static_state = ENGINE_get_static_state();\r\nfns.err_fns = ERR_get_implementation();\r\nfns.ex_data_fns = CRYPTO_get_ex_data_implementation();\r\nCRYPTO_get_mem_functions(&fns.mem_fns.malloc_cb,\r\n&fns.mem_fns.realloc_cb,\r\n&fns.mem_fns.free_cb);\r\nfns.lock_fns.lock_locking_cb = CRYPTO_get_locking_callback();\r\nfns.lock_fns.lock_add_lock_cb = CRYPTO_get_add_lock_callback();\r\nfns.lock_fns.dynlock_create_cb = CRYPTO_get_dynlock_create_callback();\r\nfns.lock_fns.dynlock_lock_cb = CRYPTO_get_dynlock_lock_callback();\r\nfns.lock_fns.dynlock_destroy_cb = CRYPTO_get_dynlock_destroy_callback();\r\nengine_set_all_null(e);\r\nif(!ctx->bind_engine(e, ctx->engine_id, &fns))\r\n{\r\nctx->bind_engine = NULL;\r\nctx->v_check = NULL;\r\nDSO_free(ctx->dynamic_dso);\r\nctx->dynamic_dso = NULL;\r\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,ENGINE_R_INIT_FAILED);\r\nmemcpy(e, &cpy, sizeof(ENGINE));\r\nreturn 0;\r\n}\r\nif(ctx->list_add_value > 0)\r\n{\r\nif(!ENGINE_add(e))\r\n{\r\nif(ctx->list_add_value > 1)\r\n{\r\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\r\nENGINE_R_CONFLICTING_ENGINE_ID);\r\nreturn 0;\r\n}\r\nERR_clear_error();\r\n}\r\n}\r\nreturn 1;\r\n}
