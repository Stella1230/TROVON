static int sn_cmp(const ASN1_OBJECT * const *a, const unsigned int *b)\r\n{ return(strcmp((*a)->sn,nid_objs[*b].sn)); }\r\nstatic int ln_cmp(const ASN1_OBJECT * const *a, const unsigned int *b)\r\n{ return(strcmp((*a)->ln,nid_objs[*b].ln)); }\r\nstatic unsigned long added_obj_hash(const ADDED_OBJ *ca)\r\n{\r\nconst ASN1_OBJECT *a;\r\nint i;\r\nunsigned long ret=0;\r\nunsigned char *p;\r\na=ca->obj;\r\nswitch (ca->type)\r\n{\r\ncase ADDED_DATA:\r\nret=a->length<<20L;\r\np=(unsigned char *)a->data;\r\nfor (i=0; i<a->length; i++)\r\nret^=p[i]<<((i*3)%24);\r\nbreak;\r\ncase ADDED_SNAME:\r\nret=lh_strhash(a->sn);\r\nbreak;\r\ncase ADDED_LNAME:\r\nret=lh_strhash(a->ln);\r\nbreak;\r\ncase ADDED_NID:\r\nret=a->nid;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nret&=0x3fffffffL;\r\nret|=ca->type<<30L;\r\nreturn(ret);\r\n}\r\nstatic int init_added(void)\r\n{\r\nif (added != NULL) return(1);\r\nadded=lh_ADDED_OBJ_new();\r\nreturn(added != NULL);\r\n}\r\nstatic void cleanup1_doall(ADDED_OBJ *a)\r\n{\r\na->obj->nid=0;\r\na->obj->flags|=ASN1_OBJECT_FLAG_DYNAMIC|\r\nASN1_OBJECT_FLAG_DYNAMIC_STRINGS|\r\nASN1_OBJECT_FLAG_DYNAMIC_DATA;\r\n}\r\nstatic void cleanup2_doall(ADDED_OBJ *a)\r\n{ a->obj->nid++; }\r\nstatic void cleanup3_doall(ADDED_OBJ *a)\r\n{\r\nif (--a->obj->nid == 0)\r\nASN1_OBJECT_free(a->obj);\r\nOPENSSL_free(a);\r\n}\r\nvoid check_defer(int nid)\r\n{\r\nif (!obj_cleanup_defer && nid >= NUM_NID)\r\nobj_cleanup_defer = 1;\r\n}\r\nvoid OBJ_cleanup(void)\r\n{\r\nif (obj_cleanup_defer)\r\n{\r\nobj_cleanup_defer = 2;\r\nreturn ;\r\n}\r\nif (added == NULL) return;\r\nlh_ADDED_OBJ_down_load(added) = 0;\r\nlh_ADDED_OBJ_doall(added,LHASH_DOALL_FN(cleanup1));\r\nlh_ADDED_OBJ_doall(added,LHASH_DOALL_FN(cleanup2));\r\nlh_ADDED_OBJ_doall(added,LHASH_DOALL_FN(cleanup3));\r\nlh_ADDED_OBJ_free(added);\r\nadded=NULL;\r\n}\r\nint OBJ_new_nid(int num)\r\n{\r\nint i;\r\ni=new_nid;\r\nnew_nid+=num;\r\nreturn(i);\r\n}\r\nint OBJ_add_object(const ASN1_OBJECT *obj)\r\n{\r\nASN1_OBJECT *o;\r\nADDED_OBJ *ao[4]={NULL,NULL,NULL,NULL},*aop;\r\nint i;\r\nif (added == NULL)\r\nif (!init_added()) return(0);\r\nif ((o=OBJ_dup(obj)) == NULL) goto err;\r\nif (!(ao[ADDED_NID]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\r\nif ((o->length != 0) && (obj->data != NULL))\r\nif (!(ao[ADDED_DATA]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\r\nif (o->sn != NULL)\r\nif (!(ao[ADDED_SNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\r\nif (o->ln != NULL)\r\nif (!(ao[ADDED_LNAME]=(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ)))) goto err2;\r\nfor (i=ADDED_DATA; i<=ADDED_NID; i++)\r\n{\r\nif (ao[i] != NULL)\r\n{\r\nao[i]->type=i;\r\nao[i]->obj=o;\r\naop=lh_ADDED_OBJ_insert(added,ao[i]);\r\nif (aop != NULL)\r\nOPENSSL_free(aop);\r\n}\r\n}\r\no->flags&= ~(ASN1_OBJECT_FLAG_DYNAMIC|ASN1_OBJECT_FLAG_DYNAMIC_STRINGS|\r\nASN1_OBJECT_FLAG_DYNAMIC_DATA);\r\nreturn(o->nid);\r\nerr2:\r\nOBJerr(OBJ_F_OBJ_ADD_OBJECT,ERR_R_MALLOC_FAILURE);\r\nerr:\r\nfor (i=ADDED_DATA; i<=ADDED_NID; i++)\r\nif (ao[i] != NULL) OPENSSL_free(ao[i]);\r\nif (o != NULL) OPENSSL_free(o);\r\nreturn(NID_undef);\r\n}\r\nASN1_OBJECT *OBJ_nid2obj(int n)\r\n{\r\nADDED_OBJ ad,*adp;\r\nASN1_OBJECT ob;\r\nif ((n >= 0) && (n < NUM_NID))\r\n{\r\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\r\n{\r\nOBJerr(OBJ_F_OBJ_NID2OBJ,OBJ_R_UNKNOWN_NID);\r\nreturn(NULL);\r\n}\r\nreturn((ASN1_OBJECT *)&(nid_objs[n]));\r\n}\r\nelse if (added == NULL)\r\nreturn(NULL);\r\nelse\r\n{\r\nad.type=ADDED_NID;\r\nad.obj= &ob;\r\nob.nid=n;\r\nadp=lh_ADDED_OBJ_retrieve(added,&ad);\r\nif (adp != NULL)\r\nreturn(adp->obj);\r\nelse\r\n{\r\nOBJerr(OBJ_F_OBJ_NID2OBJ,OBJ_R_UNKNOWN_NID);\r\nreturn(NULL);\r\n}\r\n}\r\n}\r\nconst char *OBJ_nid2sn(int n)\r\n{\r\nADDED_OBJ ad,*adp;\r\nASN1_OBJECT ob;\r\nif ((n >= 0) && (n < NUM_NID))\r\n{\r\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\r\n{\r\nOBJerr(OBJ_F_OBJ_NID2SN,OBJ_R_UNKNOWN_NID);\r\nreturn(NULL);\r\n}\r\nreturn(nid_objs[n].sn);\r\n}\r\nelse if (added == NULL)\r\nreturn(NULL);\r\nelse\r\n{\r\nad.type=ADDED_NID;\r\nad.obj= &ob;\r\nob.nid=n;\r\nadp=lh_ADDED_OBJ_retrieve(added,&ad);\r\nif (adp != NULL)\r\nreturn(adp->obj->sn);\r\nelse\r\n{\r\nOBJerr(OBJ_F_OBJ_NID2SN,OBJ_R_UNKNOWN_NID);\r\nreturn(NULL);\r\n}\r\n}\r\n}\r\nconst char *OBJ_nid2ln(int n)\r\n{\r\nADDED_OBJ ad,*adp;\r\nASN1_OBJECT ob;\r\nif ((n >= 0) && (n < NUM_NID))\r\n{\r\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef))\r\n{\r\nOBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);\r\nreturn(NULL);\r\n}\r\nreturn(nid_objs[n].ln);\r\n}\r\nelse if (added == NULL)\r\nreturn(NULL);\r\nelse\r\n{\r\nad.type=ADDED_NID;\r\nad.obj= &ob;\r\nob.nid=n;\r\nadp=lh_ADDED_OBJ_retrieve(added,&ad);\r\nif (adp != NULL)\r\nreturn(adp->obj->ln);\r\nelse\r\n{\r\nOBJerr(OBJ_F_OBJ_NID2LN,OBJ_R_UNKNOWN_NID);\r\nreturn(NULL);\r\n}\r\n}\r\n}\r\nstatic int obj_cmp(const ASN1_OBJECT * const *ap, const unsigned int *bp)\r\n{\r\nint j;\r\nconst ASN1_OBJECT *a= *ap;\r\nconst ASN1_OBJECT *b= &nid_objs[*bp];\r\nj=(a->length - b->length);\r\nif (j) return(j);\r\nreturn(memcmp(a->data,b->data,a->length));\r\n}\r\nint OBJ_obj2nid(const ASN1_OBJECT *a)\r\n{\r\nconst unsigned int *op;\r\nADDED_OBJ ad,*adp;\r\nif (a == NULL)\r\nreturn(NID_undef);\r\nif (a->nid != 0)\r\nreturn(a->nid);\r\nif (added != NULL)\r\n{\r\nad.type=ADDED_DATA;\r\nad.obj=(ASN1_OBJECT *)a;\r\nadp=lh_ADDED_OBJ_retrieve(added,&ad);\r\nif (adp != NULL) return (adp->obj->nid);\r\n}\r\nop=OBJ_bsearch_obj(&a, obj_objs, NUM_OBJ);\r\nif (op == NULL)\r\nreturn(NID_undef);\r\nreturn(nid_objs[*op].nid);\r\n}\r\nASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)\r\n{\r\nint nid = NID_undef;\r\nASN1_OBJECT *op=NULL;\r\nunsigned char *buf;\r\nunsigned char *p;\r\nconst unsigned char *cp;\r\nint i, j;\r\nif(!no_name) {\r\nif( ((nid = OBJ_sn2nid(s)) != NID_undef) ||\r\n((nid = OBJ_ln2nid(s)) != NID_undef) )\r\nreturn OBJ_nid2obj(nid);\r\n}\r\ni=a2d_ASN1_OBJECT(NULL,0,s,-1);\r\nif (i <= 0) {\r\nreturn NULL;\r\n}\r\nj = ASN1_object_size(0,i,V_ASN1_OBJECT);\r\nif((buf=(unsigned char *)OPENSSL_malloc(j)) == NULL) return NULL;\r\np = buf;\r\nASN1_put_object(&p,0,i,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);\r\na2d_ASN1_OBJECT(p,i,s,-1);\r\ncp=buf;\r\nop=d2i_ASN1_OBJECT(NULL,&cp,j);\r\nOPENSSL_free(buf);\r\nreturn op;\r\n}\r\nint OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\r\n{\r\nint i,n=0,len,nid, first, use_bn;\r\nBIGNUM *bl;\r\nunsigned long l;\r\nconst unsigned char *p;\r\nchar tbuf[DECIMAL_SIZE(i)+DECIMAL_SIZE(l)+2];\r\nif ((a == NULL) || (a->data == NULL)) {\r\nbuf[0]='\0';\r\nreturn(0);\r\n}\r\nif (!no_name && (nid=OBJ_obj2nid(a)) != NID_undef)\r\n{\r\nconst char *s;\r\ns=OBJ_nid2ln(nid);\r\nif (s == NULL)\r\ns=OBJ_nid2sn(nid);\r\nif (s)\r\n{\r\nif (buf)\r\nBUF_strlcpy(buf,s,buf_len);\r\nn=strlen(s);\r\nreturn n;\r\n}\r\n}\r\nlen=a->length;\r\np=a->data;\r\nfirst = 1;\r\nbl = NULL;\r\nwhile (len > 0)\r\n{\r\nl=0;\r\nuse_bn = 0;\r\nfor (;;)\r\n{\r\nunsigned char c = *p++;\r\nlen--;\r\nif ((len == 0) && (c & 0x80))\r\ngoto err;\r\nif (use_bn)\r\n{\r\nif (!BN_add_word(bl, c & 0x7f))\r\ngoto err;\r\n}\r\nelse\r\nl |= c & 0x7f;\r\nif (!(c & 0x80))\r\nbreak;\r\nif (!use_bn && (l > (ULONG_MAX >> 7L)))\r\n{\r\nif (!bl && !(bl = BN_new()))\r\ngoto err;\r\nif (!BN_set_word(bl, l))\r\ngoto err;\r\nuse_bn = 1;\r\n}\r\nif (use_bn)\r\n{\r\nif (!BN_lshift(bl, bl, 7))\r\ngoto err;\r\n}\r\nelse\r\nl<<=7L;\r\n}\r\nif (first)\r\n{\r\nfirst = 0;\r\nif (l >= 80)\r\n{\r\ni = 2;\r\nif (use_bn)\r\n{\r\nif (!BN_sub_word(bl, 80))\r\ngoto err;\r\n}\r\nelse\r\nl -= 80;\r\n}\r\nelse\r\n{\r\ni=(int)(l/40);\r\nl-=(long)(i*40);\r\n}\r\nif (buf && (buf_len > 0))\r\n{\r\n*buf++ = i + '0';\r\nbuf_len--;\r\n}\r\nn++;\r\n}\r\nif (use_bn)\r\n{\r\nchar *bndec;\r\nbndec = BN_bn2dec(bl);\r\nif (!bndec)\r\ngoto err;\r\ni = strlen(bndec);\r\nif (buf)\r\n{\r\nif (buf_len > 0)\r\n{\r\n*buf++ = '.';\r\nbuf_len--;\r\n}\r\nBUF_strlcpy(buf,bndec,buf_len);\r\nif (i > buf_len)\r\n{\r\nbuf += buf_len;\r\nbuf_len = 0;\r\n}\r\nelse\r\n{\r\nbuf+=i;\r\nbuf_len-=i;\r\n}\r\n}\r\nn++;\r\nn += i;\r\nOPENSSL_free(bndec);\r\n}\r\nelse\r\n{\r\nBIO_snprintf(tbuf,sizeof tbuf,".%lu",l);\r\ni=strlen(tbuf);\r\nif (buf && (buf_len > 0))\r\n{\r\nBUF_strlcpy(buf,tbuf,buf_len);\r\nif (i > buf_len)\r\n{\r\nbuf += buf_len;\r\nbuf_len = 0;\r\n}\r\nelse\r\n{\r\nbuf+=i;\r\nbuf_len-=i;\r\n}\r\n}\r\nn+=i;\r\nl=0;\r\n}\r\n}\r\nif (bl)\r\nBN_free(bl);\r\nreturn n;\r\nerr:\r\nif (bl)\r\nBN_free(bl);\r\nreturn -1;\r\n}\r\nint OBJ_txt2nid(const char *s)\r\n{\r\nASN1_OBJECT *obj;\r\nint nid;\r\nobj = OBJ_txt2obj(s, 0);\r\nnid = OBJ_obj2nid(obj);\r\nASN1_OBJECT_free(obj);\r\nreturn nid;\r\n}\r\nint OBJ_ln2nid(const char *s)\r\n{\r\nASN1_OBJECT o;\r\nconst ASN1_OBJECT *oo= &o;\r\nADDED_OBJ ad,*adp;\r\nconst unsigned int *op;\r\no.ln=s;\r\nif (added != NULL)\r\n{\r\nad.type=ADDED_LNAME;\r\nad.obj= &o;\r\nadp=lh_ADDED_OBJ_retrieve(added,&ad);\r\nif (adp != NULL) return (adp->obj->nid);\r\n}\r\nop=OBJ_bsearch_ln(&oo, ln_objs, NUM_LN);\r\nif (op == NULL) return(NID_undef);\r\nreturn(nid_objs[*op].nid);\r\n}\r\nint OBJ_sn2nid(const char *s)\r\n{\r\nASN1_OBJECT o;\r\nconst ASN1_OBJECT *oo= &o;\r\nADDED_OBJ ad,*adp;\r\nconst unsigned int *op;\r\no.sn=s;\r\nif (added != NULL)\r\n{\r\nad.type=ADDED_SNAME;\r\nad.obj= &o;\r\nadp=lh_ADDED_OBJ_retrieve(added,&ad);\r\nif (adp != NULL) return (adp->obj->nid);\r\n}\r\nop=OBJ_bsearch_sn(&oo, sn_objs, NUM_SN);\r\nif (op == NULL) return(NID_undef);\r\nreturn(nid_objs[*op].nid);\r\n}\r\nconst void *OBJ_bsearch_(const void *key, const void *base, int num, int size,\r\nint (*cmp)(const void *, const void *))\r\n{\r\nreturn OBJ_bsearch_ex_(key, base, num, size, cmp, 0);\r\n}\r\nconst void *OBJ_bsearch_ex_(const void *key, const void *base_, int num,\r\nint size,\r\nint (*cmp)(const void *, const void *),\r\nint flags)\r\n{\r\nconst char *base=base_;\r\nint l,h,i=0,c=0;\r\nconst char *p = NULL;\r\nif (num == 0) return(NULL);\r\nl=0;\r\nh=num;\r\nwhile (l < h)\r\n{\r\ni=(l+h)/2;\r\np= &(base[i*size]);\r\nc=(*cmp)(key,p);\r\nif (c < 0)\r\nh=i;\r\nelse if (c > 0)\r\nl=i+1;\r\nelse\r\nbreak;\r\n}\r\n#ifdef CHARSET_EBCDIC\r\nif (c != 0)\r\n{\r\nfor (i=0; i<num; ++i)\r\n{\r\np= &(base[i*size]);\r\nc = (*cmp)(key,p);\r\nif (c == 0 || (c < 0 && (flags & OBJ_BSEARCH_VALUE_ON_NOMATCH)))\r\nreturn p;\r\n}\r\n}\r\n#endif\r\nif (c != 0 && !(flags & OBJ_BSEARCH_VALUE_ON_NOMATCH))\r\np = NULL;\r\nelse if (c == 0 && (flags & OBJ_BSEARCH_FIRST_VALUE_ON_MATCH))\r\n{\r\nwhile(i > 0 && (*cmp)(key,&(base[(i-1)*size])) == 0)\r\ni--;\r\np = &(base[i*size]);\r\n}\r\nreturn(p);\r\n}\r\nint OBJ_create_objects(BIO *in)\r\n{\r\nMS_STATIC char buf[512];\r\nint i,num=0;\r\nchar *o,*s,*l=NULL;\r\nfor (;;)\r\n{\r\ns=o=NULL;\r\ni=BIO_gets(in,buf,512);\r\nif (i <= 0) return(num);\r\nbuf[i-1]='\0';\r\nif (!isalnum((unsigned char)buf[0])) return(num);\r\no=s=buf;\r\nwhile (isdigit((unsigned char)*s) || (*s == '.'))\r\ns++;\r\nif (*s != '\0')\r\n{\r\n*(s++)='\0';\r\nwhile (isspace((unsigned char)*s))\r\ns++;\r\nif (*s == '\0')\r\ns=NULL;\r\nelse\r\n{\r\nl=s;\r\nwhile ((*l != '\0') && !isspace((unsigned char)*l))\r\nl++;\r\nif (*l != '\0')\r\n{\r\n*(l++)='\0';\r\nwhile (isspace((unsigned char)*l))\r\nl++;\r\nif (*l == '\0') l=NULL;\r\n}\r\nelse\r\nl=NULL;\r\n}\r\n}\r\nelse\r\ns=NULL;\r\nif ((o == NULL) || (*o == '\0')) return(num);\r\nif (!OBJ_create(o,s,l)) return(num);\r\nnum++;\r\n}\r\n}\r\nint OBJ_create(const char *oid, const char *sn, const char *ln)\r\n{\r\nint ok=0;\r\nASN1_OBJECT *op=NULL;\r\nunsigned char *buf;\r\nint i;\r\ni=a2d_ASN1_OBJECT(NULL,0,oid,-1);\r\nif (i <= 0) return(0);\r\nif ((buf=(unsigned char *)OPENSSL_malloc(i)) == NULL)\r\n{\r\nOBJerr(OBJ_F_OBJ_CREATE,ERR_R_MALLOC_FAILURE);\r\nreturn(0);\r\n}\r\ni=a2d_ASN1_OBJECT(buf,i,oid,-1);\r\nif (i == 0)\r\ngoto err;\r\nop=(ASN1_OBJECT *)ASN1_OBJECT_create(OBJ_new_nid(1),buf,i,sn,ln);\r\nif (op == NULL)\r\ngoto err;\r\nok=OBJ_add_object(op);\r\nerr:\r\nASN1_OBJECT_free(op);\r\nOPENSSL_free(buf);\r\nreturn(ok);\r\n}
