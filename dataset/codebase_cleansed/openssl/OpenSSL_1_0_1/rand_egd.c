int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)\r\n{\r\nreturn(-1);\r\n}\r\nint RAND_egd(const char *path)\r\n{\r\nreturn(-1);\r\n}\r\nint RAND_egd_bytes(const char *path,int bytes)\r\n{\r\nreturn(-1);\r\n}\r\nint RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)\r\n{\r\nint ret = 0;\r\nstruct sockaddr_un addr;\r\nint len, num, numbytes;\r\nint fd = -1;\r\nint success;\r\nunsigned char egdbuf[2], tempbuf[255], *retrievebuf;\r\nmemset(&addr, 0, sizeof(addr));\r\naddr.sun_family = AF_UNIX;\r\nif (strlen(path) >= sizeof(addr.sun_path))\r\nreturn (-1);\r\nBUF_strlcpy(addr.sun_path,path,sizeof addr.sun_path);\r\nlen = offsetof(struct sockaddr_un, sun_path) + strlen(path);\r\nfd = socket(AF_UNIX, SOCK_STREAM, 0);\r\nif (fd == -1) return (-1);\r\nsuccess = 0;\r\nwhile (!success)\r\n{\r\nif (connect(fd, (struct sockaddr *)&addr, len) == 0)\r\nsuccess = 1;\r\nelse\r\n{\r\nswitch (errno)\r\n{\r\n#ifdef EINTR\r\ncase EINTR:\r\n#endif\r\n#ifdef EAGAIN\r\ncase EAGAIN:\r\n#endif\r\n#ifdef EINPROGRESS\r\ncase EINPROGRESS:\r\n#endif\r\n#ifdef EALREADY\r\ncase EALREADY:\r\n#endif\r\nbreak;\r\n#ifdef EISCONN\r\ncase EISCONN:\r\nsuccess = 1;\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto err;\r\n}\r\n}\r\n}\r\nwhile(bytes > 0)\r\n{\r\negdbuf[0] = 1;\r\negdbuf[1] = bytes < 255 ? bytes : 255;\r\nnumbytes = 0;\r\nwhile (numbytes != 2)\r\n{\r\nnum = write(fd, egdbuf + numbytes, 2 - numbytes);\r\nif (num >= 0)\r\nnumbytes += num;\r\nelse\r\n{\r\nswitch (errno)\r\n{\r\n#ifdef EINTR\r\ncase EINTR:\r\n#endif\r\n#ifdef EAGAIN\r\ncase EAGAIN:\r\n#endif\r\nbreak;\r\ndefault:\r\nret = -1;\r\ngoto err;\r\n}\r\n}\r\n}\r\nnumbytes = 0;\r\nwhile (numbytes != 1)\r\n{\r\nnum = read(fd, egdbuf, 1);\r\nif (num == 0)\r\ngoto err;\r\nelse if (num > 0)\r\nnumbytes += num;\r\nelse\r\n{\r\nswitch (errno)\r\n{\r\n#ifdef EINTR\r\ncase EINTR:\r\n#endif\r\n#ifdef EAGAIN\r\ncase EAGAIN:\r\n#endif\r\nbreak;\r\ndefault:\r\nret = -1;\r\ngoto err;\r\n}\r\n}\r\n}\r\nif(egdbuf[0] == 0)\r\ngoto err;\r\nif (buf)\r\nretrievebuf = buf + ret;\r\nelse\r\nretrievebuf = tempbuf;\r\nnumbytes = 0;\r\nwhile (numbytes != egdbuf[0])\r\n{\r\nnum = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes);\r\nif (num == 0)\r\ngoto err;\r\nelse if (num > 0)\r\nnumbytes += num;\r\nelse\r\n{\r\nswitch (errno)\r\n{\r\n#ifdef EINTR\r\ncase EINTR:\r\n#endif\r\n#ifdef EAGAIN\r\ncase EAGAIN:\r\n#endif\r\nbreak;\r\ndefault:\r\nret = -1;\r\ngoto err;\r\n}\r\n}\r\n}\r\nret += egdbuf[0];\r\nbytes -= egdbuf[0];\r\nif (!buf)\r\nRAND_seed(tempbuf, egdbuf[0]);\r\n}\r\nerr:\r\nif (fd != -1) close(fd);\r\nreturn(ret);\r\n}\r\nint RAND_egd_bytes(const char *path, int bytes)\r\n{\r\nint num, ret = 0;\r\nnum = RAND_query_egd_bytes(path, NULL, bytes);\r\nif (num < 1) goto err;\r\nif (RAND_status() == 1)\r\nret = num;\r\nerr:\r\nreturn(ret);\r\n}\r\nint RAND_egd(const char *path)\r\n{\r\nreturn (RAND_egd_bytes(path, 255));\r\n}
