static int obj_name_cmp(const void *a_void, const void *b_void)\r\n{\r\nint ret;\r\nconst OBJ_NAME *a = (const OBJ_NAME *)a_void;\r\nconst OBJ_NAME *b = (const OBJ_NAME *)b_void;\r\nret=a->type-b->type;\r\nif (ret == 0)\r\n{\r\nif ((name_funcs_stack != NULL)\r\n&& (sk_NAME_FUNCS_num(name_funcs_stack) > a->type))\r\n{\r\nret=sk_NAME_FUNCS_value(name_funcs_stack,\r\na->type)->cmp_func(a->name,b->name);\r\n}\r\nelse\r\nret=strcmp(a->name,b->name);\r\n}\r\nreturn(ret);\r\n}\r\nstatic unsigned long obj_name_hash(const void *a_void)\r\n{\r\nunsigned long ret;\r\nconst OBJ_NAME *a = (const OBJ_NAME *)a_void;\r\nif ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > a->type))\r\n{\r\nret=sk_NAME_FUNCS_value(name_funcs_stack,\r\na->type)->hash_func(a->name);\r\n}\r\nelse\r\n{\r\nret=lh_strhash(a->name);\r\n}\r\nret^=a->type;\r\nreturn(ret);\r\n}\r\nconst char *OBJ_NAME_get(const char *name, int type)\r\n{\r\nOBJ_NAME on,*ret;\r\nint num=0,alias;\r\nif (name == NULL) return(NULL);\r\nif ((names_lh == NULL) && !OBJ_NAME_init()) return(NULL);\r\nalias=type&OBJ_NAME_ALIAS;\r\ntype&= ~OBJ_NAME_ALIAS;\r\non.name=name;\r\non.type=type;\r\nfor (;;)\r\n{\r\nret=lh_OBJ_NAME_retrieve(names_lh,&on);\r\nif (ret == NULL) return(NULL);\r\nif ((ret->alias) && !alias)\r\n{\r\nif (++num > 10) return(NULL);\r\non.name=ret->data;\r\n}\r\nelse\r\n{\r\nreturn(ret->data);\r\n}\r\n}\r\n}\r\nint OBJ_NAME_add(const char *name, int type, const char *data)\r\n{\r\nOBJ_NAME *onp,*ret;\r\nint alias;\r\nif ((names_lh == NULL) && !OBJ_NAME_init()) return(0);\r\nalias=type&OBJ_NAME_ALIAS;\r\ntype&= ~OBJ_NAME_ALIAS;\r\nonp=(OBJ_NAME *)OPENSSL_malloc(sizeof(OBJ_NAME));\r\nif (onp == NULL)\r\n{\r\nreturn(0);\r\n}\r\nonp->name=name;\r\nonp->alias=alias;\r\nonp->type=type;\r\nonp->data=data;\r\nret=lh_OBJ_NAME_insert(names_lh,onp);\r\nif (ret != NULL)\r\n{\r\nif ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type))\r\n{\r\nsk_NAME_FUNCS_value(name_funcs_stack,\r\nret->type)->free_func(ret->name,ret->type,ret->data);\r\n}\r\nOPENSSL_free(ret);\r\n}\r\nelse\r\n{\r\nif (lh_OBJ_NAME_error(names_lh))\r\n{\r\nreturn(0);\r\n}\r\n}\r\nreturn(1);\r\n}\r\nint OBJ_NAME_remove(const char *name, int type)\r\n{\r\nOBJ_NAME on,*ret;\r\nif (names_lh == NULL) return(0);\r\ntype&= ~OBJ_NAME_ALIAS;\r\non.name=name;\r\non.type=type;\r\nret=lh_OBJ_NAME_delete(names_lh,&on);\r\nif (ret != NULL)\r\n{\r\nif ((name_funcs_stack != NULL) && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type))\r\n{\r\nsk_NAME_FUNCS_value(name_funcs_stack,\r\nret->type)->free_func(ret->name,ret->type,ret->data);\r\n}\r\nOPENSSL_free(ret);\r\nreturn(1);\r\n}\r\nelse\r\nreturn(0);\r\n}\r\nstatic void do_all_fn_doall_arg(const OBJ_NAME *name,struct doall *d)\r\n{\r\nif(name->type == d->type)\r\nd->fn(name,d->arg);\r\n}\r\nstatic void do_all_sorted_fn(const OBJ_NAME *name,void *d_)\r\n{\r\nstruct doall_sorted *d=d_;\r\nif(name->type != d->type)\r\nreturn;\r\nd->names[d->n++]=name;\r\n}\r\nstatic int do_all_sorted_cmp(const void *n1_,const void *n2_)\r\n{\r\nconst OBJ_NAME * const *n1=n1_;\r\nconst OBJ_NAME * const *n2=n2_;\r\nreturn strcmp((*n1)->name,(*n2)->name);\r\n}\r\nvoid OBJ_NAME_do_all_sorted(int type,void (*fn)(const OBJ_NAME *,void *arg),\r\nvoid *arg)\r\n{\r\nstruct doall_sorted d;\r\nint n;\r\nd.type=type;\r\nd.names=OPENSSL_malloc(lh_OBJ_NAME_num_items(names_lh)*sizeof *d.names);\r\nd.n=0;\r\nOBJ_NAME_do_all(type,do_all_sorted_fn,&d);\r\nqsort((void *)d.names,d.n,sizeof *d.names,do_all_sorted_cmp);\r\nfor(n=0 ; n < d.n ; ++n)\r\nfn(d.names[n],arg);\r\nOPENSSL_free((void *)d.names);\r\n}\r\nstatic void names_lh_free_doall(OBJ_NAME *onp)\r\n{\r\nif (onp == NULL)\r\nreturn;\r\nif (free_type < 0 || free_type == onp->type)\r\nOBJ_NAME_remove(onp->name,onp->type);\r\n}
