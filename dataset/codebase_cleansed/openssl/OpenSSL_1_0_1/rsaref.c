static int bind_rsaref(ENGINE *e)\r\n{\r\nconst RSA_METHOD *meth1;\r\nif(!ENGINE_set_id(e, engine_rsaref_id)\r\n|| !ENGINE_set_name(e, engine_rsaref_name)\r\n|| !ENGINE_set_RSA(e, &rsaref_rsa)\r\n|| !ENGINE_set_ciphers(e, rsaref_ciphers)\r\n|| !ENGINE_set_digests(e, rsaref_digests)\r\n|| !ENGINE_set_destroy_function(e, rsaref_destroy)\r\n|| !ENGINE_set_init_function(e, rsaref_init)\r\n|| !ENGINE_set_finish_function(e, rsaref_finish)\r\n)\r\nreturn 0;\r\nERR_load_RSAREF_strings();\r\nreturn 1;\r\n}\r\nstatic int bind_helper(ENGINE *e, const char *id)\r\n{\r\nif(id && (strcmp(id, engine_rsaref_id) != 0))\r\nreturn 0;\r\nif(!bind_rsaref(e))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic ENGINE *engine_rsaref(void)\r\n{\r\nENGINE *ret = ENGINE_new();\r\nif(!ret)\r\nreturn NULL;\r\nif(!bind_rsaref(ret))\r\n{\r\nENGINE_free(ret);\r\nreturn NULL;\r\n}\r\nreturn ret;\r\n}\r\nvoid ENGINE_load_rsaref(void)\r\n{\r\nENGINE *toadd = engine_rsaref();\r\nif(!toadd) return;\r\nENGINE_add(toadd);\r\nENGINE_free(toadd);\r\nERR_clear_error();\r\n}\r\nstatic int rsaref_init(ENGINE *e)\r\n{\r\nreturn 1;\r\n}\r\nstatic int rsaref_finish(ENGINE *e)\r\n{\r\nreturn 1;\r\n}\r\nstatic int rsaref_destroy(ENGINE *e)\r\n{\r\nERR_unload_RSAREF_strings();\r\nreturn 1;\r\n}\r\nstatic int rsaref_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)\r\n{\r\nRSAREFerr(RSAREF_F_RSAREF_MOD_EXP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\r\nreturn(0);\r\n}\r\nstatic int bnref_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\r\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\r\n{\r\nRSAREFerr(RSAREF_F_BNREF_MOD_EXP,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\r\nreturn(0);\r\n}\r\nstatic int RSAref_bn2bin(BIGNUM *from, unsigned char *to, int max)\r\n{\r\nint i;\r\ni=BN_num_bytes(from);\r\nif (i > max)\r\n{\r\nRSAREFerr(RSAREF_F_RSAREF_BN2BIN,RSAREF_R_LEN);\r\nreturn(0);\r\n}\r\nmemset(to,0,(unsigned int)max);\r\nif (!BN_bn2bin(from,&(to[max-i])))\r\nreturn(0);\r\nreturn(1);\r\n}\r\nstatic BIGNUM *RSAref_bin2bn(unsigned char *from, BIGNUM *to, int max)\r\n{\r\nint i;\r\nBIGNUM *ret;\r\nfor (i=0; i<max; i++)\r\nif (from[i]) break;\r\nret=BN_bin2bn(&(from[i]),max-i,to);\r\nreturn(ret);\r\n}\r\nstatic int RSAref_Public_ref2eay(RSArefPublicKey *from, RSA *to)\r\n{\r\nto->n=RSAref_bin2bn(from->m,NULL,RSAref_MAX_LEN);\r\nto->e=RSAref_bin2bn(from->e,NULL,RSAref_MAX_LEN);\r\nif ((to->n == NULL) || (to->e == NULL)) return(0);\r\nreturn(1);\r\n}\r\nstatic int RSAref_Public_eay2ref(RSA *from, R_RSA_PUBLIC_KEY *to)\r\n{\r\nto->bits=BN_num_bits(from->n);\r\nif (!RSAref_bn2bin(from->n,to->modulus,MAX_RSA_MODULUS_LEN)) return(0);\r\nif (!RSAref_bn2bin(from->e,to->exponent,MAX_RSA_MODULUS_LEN)) return(0);\r\nreturn(1);\r\n}\r\nstatic int RSAref_Private_ref2eay(RSArefPrivateKey *from, RSA *to)\r\n{\r\nif ((to->n=RSAref_bin2bn(from->m,NULL,RSAref_MAX_LEN)) == NULL)\r\nreturn(0);\r\nif ((to->e=RSAref_bin2bn(from->e,NULL,RSAref_MAX_LEN)) == NULL)\r\nreturn(0);\r\nif ((to->d=RSAref_bin2bn(from->d,NULL,RSAref_MAX_LEN)) == NULL)\r\nreturn(0);\r\nif ((to->p=RSAref_bin2bn(from->prime[0],NULL,RSAref_MAX_PLEN)) == NULL)\r\nreturn(0);\r\nif ((to->q=RSAref_bin2bn(from->prime[1],NULL,RSAref_MAX_PLEN)) == NULL)\r\nreturn(0);\r\nif ((to->dmp1=RSAref_bin2bn(from->pexp[0],NULL,RSAref_MAX_PLEN))\r\n== NULL)\r\nreturn(0);\r\nif ((to->dmq1=RSAref_bin2bn(from->pexp[1],NULL,RSAref_MAX_PLEN))\r\n== NULL)\r\nreturn(0);\r\nif ((to->iqmp=RSAref_bin2bn(from->coef,NULL,RSAref_MAX_PLEN)) == NULL)\r\nreturn(0);\r\nreturn(1);\r\n}\r\nstatic int RSAref_Private_eay2ref(RSA *from, R_RSA_PRIVATE_KEY *to)\r\n{\r\nto->bits=BN_num_bits(from->n);\r\nif (!RSAref_bn2bin(from->n,to->modulus,MAX_RSA_MODULUS_LEN)) return(0);\r\nif (!RSAref_bn2bin(from->e,to->publicExponent,MAX_RSA_MODULUS_LEN)) return(0);\r\nif (!RSAref_bn2bin(from->d,to->exponent,MAX_RSA_MODULUS_LEN)) return(0);\r\nif (!RSAref_bn2bin(from->p,to->prime[0],MAX_RSA_PRIME_LEN)) return(0);\r\nif (!RSAref_bn2bin(from->q,to->prime[1],MAX_RSA_PRIME_LEN)) return(0);\r\nif (!RSAref_bn2bin(from->dmp1,to->primeExponent[0],MAX_RSA_PRIME_LEN)) return(0);\r\nif (!RSAref_bn2bin(from->dmq1,to->primeExponent[1],MAX_RSA_PRIME_LEN)) return(0);\r\nif (!RSAref_bn2bin(from->iqmp,to->coefficient,MAX_RSA_PRIME_LEN)) return(0);\r\nreturn(1);\r\n}\r\nstatic int rsaref_private_decrypt(int len, const unsigned char *from, unsigned char *to,\r\nRSA *rsa, int padding)\r\n{\r\nint i,outlen= -1;\r\nR_RSA_PRIVATE_KEY RSAkey;\r\nif (!RSAref_Private_eay2ref(rsa,&RSAkey))\r\ngoto err;\r\nif ((i=RSAPrivateDecrypt(to,(unsigned int *)&outlen,(unsigned char *)from,len,&RSAkey)) != 0)\r\n{\r\nRSAREFerr(RSAREF_F_RSAREF_PRIVATE_DECRYPT,i);\r\noutlen= -1;\r\n}\r\nerr:\r\nmemset(&RSAkey,0,sizeof(RSAkey));\r\nreturn(outlen);\r\n}\r\nstatic int rsaref_private_encrypt(int len, const unsigned char *from, unsigned char *to,\r\nRSA *rsa, int padding)\r\n{\r\nint i,outlen= -1;\r\nR_RSA_PRIVATE_KEY RSAkey;\r\nif (padding != RSA_PKCS1_PADDING)\r\n{\r\nRSAREFerr(RSAREF_F_RSAREF_PRIVATE_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\r\ngoto err;\r\n}\r\nif (!RSAref_Private_eay2ref(rsa,&RSAkey))\r\ngoto err;\r\nif ((i=RSAPrivateEncrypt(to,(unsigned int *)&outlen,(unsigned char *)from,len,&RSAkey)) != 0)\r\n{\r\nRSAREFerr(RSAREF_F_RSAREF_PRIVATE_ENCRYPT,i);\r\noutlen= -1;\r\n}\r\nerr:\r\nmemset(&RSAkey,0,sizeof(RSAkey));\r\nreturn(outlen);\r\n}\r\nstatic int rsaref_public_decrypt(int len, const unsigned char *from, unsigned char *to,\r\nRSA *rsa, int padding)\r\n{\r\nint i,outlen= -1;\r\nR_RSA_PUBLIC_KEY RSAkey;\r\nif (!RSAref_Public_eay2ref(rsa,&RSAkey))\r\ngoto err;\r\nif ((i=RSAPublicDecrypt(to,(unsigned int *)&outlen,(unsigned char *)from,len,&RSAkey)) != 0)\r\n{\r\nRSAREFerr(RSAREF_F_RSAREF_PUBLIC_DECRYPT,i);\r\noutlen= -1;\r\n}\r\nerr:\r\nmemset(&RSAkey,0,sizeof(RSAkey));\r\nreturn(outlen);\r\n}\r\nstatic int rsaref_public_encrypt(int len, const unsigned char *from, unsigned char *to,\r\nRSA *rsa, int padding)\r\n{\r\nint outlen= -1;\r\nint i;\r\nR_RSA_PUBLIC_KEY RSAkey;\r\nR_RANDOM_STRUCT rnd;\r\nunsigned char buf[16];\r\nif (padding != RSA_PKCS1_PADDING && padding != RSA_SSLV23_PADDING)\r\n{\r\nRSAREFerr(RSAREF_F_RSAREF_PUBLIC_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);\r\ngoto err;\r\n}\r\nR_RandomInit(&rnd);\r\nR_GetRandomBytesNeeded((unsigned int *)&i,&rnd);\r\nwhile (i > 0)\r\n{\r\nif (RAND_bytes(buf,16) <= 0)\r\ngoto err;\r\nR_RandomUpdate(&rnd,buf,(unsigned int)((i>16)?16:i));\r\ni-=16;\r\n}\r\nif (!RSAref_Public_eay2ref(rsa,&RSAkey))\r\ngoto err;\r\nif ((i=RSAPublicEncrypt(to,(unsigned int *)&outlen,(unsigned char *)from,len,&RSAkey,&rnd)) != 0)\r\n{\r\nRSAREFerr(RSAREF_F_RSAREF_PUBLIC_ENCRYPT,i);\r\noutlen= -1;\r\ngoto err;\r\n}\r\nerr:\r\nmemset(&RSAkey,0,sizeof(RSAkey));\r\nR_RandomFinal(&rnd);\r\nmemset(&rnd,0,sizeof(rnd));\r\nreturn(outlen);\r\n}\r\nstatic int rsaref_ciphers(ENGINE *e, const EVP_CIPHER **cipher,\r\nconst int **nids, int nid)\r\n{\r\nint ok = 1;\r\nif(!cipher)\r\n{\r\n*nids = rsaref_cipher_nids;\r\nreturn (sizeof(rsaref_cipher_nids)-1)/sizeof(rsaref_cipher_nids[0]);\r\n}\r\nswitch (nid)\r\n{\r\ncase NID_des_cbc:\r\n*cipher = &cipher_des_cbc; break;\r\ncase NID_des_ede3_cbc:\r\n*cipher = &cipher_des_ede3_cbc; break;\r\ncase NID_desx_cbc:\r\n*cipher = &cipher_desx_cbc; break;\r\ndefault:\r\nok = 0;\r\n*cipher = NULL;\r\nbreak;\r\n}\r\nreturn ok;\r\n}\r\nstatic int rsaref_digests(ENGINE *e, const EVP_MD **digest,\r\nconst int **nids, int nid)\r\n{\r\nint ok = 1;\r\nif(!digest)\r\n{\r\n*nids = rsaref_digest_nids;\r\nreturn (sizeof(rsaref_digest_nids)-1)/sizeof(rsaref_digest_nids[0]);\r\n}\r\nswitch (nid)\r\n{\r\ncase NID_md2:\r\n*digest = &digest_md2; break;\r\ncase NID_md5:\r\n*digest = &digest_md5; break;\r\ndefault:\r\nok = 0;\r\n*digest = NULL;\r\nbreak;\r\n}\r\nreturn ok;\r\n}\r\nstatic int cipher_des_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,\r\nconst unsigned char *iv, int enc)\r\n{\r\nDES_CBCInit(data(ctx), (unsigned char *)key, (unsigned char *)iv, enc);\r\nreturn 1;\r\n}\r\nstatic int cipher_des_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,\r\nconst unsigned char *in, unsigned int inl)\r\n{\r\nint ret = DES_CBCUpdate(data(ctx), out, (unsigned char *)in, inl);\r\nswitch (ret)\r\n{\r\ncase RE_LEN:\r\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_UNKNOWN_FAULT);\r\n}\r\nreturn !ret;\r\n}\r\nstatic int cipher_des_cbc_clean(EVP_CIPHER_CTX *ctx)\r\n{\r\nmemset(data(ctx), 0, ctx->cipher->ctx_size);\r\nreturn 1;\r\n}\r\nstatic int cipher_des_ede3_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,\r\nconst unsigned char *iv, int enc)\r\n{\r\nDES3_CBCInit(data(ctx), (unsigned char *)key, (unsigned char *)iv,\r\nenc);\r\nreturn 1;\r\n}\r\nstatic int cipher_des_ede3_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,\r\nconst unsigned char *in, unsigned int inl)\r\n{\r\nint ret = DES3_CBCUpdate(data(ctx), out, (unsigned char *)in, inl);\r\nswitch (ret)\r\n{\r\ncase RE_LEN:\r\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_UNKNOWN_FAULT);\r\n}\r\nreturn !ret;\r\n}\r\nstatic int cipher_des_ede3_cbc_clean(EVP_CIPHER_CTX *ctx)\r\n{\r\nmemset(data(ctx), 0, ctx->cipher->ctx_size);\r\nreturn 1;\r\n}\r\nstatic int cipher_desx_cbc_init(EVP_CIPHER_CTX *ctx, const unsigned char *key,\r\nconst unsigned char *iv, int enc)\r\n{\r\nDESX_CBCInit(data(ctx), (unsigned char *)key, (unsigned char *)iv,\r\nenc);\r\nreturn 1;\r\n}\r\nstatic int cipher_desx_cbc_code(EVP_CIPHER_CTX *ctx, unsigned char *out,\r\nconst unsigned char *in, unsigned int inl)\r\n{\r\nint ret = DESX_CBCUpdate(data(ctx), out, (unsigned char *)in, inl);\r\nswitch (ret)\r\n{\r\ncase RE_LEN:\r\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_LENGTH_NOT_BLOCK_ALIGNED);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nRSAREFerr(RSAREF_F_CIPHER_DES_CBC_CODE,RSAREF_R_UNKNOWN_FAULT);\r\n}\r\nreturn !ret;\r\n}\r\nstatic int cipher_desx_cbc_clean(EVP_CIPHER_CTX *ctx)\r\n{\r\nmemset(data(ctx), 0, ctx->cipher->ctx_size);\r\nreturn 1;\r\n}\r\nstatic int digest_md2_init(EVP_MD_CTX *ctx)\r\n{\r\nMD2Init(data(ctx));\r\nreturn 1;\r\n}\r\nstatic int digest_md2_update(EVP_MD_CTX *ctx,const void *data,\r\nunsigned long count)\r\n{\r\nMD2Update(data(ctx), (unsigned char *)data, (unsigned int)count);\r\nreturn 1;\r\n}\r\nstatic int digest_md2_final(EVP_MD_CTX *ctx,unsigned char *md)\r\n{\r\nMD2Final(md, data(ctx));\r\nreturn 1;\r\n}\r\nstatic int digest_md5_init(EVP_MD_CTX *ctx)\r\n{\r\nMD5Init(data(ctx));\r\nreturn 1;\r\n}\r\nstatic int digest_md5_update(EVP_MD_CTX *ctx,const void *data,\r\nunsigned long count)\r\n{\r\nMD5Update(data(ctx), (unsigned char *)data, (unsigned int)count);\r\nreturn 1;\r\n}\r\nstatic int digest_md5_final(EVP_MD_CTX *ctx,unsigned char *md)\r\n{\r\nMD5Final(md, data(ctx));\r\nreturn 1;\r\n}
