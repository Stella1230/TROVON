static int conn_state(BIO *b, BIO_CONNECT *c)\r\n{\r\nint ret= -1,i;\r\nunsigned long l;\r\nchar *p,*q;\r\nint (*cb)(const BIO *,int,int)=NULL;\r\nif (c->info_callback != NULL)\r\ncb=c->info_callback;\r\nfor (;;)\r\n{\r\nswitch (c->state)\r\n{\r\ncase BIO_CONN_S_BEFORE:\r\np=c->param_hostname;\r\nif (p == NULL)\r\n{\r\nBIOerr(BIO_F_CONN_STATE,BIO_R_NO_HOSTNAME_SPECIFIED);\r\ngoto exit_loop;\r\n}\r\nfor ( ; *p != '\0'; p++)\r\n{\r\nif ((*p == ':') || (*p == '/')) break;\r\n}\r\ni= *p;\r\nif ((i == ':') || (i == '/'))\r\n{\r\n*(p++)='\0';\r\nif (i == ':')\r\n{\r\nfor (q=p; *q; q++)\r\nif (*q == '/')\r\n{\r\n*q='\0';\r\nbreak;\r\n}\r\nif (c->param_port != NULL)\r\nOPENSSL_free(c->param_port);\r\nc->param_port=BUF_strdup(p);\r\n}\r\n}\r\nif (c->param_port == NULL)\r\n{\r\nBIOerr(BIO_F_CONN_STATE,BIO_R_NO_PORT_SPECIFIED);\r\nERR_add_error_data(2,"host=",c->param_hostname);\r\ngoto exit_loop;\r\n}\r\nc->state=BIO_CONN_S_GET_IP;\r\nbreak;\r\ncase BIO_CONN_S_GET_IP:\r\nif (BIO_get_host_ip(c->param_hostname,&(c->ip[0])) <= 0)\r\ngoto exit_loop;\r\nc->state=BIO_CONN_S_GET_PORT;\r\nbreak;\r\ncase BIO_CONN_S_GET_PORT:\r\nif (c->param_port == NULL)\r\n{\r\ngoto exit_loop;\r\n}\r\nelse if (BIO_get_port(c->param_port,&c->port) <= 0)\r\ngoto exit_loop;\r\nc->state=BIO_CONN_S_CREATE_SOCKET;\r\nbreak;\r\ncase BIO_CONN_S_CREATE_SOCKET:\r\nmemset((char *)&c->them,0,sizeof(c->them));\r\nc->them.sin_family=AF_INET;\r\nc->them.sin_port=htons((unsigned short)c->port);\r\nl=(unsigned long)\r\n((unsigned long)c->ip[0]<<24L)|\r\n((unsigned long)c->ip[1]<<16L)|\r\n((unsigned long)c->ip[2]<< 8L)|\r\n((unsigned long)c->ip[3]);\r\nc->them.sin_addr.s_addr=htonl(l);\r\nc->state=BIO_CONN_S_CREATE_SOCKET;\r\nret=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\r\nif (ret == INVALID_SOCKET)\r\n{\r\nSYSerr(SYS_F_SOCKET,get_last_socket_error());\r\nERR_add_error_data(4,"host=",c->param_hostname,\r\n":",c->param_port);\r\nBIOerr(BIO_F_CONN_STATE,BIO_R_UNABLE_TO_CREATE_SOCKET);\r\ngoto exit_loop;\r\n}\r\nb->num=ret;\r\nc->state=BIO_CONN_S_NBIO;\r\nbreak;\r\ncase BIO_CONN_S_NBIO:\r\nif (c->nbio)\r\n{\r\nif (!BIO_socket_nbio(b->num,1))\r\n{\r\nBIOerr(BIO_F_CONN_STATE,BIO_R_ERROR_SETTING_NBIO);\r\nERR_add_error_data(4,"host=",\r\nc->param_hostname,\r\n":",c->param_port);\r\ngoto exit_loop;\r\n}\r\n}\r\nc->state=BIO_CONN_S_CONNECT;\r\n#if defined(SO_KEEPALIVE) && !defined(OPENSSL_SYS_MPE)\r\ni=1;\r\ni=setsockopt(b->num,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));\r\nif (i < 0)\r\n{\r\nSYSerr(SYS_F_SOCKET,get_last_socket_error());\r\nERR_add_error_data(4,"host=",c->param_hostname,\r\n":",c->param_port);\r\nBIOerr(BIO_F_CONN_STATE,BIO_R_KEEPALIVE);\r\ngoto exit_loop;\r\n}\r\n#endif\r\nbreak;\r\ncase BIO_CONN_S_CONNECT:\r\nBIO_clear_retry_flags(b);\r\nret=connect(b->num,\r\n(struct sockaddr *)&c->them,\r\nsizeof(c->them));\r\nb->retry_reason=0;\r\nif (ret < 0)\r\n{\r\nif (BIO_sock_should_retry(ret))\r\n{\r\nBIO_set_retry_special(b);\r\nc->state=BIO_CONN_S_BLOCKED_CONNECT;\r\nb->retry_reason=BIO_RR_CONNECT;\r\n}\r\nelse\r\n{\r\nSYSerr(SYS_F_CONNECT,get_last_socket_error());\r\nERR_add_error_data(4,"host=",\r\nc->param_hostname,\r\n":",c->param_port);\r\nBIOerr(BIO_F_CONN_STATE,BIO_R_CONNECT_ERROR);\r\n}\r\ngoto exit_loop;\r\n}\r\nelse\r\nc->state=BIO_CONN_S_OK;\r\nbreak;\r\ncase BIO_CONN_S_BLOCKED_CONNECT:\r\ni=BIO_sock_error(b->num);\r\nif (i)\r\n{\r\nBIO_clear_retry_flags(b);\r\nSYSerr(SYS_F_CONNECT,i);\r\nERR_add_error_data(4,"host=",\r\nc->param_hostname,\r\n":",c->param_port);\r\nBIOerr(BIO_F_CONN_STATE,BIO_R_NBIO_CONNECT_ERROR);\r\nret=0;\r\ngoto exit_loop;\r\n}\r\nelse\r\nc->state=BIO_CONN_S_OK;\r\nbreak;\r\ncase BIO_CONN_S_OK:\r\nret=1;\r\ngoto exit_loop;\r\ndefault:\r\ngoto exit_loop;\r\n}\r\nif (cb != NULL)\r\n{\r\nif (!(ret=cb((BIO *)b,c->state,ret)))\r\ngoto end;\r\n}\r\n}\r\nexit_loop:\r\nif (cb != NULL)\r\nret=cb((BIO *)b,c->state,ret);\r\nend:\r\nreturn(ret);\r\n}\r\nBIO_CONNECT *BIO_CONNECT_new(void)\r\n{\r\nBIO_CONNECT *ret;\r\nif ((ret=(BIO_CONNECT *)OPENSSL_malloc(sizeof(BIO_CONNECT))) == NULL)\r\nreturn(NULL);\r\nret->state=BIO_CONN_S_BEFORE;\r\nret->param_hostname=NULL;\r\nret->param_port=NULL;\r\nret->info_callback=NULL;\r\nret->nbio=0;\r\nret->ip[0]=0;\r\nret->ip[1]=0;\r\nret->ip[2]=0;\r\nret->ip[3]=0;\r\nret->port=0;\r\nmemset((char *)&ret->them,0,sizeof(ret->them));\r\nreturn(ret);\r\n}\r\nvoid BIO_CONNECT_free(BIO_CONNECT *a)\r\n{\r\nif(a == NULL)\r\nreturn;\r\nif (a->param_hostname != NULL)\r\nOPENSSL_free(a->param_hostname);\r\nif (a->param_port != NULL)\r\nOPENSSL_free(a->param_port);\r\nOPENSSL_free(a);\r\n}\r\nBIO_METHOD *BIO_s_connect(void)\r\n{\r\nreturn(&methods_connectp);\r\n}\r\nstatic int conn_new(BIO *bi)\r\n{\r\nbi->init=0;\r\nbi->num=INVALID_SOCKET;\r\nbi->flags=0;\r\nif ((bi->ptr=(char *)BIO_CONNECT_new()) == NULL)\r\nreturn(0);\r\nelse\r\nreturn(1);\r\n}\r\nstatic void conn_close_socket(BIO *bio)\r\n{\r\nBIO_CONNECT *c;\r\nc=(BIO_CONNECT *)bio->ptr;\r\nif (bio->num != INVALID_SOCKET)\r\n{\r\nif (c->state == BIO_CONN_S_OK)\r\nshutdown(bio->num,2);\r\nclosesocket(bio->num);\r\nbio->num=INVALID_SOCKET;\r\n}\r\n}\r\nstatic int conn_free(BIO *a)\r\n{\r\nBIO_CONNECT *data;\r\nif (a == NULL) return(0);\r\ndata=(BIO_CONNECT *)a->ptr;\r\nif (a->shutdown)\r\n{\r\nconn_close_socket(a);\r\nBIO_CONNECT_free(data);\r\na->ptr=NULL;\r\na->flags=0;\r\na->init=0;\r\n}\r\nreturn(1);\r\n}\r\nstatic int conn_read(BIO *b, char *out, int outl)\r\n{\r\nint ret=0;\r\nBIO_CONNECT *data;\r\ndata=(BIO_CONNECT *)b->ptr;\r\nif (data->state != BIO_CONN_S_OK)\r\n{\r\nret=conn_state(b,data);\r\nif (ret <= 0)\r\nreturn(ret);\r\n}\r\nif (out != NULL)\r\n{\r\nclear_socket_error();\r\nret=readsocket(b->num,out,outl);\r\nBIO_clear_retry_flags(b);\r\nif (ret <= 0)\r\n{\r\nif (BIO_sock_should_retry(ret))\r\nBIO_set_retry_read(b);\r\n}\r\n}\r\nreturn(ret);\r\n}\r\nstatic int conn_write(BIO *b, const char *in, int inl)\r\n{\r\nint ret;\r\nBIO_CONNECT *data;\r\ndata=(BIO_CONNECT *)b->ptr;\r\nif (data->state != BIO_CONN_S_OK)\r\n{\r\nret=conn_state(b,data);\r\nif (ret <= 0) return(ret);\r\n}\r\nclear_socket_error();\r\nret=writesocket(b->num,in,inl);\r\nBIO_clear_retry_flags(b);\r\nif (ret <= 0)\r\n{\r\nif (BIO_sock_should_retry(ret))\r\nBIO_set_retry_write(b);\r\n}\r\nreturn(ret);\r\n}\r\nstatic long conn_ctrl(BIO *b, int cmd, long num, void *ptr)\r\n{\r\nBIO *dbio;\r\nint *ip;\r\nconst char **pptr;\r\nlong ret=1;\r\nBIO_CONNECT *data;\r\ndata=(BIO_CONNECT *)b->ptr;\r\nswitch (cmd)\r\n{\r\ncase BIO_CTRL_RESET:\r\nret=0;\r\ndata->state=BIO_CONN_S_BEFORE;\r\nconn_close_socket(b);\r\nb->flags=0;\r\nbreak;\r\ncase BIO_C_DO_STATE_MACHINE:\r\nif (data->state != BIO_CONN_S_OK)\r\nret=(long)conn_state(b,data);\r\nelse\r\nret=1;\r\nbreak;\r\ncase BIO_C_GET_CONNECT:\r\nif (ptr != NULL)\r\n{\r\npptr=(const char **)ptr;\r\nif (num == 0)\r\n{\r\n*pptr=data->param_hostname;\r\n}\r\nelse if (num == 1)\r\n{\r\n*pptr=data->param_port;\r\n}\r\nelse if (num == 2)\r\n{\r\n*pptr= (char *)&(data->ip[0]);\r\n}\r\nelse if (num == 3)\r\n{\r\n*((int *)ptr)=data->port;\r\n}\r\nif ((!b->init) || (ptr == NULL))\r\n*pptr="not initialized";\r\nret=1;\r\n}\r\nbreak;\r\ncase BIO_C_SET_CONNECT:\r\nif (ptr != NULL)\r\n{\r\nb->init=1;\r\nif (num == 0)\r\n{\r\nif (data->param_hostname != NULL)\r\nOPENSSL_free(data->param_hostname);\r\ndata->param_hostname=BUF_strdup(ptr);\r\n}\r\nelse if (num == 1)\r\n{\r\nif (data->param_port != NULL)\r\nOPENSSL_free(data->param_port);\r\ndata->param_port=BUF_strdup(ptr);\r\n}\r\nelse if (num == 2)\r\n{\r\nchar buf[16];\r\nunsigned char *p = ptr;\r\nBIO_snprintf(buf,sizeof buf,"%d.%d.%d.%d",\r\np[0],p[1],p[2],p[3]);\r\nif (data->param_hostname != NULL)\r\nOPENSSL_free(data->param_hostname);\r\ndata->param_hostname=BUF_strdup(buf);\r\nmemcpy(&(data->ip[0]),ptr,4);\r\n}\r\nelse if (num == 3)\r\n{\r\nchar buf[DECIMAL_SIZE(int)+1];\r\nBIO_snprintf(buf,sizeof buf,"%d",*(int *)ptr);\r\nif (data->param_port != NULL)\r\nOPENSSL_free(data->param_port);\r\ndata->param_port=BUF_strdup(buf);\r\ndata->port= *(int *)ptr;\r\n}\r\n}\r\nbreak;\r\ncase BIO_C_SET_NBIO:\r\ndata->nbio=(int)num;\r\nbreak;\r\ncase BIO_C_GET_FD:\r\nif (b->init)\r\n{\r\nip=(int *)ptr;\r\nif (ip != NULL)\r\n*ip=b->num;\r\nret=b->num;\r\n}\r\nelse\r\nret= -1;\r\nbreak;\r\ncase BIO_CTRL_GET_CLOSE:\r\nret=b->shutdown;\r\nbreak;\r\ncase BIO_CTRL_SET_CLOSE:\r\nb->shutdown=(int)num;\r\nbreak;\r\ncase BIO_CTRL_PENDING:\r\ncase BIO_CTRL_WPENDING:\r\nret=0;\r\nbreak;\r\ncase BIO_CTRL_FLUSH:\r\nbreak;\r\ncase BIO_CTRL_DUP:\r\n{\r\ndbio=(BIO *)ptr;\r\nif (data->param_port)\r\nBIO_set_conn_port(dbio,data->param_port);\r\nif (data->param_hostname)\r\nBIO_set_conn_hostname(dbio,data->param_hostname);\r\nBIO_set_nbio(dbio,data->nbio);\r\n(void)BIO_set_info_callback(dbio,(bio_info_cb *)data->info_callback);\r\n}\r\nbreak;\r\ncase BIO_CTRL_SET_CALLBACK:\r\n{\r\n#if 0\r\nBIOerr(BIO_F_CONN_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\r\nret = -1;\r\n#else\r\nret=0;\r\n#endif\r\n}\r\nbreak;\r\ncase BIO_CTRL_GET_CALLBACK:\r\n{\r\nint (**fptr)(const BIO *bio,int state,int xret);\r\nfptr=(int (**)(const BIO *bio,int state,int xret))ptr;\r\n*fptr=data->info_callback;\r\n}\r\nbreak;\r\ndefault:\r\nret=0;\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic long conn_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\r\n{\r\nlong ret=1;\r\nBIO_CONNECT *data;\r\ndata=(BIO_CONNECT *)b->ptr;\r\nswitch (cmd)\r\n{\r\ncase BIO_CTRL_SET_CALLBACK:\r\n{\r\ndata->info_callback=(int (*)(const struct bio_st *, int, int))fp;\r\n}\r\nbreak;\r\ndefault:\r\nret=0;\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic int conn_puts(BIO *bp, const char *str)\r\n{\r\nint n,ret;\r\nn=strlen(str);\r\nret=conn_write(bp,str,n);\r\nreturn(ret);\r\n}\r\nBIO *BIO_new_connect(char *str)\r\n{\r\nBIO *ret;\r\nret=BIO_new(BIO_s_connect());\r\nif (ret == NULL) return(NULL);\r\nif (BIO_set_conn_hostname(ret,str))\r\nreturn(ret);\r\nelse\r\n{\r\nBIO_free(ret);\r\nreturn(NULL);\r\n}\r\n}
