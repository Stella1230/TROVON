X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void)\r\n{\r\nreturn(&x509_dir_lookup);\r\n}\r\nstatic int dir_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\r\nchar **retp)\r\n{\r\nint ret=0;\r\nBY_DIR *ld;\r\nchar *dir = NULL;\r\nld=(BY_DIR *)ctx->method_data;\r\nswitch (cmd)\r\n{\r\ncase X509_L_ADD_DIR:\r\nif (argl == X509_FILETYPE_DEFAULT)\r\n{\r\ndir=(char *)getenv(X509_get_default_cert_dir_env());\r\nif (dir)\r\nret=add_cert_dir(ld,dir,X509_FILETYPE_PEM);\r\nelse\r\nret=add_cert_dir(ld,X509_get_default_cert_dir(),\r\nX509_FILETYPE_PEM);\r\nif (!ret)\r\n{\r\nX509err(X509_F_DIR_CTRL,X509_R_LOADING_CERT_DIR);\r\n}\r\n}\r\nelse\r\nret=add_cert_dir(ld,argp,(int)argl);\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic int new_dir(X509_LOOKUP *lu)\r\n{\r\nBY_DIR *a;\r\nif ((a=(BY_DIR *)OPENSSL_malloc(sizeof(BY_DIR))) == NULL)\r\nreturn(0);\r\nif ((a->buffer=BUF_MEM_new()) == NULL)\r\n{\r\nOPENSSL_free(a);\r\nreturn(0);\r\n}\r\na->dirs=NULL;\r\nlu->method_data=(char *)a;\r\nreturn(1);\r\n}\r\nstatic void by_dir_hash_free(BY_DIR_HASH *hash)\r\n{\r\nOPENSSL_free(hash);\r\n}\r\nstatic int by_dir_hash_cmp(const BY_DIR_HASH * const *a,\r\nconst BY_DIR_HASH * const *b)\r\n{\r\nif ((*a)->hash > (*b)->hash)\r\nreturn 1;\r\nif ((*a)->hash < (*b)->hash)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void by_dir_entry_free(BY_DIR_ENTRY *ent)\r\n{\r\nif (ent->dir)\r\nOPENSSL_free(ent->dir);\r\nif (ent->hashes)\r\nsk_BY_DIR_HASH_pop_free(ent->hashes, by_dir_hash_free);\r\nOPENSSL_free(ent);\r\n}\r\nstatic void free_dir(X509_LOOKUP *lu)\r\n{\r\nBY_DIR *a;\r\na=(BY_DIR *)lu->method_data;\r\nif (a->dirs != NULL)\r\nsk_BY_DIR_ENTRY_pop_free(a->dirs, by_dir_entry_free);\r\nif (a->buffer != NULL)\r\nBUF_MEM_free(a->buffer);\r\nOPENSSL_free(a);\r\n}\r\nstatic int add_cert_dir(BY_DIR *ctx, const char *dir, int type)\r\n{\r\nint j,len;\r\nconst char *s,*ss,*p;\r\nif (dir == NULL || !*dir)\r\n{\r\nX509err(X509_F_ADD_CERT_DIR,X509_R_INVALID_DIRECTORY);\r\nreturn 0;\r\n}\r\ns=dir;\r\np=s;\r\nfor (;;p++)\r\n{\r\nif ((*p == LIST_SEPARATOR_CHAR) || (*p == '\0'))\r\n{\r\nBY_DIR_ENTRY *ent;\r\nss=s;\r\ns=p+1;\r\nlen=(int)(p-ss);\r\nif (len == 0) continue;\r\nfor (j=0; j < sk_BY_DIR_ENTRY_num(ctx->dirs); j++)\r\n{\r\nent = sk_BY_DIR_ENTRY_value(ctx->dirs, j);\r\nif (strlen(ent->dir) == (size_t)len &&\r\nstrncmp(ent->dir,ss,(unsigned int)len) == 0)\r\nbreak;\r\n}\r\nif (j < sk_BY_DIR_ENTRY_num(ctx->dirs))\r\ncontinue;\r\nif (ctx->dirs == NULL)\r\n{\r\nctx->dirs = sk_BY_DIR_ENTRY_new_null();\r\nif (!ctx->dirs)\r\n{\r\nX509err(X509_F_ADD_CERT_DIR,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\n}\r\nent = OPENSSL_malloc(sizeof(BY_DIR_ENTRY));\r\nif (!ent)\r\nreturn 0;\r\nent->dir_type = type;\r\nent->hashes = sk_BY_DIR_HASH_new(by_dir_hash_cmp);\r\nent->dir = OPENSSL_malloc((unsigned int)len+1);\r\nif (!ent->dir || !ent->hashes)\r\n{\r\nby_dir_entry_free(ent);\r\nreturn 0;\r\n}\r\nstrncpy(ent->dir,ss,(unsigned int)len);\r\nent->dir[len] = '\0';\r\nif (!sk_BY_DIR_ENTRY_push(ctx->dirs, ent))\r\n{\r\nby_dir_entry_free(ent);\r\nreturn 0;\r\n}\r\n}\r\nif (*p == '\0')\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int get_cert_by_subject(X509_LOOKUP *xl, int type, X509_NAME *name,\r\nX509_OBJECT *ret)\r\n{\r\nBY_DIR *ctx;\r\nunion {\r\nstruct {\r\nX509 st_x509;\r\nX509_CINF st_x509_cinf;\r\n} x509;\r\nstruct {\r\nX509_CRL st_crl;\r\nX509_CRL_INFO st_crl_info;\r\n} crl;\r\n} data;\r\nint ok=0;\r\nint i,j,k;\r\nunsigned long h;\r\nBUF_MEM *b=NULL;\r\nX509_OBJECT stmp,*tmp;\r\nconst char *postfix="";\r\nif (name == NULL) return(0);\r\nstmp.type=type;\r\nif (type == X509_LU_X509)\r\n{\r\ndata.x509.st_x509.cert_info= &data.x509.st_x509_cinf;\r\ndata.x509.st_x509_cinf.subject=name;\r\nstmp.data.x509= &data.x509.st_x509;\r\npostfix="";\r\n}\r\nelse if (type == X509_LU_CRL)\r\n{\r\ndata.crl.st_crl.crl= &data.crl.st_crl_info;\r\ndata.crl.st_crl_info.issuer=name;\r\nstmp.data.crl= &data.crl.st_crl;\r\npostfix="r";\r\n}\r\nelse\r\n{\r\nX509err(X509_F_GET_CERT_BY_SUBJECT,X509_R_WRONG_LOOKUP_TYPE);\r\ngoto finish;\r\n}\r\nif ((b=BUF_MEM_new()) == NULL)\r\n{\r\nX509err(X509_F_GET_CERT_BY_SUBJECT,ERR_R_BUF_LIB);\r\ngoto finish;\r\n}\r\nctx=(BY_DIR *)xl->method_data;\r\nh=X509_NAME_hash(name);\r\nfor (i=0; i < sk_BY_DIR_ENTRY_num(ctx->dirs); i++)\r\n{\r\nBY_DIR_ENTRY *ent;\r\nint idx;\r\nBY_DIR_HASH htmp, *hent;\r\nent = sk_BY_DIR_ENTRY_value(ctx->dirs, i);\r\nj=strlen(ent->dir)+1+8+6+1+1;\r\nif (!BUF_MEM_grow(b,j))\r\n{\r\nX509err(X509_F_GET_CERT_BY_SUBJECT,ERR_R_MALLOC_FAILURE);\r\ngoto finish;\r\n}\r\nif (type == X509_LU_CRL && ent->hashes)\r\n{\r\nhtmp.hash = h;\r\nCRYPTO_r_lock(CRYPTO_LOCK_X509_STORE);\r\nidx = sk_BY_DIR_HASH_find(ent->hashes, &htmp);\r\nif (idx >= 0)\r\n{\r\nhent = sk_BY_DIR_HASH_value(ent->hashes, idx);\r\nk = hent->suffix;\r\n}\r\nelse\r\n{\r\nhent = NULL;\r\nk=0;\r\n}\r\nCRYPTO_r_unlock(CRYPTO_LOCK_X509_STORE);\r\n}\r\nelse\r\n{\r\nk = 0;\r\nhent = NULL;\r\n}\r\nfor (;;)\r\n{\r\nchar c = '/';\r\n#ifdef OPENSSL_SYS_VMS\r\nc = ent->dir[strlen(ent->dir)-1];\r\nif (c != ':' && c != '>' && c != ']')\r\n{\r\nc = ':';\r\n}\r\nelse\r\n{\r\nc = '\0';\r\n}\r\n#endif\r\nif (c == '\0')\r\n{\r\nBIO_snprintf(b->data,b->max,\r\n"%s%08lx.%s%d",ent->dir,h,\r\npostfix,k);\r\n}\r\nelse\r\n{\r\nBIO_snprintf(b->data,b->max,\r\n"%s%c%08lx.%s%d",ent->dir,c,h,\r\npostfix,k);\r\n}\r\n#ifndef OPENSSL_NO_POSIX_IO\r\n#ifdef _WIN32\r\n#define stat _stat\r\n#endif\r\n{\r\nstruct stat st;\r\nif (stat(b->data,&st) < 0)\r\nbreak;\r\n}\r\n#endif\r\nif (type == X509_LU_X509)\r\n{\r\nif ((X509_load_cert_file(xl,b->data,\r\nent->dir_type)) == 0)\r\nbreak;\r\n}\r\nelse if (type == X509_LU_CRL)\r\n{\r\nif ((X509_load_crl_file(xl,b->data,\r\nent->dir_type)) == 0)\r\nbreak;\r\n}\r\nk++;\r\n}\r\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\r\nj = sk_X509_OBJECT_find(xl->store_ctx->objs,&stmp);\r\nif(j != -1) tmp=sk_X509_OBJECT_value(xl->store_ctx->objs,j);\r\nelse tmp = NULL;\r\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\r\nif (type == X509_LU_CRL)\r\n{\r\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\r\nif (!hent)\r\n{\r\nhtmp.hash = h;\r\nidx = sk_BY_DIR_HASH_find(ent->hashes, &htmp);\r\nif (idx >= 0)\r\nhent =\r\nsk_BY_DIR_HASH_value(ent->hashes, idx);\r\n}\r\nif (!hent)\r\n{\r\nhent = OPENSSL_malloc(sizeof(BY_DIR_HASH));\r\nhent->hash = h;\r\nhent->suffix = k;\r\nif (!sk_BY_DIR_HASH_push(ent->hashes, hent))\r\n{\r\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\r\nOPENSSL_free(hent);\r\nok = 0;\r\ngoto finish;\r\n}\r\n}\r\nelse if (hent->suffix < k)\r\nhent->suffix = k;\r\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\r\n}\r\nif (tmp != NULL)\r\n{\r\nok=1;\r\nret->type=tmp->type;\r\nmemcpy(&ret->data,&tmp->data,sizeof(ret->data));\r\ngoto finish;\r\n}\r\n}\r\nfinish:\r\nif (b != NULL) BUF_MEM_free(b);\r\nreturn(ok);\r\n}
