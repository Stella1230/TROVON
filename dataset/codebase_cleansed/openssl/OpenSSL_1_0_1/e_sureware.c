static int surewarehk_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\r\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\r\n{\r\nreturn surewarehk_modexp(r, a, p, m, ctx);\r\n}\r\nstatic int surewarehk_modexp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,\r\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\r\n{\r\nreturn surewarehk_modexp(r, a, p, m, ctx);\r\n}\r\nstatic int surewarehk_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,\r\nBIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\r\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\r\n{\r\nBIGNUM t;\r\nint to_return = 0;\r\nBN_init(&t);\r\nif (!surewarehk_modexp(rr,a1,p1,m,ctx)) goto end;\r\nif (!surewarehk_modexp(&t,a2,p2,m,ctx)) goto end;\r\nif (!BN_mod_mul(rr,rr,&t,m,ctx)) goto end;\r\nto_return = 1;\r\nend:\r\nBN_free(&t);\r\nreturn to_return;\r\n}\r\nstatic int bind_sureware(ENGINE *e)\r\n{\r\n#ifndef OPENSSL_NO_RSA\r\nconst RSA_METHOD *meth1;\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\nconst DSA_METHOD *meth2;\r\n#endif\r\n#ifndef OPENSSL_NO_DH\r\nconst DH_METHOD *meth3;\r\n#endif\r\nif(!ENGINE_set_id(e, engine_sureware_id) ||\r\n!ENGINE_set_name(e, engine_sureware_name) ||\r\n#ifndef OPENSSL_NO_RSA\r\n!ENGINE_set_RSA(e, &surewarehk_rsa) ||\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\n!ENGINE_set_DSA(e, &surewarehk_dsa) ||\r\n#endif\r\n#ifndef OPENSSL_NO_DH\r\n!ENGINE_set_DH(e, &surewarehk_dh) ||\r\n#endif\r\n!ENGINE_set_RAND(e, &surewarehk_rand) ||\r\n!ENGINE_set_destroy_function(e, surewarehk_destroy) ||\r\n!ENGINE_set_init_function(e, surewarehk_init) ||\r\n!ENGINE_set_finish_function(e, surewarehk_finish) ||\r\n!ENGINE_set_ctrl_function(e, surewarehk_ctrl) ||\r\n!ENGINE_set_load_privkey_function(e, surewarehk_load_privkey) ||\r\n!ENGINE_set_load_pubkey_function(e, surewarehk_load_pubkey))\r\nreturn 0;\r\n#ifndef OPENSSL_NO_RSA\r\nmeth1 = RSA_PKCS1_SSLeay();\r\nif (meth1)\r\n{\r\nsurewarehk_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\r\nsurewarehk_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\r\n}\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\nmeth2 = DSA_OpenSSL();\r\nif (meth2)\r\n{\r\nsurewarehk_dsa.dsa_do_verify = meth2->dsa_do_verify;\r\n}\r\n#endif\r\n#ifndef OPENSSL_NO_DH\r\nmeth3 = DH_OpenSSL();\r\nif (meth3)\r\n{\r\nsurewarehk_dh.generate_key = meth3->generate_key;\r\nsurewarehk_dh.compute_key = meth3->compute_key;\r\n}\r\n#endif\r\nERR_load_SUREWARE_strings();\r\nreturn 1;\r\n}\r\nstatic int bind_helper(ENGINE *e, const char *id)\r\n{\r\nif(id && (strcmp(id, engine_sureware_id) != 0))\r\nreturn 0;\r\nif(!bind_sureware(e))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic ENGINE *engine_sureware(void)\r\n{\r\nENGINE *ret = ENGINE_new();\r\nif(!ret)\r\nreturn NULL;\r\nif(!bind_sureware(ret))\r\n{\r\nENGINE_free(ret);\r\nreturn NULL;\r\n}\r\nreturn ret;\r\n}\r\nvoid ENGINE_load_sureware(void)\r\n{\r\nENGINE *toadd = engine_sureware();\r\nif(!toadd) return;\r\nENGINE_add(toadd);\r\nENGINE_free(toadd);\r\nERR_clear_error();\r\n}\r\nstatic int surewarehk_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\r\n{\r\nint to_return = 1;\r\nswitch(cmd)\r\n{\r\ncase ENGINE_CTRL_SET_LOGSTREAM:\r\n{\r\nBIO *bio = (BIO *)p;\r\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\r\nif (logstream)\r\n{\r\nBIO_free(logstream);\r\nlogstream = NULL;\r\n}\r\nif (CRYPTO_add(&bio->references,1,CRYPTO_LOCK_BIO) > 1)\r\nlogstream = bio;\r\nelse\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_CTRL,SUREWARE_R_BIO_WAS_FREED);\r\n}\r\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\r\nbreak;\r\ncase ENGINE_CTRL_CHIL_NO_LOCKING:\r\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\r\nthreadsafe = 0;\r\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\r\nbreak;\r\ndefault:\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_CTRL,\r\nENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);\r\nto_return = 0;\r\nbreak;\r\n}\r\nreturn to_return;\r\n}\r\nstatic int surewarehk_destroy(ENGINE *e)\r\n{\r\nERR_unload_SUREWARE_strings();\r\nreturn 1;\r\n}\r\nstatic int surewarehk_init(ENGINE *e)\r\n{\r\nchar msg[64]="ENGINE_init";\r\nSureWareHook_Init_t *p1=NULL;\r\nSureWareHook_Finish_t *p2=NULL;\r\nSureWareHook_Rand_Bytes_t *p3=NULL;\r\nSureWareHook_Rand_Seed_t *p4=NULL;\r\nSureWareHook_Load_Privkey_t *p5=NULL;\r\nSureWareHook_Load_Rsa_Pubkey_t *p6=NULL;\r\nSureWareHook_Free_t *p7=NULL;\r\nSureWareHook_Rsa_Priv_Dec_t *p8=NULL;\r\nSureWareHook_Rsa_Sign_t *p9=NULL;\r\nSureWareHook_Dsa_Sign_t *p12=NULL;\r\nSureWareHook_Info_Pubkey_t *p13=NULL;\r\nSureWareHook_Load_Dsa_Pubkey_t *p14=NULL;\r\nSureWareHook_Mod_Exp_t *p15=NULL;\r\nif(surewarehk_dso != NULL)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,ENGINE_R_ALREADY_LOADED);\r\ngoto err;\r\n}\r\nsurewarehk_dso = DSO_load(NULL, surewarehk_LIBNAME, NULL, 0);\r\nif(surewarehk_dso == NULL)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,ENGINE_R_DSO_FAILURE);\r\ngoto err;\r\n}\r\nif(!(p1=(SureWareHook_Init_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Init)) ||\r\n!(p2=(SureWareHook_Finish_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Finish)) ||\r\n!(p3=(SureWareHook_Rand_Bytes_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Rand_Bytes)) ||\r\n!(p4=(SureWareHook_Rand_Seed_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Rand_Seed)) ||\r\n!(p5=(SureWareHook_Load_Privkey_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Load_Privkey)) ||\r\n!(p6=(SureWareHook_Load_Rsa_Pubkey_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Load_Rsa_Pubkey)) ||\r\n!(p7=(SureWareHook_Free_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Free)) ||\r\n!(p8=(SureWareHook_Rsa_Priv_Dec_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Rsa_Priv_Dec)) ||\r\n!(p9=(SureWareHook_Rsa_Sign_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Rsa_Sign)) ||\r\n!(p12=(SureWareHook_Dsa_Sign_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Dsa_Sign)) ||\r\n!(p13=(SureWareHook_Info_Pubkey_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Info_Pubkey)) ||\r\n!(p14=(SureWareHook_Load_Dsa_Pubkey_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Load_Dsa_Pubkey)) ||\r\n!(p15=(SureWareHook_Mod_Exp_t*)DSO_bind_func(surewarehk_dso, n_surewarehk_Mod_Exp)))\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,ENGINE_R_DSO_FAILURE);\r\ngoto err;\r\n}\r\np_surewarehk_Init = p1;\r\np_surewarehk_Finish = p2;\r\np_surewarehk_Rand_Bytes = p3;\r\np_surewarehk_Rand_Seed = p4;\r\np_surewarehk_Load_Privkey = p5;\r\np_surewarehk_Load_Rsa_Pubkey = p6;\r\np_surewarehk_Free = p7;\r\np_surewarehk_Rsa_Priv_Dec = p8;\r\np_surewarehk_Rsa_Sign = p9;\r\np_surewarehk_Dsa_Sign = p12;\r\np_surewarehk_Info_Pubkey = p13;\r\np_surewarehk_Load_Dsa_Pubkey = p14;\r\np_surewarehk_Mod_Exp = p15;\r\nif(p_surewarehk_Init(msg,threadsafe)==SUREWAREHOOK_ERROR_UNIT_FAILURE)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,SUREWARE_R_UNIT_FAILURE);\r\ngoto err;\r\n}\r\nif(p_surewarehk_Init(msg,threadsafe)==SUREWAREHOOK_ERROR_UNIT_FAILURE)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_INIT,SUREWARE_R_UNIT_FAILURE);\r\ngoto err;\r\n}\r\nsurewarehk_load_privkey(e,NULL,NULL,NULL);\r\n#ifndef OPENSSL_NO_RSA\r\nif (rsaHndidx == -1)\r\nrsaHndidx = RSA_get_ex_new_index(0,\r\n"SureWareHook RSA key handle",\r\nNULL, NULL, surewarehk_ex_free);\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\nif (dsaHndidx == -1)\r\ndsaHndidx = DSA_get_ex_new_index(0,\r\n"SureWareHook DSA key handle",\r\nNULL, NULL, surewarehk_ex_free);\r\n#endif\r\nreturn 1;\r\nerr:\r\nif(surewarehk_dso)\r\nDSO_free(surewarehk_dso);\r\nsurewarehk_dso = NULL;\r\np_surewarehk_Init = NULL;\r\np_surewarehk_Finish = NULL;\r\np_surewarehk_Rand_Bytes = NULL;\r\np_surewarehk_Rand_Seed = NULL;\r\np_surewarehk_Load_Privkey = NULL;\r\np_surewarehk_Load_Rsa_Pubkey = NULL;\r\np_surewarehk_Free = NULL;\r\np_surewarehk_Rsa_Priv_Dec = NULL;\r\np_surewarehk_Rsa_Sign = NULL;\r\np_surewarehk_Dsa_Sign = NULL;\r\np_surewarehk_Info_Pubkey = NULL;\r\np_surewarehk_Load_Dsa_Pubkey = NULL;\r\np_surewarehk_Mod_Exp = NULL;\r\nreturn 0;\r\n}\r\nstatic int surewarehk_finish(ENGINE *e)\r\n{\r\nint to_return = 1;\r\nif(surewarehk_dso == NULL)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_FINISH,ENGINE_R_NOT_LOADED);\r\nto_return = 0;\r\ngoto err;\r\n}\r\np_surewarehk_Finish();\r\nif(!DSO_free(surewarehk_dso))\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_FINISH,ENGINE_R_DSO_FAILURE);\r\nto_return = 0;\r\ngoto err;\r\n}\r\nerr:\r\nif (logstream)\r\nBIO_free(logstream);\r\nsurewarehk_dso = NULL;\r\np_surewarehk_Init = NULL;\r\np_surewarehk_Finish = NULL;\r\np_surewarehk_Rand_Bytes = NULL;\r\np_surewarehk_Rand_Seed = NULL;\r\np_surewarehk_Load_Privkey = NULL;\r\np_surewarehk_Load_Rsa_Pubkey = NULL;\r\np_surewarehk_Free = NULL;\r\np_surewarehk_Rsa_Priv_Dec = NULL;\r\np_surewarehk_Rsa_Sign = NULL;\r\np_surewarehk_Dsa_Sign = NULL;\r\np_surewarehk_Info_Pubkey = NULL;\r\np_surewarehk_Load_Dsa_Pubkey = NULL;\r\np_surewarehk_Mod_Exp = NULL;\r\nreturn to_return;\r\n}\r\nstatic void surewarehk_error_handling(char *const msg,int func,int ret)\r\n{\r\nswitch (ret)\r\n{\r\ncase SUREWAREHOOK_ERROR_UNIT_FAILURE:\r\nENGINEerr(func,SUREWARE_R_UNIT_FAILURE);\r\nbreak;\r\ncase SUREWAREHOOK_ERROR_FALLBACK:\r\nENGINEerr(func,SUREWARE_R_REQUEST_FALLBACK);\r\nbreak;\r\ncase SUREWAREHOOK_ERROR_DATA_SIZE:\r\nENGINEerr(func,SUREWARE_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\r\nbreak;\r\ncase SUREWAREHOOK_ERROR_INVALID_PAD:\r\nENGINEerr(func,SUREWARE_R_PADDING_CHECK_FAILED);\r\nbreak;\r\ndefault:\r\nENGINEerr(func,SUREWARE_R_REQUEST_FAILED);\r\nbreak;\r\ncase 1:\r\nmsg[0]='\0';\r\n}\r\nif (*msg)\r\n{\r\nERR_add_error_data(1,msg);\r\nif (logstream)\r\n{\r\nCRYPTO_w_lock(CRYPTO_LOCK_BIO);\r\nBIO_write(logstream, msg, strlen(msg));\r\nCRYPTO_w_unlock(CRYPTO_LOCK_BIO);\r\n}\r\n}\r\n}\r\nstatic int surewarehk_rand_bytes(unsigned char *buf, int num)\r\n{\r\nint ret=0;\r\nchar msg[64]="ENGINE_rand_bytes";\r\nif(!p_surewarehk_Rand_Bytes)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RAND_BYTES,ENGINE_R_NOT_INITIALISED);\r\n}\r\nelse\r\n{\r\nret = p_surewarehk_Rand_Bytes(msg,buf, num);\r\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RAND_BYTES,ret);\r\n}\r\nreturn ret==1 ? 1 : 0;\r\n}\r\nstatic void surewarehk_rand_seed(const void *buf, int num)\r\n{\r\nint ret=0;\r\nchar msg[64]="ENGINE_rand_seed";\r\nif(!p_surewarehk_Rand_Seed)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RAND_SEED,ENGINE_R_NOT_INITIALISED);\r\n}\r\nelse\r\n{\r\nret = p_surewarehk_Rand_Seed(msg,buf, num);\r\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RAND_SEED,ret);\r\n}\r\n}\r\nstatic void surewarehk_rand_add(const void *buf, int num, double entropy)\r\n{\r\nsurewarehk_rand_seed(buf,num);\r\n}\r\nstatic EVP_PKEY* sureware_load_public(ENGINE *e,const char *key_id,char *hptr,unsigned long el,char keytype)\r\n{\r\nEVP_PKEY *res = NULL;\r\n#ifndef OPENSSL_NO_RSA\r\nRSA *rsatmp = NULL;\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\nDSA *dsatmp=NULL;\r\n#endif\r\nchar msg[64]="sureware_load_public";\r\nint ret=0;\r\nif(!p_surewarehk_Load_Rsa_Pubkey || !p_surewarehk_Load_Dsa_Pubkey)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWARE_LOAD_PUBLIC,ENGINE_R_NOT_INITIALISED);\r\ngoto err;\r\n}\r\nswitch (keytype)\r\n{\r\n#ifndef OPENSSL_NO_RSA\r\ncase 1:\r\nrsatmp = RSA_new_method(e);\r\nRSA_set_ex_data(rsatmp,rsaHndidx,hptr);\r\nrsatmp->flags |= RSA_FLAG_EXT_PKEY;\r\nrsatmp->e = BN_new();\r\nrsatmp->n = BN_new();\r\nbn_expand2(rsatmp->e, el/sizeof(BN_ULONG));\r\nbn_expand2(rsatmp->n, el/sizeof(BN_ULONG));\r\nif (!rsatmp->e || rsatmp->e->dmax!=(int)(el/sizeof(BN_ULONG))||\r\n!rsatmp->n || rsatmp->n->dmax!=(int)(el/sizeof(BN_ULONG)))\r\ngoto err;\r\nret=p_surewarehk_Load_Rsa_Pubkey(msg,key_id,el,\r\n(unsigned long *)rsatmp->n->d,\r\n(unsigned long *)rsatmp->e->d);\r\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWARE_LOAD_PUBLIC,ret);\r\nif (ret!=1)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWARE_LOAD_PUBLIC,ENGINE_R_FAILED_LOADING_PUBLIC_KEY);\r\ngoto err;\r\n}\r\nrsatmp->e->top=el/sizeof(BN_ULONG);\r\nbn_fix_top(rsatmp->e);\r\nrsatmp->n->top=el/sizeof(BN_ULONG);\r\nbn_fix_top(rsatmp->n);\r\nres = EVP_PKEY_new();\r\nEVP_PKEY_assign_RSA(res, rsatmp);\r\nbreak;\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\ncase 2:\r\ndsatmp = DSA_new_method(e);\r\nDSA_set_ex_data(dsatmp,dsaHndidx,hptr);\r\ndsatmp->pub_key = BN_new();\r\ndsatmp->p = BN_new();\r\ndsatmp->q = BN_new();\r\ndsatmp->g = BN_new();\r\nbn_expand2(dsatmp->pub_key, el/sizeof(BN_ULONG));\r\nbn_expand2(dsatmp->p, el/sizeof(BN_ULONG));\r\nbn_expand2(dsatmp->q, 20/sizeof(BN_ULONG));\r\nbn_expand2(dsatmp->g, el/sizeof(BN_ULONG));\r\nif (!dsatmp->pub_key || dsatmp->pub_key->dmax!=(int)(el/sizeof(BN_ULONG))||\r\n!dsatmp->p || dsatmp->p->dmax!=(int)(el/sizeof(BN_ULONG)) ||\r\n!dsatmp->q || dsatmp->q->dmax!=20/sizeof(BN_ULONG) ||\r\n!dsatmp->g || dsatmp->g->dmax!=(int)(el/sizeof(BN_ULONG)))\r\ngoto err;\r\nret=p_surewarehk_Load_Dsa_Pubkey(msg,key_id,el,\r\n(unsigned long *)dsatmp->pub_key->d,\r\n(unsigned long *)dsatmp->p->d,\r\n(unsigned long *)dsatmp->q->d,\r\n(unsigned long *)dsatmp->g->d);\r\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWARE_LOAD_PUBLIC,ret);\r\nif (ret!=1)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWARE_LOAD_PUBLIC,ENGINE_R_FAILED_LOADING_PUBLIC_KEY);\r\ngoto err;\r\n}\r\ndsatmp->pub_key->top=el/sizeof(BN_ULONG);\r\nbn_fix_top(dsatmp->pub_key);\r\ndsatmp->p->top=el/sizeof(BN_ULONG);\r\nbn_fix_top(dsatmp->p);\r\ndsatmp->q->top=20/sizeof(BN_ULONG);\r\nbn_fix_top(dsatmp->q);\r\ndsatmp->g->top=el/sizeof(BN_ULONG);\r\nbn_fix_top(dsatmp->g);\r\nres = EVP_PKEY_new();\r\nEVP_PKEY_assign_DSA(res, dsatmp);\r\nbreak;\r\n#endif\r\ndefault:\r\nSUREWAREerr(SUREWARE_F_SUREWARE_LOAD_PUBLIC,ENGINE_R_FAILED_LOADING_PRIVATE_KEY);\r\ngoto err;\r\n}\r\nreturn res;\r\nerr:\r\n#ifndef OPENSSL_NO_RSA\r\nif (rsatmp)\r\nRSA_free(rsatmp);\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\nif (dsatmp)\r\nDSA_free(dsatmp);\r\n#endif\r\nreturn NULL;\r\n}\r\nstatic EVP_PKEY *surewarehk_load_privkey(ENGINE *e, const char *key_id,\r\nUI_METHOD *ui_method, void *callback_data)\r\n{\r\nEVP_PKEY *res = NULL;\r\nint ret=0;\r\nunsigned long el=0;\r\nchar *hptr=NULL;\r\nchar keytype=0;\r\nchar msg[64]="ENGINE_load_privkey";\r\nif(!p_surewarehk_Load_Privkey)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_LOAD_PRIVKEY,ENGINE_R_NOT_INITIALISED);\r\n}\r\nelse\r\n{\r\nret=p_surewarehk_Load_Privkey(msg,key_id,&hptr,&el,&keytype);\r\nif (ret!=1)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_LOAD_PRIVKEY,ENGINE_R_FAILED_LOADING_PRIVATE_KEY);\r\nERR_add_error_data(1,msg);\r\n}\r\nelse\r\nres=sureware_load_public(e,key_id,hptr,el,keytype);\r\n}\r\nreturn res;\r\n}\r\nstatic EVP_PKEY *surewarehk_load_pubkey(ENGINE *e, const char *key_id,\r\nUI_METHOD *ui_method, void *callback_data)\r\n{\r\nEVP_PKEY *res = NULL;\r\nint ret=0;\r\nunsigned long el=0;\r\nchar *hptr=NULL;\r\nchar keytype=0;\r\nchar msg[64]="ENGINE_load_pubkey";\r\nif(!p_surewarehk_Info_Pubkey)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_LOAD_PUBKEY,ENGINE_R_NOT_INITIALISED);\r\n}\r\nelse\r\n{\r\nret=p_surewarehk_Info_Pubkey(msg,key_id,&el,&keytype);\r\nif (ret!=1)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_LOAD_PUBKEY,ENGINE_R_FAILED_LOADING_PUBLIC_KEY);\r\nERR_add_error_data(1,msg);\r\n}\r\nelse\r\nres=sureware_load_public(e,key_id,hptr,el,keytype);\r\n}\r\nreturn res;\r\n}\r\nstatic void surewarehk_ex_free(void *obj, void *item, CRYPTO_EX_DATA *ad,\r\nint idx,long argl, void *argp)\r\n{\r\nif(!p_surewarehk_Free)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_EX_FREE,ENGINE_R_NOT_INITIALISED);\r\n}\r\nelse\r\np_surewarehk_Free((char *)item,0);\r\n}\r\nstatic int surewarehk_rsa_priv_dec(int flen,const unsigned char *from,unsigned char *to,\r\nRSA *rsa,int padding)\r\n{\r\nint ret=0,tlen;\r\nchar *buf=NULL,*hptr=NULL;\r\nchar msg[64]="ENGINE_rsa_priv_dec";\r\nif (!p_surewarehk_Rsa_Priv_Dec)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,ENGINE_R_NOT_INITIALISED);\r\n}\r\nelse if (!(hptr=RSA_get_ex_data(rsa, rsaHndidx)))\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,SUREWARE_R_MISSING_KEY_COMPONENTS);\r\ngoto err;\r\n}\r\nif (padding==RSA_PKCS1_PADDING)\r\n{\r\nret=p_surewarehk_Rsa_Priv_Dec(msg,flen,(unsigned char *)from,&tlen,to,hptr,SUREWARE_PKCS1_PAD);\r\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,ret);\r\nif (ret!=1)\r\ngoto err;\r\nret=tlen;\r\n}\r\nelse\r\n{\r\nret=p_surewarehk_Rsa_Priv_Dec(msg,flen,(unsigned char *)from,&tlen,to,hptr,SUREWARE_NO_PAD);\r\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,ret);\r\nif (ret!=1)\r\ngoto err;\r\nif ((buf=OPENSSL_malloc(tlen)) == NULL)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\nmemcpy(buf,to,tlen);\r\nswitch (padding)\r\n{\r\n#ifndef OPENSSL_NO_SHA\r\ncase RSA_PKCS1_OAEP_PADDING:\r\nret=RSA_padding_check_PKCS1_OAEP(to,tlen,(unsigned char *)buf,tlen,tlen,NULL,0);\r\nbreak;\r\n#endif\r\ncase RSA_SSLV23_PADDING:\r\nret=RSA_padding_check_SSLv23(to,tlen,(unsigned char *)buf,flen,tlen);\r\nbreak;\r\ncase RSA_NO_PADDING:\r\nret=RSA_padding_check_none(to,tlen,(unsigned char *)buf,flen,tlen);\r\nbreak;\r\ndefault:\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,SUREWARE_R_UNKNOWN_PADDING_TYPE);\r\ngoto err;\r\n}\r\nif (ret < 0)\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_PRIV_DEC,SUREWARE_R_PADDING_CHECK_FAILED);\r\n}\r\nerr:\r\nif (buf)\r\n{\r\nOPENSSL_cleanse(buf,tlen);\r\nOPENSSL_free(buf);\r\n}\r\nreturn ret;\r\n}\r\nstatic int surewarehk_rsa_sign(int flen,const unsigned char *from,unsigned char *to,\r\nRSA *rsa,int padding)\r\n{\r\nint ret=0,tlen;\r\nchar *hptr=NULL;\r\nchar msg[64]="ENGINE_rsa_sign";\r\nif (!p_surewarehk_Rsa_Sign)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_SIGN,ENGINE_R_NOT_INITIALISED);\r\n}\r\nelse if (!(hptr=RSA_get_ex_data(rsa, rsaHndidx)))\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_SIGN,SUREWARE_R_MISSING_KEY_COMPONENTS);\r\n}\r\nelse\r\n{\r\nswitch (padding)\r\n{\r\ncase RSA_PKCS1_PADDING:\r\nret=p_surewarehk_Rsa_Sign(msg,flen,(unsigned char *)from,&tlen,to,hptr,SUREWARE_PKCS1_PAD);\r\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_RSA_SIGN,ret);\r\nbreak;\r\ncase RSA_NO_PADDING:\r\ndefault:\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_RSA_SIGN,SUREWARE_R_UNKNOWN_PADDING_TYPE);\r\n}\r\n}\r\nreturn ret==1 ? tlen : ret;\r\n}\r\nstatic DSA_SIG * surewarehk_dsa_do_sign(const unsigned char *from, int flen, DSA *dsa)\r\n{\r\nint ret=0;\r\nchar *hptr=NULL;\r\nDSA_SIG *psign=NULL;\r\nchar msg[64]="ENGINE_dsa_do_sign";\r\nif (!p_surewarehk_Dsa_Sign)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_DSA_DO_SIGN,ENGINE_R_NOT_INITIALISED);\r\ngoto err;\r\n}\r\nelse if (!(hptr=DSA_get_ex_data(dsa, dsaHndidx)))\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_DSA_DO_SIGN,SUREWARE_R_MISSING_KEY_COMPONENTS);\r\ngoto err;\r\n}\r\nelse\r\n{\r\nif((psign = DSA_SIG_new()) == NULL)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_DSA_DO_SIGN,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\npsign->r=BN_new();\r\npsign->s=BN_new();\r\nbn_expand2(psign->r, 20/sizeof(BN_ULONG));\r\nbn_expand2(psign->s, 20/sizeof(BN_ULONG));\r\nif (!psign->r || psign->r->dmax!=20/sizeof(BN_ULONG) ||\r\n!psign->s || psign->s->dmax!=20/sizeof(BN_ULONG))\r\ngoto err;\r\nret=p_surewarehk_Dsa_Sign(msg,flen,from,\r\n(unsigned long *)psign->r->d,\r\n(unsigned long *)psign->s->d,\r\nhptr);\r\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_DSA_DO_SIGN,ret);\r\n}\r\npsign->r->top=20/sizeof(BN_ULONG);\r\nbn_fix_top(psign->r);\r\npsign->s->top=20/sizeof(BN_ULONG);\r\nbn_fix_top(psign->s);\r\nerr:\r\nif (psign)\r\n{\r\nDSA_SIG_free(psign);\r\npsign=NULL;\r\n}\r\nreturn psign;\r\n}\r\nstatic int surewarehk_modexp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\r\nconst BIGNUM *m, BN_CTX *ctx)\r\n{\r\nint ret=0;\r\nchar msg[64]="ENGINE_modexp";\r\nif (!p_surewarehk_Mod_Exp)\r\n{\r\nSUREWAREerr(SUREWARE_F_SUREWAREHK_MODEXP,ENGINE_R_NOT_INITIALISED);\r\n}\r\nelse\r\n{\r\nbn_expand2(r,m->top);\r\nif (r && r->dmax==m->top)\r\n{\r\nret=p_surewarehk_Mod_Exp(msg,\r\nm->top*sizeof(BN_ULONG),\r\n(unsigned long *)m->d,\r\np->top*sizeof(BN_ULONG),\r\n(unsigned long *)p->d,\r\na->top*sizeof(BN_ULONG),\r\n(unsigned long *)a->d,\r\n(unsigned long *)r->d);\r\nsurewarehk_error_handling(msg,SUREWARE_F_SUREWAREHK_MODEXP,ret);\r\nif (ret==1)\r\n{\r\nr->top=m->top;\r\nbn_fix_top(r);\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}
