int des_read_pw_string(char *buf, int length, const char *prompt,\r\nint verify)\r\n{\r\nchar buff[BUFSIZ];\r\nint ret;\r\nret=des_read_pw(buf,buff,(length>BUFSIZ)?BUFSIZ:length,prompt,verify);\r\nOPENSSL_cleanse(buff,BUFSIZ);\r\nreturn(ret);\r\n}\r\nint des_read_pw(char *buf, char *buff, int size, const char *prompt, int verify)\r\n{\r\nmemset(buf,0,size);\r\nmemset(buff,0,size);\r\nreturn(0);\r\n}\r\nint des_read_pw(char *buf, char *buff, int size, char *prompt, int verify)\r\n{\r\nmemset(buf,0,size);\r\nmemset(buff,0,size);\r\nreturn(0);\r\n}\r\nstatic void read_till_nl(FILE *in)\r\n{\r\n#define SIZE 4\r\nchar buf[SIZE+1];\r\ndo {\r\nfgets(buf,SIZE,in);\r\n} while (strchr(buf,'\n') == NULL);\r\n}\r\nint des_read_pw(char *buf, char *buff, int size, const char *prompt,\r\nint verify)\r\n{\r\n#ifdef OPENSSL_SYS_VMS\r\nstruct IOSB iosb;\r\n$DESCRIPTOR(terminal,"TT");\r\nlong tty_orig[3], tty_new[3];\r\nlong status;\r\nunsigned short channel = 0;\r\n#else\r\n#if !defined(OPENSSL_SYS_MSDOS) || defined(__DJGPP__)\r\nTTY_STRUCT tty_orig,tty_new;\r\n#endif\r\n#endif\r\nint number;\r\nint ok;\r\nstatic int ps;\r\nint is_a_tty;\r\nstatic FILE *tty;\r\nchar *p;\r\nif (setjmp(save))\r\n{\r\nok=0;\r\ngoto error;\r\n}\r\nnumber=5;\r\nok=0;\r\nps=0;\r\nis_a_tty=1;\r\ntty=NULL;\r\n#ifdef OPENSSL_SYS_MSDOS\r\nif ((tty=fopen("con","r")) == NULL)\r\ntty=stdin;\r\n#elif defined(MAC_OS_pre_X) || defined(OPENSSL_SYS_VXWORKS)\r\ntty=stdin;\r\n#else\r\n#ifndef OPENSSL_SYS_MPE\r\nif ((tty=fopen("/dev/tty","r")) == NULL)\r\n#endif\r\ntty=stdin;\r\n#endif\r\n#if defined(TTY_get) && !defined(OPENSSL_SYS_VMS)\r\nif (TTY_get(fileno(tty),&tty_orig) == -1)\r\n{\r\n#ifdef ENOTTY\r\nif (errno == ENOTTY)\r\nis_a_tty=0;\r\nelse\r\n#endif\r\n#ifdef EINVAL\r\nif (errno == EINVAL)\r\nis_a_tty=0;\r\nelse\r\n#endif\r\nreturn(-1);\r\n}\r\nmemcpy(&(tty_new),&(tty_orig),sizeof(tty_orig));\r\n#endif\r\n#ifdef OPENSSL_SYS_VMS\r\nstatus = sys$assign(&terminal,&channel,0,0);\r\nif (status != SS$_NORMAL)\r\nreturn(-1);\r\nstatus=sys$qiow(0,channel,IO$_SENSEMODE,&iosb,0,0,tty_orig,12,0,0,0,0);\r\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\r\nreturn(-1);\r\n#endif\r\npushsig();\r\nps=1;\r\n#ifdef TTY_FLAGS\r\ntty_new.TTY_FLAGS &= ~ECHO;\r\n#endif\r\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\r\nif (is_a_tty && (TTY_set(fileno(tty),&tty_new) == -1))\r\n#ifdef OPENSSL_SYS_MPE\r\n;\r\n#else\r\nreturn(-1);\r\n#endif\r\n#endif\r\n#ifdef OPENSSL_SYS_VMS\r\ntty_new[0] = tty_orig[0];\r\ntty_new[1] = tty_orig[1] | TT$M_NOECHO;\r\ntty_new[2] = tty_orig[2];\r\nstatus = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0,tty_new,12,0,0,0,0);\r\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\r\nreturn(-1);\r\n#endif\r\nps=2;\r\nwhile ((!ok) && (number--))\r\n{\r\nfputs(prompt,stderr);\r\nfflush(stderr);\r\nbuf[0]='\0';\r\nfgets(buf,size,tty);\r\nif (feof(tty)) goto error;\r\nif (ferror(tty)) goto error;\r\nif ((p=(char *)strchr(buf,'\n')) != NULL)\r\n*p='\0';\r\nelse read_till_nl(tty);\r\nif (verify)\r\n{\r\nfprintf(stderr,"\nVerifying password - %s",prompt);\r\nfflush(stderr);\r\nbuff[0]='\0';\r\nfgets(buff,size,tty);\r\nif (feof(tty)) goto error;\r\nif ((p=(char *)strchr(buff,'\n')) != NULL)\r\n*p='\0';\r\nelse read_till_nl(tty);\r\nif (strcmp(buf,buff) != 0)\r\n{\r\nfprintf(stderr,"\nVerify failure");\r\nfflush(stderr);\r\nbreak;\r\n}\r\n}\r\nok=1;\r\n}\r\nerror:\r\nfprintf(stderr,"\n");\r\n#if 0\r\nperror("fgets(tty)");\r\n#endif\r\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\r\nif (ps >= 2) TTY_set(fileno(tty),&tty_orig);\r\n#endif\r\n#ifdef OPENSSL_SYS_VMS\r\nif (ps >= 2)\r\nstatus = sys$qiow(0,channel,IO$_SETMODE,&iosb,0,0\r\n,tty_orig,12,0,0,0,0);\r\n#endif\r\nif (ps >= 1) popsig();\r\nif (stdin != tty) fclose(tty);\r\n#ifdef OPENSSL_SYS_VMS\r\nstatus = sys$dassgn(channel);\r\n#endif\r\nreturn(!ok);\r\n}\r\nstatic void pushsig(void)\r\n{\r\nint i;\r\n#ifdef SIGACTION\r\nstruct sigaction sa;\r\nmemset(&sa,0,sizeof sa);\r\nsa.sa_handler=recsig;\r\n#endif\r\nfor (i=1; i<NX509_SIG; i++)\r\n{\r\n#ifdef SIGUSR1\r\nif (i == SIGUSR1)\r\ncontinue;\r\n#endif\r\n#ifdef SIGUSR2\r\nif (i == SIGUSR2)\r\ncontinue;\r\n#endif\r\n#ifdef SIGACTION\r\nsigaction(i,&sa,&savsig[i]);\r\n#else\r\nsavsig[i]=signal(i,recsig);\r\n#endif\r\n}\r\n#ifdef SIGWINCH\r\nsignal(SIGWINCH,SIG_DFL);\r\n#endif\r\n}\r\nstatic void popsig(void)\r\n{\r\nint i;\r\nfor (i=1; i<NX509_SIG; i++)\r\n{\r\n#ifdef SIGUSR1\r\nif (i == SIGUSR1)\r\ncontinue;\r\n#endif\r\n#ifdef SIGUSR2\r\nif (i == SIGUSR2)\r\ncontinue;\r\n#endif\r\n#ifdef SIGACTION\r\nsigaction(i,&savsig[i],NULL);\r\n#else\r\nsignal(i,savsig[i]);\r\n#endif\r\n}\r\n}\r\nstatic void recsig(int i)\r\n{\r\nlongjmp(save,1);\r\n#ifdef LINT\r\ni=i;\r\n#endif\r\n}\r\nstatic int noecho_fgets(char *buf, int size, FILE *tty)\r\n{\r\nint i;\r\nchar *p;\r\np=buf;\r\nfor (;;)\r\n{\r\nif (size == 0)\r\n{\r\n*p='\0';\r\nbreak;\r\n}\r\nsize--;\r\n#ifdef WIN16TTY\r\ni=_inchar();\r\n#else\r\ni=getch();\r\n#endif\r\nif (i == '\r') i='\n';\r\n*(p++)=i;\r\nif (i == '\n')\r\n{\r\n*p='\0';\r\nbreak;\r\n}\r\n}\r\n#ifdef WIN_CONSOLE_BUG\r\n{\r\nHANDLE inh;\r\ninh = GetStdHandle(STD_INPUT_HANDLE);\r\nFlushConsoleInputBuffer(inh);\r\n}\r\n#endif\r\nreturn(strlen(buf));\r\n}
