const STORE_METHOD *STORE_Memory(void)\r\n{\r\nreturn &store_memory;\r\n}\r\nstatic int mem_init(STORE *s)\r\n{\r\nreturn 1;\r\n}\r\nstatic void mem_clean(STORE *s)\r\n{\r\nreturn;\r\n}\r\nstatic STORE_OBJECT *mem_generate(STORE *s, STORE_OBJECT_TYPES type,\r\nOPENSSL_ITEM attributes[], OPENSSL_ITEM parameters[])\r\n{\r\nSTOREerr(STORE_F_MEM_GENERATE, STORE_R_NOT_IMPLEMENTED);\r\nreturn 0;\r\n}\r\nstatic STORE_OBJECT *mem_get(STORE *s, STORE_OBJECT_TYPES type,\r\nOPENSSL_ITEM attributes[], OPENSSL_ITEM parameters[])\r\n{\r\nvoid *context = mem_list_start(s, type, attributes, parameters);\r\nif (context)\r\n{\r\nSTORE_OBJECT *object = mem_list_next(s, context);\r\nif (mem_list_end(s, context))\r\nreturn object;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mem_store(STORE *s, STORE_OBJECT_TYPES type,\r\nSTORE_OBJECT *data, OPENSSL_ITEM attributes[],\r\nOPENSSL_ITEM parameters[])\r\n{\r\nSTOREerr(STORE_F_MEM_STORE, STORE_R_NOT_IMPLEMENTED);\r\nreturn 0;\r\n}\r\nstatic int mem_modify(STORE *s, STORE_OBJECT_TYPES type,\r\nOPENSSL_ITEM search_attributes[], OPENSSL_ITEM add_attributes[],\r\nOPENSSL_ITEM modify_attributes[], OPENSSL_ITEM delete_attributes[],\r\nOPENSSL_ITEM parameters[])\r\n{\r\nSTOREerr(STORE_F_MEM_MODIFY, STORE_R_NOT_IMPLEMENTED);\r\nreturn 0;\r\n}\r\nstatic int mem_delete(STORE *s, STORE_OBJECT_TYPES type,\r\nOPENSSL_ITEM attributes[], OPENSSL_ITEM parameters[])\r\n{\r\nSTOREerr(STORE_F_MEM_DELETE, STORE_R_NOT_IMPLEMENTED);\r\nreturn 0;\r\n}\r\nstatic void *mem_list_start(STORE *s, STORE_OBJECT_TYPES type,\r\nOPENSSL_ITEM attributes[], OPENSSL_ITEM parameters[])\r\n{\r\nstruct mem_ctx_st *context =\r\n(struct mem_ctx_st *)OPENSSL_malloc(sizeof(struct mem_ctx_st));\r\nvoid *attribute_context = NULL;\r\nSTORE_ATTR_INFO *attrs = NULL;\r\nif (!context)\r\n{\r\nSTOREerr(STORE_F_MEM_LIST_START, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nmemset(context, 0, sizeof(struct mem_ctx_st));\r\nattribute_context = STORE_parse_attrs_start(attributes);\r\nif (!attribute_context)\r\n{\r\nSTOREerr(STORE_F_MEM_LIST_START, ERR_R_STORE_LIB);\r\ngoto err;\r\n}\r\nwhile((attrs = STORE_parse_attrs_next(attribute_context)))\r\n{\r\nif (context->search_attributes == NULL)\r\n{\r\ncontext->search_attributes =\r\nsk_STORE_ATTR_INFO_new(STORE_ATTR_INFO_compare);\r\nif (!context->search_attributes)\r\n{\r\nSTOREerr(STORE_F_MEM_LIST_START,\r\nERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\n}\r\nsk_STORE_ATTR_INFO_push(context->search_attributes,attrs);\r\n}\r\nif (!STORE_parse_attrs_endp(attribute_context))\r\ngoto err;\r\nSTORE_parse_attrs_end(attribute_context);\r\ncontext->search_index = -1;\r\ncontext->index = -1;\r\nreturn context;\r\nerr:\r\nif (attribute_context) STORE_parse_attrs_end(attribute_context);\r\nmem_list_end(s, context);\r\nreturn NULL;\r\n}\r\nstatic STORE_OBJECT *mem_list_next(STORE *s, void *handle)\r\n{\r\nint i;\r\nstruct mem_ctx_st *context = (struct mem_ctx_st *)handle;\r\nstruct mem_object_data_st key = { 0, 0, 1 };\r\nstruct mem_data_st *store =\r\n(struct mem_data_st *)STORE_get_ex_data(s, 1);\r\nint srch;\r\nint cres = 0;\r\nif (!context)\r\n{\r\nSTOREerr(STORE_F_MEM_LIST_NEXT, ERR_R_PASSED_NULL_PARAMETER);\r\nreturn NULL;\r\n}\r\nif (!store)\r\n{\r\nSTOREerr(STORE_F_MEM_LIST_NEXT, STORE_R_NO_STORE);\r\nreturn NULL;\r\n}\r\nif (context->search_index == -1)\r\n{\r\nfor (i = 0;\r\ni < sk_STORE_ATTR_INFO_num(context->search_attributes);\r\ni++)\r\n{\r\nkey.attr_info\r\n= sk_STORE_ATTR_INFO_value(context->search_attributes,\r\ni);\r\nsrch = sk_MEM_OBJECT_DATA_find_ex(store->data, &key);\r\nif (srch >= 0)\r\n{\r\ncontext->search_index = srch;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (context->search_index < 0)\r\nreturn NULL;\r\nkey.attr_info =\r\nsk_STORE_ATTR_INFO_value(context->search_attributes,\r\ncontext->search_index);\r\nfor(srch = context->search_index;\r\nsrch < sk_MEM_OBJECT_DATA_num(store->data)\r\n&& STORE_ATTR_INFO_in_range(key.attr_info,\r\nsk_MEM_OBJECT_DATA_value(store->data, srch)->attr_info)\r\n&& !(cres = STORE_ATTR_INFO_in_ex(key.attr_info,\r\nsk_MEM_OBJECT_DATA_value(store->data, srch)->attr_info));\r\nsrch++)\r\n;\r\ncontext->search_index = srch;\r\nif (cres)\r\nreturn (sk_MEM_OBJECT_DATA_value(store->data, srch))->object;\r\nreturn NULL;\r\n}\r\nstatic int mem_list_end(STORE *s, void *handle)\r\n{\r\nstruct mem_ctx_st *context = (struct mem_ctx_st *)handle;\r\nif (!context)\r\n{\r\nSTOREerr(STORE_F_MEM_LIST_END, ERR_R_PASSED_NULL_PARAMETER);\r\nreturn 0;\r\n}\r\nif (context && context->search_attributes)\r\nsk_STORE_ATTR_INFO_free(context->search_attributes);\r\nif (context) OPENSSL_free(context);\r\nreturn 1;\r\n}\r\nstatic int mem_list_endp(STORE *s, void *handle)\r\n{\r\nstruct mem_ctx_st *context = (struct mem_ctx_st *)handle;\r\nif (!context\r\n|| context->search_index\r\n== sk_STORE_ATTR_INFO_num(context->search_attributes))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mem_lock(STORE *s, OPENSSL_ITEM attributes[],\r\nOPENSSL_ITEM parameters[])\r\n{\r\nreturn 1;\r\n}\r\nstatic int mem_unlock(STORE *s, OPENSSL_ITEM attributes[],\r\nOPENSSL_ITEM parameters[])\r\n{\r\nreturn 1;\r\n}\r\nstatic int mem_ctrl(STORE *s, int cmd, long l, void *p, void (*f)(void))\r\n{\r\nreturn 1;\r\n}
