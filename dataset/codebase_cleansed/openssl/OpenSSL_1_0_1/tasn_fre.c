void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it)\r\n{\r\nasn1_item_combine_free(&val, it, 0);\r\n}\r\nvoid ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nasn1_item_combine_free(pval, it, 0);\r\n}\r\nstatic void asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it, int combine)\r\n{\r\nconst ASN1_TEMPLATE *tt = NULL, *seqtt;\r\nconst ASN1_EXTERN_FUNCS *ef;\r\nconst ASN1_COMPAT_FUNCS *cf;\r\nconst ASN1_AUX *aux = it->funcs;\r\nASN1_aux_cb *asn1_cb;\r\nint i;\r\nif (!pval)\r\nreturn;\r\nif ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)\r\nreturn;\r\nif (aux && aux->asn1_cb)\r\nasn1_cb = aux->asn1_cb;\r\nelse\r\nasn1_cb = 0;\r\nswitch(it->itype)\r\n{\r\ncase ASN1_ITYPE_PRIMITIVE:\r\nif (it->templates)\r\nASN1_template_free(pval, it->templates);\r\nelse\r\nASN1_primitive_free(pval, it);\r\nbreak;\r\ncase ASN1_ITYPE_MSTRING:\r\nASN1_primitive_free(pval, it);\r\nbreak;\r\ncase ASN1_ITYPE_CHOICE:\r\nif (asn1_cb)\r\n{\r\ni = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\r\nif (i == 2)\r\nreturn;\r\n}\r\ni = asn1_get_choice_selector(pval, it);\r\nif ((i >= 0) && (i < it->tcount))\r\n{\r\nASN1_VALUE **pchval;\r\ntt = it->templates + i;\r\npchval = asn1_get_field_ptr(pval, tt);\r\nASN1_template_free(pchval, tt);\r\n}\r\nif (asn1_cb)\r\nasn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\r\nif (!combine)\r\n{\r\nOPENSSL_free(*pval);\r\n*pval = NULL;\r\n}\r\nbreak;\r\ncase ASN1_ITYPE_COMPAT:\r\ncf = it->funcs;\r\nif (cf && cf->asn1_free)\r\ncf->asn1_free(*pval);\r\nbreak;\r\ncase ASN1_ITYPE_EXTERN:\r\nef = it->funcs;\r\nif (ef && ef->asn1_ex_free)\r\nef->asn1_ex_free(pval, it);\r\nbreak;\r\ncase ASN1_ITYPE_NDEF_SEQUENCE:\r\ncase ASN1_ITYPE_SEQUENCE:\r\nif (asn1_do_lock(pval, -1, it) > 0)\r\nreturn;\r\nif (asn1_cb)\r\n{\r\ni = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\r\nif (i == 2)\r\nreturn;\r\n}\r\nasn1_enc_free(pval, it);\r\ntt = it->templates + it->tcount - 1;\r\nfor (i = 0; i < it->tcount; tt--, i++)\r\n{\r\nASN1_VALUE **pseqval;\r\nseqtt = asn1_do_adb(pval, tt, 0);\r\nif (!seqtt)\r\ncontinue;\r\npseqval = asn1_get_field_ptr(pval, seqtt);\r\nASN1_template_free(pseqval, seqtt);\r\n}\r\nif (asn1_cb)\r\nasn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\r\nif (!combine)\r\n{\r\nOPENSSL_free(*pval);\r\n*pval = NULL;\r\n}\r\nbreak;\r\n}\r\n}\r\nvoid ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\r\n{\r\nint i;\r\nif (tt->flags & ASN1_TFLG_SK_MASK)\r\n{\r\nSTACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\r\nfor (i = 0; i < sk_ASN1_VALUE_num(sk); i++)\r\n{\r\nASN1_VALUE *vtmp;\r\nvtmp = sk_ASN1_VALUE_value(sk, i);\r\nasn1_item_combine_free(&vtmp, ASN1_ITEM_ptr(tt->item),\r\n0);\r\n}\r\nsk_ASN1_VALUE_free(sk);\r\n*pval = NULL;\r\n}\r\nelse\r\nasn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),\r\ntt->flags & ASN1_TFLG_COMBINE);\r\n}\r\nvoid ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nint utype;\r\nif (it)\r\n{\r\nconst ASN1_PRIMITIVE_FUNCS *pf;\r\npf = it->funcs;\r\nif (pf && pf->prim_free)\r\n{\r\npf->prim_free(pval, it);\r\nreturn;\r\n}\r\n}\r\nif (!it)\r\n{\r\nASN1_TYPE *typ = (ASN1_TYPE *)*pval;\r\nutype = typ->type;\r\npval = &typ->value.asn1_value;\r\nif (!*pval)\r\nreturn;\r\n}\r\nelse if (it->itype == ASN1_ITYPE_MSTRING)\r\n{\r\nutype = -1;\r\nif (!*pval)\r\nreturn;\r\n}\r\nelse\r\n{\r\nutype = it->utype;\r\nif ((utype != V_ASN1_BOOLEAN) && !*pval)\r\nreturn;\r\n}\r\nswitch(utype)\r\n{\r\ncase V_ASN1_OBJECT:\r\nASN1_OBJECT_free((ASN1_OBJECT *)*pval);\r\nbreak;\r\ncase V_ASN1_BOOLEAN:\r\nif (it)\r\n*(ASN1_BOOLEAN *)pval = it->size;\r\nelse\r\n*(ASN1_BOOLEAN *)pval = -1;\r\nreturn;\r\ncase V_ASN1_NULL:\r\nbreak;\r\ncase V_ASN1_ANY:\r\nASN1_primitive_free(pval, NULL);\r\nOPENSSL_free(*pval);\r\nbreak;\r\ndefault:\r\nASN1_STRING_free((ASN1_STRING *)*pval);\r\n*pval = NULL;\r\nbreak;\r\n}\r\n*pval = NULL;\r\n}
