BIO_METHOD *BIO_f_cipher(void)\r\n{\r\nreturn(&methods_enc);\r\n}\r\nstatic int enc_new(BIO *bi)\r\n{\r\nBIO_ENC_CTX *ctx;\r\nctx=(BIO_ENC_CTX *)OPENSSL_malloc(sizeof(BIO_ENC_CTX));\r\nif (ctx == NULL) return(0);\r\nEVP_CIPHER_CTX_init(&ctx->cipher);\r\nctx->buf_len=0;\r\nctx->buf_off=0;\r\nctx->cont=1;\r\nctx->finished=0;\r\nctx->ok=1;\r\nbi->init=0;\r\nbi->ptr=(char *)ctx;\r\nbi->flags=0;\r\nreturn(1);\r\n}\r\nstatic int enc_free(BIO *a)\r\n{\r\nBIO_ENC_CTX *b;\r\nif (a == NULL) return(0);\r\nb=(BIO_ENC_CTX *)a->ptr;\r\nEVP_CIPHER_CTX_cleanup(&(b->cipher));\r\nOPENSSL_cleanse(a->ptr,sizeof(BIO_ENC_CTX));\r\nOPENSSL_free(a->ptr);\r\na->ptr=NULL;\r\na->init=0;\r\na->flags=0;\r\nreturn(1);\r\n}\r\nstatic int enc_read(BIO *b, char *out, int outl)\r\n{\r\nint ret=0,i;\r\nBIO_ENC_CTX *ctx;\r\nif (out == NULL) return(0);\r\nctx=(BIO_ENC_CTX *)b->ptr;\r\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\r\nif (ctx->buf_len > 0)\r\n{\r\ni=ctx->buf_len-ctx->buf_off;\r\nif (i > outl) i=outl;\r\nmemcpy(out,&(ctx->buf[ctx->buf_off]),i);\r\nret=i;\r\nout+=i;\r\noutl-=i;\r\nctx->buf_off+=i;\r\nif (ctx->buf_len == ctx->buf_off)\r\n{\r\nctx->buf_len=0;\r\nctx->buf_off=0;\r\n}\r\n}\r\nwhile (outl > 0)\r\n{\r\nif (ctx->cont <= 0) break;\r\ni=BIO_read(b->next_bio,&(ctx->buf[BUF_OFFSET]),ENC_BLOCK_SIZE);\r\nif (i <= 0)\r\n{\r\nif (!BIO_should_retry(b->next_bio))\r\n{\r\nctx->cont=i;\r\ni=EVP_CipherFinal_ex(&(ctx->cipher),\r\n(unsigned char *)ctx->buf,\r\n&(ctx->buf_len));\r\nctx->ok=i;\r\nctx->buf_off=0;\r\n}\r\nelse\r\n{\r\nret=(ret == 0)?i:ret;\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nEVP_CipherUpdate(&(ctx->cipher),\r\n(unsigned char *)ctx->buf,&ctx->buf_len,\r\n(unsigned char *)&(ctx->buf[BUF_OFFSET]),i);\r\nctx->cont=1;\r\nif(ctx->buf_len == 0) continue;\r\n}\r\nif (ctx->buf_len <= outl)\r\ni=ctx->buf_len;\r\nelse\r\ni=outl;\r\nif (i <= 0) break;\r\nmemcpy(out,ctx->buf,i);\r\nret+=i;\r\nctx->buf_off=i;\r\noutl-=i;\r\nout+=i;\r\n}\r\nBIO_clear_retry_flags(b);\r\nBIO_copy_next_retry(b);\r\nreturn((ret == 0)?ctx->cont:ret);\r\n}\r\nstatic int enc_write(BIO *b, const char *in, int inl)\r\n{\r\nint ret=0,n,i;\r\nBIO_ENC_CTX *ctx;\r\nctx=(BIO_ENC_CTX *)b->ptr;\r\nret=inl;\r\nBIO_clear_retry_flags(b);\r\nn=ctx->buf_len-ctx->buf_off;\r\nwhile (n > 0)\r\n{\r\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\r\nif (i <= 0)\r\n{\r\nBIO_copy_next_retry(b);\r\nreturn(i);\r\n}\r\nctx->buf_off+=i;\r\nn-=i;\r\n}\r\nif ((in == NULL) || (inl <= 0)) return(0);\r\nctx->buf_off=0;\r\nwhile (inl > 0)\r\n{\r\nn=(inl > ENC_BLOCK_SIZE)?ENC_BLOCK_SIZE:inl;\r\nEVP_CipherUpdate(&(ctx->cipher),\r\n(unsigned char *)ctx->buf,&ctx->buf_len,\r\n(unsigned char *)in,n);\r\ninl-=n;\r\nin+=n;\r\nctx->buf_off=0;\r\nn=ctx->buf_len;\r\nwhile (n > 0)\r\n{\r\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\r\nif (i <= 0)\r\n{\r\nBIO_copy_next_retry(b);\r\nreturn (ret == inl) ? i : ret - inl;\r\n}\r\nn-=i;\r\nctx->buf_off+=i;\r\n}\r\nctx->buf_len=0;\r\nctx->buf_off=0;\r\n}\r\nBIO_copy_next_retry(b);\r\nreturn(ret);\r\n}\r\nstatic long enc_ctrl(BIO *b, int cmd, long num, void *ptr)\r\n{\r\nBIO *dbio;\r\nBIO_ENC_CTX *ctx,*dctx;\r\nlong ret=1;\r\nint i;\r\nEVP_CIPHER_CTX **c_ctx;\r\nctx=(BIO_ENC_CTX *)b->ptr;\r\nswitch (cmd)\r\n{\r\ncase BIO_CTRL_RESET:\r\nctx->ok=1;\r\nctx->finished=0;\r\nEVP_CipherInit_ex(&(ctx->cipher),NULL,NULL,NULL,NULL,\r\nctx->cipher.encrypt);\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_EOF:\r\nif (ctx->cont <= 0)\r\nret=1;\r\nelse\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_WPENDING:\r\nret=ctx->buf_len-ctx->buf_off;\r\nif (ret <= 0)\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_PENDING:\r\nret=ctx->buf_len-ctx->buf_off;\r\nif (ret <= 0)\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_FLUSH:\r\nagain:\r\nwhile (ctx->buf_len != ctx->buf_off)\r\n{\r\ni=enc_write(b,NULL,0);\r\nif (i < 0)\r\nreturn i;\r\n}\r\nif (!ctx->finished)\r\n{\r\nctx->finished=1;\r\nctx->buf_off=0;\r\nret=EVP_CipherFinal_ex(&(ctx->cipher),\r\n(unsigned char *)ctx->buf,\r\n&(ctx->buf_len));\r\nctx->ok=(int)ret;\r\nif (ret <= 0) break;\r\ngoto again;\r\n}\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_C_GET_CIPHER_STATUS:\r\nret=(long)ctx->ok;\r\nbreak;\r\ncase BIO_C_DO_STATE_MACHINE:\r\nBIO_clear_retry_flags(b);\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nBIO_copy_next_retry(b);\r\nbreak;\r\ncase BIO_C_GET_CIPHER_CTX:\r\nc_ctx=(EVP_CIPHER_CTX **)ptr;\r\n(*c_ctx)= &(ctx->cipher);\r\nb->init=1;\r\nbreak;\r\ncase BIO_CTRL_DUP:\r\ndbio=(BIO *)ptr;\r\ndctx=(BIO_ENC_CTX *)dbio->ptr;\r\nEVP_CIPHER_CTX_init(&dctx->cipher);\r\nret = EVP_CIPHER_CTX_copy(&dctx->cipher,&ctx->cipher);\r\nif (ret)\r\ndbio->init=1;\r\nbreak;\r\ndefault:\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic long enc_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\r\n{\r\nlong ret=1;\r\nif (b->next_bio == NULL) return(0);\r\nswitch (cmd)\r\n{\r\ndefault:\r\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nvoid BIO_set_cipher(BIO *b, const EVP_CIPHER *c, const unsigned char *k,\r\nconst unsigned char *i, int e)\r\n{\r\nBIO_ENC_CTX *ctx;\r\nif (b == NULL) return;\r\nif ((b->callback != NULL) &&\r\n(b->callback(b,BIO_CB_CTRL,(const char *)c,BIO_CTRL_SET,e,0L) <= 0))\r\nreturn;\r\nb->init=1;\r\nctx=(BIO_ENC_CTX *)b->ptr;\r\nEVP_CipherInit_ex(&(ctx->cipher),c,NULL, k,i,e);\r\nif (b->callback != NULL)\r\nb->callback(b,BIO_CB_CTRL,(const char *)c,BIO_CTRL_SET,e,1L);\r\n}
