void help()\r\n{\r\nfprintf(stderr,"gostsum [-bvt] [-c [file]]| [files]\n"\r\n"\t-c check message digests (default is generate)\n"\r\n"\t-v verbose, print file names when checking\n"\r\n"\t-b read files in binary mode\n"\r\n"\t-t use test GOST paramset (default is CryptoPro paramset)\n"\r\n"The input for -c should be the list of message digests and file names\n"\r\n"that is printed on stdout by this program when it generates digests.\n");\r\nexit(3);\r\n}\r\nint main(int argc,char **argv)\r\n{\r\nint c,i;\r\nint verbose=0;\r\nint errors=0;\r\nint open_mode = O_RDONLY;\r\ngost_subst_block *b= &GostR3411_94_CryptoProParamSet;\r\nFILE *check_file = NULL;\r\ngost_hash_ctx ctx;\r\nwhile( (c=getopt(argc,argv,"bc::tv"))!=-1)\r\n{\r\nswitch (c)\r\n{\r\ncase 'v': verbose=1; break;\r\ncase 't': b= &GostR3411_94_TestParamSet; break;\r\ncase 'b': open_mode |= O_BINARY; break;\r\ncase 'c':\r\nif (optarg)\r\n{\r\ncheck_file = fopen(optarg,"r");\r\nif (!check_file)\r\n{\r\nperror(optarg);\r\nexit(2);\r\n}\r\n}\r\nelse\r\n{\r\ncheck_file= stdin;\r\n}\r\nbreak;\r\ndefault:\r\nfprintf(stderr,"invalid option %c",optopt);\r\nhelp();\r\n}\r\n}\r\ninit_gost_hash_ctx(&ctx,b);\r\nif (check_file)\r\n{\r\nchar inhash[65],calcsum[65],filename[PATH_MAX];\r\nint failcount=0,count=0;;\r\nif (check_file==stdin && optind<argc)\r\n{\r\ncheck_file=fopen(argv[optind],"r");\r\nif (!check_file)\r\n{\r\nperror(argv[optind]);\r\nexit(2);\r\n}\r\n}\r\nwhile (get_line(check_file,inhash,filename))\r\n{\r\nif (!hash_file(&ctx,filename,calcsum,open_mode))\r\n{\r\nexit (2);\r\n}\r\ncount++;\r\nif (!strncmp(calcsum,inhash,65))\r\n{\r\nif (verbose)\r\n{\r\nfprintf(stderr,"%s\tOK\n",filename);\r\n}\r\n}\r\nelse\r\n{\r\nif (verbose)\r\n{\r\nfprintf(stderr,"%s\tFAILED\n",filename);\r\n}\r\nelse\r\n{\r\nfprintf(stderr,"%s: GOST hash sum check failed for '%s'\n",\r\nargv[0],filename);\r\n}\r\nfailcount++;\r\n}\r\n}\r\nif (verbose && failcount)\r\n{\r\nfprintf(stderr,"%s: %d of %d file(f) failed GOST hash sum check\n",\r\nargv[0],failcount,count);\r\n}\r\nexit (failcount?1:0);\r\n}\r\nif (optind==argc)\r\n{\r\nchar sum[65];\r\nif (!hash_stream(&ctx,fileno(stdin),sum))\r\n{\r\nperror("stdin");\r\nexit(1);\r\n}\r\nprintf("%s -\n",sum);\r\nexit(0);\r\n}\r\nfor (i=optind;i<argc;i++)\r\n{\r\nchar sum[65];\r\nif (!hash_file(&ctx,argv[i],sum,open_mode))\r\n{\r\nerrors++;\r\n}\r\nelse\r\n{\r\nprintf("%s %s\n",sum,argv[i]);\r\n}\r\n}\r\nexit(errors?1:0);\r\n}\r\nint hash_file(gost_hash_ctx *ctx,char *filename,char *sum,int mode)\r\n{\r\nint fd;\r\nif ((fd=open(filename,mode))<0)\r\n{\r\nperror(filename);\r\nreturn 0;\r\n}\r\nif (!hash_stream(ctx,fd,sum))\r\n{\r\nperror(filename);\r\nreturn 0;\r\n}\r\nclose(fd);\r\nreturn 1;\r\n}\r\nint hash_stream(gost_hash_ctx *ctx,int fd, char *sum)\r\n{\r\nunsigned char buffer[BUF_SIZE];\r\nssize_t bytes;\r\nint i;\r\nstart_hash(ctx);\r\nwhile ((bytes=read(fd,buffer,BUF_SIZE))>0)\r\n{\r\nhash_block(ctx,buffer,bytes);\r\n}\r\nif (bytes<0)\r\n{\r\nreturn 0;\r\n}\r\nfinish_hash(ctx,buffer);\r\nfor (i=0;i<32;i++)\r\n{\r\nsprintf(sum+2*i,"%02x",buffer[31-i]);\r\n}\r\nreturn 1;\r\n}\r\nint get_line(FILE *f,char *hash,char *filename)\r\n{\r\nint i;\r\nif (fread(hash,1,64,f)<64) return 0;\r\nhash[64]=0;\r\nfor (i=0;i<64;i++)\r\n{\r\nif (hash[i]<'0' || (hash[i]>'9' && hash[i]<'A') || (hash[i]>'F'\r\n&& hash[i]<'a')||hash[i]>'f')\r\n{\r\nfprintf(stderr,"Not a hash value '%s'\n",hash);\r\nreturn 0;\r\n}\r\n}\r\nif (fgetc(f)!=' ')\r\n{\r\nfprintf(stderr,"Malformed input line\n");\r\nreturn 0;\r\n}\r\ni=strlen(fgets(filename,PATH_MAX,f));\r\nwhile (filename[--i]=='\n'||filename[i]=='\r') filename[i]=0;\r\nreturn 1;\r\n}
