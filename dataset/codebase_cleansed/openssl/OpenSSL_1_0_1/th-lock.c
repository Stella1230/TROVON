void CRYPTO_thread_setup(void)\r\n{\r\nint i;\r\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(HANDLE));\r\nfor (i=0; i<CRYPTO_num_locks(); i++)\r\n{\r\nlock_cs[i]=CreateMutex(NULL,FALSE,NULL);\r\n}\r\nCRYPTO_set_locking_callback((void (*)(int,int,char *,int))win32_locking_callback);\r\nreturn(1);\r\n}\r\nstatic void CRYPTO_thread_cleanup(void)\r\n{\r\nint i;\r\nCRYPTO_set_locking_callback(NULL);\r\nfor (i=0; i<CRYPTO_num_locks(); i++)\r\nCloseHandle(lock_cs[i]);\r\nOPENSSL_free(lock_cs);\r\n}\r\nvoid win32_locking_callback(int mode, int type, char *file, int line)\r\n{\r\nif (mode & CRYPTO_LOCK)\r\n{\r\nWaitForSingleObject(lock_cs[type],INFINITE);\r\n}\r\nelse\r\n{\r\nReleaseMutex(lock_cs[type]);\r\n}\r\n}\r\nvoid CRYPTO_thread_setup(void)\r\n{\r\nint i;\r\n#ifdef USE_MUTEX\r\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(mutex_t));\r\n#else\r\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(rwlock_t));\r\n#endif\r\nlock_count=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));\r\nfor (i=0; i<CRYPTO_num_locks(); i++)\r\n{\r\nlock_count[i]=0;\r\n#ifdef USE_MUTEX\r\nmutex_init(&(lock_cs[i]),USYNC_THREAD,NULL);\r\n#else\r\nrwlock_init(&(lock_cs[i]),USYNC_THREAD,NULL);\r\n#endif\r\n}\r\nCRYPTO_set_id_callback((unsigned long (*)())solaris_thread_id);\r\nCRYPTO_set_locking_callback((void (*)())solaris_locking_callback);\r\n}\r\nvoid CRYPTO_thread_cleanup(void)\r\n{\r\nint i;\r\nCRYPTO_set_locking_callback(NULL);\r\nfor (i=0; i<CRYPTO_num_locks(); i++)\r\n{\r\n#ifdef USE_MUTEX\r\nmutex_destroy(&(lock_cs[i]));\r\n#else\r\nrwlock_destroy(&(lock_cs[i]));\r\n#endif\r\n}\r\nOPENSSL_free(lock_cs);\r\nOPENSSL_free(lock_count);\r\n}\r\nvoid solaris_locking_callback(int mode, int type, char *file, int line)\r\n{\r\n#if 0\r\nfprintf(stderr,"thread=%4d mode=%s lock=%s %s:%d\n",\r\nCRYPTO_thread_id(),\r\n(mode&CRYPTO_LOCK)?"l":"u",\r\n(type&CRYPTO_READ)?"r":"w",file,line);\r\n#endif\r\n#if 0\r\nif (CRYPTO_LOCK_SSL_CERT == type)\r\nfprintf(stderr,"(t,m,f,l) %ld %d %s %d\n",\r\nCRYPTO_thread_id(),\r\nmode,file,line);\r\n#endif\r\nif (mode & CRYPTO_LOCK)\r\n{\r\n#ifdef USE_MUTEX\r\nmutex_lock(&(lock_cs[type]));\r\n#else\r\nif (mode & CRYPTO_READ)\r\nrw_rdlock(&(lock_cs[type]));\r\nelse\r\nrw_wrlock(&(lock_cs[type]));\r\n#endif\r\nlock_count[type]++;\r\n}\r\nelse\r\n{\r\n#ifdef USE_MUTEX\r\nmutex_unlock(&(lock_cs[type]));\r\n#else\r\nrw_unlock(&(lock_cs[type]));\r\n#endif\r\n}\r\n}\r\nunsigned long solaris_thread_id(void)\r\n{\r\nunsigned long ret;\r\nret=(unsigned long)thr_self();\r\nreturn(ret);\r\n}\r\nvoid CRYPTO_thread_setup(void)\r\n{\r\nint i;\r\nchar filename[20];\r\nstrcpy(filename,"/tmp/mttest.XXXXXX");\r\nmktemp(filename);\r\nusconfig(CONF_STHREADIOOFF);\r\nusconfig(CONF_STHREADMALLOCOFF);\r\nusconfig(CONF_INITUSERS,100);\r\nusconfig(CONF_LOCKTYPE,US_DEBUGPLUS);\r\narena=usinit(filename);\r\nunlink(filename);\r\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(usema_t *));\r\nfor (i=0; i<CRYPTO_num_locks(); i++)\r\n{\r\nlock_cs[i]=usnewsema(arena,1);\r\n}\r\nCRYPTO_set_id_callback((unsigned long (*)())irix_thread_id);\r\nCRYPTO_set_locking_callback((void (*)())irix_locking_callback);\r\n}\r\nvoid CRYPTO_thread_cleanup(void)\r\n{\r\nint i;\r\nCRYPTO_set_locking_callback(NULL);\r\nfor (i=0; i<CRYPTO_num_locks(); i++)\r\n{\r\nchar buf[10];\r\nsprintf(buf,"%2d:",i);\r\nusdumpsema(lock_cs[i],stdout,buf);\r\nusfreesema(lock_cs[i],arena);\r\n}\r\nOPENSSL_free(lock_cs);\r\n}\r\nvoid irix_locking_callback(int mode, int type, char *file, int line)\r\n{\r\nif (mode & CRYPTO_LOCK)\r\n{\r\nuspsema(lock_cs[type]);\r\n}\r\nelse\r\n{\r\nusvsema(lock_cs[type]);\r\n}\r\n}\r\nunsigned long irix_thread_id(void)\r\n{\r\nunsigned long ret;\r\nret=(unsigned long)getpid();\r\nreturn(ret);\r\n}\r\nvoid CRYPTO_thread_setup(void)\r\n{\r\nint i;\r\nlock_cs=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(pthread_mutex_t));\r\nlock_count=OPENSSL_malloc(CRYPTO_num_locks() * sizeof(long));\r\nfor (i=0; i<CRYPTO_num_locks(); i++)\r\n{\r\nlock_count[i]=0;\r\npthread_mutex_init(&(lock_cs[i]),NULL);\r\n}\r\nCRYPTO_set_id_callback((unsigned long (*)())pthreads_thread_id);\r\nCRYPTO_set_locking_callback((void (*)())pthreads_locking_callback);\r\n}\r\nvoid thread_cleanup(void)\r\n{\r\nint i;\r\nCRYPTO_set_locking_callback(NULL);\r\nfor (i=0; i<CRYPTO_num_locks(); i++)\r\n{\r\npthread_mutex_destroy(&(lock_cs[i]));\r\n}\r\nOPENSSL_free(lock_cs);\r\nOPENSSL_free(lock_count);\r\n}\r\nvoid pthreads_locking_callback(int mode, int type, char *file,\r\nint line)\r\n{\r\n#if 0\r\nfprintf(stderr,"thread=%4d mode=%s lock=%s %s:%d\n",\r\nCRYPTO_thread_id(),\r\n(mode&CRYPTO_LOCK)?"l":"u",\r\n(type&CRYPTO_READ)?"r":"w",file,line);\r\n#endif\r\n#if 0\r\nif (CRYPTO_LOCK_SSL_CERT == type)\r\nfprintf(stderr,"(t,m,f,l) %ld %d %s %d\n",\r\nCRYPTO_thread_id(),\r\nmode,file,line);\r\n#endif\r\nif (mode & CRYPTO_LOCK)\r\n{\r\npthread_mutex_lock(&(lock_cs[type]));\r\nlock_count[type]++;\r\n}\r\nelse\r\n{\r\npthread_mutex_unlock(&(lock_cs[type]));\r\n}\r\n}\r\nunsigned long pthreads_thread_id(void)\r\n{\r\nunsigned long ret;\r\nret=(unsigned long)pthread_self();\r\nreturn(ret);\r\n}
