char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\r\n{\r\nX509_NAME_ENTRY *ne;\r\nint i;\r\nint n,lold,l,l1,l2,num,j,type;\r\nconst char *s;\r\nchar *p;\r\nunsigned char *q;\r\nBUF_MEM *b=NULL;\r\nstatic const char hex[17]="0123456789ABCDEF";\r\nint gs_doit[4];\r\nchar tmp_buf[80];\r\n#ifdef CHARSET_EBCDIC\r\nchar ebcdic_buf[1024];\r\n#endif\r\nif (buf == NULL)\r\n{\r\nif ((b=BUF_MEM_new()) == NULL) goto err;\r\nif (!BUF_MEM_grow(b,200)) goto err;\r\nb->data[0]='\0';\r\nlen=200;\r\n}\r\nif (a == NULL)\r\n{\r\nif(b)\r\n{\r\nbuf=b->data;\r\nOPENSSL_free(b);\r\n}\r\nstrncpy(buf,"NO X509_NAME",len);\r\nbuf[len-1]='\0';\r\nreturn buf;\r\n}\r\nlen--;\r\nl=0;\r\nfor (i=0; i<sk_X509_NAME_ENTRY_num(a->entries); i++)\r\n{\r\nne=sk_X509_NAME_ENTRY_value(a->entries,i);\r\nn=OBJ_obj2nid(ne->object);\r\nif ((n == NID_undef) || ((s=OBJ_nid2sn(n)) == NULL))\r\n{\r\ni2t_ASN1_OBJECT(tmp_buf,sizeof(tmp_buf),ne->object);\r\ns=tmp_buf;\r\n}\r\nl1=strlen(s);\r\ntype=ne->value->type;\r\nnum=ne->value->length;\r\nq=ne->value->data;\r\n#ifdef CHARSET_EBCDIC\r\nif (type == V_ASN1_GENERALSTRING ||\r\ntype == V_ASN1_VISIBLESTRING ||\r\ntype == V_ASN1_PRINTABLESTRING ||\r\ntype == V_ASN1_TELETEXSTRING ||\r\ntype == V_ASN1_VISIBLESTRING ||\r\ntype == V_ASN1_IA5STRING) {\r\nascii2ebcdic(ebcdic_buf, q,\r\n(num > sizeof ebcdic_buf)\r\n? sizeof ebcdic_buf : num);\r\nq=ebcdic_buf;\r\n}\r\n#endif\r\nif ((type == V_ASN1_GENERALSTRING) && ((num%4) == 0))\r\n{\r\ngs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=0;\r\nfor (j=0; j<num; j++)\r\nif (q[j] != 0) gs_doit[j&3]=1;\r\nif (gs_doit[0]|gs_doit[1]|gs_doit[2])\r\ngs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\r\nelse\r\n{\r\ngs_doit[0]=gs_doit[1]=gs_doit[2]=0;\r\ngs_doit[3]=1;\r\n}\r\n}\r\nelse\r\ngs_doit[0]=gs_doit[1]=gs_doit[2]=gs_doit[3]=1;\r\nfor (l2=j=0; j<num; j++)\r\n{\r\nif (!gs_doit[j&3]) continue;\r\nl2++;\r\n#ifndef CHARSET_EBCDIC\r\nif ((q[j] < ' ') || (q[j] > '~')) l2+=3;\r\n#else\r\nif ((os_toascii[q[j]] < os_toascii[' ']) ||\r\n(os_toascii[q[j]] > os_toascii['~'])) l2+=3;\r\n#endif\r\n}\r\nlold=l;\r\nl+=1+l1+1+l2;\r\nif (b != NULL)\r\n{\r\nif (!BUF_MEM_grow(b,l+1)) goto err;\r\np= &(b->data[lold]);\r\n}\r\nelse if (l > len)\r\n{\r\nbreak;\r\n}\r\nelse\r\np= &(buf[lold]);\r\n*(p++)='/';\r\nmemcpy(p,s,(unsigned int)l1); p+=l1;\r\n*(p++)='=';\r\n#ifndef CHARSET_EBCDIC\r\nq=ne->value->data;\r\n#endif\r\nfor (j=0; j<num; j++)\r\n{\r\nif (!gs_doit[j&3]) continue;\r\n#ifndef CHARSET_EBCDIC\r\nn=q[j];\r\nif ((n < ' ') || (n > '~'))\r\n{\r\n*(p++)='\\';\r\n*(p++)='x';\r\n*(p++)=hex[(n>>4)&0x0f];\r\n*(p++)=hex[n&0x0f];\r\n}\r\nelse\r\n*(p++)=n;\r\n#else\r\nn=os_toascii[q[j]];\r\nif ((n < os_toascii[' ']) ||\r\n(n > os_toascii['~']))\r\n{\r\n*(p++)='\\';\r\n*(p++)='x';\r\n*(p++)=hex[(n>>4)&0x0f];\r\n*(p++)=hex[n&0x0f];\r\n}\r\nelse\r\n*(p++)=q[j];\r\n#endif\r\n}\r\n*p='\0';\r\n}\r\nif (b != NULL)\r\n{\r\np=b->data;\r\nOPENSSL_free(b);\r\n}\r\nelse\r\np=buf;\r\nif (i == 0)\r\n*p = '\0';\r\nreturn(p);\r\nerr:\r\nX509err(X509_F_X509_NAME_ONELINE,ERR_R_MALLOC_FAILURE);\r\nif (b != NULL) BUF_MEM_free(b);\r\nreturn(NULL);\r\n}
