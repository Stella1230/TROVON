ENGINE *ENGINE_new(void)\r\n{\r\nENGINE *ret;\r\nret = (ENGINE *)OPENSSL_malloc(sizeof(ENGINE));\r\nif(ret == NULL)\r\n{\r\nENGINEerr(ENGINE_F_ENGINE_NEW, ERR_R_MALLOC_FAILURE);\r\nreturn NULL;\r\n}\r\nmemset(ret, 0, sizeof(ENGINE));\r\nret->struct_ref = 1;\r\nengine_ref_debug(ret, 0, 1)\r\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_ENGINE, ret, &ret->ex_data);\r\nreturn ret;\r\n}\r\nvoid engine_set_all_null(ENGINE *e)\r\n{\r\ne->id = NULL;\r\ne->name = NULL;\r\ne->rsa_meth = NULL;\r\ne->dsa_meth = NULL;\r\ne->dh_meth = NULL;\r\ne->rand_meth = NULL;\r\ne->store_meth = NULL;\r\ne->ciphers = NULL;\r\ne->digests = NULL;\r\ne->destroy = NULL;\r\ne->init = NULL;\r\ne->finish = NULL;\r\ne->ctrl = NULL;\r\ne->load_privkey = NULL;\r\ne->load_pubkey = NULL;\r\ne->cmd_defns = NULL;\r\ne->flags = 0;\r\n}\r\nint engine_free_util(ENGINE *e, int locked)\r\n{\r\nint i;\r\nif(e == NULL)\r\n{\r\nENGINEerr(ENGINE_F_ENGINE_FREE_UTIL,\r\nERR_R_PASSED_NULL_PARAMETER);\r\nreturn 0;\r\n}\r\nif(locked)\r\ni = CRYPTO_add(&e->struct_ref,-1,CRYPTO_LOCK_ENGINE);\r\nelse\r\ni = --e->struct_ref;\r\nengine_ref_debug(e, 0, -1)\r\nif (i > 0) return 1;\r\n#ifdef REF_CHECK\r\nif (i < 0)\r\n{\r\nfprintf(stderr,"ENGINE_free, bad structural reference count\n");\r\nabort();\r\n}\r\n#endif\r\nengine_pkey_meths_free(e);\r\nengine_pkey_asn1_meths_free(e);\r\nif(e->destroy)\r\ne->destroy(e);\r\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_ENGINE, e, &e->ex_data);\r\nOPENSSL_free(e);\r\nreturn 1;\r\n}\r\nint ENGINE_free(ENGINE *e)\r\n{\r\nreturn engine_free_util(e, 1);\r\n}\r\nstatic int int_cleanup_check(int create)\r\n{\r\nif(cleanup_stack) return 1;\r\nif(!create) return 0;\r\ncleanup_stack = sk_ENGINE_CLEANUP_ITEM_new_null();\r\nreturn (cleanup_stack ? 1 : 0);\r\n}\r\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\r\n{\r\nENGINE_CLEANUP_ITEM *item = OPENSSL_malloc(sizeof(\r\nENGINE_CLEANUP_ITEM));\r\nif(!item) return NULL;\r\nitem->cb = cb;\r\nreturn item;\r\n}\r\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\r\n{\r\nENGINE_CLEANUP_ITEM *item;\r\nif(!int_cleanup_check(1)) return;\r\nitem = int_cleanup_item(cb);\r\nif(item)\r\nsk_ENGINE_CLEANUP_ITEM_insert(cleanup_stack, item, 0);\r\n}\r\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\r\n{\r\nENGINE_CLEANUP_ITEM *item;\r\nif(!int_cleanup_check(1)) return;\r\nitem = int_cleanup_item(cb);\r\nif(item)\r\nsk_ENGINE_CLEANUP_ITEM_push(cleanup_stack, item);\r\n}\r\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\r\n{\r\n(*(item->cb))();\r\nOPENSSL_free(item);\r\n}\r\nvoid ENGINE_cleanup(void)\r\n{\r\nif(int_cleanup_check(0))\r\n{\r\nsk_ENGINE_CLEANUP_ITEM_pop_free(cleanup_stack,\r\nengine_cleanup_cb_free);\r\ncleanup_stack = NULL;\r\n}\r\nRAND_set_rand_method(NULL);\r\n}\r\nint ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\r\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\r\n{\r\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_ENGINE, argl, argp,\r\nnew_func, dup_func, free_func);\r\n}\r\nint ENGINE_set_ex_data(ENGINE *e, int idx, void *arg)\r\n{\r\nreturn(CRYPTO_set_ex_data(&e->ex_data, idx, arg));\r\n}\r\nvoid *ENGINE_get_ex_data(const ENGINE *e, int idx)\r\n{\r\nreturn(CRYPTO_get_ex_data(&e->ex_data, idx));\r\n}\r\nint ENGINE_set_id(ENGINE *e, const char *id)\r\n{\r\nif(id == NULL)\r\n{\r\nENGINEerr(ENGINE_F_ENGINE_SET_ID,\r\nERR_R_PASSED_NULL_PARAMETER);\r\nreturn 0;\r\n}\r\ne->id = id;\r\nreturn 1;\r\n}\r\nint ENGINE_set_name(ENGINE *e, const char *name)\r\n{\r\nif(name == NULL)\r\n{\r\nENGINEerr(ENGINE_F_ENGINE_SET_NAME,\r\nERR_R_PASSED_NULL_PARAMETER);\r\nreturn 0;\r\n}\r\ne->name = name;\r\nreturn 1;\r\n}\r\nint ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f)\r\n{\r\ne->destroy = destroy_f;\r\nreturn 1;\r\n}\r\nint ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f)\r\n{\r\ne->init = init_f;\r\nreturn 1;\r\n}\r\nint ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f)\r\n{\r\ne->finish = finish_f;\r\nreturn 1;\r\n}\r\nint ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f)\r\n{\r\ne->ctrl = ctrl_f;\r\nreturn 1;\r\n}\r\nint ENGINE_set_flags(ENGINE *e, int flags)\r\n{\r\ne->flags = flags;\r\nreturn 1;\r\n}\r\nint ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns)\r\n{\r\ne->cmd_defns = defns;\r\nreturn 1;\r\n}\r\nconst char *ENGINE_get_id(const ENGINE *e)\r\n{\r\nreturn e->id;\r\n}\r\nconst char *ENGINE_get_name(const ENGINE *e)\r\n{\r\nreturn e->name;\r\n}\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\r\n{\r\nreturn e->destroy;\r\n}\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\r\n{\r\nreturn e->init;\r\n}\r\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\r\n{\r\nreturn e->finish;\r\n}\r\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\r\n{\r\nreturn e->ctrl;\r\n}\r\nint ENGINE_get_flags(const ENGINE *e)\r\n{\r\nreturn e->flags;\r\n}\r\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\r\n{\r\nreturn e->cmd_defns;\r\n}\r\nvoid *ENGINE_get_static_state(void)\r\n{\r\nreturn &internal_static_hack;\r\n}
