ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it)\r\n{\r\nASN1_VALUE *ret = NULL;\r\nif (ASN1_item_ex_new(&ret, it) > 0)\r\nreturn ret;\r\nreturn NULL;\r\n}\r\nint ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nreturn asn1_item_ex_combine_new(pval, it, 0);\r\n}\r\nstatic int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,\r\nint combine)\r\n{\r\nconst ASN1_TEMPLATE *tt = NULL;\r\nconst ASN1_COMPAT_FUNCS *cf;\r\nconst ASN1_EXTERN_FUNCS *ef;\r\nconst ASN1_AUX *aux = it->funcs;\r\nASN1_aux_cb *asn1_cb;\r\nASN1_VALUE **pseqval;\r\nint i;\r\nif (aux && aux->asn1_cb)\r\nasn1_cb = aux->asn1_cb;\r\nelse\r\nasn1_cb = 0;\r\nif (!combine) *pval = NULL;\r\n#ifdef CRYPTO_MDEBUG\r\nif (it->sname)\r\nCRYPTO_push_info(it->sname);\r\n#endif\r\nswitch(it->itype)\r\n{\r\ncase ASN1_ITYPE_EXTERN:\r\nef = it->funcs;\r\nif (ef && ef->asn1_ex_new)\r\n{\r\nif (!ef->asn1_ex_new(pval, it))\r\ngoto memerr;\r\n}\r\nbreak;\r\ncase ASN1_ITYPE_COMPAT:\r\ncf = it->funcs;\r\nif (cf && cf->asn1_new) {\r\n*pval = cf->asn1_new();\r\nif (!*pval)\r\ngoto memerr;\r\n}\r\nbreak;\r\ncase ASN1_ITYPE_PRIMITIVE:\r\nif (it->templates)\r\n{\r\nif (!ASN1_template_new(pval, it->templates))\r\ngoto memerr;\r\n}\r\nelse if (!ASN1_primitive_new(pval, it))\r\ngoto memerr;\r\nbreak;\r\ncase ASN1_ITYPE_MSTRING:\r\nif (!ASN1_primitive_new(pval, it))\r\ngoto memerr;\r\nbreak;\r\ncase ASN1_ITYPE_CHOICE:\r\nif (asn1_cb)\r\n{\r\ni = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);\r\nif (!i)\r\ngoto auxerr;\r\nif (i==2)\r\n{\r\n#ifdef CRYPTO_MDEBUG\r\nif (it->sname)\r\nCRYPTO_pop_info();\r\n#endif\r\nreturn 1;\r\n}\r\n}\r\nif (!combine)\r\n{\r\n*pval = OPENSSL_malloc(it->size);\r\nif (!*pval)\r\ngoto memerr;\r\nmemset(*pval, 0, it->size);\r\n}\r\nasn1_set_choice_selector(pval, -1, it);\r\nif (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL))\r\ngoto auxerr;\r\nbreak;\r\ncase ASN1_ITYPE_NDEF_SEQUENCE:\r\ncase ASN1_ITYPE_SEQUENCE:\r\nif (asn1_cb)\r\n{\r\ni = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);\r\nif (!i)\r\ngoto auxerr;\r\nif (i==2)\r\n{\r\n#ifdef CRYPTO_MDEBUG\r\nif (it->sname)\r\nCRYPTO_pop_info();\r\n#endif\r\nreturn 1;\r\n}\r\n}\r\nif (!combine)\r\n{\r\n*pval = OPENSSL_malloc(it->size);\r\nif (!*pval)\r\ngoto memerr;\r\nmemset(*pval, 0, it->size);\r\nasn1_do_lock(pval, 0, it);\r\nasn1_enc_init(pval, it);\r\n}\r\nfor (i = 0, tt = it->templates; i < it->tcount; tt++, i++)\r\n{\r\npseqval = asn1_get_field_ptr(pval, tt);\r\nif (!ASN1_template_new(pseqval, tt))\r\ngoto memerr;\r\n}\r\nif (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL))\r\ngoto auxerr;\r\nbreak;\r\n}\r\n#ifdef CRYPTO_MDEBUG\r\nif (it->sname) CRYPTO_pop_info();\r\n#endif\r\nreturn 1;\r\nmemerr:\r\nASN1err(ASN1_F_ASN1_ITEM_EX_COMBINE_NEW, ERR_R_MALLOC_FAILURE);\r\n#ifdef CRYPTO_MDEBUG\r\nif (it->sname) CRYPTO_pop_info();\r\n#endif\r\nreturn 0;\r\nauxerr:\r\nASN1err(ASN1_F_ASN1_ITEM_EX_COMBINE_NEW, ASN1_R_AUX_ERROR);\r\nASN1_item_ex_free(pval, it);\r\n#ifdef CRYPTO_MDEBUG\r\nif (it->sname) CRYPTO_pop_info();\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nconst ASN1_EXTERN_FUNCS *ef;\r\nswitch(it->itype)\r\n{\r\ncase ASN1_ITYPE_EXTERN:\r\nef = it->funcs;\r\nif (ef && ef->asn1_ex_clear)\r\nef->asn1_ex_clear(pval, it);\r\nelse *pval = NULL;\r\nbreak;\r\ncase ASN1_ITYPE_PRIMITIVE:\r\nif (it->templates)\r\nasn1_template_clear(pval, it->templates);\r\nelse\r\nasn1_primitive_clear(pval, it);\r\nbreak;\r\ncase ASN1_ITYPE_MSTRING:\r\nasn1_primitive_clear(pval, it);\r\nbreak;\r\ncase ASN1_ITYPE_COMPAT:\r\ncase ASN1_ITYPE_CHOICE:\r\ncase ASN1_ITYPE_SEQUENCE:\r\ncase ASN1_ITYPE_NDEF_SEQUENCE:\r\n*pval = NULL;\r\nbreak;\r\n}\r\n}\r\nint ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\r\n{\r\nconst ASN1_ITEM *it = ASN1_ITEM_ptr(tt->item);\r\nint ret;\r\nif (tt->flags & ASN1_TFLG_OPTIONAL)\r\n{\r\nasn1_template_clear(pval, tt);\r\nreturn 1;\r\n}\r\nif (tt->flags & ASN1_TFLG_ADB_MASK)\r\n{\r\n*pval = NULL;\r\nreturn 1;\r\n}\r\n#ifdef CRYPTO_MDEBUG\r\nif (tt->field_name)\r\nCRYPTO_push_info(tt->field_name);\r\n#endif\r\nif (tt->flags & ASN1_TFLG_SK_MASK)\r\n{\r\nSTACK_OF(ASN1_VALUE) *skval;\r\nskval = sk_ASN1_VALUE_new_null();\r\nif (!skval)\r\n{\r\nASN1err(ASN1_F_ASN1_TEMPLATE_NEW, ERR_R_MALLOC_FAILURE);\r\nret = 0;\r\ngoto done;\r\n}\r\n*pval = (ASN1_VALUE *)skval;\r\nret = 1;\r\ngoto done;\r\n}\r\nret = asn1_item_ex_combine_new(pval, it, tt->flags & ASN1_TFLG_COMBINE);\r\ndone:\r\n#ifdef CRYPTO_MDEBUG\r\nif (it->sname)\r\nCRYPTO_pop_info();\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\r\n{\r\nif (tt->flags & (ASN1_TFLG_ADB_MASK|ASN1_TFLG_SK_MASK))\r\n*pval = NULL;\r\nelse\r\nasn1_item_clear(pval, ASN1_ITEM_ptr(tt->item));\r\n}\r\nint ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nASN1_TYPE *typ;\r\nASN1_STRING *str;\r\nint utype;\r\nif (it && it->funcs)\r\n{\r\nconst ASN1_PRIMITIVE_FUNCS *pf = it->funcs;\r\nif (pf->prim_new)\r\nreturn pf->prim_new(pval, it);\r\n}\r\nif (!it || (it->itype == ASN1_ITYPE_MSTRING))\r\nutype = -1;\r\nelse\r\nutype = it->utype;\r\nswitch(utype)\r\n{\r\ncase V_ASN1_OBJECT:\r\n*pval = (ASN1_VALUE *)OBJ_nid2obj(NID_undef);\r\nreturn 1;\r\ncase V_ASN1_BOOLEAN:\r\n*(ASN1_BOOLEAN *)pval = it->size;\r\nreturn 1;\r\ncase V_ASN1_NULL:\r\n*pval = (ASN1_VALUE *)1;\r\nreturn 1;\r\ncase V_ASN1_ANY:\r\ntyp = OPENSSL_malloc(sizeof(ASN1_TYPE));\r\nif (!typ)\r\nreturn 0;\r\ntyp->value.ptr = NULL;\r\ntyp->type = -1;\r\n*pval = (ASN1_VALUE *)typ;\r\nbreak;\r\ndefault:\r\nstr = ASN1_STRING_type_new(utype);\r\nif (it->itype == ASN1_ITYPE_MSTRING && str)\r\nstr->flags |= ASN1_STRING_FLAG_MSTRING;\r\n*pval = (ASN1_VALUE *)str;\r\nbreak;\r\n}\r\nif (*pval)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it)\r\n{\r\nint utype;\r\nif (it && it->funcs)\r\n{\r\nconst ASN1_PRIMITIVE_FUNCS *pf = it->funcs;\r\nif (pf->prim_clear)\r\npf->prim_clear(pval, it);\r\nelse\r\n*pval = NULL;\r\nreturn;\r\n}\r\nif (!it || (it->itype == ASN1_ITYPE_MSTRING))\r\nutype = -1;\r\nelse\r\nutype = it->utype;\r\nif (utype == V_ASN1_BOOLEAN)\r\n*(ASN1_BOOLEAN *)pval = it->size;\r\nelse *pval = NULL;\r\n}
