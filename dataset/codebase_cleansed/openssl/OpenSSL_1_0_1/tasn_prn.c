ASN1_PCTX *ASN1_PCTX_new(void)\r\n{\r\nASN1_PCTX *ret;\r\nret = OPENSSL_malloc(sizeof(ASN1_PCTX));\r\nif (ret == NULL)\r\n{\r\nASN1err(ASN1_F_ASN1_PCTX_NEW, ERR_R_MALLOC_FAILURE);\r\nreturn NULL;\r\n}\r\nret->flags = 0;\r\nret->nm_flags = 0;\r\nret->cert_flags = 0;\r\nret->oid_flags = 0;\r\nret->str_flags = 0;\r\nreturn ret;\r\n}\r\nvoid ASN1_PCTX_free(ASN1_PCTX *p)\r\n{\r\nOPENSSL_free(p);\r\n}\r\nunsigned long ASN1_PCTX_get_flags(ASN1_PCTX *p)\r\n{\r\nreturn p->flags;\r\n}\r\nvoid ASN1_PCTX_set_flags(ASN1_PCTX *p, unsigned long flags)\r\n{\r\np->flags = flags;\r\n}\r\nunsigned long ASN1_PCTX_get_nm_flags(ASN1_PCTX *p)\r\n{\r\nreturn p->nm_flags;\r\n}\r\nvoid ASN1_PCTX_set_nm_flags(ASN1_PCTX *p, unsigned long flags)\r\n{\r\np->nm_flags = flags;\r\n}\r\nunsigned long ASN1_PCTX_get_cert_flags(ASN1_PCTX *p)\r\n{\r\nreturn p->cert_flags;\r\n}\r\nvoid ASN1_PCTX_set_cert_flags(ASN1_PCTX *p, unsigned long flags)\r\n{\r\np->cert_flags = flags;\r\n}\r\nunsigned long ASN1_PCTX_get_oid_flags(ASN1_PCTX *p)\r\n{\r\nreturn p->oid_flags;\r\n}\r\nvoid ASN1_PCTX_set_oid_flags(ASN1_PCTX *p, unsigned long flags)\r\n{\r\np->oid_flags = flags;\r\n}\r\nunsigned long ASN1_PCTX_get_str_flags(ASN1_PCTX *p)\r\n{\r\nreturn p->str_flags;\r\n}\r\nvoid ASN1_PCTX_set_str_flags(ASN1_PCTX *p, unsigned long flags)\r\n{\r\np->str_flags = flags;\r\n}\r\nint ASN1_item_print(BIO *out, ASN1_VALUE *ifld, int indent,\r\nconst ASN1_ITEM *it, const ASN1_PCTX *pctx)\r\n{\r\nconst char *sname;\r\nif (pctx == NULL)\r\npctx = &default_pctx;\r\nif (pctx->flags & ASN1_PCTX_FLAGS_NO_STRUCT_NAME)\r\nsname = NULL;\r\nelse\r\nsname = it->sname;\r\nreturn asn1_item_print_ctx(out, &ifld, indent, it,\r\nNULL, sname, 0, pctx);\r\n}\r\nstatic int asn1_item_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,\r\nconst ASN1_ITEM *it,\r\nconst char *fname, const char *sname,\r\nint nohdr, const ASN1_PCTX *pctx)\r\n{\r\nconst ASN1_TEMPLATE *tt;\r\nconst ASN1_EXTERN_FUNCS *ef;\r\nASN1_VALUE **tmpfld;\r\nconst ASN1_AUX *aux = it->funcs;\r\nASN1_aux_cb *asn1_cb;\r\nASN1_PRINT_ARG parg;\r\nint i;\r\nif (aux && aux->asn1_cb)\r\n{\r\nparg.out = out;\r\nparg.indent = indent;\r\nparg.pctx = pctx;\r\nasn1_cb = aux->asn1_cb;\r\n}\r\nelse asn1_cb = 0;\r\nif(*fld == NULL)\r\n{\r\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_ABSENT)\r\n{\r\nif (!nohdr && !asn1_print_fsname(out, indent,\r\nfname, sname, pctx))\r\nreturn 0;\r\nif (BIO_puts(out, "<ABSENT>\n") <= 0)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nswitch(it->itype)\r\n{\r\ncase ASN1_ITYPE_PRIMITIVE:\r\nif(it->templates)\r\n{\r\nif (!asn1_template_print_ctx(out, fld, indent,\r\nit->templates, pctx))\r\nreturn 0;\r\n}\r\ncase ASN1_ITYPE_MSTRING:\r\nif (!asn1_primitive_print(out, fld, it,\r\nindent, fname, sname,pctx))\r\nreturn 0;\r\nbreak;\r\ncase ASN1_ITYPE_EXTERN:\r\nif (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))\r\nreturn 0;\r\nef = it->funcs;\r\nif (ef && ef->asn1_ex_print)\r\n{\r\ni = ef->asn1_ex_print(out, fld, indent, "", pctx);\r\nif (!i)\r\nreturn 0;\r\nif ((i == 2) && (BIO_puts(out, "\n") <= 0))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nelse if (sname &&\r\nBIO_printf(out, ":EXTERNAL TYPE %s\n", sname) <= 0)\r\nreturn 0;\r\nbreak;\r\ncase ASN1_ITYPE_CHOICE:\r\n#if 0\r\nif (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))\r\nreturn 0;\r\n#endif\r\ni = asn1_get_choice_selector(fld, it);\r\nif((i < 0) || (i >= it->tcount))\r\n{\r\nif (BIO_printf(out,\r\n"ERROR: selector [%d] invalid\n", i) <= 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\ntt = it->templates + i;\r\ntmpfld = asn1_get_field_ptr(fld, tt);\r\nif (!asn1_template_print_ctx(out, tmpfld, indent, tt, pctx))\r\nreturn 0;\r\nbreak;\r\ncase ASN1_ITYPE_SEQUENCE:\r\ncase ASN1_ITYPE_NDEF_SEQUENCE:\r\nif (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))\r\nreturn 0;\r\nif (fname || sname)\r\n{\r\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)\r\n{\r\nif (BIO_puts(out, " {\n") <= 0)\r\nreturn 0;\r\n}\r\nelse\r\n{\r\nif (BIO_puts(out, "\n") <= 0)\r\nreturn 0;\r\n}\r\n}\r\nif (asn1_cb)\r\n{\r\ni = asn1_cb(ASN1_OP_PRINT_PRE, fld, it, &parg);\r\nif (i == 0)\r\nreturn 0;\r\nif (i == 2)\r\nreturn 1;\r\n}\r\nfor(i = 0, tt = it->templates; i < it->tcount; i++, tt++)\r\n{\r\nconst ASN1_TEMPLATE *seqtt;\r\nseqtt = asn1_do_adb(fld, tt, 1);\r\ntmpfld = asn1_get_field_ptr(fld, seqtt);\r\nif (!asn1_template_print_ctx(out, tmpfld,\r\nindent + 2, seqtt, pctx))\r\nreturn 0;\r\n}\r\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)\r\n{\r\nif (BIO_printf(out, "%*s}\n", indent, "") < 0)\r\nreturn 0;\r\n}\r\nif (asn1_cb)\r\n{\r\ni = asn1_cb(ASN1_OP_PRINT_POST, fld, it, &parg);\r\nif (i == 0)\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nBIO_printf(out, "Unprocessed type %d\n", it->itype);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint asn1_template_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,\r\nconst ASN1_TEMPLATE *tt, const ASN1_PCTX *pctx)\r\n{\r\nint i, flags;\r\nconst char *sname, *fname;\r\nflags = tt->flags;\r\nif(pctx->flags & ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME)\r\nsname = ASN1_ITEM_ptr(tt->item)->sname;\r\nelse\r\nsname = NULL;\r\nif(pctx->flags & ASN1_PCTX_FLAGS_NO_FIELD_NAME)\r\nfname = NULL;\r\nelse\r\nfname = tt->field_name;\r\nif(flags & ASN1_TFLG_SK_MASK)\r\n{\r\nchar *tname;\r\nASN1_VALUE *skitem;\r\nSTACK_OF(ASN1_VALUE) *stack;\r\nif (fname)\r\n{\r\nif(pctx->flags & ASN1_PCTX_FLAGS_SHOW_SSOF)\r\n{\r\nif(flags & ASN1_TFLG_SET_OF)\r\ntname = "SET";\r\nelse\r\ntname = "SEQUENCE";\r\nif (BIO_printf(out, "%*s%s OF %s {\n",\r\nindent, "", tname, tt->field_name) <= 0)\r\nreturn 0;\r\n}\r\nelse if (BIO_printf(out, "%*s%s:\n", indent, "",\r\nfname) <= 0)\r\nreturn 0;\r\n}\r\nstack = (STACK_OF(ASN1_VALUE) *)*fld;\r\nfor(i = 0; i < sk_ASN1_VALUE_num(stack); i++)\r\n{\r\nif ((i > 0) && (BIO_puts(out, "\n") <= 0))\r\nreturn 0;\r\nskitem = sk_ASN1_VALUE_value(stack, i);\r\nif (!asn1_item_print_ctx(out, &skitem, indent + 2,\r\nASN1_ITEM_ptr(tt->item), NULL, NULL, 1, pctx))\r\nreturn 0;\r\n}\r\nif (!i && BIO_printf(out, "%*s<EMPTY>\n", indent + 2, "") <= 0)\r\nreturn 0;\r\nif(pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE)\r\n{\r\nif (BIO_printf(out, "%*s}\n", indent, "") <= 0)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nreturn asn1_item_print_ctx(out, fld, indent, ASN1_ITEM_ptr(tt->item),\r\nfname, sname, 0, pctx);\r\n}\r\nstatic int asn1_print_fsname(BIO *out, int indent,\r\nconst char *fname, const char *sname,\r\nconst ASN1_PCTX *pctx)\r\n{\r\nstatic char spaces[] = " ";\r\nconst int nspaces = sizeof(spaces) - 1;\r\n#if 0\r\nif (!sname && !fname)\r\nreturn 1;\r\n#endif\r\nwhile (indent > nspaces)\r\n{\r\nif (BIO_write(out, spaces, nspaces) != nspaces)\r\nreturn 0;\r\nindent -= nspaces;\r\n}\r\nif (BIO_write(out, spaces, indent) != indent)\r\nreturn 0;\r\nif (pctx->flags & ASN1_PCTX_FLAGS_NO_STRUCT_NAME)\r\nsname = NULL;\r\nif (pctx->flags & ASN1_PCTX_FLAGS_NO_FIELD_NAME)\r\nfname = NULL;\r\nif (!sname && !fname)\r\nreturn 1;\r\nif (fname)\r\n{\r\nif (BIO_puts(out, fname) <= 0)\r\nreturn 0;\r\n}\r\nif (sname)\r\n{\r\nif (fname)\r\n{\r\nif (BIO_printf(out, " (%s)", sname) <= 0)\r\nreturn 0;\r\n}\r\nelse\r\n{\r\nif (BIO_puts(out, sname) <= 0)\r\nreturn 0;\r\n}\r\n}\r\nif (BIO_write(out, ": ", 2) != 2)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int asn1_print_boolean_ctx(BIO *out, const int bool,\r\nconst ASN1_PCTX *pctx)\r\n{\r\nconst char *str;\r\nswitch (bool)\r\n{\r\ncase -1:\r\nstr = "BOOL ABSENT";\r\nbreak;\r\ncase 0:\r\nstr = "FALSE";\r\nbreak;\r\ndefault:\r\nstr = "TRUE";\r\nbreak;\r\n}\r\nif (BIO_puts(out, str) <= 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int asn1_print_integer_ctx(BIO *out, ASN1_INTEGER *str,\r\nconst ASN1_PCTX *pctx)\r\n{\r\nchar *s;\r\nint ret = 1;\r\ns = i2s_ASN1_INTEGER(NULL, str);\r\nif (BIO_puts(out, s) <= 0)\r\nret = 0;\r\nOPENSSL_free(s);\r\nreturn ret;\r\n}\r\nstatic int asn1_print_oid_ctx(BIO *out, const ASN1_OBJECT *oid,\r\nconst ASN1_PCTX *pctx)\r\n{\r\nchar objbuf[80];\r\nconst char *ln;\r\nln = OBJ_nid2ln(OBJ_obj2nid(oid));\r\nif(!ln)\r\nln = "";\r\nOBJ_obj2txt(objbuf, sizeof objbuf, oid, 1);\r\nif (BIO_printf(out, "%s (%s)", ln, objbuf) <= 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int asn1_print_obstring_ctx(BIO *out, ASN1_STRING *str, int indent,\r\nconst ASN1_PCTX *pctx)\r\n{\r\nif (str->type == V_ASN1_BIT_STRING)\r\n{\r\nif (BIO_printf(out, " (%ld unused bits)\n",\r\nstr->flags & 0x7) <= 0)\r\nreturn 0;\r\n}\r\nelse if (BIO_puts(out, "\n") <= 0)\r\nreturn 0;\r\nif ((str->length > 0)\r\n&& BIO_dump_indent(out, (char *)str->data, str->length,\r\nindent + 2) <= 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int asn1_primitive_print(BIO *out, ASN1_VALUE **fld,\r\nconst ASN1_ITEM *it, int indent,\r\nconst char *fname, const char *sname,\r\nconst ASN1_PCTX *pctx)\r\n{\r\nlong utype;\r\nASN1_STRING *str;\r\nint ret = 1, needlf = 1;\r\nconst char *pname;\r\nconst ASN1_PRIMITIVE_FUNCS *pf;\r\npf = it->funcs;\r\nif (!asn1_print_fsname(out, indent, fname, sname, pctx))\r\nreturn 0;\r\nif (pf && pf->prim_print)\r\nreturn pf->prim_print(out, fld, it, indent, pctx);\r\nstr = (ASN1_STRING *)*fld;\r\nif (it->itype == ASN1_ITYPE_MSTRING)\r\nutype = str->type & ~V_ASN1_NEG;\r\nelse\r\nutype = it->utype;\r\nif (utype == V_ASN1_ANY)\r\n{\r\nASN1_TYPE *atype = (ASN1_TYPE *)*fld;\r\nutype = atype->type;\r\nfld = &atype->value.asn1_value;\r\nstr = (ASN1_STRING *)*fld;\r\nif (pctx->flags & ASN1_PCTX_FLAGS_NO_ANY_TYPE)\r\npname = NULL;\r\nelse\r\npname = ASN1_tag2str(utype);\r\n}\r\nelse\r\n{\r\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_TYPE)\r\npname = ASN1_tag2str(utype);\r\nelse\r\npname = NULL;\r\n}\r\nif (utype == V_ASN1_NULL)\r\n{\r\nif (BIO_puts(out, "NULL\n") <= 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nif (pname)\r\n{\r\nif (BIO_puts(out, pname) <= 0)\r\nreturn 0;\r\nif (BIO_puts(out, ":") <= 0)\r\nreturn 0;\r\n}\r\nswitch (utype)\r\n{\r\ncase V_ASN1_BOOLEAN:\r\n{\r\nint bool = *(int *)fld;\r\nif (bool == -1)\r\nbool = it->size;\r\nret = asn1_print_boolean_ctx(out, bool, pctx);\r\n}\r\nbreak;\r\ncase V_ASN1_INTEGER:\r\ncase V_ASN1_ENUMERATED:\r\nret = asn1_print_integer_ctx(out, str, pctx);\r\nbreak;\r\ncase V_ASN1_UTCTIME:\r\nret = ASN1_UTCTIME_print(out, str);\r\nbreak;\r\ncase V_ASN1_GENERALIZEDTIME:\r\nret = ASN1_GENERALIZEDTIME_print(out, str);\r\nbreak;\r\ncase V_ASN1_OBJECT:\r\nret = asn1_print_oid_ctx(out, (const ASN1_OBJECT *)*fld, pctx);\r\nbreak;\r\ncase V_ASN1_OCTET_STRING:\r\ncase V_ASN1_BIT_STRING:\r\nret = asn1_print_obstring_ctx(out, str, indent, pctx);\r\nneedlf = 0;\r\nbreak;\r\ncase V_ASN1_SEQUENCE:\r\ncase V_ASN1_SET:\r\ncase V_ASN1_OTHER:\r\nif (BIO_puts(out, "\n") <= 0)\r\nreturn 0;\r\nif (ASN1_parse_dump(out, str->data, str->length,\r\nindent, 0) <= 0)\r\nret = 0;\r\nneedlf = 0;\r\nbreak;\r\ndefault:\r\nret = ASN1_STRING_print_ex(out, str, pctx->str_flags);\r\n}\r\nif (!ret)\r\nreturn 0;\r\nif (needlf && BIO_puts(out, "\n") <= 0)\r\nreturn 0;\r\nreturn 1;\r\n}
