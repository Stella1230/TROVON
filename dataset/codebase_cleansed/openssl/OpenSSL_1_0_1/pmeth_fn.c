int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx)\r\n{\r\nint ret;\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->sign)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_SIGN_INIT,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nctx->operation = EVP_PKEY_OP_SIGN;\r\nif (!ctx->pmeth->sign_init)\r\nreturn 1;\r\nret = ctx->pmeth->sign_init(ctx);\r\nif (ret <= 0)\r\nctx->operation = EVP_PKEY_OP_UNDEFINED;\r\nreturn ret;\r\n}\r\nint EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\r\nunsigned char *sig, size_t *siglen,\r\nconst unsigned char *tbs, size_t tbslen)\r\n{\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->sign)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_SIGN,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nif (ctx->operation != EVP_PKEY_OP_SIGN)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_SIGN, EVP_R_OPERATON_NOT_INITIALIZED);\r\nreturn -1;\r\n}\r\nM_check_autoarg(ctx, sig, siglen, EVP_F_EVP_PKEY_SIGN)\r\nreturn ctx->pmeth->sign(ctx, sig, siglen, tbs, tbslen);\r\n}\r\nint EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx)\r\n{\r\nint ret;\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->verify)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_VERIFY_INIT,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nctx->operation = EVP_PKEY_OP_VERIFY;\r\nif (!ctx->pmeth->verify_init)\r\nreturn 1;\r\nret = ctx->pmeth->verify_init(ctx);\r\nif (ret <= 0)\r\nctx->operation = EVP_PKEY_OP_UNDEFINED;\r\nreturn ret;\r\n}\r\nint EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\r\nconst unsigned char *sig, size_t siglen,\r\nconst unsigned char *tbs, size_t tbslen)\r\n{\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->verify)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_VERIFY,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nif (ctx->operation != EVP_PKEY_OP_VERIFY)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_VERIFY, EVP_R_OPERATON_NOT_INITIALIZED);\r\nreturn -1;\r\n}\r\nreturn ctx->pmeth->verify(ctx, sig, siglen, tbs, tbslen);\r\n}\r\nint EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx)\r\n{\r\nint ret;\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->verify_recover)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nctx->operation = EVP_PKEY_OP_VERIFYRECOVER;\r\nif (!ctx->pmeth->verify_recover_init)\r\nreturn 1;\r\nret = ctx->pmeth->verify_recover_init(ctx);\r\nif (ret <= 0)\r\nctx->operation = EVP_PKEY_OP_UNDEFINED;\r\nreturn ret;\r\n}\r\nint EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,\r\nunsigned char *rout, size_t *routlen,\r\nconst unsigned char *sig, size_t siglen)\r\n{\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->verify_recover)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_VERIFY_RECOVER,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nif (ctx->operation != EVP_PKEY_OP_VERIFYRECOVER)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_VERIFY_RECOVER, EVP_R_OPERATON_NOT_INITIALIZED);\r\nreturn -1;\r\n}\r\nM_check_autoarg(ctx, rout, routlen, EVP_F_EVP_PKEY_VERIFY_RECOVER)\r\nreturn ctx->pmeth->verify_recover(ctx, rout, routlen, sig, siglen);\r\n}\r\nint EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx)\r\n{\r\nint ret;\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->encrypt)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_ENCRYPT_INIT,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nctx->operation = EVP_PKEY_OP_ENCRYPT;\r\nif (!ctx->pmeth->encrypt_init)\r\nreturn 1;\r\nret = ctx->pmeth->encrypt_init(ctx);\r\nif (ret <= 0)\r\nctx->operation = EVP_PKEY_OP_UNDEFINED;\r\nreturn ret;\r\n}\r\nint EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\r\nunsigned char *out, size_t *outlen,\r\nconst unsigned char *in, size_t inlen)\r\n{\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->encrypt)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_ENCRYPT,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nif (ctx->operation != EVP_PKEY_OP_ENCRYPT)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_ENCRYPT, EVP_R_OPERATON_NOT_INITIALIZED);\r\nreturn -1;\r\n}\r\nM_check_autoarg(ctx, out, outlen, EVP_F_EVP_PKEY_ENCRYPT)\r\nreturn ctx->pmeth->encrypt(ctx, out, outlen, in, inlen);\r\n}\r\nint EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx)\r\n{\r\nint ret;\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->decrypt)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DECRYPT_INIT,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nctx->operation = EVP_PKEY_OP_DECRYPT;\r\nif (!ctx->pmeth->decrypt_init)\r\nreturn 1;\r\nret = ctx->pmeth->decrypt_init(ctx);\r\nif (ret <= 0)\r\nctx->operation = EVP_PKEY_OP_UNDEFINED;\r\nreturn ret;\r\n}\r\nint EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\r\nunsigned char *out, size_t *outlen,\r\nconst unsigned char *in, size_t inlen)\r\n{\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->decrypt)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DECRYPT,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nif (ctx->operation != EVP_PKEY_OP_DECRYPT)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DECRYPT, EVP_R_OPERATON_NOT_INITIALIZED);\r\nreturn -1;\r\n}\r\nM_check_autoarg(ctx, out, outlen, EVP_F_EVP_PKEY_DECRYPT)\r\nreturn ctx->pmeth->decrypt(ctx, out, outlen, in, inlen);\r\n}\r\nint EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx)\r\n{\r\nint ret;\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->derive)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DERIVE_INIT,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nctx->operation = EVP_PKEY_OP_DERIVE;\r\nif (!ctx->pmeth->derive_init)\r\nreturn 1;\r\nret = ctx->pmeth->derive_init(ctx);\r\nif (ret <= 0)\r\nctx->operation = EVP_PKEY_OP_UNDEFINED;\r\nreturn ret;\r\n}\r\nint EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)\r\n{\r\nint ret;\r\nif (!ctx || !ctx->pmeth || !(ctx->pmeth->derive||ctx->pmeth->encrypt||ctx->pmeth->decrypt) || !ctx->pmeth->ctrl)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nif (ctx->operation != EVP_PKEY_OP_DERIVE && ctx->operation != EVP_PKEY_OP_ENCRYPT && ctx->operation != EVP_PKEY_OP_DECRYPT)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,\r\nEVP_R_OPERATON_NOT_INITIALIZED);\r\nreturn -1;\r\n}\r\nret = ctx->pmeth->ctrl(ctx, EVP_PKEY_CTRL_PEER_KEY, 0, peer);\r\nif (ret <= 0)\r\nreturn ret;\r\nif (ret == 2)\r\nreturn 1;\r\nif (!ctx->pkey)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_NO_KEY_SET);\r\nreturn -1;\r\n}\r\nif (ctx->pkey->type != peer->type)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,\r\nEVP_R_DIFFERENT_KEY_TYPES);\r\nreturn -1;\r\n}\r\nif (!EVP_PKEY_missing_parameters(peer) &&\r\n!EVP_PKEY_cmp_parameters(ctx->pkey, peer))\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,\r\nEVP_R_DIFFERENT_PARAMETERS);\r\nreturn -1;\r\n}\r\nif (ctx->peerkey)\r\nEVP_PKEY_free(ctx->peerkey);\r\nctx->peerkey = peer;\r\nret = ctx->pmeth->ctrl(ctx, EVP_PKEY_CTRL_PEER_KEY, 1, peer);\r\nif (ret <= 0)\r\n{\r\nctx->peerkey = NULL;\r\nreturn ret;\r\n}\r\nCRYPTO_add(&peer->references,1,CRYPTO_LOCK_EVP_PKEY);\r\nreturn 1;\r\n}\r\nint EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *pkeylen)\r\n{\r\nif (!ctx || !ctx->pmeth || !ctx->pmeth->derive)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DERIVE,\r\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\r\nreturn -2;\r\n}\r\nif (ctx->operation != EVP_PKEY_OP_DERIVE)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_DERIVE, EVP_R_OPERATON_NOT_INITIALIZED);\r\nreturn -1;\r\n}\r\nM_check_autoarg(ctx, key, pkeylen, EVP_F_EVP_PKEY_DERIVE)\r\nreturn ctx->pmeth->derive(ctx, key, pkeylen);\r\n}
