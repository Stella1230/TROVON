static void impl_check(void)\r\n{\r\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\r\nif(!impl)\r\nimpl = &impl_default;\r\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\r\n}\r\nconst CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void)\r\n{\r\nIMPL_CHECK\r\nreturn impl;\r\n}\r\nint CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i)\r\n{\r\nint toret = 0;\r\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\r\nif(!impl)\r\n{\r\nimpl = i;\r\ntoret = 1;\r\n}\r\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\r\nreturn toret;\r\n}\r\nstatic unsigned long ex_class_item_hash(const EX_CLASS_ITEM *a)\r\n{\r\nreturn a->class_index;\r\n}\r\nvoid def_cleanup_util_cb(CRYPTO_EX_DATA_FUNCS *funcs)\r\n{\r\nOPENSSL_free(funcs);\r\n}\r\nstatic void def_cleanup_cb(void *a_void)\r\n{\r\nEX_CLASS_ITEM *item = (EX_CLASS_ITEM *)a_void;\r\nsk_CRYPTO_EX_DATA_FUNCS_pop_free(item->meth, def_cleanup_util_cb);\r\nOPENSSL_free(item);\r\n}\r\nstatic EX_CLASS_ITEM *def_get_class(int class_index)\r\n{\r\nEX_CLASS_ITEM d, *p, *gen;\r\nEX_DATA_CHECK(return NULL;)\r\nd.class_index = class_index;\r\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\r\np = lh_EX_CLASS_ITEM_retrieve(ex_data, &d);\r\nif(!p)\r\n{\r\ngen = OPENSSL_malloc(sizeof(EX_CLASS_ITEM));\r\nif(gen)\r\n{\r\ngen->class_index = class_index;\r\ngen->meth_num = 0;\r\ngen->meth = sk_CRYPTO_EX_DATA_FUNCS_new_null();\r\nif(!gen->meth)\r\nOPENSSL_free(gen);\r\nelse\r\n{\r\n(void)lh_EX_CLASS_ITEM_insert(ex_data, gen);\r\np = gen;\r\n}\r\n}\r\n}\r\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\r\nif(!p)\r\nCRYPTOerr(CRYPTO_F_DEF_GET_CLASS,ERR_R_MALLOC_FAILURE);\r\nreturn p;\r\n}\r\nstatic int def_add_index(EX_CLASS_ITEM *item, long argl, void *argp,\r\nCRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\r\nCRYPTO_EX_free *free_func)\r\n{\r\nint toret = -1;\r\nCRYPTO_EX_DATA_FUNCS *a = (CRYPTO_EX_DATA_FUNCS *)OPENSSL_malloc(\r\nsizeof(CRYPTO_EX_DATA_FUNCS));\r\nif(!a)\r\n{\r\nCRYPTOerr(CRYPTO_F_DEF_ADD_INDEX,ERR_R_MALLOC_FAILURE);\r\nreturn -1;\r\n}\r\na->argl=argl;\r\na->argp=argp;\r\na->new_func=new_func;\r\na->dup_func=dup_func;\r\na->free_func=free_func;\r\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\r\nwhile (sk_CRYPTO_EX_DATA_FUNCS_num(item->meth) <= item->meth_num)\r\n{\r\nif (!sk_CRYPTO_EX_DATA_FUNCS_push(item->meth, NULL))\r\n{\r\nCRYPTOerr(CRYPTO_F_DEF_ADD_INDEX,ERR_R_MALLOC_FAILURE);\r\nOPENSSL_free(a);\r\ngoto err;\r\n}\r\n}\r\ntoret = item->meth_num++;\r\n(void)sk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);\r\nerr:\r\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\r\nreturn toret;\r\n}\r\nstatic int int_new_class(void)\r\n{\r\nint toret;\r\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\r\ntoret = ex_class++;\r\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\r\nreturn toret;\r\n}\r\nstatic void int_cleanup(void)\r\n{\r\nEX_DATA_CHECK(return;)\r\nlh_EX_CLASS_ITEM_doall(ex_data, def_cleanup_cb);\r\nlh_EX_CLASS_ITEM_free(ex_data);\r\nex_data = NULL;\r\nimpl = NULL;\r\n}\r\nstatic int int_get_new_index(int class_index, long argl, void *argp,\r\nCRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\r\nCRYPTO_EX_free *free_func)\r\n{\r\nEX_CLASS_ITEM *item = def_get_class(class_index);\r\nif(!item)\r\nreturn -1;\r\nreturn def_add_index(item, argl, argp, new_func, dup_func, free_func);\r\n}\r\nstatic int int_new_ex_data(int class_index, void *obj,\r\nCRYPTO_EX_DATA *ad)\r\n{\r\nint mx,i;\r\nvoid *ptr;\r\nCRYPTO_EX_DATA_FUNCS **storage = NULL;\r\nEX_CLASS_ITEM *item = def_get_class(class_index);\r\nif(!item)\r\nreturn 0;\r\nad->sk = NULL;\r\nCRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);\r\nmx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);\r\nif(mx > 0)\r\n{\r\nstorage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));\r\nif(!storage)\r\ngoto skip;\r\nfor(i = 0; i < mx; i++)\r\nstorage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);\r\n}\r\nskip:\r\nCRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);\r\nif((mx > 0) && !storage)\r\n{\r\nCRYPTOerr(CRYPTO_F_INT_NEW_EX_DATA,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nfor(i = 0; i < mx; i++)\r\n{\r\nif(storage[i] && storage[i]->new_func)\r\n{\r\nptr = CRYPTO_get_ex_data(ad, i);\r\nstorage[i]->new_func(obj,ptr,ad,i,\r\nstorage[i]->argl,storage[i]->argp);\r\n}\r\n}\r\nif(storage)\r\nOPENSSL_free(storage);\r\nreturn 1;\r\n}\r\nstatic int int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,\r\nCRYPTO_EX_DATA *from)\r\n{\r\nint mx, j, i;\r\nchar *ptr;\r\nCRYPTO_EX_DATA_FUNCS **storage = NULL;\r\nEX_CLASS_ITEM *item;\r\nif(!from->sk)\r\nreturn 1;\r\nif((item = def_get_class(class_index)) == NULL)\r\nreturn 0;\r\nCRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);\r\nmx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);\r\nj = sk_void_num(from->sk);\r\nif(j < mx)\r\nmx = j;\r\nif(mx > 0)\r\n{\r\nstorage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));\r\nif(!storage)\r\ngoto skip;\r\nfor(i = 0; i < mx; i++)\r\nstorage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);\r\n}\r\nskip:\r\nCRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);\r\nif((mx > 0) && !storage)\r\n{\r\nCRYPTOerr(CRYPTO_F_INT_DUP_EX_DATA,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nfor(i = 0; i < mx; i++)\r\n{\r\nptr = CRYPTO_get_ex_data(from, i);\r\nif(storage[i] && storage[i]->dup_func)\r\nstorage[i]->dup_func(to,from,&ptr,i,\r\nstorage[i]->argl,storage[i]->argp);\r\nCRYPTO_set_ex_data(to,i,ptr);\r\n}\r\nif(storage)\r\nOPENSSL_free(storage);\r\nreturn 1;\r\n}\r\nstatic void int_free_ex_data(int class_index, void *obj,\r\nCRYPTO_EX_DATA *ad)\r\n{\r\nint mx,i;\r\nEX_CLASS_ITEM *item;\r\nvoid *ptr;\r\nCRYPTO_EX_DATA_FUNCS **storage = NULL;\r\nif((item = def_get_class(class_index)) == NULL)\r\nreturn;\r\nCRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);\r\nmx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);\r\nif(mx > 0)\r\n{\r\nstorage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS*));\r\nif(!storage)\r\ngoto skip;\r\nfor(i = 0; i < mx; i++)\r\nstorage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth,i);\r\n}\r\nskip:\r\nCRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);\r\nif((mx > 0) && !storage)\r\n{\r\nCRYPTOerr(CRYPTO_F_INT_FREE_EX_DATA,ERR_R_MALLOC_FAILURE);\r\nreturn;\r\n}\r\nfor(i = 0; i < mx; i++)\r\n{\r\nif(storage[i] && storage[i]->free_func)\r\n{\r\nptr = CRYPTO_get_ex_data(ad,i);\r\nstorage[i]->free_func(obj,ptr,ad,i,\r\nstorage[i]->argl,storage[i]->argp);\r\n}\r\n}\r\nif(storage)\r\nOPENSSL_free(storage);\r\nif(ad->sk)\r\n{\r\nsk_void_free(ad->sk);\r\nad->sk=NULL;\r\n}\r\n}\r\nint CRYPTO_ex_data_new_class(void)\r\n{\r\nIMPL_CHECK\r\nreturn EX_IMPL(new_class)();\r\n}\r\nvoid CRYPTO_cleanup_all_ex_data(void)\r\n{\r\nIMPL_CHECK\r\nEX_IMPL(cleanup)();\r\n}\r\nint CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,\r\nCRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\r\nCRYPTO_EX_free *free_func)\r\n{\r\nint ret = -1;\r\nIMPL_CHECK\r\nret = EX_IMPL(get_new_index)(class_index,\r\nargl, argp, new_func, dup_func, free_func);\r\nreturn ret;\r\n}\r\nint CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\r\n{\r\nIMPL_CHECK\r\nreturn EX_IMPL(new_ex_data)(class_index, obj, ad);\r\n}\r\nint CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,\r\nCRYPTO_EX_DATA *from)\r\n{\r\nIMPL_CHECK\r\nreturn EX_IMPL(dup_ex_data)(class_index, to, from);\r\n}\r\nvoid CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\r\n{\r\nIMPL_CHECK\r\nEX_IMPL(free_ex_data)(class_index, obj, ad);\r\n}\r\nint CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)\r\n{\r\nint i;\r\nif (ad->sk == NULL)\r\n{\r\nif ((ad->sk=sk_void_new_null()) == NULL)\r\n{\r\nCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);\r\nreturn(0);\r\n}\r\n}\r\ni=sk_void_num(ad->sk);\r\nwhile (i <= idx)\r\n{\r\nif (!sk_void_push(ad->sk,NULL))\r\n{\r\nCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA,ERR_R_MALLOC_FAILURE);\r\nreturn(0);\r\n}\r\ni++;\r\n}\r\nsk_void_set(ad->sk,idx,val);\r\nreturn(1);\r\n}\r\nvoid *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)\r\n{\r\nif (ad->sk == NULL)\r\nreturn(0);\r\nelse if (idx >= sk_void_num(ad->sk))\r\nreturn(0);\r\nelse\r\nreturn(sk_void_value(ad->sk,idx));\r\n}
