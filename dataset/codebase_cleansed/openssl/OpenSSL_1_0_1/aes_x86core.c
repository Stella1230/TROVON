static void prefetch256(const void *table)\r\n{\r\nvolatile unsigned long *t=(void *)table,ret;\r\nunsigned long sum;\r\nint i;\r\nfor (sum=0,i=0;i<256/sizeof(t[0]);i+=32/sizeof(t[0])) sum ^= t[i];\r\nret = sum;\r\n}\r\nint AES_set_encrypt_key(const unsigned char *userKey, const int bits,\r\nAES_KEY *key) {\r\nu32 *rk;\r\nint i = 0;\r\nu32 temp;\r\nif (!userKey || !key)\r\nreturn -1;\r\nif (bits != 128 && bits != 192 && bits != 256)\r\nreturn -2;\r\nrk = key->rd_key;\r\nif (bits==128)\r\nkey->rounds = 10;\r\nelse if (bits==192)\r\nkey->rounds = 12;\r\nelse\r\nkey->rounds = 14;\r\nrk[0] = GETU32(userKey );\r\nrk[1] = GETU32(userKey + 4);\r\nrk[2] = GETU32(userKey + 8);\r\nrk[3] = GETU32(userKey + 12);\r\nif (bits == 128) {\r\nwhile (1) {\r\ntemp = rk[3];\r\nrk[4] = rk[0] ^\r\n(Te4[(temp >> 8) & 0xff] ) ^\r\n(Te4[(temp >> 16) & 0xff] << 8) ^\r\n(Te4[(temp >> 24) ] << 16) ^\r\n(Te4[(temp ) & 0xff] << 24) ^\r\nrcon[i];\r\nrk[5] = rk[1] ^ rk[4];\r\nrk[6] = rk[2] ^ rk[5];\r\nrk[7] = rk[3] ^ rk[6];\r\nif (++i == 10) {\r\nreturn 0;\r\n}\r\nrk += 4;\r\n}\r\n}\r\nrk[4] = GETU32(userKey + 16);\r\nrk[5] = GETU32(userKey + 20);\r\nif (bits == 192) {\r\nwhile (1) {\r\ntemp = rk[ 5];\r\nrk[ 6] = rk[ 0] ^\r\n(Te4[(temp >> 8) & 0xff] ) ^\r\n(Te4[(temp >> 16) & 0xff] << 8) ^\r\n(Te4[(temp >> 24) ] << 16) ^\r\n(Te4[(temp ) & 0xff] << 24) ^\r\nrcon[i];\r\nrk[ 7] = rk[ 1] ^ rk[ 6];\r\nrk[ 8] = rk[ 2] ^ rk[ 7];\r\nrk[ 9] = rk[ 3] ^ rk[ 8];\r\nif (++i == 8) {\r\nreturn 0;\r\n}\r\nrk[10] = rk[ 4] ^ rk[ 9];\r\nrk[11] = rk[ 5] ^ rk[10];\r\nrk += 6;\r\n}\r\n}\r\nrk[6] = GETU32(userKey + 24);\r\nrk[7] = GETU32(userKey + 28);\r\nif (bits == 256) {\r\nwhile (1) {\r\ntemp = rk[ 7];\r\nrk[ 8] = rk[ 0] ^\r\n(Te4[(temp >> 8) & 0xff] ) ^\r\n(Te4[(temp >> 16) & 0xff] << 8) ^\r\n(Te4[(temp >> 24) ] << 16) ^\r\n(Te4[(temp ) & 0xff] << 24) ^\r\nrcon[i];\r\nrk[ 9] = rk[ 1] ^ rk[ 8];\r\nrk[10] = rk[ 2] ^ rk[ 9];\r\nrk[11] = rk[ 3] ^ rk[10];\r\nif (++i == 7) {\r\nreturn 0;\r\n}\r\ntemp = rk[11];\r\nrk[12] = rk[ 4] ^\r\n(Te4[(temp ) & 0xff] ) ^\r\n(Te4[(temp >> 8) & 0xff] << 8) ^\r\n(Te4[(temp >> 16) & 0xff] << 16) ^\r\n(Te4[(temp >> 24) ] << 24);\r\nrk[13] = rk[ 5] ^ rk[12];\r\nrk[14] = rk[ 6] ^ rk[13];\r\nrk[15] = rk[ 7] ^ rk[14];\r\nrk += 8;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint AES_set_decrypt_key(const unsigned char *userKey, const int bits,\r\nAES_KEY *key) {\r\nu32 *rk;\r\nint i, j, status;\r\nu32 temp;\r\nstatus = AES_set_encrypt_key(userKey, bits, key);\r\nif (status < 0)\r\nreturn status;\r\nrk = key->rd_key;\r\nfor (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\r\ntemp = rk[i ]; rk[i ] = rk[j ]; rk[j ] = temp;\r\ntemp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\r\ntemp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\r\ntemp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\r\n}\r\nfor (i = 1; i < (key->rounds); i++) {\r\nrk += 4;\r\n#if 1\r\nfor (j = 0; j < 4; j++) {\r\nu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\r\ntp1 = rk[j];\r\nm = tp1 & 0x80808080;\r\ntp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\r\n((m - (m >> 7)) & 0x1b1b1b1b);\r\nm = tp2 & 0x80808080;\r\ntp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\r\n((m - (m >> 7)) & 0x1b1b1b1b);\r\nm = tp4 & 0x80808080;\r\ntp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\r\n((m - (m >> 7)) & 0x1b1b1b1b);\r\ntp9 = tp8 ^ tp1;\r\ntpb = tp9 ^ tp2;\r\ntpd = tp9 ^ tp4;\r\ntpe = tp8 ^ tp4 ^ tp2;\r\n#if defined(ROTATE)\r\nrk[j] = tpe ^ ROTATE(tpd,16) ^\r\nROTATE(tp9,8) ^ ROTATE(tpb,24);\r\n#else\r\nrk[j] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\r\n(tp9 >> 24) ^ (tp9 << 8) ^\r\n(tpb >> 8) ^ (tpb << 24);\r\n#endif\r\n}\r\n#else\r\nrk[0] =\r\nTd0[Te2[(rk[0] ) & 0xff] & 0xff] ^\r\nTd1[Te2[(rk[0] >> 8) & 0xff] & 0xff] ^\r\nTd2[Te2[(rk[0] >> 16) & 0xff] & 0xff] ^\r\nTd3[Te2[(rk[0] >> 24) ] & 0xff];\r\nrk[1] =\r\nTd0[Te2[(rk[1] ) & 0xff] & 0xff] ^\r\nTd1[Te2[(rk[1] >> 8) & 0xff] & 0xff] ^\r\nTd2[Te2[(rk[1] >> 16) & 0xff] & 0xff] ^\r\nTd3[Te2[(rk[1] >> 24) ] & 0xff];\r\nrk[2] =\r\nTd0[Te2[(rk[2] ) & 0xff] & 0xff] ^\r\nTd1[Te2[(rk[2] >> 8) & 0xff] & 0xff] ^\r\nTd2[Te2[(rk[2] >> 16) & 0xff] & 0xff] ^\r\nTd3[Te2[(rk[2] >> 24) ] & 0xff];\r\nrk[3] =\r\nTd0[Te2[(rk[3] ) & 0xff] & 0xff] ^\r\nTd1[Te2[(rk[3] >> 8) & 0xff] & 0xff] ^\r\nTd2[Te2[(rk[3] >> 16) & 0xff] & 0xff] ^\r\nTd3[Te2[(rk[3] >> 24) ] & 0xff];\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nvoid AES_encrypt(const unsigned char *in, unsigned char *out,\r\nconst AES_KEY *key) {\r\nconst u32 *rk;\r\nu32 s0, s1, s2, s3, t[4];\r\nint r;\r\nassert(in && out && key);\r\nrk = key->rd_key;\r\ns0 = GETU32(in ) ^ rk[0];\r\ns1 = GETU32(in + 4) ^ rk[1];\r\ns2 = GETU32(in + 8) ^ rk[2];\r\ns3 = GETU32(in + 12) ^ rk[3];\r\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\r\nprefetch256(Te4);\r\nt[0] = Te4[(s0 ) & 0xff] ^\r\nTe4[(s1 >> 8) & 0xff] << 8 ^\r\nTe4[(s2 >> 16) & 0xff] << 16 ^\r\nTe4[(s3 >> 24) ] << 24;\r\nt[1] = Te4[(s1 ) & 0xff] ^\r\nTe4[(s2 >> 8) & 0xff] << 8 ^\r\nTe4[(s3 >> 16) & 0xff] << 16 ^\r\nTe4[(s0 >> 24) ] << 24;\r\nt[2] = Te4[(s2 ) & 0xff] ^\r\nTe4[(s3 >> 8) & 0xff] << 8 ^\r\nTe4[(s0 >> 16) & 0xff] << 16 ^\r\nTe4[(s1 >> 24) ] << 24;\r\nt[3] = Te4[(s3 ) & 0xff] ^\r\nTe4[(s0 >> 8) & 0xff] << 8 ^\r\nTe4[(s1 >> 16) & 0xff] << 16 ^\r\nTe4[(s2 >> 24) ] << 24;\r\n{ int i;\r\nu32 r0, r1, r2;\r\nfor (i = 0; i < 4; i++) {\r\nr0 = t[i];\r\nr1 = r0 & 0x80808080;\r\nr2 = ((r0 & 0x7f7f7f7f) << 1) ^\r\n((r1 - (r1 >> 7)) & 0x1b1b1b1b);\r\n#if defined(ROTATE)\r\nt[i] = r2 ^ ROTATE(r2,24) ^ ROTATE(r0,24) ^\r\nROTATE(r0,16) ^ ROTATE(r0,8);\r\n#else\r\nt[i] = r2 ^ ((r2 ^ r0) << 24) ^ ((r2 ^ r0) >> 8) ^\r\n(r0 << 16) ^ (r0 >> 16) ^\r\n(r0 << 8) ^ (r0 >> 24);\r\n#endif\r\nt[i] ^= rk[4+i];\r\n}\r\n}\r\n#else\r\nt[0] = Te0[(s0 ) & 0xff] ^\r\nTe1[(s1 >> 8) & 0xff] ^\r\nTe2[(s2 >> 16) & 0xff] ^\r\nTe3[(s3 >> 24) ] ^\r\nrk[4];\r\nt[1] = Te0[(s1 ) & 0xff] ^\r\nTe1[(s2 >> 8) & 0xff] ^\r\nTe2[(s3 >> 16) & 0xff] ^\r\nTe3[(s0 >> 24) ] ^\r\nrk[5];\r\nt[2] = Te0[(s2 ) & 0xff] ^\r\nTe1[(s3 >> 8) & 0xff] ^\r\nTe2[(s0 >> 16) & 0xff] ^\r\nTe3[(s1 >> 24) ] ^\r\nrk[6];\r\nt[3] = Te0[(s3 ) & 0xff] ^\r\nTe1[(s0 >> 8) & 0xff] ^\r\nTe2[(s1 >> 16) & 0xff] ^\r\nTe3[(s2 >> 24) ] ^\r\nrk[7];\r\n#endif\r\ns0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\r\nfor (rk+=8,r=key->rounds-2; r>0; rk+=4,r--) {\r\n#if defined(AES_COMPACT_IN_INNER_ROUNDS)\r\nt[0] = Te4[(s0 ) & 0xff] ^\r\nTe4[(s1 >> 8) & 0xff] << 8 ^\r\nTe4[(s2 >> 16) & 0xff] << 16 ^\r\nTe4[(s3 >> 24) ] << 24;\r\nt[1] = Te4[(s1 ) & 0xff] ^\r\nTe4[(s2 >> 8) & 0xff] << 8 ^\r\nTe4[(s3 >> 16) & 0xff] << 16 ^\r\nTe4[(s0 >> 24) ] << 24;\r\nt[2] = Te4[(s2 ) & 0xff] ^\r\nTe4[(s3 >> 8) & 0xff] << 8 ^\r\nTe4[(s0 >> 16) & 0xff] << 16 ^\r\nTe4[(s1 >> 24) ] << 24;\r\nt[3] = Te4[(s3 ) & 0xff] ^\r\nTe4[(s0 >> 8) & 0xff] << 8 ^\r\nTe4[(s1 >> 16) & 0xff] << 16 ^\r\nTe4[(s2 >> 24) ] << 24;\r\n{ int i;\r\nu32 r0, r1, r2;\r\nfor (i = 0; i < 4; i++) {\r\nr0 = t[i];\r\nr1 = r0 & 0x80808080;\r\nr2 = ((r0 & 0x7f7f7f7f) << 1) ^\r\n((r1 - (r1 >> 7)) & 0x1b1b1b1b);\r\n#if defined(ROTATE)\r\nt[i] = r2 ^ ROTATE(r2,24) ^ ROTATE(r0,24) ^\r\nROTATE(r0,16) ^ ROTATE(r0,8);\r\n#else\r\nt[i] = r2 ^ ((r2 ^ r0) << 24) ^ ((r2 ^ r0) >> 8) ^\r\n(r0 << 16) ^ (r0 >> 16) ^\r\n(r0 << 8) ^ (r0 >> 24);\r\n#endif\r\nt[i] ^= rk[i];\r\n}\r\n}\r\n#else\r\nt[0] = Te0[(s0 ) & 0xff] ^\r\nTe1[(s1 >> 8) & 0xff] ^\r\nTe2[(s2 >> 16) & 0xff] ^\r\nTe3[(s3 >> 24) ] ^\r\nrk[0];\r\nt[1] = Te0[(s1 ) & 0xff] ^\r\nTe1[(s2 >> 8) & 0xff] ^\r\nTe2[(s3 >> 16) & 0xff] ^\r\nTe3[(s0 >> 24) ] ^\r\nrk[1];\r\nt[2] = Te0[(s2 ) & 0xff] ^\r\nTe1[(s3 >> 8) & 0xff] ^\r\nTe2[(s0 >> 16) & 0xff] ^\r\nTe3[(s1 >> 24) ] ^\r\nrk[2];\r\nt[3] = Te0[(s3 ) & 0xff] ^\r\nTe1[(s0 >> 8) & 0xff] ^\r\nTe2[(s1 >> 16) & 0xff] ^\r\nTe3[(s2 >> 24) ] ^\r\nrk[3];\r\n#endif\r\ns0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\r\n}\r\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\r\nprefetch256(Te4);\r\n*(u32*)(out+0) =\r\nTe4[(s0 ) & 0xff] ^\r\nTe4[(s1 >> 8) & 0xff] << 8 ^\r\nTe4[(s2 >> 16) & 0xff] << 16 ^\r\nTe4[(s3 >> 24) ] << 24 ^\r\nrk[0];\r\n*(u32*)(out+4) =\r\nTe4[(s1 ) & 0xff] ^\r\nTe4[(s2 >> 8) & 0xff] << 8 ^\r\nTe4[(s3 >> 16) & 0xff] << 16 ^\r\nTe4[(s0 >> 24) ] << 24 ^\r\nrk[1];\r\n*(u32*)(out+8) =\r\nTe4[(s2 ) & 0xff] ^\r\nTe4[(s3 >> 8) & 0xff] << 8 ^\r\nTe4[(s0 >> 16) & 0xff] << 16 ^\r\nTe4[(s1 >> 24) ] << 24 ^\r\nrk[2];\r\n*(u32*)(out+12) =\r\nTe4[(s3 ) & 0xff] ^\r\nTe4[(s0 >> 8) & 0xff] << 8 ^\r\nTe4[(s1 >> 16) & 0xff] << 16 ^\r\nTe4[(s2 >> 24) ] << 24 ^\r\nrk[3];\r\n#else\r\n*(u32*)(out+0) =\r\n(Te2[(s0 ) & 0xff] & 0x000000ffU) ^\r\n(Te3[(s1 >> 8) & 0xff] & 0x0000ff00U) ^\r\n(Te0[(s2 >> 16) & 0xff] & 0x00ff0000U) ^\r\n(Te1[(s3 >> 24) ] & 0xff000000U) ^\r\nrk[0];\r\n*(u32*)(out+4) =\r\n(Te2[(s1 ) & 0xff] & 0x000000ffU) ^\r\n(Te3[(s2 >> 8) & 0xff] & 0x0000ff00U) ^\r\n(Te0[(s3 >> 16) & 0xff] & 0x00ff0000U) ^\r\n(Te1[(s0 >> 24) ] & 0xff000000U) ^\r\nrk[1];\r\n*(u32*)(out+8) =\r\n(Te2[(s2 ) & 0xff] & 0x000000ffU) ^\r\n(Te3[(s3 >> 8) & 0xff] & 0x0000ff00U) ^\r\n(Te0[(s0 >> 16) & 0xff] & 0x00ff0000U) ^\r\n(Te1[(s1 >> 24) ] & 0xff000000U) ^\r\nrk[2];\r\n*(u32*)(out+12) =\r\n(Te2[(s3 ) & 0xff] & 0x000000ffU) ^\r\n(Te3[(s0 >> 8) & 0xff] & 0x0000ff00U) ^\r\n(Te0[(s1 >> 16) & 0xff] & 0x00ff0000U) ^\r\n(Te1[(s2 >> 24) ] & 0xff000000U) ^\r\nrk[3];\r\n#endif\r\n}\r\nvoid AES_decrypt(const unsigned char *in, unsigned char *out,\r\nconst AES_KEY *key) {\r\nconst u32 *rk;\r\nu32 s0, s1, s2, s3, t[4];\r\nint r;\r\nassert(in && out && key);\r\nrk = key->rd_key;\r\ns0 = GETU32(in ) ^ rk[0];\r\ns1 = GETU32(in + 4) ^ rk[1];\r\ns2 = GETU32(in + 8) ^ rk[2];\r\ns3 = GETU32(in + 12) ^ rk[3];\r\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\r\nprefetch256(Td4);\r\nt[0] = Td4[(s0 ) & 0xff] ^\r\nTd4[(s3 >> 8) & 0xff] << 8 ^\r\nTd4[(s2 >> 16) & 0xff] << 16 ^\r\nTd4[(s1 >> 24) ] << 24;\r\nt[1] = Td4[(s1 ) & 0xff] ^\r\nTd4[(s0 >> 8) & 0xff] << 8 ^\r\nTd4[(s3 >> 16) & 0xff] << 16 ^\r\nTd4[(s2 >> 24) ] << 24;\r\nt[2] = Td4[(s2 ) & 0xff] ^\r\nTd4[(s1 >> 8) & 0xff] << 8 ^\r\nTd4[(s0 >> 16) & 0xff] << 16 ^\r\nTd4[(s3 >> 24) ] << 24;\r\nt[3] = Td4[(s3 ) & 0xff] ^\r\nTd4[(s2 >> 8) & 0xff] << 8 ^\r\nTd4[(s1 >> 16) & 0xff] << 16 ^\r\nTd4[(s0 >> 24) ] << 24;\r\n{ int i;\r\nu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\r\nfor (i = 0; i < 4; i++) {\r\ntp1 = t[i];\r\nm = tp1 & 0x80808080;\r\ntp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\r\n((m - (m >> 7)) & 0x1b1b1b1b);\r\nm = tp2 & 0x80808080;\r\ntp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\r\n((m - (m >> 7)) & 0x1b1b1b1b);\r\nm = tp4 & 0x80808080;\r\ntp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\r\n((m - (m >> 7)) & 0x1b1b1b1b);\r\ntp9 = tp8 ^ tp1;\r\ntpb = tp9 ^ tp2;\r\ntpd = tp9 ^ tp4;\r\ntpe = tp8 ^ tp4 ^ tp2;\r\n#if defined(ROTATE)\r\nt[i] = tpe ^ ROTATE(tpd,16) ^\r\nROTATE(tp9,8) ^ ROTATE(tpb,24);\r\n#else\r\nt[i] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\r\n(tp9 >> 24) ^ (tp9 << 8) ^\r\n(tpb >> 8) ^ (tpb << 24);\r\n#endif\r\nt[i] ^= rk[4+i];\r\n}\r\n}\r\n#else\r\nt[0] = Td0[(s0 ) & 0xff] ^\r\nTd1[(s3 >> 8) & 0xff] ^\r\nTd2[(s2 >> 16) & 0xff] ^\r\nTd3[(s1 >> 24) ] ^\r\nrk[4];\r\nt[1] = Td0[(s1 ) & 0xff] ^\r\nTd1[(s0 >> 8) & 0xff] ^\r\nTd2[(s3 >> 16) & 0xff] ^\r\nTd3[(s2 >> 24) ] ^\r\nrk[5];\r\nt[2] = Td0[(s2 ) & 0xff] ^\r\nTd1[(s1 >> 8) & 0xff] ^\r\nTd2[(s0 >> 16) & 0xff] ^\r\nTd3[(s3 >> 24) ] ^\r\nrk[6];\r\nt[3] = Td0[(s3 ) & 0xff] ^\r\nTd1[(s2 >> 8) & 0xff] ^\r\nTd2[(s1 >> 16) & 0xff] ^\r\nTd3[(s0 >> 24) ] ^\r\nrk[7];\r\n#endif\r\ns0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\r\nfor (rk+=8,r=key->rounds-2; r>0; rk+=4,r--) {\r\n#if defined(AES_COMPACT_IN_INNER_ROUNDS)\r\nt[0] = Td4[(s0 ) & 0xff] ^\r\nTd4[(s3 >> 8) & 0xff] << 8 ^\r\nTd4[(s2 >> 16) & 0xff] << 16 ^\r\nTd4[(s1 >> 24) ] << 24;\r\nt[1] = Td4[(s1 ) & 0xff] ^\r\nTd4[(s0 >> 8) & 0xff] << 8 ^\r\nTd4[(s3 >> 16) & 0xff] << 16 ^\r\nTd4[(s2 >> 24) ] << 24;\r\nt[2] = Td4[(s2 ) & 0xff] ^\r\nTd4[(s1 >> 8) & 0xff] << 8 ^\r\nTd4[(s0 >> 16) & 0xff] << 16 ^\r\nTd4[(s3 >> 24) ] << 24;\r\nt[3] = Td4[(s3 ) & 0xff] ^\r\nTd4[(s2 >> 8) & 0xff] << 8 ^\r\nTd4[(s1 >> 16) & 0xff] << 16 ^\r\nTd4[(s0 >> 24) ] << 24;\r\n{ int i;\r\nu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\r\nfor (i = 0; i < 4; i++) {\r\ntp1 = t[i];\r\nm = tp1 & 0x80808080;\r\ntp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\r\n((m - (m >> 7)) & 0x1b1b1b1b);\r\nm = tp2 & 0x80808080;\r\ntp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\r\n((m - (m >> 7)) & 0x1b1b1b1b);\r\nm = tp4 & 0x80808080;\r\ntp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\r\n((m - (m >> 7)) & 0x1b1b1b1b);\r\ntp9 = tp8 ^ tp1;\r\ntpb = tp9 ^ tp2;\r\ntpd = tp9 ^ tp4;\r\ntpe = tp8 ^ tp4 ^ tp2;\r\n#if defined(ROTATE)\r\nt[i] = tpe ^ ROTATE(tpd,16) ^\r\nROTATE(tp9,8) ^ ROTATE(tpb,24);\r\n#else\r\nt[i] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\r\n(tp9 >> 24) ^ (tp9 << 8) ^\r\n(tpb >> 8) ^ (tpb << 24);\r\n#endif\r\nt[i] ^= rk[i];\r\n}\r\n}\r\n#else\r\nt[0] = Td0[(s0 ) & 0xff] ^\r\nTd1[(s3 >> 8) & 0xff] ^\r\nTd2[(s2 >> 16) & 0xff] ^\r\nTd3[(s1 >> 24) ] ^\r\nrk[0];\r\nt[1] = Td0[(s1 ) & 0xff] ^\r\nTd1[(s0 >> 8) & 0xff] ^\r\nTd2[(s3 >> 16) & 0xff] ^\r\nTd3[(s2 >> 24) ] ^\r\nrk[1];\r\nt[2] = Td0[(s2 ) & 0xff] ^\r\nTd1[(s1 >> 8) & 0xff] ^\r\nTd2[(s0 >> 16) & 0xff] ^\r\nTd3[(s3 >> 24) ] ^\r\nrk[2];\r\nt[3] = Td0[(s3 ) & 0xff] ^\r\nTd1[(s2 >> 8) & 0xff] ^\r\nTd2[(s1 >> 16) & 0xff] ^\r\nTd3[(s0 >> 24) ] ^\r\nrk[3];\r\n#endif\r\ns0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\r\n}\r\nprefetch256(Td4);\r\n*(u32*)(out+0) =\r\n(Td4[(s0 ) & 0xff]) ^\r\n(Td4[(s3 >> 8) & 0xff] << 8) ^\r\n(Td4[(s2 >> 16) & 0xff] << 16) ^\r\n(Td4[(s1 >> 24) ] << 24) ^\r\nrk[0];\r\n*(u32*)(out+4) =\r\n(Td4[(s1 ) & 0xff]) ^\r\n(Td4[(s0 >> 8) & 0xff] << 8) ^\r\n(Td4[(s3 >> 16) & 0xff] << 16) ^\r\n(Td4[(s2 >> 24) ] << 24) ^\r\nrk[1];\r\n*(u32*)(out+8) =\r\n(Td4[(s2 ) & 0xff]) ^\r\n(Td4[(s1 >> 8) & 0xff] << 8) ^\r\n(Td4[(s0 >> 16) & 0xff] << 16) ^\r\n(Td4[(s3 >> 24) ] << 24) ^\r\nrk[2];\r\n*(u32*)(out+12) =\r\n(Td4[(s3 ) & 0xff]) ^\r\n(Td4[(s2 >> 8) & 0xff] << 8) ^\r\n(Td4[(s1 >> 16) & 0xff] << 16) ^\r\n(Td4[(s0 >> 24) ] << 24) ^\r\nrk[3];\r\n}
