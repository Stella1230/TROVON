static const char *get_CCA4758_LIB_NAME(void)\r\n{\r\nif(CCA4758_LIB_NAME)\r\nreturn CCA4758_LIB_NAME;\r\nreturn CCA_LIB_NAME;\r\n}\r\nstatic void free_CCA4758_LIB_NAME(void)\r\n{\r\nif(CCA4758_LIB_NAME)\r\nOPENSSL_free((void*)CCA4758_LIB_NAME);\r\nCCA4758_LIB_NAME = NULL;\r\n}\r\nstatic long set_CCA4758_LIB_NAME(const char *name)\r\n{\r\nfree_CCA4758_LIB_NAME();\r\nreturn (((CCA4758_LIB_NAME = BUF_strdup(name)) != NULL) ? 1 : 0);\r\n}\r\nstatic int bind_helper(ENGINE *e)\r\n{\r\nif(!ENGINE_set_id(e, engine_4758_cca_id) ||\r\n!ENGINE_set_name(e, engine_4758_cca_name) ||\r\n#ifndef OPENSSL_NO_RSA\r\n!ENGINE_set_RSA(e, &ibm_4758_cca_rsa) ||\r\n#endif\r\n!ENGINE_set_RAND(e, &ibm_4758_cca_rand) ||\r\n!ENGINE_set_destroy_function(e, ibm_4758_cca_destroy) ||\r\n!ENGINE_set_init_function(e, ibm_4758_cca_init) ||\r\n!ENGINE_set_finish_function(e, ibm_4758_cca_finish) ||\r\n!ENGINE_set_ctrl_function(e, ibm_4758_cca_ctrl) ||\r\n#ifndef OPENSSL_NO_RSA\r\n!ENGINE_set_load_privkey_function(e, ibm_4758_load_privkey) ||\r\n!ENGINE_set_load_pubkey_function(e, ibm_4758_load_pubkey) ||\r\n#endif\r\n!ENGINE_set_cmd_defns(e, cca4758_cmd_defns))\r\nreturn 0;\r\nERR_load_CCA4758_strings();\r\nreturn 1;\r\n}\r\nstatic ENGINE *engine_4758_cca(void)\r\n{\r\nENGINE *ret = ENGINE_new();\r\nif(!ret)\r\nreturn NULL;\r\nif(!bind_helper(ret))\r\n{\r\nENGINE_free(ret);\r\nreturn NULL;\r\n}\r\nreturn ret;\r\n}\r\nvoid ENGINE_load_4758cca(void)\r\n{\r\nENGINE *e_4758 = engine_4758_cca();\r\nif (!e_4758) return;\r\nENGINE_add(e_4758);\r\nENGINE_free(e_4758);\r\nERR_clear_error();\r\n}\r\nstatic int ibm_4758_cca_destroy(ENGINE *e)\r\n{\r\nERR_unload_CCA4758_strings();\r\nfree_CCA4758_LIB_NAME();\r\nreturn 1;\r\n}\r\nstatic int ibm_4758_cca_init(ENGINE *e)\r\n{\r\nif(dso)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_CCA_INIT,CCA4758_R_ALREADY_LOADED);\r\ngoto err;\r\n}\r\ndso = DSO_load(NULL, get_CCA4758_LIB_NAME(), NULL, 0);\r\nif(!dso)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_CCA_INIT,CCA4758_R_DSO_FAILURE);\r\ngoto err;\r\n}\r\n#ifndef OPENSSL_NO_RSA\r\nif(!(keyRecordRead = (F_KEYRECORDREAD)\r\nDSO_bind_func(dso, n_keyRecordRead)) ||\r\n!(randomNumberGenerate = (F_RANDOMNUMBERGENERATE)\r\nDSO_bind_func(dso, n_randomNumberGenerate)) ||\r\n!(digitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE)\r\nDSO_bind_func(dso, n_digitalSignatureGenerate)) ||\r\n!(digitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)\r\nDSO_bind_func(dso, n_digitalSignatureVerify)) ||\r\n!(publicKeyExtract = (F_PUBLICKEYEXTRACT)\r\nDSO_bind_func(dso, n_publicKeyExtract)) ||\r\n!(pkaEncrypt = (F_PKAENCRYPT)\r\nDSO_bind_func(dso, n_pkaEncrypt)) ||\r\n!(pkaDecrypt = (F_PKADECRYPT)\r\nDSO_bind_func(dso, n_pkaDecrypt)))\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_CCA_INIT,CCA4758_R_DSO_FAILURE);\r\ngoto err;\r\n}\r\n#else\r\nif(!(randomNumberGenerate = (F_RANDOMNUMBERGENERATE)\r\nDSO_bind_func(dso, n_randomNumberGenerate)))\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_CCA_INIT,CCA4758_R_DSO_FAILURE);\r\ngoto err;\r\n}\r\n#endif\r\n#ifndef OPENSSL_NO_RSA\r\nhndidx = RSA_get_ex_new_index(0, "IBM 4758 CCA RSA key handle",\r\nNULL, NULL, cca_ex_free);\r\n#endif\r\nreturn 1;\r\nerr:\r\nif(dso)\r\nDSO_free(dso);\r\ndso = NULL;\r\n#ifndef OPENSSL_NO_RSA\r\nkeyRecordRead = (F_KEYRECORDREAD)0;\r\ndigitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE)0;\r\ndigitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)0;\r\npublicKeyExtract = (F_PUBLICKEYEXTRACT)0;\r\npkaEncrypt = (F_PKAENCRYPT)0;\r\npkaDecrypt = (F_PKADECRYPT)0;\r\n#endif\r\nrandomNumberGenerate = (F_RANDOMNUMBERGENERATE)0;\r\nreturn 0;\r\n}\r\nstatic int ibm_4758_cca_finish(ENGINE *e)\r\n{\r\nfree_CCA4758_LIB_NAME();\r\nif(!dso)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_CCA_FINISH,\r\nCCA4758_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\nif(!DSO_free(dso))\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_CCA_FINISH,\r\nCCA4758_R_UNIT_FAILURE);\r\nreturn 0;\r\n}\r\ndso = NULL;\r\n#ifndef OPENSSL_NO_RSA\r\nkeyRecordRead = (F_KEYRECORDREAD)0;\r\nrandomNumberGenerate = (F_RANDOMNUMBERGENERATE)0;\r\ndigitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE)0;\r\ndigitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)0;\r\npublicKeyExtract = (F_PUBLICKEYEXTRACT)0;\r\npkaEncrypt = (F_PKAENCRYPT)0;\r\npkaDecrypt = (F_PKADECRYPT)0;\r\n#endif\r\nrandomNumberGenerate = (F_RANDOMNUMBERGENERATE)0;\r\nreturn 1;\r\n}\r\nstatic int ibm_4758_cca_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)(void))\r\n{\r\nint initialised = ((dso == NULL) ? 0 : 1);\r\nswitch(cmd)\r\n{\r\ncase CCA4758_CMD_SO_PATH:\r\nif(p == NULL)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_CCA_CTRL,\r\nERR_R_PASSED_NULL_PARAMETER);\r\nreturn 0;\r\n}\r\nif(initialised)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_CCA_CTRL,\r\nCCA4758_R_ALREADY_LOADED);\r\nreturn 0;\r\n}\r\nreturn set_CCA4758_LIB_NAME((const char *)p);\r\ndefault:\r\nbreak;\r\n}\r\nCCA4758err(CCA4758_F_IBM_4758_CCA_CTRL,\r\nCCA4758_R_COMMAND_NOT_IMPLEMENTED);\r\nreturn 0;\r\n}\r\nstatic EVP_PKEY *ibm_4758_load_privkey(ENGINE* e, const char* key_id,\r\nUI_METHOD *ui_method, void *callback_data)\r\n{\r\nRSA *rtmp = NULL;\r\nEVP_PKEY *res = NULL;\r\nunsigned char* keyToken = NULL;\r\nunsigned char pubKeyToken[MAX_CCA_PKA_TOKEN_SIZE];\r\nlong pubKeyTokenLength = MAX_CCA_PKA_TOKEN_SIZE;\r\nlong keyTokenLength = MAX_CCA_PKA_TOKEN_SIZE;\r\nlong returnCode;\r\nlong reasonCode;\r\nlong exitDataLength = 0;\r\nlong ruleArrayLength = 0;\r\nunsigned char exitData[8];\r\nunsigned char ruleArray[8];\r\nunsigned char keyLabel[64];\r\nunsigned long keyLabelLength = strlen(key_id);\r\nunsigned char modulus[256];\r\nlong modulusFieldLength = sizeof(modulus);\r\nlong modulusLength = 0;\r\nunsigned char exponent[256];\r\nlong exponentLength = sizeof(exponent);\r\nif (keyLabelLength > sizeof(keyLabel))\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\r\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\r\nreturn NULL;\r\n}\r\nmemset(keyLabel,' ', sizeof(keyLabel));\r\nmemcpy(keyLabel, key_id, keyLabelLength);\r\nkeyToken = OPENSSL_malloc(MAX_CCA_PKA_TOKEN_SIZE + sizeof(long));\r\nif (!keyToken)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\r\nERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\nkeyRecordRead(&returnCode, &reasonCode, &exitDataLength,\r\nexitData, &ruleArrayLength, ruleArray, keyLabel,\r\n&keyTokenLength, keyToken+sizeof(long));\r\nif (returnCode)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\r\nCCA4758_R_FAILED_LOADING_PRIVATE_KEY);\r\ngoto err;\r\n}\r\npublicKeyExtract(&returnCode, &reasonCode, &exitDataLength,\r\nexitData, &ruleArrayLength, ruleArray, &keyTokenLength,\r\nkeyToken+sizeof(long), &pubKeyTokenLength, pubKeyToken);\r\nif (returnCode)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\r\nCCA4758_R_FAILED_LOADING_PRIVATE_KEY);\r\ngoto err;\r\n}\r\nif (!getModulusAndExponent(pubKeyToken, &exponentLength,\r\nexponent, &modulusLength, &modulusFieldLength,\r\nmodulus))\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PRIVKEY,\r\nCCA4758_R_FAILED_LOADING_PRIVATE_KEY);\r\ngoto err;\r\n}\r\n(*(long*)keyToken) = keyTokenLength;\r\nrtmp = RSA_new_method(e);\r\nRSA_set_ex_data(rtmp, hndidx, (char *)keyToken);\r\nrtmp->e = BN_bin2bn(exponent, exponentLength, NULL);\r\nrtmp->n = BN_bin2bn(modulus, modulusFieldLength, NULL);\r\nrtmp->flags |= RSA_FLAG_EXT_PKEY;\r\nres = EVP_PKEY_new();\r\nEVP_PKEY_assign_RSA(res, rtmp);\r\nreturn res;\r\nerr:\r\nif (keyToken)\r\nOPENSSL_free(keyToken);\r\nreturn NULL;\r\n}\r\nstatic EVP_PKEY *ibm_4758_load_pubkey(ENGINE* e, const char* key_id,\r\nUI_METHOD *ui_method, void *callback_data)\r\n{\r\nRSA *rtmp = NULL;\r\nEVP_PKEY *res = NULL;\r\nunsigned char* keyToken = NULL;\r\nlong keyTokenLength = MAX_CCA_PKA_TOKEN_SIZE;\r\nlong returnCode;\r\nlong reasonCode;\r\nlong exitDataLength = 0;\r\nlong ruleArrayLength = 0;\r\nunsigned char exitData[8];\r\nunsigned char ruleArray[8];\r\nunsigned char keyLabel[64];\r\nunsigned long keyLabelLength = strlen(key_id);\r\nunsigned char modulus[512];\r\nlong modulusFieldLength = sizeof(modulus);\r\nlong modulusLength = 0;\r\nunsigned char exponent[512];\r\nlong exponentLength = sizeof(exponent);\r\nif (keyLabelLength > sizeof(keyLabel))\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PUBKEY,\r\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\r\nreturn NULL;\r\n}\r\nmemset(keyLabel,' ', sizeof(keyLabel));\r\nmemcpy(keyLabel, key_id, keyLabelLength);\r\nkeyToken = OPENSSL_malloc(MAX_CCA_PKA_TOKEN_SIZE + sizeof(long));\r\nif (!keyToken)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PUBKEY,\r\nERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\nkeyRecordRead(&returnCode, &reasonCode, &exitDataLength, exitData,\r\n&ruleArrayLength, ruleArray, keyLabel, &keyTokenLength,\r\nkeyToken+sizeof(long));\r\nif (returnCode)\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PUBKEY,\r\nERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\nif (!getModulusAndExponent(keyToken+sizeof(long), &exponentLength,\r\nexponent, &modulusLength, &modulusFieldLength, modulus))\r\n{\r\nCCA4758err(CCA4758_F_IBM_4758_LOAD_PUBKEY,\r\nCCA4758_R_FAILED_LOADING_PUBLIC_KEY);\r\ngoto err;\r\n}\r\n(*(long*)keyToken) = keyTokenLength;\r\nrtmp = RSA_new_method(e);\r\nRSA_set_ex_data(rtmp, hndidx, (char *)keyToken);\r\nrtmp->e = BN_bin2bn(exponent, exponentLength, NULL);\r\nrtmp->n = BN_bin2bn(modulus, modulusFieldLength, NULL);\r\nrtmp->flags |= RSA_FLAG_EXT_PKEY;\r\nres = EVP_PKEY_new();\r\nEVP_PKEY_assign_RSA(res, rtmp);\r\nreturn res;\r\nerr:\r\nif (keyToken)\r\nOPENSSL_free(keyToken);\r\nreturn NULL;\r\n}\r\nstatic int cca_rsa_pub_enc(int flen, const unsigned char *from,\r\nunsigned char *to, RSA *rsa,int padding)\r\n{\r\nlong returnCode;\r\nlong reasonCode;\r\nlong lflen = flen;\r\nlong exitDataLength = 0;\r\nunsigned char exitData[8];\r\nlong ruleArrayLength = 1;\r\nunsigned char ruleArray[8] = "PKCS-1.2";\r\nlong dataStructureLength = 0;\r\nunsigned char dataStructure[8];\r\nlong outputLength = RSA_size(rsa);\r\nlong keyTokenLength;\r\nunsigned char* keyToken = (unsigned char*)RSA_get_ex_data(rsa, hndidx);\r\nkeyTokenLength = *(long*)keyToken;\r\nkeyToken+=sizeof(long);\r\npkaEncrypt(&returnCode, &reasonCode, &exitDataLength, exitData,\r\n&ruleArrayLength, ruleArray, &lflen, (unsigned char*)from,\r\n&dataStructureLength, dataStructure, &keyTokenLength,\r\nkeyToken, &outputLength, to);\r\nif (returnCode || reasonCode)\r\nreturn -(returnCode << 16 | reasonCode);\r\nreturn outputLength;\r\n}\r\nstatic int cca_rsa_priv_dec(int flen, const unsigned char *from,\r\nunsigned char *to, RSA *rsa,int padding)\r\n{\r\nlong returnCode;\r\nlong reasonCode;\r\nlong lflen = flen;\r\nlong exitDataLength = 0;\r\nunsigned char exitData[8];\r\nlong ruleArrayLength = 1;\r\nunsigned char ruleArray[8] = "PKCS-1.2";\r\nlong dataStructureLength = 0;\r\nunsigned char dataStructure[8];\r\nlong outputLength = RSA_size(rsa);\r\nlong keyTokenLength;\r\nunsigned char* keyToken = (unsigned char*)RSA_get_ex_data(rsa, hndidx);\r\nkeyTokenLength = *(long*)keyToken;\r\nkeyToken+=sizeof(long);\r\npkaDecrypt(&returnCode, &reasonCode, &exitDataLength, exitData,\r\n&ruleArrayLength, ruleArray, &lflen, (unsigned char*)from,\r\n&dataStructureLength, dataStructure, &keyTokenLength,\r\nkeyToken, &outputLength, to);\r\nreturn (returnCode | reasonCode) ? 0 : 1;\r\n}\r\nstatic int cca_rsa_verify(int type, const unsigned char *m, unsigned int m_len,\r\nconst unsigned char *sigbuf, unsigned int siglen, const RSA *rsa)\r\n{\r\nlong returnCode;\r\nlong reasonCode;\r\nlong lsiglen = siglen;\r\nlong exitDataLength = 0;\r\nunsigned char exitData[8];\r\nlong ruleArrayLength = 1;\r\nunsigned char ruleArray[8] = "PKCS-1.1";\r\nlong keyTokenLength;\r\nunsigned char* keyToken = (unsigned char*)RSA_get_ex_data(rsa, hndidx);\r\nlong length = SSL_SIG_LEN;\r\nlong keyLength ;\r\nunsigned char *hashBuffer = NULL;\r\nX509_SIG sig;\r\nASN1_TYPE parameter;\r\nX509_ALGOR algorithm;\r\nASN1_OCTET_STRING digest;\r\nkeyTokenLength = *(long*)keyToken;\r\nkeyToken+=sizeof(long);\r\nif (type == NID_md5 || type == NID_sha1)\r\n{\r\nsig.algor = &algorithm;\r\nalgorithm.algorithm = OBJ_nid2obj(type);\r\nif (!algorithm.algorithm)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\r\nCCA4758_R_UNKNOWN_ALGORITHM_TYPE);\r\nreturn 0;\r\n}\r\nif (!algorithm.algorithm->length)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\r\nCCA4758_R_ASN1_OID_UNKNOWN_FOR_MD);\r\nreturn 0;\r\n}\r\nparameter.type = V_ASN1_NULL;\r\nparameter.value.ptr = NULL;\r\nalgorithm.parameter = &parameter;\r\nsig.digest = &digest;\r\nsig.digest->data = (unsigned char*)m;\r\nsig.digest->length = m_len;\r\nlength = i2d_X509_SIG(&sig, NULL);\r\n}\r\nkeyLength = RSA_size(rsa);\r\nif (length - RSA_PKCS1_PADDING > keyLength)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\r\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\r\nreturn 0;\r\n}\r\nswitch (type)\r\n{\r\ncase NID_md5_sha1 :\r\nif (m_len != SSL_SIG_LEN)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\r\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\r\nreturn 0;\r\n}\r\nhashBuffer = (unsigned char *)m;\r\nlength = m_len;\r\nbreak;\r\ncase NID_md5 :\r\n{\r\nunsigned char *ptr;\r\nptr = hashBuffer = OPENSSL_malloc(\r\n(unsigned int)keyLength+1);\r\nif (!hashBuffer)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\r\nERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\ni2d_X509_SIG(&sig, &ptr);\r\n}\r\nbreak;\r\ncase NID_sha1 :\r\n{\r\nunsigned char *ptr;\r\nptr = hashBuffer = OPENSSL_malloc(\r\n(unsigned int)keyLength+1);\r\nif (!hashBuffer)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_VERIFY,\r\nERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\ni2d_X509_SIG(&sig, &ptr);\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ndigitalSignatureVerify(&returnCode, &reasonCode, &exitDataLength,\r\nexitData, &ruleArrayLength, ruleArray, &keyTokenLength,\r\nkeyToken, &length, hashBuffer, &lsiglen,\r\n(unsigned char *)sigbuf);\r\nif (type == NID_sha1 || type == NID_md5)\r\n{\r\nOPENSSL_cleanse(hashBuffer, keyLength+1);\r\nOPENSSL_free(hashBuffer);\r\n}\r\nreturn ((returnCode || reasonCode) ? 0 : 1);\r\n}\r\nstatic int cca_rsa_sign(int type, const unsigned char *m, unsigned int m_len,\r\nunsigned char *sigret, unsigned int *siglen, const RSA *rsa)\r\n{\r\nlong returnCode;\r\nlong reasonCode;\r\nlong exitDataLength = 0;\r\nunsigned char exitData[8];\r\nlong ruleArrayLength = 1;\r\nunsigned char ruleArray[8] = "PKCS-1.1";\r\nlong outputLength=256;\r\nlong outputBitLength;\r\nlong keyTokenLength;\r\nunsigned char *hashBuffer = NULL;\r\nunsigned char* keyToken = (unsigned char*)RSA_get_ex_data(rsa, hndidx);\r\nlong length = SSL_SIG_LEN;\r\nlong keyLength ;\r\nX509_SIG sig;\r\nASN1_TYPE parameter;\r\nX509_ALGOR algorithm;\r\nASN1_OCTET_STRING digest;\r\nkeyTokenLength = *(long*)keyToken;\r\nkeyToken+=sizeof(long);\r\nif (type == NID_md5 || type == NID_sha1)\r\n{\r\nsig.algor = &algorithm;\r\nalgorithm.algorithm = OBJ_nid2obj(type);\r\nif (!algorithm.algorithm)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\r\nCCA4758_R_UNKNOWN_ALGORITHM_TYPE);\r\nreturn 0;\r\n}\r\nif (!algorithm.algorithm->length)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\r\nCCA4758_R_ASN1_OID_UNKNOWN_FOR_MD);\r\nreturn 0;\r\n}\r\nparameter.type = V_ASN1_NULL;\r\nparameter.value.ptr = NULL;\r\nalgorithm.parameter = &parameter;\r\nsig.digest = &digest;\r\nsig.digest->data = (unsigned char*)m;\r\nsig.digest->length = m_len;\r\nlength = i2d_X509_SIG(&sig, NULL);\r\n}\r\nkeyLength = RSA_size(rsa);\r\nif (length - RSA_PKCS1_PADDING > keyLength)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\r\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\r\nreturn 0;\r\n}\r\nswitch (type)\r\n{\r\ncase NID_md5_sha1 :\r\nif (m_len != SSL_SIG_LEN)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\r\nCCA4758_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\r\nreturn 0;\r\n}\r\nhashBuffer = (unsigned char*)m;\r\nlength = m_len;\r\nbreak;\r\ncase NID_md5 :\r\n{\r\nunsigned char *ptr;\r\nptr = hashBuffer = OPENSSL_malloc(\r\n(unsigned int)keyLength+1);\r\nif (!hashBuffer)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\r\nERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\ni2d_X509_SIG(&sig, &ptr);\r\n}\r\nbreak;\r\ncase NID_sha1 :\r\n{\r\nunsigned char *ptr;\r\nptr = hashBuffer = OPENSSL_malloc(\r\n(unsigned int)keyLength+1);\r\nif (!hashBuffer)\r\n{\r\nCCA4758err(CCA4758_F_CCA_RSA_SIGN,\r\nERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\ni2d_X509_SIG(&sig, &ptr);\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\ndigitalSignatureGenerate(&returnCode, &reasonCode, &exitDataLength,\r\nexitData, &ruleArrayLength, ruleArray, &keyTokenLength,\r\nkeyToken, &length, hashBuffer, &outputLength, &outputBitLength,\r\nsigret);\r\nif (type == NID_sha1 || type == NID_md5)\r\n{\r\nOPENSSL_cleanse(hashBuffer, keyLength+1);\r\nOPENSSL_free(hashBuffer);\r\n}\r\n*siglen = outputLength;\r\nreturn ((returnCode || reasonCode) ? 0 : 1);\r\n}\r\nstatic int getModulusAndExponent(const unsigned char*token, long *exponentLength,\r\nunsigned char *exponent, long *modulusLength, long *modulusFieldLength,\r\nunsigned char *modulus)\r\n{\r\nunsigned long len;\r\nif (*token++ != (char)0x1E)\r\nreturn 0;\r\nif (*token++)\r\nreturn 0;\r\nlen = *token++;\r\nlen = len << 8;\r\nlen |= (unsigned char)*token++;\r\ntoken += 4;\r\nif (*token++ == (char)0x04)\r\n{\r\nif (*token++)\r\nreturn 0;\r\nlen = *token++;\r\nlen = len << 8;\r\nlen |= (unsigned char)*token++;\r\ntoken+=2;\r\nlen = *token++;\r\nlen = len << 8;\r\nlen |= (unsigned char)*token++;\r\n*exponentLength = len;\r\nlen = *token++;\r\nlen = len << 8;\r\nlen |= (unsigned char)*token++;\r\n*modulusLength = len;\r\nlen = *token++;\r\nlen = len << 8;\r\nlen |= (unsigned char)*token++;\r\n*modulusFieldLength = len;\r\nmemcpy(exponent, token, *exponentLength);\r\ntoken+= *exponentLength;\r\nmemcpy(modulus, token, *modulusFieldLength);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cca_random_status(void)\r\n{\r\nreturn 1;\r\n}\r\nstatic int cca_get_random_bytes(unsigned char* buf, int num)\r\n{\r\nlong ret_code;\r\nlong reason_code;\r\nlong exit_data_length;\r\nunsigned char exit_data[4];\r\nunsigned char form[] = "RANDOM ";\r\nunsigned char rand_buf[8];\r\nwhile(num >= (int)sizeof(rand_buf))\r\n{\r\nrandomNumberGenerate(&ret_code, &reason_code, &exit_data_length,\r\nexit_data, form, rand_buf);\r\nif (ret_code)\r\nreturn 0;\r\nnum -= sizeof(rand_buf);\r\nmemcpy(buf, rand_buf, sizeof(rand_buf));\r\nbuf += sizeof(rand_buf);\r\n}\r\nif (num)\r\n{\r\nrandomNumberGenerate(&ret_code, &reason_code, NULL, NULL,\r\nform, rand_buf);\r\nif (ret_code)\r\nreturn 0;\r\nmemcpy(buf, rand_buf, num);\r\n}\r\nreturn 1;\r\n}\r\nstatic void cca_ex_free(void *obj, void *item, CRYPTO_EX_DATA *ad, int idx,\r\nlong argl, void *argp)\r\n{\r\nif (item)\r\nOPENSSL_free(item);\r\n}\r\nstatic int bind_fn(ENGINE *e, const char *id)\r\n{\r\nif(id && (strcmp(id, engine_4758_cca_id) != 0) &&\r\n(strcmp(id, engine_4758_cca_id_alt) != 0))\r\nreturn 0;\r\nif(!bind_helper(e))\r\nreturn 0;\r\nreturn 1;\r\n}
