void PKCS12_PBE_add(void)\r\n{\r\n}\r\nint PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\r\nASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de)\r\n{\r\nPBEPARAM *pbe;\r\nint saltlen, iter, ret;\r\nunsigned char *salt;\r\nconst unsigned char *pbuf;\r\nunsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];\r\nif (param == NULL || param->type != V_ASN1_SEQUENCE ||\r\nparam->value.sequence == NULL) {\r\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_DECODE_ERROR);\r\nreturn 0;\r\n}\r\npbuf = param->value.sequence->data;\r\nif (!(pbe = d2i_PBEPARAM(NULL, &pbuf, param->value.sequence->length))) {\r\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_DECODE_ERROR);\r\nreturn 0;\r\n}\r\nif (!pbe->iter) iter = 1;\r\nelse iter = ASN1_INTEGER_get (pbe->iter);\r\nsalt = pbe->salt->data;\r\nsaltlen = pbe->salt->length;\r\nif (!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_KEY_ID,\r\niter, EVP_CIPHER_key_length(cipher), key, md)) {\r\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_KEY_GEN_ERROR);\r\nPBEPARAM_free(pbe);\r\nreturn 0;\r\n}\r\nif (!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_IV_ID,\r\niter, EVP_CIPHER_iv_length(cipher), iv, md)) {\r\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_IV_GEN_ERROR);\r\nPBEPARAM_free(pbe);\r\nreturn 0;\r\n}\r\nPBEPARAM_free(pbe);\r\nret = EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, en_de);\r\nOPENSSL_cleanse(key, EVP_MAX_KEY_LENGTH);\r\nOPENSSL_cleanse(iv, EVP_MAX_IV_LENGTH);\r\nreturn ret;\r\n}
