int MAIN(int argc, char **argv)\r\n{\r\nint ret = 1;\r\nchar *configfile = NULL;\r\nchar *section = NULL;\r\nCONF *conf = NULL;\r\nenum mode {\r\nCMD_NONE, CMD_QUERY, CMD_REPLY, CMD_VERIFY\r\n} mode = CMD_NONE;\r\nchar *data = NULL;\r\nchar *digest = NULL;\r\nconst EVP_MD *md = NULL;\r\nchar *rnd = NULL;\r\nchar *policy = NULL;\r\nint no_nonce = 0;\r\nint cert = 0;\r\nchar *in = NULL;\r\nchar *out = NULL;\r\nint text = 0;\r\nchar *queryfile = NULL;\r\nchar *passin = NULL;\r\nchar *password =NULL;\r\nchar *inkey = NULL;\r\nchar *signer = NULL;\r\nchar *chain = NULL;\r\nchar *ca_path = NULL;\r\nchar *ca_file = NULL;\r\nchar *untrusted = NULL;\r\nchar *engine = NULL;\r\nint token_in = 0;\r\nint token_out = 0;\r\nint free_bio_err = 0;\r\nERR_load_crypto_strings();\r\napps_startup();\r\nif (bio_err == NULL && (bio_err = BIO_new(BIO_s_file())) != NULL)\r\n{\r\nfree_bio_err = 1;\r\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\r\n}\r\nif (!load_config(bio_err, NULL))\r\ngoto cleanup;\r\nfor (argc--, argv++; argc > 0; argc--, argv++)\r\n{\r\nif (strcmp(*argv, "-config") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nconfigfile = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-section") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nsection = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-query") == 0)\r\n{\r\nif (mode != CMD_NONE) goto usage;\r\nmode = CMD_QUERY;\r\n}\r\nelse if (strcmp(*argv, "-data") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\ndata = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-digest") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\ndigest = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-rand") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nrnd = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-policy") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\npolicy = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-no_nonce") == 0)\r\n{\r\nno_nonce = 1;\r\n}\r\nelse if (strcmp(*argv, "-cert") == 0)\r\n{\r\ncert = 1;\r\n}\r\nelse if (strcmp(*argv, "-in") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nin = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-token_in") == 0)\r\n{\r\ntoken_in = 1;\r\n}\r\nelse if (strcmp(*argv, "-out") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nout = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-token_out") == 0)\r\n{\r\ntoken_out = 1;\r\n}\r\nelse if (strcmp(*argv, "-text") == 0)\r\n{\r\ntext = 1;\r\n}\r\nelse if (strcmp(*argv, "-reply") == 0)\r\n{\r\nif (mode != CMD_NONE) goto usage;\r\nmode = CMD_REPLY;\r\n}\r\nelse if (strcmp(*argv, "-queryfile") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nqueryfile = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-passin") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\npassin = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-inkey") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\ninkey = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-signer") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nsigner = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-chain") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nchain = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-verify") == 0)\r\n{\r\nif (mode != CMD_NONE) goto usage;\r\nmode = CMD_VERIFY;\r\n}\r\nelse if (strcmp(*argv, "-CApath") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nca_path = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-CAfile") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nca_file = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-untrusted") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nuntrusted = *++argv;\r\n}\r\nelse if (strcmp(*argv, "-engine") == 0)\r\n{\r\nif (argc-- < 1) goto usage;\r\nengine = *++argv;\r\n}\r\nelse if ((md = EVP_get_digestbyname(*argv + 1)) != NULL)\r\n{\r\n}\r\nelse\r\ngoto usage;\r\n}\r\nif (mode == CMD_QUERY && !no_nonce)\r\n{\r\nif (!app_RAND_load_file(NULL, bio_err, 1) && rnd == NULL)\r\nBIO_printf(bio_err, "warning, not much extra random "\r\n"data, consider using the -rand option\n");\r\nif (rnd != NULL)\r\nBIO_printf(bio_err,"%ld semi-random bytes loaded\n",\r\napp_RAND_load_files(rnd));\r\n}\r\nif(mode == CMD_REPLY && passin &&\r\n!app_passwd(bio_err, passin, NULL, &password, NULL))\r\n{\r\nBIO_printf(bio_err,"Error getting password.\n");\r\ngoto cleanup;\r\n}\r\nswitch (mode)\r\n{\r\ncase CMD_NONE:\r\ngoto usage;\r\ncase CMD_QUERY:\r\nret = data != NULL && digest != NULL;\r\nif (ret) goto usage;\r\nconf = load_config_file(configfile);\r\nret = !query_command(data, digest, md, policy, no_nonce, cert,\r\nin, out, text);\r\nbreak;\r\ncase CMD_REPLY:\r\nconf = load_config_file(configfile);\r\nif (in == NULL)\r\n{\r\nret = !(queryfile != NULL && conf != NULL && !token_in);\r\nif (ret) goto usage;\r\n}\r\nelse\r\n{\r\nret = !(queryfile == NULL);\r\nif (ret) goto usage;\r\n}\r\nret = !reply_command(conf, section, engine, queryfile,\r\npassword, inkey, signer, chain, policy,\r\nin, token_in, out, token_out, text);\r\nbreak;\r\ncase CMD_VERIFY:\r\nret = !(((queryfile && !data && !digest)\r\n|| (!queryfile && data && !digest)\r\n|| (!queryfile && !data && digest))\r\n&& in != NULL);\r\nif (ret) goto usage;\r\nret = !verify_command(data, digest, queryfile, in, token_in,\r\nca_path, ca_file, untrusted);\r\n}\r\ngoto cleanup;\r\nusage:\r\nBIO_printf(bio_err, "usage:\n"\r\n"ts -query [-rand file%cfile%c...] [-config configfile] "\r\n"[-data file_to_hash] [-digest digest_bytes]"\r\n"[-md2|-md4|-md5|-sha|-sha1|-mdc2|-ripemd160] "\r\n"[-policy object_id] [-no_nonce] [-cert] "\r\n"[-in request.tsq] [-out request.tsq] [-text]\n",\r\nLIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\r\nBIO_printf(bio_err, "or\n"\r\n"ts -reply [-config configfile] [-section tsa_section] "\r\n"[-queryfile request.tsq] [-passin password] "\r\n"[-signer tsa_cert.pem] [-inkey private_key.pem] "\r\n"[-chain certs_file.pem] [-policy object_id] "\r\n"[-in response.tsr] [-token_in] "\r\n"[-out response.tsr] [-token_out] [-text] [-engine id]\n");\r\nBIO_printf(bio_err, "or\n"\r\n"ts -verify [-data file_to_hash] [-digest digest_bytes] "\r\n"[-queryfile request.tsq] "\r\n"-in response.tsr [-token_in] "\r\n"-CApath ca_path -CAfile ca_file.pem "\r\n"-untrusted cert_file.pem\n");\r\ncleanup:\r\napp_RAND_write_file(NULL, bio_err);\r\nNCONF_free(conf);\r\nOPENSSL_free(password);\r\nOBJ_cleanup();\r\nif (free_bio_err)\r\n{\r\nBIO_free_all(bio_err);\r\nbio_err = NULL;\r\n}\r\nOPENSSL_EXIT(ret);\r\n}\r\nstatic ASN1_OBJECT *txt2obj(const char *oid)\r\n{\r\nASN1_OBJECT *oid_obj = NULL;\r\nif (!(oid_obj = OBJ_txt2obj(oid, 0)))\r\nBIO_printf(bio_err, "cannot convert %s to OID\n", oid);\r\nreturn oid_obj;\r\n}\r\nstatic CONF *load_config_file(const char *configfile)\r\n{\r\nCONF *conf = NULL;\r\nlong errorline = -1;\r\nif (!configfile) configfile = getenv("OPENSSL_CONF");\r\nif (!configfile) configfile = getenv("SSLEAY_CONF");\r\nif (configfile &&\r\n(!(conf = NCONF_new(NULL)) ||\r\nNCONF_load(conf, configfile, &errorline) <= 0))\r\n{\r\nif (errorline <= 0)\r\nBIO_printf(bio_err, "error loading the config file "\r\n"'%s'\n", configfile);\r\nelse\r\nBIO_printf(bio_err, "error on line %ld of config file "\r\n"'%s'\n", errorline, configfile);\r\n}\r\nif (conf != NULL)\r\n{\r\nconst char *p;\r\nBIO_printf(bio_err,"Using configuration from %s\n", configfile);\r\np = NCONF_get_string(conf, NULL, ENV_OID_FILE);\r\nif (p != NULL)\r\n{\r\nBIO *oid_bio = BIO_new_file(p, "r");\r\nif (!oid_bio)\r\nERR_print_errors(bio_err);\r\nelse\r\n{\r\nOBJ_create_objects(oid_bio);\r\nBIO_free_all(oid_bio);\r\n}\r\n}\r\nelse\r\nERR_clear_error();\r\nif(!add_oid_section(bio_err, conf))\r\nERR_print_errors(bio_err);\r\n}\r\nreturn conf;\r\n}\r\nstatic int query_command(const char *data, char *digest, const EVP_MD *md,\r\nconst char *policy, int no_nonce,\r\nint cert, const char *in, const char *out, int text)\r\n{\r\nint ret = 0;\r\nTS_REQ *query = NULL;\r\nBIO *in_bio = NULL;\r\nBIO *data_bio = NULL;\r\nBIO *out_bio = NULL;\r\nif (in != NULL)\r\n{\r\nif ((in_bio = BIO_new_file(in, "rb")) == NULL) goto end;\r\nquery = d2i_TS_REQ_bio(in_bio, NULL);\r\n}\r\nelse\r\n{\r\nif (!digest\r\n&& !(data_bio = BIO_open_with_default(data, "rb", stdin)))\r\ngoto end;\r\nquery = create_query(data_bio, digest, md,\r\npolicy, no_nonce, cert);\r\n}\r\nif (query == NULL) goto end;\r\nif ((out_bio = BIO_open_with_default(out, "wb", stdout)) == NULL)\r\ngoto end;\r\nif (text)\r\n{\r\nif (!TS_REQ_print_bio(out_bio, query))\r\ngoto end;\r\n}\r\nelse\r\n{\r\nif (!i2d_TS_REQ_bio(out_bio, query))\r\ngoto end;\r\n}\r\nret = 1;\r\nend:\r\nERR_print_errors(bio_err);\r\nBIO_free_all(in_bio);\r\nBIO_free_all(data_bio);\r\nBIO_free_all(out_bio);\r\nTS_REQ_free(query);\r\nreturn ret;\r\n}\r\nstatic BIO *BIO_open_with_default(const char *file, const char *mode,\r\nFILE *default_fp)\r\n{\r\nreturn file == NULL ?\r\nBIO_new_fp(default_fp, BIO_NOCLOSE)\r\n: BIO_new_file(file, mode);\r\n}\r\nstatic TS_REQ *create_query(BIO *data_bio, char *digest, const EVP_MD *md,\r\nconst char *policy, int no_nonce, int cert)\r\n{\r\nint ret = 0;\r\nTS_REQ *ts_req = NULL;\r\nint len;\r\nTS_MSG_IMPRINT *msg_imprint = NULL;\r\nX509_ALGOR *algo = NULL;\r\nunsigned char *data = NULL;\r\nASN1_OBJECT *policy_obj = NULL;\r\nASN1_INTEGER *nonce_asn1 = NULL;\r\nif (!md && !(md = EVP_get_digestbyname("sha1"))) goto err;\r\nif (!(ts_req = TS_REQ_new())) goto err;\r\nif (!TS_REQ_set_version(ts_req, 1)) goto err;\r\nif (!(msg_imprint = TS_MSG_IMPRINT_new())) goto err;\r\nif (!(algo = X509_ALGOR_new())) goto err;\r\nif (!(algo->algorithm = OBJ_nid2obj(EVP_MD_type(md)))) goto err;\r\nif (!(algo->parameter = ASN1_TYPE_new())) goto err;\r\nalgo->parameter->type = V_ASN1_NULL;\r\nif (!TS_MSG_IMPRINT_set_algo(msg_imprint, algo)) goto err;\r\nif ((len = create_digest(data_bio, digest, md, &data)) == 0)\r\ngoto err;\r\nif (!TS_MSG_IMPRINT_set_msg(msg_imprint, data, len)) goto err;\r\nif (!TS_REQ_set_msg_imprint(ts_req, msg_imprint)) goto err;\r\nif (policy && !(policy_obj = txt2obj(policy))) goto err;\r\nif (policy_obj && !TS_REQ_set_policy_id(ts_req, policy_obj)) goto err;\r\nif (!no_nonce && !(nonce_asn1 = create_nonce(NONCE_LENGTH))) goto err;\r\nif (nonce_asn1 && !TS_REQ_set_nonce(ts_req, nonce_asn1)) goto err;\r\nif (!TS_REQ_set_cert_req(ts_req, cert)) goto err;\r\nret = 1;\r\nerr:\r\nif (!ret)\r\n{\r\nTS_REQ_free(ts_req);\r\nts_req = NULL;\r\nBIO_printf(bio_err, "could not create query\n");\r\n}\r\nTS_MSG_IMPRINT_free(msg_imprint);\r\nX509_ALGOR_free(algo);\r\nOPENSSL_free(data);\r\nASN1_OBJECT_free(policy_obj);\r\nASN1_INTEGER_free(nonce_asn1);\r\nreturn ts_req;\r\n}\r\nstatic int create_digest(BIO *input, char *digest, const EVP_MD *md,\r\nunsigned char **md_value)\r\n{\r\nint md_value_len;\r\nmd_value_len = EVP_MD_size(md);\r\nif (md_value_len < 0)\r\ngoto err;\r\nif (input)\r\n{\r\nEVP_MD_CTX md_ctx;\r\nunsigned char buffer[4096];\r\nint length;\r\n*md_value = OPENSSL_malloc(md_value_len);\r\nif (*md_value == 0) goto err;\r\nEVP_DigestInit(&md_ctx, md);\r\nwhile ((length = BIO_read(input, buffer, sizeof(buffer))) > 0)\r\n{\r\nEVP_DigestUpdate(&md_ctx, buffer, length);\r\n}\r\nEVP_DigestFinal(&md_ctx, *md_value, NULL);\r\n}\r\nelse\r\n{\r\nlong digest_len;\r\n*md_value = string_to_hex(digest, &digest_len);\r\nif (!*md_value || md_value_len != digest_len)\r\n{\r\nOPENSSL_free(*md_value);\r\n*md_value = NULL;\r\nBIO_printf(bio_err, "bad digest, %d bytes "\r\n"must be specified\n", md_value_len);\r\ngoto err;\r\n}\r\n}\r\nreturn md_value_len;\r\nerr:\r\nreturn 0;\r\n}\r\nstatic ASN1_INTEGER *create_nonce(int bits)\r\n{\r\nunsigned char buf[20];\r\nASN1_INTEGER *nonce = NULL;\r\nint len = (bits - 1) / 8 + 1;\r\nint i;\r\nif (len > (int)sizeof(buf)) goto err;\r\nif (RAND_bytes(buf, len) <= 0) goto err;\r\nfor (i = 0; i < len && !buf[i]; ++i);\r\nif (!(nonce = ASN1_INTEGER_new())) goto err;\r\nOPENSSL_free(nonce->data);\r\nnonce->length = len - i;\r\nif (!(nonce->data = OPENSSL_malloc(nonce->length + 1))) goto err;\r\nmemcpy(nonce->data, buf + i, nonce->length);\r\nreturn nonce;\r\nerr:\r\nBIO_printf(bio_err, "could not create nonce\n");\r\nASN1_INTEGER_free(nonce);\r\nreturn NULL;\r\n}\r\nstatic int reply_command(CONF *conf, char *section, char *engine,\r\nchar *queryfile, char *passin, char *inkey,\r\nchar *signer, char *chain, const char *policy,\r\nchar *in, int token_in,\r\nchar *out, int token_out, int text)\r\n{\r\nint ret = 0;\r\nTS_RESP *response = NULL;\r\nBIO *in_bio = NULL;\r\nBIO *query_bio = NULL;\r\nBIO *inkey_bio = NULL;\r\nBIO *signer_bio = NULL;\r\nBIO *out_bio = NULL;\r\nif (in != NULL)\r\n{\r\nif ((in_bio = BIO_new_file(in, "rb")) == NULL) goto end;\r\nif (token_in)\r\n{\r\nresponse = read_PKCS7(in_bio);\r\n}\r\nelse\r\n{\r\nresponse = d2i_TS_RESP_bio(in_bio, NULL);\r\n}\r\n}\r\nelse\r\n{\r\nresponse = create_response(conf, section, engine, queryfile,\r\npassin, inkey, signer, chain,\r\npolicy);\r\nif (response)\r\nBIO_printf(bio_err, "Response has been generated.\n");\r\nelse\r\nBIO_printf(bio_err, "Response is not generated.\n");\r\n}\r\nif (response == NULL) goto end;\r\nif ((out_bio = BIO_open_with_default(out, "wb", stdout)) == NULL)\r\ngoto end;\r\nif (text)\r\n{\r\nif (token_out)\r\n{\r\nTS_TST_INFO *tst_info = TS_RESP_get_tst_info(response);\r\nif (!TS_TST_INFO_print_bio(out_bio, tst_info)) goto end;\r\n}\r\nelse\r\n{\r\nif (!TS_RESP_print_bio(out_bio, response)) goto end;\r\n}\r\n}\r\nelse\r\n{\r\nif (token_out)\r\n{\r\nPKCS7 *token = TS_RESP_get_token(response);\r\nif (!i2d_PKCS7_bio(out_bio, token)) goto end;\r\n}\r\nelse\r\n{\r\nif (!i2d_TS_RESP_bio(out_bio, response)) goto end;\r\n}\r\n}\r\nret = 1;\r\nend:\r\nERR_print_errors(bio_err);\r\nBIO_free_all(in_bio);\r\nBIO_free_all(query_bio);\r\nBIO_free_all(inkey_bio);\r\nBIO_free_all(signer_bio);\r\nBIO_free_all(out_bio);\r\nTS_RESP_free(response);\r\nreturn ret;\r\n}\r\nstatic TS_RESP *read_PKCS7(BIO *in_bio)\r\n{\r\nint ret = 0;\r\nPKCS7 *token = NULL;\r\nTS_TST_INFO *tst_info = NULL;\r\nTS_RESP *resp = NULL;\r\nTS_STATUS_INFO *si = NULL;\r\nif (!(token = d2i_PKCS7_bio(in_bio, NULL))) goto end;\r\nif (!(tst_info = PKCS7_to_TS_TST_INFO(token))) goto end;\r\nif (!(resp = TS_RESP_new())) goto end;\r\nif (!(si = TS_STATUS_INFO_new())) goto end;\r\nif (!(ASN1_INTEGER_set(si->status, TS_STATUS_GRANTED))) goto end;\r\nif (!TS_RESP_set_status_info(resp, si)) goto end;\r\nTS_RESP_set_tst_info(resp, token, tst_info);\r\ntoken = NULL;\r\ntst_info = NULL;\r\nret = 1;\r\nend:\r\nPKCS7_free(token);\r\nTS_TST_INFO_free(tst_info);\r\nif (!ret)\r\n{\r\nTS_RESP_free(resp);\r\nresp = NULL;\r\n}\r\nTS_STATUS_INFO_free(si);\r\nreturn resp;\r\n}\r\nstatic TS_RESP *create_response(CONF *conf, const char *section, char *engine,\r\nchar *queryfile, char *passin, char *inkey,\r\nchar *signer, char *chain, const char *policy)\r\n{\r\nint ret = 0;\r\nTS_RESP *response = NULL;\r\nBIO *query_bio = NULL;\r\nTS_RESP_CTX *resp_ctx = NULL;\r\nif (!(query_bio = BIO_new_file(queryfile, "rb")))\r\ngoto end;\r\nif (!(section = TS_CONF_get_tsa_section(conf, section)))\r\ngoto end;\r\nif (!(resp_ctx = TS_RESP_CTX_new())) goto end;\r\nif (!TS_CONF_set_serial(conf, section, serial_cb, resp_ctx)) goto end;\r\n#ifndef OPENSSL_NO_ENGINE\r\nif (!TS_CONF_set_crypto_device(conf, section, engine)) goto end;\r\n#endif\r\nif (!TS_CONF_set_signer_cert(conf, section, signer, resp_ctx)) goto end;\r\nif (!TS_CONF_set_certs(conf, section, chain, resp_ctx)) goto end;\r\nif (!TS_CONF_set_signer_key(conf, section, inkey, passin, resp_ctx))\r\ngoto end;\r\nif (!TS_CONF_set_def_policy(conf, section, policy, resp_ctx)) goto end;\r\nif (!TS_CONF_set_policies(conf, section, resp_ctx)) goto end;\r\nif (!TS_CONF_set_digests(conf, section, resp_ctx)) goto end;\r\nif (!TS_CONF_set_accuracy(conf, section, resp_ctx)) goto end;\r\nif (!TS_CONF_set_clock_precision_digits(conf, section, resp_ctx))\r\ngoto end;\r\nif (!TS_CONF_set_ordering(conf, section, resp_ctx)) goto end;\r\nif (!TS_CONF_set_tsa_name(conf, section, resp_ctx)) goto end;\r\nif (!TS_CONF_set_ess_cert_id_chain(conf, section, resp_ctx)) goto end;\r\nif (!(response = TS_RESP_create_response(resp_ctx, query_bio)))\r\ngoto end;\r\nret = 1;\r\nend:\r\nif (!ret)\r\n{\r\nTS_RESP_free(response);\r\nresponse = NULL;\r\n}\r\nTS_RESP_CTX_free(resp_ctx);\r\nBIO_free_all(query_bio);\r\nreturn response;\r\n}\r\nstatic ASN1_INTEGER * MS_CALLBACK serial_cb(TS_RESP_CTX *ctx, void *data)\r\n{\r\nconst char *serial_file = (const char *) data;\r\nASN1_INTEGER *serial = next_serial(serial_file);\r\nif (!serial)\r\n{\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Error during serial number "\r\n"generation.");\r\nTS_RESP_CTX_add_failure_info(ctx,\r\nTS_INFO_ADD_INFO_NOT_AVAILABLE);\r\n}\r\nelse\r\nsave_ts_serial(serial_file, serial);\r\nreturn serial;\r\n}\r\nstatic ASN1_INTEGER *next_serial(const char *serialfile)\r\n{\r\nint ret = 0;\r\nBIO *in = NULL;\r\nASN1_INTEGER *serial = NULL;\r\nBIGNUM *bn = NULL;\r\nif (!(serial = ASN1_INTEGER_new())) goto err;\r\nif (!(in = BIO_new_file(serialfile, "r")))\r\n{\r\nERR_clear_error();\r\nBIO_printf(bio_err, "Warning: could not open file %s for "\r\n"reading, using serial number: 1\n", serialfile);\r\nif (!ASN1_INTEGER_set(serial, 1)) goto err;\r\n}\r\nelse\r\n{\r\nchar buf[1024];\r\nif (!a2i_ASN1_INTEGER(in, serial, buf, sizeof(buf)))\r\n{\r\nBIO_printf(bio_err, "unable to load number from %s\n",\r\nserialfile);\r\ngoto err;\r\n}\r\nif (!(bn = ASN1_INTEGER_to_BN(serial, NULL))) goto err;\r\nASN1_INTEGER_free(serial);\r\nserial = NULL;\r\nif (!BN_add_word(bn, 1)) goto err;\r\nif (!(serial = BN_to_ASN1_INTEGER(bn, NULL))) goto err;\r\n}\r\nret = 1;\r\nerr:\r\nif (!ret)\r\n{\r\nASN1_INTEGER_free(serial);\r\nserial = NULL;\r\n}\r\nBIO_free_all(in);\r\nBN_free(bn);\r\nreturn serial;\r\n}\r\nstatic int save_ts_serial(const char *serialfile, ASN1_INTEGER *serial)\r\n{\r\nint ret = 0;\r\nBIO *out = NULL;\r\nif (!(out = BIO_new_file(serialfile, "w"))) goto err;\r\nif (i2a_ASN1_INTEGER(out, serial) <= 0) goto err;\r\nif (BIO_puts(out, "\n") <= 0) goto err;\r\nret = 1;\r\nerr:\r\nif (!ret)\r\nBIO_printf(bio_err, "could not save serial number to %s\n",\r\nserialfile);\r\nBIO_free_all(out);\r\nreturn ret;\r\n}\r\nstatic int verify_command(char *data, char *digest, char *queryfile,\r\nchar *in, int token_in,\r\nchar *ca_path, char *ca_file, char *untrusted)\r\n{\r\nBIO *in_bio = NULL;\r\nPKCS7 *token = NULL;\r\nTS_RESP *response = NULL;\r\nTS_VERIFY_CTX *verify_ctx = NULL;\r\nint ret = 0;\r\nif (!(in_bio = BIO_new_file(in, "rb"))) goto end;\r\nif (token_in)\r\n{\r\nif (!(token = d2i_PKCS7_bio(in_bio, NULL))) goto end;\r\n}\r\nelse\r\n{\r\nif (!(response = d2i_TS_RESP_bio(in_bio, NULL))) goto end;\r\n}\r\nif (!(verify_ctx = create_verify_ctx(data, digest, queryfile,\r\nca_path, ca_file, untrusted)))\r\ngoto end;\r\nret = token_in ?\r\nTS_RESP_verify_token(verify_ctx, token) :\r\nTS_RESP_verify_response(verify_ctx, response);\r\nend:\r\nprintf("Verification: ");\r\nif (ret)\r\nprintf("OK\n");\r\nelse\r\n{\r\nprintf("FAILED\n");\r\nERR_print_errors(bio_err);\r\n}\r\nBIO_free_all(in_bio);\r\nPKCS7_free(token);\r\nTS_RESP_free(response);\r\nTS_VERIFY_CTX_free(verify_ctx);\r\nreturn ret;\r\n}\r\nstatic TS_VERIFY_CTX *create_verify_ctx(char *data, char *digest,\r\nchar *queryfile,\r\nchar *ca_path, char *ca_file,\r\nchar *untrusted)\r\n{\r\nTS_VERIFY_CTX *ctx = NULL;\r\nBIO *input = NULL;\r\nTS_REQ *request = NULL;\r\nint ret = 0;\r\nif (data != NULL || digest != NULL)\r\n{\r\nif (!(ctx = TS_VERIFY_CTX_new())) goto err;\r\nctx->flags = TS_VFY_VERSION | TS_VFY_SIGNER;\r\nif (data != NULL)\r\n{\r\nctx->flags |= TS_VFY_DATA;\r\nif (!(ctx->data = BIO_new_file(data, "rb"))) goto err;\r\n}\r\nelse if (digest != NULL)\r\n{\r\nlong imprint_len;\r\nctx->flags |= TS_VFY_IMPRINT;\r\nif (!(ctx->imprint = string_to_hex(digest,\r\n&imprint_len)))\r\n{\r\nBIO_printf(bio_err, "invalid digest string\n");\r\ngoto err;\r\n}\r\nctx->imprint_len = imprint_len;\r\n}\r\n}\r\nelse if (queryfile != NULL)\r\n{\r\nif (!(input = BIO_new_file(queryfile, "rb"))) goto err;\r\nif (!(request = d2i_TS_REQ_bio(input, NULL))) goto err;\r\nif (!(ctx = TS_REQ_to_TS_VERIFY_CTX(request, NULL))) goto err;\r\n}\r\nelse\r\nreturn NULL;\r\nctx->flags |= TS_VFY_SIGNATURE;\r\nif (!(ctx->store = create_cert_store(ca_path, ca_file))) goto err;\r\nif (untrusted && !(ctx->certs = TS_CONF_load_certs(untrusted)))\r\ngoto err;\r\nret = 1;\r\nerr:\r\nif (!ret)\r\n{\r\nTS_VERIFY_CTX_free(ctx);\r\nctx = NULL;\r\n}\r\nBIO_free_all(input);\r\nTS_REQ_free(request);\r\nreturn ctx;\r\n}\r\nstatic X509_STORE *create_cert_store(char *ca_path, char *ca_file)\r\n{\r\nX509_STORE *cert_ctx = NULL;\r\nX509_LOOKUP *lookup = NULL;\r\nint i;\r\ncert_ctx = X509_STORE_new();\r\nX509_STORE_set_verify_cb(cert_ctx, verify_cb);\r\nif (ca_path)\r\n{\r\nlookup = X509_STORE_add_lookup(cert_ctx,\r\nX509_LOOKUP_hash_dir());\r\nif (lookup == NULL)\r\n{\r\nBIO_printf(bio_err, "memory allocation failure\n");\r\ngoto err;\r\n}\r\ni = X509_LOOKUP_add_dir(lookup, ca_path, X509_FILETYPE_PEM);\r\nif (!i)\r\n{\r\nBIO_printf(bio_err, "Error loading directory %s\n",\r\nca_path);\r\ngoto err;\r\n}\r\n}\r\nif (ca_file)\r\n{\r\nlookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_file());\r\nif (lookup == NULL)\r\n{\r\nBIO_printf(bio_err, "memory allocation failure\n");\r\ngoto err;\r\n}\r\ni = X509_LOOKUP_load_file(lookup, ca_file, X509_FILETYPE_PEM);\r\nif (!i)\r\n{\r\nBIO_printf(bio_err, "Error loading file %s\n", ca_file);\r\ngoto err;\r\n}\r\n}\r\nreturn cert_ctx;\r\nerr:\r\nX509_STORE_free(cert_ctx);\r\nreturn NULL;\r\n}\r\nstatic int MS_CALLBACK verify_cb(int ok, X509_STORE_CTX *ctx)\r\n{\r\nreturn ok;\r\n}
