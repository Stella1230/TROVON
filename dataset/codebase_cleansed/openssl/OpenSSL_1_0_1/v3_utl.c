void X509V3_conf_free(CONF_VALUE *conf)\r\n{\r\nif(!conf) return;\r\nif(conf->name) OPENSSL_free(conf->name);\r\nif(conf->value) OPENSSL_free(conf->value);\r\nif(conf->section) OPENSSL_free(conf->section);\r\nOPENSSL_free(conf);\r\n}\r\nchar *i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *method, ASN1_ENUMERATED *a)\r\n{\r\nBIGNUM *bntmp = NULL;\r\nchar *strtmp = NULL;\r\nif(!a) return NULL;\r\nif(!(bntmp = ASN1_ENUMERATED_to_BN(a, NULL)) ||\r\n!(strtmp = BN_bn2dec(bntmp)) )\r\nX509V3err(X509V3_F_I2S_ASN1_ENUMERATED,ERR_R_MALLOC_FAILURE);\r\nBN_free(bntmp);\r\nreturn strtmp;\r\n}\r\nchar *i2s_ASN1_INTEGER(X509V3_EXT_METHOD *method, ASN1_INTEGER *a)\r\n{\r\nBIGNUM *bntmp = NULL;\r\nchar *strtmp = NULL;\r\nif(!a) return NULL;\r\nif(!(bntmp = ASN1_INTEGER_to_BN(a, NULL)) ||\r\n!(strtmp = BN_bn2dec(bntmp)) )\r\nX509V3err(X509V3_F_I2S_ASN1_INTEGER,ERR_R_MALLOC_FAILURE);\r\nBN_free(bntmp);\r\nreturn strtmp;\r\n}\r\nASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, char *value)\r\n{\r\nBIGNUM *bn = NULL;\r\nASN1_INTEGER *aint;\r\nint isneg, ishex;\r\nint ret;\r\nif (!value) {\r\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_INVALID_NULL_VALUE);\r\nreturn 0;\r\n}\r\nbn = BN_new();\r\nif (value[0] == '-') {\r\nvalue++;\r\nisneg = 1;\r\n} else isneg = 0;\r\nif (value[0] == '0' && ((value[1] == 'x') || (value[1] == 'X'))) {\r\nvalue += 2;\r\nishex = 1;\r\n} else ishex = 0;\r\nif (ishex) ret = BN_hex2bn(&bn, value);\r\nelse ret = BN_dec2bn(&bn, value);\r\nif (!ret || value[ret]) {\r\nBN_free(bn);\r\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_BN_DEC2BN_ERROR);\r\nreturn 0;\r\n}\r\nif (isneg && BN_is_zero(bn)) isneg = 0;\r\naint = BN_to_ASN1_INTEGER(bn, NULL);\r\nBN_free(bn);\r\nif (!aint) {\r\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,X509V3_R_BN_TO_ASN1_INTEGER_ERROR);\r\nreturn 0;\r\n}\r\nif (isneg) aint->type |= V_ASN1_NEG;\r\nreturn aint;\r\n}\r\nint X509V3_get_value_bool(CONF_VALUE *value, int *asn1_bool)\r\n{\r\nchar *btmp;\r\nif(!(btmp = value->value)) goto err;\r\nif(!strcmp(btmp, "TRUE") || !strcmp(btmp, "true")\r\n|| !strcmp(btmp, "Y") || !strcmp(btmp, "y")\r\n|| !strcmp(btmp, "YES") || !strcmp(btmp, "yes")) {\r\n*asn1_bool = 0xff;\r\nreturn 1;\r\n} else if(!strcmp(btmp, "FALSE") || !strcmp(btmp, "false")\r\n|| !strcmp(btmp, "N") || !strcmp(btmp, "n")\r\n|| !strcmp(btmp, "NO") || !strcmp(btmp, "no")) {\r\n*asn1_bool = 0;\r\nreturn 1;\r\n}\r\nerr:\r\nX509V3err(X509V3_F_X509V3_GET_VALUE_BOOL,X509V3_R_INVALID_BOOLEAN_STRING);\r\nX509V3_conf_err(value);\r\nreturn 0;\r\n}\r\nint X509V3_get_value_int(CONF_VALUE *value, ASN1_INTEGER **aint)\r\n{\r\nASN1_INTEGER *itmp;\r\nif(!(itmp = s2i_ASN1_INTEGER(NULL, value->value))) {\r\nX509V3_conf_err(value);\r\nreturn 0;\r\n}\r\n*aint = itmp;\r\nreturn 1;\r\n}\r\nchar *strip_spaces(char *name)\r\n{\r\nchar *p, *q;\r\np = name;\r\nwhile(*p && isspace((unsigned char)*p)) p++;\r\nif(!*p) return NULL;\r\nq = p + strlen(p) - 1;\r\nwhile((q != p) && isspace((unsigned char)*q)) q--;\r\nif(p != q) q[1] = 0;\r\nif(!*p) return NULL;\r\nreturn p;\r\n}\r\nchar *hex_to_string(const unsigned char *buffer, long len)\r\n{\r\nchar *tmp, *q;\r\nconst unsigned char *p;\r\nint i;\r\nconst static char hexdig[] = "0123456789ABCDEF";\r\nif(!buffer || !len) return NULL;\r\nif(!(tmp = OPENSSL_malloc(len * 3 + 1))) {\r\nX509V3err(X509V3_F_HEX_TO_STRING,ERR_R_MALLOC_FAILURE);\r\nreturn NULL;\r\n}\r\nq = tmp;\r\nfor(i = 0, p = buffer; i < len; i++,p++) {\r\n*q++ = hexdig[(*p >> 4) & 0xf];\r\n*q++ = hexdig[*p & 0xf];\r\n*q++ = ':';\r\n}\r\nq[-1] = 0;\r\n#ifdef CHARSET_EBCDIC\r\nebcdic2ascii(tmp, tmp, q - tmp - 1);\r\n#endif\r\nreturn tmp;\r\n}\r\nunsigned char *string_to_hex(const char *str, long *len)\r\n{\r\nunsigned char *hexbuf, *q;\r\nunsigned char ch, cl, *p;\r\nif(!str) {\r\nX509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_INVALID_NULL_ARGUMENT);\r\nreturn NULL;\r\n}\r\nif(!(hexbuf = OPENSSL_malloc(strlen(str) >> 1))) goto err;\r\nfor(p = (unsigned char *)str, q = hexbuf; *p;) {\r\nch = *p++;\r\n#ifdef CHARSET_EBCDIC\r\nch = os_toebcdic[ch];\r\n#endif\r\nif(ch == ':') continue;\r\ncl = *p++;\r\n#ifdef CHARSET_EBCDIC\r\ncl = os_toebcdic[cl];\r\n#endif\r\nif(!cl) {\r\nX509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_ODD_NUMBER_OF_DIGITS);\r\nOPENSSL_free(hexbuf);\r\nreturn NULL;\r\n}\r\nif(isupper(ch)) ch = tolower(ch);\r\nif(isupper(cl)) cl = tolower(cl);\r\nif((ch >= '0') && (ch <= '9')) ch -= '0';\r\nelse if ((ch >= 'a') && (ch <= 'f')) ch -= 'a' - 10;\r\nelse goto badhex;\r\nif((cl >= '0') && (cl <= '9')) cl -= '0';\r\nelse if ((cl >= 'a') && (cl <= 'f')) cl -= 'a' - 10;\r\nelse goto badhex;\r\n*q++ = (ch << 4) | cl;\r\n}\r\nif(len) *len = q - hexbuf;\r\nreturn hexbuf;\r\nerr:\r\nif(hexbuf) OPENSSL_free(hexbuf);\r\nX509V3err(X509V3_F_STRING_TO_HEX,ERR_R_MALLOC_FAILURE);\r\nreturn NULL;\r\nbadhex:\r\nOPENSSL_free(hexbuf);\r\nX509V3err(X509V3_F_STRING_TO_HEX,X509V3_R_ILLEGAL_HEX_DIGIT);\r\nreturn NULL;\r\n}\r\nint name_cmp(const char *name, const char *cmp)\r\n{\r\nint len, ret;\r\nchar c;\r\nlen = strlen(cmp);\r\nif((ret = strncmp(name, cmp, len))) return ret;\r\nc = name[len];\r\nif(!c || (c=='.')) return 0;\r\nreturn 1;\r\n}\r\nstatic int sk_strcmp(const char * const *a, const char * const *b)\r\n{\r\nreturn strcmp(*a, *b);\r\n}\r\nvoid str_free(OPENSSL_STRING str)\r\n{\r\nOPENSSL_free(str);\r\n}\r\nASN1_OCTET_STRING *a2i_IPADDRESS(const char *ipasc)\r\n{\r\nunsigned char ipout[16];\r\nASN1_OCTET_STRING *ret;\r\nint iplen;\r\niplen = a2i_ipadd(ipout, ipasc);\r\nif (!iplen)\r\nreturn NULL;\r\nret = ASN1_OCTET_STRING_new();\r\nif (!ret)\r\nreturn NULL;\r\nif (!ASN1_OCTET_STRING_set(ret, ipout, iplen))\r\n{\r\nASN1_OCTET_STRING_free(ret);\r\nreturn NULL;\r\n}\r\nreturn ret;\r\n}\r\nASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc)\r\n{\r\nASN1_OCTET_STRING *ret = NULL;\r\nunsigned char ipout[32];\r\nchar *iptmp = NULL, *p;\r\nint iplen1, iplen2;\r\np = strchr(ipasc,'/');\r\nif (!p)\r\nreturn NULL;\r\niptmp = BUF_strdup(ipasc);\r\nif (!iptmp)\r\nreturn NULL;\r\np = iptmp + (p - ipasc);\r\n*p++ = 0;\r\niplen1 = a2i_ipadd(ipout, iptmp);\r\nif (!iplen1)\r\ngoto err;\r\niplen2 = a2i_ipadd(ipout + iplen1, p);\r\nOPENSSL_free(iptmp);\r\niptmp = NULL;\r\nif (!iplen2 || (iplen1 != iplen2))\r\ngoto err;\r\nret = ASN1_OCTET_STRING_new();\r\nif (!ret)\r\ngoto err;\r\nif (!ASN1_OCTET_STRING_set(ret, ipout, iplen1 + iplen2))\r\ngoto err;\r\nreturn ret;\r\nerr:\r\nif (iptmp)\r\nOPENSSL_free(iptmp);\r\nif (ret)\r\nASN1_OCTET_STRING_free(ret);\r\nreturn NULL;\r\n}\r\nint a2i_ipadd(unsigned char *ipout, const char *ipasc)\r\n{\r\nif (strchr(ipasc, ':'))\r\n{\r\nif (!ipv6_from_asc(ipout, ipasc))\r\nreturn 0;\r\nreturn 16;\r\n}\r\nelse\r\n{\r\nif (!ipv4_from_asc(ipout, ipasc))\r\nreturn 0;\r\nreturn 4;\r\n}\r\n}\r\nstatic int ipv4_from_asc(unsigned char *v4, const char *in)\r\n{\r\nint a0, a1, a2, a3;\r\nif (sscanf(in, "%d.%d.%d.%d", &a0, &a1, &a2, &a3) != 4)\r\nreturn 0;\r\nif ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255)\r\n|| (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))\r\nreturn 0;\r\nv4[0] = a0;\r\nv4[1] = a1;\r\nv4[2] = a2;\r\nv4[3] = a3;\r\nreturn 1;\r\n}\r\nstatic int ipv6_from_asc(unsigned char *v6, const char *in)\r\n{\r\nIPV6_STAT v6stat;\r\nv6stat.total = 0;\r\nv6stat.zero_pos = -1;\r\nv6stat.zero_cnt = 0;\r\nif (!CONF_parse_list(in, ':', 0, ipv6_cb, &v6stat))\r\nreturn 0;\r\nif (v6stat.zero_pos == -1)\r\n{\r\nif (v6stat.total != 16)\r\nreturn 0;\r\n}\r\nelse\r\n{\r\nif (v6stat.total == 16)\r\nreturn 0;\r\nif (v6stat.zero_cnt > 3)\r\nreturn 0;\r\nelse if (v6stat.zero_cnt == 3)\r\n{\r\nif (v6stat.total > 0)\r\nreturn 0;\r\n}\r\nelse if (v6stat.zero_cnt == 2)\r\n{\r\nif ((v6stat.zero_pos != 0)\r\n&& (v6stat.zero_pos != v6stat.total))\r\nreturn 0;\r\n}\r\nelse\r\n{\r\nif ((v6stat.zero_pos == 0)\r\n|| (v6stat.zero_pos == v6stat.total))\r\nreturn 0;\r\n}\r\n}\r\nif (v6stat.zero_pos >= 0)\r\n{\r\nmemcpy(v6, v6stat.tmp, v6stat.zero_pos);\r\nmemset(v6 + v6stat.zero_pos, 0, 16 - v6stat.total);\r\nif (v6stat.total != v6stat.zero_pos)\r\nmemcpy(v6 + v6stat.zero_pos + 16 - v6stat.total,\r\nv6stat.tmp + v6stat.zero_pos,\r\nv6stat.total - v6stat.zero_pos);\r\n}\r\nelse\r\nmemcpy(v6, v6stat.tmp, 16);\r\nreturn 1;\r\n}\r\nstatic int ipv6_cb(const char *elem, int len, void *usr)\r\n{\r\nIPV6_STAT *s = usr;\r\nif (s->total == 16)\r\nreturn 0;\r\nif (len == 0)\r\n{\r\nif (s->zero_pos == -1)\r\ns->zero_pos = s->total;\r\nelse if (s->zero_pos != s->total)\r\nreturn 0;\r\ns->zero_cnt++;\r\n}\r\nelse\r\n{\r\nif (len > 4)\r\n{\r\nif (s->total > 12)\r\nreturn 0;\r\nif (elem[len])\r\nreturn 0;\r\nif (!ipv4_from_asc(s->tmp + s->total, elem))\r\nreturn 0;\r\ns->total += 4;\r\n}\r\nelse\r\n{\r\nif (!ipv6_hex(s->tmp + s->total, elem, len))\r\nreturn 0;\r\ns->total += 2;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int ipv6_hex(unsigned char *out, const char *in, int inlen)\r\n{\r\nunsigned char c;\r\nunsigned int num = 0;\r\nif (inlen > 4)\r\nreturn 0;\r\nwhile(inlen--)\r\n{\r\nc = *in++;\r\nnum <<= 4;\r\nif ((c >= '0') && (c <= '9'))\r\nnum |= c - '0';\r\nelse if ((c >= 'A') && (c <= 'F'))\r\nnum |= c - 'A' + 10;\r\nelse if ((c >= 'a') && (c <= 'f'))\r\nnum |= c - 'a' + 10;\r\nelse\r\nreturn 0;\r\n}\r\nout[0] = num >> 8;\r\nout[1] = num & 0xff;\r\nreturn 1;\r\n}
