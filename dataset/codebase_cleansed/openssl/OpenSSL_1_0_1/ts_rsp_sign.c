static ASN1_INTEGER *def_serial_cb(struct TS_resp_ctx *ctx, void *data)\r\n{\r\nASN1_INTEGER *serial = ASN1_INTEGER_new();\r\nif (!serial) goto err;\r\nif (!ASN1_INTEGER_set(serial, 1)) goto err;\r\nreturn serial;\r\nerr:\r\nTSerr(TS_F_DEF_SERIAL_CB, ERR_R_MALLOC_FAILURE);\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Error during serial number generation.");\r\nreturn NULL;\r\n}\r\nstatic int def_time_cb(struct TS_resp_ctx *ctx, void *data,\r\nlong *sec, long *usec)\r\n{\r\nstruct timeval tv;\r\nif (gettimeofday(&tv, NULL) != 0)\r\n{\r\nTSerr(TS_F_DEF_TIME_CB, TS_R_TIME_SYSCALL_ERROR);\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Time is not available.");\r\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);\r\nreturn 0;\r\n}\r\n*sec = tv.tv_sec;\r\n*usec = tv.tv_usec;\r\nreturn 1;\r\n}\r\nstatic int def_time_cb(struct TS_resp_ctx *ctx, void *data,\r\nlong *sec, long *usec)\r\n{\r\ntime_t t;\r\nif (time(&t) == (time_t) -1)\r\n{\r\nTSerr(TS_F_DEF_TIME_CB, TS_R_TIME_SYSCALL_ERROR);\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Time is not available.");\r\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);\r\nreturn 0;\r\n}\r\n*sec = (long) t;\r\n*usec = 0;\r\nreturn 1;\r\n}\r\nstatic int def_extension_cb(struct TS_resp_ctx *ctx, X509_EXTENSION *ext,\r\nvoid *data)\r\n{\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Unsupported extension.");\r\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_UNACCEPTED_EXTENSION);\r\nreturn 0;\r\n}\r\nTS_RESP_CTX *TS_RESP_CTX_new()\r\n{\r\nTS_RESP_CTX *ctx;\r\nif (!(ctx = (TS_RESP_CTX *) OPENSSL_malloc(sizeof(TS_RESP_CTX))))\r\n{\r\nTSerr(TS_F_TS_RESP_CTX_NEW, ERR_R_MALLOC_FAILURE);\r\nreturn NULL;\r\n}\r\nmemset(ctx, 0, sizeof(TS_RESP_CTX));\r\nctx->serial_cb = def_serial_cb;\r\nctx->time_cb = def_time_cb;\r\nctx->extension_cb = def_extension_cb;\r\nreturn ctx;\r\n}\r\nvoid TS_RESP_CTX_free(TS_RESP_CTX *ctx)\r\n{\r\nif (!ctx) return;\r\nX509_free(ctx->signer_cert);\r\nEVP_PKEY_free(ctx->signer_key);\r\nsk_X509_pop_free(ctx->certs, X509_free);\r\nsk_ASN1_OBJECT_pop_free(ctx->policies, ASN1_OBJECT_free);\r\nASN1_OBJECT_free(ctx->default_policy);\r\nsk_EVP_MD_free(ctx->mds);\r\nASN1_INTEGER_free(ctx->seconds);\r\nASN1_INTEGER_free(ctx->millis);\r\nASN1_INTEGER_free(ctx->micros);\r\nOPENSSL_free(ctx);\r\n}\r\nint TS_RESP_CTX_set_signer_cert(TS_RESP_CTX *ctx, X509 *signer)\r\n{\r\nif (X509_check_purpose(signer, X509_PURPOSE_TIMESTAMP_SIGN, 0) != 1)\r\n{\r\nTSerr(TS_F_TS_RESP_CTX_SET_SIGNER_CERT,\r\nTS_R_INVALID_SIGNER_CERTIFICATE_PURPOSE);\r\nreturn 0;\r\n}\r\nif (ctx->signer_cert) X509_free(ctx->signer_cert);\r\nctx->signer_cert = signer;\r\nCRYPTO_add(&ctx->signer_cert->references, +1, CRYPTO_LOCK_X509);\r\nreturn 1;\r\n}\r\nint TS_RESP_CTX_set_signer_key(TS_RESP_CTX *ctx, EVP_PKEY *key)\r\n{\r\nif (ctx->signer_key) EVP_PKEY_free(ctx->signer_key);\r\nctx->signer_key = key;\r\nCRYPTO_add(&ctx->signer_key->references, +1, CRYPTO_LOCK_EVP_PKEY);\r\nreturn 1;\r\n}\r\nint TS_RESP_CTX_set_def_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *def_policy)\r\n{\r\nif (ctx->default_policy) ASN1_OBJECT_free(ctx->default_policy);\r\nif (!(ctx->default_policy = OBJ_dup(def_policy))) goto err;\r\nreturn 1;\r\nerr:\r\nTSerr(TS_F_TS_RESP_CTX_SET_DEF_POLICY, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nint TS_RESP_CTX_add_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *policy)\r\n{\r\nASN1_OBJECT *copy = NULL;\r\nif (!ctx->policies && !(ctx->policies = sk_ASN1_OBJECT_new_null()))\r\ngoto err;\r\nif (!(copy = OBJ_dup(policy))) goto err;\r\nif (!sk_ASN1_OBJECT_push(ctx->policies, copy)) goto err;\r\nreturn 1;\r\nerr:\r\nTSerr(TS_F_TS_RESP_CTX_ADD_POLICY, ERR_R_MALLOC_FAILURE);\r\nASN1_OBJECT_free(copy);\r\nreturn 0;\r\n}\r\nint TS_RESP_CTX_add_md(TS_RESP_CTX *ctx, const EVP_MD *md)\r\n{\r\nif (!ctx->mds && !(ctx->mds = sk_EVP_MD_new_null()))\r\ngoto err;\r\nif (!sk_EVP_MD_push(ctx->mds, (EVP_MD *)md)) goto err;\r\nreturn 1;\r\nerr:\r\nTSerr(TS_F_TS_RESP_CTX_ADD_MD, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nint TS_RESP_CTX_set_accuracy(TS_RESP_CTX *ctx,\r\nint secs, int millis, int micros)\r\n{\r\nTS_RESP_CTX_accuracy_free(ctx);\r\nif (secs && (!(ctx->seconds = ASN1_INTEGER_new())\r\n|| !ASN1_INTEGER_set(ctx->seconds, secs)))\r\ngoto err;\r\nif (millis && (!(ctx->millis = ASN1_INTEGER_new())\r\n|| !ASN1_INTEGER_set(ctx->millis, millis)))\r\ngoto err;\r\nif (micros && (!(ctx->micros = ASN1_INTEGER_new())\r\n|| !ASN1_INTEGER_set(ctx->micros, micros)))\r\ngoto err;\r\nreturn 1;\r\nerr:\r\nTS_RESP_CTX_accuracy_free(ctx);\r\nTSerr(TS_F_TS_RESP_CTX_SET_ACCURACY, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nvoid TS_RESP_CTX_add_flags(TS_RESP_CTX *ctx, int flags)\r\n{\r\nctx->flags |= flags;\r\n}\r\nvoid TS_RESP_CTX_set_serial_cb(TS_RESP_CTX *ctx, TS_serial_cb cb, void *data)\r\n{\r\nctx->serial_cb = cb;\r\nctx->serial_cb_data = data;\r\n}\r\nvoid TS_RESP_CTX_set_time_cb(TS_RESP_CTX *ctx, TS_time_cb cb, void *data)\r\n{\r\nctx->time_cb = cb;\r\nctx->time_cb_data = data;\r\n}\r\nvoid TS_RESP_CTX_set_extension_cb(TS_RESP_CTX *ctx,\r\nTS_extension_cb cb, void *data)\r\n{\r\nctx->extension_cb = cb;\r\nctx->extension_cb_data = data;\r\n}\r\nint TS_RESP_CTX_set_status_info(TS_RESP_CTX *ctx,\r\nint status, const char *text)\r\n{\r\nTS_STATUS_INFO *si = NULL;\r\nASN1_UTF8STRING *utf8_text = NULL;\r\nint ret = 0;\r\nif (!(si = TS_STATUS_INFO_new())) goto err;\r\nif (!ASN1_INTEGER_set(si->status, status)) goto err;\r\nif (text)\r\n{\r\nif (!(utf8_text = ASN1_UTF8STRING_new())\r\n|| !ASN1_STRING_set(utf8_text, text, strlen(text)))\r\ngoto err;\r\nif (!si->text && !(si->text = sk_ASN1_UTF8STRING_new_null()))\r\ngoto err;\r\nif (!sk_ASN1_UTF8STRING_push(si->text, utf8_text)) goto err;\r\nutf8_text = NULL;\r\n}\r\nif (!TS_RESP_set_status_info(ctx->response, si)) goto err;\r\nret = 1;\r\nerr:\r\nif (!ret)\r\nTSerr(TS_F_TS_RESP_CTX_SET_STATUS_INFO, ERR_R_MALLOC_FAILURE);\r\nTS_STATUS_INFO_free(si);\r\nASN1_UTF8STRING_free(utf8_text);\r\nreturn ret;\r\n}\r\nint TS_RESP_CTX_set_status_info_cond(TS_RESP_CTX *ctx,\r\nint status, const char *text)\r\n{\r\nint ret = 1;\r\nTS_STATUS_INFO *si = TS_RESP_get_status_info(ctx->response);\r\nif (ASN1_INTEGER_get(si->status) == TS_STATUS_GRANTED)\r\n{\r\nret = TS_RESP_CTX_set_status_info(ctx, status, text);\r\n}\r\nreturn ret;\r\n}\r\nint TS_RESP_CTX_add_failure_info(TS_RESP_CTX *ctx, int failure)\r\n{\r\nTS_STATUS_INFO *si = TS_RESP_get_status_info(ctx->response);\r\nif (!si->failure_info && !(si->failure_info = ASN1_BIT_STRING_new()))\r\ngoto err;\r\nif (!ASN1_BIT_STRING_set_bit(si->failure_info, failure, 1))\r\ngoto err;\r\nreturn 1;\r\nerr:\r\nTSerr(TS_F_TS_RESP_CTX_ADD_FAILURE_INFO, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nTS_REQ *TS_RESP_CTX_get_request(TS_RESP_CTX *ctx)\r\n{\r\nreturn ctx->request;\r\n}\r\nTS_TST_INFO *TS_RESP_CTX_get_tst_info(TS_RESP_CTX *ctx)\r\n{\r\nreturn ctx->tst_info;\r\n}\r\nint TS_RESP_CTX_set_clock_precision_digits(TS_RESP_CTX *ctx, unsigned precision)\r\n{\r\nif (precision > TS_MAX_CLOCK_PRECISION_DIGITS)\r\nreturn 0;\r\nctx->clock_precision_digits = precision;\r\nreturn 1;\r\n}\r\nTS_RESP *TS_RESP_create_response(TS_RESP_CTX *ctx, BIO *req_bio)\r\n{\r\nASN1_OBJECT *policy;\r\nTS_RESP *response;\r\nint result = 0;\r\nTS_RESP_CTX_init(ctx);\r\nif (!(ctx->response = TS_RESP_new()))\r\n{\r\nTSerr(TS_F_TS_RESP_CREATE_RESPONSE, ERR_R_MALLOC_FAILURE);\r\ngoto end;\r\n}\r\nif (!(ctx->request = d2i_TS_REQ_bio(req_bio, NULL)))\r\n{\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Bad request format or "\r\n"system error.");\r\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_DATA_FORMAT);\r\ngoto end;\r\n}\r\nif (!TS_RESP_CTX_set_status_info(ctx, TS_STATUS_GRANTED, NULL))\r\ngoto end;\r\nif (!TS_RESP_check_request(ctx)) goto end;\r\nif (!(policy = TS_RESP_get_policy(ctx))) goto end;\r\nif (!(ctx->tst_info = TS_RESP_create_tst_info(ctx, policy)))\r\ngoto end;\r\nif (!TS_RESP_process_extensions(ctx)) goto end;\r\nif (!TS_RESP_sign(ctx)) goto end;\r\nresult = 1;\r\nend:\r\nif (!result)\r\n{\r\nTSerr(TS_F_TS_RESP_CREATE_RESPONSE, TS_R_RESPONSE_SETUP_ERROR);\r\nif (ctx->response != NULL)\r\n{\r\nif (TS_RESP_CTX_set_status_info_cond(ctx,\r\nTS_STATUS_REJECTION, "Error during response "\r\n"generation.") == 0)\r\n{\r\nTS_RESP_free(ctx->response);\r\nctx->response = NULL;\r\n}\r\n}\r\n}\r\nresponse = ctx->response;\r\nctx->response = NULL;\r\nTS_RESP_CTX_cleanup(ctx);\r\nreturn response;\r\n}\r\nstatic void TS_RESP_CTX_init(TS_RESP_CTX *ctx)\r\n{\r\nctx->request = NULL;\r\nctx->response = NULL;\r\nctx->tst_info = NULL;\r\n}\r\nstatic void TS_RESP_CTX_cleanup(TS_RESP_CTX *ctx)\r\n{\r\nTS_REQ_free(ctx->request);\r\nctx->request = NULL;\r\nTS_RESP_free(ctx->response);\r\nctx->response = NULL;\r\nTS_TST_INFO_free(ctx->tst_info);\r\nctx->tst_info = NULL;\r\n}\r\nstatic int TS_RESP_check_request(TS_RESP_CTX *ctx)\r\n{\r\nTS_REQ *request = ctx->request;\r\nTS_MSG_IMPRINT *msg_imprint;\r\nX509_ALGOR *md_alg;\r\nint md_alg_id;\r\nconst ASN1_OCTET_STRING *digest;\r\nEVP_MD *md = NULL;\r\nint i;\r\nif (TS_REQ_get_version(request) != 1)\r\n{\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Bad request version.");\r\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_REQUEST);\r\nreturn 0;\r\n}\r\nmsg_imprint = TS_REQ_get_msg_imprint(request);\r\nmd_alg = TS_MSG_IMPRINT_get_algo(msg_imprint);\r\nmd_alg_id = OBJ_obj2nid(md_alg->algorithm);\r\nfor (i = 0; !md && i < sk_EVP_MD_num(ctx->mds); ++i)\r\n{\r\nEVP_MD *current_md = sk_EVP_MD_value(ctx->mds, i);\r\nif (md_alg_id == EVP_MD_type(current_md))\r\nmd = current_md;\r\n}\r\nif (!md)\r\n{\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Message digest algorithm is "\r\n"not supported.");\r\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_ALG);\r\nreturn 0;\r\n}\r\nif (md_alg->parameter\r\n&& ASN1_TYPE_get(md_alg->parameter) != V_ASN1_NULL)\r\n{\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Superfluous message digest "\r\n"parameter.");\r\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_ALG);\r\nreturn 0;\r\n}\r\ndigest = TS_MSG_IMPRINT_get_msg(msg_imprint);\r\nif (digest->length != EVP_MD_size(md))\r\n{\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Bad message digest.");\r\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_DATA_FORMAT);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic ASN1_OBJECT *TS_RESP_get_policy(TS_RESP_CTX *ctx)\r\n{\r\nASN1_OBJECT *requested = TS_REQ_get_policy_id(ctx->request);\r\nASN1_OBJECT *policy = NULL;\r\nint i;\r\nif (ctx->default_policy == NULL)\r\n{\r\nTSerr(TS_F_TS_RESP_GET_POLICY, TS_R_INVALID_NULL_POINTER);\r\nreturn NULL;\r\n}\r\nif (!requested || !OBJ_cmp(requested, ctx->default_policy))\r\npolicy = ctx->default_policy;\r\nfor (i = 0; !policy && i < sk_ASN1_OBJECT_num(ctx->policies); ++i)\r\n{\r\nASN1_OBJECT *current = sk_ASN1_OBJECT_value(ctx->policies, i);\r\nif (!OBJ_cmp(requested, current))\r\npolicy = current;\r\n}\r\nif (!policy)\r\n{\r\nTSerr(TS_F_TS_RESP_GET_POLICY, TS_R_UNACCEPTABLE_POLICY);\r\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\r\n"Requested policy is not "\r\n"supported.");\r\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_UNACCEPTED_POLICY);\r\n}\r\nreturn policy;\r\n}\r\nstatic TS_TST_INFO *TS_RESP_create_tst_info(TS_RESP_CTX *ctx,\r\nASN1_OBJECT *policy)\r\n{\r\nint result = 0;\r\nTS_TST_INFO *tst_info = NULL;\r\nASN1_INTEGER *serial = NULL;\r\nASN1_GENERALIZEDTIME *asn1_time = NULL;\r\nlong sec, usec;\r\nTS_ACCURACY *accuracy = NULL;\r\nconst ASN1_INTEGER *nonce;\r\nGENERAL_NAME *tsa_name = NULL;\r\nif (!(tst_info = TS_TST_INFO_new())) goto end;\r\nif (!TS_TST_INFO_set_version(tst_info, 1)) goto end;\r\nif (!TS_TST_INFO_set_policy_id(tst_info, policy)) goto end;\r\nif (!TS_TST_INFO_set_msg_imprint(tst_info, ctx->request->msg_imprint))\r\ngoto end;\r\nif (!(serial = (*ctx->serial_cb)(ctx, ctx->serial_cb_data))\r\n|| !TS_TST_INFO_set_serial(tst_info, serial))\r\ngoto end;\r\nif (!(*ctx->time_cb)(ctx, ctx->time_cb_data, &sec, &usec)\r\n|| !(asn1_time = TS_RESP_set_genTime_with_precision(NULL,\r\nsec, usec,\r\nctx->clock_precision_digits))\r\n|| !TS_TST_INFO_set_time(tst_info, asn1_time))\r\ngoto end;\r\nif ((ctx->seconds || ctx->millis || ctx->micros)\r\n&& !(accuracy = TS_ACCURACY_new()))\r\ngoto end;\r\nif (ctx->seconds && !TS_ACCURACY_set_seconds(accuracy, ctx->seconds))\r\ngoto end;\r\nif (ctx->millis && !TS_ACCURACY_set_millis(accuracy, ctx->millis))\r\ngoto end;\r\nif (ctx->micros && !TS_ACCURACY_set_micros(accuracy, ctx->micros))\r\ngoto end;\r\nif (accuracy && !TS_TST_INFO_set_accuracy(tst_info, accuracy))\r\ngoto end;\r\nif ((ctx->flags & TS_ORDERING)\r\n&& !TS_TST_INFO_set_ordering(tst_info, 1))\r\ngoto end;\r\nif ((nonce = TS_REQ_get_nonce(ctx->request)) != NULL\r\n&& !TS_TST_INFO_set_nonce(tst_info, nonce))\r\ngoto end;\r\nif (ctx->flags & TS_TSA_NAME)\r\n{\r\nif (!(tsa_name = GENERAL_NAME_new())) goto end;\r\ntsa_name->type = GEN_DIRNAME;\r\ntsa_name->d.dirn =\r\nX509_NAME_dup(ctx->signer_cert->cert_info->subject);\r\nif (!tsa_name->d.dirn) goto end;\r\nif (!TS_TST_INFO_set_tsa(tst_info, tsa_name)) goto end;\r\n}\r\nresult = 1;\r\nend:\r\nif (!result)\r\n{\r\nTS_TST_INFO_free(tst_info);\r\ntst_info = NULL;\r\nTSerr(TS_F_TS_RESP_CREATE_TST_INFO, TS_R_TST_INFO_SETUP_ERROR);\r\nTS_RESP_CTX_set_status_info_cond(ctx, TS_STATUS_REJECTION,\r\n"Error during TSTInfo "\r\n"generation.");\r\n}\r\nGENERAL_NAME_free(tsa_name);\r\nTS_ACCURACY_free(accuracy);\r\nASN1_GENERALIZEDTIME_free(asn1_time);\r\nASN1_INTEGER_free(serial);\r\nreturn tst_info;\r\n}\r\nstatic int TS_RESP_process_extensions(TS_RESP_CTX *ctx)\r\n{\r\nSTACK_OF(X509_EXTENSION) *exts = TS_REQ_get_exts(ctx->request);\r\nint i;\r\nint ok = 1;\r\nfor (i = 0; ok && i < sk_X509_EXTENSION_num(exts); ++i)\r\n{\r\nX509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);\r\nok = (*ctx->extension_cb)(ctx, ext, NULL);\r\n}\r\nreturn ok;\r\n}\r\nstatic int TS_RESP_sign(TS_RESP_CTX *ctx)\r\n{\r\nint ret = 0;\r\nPKCS7 *p7 = NULL;\r\nPKCS7_SIGNER_INFO *si;\r\nSTACK_OF(X509) *certs;\r\nESS_SIGNING_CERT *sc = NULL;\r\nASN1_OBJECT *oid;\r\nBIO *p7bio = NULL;\r\nint i;\r\nif (!X509_check_private_key(ctx->signer_cert, ctx->signer_key)) {\r\nTSerr(TS_F_TS_RESP_SIGN,\r\nTS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);\r\ngoto err;\r\n}\r\nif (!(p7 = PKCS7_new())) {\r\nTSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\nif (!PKCS7_set_type(p7, NID_pkcs7_signed)) goto err;\r\nif (!ASN1_INTEGER_set(p7->d.sign->version, 3)) goto err;\r\nif (TS_REQ_get_cert_req(ctx->request))\r\n{\r\nPKCS7_add_certificate(p7, ctx->signer_cert);\r\nif (ctx->certs)\r\n{\r\nfor(i = 0; i < sk_X509_num(ctx->certs); ++i)\r\n{\r\nX509 *cert = sk_X509_value(ctx->certs, i);\r\nPKCS7_add_certificate(p7, cert);\r\n}\r\n}\r\n}\r\nif (!(si = PKCS7_add_signature(p7, ctx->signer_cert,\r\nctx->signer_key, EVP_sha1())))\r\n{\r\nTSerr(TS_F_TS_RESP_SIGN, TS_R_PKCS7_ADD_SIGNATURE_ERROR);\r\ngoto err;\r\n}\r\noid = OBJ_nid2obj(NID_id_smime_ct_TSTInfo);\r\nif (!PKCS7_add_signed_attribute(si, NID_pkcs9_contentType,\r\nV_ASN1_OBJECT, oid))\r\n{\r\nTSerr(TS_F_TS_RESP_SIGN, TS_R_PKCS7_ADD_SIGNED_ATTR_ERROR);\r\ngoto err;\r\n}\r\ncerts = ctx->flags & TS_ESS_CERT_ID_CHAIN ? ctx->certs : NULL;\r\nif (!(sc = ESS_SIGNING_CERT_new_init(ctx->signer_cert, certs)))\r\ngoto err;\r\nif (!ESS_add_signing_cert(si, sc))\r\n{\r\nTSerr(TS_F_TS_RESP_SIGN, TS_R_ESS_ADD_SIGNING_CERT_ERROR);\r\ngoto err;\r\n}\r\nif (!TS_TST_INFO_content_new(p7)) goto err;\r\nif (!(p7bio = PKCS7_dataInit(p7, NULL))) {\r\nTSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\nif (!i2d_TS_TST_INFO_bio(p7bio, ctx->tst_info))\r\n{\r\nTSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);\r\ngoto err;\r\n}\r\nif (!PKCS7_dataFinal(p7, p7bio))\r\n{\r\nTSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);\r\ngoto err;\r\n}\r\nTS_RESP_set_tst_info(ctx->response, p7, ctx->tst_info);\r\np7 = NULL;\r\nctx->tst_info = NULL;\r\nret = 1;\r\nerr:\r\nif (!ret)\r\nTS_RESP_CTX_set_status_info_cond(ctx, TS_STATUS_REJECTION,\r\n"Error during signature "\r\n"generation.");\r\nBIO_free_all(p7bio);\r\nESS_SIGNING_CERT_free(sc);\r\nPKCS7_free(p7);\r\nreturn ret;\r\n}\r\nstatic ESS_CERT_ID *ESS_CERT_ID_new_init(X509 *cert, int issuer_needed)\r\n{\r\nESS_CERT_ID *cid = NULL;\r\nGENERAL_NAME *name = NULL;\r\nX509_check_purpose(cert, -1, 0);\r\nif (!(cid = ESS_CERT_ID_new())) goto err;\r\nif (!ASN1_OCTET_STRING_set(cid->hash, cert->sha1_hash,\r\nsizeof(cert->sha1_hash)))\r\ngoto err;\r\nif (issuer_needed)\r\n{\r\nif (!cid->issuer_serial\r\n&& !(cid->issuer_serial = ESS_ISSUER_SERIAL_new()))\r\ngoto err;\r\nif (!(name = GENERAL_NAME_new())) goto err;\r\nname->type = GEN_DIRNAME;\r\nif (!(name->d.dirn = X509_NAME_dup(cert->cert_info->issuer)))\r\ngoto err;\r\nif (!sk_GENERAL_NAME_push(cid->issuer_serial->issuer, name))\r\ngoto err;\r\nname = NULL;\r\nASN1_INTEGER_free(cid->issuer_serial->serial);\r\nif (!(cid->issuer_serial->serial =\r\nASN1_INTEGER_dup(cert->cert_info->serialNumber)))\r\ngoto err;\r\n}\r\nreturn cid;\r\nerr:\r\nGENERAL_NAME_free(name);\r\nESS_CERT_ID_free(cid);\r\nTSerr(TS_F_ESS_CERT_ID_NEW_INIT, ERR_R_MALLOC_FAILURE);\r\nreturn NULL;\r\n}\r\nstatic int TS_TST_INFO_content_new(PKCS7 *p7)\r\n{\r\nPKCS7 *ret = NULL;\r\nASN1_OCTET_STRING *octet_string = NULL;\r\nif (!(ret = PKCS7_new())) goto err;\r\nif (!(ret->d.other = ASN1_TYPE_new())) goto err;\r\nret->type = OBJ_nid2obj(NID_id_smime_ct_TSTInfo);\r\nif (!(octet_string = ASN1_OCTET_STRING_new())) goto err;\r\nASN1_TYPE_set(ret->d.other, V_ASN1_OCTET_STRING, octet_string);\r\noctet_string = NULL;\r\nif (!PKCS7_set_content(p7, ret)) goto err;\r\nreturn 1;\r\nerr:\r\nASN1_OCTET_STRING_free(octet_string);\r\nPKCS7_free(ret);\r\nreturn 0;\r\n}\r\nstatic int ESS_add_signing_cert(PKCS7_SIGNER_INFO *si, ESS_SIGNING_CERT *sc)\r\n{\r\nASN1_STRING *seq = NULL;\r\nunsigned char *p, *pp = NULL;\r\nint len;\r\nlen = i2d_ESS_SIGNING_CERT(sc, NULL);\r\nif (!(pp = (unsigned char *) OPENSSL_malloc(len)))\r\n{\r\nTSerr(TS_F_ESS_ADD_SIGNING_CERT, ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\np = pp;\r\ni2d_ESS_SIGNING_CERT(sc, &p);\r\nif (!(seq = ASN1_STRING_new()) || !ASN1_STRING_set(seq, pp, len))\r\n{\r\nTSerr(TS_F_ESS_ADD_SIGNING_CERT, ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\nOPENSSL_free(pp); pp = NULL;\r\nreturn PKCS7_add_signed_attribute(si,\r\nNID_id_smime_aa_signingCertificate,\r\nV_ASN1_SEQUENCE, seq);\r\nerr:\r\nASN1_STRING_free(seq);\r\nOPENSSL_free(pp);\r\nreturn 0;\r\n}\r\nstatic ASN1_GENERALIZEDTIME *\r\nTS_RESP_set_genTime_with_precision(ASN1_GENERALIZEDTIME *asn1_time,\r\nlong sec, long usec, unsigned precision)\r\n{\r\ntime_t time_sec = (time_t) sec;\r\nstruct tm *tm = NULL;\r\nchar genTime_str[17 + TS_MAX_CLOCK_PRECISION_DIGITS];\r\nchar *p = genTime_str;\r\nchar *p_end = genTime_str + sizeof(genTime_str);\r\nif (precision > TS_MAX_CLOCK_PRECISION_DIGITS)\r\ngoto err;\r\nif (!(tm = gmtime(&time_sec)))\r\ngoto err;\r\np += BIO_snprintf(p, p_end - p,\r\n"%04d%02d%02d%02d%02d%02d",\r\ntm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,\r\ntm->tm_hour, tm->tm_min, tm->tm_sec);\r\nif (precision > 0)\r\n{\r\nBIO_snprintf(p, 2 + precision, ".%ld", usec);\r\np += strlen(p);\r\nwhile (*--p == '0')\r\n;\r\nif (*p != '.') ++p;\r\n}\r\n*p++ = 'Z';\r\n*p++ = '\0';\r\nif (!asn1_time && !(asn1_time = M_ASN1_GENERALIZEDTIME_new()))\r\ngoto err;\r\nif (!ASN1_GENERALIZEDTIME_set_string(asn1_time, genTime_str))\r\n{\r\nASN1_GENERALIZEDTIME_free(asn1_time);\r\ngoto err;\r\n}\r\nreturn asn1_time;\r\nerr:\r\nTSerr(TS_F_TS_RESP_SET_GENTIME_WITH_PRECISION, TS_R_COULD_NOT_SET_TIME);\r\nreturn NULL;\r\n}
