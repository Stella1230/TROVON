int Camellia_Ekeygen(int keyBitLength, const u8 *rawKey, KEY_TABLE_TYPE k)\r\n{\r\nregister u32 s0,s1,s2,s3;\r\nk[0] = s0 = GETU32(rawKey);\r\nk[1] = s1 = GETU32(rawKey+4);\r\nk[2] = s2 = GETU32(rawKey+8);\r\nk[3] = s3 = GETU32(rawKey+12);\r\nif (keyBitLength != 128)\r\n{\r\nk[8] = s0 = GETU32(rawKey+16);\r\nk[9] = s1 = GETU32(rawKey+20);\r\nif (keyBitLength == 192)\r\n{\r\nk[10] = s2 = ~s0;\r\nk[11] = s3 = ~s1;\r\n}\r\nelse\r\n{\r\nk[10] = s2 = GETU32(rawKey+24);\r\nk[11] = s3 = GETU32(rawKey+28);\r\n}\r\ns0 ^= k[0], s1 ^= k[1], s2 ^= k[2], s3 ^= k[3];\r\n}\r\nCamellia_Feistel(s0,s1,s2,s3,SIGMA+0);\r\nCamellia_Feistel(s2,s3,s0,s1,SIGMA+2);\r\ns0 ^= k[0], s1 ^= k[1], s2 ^= k[2], s3 ^= k[3];\r\nCamellia_Feistel(s0,s1,s2,s3,SIGMA+4);\r\nCamellia_Feistel(s2,s3,s0,s1,SIGMA+6);\r\nif (keyBitLength == 128)\r\n{\r\nk[ 4] = s0, k[ 5] = s1, k[ 6] = s2, k[ 7] = s3;\r\nRotLeft128(s0,s1,s2,s3,15);\r\nk[12] = s0, k[13] = s1, k[14] = s2, k[15] = s3;\r\nRotLeft128(s0,s1,s2,s3,15);\r\nk[16] = s0, k[17] = s1, k[18] = s2, k[19] = s3;\r\nRotLeft128(s0,s1,s2,s3,15);\r\nk[24] = s0, k[25] = s1;\r\nRotLeft128(s0,s1,s2,s3,15);\r\nk[28] = s0, k[29] = s1, k[30] = s2, k[31] = s3;\r\nRotLeft128(s1,s2,s3,s0,2);\r\nk[40] = s1, k[41] = s2, k[42] = s3, k[43] = s0;\r\nRotLeft128(s1,s2,s3,s0,17);\r\nk[48] = s1, k[49] = s2, k[50] = s3, k[51] = s0;\r\ns0 = k[ 0], s1 = k[ 1], s2 = k[ 2], s3 = k[ 3];\r\nRotLeft128(s0,s1,s2,s3,15);\r\nk[ 8] = s0, k[ 9] = s1, k[10] = s2, k[11] = s3;\r\nRotLeft128(s0,s1,s2,s3,30);\r\nk[20] = s0, k[21] = s1, k[22] = s2, k[23] = s3;\r\nRotLeft128(s0,s1,s2,s3,15);\r\nk[26] = s2, k[27] = s3;\r\nRotLeft128(s0,s1,s2,s3,17);\r\nk[32] = s0, k[33] = s1, k[34] = s2, k[35] = s3;\r\nRotLeft128(s0,s1,s2,s3,17);\r\nk[36] = s0, k[37] = s1, k[38] = s2, k[39] = s3;\r\nRotLeft128(s0,s1,s2,s3,17);\r\nk[44] = s0, k[45] = s1, k[46] = s2, k[47] = s3;\r\nreturn 3;\r\n}\r\nelse\r\n{\r\nk[12] = s0, k[13] = s1, k[14] = s2, k[15] = s3;\r\ns0 ^= k[8], s1 ^= k[9], s2 ^=k[10], s3 ^=k[11];\r\nCamellia_Feistel(s0,s1,s2,s3,(SIGMA+8));\r\nCamellia_Feistel(s2,s3,s0,s1,(SIGMA+10));\r\nk[ 4] = s0, k[ 5] = s1, k[ 6] = s2, k[ 7] = s3;\r\nRotLeft128(s0,s1,s2,s3,30);\r\nk[20] = s0, k[21] = s1, k[22] = s2, k[23] = s3;\r\nRotLeft128(s0,s1,s2,s3,30);\r\nk[40] = s0, k[41] = s1, k[42] = s2, k[43] = s3;\r\nRotLeft128(s1,s2,s3,s0,19);\r\nk[64] = s1, k[65] = s2, k[66] = s3, k[67] = s0;\r\ns0 = k[ 8], s1 = k[ 9], s2 = k[10], s3 = k[11];\r\nRotLeft128(s0,s1,s2,s3,15);\r\nk[ 8] = s0, k[ 9] = s1, k[10] = s2, k[11] = s3;\r\nRotLeft128(s0,s1,s2,s3,15);\r\nk[16] = s0, k[17] = s1, k[18] = s2, k[19] = s3;\r\nRotLeft128(s0,s1,s2,s3,30);\r\nk[36] = s0, k[37] = s1, k[38] = s2, k[39] = s3;\r\nRotLeft128(s1,s2,s3,s0,2);\r\nk[52] = s1, k[53] = s2, k[54] = s3, k[55] = s0;\r\ns0 = k[12], s1 = k[13], s2 = k[14], s3 = k[15];\r\nRotLeft128(s0,s1,s2,s3,15);\r\nk[12] = s0, k[13] = s1, k[14] = s2, k[15] = s3;\r\nRotLeft128(s0,s1,s2,s3,30);\r\nk[28] = s0, k[29] = s1, k[30] = s2, k[31] = s3;\r\nk[48] = s1, k[49] = s2, k[50] = s3, k[51] = s0;\r\nRotLeft128(s1,s2,s3,s0,17);\r\nk[56] = s1, k[57] = s2, k[58] = s3, k[59] = s0;\r\ns0 = k[ 0], s1 = k[ 1], s2 = k[ 2], s3 = k[ 3];\r\nRotLeft128(s1,s2,s3,s0,13);\r\nk[24] = s1, k[25] = s2, k[26] = s3, k[27] = s0;\r\nRotLeft128(s1,s2,s3,s0,15);\r\nk[32] = s1, k[33] = s2, k[34] = s3, k[35] = s0;\r\nRotLeft128(s1,s2,s3,s0,17);\r\nk[44] = s1, k[45] = s2, k[46] = s3, k[47] = s0;\r\nRotLeft128(s2,s3,s0,s1,2);\r\nk[60] = s2, k[61] = s3, k[62] = s0, k[63] = s1;\r\nreturn 4;\r\n}\r\n}\r\nvoid Camellia_EncryptBlock_Rounds(int grandRounds, const u8 plaintext[],\r\nconst KEY_TABLE_TYPE keyTable, u8 ciphertext[])\r\n{\r\nregister u32 s0,s1,s2,s3;\r\nconst u32 *k = keyTable,*kend = keyTable+grandRounds*16;\r\ns0 = GETU32(plaintext) ^ k[0];\r\ns1 = GETU32(plaintext+4) ^ k[1];\r\ns2 = GETU32(plaintext+8) ^ k[2];\r\ns3 = GETU32(plaintext+12) ^ k[3];\r\nk += 4;\r\nwhile (1)\r\n{\r\nCamellia_Feistel(s0,s1,s2,s3,k+0);\r\nCamellia_Feistel(s2,s3,s0,s1,k+2);\r\nCamellia_Feistel(s0,s1,s2,s3,k+4);\r\nCamellia_Feistel(s2,s3,s0,s1,k+6);\r\nCamellia_Feistel(s0,s1,s2,s3,k+8);\r\nCamellia_Feistel(s2,s3,s0,s1,k+10);\r\nk += 12;\r\nif (k == kend) break;\r\ns1 ^= LeftRotate(s0 & k[0], 1);\r\ns2 ^= s3 | k[3];\r\ns0 ^= s1 | k[1];\r\ns3 ^= LeftRotate(s2 & k[2], 1);\r\nk += 4;\r\n}\r\ns2 ^= k[0], s3 ^= k[1], s0 ^= k[2], s1 ^= k[3];\r\nPUTU32(ciphertext, s2);\r\nPUTU32(ciphertext+4, s3);\r\nPUTU32(ciphertext+8, s0);\r\nPUTU32(ciphertext+12,s1);\r\n}\r\nvoid Camellia_EncryptBlock(int keyBitLength, const u8 plaintext[],\r\nconst KEY_TABLE_TYPE keyTable, u8 ciphertext[])\r\n{\r\nCamellia_EncryptBlock_Rounds(keyBitLength==128?3:4,\r\nplaintext,keyTable,ciphertext);\r\n}\r\nvoid Camellia_DecryptBlock_Rounds(int grandRounds, const u8 ciphertext[],\r\nconst KEY_TABLE_TYPE keyTable, u8 plaintext[])\r\n{\r\nu32 s0,s1,s2,s3;\r\nconst u32 *k = keyTable+grandRounds*16,*kend = keyTable+4;\r\ns0 = GETU32(ciphertext) ^ k[0];\r\ns1 = GETU32(ciphertext+4) ^ k[1];\r\ns2 = GETU32(ciphertext+8) ^ k[2];\r\ns3 = GETU32(ciphertext+12) ^ k[3];\r\nwhile (1)\r\n{\r\nk -= 12;\r\nCamellia_Feistel(s0,s1,s2,s3,k+10);\r\nCamellia_Feistel(s2,s3,s0,s1,k+8);\r\nCamellia_Feistel(s0,s1,s2,s3,k+6);\r\nCamellia_Feistel(s2,s3,s0,s1,k+4);\r\nCamellia_Feistel(s0,s1,s2,s3,k+2);\r\nCamellia_Feistel(s2,s3,s0,s1,k+0);\r\nif (k == kend) break;\r\nk -= 4;\r\ns1 ^= LeftRotate(s0 & k[2], 1);\r\ns2 ^= s3 | k[1];\r\ns0 ^= s1 | k[3];\r\ns3 ^= LeftRotate(s2 & k[0], 1);\r\n}\r\nk -= 4;\r\ns2 ^= k[0], s3 ^= k[1], s0 ^= k[2], s1 ^= k[3];\r\nPUTU32(plaintext, s2);\r\nPUTU32(plaintext+4, s3);\r\nPUTU32(plaintext+8, s0);\r\nPUTU32(plaintext+12,s1);\r\n}\r\nvoid Camellia_DecryptBlock(int keyBitLength, const u8 plaintext[],\r\nconst KEY_TABLE_TYPE keyTable, u8 ciphertext[])\r\n{\r\nCamellia_DecryptBlock_Rounds(keyBitLength==128?3:4,\r\nplaintext,keyTable,ciphertext);\r\n}
