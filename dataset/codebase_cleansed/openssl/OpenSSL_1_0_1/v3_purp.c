static int xp_cmp(const X509_PURPOSE * const *a,\r\nconst X509_PURPOSE * const *b)\r\n{\r\nreturn (*a)->purpose - (*b)->purpose;\r\n}\r\nint X509_check_purpose(X509 *x, int id, int ca)\r\n{\r\nint idx;\r\nconst X509_PURPOSE *pt;\r\nif(!(x->ex_flags & EXFLAG_SET)) {\r\nCRYPTO_w_lock(CRYPTO_LOCK_X509);\r\nx509v3_cache_extensions(x);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_X509);\r\n}\r\nif(id == -1) return 1;\r\nidx = X509_PURPOSE_get_by_id(id);\r\nif(idx == -1) return -1;\r\npt = X509_PURPOSE_get0(idx);\r\nreturn pt->check_purpose(pt, x, ca);\r\n}\r\nint X509_PURPOSE_set(int *p, int purpose)\r\n{\r\nif(X509_PURPOSE_get_by_id(purpose) == -1) {\r\nX509V3err(X509V3_F_X509_PURPOSE_SET, X509V3_R_INVALID_PURPOSE);\r\nreturn 0;\r\n}\r\n*p = purpose;\r\nreturn 1;\r\n}\r\nint X509_PURPOSE_get_count(void)\r\n{\r\nif(!xptable) return X509_PURPOSE_COUNT;\r\nreturn sk_X509_PURPOSE_num(xptable) + X509_PURPOSE_COUNT;\r\n}\r\nX509_PURPOSE * X509_PURPOSE_get0(int idx)\r\n{\r\nif(idx < 0) return NULL;\r\nif(idx < (int)X509_PURPOSE_COUNT) return xstandard + idx;\r\nreturn sk_X509_PURPOSE_value(xptable, idx - X509_PURPOSE_COUNT);\r\n}\r\nint X509_PURPOSE_get_by_sname(char *sname)\r\n{\r\nint i;\r\nX509_PURPOSE *xptmp;\r\nfor(i = 0; i < X509_PURPOSE_get_count(); i++) {\r\nxptmp = X509_PURPOSE_get0(i);\r\nif(!strcmp(xptmp->sname, sname)) return i;\r\n}\r\nreturn -1;\r\n}\r\nint X509_PURPOSE_get_by_id(int purpose)\r\n{\r\nX509_PURPOSE tmp;\r\nint idx;\r\nif((purpose >= X509_PURPOSE_MIN) && (purpose <= X509_PURPOSE_MAX))\r\nreturn purpose - X509_PURPOSE_MIN;\r\ntmp.purpose = purpose;\r\nif(!xptable) return -1;\r\nidx = sk_X509_PURPOSE_find(xptable, &tmp);\r\nif(idx == -1) return -1;\r\nreturn idx + X509_PURPOSE_COUNT;\r\n}\r\nint X509_PURPOSE_add(int id, int trust, int flags,\r\nint (*ck)(const X509_PURPOSE *, const X509 *, int),\r\nchar *name, char *sname, void *arg)\r\n{\r\nint idx;\r\nX509_PURPOSE *ptmp;\r\nflags &= ~X509_PURPOSE_DYNAMIC;\r\nflags |= X509_PURPOSE_DYNAMIC_NAME;\r\nidx = X509_PURPOSE_get_by_id(id);\r\nif(idx == -1) {\r\nif(!(ptmp = OPENSSL_malloc(sizeof(X509_PURPOSE)))) {\r\nX509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nptmp->flags = X509_PURPOSE_DYNAMIC;\r\n} else ptmp = X509_PURPOSE_get0(idx);\r\nif(ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) {\r\nOPENSSL_free(ptmp->name);\r\nOPENSSL_free(ptmp->sname);\r\n}\r\nptmp->name = BUF_strdup(name);\r\nptmp->sname = BUF_strdup(sname);\r\nif(!ptmp->name || !ptmp->sname) {\r\nX509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nptmp->flags &= X509_PURPOSE_DYNAMIC;\r\nptmp->flags |= flags;\r\nptmp->purpose = id;\r\nptmp->trust = trust;\r\nptmp->check_purpose = ck;\r\nptmp->usr_data = arg;\r\nif(idx == -1) {\r\nif(!xptable && !(xptable = sk_X509_PURPOSE_new(xp_cmp))) {\r\nX509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nif (!sk_X509_PURPOSE_push(xptable, ptmp)) {\r\nX509V3err(X509V3_F_X509_PURPOSE_ADD,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void xptable_free(X509_PURPOSE *p)\r\n{\r\nif(!p) return;\r\nif (p->flags & X509_PURPOSE_DYNAMIC)\r\n{\r\nif (p->flags & X509_PURPOSE_DYNAMIC_NAME) {\r\nOPENSSL_free(p->name);\r\nOPENSSL_free(p->sname);\r\n}\r\nOPENSSL_free(p);\r\n}\r\n}\r\nvoid X509_PURPOSE_cleanup(void)\r\n{\r\nunsigned int i;\r\nsk_X509_PURPOSE_pop_free(xptable, xptable_free);\r\nfor(i = 0; i < X509_PURPOSE_COUNT; i++) xptable_free(xstandard + i);\r\nxptable = NULL;\r\n}\r\nint X509_PURPOSE_get_id(X509_PURPOSE *xp)\r\n{\r\nreturn xp->purpose;\r\n}\r\nchar *X509_PURPOSE_get0_name(X509_PURPOSE *xp)\r\n{\r\nreturn xp->name;\r\n}\r\nchar *X509_PURPOSE_get0_sname(X509_PURPOSE *xp)\r\n{\r\nreturn xp->sname;\r\n}\r\nint X509_PURPOSE_get_trust(X509_PURPOSE *xp)\r\n{\r\nreturn xp->trust;\r\n}\r\nstatic int nid_cmp(const int *a, const int *b)\r\n{\r\nreturn *a - *b;\r\n}\r\nint X509_supported_extension(X509_EXTENSION *ex)\r\n{\r\nstatic const int supported_nids[] = {\r\nNID_netscape_cert_type,\r\nNID_key_usage,\r\nNID_subject_alt_name,\r\nNID_basic_constraints,\r\nNID_certificate_policies,\r\nNID_ext_key_usage,\r\n#ifndef OPENSSL_NO_RFC3779\r\nNID_sbgp_ipAddrBlock,\r\nNID_sbgp_autonomousSysNum,\r\n#endif\r\nNID_policy_constraints,\r\nNID_proxyCertInfo,\r\nNID_name_constraints,\r\nNID_policy_mappings,\r\nNID_inhibit_any_policy\r\n};\r\nint ex_nid = OBJ_obj2nid(X509_EXTENSION_get_object(ex));\r\nif (ex_nid == NID_undef)\r\nreturn 0;\r\nif (OBJ_bsearch_nid(&ex_nid, supported_nids,\r\nsizeof(supported_nids)/sizeof(int)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void setup_dp(X509 *x, DIST_POINT *dp)\r\n{\r\nX509_NAME *iname = NULL;\r\nint i;\r\nif (dp->reasons)\r\n{\r\nif (dp->reasons->length > 0)\r\ndp->dp_reasons = dp->reasons->data[0];\r\nif (dp->reasons->length > 1)\r\ndp->dp_reasons |= (dp->reasons->data[1] << 8);\r\ndp->dp_reasons &= CRLDP_ALL_REASONS;\r\n}\r\nelse\r\ndp->dp_reasons = CRLDP_ALL_REASONS;\r\nif (!dp->distpoint || (dp->distpoint->type != 1))\r\nreturn;\r\nfor (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++)\r\n{\r\nGENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);\r\nif (gen->type == GEN_DIRNAME)\r\n{\r\niname = gen->d.directoryName;\r\nbreak;\r\n}\r\n}\r\nif (!iname)\r\niname = X509_get_issuer_name(x);\r\nDIST_POINT_set_dpname(dp->distpoint, iname);\r\n}\r\nstatic void setup_crldp(X509 *x)\r\n{\r\nint i;\r\nx->crldp = X509_get_ext_d2i(x, NID_crl_distribution_points, NULL, NULL);\r\nfor (i = 0; i < sk_DIST_POINT_num(x->crldp); i++)\r\nsetup_dp(x, sk_DIST_POINT_value(x->crldp, i));\r\n}\r\nstatic void x509v3_cache_extensions(X509 *x)\r\n{\r\nBASIC_CONSTRAINTS *bs;\r\nPROXY_CERT_INFO_EXTENSION *pci;\r\nASN1_BIT_STRING *usage;\r\nASN1_BIT_STRING *ns;\r\nEXTENDED_KEY_USAGE *extusage;\r\nX509_EXTENSION *ex;\r\nint i;\r\nif(x->ex_flags & EXFLAG_SET) return;\r\n#ifndef OPENSSL_NO_SHA\r\nX509_digest(x, EVP_sha1(), x->sha1_hash, NULL);\r\n#endif\r\nif(!X509_NAME_cmp(X509_get_subject_name(x), X509_get_issuer_name(x)))\r\nx->ex_flags |= EXFLAG_SI;\r\nif(!X509_get_version(x)) x->ex_flags |= EXFLAG_V1;\r\nif((bs=X509_get_ext_d2i(x, NID_basic_constraints, NULL, NULL))) {\r\nif(bs->ca) x->ex_flags |= EXFLAG_CA;\r\nif(bs->pathlen) {\r\nif((bs->pathlen->type == V_ASN1_NEG_INTEGER)\r\n|| !bs->ca) {\r\nx->ex_flags |= EXFLAG_INVALID;\r\nx->ex_pathlen = 0;\r\n} else x->ex_pathlen = ASN1_INTEGER_get(bs->pathlen);\r\n} else x->ex_pathlen = -1;\r\nBASIC_CONSTRAINTS_free(bs);\r\nx->ex_flags |= EXFLAG_BCONS;\r\n}\r\nif((pci=X509_get_ext_d2i(x, NID_proxyCertInfo, NULL, NULL))) {\r\nif (x->ex_flags & EXFLAG_CA\r\n|| X509_get_ext_by_NID(x, NID_subject_alt_name, 0) >= 0\r\n|| X509_get_ext_by_NID(x, NID_issuer_alt_name, 0) >= 0) {\r\nx->ex_flags |= EXFLAG_INVALID;\r\n}\r\nif (pci->pcPathLengthConstraint) {\r\nx->ex_pcpathlen =\r\nASN1_INTEGER_get(pci->pcPathLengthConstraint);\r\n} else x->ex_pcpathlen = -1;\r\nPROXY_CERT_INFO_EXTENSION_free(pci);\r\nx->ex_flags |= EXFLAG_PROXY;\r\n}\r\nif((usage=X509_get_ext_d2i(x, NID_key_usage, NULL, NULL))) {\r\nif(usage->length > 0) {\r\nx->ex_kusage = usage->data[0];\r\nif(usage->length > 1)\r\nx->ex_kusage |= usage->data[1] << 8;\r\n} else x->ex_kusage = 0;\r\nx->ex_flags |= EXFLAG_KUSAGE;\r\nASN1_BIT_STRING_free(usage);\r\n}\r\nx->ex_xkusage = 0;\r\nif((extusage=X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL))) {\r\nx->ex_flags |= EXFLAG_XKUSAGE;\r\nfor(i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {\r\nswitch(OBJ_obj2nid(sk_ASN1_OBJECT_value(extusage,i))) {\r\ncase NID_server_auth:\r\nx->ex_xkusage |= XKU_SSL_SERVER;\r\nbreak;\r\ncase NID_client_auth:\r\nx->ex_xkusage |= XKU_SSL_CLIENT;\r\nbreak;\r\ncase NID_email_protect:\r\nx->ex_xkusage |= XKU_SMIME;\r\nbreak;\r\ncase NID_code_sign:\r\nx->ex_xkusage |= XKU_CODE_SIGN;\r\nbreak;\r\ncase NID_ms_sgc:\r\ncase NID_ns_sgc:\r\nx->ex_xkusage |= XKU_SGC;\r\nbreak;\r\ncase NID_OCSP_sign:\r\nx->ex_xkusage |= XKU_OCSP_SIGN;\r\nbreak;\r\ncase NID_time_stamp:\r\nx->ex_xkusage |= XKU_TIMESTAMP;\r\nbreak;\r\ncase NID_dvcs:\r\nx->ex_xkusage |= XKU_DVCS;\r\nbreak;\r\n}\r\n}\r\nsk_ASN1_OBJECT_pop_free(extusage, ASN1_OBJECT_free);\r\n}\r\nif((ns=X509_get_ext_d2i(x, NID_netscape_cert_type, NULL, NULL))) {\r\nif(ns->length > 0) x->ex_nscert = ns->data[0];\r\nelse x->ex_nscert = 0;\r\nx->ex_flags |= EXFLAG_NSCERT;\r\nASN1_BIT_STRING_free(ns);\r\n}\r\nx->skid =X509_get_ext_d2i(x, NID_subject_key_identifier, NULL, NULL);\r\nx->akid =X509_get_ext_d2i(x, NID_authority_key_identifier, NULL, NULL);\r\nx->altname = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);\r\nx->nc = X509_get_ext_d2i(x, NID_name_constraints, &i, NULL);\r\nif (!x->nc && (i != -1))\r\nx->ex_flags |= EXFLAG_INVALID;\r\nsetup_crldp(x);\r\n#ifndef OPENSSL_NO_RFC3779\r\nx->rfc3779_addr =X509_get_ext_d2i(x, NID_sbgp_ipAddrBlock, NULL, NULL);\r\nx->rfc3779_asid =X509_get_ext_d2i(x, NID_sbgp_autonomousSysNum,\r\nNULL, NULL);\r\n#endif\r\nfor (i = 0; i < X509_get_ext_count(x); i++)\r\n{\r\nex = X509_get_ext(x, i);\r\nif (!X509_EXTENSION_get_critical(ex))\r\ncontinue;\r\nif (OBJ_obj2nid(X509_EXTENSION_get_object(ex))\r\n== NID_freshest_crl)\r\nx->ex_flags |= EXFLAG_FRESHEST;\r\nif (!X509_supported_extension(ex))\r\n{\r\nx->ex_flags |= EXFLAG_CRITICAL;\r\nbreak;\r\n}\r\n}\r\nx->ex_flags |= EXFLAG_SET;\r\n}\r\nstatic int check_ca(const X509 *x)\r\n{\r\nif(ku_reject(x, KU_KEY_CERT_SIGN)) return 0;\r\nif(x->ex_flags & EXFLAG_BCONS) {\r\nif(x->ex_flags & EXFLAG_CA) return 1;\r\nelse return 0;\r\n} else {\r\nif((x->ex_flags & V1_ROOT) == V1_ROOT) return 3;\r\nelse if (x->ex_flags & EXFLAG_KUSAGE) return 4;\r\nelse if (x->ex_flags & EXFLAG_NSCERT\r\n&& x->ex_nscert & NS_ANY_CA) return 5;\r\nreturn 0;\r\n}\r\n}\r\nint X509_check_ca(X509 *x)\r\n{\r\nif(!(x->ex_flags & EXFLAG_SET)) {\r\nCRYPTO_w_lock(CRYPTO_LOCK_X509);\r\nx509v3_cache_extensions(x);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_X509);\r\n}\r\nreturn check_ca(x);\r\n}\r\nstatic int check_ssl_ca(const X509 *x)\r\n{\r\nint ca_ret;\r\nca_ret = check_ca(x);\r\nif(!ca_ret) return 0;\r\nif(ca_ret != 5 || x->ex_nscert & NS_SSL_CA) return ca_ret;\r\nelse return 0;\r\n}\r\nstatic int check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x, int ca)\r\n{\r\nif(xku_reject(x,XKU_SSL_CLIENT)) return 0;\r\nif(ca) return check_ssl_ca(x);\r\nif(ku_reject(x,KU_DIGITAL_SIGNATURE)) return 0;\r\nif(ns_reject(x, NS_SSL_CLIENT)) return 0;\r\nreturn 1;\r\n}\r\nstatic int check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)\r\n{\r\nif(xku_reject(x,XKU_SSL_SERVER|XKU_SGC)) return 0;\r\nif(ca) return check_ssl_ca(x);\r\nif(ns_reject(x, NS_SSL_SERVER)) return 0;\r\nif(ku_reject(x, KU_DIGITAL_SIGNATURE|KU_KEY_ENCIPHERMENT)) return 0;\r\nreturn 1;\r\n}\r\nstatic int check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x, int ca)\r\n{\r\nint ret;\r\nret = check_purpose_ssl_server(xp, x, ca);\r\nif(!ret || ca) return ret;\r\nif(ku_reject(x, KU_KEY_ENCIPHERMENT)) return 0;\r\nreturn ret;\r\n}\r\nstatic int purpose_smime(const X509 *x, int ca)\r\n{\r\nif(xku_reject(x,XKU_SMIME)) return 0;\r\nif(ca) {\r\nint ca_ret;\r\nca_ret = check_ca(x);\r\nif(!ca_ret) return 0;\r\nif(ca_ret != 5 || x->ex_nscert & NS_SMIME_CA) return ca_ret;\r\nelse return 0;\r\n}\r\nif(x->ex_flags & EXFLAG_NSCERT) {\r\nif(x->ex_nscert & NS_SMIME) return 1;\r\nif(x->ex_nscert & NS_SSL_CLIENT) return 2;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x, int ca)\r\n{\r\nint ret;\r\nret = purpose_smime(x, ca);\r\nif(!ret || ca) return ret;\r\nif(ku_reject(x, KU_DIGITAL_SIGNATURE|KU_NON_REPUDIATION)) return 0;\r\nreturn ret;\r\n}\r\nstatic int check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x, int ca)\r\n{\r\nint ret;\r\nret = purpose_smime(x, ca);\r\nif(!ret || ca) return ret;\r\nif(ku_reject(x, KU_KEY_ENCIPHERMENT)) return 0;\r\nreturn ret;\r\n}\r\nstatic int check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x, int ca)\r\n{\r\nif(ca) {\r\nint ca_ret;\r\nif((ca_ret = check_ca(x)) != 2) return ca_ret;\r\nelse return 0;\r\n}\r\nif(ku_reject(x, KU_CRL_SIGN)) return 0;\r\nreturn 1;\r\n}\r\nstatic int ocsp_helper(const X509_PURPOSE *xp, const X509 *x, int ca)\r\n{\r\nif(ca) return check_ca(x);\r\nreturn 1;\r\n}\r\nstatic int check_purpose_timestamp_sign(const X509_PURPOSE *xp, const X509 *x,\r\nint ca)\r\n{\r\nint i_ext;\r\nif (ca) return check_ca(x);\r\nif ((x->ex_flags & EXFLAG_KUSAGE)\r\n&& ((x->ex_kusage & ~(KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE)) ||\r\n!(x->ex_kusage & (KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE))))\r\nreturn 0;\r\nif (!(x->ex_flags & EXFLAG_XKUSAGE) || x->ex_xkusage != XKU_TIMESTAMP)\r\nreturn 0;\r\ni_ext = X509_get_ext_by_NID((X509 *) x, NID_ext_key_usage, 0);\r\nif (i_ext >= 0)\r\n{\r\nX509_EXTENSION *ext = X509_get_ext((X509 *) x, i_ext);\r\nif (!X509_EXTENSION_get_critical(ext))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int no_check(const X509_PURPOSE *xp, const X509 *x, int ca)\r\n{\r\nreturn 1;\r\n}\r\nint X509_check_issued(X509 *issuer, X509 *subject)\r\n{\r\nif(X509_NAME_cmp(X509_get_subject_name(issuer),\r\nX509_get_issuer_name(subject)))\r\nreturn X509_V_ERR_SUBJECT_ISSUER_MISMATCH;\r\nx509v3_cache_extensions(issuer);\r\nx509v3_cache_extensions(subject);\r\nif(subject->akid)\r\n{\r\nint ret = X509_check_akid(issuer, subject->akid);\r\nif (ret != X509_V_OK)\r\nreturn ret;\r\n}\r\nif(subject->ex_flags & EXFLAG_PROXY)\r\n{\r\nif(ku_reject(issuer, KU_DIGITAL_SIGNATURE))\r\nreturn X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE;\r\n}\r\nelse if(ku_reject(issuer, KU_KEY_CERT_SIGN))\r\nreturn X509_V_ERR_KEYUSAGE_NO_CERTSIGN;\r\nreturn X509_V_OK;\r\n}\r\nint X509_check_akid(X509 *issuer, AUTHORITY_KEYID *akid)\r\n{\r\nif(!akid)\r\nreturn X509_V_OK;\r\nif(akid->keyid && issuer->skid &&\r\nASN1_OCTET_STRING_cmp(akid->keyid, issuer->skid) )\r\nreturn X509_V_ERR_AKID_SKID_MISMATCH;\r\nif(akid->serial &&\r\nASN1_INTEGER_cmp(X509_get_serialNumber(issuer), akid->serial))\r\nreturn X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;\r\nif(akid->issuer)\r\n{\r\nGENERAL_NAMES *gens;\r\nGENERAL_NAME *gen;\r\nX509_NAME *nm = NULL;\r\nint i;\r\ngens = akid->issuer;\r\nfor(i = 0; i < sk_GENERAL_NAME_num(gens); i++)\r\n{\r\ngen = sk_GENERAL_NAME_value(gens, i);\r\nif(gen->type == GEN_DIRNAME)\r\n{\r\nnm = gen->d.dirn;\r\nbreak;\r\n}\r\n}\r\nif(nm && X509_NAME_cmp(nm, X509_get_issuer_name(issuer)))\r\nreturn X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;\r\n}\r\nreturn X509_V_OK;\r\n}
