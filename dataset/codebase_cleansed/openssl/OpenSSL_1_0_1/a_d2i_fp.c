void *ASN1_d2i_fp(void *(*xnew)(void), d2i_of_void *d2i, FILE *in, void **x)\r\n{\r\nBIO *b;\r\nvoid *ret;\r\nif ((b=BIO_new(BIO_s_file())) == NULL)\r\n{\r\nASN1err(ASN1_F_ASN1_D2I_FP,ERR_R_BUF_LIB);\r\nreturn(NULL);\r\n}\r\nBIO_set_fp(b,in,BIO_NOCLOSE);\r\nret=ASN1_d2i_bio(xnew,d2i,b,x);\r\nBIO_free(b);\r\nreturn(ret);\r\n}\r\nvoid *ASN1_d2i_bio(void *(*xnew)(void), d2i_of_void *d2i, BIO *in, void **x)\r\n{\r\nBUF_MEM *b = NULL;\r\nconst unsigned char *p;\r\nvoid *ret=NULL;\r\nint len;\r\nlen = asn1_d2i_read_bio(in, &b);\r\nif(len < 0) goto err;\r\np=(unsigned char *)b->data;\r\nret=d2i(x,&p,len);\r\nerr:\r\nif (b != NULL) BUF_MEM_free(b);\r\nreturn(ret);\r\n}\r\nvoid *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x)\r\n{\r\nBUF_MEM *b = NULL;\r\nconst unsigned char *p;\r\nvoid *ret=NULL;\r\nint len;\r\nlen = asn1_d2i_read_bio(in, &b);\r\nif(len < 0) goto err;\r\np=(const unsigned char *)b->data;\r\nret=ASN1_item_d2i(x,&p,len, it);\r\nerr:\r\nif (b != NULL) BUF_MEM_free(b);\r\nreturn(ret);\r\n}\r\nvoid *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x)\r\n{\r\nBIO *b;\r\nchar *ret;\r\nif ((b=BIO_new(BIO_s_file())) == NULL)\r\n{\r\nASN1err(ASN1_F_ASN1_ITEM_D2I_FP,ERR_R_BUF_LIB);\r\nreturn(NULL);\r\n}\r\nBIO_set_fp(b,in,BIO_NOCLOSE);\r\nret=ASN1_item_d2i_bio(it,b,x);\r\nBIO_free(b);\r\nreturn(ret);\r\n}\r\nstatic int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)\r\n{\r\nBUF_MEM *b;\r\nunsigned char *p;\r\nint i;\r\nint ret=-1;\r\nASN1_const_CTX c;\r\nint want=HEADER_SIZE;\r\nint eos=0;\r\n#if defined(__GNUC__) && defined(__ia64)\r\nlong off=0;\r\n#else\r\nint off=0;\r\n#endif\r\nint len=0;\r\nb=BUF_MEM_new();\r\nif (b == NULL)\r\n{\r\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);\r\nreturn -1;\r\n}\r\nERR_clear_error();\r\nfor (;;)\r\n{\r\nif (want >= (len-off))\r\n{\r\nwant-=(len-off);\r\nif (!BUF_MEM_grow_clean(b,len+want))\r\n{\r\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\ni=BIO_read(in,&(b->data[len]),want);\r\nif ((i < 0) && ((len-off) == 0))\r\n{\r\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,ASN1_R_NOT_ENOUGH_DATA);\r\ngoto err;\r\n}\r\nif (i > 0)\r\nlen+=i;\r\n}\r\np=(unsigned char *)&(b->data[off]);\r\nc.p=p;\r\nc.inf=ASN1_get_object(&(c.p),&(c.slen),&(c.tag),&(c.xclass),\r\nlen-off);\r\nif (c.inf & 0x80)\r\n{\r\nunsigned long e;\r\ne=ERR_GET_REASON(ERR_peek_error());\r\nif (e != ASN1_R_TOO_LONG)\r\ngoto err;\r\nelse\r\nERR_clear_error();\r\n}\r\ni=c.p-p;\r\noff+=i;\r\nif (c.inf & 1)\r\n{\r\neos++;\r\nwant=HEADER_SIZE;\r\n}\r\nelse if (eos && (c.slen == 0) && (c.tag == V_ASN1_EOC))\r\n{\r\neos--;\r\nif (eos <= 0)\r\nbreak;\r\nelse\r\nwant=HEADER_SIZE;\r\n}\r\nelse\r\n{\r\nwant=(int)c.slen;\r\nif (want > (len-off))\r\n{\r\nwant-=(len-off);\r\nif (!BUF_MEM_grow_clean(b,len+want))\r\n{\r\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\nwhile (want > 0)\r\n{\r\ni=BIO_read(in,&(b->data[len]),want);\r\nif (i <= 0)\r\n{\r\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,\r\nASN1_R_NOT_ENOUGH_DATA);\r\ngoto err;\r\n}\r\nlen+=i;\r\nwant -= i;\r\n}\r\n}\r\noff+=(int)c.slen;\r\nif (eos <= 0)\r\n{\r\nbreak;\r\n}\r\nelse\r\nwant=HEADER_SIZE;\r\n}\r\n}\r\n*pb = b;\r\nreturn off;\r\nerr:\r\nif (b != NULL) BUF_MEM_free(b);\r\nreturn(ret);\r\n}
