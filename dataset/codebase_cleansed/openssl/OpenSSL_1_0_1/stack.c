_STACK *sk_new(int (*c)(const void *, const void *))\r\n{\r\n_STACK *ret;\r\nint i;\r\nif ((ret=OPENSSL_malloc(sizeof(_STACK))) == NULL)\r\ngoto err;\r\nif ((ret->data=OPENSSL_malloc(sizeof(char *)*MIN_NODES)) == NULL)\r\ngoto err;\r\nfor (i=0; i<MIN_NODES; i++)\r\nret->data[i]=NULL;\r\nret->comp=c;\r\nret->num_alloc=MIN_NODES;\r\nret->num=0;\r\nret->sorted=0;\r\nreturn(ret);\r\nerr:\r\nif(ret)\r\nOPENSSL_free(ret);\r\nreturn(NULL);\r\n}\r\nint sk_insert(_STACK *st, void *data, int loc)\r\n{\r\nchar **s;\r\nif(st == NULL) return 0;\r\nif (st->num_alloc <= st->num+1)\r\n{\r\ns=OPENSSL_realloc((char *)st->data,\r\n(unsigned int)sizeof(char *)*st->num_alloc*2);\r\nif (s == NULL)\r\nreturn(0);\r\nst->data=s;\r\nst->num_alloc*=2;\r\n}\r\nif ((loc >= (int)st->num) || (loc < 0))\r\nst->data[st->num]=data;\r\nelse\r\n{\r\nint i;\r\nchar **f,**t;\r\nf=st->data;\r\nt=&(st->data[1]);\r\nfor (i=st->num; i>=loc; i--)\r\nt[i]=f[i];\r\n#ifdef undef\r\nmemmove(&(st->data[loc+1]),\r\n&(st->data[loc]),\r\nsizeof(char *)*(st->num-loc));\r\n#endif\r\nst->data[loc]=data;\r\n}\r\nst->num++;\r\nst->sorted=0;\r\nreturn(st->num);\r\n}\r\nvoid *sk_delete_ptr(_STACK *st, void *p)\r\n{\r\nint i;\r\nfor (i=0; i<st->num; i++)\r\nif (st->data[i] == p)\r\nreturn(sk_delete(st,i));\r\nreturn(NULL);\r\n}\r\nvoid *sk_delete(_STACK *st, int loc)\r\n{\r\nchar *ret;\r\nint i,j;\r\nif(!st || (loc < 0) || (loc >= st->num)) return NULL;\r\nret=st->data[loc];\r\nif (loc != st->num-1)\r\n{\r\nj=st->num-1;\r\nfor (i=loc; i<j; i++)\r\nst->data[i]=st->data[i+1];\r\n}\r\nst->num--;\r\nreturn(ret);\r\n}\r\nstatic int internal_find(_STACK *st, void *data, int ret_val_options)\r\n{\r\nconst void * const *r;\r\nint i;\r\nif(st == NULL) return -1;\r\nif (st->comp == NULL)\r\n{\r\nfor (i=0; i<st->num; i++)\r\nif (st->data[i] == data)\r\nreturn(i);\r\nreturn(-1);\r\n}\r\nsk_sort(st);\r\nif (data == NULL) return(-1);\r\nr=OBJ_bsearch_ex_(&data,st->data,st->num,sizeof(void *),st->comp,\r\nret_val_options);\r\nif (r == NULL) return(-1);\r\nreturn (int)((char **)r-st->data);\r\n}\r\nint sk_find(_STACK *st, void *data)\r\n{\r\nreturn internal_find(st, data, OBJ_BSEARCH_FIRST_VALUE_ON_MATCH);\r\n}\r\nint sk_find_ex(_STACK *st, void *data)\r\n{\r\nreturn internal_find(st, data, OBJ_BSEARCH_VALUE_ON_NOMATCH);\r\n}\r\nint sk_push(_STACK *st, void *data)\r\n{\r\nreturn(sk_insert(st,data,st->num));\r\n}\r\nint sk_unshift(_STACK *st, void *data)\r\n{\r\nreturn(sk_insert(st,data,0));\r\n}\r\nvoid *sk_shift(_STACK *st)\r\n{\r\nif (st == NULL) return(NULL);\r\nif (st->num <= 0) return(NULL);\r\nreturn(sk_delete(st,0));\r\n}\r\nvoid *sk_pop(_STACK *st)\r\n{\r\nif (st == NULL) return(NULL);\r\nif (st->num <= 0) return(NULL);\r\nreturn(sk_delete(st,st->num-1));\r\n}\r\nvoid sk_zero(_STACK *st)\r\n{\r\nif (st == NULL) return;\r\nif (st->num <= 0) return;\r\nmemset((char *)st->data,0,sizeof(st->data)*st->num);\r\nst->num=0;\r\n}\r\nvoid sk_pop_free(_STACK *st, void (*func)(void *))\r\n{\r\nint i;\r\nif (st == NULL) return;\r\nfor (i=0; i<st->num; i++)\r\nif (st->data[i] != NULL)\r\nfunc(st->data[i]);\r\nsk_free(st);\r\n}\r\nvoid sk_free(_STACK *st)\r\n{\r\nif (st == NULL) return;\r\nif (st->data != NULL) OPENSSL_free(st->data);\r\nOPENSSL_free(st);\r\n}\r\nint sk_num(const _STACK *st)\r\n{\r\nif(st == NULL) return -1;\r\nreturn st->num;\r\n}\r\nvoid *sk_value(const _STACK *st, int i)\r\n{\r\nif(!st || (i < 0) || (i >= st->num)) return NULL;\r\nreturn st->data[i];\r\n}\r\nvoid *sk_set(_STACK *st, int i, void *value)\r\n{\r\nif(!st || (i < 0) || (i >= st->num)) return NULL;\r\nreturn (st->data[i] = value);\r\n}\r\nvoid sk_sort(_STACK *st)\r\n{\r\nif (st && !st->sorted)\r\n{\r\nint (*comp_func)(const void *,const void *);\r\ncomp_func=(int (*)(const void *,const void *))(st->comp);\r\nqsort(st->data,st->num,sizeof(char *), comp_func);\r\nst->sorted=1;\r\n}\r\n}\r\nint sk_is_sorted(const _STACK *st)\r\n{\r\nif (!st)\r\nreturn 1;\r\nreturn st->sorted;\r\n}
