long ssl2_default_timeout(void)\r\n{\r\nreturn(300);\r\n}\r\nint ssl2_num_ciphers(void)\r\n{\r\nreturn(SSL2_NUM_CIPHERS);\r\n}\r\nconst SSL_CIPHER *ssl2_get_cipher(unsigned int u)\r\n{\r\nif (u < SSL2_NUM_CIPHERS)\r\nreturn(&(ssl2_ciphers[SSL2_NUM_CIPHERS-1-u]));\r\nelse\r\nreturn(NULL);\r\n}\r\nint ssl2_pending(const SSL *s)\r\n{\r\nreturn SSL_in_init(s) ? 0 : s->s2->ract_data_length;\r\n}\r\nint ssl2_new(SSL *s)\r\n{\r\nSSL2_STATE *s2;\r\nif ((s2=OPENSSL_malloc(sizeof *s2)) == NULL) goto err;\r\nmemset(s2,0,sizeof *s2);\r\n#if SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER + 3 > SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER + 2\r\n# error "assertion failed"\r\n#endif\r\nif ((s2->rbuf=OPENSSL_malloc(\r\nSSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2)) == NULL) goto err;\r\nif ((s2->wbuf=OPENSSL_malloc(\r\nSSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+3)) == NULL) goto err;\r\ns->s2=s2;\r\nssl2_clear(s);\r\nreturn(1);\r\nerr:\r\nif (s2 != NULL)\r\n{\r\nif (s2->wbuf != NULL) OPENSSL_free(s2->wbuf);\r\nif (s2->rbuf != NULL) OPENSSL_free(s2->rbuf);\r\nOPENSSL_free(s2);\r\n}\r\nreturn(0);\r\n}\r\nvoid ssl2_free(SSL *s)\r\n{\r\nSSL2_STATE *s2;\r\nif(s == NULL)\r\nreturn;\r\ns2=s->s2;\r\nif (s2->rbuf != NULL) OPENSSL_free(s2->rbuf);\r\nif (s2->wbuf != NULL) OPENSSL_free(s2->wbuf);\r\nOPENSSL_cleanse(s2,sizeof *s2);\r\nOPENSSL_free(s2);\r\ns->s2=NULL;\r\n}\r\nvoid ssl2_clear(SSL *s)\r\n{\r\nSSL2_STATE *s2;\r\nunsigned char *rbuf,*wbuf;\r\ns2=s->s2;\r\nrbuf=s2->rbuf;\r\nwbuf=s2->wbuf;\r\nmemset(s2,0,sizeof *s2);\r\ns2->rbuf=rbuf;\r\ns2->wbuf=wbuf;\r\ns2->clear_text=1;\r\ns->packet=s2->rbuf;\r\ns->version=SSL2_VERSION;\r\ns->packet_length=0;\r\n}\r\nlong ssl2_ctrl(SSL *s, int cmd, long larg, void *parg)\r\n{\r\nint ret=0;\r\nswitch(cmd)\r\n{\r\ncase SSL_CTRL_GET_SESSION_REUSED:\r\nret=s->hit;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nlong ssl2_callback_ctrl(SSL *s, int cmd, void (*fp)(void))\r\n{\r\nreturn(0);\r\n}\r\nlong ssl2_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)\r\n{\r\nreturn(0);\r\n}\r\nlong ssl2_ctx_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))\r\n{\r\nreturn(0);\r\n}\r\nconst SSL_CIPHER *ssl2_get_cipher_by_char(const unsigned char *p)\r\n{\r\nSSL_CIPHER c;\r\nconst SSL_CIPHER *cp;\r\nunsigned long id;\r\nid=0x02000000L|((unsigned long)p[0]<<16L)|\r\n((unsigned long)p[1]<<8L)|(unsigned long)p[2];\r\nc.id=id;\r\ncp = OBJ_bsearch_ssl_cipher_id(&c, ssl2_ciphers, SSL2_NUM_CIPHERS);\r\nif ((cp == NULL) || (cp->valid == 0))\r\nreturn NULL;\r\nelse\r\nreturn cp;\r\n}\r\nint ssl2_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\r\n{\r\nlong l;\r\nif (p != NULL)\r\n{\r\nl=c->id;\r\nif ((l & 0xff000000) != 0x02000000) return(0);\r\np[0]=((unsigned char)(l>>16L))&0xFF;\r\np[1]=((unsigned char)(l>> 8L))&0xFF;\r\np[2]=((unsigned char)(l ))&0xFF;\r\n}\r\nreturn(3);\r\n}\r\nint ssl2_generate_key_material(SSL *s)\r\n{\r\nunsigned int i;\r\nEVP_MD_CTX ctx;\r\nunsigned char *km;\r\nunsigned char c='0';\r\nconst EVP_MD *md5;\r\nint md_size;\r\nmd5 = EVP_md5();\r\n#ifdef CHARSET_EBCDIC\r\nc = os_toascii['0'];\r\n#endif\r\nEVP_MD_CTX_init(&ctx);\r\nkm=s->s2->key_material;\r\nif (s->session->master_key_length < 0 ||\r\ns->session->master_key_length > (int)sizeof(s->session->master_key))\r\n{\r\nSSLerr(SSL_F_SSL2_GENERATE_KEY_MATERIAL, ERR_R_INTERNAL_ERROR);\r\nreturn 0;\r\n}\r\nmd_size = EVP_MD_size(md5);\r\nif (md_size < 0)\r\nreturn 0;\r\nfor (i=0; i<s->s2->key_material_length; i += md_size)\r\n{\r\nif (((km - s->s2->key_material) + md_size) >\r\n(int)sizeof(s->s2->key_material))\r\n{\r\nSSLerr(SSL_F_SSL2_GENERATE_KEY_MATERIAL, ERR_R_INTERNAL_ERROR);\r\nreturn 0;\r\n}\r\nEVP_DigestInit_ex(&ctx, md5, NULL);\r\nOPENSSL_assert(s->session->master_key_length >= 0\r\n&& s->session->master_key_length\r\n< (int)sizeof(s->session->master_key));\r\nEVP_DigestUpdate(&ctx,s->session->master_key,s->session->master_key_length);\r\nEVP_DigestUpdate(&ctx,&c,1);\r\nc++;\r\nEVP_DigestUpdate(&ctx,s->s2->challenge,s->s2->challenge_length);\r\nEVP_DigestUpdate(&ctx,s->s2->conn_id,s->s2->conn_id_length);\r\nEVP_DigestFinal_ex(&ctx,km,NULL);\r\nkm += md_size;\r\n}\r\nEVP_MD_CTX_cleanup(&ctx);\r\nreturn 1;\r\n}\r\nvoid ssl2_return_error(SSL *s, int err)\r\n{\r\nif (!s->error)\r\n{\r\ns->error=3;\r\ns->error_code=err;\r\nssl2_write_error(s);\r\n}\r\n}\r\nvoid ssl2_write_error(SSL *s)\r\n{\r\nunsigned char buf[3];\r\nint i,error;\r\nbuf[0]=SSL2_MT_ERROR;\r\nbuf[1]=(s->error_code>>8)&0xff;\r\nbuf[2]=(s->error_code)&0xff;\r\nerror=s->error;\r\ns->error=0;\r\nOPENSSL_assert(error >= 0 && error <= (int)sizeof(buf));\r\ni=ssl2_write(s,&(buf[3-error]),error);\r\nif (i < 0)\r\ns->error=error;\r\nelse\r\n{\r\ns->error=error-i;\r\nif (s->error == 0)\r\nif (s->msg_callback)\r\ns->msg_callback(1, s->version, 0, buf, 3, s, s->msg_callback_arg);\r\n}\r\n}\r\nint ssl2_shutdown(SSL *s)\r\n{\r\ns->shutdown=(SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\r\nreturn(1);\r\n}
