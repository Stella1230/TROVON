static void\r\n_dopr(\r\nchar **sbuffer,\r\nchar **buffer,\r\nsize_t *maxlen,\r\nsize_t *retlen,\r\nint *truncated,\r\nconst char *format,\r\nva_list args)\r\n{\r\nchar ch;\r\nLLONG value;\r\nLDOUBLE fvalue;\r\nchar *strvalue;\r\nint min;\r\nint max;\r\nint state;\r\nint flags;\r\nint cflags;\r\nsize_t currlen;\r\nstate = DP_S_DEFAULT;\r\nflags = currlen = cflags = min = 0;\r\nmax = -1;\r\nch = *format++;\r\nwhile (state != DP_S_DONE) {\r\nif (ch == '\0' || (buffer == NULL && currlen >= *maxlen))\r\nstate = DP_S_DONE;\r\nswitch (state) {\r\ncase DP_S_DEFAULT:\r\nif (ch == '%')\r\nstate = DP_S_FLAGS;\r\nelse\r\ndoapr_outch(sbuffer,buffer, &currlen, maxlen, ch);\r\nch = *format++;\r\nbreak;\r\ncase DP_S_FLAGS:\r\nswitch (ch) {\r\ncase '-':\r\nflags |= DP_F_MINUS;\r\nch = *format++;\r\nbreak;\r\ncase '+':\r\nflags |= DP_F_PLUS;\r\nch = *format++;\r\nbreak;\r\ncase ' ':\r\nflags |= DP_F_SPACE;\r\nch = *format++;\r\nbreak;\r\ncase '#':\r\nflags |= DP_F_NUM;\r\nch = *format++;\r\nbreak;\r\ncase '0':\r\nflags |= DP_F_ZERO;\r\nch = *format++;\r\nbreak;\r\ndefault:\r\nstate = DP_S_MIN;\r\nbreak;\r\n}\r\nbreak;\r\ncase DP_S_MIN:\r\nif (isdigit((unsigned char)ch)) {\r\nmin = 10 * min + char_to_int(ch);\r\nch = *format++;\r\n} else if (ch == '*') {\r\nmin = va_arg(args, int);\r\nch = *format++;\r\nstate = DP_S_DOT;\r\n} else\r\nstate = DP_S_DOT;\r\nbreak;\r\ncase DP_S_DOT:\r\nif (ch == '.') {\r\nstate = DP_S_MAX;\r\nch = *format++;\r\n} else\r\nstate = DP_S_MOD;\r\nbreak;\r\ncase DP_S_MAX:\r\nif (isdigit((unsigned char)ch)) {\r\nif (max < 0)\r\nmax = 0;\r\nmax = 10 * max + char_to_int(ch);\r\nch = *format++;\r\n} else if (ch == '*') {\r\nmax = va_arg(args, int);\r\nch = *format++;\r\nstate = DP_S_MOD;\r\n} else\r\nstate = DP_S_MOD;\r\nbreak;\r\ncase DP_S_MOD:\r\nswitch (ch) {\r\ncase 'h':\r\ncflags = DP_C_SHORT;\r\nch = *format++;\r\nbreak;\r\ncase 'l':\r\nif (*format == 'l') {\r\ncflags = DP_C_LLONG;\r\nformat++;\r\n} else\r\ncflags = DP_C_LONG;\r\nch = *format++;\r\nbreak;\r\ncase 'q':\r\ncflags = DP_C_LLONG;\r\nch = *format++;\r\nbreak;\r\ncase 'L':\r\ncflags = DP_C_LDOUBLE;\r\nch = *format++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstate = DP_S_CONV;\r\nbreak;\r\ncase DP_S_CONV:\r\nswitch (ch) {\r\ncase 'd':\r\ncase 'i':\r\nswitch (cflags) {\r\ncase DP_C_SHORT:\r\nvalue = (short int)va_arg(args, int);\r\nbreak;\r\ncase DP_C_LONG:\r\nvalue = va_arg(args, long int);\r\nbreak;\r\ncase DP_C_LLONG:\r\nvalue = va_arg(args, LLONG);\r\nbreak;\r\ndefault:\r\nvalue = va_arg(args, int);\r\nbreak;\r\n}\r\nfmtint(sbuffer, buffer, &currlen, maxlen,\r\nvalue, 10, min, max, flags);\r\nbreak;\r\ncase 'X':\r\nflags |= DP_F_UP;\r\ncase 'x':\r\ncase 'o':\r\ncase 'u':\r\nflags |= DP_F_UNSIGNED;\r\nswitch (cflags) {\r\ncase DP_C_SHORT:\r\nvalue = (unsigned short int)va_arg(args, unsigned int);\r\nbreak;\r\ncase DP_C_LONG:\r\nvalue = (LLONG) va_arg(args,\r\nunsigned long int);\r\nbreak;\r\ncase DP_C_LLONG:\r\nvalue = va_arg(args, unsigned LLONG);\r\nbreak;\r\ndefault:\r\nvalue = (LLONG) va_arg(args,\r\nunsigned int);\r\nbreak;\r\n}\r\nfmtint(sbuffer, buffer, &currlen, maxlen, value,\r\nch == 'o' ? 8 : (ch == 'u' ? 10 : 16),\r\nmin, max, flags);\r\nbreak;\r\ncase 'f':\r\nif (cflags == DP_C_LDOUBLE)\r\nfvalue = va_arg(args, LDOUBLE);\r\nelse\r\nfvalue = va_arg(args, double);\r\nfmtfp(sbuffer, buffer, &currlen, maxlen,\r\nfvalue, min, max, flags);\r\nbreak;\r\ncase 'E':\r\nflags |= DP_F_UP;\r\ncase 'e':\r\nif (cflags == DP_C_LDOUBLE)\r\nfvalue = va_arg(args, LDOUBLE);\r\nelse\r\nfvalue = va_arg(args, double);\r\nbreak;\r\ncase 'G':\r\nflags |= DP_F_UP;\r\ncase 'g':\r\nif (cflags == DP_C_LDOUBLE)\r\nfvalue = va_arg(args, LDOUBLE);\r\nelse\r\nfvalue = va_arg(args, double);\r\nbreak;\r\ncase 'c':\r\ndoapr_outch(sbuffer, buffer, &currlen, maxlen,\r\nva_arg(args, int));\r\nbreak;\r\ncase 's':\r\nstrvalue = va_arg(args, char *);\r\nif (max < 0) {\r\nif (buffer)\r\nmax = INT_MAX;\r\nelse\r\nmax = *maxlen;\r\n}\r\nfmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\r\nflags, min, max);\r\nbreak;\r\ncase 'p':\r\nvalue = (long)va_arg(args, void *);\r\nfmtint(sbuffer, buffer, &currlen, maxlen,\r\nvalue, 16, min, max, flags|DP_F_NUM);\r\nbreak;\r\ncase 'n':\r\nif (cflags == DP_C_SHORT) {\r\nshort int *num;\r\nnum = va_arg(args, short int *);\r\n*num = currlen;\r\n} else if (cflags == DP_C_LONG) {\r\nlong int *num;\r\nnum = va_arg(args, long int *);\r\n*num = (long int) currlen;\r\n} else if (cflags == DP_C_LLONG) {\r\nLLONG *num;\r\nnum = va_arg(args, LLONG *);\r\n*num = (LLONG) currlen;\r\n} else {\r\nint *num;\r\nnum = va_arg(args, int *);\r\n*num = currlen;\r\n}\r\nbreak;\r\ncase '%':\r\ndoapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\r\nbreak;\r\ncase 'w':\r\nch = *format++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nch = *format++;\r\nstate = DP_S_DEFAULT;\r\nflags = cflags = min = 0;\r\nmax = -1;\r\nbreak;\r\ncase DP_S_DONE:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n*truncated = (currlen > *maxlen - 1);\r\nif (*truncated)\r\ncurrlen = *maxlen - 1;\r\ndoapr_outch(sbuffer, buffer, &currlen, maxlen, '\0');\r\n*retlen = currlen - 1;\r\nreturn;\r\n}\r\nstatic void\r\nfmtstr(\r\nchar **sbuffer,\r\nchar **buffer,\r\nsize_t *currlen,\r\nsize_t *maxlen,\r\nconst char *value,\r\nint flags,\r\nint min,\r\nint max)\r\n{\r\nint padlen, strln;\r\nint cnt = 0;\r\nif (value == 0)\r\nvalue = "<NULL>";\r\nfor (strln = 0; value[strln]; ++strln)\r\n;\r\npadlen = min - strln;\r\nif (padlen < 0)\r\npadlen = 0;\r\nif (flags & DP_F_MINUS)\r\npadlen = -padlen;\r\nwhile ((padlen > 0) && (cnt < max)) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\r\n--padlen;\r\n++cnt;\r\n}\r\nwhile (*value && (cnt < max)) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, *value++);\r\n++cnt;\r\n}\r\nwhile ((padlen < 0) && (cnt < max)) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\r\n++padlen;\r\n++cnt;\r\n}\r\n}\r\nstatic void\r\nfmtint(\r\nchar **sbuffer,\r\nchar **buffer,\r\nsize_t *currlen,\r\nsize_t *maxlen,\r\nLLONG value,\r\nint base,\r\nint min,\r\nint max,\r\nint flags)\r\n{\r\nint signvalue = 0;\r\nconst char *prefix = "";\r\nunsigned LLONG uvalue;\r\nchar convert[DECIMAL_SIZE(value)+3];\r\nint place = 0;\r\nint spadlen = 0;\r\nint zpadlen = 0;\r\nint caps = 0;\r\nif (max < 0)\r\nmax = 0;\r\nuvalue = value;\r\nif (!(flags & DP_F_UNSIGNED)) {\r\nif (value < 0) {\r\nsignvalue = '-';\r\nuvalue = -value;\r\n} else if (flags & DP_F_PLUS)\r\nsignvalue = '+';\r\nelse if (flags & DP_F_SPACE)\r\nsignvalue = ' ';\r\n}\r\nif (flags & DP_F_NUM) {\r\nif (base == 8) prefix = "0";\r\nif (base == 16) prefix = "0x";\r\n}\r\nif (flags & DP_F_UP)\r\ncaps = 1;\r\ndo {\r\nconvert[place++] =\r\n(caps ? "0123456789ABCDEF" : "0123456789abcdef")\r\n[uvalue % (unsigned) base];\r\nuvalue = (uvalue / (unsigned) base);\r\n} while (uvalue && (place < (int)sizeof(convert)));\r\nif (place == sizeof(convert))\r\nplace--;\r\nconvert[place] = 0;\r\nzpadlen = max - place;\r\nspadlen = min - OSSL_MAX(max, place) - (signvalue ? 1 : 0) - strlen(prefix);\r\nif (zpadlen < 0)\r\nzpadlen = 0;\r\nif (spadlen < 0)\r\nspadlen = 0;\r\nif (flags & DP_F_ZERO) {\r\nzpadlen = OSSL_MAX(zpadlen, spadlen);\r\nspadlen = 0;\r\n}\r\nif (flags & DP_F_MINUS)\r\nspadlen = -spadlen;\r\nwhile (spadlen > 0) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\r\n--spadlen;\r\n}\r\nif (signvalue)\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);\r\nwhile (*prefix) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, *prefix);\r\nprefix++;\r\n}\r\nif (zpadlen > 0) {\r\nwhile (zpadlen > 0) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '0');\r\n--zpadlen;\r\n}\r\n}\r\nwhile (place > 0)\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, convert[--place]);\r\nwhile (spadlen < 0) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\r\n++spadlen;\r\n}\r\nreturn;\r\n}\r\nstatic LDOUBLE\r\nabs_val(LDOUBLE value)\r\n{\r\nLDOUBLE result = value;\r\nif (value < 0)\r\nresult = -value;\r\nreturn result;\r\n}\r\nstatic LDOUBLE\r\npow_10(int in_exp)\r\n{\r\nLDOUBLE result = 1;\r\nwhile (in_exp) {\r\nresult *= 10;\r\nin_exp--;\r\n}\r\nreturn result;\r\n}\r\nstatic long\r\nroundv(LDOUBLE value)\r\n{\r\nlong intpart;\r\nintpart = (long) value;\r\nvalue = value - intpart;\r\nif (value >= 0.5)\r\nintpart++;\r\nreturn intpart;\r\n}\r\nstatic void\r\nfmtfp(\r\nchar **sbuffer,\r\nchar **buffer,\r\nsize_t *currlen,\r\nsize_t *maxlen,\r\nLDOUBLE fvalue,\r\nint min,\r\nint max,\r\nint flags)\r\n{\r\nint signvalue = 0;\r\nLDOUBLE ufvalue;\r\nchar iconvert[20];\r\nchar fconvert[20];\r\nint iplace = 0;\r\nint fplace = 0;\r\nint padlen = 0;\r\nint zpadlen = 0;\r\nint caps = 0;\r\nlong intpart;\r\nlong fracpart;\r\nlong max10;\r\nif (max < 0)\r\nmax = 6;\r\nufvalue = abs_val(fvalue);\r\nif (fvalue < 0)\r\nsignvalue = '-';\r\nelse if (flags & DP_F_PLUS)\r\nsignvalue = '+';\r\nelse if (flags & DP_F_SPACE)\r\nsignvalue = ' ';\r\nintpart = (long)ufvalue;\r\nif (max > 9)\r\nmax = 9;\r\nmax10 = roundv(pow_10(max));\r\nfracpart = roundv(pow_10(max) * (ufvalue - intpart));\r\nif (fracpart >= max10) {\r\nintpart++;\r\nfracpart -= max10;\r\n}\r\ndo {\r\niconvert[iplace++] =\r\n(caps ? "0123456789ABCDEF"\r\n: "0123456789abcdef")[intpart % 10];\r\nintpart = (intpart / 10);\r\n} while (intpart && (iplace < (int)sizeof(iconvert)));\r\nif (iplace == sizeof iconvert)\r\niplace--;\r\niconvert[iplace] = 0;\r\ndo {\r\nfconvert[fplace++] =\r\n(caps ? "0123456789ABCDEF"\r\n: "0123456789abcdef")[fracpart % 10];\r\nfracpart = (fracpart / 10);\r\n} while (fplace < max);\r\nif (fplace == sizeof fconvert)\r\nfplace--;\r\nfconvert[fplace] = 0;\r\npadlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);\r\nzpadlen = max - fplace;\r\nif (zpadlen < 0)\r\nzpadlen = 0;\r\nif (padlen < 0)\r\npadlen = 0;\r\nif (flags & DP_F_MINUS)\r\npadlen = -padlen;\r\nif ((flags & DP_F_ZERO) && (padlen > 0)) {\r\nif (signvalue) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);\r\n--padlen;\r\nsignvalue = 0;\r\n}\r\nwhile (padlen > 0) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '0');\r\n--padlen;\r\n}\r\n}\r\nwhile (padlen > 0) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\r\n--padlen;\r\n}\r\nif (signvalue)\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);\r\nwhile (iplace > 0)\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, iconvert[--iplace]);\r\nif (max > 0 || (flags & DP_F_NUM)) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '.');\r\nwhile (fplace > 0)\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, fconvert[--fplace]);\r\n}\r\nwhile (zpadlen > 0) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '0');\r\n--zpadlen;\r\n}\r\nwhile (padlen < 0) {\r\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\r\n++padlen;\r\n}\r\n}\r\nstatic void\r\ndoapr_outch(\r\nchar **sbuffer,\r\nchar **buffer,\r\nsize_t *currlen,\r\nsize_t *maxlen,\r\nint c)\r\n{\r\nassert(*sbuffer != NULL || buffer != NULL);\r\nif (buffer) {\r\nwhile (*currlen >= *maxlen) {\r\nif (*buffer == NULL) {\r\nif (*maxlen == 0)\r\n*maxlen = 1024;\r\n*buffer = OPENSSL_malloc(*maxlen);\r\nif (*currlen > 0) {\r\nassert(*sbuffer != NULL);\r\nmemcpy(*buffer, *sbuffer, *currlen);\r\n}\r\n*sbuffer = NULL;\r\n} else {\r\n*maxlen += 1024;\r\n*buffer = OPENSSL_realloc(*buffer, *maxlen);\r\n}\r\n}\r\nassert(*sbuffer != NULL || *buffer != NULL);\r\n}\r\nif (*currlen < *maxlen) {\r\nif (*sbuffer)\r\n(*sbuffer)[(*currlen)++] = (char)c;\r\nelse\r\n(*buffer)[(*currlen)++] = (char)c;\r\n}\r\nreturn;\r\n}\r\nint BIO_printf (BIO *bio, const char *format, ...)\r\n{\r\nva_list args;\r\nint ret;\r\nva_start(args, format);\r\nret = BIO_vprintf(bio, format, args);\r\nva_end(args);\r\nreturn(ret);\r\n}\r\nint BIO_vprintf (BIO *bio, const char *format, va_list args)\r\n{\r\nint ret;\r\nsize_t retlen;\r\nchar hugebuf[1024*2];\r\nchar *hugebufp = hugebuf;\r\nsize_t hugebufsize = sizeof(hugebuf);\r\nchar *dynbuf = NULL;\r\nint ignored;\r\ndynbuf = NULL;\r\nCRYPTO_push_info("doapr()");\r\n_dopr(&hugebufp, &dynbuf, &hugebufsize,\r\n&retlen, &ignored, format, args);\r\nif (dynbuf)\r\n{\r\nret=BIO_write(bio, dynbuf, (int)retlen);\r\nOPENSSL_free(dynbuf);\r\n}\r\nelse\r\n{\r\nret=BIO_write(bio, hugebuf, (int)retlen);\r\n}\r\nCRYPTO_pop_info();\r\nreturn(ret);\r\n}\r\nint BIO_snprintf(char *buf, size_t n, const char *format, ...)\r\n{\r\nva_list args;\r\nint ret;\r\nva_start(args, format);\r\nret = BIO_vsnprintf(buf, n, format, args);\r\nva_end(args);\r\nreturn(ret);\r\n}\r\nint BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)\r\n{\r\nsize_t retlen;\r\nint truncated;\r\n_dopr(&buf, NULL, &n, &retlen, &truncated, format, args);\r\nif (truncated)\r\nreturn -1;\r\nelse\r\nreturn (retlen <= INT_MAX) ? (int)retlen : -1;\r\n}
