static void* zlib_zalloc(void* opaque, unsigned int no, unsigned int size)\r\n{\r\nvoid *p;\r\np=OPENSSL_malloc(no*size);\r\nif (p)\r\nmemset(p, 0, no*size);\r\nreturn p;\r\n}\r\nstatic void zlib_zfree(void* opaque, void* address)\r\n{\r\nOPENSSL_free(address);\r\n}\r\nstatic int zlib_stateful_init(COMP_CTX *ctx)\r\n{\r\nint err;\r\nstruct zlib_state *state =\r\n(struct zlib_state *)OPENSSL_malloc(sizeof(struct zlib_state));\r\nif (state == NULL)\r\ngoto err;\r\nstate->istream.zalloc = zlib_zalloc;\r\nstate->istream.zfree = zlib_zfree;\r\nstate->istream.opaque = Z_NULL;\r\nstate->istream.next_in = Z_NULL;\r\nstate->istream.next_out = Z_NULL;\r\nstate->istream.avail_in = 0;\r\nstate->istream.avail_out = 0;\r\nerr = inflateInit_(&state->istream,\r\nZLIB_VERSION, sizeof(z_stream));\r\nif (err != Z_OK)\r\ngoto err;\r\nstate->ostream.zalloc = zlib_zalloc;\r\nstate->ostream.zfree = zlib_zfree;\r\nstate->ostream.opaque = Z_NULL;\r\nstate->ostream.next_in = Z_NULL;\r\nstate->ostream.next_out = Z_NULL;\r\nstate->ostream.avail_in = 0;\r\nstate->ostream.avail_out = 0;\r\nerr = deflateInit_(&state->ostream,Z_DEFAULT_COMPRESSION,\r\nZLIB_VERSION, sizeof(z_stream));\r\nif (err != Z_OK)\r\ngoto err;\r\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);\r\nCRYPTO_set_ex_data(&ctx->ex_data,zlib_stateful_ex_idx,state);\r\nreturn 1;\r\nerr:\r\nif (state) OPENSSL_free(state);\r\nreturn 0;\r\n}\r\nstatic void zlib_stateful_finish(COMP_CTX *ctx)\r\n{\r\nstruct zlib_state *state =\r\n(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\r\nzlib_stateful_ex_idx);\r\ninflateEnd(&state->istream);\r\ndeflateEnd(&state->ostream);\r\nOPENSSL_free(state);\r\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);\r\n}\r\nstatic int zlib_stateful_compress_block(COMP_CTX *ctx, unsigned char *out,\r\nunsigned int olen, unsigned char *in, unsigned int ilen)\r\n{\r\nint err = Z_OK;\r\nstruct zlib_state *state =\r\n(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\r\nzlib_stateful_ex_idx);\r\nif (state == NULL)\r\nreturn -1;\r\nstate->ostream.next_in = in;\r\nstate->ostream.avail_in = ilen;\r\nstate->ostream.next_out = out;\r\nstate->ostream.avail_out = olen;\r\nif (ilen > 0)\r\nerr = deflate(&state->ostream, Z_SYNC_FLUSH);\r\nif (err != Z_OK)\r\nreturn -1;\r\n#ifdef DEBUG_ZLIB\r\nfprintf(stderr,"compress(%4d)->%4d %s\n",\r\nilen,olen - state->ostream.avail_out,\r\n(ilen != olen - state->ostream.avail_out)?"zlib":"clear");\r\n#endif\r\nreturn olen - state->ostream.avail_out;\r\n}\r\nstatic int zlib_stateful_expand_block(COMP_CTX *ctx, unsigned char *out,\r\nunsigned int olen, unsigned char *in, unsigned int ilen)\r\n{\r\nint err = Z_OK;\r\nstruct zlib_state *state =\r\n(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\r\nzlib_stateful_ex_idx);\r\nif (state == NULL)\r\nreturn 0;\r\nstate->istream.next_in = in;\r\nstate->istream.avail_in = ilen;\r\nstate->istream.next_out = out;\r\nstate->istream.avail_out = olen;\r\nif (ilen > 0)\r\nerr = inflate(&state->istream, Z_SYNC_FLUSH);\r\nif (err != Z_OK)\r\nreturn -1;\r\n#ifdef DEBUG_ZLIB\r\nfprintf(stderr,"expand(%4d)->%4d %s\n",\r\nilen,olen - state->istream.avail_out,\r\n(ilen != olen - state->istream.avail_out)?"zlib":"clear");\r\n#endif\r\nreturn olen - state->istream.avail_out;\r\n}\r\nCOMP_METHOD *COMP_zlib(void)\r\n{\r\nCOMP_METHOD *meth = &zlib_method_nozlib;\r\n#ifdef ZLIB_SHARED\r\nif (!zlib_loaded)\r\n{\r\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)\r\nzlib_dso = DSO_load(NULL, "ZLIB1", NULL, 0);\r\n#else\r\nzlib_dso = DSO_load(NULL, "z", NULL, 0);\r\n#endif\r\nif (zlib_dso != NULL)\r\n{\r\np_compress\r\n= (compress_ft) DSO_bind_func(zlib_dso,\r\n"compress");\r\np_inflateEnd\r\n= (inflateEnd_ft) DSO_bind_func(zlib_dso,\r\n"inflateEnd");\r\np_inflate\r\n= (inflate_ft) DSO_bind_func(zlib_dso,\r\n"inflate");\r\np_inflateInit_\r\n= (inflateInit__ft) DSO_bind_func(zlib_dso,\r\n"inflateInit_");\r\np_deflateEnd\r\n= (deflateEnd_ft) DSO_bind_func(zlib_dso,\r\n"deflateEnd");\r\np_deflate\r\n= (deflate_ft) DSO_bind_func(zlib_dso,\r\n"deflate");\r\np_deflateInit_\r\n= (deflateInit__ft) DSO_bind_func(zlib_dso,\r\n"deflateInit_");\r\np_zError\r\n= (zError__ft) DSO_bind_func(zlib_dso,\r\n"zError");\r\nif (p_compress && p_inflateEnd && p_inflate\r\n&& p_inflateInit_ && p_deflateEnd\r\n&& p_deflate && p_deflateInit_ && p_zError)\r\nzlib_loaded++;\r\n}\r\n}\r\n#endif\r\n#ifdef ZLIB_SHARED\r\nif (zlib_loaded)\r\n#endif\r\n#if defined(ZLIB) || defined(ZLIB_SHARED)\r\n{\r\nif (zlib_stateful_ex_idx == -1)\r\n{\r\nCRYPTO_w_lock(CRYPTO_LOCK_COMP);\r\nif (zlib_stateful_ex_idx == -1)\r\nzlib_stateful_ex_idx =\r\nCRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_COMP,\r\n0,NULL,NULL,NULL,NULL);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_COMP);\r\nif (zlib_stateful_ex_idx == -1)\r\ngoto err;\r\n}\r\nmeth = &zlib_stateful_method;\r\n}\r\nerr:\r\n#endif\r\nreturn(meth);\r\n}\r\nvoid COMP_zlib_cleanup(void)\r\n{\r\n#ifdef ZLIB_SHARED\r\nif (zlib_dso)\r\nDSO_free(zlib_dso);\r\n#endif\r\n}\r\nBIO_METHOD *BIO_f_zlib(void)\r\n{\r\nreturn &bio_meth_zlib;\r\n}\r\nstatic int bio_zlib_new(BIO *bi)\r\n{\r\nBIO_ZLIB_CTX *ctx;\r\n#ifdef ZLIB_SHARED\r\n(void)COMP_zlib();\r\nif (!zlib_loaded)\r\n{\r\nCOMPerr(COMP_F_BIO_ZLIB_NEW, COMP_R_ZLIB_NOT_SUPPORTED);\r\nreturn 0;\r\n}\r\n#endif\r\nctx = OPENSSL_malloc(sizeof(BIO_ZLIB_CTX));\r\nif(!ctx)\r\n{\r\nCOMPerr(COMP_F_BIO_ZLIB_NEW, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nctx->ibuf = NULL;\r\nctx->obuf = NULL;\r\nctx->ibufsize = ZLIB_DEFAULT_BUFSIZE;\r\nctx->obufsize = ZLIB_DEFAULT_BUFSIZE;\r\nctx->zin.zalloc = Z_NULL;\r\nctx->zin.zfree = Z_NULL;\r\nctx->zin.next_in = NULL;\r\nctx->zin.avail_in = 0;\r\nctx->zin.next_out = NULL;\r\nctx->zin.avail_out = 0;\r\nctx->zout.zalloc = Z_NULL;\r\nctx->zout.zfree = Z_NULL;\r\nctx->zout.next_in = NULL;\r\nctx->zout.avail_in = 0;\r\nctx->zout.next_out = NULL;\r\nctx->zout.avail_out = 0;\r\nctx->odone = 0;\r\nctx->comp_level = Z_DEFAULT_COMPRESSION;\r\nbi->init = 1;\r\nbi->ptr = (char *)ctx;\r\nbi->flags = 0;\r\nreturn 1;\r\n}\r\nstatic int bio_zlib_free(BIO *bi)\r\n{\r\nBIO_ZLIB_CTX *ctx;\r\nif(!bi) return 0;\r\nctx = (BIO_ZLIB_CTX *)bi->ptr;\r\nif(ctx->ibuf)\r\n{\r\ninflateEnd(&ctx->zin);\r\nOPENSSL_free(ctx->ibuf);\r\n}\r\nif(ctx->obuf)\r\n{\r\ndeflateEnd(&ctx->zout);\r\nOPENSSL_free(ctx->obuf);\r\n}\r\nOPENSSL_free(ctx);\r\nbi->ptr = NULL;\r\nbi->init = 0;\r\nbi->flags = 0;\r\nreturn 1;\r\n}\r\nstatic int bio_zlib_read(BIO *b, char *out, int outl)\r\n{\r\nBIO_ZLIB_CTX *ctx;\r\nint ret;\r\nz_stream *zin;\r\nif(!out || !outl) return 0;\r\nctx = (BIO_ZLIB_CTX *)b->ptr;\r\nzin = &ctx->zin;\r\nBIO_clear_retry_flags(b);\r\nif(!ctx->ibuf)\r\n{\r\nctx->ibuf = OPENSSL_malloc(ctx->ibufsize);\r\nif(!ctx->ibuf)\r\n{\r\nCOMPerr(COMP_F_BIO_ZLIB_READ, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\ninflateInit(zin);\r\nzin->next_in = ctx->ibuf;\r\nzin->avail_in = 0;\r\n}\r\nzin->next_out = (unsigned char *)out;\r\nzin->avail_out = (unsigned int)outl;\r\nfor(;;)\r\n{\r\nwhile(zin->avail_in)\r\n{\r\nret = inflate(zin, 0);\r\nif((ret != Z_OK) && (ret != Z_STREAM_END))\r\n{\r\nCOMPerr(COMP_F_BIO_ZLIB_READ,\r\nCOMP_R_ZLIB_INFLATE_ERROR);\r\nERR_add_error_data(2, "zlib error:",\r\nzError(ret));\r\nreturn 0;\r\n}\r\nif((ret == Z_STREAM_END) || !zin->avail_out)\r\nreturn outl - zin->avail_out;\r\n}\r\nret = BIO_read(b->next_bio, ctx->ibuf, ctx->ibufsize);\r\nif(ret <= 0)\r\n{\r\nint tot = outl - zin->avail_out;\r\nBIO_copy_next_retry(b);\r\nif(ret < 0) return (tot > 0) ? tot : ret;\r\nreturn tot;\r\n}\r\nzin->avail_in = ret;\r\nzin->next_in = ctx->ibuf;\r\n}\r\n}\r\nstatic int bio_zlib_write(BIO *b, const char *in, int inl)\r\n{\r\nBIO_ZLIB_CTX *ctx;\r\nint ret;\r\nz_stream *zout;\r\nif(!in || !inl) return 0;\r\nctx = (BIO_ZLIB_CTX *)b->ptr;\r\nif(ctx->odone) return 0;\r\nzout = &ctx->zout;\r\nBIO_clear_retry_flags(b);\r\nif(!ctx->obuf)\r\n{\r\nctx->obuf = OPENSSL_malloc(ctx->obufsize);\r\nif(!ctx->obuf)\r\n{\r\nCOMPerr(COMP_F_BIO_ZLIB_WRITE, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nctx->optr = ctx->obuf;\r\nctx->ocount = 0;\r\ndeflateInit(zout, ctx->comp_level);\r\nzout->next_out = ctx->obuf;\r\nzout->avail_out = ctx->obufsize;\r\n}\r\nzout->next_in = (void *)in;\r\nzout->avail_in = inl;\r\nfor(;;)\r\n{\r\nwhile(ctx->ocount) {\r\nret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);\r\nif(ret <= 0)\r\n{\r\nint tot = inl - zout->avail_in;\r\nBIO_copy_next_retry(b);\r\nif(ret < 0) return (tot > 0) ? tot : ret;\r\nreturn tot;\r\n}\r\nctx->optr += ret;\r\nctx->ocount -= ret;\r\n}\r\nif(!zout->avail_in)\r\nreturn inl;\r\nctx->optr = ctx->obuf;\r\nzout->next_out = ctx->obuf;\r\nzout->avail_out = ctx->obufsize;\r\nret = deflate(zout, 0);\r\nif(ret != Z_OK)\r\n{\r\nCOMPerr(COMP_F_BIO_ZLIB_WRITE,\r\nCOMP_R_ZLIB_DEFLATE_ERROR);\r\nERR_add_error_data(2, "zlib error:", zError(ret));\r\nreturn 0;\r\n}\r\nctx->ocount = ctx->obufsize - zout->avail_out;\r\n}\r\n}\r\nstatic int bio_zlib_flush(BIO *b)\r\n{\r\nBIO_ZLIB_CTX *ctx;\r\nint ret;\r\nz_stream *zout;\r\nctx = (BIO_ZLIB_CTX *)b->ptr;\r\nif(!ctx->obuf || (ctx->odone && !ctx->ocount)) return 1;\r\nzout = &ctx->zout;\r\nBIO_clear_retry_flags(b);\r\nzout->next_in = NULL;\r\nzout->avail_in = 0;\r\nfor(;;)\r\n{\r\nwhile(ctx->ocount)\r\n{\r\nret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);\r\nif(ret <= 0)\r\n{\r\nBIO_copy_next_retry(b);\r\nreturn ret;\r\n}\r\nctx->optr += ret;\r\nctx->ocount -= ret;\r\n}\r\nif(ctx->odone) return 1;\r\nctx->optr = ctx->obuf;\r\nzout->next_out = ctx->obuf;\r\nzout->avail_out = ctx->obufsize;\r\nret = deflate(zout, Z_FINISH);\r\nif(ret == Z_STREAM_END) ctx->odone = 1;\r\nelse if(ret != Z_OK)\r\n{\r\nCOMPerr(COMP_F_BIO_ZLIB_FLUSH,\r\nCOMP_R_ZLIB_DEFLATE_ERROR);\r\nERR_add_error_data(2, "zlib error:", zError(ret));\r\nreturn 0;\r\n}\r\nctx->ocount = ctx->obufsize - zout->avail_out;\r\n}\r\n}\r\nstatic long bio_zlib_ctrl(BIO *b, int cmd, long num, void *ptr)\r\n{\r\nBIO_ZLIB_CTX *ctx;\r\nint ret, *ip;\r\nint ibs, obs;\r\nif(!b->next_bio) return 0;\r\nctx = (BIO_ZLIB_CTX *)b->ptr;\r\nswitch (cmd)\r\n{\r\ncase BIO_CTRL_RESET:\r\nctx->ocount = 0;\r\nctx->odone = 0;\r\nret = 1;\r\nbreak;\r\ncase BIO_CTRL_FLUSH:\r\nret = bio_zlib_flush(b);\r\nif (ret > 0)\r\nret = BIO_flush(b->next_bio);\r\nbreak;\r\ncase BIO_C_SET_BUFF_SIZE:\r\nibs = -1;\r\nobs = -1;\r\nif (ptr != NULL)\r\n{\r\nip = ptr;\r\nif (*ip == 0)\r\nibs = (int) num;\r\nelse\r\nobs = (int) num;\r\n}\r\nelse\r\n{\r\nibs = (int)num;\r\nobs = ibs;\r\n}\r\nif (ibs != -1)\r\n{\r\nif (ctx->ibuf)\r\n{\r\nOPENSSL_free(ctx->ibuf);\r\nctx->ibuf = NULL;\r\n}\r\nctx->ibufsize = ibs;\r\n}\r\nif (obs != -1)\r\n{\r\nif (ctx->obuf)\r\n{\r\nOPENSSL_free(ctx->obuf);\r\nctx->obuf = NULL;\r\n}\r\nctx->obufsize = obs;\r\n}\r\nret = 1;\r\nbreak;\r\ncase BIO_C_DO_STATE_MACHINE:\r\nBIO_clear_retry_flags(b);\r\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\r\nBIO_copy_next_retry(b);\r\nbreak;\r\ndefault:\r\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic long bio_zlib_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\r\n{\r\nif(!b->next_bio)\r\nreturn 0;\r\nreturn\r\nBIO_callback_ctrl(b->next_bio, cmd, fp);\r\n}
