DSO_METHOD *DSO_METHOD_win32(void)\r\n{\r\nreturn NULL;\r\n}\r\nstatic FARPROC GetProcAddressA(HMODULE hModule,LPCSTR lpProcName)\r\n{\r\nWCHAR lpProcNameW[64];\r\nint i;\r\nfor (i=0;lpProcName[i] && i<64;i++)\r\nlpProcNameW[i] = (WCHAR)lpProcName[i];\r\nif (i==64) return NULL;\r\nlpProcNameW[i] = 0;\r\nreturn GetProcAddressW(hModule,lpProcNameW);\r\n}\r\nstatic HINSTANCE LoadLibraryA(LPCSTR lpLibFileName)\r\n{\r\nWCHAR *fnamw;\r\nsize_t len_0=strlen(lpLibFileName)+1,i;\r\n#ifdef _MSC_VER\r\nfnamw = (WCHAR *)_alloca (len_0*sizeof(WCHAR));\r\n#else\r\nfnamw = (WCHAR *)alloca (len_0*sizeof(WCHAR));\r\n#endif\r\nif (fnamw == NULL)\r\n{\r\nSetLastError(ERROR_NOT_ENOUGH_MEMORY);\r\nreturn NULL;\r\n}\r\n#if defined(_WIN32_WCE) && _WIN32_WCE>=101\r\nif (!MultiByteToWideChar(CP_ACP,0,lpLibFileName,len_0,fnamw,len_0))\r\n#endif\r\nfor (i=0;i<len_0;i++) fnamw[i]=(WCHAR)lpLibFileName[i];\r\nreturn LoadLibraryW(fnamw);\r\n}\r\nDSO_METHOD *DSO_METHOD_win32(void)\r\n{\r\nreturn(&dso_meth_win32);\r\n}\r\nstatic int win32_load(DSO *dso)\r\n{\r\nHINSTANCE h = NULL, *p = NULL;\r\nchar *filename = DSO_convert_filename(dso, NULL);\r\nif(filename == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_LOAD,DSO_R_NO_FILENAME);\r\ngoto err;\r\n}\r\nh = LoadLibraryA(filename);\r\nif(h == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_LOAD,DSO_R_LOAD_FAILED);\r\nERR_add_error_data(3, "filename(", filename, ")");\r\ngoto err;\r\n}\r\np = (HINSTANCE *)OPENSSL_malloc(sizeof(HINSTANCE));\r\nif(p == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_LOAD,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\n*p = h;\r\nif(!sk_void_push(dso->meth_data, p))\r\n{\r\nDSOerr(DSO_F_WIN32_LOAD,DSO_R_STACK_ERROR);\r\ngoto err;\r\n}\r\ndso->loaded_filename = filename;\r\nreturn(1);\r\nerr:\r\nif(filename != NULL)\r\nOPENSSL_free(filename);\r\nif(p != NULL)\r\nOPENSSL_free(p);\r\nif(h != NULL)\r\nFreeLibrary(h);\r\nreturn(0);\r\n}\r\nstatic int win32_unload(DSO *dso)\r\n{\r\nHINSTANCE *p;\r\nif(dso == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_UNLOAD,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn(0);\r\n}\r\nif(sk_void_num(dso->meth_data) < 1)\r\nreturn(1);\r\np = sk_void_pop(dso->meth_data);\r\nif(p == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_UNLOAD,DSO_R_NULL_HANDLE);\r\nreturn(0);\r\n}\r\nif(!FreeLibrary(*p))\r\n{\r\nDSOerr(DSO_F_WIN32_UNLOAD,DSO_R_UNLOAD_FAILED);\r\nsk_void_push(dso->meth_data, p);\r\nreturn(0);\r\n}\r\nOPENSSL_free(p);\r\nreturn(1);\r\n}\r\nstatic void *win32_bind_var(DSO *dso, const char *symname)\r\n{\r\nHINSTANCE *ptr;\r\nvoid *sym;\r\nif((dso == NULL) || (symname == NULL))\r\n{\r\nDSOerr(DSO_F_WIN32_BIND_VAR,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn(NULL);\r\n}\r\nif(sk_void_num(dso->meth_data) < 1)\r\n{\r\nDSOerr(DSO_F_WIN32_BIND_VAR,DSO_R_STACK_ERROR);\r\nreturn(NULL);\r\n}\r\nptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\r\nif(ptr == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_BIND_VAR,DSO_R_NULL_HANDLE);\r\nreturn(NULL);\r\n}\r\nsym = GetProcAddress(*ptr, symname);\r\nif(sym == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_BIND_VAR,DSO_R_SYM_FAILURE);\r\nERR_add_error_data(3, "symname(", symname, ")");\r\nreturn(NULL);\r\n}\r\nreturn(sym);\r\n}\r\nstatic DSO_FUNC_TYPE win32_bind_func(DSO *dso, const char *symname)\r\n{\r\nHINSTANCE *ptr;\r\nvoid *sym;\r\nif((dso == NULL) || (symname == NULL))\r\n{\r\nDSOerr(DSO_F_WIN32_BIND_FUNC,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn(NULL);\r\n}\r\nif(sk_void_num(dso->meth_data) < 1)\r\n{\r\nDSOerr(DSO_F_WIN32_BIND_FUNC,DSO_R_STACK_ERROR);\r\nreturn(NULL);\r\n}\r\nptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\r\nif(ptr == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_BIND_FUNC,DSO_R_NULL_HANDLE);\r\nreturn(NULL);\r\n}\r\nsym = GetProcAddress(*ptr, symname);\r\nif(sym == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_BIND_FUNC,DSO_R_SYM_FAILURE);\r\nERR_add_error_data(3, "symname(", symname, ")");\r\nreturn(NULL);\r\n}\r\nreturn((DSO_FUNC_TYPE)sym);\r\n}\r\nstatic struct file_st *win32_splitter(DSO *dso, const char *filename,\r\nint assume_last_is_dir)\r\n{\r\nstruct file_st *result = NULL;\r\nenum { IN_NODE, IN_DEVICE, IN_FILE } position;\r\nconst char *start = filename;\r\nchar last;\r\nif (!filename)\r\n{\r\nDSOerr(DSO_F_WIN32_SPLITTER,DSO_R_NO_FILENAME);\r\nreturn(NULL);\r\n}\r\nresult = OPENSSL_malloc(sizeof(struct file_st));\r\nif(result == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_SPLITTER,\r\nERR_R_MALLOC_FAILURE);\r\nreturn(NULL);\r\n}\r\nmemset(result, 0, sizeof(struct file_st));\r\nposition = IN_DEVICE;\r\nif((filename[0] == '\\' && filename[1] == '\\')\r\n|| (filename[0] == '/' && filename[1] == '/'))\r\n{\r\nposition = IN_NODE;\r\nfilename += 2;\r\nstart = filename;\r\nresult->node = start;\r\n}\r\ndo\r\n{\r\nlast = filename[0];\r\nswitch(last)\r\n{\r\ncase ':':\r\nif(position != IN_DEVICE)\r\n{\r\nDSOerr(DSO_F_WIN32_SPLITTER,\r\nDSO_R_INCORRECT_FILE_SYNTAX);\r\nOPENSSL_free(result);\r\nreturn(NULL);\r\n}\r\nresult->device = start;\r\nresult->devicelen = (int)(filename - start);\r\nposition = IN_FILE;\r\nstart = ++filename;\r\nresult->dir = start;\r\nbreak;\r\ncase '\\':\r\ncase '/':\r\nif(position == IN_NODE)\r\n{\r\nresult->nodelen = (int)(filename - start);\r\nposition = IN_FILE;\r\nstart = ++filename;\r\nresult->dir = start;\r\n}\r\nelse if(position == IN_DEVICE)\r\n{\r\nposition = IN_FILE;\r\nfilename++;\r\nresult->dir = start;\r\nresult->dirlen = (int)(filename - start);\r\nstart = filename;\r\n}\r\nelse\r\n{\r\nfilename++;\r\nresult->dirlen += (int)(filename - start);\r\nstart = filename;\r\n}\r\nbreak;\r\ncase '\0':\r\nif(position == IN_NODE)\r\n{\r\nresult->nodelen = (int)(filename - start);\r\n}\r\nelse\r\n{\r\nif(filename - start > 0)\r\n{\r\nif (assume_last_is_dir)\r\n{\r\nif (position == IN_DEVICE)\r\n{\r\nresult->dir = start;\r\nresult->dirlen = 0;\r\n}\r\nresult->dirlen +=\r\n(int)(filename - start);\r\n}\r\nelse\r\n{\r\nresult->file = start;\r\nresult->filelen =\r\n(int)(filename - start);\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nfilename++;\r\nbreak;\r\n}\r\n}\r\nwhile(last);\r\nif(!result->nodelen) result->node = NULL;\r\nif(!result->devicelen) result->device = NULL;\r\nif(!result->dirlen) result->dir = NULL;\r\nif(!result->filelen) result->file = NULL;\r\nreturn(result);\r\n}\r\nstatic char *win32_joiner(DSO *dso, const struct file_st *file_split)\r\n{\r\nint len = 0, offset = 0;\r\nchar *result = NULL;\r\nconst char *start;\r\nif(!file_split)\r\n{\r\nDSOerr(DSO_F_WIN32_JOINER,\r\nERR_R_PASSED_NULL_PARAMETER);\r\nreturn(NULL);\r\n}\r\nif(file_split->node)\r\n{\r\nlen += 2 + file_split->nodelen;\r\nif(file_split->predir || file_split->dir || file_split->file)\r\nlen++;\r\n}\r\nelse if(file_split->device)\r\n{\r\nlen += file_split->devicelen + 1;\r\n}\r\nlen += file_split->predirlen;\r\nif(file_split->predir && (file_split->dir || file_split->file))\r\n{\r\nlen++;\r\n}\r\nlen += file_split->dirlen;\r\nif(file_split->dir && file_split->file)\r\n{\r\nlen++;\r\n}\r\nlen += file_split->filelen;\r\nif(!len)\r\n{\r\nDSOerr(DSO_F_WIN32_JOINER, DSO_R_EMPTY_FILE_STRUCTURE);\r\nreturn(NULL);\r\n}\r\nresult = OPENSSL_malloc(len + 1);\r\nif (!result)\r\n{\r\nDSOerr(DSO_F_WIN32_JOINER,\r\nERR_R_MALLOC_FAILURE);\r\nreturn(NULL);\r\n}\r\nif(file_split->node)\r\n{\r\nstrcpy(&result[offset], "\\\\"); offset += 2;\r\nstrncpy(&result[offset], file_split->node,\r\nfile_split->nodelen); offset += file_split->nodelen;\r\nif(file_split->predir || file_split->dir || file_split->file)\r\n{\r\nresult[offset] = '\\'; offset++;\r\n}\r\n}\r\nelse if(file_split->device)\r\n{\r\nstrncpy(&result[offset], file_split->device,\r\nfile_split->devicelen); offset += file_split->devicelen;\r\nresult[offset] = ':'; offset++;\r\n}\r\nstart = file_split->predir;\r\nwhile(file_split->predirlen > (start - file_split->predir))\r\n{\r\nconst char *end = openssl_strnchr(start, '/',\r\nfile_split->predirlen - (start - file_split->predir));\r\nif(!end)\r\nend = start\r\n+ file_split->predirlen\r\n- (start - file_split->predir);\r\nstrncpy(&result[offset], start,\r\nend - start); offset += (int)(end - start);\r\nresult[offset] = '\\'; offset++;\r\nstart = end + 1;\r\n}\r\n#if 0\r\nif(file_split->predir && (file_split->dir || file_split->file))\r\n{\r\nresult[offset] = '\\'; offset++;\r\n}\r\n#endif\r\nstart = file_split->dir;\r\nwhile(file_split->dirlen > (start - file_split->dir))\r\n{\r\nconst char *end = openssl_strnchr(start, '/',\r\nfile_split->dirlen - (start - file_split->dir));\r\nif(!end)\r\nend = start\r\n+ file_split->dirlen\r\n- (start - file_split->dir);\r\nstrncpy(&result[offset], start,\r\nend - start); offset += (int)(end - start);\r\nresult[offset] = '\\'; offset++;\r\nstart = end + 1;\r\n}\r\n#if 0\r\nif(file_split->dir && file_split->file)\r\n{\r\nresult[offset] = '\\'; offset++;\r\n}\r\n#endif\r\nstrncpy(&result[offset], file_split->file,\r\nfile_split->filelen); offset += file_split->filelen;\r\nresult[offset] = '\0';\r\nreturn(result);\r\n}\r\nstatic char *win32_merger(DSO *dso, const char *filespec1, const char *filespec2)\r\n{\r\nchar *merged = NULL;\r\nstruct file_st *filespec1_split = NULL;\r\nstruct file_st *filespec2_split = NULL;\r\nif(!filespec1 && !filespec2)\r\n{\r\nDSOerr(DSO_F_WIN32_MERGER,\r\nERR_R_PASSED_NULL_PARAMETER);\r\nreturn(NULL);\r\n}\r\nif (!filespec2)\r\n{\r\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\r\nif(!merged)\r\n{\r\nDSOerr(DSO_F_WIN32_MERGER,\r\nERR_R_MALLOC_FAILURE);\r\nreturn(NULL);\r\n}\r\nstrcpy(merged, filespec1);\r\n}\r\nelse if (!filespec1)\r\n{\r\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\r\nif(!merged)\r\n{\r\nDSOerr(DSO_F_WIN32_MERGER,\r\nERR_R_MALLOC_FAILURE);\r\nreturn(NULL);\r\n}\r\nstrcpy(merged, filespec2);\r\n}\r\nelse\r\n{\r\nfilespec1_split = win32_splitter(dso, filespec1, 0);\r\nif (!filespec1_split)\r\n{\r\nDSOerr(DSO_F_WIN32_MERGER,\r\nERR_R_MALLOC_FAILURE);\r\nreturn(NULL);\r\n}\r\nfilespec2_split = win32_splitter(dso, filespec2, 1);\r\nif (!filespec2_split)\r\n{\r\nDSOerr(DSO_F_WIN32_MERGER,\r\nERR_R_MALLOC_FAILURE);\r\nOPENSSL_free(filespec1_split);\r\nreturn(NULL);\r\n}\r\nif (!filespec1_split->node && !filespec1_split->device)\r\n{\r\nfilespec1_split->node = filespec2_split->node;\r\nfilespec1_split->nodelen = filespec2_split->nodelen;\r\nfilespec1_split->device = filespec2_split->device;\r\nfilespec1_split->devicelen = filespec2_split->devicelen;\r\n}\r\nif (!filespec1_split->dir)\r\n{\r\nfilespec1_split->dir = filespec2_split->dir;\r\nfilespec1_split->dirlen = filespec2_split->dirlen;\r\n}\r\nelse if (filespec1_split->dir[0] != '\\'\r\n&& filespec1_split->dir[0] != '/')\r\n{\r\nfilespec1_split->predir = filespec2_split->dir;\r\nfilespec1_split->predirlen = filespec2_split->dirlen;\r\n}\r\nif (!filespec1_split->file)\r\n{\r\nfilespec1_split->file = filespec2_split->file;\r\nfilespec1_split->filelen = filespec2_split->filelen;\r\n}\r\nmerged = win32_joiner(dso, filespec1_split);\r\n}\r\nOPENSSL_free(filespec1_split);\r\nOPENSSL_free(filespec2_split);\r\nreturn(merged);\r\n}\r\nstatic char *win32_name_converter(DSO *dso, const char *filename)\r\n{\r\nchar *translated;\r\nint len, transform;\r\nlen = strlen(filename);\r\ntransform = ((strstr(filename, "/") == NULL) &&\r\n(strstr(filename, "\\") == NULL) &&\r\n(strstr(filename, ":") == NULL));\r\nif(transform)\r\ntranslated = OPENSSL_malloc(len + 5);\r\nelse\r\ntranslated = OPENSSL_malloc(len + 1);\r\nif(translated == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_NAME_CONVERTER,\r\nDSO_R_NAME_TRANSLATION_FAILED);\r\nreturn(NULL);\r\n}\r\nif(transform)\r\nsprintf(translated, "%s.dll", filename);\r\nelse\r\nsprintf(translated, "%s", filename);\r\nreturn(translated);\r\n}\r\nstatic const char *openssl_strnchr(const char *string, int c, size_t len)\r\n{\r\nsize_t i;\r\nconst char *p;\r\nfor (i = 0, p = string; i < len && *p; i++, p++)\r\n{\r\nif (*p == c)\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int win32_pathbyaddr(void *addr,char *path,int sz)\r\n{\r\nHMODULE dll;\r\nHANDLE hModuleSnap = INVALID_HANDLE_VALUE;\r\nMODULEENTRY32 me32;\r\nCREATETOOLHELP32SNAPSHOT create_snap;\r\nCLOSETOOLHELP32SNAPSHOT close_snap;\r\nMODULE32 module_first, module_next;\r\nint len;\r\nif (addr == NULL)\r\n{\r\nunion { int(*f)(void*,char*,int); void *p; } t =\r\n{ win32_pathbyaddr };\r\naddr = t.p;\r\n}\r\ndll = LoadLibrary(TEXT(DLLNAME));\r\nif (dll == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_UNSUPPORTED);\r\nreturn -1;\r\n}\r\ncreate_snap = (CREATETOOLHELP32SNAPSHOT)\r\nGetProcAddress(dll,"CreateToolhelp32Snapshot");\r\nif (create_snap == NULL)\r\n{\r\nFreeLibrary(dll);\r\nDSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_UNSUPPORTED);\r\nreturn -1;\r\n}\r\n#ifdef _WIN32_WCE\r\nclose_snap = (CLOSETOOLHELP32SNAPSHOT)\r\nGetProcAddress(dll,"CloseToolhelp32Snapshot");\r\n#else\r\nclose_snap = (CLOSETOOLHELP32SNAPSHOT)CloseHandle;\r\n#endif\r\nmodule_first = (MODULE32)GetProcAddress(dll,"Module32First");\r\nmodule_next = (MODULE32)GetProcAddress(dll,"Module32Next");\r\nhModuleSnap = (*create_snap)(TH32CS_SNAPMODULE,0);\r\nif( hModuleSnap == INVALID_HANDLE_VALUE )\r\n{\r\nFreeLibrary(dll);\r\nDSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_UNSUPPORTED);\r\nreturn -1;\r\n}\r\nme32.dwSize = sizeof(me32);\r\nif(!(*module_first)(hModuleSnap,&me32))\r\n{\r\n(*close_snap)(hModuleSnap);\r\nFreeLibrary(dll);\r\nDSOerr(DSO_F_WIN32_PATHBYADDR,DSO_R_FAILURE);\r\nreturn -1;\r\n}\r\ndo {\r\nif ((BYTE *)addr >= me32.modBaseAddr &&\r\n(BYTE *)addr < me32.modBaseAddr+me32.modBaseSize)\r\n{\r\n(*close_snap)(hModuleSnap);\r\nFreeLibrary(dll);\r\n#ifdef _WIN32_WCE\r\n# if _WIN32_WCE >= 101\r\nreturn WideCharToMultiByte(CP_ACP,0,me32.szExePath,-1,\r\npath,sz,NULL,NULL);\r\n# else\r\nlen = (int)wcslen(me32.szExePath);\r\nif (sz <= 0) return len+1;\r\nif (len >= sz) len=sz-1;\r\nfor(i=0;i<len;i++)\r\npath[i] = (char)me32.szExePath[i];\r\npath[len++] = 0;\r\nreturn len;\r\n# endif\r\n#else\r\nlen = (int)strlen(me32.szExePath);\r\nif (sz <= 0) return len+1;\r\nif (len >= sz) len=sz-1;\r\nmemcpy(path,me32.szExePath,len);\r\npath[len++] = 0;\r\nreturn len;\r\n#endif\r\n}\r\n} while((*module_next)(hModuleSnap, &me32));\r\n(*close_snap)(hModuleSnap);\r\nFreeLibrary(dll);\r\nreturn 0;\r\n}\r\nstatic void *win32_globallookup(const char *name)\r\n{\r\nHMODULE dll;\r\nHANDLE hModuleSnap = INVALID_HANDLE_VALUE;\r\nMODULEENTRY32 me32;\r\nCREATETOOLHELP32SNAPSHOT create_snap;\r\nCLOSETOOLHELP32SNAPSHOT close_snap;\r\nMODULE32 module_first, module_next;\r\nFARPROC ret=NULL;\r\ndll = LoadLibrary(TEXT(DLLNAME));\r\nif (dll == NULL)\r\n{\r\nDSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);\r\nreturn NULL;\r\n}\r\ncreate_snap = (CREATETOOLHELP32SNAPSHOT)\r\nGetProcAddress(dll,"CreateToolhelp32Snapshot");\r\nif (create_snap == NULL)\r\n{\r\nFreeLibrary(dll);\r\nDSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);\r\nreturn NULL;\r\n}\r\n#ifdef _WIN32_WCE\r\nclose_snap = (CLOSETOOLHELP32SNAPSHOT)\r\nGetProcAddress(dll,"CloseToolhelp32Snapshot");\r\n#else\r\nclose_snap = (CLOSETOOLHELP32SNAPSHOT)CloseHandle;\r\n#endif\r\nmodule_first = (MODULE32)GetProcAddress(dll,"Module32First");\r\nmodule_next = (MODULE32)GetProcAddress(dll,"Module32Next");\r\nhModuleSnap = (*create_snap)(TH32CS_SNAPMODULE,0);\r\nif( hModuleSnap == INVALID_HANDLE_VALUE )\r\n{\r\nFreeLibrary(dll);\r\nDSOerr(DSO_F_WIN32_GLOBALLOOKUP,DSO_R_UNSUPPORTED);\r\nreturn NULL;\r\n}\r\nme32.dwSize = sizeof(me32);\r\nif (!(*module_first)(hModuleSnap,&me32))\r\n{\r\n(*close_snap)(hModuleSnap);\r\nFreeLibrary(dll);\r\nreturn NULL;\r\n}\r\ndo {\r\nif ((ret = GetProcAddress(me32.hModule,name)))\r\n{\r\n(*close_snap)(hModuleSnap);\r\nFreeLibrary(dll);\r\nreturn ret;\r\n}\r\n} while((*module_next)(hModuleSnap,&me32));\r\n(*close_snap)(hModuleSnap);\r\nFreeLibrary(dll);\r\nreturn NULL;\r\n}
