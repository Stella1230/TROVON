int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out,\r\nconst ASN1_ITEM *it)\r\n{\r\nreturn asn1_item_flags_i2d(val, out, it, ASN1_TFLG_NDEF);\r\n}\r\nint ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it)\r\n{\r\nreturn asn1_item_flags_i2d(val, out, it, 0);\r\n}\r\nstatic int asn1_item_flags_i2d(ASN1_VALUE *val, unsigned char **out,\r\nconst ASN1_ITEM *it, int flags)\r\n{\r\nif (out && !*out)\r\n{\r\nunsigned char *p, *buf;\r\nint len;\r\nlen = ASN1_item_ex_i2d(&val, NULL, it, -1, flags);\r\nif (len <= 0)\r\nreturn len;\r\nbuf = OPENSSL_malloc(len);\r\nif (!buf)\r\nreturn -1;\r\np = buf;\r\nASN1_item_ex_i2d(&val, &p, it, -1, flags);\r\n*out = buf;\r\nreturn len;\r\n}\r\nreturn ASN1_item_ex_i2d(&val, out, it, -1, flags);\r\n}\r\nint ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,\r\nconst ASN1_ITEM *it, int tag, int aclass)\r\n{\r\nconst ASN1_TEMPLATE *tt = NULL;\r\nunsigned char *p = NULL;\r\nint i, seqcontlen, seqlen, ndef = 1;\r\nconst ASN1_COMPAT_FUNCS *cf;\r\nconst ASN1_EXTERN_FUNCS *ef;\r\nconst ASN1_AUX *aux = it->funcs;\r\nASN1_aux_cb *asn1_cb = 0;\r\nif ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)\r\nreturn 0;\r\nif (aux && aux->asn1_cb)\r\nasn1_cb = aux->asn1_cb;\r\nswitch(it->itype)\r\n{\r\ncase ASN1_ITYPE_PRIMITIVE:\r\nif (it->templates)\r\nreturn asn1_template_ex_i2d(pval, out, it->templates,\r\ntag, aclass);\r\nreturn asn1_i2d_ex_primitive(pval, out, it, tag, aclass);\r\nbreak;\r\ncase ASN1_ITYPE_MSTRING:\r\nreturn asn1_i2d_ex_primitive(pval, out, it, -1, aclass);\r\ncase ASN1_ITYPE_CHOICE:\r\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\r\nreturn 0;\r\ni = asn1_get_choice_selector(pval, it);\r\nif ((i >= 0) && (i < it->tcount))\r\n{\r\nASN1_VALUE **pchval;\r\nconst ASN1_TEMPLATE *chtt;\r\nchtt = it->templates + i;\r\npchval = asn1_get_field_ptr(pval, chtt);\r\nreturn asn1_template_ex_i2d(pchval, out, chtt,\r\n-1, aclass);\r\n}\r\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\r\nreturn 0;\r\nbreak;\r\ncase ASN1_ITYPE_EXTERN:\r\nef = it->funcs;\r\nreturn ef->asn1_ex_i2d(pval, out, it, tag, aclass);\r\ncase ASN1_ITYPE_COMPAT:\r\ncf = it->funcs;\r\nif (out)\r\np = *out;\r\ni = cf->asn1_i2d(*pval, out);\r\nif (out && (tag != -1))\r\n*p = aclass | tag | (*p & V_ASN1_CONSTRUCTED);\r\nreturn i;\r\ncase ASN1_ITYPE_NDEF_SEQUENCE:\r\nif (aclass & ASN1_TFLG_NDEF) ndef = 2;\r\ncase ASN1_ITYPE_SEQUENCE:\r\ni = asn1_enc_restore(&seqcontlen, out, pval, it);\r\nif (i < 0)\r\nreturn 0;\r\nif (i > 0)\r\nreturn seqcontlen;\r\nseqcontlen = 0;\r\nif (tag == -1)\r\n{\r\ntag = V_ASN1_SEQUENCE;\r\naclass = (aclass & ~ASN1_TFLG_TAG_CLASS)\r\n| V_ASN1_UNIVERSAL;\r\n}\r\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\r\nreturn 0;\r\nfor (i = 0, tt = it->templates; i < it->tcount; tt++, i++)\r\n{\r\nconst ASN1_TEMPLATE *seqtt;\r\nASN1_VALUE **pseqval;\r\nseqtt = asn1_do_adb(pval, tt, 1);\r\nif (!seqtt)\r\nreturn 0;\r\npseqval = asn1_get_field_ptr(pval, seqtt);\r\nseqcontlen += asn1_template_ex_i2d(pseqval, NULL, seqtt,\r\n-1, aclass);\r\n}\r\nseqlen = ASN1_object_size(ndef, seqcontlen, tag);\r\nif (!out)\r\nreturn seqlen;\r\nASN1_put_object(out, ndef, seqcontlen, tag, aclass);\r\nfor (i = 0, tt = it->templates; i < it->tcount; tt++, i++)\r\n{\r\nconst ASN1_TEMPLATE *seqtt;\r\nASN1_VALUE **pseqval;\r\nseqtt = asn1_do_adb(pval, tt, 1);\r\nif (!seqtt)\r\nreturn 0;\r\npseqval = asn1_get_field_ptr(pval, seqtt);\r\nasn1_template_ex_i2d(pseqval, out, seqtt, -1, aclass);\r\n}\r\nif (ndef == 2)\r\nASN1_put_eoc(out);\r\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\r\nreturn 0;\r\nreturn seqlen;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nint ASN1_template_i2d(ASN1_VALUE **pval, unsigned char **out,\r\nconst ASN1_TEMPLATE *tt)\r\n{\r\nreturn asn1_template_ex_i2d(pval, out, tt, -1, 0);\r\n}\r\nstatic int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,\r\nconst ASN1_TEMPLATE *tt, int tag, int iclass)\r\n{\r\nint i, ret, flags, ttag, tclass, ndef;\r\nflags = tt->flags;\r\nif (flags & ASN1_TFLG_TAG_MASK)\r\n{\r\nif (tag != -1)\r\nreturn -1;\r\nttag = tt->tag;\r\ntclass = flags & ASN1_TFLG_TAG_CLASS;\r\n}\r\nelse if (tag != -1)\r\n{\r\nttag = tag;\r\ntclass = iclass & ASN1_TFLG_TAG_CLASS;\r\n}\r\nelse\r\n{\r\nttag = -1;\r\ntclass = 0;\r\n}\r\niclass &= ~ASN1_TFLG_TAG_CLASS;\r\nif ((flags & ASN1_TFLG_NDEF) && (iclass & ASN1_TFLG_NDEF))\r\nndef = 2;\r\nelse ndef = 1;\r\nif (flags & ASN1_TFLG_SK_MASK)\r\n{\r\nSTACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\r\nint isset, sktag, skaclass;\r\nint skcontlen, sklen;\r\nASN1_VALUE *skitem;\r\nif (!*pval)\r\nreturn 0;\r\nif (flags & ASN1_TFLG_SET_OF)\r\n{\r\nisset = 1;\r\nif (flags & ASN1_TFLG_SEQUENCE_OF)\r\nisset = 2;\r\n}\r\nelse isset = 0;\r\nif ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG))\r\n{\r\nsktag = ttag;\r\nskaclass = tclass;\r\n}\r\nelse\r\n{\r\nskaclass = V_ASN1_UNIVERSAL;\r\nif (isset)\r\nsktag = V_ASN1_SET;\r\nelse sktag = V_ASN1_SEQUENCE;\r\n}\r\nskcontlen = 0;\r\nfor (i = 0; i < sk_ASN1_VALUE_num(sk); i++)\r\n{\r\nskitem = sk_ASN1_VALUE_value(sk, i);\r\nskcontlen += ASN1_item_ex_i2d(&skitem, NULL,\r\nASN1_ITEM_ptr(tt->item),\r\n-1, iclass);\r\n}\r\nsklen = ASN1_object_size(ndef, skcontlen, sktag);\r\nif (flags & ASN1_TFLG_EXPTAG)\r\nret = ASN1_object_size(ndef, sklen, ttag);\r\nelse ret = sklen;\r\nif (!out)\r\nreturn ret;\r\nif (flags & ASN1_TFLG_EXPTAG)\r\nASN1_put_object(out, ndef, sklen, ttag, tclass);\r\nASN1_put_object(out, ndef, skcontlen, sktag, skaclass);\r\nasn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item),\r\nisset, iclass);\r\nif (ndef == 2)\r\n{\r\nASN1_put_eoc(out);\r\nif (flags & ASN1_TFLG_EXPTAG)\r\nASN1_put_eoc(out);\r\n}\r\nreturn ret;\r\n}\r\nif (flags & ASN1_TFLG_EXPTAG)\r\n{\r\ni = ASN1_item_ex_i2d(pval, NULL, ASN1_ITEM_ptr(tt->item),\r\n-1, iclass);\r\nif (!i)\r\nreturn 0;\r\nret = ASN1_object_size(ndef, i, ttag);\r\nif (out)\r\n{\r\nASN1_put_object(out, ndef, i, ttag, tclass);\r\nASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),\r\n-1, iclass);\r\nif (ndef == 2)\r\nASN1_put_eoc(out);\r\n}\r\nreturn ret;\r\n}\r\nreturn ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),\r\nttag, tclass | iclass);\r\n}\r\nstatic int der_cmp(const void *a, const void *b)\r\n{\r\nconst DER_ENC *d1 = a, *d2 = b;\r\nint cmplen, i;\r\ncmplen = (d1->length < d2->length) ? d1->length : d2->length;\r\ni = memcmp(d1->data, d2->data, cmplen);\r\nif (i)\r\nreturn i;\r\nreturn d1->length - d2->length;\r\n}\r\nstatic int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,\r\nconst ASN1_ITEM *it, int tag, int aclass)\r\n{\r\nint len;\r\nint utype;\r\nint usetag;\r\nint ndef = 0;\r\nutype = it->utype;\r\nlen = asn1_ex_i2c(pval, NULL, &utype, it);\r\nif ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||\r\n(utype == V_ASN1_OTHER))\r\nusetag = 0;\r\nelse usetag = 1;\r\nif (len == -1)\r\nreturn 0;\r\nif (len == -2)\r\n{\r\nndef = 2;\r\nlen = 0;\r\n}\r\nif (tag == -1) tag = utype;\r\nif (out)\r\n{\r\nif (usetag)\r\nASN1_put_object(out, ndef, len, tag, aclass);\r\nasn1_ex_i2c(pval, *out, &utype, it);\r\nif (ndef)\r\nASN1_put_eoc(out);\r\nelse\r\n*out += len;\r\n}\r\nif (usetag)\r\nreturn ASN1_object_size(ndef, len, tag);\r\nreturn len;\r\n}\r\nint asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *putype,\r\nconst ASN1_ITEM *it)\r\n{\r\nASN1_BOOLEAN *tbool = NULL;\r\nASN1_STRING *strtmp;\r\nASN1_OBJECT *otmp;\r\nint utype;\r\nconst unsigned char *cont;\r\nunsigned char c;\r\nint len;\r\nconst ASN1_PRIMITIVE_FUNCS *pf;\r\npf = it->funcs;\r\nif (pf && pf->prim_i2c)\r\nreturn pf->prim_i2c(pval, cout, putype, it);\r\nif ((it->itype != ASN1_ITYPE_PRIMITIVE)\r\n|| (it->utype != V_ASN1_BOOLEAN))\r\n{\r\nif (!*pval) return -1;\r\n}\r\nif (it->itype == ASN1_ITYPE_MSTRING)\r\n{\r\nstrtmp = (ASN1_STRING *)*pval;\r\nutype = strtmp->type;\r\n*putype = utype;\r\n}\r\nelse if (it->utype == V_ASN1_ANY)\r\n{\r\nASN1_TYPE *typ;\r\ntyp = (ASN1_TYPE *)*pval;\r\nutype = typ->type;\r\n*putype = utype;\r\npval = &typ->value.asn1_value;\r\n}\r\nelse utype = *putype;\r\nswitch(utype)\r\n{\r\ncase V_ASN1_OBJECT:\r\notmp = (ASN1_OBJECT *)*pval;\r\ncont = otmp->data;\r\nlen = otmp->length;\r\nbreak;\r\ncase V_ASN1_NULL:\r\ncont = NULL;\r\nlen = 0;\r\nbreak;\r\ncase V_ASN1_BOOLEAN:\r\ntbool = (ASN1_BOOLEAN *)pval;\r\nif (*tbool == -1)\r\nreturn -1;\r\nif (it->utype != V_ASN1_ANY)\r\n{\r\nif (*tbool && (it->size > 0))\r\nreturn -1;\r\nif (!*tbool && !it->size)\r\nreturn -1;\r\n}\r\nc = (unsigned char)*tbool;\r\ncont = &c;\r\nlen = 1;\r\nbreak;\r\ncase V_ASN1_BIT_STRING:\r\nreturn i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval,\r\ncout ? &cout : NULL);\r\nbreak;\r\ncase V_ASN1_INTEGER:\r\ncase V_ASN1_NEG_INTEGER:\r\ncase V_ASN1_ENUMERATED:\r\ncase V_ASN1_NEG_ENUMERATED:\r\nreturn i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval,\r\ncout ? &cout : NULL);\r\nbreak;\r\ncase V_ASN1_OCTET_STRING:\r\ncase V_ASN1_NUMERICSTRING:\r\ncase V_ASN1_PRINTABLESTRING:\r\ncase V_ASN1_T61STRING:\r\ncase V_ASN1_VIDEOTEXSTRING:\r\ncase V_ASN1_IA5STRING:\r\ncase V_ASN1_UTCTIME:\r\ncase V_ASN1_GENERALIZEDTIME:\r\ncase V_ASN1_GRAPHICSTRING:\r\ncase V_ASN1_VISIBLESTRING:\r\ncase V_ASN1_GENERALSTRING:\r\ncase V_ASN1_UNIVERSALSTRING:\r\ncase V_ASN1_BMPSTRING:\r\ncase V_ASN1_UTF8STRING:\r\ncase V_ASN1_SEQUENCE:\r\ncase V_ASN1_SET:\r\ndefault:\r\nstrtmp = (ASN1_STRING *)*pval;\r\nif ((it->size == ASN1_TFLG_NDEF)\r\n&& (strtmp->flags & ASN1_STRING_FLAG_NDEF))\r\n{\r\nif (cout)\r\n{\r\nstrtmp->data = cout;\r\nstrtmp->length = 0;\r\n}\r\nreturn -2;\r\n}\r\ncont = strtmp->data;\r\nlen = strtmp->length;\r\nbreak;\r\n}\r\nif (cout && len)\r\nmemcpy(cout, cont, len);\r\nreturn len;\r\n}
