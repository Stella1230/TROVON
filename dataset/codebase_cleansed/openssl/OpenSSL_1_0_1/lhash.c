_LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)\r\n{\r\n_LHASH *ret;\r\nint i;\r\nif ((ret=OPENSSL_malloc(sizeof(_LHASH))) == NULL)\r\ngoto err0;\r\nif ((ret->b=OPENSSL_malloc(sizeof(LHASH_NODE *)*MIN_NODES)) == NULL)\r\ngoto err1;\r\nfor (i=0; i<MIN_NODES; i++)\r\nret->b[i]=NULL;\r\nret->comp=((c == NULL)?(LHASH_COMP_FN_TYPE)strcmp:c);\r\nret->hash=((h == NULL)?(LHASH_HASH_FN_TYPE)lh_strhash:h);\r\nret->num_nodes=MIN_NODES/2;\r\nret->num_alloc_nodes=MIN_NODES;\r\nret->p=0;\r\nret->pmax=MIN_NODES/2;\r\nret->up_load=UP_LOAD;\r\nret->down_load=DOWN_LOAD;\r\nret->num_items=0;\r\nret->num_expands=0;\r\nret->num_expand_reallocs=0;\r\nret->num_contracts=0;\r\nret->num_contract_reallocs=0;\r\nret->num_hash_calls=0;\r\nret->num_comp_calls=0;\r\nret->num_insert=0;\r\nret->num_replace=0;\r\nret->num_delete=0;\r\nret->num_no_delete=0;\r\nret->num_retrieve=0;\r\nret->num_retrieve_miss=0;\r\nret->num_hash_comps=0;\r\nret->error=0;\r\nreturn(ret);\r\nerr1:\r\nOPENSSL_free(ret);\r\nerr0:\r\nreturn(NULL);\r\n}\r\nvoid lh_free(_LHASH *lh)\r\n{\r\nunsigned int i;\r\nLHASH_NODE *n,*nn;\r\nif (lh == NULL)\r\nreturn;\r\nfor (i=0; i<lh->num_nodes; i++)\r\n{\r\nn=lh->b[i];\r\nwhile (n != NULL)\r\n{\r\nnn=n->next;\r\nOPENSSL_free(n);\r\nn=nn;\r\n}\r\n}\r\nOPENSSL_free(lh->b);\r\nOPENSSL_free(lh);\r\n}\r\nvoid *lh_insert(_LHASH *lh, void *data)\r\n{\r\nunsigned long hash;\r\nLHASH_NODE *nn,**rn;\r\nvoid *ret;\r\nlh->error=0;\r\nif (lh->up_load <= (lh->num_items*LH_LOAD_MULT/lh->num_nodes))\r\nexpand(lh);\r\nrn=getrn(lh,data,&hash);\r\nif (*rn == NULL)\r\n{\r\nif ((nn=(LHASH_NODE *)OPENSSL_malloc(sizeof(LHASH_NODE))) == NULL)\r\n{\r\nlh->error++;\r\nreturn(NULL);\r\n}\r\nnn->data=data;\r\nnn->next=NULL;\r\n#ifndef OPENSSL_NO_HASH_COMP\r\nnn->hash=hash;\r\n#endif\r\n*rn=nn;\r\nret=NULL;\r\nlh->num_insert++;\r\nlh->num_items++;\r\n}\r\nelse\r\n{\r\nret= (*rn)->data;\r\n(*rn)->data=data;\r\nlh->num_replace++;\r\n}\r\nreturn(ret);\r\n}\r\nvoid *lh_delete(_LHASH *lh, const void *data)\r\n{\r\nunsigned long hash;\r\nLHASH_NODE *nn,**rn;\r\nvoid *ret;\r\nlh->error=0;\r\nrn=getrn(lh,data,&hash);\r\nif (*rn == NULL)\r\n{\r\nlh->num_no_delete++;\r\nreturn(NULL);\r\n}\r\nelse\r\n{\r\nnn= *rn;\r\n*rn=nn->next;\r\nret=nn->data;\r\nOPENSSL_free(nn);\r\nlh->num_delete++;\r\n}\r\nlh->num_items--;\r\nif ((lh->num_nodes > MIN_NODES) &&\r\n(lh->down_load >= (lh->num_items*LH_LOAD_MULT/lh->num_nodes)))\r\ncontract(lh);\r\nreturn(ret);\r\n}\r\nvoid *lh_retrieve(_LHASH *lh, const void *data)\r\n{\r\nunsigned long hash;\r\nLHASH_NODE **rn;\r\nvoid *ret;\r\nlh->error=0;\r\nrn=getrn(lh,data,&hash);\r\nif (*rn == NULL)\r\n{\r\nlh->num_retrieve_miss++;\r\nreturn(NULL);\r\n}\r\nelse\r\n{\r\nret= (*rn)->data;\r\nlh->num_retrieve++;\r\n}\r\nreturn(ret);\r\n}\r\nstatic void doall_util_fn(_LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,\r\nLHASH_DOALL_ARG_FN_TYPE func_arg, void *arg)\r\n{\r\nint i;\r\nLHASH_NODE *a,*n;\r\nif (lh == NULL)\r\nreturn;\r\nfor (i=lh->num_nodes-1; i>=0; i--)\r\n{\r\na=lh->b[i];\r\nwhile (a != NULL)\r\n{\r\nn=a->next;\r\nif(use_arg)\r\nfunc_arg(a->data,arg);\r\nelse\r\nfunc(a->data);\r\na=n;\r\n}\r\n}\r\n}\r\nvoid lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func)\r\n{\r\ndoall_util_fn(lh, 0, func, (LHASH_DOALL_ARG_FN_TYPE)0, NULL);\r\n}\r\nvoid lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)\r\n{\r\ndoall_util_fn(lh, 1, (LHASH_DOALL_FN_TYPE)0, func, arg);\r\n}\r\nstatic void expand(_LHASH *lh)\r\n{\r\nLHASH_NODE **n,**n1,**n2,*np;\r\nunsigned int p,i,j;\r\nunsigned long hash,nni;\r\nlh->num_nodes++;\r\nlh->num_expands++;\r\np=(int)lh->p++;\r\nn1= &(lh->b[p]);\r\nn2= &(lh->b[p+(int)lh->pmax]);\r\n*n2=NULL;\r\nnni=lh->num_alloc_nodes;\r\nfor (np= *n1; np != NULL; )\r\n{\r\n#ifndef OPENSSL_NO_HASH_COMP\r\nhash=np->hash;\r\n#else\r\nhash=lh->hash(np->data);\r\nlh->num_hash_calls++;\r\n#endif\r\nif ((hash%nni) != p)\r\n{\r\n*n1= (*n1)->next;\r\nnp->next= *n2;\r\n*n2=np;\r\n}\r\nelse\r\nn1= &((*n1)->next);\r\nnp= *n1;\r\n}\r\nif ((lh->p) >= lh->pmax)\r\n{\r\nj=(int)lh->num_alloc_nodes*2;\r\nn=(LHASH_NODE **)OPENSSL_realloc(lh->b,\r\n(int)(sizeof(LHASH_NODE *)*j));\r\nif (n == NULL)\r\n{\r\nlh->error++;\r\nlh->p=0;\r\nreturn;\r\n}\r\nfor (i=(int)lh->num_alloc_nodes; i<j; i++)\r\nn[i]=NULL;\r\nlh->pmax=lh->num_alloc_nodes;\r\nlh->num_alloc_nodes=j;\r\nlh->num_expand_reallocs++;\r\nlh->p=0;\r\nlh->b=n;\r\n}\r\n}\r\nstatic void contract(_LHASH *lh)\r\n{\r\nLHASH_NODE **n,*n1,*np;\r\nnp=lh->b[lh->p+lh->pmax-1];\r\nlh->b[lh->p+lh->pmax-1]=NULL;\r\nif (lh->p == 0)\r\n{\r\nn=(LHASH_NODE **)OPENSSL_realloc(lh->b,\r\n(unsigned int)(sizeof(LHASH_NODE *)*lh->pmax));\r\nif (n == NULL)\r\n{\r\nlh->error++;\r\nreturn;\r\n}\r\nlh->num_contract_reallocs++;\r\nlh->num_alloc_nodes/=2;\r\nlh->pmax/=2;\r\nlh->p=lh->pmax-1;\r\nlh->b=n;\r\n}\r\nelse\r\nlh->p--;\r\nlh->num_nodes--;\r\nlh->num_contracts++;\r\nn1=lh->b[(int)lh->p];\r\nif (n1 == NULL)\r\nlh->b[(int)lh->p]=np;\r\nelse\r\n{\r\nwhile (n1->next != NULL)\r\nn1=n1->next;\r\nn1->next=np;\r\n}\r\n}\r\nstatic LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash)\r\n{\r\nLHASH_NODE **ret,*n1;\r\nunsigned long hash,nn;\r\nLHASH_COMP_FN_TYPE cf;\r\nhash=(*(lh->hash))(data);\r\nlh->num_hash_calls++;\r\n*rhash=hash;\r\nnn=hash%lh->pmax;\r\nif (nn < lh->p)\r\nnn=hash%lh->num_alloc_nodes;\r\ncf=lh->comp;\r\nret= &(lh->b[(int)nn]);\r\nfor (n1= *ret; n1 != NULL; n1=n1->next)\r\n{\r\n#ifndef OPENSSL_NO_HASH_COMP\r\nlh->num_hash_comps++;\r\nif (n1->hash != hash)\r\n{\r\nret= &(n1->next);\r\ncontinue;\r\n}\r\n#endif\r\nlh->num_comp_calls++;\r\nif(cf(n1->data,data) == 0)\r\nbreak;\r\nret= &(n1->next);\r\n}\r\nreturn(ret);\r\n}\r\nunsigned long lh_strhash(const char *c)\r\n{\r\nunsigned long ret=0;\r\nlong n;\r\nunsigned long v;\r\nint r;\r\nif ((c == NULL) || (*c == '\0'))\r\nreturn(ret);\r\nn=0x100;\r\nwhile (*c)\r\n{\r\nv=n|(*c);\r\nn+=0x100;\r\nr= (int)((v>>2)^v)&0x0f;\r\nret=(ret<<r)|(ret>>(32-r));\r\nret&=0xFFFFFFFFL;\r\nret^=v*v;\r\nc++;\r\n}\r\nreturn((ret>>16)^ret);\r\n}\r\nunsigned long lh_num_items(const _LHASH *lh)\r\n{\r\nreturn lh ? lh->num_items : 0;\r\n}
