static void ctxdbg(BN_CTX *ctx)\r\n{\r\nunsigned int bnidx = 0, fpidx = 0;\r\nBN_POOL_ITEM *item = ctx->pool.head;\r\nBN_STACK *stack = &ctx->stack;\r\nfprintf(stderr,"(%08x): ", (unsigned int)ctx);\r\nwhile(bnidx < ctx->used)\r\n{\r\nfprintf(stderr,"%03x ", item->vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);\r\nif(!(bnidx % BN_CTX_POOL_SIZE))\r\nitem = item->next;\r\n}\r\nfprintf(stderr,"\n");\r\nbnidx = 0;\r\nfprintf(stderr," : ");\r\nwhile(fpidx < stack->depth)\r\n{\r\nwhile(bnidx++ < stack->indexes[fpidx])\r\nfprintf(stderr," ");\r\nfprintf(stderr,"^^^ ");\r\nbnidx++;\r\nfpidx++;\r\n}\r\nfprintf(stderr,"\n");\r\n}\r\nvoid BN_CTX_init(BN_CTX *ctx)\r\n{\r\nBN_POOL_reset(&ctx->pool);\r\nBN_STACK_reset(&ctx->stack);\r\nctx->used = 0;\r\nctx->err_stack = 0;\r\nctx->too_many = 0;\r\n}\r\nBN_CTX *BN_CTX_new(void)\r\n{\r\nBN_CTX *ret = OPENSSL_malloc(sizeof(BN_CTX));\r\nif(!ret)\r\n{\r\nBNerr(BN_F_BN_CTX_NEW,ERR_R_MALLOC_FAILURE);\r\nreturn NULL;\r\n}\r\nBN_POOL_init(&ret->pool);\r\nBN_STACK_init(&ret->stack);\r\nret->used = 0;\r\nret->err_stack = 0;\r\nret->too_many = 0;\r\nreturn ret;\r\n}\r\nvoid BN_CTX_free(BN_CTX *ctx)\r\n{\r\nif (ctx == NULL)\r\nreturn;\r\n#ifdef BN_CTX_DEBUG\r\n{\r\nBN_POOL_ITEM *pool = ctx->pool.head;\r\nfprintf(stderr,"BN_CTX_free, stack-size=%d, pool-bignums=%d\n",\r\nctx->stack.size, ctx->pool.size);\r\nfprintf(stderr,"dmaxs: ");\r\nwhile(pool) {\r\nunsigned loop = 0;\r\nwhile(loop < BN_CTX_POOL_SIZE)\r\nfprintf(stderr,"%02x ", pool->vals[loop++].dmax);\r\npool = pool->next;\r\n}\r\nfprintf(stderr,"\n");\r\n}\r\n#endif\r\nBN_STACK_finish(&ctx->stack);\r\nBN_POOL_finish(&ctx->pool);\r\nOPENSSL_free(ctx);\r\n}\r\nvoid BN_CTX_start(BN_CTX *ctx)\r\n{\r\nCTXDBG_ENTRY("BN_CTX_start", ctx);\r\nif(ctx->err_stack || ctx->too_many)\r\nctx->err_stack++;\r\nelse if(!BN_STACK_push(&ctx->stack, ctx->used))\r\n{\r\nBNerr(BN_F_BN_CTX_START,BN_R_TOO_MANY_TEMPORARY_VARIABLES);\r\nctx->err_stack++;\r\n}\r\nCTXDBG_EXIT(ctx);\r\n}\r\nvoid BN_CTX_end(BN_CTX *ctx)\r\n{\r\nCTXDBG_ENTRY("BN_CTX_end", ctx);\r\nif(ctx->err_stack)\r\nctx->err_stack--;\r\nelse\r\n{\r\nunsigned int fp = BN_STACK_pop(&ctx->stack);\r\nif(fp < ctx->used)\r\nBN_POOL_release(&ctx->pool, ctx->used - fp);\r\nctx->used = fp;\r\nctx->too_many = 0;\r\n}\r\nCTXDBG_EXIT(ctx);\r\n}\r\nBIGNUM *BN_CTX_get(BN_CTX *ctx)\r\n{\r\nBIGNUM *ret;\r\nCTXDBG_ENTRY("BN_CTX_get", ctx);\r\nif(ctx->err_stack || ctx->too_many) return NULL;\r\nif((ret = BN_POOL_get(&ctx->pool)) == NULL)\r\n{\r\nctx->too_many = 1;\r\nBNerr(BN_F_BN_CTX_GET,BN_R_TOO_MANY_TEMPORARY_VARIABLES);\r\nreturn NULL;\r\n}\r\nBN_zero(ret);\r\nctx->used++;\r\nCTXDBG_RET(ctx, ret);\r\nreturn ret;\r\n}\r\nstatic void BN_STACK_init(BN_STACK *st)\r\n{\r\nst->indexes = NULL;\r\nst->depth = st->size = 0;\r\n}\r\nstatic void BN_STACK_finish(BN_STACK *st)\r\n{\r\nif(st->size) OPENSSL_free(st->indexes);\r\n}\r\nstatic void BN_STACK_reset(BN_STACK *st)\r\n{\r\nst->depth = 0;\r\n}\r\nstatic int BN_STACK_push(BN_STACK *st, unsigned int idx)\r\n{\r\nif(st->depth == st->size)\r\n{\r\nunsigned int newsize = (st->size ?\r\n(st->size * 3 / 2) : BN_CTX_START_FRAMES);\r\nunsigned int *newitems = OPENSSL_malloc(newsize *\r\nsizeof(unsigned int));\r\nif(!newitems) return 0;\r\nif(st->depth)\r\nmemcpy(newitems, st->indexes, st->depth *\r\nsizeof(unsigned int));\r\nif(st->size) OPENSSL_free(st->indexes);\r\nst->indexes = newitems;\r\nst->size = newsize;\r\n}\r\nst->indexes[(st->depth)++] = idx;\r\nreturn 1;\r\n}\r\nstatic unsigned int BN_STACK_pop(BN_STACK *st)\r\n{\r\nreturn st->indexes[--(st->depth)];\r\n}\r\nstatic void BN_POOL_init(BN_POOL *p)\r\n{\r\np->head = p->current = p->tail = NULL;\r\np->used = p->size = 0;\r\n}\r\nstatic void BN_POOL_finish(BN_POOL *p)\r\n{\r\nwhile(p->head)\r\n{\r\nunsigned int loop = 0;\r\nBIGNUM *bn = p->head->vals;\r\nwhile(loop++ < BN_CTX_POOL_SIZE)\r\n{\r\nif(bn->d) BN_clear_free(bn);\r\nbn++;\r\n}\r\np->current = p->head->next;\r\nOPENSSL_free(p->head);\r\np->head = p->current;\r\n}\r\n}\r\nstatic void BN_POOL_reset(BN_POOL *p)\r\n{\r\nBN_POOL_ITEM *item = p->head;\r\nwhile(item)\r\n{\r\nunsigned int loop = 0;\r\nBIGNUM *bn = item->vals;\r\nwhile(loop++ < BN_CTX_POOL_SIZE)\r\n{\r\nif(bn->d) BN_clear(bn);\r\nbn++;\r\n}\r\nitem = item->next;\r\n}\r\np->current = p->head;\r\np->used = 0;\r\n}\r\nstatic BIGNUM *BN_POOL_get(BN_POOL *p)\r\n{\r\nif(p->used == p->size)\r\n{\r\nBIGNUM *bn;\r\nunsigned int loop = 0;\r\nBN_POOL_ITEM *item = OPENSSL_malloc(sizeof(BN_POOL_ITEM));\r\nif(!item) return NULL;\r\nbn = item->vals;\r\nwhile(loop++ < BN_CTX_POOL_SIZE)\r\nBN_init(bn++);\r\nitem->prev = p->tail;\r\nitem->next = NULL;\r\nif(!p->head)\r\np->head = p->current = p->tail = item;\r\nelse\r\n{\r\np->tail->next = item;\r\np->tail = item;\r\np->current = item;\r\n}\r\np->size += BN_CTX_POOL_SIZE;\r\np->used++;\r\nreturn item->vals;\r\n}\r\nif(!p->used)\r\np->current = p->head;\r\nelse if((p->used % BN_CTX_POOL_SIZE) == 0)\r\np->current = p->current->next;\r\nreturn p->current->vals + ((p->used++) % BN_CTX_POOL_SIZE);\r\n}\r\nstatic void BN_POOL_release(BN_POOL *p, unsigned int num)\r\n{\r\nunsigned int offset = (p->used - 1) % BN_CTX_POOL_SIZE;\r\np->used -= num;\r\nwhile(num--)\r\n{\r\nbn_check_top(p->current->vals + offset);\r\nif(!offset)\r\n{\r\noffset = BN_CTX_POOL_SIZE - 1;\r\np->current = p->current->prev;\r\n}\r\nelse\r\noffset--;\r\n}\r\n}
