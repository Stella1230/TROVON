static int oid_module_init(CONF_IMODULE *md, const CONF *cnf)\r\n{\r\nint i;\r\nconst char *oid_section;\r\nSTACK_OF(CONF_VALUE) *sktmp;\r\nCONF_VALUE *oval;\r\noid_section = CONF_imodule_get_value(md);\r\nif(!(sktmp = NCONF_get_section(cnf, oid_section)))\r\n{\r\nASN1err(ASN1_F_OID_MODULE_INIT, ASN1_R_ERROR_LOADING_SECTION);\r\nreturn 0;\r\n}\r\nfor(i = 0; i < sk_CONF_VALUE_num(sktmp); i++)\r\n{\r\noval = sk_CONF_VALUE_value(sktmp, i);\r\nif(!do_create(oval->value, oval->name))\r\n{\r\nASN1err(ASN1_F_OID_MODULE_INIT, ASN1_R_ADDING_OBJECT);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void oid_module_finish(CONF_IMODULE *md)\r\n{\r\nOBJ_cleanup();\r\n}\r\nvoid ASN1_add_oid_module(void)\r\n{\r\nCONF_module_add("oid_section", oid_module_init, oid_module_finish);\r\n}\r\nstatic int do_create(char *value, char *name)\r\n{\r\nint nid;\r\nASN1_OBJECT *oid;\r\nchar *ln, *ostr, *p, *lntmp;\r\np = strrchr(value, ',');\r\nif (!p)\r\n{\r\nln = name;\r\nostr = value;\r\n}\r\nelse\r\n{\r\nln = NULL;\r\nostr = p + 1;\r\nif (!*ostr)\r\nreturn 0;\r\nwhile(isspace((unsigned char)*ostr)) ostr++;\r\n}\r\nnid = OBJ_create(ostr, name, ln);\r\nif (nid == NID_undef)\r\nreturn 0;\r\nif (p)\r\n{\r\nln = value;\r\nwhile(isspace((unsigned char)*ln)) ln++;\r\np--;\r\nwhile(isspace((unsigned char)*p))\r\n{\r\nif (p == ln)\r\nreturn 0;\r\np--;\r\n}\r\np++;\r\nlntmp = OPENSSL_malloc((p - ln) + 1);\r\nif (lntmp == NULL)\r\nreturn 0;\r\nmemcpy(lntmp, ln, p - ln);\r\nlntmp[p - ln] = 0;\r\noid = OBJ_nid2obj(nid);\r\noid->ln = lntmp;\r\n}\r\nreturn 1;\r\n}
