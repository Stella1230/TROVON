BIO_METHOD *BIO_s_fd(void)\r\n{\r\nreturn(&methods_fdp);\r\n}\r\nBIO *BIO_new_fd(int fd,int close_flag)\r\n{\r\nBIO *ret;\r\nret=BIO_new(BIO_s_fd());\r\nif (ret == NULL) return(NULL);\r\nBIO_set_fd(ret,fd,close_flag);\r\nreturn(ret);\r\n}\r\nstatic int fd_new(BIO *bi)\r\n{\r\nbi->init=0;\r\nbi->num=-1;\r\nbi->ptr=NULL;\r\nbi->flags=BIO_FLAGS_UPLINK;\r\nreturn(1);\r\n}\r\nstatic int fd_free(BIO *a)\r\n{\r\nif (a == NULL) return(0);\r\nif (a->shutdown)\r\n{\r\nif (a->init)\r\n{\r\nUP_close(a->num);\r\n}\r\na->init=0;\r\na->flags=BIO_FLAGS_UPLINK;\r\n}\r\nreturn(1);\r\n}\r\nstatic int fd_read(BIO *b, char *out,int outl)\r\n{\r\nint ret=0;\r\nif (out != NULL)\r\n{\r\nclear_sys_error();\r\nret=UP_read(b->num,out,outl);\r\nBIO_clear_retry_flags(b);\r\nif (ret <= 0)\r\n{\r\nif (BIO_fd_should_retry(ret))\r\nBIO_set_retry_read(b);\r\n}\r\n}\r\nreturn(ret);\r\n}\r\nstatic int fd_write(BIO *b, const char *in, int inl)\r\n{\r\nint ret;\r\nclear_sys_error();\r\nret=UP_write(b->num,in,inl);\r\nBIO_clear_retry_flags(b);\r\nif (ret <= 0)\r\n{\r\nif (BIO_fd_should_retry(ret))\r\nBIO_set_retry_write(b);\r\n}\r\nreturn(ret);\r\n}\r\nstatic long fd_ctrl(BIO *b, int cmd, long num, void *ptr)\r\n{\r\nlong ret=1;\r\nint *ip;\r\nswitch (cmd)\r\n{\r\ncase BIO_CTRL_RESET:\r\nnum=0;\r\ncase BIO_C_FILE_SEEK:\r\nret=(long)UP_lseek(b->num,num,0);\r\nbreak;\r\ncase BIO_C_FILE_TELL:\r\ncase BIO_CTRL_INFO:\r\nret=(long)UP_lseek(b->num,0,1);\r\nbreak;\r\ncase BIO_C_SET_FD:\r\nfd_free(b);\r\nb->num= *((int *)ptr);\r\nb->shutdown=(int)num;\r\nb->init=1;\r\nbreak;\r\ncase BIO_C_GET_FD:\r\nif (b->init)\r\n{\r\nip=(int *)ptr;\r\nif (ip != NULL) *ip=b->num;\r\nret=b->num;\r\n}\r\nelse\r\nret= -1;\r\nbreak;\r\ncase BIO_CTRL_GET_CLOSE:\r\nret=b->shutdown;\r\nbreak;\r\ncase BIO_CTRL_SET_CLOSE:\r\nb->shutdown=(int)num;\r\nbreak;\r\ncase BIO_CTRL_PENDING:\r\ncase BIO_CTRL_WPENDING:\r\nret=0;\r\nbreak;\r\ncase BIO_CTRL_DUP:\r\ncase BIO_CTRL_FLUSH:\r\nret=1;\r\nbreak;\r\ndefault:\r\nret=0;\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic int fd_puts(BIO *bp, const char *str)\r\n{\r\nint n,ret;\r\nn=strlen(str);\r\nret=fd_write(bp,str,n);\r\nreturn(ret);\r\n}\r\nstatic int fd_gets(BIO *bp, char *buf, int size)\r\n{\r\nint ret=0;\r\nchar *ptr=buf;\r\nchar *end=buf+size-1;\r\nwhile ( (ptr < end) && (fd_read(bp, ptr, 1) > 0) && (ptr[0] != '\n') )\r\nptr++;\r\nptr[0]='\0';\r\nif (buf[0] != '\0')\r\nret=strlen(buf);\r\nreturn(ret);\r\n}\r\nint BIO_fd_should_retry(int i)\r\n{\r\nint err;\r\nif ((i == 0) || (i == -1))\r\n{\r\nerr=get_last_sys_error();\r\n#if defined(OPENSSL_SYS_WINDOWS) && 0\r\nif ((i == -1) && (err == 0))\r\nreturn(1);\r\n#endif\r\nreturn(BIO_fd_non_fatal_error(err));\r\n}\r\nreturn(0);\r\n}\r\nint BIO_fd_non_fatal_error(int err)\r\n{\r\nswitch (err)\r\n{\r\n#ifdef EWOULDBLOCK\r\n# ifdef WSAEWOULDBLOCK\r\n# if WSAEWOULDBLOCK != EWOULDBLOCK\r\ncase EWOULDBLOCK:\r\n# endif\r\n# else\r\ncase EWOULDBLOCK:\r\n# endif\r\n#endif\r\n#if defined(ENOTCONN)\r\ncase ENOTCONN:\r\n#endif\r\n#ifdef EINTR\r\ncase EINTR:\r\n#endif\r\n#ifdef EAGAIN\r\n#if EWOULDBLOCK != EAGAIN\r\ncase EAGAIN:\r\n# endif\r\n#endif\r\n#ifdef EPROTO\r\ncase EPROTO:\r\n#endif\r\n#ifdef EINPROGRESS\r\ncase EINPROGRESS:\r\n#endif\r\n#ifdef EALREADY\r\ncase EALREADY:\r\n#endif\r\nreturn(1);\r\ndefault:\r\nbreak;\r\n}\r\nreturn(0);\r\n}
