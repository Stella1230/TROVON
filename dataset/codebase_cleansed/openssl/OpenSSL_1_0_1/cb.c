void cb_ssl_info(const SSL *s, int where, int ret)\r\n{\r\nconst char *str1, *str2;\r\nint w;\r\nif(!fp_cb_ssl_info)\r\nreturn;\r\nw = where & ~SSL_ST_MASK;\r\nstr1 = (w & SSL_ST_CONNECT ? "SSL_connect" : (w & SSL_ST_ACCEPT ?\r\n"SSL_accept" : "undefined")),\r\nstr2 = SSL_state_string_long(s);\r\nif (where & SSL_CB_LOOP)\r\nfprintf(fp_cb_ssl_info, "(%s) %s\n", str1, str2);\r\nelse if (where & SSL_CB_EXIT) {\r\nif (ret == 0)\r\nfprintf(fp_cb_ssl_info, "(%s) failed in %s\n", str1, str2);\r\n#if 0\r\nelse if (ret < 0)\r\nfprintf(fp_cb_ssl_info, "%s:error in %s\n", str1, str2);\r\n#endif\r\n}\r\n}\r\nvoid cb_ssl_info_set_output(FILE *fp)\r\n{\r\nfp_cb_ssl_info = fp;\r\n}\r\nint cb_ssl_verify(int ok, X509_STORE_CTX *ctx)\r\n{\r\nchar buf1[256];\r\nchar buf2[256];\r\nconst char *reason = NULL;\r\nX509 *err_cert;\r\nint err, depth;\r\nif(!fp_cb_ssl_verify || (cb_ssl_verify_level == 0))\r\nreturn ok;\r\nerr_cert = X509_STORE_CTX_get_current_cert(ctx);\r\nerr = X509_STORE_CTX_get_error(ctx);\r\ndepth = X509_STORE_CTX_get_error_depth(ctx);\r\nbuf1[0] = buf2[0] = '\0';\r\nX509_NAME_oneline(X509_get_subject_name(err_cert), buf1, 256);\r\nX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert), buf2, 256);\r\nswitch (ctx->error) {\r\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\r\nreason = int_reason_no_issuer;\r\nbreak;\r\ncase X509_V_ERR_CERT_NOT_YET_VALID:\r\nreason = int_reason_not_yet;\r\nbreak;\r\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\r\nreason = int_reason_before;\r\nbreak;\r\ncase X509_V_ERR_CERT_HAS_EXPIRED:\r\nreason = int_reason_expired;\r\nbreak;\r\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\r\nreason = int_reason_after;\r\nbreak;\r\n}\r\nif((cb_ssl_verify_level == 1) && ok)\r\nreturn ok;\r\nfprintf(fp_cb_ssl_verify, "chain-depth=%d, ", depth);\r\nif(reason)\r\nfprintf(fp_cb_ssl_verify, "error=%s\n", reason);\r\nelse\r\nfprintf(fp_cb_ssl_verify, "error=%d\n", err);\r\nif(cb_ssl_verify_level < 3)\r\nreturn ok;\r\nfprintf(fp_cb_ssl_verify, "--> subject = %s\n", buf1);\r\nfprintf(fp_cb_ssl_verify, "--> issuer = %s\n", buf2);\r\nif(!ok)\r\nfprintf(fp_cb_ssl_verify,"--> verify error:num=%d:%s\n",err,\r\nX509_verify_cert_error_string(err));\r\nfprintf(fp_cb_ssl_verify, "--> verify return:%d\n",ok);\r\nreturn ok;\r\n}\r\nvoid cb_ssl_verify_set_output(FILE *fp)\r\n{\r\nfp_cb_ssl_verify = fp;\r\n}\r\nvoid cb_ssl_verify_set_depth(unsigned int verify_depth)\r\n{\r\nint_verify_depth = verify_depth;\r\n}\r\nvoid cb_ssl_verify_set_level(unsigned int level)\r\n{\r\nif(level < 4)\r\ncb_ssl_verify_level = level;\r\n}\r\nRSA *cb_generate_tmp_rsa(SSL *s, int is_export, int keylength)\r\n{\r\nstatic RSA *rsa_tmp = NULL;\r\nBIGNUM *bn = NULL;\r\nint ok = 1;\r\nif(!rsa_tmp) {\r\nok = 0;\r\nif(!(bn = BN_new()))\r\ngoto end;\r\nif(!BN_set_word(bn, RSA_F4))\r\ngoto end;\r\nif(!(rsa_tmp = RSA_new()))\r\ngoto end;\r\nif(!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL))\r\ngoto end;\r\nok = 1;\r\n}\r\nend:\r\nif(bn)\r\nBN_free(bn);\r\nif(!ok) {\r\nRSA_free(rsa_tmp);\r\nrsa_tmp = NULL;\r\n}\r\nreturn rsa_tmp;\r\n}
