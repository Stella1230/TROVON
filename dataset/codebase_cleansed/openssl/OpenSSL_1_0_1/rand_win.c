int RAND_poll(void)\r\n{\r\nMEMORYSTATUS m;\r\nHCRYPTPROV hProvider = 0;\r\nDWORD w;\r\nint good = 0;\r\nOSVERSIONINFO osverinfo ;\r\nosverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO) ;\r\nGetVersionEx( &osverinfo ) ;\r\n#if defined(OPENSSL_SYS_WINCE)\r\n# if defined(_WIN32_WCE) && _WIN32_WCE>=300\r\n{\r\nBYTE buf[64];\r\nif (CryptAcquireContextW(&hProvider, NULL, NULL, PROV_RSA_FULL,\r\nCRYPT_VERIFYCONTEXT))\r\n{\r\nif (CryptGenRandom(hProvider, sizeof(buf), buf))\r\nRAND_add(buf, sizeof(buf), sizeof(buf));\r\nCryptReleaseContext(hProvider, 0);\r\n}\r\n}\r\n# endif\r\n#else\r\n{\r\nHMODULE advapi = LoadLibrary(TEXT("ADVAPI32.DLL"));\r\nHMODULE kernel = LoadLibrary(TEXT("KERNEL32.DLL"));\r\nHMODULE user = NULL;\r\nHMODULE netapi = LoadLibrary(TEXT("NETAPI32.DLL"));\r\nCRYPTACQUIRECONTEXTW acquire = NULL;\r\nCRYPTGENRANDOM gen = NULL;\r\nCRYPTRELEASECONTEXT release = NULL;\r\nNETSTATGET netstatget = NULL;\r\nNETFREE netfree = NULL;\r\nBYTE buf[64];\r\nif (netapi)\r\n{\r\nnetstatget = (NETSTATGET) GetProcAddress(netapi,"NetStatisticsGet");\r\nnetfree = (NETFREE) GetProcAddress(netapi,"NetApiBufferFree");\r\n}\r\nif (netstatget && netfree)\r\n{\r\nLPBYTE outbuf;\r\nif (netstatget(NULL, L"LanmanWorkstation", 0, 0, &outbuf) == 0)\r\n{\r\nRAND_add(outbuf, sizeof(STAT_WORKSTATION_0), 45);\r\nnetfree(outbuf);\r\n}\r\nif (netstatget(NULL, L"LanmanServer", 0, 0, &outbuf) == 0)\r\n{\r\nRAND_add(outbuf, sizeof(STAT_SERVER_0), 17);\r\nnetfree(outbuf);\r\n}\r\n}\r\nif (netapi)\r\nFreeLibrary(netapi);\r\n#if 0\r\nif ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&\r\nosverinfo.dwMajorVersion < 5)\r\n{\r\nLONG rc=ERROR_MORE_DATA;\r\nchar * buf=NULL;\r\nDWORD bufsz=0;\r\nDWORD length;\r\nwhile (rc == ERROR_MORE_DATA)\r\n{\r\nbuf = realloc(buf,bufsz+8192);\r\nif (!buf)\r\nbreak;\r\nbufsz += 8192;\r\nlength = bufsz;\r\nrc = RegQueryValueEx(HKEY_PERFORMANCE_DATA, TEXT("Global"),\r\nNULL, NULL, buf, &length);\r\n}\r\nif (rc == ERROR_SUCCESS)\r\n{\r\nRAND_add(&length, sizeof(length), 0);\r\nRAND_add(buf, length, length / 4.0);\r\nRegCloseKey(HKEY_PERFORMANCE_DATA);\r\n}\r\nif (buf)\r\nfree(buf);\r\n}\r\n#endif\r\nif (advapi)\r\n{\r\nacquire = (CRYPTACQUIRECONTEXTW) GetProcAddress(advapi,\r\n"CryptAcquireContextW");\r\ngen = (CRYPTGENRANDOM) GetProcAddress(advapi,\r\n"CryptGenRandom");\r\nrelease = (CRYPTRELEASECONTEXT) GetProcAddress(advapi,\r\n"CryptReleaseContext");\r\n}\r\nif (acquire && gen && release)\r\n{\r\nif (acquire(&hProvider, NULL, NULL, PROV_RSA_FULL,\r\nCRYPT_VERIFYCONTEXT))\r\n{\r\nif (gen(hProvider, sizeof(buf), buf) != 0)\r\n{\r\nRAND_add(buf, sizeof(buf), 0);\r\ngood = 1;\r\n#if 0\r\nprintf("randomness from PROV_RSA_FULL\n");\r\n#endif\r\n}\r\nrelease(hProvider, 0);\r\n}\r\nif (acquire(&hProvider, 0, INTEL_DEF_PROV, PROV_INTEL_SEC, 0))\r\n{\r\nif (gen(hProvider, sizeof(buf), buf) != 0)\r\n{\r\nRAND_add(buf, sizeof(buf), sizeof(buf));\r\ngood = 1;\r\n#if 0\r\nprintf("randomness from PROV_INTEL_SEC\n");\r\n#endif\r\n}\r\nrelease(hProvider, 0);\r\n}\r\n}\r\nif (advapi)\r\nFreeLibrary(advapi);\r\nif ((osverinfo.dwPlatformId != VER_PLATFORM_WIN32_NT ||\r\n!OPENSSL_isservice()) &&\r\n(user = LoadLibrary(TEXT("USER32.DLL"))))\r\n{\r\nGETCURSORINFO cursor;\r\nGETFOREGROUNDWINDOW win;\r\nGETQUEUESTATUS queue;\r\nwin = (GETFOREGROUNDWINDOW) GetProcAddress(user, "GetForegroundWindow");\r\ncursor = (GETCURSORINFO) GetProcAddress(user, "GetCursorInfo");\r\nqueue = (GETQUEUESTATUS) GetProcAddress(user, "GetQueueStatus");\r\nif (win)\r\n{\r\nHWND h = win();\r\nRAND_add(&h, sizeof(h), 0);\r\n}\r\nif (cursor)\r\n{\r\nif ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&\r\nosverinfo.dwMajorVersion < 5)\r\ncursor = 0;\r\n}\r\nif (cursor)\r\n{\r\nCURSORINFO ci;\r\nci.cbSize = sizeof(CURSORINFO);\r\nif (cursor(&ci))\r\nRAND_add(&ci, ci.cbSize, 2);\r\n}\r\nif (queue)\r\n{\r\nw = queue(QS_ALLEVENTS);\r\nRAND_add(&w, sizeof(w), 1);\r\n}\r\nFreeLibrary(user);\r\n}\r\nif (kernel)\r\n{\r\nCREATETOOLHELP32SNAPSHOT snap;\r\nCLOSETOOLHELP32SNAPSHOT close_snap;\r\nHANDLE handle;\r\nHEAP32FIRST heap_first;\r\nHEAP32NEXT heap_next;\r\nHEAP32LIST heaplist_first, heaplist_next;\r\nPROCESS32 process_first, process_next;\r\nTHREAD32 thread_first, thread_next;\r\nMODULE32 module_first, module_next;\r\nHEAPLIST32 hlist;\r\nHEAPENTRY32 hentry;\r\nPROCESSENTRY32 p;\r\nTHREADENTRY32 t;\r\nMODULEENTRY32 m;\r\nDWORD starttime = 0;\r\nsnap = (CREATETOOLHELP32SNAPSHOT)\r\nGetProcAddress(kernel, "CreateToolhelp32Snapshot");\r\nclose_snap = (CLOSETOOLHELP32SNAPSHOT)\r\nGetProcAddress(kernel, "CloseToolhelp32Snapshot");\r\nheap_first = (HEAP32FIRST) GetProcAddress(kernel, "Heap32First");\r\nheap_next = (HEAP32NEXT) GetProcAddress(kernel, "Heap32Next");\r\nheaplist_first = (HEAP32LIST) GetProcAddress(kernel, "Heap32ListFirst");\r\nheaplist_next = (HEAP32LIST) GetProcAddress(kernel, "Heap32ListNext");\r\nprocess_first = (PROCESS32) GetProcAddress(kernel, "Process32First");\r\nprocess_next = (PROCESS32) GetProcAddress(kernel, "Process32Next");\r\nthread_first = (THREAD32) GetProcAddress(kernel, "Thread32First");\r\nthread_next = (THREAD32) GetProcAddress(kernel, "Thread32Next");\r\nmodule_first = (MODULE32) GetProcAddress(kernel, "Module32First");\r\nmodule_next = (MODULE32) GetProcAddress(kernel, "Module32Next");\r\nif (snap && heap_first && heap_next && heaplist_first &&\r\nheaplist_next && process_first && process_next &&\r\nthread_first && thread_next && module_first &&\r\nmodule_next && (handle = snap(TH32CS_SNAPALL,0))\r\n!= INVALID_HANDLE_VALUE)\r\n{\r\nZeroMemory(&hlist, sizeof(HEAPLIST32));\r\nhlist.dwSize = sizeof(HEAPLIST32);\r\nif (good) starttime = GetTickCount();\r\n#ifdef _MSC_VER\r\nif (heaplist_first(handle, &hlist))\r\n{\r\nint ex_cnt_limit = 42;\r\ndo\r\n{\r\nRAND_add(&hlist, hlist.dwSize, 3);\r\n__try\r\n{\r\nZeroMemory(&hentry, sizeof(HEAPENTRY32));\r\nhentry.dwSize = sizeof(HEAPENTRY32);\r\nif (heap_first(&hentry,\r\nhlist.th32ProcessID,\r\nhlist.th32HeapID))\r\n{\r\nint entrycnt = 80;\r\ndo\r\nRAND_add(&hentry,\r\nhentry.dwSize, 5);\r\nwhile (heap_next(&hentry)\r\n&& (!good || (GetTickCount()-starttime)<MAXDELAY)\r\n&& --entrycnt > 0);\r\n}\r\n}\r\n__except (EXCEPTION_EXECUTE_HANDLER)\r\n{\r\nex_cnt_limit--;\r\n}\r\n} while (heaplist_next(handle, &hlist)\r\n&& (!good || (GetTickCount()-starttime)<MAXDELAY)\r\n&& ex_cnt_limit > 0);\r\n}\r\n#else\r\nif (heaplist_first(handle, &hlist))\r\n{\r\ndo\r\n{\r\nRAND_add(&hlist, hlist.dwSize, 3);\r\nhentry.dwSize = sizeof(HEAPENTRY32);\r\nif (heap_first(&hentry,\r\nhlist.th32ProcessID,\r\nhlist.th32HeapID))\r\n{\r\nint entrycnt = 80;\r\ndo\r\nRAND_add(&hentry,\r\nhentry.dwSize, 5);\r\nwhile (heap_next(&hentry)\r\n&& --entrycnt > 0);\r\n}\r\n} while (heaplist_next(handle, &hlist)\r\n&& (!good || (GetTickCount()-starttime)<MAXDELAY));\r\n}\r\n#endif\r\np.dwSize = sizeof(PROCESSENTRY32);\r\nif (good) starttime = GetTickCount();\r\nif (process_first(handle, &p))\r\ndo\r\nRAND_add(&p, p.dwSize, 9);\r\nwhile (process_next(handle, &p) && (!good || (GetTickCount()-starttime)<MAXDELAY));\r\nt.dwSize = sizeof(THREADENTRY32);\r\nif (good) starttime = GetTickCount();\r\nif (thread_first(handle, &t))\r\ndo\r\nRAND_add(&t, t.dwSize, 6);\r\nwhile (thread_next(handle, &t) && (!good || (GetTickCount()-starttime)<MAXDELAY));\r\nm.dwSize = sizeof(MODULEENTRY32);\r\nif (good) starttime = GetTickCount();\r\nif (module_first(handle, &m))\r\ndo\r\nRAND_add(&m, m.dwSize, 9);\r\nwhile (module_next(handle, &m)\r\n&& (!good || (GetTickCount()-starttime)<MAXDELAY));\r\nif (close_snap)\r\nclose_snap(handle);\r\nelse\r\nCloseHandle(handle);\r\n}\r\nFreeLibrary(kernel);\r\n}\r\n}\r\n#endif\r\nreadtimer();\r\nGlobalMemoryStatus(&m);\r\nRAND_add(&m, sizeof(m), 1);\r\nw = GetCurrentProcessId();\r\nRAND_add(&w, sizeof(w), 1);\r\n#if 0\r\nprintf("Exiting RAND_poll\n");\r\n#endif\r\nreturn(1);\r\n}\r\nint RAND_event(UINT iMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\ndouble add_entropy=0;\r\nswitch (iMsg)\r\n{\r\ncase WM_KEYDOWN:\r\n{\r\nstatic WPARAM key;\r\nif (key != wParam)\r\nadd_entropy = 0.05;\r\nkey = wParam;\r\n}\r\nbreak;\r\ncase WM_MOUSEMOVE:\r\n{\r\nstatic int lastx,lasty,lastdx,lastdy;\r\nint x,y,dx,dy;\r\nx=LOWORD(lParam);\r\ny=HIWORD(lParam);\r\ndx=lastx-x;\r\ndy=lasty-y;\r\nif (dx != 0 && dy != 0 && dx-lastdx != 0 && dy-lastdy != 0)\r\nadd_entropy=.2;\r\nlastx=x, lasty=y;\r\nlastdx=dx, lastdy=dy;\r\n}\r\nbreak;\r\n}\r\nreadtimer();\r\nRAND_add(&iMsg, sizeof(iMsg), add_entropy);\r\nRAND_add(&wParam, sizeof(wParam), 0);\r\nRAND_add(&lParam, sizeof(lParam), 0);\r\nreturn (RAND_status());\r\n}\r\nvoid RAND_screen(void)\r\n{\r\nRAND_poll();\r\nreadscreen();\r\n}\r\nstatic void readtimer(void)\r\n{\r\nDWORD w;\r\nLARGE_INTEGER l;\r\nstatic int have_perfc = 1;\r\n#if defined(_MSC_VER) && defined(_M_X86)\r\nstatic int have_tsc = 1;\r\nDWORD cyclecount;\r\nif (have_tsc) {\r\n__try {\r\n__asm {\r\n_emit 0x0f\r\n_emit 0x31\r\nmov cyclecount, eax\r\n}\r\nRAND_add(&cyclecount, sizeof(cyclecount), 1);\r\n} __except(EXCEPTION_EXECUTE_HANDLER) {\r\nhave_tsc = 0;\r\n}\r\n}\r\n#else\r\n# define have_tsc 0\r\n#endif\r\nif (have_perfc) {\r\nif (QueryPerformanceCounter(&l) == 0)\r\nhave_perfc = 0;\r\nelse\r\nRAND_add(&l, sizeof(l), 0);\r\n}\r\nif (!have_tsc && !have_perfc) {\r\nw = GetTickCount();\r\nRAND_add(&w, sizeof(w), 0);\r\n}\r\n}\r\nstatic void readscreen(void)\r\n{\r\n#if !defined(OPENSSL_SYS_WINCE) && !defined(OPENSSL_SYS_WIN32_CYGWIN)\r\nHDC hScrDC;\r\nHDC hMemDC;\r\nHBITMAP hBitmap;\r\nHBITMAP hOldBitmap;\r\nBITMAP bm;\r\nunsigned int size;\r\nchar *bmbits;\r\nint w;\r\nint h;\r\nint y;\r\nint n = 16;\r\nif (GetVersion() < 0x80000000 && OPENSSL_isservice()>0)\r\nreturn;\r\nhScrDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);\r\nhMemDC = CreateCompatibleDC(hScrDC);\r\nw = GetDeviceCaps(hScrDC, HORZRES);\r\nh = GetDeviceCaps(hScrDC, VERTRES);\r\nhBitmap = CreateCompatibleBitmap(hScrDC, w, n);\r\nhOldBitmap = SelectObject(hMemDC, hBitmap);\r\nGetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);\r\nsize = (unsigned int)bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes;\r\nbmbits = OPENSSL_malloc(size);\r\nif (bmbits) {\r\nfor (y = 0; y < h-n; y += n)\r\n{\r\nunsigned char md[MD_DIGEST_LENGTH];\r\nBitBlt(hMemDC, 0, 0, w, n, hScrDC, 0, y, SRCCOPY);\r\nGetBitmapBits(hBitmap, size, bmbits);\r\nMD(bmbits,size,md);\r\nRAND_add(md, MD_DIGEST_LENGTH, 0);\r\n}\r\nOPENSSL_free(bmbits);\r\n}\r\nhBitmap = SelectObject(hMemDC, hOldBitmap);\r\nDeleteObject(hBitmap);\r\nDeleteDC(hMemDC);\r\nDeleteDC(hScrDC);\r\n#endif\r\n}
