ASN1_TYPE *ASN1_generate_nconf(char *str, CONF *nconf)\r\n{\r\nX509V3_CTX cnf;\r\nif (!nconf)\r\nreturn ASN1_generate_v3(str, NULL);\r\nX509V3_set_nconf(&cnf, nconf);\r\nreturn ASN1_generate_v3(str, &cnf);\r\n}\r\nASN1_TYPE *ASN1_generate_v3(char *str, X509V3_CTX *cnf)\r\n{\r\nASN1_TYPE *ret;\r\ntag_exp_arg asn1_tags;\r\ntag_exp_type *etmp;\r\nint i, len;\r\nunsigned char *orig_der = NULL, *new_der = NULL;\r\nconst unsigned char *cpy_start;\r\nunsigned char *p;\r\nconst unsigned char *cp;\r\nint cpy_len;\r\nlong hdr_len;\r\nint hdr_constructed = 0, hdr_tag, hdr_class;\r\nint r;\r\nasn1_tags.imp_tag = -1;\r\nasn1_tags.imp_class = -1;\r\nasn1_tags.format = ASN1_GEN_FORMAT_ASCII;\r\nasn1_tags.exp_count = 0;\r\nif (CONF_parse_list(str, ',', 1, asn1_cb, &asn1_tags) != 0)\r\nreturn NULL;\r\nif ((asn1_tags.utype == V_ASN1_SEQUENCE) || (asn1_tags.utype == V_ASN1_SET))\r\n{\r\nif (!cnf)\r\n{\r\nASN1err(ASN1_F_ASN1_GENERATE_V3, ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG);\r\nreturn NULL;\r\n}\r\nret = asn1_multi(asn1_tags.utype, asn1_tags.str, cnf);\r\n}\r\nelse\r\nret = asn1_str2type(asn1_tags.str, asn1_tags.format, asn1_tags.utype);\r\nif (!ret)\r\nreturn NULL;\r\nif ((asn1_tags.imp_tag == -1) && (asn1_tags.exp_count == 0))\r\nreturn ret;\r\ncpy_len = i2d_ASN1_TYPE(ret, &orig_der);\r\nASN1_TYPE_free(ret);\r\nret = NULL;\r\ncpy_start = orig_der;\r\nif (asn1_tags.imp_tag != -1)\r\n{\r\nr = ASN1_get_object(&cpy_start, &hdr_len, &hdr_tag, &hdr_class, cpy_len);\r\nif (r & 0x80)\r\ngoto err;\r\ncpy_len -= cpy_start - orig_der;\r\nif (r & 0x1)\r\n{\r\nhdr_constructed = 2;\r\nhdr_len = 0;\r\n}\r\nelse\r\nhdr_constructed = r & V_ASN1_CONSTRUCTED;\r\nlen = ASN1_object_size(0, hdr_len, asn1_tags.imp_tag);\r\n}\r\nelse\r\nlen = cpy_len;\r\nfor(i = 0, etmp = asn1_tags.exp_list + asn1_tags.exp_count - 1; i < asn1_tags.exp_count; i++, etmp--)\r\n{\r\nlen += etmp->exp_pad;\r\netmp->exp_len = len;\r\nlen = ASN1_object_size(0, len, etmp->exp_tag);\r\n}\r\nnew_der = OPENSSL_malloc(len);\r\nif (!new_der)\r\ngoto err;\r\np = new_der;\r\nfor (i = 0, etmp = asn1_tags.exp_list; i < asn1_tags.exp_count; i++, etmp++)\r\n{\r\nASN1_put_object(&p, etmp->exp_constructed, etmp->exp_len,\r\netmp->exp_tag, etmp->exp_class);\r\nif (etmp->exp_pad)\r\n*p++ = 0;\r\n}\r\nif (asn1_tags.imp_tag != -1)\r\n{\r\nif (asn1_tags.imp_class == V_ASN1_UNIVERSAL\r\n&& (asn1_tags.imp_tag == V_ASN1_SEQUENCE\r\n|| asn1_tags.imp_tag == V_ASN1_SET) )\r\nhdr_constructed = V_ASN1_CONSTRUCTED;\r\nASN1_put_object(&p, hdr_constructed, hdr_len,\r\nasn1_tags.imp_tag, asn1_tags.imp_class);\r\n}\r\nmemcpy(p, cpy_start, cpy_len);\r\ncp = new_der;\r\nret = d2i_ASN1_TYPE(NULL, &cp, len);\r\nerr:\r\nif (orig_der)\r\nOPENSSL_free(orig_der);\r\nif (new_der)\r\nOPENSSL_free(new_der);\r\nreturn ret;\r\n}\r\nstatic int asn1_cb(const char *elem, int len, void *bitstr)\r\n{\r\ntag_exp_arg *arg = bitstr;\r\nint i;\r\nint utype;\r\nint vlen = 0;\r\nconst char *p, *vstart = NULL;\r\nint tmp_tag, tmp_class;\r\nfor(i = 0, p = elem; i < len; p++, i++)\r\n{\r\nif (*p == ':')\r\n{\r\nvstart = p + 1;\r\nvlen = len - (vstart - elem);\r\nlen = p - elem;\r\nbreak;\r\n}\r\n}\r\nutype = asn1_str2tag(elem, len);\r\nif (utype == -1)\r\n{\r\nASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG);\r\nERR_add_error_data(2, "tag=", elem);\r\nreturn -1;\r\n}\r\nif (!(utype & ASN1_GEN_FLAG))\r\n{\r\narg->utype = utype;\r\narg->str = vstart;\r\nif (!vstart && elem[len])\r\n{\r\nASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nswitch(utype)\r\n{\r\ncase ASN1_GEN_FLAG_IMP:\r\nif (arg->imp_tag != -1)\r\n{\r\nASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING);\r\nreturn -1;\r\n}\r\nif (!parse_tagging(vstart, vlen, &arg->imp_tag, &arg->imp_class))\r\nreturn -1;\r\nbreak;\r\ncase ASN1_GEN_FLAG_EXP:\r\nif (!parse_tagging(vstart, vlen, &tmp_tag, &tmp_class))\r\nreturn -1;\r\nif (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0))\r\nreturn -1;\r\nbreak;\r\ncase ASN1_GEN_FLAG_SEQWRAP:\r\nif (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1))\r\nreturn -1;\r\nbreak;\r\ncase ASN1_GEN_FLAG_SETWRAP:\r\nif (!append_exp(arg, V_ASN1_SET, V_ASN1_UNIVERSAL, 1, 0, 1))\r\nreturn -1;\r\nbreak;\r\ncase ASN1_GEN_FLAG_BITWRAP:\r\nif (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1))\r\nreturn -1;\r\nbreak;\r\ncase ASN1_GEN_FLAG_OCTWRAP:\r\nif (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1))\r\nreturn -1;\r\nbreak;\r\ncase ASN1_GEN_FLAG_FORMAT:\r\nif (!strncmp(vstart, "ASCII", 5))\r\narg->format = ASN1_GEN_FORMAT_ASCII;\r\nelse if (!strncmp(vstart, "UTF8", 4))\r\narg->format = ASN1_GEN_FORMAT_UTF8;\r\nelse if (!strncmp(vstart, "HEX", 3))\r\narg->format = ASN1_GEN_FORMAT_HEX;\r\nelse if (!strncmp(vstart, "BITLIST", 3))\r\narg->format = ASN1_GEN_FORMAT_BITLIST;\r\nelse\r\n{\r\nASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKOWN_FORMAT);\r\nreturn -1;\r\n}\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic int parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass)\r\n{\r\nchar erch[2];\r\nlong tag_num;\r\nchar *eptr;\r\nif (!vstart)\r\nreturn 0;\r\ntag_num = strtoul(vstart, &eptr, 10);\r\nif (eptr && *eptr && (eptr > vstart + vlen))\r\nreturn 0;\r\nif (tag_num < 0)\r\n{\r\nASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_NUMBER);\r\nreturn 0;\r\n}\r\n*ptag = tag_num;\r\nif (eptr)\r\nvlen -= eptr - vstart;\r\nelse\r\nvlen = 0;\r\nif (vlen)\r\n{\r\nswitch (*eptr)\r\n{\r\ncase 'U':\r\n*pclass = V_ASN1_UNIVERSAL;\r\nbreak;\r\ncase 'A':\r\n*pclass = V_ASN1_APPLICATION;\r\nbreak;\r\ncase 'P':\r\n*pclass = V_ASN1_PRIVATE;\r\nbreak;\r\ncase 'C':\r\n*pclass = V_ASN1_CONTEXT_SPECIFIC;\r\nbreak;\r\ndefault:\r\nerch[0] = *eptr;\r\nerch[1] = 0;\r\nASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_MODIFIER);\r\nERR_add_error_data(2, "Char=", erch);\r\nreturn 0;\r\nbreak;\r\n}\r\n}\r\nelse\r\n*pclass = V_ASN1_CONTEXT_SPECIFIC;\r\nreturn 1;\r\n}\r\nstatic ASN1_TYPE *asn1_multi(int utype, const char *section, X509V3_CTX *cnf)\r\n{\r\nASN1_TYPE *ret = NULL;\r\nSTACK_OF(ASN1_TYPE) *sk = NULL;\r\nSTACK_OF(CONF_VALUE) *sect = NULL;\r\nunsigned char *der = NULL;\r\nint derlen;\r\nint i;\r\nsk = sk_ASN1_TYPE_new_null();\r\nif (!sk)\r\ngoto bad;\r\nif (section)\r\n{\r\nif (!cnf)\r\ngoto bad;\r\nsect = X509V3_get_section(cnf, (char *)section);\r\nif (!sect)\r\ngoto bad;\r\nfor (i = 0; i < sk_CONF_VALUE_num(sect); i++)\r\n{\r\nASN1_TYPE *typ = ASN1_generate_v3(sk_CONF_VALUE_value(sect, i)->value, cnf);\r\nif (!typ)\r\ngoto bad;\r\nif (!sk_ASN1_TYPE_push(sk, typ))\r\ngoto bad;\r\n}\r\n}\r\nif (utype == V_ASN1_SET)\r\nderlen = i2d_ASN1_SET_ANY(sk, &der);\r\nelse\r\nderlen = i2d_ASN1_SEQUENCE_ANY(sk, &der);\r\nif (derlen < 0)\r\ngoto bad;\r\nif (!(ret = ASN1_TYPE_new()))\r\ngoto bad;\r\nif (!(ret->value.asn1_string = ASN1_STRING_type_new(utype)))\r\ngoto bad;\r\nret->type = utype;\r\nret->value.asn1_string->data = der;\r\nret->value.asn1_string->length = derlen;\r\nder = NULL;\r\nbad:\r\nif (der)\r\nOPENSSL_free(der);\r\nif (sk)\r\nsk_ASN1_TYPE_pop_free(sk, ASN1_TYPE_free);\r\nif (sect)\r\nX509V3_section_free(cnf, sect);\r\nreturn ret;\r\n}\r\nstatic int append_exp(tag_exp_arg *arg, int exp_tag, int exp_class, int exp_constructed, int exp_pad, int imp_ok)\r\n{\r\ntag_exp_type *exp_tmp;\r\nif ((arg->imp_tag != -1) && !imp_ok)\r\n{\r\nASN1err(ASN1_F_APPEND_EXP, ASN1_R_ILLEGAL_IMPLICIT_TAG);\r\nreturn 0;\r\n}\r\nif (arg->exp_count == ASN1_FLAG_EXP_MAX)\r\n{\r\nASN1err(ASN1_F_APPEND_EXP, ASN1_R_DEPTH_EXCEEDED);\r\nreturn 0;\r\n}\r\nexp_tmp = &arg->exp_list[arg->exp_count++];\r\nif (arg->imp_tag != -1)\r\n{\r\nexp_tmp->exp_tag = arg->imp_tag;\r\nexp_tmp->exp_class = arg->imp_class;\r\narg->imp_tag = -1;\r\narg->imp_class = -1;\r\n}\r\nelse\r\n{\r\nexp_tmp->exp_tag = exp_tag;\r\nexp_tmp->exp_class = exp_class;\r\n}\r\nexp_tmp->exp_constructed = exp_constructed;\r\nexp_tmp->exp_pad = exp_pad;\r\nreturn 1;\r\n}\r\nstatic int asn1_str2tag(const char *tagstr, int len)\r\n{\r\nunsigned int i;\r\nstatic const struct tag_name_st *tntmp, tnst [] = {\r\nASN1_GEN_STR("BOOL", V_ASN1_BOOLEAN),\r\nASN1_GEN_STR("BOOLEAN", V_ASN1_BOOLEAN),\r\nASN1_GEN_STR("NULL", V_ASN1_NULL),\r\nASN1_GEN_STR("INT", V_ASN1_INTEGER),\r\nASN1_GEN_STR("INTEGER", V_ASN1_INTEGER),\r\nASN1_GEN_STR("ENUM", V_ASN1_ENUMERATED),\r\nASN1_GEN_STR("ENUMERATED", V_ASN1_ENUMERATED),\r\nASN1_GEN_STR("OID", V_ASN1_OBJECT),\r\nASN1_GEN_STR("OBJECT", V_ASN1_OBJECT),\r\nASN1_GEN_STR("UTCTIME", V_ASN1_UTCTIME),\r\nASN1_GEN_STR("UTC", V_ASN1_UTCTIME),\r\nASN1_GEN_STR("GENERALIZEDTIME", V_ASN1_GENERALIZEDTIME),\r\nASN1_GEN_STR("GENTIME", V_ASN1_GENERALIZEDTIME),\r\nASN1_GEN_STR("OCT", V_ASN1_OCTET_STRING),\r\nASN1_GEN_STR("OCTETSTRING", V_ASN1_OCTET_STRING),\r\nASN1_GEN_STR("BITSTR", V_ASN1_BIT_STRING),\r\nASN1_GEN_STR("BITSTRING", V_ASN1_BIT_STRING),\r\nASN1_GEN_STR("UNIVERSALSTRING", V_ASN1_UNIVERSALSTRING),\r\nASN1_GEN_STR("UNIV", V_ASN1_UNIVERSALSTRING),\r\nASN1_GEN_STR("IA5", V_ASN1_IA5STRING),\r\nASN1_GEN_STR("IA5STRING", V_ASN1_IA5STRING),\r\nASN1_GEN_STR("UTF8", V_ASN1_UTF8STRING),\r\nASN1_GEN_STR("UTF8String", V_ASN1_UTF8STRING),\r\nASN1_GEN_STR("BMP", V_ASN1_BMPSTRING),\r\nASN1_GEN_STR("BMPSTRING", V_ASN1_BMPSTRING),\r\nASN1_GEN_STR("VISIBLESTRING", V_ASN1_VISIBLESTRING),\r\nASN1_GEN_STR("VISIBLE", V_ASN1_VISIBLESTRING),\r\nASN1_GEN_STR("PRINTABLESTRING", V_ASN1_PRINTABLESTRING),\r\nASN1_GEN_STR("PRINTABLE", V_ASN1_PRINTABLESTRING),\r\nASN1_GEN_STR("T61", V_ASN1_T61STRING),\r\nASN1_GEN_STR("T61STRING", V_ASN1_T61STRING),\r\nASN1_GEN_STR("TELETEXSTRING", V_ASN1_T61STRING),\r\nASN1_GEN_STR("GeneralString", V_ASN1_GENERALSTRING),\r\nASN1_GEN_STR("GENSTR", V_ASN1_GENERALSTRING),\r\nASN1_GEN_STR("NUMERIC", V_ASN1_NUMERICSTRING),\r\nASN1_GEN_STR("NUMERICSTRING", V_ASN1_NUMERICSTRING),\r\nASN1_GEN_STR("SEQUENCE", V_ASN1_SEQUENCE),\r\nASN1_GEN_STR("SEQ", V_ASN1_SEQUENCE),\r\nASN1_GEN_STR("SET", V_ASN1_SET),\r\nASN1_GEN_STR("EXP", ASN1_GEN_FLAG_EXP),\r\nASN1_GEN_STR("EXPLICIT", ASN1_GEN_FLAG_EXP),\r\nASN1_GEN_STR("IMP", ASN1_GEN_FLAG_IMP),\r\nASN1_GEN_STR("IMPLICIT", ASN1_GEN_FLAG_IMP),\r\nASN1_GEN_STR("OCTWRAP", ASN1_GEN_FLAG_OCTWRAP),\r\nASN1_GEN_STR("SEQWRAP", ASN1_GEN_FLAG_SEQWRAP),\r\nASN1_GEN_STR("SETWRAP", ASN1_GEN_FLAG_SETWRAP),\r\nASN1_GEN_STR("BITWRAP", ASN1_GEN_FLAG_BITWRAP),\r\nASN1_GEN_STR("FORM", ASN1_GEN_FLAG_FORMAT),\r\nASN1_GEN_STR("FORMAT", ASN1_GEN_FLAG_FORMAT),\r\n};\r\nif (len == -1)\r\nlen = strlen(tagstr);\r\ntntmp = tnst;\r\nfor (i = 0; i < sizeof(tnst) / sizeof(struct tag_name_st); i++, tntmp++)\r\n{\r\nif ((len == tntmp->len) && !strncmp(tntmp->strnam, tagstr, len))\r\nreturn tntmp->tag;\r\n}\r\nreturn -1;\r\n}\r\nstatic ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)\r\n{\r\nASN1_TYPE *atmp = NULL;\r\nCONF_VALUE vtmp;\r\nunsigned char *rdata;\r\nlong rdlen;\r\nint no_unused = 1;\r\nif (!(atmp = ASN1_TYPE_new()))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\r\nreturn NULL;\r\n}\r\nif (!str)\r\nstr = "";\r\nswitch(utype)\r\n{\r\ncase V_ASN1_NULL:\r\nif (str && *str)\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_NULL_VALUE);\r\ngoto bad_form;\r\n}\r\nbreak;\r\ncase V_ASN1_BOOLEAN:\r\nif (format != ASN1_GEN_FORMAT_ASCII)\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_NOT_ASCII_FORMAT);\r\ngoto bad_form;\r\n}\r\nvtmp.name = NULL;\r\nvtmp.section = NULL;\r\nvtmp.value = (char *)str;\r\nif (!X509V3_get_value_bool(&vtmp, &atmp->value.boolean))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BOOLEAN);\r\ngoto bad_str;\r\n}\r\nbreak;\r\ncase V_ASN1_INTEGER:\r\ncase V_ASN1_ENUMERATED:\r\nif (format != ASN1_GEN_FORMAT_ASCII)\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_INTEGER_NOT_ASCII_FORMAT);\r\ngoto bad_form;\r\n}\r\nif (!(atmp->value.integer = s2i_ASN1_INTEGER(NULL, (char *)str)))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_INTEGER);\r\ngoto bad_str;\r\n}\r\nbreak;\r\ncase V_ASN1_OBJECT:\r\nif (format != ASN1_GEN_FORMAT_ASCII)\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_OBJECT_NOT_ASCII_FORMAT);\r\ngoto bad_form;\r\n}\r\nif (!(atmp->value.object = OBJ_txt2obj(str, 0)))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_OBJECT);\r\ngoto bad_str;\r\n}\r\nbreak;\r\ncase V_ASN1_UTCTIME:\r\ncase V_ASN1_GENERALIZEDTIME:\r\nif (format != ASN1_GEN_FORMAT_ASCII)\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_TIME_NOT_ASCII_FORMAT);\r\ngoto bad_form;\r\n}\r\nif (!(atmp->value.asn1_string = ASN1_STRING_new()))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\r\ngoto bad_str;\r\n}\r\nif (!ASN1_STRING_set(atmp->value.asn1_string, str, -1))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\r\ngoto bad_str;\r\n}\r\natmp->value.asn1_string->type = utype;\r\nif (!ASN1_TIME_check(atmp->value.asn1_string))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_TIME_VALUE);\r\ngoto bad_str;\r\n}\r\nbreak;\r\ncase V_ASN1_BMPSTRING:\r\ncase V_ASN1_PRINTABLESTRING:\r\ncase V_ASN1_IA5STRING:\r\ncase V_ASN1_T61STRING:\r\ncase V_ASN1_UTF8STRING:\r\ncase V_ASN1_VISIBLESTRING:\r\ncase V_ASN1_UNIVERSALSTRING:\r\ncase V_ASN1_GENERALSTRING:\r\ncase V_ASN1_NUMERICSTRING:\r\nif (format == ASN1_GEN_FORMAT_ASCII)\r\nformat = MBSTRING_ASC;\r\nelse if (format == ASN1_GEN_FORMAT_UTF8)\r\nformat = MBSTRING_UTF8;\r\nelse\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_FORMAT);\r\ngoto bad_form;\r\n}\r\nif (ASN1_mbstring_copy(&atmp->value.asn1_string, (unsigned char *)str,\r\n-1, format, ASN1_tag2bit(utype)) <= 0)\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\r\ngoto bad_str;\r\n}\r\nbreak;\r\ncase V_ASN1_BIT_STRING:\r\ncase V_ASN1_OCTET_STRING:\r\nif (!(atmp->value.asn1_string = ASN1_STRING_new()))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\r\ngoto bad_form;\r\n}\r\nif (format == ASN1_GEN_FORMAT_HEX)\r\n{\r\nif (!(rdata = string_to_hex((char *)str, &rdlen)))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_HEX);\r\ngoto bad_str;\r\n}\r\natmp->value.asn1_string->data = rdata;\r\natmp->value.asn1_string->length = rdlen;\r\natmp->value.asn1_string->type = utype;\r\n}\r\nelse if (format == ASN1_GEN_FORMAT_ASCII)\r\nASN1_STRING_set(atmp->value.asn1_string, str, -1);\r\nelse if ((format == ASN1_GEN_FORMAT_BITLIST) && (utype == V_ASN1_BIT_STRING))\r\n{\r\nif (!CONF_parse_list(str, ',', 1, bitstr_cb, atmp->value.bit_string))\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_LIST_ERROR);\r\ngoto bad_str;\r\n}\r\nno_unused = 0;\r\n}\r\nelse\r\n{\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BITSTRING_FORMAT);\r\ngoto bad_form;\r\n}\r\nif ((utype == V_ASN1_BIT_STRING) && no_unused)\r\n{\r\natmp->value.asn1_string->flags\r\n&= ~(ASN1_STRING_FLAG_BITS_LEFT|0x07);\r\natmp->value.asn1_string->flags\r\n|= ASN1_STRING_FLAG_BITS_LEFT;\r\n}\r\nbreak;\r\ndefault:\r\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_UNSUPPORTED_TYPE);\r\ngoto bad_str;\r\nbreak;\r\n}\r\natmp->type = utype;\r\nreturn atmp;\r\nbad_str:\r\nERR_add_error_data(2, "string=", str);\r\nbad_form:\r\nASN1_TYPE_free(atmp);\r\nreturn NULL;\r\n}\r\nstatic int bitstr_cb(const char *elem, int len, void *bitstr)\r\n{\r\nlong bitnum;\r\nchar *eptr;\r\nif (!elem)\r\nreturn 0;\r\nbitnum = strtoul(elem, &eptr, 10);\r\nif (eptr && *eptr && (eptr != elem + len))\r\nreturn 0;\r\nif (bitnum < 0)\r\n{\r\nASN1err(ASN1_F_BITSTR_CB, ASN1_R_INVALID_NUMBER);\r\nreturn 0;\r\n}\r\nif (!ASN1_BIT_STRING_set_bit(bitstr, bitnum, 1))\r\n{\r\nASN1err(ASN1_F_BITSTR_CB, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}
