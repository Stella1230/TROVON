static int crl_inf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\r\nvoid *exarg)\r\n{\r\nX509_CRL_INFO *a = (X509_CRL_INFO *)*pval;\r\nif(!a || !a->revoked) return 1;\r\nswitch(operation) {\r\ncase ASN1_OP_D2I_POST:\r\n(void)sk_X509_REVOKED_set_cmp_func(a->revoked,X509_REVOKED_cmp);\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nint crl_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\r\nvoid *exarg)\r\n{\r\nX509_CRL *crl = (X509_CRL *)*pval;\r\nSTACK_OF(X509_EXTENSION) *exts;\r\nX509_EXTENSION *ext;\r\nint idx;\r\nswitch(operation)\r\n{\r\ncase ASN1_OP_NEW_POST:\r\ncrl->idp = NULL;\r\ncrl->akid = NULL;\r\ncrl->flags = 0;\r\ncrl->idp_flags = 0;\r\ncrl->idp_reasons = CRLDP_ALL_REASONS;\r\ncrl->meth = default_crl_method;\r\ncrl->meth_data = NULL;\r\ncrl->issuers = NULL;\r\ncrl->crl_number = NULL;\r\ncrl->base_crl_number = NULL;\r\nbreak;\r\ncase ASN1_OP_D2I_POST:\r\n#ifndef OPENSSL_NO_SHA\r\nX509_CRL_digest(crl, EVP_sha1(), crl->sha1_hash, NULL);\r\n#endif\r\ncrl->idp = X509_CRL_get_ext_d2i(crl,\r\nNID_issuing_distribution_point, NULL, NULL);\r\nif (crl->idp)\r\nsetup_idp(crl, crl->idp);\r\ncrl->akid = X509_CRL_get_ext_d2i(crl,\r\nNID_authority_key_identifier, NULL, NULL);\r\ncrl->crl_number = X509_CRL_get_ext_d2i(crl,\r\nNID_crl_number, NULL, NULL);\r\ncrl->base_crl_number = X509_CRL_get_ext_d2i(crl,\r\nNID_delta_crl, NULL, NULL);\r\nif (crl->base_crl_number && !crl->crl_number)\r\ncrl->flags |= EXFLAG_INVALID;\r\nexts = crl->crl->extensions;\r\nfor (idx = 0; idx < sk_X509_EXTENSION_num(exts); idx++)\r\n{\r\nint nid;\r\next = sk_X509_EXTENSION_value(exts, idx);\r\nnid = OBJ_obj2nid(ext->object);\r\nif (nid == NID_freshest_crl)\r\ncrl->flags |= EXFLAG_FRESHEST;\r\nif (ext->critical > 0)\r\n{\r\nif ((nid == NID_issuing_distribution_point)\r\n|| (nid == NID_delta_crl))\r\nbreak;;\r\ncrl->flags |= EXFLAG_CRITICAL;\r\nbreak;\r\n}\r\n}\r\nif (!crl_set_issuers(crl))\r\nreturn 0;\r\nif (crl->meth->crl_init)\r\n{\r\nif (crl->meth->crl_init(crl) == 0)\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ASN1_OP_FREE_POST:\r\nif (crl->meth->crl_free)\r\n{\r\nif (!crl->meth->crl_free(crl))\r\nreturn 0;\r\n}\r\nif (crl->akid)\r\nAUTHORITY_KEYID_free(crl->akid);\r\nif (crl->idp)\r\nISSUING_DIST_POINT_free(crl->idp);\r\nASN1_INTEGER_free(crl->crl_number);\r\nASN1_INTEGER_free(crl->base_crl_number);\r\nsk_GENERAL_NAMES_pop_free(crl->issuers, GENERAL_NAMES_free);\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic void setup_idp(X509_CRL *crl, ISSUING_DIST_POINT *idp)\r\n{\r\nint idp_only = 0;\r\ncrl->idp_flags |= IDP_PRESENT;\r\nif (idp->onlyuser > 0)\r\n{\r\nidp_only++;\r\ncrl->idp_flags |= IDP_ONLYUSER;\r\n}\r\nif (idp->onlyCA > 0)\r\n{\r\nidp_only++;\r\ncrl->idp_flags |= IDP_ONLYCA;\r\n}\r\nif (idp->onlyattr > 0)\r\n{\r\nidp_only++;\r\ncrl->idp_flags |= IDP_ONLYATTR;\r\n}\r\nif (idp_only > 1)\r\ncrl->idp_flags |= IDP_INVALID;\r\nif (idp->indirectCRL > 0)\r\ncrl->idp_flags |= IDP_INDIRECT;\r\nif (idp->onlysomereasons)\r\n{\r\ncrl->idp_flags |= IDP_REASONS;\r\nif (idp->onlysomereasons->length > 0)\r\ncrl->idp_reasons = idp->onlysomereasons->data[0];\r\nif (idp->onlysomereasons->length > 1)\r\ncrl->idp_reasons |=\r\n(idp->onlysomereasons->data[1] << 8);\r\ncrl->idp_reasons &= CRLDP_ALL_REASONS;\r\n}\r\nDIST_POINT_set_dpname(idp->distpoint, X509_CRL_get_issuer(crl));\r\n}\r\nint X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev)\r\n{\r\nX509_CRL_INFO *inf;\r\ninf = crl->crl;\r\nif(!inf->revoked)\r\ninf->revoked = sk_X509_REVOKED_new(X509_REVOKED_cmp);\r\nif(!inf->revoked || !sk_X509_REVOKED_push(inf->revoked, rev)) {\r\nASN1err(ASN1_F_X509_CRL_ADD0_REVOKED, ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\ninf->enc.modified = 1;\r\nreturn 1;\r\n}\r\nint X509_CRL_verify(X509_CRL *crl, EVP_PKEY *r)\r\n{\r\nif (crl->meth->crl_verify)\r\nreturn crl->meth->crl_verify(crl, r);\r\nreturn 0;\r\n}\r\nint X509_CRL_get0_by_serial(X509_CRL *crl,\r\nX509_REVOKED **ret, ASN1_INTEGER *serial)\r\n{\r\nif (crl->meth->crl_lookup)\r\nreturn crl->meth->crl_lookup(crl, ret, serial, NULL);\r\nreturn 0;\r\n}\r\nint X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **ret, X509 *x)\r\n{\r\nif (crl->meth->crl_lookup)\r\nreturn crl->meth->crl_lookup(crl, ret,\r\nX509_get_serialNumber(x),\r\nX509_get_issuer_name(x));\r\nreturn 0;\r\n}\r\nstatic int def_crl_verify(X509_CRL *crl, EVP_PKEY *r)\r\n{\r\nreturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CRL_INFO),\r\ncrl->sig_alg, crl->signature,crl->crl,r));\r\n}\r\nstatic int crl_revoked_issuer_match(X509_CRL *crl, X509_NAME *nm,\r\nX509_REVOKED *rev)\r\n{\r\nint i;\r\nif (!rev->issuer)\r\n{\r\nif (!nm)\r\nreturn 1;\r\nif (!X509_NAME_cmp(nm, X509_CRL_get_issuer(crl)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nif (!nm)\r\nnm = X509_CRL_get_issuer(crl);\r\nfor (i = 0; i < sk_GENERAL_NAME_num(rev->issuer); i++)\r\n{\r\nGENERAL_NAME *gen = sk_GENERAL_NAME_value(rev->issuer, i);\r\nif (gen->type != GEN_DIRNAME)\r\ncontinue;\r\nif (!X509_NAME_cmp(nm, gen->d.directoryName))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int def_crl_lookup(X509_CRL *crl,\r\nX509_REVOKED **ret, ASN1_INTEGER *serial, X509_NAME *issuer)\r\n{\r\nX509_REVOKED rtmp, *rev;\r\nint idx;\r\nrtmp.serialNumber = serial;\r\nif (!sk_X509_REVOKED_is_sorted(crl->crl->revoked))\r\n{\r\nCRYPTO_w_lock(CRYPTO_LOCK_X509_CRL);\r\nsk_X509_REVOKED_sort(crl->crl->revoked);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_CRL);\r\n}\r\nidx = sk_X509_REVOKED_find(crl->crl->revoked, &rtmp);\r\nif(idx < 0)\r\nreturn 0;\r\nfor(;idx < sk_X509_REVOKED_num(crl->crl->revoked); idx++)\r\n{\r\nrev = sk_X509_REVOKED_value(crl->crl->revoked, idx);\r\nif (ASN1_INTEGER_cmp(rev->serialNumber, serial))\r\nreturn 0;\r\nif (crl_revoked_issuer_match(crl, issuer, rev))\r\n{\r\nif (ret)\r\n*ret = rev;\r\nif (rev->reason == CRL_REASON_REMOVE_FROM_CRL)\r\nreturn 2;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid X509_CRL_set_default_method(const X509_CRL_METHOD *meth)\r\n{\r\nif (meth == NULL)\r\ndefault_crl_method = &int_crl_meth;\r\nelse\r\ndefault_crl_method = meth;\r\n}\r\nX509_CRL_METHOD *X509_CRL_METHOD_new(\r\nint (*crl_init)(X509_CRL *crl),\r\nint (*crl_free)(X509_CRL *crl),\r\nint (*crl_lookup)(X509_CRL *crl, X509_REVOKED **ret,\r\nASN1_INTEGER *ser, X509_NAME *issuer),\r\nint (*crl_verify)(X509_CRL *crl, EVP_PKEY *pk))\r\n{\r\nX509_CRL_METHOD *m;\r\nm = OPENSSL_malloc(sizeof(X509_CRL_METHOD));\r\nif (!m)\r\nreturn NULL;\r\nm->crl_init = crl_init;\r\nm->crl_free = crl_free;\r\nm->crl_lookup = crl_lookup;\r\nm->crl_verify = crl_verify;\r\nm->flags = X509_CRL_METHOD_DYNAMIC;\r\nreturn m;\r\n}\r\nvoid X509_CRL_METHOD_free(X509_CRL_METHOD *m)\r\n{\r\nif (!(m->flags & X509_CRL_METHOD_DYNAMIC))\r\nreturn;\r\nOPENSSL_free(m);\r\n}\r\nvoid X509_CRL_set_meth_data(X509_CRL *crl, void *dat)\r\n{\r\ncrl->meth_data = dat;\r\n}\r\nvoid *X509_CRL_get_meth_data(X509_CRL *crl)\r\n{\r\nreturn crl->meth_data;\r\n}
