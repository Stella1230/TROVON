static const SSL_METHOD *ssl2_get_client_method(int ver)\r\n{\r\nif (ver == SSL2_VERSION)\r\nreturn(SSLv2_client_method());\r\nelse\r\nreturn(NULL);\r\n}\r\nint ssl2_connect(SSL *s)\r\n{\r\nunsigned long l=(unsigned long)time(NULL);\r\nBUF_MEM *buf=NULL;\r\nint ret= -1;\r\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\r\nint new_state,state;\r\nRAND_add(&l,sizeof(l),0);\r\nERR_clear_error();\r\nclear_sys_error();\r\nif (s->info_callback != NULL)\r\ncb=s->info_callback;\r\nelse if (s->ctx->info_callback != NULL)\r\ncb=s->ctx->info_callback;\r\ns->in_handshake++;\r\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\r\nfor (;;)\r\n{\r\nstate=s->state;\r\nswitch (s->state)\r\n{\r\ncase SSL_ST_BEFORE:\r\ncase SSL_ST_CONNECT:\r\ncase SSL_ST_BEFORE|SSL_ST_CONNECT:\r\ncase SSL_ST_OK|SSL_ST_CONNECT:\r\ns->server=0;\r\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\r\ns->version=SSL2_VERSION;\r\ns->type=SSL_ST_CONNECT;\r\nbuf=s->init_buf;\r\nif ((buf == NULL) && ((buf=BUF_MEM_new()) == NULL))\r\n{\r\nret= -1;\r\ngoto end;\r\n}\r\nif (!BUF_MEM_grow(buf,\r\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\r\n{\r\nif (buf == s->init_buf)\r\nbuf=NULL;\r\nret= -1;\r\ngoto end;\r\n}\r\ns->init_buf=buf;\r\nbuf=NULL;\r\ns->init_num=0;\r\ns->state=SSL2_ST_SEND_CLIENT_HELLO_A;\r\ns->ctx->stats.sess_connect++;\r\ns->handshake_func=ssl2_connect;\r\nBREAK;\r\ncase SSL2_ST_SEND_CLIENT_HELLO_A:\r\ncase SSL2_ST_SEND_CLIENT_HELLO_B:\r\ns->shutdown=0;\r\nret=client_hello(s);\r\nif (ret <= 0) goto end;\r\ns->init_num=0;\r\ns->state=SSL2_ST_GET_SERVER_HELLO_A;\r\nBREAK;\r\ncase SSL2_ST_GET_SERVER_HELLO_A:\r\ncase SSL2_ST_GET_SERVER_HELLO_B:\r\nret=get_server_hello(s);\r\nif (ret <= 0) goto end;\r\ns->init_num=0;\r\nif (!s->hit)\r\n{\r\ns->state=SSL2_ST_SEND_CLIENT_MASTER_KEY_A;\r\nBREAK;\r\n}\r\nelse\r\n{\r\ns->state=SSL2_ST_CLIENT_START_ENCRYPTION;\r\nbreak;\r\n}\r\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A:\r\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B:\r\nret=client_master_key(s);\r\nif (ret <= 0) goto end;\r\ns->init_num=0;\r\ns->state=SSL2_ST_CLIENT_START_ENCRYPTION;\r\nbreak;\r\ncase SSL2_ST_CLIENT_START_ENCRYPTION:\r\nif (!ssl2_enc_init(s,1))\r\n{\r\nret= -1;\r\ngoto end;\r\n}\r\ns->s2->clear_text=0;\r\ns->state=SSL2_ST_SEND_CLIENT_FINISHED_A;\r\nbreak;\r\ncase SSL2_ST_SEND_CLIENT_FINISHED_A:\r\ncase SSL2_ST_SEND_CLIENT_FINISHED_B:\r\nret=client_finished(s);\r\nif (ret <= 0) goto end;\r\ns->init_num=0;\r\ns->state=SSL2_ST_GET_SERVER_VERIFY_A;\r\nbreak;\r\ncase SSL2_ST_GET_SERVER_VERIFY_A:\r\ncase SSL2_ST_GET_SERVER_VERIFY_B:\r\nret=get_server_verify(s);\r\nif (ret <= 0) goto end;\r\ns->init_num=0;\r\ns->state=SSL2_ST_GET_SERVER_FINISHED_A;\r\nbreak;\r\ncase SSL2_ST_GET_SERVER_FINISHED_A:\r\ncase SSL2_ST_GET_SERVER_FINISHED_B:\r\nret=get_server_finished(s);\r\nif (ret <= 0) goto end;\r\nbreak;\r\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A:\r\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B:\r\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C:\r\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D:\r\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE:\r\nret=client_certificate(s);\r\nif (ret <= 0) goto end;\r\ns->init_num=0;\r\ns->state=SSL2_ST_GET_SERVER_FINISHED_A;\r\nbreak;\r\ncase SSL_ST_OK:\r\nif (s->init_buf != NULL)\r\n{\r\nBUF_MEM_free(s->init_buf);\r\ns->init_buf=NULL;\r\n}\r\ns->init_num=0;\r\nssl_update_cache(s,SSL_SESS_CACHE_CLIENT);\r\nif (s->hit) s->ctx->stats.sess_hit++;\r\nret=1;\r\ns->ctx->stats.sess_connect_good++;\r\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\r\ngoto end;\r\ndefault:\r\nSSLerr(SSL_F_SSL2_CONNECT,SSL_R_UNKNOWN_STATE);\r\nreturn(-1);\r\n}\r\nif ((cb != NULL) && (s->state != state))\r\n{\r\nnew_state=s->state;\r\ns->state=state;\r\ncb(s,SSL_CB_CONNECT_LOOP,1);\r\ns->state=new_state;\r\n}\r\n}\r\nend:\r\ns->in_handshake--;\r\nif (buf != NULL)\r\nBUF_MEM_free(buf);\r\nif (cb != NULL)\r\ncb(s,SSL_CB_CONNECT_EXIT,ret);\r\nreturn(ret);\r\n}\r\nstatic int get_server_hello(SSL *s)\r\n{\r\nunsigned char *buf;\r\nunsigned char *p;\r\nint i,j;\r\nunsigned long len;\r\nSTACK_OF(SSL_CIPHER) *sk=NULL,*cl, *prio, *allow;\r\nbuf=(unsigned char *)s->init_buf->data;\r\np=buf;\r\nif (s->state == SSL2_ST_GET_SERVER_HELLO_A)\r\n{\r\ni=ssl2_read(s,(char *)&(buf[s->init_num]),11-s->init_num);\r\nif (i < (11-s->init_num))\r\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_HELLO,i));\r\ns->init_num = 11;\r\nif (*(p++) != SSL2_MT_SERVER_HELLO)\r\n{\r\nif (p[-1] != SSL2_MT_ERROR)\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_GET_SERVER_HELLO,\r\nSSL_R_READ_WRONG_PACKET_TYPE);\r\n}\r\nelse\r\nSSLerr(SSL_F_GET_SERVER_HELLO,\r\nSSL_R_PEER_ERROR);\r\nreturn(-1);\r\n}\r\n#ifdef __APPLE_CC__\r\ns->hit=(i=*(p++))?1:0;\r\n#else\r\ns->hit=(*(p++))?1:0;\r\n#endif\r\ns->s2->tmp.cert_type= *(p++);\r\nn2s(p,i);\r\nif (i < s->version) s->version=i;\r\nn2s(p,i); s->s2->tmp.cert_length=i;\r\nn2s(p,i); s->s2->tmp.csl=i;\r\nn2s(p,i); s->s2->tmp.conn_id_length=i;\r\ns->state=SSL2_ST_GET_SERVER_HELLO_B;\r\n}\r\nlen = 11 + (unsigned long)s->s2->tmp.cert_length + (unsigned long)s->s2->tmp.csl + (unsigned long)s->s2->tmp.conn_id_length;\r\nif (len > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)\r\n{\r\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_MESSAGE_TOO_LONG);\r\nreturn -1;\r\n}\r\nj = (int)len - s->init_num;\r\ni = ssl2_read(s,(char *)&(buf[s->init_num]),j);\r\nif (i != j) return(ssl2_part_read(s,SSL_F_GET_SERVER_HELLO,i));\r\nif (s->msg_callback)\r\ns->msg_callback(0, s->version, 0, buf, (size_t)len, s, s->msg_callback_arg);\r\np = buf + 11;\r\nif (s->hit)\r\n{\r\nif (s->s2->tmp.cert_length != 0)\r\n{\r\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CERT_LENGTH_NOT_ZERO);\r\nreturn(-1);\r\n}\r\nif (s->s2->tmp.cert_type != 0)\r\n{\r\nif (!(s->options &\r\nSSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG))\r\n{\r\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CERT_TYPE_NOT_ZERO);\r\nreturn(-1);\r\n}\r\n}\r\nif (s->s2->tmp.csl != 0)\r\n{\r\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_REUSE_CIPHER_LIST_NOT_ZERO);\r\nreturn(-1);\r\n}\r\n}\r\nelse\r\n{\r\n#ifdef undef\r\nmemset(s->session->session_id,0,\r\nSSL_MAX_SSL_SESSION_ID_LENGTH_IN_BYTES);\r\ns->session->session_id_length=0;\r\n*/\r\n#endif\r\nif (s->session->session_id_length > 0)\r\n{\r\nif (!ssl_get_new_session(s,0))\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nreturn(-1);\r\n}\r\n}\r\nif (ssl2_set_certificate(s,s->s2->tmp.cert_type,\r\ns->s2->tmp.cert_length,p) <= 0)\r\n{\r\nssl2_return_error(s,SSL2_PE_BAD_CERTIFICATE);\r\nreturn(-1);\r\n}\r\np+=s->s2->tmp.cert_length;\r\nif (s->s2->tmp.csl == 0)\r\n{\r\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\r\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_NO_CIPHER_LIST);\r\nreturn(-1);\r\n}\r\nsk=ssl_bytes_to_cipher_list(s,p,s->s2->tmp.csl,\r\n&s->session->ciphers);\r\np+=s->s2->tmp.csl;\r\nif (sk == NULL)\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_GET_SERVER_HELLO,ERR_R_MALLOC_FAILURE);\r\nreturn(-1);\r\n}\r\n(void)sk_SSL_CIPHER_set_cmp_func(sk,ssl_cipher_ptr_id_cmp);\r\ncl=SSL_get_ciphers(s);\r\n(void)sk_SSL_CIPHER_set_cmp_func(cl,ssl_cipher_ptr_id_cmp);\r\nif (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE)\r\n{\r\nprio = sk;\r\nallow = cl;\r\n}\r\nelse\r\n{\r\nprio = cl;\r\nallow = sk;\r\n}\r\nfor (i=0; i<sk_SSL_CIPHER_num(prio); i++)\r\n{\r\nif (sk_SSL_CIPHER_find(allow,\r\nsk_SSL_CIPHER_value(prio,i)) >= 0)\r\nbreak;\r\n}\r\nif (i >= sk_SSL_CIPHER_num(prio))\r\n{\r\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\r\nSSLerr(SSL_F_GET_SERVER_HELLO,SSL_R_NO_CIPHER_MATCH);\r\nreturn(-1);\r\n}\r\ns->session->cipher=sk_SSL_CIPHER_value(prio,i);\r\nif (s->session->peer != NULL)\r\n{\r\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\r\nreturn(-1);\r\n}\r\ns->session->peer = s->session->sess_cert->peer_key->x509;\r\nCRYPTO_add(&s->session->peer->references, 1, CRYPTO_LOCK_X509);\r\n}\r\nif (s->session->sess_cert == NULL\r\n|| s->session->peer != s->session->sess_cert->peer_key->x509)\r\n{\r\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\r\nreturn(-1);\r\n}\r\ns->s2->conn_id_length=s->s2->tmp.conn_id_length;\r\nif (s->s2->conn_id_length > sizeof s->s2->conn_id)\r\n{\r\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_GET_SERVER_HELLO, SSL_R_SSL2_CONNECTION_ID_TOO_LONG);\r\nreturn -1;\r\n}\r\nmemcpy(s->s2->conn_id,p,s->s2->tmp.conn_id_length);\r\nreturn(1);\r\n}\r\nstatic int client_hello(SSL *s)\r\n{\r\nunsigned char *buf;\r\nunsigned char *p,*d;\r\nint i,n,j;\r\nbuf=(unsigned char *)s->init_buf->data;\r\nif (s->state == SSL2_ST_SEND_CLIENT_HELLO_A)\r\n{\r\nif ((s->session == NULL) ||\r\n(s->session->ssl_version != s->version))\r\n{\r\nif (!ssl_get_new_session(s,0))\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nreturn(-1);\r\n}\r\n}\r\np=buf;\r\nd=p+9;\r\n*(p++)=SSL2_MT_CLIENT_HELLO;\r\ns2n(SSL2_VERSION,p);\r\nn=j=0;\r\nn=ssl_cipher_list_to_bytes(s,SSL_get_ciphers(s),d,0);\r\nd+=n;\r\nif (n == 0)\r\n{\r\nSSLerr(SSL_F_CLIENT_HELLO,SSL_R_NO_CIPHERS_AVAILABLE);\r\nreturn(-1);\r\n}\r\ns2n(n,p);\r\nif ((s->session->session_id_length > 0) &&\r\n(s->session->session_id_length <=\r\nSSL2_MAX_SSL_SESSION_ID_LENGTH))\r\n{\r\ni=s->session->session_id_length;\r\ns2n(i,p);\r\nmemcpy(d,s->session->session_id,(unsigned int)i);\r\nd+=i;\r\n}\r\nelse\r\n{\r\ns2n(0,p);\r\n}\r\ns->s2->challenge_length=SSL2_CHALLENGE_LENGTH;\r\ns2n(SSL2_CHALLENGE_LENGTH,p);\r\nif (RAND_pseudo_bytes(s->s2->challenge,SSL2_CHALLENGE_LENGTH) <= 0)\r\nreturn -1;\r\nmemcpy(d,s->s2->challenge,SSL2_CHALLENGE_LENGTH);\r\nd+=SSL2_CHALLENGE_LENGTH;\r\ns->state=SSL2_ST_SEND_CLIENT_HELLO_B;\r\ns->init_num=d-buf;\r\ns->init_off=0;\r\n}\r\nreturn(ssl2_do_write(s));\r\n}\r\nstatic int client_master_key(SSL *s)\r\n{\r\nunsigned char *buf;\r\nunsigned char *p,*d;\r\nint clear,enc,karg,i;\r\nSSL_SESSION *sess;\r\nconst EVP_CIPHER *c;\r\nconst EVP_MD *md;\r\nbuf=(unsigned char *)s->init_buf->data;\r\nif (s->state == SSL2_ST_SEND_CLIENT_MASTER_KEY_A)\r\n{\r\nif (!ssl_cipher_get_evp(s->session,&c,&md,NULL,NULL,NULL))\r\n{\r\nssl2_return_error(s,SSL2_PE_NO_CIPHER);\r\nSSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS);\r\nreturn(-1);\r\n}\r\nsess=s->session;\r\np=buf;\r\nd=p+10;\r\n*(p++)=SSL2_MT_CLIENT_MASTER_KEY;\r\ni=ssl_put_cipher_by_char(s,sess->cipher,p);\r\np+=i;\r\ni=EVP_CIPHER_iv_length(c);\r\nsess->key_arg_length=i;\r\nif (i > SSL_MAX_KEY_ARG_LENGTH)\r\n{\r\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\r\nreturn -1;\r\n}\r\nif (i > 0)\r\nif (RAND_pseudo_bytes(sess->key_arg,i) <= 0)\r\nreturn -1;\r\ni=EVP_CIPHER_key_length(c);\r\nsess->master_key_length=i;\r\nif (i > 0)\r\n{\r\nif (i > (int)sizeof(sess->master_key))\r\n{\r\nssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\r\nreturn -1;\r\n}\r\nif (RAND_bytes(sess->master_key,i) <= 0)\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nreturn(-1);\r\n}\r\n}\r\nif (sess->cipher->algorithm2 & SSL2_CF_8_BYTE_ENC)\r\nenc=8;\r\nelse if (SSL_C_IS_EXPORT(sess->cipher))\r\nenc=5;\r\nelse\r\nenc=i;\r\nif ((int)i < enc)\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_CIPHER_TABLE_SRC_ERROR);\r\nreturn(-1);\r\n}\r\nclear=i-enc;\r\ns2n(clear,p);\r\nmemcpy(d,sess->master_key,(unsigned int)clear);\r\nd+=clear;\r\nenc=ssl_rsa_public_encrypt(sess->sess_cert,enc,\r\n&(sess->master_key[clear]),d,\r\n(s->s2->ssl2_rollback)?RSA_SSLV23_PADDING:RSA_PKCS1_PADDING);\r\nif (enc <= 0)\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_CLIENT_MASTER_KEY,SSL_R_PUBLIC_KEY_ENCRYPT_ERROR);\r\nreturn(-1);\r\n}\r\n#ifdef PKCS1_CHECK\r\nif (s->options & SSL_OP_PKCS1_CHECK_1) d[1]++;\r\nif (s->options & SSL_OP_PKCS1_CHECK_2)\r\nsess->master_key[clear]++;\r\n#endif\r\ns2n(enc,p);\r\nd+=enc;\r\nkarg=sess->key_arg_length;\r\ns2n(karg,p);\r\nif (karg > (int)sizeof(sess->key_arg))\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_CLIENT_MASTER_KEY, ERR_R_INTERNAL_ERROR);\r\nreturn -1;\r\n}\r\nmemcpy(d,sess->key_arg,(unsigned int)karg);\r\nd+=karg;\r\ns->state=SSL2_ST_SEND_CLIENT_MASTER_KEY_B;\r\ns->init_num=d-buf;\r\ns->init_off=0;\r\n}\r\nreturn(ssl2_do_write(s));\r\n}\r\nstatic int client_finished(SSL *s)\r\n{\r\nunsigned char *p;\r\nif (s->state == SSL2_ST_SEND_CLIENT_FINISHED_A)\r\n{\r\np=(unsigned char *)s->init_buf->data;\r\n*(p++)=SSL2_MT_CLIENT_FINISHED;\r\nif (s->s2->conn_id_length > sizeof s->s2->conn_id)\r\n{\r\nSSLerr(SSL_F_CLIENT_FINISHED, ERR_R_INTERNAL_ERROR);\r\nreturn -1;\r\n}\r\nmemcpy(p,s->s2->conn_id,(unsigned int)s->s2->conn_id_length);\r\ns->state=SSL2_ST_SEND_CLIENT_FINISHED_B;\r\ns->init_num=s->s2->conn_id_length+1;\r\ns->init_off=0;\r\n}\r\nreturn(ssl2_do_write(s));\r\n}\r\nstatic int client_certificate(SSL *s)\r\n{\r\nunsigned char *buf;\r\nunsigned char *p,*d;\r\nint i;\r\nunsigned int n;\r\nint cert_ch_len;\r\nunsigned char *cert_ch;\r\nbuf=(unsigned char *)s->init_buf->data;\r\nif (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_A)\r\n{\r\ni=ssl2_read(s,(char *)&(buf[s->init_num]),\r\nSSL2_MAX_CERT_CHALLENGE_LENGTH+2-s->init_num);\r\nif (i<(SSL2_MIN_CERT_CHALLENGE_LENGTH+2-s->init_num))\r\nreturn(ssl2_part_read(s,SSL_F_CLIENT_CERTIFICATE,i));\r\ns->init_num += i;\r\nif (s->msg_callback)\r\ns->msg_callback(0, s->version, 0, buf, (size_t)s->init_num, s, s->msg_callback_arg);\r\nif (buf[1] != SSL2_AT_MD5_WITH_RSA_ENCRYPTION)\r\n{\r\nssl2_return_error(s,SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE);\r\nSSLerr(SSL_F_CLIENT_CERTIFICATE,SSL_R_BAD_AUTHENTICATION_TYPE);\r\nreturn(-1);\r\n}\r\nif ((s->cert == NULL) ||\r\n(s->cert->key->x509 == NULL) ||\r\n(s->cert->key->privatekey == NULL))\r\n{\r\ns->state=SSL2_ST_X509_GET_CLIENT_CERTIFICATE;\r\n}\r\nelse\r\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_C;\r\n}\r\ncert_ch = buf + 2;\r\ncert_ch_len = s->init_num - 2;\r\nif (s->state == SSL2_ST_X509_GET_CLIENT_CERTIFICATE)\r\n{\r\nX509 *x509=NULL;\r\nEVP_PKEY *pkey=NULL;\r\ni=0;\r\nif (s->ctx->client_cert_cb != NULL)\r\n{\r\ni=s->ctx->client_cert_cb(s,&(x509),&(pkey));\r\n}\r\nif (i < 0)\r\n{\r\ns->rwstate=SSL_X509_LOOKUP;\r\nreturn(-1);\r\n}\r\ns->rwstate=SSL_NOTHING;\r\nif ((i == 1) && (pkey != NULL) && (x509 != NULL))\r\n{\r\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_C;\r\nif ( !SSL_use_certificate(s,x509) ||\r\n!SSL_use_PrivateKey(s,pkey))\r\n{\r\ni=0;\r\n}\r\nX509_free(x509);\r\nEVP_PKEY_free(pkey);\r\n}\r\nelse if (i == 1)\r\n{\r\nif (x509 != NULL) X509_free(x509);\r\nif (pkey != NULL) EVP_PKEY_free(pkey);\r\nSSLerr(SSL_F_CLIENT_CERTIFICATE,SSL_R_BAD_DATA_RETURNED_BY_CALLBACK);\r\ni=0;\r\n}\r\nif (i == 0)\r\n{\r\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_B;\r\np=buf;\r\n*(p++)=SSL2_MT_ERROR;\r\ns2n(SSL2_PE_NO_CERTIFICATE,p);\r\ns->init_off=0;\r\ns->init_num=3;\r\n}\r\n}\r\nif (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_B)\r\n{\r\nreturn(ssl2_do_write(s));\r\n}\r\nif (s->state == SSL2_ST_SEND_CLIENT_CERTIFICATE_C)\r\n{\r\nEVP_MD_CTX ctx;\r\np=buf;\r\nEVP_MD_CTX_init(&ctx);\r\nEVP_SignInit_ex(&ctx,s->ctx->rsa_md5, NULL);\r\nEVP_SignUpdate(&ctx,s->s2->key_material,\r\ns->s2->key_material_length);\r\nEVP_SignUpdate(&ctx,cert_ch,(unsigned int)cert_ch_len);\r\ni=i2d_X509(s->session->sess_cert->peer_key->x509,&p);\r\nif(i > 0)\r\nEVP_SignUpdate(&ctx,buf,(unsigned int)i);\r\np=buf;\r\nd=p+6;\r\n*(p++)=SSL2_MT_CLIENT_CERTIFICATE;\r\n*(p++)=SSL2_CT_X509_CERTIFICATE;\r\nn=i2d_X509(s->cert->key->x509,&d);\r\ns2n(n,p);\r\nif (!EVP_SignFinal(&ctx,d,&n,s->cert->key->privatekey))\r\n{\r\n}\r\nEVP_MD_CTX_cleanup(&ctx);\r\ns2n(n,p);\r\nd+=n;\r\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_D;\r\ns->init_num=d-buf;\r\ns->init_off=0;\r\n}\r\nreturn(ssl2_do_write(s));\r\n}\r\nstatic int get_server_verify(SSL *s)\r\n{\r\nunsigned char *p;\r\nint i, n, len;\r\np=(unsigned char *)s->init_buf->data;\r\nif (s->state == SSL2_ST_GET_SERVER_VERIFY_A)\r\n{\r\ni=ssl2_read(s,(char *)&(p[s->init_num]),1-s->init_num);\r\nif (i < (1-s->init_num))\r\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i));\r\ns->init_num += i;\r\ns->state= SSL2_ST_GET_SERVER_VERIFY_B;\r\nif (*p != SSL2_MT_SERVER_VERIFY)\r\n{\r\nif (p[0] != SSL2_MT_ERROR)\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_GET_SERVER_VERIFY,\r\nSSL_R_READ_WRONG_PACKET_TYPE);\r\n}\r\nelse\r\n{\r\nSSLerr(SSL_F_GET_SERVER_VERIFY,SSL_R_PEER_ERROR);\r\ni=ssl2_read(s,(char *)&(p[s->init_num]),3-s->init_num);\r\nreturn ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i);\r\n}\r\nreturn(-1);\r\n}\r\n}\r\np=(unsigned char *)s->init_buf->data;\r\nlen = 1 + s->s2->challenge_length;\r\nn = len - s->init_num;\r\ni = ssl2_read(s,(char *)&(p[s->init_num]),n);\r\nif (i < n)\r\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i));\r\nif (s->msg_callback)\r\ns->msg_callback(0, s->version, 0, p, len, s, s->msg_callback_arg);\r\np += 1;\r\nif (memcmp(p,s->s2->challenge,s->s2->challenge_length) != 0)\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_GET_SERVER_VERIFY,SSL_R_CHALLENGE_IS_DIFFERENT);\r\nreturn(-1);\r\n}\r\nreturn(1);\r\n}\r\nstatic int get_server_finished(SSL *s)\r\n{\r\nunsigned char *buf;\r\nunsigned char *p;\r\nint i, n, len;\r\nbuf=(unsigned char *)s->init_buf->data;\r\np=buf;\r\nif (s->state == SSL2_ST_GET_SERVER_FINISHED_A)\r\n{\r\ni=ssl2_read(s,(char *)&(buf[s->init_num]),1-s->init_num);\r\nif (i < (1-s->init_num))\r\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_FINISHED,i));\r\ns->init_num += i;\r\nif (*p == SSL2_MT_REQUEST_CERTIFICATE)\r\n{\r\ns->state=SSL2_ST_SEND_CLIENT_CERTIFICATE_A;\r\nreturn(1);\r\n}\r\nelse if (*p != SSL2_MT_SERVER_FINISHED)\r\n{\r\nif (p[0] != SSL2_MT_ERROR)\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_READ_WRONG_PACKET_TYPE);\r\n}\r\nelse\r\n{\r\nSSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_PEER_ERROR);\r\ni=ssl2_read(s,(char *)&(p[s->init_num]),3-s->init_num);\r\nreturn ssl2_part_read(s,SSL_F_GET_SERVER_VERIFY,i);\r\n}\r\nreturn(-1);\r\n}\r\ns->state=SSL2_ST_GET_SERVER_FINISHED_B;\r\n}\r\nlen = 1 + SSL2_SSL_SESSION_ID_LENGTH;\r\nn = len - s->init_num;\r\ni = ssl2_read(s,(char *)&(buf[s->init_num]), n);\r\nif (i < n)\r\nreturn(ssl2_part_read(s,SSL_F_GET_SERVER_FINISHED,i));\r\ns->init_num += i;\r\nif (s->msg_callback)\r\ns->msg_callback(0, s->version, 0, buf, (size_t)s->init_num, s, s->msg_callback_arg);\r\nif (!s->hit)\r\n{\r\ns->session->session_id_length=SSL2_SSL_SESSION_ID_LENGTH;\r\nmemcpy(s->session->session_id,p+1,SSL2_SSL_SESSION_ID_LENGTH);\r\n}\r\nelse\r\n{\r\nif (!(s->options & SSL_OP_MICROSOFT_SESS_ID_BUG))\r\n{\r\nif ((s->session->session_id_length > sizeof s->session->session_id)\r\n|| (0 != memcmp(buf + 1, s->session->session_id,\r\n(unsigned int)s->session->session_id_length)))\r\n{\r\nssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\r\nSSLerr(SSL_F_GET_SERVER_FINISHED,SSL_R_SSL_SESSION_ID_IS_DIFFERENT);\r\nreturn(-1);\r\n}\r\n}\r\n}\r\ns->state = SSL_ST_OK;\r\nreturn(1);\r\n}\r\nint ssl2_set_certificate(SSL *s, int type, int len, const unsigned char *data)\r\n{\r\nSTACK_OF(X509) *sk=NULL;\r\nEVP_PKEY *pkey=NULL;\r\nSESS_CERT *sc=NULL;\r\nint i;\r\nX509 *x509=NULL;\r\nint ret=0;\r\nx509=d2i_X509(NULL,&data,(long)len);\r\nif (x509 == NULL)\r\n{\r\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,ERR_R_X509_LIB);\r\ngoto err;\r\n}\r\nif ((sk=sk_X509_new_null()) == NULL || !sk_X509_push(sk,x509))\r\n{\r\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\ni=ssl_verify_cert_chain(s,sk);\r\nif ((s->verify_mode != SSL_VERIFY_NONE) && (i <= 0))\r\n{\r\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_CERTIFICATE_VERIFY_FAILED);\r\ngoto err;\r\n}\r\nERR_clear_error();\r\ns->session->verify_result = s->verify_result;\r\nsc=ssl_sess_cert_new();\r\nif (sc == NULL)\r\n{\r\nret= -1;\r\ngoto err;\r\n}\r\nif (s->session->sess_cert) ssl_sess_cert_free(s->session->sess_cert);\r\ns->session->sess_cert=sc;\r\nsc->peer_pkeys[SSL_PKEY_RSA_ENC].x509=x509;\r\nsc->peer_key= &(sc->peer_pkeys[SSL_PKEY_RSA_ENC]);\r\npkey=X509_get_pubkey(x509);\r\nx509=NULL;\r\nif (pkey == NULL)\r\n{\r\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_UNABLE_TO_EXTRACT_PUBLIC_KEY);\r\ngoto err;\r\n}\r\nif (pkey->type != EVP_PKEY_RSA)\r\n{\r\nSSLerr(SSL_F_SSL2_SET_CERTIFICATE,SSL_R_PUBLIC_KEY_NOT_RSA);\r\ngoto err;\r\n}\r\nif (!ssl_set_peer_cert_type(sc,SSL2_CT_X509_CERTIFICATE))\r\ngoto err;\r\nret=1;\r\nerr:\r\nsk_X509_free(sk);\r\nX509_free(x509);\r\nEVP_PKEY_free(pkey);\r\nreturn(ret);\r\n}\r\nstatic int ssl_rsa_public_encrypt(SESS_CERT *sc, int len, unsigned char *from,\r\nunsigned char *to, int padding)\r\n{\r\nEVP_PKEY *pkey=NULL;\r\nint i= -1;\r\nif ((sc == NULL) || (sc->peer_key->x509 == NULL) ||\r\n((pkey=X509_get_pubkey(sc->peer_key->x509)) == NULL))\r\n{\r\nSSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,SSL_R_NO_PUBLICKEY);\r\nreturn(-1);\r\n}\r\nif (pkey->type != EVP_PKEY_RSA)\r\n{\r\nSSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,SSL_R_PUBLIC_KEY_IS_NOT_RSA);\r\ngoto end;\r\n}\r\ni=RSA_public_encrypt(len,from,to,pkey->pkey.rsa,padding);\r\nif (i < 0)\r\nSSLerr(SSL_F_SSL_RSA_PUBLIC_ENCRYPT,ERR_R_RSA_LIB);\r\nend:\r\nEVP_PKEY_free(pkey);\r\nreturn(i);\r\n}
