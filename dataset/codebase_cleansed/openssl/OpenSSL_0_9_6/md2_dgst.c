const char *MD2_options(void)\r\n{\r\nif (sizeof(MD2_INT) == 1)\r\nreturn("md2(char)");\r\nelse\r\nreturn("md2(int)");\r\n}\r\nvoid MD2_Init(MD2_CTX *c)\r\n{\r\nc->num=0;\r\nmemset(c->state,0,MD2_BLOCK*sizeof(MD2_INT));\r\nmemset(c->cksm,0,MD2_BLOCK*sizeof(MD2_INT));\r\nmemset(c->data,0,MD2_BLOCK);\r\n}\r\nvoid MD2_Update(MD2_CTX *c, const unsigned char *data, unsigned long len)\r\n{\r\nregister UCHAR *p;\r\nif (len == 0) return;\r\np=c->data;\r\nif (c->num != 0)\r\n{\r\nif ((c->num+len) >= MD2_BLOCK)\r\n{\r\nmemcpy(&(p[c->num]),data,MD2_BLOCK-c->num);\r\nmd2_block(c,c->data);\r\ndata+=(MD2_BLOCK - c->num);\r\nlen-=(MD2_BLOCK - c->num);\r\nc->num=0;\r\n}\r\nelse\r\n{\r\nmemcpy(&(p[c->num]),data,(int)len);\r\nc->num+=(int)len;\r\nreturn;\r\n}\r\n}\r\nwhile (len >= MD2_BLOCK)\r\n{\r\nmd2_block(c,data);\r\ndata+=MD2_BLOCK;\r\nlen-=MD2_BLOCK;\r\n}\r\nmemcpy(p,data,(int)len);\r\nc->num=(int)len;\r\n}\r\nstatic void md2_block(MD2_CTX *c, const unsigned char *d)\r\n{\r\nregister MD2_INT t,*sp1,*sp2;\r\nregister int i,j;\r\nMD2_INT state[48];\r\nsp1=c->state;\r\nsp2=c->cksm;\r\nj=sp2[MD2_BLOCK-1];\r\nfor (i=0; i<16; i++)\r\n{\r\nstate[i]=sp1[i];\r\nstate[i+16]=t=d[i];\r\nstate[i+32]=(t^sp1[i]);\r\nj=sp2[i]^=S[t^j];\r\n}\r\nt=0;\r\nfor (i=0; i<18; i++)\r\n{\r\nfor (j=0; j<48; j+=8)\r\n{\r\nt= state[j+ 0]^=S[t];\r\nt= state[j+ 1]^=S[t];\r\nt= state[j+ 2]^=S[t];\r\nt= state[j+ 3]^=S[t];\r\nt= state[j+ 4]^=S[t];\r\nt= state[j+ 5]^=S[t];\r\nt= state[j+ 6]^=S[t];\r\nt= state[j+ 7]^=S[t];\r\n}\r\nt=(t+i)&0xff;\r\n}\r\nmemcpy(sp1,state,16*sizeof(MD2_INT));\r\nmemset(state,0,48*sizeof(MD2_INT));\r\n}\r\nvoid MD2_Final(unsigned char *md, MD2_CTX *c)\r\n{\r\nint i,v;\r\nregister UCHAR *cp;\r\nregister MD2_INT *p1,*p2;\r\ncp=c->data;\r\np1=c->state;\r\np2=c->cksm;\r\nv=MD2_BLOCK-c->num;\r\nfor (i=c->num; i<MD2_BLOCK; i++)\r\ncp[i]=(UCHAR)v;\r\nmd2_block(c,cp);\r\nfor (i=0; i<MD2_BLOCK; i++)\r\ncp[i]=(UCHAR)p2[i];\r\nmd2_block(c,cp);\r\nfor (i=0; i<16; i++)\r\nmd[i]=(UCHAR)(p1[i]&0xff);\r\nmemset((char *)&c,0,sizeof(c));\r\n}
