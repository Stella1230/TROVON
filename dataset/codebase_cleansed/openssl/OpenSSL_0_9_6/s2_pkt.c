int ssl2_peek(SSL *s, char *buf, int len)\r\n{\r\nint ret;\r\nret=ssl2_read(s,buf,len);\r\nif (ret > 0)\r\n{\r\ns->s2->ract_data_length+=ret;\r\ns->s2->ract_data-=ret;\r\n}\r\nreturn(ret);\r\n}\r\nint ssl2_read(SSL *s, void *buf, int len)\r\n{\r\nint n;\r\nunsigned char mac[MAX_MAC_SIZE];\r\nunsigned char *p;\r\nint i;\r\nunsigned int mac_size=0;\r\nssl2_read_again:\r\nif (SSL_in_init(s) && !s->in_handshake)\r\n{\r\nn=s->handshake_func(s);\r\nif (n < 0) return(n);\r\nif (n == 0)\r\n{\r\nSSLerr(SSL_F_SSL2_READ,SSL_R_SSL_HANDSHAKE_FAILURE);\r\nreturn(-1);\r\n}\r\n}\r\nclear_sys_error();\r\ns->rwstate=SSL_NOTHING;\r\nif (len <= 0) return(len);\r\nif (s->s2->ract_data_length != 0)\r\n{\r\nif (len > s->s2->ract_data_length)\r\nn=s->s2->ract_data_length;\r\nelse\r\nn=len;\r\nmemcpy(buf,s->s2->ract_data,(unsigned int)n);\r\ns->s2->ract_data_length-=n;\r\ns->s2->ract_data+=n;\r\nif (s->s2->ract_data_length == 0)\r\ns->rstate=SSL_ST_READ_HEADER;\r\nreturn(n);\r\n}\r\nif (s->rstate == SSL_ST_READ_HEADER)\r\n{\r\nif (s->first_packet)\r\n{\r\nn=read_n(s,5,SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2,0);\r\nif (n <= 0) return(n);\r\ns->first_packet=0;\r\np=s->packet;\r\nif (!((p[0] & 0x80) && (\r\n(p[2] == SSL2_MT_CLIENT_HELLO) ||\r\n(p[2] == SSL2_MT_SERVER_HELLO))))\r\n{\r\nSSLerr(SSL_F_SSL2_READ,SSL_R_NON_SSLV2_INITIAL_PACKET);\r\nreturn(-1);\r\n}\r\n}\r\nelse\r\n{\r\nn=read_n(s,2,SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2,0);\r\nif (n <= 0) return(n);\r\n}\r\ns->rstate=SSL_ST_READ_BODY;\r\np=s->packet;\r\ns->s2->escape=0;\r\ns->s2->rlength=(((unsigned int)p[0])<<8)|((unsigned int)p[1]);\r\nif ((p[0] & TWO_BYTE_BIT))\r\n{\r\ns->s2->three_byte_header=0;\r\ns->s2->rlength&=TWO_BYTE_MASK;\r\n}\r\nelse\r\n{\r\ns->s2->three_byte_header=1;\r\ns->s2->rlength&=THREE_BYTE_MASK;\r\ns->s2->escape=((p[0] & SEC_ESC_BIT))?1:0;\r\n}\r\n}\r\nif (s->rstate == SSL_ST_READ_BODY)\r\n{\r\nn=s->s2->rlength+2+s->s2->three_byte_header;\r\nif (n > (int)s->packet_length)\r\n{\r\nn-=s->packet_length;\r\ni=read_n(s,(unsigned int)n,(unsigned int)n,1);\r\nif (i <= 0) return(i);\r\n}\r\np= &(s->packet[2]);\r\ns->rstate=SSL_ST_READ_HEADER;\r\nif (s->s2->three_byte_header)\r\ns->s2->padding= *(p++);\r\nelse s->s2->padding=0;\r\nif (s->s2->clear_text)\r\n{\r\ns->s2->mac_data=p;\r\ns->s2->ract_data=p;\r\ns->s2->pad_data=NULL;\r\n}\r\nelse\r\n{\r\nmac_size=EVP_MD_size(s->read_hash);\r\ns->s2->mac_data=p;\r\ns->s2->ract_data= &p[mac_size];\r\ns->s2->pad_data= &p[mac_size+\r\ns->s2->rlength-s->s2->padding];\r\n}\r\ns->s2->ract_data_length=s->s2->rlength;\r\nif ((!s->s2->clear_text) &&\r\n(s->s2->rlength >= mac_size))\r\n{\r\nssl2_enc(s,0);\r\ns->s2->ract_data_length-=mac_size;\r\nssl2_mac(s,mac,0);\r\ns->s2->ract_data_length-=s->s2->padding;\r\nif ( (memcmp(mac,s->s2->mac_data,\r\n(unsigned int)mac_size) != 0) ||\r\n(s->s2->rlength%EVP_CIPHER_CTX_block_size(s->enc_read_ctx) != 0))\r\n{\r\nSSLerr(SSL_F_SSL2_READ,SSL_R_BAD_MAC_DECODE);\r\nreturn(-1);\r\n}\r\n}\r\nINC32(s->s2->read_sequence);\r\n#if 1\r\ngoto ssl2_read_again;\r\n#else\r\nif (s->s2->ract_data_length == 0)\r\nreturn(0);\r\nreturn(ssl2_read(s,buf,len));\r\n#endif\r\n}\r\nelse\r\n{\r\nSSLerr(SSL_F_SSL2_READ,SSL_R_BAD_STATE);\r\nreturn(-1);\r\n}\r\n}\r\nstatic int read_n(SSL *s, unsigned int n, unsigned int max,\r\nunsigned int extend)\r\n{\r\nint i,off,newb;\r\nif (s->s2->rbuf_left >= (int)n)\r\n{\r\nif (extend)\r\ns->packet_length+=n;\r\nelse\r\n{\r\ns->packet= &(s->s2->rbuf[s->s2->rbuf_offs]);\r\ns->packet_length=n;\r\n}\r\ns->s2->rbuf_left-=n;\r\ns->s2->rbuf_offs+=n;\r\nreturn(n);\r\n}\r\nif (!s->read_ahead) max=n;\r\nif (max > (unsigned int)(SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2))\r\nmax=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER+2;\r\noff=0;\r\nif ((s->s2->rbuf_left != 0) || ((s->packet_length != 0) && extend))\r\n{\r\nnewb=s->s2->rbuf_left;\r\nif (extend)\r\n{\r\noff=s->packet_length;\r\nif (s->packet != s->s2->rbuf)\r\nmemcpy(s->s2->rbuf,s->packet,\r\n(unsigned int)newb+off);\r\n}\r\nelse if (s->s2->rbuf_offs != 0)\r\n{\r\nmemcpy(s->s2->rbuf,&(s->s2->rbuf[s->s2->rbuf_offs]),\r\n(unsigned int)newb);\r\ns->s2->rbuf_offs=0;\r\n}\r\ns->s2->rbuf_left=0;\r\n}\r\nelse\r\nnewb=0;\r\ns->packet=s->s2->rbuf;\r\nwhile (newb < (int)n)\r\n{\r\nclear_sys_error();\r\nif (s->rbio != NULL)\r\n{\r\ns->rwstate=SSL_READING;\r\ni=BIO_read(s->rbio,(char *)&(s->s2->rbuf[off+newb]),\r\nmax-newb);\r\n}\r\nelse\r\n{\r\nSSLerr(SSL_F_READ_N,SSL_R_READ_BIO_NOT_SET);\r\ni= -1;\r\n}\r\n#ifdef PKT_DEBUG\r\nif (s->debug & 0x01) sleep(1);\r\n#endif\r\nif (i <= 0)\r\n{\r\ns->s2->rbuf_left+=newb;\r\nreturn(i);\r\n}\r\nnewb+=i;\r\n}\r\nif (newb > (int)n)\r\n{\r\ns->s2->rbuf_offs=n+off;\r\ns->s2->rbuf_left=newb-n;\r\n}\r\nelse\r\n{\r\ns->s2->rbuf_offs=0;\r\ns->s2->rbuf_left=0;\r\n}\r\nif (extend)\r\ns->packet_length+=n;\r\nelse\r\ns->packet_length=n;\r\ns->rwstate=SSL_NOTHING;\r\nreturn(n);\r\n}\r\nint ssl2_write(SSL *s, const void *_buf, int len)\r\n{\r\nconst unsigned char *buf=_buf;\r\nunsigned int n,tot;\r\nint i;\r\nif (SSL_in_init(s) && !s->in_handshake)\r\n{\r\ni=s->handshake_func(s);\r\nif (i < 0) return(i);\r\nif (i == 0)\r\n{\r\nSSLerr(SSL_F_SSL2_WRITE,SSL_R_SSL_HANDSHAKE_FAILURE);\r\nreturn(-1);\r\n}\r\n}\r\nif (s->error)\r\n{\r\nssl2_write_error(s);\r\nif (s->error)\r\nreturn(-1);\r\n}\r\nclear_sys_error();\r\ns->rwstate=SSL_NOTHING;\r\nif (len <= 0) return(len);\r\ntot=s->s2->wnum;\r\ns->s2->wnum=0;\r\nn=(len-tot);\r\nfor (;;)\r\n{\r\ni=do_ssl_write(s,&(buf[tot]),n);\r\nif (i <= 0)\r\n{\r\ns->s2->wnum=tot;\r\nreturn(i);\r\n}\r\nif ((i == (int)n) ||\r\n(s->mode & SSL_MODE_ENABLE_PARTIAL_WRITE))\r\n{\r\nreturn(tot+i);\r\n}\r\nn-=i;\r\ntot+=i;\r\n}\r\n}\r\nstatic int write_pending(SSL *s, const unsigned char *buf, unsigned int len)\r\n{\r\nint i;\r\nif ((s->s2->wpend_tot > (int)len) ||\r\n((s->s2->wpend_buf != buf) &&\r\n!(s->mode & SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER)))\r\n{\r\nSSLerr(SSL_F_WRITE_PENDING,SSL_R_BAD_WRITE_RETRY);\r\nreturn(-1);\r\n}\r\nfor (;;)\r\n{\r\nclear_sys_error();\r\nif (s->wbio != NULL)\r\n{\r\ns->rwstate=SSL_WRITING;\r\ni=BIO_write(s->wbio,\r\n(char *)&(s->s2->write_ptr[s->s2->wpend_off]),\r\n(unsigned int)s->s2->wpend_len);\r\n}\r\nelse\r\n{\r\nSSLerr(SSL_F_WRITE_PENDING,SSL_R_WRITE_BIO_NOT_SET);\r\ni= -1;\r\n}\r\n#ifdef PKT_DEBUG\r\nif (s->debug & 0x01) sleep(1);\r\n#endif\r\nif (i == s->s2->wpend_len)\r\n{\r\ns->s2->wpend_len=0;\r\ns->rwstate=SSL_NOTHING;\r\nreturn(s->s2->wpend_ret);\r\n}\r\nelse if (i <= 0)\r\nreturn(i);\r\ns->s2->wpend_off+=i;\r\ns->s2->wpend_len-=i;\r\n}\r\n}\r\nstatic int do_ssl_write(SSL *s, const unsigned char *buf, unsigned int len)\r\n{\r\nunsigned int j,k,olen,p,mac_size,bs;\r\nregister unsigned char *pp;\r\nolen=len;\r\nif (s->s2->wpend_len != 0) return(write_pending(s,buf,len));\r\nif (s->s2->clear_text)\r\nmac_size=0;\r\nelse\r\nmac_size=EVP_MD_size(s->write_hash);\r\nif (s->s2->clear_text)\r\n{\r\nif (len > SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER)\r\nlen=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER;\r\np=0;\r\ns->s2->three_byte_header=0;\r\n}\r\nelse\r\n{\r\nbs=EVP_CIPHER_CTX_block_size(s->enc_read_ctx);\r\nj=len+mac_size;\r\nif ((j > SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER) &&\r\n(!s->s2->escape))\r\n{\r\nif (j > SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER)\r\nj=SSL2_MAX_RECORD_LENGTH_2_BYTE_HEADER;\r\nk=j-(j%bs);\r\nlen=k-mac_size;\r\ns->s2->three_byte_header=0;\r\np=0;\r\n}\r\nelse if ((bs <= 1) && (!s->s2->escape))\r\n{\r\ns->s2->three_byte_header=0;\r\np=0;\r\n}\r\nelse\r\n{\r\np=(j%bs);\r\np=(p == 0)?0:(bs-p);\r\nif (s->s2->escape)\r\ns->s2->three_byte_header=1;\r\nelse\r\ns->s2->three_byte_header=(p == 0)?0:1;\r\n}\r\n}\r\ns->s2->wlength=len;\r\ns->s2->padding=p;\r\ns->s2->mac_data= &(s->s2->wbuf[3]);\r\ns->s2->wact_data= &(s->s2->wbuf[3+mac_size]);\r\nmemcpy(s->s2->wact_data,buf,len);\r\n#ifdef PURIFY\r\nif (p)\r\nmemset(&(s->s2->wact_data[len]),0,p);\r\n#endif\r\nif (!s->s2->clear_text)\r\n{\r\ns->s2->wact_data_length=len+p;\r\nssl2_mac(s,s->s2->mac_data,1);\r\ns->s2->wlength+=p+mac_size;\r\nssl2_enc(s,1);\r\n}\r\ns->s2->wpend_len=s->s2->wlength;\r\nif (s->s2->three_byte_header)\r\n{\r\npp=s->s2->mac_data;\r\npp-=3;\r\npp[0]=(s->s2->wlength>>8)&(THREE_BYTE_MASK>>8);\r\nif (s->s2->escape) pp[0]|=SEC_ESC_BIT;\r\npp[1]=s->s2->wlength&0xff;\r\npp[2]=s->s2->padding;\r\ns->s2->wpend_len+=3;\r\n}\r\nelse\r\n{\r\npp=s->s2->mac_data;\r\npp-=2;\r\npp[0]=((s->s2->wlength>>8)&(TWO_BYTE_MASK>>8))|TWO_BYTE_BIT;\r\npp[1]=s->s2->wlength&0xff;\r\ns->s2->wpend_len+=2;\r\n}\r\ns->s2->write_ptr=pp;\r\nINC32(s->s2->write_sequence);\r\ns->s2->wpend_tot=olen;\r\ns->s2->wpend_buf=buf;\r\ns->s2->wpend_ret=len;\r\ns->s2->wpend_off=0;\r\nreturn(write_pending(s,buf,olen));\r\n}\r\nint ssl2_part_read(SSL *s, unsigned long f, int i)\r\n{\r\nunsigned char *p;\r\nint j;\r\nif ((s->init_num == 0) && (i >= 3))\r\n{\r\np=(unsigned char *)s->init_buf->data;\r\nif (p[0] == SSL2_MT_ERROR)\r\n{\r\nj=(p[1]<<8)|p[2];\r\nSSLerr((int)f,ssl_mt_error(j));\r\n}\r\n}\r\nif (i < 0)\r\n{\r\nreturn(i);\r\n}\r\nelse\r\n{\r\ns->init_num+=i;\r\nreturn(0);\r\n}\r\n}\r\nint ssl2_do_write(SSL *s)\r\n{\r\nint ret;\r\nret=ssl2_write(s,&s->init_buf->data[s->init_off],s->init_num);\r\nif (ret == s->init_num)\r\nreturn(1);\r\nif (ret < 0)\r\nreturn(-1);\r\ns->init_off+=ret;\r\ns->init_num-=ret;\r\nreturn(0);\r\n}\r\nstatic int ssl_mt_error(int n)\r\n{\r\nint ret;\r\nswitch (n)\r\n{\r\ncase SSL2_PE_NO_CIPHER:\r\nret=SSL_R_PEER_ERROR_NO_CIPHER;\r\nbreak;\r\ncase SSL2_PE_NO_CERTIFICATE:\r\nret=SSL_R_PEER_ERROR_NO_CERTIFICATE;\r\nbreak;\r\ncase SSL2_PE_BAD_CERTIFICATE:\r\nret=SSL_R_PEER_ERROR_CERTIFICATE;\r\nbreak;\r\ncase SSL2_PE_UNSUPPORTED_CERTIFICATE_TYPE:\r\nret=SSL_R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE;\r\nbreak;\r\ndefault:\r\nret=SSL_R_UNKNOWN_REMOTE_ERROR_TYPE;\r\nbreak;\r\n}\r\nreturn(ret);\r\n}
