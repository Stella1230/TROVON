BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int safe, BIGNUM *add,\r\nBIGNUM *rem, void (*callback)(int,int,void *), void *cb_arg)\r\n{\r\nBIGNUM *rnd=NULL;\r\nBIGNUM t;\r\nint found=0;\r\nint i,j,c1=0;\r\nBN_CTX *ctx;\r\nint checks = BN_prime_checks_for_size(bits);\r\nctx=BN_CTX_new();\r\nif (ctx == NULL) goto err;\r\nif (ret == NULL)\r\n{\r\nif ((rnd=BN_new()) == NULL) goto err;\r\n}\r\nelse\r\nrnd=ret;\r\nBN_init(&t);\r\nloop:\r\nif (add == NULL)\r\n{\r\nif (!probable_prime(rnd,bits)) goto err;\r\n}\r\nelse\r\n{\r\nif (safe)\r\n{\r\nif (!probable_prime_dh_safe(rnd,bits,add,rem,ctx))\r\ngoto err;\r\n}\r\nelse\r\n{\r\nif (!probable_prime_dh(rnd,bits,add,rem,ctx))\r\ngoto err;\r\n}\r\n}\r\nif (callback != NULL) callback(0,c1++,cb_arg);\r\nif (!safe)\r\n{\r\ni=BN_is_prime_fasttest(rnd,checks,callback,ctx,cb_arg,0);\r\nif (i == -1) goto err;\r\nif (i == 0) goto loop;\r\n}\r\nelse\r\n{\r\nif (!BN_rshift1(&t,rnd)) goto err;\r\nfor (i=0; i<checks; i++)\r\n{\r\nj=BN_is_prime_fasttest(rnd,1,callback,ctx,cb_arg,0);\r\nif (j == -1) goto err;\r\nif (j == 0) goto loop;\r\nj=BN_is_prime_fasttest(&t,1,callback,ctx,cb_arg,0);\r\nif (j == -1) goto err;\r\nif (j == 0) goto loop;\r\nif (callback != NULL) callback(2,c1-1,cb_arg);\r\n}\r\n}\r\nfound = 1;\r\nerr:\r\nif (!found && (ret == NULL) && (rnd != NULL)) BN_free(rnd);\r\nBN_free(&t);\r\nif (ctx != NULL) BN_CTX_free(ctx);\r\nreturn(found ? rnd : NULL);\r\n}\r\nint BN_is_prime(const BIGNUM *a, int checks, void (*callback)(int,int,void *),\r\nBN_CTX *ctx_passed, void *cb_arg)\r\n{\r\nreturn BN_is_prime_fasttest(a, checks, callback, ctx_passed, cb_arg, 0);\r\n}\r\nint BN_is_prime_fasttest(const BIGNUM *a, int checks,\r\nvoid (*callback)(int,int,void *),\r\nBN_CTX *ctx_passed, void *cb_arg,\r\nint do_trial_division)\r\n{\r\nint i, j, ret = -1;\r\nint k;\r\nBN_CTX *ctx = NULL;\r\nBIGNUM *A1, *A1_odd, *check;\r\nBN_MONT_CTX *mont = NULL;\r\nconst BIGNUM *A = NULL;\r\nif (checks == BN_prime_checks)\r\nchecks = BN_prime_checks_for_size(BN_num_bits(a));\r\nif (!BN_is_odd(a))\r\nreturn(0);\r\nif (do_trial_division)\r\n{\r\nfor (i = 1; i < NUMPRIMES; i++)\r\nif (BN_mod_word(a, primes[i]) == 0)\r\nreturn 0;\r\nif (callback != NULL) callback(1, -1, cb_arg);\r\n}\r\nif (ctx_passed != NULL)\r\nctx = ctx_passed;\r\nelse\r\nif ((ctx=BN_CTX_new()) == NULL)\r\ngoto err;\r\nBN_CTX_start(ctx);\r\nif (a->neg)\r\n{\r\nBIGNUM *t;\r\nif ((t = BN_CTX_get(ctx)) == NULL) goto err;\r\nBN_copy(t, a);\r\nt->neg = 0;\r\nA = t;\r\n}\r\nelse\r\nA = a;\r\nA1 = BN_CTX_get(ctx);\r\nA1_odd = BN_CTX_get(ctx);\r\ncheck = BN_CTX_get(ctx);\r\nif (check == NULL) goto err;\r\nif (!BN_copy(A1, A))\r\ngoto err;\r\nif (!BN_sub_word(A1, 1))\r\ngoto err;\r\nif (BN_is_zero(A1))\r\n{\r\nret = 0;\r\ngoto err;\r\n}\r\nk = 1;\r\nwhile (!BN_is_bit_set(A1, k))\r\nk++;\r\nif (!BN_rshift(A1_odd, A1, k))\r\ngoto err;\r\nmont = BN_MONT_CTX_new();\r\nif (mont == NULL)\r\ngoto err;\r\nif (!BN_MONT_CTX_set(mont, A, ctx))\r\ngoto err;\r\nfor (i = 0; i < checks; i++)\r\n{\r\nif (!BN_pseudo_rand(check, BN_num_bits(A1), 0, 0))\r\ngoto err;\r\nif (BN_cmp(check, A1) >= 0)\r\nif (!BN_sub(check, check, A1))\r\ngoto err;\r\nif (!BN_add_word(check, 1))\r\ngoto err;\r\nj = witness(check, A, A1, A1_odd, k, ctx, mont);\r\nif (j == -1) goto err;\r\nif (j)\r\n{\r\nret=0;\r\ngoto err;\r\n}\r\nif (callback != NULL) callback(1,i,cb_arg);\r\n}\r\nret=1;\r\nerr:\r\nif (ctx != NULL)\r\n{\r\nBN_CTX_end(ctx);\r\nif (ctx_passed == NULL)\r\nBN_CTX_free(ctx);\r\n}\r\nif (mont != NULL)\r\nBN_MONT_CTX_free(mont);\r\nreturn(ret);\r\n}\r\nstatic int witness(BIGNUM *w, const BIGNUM *a, const BIGNUM *a1,\r\nconst BIGNUM *a1_odd, int k, BN_CTX *ctx, BN_MONT_CTX *mont)\r\n{\r\nif (!BN_mod_exp_mont(w, w, a1_odd, a, ctx, mont))\r\nreturn -1;\r\nif (BN_is_one(w))\r\nreturn 0;\r\nif (BN_cmp(w, a1) == 0)\r\nreturn 0;\r\nwhile (--k)\r\n{\r\nif (!BN_mod_mul(w, w, w, a, ctx))\r\nreturn -1;\r\nif (BN_is_one(w))\r\nreturn 1;\r\nif (BN_cmp(w, a1) == 0)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int probable_prime(BIGNUM *rnd, int bits)\r\n{\r\nint i;\r\nBN_ULONG mods[NUMPRIMES];\r\nBN_ULONG delta,d;\r\nagain:\r\nif (!BN_rand(rnd,bits,1,1)) return(0);\r\nfor (i=1; i<NUMPRIMES; i++)\r\nmods[i]=BN_mod_word(rnd,(BN_ULONG)primes[i]);\r\ndelta=0;\r\nloop: for (i=1; i<NUMPRIMES; i++)\r\n{\r\nif (((mods[i]+delta)%primes[i]) <= 1)\r\n{\r\nd=delta;\r\ndelta+=2;\r\nif (delta < d) goto again;\r\ngoto loop;\r\n}\r\n}\r\nif (!BN_add_word(rnd,delta)) return(0);\r\nreturn(1);\r\n}\r\nstatic int probable_prime_dh(BIGNUM *rnd, int bits, BIGNUM *add, BIGNUM *rem,\r\nBN_CTX *ctx)\r\n{\r\nint i,ret=0;\r\nBIGNUM *t1;\r\nBN_CTX_start(ctx);\r\nif ((t1 = BN_CTX_get(ctx)) == NULL) goto err;\r\nif (!BN_rand(rnd,bits,0,1)) goto err;\r\nif (!BN_mod(t1,rnd,add,ctx)) goto err;\r\nif (!BN_sub(rnd,rnd,t1)) goto err;\r\nif (rem == NULL)\r\n{ if (!BN_add_word(rnd,1)) goto err; }\r\nelse\r\n{ if (!BN_add(rnd,rnd,rem)) goto err; }\r\nloop: for (i=1; i<NUMPRIMES; i++)\r\n{\r\nif (BN_mod_word(rnd,(BN_ULONG)primes[i]) <= 1)\r\n{\r\nif (!BN_add(rnd,rnd,add)) goto err;\r\ngoto loop;\r\n}\r\n}\r\nret=1;\r\nerr:\r\nBN_CTX_end(ctx);\r\nreturn(ret);\r\n}\r\nstatic int probable_prime_dh_safe(BIGNUM *p, int bits, BIGNUM *padd,\r\nBIGNUM *rem, BN_CTX *ctx)\r\n{\r\nint i,ret=0;\r\nBIGNUM *t1,*qadd,*q;\r\nbits--;\r\nBN_CTX_start(ctx);\r\nt1 = BN_CTX_get(ctx);\r\nq = BN_CTX_get(ctx);\r\nqadd = BN_CTX_get(ctx);\r\nif (qadd == NULL) goto err;\r\nif (!BN_rshift1(qadd,padd)) goto err;\r\nif (!BN_rand(q,bits,0,1)) goto err;\r\nif (!BN_mod(t1,q,qadd,ctx)) goto err;\r\nif (!BN_sub(q,q,t1)) goto err;\r\nif (rem == NULL)\r\n{ if (!BN_add_word(q,1)) goto err; }\r\nelse\r\n{\r\nif (!BN_rshift1(t1,rem)) goto err;\r\nif (!BN_add(q,q,t1)) goto err;\r\n}\r\nif (!BN_lshift1(p,q)) goto err;\r\nif (!BN_add_word(p,1)) goto err;\r\nloop: for (i=1; i<NUMPRIMES; i++)\r\n{\r\nif ( (BN_mod_word(p,(BN_ULONG)primes[i]) == 0) ||\r\n(BN_mod_word(q,(BN_ULONG)primes[i]) == 0))\r\n{\r\nif (!BN_add(p,p,padd)) goto err;\r\nif (!BN_add(q,q,qadd)) goto err;\r\ngoto loop;\r\n}\r\n}\r\nret=1;\r\nerr:\r\nBN_CTX_end(ctx);\r\nreturn(ret);\r\n}
