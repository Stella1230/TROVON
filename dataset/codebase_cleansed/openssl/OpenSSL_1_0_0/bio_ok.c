BIO_METHOD *BIO_f_reliable(void)\r\n{\r\nreturn(&methods_ok);\r\n}\r\nstatic int ok_new(BIO *bi)\r\n{\r\nBIO_OK_CTX *ctx;\r\nctx=(BIO_OK_CTX *)OPENSSL_malloc(sizeof(BIO_OK_CTX));\r\nif (ctx == NULL) return(0);\r\nctx->buf_len=0;\r\nctx->buf_off=0;\r\nctx->buf_len_save=0;\r\nctx->buf_off_save=0;\r\nctx->cont=1;\r\nctx->finished=0;\r\nctx->blockout= 0;\r\nctx->sigio=1;\r\nEVP_MD_CTX_init(&ctx->md);\r\nbi->init=0;\r\nbi->ptr=(char *)ctx;\r\nbi->flags=0;\r\nreturn(1);\r\n}\r\nstatic int ok_free(BIO *a)\r\n{\r\nif (a == NULL) return(0);\r\nEVP_MD_CTX_cleanup(&((BIO_OK_CTX *)a->ptr)->md);\r\nOPENSSL_cleanse(a->ptr,sizeof(BIO_OK_CTX));\r\nOPENSSL_free(a->ptr);\r\na->ptr=NULL;\r\na->init=0;\r\na->flags=0;\r\nreturn(1);\r\n}\r\nstatic int ok_read(BIO *b, char *out, int outl)\r\n{\r\nint ret=0,i,n;\r\nBIO_OK_CTX *ctx;\r\nif (out == NULL) return(0);\r\nctx=(BIO_OK_CTX *)b->ptr;\r\nif ((ctx == NULL) || (b->next_bio == NULL) || (b->init == 0)) return(0);\r\nwhile(outl > 0)\r\n{\r\nif (ctx->blockout)\r\n{\r\ni=ctx->buf_len-ctx->buf_off;\r\nif (i > outl) i=outl;\r\nmemcpy(out,&(ctx->buf[ctx->buf_off]),i);\r\nret+=i;\r\nout+=i;\r\noutl-=i;\r\nctx->buf_off+=i;\r\nif (ctx->buf_len == ctx->buf_off)\r\n{\r\nctx->buf_off=0;\r\nif(ctx->buf_len_save- ctx->buf_off_save > 0)\r\n{\r\nctx->buf_len= ctx->buf_len_save- ctx->buf_off_save;\r\nmemmove(ctx->buf, &(ctx->buf[ctx->buf_off_save]),\r\nctx->buf_len);\r\n}\r\nelse\r\n{\r\nctx->buf_len=0;\r\n}\r\nctx->blockout= 0;\r\n}\r\n}\r\nif (outl == 0) break;\r\nn=IOBS- ctx->buf_len;\r\ni=BIO_read(b->next_bio,&(ctx->buf[ctx->buf_len]),n);\r\nif (i <= 0) break;\r\nctx->buf_len+= i;\r\nif (ctx->sigio == 1) sig_in(b);\r\nif (ctx->sigio == 0) block_in(b);\r\nif (ctx->cont <= 0) break;\r\n}\r\nBIO_clear_retry_flags(b);\r\nBIO_copy_next_retry(b);\r\nreturn(ret);\r\n}\r\nstatic int ok_write(BIO *b, const char *in, int inl)\r\n{\r\nint ret=0,n,i;\r\nBIO_OK_CTX *ctx;\r\nif (inl <= 0) return inl;\r\nctx=(BIO_OK_CTX *)b->ptr;\r\nret=inl;\r\nif ((ctx == NULL) || (b->next_bio == NULL) || (b->init == 0)) return(0);\r\nif(ctx->sigio) sig_out(b);\r\ndo{\r\nBIO_clear_retry_flags(b);\r\nn=ctx->buf_len-ctx->buf_off;\r\nwhile (ctx->blockout && n > 0)\r\n{\r\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\r\nif (i <= 0)\r\n{\r\nBIO_copy_next_retry(b);\r\nif(!BIO_should_retry(b))\r\nctx->cont= 0;\r\nreturn(i);\r\n}\r\nctx->buf_off+=i;\r\nn-=i;\r\n}\r\nctx->blockout= 0;\r\nif (ctx->buf_len == ctx->buf_off)\r\n{\r\nctx->buf_len=OK_BLOCK_BLOCK;\r\nctx->buf_off=0;\r\n}\r\nif ((in == NULL) || (inl <= 0)) return(0);\r\nn= (inl+ ctx->buf_len > OK_BLOCK_SIZE+ OK_BLOCK_BLOCK) ?\r\n(int)(OK_BLOCK_SIZE+OK_BLOCK_BLOCK-ctx->buf_len) : inl;\r\nmemcpy((unsigned char *)(&(ctx->buf[ctx->buf_len])),(unsigned char *)in,n);\r\nctx->buf_len+= n;\r\ninl-=n;\r\nin+=n;\r\nif(ctx->buf_len >= OK_BLOCK_SIZE+ OK_BLOCK_BLOCK)\r\n{\r\nblock_out(b);\r\n}\r\n}while(inl > 0);\r\nBIO_clear_retry_flags(b);\r\nBIO_copy_next_retry(b);\r\nreturn(ret);\r\n}\r\nstatic long ok_ctrl(BIO *b, int cmd, long num, void *ptr)\r\n{\r\nBIO_OK_CTX *ctx;\r\nEVP_MD *md;\r\nconst EVP_MD **ppmd;\r\nlong ret=1;\r\nint i;\r\nctx=b->ptr;\r\nswitch (cmd)\r\n{\r\ncase BIO_CTRL_RESET:\r\nctx->buf_len=0;\r\nctx->buf_off=0;\r\nctx->buf_len_save=0;\r\nctx->buf_off_save=0;\r\nctx->cont=1;\r\nctx->finished=0;\r\nctx->blockout= 0;\r\nctx->sigio=1;\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_EOF:\r\nif (ctx->cont <= 0)\r\nret=1;\r\nelse\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_PENDING:\r\ncase BIO_CTRL_WPENDING:\r\nret=ctx->blockout ? ctx->buf_len-ctx->buf_off : 0;\r\nif (ret <= 0)\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_FLUSH:\r\nif(ctx->blockout == 0)\r\nblock_out(b);\r\nwhile (ctx->blockout)\r\n{\r\ni=ok_write(b,NULL,0);\r\nif (i < 0)\r\n{\r\nret=i;\r\nbreak;\r\n}\r\n}\r\nctx->finished=1;\r\nctx->buf_off=ctx->buf_len=0;\r\nctx->cont=(int)ret;\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_C_DO_STATE_MACHINE:\r\nBIO_clear_retry_flags(b);\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nBIO_copy_next_retry(b);\r\nbreak;\r\ncase BIO_CTRL_INFO:\r\nret=(long)ctx->cont;\r\nbreak;\r\ncase BIO_C_SET_MD:\r\nmd=ptr;\r\nEVP_DigestInit_ex(&ctx->md, md, NULL);\r\nb->init=1;\r\nbreak;\r\ncase BIO_C_GET_MD:\r\nif (b->init)\r\n{\r\nppmd=ptr;\r\n*ppmd=ctx->md.digest;\r\n}\r\nelse\r\nret=0;\r\nbreak;\r\ndefault:\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic long ok_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\r\n{\r\nlong ret=1;\r\nif (b->next_bio == NULL) return(0);\r\nswitch (cmd)\r\n{\r\ndefault:\r\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic void longswap(void *_ptr, size_t len)\r\n{ const union { long one; char little; } is_endian = {1};\r\nif (is_endian.little) {\r\nsize_t i;\r\nunsigned char *p=_ptr,c;\r\nfor(i= 0;i < len;i+= 4) {\r\nc=p[0],p[0]=p[3],p[3]=c;\r\nc=p[1],p[1]=p[2],p[2]=c;\r\n}\r\n}\r\n}\r\nstatic void sig_out(BIO* b)\r\n{\r\nBIO_OK_CTX *ctx;\r\nEVP_MD_CTX *md;\r\nctx=b->ptr;\r\nmd=&ctx->md;\r\nif(ctx->buf_len+ 2* md->digest->md_size > OK_BLOCK_SIZE) return;\r\nEVP_DigestInit_ex(md, md->digest, NULL);\r\nRAND_pseudo_bytes(md->md_data, md->digest->md_size);\r\nmemcpy(&(ctx->buf[ctx->buf_len]), md->md_data, md->digest->md_size);\r\nlongswap(&(ctx->buf[ctx->buf_len]), md->digest->md_size);\r\nctx->buf_len+= md->digest->md_size;\r\nEVP_DigestUpdate(md, WELLKNOWN, strlen(WELLKNOWN));\r\nEVP_DigestFinal_ex(md, &(ctx->buf[ctx->buf_len]), NULL);\r\nctx->buf_len+= md->digest->md_size;\r\nctx->blockout= 1;\r\nctx->sigio= 0;\r\n}\r\nstatic void sig_in(BIO* b)\r\n{\r\nBIO_OK_CTX *ctx;\r\nEVP_MD_CTX *md;\r\nunsigned char tmp[EVP_MAX_MD_SIZE];\r\nint ret= 0;\r\nctx=b->ptr;\r\nmd=&ctx->md;\r\nif((int)(ctx->buf_len-ctx->buf_off) < 2*md->digest->md_size) return;\r\nEVP_DigestInit_ex(md, md->digest, NULL);\r\nmemcpy(md->md_data, &(ctx->buf[ctx->buf_off]), md->digest->md_size);\r\nlongswap(md->md_data, md->digest->md_size);\r\nctx->buf_off+= md->digest->md_size;\r\nEVP_DigestUpdate(md, WELLKNOWN, strlen(WELLKNOWN));\r\nEVP_DigestFinal_ex(md, tmp, NULL);\r\nret= memcmp(&(ctx->buf[ctx->buf_off]), tmp, md->digest->md_size) == 0;\r\nctx->buf_off+= md->digest->md_size;\r\nif(ret == 1)\r\n{\r\nctx->sigio= 0;\r\nif(ctx->buf_len != ctx->buf_off)\r\n{\r\nmemmove(ctx->buf, &(ctx->buf[ctx->buf_off]), ctx->buf_len- ctx->buf_off);\r\n}\r\nctx->buf_len-= ctx->buf_off;\r\nctx->buf_off= 0;\r\n}\r\nelse\r\n{\r\nctx->cont= 0;\r\n}\r\n}\r\nstatic void block_out(BIO* b)\r\n{\r\nBIO_OK_CTX *ctx;\r\nEVP_MD_CTX *md;\r\nunsigned long tl;\r\nctx=b->ptr;\r\nmd=&ctx->md;\r\ntl= ctx->buf_len- OK_BLOCK_BLOCK;\r\nctx->buf[0]=(unsigned char)(tl>>24);\r\nctx->buf[1]=(unsigned char)(tl>>16);\r\nctx->buf[2]=(unsigned char)(tl>>8);\r\nctx->buf[3]=(unsigned char)(tl);\r\nEVP_DigestUpdate(md, (unsigned char*) &(ctx->buf[OK_BLOCK_BLOCK]), tl);\r\nEVP_DigestFinal_ex(md, &(ctx->buf[ctx->buf_len]), NULL);\r\nctx->buf_len+= md->digest->md_size;\r\nctx->blockout= 1;\r\n}\r\nstatic void block_in(BIO* b)\r\n{\r\nBIO_OK_CTX *ctx;\r\nEVP_MD_CTX *md;\r\nunsigned long tl= 0;\r\nunsigned char tmp[EVP_MAX_MD_SIZE];\r\nctx=b->ptr;\r\nmd=&ctx->md;\r\nassert(sizeof(tl)>=OK_BLOCK_BLOCK);\r\ntl =ctx->buf[0]; tl<<=8;\r\ntl|=ctx->buf[1]; tl<<=8;\r\ntl|=ctx->buf[2]; tl<<=8;\r\ntl|=ctx->buf[3];\r\nif (ctx->buf_len < tl+ OK_BLOCK_BLOCK+ md->digest->md_size) return;\r\nEVP_DigestUpdate(md, (unsigned char*) &(ctx->buf[OK_BLOCK_BLOCK]), tl);\r\nEVP_DigestFinal_ex(md, tmp, NULL);\r\nif(memcmp(&(ctx->buf[tl+ OK_BLOCK_BLOCK]), tmp, md->digest->md_size) == 0)\r\n{\r\nctx->buf_off_save= tl+ OK_BLOCK_BLOCK+ md->digest->md_size;\r\nctx->buf_len_save= ctx->buf_len;\r\nctx->buf_off= OK_BLOCK_BLOCK;\r\nctx->buf_len= tl+ OK_BLOCK_BLOCK;\r\nctx->blockout= 1;\r\n}\r\nelse\r\n{\r\nctx->cont= 0;\r\n}\r\n}
