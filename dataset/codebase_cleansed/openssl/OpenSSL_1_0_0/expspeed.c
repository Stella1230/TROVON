static double Time_F(int s)\r\n{\r\ndouble ret;\r\n#ifdef TIMES\r\nstatic struct tms tstart,tend;\r\nif (s == START)\r\n{\r\ntimes(&tstart);\r\nreturn(0);\r\n}\r\nelse\r\n{\r\ntimes(&tend);\r\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\r\nreturn((ret < 1e-3)?1e-3:ret);\r\n}\r\n#else\r\nstatic struct timeb tstart,tend;\r\nlong i;\r\nif (s == START)\r\n{\r\nftime(&tstart);\r\nreturn(0);\r\n}\r\nelse\r\n{\r\nftime(&tend);\r\ni=(long)tend.millitm-(long)tstart.millitm;\r\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\r\nreturn((ret < 0.001)?0.001:ret);\r\n}\r\n#endif\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nBN_CTX *ctx;\r\nBIGNUM *a,*b,*c,*r;\r\n#if 1\r\nif (!CRYPTO_set_mem_debug_functions(0,0,0,0,0))\r\nabort();\r\n#endif\r\nctx=BN_CTX_new();\r\na=BN_new();\r\nb=BN_new();\r\nc=BN_new();\r\nr=BN_new();\r\nwhile (!RAND_status())\r\nRAND_SEED("I demand a manual recount!");\r\ndo_mul_exp(r,a,b,c,ctx);\r\nreturn 0;\r\n}\r\nvoid do_mul_exp(BIGNUM *r, BIGNUM *a, BIGNUM *b, BIGNUM *c, BN_CTX *ctx)\r\n{\r\nint i,k;\r\ndouble tm;\r\nlong num;\r\nnum=BASENUM;\r\nfor (i=NUM_START; i<NUM_SIZES; i++)\r\n{\r\n#ifdef C_PRIME\r\n# ifdef TEST_SQRT\r\nif (!BN_set_word(a, 64)) goto err;\r\nif (!BN_set_word(b, P_MOD_64)) goto err;\r\n# define ADD a\r\n# define REM b\r\n# else\r\n# define ADD NULL\r\n# define REM NULL\r\n# endif\r\nif (!BN_generate_prime(c,sizes[i],0,ADD,REM,genprime_cb,NULL)) goto err;\r\nputc('\n', stderr);\r\nfflush(stderr);\r\n#endif\r\nfor (k=0; k<num; k++)\r\n{\r\nif (k%50 == 0)\r\n{\r\nif (!BN_pseudo_rand(a,sizes[i],1,0)) goto err;\r\nif (!BN_pseudo_rand(b,sizes[i],1,0)) goto err;\r\n#ifndef C_PRIME\r\nif (!BN_pseudo_rand(c,sizes[i],1,1)) goto err;\r\n#endif\r\n#ifdef TEST_SQRT\r\nif (!BN_mod_sqr(a,a,c,ctx)) goto err;\r\nif (!BN_mod_sqr(b,b,c,ctx)) goto err;\r\n#else\r\nif (!BN_nnmod(a,a,c,ctx)) goto err;\r\nif (!BN_nnmod(b,b,c,ctx)) goto err;\r\n#endif\r\nif (k == 0)\r\nTime_F(START);\r\n}\r\n#if defined(TEST_EXP)\r\nif (!BN_mod_exp(r,a,b,c,ctx)) goto err;\r\n#elif defined(TEST_MUL)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < 50; i++)\r\nif (!BN_mod_mul(r,a,b,c,ctx)) goto err;\r\n}\r\n#elif defined(TEST_SQR)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < 50; i++)\r\n{\r\nif (!BN_mod_sqr(r,a,c,ctx)) goto err;\r\nif (!BN_mod_sqr(r,b,c,ctx)) goto err;\r\n}\r\n}\r\n#elif defined(TEST_GCD)\r\nif (!BN_gcd(r,a,b,ctx)) goto err;\r\nif (!BN_gcd(r,b,c,ctx)) goto err;\r\nif (!BN_gcd(r,c,a,ctx)) goto err;\r\n#elif defined(TEST_KRON)\r\nif (-2 == BN_kronecker(a,b,ctx)) goto err;\r\nif (-2 == BN_kronecker(b,c,ctx)) goto err;\r\nif (-2 == BN_kronecker(c,a,ctx)) goto err;\r\n#elif defined(TEST_INV)\r\nif (!BN_mod_inverse(r,a,c,ctx)) goto err;\r\nif (!BN_mod_inverse(r,b,c,ctx)) goto err;\r\n#else\r\nif (!BN_mod_sqrt(r,a,c,ctx)) goto err;\r\nif (!BN_mod_sqrt(r,b,c,ctx)) goto err;\r\n#endif\r\n}\r\ntm=Time_F(STOP);\r\nprintf(\r\n#if defined(TEST_EXP)\r\n"modexp %4d ^ %4d %% %4d"\r\n#elif defined(TEST_MUL)\r\n"50*modmul %4d %4d %4d"\r\n#elif defined(TEST_SQR)\r\n"100*modsqr %4d %4d %4d"\r\n#elif defined(TEST_GCD)\r\n"3*gcd %4d %4d %4d"\r\n#elif defined(TEST_KRON)\r\n"3*kronecker %4d %4d %4d"\r\n#elif defined(TEST_INV)\r\n"2*inv %4d %4d mod %4d"\r\n#else\r\n"2*sqrt [prime == %d (mod 64)] %4d %4d mod %4d"\r\n#endif\r\n" -> %8.6fms %5.1f (%ld)\n",\r\n#ifdef TEST_SQRT\r\nP_MOD_64,\r\n#endif\r\nsizes[i],sizes[i],sizes[i],tm*1000.0/num,tm*mul_c[i]/num, num);\r\nnum/=7;\r\nif (num <= 0) num=1;\r\n}\r\nreturn;\r\nerr:\r\nERR_print_errors_fp(stderr);\r\n}\r\nstatic void genprime_cb(int p, int n, void *arg)\r\n{\r\nchar c='*';\r\nif (p == 0) c='.';\r\nif (p == 1) c='+';\r\nif (p == 2) c='*';\r\nif (p == 3) c='\n';\r\nputc(c, stderr);\r\nfflush(stderr);\r\n(void)n;\r\n(void)arg;\r\n}
