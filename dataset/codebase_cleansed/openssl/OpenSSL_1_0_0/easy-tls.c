static void\r\ntls_app_errflush(int child_p, char *errbuf, size_t num, void *apparg)\r\n{\r\nfputs(errbuf, stderr);\r\n}\r\nstruct tls_start_proxy_args\r\ntls_start_proxy_defaultargs(void)\r\n{\r\nstruct tls_start_proxy_args ret;\r\nret.fd = -1;\r\nret.client_p = -1;\r\nret.ctx = NULL;\r\nret.pid = NULL;\r\nret.infofd = NULL;\r\nreturn ret;\r\n}\r\nint\r\ntls_start_proxy(struct tls_start_proxy_args a, void *apparg)\r\n{\r\nint fds[2] = {-1, -1};\r\nint infofds[2] = {-1, -1};\r\nint r, getfd, getfl;\r\nint ret;\r\nDEBUG_MSG2("tls_start_proxy fd", a.fd);\r\nDEBUG_MSG2("tls_start_proxy client_p", a.client_p);\r\nif (a.fd == -1 || a.client_p == -1 || a.ctx == NULL)\r\nreturn 1;\r\nif (a.pid != NULL) {\r\n*a.pid = 0;\r\n}\r\nif (a.infofd != NULL) {\r\n*a.infofd = -1;\r\n}\r\nr = socketpair(AF_UNIX, SOCK_STREAM, 0, fds);\r\nif (r == -1)\r\nreturn -1;\r\nif (a.fd >= FD_SETSIZE || fds[0] >= FD_SETSIZE) {\r\nret = 2;\r\ngoto err;\r\n}\r\nif (a.infofd != NULL) {\r\nr = pipe(infofds);\r\nif (r == -1) {\r\nret = -3;\r\ngoto err;\r\n}\r\n}\r\nr = fork();\r\nif (r == -1) {\r\nret = -4;\r\ngoto err;\r\n}\r\nif (r == 0) {\r\nDEBUG_MSG("fork");\r\ntls_child_p = 1;\r\ntls_child_apparg = apparg;\r\nclose(fds[1]);\r\nif (infofds[0] != -1)\r\nclose(infofds[0]);\r\nTLS_APP_PROCESS_INIT(a.fd, a.client_p, apparg);\r\nDEBUG_MSG("TLS_APP_PROCESS_INIT");\r\ntls_proxy(fds[0], a.fd, infofds[1], a.ctx, a.client_p);\r\nexit(0);\r\n}\r\nif (a.pid != NULL)\r\n*a.pid = r;\r\nif (infofds[1] != -1) {\r\nclose(infofds[1]);\r\ninfofds[1] = -1;\r\n}\r\nclose(fds[0]);\r\nfds[0] = -1;\r\ngetfd = fcntl(a.fd, F_GETFD);\r\ngetfl = fcntl(a.fd, F_GETFL);\r\nr = dup2(fds[1], a.fd);\r\nclose(fds[1]);\r\nfds[1] = -1;\r\nif (r == -1) {\r\nret = -5;\r\ngoto err;\r\n}\r\nif (getfd != 1)\r\nfcntl(a.fd, F_SETFD, getfd);\r\nif (getfl & O_NONBLOCK)\r\n(void)tls_socket_nonblocking(a.fd);\r\nif (a.infofd != NULL)\r\n*a.infofd = infofds[0];\r\nreturn 0;\r\nerr:\r\nif (fds[0] != -1)\r\nclose(fds[0]);\r\nif (fds[1] != -1)\r\nclose(fds[1]);\r\nif (infofds[0] != -1)\r\nclose(infofds[0]);\r\nif (infofds[1] != -1)\r\nclose(infofds[1]);\r\nreturn ret;\r\n}\r\nstatic void\r\ntls_errflush(void *apparg)\r\n{\r\nif (errbuf_i == 0)\r\nreturn;\r\nassert(errbuf_i < sizeof errbuf);\r\nassert(errbuf[errbuf_i] == 0);\r\nif (errbuf_i == sizeof errbuf - 1) {\r\nerrbuf[errbuf_i - 1] = '\n';\r\n}\r\nTLS_APP_ERRFLUSH(tls_child_p, errbuf, errbuf_i, apparg);\r\nerrbuf_i = 0;\r\n}\r\nstatic void\r\ntls_errprintf(int flush, void *apparg, const char *fmt, ...)\r\n{\r\nva_list args;\r\nint r;\r\nif (errbuf_i < sizeof errbuf - 1) {\r\nsize_t n;\r\nva_start(args, fmt);\r\nn = (sizeof errbuf) - errbuf_i;\r\nr = vsnprintf(errbuf + errbuf_i, n, fmt, args);\r\nif (r >= n)\r\nr = n - 1;\r\nif (r >= 0) {\r\nerrbuf_i += r;\r\n} else {\r\nerrbuf_i = sizeof errbuf - 1;\r\nerrbuf[errbuf_i] = '\0';\r\n}\r\nassert(errbuf_i < sizeof errbuf);\r\nassert(errbuf[errbuf_i] == 0);\r\n}\r\n#ifndef TLS_CUMULATE_ERRORS\r\ntls_errflush(apparg);\r\n#else\r\nif (flush)\r\ntls_errflush(apparg);\r\n#endif\r\n}\r\nstatic char *\r\ntls_openssl_errors(const char *app_prefix_1, const char *app_prefix_2, const char *default_text, void *apparg)\r\n{\r\nstatic char reasons[255];\r\nsize_t reasons_i;\r\nunsigned long err;\r\nconst char *file;\r\nint line;\r\nconst char *data;\r\nint flags;\r\nchar *errstring;\r\nint printed_something = 0;\r\nreasons_i = 0;\r\nassert(app_prefix_1 != NULL);\r\nassert(app_prefix_2 != NULL);\r\nif (default_text == NULL)\r\ndefault_text = "?""?""?";\r\nwhile ((err = ERR_get_error_line_data(&file,&line,&data,&flags)) != 0) {\r\nif (reasons_i < sizeof reasons) {\r\nsize_t n;\r\nint r;\r\nn = (sizeof reasons) - reasons_i;\r\nr = snprintf(reasons + reasons_i, n, "%s%s", (reasons_i > 0 ? ", " : ""), ERR_reason_error_string(err)\r\nstatic int\r\ntls_init(void *apparg)\r\n{\r\nif (tls_init_done)\r\nreturn 0;\r\nSSL_load_error_strings();\r\nif (!SSL_library_init() ) {\r\ntls_errprintf(1, apparg, "SSL_library_init failed.\n");\r\nreturn -1;\r\n}\r\ntls_init_done = 1;\r\ntls_rand_seed();\r\nreturn 0;\r\n}\r\nstatic void\r\ntls_rand_seed_uniquely(void)\r\n{\r\nstruct {\r\npid_t pid;\r\ntime_t time;\r\nvoid *stack;\r\n} data;\r\ndata.pid = getpid();\r\ndata.time = time(NULL);\r\ndata.stack = (void *)&data;\r\nRAND_seed((const void *)&data, sizeof data);\r\n}\r\nvoid\r\ntls_rand_seed(void)\r\n{\r\nstruct {\r\nstruct utsname uname;\r\nint uname_1;\r\nint uname_2;\r\nuid_t uid;\r\nuid_t euid;\r\ngid_t gid;\r\ngid_t egid;\r\n} data;\r\ndata.uname_1 = uname(&data.uname);\r\ndata.uname_2 = errno;\r\ndata.uid = getuid();\r\ndata.euid = geteuid();\r\ndata.gid = getgid();\r\ndata.egid = getegid();\r\nRAND_seed((const void *)&data, sizeof data);\r\ntls_rand_seed_uniquely();\r\n}\r\nint\r\ntls_rand_seed_from_file(const char *filename, size_t n, void *apparg)\r\n{\r\nint r;\r\nif (tls_init(apparg) == -1)\r\nreturn -1;\r\ntls_rand_seed();\r\nr = RAND_load_file(filename, (n > 0 && n < LONG_MAX) ? (long)n : LONG_MAX);\r\nassert(1 < my_MIN_SEED_BYTES);\r\nif (n == 0)\r\nn = my_MIN_SEED_BYTES;\r\nif (r < n) {\r\ntls_errprintf(1, apparg, "rand_seed_from_file: could not read %d bytes from %s.\n", n, filename);\r\nreturn -1;\r\n} else {\r\ntls_rand_seeded_p = 1;\r\nreturn 0;\r\n}\r\n}\r\nvoid\r\ntls_rand_seed_from_memory(const void *buf, size_t n)\r\n{\r\nsize_t i = 0;\r\nwhile (i < n) {\r\nsize_t rest = n - i;\r\nint chunk = rest < INT_MAX ? (int)rest : INT_MAX;\r\nRAND_seed((const char *)buf + i, chunk);\r\ni += chunk;\r\n}\r\ntls_rand_seeded_p = 1;\r\n}\r\nstatic void\r\ntls_get_x509_subject_name_oneline(X509 *cert, struct tls_x509_name_string *namestring)\r\n{\r\nX509_NAME *name;\r\nif (cert == NULL) {\r\nnamestring->str[0] = '\0';\r\nreturn;\r\n}\r\nname = X509_get_subject_name(cert);\r\nassert(sizeof namestring->str >= 4);\r\nif (name == NULL) {\r\nnamestring->str[0] = '?';\r\nnamestring->str[1] = 0;\r\n} else {\r\nsize_t len;\r\nX509_NAME_oneline(name, namestring->str, sizeof namestring->str);\r\nlen = strlen(namestring->str);\r\nassert(namestring->str[len] == 0);\r\nassert(len < sizeof namestring->str);\r\nif (len+1 == sizeof namestring->str) {\r\nassert(namestring->str[len] == 0);\r\nnamestring->str[--len] = '.';\r\nnamestring->str[--len] = '.';\r\nnamestring->str[--len] = '.';\r\n}\r\n}\r\n}\r\nstatic int\r\nno_passphrase_callback(char *buf, int num, int w, void *arg)\r\n{\r\nreturn -1;\r\n}\r\nvoid\r\ntls_set_dhe1024(int i, void *apparg)\r\n{\r\nDSA *dsaparams;\r\nDH *dhparams;\r\nconst char *seed[] = { ";-) :-( :-) :-( ",\r\n";-) :-( :-) :-( ",\r\n"Random String no. 12",\r\n";-) :-( :-) :-( ",\r\n"hackers have even mo",\r\n};\r\nunsigned char seedbuf[20];\r\ntls_init(apparg);\r\nif (i >= 0) {\r\ni %= sizeof seed / sizeof seed[0];\r\nassert(strlen(seed[i]) == 20);\r\nmemcpy(seedbuf, seed[i], 20);\r\ndsaparams = DSA_generate_parameters(1024, seedbuf, 20, NULL, NULL, 0, NULL);\r\n} else {\r\ndsaparams = DSA_generate_parameters(1024, NULL, 0, NULL, NULL, 0, NULL);\r\n}\r\nif (dsaparams == NULL) {\r\ntls_openssl_errors("", "", NULL, apparg);\r\nreturn;\r\n}\r\ndhparams = DSA_dup_DH(dsaparams);\r\nDSA_free(dsaparams);\r\nif (dhparams == NULL) {\r\ntls_openssl_errors("", "", NULL, apparg);\r\nreturn;\r\n}\r\nif (tls_dhe1024 != NULL)\r\nDH_free(tls_dhe1024);\r\ntls_dhe1024 = dhparams;\r\n}\r\nstruct tls_create_ctx_args\r\ntls_create_ctx_defaultargs(void)\r\n{\r\nstruct tls_create_ctx_args ret;\r\nret.client_p = 0;\r\nret.certificate_file = NULL;\r\nret.key_file = NULL;\r\nret.ca_file = NULL;\r\nret.verify_depth = -1;\r\nret.fail_unless_verified = 0;\r\nret.export_p = 0;\r\nreturn ret;\r\n}\r\nSSL_CTX *\r\ntls_create_ctx(struct tls_create_ctx_args a, void *apparg)\r\n{\r\nint r;\r\nstatic long context_num = 0;\r\nSSL_CTX *ret;\r\nconst char *err_pref_1 = "", *err_pref_2 = "";\r\nif (tls_init(apparg) == -1)\r\nreturn NULL;\r\nret = SSL_CTX_new((a.client_p? SSLv23_client_method:SSLv23_server_method)());\r\nif (ret == NULL)\r\ngoto err;\r\nSSL_CTX_set_default_passwd_cb(ret, no_passphrase_callback);\r\nSSL_CTX_set_mode(ret, SSL_MODE_ENABLE_PARTIAL_WRITE);\r\nif ((a.certificate_file != NULL) || (a.key_file != NULL)) {\r\nif (a.key_file == NULL) {\r\ntls_errprintf(1, apparg, "Need a key file.\n");\r\ngoto err_return;\r\n}\r\nif (a.certificate_file == NULL) {\r\ntls_errprintf(1, apparg, "Need a certificate chain file.\n");\r\ngoto err_return;\r\n}\r\nif (!SSL_CTX_use_PrivateKey_file(ret, a.key_file, SSL_FILETYPE_PEM))\r\ngoto err;\r\nif (!tls_rand_seeded_p) {\r\nif (tls_rand_seed_from_file(a.key_file, 0, apparg) == -1)\r\ngoto err_return;\r\n}\r\nif (!SSL_CTX_use_certificate_chain_file(ret, a.certificate_file))\r\ngoto err;\r\nif (!SSL_CTX_check_private_key(ret)) {\r\ntls_errprintf(1, apparg, "Private key \"%s\" does not match certificate \"%s\".\n", a.key_file, a.certificate_file);\r\ngoto err_peek;\r\n}\r\n}\r\nif ((a.ca_file != NULL) || (a.verify_depth > 0)) {\r\ncontext_num++;\r\nr = SSL_CTX_set_session_id_context(ret, (const void *)&context_num, (unsigned int)sizeof context_num);\r\nif (!r)\r\ngoto err;\r\nSSL_CTX_set_verify(ret, SSL_VERIFY_PEER | (a.fail_unless_verified ? SSL_VERIFY_FAIL_IF_NO_PEER_CERT : 0), 0);\r\nif (!a.fail_unless_verified)\r\nSSL_CTX_set_cert_verify_callback(ret, verify_dont_fail_cb, NULL);\r\nif (a.verify_depth > 0)\r\nSSL_CTX_set_verify_depth(ret, a.verify_depth);\r\nif (a.ca_file != NULL) {\r\nr = SSL_CTX_load_verify_locations(ret, a.ca_file, NULL );\r\nif (!r) {\r\nerr_pref_1 = " while processing certificate file ";\r\nerr_pref_2 = a.ca_file;\r\ngoto err;\r\n}\r\nif (!a.client_p) {\r\nSSL_CTX_set_client_CA_list(ret, SSL_load_client_CA_file(a.ca_file));\r\nif (SSL_CTX_get_client_CA_list(ret) == NULL) {\r\ntls_errprintf(1, apparg, "Could not set client CA list from \"%s\".\n", a.ca_file);\r\ngoto err_peek;\r\n}\r\n}\r\n}\r\n}\r\nif (!a.client_p) {\r\nif (tls_dhe1024 == NULL) {\r\nint i;\r\nRAND_bytes((unsigned char *) &i, sizeof i);\r\nif (i < 0)\r\ni = -i;\r\nif (i < 0)\r\ni = 0;\r\ntls_set_dhe1024(i, apparg);\r\nif (tls_dhe1024 == NULL)\r\ngoto err_return;\r\n}\r\nif (!SSL_CTX_set_tmp_dh(ret, tls_dhe1024))\r\ngoto err;\r\nSSL_CTX_set_options(ret, SSL_OP_SINGLE_DH_USE);\r\n}\r\n#ifndef NO_RSA\r\nif (!a.client_p && a.export_p) {\r\nRSA *tmpkey;\r\ntmpkey = RSA_generate_key(512, RSA_F4, 0, NULL);\r\nif (tmpkey == NULL)\r\ngoto err;\r\nif (!SSL_CTX_set_tmp_rsa(ret, tmpkey)) {\r\nRSA_free(tmpkey);\r\ngoto err;\r\n}\r\nRSA_free(tmpkey);\r\n}\r\n#endif\r\nreturn ret;\r\nerr_peek:\r\nif (!ERR_peek_error())\r\ngoto err_return;\r\nerr:\r\ntls_openssl_errors(err_pref_1, err_pref_2, NULL, apparg);\r\nerr_return:\r\nif (ret != NULL)\r\nSSL_CTX_free(ret);\r\nreturn NULL;\r\n}\r\nstatic int\r\ntls_socket_nonblocking(int fd)\r\n{\r\nint v, r;\r\nv = fcntl(fd, F_GETFL, 0);\r\nif (v == -1) {\r\nif (errno == EINVAL)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nr = fcntl(fd, F_SETFL, v | O_NONBLOCK);\r\nif (r == -1) {\r\nif (errno == EINVAL)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmax(int a, int b)\r\n{\r\nreturn a > b ? a : b;\r\n}\r\nstatic void\r\ntls_sockets_select(int read_select_1, int read_select_2, int write_select_1, int write_select_2, int seconds )\r\n{\r\nint maxfd, n;\r\nfd_set reads, writes;\r\nstruct timeval timeout;\r\nstruct timeval *timeout_p;\r\nassert(read_select_1 >= -1 && read_select_2 >= -1 && write_select_1 >= -1 && write_select_2 >= -1);\r\nassert(read_select_1 < FD_SETSIZE && read_select_2 < FD_SETSIZE -1 && write_select_1 < FD_SETSIZE -1 && write_select_2 < FD_SETSIZE -1);\r\nmaxfd = max(max(read_select_1, read_select_2), max(write_select_1, write_select_2));\r\nassert(maxfd >= 0);\r\nFD_ZERO(&reads);\r\nFD_ZERO(&writes);\r\nfor(n = 0; n < 4; ++n) {\r\nint i = n % 2;\r\nint w = n >= 2;\r\nint fd;\r\nif (i == 0 && w == 0)\r\nfd = read_select_1;\r\nelse if (i == 1 && w == 0)\r\nfd = read_select_2;\r\nelse if (i == 0 && w == 1)\r\nfd = write_select_1;\r\nelse {\r\nassert(i == 1 && w == 1);\r\nfd = write_select_2;\r\n}\r\nif (fd >= 0) {\r\nif (w == 0)\r\nFD_SET(fd, &reads);\r\nelse\r\nFD_SET(fd, &writes);\r\n}\r\n}\r\nif (seconds >= 0) {\r\ntimeout.tv_sec = seconds;\r\ntimeout.tv_usec = 0;\r\ntimeout_p = &timeout;\r\n} else\r\ntimeout_p = NULL;\r\nDEBUG_MSG2("select no.", ++tls_select_count);\r\nselect(maxfd + 1, &reads, &writes, (fd_set *) NULL, timeout_p);\r\nDEBUG_MSG("cont.");\r\n}\r\nstatic void write_info(SSL *ssl, int *info_fd)\r\n{\r\nif (*info_fd != -1) {\r\nlong v;\r\nint v_ok;\r\nstruct tls_x509_name_string peer;\r\nchar infobuf[TLS_INFO_SIZE];\r\nint r;\r\nDEBUG_MSG("write_info");\r\nv = SSL_get_verify_result(ssl);\r\nv_ok = (v == X509_V_OK) ? 'A' : 'E';\r\n{\r\nX509 *peercert;\r\npeercert = SSL_get_peer_certificate(ssl);\r\ntls_get_x509_subject_name_oneline(peercert, &peer);\r\nif (peercert != NULL)\r\nX509_free(peercert);\r\n}\r\nif (peer.str[0] == '\0')\r\nv_ok = '0';\r\nelse\r\nif (strchr(peer.str, '\n')) {\r\n*strchr(peer.str, '\n') = '\0';\r\n}\r\nr = snprintf(infobuf, sizeof infobuf, "%c:%s\n%s\n", v_ok, X509_verify_cert_error_string(v), peer.str);\r\nDEBUG_MSG2("snprintf", r);\r\nif (r == -1 || r >= sizeof infobuf)\r\nr = sizeof infobuf - 1;\r\nwrite(*info_fd, infobuf, r);\r\nclose (*info_fd);\r\n*info_fd = -1;\r\n}\r\n}\r\nstatic void\r\ntls_proxy(int clear_fd, int tls_fd, int info_fd, SSL_CTX *ctx, int client_p)\r\n{\r\nstruct tunnelbuf clear_to_tls, tls_to_clear;\r\nSSL *ssl;\r\nBIO *rbio, *wbio;\r\nint closed, in_handshake;\r\nconst char *err_pref_1 = "", *err_pref_2 = "";\r\nconst char *err_def = NULL;\r\nassert(clear_fd != -1);\r\nassert(tls_fd != -1);\r\nassert(clear_fd < FD_SETSIZE);\r\nassert(tls_fd < FD_SETSIZE);\r\nassert(ctx != NULL);\r\ntls_rand_seed_uniquely();\r\ntls_socket_nonblocking(clear_fd);\r\nDEBUG_MSG2("clear_fd", clear_fd);\r\ntls_socket_nonblocking(tls_fd);\r\nDEBUG_MSG2("tls_fd", tls_fd);\r\nssl = SSL_new(ctx);\r\nif (ssl == NULL)\r\ngoto err;\r\nDEBUG_MSG("SSL_new");\r\nif (!SSL_set_fd(ssl, tls_fd))\r\ngoto err;\r\nrbio = SSL_get_rbio(ssl);\r\nwbio = SSL_get_wbio(ssl);\r\nassert(rbio != NULL);\r\nassert(wbio != NULL);\r\nif (client_p)\r\nSSL_set_connect_state(ssl);\r\nelse\r\nSSL_set_accept_state(ssl);\r\nclosed = 0;\r\nin_handshake = 1;\r\ntls_to_clear.len = 0;\r\ntls_to_clear.offset = 0;\r\nclear_to_tls.len = 0;\r\nclear_to_tls.offset = 0;\r\nerr_def = "I/O error";\r\ndo {\r\nint clear_read_select = 0, clear_write_select = 0,\r\ntls_read_select = 0, tls_write_select = 0,\r\nprogress = 0;\r\nint r;\r\nunsigned long num_read = BIO_number_read(rbio),\r\nnum_written = BIO_number_written(wbio);\r\nDEBUG_MSG2("loop iteration", ++tls_loop_count);\r\nif (in_handshake) {\r\nDEBUG_MSG("in_handshake");\r\nif (client_p)\r\nr = tls_connect_attempt(ssl, &tls_write_select, &tls_read_select, &closed, &progress, &err_pref_1);\r\nelse\r\nr = tls_accept_attempt(ssl, &tls_write_select, &tls_read_select, &closed, &progress, &err_pref_1);\r\nif (r != 0) {\r\nwrite_info(ssl, &info_fd);\r\ngoto err;\r\n}\r\nif (closed)\r\ngoto err_return;\r\nif (!SSL_in_init(ssl)) {\r\nin_handshake = 0;\r\nwrite_info(ssl, &info_fd);\r\n}\r\n}\r\nif (clear_to_tls.len != 0 && !in_handshake) {\r\nassert(!closed);\r\nr = tls_write_attempt(ssl, &clear_to_tls, &tls_write_select, &tls_read_select, &closed, &progress, &err_pref_1);\r\nif (r != 0)\r\ngoto err;\r\nif (closed) {\r\nassert(progress);\r\ntls_to_clear.offset = 0;\r\ntls_to_clear.len = 0;\r\n}\r\n}\r\nif (tls_to_clear.len != 0) {\r\nassert(!closed);\r\nr = write_attempt(clear_fd, &tls_to_clear, &clear_write_select, &closed, &progress);\r\nif (r != 0)\r\ngoto err_return;\r\nif (closed) {\r\nassert(progress);\r\nclear_to_tls.offset = 0;\r\nclear_to_tls.len = 0;\r\n}\r\n}\r\nif (!closed) {\r\nif (clear_to_tls.offset + clear_to_tls.len < sizeof clear_to_tls.buf) {\r\nr = read_attempt(clear_fd, &clear_to_tls, &clear_read_select, &closed, &progress);\r\nif (r != 0)\r\ngoto err_return;\r\nif (closed) {\r\nr = SSL_shutdown(ssl);\r\nDEBUG_MSG2("SSL_shutdown", r);\r\n}\r\n}\r\n}\r\nif (!closed && !in_handshake) {\r\nif (tls_to_clear.offset + tls_to_clear.len < sizeof tls_to_clear.buf) {\r\nr = tls_read_attempt(ssl, &tls_to_clear, &tls_write_select, &tls_read_select, &closed, &progress, &err_pref_1);\r\nif (r != 0)\r\ngoto err;\r\nif (closed) {\r\nr = SSL_shutdown(ssl);\r\nDEBUG_MSG2("SSL_shutdown", r);\r\n}\r\n}\r\n}\r\nif (!progress) {\r\nDEBUG_MSG("!progress?");\r\nif (num_read != BIO_number_read(rbio) || num_written != BIO_number_written(wbio))\r\nprogress = 1;\r\nif (!progress) {\r\nDEBUG_MSG("!progress");\r\nassert(clear_read_select || tls_read_select || clear_write_select || tls_write_select);\r\ntls_sockets_select(clear_read_select ? clear_fd : -1, tls_read_select ? tls_fd : -1, clear_write_select ? clear_fd : -1, tls_write_select ? tls_fd : -1, -1);\r\n}\r\n}\r\n} while (!closed);\r\nreturn;\r\nerr:\r\ntls_openssl_errors(err_pref_1, err_pref_2, err_def, tls_child_apparg);\r\nerr_return:\r\nreturn;\r\n}\r\nstatic int\r\ntls_get_error(SSL *ssl, int r, int *write_select, int *read_select, int *closed, int *progress)\r\n{\r\nint err = SSL_get_error(ssl, r);\r\nif (err == SSL_ERROR_NONE) {\r\nassert(r > 0);\r\n*progress = 1;\r\nreturn 0;\r\n}\r\nassert(r <= 0);\r\nswitch (err) {\r\ncase SSL_ERROR_ZERO_RETURN:\r\nassert(r == 0);\r\n*closed = 1;\r\n*progress = 1;\r\nreturn 0;\r\ncase SSL_ERROR_WANT_WRITE:\r\n*write_select = 1;\r\nreturn 0;\r\ncase SSL_ERROR_WANT_READ:\r\n*read_select = 1;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int\r\ntls_connect_attempt(SSL *ssl, int *write_select, int *read_select, int *closed, int *progress, const char **err_pref)\r\n{\r\nint n, r;\r\nDEBUG_MSG("tls_connect_attempt");\r\nn = SSL_connect(ssl);\r\nDEBUG_MSG2("SSL_connect",n);\r\nr = tls_get_error(ssl, n, write_select, read_select, closed, progress);\r\nif (r == -1)\r\n*err_pref = " during SSL_connect";\r\nreturn r;\r\n}\r\nstatic int\r\ntls_accept_attempt(SSL *ssl, int *write_select, int *read_select, int *closed, int *progress, const char **err_pref)\r\n{\r\nint n, r;\r\nDEBUG_MSG("tls_accept_attempt");\r\nn = SSL_accept(ssl);\r\nDEBUG_MSG2("SSL_accept",n);\r\nr = tls_get_error(ssl, n, write_select, read_select, closed, progress);\r\nif (r == -1)\r\n*err_pref = " during SSL_accept";\r\nreturn r;\r\n}\r\nstatic int\r\ntls_write_attempt(SSL *ssl, struct tunnelbuf *buf, int *write_select, int *read_select, int *closed, int *progress, const char **err_pref)\r\n{\r\nint n, r;\r\nDEBUG_MSG("tls_write_attempt");\r\nn = SSL_write(ssl, buf->buf + buf->offset, buf->len);\r\nDEBUG_MSG2("SSL_write",n);\r\nr = tls_get_error(ssl, n, write_select, read_select, closed, progress);\r\nif (n > 0) {\r\nbuf->len -= n;\r\nassert(buf->len >= 0);\r\nif (buf->len == 0)\r\nbuf->offset = 0;\r\nelse\r\nbuf->offset += n;\r\n}\r\nif (r == -1)\r\n*err_pref = " during SSL_write";\r\nreturn r;\r\n}\r\nstatic int\r\ntls_read_attempt(SSL *ssl, struct tunnelbuf *buf, int *write_select, int *read_select, int *closed, int *progress, const char **err_pref)\r\n{\r\nint n, r;\r\nsize_t total;\r\nDEBUG_MSG("tls_read_attempt");\r\ntotal = buf->offset + buf->len;\r\nassert(total < sizeof buf->buf);\r\nn = SSL_read(ssl, buf->buf + total, (sizeof buf->buf) - total);\r\nDEBUG_MSG2("SSL_read",n);\r\nr = tls_get_error(ssl, n, write_select, read_select, closed, progress);\r\nif (n > 0) {\r\nbuf->len += n;\r\nassert(buf->offset + buf->len <= sizeof buf->buf);\r\n}\r\nif (r == -1)\r\n*err_pref = " during SSL_read";\r\nreturn r;\r\n}\r\nstatic int\r\nget_error(int r, int *select, int *closed, int *progress)\r\n{\r\nif (r >= 0) {\r\n*progress = 1;\r\nif (r == 0)\r\n*closed = 1;\r\nreturn 0;\r\n} else {\r\nassert(r == -1);\r\nif (errno == EAGAIN || errno == EWOULDBLOCK) {\r\n*select = 1;\r\nreturn 0;\r\n} else if (errno == EPIPE) {\r\n*progress = 1;\r\n*closed = 1;\r\nreturn 0;\r\n} else\r\nreturn -1;\r\n}\r\n}\r\nstatic int write_attempt(int fd, struct tunnelbuf *buf, int *select, int *closed, int *progress)\r\n{\r\nint n, r;\r\nDEBUG_MSG("write_attempt");\r\nn = write(fd, buf->buf + buf->offset, buf->len);\r\nDEBUG_MSG2("write",n);\r\nr = get_error(n, select, closed, progress);\r\nif (n > 0) {\r\nbuf->len -= n;\r\nassert(buf->len >= 0);\r\nif (buf->len == 0)\r\nbuf->offset = 0;\r\nelse\r\nbuf->offset += n;\r\n}\r\nif (r == -1)\r\ntls_errprintf(1, tls_child_apparg, "write error: %s\n", strerror(errno));\r\nreturn r;\r\n}\r\nstatic int\r\nread_attempt(int fd, struct tunnelbuf *buf, int *select, int *closed, int *progress)\r\n{\r\nint n, r;\r\nsize_t total;\r\nDEBUG_MSG("read_attempt");\r\ntotal = buf->offset + buf->len;\r\nassert(total < sizeof buf->buf);\r\nn = read(fd, buf->buf + total, (sizeof buf->buf) - total);\r\nDEBUG_MSG2("read",n);\r\nr = get_error(n, select, closed, progress);\r\nif (n > 0) {\r\nbuf->len += n;\r\nassert(buf->offset + buf->len <= sizeof buf->buf);\r\n}\r\nif (r == -1)\r\ntls_errprintf(1, tls_child_apparg, "read error: %s\n", strerror(errno));\r\nreturn r;\r\n}
