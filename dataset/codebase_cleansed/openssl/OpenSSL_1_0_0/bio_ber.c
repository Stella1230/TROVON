BIO_METHOD *BIO_f_ber(void)\r\n{\r\nreturn(&methods_ber);\r\n}\r\nstatic int ber_new(BIO *bi)\r\n{\r\nBIO_BER_CTX *ctx;\r\nctx=(BIO_BER_CTX *)OPENSSL_malloc(sizeof(BIO_BER_CTX));\r\nif (ctx == NULL) return(0);\r\nmemset((char *)ctx,0,sizeof(BIO_BER_CTX));\r\nbi->init=0;\r\nbi->ptr=(char *)ctx;\r\nbi->flags=0;\r\nreturn(1);\r\n}\r\nstatic int ber_free(BIO *a)\r\n{\r\nBIO_BER_CTX *b;\r\nif (a == NULL) return(0);\r\nb=(BIO_BER_CTX *)a->ptr;\r\nOPENSSL_cleanse(a->ptr,sizeof(BIO_BER_CTX));\r\nOPENSSL_free(a->ptr);\r\na->ptr=NULL;\r\na->init=0;\r\na->flags=0;\r\nreturn(1);\r\n}\r\nint bio_ber_get_header(BIO *bio, BIO_BER_CTX *ctx)\r\n{\r\nchar buf[64];\r\nint i,j,n;\r\nint ret;\r\nunsigned char *p;\r\nunsigned long length\r\nint tag;\r\nint class;\r\nlong max;\r\nBIO_clear_retry_flags(b);\r\nif (ctx->buf_off != 0)\r\n{\r\np=ctx->buf;\r\nj=ctx->buf_off;\r\nn=ctx->buf_len-j;\r\nfor (i=0; i<n; i++)\r\n{\r\np[0]=p[j];\r\np++;\r\n}\r\nctx->buf_len-j;\r\nctx->buf_off=0;\r\n}\r\ni=BER_BUF_SIZE-ctx->buf_len;\r\nif (i)\r\n{\r\ni=BIO_read(bio->next_bio,&(ctx->buf[ctx->buf_len]),i);\r\nif (i <= 0)\r\n{\r\nBIO_copy_next_retry(b);\r\nreturn(i);\r\n}\r\nelse\r\nctx->buf_len+=i;\r\n}\r\nmax=ctx->buf_len;\r\np=ctx->buf;\r\nret=ASN1_get_object(&p,&length,&tag,&class,max);\r\nif (ret & 0x80)\r\n{\r\nif ((ctx->buf_len < BER_BUF_SIZE) &&\r\n(ERR_GET_REASON(ERR_peek_error()) == ASN1_R_TOO_LONG))\r\n{\r\nERR_clear_error();\r\nBIO_set_retry_read(b);\r\n}\r\nreturn(-1);\r\n}\r\nif ((ctx->tag >= 0) && (ctx->tag != tag))\r\n{\r\nBIOerr(BIO_F_BIO_BER_GET_HEADER,BIO_R_TAG_MISMATCH);\r\nsprintf(buf,"tag=%d, got %d",ctx->tag,tag);\r\nERR_add_error_data(1,buf);\r\nreturn(-1);\r\n}\r\nif (ret & 0x01)\r\nif (ret & V_ASN1_CONSTRUCTED)\r\n}\r\nstatic int ber_read(BIO *b, char *out, int outl)\r\n{\r\nint ret=0,i,n;\r\nBIO_BER_CTX *ctx;\r\nBIO_clear_retry_flags(b);\r\nif (out == NULL) return(0);\r\nctx=(BIO_BER_CTX *)b->ptr;\r\nif ((ctx == NULL) || (b->next_bio == NULL)) return(0);\r\nif (ctx->finished) return(0);\r\nagain:\r\nif (ctx->num_left > 0)\r\n{\r\nif (ctx->num_left < outl)\r\nn=ctx->num_left;\r\nelse\r\nn=outl;\r\ni=BIO_read(b->next_bio,out,n);\r\nif (i <= 0)\r\n{\r\nBIO_copy_next_retry(b);\r\nreturn(i);\r\n}\r\nctx->num_left-=i;\r\noutl-=i;\r\nret+=i;\r\nif (ctx->num_left <= 0)\r\n{\r\nctx->depth--;\r\nif (ctx->depth <= 0)\r\nctx->finished=1;\r\n}\r\nif (outl <= 0)\r\nreturn(ret);\r\nelse\r\ngoto again;\r\n}\r\nelse\r\n{\r\n}\r\n}\r\nstatic int ber_write(BIO *b, char *in, int inl)\r\n{\r\nint ret=0,n,i;\r\nBIO_ENC_CTX *ctx;\r\nctx=(BIO_ENC_CTX *)b->ptr;\r\nret=inl;\r\nBIO_clear_retry_flags(b);\r\nn=ctx->buf_len-ctx->buf_off;\r\nwhile (n > 0)\r\n{\r\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\r\nif (i <= 0)\r\n{\r\nBIO_copy_next_retry(b);\r\nreturn(i);\r\n}\r\nctx->buf_off+=i;\r\nn-=i;\r\n}\r\nif ((in == NULL) || (inl <= 0)) return(0);\r\nctx->buf_off=0;\r\nwhile (inl > 0)\r\n{\r\nn=(inl > ENC_BLOCK_SIZE)?ENC_BLOCK_SIZE:inl;\r\nEVP_CipherUpdate(&(ctx->cipher),\r\n(unsigned char *)ctx->buf,&ctx->buf_len,\r\n(unsigned char *)in,n);\r\ninl-=n;\r\nin+=n;\r\nctx->buf_off=0;\r\nn=ctx->buf_len;\r\nwhile (n > 0)\r\n{\r\ni=BIO_write(b->next_bio,&(ctx->buf[ctx->buf_off]),n);\r\nif (i <= 0)\r\n{\r\nBIO_copy_next_retry(b);\r\nreturn(i);\r\n}\r\nn-=i;\r\nctx->buf_off+=i;\r\n}\r\nctx->buf_len=0;\r\nctx->buf_off=0;\r\n}\r\nBIO_copy_next_retry(b);\r\nreturn(ret);\r\n}\r\nstatic long ber_ctrl(BIO *b, int cmd, long num, char *ptr)\r\n{\r\nBIO *dbio;\r\nBIO_ENC_CTX *ctx,*dctx;\r\nlong ret=1;\r\nint i;\r\nctx=(BIO_ENC_CTX *)b->ptr;\r\nswitch (cmd)\r\n{\r\ncase BIO_CTRL_RESET:\r\nctx->ok=1;\r\nctx->finished=0;\r\nEVP_CipherInit_ex(&(ctx->cipher),NULL,NULL,NULL,NULL,\r\nctx->cipher.berrypt);\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_EOF:\r\nif (ctx->cont <= 0)\r\nret=1;\r\nelse\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_WPENDING:\r\nret=ctx->buf_len-ctx->buf_off;\r\nif (ret <= 0)\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_PENDING:\r\nret=ctx->buf_len-ctx->buf_off;\r\nif (ret <= 0)\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_FLUSH:\r\nagain:\r\nwhile (ctx->buf_len != ctx->buf_off)\r\n{\r\ni=ber_write(b,NULL,0);\r\nif (i < 0)\r\n{\r\nret=i;\r\nbreak;\r\n}\r\n}\r\nif (!ctx->finished)\r\n{\r\nctx->finished=1;\r\nctx->buf_off=0;\r\nret=EVP_CipherFinal_ex(&(ctx->cipher),\r\n(unsigned char *)ctx->buf,\r\n&(ctx->buf_len));\r\nctx->ok=(int)ret;\r\nif (ret <= 0) break;\r\ngoto again;\r\n}\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_C_GET_CIPHER_STATUS:\r\nret=(long)ctx->ok;\r\nbreak;\r\ncase BIO_C_DO_STATE_MACHINE:\r\nBIO_clear_retry_flags(b);\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nBIO_copy_next_retry(b);\r\nbreak;\r\ncase BIO_CTRL_DUP:\r\ndbio=(BIO *)ptr;\r\ndctx=(BIO_ENC_CTX *)dbio->ptr;\r\nmemcpy(&(dctx->cipher),&(ctx->cipher),sizeof(ctx->cipher));\r\ndbio->init=1;\r\nbreak;\r\ndefault:\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic long ber_callback_ctrl(BIO *b, int cmd, void *(*fp)())\r\n{\r\nlong ret=1;\r\nif (b->next_bio == NULL) return(0);\r\nswitch (cmd)\r\n{\r\ndefault:\r\nret=BIO_callback_ctrl(b->next_bio,cmd,fp);\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nvoid BIO_set_cipher(BIO *b, EVP_CIPHER *c, unsigned char *k, unsigned char *i,\r\nint e)\r\n{\r\nBIO_ENC_CTX *ctx;\r\nif (b == NULL) return;\r\nif ((b->callback != NULL) &&\r\n(b->callback(b,BIO_CB_CTRL,(char *)c,BIO_CTRL_SET,e,0L) <= 0))\r\nreturn;\r\nb->init=1;\r\nctx=(BIO_ENC_CTX *)b->ptr;\r\nEVP_CipherInit_ex(&(ctx->cipher),c,NULL,k,i,e);\r\nif (b->callback != NULL)\r\nb->callback(b,BIO_CB_CTRL,(char *)c,BIO_CTRL_SET,e,1L);\r\n}
