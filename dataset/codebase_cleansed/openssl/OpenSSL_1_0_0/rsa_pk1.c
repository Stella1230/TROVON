int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,\r\nconst unsigned char *from, int flen)\r\n{\r\nint j;\r\nunsigned char *p;\r\nif (flen > (tlen-RSA_PKCS1_PADDING_SIZE))\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\r\nreturn(0);\r\n}\r\np=(unsigned char *)to;\r\n*(p++)=0;\r\n*(p++)=1;\r\nj=tlen-3-flen;\r\nmemset(p,0xff,j);\r\np+=j;\r\n*(p++)='\0';\r\nmemcpy(p,from,(unsigned int)flen);\r\nreturn(1);\r\n}\r\nint RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,\r\nconst unsigned char *from, int flen, int num)\r\n{\r\nint i,j;\r\nconst unsigned char *p;\r\np=from;\r\nif ((num != (flen+1)) || (*(p++) != 01))\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BLOCK_TYPE_IS_NOT_01);\r\nreturn(-1);\r\n}\r\nj=flen-1;\r\nfor (i=0; i<j; i++)\r\n{\r\nif (*p != 0xff)\r\n{\r\nif (*p == 0)\r\n{ p++; break; }\r\nelse {\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BAD_FIXED_HEADER_DECRYPT);\r\nreturn(-1);\r\n}\r\n}\r\np++;\r\n}\r\nif (i == j)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_NULL_BEFORE_BLOCK_MISSING);\r\nreturn(-1);\r\n}\r\nif (i < 8)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_BAD_PAD_BYTE_COUNT);\r\nreturn(-1);\r\n}\r\ni++;\r\nj-=i;\r\nif (j > tlen)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,RSA_R_DATA_TOO_LARGE);\r\nreturn(-1);\r\n}\r\nmemcpy(to,p,(unsigned int)j);\r\nreturn(j);\r\n}\r\nint RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,\r\nconst unsigned char *from, int flen)\r\n{\r\nint i,j;\r\nunsigned char *p;\r\nif (flen > (tlen-11))\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2,RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\r\nreturn(0);\r\n}\r\np=(unsigned char *)to;\r\n*(p++)=0;\r\n*(p++)=2;\r\nj=tlen-3-flen;\r\nif (RAND_bytes(p,j) <= 0)\r\nreturn(0);\r\nfor (i=0; i<j; i++)\r\n{\r\nif (*p == '\0')\r\ndo {\r\nif (RAND_bytes(p,1) <= 0)\r\nreturn(0);\r\n} while (*p == '\0');\r\np++;\r\n}\r\n*(p++)='\0';\r\nmemcpy(p,from,(unsigned int)flen);\r\nreturn(1);\r\n}\r\nint RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,\r\nconst unsigned char *from, int flen, int num)\r\n{\r\nint i,j;\r\nconst unsigned char *p;\r\np=from;\r\nif ((num != (flen+1)) || (*(p++) != 02))\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_BLOCK_TYPE_IS_NOT_02);\r\nreturn(-1);\r\n}\r\n#ifdef PKCS1_CHECK\r\nreturn(num-11);\r\n#endif\r\nj=flen-1;\r\nfor (i=0; i<j; i++)\r\nif (*(p++) == 0) break;\r\nif (i == j)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_NULL_BEFORE_BLOCK_MISSING);\r\nreturn(-1);\r\n}\r\nif (i < 8)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_BAD_PAD_BYTE_COUNT);\r\nreturn(-1);\r\n}\r\ni++;\r\nj-=i;\r\nif (j > tlen)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,RSA_R_DATA_TOO_LARGE);\r\nreturn(-1);\r\n}\r\nmemcpy(to,p,(unsigned int)j);\r\nreturn(j);\r\n}
