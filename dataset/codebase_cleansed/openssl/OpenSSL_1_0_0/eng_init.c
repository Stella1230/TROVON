int engine_unlocked_init(ENGINE *e)\r\n{\r\nint to_return = 1;\r\nif((e->funct_ref == 0) && e->init)\r\nto_return = e->init(e);\r\nif(to_return)\r\n{\r\ne->struct_ref++;\r\ne->funct_ref++;\r\nengine_ref_debug(e, 0, 1)\r\nengine_ref_debug(e, 1, 1)\r\n}\r\nreturn to_return;\r\n}\r\nint engine_unlocked_finish(ENGINE *e, int unlock_for_handlers)\r\n{\r\nint to_return = 1;\r\ne->funct_ref--;\r\nengine_ref_debug(e, 1, -1);\r\nif((e->funct_ref == 0) && e->finish)\r\n{\r\nif(unlock_for_handlers)\r\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\r\nto_return = e->finish(e);\r\nif(unlock_for_handlers)\r\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\r\nif(!to_return)\r\nreturn 0;\r\n}\r\n#ifdef REF_CHECK\r\nif(e->funct_ref < 0)\r\n{\r\nfprintf(stderr,"ENGINE_finish, bad functional reference count\n");\r\nabort();\r\n}\r\n#endif\r\nif(!engine_free_util(e, 0))\r\n{\r\nENGINEerr(ENGINE_F_ENGINE_UNLOCKED_FINISH,ENGINE_R_FINISH_FAILED);\r\nreturn 0;\r\n}\r\nreturn to_return;\r\n}\r\nint ENGINE_init(ENGINE *e)\r\n{\r\nint ret;\r\nif(e == NULL)\r\n{\r\nENGINEerr(ENGINE_F_ENGINE_INIT,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn 0;\r\n}\r\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\r\nret = engine_unlocked_init(e);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\r\nreturn ret;\r\n}\r\nint ENGINE_finish(ENGINE *e)\r\n{\r\nint to_return = 1;\r\nif(e == NULL)\r\n{\r\nENGINEerr(ENGINE_F_ENGINE_FINISH,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn 0;\r\n}\r\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\r\nto_return = engine_unlocked_finish(e, 1);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\r\nif(!to_return)\r\n{\r\nENGINEerr(ENGINE_F_ENGINE_FINISH,ENGINE_R_FINISH_FAILED);\r\nreturn 0;\r\n}\r\nreturn to_return;\r\n}
