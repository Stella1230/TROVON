X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void)\r\n{\r\nreturn(&x509_dir_lookup);\r\n}\r\nstatic int dir_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\r\nchar **retp)\r\n{\r\nint ret=0;\r\nBY_DIR *ld;\r\nchar *dir;\r\nld=(BY_DIR *)ctx->method_data;\r\nswitch (cmd)\r\n{\r\ncase X509_L_ADD_DIR:\r\nif (argl == X509_FILETYPE_DEFAULT)\r\n{\r\nret=add_cert_dir(ld,X509_get_default_cert_dir(),\r\nX509_FILETYPE_PEM);\r\nif (!ret)\r\n{\r\nX509err(X509_F_DIR_CTRL,X509_R_LOADING_CERT_DIR);\r\n}\r\nelse\r\n{\r\ndir=(char *)Getenv(X509_get_default_cert_dir_env());\r\nret=add_cert_dir(ld,dir,X509_FILETYPE_PEM);\r\n}\r\n}\r\nelse\r\nret=add_cert_dir(ld,argp,(int)argl);\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic int new_dir(X509_LOOKUP *lu)\r\n{\r\nBY_DIR *a;\r\nif ((a=(BY_DIR *)Malloc(sizeof(BY_DIR))) == NULL)\r\nreturn(0);\r\nif ((a->buffer=BUF_MEM_new()) == NULL)\r\n{\r\nFree(a);\r\nreturn(0);\r\n}\r\na->num_dirs=0;\r\na->dirs=NULL;\r\na->dirs_type=NULL;\r\na->num_dirs_alloced=0;\r\nlu->method_data=(char *)a;\r\nreturn(1);\r\n}\r\nstatic void free_dir(X509_LOOKUP *lu)\r\n{\r\nBY_DIR *a;\r\nint i;\r\na=(BY_DIR *)lu->method_data;\r\nfor (i=0; i<a->num_dirs; i++)\r\nif (a->dirs[i] != NULL) Free(a->dirs[i]);\r\nif (a->dirs != NULL) Free(a->dirs);\r\nif (a->dirs_type != NULL) Free(a->dirs_type);\r\nif (a->buffer != NULL) BUF_MEM_free(a->buffer);\r\nFree(a);\r\n}\r\nstatic int add_cert_dir(BY_DIR *ctx, const char *dir, int type)\r\n{\r\nint j,len;\r\nint *ip;\r\nconst char *s,*ss,*p;\r\nchar **pp;\r\nif (dir == NULL || !*dir)\r\n{\r\nX509err(X509_F_ADD_CERT_DIR,X509_R_INVALID_DIRECTORY);\r\nreturn 0;\r\n}\r\ns=dir;\r\np=s;\r\nfor (;;)\r\n{\r\nif ((*p == LIST_SEPARATOR_CHAR) || (*p == '\0'))\r\n{\r\nss=s;\r\ns=p+1;\r\nlen=(int)(p-ss);\r\nif (len == 0) continue;\r\nfor (j=0; j<ctx->num_dirs; j++)\r\nif (strncmp(ctx->dirs[j],ss,(unsigned int)len) == 0)\r\ncontinue;\r\nif (ctx->num_dirs_alloced < (ctx->num_dirs+1))\r\n{\r\nctx->num_dirs_alloced+=10;\r\npp=(char **)Malloc(ctx->num_dirs_alloced*\r\nsizeof(char *));\r\nip=(int *)Malloc(ctx->num_dirs_alloced*\r\nsizeof(int));\r\nif ((pp == NULL) || (ip == NULL))\r\n{\r\nX509err(X509_F_ADD_CERT_DIR,ERR_R_MALLOC_FAILURE);\r\nreturn(0);\r\n}\r\nmemcpy(pp,ctx->dirs,(ctx->num_dirs_alloced-10)*\r\nsizeof(char *));\r\nmemcpy(ip,ctx->dirs_type,(ctx->num_dirs_alloced-10)*\r\nsizeof(int));\r\nif (ctx->dirs != NULL)\r\nFree((char *)ctx->dirs);\r\nif (ctx->dirs_type != NULL)\r\nFree((char *)ctx->dirs_type);\r\nctx->dirs=pp;\r\nctx->dirs_type=ip;\r\n}\r\nctx->dirs_type[ctx->num_dirs]=type;\r\nctx->dirs[ctx->num_dirs]=(char *)Malloc((unsigned int)len+1);\r\nif (ctx->dirs[ctx->num_dirs] == NULL) return(0);\r\nstrncpy(ctx->dirs[ctx->num_dirs],ss,(unsigned int)len);\r\nctx->dirs[ctx->num_dirs][len]='\0';\r\nctx->num_dirs++;\r\n}\r\nif (*p == '\0') break;\r\np++;\r\n}\r\nreturn(1);\r\n}\r\nstatic int get_cert_by_subject(X509_LOOKUP *xl, int type, X509_NAME *name,\r\nX509_OBJECT *ret)\r\n{\r\nBY_DIR *ctx;\r\nunion {\r\nstruct {\r\nX509 st_x509;\r\nX509_CINF st_x509_cinf;\r\n} x509;\r\nstruct {\r\nX509_CRL st_crl;\r\nX509_CRL_INFO st_crl_info;\r\n} crl;\r\n} data;\r\nint ok=0;\r\nint i,j,k;\r\nunsigned long h;\r\nBUF_MEM *b=NULL;\r\nstruct stat st;\r\nX509_OBJECT stmp,*tmp;\r\nconst char *postfix="";\r\nif (name == NULL) return(0);\r\nstmp.type=type;\r\nif (type == X509_LU_X509)\r\n{\r\ndata.x509.st_x509.cert_info= &data.x509.st_x509_cinf;\r\ndata.x509.st_x509_cinf.subject=name;\r\nstmp.data.x509= &data.x509.st_x509;\r\npostfix="";\r\n}\r\nelse if (type == X509_LU_CRL)\r\n{\r\ndata.crl.st_crl.crl= &data.crl.st_crl_info;\r\ndata.crl.st_crl_info.issuer=name;\r\nstmp.data.crl= &data.crl.st_crl;\r\npostfix="r";\r\n}\r\nelse\r\n{\r\nX509err(X509_F_GET_CERT_BY_SUBJECT,X509_R_WRONG_LOOKUP_TYPE);\r\ngoto finish;\r\n}\r\nif ((b=BUF_MEM_new()) == NULL)\r\n{\r\nX509err(X509_F_GET_CERT_BY_SUBJECT,ERR_R_BUF_LIB);\r\ngoto finish;\r\n}\r\nctx=(BY_DIR *)xl->method_data;\r\nh=X509_NAME_hash(name);\r\nfor (i=0; i<ctx->num_dirs; i++)\r\n{\r\nj=strlen(ctx->dirs[i])+1+8+6+1+1;\r\nif (!BUF_MEM_grow(b,j))\r\n{\r\nX509err(X509_F_GET_CERT_BY_SUBJECT,ERR_R_MALLOC_FAILURE);\r\ngoto finish;\r\n}\r\nk=0;\r\nfor (;;)\r\n{\r\nsprintf(b->data,"%s/%08lx.%s%d",ctx->dirs[i],h,\r\npostfix,k);\r\nk++;\r\nif (stat(b->data,&st) < 0)\r\nbreak;\r\nif (type == X509_LU_X509)\r\n{\r\nif ((X509_load_cert_file(xl,b->data,\r\nctx->dirs_type[i])) == 0)\r\nbreak;\r\n}\r\nelse if (type == X509_LU_CRL)\r\n{\r\nif ((X509_load_crl_file(xl,b->data,\r\nctx->dirs_type[i])) == 0)\r\nbreak;\r\n}\r\n}\r\nCRYPTO_r_lock(CRYPTO_LOCK_X509_STORE);\r\ntmp=(X509_OBJECT *)lh_retrieve(xl->store_ctx->certs,\r\n(char *)&stmp);\r\nCRYPTO_r_unlock(CRYPTO_LOCK_X509_STORE);\r\nif (tmp != NULL)\r\n{\r\nok=1;\r\nret->type=tmp->type;\r\nmemcpy(&ret->data,&tmp->data,sizeof(ret->data));\r\ngoto finish;\r\n}\r\n}\r\nfinish:\r\nif (b != NULL) BUF_MEM_free(b);\r\nreturn(ok);\r\n}
