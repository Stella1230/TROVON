void lh_free(LHASH *lh)\r\n{\r\nunsigned int i;\r\nLHASH_NODE *n,*nn;\r\nif(lh == NULL)\r\nreturn;\r\nfor (i=0; i<lh->num_nodes; i++)\r\n{\r\nn=lh->b[i];\r\nwhile (n != NULL)\r\n{\r\nnn=n->next;\r\nFree(n);\r\nn=nn;\r\n}\r\n}\r\nFree((char *)lh->b);\r\nFree((char *)lh);\r\n}\r\nchar *lh_insert(LHASH *lh, char *data)\r\n{\r\nunsigned long hash;\r\nLHASH_NODE *nn,**rn;\r\nchar *ret;\r\nlh->error=0;\r\nif (lh->up_load <= (lh->num_items*LH_LOAD_MULT/lh->num_nodes))\r\nexpand(lh);\r\nrn=getrn(lh,data,&hash);\r\nif (*rn == NULL)\r\n{\r\nif ((nn=(LHASH_NODE *)Malloc(sizeof(LHASH_NODE))) == NULL)\r\n{\r\nlh->error++;\r\nreturn(NULL);\r\n}\r\nnn->data=data;\r\nnn->next=NULL;\r\n#ifndef NO_HASH_COMP\r\nnn->hash=hash;\r\n#endif\r\n*rn=nn;\r\nret=NULL;\r\nlh->num_insert++;\r\nlh->num_items++;\r\n}\r\nelse\r\n{\r\nret= (*rn)->data;\r\n(*rn)->data=data;\r\nlh->num_replace++;\r\n}\r\nreturn(ret);\r\n}\r\nchar *lh_delete(LHASH *lh, char *data)\r\n{\r\nunsigned long hash;\r\nLHASH_NODE *nn,**rn;\r\nchar *ret;\r\nlh->error=0;\r\nrn=getrn(lh,data,&hash);\r\nif (*rn == NULL)\r\n{\r\nlh->num_no_delete++;\r\nreturn(NULL);\r\n}\r\nelse\r\n{\r\nnn= *rn;\r\n*rn=nn->next;\r\nret=nn->data;\r\nFree((char *)nn);\r\nlh->num_delete++;\r\n}\r\nlh->num_items--;\r\nif ((lh->num_nodes > MIN_NODES) &&\r\n(lh->down_load >= (lh->num_items*LH_LOAD_MULT/lh->num_nodes)))\r\ncontract(lh);\r\nreturn(ret);\r\n}\r\nchar *lh_retrieve(LHASH *lh, char *data)\r\n{\r\nunsigned long hash;\r\nLHASH_NODE **rn;\r\nchar *ret;\r\nlh->error=0;\r\nrn=getrn(lh,data,&hash);\r\nif (*rn == NULL)\r\n{\r\nlh->num_retrieve_miss++;\r\nreturn(NULL);\r\n}\r\nelse\r\n{\r\nret= (*rn)->data;\r\nlh->num_retrieve++;\r\n}\r\nreturn(ret);\r\n}\r\nvoid lh_doall(LHASH *lh, void (*func)())\r\n{\r\nlh_doall_arg(lh,func,NULL);\r\n}\r\nvoid lh_doall_arg(LHASH *lh, void (*func)(), char *arg)\r\n{\r\nint i;\r\nLHASH_NODE *a,*n;\r\nfor (i=lh->num_nodes-1; i>=0; i--)\r\n{\r\na=lh->b[i];\r\nwhile (a != NULL)\r\n{\r\nn=a->next;\r\nfunc(a->data,arg);\r\na=n;\r\n}\r\n}\r\n}\r\nstatic void expand(LHASH *lh)\r\n{\r\nLHASH_NODE **n,**n1,**n2,*np;\r\nunsigned int p,i,j;\r\nunsigned long hash,nni;\r\nlh->num_nodes++;\r\nlh->num_expands++;\r\np=(int)lh->p++;\r\nn1= &(lh->b[p]);\r\nn2= &(lh->b[p+(int)lh->pmax]);\r\n*n2=NULL;\r\nnni=lh->num_alloc_nodes;\r\nfor (np= *n1; np != NULL; )\r\n{\r\n#ifndef NO_HASH_COMP\r\nhash=np->hash;\r\n#else\r\nhash=(*(lh->hash))(np->data);\r\nlh->num_hash_calls++;\r\n#endif\r\nif ((hash%nni) != p)\r\n{\r\n*n1= (*n1)->next;\r\nnp->next= *n2;\r\n*n2=np;\r\n}\r\nelse\r\nn1= &((*n1)->next);\r\nnp= *n1;\r\n}\r\nif ((lh->p) >= lh->pmax)\r\n{\r\nj=(int)lh->num_alloc_nodes*2;\r\nn=(LHASH_NODE **)Realloc((char *)lh->b,\r\n(unsigned int)sizeof(LHASH_NODE *)*j);\r\nif (n == NULL)\r\n{\r\nlh->error++;\r\nlh->p=0;\r\nreturn;\r\n}\r\nfor (i=(int)lh->num_alloc_nodes; i<j; i++)\r\nn[i]=NULL;\r\nlh->pmax=lh->num_alloc_nodes;\r\nlh->num_alloc_nodes=j;\r\nlh->num_expand_reallocs++;\r\nlh->p=0;\r\nlh->b=n;\r\n}\r\n}\r\nstatic void contract(LHASH *lh)\r\n{\r\nLHASH_NODE **n,*n1,*np;\r\nnp=lh->b[lh->p+lh->pmax-1];\r\nlh->b[lh->p+lh->pmax-1]=NULL;\r\nif (lh->p == 0)\r\n{\r\nn=(LHASH_NODE **)Realloc((char *)lh->b,\r\n(unsigned int)(sizeof(LHASH_NODE *)*lh->pmax));\r\nif (n == NULL)\r\n{\r\nlh->error++;\r\nreturn;\r\n}\r\nlh->num_contract_reallocs++;\r\nlh->num_alloc_nodes/=2;\r\nlh->pmax/=2;\r\nlh->p=lh->pmax-1;\r\nlh->b=n;\r\n}\r\nelse\r\nlh->p--;\r\nlh->num_nodes--;\r\nlh->num_contracts++;\r\nn1=lh->b[(int)lh->p];\r\nif (n1 == NULL)\r\nlh->b[(int)lh->p]=np;\r\nelse\r\n{\r\nwhile (n1->next != NULL)\r\nn1=n1->next;\r\nn1->next=np;\r\n}\r\n}\r\nstatic LHASH_NODE **getrn(LHASH *lh, char *data, unsigned long *rhash)\r\n{\r\nLHASH_NODE **ret,*n1;\r\nunsigned long hash,nn;\r\nint (*cf)();\r\nhash=(*(lh->hash))(data);\r\nlh->num_hash_calls++;\r\n*rhash=hash;\r\nnn=hash%lh->pmax;\r\nif (nn < lh->p)\r\nnn=hash%lh->num_alloc_nodes;\r\ncf=lh->comp;\r\nret= &(lh->b[(int)nn]);\r\nfor (n1= *ret; n1 != NULL; n1=n1->next)\r\n{\r\n#ifndef NO_HASH_COMP\r\nlh->num_hash_comps++;\r\nif (n1->hash != hash)\r\n{\r\nret= &(n1->next);\r\ncontinue;\r\n}\r\n#endif\r\nlh->num_comp_calls++;\r\nif ((*cf)(n1->data,data) == 0)\r\nbreak;\r\nret= &(n1->next);\r\n}\r\nreturn(ret);\r\n}\r\nunsigned long lh_strhash(const char *c)\r\n{\r\nunsigned long ret=0;\r\nlong n;\r\nunsigned long v;\r\nint r;\r\nif ((c == NULL) || (*c == '\0'))\r\nreturn(ret);\r\nn=0x100;\r\nwhile (*c)\r\n{\r\nv=n|(*c);\r\nn+=0x100;\r\nr= (int)((v>>2)^v)&0x0f;\r\nret=(ret<<r)|(ret>>(32-r));\r\nret&=0xFFFFFFFFL;\r\nret^=v*v;\r\nc++;\r\n}\r\nreturn((ret>>16)^ret);\r\n}
