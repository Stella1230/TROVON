int PKCS12_parse (PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert,\r\nSTACK **ca)\r\n{\r\nif(!p12) {\r\nPKCS12err(PKCS12_F_PKCS12_PARSE,PKCS12_R_INVALID_NULL_PKCS12_POINTER);\r\nreturn 0;\r\n}\r\nif ((ca != NULL) && (*ca == NULL)) {\r\nif (!(*ca = sk_new(NULL))) {\r\nPKCS12err(PKCS12_F_PKCS12_PARSE,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\n}\r\nif(pkey) *pkey = NULL;\r\nif(cert) *cert = NULL;\r\nif (!PKCS12_verify_mac (p12, pass, -1)) {\r\nPKCS12err(PKCS12_F_PKCS12_PARSE,PKCS12_R_MAC_VERIFY_FAILURE);\r\ngoto err;\r\n}\r\nif (!parse_pk12 (p12, pass, -1, pkey, cert, ca)) {\r\nPKCS12err(PKCS12_F_PKCS12_PARSE,PKCS12_R_PARSE_ERROR);\r\ngoto err;\r\n}\r\nreturn 1;\r\nerr:\r\nif (pkey && *pkey) EVP_PKEY_free (*pkey);\r\nif (cert && *cert) X509_free (*cert);\r\nif (ca) sk_pop_free (*ca, X509_free);\r\nreturn 0;\r\n}\r\nstatic int parse_pk12 (PKCS12 *p12, const char *pass, int passlen,\r\nEVP_PKEY **pkey, X509 **cert, STACK **ca)\r\n{\r\nSTACK *asafes, *bags;\r\nint i, bagnid;\r\nPKCS7 *p7;\r\nASN1_OCTET_STRING *keyid = NULL;\r\nchar keymatch = 0;\r\nif (!( asafes = M_PKCS12_unpack_authsafes (p12))) return 0;\r\nfor (i = 0; i < sk_num (asafes); i++) {\r\np7 = (PKCS7 *) sk_value (asafes, i);\r\nbagnid = OBJ_obj2nid (p7->type);\r\nif (bagnid == NID_pkcs7_data) {\r\nbags = M_PKCS12_unpack_p7data (p7);\r\n} else if (bagnid == NID_pkcs7_encrypted) {\r\nbags = M_PKCS12_unpack_p7encdata (p7, pass, passlen);\r\n} else continue;\r\nif (!bags) {\r\nsk_pop_free (asafes, PKCS7_free);\r\nreturn 0;\r\n}\r\nif (!parse_bags (bags, pass, passlen, pkey, cert, ca,\r\n&keyid, &keymatch)) {\r\nsk_pop_free (bags, PKCS12_SAFEBAG_free);\r\nsk_pop_free (asafes, PKCS7_free);\r\nreturn 0;\r\n}\r\nsk_pop_free (bags, PKCS12_SAFEBAG_free);\r\n}\r\nsk_pop_free (asafes, PKCS7_free);\r\nif (keyid) ASN1_OCTET_STRING_free (keyid);\r\nreturn 1;\r\n}\r\nstatic int parse_bags (STACK *bags, const char *pass, int passlen,\r\nEVP_PKEY **pkey, X509 **cert, STACK **ca,\r\nASN1_OCTET_STRING **keyid, char *keymatch)\r\n{\r\nint i;\r\nfor (i = 0; i < sk_num (bags); i++) {\r\nif (!parse_bag ((PKCS12_SAFEBAG *)sk_value (bags, i),\r\npass, passlen, pkey, cert, ca, keyid,\r\nkeymatch)) return 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int parse_bag (PKCS12_SAFEBAG *bag, const char *pass, int passlen,\r\nEVP_PKEY **pkey, X509 **cert, STACK **ca,\r\nASN1_OCTET_STRING **keyid,\r\nchar *keymatch)\r\n{\r\nPKCS8_PRIV_KEY_INFO *p8;\r\nX509 *x509;\r\nASN1_OCTET_STRING *lkey = NULL;\r\nASN1_TYPE *attrib;\r\nif ((attrib = PKCS12_get_attr (bag, NID_localKeyID)))\r\nlkey = attrib->value.octet_string;\r\nif (lkey && ((*keymatch & MATCH_ALL) != MATCH_ALL)) {\r\nif (*keyid) {\r\nif (ASN1_OCTET_STRING_cmp (*keyid, lkey)) lkey = NULL;\r\n} else {\r\nif (!(*keyid = ASN1_OCTET_STRING_dup (lkey))) {\r\nPKCS12err(PKCS12_F_PARSE_BAGS,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nswitch (M_PKCS12_bag_type(bag))\r\n{\r\ncase NID_keyBag:\r\nif (!lkey || !pkey) return 1;\r\nif (!(*pkey = EVP_PKCS82PKEY (bag->value.keybag))) return 0;\r\n*keymatch |= MATCH_KEY;\r\nbreak;\r\ncase NID_pkcs8ShroudedKeyBag:\r\nif (!lkey || !pkey) return 1;\r\nif (!(p8 = M_PKCS12_decrypt_skey (bag, pass, passlen)))\r\nreturn 0;\r\n*pkey = EVP_PKCS82PKEY (p8);\r\nPKCS8_PRIV_KEY_INFO_free (p8);\r\nif (!(*pkey)) return 0;\r\n*keymatch |= MATCH_KEY;\r\nbreak;\r\ncase NID_certBag:\r\nif (M_PKCS12_cert_bag_type(bag) != NID_x509Certificate )\r\nreturn 1;\r\nif (!(x509 = M_PKCS12_certbag2x509(bag))) return 0;\r\nif (lkey) {\r\n*keymatch |= MATCH_CERT;\r\nif (cert) *cert = x509;\r\n} else if (ca) sk_push (*ca, (char *)x509);\r\nbreak;\r\ncase NID_safeContentsBag:\r\nreturn parse_bags(bag->value.safes, pass, passlen,\r\npkey, cert, ca, keyid, keymatch);\r\nbreak;\r\ndefault:\r\nreturn 1;\r\nbreak;\r\n}\r\nreturn 1;\r\n}
