TXT_DB *TXT_DB_read(BIO *in, int num)\r\n{\r\nTXT_DB *ret=NULL;\r\nint er=1;\r\nint esc=0;\r\nlong ln=0;\r\nint i,add,n;\r\nint size=BUFSIZE;\r\nint offset=0;\r\nchar *p,**pp,*f;\r\nBUF_MEM *buf=NULL;\r\nif ((buf=BUF_MEM_new()) == NULL) goto err;\r\nif (!BUF_MEM_grow(buf,size)) goto err;\r\nif ((ret=(TXT_DB *)Malloc(sizeof(TXT_DB))) == NULL)\r\ngoto err;\r\nret->num_fields=num;\r\nret->index=NULL;\r\nret->qual=NULL;\r\nif ((ret->data=sk_new_null()) == NULL)\r\ngoto err;\r\nif ((ret->index=(LHASH **)Malloc(sizeof(LHASH *)*num)) == NULL)\r\ngoto err;\r\nif ((ret->qual=(int (**)())Malloc(sizeof(int (**)())*num)) == NULL)\r\ngoto err;\r\nfor (i=0; i<num; i++)\r\n{\r\nret->index[i]=NULL;\r\nret->qual[i]=NULL;\r\n}\r\nadd=(num+1)*sizeof(char *);\r\nbuf->data[size-1]='\0';\r\noffset=0;\r\nfor (;;)\r\n{\r\nif (offset != 0)\r\n{\r\nsize+=BUFSIZE;\r\nif (!BUF_MEM_grow(buf,size)) goto err;\r\n}\r\nbuf->data[offset]='\0';\r\nBIO_gets(in,&(buf->data[offset]),size-offset);\r\nln++;\r\nif (buf->data[offset] == '\0') break;\r\nif ((offset == 0) && (buf->data[0] == '#')) continue;\r\ni=strlen(&(buf->data[offset]));\r\noffset+=i;\r\nif (buf->data[offset-1] != '\n')\r\ncontinue;\r\nelse\r\n{\r\nbuf->data[offset-1]='\0';\r\np=(char *)Malloc(add+offset);\r\noffset=0;\r\n}\r\npp=(char **)p;\r\np+=add;\r\nn=0;\r\npp[n++]=p;\r\ni=0;\r\nf=buf->data;\r\nesc=0;\r\nfor (;;)\r\n{\r\nif (*f == '\0') break;\r\nif (*f == '\t')\r\n{\r\nif (esc)\r\np--;\r\nelse\r\n{\r\n*(p++)='\0';\r\nf++;\r\nif (n >= num) break;\r\npp[n++]=p;\r\ncontinue;\r\n}\r\n}\r\nesc=(*f == '\\');\r\n*(p++)= *(f++);\r\n}\r\n*(p++)='\0';\r\nif ((n != num) || (*f != '\0'))\r\n{\r\n#if !defined(NO_STDIO) && !defined(WIN16)\r\nfprintf(stderr,"wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)\n",ln,num,n,f);\r\n#endif\r\ner=2;\r\ngoto err;\r\n}\r\npp[n]=p;\r\nif (!sk_push(ret->data,(char *)pp))\r\n{\r\n#if !defined(NO_STDIO) && !defined(WIN16)\r\nfprintf(stderr,"failure in sk_push\n");\r\n#endif\r\ner=2;\r\ngoto err;\r\n}\r\n}\r\ner=0;\r\nerr:\r\nBUF_MEM_free(buf);\r\nif (er)\r\n{\r\n#if !defined(NO_STDIO) && !defined(WIN16)\r\nif (er == 1) fprintf(stderr,"Malloc failure\n");\r\n#endif\r\nif (ret->data != NULL) sk_free(ret->data);\r\nif (ret->index != NULL) Free(ret->index);\r\nif (ret->qual != NULL) Free((char *)ret->qual);\r\nif (ret != NULL) Free(ret);\r\nreturn(NULL);\r\n}\r\nelse\r\nreturn(ret);\r\n}\r\nchar **TXT_DB_get_by_index(TXT_DB *db, int idx, char **value)\r\n{\r\nchar **ret;\r\nLHASH *lh;\r\nif (idx >= db->num_fields)\r\n{\r\ndb->error=DB_ERROR_INDEX_OUT_OF_RANGE;\r\nreturn(NULL);\r\n}\r\nlh=db->index[idx];\r\nif (lh == NULL)\r\n{\r\ndb->error=DB_ERROR_NO_INDEX;\r\nreturn(NULL);\r\n}\r\nret=(char **)lh_retrieve(lh,(char *)value);\r\ndb->error=DB_ERROR_OK;\r\nreturn(ret);\r\n}\r\nlong TXT_DB_write(BIO *out, TXT_DB *db)\r\n{\r\nlong i,j,n,nn,l,tot=0;\r\nchar *p,**pp,*f;\r\nBUF_MEM *buf=NULL;\r\nlong ret= -1;\r\nif ((buf=BUF_MEM_new()) == NULL)\r\ngoto err;\r\nn=sk_num(db->data);\r\nnn=db->num_fields;\r\nfor (i=0; i<n; i++)\r\n{\r\npp=(char **)sk_value(db->data,i);\r\nl=0;\r\nfor (j=0; j<nn; j++)\r\n{\r\nif (pp[j] != NULL)\r\nl+=strlen(pp[j]);\r\n}\r\nif (!BUF_MEM_grow(buf,(int)(l*2+nn))) goto err;\r\np=buf->data;\r\nfor (j=0; j<nn; j++)\r\n{\r\nf=pp[j];\r\nif (f != NULL)\r\nfor (;;)\r\n{\r\nif (*f == '\0') break;\r\nif (*f == '\t') *(p++)='\\';\r\n*(p++)= *(f++);\r\n}\r\n*(p++)='\t';\r\n}\r\np[-1]='\n';\r\nj=p-buf->data;\r\nif (BIO_write(out,buf->data,(int)j) != j)\r\ngoto err;\r\ntot+=j;\r\n}\r\nret=tot;\r\nerr:\r\nif (buf != NULL) BUF_MEM_free(buf);\r\nreturn(ret);\r\n}\r\nint TXT_DB_insert(TXT_DB *db, char **row)\r\n{\r\nint i;\r\nchar **r;\r\nfor (i=0; i<db->num_fields; i++)\r\n{\r\nif (db->index[i] != NULL)\r\n{\r\nif ((db->qual[i] != NULL) &&\r\n(db->qual[i](row) == 0)) continue;\r\nr=(char **)lh_retrieve(db->index[i],(char *)row);\r\nif (r != NULL)\r\n{\r\ndb->error=DB_ERROR_INDEX_CLASH;\r\ndb->arg1=i;\r\ndb->arg_row=r;\r\ngoto err;\r\n}\r\n}\r\n}\r\nif (!sk_push(db->data,(char *)row))\r\n{\r\ndb->error=DB_ERROR_MALLOC;\r\ngoto err;\r\n}\r\nfor (i=0; i<db->num_fields; i++)\r\n{\r\nif (db->index[i] != NULL)\r\n{\r\nif ((db->qual[i] != NULL) &&\r\n(db->qual[i](row) == 0)) continue;\r\nlh_insert(db->index[i],(char *)row);\r\n}\r\n}\r\nreturn(1);\r\nerr:\r\nreturn(0);\r\n}\r\nvoid TXT_DB_free(TXT_DB *db)\r\n{\r\nint i,n;\r\nchar **p,*max;\r\nif(db == NULL)\r\nreturn;\r\nif (db->index != NULL)\r\n{\r\nfor (i=db->num_fields-1; i>=0; i--)\r\nif (db->index[i] != NULL) lh_free(db->index[i]);\r\nFree(db->index);\r\n}\r\nif (db->qual != NULL)\r\nFree(db->qual);\r\nif (db->data != NULL)\r\n{\r\nfor (i=sk_num(db->data)-1; i>=0; i--)\r\n{\r\np=(char **)sk_value(db->data,i);\r\nmax=p[db->num_fields];\r\nif (max == NULL)\r\n{\r\nfor (n=0; n<db->num_fields; n++)\r\nif (p[n] != NULL) Free(p[n]);\r\n}\r\nelse\r\n{\r\nfor (n=0; n<db->num_fields; n++)\r\n{\r\nif (((p[n] < (char *)p) || (p[n] > max))\r\n&& (p[n] != NULL))\r\nFree(p[n]);\r\n}\r\n}\r\nFree(sk_value(db->data,i));\r\n}\r\nsk_free(db->data);\r\n}\r\nFree(db);\r\n}
