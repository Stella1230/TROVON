RAND_METHOD *RAND_SSLeay(void)\r\n{\r\nreturn(&rand_ssleay_meth);\r\n}\r\nstatic void ssleay_rand_cleanup(void)\r\n{\r\nmemset(state,0,sizeof(state));\r\nstate_num=0;\r\nstate_index=0;\r\nmemset(md,0,MD_DIGEST_LENGTH);\r\nmd_count[0]=0;\r\nmd_count[1]=0;\r\n}\r\nstatic void ssleay_rand_seed(const void *buf, int num)\r\n{\r\nint i,j,k,st_idx,st_num;\r\nMD_CTX m;\r\n#ifdef NORAND\r\nreturn;\r\n#endif\r\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\r\nst_idx=state_index;\r\nst_num=state_num;\r\nstate_index=(state_index+num);\r\nif (state_index >= STATE_SIZE)\r\n{\r\nstate_index%=STATE_SIZE;\r\nstate_num=STATE_SIZE;\r\n}\r\nelse if (state_num < STATE_SIZE)\r\n{\r\nif (state_index > state_num)\r\nstate_num=state_index;\r\n}\r\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\r\nfor (i=0; i<num; i+=MD_DIGEST_LENGTH)\r\n{\r\nj=(num-i);\r\nj=(j > MD_DIGEST_LENGTH)?MD_DIGEST_LENGTH:j;\r\nMD_Init(&m);\r\nMD_Update(&m,md,MD_DIGEST_LENGTH);\r\nk=(st_idx+j)-STATE_SIZE;\r\nif (k > 0)\r\n{\r\nMD_Update(&m,&(state[st_idx]),j-k);\r\nMD_Update(&m,&(state[0]),k);\r\n}\r\nelse\r\nMD_Update(&m,&(state[st_idx]),j);\r\nMD_Update(&m,buf,j);\r\nMD_Update(&m,(unsigned char *)&(md_count[0]),sizeof(md_count));\r\nMD_Final(md,&m);\r\nmd_count[1]++;\r\nbuf=(const char *)buf + j;\r\nfor (k=0; k<j; k++)\r\n{\r\nstate[st_idx++]^=md[k];\r\nif (st_idx >= STATE_SIZE)\r\n{\r\nst_idx=0;\r\nst_num=STATE_SIZE;\r\n}\r\n}\r\n}\r\nmemset((char *)&m,0,sizeof(m));\r\n}\r\nstatic void ssleay_rand_bytes(unsigned char *buf, int num)\r\n{\r\nint i,j,k,st_num,st_idx;\r\nMD_CTX m;\r\nstatic int init=1;\r\nunsigned long l;\r\n#ifdef DEVRANDOM\r\nFILE *fh;\r\n#endif\r\n#ifdef PREDICT\r\n{\r\nstatic unsigned char val=0;\r\nfor (i=0; i<num; i++)\r\nbuf[i]=val++;\r\nreturn;\r\n}\r\n#endif\r\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\r\nif (init)\r\n{\r\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\r\nRAND_seed(&m,sizeof(m));\r\n#ifndef MSDOS\r\nl=getpid();\r\nRAND_seed(&l,sizeof(l));\r\nl=getuid();\r\nRAND_seed(&l,sizeof(l));\r\n#endif\r\nl=time(NULL);\r\nRAND_seed(&l,sizeof(l));\r\nif ((fh = fopen(DEVRANDOM, "r")) != NULL)\r\n{\r\nunsigned char tmpbuf[32];\r\nfread((unsigned char *)tmpbuf,1,32,fh);\r\nfclose(fh);\r\nRAND_seed(tmpbuf,32);\r\nmemset(tmpbuf,0,32);\r\n}\r\n#ifdef PURIFY\r\nmemset(state,0,STATE_SIZE);\r\nmemset(md,0,MD_DIGEST_LENGTH);\r\n#endif\r\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\r\ninit=0;\r\n}\r\nst_idx=state_index;\r\nst_num=state_num;\r\nstate_index+=num;\r\nif (state_index > state_num)\r\nstate_index=(state_index%state_num);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\r\nwhile (num > 0)\r\n{\r\nj=(num >= MD_DIGEST_LENGTH/2)?MD_DIGEST_LENGTH/2:num;\r\nnum-=j;\r\nMD_Init(&m);\r\nMD_Update(&m,&(md[MD_DIGEST_LENGTH/2]),MD_DIGEST_LENGTH/2);\r\nMD_Update(&m,(unsigned char *)&(md_count[0]),sizeof(md_count));\r\n#ifndef PURIFY\r\nMD_Update(&m,buf,j);\r\n#endif\r\nk=(st_idx+j)-st_num;\r\nif (k > 0)\r\n{\r\nMD_Update(&m,&(state[st_idx]),j-k);\r\nMD_Update(&m,&(state[0]),k);\r\n}\r\nelse\r\nMD_Update(&m,&(state[st_idx]),j);\r\nMD_Final(md,&m);\r\nfor (i=0; i<j; i++)\r\n{\r\nif (st_idx >= st_num)\r\nst_idx=0;\r\nstate[st_idx++]^=md[i];\r\n*(buf++)=md[i+MD_DIGEST_LENGTH/2];\r\n}\r\n}\r\nMD_Init(&m);\r\nMD_Update(&m,(unsigned char *)&(md_count[0]),sizeof(md_count));\r\nmd_count[0]++;\r\nMD_Update(&m,md,MD_DIGEST_LENGTH);\r\nMD_Final(md,&m);\r\nmemset(&m,0,sizeof(m));\r\n}\r\nvoid RAND_screen(void)\r\n{\r\nHDC hScrDC;\r\nHDC hMemDC;\r\nHBITMAP hBitmap;\r\nHBITMAP hOldBitmap;\r\nBITMAP bm;\r\nunsigned int size;\r\nchar *bmbits;\r\nint w;\r\nint h;\r\nint y;\r\nint n = 16;\r\nhScrDC = CreateDC("DISPLAY", NULL, NULL, NULL);\r\nhMemDC = CreateCompatibleDC(hScrDC);\r\nw = GetDeviceCaps(hScrDC, HORZRES);\r\nh = GetDeviceCaps(hScrDC, VERTRES);\r\nhBitmap = CreateCompatibleBitmap(hScrDC, w, n);\r\nhOldBitmap = SelectObject(hMemDC, hBitmap);\r\nGetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);\r\nsize = (unsigned int)bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes;\r\nbmbits = Malloc(size);\r\nif (bmbits) {\r\nfor (y = 0; y < h-n; y += n)\r\n{\r\nunsigned char md[MD_DIGEST_LENGTH];\r\nBitBlt(hMemDC, 0, 0, w, n, hScrDC, 0, y, SRCCOPY);\r\nGetBitmapBits(hBitmap, size, bmbits);\r\nMD(bmbits,size,md);\r\nRAND_seed(md, MD_DIGEST_LENGTH);\r\n}\r\nFree(bmbits);\r\n}\r\nhBitmap = SelectObject(hMemDC, hOldBitmap);\r\nDeleteObject(hBitmap);\r\nDeleteDC(hMemDC);\r\nDeleteDC(hScrDC);\r\n}
