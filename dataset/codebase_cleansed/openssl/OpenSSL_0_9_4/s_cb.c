int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)\r\n{\r\nchar buf[256];\r\nX509 *err_cert;\r\nint err,depth;\r\nerr_cert=X509_STORE_CTX_get_current_cert(ctx);\r\nerr= X509_STORE_CTX_get_error(ctx);\r\ndepth= X509_STORE_CTX_get_error_depth(ctx);\r\nX509_NAME_oneline(X509_get_subject_name(err_cert),buf,256);\r\nBIO_printf(bio_err,"depth=%d %s\n",depth,buf);\r\nif (!ok)\r\n{\r\nBIO_printf(bio_err,"verify error:num=%d:%s\n",err,\r\nX509_verify_cert_error_string(err));\r\nif (verify_depth >= depth)\r\n{\r\nok=1;\r\nverify_error=X509_V_OK;\r\n}\r\nelse\r\n{\r\nok=0;\r\nverify_error=X509_V_ERR_CERT_CHAIN_TOO_LONG;\r\n}\r\n}\r\nswitch (ctx->error)\r\n{\r\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\r\nX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),buf,256);\r\nBIO_printf(bio_err,"issuer= %s\n",buf);\r\nbreak;\r\ncase X509_V_ERR_CERT_NOT_YET_VALID:\r\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\r\nBIO_printf(bio_err,"notBefore=");\r\nASN1_TIME_print(bio_err,X509_get_notBefore(ctx->current_cert));\r\nBIO_printf(bio_err,"\n");\r\nbreak;\r\ncase X509_V_ERR_CERT_HAS_EXPIRED:\r\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\r\nBIO_printf(bio_err,"notAfter=");\r\nASN1_TIME_print(bio_err,X509_get_notAfter(ctx->current_cert));\r\nBIO_printf(bio_err,"\n");\r\nbreak;\r\n}\r\nBIO_printf(bio_err,"verify return:%d\n",ok);\r\nreturn(ok);\r\n}\r\nint set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)\r\n{\r\nif (cert_file != NULL)\r\n{\r\nif (SSL_CTX_use_certificate_file(ctx,cert_file,\r\nSSL_FILETYPE_PEM) <= 0)\r\n{\r\nBIO_printf(bio_err,"unable to get certificate from '%s'\n",cert_file);\r\nERR_print_errors(bio_err);\r\nreturn(0);\r\n}\r\nif (key_file == NULL) key_file=cert_file;\r\nif (SSL_CTX_use_PrivateKey_file(ctx,key_file,\r\nSSL_FILETYPE_PEM) <= 0)\r\n{\r\nBIO_printf(bio_err,"unable to get private key from '%s'\n",key_file);\r\nERR_print_errors(bio_err);\r\nreturn(0);\r\n}\r\nif (!SSL_CTX_check_private_key(ctx))\r\n{\r\nBIO_printf(bio_err,"Private key does not match the certificate public key\n");\r\nreturn(0);\r\n}\r\n}\r\nreturn(1);\r\n}\r\nlong MS_CALLBACK bio_dump_cb(BIO *bio, int cmd, const char *argp, int argi,\r\nlong argl, long ret)\r\n{\r\nBIO *out;\r\nout=(BIO *)BIO_get_callback_arg(bio);\r\nif (out == NULL) return(ret);\r\nif (cmd == (BIO_CB_READ|BIO_CB_RETURN))\r\n{\r\nBIO_printf(out,"read from %08X [%08lX] (%d bytes => %ld (0x%X))\n",\r\nbio,argp,argi,ret,ret);\r\nBIO_dump(out,argp,(int)ret);\r\nreturn(ret);\r\n}\r\nelse if (cmd == (BIO_CB_WRITE|BIO_CB_RETURN))\r\n{\r\nBIO_printf(out,"write to %08X [%08lX] (%d bytes => %ld (0x%X))\n",\r\nbio,argp,argi,ret,ret);\r\nBIO_dump(out,argp,(int)ret);\r\n}\r\nreturn(ret);\r\n}\r\nvoid MS_CALLBACK apps_ssl_info_callback(SSL *s, int where, int ret)\r\n{\r\nchar *str;\r\nint w;\r\nw=where& ~SSL_ST_MASK;\r\nif (w & SSL_ST_CONNECT) str="SSL_connect";\r\nelse if (w & SSL_ST_ACCEPT) str="SSL_accept";\r\nelse str="undefined";\r\nif (where & SSL_CB_LOOP)\r\n{\r\nBIO_printf(bio_err,"%s:%s\n",str,SSL_state_string_long(s));\r\n}\r\nelse if (where & SSL_CB_ALERT)\r\n{\r\nstr=(where & SSL_CB_READ)?"read":"write";\r\nBIO_printf(bio_err,"SSL3 alert %s:%s:%s\n",\r\nstr,\r\nSSL_alert_type_string_long(ret),\r\nSSL_alert_desc_string_long(ret));\r\n}\r\nelse if (where & SSL_CB_EXIT)\r\n{\r\nif (ret == 0)\r\nBIO_printf(bio_err,"%s:failed in %s\n",\r\nstr,SSL_state_string_long(s));\r\nelse if (ret < 0)\r\n{\r\nBIO_printf(bio_err,"%s:error in %s\n",\r\nstr,SSL_state_string_long(s));\r\n}\r\n}\r\n}
