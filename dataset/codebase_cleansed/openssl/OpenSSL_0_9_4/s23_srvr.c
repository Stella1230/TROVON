static SSL_METHOD *ssl23_get_server_method(int ver)\r\n{\r\nif (ver == SSL2_VERSION)\r\nreturn(SSLv2_server_method());\r\nif (ver == SSL3_VERSION)\r\nreturn(SSLv3_server_method());\r\nelse if (ver == TLS1_VERSION)\r\nreturn(TLSv1_server_method());\r\nelse\r\nreturn(NULL);\r\n}\r\nSSL_METHOD *SSLv23_server_method(void)\r\n{\r\nstatic int init=1;\r\nstatic SSL_METHOD SSLv23_server_data;\r\nif (init)\r\n{\r\nmemcpy((char *)&SSLv23_server_data,\r\n(char *)sslv23_base_method(),sizeof(SSL_METHOD));\r\nSSLv23_server_data.ssl_accept=ssl23_accept;\r\nSSLv23_server_data.get_ssl_method=ssl23_get_server_method;\r\ninit=0;\r\n}\r\nreturn(&SSLv23_server_data);\r\n}\r\nint ssl23_accept(SSL *s)\r\n{\r\nBUF_MEM *buf;\r\nunsigned long Time=time(NULL);\r\nvoid (*cb)()=NULL;\r\nint ret= -1;\r\nint new_state,state;\r\nRAND_seed(&Time,sizeof(Time));\r\nERR_clear_error();\r\nclear_sys_error();\r\nif (s->info_callback != NULL)\r\ncb=s->info_callback;\r\nelse if (s->ctx->info_callback != NULL)\r\ncb=s->ctx->info_callback;\r\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\r\ns->in_handshake++;\r\nfor (;;)\r\n{\r\nstate=s->state;\r\nswitch(s->state)\r\n{\r\ncase SSL_ST_BEFORE:\r\ncase SSL_ST_ACCEPT:\r\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT:\r\ncase SSL_ST_OK|SSL_ST_ACCEPT:\r\ns->server=1;\r\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\r\ns->type=SSL_ST_ACCEPT;\r\nif (s->init_buf == NULL)\r\n{\r\nif ((buf=BUF_MEM_new()) == NULL)\r\n{\r\nret= -1;\r\ngoto end;\r\n}\r\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\r\n{\r\nret= -1;\r\ngoto end;\r\n}\r\ns->init_buf=buf;\r\n}\r\nssl3_init_finished_mac(s);\r\ns->state=SSL23_ST_SR_CLNT_HELLO_A;\r\ns->ctx->stats.sess_accept++;\r\ns->init_num=0;\r\nbreak;\r\ncase SSL23_ST_SR_CLNT_HELLO_A:\r\ncase SSL23_ST_SR_CLNT_HELLO_B:\r\ns->shutdown=0;\r\nret=ssl23_get_client_hello(s);\r\nif (ret >= 0) cb=NULL;\r\ngoto end;\r\ndefault:\r\nSSLerr(SSL_F_SSL23_ACCEPT,SSL_R_UNKNOWN_STATE);\r\nret= -1;\r\ngoto end;\r\n}\r\nif ((cb != NULL) && (s->state != state))\r\n{\r\nnew_state=s->state;\r\ns->state=state;\r\ncb(s,SSL_CB_ACCEPT_LOOP,1);\r\ns->state=new_state;\r\n}\r\n}\r\nend:\r\nif (cb != NULL)\r\ncb(s,SSL_CB_ACCEPT_EXIT,ret);\r\ns->in_handshake--;\r\nreturn(ret);\r\n}\r\nint ssl23_get_client_hello(SSL *s)\r\n{\r\nchar buf_space[8];\r\nchar *buf= &(buf_space[0]);\r\nunsigned char *p,*d,*dd;\r\nunsigned int i;\r\nunsigned int csl,sil,cl;\r\nint n=0,j,tls1=0;\r\nint type=0,use_sslv2_strong=0;\r\nint v[2];\r\nv[0]=v[1]=0;\r\nif (s->state == SSL23_ST_SR_CLNT_HELLO_A)\r\n{\r\nif (!ssl3_setup_buffers(s)) goto err;\r\nn=ssl23_read_bytes(s,7);\r\nif (n != 7) return(n);\r\np=s->packet;\r\nmemcpy(buf,p,n);\r\nif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\r\n{\r\nif ((p[3] == 0x00) && (p[4] == 0x02))\r\n{\r\nv[0]=p[3]; v[1]=p[4];\r\nif (!(s->options & SSL_OP_NO_SSLv2))\r\ntype=1;\r\n}\r\nelse if (p[3] == SSL3_VERSION_MAJOR)\r\n{\r\nv[0]=p[3]; v[1]=p[4];\r\nif (p[4] >= TLS1_VERSION_MINOR)\r\n{\r\nif (!(s->options & SSL_OP_NO_TLSv1))\r\n{\r\ntls1=1;\r\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv3))\r\n{\r\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv2))\r\n{\r\ntype=1;\r\n}\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv3))\r\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\r\nelse if (!(s->options & SSL_OP_NO_SSLv2))\r\ntype=1;\r\nif (s->options & SSL_OP_NON_EXPORT_FIRST)\r\n{\r\nSTACK_OF(SSL_CIPHER) *sk;\r\nSSL_CIPHER *c;\r\nint ne2,ne3;\r\nj=((p[0]&0x7f)<<8)|p[1];\r\nif (j > (1024*4))\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\r\ngoto err;\r\n}\r\nn=ssl23_read_bytes(s,j+2);\r\nif (n <= 0) return(n);\r\np=s->packet;\r\nif ((buf=Malloc(n)) == NULL)\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE);\r\ngoto err;\r\n}\r\nmemcpy(buf,p,n);\r\np+=5;\r\nn2s(p,csl);\r\np+=4;\r\nsk=ssl_bytes_to_cipher_list(\r\ns,p,csl,NULL);\r\nif (sk != NULL)\r\n{\r\nne2=ne3=0;\r\nfor (j=0; j<sk_SSL_CIPHER_num(sk); j++)\r\n{\r\nc=sk_SSL_CIPHER_value(sk,j);\r\nif (!SSL_C_IS_EXPORT(c))\r\n{\r\nif ((c->id>>24L) == 2L)\r\nne2=1;\r\nelse\r\nne3=1;\r\n}\r\n}\r\nif (ne2 && !ne3)\r\n{\r\ntype=1;\r\nuse_sslv2_strong=1;\r\ngoto next_bit;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nelse if ((p[0] == SSL3_RT_HANDSHAKE) &&\r\n(p[1] == SSL3_VERSION_MAJOR) &&\r\n(p[5] == SSL3_MT_CLIENT_HELLO))\r\n{\r\nv[0]=p[1]; v[1]=p[2];\r\nif (p[2] >= TLS1_VERSION_MINOR)\r\n{\r\nif (!(s->options & SSL_OP_NO_TLSv1))\r\n{\r\ntype=3;\r\ntls1=1;\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv3))\r\ntype=3;\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv3))\r\ntype=3;\r\n}\r\nelse if ((strncmp("GET ", (char *)p,4) == 0) ||\r\n(strncmp("POST ",(char *)p,5) == 0) ||\r\n(strncmp("HEAD ",(char *)p,5) == 0) ||\r\n(strncmp("PUT ", (char *)p,4) == 0))\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\r\ngoto err;\r\n}\r\nelse if (strncmp("CONNECT",(char *)p,7) == 0)\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\r\ngoto err;\r\n}\r\n}\r\nnext_bit:\r\nif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\r\n{\r\ntype=2;\r\np=s->packet;\r\nn=((p[0]&0x7f)<<8)|p[1];\r\nif (n > (1024*4))\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\r\ngoto err;\r\n}\r\nj=ssl23_read_bytes(s,n+2);\r\nif (j <= 0) return(j);\r\nssl3_finish_mac(s,&(s->packet[2]),s->packet_length-2);\r\np=s->packet;\r\np+=5;\r\nn2s(p,csl);\r\nn2s(p,sil);\r\nn2s(p,cl);\r\nd=(unsigned char *)s->init_buf->data;\r\nif ((csl+sil+cl+11) != s->packet_length)\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\r\ngoto err;\r\n}\r\n*(d++)=SSL3_VERSION_MAJOR;\r\nif (tls1)\r\n*(d++)=TLS1_VERSION_MINOR;\r\nelse\r\n*(d++)=SSL3_VERSION_MINOR;\r\ni=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\r\nmemset(d,0,SSL3_RANDOM_SIZE);\r\nmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\r\nd+=SSL3_RANDOM_SIZE;\r\n*(d++)=0;\r\nj=0;\r\ndd=d;\r\nd+=2;\r\nfor (i=0; i<csl; i+=3)\r\n{\r\nif (p[i] != 0) continue;\r\n*(d++)=p[i+1];\r\n*(d++)=p[i+2];\r\nj+=2;\r\n}\r\ns2n(j,dd);\r\n*(d++)=1;\r\n*(d++)=0;\r\ni=(d-(unsigned char *)s->init_buf->data);\r\ns->s3->tmp.reuse_message=1;\r\ns->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\r\ns->s3->tmp.message_size=i;\r\n}\r\nif (type == 1)\r\n{\r\nif (s->s2 == NULL)\r\n{\r\nif (!ssl2_new(s))\r\ngoto err;\r\n}\r\nelse\r\nssl2_clear(s);\r\nif (s->s3 != NULL) ssl3_free(s);\r\nif (!BUF_MEM_grow(s->init_buf,\r\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\r\n{\r\ngoto err;\r\n}\r\ns->state=SSL2_ST_GET_CLIENT_HELLO_A;\r\nif ((s->options & SSL_OP_MSIE_SSLV2_RSA_PADDING) ||\r\nuse_sslv2_strong)\r\ns->s2->ssl2_rollback=0;\r\nelse\r\ns->s2->ssl2_rollback=1;\r\ns->rstate=SSL_ST_READ_HEADER;\r\ns->packet_length=n;\r\ns->packet= &(s->s2->rbuf[0]);\r\nmemcpy(s->packet,buf,n);\r\ns->s2->rbuf_left=n;\r\ns->s2->rbuf_offs=0;\r\ns->method=SSLv2_server_method();\r\ns->handshake_func=s->method->ssl_accept;\r\n}\r\nif ((type == 2) || (type == 3))\r\n{\r\nif (!ssl_init_wbio_buffer(s,1)) goto err;\r\ns->state=SSL3_ST_SR_CLNT_HELLO_A;\r\nif (type == 3)\r\n{\r\ns->rstate=SSL_ST_READ_HEADER;\r\ns->packet_length=n;\r\ns->packet= &(s->s3->rbuf.buf[0]);\r\nmemcpy(s->packet,buf,n);\r\ns->s3->rbuf.left=n;\r\ns->s3->rbuf.offset=0;\r\n}\r\nelse\r\n{\r\ns->packet_length=0;\r\ns->s3->rbuf.left=0;\r\ns->s3->rbuf.offset=0;\r\n}\r\nif (tls1)\r\n{\r\ns->version=TLS1_VERSION;\r\ns->method=TLSv1_server_method();\r\n}\r\nelse\r\n{\r\ns->version=SSL3_VERSION;\r\ns->method=SSLv3_server_method();\r\n}\r\ns->client_version=(v[0]<<8)|v[1];\r\ns->handshake_func=s->method->ssl_accept;\r\n}\r\nif ((type < 1) || (type > 3))\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\r\ngoto err;\r\n}\r\ns->init_num=0;\r\nif (buf != buf_space) Free(buf);\r\ns->first_packet=1;\r\nreturn(SSL_accept(s));\r\nerr:\r\nif (buf != buf_space) Free(buf);\r\nreturn(-1);\r\n}
