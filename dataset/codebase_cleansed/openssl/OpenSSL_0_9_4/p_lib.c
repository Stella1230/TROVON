int EVP_PKEY_bits(EVP_PKEY *pkey)\r\n{\r\n#ifndef NO_RSA\r\nif (pkey->type == EVP_PKEY_RSA)\r\nreturn(BN_num_bits(pkey->pkey.rsa->n));\r\nelse\r\n#endif\r\n#ifndef NO_DSA\r\nif (pkey->type == EVP_PKEY_DSA)\r\nreturn(BN_num_bits(pkey->pkey.dsa->p));\r\n#endif\r\nreturn(0);\r\n}\r\nint EVP_PKEY_size(EVP_PKEY *pkey)\r\n{\r\nif (pkey == NULL)\r\nreturn(0);\r\n#ifndef NO_RSA\r\nif (pkey->type == EVP_PKEY_RSA)\r\nreturn(RSA_size(pkey->pkey.rsa));\r\nelse\r\n#endif\r\n#ifndef NO_DSA\r\nif (pkey->type == EVP_PKEY_DSA)\r\nreturn(DSA_size(pkey->pkey.dsa));\r\n#endif\r\nreturn(0);\r\n}\r\nint EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode)\r\n{\r\n#ifndef NO_DSA\r\nif (pkey->type == EVP_PKEY_DSA)\r\n{\r\nint ret=pkey->save_parameters=mode;\r\nif (mode >= 0)\r\npkey->save_parameters=mode;\r\nreturn(ret);\r\n}\r\n#endif\r\nreturn(0);\r\n}\r\nint EVP_PKEY_copy_parameters(EVP_PKEY *to, EVP_PKEY *from)\r\n{\r\nif (to->type != from->type)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_DIFFERENT_KEY_TYPES);\r\ngoto err;\r\n}\r\nif (EVP_PKEY_missing_parameters(from))\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS,EVP_R_MISSING_PARMATERS);\r\ngoto err;\r\n}\r\n#ifndef NO_DSA\r\nif (to->type == EVP_PKEY_DSA)\r\n{\r\nBIGNUM *a;\r\nif ((a=BN_dup(from->pkey.dsa->p)) == NULL) goto err;\r\nif (to->pkey.dsa->p != NULL) BN_free(to->pkey.dsa->p);\r\nto->pkey.dsa->p=a;\r\nif ((a=BN_dup(from->pkey.dsa->q)) == NULL) goto err;\r\nif (to->pkey.dsa->q != NULL) BN_free(to->pkey.dsa->q);\r\nto->pkey.dsa->q=a;\r\nif ((a=BN_dup(from->pkey.dsa->g)) == NULL) goto err;\r\nif (to->pkey.dsa->g != NULL) BN_free(to->pkey.dsa->g);\r\nto->pkey.dsa->g=a;\r\n}\r\n#endif\r\nreturn(1);\r\nerr:\r\nreturn(0);\r\n}\r\nint EVP_PKEY_missing_parameters(EVP_PKEY *pkey)\r\n{\r\n#ifndef NO_DSA\r\nif (pkey->type == EVP_PKEY_DSA)\r\n{\r\nDSA *dsa;\r\ndsa=pkey->pkey.dsa;\r\nif ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\r\nreturn(1);\r\n}\r\n#endif\r\nreturn(0);\r\n}\r\nint EVP_PKEY_cmp_parameters(EVP_PKEY *a, EVP_PKEY *b)\r\n{\r\n#ifndef NO_DSA\r\nif ((a->type == EVP_PKEY_DSA) && (b->type == EVP_PKEY_DSA))\r\n{\r\nif ( BN_cmp(a->pkey.dsa->p,b->pkey.dsa->p) ||\r\nBN_cmp(a->pkey.dsa->q,b->pkey.dsa->q) ||\r\nBN_cmp(a->pkey.dsa->g,b->pkey.dsa->g))\r\nreturn(0);\r\nelse\r\nreturn(1);\r\n}\r\n#endif\r\nreturn(-1);\r\n}\r\nEVP_PKEY *EVP_PKEY_new(void)\r\n{\r\nEVP_PKEY *ret;\r\nret=(EVP_PKEY *)Malloc(sizeof(EVP_PKEY));\r\nif (ret == NULL)\r\n{\r\nEVPerr(EVP_F_EVP_PKEY_NEW,ERR_R_MALLOC_FAILURE);\r\nreturn(NULL);\r\n}\r\nret->type=EVP_PKEY_NONE;\r\nret->references=1;\r\nret->pkey.ptr=NULL;\r\nret->attributes=NULL;\r\nret->save_parameters=1;\r\nreturn(ret);\r\n}\r\nint EVP_PKEY_assign(EVP_PKEY *pkey, int type, char *key)\r\n{\r\nif (pkey == NULL) return(0);\r\nif (pkey->pkey.ptr != NULL)\r\nEVP_PKEY_free_it(pkey);\r\npkey->type=EVP_PKEY_type(type);\r\npkey->save_type=type;\r\npkey->pkey.ptr=key;\r\nreturn(1);\r\n}\r\nint EVP_PKEY_type(int type)\r\n{\r\nswitch (type)\r\n{\r\ncase EVP_PKEY_RSA:\r\ncase EVP_PKEY_RSA2:\r\nreturn(EVP_PKEY_RSA);\r\ncase EVP_PKEY_DSA:\r\ncase EVP_PKEY_DSA1:\r\ncase EVP_PKEY_DSA2:\r\ncase EVP_PKEY_DSA3:\r\ncase EVP_PKEY_DSA4:\r\nreturn(EVP_PKEY_DSA);\r\ncase EVP_PKEY_DH:\r\nreturn(EVP_PKEY_DH);\r\ndefault:\r\nreturn(NID_undef);\r\n}\r\n}\r\nvoid EVP_PKEY_free(EVP_PKEY *x)\r\n{\r\nint i;\r\nif (x == NULL) return;\r\ni=CRYPTO_add(&x->references,-1,CRYPTO_LOCK_EVP_PKEY);\r\n#ifdef REF_PRINT\r\nREF_PRINT("EVP_PKEY",x);\r\n#endif\r\nif (i > 0) return;\r\n#ifdef REF_CHECK\r\nif (i < 0)\r\n{\r\nfprintf(stderr,"EVP_PKEY_free, bad reference count\n");\r\nabort();\r\n}\r\n#endif\r\nEVP_PKEY_free_it(x);\r\nFree((char *)x);\r\n}\r\nstatic void EVP_PKEY_free_it(EVP_PKEY *x)\r\n{\r\nswitch (x->type)\r\n{\r\n#ifndef NO_RSA\r\ncase EVP_PKEY_RSA:\r\ncase EVP_PKEY_RSA2:\r\nRSA_free(x->pkey.rsa);\r\nbreak;\r\n#endif\r\n#ifndef NO_DSA\r\ncase EVP_PKEY_DSA:\r\ncase EVP_PKEY_DSA2:\r\ncase EVP_PKEY_DSA3:\r\ncase EVP_PKEY_DSA4:\r\nDSA_free(x->pkey.dsa);\r\nbreak;\r\n#endif\r\n#ifndef NO_DH\r\ncase EVP_PKEY_DH:\r\nDH_free(x->pkey.dh);\r\nbreak;\r\n#endif\r\n}\r\n}
