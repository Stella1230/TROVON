int OBJ_NAME_init(void)\r\n{\r\nif (names_lh != NULL) return(1);\r\nMemCheck_off();\r\nnames_lh=lh_new(obj_name_hash,obj_name_cmp);\r\nMemCheck_on();\r\nreturn(names_lh != NULL);\r\n}\r\nstatic int obj_name_cmp(OBJ_NAME *a, OBJ_NAME *b)\r\n{\r\nint ret;\r\nint (*cmp)();\r\nret=a->type-b->type;\r\nif (ret == 0)\r\n{\r\nif ((names_cmp != NULL) && (sk_num(names_cmp) > a->type))\r\n{\r\ncmp=(int (*)())sk_value(names_cmp,a->type);\r\nret=cmp(a->name,b->name);\r\n}\r\nelse\r\nret=strcmp(a->name,b->name);\r\n}\r\nreturn(ret);\r\n}\r\nstatic unsigned long obj_name_hash(OBJ_NAME *a)\r\n{\r\nunsigned long ret;\r\nunsigned long (*hash)();\r\nif ((names_hash != NULL) && (sk_num(names_hash) > a->type))\r\n{\r\nhash=(unsigned long (*)())sk_value(names_hash,a->type);\r\nret=hash(a->name);\r\n}\r\nelse\r\n{\r\nret=lh_strhash(a->name);\r\n}\r\nret^=a->type;\r\nreturn(ret);\r\n}\r\nconst char *OBJ_NAME_get(const char *name, int type)\r\n{\r\nOBJ_NAME on,*ret;\r\nint num=0,alias;\r\nif (name == NULL) return(NULL);\r\nif ((names_lh == NULL) && !OBJ_NAME_init()) return(NULL);\r\nalias=type&OBJ_NAME_ALIAS;\r\ntype&= ~OBJ_NAME_ALIAS;\r\non.name=name;\r\non.type=type;\r\nfor (;;)\r\n{\r\nret=(OBJ_NAME *)lh_retrieve(names_lh,(char *)&on);\r\nif (ret == NULL) return(NULL);\r\nif ((ret->alias) && !alias)\r\n{\r\nif (++num > 10) return(NULL);\r\non.name=ret->data;\r\n}\r\nelse\r\n{\r\nreturn(ret->data);\r\n}\r\n}\r\n}\r\nint OBJ_NAME_add(const char *name, int type, const char *data)\r\n{\r\nvoid (*f)();\r\nOBJ_NAME *onp,*ret;\r\nint alias;\r\nif ((names_lh == NULL) && !OBJ_NAME_init()) return(0);\r\nalias=type&OBJ_NAME_ALIAS;\r\ntype&= ~OBJ_NAME_ALIAS;\r\nonp=(OBJ_NAME *)Malloc(sizeof(OBJ_NAME));\r\nif (onp == NULL)\r\n{\r\nreturn(0);\r\n}\r\nonp->name=name;\r\nonp->alias=alias;\r\nonp->type=type;\r\nonp->data=data;\r\nret=(OBJ_NAME *)lh_insert(names_lh,(char *)onp);\r\nif (ret != NULL)\r\n{\r\nif ((names_free != NULL) && (sk_num(names_free) > ret->type))\r\n{\r\nf=(void (*)())sk_value(names_free,ret->type);\r\nf(ret->name,ret->type,ret->data);\r\n}\r\nFree((char *)ret);\r\n}\r\nelse\r\n{\r\nif (lh_error(names_lh))\r\n{\r\nreturn(0);\r\n}\r\n}\r\nreturn(1);\r\n}\r\nint OBJ_NAME_remove(const char *name, int type)\r\n{\r\nOBJ_NAME on,*ret;\r\nvoid (*f)();\r\nif (names_lh == NULL) return(0);\r\ntype&= ~OBJ_NAME_ALIAS;\r\non.name=name;\r\non.type=type;\r\nret=(OBJ_NAME *)lh_delete(names_lh,(char *)&on);\r\nif (ret != NULL)\r\n{\r\nif ((names_free != NULL) && (sk_num(names_free) > type))\r\n{\r\nf=(void (*)())sk_value(names_free,type);\r\nf(ret->name,ret->type,ret->data);\r\n}\r\nFree((char *)ret);\r\nreturn(1);\r\n}\r\nelse\r\nreturn(0);\r\n}\r\nstatic void names_lh_free(OBJ_NAME *onp, int type)\r\n{\r\nif(onp == NULL)\r\nreturn;\r\nif ((free_type < 0) || (free_type == onp->type))\r\n{\r\nOBJ_NAME_remove(onp->name,onp->type);\r\n}\r\n}\r\nvoid OBJ_NAME_cleanup(int type)\r\n{\r\nunsigned long down_load;\r\nif (names_lh == NULL) return;\r\nfree_type=type;\r\ndown_load=names_lh->down_load;\r\nnames_lh->down_load=0;\r\nlh_doall(names_lh,names_lh_free);\r\nif (type < 0)\r\n{\r\nlh_free(names_lh);\r\nsk_free(names_hash);\r\nsk_free(names_cmp);\r\nsk_free(names_free);\r\nnames_lh=NULL;\r\nnames_hash=NULL;\r\nnames_cmp=NULL;\r\nnames_free=NULL;\r\n}\r\nelse\r\nnames_lh->down_load=down_load;\r\n}
