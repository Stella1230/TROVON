int PKCS12_key_gen_asc (const char *pass, int passlen, unsigned char *salt,\r\nint saltlen, int id, int iter, int n, unsigned char *out,\r\nconst EVP_MD *md_type)\r\n{\r\nint ret;\r\nunsigned char *unipass;\r\nint uniplen;\r\nif (!asc2uni (pass, &unipass, &uniplen)) {\r\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_ASC,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nret = PKCS12_key_gen_uni (unipass, uniplen, salt, saltlen,\r\nid, iter, n, out, md_type);\r\nmemset(unipass, 0, uniplen);\r\nFree(unipass);\r\nreturn ret;\r\n}\r\nint PKCS12_key_gen_uni (unsigned char *pass, int passlen, unsigned char *salt,\r\nint saltlen, int id, int iter, int n, unsigned char *out,\r\nconst EVP_MD *md_type)\r\n{\r\nunsigned char *B, *D, *I, *p, *Ai;\r\nint Slen, Plen, Ilen;\r\nint i, j, u, v;\r\nBIGNUM *Ij, *Bpl1;\r\nEVP_MD_CTX ctx;\r\n#ifdef DEBUG_KEYGEN\r\nunsigned char *tmpout = out;\r\nint tmpn = n;\r\nBIO_printf (bio_err, "KEYGEN DEBUG\n");\r\nBIO_printf (bio_err, "ID %d, ITER %d\n", id, iter);\r\nBIO_printf (bio_err, "Password (length %d):\n", passlen);\r\nh__dump (pass, passlen);\r\nBIO_printf (bio_err, "Salt (length %d):\n", saltlen);\r\nh__dump (salt, saltlen);\r\nBIO_printf (bio_err, "ID %d, ITER %d\n\n", id, iter);\r\n#endif\r\nv = EVP_MD_block_size (md_type);\r\nu = EVP_MD_size (md_type);\r\nD = Malloc (v);\r\nAi = Malloc (u);\r\nB = Malloc (v + 1);\r\nSlen = v * ((saltlen+v-1)/v);\r\nPlen = v * ((passlen+v-1)/v);\r\nIlen = Slen + Plen;\r\nI = Malloc (Ilen);\r\nIj = BN_new();\r\nBpl1 = BN_new();\r\nif (!D || !Ai || !B || !I || !Ij || !Bpl1) {\r\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_UNI,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < v; i++) D[i] = id;\r\np = I;\r\nfor (i = 0; i < Slen; i++) *p++ = salt[i % saltlen];\r\nfor (i = 0; i < Plen; i++) *p++ = pass[i % passlen];\r\nfor (;;) {\r\nEVP_DigestInit (&ctx, md_type);\r\nEVP_DigestUpdate (&ctx, D, v);\r\nEVP_DigestUpdate (&ctx, I, Ilen);\r\nEVP_DigestFinal (&ctx, Ai, NULL);\r\nfor (j = 1; j < iter; j++) {\r\nEVP_DigestInit (&ctx, md_type);\r\nEVP_DigestUpdate (&ctx, Ai, u);\r\nEVP_DigestFinal (&ctx, Ai, NULL);\r\n}\r\nmemcpy (out, Ai, min (n, u));\r\nif (u >= n) {\r\nFree (Ai);\r\nFree (B);\r\nFree (D);\r\nFree (I);\r\nBN_free (Ij);\r\nBN_free (Bpl1);\r\n#ifdef DEBUG_KEYGEN\r\nBIO_printf (bio_err, "Output KEY (length %d)\n", tmpn);\r\nh__dump (tmpout, tmpn);\r\n#endif\r\nreturn 1;\r\n}\r\nn -= u;\r\nout += u;\r\nfor (j = 0; j < v; j++) B[j] = Ai[j % u];\r\nBN_bin2bn (B, v, Bpl1);\r\nBN_add_word (Bpl1, 1);\r\nfor (j = 0; j < Ilen ; j+=v) {\r\nBN_bin2bn (I + j, v, Ij);\r\nBN_add (Ij, Ij, Bpl1);\r\nBN_bn2bin (Ij, B);\r\nif (BN_num_bytes (Ij) > v) {\r\nBN_bn2bin (Ij, B);\r\nmemcpy (I + j, B + 1, v);\r\n} else BN_bn2bin (Ij, I + j);\r\n}\r\n}\r\n}\r\nvoid h__dump (unsigned char *p, int len)\r\n{\r\nfor (; len --; p++) BIO_printf (bio_err, "%02X", *p);\r\nBIO_printf (bio_err, "\n");\r\n}
