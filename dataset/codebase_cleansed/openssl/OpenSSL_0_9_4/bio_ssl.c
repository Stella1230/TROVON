BIO_METHOD *BIO_f_ssl(void)\r\n{\r\nreturn(&methods_sslp);\r\n}\r\nstatic int ssl_new(BIO *bi)\r\n{\r\nBIO_SSL *bs;\r\nbs=(BIO_SSL *)Malloc(sizeof(BIO_SSL));\r\nif (bs == NULL)\r\n{\r\nBIOerr(BIO_F_SSL_NEW,ERR_R_MALLOC_FAILURE);\r\nreturn(0);\r\n}\r\nmemset(bs,0,sizeof(BIO_SSL));\r\nbi->init=0;\r\nbi->ptr=(char *)bs;\r\nbi->flags=0;\r\nreturn(1);\r\n}\r\nstatic int ssl_free(BIO *a)\r\n{\r\nBIO_SSL *bs;\r\nif (a == NULL) return(0);\r\nbs=(BIO_SSL *)a->ptr;\r\nif (bs->ssl != NULL) SSL_shutdown(bs->ssl);\r\nif (a->shutdown)\r\n{\r\nif (a->init && (bs->ssl != NULL))\r\nSSL_free(bs->ssl);\r\na->init=0;\r\na->flags=0;\r\n}\r\nif (a->ptr != NULL)\r\nFree(a->ptr);\r\nreturn(1);\r\n}\r\nstatic int ssl_read(BIO *b, char *out, int outl)\r\n{\r\nint ret=1;\r\nBIO_SSL *sb;\r\nSSL *ssl;\r\nint retry_reason=0;\r\nint r=0;\r\nif (out == NULL) return(0);\r\nsb=(BIO_SSL *)b->ptr;\r\nssl=sb->ssl;\r\nBIO_clear_retry_flags(b);\r\n#if 0\r\nif (!SSL_is_init_finished(ssl))\r\n{\r\nif (ret > 0)\r\n{\r\noutflags=(BIO_FLAGS_READ|BIO_FLAGS_SHOULD_RETRY);\r\nret= -1;\r\ngoto end;\r\n}\r\n}\r\n#endif\r\nret=SSL_read(ssl,out,outl);\r\nswitch (SSL_get_error(ssl,ret))\r\n{\r\ncase SSL_ERROR_NONE:\r\nif (ret <= 0) break;\r\nif (sb->renegotiate_count > 0)\r\n{\r\nsb->byte_count+=ret;\r\nif (sb->byte_count > sb->renegotiate_count)\r\n{\r\nsb->byte_count=0;\r\nsb->num_renegotiates++;\r\nSSL_renegotiate(ssl);\r\nr=1;\r\n}\r\n}\r\nif ((sb->renegotiate_timeout > 0) && (!r))\r\n{\r\nunsigned long tm;\r\ntm=(unsigned long)time(NULL);\r\nif (tm > sb->last_time+sb->renegotiate_timeout)\r\n{\r\nsb->last_time=tm;\r\nsb->num_renegotiates++;\r\nSSL_renegotiate(ssl);\r\n}\r\n}\r\nbreak;\r\ncase SSL_ERROR_WANT_READ:\r\nBIO_set_retry_read(b);\r\nbreak;\r\ncase SSL_ERROR_WANT_WRITE:\r\nBIO_set_retry_write(b);\r\nbreak;\r\ncase SSL_ERROR_WANT_X509_LOOKUP:\r\nBIO_set_retry_special(b);\r\nretry_reason=BIO_RR_SSL_X509_LOOKUP;\r\nbreak;\r\ncase SSL_ERROR_WANT_CONNECT:\r\nBIO_set_retry_special(b);\r\nretry_reason=BIO_RR_CONNECT;\r\nbreak;\r\ncase SSL_ERROR_SYSCALL:\r\ncase SSL_ERROR_SSL:\r\ncase SSL_ERROR_ZERO_RETURN:\r\ndefault:\r\nbreak;\r\n}\r\nb->retry_reason=retry_reason;\r\nreturn(ret);\r\n}\r\nstatic int ssl_write(BIO *b, char *out, int outl)\r\n{\r\nint ret,r=0;\r\nint retry_reason=0;\r\nSSL *ssl;\r\nBIO_SSL *bs;\r\nif (out == NULL) return(0);\r\nbs=(BIO_SSL *)b->ptr;\r\nssl=bs->ssl;\r\nBIO_clear_retry_flags(b);\r\nret=SSL_write(ssl,out,outl);\r\nswitch (SSL_get_error(ssl,ret))\r\n{\r\ncase SSL_ERROR_NONE:\r\nif (ret <= 0) break;\r\nif (bs->renegotiate_count > 0)\r\n{\r\nbs->byte_count+=ret;\r\nif (bs->byte_count > bs->renegotiate_count)\r\n{\r\nbs->byte_count=0;\r\nbs->num_renegotiates++;\r\nSSL_renegotiate(ssl);\r\nr=1;\r\n}\r\n}\r\nif ((bs->renegotiate_timeout > 0) && (!r))\r\n{\r\nunsigned long tm;\r\ntm=(unsigned long)time(NULL);\r\nif (tm > bs->last_time+bs->renegotiate_timeout)\r\n{\r\nbs->last_time=tm;\r\nbs->num_renegotiates++;\r\nSSL_renegotiate(ssl);\r\n}\r\n}\r\nbreak;\r\ncase SSL_ERROR_WANT_WRITE:\r\nBIO_set_retry_write(b);\r\nbreak;\r\ncase SSL_ERROR_WANT_READ:\r\nBIO_set_retry_read(b);\r\nbreak;\r\ncase SSL_ERROR_WANT_X509_LOOKUP:\r\nBIO_set_retry_special(b);\r\nretry_reason=BIO_RR_SSL_X509_LOOKUP;\r\nbreak;\r\ncase SSL_ERROR_WANT_CONNECT:\r\nBIO_set_retry_special(b);\r\nretry_reason=BIO_RR_CONNECT;\r\ncase SSL_ERROR_SYSCALL:\r\ncase SSL_ERROR_SSL:\r\ndefault:\r\nbreak;\r\n}\r\nb->retry_reason=retry_reason;\r\nreturn(ret);\r\n}\r\nstatic long ssl_ctrl(BIO *b, int cmd, long num, char *ptr)\r\n{\r\nSSL **sslp,*ssl;\r\nBIO_SSL *bs;\r\nBIO *dbio,*bio;\r\nlong ret=1;\r\nbs=(BIO_SSL *)b->ptr;\r\nssl=bs->ssl;\r\nif ((ssl == NULL) && (cmd != BIO_C_SET_SSL))\r\nreturn(0);\r\nswitch (cmd)\r\n{\r\ncase BIO_CTRL_RESET:\r\nSSL_shutdown(ssl);\r\nif (ssl->handshake_func == ssl->method->ssl_connect)\r\nSSL_set_connect_state(ssl);\r\nelse if (ssl->handshake_func == ssl->method->ssl_accept)\r\nSSL_set_accept_state(ssl);\r\nSSL_clear(ssl);\r\nif (b->next_bio != NULL)\r\nret=BIO_ctrl(b->next_bio,cmd,num,ptr);\r\nelse if (ssl->rbio != NULL)\r\nret=BIO_ctrl(ssl->rbio,cmd,num,ptr);\r\nelse\r\nret=1;\r\nbreak;\r\ncase BIO_CTRL_INFO:\r\nret=0;\r\nbreak;\r\ncase BIO_C_SSL_MODE:\r\nif (num)\r\nSSL_set_connect_state(ssl);\r\nelse\r\nSSL_set_accept_state(ssl);\r\nbreak;\r\ncase BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT:\r\nret=bs->renegotiate_timeout;\r\nif (num < 60) num=5;\r\nbs->renegotiate_timeout=(unsigned long)num;\r\nbs->last_time=(unsigned long)time(NULL);\r\nbreak;\r\ncase BIO_C_SET_SSL_RENEGOTIATE_BYTES:\r\nret=bs->renegotiate_count;\r\nif ((long)num >=512)\r\nbs->renegotiate_count=(unsigned long)num;\r\nbreak;\r\ncase BIO_C_GET_SSL_NUM_RENEGOTIATES:\r\nret=bs->num_renegotiates;\r\nbreak;\r\ncase BIO_C_SET_SSL:\r\nif (ssl != NULL)\r\nssl_free(b);\r\nb->shutdown=(int)num;\r\nssl=(SSL *)ptr;\r\n((BIO_SSL *)b->ptr)->ssl=ssl;\r\nbio=SSL_get_rbio(ssl);\r\nif (bio != NULL)\r\n{\r\nif (b->next_bio != NULL)\r\nBIO_push(bio,b->next_bio);\r\nb->next_bio=bio;\r\nCRYPTO_add(&bio->references,1,CRYPTO_LOCK_BIO);\r\n}\r\nb->init=1;\r\nbreak;\r\ncase BIO_C_GET_SSL:\r\nif (ptr != NULL)\r\n{\r\nsslp=(SSL **)ptr;\r\n*sslp=ssl;\r\n}\r\nelse\r\nret=0;\r\nbreak;\r\ncase BIO_CTRL_GET_CLOSE:\r\nret=b->shutdown;\r\nbreak;\r\ncase BIO_CTRL_SET_CLOSE:\r\nb->shutdown=(int)num;\r\nbreak;\r\ncase BIO_CTRL_WPENDING:\r\nret=BIO_ctrl(ssl->wbio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_PENDING:\r\nret=SSL_pending(ssl);\r\nif (ret == 0)\r\nret=BIO_pending(ssl->rbio);\r\nbreak;\r\ncase BIO_CTRL_FLUSH:\r\nBIO_clear_retry_flags(b);\r\nret=BIO_ctrl(ssl->wbio,cmd,num,ptr);\r\nBIO_copy_next_retry(b);\r\nbreak;\r\ncase BIO_CTRL_PUSH:\r\nif ((b->next_bio != NULL) && (b->next_bio != ssl->rbio))\r\n{\r\nSSL_set_bio(ssl,b->next_bio,b->next_bio);\r\nCRYPTO_add(&b->next_bio->references,1,CRYPTO_LOCK_BIO);\r\n}\r\nbreak;\r\ncase BIO_CTRL_POP:\r\nif (ssl->rbio != ssl->wbio)\r\n{\r\nBIO_free_all(ssl->wbio);\r\n}\r\nssl->wbio=NULL;\r\nssl->rbio=NULL;\r\nbreak;\r\ncase BIO_C_DO_STATE_MACHINE:\r\nBIO_clear_retry_flags(b);\r\nb->retry_reason=0;\r\nret=(int)SSL_do_handshake(ssl);\r\nswitch (SSL_get_error(ssl,(int)ret))\r\n{\r\ncase SSL_ERROR_WANT_READ:\r\nBIO_set_flags(b,\r\nBIO_FLAGS_READ|BIO_FLAGS_SHOULD_RETRY);\r\nbreak;\r\ncase SSL_ERROR_WANT_WRITE:\r\nBIO_set_flags(b,\r\nBIO_FLAGS_WRITE|BIO_FLAGS_SHOULD_RETRY);\r\nbreak;\r\ncase SSL_ERROR_WANT_CONNECT:\r\nBIO_set_flags(b,\r\nBIO_FLAGS_IO_SPECIAL|BIO_FLAGS_SHOULD_RETRY);\r\nb->retry_reason=b->next_bio->retry_reason;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase BIO_CTRL_DUP:\r\ndbio=(BIO *)ptr;\r\nif (((BIO_SSL *)dbio->ptr)->ssl != NULL)\r\nSSL_free(((BIO_SSL *)dbio->ptr)->ssl);\r\n((BIO_SSL *)dbio->ptr)->ssl=SSL_dup(ssl);\r\n((BIO_SSL *)dbio->ptr)->renegotiate_count=\r\n((BIO_SSL *)b->ptr)->renegotiate_count;\r\n((BIO_SSL *)dbio->ptr)->byte_count=\r\n((BIO_SSL *)b->ptr)->byte_count;\r\n((BIO_SSL *)dbio->ptr)->renegotiate_timeout=\r\n((BIO_SSL *)b->ptr)->renegotiate_timeout;\r\n((BIO_SSL *)dbio->ptr)->last_time=\r\n((BIO_SSL *)b->ptr)->last_time;\r\nret=(((BIO_SSL *)dbio->ptr)->ssl != NULL);\r\nbreak;\r\ncase BIO_C_GET_FD:\r\nret=BIO_ctrl(ssl->rbio,cmd,num,ptr);\r\nbreak;\r\ncase BIO_CTRL_SET_CALLBACK:\r\nSSL_set_info_callback(ssl,(void (*)())ptr);\r\nbreak;\r\ncase BIO_CTRL_GET_CALLBACK:\r\n{\r\nvoid (**fptr)();\r\nfptr=(void (**)())ptr;\r\n*fptr=SSL_get_info_callback(ssl);\r\n}\r\nbreak;\r\ndefault:\r\nret=BIO_ctrl(ssl->rbio,cmd,num,ptr);\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic int ssl_puts(BIO *bp, char *str)\r\n{\r\nint n,ret;\r\nn=strlen(str);\r\nret=BIO_write(bp,str,n);\r\nreturn(ret);\r\n}\r\nBIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx)\r\n{\r\nBIO *ret=NULL,*buf=NULL,*ssl=NULL;\r\nif ((buf=BIO_new(BIO_f_buffer())) == NULL)\r\nreturn(NULL);\r\nif ((ssl=BIO_new_ssl_connect(ctx)) == NULL)\r\ngoto err;\r\nif ((ret=BIO_push(buf,ssl)) == NULL)\r\ngoto err;\r\nreturn(ret);\r\nerr:\r\nif (buf != NULL) BIO_free(buf);\r\nif (ssl != NULL) BIO_free(ssl);\r\nreturn(NULL);\r\n}\r\nBIO *BIO_new_ssl_connect(SSL_CTX *ctx)\r\n{\r\nBIO *ret=NULL,*con=NULL,*ssl=NULL;\r\nif ((con=BIO_new(BIO_s_connect())) == NULL)\r\nreturn(NULL);\r\nif ((ssl=BIO_new_ssl(ctx,1)) == NULL)\r\ngoto err;\r\nif ((ret=BIO_push(ssl,con)) == NULL)\r\ngoto err;\r\nreturn(ret);\r\nerr:\r\nif (con != NULL) BIO_free(con);\r\nif (ret != NULL) BIO_free(ret);\r\nreturn(NULL);\r\n}\r\nBIO *BIO_new_ssl(SSL_CTX *ctx, int client)\r\n{\r\nBIO *ret;\r\nSSL *ssl;\r\nif ((ret=BIO_new(BIO_f_ssl())) == NULL)\r\nreturn(NULL);\r\nif ((ssl=SSL_new(ctx)) == NULL)\r\n{\r\nBIO_free(ret);\r\nreturn(NULL);\r\n}\r\nif (client)\r\nSSL_set_connect_state(ssl);\r\nelse\r\nSSL_set_accept_state(ssl);\r\nBIO_set_ssl(ret,ssl,BIO_CLOSE);\r\nreturn(ret);\r\n}\r\nint BIO_ssl_copy_session_id(BIO *t, BIO *f)\r\n{\r\nt=BIO_find_type(t,BIO_TYPE_SSL);\r\nf=BIO_find_type(f,BIO_TYPE_SSL);\r\nif ((t == NULL) || (f == NULL))\r\nreturn(0);\r\nif ( (((BIO_SSL *)t->ptr)->ssl == NULL) ||\r\n(((BIO_SSL *)f->ptr)->ssl == NULL))\r\nreturn(0);\r\nSSL_copy_session_id(((BIO_SSL *)t->ptr)->ssl,((BIO_SSL *)f->ptr)->ssl);\r\nreturn(1);\r\n}\r\nvoid BIO_ssl_shutdown(BIO *b)\r\n{\r\nSSL *s;\r\nwhile (b != NULL)\r\n{\r\nif (b->method->type == BIO_TYPE_SSL)\r\n{\r\ns=((BIO_SSL *)b->ptr)->ssl;\r\nSSL_shutdown(s);\r\nbreak;\r\n}\r\nb=b->next_bio;\r\n}\r\n}
