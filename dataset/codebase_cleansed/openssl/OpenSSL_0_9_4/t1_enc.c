static void tls1_P_hash(const EVP_MD *md, const unsigned char *sec,\r\nint sec_len, unsigned char *seed, int seed_len,\r\nunsigned char *out, int olen)\r\n{\r\nint chunk,n;\r\nunsigned int j;\r\nHMAC_CTX ctx;\r\nHMAC_CTX ctx_tmp;\r\nunsigned char A1[HMAC_MAX_MD_CBLOCK];\r\nunsigned int A1_len;\r\nchunk=EVP_MD_size(md);\r\nHMAC_Init(&ctx,sec,sec_len,md);\r\nHMAC_Update(&ctx,seed,seed_len);\r\nHMAC_Final(&ctx,A1,&A1_len);\r\nn=0;\r\nfor (;;)\r\n{\r\nHMAC_Init(&ctx,NULL,0,NULL);\r\nHMAC_Update(&ctx,A1,A1_len);\r\nmemcpy(&ctx_tmp,&ctx,sizeof(ctx));\r\nHMAC_Update(&ctx,seed,seed_len);\r\nif (olen > chunk)\r\n{\r\nHMAC_Final(&ctx,out,&j);\r\nout+=j;\r\nolen-=j;\r\nHMAC_Final(&ctx_tmp,A1,&A1_len);\r\n}\r\nelse\r\n{\r\nHMAC_Final(&ctx,A1,&A1_len);\r\nmemcpy(out,A1,olen);\r\nbreak;\r\n}\r\n}\r\nHMAC_cleanup(&ctx);\r\nHMAC_cleanup(&ctx_tmp);\r\nmemset(A1,0,sizeof(A1));\r\n}\r\nstatic void tls1_PRF(const EVP_MD *md5, const EVP_MD *sha1,\r\nunsigned char *label, int label_len,\r\nconst unsigned char *sec, int slen, unsigned char *out1,\r\nunsigned char *out2, int olen)\r\n{\r\nint len,i;\r\nconst unsigned char *S1,*S2;\r\nlen=slen/2;\r\nS1=sec;\r\nS2= &(sec[len]);\r\nlen+=(slen&1);\r\ntls1_P_hash(md5 ,S1,len,label,label_len,out1,olen);\r\ntls1_P_hash(sha1,S2,len,label,label_len,out2,olen);\r\nfor (i=0; i<olen; i++)\r\nout1[i]^=out2[i];\r\n}\r\nstatic void tls1_generate_key_block(SSL *s, unsigned char *km,\r\nunsigned char *tmp, int num)\r\n{\r\nunsigned char *p;\r\nunsigned char buf[SSL3_RANDOM_SIZE*2+\r\nTLS_MD_MAX_CONST_SIZE];\r\np=buf;\r\nmemcpy(p,TLS_MD_KEY_EXPANSION_CONST,\r\nTLS_MD_KEY_EXPANSION_CONST_SIZE);\r\np+=TLS_MD_KEY_EXPANSION_CONST_SIZE;\r\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\r\np+=SSL3_RANDOM_SIZE;\r\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\r\np+=SSL3_RANDOM_SIZE;\r\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),\r\ns->session->master_key,s->session->master_key_length,\r\nkm,tmp,num);\r\n}\r\nint tls1_change_cipher_state(SSL *s, int which)\r\n{\r\nstatic const unsigned char empty[]="";\r\nunsigned char *p,*key_block,*mac_secret;\r\nunsigned char *exp_label,buf[TLS_MD_MAX_CONST_SIZE+\r\nSSL3_RANDOM_SIZE*2];\r\nunsigned char tmp1[EVP_MAX_KEY_LENGTH];\r\nunsigned char tmp2[EVP_MAX_KEY_LENGTH];\r\nunsigned char iv1[EVP_MAX_IV_LENGTH*2];\r\nunsigned char iv2[EVP_MAX_IV_LENGTH*2];\r\nunsigned char *ms,*key,*iv,*er1,*er2;\r\nint client_write;\r\nEVP_CIPHER_CTX *dd;\r\nconst EVP_CIPHER *c;\r\nconst SSL_COMP *comp;\r\nconst EVP_MD *m;\r\nint _exp,n,i,j,k,exp_label_len,cl;\r\n_exp=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\r\nc=s->s3->tmp.new_sym_enc;\r\nm=s->s3->tmp.new_hash;\r\ncomp=s->s3->tmp.new_compression;\r\nkey_block=s->s3->tmp.key_block;\r\nif (which & SSL3_CC_READ)\r\n{\r\nif ((s->enc_read_ctx == NULL) &&\r\n((s->enc_read_ctx=(EVP_CIPHER_CTX *)\r\nMalloc(sizeof(EVP_CIPHER_CTX))) == NULL))\r\ngoto err;\r\ndd= s->enc_read_ctx;\r\ns->read_hash=m;\r\nif (s->expand != NULL)\r\n{\r\nCOMP_CTX_free(s->expand);\r\ns->expand=NULL;\r\n}\r\nif (comp != NULL)\r\n{\r\ns->expand=COMP_CTX_new(comp->method);\r\nif (s->expand == NULL)\r\n{\r\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\r\ngoto err2;\r\n}\r\nif (s->s3->rrec.comp == NULL)\r\ns->s3->rrec.comp=(unsigned char *)\r\nMalloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);\r\nif (s->s3->rrec.comp == NULL)\r\ngoto err;\r\n}\r\nmemset(&(s->s3->read_sequence[0]),0,8);\r\nmac_secret= &(s->s3->read_mac_secret[0]);\r\n}\r\nelse\r\n{\r\nif ((s->enc_write_ctx == NULL) &&\r\n((s->enc_write_ctx=(EVP_CIPHER_CTX *)\r\nMalloc(sizeof(EVP_CIPHER_CTX))) == NULL))\r\ngoto err;\r\ndd= s->enc_write_ctx;\r\ns->write_hash=m;\r\nif (s->compress != NULL)\r\n{\r\nCOMP_CTX_free(s->compress);\r\ns->compress=NULL;\r\n}\r\nif (comp != NULL)\r\n{\r\ns->compress=COMP_CTX_new(comp->method);\r\nif (s->compress == NULL)\r\n{\r\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);\r\ngoto err2;\r\n}\r\n}\r\nmemset(&(s->s3->write_sequence[0]),0,8);\r\nmac_secret= &(s->s3->write_mac_secret[0]);\r\n}\r\nEVP_CIPHER_CTX_init(dd);\r\np=s->s3->tmp.key_block;\r\ni=EVP_MD_size(m);\r\ncl=EVP_CIPHER_key_length(c);\r\nj=_exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?\r\ncl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;\r\nk=EVP_CIPHER_iv_length(c);\r\ner1= &(s->s3->client_random[0]);\r\ner2= &(s->s3->server_random[0]);\r\nif ( (which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\r\n(which == SSL3_CHANGE_CIPHER_SERVER_READ))\r\n{\r\nms= &(p[ 0]); n=i+i;\r\nkey= &(p[ n]); n+=j+j;\r\niv= &(p[ n]); n+=k+k;\r\nexp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;\r\nexp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;\r\nclient_write=1;\r\n}\r\nelse\r\n{\r\nn=i;\r\nms= &(p[ n]); n+=i+j;\r\nkey= &(p[ n]); n+=j+k;\r\niv= &(p[ n]); n+=k;\r\nexp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;\r\nexp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;\r\nclient_write=0;\r\n}\r\nif (n > s->s3->tmp.key_block_length)\r\n{\r\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_INTERNAL_ERROR);\r\ngoto err2;\r\n}\r\nmemcpy(mac_secret,ms,i);\r\n#ifdef TLS_DEBUG\r\nprintf("which = %04X\nmac key=",which);\r\n{ int z; for (z=0; z<i; z++) printf("%02X%c",ms[z],((z+1)%16)?' ':'\n'); }\r\n#endif\r\nif (_exp)\r\n{\r\np=buf;\r\nmemcpy(p,exp_label,exp_label_len);\r\np+=exp_label_len;\r\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\r\np+=SSL3_RANDOM_SIZE;\r\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\r\np+=SSL3_RANDOM_SIZE;\r\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(p-buf),key,j,\r\ntmp1,tmp2,EVP_CIPHER_key_length(c));\r\nkey=tmp1;\r\nif (k > 0)\r\n{\r\np=buf;\r\nmemcpy(p,TLS_MD_IV_BLOCK_CONST,\r\nTLS_MD_IV_BLOCK_CONST_SIZE);\r\np+=TLS_MD_IV_BLOCK_CONST_SIZE;\r\nmemcpy(p,s->s3->client_random,SSL3_RANDOM_SIZE);\r\np+=SSL3_RANDOM_SIZE;\r\nmemcpy(p,s->s3->server_random,SSL3_RANDOM_SIZE);\r\np+=SSL3_RANDOM_SIZE;\r\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,p-buf,empty,0,\r\niv1,iv2,k*2);\r\nif (client_write)\r\niv=iv1;\r\nelse\r\niv= &(iv1[k]);\r\n}\r\n}\r\ns->session->key_arg_length=0;\r\nEVP_CipherInit(dd,c,key,iv,(which & SSL3_CC_WRITE));\r\n#ifdef TLS_DEBUG\r\nprintf("which = %04X\nkey=",which);\r\n{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf("%02X%c",key[z],((z+1)%16)?' ':'\n'); }\r\nprintf("\niv=");\r\n{ int z; for (z=0; z<k; z++) printf("%02X%c",iv[z],((z+1)%16)?' ':'\n'); }\r\nprintf("\n");\r\n#endif\r\nmemset(tmp1,0,sizeof(tmp1));\r\nmemset(tmp2,0,sizeof(tmp1));\r\nmemset(iv1,0,sizeof(iv1));\r\nmemset(iv2,0,sizeof(iv2));\r\nreturn(1);\r\nerr:\r\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);\r\nerr2:\r\nreturn(0);\r\n}\r\nint tls1_setup_key_block(SSL *s)\r\n{\r\nunsigned char *p1,*p2;\r\nconst EVP_CIPHER *c;\r\nconst EVP_MD *hash;\r\nint num;\r\nSSL_COMP *comp;\r\nif (s->s3->tmp.key_block_length != 0)\r\nreturn(1);\r\nif (!ssl_cipher_get_evp(s->session,&c,&hash,&comp))\r\n{\r\nSSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\r\nreturn(0);\r\n}\r\ns->s3->tmp.new_sym_enc=c;\r\ns->s3->tmp.new_hash=hash;\r\nnum=EVP_CIPHER_key_length(c)+EVP_MD_size(hash)+EVP_CIPHER_iv_length(c);\r\nnum*=2;\r\nssl3_cleanup_key_block(s);\r\nif ((p1=(unsigned char *)Malloc(num)) == NULL)\r\ngoto err;\r\nif ((p2=(unsigned char *)Malloc(num)) == NULL)\r\ngoto err;\r\ns->s3->tmp.key_block_length=num;\r\ns->s3->tmp.key_block=p1;\r\n#ifdef TLS_DEBUG\r\nprintf("client random\n");\r\n{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf("%02X%c",s->s3->client_random[z],((z+1)%16)?' ':'\n'); }\r\nprintf("server random\n");\r\n{ int z; for (z=0; z<SSL3_RANDOM_SIZE; z++) printf("%02X%c",s->s3->server_random[z],((z+1)%16)?' ':'\n'); }\r\nprintf("pre-master\n");\r\n{ int z; for (z=0; z<s->session->master_key_length; z++) printf("%02X%c",s->session->master_key[z],((z+1)%16)?' ':'\n'); }\r\n#endif\r\ntls1_generate_key_block(s,p1,p2,num);\r\nmemset(p2,0,num);\r\nFree(p2);\r\n#ifdef TLS_DEBUG\r\nprintf("\nkey block\n");\r\n{ int z; for (z=0; z<num; z++) printf("%02X%c",p1[z],((z+1)%16)?' ':'\n'); }\r\n#endif\r\nreturn(1);\r\nerr:\r\nSSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK,ERR_R_MALLOC_FAILURE);\r\nreturn(0);\r\n}\r\nint tls1_enc(SSL *s, int send)\r\n{\r\nSSL3_RECORD *rec;\r\nEVP_CIPHER_CTX *ds;\r\nunsigned long l;\r\nint bs,i,ii,j,k,n=0;\r\nconst EVP_CIPHER *enc;\r\nif (send)\r\n{\r\nif (s->write_hash != NULL)\r\nn=EVP_MD_size(s->write_hash);\r\nds=s->enc_write_ctx;\r\nrec= &(s->s3->wrec);\r\nif (s->enc_write_ctx == NULL)\r\nenc=NULL;\r\nelse\r\nenc=EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\r\n}\r\nelse\r\n{\r\nif (s->read_hash != NULL)\r\nn=EVP_MD_size(s->read_hash);\r\nds=s->enc_read_ctx;\r\nrec= &(s->s3->rrec);\r\nif (s->enc_read_ctx == NULL)\r\nenc=NULL;\r\nelse\r\nenc=EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\r\n}\r\nif ((s->session == NULL) || (ds == NULL) ||\r\n(enc == NULL))\r\n{\r\nmemcpy(rec->data,rec->input,rec->length);\r\nrec->input=rec->data;\r\n}\r\nelse\r\n{\r\nl=rec->length;\r\nbs=EVP_CIPHER_block_size(ds->cipher);\r\nif ((bs != 1) && send)\r\n{\r\ni=bs-((int)l%bs);\r\nj=i-1;\r\nif (s->options & SSL_OP_TLS_BLOCK_PADDING_BUG)\r\n{\r\nif (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)\r\nj++;\r\n}\r\nfor (k=(int)l; k<(int)(l+i); k++)\r\nrec->input[k]=j;\r\nl+=i;\r\nrec->length+=i;\r\n}\r\nEVP_Cipher(ds,rec->data,rec->input,l);\r\nif ((bs != 1) && !send)\r\n{\r\nii=i=rec->data[l-1];\r\ni++;\r\nif (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG)\r\n{\r\nif ((memcmp(s->s3->read_sequence,\r\n"\0\0\0\0\0\0\0\0",8) == 0) && !(ii & 1))\r\ns->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;\r\nif (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)\r\ni--;\r\n}\r\nif (i > (int)rec->length)\r\n{\r\nSSLerr(SSL_F_TLS1_ENC,SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);\r\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);\r\nreturn(0);\r\n}\r\nfor (j=(int)(l-i); j<(int)l; j++)\r\n{\r\nif (rec->data[j] != ii)\r\n{\r\nSSLerr(SSL_F_TLS1_ENC,SSL_R_DECRYPTION_FAILED);\r\nssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_DECRYPTION_FAILED);\r\nreturn(0);\r\n}\r\n}\r\nrec->length-=i;\r\n}\r\n}\r\nreturn(1);\r\n}\r\nint tls1_cert_verify_mac(SSL *s, EVP_MD_CTX *in_ctx, unsigned char *out)\r\n{\r\nunsigned int ret;\r\nEVP_MD_CTX ctx;\r\nEVP_MD_CTX_copy(&ctx,in_ctx);\r\nEVP_DigestFinal(&ctx,out,&ret);\r\nreturn((int)ret);\r\n}\r\nint tls1_final_finish_mac(SSL *s, EVP_MD_CTX *in1_ctx, EVP_MD_CTX *in2_ctx,\r\nunsigned char *str, int slen, unsigned char *out)\r\n{\r\nunsigned int i;\r\nEVP_MD_CTX ctx;\r\nunsigned char buf[TLS_MD_MAX_CONST_SIZE+MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\r\nunsigned char *q,buf2[12];\r\nq=buf;\r\nmemcpy(q,str,slen);\r\nq+=slen;\r\nEVP_MD_CTX_copy(&ctx,in1_ctx);\r\nEVP_DigestFinal(&ctx,q,&i);\r\nq+=i;\r\nEVP_MD_CTX_copy(&ctx,in2_ctx);\r\nEVP_DigestFinal(&ctx,q,&i);\r\nq+=i;\r\ntls1_PRF(s->ctx->md5,s->ctx->sha1,buf,(int)(q-buf),\r\ns->session->master_key,s->session->master_key_length,\r\nout,buf2,12);\r\nmemset(&ctx,0,sizeof(EVP_MD_CTX));\r\nreturn((int)12);\r\n}\r\nint tls1_mac(SSL *ssl, unsigned char *md, int send)\r\n{\r\nSSL3_RECORD *rec;\r\nunsigned char *mac_sec,*seq;\r\nconst EVP_MD *hash;\r\nunsigned int md_size;\r\nint i;\r\nHMAC_CTX hmac;\r\nunsigned char buf[5];\r\nif (send)\r\n{\r\nrec= &(ssl->s3->wrec);\r\nmac_sec= &(ssl->s3->write_mac_secret[0]);\r\nseq= &(ssl->s3->write_sequence[0]);\r\nhash=ssl->write_hash;\r\n}\r\nelse\r\n{\r\nrec= &(ssl->s3->rrec);\r\nmac_sec= &(ssl->s3->read_mac_secret[0]);\r\nseq= &(ssl->s3->read_sequence[0]);\r\nhash=ssl->read_hash;\r\n}\r\nmd_size=EVP_MD_size(hash);\r\nbuf[0]=rec->type;\r\nbuf[1]=TLS1_VERSION_MAJOR;\r\nbuf[2]=TLS1_VERSION_MINOR;\r\nbuf[3]=rec->length>>8;\r\nbuf[4]=rec->length&0xff;\r\nHMAC_Init(&hmac,mac_sec,EVP_MD_size(hash),hash);\r\nHMAC_Update(&hmac,seq,8);\r\nHMAC_Update(&hmac,buf,5);\r\nHMAC_Update(&hmac,rec->input,rec->length);\r\nHMAC_Final(&hmac,md,&md_size);\r\n#ifdef TLS_DEBUG\r\nprintf("sec=");\r\n{unsigned int z; for (z=0; z<md_size; z++) printf("%02X ",mac_sec[z]); printf("\n"); }\r\nprintf("seq=");\r\n{int z; for (z=0; z<8; z++) printf("%02X ",seq[z]); printf("\n"); }\r\nprintf("buf=");\r\n{int z; for (z=0; z<5; z++) printf("%02X ",buf[z]); printf("\n"); }\r\nprintf("rec=");\r\n{unsigned int z; for (z=0; z<rec->length; z++) printf("%02X ",buf[z]); printf("\n"); }\r\n#endif\r\nfor (i=7; i>=0; i--)\r\nif (++seq[i]) break;\r\n#ifdef TLS_DEBUG\r\n{unsigned int z; for (z=0; z<md_size; z++) printf("%02X ",md[z]); printf("\n"); }\r\n#endif\r\nreturn(md_size);\r\n}\r\nint tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,\r\nint len)\r\n{\r\nunsigned char buf[SSL3_RANDOM_SIZE*2+TLS_MD_MASTER_SECRET_CONST_SIZE];\r\nunsigned char buff[SSL_MAX_MASTER_KEY_LENGTH];\r\nmemcpy(buf,TLS_MD_MASTER_SECRET_CONST,\r\nTLS_MD_MASTER_SECRET_CONST_SIZE);\r\nmemcpy(&(buf[TLS_MD_MASTER_SECRET_CONST_SIZE]),\r\ns->s3->client_random,SSL3_RANDOM_SIZE);\r\nmemcpy(&(buf[SSL3_RANDOM_SIZE+TLS_MD_MASTER_SECRET_CONST_SIZE]),\r\ns->s3->server_random,SSL3_RANDOM_SIZE);\r\ntls1_PRF(s->ctx->md5,s->ctx->sha1,\r\nbuf,TLS_MD_MASTER_SECRET_CONST_SIZE+SSL3_RANDOM_SIZE*2,p,len,\r\ns->session->master_key,buff,SSL3_MASTER_SECRET_SIZE);\r\nreturn(SSL3_MASTER_SECRET_SIZE);\r\n}\r\nint tls1_alert_code(int code)\r\n{\r\nswitch (code)\r\n{\r\ncase SSL_AD_CLOSE_NOTIFY: return(SSL3_AD_CLOSE_NOTIFY);\r\ncase SSL_AD_UNEXPECTED_MESSAGE: return(SSL3_AD_UNEXPECTED_MESSAGE);\r\ncase SSL_AD_BAD_RECORD_MAC: return(SSL3_AD_BAD_RECORD_MAC);\r\ncase SSL_AD_DECRYPTION_FAILED: return(TLS1_AD_DECRYPTION_FAILED);\r\ncase SSL_AD_RECORD_OVERFLOW: return(TLS1_AD_RECORD_OVERFLOW);\r\ncase SSL_AD_DECOMPRESSION_FAILURE:return(SSL3_AD_DECOMPRESSION_FAILURE);\r\ncase SSL_AD_HANDSHAKE_FAILURE: return(SSL3_AD_HANDSHAKE_FAILURE);\r\ncase SSL_AD_NO_CERTIFICATE: return(-1);\r\ncase SSL_AD_BAD_CERTIFICATE: return(SSL3_AD_BAD_CERTIFICATE);\r\ncase SSL_AD_UNSUPPORTED_CERTIFICATE:return(SSL3_AD_UNSUPPORTED_CERTIFICATE);\r\ncase SSL_AD_CERTIFICATE_REVOKED:return(SSL3_AD_CERTIFICATE_REVOKED);\r\ncase SSL_AD_CERTIFICATE_EXPIRED:return(SSL3_AD_CERTIFICATE_EXPIRED);\r\ncase SSL_AD_CERTIFICATE_UNKNOWN:return(SSL3_AD_CERTIFICATE_UNKNOWN);\r\ncase SSL_AD_ILLEGAL_PARAMETER: return(SSL3_AD_ILLEGAL_PARAMETER);\r\ncase SSL_AD_UNKNOWN_CA: return(TLS1_AD_UNKNOWN_CA);\r\ncase SSL_AD_ACCESS_DENIED: return(TLS1_AD_ACCESS_DENIED);\r\ncase SSL_AD_DECODE_ERROR: return(TLS1_AD_DECODE_ERROR);\r\ncase SSL_AD_DECRYPT_ERROR: return(TLS1_AD_DECRYPT_ERROR);\r\ncase SSL_AD_EXPORT_RESTRICION: return(TLS1_AD_EXPORT_RESTRICION);\r\ncase SSL_AD_PROTOCOL_VERSION: return(TLS1_AD_PROTOCOL_VERSION);\r\ncase SSL_AD_INSUFFICIENT_SECURITY:return(TLS1_AD_INSUFFICIENT_SECURITY);\r\ncase SSL_AD_INTERNAL_ERROR: return(TLS1_AD_INTERNAL_ERROR);\r\ncase SSL_AD_USER_CANCLED: return(TLS1_AD_USER_CANCLED);\r\ncase SSL_AD_NO_RENEGOTIATION: return(TLS1_AD_NO_RENEGOTIATION);\r\ndefault: return(-1);\r\n}\r\n}
