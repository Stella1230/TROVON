static long ssl3_default_timeout(void)\r\n{\r\nreturn(60*60*2);\r\n}\r\nSSL_METHOD *sslv3_base_method(void)\r\n{\r\nreturn(&SSLv3_data);\r\n}\r\nint ssl3_num_ciphers(void)\r\n{\r\nreturn(SSL3_NUM_CIPHERS);\r\n}\r\nSSL_CIPHER *ssl3_get_cipher(unsigned int u)\r\n{\r\nif (u < SSL3_NUM_CIPHERS)\r\nreturn(&(ssl3_ciphers[SSL3_NUM_CIPHERS-1-u]));\r\nelse\r\nreturn(NULL);\r\n}\r\nint ssl3_pending(SSL *s)\r\n{\r\nreturn(s->s3->rrec.length);\r\n}\r\nint ssl3_new(SSL *s)\r\n{\r\nSSL3_CTX *s3;\r\nif ((s3=(SSL3_CTX *)Malloc(sizeof(SSL3_CTX))) == NULL) goto err;\r\nmemset(s3,0,sizeof(SSL3_CTX));\r\ns->s3=s3;\r\ns->method->ssl_clear(s);\r\nreturn(1);\r\nerr:\r\nreturn(0);\r\n}\r\nvoid ssl3_free(SSL *s)\r\n{\r\nif(s == NULL)\r\nreturn;\r\nssl3_cleanup_key_block(s);\r\nif (s->s3->rbuf.buf != NULL)\r\nFree(s->s3->rbuf.buf);\r\nif (s->s3->wbuf.buf != NULL)\r\nFree(s->s3->wbuf.buf);\r\nif (s->s3->rrec.comp != NULL)\r\nFree(s->s3->rrec.comp);\r\n#ifndef NO_DH\r\nif (s->s3->tmp.dh != NULL)\r\nDH_free(s->s3->tmp.dh);\r\n#endif\r\nif (s->s3->tmp.ca_names != NULL)\r\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\r\nmemset(s->s3,0,sizeof(SSL3_CTX));\r\nFree(s->s3);\r\ns->s3=NULL;\r\n}\r\nvoid ssl3_clear(SSL *s)\r\n{\r\nunsigned char *rp,*wp;\r\nssl3_cleanup_key_block(s);\r\nif (s->s3->tmp.ca_names != NULL)\r\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\r\nif (s->s3->rrec.comp != NULL)\r\n{\r\nFree(s->s3->rrec.comp);\r\ns->s3->rrec.comp=NULL;\r\n}\r\nrp=s->s3->rbuf.buf;\r\nwp=s->s3->wbuf.buf;\r\nmemset(s->s3,0,sizeof(SSL3_CTX));\r\nif (rp != NULL) s->s3->rbuf.buf=rp;\r\nif (wp != NULL) s->s3->wbuf.buf=wp;\r\nssl_free_wbio_buffer(s);\r\ns->packet_length=0;\r\ns->s3->renegotiate=0;\r\ns->s3->total_renegotiations=0;\r\ns->s3->num_renegotiations=0;\r\ns->s3->in_read_app_data=0;\r\ns->version=SSL3_VERSION;\r\n}\r\nlong ssl3_ctrl(SSL *s, int cmd, long larg, char *parg)\r\n{\r\nint ret=0;\r\n#if !defined(NO_DSA) || !defined(NO_RSA)\r\nif (\r\n#ifndef NO_RSA\r\ncmd == SSL_CTRL_SET_TMP_RSA ||\r\ncmd == SSL_CTRL_SET_TMP_RSA_CB ||\r\n#endif\r\n#ifndef NO_DSA\r\ncmd == SSL_CTRL_SET_TMP_DH ||\r\ncmd == SSL_CTRL_SET_TMP_DH_CB ||\r\n#endif\r\n0)\r\n{\r\nif (!ssl_cert_inst(&s->cert))\r\n{\r\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_MALLOC_FAILURE);\r\nreturn(0);\r\n}\r\n}\r\n#endif\r\nswitch (cmd)\r\n{\r\ncase SSL_CTRL_GET_SESSION_REUSED:\r\nret=s->hit;\r\nbreak;\r\ncase SSL_CTRL_GET_CLIENT_CERT_REQUEST:\r\nbreak;\r\ncase SSL_CTRL_GET_NUM_RENEGOTIATIONS:\r\nret=s->s3->num_renegotiations;\r\nbreak;\r\ncase SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS:\r\nret=s->s3->num_renegotiations;\r\ns->s3->num_renegotiations=0;\r\nbreak;\r\ncase SSL_CTRL_GET_TOTAL_RENEGOTIATIONS:\r\nret=s->s3->total_renegotiations;\r\nbreak;\r\ncase SSL_CTRL_GET_FLAGS:\r\nret=(int)(s->s3->flags);\r\nbreak;\r\n#ifndef NO_RSA\r\ncase SSL_CTRL_NEED_TMP_RSA:\r\nif ((s->cert != NULL) && (s->cert->rsa_tmp == NULL) &&\r\n((s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\r\n(EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) > (512/8))))\r\nret = 1;\r\nbreak;\r\ncase SSL_CTRL_SET_TMP_RSA:\r\n{\r\nRSA *rsa = (RSA *)parg;\r\nif (rsa == NULL) {\r\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\r\nreturn(ret);\r\n}\r\nif ((rsa = RSAPrivateKey_dup(rsa)) == NULL) {\r\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_RSA_LIB);\r\nreturn(ret);\r\n}\r\nif (s->cert->rsa_tmp != NULL)\r\nRSA_free(s->cert->rsa_tmp);\r\ns->cert->rsa_tmp = rsa;\r\nret = 1;\r\n}\r\nbreak;\r\ncase SSL_CTRL_SET_TMP_RSA_CB:\r\ns->cert->rsa_tmp_cb = (RSA *(*)(SSL *, int, int))parg;\r\nbreak;\r\n#endif\r\n#ifndef NO_DH\r\ncase SSL_CTRL_SET_TMP_DH:\r\n{\r\nDH *dh = (DH *)parg;\r\nif (dh == NULL) {\r\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\r\nreturn(ret);\r\n}\r\nif ((dh = DHparams_dup(dh)) == NULL) {\r\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\r\nreturn(ret);\r\n}\r\nif (!DH_generate_key(dh)) {\r\nDH_free(dh);\r\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\r\nreturn(ret);\r\n}\r\nif (s->cert->dh_tmp != NULL)\r\nDH_free(s->cert->dh_tmp);\r\ns->cert->dh_tmp = dh;\r\nret = 1;\r\n}\r\nbreak;\r\ncase SSL_CTRL_SET_TMP_DH_CB:\r\ns->cert->dh_tmp_cb = (DH *(*)(SSL *, int, int))parg;\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nlong ssl3_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, char *parg)\r\n{\r\nCERT *cert;\r\ncert=ctx->cert;\r\nswitch (cmd)\r\n{\r\n#ifndef NO_RSA\r\ncase SSL_CTRL_NEED_TMP_RSA:\r\nif ( (cert->rsa_tmp == NULL) &&\r\n((cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\r\n(EVP_PKEY_size(cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) > (512/8)))\r\n)\r\nreturn(1);\r\nelse\r\nreturn(0);\r\ncase SSL_CTRL_SET_TMP_RSA:\r\n{\r\nRSA *rsa;\r\nint i;\r\nrsa=(RSA *)parg;\r\ni=1;\r\nif (rsa == NULL)\r\ni=0;\r\nelse\r\n{\r\nif ((rsa=RSAPrivateKey_dup(rsa)) == NULL)\r\ni=0;\r\n}\r\nif (!i)\r\n{\r\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_RSA_LIB);\r\nreturn(0);\r\n}\r\nelse\r\n{\r\nif (cert->rsa_tmp != NULL)\r\nRSA_free(cert->rsa_tmp);\r\ncert->rsa_tmp=rsa;\r\nreturn(1);\r\n}\r\n}\r\ncase SSL_CTRL_SET_TMP_RSA_CB:\r\ncert->rsa_tmp_cb=(RSA *(*)(SSL *, int, int))parg;\r\nbreak;\r\n#endif\r\n#ifndef NO_DH\r\ncase SSL_CTRL_SET_TMP_DH:\r\n{\r\nDH *new=NULL,*dh;\r\nint rret=0;\r\ndh=(DH *)parg;\r\nif ( ((new=DHparams_dup(dh)) == NULL) ||\r\n(!DH_generate_key(new)))\r\n{\r\nSSLerr(SSL_F_SSL3_CTX_CTRL,ERR_R_DH_LIB);\r\nif (new != NULL) DH_free(new);\r\n}\r\nelse\r\n{\r\nif (cert->dh_tmp != NULL)\r\nDH_free(cert->dh_tmp);\r\ncert->dh_tmp=new;\r\nrret=1;\r\n}\r\nreturn(rret);\r\n}\r\ncase SSL_CTRL_SET_TMP_DH_CB:\r\ncert->dh_tmp_cb=(DH *(*)(SSL *, int, int))parg;\r\nbreak;\r\n#endif\r\ncase SSL_CTRL_EXTRA_CHAIN_CERT:\r\nif (ctx->extra_certs == NULL)\r\n{\r\nif ((ctx->extra_certs=sk_X509_new_null()) == NULL)\r\nreturn(0);\r\n}\r\nsk_X509_push(ctx->extra_certs,(X509 *)parg);\r\nbreak;\r\ndefault:\r\nreturn(0);\r\n}\r\nreturn(1);\r\n}\r\nSSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p)\r\n{\r\nstatic int init=1;\r\nstatic SSL_CIPHER *sorted[SSL3_NUM_CIPHERS];\r\nSSL_CIPHER c,*cp= &c,**cpp;\r\nunsigned long id;\r\nint i;\r\nif (init)\r\n{\r\nCRYPTO_w_lock(CRYPTO_LOCK_SSL);\r\nfor (i=0; i<SSL3_NUM_CIPHERS; i++)\r\nsorted[i]= &(ssl3_ciphers[i]);\r\nqsort( (char *)sorted,\r\nSSL3_NUM_CIPHERS,sizeof(SSL_CIPHER *),\r\nFP_ICC ssl_cipher_ptr_id_cmp);\r\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL);\r\ninit=0;\r\n}\r\nid=0x03000000L|((unsigned long)p[0]<<8L)|(unsigned long)p[1];\r\nc.id=id;\r\ncpp=(SSL_CIPHER **)OBJ_bsearch((char *)&cp,\r\n(char *)sorted,\r\nSSL3_NUM_CIPHERS,sizeof(SSL_CIPHER *),\r\n(int (*)())ssl_cipher_ptr_id_cmp);\r\nif ((cpp == NULL) || !(*cpp)->valid)\r\nreturn(NULL);\r\nelse\r\nreturn(*cpp);\r\n}\r\nint ssl3_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\r\n{\r\nlong l;\r\nif (p != NULL)\r\n{\r\nl=c->id;\r\nif ((l & 0xff000000) != 0x03000000) return(0);\r\np[0]=((unsigned char)(l>> 8L))&0xFF;\r\np[1]=((unsigned char)(l ))&0xFF;\r\n}\r\nreturn(2);\r\n}\r\nint ssl3_part_read(SSL *s, int i)\r\n{\r\ns->rwstate=SSL_READING;\r\nif (i < 0)\r\n{\r\nreturn(i);\r\n}\r\nelse\r\n{\r\ns->init_num+=i;\r\nreturn(0);\r\n}\r\n}\r\nint ssl3_get_req_cert_type(SSL *s, unsigned char *p)\r\n{\r\nint ret=0;\r\nunsigned long alg;\r\nalg=s->s3->tmp.new_cipher->algorithms;\r\n#ifndef NO_DH\r\nif (alg & (SSL_kDHr|SSL_kEDH))\r\n{\r\n# ifndef NO_RSA\r\np[ret++]=SSL3_CT_RSA_FIXED_DH;\r\n# endif\r\n# ifndef NO_DSA\r\np[ret++]=SSL3_CT_DSS_FIXED_DH;\r\n# endif\r\n}\r\nif ((s->version == SSL3_VERSION) &&\r\n(alg & (SSL_kEDH|SSL_kDHd|SSL_kDHr)))\r\n{\r\n# ifndef NO_RSA\r\np[ret++]=SSL3_CT_RSA_EPHEMERAL_DH;\r\n# endif\r\n# ifndef NO_DSA\r\np[ret++]=SSL3_CT_DSS_EPHEMERAL_DH;\r\n# endif\r\n}\r\n#endif\r\n#ifndef NO_RSA\r\np[ret++]=SSL3_CT_RSA_SIGN;\r\n#endif\r\n#ifndef NO_DSA\r\np[ret++]=SSL3_CT_DSS_SIGN;\r\n#endif\r\nreturn(ret);\r\n}\r\nint ssl3_shutdown(SSL *s)\r\n{\r\nif ((s->quiet_shutdown) || (s->state == SSL_ST_BEFORE))\r\n{\r\ns->shutdown=(SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);\r\nreturn(1);\r\n}\r\nif (!(s->shutdown & SSL_SENT_SHUTDOWN))\r\n{\r\ns->shutdown|=SSL_SENT_SHUTDOWN;\r\n#if 1\r\nssl3_send_alert(s,SSL3_AL_WARNING,SSL_AD_CLOSE_NOTIFY);\r\n#endif\r\n}\r\nelse if (s->s3->alert_dispatch)\r\n{\r\n#if 1\r\nssl3_dispatch_alert(s);\r\n#endif\r\n}\r\nelse if (!(s->shutdown & SSL_RECEIVED_SHUTDOWN))\r\n{\r\nssl3_read_bytes(s,0,NULL,0);\r\n}\r\nif ((s->shutdown == (SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN)) &&\r\n!s->s3->alert_dispatch)\r\nreturn(1);\r\nelse\r\nreturn(0);\r\n}\r\nint ssl3_write(SSL *s, const void *buf, int len)\r\n{\r\nint ret,n;\r\n#if 0\r\nif (s->shutdown & SSL_SEND_SHUTDOWN)\r\n{\r\ns->rwstate=SSL_NOTHING;\r\nreturn(0);\r\n}\r\n#endif\r\nclear_sys_error();\r\nif (s->s3->renegotiate) ssl3_renegotiate_check(s);\r\nif ((s->s3->flags & SSL3_FLAGS_POP_BUFFER) && (s->wbio == s->bbio))\r\n{\r\nif (s->s3->delay_buf_pop_ret == 0)\r\n{\r\nret=ssl3_write_bytes(s,SSL3_RT_APPLICATION_DATA,\r\nbuf,len);\r\nif (ret <= 0) return(ret);\r\ns->s3->delay_buf_pop_ret=ret;\r\n}\r\ns->rwstate=SSL_WRITING;\r\nn=BIO_flush(s->wbio);\r\nif (n <= 0) return(n);\r\ns->rwstate=SSL_NOTHING;\r\nssl_free_wbio_buffer(s);\r\ns->s3->flags&= ~SSL3_FLAGS_POP_BUFFER;\r\nret=s->s3->delay_buf_pop_ret;\r\ns->s3->delay_buf_pop_ret=0;\r\n}\r\nelse\r\n{\r\nret=ssl3_write_bytes(s,SSL3_RT_APPLICATION_DATA,\r\nbuf,len);\r\nif (ret <= 0) return(ret);\r\n}\r\nreturn(ret);\r\n}\r\nint ssl3_read(SSL *s, void *buf, int len)\r\n{\r\nint ret;\r\nclear_sys_error();\r\nif (s->s3->renegotiate) ssl3_renegotiate_check(s);\r\ns->s3->in_read_app_data=1;\r\nret=ssl3_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len);\r\nif ((ret == -1) && (s->s3->in_read_app_data == 0))\r\n{\r\nERR_get_error();\r\ns->s3->in_read_app_data=0;\r\ns->in_handshake++;\r\nret=ssl3_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len);\r\ns->in_handshake--;\r\n}\r\nelse\r\ns->s3->in_read_app_data=0;\r\nreturn(ret);\r\n}\r\nint ssl3_peek(SSL *s, char *buf, int len)\r\n{\r\nSSL3_RECORD *rr;\r\nint n;\r\nrr= &(s->s3->rrec);\r\nif ((rr->length == 0) || (rr->type != SSL3_RT_APPLICATION_DATA))\r\n{\r\nn=ssl3_read(s,buf,1);\r\nif (n <= 0) return(n);\r\nrr->length++;\r\nrr->off--;\r\n}\r\nif ((unsigned int)len > rr->length)\r\nn=rr->length;\r\nelse\r\nn=len;\r\nmemcpy(buf,&(rr->data[rr->off]),(unsigned int)n);\r\nreturn(n);\r\n}\r\nint ssl3_renegotiate(SSL *s)\r\n{\r\nif (s->handshake_func == NULL)\r\nreturn(1);\r\nif (s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)\r\nreturn(0);\r\ns->s3->renegotiate=1;\r\nreturn(1);\r\n}\r\nint ssl3_renegotiate_check(SSL *s)\r\n{\r\nint ret=0;\r\nif (s->s3->renegotiate)\r\n{\r\nif ( (s->s3->rbuf.left == 0) &&\r\n(s->s3->wbuf.left == 0) &&\r\n!SSL_in_init(s))\r\n{\r\ns->state=SSL_ST_RENEGOTIATE;\r\ns->s3->renegotiate=0;\r\ns->s3->num_renegotiations++;\r\ns->s3->total_renegotiations++;\r\nret=1;\r\n}\r\n}\r\nreturn(ret);\r\n}
