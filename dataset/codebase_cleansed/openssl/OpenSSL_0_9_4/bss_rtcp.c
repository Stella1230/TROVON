BIO_METHOD *BIO_s_rtcp(void)\r\n{\r\nreturn(&rtcp_method);\r\n}\r\nstatic int get ( io_channel chan, char *buffer, int maxlen, int *length )\r\n{\r\nint status;\r\nstruct io_status iosb;\r\nstatus = sys$qiow ( 0, chan, IO$_READVBLK, &iosb, 0, 0,\r\nbuffer, maxlen, 0, 0, 0, 0 );\r\nif ( (status&1) == 1 ) status = iosb.status;\r\nif ( (status&1) == 1 ) *length = iosb.count;\r\nreturn status;\r\n}\r\nstatic int put ( io_channel chan, char *buffer, int length )\r\n{\r\nint status;\r\nstruct io_status iosb;\r\nstatus = sys$qiow ( 0, chan, IO$_WRITEVBLK, &iosb, 0, 0,\r\nbuffer, length, 0, 0, 0, 0 );\r\nif ( (status&1) == 1 ) status = iosb.status;\r\nreturn status;\r\n}\r\nstatic int rtcp_new(BIO *bi)\r\n{\r\nstruct rpc_ctx *ctx;\r\nbi->init=1;\r\nbi->num=0;\r\nbi->flags = 0;\r\nbi->ptr=Malloc(sizeof(struct rpc_ctx));\r\nctx = (struct rpc_ctx *) bi->ptr;\r\nctx->filled = 0;\r\nctx->pos = 0;\r\nreturn(1);\r\n}\r\nstatic int rtcp_free(BIO *a)\r\n{\r\nif (a == NULL) return(0);\r\nif ( a->ptr ) Free ( a->ptr );\r\na->ptr = NULL;\r\nreturn(1);\r\n}\r\nstatic int rtcp_read(BIO *b, char *out, int outl)\r\n{\r\nint status, length;\r\nstruct rpc_ctx *ctx;\r\nctx = (struct rpc_ctx *) b->ptr;\r\nif ( ctx->pos < ctx->filled ) {\r\nlength = ctx->filled - ctx->pos;\r\nif ( length > outl ) length = outl;\r\nmemmove ( out, &ctx->msg.data[ctx->pos], length );\r\nctx->pos += length;\r\nreturn length;\r\n}\r\nctx->msg.channel = 'R';\r\nctx->msg.function = 'G';\r\nctx->msg.length = sizeof(ctx->msg.data);\r\nstatus = put ( b->num, (char *) &ctx->msg, RPC_HDR_SIZE );\r\nif ( (status&1) == 0 ) {\r\nreturn -1;\r\n}\r\nctx->pos = ctx->filled = 0;\r\nstatus = get ( b->num, (char *) &ctx->msg, sizeof(ctx->msg), &length );\r\nif ( (status&1) == 0 ) length = -1;\r\nif ( ctx->msg.channel != 'R' || ctx->msg.function != 'C' ) {\r\nlength = -1;\r\n}\r\nctx->filled = length - RPC_HDR_SIZE;\r\nif ( ctx->pos < ctx->filled ) {\r\nlength = ctx->filled - ctx->pos;\r\nif ( length > outl ) length = outl;\r\nmemmove ( out, ctx->msg.data, length );\r\nctx->pos += length;\r\nreturn length;\r\n}\r\nreturn length;\r\n}\r\nstatic int rtcp_write(BIO *b, char *in, int inl)\r\n{\r\nint status, i, segment, length;\r\nstruct rpc_ctx *ctx;\r\nctx = (struct rpc_ctx *) b->ptr;\r\nfor ( i = 0; i < inl; i += segment ) {\r\nsegment = inl - i;\r\nif ( segment > sizeof(ctx->msg.data) ) segment = sizeof(ctx->msg.data);\r\nctx->msg.channel = 'R';\r\nctx->msg.function = 'P';\r\nctx->msg.length = segment;\r\nmemmove ( ctx->msg.data, &in[i], segment );\r\nstatus = put ( b->num, (char *) &ctx->msg, segment + RPC_HDR_SIZE );\r\nif ((status&1) == 0 ) { i = -1; break; }\r\nstatus = get ( b->num, (char *) &ctx->msg, sizeof(ctx->msg), &length );\r\nif ( ((status&1) == 0) || (length < RPC_HDR_SIZE) ) { i = -1; break; }\r\nif ( (ctx->msg.channel != 'R') || (ctx->msg.function != 'C') ) {\r\nprintf("unexpected response when confirming put %c %c\n",\r\nctx->msg.channel, ctx->msg.function );\r\n}\r\n}\r\nreturn(i);\r\n}\r\nstatic long rtcp_ctrl(BIO *b, int cmd, long num, char *ptr)\r\n{\r\nlong ret=1;\r\nswitch (cmd)\r\n{\r\ncase BIO_CTRL_RESET:\r\ncase BIO_CTRL_EOF:\r\nret = 1;\r\nbreak;\r\ncase BIO_C_SET_FD:\r\nb->num = num;\r\nret = 1;\r\nbreak;\r\ncase BIO_CTRL_SET_CLOSE:\r\ncase BIO_CTRL_FLUSH:\r\ncase BIO_CTRL_DUP:\r\nret=1;\r\nbreak;\r\ncase BIO_CTRL_GET_CLOSE:\r\ncase BIO_CTRL_INFO:\r\ncase BIO_CTRL_GET:\r\ncase BIO_CTRL_PENDING:\r\ncase BIO_CTRL_WPENDING:\r\ndefault:\r\nret=0;\r\nbreak;\r\n}\r\nreturn(ret);\r\n}\r\nstatic int rtcp_gets(BIO *bp, char *buf, int size)\r\n{\r\nreturn(0);\r\n}\r\nstatic int rtcp_puts(BIO *bp, char *str)\r\n{\r\nint length;\r\nif (str == NULL) return(0);\r\nlength = strlen ( str );\r\nif ( length == 0 ) return (0);\r\nreturn rtcp_write ( bp,str, length );\r\n}
