int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,\r\nunsigned char *from, int flen, unsigned char *param, int plen)\r\n{\r\nint i, emlen = tlen - 1;\r\nunsigned char *db, *seed;\r\nunsigned char *dbmask, seedmask[SHA_DIGEST_LENGTH];\r\nif (flen > emlen - 2 * SHA_DIGEST_LENGTH - 1)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP,\r\nRSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\r\nreturn (0);\r\n}\r\nif (emlen < 2 * SHA_DIGEST_LENGTH + 1)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_KEY_SIZE_TOO_SMALL);\r\nreturn (0);\r\n}\r\ndbmask = Malloc(emlen - SHA_DIGEST_LENGTH);\r\nif (dbmask == NULL)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);\r\nreturn (0);\r\n}\r\nto[0] = 0;\r\nseed = to + 1;\r\ndb = to + SHA_DIGEST_LENGTH + 1;\r\nSHA1(param, plen, db);\r\nmemset(db + SHA_DIGEST_LENGTH, 0,\r\nemlen - flen - 2 * SHA_DIGEST_LENGTH - 1);\r\ndb[emlen - flen - SHA_DIGEST_LENGTH - 1] = 0x01;\r\nmemcpy(db + emlen - flen - SHA_DIGEST_LENGTH, from, (unsigned int) flen);\r\nRAND_bytes(seed, SHA_DIGEST_LENGTH);\r\n#ifdef PKCS_TESTVECT\r\nmemcpy(seed,\r\n"\xaa\xfd\x12\xf6\x59\xca\xe6\x34\x89\xb4\x79\xe5\x07\x6d\xde\xc2\xf0\x6c\xb5\x8f",\r\n20);\r\n#endif\r\nMGF1(dbmask, emlen - SHA_DIGEST_LENGTH, seed, SHA_DIGEST_LENGTH);\r\nfor (i = 0; i < emlen - SHA_DIGEST_LENGTH; i++)\r\ndb[i] ^= dbmask[i];\r\nMGF1(seedmask, SHA_DIGEST_LENGTH, db, emlen - SHA_DIGEST_LENGTH);\r\nfor (i = 0; i < SHA_DIGEST_LENGTH; i++)\r\nseed[i] ^= seedmask[i];\r\nFree(dbmask);\r\nreturn (1);\r\n}\r\nint RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,\r\nunsigned char *from, int flen, int num, unsigned char *param,\r\nint plen)\r\n{\r\nint i, dblen, mlen = -1;\r\nunsigned char *maskeddb;\r\nint lzero;\r\nunsigned char *db, seed[SHA_DIGEST_LENGTH], phash[SHA_DIGEST_LENGTH];\r\nif (--num < 2 * SHA_DIGEST_LENGTH + 1)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);\r\nreturn (-1);\r\n}\r\ndblen = num - SHA_DIGEST_LENGTH;\r\ndb = Malloc(dblen);\r\nif (db == NULL)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, ERR_R_MALLOC_FAILURE);\r\nreturn (-1);\r\n}\r\nlzero = num - flen;\r\nmaskeddb = from - lzero + SHA_DIGEST_LENGTH;\r\nMGF1(seed, SHA_DIGEST_LENGTH, maskeddb, dblen);\r\nfor (i = lzero; i < SHA_DIGEST_LENGTH; i++)\r\nseed[i] ^= from[i - lzero];\r\nMGF1(db, dblen, seed, SHA_DIGEST_LENGTH);\r\nfor (i = 0; i < dblen; i++)\r\ndb[i] ^= maskeddb[i];\r\nSHA1(param, plen, phash);\r\nif (memcmp(db, phash, SHA_DIGEST_LENGTH) != 0)\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP, RSA_R_OAEP_DECODING_ERROR);\r\nelse\r\n{\r\nfor (i = SHA_DIGEST_LENGTH; i < dblen; i++)\r\nif (db[i] != 0x00)\r\nbreak;\r\nif (db[i] != 0x01 || i++ >= dblen)\r\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP,\r\nRSA_R_OAEP_DECODING_ERROR);\r\nelse\r\n{\r\nmlen = dblen - i;\r\nif (tlen < mlen)\r\n{\r\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP, RSA_R_DATA_TOO_LARGE);\r\nmlen = -1;\r\n}\r\nelse\r\nmemcpy(to, db + i, mlen);\r\n}\r\n}\r\nFree(db);\r\nreturn (mlen);\r\n}\r\nint MGF1(unsigned char *mask, long len, unsigned char *seed, long seedlen)\r\n{\r\nlong i, outlen = 0;\r\nunsigned char cnt[4];\r\nSHA_CTX c;\r\nunsigned char md[SHA_DIGEST_LENGTH];\r\nfor (i = 0; outlen < len; i++)\r\n{\r\ncnt[0] = (i >> 24) & 255, cnt[1] = (i >> 16) & 255,\r\ncnt[2] = (i >> 8) & 255, cnt[3] = i & 255;\r\nSHA1_Init(&c);\r\nSHA1_Update(&c, seed, seedlen);\r\nSHA1_Update(&c, cnt, 4);\r\nif (outlen + SHA_DIGEST_LENGTH <= len)\r\n{\r\nSHA1_Final(mask + outlen, &c);\r\noutlen += SHA_DIGEST_LENGTH;\r\n}\r\nelse\r\n{\r\nSHA1_Final(md, &c);\r\nmemcpy(mask + outlen, md, len - outlen);\r\noutlen = len;\r\n}\r\n}\r\nreturn (0);\r\n}
