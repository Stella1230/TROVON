void EVP_set_pw_prompt(char *prompt)\r\n{\r\nif (prompt == NULL)\r\nprompt_string[0]='\0';\r\nelse\r\nstrncpy(prompt_string,prompt,79);\r\n}\r\nchar *EVP_get_pw_prompt(void)\r\n{\r\nif (prompt_string[0] == '\0')\r\nreturn(NULL);\r\nelse\r\nreturn(prompt_string);\r\n}\r\nint EVP_read_pw_string(char *buf, int len, const char *prompt, int verify)\r\n{\r\nif ((prompt == NULL) && (prompt_string[0] != '\0'))\r\nprompt=prompt_string;\r\nreturn(des_read_pw_string(buf,len,prompt,verify));\r\n}\r\nint EVP_BytesToKey(const EVP_CIPHER *type, EVP_MD *md, unsigned char *salt,\r\nunsigned char *data, int datal, int count, unsigned char *key,\r\nunsigned char *iv)\r\n{\r\nEVP_MD_CTX c;\r\nunsigned char md_buf[EVP_MAX_MD_SIZE];\r\nint niv,nkey,addmd=0;\r\nunsigned int mds=0,i;\r\nnkey=type->key_len;\r\nniv=type->iv_len;\r\nif (data == NULL) return(nkey);\r\nfor (;;)\r\n{\r\nEVP_DigestInit(&c,md);\r\nif (addmd++)\r\nEVP_DigestUpdate(&c,&(md_buf[0]),mds);\r\nEVP_DigestUpdate(&c,data,datal);\r\nif (salt != NULL)\r\nEVP_DigestUpdate(&c,salt,8);\r\nEVP_DigestFinal(&c,&(md_buf[0]),&mds);\r\nfor (i=1; i<(unsigned int)count; i++)\r\n{\r\nEVP_DigestInit(&c,md);\r\nEVP_DigestUpdate(&c,&(md_buf[0]),mds);\r\nEVP_DigestFinal(&c,&(md_buf[0]),&mds);\r\n}\r\ni=0;\r\nif (nkey)\r\n{\r\nfor (;;)\r\n{\r\nif (nkey == 0) break;\r\nif (i == mds) break;\r\nif (key != NULL)\r\n*(key++)=md_buf[i];\r\nnkey--;\r\ni++;\r\n}\r\n}\r\nif (niv && (i != mds))\r\n{\r\nfor (;;)\r\n{\r\nif (niv == 0) break;\r\nif (i == mds) break;\r\nif (iv != NULL)\r\n*(iv++)=md_buf[i];\r\nniv--;\r\ni++;\r\n}\r\n}\r\nif ((nkey == 0) && (niv == 0)) break;\r\n}\r\nmemset(&c,0,sizeof(c));\r\nmemset(&(md_buf[0]),0,EVP_MAX_MD_SIZE);\r\nreturn(type->key_len);\r\n}
