ASN1_STRING *d2i_ASN1_type_bytes(ASN1_STRING **a, unsigned char **pp,\r\nlong length, int type)\r\n{\r\nASN1_STRING *ret=NULL;\r\nunsigned char *p,*s;\r\nlong len;\r\nint inf,tag,xclass;\r\nint i=0;\r\np= *pp;\r\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\r\nif (inf & 0x80) goto err;\r\nif (tag >= 32)\r\n{\r\ni=ASN1_R_TAG_VALUE_TOO_HIGH;;\r\ngoto err;\r\n}\r\nif (!(tag2bit[tag] & type))\r\n{\r\ni=ASN1_R_WRONG_TYPE;\r\ngoto err;\r\n}\r\nif (tag == V_ASN1_BIT_STRING)\r\nreturn(d2i_ASN1_BIT_STRING(a,pp,length));\r\nif ((a == NULL) || ((*a) == NULL))\r\n{\r\nif ((ret=ASN1_STRING_new()) == NULL) return(NULL);\r\n}\r\nelse\r\nret=(*a);\r\nif (len != 0)\r\n{\r\ns=(unsigned char *)Malloc((int)len+1);\r\nif (s == NULL)\r\n{\r\ni=ERR_R_MALLOC_FAILURE;\r\ngoto err;\r\n}\r\nmemcpy(s,p,(int)len);\r\ns[len]='\0';\r\np+=len;\r\n}\r\nelse\r\ns=NULL;\r\nif (ret->data != NULL) Free((char *)ret->data);\r\nret->length=(int)len;\r\nret->data=s;\r\nret->type=tag;\r\nif (a != NULL) (*a)=ret;\r\n*pp=p;\r\nreturn(ret);\r\nerr:\r\nASN1err(ASN1_F_D2I_ASN1_TYPE_BYTES,i);\r\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\r\nASN1_STRING_free(ret);\r\nreturn(NULL);\r\n}\r\nint i2d_ASN1_bytes(ASN1_STRING *a, unsigned char **pp, int tag, int xclass)\r\n{\r\nint ret,r,constructed;\r\nunsigned char *p;\r\nif (a == NULL) return(0);\r\nif (tag == V_ASN1_BIT_STRING)\r\nreturn(i2d_ASN1_BIT_STRING(a,pp));\r\nret=a->length;\r\nr=ASN1_object_size(0,ret,tag);\r\nif (pp == NULL) return(r);\r\np= *pp;\r\nif ((tag == V_ASN1_SEQUENCE) || (tag == V_ASN1_SET))\r\nconstructed=1;\r\nelse\r\nconstructed=0;\r\nASN1_put_object(&p,constructed,ret,tag,xclass);\r\nmemcpy(p,a->data,a->length);\r\np+=a->length;\r\n*pp= p;\r\nreturn(r);\r\n}\r\nASN1_STRING *d2i_ASN1_bytes(ASN1_STRING **a, unsigned char **pp, long length,\r\nint Ptag, int Pclass)\r\n{\r\nASN1_STRING *ret=NULL;\r\nunsigned char *p,*s;\r\nlong len;\r\nint inf,tag,xclass;\r\nint i=0;\r\nif ((a == NULL) || ((*a) == NULL))\r\n{\r\nif ((ret=ASN1_STRING_new()) == NULL) return(NULL);\r\n}\r\nelse\r\nret=(*a);\r\np= *pp;\r\ninf=ASN1_get_object(&p,&len,&tag,&xclass,length);\r\nif (inf & 0x80)\r\n{\r\ni=ASN1_R_BAD_OBJECT_HEADER;\r\ngoto err;\r\n}\r\nif (tag != Ptag)\r\n{\r\ni=ASN1_R_WRONG_TAG;\r\ngoto err;\r\n}\r\nif (inf & V_ASN1_CONSTRUCTED)\r\n{\r\nASN1_CTX c;\r\nc.pp=pp;\r\nc.p=p;\r\nc.inf=inf;\r\nc.slen=len;\r\nc.tag=Ptag;\r\nc.xclass=Pclass;\r\nc.max=(length == 0)?0:(p+length);\r\nif (!asn1_collate_primative(ret,&c))\r\ngoto err;\r\nelse\r\n{\r\np=c.p;\r\n}\r\n}\r\nelse\r\n{\r\nif (len != 0)\r\n{\r\nif ((ret->length < len) || (ret->data == NULL))\r\n{\r\nif (ret->data != NULL) Free((char *)ret->data);\r\ns=(unsigned char *)Malloc((int)len);\r\nif (s == NULL)\r\n{\r\ni=ERR_R_MALLOC_FAILURE;\r\ngoto err;\r\n}\r\n}\r\nelse\r\ns=ret->data;\r\nmemcpy(s,p,(int)len);\r\np+=len;\r\n}\r\nelse\r\n{\r\ns=NULL;\r\nif (ret->data != NULL) Free((char *)ret->data);\r\n}\r\nret->length=(int)len;\r\nret->data=s;\r\nret->type=Ptag;\r\n}\r\nif (a != NULL) (*a)=ret;\r\n*pp=p;\r\nreturn(ret);\r\nerr:\r\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\r\nASN1_STRING_free(ret);\r\nASN1err(ASN1_F_D2I_ASN1_BYTES,i);\r\nreturn(NULL);\r\n}\r\nstatic int asn1_collate_primative(ASN1_STRING *a, ASN1_CTX *c)\r\n{\r\nASN1_STRING *os=NULL;\r\nBUF_MEM b;\r\nint num;\r\nb.length=0;\r\nb.max=0;\r\nb.data=NULL;\r\nif (a == NULL)\r\n{\r\nc->error=ERR_R_PASSED_NULL_PARAMETER;\r\ngoto err;\r\n}\r\nnum=0;\r\nfor (;;)\r\n{\r\nif (c->inf & 1)\r\n{\r\nc->eos=ASN1_check_infinite_end(&c->p,\r\n(long)(c->max-c->p));\r\nif (c->eos) break;\r\n}\r\nelse\r\n{\r\nif (c->slen <= 0) break;\r\n}\r\nc->q=c->p;\r\nif (d2i_ASN1_bytes(&os,&c->p,c->max-c->p,c->tag,c->xclass)\r\n== NULL)\r\n{\r\nc->error=ERR_R_ASN1_LIB;\r\ngoto err;\r\n}\r\nif (!BUF_MEM_grow(&b,num+os->length))\r\n{\r\nc->error=ERR_R_BUF_LIB;\r\ngoto err;\r\n}\r\nmemcpy(&(b.data[num]),os->data,os->length);\r\nif (!(c->inf & 1))\r\nc->slen-=(c->p-c->q);\r\nnum+=os->length;\r\n}\r\nif (!asn1_Finish(c)) goto err;\r\na->length=num;\r\nif (a->data != NULL) Free(a->data);\r\na->data=(unsigned char *)b.data;\r\nif (os != NULL) ASN1_STRING_free(os);\r\nreturn(1);\r\nerr:\r\nASN1err(ASN1_F_ASN1_COLLATE_PRIMITIVE,c->error);\r\nif (os != NULL) ASN1_STRING_free(os);\r\nif (b.data != NULL) Free(b.data);\r\nreturn(0);\r\n}
