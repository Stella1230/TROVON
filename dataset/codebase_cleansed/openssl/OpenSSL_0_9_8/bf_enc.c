void BF_encrypt(BF_LONG *data, const BF_KEY *key)\r\n{\r\n#ifndef BF_PTR2\r\nregister BF_LONG l,r;\r\nconst register BF_LONG *p,*s;\r\np=key->P;\r\ns= &(key->S[0]);\r\nl=data[0];\r\nr=data[1];\r\nl^=p[0];\r\nBF_ENC(r,l,s,p[ 1]);\r\nBF_ENC(l,r,s,p[ 2]);\r\nBF_ENC(r,l,s,p[ 3]);\r\nBF_ENC(l,r,s,p[ 4]);\r\nBF_ENC(r,l,s,p[ 5]);\r\nBF_ENC(l,r,s,p[ 6]);\r\nBF_ENC(r,l,s,p[ 7]);\r\nBF_ENC(l,r,s,p[ 8]);\r\nBF_ENC(r,l,s,p[ 9]);\r\nBF_ENC(l,r,s,p[10]);\r\nBF_ENC(r,l,s,p[11]);\r\nBF_ENC(l,r,s,p[12]);\r\nBF_ENC(r,l,s,p[13]);\r\nBF_ENC(l,r,s,p[14]);\r\nBF_ENC(r,l,s,p[15]);\r\nBF_ENC(l,r,s,p[16]);\r\n#if BF_ROUNDS == 20\r\nBF_ENC(r,l,s,p[17]);\r\nBF_ENC(l,r,s,p[18]);\r\nBF_ENC(r,l,s,p[19]);\r\nBF_ENC(l,r,s,p[20]);\r\n#endif\r\nr^=p[BF_ROUNDS+1];\r\ndata[1]=l&0xffffffffL;\r\ndata[0]=r&0xffffffffL;\r\n#else\r\nregister BF_LONG l,r,t,*k;\r\nl=data[0];\r\nr=data[1];\r\nk=(BF_LONG*)key;\r\nl^=k[0];\r\nBF_ENC(r,l,k, 1);\r\nBF_ENC(l,r,k, 2);\r\nBF_ENC(r,l,k, 3);\r\nBF_ENC(l,r,k, 4);\r\nBF_ENC(r,l,k, 5);\r\nBF_ENC(l,r,k, 6);\r\nBF_ENC(r,l,k, 7);\r\nBF_ENC(l,r,k, 8);\r\nBF_ENC(r,l,k, 9);\r\nBF_ENC(l,r,k,10);\r\nBF_ENC(r,l,k,11);\r\nBF_ENC(l,r,k,12);\r\nBF_ENC(r,l,k,13);\r\nBF_ENC(l,r,k,14);\r\nBF_ENC(r,l,k,15);\r\nBF_ENC(l,r,k,16);\r\n#if BF_ROUNDS == 20\r\nBF_ENC(r,l,k,17);\r\nBF_ENC(l,r,k,18);\r\nBF_ENC(r,l,k,19);\r\nBF_ENC(l,r,k,20);\r\n#endif\r\nr^=k[BF_ROUNDS+1];\r\ndata[1]=l&0xffffffffL;\r\ndata[0]=r&0xffffffffL;\r\n#endif\r\n}\r\nvoid BF_decrypt(BF_LONG *data, const BF_KEY *key)\r\n{\r\n#ifndef BF_PTR2\r\nregister BF_LONG l,r;\r\nconst register BF_LONG *p,*s;\r\np=key->P;\r\ns= &(key->S[0]);\r\nl=data[0];\r\nr=data[1];\r\nl^=p[BF_ROUNDS+1];\r\n#if BF_ROUNDS == 20\r\nBF_ENC(r,l,s,p[20]);\r\nBF_ENC(l,r,s,p[19]);\r\nBF_ENC(r,l,s,p[18]);\r\nBF_ENC(l,r,s,p[17]);\r\n#endif\r\nBF_ENC(r,l,s,p[16]);\r\nBF_ENC(l,r,s,p[15]);\r\nBF_ENC(r,l,s,p[14]);\r\nBF_ENC(l,r,s,p[13]);\r\nBF_ENC(r,l,s,p[12]);\r\nBF_ENC(l,r,s,p[11]);\r\nBF_ENC(r,l,s,p[10]);\r\nBF_ENC(l,r,s,p[ 9]);\r\nBF_ENC(r,l,s,p[ 8]);\r\nBF_ENC(l,r,s,p[ 7]);\r\nBF_ENC(r,l,s,p[ 6]);\r\nBF_ENC(l,r,s,p[ 5]);\r\nBF_ENC(r,l,s,p[ 4]);\r\nBF_ENC(l,r,s,p[ 3]);\r\nBF_ENC(r,l,s,p[ 2]);\r\nBF_ENC(l,r,s,p[ 1]);\r\nr^=p[0];\r\ndata[1]=l&0xffffffffL;\r\ndata[0]=r&0xffffffffL;\r\n#else\r\nregister BF_LONG l,r,t,*k;\r\nl=data[0];\r\nr=data[1];\r\nk=(BF_LONG *)key;\r\nl^=k[BF_ROUNDS+1];\r\n#if BF_ROUNDS == 20\r\nBF_ENC(r,l,k,20);\r\nBF_ENC(l,r,k,19);\r\nBF_ENC(r,l,k,18);\r\nBF_ENC(l,r,k,17);\r\n#endif\r\nBF_ENC(r,l,k,16);\r\nBF_ENC(l,r,k,15);\r\nBF_ENC(r,l,k,14);\r\nBF_ENC(l,r,k,13);\r\nBF_ENC(r,l,k,12);\r\nBF_ENC(l,r,k,11);\r\nBF_ENC(r,l,k,10);\r\nBF_ENC(l,r,k, 9);\r\nBF_ENC(r,l,k, 8);\r\nBF_ENC(l,r,k, 7);\r\nBF_ENC(r,l,k, 6);\r\nBF_ENC(l,r,k, 5);\r\nBF_ENC(r,l,k, 4);\r\nBF_ENC(l,r,k, 3);\r\nBF_ENC(r,l,k, 2);\r\nBF_ENC(l,r,k, 1);\r\nr^=k[0];\r\ndata[1]=l&0xffffffffL;\r\ndata[0]=r&0xffffffffL;\r\n#endif\r\n}\r\nvoid BF_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\r\nconst BF_KEY *schedule, unsigned char *ivec, int encrypt)\r\n{\r\nregister BF_LONG tin0,tin1;\r\nregister BF_LONG tout0,tout1,xor0,xor1;\r\nregister long l=length;\r\nBF_LONG tin[2];\r\nif (encrypt)\r\n{\r\nn2l(ivec,tout0);\r\nn2l(ivec,tout1);\r\nivec-=8;\r\nfor (l-=8; l>=0; l-=8)\r\n{\r\nn2l(in,tin0);\r\nn2l(in,tin1);\r\ntin0^=tout0;\r\ntin1^=tout1;\r\ntin[0]=tin0;\r\ntin[1]=tin1;\r\nBF_encrypt(tin,schedule);\r\ntout0=tin[0];\r\ntout1=tin[1];\r\nl2n(tout0,out);\r\nl2n(tout1,out);\r\n}\r\nif (l != -8)\r\n{\r\nn2ln(in,tin0,tin1,l+8);\r\ntin0^=tout0;\r\ntin1^=tout1;\r\ntin[0]=tin0;\r\ntin[1]=tin1;\r\nBF_encrypt(tin,schedule);\r\ntout0=tin[0];\r\ntout1=tin[1];\r\nl2n(tout0,out);\r\nl2n(tout1,out);\r\n}\r\nl2n(tout0,ivec);\r\nl2n(tout1,ivec);\r\n}\r\nelse\r\n{\r\nn2l(ivec,xor0);\r\nn2l(ivec,xor1);\r\nivec-=8;\r\nfor (l-=8; l>=0; l-=8)\r\n{\r\nn2l(in,tin0);\r\nn2l(in,tin1);\r\ntin[0]=tin0;\r\ntin[1]=tin1;\r\nBF_decrypt(tin,schedule);\r\ntout0=tin[0]^xor0;\r\ntout1=tin[1]^xor1;\r\nl2n(tout0,out);\r\nl2n(tout1,out);\r\nxor0=tin0;\r\nxor1=tin1;\r\n}\r\nif (l != -8)\r\n{\r\nn2l(in,tin0);\r\nn2l(in,tin1);\r\ntin[0]=tin0;\r\ntin[1]=tin1;\r\nBF_decrypt(tin,schedule);\r\ntout0=tin[0]^xor0;\r\ntout1=tin[1]^xor1;\r\nl2nn(tout0,tout1,out,l+8);\r\nxor0=tin0;\r\nxor1=tin1;\r\n}\r\nl2n(xor0,ivec);\r\nl2n(xor1,ivec);\r\n}\r\ntin0=tin1=tout0=tout1=xor0=xor1=0;\r\ntin[0]=tin[1]=0;\r\n}
