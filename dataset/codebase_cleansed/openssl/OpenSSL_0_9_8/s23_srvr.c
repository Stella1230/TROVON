static SSL_METHOD *ssl23_get_server_method(int ver)\r\n{\r\n#ifndef OPENSSL_NO_SSL2\r\nif (ver == SSL2_VERSION)\r\nreturn(SSLv2_server_method());\r\n#endif\r\nif (ver == SSL3_VERSION)\r\nreturn(SSLv3_server_method());\r\nelse if (ver == TLS1_VERSION)\r\nreturn(TLSv1_server_method());\r\nelse\r\nreturn(NULL);\r\n}\r\nSSL_METHOD *SSLv23_server_method(void)\r\n{\r\nstatic int init=1;\r\nstatic SSL_METHOD SSLv23_server_data;\r\nif (init)\r\n{\r\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_METHOD);\r\nif (init)\r\n{\r\nmemcpy((char *)&SSLv23_server_data,\r\n(char *)sslv23_base_method(),sizeof(SSL_METHOD));\r\nSSLv23_server_data.ssl_accept=ssl23_accept;\r\nSSLv23_server_data.get_ssl_method=ssl23_get_server_method;\r\ninit=0;\r\n}\r\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_METHOD);\r\n}\r\nreturn(&SSLv23_server_data);\r\n}\r\nint ssl23_accept(SSL *s)\r\n{\r\nBUF_MEM *buf;\r\nunsigned long Time=time(NULL);\r\nvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\r\nint ret= -1;\r\nint new_state,state;\r\nRAND_add(&Time,sizeof(Time),0);\r\nERR_clear_error();\r\nclear_sys_error();\r\nif (s->info_callback != NULL)\r\ncb=s->info_callback;\r\nelse if (s->ctx->info_callback != NULL)\r\ncb=s->ctx->info_callback;\r\ns->in_handshake++;\r\nif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\r\nfor (;;)\r\n{\r\nstate=s->state;\r\nswitch(s->state)\r\n{\r\ncase SSL_ST_BEFORE:\r\ncase SSL_ST_ACCEPT:\r\ncase SSL_ST_BEFORE|SSL_ST_ACCEPT:\r\ncase SSL_ST_OK|SSL_ST_ACCEPT:\r\ns->server=1;\r\nif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\r\ns->type=SSL_ST_ACCEPT;\r\nif (s->init_buf == NULL)\r\n{\r\nif ((buf=BUF_MEM_new()) == NULL)\r\n{\r\nret= -1;\r\ngoto end;\r\n}\r\nif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\r\n{\r\nret= -1;\r\ngoto end;\r\n}\r\ns->init_buf=buf;\r\n}\r\nssl3_init_finished_mac(s);\r\ns->state=SSL23_ST_SR_CLNT_HELLO_A;\r\ns->ctx->stats.sess_accept++;\r\ns->init_num=0;\r\nbreak;\r\ncase SSL23_ST_SR_CLNT_HELLO_A:\r\ncase SSL23_ST_SR_CLNT_HELLO_B:\r\ns->shutdown=0;\r\nret=ssl23_get_client_hello(s);\r\nif (ret >= 0) cb=NULL;\r\ngoto end;\r\ndefault:\r\nSSLerr(SSL_F_SSL23_ACCEPT,SSL_R_UNKNOWN_STATE);\r\nret= -1;\r\ngoto end;\r\n}\r\nif ((cb != NULL) && (s->state != state))\r\n{\r\nnew_state=s->state;\r\ns->state=state;\r\ncb(s,SSL_CB_ACCEPT_LOOP,1);\r\ns->state=new_state;\r\n}\r\n}\r\nend:\r\ns->in_handshake--;\r\nif (cb != NULL)\r\ncb(s,SSL_CB_ACCEPT_EXIT,ret);\r\nreturn(ret);\r\n}\r\nint ssl23_get_client_hello(SSL *s)\r\n{\r\nchar buf_space[11];\r\nchar *buf= &(buf_space[0]);\r\nunsigned char *p,*d,*d_len,*dd;\r\nunsigned int i;\r\nunsigned int csl,sil,cl;\r\nint n=0,j;\r\nint type=0;\r\nint v[2];\r\n#ifndef OPENSSL_NO_RSA\r\nint use_sslv2_strong=0;\r\n#endif\r\nif (s->state == SSL23_ST_SR_CLNT_HELLO_A)\r\n{\r\nv[0]=v[1]=0;\r\nif (!ssl3_setup_buffers(s)) goto err;\r\nn=ssl23_read_bytes(s, sizeof buf_space);\r\nif (n != sizeof buf_space) return(n);\r\np=s->packet;\r\nmemcpy(buf,p,n);\r\nif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\r\n{\r\nif ((p[3] == 0x00) && (p[4] == 0x02))\r\n{\r\nv[0]=p[3]; v[1]=p[4];\r\nif (!(s->options & SSL_OP_NO_SSLv2))\r\ntype=1;\r\n}\r\nelse if (p[3] == SSL3_VERSION_MAJOR)\r\n{\r\nv[0]=p[3]; v[1]=p[4];\r\nif (p[4] >= TLS1_VERSION_MINOR)\r\n{\r\nif (!(s->options & SSL_OP_NO_TLSv1))\r\n{\r\ns->version=TLS1_VERSION;\r\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv3))\r\n{\r\ns->version=SSL3_VERSION;\r\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv2))\r\n{\r\ntype=1;\r\n}\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv3))\r\n{\r\ns->version=SSL3_VERSION;\r\ns->state=SSL23_ST_SR_CLNT_HELLO_B;\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv2))\r\ntype=1;\r\n}\r\n}\r\nelse if ((p[0] == SSL3_RT_HANDSHAKE) &&\r\n(p[1] == SSL3_VERSION_MAJOR) &&\r\n(p[5] == SSL3_MT_CLIENT_HELLO) &&\r\n((p[3] == 0 && p[4] < 5 )\r\n|| (p[9] == p[1])))\r\n{\r\nv[0]=p[1];\r\nif (p[3] == 0 && p[4] < 6)\r\n{\r\n#if 0\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);\r\ngoto err;\r\n#else\r\nv[1] = TLS1_VERSION_MINOR;\r\n#endif\r\n}\r\nelse\r\nv[1]=p[10];\r\nif (v[1] >= TLS1_VERSION_MINOR)\r\n{\r\nif (!(s->options & SSL_OP_NO_TLSv1))\r\n{\r\ns->version=TLS1_VERSION;\r\ntype=3;\r\n}\r\nelse if (!(s->options & SSL_OP_NO_SSLv3))\r\n{\r\ns->version=SSL3_VERSION;\r\ntype=3;\r\n}\r\n}\r\nelse\r\n{\r\nif (!(s->options & SSL_OP_NO_SSLv3))\r\n{\r\ns->version=SSL3_VERSION;\r\ntype=3;\r\n}\r\nelse if (!(s->options & SSL_OP_NO_TLSv1))\r\n{\r\ns->version=TLS1_VERSION;\r\ntype=3;\r\n}\r\n}\r\n}\r\nelse if ((strncmp("GET ", (char *)p,4) == 0) ||\r\n(strncmp("POST ",(char *)p,5) == 0) ||\r\n(strncmp("HEAD ",(char *)p,5) == 0) ||\r\n(strncmp("PUT ", (char *)p,4) == 0))\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\r\ngoto err;\r\n}\r\nelse if (strncmp("CONNECT",(char *)p,7) == 0)\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\r\ngoto err;\r\n}\r\n}\r\nif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\r\n{\r\ntype=2;\r\np=s->packet;\r\nv[0] = p[3];\r\nv[1] = p[4];\r\nn=((p[0]&0x7f)<<8)|p[1];\r\nif (n > (1024*4))\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\r\ngoto err;\r\n}\r\nj=ssl23_read_bytes(s,n+2);\r\nif (j <= 0) return(j);\r\nssl3_finish_mac(s, s->packet+2, s->packet_length-2);\r\nif (s->msg_callback)\r\ns->msg_callback(0, SSL2_VERSION, 0, s->packet+2, s->packet_length-2, s, s->msg_callback_arg);\r\np=s->packet;\r\np+=5;\r\nn2s(p,csl);\r\nn2s(p,sil);\r\nn2s(p,cl);\r\nd=(unsigned char *)s->init_buf->data;\r\nif ((csl+sil+cl+11) != s->packet_length)\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\r\ngoto err;\r\n}\r\n*(d++) = SSL3_MT_CLIENT_HELLO;\r\nd_len = d;\r\nd += 3;\r\n*(d++) = SSL3_VERSION_MAJOR;\r\n*(d++) = v[1];\r\ni=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\r\nmemset(d,0,SSL3_RANDOM_SIZE);\r\nmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\r\nd+=SSL3_RANDOM_SIZE;\r\n*(d++)=0;\r\nj=0;\r\ndd=d;\r\nd+=2;\r\nfor (i=0; i<csl; i+=3)\r\n{\r\nif (p[i] != 0) continue;\r\n*(d++)=p[i+1];\r\n*(d++)=p[i+2];\r\nj+=2;\r\n}\r\ns2n(j,dd);\r\n*(d++)=1;\r\n*(d++)=0;\r\ni = (d-(unsigned char *)s->init_buf->data) - 4;\r\nl2n3((long)i, d_len);\r\ns->s3->tmp.reuse_message=1;\r\ns->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\r\ns->s3->tmp.message_size=i;\r\n}\r\nif (type == 1)\r\n{\r\n#ifdef OPENSSL_NO_SSL2\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);\r\ngoto err;\r\n#else\r\nif (s->s2 == NULL)\r\n{\r\nif (!ssl2_new(s))\r\ngoto err;\r\n}\r\nelse\r\nssl2_clear(s);\r\nif (s->s3 != NULL) ssl3_free(s);\r\nif (!BUF_MEM_grow_clean(s->init_buf,\r\nSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\r\n{\r\ngoto err;\r\n}\r\ns->state=SSL2_ST_GET_CLIENT_HELLO_A;\r\nif ((s->options & SSL_OP_MSIE_SSLV2_RSA_PADDING) ||\r\nuse_sslv2_strong ||\r\n(s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3))\r\ns->s2->ssl2_rollback=0;\r\nelse\r\ns->s2->ssl2_rollback=1;\r\ns->rstate=SSL_ST_READ_HEADER;\r\ns->packet_length=n;\r\ns->packet= &(s->s2->rbuf[0]);\r\nmemcpy(s->packet,buf,n);\r\ns->s2->rbuf_left=n;\r\ns->s2->rbuf_offs=0;\r\ns->method=SSLv2_server_method();\r\ns->handshake_func=s->method->ssl_accept;\r\n#endif\r\n}\r\nif ((type == 2) || (type == 3))\r\n{\r\nif (!ssl_init_wbio_buffer(s,1)) goto err;\r\ns->state=SSL3_ST_SR_CLNT_HELLO_A;\r\nif (type == 3)\r\n{\r\ns->rstate=SSL_ST_READ_HEADER;\r\ns->packet_length=n;\r\ns->packet= &(s->s3->rbuf.buf[0]);\r\nmemcpy(s->packet,buf,n);\r\ns->s3->rbuf.left=n;\r\ns->s3->rbuf.offset=0;\r\n}\r\nelse\r\n{\r\ns->packet_length=0;\r\ns->s3->rbuf.left=0;\r\ns->s3->rbuf.offset=0;\r\n}\r\nif (s->version == TLS1_VERSION)\r\ns->method = TLSv1_server_method();\r\nelse\r\ns->method = SSLv3_server_method();\r\n#if 0\r\ns->client_version=(v[0]<<8)|v[1];\r\n#endif\r\ns->handshake_func=s->method->ssl_accept;\r\n}\r\nif ((type < 1) || (type > 3))\r\n{\r\nSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\r\ngoto err;\r\n}\r\ns->init_num=0;\r\nif (buf != buf_space) OPENSSL_free(buf);\r\ns->first_packet=1;\r\nreturn(SSL_accept(s));\r\nerr:\r\nif (buf != buf_space) OPENSSL_free(buf);\r\nreturn(-1);\r\n}
