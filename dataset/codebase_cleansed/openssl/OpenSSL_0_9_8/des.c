int main(int argc, char **argv)\r\n{\r\nint i;\r\nstruct stat ins,outs;\r\nchar *p;\r\nchar *in=NULL,*out=NULL;\r\nvflag=cflag=eflag=dflag=kflag=hflag=bflag=fflag=sflag=uflag=flag3=0;\r\nerror=0;\r\nmemset(key,0,sizeof(key));\r\nfor (i=1; i<argc; i++)\r\n{\r\np=argv[i];\r\nif ((p[0] == '-') && (p[1] != '\0'))\r\n{\r\np++;\r\nwhile (*p)\r\n{\r\nswitch (*(p++))\r\n{\r\ncase '3':\r\nflag3=1;\r\nlongk=1;\r\nbreak;\r\ncase 'c':\r\ncflag=1;\r\nstrncpy(cksumname,p,200);\r\ncksumname[sizeof(cksumname)-1]='\0';\r\np+=strlen(cksumname);\r\nbreak;\r\ncase 'C':\r\ncflag=1;\r\nlongk=1;\r\nstrncpy(cksumname,p,200);\r\ncksumname[sizeof(cksumname)-1]='\0';\r\np+=strlen(cksumname);\r\nbreak;\r\ncase 'e':\r\neflag=1;\r\nbreak;\r\ncase 'v':\r\nvflag=1;\r\nbreak;\r\ncase 'E':\r\neflag=1;\r\nlongk=1;\r\nbreak;\r\ncase 'd':\r\ndflag=1;\r\nbreak;\r\ncase 'D':\r\ndflag=1;\r\nlongk=1;\r\nbreak;\r\ncase 'b':\r\nbflag=1;\r\nbreak;\r\ncase 'f':\r\nfflag=1;\r\nbreak;\r\ncase 's':\r\nsflag=1;\r\nbreak;\r\ncase 'u':\r\nuflag=1;\r\nstrncpy(uuname,p,200);\r\nuuname[sizeof(uuname)-1]='\0';\r\np+=strlen(uuname);\r\nbreak;\r\ncase 'h':\r\nhflag=1;\r\nbreak;\r\ncase 'k':\r\nkflag=1;\r\nif ((i+1) == argc)\r\n{\r\nfputs("must have a key with the -k option\n",stderr);\r\nerror=1;\r\n}\r\nelse\r\n{\r\nint j;\r\ni++;\r\nstrncpy(key,argv[i],KEYSIZB);\r\nfor (j=strlen(argv[i])-1; j>=0; j--)\r\nargv[i][j]='\0';\r\n}\r\nbreak;\r\ndefault:\r\nfprintf(stderr,"'%c' unknown flag\n",p[-1]);\r\nerror=1;\r\nbreak;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif (in == NULL)\r\nin=argv[i];\r\nelse if (out == NULL)\r\nout=argv[i];\r\nelse\r\nerror=1;\r\n}\r\n}\r\nif (error) usage();\r\nif (((eflag+dflag) == 1) || cflag)\r\n{\r\nif (eflag) do_encrypt=DES_ENCRYPT;\r\nif (dflag) do_encrypt=DES_DECRYPT;\r\n}\r\nelse\r\n{\r\nif (vflag)\r\n{\r\n#ifndef _Windows\r\nfprintf(stderr,"des(1) built with %s\n",libdes_version);\r\n#endif\r\nEXIT(1);\r\n}\r\nelse usage();\r\n}\r\n#ifndef _Windows\r\nif (vflag) fprintf(stderr,"des(1) built with %s\n",libdes_version);\r\n#endif\r\nif ( (in != NULL) &&\r\n(out != NULL) &&\r\n#ifndef OPENSSL_SYS_MSDOS\r\n(stat(in,&ins) != -1) &&\r\n(stat(out,&outs) != -1) &&\r\n(ins.st_dev == outs.st_dev) &&\r\n(ins.st_ino == outs.st_ino))\r\n#else\r\n(strcmp(in,out) == 0))\r\n#endif\r\n{\r\nfputs("input and output file are the same\n",stderr);\r\nEXIT(3);\r\n}\r\nif (!kflag\r\nvoid doencryption(void)\r\n{\r\n#ifdef _LIBC\r\nextern unsigned long time();\r\n#endif\r\nregister int i;\r\nDES_key_schedule ks,ks2;\r\nDES_cblock iv,iv2;\r\nchar *p;\r\nint num=0,j,k,l,rem,ll,len,last,ex=0;\r\nDES_cblock kk,k2;\r\nFILE *O;\r\nint Exit=0;\r\n#ifndef OPENSSL_SYS_MSDOS\r\nstatic unsigned char buf[BUFSIZE+8],obuf[BUFSIZE+8];\r\n#else\r\nstatic unsigned char *buf=NULL,*obuf=NULL;\r\nif (buf == NULL)\r\n{\r\nif ( (( buf=OPENSSL_malloc(BUFSIZE+8)) == NULL) ||\r\n((obuf=OPENSSL_malloc(BUFSIZE+8)) == NULL))\r\n{\r\nfputs("Not enough memory\n",stderr);\r\nExit=10;\r\ngoto problems;\r\n}\r\n}\r\n#endif\r\nif (hflag)\r\n{\r\nj=(flag3?16:8);\r\np=key;\r\nfor (i=0; i<j; i++)\r\n{\r\nk=0;\r\nif ((*p <= '9') && (*p >= '0'))\r\nk=(*p-'0')<<4;\r\nelse if ((*p <= 'f') && (*p >= 'a'))\r\nk=(*p-'a'+10)<<4;\r\nelse if ((*p <= 'F') && (*p >= 'A'))\r\nk=(*p-'A'+10)<<4;\r\nelse\r\n{\r\nfputs("Bad hex key\n",stderr);\r\nExit=9;\r\ngoto problems;\r\n}\r\np++;\r\nif ((*p <= '9') && (*p >= '0'))\r\nk|=(*p-'0');\r\nelse if ((*p <= 'f') && (*p >= 'a'))\r\nk|=(*p-'a'+10);\r\nelse if ((*p <= 'F') && (*p >= 'A'))\r\nk|=(*p-'A'+10);\r\nelse\r\n{\r\nfputs("Bad hex key\n",stderr);\r\nExit=9;\r\ngoto problems;\r\n}\r\np++;\r\nif (i < 8)\r\nkk[i]=k;\r\nelse\r\nk2[i-8]=k;\r\n}\r\nDES_set_key_unchecked(&k2,&ks2);\r\nOPENSSL_cleanse(k2,sizeof(k2));\r\n}\r\nelse if (longk || flag3)\r\n{\r\nif (flag3)\r\n{\r\nDES_string_to_2keys(key,&kk,&k2);\r\nDES_set_key_unchecked(&k2,&ks2);\r\nOPENSSL_cleanse(k2,sizeof(k2));\r\n}\r\nelse\r\nDES_string_to_key(key,&kk);\r\n}\r\nelse\r\nfor (i=0; i<KEYSIZ; i++)\r\n{\r\nl=0;\r\nk=key[i];\r\nfor (j=0; j<8; j++)\r\n{\r\nif (k&1) l++;\r\nk>>=1;\r\n}\r\nif (l & 1)\r\nkk[i]=key[i]&0x7f;\r\nelse\r\nkk[i]=key[i]|0x80;\r\n}\r\nDES_set_key_unchecked(&kk,&ks);\r\nOPENSSL_cleanse(key,sizeof(key));\r\nOPENSSL_cleanse(kk,sizeof(kk));\r\nmemset(iv,0,sizeof(iv));\r\nmemset(iv2,0,sizeof(iv2));\r\nl=1;\r\nrem=0;\r\nif (eflag || (!dflag && cflag))\r\n{\r\nfor (;;)\r\n{\r\nnum=l=fread(&(buf[rem]),1,BUFSIZE,DES_IN);\r\nl+=rem;\r\nnum+=rem;\r\nif (l < 0)\r\n{\r\nperror("read error");\r\nExit=6;\r\ngoto problems;\r\n}\r\nrem=l%8;\r\nlen=l-rem;\r\nif (feof(DES_IN))\r\n{\r\nfor (i=7-rem; i>0; i--)\r\nRAND_pseudo_bytes(buf + l++, 1);\r\nbuf[l++]=rem;\r\nex=1;\r\nlen+=rem;\r\n}\r\nelse\r\nl-=rem;\r\nif (cflag)\r\n{\r\nDES_cbc_cksum(buf,&cksum,\r\n(long)len,&ks,&cksum);\r\nif (!eflag)\r\n{\r\nif (feof(DES_IN)) break;\r\nelse continue;\r\n}\r\n}\r\nif (bflag && !flag3)\r\nfor (i=0; i<l; i+=8)\r\nDES_ecb_encrypt(\r\n(DES_cblock *)&(buf[i]),\r\n(DES_cblock *)&(obuf[i]),\r\n&ks,do_encrypt);\r\nelse if (flag3 && bflag)\r\nfor (i=0; i<l; i+=8)\r\nDES_ecb2_encrypt(\r\n(DES_cblock *)&(buf[i]),\r\n(DES_cblock *)&(obuf[i]),\r\n&ks,&ks2,do_encrypt);\r\nelse if (flag3 && !bflag)\r\n{\r\nchar tmpbuf[8];\r\nif (rem) memcpy(tmpbuf,&(buf[l]),\r\n(unsigned int)rem);\r\nDES_3cbc_encrypt(\r\n(DES_cblock *)buf,(DES_cblock *)obuf,\r\n(long)l,ks,ks2,&iv,\r\n&iv2,do_encrypt);\r\nif (rem) memcpy(&(buf[l]),tmpbuf,\r\n(unsigned int)rem);\r\n}\r\nelse\r\n{\r\nDES_cbc_encrypt(\r\nbuf,obuf,\r\n(long)l,&ks,&iv,do_encrypt);\r\nif (l >= 8) memcpy(iv,&(obuf[l-8]),8);\r\n}\r\nif (rem) memcpy(buf,&(buf[l]),(unsigned int)rem);\r\ni=0;\r\nwhile (i < l)\r\n{\r\nif (uflag)\r\nj=uufwrite(obuf,1,(unsigned int)l-i,\r\nDES_OUT);\r\nelse\r\nj=fwrite(obuf,1,(unsigned int)l-i,\r\nDES_OUT);\r\nif (j == -1)\r\n{\r\nperror("Write error");\r\nExit=7;\r\ngoto problems;\r\n}\r\ni+=j;\r\n}\r\nif (feof(DES_IN))\r\n{\r\nif (uflag) uufwriteEnd(DES_OUT);\r\nbreak;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nex=1;\r\nfor (;;)\r\n{\r\nif (ex) {\r\nif (uflag)\r\nl=uufread(buf,1,BUFSIZE,DES_IN);\r\nelse\r\nl=fread(buf,1,BUFSIZE,DES_IN);\r\nex=0;\r\nrem=l%8;\r\nl-=rem;\r\n}\r\nif (l < 0)\r\n{\r\nperror("read error");\r\nExit=6;\r\ngoto problems;\r\n}\r\nif (bflag && !flag3)\r\nfor (i=0; i<l; i+=8)\r\nDES_ecb_encrypt(\r\n(DES_cblock *)&(buf[i]),\r\n(DES_cblock *)&(obuf[i]),\r\n&ks,do_encrypt);\r\nelse if (flag3 && bflag)\r\nfor (i=0; i<l; i+=8)\r\nDES_ecb2_encrypt(\r\n(DES_cblock *)&(buf[i]),\r\n(DES_cblock *)&(obuf[i]),\r\n&ks,&ks2,do_encrypt);\r\nelse if (flag3 && !bflag)\r\n{\r\nDES_3cbc_encrypt(\r\n(DES_cblock *)buf,(DES_cblock *)obuf,\r\n(long)l,ks,ks2,&iv,\r\n&iv2,do_encrypt);\r\n}\r\nelse\r\n{\r\nDES_cbc_encrypt(\r\nbuf,obuf,\r\n(long)l,&ks,&iv,do_encrypt);\r\nif (l >= 8) memcpy(iv,&(buf[l-8]),8);\r\n}\r\nif (uflag)\r\nll=uufread(&(buf[rem]),1,BUFSIZE,DES_IN);\r\nelse\r\nll=fread(&(buf[rem]),1,BUFSIZE,DES_IN);\r\nll+=rem;\r\nrem=ll%8;\r\nll-=rem;\r\nif (feof(DES_IN) && (ll == 0))\r\n{\r\nlast=obuf[l-1];\r\nif ((last > 7) || (last < 0))\r\n{\r\nfputs("The file was not decrypted correctly.\n",\r\nstderr);\r\nExit=8;\r\nlast=0;\r\n}\r\nl=l-8+last;\r\n}\r\ni=0;\r\nif (cflag) DES_cbc_cksum(obuf,\r\n(DES_cblock *)cksum,(long)l/8*8,&ks,\r\n(DES_cblock *)cksum);\r\nwhile (i != l)\r\n{\r\nj=fwrite(obuf,1,(unsigned int)l-i,DES_OUT);\r\nif (j == -1)\r\n{\r\nperror("Write error");\r\nExit=7;\r\ngoto problems;\r\n}\r\ni+=j;\r\n}\r\nl=ll;\r\nif ((l == 0) && feof(DES_IN)) break;\r\n}\r\n}\r\nif (cflag)\r\n{\r\nl=0;\r\nif (cksumname[0] != '\0')\r\n{\r\nif ((O=fopen(cksumname,"w")) != NULL)\r\n{\r\nCKSUM_OUT=O;\r\nl=1;\r\n}\r\n}\r\nfor (i=0; i<8; i++)\r\nfprintf(CKSUM_OUT,"%02X",cksum[i]);\r\nfprintf(CKSUM_OUT,"\n");\r\nif (l) fclose(CKSUM_OUT);\r\n}\r\nproblems:\r\nOPENSSL_cleanse(buf,sizeof(buf));\r\nOPENSSL_cleanse(obuf,sizeof(obuf));\r\nOPENSSL_cleanse(&ks,sizeof(ks));\r\nOPENSSL_cleanse(&ks2,sizeof(ks2));\r\nOPENSSL_cleanse(iv,sizeof(iv));\r\nOPENSSL_cleanse(iv2,sizeof(iv2));\r\nOPENSSL_cleanse(kk,sizeof(kk));\r\nOPENSSL_cleanse(k2,sizeof(k2));\r\nOPENSSL_cleanse(uubuf,sizeof(uubuf));\r\nOPENSSL_cleanse(b,sizeof(b));\r\nOPENSSL_cleanse(bb,sizeof(bb));\r\nOPENSSL_cleanse(cksum,sizeof(cksum));\r\nif (Exit) EXIT(Exit);\r\n}\r\nint uufwrite(unsigned char *data, int size, unsigned int num, FILE *fp)\r\n{\r\nint i,j,left,rem,ret=num;\r\nstatic int start=1;\r\nif (start)\r\n{\r\nfprintf(fp,"begin 600 %s\n",\r\n(uuname[0] == '\0')?"text.d":uuname);\r\nstart=0;\r\n}\r\nif (uubufnum)\r\n{\r\nif (uubufnum+num < 45)\r\n{\r\nmemcpy(&(uubuf[uubufnum]),data,(unsigned int)num);\r\nuubufnum+=num;\r\nreturn(num);\r\n}\r\nelse\r\n{\r\ni=45-uubufnum;\r\nmemcpy(&(uubuf[uubufnum]),data,(unsigned int)i);\r\nj=uuencode((unsigned char *)uubuf,45,b);\r\nfwrite(b,1,(unsigned int)j,fp);\r\nuubufnum=0;\r\ndata+=i;\r\nnum-=i;\r\n}\r\n}\r\nfor (i=0; i<(((int)num)-INUUBUFN); i+=INUUBUFN)\r\n{\r\nj=uuencode(&(data[i]),INUUBUFN,b);\r\nfwrite(b,1,(unsigned int)j,fp);\r\n}\r\nrem=(num-i)%45;\r\nleft=(num-i-rem);\r\nif (left)\r\n{\r\nj=uuencode(&(data[i]),left,b);\r\nfwrite(b,1,(unsigned int)j,fp);\r\ni+=left;\r\n}\r\nif (i != num)\r\n{\r\nmemcpy(uubuf,&(data[i]),(unsigned int)rem);\r\nuubufnum=rem;\r\n}\r\nreturn(ret);\r\n}\r\nvoid uufwriteEnd(FILE *fp)\r\n{\r\nint j;\r\nstatic const char *end=" \nend\n";\r\nif (uubufnum != 0)\r\n{\r\nuubuf[uubufnum]='\0';\r\nuubuf[uubufnum+1]='\0';\r\nuubuf[uubufnum+2]='\0';\r\nj=uuencode(uubuf,uubufnum,b);\r\nfwrite(b,1,(unsigned int)j,fp);\r\n}\r\nfwrite(end,1,strlen(end),fp);\r\n}\r\nint uufread(unsigned char *out, int size, unsigned int num, FILE *fp)\r\n{\r\nint i,j,tot;\r\nstatic int done=0;\r\nstatic int valid=0;\r\nstatic int start=1;\r\nif (start)\r\n{\r\nfor (;;)\r\n{\r\nb[0]='\0';\r\nfgets((char *)b,300,fp);\r\nif (b[0] == '\0')\r\n{\r\nfprintf(stderr,"no 'begin' found in uuencoded input\n");\r\nreturn(-1);\r\n}\r\nif (strncmp((char *)b,"begin ",6) == 0) break;\r\n}\r\nstart=0;\r\n}\r\nif (done) return(0);\r\ntot=0;\r\nif (valid)\r\n{\r\nmemcpy(out,bb,(unsigned int)valid);\r\ntot=valid;\r\nvalid=0;\r\n}\r\nfor (;;)\r\n{\r\nb[0]='\0';\r\nfgets((char *)b,300,fp);\r\nif (b[0] == '\0') break;\r\ni=strlen((char *)b);\r\nif ((b[0] == 'e') && (b[1] == 'n') && (b[2] == 'd'))\r\n{\r\ndone=1;\r\nwhile (!feof(fp))\r\n{\r\nfgets((char *)b,300,fp);\r\n}\r\nbreak;\r\n}\r\ni=uudecode(b,i,bb);\r\nif (i < 0) break;\r\nif ((i+tot+8) > num)\r\n{\r\nj=(num/8*8)-tot-8;\r\nmemcpy(&(out[tot]),bb,(unsigned int)j);\r\ntot+=j;\r\nmemcpy(bb,&(bb[j]),(unsigned int)i-j);\r\nvalid=i-j;\r\nbreak;\r\n}\r\nmemcpy(&(out[tot]),bb,(unsigned int)i);\r\ntot+=i;\r\n}\r\nreturn(tot);\r\n}\r\nint uuencode(unsigned char *in, int num, unsigned char *out)\r\n{\r\nint j,i,n,tot=0;\r\nDES_LONG l;\r\nregister unsigned char *p;\r\np=out;\r\nfor (j=0; j<num; j+=45)\r\n{\r\nif (j+45 > num)\r\ni=(num-j);\r\nelse i=45;\r\n*(p++)=i+' ';\r\nfor (n=0; n<i; n+=3)\r\n{\r\nccc2l(in,l);\r\n*(p++)=((l>>18)&0x3f)+' ';\r\n*(p++)=((l>>12)&0x3f)+' ';\r\n*(p++)=((l>> 6)&0x3f)+' ';\r\n*(p++)=((l )&0x3f)+' ';\r\ntot+=4;\r\n}\r\n*(p++)='\n';\r\ntot+=2;\r\n}\r\n*p='\0';\r\nl=0;\r\nreturn(tot);\r\n}\r\nint uudecode(unsigned char *in, int num, unsigned char *out)\r\n{\r\nint j,i,k;\r\nunsigned int n=0,space=0;\r\nDES_LONG l;\r\nDES_LONG w,x,y,z;\r\nunsigned int blank=(unsigned int)'\n'-' ';\r\nfor (j=0; j<num; )\r\n{\r\nn= *(in++)-' ';\r\nif (n == blank)\r\n{\r\nn=0;\r\nin--;\r\n}\r\nif (n > 60)\r\n{\r\nfprintf(stderr,"uuencoded line length too long\n");\r\nreturn(-1);\r\n}\r\nj++;\r\nfor (i=0; i<n; j+=4,i+=3)\r\n{\r\nif (space)\r\n{\r\nw=x=y=z=0;\r\n}\r\nelse\r\n{\r\nw= *(in++)-' ';\r\nx= *(in++)-' ';\r\ny= *(in++)-' ';\r\nz= *(in++)-' ';\r\n}\r\nif ((w > 63) || (x > 63) || (y > 63) || (z > 63))\r\n{\r\nk=0;\r\nif (w == blank) k=1;\r\nif (x == blank) k=2;\r\nif (y == blank) k=3;\r\nif (z == blank) k=4;\r\nspace=1;\r\nswitch (k) {\r\ncase 1: w=0; in--;\r\ncase 2: x=0; in--;\r\ncase 3: y=0; in--;\r\ncase 4: z=0; in--;\r\nbreak;\r\ncase 0:\r\nspace=0;\r\nfprintf(stderr,"bad uuencoded data values\n");\r\nw=x=y=z=0;\r\nreturn(-1);\r\nbreak;\r\n}\r\n}\r\nl=(w<<18)|(x<<12)|(y<< 6)|(z );\r\nl2ccc(l,out);\r\n}\r\nif (*(in++) != '\n')\r\n{\r\nfprintf(stderr,"missing nl in uuencoded line\n");\r\nw=x=y=z=0;\r\nreturn(-1);\r\n}\r\nj++;\r\n}\r\n*out='\0';\r\nw=x=y=z=0;\r\nreturn(n);\r\n}
