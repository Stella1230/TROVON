CONF_VALUE *_CONF_get_section(const CONF *conf, const char *section)\r\n{\r\nCONF_VALUE *v,vv;\r\nif ((conf == NULL) || (section == NULL)) return(NULL);\r\nvv.name=NULL;\r\nvv.section=(char *)section;\r\nv=(CONF_VALUE *)lh_retrieve(conf->data,&vv);\r\nreturn(v);\r\n}\r\nint _CONF_add_string(CONF *conf, CONF_VALUE *section, CONF_VALUE *value)\r\n{\r\nCONF_VALUE *v = NULL;\r\nSTACK_OF(CONF_VALUE) *ts;\r\nts = (STACK_OF(CONF_VALUE) *)section->value;\r\nvalue->section=section->section;\r\nif (!sk_CONF_VALUE_push(ts,value))\r\n{\r\nreturn 0;\r\n}\r\nv = (CONF_VALUE *)lh_insert(conf->data, value);\r\nif (v != NULL)\r\n{\r\nsk_CONF_VALUE_delete_ptr(ts,v);\r\nOPENSSL_free(v->name);\r\nOPENSSL_free(v->value);\r\nOPENSSL_free(v);\r\n}\r\nreturn 1;\r\n}\r\nchar *_CONF_get_string(const CONF *conf, const char *section, const char *name)\r\n{\r\nCONF_VALUE *v,vv;\r\nchar *p;\r\nif (name == NULL) return(NULL);\r\nif (conf != NULL)\r\n{\r\nif (section != NULL)\r\n{\r\nvv.name=(char *)name;\r\nvv.section=(char *)section;\r\nv=(CONF_VALUE *)lh_retrieve(conf->data,&vv);\r\nif (v != NULL) return(v->value);\r\nif (strcmp(section,"ENV") == 0)\r\n{\r\np=Getenv(name);\r\nif (p != NULL) return(p);\r\n}\r\n}\r\nvv.section="default";\r\nvv.name=(char *)name;\r\nv=(CONF_VALUE *)lh_retrieve(conf->data,&vv);\r\nif (v != NULL)\r\nreturn(v->value);\r\nelse\r\nreturn(NULL);\r\n}\r\nelse\r\nreturn(Getenv(name));\r\n}\r\nint _CONF_new_data(CONF *conf)\r\n{\r\nif (conf == NULL)\r\n{\r\nreturn 0;\r\n}\r\nif (conf->data == NULL)\r\nif ((conf->data = lh_new(hash, cmp_conf)) == NULL)\r\n{\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid _CONF_free_data(CONF *conf)\r\n{\r\nif (conf == NULL || conf->data == NULL) return;\r\nconf->data->down_load=0;\r\nlh_doall_arg(conf->data, LHASH_DOALL_ARG_FN(value_free_hash),\r\nconf->data);\r\nlh_doall_arg(conf->data, LHASH_DOALL_ARG_FN(value_free_stack),\r\nconf->data);\r\nlh_free(conf->data);\r\n}\r\nstatic void value_free_hash(CONF_VALUE *a, LHASH *conf)\r\n{\r\nif (a->name != NULL)\r\n{\r\na=(CONF_VALUE *)lh_delete(conf,a);\r\n}\r\n}\r\nstatic void value_free_stack(CONF_VALUE *a, LHASH *conf)\r\n{\r\nCONF_VALUE *vv;\r\nSTACK *sk;\r\nint i;\r\nif (a->name != NULL) return;\r\nsk=(STACK *)a->value;\r\nfor (i=sk_num(sk)-1; i>=0; i--)\r\n{\r\nvv=(CONF_VALUE *)sk_value(sk,i);\r\nOPENSSL_free(vv->value);\r\nOPENSSL_free(vv->name);\r\nOPENSSL_free(vv);\r\n}\r\nif (sk != NULL) sk_free(sk);\r\nOPENSSL_free(a->section);\r\nOPENSSL_free(a);\r\n}\r\nstatic unsigned long hash(const void *v_void)\r\n{\r\nCONF_VALUE *v = (CONF_VALUE *)v_void;\r\nreturn((lh_strhash(v->section)<<2)^lh_strhash(v->name));\r\n}\r\nstatic int cmp_conf(const void *a_void,const void *b_void)\r\n{\r\nint i;\r\nCONF_VALUE *a = (CONF_VALUE *)a_void;\r\nCONF_VALUE *b = (CONF_VALUE *)b_void;\r\nif (a->section != b->section)\r\n{\r\ni=strcmp(a->section,b->section);\r\nif (i) return(i);\r\n}\r\nif ((a->name != NULL) && (b->name != NULL))\r\n{\r\ni=strcmp(a->name,b->name);\r\nreturn(i);\r\n}\r\nelse if (a->name == b->name)\r\nreturn(0);\r\nelse\r\nreturn((a->name == NULL)?-1:1);\r\n}\r\nCONF_VALUE *_CONF_new_section(CONF *conf, const char *section)\r\n{\r\nSTACK *sk=NULL;\r\nint ok=0,i;\r\nCONF_VALUE *v=NULL,*vv;\r\nif ((sk=sk_new_null()) == NULL)\r\ngoto err;\r\nif ((v=(CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE))) == NULL)\r\ngoto err;\r\ni=strlen(section)+1;\r\nif ((v->section=(char *)OPENSSL_malloc(i)) == NULL)\r\ngoto err;\r\nmemcpy(v->section,section,i);\r\nv->name=NULL;\r\nv->value=(char *)sk;\r\nvv=(CONF_VALUE *)lh_insert(conf->data,v);\r\nassert(vv == NULL);\r\nok=1;\r\nerr:\r\nif (!ok)\r\n{\r\nif (sk != NULL) sk_free(sk);\r\nif (v != NULL) OPENSSL_free(v);\r\nv=NULL;\r\n}\r\nreturn(v);\r\n}
