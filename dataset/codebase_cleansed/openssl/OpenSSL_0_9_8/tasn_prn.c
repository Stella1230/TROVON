int ASN1_item_print(BIO *out, void *fld, int indent, const ASN1_ITEM *it)\r\n{\r\nreturn asn1_item_print_nm(out, fld, indent, it, it->sname);\r\n}\r\nstatic int asn1_item_print_nm(BIO *out, void *fld, int indent, const ASN1_ITEM *it, const char *name)\r\n{\r\nASN1_STRING *str;\r\nconst ASN1_TEMPLATE *tt;\r\nvoid *tmpfld;\r\nint i;\r\nif(!fld) {\r\nBIO_printf(out, "%*s%s ABSENT\n", indent, "", name);\r\nreturn 1;\r\n}\r\nswitch(it->itype) {\r\ncase ASN1_ITYPE_PRIMITIVE:\r\nif(it->templates)\r\nreturn ASN1_template_print(out, fld, indent, it->templates);\r\nreturn asn1_primitive_print(out, fld, it->utype, indent, name);\r\nbreak;\r\ncase ASN1_ITYPE_MSTRING:\r\nstr = fld;\r\nreturn asn1_primitive_print(out, fld, str->type, indent, name);\r\ncase ASN1_ITYPE_EXTERN:\r\nBIO_printf(out, "%*s%s:EXTERNAL TYPE %s %s\n", indent, "", name, it->sname, fld ? "" : "ABSENT");\r\nreturn 1;\r\ncase ASN1_ITYPE_COMPAT:\r\nBIO_printf(out, "%*s%s:COMPATIBLE TYPE %s %s\n", indent, "", name, it->sname, fld ? "" : "ABSENT");\r\nreturn 1;\r\ncase ASN1_ITYPE_CHOICE:\r\ni = asn1_get_choice_selector(fld, it);\r\nif((i < 0) || (i >= it->tcount)) {\r\nBIO_printf(out, "%s selector [%d] out of range\n", it->sname, i);\r\nreturn 1;\r\n}\r\ntt = it->templates + i;\r\ntmpfld = asn1_get_field(fld, tt);\r\nreturn ASN1_template_print(out, tmpfld, indent, tt);\r\ncase ASN1_ITYPE_SEQUENCE:\r\nBIO_printf(out, "%*s%s {\n", indent, "", name);\r\nfor(i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\r\ntmpfld = asn1_get_field(fld, tt);\r\nASN1_template_print(out, tmpfld, indent + 2, tt);\r\n}\r\nBIO_printf(out, "%*s}\n", indent, "");\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint ASN1_template_print(BIO *out, void *fld, int indent, const ASN1_TEMPLATE *tt)\r\n{\r\nint i, flags;\r\n#if 0\r\nif(!fld) return 0;\r\n#endif\r\nflags = tt->flags;\r\nif(flags & ASN1_TFLG_SK_MASK) {\r\nchar *tname;\r\nvoid *skitem;\r\nif(flags & ASN1_TFLG_SET_OF) tname = "SET";\r\nelse tname = "SEQUENCE";\r\nif(fld) {\r\nBIO_printf(out, "%*s%s OF %s {\n", indent, "", tname, tt->field_name);\r\nfor(i = 0; i < sk_num(fld); i++) {\r\nskitem = sk_value(fld, i);\r\nasn1_item_print_nm(out, skitem, indent + 2, tt->item, "");\r\n}\r\nBIO_printf(out, "%*s}\n", indent, "");\r\n} else\r\nBIO_printf(out, "%*s%s OF %s ABSENT\n", indent, "", tname, tt->field_name);\r\nreturn 1;\r\n}\r\nreturn asn1_item_print_nm(out, fld, indent, tt->item, tt->field_name);\r\n}\r\nstatic int asn1_primitive_print(BIO *out, void *fld, long utype, int indent, const char *name)\r\n{\r\nASN1_STRING *str = fld;\r\nif(fld) {\r\nif(utype == V_ASN1_BOOLEAN) {\r\nint *bool = fld;\r\nif(*bool == -1) printf("BOOL MISSING\n");\r\nBIO_printf(out, "%*s%s:%s", indent, "", "BOOLEAN", *bool ? "TRUE" : "FALSE");\r\n} else if((utype == V_ASN1_INTEGER)\r\n|| (utype == V_ASN1_ENUMERATED)) {\r\nchar *s, *nm;\r\ns = i2s_ASN1_INTEGER(NULL, fld);\r\nif(utype == V_ASN1_INTEGER) nm = "INTEGER";\r\nelse nm = "ENUMERATED";\r\nBIO_printf(out, "%*s%s:%s", indent, "", nm, s);\r\nOPENSSL_free(s);\r\n} else if(utype == V_ASN1_NULL) {\r\nBIO_printf(out, "%*s%s", indent, "", "NULL");\r\n} else if(utype == V_ASN1_UTCTIME) {\r\nBIO_printf(out, "%*s%s:%s:", indent, "", name, "UTCTIME");\r\nASN1_UTCTIME_print(out, str);\r\n} else if(utype == V_ASN1_GENERALIZEDTIME) {\r\nBIO_printf(out, "%*s%s:%s:", indent, "", name, "GENERALIZEDTIME");\r\nASN1_GENERALIZEDTIME_print(out, str);\r\n} else if(utype == V_ASN1_OBJECT) {\r\nchar objbuf[80], *ln;\r\nln = OBJ_nid2ln(OBJ_obj2nid(fld));\r\nif(!ln) ln = "";\r\nOBJ_obj2txt(objbuf, sizeof objbuf, fld, 1);\r\nBIO_printf(out, "%*s%s:%s (%s)", indent, "", "OBJECT", ln, objbuf);\r\n} else {\r\nBIO_printf(out, "%*s%s:", indent, "", name);\r\nASN1_STRING_print_ex(out, str, ASN1_STRFLGS_DUMP_UNKNOWN|ASN1_STRFLGS_SHOW_TYPE);\r\n}\r\nBIO_printf(out, "\n");\r\n} else BIO_printf(out, "%*s%s [ABSENT]\n", indent, "", name);\r\nreturn 1;\r\n}
