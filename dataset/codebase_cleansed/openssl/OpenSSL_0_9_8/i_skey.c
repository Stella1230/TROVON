void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks)\r\n{\r\nint i;\r\nregister IDEA_INT *kt,*kf,r0,r1,r2;\r\nkt= &(ks->data[0][0]);\r\nn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]);\r\nn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]);\r\nkf=kt;\r\nkt+=8;\r\nfor (i=0; i<6; i++)\r\n{\r\nr2= kf[1];\r\nr1= kf[2];\r\n*(kt++)= ((r2<<9) | (r1>>7))&0xffff;\r\nr0= kf[3];\r\n*(kt++)= ((r1<<9) | (r0>>7))&0xffff;\r\nr1= kf[4];\r\n*(kt++)= ((r0<<9) | (r1>>7))&0xffff;\r\nr0= kf[5];\r\n*(kt++)= ((r1<<9) | (r0>>7))&0xffff;\r\nr1= kf[6];\r\n*(kt++)= ((r0<<9) | (r1>>7))&0xffff;\r\nr0= kf[7];\r\n*(kt++)= ((r1<<9) | (r0>>7))&0xffff;\r\nr1= kf[0];\r\nif (i >= 5) break;\r\n*(kt++)= ((r0<<9) | (r1>>7))&0xffff;\r\n*(kt++)= ((r1<<9) | (r2>>7))&0xffff;\r\nkf+=8;\r\n}\r\n}\r\nvoid idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk)\r\n{\r\nint r;\r\nregister IDEA_INT *fp,*tp,t;\r\ntp= &(dk->data[0][0]);\r\nfp= &(ek->data[8][0]);\r\nfor (r=0; r<9; r++)\r\n{\r\n*(tp++)=inverse(fp[0]);\r\n*(tp++)=((int)(0x10000L-fp[2])&0xffff);\r\n*(tp++)=((int)(0x10000L-fp[1])&0xffff);\r\n*(tp++)=inverse(fp[3]);\r\nif (r == 8) break;\r\nfp-=6;\r\n*(tp++)=fp[4];\r\n*(tp++)=fp[5];\r\n}\r\ntp= &(dk->data[0][0]);\r\nt=tp[1];\r\ntp[1]=tp[2];\r\ntp[2]=t;\r\nt=tp[49];\r\ntp[49]=tp[50];\r\ntp[50]=t;\r\n}\r\nstatic IDEA_INT inverse(unsigned int xin)\r\n{\r\nlong n1,n2,q,r,b1,b2,t;\r\nif (xin == 0)\r\nb2=0;\r\nelse\r\n{\r\nn1=0x10001;\r\nn2=xin;\r\nb2=1;\r\nb1=0;\r\ndo {\r\nr=(n1%n2);\r\nq=(n1-r)/n2;\r\nif (r == 0)\r\n{ if (b2 < 0) b2=0x10001+b2; }\r\nelse\r\n{\r\nn1=n2;\r\nn2=r;\r\nt=b2;\r\nb2=b1-q*b2;\r\nb1=t;\r\n}\r\n} while (r != 0);\r\n}\r\nreturn((IDEA_INT)b2);\r\n}
