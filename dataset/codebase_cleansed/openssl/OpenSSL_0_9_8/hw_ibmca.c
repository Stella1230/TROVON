static int bind_helper(ENGINE *e)\r\n{\r\n#ifndef OPENSSL_NO_RSA\r\nconst RSA_METHOD *meth1;\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\nconst DSA_METHOD *meth2;\r\n#endif\r\n#ifndef OPENSSL_NO_DH\r\nconst DH_METHOD *meth3;\r\n#endif\r\nif(!ENGINE_set_id(e, engine_ibmca_id) ||\r\n!ENGINE_set_name(e, engine_ibmca_name) ||\r\n#ifndef OPENSSL_NO_RSA\r\n!ENGINE_set_RSA(e, &ibmca_rsa) ||\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\n!ENGINE_set_DSA(e, &ibmca_dsa) ||\r\n#endif\r\n#ifndef OPENSSL_NO_DH\r\n!ENGINE_set_DH(e, &ibmca_dh) ||\r\n#endif\r\n!ENGINE_set_RAND(e, &ibmca_rand) ||\r\n!ENGINE_set_destroy_function(e, ibmca_destroy) ||\r\n!ENGINE_set_init_function(e, ibmca_init) ||\r\n!ENGINE_set_finish_function(e, ibmca_finish) ||\r\n!ENGINE_set_ctrl_function(e, ibmca_ctrl) ||\r\n!ENGINE_set_cmd_defns(e, ibmca_cmd_defns))\r\nreturn 0;\r\n#ifndef OPENSSL_NO_RSA\r\nmeth1 = RSA_PKCS1_SSLeay();\r\nibmca_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\r\nibmca_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\r\nibmca_rsa.rsa_priv_enc = meth1->rsa_priv_enc;\r\nibmca_rsa.rsa_priv_dec = meth1->rsa_priv_dec;\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\nmeth2 = DSA_OpenSSL();\r\nibmca_dsa.dsa_do_sign = meth2->dsa_do_sign;\r\nibmca_dsa.dsa_sign_setup = meth2->dsa_sign_setup;\r\nibmca_dsa.dsa_do_verify = meth2->dsa_do_verify;\r\n#endif\r\n#ifndef OPENSSL_NO_DH\r\nmeth3 = DH_OpenSSL();\r\nibmca_dh.generate_key = meth3->generate_key;\r\nibmca_dh.compute_key = meth3->compute_key;\r\n#endif\r\nERR_load_IBMCA_strings();\r\nreturn 1;\r\n}\r\nstatic ENGINE *engine_ibmca(void)\r\n{\r\nENGINE *ret = ENGINE_new();\r\nif(!ret)\r\nreturn NULL;\r\nif(!bind_helper(ret))\r\n{\r\nENGINE_free(ret);\r\nreturn NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic\r\n#endif\r\nvoid ENGINE_load_ibmca(void)\r\n{\r\nENGINE *toadd = engine_ibmca();\r\nif(!toadd) return;\r\nENGINE_add(toadd);\r\nENGINE_free(toadd);\r\nERR_clear_error();\r\n}\r\nstatic int ibmca_destroy(ENGINE *e)\r\n{\r\nERR_unload_IBMCA_strings();\r\nreturn 1;\r\n}\r\nstatic int get_context(ICA_ADAPTER_HANDLE *p_handle)\r\n{\r\nunsigned int status=0;\r\nstatus = p_icaOpenAdapter(0, p_handle);\r\nif(status != 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void release_context(ICA_ADAPTER_HANDLE handle)\r\n{\r\np_icaCloseAdapter(handle);\r\n}\r\nstatic int ibmca_init(ENGINE *e)\r\n{\r\nvoid (*p1)();\r\nvoid (*p2)();\r\nvoid (*p3)();\r\nvoid (*p4)();\r\nvoid (*p5)();\r\nif(ibmca_dso != NULL)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_INIT,IBMCA_R_ALREADY_LOADED);\r\ngoto err;\r\n}\r\nibmca_dso = DSO_load(NULL, IBMCA_LIBNAME, NULL,\r\n0);\r\nif(ibmca_dso == NULL)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_INIT,IBMCA_R_DSO_FAILURE);\r\ngoto err;\r\n}\r\nif(!(p1 = DSO_bind_func(\r\nibmca_dso, IBMCA_F1)) ||\r\n!(p2 = DSO_bind_func(\r\nibmca_dso, IBMCA_F2)) ||\r\n!(p3 = DSO_bind_func(\r\nibmca_dso, IBMCA_F3)) ||\r\n!(p4 = DSO_bind_func(\r\nibmca_dso, IBMCA_F4)) ||\r\n!(p5 = DSO_bind_func(\r\nibmca_dso, IBMCA_F5)))\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_INIT,IBMCA_R_DSO_FAILURE);\r\ngoto err;\r\n}\r\np_icaOpenAdapter = (unsigned int (ICA_CALL *)())p1;\r\np_icaCloseAdapter = (unsigned int (ICA_CALL *)())p2;\r\np_icaRsaModExpo = (unsigned int (ICA_CALL *)())p3;\r\np_icaRandomNumberGenerate = (unsigned int (ICA_CALL *)())p4;\r\np_icaRsaCrt = (unsigned int (ICA_CALL *)())p5;\r\nif(!get_context(&handle))\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_INIT,IBMCA_R_UNIT_FAILURE);\r\ngoto err;\r\n}\r\nreturn 1;\r\nerr:\r\nif(ibmca_dso)\r\nDSO_free(ibmca_dso);\r\np_icaOpenAdapter = NULL;\r\np_icaCloseAdapter = NULL;\r\np_icaRsaModExpo = NULL;\r\np_icaRandomNumberGenerate = NULL;\r\nreturn 0;\r\n}\r\nstatic int ibmca_finish(ENGINE *e)\r\n{\r\nif(ibmca_dso == NULL)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_FINISH,IBMCA_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\nrelease_context(handle);\r\nif(!DSO_free(ibmca_dso))\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_FINISH,IBMCA_R_DSO_FAILURE);\r\nreturn 0;\r\n}\r\nibmca_dso = NULL;\r\nreturn 1;\r\n}\r\nstatic int ibmca_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f)())\r\n{\r\nint initialised = ((ibmca_dso == NULL) ? 0 : 1);\r\nswitch(cmd)\r\n{\r\ncase IBMCA_CMD_SO_PATH:\r\nif(p == NULL)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_CTRL,ERR_R_PASSED_NULL_PARAMETER);\r\nreturn 0;\r\n}\r\nif(initialised)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_CTRL,IBMCA_R_ALREADY_LOADED);\r\nreturn 0;\r\n}\r\nIBMCA_LIBNAME = (const char *)p;\r\nreturn 1;\r\ndefault:\r\nbreak;\r\n}\r\nIBMCAerr(IBMCA_F_IBMCA_CTRL,IBMCA_R_CTRL_COMMAND_NOT_IMPLEMENTED);\r\nreturn 0;\r\n}\r\nstatic int ibmca_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\r\nconst BIGNUM *m, BN_CTX *ctx)\r\n{\r\nBIGNUM *argument=NULL;\r\nBIGNUM *result=NULL;\r\nBIGNUM *key=NULL;\r\nint to_return;\r\nint inLen, outLen, tmpLen;\r\nICA_KEY_RSA_MODEXPO *publKey=NULL;\r\nunsigned int rc;\r\nto_return = 0;\r\nif(!ibmca_dso)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_NOT_LOADED);\r\ngoto err;\r\n}\r\nBN_CTX_start(ctx);\r\nargument = BN_CTX_get(ctx);\r\nresult = BN_CTX_get(ctx);\r\nkey = BN_CTX_get(ctx);\r\nif( !argument || !result || !key)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_BN_CTX_FULL);\r\ngoto err;\r\n}\r\nif(!bn_wexpand(argument, m->top) || !bn_wexpand(result, m->top) ||\r\n!bn_wexpand(key, sizeof(*publKey)/BN_BYTES))\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_BN_EXPAND_FAIL);\r\ngoto err;\r\n}\r\npublKey = (ICA_KEY_RSA_MODEXPO *)key->d;\r\nif (publKey == NULL)\r\n{\r\ngoto err;\r\n}\r\nmemset(publKey, 0, sizeof(ICA_KEY_RSA_MODEXPO));\r\npublKey->keyType = CORRECT_ENDIANNESS(ME_KEY_TYPE);\r\npublKey->keyLength = CORRECT_ENDIANNESS(sizeof(ICA_KEY_RSA_MODEXPO));\r\npublKey->expOffset = (char *) publKey->keyRecord - (char *) publKey;\r\noutLen = BN_num_bytes(m);\r\nif (outLen > 256 ) {\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_MEXP_LENGTH_TO_LARGE);\r\ngoto err;\r\n}\r\npublKey->expLength = publKey->nLength = outLen;\r\nif (outLen < BN_num_bytes(p)){\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_UNDERFLOW_KEYRECORD);\r\ngoto err;\r\n}\r\nBN_bn2bin(p, &publKey->keyRecord[publKey->expLength -\r\nBN_num_bytes(p)]);\r\nBN_bn2bin(m, &publKey->keyRecord[publKey->expLength]);\r\npublKey->modulusBitLength = CORRECT_ENDIANNESS(publKey->nLength * 8);\r\npublKey->nOffset = CORRECT_ENDIANNESS(publKey->expOffset +\r\npublKey->expLength);\r\npublKey->expOffset = CORRECT_ENDIANNESS((char *) publKey->keyRecord -\r\n(char *) publKey);\r\ntmpLen = outLen;\r\npublKey->expLength = publKey->nLength = CORRECT_ENDIANNESS(tmpLen);\r\nmemset(argument->d, 0, outLen);\r\nBN_bn2bin(a, (unsigned char *)argument->d + outLen -\r\nBN_num_bytes(a));\r\ninLen = outLen;\r\nif( (rc = p_icaRsaModExpo(handle, inLen,(unsigned char *)argument->d,\r\npublKey, &outLen, (unsigned char *)result->d))\r\n!=0 )\r\n{\r\nprintf("rc = %d\n", rc);\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP,IBMCA_R_REQUEST_FAILED);\r\ngoto err;\r\n}\r\nBN_bin2bn((unsigned char *)result->d, outLen, r);\r\nto_return = 1;\r\nerr:\r\nBN_CTX_end(ctx);\r\nreturn to_return;\r\n}\r\nstatic int ibmca_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)\r\n{\r\nBN_CTX *ctx;\r\nint to_return = 0;\r\nif((ctx = BN_CTX_new()) == NULL)\r\ngoto err;\r\nif(!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp)\r\n{\r\nif(!rsa->d || !rsa->n)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_RSA_MOD_EXP,\r\nIBMCA_R_MISSING_KEY_COMPONENTS);\r\ngoto err;\r\n}\r\nto_return = ibmca_mod_exp(r0, I, rsa->d, rsa->n, ctx);\r\n}\r\nelse\r\n{\r\nto_return = ibmca_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1,\r\nrsa->dmq1, rsa->iqmp, ctx);\r\n}\r\nerr:\r\nif(ctx)\r\nBN_CTX_free(ctx);\r\nreturn to_return;\r\n}\r\nstatic int ibmca_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\r\nconst BIGNUM *q, const BIGNUM *dmp1,\r\nconst BIGNUM *dmq1, const BIGNUM *iqmp, BN_CTX *ctx)\r\n{\r\nBIGNUM *argument = NULL;\r\nBIGNUM *result = NULL;\r\nBIGNUM *key = NULL;\r\nint to_return = 0;\r\nchar *pkey=NULL;\r\nICA_KEY_RSA_CRT *privKey=NULL;\r\nint inLen, outLen;\r\nint rc;\r\nunsigned int offset, pSize, qSize;\r\nunsigned int keyRecordSize;\r\nunsigned int pbytes = BN_num_bytes(p);\r\nunsigned int qbytes = BN_num_bytes(q);\r\nunsigned int dmp1bytes = BN_num_bytes(dmp1);\r\nunsigned int dmq1bytes = BN_num_bytes(dmq1);\r\nunsigned int iqmpbytes = BN_num_bytes(iqmp);\r\nBN_CTX_start(ctx);\r\nargument = BN_CTX_get(ctx);\r\nresult = BN_CTX_get(ctx);\r\nkey = BN_CTX_get(ctx);\r\nif(!argument || !result || !key)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_BN_CTX_FULL);\r\ngoto err;\r\n}\r\nif(!bn_wexpand(argument, p->top + q->top) ||\r\n!bn_wexpand(result, p->top + q->top) ||\r\n!bn_wexpand(key, sizeof(*privKey)/BN_BYTES ))\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_BN_EXPAND_FAIL);\r\ngoto err;\r\n}\r\nprivKey = (ICA_KEY_RSA_CRT *)key->d;\r\nkeyRecordSize = pbytes+qbytes+dmp1bytes+dmq1bytes+iqmpbytes;\r\nif ( keyRecordSize > sizeof(privKey->keyRecord )) {\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_OPERANDS_TO_LARGE);\r\ngoto err;\r\n}\r\nif ( (qbytes + dmq1bytes) > 256 ){\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_OPERANDS_TO_LARGE);\r\ngoto err;\r\n}\r\nif ( pbytes + dmp1bytes > 256 ) {\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_OPERANDS_TO_LARGE);\r\ngoto err;\r\n}\r\nmemset(privKey, 0, sizeof(ICA_KEY_RSA_CRT));\r\nprivKey->keyType = CORRECT_ENDIANNESS(CRT_KEY_TYPE);\r\nprivKey->keyLength = CORRECT_ENDIANNESS(sizeof(ICA_KEY_RSA_CRT));\r\nprivKey->modulusBitLength =\r\nCORRECT_ENDIANNESS(BN_num_bytes(q) * 2 * 8);\r\nprivKey->pLength = CORRECT_ENDIANNESS(BN_num_bytes(p)+8);\r\nprivKey->qLength = CORRECT_ENDIANNESS(BN_num_bytes(q));\r\nprivKey->dpLength = CORRECT_ENDIANNESS(BN_num_bytes(dmp1)+8);\r\nprivKey->dqLength = CORRECT_ENDIANNESS(BN_num_bytes(dmq1));\r\nprivKey->qInvLength = CORRECT_ENDIANNESS(BN_num_bytes(iqmp)+8);\r\noffset = (char *) privKey->keyRecord\r\n- (char *) privKey;\r\nqSize = BN_num_bytes(q);\r\npSize = qSize + 8;\r\nif ( (pbytes > pSize) || (dmp1bytes > pSize) ||\r\n(iqmpbytes > pSize) || ( qbytes >qSize) ||\r\n(dmq1bytes > qSize) ) {\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_OPERANDS_TO_LARGE);\r\ngoto err;\r\n}\r\nprivKey->dpOffset = CORRECT_ENDIANNESS(offset);\r\noffset += pSize;\r\nprivKey->dqOffset = CORRECT_ENDIANNESS(offset);\r\noffset += qSize;\r\nprivKey->pOffset = CORRECT_ENDIANNESS(offset);\r\noffset += pSize;\r\nprivKey->qOffset = CORRECT_ENDIANNESS(offset);\r\noffset += qSize;\r\nprivKey->qInvOffset = CORRECT_ENDIANNESS(offset);\r\npkey = (char *) privKey->keyRecord;\r\nif ( pSize < pbytes ) {\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT, IBMCA_R_UNDERFLOW_CONDITION);\r\ngoto err;\r\n}\r\npkey += pSize - BN_num_bytes(dmp1);\r\nBN_bn2bin(dmp1, pkey);\r\npkey += BN_num_bytes(dmp1);\r\nBN_bn2bin(dmq1, pkey);\r\npkey += qSize;\r\npkey += pSize - BN_num_bytes(p);\r\nBN_bn2bin(p, pkey);\r\npkey += BN_num_bytes(p);\r\nBN_bn2bin(q, pkey);\r\npkey += qSize ;\r\npkey += pSize - BN_num_bytes(iqmp);\r\nBN_bn2bin(iqmp, pkey);\r\noutLen = CORRECT_ENDIANNESS(privKey->qLength) * 2;\r\nif (outLen > 256) {\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_OUTLEN_TO_LARGE);\r\ngoto err;\r\n}\r\nif ( outLen < BN_num_bytes(a)) {\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_UNDERFLOW_CONDITION);\r\ngoto err;\r\n}\r\nBN_bn2bin(a, (unsigned char *)argument->d + outLen -\r\nBN_num_bytes(a));\r\ninLen = outLen;\r\nmemset(result->d, 0, outLen);\r\nif ( (rc = p_icaRsaCrt(handle, inLen, (unsigned char *)argument->d,\r\nprivKey, &outLen, (unsigned char *)result->d)) != 0)\r\n{\r\nprintf("rc = %d\n", rc);\r\nIBMCAerr(IBMCA_F_IBMCA_MOD_EXP_CRT,IBMCA_R_REQUEST_FAILED);\r\ngoto err;\r\n}\r\nBN_bin2bn((unsigned char *)result->d, outLen, r);\r\nto_return = 1;\r\nerr:\r\nBN_CTX_end(ctx);\r\nreturn to_return;\r\n}\r\nstatic int ibmca_dsa_mod_exp(DSA *dsa, BIGNUM *rr, BIGNUM *a1,\r\nBIGNUM *p1, BIGNUM *a2, BIGNUM *p2, BIGNUM *m,\r\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\r\n{\r\nBIGNUM t;\r\nint to_return = 0;\r\nBN_init(&t);\r\nif (!ibmca_mod_exp(rr,a1,p1,m,ctx)) goto end;\r\nif (!ibmca_mod_exp(&t,a2,p2,m,ctx)) goto end;\r\nif (!BN_mod_mul(rr,rr,&t,m,ctx)) goto end;\r\nto_return = 1;\r\nend:\r\nBN_free(&t);\r\nreturn to_return;\r\n}\r\nstatic int ibmca_mod_exp_dsa(DSA *dsa, BIGNUM *r, BIGNUM *a,\r\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\r\nBN_MONT_CTX *m_ctx)\r\n{\r\nreturn ibmca_mod_exp(r, a, p, m, ctx);\r\n}\r\nstatic int ibmca_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\r\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\r\n{\r\nreturn ibmca_mod_exp(r, a, p, m, ctx);\r\n}\r\nstatic int ibmca_mod_exp_dh(DH const *dh, BIGNUM *r,\r\nconst BIGNUM *a, const BIGNUM *p,\r\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\r\n{\r\nreturn ibmca_mod_exp(r, a, p, m, ctx);\r\n}\r\nstatic int ibmca_rand_bytes(unsigned char *buf, int num)\r\n{\r\nint to_return = 0;\r\nunsigned int ret;\r\nif(handle == 0)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_RAND_BYTES,IBMCA_R_NOT_INITIALISED);\r\ngoto err;\r\n}\r\nret = p_icaRandomNumberGenerate(handle, num, buf);\r\nif (ret < 0)\r\n{\r\nIBMCAerr(IBMCA_F_IBMCA_RAND_BYTES,IBMCA_R_REQUEST_FAILED);\r\ngoto err;\r\n}\r\nto_return = 1;\r\nerr:\r\nreturn to_return;\r\n}\r\nstatic int ibmca_rand_status(void)\r\n{\r\nreturn 1;\r\n}\r\nstatic int bind_fn(ENGINE *e, const char *id)\r\n{\r\nif(id && (strcmp(id, engine_ibmca_id) != 0))\r\nreturn 0;\r\nif(!bind_helper(e))\r\nreturn 0;\r\nreturn 1;\r\n}
