void SSLStateMachine_print_error(SSLStateMachine *pMachine,const char *szErr)\r\n{\r\nunsigned long l;\r\nfprintf(stderr,"%s\n",szErr);\r\nwhile((l=ERR_get_error()))\r\n{\r\nchar buf[1024];\r\nERR_error_string_n(l,buf,sizeof buf);\r\nfprintf(stderr,"Error %lx: %s\n",l,buf);\r\n}\r\n}\r\nSSLStateMachine *SSLStateMachine_new(const char *szCertificateFile,\r\nconst char *szKeyFile)\r\n{\r\nSSLStateMachine *pMachine=malloc(sizeof *pMachine);\r\nint n;\r\ndie_unless(pMachine);\r\npMachine->pCtx=SSL_CTX_new(SSLv23_server_method());\r\ndie_unless(pMachine->pCtx);\r\nn=SSL_CTX_use_certificate_file(pMachine->pCtx,szCertificateFile,\r\nSSL_FILETYPE_PEM);\r\ndie_unless(n > 0);\r\nn=SSL_CTX_use_PrivateKey_file(pMachine->pCtx,szKeyFile,SSL_FILETYPE_PEM);\r\ndie_unless(n > 0);\r\npMachine->pSSL=SSL_new(pMachine->pCtx);\r\ndie_unless(pMachine->pSSL);\r\npMachine->pbioRead=BIO_new(BIO_s_mem());\r\npMachine->pbioWrite=BIO_new(BIO_s_mem());\r\nSSL_set_bio(pMachine->pSSL,pMachine->pbioRead,pMachine->pbioWrite);\r\nSSL_set_accept_state(pMachine->pSSL);\r\nreturn pMachine;\r\n}\r\nvoid SSLStateMachine_read_inject(SSLStateMachine *pMachine,\r\nconst unsigned char *aucBuf,int nBuf)\r\n{\r\nint n=BIO_write(pMachine->pbioRead,aucBuf,nBuf);\r\nassert(n == nBuf);\r\nfprintf(stderr,"%d bytes of encrypted data fed to state machine\n",n);\r\n}\r\nint SSLStateMachine_read_extract(SSLStateMachine *pMachine,\r\nunsigned char *aucBuf,int nBuf)\r\n{\r\nint n;\r\nif(!SSL_is_init_finished(pMachine->pSSL))\r\n{\r\nfprintf(stderr,"Doing SSL_accept\n");\r\nn=SSL_accept(pMachine->pSSL);\r\nif(n == 0)\r\nfprintf(stderr,"SSL_accept returned zero\n");\r\nif(n < 0)\r\n{\r\nint err;\r\nif((err=SSL_get_error(pMachine->pSSL,n)) == SSL_ERROR_WANT_READ)\r\n{\r\nfprintf(stderr,"SSL_accept wants more data\n");\r\nreturn 0;\r\n}\r\nSSLStateMachine_print_error(pMachine,"SSL_accept error");\r\nexit(7);\r\n}\r\nreturn 0;\r\n}\r\nn=SSL_read(pMachine->pSSL,aucBuf,nBuf);\r\nif(n < 0)\r\n{\r\nint err=SSL_get_error(pMachine->pSSL,n);\r\nif(err == SSL_ERROR_WANT_READ)\r\n{\r\nfprintf(stderr,"SSL_read wants more data\n");\r\nreturn 0;\r\n}\r\nSSLStateMachine_print_error(pMachine,"SSL_read error");\r\nexit(8);\r\n}\r\nfprintf(stderr,"%d bytes of decrypted data read from state machine\n",n);\r\nreturn n;\r\n}\r\nint SSLStateMachine_write_can_extract(SSLStateMachine *pMachine)\r\n{\r\nint n=BIO_pending(pMachine->pbioWrite);\r\nif(n)\r\nfprintf(stderr,"There is encrypted data available to write\n");\r\nelse\r\nfprintf(stderr,"There is no encrypted data available to write\n");\r\nreturn n;\r\n}\r\nint SSLStateMachine_write_extract(SSLStateMachine *pMachine,\r\nunsigned char *aucBuf,int nBuf)\r\n{\r\nint n;\r\nn=BIO_read(pMachine->pbioWrite,aucBuf,nBuf);\r\nfprintf(stderr,"%d bytes of encrypted data read from state machine\n",n);\r\nreturn n;\r\n}\r\nvoid SSLStateMachine_write_inject(SSLStateMachine *pMachine,\r\nconst unsigned char *aucBuf,int nBuf)\r\n{\r\nint n=SSL_write(pMachine->pSSL,aucBuf,nBuf);\r\nassert(n == nBuf);\r\nfprintf(stderr,"%d bytes of unencrypted data fed to state machine\n",n);\r\n}\r\nint OpenSocket(int nPort)\r\n{\r\nint nSocket;\r\nstruct sockaddr_in saServer;\r\nstruct sockaddr_in saClient;\r\nint one=1;\r\nint nSize;\r\nint nFD;\r\nint nLen;\r\nnSocket=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\r\nif(nSocket < 0)\r\n{\r\nperror("socket");\r\nexit(1);\r\n}\r\nif(setsockopt(nSocket,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof one) < 0)\r\n{\r\nperror("setsockopt");\r\nexit(2);\r\n}\r\nmemset(&saServer,0,sizeof saServer);\r\nsaServer.sin_family=AF_INET;\r\nsaServer.sin_port=htons(nPort);\r\nnSize=sizeof saServer;\r\nif(bind(nSocket,(struct sockaddr *)&saServer,nSize) < 0)\r\n{\r\nperror("bind");\r\nexit(3);\r\n}\r\nif(listen(nSocket,512) < 0)\r\n{\r\nperror("listen");\r\nexit(4);\r\n}\r\nnLen=sizeof saClient;\r\nnFD=accept(nSocket,(struct sockaddr *)&saClient,&nLen);\r\nif(nFD < 0)\r\n{\r\nperror("accept");\r\nexit(5);\r\n}\r\nfprintf(stderr,"Incoming accepted on port %d\n",nPort);\r\nreturn nFD;\r\n}\r\nint main(int argc,char **argv)\r\n{\r\nSSLStateMachine *pMachine;\r\nint nPort;\r\nint nFD;\r\nconst char *szCertificateFile;\r\nconst char *szKeyFile;\r\nchar rbuf[1];\r\nint nrbuf=0;\r\nif(argc != 4)\r\n{\r\nfprintf(stderr,"%s <port> <certificate file> <key file>\n",argv[0]);\r\nexit(6);\r\n}\r\nnPort=atoi(argv[1]);\r\nszCertificateFile=argv[2];\r\nszKeyFile=argv[3];\r\nSSL_library_init();\r\nOpenSSL_add_ssl_algorithms();\r\nSSL_load_error_strings();\r\nERR_load_crypto_strings();\r\nnFD=OpenSocket(nPort);\r\npMachine=SSLStateMachine_new(szCertificateFile,szKeyFile);\r\nfor( ; ; )\r\n{\r\nfd_set rfds,wfds;\r\nunsigned char buf[1024];\r\nint n;\r\nFD_ZERO(&rfds);\r\nFD_ZERO(&wfds);\r\nFD_SET(nFD,&rfds);\r\nif(!nrbuf)\r\nnrbuf=SSLStateMachine_read_extract(pMachine,rbuf,1);\r\nif(nrbuf)\r\nFD_SET(1,&wfds);\r\nif(SSLStateMachine_write_can_extract(pMachine))\r\nFD_SET(nFD,&wfds);\r\nFD_SET(0,&rfds);\r\nn=select(nFD+1,&rfds,&wfds,NULL,NULL);\r\nassert(n > 0);\r\nif(FD_ISSET(nFD,&rfds))\r\n{\r\nn=read(nFD,buf,sizeof buf);\r\nif(n == 0)\r\n{\r\nfprintf(stderr,"Got EOF on socket\n");\r\nexit(0);\r\n}\r\nassert(n > 0);\r\nSSLStateMachine_read_inject(pMachine,buf,n);\r\n}\r\nif(FD_ISSET(1,&wfds))\r\n{\r\nassert(nrbuf == 1);\r\nbuf[0]=rbuf[0];\r\nnrbuf=0;\r\nn=SSLStateMachine_read_extract(pMachine,buf+1,sizeof buf-1);\r\nif(n < 0)\r\n{\r\nSSLStateMachine_print_error(pMachine,"read extract failed");\r\nbreak;\r\n}\r\nassert(n >= 0);\r\n++n;\r\nif(n > 0)\r\n{\r\nint w;\r\nw=write(1,buf,n);\r\nassert(w == n);\r\n}\r\n}\r\nif(FD_ISSET(nFD,&wfds))\r\n{\r\nint w;\r\nn=SSLStateMachine_write_extract(pMachine,buf,sizeof buf);\r\nassert(n > 0);\r\nw=write(nFD,buf,n);\r\nassert(w == n);\r\n}\r\nif(FD_ISSET(0,&rfds))\r\n{\r\nn=read(0,buf,sizeof buf);\r\nif(n == 0)\r\n{\r\nfprintf(stderr,"Got EOF on stdin\n");\r\nexit(0);\r\n}\r\nassert(n > 0);\r\nSSLStateMachine_write_inject(pMachine,buf,n);\r\n}\r\n}\r\nreturn 0;\r\n}
