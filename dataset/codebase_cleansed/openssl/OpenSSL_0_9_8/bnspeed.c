static double Time_F(int s)\r\n{\r\ndouble ret;\r\n#ifdef TIMES\r\nstatic struct tms tstart,tend;\r\nif (s == START)\r\n{\r\ntimes(&tstart);\r\nreturn(0);\r\n}\r\nelse\r\n{\r\ntimes(&tend);\r\nret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;\r\nreturn((ret < 1e-3)?1e-3:ret);\r\n}\r\n#else\r\nstatic struct timeb tstart,tend;\r\nlong i;\r\nif (s == START)\r\n{\r\nftime(&tstart);\r\nreturn(0);\r\n}\r\nelse\r\n{\r\nftime(&tend);\r\ni=(long)tend.millitm-(long)tstart.millitm;\r\nret=((double)(tend.time-tstart.time))+((double)i)/1000.0;\r\nreturn((ret < 0.001)?0.001:ret);\r\n}\r\n#endif\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nBN_CTX *ctx;\r\nBIGNUM a,b,c;\r\nctx=BN_CTX_new();\r\nBN_init(&a);\r\nBN_init(&b);\r\nBN_init(&c);\r\ndo_mul(&a,&b,&c,ctx);\r\n}\r\nvoid do_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)\r\n{\r\nint i,j,k;\r\ndouble tm;\r\nlong num;\r\nfor (i=0; i<NUM_SIZES; i++)\r\n{\r\nnum=BASENUM;\r\nif (i) num/=(i*3);\r\nBN_rand(a,sizes[i],1,0);\r\nfor (j=i; j<NUM_SIZES; j++)\r\n{\r\nBN_rand(b,sizes[j],1,0);\r\nTime_F(START);\r\nfor (k=0; k<num; k++)\r\nBN_mul(r,b,a,ctx);\r\ntm=Time_F(STOP);\r\nprintf("mul %4d x %4d -> %8.3fms\n",sizes[i],sizes[j],tm*1000.0/num);\r\n}\r\n}\r\nfor (i=0; i<NUM_SIZES; i++)\r\n{\r\nnum=BASENUM;\r\nif (i) num/=(i*3);\r\nBN_rand(a,sizes[i],1,0);\r\nTime_F(START);\r\nfor (k=0; k<num; k++)\r\nBN_sqr(r,a,ctx);\r\ntm=Time_F(STOP);\r\nprintf("sqr %4d x %4d -> %8.3fms\n",sizes[i],sizes[i],tm*1000.0/num);\r\n}\r\nfor (i=0; i<NUM_SIZES; i++)\r\n{\r\nnum=BASENUM/10;\r\nif (i) num/=(i*3);\r\nBN_rand(a,sizes[i]-1,1,0);\r\nfor (j=i; j<NUM_SIZES; j++)\r\n{\r\nBN_rand(b,sizes[j],1,0);\r\nTime_F(START);\r\nfor (k=0; k<100000; k++)\r\nBN_div(r, NULL, b, a,ctx);\r\ntm=Time_F(STOP);\r\nprintf("div %4d / %4d -> %8.3fms\n",sizes[j],sizes[i]-1,tm*1000.0/num);\r\n}\r\n}\r\n}
