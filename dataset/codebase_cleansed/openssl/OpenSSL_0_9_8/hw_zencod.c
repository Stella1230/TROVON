static inline void esrever ( unsigned char *d, int l )\r\n{\r\nfor(;--l>0;--l,d++){*d^=*(d+l);*(d+l)^=*d;*d^=*(d+l);}\r\n}\r\nstatic inline void ypcmem ( unsigned char *d, const unsigned char *s, int l )\r\n{\r\nfor(d+=l;l--;)*--d=*s++;\r\n}\r\nstatic __inline void esrever ( unsigned char *d, int l )\r\n{\r\nfor(;--l>0;--l,d++){*d^=*(d+l);*(d+l)^=*d;*d^=*(d+l);}\r\n}\r\nstatic __inline void ypcmem ( unsigned char *d, const unsigned char *s, int l )\r\n{\r\nfor(d+=l;l--;)*--d=*s++;\r\n}\r\nstatic int bind_helper ( ENGINE *e )\r\n{\r\n#ifndef OPENSSL_NO_RSA\r\nconst RSA_METHOD *meth_rsa ;\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\nconst DSA_METHOD *meth_dsa ;\r\n#endif\r\n#ifndef OPENSSL_NO_DH\r\nconst DH_METHOD *meth_dh ;\r\n#endif\r\nconst RAND_METHOD *meth_rand ;\r\nif ( !ENGINE_set_id ( e, engine_zencod_id ) ||\r\n!ENGINE_set_name ( e, engine_zencod_name ) ||\r\n#ifndef OPENSSL_NO_RSA\r\n!ENGINE_set_RSA ( e, &zencod_rsa ) ||\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\n!ENGINE_set_DSA ( e, &zencod_dsa ) ||\r\n#endif\r\n#ifndef OPENSSL_NO_DH\r\n!ENGINE_set_DH ( e, &zencod_dh ) ||\r\n#endif\r\n!ENGINE_set_RAND ( e, &zencod_rand ) ||\r\n!ENGINE_set_destroy_function ( e, zencod_destroy ) ||\r\n!ENGINE_set_init_function ( e, zencod_init ) ||\r\n!ENGINE_set_finish_function ( e, zencod_finish ) ||\r\n!ENGINE_set_ctrl_function ( e, zencod_ctrl ) ||\r\n!ENGINE_set_cmd_defns ( e, zencod_cmd_defns ) ||\r\n!ENGINE_set_digests ( e, engine_digests ) ||\r\n!ENGINE_set_ciphers ( e, engine_ciphers ) ) {\r\nreturn 0 ;\r\n}\r\n#ifndef OPENSSL_NO_RSA\r\nmeth_rsa = RSA_PKCS1_SSLeay () ;\r\nzencod_rsa.rsa_pub_enc = meth_rsa->rsa_pub_enc ;\r\nzencod_rsa.rsa_pub_dec = meth_rsa->rsa_pub_dec ;\r\nzencod_rsa.rsa_priv_enc = meth_rsa->rsa_priv_enc ;\r\nzencod_rsa.rsa_priv_dec = meth_rsa->rsa_priv_dec ;\r\nzencod_rsa.init = meth_rsa->init ;\r\nzencod_rsa.finish = meth_rsa->finish ;\r\n#endif\r\n#ifndef OPENSSL_NO_DSA\r\nmeth_dsa = DSA_OpenSSL () ;\r\nzencod_dsa.dsa_sign_setup = meth_dsa->dsa_sign_setup ;\r\nzencod_dsa.dsa_mod_exp = meth_dsa->dsa_mod_exp ;\r\nzencod_dsa.init = meth_dsa->init ;\r\nzencod_dsa.finish = meth_dsa->finish ;\r\n#endif\r\n#ifndef OPENSSL_NO_DH\r\nmeth_dh = DH_OpenSSL () ;\r\nzencod_dh.init = meth_dh->init ;\r\nzencod_dh.finish = meth_dh->finish ;\r\n#endif\r\nmeth_rand = RAND_SSLeay () ;\r\nzencod_rand.cleanup = meth_rand->cleanup ;\r\nzencod_rand.add = meth_rand->add ;\r\nERR_load_ZENCOD_strings () ;\r\nreturn 1 ;\r\n}\r\nstatic ENGINE *ENGINE_zencod ( void )\r\n{\r\nENGINE *eng = ENGINE_new () ;\r\nif ( !eng ) {\r\nreturn NULL ;\r\n}\r\nif ( !bind_helper ( eng ) ) {\r\nENGINE_free ( eng ) ;\r\nreturn NULL ;\r\n}\r\nreturn eng ;\r\n}\r\nstatic\r\n#endif\r\nvoid ENGINE_load_zencod ( void )\r\n{\r\nENGINE *toadd = ENGINE_zencod ( ) ;\r\nif ( !toadd ) return ;\r\nENGINE_add ( toadd ) ;\r\nENGINE_free ( toadd ) ;\r\nERR_clear_error ( ) ;\r\n}\r\nstatic int zencod_destroy (ENGINE *e )\r\n{\r\nERR_unload_ZENCOD_strings () ;\r\nreturn 1 ;\r\n}\r\nstatic int zencod_init ( ENGINE *e )\r\n{\r\nt_zencod_test *ptr_0 ;\r\nt_zencod_bytes2bits *ptr_1 ;\r\nt_zencod_bits2bytes *ptr_2 ;\r\nt_zencod_new_number *ptr_3 ;\r\nt_zencod_init_number *ptr_4 ;\r\nt_zencod_rsa_mod_exp *ptr_exp_1 ;\r\nt_zencod_rsa_mod_exp_crt *ptr_exp_2 ;\r\nt_zencod_dsa_do_sign *ptr_dsa_1 ;\r\nt_zencod_dsa_do_verify *ptr_dsa_2 ;\r\nt_zencod_dh_generate_key *ptr_dh_1 ;\r\nt_zencod_dh_compute_key *ptr_dh_2 ;\r\nt_zencod_rand_bytes *ptr_rand_1 ;\r\nt_zencod_math_mod_exp *ptr_math_1 ;\r\nt_zencod_md5_init *ptr_md5_1 ;\r\nt_zencod_md5_update *ptr_md5_2 ;\r\nt_zencod_md5_do_final *ptr_md5_3 ;\r\nt_zencod_sha1_init *ptr_sha1_1 ;\r\nt_zencod_sha1_update *ptr_sha1_2 ;\r\nt_zencod_sha1_do_final *ptr_sha1_3 ;\r\nt_zencod_xdes_cipher *ptr_xdes_1 ;\r\nt_zencod_rc4_cipher *ptr_rc4_1 ;\r\nCHEESE () ;\r\nif ( zencod_dso != NULL ) {\r\nZENCODerr ( ZENCOD_F_ZENCOD_INIT, ZENCOD_R_ALREADY_LOADED ) ;\r\ngoto err ;\r\n}\r\nzencod_dso = DSO_load ( NULL, ZENCOD_LIBNAME, NULL, 0 ) ;\r\nif ( zencod_dso == NULL ) {\r\nZENCODerr ( ZENCOD_F_ZENCOD_INIT, ZENCOD_R_DSO_FAILURE ) ;\r\ngoto err ;\r\n}\r\nif ( ! ( ptr_1 = (t_zencod_bytes2bits*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_1 ) ) ||\r\n! ( ptr_2 = (t_zencod_bits2bytes*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_2 ) ) ||\r\n! ( ptr_3 = (t_zencod_new_number*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_3 ) ) ||\r\n! ( ptr_4 = (t_zencod_init_number*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_4 ) ) ||\r\n! ( ptr_exp_1 = (t_zencod_rsa_mod_exp*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_exp_1 ) ) ||\r\n! ( ptr_exp_2 = (t_zencod_rsa_mod_exp_crt*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_exp_2 ) ) ||\r\n! ( ptr_dsa_1 = (t_zencod_dsa_do_sign*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_dsa_1 ) ) ||\r\n! ( ptr_dsa_2 = (t_zencod_dsa_do_verify*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_dsa_2 ) ) ||\r\n! ( ptr_dh_1 = (t_zencod_dh_generate_key*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_dh_1 ) ) ||\r\n! ( ptr_dh_2 = (t_zencod_dh_compute_key*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_dh_2 ) ) ||\r\n! ( ptr_rand_1 = (t_zencod_rand_bytes*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_rand_1 ) ) ||\r\n! ( ptr_math_1 = (t_zencod_math_mod_exp*) DSO_bind_func ( zencod_dso, ZENCOD_Fct_math_1 ) ) ||\r\n! ( ptr_0 = (t_zencod_test *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_0 ) ) ||\r\n! ( ptr_md5_1 = (t_zencod_md5_init *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_md5_1 ) ) ||\r\n! ( ptr_md5_2 = (t_zencod_md5_update *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_md5_2 ) ) ||\r\n! ( ptr_md5_3 = (t_zencod_md5_do_final *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_md5_3 ) ) ||\r\n! ( ptr_sha1_1 = (t_zencod_sha1_init *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_sha1_1 ) ) ||\r\n! ( ptr_sha1_2 = (t_zencod_sha1_update *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_sha1_2 ) ) ||\r\n! ( ptr_sha1_3 = (t_zencod_sha1_do_final *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_sha1_3 ) ) ||\r\n! ( ptr_xdes_1 = (t_zencod_xdes_cipher *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_xdes_1 ) ) ||\r\n! ( ptr_rc4_1 = (t_zencod_rc4_cipher *) DSO_bind_func ( zencod_dso, ZENCOD_Fct_rc4_1 ) ) ) {\r\nZENCODerr ( ZENCOD_F_ZENCOD_INIT, ZENCOD_R_DSO_FAILURE ) ;\r\ngoto err ;\r\n}\r\nptr_zencod_test = ptr_0 ;\r\nptr_zencod_bytes2bits = ptr_1 ;\r\nptr_zencod_bits2bytes = ptr_2 ;\r\nptr_zencod_new_number = ptr_3 ;\r\nptr_zencod_init_number = ptr_4 ;\r\nptr_zencod_rsa_mod_exp = ptr_exp_1 ;\r\nptr_zencod_rsa_mod_exp_crt = ptr_exp_2 ;\r\nptr_zencod_dsa_do_sign = ptr_dsa_1 ;\r\nptr_zencod_dsa_do_verify = ptr_dsa_2 ;\r\nptr_zencod_dh_generate_key = ptr_dh_1 ;\r\nptr_zencod_dh_compute_key = ptr_dh_2 ;\r\nptr_zencod_rand_bytes = ptr_rand_1 ;\r\nptr_zencod_math_mod_exp = ptr_math_1 ;\r\nptr_zencod_test = ptr_0 ;\r\nptr_zencod_md5_init = ptr_md5_1 ;\r\nptr_zencod_md5_update = ptr_md5_2 ;\r\nptr_zencod_md5_do_final = ptr_md5_3 ;\r\nptr_zencod_sha1_init = ptr_sha1_1 ;\r\nptr_zencod_sha1_update = ptr_sha1_2 ;\r\nptr_zencod_sha1_do_final = ptr_sha1_3 ;\r\nptr_zencod_xdes_cipher = ptr_xdes_1 ;\r\nptr_zencod_rc4_cipher = ptr_rc4_1 ;\r\nif ( ptr_zencod_test () != 0 ) {\r\nZENCODerr ( ZENCOD_F_ZENCOD_INIT, ZENCOD_R_UNIT_FAILURE ) ;\r\ngoto err ;\r\n}\r\nreturn 1 ;\r\nerr :\r\nif ( zencod_dso ) {\r\nDSO_free ( zencod_dso ) ;\r\n}\r\nzencod_dso = NULL ;\r\nptr_zencod_bytes2bits = NULL ;\r\nptr_zencod_bits2bytes = NULL ;\r\nptr_zencod_new_number = NULL ;\r\nptr_zencod_init_number = NULL ;\r\nptr_zencod_rsa_mod_exp = NULL ;\r\nptr_zencod_rsa_mod_exp_crt = NULL ;\r\nptr_zencod_dsa_do_sign = NULL ;\r\nptr_zencod_dsa_do_verify = NULL ;\r\nptr_zencod_dh_generate_key = NULL ;\r\nptr_zencod_dh_compute_key = NULL ;\r\nptr_zencod_rand_bytes = NULL ;\r\nptr_zencod_math_mod_exp = NULL ;\r\nptr_zencod_test = NULL ;\r\nptr_zencod_md5_init = NULL ;\r\nptr_zencod_md5_update = NULL ;\r\nptr_zencod_md5_do_final = NULL ;\r\nptr_zencod_sha1_init = NULL ;\r\nptr_zencod_sha1_update = NULL ;\r\nptr_zencod_sha1_do_final = NULL ;\r\nptr_zencod_xdes_cipher = NULL ;\r\nptr_zencod_rc4_cipher = NULL ;\r\nreturn 0 ;\r\n}\r\nstatic int zencod_finish ( ENGINE *e )\r\n{\r\nCHEESE () ;\r\nif ( zencod_dso == NULL ) {\r\nZENCODerr ( ZENCOD_F_ZENCOD_FINISH, ZENCOD_R_NOT_LOADED ) ;\r\nreturn 0 ;\r\n}\r\nif ( !DSO_free ( zencod_dso ) ) {\r\nZENCODerr ( ZENCOD_F_ZENCOD_FINISH, ZENCOD_R_DSO_FAILURE ) ;\r\nreturn 0 ;\r\n}\r\nzencod_dso = NULL ;\r\nptr_zencod_bytes2bits = NULL ;\r\nptr_zencod_bits2bytes = NULL ;\r\nptr_zencod_new_number = NULL ;\r\nptr_zencod_init_number = NULL ;\r\nptr_zencod_rsa_mod_exp = NULL ;\r\nptr_zencod_rsa_mod_exp_crt = NULL ;\r\nptr_zencod_dsa_do_sign = NULL ;\r\nptr_zencod_dsa_do_verify = NULL ;\r\nptr_zencod_dh_generate_key = NULL ;\r\nptr_zencod_dh_compute_key = NULL ;\r\nptr_zencod_rand_bytes = NULL ;\r\nptr_zencod_math_mod_exp = NULL ;\r\nptr_zencod_test = NULL ;\r\nptr_zencod_md5_init = NULL ;\r\nptr_zencod_md5_update = NULL ;\r\nptr_zencod_md5_do_final = NULL ;\r\nptr_zencod_sha1_init = NULL ;\r\nptr_zencod_sha1_update = NULL ;\r\nptr_zencod_sha1_do_final = NULL ;\r\nptr_zencod_xdes_cipher = NULL ;\r\nptr_zencod_rc4_cipher = NULL ;\r\nreturn 1 ;\r\n}\r\nstatic int zencod_ctrl ( ENGINE *e, int cmd, long i, void *p, void (*f) () )\r\n{\r\nint initialised = ( ( zencod_dso == NULL ) ? 0 : 1 ) ;\r\nCHEESE () ;\r\nswitch ( cmd ) {\r\ncase ZENCOD_CMD_SO_PATH :\r\nif ( p == NULL ) {\r\nZENCODerr ( ZENCOD_F_ZENCOD_CTRL, ERR_R_PASSED_NULL_PARAMETER ) ;\r\nreturn 0 ;\r\n}\r\nif ( initialised ) {\r\nZENCODerr ( ZENCOD_F_ZENCOD_CTRL, ZENCOD_R_ALREADY_LOADED ) ;\r\nreturn 0 ;\r\n}\r\nZENCOD_LIBNAME = (const char *) p ;\r\nreturn 1 ;\r\ndefault :\r\nbreak ;\r\n}\r\nZENCODerr ( ZENCOD_F_ZENCOD_CTRL, ZENCOD_R_CTRL_COMMAND_NOT_IMPLEMENTED ) ;\r\nreturn 0 ;\r\n}\r\nstatic int zencod_bn_mod_exp ( BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx )\r\n{\r\nzen_nb_t y, x, e, n;\r\nint ret;\r\nCHEESE () ;\r\nif ( !zencod_dso ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_BN_MOD_EXP, ZENCOD_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\nif ( !bn_wexpand(r, m->top + 1) ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_BN_MOD_EXP, ZENCOD_R_BN_EXPAND_FAIL);\r\nreturn 0;\r\n}\r\nmemset(r->d, 0, BN_num_bytes(m));\r\nptr_zencod_init_number ( &y, (r->dmax - 1) * sizeof (BN_ULONG) * 8, (unsigned char *) r->d ) ;\r\nBIGNUM2ZEN ( &x, a ) ;\r\nBIGNUM2ZEN ( &e, p ) ;\r\nBIGNUM2ZEN ( &n, m ) ;\r\nret = ptr_zencod_math_mod_exp ( &y, &e, &x, &n ) ;\r\nif ( ret ) {\r\nPERROR("zenbridge_math_mod_exp");\r\nENGINEerr(ZENCOD_F_ZENCOD_BN_MOD_EXP, ZENCOD_R_REQUEST_FAILED);\r\nreturn 0;\r\n}\r\nr->top = (BN_num_bits(m) + BN_BITS2 - 1) / BN_BITS2;\r\nreturn 1;\r\n}\r\nstatic int RSA_zencod_rsa_mod_exp ( BIGNUM *r0, const BIGNUM *i, RSA *rsa )\r\n{\r\nCHEESE () ;\r\nif ( !zencod_dso ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, ZENCOD_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\nif ( !rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, ZENCOD_R_BAD_KEY_COMPONENTS);\r\nreturn 0;\r\n}\r\nif ( RSA_size(rsa) * 8 > ZENBRIDGE_MAX_KEYSIZE_RSA_CRT ) {\r\nconst RSA_METHOD *meth;\r\nmeth = RSA_PKCS1_SSLeay();\r\nreturn meth->rsa_mod_exp(r0, i, rsa);\r\n} else {\r\nzen_nb_t y, x, p, q, dmp1, dmq1, iqmp;\r\nif ( !bn_expand(r0, RSA_size(rsa) * 8) ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, ZENCOD_R_BN_EXPAND_FAIL);\r\nreturn 0;\r\n}\r\nr0->top = (RSA_size(rsa) * 8 + BN_BITS2 - 1) / BN_BITS2;\r\nBIGNUM2ZEN ( &x, i ) ;\r\nBIGNUM2ZEN ( &y, r0 ) ;\r\nBIGNUM2ZEN ( &p, rsa->p ) ;\r\nBIGNUM2ZEN ( &q, rsa->q ) ;\r\nBIGNUM2ZEN ( &dmp1, rsa->dmp1 ) ;\r\nBIGNUM2ZEN ( &dmq1, rsa->dmq1 ) ;\r\nBIGNUM2ZEN ( &iqmp, rsa->iqmp ) ;\r\nif ( ptr_zencod_rsa_mod_exp_crt ( &y, &x, &p, &q, &dmp1, &dmq1, &iqmp ) < 0 ) {\r\nPERROR("zenbridge_rsa_mod_exp_crt");\r\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP_CRT, ZENCOD_R_REQUEST_FAILED);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\n}\r\nstatic int RSA_zencod_bn_mod_exp ( BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\r\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx )\r\n{\r\nCHEESE () ;\r\nif ( !zencod_dso ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP, ZENCOD_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\nif ( BN_num_bits(m) > ZENBRIDGE_MAX_KEYSIZE_RSA ) {\r\nconst RSA_METHOD *meth;\r\nmeth = RSA_PKCS1_SSLeay();\r\nreturn meth->bn_mod_exp(r, a, p, m, ctx, m_ctx);\r\n} else {\r\nzen_nb_t y, x, e, n;\r\nif ( !bn_expand(r, BN_num_bits(m)) ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP, ZENCOD_R_BN_EXPAND_FAIL);\r\nreturn 0;\r\n}\r\nr->top = (BN_num_bits(m) + BN_BITS2 - 1) / BN_BITS2;\r\nBIGNUM2ZEN ( &x, a ) ;\r\nBIGNUM2ZEN ( &y, r ) ;\r\nBIGNUM2ZEN ( &e, p ) ;\r\nBIGNUM2ZEN ( &n, m ) ;\r\nif ( ptr_zencod_rsa_mod_exp ( &y, &x, &n, &e ) < 0 ) {\r\nPERROR("zenbridge_rsa_mod_exp");\r\nENGINEerr(ZENCOD_F_ZENCOD_RSA_MOD_EXP, ZENCOD_R_REQUEST_FAILED);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\n}\r\nstatic DSA_SIG *DSA_zencod_do_sign ( const unsigned char *dgst, int dlen, DSA *dsa )\r\n{\r\nzen_nb_t p, q, g, x, y, r, s, data;\r\nDSA_SIG *sig;\r\nBIGNUM *bn_r = NULL;\r\nBIGNUM *bn_s = NULL;\r\nchar msg[20];\r\nCHEESE();\r\nif ( !zencod_dso ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_NOT_LOADED);\r\ngoto FAILED;\r\n}\r\nif ( dlen > 160 ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);\r\ngoto FAILED;\r\n}\r\nif ( BN_num_bits(dsa->p) > ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ||\r\nBN_num_bits(dsa->g) > ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ) {\r\nconst DSA_METHOD *meth;\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BAD_KEY_COMPONENTS);\r\nmeth = DSA_OpenSSL();\r\nreturn meth->dsa_do_sign(dgst, dlen, dsa);\r\n}\r\nif ( !(bn_s = BN_new()) || !(bn_r = BN_new()) ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BAD_KEY_COMPONENTS);\r\ngoto FAILED;\r\n}\r\nif ( !bn_expand(bn_r, 160) || !bn_expand(bn_s, 160) ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BN_EXPAND_FAIL);\r\ngoto FAILED;\r\n}\r\nbn_r->top = bn_s->top = (160 + BN_BITS2 - 1) / BN_BITS2;\r\nBIGNUM2ZEN ( &p, dsa->p ) ;\r\nBIGNUM2ZEN ( &q, dsa->q ) ;\r\nBIGNUM2ZEN ( &g, dsa->g ) ;\r\nBIGNUM2ZEN ( &x, dsa->priv_key ) ;\r\nBIGNUM2ZEN ( &y, dsa->pub_key ) ;\r\nBIGNUM2ZEN ( &r, bn_r ) ;\r\nBIGNUM2ZEN ( &s, bn_s ) ;\r\nq.len = x.len = 160;\r\nypcmem(msg, dgst, 20);\r\nptr_zencod_init_number ( &data, 160, msg ) ;\r\nif ( ptr_zencod_dsa_do_sign ( 0, &data, &y, &p, &q, &g, &x, &r, &s ) < 0 ) {\r\nPERROR("zenbridge_dsa_do_sign");\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);\r\ngoto FAILED;\r\n}\r\nif ( !( sig = DSA_SIG_new () ) ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);\r\ngoto FAILED;\r\n}\r\nsig->r = bn_r;\r\nsig->s = bn_s;\r\nreturn sig;\r\nFAILED:\r\nif (bn_r)\r\nBN_free(bn_r);\r\nif (bn_s)\r\nBN_free(bn_s);\r\nreturn NULL;\r\n}\r\nstatic int DSA_zencod_do_verify ( const unsigned char *dgst, int dlen, DSA_SIG *sig, DSA *dsa )\r\n{\r\nzen_nb_t data, p, q, g, y, r, s, v;\r\nchar msg[20];\r\nchar v_data[20];\r\nint ret;\r\nCHEESE();\r\nif ( !zencod_dso ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_VERIFY, ZENCOD_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\nif ( dlen > 160 ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_REQUEST_FAILED);\r\nreturn 0;\r\n}\r\nif ( BN_num_bits(dsa->p) > ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ||\r\nBN_num_bits(dsa->g) > ZENBRIDGE_MAX_KEYSIZE_DSA_SIGN ) {\r\nconst DSA_METHOD *meth;\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_SIGN, ZENCOD_R_BAD_KEY_COMPONENTS);\r\nmeth = DSA_OpenSSL();\r\nreturn meth->dsa_do_verify(dgst, dlen, sig, dsa);\r\n}\r\nBIGNUM2ZEN ( &p, dsa->p ) ;\r\nBIGNUM2ZEN ( &q, dsa->q ) ;\r\nBIGNUM2ZEN ( &g, dsa->g ) ;\r\nBIGNUM2ZEN ( &y, dsa->pub_key ) ;\r\nBIGNUM2ZEN ( &r, sig->r ) ;\r\nBIGNUM2ZEN ( &s, sig->s ) ;\r\nptr_zencod_init_number ( &v, 160, v_data ) ;\r\nypcmem(msg, dgst, 20);\r\nptr_zencod_init_number ( &data, 160, msg ) ;\r\nif ( ( ret = ptr_zencod_dsa_do_verify ( 0, &data, &p, &q, &g, &y, &r, &s, &v ) ) < 0 ) {\r\nPERROR("zenbridge_dsa_do_verify");\r\nENGINEerr(ZENCOD_F_ZENCOD_DSA_DO_VERIFY, ZENCOD_R_REQUEST_FAILED);\r\nreturn 0;\r\n}\r\nreturn ( ( ret == 0 ) ? 1 : ret ) ;\r\n}\r\nstatic int DSA_zencod_bn_mod_exp ( DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p, const BIGNUM *m,\r\nBN_CTX *ctx, BN_MONT_CTX *m_ctx )\r\n{\r\nCHEESE () ;\r\nreturn zencod_bn_mod_exp ( r, a, p, m, ctx ) ;\r\n}\r\nstatic int DH_zencod_generate_key ( DH *dh )\r\n{\r\nBIGNUM *bn_prv = NULL;\r\nBIGNUM *bn_pub = NULL;\r\nzen_nb_t y, x, g, p;\r\nint generate_x;\r\nCHEESE();\r\nif ( !zencod_dso ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\nif ( dh->priv_key ) {\r\nbn_prv = dh->priv_key;\r\ngenerate_x = 0;\r\n} else {\r\nif (!(bn_prv = BN_new())) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_BN_EXPAND_FAIL);\r\ngoto FAILED;\r\n}\r\ngenerate_x = 1;\r\n}\r\nif ( dh->pub_key )\r\nbn_pub = dh->pub_key;\r\nelse\r\nif ( !( bn_pub = BN_new () ) ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_BN_EXPAND_FAIL);\r\ngoto FAILED;\r\n}\r\nif ( !bn_wexpand ( bn_prv, dh->p->dmax ) ||\r\n!bn_wexpand ( bn_pub, dh->p->dmax ) ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_BN_EXPAND_FAIL);\r\ngoto FAILED;\r\n}\r\nbn_prv->top = dh->p->top;\r\nbn_pub->top = dh->p->top;\r\nBIGNUM2ZEN ( &p, dh->p ) ;\r\nBIGNUM2ZEN ( &g, dh->g ) ;\r\nBIGNUM2ZEN ( &y, bn_pub ) ;\r\nBIGNUM2ZEN ( &x, bn_prv ) ;\r\nx.len = DH_size(dh) * 8;\r\np.len = ptr_zencod_bytes2bits ( p.data, ZEN_BYTES ( p.len ) ) ;\r\ng.len = ptr_zencod_bytes2bits ( g.data, ZEN_BYTES ( g.len ) ) ;\r\nif ( ptr_zencod_dh_generate_key ( &y, &x, &g, &p, generate_x ) < 0 ) {\r\nperror("zenbridge_dh_generate_key");\r\nENGINEerr(ZENCOD_F_ZENCOD_DH_GENERATE, ZENCOD_R_REQUEST_FAILED);\r\ngoto FAILED;\r\n}\r\ndh->priv_key = bn_prv;\r\ndh->pub_key = bn_pub;\r\nreturn 1;\r\nFAILED:\r\nif (!dh->priv_key && bn_prv)\r\nBN_free(bn_prv);\r\nif (!dh->pub_key && bn_pub)\r\nBN_free(bn_pub);\r\nreturn 0;\r\n}\r\nstatic int DH_zencod_compute_key ( unsigned char *key, const BIGNUM *pub_key, DH *dh )\r\n{\r\nzen_nb_t y, x, p, k;\r\nCHEESE();\r\nif ( !zencod_dso ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DH_COMPUTE, ZENCOD_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\nif ( !dh->priv_key ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DH_COMPUTE, ZENCOD_R_BAD_KEY_COMPONENTS);\r\nreturn 0;\r\n}\r\nBIGNUM2ZEN ( &y, pub_key ) ;\r\nBIGNUM2ZEN ( &x, dh->priv_key ) ;\r\nBIGNUM2ZEN ( &p, dh->p ) ;\r\nptr_zencod_init_number ( &k, p.len, key ) ;\r\np.len = ptr_zencod_bytes2bits ( p.data, ZEN_BYTES ( p.len ) ) ;\r\ny.len = ptr_zencod_bytes2bits ( y.data, ZEN_BYTES ( y.len ) ) ;\r\nx.len = ptr_zencod_bytes2bits ( x.data, ZEN_BYTES ( x.len ) ) ;\r\nif ( ptr_zencod_dh_compute_key ( &k, &y, &x, &p ) < 0 ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_DH_COMPUTE, ZENCOD_R_REQUEST_FAILED);\r\nreturn 0;\r\n}\r\nk.len = ptr_zencod_bytes2bits ( k.data, ZEN_BYTES ( k.len ) ) ;\r\nesrever ( key, ZEN_BYTES ( k.len ) ) ;\r\nreturn ZEN_BYTES ( k.len ) ;\r\n}\r\nstatic int DH_zencod_bn_mod_exp ( const DH *dh, BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\r\nBN_MONT_CTX *m_ctx )\r\n{\r\nCHEESE () ;\r\nreturn zencod_bn_mod_exp ( r, a, p, m, ctx ) ;\r\n}\r\nstatic void RAND_zencod_seed ( const void *buf, int num )\r\n{\r\n}\r\nstatic int RAND_zencod_rand_bytes ( unsigned char *buf, int num )\r\n{\r\nzen_nb_t r;\r\nCHEESE();\r\nif ( !zencod_dso ) {\r\nENGINEerr(ZENCOD_F_ZENCOD_RAND, ZENCOD_R_NOT_LOADED);\r\nreturn 0;\r\n}\r\nptr_zencod_init_number ( &r, num * 8, buf ) ;\r\nif ( ptr_zencod_rand_bytes ( &r, ZENBRIDGE_RNG_DIRECT ) < 0 ) {\r\nPERROR("zenbridge_rand_bytes");\r\nENGINEerr(ZENCOD_F_ZENCOD_RAND, ZENCOD_R_REQUEST_FAILED);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int RAND_zencod_rand_status ( void )\r\n{\r\nCHEESE () ;\r\nreturn 1;\r\n}\r\nstatic int bind_fn ( ENGINE *e, const char *id )\r\n{\r\nif ( id && ( strcmp ( id, engine_zencod_id ) != 0 ) ) {\r\nreturn 0 ;\r\n}\r\nif ( !bind_helper ( e ) ) {\r\nreturn 0 ;\r\n}\r\nreturn 1 ;\r\n}\r\nstatic int engine_digests ( ENGINE *e, const EVP_MD **digest, const int **nids, int nid )\r\n{\r\n#ifdef DEBUG_ZENCOD_MD\r\nfprintf ( stderr, "\t=>Function : static int engine_digests () called !\n" ) ;\r\n#endif\r\nif ( !digest ) {\r\n*nids = engine_digest_nids ;\r\nreturn engine_digest_nids_num ;\r\n}\r\nif ( nid == NID_md5 ) {\r\n*digest = &engine_md5_md ;\r\n}\r\nelse if ( nid == NID_sha1 ) {\r\n*digest = &engine_sha1_md ;\r\n}\r\nelse {\r\n*digest = NULL ;\r\nreturn 0 ;\r\n}\r\nreturn 1 ;\r\n}\r\nstatic int engine_sha1_init ( EVP_MD_CTX *ctx )\r\n{\r\nint to_return = 0 ;\r\nto_return = ptr_zencod_sha1_init ( (ZEN_MD_DATA *) ctx->md_data ) ;\r\nto_return = !to_return ;\r\nreturn to_return ;\r\n}\r\nstatic int engine_sha1_update ( EVP_MD_CTX *ctx, const void *data, unsigned long count )\r\n{\r\nzen_nb_t input ;\r\nint to_return = 0 ;\r\ninput.len = count ;\r\ninput.data = (unsigned char *) data ;\r\nto_return = ptr_zencod_sha1_update ( (ZEN_MD_DATA *) ctx->md_data, (const zen_nb_t *) &input ) ;\r\nto_return = !to_return ;\r\nreturn to_return ;\r\n}\r\nstatic int engine_sha1_final ( EVP_MD_CTX *ctx, unsigned char *md )\r\n{\r\nzen_nb_t output ;\r\nint to_return = 0 ;\r\noutput.len = SHA_DIGEST_LENGTH ;\r\noutput.data = md ;\r\nto_return = ptr_zencod_sha1_do_final ( (ZEN_MD_DATA *) ctx->md_data, (zen_nb_t *) &output ) ;\r\nto_return = !to_return ;\r\nreturn to_return ;\r\n}\r\nstatic int engine_md5_init ( EVP_MD_CTX *ctx )\r\n{\r\nint to_return = 0 ;\r\nto_return = ptr_zencod_md5_init ( (ZEN_MD_DATA *) ctx->md_data ) ;\r\nto_return = !to_return ;\r\nreturn to_return ;\r\n}\r\nstatic int engine_md5_update ( EVP_MD_CTX *ctx, const void *data, unsigned long count )\r\n{\r\nzen_nb_t input ;\r\nint to_return = 0 ;\r\ninput.len = count ;\r\ninput.data = (unsigned char *) data ;\r\nto_return = ptr_zencod_md5_update ( (ZEN_MD_DATA *) ctx->md_data, (const zen_nb_t *) &input ) ;\r\nto_return = !to_return ;\r\nreturn to_return ;\r\n}\r\nstatic int engine_md5_final ( EVP_MD_CTX *ctx, unsigned char *md )\r\n{\r\nzen_nb_t output ;\r\nint to_return = 0 ;\r\noutput.len = MD5_DIGEST_LENGTH ;\r\noutput.data = md ;\r\nto_return = ptr_zencod_md5_do_final ( (ZEN_MD_DATA *) ctx->md_data, (zen_nb_t *) &output ) ;\r\nto_return = !to_return ;\r\nreturn to_return ;\r\n}\r\nstatic int engine_md_cleanup ( EVP_MD_CTX *ctx )\r\n{\r\nZEN_MD_DATA *zen_md_data = (ZEN_MD_DATA *) ctx->md_data ;\r\nif ( zen_md_data->HashBuffer != NULL ) {\r\nOPENSSL_free ( zen_md_data->HashBuffer ) ;\r\nzen_md_data->HashBufferSize = 0 ;\r\nctx->md_data = NULL ;\r\n}\r\nreturn 1 ;\r\n}\r\nstatic int engine_md_copy ( EVP_MD_CTX *to, const EVP_MD_CTX *from )\r\n{\r\nconst ZEN_MD_DATA *from_md = (ZEN_MD_DATA *) from->md_data ;\r\nZEN_MD_DATA *to_md = (ZEN_MD_DATA *) to->md_data ;\r\nto_md->HashBuffer = OPENSSL_malloc ( from_md->HashBufferSize ) ;\r\nmemcpy ( to_md->HashBuffer, from_md->HashBuffer, from_md->HashBufferSize ) ;\r\nreturn 1;\r\n}\r\nstatic int engine_ciphers ( ENGINE *e, const EVP_CIPHER **cipher, const int **nids, int nid )\r\n{\r\nif ( !cipher ) {\r\n*nids = engine_cipher_nids ;\r\nreturn engine_cipher_nids_num ;\r\n}\r\nif ( nid == NID_rc4 ) {\r\n*cipher = &engine_rc4 ;\r\n}\r\nelse if ( nid == NID_rc4_40 ) {\r\n*cipher = &engine_rc4_40 ;\r\n}\r\nelse if ( nid == NID_des_cbc ) {\r\n*cipher = &engine_des_cbc ;\r\n}\r\nelse if ( nid == NID_des_ede3_cbc ) {\r\n*cipher = &engine_des_ede3_cbc ;\r\n}\r\nelse {\r\n*cipher = NULL ;\r\nreturn 0 ;\r\n}\r\nreturn 1 ;\r\n}\r\nstatic int engine_rc4_init_key ( EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc )\r\n{\r\nint to_return = 0 ;\r\nint i = 0 ;\r\nint nb = 0 ;\r\nNEW_ZEN_RC4_KEY *tmp_rc4_key = NULL ;\r\ntmp_rc4_key = (NEW_ZEN_RC4_KEY *) ( ctx->cipher_data ) ;\r\ntmp_rc4_key->first = 0 ;\r\ntmp_rc4_key->len = ctx->key_len ;\r\ntmp_rc4_key->rc4_state [ 0 ] = 0x00 ;\r\ntmp_rc4_key->rc4_state [ 2 ] = 0x00 ;\r\nnb = 256 / ctx->key_len ;\r\nfor ( i = 0; i < nb ; i++ ) {\r\nmemcpy ( &( tmp_rc4_key->rc4_state [ 4 + i*ctx->key_len ] ), key, ctx->key_len ) ;\r\n}\r\nto_return = 1 ;\r\nreturn to_return ;\r\n}\r\nstatic int engine_rc4_cipher ( EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int in_len )\r\n{\r\nzen_nb_t output, input ;\r\nzen_nb_t rc4key ;\r\nint to_return = 0 ;\r\nNEW_ZEN_RC4_KEY *tmp_rc4_key = NULL ;\r\ninput.len = in_len ;\r\ninput.data = (unsigned char *) in ;\r\noutput.len = in_len ;\r\noutput.data = (unsigned char *) out ;\r\ntmp_rc4_key = ( (NEW_ZEN_RC4_KEY *) ( ctx->cipher_data ) ) ;\r\nrc4key.len = 260 ;\r\nrc4key.data = &( tmp_rc4_key->rc4_state [ 0 ] ) ;\r\nto_return = ptr_zencod_rc4_cipher ( &output, &input, (const zen_nb_t *) &rc4key, &( tmp_rc4_key->rc4_state [0] ), &( tmp_rc4_key->rc4_state [3] ), !tmp_rc4_key->first ) ;\r\nto_return = !to_return ;\r\ntmp_rc4_key->first = 1 ;\r\ntmp_rc4_key = NULL ;\r\nreturn to_return ;\r\n}\r\nstatic int engine_des_init_key ( EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc )\r\n{\r\nZEN_DES_KEY *tmp_des_key = NULL ;\r\nint to_return = 0 ;\r\ntmp_des_key = (ZEN_DES_KEY *) ( ctx->cipher_data ) ;\r\nmemcpy ( &( tmp_des_key->des_key [ 0 ] ), key, 8 ) ;\r\nmemcpy ( &( tmp_des_key->des_key [ 8 ] ), key, 8 ) ;\r\nmemcpy ( &( tmp_des_key->des_key [ 16 ] ), key, 8 ) ;\r\nmemcpy ( &( tmp_des_key->des_iv [ 0 ] ), iv, 8 ) ;\r\nto_return = 1 ;\r\nreturn to_return ;\r\n}\r\nstatic int engine_des_cbc_cipher ( EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in, unsigned int inl )\r\n{\r\nzen_nb_t output, input ;\r\nzen_nb_t deskey_1, deskey_2, deskey_3, iv ;\r\nint to_return = 0 ;\r\ninput.len = inl ;\r\ninput.data = (unsigned char *) in ;\r\noutput.len = inl ;\r\noutput.data = out ;\r\ndeskey_1.len = 8 ;\r\ndeskey_2.len = 8 ;\r\ndeskey_3.len = 8 ;\r\ndeskey_1.data = (unsigned char *) ( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_key ;\r\ndeskey_2.data = (unsigned char *) &( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_key [ 8 ] ;\r\ndeskey_3.data = (unsigned char *) &( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_key [ 16 ] ;\r\nmemcpy ( ( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_iv, ctx->iv, 8 ) ;\r\niv.len = 8 ;\r\niv.data = (unsigned char *) ( (ZEN_DES_KEY *) ( ctx->cipher_data ) )->des_iv ;\r\nif ( ctx->encrypt == 0 ) {\r\nmemcpy ( ctx->iv, &( input.data [ input.len - 8 ] ), 8 ) ;\r\n}\r\nto_return = ptr_zencod_xdes_cipher ( &output, &input,\r\n(zen_nb_t *) &deskey_1, (zen_nb_t *) &deskey_2, (zen_nb_t *) &deskey_3, &iv, ctx->encrypt ) ;\r\nto_return = !to_return ;\r\nif ( ctx->encrypt == 1 ) {\r\nmemcpy ( ctx->iv, &( output.data [ output.len - 8 ] ), 8 ) ;\r\n}\r\nreturn to_return ;\r\n}\r\nstatic int engine_des_ede3_init_key ( EVP_CIPHER_CTX *ctx, const unsigned char *key, const unsigned char *iv, int enc )\r\n{\r\nZEN_3DES_KEY *tmp_3des_key = NULL ;\r\nint to_return = 0 ;\r\ntmp_3des_key = (ZEN_3DES_KEY *) ( ctx->cipher_data ) ;\r\nmemcpy ( &( tmp_3des_key->des3_key [ 0 ] ), key, 24 ) ;\r\nmemcpy ( &( tmp_3des_key->des3_iv [ 0 ] ), iv, 8 ) ;\r\nto_return = 1;\r\nreturn to_return ;\r\n}\r\nstatic int engine_des_ede3_cbc_cipher ( EVP_CIPHER_CTX *ctx, unsigned char *out, const unsigned char *in,\r\nunsigned int in_len )\r\n{\r\nzen_nb_t output, input ;\r\nzen_nb_t deskey_1, deskey_2, deskey_3, iv ;\r\nint to_return = 0 ;\r\ninput.len = in_len ;\r\ninput.data = (unsigned char *) in ;\r\noutput.len = in_len ;\r\noutput.data = out ;\r\ndeskey_1.len = 8 ;\r\ndeskey_2.len = 8 ;\r\ndeskey_3.len = 8 ;\r\ndeskey_1.data = (unsigned char *) ( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_key ;\r\ndeskey_2.data = (unsigned char *) &( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_key [ 8 ] ;\r\ndeskey_3.data = (unsigned char *) &( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_key [ 16 ] ;\r\nmemcpy ( ( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_iv, ctx->iv, 8 ) ;\r\niv.len = 8 ;\r\niv.data = (unsigned char *) ( (ZEN_3DES_KEY *) ( ctx->cipher_data ) )->des3_iv ;\r\nif ( ctx->encrypt == 0 ) {\r\nmemcpy ( ctx->iv, &( input.data [ input.len - 8 ] ), 8 ) ;\r\n}\r\nto_return = ptr_zencod_xdes_cipher ( &output, &input,\r\n(zen_nb_t *) &deskey_1, (zen_nb_t *) &deskey_2, (zen_nb_t *) &deskey_3, &iv, ctx->encrypt ) ;\r\nto_return = !to_return ;\r\nif ( ctx->encrypt == 1 ) {\r\nmemcpy ( ctx->iv, &( output.data [ output.len - 8 ] ), 8 ) ;\r\n}\r\nreturn to_return ;\r\n}\r\nstatic int engine_cipher_cleanup ( EVP_CIPHER_CTX *ctx )\r\n{\r\nif ( ctx->cipher->nid == NID_rc4 || ctx->cipher->nid == NID_rc4_40 ) {\r\n}\r\nelse if ( ctx->cipher->nid == NID_des_cbc ) {\r\n}\r\nelse if ( ctx->cipher->nid == NID_des_ede3_cbc ) {\r\n}\r\nreturn 1 ;\r\n}
