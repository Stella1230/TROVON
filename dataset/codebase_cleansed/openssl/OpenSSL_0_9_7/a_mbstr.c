int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in, int len,\r\nint inform, unsigned long mask)\r\n{\r\nreturn ASN1_mbstring_ncopy(out, in, len, inform, mask, 0, 0);\r\n}\r\nint ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,\r\nint inform, unsigned long mask,\r\nlong minsize, long maxsize)\r\n{\r\nint str_type;\r\nint ret;\r\nchar free_out;\r\nint outform, outlen;\r\nASN1_STRING *dest;\r\nunsigned char *p;\r\nint nchar;\r\nchar strbuf[32];\r\nint (*cpyfunc)(unsigned long,void *) = NULL;\r\nif(len == -1) len = strlen((const char *)in);\r\nif(!mask) mask = DIRSTRING_TYPE;\r\nswitch(inform) {\r\ncase MBSTRING_BMP:\r\nif(len & 1) {\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY,\r\nASN1_R_INVALID_BMPSTRING_LENGTH);\r\nreturn -1;\r\n}\r\nnchar = len >> 1;\r\nbreak;\r\ncase MBSTRING_UNIV:\r\nif(len & 3) {\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY,\r\nASN1_R_INVALID_UNIVERSALSTRING_LENGTH);\r\nreturn -1;\r\n}\r\nnchar = len >> 2;\r\nbreak;\r\ncase MBSTRING_UTF8:\r\nnchar = 0;\r\nret = traverse_string(in, len, MBSTRING_UTF8, in_utf8, &nchar);\r\nif(ret < 0) {\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY,\r\nASN1_R_INVALID_UTF8STRING);\r\nreturn -1;\r\n}\r\nbreak;\r\ncase MBSTRING_ASC:\r\nnchar = len;\r\nbreak;\r\ndefault:\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY, ASN1_R_UNKNOWN_FORMAT);\r\nreturn -1;\r\n}\r\nif((minsize > 0) && (nchar < minsize)) {\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY, ASN1_R_STRING_TOO_SHORT);\r\nsprintf(strbuf, "%ld", minsize);\r\nERR_add_error_data(2, "minsize=", strbuf);\r\nreturn -1;\r\n}\r\nif((maxsize > 0) && (nchar > maxsize)) {\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY, ASN1_R_STRING_TOO_LONG);\r\nsprintf(strbuf, "%ld", maxsize);\r\nERR_add_error_data(2, "maxsize=", strbuf);\r\nreturn -1;\r\n}\r\nif(traverse_string(in, len, inform, type_str, &mask) < 0) {\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY, ASN1_R_ILLEGAL_CHARACTERS);\r\nreturn -1;\r\n}\r\noutform = MBSTRING_ASC;\r\nif(mask & B_ASN1_PRINTABLESTRING) str_type = V_ASN1_PRINTABLESTRING;\r\nelse if(mask & B_ASN1_IA5STRING) str_type = V_ASN1_IA5STRING;\r\nelse if(mask & B_ASN1_T61STRING) str_type = V_ASN1_T61STRING;\r\nelse if(mask & B_ASN1_BMPSTRING) {\r\nstr_type = V_ASN1_BMPSTRING;\r\noutform = MBSTRING_BMP;\r\n} else if(mask & B_ASN1_UNIVERSALSTRING) {\r\nstr_type = V_ASN1_UNIVERSALSTRING;\r\noutform = MBSTRING_UNIV;\r\n} else {\r\nstr_type = V_ASN1_UTF8STRING;\r\noutform = MBSTRING_UTF8;\r\n}\r\nif(!out) return str_type;\r\nif(*out) {\r\nfree_out = 0;\r\ndest = *out;\r\nif(dest->data) {\r\ndest->length = 0;\r\nOPENSSL_free(dest->data);\r\ndest->data = NULL;\r\n}\r\ndest->type = str_type;\r\n} else {\r\nfree_out = 1;\r\ndest = ASN1_STRING_type_new(str_type);\r\nif(!dest) {\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY,\r\nERR_R_MALLOC_FAILURE);\r\nreturn -1;\r\n}\r\n*out = dest;\r\n}\r\nif(inform == outform) {\r\nif(!ASN1_STRING_set(dest, in, len)) {\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY,ERR_R_MALLOC_FAILURE);\r\nreturn -1;\r\n}\r\nreturn str_type;\r\n}\r\nswitch(outform) {\r\ncase MBSTRING_ASC:\r\noutlen = nchar;\r\ncpyfunc = cpy_asc;\r\nbreak;\r\ncase MBSTRING_BMP:\r\noutlen = nchar << 1;\r\ncpyfunc = cpy_bmp;\r\nbreak;\r\ncase MBSTRING_UNIV:\r\noutlen = nchar << 2;\r\ncpyfunc = cpy_univ;\r\nbreak;\r\ncase MBSTRING_UTF8:\r\noutlen = 0;\r\ntraverse_string(in, len, inform, out_utf8, &outlen);\r\ncpyfunc = cpy_utf8;\r\nbreak;\r\n}\r\nif(!(p = OPENSSL_malloc(outlen + 1))) {\r\nif(free_out) ASN1_STRING_free(dest);\r\nASN1err(ASN1_F_ASN1_MBSTRING_COPY,ERR_R_MALLOC_FAILURE);\r\nreturn -1;\r\n}\r\ndest->length = outlen;\r\ndest->data = p;\r\np[outlen] = 0;\r\ntraverse_string(in, len, inform, cpyfunc, &p);\r\nreturn str_type;\r\n}\r\nstatic int traverse_string(const unsigned char *p, int len, int inform,\r\nint (*rfunc)(unsigned long value, void *in), void *arg)\r\n{\r\nunsigned long value;\r\nint ret;\r\nwhile(len) {\r\nif(inform == MBSTRING_ASC) {\r\nvalue = *p++;\r\nlen--;\r\n} else if(inform == MBSTRING_BMP) {\r\nvalue = *p++ << 8;\r\nvalue |= *p++;\r\nlen -= 2;\r\n} else if(inform == MBSTRING_UNIV) {\r\nvalue = ((unsigned long)*p++) << 24;\r\nvalue |= ((unsigned long)*p++) << 16;\r\nvalue |= *p++ << 8;\r\nvalue |= *p++;\r\nlen -= 4;\r\n} else {\r\nret = UTF8_getc(p, len, &value);\r\nif(ret < 0) return -1;\r\nlen -= ret;\r\np += ret;\r\n}\r\nif(rfunc) {\r\nret = rfunc(value, arg);\r\nif(ret <= 0) return ret;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int in_utf8(unsigned long value, void *arg)\r\n{\r\nint *nchar;\r\nnchar = arg;\r\n(*nchar)++;\r\nreturn 1;\r\n}\r\nstatic int out_utf8(unsigned long value, void *arg)\r\n{\r\nlong *outlen;\r\noutlen = arg;\r\n*outlen += UTF8_putc(NULL, -1, value);\r\nreturn 1;\r\n}\r\nstatic int type_str(unsigned long value, void *arg)\r\n{\r\nunsigned long types;\r\ntypes = *((unsigned long *)arg);\r\nif((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))\r\ntypes &= ~B_ASN1_PRINTABLESTRING;\r\nif((types & B_ASN1_IA5STRING) && (value > 127))\r\ntypes &= ~B_ASN1_IA5STRING;\r\nif((types & B_ASN1_T61STRING) && (value > 0xff))\r\ntypes &= ~B_ASN1_T61STRING;\r\nif((types & B_ASN1_BMPSTRING) && (value > 0xffff))\r\ntypes &= ~B_ASN1_BMPSTRING;\r\nif(!types) return -1;\r\n*((unsigned long *)arg) = types;\r\nreturn 1;\r\n}\r\nstatic int cpy_asc(unsigned long value, void *arg)\r\n{\r\nunsigned char **p, *q;\r\np = arg;\r\nq = *p;\r\n*q = (unsigned char) value;\r\n(*p)++;\r\nreturn 1;\r\n}\r\nstatic int cpy_bmp(unsigned long value, void *arg)\r\n{\r\nunsigned char **p, *q;\r\np = arg;\r\nq = *p;\r\n*q++ = (unsigned char) ((value >> 8) & 0xff);\r\n*q = (unsigned char) (value & 0xff);\r\n*p += 2;\r\nreturn 1;\r\n}\r\nstatic int cpy_univ(unsigned long value, void *arg)\r\n{\r\nunsigned char **p, *q;\r\np = arg;\r\nq = *p;\r\n*q++ = (unsigned char) ((value >> 24) & 0xff);\r\n*q++ = (unsigned char) ((value >> 16) & 0xff);\r\n*q++ = (unsigned char) ((value >> 8) & 0xff);\r\n*q = (unsigned char) (value & 0xff);\r\n*p += 4;\r\nreturn 1;\r\n}\r\nstatic int cpy_utf8(unsigned long value, void *arg)\r\n{\r\nunsigned char **p;\r\nint ret;\r\np = arg;\r\nret = UTF8_putc(*p, 0xff, value);\r\n*p += ret;\r\nreturn 1;\r\n}\r\nstatic int is_printable(unsigned long value)\r\n{\r\nint ch;\r\nif(value > 0x7f) return 0;\r\nch = (int) value;\r\n#ifndef CHARSET_EBCDIC\r\nif((ch >= 'a') && (ch <= 'z')) return 1;\r\nif((ch >= 'A') && (ch <= 'Z')) return 1;\r\nif((ch >= '0') && (ch <= '9')) return 1;\r\nif ((ch == ' ') || strchr("'()+,-./:=?", ch)) return 1;\r\n#else\r\nif((ch >= os_toascii['a']) && (ch <= os_toascii['z'])) return 1;\r\nif((ch >= os_toascii['A']) && (ch <= os_toascii['Z'])) return 1;\r\nif((ch >= os_toascii['0']) && (ch <= os_toascii['9'])) return 1;\r\nif ((ch == os_toascii[' ']) || strchr("'()+,-./:=?", os_toebcdic[ch])) return 1;\r\n#endif\r\nreturn 0;\r\n}
