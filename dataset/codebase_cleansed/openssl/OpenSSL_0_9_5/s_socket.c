static LONG FAR PASCAL topHookProc(HWND hwnd, UINT message, WPARAM wParam,\r\nLPARAM lParam)\r\n{\r\nif (hwnd == topWnd)\r\n{\r\nswitch(message)\r\n{\r\ncase WM_DESTROY:\r\ncase WM_CLOSE:\r\nSetWindowLong(topWnd,GWL_WNDPROC,(LONG)lpTopWndProc);\r\nsock_cleanup();\r\nbreak;\r\n}\r\n}\r\nreturn CallWindowProc(lpTopWndProc,hwnd,message,wParam,lParam);\r\n}\r\nstatic BOOL CALLBACK enumproc(HWND hwnd,LPARAM lParam)\r\n{\r\ntopWnd=hwnd;\r\nreturn(FALSE);\r\n}\r\nvoid sock_cleanup(void)\r\n{\r\n#ifdef WINDOWS\r\nif (wsa_init_done)\r\n{\r\nwsa_init_done=0;\r\nWSACancelBlockingCall();\r\nWSACleanup();\r\n}\r\n#endif\r\n}\r\nint sock_init(void)\r\n{\r\n#ifdef WINDOWS\r\nif (!wsa_init_done)\r\n{\r\nint err;\r\n#ifdef SIGINT\r\nsignal(SIGINT,(void (*)(int))sock_cleanup);\r\n#endif\r\nwsa_init_done=1;\r\nmemset(&wsa_state,0,sizeof(wsa_state));\r\nif (WSAStartup(0x0101,&wsa_state)!=0)\r\n{\r\nerr=WSAGetLastError();\r\nBIO_printf(bio_err,"unable to start WINSOCK, error code=%d\n",err);\r\nreturn(0);\r\n}\r\n#ifdef WIN16\r\nEnumTaskWindows(GetCurrentTask(),enumproc,0L);\r\nlpTopWndProc=(FARPROC)GetWindowLong(topWnd,GWL_WNDPROC);\r\nlpTopHookProc=MakeProcInstance((FARPROC)topHookProc,_hInstance);\r\nSetWindowLong(topWnd,GWL_WNDPROC,(LONG)lpTopHookProc);\r\n#endif\r\n}\r\n#endif\r\nreturn(1);\r\n}\r\nint init_client(int *sock, char *host, int port)\r\n{\r\nunsigned char ip[4];\r\nshort p=0;\r\nif (!host_ip(host,&(ip[0])))\r\n{\r\nreturn(0);\r\n}\r\nif (p != 0) port=p;\r\nreturn(init_client_ip(sock,ip,port));\r\n}\r\nint init_client_ip(int *sock, unsigned char ip[4], int port)\r\n{\r\nunsigned long addr;\r\nstruct sockaddr_in them;\r\nint s,i;\r\nif (!sock_init()) return(0);\r\nmemset((char *)&them,0,sizeof(them));\r\nthem.sin_family=AF_INET;\r\nthem.sin_port=htons((unsigned short)port);\r\naddr=(unsigned long)\r\n((unsigned long)ip[0]<<24L)|\r\n((unsigned long)ip[1]<<16L)|\r\n((unsigned long)ip[2]<< 8L)|\r\n((unsigned long)ip[3]);\r\nthem.sin_addr.s_addr=htonl(addr);\r\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\r\nif (s == INVALID_SOCKET) { perror("socket"); return(0); }\r\ni=0;\r\ni=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));\r\nif (i < 0) { perror("keepalive"); return(0); }\r\nif (connect(s,(struct sockaddr *)&them,sizeof(them)) == -1)\r\n{ close(s); perror("connect"); return(0); }\r\n*sock=s;\r\nreturn(1);\r\n}\r\nint nbio_sock_error(int sock)\r\n{\r\nint j,i;\r\nint size;\r\nsize=sizeof(int);\r\ni=getsockopt(sock,SOL_SOCKET,SO_ERROR,(char *)&j,(void *)&size);\r\nif (i < 0)\r\nreturn(1);\r\nelse\r\nreturn(j);\r\n}\r\nint nbio_init_client_ip(int *sock, unsigned char ip[4], int port)\r\n{\r\nunsigned long addr;\r\nstruct sockaddr_in them;\r\nint s,i;\r\nif (!sock_init()) return(0);\r\nmemset((char *)&them,0,sizeof(them));\r\nthem.sin_family=AF_INET;\r\nthem.sin_port=htons((unsigned short)port);\r\naddr= (unsigned long)\r\n((unsigned long)ip[0]<<24L)|\r\n((unsigned long)ip[1]<<16L)|\r\n((unsigned long)ip[2]<< 8L)|\r\n((unsigned long)ip[3]);\r\nthem.sin_addr.s_addr=htonl(addr);\r\nif (*sock <= 0)\r\n{\r\n#ifdef FIONBIO\r\nunsigned long l=1;\r\n#endif\r\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\r\nif (s == INVALID_SOCKET) { perror("socket"); return(0); }\r\ni=0;\r\ni=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));\r\nif (i < 0) { perror("keepalive"); return(0); }\r\n*sock=s;\r\n#ifdef FIONBIO\r\nBIO_socket_ioctl(s,FIONBIO,&l);\r\n#endif\r\n}\r\nelse\r\ns= *sock;\r\ni=connect(s,(struct sockaddr *)&them,sizeof(them));\r\nif (i == INVALID_SOCKET)\r\n{\r\nif (BIO_sock_should_retry(i))\r\nreturn(-1);\r\nelse\r\nreturn(0);\r\n}\r\nelse\r\nreturn(1);\r\n}\r\nint do_server(int port, int *ret, int (*cb)(), char *context)\r\n{\r\nint sock;\r\nchar *name;\r\nint accept_socket;\r\nint i;\r\nif (!init_server(&accept_socket,port)) return(0);\r\nif (ret != NULL)\r\n{\r\n*ret=accept_socket;\r\n}\r\nfor (;;)\r\n{\r\nif (do_accept(accept_socket,&sock,&name) == 0)\r\n{\r\nSHUTDOWN(accept_socket);\r\nreturn(0);\r\n}\r\ni=(*cb)(name,sock, context);\r\nif (name != NULL) Free(name);\r\nSHUTDOWN2(sock);\r\nif (i < 0)\r\n{\r\nSHUTDOWN2(accept_socket);\r\nreturn(i);\r\n}\r\n}\r\n}\r\nint init_server_long(int *sock, int port, char *ip)\r\n{\r\nint ret=0;\r\nstruct sockaddr_in server;\r\nint s= -1,i;\r\nif (!sock_init()) return(0);\r\nmemset((char *)&server,0,sizeof(server));\r\nserver.sin_family=AF_INET;\r\nserver.sin_port=htons((unsigned short)port);\r\nif (ip == NULL)\r\nserver.sin_addr.s_addr=INADDR_ANY;\r\nelse\r\n#ifndef BIT_FIELD_LIMITS\r\nmemcpy(&server.sin_addr.s_addr,ip,4);\r\n#else\r\nmemcpy(&server.sin_addr,ip,4);\r\n#endif\r\ns=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\r\nif (s == INVALID_SOCKET) goto err;\r\n#if defined SOL_SOCKET && defined SO_REUSEADDR\r\n{\r\nint j = 1;\r\nsetsockopt(s, SOL_SOCKET, SO_REUSEADDR,\r\n(void *) &j, sizeof j);\r\n}\r\n#endif\r\nif (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)\r\n{\r\n#ifndef WINDOWS\r\nperror("bind");\r\n#endif\r\ngoto err;\r\n}\r\nif (listen(s,128) == -1) goto err;\r\ni=0;\r\n*sock=s;\r\nret=1;\r\nerr:\r\nif ((ret == 0) && (s != -1))\r\n{\r\nSHUTDOWN(s);\r\n}\r\nreturn(ret);\r\n}\r\nint init_server(int *sock, int port)\r\n{\r\nreturn(init_server_long(sock, port, NULL));\r\n}\r\nint do_accept(int acc_sock, int *sock, char **host)\r\n{\r\nint ret,i;\r\nstruct hostent *h1,*h2;\r\nstatic struct sockaddr_in from;\r\nint len;\r\nif (!sock_init()) return(0);\r\n#ifndef WINDOWS\r\nredoit:\r\n#endif\r\nmemset((char *)&from,0,sizeof(from));\r\nlen=sizeof(from);\r\nret=accept(acc_sock,(struct sockaddr *)&from,(void *)&len);\r\nif (ret == INVALID_SOCKET)\r\n{\r\n#ifdef WINDOWS\r\ni=WSAGetLastError();\r\nBIO_printf(bio_err,"accept error %d\n",i);\r\n#else\r\nif (errno == EINTR)\r\n{\r\ngoto redoit;\r\n}\r\nfprintf(stderr,"errno=%d ",errno);\r\nperror("accept");\r\n#endif\r\nreturn(0);\r\n}\r\nif (host == NULL) goto end;\r\n#ifndef BIT_FIELD_LIMITS\r\nh1=gethostbyaddr((char *)&from.sin_addr.s_addr,\r\nsizeof(from.sin_addr.s_addr),AF_INET);\r\n#else\r\nh1=gethostbyaddr((char *)&from.sin_addr,\r\nsizeof(struct in_addr),AF_INET);\r\n#endif\r\nif (h1 == NULL)\r\n{\r\nBIO_printf(bio_err,"bad gethostbyaddr\n");\r\n*host=NULL;\r\n}\r\nelse\r\n{\r\nif ((*host=(char *)Malloc(strlen(h1->h_name)+1)) == NULL)\r\n{\r\nperror("Malloc");\r\nreturn(0);\r\n}\r\nstrcpy(*host,h1->h_name);\r\nh2=GetHostByName(*host);\r\nif (h2 == NULL)\r\n{\r\nBIO_printf(bio_err,"gethostbyname failure\n");\r\nreturn(0);\r\n}\r\ni=0;\r\nif (h2->h_addrtype != AF_INET)\r\n{\r\nBIO_printf(bio_err,"gethostbyname addr is not AF_INET\n");\r\nreturn(0);\r\n}\r\n}\r\nend:\r\n*sock=ret;\r\nreturn(1);\r\n}\r\nint extract_host_port(char *str, char **host_ptr, unsigned char *ip,\r\nshort *port_ptr)\r\n{\r\nchar *h,*p;\r\nh=str;\r\np=strchr(str,':');\r\nif (p == NULL)\r\n{\r\nBIO_printf(bio_err,"no port defined\n");\r\nreturn(0);\r\n}\r\n*(p++)='\0';\r\nif ((ip != NULL) && !host_ip(str,ip))\r\ngoto err;\r\nif (host_ptr != NULL) *host_ptr=h;\r\nif (!extract_port(p,port_ptr))\r\ngoto err;\r\nreturn(1);\r\nerr:\r\nreturn(0);\r\n}\r\nint host_ip(char *str, unsigned char ip[4])\r\n{\r\nunsigned int in[4];\r\nint i;\r\nif (sscanf(str,"%u.%u.%u.%u",&(in[0]),&(in[1]),&(in[2]),&(in[3])) == 4)\r\n{\r\nfor (i=0; i<4; i++)\r\nif (in[i] > 255)\r\n{\r\nBIO_printf(bio_err,"invalid IP address\n");\r\ngoto err;\r\n}\r\nip[0]=in[0];\r\nip[1]=in[1];\r\nip[2]=in[2];\r\nip[3]=in[3];\r\n}\r\nelse\r\n{\r\nstruct hostent *he;\r\nif (!sock_init()) return(0);\r\nhe=GetHostByName(str);\r\nif (he == NULL)\r\n{\r\nBIO_printf(bio_err,"gethostbyname failure\n");\r\ngoto err;\r\n}\r\nif ((short)he->h_addrtype != AF_INET)\r\n{\r\nBIO_printf(bio_err,"gethostbyname addr is not AF_INET\n");\r\nreturn(0);\r\n}\r\nip[0]=he->h_addr_list[0][0];\r\nip[1]=he->h_addr_list[0][1];\r\nip[2]=he->h_addr_list[0][2];\r\nip[3]=he->h_addr_list[0][3];\r\n}\r\nreturn(1);\r\nerr:\r\nreturn(0);\r\n}\r\nint extract_port(char *str, short *port_ptr)\r\n{\r\nint i;\r\nstruct servent *s;\r\ni=atoi(str);\r\nif (i != 0)\r\n*port_ptr=(unsigned short)i;\r\nelse\r\n{\r\ns=getservbyname(str,"tcp");\r\nif (s == NULL)\r\n{\r\nBIO_printf(bio_err,"getservbyname failure for %s\n",str);\r\nreturn(0);\r\n}\r\n*port_ptr=ntohs((unsigned short)s->s_port);\r\n}\r\nreturn(1);\r\n}\r\nstatic struct hostent *GetHostByName(char *name)\r\n{\r\nstruct hostent *ret;\r\nint i,lowi=0;\r\nunsigned long low= (unsigned long)-1;\r\nfor (i=0; i<GHBN_NUM; i++)\r\n{\r\nif (low > ghbn_cache[i].order)\r\n{\r\nlow=ghbn_cache[i].order;\r\nlowi=i;\r\n}\r\nif (ghbn_cache[i].order > 0)\r\n{\r\nif (strncmp(name,ghbn_cache[i].name,128) == 0)\r\nbreak;\r\n}\r\n}\r\nif (i == GHBN_NUM)\r\n{\r\nghbn_miss++;\r\nret=gethostbyname(name);\r\nif (ret == NULL) return(NULL);\r\nstrncpy(ghbn_cache[lowi].name,name,128);\r\nmemcpy((char *)&(ghbn_cache[lowi].ent),ret,sizeof(struct hostent));\r\nghbn_cache[lowi].order=ghbn_miss+ghbn_hits;\r\nreturn(ret);\r\n}\r\nelse\r\n{\r\nghbn_hits++;\r\nret= &(ghbn_cache[i].ent);\r\nghbn_cache[i].order=ghbn_miss+ghbn_hits;\r\nreturn(ret);\r\n}\r\n}\r\nint spawn(int argc, char **argv, int *in, int *out)\r\n{\r\nint pid;\r\n#define CHILD_READ p1[0]\r\n#define CHILD_WRITE p2[1]\r\n#define PARENT_READ p2[0]\r\n#define PARENT_WRITE p1[1]\r\nint p1[2],p2[2];\r\nif ((pipe(p1) < 0) || (pipe(p2) < 0)) return(-1);\r\n#ifdef VMS\r\nif ((pid=vfork()) == 0)\r\n#else\r\nif ((pid=fork()) == 0)\r\n#endif\r\n{\r\nif (dup2(CHILD_WRITE,fileno(stdout)) < 0)\r\nperror("dup2");\r\nif (dup2(CHILD_WRITE,fileno(stderr)) < 0)\r\nperror("dup2");\r\nif (dup2(CHILD_READ,fileno(stdin)) < 0)\r\nperror("dup2");\r\nclose(CHILD_READ);\r\nclose(CHILD_WRITE);\r\nclose(PARENT_READ);\r\nclose(PARENT_WRITE);\r\nexecvp(argv[0],argv);\r\nperror("child");\r\nexit(1);\r\n}\r\n*in= PARENT_READ;\r\n*out=PARENT_WRITE;\r\nclose(CHILD_READ);\r\nclose(CHILD_WRITE);\r\nreturn(pid);\r\n}
