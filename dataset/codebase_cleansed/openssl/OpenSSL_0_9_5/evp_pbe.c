int EVP_PBE_CipherInit (ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\r\nASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)\r\n{\r\nEVP_PBE_CTL *pbetmp, pbelu;\r\nint i;\r\npbelu.pbe_nid = OBJ_obj2nid(pbe_obj);\r\nif (pbelu.pbe_nid != NID_undef) i = sk_find(pbe_algs, (char *)&pbelu);\r\nelse i = -1;\r\nif (i == -1) {\r\nchar obj_tmp[80];\r\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT,EVP_R_UNKNOWN_PBE_ALGORITHM);\r\nif (!pbe_obj) strcpy (obj_tmp, "NULL");\r\nelse i2t_ASN1_OBJECT(obj_tmp, 80, pbe_obj);\r\nERR_add_error_data(2, "TYPE=", obj_tmp);\r\nreturn 0;\r\n}\r\nif (passlen == -1) passlen = strlen(pass);\r\npbetmp = (EVP_PBE_CTL *)sk_value (pbe_algs, i);\r\ni = (*pbetmp->keygen)(ctx, pass, passlen, param, pbetmp->cipher,\r\npbetmp->md, en_de);\r\nif (!i) {\r\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT,EVP_R_KEYGEN_FAILURE);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int pbe_cmp (EVP_PBE_CTL **pbe1, EVP_PBE_CTL **pbe2)\r\n{\r\nreturn ((*pbe1)->pbe_nid - (*pbe2)->pbe_nid);\r\n}\r\nint EVP_PBE_alg_add (int nid, EVP_CIPHER *cipher, EVP_MD *md,\r\nEVP_PBE_KEYGEN *keygen)\r\n{\r\nEVP_PBE_CTL *pbe_tmp;\r\nif (!pbe_algs) pbe_algs = sk_new (pbe_cmp);\r\nif (!(pbe_tmp = (EVP_PBE_CTL*) Malloc (sizeof(EVP_PBE_CTL)))) {\r\nEVPerr(EVP_F_EVP_PBE_ALG_ADD,ERR_R_MALLOC_FAILURE);\r\nreturn 0;\r\n}\r\npbe_tmp->pbe_nid = nid;\r\npbe_tmp->cipher = cipher;\r\npbe_tmp->md = md;\r\npbe_tmp->keygen = keygen;\r\nsk_push (pbe_algs, (char *)pbe_tmp);\r\nreturn 1;\r\n}\r\nvoid EVP_PBE_cleanup(void)\r\n{\r\nsk_pop_free(pbe_algs, FreeFunc);\r\npbe_algs = NULL;\r\n}
