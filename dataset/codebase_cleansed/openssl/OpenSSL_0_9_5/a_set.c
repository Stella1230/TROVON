static int SetBlobCmp(const void *elem1, const void *elem2 )\r\n{\r\nconst MYBLOB *b1 = (const MYBLOB *)elem1;\r\nconst MYBLOB *b2 = (const MYBLOB *)elem2;\r\nint r;\r\nr = memcmp(b1->pbData, b2->pbData,\r\nb1->cbData < b2->cbData ? b1->cbData : b2->cbData);\r\nif(r != 0)\r\nreturn r;\r\nreturn b1->cbData-b2->cbData;\r\n}\r\nint i2d_ASN1_SET(STACK *a, unsigned char **pp, int (*func)(), int ex_tag,\r\nint ex_class, int is_set)\r\n{\r\nint ret=0,r;\r\nint i;\r\nunsigned char *p;\r\nunsigned char *pStart, *pTempMem;\r\nMYBLOB *rgSetBlob;\r\nint totSize;\r\nif (a == NULL) return(0);\r\nfor (i=sk_num(a)-1; i>=0; i--)\r\nret+=func(sk_value(a,i),NULL);\r\nr=ASN1_object_size(1,ret,ex_tag);\r\nif (pp == NULL) return(r);\r\np= *pp;\r\nASN1_put_object(&p,1,ret,ex_tag,ex_class);\r\nif(!is_set || (sk_num(a) < 2))\r\n{\r\nfor (i=0; i<sk_num(a); i++)\r\nfunc(sk_value(a,i),&p);\r\n*pp=p;\r\nreturn(r);\r\n}\r\npStart = p;\r\nrgSetBlob = (MYBLOB *)Malloc( sk_num(a) * sizeof(MYBLOB));\r\nfor (i=0; i<sk_num(a); i++)\r\n{\r\nrgSetBlob[i].pbData = p;\r\nfunc(sk_value(a,i),&p);\r\nrgSetBlob[i].cbData = p - rgSetBlob[i].pbData;\r\n}\r\n*pp=p;\r\ntotSize = p - pStart;\r\nqsort( rgSetBlob, sk_num(a), sizeof(MYBLOB), SetBlobCmp);\r\npTempMem = Malloc(totSize);\r\np = pTempMem;\r\nfor(i=0; i<sk_num(a); ++i)\r\n{\r\nmemcpy(p, rgSetBlob[i].pbData, rgSetBlob[i].cbData);\r\np += rgSetBlob[i].cbData;\r\n}\r\nmemcpy(pStart, pTempMem, totSize);\r\nFree(pTempMem);\r\nFree(rgSetBlob);\r\nreturn(r);\r\n}\r\nSTACK *d2i_ASN1_SET(STACK **a, unsigned char **pp, long length,\r\nchar *(*func)(), void (*free_func)(), int ex_tag, int ex_class)\r\n{\r\nASN1_CTX c;\r\nSTACK *ret=NULL;\r\nif ((a == NULL) || ((*a) == NULL))\r\n{ if ((ret=sk_new(NULL)) == NULL) goto err; }\r\nelse\r\nret=(*a);\r\nc.p= *pp;\r\nc.max=(length == 0)?0:(c.p+length);\r\nc.inf=ASN1_get_object(&c.p,&c.slen,&c.tag,&c.xclass,c.max-c.p);\r\nif (c.inf & 0x80) goto err;\r\nif (ex_class != c.xclass)\r\n{\r\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_BAD_CLASS);\r\ngoto err;\r\n}\r\nif (ex_tag != c.tag)\r\n{\r\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_BAD_TAG);\r\ngoto err;\r\n}\r\nif ((c.slen+c.p) > c.max)\r\n{\r\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_LENGTH_ERROR);\r\ngoto err;\r\n}\r\nif (c.inf == (V_ASN1_CONSTRUCTED+1))\r\nc.slen=length+ *pp-c.p;\r\nc.max=c.p+c.slen;\r\nwhile (c.p < c.max)\r\n{\r\nchar *s;\r\nif (M_ASN1_D2I_end_sequence()) break;\r\nif ((s=func(NULL,&c.p,c.slen,c.max-c.p)) == NULL)\r\n{\r\nASN1err(ASN1_F_D2I_ASN1_SET,ASN1_R_ERROR_PARSING_SET_ELEMENT);\r\nasn1_add_error(*pp,(int)(c.q- *pp));\r\ngoto err;\r\n}\r\nif (!sk_push(ret,s)) goto err;\r\n}\r\nif (a != NULL) (*a)=ret;\r\n*pp=c.p;\r\nreturn(ret);\r\nerr:\r\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\r\n{\r\nif (free_func != NULL)\r\nsk_pop_free(ret,free_func);\r\nelse\r\nsk_free(ret);\r\n}\r\nreturn(NULL);\r\n}
