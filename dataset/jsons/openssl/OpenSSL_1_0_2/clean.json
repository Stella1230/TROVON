[
{
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_conf_c", "target": 0, "func": "X509 *TS_CONF_load_cert(const char *file)\\r\\n{\\r\\nBIO *cert = NULL;\\r\\nX509 *x = NULL;\\r\\nif ((cert = BIO_new_file(file, \"r\")) == NULL)\\r\\ngoto end;\\r\\nx = PEM_read_bio_X509_AUX(cert, NULL, NULL, NULL);\\r\\nend:\\r\\nif (x == NULL)\\r\\nfprintf(stderr, \"unable to load certificate: %s\\n\", file);\\r\\nBIO_free(cert);\\r\\nreturn x;\\r\\n}\\r\\nvoid TS_CONF_lookup_fail(const char *name, const char *tag)\\r\\n{\\r\\nfprintf(stderr, \"variable lookup failed for %s::%s\\n\", name, tag);\\r\\n}\\r\\nstatic void TS_CONF_invalid(const char *name, const char *tag)\\r\\n{\\r\\nfprintf(stderr, \"invalid variable value for %s::%s\\n\", name, tag);\\r\\n}\\r\\nconst char *TS_CONF_get_tsa_section(CONF *conf, const char *section)\\r\\n{\\r\\nif (!section) {\\r\\nsection = NCONF_get_string(conf, BASE_SECTION, ENV_DEFAULT_TSA);\\r\\nif (!section)\\r\\nTS_CONF_lookup_fail(BASE_SECTION, ENV_DEFAULT_TSA);\\r\\n}\\r\\nreturn section;\\r\\n}\\r\\nint TS_CONF_set_serial(CONF *conf, const char *section, TS_serial_cb cb,\\r\\nTS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nchar *serial = NCONF_get_string(conf, section, ENV_SERIAL);\\r\\nif (!serial) {\\r\\nTS_CONF_lookup_fail(section, ENV_SERIAL);\\r\\ngoto err;\\r\\n}\\r\\nTS_RESP_CTX_set_serial_cb(ctx, cb, serial);\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_crypto_device(CONF *conf, const char *section,\\r\\nconst char *device)\\r\\n{\\r\\nint ret = 0;\\r\\nif (!device)\\r\\ndevice = NCONF_get_string(conf, section, ENV_CRYPTO_DEVICE);\\r\\nif (device && !TS_CONF_set_default_engine(device)) {\\r\\nTS_CONF_invalid(section, ENV_CRYPTO_DEVICE);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_default_engine(const char *name)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint ret = 0;\\r\\nif (strcmp(name, \"builtin\") == 0)\\r\\nreturn 1;\\r\\nif (!(e = ENGINE_by_id(name)))\\r\\ngoto err;\\r\\nif (strcmp(name, \"chil\") == 0)\\r\\nENGINE_ctrl(e, ENGINE_CTRL_CHIL_SET_FORKCHECK, 1, 0, 0);\\r\\nif (!ENGINE_set_default(e, ENGINE_METHOD_ALL))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret) {\\r\\nTSerr(TS_F_TS_CONF_SET_DEFAULT_ENGINE, TS_R_COULD_NOT_SET_ENGINE);\\r\\nERR_add_error_data(2, \"engine:\", name);\\r\\n}\\r\\nif (e)\\r\\nENGINE_free(e);\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_signer_cert(CONF *conf, const char *section,\\r\\nconst char *cert, TS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nX509 *cert_obj = NULL;\\r\\nif (!cert)\\r\\ncert = NCONF_get_string(conf, section, ENV_SIGNER_CERT);\\r\\nif (!cert) {\\r\\nTS_CONF_lookup_fail(section, ENV_SIGNER_CERT);\\r\\ngoto err;\\r\\n}\\r\\nif (!(cert_obj = TS_CONF_load_cert(cert)))\\r\\ngoto err;\\r\\nif (!TS_RESP_CTX_set_signer_cert(ctx, cert_obj))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nX509_free(cert_obj);\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_certs(CONF *conf, const char *section, const char *certs,\\r\\nTS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nSTACK_OF(X509) *certs_obj = NULL;\\r\\nif (!certs)\\r\\ncerts = NCONF_get_string(conf, section, ENV_CERTS);\\r\\nif (!certs)\\r\\ngoto end;\\r\\nif (!(certs_obj = TS_CONF_load_certs(certs)))\\r\\ngoto err;\\r\\nif (!TS_RESP_CTX_set_certs(ctx, certs_obj))\\r\\ngoto err;\\r\\nend:\\r\\nret = 1;\\r\\nerr:\\r\\nsk_X509_pop_free(certs_obj, X509_free);\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_signer_key(CONF *conf, const char *section,\\r\\nconst char *key, const char *pass,\\r\\nTS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nEVP_PKEY *key_obj = NULL;\\r\\nif (!key)\\r\\nkey = NCONF_get_string(conf, section, ENV_SIGNER_KEY);\\r\\nif (!key) {\\r\\nTS_CONF_lookup_fail(section, ENV_SIGNER_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (!(key_obj = TS_CONF_load_key(key, pass)))\\r\\ngoto err;\\r\\nif (!TS_RESP_CTX_set_signer_key(ctx, key_obj))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nEVP_PKEY_free(key_obj);\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_def_policy(CONF *conf, const char *section,\\r\\nconst char *policy, TS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nASN1_OBJECT *policy_obj = NULL;\\r\\nif (!policy)\\r\\npolicy = NCONF_get_string(conf, section, ENV_DEFAULT_POLICY);\\r\\nif (!policy) {\\r\\nTS_CONF_lookup_fail(section, ENV_DEFAULT_POLICY);\\r\\ngoto err;\\r\\n}\\r\\nif (!(policy_obj = OBJ_txt2obj(policy, 0))) {\\r\\nTS_CONF_invalid(section, ENV_DEFAULT_POLICY);\\r\\ngoto err;\\r\\n}\\r\\nif (!TS_RESP_CTX_set_def_policy(ctx, policy_obj))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nASN1_OBJECT_free(policy_obj);\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_policies(CONF *conf, const char *section, TS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nint i;\\r\\nSTACK_OF(CONF_VALUE) *list = NULL;\\r\\nchar *policies = NCONF_get_string(conf, section,\\r\\nENV_OTHER_POLICIES);\\r\\nif (policies && !(list = X509V3_parse_list(policies))) {\\r\\nTS_CONF_invalid(section, ENV_OTHER_POLICIES);\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(list); ++i) {\\r\\nCONF_VALUE *val = sk_CONF_VALUE_value(list, i);\\r\\nconst char *extval = val->value ? val->value : val->name;\\r\\nASN1_OBJECT *objtmp;\\r\\nif (!(objtmp = OBJ_txt2obj(extval, 0))) {\\r\\nTS_CONF_invalid(section, ENV_OTHER_POLICIES);\\r\\ngoto err;\\r\\n}\\r\\nif (!TS_RESP_CTX_add_policy(ctx, objtmp))\\r\\ngoto err;\\r\\nASN1_OBJECT_free(objtmp);\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nsk_CONF_VALUE_pop_free(list, X509V3_conf_free);\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_digests(CONF *conf, const char *section, TS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nint i;\\r\\nSTACK_OF(CONF_VALUE) *list = NULL;\\r\\nchar *digests = NCONF_get_string(conf, section, ENV_DIGESTS);\\r\\nif (!digests) {\\r\\nTS_CONF_lookup_fail(section, ENV_DIGESTS);\\r\\ngoto err;\\r\\n}\\r\\nif (!(list = X509V3_parse_list(digests))) {\\r\\nTS_CONF_invalid(section, ENV_DIGESTS);\\r\\ngoto err;\\r\\n}\\r\\nif (sk_CONF_VALUE_num(list) == 0) {\\r\\nTS_CONF_invalid(section, ENV_DIGESTS);\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(list); ++i) {\\r\\nCONF_VALUE *val = sk_CONF_VALUE_value(list, i);\\r\\nconst char *extval = val->value ? val->value : val->name;\\r\\nconst EVP_MD *md;\\r\\nif (!(md = EVP_get_digestbyname(extval))) {\\r\\nTS_CONF_invalid(section, ENV_DIGESTS);\\r\\ngoto err;\\r\\n}\\r\\nif (!TS_RESP_CTX_add_md(ctx, md))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nsk_CONF_VALUE_pop_free(list, X509V3_conf_free);\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_accuracy(CONF *conf, const char *section, TS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nint i;\\r\\nint secs = 0, millis = 0, micros = 0;\\r\\nSTACK_OF(CONF_VALUE) *list = NULL;\\r\\nchar *accuracy = NCONF_get_string(conf, section, ENV_ACCURACY);\\r\\nif (accuracy && !(list = X509V3_parse_list(accuracy))) {\\r\\nTS_CONF_invalid(section, ENV_ACCURACY);\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(list); ++i) {\\r\\nCONF_VALUE *val = sk_CONF_VALUE_value(list, i);\\r\\nif (strcmp(val->name, ENV_VALUE_SECS) == 0) {\\r\\nif (val->value)\\r\\nsecs = atoi(val->value);\\r\\n} else if (strcmp(val->name, ENV_VALUE_MILLISECS) == 0) {\\r\\nif (val->value)\\r\\nmillis = atoi(val->value);\\r\\n} else if (strcmp(val->name, ENV_VALUE_MICROSECS) == 0) {\\r\\nif (val->value)\\r\\nmicros = atoi(val->value);\\r\\n} else {\\r\\nTS_CONF_invalid(section, ENV_ACCURACY);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!TS_RESP_CTX_set_accuracy(ctx, secs, millis, micros))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nsk_CONF_VALUE_pop_free(list, X509V3_conf_free);\\r\\nreturn ret;\\r\\n}\\r\\nint TS_CONF_set_clock_precision_digits(CONF *conf, const char *section,\\r\\nTS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nlong digits = 0;\\r\\nif (!NCONF_get_number_e(conf, section, ENV_CLOCK_PRECISION_DIGITS,\\r\\n&digits))\\r\\ndigits = 0;\\r\\nif (digits < 0 || digits > TS_MAX_CLOCK_PRECISION_DIGITS) {\\r\\nTS_CONF_invalid(section, ENV_CLOCK_PRECISION_DIGITS);\\r\\ngoto err;\\r\\n}\\r\\nif (!TS_RESP_CTX_set_clock_precision_digits(ctx, digits))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nstatic int TS_CONF_add_flag(CONF *conf, const char *section,\\r\\nconst char *field, int flag, TS_RESP_CTX *ctx)\\r\\n{\\r\\nconst char *value = NCONF_get_string(conf, section, field);\\r\\nif (value) {\\r\\nif (strcmp(value, ENV_VALUE_YES) == 0)\\r\\nTS_RESP_CTX_add_flags(ctx, flag);\\r\\nelse if (strcmp(value, ENV_VALUE_NO) != 0) {\\r\\nTS_CONF_invalid(section, field);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint TS_CONF_set_ordering(CONF *conf, const char *section, TS_RESP_CTX *ctx)\\r\\n{\\r\\nreturn TS_CONF_add_flag(conf, section, ENV_ORDERING, TS_ORDERING, ctx);\\r\\n}\\r\\nint TS_CONF_set_tsa_name(CONF *conf, const char *section, TS_RESP_CTX *ctx)\\r\\n{\\r\\nreturn TS_CONF_add_flag(conf, section, ENV_TSA_NAME, TS_TSA_NAME, ctx);\\r\\n}\\r\\nint TS_CONF_set_ess_cert_id_chain(CONF *conf, const char *section,\\r\\nTS_RESP_CTX *ctx)\\r\\n{\\r\\nreturn TS_CONF_add_flag(conf, section, ENV_ESS_CERT_ID_CHAIN,\\r\\nTS_ESS_CERT_ID_CHAIN, ctx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_aes_ecb_c", "target": 0, "func": "void AES_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst AES_KEY *key, const int enc)\\r\\n{\\r\\nassert(in && out && key);\\r\\nassert((AES_ENCRYPT == enc) || (AES_DECRYPT == enc));\\r\\nif (AES_ENCRYPT == enc)\\r\\nAES_encrypt(in, out, key);\\r\\nelse\\r\\nAES_decrypt(in, out, key);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pk7_attr_c", "target": 0, "func": "int PKCS7_add_attrib_content_type(PKCS7_SIGNER_INFO *si, ASN1_OBJECT *coid)\\r\\n{\\r\\nif (PKCS7_get_signed_attribute(si, NID_pkcs9_contentType))\\r\\nreturn 0;\\r\\nif (!coid)\\r\\ncoid = OBJ_nid2obj(NID_pkcs7_data);\\r\\nreturn PKCS7_add_signed_attribute(si, NID_pkcs9_contentType,\\r\\nV_ASN1_OBJECT, coid);\\r\\n}\\r\\nint PKCS7_add0_attrib_signing_time(PKCS7_SIGNER_INFO *si, ASN1_TIME *t)\\r\\n{\\r\\nif (!t && !(t = X509_gmtime_adj(NULL, 0))) {\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD0_ATTRIB_SIGNING_TIME,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn PKCS7_add_signed_attribute(si, NID_pkcs9_signingTime,\\r\\nV_ASN1_UTCTIME, t);\\r\\n}\\r\\nint PKCS7_add1_attrib_digest(PKCS7_SIGNER_INFO *si,\\r\\nconst unsigned char *md, int mdlen)\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nos = ASN1_OCTET_STRING_new();\\r\\nif (!os)\\r\\nreturn 0;\\r\\nif (!ASN1_STRING_set(os, md, mdlen)\\r\\n|| !PKCS7_add_signed_attribute(si, NID_pkcs9_messageDigest,\\r\\nV_ASN1_OCTET_STRING, os)) {\\r\\nASN1_OCTET_STRING_free(os);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc4_enc_c", "target": 0, "func": "void RC4(RC4_KEY *key, size_t len, const unsigned char *indata,\\r\\nunsigned char *outdata)\\r\\n{\\r\\nregister RC4_INT *d;\\r\\nregister RC4_INT x, y, tx, ty;\\r\\nsize_t i;\\r\\nx = key->x;\\r\\ny = key->y;\\r\\nd = key->data;\\r\\n#if defined(RC4_CHUNK) && !defined(PEDANTIC)\\r\\n# define RC4_STEP ( \\\\r\\nx=(x+1) &0xff, \\\\r\\ntx=d[x], \\\\r\\ny=(tx+y)&0xff, \\\\r\\nty=d[y], \\\\r\\nd[y]=tx, \\\\r\\nd[x]=ty, \\\\r\\n(RC4_CHUNK)d[(tx+ty)&0xff]\\\\r\\n)\\r\\nif ((((size_t)indata & (sizeof(RC4_CHUNK) - 1)) |\\r\\n((size_t)outdata & (sizeof(RC4_CHUNK) - 1))) == 0) {\\r\\nRC4_CHUNK ichunk, otp;\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nif (!is_endian.little) {\\r\\n# define BESHFT(c) (((sizeof(RC4_CHUNK)-(c)-1)*8)&(sizeof(RC4_CHUNK)*8-1))\\r\\nfor (; len & (0 - sizeof(RC4_CHUNK)); len -= sizeof(RC4_CHUNK)) {\\r\\nichunk = *(RC4_CHUNK *) indata;\\r\\notp = RC4_STEP << BESHFT(0);\\r\\notp |= RC4_STEP << BESHFT(1);\\r\\notp |= RC4_STEP << BESHFT(2);\\r\\notp |= RC4_STEP << BESHFT(3);\\r\\nif (sizeof(RC4_CHUNK) == 8) {\\r\\notp |= RC4_STEP << BESHFT(4);\\r\\notp |= RC4_STEP << BESHFT(5);\\r\\notp |= RC4_STEP << BESHFT(6);\\r\\notp |= RC4_STEP << BESHFT(7);\\r\\n}\\r\\n*(RC4_CHUNK *) outdata = otp ^ ichunk;\\r\\nindata += sizeof(RC4_CHUNK);\\r\\noutdata += sizeof(RC4_CHUNK);\\r\\n}\\r\\nif (len) {\\r\\nRC4_CHUNK mask = (RC4_CHUNK) - 1, ochunk;\\r\\nichunk = *(RC4_CHUNK *) indata;\\r\\nochunk = *(RC4_CHUNK *) outdata;\\r\\notp = 0;\\r\\ni = BESHFT(0);\\r\\nmask <<= (sizeof(RC4_CHUNK) - len) << 3;\\r\\nswitch (len & (sizeof(RC4_CHUNK) - 1)) {\\r\\ncase 7:\\r\\notp = RC4_STEP << i, i -= 8;\\r\\ncase 6:\\r\\notp |= RC4_STEP << i, i -= 8;\\r\\ncase 5:\\r\\notp |= RC4_STEP << i, i -= 8;\\r\\ncase 4:\\r\\notp |= RC4_STEP << i, i -= 8;\\r\\ncase 3:\\r\\notp |= RC4_STEP << i, i -= 8;\\r\\ncase 2:\\r\\notp |= RC4_STEP << i, i -= 8;\\r\\ncase 1:\\r\\notp |= RC4_STEP << i, i -= 8;\\r\\ncase 0:;\\r\\n}\\r\\nochunk &= ~mask;\\r\\nochunk |= (otp ^ ichunk) & mask;\\r\\n*(RC4_CHUNK *) outdata = ochunk;\\r\\n}\\r\\nkey->x = x;\\r\\nkey->y = y;\\r\\nreturn;\\r\\n} else {\\r\\n# define LESHFT(c) (((c)*8)&(sizeof(RC4_CHUNK)*8-1))\\r\\nfor (; len & (0 - sizeof(RC4_CHUNK)); len -= sizeof(RC4_CHUNK)) {\\r\\nichunk = *(RC4_CHUNK *) indata;\\r\\notp = RC4_STEP;\\r\\notp |= RC4_STEP << 8;\\r\\notp |= RC4_STEP << 16;\\r\\notp |= RC4_STEP << 24;\\r\\nif (sizeof(RC4_CHUNK) == 8) {\\r\\notp |= RC4_STEP << LESHFT(4);\\r\\notp |= RC4_STEP << LESHFT(5);\\r\\notp |= RC4_STEP << LESHFT(6);\\r\\notp |= RC4_STEP << LESHFT(7);\\r\\n}\\r\\n*(RC4_CHUNK *) outdata = otp ^ ichunk;\\r\\nindata += sizeof(RC4_CHUNK);\\r\\noutdata += sizeof(RC4_CHUNK);\\r\\n}\\r\\nif (len) {\\r\\nRC4_CHUNK mask = (RC4_CHUNK) - 1, ochunk;\\r\\nichunk = *(RC4_CHUNK *) indata;\\r\\nochunk = *(RC4_CHUNK *) outdata;\\r\\notp = 0;\\r\\ni = 0;\\r\\nmask >>= (sizeof(RC4_CHUNK) - len) << 3;\\r\\nswitch (len & (sizeof(RC4_CHUNK) - 1)) {\\r\\ncase 7:\\r\\notp = RC4_STEP, i += 8;\\r\\ncase 6:\\r\\notp |= RC4_STEP << i, i += 8;\\r\\ncase 5:\\r\\notp |= RC4_STEP << i, i += 8;\\r\\ncase 4:\\r\\notp |= RC4_STEP << i, i += 8;\\r\\ncase 3:\\r\\notp |= RC4_STEP << i, i += 8;\\r\\ncase 2:\\r\\notp |= RC4_STEP << i, i += 8;\\r\\ncase 1:\\r\\notp |= RC4_STEP << i, i += 8;\\r\\ncase 0:;\\r\\n}\\r\\nochunk &= ~mask;\\r\\nochunk |= (otp ^ ichunk) & mask;\\r\\n*(RC4_CHUNK *) outdata = ochunk;\\r\\n}\\r\\nkey->x = x;\\r\\nkey->y = y;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#define LOOP(in,out) \\\\r\\nx=((x+1)&0xff); \\\\r\\ntx=d[x]; \\\\r\\ny=(tx+y)&0xff; \\\\r\\nd[x]=ty=d[y]; \\\\r\\nd[y]=tx; \\\\r\\n(out) = d[(tx+ty)&0xff]^ (in);\\r\\n#ifndef RC4_INDEX\\r\\n# define RC4_LOOP(a,b,i) LOOP(*((a)++),*((b)++))\\r\\n#else\\r\\n# define RC4_LOOP(a,b,i) LOOP(a[i],b[i])\\r\\n#endif\\r\\ni = len >> 3;\\r\\nif (i) {\\r\\nfor (;;) {\\r\\nRC4_LOOP(indata, outdata, 0);\\r\\nRC4_LOOP(indata, outdata, 1);\\r\\nRC4_LOOP(indata, outdata, 2);\\r\\nRC4_LOOP(indata, outdata, 3);\\r\\nRC4_LOOP(indata, outdata, 4);\\r\\nRC4_LOOP(indata, outdata, 5);\\r\\nRC4_LOOP(indata, outdata, 6);\\r\\nRC4_LOOP(indata, outdata, 7);\\r\\n#ifdef RC4_INDEX\\r\\nindata += 8;\\r\\noutdata += 8;\\r\\n#endif\\r\\nif (--i == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\ni = len & 0x07;\\r\\nif (i) {\\r\\nfor (;;) {\\r\\nRC4_LOOP(indata, outdata, 0);\\r\\nif (--i == 0)\\r\\nbreak;\\r\\nRC4_LOOP(indata, outdata, 1);\\r\\nif (--i == 0)\\r\\nbreak;\\r\\nRC4_LOOP(indata, outdata, 2);\\r\\nif (--i == 0)\\r\\nbreak;\\r\\nRC4_LOOP(indata, outdata, 3);\\r\\nif (--i == 0)\\r\\nbreak;\\r\\nRC4_LOOP(indata, outdata, 4);\\r\\nif (--i == 0)\\r\\nbreak;\\r\\nRC4_LOOP(indata, outdata, 5);\\r\\nif (--i == 0)\\r\\nbreak;\\r\\nRC4_LOOP(indata, outdata, 6);\\r\\nif (--i == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nkey->x = x;\\r\\nkey->y = y;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_apps_c", "target": 0, "func": "int args_from_file(char *file, int *argc, char **argv[])\\r\\n{\\r\\nFILE *fp;\\r\\nint num, i;\\r\\nunsigned int len;\\r\\nstatic char *buf = NULL;\\r\\nstatic char **arg = NULL;\\r\\nchar *p;\\r\\nfp = fopen(file, \"r\");\\r\\nif (fp == NULL)\\r\\nreturn (0);\\r\\nif (fseek(fp, 0, SEEK_END) == 0)\\r\\nlen = ftell(fp), rewind(fp);\\r\\nelse\\r\\nlen = -1;\\r\\nif (len <= 0) {\\r\\nfclose(fp);\\r\\nreturn (0);\\r\\n}\\r\\n*argc = 0;\\r\\n*argv = NULL;\\r\\nif (buf != NULL)\\r\\nOPENSSL_free(buf);\\r\\nbuf = (char *)OPENSSL_malloc(len + 1);\\r\\nif (buf == NULL)\\r\\nreturn (0);\\r\\nlen = fread(buf, 1, len, fp);\\r\\nif (len <= 1)\\r\\nreturn (0);\\r\\nbuf[len] = '\\0';\\r\\ni = 0;\\r\\nfor (p = buf; *p; p++)\\r\\nif (*p == '\\n')\\r\\ni++;\\r\\nif (arg != NULL)\\r\\nOPENSSL_free(arg);\\r\\narg = (char **)OPENSSL_malloc(sizeof(char *) * (i * 2));\\r\\n*argv = arg;\\r\\nnum = 0;\\r\\np = buf;\\r\\nfor (;;) {\\r\\nif (!*p)\\r\\nbreak;\\r\\nif (*p == '#') {\\r\\nwhile (*p && (*p != '\\n'))\\r\\np++;\\r\\ncontinue;\\r\\n}\\r\\n*(arg++) = p;\\r\\nnum++;\\r\\nwhile (*p && ((*p != ' ') && (*p != '\\t') && (*p != '\\n')))\\r\\np++;\\r\\nif (!*p)\\r\\nbreak;\\r\\nif (*p == '\\n') {\\r\\n*(p++) = '\\0';\\r\\ncontinue;\\r\\n}\\r\\np++;\\r\\nwhile (*p && ((*p == ' ') || (*p == '\\t') || (*p == '\\n')))\\r\\np++;\\r\\nif (!*p)\\r\\nbreak;\\r\\nif (*p == '\\n') {\\r\\np++;\\r\\ncontinue;\\r\\n}\\r\\n*(arg++) = p++;\\r\\nnum++;\\r\\nwhile (*p && (*p != '\\n'))\\r\\np++;\\r\\nif (!*p)\\r\\nbreak;\\r\\n*(p++) = '\\0';\\r\\n}\\r\\n*argc = num;\\r\\nreturn (1);\\r\\n}\\r\\nint str2fmt(char *s)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn FORMAT_UNDEF;\\r\\nif ((*s == 'D') || (*s == 'd'))\\r\\nreturn (FORMAT_ASN1);\\r\\nelse if ((*s == 'T') || (*s == 't'))\\r\\nreturn (FORMAT_TEXT);\\r\\nelse if ((*s == 'N') || (*s == 'n'))\\r\\nreturn (FORMAT_NETSCAPE);\\r\\nelse if ((*s == 'S') || (*s == 's'))\\r\\nreturn (FORMAT_SMIME);\\r\\nelse if ((*s == 'M') || (*s == 'm'))\\r\\nreturn (FORMAT_MSBLOB);\\r\\nelse if ((*s == '1')\\r\\n|| (strcmp(s, \"PKCS12\") == 0) || (strcmp(s, \"pkcs12\") == 0)\\r\\n|| (strcmp(s, \"P12\") == 0) || (strcmp(s, \"p12\") == 0))\\r\\nreturn (FORMAT_PKCS12);\\r\\nelse if ((*s == 'E') || (*s == 'e'))\\r\\nreturn (FORMAT_ENGINE);\\r\\nelse if ((*s == 'H') || (*s == 'h'))\\r\\nreturn FORMAT_HTTP;\\r\\nelse if ((*s == 'P') || (*s == 'p')) {\\r\\nif (s[1] == 'V' || s[1] == 'v')\\r\\nreturn FORMAT_PVK;\\r\\nelse\\r\\nreturn (FORMAT_PEM);\\r\\n} else\\r\\nreturn (FORMAT_UNDEF);\\r\\n}\\r\\nvoid program_name(char *in, char *out, int size)\\r\\n{\\r\\nint i, n;\\r\\nchar *p = NULL;\\r\\nn = strlen(in);\\r\\nfor (i = n - 1; i > 0; i--) {\\r\\nif ((in[i] == '/') || (in[i] == '\\\\') || (in[i] == ':')) {\\r\\np = &(in[i + 1]);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (p == NULL)\\r\\np = in;\\r\\nn = strlen(p);\\r\\n# if defined(OPENSSL_SYS_NETWARE)\\r\\nif ((n > 4) && (p[n - 4] == '.') &&\\r\\n((p[n - 3] == 'n') || (p[n - 3] == 'N')) &&\\r\\n((p[n - 2] == 'l') || (p[n - 2] == 'L')) &&\\r\\n((p[n - 1] == 'm') || (p[n - 1] == 'M')))\\r\\nn -= 4;\\r\\n# else\\r\\nif ((n > 4) && (p[n - 4] == '.') &&\\r\\n((p[n - 3] == 'e') || (p[n - 3] == 'E')) &&\\r\\n((p[n - 2] == 'x') || (p[n - 2] == 'X')) &&\\r\\n((p[n - 1] == 'e') || (p[n - 1] == 'E')))\\r\\nn -= 4;\\r\\n# endif\\r\\nif (n > size - 1)\\r\\nn = size - 1;\\r\\nfor (i = 0; i < n; i++) {\\r\\nif ((p[i] >= 'A') && (p[i] <= 'Z'))\\r\\nout[i] = p[i] - 'A' + 'a';\\r\\nelse\\r\\nout[i] = p[i];\\r\\n}\\r\\nout[n] = '\\0';\\r\\n}\\r\\nvoid program_name(char *in, char *out, int size)\\r\\n{\\r\\nchar *p = in, *q;\\r\\nchar *chars = \":]>\";\\r\\nwhile (*chars != '\\0') {\\r\\nq = strrchr(p, *chars);\\r\\nif (q > p)\\r\\np = q + 1;\\r\\nchars++;\\r\\n}\\r\\nq = strrchr(p, '.');\\r\\nif (q == NULL)\\r\\nq = p + strlen(p);\\r\\nstrncpy(out, p, size - 1);\\r\\nif (q - p >= size) {\\r\\nout[size - 1] = '\\0';\\r\\n} else {\\r\\nout[q - p] = '\\0';\\r\\n}\\r\\n}\\r\\nvoid program_name(char *in, char *out, int size)\\r\\n{\\r\\nchar *p;\\r\\np = strrchr(in, '/');\\r\\nif (p != NULL)\\r\\np++;\\r\\nelse\\r\\np = in;\\r\\nBUF_strlcpy(out, p, size);\\r\\n}\\r\\nint chopup_args(ARGS *arg, char *buf, int *argc, char **argv[])\\r\\n{\\r\\nint num, i;\\r\\nchar *p;\\r\\n*argc = 0;\\r\\n*argv = NULL;\\r\\ni = 0;\\r\\nif (arg->count == 0) {\\r\\narg->count = 20;\\r\\narg->data = (char **)OPENSSL_malloc(sizeof(char *) * arg->count);\\r\\nif (arg->data == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < arg->count; i++)\\r\\narg->data[i] = NULL;\\r\\nnum = 0;\\r\\np = buf;\\r\\nfor (;;) {\\r\\nif (!*p)\\r\\nbreak;\\r\\nwhile (*p && ((*p == ' ') || (*p == '\\t') || (*p == '\\n')))\\r\\np++;\\r\\nif (!*p)\\r\\nbreak;\\r\\nif (num >= arg->count) {\\r\\nchar **tmp_p;\\r\\nint tlen = arg->count + 20;\\r\\ntmp_p = (char **)OPENSSL_realloc(arg->data,\\r\\nsizeof(char *) * tlen);\\r\\nif (tmp_p == NULL)\\r\\nreturn 0;\\r\\narg->data = tmp_p;\\r\\narg->count = tlen;\\r\\nfor (i = num; i < arg->count; i++)\\r\\narg->data[i] = NULL;\\r\\n}\\r\\narg->data[num++] = p;\\r\\nif ((*p == '\\'') || (*p == '\\\"')) {\\r\\ni = *(p++);\\r\\narg->data[num - 1]++;\\r\\nwhile (*p && (*p != i))\\r\\np++;\\r\\n*p = '\\0';\\r\\n} else {\\r\\nwhile (*p && ((*p != ' ') && (*p != '\\t') && (*p != '\\n')))\\r\\np++;\\r\\nif (*p == '\\0')\\r\\np--;\\r\\nelse\\r\\n*p = '\\0';\\r\\n}\\r\\np++;\\r\\n}\\r\\n*argc = num;\\r\\n*argv = arg->data;\\r\\nreturn (1);\\r\\n}\\r\\nint app_init(long mesgwin)\\r\\n{\\r\\nreturn (1);\\r\\n}\\r\\nint dump_cert_text(BIO *out, X509 *x)\\r\\n{\\r\\nchar *p;\\r\\np = X509_NAME_oneline(X509_get_subject_name(x), NULL, 0);\\r\\nBIO_puts(out, \"subject=\");\\r\\nBIO_puts(out, p);\\r\\nOPENSSL_free(p);\\r\\np = X509_NAME_oneline(X509_get_issuer_name(x), NULL, 0);\\r\\nBIO_puts(out, \"\\nissuer=\");\\r\\nBIO_puts(out, p);\\r\\nBIO_puts(out, \"\\n\");\\r\\nOPENSSL_free(p);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ui_open(UI *ui)\\r\\n{\\r\\nreturn UI_method_get_opener(UI_OpenSSL())(ui);\\r\\n}\\r\\nstatic int ui_read(UI *ui, UI_STRING *uis)\\r\\n{\\r\\nif (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD\\r\\n&& UI_get0_user_data(ui)) {\\r\\nswitch (UI_get_string_type(uis)) {\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\n{\\r\\nconst char *password =\\r\\n((PW_CB_DATA *)UI_get0_user_data(ui))->password;\\r\\nif (password && password[0] != '\\0') {\\r\\nUI_set_result(ui, uis, password);\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn UI_method_get_reader(UI_OpenSSL())(ui, uis);\\r\\n}\\r\\nstatic int ui_write(UI *ui, UI_STRING *uis)\\r\\n{\\r\\nif (UI_get_input_flags(uis) & UI_INPUT_FLAG_DEFAULT_PWD\\r\\n&& UI_get0_user_data(ui)) {\\r\\nswitch (UI_get_string_type(uis)) {\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\n{\\r\\nconst char *password =\\r\\n((PW_CB_DATA *)UI_get0_user_data(ui))->password;\\r\\nif (password && password[0] != '\\0')\\r\\nreturn 1;\\r\\n}\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn UI_method_get_writer(UI_OpenSSL())(ui, uis);\\r\\n}\\r\\nstatic int ui_close(UI *ui)\\r\\n{\\r\\nreturn UI_method_get_closer(UI_OpenSSL())(ui);\\r\\n}\\r\\nint setup_ui_method(void)\\r\\n{\\r\\nui_method = UI_create_method(\"OpenSSL application user interface\");\\r\\nUI_method_set_opener(ui_method, ui_open);\\r\\nUI_method_set_reader(ui_method, ui_read);\\r\\nUI_method_set_writer(ui_method, ui_write);\\r\\nUI_method_set_closer(ui_method, ui_close);\\r\\nreturn 0;\\r\\n}\\r\\nvoid destroy_ui_method(void)\\r\\n{\\r\\nif (ui_method) {\\r\\nUI_destroy_method(ui_method);\\r\\nui_method = NULL;\\r\\n}\\r\\n}\\r\\nint password_callback(char *buf, int bufsiz, int verify, PW_CB_DATA *cb_tmp)\\r\\n{\\r\\nUI *ui = NULL;\\r\\nint res = 0;\\r\\nconst char *prompt_info = NULL;\\r\\nconst char *password = NULL;\\r\\nPW_CB_DATA *cb_data = (PW_CB_DATA *)cb_tmp;\\r\\nif (cb_data) {\\r\\nif (cb_data->password)\\r\\npassword = cb_data->password;\\r\\nif (cb_data->prompt_info)\\r\\nprompt_info = cb_data->prompt_info;\\r\\n}\\r\\nif (password) {\\r\\nres = strlen(password);\\r\\nif (res > bufsiz)\\r\\nres = bufsiz;\\r\\nmemcpy(buf, password, res);\\r\\nreturn res;\\r\\n}\\r\\nui = UI_new_method(ui_method);\\r\\nif (ui) {\\r\\nint ok = 0;\\r\\nchar *buff = NULL;\\r\\nint ui_flags = 0;\\r\\nchar *prompt = NULL;\\r\\nprompt = UI_construct_prompt(ui, \"pass phrase\", prompt_info);\\r\\nui_flags |= UI_INPUT_FLAG_DEFAULT_PWD;\\r\\nUI_ctrl(ui, UI_CTRL_PRINT_ERRORS, 1, 0, 0);\\r\\nif (ok >= 0)\\r\\nok = UI_add_input_string(ui, prompt, ui_flags, buf,\\r\\nPW_MIN_LENGTH, bufsiz - 1);\\r\\nif (ok >= 0 && verify) {\\r\\nbuff = (char *)OPENSSL_malloc(bufsiz);\\r\\nok = UI_add_verify_string(ui, prompt, ui_flags, buff,\\r\\nPW_MIN_LENGTH, bufsiz - 1, buf);\\r\\n}\\r\\nif (ok >= 0)\\r\\ndo {\\r\\nok = UI_process(ui);\\r\\n}\\r\\nwhile (ok < 0 && UI_ctrl(ui, UI_CTRL_IS_REDOABLE, 0, 0, 0));\\r\\nif (buff) {\\r\\nOPENSSL_cleanse(buff, (unsigned int)bufsiz);\\r\\nOPENSSL_free(buff);\\r\\n}\\r\\nif (ok >= 0)\\r\\nres = strlen(buf);\\r\\nif (ok == -1) {\\r\\nBIO_printf(bio_err, \"User interface error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nOPENSSL_cleanse(buf, (unsigned int)bufsiz);\\r\\nres = 0;\\r\\n}\\r\\nif (ok == -2) {\\r\\nBIO_printf(bio_err, \"aborted!\\n\");\\r\\nOPENSSL_cleanse(buf, (unsigned int)bufsiz);\\r\\nres = 0;\\r\\n}\\r\\nUI_free(ui);\\r\\nOPENSSL_free(prompt);\\r\\n}\\r\\nreturn res;\\r\\n}\\r\\nint app_passwd(BIO *err, char *arg1, char *arg2, char **pass1, char **pass2)\\r\\n{\\r\\nint same;\\r\\nif (!arg2 || !arg1 || strcmp(arg1, arg2))\\r\\nsame = 0;\\r\\nelse\\r\\nsame = 1;\\r\\nif (arg1) {\\r\\n*pass1 = app_get_pass(err, arg1, same);\\r\\nif (!*pass1)\\r\\nreturn 0;\\r\\n} else if (pass1)\\r\\n*pass1 = NULL;\\r\\nif (arg2) {\\r\\n*pass2 = app_get_pass(err, arg2, same ? 2 : 0);\\r\\nif (!*pass2)\\r\\nreturn 0;\\r\\n} else if (pass2)\\r\\n*pass2 = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic char *app_get_pass(BIO *err, char *arg, int keepbio)\\r\\n{\\r\\nchar *tmp, tpass[APP_PASS_LEN];\\r\\nstatic BIO *pwdbio = NULL;\\r\\nint i;\\r\\nif (!strncmp(arg, \"pass:\", 5))\\r\\nreturn BUF_strdup(arg + 5);\\r\\nif (!strncmp(arg, \"env:\", 4)) {\\r\\ntmp = getenv(arg + 4);\\r\\nif (!tmp) {\\r\\nBIO_printf(err, \"Can't read environment variable %s\\n\", arg + 4);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn BUF_strdup(tmp);\\r\\n}\\r\\nif (!keepbio || !pwdbio) {\\r\\nif (!strncmp(arg, \"file:\", 5)) {\\r\\npwdbio = BIO_new_file(arg + 5, \"r\");\\r\\nif (!pwdbio) {\\r\\nBIO_printf(err, \"Can't open file %s\\n\", arg + 5);\\r\\nreturn NULL;\\r\\n}\\r\\n#if !defined(_WIN32)\\r\\n} else if (!strncmp(arg, \"fd:\", 3)) {\\r\\nBIO *btmp;\\r\\ni = atoi(arg + 3);\\r\\nif (i >= 0)\\r\\npwdbio = BIO_new_fd(i, BIO_NOCLOSE);\\r\\nif ((i < 0) || !pwdbio) {\\r\\nBIO_printf(err, \"Can't access file descriptor %s\\n\", arg + 3);\\r\\nreturn NULL;\\r\\n}\\r\\nbtmp = BIO_new(BIO_f_buffer());\\r\\npwdbio = BIO_push(btmp, pwdbio);\\r\\n#endif\\r\\n} else if (!strcmp(arg, \"stdin\")) {\\r\\npwdbio = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (!pwdbio) {\\r\\nBIO_printf(err, \"Can't open BIO for stdin\\n\");\\r\\nreturn NULL;\\r\\n}\\r\\n} else {\\r\\nBIO_printf(err, \"Invalid password argument \\\"%s\\\"\\n\", arg);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\ni = BIO_gets(pwdbio, tpass, APP_PASS_LEN);\\r\\nif (keepbio != 1) {\\r\\nBIO_free_all(pwdbio);\\r\\npwdbio = NULL;\\r\\n}\\r\\nif (i <= 0) {\\r\\nBIO_printf(err, \"Error reading password from BIO\\n\");\\r\\nreturn NULL;\\r\\n}\\r\\ntmp = strchr(tpass, '\\n');\\r\\nif (tmp)\\r\\n*tmp = 0;\\r\\nreturn BUF_strdup(tpass);\\r\\n}\\r\\nint add_oid_section(BIO *err, CONF *conf)\\r\\n{\\r\\nchar *p;\\r\\nSTACK_OF(CONF_VALUE) *sktmp;\\r\\nCONF_VALUE *cnf;\\r\\nint i;\\r\\nif (!(p = NCONF_get_string(conf, NULL, \"oid_section\"))) {\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nif (!(sktmp = NCONF_get_section(conf, p))) {\\r\\nBIO_printf(err, \"problem loading oid section %s\\n\", p);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {\\r\\ncnf = sk_CONF_VALUE_value(sktmp, i);\\r\\nif (OBJ_create(cnf->value, cnf->name, cnf->name) == NID_undef) {\\r\\nBIO_printf(err, \"problem creating object %s=%s\\n\",\\r\\ncnf->name, cnf->value);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint load_cert_crl_http(const char *url, BIO *err,\\r\\nX509 **pcert, X509_CRL **pcrl)\\r\\n{\\r\\nchar *host = NULL, *port = NULL, *path = NULL;\\r\\nBIO *bio = NULL;\\r\\nOCSP_REQ_CTX *rctx = NULL;\\r\\nint use_ssl, rv = 0;\\r\\nif (!OCSP_parse_url(url, &host, &port, &path, &use_ssl))\\r\\ngoto err;\\r\\nif (use_ssl) {\\r\\nif (err)\\r\\nBIO_puts(err, \"https not supported\\n\");\\r\\ngoto err;\\r\\n}\\r\\nbio = BIO_new_connect(host);\\r\\nif (!bio || !BIO_set_conn_port(bio, port))\\r\\ngoto err;\\r\\nrctx = OCSP_REQ_CTX_new(bio, 1024);\\r\\nif (!rctx)\\r\\ngoto err;\\r\\nif (!OCSP_REQ_CTX_http(rctx, \"GET\", path))\\r\\ngoto err;\\r\\nif (!OCSP_REQ_CTX_add1_header(rctx, \"Host\", host))\\r\\ngoto err;\\r\\nif (pcert) {\\r\\ndo {\\r\\nrv = X509_http_nbio(rctx, pcert);\\r\\n}\\r\\nwhile (rv == -1);\\r\\n} else {\\r\\ndo {\\r\\nrv = X509_CRL_http_nbio(rctx, pcrl);\\r\\n} while (rv == -1);\\r\\n}\\r\\nerr:\\r\\nif (host)\\r\\nOPENSSL_free(host);\\r\\nif (path)\\r\\nOPENSSL_free(path);\\r\\nif (port)\\r\\nOPENSSL_free(port);\\r\\nif (bio)\\r\\nBIO_free_all(bio);\\r\\nif (rctx)\\r\\nOCSP_REQ_CTX_free(rctx);\\r\\nif (rv != 1) {\\r\\nif (bio && err)\\r\\nBIO_printf(bio_err, \"Error loading %s from %s\\n\",\\r\\npcert ? \"certificate\" : \"CRL\", url);\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nreturn rv;\\r\\n}\\r\\nX509 *load_cert(BIO *err, const char *file, int format,\\r\\nconst char *pass, ENGINE *e, const char *cert_descrip)\\r\\n{\\r\\nX509 *x = NULL;\\r\\nBIO *cert;\\r\\nif (format == FORMAT_HTTP) {\\r\\nload_cert_crl_http(file, err, &x, NULL);\\r\\nreturn x;\\r\\n}\\r\\nif ((cert = BIO_new(BIO_s_file())) == NULL) {\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (file == NULL) {\\r\\n#ifdef _IONBF\\r\\n# ifndef OPENSSL_NO_SETVBUF_IONBF\\r\\nsetvbuf(stdin, NULL, _IONBF, 0);\\r\\n# endif\\r\\n#endif\\r\\nBIO_set_fp(cert, stdin, BIO_NOCLOSE);\\r\\n} else {\\r\\nif (BIO_read_filename(cert, file) <= 0) {\\r\\nBIO_printf(err, \"Error opening %s %s\\n\", cert_descrip, file);\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\nx = d2i_X509_bio(cert, NULL);\\r\\nelse if (format == FORMAT_NETSCAPE) {\\r\\nNETSCAPE_X509 *nx;\\r\\nnx = ASN1_item_d2i_bio(ASN1_ITEM_rptr(NETSCAPE_X509), cert, NULL);\\r\\nif (nx == NULL)\\r\\ngoto end;\\r\\nif ((strncmp(NETSCAPE_CERT_HDR, (char *)nx->header->data,\\r\\nnx->header->length) != 0)) {\\r\\nNETSCAPE_X509_free(nx);\\r\\nBIO_printf(err, \"Error reading header on certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\nx = nx->cert;\\r\\nnx->cert = NULL;\\r\\nNETSCAPE_X509_free(nx);\\r\\n} else if (format == FORMAT_PEM)\\r\\nx = PEM_read_bio_X509_AUX(cert, NULL,\\r\\n(pem_password_cb *)password_callback, NULL);\\r\\nelse if (format == FORMAT_PKCS12) {\\r\\nif (!load_pkcs12(err, cert, cert_descrip, NULL, NULL, NULL, &x, NULL))\\r\\ngoto end;\\r\\n} else {\\r\\nBIO_printf(err, \"bad input format specified for %s\\n\", cert_descrip);\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (x == NULL) {\\r\\nBIO_printf(err, \"unable to load certificate\\n\");\\r\\nERR_print_errors(err);\\r\\n}\\r\\nif (cert != NULL)\\r\\nBIO_free(cert);\\r\\nreturn (x);\\r\\n}\\r\\nX509_CRL *load_crl(const char *infile, int format)\\r\\n{\\r\\nX509_CRL *x = NULL;\\r\\nBIO *in = NULL;\\r\\nif (format == FORMAT_HTTP) {\\r\\nload_cert_crl_http(infile, bio_err, NULL, &x);\\r\\nreturn x;\\r\\n}\\r\\nin = BIO_new(BIO_s_file());\\r\\nif (in == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\nx = d2i_X509_CRL_bio(in, NULL);\\r\\nelse if (format == FORMAT_PEM)\\r\\nx = PEM_read_bio_X509_CRL(in, NULL, NULL, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad input format specified for input crl\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nBIO_free(in);\\r\\nreturn (x);\\r\\n}\\r\\nEVP_PKEY *load_key(BIO *err, const char *file, int format, int maybe_stdin,\\r\\nconst char *pass, ENGINE *e, const char *key_descrip)\\r\\n{\\r\\nBIO *key = NULL;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nPW_CB_DATA cb_data;\\r\\ncb_data.password = pass;\\r\\ncb_data.prompt_info = file;\\r\\nif (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE)) {\\r\\nBIO_printf(err, \"no keyfile specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (format == FORMAT_ENGINE) {\\r\\nif (!e)\\r\\nBIO_printf(err, \"no engine specified\\n\");\\r\\nelse {\\r\\npkey = ENGINE_load_private_key(e, file, ui_method, &cb_data);\\r\\nif (!pkey) {\\r\\nBIO_printf(err, \"cannot load %s from engine\\n\", key_descrip);\\r\\nERR_print_errors(err);\\r\\n}\\r\\n}\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nkey = BIO_new(BIO_s_file());\\r\\nif (key == NULL) {\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (file == NULL && maybe_stdin) {\\r\\n#ifdef _IONBF\\r\\n# ifndef OPENSSL_NO_SETVBUF_IONBF\\r\\nsetvbuf(stdin, NULL, _IONBF, 0);\\r\\n# endif\\r\\n#endif\\r\\nBIO_set_fp(key, stdin, BIO_NOCLOSE);\\r\\n} else if (BIO_read_filename(key, file) <= 0) {\\r\\nBIO_printf(err, \"Error opening %s %s\\n\", key_descrip, file);\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (format == FORMAT_ASN1) {\\r\\npkey = d2i_PrivateKey_bio(key, NULL);\\r\\n} else if (format == FORMAT_PEM) {\\r\\npkey = PEM_read_bio_PrivateKey(key, NULL,\\r\\n(pem_password_cb *)password_callback,\\r\\n&cb_data);\\r\\n}\\r\\n#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)\\r\\nelse if (format == FORMAT_NETSCAPE || format == FORMAT_IISSGC)\\r\\npkey = load_netscape_key(err, key, file, key_descrip, format);\\r\\n#endif\\r\\nelse if (format == FORMAT_PKCS12) {\\r\\nif (!load_pkcs12(err, key, key_descrip,\\r\\n(pem_password_cb *)password_callback, &cb_data,\\r\\n&pkey, NULL, NULL))\\r\\ngoto end;\\r\\n}\\r\\n#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DSA) && !defined (OPENSSL_NO_RC4)\\r\\nelse if (format == FORMAT_MSBLOB)\\r\\npkey = b2i_PrivateKey_bio(key);\\r\\nelse if (format == FORMAT_PVK)\\r\\npkey = b2i_PVK_bio(key, (pem_password_cb *)password_callback,\\r\\n&cb_data);\\r\\n#endif\\r\\nelse {\\r\\nBIO_printf(err, \"bad input format specified for key file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (key != NULL)\\r\\nBIO_free(key);\\r\\nif (pkey == NULL) {\\r\\nBIO_printf(err, \"unable to load %s\\n\", key_descrip);\\r\\nERR_print_errors(err);\\r\\n}\\r\\nreturn (pkey);\\r\\n}\\r\\nEVP_PKEY *load_pubkey(BIO *err, const char *file, int format, int maybe_stdin,\\r\\nconst char *pass, ENGINE *e, const char *key_descrip)\\r\\n{\\r\\nBIO *key = NULL;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nPW_CB_DATA cb_data;\\r\\ncb_data.password = pass;\\r\\ncb_data.prompt_info = file;\\r\\nif (file == NULL && (!maybe_stdin || format == FORMAT_ENGINE)) {\\r\\nBIO_printf(err, \"no keyfile specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (format == FORMAT_ENGINE) {\\r\\nif (!e)\\r\\nBIO_printf(bio_err, \"no engine specified\\n\");\\r\\nelse\\r\\npkey = ENGINE_load_public_key(e, file, ui_method, &cb_data);\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nkey = BIO_new(BIO_s_file());\\r\\nif (key == NULL) {\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (file == NULL && maybe_stdin) {\\r\\n#ifdef _IONBF\\r\\n# ifndef OPENSSL_NO_SETVBUF_IONBF\\r\\nsetvbuf(stdin, NULL, _IONBF, 0);\\r\\n# endif\\r\\n#endif\\r\\nBIO_set_fp(key, stdin, BIO_NOCLOSE);\\r\\n} else if (BIO_read_filename(key, file) <= 0) {\\r\\nBIO_printf(err, \"Error opening %s %s\\n\", key_descrip, file);\\r\\nERR_print_errors(err);\\r\\ngoto end;\\r\\n}\\r\\nif (format == FORMAT_ASN1) {\\r\\npkey = d2i_PUBKEY_bio(key, NULL);\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nelse if (format == FORMAT_ASN1RSA) {\\r\\nRSA *rsa;\\r\\nrsa = d2i_RSAPublicKey_bio(key, NULL);\\r\\nif (rsa) {\\r\\npkey = EVP_PKEY_new();\\r\\nif (pkey)\\r\\nEVP_PKEY_set1_RSA(pkey, rsa);\\r\\nRSA_free(rsa);\\r\\n} else\\r\\npkey = NULL;\\r\\n} else if (format == FORMAT_PEMRSA) {\\r\\nRSA *rsa;\\r\\nrsa = PEM_read_bio_RSAPublicKey(key, NULL,\\r\\n(pem_password_cb *)password_callback,\\r\\n&cb_data);\\r\\nif (rsa) {\\r\\npkey = EVP_PKEY_new();\\r\\nif (pkey)\\r\\nEVP_PKEY_set1_RSA(pkey, rsa);\\r\\nRSA_free(rsa);\\r\\n} else\\r\\npkey = NULL;\\r\\n}\\r\\n#endif\\r\\nelse if (format == FORMAT_PEM) {\\r\\npkey = PEM_read_bio_PUBKEY(key, NULL,\\r\\n(pem_password_cb *)password_callback,\\r\\n&cb_data);\\r\\n}\\r\\n#if !defined(OPENSSL_NO_RC4) && !defined(OPENSSL_NO_RSA)\\r\\nelse if (format == FORMAT_NETSCAPE || format == FORMAT_IISSGC)\\r\\npkey = load_netscape_key(err, key, file, key_descrip, format);\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DSA)\\r\\nelse if (format == FORMAT_MSBLOB)\\r\\npkey = b2i_PublicKey_bio(key);\\r\\n#endif\\r\\nelse {\\r\\nBIO_printf(err, \"bad input format specified for key file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (key != NULL)\\r\\nBIO_free(key);\\r\\nif (pkey == NULL)\\r\\nBIO_printf(err, \"unable to load %s\\n\", key_descrip);\\r\\nreturn (pkey);\\r\\n}\\r\\nstatic EVP_PKEY *load_netscape_key(BIO *err, BIO *key, const char *file,\\r\\nconst char *key_descrip, int format)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nBUF_MEM *buf;\\r\\nRSA *rsa;\\r\\nconst unsigned char *p;\\r\\nint size, i;\\r\\nbuf = BUF_MEM_new();\\r\\npkey = EVP_PKEY_new();\\r\\nsize = 0;\\r\\nif (buf == NULL || pkey == NULL)\\r\\ngoto error;\\r\\nfor (;;) {\\r\\nif (!BUF_MEM_grow_clean(buf, size + 1024 * 10))\\r\\ngoto error;\\r\\ni = BIO_read(key, &(buf->data[size]), 1024 * 10);\\r\\nsize += i;\\r\\nif (i == 0)\\r\\nbreak;\\r\\nif (i < 0) {\\r\\nBIO_printf(err, \"Error reading %s %s\", key_descrip, file);\\r\\ngoto error;\\r\\n}\\r\\n}\\r\\np = (unsigned char *)buf->data;\\r\\nrsa = d2i_RSA_NET(NULL, &p, (long)size, NULL,\\r\\n(format == FORMAT_IISSGC ? 1 : 0));\\r\\nif (rsa == NULL)\\r\\ngoto error;\\r\\nBUF_MEM_free(buf);\\r\\nEVP_PKEY_set1_RSA(pkey, rsa);\\r\\nreturn pkey;\\r\\nerror:\\r\\nBUF_MEM_free(buf);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn NULL;\\r\\n}\\r\\nint set_name_ex(unsigned long *flags, const char *arg)\\r\\n{\\r\\nstatic const NAME_EX_TBL ex_tbl[] = {\\r\\n{\"esc_2253\", ASN1_STRFLGS_ESC_2253, 0},\\r\\n{\"esc_ctrl\", ASN1_STRFLGS_ESC_CTRL, 0},\\r\\n{\"esc_msb\", ASN1_STRFLGS_ESC_MSB, 0},\\r\\n{\"use_quote\", ASN1_STRFLGS_ESC_QUOTE, 0},\\r\\n{\"utf8\", ASN1_STRFLGS_UTF8_CONVERT, 0},\\r\\n{\"ignore_type\", ASN1_STRFLGS_IGNORE_TYPE, 0},\\r\\n{\"show_type\", ASN1_STRFLGS_SHOW_TYPE, 0},\\r\\n{\"dump_all\", ASN1_STRFLGS_DUMP_ALL, 0},\\r\\n{\"dump_nostr\", ASN1_STRFLGS_DUMP_UNKNOWN, 0},\\r\\n{\"dump_der\", ASN1_STRFLGS_DUMP_DER, 0},\\r\\n{\"compat\", XN_FLAG_COMPAT, 0xffffffffL},\\r\\n{\"sep_comma_plus\", XN_FLAG_SEP_COMMA_PLUS, XN_FLAG_SEP_MASK},\\r\\n{\"sep_comma_plus_space\", XN_FLAG_SEP_CPLUS_SPC, XN_FLAG_SEP_MASK},\\r\\n{\"sep_semi_plus_space\", XN_FLAG_SEP_SPLUS_SPC, XN_FLAG_SEP_MASK},\\r\\n{\"sep_multiline\", XN_FLAG_SEP_MULTILINE, XN_FLAG_SEP_MASK},\\r\\n{\"dn_rev\", XN_FLAG_DN_REV, 0},\\r\\n{\"nofname\", XN_FLAG_FN_NONE, XN_FLAG_FN_MASK},\\r\\n{\"sname\", XN_FLAG_FN_SN, XN_FLAG_FN_MASK},\\r\\n{\"lname\", XN_FLAG_FN_LN, XN_FLAG_FN_MASK},\\r\\n{\"align\", XN_FLAG_FN_ALIGN, 0},\\r\\n{\"oid\", XN_FLAG_FN_OID, XN_FLAG_FN_MASK},\\r\\n{\"space_eq\", XN_FLAG_SPC_EQ, 0},\\r\\n{\"dump_unknown\", XN_FLAG_DUMP_UNKNOWN_FIELDS, 0},\\r\\n{\"RFC2253\", XN_FLAG_RFC2253, 0xffffffffL},\\r\\n{\"oneline\", XN_FLAG_ONELINE, 0xffffffffL},\\r\\n{\"multiline\", XN_FLAG_MULTILINE, 0xffffffffL},\\r\\n{\"ca_default\", XN_FLAG_MULTILINE, 0xffffffffL},\\r\\n{NULL, 0, 0}\\r\\n};\\r\\nreturn set_multi_opts(flags, arg, ex_tbl);\\r\\n}\\r\\nint set_ext_copy(int *copy_type, const char *arg)\\r\\n{\\r\\nif (!strcasecmp(arg, \"none\"))\\r\\n*copy_type = EXT_COPY_NONE;\\r\\nelse if (!strcasecmp(arg, \"copy\"))\\r\\n*copy_type = EXT_COPY_ADD;\\r\\nelse if (!strcasecmp(arg, \"copyall\"))\\r\\n*copy_type = EXT_COPY_ALL;\\r\\nelse\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint copy_extensions(X509 *x, X509_REQ *req, int copy_type)\\r\\n{\\r\\nSTACK_OF(X509_EXTENSION) *exts = NULL;\\r\\nX509_EXTENSION *ext, *tmpext;\\r\\nASN1_OBJECT *obj;\\r\\nint i, idx, ret = 0;\\r\\nif (!x || !req || (copy_type == EXT_COPY_NONE))\\r\\nreturn 1;\\r\\nexts = X509_REQ_get_extensions(req);\\r\\nfor (i = 0; i < sk_X509_EXTENSION_num(exts); i++) {\\r\\next = sk_X509_EXTENSION_value(exts, i);\\r\\nobj = X509_EXTENSION_get_object(ext);\\r\\nidx = X509_get_ext_by_OBJ(x, obj, -1);\\r\\nif (idx != -1) {\\r\\nif (copy_type == EXT_COPY_ADD)\\r\\ncontinue;\\r\\ndo {\\r\\ntmpext = X509_get_ext(x, idx);\\r\\nX509_delete_ext(x, idx);\\r\\nX509_EXTENSION_free(tmpext);\\r\\nidx = X509_get_ext_by_OBJ(x, obj, -1);\\r\\n} while (idx != -1);\\r\\n}\\r\\nif (!X509_add_ext(x, ext, -1))\\r\\ngoto end;\\r\\n}\\r\\nret = 1;\\r\\nend:\\r\\nsk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int set_multi_opts(unsigned long *flags, const char *arg,\\r\\nconst NAME_EX_TBL * in_tbl)\\r\\n{\\r\\nSTACK_OF(CONF_VALUE) *vals;\\r\\nCONF_VALUE *val;\\r\\nint i, ret = 1;\\r\\nif (!arg)\\r\\nreturn 0;\\r\\nvals = X509V3_parse_list(arg);\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(vals); i++) {\\r\\nval = sk_CONF_VALUE_value(vals, i);\\r\\nif (!set_table_opts(flags, val->name, in_tbl))\\r\\nret = 0;\\r\\n}\\r\\nsk_CONF_VALUE_pop_free(vals, X509V3_conf_free);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int set_table_opts(unsigned long *flags, const char *arg,\\r\\nconst NAME_EX_TBL * in_tbl)\\r\\n{\\r\\nchar c;\\r\\nconst NAME_EX_TBL *ptbl;\\r\\nc = arg[0];\\r\\nif (c == '-') {\\r\\nc = 0;\\r\\narg++;\\r\\n} else if (c == '+') {\\r\\nc = 1;\\r\\narg++;\\r\\n} else\\r\\nc = 1;\\r\\nfor (ptbl = in_tbl; ptbl->name; ptbl++) {\\r\\nif (!strcasecmp(arg, ptbl->name)) {\\r\\n*flags &= ~ptbl->mask;\\r\\nif (c)\\r\\n*flags |= ptbl->flag;\\r\\nelse\\r\\n*flags &= ~ptbl->flag;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid print_name(BIO *out, const char *title, X509_NAME *nm,\\r\\nunsigned long lflags)\\r\\n{\\r\\nchar *buf;\\r\\nchar mline = 0;\\r\\nint indent = 0;\\r\\nif (title)\\r\\nBIO_puts(out, title);\\r\\nif ((lflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {\\r\\nmline = 1;\\r\\nindent = 4;\\r\\n}\\r\\nif (lflags == XN_FLAG_COMPAT) {\\r\\nbuf = X509_NAME_oneline(nm, 0, 0);\\r\\nBIO_puts(out, buf);\\r\\nBIO_puts(out, \"\\n\");\\r\\nOPENSSL_free(buf);\\r\\n} else {\\r\\nif (mline)\\r\\nBIO_puts(out, \"\\n\");\\r\\nX509_NAME_print_ex(out, nm, indent, lflags);\\r\\nBIO_puts(out, \"\\n\");\\r\\n}\\r\\n}\\r\\nX509_STORE *setup_verify(BIO *bp, char *CAfile, char *CApath)\\r\\n{\\r\\nX509_STORE *store;\\r\\nX509_LOOKUP *lookup;\\r\\nif (!(store = X509_STORE_new()))\\r\\ngoto end;\\r\\nlookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());\\r\\nif (lookup == NULL)\\r\\ngoto end;\\r\\nif (CAfile) {\\r\\nif (!X509_LOOKUP_load_file(lookup, CAfile, X509_FILETYPE_PEM)) {\\r\\nBIO_printf(bp, \"Error loading file %s\\n\", CAfile);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nX509_LOOKUP_load_file(lookup, NULL, X509_FILETYPE_DEFAULT);\\r\\nlookup = X509_STORE_add_lookup(store, X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL)\\r\\ngoto end;\\r\\nif (CApath) {\\r\\nif (!X509_LOOKUP_add_dir(lookup, CApath, X509_FILETYPE_PEM)) {\\r\\nBIO_printf(bp, \"Error loading directory %s\\n\", CApath);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nX509_LOOKUP_add_dir(lookup, NULL, X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nreturn store;\\r\\nend:\\r\\nX509_STORE_free(store);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic ENGINE *try_load_engine(BIO *err, const char *engine, int debug)\\r\\n{\\r\\nENGINE *e = ENGINE_by_id(\"dynamic\");\\r\\nif (e) {\\r\\nif (!ENGINE_ctrl_cmd_string(e, \"SO_PATH\", engine, 0)\\r\\n|| !ENGINE_ctrl_cmd_string(e, \"LOAD\", NULL, 0)) {\\r\\nENGINE_free(e);\\r\\ne = NULL;\\r\\n}\\r\\n}\\r\\nreturn e;\\r\\n}\\r\\nENGINE *setup_engine(BIO *err, const char *engine, int debug)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nif (engine) {\\r\\nif (strcmp(engine, \"auto\") == 0) {\\r\\nBIO_printf(err, \"enabling auto ENGINE support\\n\");\\r\\nENGINE_register_all_complete();\\r\\nreturn NULL;\\r\\n}\\r\\nif ((e = ENGINE_by_id(engine)) == NULL\\r\\n&& (e = try_load_engine(err, engine, debug)) == NULL) {\\r\\nBIO_printf(err, \"invalid engine \\\"%s\\\"\\n\", engine);\\r\\nERR_print_errors(err);\\r\\nreturn NULL;\\r\\n}\\r\\nif (debug) {\\r\\nENGINE_ctrl(e, ENGINE_CTRL_SET_LOGSTREAM, 0, err, 0);\\r\\n}\\r\\nENGINE_ctrl_cmd(e, \"SET_USER_INTERFACE\", 0, ui_method, 0, 1);\\r\\nif (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {\\r\\nBIO_printf(err, \"can't use that engine\\n\");\\r\\nERR_print_errors(err);\\r\\nENGINE_free(e);\\r\\nreturn NULL;\\r\\n}\\r\\nBIO_printf(err, \"engine \\\"%s\\\" set.\\n\", ENGINE_get_id(e));\\r\\nENGINE_free(e);\\r\\n}\\r\\nreturn e;\\r\\n}\\r\\nint load_config(BIO *err, CONF *cnf)\\r\\n{\\r\\nstatic int load_config_called = 0;\\r\\nif (load_config_called)\\r\\nreturn 1;\\r\\nload_config_called = 1;\\r\\nif (!cnf)\\r\\ncnf = config;\\r\\nif (!cnf)\\r\\nreturn 1;\\r\\nOPENSSL_load_builtin_modules();\\r\\nif (CONF_modules_load(cnf, NULL, 0) <= 0) {\\r\\nBIO_printf(err, \"Error configuring OpenSSL\\n\");\\r\\nERR_print_errors(err);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nchar *make_config_name()\\r\\n{\\r\\nconst char *t = X509_get_default_cert_area();\\r\\nsize_t len;\\r\\nchar *p;\\r\\nlen = strlen(t) + strlen(OPENSSL_CONF) + 2;\\r\\np = OPENSSL_malloc(len);\\r\\nif (p == NULL)\\r\\nreturn NULL;\\r\\nBUF_strlcpy(p, t, len);\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBUF_strlcat(p, \"/\", len);\\r\\n#endif\\r\\nBUF_strlcat(p, OPENSSL_CONF, len);\\r\\nreturn p;\\r\\n}\\r\\nstatic unsigned long index_serial_hash(const OPENSSL_CSTRING *a)\\r\\n{\\r\\nconst char *n;\\r\\nn = a[DB_serial];\\r\\nwhile (*n == '0')\\r\\nn++;\\r\\nreturn (lh_strhash(n));\\r\\n}\\r\\nstatic int index_serial_cmp(const OPENSSL_CSTRING *a,\\r\\nconst OPENSSL_CSTRING *b)\\r\\n{\\r\\nconst char *aa, *bb;\\r\\nfor (aa = a[DB_serial]; *aa == '0'; aa++) ;\\r\\nfor (bb = b[DB_serial]; *bb == '0'; bb++) ;\\r\\nreturn (strcmp(aa, bb));\\r\\n}\\r\\nstatic int index_name_qual(char **a)\\r\\n{\\r\\nreturn (a[0][0] == 'V');\\r\\n}\\r\\nstatic unsigned long index_name_hash(const OPENSSL_CSTRING *a)\\r\\n{\\r\\nreturn (lh_strhash(a[DB_name]));\\r\\n}\\r\\nint index_name_cmp(const OPENSSL_CSTRING *a, const OPENSSL_CSTRING *b)\\r\\n{\\r\\nreturn (strcmp(a[DB_name], b[DB_name]));\\r\\n}\\r\\nint rotate_serial(char *serialfile, char *new_suffix, char *old_suffix)\\r\\n{\\r\\nchar buf[5][BSIZE];\\r\\nint i, j;\\r\\ni = strlen(serialfile) + strlen(old_suffix);\\r\\nj = strlen(serialfile) + strlen(new_suffix);\\r\\nif (i > j)\\r\\nj = i;\\r\\nif (j + 1 >= BSIZE) {\\r\\nBIO_printf(bio_err, \"file name too long\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s.%s\", serialfile, new_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s-%s\", serialfile, new_suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s.%s\", serialfile, old_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s-%s\", serialfile, old_suffix);\\r\\n#endif\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\",\\r\\nserialfile, buf[1]);\\r\\n#endif\\r\\nif (rename(serialfile, buf[1]) < 0 && errno != ENOENT\\r\\n#ifdef ENOTDIR\\r\\n&& errno != ENOTDIR\\r\\n#endif\\r\\n) {\\r\\nBIO_printf(bio_err,\\r\\n\"unable to rename %s to %s\\n\", serialfile, buf[1]);\\r\\nperror(\"reason\");\\r\\ngoto err;\\r\\n}\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\",\\r\\nbuf[0], serialfile);\\r\\n#endif\\r\\nif (rename(buf[0], serialfile) < 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"unable to rename %s to %s\\n\", buf[0], serialfile);\\r\\nperror(\"reason\");\\r\\nrename(buf[1], serialfile);\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint rand_serial(BIGNUM *b, ASN1_INTEGER *ai)\\r\\n{\\r\\nBIGNUM *btmp;\\r\\nint ret = 0;\\r\\nif (b)\\r\\nbtmp = b;\\r\\nelse\\r\\nbtmp = BN_new();\\r\\nif (!btmp)\\r\\nreturn 0;\\r\\nif (!BN_pseudo_rand(btmp, SERIAL_RAND_BITS, 0, 0))\\r\\ngoto error;\\r\\nif (ai && !BN_to_ASN1_INTEGER(btmp, ai))\\r\\ngoto error;\\r\\nret = 1;\\r\\nerror:\\r\\nif (!b)\\r\\nBN_free(btmp);\\r\\nreturn ret;\\r\\n}\\r\\nCA_DB *load_index(char *dbfile, DB_ATTR *db_attr)\\r\\n{\\r\\nCA_DB *retdb = NULL;\\r\\nTXT_DB *tmpdb = NULL;\\r\\nBIO *in = BIO_new(BIO_s_file());\\r\\nCONF *dbattr_conf = NULL;\\r\\nchar buf[1][BSIZE];\\r\\nlong errorline = -1;\\r\\nif (in == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_read_filename(in, dbfile) <= 0) {\\r\\nperror(dbfile);\\r\\nBIO_printf(bio_err, \"unable to open '%s'\\n\", dbfile);\\r\\ngoto err;\\r\\n}\\r\\nif ((tmpdb = TXT_DB_read(in, DB_NUMBER)) == NULL)\\r\\ngoto err;\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBIO_snprintf(buf[0], sizeof buf[0], \"%s.attr\", dbfile);\\r\\n#else\\r\\nBIO_snprintf(buf[0], sizeof buf[0], \"%s-attr\", dbfile);\\r\\n#endif\\r\\ndbattr_conf = NCONF_new(NULL);\\r\\nif (NCONF_load(dbattr_conf, buf[0], &errorline) <= 0) {\\r\\nif (errorline > 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"error on line %ld of db attribute file '%s'\\n\",\\r\\nerrorline, buf[0]);\\r\\ngoto err;\\r\\n} else {\\r\\nNCONF_free(dbattr_conf);\\r\\ndbattr_conf = NULL;\\r\\n}\\r\\n}\\r\\nif ((retdb = OPENSSL_malloc(sizeof(CA_DB))) == NULL) {\\r\\nfprintf(stderr, \"Out of memory\\n\");\\r\\ngoto err;\\r\\n}\\r\\nretdb->db = tmpdb;\\r\\ntmpdb = NULL;\\r\\nif (db_attr)\\r\\nretdb->attributes = *db_attr;\\r\\nelse {\\r\\nretdb->attributes.unique_subject = 1;\\r\\n}\\r\\nif (dbattr_conf) {\\r\\nchar *p = NCONF_get_string(dbattr_conf, NULL, \"unique_subject\");\\r\\nif (p) {\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err,\\r\\n\"DEBUG[load_index]: unique_subject = \\\"%s\\\"\\n\", p);\\r\\n#endif\\r\\nretdb->attributes.unique_subject = parse_yesno(p, 1);\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (dbattr_conf)\\r\\nNCONF_free(dbattr_conf);\\r\\nif (tmpdb)\\r\\nTXT_DB_free(tmpdb);\\r\\nif (in)\\r\\nBIO_free_all(in);\\r\\nreturn retdb;\\r\\n}\\r\\nint index_index(CA_DB *db)\\r\\n{\\r\\nif (!TXT_DB_create_index(db->db, DB_serial, NULL,\\r\\nLHASH_HASH_FN(index_serial),\\r\\nLHASH_COMP_FN(index_serial))) {\\r\\nBIO_printf(bio_err,\\r\\n\"error creating serial number index:(%ld,%ld,%ld)\\n\",\\r\\ndb->db->error, db->db->arg1, db->db->arg2);\\r\\nreturn 0;\\r\\n}\\r\\nif (db->attributes.unique_subject\\r\\n&& !TXT_DB_create_index(db->db, DB_name, index_name_qual,\\r\\nLHASH_HASH_FN(index_name),\\r\\nLHASH_COMP_FN(index_name))) {\\r\\nBIO_printf(bio_err, \"error creating name index:(%ld,%ld,%ld)\\n\",\\r\\ndb->db->error, db->db->arg1, db->db->arg2);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint save_index(const char *dbfile, const char *suffix, CA_DB *db)\\r\\n{\\r\\nchar buf[3][BSIZE];\\r\\nBIO *out = BIO_new(BIO_s_file());\\r\\nint j;\\r\\nif (out == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nj = strlen(dbfile) + strlen(suffix);\\r\\nif (j + 6 >= BSIZE) {\\r\\nBIO_printf(bio_err, \"file name too long\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[2], sizeof buf[2], \"%s.attr\", dbfile);\\r\\n#else\\r\\nj = BIO_snprintf(buf[2], sizeof buf[2], \"%s-attr\", dbfile);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s.attr.%s\", dbfile, suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s-attr-%s\", dbfile, suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s.%s\", dbfile, suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s-%s\", dbfile, suffix);\\r\\n#endif\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: writing \\\"%s\\\"\\n\", buf[0]);\\r\\n#endif\\r\\nif (BIO_write_filename(out, buf[0]) <= 0) {\\r\\nperror(dbfile);\\r\\nBIO_printf(bio_err, \"unable to open '%s'\\n\", dbfile);\\r\\ngoto err;\\r\\n}\\r\\nj = TXT_DB_write(out, db->db);\\r\\nif (j <= 0)\\r\\ngoto err;\\r\\nBIO_free(out);\\r\\nout = BIO_new(BIO_s_file());\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: writing \\\"%s\\\"\\n\", buf[1]);\\r\\n#endif\\r\\nif (BIO_write_filename(out, buf[1]) <= 0) {\\r\\nperror(buf[2]);\\r\\nBIO_printf(bio_err, \"unable to open '%s'\\n\", buf[2]);\\r\\ngoto err;\\r\\n}\\r\\nBIO_printf(out, \"unique_subject = %s\\n\",\\r\\ndb->attributes.unique_subject ? \"yes\" : \"no\");\\r\\nBIO_free(out);\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint rotate_index(const char *dbfile, const char *new_suffix,\\r\\nconst char *old_suffix)\\r\\n{\\r\\nchar buf[5][BSIZE];\\r\\nint i, j;\\r\\ni = strlen(dbfile) + strlen(old_suffix);\\r\\nj = strlen(dbfile) + strlen(new_suffix);\\r\\nif (i > j)\\r\\nj = i;\\r\\nif (j + 6 >= BSIZE) {\\r\\nBIO_printf(bio_err, \"file name too long\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[4], sizeof buf[4], \"%s.attr\", dbfile);\\r\\n#else\\r\\nj = BIO_snprintf(buf[4], sizeof buf[4], \"%s-attr\", dbfile);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[2], sizeof buf[2], \"%s.attr.%s\", dbfile, new_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[2], sizeof buf[2], \"%s-attr-%s\", dbfile, new_suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s.%s\", dbfile, new_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[0], sizeof buf[0], \"%s-%s\", dbfile, new_suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s.%s\", dbfile, old_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[1], sizeof buf[1], \"%s-%s\", dbfile, old_suffix);\\r\\n#endif\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nj = BIO_snprintf(buf[3], sizeof buf[3], \"%s.attr.%s\", dbfile, old_suffix);\\r\\n#else\\r\\nj = BIO_snprintf(buf[3], sizeof buf[3], \"%s-attr-%s\", dbfile, old_suffix);\\r\\n#endif\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\", dbfile, buf[1]);\\r\\n#endif\\r\\nif (rename(dbfile, buf[1]) < 0 && errno != ENOENT\\r\\n#ifdef ENOTDIR\\r\\n&& errno != ENOTDIR\\r\\n#endif\\r\\n) {\\r\\nBIO_printf(bio_err, \"unable to rename %s to %s\\n\", dbfile, buf[1]);\\r\\nperror(\"reason\");\\r\\ngoto err;\\r\\n}\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\", buf[0], dbfile);\\r\\n#endif\\r\\nif (rename(buf[0], dbfile) < 0) {\\r\\nBIO_printf(bio_err, \"unable to rename %s to %s\\n\", buf[0], dbfile);\\r\\nperror(\"reason\");\\r\\nrename(buf[1], dbfile);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\", buf[4], buf[3]);\\r\\n#endif\\r\\nif (rename(buf[4], buf[3]) < 0 && errno != ENOENT\\r\\n#ifdef ENOTDIR\\r\\n&& errno != ENOTDIR\\r\\n#endif\\r\\n) {\\r\\nBIO_printf(bio_err, \"unable to rename %s to %s\\n\", buf[4], buf[3]);\\r\\nperror(\"reason\");\\r\\nrename(dbfile, buf[0]);\\r\\nrename(buf[1], dbfile);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: renaming \\\"%s\\\" to \\\"%s\\\"\\n\", buf[2], buf[4]);\\r\\n#endif\\r\\nif (rename(buf[2], buf[4]) < 0) {\\r\\nBIO_printf(bio_err, \"unable to rename %s to %s\\n\", buf[2], buf[4]);\\r\\nperror(\"reason\");\\r\\nrename(buf[3], buf[4]);\\r\\nrename(dbfile, buf[0]);\\r\\nrename(buf[1], dbfile);\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nvoid free_index(CA_DB *db)\\r\\n{\\r\\nif (db) {\\r\\nif (db->db)\\r\\nTXT_DB_free(db->db);\\r\\nOPENSSL_free(db);\\r\\n}\\r\\n}\\r\\nint parse_yesno(const char *str, int def)\\r\\n{\\r\\nint ret = def;\\r\\nif (str) {\\r\\nswitch (*str) {\\r\\ncase 'f':\\r\\ncase 'F':\\r\\ncase 'n':\\r\\ncase 'N':\\r\\ncase '0':\\r\\nret = 0;\\r\\nbreak;\\r\\ncase 't':\\r\\ncase 'T':\\r\\ncase 'y':\\r\\ncase 'Y':\\r\\ncase '1':\\r\\nret = 1;\\r\\nbreak;\\r\\ndefault:\\r\\nret = def;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nX509_NAME *parse_name(char *subject, long chtype, int multirdn)\\r\\n{\\r\\nsize_t buflen = strlen(subject) + 1;\\r\\nchar *buf = OPENSSL_malloc(buflen);\\r\\nsize_t max_ne = buflen / 2 + 1;\\r\\nchar **ne_types = OPENSSL_malloc(max_ne * sizeof(char *));\\r\\nchar **ne_values = OPENSSL_malloc(max_ne * sizeof(char *));\\r\\nint *mval = OPENSSL_malloc(max_ne * sizeof(int));\\r\\nchar *sp = subject, *bp = buf;\\r\\nint i, ne_num = 0;\\r\\nX509_NAME *n = NULL;\\r\\nint nid;\\r\\nif (!buf || !ne_types || !ne_values || !mval) {\\r\\nBIO_printf(bio_err, \"malloc error\\n\");\\r\\ngoto error;\\r\\n}\\r\\nif (*subject != '/') {\\r\\nBIO_printf(bio_err, \"Subject does not start with '/'.\\n\");\\r\\ngoto error;\\r\\n}\\r\\nsp++;\\r\\nmval[ne_num] = 0;\\r\\nwhile (*sp) {\\r\\nne_types[ne_num] = bp;\\r\\nwhile (*sp) {\\r\\nif (*sp == '\\\\') {\\r\\nif (*++sp)\\r\\n*bp++ = *sp++;\\r\\nelse {\\r\\nBIO_printf(bio_err,\\r\\n\"escape character at end of string\\n\");\\r\\ngoto error;\\r\\n}\\r\\n} else if (*sp == '=') {\\r\\nsp++;\\r\\n*bp++ = '\\0';\\r\\nbreak;\\r\\n} else\\r\\n*bp++ = *sp++;\\r\\n}\\r\\nif (!*sp) {\\r\\nBIO_printf(bio_err,\\r\\n\"end of string encountered while processing type of subject name element #%d\\n\",\\r\\nne_num);\\r\\ngoto error;\\r\\n}\\r\\nne_values[ne_num] = bp;\\r\\nwhile (*sp) {\\r\\nif (*sp == '\\\\') {\\r\\nif (*++sp)\\r\\n*bp++ = *sp++;\\r\\nelse {\\r\\nBIO_printf(bio_err,\\r\\n\"escape character at end of string\\n\");\\r\\ngoto error;\\r\\n}\\r\\n} else if (*sp == '/') {\\r\\nsp++;\\r\\nmval[ne_num + 1] = 0;\\r\\nbreak;\\r\\n} else if (*sp == '+' && multirdn) {\\r\\nsp++;\\r\\nmval[ne_num + 1] = -1;\\r\\nbreak;\\r\\n} else\\r\\n*bp++ = *sp++;\\r\\n}\\r\\n*bp++ = '\\0';\\r\\nne_num++;\\r\\n}\\r\\nif (!(n = X509_NAME_new()))\\r\\ngoto error;\\r\\nfor (i = 0; i < ne_num; i++) {\\r\\nif ((nid = OBJ_txt2nid(ne_types[i])) == NID_undef) {\\r\\nBIO_printf(bio_err,\\r\\n\"Subject Attribute %s has no known NID, skipped\\n\",\\r\\nne_types[i]);\\r\\ncontinue;\\r\\n}\\r\\nif (!*ne_values[i]) {\\r\\nBIO_printf(bio_err,\\r\\n\"No value provided for Subject Attribute %s, skipped\\n\",\\r\\nne_types[i]);\\r\\ncontinue;\\r\\n}\\r\\nif (!X509_NAME_add_entry_by_NID\\r\\n(n, nid, chtype, (unsigned char *)ne_values[i], -1, -1, mval[i]))\\r\\ngoto error;\\r\\n}\\r\\nOPENSSL_free(ne_values);\\r\\nOPENSSL_free(ne_types);\\r\\nOPENSSL_free(buf);\\r\\nOPENSSL_free(mval);\\r\\nreturn n;\\r\\nerror:\\r\\nX509_NAME_free(n);\\r\\nif (ne_values)\\r\\nOPENSSL_free(ne_values);\\r\\nif (ne_types)\\r\\nOPENSSL_free(ne_types);\\r\\nif (mval)\\r\\nOPENSSL_free(mval);\\r\\nif (buf)\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nint args_verify(char ***pargs, int *pargc,\\r\\nint *badarg, BIO *err, X509_VERIFY_PARAM **pm)\\r\\n{\\r\\nASN1_OBJECT *otmp = NULL;\\r\\nunsigned long flags = 0;\\r\\nint i;\\r\\nint purpose = 0, depth = -1;\\r\\nchar **oldargs = *pargs;\\r\\nchar *arg = **pargs, *argn = (*pargs)[1];\\r\\ntime_t at_time = 0;\\r\\nchar *hostname = NULL;\\r\\nchar *email = NULL;\\r\\nchar *ipasc = NULL;\\r\\nif (!strcmp(arg, \"-policy\")) {\\r\\nif (!argn)\\r\\n*badarg = 1;\\r\\nelse {\\r\\notmp = OBJ_txt2obj(argn, 0);\\r\\nif (!otmp) {\\r\\nBIO_printf(err, \"Invalid Policy \\\"%s\\\"\\n\", argn);\\r\\n*badarg = 1;\\r\\n}\\r\\n}\\r\\n(*pargs)++;\\r\\n} else if (strcmp(arg, \"-purpose\") == 0) {\\r\\nX509_PURPOSE *xptmp;\\r\\nif (!argn)\\r\\n*badarg = 1;\\r\\nelse {\\r\\ni = X509_PURPOSE_get_by_sname(argn);\\r\\nif (i < 0) {\\r\\nBIO_printf(err, \"unrecognized purpose\\n\");\\r\\n*badarg = 1;\\r\\n} else {\\r\\nxptmp = X509_PURPOSE_get0(i);\\r\\npurpose = X509_PURPOSE_get_id(xptmp);\\r\\n}\\r\\n}\\r\\n(*pargs)++;\\r\\n} else if (strcmp(arg, \"-verify_depth\") == 0) {\\r\\nif (!argn)\\r\\n*badarg = 1;\\r\\nelse {\\r\\ndepth = atoi(argn);\\r\\nif (depth < 0) {\\r\\nBIO_printf(err, \"invalid depth\\n\");\\r\\n*badarg = 1;\\r\\n}\\r\\n}\\r\\n(*pargs)++;\\r\\n} else if (strcmp(arg, \"-attime\") == 0) {\\r\\nif (!argn)\\r\\n*badarg = 1;\\r\\nelse {\\r\\nlong timestamp;\\r\\nif (sscanf(argn, \"%li\", &timestamp) != 1) {\\r\\nBIO_printf(bio_err, \"Error parsing timestamp %s\\n\", argn);\\r\\n*badarg = 1;\\r\\n}\\r\\nat_time = (time_t)timestamp;\\r\\n}\\r\\n(*pargs)++;\\r\\n} else if (strcmp(arg, \"-verify_hostname\") == 0) {\\r\\nif (!argn)\\r\\n*badarg = 1;\\r\\nhostname = argn;\\r\\n(*pargs)++;\\r\\n} else if (strcmp(arg, \"-verify_email\") == 0) {\\r\\nif (!argn)\\r\\n*badarg = 1;\\r\\nemail = argn;\\r\\n(*pargs)++;\\r\\n} else if (strcmp(arg, \"-verify_ip\") == 0) {\\r\\nif (!argn)\\r\\n*badarg = 1;\\r\\nipasc = argn;\\r\\n(*pargs)++;\\r\\n} else if (!strcmp(arg, \"-ignore_critical\"))\\r\\nflags |= X509_V_FLAG_IGNORE_CRITICAL;\\r\\nelse if (!strcmp(arg, \"-issuer_checks\"))\\r\\nflags |= X509_V_FLAG_CB_ISSUER_CHECK;\\r\\nelse if (!strcmp(arg, \"-crl_check\"))\\r\\nflags |= X509_V_FLAG_CRL_CHECK;\\r\\nelse if (!strcmp(arg, \"-crl_check_all\"))\\r\\nflags |= X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL;\\r\\nelse if (!strcmp(arg, \"-policy_check\"))\\r\\nflags |= X509_V_FLAG_POLICY_CHECK;\\r\\nelse if (!strcmp(arg, \"-explicit_policy\"))\\r\\nflags |= X509_V_FLAG_EXPLICIT_POLICY;\\r\\nelse if (!strcmp(arg, \"-inhibit_any\"))\\r\\nflags |= X509_V_FLAG_INHIBIT_ANY;\\r\\nelse if (!strcmp(arg, \"-inhibit_map\"))\\r\\nflags |= X509_V_FLAG_INHIBIT_MAP;\\r\\nelse if (!strcmp(arg, \"-x509_strict\"))\\r\\nflags |= X509_V_FLAG_X509_STRICT;\\r\\nelse if (!strcmp(arg, \"-extended_crl\"))\\r\\nflags |= X509_V_FLAG_EXTENDED_CRL_SUPPORT;\\r\\nelse if (!strcmp(arg, \"-use_deltas\"))\\r\\nflags |= X509_V_FLAG_USE_DELTAS;\\r\\nelse if (!strcmp(arg, \"-policy_print\"))\\r\\nflags |= X509_V_FLAG_NOTIFY_POLICY;\\r\\nelse if (!strcmp(arg, \"-check_ss_sig\"))\\r\\nflags |= X509_V_FLAG_CHECK_SS_SIGNATURE;\\r\\nelse if (!strcmp(arg, \"-trusted_first\"))\\r\\nflags |= X509_V_FLAG_TRUSTED_FIRST;\\r\\nelse if (!strcmp(arg, \"-suiteB_128_only\"))\\r\\nflags |= X509_V_FLAG_SUITEB_128_LOS_ONLY;\\r\\nelse if (!strcmp(arg, \"-suiteB_128\"))\\r\\nflags |= X509_V_FLAG_SUITEB_128_LOS;\\r\\nelse if (!strcmp(arg, \"-suiteB_192\"))\\r\\nflags |= X509_V_FLAG_SUITEB_192_LOS;\\r\\nelse if (!strcmp(arg, \"-partial_chain\"))\\r\\nflags |= X509_V_FLAG_PARTIAL_CHAIN;\\r\\nelse\\r\\nreturn 0;\\r\\nif (*badarg) {\\r\\nif (*pm)\\r\\nX509_VERIFY_PARAM_free(*pm);\\r\\n*pm = NULL;\\r\\ngoto end;\\r\\n}\\r\\nif (!*pm && !(*pm = X509_VERIFY_PARAM_new())) {\\r\\n*badarg = 1;\\r\\ngoto end;\\r\\n}\\r\\nif (otmp)\\r\\nX509_VERIFY_PARAM_add0_policy(*pm, otmp);\\r\\nif (flags)\\r\\nX509_VERIFY_PARAM_set_flags(*pm, flags);\\r\\nif (purpose)\\r\\nX509_VERIFY_PARAM_set_purpose(*pm, purpose);\\r\\nif (depth >= 0)\\r\\nX509_VERIFY_PARAM_set_depth(*pm, depth);\\r\\nif (at_time)\\r\\nX509_VERIFY_PARAM_set_time(*pm, at_time);\\r\\nif (hostname && !X509_VERIFY_PARAM_set1_host(*pm, hostname, 0))\\r\\n*badarg = 1;\\r\\nif (email && !X509_VERIFY_PARAM_set1_email(*pm, email, 0))\\r\\n*badarg = 1;\\r\\nif (ipasc && !X509_VERIFY_PARAM_set1_ip_asc(*pm, ipasc))\\r\\n*badarg = 1;\\r\\nend:\\r\\n(*pargs)++;\\r\\nif (pargc)\\r\\n*pargc -= *pargs - oldargs;\\r\\nreturn 1;\\r\\n}\\r\\nint bio_to_mem(unsigned char **out, int maxlen, BIO *in)\\r\\n{\\r\\nBIO *mem;\\r\\nint len, ret;\\r\\nunsigned char tbuf[1024];\\r\\nmem = BIO_new(BIO_s_mem());\\r\\nif (!mem)\\r\\nreturn -1;\\r\\nfor (;;) {\\r\\nif ((maxlen != -1) && maxlen < 1024)\\r\\nlen = maxlen;\\r\\nelse\\r\\nlen = 1024;\\r\\nlen = BIO_read(in, tbuf, len);\\r\\nif (len <= 0)\\r\\nbreak;\\r\\nif (BIO_write(mem, tbuf, len) != len) {\\r\\nBIO_free(mem);\\r\\nreturn -1;\\r\\n}\\r\\nmaxlen -= len;\\r\\nif (maxlen == 0)\\r\\nbreak;\\r\\n}\\r\\nret = BIO_get_mem_data(mem, (char **)out);\\r\\nBIO_set_flags(mem, BIO_FLAGS_MEM_RDONLY);\\r\\nBIO_free(mem);\\r\\nreturn ret;\\r\\n}\\r\\nint pkey_ctrl_string(EVP_PKEY_CTX *ctx, char *value)\\r\\n{\\r\\nint rv;\\r\\nchar *stmp, *vtmp = NULL;\\r\\nstmp = BUF_strdup(value);\\r\\nif (!stmp)\\r\\nreturn -1;\\r\\nvtmp = strchr(stmp, ':');\\r\\nif (vtmp) {\\r\\n*vtmp = 0;\\r\\nvtmp++;\\r\\n}\\r\\nrv = EVP_PKEY_CTX_ctrl_str(ctx, stmp, vtmp);\\r\\nOPENSSL_free(stmp);\\r\\nreturn rv;\\r\\n}\\r\\nvoid policies_print(BIO *out, X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509_POLICY_TREE *tree;\\r\\nint explicit_policy;\\r\\nint free_out = 0;\\r\\nif (out == NULL) {\\r\\nout = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nfree_out = 1;\\r\\n}\\r\\ntree = X509_STORE_CTX_get0_policy_tree(ctx);\\r\\nexplicit_policy = X509_STORE_CTX_get_explicit_policy(ctx);\\r\\nBIO_printf(out, \"Require explicit Policy: %s\\n\",\\r\\nexplicit_policy ? \"True\" : \"False\");\\r\\nnodes_print(out, \"Authority\", X509_policy_tree_get0_policies(tree));\\r\\nnodes_print(out, \"User\", X509_policy_tree_get0_user_policies(tree));\\r\\nif (free_out)\\r\\nBIO_free(out);\\r\\n}\\r\\nstatic JPAKE_CTX *jpake_init(const char *us, const char *them,\\r\\nconst char *secret)\\r\\n{\\r\\nBIGNUM *p = NULL;\\r\\nBIGNUM *g = NULL;\\r\\nBIGNUM *q = NULL;\\r\\nBIGNUM *bnsecret = BN_new();\\r\\nJPAKE_CTX *ctx;\\r\\nBN_hex2bn(&p,\\r\\n\"F9E5B365665EA7A05A9C534502780FEE6F1AB5BD4F49947FD036DBD7E905269AF46EF28B0FC07487EE4F5D20FB3C0AF8E700F3A2FA3414970CBED44FEDFF80CE78D800F184BB82435D137AADA2C6C16523247930A63B85661D1FC817A51ACD96168E95898A1F83A79FFB529368AA7833ABD1B0C3AEDDB14D2E1A2F71D99F763F\");\\r\\ng = BN_new();\\r\\nBN_set_word(g, 2);\\r\\nq = BN_new();\\r\\nBN_rshift1(q, p);\\r\\nBN_bin2bn((const unsigned char *)secret, strlen(secret), bnsecret);\\r\\nctx = JPAKE_CTX_new(us, them, p, g, q, bnsecret);\\r\\nBN_free(bnsecret);\\r\\nBN_free(q);\\r\\nBN_free(g);\\r\\nBN_free(p);\\r\\nreturn ctx;\\r\\n}\\r\\nstatic void jpake_send_part(BIO *conn, const JPAKE_STEP_PART *p)\\r\\n{\\r\\nBN_print(conn, p->gx);\\r\\nBIO_puts(conn, \"\\n\");\\r\\nBN_print(conn, p->zkpx.gr);\\r\\nBIO_puts(conn, \"\\n\");\\r\\nBN_print(conn, p->zkpx.b);\\r\\nBIO_puts(conn, \"\\n\");\\r\\n}\\r\\nstatic void jpake_send_step1(BIO *bconn, JPAKE_CTX *ctx)\\r\\n{\\r\\nJPAKE_STEP1 s1;\\r\\nJPAKE_STEP1_init(&s1);\\r\\nJPAKE_STEP1_generate(&s1, ctx);\\r\\njpake_send_part(bconn, &s1.p1);\\r\\njpake_send_part(bconn, &s1.p2);\\r\\n(void)BIO_flush(bconn);\\r\\nJPAKE_STEP1_release(&s1);\\r\\n}\\r\\nstatic void jpake_send_step2(BIO *bconn, JPAKE_CTX *ctx)\\r\\n{\\r\\nJPAKE_STEP2 s2;\\r\\nJPAKE_STEP2_init(&s2);\\r\\nJPAKE_STEP2_generate(&s2, ctx);\\r\\njpake_send_part(bconn, &s2);\\r\\n(void)BIO_flush(bconn);\\r\\nJPAKE_STEP2_release(&s2);\\r\\n}\\r\\nstatic void jpake_send_step3a(BIO *bconn, JPAKE_CTX *ctx)\\r\\n{\\r\\nJPAKE_STEP3A s3a;\\r\\nJPAKE_STEP3A_init(&s3a);\\r\\nJPAKE_STEP3A_generate(&s3a, ctx);\\r\\nBIO_write(bconn, s3a.hhk, sizeof s3a.hhk);\\r\\n(void)BIO_flush(bconn);\\r\\nJPAKE_STEP3A_release(&s3a);\\r\\n}\\r\\nstatic void jpake_send_step3b(BIO *bconn, JPAKE_CTX *ctx)\\r\\n{\\r\\nJPAKE_STEP3B s3b;\\r\\nJPAKE_STEP3B_init(&s3b);\\r\\nJPAKE_STEP3B_generate(&s3b, ctx);\\r\\nBIO_write(bconn, s3b.hk, sizeof s3b.hk);\\r\\n(void)BIO_flush(bconn);\\r\\nJPAKE_STEP3B_release(&s3b);\\r\\n}\\r\\nstatic void readbn(BIGNUM **bn, BIO *bconn)\\r\\n{\\r\\nchar buf[10240];\\r\\nint l;\\r\\nl = BIO_gets(bconn, buf, sizeof buf);\\r\\nassert(l > 0);\\r\\nassert(buf[l - 1] == '\\n');\\r\\nbuf[l - 1] = '\\0';\\r\\nBN_hex2bn(bn, buf);\\r\\n}\\r\\nstatic void jpake_receive_part(JPAKE_STEP_PART *p, BIO *bconn)\\r\\n{\\r\\nreadbn(&p->gx, bconn);\\r\\nreadbn(&p->zkpx.gr, bconn);\\r\\nreadbn(&p->zkpx.b, bconn);\\r\\n}\\r\\nstatic void jpake_receive_step1(JPAKE_CTX *ctx, BIO *bconn)\\r\\n{\\r\\nJPAKE_STEP1 s1;\\r\\nJPAKE_STEP1_init(&s1);\\r\\njpake_receive_part(&s1.p1, bconn);\\r\\njpake_receive_part(&s1.p2, bconn);\\r\\nif (!JPAKE_STEP1_process(ctx, &s1)) {\\r\\nERR_print_errors(bio_err);\\r\\nexit(1);\\r\\n}\\r\\nJPAKE_STEP1_release(&s1);\\r\\n}\\r\\nstatic void jpake_receive_step2(JPAKE_CTX *ctx, BIO *bconn)\\r\\n{\\r\\nJPAKE_STEP2 s2;\\r\\nJPAKE_STEP2_init(&s2);\\r\\njpake_receive_part(&s2, bconn);\\r\\nif (!JPAKE_STEP2_process(ctx, &s2)) {\\r\\nERR_print_errors(bio_err);\\r\\nexit(1);\\r\\n}\\r\\nJPAKE_STEP2_release(&s2);\\r\\n}\\r\\nstatic void jpake_receive_step3a(JPAKE_CTX *ctx, BIO *bconn)\\r\\n{\\r\\nJPAKE_STEP3A s3a;\\r\\nint l;\\r\\nJPAKE_STEP3A_init(&s3a);\\r\\nl = BIO_read(bconn, s3a.hhk, sizeof s3a.hhk);\\r\\nassert(l == sizeof s3a.hhk);\\r\\nif (!JPAKE_STEP3A_process(ctx, &s3a)) {\\r\\nERR_print_errors(bio_err);\\r\\nexit(1);\\r\\n}\\r\\nJPAKE_STEP3A_release(&s3a);\\r\\n}\\r\\nstatic void jpake_receive_step3b(JPAKE_CTX *ctx, BIO *bconn)\\r\\n{\\r\\nJPAKE_STEP3B s3b;\\r\\nint l;\\r\\nJPAKE_STEP3B_init(&s3b);\\r\\nl = BIO_read(bconn, s3b.hk, sizeof s3b.hk);\\r\\nassert(l == sizeof s3b.hk);\\r\\nif (!JPAKE_STEP3B_process(ctx, &s3b)) {\\r\\nERR_print_errors(bio_err);\\r\\nexit(1);\\r\\n}\\r\\nJPAKE_STEP3B_release(&s3b);\\r\\n}\\r\\nvoid jpake_client_auth(BIO *out, BIO *conn, const char *secret)\\r\\n{\\r\\nJPAKE_CTX *ctx;\\r\\nBIO *bconn;\\r\\nBIO_puts(out, \"Authenticating with JPAKE\\n\");\\r\\nctx = jpake_init(\"client\", \"server\", secret);\\r\\nbconn = BIO_new(BIO_f_buffer());\\r\\nBIO_push(bconn, conn);\\r\\njpake_send_step1(bconn, ctx);\\r\\njpake_receive_step1(ctx, bconn);\\r\\njpake_send_step2(bconn, ctx);\\r\\njpake_receive_step2(ctx, bconn);\\r\\njpake_send_step3a(bconn, ctx);\\r\\njpake_receive_step3b(ctx, bconn);\\r\\nBIO_puts(out, \"JPAKE authentication succeeded, setting PSK\\n\");\\r\\nif (psk_key)\\r\\nOPENSSL_free(psk_key);\\r\\npsk_key = BN_bn2hex(JPAKE_get_shared_key(ctx));\\r\\nBIO_pop(bconn);\\r\\nBIO_free(bconn);\\r\\nJPAKE_CTX_free(ctx);\\r\\n}\\r\\nvoid jpake_server_auth(BIO *out, BIO *conn, const char *secret)\\r\\n{\\r\\nJPAKE_CTX *ctx;\\r\\nBIO *bconn;\\r\\nBIO_puts(out, \"Authenticating with JPAKE\\n\");\\r\\nctx = jpake_init(\"server\", \"client\", secret);\\r\\nbconn = BIO_new(BIO_f_buffer());\\r\\nBIO_push(bconn, conn);\\r\\njpake_receive_step1(ctx, bconn);\\r\\njpake_send_step1(bconn, ctx);\\r\\njpake_receive_step2(ctx, bconn);\\r\\njpake_send_step2(bconn, ctx);\\r\\njpake_receive_step3a(ctx, bconn);\\r\\njpake_send_step3b(bconn, ctx);\\r\\nBIO_puts(out, \"JPAKE authentication succeeded, setting PSK\\n\");\\r\\nif (psk_key)\\r\\nOPENSSL_free(psk_key);\\r\\npsk_key = BN_bn2hex(JPAKE_get_shared_key(ctx));\\r\\nBIO_pop(bconn);\\r\\nBIO_free(bconn);\\r\\nJPAKE_CTX_free(ctx);\\r\\n}\\r\\nunsigned char *next_protos_parse(unsigned short *outlen, const char *in)\\r\\n{\\r\\nsize_t len;\\r\\nunsigned char *out;\\r\\nsize_t i, start = 0;\\r\\nlen = strlen(in);\\r\\nif (len >= 65535)\\r\\nreturn NULL;\\r\\nout = OPENSSL_malloc(strlen(in) + 1);\\r\\nif (!out)\\r\\nreturn NULL;\\r\\nfor (i = 0; i <= len; ++i) {\\r\\nif (i == len || in[i] == ',') {\\r\\nif (i - start > 255) {\\r\\nOPENSSL_free(out);\\r\\nreturn NULL;\\r\\n}\\r\\nout[start] = i - start;\\r\\nstart = i + 1;\\r\\n} else\\r\\nout[i + 1] = in[i];\\r\\n}\\r\\n*outlen = len + 1;\\r\\nreturn out;\\r\\n}\\r\\nvoid print_cert_checks(BIO *bio, X509 *x,\\r\\nconst char *checkhost,\\r\\nconst char *checkemail, const char *checkip)\\r\\n{\\r\\nif (x == NULL)\\r\\nreturn;\\r\\nif (checkhost) {\\r\\nBIO_printf(bio, \"Hostname %s does%s match certificate\\n\",\\r\\ncheckhost, X509_check_host(x, checkhost, 0, 0, NULL)\\r\\n? \"\" : \" NOT\");\\r\\n}\\r\\nif (checkemail) {\\r\\nBIO_printf(bio, \"Email %s does%s match certificate\\n\",\\r\\ncheckemail, X509_check_email(x, checkemail, 0,\\r\\n0) ? \"\" : \" NOT\");\\r\\n}\\r\\nif (checkip) {\\r\\nBIO_printf(bio, \"IP %s does%s match certificate\\n\",\\r\\ncheckip, X509_check_ip_asc(x, checkip, 0) ? \"\" : \" NOT\");\\r\\n}\\r\\n}\\r\\nstatic const char *get_dp_url(DIST_POINT *dp)\\r\\n{\\r\\nGENERAL_NAMES *gens;\\r\\nGENERAL_NAME *gen;\\r\\nint i, gtype;\\r\\nASN1_STRING *uri;\\r\\nif (!dp->distpoint || dp->distpoint->type != 0)\\r\\nreturn NULL;\\r\\ngens = dp->distpoint->name.fullname;\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {\\r\\ngen = sk_GENERAL_NAME_value(gens, i);\\r\\nuri = GENERAL_NAME_get0_value(gen, &gtype);\\r\\nif (gtype == GEN_URI && ASN1_STRING_length(uri) > 6) {\\r\\nchar *uptr = (char *)ASN1_STRING_data(uri);\\r\\nif (!strncmp(uptr, \"http://\", 7))\\r\\nreturn uptr;\\r\\n}\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int WIN32_rename(const char *from, const char *to)\\r\\n{\\r\\nTCHAR *tfrom = NULL, *tto;\\r\\nDWORD err;\\r\\nint ret = 0;\\r\\nif (sizeof(TCHAR) == 1) {\\r\\ntfrom = (TCHAR *)from;\\r\\ntto = (TCHAR *)to;\\r\\n} else {\\r\\nsize_t i, flen = strlen(from) + 1, tlen = strlen(to) + 1;\\r\\ntfrom = (TCHAR *)malloc(sizeof(TCHAR) * (flen + tlen));\\r\\nif (tfrom == NULL)\\r\\ngoto err;\\r\\ntto = tfrom + flen;\\r\\n# if !defined(_WIN32_WCE) || _WIN32_WCE>=101\\r\\nif (!MultiByteToWideChar(CP_ACP, 0, from, flen, (WCHAR *)tfrom, flen))\\r\\n# endif\\r\\nfor (i = 0; i < flen; i++)\\r\\ntfrom[i] = (TCHAR)from[i];\\r\\n# if !defined(_WIN32_WCE) || _WIN32_WCE>=101\\r\\nif (!MultiByteToWideChar(CP_ACP, 0, to, tlen, (WCHAR *)tto, tlen))\\r\\n# endif\\r\\nfor (i = 0; i < tlen; i++)\\r\\ntto[i] = (TCHAR)to[i];\\r\\n}\\r\\nif (MoveFile(tfrom, tto))\\r\\ngoto ok;\\r\\nerr = GetLastError();\\r\\nif (err == ERROR_ALREADY_EXISTS || err == ERROR_FILE_EXISTS) {\\r\\nif (DeleteFile(tto) && MoveFile(tfrom, tto))\\r\\ngoto ok;\\r\\nerr = GetLastError();\\r\\n}\\r\\nif (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND)\\r\\nerrno = ENOENT;\\r\\nelse if (err == ERROR_ACCESS_DENIED)\\r\\nerrno = EACCES;\\r\\nelse\\r\\nerrno = EINVAL;\\r\\nerr:\\r\\nret = -1;\\r\\nok:\\r\\nif (tfrom != NULL && tfrom != (TCHAR *)from)\\r\\nfree(tfrom);\\r\\nreturn ret;\\r\\n}\\r\\ndouble app_tminterval(int stop, int usertime)\\r\\n{\\r\\nFILETIME now;\\r\\ndouble ret = 0;\\r\\nstatic ULARGE_INTEGER tmstart;\\r\\nstatic int warning = 1;\\r\\n# ifdef _WIN32_WINNT\\r\\nstatic HANDLE proc = NULL;\\r\\nif (proc == NULL) {\\r\\nif (check_winnt())\\r\\nproc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,\\r\\nGetCurrentProcessId());\\r\\nif (proc == NULL)\\r\\nproc = (HANDLE) - 1;\\r\\n}\\r\\nif (usertime && proc != (HANDLE) - 1) {\\r\\nFILETIME junk;\\r\\nGetProcessTimes(proc, &junk, &junk, &junk, &now);\\r\\n} else\\r\\n# endif\\r\\n{\\r\\nSYSTEMTIME systime;\\r\\nif (usertime && warning) {\\r\\nBIO_printf(bio_err, \"To get meaningful results, run \"\\r\\n\"this program on idle system.\\n\");\\r\\nwarning = 0;\\r\\n}\\r\\nGetSystemTime(&systime);\\r\\nSystemTimeToFileTime(&systime, &now);\\r\\n}\\r\\nif (stop == TM_START) {\\r\\ntmstart.u.LowPart = now.dwLowDateTime;\\r\\ntmstart.u.HighPart = now.dwHighDateTime;\\r\\n} else {\\r\\nULARGE_INTEGER tmstop;\\r\\ntmstop.u.LowPart = now.dwLowDateTime;\\r\\ntmstop.u.HighPart = now.dwHighDateTime;\\r\\nret = (__int64)(tmstop.QuadPart - tmstart.QuadPart) * 1e-7;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\ndouble app_tminterval(int stop, int usertime)\\r\\n{\\r\\ndouble ret = 0;\\r\\nstatic clock_t tmstart;\\r\\nstatic int warning = 1;\\r\\nif (usertime && warning) {\\r\\nBIO_printf(bio_err, \"To get meaningful results, run \"\\r\\n\"this program on idle system.\\n\");\\r\\nwarning = 0;\\r\\n}\\r\\nif (stop == TM_START)\\r\\ntmstart = clock();\\r\\nelse\\r\\nret = (clock() - tmstart) / (double)CLOCKS_PER_SEC;\\r\\nreturn (ret);\\r\\n}\\r\\ndouble app_tminterval(int stop, int usertime)\\r\\n{\\r\\ndouble ret = 0;\\r\\n# ifdef CLOCK_REALTIME\\r\\nstatic struct timespec tmstart;\\r\\nstruct timespec now;\\r\\n# else\\r\\nstatic unsigned long tmstart;\\r\\nunsigned long now;\\r\\n# endif\\r\\nstatic int warning = 1;\\r\\nif (usertime && warning) {\\r\\nBIO_printf(bio_err, \"To get meaningful results, run \"\\r\\n\"this program on idle system.\\n\");\\r\\nwarning = 0;\\r\\n}\\r\\n# ifdef CLOCK_REALTIME\\r\\nclock_gettime(CLOCK_REALTIME, &now);\\r\\nif (stop == TM_START)\\r\\ntmstart = now;\\r\\nelse\\r\\nret = ((now.tv_sec + now.tv_nsec * 1e-9)\\r\\n- (tmstart.tv_sec + tmstart.tv_nsec * 1e-9));\\r\\n# else\\r\\nnow = tickGet();\\r\\nif (stop == TM_START)\\r\\ntmstart = now;\\r\\nelse\\r\\nret = (now - tmstart) / (double)sysClkRateGet();\\r\\n# endif\\r\\nreturn (ret);\\r\\n}\\r\\ndouble app_tminterval(int stop, int usertime)\\r\\n{\\r\\nstatic clock_t tmstart;\\r\\ndouble ret = 0;\\r\\nclock_t now;\\r\\n# ifdef __TMS\\r\\nstruct tms rus;\\r\\nnow = times(&rus);\\r\\nif (usertime)\\r\\nnow = rus.tms_utime;\\r\\n# else\\r\\nif (usertime)\\r\\nnow = clock();\\r\\nelse {\\r\\nstruct timeval tv;\\r\\ngettimeofday(&tv, NULL);\\r\\nnow = (clock_t)((unsigned long long)tv.tv_sec * CLK_TCK +\\r\\n(unsigned long long)tv.tv_usec * (1000000 / CLK_TCK)\\r\\n);\\r\\n}\\r\\n# endif\\r\\nif (stop == TM_START)\\r\\ntmstart = now;\\r\\nelse\\r\\nret = (now - tmstart) / (double)(CLK_TCK);\\r\\nreturn (ret);\\r\\n}\\r\\ndouble app_tminterval(int stop, int usertime)\\r\\n{\\r\\ndouble ret = 0;\\r\\nstruct tms rus;\\r\\nclock_t now = times(&rus);\\r\\nstatic clock_t tmstart;\\r\\nif (usertime)\\r\\nnow = rus.tms_utime;\\r\\nif (stop == TM_START)\\r\\ntmstart = now;\\r\\nelse {\\r\\nlong int tck = sysconf(_SC_CLK_TCK);\\r\\nret = (now - tmstart) / (double)tck;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\ndouble app_tminterval(int stop, int usertime)\\r\\n{\\r\\ndouble ret = 0;\\r\\nstruct rusage rus;\\r\\nstruct timeval now;\\r\\nstatic struct timeval tmstart;\\r\\nif (usertime)\\r\\ngetrusage(RUSAGE_SELF, &rus), now = rus.ru_utime;\\r\\nelse\\r\\ngettimeofday(&now, NULL);\\r\\nif (stop == TM_START)\\r\\ntmstart = now;\\r\\nelse\\r\\nret = ((now.tv_sec + now.tv_usec * 1e-6)\\r\\n- (tmstart.tv_sec + tmstart.tv_usec * 1e-6));\\r\\nreturn ret;\\r\\n}\\r\\nint app_isdir(const char *name)\\r\\n{\\r\\nHANDLE hList;\\r\\nWIN32_FIND_DATA FileData;\\r\\n# if defined(UNICODE) || defined(_UNICODE)\\r\\nsize_t i, len_0 = strlen(name) + 1;\\r\\nif (len_0 > sizeof(FileData.cFileName) / sizeof(FileData.cFileName[0]))\\r\\nreturn -1;\\r\\n# if !defined(_WIN32_WCE) || _WIN32_WCE>=101\\r\\nif (!MultiByteToWideChar\\r\\n(CP_ACP, 0, name, len_0, FileData.cFileName, len_0))\\r\\n# endif\\r\\nfor (i = 0; i < len_0; i++)\\r\\nFileData.cFileName[i] = (WCHAR)name[i];\\r\\nhList = FindFirstFile(FileData.cFileName, &FileData);\\r\\n# else\\r\\nhList = FindFirstFile(name, &FileData);\\r\\n# endif\\r\\nif (hList == INVALID_HANDLE_VALUE)\\r\\nreturn -1;\\r\\nFindClose(hList);\\r\\nreturn ((FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);\\r\\n}\\r\\nint app_isdir(const char *name)\\r\\n{\\r\\n# if defined(S_ISDIR)\\r\\nstruct stat st;\\r\\nif (stat(name, &st) == 0)\\r\\nreturn S_ISDIR(st.st_mode);\\r\\nelse\\r\\nreturn -1;\\r\\n# else\\r\\nreturn -1;\\r\\n# endif\\r\\n}\\r\\nint raw_read_stdin(void *buf, int siz)\\r\\n{\\r\\nDWORD n;\\r\\nif (ReadFile(GetStdHandle(STD_INPUT_HANDLE), buf, siz, &n, NULL))\\r\\nreturn (n);\\r\\nelse\\r\\nreturn (-1);\\r\\n}\\r\\nint raw_read_stdin(void *buf, int siz)\\r\\n{\\r\\nreturn read(fileno(stdin), buf, siz);\\r\\n}\\r\\nint raw_write_stdout(const void *buf, int siz)\\r\\n{\\r\\nDWORD n;\\r\\nif (WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), buf, siz, &n, NULL))\\r\\nreturn (n);\\r\\nelse\\r\\nreturn (-1);\\r\\n}\\r\\nint raw_write_stdout(const void *buf, int siz)\\r\\n{\\r\\nreturn write(fileno(stdout), buf, siz);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cm_pmeth_c", "target": 0, "func": "static int pkey_cmac_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nctx->data = CMAC_CTX_new();\\r\\nif (!ctx->data)\\r\\nreturn 0;\\r\\nctx->keygen_info_count = 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_cmac_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)\\r\\n{\\r\\nif (!pkey_cmac_init(dst))\\r\\nreturn 0;\\r\\nif (!CMAC_CTX_copy(dst->data, src->data))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void pkey_cmac_cleanup(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nCMAC_CTX_free(ctx->data);\\r\\n}\\r\\nstatic int pkey_cmac_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nCMAC_CTX *cmkey = CMAC_CTX_new();\\r\\nCMAC_CTX *cmctx = ctx->data;\\r\\nif (!cmkey)\\r\\nreturn 0;\\r\\nif (!CMAC_CTX_copy(cmkey, cmctx)) {\\r\\nCMAC_CTX_free(cmkey);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_assign(pkey, EVP_PKEY_CMAC, cmkey);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nif (!CMAC_Update(ctx->pctx->data, data, count))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cmac_signctx_init(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx)\\r\\n{\\r\\nEVP_MD_CTX_set_flags(mctx, EVP_MD_CTX_FLAG_NO_INIT);\\r\\nmctx->update = int_update;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cmac_signctx(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,\\r\\nEVP_MD_CTX *mctx)\\r\\n{\\r\\nreturn CMAC_Final(ctx->data, sig, siglen);\\r\\n}\\r\\nstatic int pkey_cmac_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)\\r\\n{\\r\\nCMAC_CTX *cmctx = ctx->data;\\r\\nswitch (type) {\\r\\ncase EVP_PKEY_CTRL_SET_MAC_KEY:\\r\\nif (!p2 || p1 < 0)\\r\\nreturn 0;\\r\\nif (!CMAC_Init(cmctx, p2, p1, NULL, NULL))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase EVP_PKEY_CTRL_CIPHER:\\r\\nif (!CMAC_Init(cmctx, NULL, 0, p2, ctx->engine))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase EVP_PKEY_CTRL_MD:\\r\\nif (ctx->pkey && !CMAC_CTX_copy(ctx->data,\\r\\n(CMAC_CTX *)ctx->pkey->pkey.ptr))\\r\\nreturn 0;\\r\\nif (!CMAC_Init(cmctx, NULL, 0, NULL, NULL))\\r\\nreturn 0;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_cmac_ctrl_str(EVP_PKEY_CTX *ctx,\\r\\nconst char *type, const char *value)\\r\\n{\\r\\nif (!value) {\\r\\nreturn 0;\\r\\n}\\r\\nif (!strcmp(type, \"key\")) {\\r\\nvoid *p = (void *)value;\\r\\nreturn pkey_cmac_ctrl(ctx, EVP_PKEY_CTRL_SET_MAC_KEY, strlen(p), p);\\r\\n}\\r\\nif (!strcmp(type, \"cipher\")) {\\r\\nconst EVP_CIPHER *c;\\r\\nc = EVP_get_cipherbyname(value);\\r\\nif (!c)\\r\\nreturn 0;\\r\\nreturn pkey_cmac_ctrl(ctx, EVP_PKEY_CTRL_CIPHER, -1, (void *)c);\\r\\n}\\r\\nif (!strcmp(type, \"hexkey\")) {\\r\\nunsigned char *key;\\r\\nint r;\\r\\nlong keylen;\\r\\nkey = string_to_hex(value, &keylen);\\r\\nif (!key)\\r\\nreturn 0;\\r\\nr = pkey_cmac_ctrl(ctx, EVP_PKEY_CTRL_SET_MAC_KEY, keylen, key);\\r\\nOPENSSL_free(key);\\r\\nreturn r;\\r\\n}\\r\\nreturn -2;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_depr_c", "target": 0, "func": "BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int safe,\\r\\nconst BIGNUM *add, const BIGNUM *rem,\\r\\nvoid (*callback) (int, int, void *), void *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nBIGNUM *rnd = NULL;\\r\\nint found = 0;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nif (ret == NULL) {\\r\\nif ((rnd = BN_new()) == NULL)\\r\\ngoto err;\\r\\n} else\\r\\nrnd = ret;\\r\\nif (!BN_generate_prime_ex(rnd, bits, safe, add, rem, &cb))\\r\\ngoto err;\\r\\nfound = 1;\\r\\nerr:\\r\\nif (!found && (ret == NULL) && (rnd != NULL))\\r\\nBN_free(rnd);\\r\\nreturn (found ? rnd : NULL);\\r\\n}\\r\\nint BN_is_prime(const BIGNUM *a, int checks,\\r\\nvoid (*callback) (int, int, void *), BN_CTX *ctx_passed,\\r\\nvoid *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nreturn BN_is_prime_ex(a, checks, ctx_passed, &cb);\\r\\n}\\r\\nint BN_is_prime_fasttest(const BIGNUM *a, int checks,\\r\\nvoid (*callback) (int, int, void *),\\r\\nBN_CTX *ctx_passed, void *cb_arg,\\r\\nint do_trial_division)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nreturn BN_is_prime_fasttest_ex(a, checks, ctx_passed,\\r\\ndo_trial_division, &cb);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_seed_cbc_c", "target": 0, "func": "void SEED_cbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const SEED_KEY_SCHEDULE *ks,\\r\\nunsigned char ivec[SEED_BLOCK_SIZE], int enc)\\r\\n{\\r\\nif (enc)\\r\\nCRYPTO_cbc128_encrypt(in, out, len, ks, ivec,\\r\\n(block128_f) SEED_encrypt);\\r\\nelse\\r\\nCRYPTO_cbc128_decrypt(in, out, len, ks, ivec,\\r\\n(block128_f) SEED_decrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_smime_c", "target": 1, "func": "static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\\r\\n{\\r\\nunsigned char buf[4096];\\r\\nint r = 0, i;\\r\\nBIO *tmpout = NULL;\\r\\nif (out == NULL)\\r\\ntmpout = BIO_new(BIO_s_null());\\r\\nelse if (flags & CMS_TEXT) {\\r\\ntmpout = BIO_new(BIO_s_mem());\\r\\nBIO_set_mem_eof_return(tmpout, 0);\\r\\n} else\\r\\ntmpout = out;\\r\\nif (!tmpout) {\\r\\nCMSerr(CMS_F_CMS_COPY_CONTENT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nfor (;;) {\\r\\ni = BIO_read(in, buf, sizeof(buf));\\r\\nif (i <= 0) {\\r\\nif (BIO_method_type(in) == BIO_TYPE_CIPHER) {\\r\\nif (!BIO_get_cipher_status(in))\\r\\ngoto err;\\r\\n}\\r\\nif (i < 0)\\r\\ngoto err;\\r\\nbreak;\\r\\n}\\r\\nif (tmpout && (BIO_write(tmpout, buf, i) != i))\\r\\ngoto err;\\r\\n}\\r\\nif (flags & CMS_TEXT) {\\r\\nif (!SMIME_text(tmpout, out)) {\\r\\nCMSerr(CMS_F_CMS_COPY_CONTENT, CMS_R_SMIME_TEXT_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nr = 1;\\r\\nerr:\\r\\nif (tmpout && (tmpout != out))\\r\\nBIO_free(tmpout);\\r\\nreturn r;\\r\\n}\\r\\nstatic int check_content(CMS_ContentInfo *cms)\\r\\n{\\r\\nASN1_OCTET_STRING **pos = CMS_get0_content(cms);\\r\\nif (!pos || !*pos) {\\r\\nCMSerr(CMS_F_CHECK_CONTENT, CMS_R_NO_CONTENT);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void do_free_upto(BIO *f, BIO *upto)\\r\\n{\\r\\nif (upto) {\\r\\nBIO *tbio;\\r\\ndo {\\r\\ntbio = BIO_pop(f);\\r\\nBIO_free(f);\\r\\nf = tbio;\\r\\n}\\r\\nwhile (f != upto);\\r\\n} else\\r\\nBIO_free_all(f);\\r\\n}\\r\\nint CMS_data(CMS_ContentInfo *cms, BIO *out, unsigned int flags)\\r\\n{\\r\\nBIO *cont;\\r\\nint r;\\r\\nif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_data) {\\r\\nCMSerr(CMS_F_CMS_DATA, CMS_R_TYPE_NOT_DATA);\\r\\nreturn 0;\\r\\n}\\r\\ncont = CMS_dataInit(cms, NULL);\\r\\nif (!cont)\\r\\nreturn 0;\\r\\nr = cms_copy_content(out, cont, flags);\\r\\nBIO_free_all(cont);\\r\\nreturn r;\\r\\n}\\r\\nCMS_ContentInfo *CMS_data_create(BIO *in, unsigned int flags)\\r\\n{\\r\\nCMS_ContentInfo *cms;\\r\\ncms = cms_Data_create();\\r\\nif (!cms)\\r\\nreturn NULL;\\r\\nif ((flags & CMS_STREAM) || CMS_final(cms, in, NULL, flags))\\r\\nreturn cms;\\r\\nCMS_ContentInfo_free(cms);\\r\\nreturn NULL;\\r\\n}\\r\\nint CMS_digest_verify(CMS_ContentInfo *cms, BIO *dcont, BIO *out,\\r\\nunsigned int flags)\\r\\n{\\r\\nBIO *cont;\\r\\nint r;\\r\\nif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_digest) {\\r\\nCMSerr(CMS_F_CMS_DIGEST_VERIFY, CMS_R_TYPE_NOT_DIGESTED_DATA);\\r\\nreturn 0;\\r\\n}\\r\\nif (!dcont && !check_content(cms))\\r\\nreturn 0;\\r\\ncont = CMS_dataInit(cms, dcont);\\r\\nif (!cont)\\r\\nreturn 0;\\r\\nr = cms_copy_content(out, cont, flags);\\r\\nif (r)\\r\\nr = cms_DigestedData_do_final(cms, cont, 1);\\r\\ndo_free_upto(cont, dcont);\\r\\nreturn r;\\r\\n}\\r\\nCMS_ContentInfo *CMS_digest_create(BIO *in, const EVP_MD *md,\\r\\nunsigned int flags)\\r\\n{\\r\\nCMS_ContentInfo *cms;\\r\\nif (!md)\\r\\nmd = EVP_sha1();\\r\\ncms = cms_DigestedData_create(md);\\r\\nif (!cms)\\r\\nreturn NULL;\\r\\nif (!(flags & CMS_DETACHED))\\r\\nCMS_set_detached(cms, 0);\\r\\nif ((flags & CMS_STREAM) || CMS_final(cms, in, NULL, flags))\\r\\nreturn cms;\\r\\nCMS_ContentInfo_free(cms);\\r\\nreturn NULL;\\r\\n}\\r\\nint CMS_EncryptedData_decrypt(CMS_ContentInfo *cms,\\r\\nconst unsigned char *key, size_t keylen,\\r\\nBIO *dcont, BIO *out, unsigned int flags)\\r\\n{\\r\\nBIO *cont;\\r\\nint r;\\r\\nif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_encrypted) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDDATA_DECRYPT,\\r\\nCMS_R_TYPE_NOT_ENCRYPTED_DATA);\\r\\nreturn 0;\\r\\n}\\r\\nif (!dcont && !check_content(cms))\\r\\nreturn 0;\\r\\nif (CMS_EncryptedData_set1_key(cms, NULL, key, keylen) <= 0)\\r\\nreturn 0;\\r\\ncont = CMS_dataInit(cms, dcont);\\r\\nif (!cont)\\r\\nreturn 0;\\r\\nr = cms_copy_content(out, cont, flags);\\r\\ndo_free_upto(cont, dcont);\\r\\nreturn r;\\r\\n}\\r\\nCMS_ContentInfo *CMS_EncryptedData_encrypt(BIO *in, const EVP_CIPHER *cipher,\\r\\nconst unsigned char *key,\\r\\nsize_t keylen, unsigned int flags)\\r\\n{\\r\\nCMS_ContentInfo *cms;\\r\\nif (!cipher) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDDATA_ENCRYPT, CMS_R_NO_CIPHER);\\r\\nreturn NULL;\\r\\n}\\r\\ncms = CMS_ContentInfo_new();\\r\\nif (!cms)\\r\\nreturn NULL;\\r\\nif (!CMS_EncryptedData_set1_key(cms, cipher, key, keylen))\\r\\nreturn NULL;\\r\\nif (!(flags & CMS_DETACHED))\\r\\nCMS_set_detached(cms, 0);\\r\\nif ((flags & (CMS_STREAM | CMS_PARTIAL))\\r\\n|| CMS_final(cms, in, NULL, flags))\\r\\nreturn cms;\\r\\nCMS_ContentInfo_free(cms);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int cms_kari_set1_pkey(CMS_ContentInfo *cms, CMS_RecipientInfo *ri,\\r\\nEVP_PKEY *pk, X509 *cert)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(CMS_RecipientEncryptedKey) *reks;\\r\\nCMS_RecipientEncryptedKey *rek;\\r\\nreks = CMS_RecipientInfo_kari_get0_reks(ri);\\r\\nif (!cert)\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_CMS_RecipientEncryptedKey_num(reks); i++) {\\r\\nint rv;\\r\\nrek = sk_CMS_RecipientEncryptedKey_value(reks, i);\\r\\nif (CMS_RecipientEncryptedKey_cert_cmp(rek, cert))\\r\\ncontinue;\\r\\nCMS_RecipientInfo_kari_set0_pkey(ri, pk);\\r\\nrv = CMS_RecipientInfo_kari_decrypt(cms, ri, rek);\\r\\nCMS_RecipientInfo_kari_set0_pkey(ri, NULL);\\r\\nif (rv > 0)\\r\\nreturn 1;\\r\\nreturn -1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_decrypt_set1_pkey(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert)\\r\\n{\\r\\nSTACK_OF(CMS_RecipientInfo) *ris;\\r\\nCMS_RecipientInfo *ri;\\r\\nint i, r, ri_type;\\r\\nint debug = 0, match_ri = 0;\\r\\nris = CMS_get0_RecipientInfos(cms);\\r\\nif (ris)\\r\\ndebug = cms->d.envelopedData->encryptedContentInfo->debug;\\r\\nri_type = cms_pkey_get_ri_type(pk);\\r\\nif (ri_type == CMS_RECIPINFO_NONE) {\\r\\nCMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY,\\r\\nCMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_CMS_RecipientInfo_num(ris); i++) {\\r\\nri = sk_CMS_RecipientInfo_value(ris, i);\\r\\nif (CMS_RecipientInfo_type(ri) != ri_type)\\r\\ncontinue;\\r\\nmatch_ri = 1;\\r\\nif (ri_type == CMS_RECIPINFO_AGREE) {\\r\\nr = cms_kari_set1_pkey(cms, ri, pk, cert);\\r\\nif (r > 0)\\r\\nreturn 1;\\r\\nif (r < 0)\\r\\nreturn 0;\\r\\n}\\r\\nelse if (!cert || !CMS_RecipientInfo_ktri_cert_cmp(ri, cert)) {\\r\\nCMS_RecipientInfo_set0_pkey(ri, pk);\\r\\nr = CMS_RecipientInfo_decrypt(cms, ri);\\r\\nCMS_RecipientInfo_set0_pkey(ri, NULL);\\r\\nif (cert) {\\r\\nif (!debug) {\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nif (r > 0)\\r\\nreturn 1;\\r\\nCMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY, CMS_R_DECRYPT_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nelse if (r > 0 && debug)\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nif (match_ri && !cert && !debug) {\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nCMSerr(CMS_F_CMS_DECRYPT_SET1_PKEY, CMS_R_NO_MATCHING_RECIPIENT);\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_decrypt_set1_key(CMS_ContentInfo *cms,\\r\\nunsigned char *key, size_t keylen,\\r\\nunsigned char *id, size_t idlen)\\r\\n{\\r\\nSTACK_OF(CMS_RecipientInfo) *ris;\\r\\nCMS_RecipientInfo *ri;\\r\\nint i, r;\\r\\nris = CMS_get0_RecipientInfos(cms);\\r\\nfor (i = 0; i < sk_CMS_RecipientInfo_num(ris); i++) {\\r\\nri = sk_CMS_RecipientInfo_value(ris, i);\\r\\nif (CMS_RecipientInfo_type(ri) != CMS_RECIPINFO_KEK)\\r\\ncontinue;\\r\\nif (!id || (CMS_RecipientInfo_kekri_id_cmp(ri, id, idlen) == 0)) {\\r\\nCMS_RecipientInfo_set0_key(ri, key, keylen);\\r\\nr = CMS_RecipientInfo_decrypt(cms, ri);\\r\\nCMS_RecipientInfo_set0_key(ri, NULL, 0);\\r\\nif (r > 0)\\r\\nreturn 1;\\r\\nif (id) {\\r\\nCMSerr(CMS_F_CMS_DECRYPT_SET1_KEY, CMS_R_DECRYPT_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\nCMSerr(CMS_F_CMS_DECRYPT_SET1_KEY, CMS_R_NO_MATCHING_RECIPIENT);\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_decrypt_set1_password(CMS_ContentInfo *cms,\\r\\nunsigned char *pass, ossl_ssize_t passlen)\\r\\n{\\r\\nSTACK_OF(CMS_RecipientInfo) *ris;\\r\\nCMS_RecipientInfo *ri;\\r\\nint i, r;\\r\\nris = CMS_get0_RecipientInfos(cms);\\r\\nfor (i = 0; i < sk_CMS_RecipientInfo_num(ris); i++) {\\r\\nri = sk_CMS_RecipientInfo_value(ris, i);\\r\\nif (CMS_RecipientInfo_type(ri) != CMS_RECIPINFO_PASS)\\r\\ncontinue;\\r\\nCMS_RecipientInfo_set0_password(ri, pass, passlen);\\r\\nr = CMS_RecipientInfo_decrypt(cms, ri);\\r\\nCMS_RecipientInfo_set0_password(ri, NULL, 0);\\r\\nif (r > 0)\\r\\nreturn 1;\\r\\n}\\r\\nCMSerr(CMS_F_CMS_DECRYPT_SET1_PASSWORD, CMS_R_NO_MATCHING_RECIPIENT);\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,\\r\\nBIO *dcont, BIO *out, unsigned int flags)\\r\\n{\\r\\nint r;\\r\\nBIO *cont;\\r\\nif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {\\r\\nCMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);\\r\\nreturn 0;\\r\\n}\\r\\nif (!dcont && !check_content(cms))\\r\\nreturn 0;\\r\\nif (flags & CMS_DEBUG_DECRYPT)\\r\\ncms->d.envelopedData->encryptedContentInfo->debug = 1;\\r\\nelse\\r\\ncms->d.envelopedData->encryptedContentInfo->debug = 0;\\r\\nif (!pk && !cert && !dcont && !out)\\r\\nreturn 1;\\r\\nif (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))\\r\\nreturn 0;\\r\\ncont = CMS_dataInit(cms, dcont);\\r\\nif (!cont)\\r\\nreturn 0;\\r\\nr = cms_copy_content(out, cont, flags);\\r\\ndo_free_upto(cont, dcont);\\r\\nreturn r;\\r\\n}\\r\\nint CMS_final(CMS_ContentInfo *cms, BIO *data, BIO *dcont, unsigned int flags)\\r\\n{\\r\\nBIO *cmsbio;\\r\\nint ret = 0;\\r\\nif (!(cmsbio = CMS_dataInit(cms, dcont))) {\\r\\nCMSerr(CMS_F_CMS_FINAL, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nSMIME_crlf_copy(data, cmsbio, flags);\\r\\n(void)BIO_flush(cmsbio);\\r\\nif (!CMS_dataFinal(cms, cmsbio)) {\\r\\nCMSerr(CMS_F_CMS_FINAL, CMS_R_CMS_DATAFINAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\ndo_free_upto(cmsbio, dcont);\\r\\nreturn ret;\\r\\n}\\r\\nint CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out,\\r\\nunsigned int flags)\\r\\n{\\r\\nBIO *cont;\\r\\nint r;\\r\\nif (OBJ_obj2nid(CMS_get0_type(cms)) != NID_id_smime_ct_compressedData) {\\r\\nCMSerr(CMS_F_CMS_UNCOMPRESS, CMS_R_TYPE_NOT_COMPRESSED_DATA);\\r\\nreturn 0;\\r\\n}\\r\\nif (!dcont && !check_content(cms))\\r\\nreturn 0;\\r\\ncont = CMS_dataInit(cms, dcont);\\r\\nif (!cont)\\r\\nreturn 0;\\r\\nr = cms_copy_content(out, cont, flags);\\r\\ndo_free_upto(cont, dcont);\\r\\nreturn r;\\r\\n}\\r\\nCMS_ContentInfo *CMS_compress(BIO *in, int comp_nid, unsigned int flags)\\r\\n{\\r\\nCMS_ContentInfo *cms;\\r\\nif (comp_nid <= 0)\\r\\ncomp_nid = NID_zlib_compression;\\r\\ncms = cms_CompressedData_create(comp_nid);\\r\\nif (!cms)\\r\\nreturn NULL;\\r\\nif (!(flags & CMS_DETACHED))\\r\\nCMS_set_detached(cms, 0);\\r\\nif ((flags & CMS_STREAM) || CMS_final(cms, in, NULL, flags))\\r\\nreturn cms;\\r\\nCMS_ContentInfo_free(cms);\\r\\nreturn NULL;\\r\\n}\\r\\nint CMS_uncompress(CMS_ContentInfo *cms, BIO *dcont, BIO *out,\\r\\nunsigned int flags)\\r\\n{\\r\\nCMSerr(CMS_F_CMS_UNCOMPRESS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\\r\\nreturn 0;\\r\\n}\\r\\nCMS_ContentInfo *CMS_compress(BIO *in, int comp_nid, unsigned int flags)\\r\\n{\\r\\nCMSerr(CMS_F_CMS_COMPRESS, CMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_m_md2_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn MD2_Init(ctx->md_data);\\r\\n}\\r\\nstatic int update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn MD2_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn MD2_Final(md, ctx->md_data);\\r\\n}\\r\\nconst EVP_MD *EVP_md2(void)\\r\\n{\\r\\nreturn (&md2_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pk7_lib_c", "target": 0, "func": "long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg)\\r\\n{\\r\\nint nid;\\r\\nlong ret;\\r\\nnid = OBJ_obj2nid(p7->type);\\r\\nswitch (cmd) {\\r\\ncase PKCS7_OP_SET_DETACHED_SIGNATURE:\\r\\nif (nid == NID_pkcs7_signed) {\\r\\nret = p7->detached = (int)larg;\\r\\nif (ret && PKCS7_type_is_data(p7->d.sign->contents)) {\\r\\nASN1_OCTET_STRING *os;\\r\\nos = p7->d.sign->contents->d.data;\\r\\nASN1_OCTET_STRING_free(os);\\r\\np7->d.sign->contents->d.data = NULL;\\r\\n}\\r\\n} else {\\r\\nPKCS7err(PKCS7_F_PKCS7_CTRL,\\r\\nPKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);\\r\\nret = 0;\\r\\n}\\r\\nbreak;\\r\\ncase PKCS7_OP_GET_DETACHED_SIGNATURE:\\r\\nif (nid == NID_pkcs7_signed) {\\r\\nif (!p7->d.sign || !p7->d.sign->contents->d.ptr)\\r\\nret = 1;\\r\\nelse\\r\\nret = 0;\\r\\np7->detached = ret;\\r\\n} else {\\r\\nPKCS7err(PKCS7_F_PKCS7_CTRL,\\r\\nPKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE);\\r\\nret = 0;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_CTRL, PKCS7_R_UNKNOWN_OPERATION);\\r\\nret = 0;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint PKCS7_content_new(PKCS7 *p7, int type)\\r\\n{\\r\\nPKCS7 *ret = NULL;\\r\\nif ((ret = PKCS7_new()) == NULL)\\r\\ngoto err;\\r\\nif (!PKCS7_set_type(ret, type))\\r\\ngoto err;\\r\\nif (!PKCS7_set_content(p7, ret))\\r\\ngoto err;\\r\\nreturn (1);\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nPKCS7_free(ret);\\r\\nreturn (0);\\r\\n}\\r\\nint PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data)\\r\\n{\\r\\nint i;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_signed:\\r\\nif (p7->d.sign->contents != NULL)\\r\\nPKCS7_free(p7->d.sign->contents);\\r\\np7->d.sign->contents = p7_data;\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nif (p7->d.digest->contents != NULL)\\r\\nPKCS7_free(p7->d.digest->contents);\\r\\np7->d.digest->contents = p7_data;\\r\\nbreak;\\r\\ncase NID_pkcs7_data:\\r\\ncase NID_pkcs7_enveloped:\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\ncase NID_pkcs7_encrypted:\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_CONTENT, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nreturn (1);\\r\\nerr:\\r\\nreturn (0);\\r\\n}\\r\\nint PKCS7_set_type(PKCS7 *p7, int type)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nobj = OBJ_nid2obj(type);\\r\\nswitch (type) {\\r\\ncase NID_pkcs7_signed:\\r\\np7->type = obj;\\r\\nif ((p7->d.sign = PKCS7_SIGNED_new()) == NULL)\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(p7->d.sign->version, 1)) {\\r\\nPKCS7_SIGNED_free(p7->d.sign);\\r\\np7->d.sign = NULL;\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_data:\\r\\np7->type = obj;\\r\\nif ((p7->d.data = M_ASN1_OCTET_STRING_new()) == NULL)\\r\\ngoto err;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\np7->type = obj;\\r\\nif ((p7->d.signed_and_enveloped = PKCS7_SIGN_ENVELOPE_new())\\r\\n== NULL)\\r\\ngoto err;\\r\\nASN1_INTEGER_set(p7->d.signed_and_enveloped->version, 1);\\r\\nif (!ASN1_INTEGER_set(p7->d.signed_and_enveloped->version, 1))\\r\\ngoto err;\\r\\np7->d.signed_and_enveloped->enc_data->content_type\\r\\n= OBJ_nid2obj(NID_pkcs7_data);\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\np7->type = obj;\\r\\nif ((p7->d.enveloped = PKCS7_ENVELOPE_new())\\r\\n== NULL)\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(p7->d.enveloped->version, 0))\\r\\ngoto err;\\r\\np7->d.enveloped->enc_data->content_type = OBJ_nid2obj(NID_pkcs7_data);\\r\\nbreak;\\r\\ncase NID_pkcs7_encrypted:\\r\\np7->type = obj;\\r\\nif ((p7->d.encrypted = PKCS7_ENCRYPT_new())\\r\\n== NULL)\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(p7->d.encrypted->version, 0))\\r\\ngoto err;\\r\\np7->d.encrypted->enc_data->content_type = OBJ_nid2obj(NID_pkcs7_data);\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\np7->type = obj;\\r\\nif ((p7->d.digest = PKCS7_DIGEST_new())\\r\\n== NULL)\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(p7->d.digest->version, 0))\\r\\ngoto err;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_TYPE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nreturn (1);\\r\\nerr:\\r\\nreturn (0);\\r\\n}\\r\\nint PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other)\\r\\n{\\r\\np7->type = OBJ_nid2obj(type);\\r\\np7->d.other = other;\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *psi)\\r\\n{\\r\\nint i, j, nid;\\r\\nX509_ALGOR *alg;\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *signer_sk;\\r\\nSTACK_OF(X509_ALGOR) *md_sk;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_signed:\\r\\nsigner_sk = p7->d.sign->signer_info;\\r\\nmd_sk = p7->d.sign->md_algs;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsigner_sk = p7->d.signed_and_enveloped->signer_info;\\r\\nmd_sk = p7->d.signed_and_enveloped->md_algs;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_SIGNER, PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn (0);\\r\\n}\\r\\nnid = OBJ_obj2nid(psi->digest_alg->algorithm);\\r\\nj = 0;\\r\\nfor (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\\r\\nalg = sk_X509_ALGOR_value(md_sk, i);\\r\\nif (OBJ_obj2nid(alg->algorithm) == nid) {\\r\\nj = 1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!j) {\\r\\nif (!(alg = X509_ALGOR_new())\\r\\n|| !(alg->parameter = ASN1_TYPE_new())) {\\r\\nX509_ALGOR_free(alg);\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_SIGNER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nalg->algorithm = OBJ_nid2obj(nid);\\r\\nalg->parameter->type = V_ASN1_NULL;\\r\\nif (!sk_X509_ALGOR_push(md_sk, alg)) {\\r\\nX509_ALGOR_free(alg);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (!sk_PKCS7_SIGNER_INFO_push(signer_sk, psi))\\r\\nreturn 0;\\r\\nreturn (1);\\r\\n}\\r\\nint PKCS7_add_certificate(PKCS7 *p7, X509 *x509)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509) **sk;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_signed:\\r\\nsk = &(p7->d.sign->cert);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsk = &(p7->d.signed_and_enveloped->cert);\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE, PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn (0);\\r\\n}\\r\\nif (*sk == NULL)\\r\\n*sk = sk_X509_new_null();\\r\\nif (*sk == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_CERTIFICATE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&x509->references, 1, CRYPTO_LOCK_X509);\\r\\nif (!sk_X509_push(*sk, x509)) {\\r\\nX509_free(x509);\\r\\nreturn 0;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nint PKCS7_add_crl(PKCS7 *p7, X509_CRL *crl)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_CRL) **sk;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_signed:\\r\\nsk = &(p7->d.sign->crl);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsk = &(p7->d.signed_and_enveloped->crl);\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_CRL, PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn (0);\\r\\n}\\r\\nif (*sk == NULL)\\r\\n*sk = sk_X509_CRL_new_null();\\r\\nif (*sk == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_CRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&crl->references, 1, CRYPTO_LOCK_X509_CRL);\\r\\nif (!sk_X509_CRL_push(*sk, crl)) {\\r\\nX509_CRL_free(crl);\\r\\nreturn 0;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nint PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,\\r\\nconst EVP_MD *dgst)\\r\\n{\\r\\nint ret;\\r\\nif (!ASN1_INTEGER_set(p7i->version, 1))\\r\\ngoto err;\\r\\nif (!X509_NAME_set(&p7i->issuer_and_serial->issuer,\\r\\nX509_get_issuer_name(x509)))\\r\\ngoto err;\\r\\nM_ASN1_INTEGER_free(p7i->issuer_and_serial->serial);\\r\\nif (!(p7i->issuer_and_serial->serial =\\r\\nM_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))\\r\\ngoto err;\\r\\nCRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\np7i->pkey = pkey;\\r\\nX509_ALGOR_set0(p7i->digest_alg, OBJ_nid2obj(EVP_MD_type(dgst)),\\r\\nV_ASN1_NULL, NULL);\\r\\nif (pkey->ameth && pkey->ameth->pkey_ctrl) {\\r\\nret = pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_PKCS7_SIGN, 0, p7i);\\r\\nif (ret > 0)\\r\\nreturn 1;\\r\\nif (ret != -2) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SET,\\r\\nPKCS7_R_SIGNING_CTRL_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SET,\\r\\nPKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nPKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey,\\r\\nconst EVP_MD *dgst)\\r\\n{\\r\\nPKCS7_SIGNER_INFO *si = NULL;\\r\\nif (dgst == NULL) {\\r\\nint def_nid;\\r\\nif (EVP_PKEY_get_default_digest_nid(pkey, &def_nid) <= 0)\\r\\ngoto err;\\r\\ndgst = EVP_get_digestbynid(def_nid);\\r\\nif (dgst == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_SIGNATURE, PKCS7_R_NO_DEFAULT_DIGEST);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((si = PKCS7_SIGNER_INFO_new()) == NULL)\\r\\ngoto err;\\r\\nif (!PKCS7_SIGNER_INFO_set(si, x509, pkey, dgst))\\r\\ngoto err;\\r\\nif (!PKCS7_add_signer(p7, si))\\r\\ngoto err;\\r\\nreturn (si);\\r\\nerr:\\r\\nif (si)\\r\\nPKCS7_SIGNER_INFO_free(si);\\r\\nreturn (NULL);\\r\\n}\\r\\nint PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md)\\r\\n{\\r\\nif (PKCS7_type_is_digest(p7)) {\\r\\nif (!(p7->d.digest->md->parameter = ASN1_TYPE_new())) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_DIGEST, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\np7->d.digest->md->parameter->type = V_ASN1_NULL;\\r\\np7->d.digest->md->algorithm = OBJ_nid2obj(EVP_MD_nid(md));\\r\\nreturn 1;\\r\\n}\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_DIGEST, PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn 1;\\r\\n}\\r\\nvoid PKCS7_RECIP_INFO_get0_alg(PKCS7_RECIP_INFO *ri, X509_ALGOR **penc)\\r\\n{\\r\\nif (penc)\\r\\n*penc = ri->key_enc_algor;\\r\\n}\\r\\nPKCS7_RECIP_INFO *PKCS7_add_recipient(PKCS7 *p7, X509 *x509)\\r\\n{\\r\\nPKCS7_RECIP_INFO *ri;\\r\\nif ((ri = PKCS7_RECIP_INFO_new()) == NULL)\\r\\ngoto err;\\r\\nif (!PKCS7_RECIP_INFO_set(ri, x509))\\r\\ngoto err;\\r\\nif (!PKCS7_add_recipient_info(p7, ri))\\r\\ngoto err;\\r\\nreturn ri;\\r\\nerr:\\r\\nif (ri)\\r\\nPKCS7_RECIP_INFO_free(ri);\\r\\nreturn NULL;\\r\\n}\\r\\nint PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *sk;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsk = p7->d.signed_and_enveloped->recipientinfo;\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nsk = p7->d.enveloped->recipientinfo;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_ADD_RECIPIENT_INFO,\\r\\nPKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn (0);\\r\\n}\\r\\nif (!sk_PKCS7_RECIP_INFO_push(sk, ri))\\r\\nreturn 0;\\r\\nreturn (1);\\r\\n}\\r\\nint PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)\\r\\n{\\r\\nint ret;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nif (!ASN1_INTEGER_set(p7i->version, 0))\\r\\nreturn 0;\\r\\nif (!X509_NAME_set(&p7i->issuer_and_serial->issuer,\\r\\nX509_get_issuer_name(x509)))\\r\\nreturn 0;\\r\\nM_ASN1_INTEGER_free(p7i->issuer_and_serial->serial);\\r\\nif (!(p7i->issuer_and_serial->serial =\\r\\nM_ASN1_INTEGER_dup(X509_get_serialNumber(x509))))\\r\\nreturn 0;\\r\\npkey = X509_get_pubkey(x509);\\r\\nif (!pkey || !pkey->ameth || !pkey->ameth->pkey_ctrl) {\\r\\nPKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,\\r\\nPKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nret = pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_PKCS7_ENCRYPT, 0, p7i);\\r\\nif (ret == -2) {\\r\\nPKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,\\r\\nPKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (ret <= 0) {\\r\\nPKCS7err(PKCS7_F_PKCS7_RECIP_INFO_SET,\\r\\nPKCS7_R_ENCRYPTION_CTRL_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_PKEY_free(pkey);\\r\\nCRYPTO_add(&x509->references, 1, CRYPTO_LOCK_X509);\\r\\np7i->cert = x509;\\r\\nreturn 1;\\r\\nerr:\\r\\nif (pkey)\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn 0;\\r\\n}\\r\\nX509 *PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nif (PKCS7_type_is_signed(p7))\\r\\nreturn (X509_find_by_issuer_and_serial(p7->d.sign->cert,\\r\\nsi->issuer_and_serial->issuer,\\r\\nsi->\\r\\nissuer_and_serial->serial));\\r\\nelse\\r\\nreturn (NULL);\\r\\n}\\r\\nint PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)\\r\\n{\\r\\nint i;\\r\\nPKCS7_ENC_CONTENT *ec;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nec = p7->d.signed_and_enveloped->enc_data;\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nec = p7->d.enveloped->enc_data;\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_CIPHER, PKCS7_R_WRONG_CONTENT_TYPE);\\r\\nreturn (0);\\r\\n}\\r\\ni = EVP_CIPHER_type(cipher);\\r\\nif (i == NID_undef) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SET_CIPHER,\\r\\nPKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER);\\r\\nreturn (0);\\r\\n}\\r\\nec->cipher = cipher;\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS7_stream(unsigned char ***boundary, PKCS7 *p7)\\r\\n{\\r\\nASN1_OCTET_STRING *os = NULL;\\r\\nswitch (OBJ_obj2nid(p7->type)) {\\r\\ncase NID_pkcs7_data:\\r\\nos = p7->d.data;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nos = p7->d.signed_and_enveloped->enc_data->enc_data;\\r\\nif (os == NULL) {\\r\\nos = M_ASN1_OCTET_STRING_new();\\r\\np7->d.signed_and_enveloped->enc_data->enc_data = os;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nos = p7->d.enveloped->enc_data->enc_data;\\r\\nif (os == NULL) {\\r\\nos = M_ASN1_OCTET_STRING_new();\\r\\np7->d.enveloped->enc_data->enc_data = os;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_signed:\\r\\nos = p7->d.sign->contents->d.data;\\r\\nbreak;\\r\\ndefault:\\r\\nos = NULL;\\r\\nbreak;\\r\\n}\\r\\nif (os == NULL)\\r\\nreturn 0;\\r\\nos->flags |= ASN1_STRING_FLAG_NDEF;\\r\\n*boundary = &os->data;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_cmp_c", "target": 0, "func": "int X509_issuer_and_serial_cmp(const X509 *a, const X509 *b)\\r\\n{\\r\\nint i;\\r\\nX509_CINF *ai, *bi;\\r\\nai = a->cert_info;\\r\\nbi = b->cert_info;\\r\\ni = M_ASN1_INTEGER_cmp(ai->serialNumber, bi->serialNumber);\\r\\nif (i)\\r\\nreturn (i);\\r\\nreturn (X509_NAME_cmp(ai->issuer, bi->issuer));\\r\\n}\\r\\nunsigned long X509_issuer_and_serial_hash(X509 *a)\\r\\n{\\r\\nunsigned long ret = 0;\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char md[16];\\r\\nchar *f;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nf = X509_NAME_oneline(a->cert_info->issuer, NULL, 0);\\r\\nif (!EVP_DigestInit_ex(&ctx, EVP_md5(), NULL))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&ctx, (unsigned char *)f, strlen(f)))\\r\\ngoto err;\\r\\nOPENSSL_free(f);\\r\\nif (!EVP_DigestUpdate\\r\\n(&ctx, (unsigned char *)a->cert_info->serialNumber->data,\\r\\n(unsigned long)a->cert_info->serialNumber->length))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&ctx, &(md[0]), NULL))\\r\\ngoto err;\\r\\nret = (((unsigned long)md[0]) | ((unsigned long)md[1] << 8L) |\\r\\n((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L)\\r\\n) & 0xffffffffL;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nint X509_issuer_name_cmp(const X509 *a, const X509 *b)\\r\\n{\\r\\nreturn (X509_NAME_cmp(a->cert_info->issuer, b->cert_info->issuer));\\r\\n}\\r\\nint X509_subject_name_cmp(const X509 *a, const X509 *b)\\r\\n{\\r\\nreturn (X509_NAME_cmp(a->cert_info->subject, b->cert_info->subject));\\r\\n}\\r\\nint X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b)\\r\\n{\\r\\nreturn (X509_NAME_cmp(a->crl->issuer, b->crl->issuer));\\r\\n}\\r\\nint X509_CRL_match(const X509_CRL *a, const X509_CRL *b)\\r\\n{\\r\\nreturn memcmp(a->sha1_hash, b->sha1_hash, 20);\\r\\n}\\r\\nX509_NAME *X509_get_issuer_name(X509 *a)\\r\\n{\\r\\nreturn (a->cert_info->issuer);\\r\\n}\\r\\nunsigned long X509_issuer_name_hash(X509 *x)\\r\\n{\\r\\nreturn (X509_NAME_hash(x->cert_info->issuer));\\r\\n}\\r\\nunsigned long X509_issuer_name_hash_old(X509 *x)\\r\\n{\\r\\nreturn (X509_NAME_hash_old(x->cert_info->issuer));\\r\\n}\\r\\nX509_NAME *X509_get_subject_name(X509 *a)\\r\\n{\\r\\nreturn (a->cert_info->subject);\\r\\n}\\r\\nASN1_INTEGER *X509_get_serialNumber(X509 *a)\\r\\n{\\r\\nreturn (a->cert_info->serialNumber);\\r\\n}\\r\\nunsigned long X509_subject_name_hash(X509 *x)\\r\\n{\\r\\nreturn (X509_NAME_hash(x->cert_info->subject));\\r\\n}\\r\\nunsigned long X509_subject_name_hash_old(X509 *x)\\r\\n{\\r\\nreturn (X509_NAME_hash_old(x->cert_info->subject));\\r\\n}\\r\\nint X509_cmp(const X509 *a, const X509 *b)\\r\\n{\\r\\nint rv;\\r\\nX509_check_purpose((X509 *)a, -1, 0);\\r\\nX509_check_purpose((X509 *)b, -1, 0);\\r\\nrv = memcmp(a->sha1_hash, b->sha1_hash, SHA_DIGEST_LENGTH);\\r\\nif (rv)\\r\\nreturn rv;\\r\\nif (!a->cert_info->enc.modified && !b->cert_info->enc.modified) {\\r\\nrv = (int)(a->cert_info->enc.len - b->cert_info->enc.len);\\r\\nif (rv)\\r\\nreturn rv;\\r\\nreturn memcmp(a->cert_info->enc.enc, b->cert_info->enc.enc,\\r\\na->cert_info->enc.len);\\r\\n}\\r\\nreturn rv;\\r\\n}\\r\\nint X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b)\\r\\n{\\r\\nint ret;\\r\\nif (!a->canon_enc || a->modified) {\\r\\nret = i2d_X509_NAME((X509_NAME *)a, NULL);\\r\\nif (ret < 0)\\r\\nreturn -2;\\r\\n}\\r\\nif (!b->canon_enc || b->modified) {\\r\\nret = i2d_X509_NAME((X509_NAME *)b, NULL);\\r\\nif (ret < 0)\\r\\nreturn -2;\\r\\n}\\r\\nret = a->canon_enclen - b->canon_enclen;\\r\\nif (ret)\\r\\nreturn ret;\\r\\nreturn memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);\\r\\n}\\r\\nunsigned long X509_NAME_hash(X509_NAME *x)\\r\\n{\\r\\nunsigned long ret = 0;\\r\\nunsigned char md[SHA_DIGEST_LENGTH];\\r\\ni2d_X509_NAME(x, NULL);\\r\\nif (!EVP_Digest(x->canon_enc, x->canon_enclen, md, NULL, EVP_sha1(),\\r\\nNULL))\\r\\nreturn 0;\\r\\nret = (((unsigned long)md[0]) | ((unsigned long)md[1] << 8L) |\\r\\n((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L)\\r\\n) & 0xffffffffL;\\r\\nreturn (ret);\\r\\n}\\r\\nunsigned long X509_NAME_hash_old(X509_NAME *x)\\r\\n{\\r\\nEVP_MD_CTX md_ctx;\\r\\nunsigned long ret = 0;\\r\\nunsigned char md[16];\\r\\ni2d_X509_NAME(x, NULL);\\r\\nEVP_MD_CTX_init(&md_ctx);\\r\\nEVP_MD_CTX_set_flags(&md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\\r\\nif (EVP_DigestInit_ex(&md_ctx, EVP_md5(), NULL)\\r\\n&& EVP_DigestUpdate(&md_ctx, x->bytes->data, x->bytes->length)\\r\\n&& EVP_DigestFinal_ex(&md_ctx, md, NULL))\\r\\nret = (((unsigned long)md[0]) | ((unsigned long)md[1] << 8L) |\\r\\n((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L)\\r\\n) & 0xffffffffL;\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nEVP_PKEY *X509_get_pubkey(X509 *x)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL))\\r\\nreturn (NULL);\\r\\nreturn (X509_PUBKEY_get(x->cert_info->key));\\r\\n}\\r\\nASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x)\\r\\n{\\r\\nif (!x)\\r\\nreturn NULL;\\r\\nreturn x->cert_info->key->public_key;\\r\\n}\\r\\nint X509_check_private_key(X509 *x, EVP_PKEY *k)\\r\\n{\\r\\nEVP_PKEY *xk;\\r\\nint ret;\\r\\nxk = X509_get_pubkey(x);\\r\\nif (xk)\\r\\nret = EVP_PKEY_cmp(xk, k);\\r\\nelse\\r\\nret = -2;\\r\\nswitch (ret) {\\r\\ncase 1:\\r\\nbreak;\\r\\ncase 0:\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY, X509_R_KEY_VALUES_MISMATCH);\\r\\nbreak;\\r\\ncase -1:\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH);\\r\\nbreak;\\r\\ncase -2:\\r\\nX509err(X509_F_X509_CHECK_PRIVATE_KEY, X509_R_UNKNOWN_KEY_TYPE);\\r\\n}\\r\\nif (xk)\\r\\nEVP_PKEY_free(xk);\\r\\nif (ret > 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int check_suite_b(EVP_PKEY *pkey, int sign_nid, unsigned long *pflags)\\r\\n{\\r\\nconst EC_GROUP *grp = NULL;\\r\\nint curve_nid;\\r\\nif (pkey && pkey->type == EVP_PKEY_EC)\\r\\ngrp = EC_KEY_get0_group(pkey->pkey.ec);\\r\\nif (!grp)\\r\\nreturn X509_V_ERR_SUITE_B_INVALID_ALGORITHM;\\r\\ncurve_nid = EC_GROUP_get_curve_name(grp);\\r\\nif (curve_nid == NID_secp384r1) {\\r\\nif (sign_nid != -1 && sign_nid != NID_ecdsa_with_SHA384)\\r\\nreturn X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM;\\r\\nif (!(*pflags & X509_V_FLAG_SUITEB_192_LOS))\\r\\nreturn X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED;\\r\\n*pflags &= ~X509_V_FLAG_SUITEB_128_LOS_ONLY;\\r\\n} else if (curve_nid == NID_X9_62_prime256v1) {\\r\\nif (sign_nid != -1 && sign_nid != NID_ecdsa_with_SHA256)\\r\\nreturn X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM;\\r\\nif (!(*pflags & X509_V_FLAG_SUITEB_128_LOS_ONLY))\\r\\nreturn X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED;\\r\\n} else\\r\\nreturn X509_V_ERR_SUITE_B_INVALID_CURVE;\\r\\nreturn X509_V_OK;\\r\\n}\\r\\nint X509_CRL_check_suiteb(X509_CRL *crl, EVP_PKEY *pk, unsigned long flags)\\r\\n{\\r\\nint sign_nid;\\r\\nif (!(flags & X509_V_FLAG_SUITEB_128_LOS))\\r\\nreturn X509_V_OK;\\r\\nsign_nid = OBJ_obj2nid(crl->crl->sig_alg->algorithm);\\r\\nreturn check_suite_b(pk, sign_nid, &flags);\\r\\n}\\r\\nint X509_CRL_check_suiteb(X509_CRL *crl, EVP_PKEY *pk, unsigned long flags)\\r\\n{\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_verify_c", "target": 0, "func": "int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *a, ASN1_BIT_STRING *signature,\\r\\nchar *data, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nconst EVP_MD *type;\\r\\nunsigned char *p, *buf_in = NULL;\\r\\nint ret = -1, i, inl;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\ni = OBJ_obj2nid(a->algorithm);\\r\\ntype = EVP_get_digestbyname(OBJ_nid2sn(i));\\r\\nif (type == NULL) {\\r\\nASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7) {\\r\\nASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\\r\\ngoto err;\\r\\n}\\r\\ninl = i2d(data, NULL);\\r\\nbuf_in = OPENSSL_malloc((unsigned int)inl);\\r\\nif (buf_in == NULL) {\\r\\nASN1err(ASN1_F_ASN1_VERIFY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np = buf_in;\\r\\ni2d(data, &p);\\r\\nif (!EVP_VerifyInit_ex(&ctx, type, NULL)\\r\\n|| !EVP_VerifyUpdate(&ctx, (unsigned char *)buf_in, inl)) {\\r\\nASN1err(ASN1_F_ASN1_VERIFY, ERR_R_EVP_LIB);\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nOPENSSL_cleanse(buf_in, (unsigned int)inl);\\r\\nOPENSSL_free(buf_in);\\r\\nif (EVP_VerifyFinal(&ctx, (unsigned char *)signature->data,\\r\\n(unsigned int)signature->length, pkey) <= 0) {\\r\\nASN1err(ASN1_F_ASN1_VERIFY, ERR_R_EVP_LIB);\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nint ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,\\r\\nASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char *buf_in = NULL;\\r\\nint ret = -1, inl;\\r\\nint mdnid, pknid;\\r\\nif (!pkey) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn -1;\\r\\n}\\r\\nif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);\\r\\nreturn -1;\\r\\n}\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nif (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid)) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nif (mdnid == NID_undef) {\\r\\nif (!pkey->ameth || !pkey->ameth->item_verify) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,\\r\\nASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nret = pkey->ameth->item_verify(&ctx, it, asn, a, signature, pkey);\\r\\nif (ret != 2)\\r\\ngoto err;\\r\\nret = -1;\\r\\n} else {\\r\\nconst EVP_MD *type;\\r\\ntype = EVP_get_digestbynid(mdnid);\\r\\nif (type == NULL) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY,\\r\\nASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_WRONG_PUBLIC_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey)) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_EVP_LIB);\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ninl = ASN1_item_i2d(asn, &buf_in, it);\\r\\nif (buf_in == NULL) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DigestVerifyUpdate(&ctx, buf_in, inl)) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_EVP_LIB);\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nOPENSSL_cleanse(buf_in, (unsigned int)inl);\\r\\nOPENSSL_free(buf_in);\\r\\nif (EVP_DigestVerifyFinal(&ctx, signature->data,\\r\\n(size_t)signature->length) <= 0) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_EVP_LIB);\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tasn_dec_c", "target": 1, "func": "unsigned long ASN1_tag2bit(int tag)\\r\\n{\\r\\nif ((tag < 0) || (tag > 30))\\r\\nreturn 0;\\r\\nreturn tag2bit[tag];\\r\\n}\\r\\nASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **pval,\\r\\nconst unsigned char **in, long len,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nASN1_TLC c;\\r\\nASN1_VALUE *ptmpval = NULL;\\r\\nif (!pval)\\r\\npval = &ptmpval;\\r\\nasn1_tlc_clear_nc(&c);\\r\\nif (ASN1_item_ex_d2i(pval, in, len, it, -1, 0, 0, &c) > 0)\\r\\nreturn *pval;\\r\\nreturn NULL;\\r\\n}\\r\\nint ASN1_template_d2i(ASN1_VALUE **pval,\\r\\nconst unsigned char **in, long len,\\r\\nconst ASN1_TEMPLATE *tt)\\r\\n{\\r\\nASN1_TLC c;\\r\\nasn1_tlc_clear_nc(&c);\\r\\nreturn asn1_template_ex_d2i(pval, in, len, tt, 0, &c);\\r\\n}\\r\\nint ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,\\r\\nconst ASN1_ITEM *it,\\r\\nint tag, int aclass, char opt, ASN1_TLC *ctx)\\r\\n{\\r\\nconst ASN1_TEMPLATE *tt, *errtt = NULL;\\r\\nconst ASN1_COMPAT_FUNCS *cf;\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_aux_cb *asn1_cb;\\r\\nconst unsigned char *p = NULL, *q;\\r\\nunsigned char *wp = NULL;\\r\\nunsigned char imphack = 0, oclass;\\r\\nchar seq_eoc, seq_nolen, cst, isopt;\\r\\nlong tmplen;\\r\\nint i;\\r\\nint otag;\\r\\nint ret = 0;\\r\\nASN1_VALUE **pchptr, *ptmpval;\\r\\nif (!pval)\\r\\nreturn 0;\\r\\nif (aux && aux->asn1_cb)\\r\\nasn1_cb = aux->asn1_cb;\\r\\nelse\\r\\nasn1_cb = 0;\\r\\nswitch (it->itype) {\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates) {\\r\\nif ((tag != -1) || opt) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I,\\r\\nASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);\\r\\ngoto err;\\r\\n}\\r\\nreturn asn1_template_ex_d2i(pval, in, len,\\r\\nit->templates, opt, ctx);\\r\\n}\\r\\nreturn asn1_d2i_ex_primitive(pval, in, len, it,\\r\\ntag, aclass, opt, ctx);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\np = *in;\\r\\nret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,\\r\\n&p, len, -1, 0, 1, ctx);\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (oclass != V_ASN1_UNIVERSAL) {\\r\\nif (opt)\\r\\nreturn -1;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);\\r\\ngoto err;\\r\\n}\\r\\nif (!(ASN1_tag2bit(otag) & it->utype)) {\\r\\nif (opt)\\r\\nreturn -1;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);\\r\\ngoto err;\\r\\n}\\r\\nreturn asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nreturn ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncf = it->funcs;\\r\\nif (opt) {\\r\\nint exptag;\\r\\np = *in;\\r\\nif (tag == -1)\\r\\nexptag = it->utype;\\r\\nelse\\r\\nexptag = tag;\\r\\nret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,\\r\\n&p, len, exptag, aclass, 1, ctx);\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (ret == -1)\\r\\nreturn -1;\\r\\n}\\r\\nif (tag != -1) {\\r\\nwp = *(unsigned char **)in;\\r\\nimphack = *wp;\\r\\nif (p == NULL) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n*wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)\\r\\n| it->utype);\\r\\n}\\r\\nptmpval = cf->asn1_d2i(pval, in, len);\\r\\nif (tag != -1)\\r\\n*wp = imphack;\\r\\nif (ptmpval)\\r\\nreturn 1;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\\r\\ngoto auxerr;\\r\\nif (!*pval && !ASN1_item_ex_new(pval, it)) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\np = *in;\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\\r\\npchptr = asn1_get_field_ptr(pval, tt);\\r\\nret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);\\r\\nif (ret == -1)\\r\\ncontinue;\\r\\nif (ret > 0)\\r\\nbreak;\\r\\nerrtt = tt;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (i == it->tcount) {\\r\\nif (opt) {\\r\\nASN1_item_ex_free(pval, it);\\r\\nreturn -1;\\r\\n}\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nasn1_set_choice_selector(pval, i, it);\\r\\n*in = p;\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\\r\\ngoto auxerr;\\r\\nreturn 1;\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\np = *in;\\r\\ntmplen = len;\\r\\nif (tag == -1) {\\r\\ntag = V_ASN1_SEQUENCE;\\r\\naclass = V_ASN1_UNIVERSAL;\\r\\n}\\r\\nret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,\\r\\n&p, len, tag, aclass, opt, ctx);\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n} else if (ret == -1)\\r\\nreturn -1;\\r\\nif (aux && (aux->flags & ASN1_AFLG_BROKEN)) {\\r\\nlen = tmplen - (p - *in);\\r\\nseq_nolen = 1;\\r\\n}\\r\\nelse\\r\\nseq_nolen = seq_eoc;\\r\\nif (!cst) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);\\r\\ngoto err;\\r\\n}\\r\\nif (!*pval && !ASN1_item_ex_new(pval, it)) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))\\r\\ngoto auxerr;\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\\r\\nconst ASN1_TEMPLATE *seqtt;\\r\\nASN1_VALUE **pseqval;\\r\\nseqtt = asn1_do_adb(pval, tt, 1);\\r\\nif (!seqtt)\\r\\ngoto err;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nif (!len)\\r\\nbreak;\\r\\nq = p;\\r\\nif (asn1_check_eoc(&p, len)) {\\r\\nif (!seq_eoc) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);\\r\\ngoto err;\\r\\n}\\r\\nlen -= p - q;\\r\\nseq_eoc = 0;\\r\\nq = p;\\r\\nbreak;\\r\\n}\\r\\nif (i == (it->tcount - 1))\\r\\nisopt = 0;\\r\\nelse\\r\\nisopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);\\r\\nret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);\\r\\nif (!ret) {\\r\\nerrtt = seqtt;\\r\\ngoto err;\\r\\n} else if (ret == -1) {\\r\\nASN1_template_free(pseqval, seqtt);\\r\\ncontinue;\\r\\n}\\r\\nlen -= p - q;\\r\\n}\\r\\nif (seq_eoc && !asn1_check_eoc(&p, len)) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);\\r\\ngoto err;\\r\\n}\\r\\nif (!seq_nolen && len) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nfor (; i < it->tcount; tt++, i++) {\\r\\nconst ASN1_TEMPLATE *seqtt;\\r\\nseqtt = asn1_do_adb(pval, tt, 1);\\r\\nif (!seqtt)\\r\\ngoto err;\\r\\nif (seqtt->flags & ASN1_TFLG_OPTIONAL) {\\r\\nASN1_VALUE **pseqval;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nASN1_template_free(pseqval, seqtt);\\r\\n} else {\\r\\nerrtt = seqtt;\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!asn1_enc_save(pval, *in, p - *in, it))\\r\\ngoto auxerr;\\r\\n*in = p;\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))\\r\\ngoto auxerr;\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nauxerr:\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);\\r\\nerr:\\r\\nASN1_item_ex_free(pval, it);\\r\\nif (errtt)\\r\\nERR_add_error_data(4, \"Field=\", errtt->field_name,\\r\\n\", Type=\", it->sname);\\r\\nelse\\r\\nERR_add_error_data(2, \"Type=\", it->sname);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int asn1_template_ex_d2i(ASN1_VALUE **val,\\r\\nconst unsigned char **in, long inlen,\\r\\nconst ASN1_TEMPLATE *tt, char opt,\\r\\nASN1_TLC *ctx)\\r\\n{\\r\\nint flags, aclass;\\r\\nint ret;\\r\\nlong len;\\r\\nconst unsigned char *p, *q;\\r\\nchar exp_eoc;\\r\\nif (!val)\\r\\nreturn 0;\\r\\nflags = tt->flags;\\r\\naclass = flags & ASN1_TFLG_TAG_CLASS;\\r\\np = *in;\\r\\nif (flags & ASN1_TFLG_EXPTAG) {\\r\\nchar cst;\\r\\nret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst,\\r\\n&p, inlen, tt->tag, aclass, opt, ctx);\\r\\nq = p;\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n} else if (ret == -1)\\r\\nreturn -1;\\r\\nif (!cst) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\\r\\nASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);\\r\\nreturn 0;\\r\\n}\\r\\nret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx);\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nlen -= p - q;\\r\\nif (exp_eoc) {\\r\\nif (!asn1_check_eoc(&p, len)) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ASN1_R_MISSING_EOC);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nif (len) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,\\r\\nASN1_R_EXPLICIT_LENGTH_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n} else\\r\\nreturn asn1_template_noexp_d2i(val, in, inlen, tt, opt, ctx);\\r\\n*in = p;\\r\\nreturn 1;\\r\\nerr:\\r\\nASN1_template_free(val, tt);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int asn1_template_noexp_d2i(ASN1_VALUE **val,\\r\\nconst unsigned char **in, long len,\\r\\nconst ASN1_TEMPLATE *tt, char opt,\\r\\nASN1_TLC *ctx)\\r\\n{\\r\\nint flags, aclass;\\r\\nint ret;\\r\\nconst unsigned char *p, *q;\\r\\nif (!val)\\r\\nreturn 0;\\r\\nflags = tt->flags;\\r\\naclass = flags & ASN1_TFLG_TAG_CLASS;\\r\\np = *in;\\r\\nq = p;\\r\\nif (flags & ASN1_TFLG_SK_MASK) {\\r\\nint sktag, skaclass;\\r\\nchar sk_eoc;\\r\\nif (flags & ASN1_TFLG_IMPTAG) {\\r\\nsktag = tt->tag;\\r\\nskaclass = aclass;\\r\\n} else {\\r\\nskaclass = V_ASN1_UNIVERSAL;\\r\\nif (flags & ASN1_TFLG_SET_OF)\\r\\nsktag = V_ASN1_SET;\\r\\nelse\\r\\nsktag = V_ASN1_SEQUENCE;\\r\\n}\\r\\nret = asn1_check_tlen(&len, NULL, NULL, &sk_eoc, NULL,\\r\\n&p, len, sktag, skaclass, opt, ctx);\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n} else if (ret == -1)\\r\\nreturn -1;\\r\\nif (!*val)\\r\\n*val = (ASN1_VALUE *)sk_new_null();\\r\\nelse {\\r\\nSTACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val;\\r\\nASN1_VALUE *vtmp;\\r\\nwhile (sk_ASN1_VALUE_num(sktmp) > 0) {\\r\\nvtmp = sk_ASN1_VALUE_pop(sktmp);\\r\\nASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));\\r\\n}\\r\\n}\\r\\nif (!*val) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nwhile (len > 0) {\\r\\nASN1_VALUE *skfield;\\r\\nq = p;\\r\\nif (asn1_check_eoc(&p, len)) {\\r\\nif (!sk_eoc) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,\\r\\nASN1_R_UNEXPECTED_EOC);\\r\\ngoto err;\\r\\n}\\r\\nlen -= p - q;\\r\\nsk_eoc = 0;\\r\\nbreak;\\r\\n}\\r\\nskfield = NULL;\\r\\nif (!ASN1_item_ex_d2i(&skfield, &p, len,\\r\\nASN1_ITEM_ptr(tt->item), -1, 0, 0, ctx)) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,\\r\\nERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nlen -= p - q;\\r\\nif (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (sk_eoc) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ASN1_R_MISSING_EOC);\\r\\ngoto err;\\r\\n}\\r\\n} else if (flags & ASN1_TFLG_IMPTAG) {\\r\\nret = ASN1_item_ex_d2i(val, &p, len,\\r\\nASN1_ITEM_ptr(tt->item), tt->tag, aclass, opt,\\r\\nctx);\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n} else if (ret == -1)\\r\\nreturn -1;\\r\\n} else {\\r\\nret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item),\\r\\n-1, 0, opt, ctx);\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n} else if (ret == -1)\\r\\nreturn -1;\\r\\n}\\r\\n*in = p;\\r\\nreturn 1;\\r\\nerr:\\r\\nASN1_template_free(val, tt);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\\r\\nconst unsigned char **in, long inlen,\\r\\nconst ASN1_ITEM *it,\\r\\nint tag, int aclass, char opt, ASN1_TLC *ctx)\\r\\n{\\r\\nint ret = 0, utype;\\r\\nlong plen;\\r\\nchar cst, inf, free_cont = 0;\\r\\nconst unsigned char *p;\\r\\nBUF_MEM buf;\\r\\nconst unsigned char *cont = NULL;\\r\\nlong len;\\r\\nif (!pval) {\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_NULL);\\r\\nreturn 0;\\r\\n}\\r\\nif (it->itype == ASN1_ITYPE_MSTRING) {\\r\\nutype = tag;\\r\\ntag = -1;\\r\\n} else\\r\\nutype = it->utype;\\r\\nif (utype == V_ASN1_ANY) {\\r\\nunsigned char oclass;\\r\\nif (tag >= 0) {\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_TAGGED_ANY);\\r\\nreturn 0;\\r\\n}\\r\\nif (opt) {\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,\\r\\nASN1_R_ILLEGAL_OPTIONAL_ANY);\\r\\nreturn 0;\\r\\n}\\r\\np = *in;\\r\\nret = asn1_check_tlen(NULL, &utype, &oclass, NULL, NULL,\\r\\n&p, inlen, -1, 0, 0, ctx);\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (oclass != V_ASN1_UNIVERSAL)\\r\\nutype = V_ASN1_OTHER;\\r\\n}\\r\\nif (tag == -1) {\\r\\ntag = utype;\\r\\naclass = V_ASN1_UNIVERSAL;\\r\\n}\\r\\np = *in;\\r\\nret = asn1_check_tlen(&plen, NULL, NULL, &inf, &cst,\\r\\n&p, inlen, tag, aclass, opt, ctx);\\r\\nif (!ret) {\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n} else if (ret == -1)\\r\\nreturn -1;\\r\\nret = 0;\\r\\nif ((utype == V_ASN1_SEQUENCE)\\r\\n|| (utype == V_ASN1_SET) || (utype == V_ASN1_OTHER)) {\\r\\nif (utype == V_ASN1_OTHER) {\\r\\nasn1_tlc_clear(ctx);\\r\\n}\\r\\nelse if (!cst) {\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,\\r\\nASN1_R_TYPE_NOT_CONSTRUCTED);\\r\\nreturn 0;\\r\\n}\\r\\ncont = *in;\\r\\nif (inf) {\\r\\nif (!asn1_find_end(&p, plen, inf))\\r\\ngoto err;\\r\\nlen = p - cont;\\r\\n} else {\\r\\nlen = p - cont + plen;\\r\\np += plen;\\r\\nbuf.data = NULL;\\r\\n}\\r\\n} else if (cst) {\\r\\nif (utype == V_ASN1_NULL || utype == V_ASN1_BOOLEAN\\r\\n|| utype == V_ASN1_OBJECT || utype == V_ASN1_INTEGER\\r\\n|| utype == V_ASN1_ENUMERATED) {\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_TYPE_NOT_PRIMITIVE);\\r\\nreturn 0;\\r\\n}\\r\\nbuf.length = 0;\\r\\nbuf.max = 0;\\r\\nbuf.data = NULL;\\r\\nif (!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL, 0)) {\\r\\nfree_cont = 1;\\r\\ngoto err;\\r\\n}\\r\\nlen = buf.length;\\r\\nif (!BUF_MEM_grow_clean(&buf, len + 1)) {\\r\\nASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nbuf.data[len] = 0;\\r\\ncont = (const unsigned char *)buf.data;\\r\\nfree_cont = 1;\\r\\n} else {\\r\\ncont = p;\\r\\nlen = plen;\\r\\np += plen;\\r\\n}\\r\\nif (!asn1_ex_c2i(pval, cont, len, utype, &free_cont, it))\\r\\ngoto err;\\r\\n*in = p;\\r\\nret = 1;\\r\\nerr:\\r\\nif (free_cont && buf.data)\\r\\nOPENSSL_free(buf.data);\\r\\nreturn ret;\\r\\n}\\r\\nint asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,\\r\\nint utype, char *free_cont, const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_VALUE **opval = NULL;\\r\\nASN1_STRING *stmp;\\r\\nASN1_TYPE *typ = NULL;\\r\\nint ret = 0;\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf;\\r\\nASN1_INTEGER **tint;\\r\\npf = it->funcs;\\r\\nif (pf && pf->prim_c2i)\\r\\nreturn pf->prim_c2i(pval, cont, len, utype, free_cont, it);\\r\\nif (it->utype == V_ASN1_ANY) {\\r\\nif (!*pval) {\\r\\ntyp = ASN1_TYPE_new();\\r\\nif (typ == NULL)\\r\\ngoto err;\\r\\n*pval = (ASN1_VALUE *)typ;\\r\\n} else\\r\\ntyp = (ASN1_TYPE *)*pval;\\r\\nif (utype != typ->type)\\r\\nASN1_TYPE_set(typ, utype, NULL);\\r\\nopval = pval;\\r\\npval = &typ->value.asn1_value;\\r\\n}\\r\\nswitch (utype) {\\r\\ncase V_ASN1_OBJECT:\\r\\nif (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len))\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_NULL:\\r\\nif (len) {\\r\\nASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_NULL_IS_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\n*pval = (ASN1_VALUE *)1;\\r\\nbreak;\\r\\ncase V_ASN1_BOOLEAN:\\r\\nif (len != 1) {\\r\\nASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);\\r\\ngoto err;\\r\\n} else {\\r\\nASN1_BOOLEAN *tbool;\\r\\ntbool = (ASN1_BOOLEAN *)pval;\\r\\n*tbool = *cont;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_BIT_STRING:\\r\\nif (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len))\\r\\ngoto err;\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_NEG_INTEGER:\\r\\ncase V_ASN1_ENUMERATED:\\r\\ncase V_ASN1_NEG_ENUMERATED:\\r\\ntint = (ASN1_INTEGER **)pval;\\r\\nif (!c2i_ASN1_INTEGER(tint, &cont, len))\\r\\ngoto err;\\r\\n(*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);\\r\\nbreak;\\r\\ncase V_ASN1_OCTET_STRING:\\r\\ncase V_ASN1_NUMERICSTRING:\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\ncase V_ASN1_T61STRING:\\r\\ncase V_ASN1_VIDEOTEXSTRING:\\r\\ncase V_ASN1_IA5STRING:\\r\\ncase V_ASN1_UTCTIME:\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\ncase V_ASN1_GRAPHICSTRING:\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\ncase V_ASN1_GENERALSTRING:\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\ncase V_ASN1_BMPSTRING:\\r\\ncase V_ASN1_UTF8STRING:\\r\\ncase V_ASN1_OTHER:\\r\\ncase V_ASN1_SET:\\r\\ncase V_ASN1_SEQUENCE:\\r\\ndefault:\\r\\nif (utype == V_ASN1_BMPSTRING && (len & 1)) {\\r\\nASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nif (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {\\r\\nASN1err(ASN1_F_ASN1_EX_C2I,\\r\\nASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nif (!*pval) {\\r\\nstmp = ASN1_STRING_type_new(utype);\\r\\nif (!stmp) {\\r\\nASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n*pval = (ASN1_VALUE *)stmp;\\r\\n} else {\\r\\nstmp = (ASN1_STRING *)*pval;\\r\\nstmp->type = utype;\\r\\n}\\r\\nif (*free_cont) {\\r\\nif (stmp->data)\\r\\nOPENSSL_free(stmp->data);\\r\\nstmp->data = (unsigned char *)cont;\\r\\nstmp->length = len;\\r\\n*free_cont = 0;\\r\\n} else {\\r\\nif (!ASN1_STRING_set(stmp, cont, len)) {\\r\\nASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE);\\r\\nASN1_STRING_free(stmp);\\r\\n*pval = NULL;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nif (typ && (utype == V_ASN1_NULL))\\r\\ntyp->value.ptr = NULL;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret) {\\r\\nASN1_TYPE_free(typ);\\r\\nif (opval)\\r\\n*opval = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int asn1_find_end(const unsigned char **in, long len, char inf)\\r\\n{\\r\\nint expected_eoc;\\r\\nlong plen;\\r\\nconst unsigned char *p = *in, *q;\\r\\nif (inf == 0) {\\r\\n*in += len;\\r\\nreturn 1;\\r\\n}\\r\\nexpected_eoc = 1;\\r\\nwhile (len > 0) {\\r\\nif (asn1_check_eoc(&p, len)) {\\r\\nexpected_eoc--;\\r\\nif (expected_eoc == 0)\\r\\nbreak;\\r\\nlen -= 2;\\r\\ncontinue;\\r\\n}\\r\\nq = p;\\r\\nif (!asn1_check_tlen(&plen, NULL, NULL, &inf, NULL, &p, len,\\r\\n-1, 0, 0, NULL)) {\\r\\nASN1err(ASN1_F_ASN1_FIND_END, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (inf)\\r\\nexpected_eoc++;\\r\\nelse\\r\\np += plen;\\r\\nlen -= p - q;\\r\\n}\\r\\nif (expected_eoc) {\\r\\nASN1err(ASN1_F_ASN1_FIND_END, ASN1_R_MISSING_EOC);\\r\\nreturn 0;\\r\\n}\\r\\n*in = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_collect(BUF_MEM *buf, const unsigned char **in, long len,\\r\\nchar inf, int tag, int aclass, int depth)\\r\\n{\\r\\nconst unsigned char *p, *q;\\r\\nlong plen;\\r\\nchar cst, ininf;\\r\\np = *in;\\r\\ninf &= 1;\\r\\nif (!buf && !inf) {\\r\\n*in += len;\\r\\nreturn 1;\\r\\n}\\r\\nwhile (len > 0) {\\r\\nq = p;\\r\\nif (asn1_check_eoc(&p, len)) {\\r\\nif (!inf) {\\r\\nASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_UNEXPECTED_EOC);\\r\\nreturn 0;\\r\\n}\\r\\ninf = 0;\\r\\nbreak;\\r\\n}\\r\\nif (!asn1_check_tlen(&plen, NULL, NULL, &ininf, &cst, &p,\\r\\nlen, tag, aclass, 0, NULL)) {\\r\\nASN1err(ASN1_F_ASN1_COLLECT, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (cst) {\\r\\nif (depth >= ASN1_MAX_STRING_NEST) {\\r\\nASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_NESTED_ASN1_STRING);\\r\\nreturn 0;\\r\\n}\\r\\nif (!asn1_collect(buf, &p, plen, ininf, tag, aclass, depth + 1))\\r\\nreturn 0;\\r\\n} else if (plen && !collect_data(buf, &p, plen))\\r\\nreturn 0;\\r\\nlen -= p - q;\\r\\n}\\r\\nif (inf) {\\r\\nASN1err(ASN1_F_ASN1_COLLECT, ASN1_R_MISSING_EOC);\\r\\nreturn 0;\\r\\n}\\r\\n*in = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int collect_data(BUF_MEM *buf, const unsigned char **p, long plen)\\r\\n{\\r\\nint len;\\r\\nif (buf) {\\r\\nlen = buf->length;\\r\\nif (!BUF_MEM_grow_clean(buf, len + plen)) {\\r\\nASN1err(ASN1_F_COLLECT_DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(buf->data + len, *p, plen);\\r\\n}\\r\\n*p += plen;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_check_eoc(const unsigned char **in, long len)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nif (len < 2)\\r\\nreturn 0;\\r\\np = *in;\\r\\nif (!p[0] && !p[1]) {\\r\\n*in += 2;\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int asn1_check_tlen(long *olen, int *otag, unsigned char *oclass,\\r\\nchar *inf, char *cst,\\r\\nconst unsigned char **in, long len,\\r\\nint exptag, int expclass, char opt, ASN1_TLC *ctx)\\r\\n{\\r\\nint i;\\r\\nint ptag, pclass;\\r\\nlong plen;\\r\\nconst unsigned char *p, *q;\\r\\np = *in;\\r\\nq = p;\\r\\nif (ctx && ctx->valid) {\\r\\ni = ctx->ret;\\r\\nplen = ctx->plen;\\r\\npclass = ctx->pclass;\\r\\nptag = ctx->ptag;\\r\\np += ctx->hdrlen;\\r\\n} else {\\r\\ni = ASN1_get_object(&p, &plen, &ptag, &pclass, len);\\r\\nif (ctx) {\\r\\nctx->ret = i;\\r\\nctx->plen = plen;\\r\\nctx->pclass = pclass;\\r\\nctx->ptag = ptag;\\r\\nctx->hdrlen = p - q;\\r\\nctx->valid = 1;\\r\\nif (!(i & 0x81) && ((plen + ctx->hdrlen) > len)) {\\r\\nASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_TOO_LONG);\\r\\nasn1_tlc_clear(ctx);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (i & 0x80) {\\r\\nASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_BAD_OBJECT_HEADER);\\r\\nasn1_tlc_clear(ctx);\\r\\nreturn 0;\\r\\n}\\r\\nif (exptag >= 0) {\\r\\nif ((exptag != ptag) || (expclass != pclass)) {\\r\\nif (opt)\\r\\nreturn -1;\\r\\nasn1_tlc_clear(ctx);\\r\\nASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_WRONG_TAG);\\r\\nreturn 0;\\r\\n}\\r\\nasn1_tlc_clear(ctx);\\r\\n}\\r\\nif (i & 1)\\r\\nplen = len - (p - q);\\r\\nif (inf)\\r\\n*inf = i & 1;\\r\\nif (cst)\\r\\n*cst = i & V_ASN1_CONSTRUCTED;\\r\\nif (olen)\\r\\n*olen = plen;\\r\\nif (oclass)\\r\\n*oclass = pclass;\\r\\nif (otag)\\r\\n*otag = ptag;\\r\\n*in = p;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cmll_cfb_c", "target": 0, "func": "void Camellia_cfb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const CAMELLIA_KEY *key,\\r\\nunsigned char *ivec, int *num, const int enc)\\r\\n{\\r\\nCRYPTO_cfb128_encrypt(in, out, length, key, ivec, num, enc,\\r\\n(block128_f) Camellia_encrypt);\\r\\n}\\r\\nvoid Camellia_cfb1_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const CAMELLIA_KEY *key,\\r\\nunsigned char *ivec, int *num, const int enc)\\r\\n{\\r\\nCRYPTO_cfb128_1_encrypt(in, out, length, key, ivec, num, enc,\\r\\n(block128_f) Camellia_encrypt);\\r\\n}\\r\\nvoid Camellia_cfb8_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const CAMELLIA_KEY *key,\\r\\nunsigned char *ivec, int *num, const int enc)\\r\\n{\\r\\nCRYPTO_cfb128_8_encrypt(in, out, length, key, ivec, num, enc,\\r\\n(block128_f) Camellia_encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pkcs12_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nchar *infile = NULL, *outfile = NULL, *keyname = NULL;\\r\\nchar *certfile = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nchar **args;\\r\\nchar *name = NULL;\\r\\nchar *csp_name = NULL;\\r\\nint add_lmk = 0;\\r\\nPKCS12 *p12 = NULL;\\r\\nchar pass[50], macpass[50];\\r\\nint export_cert = 0;\\r\\nint options = 0;\\r\\nint chain = 0;\\r\\nint badarg = 0;\\r\\nint iter = PKCS12_DEFAULT_ITER;\\r\\nint maciter = PKCS12_DEFAULT_ITER;\\r\\nint twopass = 0;\\r\\nint keytype = 0;\\r\\nint cert_pbe;\\r\\nint key_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;\\r\\nint ret = 1;\\r\\nint macver = 1;\\r\\nint noprompt = 0;\\r\\nSTACK_OF(OPENSSL_STRING) *canames = NULL;\\r\\nchar *cpass = NULL, *mpass = NULL;\\r\\nchar *passargin = NULL, *passargout = NULL, *passarg = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\nchar *inrand = NULL;\\r\\nchar *macalg = NULL;\\r\\nchar *CApath = NULL, *CAfile = NULL;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n# endif\\r\\napps_startup();\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\ncert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;\\r\\nelse\\r\\n# endif\\r\\ncert_pbe = NID_pbe_WithSHA1And40BitRC2_CBC;\\r\\nenc = EVP_des_ede3_cbc();\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nargs = argv + 1;\\r\\nwhile (*args) {\\r\\nif (*args[0] == '-') {\\r\\nif (!strcmp(*args, \"-nokeys\"))\\r\\noptions |= NOKEYS;\\r\\nelse if (!strcmp(*args, \"-keyex\"))\\r\\nkeytype = KEY_EX;\\r\\nelse if (!strcmp(*args, \"-keysig\"))\\r\\nkeytype = KEY_SIG;\\r\\nelse if (!strcmp(*args, \"-nocerts\"))\\r\\noptions |= NOCERTS;\\r\\nelse if (!strcmp(*args, \"-clcerts\"))\\r\\noptions |= CLCERTS;\\r\\nelse if (!strcmp(*args, \"-cacerts\"))\\r\\noptions |= CACERTS;\\r\\nelse if (!strcmp(*args, \"-noout\"))\\r\\noptions |= (NOKEYS | NOCERTS);\\r\\nelse if (!strcmp(*args, \"-info\"))\\r\\noptions |= INFO;\\r\\nelse if (!strcmp(*args, \"-chain\"))\\r\\nchain = 1;\\r\\nelse if (!strcmp(*args, \"-twopass\"))\\r\\ntwopass = 1;\\r\\nelse if (!strcmp(*args, \"-nomacver\"))\\r\\nmacver = 0;\\r\\nelse if (!strcmp(*args, \"-descert\"))\\r\\ncert_pbe = NID_pbe_WithSHA1And3_Key_TripleDES_CBC;\\r\\nelse if (!strcmp(*args, \"-export\"))\\r\\nexport_cert = 1;\\r\\nelse if (!strcmp(*args, \"-des\"))\\r\\nenc = EVP_des_cbc();\\r\\nelse if (!strcmp(*args, \"-des3\"))\\r\\nenc = EVP_des_ede3_cbc();\\r\\n# ifndef OPENSSL_NO_IDEA\\r\\nelse if (!strcmp(*args, \"-idea\"))\\r\\nenc = EVP_idea_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nelse if (!strcmp(*args, \"-seed\"))\\r\\nenc = EVP_seed_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nelse if (!strcmp(*args, \"-aes128\"))\\r\\nenc = EVP_aes_128_cbc();\\r\\nelse if (!strcmp(*args, \"-aes192\"))\\r\\nenc = EVP_aes_192_cbc();\\r\\nelse if (!strcmp(*args, \"-aes256\"))\\r\\nenc = EVP_aes_256_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nelse if (!strcmp(*args, \"-camellia128\"))\\r\\nenc = EVP_camellia_128_cbc();\\r\\nelse if (!strcmp(*args, \"-camellia192\"))\\r\\nenc = EVP_camellia_192_cbc();\\r\\nelse if (!strcmp(*args, \"-camellia256\"))\\r\\nenc = EVP_camellia_256_cbc();\\r\\n# endif\\r\\nelse if (!strcmp(*args, \"-noiter\"))\\r\\niter = 1;\\r\\nelse if (!strcmp(*args, \"-maciter\"))\\r\\nmaciter = PKCS12_DEFAULT_ITER;\\r\\nelse if (!strcmp(*args, \"-nomaciter\"))\\r\\nmaciter = 1;\\r\\nelse if (!strcmp(*args, \"-nomac\"))\\r\\nmaciter = -1;\\r\\nelse if (!strcmp(*args, \"-macalg\"))\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nmacalg = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\nelse if (!strcmp(*args, \"-nodes\"))\\r\\nenc = NULL;\\r\\nelse if (!strcmp(*args, \"-certpbe\")) {\\r\\nif (!set_pbe(bio_err, &cert_pbe, *++args))\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-keypbe\")) {\\r\\nif (!set_pbe(bio_err, &key_pbe, *++args))\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-rand\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninrand = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-inkey\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nkeyname = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-certfile\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ncertfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-name\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nname = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-LMK\"))\\r\\nadd_lmk = 1;\\r\\nelse if (!strcmp(*args, \"-CSP\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ncsp_name = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-caname\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nif (!canames)\\r\\ncanames = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(canames, *args);\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-passin\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\npassargin = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-passout\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\npassargout = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-password\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\npassarg = *args;\\r\\nnoprompt = 1;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-CApath\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nCApath = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-CAfile\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nCAfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\n} else if (!strcmp(*args, \"-engine\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nengine = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n# endif\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else\\r\\nbadarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\nBIO_printf(bio_err, \"Usage: pkcs12 [options]\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-export output PKCS12 file\\n\");\\r\\nBIO_printf(bio_err, \"-chain add certificate chain\\n\");\\r\\nBIO_printf(bio_err, \"-inkey file private key if not infile\\n\");\\r\\nBIO_printf(bio_err, \"-certfile f add all certs in f\\n\");\\r\\nBIO_printf(bio_err, \"-CApath arg - PEM format directory of CA's\\n\");\\r\\nBIO_printf(bio_err, \"-CAfile arg - PEM format file of CA's\\n\");\\r\\nBIO_printf(bio_err, \"-name \\\"name\\\" use name as friendly name\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-caname \\\"nm\\\" use nm as CA friendly name (can be used more than once).\\n\");\\r\\nBIO_printf(bio_err, \"-in infile input filename\\n\");\\r\\nBIO_printf(bio_err, \"-out outfile output filename\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-noout don't output anything, just verify.\\n\");\\r\\nBIO_printf(bio_err, \"-nomacver don't verify MAC.\\n\");\\r\\nBIO_printf(bio_err, \"-nocerts don't output certificates.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-clcerts only output client certificates.\\n\");\\r\\nBIO_printf(bio_err, \"-cacerts only output CA certificates.\\n\");\\r\\nBIO_printf(bio_err, \"-nokeys don't output private keys.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-info give info about PKCS#12 structure.\\n\");\\r\\nBIO_printf(bio_err, \"-des encrypt private keys with DES\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-des3 encrypt private keys with triple DES (default)\\n\");\\r\\n# ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf(bio_err, \"-idea encrypt private keys with idea\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nBIO_printf(bio_err, \"-seed encrypt private keys with seed\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err, \"-aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc aes\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nBIO_printf(bio_err, \"-camellia128, -camellia192, -camellia256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc camellia\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \"-nodes don't encrypt private keys\\n\");\\r\\nBIO_printf(bio_err, \"-noiter don't use encryption iteration\\n\");\\r\\nBIO_printf(bio_err, \"-nomaciter don't use MAC iteration\\n\");\\r\\nBIO_printf(bio_err, \"-maciter use MAC iteration\\n\");\\r\\nBIO_printf(bio_err, \"-nomac don't generate MAC\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-twopass separate MAC, encryption passwords\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-descert encrypt PKCS#12 certificates with triple DES (default RC2-40)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-certpbe alg specify certificate PBE algorithm (default RC2-40)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-keypbe alg specify private key PBE algorithm (default 3DES)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-macalg alg digest algorithm used in MAC (default SHA1)\\n\");\\r\\nBIO_printf(bio_err, \"-keyex set MS key exchange type\\n\");\\r\\nBIO_printf(bio_err, \"-keysig set MS key signature type\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-password p set import/export password source\\n\");\\r\\nBIO_printf(bio_err, \"-passin p input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \"-passout p output file pass phrase source\\n\");\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \"-rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\\r\\n\" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\nBIO_printf(bio_err, \"-CSP name Microsoft CSP name\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-LMK Add local machine keyset attribute to private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (passarg) {\\r\\nif (export_cert)\\r\\npassargout = passarg;\\r\\nelse\\r\\npassargin = passarg;\\r\\n}\\r\\nif (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!cpass) {\\r\\nif (export_cert)\\r\\ncpass = passout;\\r\\nelse\\r\\ncpass = passin;\\r\\n}\\r\\nif (cpass) {\\r\\nmpass = cpass;\\r\\nnoprompt = 1;\\r\\n} else {\\r\\ncpass = pass;\\r\\nmpass = macpass;\\r\\n}\\r\\nif (export_cert || inrand) {\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"read files\");\\r\\n# endif\\r\\nif (!infile)\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nelse\\r\\nin = BIO_new_file(infile, \"rb\");\\r\\nif (!in) {\\r\\nBIO_printf(bio_err, \"Error opening input file %s\\n\",\\r\\ninfile ? infile : \"<stdin>\");\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"write files\");\\r\\n# endif\\r\\nif (!outfile) {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n} else\\r\\nout = BIO_new_file(outfile, \"wb\");\\r\\nif (!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file %s\\n\",\\r\\noutfile ? outfile : \"<stdout>\");\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\nif (twopass) {\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"read MAC password\");\\r\\n# endif\\r\\nif (EVP_read_pw_string\\r\\n(macpass, sizeof macpass, \"Enter MAC Password:\", export_cert)) {\\r\\nBIO_printf(bio_err, \"Can't read Password\\n\");\\r\\ngoto end;\\r\\n}\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n# endif\\r\\n}\\r\\nif (export_cert) {\\r\\nEVP_PKEY *key = NULL;\\r\\nX509 *ucert = NULL, *x = NULL;\\r\\nSTACK_OF(X509) *certs = NULL;\\r\\nconst EVP_MD *macmd = NULL;\\r\\nunsigned char *catmp = NULL;\\r\\nint i;\\r\\nif ((options & (NOCERTS | NOKEYS)) == (NOCERTS | NOKEYS)) {\\r\\nBIO_printf(bio_err, \"Nothing to do!\\n\");\\r\\ngoto export_end;\\r\\n}\\r\\nif (options & NOCERTS)\\r\\nchain = 0;\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"process -export_cert\");\\r\\nCRYPTO_push_info(\"reading private key\");\\r\\n# endif\\r\\nif (!(options & NOKEYS)) {\\r\\nkey = load_key(bio_err, keyname ? keyname : infile,\\r\\nFORMAT_PEM, 1, passin, e, \"private key\");\\r\\nif (!key)\\r\\ngoto export_end;\\r\\n}\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"reading certs from input\");\\r\\n# endif\\r\\nif (!(options & NOCERTS)) {\\r\\ncerts = load_certs(bio_err, infile, FORMAT_PEM, NULL, e,\\r\\n\"certificates\");\\r\\nif (!certs)\\r\\ngoto export_end;\\r\\nif (key) {\\r\\nfor (i = 0; i < sk_X509_num(certs); i++) {\\r\\nx = sk_X509_value(certs, i);\\r\\nif (X509_check_private_key(x, key)) {\\r\\nucert = x;\\r\\nX509_keyid_set1(ucert, NULL, 0);\\r\\nX509_alias_set1(ucert, NULL, 0);\\r\\n(void)sk_X509_delete(certs, i);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ucert) {\\r\\nBIO_printf(bio_err,\\r\\n\"No certificate matches private key\\n\");\\r\\ngoto export_end;\\r\\n}\\r\\n}\\r\\n}\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"reading certs from input 2\");\\r\\n# endif\\r\\nif (certfile) {\\r\\nSTACK_OF(X509) *morecerts = NULL;\\r\\nif (!(morecerts = load_certs(bio_err, certfile, FORMAT_PEM,\\r\\nNULL, e,\\r\\n\"certificates from certfile\")))\\r\\ngoto export_end;\\r\\nwhile (sk_X509_num(morecerts) > 0)\\r\\nsk_X509_push(certs, sk_X509_shift(morecerts));\\r\\nsk_X509_free(morecerts);\\r\\n}\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"reading certs from certfile\");\\r\\n# endif\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"building chain\");\\r\\n# endif\\r\\nif (chain) {\\r\\nint vret;\\r\\nSTACK_OF(X509) *chain2;\\r\\nX509_STORE *store = X509_STORE_new();\\r\\nif (!store) {\\r\\nBIO_printf(bio_err, \"Memory allocation error\\n\");\\r\\ngoto export_end;\\r\\n}\\r\\nif (!X509_STORE_load_locations(store, CAfile, CApath))\\r\\nX509_STORE_set_default_paths(store);\\r\\nvret = get_cert_chain(ucert, store, &chain2);\\r\\nX509_STORE_free(store);\\r\\nif (!vret) {\\r\\nfor (i = 1; i < sk_X509_num(chain2); i++)\\r\\nsk_X509_push(certs, sk_X509_value(chain2, i));\\r\\nX509_free(sk_X509_value(chain2, 0));\\r\\nsk_X509_free(chain2);\\r\\n} else {\\r\\nif (vret >= 0)\\r\\nBIO_printf(bio_err, \"Error %s getting chain.\\n\",\\r\\nX509_verify_cert_error_string(vret));\\r\\nelse\\r\\nERR_print_errors(bio_err);\\r\\ngoto export_end;\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < sk_OPENSSL_STRING_num(canames); i++) {\\r\\ncatmp = (unsigned char *)sk_OPENSSL_STRING_value(canames, i);\\r\\nX509_alias_set1(sk_X509_value(certs, i), catmp, -1);\\r\\n}\\r\\nif (csp_name && key)\\r\\nEVP_PKEY_add1_attr_by_NID(key, NID_ms_csp_name,\\r\\nMBSTRING_ASC, (unsigned char *)csp_name,\\r\\n-1);\\r\\nif (add_lmk && key)\\r\\nEVP_PKEY_add1_attr_by_NID(key, NID_LocalKeySet, 0, NULL, -1);\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"reading password\");\\r\\n# endif\\r\\nif (!noprompt &&\\r\\nEVP_read_pw_string(pass, sizeof pass, \"Enter Export Password:\",\\r\\n1)) {\\r\\nBIO_printf(bio_err, \"Can't read Password\\n\");\\r\\ngoto export_end;\\r\\n}\\r\\nif (!twopass)\\r\\nBUF_strlcpy(macpass, pass, sizeof macpass);\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"creating PKCS#12 structure\");\\r\\n# endif\\r\\np12 = PKCS12_create(cpass, name, key, ucert, certs,\\r\\nkey_pbe, cert_pbe, iter, -1, keytype);\\r\\nif (!p12) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto export_end;\\r\\n}\\r\\nif (macalg) {\\r\\nmacmd = EVP_get_digestbyname(macalg);\\r\\nif (!macmd) {\\r\\nBIO_printf(bio_err, \"Unknown digest algorithm %s\\n\", macalg);\\r\\n}\\r\\n}\\r\\nif (maciter != -1)\\r\\nPKCS12_set_mac(p12, mpass, -1, NULL, 0, maciter, macmd);\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"writing pkcs12\");\\r\\n# endif\\r\\ni2d_PKCS12_bio(out, p12);\\r\\nret = 0;\\r\\nexport_end:\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_pop_info();\\r\\nCRYPTO_push_info(\"process -export_cert: freeing\");\\r\\n# endif\\r\\nif (key)\\r\\nEVP_PKEY_free(key);\\r\\nif (certs)\\r\\nsk_X509_pop_free(certs, X509_free);\\r\\nif (ucert)\\r\\nX509_free(ucert);\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n# endif\\r\\ngoto end;\\r\\n}\\r\\nif (!(p12 = d2i_PKCS12_bio(in, NULL))) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"read import password\");\\r\\n# endif\\r\\nif (!noprompt\\r\\n&& EVP_read_pw_string(pass, sizeof pass, \"Enter Import Password:\",\\r\\n0)) {\\r\\nBIO_printf(bio_err, \"Can't read Password\\n\");\\r\\ngoto end;\\r\\n}\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n# endif\\r\\nif (!twopass)\\r\\nBUF_strlcpy(macpass, pass, sizeof macpass);\\r\\nif ((options & INFO) && p12->mac)\\r\\nBIO_printf(bio_err, \"MAC Iteration %ld\\n\",\\r\\np12->mac->iter ? ASN1_INTEGER_get(p12->mac->iter) : 1);\\r\\nif (macver) {\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"verify MAC\");\\r\\n# endif\\r\\nif (!mpass[0] && PKCS12_verify_mac(p12, NULL, 0)) {\\r\\nif (!twopass)\\r\\ncpass = NULL;\\r\\n} else if (!PKCS12_verify_mac(p12, mpass, -1)) {\\r\\nBIO_printf(bio_err, \"Mac verify error: invalid password?\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err, \"MAC verified OK\\n\");\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n# endif\\r\\n}\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_push_info(\"output keys and certificates\");\\r\\n# endif\\r\\nif (!dump_certs_keys_p12(out, p12, cpass, -1, options, passout)) {\\r\\nBIO_printf(bio_err, \"Error outputting keys and certificates\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_pop_info();\\r\\n# endif\\r\\nret = 0;\\r\\nend:\\r\\nif (p12)\\r\\nPKCS12_free(p12);\\r\\nif (export_cert || inrand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\n# ifdef CRYPTO_MDEBUG\\r\\nCRYPTO_remove_all_info();\\r\\n# endif\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nif (canames)\\r\\nsk_OPENSSL_STRING_free(canames);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nint dump_certs_keys_p12(BIO *out, PKCS12 *p12, char *pass,\\r\\nint passlen, int options, char *pempass)\\r\\n{\\r\\nSTACK_OF(PKCS7) *asafes = NULL;\\r\\nSTACK_OF(PKCS12_SAFEBAG) *bags;\\r\\nint i, bagnid;\\r\\nint ret = 0;\\r\\nPKCS7 *p7;\\r\\nif (!(asafes = PKCS12_unpack_authsafes(p12)))\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_PKCS7_num(asafes); i++) {\\r\\np7 = sk_PKCS7_value(asafes, i);\\r\\nbagnid = OBJ_obj2nid(p7->type);\\r\\nif (bagnid == NID_pkcs7_data) {\\r\\nbags = PKCS12_unpack_p7data(p7);\\r\\nif (options & INFO)\\r\\nBIO_printf(bio_err, \"PKCS7 Data\\n\");\\r\\n} else if (bagnid == NID_pkcs7_encrypted) {\\r\\nif (options & INFO) {\\r\\nBIO_printf(bio_err, \"PKCS7 Encrypted data: \");\\r\\nalg_print(bio_err, p7->d.encrypted->enc_data->algorithm);\\r\\n}\\r\\nbags = PKCS12_unpack_p7encdata(p7, pass, passlen);\\r\\n} else\\r\\ncontinue;\\r\\nif (!bags)\\r\\ngoto err;\\r\\nif (!dump_certs_pkeys_bags(out, bags, pass, passlen,\\r\\noptions, pempass)) {\\r\\nsk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\ngoto err;\\r\\n}\\r\\nsk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nbags = NULL;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (asafes)\\r\\nsk_PKCS7_pop_free(asafes, PKCS7_free);\\r\\nreturn ret;\\r\\n}\\r\\nint dump_certs_pkeys_bag(BIO *out, PKCS12_SAFEBAG *bag, char *pass,\\r\\nint passlen, int options, char *pempass)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nX509 *x509;\\r\\nswitch (M_PKCS12_bag_type(bag)) {\\r\\ncase NID_keyBag:\\r\\nif (options & INFO)\\r\\nBIO_printf(bio_err, \"Key bag\\n\");\\r\\nif (options & NOKEYS)\\r\\nreturn 1;\\r\\nprint_attribs(out, bag->attrib, \"Bag Attributes\");\\r\\np8 = bag->value.keybag;\\r\\nif (!(pkey = EVP_PKCS82PKEY(p8)))\\r\\nreturn 0;\\r\\nprint_attribs(out, p8->attributes, \"Key Attributes\");\\r\\nPEM_write_bio_PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);\\r\\nEVP_PKEY_free(pkey);\\r\\nbreak;\\r\\ncase NID_pkcs8ShroudedKeyBag:\\r\\nif (options & INFO) {\\r\\nBIO_printf(bio_err, \"Shrouded Keybag: \");\\r\\nalg_print(bio_err, bag->value.shkeybag->algor);\\r\\n}\\r\\nif (options & NOKEYS)\\r\\nreturn 1;\\r\\nprint_attribs(out, bag->attrib, \"Bag Attributes\");\\r\\nif (!(p8 = PKCS12_decrypt_skey(bag, pass, passlen)))\\r\\nreturn 0;\\r\\nif (!(pkey = EVP_PKCS82PKEY(p8))) {\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nreturn 0;\\r\\n}\\r\\nprint_attribs(out, p8->attributes, \"Key Attributes\");\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nPEM_write_bio_PrivateKey(out, pkey, enc, NULL, 0, NULL, pempass);\\r\\nEVP_PKEY_free(pkey);\\r\\nbreak;\\r\\ncase NID_certBag:\\r\\nif (options & INFO)\\r\\nBIO_printf(bio_err, \"Certificate bag\\n\");\\r\\nif (options & NOCERTS)\\r\\nreturn 1;\\r\\nif (PKCS12_get_attr(bag, NID_localKeyID)) {\\r\\nif (options & CACERTS)\\r\\nreturn 1;\\r\\n} else if (options & CLCERTS)\\r\\nreturn 1;\\r\\nprint_attribs(out, bag->attrib, \"Bag Attributes\");\\r\\nif (M_PKCS12_cert_bag_type(bag) != NID_x509Certificate)\\r\\nreturn 1;\\r\\nif (!(x509 = PKCS12_certbag2x509(bag)))\\r\\nreturn 0;\\r\\ndump_cert_text(out, x509);\\r\\nPEM_write_bio_X509(out, x509);\\r\\nX509_free(x509);\\r\\nbreak;\\r\\ncase NID_safeContentsBag:\\r\\nif (options & INFO)\\r\\nBIO_printf(bio_err, \"Safe Contents bag\\n\");\\r\\nprint_attribs(out, bag->attrib, \"Bag Attributes\");\\r\\nreturn dump_certs_pkeys_bags(out, bag->value.safes, pass,\\r\\npasslen, options, pempass);\\r\\ndefault:\\r\\nBIO_printf(bio_err, \"Warning unsupported bag type: \");\\r\\ni2a_ASN1_OBJECT(bio_err, bag->type);\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\nreturn 1;\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint alg_print(BIO *x, X509_ALGOR *alg)\\r\\n{\\r\\nPBEPARAM *pbe;\\r\\nconst unsigned char *p;\\r\\np = alg->parameter->value.sequence->data;\\r\\npbe = d2i_PBEPARAM(NULL, &p, alg->parameter->value.sequence->length);\\r\\nif (!pbe)\\r\\nreturn 1;\\r\\nBIO_printf(bio_err, \"%s, Iteration %ld\\n\",\\r\\nOBJ_nid2ln(OBJ_obj2nid(alg->algorithm)),\\r\\nASN1_INTEGER_get(pbe->iter));\\r\\nPBEPARAM_free(pbe);\\r\\nreturn 1;\\r\\n}\\r\\nvoid hex_prin(BIO *out, unsigned char *buf, int len)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < len; i++)\\r\\nBIO_printf(out, \"%02X \", buf[i]);\\r\\n}\\r\\nstatic int set_pbe(BIO *err, int *ppbe, const char *str)\\r\\n{\\r\\nif (!str)\\r\\nreturn 0;\\r\\nif (!strcmp(str, \"NONE\")) {\\r\\n*ppbe = -1;\\r\\nreturn 1;\\r\\n}\\r\\n*ppbe = OBJ_txt2nid(str);\\r\\nif (*ppbe == NID_undef) {\\r\\nBIO_printf(bio_err, \"Unknown PBE algorithm %s\\n\", str);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pkcs7_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nPKCS7 *p7 = NULL;\\r\\nint i, badops = 0;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat;\\r\\nchar *infile, *outfile, *prog;\\r\\nint print_certs = 0, text = 0, noout = 0, p7_print = 0;\\r\\nint ret = 1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninfile = NULL;\\r\\noutfile = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv, \"-print\") == 0)\\r\\np7_print = 1;\\r\\nelse if (strcmp(*argv, \"-print_certs\") == 0)\\r\\nprint_certs = 1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile >outfile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -print_certs print any certs or crl in the input\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -text print full details of certificates\\n\");\\r\\nBIO_printf(bio_err, \" -noout don't output encoded data\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0)\\r\\nif (in == NULL) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\np7 = d2i_PKCS7_bio(in, NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\np7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad input format specified for pkcs7 object\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (p7 == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load PKCS7 object\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (p7_print)\\r\\nPKCS7_print_ctx(out, p7, 0, NULL);\\r\\nif (print_certs) {\\r\\nSTACK_OF(X509) *certs = NULL;\\r\\nSTACK_OF(X509_CRL) *crls = NULL;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_signed:\\r\\ncerts = p7->d.sign->cert;\\r\\ncrls = p7->d.sign->crl;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\ncerts = p7->d.signed_and_enveloped->cert;\\r\\ncrls = p7->d.signed_and_enveloped->crl;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nif (certs != NULL) {\\r\\nX509 *x;\\r\\nfor (i = 0; i < sk_X509_num(certs); i++) {\\r\\nx = sk_X509_value(certs, i);\\r\\nif (text)\\r\\nX509_print(out, x);\\r\\nelse\\r\\ndump_cert_text(out, x);\\r\\nif (!noout)\\r\\nPEM_write_bio_X509(out, x);\\r\\nBIO_puts(out, \"\\n\");\\r\\n}\\r\\n}\\r\\nif (crls != NULL) {\\r\\nX509_CRL *crl;\\r\\nfor (i = 0; i < sk_X509_CRL_num(crls); i++) {\\r\\ncrl = sk_X509_CRL_value(crls, i);\\r\\nX509_CRL_print(out, crl);\\r\\nif (!noout)\\r\\nPEM_write_bio_X509_CRL(out, crl);\\r\\nBIO_puts(out, \"\\n\");\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (!noout) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_PKCS7_bio(out, p7);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_PKCS7(out, p7);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write pkcs7 object\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (p7 != NULL)\\r\\nPKCS7_free(p7);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_exp_c", "target": 0, "func": "int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint i, bits, ret = 0;\\r\\nBIGNUM *v, *rr;\\r\\nif (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\\r\\nBNerr(BN_F_BN_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nif ((r == a) || (r == p))\\r\\nrr = BN_CTX_get(ctx);\\r\\nelse\\r\\nrr = r;\\r\\nv = BN_CTX_get(ctx);\\r\\nif (rr == NULL || v == NULL)\\r\\ngoto err;\\r\\nif (BN_copy(v, a) == NULL)\\r\\ngoto err;\\r\\nbits = BN_num_bits(p);\\r\\nif (BN_is_odd(p)) {\\r\\nif (BN_copy(rr, a) == NULL)\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_one(rr))\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 1; i < bits; i++) {\\r\\nif (!BN_sqr(v, v, ctx))\\r\\ngoto err;\\r\\nif (BN_is_bit_set(p, i)) {\\r\\nif (!BN_mul(rr, rr, v, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (r != rr)\\r\\nBN_copy(r, rr);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(r);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\n#define MONT_MUL_MOD\\r\\n#define MONT_EXP_WORD\\r\\n#define RECP_MUL_MOD\\r\\n#ifdef MONT_MUL_MOD\\r\\nif (BN_is_odd(m)) {\\r\\n# ifdef MONT_EXP_WORD\\r\\nif (a->top == 1 && !a->neg\\r\\n&& (BN_get_flags(p, BN_FLG_CONSTTIME) == 0)) {\\r\\nBN_ULONG A = a->d[0];\\r\\nret = BN_mod_exp_mont_word(r, A, p, m, ctx, NULL);\\r\\n} else\\r\\n# endif\\r\\nret = BN_mod_exp_mont(r, a, p, m, ctx, NULL);\\r\\n} else\\r\\n#endif\\r\\n#ifdef RECP_MUL_MOD\\r\\n{\\r\\nret = BN_mod_exp_recp(r, a, p, m, ctx);\\r\\n}\\r\\n#else\\r\\n{\\r\\nret = BN_mod_exp_simple(r, a, p, m, ctx);\\r\\n}\\r\\n#endif\\r\\nbn_check_top(r);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nint i, j, bits, ret = 0, wstart, wend, window, wvalue;\\r\\nint start = 1;\\r\\nBIGNUM *aa;\\r\\nBIGNUM *val[TABLE_SIZE];\\r\\nBN_RECP_CTX recp;\\r\\nif (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\\r\\nBNerr(BN_F_BN_MOD_EXP_RECP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn -1;\\r\\n}\\r\\nbits = BN_num_bits(p);\\r\\nif (bits == 0) {\\r\\nret = BN_one(r);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\naa = BN_CTX_get(ctx);\\r\\nval[0] = BN_CTX_get(ctx);\\r\\nif (!aa || !val[0])\\r\\ngoto err;\\r\\nBN_RECP_CTX_init(&recp);\\r\\nif (m->neg) {\\r\\nif (!BN_copy(aa, m))\\r\\ngoto err;\\r\\naa->neg = 0;\\r\\nif (BN_RECP_CTX_set(&recp, aa, ctx) <= 0)\\r\\ngoto err;\\r\\n} else {\\r\\nif (BN_RECP_CTX_set(&recp, m, ctx) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_nnmod(val[0], a, m, ctx))\\r\\ngoto err;\\r\\nif (BN_is_zero(val[0])) {\\r\\nBN_zero(r);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nwindow = BN_window_bits_for_exponent_size(bits);\\r\\nif (window > 1) {\\r\\nif (!BN_mod_mul_reciprocal(aa, val[0], val[0], &recp, ctx))\\r\\ngoto err;\\r\\nj = 1 << (window - 1);\\r\\nfor (i = 1; i < j; i++) {\\r\\nif (((val[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul_reciprocal(val[i], val[i - 1], aa, &recp, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nstart = 1;\\r\\nwvalue = 0;\\r\\nwstart = bits - 1;\\r\\nwend = 0;\\r\\nif (!BN_one(r))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nif (BN_is_bit_set(p, wstart) == 0) {\\r\\nif (!start)\\r\\nif (!BN_mod_mul_reciprocal(r, r, r, &recp, ctx))\\r\\ngoto err;\\r\\nif (wstart == 0)\\r\\nbreak;\\r\\nwstart--;\\r\\ncontinue;\\r\\n}\\r\\nj = wstart;\\r\\nwvalue = 1;\\r\\nwend = 0;\\r\\nfor (i = 1; i < window; i++) {\\r\\nif (wstart - i < 0)\\r\\nbreak;\\r\\nif (BN_is_bit_set(p, wstart - i)) {\\r\\nwvalue <<= (i - wend);\\r\\nwvalue |= 1;\\r\\nwend = i;\\r\\n}\\r\\n}\\r\\nj = wend + 1;\\r\\nif (!start)\\r\\nfor (i = 0; i < j; i++) {\\r\\nif (!BN_mod_mul_reciprocal(r, r, r, &recp, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul_reciprocal(r, r, val[wvalue >> 1], &recp, ctx))\\r\\ngoto err;\\r\\nwstart -= wend + 1;\\r\\nwvalue = 0;\\r\\nstart = 0;\\r\\nif (wstart < 0)\\r\\nbreak;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nBN_RECP_CTX_free(&recp);\\r\\nbn_check_top(r);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nint i, j, bits, ret = 0, wstart, wend, window, wvalue;\\r\\nint start = 1;\\r\\nBIGNUM *d, *r;\\r\\nconst BIGNUM *aa;\\r\\nBIGNUM *val[TABLE_SIZE];\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nif (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\\r\\nreturn BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);\\r\\n}\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\nif (!BN_is_odd(m)) {\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT, BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn (0);\\r\\n}\\r\\nbits = BN_num_bits(p);\\r\\nif (bits == 0) {\\r\\nret = BN_one(rr);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nd = BN_CTX_get(ctx);\\r\\nr = BN_CTX_get(ctx);\\r\\nval[0] = BN_CTX_get(ctx);\\r\\nif (!d || !r || !val[0])\\r\\ngoto err;\\r\\nif (in_mont != NULL)\\r\\nmont = in_mont;\\r\\nelse {\\r\\nif ((mont = BN_MONT_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(mont, m, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (a->neg || BN_ucmp(a, m) >= 0) {\\r\\nif (!BN_nnmod(val[0], a, m, ctx))\\r\\ngoto err;\\r\\naa = val[0];\\r\\n} else\\r\\naa = a;\\r\\nif (BN_is_zero(aa)) {\\r\\nBN_zero(rr);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_to_montgomery(val[0], aa, mont, ctx))\\r\\ngoto err;\\r\\nwindow = BN_window_bits_for_exponent_size(bits);\\r\\nif (window > 1) {\\r\\nif (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx))\\r\\ngoto err;\\r\\nj = 1 << (window - 1);\\r\\nfor (i = 1; i < j; i++) {\\r\\nif (((val[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul_montgomery(val[i], val[i - 1], d, mont, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nstart = 1;\\r\\nwvalue = 0;\\r\\nwstart = bits - 1;\\r\\nwend = 0;\\r\\n#if 1\\r\\nj = m->top;\\r\\nif (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\\r\\nif (bn_wexpand(r, j) == NULL)\\r\\ngoto err;\\r\\nr->d[0] = (0 - m->d[0]) & BN_MASK2;\\r\\nfor (i = 1; i < j; i++)\\r\\nr->d[i] = (~m->d[i]) & BN_MASK2;\\r\\nr->top = j;\\r\\nbn_correct_top(r);\\r\\n} else\\r\\n#endif\\r\\nif (!BN_to_montgomery(r, BN_value_one(), mont, ctx))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nif (BN_is_bit_set(p, wstart) == 0) {\\r\\nif (!start) {\\r\\nif (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (wstart == 0)\\r\\nbreak;\\r\\nwstart--;\\r\\ncontinue;\\r\\n}\\r\\nj = wstart;\\r\\nwvalue = 1;\\r\\nwend = 0;\\r\\nfor (i = 1; i < window; i++) {\\r\\nif (wstart - i < 0)\\r\\nbreak;\\r\\nif (BN_is_bit_set(p, wstart - i)) {\\r\\nwvalue <<= (i - wend);\\r\\nwvalue |= 1;\\r\\nwend = i;\\r\\n}\\r\\n}\\r\\nj = wend + 1;\\r\\nif (!start)\\r\\nfor (i = 0; i < j; i++) {\\r\\nif (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx))\\r\\ngoto err;\\r\\nwstart -= wend + 1;\\r\\nwvalue = 0;\\r\\nstart = 0;\\r\\nif (wstart < 0)\\r\\nbreak;\\r\\n}\\r\\n#if defined(SPARC_T4_MONT)\\r\\nif (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) {\\r\\nj = mont->N.top;\\r\\nval[0]->d[0] = 1;\\r\\nfor (i = 1; i < j; i++)\\r\\nval[0]->d[i] = 0;\\r\\nval[0]->top = j;\\r\\nif (!BN_mod_mul_montgomery(rr, r, val[0], mont, ctx))\\r\\ngoto err;\\r\\n} else\\r\\n#endif\\r\\nif (!BN_from_montgomery(rr, r, mont, ctx))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL))\\r\\nBN_MONT_CTX_free(mont);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(rr);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic BN_ULONG bn_get_bits(const BIGNUM *a, int bitpos)\\r\\n{\\r\\nBN_ULONG ret = 0;\\r\\nint wordpos;\\r\\nwordpos = bitpos / BN_BITS2;\\r\\nbitpos %= BN_BITS2;\\r\\nif (wordpos >= 0 && wordpos < a->top) {\\r\\nret = a->d[wordpos] & BN_MASK2;\\r\\nif (bitpos) {\\r\\nret >>= bitpos;\\r\\nif (++wordpos < a->top)\\r\\nret |= a->d[wordpos] << (BN_BITS2 - bitpos);\\r\\n}\\r\\n}\\r\\nreturn ret & BN_MASK2;\\r\\n}\\r\\nstatic int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top,\\r\\nunsigned char *buf, int idx,\\r\\nint width)\\r\\n{\\r\\nsize_t i, j;\\r\\nif (top > b->top)\\r\\ntop = b->top;\\r\\nfor (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\\r\\nbuf[j] = ((unsigned char *)b->d)[i];\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\\r\\nunsigned char *buf, int idx,\\r\\nint width)\\r\\n{\\r\\nsize_t i, j;\\r\\nif (bn_wexpand(b, top) == NULL)\\r\\nreturn 0;\\r\\nfor (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\\r\\n((unsigned char *)b->d)[i] = buf[j];\\r\\n}\\r\\nb->top = top;\\r\\nbn_correct_top(b);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *in_mont)\\r\\n{\\r\\nint i, bits, ret = 0, window, wvalue;\\r\\nint top;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nint numPowers;\\r\\nunsigned char *powerbufFree = NULL;\\r\\nint powerbufLen = 0;\\r\\nunsigned char *powerbuf = NULL;\\r\\nBIGNUM tmp, am;\\r\\n#if defined(SPARC_T4_MONT)\\r\\nunsigned int t4 = 0;\\r\\n#endif\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\ntop = m->top;\\r\\nif (!(m->d[0] & 1)) {\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT_CONSTTIME, BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn (0);\\r\\n}\\r\\nbits = BN_num_bits(p);\\r\\nif (bits == 0) {\\r\\nret = BN_one(rr);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nif (in_mont != NULL)\\r\\nmont = in_mont;\\r\\nelse {\\r\\nif ((mont = BN_MONT_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(mont, m, ctx))\\r\\ngoto err;\\r\\n}\\r\\n#ifdef RSAZ_ENABLED\\r\\nif ((16 == a->top) && (16 == p->top) && (BN_num_bits(m) == 1024)\\r\\n&& rsaz_avx2_eligible()) {\\r\\nif (NULL == bn_wexpand(rr, 16))\\r\\ngoto err;\\r\\nRSAZ_1024_mod_exp_avx2(rr->d, a->d, p->d, m->d, mont->RR.d,\\r\\nmont->n0[0]);\\r\\nrr->top = 16;\\r\\nrr->neg = 0;\\r\\nbn_correct_top(rr);\\r\\nret = 1;\\r\\ngoto err;\\r\\n} else if ((8 == a->top) && (8 == p->top) && (BN_num_bits(m) == 512)) {\\r\\nif (NULL == bn_wexpand(rr, 8))\\r\\ngoto err;\\r\\nRSAZ_512_mod_exp(rr->d, a->d, p->d, m->d, mont->n0[0], mont->RR.d);\\r\\nrr->top = 8;\\r\\nrr->neg = 0;\\r\\nbn_correct_top(rr);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\nwindow = BN_window_bits_for_ctime_exponent_size(bits);\\r\\n#if defined(SPARC_T4_MONT)\\r\\nif (window >= 5 && (top & 15) == 0 && top <= 64 &&\\r\\n(OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\\r\\n(CFR_MONTMUL | CFR_MONTSQR) && (t4 = OPENSSL_sparcv9cap_P[0]))\\r\\nwindow = 5;\\r\\nelse\\r\\n#endif\\r\\n#if defined(OPENSSL_BN_ASM_MONT5)\\r\\nif (window >= 5) {\\r\\nwindow = 5;\\r\\nif ((top & 7) == 0)\\r\\npowerbufLen += 2 * top * sizeof(m->d[0]);\\r\\n}\\r\\n#endif\\r\\n(void)0;\\r\\nnumPowers = 1 << window;\\r\\npowerbufLen += sizeof(m->d[0]) * (top * numPowers +\\r\\n((2 * top) >\\r\\nnumPowers ? (2 * top) : numPowers));\\r\\n#ifdef alloca\\r\\nif (powerbufLen < 3072)\\r\\npowerbufFree =\\r\\nalloca(powerbufLen + MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH);\\r\\nelse\\r\\n#endif\\r\\nif ((powerbufFree =\\r\\n(unsigned char *)OPENSSL_malloc(powerbufLen +\\r\\nMOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH))\\r\\n== NULL)\\r\\ngoto err;\\r\\npowerbuf = MOD_EXP_CTIME_ALIGN(powerbufFree);\\r\\nmemset(powerbuf, 0, powerbufLen);\\r\\n#ifdef alloca\\r\\nif (powerbufLen < 3072)\\r\\npowerbufFree = NULL;\\r\\n#endif\\r\\ntmp.d = (BN_ULONG *)(powerbuf + sizeof(m->d[0]) * top * numPowers);\\r\\nam.d = tmp.d + top;\\r\\ntmp.top = am.top = 0;\\r\\ntmp.dmax = am.dmax = top;\\r\\ntmp.neg = am.neg = 0;\\r\\ntmp.flags = am.flags = BN_FLG_STATIC_DATA;\\r\\n#if 1\\r\\nif (m->d[top - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\\r\\ntmp.d[0] = (0 - m->d[0]) & BN_MASK2;\\r\\nfor (i = 1; i < top; i++)\\r\\ntmp.d[i] = (~m->d[i]) & BN_MASK2;\\r\\ntmp.top = top;\\r\\n} else\\r\\n#endif\\r\\nif (!BN_to_montgomery(&tmp, BN_value_one(), mont, ctx))\\r\\ngoto err;\\r\\nif (a->neg || BN_ucmp(a, m) >= 0) {\\r\\nif (!BN_mod(&am, a, m, ctx))\\r\\ngoto err;\\r\\nif (!BN_to_montgomery(&am, &am, mont, ctx))\\r\\ngoto err;\\r\\n} else if (!BN_to_montgomery(&am, a, mont, ctx))\\r\\ngoto err;\\r\\n#if defined(SPARC_T4_MONT)\\r\\nif (t4) {\\r\\ntypedef int (*bn_pwr5_mont_f) (BN_ULONG *tp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, const void *table,\\r\\nint power, int bits);\\r\\nint bn_pwr5_mont_t4_8(BN_ULONG *tp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, const void *table,\\r\\nint power, int bits);\\r\\nint bn_pwr5_mont_t4_16(BN_ULONG *tp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, const void *table,\\r\\nint power, int bits);\\r\\nint bn_pwr5_mont_t4_24(BN_ULONG *tp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, const void *table,\\r\\nint power, int bits);\\r\\nint bn_pwr5_mont_t4_32(BN_ULONG *tp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, const void *table,\\r\\nint power, int bits);\\r\\nstatic const bn_pwr5_mont_f pwr5_funcs[4] = {\\r\\nbn_pwr5_mont_t4_8, bn_pwr5_mont_t4_16,\\r\\nbn_pwr5_mont_t4_24, bn_pwr5_mont_t4_32\\r\\n};\\r\\nbn_pwr5_mont_f pwr5_worker = pwr5_funcs[top / 16 - 1];\\r\\ntypedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst void *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0);\\r\\nint bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap, const void *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0);\\r\\nint bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst void *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0);\\r\\nint bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst void *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0);\\r\\nint bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst void *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0);\\r\\nstatic const bn_mul_mont_f mul_funcs[4] = {\\r\\nbn_mul_mont_t4_8, bn_mul_mont_t4_16,\\r\\nbn_mul_mont_t4_24, bn_mul_mont_t4_32\\r\\n};\\r\\nbn_mul_mont_f mul_worker = mul_funcs[top / 16 - 1];\\r\\nvoid bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst void *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, int num);\\r\\nvoid bn_mul_mont_t4(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst void *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, int num);\\r\\nvoid bn_mul_mont_gather5_t4(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst void *table, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, int num, int power);\\r\\nvoid bn_flip_n_scatter5_t4(const BN_ULONG *inp, size_t num,\\r\\nvoid *table, size_t power);\\r\\nvoid bn_gather5_t4(BN_ULONG *out, size_t num,\\r\\nvoid *table, size_t power);\\r\\nvoid bn_flip_t4(BN_ULONG *dst, BN_ULONG *src, size_t num);\\r\\nBN_ULONG *np = mont->N.d, *n0 = mont->n0;\\r\\nint stride = 5 * (6 - (top / 16 - 1));\\r\\nfor (i = am.top; i < top; i++)\\r\\nam.d[i] = 0;\\r\\nfor (i = tmp.top; i < top; i++)\\r\\ntmp.d[i] = 0;\\r\\nbn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 0);\\r\\nbn_flip_n_scatter5_t4(am.d, top, powerbuf, 1);\\r\\nif (!(*mul_worker) (tmp.d, am.d, am.d, np, n0) &&\\r\\n!(*mul_worker) (tmp.d, am.d, am.d, np, n0))\\r\\nbn_mul_mont_vis3(tmp.d, am.d, am.d, np, n0, top);\\r\\nbn_flip_n_scatter5_t4(tmp.d, top, powerbuf, 2);\\r\\nfor (i = 3; i < 32; i++) {\\r\\nif (!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0) &&\\r\\n!(*mul_worker) (tmp.d, tmp.d, am.d, np, n0))\\r\\nbn_mul_mont_vis3(tmp.d, tmp.d, am.d, np, n0, top);\\r\\nbn_flip_n_scatter5_t4(tmp.d, top, powerbuf, i);\\r\\n}\\r\\nnp = alloca(top * sizeof(BN_ULONG));\\r\\ntop /= 2;\\r\\nbn_flip_t4(np, mont->N.d, top);\\r\\nbits--;\\r\\nfor (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\\r\\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\\r\\nbn_gather5_t4(tmp.d, top, powerbuf, wvalue);\\r\\nwhile (bits >= 0) {\\r\\nif (bits < stride)\\r\\nstride = bits + 1;\\r\\nbits -= stride;\\r\\nwvalue = bn_get_bits(p, bits + 1);\\r\\nif ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\\r\\ncontinue;\\r\\nif ((*pwr5_worker) (tmp.d, np, n0, powerbuf, wvalue, stride))\\r\\ncontinue;\\r\\nbits += stride - 5;\\r\\nwvalue >>= stride - 5;\\r\\nwvalue &= 31;\\r\\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont_t4(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont_gather5_t4(tmp.d, tmp.d, powerbuf, np, n0, top,\\r\\nwvalue);\\r\\n}\\r\\nbn_flip_t4(tmp.d, tmp.d, top);\\r\\ntop *= 2;\\r\\ntmp.top = top;\\r\\nbn_correct_top(&tmp);\\r\\nOPENSSL_cleanse(np, top * sizeof(BN_ULONG));\\r\\n} else\\r\\n#endif\\r\\n#if defined(OPENSSL_BN_ASM_MONT5)\\r\\nif (window == 5 && top > 1) {\\r\\nvoid bn_mul_mont_gather5(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst void *table, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, int num, int power);\\r\\nvoid bn_scatter5(const BN_ULONG *inp, size_t num,\\r\\nvoid *table, size_t power);\\r\\nvoid bn_gather5(BN_ULONG *out, size_t num, void *table, size_t power);\\r\\nvoid bn_power5(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst void *table, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, int num, int power);\\r\\nint bn_get_bits5(const BN_ULONG *ap, int off);\\r\\nint bn_from_montgomery(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst BN_ULONG *not_used, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, int num);\\r\\nBN_ULONG *np = mont->N.d, *n0 = mont->n0, *np2;\\r\\nfor (i = am.top; i < top; i++)\\r\\nam.d[i] = 0;\\r\\nfor (i = tmp.top; i < top; i++)\\r\\ntmp.d[i] = 0;\\r\\nif (top & 7)\\r\\nnp2 = np;\\r\\nelse\\r\\nfor (np2 = am.d + top, i = 0; i < top; i++)\\r\\nnp2[2 * i] = np[i];\\r\\nbn_scatter5(tmp.d, top, powerbuf, 0);\\r\\nbn_scatter5(am.d, am.top, powerbuf, 1);\\r\\nbn_mul_mont(tmp.d, am.d, am.d, np, n0, top);\\r\\nbn_scatter5(tmp.d, top, powerbuf, 2);\\r\\n# if 0\\r\\nfor (i = 3; i < 32; i++) {\\r\\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\\r\\nbn_scatter5(tmp.d, top, powerbuf, i);\\r\\n}\\r\\n# else\\r\\nfor (i = 4; i < 32; i *= 2) {\\r\\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_scatter5(tmp.d, top, powerbuf, i);\\r\\n}\\r\\nfor (i = 3; i < 8; i += 2) {\\r\\nint j;\\r\\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\\r\\nbn_scatter5(tmp.d, top, powerbuf, i);\\r\\nfor (j = 2 * i; j < 32; j *= 2) {\\r\\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_scatter5(tmp.d, top, powerbuf, j);\\r\\n}\\r\\n}\\r\\nfor (; i < 16; i += 2) {\\r\\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\\r\\nbn_scatter5(tmp.d, top, powerbuf, i);\\r\\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_scatter5(tmp.d, top, powerbuf, 2 * i);\\r\\n}\\r\\nfor (; i < 32; i += 2) {\\r\\nbn_mul_mont_gather5(tmp.d, am.d, powerbuf, np2, n0, top, i - 1);\\r\\nbn_scatter5(tmp.d, top, powerbuf, i);\\r\\n}\\r\\n# endif\\r\\nbits--;\\r\\nfor (wvalue = 0, i = bits % 5; i >= 0; i--, bits--)\\r\\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\\r\\nbn_gather5(tmp.d, top, powerbuf, wvalue);\\r\\nif (top & 7)\\r\\nwhile (bits >= 0) {\\r\\nfor (wvalue = 0, i = 0; i < 5; i++, bits--)\\r\\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\\r\\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont(tmp.d, tmp.d, tmp.d, np, n0, top);\\r\\nbn_mul_mont_gather5(tmp.d, tmp.d, powerbuf, np, n0, top,\\r\\nwvalue);\\r\\n} else {\\r\\nwhile (bits >= 0) {\\r\\nwvalue = bn_get_bits5(p->d, bits - 4);\\r\\nbits -= 5;\\r\\nbn_power5(tmp.d, tmp.d, powerbuf, np2, n0, top, wvalue);\\r\\n}\\r\\n}\\r\\nret = bn_from_montgomery(tmp.d, tmp.d, NULL, np2, n0, top);\\r\\ntmp.top = top;\\r\\nbn_correct_top(&tmp);\\r\\nif (ret) {\\r\\nif (!BN_copy(rr, &tmp))\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\n#endif\\r\\n{\\r\\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(&tmp, top, powerbuf, 0, numPowers))\\r\\ngoto err;\\r\\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF(&am, top, powerbuf, 1, numPowers))\\r\\ngoto err;\\r\\nif (window > 1) {\\r\\nif (!BN_mod_mul_montgomery(&tmp, &am, &am, mont, ctx))\\r\\ngoto err;\\r\\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF\\r\\n(&tmp, top, powerbuf, 2, numPowers))\\r\\ngoto err;\\r\\nfor (i = 3; i < numPowers; i++) {\\r\\nif (!BN_mod_mul_montgomery(&tmp, &am, &tmp, mont, ctx))\\r\\ngoto err;\\r\\nif (!MOD_EXP_CTIME_COPY_TO_PREBUF\\r\\n(&tmp, top, powerbuf, i, numPowers))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nbits--;\\r\\nfor (wvalue = 0, i = bits % window; i >= 0; i--, bits--)\\r\\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\\r\\nif (!MOD_EXP_CTIME_COPY_FROM_PREBUF\\r\\n(&tmp, top, powerbuf, wvalue, numPowers))\\r\\ngoto err;\\r\\nwhile (bits >= 0) {\\r\\nwvalue = 0;\\r\\nfor (i = 0; i < window; i++, bits--) {\\r\\nif (!BN_mod_mul_montgomery(&tmp, &tmp, &tmp, mont, ctx))\\r\\ngoto err;\\r\\nwvalue = (wvalue << 1) + BN_is_bit_set(p, bits);\\r\\n}\\r\\nif (!MOD_EXP_CTIME_COPY_FROM_PREBUF\\r\\n(&am, top, powerbuf, wvalue, numPowers))\\r\\ngoto err;\\r\\nif (!BN_mod_mul_montgomery(&tmp, &tmp, &am, mont, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#if defined(SPARC_T4_MONT)\\r\\nif (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) {\\r\\nam.d[0] = 1;\\r\\nfor (i = 1; i < top; i++)\\r\\nam.d[i] = 0;\\r\\nif (!BN_mod_mul_montgomery(rr, &tmp, &am, mont, ctx))\\r\\ngoto err;\\r\\n} else\\r\\n#endif\\r\\nif (!BN_from_montgomery(rr, &tmp, mont, ctx))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL))\\r\\nBN_MONT_CTX_free(mont);\\r\\nif (powerbuf != NULL) {\\r\\nOPENSSL_cleanse(powerbuf, powerbufLen);\\r\\nif (powerbufFree)\\r\\nOPENSSL_free(powerbufFree);\\r\\n}\\r\\nBN_CTX_end(ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nint b, bits, ret = 0;\\r\\nint r_is_one;\\r\\nBN_ULONG w, next_w;\\r\\nBIGNUM *d, *r, *t;\\r\\nBIGNUM *swap_tmp;\\r\\n#define BN_MOD_MUL_WORD(r, w, m) \\\\r\\n(BN_mul_word(r, (w)) && \\\\r\\n( \\\\r\\n(BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\\r\\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\\r\\n(BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\\r\\nif (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn -1;\\r\\n}\\r\\nbn_check_top(p);\\r\\nbn_check_top(m);\\r\\nif (!BN_is_odd(m)) {\\r\\nBNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn (0);\\r\\n}\\r\\nif (m->top == 1)\\r\\na %= m->d[0];\\r\\nbits = BN_num_bits(p);\\r\\nif (bits == 0) {\\r\\nif (BN_is_one(m)) {\\r\\nret = 1;\\r\\nBN_zero(rr);\\r\\n} else\\r\\nret = BN_one(rr);\\r\\nreturn ret;\\r\\n}\\r\\nif (a == 0) {\\r\\nBN_zero(rr);\\r\\nret = 1;\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nd = BN_CTX_get(ctx);\\r\\nr = BN_CTX_get(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\nif (d == NULL || r == NULL || t == NULL)\\r\\ngoto err;\\r\\nif (in_mont != NULL)\\r\\nmont = in_mont;\\r\\nelse {\\r\\nif ((mont = BN_MONT_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(mont, m, ctx))\\r\\ngoto err;\\r\\n}\\r\\nr_is_one = 1;\\r\\nw = a;\\r\\nfor (b = bits - 2; b >= 0; b--) {\\r\\nnext_w = w * w;\\r\\nif ((next_w / w) != w) {\\r\\nif (r_is_one) {\\r\\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont))\\r\\ngoto err;\\r\\nr_is_one = 0;\\r\\n} else {\\r\\nif (!BN_MOD_MUL_WORD(r, w, m))\\r\\ngoto err;\\r\\n}\\r\\nnext_w = 1;\\r\\n}\\r\\nw = next_w;\\r\\nif (!r_is_one) {\\r\\nif (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_bit_set(p, b)) {\\r\\nnext_w = w * a;\\r\\nif ((next_w / a) != w) {\\r\\nif (r_is_one) {\\r\\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont))\\r\\ngoto err;\\r\\nr_is_one = 0;\\r\\n} else {\\r\\nif (!BN_MOD_MUL_WORD(r, w, m))\\r\\ngoto err;\\r\\n}\\r\\nnext_w = a;\\r\\n}\\r\\nw = next_w;\\r\\n}\\r\\n}\\r\\nif (w != 1) {\\r\\nif (r_is_one) {\\r\\nif (!BN_TO_MONTGOMERY_WORD(r, w, mont))\\r\\ngoto err;\\r\\nr_is_one = 0;\\r\\n} else {\\r\\nif (!BN_MOD_MUL_WORD(r, w, m))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (r_is_one) {\\r\\nif (!BN_one(rr))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_from_montgomery(rr, r, mont, ctx))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL))\\r\\nBN_MONT_CTX_free(mont);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(rr);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nint i, j, bits, ret = 0, wstart, wend, window, wvalue;\\r\\nint start = 1;\\r\\nBIGNUM *d;\\r\\nBIGNUM *val[TABLE_SIZE];\\r\\nif (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\\r\\nBNerr(BN_F_BN_MOD_EXP_SIMPLE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn -1;\\r\\n}\\r\\nbits = BN_num_bits(p);\\r\\nif (bits == 0) {\\r\\nret = BN_one(r);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nd = BN_CTX_get(ctx);\\r\\nval[0] = BN_CTX_get(ctx);\\r\\nif (!d || !val[0])\\r\\ngoto err;\\r\\nif (!BN_nnmod(val[0], a, m, ctx))\\r\\ngoto err;\\r\\nif (BN_is_zero(val[0])) {\\r\\nBN_zero(r);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nwindow = BN_window_bits_for_exponent_size(bits);\\r\\nif (window > 1) {\\r\\nif (!BN_mod_mul(d, val[0], val[0], m, ctx))\\r\\ngoto err;\\r\\nj = 1 << (window - 1);\\r\\nfor (i = 1; i < j; i++) {\\r\\nif (((val[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul(val[i], val[i - 1], d, m, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nstart = 1;\\r\\nwvalue = 0;\\r\\nwstart = bits - 1;\\r\\nwend = 0;\\r\\nif (!BN_one(r))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nif (BN_is_bit_set(p, wstart) == 0) {\\r\\nif (!start)\\r\\nif (!BN_mod_mul(r, r, r, m, ctx))\\r\\ngoto err;\\r\\nif (wstart == 0)\\r\\nbreak;\\r\\nwstart--;\\r\\ncontinue;\\r\\n}\\r\\nj = wstart;\\r\\nwvalue = 1;\\r\\nwend = 0;\\r\\nfor (i = 1; i < window; i++) {\\r\\nif (wstart - i < 0)\\r\\nbreak;\\r\\nif (BN_is_bit_set(p, wstart - i)) {\\r\\nwvalue <<= (i - wend);\\r\\nwvalue |= 1;\\r\\nwend = i;\\r\\n}\\r\\n}\\r\\nj = wend + 1;\\r\\nif (!start)\\r\\nfor (i = 0; i < j; i++) {\\r\\nif (!BN_mod_mul(r, r, r, m, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_mul(r, r, val[wvalue >> 1], m, ctx))\\r\\ngoto err;\\r\\nwstart -= wend + 1;\\r\\nwvalue = 0;\\r\\nstart = 0;\\r\\nif (wstart < 0)\\r\\nbreak;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(r);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509spki_c", "target": 0, "func": "int NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *x, EVP_PKEY *pkey)\\r\\n{\\r\\nif ((x == NULL) || (x->spkac == NULL))\\r\\nreturn (0);\\r\\nreturn (X509_PUBKEY_set(&(x->spkac->pubkey), pkey));\\r\\n}\\r\\nEVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *x)\\r\\n{\\r\\nif ((x == NULL) || (x->spkac == NULL))\\r\\nreturn (NULL);\\r\\nreturn (X509_PUBKEY_get(x->spkac->pubkey));\\r\\n}\\r\\nNETSCAPE_SPKI *NETSCAPE_SPKI_b64_decode(const char *str, int len)\\r\\n{\\r\\nunsigned char *spki_der;\\r\\nconst unsigned char *p;\\r\\nint spki_len;\\r\\nNETSCAPE_SPKI *spki;\\r\\nif (len <= 0)\\r\\nlen = strlen(str);\\r\\nif (!(spki_der = OPENSSL_malloc(len + 1))) {\\r\\nX509err(X509_F_NETSCAPE_SPKI_B64_DECODE, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nspki_len = EVP_DecodeBlock(spki_der, (const unsigned char *)str, len);\\r\\nif (spki_len < 0) {\\r\\nX509err(X509_F_NETSCAPE_SPKI_B64_DECODE, X509_R_BASE64_DECODE_ERROR);\\r\\nOPENSSL_free(spki_der);\\r\\nreturn NULL;\\r\\n}\\r\\np = spki_der;\\r\\nspki = d2i_NETSCAPE_SPKI(NULL, &p, spki_len);\\r\\nOPENSSL_free(spki_der);\\r\\nreturn spki;\\r\\n}\\r\\nchar *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *spki)\\r\\n{\\r\\nunsigned char *der_spki, *p;\\r\\nchar *b64_str;\\r\\nint der_len;\\r\\nder_len = i2d_NETSCAPE_SPKI(spki, NULL);\\r\\nder_spki = OPENSSL_malloc(der_len);\\r\\nb64_str = OPENSSL_malloc(der_len * 2);\\r\\nif (!der_spki || !b64_str) {\\r\\nX509err(X509_F_NETSCAPE_SPKI_B64_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\np = der_spki;\\r\\ni2d_NETSCAPE_SPKI(spki, &p);\\r\\nEVP_EncodeBlock((unsigned char *)b64_str, der_spki, der_len);\\r\\nOPENSSL_free(der_spki);\\r\\nreturn b64_str;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecp_oct_c", "target": 0, "func": "int ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *group,\\r\\nEC_POINT *point,\\r\\nconst BIGNUM *x_, int y_bit,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp1, *tmp2, *x, *y;\\r\\nint ret = 0;\\r\\nERR_clear_error();\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\ny_bit = (y_bit != 0);\\r\\nBN_CTX_start(ctx);\\r\\ntmp1 = BN_CTX_get(ctx);\\r\\ntmp2 = BN_CTX_get(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL)\\r\\ngoto err;\\r\\nif (!BN_nnmod(x, x_, &group->field, ctx))\\r\\ngoto err;\\r\\nif (group->meth->field_decode == 0) {\\r\\nif (!group->meth->field_sqr(group, tmp2, x_, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, tmp1, tmp2, x_, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mod_sqr(tmp2, x_, &group->field, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(tmp1, tmp2, x_, &group->field, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (group->a_is_minus3) {\\r\\nif (!BN_mod_lshift1_quick(tmp2, x, &group->field))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(tmp2, tmp2, x, &group->field))\\r\\ngoto err;\\r\\nif (!BN_mod_sub_quick(tmp1, tmp1, tmp2, &group->field))\\r\\ngoto err;\\r\\n} else {\\r\\nif (group->meth->field_decode) {\\r\\nif (!group->meth->field_decode(group, tmp2, &group->a, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(tmp2, tmp2, x, &group->field, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!group->meth->field_mul(group, tmp2, &group->a, x, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_add_quick(tmp1, tmp1, tmp2, &group->field))\\r\\ngoto err;\\r\\n}\\r\\nif (group->meth->field_decode) {\\r\\nif (!group->meth->field_decode(group, tmp2, &group->b, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(tmp1, tmp1, tmp2, &group->field))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mod_add_quick(tmp1, tmp1, &group->b, &group->field))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_sqrt(y, tmp1, &group->field, ctx)) {\\r\\nunsigned long err = ERR_peek_last_error();\\r\\nif (ERR_GET_LIB(err) == ERR_LIB_BN\\r\\n&& ERR_GET_REASON(err) == BN_R_NOT_A_SQUARE) {\\r\\nERR_clear_error();\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,\\r\\nEC_R_INVALID_COMPRESSED_POINT);\\r\\n} else\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,\\r\\nERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (y_bit != BN_is_odd(y)) {\\r\\nif (BN_is_zero(y)) {\\r\\nint kron;\\r\\nkron = BN_kronecker(x, &group->field, ctx);\\r\\nif (kron == -2)\\r\\ngoto err;\\r\\nif (kron == 1)\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,\\r\\nEC_R_INVALID_COMPRESSION_BIT);\\r\\nelse\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,\\r\\nEC_R_INVALID_COMPRESSED_POINT);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_usub(y, &group->field, y))\\r\\ngoto err;\\r\\n}\\r\\nif (y_bit != BN_is_odd(y)) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES,\\r\\nERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nsize_t ec_GFp_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,\\r\\npoint_conversion_form_t form,\\r\\nunsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\nsize_t ret;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint used_ctx = 0;\\r\\nBIGNUM *x, *y;\\r\\nsize_t field_len, i, skip;\\r\\nif ((form != POINT_CONVERSION_COMPRESSED)\\r\\n&& (form != POINT_CONVERSION_UNCOMPRESSED)\\r\\n&& (form != POINT_CONVERSION_HYBRID)) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_INVALID_FORM);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_POINT_is_at_infinity(group, point)) {\\r\\nif (buf != NULL) {\\r\\nif (len < 1) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nbuf[0] = 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nfield_len = BN_num_bytes(&group->field);\\r\\nret =\\r\\n(form ==\\r\\nPOINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2 * field_len;\\r\\nif (buf != NULL) {\\r\\nif (len < ret) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nused_ctx = 1;\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL)\\r\\ngoto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GFp(group, point, x, y, ctx))\\r\\ngoto err;\\r\\nif ((form == POINT_CONVERSION_COMPRESSED\\r\\n|| form == POINT_CONVERSION_HYBRID) && BN_is_odd(y))\\r\\nbuf[0] = form + 1;\\r\\nelse\\r\\nbuf[0] = form;\\r\\ni = 1;\\r\\nskip = field_len - BN_num_bytes(x);\\r\\nif (skip > field_len) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwhile (skip > 0) {\\r\\nbuf[i++] = 0;\\r\\nskip--;\\r\\n}\\r\\nskip = BN_bn2bin(x, buf + i);\\r\\ni += skip;\\r\\nif (i != 1 + field_len) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_UNCOMPRESSED\\r\\n|| form == POINT_CONVERSION_HYBRID) {\\r\\nskip = field_len - BN_num_bytes(y);\\r\\nif (skip > field_len) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwhile (skip > 0) {\\r\\nbuf[i++] = 0;\\r\\nskip--;\\r\\n}\\r\\nskip = BN_bn2bin(y, buf + i);\\r\\ni += skip;\\r\\n}\\r\\nif (i != ret) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (used_ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\nerr:\\r\\nif (used_ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn 0;\\r\\n}\\r\\nint ec_GFp_simple_oct2point(const EC_GROUP *group, EC_POINT *point,\\r\\nconst unsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\npoint_conversion_form_t form;\\r\\nint y_bit;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y;\\r\\nsize_t field_len, enc_len;\\r\\nint ret = 0;\\r\\nif (len == 0) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_BUFFER_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nform = buf[0];\\r\\ny_bit = form & 1;\\r\\nform = form & ~1U;\\r\\nif ((form != 0) && (form != POINT_CONVERSION_COMPRESSED)\\r\\n&& (form != POINT_CONVERSION_UNCOMPRESSED)\\r\\n&& (form != POINT_CONVERSION_HYBRID)) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif ((form == 0 || form == POINT_CONVERSION_UNCOMPRESSED) && y_bit) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif (form == 0) {\\r\\nif (len != 1) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EC_POINT_set_to_infinity(group, point);\\r\\n}\\r\\nfield_len = BN_num_bytes(&group->field);\\r\\nenc_len =\\r\\n(form ==\\r\\nPOINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2 * field_len;\\r\\nif (len != enc_len) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL)\\r\\ngoto err;\\r\\nif (!BN_bin2bn(buf + 1, field_len, x))\\r\\ngoto err;\\r\\nif (BN_ucmp(x, &group->field) >= 0) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_COMPRESSED) {\\r\\nif (!EC_POINT_set_compressed_coordinates_GFp\\r\\n(group, point, x, y_bit, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_bin2bn(buf + 1 + field_len, field_len, y))\\r\\ngoto err;\\r\\nif (BN_ucmp(y, &group->field) >= 0) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_HYBRID) {\\r\\nif (y_bit != BN_is_odd(y)) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_is_on_curve(group, point, ctx)) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_OCT2POINT, EC_R_POINT_IS_NOT_ON_CURVE);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_cpols_c", "target": 0, "func": "static void print_notice(BIO *out, USERNOTICE *notice, int indent)\\r\\n{\\r\\nint i;\\r\\nif (notice->noticeref) {\\r\\nNOTICEREF *ref;\\r\\nref = notice->noticeref;\\r\\nBIO_printf(out, \"%*sOrganization: %s\\n\", indent, \"\",\\r\\nref->organization->data);\\r\\nBIO_printf(out, \"%*sNumber%s: \", indent, \"\",\\r\\nsk_ASN1_INTEGER_num(ref->noticenos) > 1 ? \"s\" : \"\");\\r\\nfor (i = 0; i < sk_ASN1_INTEGER_num(ref->noticenos); i++) {\\r\\nASN1_INTEGER *num;\\r\\nchar *tmp;\\r\\nnum = sk_ASN1_INTEGER_value(ref->noticenos, i);\\r\\nif (i)\\r\\nBIO_puts(out, \", \");\\r\\ntmp = i2s_ASN1_INTEGER(NULL, num);\\r\\nBIO_puts(out, tmp);\\r\\nOPENSSL_free(tmp);\\r\\n}\\r\\nBIO_puts(out, \"\\n\");\\r\\n}\\r\\nif (notice->exptext)\\r\\nBIO_printf(out, \"%*sExplicit Text: %s\\n\", indent, \"\",\\r\\nnotice->exptext->data);\\r\\n}\\r\\nvoid X509_POLICY_NODE_print(BIO *out, X509_POLICY_NODE *node, int indent)\\r\\n{\\r\\nconst X509_POLICY_DATA *dat = node->data;\\r\\nBIO_printf(out, \"%*sPolicy: \", indent, \"\");\\r\\ni2a_ASN1_OBJECT(out, dat->valid_policy);\\r\\nBIO_puts(out, \"\\n\");\\r\\nBIO_printf(out, \"%*s%s\\n\", indent + 2, \"\",\\r\\nnode_data_critical(dat) ? \"Critical\" : \"Non Critical\");\\r\\nif (dat->qualifier_set)\\r\\nprint_qualifiers(out, dat->qualifier_set, indent + 2);\\r\\nelse\\r\\nBIO_printf(out, \"%*sNo Qualifiers\\n\", indent + 2, \"\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_LPdir_vms_c", "target": 0, "func": "const char *LP_find_file(LP_DIR_CTX **ctx, const char *directory)\\r\\n{\\r\\nint status;\\r\\nchar *p, *r;\\r\\nsize_t l;\\r\\nunsigned long flags = 0;\\r\\n#if __INITIAL_POINTER_SIZE == 64\\r\\n# pragma pointer_size save\\r\\n# pragma pointer_size 32\\r\\nchar *ctx_filespec_32p;\\r\\n# pragma pointer_size restore\\r\\nchar ctx_filespec_32[NAMX_MAXRSS + 1];\\r\\n#endif\\r\\n#ifdef NAML$C_MAXRSS\\r\\nflags |= LIB$M_FIL_LONG_NAMES;\\r\\n#endif\\r\\nif (ctx == NULL || directory == NULL) {\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nerrno = 0;\\r\\nif (*ctx == NULL) {\\r\\nsize_t filespeclen = strlen(directory);\\r\\nchar *filespec = NULL;\\r\\nif (filespeclen == 0) {\\r\\nerrno = ENOENT;\\r\\nreturn 0;\\r\\n}\\r\\nif (directory[filespeclen - 1] != ']'\\r\\n&& directory[filespeclen - 1] != '>'\\r\\n&& directory[filespeclen - 1] != ':') {\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nfilespeclen += 4;\\r\\nif (filespeclen > NAMX_MAXRSS) {\\r\\nerrno = ENAMETOOLONG;\\r\\nreturn 0;\\r\\n}\\r\\n*ctx = (LP_DIR_CTX *)malloc(sizeof(LP_DIR_CTX));\\r\\nif (*ctx == NULL) {\\r\\nerrno = ENOMEM;\\r\\nreturn 0;\\r\\n}\\r\\nmemset(*ctx, '\\0', sizeof(LP_DIR_CTX));\\r\\nstrcpy((*ctx)->filespec, directory);\\r\\nstrcat((*ctx)->filespec, \"*.*;\");\\r\\n#if __INITIAL_POINTER_SIZE == 64\\r\\n# define CTX_FILESPEC ctx_filespec_32p\\r\\nctx_filespec_32p = ctx_filespec_32;\\r\\nstrcpy(ctx_filespec_32p, (*ctx)->filespec);\\r\\n#else\\r\\n# define CTX_FILESPEC (*ctx)->filespec\\r\\n#endif\\r\\n(*ctx)->filespec_dsc.dsc$w_length = filespeclen;\\r\\n(*ctx)->filespec_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\n(*ctx)->filespec_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\n(*ctx)->filespec_dsc.dsc$a_pointer = CTX_FILESPEC;\\r\\n}\\r\\n(*ctx)->result_dsc.dsc$w_length = 0;\\r\\n(*ctx)->result_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\n(*ctx)->result_dsc.dsc$b_class = DSC$K_CLASS_D;\\r\\n(*ctx)->result_dsc.dsc$a_pointer = 0;\\r\\nstatus = lib$find_file(&(*ctx)->filespec_dsc, &(*ctx)->result_dsc,\\r\\n&(*ctx)->VMS_context, 0, 0, 0, &flags);\\r\\nif (status == RMS$_NMF) {\\r\\nerrno = 0;\\r\\nvaxc$errno = status;\\r\\nreturn NULL;\\r\\n}\\r\\nif (!$VMS_STATUS_SUCCESS(status)) {\\r\\nerrno = EVMSERR;\\r\\nvaxc$errno = status;\\r\\nreturn NULL;\\r\\n}\\r\\nl = (*ctx)->result_dsc.dsc$w_length;\\r\\np = (*ctx)->result_dsc.dsc$a_pointer;\\r\\nr = p;\\r\\nfor (; *p; p++) {\\r\\nif (*p == '^' && p[1] != '\\0') {\\r\\np++;\\r\\n} else if (*p == ':' || *p == '>' || *p == ']') {\\r\\nl -= p + 1 - r;\\r\\nr = p + 1;\\r\\n} else if (*p == ';') {\\r\\nl = p - r;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nstrncpy((*ctx)->result, r, l);\\r\\n(*ctx)->result[l] = '\\0';\\r\\nstr$free1_dx(&(*ctx)->result_dsc);\\r\\nreturn (*ctx)->result;\\r\\n}\\r\\nint LP_find_file_end(LP_DIR_CTX **ctx)\\r\\n{\\r\\nif (ctx != NULL && *ctx != NULL) {\\r\\nint status = lib$find_file_end(&(*ctx)->VMS_context);\\r\\nfree(*ctx);\\r\\nif (!$VMS_STATUS_SUCCESS(status)) {\\r\\nerrno = EVMSERR;\\r\\nvaxc$errno = status;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_s3_lib_c", "target": 0, "func": "long ssl3_default_timeout(void)\\r\\n{\\r\\nreturn (60 * 60 * 2);\\r\\n}\\r\\nint ssl3_num_ciphers(void)\\r\\n{\\r\\nreturn (SSL3_NUM_CIPHERS);\\r\\n}\\r\\nconst SSL_CIPHER *ssl3_get_cipher(unsigned int u)\\r\\n{\\r\\nif (u < SSL3_NUM_CIPHERS)\\r\\nreturn (&(ssl3_ciphers[SSL3_NUM_CIPHERS - 1 - u]));\\r\\nelse\\r\\nreturn (NULL);\\r\\n}\\r\\nint ssl3_pending(const SSL *s)\\r\\n{\\r\\nif (s->rstate == SSL_ST_READ_BODY)\\r\\nreturn 0;\\r\\nreturn (s->s3->rrec.type ==\\r\\nSSL3_RT_APPLICATION_DATA) ? s->s3->rrec.length : 0;\\r\\n}\\r\\nvoid ssl3_set_handshake_header(SSL *s, int htype, unsigned long len)\\r\\n{\\r\\nunsigned char *p = (unsigned char *)s->init_buf->data;\\r\\n*(p++) = htype;\\r\\nl2n3(len, p);\\r\\ns->init_num = (int)len + SSL3_HM_HEADER_LENGTH;\\r\\ns->init_off = 0;\\r\\n}\\r\\nint ssl3_handshake_write(SSL *s)\\r\\n{\\r\\nreturn ssl3_do_write(s, SSL3_RT_HANDSHAKE);\\r\\n}\\r\\nint ssl3_new(SSL *s)\\r\\n{\\r\\nSSL3_STATE *s3;\\r\\nif ((s3 = OPENSSL_malloc(sizeof *s3)) == NULL)\\r\\ngoto err;\\r\\nmemset(s3, 0, sizeof *s3);\\r\\nmemset(s3->rrec.seq_num, 0, sizeof(s3->rrec.seq_num));\\r\\nmemset(s3->wrec.seq_num, 0, sizeof(s3->wrec.seq_num));\\r\\ns->s3 = s3;\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nSSL_SRP_CTX_init(s);\\r\\n#endif\\r\\ns->method->ssl_clear(s);\\r\\nreturn (1);\\r\\nerr:\\r\\nreturn (0);\\r\\n}\\r\\nvoid ssl3_free(SSL *s)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn;\\r\\n#ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nif (s->s3->client_opaque_prf_input != NULL)\\r\\nOPENSSL_free(s->s3->client_opaque_prf_input);\\r\\nif (s->s3->server_opaque_prf_input != NULL)\\r\\nOPENSSL_free(s->s3->server_opaque_prf_input);\\r\\n#endif\\r\\nssl3_cleanup_key_block(s);\\r\\nif (s->s3->rbuf.buf != NULL)\\r\\nssl3_release_read_buffer(s);\\r\\nif (s->s3->wbuf.buf != NULL)\\r\\nssl3_release_write_buffer(s);\\r\\nif (s->s3->rrec.comp != NULL)\\r\\nOPENSSL_free(s->s3->rrec.comp);\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (s->s3->tmp.dh != NULL)\\r\\nDH_free(s->s3->tmp.dh);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (s->s3->tmp.ecdh != NULL)\\r\\nEC_KEY_free(s->s3->tmp.ecdh);\\r\\n#endif\\r\\nif (s->s3->tmp.ca_names != NULL)\\r\\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);\\r\\nif (s->s3->handshake_buffer) {\\r\\nBIO_free(s->s3->handshake_buffer);\\r\\n}\\r\\nif (s->s3->handshake_dgst)\\r\\nssl3_free_digest_list(s);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s->s3->alpn_selected)\\r\\nOPENSSL_free(s->s3->alpn_selected);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nSSL_SRP_CTX_free(s);\\r\\n#endif\\r\\nOPENSSL_cleanse(s->s3, sizeof *s->s3);\\r\\nOPENSSL_free(s->s3);\\r\\ns->s3 = NULL;\\r\\n}\\r\\nvoid ssl3_clear(SSL *s)\\r\\n{\\r\\nunsigned char *rp, *wp;\\r\\nsize_t rlen, wlen;\\r\\nint init_extra;\\r\\n#ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nif (s->s3->client_opaque_prf_input != NULL)\\r\\nOPENSSL_free(s->s3->client_opaque_prf_input);\\r\\ns->s3->client_opaque_prf_input = NULL;\\r\\nif (s->s3->server_opaque_prf_input != NULL)\\r\\nOPENSSL_free(s->s3->server_opaque_prf_input);\\r\\ns->s3->server_opaque_prf_input = NULL;\\r\\n#endif\\r\\nssl3_cleanup_key_block(s);\\r\\nif (s->s3->tmp.ca_names != NULL)\\r\\nsk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);\\r\\nif (s->s3->rrec.comp != NULL) {\\r\\nOPENSSL_free(s->s3->rrec.comp);\\r\\ns->s3->rrec.comp = NULL;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (s->s3->tmp.dh != NULL) {\\r\\nDH_free(s->s3->tmp.dh);\\r\\ns->s3->tmp.dh = NULL;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (s->s3->tmp.ecdh != NULL) {\\r\\nEC_KEY_free(s->s3->tmp.ecdh);\\r\\ns->s3->tmp.ecdh = NULL;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\n# ifndef OPENSSL_NO_EC\\r\\ns->s3->is_probably_safari = 0;\\r\\n# endif\\r\\n#endif\\r\\nrp = s->s3->rbuf.buf;\\r\\nwp = s->s3->wbuf.buf;\\r\\nrlen = s->s3->rbuf.len;\\r\\nwlen = s->s3->wbuf.len;\\r\\ninit_extra = s->s3->init_extra;\\r\\nif (s->s3->handshake_buffer) {\\r\\nBIO_free(s->s3->handshake_buffer);\\r\\ns->s3->handshake_buffer = NULL;\\r\\n}\\r\\nif (s->s3->handshake_dgst) {\\r\\nssl3_free_digest_list(s);\\r\\n}\\r\\n#if !defined(OPENSSL_NO_TLSEXT)\\r\\nif (s->s3->alpn_selected) {\\r\\nfree(s->s3->alpn_selected);\\r\\ns->s3->alpn_selected = NULL;\\r\\n}\\r\\n#endif\\r\\nmemset(s->s3, 0, sizeof *s->s3);\\r\\ns->s3->rbuf.buf = rp;\\r\\ns->s3->wbuf.buf = wp;\\r\\ns->s3->rbuf.len = rlen;\\r\\ns->s3->wbuf.len = wlen;\\r\\ns->s3->init_extra = init_extra;\\r\\nssl_free_wbio_buffer(s);\\r\\ns->packet_length = 0;\\r\\ns->s3->renegotiate = 0;\\r\\ns->s3->total_renegotiations = 0;\\r\\ns->s3->num_renegotiations = 0;\\r\\ns->s3->in_read_app_data = 0;\\r\\ns->version = SSL3_VERSION;\\r\\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\\r\\nif (s->next_proto_negotiated) {\\r\\nOPENSSL_free(s->next_proto_negotiated);\\r\\ns->next_proto_negotiated = NULL;\\r\\ns->next_proto_negotiated_len = 0;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nstatic char *MS_CALLBACK srp_password_from_info_cb(SSL *s, void *arg)\\r\\n{\\r\\nreturn BUF_strdup(s->srp_ctx.info);\\r\\n}\\r\\nlong ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)\\r\\n{\\r\\nint ret = 0;\\r\\n#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_RSA)\\r\\nif (\\r\\n# ifndef OPENSSL_NO_RSA\\r\\ncmd == SSL_CTRL_SET_TMP_RSA || cmd == SSL_CTRL_SET_TMP_RSA_CB ||\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DSA\\r\\ncmd == SSL_CTRL_SET_TMP_DH || cmd == SSL_CTRL_SET_TMP_DH_CB ||\\r\\n# endif\\r\\n0) {\\r\\nif (!ssl_cert_inst(&s->cert)) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nswitch (cmd) {\\r\\ncase SSL_CTRL_GET_SESSION_REUSED:\\r\\nret = s->hit;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_CLIENT_CERT_REQUEST:\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_NUM_RENEGOTIATIONS:\\r\\nret = s->s3->num_renegotiations;\\r\\nbreak;\\r\\ncase SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS:\\r\\nret = s->s3->num_renegotiations;\\r\\ns->s3->num_renegotiations = 0;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_TOTAL_RENEGOTIATIONS:\\r\\nret = s->s3->total_renegotiations;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_FLAGS:\\r\\nret = (int)(s->s3->flags);\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase SSL_CTRL_NEED_TMP_RSA:\\r\\nif ((s->cert != NULL) && (s->cert->rsa_tmp == NULL) &&\\r\\n((s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\\r\\n(EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) >\\r\\n(512 / 8))))\\r\\nret = 1;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_RSA:\\r\\n{\\r\\nRSA *rsa = (RSA *)parg;\\r\\nif (rsa == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (ret);\\r\\n}\\r\\nif ((rsa = RSAPrivateKey_dup(rsa)) == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_RSA_LIB);\\r\\nreturn (ret);\\r\\n}\\r\\nif (s->cert->rsa_tmp != NULL)\\r\\nRSA_free(s->cert->rsa_tmp);\\r\\ns->cert->rsa_tmp = rsa;\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (ret);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH:\\r\\n{\\r\\nDH *dh = (DH *)parg;\\r\\nif (dh == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (ret);\\r\\n}\\r\\nif ((dh = DHparams_dup(dh)) == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\\r\\nreturn (ret);\\r\\n}\\r\\nif (!(s->options & SSL_OP_SINGLE_DH_USE)) {\\r\\nif (!DH_generate_key(dh)) {\\r\\nDH_free(dh);\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\\r\\nreturn (ret);\\r\\n}\\r\\n}\\r\\nif (s->cert->dh_tmp != NULL)\\r\\nDH_free(s->cert->dh_tmp);\\r\\ns->cert->dh_tmp = dh;\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (ret);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_TMP_ECDH:\\r\\n{\\r\\nEC_KEY *ecdh = NULL;\\r\\nif (parg == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (ret);\\r\\n}\\r\\nif (!EC_KEY_up_ref((EC_KEY *)parg)) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_ECDH_LIB);\\r\\nreturn (ret);\\r\\n}\\r\\necdh = (EC_KEY *)parg;\\r\\nif (!(s->options & SSL_OP_SINGLE_ECDH_USE)) {\\r\\nif (!EC_KEY_generate_key(ecdh)) {\\r\\nEC_KEY_free(ecdh);\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_ECDH_LIB);\\r\\nreturn (ret);\\r\\n}\\r\\n}\\r\\nif (s->cert->ecdh_tmp != NULL)\\r\\nEC_KEY_free(s->cert->ecdh_tmp);\\r\\ns->cert->ecdh_tmp = ecdh;\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TMP_ECDH_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (ret);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\ncase SSL_CTRL_SET_TLSEXT_HOSTNAME:\\r\\nif (larg == TLSEXT_NAMETYPE_host_name) {\\r\\nif (s->tlsext_hostname != NULL)\\r\\nOPENSSL_free(s->tlsext_hostname);\\r\\ns->tlsext_hostname = NULL;\\r\\nret = 1;\\r\\nif (parg == NULL)\\r\\nbreak;\\r\\nif (strlen((char *)parg) > TLSEXT_MAXLEN_host_name) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME);\\r\\nreturn 0;\\r\\n}\\r\\nif ((s->tlsext_hostname = BUF_strdup((char *)parg)) == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n} else {\\r\\nSSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TLSEXT_DEBUG_ARG:\\r\\ns->tlsext_debug_arg = parg;\\r\\nret = 1;\\r\\nbreak;\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\ncase SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT:\\r\\nif (larg > 12288) {\\r\\nSSLerr(SSL_F_SSL3_CTRL, SSL_R_OPAQUE_PRF_INPUT_TOO_LONG);\\r\\nbreak;\\r\\n}\\r\\nif (s->tlsext_opaque_prf_input != NULL)\\r\\nOPENSSL_free(s->tlsext_opaque_prf_input);\\r\\nif ((size_t)larg == 0)\\r\\ns->tlsext_opaque_prf_input = OPENSSL_malloc(1);\\r\\nelse\\r\\ns->tlsext_opaque_prf_input = BUF_memdup(parg, (size_t)larg);\\r\\nif (s->tlsext_opaque_prf_input != NULL) {\\r\\ns->tlsext_opaque_prf_input_len = (size_t)larg;\\r\\nret = 1;\\r\\n} else\\r\\ns->tlsext_opaque_prf_input_len = 0;\\r\\nbreak;\\r\\n# endif\\r\\ncase SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE:\\r\\ns->tlsext_status_type = larg;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS:\\r\\n*(STACK_OF(X509_EXTENSION) **)parg = s->tlsext_ocsp_exts;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS:\\r\\ns->tlsext_ocsp_exts = parg;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS:\\r\\n*(STACK_OF(OCSP_RESPID) **)parg = s->tlsext_ocsp_ids;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS:\\r\\ns->tlsext_ocsp_ids = parg;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP:\\r\\n*(unsigned char **)parg = s->tlsext_ocsp_resp;\\r\\nreturn s->tlsext_ocsp_resplen;\\r\\ncase SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP:\\r\\nif (s->tlsext_ocsp_resp)\\r\\nOPENSSL_free(s->tlsext_ocsp_resp);\\r\\ns->tlsext_ocsp_resp = parg;\\r\\ns->tlsext_ocsp_resplen = larg;\\r\\nret = 1;\\r\\nbreak;\\r\\n# ifndef OPENSSL_NO_HEARTBEATS\\r\\ncase SSL_CTRL_TLS_EXT_SEND_HEARTBEAT:\\r\\nif (SSL_IS_DTLS(s))\\r\\nret = dtls1_heartbeat(s);\\r\\nelse\\r\\nret = tls1_heartbeat(s);\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING:\\r\\nret = s->tlsext_hb_pending;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS:\\r\\nif (larg)\\r\\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\\r\\nelse\\r\\ns->tlsext_heartbeat &= ~SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\\r\\nret = 1;\\r\\nbreak;\\r\\n# endif\\r\\n#endif\\r\\ncase SSL_CTRL_CHAIN:\\r\\nif (larg)\\r\\nreturn ssl_cert_set1_chain(s->cert, (STACK_OF(X509) *)parg);\\r\\nelse\\r\\nreturn ssl_cert_set0_chain(s->cert, (STACK_OF(X509) *)parg);\\r\\ncase SSL_CTRL_CHAIN_CERT:\\r\\nif (larg)\\r\\nreturn ssl_cert_add1_chain_cert(s->cert, (X509 *)parg);\\r\\nelse\\r\\nreturn ssl_cert_add0_chain_cert(s->cert, (X509 *)parg);\\r\\ncase SSL_CTRL_GET_CHAIN_CERTS:\\r\\n*(STACK_OF(X509) **)parg = s->cert->key->chain;\\r\\nbreak;\\r\\ncase SSL_CTRL_SELECT_CURRENT_CERT:\\r\\nreturn ssl_cert_select_current(s->cert, (X509 *)parg);\\r\\ncase SSL_CTRL_SET_CURRENT_CERT:\\r\\nif (larg == SSL_CERT_SET_SERVER) {\\r\\nCERT_PKEY *cpk;\\r\\nconst SSL_CIPHER *cipher;\\r\\nif (!s->server)\\r\\nreturn 0;\\r\\ncipher = s->s3->tmp.new_cipher;\\r\\nif (!cipher)\\r\\nreturn 0;\\r\\nif (cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\\r\\nreturn 2;\\r\\ncpk = ssl_get_server_send_pkey(s);\\r\\nif (!cpk)\\r\\nreturn 0;\\r\\ns->cert->key = cpk;\\r\\nreturn 1;\\r\\n}\\r\\nreturn ssl_cert_set_current(s->cert, larg);\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase SSL_CTRL_GET_CURVES:\\r\\n{\\r\\nunsigned char *clist;\\r\\nsize_t clistlen;\\r\\nif (!s->session)\\r\\nreturn 0;\\r\\nclist = s->session->tlsext_ellipticcurvelist;\\r\\nclistlen = s->session->tlsext_ellipticcurvelist_length / 2;\\r\\nif (parg) {\\r\\nsize_t i;\\r\\nint *cptr = parg;\\r\\nunsigned int cid, nid;\\r\\nfor (i = 0; i < clistlen; i++) {\\r\\nn2s(clist, cid);\\r\\nnid = tls1_ec_curve_id2nid(cid);\\r\\nif (nid != 0)\\r\\ncptr[i] = nid;\\r\\nelse\\r\\ncptr[i] = TLSEXT_nid_unknown | cid;\\r\\n}\\r\\n}\\r\\nreturn (int)clistlen;\\r\\n}\\r\\ncase SSL_CTRL_SET_CURVES:\\r\\nreturn tls1_set_curves(&s->tlsext_ellipticcurvelist,\\r\\n&s->tlsext_ellipticcurvelist_length,\\r\\nparg, larg);\\r\\ncase SSL_CTRL_SET_CURVES_LIST:\\r\\nreturn tls1_set_curves_list(&s->tlsext_ellipticcurvelist,\\r\\n&s->tlsext_ellipticcurvelist_length,\\r\\nparg);\\r\\ncase SSL_CTRL_GET_SHARED_CURVE:\\r\\nreturn tls1_shared_curve(s, larg);\\r\\n# ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_ECDH_AUTO:\\r\\ns->cert->ecdh_tmp_auto = larg;\\r\\nreturn 1;\\r\\n# endif\\r\\n#endif\\r\\ncase SSL_CTRL_SET_SIGALGS:\\r\\nreturn tls1_set_sigalgs(s->cert, parg, larg, 0);\\r\\ncase SSL_CTRL_SET_SIGALGS_LIST:\\r\\nreturn tls1_set_sigalgs_list(s->cert, parg, 0);\\r\\ncase SSL_CTRL_SET_CLIENT_SIGALGS:\\r\\nreturn tls1_set_sigalgs(s->cert, parg, larg, 1);\\r\\ncase SSL_CTRL_SET_CLIENT_SIGALGS_LIST:\\r\\nreturn tls1_set_sigalgs_list(s->cert, parg, 1);\\r\\ncase SSL_CTRL_GET_CLIENT_CERT_TYPES:\\r\\n{\\r\\nconst unsigned char **pctype = parg;\\r\\nif (s->server || !s->s3->tmp.cert_req)\\r\\nreturn 0;\\r\\nif (s->cert->ctypes) {\\r\\nif (pctype)\\r\\n*pctype = s->cert->ctypes;\\r\\nreturn (int)s->cert->ctype_num;\\r\\n}\\r\\nif (pctype)\\r\\n*pctype = (unsigned char *)s->s3->tmp.ctype;\\r\\nreturn s->s3->tmp.ctype_num;\\r\\n}\\r\\ncase SSL_CTRL_SET_CLIENT_CERT_TYPES:\\r\\nif (!s->server)\\r\\nreturn 0;\\r\\nreturn ssl3_set_req_cert_type(s->cert, parg, larg);\\r\\ncase SSL_CTRL_BUILD_CERT_CHAIN:\\r\\nreturn ssl_build_cert_chain(s->cert, s->ctx->cert_store, larg);\\r\\ncase SSL_CTRL_SET_VERIFY_CERT_STORE:\\r\\nreturn ssl_cert_set_cert_store(s->cert, parg, 0, larg);\\r\\ncase SSL_CTRL_SET_CHAIN_CERT_STORE:\\r\\nreturn ssl_cert_set_cert_store(s->cert, parg, 1, larg);\\r\\ncase SSL_CTRL_GET_PEER_SIGNATURE_NID:\\r\\nif (SSL_USE_SIGALGS(s)) {\\r\\nif (s->session && s->session->sess_cert) {\\r\\nconst EVP_MD *sig;\\r\\nsig = s->session->sess_cert->peer_key->digest;\\r\\nif (sig) {\\r\\n*(int *)parg = EVP_MD_type(sig);\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nelse\\r\\nreturn 0;\\r\\ncase SSL_CTRL_GET_SERVER_TMP_KEY:\\r\\nif (s->server || !s->session || !s->session->sess_cert)\\r\\nreturn 0;\\r\\nelse {\\r\\nSESS_CERT *sc;\\r\\nEVP_PKEY *ptmp;\\r\\nint rv = 0;\\r\\nsc = s->session->sess_cert;\\r\\n#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DH) && !defined(OPENSSL_NO_EC) && !defined(OPENSSL_NO_ECDH)\\r\\nif (!sc->peer_rsa_tmp && !sc->peer_dh_tmp && !sc->peer_ecdh_tmp)\\r\\nreturn 0;\\r\\n#endif\\r\\nptmp = EVP_PKEY_new();\\r\\nif (!ptmp)\\r\\nreturn 0;\\r\\nif (0) ;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nelse if (sc->peer_rsa_tmp)\\r\\nrv = EVP_PKEY_set1_RSA(ptmp, sc->peer_rsa_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nelse if (sc->peer_dh_tmp)\\r\\nrv = EVP_PKEY_set1_DH(ptmp, sc->peer_dh_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nelse if (sc->peer_ecdh_tmp)\\r\\nrv = EVP_PKEY_set1_EC_KEY(ptmp, sc->peer_ecdh_tmp);\\r\\n#endif\\r\\nif (rv) {\\r\\n*(EVP_PKEY **)parg = ptmp;\\r\\nreturn 1;\\r\\n}\\r\\nEVP_PKEY_free(ptmp);\\r\\nreturn 0;\\r\\n}\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase SSL_CTRL_GET_EC_POINT_FORMATS:\\r\\n{\\r\\nSSL_SESSION *sess = s->session;\\r\\nconst unsigned char **pformat = parg;\\r\\nif (!sess || !sess->tlsext_ecpointformatlist)\\r\\nreturn 0;\\r\\n*pformat = sess->tlsext_ecpointformatlist;\\r\\nreturn (int)sess->tlsext_ecpointformatlist_length;\\r\\n}\\r\\n#endif\\r\\ncase SSL_CTRL_CHECK_PROTO_VERSION:\\r\\nif (s->version == s->ctx->method->version)\\r\\nreturn 1;\\r\\nif (s->ctx->method->version == SSLv23_method()->version) {\\r\\n#if TLS_MAX_VERSION != TLS1_2_VERSION\\r\\n# error Code needs update for SSLv23_method() support beyond TLS1_2_VERSION.\\r\\n#endif\\r\\nif (!(s->options & SSL_OP_NO_TLSv1_2))\\r\\nreturn s->version == TLS1_2_VERSION;\\r\\nif (!(s->options & SSL_OP_NO_TLSv1_1))\\r\\nreturn s->version == TLS1_1_VERSION;\\r\\nif (!(s->options & SSL_OP_NO_TLSv1))\\r\\nreturn s->version == TLS1_VERSION;\\r\\nif (!(s->options & SSL_OP_NO_SSLv3))\\r\\nreturn s->version == SSL3_VERSION;\\r\\nif (!(s->options & SSL_OP_NO_SSLv2))\\r\\nreturn s->version == SSL2_VERSION;\\r\\n}\\r\\nreturn 0;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nlong ssl3_callback_ctrl(SSL *s, int cmd, void (*fp) (void))\\r\\n{\\r\\nint ret = 0;\\r\\n#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_RSA)\\r\\nif (\\r\\n# ifndef OPENSSL_NO_RSA\\r\\ncmd == SSL_CTRL_SET_TMP_RSA_CB ||\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DSA\\r\\ncmd == SSL_CTRL_SET_TMP_DH_CB ||\\r\\n# endif\\r\\n0) {\\r\\nif (!ssl_cert_inst(&s->cert)) {\\r\\nSSLerr(SSL_F_SSL3_CALLBACK_CTRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nswitch (cmd) {\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\n{\\r\\ns->cert->rsa_tmp_cb = (RSA *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\n{\\r\\ns->cert->dh_tmp_cb = (DH *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_TMP_ECDH_CB:\\r\\n{\\r\\ns->cert->ecdh_tmp_cb = (EC_KEY *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\ncase SSL_CTRL_SET_TLSEXT_DEBUG_CB:\\r\\ns->tlsext_debug_cb = (void (*)(SSL *, int, int,\\r\\nunsigned char *, int, void *))fp;\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nlong ssl3_ctx_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)\\r\\n{\\r\\nCERT *cert;\\r\\ncert = ctx->cert;\\r\\nswitch (cmd) {\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase SSL_CTRL_NEED_TMP_RSA:\\r\\nif ((cert->rsa_tmp == NULL) &&\\r\\n((cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||\\r\\n(EVP_PKEY_size(cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) >\\r\\n(512 / 8)))\\r\\n)\\r\\nreturn (1);\\r\\nelse\\r\\nreturn (0);\\r\\ncase SSL_CTRL_SET_TMP_RSA:\\r\\n{\\r\\nRSA *rsa;\\r\\nint i;\\r\\nrsa = (RSA *)parg;\\r\\ni = 1;\\r\\nif (rsa == NULL)\\r\\ni = 0;\\r\\nelse {\\r\\nif ((rsa = RSAPrivateKey_dup(rsa)) == NULL)\\r\\ni = 0;\\r\\n}\\r\\nif (!i) {\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_RSA_LIB);\\r\\nreturn (0);\\r\\n} else {\\r\\nif (cert->rsa_tmp != NULL)\\r\\nRSA_free(cert->rsa_tmp);\\r\\ncert->rsa_tmp = rsa;\\r\\nreturn (1);\\r\\n}\\r\\n}\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (0);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH:\\r\\n{\\r\\nDH *new = NULL, *dh;\\r\\ndh = (DH *)parg;\\r\\nif ((new = DHparams_dup(dh)) == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_DH_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(ctx->options & SSL_OP_SINGLE_DH_USE)) {\\r\\nif (!DH_generate_key(new)) {\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_DH_LIB);\\r\\nDH_free(new);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (cert->dh_tmp != NULL)\\r\\nDH_free(cert->dh_tmp);\\r\\ncert->dh_tmp = new;\\r\\nreturn 1;\\r\\n}\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (0);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_TMP_ECDH:\\r\\n{\\r\\nEC_KEY *ecdh = NULL;\\r\\nif (parg == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_ECDH_LIB);\\r\\nreturn 0;\\r\\n}\\r\\necdh = EC_KEY_dup((EC_KEY *)parg);\\r\\nif (ecdh == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(ctx->options & SSL_OP_SINGLE_ECDH_USE)) {\\r\\nif (!EC_KEY_generate_key(ecdh)) {\\r\\nEC_KEY_free(ecdh);\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_ECDH_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (cert->ecdh_tmp != NULL) {\\r\\nEC_KEY_free(cert->ecdh_tmp);\\r\\n}\\r\\ncert->ecdh_tmp = ecdh;\\r\\nreturn 1;\\r\\n}\\r\\ncase SSL_CTRL_SET_TMP_ECDH_CB:\\r\\n{\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (0);\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\ncase SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG:\\r\\nctx->tlsext_servername_arg = parg;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TLSEXT_TICKET_KEYS:\\r\\ncase SSL_CTRL_GET_TLSEXT_TICKET_KEYS:\\r\\n{\\r\\nunsigned char *keys = parg;\\r\\nif (!keys)\\r\\nreturn 48;\\r\\nif (larg != 48) {\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, SSL_R_INVALID_TICKET_KEYS_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\nif (cmd == SSL_CTRL_SET_TLSEXT_TICKET_KEYS) {\\r\\nmemcpy(ctx->tlsext_tick_key_name, keys, 16);\\r\\nmemcpy(ctx->tlsext_tick_hmac_key, keys + 16, 16);\\r\\nmemcpy(ctx->tlsext_tick_aes_key, keys + 32, 16);\\r\\n} else {\\r\\nmemcpy(keys, ctx->tlsext_tick_key_name, 16);\\r\\nmemcpy(keys + 16, ctx->tlsext_tick_hmac_key, 16);\\r\\nmemcpy(keys + 32, ctx->tlsext_tick_aes_key, 16);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\ncase SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG:\\r\\nctx->tlsext_opaque_prf_input_callback_arg = parg;\\r\\nreturn 1;\\r\\n# endif\\r\\ncase SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG:\\r\\nctx->tlsext_status_arg = parg;\\r\\nreturn 1;\\r\\nbreak;\\r\\n# ifndef OPENSSL_NO_SRP\\r\\ncase SSL_CTRL_SET_TLS_EXT_SRP_USERNAME:\\r\\nctx->srp_ctx.srp_Mask |= SSL_kSRP;\\r\\nif (ctx->srp_ctx.login != NULL)\\r\\nOPENSSL_free(ctx->srp_ctx.login);\\r\\nctx->srp_ctx.login = NULL;\\r\\nif (parg == NULL)\\r\\nbreak;\\r\\nif (strlen((const char *)parg) > 255\\r\\n|| strlen((const char *)parg) < 1) {\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, SSL_R_INVALID_SRP_USERNAME);\\r\\nreturn 0;\\r\\n}\\r\\nif ((ctx->srp_ctx.login = BUF_strdup((char *)parg)) == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CTX_CTRL, ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD:\\r\\nctx->srp_ctx.SRP_give_srp_client_pwd_callback =\\r\\nsrp_password_from_info_cb;\\r\\nctx->srp_ctx.info = parg;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_SRP_ARG:\\r\\nctx->srp_ctx.srp_Mask |= SSL_kSRP;\\r\\nctx->srp_ctx.SRP_cb_arg = parg;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH:\\r\\nctx->srp_ctx.strength = larg;\\r\\nbreak;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_EC\\r\\ncase SSL_CTRL_SET_CURVES:\\r\\nreturn tls1_set_curves(&ctx->tlsext_ellipticcurvelist,\\r\\n&ctx->tlsext_ellipticcurvelist_length,\\r\\nparg, larg);\\r\\ncase SSL_CTRL_SET_CURVES_LIST:\\r\\nreturn tls1_set_curves_list(&ctx->tlsext_ellipticcurvelist,\\r\\n&ctx->tlsext_ellipticcurvelist_length,\\r\\nparg);\\r\\n# ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_ECDH_AUTO:\\r\\nctx->cert->ecdh_tmp_auto = larg;\\r\\nreturn 1;\\r\\n# endif\\r\\n# endif\\r\\ncase SSL_CTRL_SET_SIGALGS:\\r\\nreturn tls1_set_sigalgs(ctx->cert, parg, larg, 0);\\r\\ncase SSL_CTRL_SET_SIGALGS_LIST:\\r\\nreturn tls1_set_sigalgs_list(ctx->cert, parg, 0);\\r\\ncase SSL_CTRL_SET_CLIENT_SIGALGS:\\r\\nreturn tls1_set_sigalgs(ctx->cert, parg, larg, 1);\\r\\ncase SSL_CTRL_SET_CLIENT_SIGALGS_LIST:\\r\\nreturn tls1_set_sigalgs_list(ctx->cert, parg, 1);\\r\\ncase SSL_CTRL_SET_CLIENT_CERT_TYPES:\\r\\nreturn ssl3_set_req_cert_type(ctx->cert, parg, larg);\\r\\ncase SSL_CTRL_BUILD_CERT_CHAIN:\\r\\nreturn ssl_build_cert_chain(ctx->cert, ctx->cert_store, larg);\\r\\ncase SSL_CTRL_SET_VERIFY_CERT_STORE:\\r\\nreturn ssl_cert_set_cert_store(ctx->cert, parg, 0, larg);\\r\\ncase SSL_CTRL_SET_CHAIN_CERT_STORE:\\r\\nreturn ssl_cert_set_cert_store(ctx->cert, parg, 1, larg);\\r\\n#endif\\r\\ncase SSL_CTRL_EXTRA_CHAIN_CERT:\\r\\nif (ctx->extra_certs == NULL) {\\r\\nif ((ctx->extra_certs = sk_X509_new_null()) == NULL)\\r\\nreturn (0);\\r\\n}\\r\\nsk_X509_push(ctx->extra_certs, (X509 *)parg);\\r\\nbreak;\\r\\ncase SSL_CTRL_GET_EXTRA_CHAIN_CERTS:\\r\\nif (ctx->extra_certs == NULL && larg == 0)\\r\\n*(STACK_OF(X509) **)parg = ctx->cert->key->chain;\\r\\nelse\\r\\n*(STACK_OF(X509) **)parg = ctx->extra_certs;\\r\\nbreak;\\r\\ncase SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS:\\r\\nif (ctx->extra_certs) {\\r\\nsk_X509_pop_free(ctx->extra_certs, X509_free);\\r\\nctx->extra_certs = NULL;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_CTRL_CHAIN:\\r\\nif (larg)\\r\\nreturn ssl_cert_set1_chain(ctx->cert, (STACK_OF(X509) *)parg);\\r\\nelse\\r\\nreturn ssl_cert_set0_chain(ctx->cert, (STACK_OF(X509) *)parg);\\r\\ncase SSL_CTRL_CHAIN_CERT:\\r\\nif (larg)\\r\\nreturn ssl_cert_add1_chain_cert(ctx->cert, (X509 *)parg);\\r\\nelse\\r\\nreturn ssl_cert_add0_chain_cert(ctx->cert, (X509 *)parg);\\r\\ncase SSL_CTRL_GET_CHAIN_CERTS:\\r\\n*(STACK_OF(X509) **)parg = ctx->cert->key->chain;\\r\\nbreak;\\r\\ncase SSL_CTRL_SELECT_CURRENT_CERT:\\r\\nreturn ssl_cert_select_current(ctx->cert, (X509 *)parg);\\r\\ncase SSL_CTRL_SET_CURRENT_CERT:\\r\\nreturn ssl_cert_set_current(ctx->cert, larg);\\r\\ndefault:\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nlong ssl3_ctx_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp) (void))\\r\\n{\\r\\nCERT *cert;\\r\\ncert = ctx->cert;\\r\\nswitch (cmd) {\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase SSL_CTRL_SET_TMP_RSA_CB:\\r\\n{\\r\\ncert->rsa_tmp_cb = (RSA *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ncase SSL_CTRL_SET_TMP_DH_CB:\\r\\n{\\r\\ncert->dh_tmp_cb = (DH *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase SSL_CTRL_SET_TMP_ECDH_CB:\\r\\n{\\r\\ncert->ecdh_tmp_cb = (EC_KEY *(*)(SSL *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\ncase SSL_CTRL_SET_TLSEXT_SERVERNAME_CB:\\r\\nctx->tlsext_servername_callback = (int (*)(SSL *, int *, void *))fp;\\r\\nbreak;\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\ncase SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB:\\r\\nctx->tlsext_opaque_prf_input_callback =\\r\\n(int (*)(SSL *, void *, size_t, void *))fp;\\r\\nbreak;\\r\\n# endif\\r\\ncase SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB:\\r\\nctx->tlsext_status_cb = (int (*)(SSL *, void *))fp;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB:\\r\\nctx->tlsext_ticket_key_cb = (int (*)(SSL *, unsigned char *,\\r\\nunsigned char *,\\r\\nEVP_CIPHER_CTX *,\\r\\nHMAC_CTX *, int))fp;\\r\\nbreak;\\r\\n# ifndef OPENSSL_NO_SRP\\r\\ncase SSL_CTRL_SET_SRP_VERIFY_PARAM_CB:\\r\\nctx->srp_ctx.srp_Mask |= SSL_kSRP;\\r\\nctx->srp_ctx.SRP_verify_param_callback = (int (*)(SSL *, void *))fp;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB:\\r\\nctx->srp_ctx.srp_Mask |= SSL_kSRP;\\r\\nctx->srp_ctx.TLS_ext_srp_username_callback =\\r\\n(int (*)(SSL *, int *, void *))fp;\\r\\nbreak;\\r\\ncase SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB:\\r\\nctx->srp_ctx.srp_Mask |= SSL_kSRP;\\r\\nctx->srp_ctx.SRP_give_srp_client_pwd_callback =\\r\\n(char *(*)(SSL *, void *))fp;\\r\\nbreak;\\r\\n# endif\\r\\n#endif\\r\\ndefault:\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nconst SSL_CIPHER *ssl3_get_cipher_by_char(const unsigned char *p)\\r\\n{\\r\\nSSL_CIPHER c;\\r\\nconst SSL_CIPHER *cp;\\r\\nunsigned long id;\\r\\nid = 0x03000000L | ((unsigned long)p[0] << 8L) | (unsigned long)p[1];\\r\\nc.id = id;\\r\\ncp = OBJ_bsearch_ssl_cipher_id(&c, ssl3_ciphers, SSL3_NUM_CIPHERS);\\r\\n#ifdef DEBUG_PRINT_UNKNOWN_CIPHERSUITES\\r\\nif (cp == NULL)\\r\\nfprintf(stderr, \"Unknown cipher ID %x\\n\", (p[0] << 8) | p[1]);\\r\\n#endif\\r\\nreturn cp;\\r\\n}\\r\\nint ssl3_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)\\r\\n{\\r\\nlong l;\\r\\nif (p != NULL) {\\r\\nl = c->id;\\r\\nif ((l & 0xff000000) != 0x03000000)\\r\\nreturn (0);\\r\\np[0] = ((unsigned char)(l >> 8L)) & 0xFF;\\r\\np[1] = ((unsigned char)(l)) & 0xFF;\\r\\n}\\r\\nreturn (2);\\r\\n}\\r\\nint ssl3_get_req_cert_type(SSL *s, unsigned char *p)\\r\\n{\\r\\nint ret = 0;\\r\\nconst unsigned char *sig;\\r\\nsize_t i, siglen;\\r\\nint have_rsa_sign = 0, have_dsa_sign = 0;\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nint have_ecdsa_sign = 0;\\r\\n#endif\\r\\nint nostrict = 1;\\r\\nunsigned long alg_k;\\r\\nif (s->cert->ctypes) {\\r\\nmemcpy(p, s->cert->ctypes, s->cert->ctype_num);\\r\\nreturn (int)s->cert->ctype_num;\\r\\n}\\r\\nsiglen = tls12_get_psigalgs(s, &sig);\\r\\nif (s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)\\r\\nnostrict = 0;\\r\\nfor (i = 0; i < siglen; i += 2, sig += 2) {\\r\\nswitch (sig[1]) {\\r\\ncase TLSEXT_signature_rsa:\\r\\nhave_rsa_sign = 1;\\r\\nbreak;\\r\\ncase TLSEXT_signature_dsa:\\r\\nhave_dsa_sign = 1;\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\ncase TLSEXT_signature_ecdsa:\\r\\nhave_ecdsa_sign = 1;\\r\\nbreak;\\r\\n#endif\\r\\n}\\r\\n}\\r\\nalg_k = s->s3->tmp.new_cipher->algorithm_mkey;\\r\\n#ifndef OPENSSL_NO_GOST\\r\\nif (s->version >= TLS1_VERSION) {\\r\\nif (alg_k & SSL_kGOST) {\\r\\np[ret++] = TLS_CT_GOST94_SIGN;\\r\\np[ret++] = TLS_CT_GOST01_SIGN;\\r\\nreturn (ret);\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (alg_k & (SSL_kDHr | SSL_kEDH)) {\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nif (nostrict || have_rsa_sign)\\r\\np[ret++] = SSL3_CT_RSA_FIXED_DH;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nif (nostrict || have_dsa_sign)\\r\\np[ret++] = SSL3_CT_DSS_FIXED_DH;\\r\\n# endif\\r\\n}\\r\\nif ((s->version == SSL3_VERSION) &&\\r\\n(alg_k & (SSL_kEDH | SSL_kDHd | SSL_kDHr))) {\\r\\n# ifndef OPENSSL_NO_RSA\\r\\np[ret++] = SSL3_CT_RSA_EPHEMERAL_DH;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DSA\\r\\np[ret++] = SSL3_CT_DSS_EPHEMERAL_DH;\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (have_rsa_sign)\\r\\np[ret++] = SSL3_CT_RSA_SIGN;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (have_dsa_sign)\\r\\np[ret++] = SSL3_CT_DSS_SIGN;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif ((alg_k & (SSL_kECDHr | SSL_kECDHe)) && (s->version >= TLS1_VERSION)) {\\r\\nif (nostrict || have_rsa_sign)\\r\\np[ret++] = TLS_CT_RSA_FIXED_ECDH;\\r\\nif (nostrict || have_ecdsa_sign)\\r\\np[ret++] = TLS_CT_ECDSA_FIXED_ECDH;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif (s->version >= TLS1_VERSION) {\\r\\nif (have_ecdsa_sign)\\r\\np[ret++] = TLS_CT_ECDSA_SIGN;\\r\\n}\\r\\n#endif\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ssl3_set_req_cert_type(CERT *c, const unsigned char *p, size_t len)\\r\\n{\\r\\nif (c->ctypes) {\\r\\nOPENSSL_free(c->ctypes);\\r\\nc->ctypes = NULL;\\r\\n}\\r\\nif (!p || !len)\\r\\nreturn 1;\\r\\nif (len > 0xff)\\r\\nreturn 0;\\r\\nc->ctypes = OPENSSL_malloc(len);\\r\\nif (!c->ctypes)\\r\\nreturn 0;\\r\\nmemcpy(c->ctypes, p, len);\\r\\nc->ctype_num = len;\\r\\nreturn 1;\\r\\n}\\r\\nint ssl3_shutdown(SSL *s)\\r\\n{\\r\\nint ret;\\r\\nif ((s->quiet_shutdown) || (s->state == SSL_ST_BEFORE)) {\\r\\ns->shutdown = (SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);\\r\\nreturn (1);\\r\\n}\\r\\nif (!(s->shutdown & SSL_SENT_SHUTDOWN)) {\\r\\ns->shutdown |= SSL_SENT_SHUTDOWN;\\r\\n#if 1\\r\\nssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_CLOSE_NOTIFY);\\r\\n#endif\\r\\nif (s->s3->alert_dispatch)\\r\\nreturn (-1);\\r\\n} else if (s->s3->alert_dispatch) {\\r\\n#if 1\\r\\nret = s->method->ssl_dispatch_alert(s);\\r\\nif (ret == -1) {\\r\\nreturn (ret);\\r\\n}\\r\\n#endif\\r\\n} else if (!(s->shutdown & SSL_RECEIVED_SHUTDOWN)) {\\r\\ns->method->ssl_read_bytes(s, 0, NULL, 0, 0);\\r\\nif (!(s->shutdown & SSL_RECEIVED_SHUTDOWN)) {\\r\\nreturn (-1);\\r\\n}\\r\\n}\\r\\nif ((s->shutdown == (SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN)) &&\\r\\n!s->s3->alert_dispatch)\\r\\nreturn (1);\\r\\nelse\\r\\nreturn (0);\\r\\n}\\r\\nint ssl3_write(SSL *s, const void *buf, int len)\\r\\n{\\r\\nint ret, n;\\r\\n#if 0\\r\\nif (s->shutdown & SSL_SEND_SHUTDOWN) {\\r\\ns->rwstate = SSL_NOTHING;\\r\\nreturn (0);\\r\\n}\\r\\n#endif\\r\\nclear_sys_error();\\r\\nif (s->s3->renegotiate)\\r\\nssl3_renegotiate_check(s);\\r\\nif ((s->s3->flags & SSL3_FLAGS_POP_BUFFER) && (s->wbio == s->bbio)) {\\r\\nif (s->s3->delay_buf_pop_ret == 0) {\\r\\nret = ssl3_write_bytes(s, SSL3_RT_APPLICATION_DATA, buf, len);\\r\\nif (ret <= 0)\\r\\nreturn (ret);\\r\\ns->s3->delay_buf_pop_ret = ret;\\r\\n}\\r\\ns->rwstate = SSL_WRITING;\\r\\nn = BIO_flush(s->wbio);\\r\\nif (n <= 0)\\r\\nreturn (n);\\r\\ns->rwstate = SSL_NOTHING;\\r\\nssl_free_wbio_buffer(s);\\r\\ns->s3->flags &= ~SSL3_FLAGS_POP_BUFFER;\\r\\nret = s->s3->delay_buf_pop_ret;\\r\\ns->s3->delay_buf_pop_ret = 0;\\r\\n} else {\\r\\nret = s->method->ssl_write_bytes(s, SSL3_RT_APPLICATION_DATA,\\r\\nbuf, len);\\r\\nif (ret <= 0)\\r\\nreturn (ret);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ssl3_read_internal(SSL *s, void *buf, int len, int peek)\\r\\n{\\r\\nint ret;\\r\\nclear_sys_error();\\r\\nif (s->s3->renegotiate)\\r\\nssl3_renegotiate_check(s);\\r\\ns->s3->in_read_app_data = 1;\\r\\nret =\\r\\ns->method->ssl_read_bytes(s, SSL3_RT_APPLICATION_DATA, buf, len,\\r\\npeek);\\r\\nif ((ret == -1) && (s->s3->in_read_app_data == 2)) {\\r\\ns->in_handshake++;\\r\\nret =\\r\\ns->method->ssl_read_bytes(s, SSL3_RT_APPLICATION_DATA, buf, len,\\r\\npeek);\\r\\ns->in_handshake--;\\r\\n} else\\r\\ns->s3->in_read_app_data = 0;\\r\\nreturn (ret);\\r\\n}\\r\\nint ssl3_read(SSL *s, void *buf, int len)\\r\\n{\\r\\nreturn ssl3_read_internal(s, buf, len, 0);\\r\\n}\\r\\nint ssl3_peek(SSL *s, void *buf, int len)\\r\\n{\\r\\nreturn ssl3_read_internal(s, buf, len, 1);\\r\\n}\\r\\nint ssl3_renegotiate(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == NULL)\\r\\nreturn (1);\\r\\nif (s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)\\r\\nreturn (0);\\r\\ns->s3->renegotiate = 1;\\r\\nreturn (1);\\r\\n}\\r\\nint ssl3_renegotiate_check(SSL *s)\\r\\n{\\r\\nint ret = 0;\\r\\nif (s->s3->renegotiate) {\\r\\nif ((s->s3->rbuf.left == 0) &&\\r\\n(s->s3->wbuf.left == 0) && !SSL_in_init(s)) {\\r\\ns->state = SSL_ST_RENEGOTIATE;\\r\\ns->s3->renegotiate = 0;\\r\\ns->s3->num_renegotiations++;\\r\\ns->s3->total_renegotiations++;\\r\\nret = 1;\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nlong ssl_get_algorithm2(SSL *s)\\r\\n{\\r\\nlong alg2 = s->s3->tmp.new_cipher->algorithm2;\\r\\nif (s->method->ssl3_enc->enc_flags & SSL_ENC_FLAG_SHA256_PRF\\r\\n&& alg2 == (SSL_HANDSHAKE_MAC_DEFAULT | TLS1_PRF))\\r\\nreturn SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\\r\\nreturn alg2;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_list_c", "target": 0, "func": "static void engine_list_cleanup(void)\\r\\n{\\r\\nENGINE *iterator = engine_list_head;\\r\\nwhile (iterator != NULL) {\\r\\nENGINE_remove(iterator);\\r\\niterator = engine_list_head;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nstatic int engine_list_add(ENGINE *e)\\r\\n{\\r\\nint conflict = 0;\\r\\nENGINE *iterator = NULL;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\niterator = engine_list_head;\\r\\nwhile (iterator && !conflict) {\\r\\nconflict = (strcmp(iterator->id, e->id) == 0);\\r\\niterator = iterator->next;\\r\\n}\\r\\nif (conflict) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nif (engine_list_head == NULL) {\\r\\nif (engine_list_tail) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nengine_list_head = e;\\r\\ne->prev = NULL;\\r\\nengine_cleanup_add_last(engine_list_cleanup);\\r\\n} else {\\r\\nif ((engine_list_tail == NULL) || (engine_list_tail->next != NULL)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nengine_list_tail->next = e;\\r\\ne->prev = engine_list_tail;\\r\\n}\\r\\ne->struct_ref++;\\r\\nengine_ref_debug(e, 0, 1)\\r\\nengine_list_tail = e;\\r\\ne->next = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int engine_list_remove(ENGINE *e)\\r\\n{\\r\\nENGINE *iterator;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_REMOVE, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\niterator = engine_list_head;\\r\\nwhile (iterator && (iterator != e))\\r\\niterator = iterator->next;\\r\\nif (iterator == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LIST_REMOVE,\\r\\nENGINE_R_ENGINE_IS_NOT_IN_LIST);\\r\\nreturn 0;\\r\\n}\\r\\nif (e->next)\\r\\ne->next->prev = e->prev;\\r\\nif (e->prev)\\r\\ne->prev->next = e->next;\\r\\nif (engine_list_head == e)\\r\\nengine_list_head = e->next;\\r\\nif (engine_list_tail == e)\\r\\nengine_list_tail = e->prev;\\r\\nengine_free_util(e, 0);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_first(void)\\r\\n{\\r\\nENGINE *ret;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = engine_list_head;\\r\\nif (ret) {\\r\\nret->struct_ref++;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn ret;\\r\\n}\\r\\nENGINE *ENGINE_get_last(void)\\r\\n{\\r\\nENGINE *ret;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = engine_list_tail;\\r\\nif (ret) {\\r\\nret->struct_ref++;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn ret;\\r\\n}\\r\\nENGINE *ENGINE_get_next(ENGINE *e)\\r\\n{\\r\\nENGINE *ret = NULL;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_NEXT, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = e->next;\\r\\nif (ret) {\\r\\nret->struct_ref++;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nENGINE_free(e);\\r\\nreturn ret;\\r\\n}\\r\\nENGINE *ENGINE_get_prev(ENGINE *e)\\r\\n{\\r\\nENGINE *ret = NULL;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_PREV, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = e->prev;\\r\\nif (ret) {\\r\\nret->struct_ref++;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nENGINE_free(e);\\r\\nreturn ret;\\r\\n}\\r\\nint ENGINE_add(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_ADD, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif ((e->id == NULL) || (e->name == NULL)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_ID_OR_NAME_MISSING);\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (!engine_list_add(e)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_INTERNAL_LIST_ERROR);\\r\\nto_return = 0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn to_return;\\r\\n}\\r\\nint ENGINE_remove(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_REMOVE, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (!engine_list_remove(e)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_REMOVE, ENGINE_R_INTERNAL_LIST_ERROR);\\r\\nto_return = 0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn to_return;\\r\\n}\\r\\nstatic void engine_cpy(ENGINE *dest, const ENGINE *src)\\r\\n{\\r\\ndest->id = src->id;\\r\\ndest->name = src->name;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ndest->rsa_meth = src->rsa_meth;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ndest->dsa_meth = src->dsa_meth;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ndest->dh_meth = src->dh_meth;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ndest->ecdh_meth = src->ecdh_meth;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\ndest->ecdsa_meth = src->ecdsa_meth;\\r\\n#endif\\r\\ndest->rand_meth = src->rand_meth;\\r\\ndest->store_meth = src->store_meth;\\r\\ndest->ciphers = src->ciphers;\\r\\ndest->digests = src->digests;\\r\\ndest->pkey_meths = src->pkey_meths;\\r\\ndest->destroy = src->destroy;\\r\\ndest->init = src->init;\\r\\ndest->finish = src->finish;\\r\\ndest->ctrl = src->ctrl;\\r\\ndest->load_privkey = src->load_privkey;\\r\\ndest->load_pubkey = src->load_pubkey;\\r\\ndest->cmd_defns = src->cmd_defns;\\r\\ndest->flags = src->flags;\\r\\n}\\r\\nENGINE *ENGINE_by_id(const char *id)\\r\\n{\\r\\nENGINE *iterator;\\r\\nchar *load_dir = NULL;\\r\\nif (id == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_BY_ID, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\niterator = engine_list_head;\\r\\nwhile (iterator && (strcmp(id, iterator->id) != 0))\\r\\niterator = iterator->next;\\r\\nif (iterator) {\\r\\nif (iterator->flags & ENGINE_FLAGS_BY_ID_COPY) {\\r\\nENGINE *cp = ENGINE_new();\\r\\nif (!cp)\\r\\niterator = NULL;\\r\\nelse {\\r\\nengine_cpy(cp, iterator);\\r\\niterator = cp;\\r\\n}\\r\\n} else {\\r\\niterator->struct_ref++;\\r\\nengine_ref_debug(iterator, 0, 1)\\r\\n}\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\n#if 0\\r\\nif (iterator == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_BY_ID, ENGINE_R_NO_SUCH_ENGINE);\\r\\nERR_add_error_data(2, \"id=\", id);\\r\\n}\\r\\nreturn iterator;\\r\\n#else\\r\\nif (iterator)\\r\\nreturn iterator;\\r\\nif (strcmp(id, \"dynamic\")) {\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\nif ((load_dir = getenv(\"OPENSSL_ENGINES\")) == 0)\\r\\nload_dir = \"SSLROOT:[ENGINES]\";\\r\\n# else\\r\\nif ((load_dir = getenv(\"OPENSSL_ENGINES\")) == 0)\\r\\nload_dir = ENGINESDIR;\\r\\n# endif\\r\\niterator = ENGINE_by_id(\"dynamic\");\\r\\nif (!iterator || !ENGINE_ctrl_cmd_string(iterator, \"ID\", id, 0) ||\\r\\n!ENGINE_ctrl_cmd_string(iterator, \"DIR_LOAD\", \"2\", 0) ||\\r\\n!ENGINE_ctrl_cmd_string(iterator, \"DIR_ADD\",\\r\\nload_dir, 0) ||\\r\\n!ENGINE_ctrl_cmd_string(iterator, \"LIST_ADD\", \"1\", 0) ||\\r\\n!ENGINE_ctrl_cmd_string(iterator, \"LOAD\", NULL, 0))\\r\\ngoto notfound;\\r\\nreturn iterator;\\r\\n}\\r\\nnotfound:\\r\\nENGINE_free(iterator);\\r\\nENGINEerr(ENGINE_F_ENGINE_BY_ID, ENGINE_R_NO_SUCH_ENGINE);\\r\\nERR_add_error_data(2, \"id=\", id);\\r\\nreturn NULL;\\r\\n#endif\\r\\n}\\r\\nint ENGINE_up_ref(ENGINE *e)\\r\\n{\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_UP_REF, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_add(&e->struct_ref, 1, CRYPTO_LOCK_ENGINE);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_asn1_c", "target": 0, "func": "static int sig_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nif (operation == ASN1_OP_NEW_PRE) {\\r\\nDSA_SIG *sig;\\r\\nsig = OPENSSL_malloc(sizeof(DSA_SIG));\\r\\nif (!sig) {\\r\\nDSAerr(DSA_F_SIG_CB, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nsig->r = NULL;\\r\\nsig->s = NULL;\\r\\n*pval = (ASN1_VALUE *)sig;\\r\\nreturn 2;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint DSA_sign(int type, const unsigned char *dgst, int dlen,\\r\\nunsigned char *sig, unsigned int *siglen, DSA *dsa)\\r\\n{\\r\\nDSA_SIG *s;\\r\\nRAND_seed(dgst, dlen);\\r\\ns = DSA_do_sign(dgst, dlen, dsa);\\r\\nif (s == NULL) {\\r\\n*siglen = 0;\\r\\nreturn (0);\\r\\n}\\r\\n*siglen = i2d_DSA_SIG(s, &sig);\\r\\nDSA_SIG_free(s);\\r\\nreturn (1);\\r\\n}\\r\\nint DSA_verify(int type, const unsigned char *dgst, int dgst_len,\\r\\nconst unsigned char *sigbuf, int siglen, DSA *dsa)\\r\\n{\\r\\nDSA_SIG *s;\\r\\nconst unsigned char *p = sigbuf;\\r\\nunsigned char *der = NULL;\\r\\nint derlen = -1;\\r\\nint ret = -1;\\r\\ns = DSA_SIG_new();\\r\\nif (s == NULL)\\r\\nreturn (ret);\\r\\nif (d2i_DSA_SIG(&s, &p, siglen) == NULL)\\r\\ngoto err;\\r\\nderlen = i2d_DSA_SIG(s, &der);\\r\\nif (derlen != siglen || memcmp(sigbuf, der, derlen))\\r\\ngoto err;\\r\\nret = DSA_do_verify(dgst, dgst_len, s, dsa);\\r\\nerr:\\r\\nif (derlen > 0) {\\r\\nOPENSSL_cleanse(der, derlen);\\r\\nOPENSSL_free(der);\\r\\n}\\r\\nDSA_SIG_free(s);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc5cfb64_c", "target": 0, "func": "void RC5_32_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC5_32_KEY *schedule,\\r\\nunsigned char *ivec, int *num, int encrypt)\\r\\n{\\r\\nregister unsigned long v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv, c, cc;\\r\\niv = (unsigned char *)ivec;\\r\\nif (encrypt) {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nc2l(iv, v0);\\r\\nti[0] = v0;\\r\\nc2l(iv, v1);\\r\\nti[1] = v1;\\r\\nRC5_32_encrypt((unsigned long *)ti, schedule);\\r\\niv = (unsigned char *)ivec;\\r\\nt = ti[0];\\r\\nl2c(t, iv);\\r\\nt = ti[1];\\r\\nl2c(t, iv);\\r\\niv = (unsigned char *)ivec;\\r\\n}\\r\\nc = *(in++) ^ iv[n];\\r\\n*(out++) = c;\\r\\niv[n] = c;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n} else {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nc2l(iv, v0);\\r\\nti[0] = v0;\\r\\nc2l(iv, v1);\\r\\nti[1] = v1;\\r\\nRC5_32_encrypt((unsigned long *)ti, schedule);\\r\\niv = (unsigned char *)ivec;\\r\\nt = ti[0];\\r\\nl2c(t, iv);\\r\\nt = ti[1];\\r\\nl2c(t, iv);\\r\\niv = (unsigned char *)ivec;\\r\\n}\\r\\ncc = *(in++);\\r\\nc = iv[n];\\r\\niv[n] = cc;\\r\\n*(out++) = c ^ cc;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n}\\r\\nv0 = v1 = ti[0] = ti[1] = t = c = cc = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_strnid_c", "target": 0, "func": "void ASN1_STRING_set_default_mask(unsigned long mask)\\r\\n{\\r\\nglobal_mask = mask;\\r\\n}\\r\\nunsigned long ASN1_STRING_get_default_mask(void)\\r\\n{\\r\\nreturn global_mask;\\r\\n}\\r\\nint ASN1_STRING_set_default_mask_asc(const char *p)\\r\\n{\\r\\nunsigned long mask;\\r\\nchar *end;\\r\\nif (!strncmp(p, \"MASK:\", 5)) {\\r\\nif (!p[5])\\r\\nreturn 0;\\r\\nmask = strtoul(p + 5, &end, 0);\\r\\nif (*end)\\r\\nreturn 0;\\r\\n} else if (!strcmp(p, \"nombstr\"))\\r\\nmask = ~((unsigned long)(B_ASN1_BMPSTRING | B_ASN1_UTF8STRING));\\r\\nelse if (!strcmp(p, \"pkix\"))\\r\\nmask = ~((unsigned long)B_ASN1_T61STRING);\\r\\nelse if (!strcmp(p, \"utf8only\"))\\r\\nmask = B_ASN1_UTF8STRING;\\r\\nelse if (!strcmp(p, \"default\"))\\r\\nmask = 0xFFFFFFFFL;\\r\\nelse\\r\\nreturn 0;\\r\\nASN1_STRING_set_default_mask(mask);\\r\\nreturn 1;\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out,\\r\\nconst unsigned char *in, int inlen,\\r\\nint inform, int nid)\\r\\n{\\r\\nASN1_STRING_TABLE *tbl;\\r\\nASN1_STRING *str = NULL;\\r\\nunsigned long mask;\\r\\nint ret;\\r\\nif (!out)\\r\\nout = &str;\\r\\ntbl = ASN1_STRING_TABLE_get(nid);\\r\\nif (tbl) {\\r\\nmask = tbl->mask;\\r\\nif (!(tbl->flags & STABLE_NO_MASK))\\r\\nmask &= global_mask;\\r\\nret = ASN1_mbstring_ncopy(out, in, inlen, inform, mask,\\r\\ntbl->minsize, tbl->maxsize);\\r\\n} else\\r\\nret =\\r\\nASN1_mbstring_copy(out, in, inlen, inform,\\r\\nDIRSTRING_TYPE & global_mask);\\r\\nif (ret <= 0)\\r\\nreturn NULL;\\r\\nreturn *out;\\r\\n}\\r\\nstatic int sk_table_cmp(const ASN1_STRING_TABLE *const *a,\\r\\nconst ASN1_STRING_TABLE *const *b)\\r\\n{\\r\\nreturn (*a)->nid - (*b)->nid;\\r\\n}\\r\\nstatic int table_cmp(const ASN1_STRING_TABLE *a, const ASN1_STRING_TABLE *b)\\r\\n{\\r\\nreturn a->nid - b->nid;\\r\\n}\\r\\nASN1_STRING_TABLE *ASN1_STRING_TABLE_get(int nid)\\r\\n{\\r\\nint idx;\\r\\nASN1_STRING_TABLE *ttmp;\\r\\nASN1_STRING_TABLE fnd;\\r\\nfnd.nid = nid;\\r\\nttmp = OBJ_bsearch_table(&fnd, tbl_standard,\\r\\nsizeof(tbl_standard) /\\r\\nsizeof(ASN1_STRING_TABLE));\\r\\nif (ttmp)\\r\\nreturn ttmp;\\r\\nif (!stable)\\r\\nreturn NULL;\\r\\nidx = sk_ASN1_STRING_TABLE_find(stable, &fnd);\\r\\nif (idx < 0)\\r\\nreturn NULL;\\r\\nreturn sk_ASN1_STRING_TABLE_value(stable, idx);\\r\\n}\\r\\nint ASN1_STRING_TABLE_add(int nid,\\r\\nlong minsize, long maxsize, unsigned long mask,\\r\\nunsigned long flags)\\r\\n{\\r\\nASN1_STRING_TABLE *tmp;\\r\\nchar new_nid = 0;\\r\\nflags &= ~STABLE_FLAGS_MALLOC;\\r\\nif (!stable)\\r\\nstable = sk_ASN1_STRING_TABLE_new(sk_table_cmp);\\r\\nif (!stable) {\\r\\nASN1err(ASN1_F_ASN1_STRING_TABLE_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(tmp = ASN1_STRING_TABLE_get(nid))) {\\r\\ntmp = OPENSSL_malloc(sizeof(ASN1_STRING_TABLE));\\r\\nif (!tmp) {\\r\\nASN1err(ASN1_F_ASN1_STRING_TABLE_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ntmp->flags = flags | STABLE_FLAGS_MALLOC;\\r\\ntmp->nid = nid;\\r\\nnew_nid = 1;\\r\\n} else\\r\\ntmp->flags = (tmp->flags & STABLE_FLAGS_MALLOC) | flags;\\r\\nif (minsize != -1)\\r\\ntmp->minsize = minsize;\\r\\nif (maxsize != -1)\\r\\ntmp->maxsize = maxsize;\\r\\ntmp->mask = mask;\\r\\nif (new_nid)\\r\\nsk_ASN1_STRING_TABLE_push(stable, tmp);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ASN1_STRING_TABLE_cleanup(void)\\r\\n{\\r\\nSTACK_OF(ASN1_STRING_TABLE) *tmp;\\r\\ntmp = stable;\\r\\nif (!tmp)\\r\\nreturn;\\r\\nstable = NULL;\\r\\nsk_ASN1_STRING_TABLE_pop_free(tmp, st_free);\\r\\n}\\r\\nstatic void st_free(ASN1_STRING_TABLE *tbl)\\r\\n{\\r\\nif (tbl->flags & STABLE_FLAGS_MALLOC)\\r\\nOPENSSL_free(tbl);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cfb64ede_c", "target": 0, "func": "void DES_ede3_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2, DES_key_schedule *ks3,\\r\\nDES_cblock *ivec, int *num, int enc)\\r\\n{\\r\\nregister DES_LONG v0, v1;\\r\\nregister long l = length;\\r\\nregister int n = *num;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv, c, cc;\\r\\niv = &(*ivec)[0];\\r\\nif (enc) {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\nDES_encrypt3(ti, ks1, ks2, ks3);\\r\\nv0 = ti[0];\\r\\nv1 = ti[1];\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\nc = *(in++) ^ iv[n];\\r\\n*(out++) = c;\\r\\niv[n] = c;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n} else {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\nDES_encrypt3(ti, ks1, ks2, ks3);\\r\\nv0 = ti[0];\\r\\nv1 = ti[1];\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\ncc = *(in++);\\r\\nc = iv[n];\\r\\niv[n] = cc;\\r\\n*(out++) = c ^ cc;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n}\\r\\nv0 = v1 = ti[0] = ti[1] = c = cc = 0;\\r\\n*num = n;\\r\\n}\\r\\nvoid DES_ede3_cfb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nint numbits, long length, DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2, DES_key_schedule *ks3,\\r\\nDES_cblock *ivec, int enc)\\r\\n{\\r\\nregister DES_LONG d0, d1, v0, v1;\\r\\nregister unsigned long l = length, n = ((unsigned int)numbits + 7) / 8;\\r\\nregister int num = numbits, i;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nunsigned char ovec[16];\\r\\nif (num > 64)\\r\\nreturn;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\nif (enc) {\\r\\nwhile (l >= n) {\\r\\nl -= n;\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\nDES_encrypt3(ti, ks1, ks2, ks3);\\r\\nc2ln(in, d0, d1, n);\\r\\nin += n;\\r\\nd0 ^= ti[0];\\r\\nd1 ^= ti[1];\\r\\nl2cn(d0, d1, out, n);\\r\\nout += n;\\r\\nif (num == 32) {\\r\\nv0 = v1;\\r\\nv1 = d0;\\r\\n} else if (num == 64) {\\r\\nv0 = d0;\\r\\nv1 = d1;\\r\\n} else {\\r\\niv = &ovec[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\nl2c(d0, iv);\\r\\nl2c(d1, iv);\\r\\nmemmove(ovec, ovec + num / 8, 8 + (num % 8 ? 1 : 0));\\r\\nif (num % 8 != 0)\\r\\nfor (i = 0; i < 8; ++i) {\\r\\novec[i] <<= num % 8;\\r\\novec[i] |= ovec[i + 1] >> (8 - num % 8);\\r\\n}\\r\\niv = &ovec[0];\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\n}\\r\\n}\\r\\n} else {\\r\\nwhile (l >= n) {\\r\\nl -= n;\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\nDES_encrypt3(ti, ks1, ks2, ks3);\\r\\nc2ln(in, d0, d1, n);\\r\\nin += n;\\r\\nif (num == 32) {\\r\\nv0 = v1;\\r\\nv1 = d0;\\r\\n} else if (num == 64) {\\r\\nv0 = d0;\\r\\nv1 = d1;\\r\\n} else {\\r\\niv = &ovec[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\nl2c(d0, iv);\\r\\nl2c(d1, iv);\\r\\nmemmove(ovec, ovec + num / 8, 8 + (num % 8 ? 1 : 0));\\r\\nif (num % 8 != 0)\\r\\nfor (i = 0; i < 8; ++i) {\\r\\novec[i] <<= num % 8;\\r\\novec[i] |= ovec[i + 1] >> (8 - num % 8);\\r\\n}\\r\\niv = &ovec[0];\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\n}\\r\\nd0 ^= ti[0];\\r\\nd1 ^= ti[1];\\r\\nl2cn(d0, d1, out, n);\\r\\nout += n;\\r\\n}\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\nv0 = v1 = d0 = d1 = ti[0] = ti[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_speed_c", "target": 0, "func": "SIGRETTYPE sig_done(int sig)\\r\\n{\\r\\nsignal(SIGALRM, sig_done);\\r\\nrun = 0;\\r\\n# ifdef LINT\\r\\nsig = sig;\\r\\n# endif\\r\\n}\\r\\ndouble Time_F(int s)\\r\\n{\\r\\ndouble ret;\\r\\n#ifdef TIMES\\r\\nstatic struct tms tstart, tend;\\r\\nif (s == START) {\\r\\ntimes(&tstart);\\r\\nreturn (0);\\r\\n} else {\\r\\ntimes(&tend);\\r\\nret = ((double)(tend.tms_utime - tstart.tms_utime)) / HZ;\\r\\nreturn ((ret == 0.0) ? 1e-6 : ret);\\r\\n}\\r\\n#else\\r\\nstatic struct timeb tstart, tend;\\r\\nlong i;\\r\\nif (s == START) {\\r\\nftime(&tstart);\\r\\nreturn (0);\\r\\n} else {\\r\\nftime(&tend);\\r\\ni = (long)tend.millitm - (long)tstart.millitm;\\r\\nret = ((double)(tend.time - tstart.time)) + ((double)i) / 1e3;\\r\\nreturn ((ret == 0.0) ? 1e-6 : ret);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong count;\\r\\nstatic unsigned char buf[BUFSIZE];\\r\\nstatic DES_cblock key =\\r\\n{ 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0 };\\r\\nstatic DES_cblock key2 =\\r\\n{ 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12 };\\r\\nstatic DES_cblock key3 =\\r\\n{ 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34 };\\r\\nDES_key_schedule sch, sch2, sch3;\\r\\ndouble a, b, c, d, e;\\r\\n#ifndef SIGALRM\\r\\nlong ca, cb, cc, cd, ce;\\r\\n#endif\\r\\n#ifndef TIMES\\r\\nprintf(\"To get the most accurate results, try to run this\\n\");\\r\\nprintf(\"program when this computer is idle.\\n\");\\r\\n#endif\\r\\nDES_set_key_unchecked(&key2, &sch2);\\r\\nDES_set_key_unchecked(&key3, &sch3);\\r\\n#ifndef SIGALRM\\r\\nprintf(\"First we calculate the approximate speed ...\\n\");\\r\\nDES_set_key_unchecked(&key, &sch);\\r\\ncount = 10;\\r\\ndo {\\r\\nlong i;\\r\\nDES_LONG data[2];\\r\\ncount *= 2;\\r\\nTime_F(START);\\r\\nfor (i = count; i; i--)\\r\\nDES_encrypt1(data, &sch, DES_ENCRYPT);\\r\\nd = Time_F(STOP);\\r\\n} while (d < 3.0);\\r\\nca = count;\\r\\ncb = count * 3;\\r\\ncc = count * 3 * 8 / BUFSIZE + 1;\\r\\ncd = count * 8 / BUFSIZE + 1;\\r\\nce = count / 20 + 1;\\r\\nprintf(\"Doing set_key %ld times\\n\", ca);\\r\\n# define COND(d) (count != (d))\\r\\n# define COUNT(d) (d)\\r\\n#else\\r\\n# define COND(c) (run)\\r\\n# define COUNT(d) (count)\\r\\nsignal(SIGALRM, sig_done);\\r\\nprintf(\"Doing set_key for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count = 0, run = 1; COND(ca); count++)\\r\\nDES_set_key_unchecked(&key, &sch);\\r\\nd = Time_F(STOP);\\r\\nprintf(\"%ld set_key's in %.2f seconds\\n\", count, d);\\r\\na = ((double)COUNT(ca)) / d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing DES_encrypt's for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing DES_encrypt %ld times\\n\", cb);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count = 0, run = 1; COND(cb); count++) {\\r\\nDES_LONG data[2];\\r\\nDES_encrypt1(data, &sch, DES_ENCRYPT);\\r\\n}\\r\\nd = Time_F(STOP);\\r\\nprintf(\"%ld DES_encrypt's in %.2f second\\n\", count, d);\\r\\nb = ((double)COUNT(cb) * 8) / d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing DES_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing DES_cbc_encrypt %ld times on %ld byte blocks\\n\", cc,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count = 0, run = 1; COND(cc); count++)\\r\\nDES_ncbc_encrypt(buf, buf, BUFSIZE, &sch, &key, DES_ENCRYPT);\\r\\nd = Time_F(STOP);\\r\\nprintf(\"%ld DES_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount, BUFSIZE, d);\\r\\nc = ((double)COUNT(cc) * BUFSIZE) / d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing DES_ede_cbc_encrypt on %ld byte blocks for 10 seconds\\n\",\\r\\nBUFSIZE);\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing DES_ede_cbc_encrypt %ld times on %ld byte blocks\\n\", cd,\\r\\nBUFSIZE);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count = 0, run = 1; COND(cd); count++)\\r\\nDES_ede3_cbc_encrypt(buf, buf, BUFSIZE,\\r\\n&sch, &sch2, &sch3, &key, DES_ENCRYPT);\\r\\nd = Time_F(STOP);\\r\\nprintf(\"%ld DES_ede_cbc_encrypt's of %ld byte blocks in %.2f second\\n\",\\r\\ncount, BUFSIZE, d);\\r\\nd = ((double)COUNT(cd) * BUFSIZE) / d;\\r\\n#ifdef SIGALRM\\r\\nprintf(\"Doing crypt for 10 seconds\\n\");\\r\\nalarm(10);\\r\\n#else\\r\\nprintf(\"Doing crypt %ld times\\n\", ce);\\r\\n#endif\\r\\nTime_F(START);\\r\\nfor (count = 0, run = 1; COND(ce); count++)\\r\\ncrypt(\"testing1\", \"ef\");\\r\\ne = Time_F(STOP);\\r\\nprintf(\"%ld crypts in %.2f second\\n\", count, e);\\r\\ne = ((double)COUNT(ce)) / e;\\r\\nprintf(\"set_key per sec = %12.2f (%9.3fuS)\\n\", a, 1.0e6 / a);\\r\\nprintf(\"DES raw ecb bytes per sec = %12.2f (%9.3fuS)\\n\", b, 8.0e6 / b);\\r\\nprintf(\"DES cbc bytes per sec = %12.2f (%9.3fuS)\\n\", c, 8.0e6 / c);\\r\\nprintf(\"DES ede cbc bytes per sec = %12.2f (%9.3fuS)\\n\", d, 8.0e6 / d);\\r\\nprintf(\"crypt per sec = %12.2f (%9.3fuS)\\n\", e, 1.0e6 / e);\\r\\nexit(0);\\r\\n#if defined(LINT) || defined(OPENSSL_SYS_MSDOS)\\r\\nreturn (0);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_exp2_c", "target": 0, "func": "int BN_mod_exp2_mont(BIGNUM *rr, const BIGNUM *a1, const BIGNUM *p1,\\r\\nconst BIGNUM *a2, const BIGNUM *p2, const BIGNUM *m,\\r\\nBN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nint i, j, bits, b, bits1, bits2, ret =\\r\\n0, wpos1, wpos2, window1, window2, wvalue1, wvalue2;\\r\\nint r_is_one = 1;\\r\\nBIGNUM *d, *r;\\r\\nconst BIGNUM *a_mod_m;\\r\\nBIGNUM *val1[TABLE_SIZE], *val2[TABLE_SIZE];\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nbn_check_top(a1);\\r\\nbn_check_top(p1);\\r\\nbn_check_top(a2);\\r\\nbn_check_top(p2);\\r\\nbn_check_top(m);\\r\\nif (!(m->d[0] & 1)) {\\r\\nBNerr(BN_F_BN_MOD_EXP2_MONT, BN_R_CALLED_WITH_EVEN_MODULUS);\\r\\nreturn (0);\\r\\n}\\r\\nbits1 = BN_num_bits(p1);\\r\\nbits2 = BN_num_bits(p2);\\r\\nif ((bits1 == 0) && (bits2 == 0)) {\\r\\nret = BN_one(rr);\\r\\nreturn ret;\\r\\n}\\r\\nbits = (bits1 > bits2) ? bits1 : bits2;\\r\\nBN_CTX_start(ctx);\\r\\nd = BN_CTX_get(ctx);\\r\\nr = BN_CTX_get(ctx);\\r\\nval1[0] = BN_CTX_get(ctx);\\r\\nval2[0] = BN_CTX_get(ctx);\\r\\nif (!d || !r || !val1[0] || !val2[0])\\r\\ngoto err;\\r\\nif (in_mont != NULL)\\r\\nmont = in_mont;\\r\\nelse {\\r\\nif ((mont = BN_MONT_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(mont, m, ctx))\\r\\ngoto err;\\r\\n}\\r\\nwindow1 = BN_window_bits_for_exponent_size(bits1);\\r\\nwindow2 = BN_window_bits_for_exponent_size(bits2);\\r\\nif (a1->neg || BN_ucmp(a1, m) >= 0) {\\r\\nif (!BN_mod(val1[0], a1, m, ctx))\\r\\ngoto err;\\r\\na_mod_m = val1[0];\\r\\n} else\\r\\na_mod_m = a1;\\r\\nif (BN_is_zero(a_mod_m)) {\\r\\nBN_zero(rr);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_to_montgomery(val1[0], a_mod_m, mont, ctx))\\r\\ngoto err;\\r\\nif (window1 > 1) {\\r\\nif (!BN_mod_mul_montgomery(d, val1[0], val1[0], mont, ctx))\\r\\ngoto err;\\r\\nj = 1 << (window1 - 1);\\r\\nfor (i = 1; i < j; i++) {\\r\\nif (((val1[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul_montgomery(val1[i], val1[i - 1], d, mont, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (a2->neg || BN_ucmp(a2, m) >= 0) {\\r\\nif (!BN_mod(val2[0], a2, m, ctx))\\r\\ngoto err;\\r\\na_mod_m = val2[0];\\r\\n} else\\r\\na_mod_m = a2;\\r\\nif (BN_is_zero(a_mod_m)) {\\r\\nBN_zero(rr);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_to_montgomery(val2[0], a_mod_m, mont, ctx))\\r\\ngoto err;\\r\\nif (window2 > 1) {\\r\\nif (!BN_mod_mul_montgomery(d, val2[0], val2[0], mont, ctx))\\r\\ngoto err;\\r\\nj = 1 << (window2 - 1);\\r\\nfor (i = 1; i < j; i++) {\\r\\nif (((val2[i] = BN_CTX_get(ctx)) == NULL) ||\\r\\n!BN_mod_mul_montgomery(val2[i], val2[i - 1], d, mont, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nr_is_one = 1;\\r\\nwvalue1 = 0;\\r\\nwvalue2 = 0;\\r\\nwpos1 = 0;\\r\\nwpos2 = 0;\\r\\nif (!BN_to_montgomery(r, BN_value_one(), mont, ctx))\\r\\ngoto err;\\r\\nfor (b = bits - 1; b >= 0; b--) {\\r\\nif (!r_is_one) {\\r\\nif (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!wvalue1)\\r\\nif (BN_is_bit_set(p1, b)) {\\r\\ni = b - window1 + 1;\\r\\nwhile (!BN_is_bit_set(p1, i))\\r\\ni++;\\r\\nwpos1 = i;\\r\\nwvalue1 = 1;\\r\\nfor (i = b - 1; i >= wpos1; i--) {\\r\\nwvalue1 <<= 1;\\r\\nif (BN_is_bit_set(p1, i))\\r\\nwvalue1++;\\r\\n}\\r\\n}\\r\\nif (!wvalue2)\\r\\nif (BN_is_bit_set(p2, b)) {\\r\\ni = b - window2 + 1;\\r\\nwhile (!BN_is_bit_set(p2, i))\\r\\ni++;\\r\\nwpos2 = i;\\r\\nwvalue2 = 1;\\r\\nfor (i = b - 1; i >= wpos2; i--) {\\r\\nwvalue2 <<= 1;\\r\\nif (BN_is_bit_set(p2, i))\\r\\nwvalue2++;\\r\\n}\\r\\n}\\r\\nif (wvalue1 && b == wpos1) {\\r\\nif (!BN_mod_mul_montgomery(r, r, val1[wvalue1 >> 1], mont, ctx))\\r\\ngoto err;\\r\\nwvalue1 = 0;\\r\\nr_is_one = 0;\\r\\n}\\r\\nif (wvalue2 && b == wpos2) {\\r\\nif (!BN_mod_mul_montgomery(r, r, val2[wvalue2 >> 1], mont, ctx))\\r\\ngoto err;\\r\\nwvalue2 = 0;\\r\\nr_is_one = 0;\\r\\n}\\r\\n}\\r\\nif (!BN_from_montgomery(rr, r, mont, ctx))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif ((in_mont == NULL) && (mont != NULL))\\r\\nBN_MONT_CTX_free(mont);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(rr);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_sign_c", "target": 0, "func": "int RSA_sign(int type, const unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigret, unsigned int *siglen, RSA *rsa)\\r\\n{\\r\\nX509_SIG sig;\\r\\nASN1_TYPE parameter;\\r\\nint i, j, ret = 1;\\r\\nunsigned char *p, *tmps = NULL;\\r\\nconst unsigned char *s = NULL;\\r\\nX509_ALGOR algor;\\r\\nASN1_OCTET_STRING digest;\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)\\r\\n&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nRSAerr(RSA_F_RSA_SIGN, RSA_R_NON_FIPS_RSA_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nif ((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_sign) {\\r\\nreturn rsa->meth->rsa_sign(type, m, m_len, sigret, siglen, rsa);\\r\\n}\\r\\nif (type == NID_md5_sha1) {\\r\\nif (m_len != SSL_SIG_LENGTH) {\\r\\nRSAerr(RSA_F_RSA_SIGN, RSA_R_INVALID_MESSAGE_LENGTH);\\r\\nreturn (0);\\r\\n}\\r\\ni = SSL_SIG_LENGTH;\\r\\ns = m;\\r\\n} else {\\r\\nsig.algor = &algor;\\r\\nsig.algor->algorithm = OBJ_nid2obj(type);\\r\\nif (sig.algor->algorithm == NULL) {\\r\\nRSAerr(RSA_F_RSA_SIGN, RSA_R_UNKNOWN_ALGORITHM_TYPE);\\r\\nreturn (0);\\r\\n}\\r\\nif (sig.algor->algorithm->length == 0) {\\r\\nRSAerr(RSA_F_RSA_SIGN,\\r\\nRSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);\\r\\nreturn (0);\\r\\n}\\r\\nparameter.type = V_ASN1_NULL;\\r\\nparameter.value.ptr = NULL;\\r\\nsig.algor->parameter = &parameter;\\r\\nsig.digest = &digest;\\r\\nsig.digest->data = (unsigned char *)m;\\r\\nsig.digest->length = m_len;\\r\\ni = i2d_X509_SIG(&sig, NULL);\\r\\n}\\r\\nj = RSA_size(rsa);\\r\\nif (i > (j - RSA_PKCS1_PADDING_SIZE)) {\\r\\nRSAerr(RSA_F_RSA_SIGN, RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);\\r\\nreturn (0);\\r\\n}\\r\\nif (type != NID_md5_sha1) {\\r\\ntmps = (unsigned char *)OPENSSL_malloc((unsigned int)j + 1);\\r\\nif (tmps == NULL) {\\r\\nRSAerr(RSA_F_RSA_SIGN, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\np = tmps;\\r\\ni2d_X509_SIG(&sig, &p);\\r\\ns = tmps;\\r\\n}\\r\\ni = RSA_private_encrypt(i, s, sigret, rsa, RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\nret = 0;\\r\\nelse\\r\\n*siglen = i;\\r\\nif (type != NID_md5_sha1) {\\r\\nOPENSSL_cleanse(tmps, (unsigned int)j + 1);\\r\\nOPENSSL_free(tmps);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int rsa_check_digestinfo(X509_SIG *sig, const unsigned char *dinfo,\\r\\nint dinfolen)\\r\\n{\\r\\nunsigned char *der = NULL;\\r\\nint derlen;\\r\\nint ret = 0;\\r\\nderlen = i2d_X509_SIG(sig, &der);\\r\\nif (derlen <= 0)\\r\\nreturn 0;\\r\\nif (derlen == dinfolen && !memcmp(dinfo, der, derlen))\\r\\nret = 1;\\r\\nOPENSSL_cleanse(der, derlen);\\r\\nOPENSSL_free(der);\\r\\nreturn ret;\\r\\n}\\r\\nint int_rsa_verify(int dtype, const unsigned char *m,\\r\\nunsigned int m_len,\\r\\nunsigned char *rm, size_t *prm_len,\\r\\nconst unsigned char *sigbuf, size_t siglen, RSA *rsa)\\r\\n{\\r\\nint i, ret = 0, sigtype;\\r\\nunsigned char *s;\\r\\nX509_SIG *sig = NULL;\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)\\r\\n&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_NON_FIPS_RSA_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nif (siglen != (unsigned int)RSA_size(rsa)) {\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_WRONG_SIGNATURE_LENGTH);\\r\\nreturn (0);\\r\\n}\\r\\nif ((dtype == NID_md5_sha1) && rm) {\\r\\ni = RSA_public_decrypt((int)siglen,\\r\\nsigbuf, rm, rsa, RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\nreturn 0;\\r\\n*prm_len = i;\\r\\nreturn 1;\\r\\n}\\r\\ns = (unsigned char *)OPENSSL_malloc((unsigned int)siglen);\\r\\nif (s == NULL) {\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ((dtype == NID_md5_sha1) && (m_len != SSL_SIG_LENGTH)) {\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\ni = RSA_public_decrypt((int)siglen, sigbuf, s, rsa, RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\ngoto err;\\r\\nif (dtype == NID_mdc2 && i == 18 && s[0] == 0x04 && s[1] == 0x10) {\\r\\nif (rm) {\\r\\nmemcpy(rm, s + 2, 16);\\r\\n*prm_len = 16;\\r\\nret = 1;\\r\\n} else if (memcmp(m, s + 2, 16))\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);\\r\\nelse\\r\\nret = 1;\\r\\n}\\r\\nif (dtype == NID_md5_sha1) {\\r\\nif ((i != SSL_SIG_LENGTH) || memcmp(s, m, SSL_SIG_LENGTH))\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);\\r\\nelse\\r\\nret = 1;\\r\\n} else {\\r\\nconst unsigned char *p = s;\\r\\nsig = d2i_X509_SIG(NULL, &p, (long)i);\\r\\nif (sig == NULL)\\r\\ngoto err;\\r\\nif (p != s + i || !rsa_check_digestinfo(sig, s, i)) {\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);\\r\\ngoto err;\\r\\n}\\r\\nif (sig->algor->parameter\\r\\n&& ASN1_TYPE_get(sig->algor->parameter) != V_ASN1_NULL) {\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);\\r\\ngoto err;\\r\\n}\\r\\nsigtype = OBJ_obj2nid(sig->algor->algorithm);\\r\\n#ifdef RSA_DEBUG\\r\\nfprintf(stderr, \"in(%s) expect(%s)\\n\", OBJ_nid2ln(sigtype),\\r\\nOBJ_nid2ln(dtype));\\r\\n#endif\\r\\nif (sigtype != dtype) {\\r\\nif (((dtype == NID_md5) &&\\r\\n(sigtype == NID_md5WithRSAEncryption)) ||\\r\\n((dtype == NID_md2) &&\\r\\n(sigtype == NID_md2WithRSAEncryption))) {\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nfprintf(stderr,\\r\\n\"signature has problems, re-make with post SSLeay045\\n\");\\r\\n#endif\\r\\n} else {\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_ALGORITHM_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (rm) {\\r\\nconst EVP_MD *md;\\r\\nmd = EVP_get_digestbynid(dtype);\\r\\nif (md && (EVP_MD_size(md) != sig->digest->length))\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_DIGEST_LENGTH);\\r\\nelse {\\r\\nmemcpy(rm, sig->digest->data, sig->digest->length);\\r\\n*prm_len = sig->digest->length;\\r\\nret = 1;\\r\\n}\\r\\n} else if (((unsigned int)sig->digest->length != m_len) ||\\r\\n(memcmp(m, sig->digest->data, m_len) != 0)) {\\r\\nRSAerr(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);\\r\\n} else\\r\\nret = 1;\\r\\n}\\r\\nerr:\\r\\nif (sig != NULL)\\r\\nX509_SIG_free(sig);\\r\\nif (s != NULL) {\\r\\nOPENSSL_cleanse(s, (unsigned int)siglen);\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint RSA_verify(int dtype, const unsigned char *m, unsigned int m_len,\\r\\nconst unsigned char *sigbuf, unsigned int siglen, RSA *rsa)\\r\\n{\\r\\nif ((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_verify) {\\r\\nreturn rsa->meth->rsa_verify(dtype, m, m_len, sigbuf, siglen, rsa);\\r\\n}\\r\\nreturn int_rsa_verify(dtype, m, m_len, NULL, NULL, sigbuf, siglen, rsa);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_pkey_c", "target": 0, "func": "int ENGINE_set_load_privkey_function(ENGINE *e,\\r\\nENGINE_LOAD_KEY_PTR loadpriv_f)\\r\\n{\\r\\ne->load_privkey = loadpriv_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_load_pubkey_function(ENGINE *e, ENGINE_LOAD_KEY_PTR loadpub_f)\\r\\n{\\r\\ne->load_pubkey = loadpub_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_load_ssl_client_cert_function(ENGINE *e,\\r\\nENGINE_SSL_CLIENT_CERT_PTR\\r\\nloadssl_f)\\r\\n{\\r\\ne->load_ssl_client_cert = loadssl_f;\\r\\nreturn 1;\\r\\n}\\r\\nENGINE_LOAD_KEY_PTR ENGINE_get_load_privkey_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->load_privkey;\\r\\n}\\r\\nENGINE_LOAD_KEY_PTR ENGINE_get_load_pubkey_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->load_pubkey;\\r\\n}\\r\\nENGINE_SSL_CLIENT_CERT_PTR ENGINE_get_ssl_client_cert_function(const ENGINE\\r\\n*e)\\r\\n{\\r\\nreturn e->load_ssl_client_cert;\\r\\n}\\r\\nEVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (e->funct_ref == 0) {\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY, ENGINE_R_NOT_INITIALISED);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nif (!e->load_privkey) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,\\r\\nENGINE_R_NO_LOAD_FUNCTION);\\r\\nreturn 0;\\r\\n}\\r\\npkey = e->load_privkey(e, key_id, ui_method, callback_data);\\r\\nif (!pkey) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PRIVATE_KEY,\\r\\nENGINE_R_FAILED_LOADING_PRIVATE_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn pkey;\\r\\n}\\r\\nEVP_PKEY *ENGINE_load_public_key(ENGINE *e, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (e->funct_ref == 0) {\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY, ENGINE_R_NOT_INITIALISED);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nif (!e->load_pubkey) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY, ENGINE_R_NO_LOAD_FUNCTION);\\r\\nreturn 0;\\r\\n}\\r\\npkey = e->load_pubkey(e, key_id, ui_method, callback_data);\\r\\nif (!pkey) {\\r\\nENGINEerr(ENGINE_F_ENGINE_LOAD_PUBLIC_KEY,\\r\\nENGINE_R_FAILED_LOADING_PUBLIC_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nreturn pkey;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_asn1_c", "target": 0, "func": "int EC_GROUP_get_basis_type(const EC_GROUP *group)\\r\\n{\\r\\nint i = 0;\\r\\nif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\\r\\nNID_X9_62_characteristic_two_field)\\r\\nreturn 0;\\r\\nwhile (group->poly[i] != 0)\\r\\ni++;\\r\\nif (i == 4)\\r\\nreturn NID_X9_62_ppBasis;\\r\\nelse if (i == 2)\\r\\nreturn NID_X9_62_tpBasis;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint EC_GROUP_get_trinomial_basis(const EC_GROUP *group, unsigned int *k)\\r\\n{\\r\\nif (group == NULL)\\r\\nreturn 0;\\r\\nif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\\r\\nNID_X9_62_characteristic_two_field\\r\\n|| !((group->poly[0] != 0) && (group->poly[1] != 0)\\r\\n&& (group->poly[2] == 0))) {\\r\\nECerr(EC_F_EC_GROUP_GET_TRINOMIAL_BASIS,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (k)\\r\\n*k = group->poly[1];\\r\\nreturn 1;\\r\\n}\\r\\nint EC_GROUP_get_pentanomial_basis(const EC_GROUP *group, unsigned int *k1,\\r\\nunsigned int *k2, unsigned int *k3)\\r\\n{\\r\\nif (group == NULL)\\r\\nreturn 0;\\r\\nif (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\\r\\nNID_X9_62_characteristic_two_field\\r\\n|| !((group->poly[0] != 0) && (group->poly[1] != 0)\\r\\n&& (group->poly[2] != 0) && (group->poly[3] != 0)\\r\\n&& (group->poly[4] == 0))) {\\r\\nECerr(EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (k1)\\r\\n*k1 = group->poly[3];\\r\\nif (k2)\\r\\n*k2 = group->poly[2];\\r\\nif (k3)\\r\\n*k3 = group->poly[1];\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ec_asn1_group2fieldid(const EC_GROUP *group, X9_62_FIELDID *field)\\r\\n{\\r\\nint ok = 0, nid;\\r\\nBIGNUM *tmp = NULL;\\r\\nif (group == NULL || field == NULL)\\r\\nreturn 0;\\r\\nif (field->fieldType != NULL)\\r\\nASN1_OBJECT_free(field->fieldType);\\r\\nif (field->p.other != NULL)\\r\\nASN1_TYPE_free(field->p.other);\\r\\nnid = EC_METHOD_get_field_type(EC_GROUP_method_of(group));\\r\\nif ((field->fieldType = OBJ_nid2obj(nid)) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (nid == NID_X9_62_prime_field) {\\r\\nif ((tmp = BN_new()) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_curve_GFp(group, tmp, NULL, NULL, NULL)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nfield->p.prime = BN_to_ASN1_INTEGER(tmp, NULL);\\r\\nif (field->p.prime == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\n#ifdef OPENSSL_NO_EC2M\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, EC_R_GF2M_NOT_SUPPORTED);\\r\\ngoto err;\\r\\n}\\r\\n#else\\r\\n{\\r\\nint field_type;\\r\\nX9_62_CHARACTERISTIC_TWO *char_two;\\r\\nfield->p.char_two = X9_62_CHARACTERISTIC_TWO_new();\\r\\nchar_two = field->p.char_two;\\r\\nif (char_two == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nchar_two->m = (long)EC_GROUP_get_degree(group);\\r\\nfield_type = EC_GROUP_get_basis_type(group);\\r\\nif (field_type == 0) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((char_two->type = OBJ_nid2obj(field_type)) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_OBJ_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (field_type == NID_X9_62_tpBasis) {\\r\\nunsigned int k;\\r\\nif (!EC_GROUP_get_trinomial_basis(group, &k))\\r\\ngoto err;\\r\\nchar_two->p.tpBasis = ASN1_INTEGER_new();\\r\\nif (!char_two->p.tpBasis) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_INTEGER_set(char_two->p.tpBasis, (long)k)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n} else if (field_type == NID_X9_62_ppBasis) {\\r\\nunsigned int k1, k2, k3;\\r\\nif (!EC_GROUP_get_pentanomial_basis(group, &k1, &k2, &k3))\\r\\ngoto err;\\r\\nchar_two->p.ppBasis = X9_62_PENTANOMIAL_new();\\r\\nif (!char_two->p.ppBasis) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nchar_two->p.ppBasis->k1 = (long)k1;\\r\\nchar_two->p.ppBasis->k2 = (long)k2;\\r\\nchar_two->p.ppBasis->k3 = (long)k3;\\r\\n} else {\\r\\nchar_two->p.onBasis = ASN1_NULL_new();\\r\\nif (!char_two->p.onBasis) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2FIELDID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\n#endif\\r\\nok = 1;\\r\\nerr:if (tmp)\\r\\nBN_free(tmp);\\r\\nreturn (ok);\\r\\n}\\r\\nstatic int ec_asn1_group2curve(const EC_GROUP *group, X9_62_CURVE *curve)\\r\\n{\\r\\nint ok = 0, nid;\\r\\nBIGNUM *tmp_1 = NULL, *tmp_2 = NULL;\\r\\nunsigned char *buffer_1 = NULL, *buffer_2 = NULL,\\r\\n*a_buf = NULL, *b_buf = NULL;\\r\\nsize_t len_1, len_2;\\r\\nunsigned char char_zero = 0;\\r\\nif (!group || !curve || !curve->a || !curve->b)\\r\\nreturn 0;\\r\\nif ((tmp_1 = BN_new()) == NULL || (tmp_2 = BN_new()) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nnid = EC_METHOD_get_field_type(EC_GROUP_method_of(group));\\r\\nif (nid == NID_X9_62_prime_field) {\\r\\nif (!EC_GROUP_get_curve_GFp(group, NULL, tmp_1, tmp_2, NULL)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#ifndef OPENSSL_NO_EC2M\\r\\nelse {\\r\\nif (!EC_GROUP_get_curve_GF2m(group, NULL, tmp_1, tmp_2, NULL)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nlen_1 = (size_t)BN_num_bytes(tmp_1);\\r\\nlen_2 = (size_t)BN_num_bytes(tmp_2);\\r\\nif (len_1 == 0) {\\r\\na_buf = &char_zero;\\r\\nlen_1 = 1;\\r\\n} else {\\r\\nif ((buffer_1 = OPENSSL_malloc(len_1)) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ((len_1 = BN_bn2bin(tmp_1, buffer_1)) == 0) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\na_buf = buffer_1;\\r\\n}\\r\\nif (len_2 == 0) {\\r\\nb_buf = &char_zero;\\r\\nlen_2 = 1;\\r\\n} else {\\r\\nif ((buffer_2 = OPENSSL_malloc(len_2)) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ((len_2 = BN_bn2bin(tmp_2, buffer_2)) == 0) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nb_buf = buffer_2;\\r\\n}\\r\\nif (!M_ASN1_OCTET_STRING_set(curve->a, a_buf, len_1) ||\\r\\n!M_ASN1_OCTET_STRING_set(curve->b, b_buf, len_2)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (group->seed) {\\r\\nif (!curve->seed)\\r\\nif ((curve->seed = ASN1_BIT_STRING_new()) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ncurve->seed->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\ncurve->seed->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\nif (!ASN1_BIT_STRING_set(curve->seed, group->seed,\\r\\n(int)group->seed_len)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2CURVE, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nif (curve->seed) {\\r\\nASN1_BIT_STRING_free(curve->seed);\\r\\ncurve->seed = NULL;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:if (buffer_1)\\r\\nOPENSSL_free(buffer_1);\\r\\nif (buffer_2)\\r\\nOPENSSL_free(buffer_2);\\r\\nif (tmp_1)\\r\\nBN_free(tmp_1);\\r\\nif (tmp_2)\\r\\nBN_free(tmp_2);\\r\\nreturn (ok);\\r\\n}\\r\\nstatic ECPARAMETERS *ec_asn1_group2parameters(const EC_GROUP *group,\\r\\nECPARAMETERS *param)\\r\\n{\\r\\nint ok = 0;\\r\\nsize_t len = 0;\\r\\nECPARAMETERS *ret = NULL;\\r\\nBIGNUM *tmp = NULL;\\r\\nunsigned char *buffer = NULL;\\r\\nconst EC_POINT *point = NULL;\\r\\npoint_conversion_form_t form;\\r\\nif ((tmp = BN_new()) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (param == NULL) {\\r\\nif ((ret = ECPARAMETERS_new()) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\nret = param;\\r\\nret->version = (long)0x1;\\r\\nif (!ec_asn1_group2fieldid(group, ret->fieldID)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!ec_asn1_group2curve(group, ret->curve)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((point = EC_GROUP_get0_generator(group)) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, EC_R_UNDEFINED_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\nform = EC_GROUP_get_point_conversion_form(group);\\r\\nlen = EC_POINT_point2oct(group, point, form, NULL, len, NULL);\\r\\nif (len == 0) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((buffer = OPENSSL_malloc(len)) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_point2oct(group, point, form, buffer, len, NULL)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (ret->base == NULL && (ret->base = ASN1_OCTET_STRING_new()) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_OCTET_STRING_set(ret->base, buffer, len)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_order(group, tmp, NULL)) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->order = BN_to_ASN1_INTEGER(tmp, ret->order);\\r\\nif (ret->order == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_GROUP_get_cofactor(group, tmp, NULL)) {\\r\\nret->cofactor = BN_to_ASN1_INTEGER(tmp, ret->cofactor);\\r\\nif (ret->cofactor == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PARAMETERS, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:if (!ok) {\\r\\nif (ret && !param)\\r\\nECPARAMETERS_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nif (tmp)\\r\\nBN_free(tmp);\\r\\nif (buffer)\\r\\nOPENSSL_free(buffer);\\r\\nreturn (ret);\\r\\n}\\r\\nECPKPARAMETERS *ec_asn1_group2pkparameters(const EC_GROUP *group,\\r\\nECPKPARAMETERS *params)\\r\\n{\\r\\nint ok = 1, tmp;\\r\\nECPKPARAMETERS *ret = params;\\r\\nif (ret == NULL) {\\r\\nif ((ret = ECPKPARAMETERS_new()) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_GROUP2PKPARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\n} else {\\r\\nif (ret->type == 0 && ret->value.named_curve)\\r\\nASN1_OBJECT_free(ret->value.named_curve);\\r\\nelse if (ret->type == 1 && ret->value.parameters)\\r\\nECPARAMETERS_free(ret->value.parameters);\\r\\n}\\r\\nif (EC_GROUP_get_asn1_flag(group)) {\\r\\ntmp = EC_GROUP_get_curve_name(group);\\r\\nif (tmp) {\\r\\nret->type = 0;\\r\\nif ((ret->value.named_curve = OBJ_nid2obj(tmp)) == NULL)\\r\\nok = 0;\\r\\n} else\\r\\nok = 0;\\r\\n} else {\\r\\nret->type = 1;\\r\\nif ((ret->value.parameters =\\r\\nec_asn1_group2parameters(group, NULL)) == NULL)\\r\\nok = 0;\\r\\n}\\r\\nif (!ok) {\\r\\nECPKPARAMETERS_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic EC_GROUP *ec_asn1_parameters2group(const ECPARAMETERS *params)\\r\\n{\\r\\nint ok = 0, tmp;\\r\\nEC_GROUP *ret = NULL;\\r\\nBIGNUM *p = NULL, *a = NULL, *b = NULL;\\r\\nEC_POINT *point = NULL;\\r\\nlong field_bits;\\r\\nif (!params->fieldID || !params->fieldID->fieldType ||\\r\\n!params->fieldID->p.ptr) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!params->curve || !params->curve->a ||\\r\\n!params->curve->a->data || !params->curve->b ||\\r\\n!params->curve->b->data) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\na = BN_bin2bn(params->curve->a->data, params->curve->a->length, NULL);\\r\\nif (a == NULL) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nb = BN_bin2bn(params->curve->b->data, params->curve->b->length, NULL);\\r\\nif (b == NULL) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\ntmp = OBJ_obj2nid(params->fieldID->fieldType);\\r\\nif (tmp == NID_X9_62_characteristic_two_field)\\r\\n#ifdef OPENSSL_NO_EC2M\\r\\n{\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_GF2M_NOT_SUPPORTED);\\r\\ngoto err;\\r\\n}\\r\\n#else\\r\\n{\\r\\nX9_62_CHARACTERISTIC_TWO *char_two;\\r\\nchar_two = params->fieldID->p.char_two;\\r\\nfield_bits = char_two->m;\\r\\nif (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_FIELD_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif ((p = BN_new()) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ntmp = OBJ_obj2nid(char_two->type);\\r\\nif (tmp == NID_X9_62_tpBasis) {\\r\\nlong tmp_long;\\r\\nif (!char_two->p.tpBasis) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ntmp_long = ASN1_INTEGER_get(char_two->p.tpBasis);\\r\\nif (!(char_two->m > tmp_long && tmp_long > 0)) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP,\\r\\nEC_R_INVALID_TRINOMIAL_BASIS);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_set_bit(p, (int)char_two->m))\\r\\ngoto err;\\r\\nif (!BN_set_bit(p, (int)tmp_long))\\r\\ngoto err;\\r\\nif (!BN_set_bit(p, 0))\\r\\ngoto err;\\r\\n} else if (tmp == NID_X9_62_ppBasis) {\\r\\nX9_62_PENTANOMIAL *penta;\\r\\npenta = char_two->p.ppBasis;\\r\\nif (!penta) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!\\r\\n(char_two->m > penta->k3 && penta->k3 > penta->k2\\r\\n&& penta->k2 > penta->k1 && penta->k1 > 0)) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP,\\r\\nEC_R_INVALID_PENTANOMIAL_BASIS);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_set_bit(p, (int)char_two->m))\\r\\ngoto err;\\r\\nif (!BN_set_bit(p, (int)penta->k1))\\r\\ngoto err;\\r\\nif (!BN_set_bit(p, (int)penta->k2))\\r\\ngoto err;\\r\\nif (!BN_set_bit(p, (int)penta->k3))\\r\\ngoto err;\\r\\nif (!BN_set_bit(p, 0))\\r\\ngoto err;\\r\\n} else if (tmp == NID_X9_62_onBasis) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_NOT_IMPLEMENTED);\\r\\ngoto err;\\r\\n} else {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nret = EC_GROUP_new_curve_GF2m(p, a, b, NULL);\\r\\n}\\r\\n#endif\\r\\nelse if (tmp == NID_X9_62_prime_field) {\\r\\nif (!params->fieldID->p.prime) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\np = ASN1_INTEGER_to_BN(params->fieldID->p.prime, NULL);\\r\\nif (p == NULL) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_negative(p) || BN_is_zero(p)) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_FIELD);\\r\\ngoto err;\\r\\n}\\r\\nfield_bits = BN_num_bits(p);\\r\\nif (field_bits > OPENSSL_ECC_MAX_FIELD_BITS) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_FIELD_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nret = EC_GROUP_new_curve_GFp(p, a, b, NULL);\\r\\n} else {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_FIELD);\\r\\ngoto err;\\r\\n}\\r\\nif (ret == NULL) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (params->curve->seed != NULL) {\\r\\nif (ret->seed != NULL)\\r\\nOPENSSL_free(ret->seed);\\r\\nif (!(ret->seed = OPENSSL_malloc(params->curve->seed->length))) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(ret->seed, params->curve->seed->data,\\r\\nparams->curve->seed->length);\\r\\nret->seed_len = params->curve->seed->length;\\r\\n}\\r\\nif (!params->order || !params->base || !params->base->data) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif ((point = EC_POINT_new(ret)) == NULL)\\r\\ngoto err;\\r\\nEC_GROUP_set_point_conversion_form(ret, (point_conversion_form_t)\\r\\n(params->base->data[0] & ~0x01));\\r\\nif (!EC_POINT_oct2point(ret, point, params->base->data,\\r\\nparams->base->length, NULL)) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((a = ASN1_INTEGER_to_BN(params->order, a)) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_negative(a) || BN_is_zero(a)) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_GROUP_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_num_bits(a) > (int)field_bits + 1) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, EC_R_INVALID_GROUP_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (params->cofactor == NULL) {\\r\\nif (b) {\\r\\nBN_free(b);\\r\\nb = NULL;\\r\\n}\\r\\n} else if ((b = ASN1_INTEGER_to_BN(params->cofactor, b)) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_set_generator(ret, point, a, b)) {\\r\\nECerr(EC_F_EC_ASN1_PARAMETERS2GROUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nok = 1;\\r\\nerr:if (!ok) {\\r\\nif (ret)\\r\\nEC_GROUP_clear_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nif (p)\\r\\nBN_free(p);\\r\\nif (a)\\r\\nBN_free(a);\\r\\nif (b)\\r\\nBN_free(b);\\r\\nif (point)\\r\\nEC_POINT_free(point);\\r\\nreturn (ret);\\r\\n}\\r\\nEC_GROUP *ec_asn1_pkparameters2group(const ECPKPARAMETERS *params)\\r\\n{\\r\\nEC_GROUP *ret = NULL;\\r\\nint tmp = 0;\\r\\nif (params == NULL) {\\r\\nECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP, EC_R_MISSING_PARAMETERS);\\r\\nreturn NULL;\\r\\n}\\r\\nif (params->type == 0) {\\r\\ntmp = OBJ_obj2nid(params->value.named_curve);\\r\\nif ((ret = EC_GROUP_new_by_curve_name(tmp)) == NULL) {\\r\\nECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP,\\r\\nEC_R_EC_GROUP_NEW_BY_NAME_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nEC_GROUP_set_asn1_flag(ret, OPENSSL_EC_NAMED_CURVE);\\r\\n} else if (params->type == 1) {\\r\\nret = ec_asn1_parameters2group(params->value.parameters);\\r\\nif (!ret) {\\r\\nECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP, ERR_R_EC_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nEC_GROUP_set_asn1_flag(ret, 0x0);\\r\\n} else if (params->type == 2) {\\r\\nreturn NULL;\\r\\n} else {\\r\\nECerr(EC_F_EC_ASN1_PKPARAMETERS2GROUP, EC_R_ASN1_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nEC_GROUP *d2i_ECPKParameters(EC_GROUP **a, const unsigned char **in, long len)\\r\\n{\\r\\nEC_GROUP *group = NULL;\\r\\nECPKPARAMETERS *params = NULL;\\r\\nif ((params = d2i_ECPKPARAMETERS(NULL, in, len)) == NULL) {\\r\\nECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_D2I_ECPKPARAMETERS_FAILURE);\\r\\nECPKPARAMETERS_free(params);\\r\\nreturn NULL;\\r\\n}\\r\\nif ((group = ec_asn1_pkparameters2group(params)) == NULL) {\\r\\nECerr(EC_F_D2I_ECPKPARAMETERS, EC_R_PKPARAMETERS2GROUP_FAILURE);\\r\\nECPKPARAMETERS_free(params);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a && *a)\\r\\nEC_GROUP_clear_free(*a);\\r\\nif (a)\\r\\n*a = group;\\r\\nECPKPARAMETERS_free(params);\\r\\nreturn (group);\\r\\n}\\r\\nint i2d_ECPKParameters(const EC_GROUP *a, unsigned char **out)\\r\\n{\\r\\nint ret = 0;\\r\\nECPKPARAMETERS *tmp = ec_asn1_group2pkparameters(a, NULL);\\r\\nif (tmp == NULL) {\\r\\nECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_GROUP2PKPARAMETERS_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif ((ret = i2d_ECPKPARAMETERS(tmp, out)) == 0) {\\r\\nECerr(EC_F_I2D_ECPKPARAMETERS, EC_R_I2D_ECPKPARAMETERS_FAILURE);\\r\\nECPKPARAMETERS_free(tmp);\\r\\nreturn 0;\\r\\n}\\r\\nECPKPARAMETERS_free(tmp);\\r\\nreturn (ret);\\r\\n}\\r\\nEC_KEY *d2i_ECPrivateKey(EC_KEY **a, const unsigned char **in, long len)\\r\\n{\\r\\nint ok = 0;\\r\\nEC_KEY *ret = NULL;\\r\\nEC_PRIVATEKEY *priv_key = NULL;\\r\\nif ((priv_key = EC_PRIVATEKEY_new()) == NULL) {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif ((priv_key = d2i_EC_PRIVATEKEY(&priv_key, in, len)) == NULL) {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\nEC_PRIVATEKEY_free(priv_key);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a == NULL || *a == NULL) {\\r\\nif ((ret = EC_KEY_new()) == NULL) {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (a)\\r\\n*a = ret;\\r\\n} else\\r\\nret = *a;\\r\\nif (priv_key->parameters) {\\r\\nif (ret->group)\\r\\nEC_GROUP_clear_free(ret->group);\\r\\nret->group = ec_asn1_pkparameters2group(priv_key->parameters);\\r\\n}\\r\\nif (ret->group == NULL) {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->version = priv_key->version;\\r\\nif (priv_key->privateKey) {\\r\\nret->priv_key = BN_bin2bn(M_ASN1_STRING_data(priv_key->privateKey),\\r\\nM_ASN1_STRING_length(priv_key->privateKey),\\r\\nret->priv_key);\\r\\nif (ret->priv_key == NULL) {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, EC_R_MISSING_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (ret->pub_key)\\r\\nEC_POINT_clear_free(ret->pub_key);\\r\\nret->pub_key = EC_POINT_new(ret->group);\\r\\nif (ret->pub_key == NULL) {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (priv_key->publicKey) {\\r\\nconst unsigned char *pub_oct;\\r\\nint pub_oct_len;\\r\\npub_oct = M_ASN1_STRING_data(priv_key->publicKey);\\r\\npub_oct_len = M_ASN1_STRING_length(priv_key->publicKey);\\r\\nif (pub_oct_len <= 0) {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, EC_R_BUFFER_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nret->conv_form = (point_conversion_form_t) (pub_oct[0] & ~0x01);\\r\\nif (!EC_POINT_oct2point(ret->group, ret->pub_key,\\r\\npub_oct, (size_t)(pub_oct_len), NULL)) {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nif (!EC_POINT_mul\\r\\n(ret->group, ret->pub_key, ret->priv_key, NULL, NULL, NULL)) {\\r\\nECerr(EC_F_D2I_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->enc_flag |= EC_PKEY_NO_PUBKEY;\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (!ok) {\\r\\nif (ret)\\r\\nEC_KEY_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nif (priv_key)\\r\\nEC_PRIVATEKEY_free(priv_key);\\r\\nreturn (ret);\\r\\n}\\r\\nint i2d_ECPrivateKey(EC_KEY *a, unsigned char **out)\\r\\n{\\r\\nint ret = 0, ok = 0;\\r\\nunsigned char *buffer = NULL;\\r\\nsize_t buf_len = 0, tmp_len;\\r\\nEC_PRIVATEKEY *priv_key = NULL;\\r\\nif (a == NULL || a->group == NULL || a->priv_key == NULL ||\\r\\n(!(a->enc_flag & EC_PKEY_NO_PUBKEY) && a->pub_key == NULL)) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\ngoto err;\\r\\n}\\r\\nif ((priv_key = EC_PRIVATEKEY_new()) == NULL) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npriv_key->version = a->version;\\r\\nbuf_len = (size_t)BN_num_bytes(a->priv_key);\\r\\nbuffer = OPENSSL_malloc(buf_len);\\r\\nif (buffer == NULL) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_bn2bin(a->priv_key, buffer)) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!M_ASN1_OCTET_STRING_set(priv_key->privateKey, buffer, buf_len)) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!(a->enc_flag & EC_PKEY_NO_PARAMETERS)) {\\r\\nif ((priv_key->parameters =\\r\\nec_asn1_group2pkparameters(a->group,\\r\\npriv_key->parameters)) == NULL) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!(a->enc_flag & EC_PKEY_NO_PUBKEY)) {\\r\\npriv_key->publicKey = M_ASN1_BIT_STRING_new();\\r\\nif (priv_key->publicKey == NULL) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ntmp_len = EC_POINT_point2oct(a->group, a->pub_key,\\r\\na->conv_form, NULL, 0, NULL);\\r\\nif (tmp_len > buf_len) {\\r\\nunsigned char *tmp_buffer = OPENSSL_realloc(buffer, tmp_len);\\r\\nif (!tmp_buffer) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nbuffer = tmp_buffer;\\r\\nbuf_len = tmp_len;\\r\\n}\\r\\nif (!EC_POINT_point2oct(a->group, a->pub_key,\\r\\na->conv_form, buffer, buf_len, NULL)) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\npriv_key->publicKey->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\npriv_key->publicKey->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\nif (!M_ASN1_BIT_STRING_set(priv_key->publicKey, buffer, buf_len)) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((ret = i2d_EC_PRIVATEKEY(priv_key, out)) == 0) {\\r\\nECerr(EC_F_I2D_ECPRIVATEKEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (buffer)\\r\\nOPENSSL_free(buffer);\\r\\nif (priv_key)\\r\\nEC_PRIVATEKEY_free(priv_key);\\r\\nreturn (ok ? ret : 0);\\r\\n}\\r\\nint i2d_ECParameters(EC_KEY *a, unsigned char **out)\\r\\n{\\r\\nif (a == NULL) {\\r\\nECerr(EC_F_I2D_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nreturn i2d_ECPKParameters(a->group, out);\\r\\n}\\r\\nEC_KEY *d2i_ECParameters(EC_KEY **a, const unsigned char **in, long len)\\r\\n{\\r\\nEC_KEY *ret;\\r\\nif (in == NULL || *in == NULL) {\\r\\nECerr(EC_F_D2I_ECPARAMETERS, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a == NULL || *a == NULL) {\\r\\nif ((ret = EC_KEY_new()) == NULL) {\\r\\nECerr(EC_F_D2I_ECPARAMETERS, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a)\\r\\n*a = ret;\\r\\n} else\\r\\nret = *a;\\r\\nif (!d2i_ECPKParameters(&ret->group, in, len)) {\\r\\nECerr(EC_F_D2I_ECPARAMETERS, ERR_R_EC_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nEC_KEY *o2i_ECPublicKey(EC_KEY **a, const unsigned char **in, long len)\\r\\n{\\r\\nEC_KEY *ret = NULL;\\r\\nif (a == NULL || (*a) == NULL || (*a)->group == NULL) {\\r\\nECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nret = *a;\\r\\nif (ret->pub_key == NULL &&\\r\\n(ret->pub_key = EC_POINT_new(ret->group)) == NULL) {\\r\\nECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!EC_POINT_oct2point(ret->group, ret->pub_key, *in, len, NULL)) {\\r\\nECerr(EC_F_O2I_ECPUBLICKEY, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret->conv_form = (point_conversion_form_t) (*in[0] & ~0x01);\\r\\n*in += len;\\r\\nreturn ret;\\r\\n}\\r\\nint i2o_ECPublicKey(EC_KEY *a, unsigned char **out)\\r\\n{\\r\\nsize_t buf_len = 0;\\r\\nint new_buffer = 0;\\r\\nif (a == NULL) {\\r\\nECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nbuf_len = EC_POINT_point2oct(a->group, a->pub_key,\\r\\na->conv_form, NULL, 0, NULL);\\r\\nif (out == NULL || buf_len == 0)\\r\\nreturn buf_len;\\r\\nif (*out == NULL) {\\r\\nif ((*out = OPENSSL_malloc(buf_len)) == NULL) {\\r\\nECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nnew_buffer = 1;\\r\\n}\\r\\nif (!EC_POINT_point2oct(a->group, a->pub_key, a->conv_form,\\r\\n*out, buf_len, NULL)) {\\r\\nECerr(EC_F_I2O_ECPUBLICKEY, ERR_R_EC_LIB);\\r\\nif (new_buffer) {\\r\\nOPENSSL_free(*out);\\r\\n*out = NULL;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nif (!new_buffer)\\r\\n*out += buf_len;\\r\\nreturn buf_len;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_smime_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint operation = 0;\\r\\nint ret = 0;\\r\\nchar **args;\\r\\nconst char *inmode = \"r\", *outmode = \"w\";\\r\\nchar *infile = NULL, *outfile = NULL;\\r\\nchar *signerfile = NULL, *recipfile = NULL;\\r\\nSTACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\\r\\nchar *certfile = NULL, *keyfile = NULL, *contfile = NULL;\\r\\nconst EVP_CIPHER *cipher = NULL;\\r\\nPKCS7 *p7 = NULL;\\r\\nX509_STORE *store = NULL;\\r\\nX509 *cert = NULL, *recip = NULL, *signer = NULL;\\r\\nEVP_PKEY *key = NULL;\\r\\nSTACK_OF(X509) *encerts = NULL, *other = NULL;\\r\\nBIO *in = NULL, *out = NULL, *indata = NULL;\\r\\nint badarg = 0;\\r\\nint flags = PKCS7_DETACHED;\\r\\nchar *to = NULL, *from = NULL, *subject = NULL;\\r\\nchar *CAfile = NULL, *CApath = NULL;\\r\\nchar *passargin = NULL, *passin = NULL;\\r\\nchar *inrand = NULL;\\r\\nint need_rand = 0;\\r\\nint indef = 0;\\r\\nconst EVP_MD *sign_md = NULL;\\r\\nint informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\\r\\nint keyform = FORMAT_PEM;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nX509_VERIFY_PARAM *vpm = NULL;\\r\\nargs = argv + 1;\\r\\nret = 1;\\r\\napps_startup();\\r\\nif (bio_err == NULL) {\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n}\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp(*args, \"-encrypt\"))\\r\\noperation = SMIME_ENCRYPT;\\r\\nelse if (!strcmp(*args, \"-decrypt\"))\\r\\noperation = SMIME_DECRYPT;\\r\\nelse if (!strcmp(*args, \"-sign\"))\\r\\noperation = SMIME_SIGN;\\r\\nelse if (!strcmp(*args, \"-resign\"))\\r\\noperation = SMIME_RESIGN;\\r\\nelse if (!strcmp(*args, \"-verify\"))\\r\\noperation = SMIME_VERIFY;\\r\\nelse if (!strcmp(*args, \"-pk7out\"))\\r\\noperation = SMIME_PK7OUT;\\r\\n#ifndef OPENSSL_NO_DES\\r\\nelse if (!strcmp(*args, \"-des3\"))\\r\\ncipher = EVP_des_ede3_cbc();\\r\\nelse if (!strcmp(*args, \"-des\"))\\r\\ncipher = EVP_des_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SEED\\r\\nelse if (!strcmp(*args, \"-seed\"))\\r\\ncipher = EVP_seed_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC2\\r\\nelse if (!strcmp(*args, \"-rc2-40\"))\\r\\ncipher = EVP_rc2_40_cbc();\\r\\nelse if (!strcmp(*args, \"-rc2-128\"))\\r\\ncipher = EVP_rc2_cbc();\\r\\nelse if (!strcmp(*args, \"-rc2-64\"))\\r\\ncipher = EVP_rc2_64_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nelse if (!strcmp(*args, \"-aes128\"))\\r\\ncipher = EVP_aes_128_cbc();\\r\\nelse if (!strcmp(*args, \"-aes192\"))\\r\\ncipher = EVP_aes_192_cbc();\\r\\nelse if (!strcmp(*args, \"-aes256\"))\\r\\ncipher = EVP_aes_256_cbc();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_CAMELLIA\\r\\nelse if (!strcmp(*args, \"-camellia128\"))\\r\\ncipher = EVP_camellia_128_cbc();\\r\\nelse if (!strcmp(*args, \"-camellia192\"))\\r\\ncipher = EVP_camellia_192_cbc();\\r\\nelse if (!strcmp(*args, \"-camellia256\"))\\r\\ncipher = EVP_camellia_256_cbc();\\r\\n#endif\\r\\nelse if (!strcmp(*args, \"-text\"))\\r\\nflags |= PKCS7_TEXT;\\r\\nelse if (!strcmp(*args, \"-nointern\"))\\r\\nflags |= PKCS7_NOINTERN;\\r\\nelse if (!strcmp(*args, \"-noverify\"))\\r\\nflags |= PKCS7_NOVERIFY;\\r\\nelse if (!strcmp(*args, \"-nochain\"))\\r\\nflags |= PKCS7_NOCHAIN;\\r\\nelse if (!strcmp(*args, \"-nocerts\"))\\r\\nflags |= PKCS7_NOCERTS;\\r\\nelse if (!strcmp(*args, \"-noattr\"))\\r\\nflags |= PKCS7_NOATTR;\\r\\nelse if (!strcmp(*args, \"-nodetach\"))\\r\\nflags &= ~PKCS7_DETACHED;\\r\\nelse if (!strcmp(*args, \"-nosmimecap\"))\\r\\nflags |= PKCS7_NOSMIMECAP;\\r\\nelse if (!strcmp(*args, \"-binary\"))\\r\\nflags |= PKCS7_BINARY;\\r\\nelse if (!strcmp(*args, \"-nosigs\"))\\r\\nflags |= PKCS7_NOSIGS;\\r\\nelse if (!strcmp(*args, \"-stream\"))\\r\\nindef = 1;\\r\\nelse if (!strcmp(*args, \"-indef\"))\\r\\nindef = 1;\\r\\nelse if (!strcmp(*args, \"-noindef\"))\\r\\nindef = 0;\\r\\nelse if (!strcmp(*args, \"-nooldmime\"))\\r\\nflags |= PKCS7_NOOLDMIMETYPE;\\r\\nelse if (!strcmp(*args, \"-crlfeol\"))\\r\\nflags |= PKCS7_CRLFEOL;\\r\\nelse if (!strcmp(*args, \"-rand\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nargs++;\\r\\ninrand = *args;\\r\\nneed_rand = 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (!strcmp(*args, \"-engine\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nengine = *++args;\\r\\n}\\r\\n#endif\\r\\nelse if (!strcmp(*args, \"-passin\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\npassargin = *++args;\\r\\n} else if (!strcmp(*args, \"-to\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nto = *++args;\\r\\n} else if (!strcmp(*args, \"-from\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nfrom = *++args;\\r\\n} else if (!strcmp(*args, \"-subject\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nsubject = *++args;\\r\\n} else if (!strcmp(*args, \"-signer\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nif (signerfile) {\\r\\nif (!sksigners)\\r\\nsksigners = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(sksigners, signerfile);\\r\\nif (!keyfile)\\r\\nkeyfile = signerfile;\\r\\nif (!skkeys)\\r\\nskkeys = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(skkeys, keyfile);\\r\\nkeyfile = NULL;\\r\\n}\\r\\nsignerfile = *++args;\\r\\n} else if (!strcmp(*args, \"-recip\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nrecipfile = *++args;\\r\\n} else if (!strcmp(*args, \"-md\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nsign_md = EVP_get_digestbyname(*++args);\\r\\nif (sign_md == NULL) {\\r\\nBIO_printf(bio_err, \"Unknown digest %s\\n\", *args);\\r\\ngoto argerr;\\r\\n}\\r\\n} else if (!strcmp(*args, \"-inkey\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nif (keyfile) {\\r\\nif (!signerfile) {\\r\\nBIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\\r\\ngoto argerr;\\r\\n}\\r\\nif (!sksigners)\\r\\nsksigners = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(sksigners, signerfile);\\r\\nsignerfile = NULL;\\r\\nif (!skkeys)\\r\\nskkeys = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(skkeys, keyfile);\\r\\n}\\r\\nkeyfile = *++args;\\r\\n} else if (!strcmp(*args, \"-keyform\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nkeyform = str2fmt(*++args);\\r\\n} else if (!strcmp(*args, \"-certfile\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\ncertfile = *++args;\\r\\n} else if (!strcmp(*args, \"-CAfile\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nCAfile = *++args;\\r\\n} else if (!strcmp(*args, \"-CApath\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nCApath = *++args;\\r\\n} else if (!strcmp(*args, \"-in\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\ninfile = *++args;\\r\\n} else if (!strcmp(*args, \"-inform\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\ninformat = str2fmt(*++args);\\r\\n} else if (!strcmp(*args, \"-outform\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\noutformat = str2fmt(*++args);\\r\\n} else if (!strcmp(*args, \"-out\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\noutfile = *++args;\\r\\n} else if (!strcmp(*args, \"-content\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\ncontfile = *++args;\\r\\n} else if (args_verify(&args, NULL, &badarg, bio_err, &vpm))\\r\\ncontinue;\\r\\nelse if ((cipher = EVP_get_cipherbyname(*args + 1)) == NULL)\\r\\nbadarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (!(operation & SMIME_SIGNERS) && (skkeys || sksigners)) {\\r\\nBIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\\r\\ngoto argerr;\\r\\n}\\r\\nif (operation & SMIME_SIGNERS) {\\r\\nif (keyfile && !signerfile) {\\r\\nBIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\\r\\ngoto argerr;\\r\\n}\\r\\nif (signerfile) {\\r\\nif (!sksigners)\\r\\nsksigners = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(sksigners, signerfile);\\r\\nif (!skkeys)\\r\\nskkeys = sk_OPENSSL_STRING_new_null();\\r\\nif (!keyfile)\\r\\nkeyfile = signerfile;\\r\\nsk_OPENSSL_STRING_push(skkeys, keyfile);\\r\\n}\\r\\nif (!sksigners) {\\r\\nBIO_printf(bio_err, \"No signer certificate specified\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\nsignerfile = NULL;\\r\\nkeyfile = NULL;\\r\\nneed_rand = 1;\\r\\n} else if (operation == SMIME_DECRYPT) {\\r\\nif (!recipfile && !keyfile) {\\r\\nBIO_printf(bio_err,\\r\\n\"No recipient certificate or key specified\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\n} else if (operation == SMIME_ENCRYPT) {\\r\\nif (!*args) {\\r\\nBIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\nneed_rand = 1;\\r\\n} else if (!operation)\\r\\nbadarg = 1;\\r\\nif (badarg) {\\r\\nargerr:\\r\\nBIO_printf(bio_err, \"Usage smime [options] cert.pem ...\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-encrypt encrypt message\\n\");\\r\\nBIO_printf(bio_err, \"-decrypt decrypt encrypted message\\n\");\\r\\nBIO_printf(bio_err, \"-sign sign message\\n\");\\r\\nBIO_printf(bio_err, \"-verify verify signed message\\n\");\\r\\nBIO_printf(bio_err, \"-pk7out output PKCS#7 structure\\n\");\\r\\n#ifndef OPENSSL_NO_DES\\r\\nBIO_printf(bio_err, \"-des3 encrypt with triple DES\\n\");\\r\\nBIO_printf(bio_err, \"-des encrypt with DES\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SEED\\r\\nBIO_printf(bio_err, \"-seed encrypt with SEED\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC2\\r\\nBIO_printf(bio_err, \"-rc2-40 encrypt with RC2-40 (default)\\n\");\\r\\nBIO_printf(bio_err, \"-rc2-64 encrypt with RC2-64\\n\");\\r\\nBIO_printf(bio_err, \"-rc2-128 encrypt with RC2-128\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err, \"-aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc aes\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_CAMELLIA\\r\\nBIO_printf(bio_err, \"-camellia128, -camellia192, -camellia256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc camellia\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\\r\\n\"-nointern don't search certificates in message for signer\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nosigs don't verify message signature\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-noverify don't verify signers certificate\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nocerts don't include signers certificate when signing\\n\");\\r\\nBIO_printf(bio_err, \"-nodetach use opaque signing\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-noattr don't include any signed attributes\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-binary don't translate message to text\\n\");\\r\\nBIO_printf(bio_err, \"-certfile file other certificates file\\n\");\\r\\nBIO_printf(bio_err, \"-signer file signer certificate file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-recip file recipient certificate file for decryption\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-inform arg input format SMIME (default), PEM or DER\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-inkey file input private key (if not signer or recipient)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-keyform arg input private key format (PEM or ENGINE)\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-outform arg output format SMIME (default), PEM or DER\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-content file supply or override content for detached signature\\n\");\\r\\nBIO_printf(bio_err, \"-to addr to address\\n\");\\r\\nBIO_printf(bio_err, \"-from ad from address\\n\");\\r\\nBIO_printf(bio_err, \"-subject s subject\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-text include or delete text MIME headers\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-CApath dir trusted certificates directory\\n\");\\r\\nBIO_printf(bio_err, \"-CAfile file trusted certificates file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-crl_check check revocation status of signer's certificate using CRLs\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-crl_check_all check revocation status of signer's certificate chain using CRLs\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \"-passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \"-rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\\r\\n\" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"cert.pem recipient certificate(s) for encryption\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (need_rand) {\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n}\\r\\nret = 2;\\r\\nif (!(operation & SMIME_SIGNERS))\\r\\nflags &= ~PKCS7_DETACHED;\\r\\nif (operation & SMIME_OP) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\noutmode = \"wb\";\\r\\n} else {\\r\\nif (flags & PKCS7_BINARY)\\r\\noutmode = \"wb\";\\r\\n}\\r\\nif (operation & SMIME_IP) {\\r\\nif (informat == FORMAT_ASN1)\\r\\ninmode = \"rb\";\\r\\n} else {\\r\\nif (flags & PKCS7_BINARY)\\r\\ninmode = \"rb\";\\r\\n}\\r\\nif (operation == SMIME_ENCRYPT) {\\r\\nif (!cipher) {\\r\\n#ifndef OPENSSL_NO_DES\\r\\ncipher = EVP_des_ede3_cbc();\\r\\n#else\\r\\nBIO_printf(bio_err, \"No cipher selected\\n\");\\r\\ngoto end;\\r\\n#endif\\r\\n}\\r\\nencerts = sk_X509_new_null();\\r\\nwhile (*args) {\\r\\nif (!(cert = load_cert(bio_err, *args, FORMAT_PEM,\\r\\nNULL, e, \"recipient certificate file\"))) {\\r\\n#if 0\\r\\nBIO_printf(bio_err,\\r\\n\"Can't read recipient certificate file %s\\n\",\\r\\n*args);\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\nsk_X509_push(encerts, cert);\\r\\ncert = NULL;\\r\\nargs++;\\r\\n}\\r\\n}\\r\\nif (certfile) {\\r\\nif (!(other = load_certs(bio_err, certfile, FORMAT_PEM, NULL,\\r\\ne, \"certificate file\"))) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (recipfile && (operation == SMIME_DECRYPT)) {\\r\\nif (!(recip = load_cert(bio_err, recipfile, FORMAT_PEM, NULL,\\r\\ne, \"recipient certificate file\"))) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (operation == SMIME_DECRYPT) {\\r\\nif (!keyfile)\\r\\nkeyfile = recipfile;\\r\\n} else if (operation == SMIME_SIGN) {\\r\\nif (!keyfile)\\r\\nkeyfile = signerfile;\\r\\n} else\\r\\nkeyfile = NULL;\\r\\nif (keyfile) {\\r\\nkey = load_key(bio_err, keyfile, keyform, 0, passin, e,\\r\\n\"signing key file\");\\r\\nif (!key)\\r\\ngoto end;\\r\\n}\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file(infile, inmode))) {\\r\\nBIO_printf(bio_err, \"Can't open input file %s\\n\", infile);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (operation & SMIME_IP) {\\r\\nif (informat == FORMAT_SMIME)\\r\\np7 = SMIME_read_PKCS7(in, &indata);\\r\\nelse if (informat == FORMAT_PEM)\\r\\np7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);\\r\\nelse if (informat == FORMAT_ASN1)\\r\\np7 = d2i_PKCS7_bio(in, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad input format for PKCS#7 file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!p7) {\\r\\nBIO_printf(bio_err, \"Error reading S/MIME message\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (contfile) {\\r\\nBIO_free(indata);\\r\\nif (!(indata = BIO_new_file(contfile, \"rb\"))) {\\r\\nBIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file(outfile, outmode))) {\\r\\nBIO_printf(bio_err, \"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (operation == SMIME_VERIFY) {\\r\\nif (!(store = setup_verify(bio_err, CAfile, CApath)))\\r\\ngoto end;\\r\\nX509_STORE_set_verify_cb(store, smime_cb);\\r\\nif (vpm)\\r\\nX509_STORE_set1_param(store, vpm);\\r\\n}\\r\\nret = 3;\\r\\nif (operation == SMIME_ENCRYPT) {\\r\\nif (indef)\\r\\nflags |= PKCS7_STREAM;\\r\\np7 = PKCS7_encrypt(encerts, in, cipher, flags);\\r\\n} else if (operation & SMIME_SIGNERS) {\\r\\nint i;\\r\\nif (operation == SMIME_SIGN) {\\r\\nif (flags & PKCS7_DETACHED) {\\r\\nif (outformat == FORMAT_SMIME)\\r\\nflags |= PKCS7_STREAM;\\r\\n} else if (indef)\\r\\nflags |= PKCS7_STREAM;\\r\\nflags |= PKCS7_PARTIAL;\\r\\np7 = PKCS7_sign(NULL, NULL, other, in, flags);\\r\\nif (!p7)\\r\\ngoto end;\\r\\nif (flags & PKCS7_NOCERTS) {\\r\\nfor (i = 0; i < sk_X509_num(other); i++) {\\r\\nX509 *x = sk_X509_value(other, i);\\r\\nPKCS7_add_certificate(p7, x);\\r\\n}\\r\\n}\\r\\n} else\\r\\nflags |= PKCS7_REUSE_DIGEST;\\r\\nfor (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\\r\\nsignerfile = sk_OPENSSL_STRING_value(sksigners, i);\\r\\nkeyfile = sk_OPENSSL_STRING_value(skkeys, i);\\r\\nsigner = load_cert(bio_err, signerfile, FORMAT_PEM, NULL,\\r\\ne, \"signer certificate\");\\r\\nif (!signer)\\r\\ngoto end;\\r\\nkey = load_key(bio_err, keyfile, keyform, 0, passin, e,\\r\\n\"signing key file\");\\r\\nif (!key)\\r\\ngoto end;\\r\\nif (!PKCS7_sign_add_signer(p7, signer, key, sign_md, flags))\\r\\ngoto end;\\r\\nX509_free(signer);\\r\\nsigner = NULL;\\r\\nEVP_PKEY_free(key);\\r\\nkey = NULL;\\r\\n}\\r\\nif ((operation == SMIME_SIGN) && !(flags & PKCS7_STREAM)) {\\r\\nif (!PKCS7_final(p7, in, flags))\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!p7) {\\r\\nBIO_printf(bio_err, \"Error creating PKCS#7 structure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nret = 4;\\r\\nif (operation == SMIME_DECRYPT) {\\r\\nif (!PKCS7_decrypt(p7, key, recip, out, flags)) {\\r\\nBIO_printf(bio_err, \"Error decrypting PKCS#7 structure\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else if (operation == SMIME_VERIFY) {\\r\\nSTACK_OF(X509) *signers;\\r\\nif (PKCS7_verify(p7, other, store, indata, out, flags))\\r\\nBIO_printf(bio_err, \"Verification successful\\n\");\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Verification failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nsigners = PKCS7_get0_signers(p7, other, flags);\\r\\nif (!save_certs(signerfile, signers)) {\\r\\nBIO_printf(bio_err, \"Error writing signers to %s\\n\", signerfile);\\r\\nret = 5;\\r\\ngoto end;\\r\\n}\\r\\nsk_X509_free(signers);\\r\\n} else if (operation == SMIME_PK7OUT)\\r\\nPEM_write_bio_PKCS7(out, p7);\\r\\nelse {\\r\\nif (to)\\r\\nBIO_printf(out, \"To: %s\\n\", to);\\r\\nif (from)\\r\\nBIO_printf(out, \"From: %s\\n\", from);\\r\\nif (subject)\\r\\nBIO_printf(out, \"Subject: %s\\n\", subject);\\r\\nif (outformat == FORMAT_SMIME) {\\r\\nif (operation == SMIME_RESIGN)\\r\\nSMIME_write_PKCS7(out, p7, indata, flags);\\r\\nelse\\r\\nSMIME_write_PKCS7(out, p7, in, flags);\\r\\n} else if (outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PKCS7_stream(out, p7, in, flags);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\ni2d_PKCS7_bio_stream(out, p7, in, flags);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad output format for PKCS#7 file\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (need_rand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nif (ret)\\r\\nERR_print_errors(bio_err);\\r\\nsk_X509_pop_free(encerts, X509_free);\\r\\nsk_X509_pop_free(other, X509_free);\\r\\nif (vpm)\\r\\nX509_VERIFY_PARAM_free(vpm);\\r\\nif (sksigners)\\r\\nsk_OPENSSL_STRING_free(sksigners);\\r\\nif (skkeys)\\r\\nsk_OPENSSL_STRING_free(skkeys);\\r\\nX509_STORE_free(store);\\r\\nX509_free(cert);\\r\\nX509_free(recip);\\r\\nX509_free(signer);\\r\\nEVP_PKEY_free(key);\\r\\nPKCS7_free(p7);\\r\\nBIO_free(in);\\r\\nBIO_free(indata);\\r\\nBIO_free_all(out);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int smime_cb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nint error;\\r\\nerror = X509_STORE_CTX_get_error(ctx);\\r\\nif ((error != X509_V_ERR_NO_EXPLICIT_POLICY)\\r\\n&& ((error != X509_V_OK) || (ok != 2)))\\r\\nreturn ok;\\r\\npolicies_print(NULL, ctx);\\r\\nreturn ok;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_ossl_c", "target": 1, "func": "const DSA_METHOD *DSA_OpenSSL(void)\\r\\n{\\r\\nreturn &openssl_dsa_meth;\\r\\n}\\r\\nstatic DSA_SIG *dsa_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)\\r\\n{\\r\\nBIGNUM *kinv = NULL, *r = NULL, *s = NULL;\\r\\nBIGNUM m;\\r\\nBIGNUM xr;\\r\\nBN_CTX *ctx = NULL;\\r\\nint reason = ERR_R_BN_LIB;\\r\\nDSA_SIG *ret = NULL;\\r\\nint noredo = 0;\\r\\nBN_init(&m);\\r\\nBN_init(&xr);\\r\\nif (!dsa->p || !dsa->q || !dsa->g) {\\r\\nreason = DSA_R_MISSING_PARAMETERS;\\r\\ngoto err;\\r\\n}\\r\\ns = BN_new();\\r\\nif (s == NULL)\\r\\ngoto err;\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\nredo:\\r\\nif ((dsa->kinv == NULL) || (dsa->r == NULL)) {\\r\\nif (!DSA_sign_setup(dsa, ctx, &kinv, &r))\\r\\ngoto err;\\r\\n} else {\\r\\nkinv = dsa->kinv;\\r\\ndsa->kinv = NULL;\\r\\nr = dsa->r;\\r\\ndsa->r = NULL;\\r\\nnoredo = 1;\\r\\n}\\r\\nif (dlen > BN_num_bytes(dsa->q))\\r\\ndlen = BN_num_bytes(dsa->q);\\r\\nif (BN_bin2bn(dgst, dlen, &m) == NULL)\\r\\ngoto err;\\r\\nif (!BN_mod_mul(&xr, dsa->priv_key, r, dsa->q, ctx))\\r\\ngoto err;\\r\\nif (!BN_add(s, &xr, &m))\\r\\ngoto err;\\r\\nif (BN_cmp(s, dsa->q) > 0)\\r\\nif (!BN_sub(s, s, dsa->q))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(s, s, kinv, dsa->q, ctx))\\r\\ngoto err;\\r\\nret = DSA_SIG_new();\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\nif (BN_is_zero(r) || BN_is_zero(s)) {\\r\\nif (noredo) {\\r\\nreason = DSA_R_NEED_NEW_SETUP_VALUES;\\r\\ngoto err;\\r\\n}\\r\\ngoto redo;\\r\\n}\\r\\nret->r = r;\\r\\nret->s = s;\\r\\nerr:\\r\\nif (!ret) {\\r\\nDSAerr(DSA_F_DSA_DO_SIGN, reason);\\r\\nBN_free(r);\\r\\nBN_free(s);\\r\\n}\\r\\nif (ctx != NULL)\\r\\nBN_CTX_free(ctx);\\r\\nBN_clear_free(&m);\\r\\nBN_clear_free(&xr);\\r\\nif (kinv != NULL)\\r\\nBN_clear_free(kinv);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,\\r\\nBIGNUM **rp)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM k, kq, *K, *kinv = NULL, *r = NULL;\\r\\nint ret = 0;\\r\\nif (!dsa->p || !dsa->q || !dsa->g) {\\r\\nDSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\\r\\nreturn 0;\\r\\n}\\r\\nBN_init(&k);\\r\\nBN_init(&kq);\\r\\nif (ctx_in == NULL) {\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\n} else\\r\\nctx = ctx_in;\\r\\nif ((r = BN_new()) == NULL)\\r\\ngoto err;\\r\\ndo\\r\\nif (!BN_rand_range(&k, dsa->q))\\r\\ngoto err;\\r\\nwhile (BN_is_zero(&k)) ;\\r\\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\\r\\nBN_set_flags(&k, BN_FLG_CONSTTIME);\\r\\n}\\r\\nif (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\\r\\nif (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\\r\\nCRYPTO_LOCK_DSA, dsa->p, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\\r\\nif (!BN_copy(&kq, &k))\\r\\ngoto err;\\r\\nif (!BN_add(&kq, &kq, dsa->q))\\r\\ngoto err;\\r\\nif (BN_num_bits(&kq) <= BN_num_bits(dsa->q)) {\\r\\nif (!BN_add(&kq, &kq, dsa->q))\\r\\ngoto err;\\r\\n}\\r\\nK = &kq;\\r\\n} else {\\r\\nK = &k;\\r\\n}\\r\\nDSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, K, dsa->p, ctx,\\r\\ndsa->method_mont_p);\\r\\nif (!BN_mod(r, r, dsa->q, ctx))\\r\\ngoto err;\\r\\nif ((kinv = BN_mod_inverse(NULL, &k, dsa->q, ctx)) == NULL)\\r\\ngoto err;\\r\\nif (*kinvp != NULL)\\r\\nBN_clear_free(*kinvp);\\r\\n*kinvp = kinv;\\r\\nkinv = NULL;\\r\\nif (*rp != NULL)\\r\\nBN_clear_free(*rp);\\r\\n*rp = r;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret) {\\r\\nDSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\\r\\nif (r != NULL)\\r\\nBN_clear_free(r);\\r\\n}\\r\\nif (ctx_in == NULL)\\r\\nBN_CTX_free(ctx);\\r\\nBN_clear_free(&k);\\r\\nBN_clear_free(&kq);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int dsa_do_verify(const unsigned char *dgst, int dgst_len,\\r\\nDSA_SIG *sig, DSA *dsa)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM u1, u2, t1;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nint ret = -1, i;\\r\\nif (!dsa->p || !dsa->q || !dsa->g) {\\r\\nDSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_MISSING_PARAMETERS);\\r\\nreturn -1;\\r\\n}\\r\\ni = BN_num_bits(dsa->q);\\r\\nif (i != 160 && i != 224 && i != 256) {\\r\\nDSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_BAD_Q_VALUE);\\r\\nreturn -1;\\r\\n}\\r\\nif (BN_num_bits(dsa->p) > OPENSSL_DSA_MAX_MODULUS_BITS) {\\r\\nDSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_MODULUS_TOO_LARGE);\\r\\nreturn -1;\\r\\n}\\r\\nBN_init(&u1);\\r\\nBN_init(&u2);\\r\\nBN_init(&t1);\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (BN_is_zero(sig->r) || BN_is_negative(sig->r) ||\\r\\nBN_ucmp(sig->r, dsa->q) >= 0) {\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_zero(sig->s) || BN_is_negative(sig->s) ||\\r\\nBN_ucmp(sig->s, dsa->q) >= 0) {\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nif ((BN_mod_inverse(&u2, sig->s, dsa->q, ctx)) == NULL)\\r\\ngoto err;\\r\\nif (dgst_len > (i >> 3))\\r\\ndgst_len = (i >> 3);\\r\\nif (BN_bin2bn(dgst, dgst_len, &u1) == NULL)\\r\\ngoto err;\\r\\nif (!BN_mod_mul(&u1, &u1, &u2, dsa->q, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(&u2, sig->r, &u2, dsa->q, ctx))\\r\\ngoto err;\\r\\nif (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\\r\\nmont = BN_MONT_CTX_set_locked(&dsa->method_mont_p,\\r\\nCRYPTO_LOCK_DSA, dsa->p, ctx);\\r\\nif (!mont)\\r\\ngoto err;\\r\\n}\\r\\nDSA_MOD_EXP(goto err, dsa, &t1, dsa->g, &u1, dsa->pub_key, &u2, dsa->p,\\r\\nctx, mont);\\r\\nif (!BN_mod(&u1, &t1, dsa->q, ctx))\\r\\ngoto err;\\r\\nret = (BN_ucmp(&u1, sig->r) == 0);\\r\\nerr:\\r\\nif (ret < 0)\\r\\nDSAerr(DSA_F_DSA_DO_VERIFY, ERR_R_BN_LIB);\\r\\nif (ctx != NULL)\\r\\nBN_CTX_free(ctx);\\r\\nBN_free(&u1);\\r\\nBN_free(&u2);\\r\\nBN_free(&t1);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int dsa_init(DSA *dsa)\\r\\n{\\r\\ndsa->flags |= DSA_FLAG_CACHE_MONT_P;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int dsa_finish(DSA *dsa)\\r\\n{\\r\\nif (dsa->method_mont_p)\\r\\nBN_MONT_CTX_free(dsa->method_mont_p);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_server-arg_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nchar *port = \"*:4433\";\\r\\nBIO *ssl_bio, *tmp;\\r\\nSSL_CTX *ctx;\\r\\nSSL_CONF_CTX *cctx;\\r\\nchar buf[512];\\r\\nBIO *in = NULL;\\r\\nint ret = 1, i;\\r\\nchar **args = argv + 1;\\r\\nint nargs = argc - 1;\\r\\nSSL_load_error_strings();\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nctx = SSL_CTX_new(SSLv23_server_method());\\r\\ncctx = SSL_CONF_CTX_new();\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_SERVER);\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CERTIFICATE);\\r\\nSSL_CONF_CTX_set_ssl_ctx(cctx, ctx);\\r\\nwhile (*args && **args == '-') {\\r\\nint rv;\\r\\nrv = SSL_CONF_cmd_argv(cctx, &nargs, &args);\\r\\nif (rv == -3) {\\r\\nfprintf(stderr, \"Missing argument for %s\\n\", *args);\\r\\ngoto err;\\r\\n}\\r\\nif (rv < 0) {\\r\\nfprintf(stderr, \"Error in command %s\\n\", *args);\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto err;\\r\\n}\\r\\nif (rv > 0)\\r\\ncontinue;\\r\\nif (!strcmp(*args, \"-port\")) {\\r\\nport = args[1];\\r\\nif (port == NULL) {\\r\\nfprintf(stderr, \"Missing -port argument\\n\");\\r\\ngoto err;\\r\\n}\\r\\nargs += 2;\\r\\nnargs -= 2;\\r\\ncontinue;\\r\\n} else {\\r\\nfprintf(stderr, \"Unknown argument %s\\n\", *args);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!SSL_CONF_CTX_finish(cctx)) {\\r\\nfprintf(stderr, \"Finish error\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto err;\\r\\n}\\r\\n#if 0\\r\\n{\\r\\nX509 *x;\\r\\nint rv;\\r\\nrv = SSL_CTX_set_current_cert(ctx, SSL_CERT_SET_FIRST);\\r\\nwhile (rv) {\\r\\nX509 *x = SSL_CTX_get0_certificate(ctx);\\r\\nX509_NAME_print_ex_fp(stdout, X509_get_subject_name(x), 0,\\r\\nXN_FLAG_ONELINE);\\r\\nprintf(\"\\n\");\\r\\nrv = SSL_CTX_set_current_cert(ctx, SSL_CERT_SET_NEXT);\\r\\n}\\r\\nfflush(stdout);\\r\\n}\\r\\n#endif\\r\\nssl_bio = BIO_new_ssl(ctx, 0);\\r\\nif ((in = BIO_new_accept(port)) == NULL)\\r\\ngoto err;\\r\\nBIO_set_accept_bios(in, ssl_bio);\\r\\nagain:\\r\\nif (BIO_do_accept(in) <= 0)\\r\\ngoto err;\\r\\nfor (;;) {\\r\\ni = BIO_read(in, buf, 512);\\r\\nif (i == 0) {\\r\\nprintf(\"Done\\n\");\\r\\ntmp = BIO_pop(in);\\r\\nBIO_free_all(tmp);\\r\\ngoto again;\\r\\n}\\r\\nif (i < 0)\\r\\ngoto err;\\r\\nfwrite(buf, 1, i, stdout);\\r\\nfflush(stdout);\\r\\n}\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nexit(ret);\\r\\nreturn (!ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_des_enc_c", "target": 0, "func": "void DES_encrypt1(DES_LONG *data, DES_key_schedule *ks, int enc)\\r\\n{\\r\\nregister DES_LONG l, r, t, u;\\r\\n#ifdef DES_PTR\\r\\nregister const unsigned char *des_SP = (const unsigned char *)DES_SPtrans;\\r\\n#endif\\r\\n#ifndef DES_UNROLL\\r\\nregister int i;\\r\\n#endif\\r\\nregister DES_LONG *s;\\r\\nr = data[0];\\r\\nl = data[1];\\r\\nIP(r, l);\\r\\nr = ROTATE(r, 29) & 0xffffffffL;\\r\\nl = ROTATE(l, 29) & 0xffffffffL;\\r\\ns = ks->ks->deslong;\\r\\nif (enc) {\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l, r, 0);\\r\\nD_ENCRYPT(r, l, 2);\\r\\nD_ENCRYPT(l, r, 4);\\r\\nD_ENCRYPT(r, l, 6);\\r\\nD_ENCRYPT(l, r, 8);\\r\\nD_ENCRYPT(r, l, 10);\\r\\nD_ENCRYPT(l, r, 12);\\r\\nD_ENCRYPT(r, l, 14);\\r\\nD_ENCRYPT(l, r, 16);\\r\\nD_ENCRYPT(r, l, 18);\\r\\nD_ENCRYPT(l, r, 20);\\r\\nD_ENCRYPT(r, l, 22);\\r\\nD_ENCRYPT(l, r, 24);\\r\\nD_ENCRYPT(r, l, 26);\\r\\nD_ENCRYPT(l, r, 28);\\r\\nD_ENCRYPT(r, l, 30);\\r\\n#else\\r\\nfor (i = 0; i < 32; i += 4) {\\r\\nD_ENCRYPT(l, r, i + 0);\\r\\nD_ENCRYPT(r, l, i + 2);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l, r, 30);\\r\\nD_ENCRYPT(r, l, 28);\\r\\nD_ENCRYPT(l, r, 26);\\r\\nD_ENCRYPT(r, l, 24);\\r\\nD_ENCRYPT(l, r, 22);\\r\\nD_ENCRYPT(r, l, 20);\\r\\nD_ENCRYPT(l, r, 18);\\r\\nD_ENCRYPT(r, l, 16);\\r\\nD_ENCRYPT(l, r, 14);\\r\\nD_ENCRYPT(r, l, 12);\\r\\nD_ENCRYPT(l, r, 10);\\r\\nD_ENCRYPT(r, l, 8);\\r\\nD_ENCRYPT(l, r, 6);\\r\\nD_ENCRYPT(r, l, 4);\\r\\nD_ENCRYPT(l, r, 2);\\r\\nD_ENCRYPT(r, l, 0);\\r\\n#else\\r\\nfor (i = 30; i > 0; i -= 4) {\\r\\nD_ENCRYPT(l, r, i - 0);\\r\\nD_ENCRYPT(r, l, i - 2);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nl = ROTATE(l, 3) & 0xffffffffL;\\r\\nr = ROTATE(r, 3) & 0xffffffffL;\\r\\nFP(r, l);\\r\\ndata[0] = l;\\r\\ndata[1] = r;\\r\\nl = r = t = u = 0;\\r\\n}\\r\\nvoid DES_encrypt2(DES_LONG *data, DES_key_schedule *ks, int enc)\\r\\n{\\r\\nregister DES_LONG l, r, t, u;\\r\\n#ifdef DES_PTR\\r\\nregister const unsigned char *des_SP = (const unsigned char *)DES_SPtrans;\\r\\n#endif\\r\\n#ifndef DES_UNROLL\\r\\nregister int i;\\r\\n#endif\\r\\nregister DES_LONG *s;\\r\\nr = data[0];\\r\\nl = data[1];\\r\\nr = ROTATE(r, 29) & 0xffffffffL;\\r\\nl = ROTATE(l, 29) & 0xffffffffL;\\r\\ns = ks->ks->deslong;\\r\\nif (enc) {\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l, r, 0);\\r\\nD_ENCRYPT(r, l, 2);\\r\\nD_ENCRYPT(l, r, 4);\\r\\nD_ENCRYPT(r, l, 6);\\r\\nD_ENCRYPT(l, r, 8);\\r\\nD_ENCRYPT(r, l, 10);\\r\\nD_ENCRYPT(l, r, 12);\\r\\nD_ENCRYPT(r, l, 14);\\r\\nD_ENCRYPT(l, r, 16);\\r\\nD_ENCRYPT(r, l, 18);\\r\\nD_ENCRYPT(l, r, 20);\\r\\nD_ENCRYPT(r, l, 22);\\r\\nD_ENCRYPT(l, r, 24);\\r\\nD_ENCRYPT(r, l, 26);\\r\\nD_ENCRYPT(l, r, 28);\\r\\nD_ENCRYPT(r, l, 30);\\r\\n#else\\r\\nfor (i = 0; i < 32; i += 4) {\\r\\nD_ENCRYPT(l, r, i + 0);\\r\\nD_ENCRYPT(r, l, i + 2);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\n#ifdef DES_UNROLL\\r\\nD_ENCRYPT(l, r, 30);\\r\\nD_ENCRYPT(r, l, 28);\\r\\nD_ENCRYPT(l, r, 26);\\r\\nD_ENCRYPT(r, l, 24);\\r\\nD_ENCRYPT(l, r, 22);\\r\\nD_ENCRYPT(r, l, 20);\\r\\nD_ENCRYPT(l, r, 18);\\r\\nD_ENCRYPT(r, l, 16);\\r\\nD_ENCRYPT(l, r, 14);\\r\\nD_ENCRYPT(r, l, 12);\\r\\nD_ENCRYPT(l, r, 10);\\r\\nD_ENCRYPT(r, l, 8);\\r\\nD_ENCRYPT(l, r, 6);\\r\\nD_ENCRYPT(r, l, 4);\\r\\nD_ENCRYPT(l, r, 2);\\r\\nD_ENCRYPT(r, l, 0);\\r\\n#else\\r\\nfor (i = 30; i > 0; i -= 4) {\\r\\nD_ENCRYPT(l, r, i - 0);\\r\\nD_ENCRYPT(r, l, i - 2);\\r\\n}\\r\\n#endif\\r\\n}\\r\\ndata[0] = ROTATE(l, 3) & 0xffffffffL;\\r\\ndata[1] = ROTATE(r, 3) & 0xffffffffL;\\r\\nl = r = t = u = 0;\\r\\n}\\r\\nvoid DES_encrypt3(DES_LONG *data, DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2, DES_key_schedule *ks3)\\r\\n{\\r\\nregister DES_LONG l, r;\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nIP(l, r);\\r\\ndata[0] = l;\\r\\ndata[1] = r;\\r\\nDES_encrypt2((DES_LONG *)data, ks1, DES_ENCRYPT);\\r\\nDES_encrypt2((DES_LONG *)data, ks2, DES_DECRYPT);\\r\\nDES_encrypt2((DES_LONG *)data, ks3, DES_ENCRYPT);\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nFP(r, l);\\r\\ndata[0] = l;\\r\\ndata[1] = r;\\r\\n}\\r\\nvoid DES_decrypt3(DES_LONG *data, DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2, DES_key_schedule *ks3)\\r\\n{\\r\\nregister DES_LONG l, r;\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nIP(l, r);\\r\\ndata[0] = l;\\r\\ndata[1] = r;\\r\\nDES_encrypt2((DES_LONG *)data, ks3, DES_DECRYPT);\\r\\nDES_encrypt2((DES_LONG *)data, ks2, DES_ENCRYPT);\\r\\nDES_encrypt2((DES_LONG *)data, ks1, DES_DECRYPT);\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nFP(r, l);\\r\\ndata[0] = l;\\r\\ndata[1] = r;\\r\\n}\\r\\nvoid DES_ede3_cbc_encrypt(const unsigned char *input, unsigned char *output,\\r\\nlong length, DES_key_schedule *ks1,\\r\\nDES_key_schedule *ks2, DES_key_schedule *ks3,\\r\\nDES_cblock *ivec, int enc)\\r\\n{\\r\\nregister DES_LONG tin0, tin1;\\r\\nregister DES_LONG tout0, tout1, xor0, xor1;\\r\\nregister const unsigned char *in;\\r\\nunsigned char *out;\\r\\nregister long l = length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *iv;\\r\\nin = input;\\r\\nout = output;\\r\\niv = &(*ivec)[0];\\r\\nif (enc) {\\r\\nc2l(iv, tout0);\\r\\nc2l(iv, tout1);\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nc2l(in, tin0);\\r\\nc2l(in, tin1);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nDES_encrypt3((DES_LONG *)tin, ks1, ks2, ks3);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\nl2c(tout0, out);\\r\\nl2c(tout1, out);\\r\\n}\\r\\nif (l != -8) {\\r\\nc2ln(in, tin0, tin1, l + 8);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nDES_encrypt3((DES_LONG *)tin, ks1, ks2, ks3);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\nl2c(tout0, out);\\r\\nl2c(tout1, out);\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(tout0, iv);\\r\\nl2c(tout1, iv);\\r\\n} else {\\r\\nregister DES_LONG t0, t1;\\r\\nc2l(iv, xor0);\\r\\nc2l(iv, xor1);\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nc2l(in, tin0);\\r\\nc2l(in, tin1);\\r\\nt0 = tin0;\\r\\nt1 = tin1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nDES_decrypt3((DES_LONG *)tin, ks1, ks2, ks3);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\ntout0 ^= xor0;\\r\\ntout1 ^= xor1;\\r\\nl2c(tout0, out);\\r\\nl2c(tout1, out);\\r\\nxor0 = t0;\\r\\nxor1 = t1;\\r\\n}\\r\\nif (l != -8) {\\r\\nc2l(in, tin0);\\r\\nc2l(in, tin1);\\r\\nt0 = tin0;\\r\\nt1 = tin1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nDES_decrypt3((DES_LONG *)tin, ks1, ks2, ks3);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\ntout0 ^= xor0;\\r\\ntout1 ^= xor1;\\r\\nl2cn(tout0, tout1, out, l + 8);\\r\\nxor0 = t0;\\r\\nxor1 = t1;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(xor0, iv);\\r\\nl2c(xor1, iv);\\r\\n}\\r\\ntin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;\\r\\ntin[0] = tin[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_print_c", "target": 0, "func": "int ASN1_PRINTABLE_type(const unsigned char *s, int len)\\r\\n{\\r\\nint c;\\r\\nint ia5 = 0;\\r\\nint t61 = 0;\\r\\nif (len <= 0)\\r\\nlen = -1;\\r\\nif (s == NULL)\\r\\nreturn (V_ASN1_PRINTABLESTRING);\\r\\nwhile ((*s) && (len-- != 0)) {\\r\\nc = *(s++);\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!(((c >= 'a') && (c <= 'z')) ||\\r\\n((c >= 'A') && (c <= 'Z')) ||\\r\\n(c == ' ') ||\\r\\n((c >= '0') && (c <= '9')) ||\\r\\n(c == ' ') || (c == '\\'') ||\\r\\n(c == '(') || (c == ')') ||\\r\\n(c == '+') || (c == ',') ||\\r\\n(c == '-') || (c == '.') ||\\r\\n(c == '/') || (c == ':') || (c == '=') || (c == '?')))\\r\\nia5 = 1;\\r\\nif (c & 0x80)\\r\\nt61 = 1;\\r\\n#else\\r\\nif (!isalnum(c) && (c != ' ') && strchr(\"'()+,-./:=?\", c) == NULL)\\r\\nia5 = 1;\\r\\nif (os_toascii[c] & 0x80)\\r\\nt61 = 1;\\r\\n#endif\\r\\n}\\r\\nif (t61)\\r\\nreturn (V_ASN1_T61STRING);\\r\\nif (ia5)\\r\\nreturn (V_ASN1_IA5STRING);\\r\\nreturn (V_ASN1_PRINTABLESTRING);\\r\\n}\\r\\nint ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s)\\r\\n{\\r\\nint i;\\r\\nunsigned char *p;\\r\\nif (s->type != V_ASN1_UNIVERSALSTRING)\\r\\nreturn (0);\\r\\nif ((s->length % 4) != 0)\\r\\nreturn (0);\\r\\np = s->data;\\r\\nfor (i = 0; i < s->length; i += 4) {\\r\\nif ((p[0] != '\\0') || (p[1] != '\\0') || (p[2] != '\\0'))\\r\\nbreak;\\r\\nelse\\r\\np += 4;\\r\\n}\\r\\nif (i < s->length)\\r\\nreturn (0);\\r\\np = s->data;\\r\\nfor (i = 3; i < s->length; i += 4) {\\r\\n*(p++) = s->data[i];\\r\\n}\\r\\n*(p) = '\\0';\\r\\ns->length /= 4;\\r\\ns->type = ASN1_PRINTABLE_type(s->data, s->length);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_hm_pmeth_c", "target": 0, "func": "static int pkey_hmac_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nHMAC_PKEY_CTX *hctx;\\r\\nhctx = OPENSSL_malloc(sizeof(HMAC_PKEY_CTX));\\r\\nif (!hctx)\\r\\nreturn 0;\\r\\nhctx->md = NULL;\\r\\nhctx->ktmp.data = NULL;\\r\\nhctx->ktmp.length = 0;\\r\\nhctx->ktmp.flags = 0;\\r\\nhctx->ktmp.type = V_ASN1_OCTET_STRING;\\r\\nHMAC_CTX_init(&hctx->ctx);\\r\\nctx->data = hctx;\\r\\nctx->keygen_info_count = 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_hmac_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)\\r\\n{\\r\\nHMAC_PKEY_CTX *sctx, *dctx;\\r\\nif (!pkey_hmac_init(dst))\\r\\nreturn 0;\\r\\nsctx = src->data;\\r\\ndctx = dst->data;\\r\\ndctx->md = sctx->md;\\r\\nHMAC_CTX_init(&dctx->ctx);\\r\\nif (!HMAC_CTX_copy(&dctx->ctx, &sctx->ctx))\\r\\nreturn 0;\\r\\nif (sctx->ktmp.data) {\\r\\nif (!ASN1_OCTET_STRING_set(&dctx->ktmp,\\r\\nsctx->ktmp.data, sctx->ktmp.length))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void pkey_hmac_cleanup(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nHMAC_PKEY_CTX *hctx = ctx->data;\\r\\nHMAC_CTX_cleanup(&hctx->ctx);\\r\\nif (hctx->ktmp.data) {\\r\\nif (hctx->ktmp.length)\\r\\nOPENSSL_cleanse(hctx->ktmp.data, hctx->ktmp.length);\\r\\nOPENSSL_free(hctx->ktmp.data);\\r\\nhctx->ktmp.data = NULL;\\r\\n}\\r\\nOPENSSL_free(hctx);\\r\\n}\\r\\nstatic int pkey_hmac_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nASN1_OCTET_STRING *hkey = NULL;\\r\\nHMAC_PKEY_CTX *hctx = ctx->data;\\r\\nif (!hctx->ktmp.data)\\r\\nreturn 0;\\r\\nhkey = ASN1_OCTET_STRING_dup(&hctx->ktmp);\\r\\nif (!hkey)\\r\\nreturn 0;\\r\\nEVP_PKEY_assign(pkey, EVP_PKEY_HMAC, hkey);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nHMAC_PKEY_CTX *hctx = ctx->pctx->data;\\r\\nif (!HMAC_Update(&hctx->ctx, data, count))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int hmac_signctx_init(EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx)\\r\\n{\\r\\nHMAC_PKEY_CTX *hctx = ctx->data;\\r\\nHMAC_CTX_set_flags(&hctx->ctx, mctx->flags & ~EVP_MD_CTX_FLAG_NO_INIT);\\r\\nEVP_MD_CTX_set_flags(mctx, EVP_MD_CTX_FLAG_NO_INIT);\\r\\nmctx->update = int_update;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int hmac_signctx(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,\\r\\nEVP_MD_CTX *mctx)\\r\\n{\\r\\nunsigned int hlen;\\r\\nHMAC_PKEY_CTX *hctx = ctx->data;\\r\\nint l = EVP_MD_CTX_size(mctx);\\r\\nif (l < 0)\\r\\nreturn 0;\\r\\n*siglen = l;\\r\\nif (!sig)\\r\\nreturn 1;\\r\\nif (!HMAC_Final(&hctx->ctx, sig, &hlen))\\r\\nreturn 0;\\r\\n*siglen = (size_t)hlen;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_hmac_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)\\r\\n{\\r\\nHMAC_PKEY_CTX *hctx = ctx->data;\\r\\nASN1_OCTET_STRING *key;\\r\\nswitch (type) {\\r\\ncase EVP_PKEY_CTRL_SET_MAC_KEY:\\r\\nif ((!p2 && p1 > 0) || (p1 < -1))\\r\\nreturn 0;\\r\\nif (!ASN1_OCTET_STRING_set(&hctx->ktmp, p2, p1))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase EVP_PKEY_CTRL_MD:\\r\\nhctx->md = p2;\\r\\nbreak;\\r\\ncase EVP_PKEY_CTRL_DIGESTINIT:\\r\\nkey = (ASN1_OCTET_STRING *)ctx->pkey->pkey.ptr;\\r\\nif (!HMAC_Init_ex(&hctx->ctx, key->data, key->length, hctx->md,\\r\\nctx->engine))\\r\\nreturn 0;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_hmac_ctrl_str(EVP_PKEY_CTX *ctx,\\r\\nconst char *type, const char *value)\\r\\n{\\r\\nif (!value) {\\r\\nreturn 0;\\r\\n}\\r\\nif (!strcmp(type, \"key\")) {\\r\\nvoid *p = (void *)value;\\r\\nreturn pkey_hmac_ctrl(ctx, EVP_PKEY_CTRL_SET_MAC_KEY, -1, p);\\r\\n}\\r\\nif (!strcmp(type, \"hexkey\")) {\\r\\nunsigned char *key;\\r\\nint r;\\r\\nlong keylen;\\r\\nkey = string_to_hex(value, &keylen);\\r\\nif (!key)\\r\\nreturn 0;\\r\\nr = pkey_hmac_ctrl(ctx, EVP_PKEY_CTRL_SET_MAC_KEY, keylen, key);\\r\\nOPENSSL_free(key);\\r\\nreturn r;\\r\\n}\\r\\nreturn -2;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_by_file_c", "target": 0, "func": "X509_LOOKUP_METHOD *X509_LOOKUP_file(void)\\r\\n{\\r\\nreturn (&x509_file_lookup);\\r\\n}\\r\\nstatic int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp,\\r\\nlong argl, char **ret)\\r\\n{\\r\\nint ok = 0;\\r\\nchar *file;\\r\\nswitch (cmd) {\\r\\ncase X509_L_FILE_LOAD:\\r\\nif (argl == X509_FILETYPE_DEFAULT) {\\r\\nfile = (char *)getenv(X509_get_default_cert_file_env());\\r\\nif (file)\\r\\nok = (X509_load_cert_crl_file(ctx, file,\\r\\nX509_FILETYPE_PEM) != 0);\\r\\nelse\\r\\nok = (X509_load_cert_crl_file\\r\\n(ctx, X509_get_default_cert_file(),\\r\\nX509_FILETYPE_PEM) != 0);\\r\\nif (!ok) {\\r\\nX509err(X509_F_BY_FILE_CTRL, X509_R_LOADING_DEFAULTS);\\r\\n}\\r\\n} else {\\r\\nif (argl == X509_FILETYPE_PEM)\\r\\nok = (X509_load_cert_crl_file(ctx, argp,\\r\\nX509_FILETYPE_PEM) != 0);\\r\\nelse\\r\\nok = (X509_load_cert_file(ctx, argp, (int)argl) != 0);\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn (ok);\\r\\n}\\r\\nint X509_load_cert_file(X509_LOOKUP *ctx, const char *file, int type)\\r\\n{\\r\\nint ret = 0;\\r\\nBIO *in = NULL;\\r\\nint i, count = 0;\\r\\nX509 *x = NULL;\\r\\nif (file == NULL)\\r\\nreturn (1);\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif ((in == NULL) || (BIO_read_filename(in, file) <= 0)) {\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE, ERR_R_SYS_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (type == X509_FILETYPE_PEM) {\\r\\nfor (;;) {\\r\\nx = PEM_read_bio_X509_AUX(in, NULL, NULL, NULL);\\r\\nif (x == NULL) {\\r\\nif ((ERR_GET_REASON(ERR_peek_last_error()) ==\\r\\nPEM_R_NO_START_LINE) && (count > 0)) {\\r\\nERR_clear_error();\\r\\nbreak;\\r\\n} else {\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE, ERR_R_PEM_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ni = X509_STORE_add_cert(ctx->store_ctx, x);\\r\\nif (!i)\\r\\ngoto err;\\r\\ncount++;\\r\\nX509_free(x);\\r\\nx = NULL;\\r\\n}\\r\\nret = count;\\r\\n} else if (type == X509_FILETYPE_ASN1) {\\r\\nx = d2i_X509_bio(in, NULL);\\r\\nif (x == NULL) {\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\ni = X509_STORE_add_cert(ctx->store_ctx, x);\\r\\nif (!i)\\r\\ngoto err;\\r\\nret = i;\\r\\n} else {\\r\\nX509err(X509_F_X509_LOAD_CERT_FILE, X509_R_BAD_X509_FILETYPE);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (x != NULL)\\r\\nX509_free(x);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (ret);\\r\\n}\\r\\nint X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type)\\r\\n{\\r\\nint ret = 0;\\r\\nBIO *in = NULL;\\r\\nint i, count = 0;\\r\\nX509_CRL *x = NULL;\\r\\nif (file == NULL)\\r\\nreturn (1);\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif ((in == NULL) || (BIO_read_filename(in, file) <= 0)) {\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE, ERR_R_SYS_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (type == X509_FILETYPE_PEM) {\\r\\nfor (;;) {\\r\\nx = PEM_read_bio_X509_CRL(in, NULL, NULL, NULL);\\r\\nif (x == NULL) {\\r\\nif ((ERR_GET_REASON(ERR_peek_last_error()) ==\\r\\nPEM_R_NO_START_LINE) && (count > 0)) {\\r\\nERR_clear_error();\\r\\nbreak;\\r\\n} else {\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE, ERR_R_PEM_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ni = X509_STORE_add_crl(ctx->store_ctx, x);\\r\\nif (!i)\\r\\ngoto err;\\r\\ncount++;\\r\\nX509_CRL_free(x);\\r\\nx = NULL;\\r\\n}\\r\\nret = count;\\r\\n} else if (type == X509_FILETYPE_ASN1) {\\r\\nx = d2i_X509_CRL_bio(in, NULL);\\r\\nif (x == NULL) {\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\ni = X509_STORE_add_crl(ctx->store_ctx, x);\\r\\nif (!i)\\r\\ngoto err;\\r\\nret = i;\\r\\n} else {\\r\\nX509err(X509_F_X509_LOAD_CRL_FILE, X509_R_BAD_X509_FILETYPE);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (x != NULL)\\r\\nX509_CRL_free(x);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (ret);\\r\\n}\\r\\nint X509_load_cert_crl_file(X509_LOOKUP *ctx, const char *file, int type)\\r\\n{\\r\\nSTACK_OF(X509_INFO) *inf;\\r\\nX509_INFO *itmp;\\r\\nBIO *in;\\r\\nint i, count = 0;\\r\\nif (type != X509_FILETYPE_PEM)\\r\\nreturn X509_load_cert_file(ctx, file, type);\\r\\nin = BIO_new_file(file, \"r\");\\r\\nif (!in) {\\r\\nX509err(X509_F_X509_LOAD_CERT_CRL_FILE, ERR_R_SYS_LIB);\\r\\nreturn 0;\\r\\n}\\r\\ninf = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL);\\r\\nBIO_free(in);\\r\\nif (!inf) {\\r\\nX509err(X509_F_X509_LOAD_CERT_CRL_FILE, ERR_R_PEM_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_X509_INFO_num(inf); i++) {\\r\\nitmp = sk_X509_INFO_value(inf, i);\\r\\nif (itmp->x509) {\\r\\nX509_STORE_add_cert(ctx->store_ctx, itmp->x509);\\r\\ncount++;\\r\\n}\\r\\nif (itmp->crl) {\\r\\nX509_STORE_add_crl(ctx->store_ctx, itmp->crl);\\r\\ncount++;\\r\\n}\\r\\n}\\r\\nsk_X509_INFO_pop_free(inf, X509_INFO_free);\\r\\nreturn count;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_smdec_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL;\\r\\nX509 *rcert = NULL;\\r\\nEVP_PKEY *rkey = NULL;\\r\\nPKCS7 *p7 = NULL;\\r\\nint ret = 1;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\ntbio = BIO_new_file(\"signer.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nrcert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nBIO_reset(tbio);\\r\\nrkey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);\\r\\nif (!rcert || !rkey)\\r\\ngoto err;\\r\\nin = BIO_new_file(\"smencr.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\np7 = SMIME_read_PKCS7(in, NULL);\\r\\nif (!p7)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"encrout.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!PKCS7_decrypt(p7, rkey, rcert, out, 0))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Signing Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (p7)\\r\\nPKCS7_free(p7);\\r\\nif (rcert)\\r\\nX509_free(rcert);\\r\\nif (rkey)\\r\\nEVP_PKEY_free(rkey);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_utl_c", "target": 0, "func": "void X509V3_conf_free(CONF_VALUE *conf)\\r\\n{\\r\\nif (!conf)\\r\\nreturn;\\r\\nif (conf->name)\\r\\nOPENSSL_free(conf->name);\\r\\nif (conf->value)\\r\\nOPENSSL_free(conf->value);\\r\\nif (conf->section)\\r\\nOPENSSL_free(conf->section);\\r\\nOPENSSL_free(conf);\\r\\n}\\r\\nchar *i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *method, ASN1_ENUMERATED *a)\\r\\n{\\r\\nBIGNUM *bntmp = NULL;\\r\\nchar *strtmp = NULL;\\r\\nif (!a)\\r\\nreturn NULL;\\r\\nif (!(bntmp = ASN1_ENUMERATED_to_BN(a, NULL)) ||\\r\\n!(strtmp = BN_bn2dec(bntmp)))\\r\\nX509V3err(X509V3_F_I2S_ASN1_ENUMERATED, ERR_R_MALLOC_FAILURE);\\r\\nBN_free(bntmp);\\r\\nreturn strtmp;\\r\\n}\\r\\nchar *i2s_ASN1_INTEGER(X509V3_EXT_METHOD *method, ASN1_INTEGER *a)\\r\\n{\\r\\nBIGNUM *bntmp = NULL;\\r\\nchar *strtmp = NULL;\\r\\nif (!a)\\r\\nreturn NULL;\\r\\nif (!(bntmp = ASN1_INTEGER_to_BN(a, NULL)) ||\\r\\n!(strtmp = BN_bn2dec(bntmp)))\\r\\nX509V3err(X509V3_F_I2S_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);\\r\\nBN_free(bntmp);\\r\\nreturn strtmp;\\r\\n}\\r\\nASN1_INTEGER *s2i_ASN1_INTEGER(X509V3_EXT_METHOD *method, char *value)\\r\\n{\\r\\nBIGNUM *bn = NULL;\\r\\nASN1_INTEGER *aint;\\r\\nint isneg, ishex;\\r\\nint ret;\\r\\nif (!value) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_INTEGER, X509V3_R_INVALID_NULL_VALUE);\\r\\nreturn 0;\\r\\n}\\r\\nbn = BN_new();\\r\\nif (value[0] == '-') {\\r\\nvalue++;\\r\\nisneg = 1;\\r\\n} else\\r\\nisneg = 0;\\r\\nif (value[0] == '0' && ((value[1] == 'x') || (value[1] == 'X'))) {\\r\\nvalue += 2;\\r\\nishex = 1;\\r\\n} else\\r\\nishex = 0;\\r\\nif (ishex)\\r\\nret = BN_hex2bn(&bn, value);\\r\\nelse\\r\\nret = BN_dec2bn(&bn, value);\\r\\nif (!ret || value[ret]) {\\r\\nBN_free(bn);\\r\\nX509V3err(X509V3_F_S2I_ASN1_INTEGER, X509V3_R_BN_DEC2BN_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (isneg && BN_is_zero(bn))\\r\\nisneg = 0;\\r\\naint = BN_to_ASN1_INTEGER(bn, NULL);\\r\\nBN_free(bn);\\r\\nif (!aint) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_INTEGER,\\r\\nX509V3_R_BN_TO_ASN1_INTEGER_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (isneg)\\r\\naint->type |= V_ASN1_NEG;\\r\\nreturn aint;\\r\\n}\\r\\nint X509V3_get_value_bool(CONF_VALUE *value, int *asn1_bool)\\r\\n{\\r\\nchar *btmp;\\r\\nif (!(btmp = value->value))\\r\\ngoto err;\\r\\nif (!strcmp(btmp, \"TRUE\") || !strcmp(btmp, \"true\")\\r\\n|| !strcmp(btmp, \"Y\") || !strcmp(btmp, \"y\")\\r\\n|| !strcmp(btmp, \"YES\") || !strcmp(btmp, \"yes\")) {\\r\\n*asn1_bool = 0xff;\\r\\nreturn 1;\\r\\n} else if (!strcmp(btmp, \"FALSE\") || !strcmp(btmp, \"false\")\\r\\n|| !strcmp(btmp, \"N\") || !strcmp(btmp, \"n\")\\r\\n|| !strcmp(btmp, \"NO\") || !strcmp(btmp, \"no\")) {\\r\\n*asn1_bool = 0;\\r\\nreturn 1;\\r\\n}\\r\\nerr:\\r\\nX509V3err(X509V3_F_X509V3_GET_VALUE_BOOL,\\r\\nX509V3_R_INVALID_BOOLEAN_STRING);\\r\\nX509V3_conf_err(value);\\r\\nreturn 0;\\r\\n}\\r\\nint X509V3_get_value_int(CONF_VALUE *value, ASN1_INTEGER **aint)\\r\\n{\\r\\nASN1_INTEGER *itmp;\\r\\nif (!(itmp = s2i_ASN1_INTEGER(NULL, value->value))) {\\r\\nX509V3_conf_err(value);\\r\\nreturn 0;\\r\\n}\\r\\n*aint = itmp;\\r\\nreturn 1;\\r\\n}\\r\\nchar *strip_spaces(char *name)\\r\\n{\\r\\nchar *p, *q;\\r\\np = name;\\r\\nwhile (*p && isspace((unsigned char)*p))\\r\\np++;\\r\\nif (!*p)\\r\\nreturn NULL;\\r\\nq = p + strlen(p) - 1;\\r\\nwhile ((q != p) && isspace((unsigned char)*q))\\r\\nq--;\\r\\nif (p != q)\\r\\nq[1] = 0;\\r\\nif (!*p)\\r\\nreturn NULL;\\r\\nreturn p;\\r\\n}\\r\\nchar *hex_to_string(const unsigned char *buffer, long len)\\r\\n{\\r\\nchar *tmp, *q;\\r\\nconst unsigned char *p;\\r\\nint i;\\r\\nconst static char hexdig[] = \"0123456789ABCDEF\";\\r\\nif (!buffer || !len)\\r\\nreturn NULL;\\r\\nif (!(tmp = OPENSSL_malloc(len * 3 + 1))) {\\r\\nX509V3err(X509V3_F_HEX_TO_STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nq = tmp;\\r\\nfor (i = 0, p = buffer; i < len; i++, p++) {\\r\\n*q++ = hexdig[(*p >> 4) & 0xf];\\r\\n*q++ = hexdig[*p & 0xf];\\r\\n*q++ = ':';\\r\\n}\\r\\nq[-1] = 0;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(tmp, tmp, q - tmp - 1);\\r\\n#endif\\r\\nreturn tmp;\\r\\n}\\r\\nunsigned char *string_to_hex(const char *str, long *len)\\r\\n{\\r\\nunsigned char *hexbuf, *q;\\r\\nunsigned char ch, cl, *p;\\r\\nif (!str) {\\r\\nX509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_INVALID_NULL_ARGUMENT);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(hexbuf = OPENSSL_malloc(strlen(str) >> 1)))\\r\\ngoto err;\\r\\nfor (p = (unsigned char *)str, q = hexbuf; *p;) {\\r\\nch = *p++;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nch = os_toebcdic[ch];\\r\\n#endif\\r\\nif (ch == ':')\\r\\ncontinue;\\r\\ncl = *p++;\\r\\n#ifdef CHARSET_EBCDIC\\r\\ncl = os_toebcdic[cl];\\r\\n#endif\\r\\nif (!cl) {\\r\\nX509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_ODD_NUMBER_OF_DIGITS);\\r\\nOPENSSL_free(hexbuf);\\r\\nreturn NULL;\\r\\n}\\r\\nif (isupper(ch))\\r\\nch = tolower(ch);\\r\\nif (isupper(cl))\\r\\ncl = tolower(cl);\\r\\nif ((ch >= '0') && (ch <= '9'))\\r\\nch -= '0';\\r\\nelse if ((ch >= 'a') && (ch <= 'f'))\\r\\nch -= 'a' - 10;\\r\\nelse\\r\\ngoto badhex;\\r\\nif ((cl >= '0') && (cl <= '9'))\\r\\ncl -= '0';\\r\\nelse if ((cl >= 'a') && (cl <= 'f'))\\r\\ncl -= 'a' - 10;\\r\\nelse\\r\\ngoto badhex;\\r\\n*q++ = (ch << 4) | cl;\\r\\n}\\r\\nif (len)\\r\\n*len = q - hexbuf;\\r\\nreturn hexbuf;\\r\\nerr:\\r\\nif (hexbuf)\\r\\nOPENSSL_free(hexbuf);\\r\\nX509V3err(X509V3_F_STRING_TO_HEX, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\nbadhex:\\r\\nOPENSSL_free(hexbuf);\\r\\nX509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_ILLEGAL_HEX_DIGIT);\\r\\nreturn NULL;\\r\\n}\\r\\nint name_cmp(const char *name, const char *cmp)\\r\\n{\\r\\nint len, ret;\\r\\nchar c;\\r\\nlen = strlen(cmp);\\r\\nif ((ret = strncmp(name, cmp, len)))\\r\\nreturn ret;\\r\\nc = name[len];\\r\\nif (!c || (c == '.'))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int sk_strcmp(const char *const *a, const char *const *b)\\r\\n{\\r\\nreturn strcmp(*a, *b);\\r\\n}\\r\\nvoid str_free(OPENSSL_STRING str)\\r\\n{\\r\\nOPENSSL_free(str);\\r\\n}\\r\\nstatic void skip_prefix(const unsigned char **p, size_t *plen,\\r\\nconst unsigned char *subject, size_t subject_len,\\r\\nunsigned int flags)\\r\\n{\\r\\nconst unsigned char *pattern = *p;\\r\\nsize_t pattern_len = *plen;\\r\\nif ((flags & _X509_CHECK_FLAG_DOT_SUBDOMAINS) == 0)\\r\\nreturn;\\r\\nwhile (pattern_len > subject_len && *pattern) {\\r\\nif ((flags & X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS) &&\\r\\n*pattern == '.')\\r\\nbreak;\\r\\n++pattern;\\r\\n--pattern_len;\\r\\n}\\r\\nif (pattern_len == subject_len) {\\r\\n*p = pattern;\\r\\n*plen = pattern_len;\\r\\n}\\r\\n}\\r\\nstatic int equal_nocase(const unsigned char *pattern, size_t pattern_len,\\r\\nconst unsigned char *subject, size_t subject_len,\\r\\nunsigned int flags)\\r\\n{\\r\\nskip_prefix(&pattern, &pattern_len, subject, subject_len, flags);\\r\\nif (pattern_len != subject_len)\\r\\nreturn 0;\\r\\nwhile (pattern_len) {\\r\\nunsigned char l = *pattern;\\r\\nunsigned char r = *subject;\\r\\nif (l == 0)\\r\\nreturn 0;\\r\\nif (l != r) {\\r\\nif ('A' <= l && l <= 'Z')\\r\\nl = (l - 'A') + 'a';\\r\\nif ('A' <= r && r <= 'Z')\\r\\nr = (r - 'A') + 'a';\\r\\nif (l != r)\\r\\nreturn 0;\\r\\n}\\r\\n++pattern;\\r\\n++subject;\\r\\n--pattern_len;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int equal_case(const unsigned char *pattern, size_t pattern_len,\\r\\nconst unsigned char *subject, size_t subject_len,\\r\\nunsigned int flags)\\r\\n{\\r\\nskip_prefix(&pattern, &pattern_len, subject, subject_len, flags);\\r\\nif (pattern_len != subject_len)\\r\\nreturn 0;\\r\\nreturn !memcmp(pattern, subject, pattern_len);\\r\\n}\\r\\nstatic int equal_email(const unsigned char *a, size_t a_len,\\r\\nconst unsigned char *b, size_t b_len,\\r\\nunsigned int unused_flags)\\r\\n{\\r\\nsize_t i = a_len;\\r\\nif (a_len != b_len)\\r\\nreturn 0;\\r\\nwhile (i > 0) {\\r\\n--i;\\r\\nif (a[i] == '@' || b[i] == '@') {\\r\\nif (!equal_nocase(a + i, a_len - i, b + i, a_len - i, 0))\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (i == 0)\\r\\ni = a_len;\\r\\nreturn equal_case(a, i, b, i, 0);\\r\\n}\\r\\nstatic int wildcard_match(const unsigned char *prefix, size_t prefix_len,\\r\\nconst unsigned char *suffix, size_t suffix_len,\\r\\nconst unsigned char *subject, size_t subject_len,\\r\\nunsigned int flags)\\r\\n{\\r\\nconst unsigned char *wildcard_start;\\r\\nconst unsigned char *wildcard_end;\\r\\nconst unsigned char *p;\\r\\nint allow_multi = 0;\\r\\nint allow_idna = 0;\\r\\nif (subject_len < prefix_len + suffix_len)\\r\\nreturn 0;\\r\\nif (!equal_nocase(prefix, prefix_len, subject, prefix_len, flags))\\r\\nreturn 0;\\r\\nwildcard_start = subject + prefix_len;\\r\\nwildcard_end = subject + (subject_len - suffix_len);\\r\\nif (!equal_nocase(wildcard_end, suffix_len, suffix, suffix_len, flags))\\r\\nreturn 0;\\r\\nif (prefix_len == 0 && *suffix == '.') {\\r\\nif (wildcard_start == wildcard_end)\\r\\nreturn 0;\\r\\nallow_idna = 1;\\r\\nif (flags & X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS)\\r\\nallow_multi = 1;\\r\\n}\\r\\nif (!allow_idna &&\\r\\nsubject_len >= 4 && strncasecmp((char *)subject, \"xn--\", 4) == 0)\\r\\nreturn 0;\\r\\nif (wildcard_end == wildcard_start + 1 && *wildcard_start == '*')\\r\\nreturn 1;\\r\\nfor (p = wildcard_start; p != wildcard_end; ++p)\\r\\nif (!(('0' <= *p && *p <= '9') ||\\r\\n('A' <= *p && *p <= 'Z') ||\\r\\n('a' <= *p && *p <= 'z') ||\\r\\n*p == '-' || (allow_multi && *p == '.')))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic const unsigned char *valid_star(const unsigned char *p, size_t len,\\r\\nunsigned int flags)\\r\\n{\\r\\nconst unsigned char *star = 0;\\r\\nsize_t i;\\r\\nint state = LABEL_START;\\r\\nint dots = 0;\\r\\nfor (i = 0; i < len; ++i) {\\r\\nif (p[i] == '*') {\\r\\nint atstart = (state & LABEL_START);\\r\\nint atend = (i == len - 1 || p[i + i] == '.');\\r\\nif (star != NULL || (state & LABEL_IDNA) != 0 || dots)\\r\\nreturn NULL;\\r\\nif ((flags & X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS)\\r\\n&& (!atstart || !atend))\\r\\nreturn NULL;\\r\\nif (!atstart && !atend)\\r\\nreturn NULL;\\r\\nstar = &p[i];\\r\\nstate &= ~LABEL_START;\\r\\n} else if (('a' <= p[i] && p[i] <= 'z')\\r\\n|| ('A' <= p[i] && p[i] <= 'Z')\\r\\n|| ('0' <= p[i] && p[i] <= '9')) {\\r\\nif ((state & LABEL_START) != 0\\r\\n&& len - i >= 4 && strncasecmp((char *)&p[i], \"xn--\", 4) == 0)\\r\\nstate |= LABEL_IDNA;\\r\\nstate &= ~(LABEL_HYPHEN | LABEL_START);\\r\\n} else if (p[i] == '.') {\\r\\nif ((state & (LABEL_HYPHEN | LABEL_START)) != 0)\\r\\nreturn NULL;\\r\\nstate = LABEL_START;\\r\\n++dots;\\r\\n} else if (p[i] == '-') {\\r\\nif ((state & LABEL_HYPHEN) != 0)\\r\\nreturn NULL;\\r\\nstate |= LABEL_HYPHEN;\\r\\n} else\\r\\nreturn NULL;\\r\\n}\\r\\nif ((state & (LABEL_START | LABEL_HYPHEN)) != 0 || dots < 2)\\r\\nreturn NULL;\\r\\nreturn star;\\r\\n}\\r\\nstatic int equal_wildcard(const unsigned char *pattern, size_t pattern_len,\\r\\nconst unsigned char *subject, size_t subject_len,\\r\\nunsigned int flags)\\r\\n{\\r\\nconst unsigned char *star = NULL;\\r\\nif (!(subject_len > 1 && subject[0] == '.'))\\r\\nstar = valid_star(pattern, pattern_len, flags);\\r\\nif (star == NULL)\\r\\nreturn equal_nocase(pattern, pattern_len,\\r\\nsubject, subject_len, flags);\\r\\nreturn wildcard_match(pattern, star - pattern,\\r\\nstar + 1, (pattern + pattern_len) - star - 1,\\r\\nsubject, subject_len, flags);\\r\\n}\\r\\nstatic int do_check_string(ASN1_STRING *a, int cmp_type, equal_fn equal,\\r\\nunsigned int flags, const char *b, size_t blen,\\r\\nchar **peername)\\r\\n{\\r\\nint rv = 0;\\r\\nif (!a->data || !a->length)\\r\\nreturn 0;\\r\\nif (cmp_type > 0) {\\r\\nif (cmp_type != a->type)\\r\\nreturn 0;\\r\\nif (cmp_type == V_ASN1_IA5STRING)\\r\\nrv = equal(a->data, a->length, (unsigned char *)b, blen, flags);\\r\\nelse if (a->length == (int)blen && !memcmp(a->data, b, blen))\\r\\nrv = 1;\\r\\nif (rv > 0 && peername)\\r\\n*peername = BUF_strndup((char *)a->data, a->length);\\r\\n} else {\\r\\nint astrlen;\\r\\nunsigned char *astr;\\r\\nastrlen = ASN1_STRING_to_UTF8(&astr, a);\\r\\nif (astrlen < 0)\\r\\nreturn -1;\\r\\nrv = equal(astr, astrlen, (unsigned char *)b, blen, flags);\\r\\nif (rv > 0 && peername)\\r\\n*peername = BUF_strndup((char *)astr, astrlen);\\r\\nOPENSSL_free(astr);\\r\\n}\\r\\nreturn rv;\\r\\n}\\r\\nstatic int do_x509_check(X509 *x, const char *chk, size_t chklen,\\r\\nunsigned int flags, int check_type, char **peername)\\r\\n{\\r\\nGENERAL_NAMES *gens = NULL;\\r\\nX509_NAME *name = NULL;\\r\\nint i;\\r\\nint cnid;\\r\\nint alt_type;\\r\\nint san_present = 0;\\r\\nint rv = 0;\\r\\nequal_fn equal;\\r\\nflags &= ~_X509_CHECK_FLAG_DOT_SUBDOMAINS;\\r\\nif (check_type == GEN_EMAIL) {\\r\\ncnid = NID_pkcs9_emailAddress;\\r\\nalt_type = V_ASN1_IA5STRING;\\r\\nequal = equal_email;\\r\\n} else if (check_type == GEN_DNS) {\\r\\ncnid = NID_commonName;\\r\\nif (chklen > 1 && chk[0] == '.')\\r\\nflags |= _X509_CHECK_FLAG_DOT_SUBDOMAINS;\\r\\nalt_type = V_ASN1_IA5STRING;\\r\\nif (flags & X509_CHECK_FLAG_NO_WILDCARDS)\\r\\nequal = equal_nocase;\\r\\nelse\\r\\nequal = equal_wildcard;\\r\\n} else {\\r\\ncnid = 0;\\r\\nalt_type = V_ASN1_OCTET_STRING;\\r\\nequal = equal_case;\\r\\n}\\r\\nif (chklen == 0)\\r\\nchklen = strlen(chk);\\r\\ngens = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);\\r\\nif (gens) {\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {\\r\\nGENERAL_NAME *gen;\\r\\nASN1_STRING *cstr;\\r\\ngen = sk_GENERAL_NAME_value(gens, i);\\r\\nif (gen->type != check_type)\\r\\ncontinue;\\r\\nsan_present = 1;\\r\\nif (check_type == GEN_EMAIL)\\r\\ncstr = gen->d.rfc822Name;\\r\\nelse if (check_type == GEN_DNS)\\r\\ncstr = gen->d.dNSName;\\r\\nelse\\r\\ncstr = gen->d.iPAddress;\\r\\nif ((rv = do_check_string(cstr, alt_type, equal, flags,\\r\\nchk, chklen, peername)) != 0)\\r\\nbreak;\\r\\n}\\r\\nGENERAL_NAMES_free(gens);\\r\\nif (rv != 0)\\r\\nreturn rv;\\r\\nif (!cnid\\r\\n|| (san_present\\r\\n&& !(flags & X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT)))\\r\\nreturn 0;\\r\\n}\\r\\ni = -1;\\r\\nname = X509_get_subject_name(x);\\r\\nwhile ((i = X509_NAME_get_index_by_NID(name, cnid, i)) >= 0) {\\r\\nX509_NAME_ENTRY *ne;\\r\\nASN1_STRING *str;\\r\\nne = X509_NAME_get_entry(name, i);\\r\\nstr = X509_NAME_ENTRY_get_data(ne);\\r\\nif ((rv = do_check_string(str, -1, equal, flags,\\r\\nchk, chklen, peername)) != 0)\\r\\nreturn rv;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint X509_check_host(X509 *x, const char *chk, size_t chklen,\\r\\nunsigned int flags, char **peername)\\r\\n{\\r\\nif (chk == NULL)\\r\\nreturn -2;\\r\\nif (chklen == 0)\\r\\nchklen = strlen(chk);\\r\\nelse if (memchr(chk, '\\0', chklen > 1 ? chklen - 1 : chklen))\\r\\nreturn -2;\\r\\nif (chklen > 1 && chk[chklen - 1] == '\\0')\\r\\n--chklen;\\r\\nreturn do_x509_check(x, chk, chklen, flags, GEN_DNS, peername);\\r\\n}\\r\\nint X509_check_email(X509 *x, const char *chk, size_t chklen,\\r\\nunsigned int flags)\\r\\n{\\r\\nif (chk == NULL)\\r\\nreturn -2;\\r\\nif (chklen == 0)\\r\\nchklen = strlen((char *)chk);\\r\\nelse if (memchr(chk, '\\0', chklen > 1 ? chklen - 1 : chklen))\\r\\nreturn -2;\\r\\nif (chklen > 1 && chk[chklen - 1] == '\\0')\\r\\n--chklen;\\r\\nreturn do_x509_check(x, chk, chklen, flags, GEN_EMAIL, NULL);\\r\\n}\\r\\nint X509_check_ip(X509 *x, const unsigned char *chk, size_t chklen,\\r\\nunsigned int flags)\\r\\n{\\r\\nif (chk == NULL)\\r\\nreturn -2;\\r\\nreturn do_x509_check(x, (char *)chk, chklen, flags, GEN_IPADD, NULL);\\r\\n}\\r\\nint X509_check_ip_asc(X509 *x, const char *ipasc, unsigned int flags)\\r\\n{\\r\\nunsigned char ipout[16];\\r\\nsize_t iplen;\\r\\nif (ipasc == NULL)\\r\\nreturn -2;\\r\\niplen = (size_t)a2i_ipadd(ipout, ipasc);\\r\\nif (iplen == 0)\\r\\nreturn -2;\\r\\nreturn do_x509_check(x, (char *)ipout, iplen, flags, GEN_IPADD, NULL);\\r\\n}\\r\\nASN1_OCTET_STRING *a2i_IPADDRESS(const char *ipasc)\\r\\n{\\r\\nunsigned char ipout[16];\\r\\nASN1_OCTET_STRING *ret;\\r\\nint iplen;\\r\\niplen = a2i_ipadd(ipout, ipasc);\\r\\nif (!iplen)\\r\\nreturn NULL;\\r\\nret = ASN1_OCTET_STRING_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!ASN1_OCTET_STRING_set(ret, ipout, iplen)) {\\r\\nASN1_OCTET_STRING_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc)\\r\\n{\\r\\nASN1_OCTET_STRING *ret = NULL;\\r\\nunsigned char ipout[32];\\r\\nchar *iptmp = NULL, *p;\\r\\nint iplen1, iplen2;\\r\\np = strchr(ipasc, '/');\\r\\nif (!p)\\r\\nreturn NULL;\\r\\niptmp = BUF_strdup(ipasc);\\r\\nif (!iptmp)\\r\\nreturn NULL;\\r\\np = iptmp + (p - ipasc);\\r\\n*p++ = 0;\\r\\niplen1 = a2i_ipadd(ipout, iptmp);\\r\\nif (!iplen1)\\r\\ngoto err;\\r\\niplen2 = a2i_ipadd(ipout + iplen1, p);\\r\\nOPENSSL_free(iptmp);\\r\\niptmp = NULL;\\r\\nif (!iplen2 || (iplen1 != iplen2))\\r\\ngoto err;\\r\\nret = ASN1_OCTET_STRING_new();\\r\\nif (!ret)\\r\\ngoto err;\\r\\nif (!ASN1_OCTET_STRING_set(ret, ipout, iplen1 + iplen2))\\r\\ngoto err;\\r\\nreturn ret;\\r\\nerr:\\r\\nif (iptmp)\\r\\nOPENSSL_free(iptmp);\\r\\nif (ret)\\r\\nASN1_OCTET_STRING_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nint a2i_ipadd(unsigned char *ipout, const char *ipasc)\\r\\n{\\r\\nif (strchr(ipasc, ':')) {\\r\\nif (!ipv6_from_asc(ipout, ipasc))\\r\\nreturn 0;\\r\\nreturn 16;\\r\\n} else {\\r\\nif (!ipv4_from_asc(ipout, ipasc))\\r\\nreturn 0;\\r\\nreturn 4;\\r\\n}\\r\\n}\\r\\nstatic int ipv4_from_asc(unsigned char *v4, const char *in)\\r\\n{\\r\\nint a0, a1, a2, a3;\\r\\nif (sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4)\\r\\nreturn 0;\\r\\nif ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255)\\r\\n|| (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))\\r\\nreturn 0;\\r\\nv4[0] = a0;\\r\\nv4[1] = a1;\\r\\nv4[2] = a2;\\r\\nv4[3] = a3;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ipv6_from_asc(unsigned char *v6, const char *in)\\r\\n{\\r\\nIPV6_STAT v6stat;\\r\\nv6stat.total = 0;\\r\\nv6stat.zero_pos = -1;\\r\\nv6stat.zero_cnt = 0;\\r\\nif (!CONF_parse_list(in, ':', 0, ipv6_cb, &v6stat))\\r\\nreturn 0;\\r\\nif (v6stat.zero_pos == -1) {\\r\\nif (v6stat.total != 16)\\r\\nreturn 0;\\r\\n} else {\\r\\nif (v6stat.total == 16)\\r\\nreturn 0;\\r\\nif (v6stat.zero_cnt > 3)\\r\\nreturn 0;\\r\\nelse if (v6stat.zero_cnt == 3) {\\r\\nif (v6stat.total > 0)\\r\\nreturn 0;\\r\\n}\\r\\nelse if (v6stat.zero_cnt == 2) {\\r\\nif ((v6stat.zero_pos != 0)\\r\\n&& (v6stat.zero_pos != v6stat.total))\\r\\nreturn 0;\\r\\n} else\\r\\n{\\r\\nif ((v6stat.zero_pos == 0)\\r\\n|| (v6stat.zero_pos == v6stat.total))\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (v6stat.zero_pos >= 0) {\\r\\nmemcpy(v6, v6stat.tmp, v6stat.zero_pos);\\r\\nmemset(v6 + v6stat.zero_pos, 0, 16 - v6stat.total);\\r\\nif (v6stat.total != v6stat.zero_pos)\\r\\nmemcpy(v6 + v6stat.zero_pos + 16 - v6stat.total,\\r\\nv6stat.tmp + v6stat.zero_pos,\\r\\nv6stat.total - v6stat.zero_pos);\\r\\n} else\\r\\nmemcpy(v6, v6stat.tmp, 16);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ipv6_cb(const char *elem, int len, void *usr)\\r\\n{\\r\\nIPV6_STAT *s = usr;\\r\\nif (s->total == 16)\\r\\nreturn 0;\\r\\nif (len == 0) {\\r\\nif (s->zero_pos == -1)\\r\\ns->zero_pos = s->total;\\r\\nelse if (s->zero_pos != s->total)\\r\\nreturn 0;\\r\\ns->zero_cnt++;\\r\\n} else {\\r\\nif (len > 4) {\\r\\nif (s->total > 12)\\r\\nreturn 0;\\r\\nif (elem[len])\\r\\nreturn 0;\\r\\nif (!ipv4_from_asc(s->tmp + s->total, elem))\\r\\nreturn 0;\\r\\ns->total += 4;\\r\\n} else {\\r\\nif (!ipv6_hex(s->tmp + s->total, elem, len))\\r\\nreturn 0;\\r\\ns->total += 2;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ipv6_hex(unsigned char *out, const char *in, int inlen)\\r\\n{\\r\\nunsigned char c;\\r\\nunsigned int num = 0;\\r\\nif (inlen > 4)\\r\\nreturn 0;\\r\\nwhile (inlen--) {\\r\\nc = *in++;\\r\\nnum <<= 4;\\r\\nif ((c >= '0') && (c <= '9'))\\r\\nnum |= c - '0';\\r\\nelse if ((c >= 'A') && (c <= 'F'))\\r\\nnum |= c - 'A' + 10;\\r\\nelse if ((c >= 'a') && (c <= 'f'))\\r\\nnum |= c - 'a' + 10;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nout[0] = num >> 8;\\r\\nout[1] = num & 0xff;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_prn_c", "target": 0, "func": "int DSA_print_fp(FILE *fp, const DSA *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nDSAerr(DSA_F_DSA_PRINT_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = DSA_print(b, x, off);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint DSAparams_print_fp(FILE *fp, const DSA *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nDSAerr(DSA_F_DSAPARAMS_PRINT_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = DSAparams_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint DSA_print(BIO *bp, const DSA *x, int off)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret;\\r\\npk = EVP_PKEY_new();\\r\\nif (!pk || !EVP_PKEY_set1_DSA(pk, (DSA *)x))\\r\\nreturn 0;\\r\\nret = EVP_PKEY_print_private(bp, pk, off, NULL);\\r\\nEVP_PKEY_free(pk);\\r\\nreturn ret;\\r\\n}\\r\\nint DSAparams_print(BIO *bp, const DSA *x)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret;\\r\\npk = EVP_PKEY_new();\\r\\nif (!pk || !EVP_PKEY_set1_DSA(pk, (DSA *)x))\\r\\nreturn 0;\\r\\nret = EVP_PKEY_print_params(bp, pk, 4, NULL);\\r\\nEVP_PKEY_free(pk);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_m_wp_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn WHIRLPOOL_Init(ctx->md_data);\\r\\n}\\r\\nstatic int update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn WHIRLPOOL_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn WHIRLPOOL_Final(md, ctx->md_data);\\r\\n}\\r\\nconst EVP_MD *EVP_whirlpool(void)\\r\\n{\\r\\nreturn (&whirlpool_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc5ofb64_c", "target": 0, "func": "void RC5_32_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC5_32_KEY *schedule,\\r\\nunsigned char *ivec, int *num)\\r\\n{\\r\\nregister unsigned long v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv;\\r\\nint save = 0;\\r\\niv = (unsigned char *)ivec;\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\ndp = (char *)d;\\r\\nl2c(v0, dp);\\r\\nl2c(v1, dp);\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nRC5_32_encrypt((unsigned long *)ti, schedule);\\r\\ndp = (char *)d;\\r\\nt = ti[0];\\r\\nl2c(t, dp);\\r\\nt = ti[1];\\r\\nl2c(t, dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++) = *(in++) ^ d[n];\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\nif (save) {\\r\\nv0 = ti[0];\\r\\nv1 = ti[1];\\r\\niv = (unsigned char *)ivec;\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\n}\\r\\nt = v0 = v1 = ti[0] = ti[1] = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_o_fips_c", "target": 0, "func": "int FIPS_mode(void)\\r\\n{\\r\\nOPENSSL_init();\\r\\n#ifdef OPENSSL_FIPS\\r\\nreturn FIPS_module_mode();\\r\\n#else\\r\\nreturn 0;\\r\\n#endif\\r\\n}\\r\\nint FIPS_mode_set(int r)\\r\\n{\\r\\nOPENSSL_init();\\r\\n#ifdef OPENSSL_FIPS\\r\\n# ifndef FIPS_AUTH_USER_PASS\\r\\n# define FIPS_AUTH_USER_PASS \"Default FIPS Crypto User Password\"\\r\\n# endif\\r\\nif (!FIPS_module_mode_set(r, FIPS_AUTH_USER_PASS))\\r\\nreturn 0;\\r\\nif (r)\\r\\nRAND_set_rand_method(FIPS_rand_get_method());\\r\\nelse\\r\\nRAND_set_rand_method(NULL);\\r\\nreturn 1;\\r\\n#else\\r\\nif (r == 0)\\r\\nreturn 1;\\r\\nCRYPTOerr(CRYPTO_F_FIPS_MODE_SET, CRYPTO_R_FIPS_MODE_NOT_SUPPORTED);\\r\\nreturn 0;\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_key_c", "target": 0, "func": "int PKCS12_key_gen_asc(const char *pass, int passlen, unsigned char *salt,\\r\\nint saltlen, int id, int iter, int n,\\r\\nunsigned char *out, const EVP_MD *md_type)\\r\\n{\\r\\nint ret;\\r\\nunsigned char *unipass;\\r\\nint uniplen;\\r\\nif (!pass) {\\r\\nunipass = NULL;\\r\\nuniplen = 0;\\r\\n} else if (!OPENSSL_asc2uni(pass, passlen, &unipass, &uniplen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_ASC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nret = PKCS12_key_gen_uni(unipass, uniplen, salt, saltlen,\\r\\nid, iter, n, out, md_type);\\r\\nif (ret <= 0)\\r\\nreturn 0;\\r\\nif (unipass) {\\r\\nOPENSSL_cleanse(unipass, uniplen);\\r\\nOPENSSL_free(unipass);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint PKCS12_key_gen_uni(unsigned char *pass, int passlen, unsigned char *salt,\\r\\nint saltlen, int id, int iter, int n,\\r\\nunsigned char *out, const EVP_MD *md_type)\\r\\n{\\r\\nunsigned char *B, *D, *I, *p, *Ai;\\r\\nint Slen, Plen, Ilen, Ijlen;\\r\\nint i, j, u, v;\\r\\nint ret = 0;\\r\\nBIGNUM *Ij, *Bpl1;\\r\\nEVP_MD_CTX ctx;\\r\\n#ifdef DEBUG_KEYGEN\\r\\nunsigned char *tmpout = out;\\r\\nint tmpn = n;\\r\\n#endif\\r\\n#if 0\\r\\nif (!pass) {\\r\\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_UNI, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nEVP_MD_CTX_init(&ctx);\\r\\n#ifdef DEBUG_KEYGEN\\r\\nfprintf(stderr, \"KEYGEN DEBUG\\n\");\\r\\nfprintf(stderr, \"ID %d, ITER %d\\n\", id, iter);\\r\\nfprintf(stderr, \"Password (length %d):\\n\", passlen);\\r\\nh__dump(pass, passlen);\\r\\nfprintf(stderr, \"Salt (length %d):\\n\", saltlen);\\r\\nh__dump(salt, saltlen);\\r\\n#endif\\r\\nv = EVP_MD_block_size(md_type);\\r\\nu = EVP_MD_size(md_type);\\r\\nif (u < 0)\\r\\nreturn 0;\\r\\nD = OPENSSL_malloc(v);\\r\\nAi = OPENSSL_malloc(u);\\r\\nB = OPENSSL_malloc(v + 1);\\r\\nSlen = v * ((saltlen + v - 1) / v);\\r\\nif (passlen)\\r\\nPlen = v * ((passlen + v - 1) / v);\\r\\nelse\\r\\nPlen = 0;\\r\\nIlen = Slen + Plen;\\r\\nI = OPENSSL_malloc(Ilen);\\r\\nIj = BN_new();\\r\\nBpl1 = BN_new();\\r\\nif (!D || !Ai || !B || !I || !Ij || !Bpl1)\\r\\ngoto err;\\r\\nfor (i = 0; i < v; i++)\\r\\nD[i] = id;\\r\\np = I;\\r\\nfor (i = 0; i < Slen; i++)\\r\\n*p++ = salt[i % saltlen];\\r\\nfor (i = 0; i < Plen; i++)\\r\\n*p++ = pass[i % passlen];\\r\\nfor (;;) {\\r\\nif (!EVP_DigestInit_ex(&ctx, md_type, NULL)\\r\\n|| !EVP_DigestUpdate(&ctx, D, v)\\r\\n|| !EVP_DigestUpdate(&ctx, I, Ilen)\\r\\n|| !EVP_DigestFinal_ex(&ctx, Ai, NULL))\\r\\ngoto err;\\r\\nfor (j = 1; j < iter; j++) {\\r\\nif (!EVP_DigestInit_ex(&ctx, md_type, NULL)\\r\\n|| !EVP_DigestUpdate(&ctx, Ai, u)\\r\\n|| !EVP_DigestFinal_ex(&ctx, Ai, NULL))\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(out, Ai, min(n, u));\\r\\nif (u >= n) {\\r\\n#ifdef DEBUG_KEYGEN\\r\\nfprintf(stderr, \"Output KEY (length %d)\\n\", tmpn);\\r\\nh__dump(tmpout, tmpn);\\r\\n#endif\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nn -= u;\\r\\nout += u;\\r\\nfor (j = 0; j < v; j++)\\r\\nB[j] = Ai[j % u];\\r\\nif (!BN_bin2bn(B, v, Bpl1))\\r\\ngoto err;\\r\\nif (!BN_add_word(Bpl1, 1))\\r\\ngoto err;\\r\\nfor (j = 0; j < Ilen; j += v) {\\r\\nif (!BN_bin2bn(I + j, v, Ij))\\r\\ngoto err;\\r\\nif (!BN_add(Ij, Ij, Bpl1))\\r\\ngoto err;\\r\\nif (!BN_bn2bin(Ij, B))\\r\\ngoto err;\\r\\nIjlen = BN_num_bytes(Ij);\\r\\nif (Ijlen > v) {\\r\\nif (!BN_bn2bin(Ij, B))\\r\\ngoto err;\\r\\nmemcpy(I + j, B + 1, v);\\r\\n#ifndef PKCS12_BROKEN_KEYGEN\\r\\n} else if (Ijlen < v) {\\r\\nmemset(I + j, 0, v - Ijlen);\\r\\nif (!BN_bn2bin(Ij, I + j + v - Ijlen))\\r\\ngoto err;\\r\\n#endif\\r\\n} else if (!BN_bn2bin(Ij, I + j))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nerr:\\r\\nPKCS12err(PKCS12_F_PKCS12_KEY_GEN_UNI, ERR_R_MALLOC_FAILURE);\\r\\nend:\\r\\nOPENSSL_free(Ai);\\r\\nOPENSSL_free(B);\\r\\nOPENSSL_free(D);\\r\\nOPENSSL_free(I);\\r\\nBN_free(Ij);\\r\\nBN_free(Bpl1);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn ret;\\r\\n}\\r\\nvoid h__dump(unsigned char *p, int len)\\r\\n{\\r\\nfor (; len--; p++)\\r\\nfprintf(stderr, \"%02X\", *p);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pkcs8_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nchar **args, *infile = NULL, *outfile = NULL;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint topk8 = 0;\\r\\nint pbe_nid = -1;\\r\\nconst EVP_CIPHER *cipher = NULL;\\r\\nint iter = PKCS12_DEFAULT_ITER;\\r\\nint informat, outformat;\\r\\nint p8_broken = PKCS8_OK;\\r\\nint nocrypt = 0;\\r\\nX509_SIG *p8 = NULL;\\r\\nPKCS8_PRIV_KEY_INFO *p8inf = NULL;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nchar pass[50], *passin = NULL, *passout = NULL, *p8pass = NULL;\\r\\nint badarg = 0;\\r\\nint ret = 1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nERR_load_crypto_strings();\\r\\nOpenSSL_add_all_algorithms();\\r\\nargs = argv + 1;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp(*args, \"-v2\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ncipher = EVP_get_cipherbyname(*args);\\r\\nif (!cipher) {\\r\\nBIO_printf(bio_err, \"Unknown cipher %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-v1\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\npbe_nid = OBJ_txt2nid(*args);\\r\\nif (pbe_nid == NID_undef) {\\r\\nBIO_printf(bio_err, \"Unknown PBE algorithm %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-v2prf\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\npbe_nid = OBJ_txt2nid(*args);\\r\\nif (!EVP_PBE_find(EVP_PBE_TYPE_PRF, pbe_nid, NULL, NULL, 0)) {\\r\\nBIO_printf(bio_err, \"Unknown PRF algorithm %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-inform\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninformat = str2fmt(*args);\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-outform\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutformat = str2fmt(*args);\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-topk8\"))\\r\\ntopk8 = 1;\\r\\nelse if (!strcmp(*args, \"-noiter\"))\\r\\niter = 1;\\r\\nelse if (!strcmp(*args, \"-nocrypt\"))\\r\\nnocrypt = 1;\\r\\nelse if (!strcmp(*args, \"-nooct\"))\\r\\np8_broken = PKCS8_NO_OCTET;\\r\\nelse if (!strcmp(*args, \"-nsdb\"))\\r\\np8_broken = PKCS8_NS_DB;\\r\\nelse if (!strcmp(*args, \"-embed\"))\\r\\np8_broken = PKCS8_EMBEDDED_PARAM;\\r\\nelse if (!strcmp(*args, \"-passin\")) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\npassargin = *(++args);\\r\\n} else if (!strcmp(*args, \"-passout\")) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\npassargout = *(++args);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*args, \"-engine\") == 0) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\nengine = *(++args);\\r\\n}\\r\\n#endif\\r\\nelse if (!strcmp(*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else\\r\\nbadarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"Usage pkcs8 [options]\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err, \"-inform X input format (DER or PEM)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \"-outform X output format (DER or PEM)\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-passout arg output file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \"-topk8 output PKCS8 file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nooct use (nonstandard) no octet format\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-embed use (nonstandard) embedded DSA parameters format\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nsdb use (nonstandard) DSA Netscape DB format\\n\");\\r\\nBIO_printf(bio_err, \"-noiter use 1 as iteration count\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nocrypt use or expect unencrypted private key\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-v2 alg use PKCS#5 v2.0 and cipher \\\"alg\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-v1 obj use PKCS#5 v1.5 and cipher \\\"alg\\\"\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((pbe_nid == -1) && !cipher)\\r\\npbe_nid = NID_pbeWithMD5AndDES_CBC;\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file(infile, \"rb\"))) {\\r\\nBIO_printf(bio_err, \"Can't open input file %s\\n\", infile);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file(outfile, \"wb\"))) {\\r\\nBIO_printf(bio_err, \"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (topk8) {\\r\\npkey = load_key(bio_err, infile, informat, 1, passin, e, \"key\");\\r\\nif (!pkey)\\r\\ngoto end;\\r\\nif (!(p8inf = EVP_PKEY2PKCS8_broken(pkey, p8_broken))) {\\r\\nBIO_printf(bio_err, \"Error converting key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (nocrypt) {\\r\\nif (outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PKCS8_PRIV_KEY_INFO(out, p8inf);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\ni2d_PKCS8_PRIV_KEY_INFO_bio(out, p8inf);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nif (passout)\\r\\np8pass = passout;\\r\\nelse {\\r\\np8pass = pass;\\r\\nif (EVP_read_pw_string\\r\\n(pass, sizeof pass, \"Enter Encryption Password:\", 1))\\r\\ngoto end;\\r\\n}\\r\\napp_RAND_load_file(NULL, bio_err, 0);\\r\\nif (!(p8 = PKCS8_encrypt(pbe_nid, cipher,\\r\\np8pass, strlen(p8pass),\\r\\nNULL, 0, iter, p8inf))) {\\r\\nBIO_printf(bio_err, \"Error encrypting key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nif (outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PKCS8(out, p8);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\ni2d_PKCS8_bio(out, p8);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (nocrypt) {\\r\\nif (informat == FORMAT_PEM)\\r\\np8inf = PEM_read_bio_PKCS8_PRIV_KEY_INFO(in, NULL, NULL, NULL);\\r\\nelse if (informat == FORMAT_ASN1)\\r\\np8inf = d2i_PKCS8_PRIV_KEY_INFO_bio(in, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nif (informat == FORMAT_PEM)\\r\\np8 = PEM_read_bio_PKCS8(in, NULL, NULL, NULL);\\r\\nelse if (informat == FORMAT_ASN1)\\r\\np8 = d2i_PKCS8_bio(in, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!p8) {\\r\\nBIO_printf(bio_err, \"Error reading key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (passin)\\r\\np8pass = passin;\\r\\nelse {\\r\\np8pass = pass;\\r\\nEVP_read_pw_string(pass, sizeof pass, \"Enter Password:\", 0);\\r\\n}\\r\\np8inf = PKCS8_decrypt(p8, p8pass, strlen(p8pass));\\r\\n}\\r\\nif (!p8inf) {\\r\\nBIO_printf(bio_err, \"Error decrypting key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!(pkey = EVP_PKCS82PKEY(p8inf))) {\\r\\nBIO_printf(bio_err, \"Error converting key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (p8inf->broken) {\\r\\nBIO_printf(bio_err, \"Warning: broken key encoding: \");\\r\\nswitch (p8inf->broken) {\\r\\ncase PKCS8_NO_OCTET:\\r\\nBIO_printf(bio_err, \"No Octet String in PrivateKey\\n\");\\r\\nbreak;\\r\\ncase PKCS8_EMBEDDED_PARAM:\\r\\nBIO_printf(bio_err, \"DSA parameters included in PrivateKey\\n\");\\r\\nbreak;\\r\\ncase PKCS8_NS_DB:\\r\\nBIO_printf(bio_err, \"DSA public key include in PrivateKey\\n\");\\r\\nbreak;\\r\\ncase PKCS8_NEG_PRIVKEY:\\r\\nBIO_printf(bio_err, \"DSA private key value is negative\\n\");\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_printf(bio_err, \"Unknown broken type\\n\");\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (outformat == FORMAT_PEM)\\r\\nPEM_write_bio_PrivateKey(out, pkey, NULL, NULL, 0, NULL, passout);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\ni2d_PrivateKey_bio(out, pkey);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nX509_SIG_free(p8);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nBIO_free(in);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ocsp_ext_c", "target": 0, "func": "int OCSP_REQUEST_get_ext_count(OCSP_REQUEST *x)\\r\\n{\\r\\nreturn (X509v3_get_ext_count(x->tbsRequest->requestExtensions));\\r\\n}\\r\\nint OCSP_REQUEST_get_ext_by_NID(OCSP_REQUEST *x, int nid, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_NID\\r\\n(x->tbsRequest->requestExtensions, nid, lastpos));\\r\\n}\\r\\nint OCSP_REQUEST_get_ext_by_OBJ(OCSP_REQUEST *x, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_OBJ\\r\\n(x->tbsRequest->requestExtensions, obj, lastpos));\\r\\n}\\r\\nint OCSP_REQUEST_get_ext_by_critical(OCSP_REQUEST *x, int crit, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_critical\\r\\n(x->tbsRequest->requestExtensions, crit, lastpos));\\r\\n}\\r\\nX509_EXTENSION *OCSP_REQUEST_get_ext(OCSP_REQUEST *x, int loc)\\r\\n{\\r\\nreturn (X509v3_get_ext(x->tbsRequest->requestExtensions, loc));\\r\\n}\\r\\nX509_EXTENSION *OCSP_REQUEST_delete_ext(OCSP_REQUEST *x, int loc)\\r\\n{\\r\\nreturn (X509v3_delete_ext(x->tbsRequest->requestExtensions, loc));\\r\\n}\\r\\nvoid *OCSP_REQUEST_get1_ext_d2i(OCSP_REQUEST *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->tbsRequest->requestExtensions, nid, crit, idx);\\r\\n}\\r\\nint OCSP_REQUEST_add1_ext_i2d(OCSP_REQUEST *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->tbsRequest->requestExtensions, nid, value,\\r\\ncrit, flags);\\r\\n}\\r\\nint OCSP_REQUEST_add_ext(OCSP_REQUEST *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn (X509v3_add_ext(&(x->tbsRequest->requestExtensions), ex, loc) !=\\r\\nNULL);\\r\\n}\\r\\nint OCSP_ONEREQ_get_ext_count(OCSP_ONEREQ *x)\\r\\n{\\r\\nreturn (X509v3_get_ext_count(x->singleRequestExtensions));\\r\\n}\\r\\nint OCSP_ONEREQ_get_ext_by_NID(OCSP_ONEREQ *x, int nid, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_NID(x->singleRequestExtensions, nid, lastpos));\\r\\n}\\r\\nint OCSP_ONEREQ_get_ext_by_OBJ(OCSP_ONEREQ *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_OBJ(x->singleRequestExtensions, obj, lastpos));\\r\\n}\\r\\nint OCSP_ONEREQ_get_ext_by_critical(OCSP_ONEREQ *x, int crit, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_critical\\r\\n(x->singleRequestExtensions, crit, lastpos));\\r\\n}\\r\\nX509_EXTENSION *OCSP_ONEREQ_get_ext(OCSP_ONEREQ *x, int loc)\\r\\n{\\r\\nreturn (X509v3_get_ext(x->singleRequestExtensions, loc));\\r\\n}\\r\\nX509_EXTENSION *OCSP_ONEREQ_delete_ext(OCSP_ONEREQ *x, int loc)\\r\\n{\\r\\nreturn (X509v3_delete_ext(x->singleRequestExtensions, loc));\\r\\n}\\r\\nvoid *OCSP_ONEREQ_get1_ext_d2i(OCSP_ONEREQ *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->singleRequestExtensions, nid, crit, idx);\\r\\n}\\r\\nint OCSP_ONEREQ_add1_ext_i2d(OCSP_ONEREQ *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->singleRequestExtensions, nid, value, crit,\\r\\nflags);\\r\\n}\\r\\nint OCSP_ONEREQ_add_ext(OCSP_ONEREQ *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn (X509v3_add_ext(&(x->singleRequestExtensions), ex, loc) != NULL);\\r\\n}\\r\\nint OCSP_BASICRESP_get_ext_count(OCSP_BASICRESP *x)\\r\\n{\\r\\nreturn (X509v3_get_ext_count(x->tbsResponseData->responseExtensions));\\r\\n}\\r\\nint OCSP_BASICRESP_get_ext_by_NID(OCSP_BASICRESP *x, int nid, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_NID\\r\\n(x->tbsResponseData->responseExtensions, nid, lastpos));\\r\\n}\\r\\nint OCSP_BASICRESP_get_ext_by_OBJ(OCSP_BASICRESP *x, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_OBJ\\r\\n(x->tbsResponseData->responseExtensions, obj, lastpos));\\r\\n}\\r\\nint OCSP_BASICRESP_get_ext_by_critical(OCSP_BASICRESP *x, int crit,\\r\\nint lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_critical\\r\\n(x->tbsResponseData->responseExtensions, crit, lastpos));\\r\\n}\\r\\nX509_EXTENSION *OCSP_BASICRESP_get_ext(OCSP_BASICRESP *x, int loc)\\r\\n{\\r\\nreturn (X509v3_get_ext(x->tbsResponseData->responseExtensions, loc));\\r\\n}\\r\\nX509_EXTENSION *OCSP_BASICRESP_delete_ext(OCSP_BASICRESP *x, int loc)\\r\\n{\\r\\nreturn (X509v3_delete_ext(x->tbsResponseData->responseExtensions, loc));\\r\\n}\\r\\nvoid *OCSP_BASICRESP_get1_ext_d2i(OCSP_BASICRESP *x, int nid, int *crit,\\r\\nint *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->tbsResponseData->responseExtensions, nid, crit,\\r\\nidx);\\r\\n}\\r\\nint OCSP_BASICRESP_add1_ext_i2d(OCSP_BASICRESP *x, int nid, void *value,\\r\\nint crit, unsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->tbsResponseData->responseExtensions, nid,\\r\\nvalue, crit, flags);\\r\\n}\\r\\nint OCSP_BASICRESP_add_ext(OCSP_BASICRESP *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn (X509v3_add_ext(&(x->tbsResponseData->responseExtensions), ex, loc)\\r\\n!= NULL);\\r\\n}\\r\\nint OCSP_SINGLERESP_get_ext_count(OCSP_SINGLERESP *x)\\r\\n{\\r\\nreturn (X509v3_get_ext_count(x->singleExtensions));\\r\\n}\\r\\nint OCSP_SINGLERESP_get_ext_by_NID(OCSP_SINGLERESP *x, int nid, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_NID(x->singleExtensions, nid, lastpos));\\r\\n}\\r\\nint OCSP_SINGLERESP_get_ext_by_OBJ(OCSP_SINGLERESP *x, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_OBJ(x->singleExtensions, obj, lastpos));\\r\\n}\\r\\nint OCSP_SINGLERESP_get_ext_by_critical(OCSP_SINGLERESP *x, int crit,\\r\\nint lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_critical(x->singleExtensions, crit, lastpos));\\r\\n}\\r\\nX509_EXTENSION *OCSP_SINGLERESP_get_ext(OCSP_SINGLERESP *x, int loc)\\r\\n{\\r\\nreturn (X509v3_get_ext(x->singleExtensions, loc));\\r\\n}\\r\\nX509_EXTENSION *OCSP_SINGLERESP_delete_ext(OCSP_SINGLERESP *x, int loc)\\r\\n{\\r\\nreturn (X509v3_delete_ext(x->singleExtensions, loc));\\r\\n}\\r\\nvoid *OCSP_SINGLERESP_get1_ext_d2i(OCSP_SINGLERESP *x, int nid, int *crit,\\r\\nint *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->singleExtensions, nid, crit, idx);\\r\\n}\\r\\nint OCSP_SINGLERESP_add1_ext_i2d(OCSP_SINGLERESP *x, int nid, void *value,\\r\\nint crit, unsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->singleExtensions, nid, value, crit, flags);\\r\\n}\\r\\nint OCSP_SINGLERESP_add_ext(OCSP_SINGLERESP *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn (X509v3_add_ext(&(x->singleExtensions), ex, loc) != NULL);\\r\\n}\\r\\nint OCSP_request_add1_nonce(OCSP_REQUEST *req, unsigned char *val, int len)\\r\\n{\\r\\nreturn ocsp_add1_nonce(&req->tbsRequest->requestExtensions, val, len);\\r\\n}\\r\\nint OCSP_basic_add1_nonce(OCSP_BASICRESP *resp, unsigned char *val, int len)\\r\\n{\\r\\nreturn ocsp_add1_nonce(&resp->tbsResponseData->responseExtensions, val,\\r\\nlen);\\r\\n}\\r\\nint OCSP_check_nonce(OCSP_REQUEST *req, OCSP_BASICRESP *bs)\\r\\n{\\r\\nint req_idx, resp_idx;\\r\\nX509_EXTENSION *req_ext, *resp_ext;\\r\\nreq_idx = OCSP_REQUEST_get_ext_by_NID(req, NID_id_pkix_OCSP_Nonce, -1);\\r\\nresp_idx = OCSP_BASICRESP_get_ext_by_NID(bs, NID_id_pkix_OCSP_Nonce, -1);\\r\\nif ((req_idx < 0) && (resp_idx < 0))\\r\\nreturn 2;\\r\\nif ((req_idx >= 0) && (resp_idx < 0))\\r\\nreturn -1;\\r\\nif ((req_idx < 0) && (resp_idx >= 0))\\r\\nreturn 3;\\r\\nreq_ext = OCSP_REQUEST_get_ext(req, req_idx);\\r\\nresp_ext = OCSP_BASICRESP_get_ext(bs, resp_idx);\\r\\nif (ASN1_OCTET_STRING_cmp(req_ext->value, resp_ext->value))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_copy_nonce(OCSP_BASICRESP *resp, OCSP_REQUEST *req)\\r\\n{\\r\\nX509_EXTENSION *req_ext;\\r\\nint req_idx;\\r\\nreq_idx = OCSP_REQUEST_get_ext_by_NID(req, NID_id_pkix_OCSP_Nonce, -1);\\r\\nif (req_idx < 0)\\r\\nreturn 2;\\r\\nreq_ext = OCSP_REQUEST_get_ext(req, req_idx);\\r\\nreturn OCSP_BASICRESP_add_ext(resp, req_ext, -1);\\r\\n}\\r\\nX509_EXTENSION *OCSP_crlID_new(char *url, long *n, char *tim)\\r\\n{\\r\\nX509_EXTENSION *x = NULL;\\r\\nOCSP_CRLID *cid = NULL;\\r\\nif (!(cid = OCSP_CRLID_new()))\\r\\ngoto err;\\r\\nif (url) {\\r\\nif (!(cid->crlUrl = ASN1_IA5STRING_new()))\\r\\ngoto err;\\r\\nif (!(ASN1_STRING_set(cid->crlUrl, url, -1)))\\r\\ngoto err;\\r\\n}\\r\\nif (n) {\\r\\nif (!(cid->crlNum = ASN1_INTEGER_new()))\\r\\ngoto err;\\r\\nif (!(ASN1_INTEGER_set(cid->crlNum, *n)))\\r\\ngoto err;\\r\\n}\\r\\nif (tim) {\\r\\nif (!(cid->crlTime = ASN1_GENERALIZEDTIME_new()))\\r\\ngoto err;\\r\\nif (!(ASN1_GENERALIZEDTIME_set_string(cid->crlTime, tim)))\\r\\ngoto err;\\r\\n}\\r\\nx = X509V3_EXT_i2d(NID_id_pkix_OCSP_CrlID, 0, cid);\\r\\nerr:\\r\\nif (cid)\\r\\nOCSP_CRLID_free(cid);\\r\\nreturn x;\\r\\n}\\r\\nX509_EXTENSION *OCSP_accept_responses_new(char **oids)\\r\\n{\\r\\nint nid;\\r\\nSTACK_OF(ASN1_OBJECT) *sk = NULL;\\r\\nASN1_OBJECT *o = NULL;\\r\\nX509_EXTENSION *x = NULL;\\r\\nif (!(sk = sk_ASN1_OBJECT_new_null()))\\r\\ngoto err;\\r\\nwhile (oids && *oids) {\\r\\nif ((nid = OBJ_txt2nid(*oids)) != NID_undef && (o = OBJ_nid2obj(nid)))\\r\\nsk_ASN1_OBJECT_push(sk, o);\\r\\noids++;\\r\\n}\\r\\nx = X509V3_EXT_i2d(NID_id_pkix_OCSP_acceptableResponses, 0, sk);\\r\\nerr:\\r\\nif (sk)\\r\\nsk_ASN1_OBJECT_pop_free(sk, ASN1_OBJECT_free);\\r\\nreturn x;\\r\\n}\\r\\nX509_EXTENSION *OCSP_archive_cutoff_new(char *tim)\\r\\n{\\r\\nX509_EXTENSION *x = NULL;\\r\\nASN1_GENERALIZEDTIME *gt = NULL;\\r\\nif (!(gt = ASN1_GENERALIZEDTIME_new()))\\r\\ngoto err;\\r\\nif (!(ASN1_GENERALIZEDTIME_set_string(gt, tim)))\\r\\ngoto err;\\r\\nx = X509V3_EXT_i2d(NID_id_pkix_OCSP_archiveCutoff, 0, gt);\\r\\nerr:\\r\\nif (gt)\\r\\nASN1_GENERALIZEDTIME_free(gt);\\r\\nreturn x;\\r\\n}\\r\\nX509_EXTENSION *OCSP_url_svcloc_new(X509_NAME *issuer, char **urls)\\r\\n{\\r\\nX509_EXTENSION *x = NULL;\\r\\nASN1_IA5STRING *ia5 = NULL;\\r\\nOCSP_SERVICELOC *sloc = NULL;\\r\\nACCESS_DESCRIPTION *ad = NULL;\\r\\nif (!(sloc = OCSP_SERVICELOC_new()))\\r\\ngoto err;\\r\\nif (!(sloc->issuer = X509_NAME_dup(issuer)))\\r\\ngoto err;\\r\\nif (urls && *urls && !(sloc->locator = sk_ACCESS_DESCRIPTION_new_null()))\\r\\ngoto err;\\r\\nwhile (urls && *urls) {\\r\\nif (!(ad = ACCESS_DESCRIPTION_new()))\\r\\ngoto err;\\r\\nif (!(ad->method = OBJ_nid2obj(NID_ad_OCSP)))\\r\\ngoto err;\\r\\nif (!(ad->location = GENERAL_NAME_new()))\\r\\ngoto err;\\r\\nif (!(ia5 = ASN1_IA5STRING_new()))\\r\\ngoto err;\\r\\nif (!ASN1_STRING_set((ASN1_STRING *)ia5, *urls, -1))\\r\\ngoto err;\\r\\nad->location->type = GEN_URI;\\r\\nad->location->d.ia5 = ia5;\\r\\nif (!sk_ACCESS_DESCRIPTION_push(sloc->locator, ad))\\r\\ngoto err;\\r\\nurls++;\\r\\n}\\r\\nx = X509V3_EXT_i2d(NID_id_pkix_OCSP_serviceLocator, 0, sloc);\\r\\nerr:\\r\\nif (sloc)\\r\\nOCSP_SERVICELOC_free(sloc);\\r\\nreturn x;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tb_dh_c", "target": 0, "func": "void ENGINE_unregister_DH(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&dh_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_DH(void)\\r\\n{\\r\\nengine_table_cleanup(&dh_table);\\r\\n}\\r\\nint ENGINE_register_DH(ENGINE *e)\\r\\n{\\r\\nif (e->dh_meth)\\r\\nreturn engine_table_register(&dh_table,\\r\\nengine_unregister_all_DH, e, &dummy_nid,\\r\\n1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_DH()\\r\\n{\\r\\nENGINE *e;\\r\\nfor (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))\\r\\nENGINE_register_DH(e);\\r\\n}\\r\\nint ENGINE_set_default_DH(ENGINE *e)\\r\\n{\\r\\nif (e->dh_meth)\\r\\nreturn engine_table_register(&dh_table,\\r\\nengine_unregister_all_DH, e, &dummy_nid,\\r\\n1, 1);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_DH(void)\\r\\n{\\r\\nreturn engine_table_select(&dh_table, dummy_nid);\\r\\n}\\r\\nconst DH_METHOD *ENGINE_get_DH(const ENGINE *e)\\r\\n{\\r\\nreturn e->dh_meth;\\r\\n}\\r\\nint ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth)\\r\\n{\\r\\ne->dh_meth = dh_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecb3_enc_c", "target": 0, "func": "void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,\\r\\nDES_key_schedule *ks1, DES_key_schedule *ks2,\\r\\nDES_key_schedule *ks3, int enc)\\r\\n{\\r\\nregister DES_LONG l0, l1;\\r\\nDES_LONG ll[2];\\r\\nconst unsigned char *in = &(*input)[0];\\r\\nunsigned char *out = &(*output)[0];\\r\\nc2l(in, l0);\\r\\nc2l(in, l1);\\r\\nll[0] = l0;\\r\\nll[1] = l1;\\r\\nif (enc)\\r\\nDES_encrypt3(ll, ks1, ks2, ks3);\\r\\nelse\\r\\nDES_decrypt3(ll, ks1, ks2, ks3);\\r\\nl0 = ll[0];\\r\\nl1 = ll[1];\\r\\nl2c(l0, out);\\r\\nl2c(l1, out);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_crld_c", "target": 0, "func": "int set_dist_point_name(DIST_POINT_NAME **pdp, X509V3_CTX *ctx,\\r\\nCONF_VALUE *cnf)\\r\\n{\\r\\nSTACK_OF(GENERAL_NAME) *fnm = NULL;\\r\\nSTACK_OF(X509_NAME_ENTRY) *rnm = NULL;\\r\\nif (!strncmp(cnf->name, \"fullname\", 9)) {\\r\\nfnm = gnames_from_sectname(ctx, cnf->value);\\r\\nif (!fnm)\\r\\ngoto err;\\r\\n} else if (!strcmp(cnf->name, \"relativename\")) {\\r\\nint ret;\\r\\nSTACK_OF(CONF_VALUE) *dnsect;\\r\\nX509_NAME *nm;\\r\\nnm = X509_NAME_new();\\r\\nif (!nm)\\r\\nreturn -1;\\r\\ndnsect = X509V3_get_section(ctx, cnf->value);\\r\\nif (!dnsect) {\\r\\nX509V3err(X509V3_F_SET_DIST_POINT_NAME,\\r\\nX509V3_R_SECTION_NOT_FOUND);\\r\\nreturn -1;\\r\\n}\\r\\nret = X509V3_NAME_from_section(nm, dnsect, MBSTRING_ASC);\\r\\nX509V3_section_free(ctx, dnsect);\\r\\nrnm = nm->entries;\\r\\nnm->entries = NULL;\\r\\nX509_NAME_free(nm);\\r\\nif (!ret || sk_X509_NAME_ENTRY_num(rnm) <= 0)\\r\\ngoto err;\\r\\nif (sk_X509_NAME_ENTRY_value(rnm,\\r\\nsk_X509_NAME_ENTRY_num(rnm) - 1)->set) {\\r\\nX509V3err(X509V3_F_SET_DIST_POINT_NAME,\\r\\nX509V3_R_INVALID_MULTIPLE_RDNS);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\nreturn 0;\\r\\nif (*pdp) {\\r\\nX509V3err(X509V3_F_SET_DIST_POINT_NAME,\\r\\nX509V3_R_DISTPOINT_ALREADY_SET);\\r\\ngoto err;\\r\\n}\\r\\n*pdp = DIST_POINT_NAME_new();\\r\\nif (!*pdp)\\r\\ngoto err;\\r\\nif (fnm) {\\r\\n(*pdp)->type = 0;\\r\\n(*pdp)->name.fullname = fnm;\\r\\n} else {\\r\\n(*pdp)->type = 1;\\r\\n(*pdp)->name.relativename = rnm;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nif (fnm)\\r\\nsk_GENERAL_NAME_pop_free(fnm, GENERAL_NAME_free);\\r\\nif (rnm)\\r\\nsk_X509_NAME_ENTRY_pop_free(rnm, X509_NAME_ENTRY_free);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int set_reasons(ASN1_BIT_STRING **preas, char *value)\\r\\n{\\r\\nSTACK_OF(CONF_VALUE) *rsk = NULL;\\r\\nconst BIT_STRING_BITNAME *pbn;\\r\\nconst char *bnam;\\r\\nint i, ret = 0;\\r\\nrsk = X509V3_parse_list(value);\\r\\nif (!rsk)\\r\\nreturn 0;\\r\\nif (*preas)\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(rsk); i++) {\\r\\nbnam = sk_CONF_VALUE_value(rsk, i)->name;\\r\\nif (!*preas) {\\r\\n*preas = ASN1_BIT_STRING_new();\\r\\nif (!*preas)\\r\\ngoto err;\\r\\n}\\r\\nfor (pbn = reason_flags; pbn->lname; pbn++) {\\r\\nif (!strcmp(pbn->sname, bnam)) {\\r\\nif (!ASN1_BIT_STRING_set_bit(*preas, pbn->bitnum, 1))\\r\\ngoto err;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!pbn->lname)\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nsk_CONF_VALUE_pop_free(rsk, X509V3_conf_free);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int print_reasons(BIO *out, const char *rname,\\r\\nASN1_BIT_STRING *rflags, int indent)\\r\\n{\\r\\nint first = 1;\\r\\nconst BIT_STRING_BITNAME *pbn;\\r\\nBIO_printf(out, \"%*s%s:\\n%*s\", indent, \"\", rname, indent + 2, \"\");\\r\\nfor (pbn = reason_flags; pbn->lname; pbn++) {\\r\\nif (ASN1_BIT_STRING_get_bit(rflags, pbn->bitnum)) {\\r\\nif (first)\\r\\nfirst = 0;\\r\\nelse\\r\\nBIO_puts(out, \", \");\\r\\nBIO_puts(out, pbn->lname);\\r\\n}\\r\\n}\\r\\nif (first)\\r\\nBIO_puts(out, \"<EMPTY>\\n\");\\r\\nelse\\r\\nBIO_puts(out, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic int dpn_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nDIST_POINT_NAME *dpn = (DIST_POINT_NAME *)*pval;\\r\\nswitch (operation) {\\r\\ncase ASN1_OP_NEW_POST:\\r\\ndpn->dpname = NULL;\\r\\nbreak;\\r\\ncase ASN1_OP_FREE_POST:\\r\\nif (dpn->dpname)\\r\\nX509_NAME_free(dpn->dpname);\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int print_distpoint(BIO *out, DIST_POINT_NAME *dpn, int indent)\\r\\n{\\r\\nif (dpn->type == 0) {\\r\\nBIO_printf(out, \"%*sFull Name:\\n\", indent, \"\");\\r\\nprint_gens(out, dpn->name.fullname, indent);\\r\\n} else {\\r\\nX509_NAME ntmp;\\r\\nntmp.entries = dpn->name.relativename;\\r\\nBIO_printf(out, \"%*sRelative Name:\\n%*s\", indent, \"\", indent + 2, \"\");\\r\\nX509_NAME_print_ex(out, &ntmp, 0, XN_FLAG_ONELINE);\\r\\nBIO_puts(out, \"\\n\");\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int i2r_idp(const X509V3_EXT_METHOD *method, void *pidp, BIO *out,\\r\\nint indent)\\r\\n{\\r\\nISSUING_DIST_POINT *idp = pidp;\\r\\nif (idp->distpoint)\\r\\nprint_distpoint(out, idp->distpoint, indent);\\r\\nif (idp->onlyuser > 0)\\r\\nBIO_printf(out, \"%*sOnly User Certificates\\n\", indent, \"\");\\r\\nif (idp->onlyCA > 0)\\r\\nBIO_printf(out, \"%*sOnly CA Certificates\\n\", indent, \"\");\\r\\nif (idp->indirectCRL > 0)\\r\\nBIO_printf(out, \"%*sIndirect CRL\\n\", indent, \"\");\\r\\nif (idp->onlysomereasons)\\r\\nprint_reasons(out, \"Only Some Reasons\", idp->onlysomereasons, indent);\\r\\nif (idp->onlyattr > 0)\\r\\nBIO_printf(out, \"%*sOnly Attribute Certificates\\n\", indent, \"\");\\r\\nif (!idp->distpoint && (idp->onlyuser <= 0) && (idp->onlyCA <= 0)\\r\\n&& (idp->indirectCRL <= 0) && !idp->onlysomereasons\\r\\n&& (idp->onlyattr <= 0))\\r\\nBIO_printf(out, \"%*s<EMPTY>\\n\", indent, \"\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic int i2r_crldp(const X509V3_EXT_METHOD *method, void *pcrldp, BIO *out,\\r\\nint indent)\\r\\n{\\r\\nSTACK_OF(DIST_POINT) *crld = pcrldp;\\r\\nDIST_POINT *point;\\r\\nint i;\\r\\nfor (i = 0; i < sk_DIST_POINT_num(crld); i++) {\\r\\nBIO_puts(out, \"\\n\");\\r\\npoint = sk_DIST_POINT_value(crld, i);\\r\\nif (point->distpoint)\\r\\nprint_distpoint(out, point->distpoint, indent);\\r\\nif (point->reasons)\\r\\nprint_reasons(out, \"Reasons\", point->reasons, indent);\\r\\nif (point->CRLissuer) {\\r\\nBIO_printf(out, \"%*sCRL Issuer:\\n\", indent, \"\");\\r\\nprint_gens(out, point->CRLissuer, indent);\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint DIST_POINT_set_dpname(DIST_POINT_NAME *dpn, X509_NAME *iname)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_NAME_ENTRY) *frag;\\r\\nX509_NAME_ENTRY *ne;\\r\\nif (!dpn || (dpn->type != 1))\\r\\nreturn 1;\\r\\nfrag = dpn->name.relativename;\\r\\ndpn->dpname = X509_NAME_dup(iname);\\r\\nif (!dpn->dpname)\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_X509_NAME_ENTRY_num(frag); i++) {\\r\\nne = sk_X509_NAME_ENTRY_value(frag, i);\\r\\nif (!X509_NAME_add_entry(dpn->dpname, ne, -1, i ? 0 : 1)) {\\r\\nX509_NAME_free(dpn->dpname);\\r\\ndpn->dpname = NULL;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (i2d_X509_NAME(dpn->dpname, NULL) < 0) {\\r\\nX509_NAME_free(dpn->dpname);\\r\\ndpn->dpname = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tb_digest_c", "target": 0, "func": "void ENGINE_unregister_digests(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&digest_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_digests(void)\\r\\n{\\r\\nengine_table_cleanup(&digest_table);\\r\\n}\\r\\nint ENGINE_register_digests(ENGINE *e)\\r\\n{\\r\\nif (e->digests) {\\r\\nconst int *nids;\\r\\nint num_nids = e->digests(e, NULL, &nids, 0);\\r\\nif (num_nids > 0)\\r\\nreturn engine_table_register(&digest_table,\\r\\nengine_unregister_all_digests, e,\\r\\nnids, num_nids, 0);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_digests()\\r\\n{\\r\\nENGINE *e;\\r\\nfor (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))\\r\\nENGINE_register_digests(e);\\r\\n}\\r\\nint ENGINE_set_default_digests(ENGINE *e)\\r\\n{\\r\\nif (e->digests) {\\r\\nconst int *nids;\\r\\nint num_nids = e->digests(e, NULL, &nids, 0);\\r\\nif (num_nids > 0)\\r\\nreturn engine_table_register(&digest_table,\\r\\nengine_unregister_all_digests, e,\\r\\nnids, num_nids, 1);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_digest_engine(int nid)\\r\\n{\\r\\nreturn engine_table_select(&digest_table, nid);\\r\\n}\\r\\nconst EVP_MD *ENGINE_get_digest(ENGINE *e, int nid)\\r\\n{\\r\\nconst EVP_MD *ret;\\r\\nENGINE_DIGESTS_PTR fn = ENGINE_get_digests(e);\\r\\nif (!fn || !fn(e, &ret, NULL, nid)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_DIGEST, ENGINE_R_UNIMPLEMENTED_DIGEST);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e)\\r\\n{\\r\\nreturn e->digests;\\r\\n}\\r\\nint ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f)\\r\\n{\\r\\ne->digests = f;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_lib_c", "target": 0, "func": "RSA *RSA_new(void)\\r\\n{\\r\\nRSA *r = RSA_new_method(NULL);\\r\\nreturn r;\\r\\n}\\r\\nvoid RSA_set_default_method(const RSA_METHOD *meth)\\r\\n{\\r\\ndefault_RSA_meth = meth;\\r\\n}\\r\\nconst RSA_METHOD *RSA_get_default_method(void)\\r\\n{\\r\\nif (default_RSA_meth == NULL) {\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_rsa_pkcs1_ssleay();\\r\\nelse\\r\\nreturn RSA_PKCS1_SSLeay();\\r\\n#else\\r\\n# ifdef RSA_NULL\\r\\ndefault_RSA_meth = RSA_null_method();\\r\\n# else\\r\\ndefault_RSA_meth = RSA_PKCS1_SSLeay();\\r\\n# endif\\r\\n#endif\\r\\n}\\r\\nreturn default_RSA_meth;\\r\\n}\\r\\nconst RSA_METHOD *RSA_get_method(const RSA *rsa)\\r\\n{\\r\\nreturn rsa->meth;\\r\\n}\\r\\nint RSA_set_method(RSA *rsa, const RSA_METHOD *meth)\\r\\n{\\r\\nconst RSA_METHOD *mtmp;\\r\\nmtmp = rsa->meth;\\r\\nif (mtmp->finish)\\r\\nmtmp->finish(rsa);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (rsa->engine) {\\r\\nENGINE_finish(rsa->engine);\\r\\nrsa->engine = NULL;\\r\\n}\\r\\n#endif\\r\\nrsa->meth = meth;\\r\\nif (meth->init)\\r\\nmeth->init(rsa);\\r\\nreturn 1;\\r\\n}\\r\\nRSA *RSA_new_method(ENGINE *engine)\\r\\n{\\r\\nRSA *ret;\\r\\nret = (RSA *)OPENSSL_malloc(sizeof(RSA));\\r\\nif (ret == NULL) {\\r\\nRSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->meth = RSA_get_default_method();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (engine) {\\r\\nif (!ENGINE_init(engine)) {\\r\\nRSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nret->engine = engine;\\r\\n} else\\r\\nret->engine = ENGINE_get_default_RSA();\\r\\nif (ret->engine) {\\r\\nret->meth = ENGINE_get_RSA(ret->engine);\\r\\nif (!ret->meth) {\\r\\nRSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nENGINE_finish(ret->engine);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret->pad = 0;\\r\\nret->version = 0;\\r\\nret->n = NULL;\\r\\nret->e = NULL;\\r\\nret->d = NULL;\\r\\nret->p = NULL;\\r\\nret->q = NULL;\\r\\nret->dmp1 = NULL;\\r\\nret->dmq1 = NULL;\\r\\nret->iqmp = NULL;\\r\\nret->references = 1;\\r\\nret->_method_mod_n = NULL;\\r\\nret->_method_mod_p = NULL;\\r\\nret->_method_mod_q = NULL;\\r\\nret->blinding = NULL;\\r\\nret->mt_blinding = NULL;\\r\\nret->bignum_data = NULL;\\r\\nret->flags = ret->meth->flags & ~RSA_FLAG_NON_FIPS_ALLOW;\\r\\nif (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data)) {\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ret->engine)\\r\\nENGINE_finish(ret->engine);\\r\\n#endif\\r\\nOPENSSL_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret)) {\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ret->engine)\\r\\nENGINE_finish(ret->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data);\\r\\nOPENSSL_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid RSA_free(RSA *r)\\r\\n{\\r\\nint i;\\r\\nif (r == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_RSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"RSA\", r);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"RSA_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (r->meth->finish)\\r\\nr->meth->finish(r);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (r->engine)\\r\\nENGINE_finish(r->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, r, &r->ex_data);\\r\\nif (r->n != NULL)\\r\\nBN_clear_free(r->n);\\r\\nif (r->e != NULL)\\r\\nBN_clear_free(r->e);\\r\\nif (r->d != NULL)\\r\\nBN_clear_free(r->d);\\r\\nif (r->p != NULL)\\r\\nBN_clear_free(r->p);\\r\\nif (r->q != NULL)\\r\\nBN_clear_free(r->q);\\r\\nif (r->dmp1 != NULL)\\r\\nBN_clear_free(r->dmp1);\\r\\nif (r->dmq1 != NULL)\\r\\nBN_clear_free(r->dmq1);\\r\\nif (r->iqmp != NULL)\\r\\nBN_clear_free(r->iqmp);\\r\\nif (r->blinding != NULL)\\r\\nBN_BLINDING_free(r->blinding);\\r\\nif (r->mt_blinding != NULL)\\r\\nBN_BLINDING_free(r->mt_blinding);\\r\\nif (r->bignum_data != NULL)\\r\\nOPENSSL_free_locked(r->bignum_data);\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nint RSA_up_ref(RSA *r)\\r\\n{\\r\\nint i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_RSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"RSA\", r);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (i < 2) {\\r\\nfprintf(stderr, \"RSA_up_ref, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nreturn ((i > 1) ? 1 : 0);\\r\\n}\\r\\nint RSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_RSA, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint RSA_set_ex_data(RSA *r, int idx, void *arg)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&r->ex_data, idx, arg));\\r\\n}\\r\\nvoid *RSA_get_ex_data(const RSA *r, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&r->ex_data, idx));\\r\\n}\\r\\nint RSA_memory_lock(RSA *r)\\r\\n{\\r\\nint i, j, k, off;\\r\\nchar *p;\\r\\nBIGNUM *bn, **t[6], *b;\\r\\nBN_ULONG *ul;\\r\\nif (r->d == NULL)\\r\\nreturn (1);\\r\\nt[0] = &r->d;\\r\\nt[1] = &r->p;\\r\\nt[2] = &r->q;\\r\\nt[3] = &r->dmp1;\\r\\nt[4] = &r->dmq1;\\r\\nt[5] = &r->iqmp;\\r\\nk = sizeof(BIGNUM) * 6;\\r\\noff = k / sizeof(BN_ULONG) + 1;\\r\\nj = 1;\\r\\nfor (i = 0; i < 6; i++)\\r\\nj += (*t[i])->top;\\r\\nif ((p = OPENSSL_malloc_locked((off + j) * sizeof(BN_ULONG))) == NULL) {\\r\\nRSAerr(RSA_F_RSA_MEMORY_LOCK, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nbn = (BIGNUM *)p;\\r\\nul = (BN_ULONG *)&(p[off]);\\r\\nfor (i = 0; i < 6; i++) {\\r\\nb = *(t[i]);\\r\\n*(t[i]) = &(bn[i]);\\r\\nmemcpy((char *)&(bn[i]), (char *)b, sizeof(BIGNUM));\\r\\nbn[i].flags = BN_FLG_STATIC_DATA;\\r\\nbn[i].d = ul;\\r\\nmemcpy((char *)ul, b->d, sizeof(BN_ULONG) * b->top);\\r\\nul += b->top;\\r\\nBN_clear_free(b);\\r\\n}\\r\\nr->flags &= ~(RSA_FLAG_CACHE_PRIVATE | RSA_FLAG_CACHE_PUBLIC);\\r\\nr->bignum_data = p;\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_sha512_c", "target": 0, "func": "int SHA512_Final(unsigned char *md, SHA512_CTX *c)\\r\\n{\\r\\nunsigned char *p = (unsigned char *)c->u.p;\\r\\nsize_t n = c->num;\\r\\np[n] = 0x80;\\r\\nn++;\\r\\nif (n > (sizeof(c->u) - 16))\\r\\nmemset(p + n, 0, sizeof(c->u) - n), n = 0,\\r\\nsha512_block_data_order(c, p, 1);\\r\\nmemset(p + n, 0, sizeof(c->u) - 16 - n);\\r\\n# ifdef B_ENDIAN\\r\\nc->u.d[SHA_LBLOCK - 2] = c->Nh;\\r\\nc->u.d[SHA_LBLOCK - 1] = c->Nl;\\r\\n# else\\r\\np[sizeof(c->u) - 1] = (unsigned char)(c->Nl);\\r\\np[sizeof(c->u) - 2] = (unsigned char)(c->Nl >> 8);\\r\\np[sizeof(c->u) - 3] = (unsigned char)(c->Nl >> 16);\\r\\np[sizeof(c->u) - 4] = (unsigned char)(c->Nl >> 24);\\r\\np[sizeof(c->u) - 5] = (unsigned char)(c->Nl >> 32);\\r\\np[sizeof(c->u) - 6] = (unsigned char)(c->Nl >> 40);\\r\\np[sizeof(c->u) - 7] = (unsigned char)(c->Nl >> 48);\\r\\np[sizeof(c->u) - 8] = (unsigned char)(c->Nl >> 56);\\r\\np[sizeof(c->u) - 9] = (unsigned char)(c->Nh);\\r\\np[sizeof(c->u) - 10] = (unsigned char)(c->Nh >> 8);\\r\\np[sizeof(c->u) - 11] = (unsigned char)(c->Nh >> 16);\\r\\np[sizeof(c->u) - 12] = (unsigned char)(c->Nh >> 24);\\r\\np[sizeof(c->u) - 13] = (unsigned char)(c->Nh >> 32);\\r\\np[sizeof(c->u) - 14] = (unsigned char)(c->Nh >> 40);\\r\\np[sizeof(c->u) - 15] = (unsigned char)(c->Nh >> 48);\\r\\np[sizeof(c->u) - 16] = (unsigned char)(c->Nh >> 56);\\r\\n# endif\\r\\nsha512_block_data_order(c, p, 1);\\r\\nif (md == 0)\\r\\nreturn 0;\\r\\nswitch (c->md_len) {\\r\\ncase SHA384_DIGEST_LENGTH:\\r\\nfor (n = 0; n < SHA384_DIGEST_LENGTH / 8; n++) {\\r\\nSHA_LONG64 t = c->h[n];\\r\\n*(md++) = (unsigned char)(t >> 56);\\r\\n*(md++) = (unsigned char)(t >> 48);\\r\\n*(md++) = (unsigned char)(t >> 40);\\r\\n*(md++) = (unsigned char)(t >> 32);\\r\\n*(md++) = (unsigned char)(t >> 24);\\r\\n*(md++) = (unsigned char)(t >> 16);\\r\\n*(md++) = (unsigned char)(t >> 8);\\r\\n*(md++) = (unsigned char)(t);\\r\\n}\\r\\nbreak;\\r\\ncase SHA512_DIGEST_LENGTH:\\r\\nfor (n = 0; n < SHA512_DIGEST_LENGTH / 8; n++) {\\r\\nSHA_LONG64 t = c->h[n];\\r\\n*(md++) = (unsigned char)(t >> 56);\\r\\n*(md++) = (unsigned char)(t >> 48);\\r\\n*(md++) = (unsigned char)(t >> 40);\\r\\n*(md++) = (unsigned char)(t >> 32);\\r\\n*(md++) = (unsigned char)(t >> 24);\\r\\n*(md++) = (unsigned char)(t >> 16);\\r\\n*(md++) = (unsigned char)(t >> 8);\\r\\n*(md++) = (unsigned char)(t);\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SHA384_Final(unsigned char *md, SHA512_CTX *c)\\r\\n{\\r\\nreturn SHA512_Final(md, c);\\r\\n}\\r\\nint SHA512_Update(SHA512_CTX *c, const void *_data, size_t len)\\r\\n{\\r\\nSHA_LONG64 l;\\r\\nunsigned char *p = c->u.p;\\r\\nconst unsigned char *data = (const unsigned char *)_data;\\r\\nif (len == 0)\\r\\nreturn 1;\\r\\nl = (c->Nl + (((SHA_LONG64) len) << 3)) & U64(0xffffffffffffffff);\\r\\nif (l < c->Nl)\\r\\nc->Nh++;\\r\\nif (sizeof(len) >= 8)\\r\\nc->Nh += (((SHA_LONG64) len) >> 61);\\r\\nc->Nl = l;\\r\\nif (c->num != 0) {\\r\\nsize_t n = sizeof(c->u) - c->num;\\r\\nif (len < n) {\\r\\nmemcpy(p + c->num, data, len), c->num += (unsigned int)len;\\r\\nreturn 1;\\r\\n} else {\\r\\nmemcpy(p + c->num, data, n), c->num = 0;\\r\\nlen -= n, data += n;\\r\\nsha512_block_data_order(c, p, 1);\\r\\n}\\r\\n}\\r\\nif (len >= sizeof(c->u)) {\\r\\n# ifndef SHA512_BLOCK_CAN_MANAGE_UNALIGNED_DATA\\r\\nif ((size_t)data % sizeof(c->u.d[0]) != 0)\\r\\nwhile (len >= sizeof(c->u))\\r\\nmemcpy(p, data, sizeof(c->u)),\\r\\nsha512_block_data_order(c, p, 1),\\r\\nlen -= sizeof(c->u), data += sizeof(c->u);\\r\\nelse\\r\\n# endif\\r\\nsha512_block_data_order(c, data, len / sizeof(c->u)),\\r\\ndata += len, len %= sizeof(c->u), data -= len;\\r\\n}\\r\\nif (len != 0)\\r\\nmemcpy(p, data, len), c->num = (int)len;\\r\\nreturn 1;\\r\\n}\\r\\nint SHA384_Update(SHA512_CTX *c, const void *data, size_t len)\\r\\n{\\r\\nreturn SHA512_Update(c, data, len);\\r\\n}\\r\\nvoid SHA512_Transform(SHA512_CTX *c, const unsigned char *data)\\r\\n{\\r\\n# ifndef SHA512_BLOCK_CAN_MANAGE_UNALIGNED_DATA\\r\\nif ((size_t)data % sizeof(c->u.d[0]) != 0)\\r\\nmemcpy(c->u.p, data, sizeof(c->u.p)), data = c->u.p;\\r\\n# endif\\r\\nsha512_block_data_order(c, data, 1);\\r\\n}\\r\\nunsigned char *SHA384(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA512_CTX c;\\r\\nstatic unsigned char m[SHA384_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nSHA384_Init(&c);\\r\\nSHA512_Update(&c, d, n);\\r\\nSHA512_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}\\r\\nunsigned char *SHA512(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA512_CTX c;\\r\\nstatic unsigned char m[SHA512_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nSHA512_Init(&c);\\r\\nSHA512_Update(&c, d, n);\\r\\nSHA512_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}\\r\\nstatic SHA_LONG64 __fastcall __pull64be(const void *x)\\r\\n{\\r\\n_asm mov edx,[ecx + 0]\\r\\n_asm mov eax,[ecx + 4]\\r\\n_asm xchg dh, dl\\r\\n_asm xchg ah, al\\r\\n_asm rol edx, 16 _asm rol eax, 16 _asm xchg dh, dl _asm xchg ah, al}\\r\\nstatic SHA_LONG64 __fastcall __pull64be(const void *x)\\r\\n{\\r\\n_asm mov edx,[ecx + 0]\\r\\n_asm mov eax,[ecx + 4]\\r\\n_asm bswap edx _asm bswap eax}\\r\\nstatic void sha512_block_data_order(SHA512_CTX *ctx, const void *in,\\r\\nsize_t num)\\r\\n{\\r\\nconst SHA_LONG64 *W = in;\\r\\nSHA_LONG64 A, E, T;\\r\\nSHA_LONG64 X[9 + 80], *F;\\r\\nint i;\\r\\nwhile (num--) {\\r\\nF = X + 80;\\r\\nA = ctx->h[0];\\r\\nF[1] = ctx->h[1];\\r\\nF[2] = ctx->h[2];\\r\\nF[3] = ctx->h[3];\\r\\nE = ctx->h[4];\\r\\nF[5] = ctx->h[5];\\r\\nF[6] = ctx->h[6];\\r\\nF[7] = ctx->h[7];\\r\\nfor (i = 0; i < 16; i++, F--) {\\r\\n# ifdef B_ENDIAN\\r\\nT = W[i];\\r\\n# else\\r\\nT = PULL64(W[i]);\\r\\n# endif\\r\\nF[0] = A;\\r\\nF[4] = E;\\r\\nF[8] = T;\\r\\nT += F[7] + Sigma1(E) + Ch(E, F[5], F[6]) + K512[i];\\r\\nE = F[3] + T;\\r\\nA = T + Sigma0(A) + Maj(A, F[1], F[2]);\\r\\n}\\r\\nfor (; i < 80; i++, F--) {\\r\\nT = sigma0(F[8 + 16 - 1]);\\r\\nT += sigma1(F[8 + 16 - 14]);\\r\\nT += F[8 + 16] + F[8 + 16 - 9];\\r\\nF[0] = A;\\r\\nF[4] = E;\\r\\nF[8] = T;\\r\\nT += F[7] + Sigma1(E) + Ch(E, F[5], F[6]) + K512[i];\\r\\nE = F[3] + T;\\r\\nA = T + Sigma0(A) + Maj(A, F[1], F[2]);\\r\\n}\\r\\nctx->h[0] += A;\\r\\nctx->h[1] += F[1];\\r\\nctx->h[2] += F[2];\\r\\nctx->h[3] += F[3];\\r\\nctx->h[4] += E;\\r\\nctx->h[5] += F[5];\\r\\nctx->h[6] += F[6];\\r\\nctx->h[7] += F[7];\\r\\nW += SHA_LBLOCK;\\r\\n}\\r\\n}\\r\\nstatic void sha512_block_data_order(SHA512_CTX *ctx, const void *in,\\r\\nsize_t num)\\r\\n{\\r\\nconst SHA_LONG64 *W = in;\\r\\nSHA_LONG64 a, b, c, d, e, f, g, h, s0, s1, T1, T2;\\r\\nSHA_LONG64 X[16];\\r\\nint i;\\r\\nwhile (num--) {\\r\\na = ctx->h[0];\\r\\nb = ctx->h[1];\\r\\nc = ctx->h[2];\\r\\nd = ctx->h[3];\\r\\ne = ctx->h[4];\\r\\nf = ctx->h[5];\\r\\ng = ctx->h[6];\\r\\nh = ctx->h[7];\\r\\nfor (i = 0; i < 16; i++) {\\r\\n# ifdef B_ENDIAN\\r\\nT1 = X[i] = W[i];\\r\\n# else\\r\\nT1 = X[i] = PULL64(W[i]);\\r\\n# endif\\r\\nT1 += h + Sigma1(e) + Ch(e, f, g) + K512[i];\\r\\nT2 = Sigma0(a) + Maj(a, b, c);\\r\\nh = g;\\r\\ng = f;\\r\\nf = e;\\r\\ne = d + T1;\\r\\nd = c;\\r\\nc = b;\\r\\nb = a;\\r\\na = T1 + T2;\\r\\n}\\r\\nfor (; i < 80; i++) {\\r\\ns0 = X[(i + 1) & 0x0f];\\r\\ns0 = sigma0(s0);\\r\\ns1 = X[(i + 14) & 0x0f];\\r\\ns1 = sigma1(s1);\\r\\nT1 = X[i & 0xf] += s0 + s1 + X[(i + 9) & 0xf];\\r\\nT1 += h + Sigma1(e) + Ch(e, f, g) + K512[i];\\r\\nT2 = Sigma0(a) + Maj(a, b, c);\\r\\nh = g;\\r\\ng = f;\\r\\nf = e;\\r\\ne = d + T1;\\r\\nd = c;\\r\\nc = b;\\r\\nb = a;\\r\\na = T1 + T2;\\r\\n}\\r\\nctx->h[0] += a;\\r\\nctx->h[1] += b;\\r\\nctx->h[2] += c;\\r\\nctx->h[3] += d;\\r\\nctx->h[4] += e;\\r\\nctx->h[5] += f;\\r\\nctx->h[6] += g;\\r\\nctx->h[7] += h;\\r\\nW += SHA_LBLOCK;\\r\\n}\\r\\n}\\r\\nstatic void sha512_block_data_order(SHA512_CTX *ctx, const void *in,\\r\\nsize_t num)\\r\\n{\\r\\nconst SHA_LONG64 *W = in;\\r\\nSHA_LONG64 a, b, c, d, e, f, g, h, s0, s1, T1;\\r\\nSHA_LONG64 X[16];\\r\\nint i;\\r\\nwhile (num--) {\\r\\na = ctx->h[0];\\r\\nb = ctx->h[1];\\r\\nc = ctx->h[2];\\r\\nd = ctx->h[3];\\r\\ne = ctx->h[4];\\r\\nf = ctx->h[5];\\r\\ng = ctx->h[6];\\r\\nh = ctx->h[7];\\r\\n# ifdef B_ENDIAN\\r\\nT1 = X[0] = W[0];\\r\\nROUND_00_15(0, a, b, c, d, e, f, g, h);\\r\\nT1 = X[1] = W[1];\\r\\nROUND_00_15(1, h, a, b, c, d, e, f, g);\\r\\nT1 = X[2] = W[2];\\r\\nROUND_00_15(2, g, h, a, b, c, d, e, f);\\r\\nT1 = X[3] = W[3];\\r\\nROUND_00_15(3, f, g, h, a, b, c, d, e);\\r\\nT1 = X[4] = W[4];\\r\\nROUND_00_15(4, e, f, g, h, a, b, c, d);\\r\\nT1 = X[5] = W[5];\\r\\nROUND_00_15(5, d, e, f, g, h, a, b, c);\\r\\nT1 = X[6] = W[6];\\r\\nROUND_00_15(6, c, d, e, f, g, h, a, b);\\r\\nT1 = X[7] = W[7];\\r\\nROUND_00_15(7, b, c, d, e, f, g, h, a);\\r\\nT1 = X[8] = W[8];\\r\\nROUND_00_15(8, a, b, c, d, e, f, g, h);\\r\\nT1 = X[9] = W[9];\\r\\nROUND_00_15(9, h, a, b, c, d, e, f, g);\\r\\nT1 = X[10] = W[10];\\r\\nROUND_00_15(10, g, h, a, b, c, d, e, f);\\r\\nT1 = X[11] = W[11];\\r\\nROUND_00_15(11, f, g, h, a, b, c, d, e);\\r\\nT1 = X[12] = W[12];\\r\\nROUND_00_15(12, e, f, g, h, a, b, c, d);\\r\\nT1 = X[13] = W[13];\\r\\nROUND_00_15(13, d, e, f, g, h, a, b, c);\\r\\nT1 = X[14] = W[14];\\r\\nROUND_00_15(14, c, d, e, f, g, h, a, b);\\r\\nT1 = X[15] = W[15];\\r\\nROUND_00_15(15, b, c, d, e, f, g, h, a);\\r\\n# else\\r\\nT1 = X[0] = PULL64(W[0]);\\r\\nROUND_00_15(0, a, b, c, d, e, f, g, h);\\r\\nT1 = X[1] = PULL64(W[1]);\\r\\nROUND_00_15(1, h, a, b, c, d, e, f, g);\\r\\nT1 = X[2] = PULL64(W[2]);\\r\\nROUND_00_15(2, g, h, a, b, c, d, e, f);\\r\\nT1 = X[3] = PULL64(W[3]);\\r\\nROUND_00_15(3, f, g, h, a, b, c, d, e);\\r\\nT1 = X[4] = PULL64(W[4]);\\r\\nROUND_00_15(4, e, f, g, h, a, b, c, d);\\r\\nT1 = X[5] = PULL64(W[5]);\\r\\nROUND_00_15(5, d, e, f, g, h, a, b, c);\\r\\nT1 = X[6] = PULL64(W[6]);\\r\\nROUND_00_15(6, c, d, e, f, g, h, a, b);\\r\\nT1 = X[7] = PULL64(W[7]);\\r\\nROUND_00_15(7, b, c, d, e, f, g, h, a);\\r\\nT1 = X[8] = PULL64(W[8]);\\r\\nROUND_00_15(8, a, b, c, d, e, f, g, h);\\r\\nT1 = X[9] = PULL64(W[9]);\\r\\nROUND_00_15(9, h, a, b, c, d, e, f, g);\\r\\nT1 = X[10] = PULL64(W[10]);\\r\\nROUND_00_15(10, g, h, a, b, c, d, e, f);\\r\\nT1 = X[11] = PULL64(W[11]);\\r\\nROUND_00_15(11, f, g, h, a, b, c, d, e);\\r\\nT1 = X[12] = PULL64(W[12]);\\r\\nROUND_00_15(12, e, f, g, h, a, b, c, d);\\r\\nT1 = X[13] = PULL64(W[13]);\\r\\nROUND_00_15(13, d, e, f, g, h, a, b, c);\\r\\nT1 = X[14] = PULL64(W[14]);\\r\\nROUND_00_15(14, c, d, e, f, g, h, a, b);\\r\\nT1 = X[15] = PULL64(W[15]);\\r\\nROUND_00_15(15, b, c, d, e, f, g, h, a);\\r\\n# endif\\r\\nfor (i = 16; i < 80; i += 16) {\\r\\nROUND_16_80(i, 0, a, b, c, d, e, f, g, h, X);\\r\\nROUND_16_80(i, 1, h, a, b, c, d, e, f, g, X);\\r\\nROUND_16_80(i, 2, g, h, a, b, c, d, e, f, X);\\r\\nROUND_16_80(i, 3, f, g, h, a, b, c, d, e, X);\\r\\nROUND_16_80(i, 4, e, f, g, h, a, b, c, d, X);\\r\\nROUND_16_80(i, 5, d, e, f, g, h, a, b, c, X);\\r\\nROUND_16_80(i, 6, c, d, e, f, g, h, a, b, X);\\r\\nROUND_16_80(i, 7, b, c, d, e, f, g, h, a, X);\\r\\nROUND_16_80(i, 8, a, b, c, d, e, f, g, h, X);\\r\\nROUND_16_80(i, 9, h, a, b, c, d, e, f, g, X);\\r\\nROUND_16_80(i, 10, g, h, a, b, c, d, e, f, X);\\r\\nROUND_16_80(i, 11, f, g, h, a, b, c, d, e, X);\\r\\nROUND_16_80(i, 12, e, f, g, h, a, b, c, d, X);\\r\\nROUND_16_80(i, 13, d, e, f, g, h, a, b, c, X);\\r\\nROUND_16_80(i, 14, c, d, e, f, g, h, a, b, X);\\r\\nROUND_16_80(i, 15, b, c, d, e, f, g, h, a, X);\\r\\n}\\r\\nctx->h[0] += a;\\r\\nctx->h[1] += b;\\r\\nctx->h[2] += c;\\r\\nctx->h[3] += d;\\r\\nctx->h[4] += e;\\r\\nctx->h[5] += f;\\r\\nctx->h[6] += g;\\r\\nctx->h[7] += h;\\r\\nW += SHA_LBLOCK;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_dd_c", "target": 0, "func": "CMS_ContentInfo *cms_DigestedData_create(const EVP_MD *md)\\r\\n{\\r\\nCMS_ContentInfo *cms;\\r\\nCMS_DigestedData *dd;\\r\\ncms = CMS_ContentInfo_new();\\r\\nif (!cms)\\r\\nreturn NULL;\\r\\ndd = M_ASN1_new_of(CMS_DigestedData);\\r\\nif (!dd)\\r\\ngoto err;\\r\\ncms->contentType = OBJ_nid2obj(NID_pkcs7_digest);\\r\\ncms->d.digestedData = dd;\\r\\ndd->version = 0;\\r\\ndd->encapContentInfo->eContentType = OBJ_nid2obj(NID_pkcs7_data);\\r\\ncms_DigestAlgorithm_set(dd->digestAlgorithm, md);\\r\\nreturn cms;\\r\\nerr:\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nreturn NULL;\\r\\n}\\r\\nBIO *cms_DigestedData_init_bio(CMS_ContentInfo *cms)\\r\\n{\\r\\nCMS_DigestedData *dd;\\r\\ndd = cms->d.digestedData;\\r\\nreturn cms_DigestAlgorithm_init_bio(dd->digestAlgorithm);\\r\\n}\\r\\nint cms_DigestedData_do_final(CMS_ContentInfo *cms, BIO *chain, int verify)\\r\\n{\\r\\nEVP_MD_CTX mctx;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nunsigned int mdlen;\\r\\nint r = 0;\\r\\nCMS_DigestedData *dd;\\r\\nEVP_MD_CTX_init(&mctx);\\r\\ndd = cms->d.digestedData;\\r\\nif (!cms_DigestAlgorithm_find_ctx(&mctx, chain, dd->digestAlgorithm))\\r\\ngoto err;\\r\\nif (EVP_DigestFinal_ex(&mctx, md, &mdlen) <= 0)\\r\\ngoto err;\\r\\nif (verify) {\\r\\nif (mdlen != (unsigned int)dd->digest->length) {\\r\\nCMSerr(CMS_F_CMS_DIGESTEDDATA_DO_FINAL,\\r\\nCMS_R_MESSAGEDIGEST_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nif (memcmp(md, dd->digest->data, mdlen))\\r\\nCMSerr(CMS_F_CMS_DIGESTEDDATA_DO_FINAL,\\r\\nCMS_R_VERIFICATION_FAILURE);\\r\\nelse\\r\\nr = 1;\\r\\n} else {\\r\\nif (!ASN1_STRING_set(dd->digest, md, mdlen))\\r\\ngoto err;\\r\\nr = 1;\\r\\n}\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&mctx);\\r\\nreturn r;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_o_str_c", "target": 0, "func": "int OPENSSL_strncasecmp(const char *str1, const char *str2, size_t n)\\r\\n{\\r\\n#if defined(OPENSSL_IMPLEMENTS_strncasecmp)\\r\\nwhile (*str1 && *str2 && n) {\\r\\nint res = toupper(*str1) - toupper(*str2);\\r\\nif (res)\\r\\nreturn res < 0 ? -1 : 1;\\r\\nstr1++;\\r\\nstr2++;\\r\\nn--;\\r\\n}\\r\\nif (n == 0)\\r\\nreturn 0;\\r\\nif (*str1)\\r\\nreturn 1;\\r\\nif (*str2)\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n#else\\r\\nreturn strncasecmp(str1, str2, n);\\r\\n#endif\\r\\n}\\r\\nint OPENSSL_strcasecmp(const char *str1, const char *str2)\\r\\n{\\r\\n#if defined(OPENSSL_IMPLEMENTS_strncasecmp)\\r\\nreturn OPENSSL_strncasecmp(str1, str2, (size_t)-1);\\r\\n#else\\r\\nreturn strcasecmp(str1, str2);\\r\\n#endif\\r\\n}\\r\\nint OPENSSL_memcmp(const void *v1, const void *v2, size_t n)\\r\\n{\\r\\nconst unsigned char *c1 = v1, *c2 = v2;\\r\\nint ret = 0;\\r\\nwhile (n && (ret = *c1 - *c2) == 0)\\r\\nn--, c1++, c2++;\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_gen_c", "target": 0, "func": "int DSA_generate_parameters_ex(DSA *ret, int bits,\\r\\nconst unsigned char *seed_in, int seed_len,\\r\\nint *counter_ret, unsigned long *h_ret,\\r\\nBN_GENCB *cb)\\r\\n{\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(ret->meth->flags & DSA_FLAG_FIPS_METHOD)\\r\\n&& !(ret->flags & DSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nDSAerr(DSA_F_DSA_GENERATE_PARAMETERS_EX, DSA_R_NON_FIPS_DSA_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\n# endif\\r\\nif (ret->meth->dsa_paramgen)\\r\\nreturn ret->meth->dsa_paramgen(ret, bits, seed_in, seed_len,\\r\\ncounter_ret, h_ret, cb);\\r\\n# ifdef OPENSSL_FIPS\\r\\nelse if (FIPS_mode()) {\\r\\nreturn FIPS_dsa_generate_parameters_ex(ret, bits,\\r\\nseed_in, seed_len,\\r\\ncounter_ret, h_ret, cb);\\r\\n}\\r\\n# endif\\r\\nelse {\\r\\nconst EVP_MD *evpmd;\\r\\nsize_t qbits = bits >= 2048 ? 256 : 160;\\r\\nif (bits >= 2048) {\\r\\nqbits = 256;\\r\\nevpmd = EVP_sha256();\\r\\n} else {\\r\\nqbits = 160;\\r\\nevpmd = EVP_sha1();\\r\\n}\\r\\nreturn dsa_builtin_paramgen(ret, bits, qbits, evpmd,\\r\\nseed_in, seed_len, NULL, counter_ret,\\r\\nh_ret, cb);\\r\\n}\\r\\n}\\r\\nint dsa_builtin_paramgen(DSA *ret, size_t bits, size_t qbits,\\r\\nconst EVP_MD *evpmd, const unsigned char *seed_in,\\r\\nsize_t seed_len, unsigned char *seed_out,\\r\\nint *counter_ret, unsigned long *h_ret, BN_GENCB *cb)\\r\\n{\\r\\nint ok = 0;\\r\\nunsigned char seed[SHA256_DIGEST_LENGTH];\\r\\nunsigned char md[SHA256_DIGEST_LENGTH];\\r\\nunsigned char buf[SHA256_DIGEST_LENGTH], buf2[SHA256_DIGEST_LENGTH];\\r\\nBIGNUM *r0, *W, *X, *c, *test;\\r\\nBIGNUM *g = NULL, *q = NULL, *p = NULL;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nint i, k, n = 0, m = 0, qsize = qbits >> 3;\\r\\nint counter = 0;\\r\\nint r = 0;\\r\\nBN_CTX *ctx = NULL;\\r\\nunsigned int h = 2;\\r\\nif (qsize != SHA_DIGEST_LENGTH && qsize != SHA224_DIGEST_LENGTH &&\\r\\nqsize != SHA256_DIGEST_LENGTH)\\r\\nreturn 0;\\r\\nif (evpmd == NULL)\\r\\nevpmd = EVP_sha1();\\r\\nif (bits < 512)\\r\\nbits = 512;\\r\\nbits = (bits + 63) / 64 * 64;\\r\\nif (seed_len && (seed_len < (size_t)qsize))\\r\\nseed_in = NULL;\\r\\nif (seed_len > (size_t)qsize)\\r\\nseed_len = qsize;\\r\\nif (seed_in != NULL)\\r\\nmemcpy(seed, seed_in, seed_len);\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif ((mont = BN_MONT_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nBN_CTX_start(ctx);\\r\\nr0 = BN_CTX_get(ctx);\\r\\ng = BN_CTX_get(ctx);\\r\\nW = BN_CTX_get(ctx);\\r\\nq = BN_CTX_get(ctx);\\r\\nX = BN_CTX_get(ctx);\\r\\nc = BN_CTX_get(ctx);\\r\\np = BN_CTX_get(ctx);\\r\\ntest = BN_CTX_get(ctx);\\r\\nif (!BN_lshift(test, BN_value_one(), bits - 1))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nfor (;;) {\\r\\nint seed_is_random;\\r\\nif (!BN_GENCB_call(cb, 0, m++))\\r\\ngoto err;\\r\\nif (!seed_len) {\\r\\nRAND_pseudo_bytes(seed, qsize);\\r\\nseed_is_random = 1;\\r\\n} else {\\r\\nseed_is_random = 0;\\r\\nseed_len = 0;\\r\\n}\\r\\nmemcpy(buf, seed, qsize);\\r\\nmemcpy(buf2, seed, qsize);\\r\\nfor (i = qsize - 1; i >= 0; i--) {\\r\\nbuf[i]++;\\r\\nif (buf[i] != 0)\\r\\nbreak;\\r\\n}\\r\\nif (!EVP_Digest(seed, qsize, md, NULL, evpmd, NULL))\\r\\ngoto err;\\r\\nif (!EVP_Digest(buf, qsize, buf2, NULL, evpmd, NULL))\\r\\ngoto err;\\r\\nfor (i = 0; i < qsize; i++)\\r\\nmd[i] ^= buf2[i];\\r\\nmd[0] |= 0x80;\\r\\nmd[qsize - 1] |= 0x01;\\r\\nif (!BN_bin2bn(md, qsize, q))\\r\\ngoto err;\\r\\nr = BN_is_prime_fasttest_ex(q, DSS_prime_checks, ctx,\\r\\nseed_is_random, cb);\\r\\nif (r > 0)\\r\\nbreak;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_GENCB_call(cb, 2, 0))\\r\\ngoto err;\\r\\nif (!BN_GENCB_call(cb, 3, 0))\\r\\ngoto err;\\r\\ncounter = 0;\\r\\nn = (bits - 1) / 160;\\r\\nfor (;;) {\\r\\nif ((counter != 0) && !BN_GENCB_call(cb, 0, counter))\\r\\ngoto err;\\r\\nBN_zero(W);\\r\\nfor (k = 0; k <= n; k++) {\\r\\nfor (i = qsize - 1; i >= 0; i--) {\\r\\nbuf[i]++;\\r\\nif (buf[i] != 0)\\r\\nbreak;\\r\\n}\\r\\nif (!EVP_Digest(buf, qsize, md, NULL, evpmd, NULL))\\r\\ngoto err;\\r\\nif (!BN_bin2bn(md, qsize, r0))\\r\\ngoto err;\\r\\nif (!BN_lshift(r0, r0, (qsize << 3) * k))\\r\\ngoto err;\\r\\nif (!BN_add(W, W, r0))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mask_bits(W, bits - 1))\\r\\ngoto err;\\r\\nif (!BN_copy(X, W))\\r\\ngoto err;\\r\\nif (!BN_add(X, X, test))\\r\\ngoto err;\\r\\nif (!BN_lshift1(r0, q))\\r\\ngoto err;\\r\\nif (!BN_mod(c, X, r0, ctx))\\r\\ngoto err;\\r\\nif (!BN_sub(r0, c, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_sub(p, X, r0))\\r\\ngoto err;\\r\\nif (BN_cmp(p, test) >= 0) {\\r\\nr = BN_is_prime_fasttest_ex(p, DSS_prime_checks, ctx, 1, cb);\\r\\nif (r > 0)\\r\\ngoto end;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\n}\\r\\ncounter++;\\r\\nif (counter >= 4096)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (!BN_GENCB_call(cb, 2, 1))\\r\\ngoto err;\\r\\nif (!BN_sub(test, p, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_div(r0, NULL, test, q, ctx))\\r\\ngoto err;\\r\\nif (!BN_set_word(test, h))\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(mont, p, ctx))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nif (!BN_mod_exp_mont(g, test, r0, p, ctx, mont))\\r\\ngoto err;\\r\\nif (!BN_is_one(g))\\r\\nbreak;\\r\\nif (!BN_add(test, test, BN_value_one()))\\r\\ngoto err;\\r\\nh++;\\r\\n}\\r\\nif (!BN_GENCB_call(cb, 3, 1))\\r\\ngoto err;\\r\\nok = 1;\\r\\nerr:\\r\\nif (ok) {\\r\\nif (ret->p)\\r\\nBN_free(ret->p);\\r\\nif (ret->q)\\r\\nBN_free(ret->q);\\r\\nif (ret->g)\\r\\nBN_free(ret->g);\\r\\nret->p = BN_dup(p);\\r\\nret->q = BN_dup(q);\\r\\nret->g = BN_dup(g);\\r\\nif (ret->p == NULL || ret->q == NULL || ret->g == NULL) {\\r\\nok = 0;\\r\\ngoto err;\\r\\n}\\r\\nif (counter_ret != NULL)\\r\\n*counter_ret = counter;\\r\\nif (h_ret != NULL)\\r\\n*h_ret = h;\\r\\nif (seed_out)\\r\\nmemcpy(seed_out, seed, qsize);\\r\\n}\\r\\nif (ctx) {\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nif (mont != NULL)\\r\\nBN_MONT_CTX_free(mont);\\r\\nreturn ok;\\r\\n}\\r\\nint dsa_builtin_paramgen2(DSA *ret, size_t L, size_t N,\\r\\nconst EVP_MD *evpmd, const unsigned char *seed_in,\\r\\nsize_t seed_len, int idx, unsigned char *seed_out,\\r\\nint *counter_ret, unsigned long *h_ret,\\r\\nBN_GENCB *cb)\\r\\n{\\r\\nint ok = -1;\\r\\nunsigned char *seed = NULL, *seed_tmp = NULL;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nint mdsize;\\r\\nBIGNUM *r0, *W, *X, *c, *test;\\r\\nBIGNUM *g = NULL, *q = NULL, *p = NULL;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nint i, k, n = 0, m = 0, qsize = N >> 3;\\r\\nint counter = 0;\\r\\nint r = 0;\\r\\nBN_CTX *ctx = NULL;\\r\\nEVP_MD_CTX mctx;\\r\\nunsigned int h = 2;\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn fips_dsa_builtin_paramgen2(ret, L, N, evpmd,\\r\\nseed_in, seed_len, idx,\\r\\nseed_out, counter_ret, h_ret, cb);\\r\\n# endif\\r\\nEVP_MD_CTX_init(&mctx);\\r\\nif (evpmd == NULL) {\\r\\nif (N == 160)\\r\\nevpmd = EVP_sha1();\\r\\nelse if (N == 224)\\r\\nevpmd = EVP_sha224();\\r\\nelse\\r\\nevpmd = EVP_sha256();\\r\\n}\\r\\nmdsize = EVP_MD_size(evpmd);\\r\\nif (!ret->p || !ret->q || idx >= 0) {\\r\\nif (seed_len == 0)\\r\\nseed_len = mdsize;\\r\\nseed = OPENSSL_malloc(seed_len);\\r\\nif (seed_out)\\r\\nseed_tmp = seed_out;\\r\\nelse\\r\\nseed_tmp = OPENSSL_malloc(seed_len);\\r\\nif (!seed || !seed_tmp)\\r\\ngoto err;\\r\\nif (seed_in)\\r\\nmemcpy(seed, seed_in, seed_len);\\r\\n}\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif ((mont = BN_MONT_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nBN_CTX_start(ctx);\\r\\nr0 = BN_CTX_get(ctx);\\r\\ng = BN_CTX_get(ctx);\\r\\nW = BN_CTX_get(ctx);\\r\\nX = BN_CTX_get(ctx);\\r\\nc = BN_CTX_get(ctx);\\r\\ntest = BN_CTX_get(ctx);\\r\\nif (ret->p && ret->q) {\\r\\np = ret->p;\\r\\nq = ret->q;\\r\\nif (idx >= 0)\\r\\nmemcpy(seed_tmp, seed, seed_len);\\r\\ngoto g_only;\\r\\n} else {\\r\\np = BN_CTX_get(ctx);\\r\\nq = BN_CTX_get(ctx);\\r\\n}\\r\\nif (!BN_lshift(test, BN_value_one(), L - 1))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nfor (;;) {\\r\\nunsigned char *pmd;\\r\\nif (!BN_GENCB_call(cb, 0, m++))\\r\\ngoto err;\\r\\nif (!seed_in) {\\r\\nif (RAND_pseudo_bytes(seed, seed_len) < 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_Digest(seed, seed_len, md, NULL, evpmd, NULL))\\r\\ngoto err;\\r\\nif (mdsize > qsize)\\r\\npmd = md + mdsize - qsize;\\r\\nelse\\r\\npmd = md;\\r\\nif (mdsize < qsize)\\r\\nmemset(md + mdsize, 0, qsize - mdsize);\\r\\npmd[0] |= 0x80;\\r\\npmd[qsize - 1] |= 0x01;\\r\\nif (!BN_bin2bn(pmd, qsize, q))\\r\\ngoto err;\\r\\nr = BN_is_prime_fasttest_ex(q, DSS_prime_checks, ctx,\\r\\nseed_in ? 1 : 0, cb);\\r\\nif (r > 0)\\r\\nbreak;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\nif (seed_in) {\\r\\nok = 0;\\r\\nDSAerr(DSA_F_DSA_BUILTIN_PARAMGEN2, DSA_R_Q_NOT_PRIME);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (seed_out)\\r\\nmemcpy(seed_out, seed, seed_len);\\r\\nif (!BN_GENCB_call(cb, 2, 0))\\r\\ngoto err;\\r\\nif (!BN_GENCB_call(cb, 3, 0))\\r\\ngoto err;\\r\\ncounter = 0;\\r\\nn = (L - 1) / (mdsize << 3);\\r\\nfor (;;) {\\r\\nif ((counter != 0) && !BN_GENCB_call(cb, 0, counter))\\r\\ngoto err;\\r\\nBN_zero(W);\\r\\nfor (k = 0; k <= n; k++) {\\r\\nfor (i = seed_len - 1; i >= 0; i--) {\\r\\nseed[i]++;\\r\\nif (seed[i] != 0)\\r\\nbreak;\\r\\n}\\r\\nif (!EVP_Digest(seed, seed_len, md, NULL, evpmd, NULL))\\r\\ngoto err;\\r\\nif (!BN_bin2bn(md, mdsize, r0))\\r\\ngoto err;\\r\\nif (!BN_lshift(r0, r0, (mdsize << 3) * k))\\r\\ngoto err;\\r\\nif (!BN_add(W, W, r0))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mask_bits(W, L - 1))\\r\\ngoto err;\\r\\nif (!BN_copy(X, W))\\r\\ngoto err;\\r\\nif (!BN_add(X, X, test))\\r\\ngoto err;\\r\\nif (!BN_lshift1(r0, q))\\r\\ngoto err;\\r\\nif (!BN_mod(c, X, r0, ctx))\\r\\ngoto err;\\r\\nif (!BN_sub(r0, c, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_sub(p, X, r0))\\r\\ngoto err;\\r\\nif (BN_cmp(p, test) >= 0) {\\r\\nr = BN_is_prime_fasttest_ex(p, DSS_prime_checks, ctx, 1, cb);\\r\\nif (r > 0)\\r\\ngoto end;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\n}\\r\\ncounter++;\\r\\nif (counter >= (int)(4 * L))\\r\\nbreak;\\r\\n}\\r\\nif (seed_in) {\\r\\nok = 0;\\r\\nDSAerr(DSA_F_DSA_BUILTIN_PARAMGEN2, DSA_R_INVALID_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (!BN_GENCB_call(cb, 2, 1))\\r\\ngoto err;\\r\\ng_only:\\r\\nif (!BN_sub(test, p, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_div(r0, NULL, test, q, ctx))\\r\\ngoto err;\\r\\nif (idx < 0) {\\r\\nif (!BN_set_word(test, h))\\r\\ngoto err;\\r\\n} else\\r\\nh = 1;\\r\\nif (!BN_MONT_CTX_set(mont, p, ctx))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nstatic const unsigned char ggen[4] = { 0x67, 0x67, 0x65, 0x6e };\\r\\nif (idx >= 0) {\\r\\nmd[0] = idx & 0xff;\\r\\nmd[1] = (h >> 8) & 0xff;\\r\\nmd[2] = h & 0xff;\\r\\nif (!EVP_DigestInit_ex(&mctx, evpmd, NULL))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&mctx, seed_tmp, seed_len))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&mctx, ggen, sizeof(ggen)))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&mctx, md, 3))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&mctx, md, NULL))\\r\\ngoto err;\\r\\nif (!BN_bin2bn(md, mdsize, test))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_exp_mont(g, test, r0, p, ctx, mont))\\r\\ngoto err;\\r\\nif (!BN_is_one(g))\\r\\nbreak;\\r\\nif (idx < 0 && !BN_add(test, test, BN_value_one()))\\r\\ngoto err;\\r\\nh++;\\r\\nif (idx >= 0 && h > 0xffff)\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_GENCB_call(cb, 3, 1))\\r\\ngoto err;\\r\\nok = 1;\\r\\nerr:\\r\\nif (ok == 1) {\\r\\nif (p != ret->p) {\\r\\nif (ret->p)\\r\\nBN_free(ret->p);\\r\\nret->p = BN_dup(p);\\r\\n}\\r\\nif (q != ret->q) {\\r\\nif (ret->q)\\r\\nBN_free(ret->q);\\r\\nret->q = BN_dup(q);\\r\\n}\\r\\nif (ret->g)\\r\\nBN_free(ret->g);\\r\\nret->g = BN_dup(g);\\r\\nif (ret->p == NULL || ret->q == NULL || ret->g == NULL) {\\r\\nok = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (counter_ret != NULL)\\r\\n*counter_ret = counter;\\r\\nif (h_ret != NULL)\\r\\n*h_ret = h;\\r\\n}\\r\\nif (seed)\\r\\nOPENSSL_free(seed);\\r\\nif (seed_out != seed_tmp)\\r\\nOPENSSL_free(seed_tmp);\\r\\nif (ctx) {\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nif (mont != NULL)\\r\\nBN_MONT_CTX_free(mont);\\r\\nEVP_MD_CTX_cleanup(&mctx);\\r\\nreturn ok;\\r\\n}\\r\\nint dsa_paramgen_check_g(DSA *dsa)\\r\\n{\\r\\nBN_CTX *ctx;\\r\\nBIGNUM *tmp;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nint rv = -1;\\r\\nctx = BN_CTX_new();\\r\\nif (!ctx)\\r\\nreturn -1;\\r\\nBN_CTX_start(ctx);\\r\\nif (BN_cmp(dsa->g, BN_value_one()) <= 0)\\r\\nreturn 0;\\r\\nif (BN_cmp(dsa->g, dsa->p) >= 0)\\r\\nreturn 0;\\r\\ntmp = BN_CTX_get(ctx);\\r\\nif (!tmp)\\r\\ngoto err;\\r\\nif ((mont = BN_MONT_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(mont, dsa->p, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_exp_mont(tmp, dsa->g, dsa->q, dsa->p, ctx, mont))\\r\\ngoto err;\\r\\nif (!BN_cmp(tmp, BN_value_one()))\\r\\nrv = 1;\\r\\nelse\\r\\nrv = 0;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (mont)\\r\\nBN_MONT_CTX_free(mont);\\r\\nBN_CTX_free(ctx);\\r\\nreturn rv;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p_dec_c", "target": 0, "func": "int EVP_PKEY_decrypt_old(unsigned char *key, const unsigned char *ek, int ekl,\\r\\nEVP_PKEY *priv)\\r\\n{\\r\\nint ret = -1;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (priv->type != EVP_PKEY_RSA) {\\r\\n#endif\\r\\nEVPerr(EVP_F_EVP_PKEY_DECRYPT_OLD, EVP_R_PUBLIC_KEY_NOT_RSA);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ngoto err;\\r\\n}\\r\\nret =\\r\\nRSA_private_decrypt(ekl, ek, key, priv->pkey.rsa, RSA_PKCS1_PADDING);\\r\\nerr:\\r\\n#endif\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_sparcv9cap_c", "target": 0, "func": "int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0, int num)\\r\\n{\\r\\nint bn_mul_mont_vis3(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0, int num);\\r\\nint bn_mul_mont_fpu(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0, int num);\\r\\nint bn_mul_mont_int(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0, int num);\\r\\nif (!(num & 1) && num >= 6) {\\r\\nif ((num & 15) == 0 && num <= 64 &&\\r\\n(OPENSSL_sparcv9cap_P[1] & (CFR_MONTMUL | CFR_MONTSQR)) ==\\r\\n(CFR_MONTMUL | CFR_MONTSQR)) {\\r\\ntypedef int (*bn_mul_mont_f) (BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst BN_ULONG *bp,\\r\\nconst BN_ULONG *np,\\r\\nconst BN_ULONG *n0);\\r\\nint bn_mul_mont_t4_8(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst BN_ULONG *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0);\\r\\nint bn_mul_mont_t4_16(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst BN_ULONG *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0);\\r\\nint bn_mul_mont_t4_24(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst BN_ULONG *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0);\\r\\nint bn_mul_mont_t4_32(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst BN_ULONG *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0);\\r\\nstatic const bn_mul_mont_f funcs[4] = {\\r\\nbn_mul_mont_t4_8, bn_mul_mont_t4_16,\\r\\nbn_mul_mont_t4_24, bn_mul_mont_t4_32\\r\\n};\\r\\nbn_mul_mont_f worker = funcs[num / 16 - 1];\\r\\nif ((*worker) (rp, ap, bp, np, n0))\\r\\nreturn 1;\\r\\nif ((*worker) (rp, ap, bp, np, n0))\\r\\nreturn 1;\\r\\nreturn bn_mul_mont_vis3(rp, ap, bp, np, n0, num);\\r\\n}\\r\\nif ((OPENSSL_sparcv9cap_P[0] & SPARCV9_VIS3))\\r\\nreturn bn_mul_mont_vis3(rp, ap, bp, np, n0, num);\\r\\nelse if (num >= 8 &&\\r\\n(OPENSSL_sparcv9cap_P[0] &\\r\\n(SPARCV9_PREFER_FPU | SPARCV9_VIS1)) ==\\r\\n(SPARCV9_PREFER_FPU | SPARCV9_VIS1))\\r\\nreturn bn_mul_mont_fpu(rp, ap, bp, np, n0, num);\\r\\n}\\r\\nreturn bn_mul_mont_int(rp, ap, bp, np, n0, num);\\r\\n}\\r\\nunsigned long OPENSSL_rdtsc(void)\\r\\n{\\r\\nif (OPENSSL_sparcv9cap_P[0] & SPARCV9_TICK_PRIVILEGED)\\r\\n#if defined(__sun) && defined(__SVR4)\\r\\nreturn gethrtime();\\r\\n#else\\r\\nreturn 0;\\r\\n#endif\\r\\nelse\\r\\nreturn _sparcv9_rdtick();\\r\\n}\\r\\nsize_t OPENSSL_instrument_bus(unsigned int *out, size_t cnt)\\r\\n{\\r\\nif ((OPENSSL_sparcv9cap_P[0] & (SPARCV9_TICK_PRIVILEGED | SPARCV9_BLK)) ==\\r\\nSPARCV9_BLK)\\r\\nreturn _sparcv9_vis1_instrument_bus(out, cnt);\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nsize_t OPENSSL_instrument_bus2(unsigned int *out, size_t cnt, size_t max)\\r\\n{\\r\\nif ((OPENSSL_sparcv9cap_P[0] & (SPARCV9_TICK_PRIVILEGED | SPARCV9_BLK)) ==\\r\\nSPARCV9_BLK)\\r\\nreturn _sparcv9_vis1_instrument_bus2(out, cnt, max);\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nstatic void common_handler(int sig)\\r\\n{\\r\\nsiglongjmp(common_jmp, sig);\\r\\n}\\r\\nvoid OPENSSL_cpuid_setup(void)\\r\\n{\\r\\nchar *e;\\r\\nstruct sigaction common_act, ill_oact, bus_oact;\\r\\nsigset_t all_masked, oset;\\r\\nstatic int trigger = 0;\\r\\nif (trigger)\\r\\nreturn;\\r\\ntrigger = 1;\\r\\nif ((e = getenv(\"OPENSSL_sparcv9cap\"))) {\\r\\nOPENSSL_sparcv9cap_P[0] = strtoul(e, NULL, 0);\\r\\nif ((e = strchr(e, ':')))\\r\\nOPENSSL_sparcv9cap_P[1] = strtoul(e + 1, NULL, 0);\\r\\nreturn;\\r\\n}\\r\\nOPENSSL_sparcv9cap_P[0] = SPARCV9_PREFER_FPU | SPARCV9_TICK_PRIVILEGED;\\r\\nsigfillset(&all_masked);\\r\\nsigdelset(&all_masked, SIGILL);\\r\\nsigdelset(&all_masked, SIGTRAP);\\r\\n# ifdef SIGEMT\\r\\nsigdelset(&all_masked, SIGEMT);\\r\\n# endif\\r\\nsigdelset(&all_masked, SIGFPE);\\r\\nsigdelset(&all_masked, SIGBUS);\\r\\nsigdelset(&all_masked, SIGSEGV);\\r\\nsigprocmask(SIG_SETMASK, &all_masked, &oset);\\r\\nmemset(&common_act, 0, sizeof(common_act));\\r\\ncommon_act.sa_handler = common_handler;\\r\\ncommon_act.sa_mask = all_masked;\\r\\nsigaction(SIGILL, &common_act, &ill_oact);\\r\\nsigaction(SIGBUS, &common_act, &bus_oact);\\r\\nif (sigsetjmp(common_jmp, 1) == 0) {\\r\\n_sparcv9_rdtick();\\r\\nOPENSSL_sparcv9cap_P[0] &= ~SPARCV9_TICK_PRIVILEGED;\\r\\n}\\r\\nif (sigsetjmp(common_jmp, 1) == 0) {\\r\\n_sparcv9_vis1_probe();\\r\\nOPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS1 | SPARCV9_BLK;\\r\\nif (_sparcv9_vis1_instrument() >= 12)\\r\\nOPENSSL_sparcv9cap_P[0] &= ~(SPARCV9_VIS1 | SPARCV9_PREFER_FPU);\\r\\nelse {\\r\\n_sparcv9_vis2_probe();\\r\\nOPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS2;\\r\\n}\\r\\n}\\r\\nif (sigsetjmp(common_jmp, 1) == 0) {\\r\\n_sparcv9_fmadd_probe();\\r\\nOPENSSL_sparcv9cap_P[0] |= SPARCV9_FMADD;\\r\\n}\\r\\nif (sigsetjmp(common_jmp, 1) == 0) {\\r\\n_sparcv9_vis3_probe();\\r\\nOPENSSL_sparcv9cap_P[0] |= SPARCV9_VIS3;\\r\\n}\\r\\n# if 0\\r\\nif (sigsetjmp(common_jmp, 1) == 0) {\\r\\n(void)_sparcv9_random();\\r\\nOPENSSL_sparcv9cap_P[0] |= SPARCV9_RANDOM;\\r\\n}\\r\\n# endif\\r\\nif ((OPENSSL_sparcv9cap_P[0] & SPARCV9_VIS3) &&\\r\\nsigsetjmp(common_jmp, 1) == 0) {\\r\\nOPENSSL_sparcv9cap_P[1] = (unsigned int)_sparcv9_rdcfr();\\r\\n}\\r\\nsigaction(SIGBUS, &bus_oact, NULL);\\r\\nsigaction(SIGILL, &ill_oact, NULL);\\r\\nsigprocmask(SIG_SETMASK, &oset, NULL);\\r\\nif (sizeof(size_t) == 8)\\r\\nOPENSSL_sparcv9cap_P[0] |= SPARCV9_64BIT_STACK;\\r\\n# ifdef __linux\\r\\nelse {\\r\\nint ret = syscall(340);\\r\\nif (ret >= 0 && ret & 1)\\r\\nOPENSSL_sparcv9cap_P[0] |= SPARCV9_64BIT_STACK;\\r\\n}\\r\\n# endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_xcbc_d_c", "target": 0, "func": "const EVP_CIPHER *EVP_desx_cbc(void)\\r\\n{\\r\\nreturn (&d_xcbc_cipher);\\r\\n}\\r\\nstatic int desx_cbc_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES_cblock *deskey = (DES_cblock *)key;\\r\\nDES_set_key_unchecked(deskey, &data(ctx)->ks);\\r\\nmemcpy(&data(ctx)->inw[0], &key[8], 8);\\r\\nmemcpy(&data(ctx)->outw[0], &key[16], 8);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int desx_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nwhile (inl >= EVP_MAXCHUNK) {\\r\\nDES_xcbc_encrypt(in, out, (long)EVP_MAXCHUNK, &data(ctx)->ks,\\r\\n(DES_cblock *)&(ctx->iv[0]),\\r\\n&data(ctx)->inw, &data(ctx)->outw, ctx->encrypt);\\r\\ninl -= EVP_MAXCHUNK;\\r\\nin += EVP_MAXCHUNK;\\r\\nout += EVP_MAXCHUNK;\\r\\n}\\r\\nif (inl)\\r\\nDES_xcbc_encrypt(in, out, (long)inl, &data(ctx)->ks,\\r\\n(DES_cblock *)&(ctx->iv[0]),\\r\\n&data(ctx)->inw, &data(ctx)->outw, ctx->encrypt);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecp_nistp224_c", "target": 0, "func": "const EC_METHOD *EC_GFp_nistp224_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nEC_FLAGS_DEFAULT_OCT,\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_nistp224_group_init,\\r\\nec_GFp_simple_group_finish,\\r\\nec_GFp_simple_group_clear_finish,\\r\\nec_GFp_nist_group_copy,\\r\\nec_GFp_nistp224_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\nec_GFp_nistp224_point_get_affine_coordinates,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\nec_GFp_nistp224_points_mul,\\r\\nec_GFp_nistp224_precompute_mult,\\r\\nec_GFp_nistp224_have_precompute_mult,\\r\\nec_GFp_nist_field_mul,\\r\\nec_GFp_nist_field_sqr,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\n0\\r\\n};\\r\\nreturn &ret;\\r\\n}\\r\\nstatic void bin28_to_felem(felem out, const u8 in[28])\\r\\n{\\r\\nout[0] = *((const uint64_t *)(in)) & 0x00ffffffffffffff;\\r\\nout[1] = (*((const uint64_t *)(in + 7))) & 0x00ffffffffffffff;\\r\\nout[2] = (*((const uint64_t *)(in + 14))) & 0x00ffffffffffffff;\\r\\nout[3] = (*((const uint64_t *)(in + 21))) & 0x00ffffffffffffff;\\r\\n}\\r\\nstatic void felem_to_bin28(u8 out[28], const felem in)\\r\\n{\\r\\nunsigned i;\\r\\nfor (i = 0; i < 7; ++i) {\\r\\nout[i] = in[0] >> (8 * i);\\r\\nout[i + 7] = in[1] >> (8 * i);\\r\\nout[i + 14] = in[2] >> (8 * i);\\r\\nout[i + 21] = in[3] >> (8 * i);\\r\\n}\\r\\n}\\r\\nstatic void flip_endian(u8 *out, const u8 *in, unsigned len)\\r\\n{\\r\\nunsigned i;\\r\\nfor (i = 0; i < len; ++i)\\r\\nout[i] = in[len - 1 - i];\\r\\n}\\r\\nstatic int BN_to_felem(felem out, const BIGNUM *bn)\\r\\n{\\r\\nfelem_bytearray b_in;\\r\\nfelem_bytearray b_out;\\r\\nunsigned num_bytes;\\r\\nmemset(b_out, 0, sizeof b_out);\\r\\nnum_bytes = BN_num_bytes(bn);\\r\\nif (num_bytes > sizeof b_out) {\\r\\nECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\nif (BN_is_negative(bn)) {\\r\\nECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\nnum_bytes = BN_bn2bin(bn, b_in);\\r\\nflip_endian(b_out, b_in, num_bytes);\\r\\nbin28_to_felem(out, b_out);\\r\\nreturn 1;\\r\\n}\\r\\nstatic BIGNUM *felem_to_BN(BIGNUM *out, const felem in)\\r\\n{\\r\\nfelem_bytearray b_in, b_out;\\r\\nfelem_to_bin28(b_in, in);\\r\\nflip_endian(b_out, b_in, sizeof b_out);\\r\\nreturn BN_bin2bn(b_out, sizeof b_out, out);\\r\\n}\\r\\nstatic void felem_one(felem out)\\r\\n{\\r\\nout[0] = 1;\\r\\nout[1] = 0;\\r\\nout[2] = 0;\\r\\nout[3] = 0;\\r\\n}\\r\\nstatic void felem_assign(felem out, const felem in)\\r\\n{\\r\\nout[0] = in[0];\\r\\nout[1] = in[1];\\r\\nout[2] = in[2];\\r\\nout[3] = in[3];\\r\\n}\\r\\nstatic void felem_sum(felem out, const felem in)\\r\\n{\\r\\nout[0] += in[0];\\r\\nout[1] += in[1];\\r\\nout[2] += in[2];\\r\\nout[3] += in[3];\\r\\n}\\r\\nstatic void felem_neg(felem out, const felem in)\\r\\n{\\r\\nstatic const limb two58p2 = (((limb) 1) << 58) + (((limb) 1) << 2);\\r\\nstatic const limb two58m2 = (((limb) 1) << 58) - (((limb) 1) << 2);\\r\\nstatic const limb two58m42m2 = (((limb) 1) << 58) -\\r\\n(((limb) 1) << 42) - (((limb) 1) << 2);\\r\\nout[0] = two58p2 - in[0];\\r\\nout[1] = two58m42m2 - in[1];\\r\\nout[2] = two58m2 - in[2];\\r\\nout[3] = two58m2 - in[3];\\r\\n}\\r\\nstatic void felem_diff(felem out, const felem in)\\r\\n{\\r\\nstatic const limb two58p2 = (((limb) 1) << 58) + (((limb) 1) << 2);\\r\\nstatic const limb two58m2 = (((limb) 1) << 58) - (((limb) 1) << 2);\\r\\nstatic const limb two58m42m2 = (((limb) 1) << 58) -\\r\\n(((limb) 1) << 42) - (((limb) 1) << 2);\\r\\nout[0] += two58p2;\\r\\nout[1] += two58m42m2;\\r\\nout[2] += two58m2;\\r\\nout[3] += two58m2;\\r\\nout[0] -= in[0];\\r\\nout[1] -= in[1];\\r\\nout[2] -= in[2];\\r\\nout[3] -= in[3];\\r\\n}\\r\\nstatic void widefelem_diff(widefelem out, const widefelem in)\\r\\n{\\r\\nstatic const widelimb two120 = ((widelimb) 1) << 120;\\r\\nstatic const widelimb two120m64 = (((widelimb) 1) << 120) -\\r\\n(((widelimb) 1) << 64);\\r\\nstatic const widelimb two120m104m64 = (((widelimb) 1) << 120) -\\r\\n(((widelimb) 1) << 104) - (((widelimb) 1) << 64);\\r\\nout[0] += two120;\\r\\nout[1] += two120m64;\\r\\nout[2] += two120m64;\\r\\nout[3] += two120;\\r\\nout[4] += two120m104m64;\\r\\nout[5] += two120m64;\\r\\nout[6] += two120m64;\\r\\nout[0] -= in[0];\\r\\nout[1] -= in[1];\\r\\nout[2] -= in[2];\\r\\nout[3] -= in[3];\\r\\nout[4] -= in[4];\\r\\nout[5] -= in[5];\\r\\nout[6] -= in[6];\\r\\n}\\r\\nstatic void felem_diff_128_64(widefelem out, const felem in)\\r\\n{\\r\\nstatic const widelimb two64p8 = (((widelimb) 1) << 64) +\\r\\n(((widelimb) 1) << 8);\\r\\nstatic const widelimb two64m8 = (((widelimb) 1) << 64) -\\r\\n(((widelimb) 1) << 8);\\r\\nstatic const widelimb two64m48m8 = (((widelimb) 1) << 64) -\\r\\n(((widelimb) 1) << 48) - (((widelimb) 1) << 8);\\r\\nout[0] += two64p8;\\r\\nout[1] += two64m48m8;\\r\\nout[2] += two64m8;\\r\\nout[3] += two64m8;\\r\\nout[0] -= in[0];\\r\\nout[1] -= in[1];\\r\\nout[2] -= in[2];\\r\\nout[3] -= in[3];\\r\\n}\\r\\nstatic void felem_scalar(felem out, const limb scalar)\\r\\n{\\r\\nout[0] *= scalar;\\r\\nout[1] *= scalar;\\r\\nout[2] *= scalar;\\r\\nout[3] *= scalar;\\r\\n}\\r\\nstatic void widefelem_scalar(widefelem out, const widelimb scalar)\\r\\n{\\r\\nout[0] *= scalar;\\r\\nout[1] *= scalar;\\r\\nout[2] *= scalar;\\r\\nout[3] *= scalar;\\r\\nout[4] *= scalar;\\r\\nout[5] *= scalar;\\r\\nout[6] *= scalar;\\r\\n}\\r\\nstatic void felem_square(widefelem out, const felem in)\\r\\n{\\r\\nlimb tmp0, tmp1, tmp2;\\r\\ntmp0 = 2 * in[0];\\r\\ntmp1 = 2 * in[1];\\r\\ntmp2 = 2 * in[2];\\r\\nout[0] = ((widelimb) in[0]) * in[0];\\r\\nout[1] = ((widelimb) in[0]) * tmp1;\\r\\nout[2] = ((widelimb) in[0]) * tmp2 + ((widelimb) in[1]) * in[1];\\r\\nout[3] = ((widelimb) in[3]) * tmp0 + ((widelimb) in[1]) * tmp2;\\r\\nout[4] = ((widelimb) in[3]) * tmp1 + ((widelimb) in[2]) * in[2];\\r\\nout[5] = ((widelimb) in[3]) * tmp2;\\r\\nout[6] = ((widelimb) in[3]) * in[3];\\r\\n}\\r\\nstatic void felem_mul(widefelem out, const felem in1, const felem in2)\\r\\n{\\r\\nout[0] = ((widelimb) in1[0]) * in2[0];\\r\\nout[1] = ((widelimb) in1[0]) * in2[1] + ((widelimb) in1[1]) * in2[0];\\r\\nout[2] = ((widelimb) in1[0]) * in2[2] + ((widelimb) in1[1]) * in2[1] +\\r\\n((widelimb) in1[2]) * in2[0];\\r\\nout[3] = ((widelimb) in1[0]) * in2[3] + ((widelimb) in1[1]) * in2[2] +\\r\\n((widelimb) in1[2]) * in2[1] + ((widelimb) in1[3]) * in2[0];\\r\\nout[4] = ((widelimb) in1[1]) * in2[3] + ((widelimb) in1[2]) * in2[2] +\\r\\n((widelimb) in1[3]) * in2[1];\\r\\nout[5] = ((widelimb) in1[2]) * in2[3] + ((widelimb) in1[3]) * in2[2];\\r\\nout[6] = ((widelimb) in1[3]) * in2[3];\\r\\n}\\r\\nstatic void felem_reduce(felem out, const widefelem in)\\r\\n{\\r\\nstatic const widelimb two127p15 = (((widelimb) 1) << 127) +\\r\\n(((widelimb) 1) << 15);\\r\\nstatic const widelimb two127m71 = (((widelimb) 1) << 127) -\\r\\n(((widelimb) 1) << 71);\\r\\nstatic const widelimb two127m71m55 = (((widelimb) 1) << 127) -\\r\\n(((widelimb) 1) << 71) - (((widelimb) 1) << 55);\\r\\nwidelimb output[5];\\r\\noutput[0] = in[0] + two127p15;\\r\\noutput[1] = in[1] + two127m71m55;\\r\\noutput[2] = in[2] + two127m71;\\r\\noutput[3] = in[3];\\r\\noutput[4] = in[4];\\r\\noutput[4] += in[6] >> 16;\\r\\noutput[3] += (in[6] & 0xffff) << 40;\\r\\noutput[2] -= in[6];\\r\\noutput[3] += in[5] >> 16;\\r\\noutput[2] += (in[5] & 0xffff) << 40;\\r\\noutput[1] -= in[5];\\r\\noutput[2] += output[4] >> 16;\\r\\noutput[1] += (output[4] & 0xffff) << 40;\\r\\noutput[0] -= output[4];\\r\\noutput[3] += output[2] >> 56;\\r\\noutput[2] &= 0x00ffffffffffffff;\\r\\noutput[4] = output[3] >> 56;\\r\\noutput[3] &= 0x00ffffffffffffff;\\r\\noutput[2] += output[4] >> 16;\\r\\noutput[1] += (output[4] & 0xffff) << 40;\\r\\noutput[0] -= output[4];\\r\\noutput[1] += output[0] >> 56;\\r\\nout[0] = output[0] & 0x00ffffffffffffff;\\r\\noutput[2] += output[1] >> 56;\\r\\nout[1] = output[1] & 0x00ffffffffffffff;\\r\\noutput[3] += output[2] >> 56;\\r\\nout[2] = output[2] & 0x00ffffffffffffff;\\r\\nout[3] = output[3];\\r\\n}\\r\\nstatic void felem_square_reduce(felem out, const felem in)\\r\\n{\\r\\nwidefelem tmp;\\r\\nfelem_square(tmp, in);\\r\\nfelem_reduce(out, tmp);\\r\\n}\\r\\nstatic void felem_mul_reduce(felem out, const felem in1, const felem in2)\\r\\n{\\r\\nwidefelem tmp;\\r\\nfelem_mul(tmp, in1, in2);\\r\\nfelem_reduce(out, tmp);\\r\\n}\\r\\nstatic void felem_contract(felem out, const felem in)\\r\\n{\\r\\nstatic const int64_t two56 = ((limb) 1) << 56;\\r\\nint64_t tmp[4], a;\\r\\ntmp[0] = in[0];\\r\\ntmp[1] = in[1];\\r\\ntmp[2] = in[2];\\r\\ntmp[3] = in[3];\\r\\na = (in[3] >> 56);\\r\\ntmp[0] -= a;\\r\\ntmp[1] += a << 40;\\r\\ntmp[3] &= 0x00ffffffffffffff;\\r\\na = ((in[3] & in[2] & (in[1] | 0x000000ffffffffff)) + 1) |\\r\\n(((int64_t) (in[0] + (in[1] & 0x000000ffffffffff)) - 1) >> 63);\\r\\na &= 0x00ffffffffffffff;\\r\\na = (a - 1) >> 63;\\r\\ntmp[3] &= a ^ 0xffffffffffffffff;\\r\\ntmp[2] &= a ^ 0xffffffffffffffff;\\r\\ntmp[1] &= (a ^ 0xffffffffffffffff) | 0x000000ffffffffff;\\r\\ntmp[0] -= 1 & a;\\r\\na = tmp[0] >> 63;\\r\\ntmp[0] += two56 & a;\\r\\ntmp[1] -= 1 & a;\\r\\ntmp[2] += tmp[1] >> 56;\\r\\ntmp[1] &= 0x00ffffffffffffff;\\r\\ntmp[3] += tmp[2] >> 56;\\r\\ntmp[2] &= 0x00ffffffffffffff;\\r\\nout[0] = tmp[0];\\r\\nout[1] = tmp[1];\\r\\nout[2] = tmp[2];\\r\\nout[3] = tmp[3];\\r\\n}\\r\\nstatic limb felem_is_zero(const felem in)\\r\\n{\\r\\nlimb zero, two224m96p1, two225m97p2;\\r\\nzero = in[0] | in[1] | in[2] | in[3];\\r\\nzero = (((int64_t) (zero) - 1) >> 63) & 1;\\r\\ntwo224m96p1 = (in[0] ^ 1) | (in[1] ^ 0x00ffff0000000000)\\r\\n| (in[2] ^ 0x00ffffffffffffff) | (in[3] ^ 0x00ffffffffffffff);\\r\\ntwo224m96p1 = (((int64_t) (two224m96p1) - 1) >> 63) & 1;\\r\\ntwo225m97p2 = (in[0] ^ 2) | (in[1] ^ 0x00fffe0000000000)\\r\\n| (in[2] ^ 0x00ffffffffffffff) | (in[3] ^ 0x01ffffffffffffff);\\r\\ntwo225m97p2 = (((int64_t) (two225m97p2) - 1) >> 63) & 1;\\r\\nreturn (zero | two224m96p1 | two225m97p2);\\r\\n}\\r\\nstatic limb felem_is_zero_int(const felem in)\\r\\n{\\r\\nreturn (int)(felem_is_zero(in) & ((limb) 1));\\r\\n}\\r\\nstatic void felem_inv(felem out, const felem in)\\r\\n{\\r\\nfelem ftmp, ftmp2, ftmp3, ftmp4;\\r\\nwidefelem tmp;\\r\\nunsigned i;\\r\\nfelem_square(tmp, in);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, in, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, in, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, ftmp2, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfor (i = 0; i < 5; ++i) {\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp2, ftmp);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfor (i = 0; i < 11; ++i) {\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfor (i = 0; i < 23; ++i) {\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\nfor (i = 0; i < 47; ++i) {\\r\\nfelem_square(tmp, ftmp4);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp4);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\nfor (i = 0; i < 23; ++i) {\\r\\nfelem_square(tmp, ftmp4);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp2, ftmp4);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfor (i = 0; i < 6; ++i) {\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp2, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, ftmp, in);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfor (i = 0; i < 97; ++i) {\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp, ftmp3);\\r\\nfelem_reduce(out, tmp);\\r\\n}\\r\\nstatic void copy_conditional(felem out, const felem in, limb icopy)\\r\\n{\\r\\nunsigned i;\\r\\nconst limb copy = -icopy;\\r\\nfor (i = 0; i < 4; ++i) {\\r\\nconst limb tmp = copy & (in[i] ^ out[i]);\\r\\nout[i] ^= tmp;\\r\\n}\\r\\n}\\r\\nstatic void\\r\\npoint_double(felem x_out, felem y_out, felem z_out,\\r\\nconst felem x_in, const felem y_in, const felem z_in)\\r\\n{\\r\\nwidefelem tmp, tmp2;\\r\\nfelem delta, gamma, beta, alpha, ftmp, ftmp2;\\r\\nfelem_assign(ftmp, x_in);\\r\\nfelem_assign(ftmp2, x_in);\\r\\nfelem_square(tmp, z_in);\\r\\nfelem_reduce(delta, tmp);\\r\\nfelem_square(tmp, y_in);\\r\\nfelem_reduce(gamma, tmp);\\r\\nfelem_mul(tmp, x_in, gamma);\\r\\nfelem_reduce(beta, tmp);\\r\\nfelem_diff(ftmp, delta);\\r\\nfelem_sum(ftmp2, delta);\\r\\nfelem_scalar(ftmp2, 3);\\r\\nfelem_mul(tmp, ftmp, ftmp2);\\r\\nfelem_reduce(alpha, tmp);\\r\\nfelem_square(tmp, alpha);\\r\\nfelem_assign(ftmp, beta);\\r\\nfelem_scalar(ftmp, 8);\\r\\nfelem_diff_128_64(tmp, ftmp);\\r\\nfelem_reduce(x_out, tmp);\\r\\nfelem_sum(delta, gamma);\\r\\nfelem_assign(ftmp, y_in);\\r\\nfelem_sum(ftmp, z_in);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_diff_128_64(tmp, delta);\\r\\nfelem_reduce(z_out, tmp);\\r\\nfelem_scalar(beta, 4);\\r\\nfelem_diff(beta, x_out);\\r\\nfelem_mul(tmp, alpha, beta);\\r\\nfelem_square(tmp2, gamma);\\r\\nwidefelem_scalar(tmp2, 8);\\r\\nwidefelem_diff(tmp, tmp2);\\r\\nfelem_reduce(y_out, tmp);\\r\\n}\\r\\nstatic void point_add(felem x3, felem y3, felem z3,\\r\\nconst felem x1, const felem y1, const felem z1,\\r\\nconst int mixed, const felem x2, const felem y2,\\r\\nconst felem z2)\\r\\n{\\r\\nfelem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\\r\\nwidefelem tmp, tmp2;\\r\\nlimb z1_is_zero, z2_is_zero, x_equal, y_equal;\\r\\nif (!mixed) {\\r\\nfelem_square(tmp, z2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, ftmp2, z2);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\nfelem_mul(tmp2, ftmp4, y1);\\r\\nfelem_reduce(ftmp4, tmp2);\\r\\nfelem_mul(tmp2, ftmp2, x1);\\r\\nfelem_reduce(ftmp2, tmp2);\\r\\n} else {\\r\\nfelem_assign(ftmp4, y1);\\r\\nfelem_assign(ftmp2, x1);\\r\\n}\\r\\nfelem_square(tmp, z1);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, ftmp, z1);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_mul(tmp, ftmp3, y2);\\r\\nfelem_diff_128_64(tmp, ftmp4);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_mul(tmp, ftmp, x2);\\r\\nfelem_diff_128_64(tmp, ftmp2);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nx_equal = felem_is_zero(ftmp);\\r\\ny_equal = felem_is_zero(ftmp3);\\r\\nz1_is_zero = felem_is_zero(z1);\\r\\nz2_is_zero = felem_is_zero(z2);\\r\\nif (x_equal && y_equal && !z1_is_zero && !z2_is_zero) {\\r\\npoint_double(x3, y3, z3, x1, y1, z1);\\r\\nreturn;\\r\\n}\\r\\nif (!mixed) {\\r\\nfelem_mul(tmp, z1, z2);\\r\\nfelem_reduce(ftmp5, tmp);\\r\\n} else {\\r\\nfelem_assign(ftmp5, z1);\\r\\n}\\r\\nfelem_mul(tmp, ftmp, ftmp5);\\r\\nfelem_reduce(z_out, tmp);\\r\\nfelem_assign(ftmp5, ftmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, ftmp, ftmp5);\\r\\nfelem_reduce(ftmp5, tmp);\\r\\nfelem_mul(tmp, ftmp2, ftmp);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, ftmp4, ftmp5);\\r\\nfelem_square(tmp2, ftmp3);\\r\\nfelem_diff_128_64(tmp2, ftmp5);\\r\\nfelem_assign(ftmp5, ftmp2);\\r\\nfelem_scalar(ftmp5, 2);\\r\\nfelem_diff_128_64(tmp2, ftmp5);\\r\\nfelem_reduce(x_out, tmp2);\\r\\nfelem_diff(ftmp2, x_out);\\r\\nfelem_mul(tmp2, ftmp3, ftmp2);\\r\\nwidefelem_diff(tmp2, tmp);\\r\\nfelem_reduce(y_out, tmp2);\\r\\ncopy_conditional(x_out, x2, z1_is_zero);\\r\\ncopy_conditional(x_out, x1, z2_is_zero);\\r\\ncopy_conditional(y_out, y2, z1_is_zero);\\r\\ncopy_conditional(y_out, y1, z2_is_zero);\\r\\ncopy_conditional(z_out, z2, z1_is_zero);\\r\\ncopy_conditional(z_out, z1, z2_is_zero);\\r\\nfelem_assign(x3, x_out);\\r\\nfelem_assign(y3, y_out);\\r\\nfelem_assign(z3, z_out);\\r\\n}\\r\\nstatic void select_point(const u64 idx, unsigned int size,\\r\\nconst felem pre_comp[][3], felem out[3])\\r\\n{\\r\\nunsigned i, j;\\r\\nlimb *outlimbs = &out[0][0];\\r\\nmemset(outlimbs, 0, 3 * sizeof(felem));\\r\\nfor (i = 0; i < size; i++) {\\r\\nconst limb *inlimbs = &pre_comp[i][0][0];\\r\\nu64 mask = i ^ idx;\\r\\nmask |= mask >> 4;\\r\\nmask |= mask >> 2;\\r\\nmask |= mask >> 1;\\r\\nmask &= 1;\\r\\nmask--;\\r\\nfor (j = 0; j < 4 * 3; j++)\\r\\noutlimbs[j] |= inlimbs[j] & mask;\\r\\n}\\r\\n}\\r\\nstatic char get_bit(const felem_bytearray in, unsigned i)\\r\\n{\\r\\nif (i >= 224)\\r\\nreturn 0;\\r\\nreturn (in[i >> 3] >> (i & 7)) & 1;\\r\\n}\\r\\nstatic void batch_mul(felem x_out, felem y_out, felem z_out,\\r\\nconst felem_bytearray scalars[],\\r\\nconst unsigned num_points, const u8 *g_scalar,\\r\\nconst int mixed, const felem pre_comp[][17][3],\\r\\nconst felem g_pre_comp[2][16][3])\\r\\n{\\r\\nint i, skip;\\r\\nunsigned num;\\r\\nunsigned gen_mul = (g_scalar != NULL);\\r\\nfelem nq[3], tmp[4];\\r\\nu64 bits;\\r\\nu8 sign, digit;\\r\\nmemset(nq, 0, 3 * sizeof(felem));\\r\\nskip = 1;\\r\\nfor (i = (num_points ? 220 : 27); i >= 0; --i) {\\r\\nif (!skip)\\r\\npoint_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\\r\\nif (gen_mul && (i <= 27)) {\\r\\nbits = get_bit(g_scalar, i + 196) << 3;\\r\\nbits |= get_bit(g_scalar, i + 140) << 2;\\r\\nbits |= get_bit(g_scalar, i + 84) << 1;\\r\\nbits |= get_bit(g_scalar, i + 28);\\r\\nselect_point(bits, 16, g_pre_comp[1], tmp);\\r\\nif (!skip) {\\r\\npoint_add(nq[0], nq[1], nq[2],\\r\\nnq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\\r\\n} else {\\r\\nmemcpy(nq, tmp, 3 * sizeof(felem));\\r\\nskip = 0;\\r\\n}\\r\\nbits = get_bit(g_scalar, i + 168) << 3;\\r\\nbits |= get_bit(g_scalar, i + 112) << 2;\\r\\nbits |= get_bit(g_scalar, i + 56) << 1;\\r\\nbits |= get_bit(g_scalar, i);\\r\\nselect_point(bits, 16, g_pre_comp[0], tmp);\\r\\npoint_add(nq[0], nq[1], nq[2],\\r\\nnq[0], nq[1], nq[2],\\r\\n1 , tmp[0], tmp[1], tmp[2]);\\r\\n}\\r\\nif (num_points && (i % 5 == 0)) {\\r\\nfor (num = 0; num < num_points; ++num) {\\r\\nbits = get_bit(scalars[num], i + 4) << 5;\\r\\nbits |= get_bit(scalars[num], i + 3) << 4;\\r\\nbits |= get_bit(scalars[num], i + 2) << 3;\\r\\nbits |= get_bit(scalars[num], i + 1) << 2;\\r\\nbits |= get_bit(scalars[num], i) << 1;\\r\\nbits |= get_bit(scalars[num], i - 1);\\r\\nec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\\r\\nselect_point(digit, 17, pre_comp[num], tmp);\\r\\nfelem_neg(tmp[3], tmp[1]);\\r\\ncopy_conditional(tmp[1], tmp[3], sign);\\r\\nif (!skip) {\\r\\npoint_add(nq[0], nq[1], nq[2],\\r\\nnq[0], nq[1], nq[2],\\r\\nmixed, tmp[0], tmp[1], tmp[2]);\\r\\n} else {\\r\\nmemcpy(nq, tmp, 3 * sizeof(felem));\\r\\nskip = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nfelem_assign(x_out, nq[0]);\\r\\nfelem_assign(y_out, nq[1]);\\r\\nfelem_assign(z_out, nq[2]);\\r\\n}\\r\\nstatic NISTP224_PRE_COMP *nistp224_pre_comp_new()\\r\\n{\\r\\nNISTP224_PRE_COMP *ret = NULL;\\r\\nret = (NISTP224_PRE_COMP *) OPENSSL_malloc(sizeof *ret);\\r\\nif (!ret) {\\r\\nECerr(EC_F_NISTP224_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn ret;\\r\\n}\\r\\nmemset(ret->g_pre_comp, 0, sizeof(ret->g_pre_comp));\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nstatic void *nistp224_pre_comp_dup(void *src_)\\r\\n{\\r\\nNISTP224_PRE_COMP *src = src_;\\r\\nCRYPTO_add(&src->references, 1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nreturn src_;\\r\\n}\\r\\nstatic void nistp224_pre_comp_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nNISTP224_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nstatic void nistp224_pre_comp_clear_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nNISTP224_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nOPENSSL_cleanse(pre, sizeof *pre);\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nint ec_GFp_nistp224_group_init(EC_GROUP *group)\\r\\n{\\r\\nint ret;\\r\\nret = ec_GFp_simple_group_init(group);\\r\\ngroup->a_is_minus3 = 1;\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp224_group_set_curve(EC_GROUP *group, const BIGNUM *p,\\r\\nconst BIGNUM *a, const BIGNUM *b,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *curve_p, *curve_a, *curve_b;\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (((curve_p = BN_CTX_get(ctx)) == NULL) ||\\r\\n((curve_a = BN_CTX_get(ctx)) == NULL) ||\\r\\n((curve_b = BN_CTX_get(ctx)) == NULL))\\r\\ngoto err;\\r\\nBN_bin2bn(nistp224_curve_params[0], sizeof(felem_bytearray), curve_p);\\r\\nBN_bin2bn(nistp224_curve_params[1], sizeof(felem_bytearray), curve_a);\\r\\nBN_bin2bn(nistp224_curve_params[2], sizeof(felem_bytearray), curve_b);\\r\\nif ((BN_cmp(curve_p, p)) || (BN_cmp(curve_a, a)) || (BN_cmp(curve_b, b))) {\\r\\nECerr(EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE,\\r\\nEC_R_WRONG_CURVE_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\ngroup->field_mod_func = BN_nist_mod_224;\\r\\nret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp224_point_get_affine_coordinates(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nfelem z1, z2, x_in, y_in, x_out, y_out;\\r\\nwidefelem tmp;\\r\\nif (EC_POINT_is_at_infinity(group, point)) {\\r\\nECerr(EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES,\\r\\nEC_R_POINT_AT_INFINITY);\\r\\nreturn 0;\\r\\n}\\r\\nif ((!BN_to_felem(x_in, &point->X)) || (!BN_to_felem(y_in, &point->Y)) ||\\r\\n(!BN_to_felem(z1, &point->Z)))\\r\\nreturn 0;\\r\\nfelem_inv(z2, z1);\\r\\nfelem_square(tmp, z2);\\r\\nfelem_reduce(z1, tmp);\\r\\nfelem_mul(tmp, x_in, z1);\\r\\nfelem_reduce(x_in, tmp);\\r\\nfelem_contract(x_out, x_in);\\r\\nif (x != NULL) {\\r\\nif (!felem_to_BN(x, x_out)) {\\r\\nECerr(EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES,\\r\\nERR_R_BN_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nfelem_mul(tmp, z1, z2);\\r\\nfelem_reduce(z1, tmp);\\r\\nfelem_mul(tmp, y_in, z1);\\r\\nfelem_reduce(y_in, tmp);\\r\\nfelem_contract(y_out, y_in);\\r\\nif (y != NULL) {\\r\\nif (!felem_to_BN(y, y_out)) {\\r\\nECerr(EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES,\\r\\nERR_R_BN_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void make_points_affine(size_t num, felem points[ ][3],\\r\\nfelem tmp_felems[ ])\\r\\n{\\r\\nec_GFp_nistp_points_make_affine_internal(num,\\r\\npoints,\\r\\nsizeof(felem),\\r\\ntmp_felems,\\r\\n(void (*)(void *))felem_one,\\r\\n(int (*)(const void *))\\r\\nfelem_is_zero_int,\\r\\n(void (*)(void *, const void *))\\r\\nfelem_assign,\\r\\n(void (*)(void *, const void *))\\r\\nfelem_square_reduce, (void (*)\\r\\n(void *,\\r\\nconst void\\r\\n*,\\r\\nconst void\\r\\n*))\\r\\nfelem_mul_reduce,\\r\\n(void (*)(void *, const void *))\\r\\nfelem_inv,\\r\\n(void (*)(void *, const void *))\\r\\nfelem_contract);\\r\\n}\\r\\nint ec_GFp_nistp224_points_mul(const EC_GROUP *group, EC_POINT *r,\\r\\nconst BIGNUM *scalar, size_t num,\\r\\nconst EC_POINT *points[],\\r\\nconst BIGNUM *scalars[], BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nint j;\\r\\nunsigned i;\\r\\nint mixed = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y, *z, *tmp_scalar;\\r\\nfelem_bytearray g_secret;\\r\\nfelem_bytearray *secrets = NULL;\\r\\nfelem(*pre_comp)[17][3] = NULL;\\r\\nfelem *tmp_felems = NULL;\\r\\nfelem_bytearray tmp;\\r\\nunsigned num_bytes;\\r\\nint have_pre_comp = 0;\\r\\nsize_t num_points = num;\\r\\nfelem x_in, y_in, z_in, x_out, y_out, z_out;\\r\\nNISTP224_PRE_COMP *pre = NULL;\\r\\nconst felem(*g_pre_comp)[16][3] = NULL;\\r\\nEC_POINT *generator = NULL;\\r\\nconst EC_POINT *p = NULL;\\r\\nconst BIGNUM *p_scalar = NULL;\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (((x = BN_CTX_get(ctx)) == NULL) ||\\r\\n((y = BN_CTX_get(ctx)) == NULL) ||\\r\\n((z = BN_CTX_get(ctx)) == NULL) ||\\r\\n((tmp_scalar = BN_CTX_get(ctx)) == NULL))\\r\\ngoto err;\\r\\nif (scalar != NULL) {\\r\\npre = EC_EX_DATA_get_data(group->extra_data,\\r\\nnistp224_pre_comp_dup,\\r\\nnistp224_pre_comp_free,\\r\\nnistp224_pre_comp_clear_free);\\r\\nif (pre)\\r\\ng_pre_comp = (const felem(*)[16][3])pre->g_pre_comp;\\r\\nelse\\r\\ng_pre_comp = &gmul[0];\\r\\ngenerator = EC_POINT_new(group);\\r\\nif (generator == NULL)\\r\\ngoto err;\\r\\nif (!felem_to_BN(x, g_pre_comp[0][1][0]) ||\\r\\n!felem_to_BN(y, g_pre_comp[0][1][1]) ||\\r\\n!felem_to_BN(z, g_pre_comp[0][1][2])) {\\r\\nECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_set_Jprojective_coordinates_GFp(group,\\r\\ngenerator, x, y, z,\\r\\nctx))\\r\\ngoto err;\\r\\nif (0 == EC_POINT_cmp(group, generator, group->generator, ctx))\\r\\nhave_pre_comp = 1;\\r\\nelse\\r\\nnum_points = num_points + 1;\\r\\n}\\r\\nif (num_points > 0) {\\r\\nif (num_points >= 3) {\\r\\nmixed = 1;\\r\\n}\\r\\nsecrets = OPENSSL_malloc(num_points * sizeof(felem_bytearray));\\r\\npre_comp = OPENSSL_malloc(num_points * 17 * 3 * sizeof(felem));\\r\\nif (mixed)\\r\\ntmp_felems =\\r\\nOPENSSL_malloc((num_points * 17 + 1) * sizeof(felem));\\r\\nif ((secrets == NULL) || (pre_comp == NULL)\\r\\n|| (mixed && (tmp_felems == NULL))) {\\r\\nECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemset(secrets, 0, num_points * sizeof(felem_bytearray));\\r\\nmemset(pre_comp, 0, num_points * 17 * 3 * sizeof(felem));\\r\\nfor (i = 0; i < num_points; ++i) {\\r\\nif (i == num)\\r\\n{\\r\\np = EC_GROUP_get0_generator(group);\\r\\np_scalar = scalar;\\r\\n} else\\r\\n{\\r\\np = points[i];\\r\\np_scalar = scalars[i];\\r\\n}\\r\\nif ((p_scalar != NULL) && (p != NULL)) {\\r\\nif ((BN_num_bits(p_scalar) > 224)\\r\\n|| (BN_is_negative(p_scalar))) {\\r\\nif (!BN_nnmod(tmp_scalar, p_scalar, &group->order, ctx)) {\\r\\nECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nnum_bytes = BN_bn2bin(tmp_scalar, tmp);\\r\\n} else\\r\\nnum_bytes = BN_bn2bin(p_scalar, tmp);\\r\\nflip_endian(secrets[i], tmp, num_bytes);\\r\\nif ((!BN_to_felem(x_out, &p->X)) ||\\r\\n(!BN_to_felem(y_out, &p->Y)) ||\\r\\n(!BN_to_felem(z_out, &p->Z)))\\r\\ngoto err;\\r\\nfelem_assign(pre_comp[i][1][0], x_out);\\r\\nfelem_assign(pre_comp[i][1][1], y_out);\\r\\nfelem_assign(pre_comp[i][1][2], z_out);\\r\\nfor (j = 2; j <= 16; ++j) {\\r\\nif (j & 1) {\\r\\npoint_add(pre_comp[i][j][0], pre_comp[i][j][1],\\r\\npre_comp[i][j][2], pre_comp[i][1][0],\\r\\npre_comp[i][1][1], pre_comp[i][1][2], 0,\\r\\npre_comp[i][j - 1][0],\\r\\npre_comp[i][j - 1][1],\\r\\npre_comp[i][j - 1][2]);\\r\\n} else {\\r\\npoint_double(pre_comp[i][j][0], pre_comp[i][j][1],\\r\\npre_comp[i][j][2], pre_comp[i][j / 2][0],\\r\\npre_comp[i][j / 2][1],\\r\\npre_comp[i][j / 2][2]);\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nif (mixed)\\r\\nmake_points_affine(num_points * 17, pre_comp[0], tmp_felems);\\r\\n}\\r\\nif ((scalar != NULL) && (have_pre_comp)) {\\r\\nmemset(g_secret, 0, sizeof g_secret);\\r\\nif ((BN_num_bits(scalar) > 224) || (BN_is_negative(scalar))) {\\r\\nif (!BN_nnmod(tmp_scalar, scalar, &group->order, ctx)) {\\r\\nECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nnum_bytes = BN_bn2bin(tmp_scalar, tmp);\\r\\n} else\\r\\nnum_bytes = BN_bn2bin(scalar, tmp);\\r\\nflip_endian(g_secret, tmp, num_bytes);\\r\\nbatch_mul(x_out, y_out, z_out,\\r\\n(const felem_bytearray(*))secrets, num_points,\\r\\ng_secret,\\r\\nmixed, (const felem(*)[17][3])pre_comp, g_pre_comp);\\r\\n} else\\r\\nbatch_mul(x_out, y_out, z_out,\\r\\n(const felem_bytearray(*))secrets, num_points,\\r\\nNULL, mixed, (const felem(*)[17][3])pre_comp, NULL);\\r\\nfelem_contract(x_in, x_out);\\r\\nfelem_contract(y_in, y_out);\\r\\nfelem_contract(z_in, z_out);\\r\\nif ((!felem_to_BN(x, x_in)) || (!felem_to_BN(y, y_in)) ||\\r\\n(!felem_to_BN(z, z_in))) {\\r\\nECerr(EC_F_EC_GFP_NISTP224_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret = EC_POINT_set_Jprojective_coordinates_GFp(group, r, x, y, z, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (generator != NULL)\\r\\nEC_POINT_free(generator);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (secrets != NULL)\\r\\nOPENSSL_free(secrets);\\r\\nif (pre_comp != NULL)\\r\\nOPENSSL_free(pre_comp);\\r\\nif (tmp_felems != NULL)\\r\\nOPENSSL_free(tmp_felems);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp224_precompute_mult(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nNISTP224_PRE_COMP *pre = NULL;\\r\\nint i, j;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y;\\r\\nEC_POINT *generator = NULL;\\r\\nfelem tmp_felems[32];\\r\\nEC_EX_DATA_free_data(&group->extra_data, nistp224_pre_comp_dup,\\r\\nnistp224_pre_comp_free,\\r\\nnistp224_pre_comp_clear_free);\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (((x = BN_CTX_get(ctx)) == NULL) || ((y = BN_CTX_get(ctx)) == NULL))\\r\\ngoto err;\\r\\nif (group->generator == NULL)\\r\\ngoto err;\\r\\ngenerator = EC_POINT_new(group);\\r\\nif (generator == NULL)\\r\\ngoto err;\\r\\nBN_bin2bn(nistp224_curve_params[3], sizeof(felem_bytearray), x);\\r\\nBN_bin2bn(nistp224_curve_params[4], sizeof(felem_bytearray), y);\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, generator, x, y, ctx))\\r\\ngoto err;\\r\\nif ((pre = nistp224_pre_comp_new()) == NULL)\\r\\ngoto err;\\r\\nif (0 == EC_POINT_cmp(group, generator, group->generator, ctx)) {\\r\\nmemcpy(pre->g_pre_comp, gmul, sizeof(pre->g_pre_comp));\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif ((!BN_to_felem(pre->g_pre_comp[0][1][0], &group->generator->X)) ||\\r\\n(!BN_to_felem(pre->g_pre_comp[0][1][1], &group->generator->Y)) ||\\r\\n(!BN_to_felem(pre->g_pre_comp[0][1][2], &group->generator->Z)))\\r\\ngoto err;\\r\\nfor (i = 1; i <= 8; i <<= 1) {\\r\\npoint_double(pre->g_pre_comp[1][i][0], pre->g_pre_comp[1][i][1],\\r\\npre->g_pre_comp[1][i][2], pre->g_pre_comp[0][i][0],\\r\\npre->g_pre_comp[0][i][1], pre->g_pre_comp[0][i][2]);\\r\\nfor (j = 0; j < 27; ++j) {\\r\\npoint_double(pre->g_pre_comp[1][i][0], pre->g_pre_comp[1][i][1],\\r\\npre->g_pre_comp[1][i][2], pre->g_pre_comp[1][i][0],\\r\\npre->g_pre_comp[1][i][1], pre->g_pre_comp[1][i][2]);\\r\\n}\\r\\nif (i == 8)\\r\\nbreak;\\r\\npoint_double(pre->g_pre_comp[0][2 * i][0],\\r\\npre->g_pre_comp[0][2 * i][1],\\r\\npre->g_pre_comp[0][2 * i][2], pre->g_pre_comp[1][i][0],\\r\\npre->g_pre_comp[1][i][1], pre->g_pre_comp[1][i][2]);\\r\\nfor (j = 0; j < 27; ++j) {\\r\\npoint_double(pre->g_pre_comp[0][2 * i][0],\\r\\npre->g_pre_comp[0][2 * i][1],\\r\\npre->g_pre_comp[0][2 * i][2],\\r\\npre->g_pre_comp[0][2 * i][0],\\r\\npre->g_pre_comp[0][2 * i][1],\\r\\npre->g_pre_comp[0][2 * i][2]);\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < 2; i++) {\\r\\nmemset(pre->g_pre_comp[i][0], 0, sizeof(pre->g_pre_comp[i][0]));\\r\\npoint_add(pre->g_pre_comp[i][6][0], pre->g_pre_comp[i][6][1],\\r\\npre->g_pre_comp[i][6][2], pre->g_pre_comp[i][4][0],\\r\\npre->g_pre_comp[i][4][1], pre->g_pre_comp[i][4][2],\\r\\n0, pre->g_pre_comp[i][2][0], pre->g_pre_comp[i][2][1],\\r\\npre->g_pre_comp[i][2][2]);\\r\\npoint_add(pre->g_pre_comp[i][10][0], pre->g_pre_comp[i][10][1],\\r\\npre->g_pre_comp[i][10][2], pre->g_pre_comp[i][8][0],\\r\\npre->g_pre_comp[i][8][1], pre->g_pre_comp[i][8][2],\\r\\n0, pre->g_pre_comp[i][2][0], pre->g_pre_comp[i][2][1],\\r\\npre->g_pre_comp[i][2][2]);\\r\\npoint_add(pre->g_pre_comp[i][12][0], pre->g_pre_comp[i][12][1],\\r\\npre->g_pre_comp[i][12][2], pre->g_pre_comp[i][8][0],\\r\\npre->g_pre_comp[i][8][1], pre->g_pre_comp[i][8][2],\\r\\n0, pre->g_pre_comp[i][4][0], pre->g_pre_comp[i][4][1],\\r\\npre->g_pre_comp[i][4][2]);\\r\\npoint_add(pre->g_pre_comp[i][14][0], pre->g_pre_comp[i][14][1],\\r\\npre->g_pre_comp[i][14][2], pre->g_pre_comp[i][12][0],\\r\\npre->g_pre_comp[i][12][1], pre->g_pre_comp[i][12][2],\\r\\n0, pre->g_pre_comp[i][2][0], pre->g_pre_comp[i][2][1],\\r\\npre->g_pre_comp[i][2][2]);\\r\\nfor (j = 1; j < 8; ++j) {\\r\\npoint_add(pre->g_pre_comp[i][2 * j + 1][0],\\r\\npre->g_pre_comp[i][2 * j + 1][1],\\r\\npre->g_pre_comp[i][2 * j + 1][2],\\r\\npre->g_pre_comp[i][2 * j][0],\\r\\npre->g_pre_comp[i][2 * j][1],\\r\\npre->g_pre_comp[i][2 * j][2], 0,\\r\\npre->g_pre_comp[i][1][0], pre->g_pre_comp[i][1][1],\\r\\npre->g_pre_comp[i][1][2]);\\r\\n}\\r\\n}\\r\\nmake_points_affine(31, &(pre->g_pre_comp[0][1]), tmp_felems);\\r\\nif (!EC_EX_DATA_set_data(&group->extra_data, pre, nistp224_pre_comp_dup,\\r\\nnistp224_pre_comp_free,\\r\\nnistp224_pre_comp_clear_free))\\r\\ngoto err;\\r\\nret = 1;\\r\\npre = NULL;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (generator != NULL)\\r\\nEC_POINT_free(generator);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (pre)\\r\\nnistp224_pre_comp_free(pre);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp224_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nif (EC_EX_DATA_get_data(group->extra_data, nistp224_pre_comp_dup,\\r\\nnistp224_pre_comp_free,\\r\\nnistp224_pre_comp_clear_free)\\r\\n!= NULL)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pkcs7err_c", "target": 0, "func": "void ERR_load_PKCS7_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(PKCS7_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, PKCS7_str_functs);\\r\\nERR_load_strings(0, PKCS7_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_rsp_utils_c", "target": 0, "func": "int TS_RESP_set_status_info(TS_RESP *a, TS_STATUS_INFO *status_info)\\r\\n{\\r\\nTS_STATUS_INFO *new_status_info;\\r\\nif (a->status_info == status_info)\\r\\nreturn 1;\\r\\nnew_status_info = TS_STATUS_INFO_dup(status_info);\\r\\nif (new_status_info == NULL) {\\r\\nTSerr(TS_F_TS_RESP_SET_STATUS_INFO, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nTS_STATUS_INFO_free(a->status_info);\\r\\na->status_info = new_status_info;\\r\\nreturn 1;\\r\\n}\\r\\nTS_STATUS_INFO *TS_RESP_get_status_info(TS_RESP *a)\\r\\n{\\r\\nreturn a->status_info;\\r\\n}\\r\\nvoid TS_RESP_set_tst_info(TS_RESP *a, PKCS7 *p7, TS_TST_INFO *tst_info)\\r\\n{\\r\\nPKCS7_free(a->token);\\r\\na->token = p7;\\r\\nTS_TST_INFO_free(a->tst_info);\\r\\na->tst_info = tst_info;\\r\\n}\\r\\nPKCS7 *TS_RESP_get_token(TS_RESP *a)\\r\\n{\\r\\nreturn a->token;\\r\\n}\\r\\nTS_TST_INFO *TS_RESP_get_tst_info(TS_RESP *a)\\r\\n{\\r\\nreturn a->tst_info;\\r\\n}\\r\\nint TS_TST_INFO_set_version(TS_TST_INFO *a, long version)\\r\\n{\\r\\nreturn ASN1_INTEGER_set(a->version, version);\\r\\n}\\r\\nlong TS_TST_INFO_get_version(const TS_TST_INFO *a)\\r\\n{\\r\\nreturn ASN1_INTEGER_get(a->version);\\r\\n}\\r\\nint TS_TST_INFO_set_policy_id(TS_TST_INFO *a, ASN1_OBJECT *policy)\\r\\n{\\r\\nASN1_OBJECT *new_policy;\\r\\nif (a->policy_id == policy)\\r\\nreturn 1;\\r\\nnew_policy = OBJ_dup(policy);\\r\\nif (new_policy == NULL) {\\r\\nTSerr(TS_F_TS_TST_INFO_SET_POLICY_ID, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_OBJECT_free(a->policy_id);\\r\\na->policy_id = new_policy;\\r\\nreturn 1;\\r\\n}\\r\\nASN1_OBJECT *TS_TST_INFO_get_policy_id(TS_TST_INFO *a)\\r\\n{\\r\\nreturn a->policy_id;\\r\\n}\\r\\nint TS_TST_INFO_set_msg_imprint(TS_TST_INFO *a, TS_MSG_IMPRINT *msg_imprint)\\r\\n{\\r\\nTS_MSG_IMPRINT *new_msg_imprint;\\r\\nif (a->msg_imprint == msg_imprint)\\r\\nreturn 1;\\r\\nnew_msg_imprint = TS_MSG_IMPRINT_dup(msg_imprint);\\r\\nif (new_msg_imprint == NULL) {\\r\\nTSerr(TS_F_TS_TST_INFO_SET_MSG_IMPRINT, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nTS_MSG_IMPRINT_free(a->msg_imprint);\\r\\na->msg_imprint = new_msg_imprint;\\r\\nreturn 1;\\r\\n}\\r\\nTS_MSG_IMPRINT *TS_TST_INFO_get_msg_imprint(TS_TST_INFO *a)\\r\\n{\\r\\nreturn a->msg_imprint;\\r\\n}\\r\\nint TS_TST_INFO_set_serial(TS_TST_INFO *a, const ASN1_INTEGER *serial)\\r\\n{\\r\\nASN1_INTEGER *new_serial;\\r\\nif (a->serial == serial)\\r\\nreturn 1;\\r\\nnew_serial = ASN1_INTEGER_dup(serial);\\r\\nif (new_serial == NULL) {\\r\\nTSerr(TS_F_TS_TST_INFO_SET_SERIAL, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_INTEGER_free(a->serial);\\r\\na->serial = new_serial;\\r\\nreturn 1;\\r\\n}\\r\\nconst ASN1_INTEGER *TS_TST_INFO_get_serial(const TS_TST_INFO *a)\\r\\n{\\r\\nreturn a->serial;\\r\\n}\\r\\nint TS_TST_INFO_set_time(TS_TST_INFO *a, const ASN1_GENERALIZEDTIME *gtime)\\r\\n{\\r\\nASN1_GENERALIZEDTIME *new_time;\\r\\nif (a->time == gtime)\\r\\nreturn 1;\\r\\nnew_time = M_ASN1_GENERALIZEDTIME_dup(gtime);\\r\\nif (new_time == NULL) {\\r\\nTSerr(TS_F_TS_TST_INFO_SET_TIME, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_GENERALIZEDTIME_free(a->time);\\r\\na->time = new_time;\\r\\nreturn 1;\\r\\n}\\r\\nconst ASN1_GENERALIZEDTIME *TS_TST_INFO_get_time(const TS_TST_INFO *a)\\r\\n{\\r\\nreturn a->time;\\r\\n}\\r\\nint TS_TST_INFO_set_accuracy(TS_TST_INFO *a, TS_ACCURACY *accuracy)\\r\\n{\\r\\nTS_ACCURACY *new_accuracy;\\r\\nif (a->accuracy == accuracy)\\r\\nreturn 1;\\r\\nnew_accuracy = TS_ACCURACY_dup(accuracy);\\r\\nif (new_accuracy == NULL) {\\r\\nTSerr(TS_F_TS_TST_INFO_SET_ACCURACY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nTS_ACCURACY_free(a->accuracy);\\r\\na->accuracy = new_accuracy;\\r\\nreturn 1;\\r\\n}\\r\\nTS_ACCURACY *TS_TST_INFO_get_accuracy(TS_TST_INFO *a)\\r\\n{\\r\\nreturn a->accuracy;\\r\\n}\\r\\nint TS_ACCURACY_set_seconds(TS_ACCURACY *a, const ASN1_INTEGER *seconds)\\r\\n{\\r\\nASN1_INTEGER *new_seconds;\\r\\nif (a->seconds == seconds)\\r\\nreturn 1;\\r\\nnew_seconds = ASN1_INTEGER_dup(seconds);\\r\\nif (new_seconds == NULL) {\\r\\nTSerr(TS_F_TS_ACCURACY_SET_SECONDS, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_INTEGER_free(a->seconds);\\r\\na->seconds = new_seconds;\\r\\nreturn 1;\\r\\n}\\r\\nconst ASN1_INTEGER *TS_ACCURACY_get_seconds(const TS_ACCURACY *a)\\r\\n{\\r\\nreturn a->seconds;\\r\\n}\\r\\nint TS_ACCURACY_set_millis(TS_ACCURACY *a, const ASN1_INTEGER *millis)\\r\\n{\\r\\nASN1_INTEGER *new_millis = NULL;\\r\\nif (a->millis == millis)\\r\\nreturn 1;\\r\\nif (millis != NULL) {\\r\\nnew_millis = ASN1_INTEGER_dup(millis);\\r\\nif (new_millis == NULL) {\\r\\nTSerr(TS_F_TS_ACCURACY_SET_MILLIS, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nASN1_INTEGER_free(a->millis);\\r\\na->millis = new_millis;\\r\\nreturn 1;\\r\\n}\\r\\nconst ASN1_INTEGER *TS_ACCURACY_get_millis(const TS_ACCURACY *a)\\r\\n{\\r\\nreturn a->millis;\\r\\n}\\r\\nint TS_ACCURACY_set_micros(TS_ACCURACY *a, const ASN1_INTEGER *micros)\\r\\n{\\r\\nASN1_INTEGER *new_micros = NULL;\\r\\nif (a->micros == micros)\\r\\nreturn 1;\\r\\nif (micros != NULL) {\\r\\nnew_micros = ASN1_INTEGER_dup(micros);\\r\\nif (new_micros == NULL) {\\r\\nTSerr(TS_F_TS_ACCURACY_SET_MICROS, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nASN1_INTEGER_free(a->micros);\\r\\na->micros = new_micros;\\r\\nreturn 1;\\r\\n}\\r\\nconst ASN1_INTEGER *TS_ACCURACY_get_micros(const TS_ACCURACY *a)\\r\\n{\\r\\nreturn a->micros;\\r\\n}\\r\\nint TS_TST_INFO_set_ordering(TS_TST_INFO *a, int ordering)\\r\\n{\\r\\na->ordering = ordering ? 0xFF : 0x00;\\r\\nreturn 1;\\r\\n}\\r\\nint TS_TST_INFO_get_ordering(const TS_TST_INFO *a)\\r\\n{\\r\\nreturn a->ordering ? 1 : 0;\\r\\n}\\r\\nint TS_TST_INFO_set_nonce(TS_TST_INFO *a, const ASN1_INTEGER *nonce)\\r\\n{\\r\\nASN1_INTEGER *new_nonce;\\r\\nif (a->nonce == nonce)\\r\\nreturn 1;\\r\\nnew_nonce = ASN1_INTEGER_dup(nonce);\\r\\nif (new_nonce == NULL) {\\r\\nTSerr(TS_F_TS_TST_INFO_SET_NONCE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_INTEGER_free(a->nonce);\\r\\na->nonce = new_nonce;\\r\\nreturn 1;\\r\\n}\\r\\nconst ASN1_INTEGER *TS_TST_INFO_get_nonce(const TS_TST_INFO *a)\\r\\n{\\r\\nreturn a->nonce;\\r\\n}\\r\\nint TS_TST_INFO_set_tsa(TS_TST_INFO *a, GENERAL_NAME *tsa)\\r\\n{\\r\\nGENERAL_NAME *new_tsa;\\r\\nif (a->tsa == tsa)\\r\\nreturn 1;\\r\\nnew_tsa = GENERAL_NAME_dup(tsa);\\r\\nif (new_tsa == NULL) {\\r\\nTSerr(TS_F_TS_TST_INFO_SET_TSA, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nGENERAL_NAME_free(a->tsa);\\r\\na->tsa = new_tsa;\\r\\nreturn 1;\\r\\n}\\r\\nGENERAL_NAME *TS_TST_INFO_get_tsa(TS_TST_INFO *a)\\r\\n{\\r\\nreturn a->tsa;\\r\\n}\\r\\nvoid TS_TST_INFO_ext_free(TS_TST_INFO *a)\\r\\n{\\r\\nif (!a)\\r\\nreturn;\\r\\nsk_X509_EXTENSION_pop_free(a->extensions, X509_EXTENSION_free);\\r\\na->extensions = NULL;\\r\\n}\\r\\nint TS_TST_INFO_get_ext_count(TS_TST_INFO *a)\\r\\n{\\r\\nreturn X509v3_get_ext_count(a->extensions);\\r\\n}\\r\\nint TS_TST_INFO_get_ext_by_NID(TS_TST_INFO *a, int nid, int lastpos)\\r\\n{\\r\\nreturn X509v3_get_ext_by_NID(a->extensions, nid, lastpos);\\r\\n}\\r\\nint TS_TST_INFO_get_ext_by_OBJ(TS_TST_INFO *a, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn X509v3_get_ext_by_OBJ(a->extensions, obj, lastpos);\\r\\n}\\r\\nint TS_TST_INFO_get_ext_by_critical(TS_TST_INFO *a, int crit, int lastpos)\\r\\n{\\r\\nreturn X509v3_get_ext_by_critical(a->extensions, crit, lastpos);\\r\\n}\\r\\nX509_EXTENSION *TS_TST_INFO_get_ext(TS_TST_INFO *a, int loc)\\r\\n{\\r\\nreturn X509v3_get_ext(a->extensions, loc);\\r\\n}\\r\\nX509_EXTENSION *TS_TST_INFO_delete_ext(TS_TST_INFO *a, int loc)\\r\\n{\\r\\nreturn X509v3_delete_ext(a->extensions, loc);\\r\\n}\\r\\nint TS_TST_INFO_add_ext(TS_TST_INFO *a, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn X509v3_add_ext(&a->extensions, ex, loc) != NULL;\\r\\n}\\r\\nvoid *TS_TST_INFO_get_ext_d2i(TS_TST_INFO *a, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(a->extensions, nid, crit, idx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_mul_c", "target": 0, "func": "BN_ULONG bn_sub_part_words(BN_ULONG *r,\\r\\nconst BN_ULONG *a, const BN_ULONG *b,\\r\\nint cl, int dl)\\r\\n{\\r\\nBN_ULONG c, t;\\r\\nassert(cl >= 0);\\r\\nc = bn_sub_words(r, a, b, cl);\\r\\nif (dl == 0)\\r\\nreturn c;\\r\\nr += cl;\\r\\na += cl;\\r\\nb += cl;\\r\\nif (dl < 0) {\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_sub_part_words %d + %d (dl < 0, c = %d)\\n\", cl,\\r\\ndl, c);\\r\\n# endif\\r\\nfor (;;) {\\r\\nt = b[0];\\r\\nr[0] = (0 - t - c) & BN_MASK2;\\r\\nif (t != 0)\\r\\nc = 1;\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nt = b[1];\\r\\nr[1] = (0 - t - c) & BN_MASK2;\\r\\nif (t != 0)\\r\\nc = 1;\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nt = b[2];\\r\\nr[2] = (0 - t - c) & BN_MASK2;\\r\\nif (t != 0)\\r\\nc = 1;\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nt = b[3];\\r\\nr[3] = (0 - t - c) & BN_MASK2;\\r\\nif (t != 0)\\r\\nc = 1;\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nb += 4;\\r\\nr += 4;\\r\\n}\\r\\n} else {\\r\\nint save_dl = dl;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_sub_part_words %d + %d (dl > 0, c = %d)\\n\", cl,\\r\\ndl, c);\\r\\n# endif\\r\\nwhile (c) {\\r\\nt = a[0];\\r\\nr[0] = (t - c) & BN_MASK2;\\r\\nif (t != 0)\\r\\nc = 0;\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nt = a[1];\\r\\nr[1] = (t - c) & BN_MASK2;\\r\\nif (t != 0)\\r\\nc = 0;\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nt = a[2];\\r\\nr[2] = (t - c) & BN_MASK2;\\r\\nif (t != 0)\\r\\nc = 0;\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nt = a[3];\\r\\nr[3] = (t - c) & BN_MASK2;\\r\\nif (t != 0)\\r\\nc = 0;\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nsave_dl = dl;\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\nif (dl > 0) {\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_sub_part_words %d + %d (dl > 0, c == 0)\\n\",\\r\\ncl, dl);\\r\\n# endif\\r\\nif (save_dl > dl) {\\r\\nswitch (save_dl - dl) {\\r\\ncase 1:\\r\\nr[1] = a[1];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\ncase 2:\\r\\nr[2] = a[2];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\ncase 3:\\r\\nr[3] = a[3];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\n}\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\nif (dl > 0) {\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_sub_part_words %d + %d (dl > 0, copy)\\n\",\\r\\ncl, dl);\\r\\n# endif\\r\\nfor (;;) {\\r\\nr[0] = a[0];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nr[1] = a[1];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nr[2] = a[2];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nr[3] = a[3];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn c;\\r\\n}\\r\\nBN_ULONG bn_add_part_words(BN_ULONG *r,\\r\\nconst BN_ULONG *a, const BN_ULONG *b,\\r\\nint cl, int dl)\\r\\n{\\r\\nBN_ULONG c, l, t;\\r\\nassert(cl >= 0);\\r\\nc = bn_add_words(r, a, b, cl);\\r\\nif (dl == 0)\\r\\nreturn c;\\r\\nr += cl;\\r\\na += cl;\\r\\nb += cl;\\r\\nif (dl < 0) {\\r\\nint save_dl = dl;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl < 0, c = %d)\\n\", cl,\\r\\ndl, c);\\r\\n#endif\\r\\nwhile (c) {\\r\\nl = (c + b[0]) & BN_MASK2;\\r\\nc = (l < c);\\r\\nr[0] = l;\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nl = (c + b[1]) & BN_MASK2;\\r\\nc = (l < c);\\r\\nr[1] = l;\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nl = (c + b[2]) & BN_MASK2;\\r\\nc = (l < c);\\r\\nr[2] = l;\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nl = (c + b[3]) & BN_MASK2;\\r\\nc = (l < c);\\r\\nr[3] = l;\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nsave_dl = dl;\\r\\nb += 4;\\r\\nr += 4;\\r\\n}\\r\\nif (dl < 0) {\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl < 0, c == 0)\\n\",\\r\\ncl, dl);\\r\\n#endif\\r\\nif (save_dl < dl) {\\r\\nswitch (dl - save_dl) {\\r\\ncase 1:\\r\\nr[1] = b[1];\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\ncase 2:\\r\\nr[2] = b[2];\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\ncase 3:\\r\\nr[3] = b[3];\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\n}\\r\\nb += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\nif (dl < 0) {\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl < 0, copy)\\n\",\\r\\ncl, dl);\\r\\n#endif\\r\\nfor (;;) {\\r\\nr[0] = b[0];\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nr[1] = b[1];\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nr[2] = b[2];\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nr[3] = b[3];\\r\\nif (++dl >= 0)\\r\\nbreak;\\r\\nb += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\n} else {\\r\\nint save_dl = dl;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl > 0)\\n\", cl, dl);\\r\\n#endif\\r\\nwhile (c) {\\r\\nt = (a[0] + c) & BN_MASK2;\\r\\nc = (t < c);\\r\\nr[0] = t;\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nt = (a[1] + c) & BN_MASK2;\\r\\nc = (t < c);\\r\\nr[1] = t;\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nt = (a[2] + c) & BN_MASK2;\\r\\nc = (t < c);\\r\\nr[2] = t;\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nt = (a[3] + c) & BN_MASK2;\\r\\nc = (t < c);\\r\\nr[3] = t;\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nsave_dl = dl;\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl > 0, c == 0)\\n\", cl,\\r\\ndl);\\r\\n#endif\\r\\nif (dl > 0) {\\r\\nif (save_dl > dl) {\\r\\nswitch (save_dl - dl) {\\r\\ncase 1:\\r\\nr[1] = a[1];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\ncase 2:\\r\\nr[2] = a[2];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\ncase 3:\\r\\nr[3] = a[3];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\n}\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\nif (dl > 0) {\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_add_part_words %d + %d (dl > 0, copy)\\n\",\\r\\ncl, dl);\\r\\n#endif\\r\\nfor (;;) {\\r\\nr[0] = a[0];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nr[1] = a[1];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nr[2] = a[2];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\nr[3] = a[3];\\r\\nif (--dl <= 0)\\r\\nbreak;\\r\\na += 4;\\r\\nr += 4;\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn c;\\r\\n}\\r\\nvoid bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\\r\\nint dna, int dnb, BN_ULONG *t)\\r\\n{\\r\\nint n = n2 / 2, c1, c2;\\r\\nint tna = n + dna, tnb = n + dnb;\\r\\nunsigned int neg, zero;\\r\\nBN_ULONG ln, lo, *p;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_mul_recursive %d%+d * %d%+d\\n\", n2, dna, n2, dnb);\\r\\n# endif\\r\\n# ifdef BN_MUL_COMBA\\r\\n# if 0\\r\\nif (n2 == 4) {\\r\\nbn_mul_comba4(r, a, b);\\r\\nreturn;\\r\\n}\\r\\n# endif\\r\\nif (n2 == 8 && dna == 0 && dnb == 0) {\\r\\nbn_mul_comba8(r, a, b);\\r\\nreturn;\\r\\n}\\r\\n# endif\\r\\nif (n2 < BN_MUL_RECURSIVE_SIZE_NORMAL) {\\r\\nbn_mul_normal(r, a, n2 + dna, b, n2 + dnb);\\r\\nif ((dna + dnb) < 0)\\r\\nmemset(&r[2 * n2 + dna + dnb], 0,\\r\\nsizeof(BN_ULONG) * -(dna + dnb));\\r\\nreturn;\\r\\n}\\r\\nc1 = bn_cmp_part_words(a, &(a[n]), tna, n - tna);\\r\\nc2 = bn_cmp_part_words(&(b[n]), b, tnb, tnb - n);\\r\\nzero = neg = 0;\\r\\nswitch (c1 * 3 + c2) {\\r\\ncase -4:\\r\\nbn_sub_part_words(t, &(a[n]), a, tna, tna - n);\\r\\nbn_sub_part_words(&(t[n]), b, &(b[n]), tnb, n - tnb);\\r\\nbreak;\\r\\ncase -3:\\r\\nzero = 1;\\r\\nbreak;\\r\\ncase -2:\\r\\nbn_sub_part_words(t, &(a[n]), a, tna, tna - n);\\r\\nbn_sub_part_words(&(t[n]), &(b[n]), b, tnb, tnb - n);\\r\\nneg = 1;\\r\\nbreak;\\r\\ncase -1:\\r\\ncase 0:\\r\\ncase 1:\\r\\nzero = 1;\\r\\nbreak;\\r\\ncase 2:\\r\\nbn_sub_part_words(t, a, &(a[n]), tna, n - tna);\\r\\nbn_sub_part_words(&(t[n]), b, &(b[n]), tnb, n - tnb);\\r\\nneg = 1;\\r\\nbreak;\\r\\ncase 3:\\r\\nzero = 1;\\r\\nbreak;\\r\\ncase 4:\\r\\nbn_sub_part_words(t, a, &(a[n]), tna, n - tna);\\r\\nbn_sub_part_words(&(t[n]), &(b[n]), b, tnb, tnb - n);\\r\\nbreak;\\r\\n}\\r\\n# ifdef BN_MUL_COMBA\\r\\nif (n == 4 && dna == 0 && dnb == 0) {\\r\\nif (!zero)\\r\\nbn_mul_comba4(&(t[n2]), t, &(t[n]));\\r\\nelse\\r\\nmemset(&(t[n2]), 0, 8 * sizeof(BN_ULONG));\\r\\nbn_mul_comba4(r, a, b);\\r\\nbn_mul_comba4(&(r[n2]), &(a[n]), &(b[n]));\\r\\n} else if (n == 8 && dna == 0 && dnb == 0) {\\r\\nif (!zero)\\r\\nbn_mul_comba8(&(t[n2]), t, &(t[n]));\\r\\nelse\\r\\nmemset(&(t[n2]), 0, 16 * sizeof(BN_ULONG));\\r\\nbn_mul_comba8(r, a, b);\\r\\nbn_mul_comba8(&(r[n2]), &(a[n]), &(b[n]));\\r\\n} else\\r\\n# endif\\r\\n{\\r\\np = &(t[n2 * 2]);\\r\\nif (!zero)\\r\\nbn_mul_recursive(&(t[n2]), t, &(t[n]), n, 0, 0, p);\\r\\nelse\\r\\nmemset(&(t[n2]), 0, n2 * sizeof(BN_ULONG));\\r\\nbn_mul_recursive(r, a, b, n, 0, 0, p);\\r\\nbn_mul_recursive(&(r[n2]), &(a[n]), &(b[n]), n, dna, dnb, p);\\r\\n}\\r\\nc1 = (int)(bn_add_words(t, r, &(r[n2]), n2));\\r\\nif (neg) {\\r\\nc1 -= (int)(bn_sub_words(&(t[n2]), t, &(t[n2]), n2));\\r\\n} else {\\r\\nc1 += (int)(bn_add_words(&(t[n2]), &(t[n2]), t, n2));\\r\\n}\\r\\nc1 += (int)(bn_add_words(&(r[n]), &(r[n]), &(t[n2]), n2));\\r\\nif (c1) {\\r\\np = &(r[n + n2]);\\r\\nlo = *p;\\r\\nln = (lo + c1) & BN_MASK2;\\r\\n*p = ln;\\r\\nif (ln < (BN_ULONG)c1) {\\r\\ndo {\\r\\np++;\\r\\nlo = *p;\\r\\nln = (lo + 1) & BN_MASK2;\\r\\n*p = ln;\\r\\n} while (ln == 0);\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n,\\r\\nint tna, int tnb, BN_ULONG *t)\\r\\n{\\r\\nint i, j, n2 = n * 2;\\r\\nint c1, c2, neg;\\r\\nBN_ULONG ln, lo, *p;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_mul_part_recursive (%d%+d) * (%d%+d)\\n\",\\r\\nn, tna, n, tnb);\\r\\n# endif\\r\\nif (n < 8) {\\r\\nbn_mul_normal(r, a, n + tna, b, n + tnb);\\r\\nreturn;\\r\\n}\\r\\nc1 = bn_cmp_part_words(a, &(a[n]), tna, n - tna);\\r\\nc2 = bn_cmp_part_words(&(b[n]), b, tnb, tnb - n);\\r\\nneg = 0;\\r\\nswitch (c1 * 3 + c2) {\\r\\ncase -4:\\r\\nbn_sub_part_words(t, &(a[n]), a, tna, tna - n);\\r\\nbn_sub_part_words(&(t[n]), b, &(b[n]), tnb, n - tnb);\\r\\nbreak;\\r\\ncase -3:\\r\\ncase -2:\\r\\nbn_sub_part_words(t, &(a[n]), a, tna, tna - n);\\r\\nbn_sub_part_words(&(t[n]), &(b[n]), b, tnb, tnb - n);\\r\\nneg = 1;\\r\\nbreak;\\r\\ncase -1:\\r\\ncase 0:\\r\\ncase 1:\\r\\ncase 2:\\r\\nbn_sub_part_words(t, a, &(a[n]), tna, n - tna);\\r\\nbn_sub_part_words(&(t[n]), b, &(b[n]), tnb, n - tnb);\\r\\nneg = 1;\\r\\nbreak;\\r\\ncase 3:\\r\\ncase 4:\\r\\nbn_sub_part_words(t, a, &(a[n]), tna, n - tna);\\r\\nbn_sub_part_words(&(t[n]), &(b[n]), b, tnb, tnb - n);\\r\\nbreak;\\r\\n}\\r\\n# if 0\\r\\nif (n == 4) {\\r\\nbn_mul_comba4(&(t[n2]), t, &(t[n]));\\r\\nbn_mul_comba4(r, a, b);\\r\\nbn_mul_normal(&(r[n2]), &(a[n]), tn, &(b[n]), tn);\\r\\nmemset(&(r[n2 + tn * 2]), 0, sizeof(BN_ULONG) * (n2 - tn * 2));\\r\\n} else\\r\\n# endif\\r\\nif (n == 8) {\\r\\nbn_mul_comba8(&(t[n2]), t, &(t[n]));\\r\\nbn_mul_comba8(r, a, b);\\r\\nbn_mul_normal(&(r[n2]), &(a[n]), tna, &(b[n]), tnb);\\r\\nmemset(&(r[n2 + tna + tnb]), 0, sizeof(BN_ULONG) * (n2 - tna - tnb));\\r\\n} else {\\r\\np = &(t[n2 * 2]);\\r\\nbn_mul_recursive(&(t[n2]), t, &(t[n]), n, 0, 0, p);\\r\\nbn_mul_recursive(r, a, b, n, 0, 0, p);\\r\\ni = n / 2;\\r\\nif (tna > tnb)\\r\\nj = tna - i;\\r\\nelse\\r\\nj = tnb - i;\\r\\nif (j == 0) {\\r\\nbn_mul_recursive(&(r[n2]), &(a[n]), &(b[n]),\\r\\ni, tna - i, tnb - i, p);\\r\\nmemset(&(r[n2 + i * 2]), 0, sizeof(BN_ULONG) * (n2 - i * 2));\\r\\n} else if (j > 0) {\\r\\nbn_mul_part_recursive(&(r[n2]), &(a[n]), &(b[n]),\\r\\ni, tna - i, tnb - i, p);\\r\\nmemset(&(r[n2 + tna + tnb]), 0,\\r\\nsizeof(BN_ULONG) * (n2 - tna - tnb));\\r\\n} else {\\r\\nmemset(&(r[n2]), 0, sizeof(BN_ULONG) * n2);\\r\\nif (tna < BN_MUL_RECURSIVE_SIZE_NORMAL\\r\\n&& tnb < BN_MUL_RECURSIVE_SIZE_NORMAL) {\\r\\nbn_mul_normal(&(r[n2]), &(a[n]), tna, &(b[n]), tnb);\\r\\n} else {\\r\\nfor (;;) {\\r\\ni /= 2;\\r\\nif (i < tna || i < tnb) {\\r\\nbn_mul_part_recursive(&(r[n2]),\\r\\n&(a[n]), &(b[n]),\\r\\ni, tna - i, tnb - i, p);\\r\\nbreak;\\r\\n} else if (i == tna || i == tnb) {\\r\\nbn_mul_recursive(&(r[n2]),\\r\\n&(a[n]), &(b[n]),\\r\\ni, tna - i, tnb - i, p);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nc1 = (int)(bn_add_words(t, r, &(r[n2]), n2));\\r\\nif (neg) {\\r\\nc1 -= (int)(bn_sub_words(&(t[n2]), t, &(t[n2]), n2));\\r\\n} else {\\r\\nc1 += (int)(bn_add_words(&(t[n2]), &(t[n2]), t, n2));\\r\\n}\\r\\nc1 += (int)(bn_add_words(&(r[n]), &(r[n]), &(t[n2]), n2));\\r\\nif (c1) {\\r\\np = &(r[n + n2]);\\r\\nlo = *p;\\r\\nln = (lo + c1) & BN_MASK2;\\r\\n*p = ln;\\r\\nif (ln < (BN_ULONG)c1) {\\r\\ndo {\\r\\np++;\\r\\nlo = *p;\\r\\nln = (lo + 1) & BN_MASK2;\\r\\n*p = ln;\\r\\n} while (ln == 0);\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,\\r\\nBN_ULONG *t)\\r\\n{\\r\\nint n = n2 / 2;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_mul_low_recursive %d * %d\\n\", n2, n2);\\r\\n# endif\\r\\nbn_mul_recursive(r, a, b, n, 0, 0, &(t[0]));\\r\\nif (n >= BN_MUL_LOW_RECURSIVE_SIZE_NORMAL) {\\r\\nbn_mul_low_recursive(&(t[0]), &(a[0]), &(b[n]), n, &(t[n2]));\\r\\nbn_add_words(&(r[n]), &(r[n]), &(t[0]), n);\\r\\nbn_mul_low_recursive(&(t[0]), &(a[n]), &(b[0]), n, &(t[n2]));\\r\\nbn_add_words(&(r[n]), &(r[n]), &(t[0]), n);\\r\\n} else {\\r\\nbn_mul_low_normal(&(t[0]), &(a[0]), &(b[n]), n);\\r\\nbn_mul_low_normal(&(t[n]), &(a[n]), &(b[0]), n);\\r\\nbn_add_words(&(r[n]), &(r[n]), &(t[0]), n);\\r\\nbn_add_words(&(r[n]), &(r[n]), &(t[n]), n);\\r\\n}\\r\\n}\\r\\nvoid bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l, int n2,\\r\\nBN_ULONG *t)\\r\\n{\\r\\nint i, n;\\r\\nint c1, c2;\\r\\nint neg, oneg, zero;\\r\\nBN_ULONG ll, lc, *lp, *mp;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_mul_high %d * %d\\n\", n2, n2);\\r\\n# endif\\r\\nn = n2 / 2;\\r\\nneg = zero = 0;\\r\\nc1 = bn_cmp_words(&(a[0]), &(a[n]), n);\\r\\nc2 = bn_cmp_words(&(b[n]), &(b[0]), n);\\r\\nswitch (c1 * 3 + c2) {\\r\\ncase -4:\\r\\nbn_sub_words(&(r[0]), &(a[n]), &(a[0]), n);\\r\\nbn_sub_words(&(r[n]), &(b[0]), &(b[n]), n);\\r\\nbreak;\\r\\ncase -3:\\r\\nzero = 1;\\r\\nbreak;\\r\\ncase -2:\\r\\nbn_sub_words(&(r[0]), &(a[n]), &(a[0]), n);\\r\\nbn_sub_words(&(r[n]), &(b[n]), &(b[0]), n);\\r\\nneg = 1;\\r\\nbreak;\\r\\ncase -1:\\r\\ncase 0:\\r\\ncase 1:\\r\\nzero = 1;\\r\\nbreak;\\r\\ncase 2:\\r\\nbn_sub_words(&(r[0]), &(a[0]), &(a[n]), n);\\r\\nbn_sub_words(&(r[n]), &(b[0]), &(b[n]), n);\\r\\nneg = 1;\\r\\nbreak;\\r\\ncase 3:\\r\\nzero = 1;\\r\\nbreak;\\r\\ncase 4:\\r\\nbn_sub_words(&(r[0]), &(a[0]), &(a[n]), n);\\r\\nbn_sub_words(&(r[n]), &(b[n]), &(b[0]), n);\\r\\nbreak;\\r\\n}\\r\\noneg = neg;\\r\\n# ifdef BN_MUL_COMBA\\r\\nif (n == 8) {\\r\\nbn_mul_comba8(&(t[0]), &(r[0]), &(r[n]));\\r\\nbn_mul_comba8(r, &(a[n]), &(b[n]));\\r\\n} else\\r\\n# endif\\r\\n{\\r\\nbn_mul_recursive(&(t[0]), &(r[0]), &(r[n]), n, 0, 0, &(t[n2]));\\r\\nbn_mul_recursive(r, &(a[n]), &(b[n]), n, 0, 0, &(t[n2]));\\r\\n}\\r\\nif (l != NULL) {\\r\\nlp = &(t[n2 + n]);\\r\\nc1 = (int)(bn_add_words(lp, &(r[0]), &(l[0]), n));\\r\\n} else {\\r\\nc1 = 0;\\r\\nlp = &(r[0]);\\r\\n}\\r\\nif (neg)\\r\\nneg = (int)(bn_sub_words(&(t[n2]), lp, &(t[0]), n));\\r\\nelse {\\r\\nbn_add_words(&(t[n2]), lp, &(t[0]), n);\\r\\nneg = 0;\\r\\n}\\r\\nif (l != NULL) {\\r\\nbn_sub_words(&(t[n2 + n]), &(l[n]), &(t[n2]), n);\\r\\n} else {\\r\\nlp = &(t[n2 + n]);\\r\\nmp = &(t[n2]);\\r\\nfor (i = 0; i < n; i++)\\r\\nlp[i] = ((~mp[i]) + 1) & BN_MASK2;\\r\\n}\\r\\nif (l != NULL) {\\r\\nlp = &(t[n2]);\\r\\nc1 = (int)(bn_add_words(lp, &(t[n2 + n]), &(l[0]), n));\\r\\n} else {\\r\\nlp = &(t[n2 + n]);\\r\\nc1 = 0;\\r\\n}\\r\\nc1 += (int)(bn_add_words(&(t[n2]), lp, &(r[0]), n));\\r\\nif (oneg)\\r\\nc1 -= (int)(bn_sub_words(&(t[n2]), &(t[n2]), &(t[0]), n));\\r\\nelse\\r\\nc1 += (int)(bn_add_words(&(t[n2]), &(t[n2]), &(t[0]), n));\\r\\nc2 = (int)(bn_add_words(&(r[0]), &(r[0]), &(t[n2 + n]), n));\\r\\nc2 += (int)(bn_add_words(&(r[0]), &(r[0]), &(r[n]), n));\\r\\nif (oneg)\\r\\nc2 -= (int)(bn_sub_words(&(r[0]), &(r[0]), &(t[n]), n));\\r\\nelse\\r\\nc2 += (int)(bn_add_words(&(r[0]), &(r[0]), &(t[n]), n));\\r\\nif (c1 != 0) {\\r\\ni = 0;\\r\\nif (c1 > 0) {\\r\\nlc = c1;\\r\\ndo {\\r\\nll = (r[i] + lc) & BN_MASK2;\\r\\nr[i++] = ll;\\r\\nlc = (lc > ll);\\r\\n} while (lc);\\r\\n} else {\\r\\nlc = -c1;\\r\\ndo {\\r\\nll = r[i];\\r\\nr[i++] = (ll - lc) & BN_MASK2;\\r\\nlc = (lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\n}\\r\\nif (c2 != 0) {\\r\\ni = n;\\r\\nif (c2 > 0) {\\r\\nlc = c2;\\r\\ndo {\\r\\nll = (r[i] + lc) & BN_MASK2;\\r\\nr[i++] = ll;\\r\\nlc = (lc > ll);\\r\\n} while (lc);\\r\\n} else {\\r\\nlc = -c2;\\r\\ndo {\\r\\nll = r[i];\\r\\nr[i++] = (ll - lc) & BN_MASK2;\\r\\nlc = (lc > ll);\\r\\n} while (lc);\\r\\n}\\r\\n}\\r\\n}\\r\\nint BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nint top, al, bl;\\r\\nBIGNUM *rr;\\r\\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\\r\\nint i;\\r\\n#endif\\r\\n#ifdef BN_RECURSION\\r\\nBIGNUM *t = NULL;\\r\\nint j = 0, k;\\r\\n#endif\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \"BN_mul %d * %d\\n\", a->top, b->top);\\r\\n#endif\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(r);\\r\\nal = a->top;\\r\\nbl = b->top;\\r\\nif ((al == 0) || (bl == 0)) {\\r\\nBN_zero(r);\\r\\nreturn (1);\\r\\n}\\r\\ntop = al + bl;\\r\\nBN_CTX_start(ctx);\\r\\nif ((r == a) || (r == b)) {\\r\\nif ((rr = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\n} else\\r\\nrr = r;\\r\\nrr->neg = a->neg ^ b->neg;\\r\\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\\r\\ni = al - bl;\\r\\n#endif\\r\\n#ifdef BN_MUL_COMBA\\r\\nif (i == 0) {\\r\\n# if 0\\r\\nif (al == 4) {\\r\\nif (bn_wexpand(rr, 8) == NULL)\\r\\ngoto err;\\r\\nrr->top = 8;\\r\\nbn_mul_comba4(rr->d, a->d, b->d);\\r\\ngoto end;\\r\\n}\\r\\n# endif\\r\\nif (al == 8) {\\r\\nif (bn_wexpand(rr, 16) == NULL)\\r\\ngoto err;\\r\\nrr->top = 16;\\r\\nbn_mul_comba8(rr->d, a->d, b->d);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifdef BN_RECURSION\\r\\nif ((al >= BN_MULL_SIZE_NORMAL) && (bl >= BN_MULL_SIZE_NORMAL)) {\\r\\nif (i >= -1 && i <= 1) {\\r\\nif (i >= 0) {\\r\\nj = BN_num_bits_word((BN_ULONG)al);\\r\\n}\\r\\nif (i == -1) {\\r\\nj = BN_num_bits_word((BN_ULONG)bl);\\r\\n}\\r\\nj = 1 << (j - 1);\\r\\nassert(j <= al || j <= bl);\\r\\nk = j + j;\\r\\nt = BN_CTX_get(ctx);\\r\\nif (t == NULL)\\r\\ngoto err;\\r\\nif (al > j || bl > j) {\\r\\nif (bn_wexpand(t, k * 4) == NULL)\\r\\ngoto err;\\r\\nif (bn_wexpand(rr, k * 4) == NULL)\\r\\ngoto err;\\r\\nbn_mul_part_recursive(rr->d, a->d, b->d,\\r\\nj, al - j, bl - j, t->d);\\r\\n} else {\\r\\nif (bn_wexpand(t, k * 2) == NULL)\\r\\ngoto err;\\r\\nif (bn_wexpand(rr, k * 2) == NULL)\\r\\ngoto err;\\r\\nbn_mul_recursive(rr->d, a->d, b->d, j, al - j, bl - j, t->d);\\r\\n}\\r\\nrr->top = top;\\r\\ngoto end;\\r\\n}\\r\\n# if 0\\r\\nif (i == 1 && !BN_get_flags(b, BN_FLG_STATIC_DATA)) {\\r\\nBIGNUM *tmp_bn = (BIGNUM *)b;\\r\\nif (bn_wexpand(tmp_bn, al) == NULL)\\r\\ngoto err;\\r\\ntmp_bn->d[bl] = 0;\\r\\nbl++;\\r\\ni--;\\r\\n} else if (i == -1 && !BN_get_flags(a, BN_FLG_STATIC_DATA)) {\\r\\nBIGNUM *tmp_bn = (BIGNUM *)a;\\r\\nif (bn_wexpand(tmp_bn, bl) == NULL)\\r\\ngoto err;\\r\\ntmp_bn->d[al] = 0;\\r\\nal++;\\r\\ni++;\\r\\n}\\r\\nif (i == 0) {\\r\\nj = BN_num_bits_word((BN_ULONG)al);\\r\\nj = 1 << (j - 1);\\r\\nk = j + j;\\r\\nt = BN_CTX_get(ctx);\\r\\nif (al == j) {\\r\\nif (bn_wexpand(t, k * 2) == NULL)\\r\\ngoto err;\\r\\nif (bn_wexpand(rr, k * 2) == NULL)\\r\\ngoto err;\\r\\nbn_mul_recursive(rr->d, a->d, b->d, al, t->d);\\r\\n} else {\\r\\nif (bn_wexpand(t, k * 4) == NULL)\\r\\ngoto err;\\r\\nif (bn_wexpand(rr, k * 4) == NULL)\\r\\ngoto err;\\r\\nbn_mul_part_recursive(rr->d, a->d, b->d, al - j, j, t->d);\\r\\n}\\r\\nrr->top = top;\\r\\ngoto end;\\r\\n}\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\nif (bn_wexpand(rr, top) == NULL)\\r\\ngoto err;\\r\\nrr->top = top;\\r\\nbn_mul_normal(rr->d, a->d, al, b->d, bl);\\r\\n#if defined(BN_MUL_COMBA) || defined(BN_RECURSION)\\r\\nend:\\r\\n#endif\\r\\nbn_correct_top(rr);\\r\\nif (r != rr)\\r\\nBN_copy(r, rr);\\r\\nret = 1;\\r\\nerr:\\r\\nbn_check_top(r);\\r\\nBN_CTX_end(ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nvoid bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b, int nb)\\r\\n{\\r\\nBN_ULONG *rr;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_mul_normal %d * %d\\n\", na, nb);\\r\\n#endif\\r\\nif (na < nb) {\\r\\nint itmp;\\r\\nBN_ULONG *ltmp;\\r\\nitmp = na;\\r\\nna = nb;\\r\\nnb = itmp;\\r\\nltmp = a;\\r\\na = b;\\r\\nb = ltmp;\\r\\n}\\r\\nrr = &(r[na]);\\r\\nif (nb <= 0) {\\r\\n(void)bn_mul_words(r, a, na, 0);\\r\\nreturn;\\r\\n} else\\r\\nrr[0] = bn_mul_words(r, a, na, b[0]);\\r\\nfor (;;) {\\r\\nif (--nb <= 0)\\r\\nreturn;\\r\\nrr[1] = bn_mul_add_words(&(r[1]), a, na, b[1]);\\r\\nif (--nb <= 0)\\r\\nreturn;\\r\\nrr[2] = bn_mul_add_words(&(r[2]), a, na, b[2]);\\r\\nif (--nb <= 0)\\r\\nreturn;\\r\\nrr[3] = bn_mul_add_words(&(r[3]), a, na, b[3]);\\r\\nif (--nb <= 0)\\r\\nreturn;\\r\\nrr[4] = bn_mul_add_words(&(r[4]), a, na, b[4]);\\r\\nrr += 4;\\r\\nr += 4;\\r\\nb += 4;\\r\\n}\\r\\n}\\r\\nvoid bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\\r\\n{\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_mul_low_normal %d * %d\\n\", n, n);\\r\\n#endif\\r\\nbn_mul_words(r, a, n, b[0]);\\r\\nfor (;;) {\\r\\nif (--n <= 0)\\r\\nreturn;\\r\\nbn_mul_add_words(&(r[1]), a, n, b[1]);\\r\\nif (--n <= 0)\\r\\nreturn;\\r\\nbn_mul_add_words(&(r[2]), a, n, b[2]);\\r\\nif (--n <= 0)\\r\\nreturn;\\r\\nbn_mul_add_words(&(r[3]), a, n, b[3]);\\r\\nif (--n <= 0)\\r\\nreturn;\\r\\nbn_mul_add_words(&(r[4]), a, n, b[4]);\\r\\nr += 4;\\r\\nb += 4;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rand_key_c", "target": 0, "func": "int DES_random_key(DES_cblock *ret)\\r\\n{\\r\\ndo {\\r\\nif (RAND_bytes((unsigned char *)ret, sizeof(DES_cblock)) != 1)\\r\\nreturn (0);\\r\\n} while (DES_is_weak_key(ret));\\r\\nDES_set_odd_parity(ret);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc2_cbc_c", "target": 0, "func": "void RC2_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nRC2_KEY *ks, unsigned char *iv, int encrypt)\\r\\n{\\r\\nregister unsigned long tin0, tin1;\\r\\nregister unsigned long tout0, tout1, xor0, xor1;\\r\\nregister long l = length;\\r\\nunsigned long tin[2];\\r\\nif (encrypt) {\\r\\nc2l(iv, tout0);\\r\\nc2l(iv, tout1);\\r\\niv -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nc2l(in, tin0);\\r\\nc2l(in, tin1);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nRC2_encrypt(tin, ks);\\r\\ntout0 = tin[0];\\r\\nl2c(tout0, out);\\r\\ntout1 = tin[1];\\r\\nl2c(tout1, out);\\r\\n}\\r\\nif (l != -8) {\\r\\nc2ln(in, tin0, tin1, l + 8);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nRC2_encrypt(tin, ks);\\r\\ntout0 = tin[0];\\r\\nl2c(tout0, out);\\r\\ntout1 = tin[1];\\r\\nl2c(tout1, out);\\r\\n}\\r\\nl2c(tout0, iv);\\r\\nl2c(tout1, iv);\\r\\n} else {\\r\\nc2l(iv, xor0);\\r\\nc2l(iv, xor1);\\r\\niv -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nc2l(in, tin0);\\r\\ntin[0] = tin0;\\r\\nc2l(in, tin1);\\r\\ntin[1] = tin1;\\r\\nRC2_decrypt(tin, ks);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2c(tout0, out);\\r\\nl2c(tout1, out);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nif (l != -8) {\\r\\nc2l(in, tin0);\\r\\ntin[0] = tin0;\\r\\nc2l(in, tin1);\\r\\ntin[1] = tin1;\\r\\nRC2_decrypt(tin, ks);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2cn(tout0, tout1, out, l + 8);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nl2c(xor0, iv);\\r\\nl2c(xor1, iv);\\r\\n}\\r\\ntin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;\\r\\ntin[0] = tin[1] = 0;\\r\\n}\\r\\nvoid RC2_encrypt(unsigned long *d, RC2_KEY *key)\\r\\n{\\r\\nint i, n;\\r\\nregister RC2_INT *p0, *p1;\\r\\nregister RC2_INT x0, x1, x2, x3, t;\\r\\nunsigned long l;\\r\\nl = d[0];\\r\\nx0 = (RC2_INT) l & 0xffff;\\r\\nx1 = (RC2_INT) (l >> 16L);\\r\\nl = d[1];\\r\\nx2 = (RC2_INT) l & 0xffff;\\r\\nx3 = (RC2_INT) (l >> 16L);\\r\\nn = 3;\\r\\ni = 5;\\r\\np0 = p1 = &(key->data[0]);\\r\\nfor (;;) {\\r\\nt = (x0 + (x1 & ~x3) + (x2 & x3) + *(p0++)) & 0xffff;\\r\\nx0 = (t << 1) | (t >> 15);\\r\\nt = (x1 + (x2 & ~x0) + (x3 & x0) + *(p0++)) & 0xffff;\\r\\nx1 = (t << 2) | (t >> 14);\\r\\nt = (x2 + (x3 & ~x1) + (x0 & x1) + *(p0++)) & 0xffff;\\r\\nx2 = (t << 3) | (t >> 13);\\r\\nt = (x3 + (x0 & ~x2) + (x1 & x2) + *(p0++)) & 0xffff;\\r\\nx3 = (t << 5) | (t >> 11);\\r\\nif (--i == 0) {\\r\\nif (--n == 0)\\r\\nbreak;\\r\\ni = (n == 2) ? 6 : 5;\\r\\nx0 += p1[x3 & 0x3f];\\r\\nx1 += p1[x0 & 0x3f];\\r\\nx2 += p1[x1 & 0x3f];\\r\\nx3 += p1[x2 & 0x3f];\\r\\n}\\r\\n}\\r\\nd[0] =\\r\\n(unsigned long)(x0 & 0xffff) | ((unsigned long)(x1 & 0xffff) << 16L);\\r\\nd[1] =\\r\\n(unsigned long)(x2 & 0xffff) | ((unsigned long)(x3 & 0xffff) << 16L);\\r\\n}\\r\\nvoid RC2_decrypt(unsigned long *d, RC2_KEY *key)\\r\\n{\\r\\nint i, n;\\r\\nregister RC2_INT *p0, *p1;\\r\\nregister RC2_INT x0, x1, x2, x3, t;\\r\\nunsigned long l;\\r\\nl = d[0];\\r\\nx0 = (RC2_INT) l & 0xffff;\\r\\nx1 = (RC2_INT) (l >> 16L);\\r\\nl = d[1];\\r\\nx2 = (RC2_INT) l & 0xffff;\\r\\nx3 = (RC2_INT) (l >> 16L);\\r\\nn = 3;\\r\\ni = 5;\\r\\np0 = &(key->data[63]);\\r\\np1 = &(key->data[0]);\\r\\nfor (;;) {\\r\\nt = ((x3 << 11) | (x3 >> 5)) & 0xffff;\\r\\nx3 = (t - (x0 & ~x2) - (x1 & x2) - *(p0--)) & 0xffff;\\r\\nt = ((x2 << 13) | (x2 >> 3)) & 0xffff;\\r\\nx2 = (t - (x3 & ~x1) - (x0 & x1) - *(p0--)) & 0xffff;\\r\\nt = ((x1 << 14) | (x1 >> 2)) & 0xffff;\\r\\nx1 = (t - (x2 & ~x0) - (x3 & x0) - *(p0--)) & 0xffff;\\r\\nt = ((x0 << 15) | (x0 >> 1)) & 0xffff;\\r\\nx0 = (t - (x1 & ~x3) - (x2 & x3) - *(p0--)) & 0xffff;\\r\\nif (--i == 0) {\\r\\nif (--n == 0)\\r\\nbreak;\\r\\ni = (n == 2) ? 6 : 5;\\r\\nx3 = (x3 - p1[x2 & 0x3f]) & 0xffff;\\r\\nx2 = (x2 - p1[x1 & 0x3f]) & 0xffff;\\r\\nx1 = (x1 - p1[x0 & 0x3f]) & 0xffff;\\r\\nx0 = (x0 - p1[x3 & 0x3f]) & 0xffff;\\r\\n}\\r\\n}\\r\\nd[0] =\\r\\n(unsigned long)(x0 & 0xffff) | ((unsigned long)(x1 & 0xffff) << 16L);\\r\\nd[1] =\\r\\n(unsigned long)(x2 & 0xffff) | ((unsigned long)(x3 & 0xffff) << 16L);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_d1_srtp_c", "target": 0, "func": "static int find_profile_by_name(char *profile_name,\\r\\nSRTP_PROTECTION_PROFILE **pptr, unsigned len)\\r\\n{\\r\\nSRTP_PROTECTION_PROFILE *p;\\r\\np = srtp_known_profiles;\\r\\nwhile (p->name) {\\r\\nif ((len == strlen(p->name)) && !strncmp(p->name, profile_name, len)) {\\r\\n*pptr = p;\\r\\nreturn 0;\\r\\n}\\r\\np++;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_CTX_set_tlsext_use_srtp(SSL_CTX *ctx, const char *profiles)\\r\\n{\\r\\nreturn ssl_ctx_make_profiles(profiles, &ctx->srtp_profiles);\\r\\n}\\r\\nint SSL_set_tlsext_use_srtp(SSL *s, const char *profiles)\\r\\n{\\r\\nreturn ssl_ctx_make_profiles(profiles, &s->srtp_profiles);\\r\\n}\\r\\nint ssl_add_clienthello_use_srtp_ext(SSL *s, unsigned char *p, int *len,\\r\\nint maxlen)\\r\\n{\\r\\nint ct = 0;\\r\\nint i;\\r\\nSTACK_OF(SRTP_PROTECTION_PROFILE) *clnt = 0;\\r\\nSRTP_PROTECTION_PROFILE *prof;\\r\\nclnt = SSL_get_srtp_profiles(s);\\r\\nct = sk_SRTP_PROTECTION_PROFILE_num(clnt);\\r\\nif (p) {\\r\\nif (ct == 0) {\\r\\nSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_USE_SRTP_EXT,\\r\\nSSL_R_EMPTY_SRTP_PROTECTION_PROFILE_LIST);\\r\\nreturn 1;\\r\\n}\\r\\nif ((2 + ct * 2 + 1) > maxlen) {\\r\\nSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_USE_SRTP_EXT,\\r\\nSSL_R_SRTP_PROTECTION_PROFILE_LIST_TOO_LONG);\\r\\nreturn 1;\\r\\n}\\r\\ns2n(ct * 2, p);\\r\\nfor (i = 0; i < ct; i++) {\\r\\nprof = sk_SRTP_PROTECTION_PROFILE_value(clnt, i);\\r\\ns2n(prof->id, p);\\r\\n}\\r\\n*p++ = 0;\\r\\n}\\r\\n*len = 2 + ct * 2 + 1;\\r\\nreturn 0;\\r\\n}\\r\\nint ssl_parse_clienthello_use_srtp_ext(SSL *s, unsigned char *d, int len,\\r\\nint *al)\\r\\n{\\r\\nSRTP_PROTECTION_PROFILE *sprof;\\r\\nSTACK_OF(SRTP_PROTECTION_PROFILE) *srvr;\\r\\nint ct;\\r\\nint mki_len;\\r\\nint i, srtp_pref;\\r\\nunsigned int id;\\r\\nif (len < 3) {\\r\\nSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT,\\r\\nSSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 1;\\r\\n}\\r\\nn2s(d, ct);\\r\\nlen -= 2;\\r\\nif (ct % 2) {\\r\\nSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT,\\r\\nSSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 1;\\r\\n}\\r\\nif (len < (ct + 1)) {\\r\\nSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT,\\r\\nSSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 1;\\r\\n}\\r\\nsrvr = SSL_get_srtp_profiles(s);\\r\\ns->srtp_profile = NULL;\\r\\nsrtp_pref = sk_SRTP_PROTECTION_PROFILE_num(srvr);\\r\\nwhile (ct) {\\r\\nn2s(d, id);\\r\\nct -= 2;\\r\\nlen -= 2;\\r\\nfor (i = 0; i < srtp_pref; i++) {\\r\\nsprof = sk_SRTP_PROTECTION_PROFILE_value(srvr, i);\\r\\nif (sprof->id == id) {\\r\\ns->srtp_profile = sprof;\\r\\nsrtp_pref = i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nmki_len = *d;\\r\\nd++;\\r\\nlen--;\\r\\nif (mki_len != len) {\\r\\nSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT,\\r\\nSSL_R_BAD_SRTP_MKI_VALUE);\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint ssl_add_serverhello_use_srtp_ext(SSL *s, unsigned char *p, int *len,\\r\\nint maxlen)\\r\\n{\\r\\nif (p) {\\r\\nif (maxlen < 5) {\\r\\nSSLerr(SSL_F_SSL_ADD_SERVERHELLO_USE_SRTP_EXT,\\r\\nSSL_R_SRTP_PROTECTION_PROFILE_LIST_TOO_LONG);\\r\\nreturn 1;\\r\\n}\\r\\nif (s->srtp_profile == 0) {\\r\\nSSLerr(SSL_F_SSL_ADD_SERVERHELLO_USE_SRTP_EXT,\\r\\nSSL_R_USE_SRTP_NOT_NEGOTIATED);\\r\\nreturn 1;\\r\\n}\\r\\ns2n(2, p);\\r\\ns2n(s->srtp_profile->id, p);\\r\\n*p++ = 0;\\r\\n}\\r\\n*len = 5;\\r\\nreturn 0;\\r\\n}\\r\\nint ssl_parse_serverhello_use_srtp_ext(SSL *s, unsigned char *d, int len,\\r\\nint *al)\\r\\n{\\r\\nunsigned id;\\r\\nint i;\\r\\nint ct;\\r\\nSTACK_OF(SRTP_PROTECTION_PROFILE) *clnt;\\r\\nSRTP_PROTECTION_PROFILE *prof;\\r\\nif (len != 5) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT,\\r\\nSSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 1;\\r\\n}\\r\\nn2s(d, ct);\\r\\nif (ct != 2) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT,\\r\\nSSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 1;\\r\\n}\\r\\nn2s(d, id);\\r\\nif (*d) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT,\\r\\nSSL_R_BAD_SRTP_MKI_VALUE);\\r\\n*al = SSL_AD_ILLEGAL_PARAMETER;\\r\\nreturn 1;\\r\\n}\\r\\nclnt = SSL_get_srtp_profiles(s);\\r\\nif (clnt == NULL) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT,\\r\\nSSL_R_NO_SRTP_PROFILES);\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 1;\\r\\n}\\r\\nfor (i = 0; i < sk_SRTP_PROTECTION_PROFILE_num(clnt); i++) {\\r\\nprof = sk_SRTP_PROTECTION_PROFILE_value(clnt, i);\\r\\nif (prof->id == id) {\\r\\ns->srtp_profile = prof;\\r\\n*al = 0;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT,\\r\\nSSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_wp_block_c", "target": 0, "func": "void whirlpool_block(WHIRLPOOL_CTX *ctx, const void *inp, size_t n)\\r\\n{\\r\\nint r;\\r\\nconst u8 *p = inp;\\r\\nunion {\\r\\nu64 q[8];\\r\\nu8 c[64];\\r\\n} S, K, *H = (void *)ctx->H.q;\\r\\n#ifdef GO_FOR_MMX\\r\\nGO_FOR_MMX(ctx, inp, n);\\r\\n#endif\\r\\ndo {\\r\\n#ifdef OPENSSL_SMALL_FOOTPRINT\\r\\nu64 L[8];\\r\\nint i;\\r\\nfor (i = 0; i < 64; i++)\\r\\nS.c[i] = (K.c[i] = H->c[i]) ^ p[i];\\r\\nfor (r = 0; r < ROUNDS; r++) {\\r\\nfor (i = 0; i < 8; i++) {\\r\\nL[i] = i ? 0 : RC[r];\\r\\nL[i] ^= C0(K, i) ^ C1(K, (i - 1) & 7) ^\\r\\nC2(K, (i - 2) & 7) ^ C3(K, (i - 3) & 7) ^\\r\\nC4(K, (i - 4) & 7) ^ C5(K, (i - 5) & 7) ^\\r\\nC6(K, (i - 6) & 7) ^ C7(K, (i - 7) & 7);\\r\\n}\\r\\nmemcpy(K.q, L, 64);\\r\\nfor (i = 0; i < 8; i++) {\\r\\nL[i] ^= C0(S, i) ^ C1(S, (i - 1) & 7) ^\\r\\nC2(S, (i - 2) & 7) ^ C3(S, (i - 3) & 7) ^\\r\\nC4(S, (i - 4) & 7) ^ C5(S, (i - 5) & 7) ^\\r\\nC6(S, (i - 6) & 7) ^ C7(S, (i - 7) & 7);\\r\\n}\\r\\nmemcpy(S.q, L, 64);\\r\\n}\\r\\nfor (i = 0; i < 64; i++)\\r\\nH->c[i] ^= S.c[i] ^ p[i];\\r\\n#else\\r\\nu64 L0, L1, L2, L3, L4, L5, L6, L7;\\r\\n# ifdef STRICT_ALIGNMENT\\r\\nif ((size_t)p & 7) {\\r\\nmemcpy(S.c, p, 64);\\r\\nS.q[0] ^= (K.q[0] = H->q[0]);\\r\\nS.q[1] ^= (K.q[1] = H->q[1]);\\r\\nS.q[2] ^= (K.q[2] = H->q[2]);\\r\\nS.q[3] ^= (K.q[3] = H->q[3]);\\r\\nS.q[4] ^= (K.q[4] = H->q[4]);\\r\\nS.q[5] ^= (K.q[5] = H->q[5]);\\r\\nS.q[6] ^= (K.q[6] = H->q[6]);\\r\\nS.q[7] ^= (K.q[7] = H->q[7]);\\r\\n} else\\r\\n# endif\\r\\n{\\r\\nconst u64 *pa = (const u64 *)p;\\r\\nS.q[0] = (K.q[0] = H->q[0]) ^ pa[0];\\r\\nS.q[1] = (K.q[1] = H->q[1]) ^ pa[1];\\r\\nS.q[2] = (K.q[2] = H->q[2]) ^ pa[2];\\r\\nS.q[3] = (K.q[3] = H->q[3]) ^ pa[3];\\r\\nS.q[4] = (K.q[4] = H->q[4]) ^ pa[4];\\r\\nS.q[5] = (K.q[5] = H->q[5]) ^ pa[5];\\r\\nS.q[6] = (K.q[6] = H->q[6]) ^ pa[6];\\r\\nS.q[7] = (K.q[7] = H->q[7]) ^ pa[7];\\r\\n}\\r\\nfor (r = 0; r < ROUNDS; r++) {\\r\\n# ifdef SMALL_REGISTER_BANK\\r\\nL0 = C0(K, 0) ^ C1(K, 7) ^ C2(K, 6) ^ C3(K, 5) ^\\r\\nC4(K, 4) ^ C5(K, 3) ^ C6(K, 2) ^ C7(K, 1) ^ RC[r];\\r\\nL1 = C0(K, 1) ^ C1(K, 0) ^ C2(K, 7) ^ C3(K, 6) ^\\r\\nC4(K, 5) ^ C5(K, 4) ^ C6(K, 3) ^ C7(K, 2);\\r\\nL2 = C0(K, 2) ^ C1(K, 1) ^ C2(K, 0) ^ C3(K, 7) ^\\r\\nC4(K, 6) ^ C5(K, 5) ^ C6(K, 4) ^ C7(K, 3);\\r\\nL3 = C0(K, 3) ^ C1(K, 2) ^ C2(K, 1) ^ C3(K, 0) ^\\r\\nC4(K, 7) ^ C5(K, 6) ^ C6(K, 5) ^ C7(K, 4);\\r\\nL4 = C0(K, 4) ^ C1(K, 3) ^ C2(K, 2) ^ C3(K, 1) ^\\r\\nC4(K, 0) ^ C5(K, 7) ^ C6(K, 6) ^ C7(K, 5);\\r\\nL5 = C0(K, 5) ^ C1(K, 4) ^ C2(K, 3) ^ C3(K, 2) ^\\r\\nC4(K, 1) ^ C5(K, 0) ^ C6(K, 7) ^ C7(K, 6);\\r\\nL6 = C0(K, 6) ^ C1(K, 5) ^ C2(K, 4) ^ C3(K, 3) ^\\r\\nC4(K, 2) ^ C5(K, 1) ^ C6(K, 0) ^ C7(K, 7);\\r\\nL7 = C0(K, 7) ^ C1(K, 6) ^ C2(K, 5) ^ C3(K, 4) ^\\r\\nC4(K, 3) ^ C5(K, 2) ^ C6(K, 1) ^ C7(K, 0);\\r\\nK.q[0] = L0;\\r\\nK.q[1] = L1;\\r\\nK.q[2] = L2;\\r\\nK.q[3] = L3;\\r\\nK.q[4] = L4;\\r\\nK.q[5] = L5;\\r\\nK.q[6] = L6;\\r\\nK.q[7] = L7;\\r\\nL0 ^= C0(S, 0) ^ C1(S, 7) ^ C2(S, 6) ^ C3(S, 5) ^\\r\\nC4(S, 4) ^ C5(S, 3) ^ C6(S, 2) ^ C7(S, 1);\\r\\nL1 ^= C0(S, 1) ^ C1(S, 0) ^ C2(S, 7) ^ C3(S, 6) ^\\r\\nC4(S, 5) ^ C5(S, 4) ^ C6(S, 3) ^ C7(S, 2);\\r\\nL2 ^= C0(S, 2) ^ C1(S, 1) ^ C2(S, 0) ^ C3(S, 7) ^\\r\\nC4(S, 6) ^ C5(S, 5) ^ C6(S, 4) ^ C7(S, 3);\\r\\nL3 ^= C0(S, 3) ^ C1(S, 2) ^ C2(S, 1) ^ C3(S, 0) ^\\r\\nC4(S, 7) ^ C5(S, 6) ^ C6(S, 5) ^ C7(S, 4);\\r\\nL4 ^= C0(S, 4) ^ C1(S, 3) ^ C2(S, 2) ^ C3(S, 1) ^\\r\\nC4(S, 0) ^ C5(S, 7) ^ C6(S, 6) ^ C7(S, 5);\\r\\nL5 ^= C0(S, 5) ^ C1(S, 4) ^ C2(S, 3) ^ C3(S, 2) ^\\r\\nC4(S, 1) ^ C5(S, 0) ^ C6(S, 7) ^ C7(S, 6);\\r\\nL6 ^= C0(S, 6) ^ C1(S, 5) ^ C2(S, 4) ^ C3(S, 3) ^\\r\\nC4(S, 2) ^ C5(S, 1) ^ C6(S, 0) ^ C7(S, 7);\\r\\nL7 ^= C0(S, 7) ^ C1(S, 6) ^ C2(S, 5) ^ C3(S, 4) ^\\r\\nC4(S, 3) ^ C5(S, 2) ^ C6(S, 1) ^ C7(S, 0);\\r\\nS.q[0] = L0;\\r\\nS.q[1] = L1;\\r\\nS.q[2] = L2;\\r\\nS.q[3] = L3;\\r\\nS.q[4] = L4;\\r\\nS.q[5] = L5;\\r\\nS.q[6] = L6;\\r\\nS.q[7] = L7;\\r\\n# else\\r\\nL0 = C0(K, 0);\\r\\nL1 = C1(K, 0);\\r\\nL2 = C2(K, 0);\\r\\nL3 = C3(K, 0);\\r\\nL4 = C4(K, 0);\\r\\nL5 = C5(K, 0);\\r\\nL6 = C6(K, 0);\\r\\nL7 = C7(K, 0);\\r\\nL0 ^= RC[r];\\r\\nL1 ^= C0(K, 1);\\r\\nL2 ^= C1(K, 1);\\r\\nL3 ^= C2(K, 1);\\r\\nL4 ^= C3(K, 1);\\r\\nL5 ^= C4(K, 1);\\r\\nL6 ^= C5(K, 1);\\r\\nL7 ^= C6(K, 1);\\r\\nL0 ^= C7(K, 1);\\r\\nL2 ^= C0(K, 2);\\r\\nL3 ^= C1(K, 2);\\r\\nL4 ^= C2(K, 2);\\r\\nL5 ^= C3(K, 2);\\r\\nL6 ^= C4(K, 2);\\r\\nL7 ^= C5(K, 2);\\r\\nL0 ^= C6(K, 2);\\r\\nL1 ^= C7(K, 2);\\r\\nL3 ^= C0(K, 3);\\r\\nL4 ^= C1(K, 3);\\r\\nL5 ^= C2(K, 3);\\r\\nL6 ^= C3(K, 3);\\r\\nL7 ^= C4(K, 3);\\r\\nL0 ^= C5(K, 3);\\r\\nL1 ^= C6(K, 3);\\r\\nL2 ^= C7(K, 3);\\r\\nL4 ^= C0(K, 4);\\r\\nL5 ^= C1(K, 4);\\r\\nL6 ^= C2(K, 4);\\r\\nL7 ^= C3(K, 4);\\r\\nL0 ^= C4(K, 4);\\r\\nL1 ^= C5(K, 4);\\r\\nL2 ^= C6(K, 4);\\r\\nL3 ^= C7(K, 4);\\r\\nL5 ^= C0(K, 5);\\r\\nL6 ^= C1(K, 5);\\r\\nL7 ^= C2(K, 5);\\r\\nL0 ^= C3(K, 5);\\r\\nL1 ^= C4(K, 5);\\r\\nL2 ^= C5(K, 5);\\r\\nL3 ^= C6(K, 5);\\r\\nL4 ^= C7(K, 5);\\r\\nL6 ^= C0(K, 6);\\r\\nL7 ^= C1(K, 6);\\r\\nL0 ^= C2(K, 6);\\r\\nL1 ^= C3(K, 6);\\r\\nL2 ^= C4(K, 6);\\r\\nL3 ^= C5(K, 6);\\r\\nL4 ^= C6(K, 6);\\r\\nL5 ^= C7(K, 6);\\r\\nL7 ^= C0(K, 7);\\r\\nL0 ^= C1(K, 7);\\r\\nL1 ^= C2(K, 7);\\r\\nL2 ^= C3(K, 7);\\r\\nL3 ^= C4(K, 7);\\r\\nL4 ^= C5(K, 7);\\r\\nL5 ^= C6(K, 7);\\r\\nL6 ^= C7(K, 7);\\r\\nK.q[0] = L0;\\r\\nK.q[1] = L1;\\r\\nK.q[2] = L2;\\r\\nK.q[3] = L3;\\r\\nK.q[4] = L4;\\r\\nK.q[5] = L5;\\r\\nK.q[6] = L6;\\r\\nK.q[7] = L7;\\r\\nL0 ^= C0(S, 0);\\r\\nL1 ^= C1(S, 0);\\r\\nL2 ^= C2(S, 0);\\r\\nL3 ^= C3(S, 0);\\r\\nL4 ^= C4(S, 0);\\r\\nL5 ^= C5(S, 0);\\r\\nL6 ^= C6(S, 0);\\r\\nL7 ^= C7(S, 0);\\r\\nL1 ^= C0(S, 1);\\r\\nL2 ^= C1(S, 1);\\r\\nL3 ^= C2(S, 1);\\r\\nL4 ^= C3(S, 1);\\r\\nL5 ^= C4(S, 1);\\r\\nL6 ^= C5(S, 1);\\r\\nL7 ^= C6(S, 1);\\r\\nL0 ^= C7(S, 1);\\r\\nL2 ^= C0(S, 2);\\r\\nL3 ^= C1(S, 2);\\r\\nL4 ^= C2(S, 2);\\r\\nL5 ^= C3(S, 2);\\r\\nL6 ^= C4(S, 2);\\r\\nL7 ^= C5(S, 2);\\r\\nL0 ^= C6(S, 2);\\r\\nL1 ^= C7(S, 2);\\r\\nL3 ^= C0(S, 3);\\r\\nL4 ^= C1(S, 3);\\r\\nL5 ^= C2(S, 3);\\r\\nL6 ^= C3(S, 3);\\r\\nL7 ^= C4(S, 3);\\r\\nL0 ^= C5(S, 3);\\r\\nL1 ^= C6(S, 3);\\r\\nL2 ^= C7(S, 3);\\r\\nL4 ^= C0(S, 4);\\r\\nL5 ^= C1(S, 4);\\r\\nL6 ^= C2(S, 4);\\r\\nL7 ^= C3(S, 4);\\r\\nL0 ^= C4(S, 4);\\r\\nL1 ^= C5(S, 4);\\r\\nL2 ^= C6(S, 4);\\r\\nL3 ^= C7(S, 4);\\r\\nL5 ^= C0(S, 5);\\r\\nL6 ^= C1(S, 5);\\r\\nL7 ^= C2(S, 5);\\r\\nL0 ^= C3(S, 5);\\r\\nL1 ^= C4(S, 5);\\r\\nL2 ^= C5(S, 5);\\r\\nL3 ^= C6(S, 5);\\r\\nL4 ^= C7(S, 5);\\r\\nL6 ^= C0(S, 6);\\r\\nL7 ^= C1(S, 6);\\r\\nL0 ^= C2(S, 6);\\r\\nL1 ^= C3(S, 6);\\r\\nL2 ^= C4(S, 6);\\r\\nL3 ^= C5(S, 6);\\r\\nL4 ^= C6(S, 6);\\r\\nL5 ^= C7(S, 6);\\r\\nL7 ^= C0(S, 7);\\r\\nL0 ^= C1(S, 7);\\r\\nL1 ^= C2(S, 7);\\r\\nL2 ^= C3(S, 7);\\r\\nL3 ^= C4(S, 7);\\r\\nL4 ^= C5(S, 7);\\r\\nL5 ^= C6(S, 7);\\r\\nL6 ^= C7(S, 7);\\r\\nS.q[0] = L0;\\r\\nS.q[1] = L1;\\r\\nS.q[2] = L2;\\r\\nS.q[3] = L3;\\r\\nS.q[4] = L4;\\r\\nS.q[5] = L5;\\r\\nS.q[6] = L6;\\r\\nS.q[7] = L7;\\r\\n# endif\\r\\n}\\r\\n# ifdef STRICT_ALIGNMENT\\r\\nif ((size_t)p & 7) {\\r\\nint i;\\r\\nfor (i = 0; i < 64; i++)\\r\\nH->c[i] ^= S.c[i] ^ p[i];\\r\\n} else\\r\\n# endif\\r\\n{\\r\\nconst u64 *pa = (const u64 *)p;\\r\\nH->q[0] ^= S.q[0] ^ pa[0];\\r\\nH->q[1] ^= S.q[1] ^ pa[1];\\r\\nH->q[2] ^= S.q[2] ^ pa[2];\\r\\nH->q[3] ^= S.q[3] ^ pa[3];\\r\\nH->q[4] ^= S.q[4] ^ pa[4];\\r\\nH->q[5] ^= S.q[5] ^ pa[5];\\r\\nH->q[6] ^= S.q[6] ^ pa[6];\\r\\nH->q[7] ^= S.q[7] ^ pa[7];\\r\\n}\\r\\n#endif\\r\\np += 64;\\r\\n} while (--n);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_obj_lib_c", "target": 0, "func": "ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o)\\r\\n{\\r\\nASN1_OBJECT *r;\\r\\nint i;\\r\\nchar *ln = NULL, *sn = NULL;\\r\\nunsigned char *data = NULL;\\r\\nif (o == NULL)\\r\\nreturn (NULL);\\r\\nif (!(o->flags & ASN1_OBJECT_FLAG_DYNAMIC))\\r\\nreturn ((ASN1_OBJECT *)o);\\r\\nr = ASN1_OBJECT_new();\\r\\nif (r == NULL) {\\r\\nOBJerr(OBJ_F_OBJ_DUP, ERR_R_ASN1_LIB);\\r\\nreturn (NULL);\\r\\n}\\r\\ndata = OPENSSL_malloc(o->length);\\r\\nif (data == NULL)\\r\\ngoto err;\\r\\nif (o->data != NULL)\\r\\nmemcpy(data, o->data, o->length);\\r\\nr->data = data;\\r\\nr->length = o->length;\\r\\nr->nid = o->nid;\\r\\nr->ln = r->sn = NULL;\\r\\nif (o->ln != NULL) {\\r\\ni = strlen(o->ln) + 1;\\r\\nln = OPENSSL_malloc(i);\\r\\nif (ln == NULL)\\r\\ngoto err;\\r\\nmemcpy(ln, o->ln, i);\\r\\nr->ln = ln;\\r\\n}\\r\\nif (o->sn != NULL) {\\r\\ni = strlen(o->sn) + 1;\\r\\nsn = OPENSSL_malloc(i);\\r\\nif (sn == NULL)\\r\\ngoto err;\\r\\nmemcpy(sn, o->sn, i);\\r\\nr->sn = sn;\\r\\n}\\r\\nr->flags = o->flags | (ASN1_OBJECT_FLAG_DYNAMIC |\\r\\nASN1_OBJECT_FLAG_DYNAMIC_STRINGS |\\r\\nASN1_OBJECT_FLAG_DYNAMIC_DATA);\\r\\nreturn (r);\\r\\nerr:\\r\\nOBJerr(OBJ_F_OBJ_DUP, ERR_R_MALLOC_FAILURE);\\r\\nif (ln != NULL)\\r\\nOPENSSL_free(ln);\\r\\nif (sn != NULL)\\r\\nOPENSSL_free(sn);\\r\\nif (data != NULL)\\r\\nOPENSSL_free(data);\\r\\nif (r != NULL)\\r\\nOPENSSL_free(r);\\r\\nreturn (NULL);\\r\\n}\\r\\nint OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b)\\r\\n{\\r\\nint ret;\\r\\nret = (a->length - b->length);\\r\\nif (ret)\\r\\nreturn (ret);\\r\\nreturn (memcmp(a->data, b->data, a->length));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret = 1;\\r\\nchar *configfile = NULL;\\r\\nchar *section = NULL;\\r\\nCONF *conf = NULL;\\r\\nenum mode {\\r\\nCMD_NONE, CMD_QUERY, CMD_REPLY, CMD_VERIFY\\r\\n} mode = CMD_NONE;\\r\\nchar *data = NULL;\\r\\nchar *digest = NULL;\\r\\nconst EVP_MD *md = NULL;\\r\\nchar *rnd = NULL;\\r\\nchar *policy = NULL;\\r\\nint no_nonce = 0;\\r\\nint cert = 0;\\r\\nchar *in = NULL;\\r\\nchar *out = NULL;\\r\\nint text = 0;\\r\\nchar *queryfile = NULL;\\r\\nchar *passin = NULL;\\r\\nchar *password = NULL;\\r\\nchar *inkey = NULL;\\r\\nchar *signer = NULL;\\r\\nchar *chain = NULL;\\r\\nchar *ca_path = NULL;\\r\\nchar *ca_file = NULL;\\r\\nchar *untrusted = NULL;\\r\\nchar *engine = NULL;\\r\\nint token_in = 0;\\r\\nint token_out = 0;\\r\\nint free_bio_err = 0;\\r\\nERR_load_crypto_strings();\\r\\napps_startup();\\r\\nif (bio_err == NULL && (bio_err = BIO_new(BIO_s_file())) != NULL) {\\r\\nfree_bio_err = 1;\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n}\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto cleanup;\\r\\nfor (argc--, argv++; argc > 0; argc--, argv++) {\\r\\nif (strcmp(*argv, \"-config\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nconfigfile = *++argv;\\r\\n} else if (strcmp(*argv, \"-section\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nsection = *++argv;\\r\\n} else if (strcmp(*argv, \"-query\") == 0) {\\r\\nif (mode != CMD_NONE)\\r\\ngoto usage;\\r\\nmode = CMD_QUERY;\\r\\n} else if (strcmp(*argv, \"-data\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\ndata = *++argv;\\r\\n} else if (strcmp(*argv, \"-digest\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\ndigest = *++argv;\\r\\n} else if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nrnd = *++argv;\\r\\n} else if (strcmp(*argv, \"-policy\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\npolicy = *++argv;\\r\\n} else if (strcmp(*argv, \"-no_nonce\") == 0) {\\r\\nno_nonce = 1;\\r\\n} else if (strcmp(*argv, \"-cert\") == 0) {\\r\\ncert = 1;\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nin = *++argv;\\r\\n} else if (strcmp(*argv, \"-token_in\") == 0) {\\r\\ntoken_in = 1;\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nout = *++argv;\\r\\n} else if (strcmp(*argv, \"-token_out\") == 0) {\\r\\ntoken_out = 1;\\r\\n} else if (strcmp(*argv, \"-text\") == 0) {\\r\\ntext = 1;\\r\\n} else if (strcmp(*argv, \"-reply\") == 0) {\\r\\nif (mode != CMD_NONE)\\r\\ngoto usage;\\r\\nmode = CMD_REPLY;\\r\\n} else if (strcmp(*argv, \"-queryfile\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nqueryfile = *++argv;\\r\\n} else if (strcmp(*argv, \"-passin\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\npassin = *++argv;\\r\\n} else if (strcmp(*argv, \"-inkey\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\ninkey = *++argv;\\r\\n} else if (strcmp(*argv, \"-signer\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nsigner = *++argv;\\r\\n} else if (strcmp(*argv, \"-chain\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nchain = *++argv;\\r\\n} else if (strcmp(*argv, \"-verify\") == 0) {\\r\\nif (mode != CMD_NONE)\\r\\ngoto usage;\\r\\nmode = CMD_VERIFY;\\r\\n} else if (strcmp(*argv, \"-CApath\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nca_path = *++argv;\\r\\n} else if (strcmp(*argv, \"-CAfile\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nca_file = *++argv;\\r\\n} else if (strcmp(*argv, \"-untrusted\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nuntrusted = *++argv;\\r\\n} else if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto usage;\\r\\nengine = *++argv;\\r\\n} else if ((md = EVP_get_digestbyname(*argv + 1)) != NULL) {\\r\\n} else\\r\\ngoto usage;\\r\\n}\\r\\nif (mode == CMD_QUERY && !no_nonce) {\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && rnd == NULL)\\r\\nBIO_printf(bio_err, \"warning, not much extra random \"\\r\\n\"data, consider using the -rand option\\n\");\\r\\nif (rnd != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(rnd));\\r\\n}\\r\\nif (mode == CMD_REPLY && passin &&\\r\\n!app_passwd(bio_err, passin, NULL, &password, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password.\\n\");\\r\\ngoto cleanup;\\r\\n}\\r\\nswitch (mode) {\\r\\ncase CMD_NONE:\\r\\ngoto usage;\\r\\ncase CMD_QUERY:\\r\\nret = data != NULL && digest != NULL;\\r\\nif (ret)\\r\\ngoto usage;\\r\\nconf = load_config_file(configfile);\\r\\nret = !query_command(data, digest, md, policy, no_nonce, cert,\\r\\nin, out, text);\\r\\nbreak;\\r\\ncase CMD_REPLY:\\r\\nconf = load_config_file(configfile);\\r\\nif (in == NULL) {\\r\\nret = !(queryfile != NULL && conf != NULL && !token_in);\\r\\nif (ret)\\r\\ngoto usage;\\r\\n} else {\\r\\nret = !(queryfile == NULL);\\r\\nif (ret)\\r\\ngoto usage;\\r\\n}\\r\\nret = !reply_command(conf, section, engine, queryfile,\\r\\npassword, inkey, signer, chain, policy,\\r\\nin, token_in, out, token_out, text);\\r\\nbreak;\\r\\ncase CMD_VERIFY:\\r\\nret = !(((queryfile && !data && !digest)\\r\\n|| (!queryfile && data && !digest)\\r\\n|| (!queryfile && !data && digest))\\r\\n&& in != NULL);\\r\\nif (ret)\\r\\ngoto usage;\\r\\nret = !verify_command(data, digest, queryfile, in, token_in,\\r\\nca_path, ca_file, untrusted);\\r\\n}\\r\\ngoto cleanup;\\r\\nusage:\\r\\nBIO_printf(bio_err, \"usage:\\n\"\\r\\n\"ts -query [-rand file%cfile%c...] [-config configfile] \"\\r\\n\"[-data file_to_hash] [-digest digest_bytes]\"\\r\\n\"[-md2|-md4|-md5|-sha|-sha1|-mdc2|-ripemd160] \"\\r\\n\"[-policy object_id] [-no_nonce] [-cert] \"\\r\\n\"[-in request.tsq] [-out request.tsq] [-text]\\n\",\\r\\nLIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err, \"or\\n\"\\r\\n\"ts -reply [-config configfile] [-section tsa_section] \"\\r\\n\"[-queryfile request.tsq] [-passin password] \"\\r\\n\"[-signer tsa_cert.pem] [-inkey private_key.pem] \"\\r\\n\"[-chain certs_file.pem] [-policy object_id] \"\\r\\n\"[-in response.tsr] [-token_in] \"\\r\\n\"[-out response.tsr] [-token_out] [-text] [-engine id]\\n\");\\r\\nBIO_printf(bio_err, \"or\\n\"\\r\\n\"ts -verify [-data file_to_hash] [-digest digest_bytes] \"\\r\\n\"[-queryfile request.tsq] \"\\r\\n\"-in response.tsr [-token_in] \"\\r\\n\"-CApath ca_path -CAfile ca_file.pem \"\\r\\n\"-untrusted cert_file.pem\\n\");\\r\\ncleanup:\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nNCONF_free(conf);\\r\\nOPENSSL_free(password);\\r\\nOBJ_cleanup();\\r\\nif (free_bio_err) {\\r\\nBIO_free_all(bio_err);\\r\\nbio_err = NULL;\\r\\n}\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic ASN1_OBJECT *txt2obj(const char *oid)\\r\\n{\\r\\nASN1_OBJECT *oid_obj = NULL;\\r\\nif (!(oid_obj = OBJ_txt2obj(oid, 0)))\\r\\nBIO_printf(bio_err, \"cannot convert %s to OID\\n\", oid);\\r\\nreturn oid_obj;\\r\\n}\\r\\nstatic CONF *load_config_file(const char *configfile)\\r\\n{\\r\\nCONF *conf = NULL;\\r\\nlong errorline = -1;\\r\\nif (!configfile)\\r\\nconfigfile = getenv(\"OPENSSL_CONF\");\\r\\nif (!configfile)\\r\\nconfigfile = getenv(\"SSLEAY_CONF\");\\r\\nif (configfile &&\\r\\n(!(conf = NCONF_new(NULL)) ||\\r\\nNCONF_load(conf, configfile, &errorline) <= 0)) {\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err, \"error loading the config file \"\\r\\n\"'%s'\\n\", configfile);\\r\\nelse\\r\\nBIO_printf(bio_err, \"error on line %ld of config file \"\\r\\n\"'%s'\\n\", errorline, configfile);\\r\\n}\\r\\nif (conf != NULL) {\\r\\nconst char *p;\\r\\nBIO_printf(bio_err, \"Using configuration from %s\\n\", configfile);\\r\\np = NCONF_get_string(conf, NULL, ENV_OID_FILE);\\r\\nif (p != NULL) {\\r\\nBIO *oid_bio = BIO_new_file(p, \"r\");\\r\\nif (!oid_bio)\\r\\nERR_print_errors(bio_err);\\r\\nelse {\\r\\nOBJ_create_objects(oid_bio);\\r\\nBIO_free_all(oid_bio);\\r\\n}\\r\\n} else\\r\\nERR_clear_error();\\r\\nif (!add_oid_section(bio_err, conf))\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nreturn conf;\\r\\n}\\r\\nstatic int query_command(const char *data, char *digest, const EVP_MD *md,\\r\\nconst char *policy, int no_nonce,\\r\\nint cert, const char *in, const char *out, int text)\\r\\n{\\r\\nint ret = 0;\\r\\nTS_REQ *query = NULL;\\r\\nBIO *in_bio = NULL;\\r\\nBIO *data_bio = NULL;\\r\\nBIO *out_bio = NULL;\\r\\nif (in != NULL) {\\r\\nif ((in_bio = BIO_new_file(in, \"rb\")) == NULL)\\r\\ngoto end;\\r\\nquery = d2i_TS_REQ_bio(in_bio, NULL);\\r\\n} else {\\r\\nif (!digest && !(data_bio = BIO_open_with_default(data, \"rb\", stdin)))\\r\\ngoto end;\\r\\nquery = create_query(data_bio, digest, md, policy, no_nonce, cert);\\r\\n}\\r\\nif (query == NULL)\\r\\ngoto end;\\r\\nif ((out_bio = BIO_open_with_default(out, \"wb\", stdout)) == NULL)\\r\\ngoto end;\\r\\nif (text) {\\r\\nif (!TS_REQ_print_bio(out_bio, query))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!i2d_TS_REQ_bio(out_bio, query))\\r\\ngoto end;\\r\\n}\\r\\nret = 1;\\r\\nend:\\r\\nERR_print_errors(bio_err);\\r\\nBIO_free_all(in_bio);\\r\\nBIO_free_all(data_bio);\\r\\nBIO_free_all(out_bio);\\r\\nTS_REQ_free(query);\\r\\nreturn ret;\\r\\n}\\r\\nstatic BIO *BIO_open_with_default(const char *file, const char *mode,\\r\\nFILE *default_fp)\\r\\n{\\r\\nreturn file == NULL ? BIO_new_fp(default_fp, BIO_NOCLOSE)\\r\\n: BIO_new_file(file, mode);\\r\\n}\\r\\nstatic TS_REQ *create_query(BIO *data_bio, char *digest, const EVP_MD *md,\\r\\nconst char *policy, int no_nonce, int cert)\\r\\n{\\r\\nint ret = 0;\\r\\nTS_REQ *ts_req = NULL;\\r\\nint len;\\r\\nTS_MSG_IMPRINT *msg_imprint = NULL;\\r\\nX509_ALGOR *algo = NULL;\\r\\nunsigned char *data = NULL;\\r\\nASN1_OBJECT *policy_obj = NULL;\\r\\nASN1_INTEGER *nonce_asn1 = NULL;\\r\\nif (!md && !(md = EVP_get_digestbyname(\"sha1\")))\\r\\ngoto err;\\r\\nif (!(ts_req = TS_REQ_new()))\\r\\ngoto err;\\r\\nif (!TS_REQ_set_version(ts_req, 1))\\r\\ngoto err;\\r\\nif (!(msg_imprint = TS_MSG_IMPRINT_new()))\\r\\ngoto err;\\r\\nif (!(algo = X509_ALGOR_new()))\\r\\ngoto err;\\r\\nif (!(algo->algorithm = OBJ_nid2obj(EVP_MD_type(md))))\\r\\ngoto err;\\r\\nif (!(algo->parameter = ASN1_TYPE_new()))\\r\\ngoto err;\\r\\nalgo->parameter->type = V_ASN1_NULL;\\r\\nif (!TS_MSG_IMPRINT_set_algo(msg_imprint, algo))\\r\\ngoto err;\\r\\nif ((len = create_digest(data_bio, digest, md, &data)) == 0)\\r\\ngoto err;\\r\\nif (!TS_MSG_IMPRINT_set_msg(msg_imprint, data, len))\\r\\ngoto err;\\r\\nif (!TS_REQ_set_msg_imprint(ts_req, msg_imprint))\\r\\ngoto err;\\r\\nif (policy && !(policy_obj = txt2obj(policy)))\\r\\ngoto err;\\r\\nif (policy_obj && !TS_REQ_set_policy_id(ts_req, policy_obj))\\r\\ngoto err;\\r\\nif (!no_nonce && !(nonce_asn1 = create_nonce(NONCE_LENGTH)))\\r\\ngoto err;\\r\\nif (nonce_asn1 && !TS_REQ_set_nonce(ts_req, nonce_asn1))\\r\\ngoto err;\\r\\nif (!TS_REQ_set_cert_req(ts_req, cert))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret) {\\r\\nTS_REQ_free(ts_req);\\r\\nts_req = NULL;\\r\\nBIO_printf(bio_err, \"could not create query\\n\");\\r\\n}\\r\\nTS_MSG_IMPRINT_free(msg_imprint);\\r\\nX509_ALGOR_free(algo);\\r\\nOPENSSL_free(data);\\r\\nASN1_OBJECT_free(policy_obj);\\r\\nASN1_INTEGER_free(nonce_asn1);\\r\\nreturn ts_req;\\r\\n}\\r\\nstatic int create_digest(BIO *input, char *digest, const EVP_MD *md,\\r\\nunsigned char **md_value)\\r\\n{\\r\\nint md_value_len;\\r\\nmd_value_len = EVP_MD_size(md);\\r\\nif (md_value_len < 0)\\r\\ngoto err;\\r\\nif (input) {\\r\\nEVP_MD_CTX md_ctx;\\r\\nunsigned char buffer[4096];\\r\\nint length;\\r\\n*md_value = OPENSSL_malloc(md_value_len);\\r\\nif (*md_value == 0)\\r\\ngoto err;\\r\\nEVP_DigestInit(&md_ctx, md);\\r\\nwhile ((length = BIO_read(input, buffer, sizeof(buffer))) > 0) {\\r\\nEVP_DigestUpdate(&md_ctx, buffer, length);\\r\\n}\\r\\nEVP_DigestFinal(&md_ctx, *md_value, NULL);\\r\\n} else {\\r\\nlong digest_len;\\r\\n*md_value = string_to_hex(digest, &digest_len);\\r\\nif (!*md_value || md_value_len != digest_len) {\\r\\nOPENSSL_free(*md_value);\\r\\n*md_value = NULL;\\r\\nBIO_printf(bio_err, \"bad digest, %d bytes \"\\r\\n\"must be specified\\n\", md_value_len);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nreturn md_value_len;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nstatic ASN1_INTEGER *create_nonce(int bits)\\r\\n{\\r\\nunsigned char buf[20];\\r\\nASN1_INTEGER *nonce = NULL;\\r\\nint len = (bits - 1) / 8 + 1;\\r\\nint i;\\r\\nif (len > (int)sizeof(buf))\\r\\ngoto err;\\r\\nif (RAND_bytes(buf, len) <= 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < len && !buf[i]; ++i) ;\\r\\nif (!(nonce = ASN1_INTEGER_new()))\\r\\ngoto err;\\r\\nOPENSSL_free(nonce->data);\\r\\nnonce->length = len - i;\\r\\nif (!(nonce->data = OPENSSL_malloc(nonce->length + 1)))\\r\\ngoto err;\\r\\nmemcpy(nonce->data, buf + i, nonce->length);\\r\\nreturn nonce;\\r\\nerr:\\r\\nBIO_printf(bio_err, \"could not create nonce\\n\");\\r\\nASN1_INTEGER_free(nonce);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int reply_command(CONF *conf, char *section, char *engine,\\r\\nchar *queryfile, char *passin, char *inkey,\\r\\nchar *signer, char *chain, const char *policy,\\r\\nchar *in, int token_in,\\r\\nchar *out, int token_out, int text)\\r\\n{\\r\\nint ret = 0;\\r\\nTS_RESP *response = NULL;\\r\\nBIO *in_bio = NULL;\\r\\nBIO *query_bio = NULL;\\r\\nBIO *inkey_bio = NULL;\\r\\nBIO *signer_bio = NULL;\\r\\nBIO *out_bio = NULL;\\r\\nif (in != NULL) {\\r\\nif ((in_bio = BIO_new_file(in, \"rb\")) == NULL)\\r\\ngoto end;\\r\\nif (token_in) {\\r\\nresponse = read_PKCS7(in_bio);\\r\\n} else {\\r\\nresponse = d2i_TS_RESP_bio(in_bio, NULL);\\r\\n}\\r\\n} else {\\r\\nresponse = create_response(conf, section, engine, queryfile,\\r\\npassin, inkey, signer, chain, policy);\\r\\nif (response)\\r\\nBIO_printf(bio_err, \"Response has been generated.\\n\");\\r\\nelse\\r\\nBIO_printf(bio_err, \"Response is not generated.\\n\");\\r\\n}\\r\\nif (response == NULL)\\r\\ngoto end;\\r\\nif ((out_bio = BIO_open_with_default(out, \"wb\", stdout)) == NULL)\\r\\ngoto end;\\r\\nif (text) {\\r\\nif (token_out) {\\r\\nTS_TST_INFO *tst_info = TS_RESP_get_tst_info(response);\\r\\nif (!TS_TST_INFO_print_bio(out_bio, tst_info))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!TS_RESP_print_bio(out_bio, response))\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nif (token_out) {\\r\\nPKCS7 *token = TS_RESP_get_token(response);\\r\\nif (!i2d_PKCS7_bio(out_bio, token))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!i2d_TS_RESP_bio(out_bio, response))\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nend:\\r\\nERR_print_errors(bio_err);\\r\\nBIO_free_all(in_bio);\\r\\nBIO_free_all(query_bio);\\r\\nBIO_free_all(inkey_bio);\\r\\nBIO_free_all(signer_bio);\\r\\nBIO_free_all(out_bio);\\r\\nTS_RESP_free(response);\\r\\nreturn ret;\\r\\n}\\r\\nstatic TS_RESP *read_PKCS7(BIO *in_bio)\\r\\n{\\r\\nint ret = 0;\\r\\nPKCS7 *token = NULL;\\r\\nTS_TST_INFO *tst_info = NULL;\\r\\nTS_RESP *resp = NULL;\\r\\nTS_STATUS_INFO *si = NULL;\\r\\nif (!(token = d2i_PKCS7_bio(in_bio, NULL)))\\r\\ngoto end;\\r\\nif (!(tst_info = PKCS7_to_TS_TST_INFO(token)))\\r\\ngoto end;\\r\\nif (!(resp = TS_RESP_new()))\\r\\ngoto end;\\r\\nif (!(si = TS_STATUS_INFO_new()))\\r\\ngoto end;\\r\\nif (!(ASN1_INTEGER_set(si->status, TS_STATUS_GRANTED)))\\r\\ngoto end;\\r\\nif (!TS_RESP_set_status_info(resp, si))\\r\\ngoto end;\\r\\nTS_RESP_set_tst_info(resp, token, tst_info);\\r\\ntoken = NULL;\\r\\ntst_info = NULL;\\r\\nret = 1;\\r\\nend:\\r\\nPKCS7_free(token);\\r\\nTS_TST_INFO_free(tst_info);\\r\\nif (!ret) {\\r\\nTS_RESP_free(resp);\\r\\nresp = NULL;\\r\\n}\\r\\nTS_STATUS_INFO_free(si);\\r\\nreturn resp;\\r\\n}\\r\\nstatic TS_RESP *create_response(CONF *conf, const char *section, char *engine,\\r\\nchar *queryfile, char *passin, char *inkey,\\r\\nchar *signer, char *chain, const char *policy)\\r\\n{\\r\\nint ret = 0;\\r\\nTS_RESP *response = NULL;\\r\\nBIO *query_bio = NULL;\\r\\nTS_RESP_CTX *resp_ctx = NULL;\\r\\nif (!(query_bio = BIO_new_file(queryfile, \"rb\")))\\r\\ngoto end;\\r\\nif (!(section = TS_CONF_get_tsa_section(conf, section)))\\r\\ngoto end;\\r\\nif (!(resp_ctx = TS_RESP_CTX_new()))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_serial(conf, section, serial_cb, resp_ctx))\\r\\ngoto end;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (!TS_CONF_set_crypto_device(conf, section, engine))\\r\\ngoto end;\\r\\n#endif\\r\\nif (!TS_CONF_set_signer_cert(conf, section, signer, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_certs(conf, section, chain, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_signer_key(conf, section, inkey, passin, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_def_policy(conf, section, policy, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_policies(conf, section, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_digests(conf, section, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_accuracy(conf, section, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_clock_precision_digits(conf, section, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_ordering(conf, section, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_tsa_name(conf, section, resp_ctx))\\r\\ngoto end;\\r\\nif (!TS_CONF_set_ess_cert_id_chain(conf, section, resp_ctx))\\r\\ngoto end;\\r\\nif (!(response = TS_RESP_create_response(resp_ctx, query_bio)))\\r\\ngoto end;\\r\\nret = 1;\\r\\nend:\\r\\nif (!ret) {\\r\\nTS_RESP_free(response);\\r\\nresponse = NULL;\\r\\n}\\r\\nTS_RESP_CTX_free(resp_ctx);\\r\\nBIO_free_all(query_bio);\\r\\nreturn response;\\r\\n}\\r\\nstatic ASN1_INTEGER *MS_CALLBACK serial_cb(TS_RESP_CTX *ctx, void *data)\\r\\n{\\r\\nconst char *serial_file = (const char *)data;\\r\\nASN1_INTEGER *serial = next_serial(serial_file);\\r\\nif (!serial) {\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Error during serial number \"\\r\\n\"generation.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_ADD_INFO_NOT_AVAILABLE);\\r\\n} else\\r\\nsave_ts_serial(serial_file, serial);\\r\\nreturn serial;\\r\\n}\\r\\nstatic ASN1_INTEGER *next_serial(const char *serialfile)\\r\\n{\\r\\nint ret = 0;\\r\\nBIO *in = NULL;\\r\\nASN1_INTEGER *serial = NULL;\\r\\nBIGNUM *bn = NULL;\\r\\nif (!(serial = ASN1_INTEGER_new()))\\r\\ngoto err;\\r\\nif (!(in = BIO_new_file(serialfile, \"r\"))) {\\r\\nERR_clear_error();\\r\\nBIO_printf(bio_err, \"Warning: could not open file %s for \"\\r\\n\"reading, using serial number: 1\\n\", serialfile);\\r\\nif (!ASN1_INTEGER_set(serial, 1))\\r\\ngoto err;\\r\\n} else {\\r\\nchar buf[1024];\\r\\nif (!a2i_ASN1_INTEGER(in, serial, buf, sizeof(buf))) {\\r\\nBIO_printf(bio_err, \"unable to load number from %s\\n\",\\r\\nserialfile);\\r\\ngoto err;\\r\\n}\\r\\nif (!(bn = ASN1_INTEGER_to_BN(serial, NULL)))\\r\\ngoto err;\\r\\nASN1_INTEGER_free(serial);\\r\\nserial = NULL;\\r\\nif (!BN_add_word(bn, 1))\\r\\ngoto err;\\r\\nif (!(serial = BN_to_ASN1_INTEGER(bn, NULL)))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret) {\\r\\nASN1_INTEGER_free(serial);\\r\\nserial = NULL;\\r\\n}\\r\\nBIO_free_all(in);\\r\\nBN_free(bn);\\r\\nreturn serial;\\r\\n}\\r\\nstatic int save_ts_serial(const char *serialfile, ASN1_INTEGER *serial)\\r\\n{\\r\\nint ret = 0;\\r\\nBIO *out = NULL;\\r\\nif (!(out = BIO_new_file(serialfile, \"w\")))\\r\\ngoto err;\\r\\nif (i2a_ASN1_INTEGER(out, serial) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(out, \"\\n\") <= 0)\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret)\\r\\nBIO_printf(bio_err, \"could not save serial number to %s\\n\",\\r\\nserialfile);\\r\\nBIO_free_all(out);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int verify_command(char *data, char *digest, char *queryfile,\\r\\nchar *in, int token_in,\\r\\nchar *ca_path, char *ca_file, char *untrusted)\\r\\n{\\r\\nBIO *in_bio = NULL;\\r\\nPKCS7 *token = NULL;\\r\\nTS_RESP *response = NULL;\\r\\nTS_VERIFY_CTX *verify_ctx = NULL;\\r\\nint ret = 0;\\r\\nif (!(in_bio = BIO_new_file(in, \"rb\")))\\r\\ngoto end;\\r\\nif (token_in) {\\r\\nif (!(token = d2i_PKCS7_bio(in_bio, NULL)))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!(response = d2i_TS_RESP_bio(in_bio, NULL)))\\r\\ngoto end;\\r\\n}\\r\\nif (!(verify_ctx = create_verify_ctx(data, digest, queryfile,\\r\\nca_path, ca_file, untrusted)))\\r\\ngoto end;\\r\\nret = token_in ?\\r\\nTS_RESP_verify_token(verify_ctx, token) :\\r\\nTS_RESP_verify_response(verify_ctx, response);\\r\\nend:\\r\\nprintf(\"Verification: \");\\r\\nif (ret)\\r\\nprintf(\"OK\\n\");\\r\\nelse {\\r\\nprintf(\"FAILED\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nBIO_free_all(in_bio);\\r\\nPKCS7_free(token);\\r\\nTS_RESP_free(response);\\r\\nTS_VERIFY_CTX_free(verify_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic TS_VERIFY_CTX *create_verify_ctx(char *data, char *digest,\\r\\nchar *queryfile,\\r\\nchar *ca_path, char *ca_file,\\r\\nchar *untrusted)\\r\\n{\\r\\nTS_VERIFY_CTX *ctx = NULL;\\r\\nBIO *input = NULL;\\r\\nTS_REQ *request = NULL;\\r\\nint ret = 0;\\r\\nif (data != NULL || digest != NULL) {\\r\\nif (!(ctx = TS_VERIFY_CTX_new()))\\r\\ngoto err;\\r\\nctx->flags = TS_VFY_VERSION | TS_VFY_SIGNER;\\r\\nif (data != NULL) {\\r\\nctx->flags |= TS_VFY_DATA;\\r\\nif (!(ctx->data = BIO_new_file(data, \"rb\")))\\r\\ngoto err;\\r\\n} else if (digest != NULL) {\\r\\nlong imprint_len;\\r\\nctx->flags |= TS_VFY_IMPRINT;\\r\\nif (!(ctx->imprint = string_to_hex(digest, &imprint_len))) {\\r\\nBIO_printf(bio_err, \"invalid digest string\\n\");\\r\\ngoto err;\\r\\n}\\r\\nctx->imprint_len = imprint_len;\\r\\n}\\r\\n} else if (queryfile != NULL) {\\r\\nif (!(input = BIO_new_file(queryfile, \"rb\")))\\r\\ngoto err;\\r\\nif (!(request = d2i_TS_REQ_bio(input, NULL)))\\r\\ngoto err;\\r\\nif (!(ctx = TS_REQ_to_TS_VERIFY_CTX(request, NULL)))\\r\\ngoto err;\\r\\n} else\\r\\nreturn NULL;\\r\\nctx->flags |= TS_VFY_SIGNATURE;\\r\\nif (!(ctx->store = create_cert_store(ca_path, ca_file)))\\r\\ngoto err;\\r\\nif (untrusted && !(ctx->certs = TS_CONF_load_certs(untrusted)))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret) {\\r\\nTS_VERIFY_CTX_free(ctx);\\r\\nctx = NULL;\\r\\n}\\r\\nBIO_free_all(input);\\r\\nTS_REQ_free(request);\\r\\nreturn ctx;\\r\\n}\\r\\nstatic X509_STORE *create_cert_store(char *ca_path, char *ca_file)\\r\\n{\\r\\nX509_STORE *cert_ctx = NULL;\\r\\nX509_LOOKUP *lookup = NULL;\\r\\nint i;\\r\\ncert_ctx = X509_STORE_new();\\r\\nX509_STORE_set_verify_cb(cert_ctx, verify_cb);\\r\\nif (ca_path) {\\r\\nlookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL) {\\r\\nBIO_printf(bio_err, \"memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\ni = X509_LOOKUP_add_dir(lookup, ca_path, X509_FILETYPE_PEM);\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"Error loading directory %s\\n\", ca_path);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (ca_file) {\\r\\nlookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_file());\\r\\nif (lookup == NULL) {\\r\\nBIO_printf(bio_err, \"memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\ni = X509_LOOKUP_load_file(lookup, ca_file, X509_FILETYPE_PEM);\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"Error loading file %s\\n\", ca_file);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nreturn cert_ctx;\\r\\nerr:\\r\\nX509_STORE_free(cert_ctx);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int MS_CALLBACK verify_cb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ok;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_conf_api_c", "target": 0, "func": "int _CONF_add_string(CONF *conf, CONF_VALUE *section, CONF_VALUE *value)\\r\\n{\\r\\nCONF_VALUE *v = NULL;\\r\\nSTACK_OF(CONF_VALUE) *ts;\\r\\nts = (STACK_OF(CONF_VALUE) *)section->value;\\r\\nvalue->section = section->section;\\r\\nif (!sk_CONF_VALUE_push(ts, value)) {\\r\\nreturn 0;\\r\\n}\\r\\nv = lh_CONF_VALUE_insert(conf->data, value);\\r\\nif (v != NULL) {\\r\\n(void)sk_CONF_VALUE_delete_ptr(ts, v);\\r\\nOPENSSL_free(v->name);\\r\\nOPENSSL_free(v->value);\\r\\nOPENSSL_free(v);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nchar *_CONF_get_string(const CONF *conf, const char *section,\\r\\nconst char *name)\\r\\n{\\r\\nCONF_VALUE *v, vv;\\r\\nchar *p;\\r\\nif (name == NULL)\\r\\nreturn (NULL);\\r\\nif (conf != NULL) {\\r\\nif (section != NULL) {\\r\\nvv.name = (char *)name;\\r\\nvv.section = (char *)section;\\r\\nv = lh_CONF_VALUE_retrieve(conf->data, &vv);\\r\\nif (v != NULL)\\r\\nreturn (v->value);\\r\\nif (strcmp(section, \"ENV\") == 0) {\\r\\np = getenv(name);\\r\\nif (p != NULL)\\r\\nreturn (p);\\r\\n}\\r\\n}\\r\\nvv.section = \"default\";\\r\\nvv.name = (char *)name;\\r\\nv = lh_CONF_VALUE_retrieve(conf->data, &vv);\\r\\nif (v != NULL)\\r\\nreturn (v->value);\\r\\nelse\\r\\nreturn (NULL);\\r\\n} else\\r\\nreturn (getenv(name));\\r\\n}\\r\\nstatic unsigned long conf_value_hash(const CONF_VALUE *v)\\r\\n{\\r\\nreturn (lh_strhash(v->section) << 2) ^ lh_strhash(v->name);\\r\\n}\\r\\nint _CONF_new_data(CONF *conf)\\r\\n{\\r\\nif (conf == NULL) {\\r\\nreturn 0;\\r\\n}\\r\\nif (conf->data == NULL)\\r\\nif ((conf->data = lh_CONF_VALUE_new()) == NULL) {\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid _CONF_free_data(CONF *conf)\\r\\n{\\r\\nif (conf == NULL || conf->data == NULL)\\r\\nreturn;\\r\\nlh_CONF_VALUE_down_load(conf->data) = 0;\\r\\nlh_CONF_VALUE_doall_arg(conf->data,\\r\\nLHASH_DOALL_ARG_FN(value_free_hash),\\r\\nLHASH_OF(CONF_VALUE), conf->data);\\r\\nlh_CONF_VALUE_doall(conf->data, LHASH_DOALL_FN(value_free_stack));\\r\\nlh_CONF_VALUE_free(conf->data);\\r\\n}\\r\\nstatic void value_free_stack_doall(CONF_VALUE *a)\\r\\n{\\r\\nCONF_VALUE *vv;\\r\\nSTACK_OF(CONF_VALUE) *sk;\\r\\nint i;\\r\\nif (a->name != NULL)\\r\\nreturn;\\r\\nsk = (STACK_OF(CONF_VALUE) *)a->value;\\r\\nfor (i = sk_CONF_VALUE_num(sk) - 1; i >= 0; i--) {\\r\\nvv = sk_CONF_VALUE_value(sk, i);\\r\\nOPENSSL_free(vv->value);\\r\\nOPENSSL_free(vv->name);\\r\\nOPENSSL_free(vv);\\r\\n}\\r\\nif (sk != NULL)\\r\\nsk_CONF_VALUE_free(sk);\\r\\nOPENSSL_free(a->section);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nCONF_VALUE *_CONF_new_section(CONF *conf, const char *section)\\r\\n{\\r\\nSTACK_OF(CONF_VALUE) *sk = NULL;\\r\\nint ok = 0, i;\\r\\nCONF_VALUE *v = NULL, *vv;\\r\\nif ((sk = sk_CONF_VALUE_new_null()) == NULL)\\r\\ngoto err;\\r\\nif ((v = OPENSSL_malloc(sizeof(CONF_VALUE))) == NULL)\\r\\ngoto err;\\r\\ni = strlen(section) + 1;\\r\\nif ((v->section = OPENSSL_malloc(i)) == NULL)\\r\\ngoto err;\\r\\nmemcpy(v->section, section, i);\\r\\nv->name = NULL;\\r\\nv->value = (char *)sk;\\r\\nvv = lh_CONF_VALUE_insert(conf->data, v);\\r\\nOPENSSL_assert(vv == NULL);\\r\\nok = 1;\\r\\nerr:\\r\\nif (!ok) {\\r\\nif (sk != NULL)\\r\\nsk_CONF_VALUE_free(sk);\\r\\nif (v != NULL)\\r\\nOPENSSL_free(v);\\r\\nv = NULL;\\r\\n}\\r\\nreturn (v);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_mont_c", "target": 0, "func": "int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\\r\\nBN_MONT_CTX *mont, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *tmp;\\r\\nint ret = 0;\\r\\n#if defined(OPENSSL_BN_ASM_MONT) && defined(MONT_WORD)\\r\\nint num = mont->N.top;\\r\\nif (num > 1 && a->top == num && b->top == num) {\\r\\nif (bn_wexpand(r, num) == NULL)\\r\\nreturn (0);\\r\\nif (bn_mul_mont(r->d, a->d, b->d, mont->N.d, mont->n0, num)) {\\r\\nr->neg = a->neg ^ b->neg;\\r\\nr->top = num;\\r\\nbn_correct_top(r);\\r\\nreturn (1);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nBN_CTX_start(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nif (tmp == NULL)\\r\\ngoto err;\\r\\nbn_check_top(tmp);\\r\\nif (a == b) {\\r\\nif (!BN_sqr(tmp, a, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mul(tmp, a, b, ctx))\\r\\ngoto err;\\r\\n}\\r\\n#ifdef MONT_WORD\\r\\nif (!BN_from_montgomery_word(r, tmp, mont))\\r\\ngoto err;\\r\\n#else\\r\\nif (!BN_from_montgomery(r, tmp, mont, ctx))\\r\\ngoto err;\\r\\n#endif\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int BN_from_montgomery_word(BIGNUM *ret, BIGNUM *r, BN_MONT_CTX *mont)\\r\\n{\\r\\nBIGNUM *n;\\r\\nBN_ULONG *ap, *np, *rp, n0, v, carry;\\r\\nint nl, max, i;\\r\\nn = &(mont->N);\\r\\nnl = n->top;\\r\\nif (nl == 0) {\\r\\nret->top = 0;\\r\\nreturn (1);\\r\\n}\\r\\nmax = (2 * nl);\\r\\nif (bn_wexpand(r, max) == NULL)\\r\\nreturn (0);\\r\\nr->neg ^= n->neg;\\r\\nnp = n->d;\\r\\nrp = r->d;\\r\\n# if 1\\r\\nfor (i = r->top; i < max; i++)\\r\\nrp[i] = 0;\\r\\n# else\\r\\nmemset(&(rp[r->top]), 0, (max - r->top) * sizeof(BN_ULONG));\\r\\n# endif\\r\\nr->top = max;\\r\\nn0 = mont->n0[0];\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \"word BN_from_montgomery_word %d * %d\\n\", nl, nl);\\r\\n# endif\\r\\nfor (carry = 0, i = 0; i < nl; i++, rp++) {\\r\\n# ifdef __TANDEM\\r\\n{\\r\\nlong long t1;\\r\\nlong long t2;\\r\\nlong long t3;\\r\\nt1 = rp[0] * (n0 & 0177777);\\r\\nt2 = 037777600000l;\\r\\nt2 = n0 & t2;\\r\\nt3 = rp[0] & 0177777;\\r\\nt2 = (t3 * t2) & BN_MASK2;\\r\\nt1 = t1 + t2;\\r\\nv = bn_mul_add_words(rp, np, nl, (BN_ULONG)t1);\\r\\n}\\r\\n# else\\r\\nv = bn_mul_add_words(rp, np, nl, (rp[0] * n0) & BN_MASK2);\\r\\n# endif\\r\\nv = (v + carry + rp[nl]) & BN_MASK2;\\r\\ncarry |= (v != rp[nl]);\\r\\ncarry &= (v <= rp[nl]);\\r\\nrp[nl] = v;\\r\\n}\\r\\nif (bn_wexpand(ret, nl) == NULL)\\r\\nreturn (0);\\r\\nret->top = nl;\\r\\nret->neg = r->neg;\\r\\nrp = ret->d;\\r\\nap = &(r->d[nl]);\\r\\n# define BRANCH_FREE 1\\r\\n# if BRANCH_FREE\\r\\n{\\r\\nBN_ULONG *nrp;\\r\\nsize_t m;\\r\\nv = bn_sub_words(rp, ap, np, nl) - carry;\\r\\nm = (0 - (size_t)v);\\r\\nnrp =\\r\\n(BN_ULONG *)(((PTR_SIZE_INT) rp & ~m) | ((PTR_SIZE_INT) ap & m));\\r\\nfor (i = 0, nl -= 4; i < nl; i += 4) {\\r\\nBN_ULONG t1, t2, t3, t4;\\r\\nt1 = nrp[i + 0];\\r\\nt2 = nrp[i + 1];\\r\\nt3 = nrp[i + 2];\\r\\nap[i + 0] = 0;\\r\\nt4 = nrp[i + 3];\\r\\nap[i + 1] = 0;\\r\\nrp[i + 0] = t1;\\r\\nap[i + 2] = 0;\\r\\nrp[i + 1] = t2;\\r\\nap[i + 3] = 0;\\r\\nrp[i + 2] = t3;\\r\\nrp[i + 3] = t4;\\r\\n}\\r\\nfor (nl += 4; i < nl; i++)\\r\\nrp[i] = nrp[i], ap[i] = 0;\\r\\n}\\r\\n# else\\r\\nif (bn_sub_words(rp, ap, np, nl) - carry)\\r\\nmemcpy(rp, ap, nl * sizeof(BN_ULONG));\\r\\n# endif\\r\\nbn_correct_top(r);\\r\\nbn_correct_top(ret);\\r\\nbn_check_top(ret);\\r\\nreturn (1);\\r\\n}\\r\\nint BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint retn = 0;\\r\\n#ifdef MONT_WORD\\r\\nBIGNUM *t;\\r\\nBN_CTX_start(ctx);\\r\\nif ((t = BN_CTX_get(ctx)) && BN_copy(t, a))\\r\\nretn = BN_from_montgomery_word(ret, t, mont);\\r\\nBN_CTX_end(ctx);\\r\\n#else\\r\\nBIGNUM *t1, *t2;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nt2 = BN_CTX_get(ctx);\\r\\nif (t1 == NULL || t2 == NULL)\\r\\ngoto err;\\r\\nif (!BN_copy(t1, a))\\r\\ngoto err;\\r\\nBN_mask_bits(t1, mont->ri);\\r\\nif (!BN_mul(t2, t1, &mont->Ni, ctx))\\r\\ngoto err;\\r\\nBN_mask_bits(t2, mont->ri);\\r\\nif (!BN_mul(t1, t2, &mont->N, ctx))\\r\\ngoto err;\\r\\nif (!BN_add(t2, a, t1))\\r\\ngoto err;\\r\\nif (!BN_rshift(ret, t2, mont->ri))\\r\\ngoto err;\\r\\nif (BN_ucmp(ret, &(mont->N)) >= 0) {\\r\\nif (!BN_usub(ret, ret, &(mont->N)))\\r\\ngoto err;\\r\\n}\\r\\nretn = 1;\\r\\nbn_check_top(ret);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\n#endif\\r\\nreturn (retn);\\r\\n}\\r\\nBN_MONT_CTX *BN_MONT_CTX_new(void)\\r\\n{\\r\\nBN_MONT_CTX *ret;\\r\\nif ((ret = (BN_MONT_CTX *)OPENSSL_malloc(sizeof(BN_MONT_CTX))) == NULL)\\r\\nreturn (NULL);\\r\\nBN_MONT_CTX_init(ret);\\r\\nret->flags = BN_FLG_MALLOCED;\\r\\nreturn (ret);\\r\\n}\\r\\nvoid BN_MONT_CTX_init(BN_MONT_CTX *ctx)\\r\\n{\\r\\nctx->ri = 0;\\r\\nBN_init(&(ctx->RR));\\r\\nBN_init(&(ctx->N));\\r\\nBN_init(&(ctx->Ni));\\r\\nctx->n0[0] = ctx->n0[1] = 0;\\r\\nctx->flags = 0;\\r\\n}\\r\\nvoid BN_MONT_CTX_free(BN_MONT_CTX *mont)\\r\\n{\\r\\nif (mont == NULL)\\r\\nreturn;\\r\\nBN_free(&(mont->RR));\\r\\nBN_free(&(mont->N));\\r\\nBN_free(&(mont->Ni));\\r\\nif (mont->flags & BN_FLG_MALLOCED)\\r\\nOPENSSL_free(mont);\\r\\n}\\r\\nint BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *Ri, *R;\\r\\nBN_CTX_start(ctx);\\r\\nif ((Ri = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nR = &(mont->RR);\\r\\nif (!BN_copy(&(mont->N), mod))\\r\\ngoto err;\\r\\nmont->N.neg = 0;\\r\\n#ifdef MONT_WORD\\r\\n{\\r\\nBIGNUM tmod;\\r\\nBN_ULONG buf[2];\\r\\nBN_init(&tmod);\\r\\ntmod.d = buf;\\r\\ntmod.dmax = 2;\\r\\ntmod.neg = 0;\\r\\nmont->ri = (BN_num_bits(mod) + (BN_BITS2 - 1)) / BN_BITS2 * BN_BITS2;\\r\\n# if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)\\r\\nBN_zero(R);\\r\\nif (!(BN_set_bit(R, 2 * BN_BITS2)))\\r\\ngoto err;\\r\\ntmod.top = 0;\\r\\nif ((buf[0] = mod->d[0]))\\r\\ntmod.top = 1;\\r\\nif ((buf[1] = mod->top > 1 ? mod->d[1] : 0))\\r\\ntmod.top = 2;\\r\\nif ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_lshift(Ri, Ri, 2 * BN_BITS2))\\r\\ngoto err;\\r\\nif (!BN_is_zero(Ri)) {\\r\\nif (!BN_sub_word(Ri, 1))\\r\\ngoto err;\\r\\n} else {\\r\\nif (bn_expand(Ri, (int)sizeof(BN_ULONG) * 2) == NULL)\\r\\ngoto err;\\r\\nRi->neg = 0;\\r\\nRi->d[0] = BN_MASK2;\\r\\nRi->d[1] = BN_MASK2;\\r\\nRi->top = 2;\\r\\n}\\r\\nif (!BN_div(Ri, NULL, Ri, &tmod, ctx))\\r\\ngoto err;\\r\\nmont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;\\r\\nmont->n0[1] = (Ri->top > 1) ? Ri->d[1] : 0;\\r\\n# else\\r\\nBN_zero(R);\\r\\nif (!(BN_set_bit(R, BN_BITS2)))\\r\\ngoto err;\\r\\nbuf[0] = mod->d[0];\\r\\nbuf[1] = 0;\\r\\ntmod.top = buf[0] != 0 ? 1 : 0;\\r\\nif ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_lshift(Ri, Ri, BN_BITS2))\\r\\ngoto err;\\r\\nif (!BN_is_zero(Ri)) {\\r\\nif (!BN_sub_word(Ri, 1))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_set_word(Ri, BN_MASK2))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_div(Ri, NULL, Ri, &tmod, ctx))\\r\\ngoto err;\\r\\nmont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;\\r\\nmont->n0[1] = 0;\\r\\n# endif\\r\\n}\\r\\n#else\\r\\n{\\r\\nmont->ri = BN_num_bits(&mont->N);\\r\\nBN_zero(R);\\r\\nif (!BN_set_bit(R, mont->ri))\\r\\ngoto err;\\r\\nif ((BN_mod_inverse(Ri, R, &mont->N, ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_lshift(Ri, Ri, mont->ri))\\r\\ngoto err;\\r\\nif (!BN_sub_word(Ri, 1))\\r\\ngoto err;\\r\\nif (!BN_div(&(mont->Ni), NULL, Ri, &mont->N, ctx))\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\nBN_zero(&(mont->RR));\\r\\nif (!BN_set_bit(&(mont->RR), mont->ri * 2))\\r\\ngoto err;\\r\\nif (!BN_mod(&(mont->RR), &(mont->RR), &(mont->N), ctx))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nBN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from)\\r\\n{\\r\\nif (to == from)\\r\\nreturn (to);\\r\\nif (!BN_copy(&(to->RR), &(from->RR)))\\r\\nreturn NULL;\\r\\nif (!BN_copy(&(to->N), &(from->N)))\\r\\nreturn NULL;\\r\\nif (!BN_copy(&(to->Ni), &(from->Ni)))\\r\\nreturn NULL;\\r\\nto->ri = from->ri;\\r\\nto->n0[0] = from->n0[0];\\r\\nto->n0[1] = from->n0[1];\\r\\nreturn (to);\\r\\n}\\r\\nBN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock,\\r\\nconst BIGNUM *mod, BN_CTX *ctx)\\r\\n{\\r\\nBN_MONT_CTX *ret;\\r\\nCRYPTO_r_lock(lock);\\r\\nret = *pmont;\\r\\nCRYPTO_r_unlock(lock);\\r\\nif (ret)\\r\\nreturn ret;\\r\\nret = BN_MONT_CTX_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!BN_MONT_CTX_set(ret, mod, ctx)) {\\r\\nBN_MONT_CTX_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nCRYPTO_w_lock(lock);\\r\\nif (*pmont) {\\r\\nBN_MONT_CTX_free(ret);\\r\\nret = *pmont;\\r\\n} else\\r\\n*pmont = ret;\\r\\nCRYPTO_w_unlock(lock);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_rsp_sign_c", "target": 0, "func": "static ASN1_INTEGER *def_serial_cb(struct TS_resp_ctx *ctx, void *data)\\r\\n{\\r\\nASN1_INTEGER *serial = ASN1_INTEGER_new();\\r\\nif (!serial)\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(serial, 1))\\r\\ngoto err;\\r\\nreturn serial;\\r\\nerr:\\r\\nTSerr(TS_F_DEF_SERIAL_CB, ERR_R_MALLOC_FAILURE);\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Error during serial number generation.\");\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int def_time_cb(struct TS_resp_ctx *ctx, void *data,\\r\\nlong *sec, long *usec)\\r\\n{\\r\\nstruct timeval tv;\\r\\nif (gettimeofday(&tv, NULL) != 0) {\\r\\nTSerr(TS_F_DEF_TIME_CB, TS_R_TIME_SYSCALL_ERROR);\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Time is not available.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);\\r\\nreturn 0;\\r\\n}\\r\\n*sec = tv.tv_sec;\\r\\n*usec = tv.tv_usec;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int def_time_cb(struct TS_resp_ctx *ctx, void *data,\\r\\nlong *sec, long *usec)\\r\\n{\\r\\ntime_t t;\\r\\nif (time(&t) == (time_t)-1) {\\r\\nTSerr(TS_F_DEF_TIME_CB, TS_R_TIME_SYSCALL_ERROR);\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Time is not available.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);\\r\\nreturn 0;\\r\\n}\\r\\n*sec = (long)t;\\r\\n*usec = 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int def_extension_cb(struct TS_resp_ctx *ctx, X509_EXTENSION *ext,\\r\\nvoid *data)\\r\\n{\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Unsupported extension.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_UNACCEPTED_EXTENSION);\\r\\nreturn 0;\\r\\n}\\r\\nTS_RESP_CTX *TS_RESP_CTX_new()\\r\\n{\\r\\nTS_RESP_CTX *ctx;\\r\\nif (!(ctx = (TS_RESP_CTX *)OPENSSL_malloc(sizeof(TS_RESP_CTX)))) {\\r\\nTSerr(TS_F_TS_RESP_CTX_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(ctx, 0, sizeof(TS_RESP_CTX));\\r\\nctx->serial_cb = def_serial_cb;\\r\\nctx->time_cb = def_time_cb;\\r\\nctx->extension_cb = def_extension_cb;\\r\\nreturn ctx;\\r\\n}\\r\\nvoid TS_RESP_CTX_free(TS_RESP_CTX *ctx)\\r\\n{\\r\\nif (!ctx)\\r\\nreturn;\\r\\nX509_free(ctx->signer_cert);\\r\\nEVP_PKEY_free(ctx->signer_key);\\r\\nsk_X509_pop_free(ctx->certs, X509_free);\\r\\nsk_ASN1_OBJECT_pop_free(ctx->policies, ASN1_OBJECT_free);\\r\\nASN1_OBJECT_free(ctx->default_policy);\\r\\nsk_EVP_MD_free(ctx->mds);\\r\\nASN1_INTEGER_free(ctx->seconds);\\r\\nASN1_INTEGER_free(ctx->millis);\\r\\nASN1_INTEGER_free(ctx->micros);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nint TS_RESP_CTX_set_signer_cert(TS_RESP_CTX *ctx, X509 *signer)\\r\\n{\\r\\nif (X509_check_purpose(signer, X509_PURPOSE_TIMESTAMP_SIGN, 0) != 1) {\\r\\nTSerr(TS_F_TS_RESP_CTX_SET_SIGNER_CERT,\\r\\nTS_R_INVALID_SIGNER_CERTIFICATE_PURPOSE);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx->signer_cert)\\r\\nX509_free(ctx->signer_cert);\\r\\nctx->signer_cert = signer;\\r\\nCRYPTO_add(&ctx->signer_cert->references, +1, CRYPTO_LOCK_X509);\\r\\nreturn 1;\\r\\n}\\r\\nint TS_RESP_CTX_set_signer_key(TS_RESP_CTX *ctx, EVP_PKEY *key)\\r\\n{\\r\\nif (ctx->signer_key)\\r\\nEVP_PKEY_free(ctx->signer_key);\\r\\nctx->signer_key = key;\\r\\nCRYPTO_add(&ctx->signer_key->references, +1, CRYPTO_LOCK_EVP_PKEY);\\r\\nreturn 1;\\r\\n}\\r\\nint TS_RESP_CTX_set_def_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *def_policy)\\r\\n{\\r\\nif (ctx->default_policy)\\r\\nASN1_OBJECT_free(ctx->default_policy);\\r\\nif (!(ctx->default_policy = OBJ_dup(def_policy)))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nTSerr(TS_F_TS_RESP_CTX_SET_DEF_POLICY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nint TS_RESP_CTX_add_policy(TS_RESP_CTX *ctx, ASN1_OBJECT *policy)\\r\\n{\\r\\nASN1_OBJECT *copy = NULL;\\r\\nif (!ctx->policies && !(ctx->policies = sk_ASN1_OBJECT_new_null()))\\r\\ngoto err;\\r\\nif (!(copy = OBJ_dup(policy)))\\r\\ngoto err;\\r\\nif (!sk_ASN1_OBJECT_push(ctx->policies, copy))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nTSerr(TS_F_TS_RESP_CTX_ADD_POLICY, ERR_R_MALLOC_FAILURE);\\r\\nASN1_OBJECT_free(copy);\\r\\nreturn 0;\\r\\n}\\r\\nint TS_RESP_CTX_add_md(TS_RESP_CTX *ctx, const EVP_MD *md)\\r\\n{\\r\\nif (!ctx->mds && !(ctx->mds = sk_EVP_MD_new_null()))\\r\\ngoto err;\\r\\nif (!sk_EVP_MD_push(ctx->mds, (EVP_MD *)md))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nTSerr(TS_F_TS_RESP_CTX_ADD_MD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nint TS_RESP_CTX_set_accuracy(TS_RESP_CTX *ctx,\\r\\nint secs, int millis, int micros)\\r\\n{\\r\\nTS_RESP_CTX_accuracy_free(ctx);\\r\\nif (secs && (!(ctx->seconds = ASN1_INTEGER_new())\\r\\n|| !ASN1_INTEGER_set(ctx->seconds, secs)))\\r\\ngoto err;\\r\\nif (millis && (!(ctx->millis = ASN1_INTEGER_new())\\r\\n|| !ASN1_INTEGER_set(ctx->millis, millis)))\\r\\ngoto err;\\r\\nif (micros && (!(ctx->micros = ASN1_INTEGER_new())\\r\\n|| !ASN1_INTEGER_set(ctx->micros, micros)))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nTS_RESP_CTX_accuracy_free(ctx);\\r\\nTSerr(TS_F_TS_RESP_CTX_SET_ACCURACY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nvoid TS_RESP_CTX_add_flags(TS_RESP_CTX *ctx, int flags)\\r\\n{\\r\\nctx->flags |= flags;\\r\\n}\\r\\nvoid TS_RESP_CTX_set_serial_cb(TS_RESP_CTX *ctx, TS_serial_cb cb, void *data)\\r\\n{\\r\\nctx->serial_cb = cb;\\r\\nctx->serial_cb_data = data;\\r\\n}\\r\\nvoid TS_RESP_CTX_set_time_cb(TS_RESP_CTX *ctx, TS_time_cb cb, void *data)\\r\\n{\\r\\nctx->time_cb = cb;\\r\\nctx->time_cb_data = data;\\r\\n}\\r\\nvoid TS_RESP_CTX_set_extension_cb(TS_RESP_CTX *ctx,\\r\\nTS_extension_cb cb, void *data)\\r\\n{\\r\\nctx->extension_cb = cb;\\r\\nctx->extension_cb_data = data;\\r\\n}\\r\\nint TS_RESP_CTX_set_status_info(TS_RESP_CTX *ctx,\\r\\nint status, const char *text)\\r\\n{\\r\\nTS_STATUS_INFO *si = NULL;\\r\\nASN1_UTF8STRING *utf8_text = NULL;\\r\\nint ret = 0;\\r\\nif (!(si = TS_STATUS_INFO_new()))\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(si->status, status))\\r\\ngoto err;\\r\\nif (text) {\\r\\nif (!(utf8_text = ASN1_UTF8STRING_new())\\r\\n|| !ASN1_STRING_set(utf8_text, text, strlen(text)))\\r\\ngoto err;\\r\\nif (!si->text && !(si->text = sk_ASN1_UTF8STRING_new_null()))\\r\\ngoto err;\\r\\nif (!sk_ASN1_UTF8STRING_push(si->text, utf8_text))\\r\\ngoto err;\\r\\nutf8_text = NULL;\\r\\n}\\r\\nif (!TS_RESP_set_status_info(ctx->response, si))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret)\\r\\nTSerr(TS_F_TS_RESP_CTX_SET_STATUS_INFO, ERR_R_MALLOC_FAILURE);\\r\\nTS_STATUS_INFO_free(si);\\r\\nASN1_UTF8STRING_free(utf8_text);\\r\\nreturn ret;\\r\\n}\\r\\nint TS_RESP_CTX_set_status_info_cond(TS_RESP_CTX *ctx,\\r\\nint status, const char *text)\\r\\n{\\r\\nint ret = 1;\\r\\nTS_STATUS_INFO *si = TS_RESP_get_status_info(ctx->response);\\r\\nif (ASN1_INTEGER_get(si->status) == TS_STATUS_GRANTED) {\\r\\nret = TS_RESP_CTX_set_status_info(ctx, status, text);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint TS_RESP_CTX_add_failure_info(TS_RESP_CTX *ctx, int failure)\\r\\n{\\r\\nTS_STATUS_INFO *si = TS_RESP_get_status_info(ctx->response);\\r\\nif (!si->failure_info && !(si->failure_info = ASN1_BIT_STRING_new()))\\r\\ngoto err;\\r\\nif (!ASN1_BIT_STRING_set_bit(si->failure_info, failure, 1))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nTSerr(TS_F_TS_RESP_CTX_ADD_FAILURE_INFO, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nTS_REQ *TS_RESP_CTX_get_request(TS_RESP_CTX *ctx)\\r\\n{\\r\\nreturn ctx->request;\\r\\n}\\r\\nTS_TST_INFO *TS_RESP_CTX_get_tst_info(TS_RESP_CTX *ctx)\\r\\n{\\r\\nreturn ctx->tst_info;\\r\\n}\\r\\nint TS_RESP_CTX_set_clock_precision_digits(TS_RESP_CTX *ctx,\\r\\nunsigned precision)\\r\\n{\\r\\nif (precision > TS_MAX_CLOCK_PRECISION_DIGITS)\\r\\nreturn 0;\\r\\nctx->clock_precision_digits = precision;\\r\\nreturn 1;\\r\\n}\\r\\nTS_RESP *TS_RESP_create_response(TS_RESP_CTX *ctx, BIO *req_bio)\\r\\n{\\r\\nASN1_OBJECT *policy;\\r\\nTS_RESP *response;\\r\\nint result = 0;\\r\\nTS_RESP_CTX_init(ctx);\\r\\nif (!(ctx->response = TS_RESP_new())) {\\r\\nTSerr(TS_F_TS_RESP_CREATE_RESPONSE, ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nif (!(ctx->request = d2i_TS_REQ_bio(req_bio, NULL))) {\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Bad request format or \" \"system error.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_DATA_FORMAT);\\r\\ngoto end;\\r\\n}\\r\\nif (!TS_RESP_CTX_set_status_info(ctx, TS_STATUS_GRANTED, NULL))\\r\\ngoto end;\\r\\nif (!TS_RESP_check_request(ctx))\\r\\ngoto end;\\r\\nif (!(policy = TS_RESP_get_policy(ctx)))\\r\\ngoto end;\\r\\nif (!(ctx->tst_info = TS_RESP_create_tst_info(ctx, policy)))\\r\\ngoto end;\\r\\nif (!TS_RESP_process_extensions(ctx))\\r\\ngoto end;\\r\\nif (!TS_RESP_sign(ctx))\\r\\ngoto end;\\r\\nresult = 1;\\r\\nend:\\r\\nif (!result) {\\r\\nTSerr(TS_F_TS_RESP_CREATE_RESPONSE, TS_R_RESPONSE_SETUP_ERROR);\\r\\nif (ctx->response != NULL) {\\r\\nif (TS_RESP_CTX_set_status_info_cond(ctx,\\r\\nTS_STATUS_REJECTION,\\r\\n\"Error during response \"\\r\\n\"generation.\") == 0) {\\r\\nTS_RESP_free(ctx->response);\\r\\nctx->response = NULL;\\r\\n}\\r\\n}\\r\\n}\\r\\nresponse = ctx->response;\\r\\nctx->response = NULL;\\r\\nTS_RESP_CTX_cleanup(ctx);\\r\\nreturn response;\\r\\n}\\r\\nstatic void TS_RESP_CTX_init(TS_RESP_CTX *ctx)\\r\\n{\\r\\nctx->request = NULL;\\r\\nctx->response = NULL;\\r\\nctx->tst_info = NULL;\\r\\n}\\r\\nstatic void TS_RESP_CTX_cleanup(TS_RESP_CTX *ctx)\\r\\n{\\r\\nTS_REQ_free(ctx->request);\\r\\nctx->request = NULL;\\r\\nTS_RESP_free(ctx->response);\\r\\nctx->response = NULL;\\r\\nTS_TST_INFO_free(ctx->tst_info);\\r\\nctx->tst_info = NULL;\\r\\n}\\r\\nstatic int TS_RESP_check_request(TS_RESP_CTX *ctx)\\r\\n{\\r\\nTS_REQ *request = ctx->request;\\r\\nTS_MSG_IMPRINT *msg_imprint;\\r\\nX509_ALGOR *md_alg;\\r\\nint md_alg_id;\\r\\nconst ASN1_OCTET_STRING *digest;\\r\\nEVP_MD *md = NULL;\\r\\nint i;\\r\\nif (TS_REQ_get_version(request) != 1) {\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Bad request version.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_REQUEST);\\r\\nreturn 0;\\r\\n}\\r\\nmsg_imprint = TS_REQ_get_msg_imprint(request);\\r\\nmd_alg = TS_MSG_IMPRINT_get_algo(msg_imprint);\\r\\nmd_alg_id = OBJ_obj2nid(md_alg->algorithm);\\r\\nfor (i = 0; !md && i < sk_EVP_MD_num(ctx->mds); ++i) {\\r\\nEVP_MD *current_md = sk_EVP_MD_value(ctx->mds, i);\\r\\nif (md_alg_id == EVP_MD_type(current_md))\\r\\nmd = current_md;\\r\\n}\\r\\nif (!md) {\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Message digest algorithm is \"\\r\\n\"not supported.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_ALG);\\r\\nreturn 0;\\r\\n}\\r\\nif (md_alg->parameter && ASN1_TYPE_get(md_alg->parameter) != V_ASN1_NULL) {\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Superfluous message digest \"\\r\\n\"parameter.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_ALG);\\r\\nreturn 0;\\r\\n}\\r\\ndigest = TS_MSG_IMPRINT_get_msg(msg_imprint);\\r\\nif (digest->length != EVP_MD_size(md)) {\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Bad message digest.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_BAD_DATA_FORMAT);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic ASN1_OBJECT *TS_RESP_get_policy(TS_RESP_CTX *ctx)\\r\\n{\\r\\nASN1_OBJECT *requested = TS_REQ_get_policy_id(ctx->request);\\r\\nASN1_OBJECT *policy = NULL;\\r\\nint i;\\r\\nif (ctx->default_policy == NULL) {\\r\\nTSerr(TS_F_TS_RESP_GET_POLICY, TS_R_INVALID_NULL_POINTER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!requested || !OBJ_cmp(requested, ctx->default_policy))\\r\\npolicy = ctx->default_policy;\\r\\nfor (i = 0; !policy && i < sk_ASN1_OBJECT_num(ctx->policies); ++i) {\\r\\nASN1_OBJECT *current = sk_ASN1_OBJECT_value(ctx->policies, i);\\r\\nif (!OBJ_cmp(requested, current))\\r\\npolicy = current;\\r\\n}\\r\\nif (!policy) {\\r\\nTSerr(TS_F_TS_RESP_GET_POLICY, TS_R_UNACCEPTABLE_POLICY);\\r\\nTS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\\r\\n\"Requested policy is not \" \"supported.\");\\r\\nTS_RESP_CTX_add_failure_info(ctx, TS_INFO_UNACCEPTED_POLICY);\\r\\n}\\r\\nreturn policy;\\r\\n}\\r\\nstatic TS_TST_INFO *TS_RESP_create_tst_info(TS_RESP_CTX *ctx,\\r\\nASN1_OBJECT *policy)\\r\\n{\\r\\nint result = 0;\\r\\nTS_TST_INFO *tst_info = NULL;\\r\\nASN1_INTEGER *serial = NULL;\\r\\nASN1_GENERALIZEDTIME *asn1_time = NULL;\\r\\nlong sec, usec;\\r\\nTS_ACCURACY *accuracy = NULL;\\r\\nconst ASN1_INTEGER *nonce;\\r\\nGENERAL_NAME *tsa_name = NULL;\\r\\nif (!(tst_info = TS_TST_INFO_new()))\\r\\ngoto end;\\r\\nif (!TS_TST_INFO_set_version(tst_info, 1))\\r\\ngoto end;\\r\\nif (!TS_TST_INFO_set_policy_id(tst_info, policy))\\r\\ngoto end;\\r\\nif (!TS_TST_INFO_set_msg_imprint(tst_info, ctx->request->msg_imprint))\\r\\ngoto end;\\r\\nif (!(serial = (*ctx->serial_cb) (ctx, ctx->serial_cb_data))\\r\\n|| !TS_TST_INFO_set_serial(tst_info, serial))\\r\\ngoto end;\\r\\nif (!(*ctx->time_cb) (ctx, ctx->time_cb_data, &sec, &usec)\\r\\n|| !(asn1_time = TS_RESP_set_genTime_with_precision(NULL,\\r\\nsec, usec,\\r\\nctx->clock_precision_digits))\\r\\n|| !TS_TST_INFO_set_time(tst_info, asn1_time))\\r\\ngoto end;\\r\\nif ((ctx->seconds || ctx->millis || ctx->micros)\\r\\n&& !(accuracy = TS_ACCURACY_new()))\\r\\ngoto end;\\r\\nif (ctx->seconds && !TS_ACCURACY_set_seconds(accuracy, ctx->seconds))\\r\\ngoto end;\\r\\nif (ctx->millis && !TS_ACCURACY_set_millis(accuracy, ctx->millis))\\r\\ngoto end;\\r\\nif (ctx->micros && !TS_ACCURACY_set_micros(accuracy, ctx->micros))\\r\\ngoto end;\\r\\nif (accuracy && !TS_TST_INFO_set_accuracy(tst_info, accuracy))\\r\\ngoto end;\\r\\nif ((ctx->flags & TS_ORDERING)\\r\\n&& !TS_TST_INFO_set_ordering(tst_info, 1))\\r\\ngoto end;\\r\\nif ((nonce = TS_REQ_get_nonce(ctx->request)) != NULL\\r\\n&& !TS_TST_INFO_set_nonce(tst_info, nonce))\\r\\ngoto end;\\r\\nif (ctx->flags & TS_TSA_NAME) {\\r\\nif (!(tsa_name = GENERAL_NAME_new()))\\r\\ngoto end;\\r\\ntsa_name->type = GEN_DIRNAME;\\r\\ntsa_name->d.dirn =\\r\\nX509_NAME_dup(ctx->signer_cert->cert_info->subject);\\r\\nif (!tsa_name->d.dirn)\\r\\ngoto end;\\r\\nif (!TS_TST_INFO_set_tsa(tst_info, tsa_name))\\r\\ngoto end;\\r\\n}\\r\\nresult = 1;\\r\\nend:\\r\\nif (!result) {\\r\\nTS_TST_INFO_free(tst_info);\\r\\ntst_info = NULL;\\r\\nTSerr(TS_F_TS_RESP_CREATE_TST_INFO, TS_R_TST_INFO_SETUP_ERROR);\\r\\nTS_RESP_CTX_set_status_info_cond(ctx, TS_STATUS_REJECTION,\\r\\n\"Error during TSTInfo \"\\r\\n\"generation.\");\\r\\n}\\r\\nGENERAL_NAME_free(tsa_name);\\r\\nTS_ACCURACY_free(accuracy);\\r\\nASN1_GENERALIZEDTIME_free(asn1_time);\\r\\nASN1_INTEGER_free(serial);\\r\\nreturn tst_info;\\r\\n}\\r\\nstatic int TS_RESP_process_extensions(TS_RESP_CTX *ctx)\\r\\n{\\r\\nSTACK_OF(X509_EXTENSION) *exts = TS_REQ_get_exts(ctx->request);\\r\\nint i;\\r\\nint ok = 1;\\r\\nfor (i = 0; ok && i < sk_X509_EXTENSION_num(exts); ++i) {\\r\\nX509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);\\r\\nok = (*ctx->extension_cb) (ctx, ext, NULL);\\r\\n}\\r\\nreturn ok;\\r\\n}\\r\\nstatic int TS_RESP_sign(TS_RESP_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nPKCS7 *p7 = NULL;\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nSTACK_OF(X509) *certs;\\r\\nESS_SIGNING_CERT *sc = NULL;\\r\\nASN1_OBJECT *oid;\\r\\nBIO *p7bio = NULL;\\r\\nint i;\\r\\nif (!X509_check_private_key(ctx->signer_cert, ctx->signer_key)) {\\r\\nTSerr(TS_F_TS_RESP_SIGN, TS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);\\r\\ngoto err;\\r\\n}\\r\\nif (!(p7 = PKCS7_new())) {\\r\\nTSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!PKCS7_set_type(p7, NID_pkcs7_signed))\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(p7->d.sign->version, 3))\\r\\ngoto err;\\r\\nif (TS_REQ_get_cert_req(ctx->request)) {\\r\\nPKCS7_add_certificate(p7, ctx->signer_cert);\\r\\nif (ctx->certs) {\\r\\nfor (i = 0; i < sk_X509_num(ctx->certs); ++i) {\\r\\nX509 *cert = sk_X509_value(ctx->certs, i);\\r\\nPKCS7_add_certificate(p7, cert);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!(si = PKCS7_add_signature(p7, ctx->signer_cert,\\r\\nctx->signer_key, EVP_sha1()))) {\\r\\nTSerr(TS_F_TS_RESP_SIGN, TS_R_PKCS7_ADD_SIGNATURE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\noid = OBJ_nid2obj(NID_id_smime_ct_TSTInfo);\\r\\nif (!PKCS7_add_signed_attribute(si, NID_pkcs9_contentType,\\r\\nV_ASN1_OBJECT, oid)) {\\r\\nTSerr(TS_F_TS_RESP_SIGN, TS_R_PKCS7_ADD_SIGNED_ATTR_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ncerts = ctx->flags & TS_ESS_CERT_ID_CHAIN ? ctx->certs : NULL;\\r\\nif (!(sc = ESS_SIGNING_CERT_new_init(ctx->signer_cert, certs)))\\r\\ngoto err;\\r\\nif (!ESS_add_signing_cert(si, sc)) {\\r\\nTSerr(TS_F_TS_RESP_SIGN, TS_R_ESS_ADD_SIGNING_CERT_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!TS_TST_INFO_content_new(p7))\\r\\ngoto err;\\r\\nif (!(p7bio = PKCS7_dataInit(p7, NULL))) {\\r\\nTSerr(TS_F_TS_RESP_SIGN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!i2d_TS_TST_INFO_bio(p7bio, ctx->tst_info)) {\\r\\nTSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);\\r\\ngoto err;\\r\\n}\\r\\nif (!PKCS7_dataFinal(p7, p7bio)) {\\r\\nTSerr(TS_F_TS_RESP_SIGN, TS_R_TS_DATASIGN);\\r\\ngoto err;\\r\\n}\\r\\nTS_RESP_set_tst_info(ctx->response, p7, ctx->tst_info);\\r\\np7 = NULL;\\r\\nctx->tst_info = NULL;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret)\\r\\nTS_RESP_CTX_set_status_info_cond(ctx, TS_STATUS_REJECTION,\\r\\n\"Error during signature \"\\r\\n\"generation.\");\\r\\nBIO_free_all(p7bio);\\r\\nESS_SIGNING_CERT_free(sc);\\r\\nPKCS7_free(p7);\\r\\nreturn ret;\\r\\n}\\r\\nstatic ESS_CERT_ID *ESS_CERT_ID_new_init(X509 *cert, int issuer_needed)\\r\\n{\\r\\nESS_CERT_ID *cid = NULL;\\r\\nGENERAL_NAME *name = NULL;\\r\\nX509_check_purpose(cert, -1, 0);\\r\\nif (!(cid = ESS_CERT_ID_new()))\\r\\ngoto err;\\r\\nif (!ASN1_OCTET_STRING_set(cid->hash, cert->sha1_hash,\\r\\nsizeof(cert->sha1_hash)))\\r\\ngoto err;\\r\\nif (issuer_needed) {\\r\\nif (!cid->issuer_serial\\r\\n&& !(cid->issuer_serial = ESS_ISSUER_SERIAL_new()))\\r\\ngoto err;\\r\\nif (!(name = GENERAL_NAME_new()))\\r\\ngoto err;\\r\\nname->type = GEN_DIRNAME;\\r\\nif (!(name->d.dirn = X509_NAME_dup(cert->cert_info->issuer)))\\r\\ngoto err;\\r\\nif (!sk_GENERAL_NAME_push(cid->issuer_serial->issuer, name))\\r\\ngoto err;\\r\\nname = NULL;\\r\\nASN1_INTEGER_free(cid->issuer_serial->serial);\\r\\nif (!(cid->issuer_serial->serial =\\r\\nASN1_INTEGER_dup(cert->cert_info->serialNumber)))\\r\\ngoto err;\\r\\n}\\r\\nreturn cid;\\r\\nerr:\\r\\nGENERAL_NAME_free(name);\\r\\nESS_CERT_ID_free(cid);\\r\\nTSerr(TS_F_ESS_CERT_ID_NEW_INIT, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int TS_TST_INFO_content_new(PKCS7 *p7)\\r\\n{\\r\\nPKCS7 *ret = NULL;\\r\\nASN1_OCTET_STRING *octet_string = NULL;\\r\\nif (!(ret = PKCS7_new()))\\r\\ngoto err;\\r\\nif (!(ret->d.other = ASN1_TYPE_new()))\\r\\ngoto err;\\r\\nret->type = OBJ_nid2obj(NID_id_smime_ct_TSTInfo);\\r\\nif (!(octet_string = ASN1_OCTET_STRING_new()))\\r\\ngoto err;\\r\\nASN1_TYPE_set(ret->d.other, V_ASN1_OCTET_STRING, octet_string);\\r\\noctet_string = NULL;\\r\\nif (!PKCS7_set_content(p7, ret))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nASN1_OCTET_STRING_free(octet_string);\\r\\nPKCS7_free(ret);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ESS_add_signing_cert(PKCS7_SIGNER_INFO *si, ESS_SIGNING_CERT *sc)\\r\\n{\\r\\nASN1_STRING *seq = NULL;\\r\\nunsigned char *p, *pp = NULL;\\r\\nint len;\\r\\nlen = i2d_ESS_SIGNING_CERT(sc, NULL);\\r\\nif (!(pp = (unsigned char *)OPENSSL_malloc(len))) {\\r\\nTSerr(TS_F_ESS_ADD_SIGNING_CERT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np = pp;\\r\\ni2d_ESS_SIGNING_CERT(sc, &p);\\r\\nif (!(seq = ASN1_STRING_new()) || !ASN1_STRING_set(seq, pp, len)) {\\r\\nTSerr(TS_F_ESS_ADD_SIGNING_CERT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nOPENSSL_free(pp);\\r\\npp = NULL;\\r\\nreturn PKCS7_add_signed_attribute(si,\\r\\nNID_id_smime_aa_signingCertificate,\\r\\nV_ASN1_SEQUENCE, seq);\\r\\nerr:\\r\\nASN1_STRING_free(seq);\\r\\nOPENSSL_free(pp);\\r\\nreturn 0;\\r\\n}\\r\\nstatic ASN1_GENERALIZEDTIME\\r\\n*TS_RESP_set_genTime_with_precision(ASN1_GENERALIZEDTIME *asn1_time,\\r\\nlong sec, long usec, unsigned precision)\\r\\n{\\r\\ntime_t time_sec = (time_t)sec;\\r\\nstruct tm *tm = NULL;\\r\\nchar genTime_str[17 + TS_MAX_CLOCK_PRECISION_DIGITS];\\r\\nchar *p = genTime_str;\\r\\nchar *p_end = genTime_str + sizeof(genTime_str);\\r\\nif (precision > TS_MAX_CLOCK_PRECISION_DIGITS)\\r\\ngoto err;\\r\\nif (!(tm = gmtime(&time_sec)))\\r\\ngoto err;\\r\\np += BIO_snprintf(p, p_end - p,\\r\\n\"%04d%02d%02d%02d%02d%02d\",\\r\\ntm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,\\r\\ntm->tm_hour, tm->tm_min, tm->tm_sec);\\r\\nif (precision > 0) {\\r\\nBIO_snprintf(p, 2 + precision, \".%06ld\", usec);\\r\\np += strlen(p);\\r\\nwhile (*--p == '0')\\r\\n;\\r\\nif (*p != '.')\\r\\n++p;\\r\\n}\\r\\n*p++ = 'Z';\\r\\n*p++ = '\\0';\\r\\nif (!asn1_time && !(asn1_time = M_ASN1_GENERALIZEDTIME_new()))\\r\\ngoto err;\\r\\nif (!ASN1_GENERALIZEDTIME_set_string(asn1_time, genTime_str)) {\\r\\nASN1_GENERALIZEDTIME_free(asn1_time);\\r\\ngoto err;\\r\\n}\\r\\nreturn asn1_time;\\r\\nerr:\\r\\nTSerr(TS_F_TS_RESP_SET_GENTIME_WITH_PRECISION, TS_R_COULD_NOT_SET_TIME);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rand_unix_c", "target": 0, "func": "int RAND_poll(void)\\r\\n{\\r\\nshort int code;\\r\\ngid_t curr_gid;\\r\\npid_t curr_pid;\\r\\nuid_t curr_uid;\\r\\nint i, k;\\r\\nstruct timespec ts;\\r\\nunsigned char v;\\r\\n# ifdef OPENSSL_SYS_VOS_HPPA\\r\\nlong duration;\\r\\nextern void s$sleep(long *_duration, short int *_code);\\r\\n# else\\r\\n# ifdef OPENSSL_SYS_VOS_IA32\\r\\nlong long duration;\\r\\nextern void s$sleep2(long long *_duration, short int *_code);\\r\\n# else\\r\\n# error \"Unsupported Platform.\"\\r\\n# endif\\r\\n# endif\\r\\ncurr_gid = getgid();\\r\\nRAND_add(&curr_gid, sizeof curr_gid, 1);\\r\\ncurr_gid = 0;\\r\\ncurr_pid = getpid();\\r\\nRAND_add(&curr_pid, sizeof curr_pid, 1);\\r\\ncurr_pid = 0;\\r\\ncurr_uid = getuid();\\r\\nRAND_add(&curr_uid, sizeof curr_uid, 1);\\r\\ncurr_uid = 0;\\r\\nfor (i = 0; i < (ENTROPY_NEEDED * 4); i++) {\\r\\nfor (k = 0; k < 99; k++)\\r\\nts.tv_nsec = random();\\r\\n# ifdef OPENSSL_SYS_VOS_HPPA\\r\\nduration = 1;\\r\\ns$sleep(&duration, &code);\\r\\n# else\\r\\n# ifdef OPENSSL_SYS_VOS_IA32\\r\\nduration = 1;\\r\\ns$sleep2(&duration, &code);\\r\\n# endif\\r\\n# endif\\r\\nclock_gettime(CLOCK_REALTIME, &ts);\\r\\nv = (unsigned char)(ts.tv_nsec % 256);\\r\\nRAND_add(&v, sizeof v, 1);\\r\\nv = 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint RAND_poll(void)\\r\\n{\\r\\nu_int32_t rnd = 0, i;\\r\\nunsigned char buf[ENTROPY_NEEDED];\\r\\nfor (i = 0; i < sizeof(buf); i++) {\\r\\nif (i % 4 == 0)\\r\\nrnd = arc4random();\\r\\nbuf[i] = rnd;\\r\\nrnd >>= 8;\\r\\n}\\r\\nRAND_add(buf, sizeof(buf), ENTROPY_NEEDED);\\r\\nmemset(buf, 0, sizeof(buf));\\r\\nreturn 1;\\r\\n}\\r\\nint RAND_poll(void)\\r\\n{\\r\\nunsigned long l;\\r\\npid_t curr_pid = getpid();\\r\\n# if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)\\r\\nunsigned char tmpbuf[ENTROPY_NEEDED];\\r\\nint n = 0;\\r\\n# endif\\r\\n# ifdef DEVRANDOM\\r\\nstatic const char *randomfiles[] = { DEVRANDOM };\\r\\nstruct stat randomstats[sizeof(randomfiles) / sizeof(randomfiles[0])];\\r\\nint fd;\\r\\nunsigned int i;\\r\\n# endif\\r\\n# ifdef DEVRANDOM_EGD\\r\\nstatic const char *egdsockets[] = { DEVRANDOM_EGD, NULL };\\r\\nconst char **egdsocket = NULL;\\r\\n# endif\\r\\n# ifdef DEVRANDOM\\r\\nmemset(randomstats, 0, sizeof(randomstats));\\r\\nfor (i = 0; (i < sizeof(randomfiles) / sizeof(randomfiles[0])) &&\\r\\n(n < ENTROPY_NEEDED); i++) {\\r\\nif ((fd = open(randomfiles[i], O_RDONLY\\r\\n# ifdef O_NONBLOCK\\r\\n| O_NONBLOCK\\r\\n# endif\\r\\n# ifdef O_BINARY\\r\\n| O_BINARY\\r\\n# endif\\r\\n# ifdef O_NOCTTY\\r\\n| O_NOCTTY\\r\\n# endif\\r\\n)) >= 0) {\\r\\nint usec = 10 * 1000;\\r\\nint r;\\r\\nunsigned int j;\\r\\nstruct stat *st = &randomstats[i];\\r\\nif (fstat(fd, st) != 0) {\\r\\nclose(fd);\\r\\ncontinue;\\r\\n}\\r\\nfor (j = 0; j < i; j++) {\\r\\nif (randomstats[j].st_ino == st->st_ino &&\\r\\nrandomstats[j].st_dev == st->st_dev)\\r\\nbreak;\\r\\n}\\r\\nif (j < i) {\\r\\nclose(fd);\\r\\ncontinue;\\r\\n}\\r\\ndo {\\r\\nint try_read = 0;\\r\\n# if defined(OPENSSL_SYS_BEOS_R5)\\r\\ntry_read = 1;\\r\\n# elif defined(OPENSSL_SYS_LINUX)\\r\\nstruct pollfd pset;\\r\\npset.fd = fd;\\r\\npset.events = POLLIN;\\r\\npset.revents = 0;\\r\\nif (poll(&pset, 1, usec / 1000) < 0)\\r\\nusec = 0;\\r\\nelse\\r\\ntry_read = (pset.revents & POLLIN) != 0;\\r\\n# else\\r\\nfd_set fset;\\r\\nstruct timeval t;\\r\\nt.tv_sec = 0;\\r\\nt.tv_usec = usec;\\r\\nif (FD_SETSIZE > 0 && (unsigned)fd >= FD_SETSIZE) {\\r\\ntry_read = 1;\\r\\n} else {\\r\\nFD_ZERO(&fset);\\r\\nFD_SET(fd, &fset);\\r\\nif (select(fd + 1, &fset, NULL, NULL, &t) >= 0) {\\r\\nusec = t.tv_usec;\\r\\nif (FD_ISSET(fd, &fset))\\r\\ntry_read = 1;\\r\\n} else\\r\\nusec = 0;\\r\\n}\\r\\n# endif\\r\\nif (try_read) {\\r\\nr = read(fd, (unsigned char *)tmpbuf + n,\\r\\nENTROPY_NEEDED - n);\\r\\nif (r > 0)\\r\\nn += r;\\r\\n# if defined(OPENSSL_SYS_BEOS_R5)\\r\\nif (r == 0)\\r\\nsnooze(t.tv_usec);\\r\\n# endif\\r\\n} else\\r\\nr = -1;\\r\\nif (usec == 10 * 1000)\\r\\nusec = 0;\\r\\n}\\r\\nwhile ((r > 0 ||\\r\\n(errno == EINTR || errno == EAGAIN)) && usec != 0\\r\\n&& n < ENTROPY_NEEDED);\\r\\nclose(fd);\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# ifdef DEVRANDOM_EGD\\r\\nfor (egdsocket = egdsockets; *egdsocket && n < ENTROPY_NEEDED;\\r\\negdsocket++) {\\r\\nint r;\\r\\nr = RAND_query_egd_bytes(*egdsocket, (unsigned char *)tmpbuf + n,\\r\\nENTROPY_NEEDED - n);\\r\\nif (r > 0)\\r\\nn += r;\\r\\n}\\r\\n# endif\\r\\n# if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)\\r\\nif (n > 0) {\\r\\nRAND_add(tmpbuf, sizeof tmpbuf, (double)n);\\r\\nOPENSSL_cleanse(tmpbuf, n);\\r\\n}\\r\\n# endif\\r\\nl = curr_pid;\\r\\nRAND_add(&l, sizeof(l), 0.0);\\r\\nl = getuid();\\r\\nRAND_add(&l, sizeof(l), 0.0);\\r\\nl = time(NULL);\\r\\nRAND_add(&l, sizeof(l), 0.0);\\r\\n# if defined(OPENSSL_SYS_BEOS)\\r\\n{\\r\\nsystem_info sysInfo;\\r\\nget_system_info(&sysInfo);\\r\\nRAND_add(&sysInfo, sizeof(sysInfo), 0);\\r\\n}\\r\\n# endif\\r\\n# if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)\\r\\nreturn 1;\\r\\n# else\\r\\nreturn 0;\\r\\n# endif\\r\\n}\\r\\nint RAND_poll(void)\\r\\n{\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecp_nist_c", "target": 0, "func": "const EC_METHOD *EC_GFp_nist_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nEC_FLAGS_DEFAULT_OCT,\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_simple_group_init,\\r\\nec_GFp_simple_group_finish,\\r\\nec_GFp_simple_group_clear_finish,\\r\\nec_GFp_nist_group_copy,\\r\\nec_GFp_nist_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\nec_GFp_simple_point_get_affine_coordinates,\\r\\n0, 0, 0,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GFp_nist_field_mul,\\r\\nec_GFp_nist_field_sqr,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\n0\\r\\n};\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn fips_ec_gfp_nist_method();\\r\\n#endif\\r\\nreturn &ret;\\r\\n}\\r\\nint ec_GFp_nist_group_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\ndest->field_mod_func = src->field_mod_func;\\r\\nreturn ec_GFp_simple_group_copy(dest, src);\\r\\n}\\r\\nint ec_GFp_nist_group_set_curve(EC_GROUP *group, const BIGNUM *p,\\r\\nconst BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp_bn;\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif ((tmp_bn = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (BN_ucmp(BN_get0_nist_prime_192(), p) == 0)\\r\\ngroup->field_mod_func = BN_nist_mod_192;\\r\\nelse if (BN_ucmp(BN_get0_nist_prime_224(), p) == 0)\\r\\ngroup->field_mod_func = BN_nist_mod_224;\\r\\nelse if (BN_ucmp(BN_get0_nist_prime_256(), p) == 0)\\r\\ngroup->field_mod_func = BN_nist_mod_256;\\r\\nelse if (BN_ucmp(BN_get0_nist_prime_384(), p) == 0)\\r\\ngroup->field_mod_func = BN_nist_mod_384;\\r\\nelse if (BN_ucmp(BN_get0_nist_prime_521(), p) == 0)\\r\\ngroup->field_mod_func = BN_nist_mod_521;\\r\\nelse {\\r\\nECerr(EC_F_EC_GFP_NIST_GROUP_SET_CURVE, EC_R_NOT_A_NIST_PRIME);\\r\\ngoto err;\\r\\n}\\r\\nret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nist_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *ctx_new = NULL;\\r\\nif (!group || !r || !a || !b) {\\r\\nECerr(EC_F_EC_GFP_NIST_FIELD_MUL, ERR_R_PASSED_NULL_PARAMETER);\\r\\ngoto err;\\r\\n}\\r\\nif (!ctx)\\r\\nif ((ctx_new = ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_mul(r, a, b, ctx))\\r\\ngoto err;\\r\\nif (!group->field_mod_func(r, r, &group->field, ctx))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx_new);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nist_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *ctx_new = NULL;\\r\\nif (!group || !r || !a) {\\r\\nECerr(EC_F_EC_GFP_NIST_FIELD_SQR, EC_R_PASSED_NULL_PARAMETER);\\r\\ngoto err;\\r\\n}\\r\\nif (!ctx)\\r\\nif ((ctx_new = ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_sqr(r, a, ctx))\\r\\ngoto err;\\r\\nif (!group->field_mod_func(r, r, &group->field, ctx))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx_new);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_c_skey_c", "target": 0, "func": "void CAST_set_key(CAST_KEY *key, int len, const unsigned char *data)\\r\\n#ifdef OPENSSL_FIPS\\r\\n{\\r\\nfips_cipher_abort(CAST);\\r\\nprivate_CAST_set_key(key, len, data);\\r\\n}\\r\\nvoid private_CAST_set_key(CAST_KEY *key, int len, const unsigned char *data)\\r\\n#endif\\r\\n{\\r\\nCAST_LONG x[16];\\r\\nCAST_LONG z[16];\\r\\nCAST_LONG k[32];\\r\\nCAST_LONG X[4], Z[4];\\r\\nCAST_LONG l, *K;\\r\\nint i;\\r\\nfor (i = 0; i < 16; i++)\\r\\nx[i] = 0;\\r\\nif (len > 16)\\r\\nlen = 16;\\r\\nfor (i = 0; i < len; i++)\\r\\nx[i] = data[i];\\r\\nif (len <= 10)\\r\\nkey->short_key = 1;\\r\\nelse\\r\\nkey->short_key = 0;\\r\\nK = &k[0];\\r\\nX[0] = ((x[0] << 24) | (x[1] << 16) | (x[2] << 8) | x[3]) & 0xffffffffL;\\r\\nX[1] = ((x[4] << 24) | (x[5] << 16) | (x[6] << 8) | x[7]) & 0xffffffffL;\\r\\nX[2] = ((x[8] << 24) | (x[9] << 16) | (x[10] << 8) | x[11]) & 0xffffffffL;\\r\\nX[3] =\\r\\n((x[12] << 24) | (x[13] << 16) | (x[14] << 8) | x[15]) & 0xffffffffL;\\r\\nfor (;;) {\\r\\nl = X[0] ^ S4[x[13]] ^ S5[x[15]] ^ S6[x[12]] ^ S7[x[14]] ^ S6[x[8]];\\r\\nCAST_exp(l, Z, z, 0);\\r\\nl = X[2] ^ S4[z[0]] ^ S5[z[2]] ^ S6[z[1]] ^ S7[z[3]] ^ S7[x[10]];\\r\\nCAST_exp(l, Z, z, 4);\\r\\nl = X[3] ^ S4[z[7]] ^ S5[z[6]] ^ S6[z[5]] ^ S7[z[4]] ^ S4[x[9]];\\r\\nCAST_exp(l, Z, z, 8);\\r\\nl = X[1] ^ S4[z[10]] ^ S5[z[9]] ^ S6[z[11]] ^ S7[z[8]] ^ S5[x[11]];\\r\\nCAST_exp(l, Z, z, 12);\\r\\nK[0] = S4[z[8]] ^ S5[z[9]] ^ S6[z[7]] ^ S7[z[6]] ^ S4[z[2]];\\r\\nK[1] = S4[z[10]] ^ S5[z[11]] ^ S6[z[5]] ^ S7[z[4]] ^ S5[z[6]];\\r\\nK[2] = S4[z[12]] ^ S5[z[13]] ^ S6[z[3]] ^ S7[z[2]] ^ S6[z[9]];\\r\\nK[3] = S4[z[14]] ^ S5[z[15]] ^ S6[z[1]] ^ S7[z[0]] ^ S7[z[12]];\\r\\nl = Z[2] ^ S4[z[5]] ^ S5[z[7]] ^ S6[z[4]] ^ S7[z[6]] ^ S6[z[0]];\\r\\nCAST_exp(l, X, x, 0);\\r\\nl = Z[0] ^ S4[x[0]] ^ S5[x[2]] ^ S6[x[1]] ^ S7[x[3]] ^ S7[z[2]];\\r\\nCAST_exp(l, X, x, 4);\\r\\nl = Z[1] ^ S4[x[7]] ^ S5[x[6]] ^ S6[x[5]] ^ S7[x[4]] ^ S4[z[1]];\\r\\nCAST_exp(l, X, x, 8);\\r\\nl = Z[3] ^ S4[x[10]] ^ S5[x[9]] ^ S6[x[11]] ^ S7[x[8]] ^ S5[z[3]];\\r\\nCAST_exp(l, X, x, 12);\\r\\nK[4] = S4[x[3]] ^ S5[x[2]] ^ S6[x[12]] ^ S7[x[13]] ^ S4[x[8]];\\r\\nK[5] = S4[x[1]] ^ S5[x[0]] ^ S6[x[14]] ^ S7[x[15]] ^ S5[x[13]];\\r\\nK[6] = S4[x[7]] ^ S5[x[6]] ^ S6[x[8]] ^ S7[x[9]] ^ S6[x[3]];\\r\\nK[7] = S4[x[5]] ^ S5[x[4]] ^ S6[x[10]] ^ S7[x[11]] ^ S7[x[7]];\\r\\nl = X[0] ^ S4[x[13]] ^ S5[x[15]] ^ S6[x[12]] ^ S7[x[14]] ^ S6[x[8]];\\r\\nCAST_exp(l, Z, z, 0);\\r\\nl = X[2] ^ S4[z[0]] ^ S5[z[2]] ^ S6[z[1]] ^ S7[z[3]] ^ S7[x[10]];\\r\\nCAST_exp(l, Z, z, 4);\\r\\nl = X[3] ^ S4[z[7]] ^ S5[z[6]] ^ S6[z[5]] ^ S7[z[4]] ^ S4[x[9]];\\r\\nCAST_exp(l, Z, z, 8);\\r\\nl = X[1] ^ S4[z[10]] ^ S5[z[9]] ^ S6[z[11]] ^ S7[z[8]] ^ S5[x[11]];\\r\\nCAST_exp(l, Z, z, 12);\\r\\nK[8] = S4[z[3]] ^ S5[z[2]] ^ S6[z[12]] ^ S7[z[13]] ^ S4[z[9]];\\r\\nK[9] = S4[z[1]] ^ S5[z[0]] ^ S6[z[14]] ^ S7[z[15]] ^ S5[z[12]];\\r\\nK[10] = S4[z[7]] ^ S5[z[6]] ^ S6[z[8]] ^ S7[z[9]] ^ S6[z[2]];\\r\\nK[11] = S4[z[5]] ^ S5[z[4]] ^ S6[z[10]] ^ S7[z[11]] ^ S7[z[6]];\\r\\nl = Z[2] ^ S4[z[5]] ^ S5[z[7]] ^ S6[z[4]] ^ S7[z[6]] ^ S6[z[0]];\\r\\nCAST_exp(l, X, x, 0);\\r\\nl = Z[0] ^ S4[x[0]] ^ S5[x[2]] ^ S6[x[1]] ^ S7[x[3]] ^ S7[z[2]];\\r\\nCAST_exp(l, X, x, 4);\\r\\nl = Z[1] ^ S4[x[7]] ^ S5[x[6]] ^ S6[x[5]] ^ S7[x[4]] ^ S4[z[1]];\\r\\nCAST_exp(l, X, x, 8);\\r\\nl = Z[3] ^ S4[x[10]] ^ S5[x[9]] ^ S6[x[11]] ^ S7[x[8]] ^ S5[z[3]];\\r\\nCAST_exp(l, X, x, 12);\\r\\nK[12] = S4[x[8]] ^ S5[x[9]] ^ S6[x[7]] ^ S7[x[6]] ^ S4[x[3]];\\r\\nK[13] = S4[x[10]] ^ S5[x[11]] ^ S6[x[5]] ^ S7[x[4]] ^ S5[x[7]];\\r\\nK[14] = S4[x[12]] ^ S5[x[13]] ^ S6[x[3]] ^ S7[x[2]] ^ S6[x[8]];\\r\\nK[15] = S4[x[14]] ^ S5[x[15]] ^ S6[x[1]] ^ S7[x[0]] ^ S7[x[13]];\\r\\nif (K != k)\\r\\nbreak;\\r\\nK += 16;\\r\\n}\\r\\nfor (i = 0; i < 16; i++) {\\r\\nkey->data[i * 2] = k[i];\\r\\nkey->data[i * 2 + 1] = ((k[i + 16]) + 16) & 0x1f;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_evp_enc_c", "target": 0, "func": "void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nmemset(ctx, 0, sizeof(EVP_CIPHER_CTX));\\r\\n}\\r\\nEVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void)\\r\\n{\\r\\nEVP_CIPHER_CTX *ctx = OPENSSL_malloc(sizeof *ctx);\\r\\nif (ctx)\\r\\nEVP_CIPHER_CTX_init(ctx);\\r\\nreturn ctx;\\r\\n}\\r\\nint EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nconst unsigned char *key, const unsigned char *iv, int enc)\\r\\n{\\r\\nif (cipher)\\r\\nEVP_CIPHER_CTX_init(ctx);\\r\\nreturn EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, enc);\\r\\n}\\r\\nint EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nENGINE *impl, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nif (enc == -1)\\r\\nenc = ctx->encrypt;\\r\\nelse {\\r\\nif (enc)\\r\\nenc = 1;\\r\\nctx->encrypt = enc;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ctx->engine && ctx->cipher && (!cipher ||\\r\\n(cipher\\r\\n&& (cipher->nid ==\\r\\nctx->cipher->nid))))\\r\\ngoto skip_to_init;\\r\\n#endif\\r\\nif (cipher) {\\r\\nif (ctx->cipher) {\\r\\nunsigned long flags = ctx->flags;\\r\\nEVP_CIPHER_CTX_cleanup(ctx);\\r\\nctx->encrypt = enc;\\r\\nctx->flags = flags;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (impl) {\\r\\nif (!ENGINE_init(impl)) {\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n} else\\r\\nimpl = ENGINE_get_cipher_engine(cipher->nid);\\r\\nif (impl) {\\r\\nconst EVP_CIPHER *c = ENGINE_get_cipher(impl, cipher->nid);\\r\\nif (!c) {\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\ncipher = c;\\r\\nctx->engine = impl;\\r\\n} else\\r\\nctx->engine = NULL;\\r\\n#endif\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode()) {\\r\\nconst EVP_CIPHER *fcipher;\\r\\nif (cipher)\\r\\nfcipher = evp_get_fips_cipher(cipher);\\r\\nif (fcipher)\\r\\ncipher = fcipher;\\r\\nreturn FIPS_cipherinit(ctx, cipher, key, iv, enc);\\r\\n}\\r\\n#endif\\r\\nctx->cipher = cipher;\\r\\nif (ctx->cipher->ctx_size) {\\r\\nctx->cipher_data = OPENSSL_malloc(ctx->cipher->ctx_size);\\r\\nif (!ctx->cipher_data) {\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n} else {\\r\\nctx->cipher_data = NULL;\\r\\n}\\r\\nctx->key_len = cipher->key_len;\\r\\nctx->flags &= EVP_CIPHER_CTX_FLAG_WRAP_ALLOW;\\r\\nif (ctx->cipher->flags & EVP_CIPH_CTRL_INIT) {\\r\\nif (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL)) {\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_INITIALIZATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n} else if (!ctx->cipher) {\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_NO_CIPHER_SET);\\r\\nreturn 0;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nskip_to_init:\\r\\n#endif\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_cipherinit(ctx, cipher, key, iv, enc);\\r\\n#endif\\r\\nOPENSSL_assert(ctx->cipher->block_size == 1\\r\\n|| ctx->cipher->block_size == 8\\r\\n|| ctx->cipher->block_size == 16);\\r\\nif (!(ctx->flags & EVP_CIPHER_CTX_FLAG_WRAP_ALLOW)\\r\\n&& EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_WRAP_MODE) {\\r\\nEVPerr(EVP_F_EVP_CIPHERINIT_EX, EVP_R_WRAP_MODE_NOT_ALLOWED);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(EVP_CIPHER_CTX_flags(ctx) & EVP_CIPH_CUSTOM_IV)) {\\r\\nswitch (EVP_CIPHER_CTX_mode(ctx)) {\\r\\ncase EVP_CIPH_STREAM_CIPHER:\\r\\ncase EVP_CIPH_ECB_MODE:\\r\\nbreak;\\r\\ncase EVP_CIPH_CFB_MODE:\\r\\ncase EVP_CIPH_OFB_MODE:\\r\\nctx->num = 0;\\r\\ncase EVP_CIPH_CBC_MODE:\\r\\nOPENSSL_assert(EVP_CIPHER_CTX_iv_length(ctx) <=\\r\\n(int)sizeof(ctx->iv));\\r\\nif (iv)\\r\\nmemcpy(ctx->oiv, iv, EVP_CIPHER_CTX_iv_length(ctx));\\r\\nmemcpy(ctx->iv, ctx->oiv, EVP_CIPHER_CTX_iv_length(ctx));\\r\\nbreak;\\r\\ncase EVP_CIPH_CTR_MODE:\\r\\nctx->num = 0;\\r\\nif (iv)\\r\\nmemcpy(ctx->iv, iv, EVP_CIPHER_CTX_iv_length(ctx));\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (key || (ctx->cipher->flags & EVP_CIPH_ALWAYS_CALL_INIT)) {\\r\\nif (!ctx->cipher->init(ctx, key, iv, enc))\\r\\nreturn 0;\\r\\n}\\r\\nctx->buf_len = 0;\\r\\nctx->final_used = 0;\\r\\nctx->block_mask = ctx->cipher->block_size - 1;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nif (ctx->encrypt)\\r\\nreturn EVP_EncryptUpdate(ctx, out, outl, in, inl);\\r\\nelse\\r\\nreturn EVP_DecryptUpdate(ctx, out, outl, in, inl);\\r\\n}\\r\\nint EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nif (ctx->encrypt)\\r\\nreturn EVP_EncryptFinal_ex(ctx, out, outl);\\r\\nelse\\r\\nreturn EVP_DecryptFinal_ex(ctx, out, outl);\\r\\n}\\r\\nint EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nif (ctx->encrypt)\\r\\nreturn EVP_EncryptFinal(ctx, out, outl);\\r\\nelse\\r\\nreturn EVP_DecryptFinal(ctx, out, outl);\\r\\n}\\r\\nint EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nconst unsigned char *key, const unsigned char *iv)\\r\\n{\\r\\nreturn EVP_CipherInit(ctx, cipher, key, iv, 1);\\r\\n}\\r\\nint EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nENGINE *impl, const unsigned char *key,\\r\\nconst unsigned char *iv)\\r\\n{\\r\\nreturn EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 1);\\r\\n}\\r\\nint EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nconst unsigned char *key, const unsigned char *iv)\\r\\n{\\r\\nreturn EVP_CipherInit(ctx, cipher, key, iv, 0);\\r\\n}\\r\\nint EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,\\r\\nENGINE *impl, const unsigned char *key,\\r\\nconst unsigned char *iv)\\r\\n{\\r\\nreturn EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 0);\\r\\n}\\r\\nint EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nint i, j, bl;\\r\\nif (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\\r\\ni = M_do_cipher(ctx, out, in, inl);\\r\\nif (i < 0)\\r\\nreturn 0;\\r\\nelse\\r\\n*outl = i;\\r\\nreturn 1;\\r\\n}\\r\\nif (inl <= 0) {\\r\\n*outl = 0;\\r\\nreturn inl == 0;\\r\\n}\\r\\nif (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\\r\\nif (M_do_cipher(ctx, out, in, inl)) {\\r\\n*outl = inl;\\r\\nreturn 1;\\r\\n} else {\\r\\n*outl = 0;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\ni = ctx->buf_len;\\r\\nbl = ctx->cipher->block_size;\\r\\nOPENSSL_assert(bl <= (int)sizeof(ctx->buf));\\r\\nif (i != 0) {\\r\\nif (i + inl < bl) {\\r\\nmemcpy(&(ctx->buf[i]), in, inl);\\r\\nctx->buf_len += inl;\\r\\n*outl = 0;\\r\\nreturn 1;\\r\\n} else {\\r\\nj = bl - i;\\r\\nmemcpy(&(ctx->buf[i]), in, j);\\r\\nif (!M_do_cipher(ctx, out, ctx->buf, bl))\\r\\nreturn 0;\\r\\ninl -= j;\\r\\nin += j;\\r\\nout += bl;\\r\\n*outl = bl;\\r\\n}\\r\\n} else\\r\\n*outl = 0;\\r\\ni = inl & (bl - 1);\\r\\ninl -= i;\\r\\nif (inl > 0) {\\r\\nif (!M_do_cipher(ctx, out, in, inl))\\r\\nreturn 0;\\r\\n*outl += inl;\\r\\n}\\r\\nif (i != 0)\\r\\nmemcpy(ctx->buf, &(in[inl]), i);\\r\\nctx->buf_len = i;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint ret;\\r\\nret = EVP_EncryptFinal_ex(ctx, out, outl);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint n, ret;\\r\\nunsigned int i, b, bl;\\r\\nif (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\\r\\nret = M_do_cipher(ctx, out, NULL, 0);\\r\\nif (ret < 0)\\r\\nreturn 0;\\r\\nelse\\r\\n*outl = ret;\\r\\nreturn 1;\\r\\n}\\r\\nb = ctx->cipher->block_size;\\r\\nOPENSSL_assert(b <= sizeof ctx->buf);\\r\\nif (b == 1) {\\r\\n*outl = 0;\\r\\nreturn 1;\\r\\n}\\r\\nbl = ctx->buf_len;\\r\\nif (ctx->flags & EVP_CIPH_NO_PADDING) {\\r\\nif (bl) {\\r\\nEVPerr(EVP_F_EVP_ENCRYPTFINAL_EX,\\r\\nEVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\n*outl = 0;\\r\\nreturn 1;\\r\\n}\\r\\nn = b - bl;\\r\\nfor (i = bl; i < b; i++)\\r\\nctx->buf[i] = n;\\r\\nret = M_do_cipher(ctx, out, ctx->buf, b);\\r\\nif (ret)\\r\\n*outl = b;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nint fix_len;\\r\\nunsigned int b;\\r\\nif (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\\r\\nfix_len = M_do_cipher(ctx, out, in, inl);\\r\\nif (fix_len < 0) {\\r\\n*outl = 0;\\r\\nreturn 0;\\r\\n} else\\r\\n*outl = fix_len;\\r\\nreturn 1;\\r\\n}\\r\\nif (inl <= 0) {\\r\\n*outl = 0;\\r\\nreturn inl == 0;\\r\\n}\\r\\nif (ctx->flags & EVP_CIPH_NO_PADDING)\\r\\nreturn EVP_EncryptUpdate(ctx, out, outl, in, inl);\\r\\nb = ctx->cipher->block_size;\\r\\nOPENSSL_assert(b <= sizeof ctx->final);\\r\\nif (ctx->final_used) {\\r\\nmemcpy(out, ctx->final, b);\\r\\nout += b;\\r\\nfix_len = 1;\\r\\n} else\\r\\nfix_len = 0;\\r\\nif (!EVP_EncryptUpdate(ctx, out, outl, in, inl))\\r\\nreturn 0;\\r\\nif (b > 1 && !ctx->buf_len) {\\r\\n*outl -= b;\\r\\nctx->final_used = 1;\\r\\nmemcpy(ctx->final, &out[*outl], b);\\r\\n} else\\r\\nctx->final_used = 0;\\r\\nif (fix_len)\\r\\n*outl += b;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint ret;\\r\\nret = EVP_DecryptFinal_ex(ctx, out, outl);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i, n;\\r\\nunsigned int b;\\r\\n*outl = 0;\\r\\nif (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\\r\\ni = M_do_cipher(ctx, out, NULL, 0);\\r\\nif (i < 0)\\r\\nreturn 0;\\r\\nelse\\r\\n*outl = i;\\r\\nreturn 1;\\r\\n}\\r\\nb = ctx->cipher->block_size;\\r\\nif (ctx->flags & EVP_CIPH_NO_PADDING) {\\r\\nif (ctx->buf_len) {\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,\\r\\nEVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\n*outl = 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (b > 1) {\\r\\nif (ctx->buf_len || !ctx->final_used) {\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_WRONG_FINAL_BLOCK_LENGTH);\\r\\nreturn (0);\\r\\n}\\r\\nOPENSSL_assert(b <= sizeof ctx->final);\\r\\nn = ctx->final[b - 1];\\r\\nif (n == 0 || n > (int)b) {\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_BAD_DECRYPT);\\r\\nreturn (0);\\r\\n}\\r\\nfor (i = 0; i < n; i++) {\\r\\nif (ctx->final[--b] != n) {\\r\\nEVPerr(EVP_F_EVP_DECRYPTFINAL_EX, EVP_R_BAD_DECRYPT);\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nn = ctx->cipher->block_size - n;\\r\\nfor (i = 0; i < n; i++)\\r\\nout[i] = ctx->final[i];\\r\\n*outl = n;\\r\\n} else\\r\\n*outl = 0;\\r\\nreturn (1);\\r\\n}\\r\\nvoid EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nif (ctx) {\\r\\nEVP_CIPHER_CTX_cleanup(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\n}\\r\\nint EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *c)\\r\\n{\\r\\n#ifndef OPENSSL_FIPS\\r\\nif (c->cipher != NULL) {\\r\\nif (c->cipher->cleanup && !c->cipher->cleanup(c))\\r\\nreturn 0;\\r\\nif (c->cipher_data)\\r\\nOPENSSL_cleanse(c->cipher_data, c->cipher->ctx_size);\\r\\n}\\r\\nif (c->cipher_data)\\r\\nOPENSSL_free(c->cipher_data);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (c->engine)\\r\\nENGINE_finish(c->engine);\\r\\n#endif\\r\\n#ifdef OPENSSL_FIPS\\r\\nFIPS_cipher_ctx_cleanup(c);\\r\\n#endif\\r\\nmemset(c, 0, sizeof(EVP_CIPHER_CTX));\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *c, int keylen)\\r\\n{\\r\\nif (c->cipher->flags & EVP_CIPH_CUSTOM_KEY_LENGTH)\\r\\nreturn EVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_KEY_LENGTH, keylen, NULL);\\r\\nif (c->key_len == keylen)\\r\\nreturn 1;\\r\\nif ((keylen > 0) && (c->cipher->flags & EVP_CIPH_VARIABLE_LENGTH)) {\\r\\nc->key_len = keylen;\\r\\nreturn 1;\\r\\n}\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH, EVP_R_INVALID_KEY_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *ctx, int pad)\\r\\n{\\r\\nif (pad)\\r\\nctx->flags &= ~EVP_CIPH_NO_PADDING;\\r\\nelse\\r\\nctx->flags |= EVP_CIPH_NO_PADDING;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx->cipher) {\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_NO_CIPHER_SET);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ctx->cipher->ctrl) {\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_CTRL, EVP_R_CTRL_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nret = ctx->cipher->ctrl(ctx, type, arg, ptr);\\r\\nif (ret == -1) {\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_CTRL,\\r\\nEVP_R_CTRL_OPERATION_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key)\\r\\n{\\r\\nif (ctx->cipher->flags & EVP_CIPH_RAND_KEY)\\r\\nreturn EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_RAND_KEY, 0, key);\\r\\nif (RAND_bytes(key, ctx->key_len) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in)\\r\\n{\\r\\nif ((in == NULL) || (in->cipher == NULL)) {\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_COPY, EVP_R_INPUT_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (in->engine && !ENGINE_init(in->engine)) {\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_COPY, ERR_R_ENGINE_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nEVP_CIPHER_CTX_cleanup(out);\\r\\nmemcpy(out, in, sizeof *out);\\r\\nif (in->cipher_data && in->cipher->ctx_size) {\\r\\nout->cipher_data = OPENSSL_malloc(in->cipher->ctx_size);\\r\\nif (!out->cipher_data) {\\r\\nEVPerr(EVP_F_EVP_CIPHER_CTX_COPY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(out->cipher_data, in->cipher_data, in->cipher->ctx_size);\\r\\n}\\r\\nif (in->cipher->flags & EVP_CIPH_CUSTOM_COPY)\\r\\nreturn in->cipher->ctrl((EVP_CIPHER_CTX *)in, EVP_CTRL_COPY, 0, out);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_cd_c", "target": 0, "func": "CMS_ContentInfo *cms_CompressedData_create(int comp_nid)\\r\\n{\\r\\nCMS_ContentInfo *cms;\\r\\nCMS_CompressedData *cd;\\r\\nif (comp_nid != NID_zlib_compression) {\\r\\nCMSerr(CMS_F_CMS_COMPRESSEDDATA_CREATE,\\r\\nCMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\\r\\nreturn NULL;\\r\\n}\\r\\ncms = CMS_ContentInfo_new();\\r\\nif (!cms)\\r\\nreturn NULL;\\r\\ncd = M_ASN1_new_of(CMS_CompressedData);\\r\\nif (!cd)\\r\\ngoto err;\\r\\ncms->contentType = OBJ_nid2obj(NID_id_smime_ct_compressedData);\\r\\ncms->d.compressedData = cd;\\r\\ncd->version = 0;\\r\\nX509_ALGOR_set0(cd->compressionAlgorithm,\\r\\nOBJ_nid2obj(NID_zlib_compression), V_ASN1_UNDEF, NULL);\\r\\ncd->encapContentInfo->eContentType = OBJ_nid2obj(NID_pkcs7_data);\\r\\nreturn cms;\\r\\nerr:\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nreturn NULL;\\r\\n}\\r\\nBIO *cms_CompressedData_init_bio(CMS_ContentInfo *cms)\\r\\n{\\r\\nCMS_CompressedData *cd;\\r\\nASN1_OBJECT *compoid;\\r\\nif (OBJ_obj2nid(cms->contentType) != NID_id_smime_ct_compressedData) {\\r\\nCMSerr(CMS_F_CMS_COMPRESSEDDATA_INIT_BIO,\\r\\nCMS_R_CONTENT_TYPE_NOT_COMPRESSED_DATA);\\r\\nreturn NULL;\\r\\n}\\r\\ncd = cms->d.compressedData;\\r\\nX509_ALGOR_get0(&compoid, NULL, NULL, cd->compressionAlgorithm);\\r\\nif (OBJ_obj2nid(compoid) != NID_zlib_compression) {\\r\\nCMSerr(CMS_F_CMS_COMPRESSEDDATA_INIT_BIO,\\r\\nCMS_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn BIO_new(BIO_f_zlib());\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_err_all_c", "target": 0, "func": "void ERR_load_crypto_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_ERR_strings();\\r\\nERR_load_BN_strings();\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nERR_load_RSA_strings();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DH\\r\\nERR_load_DH_strings();\\r\\n# endif\\r\\nERR_load_EVP_strings();\\r\\nERR_load_BUF_strings();\\r\\nERR_load_OBJ_strings();\\r\\nERR_load_PEM_strings();\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nERR_load_DSA_strings();\\r\\n# endif\\r\\nERR_load_X509_strings();\\r\\nERR_load_ASN1_strings();\\r\\nERR_load_CONF_strings();\\r\\nERR_load_CRYPTO_strings();\\r\\n# ifndef OPENSSL_NO_COMP\\r\\nERR_load_COMP_strings();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_EC\\r\\nERR_load_EC_strings();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ECDSA\\r\\nERR_load_ECDSA_strings();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ECDH\\r\\nERR_load_ECDH_strings();\\r\\n# endif\\r\\nERR_load_BIO_strings();\\r\\nERR_load_PKCS7_strings();\\r\\nERR_load_X509V3_strings();\\r\\nERR_load_PKCS12_strings();\\r\\nERR_load_RAND_strings();\\r\\nERR_load_DSO_strings();\\r\\nERR_load_TS_strings();\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nERR_load_ENGINE_strings();\\r\\n# endif\\r\\nERR_load_OCSP_strings();\\r\\nERR_load_UI_strings();\\r\\n# ifdef OPENSSL_FIPS\\r\\nERR_load_FIPS_strings();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CMS\\r\\nERR_load_CMS_strings();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_JPAKE\\r\\nERR_load_JPAKE_strings();\\r\\n# endif\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_d1_lib_c", "target": 0, "func": "long dtls1_default_timeout(void)\\r\\n{\\r\\nreturn (60 * 60 * 2);\\r\\n}\\r\\nint dtls1_new(SSL *s)\\r\\n{\\r\\nDTLS1_STATE *d1;\\r\\nif (!ssl3_new(s))\\r\\nreturn (0);\\r\\nif ((d1 = OPENSSL_malloc(sizeof *d1)) == NULL)\\r\\nreturn (0);\\r\\nmemset(d1, 0, sizeof *d1);\\r\\nd1->unprocessed_rcds.q = pqueue_new();\\r\\nd1->processed_rcds.q = pqueue_new();\\r\\nd1->buffered_messages = pqueue_new();\\r\\nd1->sent_messages = pqueue_new();\\r\\nd1->buffered_app_data.q = pqueue_new();\\r\\nif (s->server) {\\r\\nd1->cookie_len = sizeof(s->d1->cookie);\\r\\n}\\r\\nd1->link_mtu = 0;\\r\\nd1->mtu = 0;\\r\\nif (!d1->unprocessed_rcds.q || !d1->processed_rcds.q\\r\\n|| !d1->buffered_messages || !d1->sent_messages\\r\\n|| !d1->buffered_app_data.q) {\\r\\nif (d1->unprocessed_rcds.q)\\r\\npqueue_free(d1->unprocessed_rcds.q);\\r\\nif (d1->processed_rcds.q)\\r\\npqueue_free(d1->processed_rcds.q);\\r\\nif (d1->buffered_messages)\\r\\npqueue_free(d1->buffered_messages);\\r\\nif (d1->sent_messages)\\r\\npqueue_free(d1->sent_messages);\\r\\nif (d1->buffered_app_data.q)\\r\\npqueue_free(d1->buffered_app_data.q);\\r\\nOPENSSL_free(d1);\\r\\nreturn (0);\\r\\n}\\r\\ns->d1 = d1;\\r\\ns->method->ssl_clear(s);\\r\\nreturn (1);\\r\\n}\\r\\nstatic void dtls1_clear_queues(SSL *s)\\r\\n{\\r\\npitem *item = NULL;\\r\\nhm_fragment *frag = NULL;\\r\\nDTLS1_RECORD_DATA *rdata;\\r\\nwhile ((item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL) {\\r\\nrdata = (DTLS1_RECORD_DATA *)item->data;\\r\\nif (rdata->rbuf.buf) {\\r\\nOPENSSL_free(rdata->rbuf.buf);\\r\\n}\\r\\nOPENSSL_free(item->data);\\r\\npitem_free(item);\\r\\n}\\r\\nwhile ((item = pqueue_pop(s->d1->processed_rcds.q)) != NULL) {\\r\\nrdata = (DTLS1_RECORD_DATA *)item->data;\\r\\nif (rdata->rbuf.buf) {\\r\\nOPENSSL_free(rdata->rbuf.buf);\\r\\n}\\r\\nOPENSSL_free(item->data);\\r\\npitem_free(item);\\r\\n}\\r\\nwhile ((item = pqueue_pop(s->d1->buffered_messages)) != NULL) {\\r\\nfrag = (hm_fragment *)item->data;\\r\\ndtls1_hm_fragment_free(frag);\\r\\npitem_free(item);\\r\\n}\\r\\nwhile ((item = pqueue_pop(s->d1->sent_messages)) != NULL) {\\r\\nfrag = (hm_fragment *)item->data;\\r\\ndtls1_hm_fragment_free(frag);\\r\\npitem_free(item);\\r\\n}\\r\\nwhile ((item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL) {\\r\\nrdata = (DTLS1_RECORD_DATA *)item->data;\\r\\nif (rdata->rbuf.buf) {\\r\\nOPENSSL_free(rdata->rbuf.buf);\\r\\n}\\r\\nOPENSSL_free(item->data);\\r\\npitem_free(item);\\r\\n}\\r\\n}\\r\\nvoid dtls1_free(SSL *s)\\r\\n{\\r\\nssl3_free(s);\\r\\ndtls1_clear_queues(s);\\r\\npqueue_free(s->d1->unprocessed_rcds.q);\\r\\npqueue_free(s->d1->processed_rcds.q);\\r\\npqueue_free(s->d1->buffered_messages);\\r\\npqueue_free(s->d1->sent_messages);\\r\\npqueue_free(s->d1->buffered_app_data.q);\\r\\nOPENSSL_free(s->d1);\\r\\ns->d1 = NULL;\\r\\n}\\r\\nvoid dtls1_clear(SSL *s)\\r\\n{\\r\\npqueue unprocessed_rcds;\\r\\npqueue processed_rcds;\\r\\npqueue buffered_messages;\\r\\npqueue sent_messages;\\r\\npqueue buffered_app_data;\\r\\nunsigned int mtu;\\r\\nunsigned int link_mtu;\\r\\nif (s->d1) {\\r\\nunprocessed_rcds = s->d1->unprocessed_rcds.q;\\r\\nprocessed_rcds = s->d1->processed_rcds.q;\\r\\nbuffered_messages = s->d1->buffered_messages;\\r\\nsent_messages = s->d1->sent_messages;\\r\\nbuffered_app_data = s->d1->buffered_app_data.q;\\r\\nmtu = s->d1->mtu;\\r\\nlink_mtu = s->d1->link_mtu;\\r\\ndtls1_clear_queues(s);\\r\\nmemset(s->d1, 0, sizeof(*(s->d1)));\\r\\nif (s->server) {\\r\\ns->d1->cookie_len = sizeof(s->d1->cookie);\\r\\n}\\r\\nif (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU) {\\r\\ns->d1->mtu = mtu;\\r\\ns->d1->link_mtu = link_mtu;\\r\\n}\\r\\ns->d1->unprocessed_rcds.q = unprocessed_rcds;\\r\\ns->d1->processed_rcds.q = processed_rcds;\\r\\ns->d1->buffered_messages = buffered_messages;\\r\\ns->d1->sent_messages = sent_messages;\\r\\ns->d1->buffered_app_data.q = buffered_app_data;\\r\\n}\\r\\nssl3_clear(s);\\r\\nif (s->options & SSL_OP_CISCO_ANYCONNECT)\\r\\ns->version = DTLS1_BAD_VER;\\r\\nelse if (s->method->version == DTLS_ANY_VERSION)\\r\\ns->version = DTLS1_2_VERSION;\\r\\nelse\\r\\ns->version = s->method->version;\\r\\n}\\r\\nlong dtls1_ctrl(SSL *s, int cmd, long larg, void *parg)\\r\\n{\\r\\nint ret = 0;\\r\\nswitch (cmd) {\\r\\ncase DTLS_CTRL_GET_TIMEOUT:\\r\\nif (dtls1_get_timeout(s, (struct timeval *)parg) != NULL) {\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase DTLS_CTRL_HANDLE_TIMEOUT:\\r\\nret = dtls1_handle_timeout(s);\\r\\nbreak;\\r\\ncase DTLS_CTRL_LISTEN:\\r\\nret = dtls1_listen(s, parg);\\r\\nbreak;\\r\\ncase SSL_CTRL_CHECK_PROTO_VERSION:\\r\\nif (s->version == s->ctx->method->version)\\r\\nreturn 1;\\r\\nif (s->ctx->method->version == DTLS_method()->version) {\\r\\n#if DTLS_MAX_VERSION != DTLS1_2_VERSION\\r\\n# error Code needs update for DTLS_method() support beyond DTLS1_2_VERSION.\\r\\n#endif\\r\\nif (!(s->options & SSL_OP_NO_DTLSv1_2))\\r\\nreturn s->version == DTLS1_2_VERSION;\\r\\nif (!(s->options & SSL_OP_NO_DTLSv1))\\r\\nreturn s->version == DTLS1_VERSION;\\r\\n}\\r\\nreturn 0;\\r\\ncase DTLS_CTRL_SET_LINK_MTU:\\r\\nif (larg < (long)dtls1_link_min_mtu())\\r\\nreturn 0;\\r\\ns->d1->link_mtu = larg;\\r\\nreturn 1;\\r\\ncase DTLS_CTRL_GET_LINK_MIN_MTU:\\r\\nreturn (long)dtls1_link_min_mtu();\\r\\ncase SSL_CTRL_SET_MTU:\\r\\nif (larg < (long)dtls1_link_min_mtu() - DTLS1_MAX_MTU_OVERHEAD)\\r\\nreturn 0;\\r\\ns->d1->mtu = larg;\\r\\nreturn larg;\\r\\ndefault:\\r\\nret = ssl3_ctrl(s, cmd, larg, parg);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nconst SSL_CIPHER *dtls1_get_cipher(unsigned int u)\\r\\n{\\r\\nconst SSL_CIPHER *ciph = ssl3_get_cipher(u);\\r\\nif (ciph != NULL) {\\r\\nif (ciph->algorithm_enc == SSL_RC4)\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ciph;\\r\\n}\\r\\nvoid dtls1_start_timer(SSL *s)\\r\\n{\\r\\n#ifndef OPENSSL_NO_SCTP\\r\\nif (BIO_dgram_is_sctp(SSL_get_wbio(s))) {\\r\\nmemset(&(s->d1->next_timeout), 0, sizeof(struct timeval));\\r\\nreturn;\\r\\n}\\r\\n#endif\\r\\nif (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) {\\r\\ns->d1->timeout_duration = 1;\\r\\n}\\r\\nget_current_time(&(s->d1->next_timeout));\\r\\ns->d1->next_timeout.tv_sec += s->d1->timeout_duration;\\r\\nBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,\\r\\n&(s->d1->next_timeout));\\r\\n}\\r\\nstruct timeval *dtls1_get_timeout(SSL *s, struct timeval *timeleft)\\r\\n{\\r\\nstruct timeval timenow;\\r\\nif (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) {\\r\\nreturn NULL;\\r\\n}\\r\\nget_current_time(&timenow);\\r\\nif (s->d1->next_timeout.tv_sec < timenow.tv_sec ||\\r\\n(s->d1->next_timeout.tv_sec == timenow.tv_sec &&\\r\\ns->d1->next_timeout.tv_usec <= timenow.tv_usec)) {\\r\\nmemset(timeleft, 0, sizeof(struct timeval));\\r\\nreturn timeleft;\\r\\n}\\r\\nmemcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));\\r\\ntimeleft->tv_sec -= timenow.tv_sec;\\r\\ntimeleft->tv_usec -= timenow.tv_usec;\\r\\nif (timeleft->tv_usec < 0) {\\r\\ntimeleft->tv_sec--;\\r\\ntimeleft->tv_usec += 1000000;\\r\\n}\\r\\nif (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000) {\\r\\nmemset(timeleft, 0, sizeof(struct timeval));\\r\\n}\\r\\nreturn timeleft;\\r\\n}\\r\\nint dtls1_is_timer_expired(SSL *s)\\r\\n{\\r\\nstruct timeval timeleft;\\r\\nif (dtls1_get_timeout(s, &timeleft) == NULL) {\\r\\nreturn 0;\\r\\n}\\r\\nif (timeleft.tv_sec > 0 || timeleft.tv_usec > 0) {\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid dtls1_double_timeout(SSL *s)\\r\\n{\\r\\ns->d1->timeout_duration *= 2;\\r\\nif (s->d1->timeout_duration > 60)\\r\\ns->d1->timeout_duration = 60;\\r\\ndtls1_start_timer(s);\\r\\n}\\r\\nvoid dtls1_stop_timer(SSL *s)\\r\\n{\\r\\nmemset(&(s->d1->timeout), 0, sizeof(struct dtls1_timeout_st));\\r\\nmemset(&(s->d1->next_timeout), 0, sizeof(struct timeval));\\r\\ns->d1->timeout_duration = 1;\\r\\nBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,\\r\\n&(s->d1->next_timeout));\\r\\ndtls1_clear_record_buffer(s);\\r\\n}\\r\\nint dtls1_check_timeout_num(SSL *s)\\r\\n{\\r\\nunsigned int mtu;\\r\\ns->d1->timeout.num_alerts++;\\r\\nif (s->d1->timeout.num_alerts > 2\\r\\n&& !(SSL_get_options(s) & SSL_OP_NO_QUERY_MTU)) {\\r\\nmtu =\\r\\nBIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_GET_FALLBACK_MTU, 0,\\r\\nNULL);\\r\\nif (mtu < s->d1->mtu)\\r\\ns->d1->mtu = mtu;\\r\\n}\\r\\nif (s->d1->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT) {\\r\\nSSLerr(SSL_F_DTLS1_CHECK_TIMEOUT_NUM, SSL_R_READ_TIMEOUT_EXPIRED);\\r\\nreturn -1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint dtls1_handle_timeout(SSL *s)\\r\\n{\\r\\nif (!dtls1_is_timer_expired(s)) {\\r\\nreturn 0;\\r\\n}\\r\\ndtls1_double_timeout(s);\\r\\nif (dtls1_check_timeout_num(s) < 0)\\r\\nreturn -1;\\r\\ns->d1->timeout.read_timeouts++;\\r\\nif (s->d1->timeout.read_timeouts > DTLS1_TMO_READ_COUNT) {\\r\\ns->d1->timeout.read_timeouts = 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_HEARTBEATS\\r\\nif (s->tlsext_hb_pending) {\\r\\ns->tlsext_hb_pending = 0;\\r\\nreturn dtls1_heartbeat(s);\\r\\n}\\r\\n#endif\\r\\ndtls1_start_timer(s);\\r\\nreturn dtls1_retransmit_buffered_messages(s);\\r\\n}\\r\\nstatic void get_current_time(struct timeval *t)\\r\\n{\\r\\n#if defined(_WIN32)\\r\\nSYSTEMTIME st;\\r\\nunion {\\r\\nunsigned __int64 ul;\\r\\nFILETIME ft;\\r\\n} now;\\r\\nGetSystemTime(&st);\\r\\nSystemTimeToFileTime(&st, &now.ft);\\r\\n# ifdef __MINGW32__\\r\\nnow.ul -= 116444736000000000ULL;\\r\\n# else\\r\\nnow.ul -= 116444736000000000UI64;\\r\\n# endif\\r\\nt->tv_sec = (long)(now.ul / 10000000);\\r\\nt->tv_usec = ((int)(now.ul % 10000000)) / 10;\\r\\n#elif defined(OPENSSL_SYS_VMS)\\r\\nstruct timeb tb;\\r\\nftime(&tb);\\r\\nt->tv_sec = (long)tb.time;\\r\\nt->tv_usec = (long)tb.millitm * 1000;\\r\\n#else\\r\\ngettimeofday(t, NULL);\\r\\n#endif\\r\\n}\\r\\nint dtls1_listen(SSL *s, struct sockaddr *client)\\r\\n{\\r\\nint ret;\\r\\nSSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);\\r\\ns->d1->listen = 1;\\r\\nret = SSL_accept(s);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\n(void)BIO_dgram_get_peer(SSL_get_rbio(s), client);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void dtls1_set_handshake_header(SSL *s, int htype, unsigned long len)\\r\\n{\\r\\nunsigned char *p = (unsigned char *)s->init_buf->data;\\r\\ndtls1_set_message_header(s, p, htype, len, 0, len);\\r\\ns->init_num = (int)len + DTLS1_HM_HEADER_LENGTH;\\r\\ns->init_off = 0;\\r\\ndtls1_buffer_message(s, 0);\\r\\n}\\r\\nstatic int dtls1_handshake_write(SSL *s)\\r\\n{\\r\\nreturn dtls1_do_write(s, SSL3_RT_HANDSHAKE);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_asn1_c", "target": 0, "func": "static int cms_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nASN1_STREAM_ARG *sarg = exarg;\\r\\nCMS_ContentInfo *cms = NULL;\\r\\nif (pval)\\r\\ncms = (CMS_ContentInfo *)*pval;\\r\\nelse\\r\\nreturn 1;\\r\\nswitch (operation) {\\r\\ncase ASN1_OP_STREAM_PRE:\\r\\nif (CMS_stream(&sarg->boundary, cms) <= 0)\\r\\nreturn 0;\\r\\ncase ASN1_OP_DETACHED_PRE:\\r\\nsarg->ndef_bio = CMS_dataInit(cms, sarg->out);\\r\\nif (!sarg->ndef_bio)\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase ASN1_OP_STREAM_POST:\\r\\ncase ASN1_OP_DETACHED_POST:\\r\\nif (CMS_dataFinal(cms, sarg->ndef_bio) <= 0)\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rpc_enc_c", "target": 0, "func": "int _des_crypt(char *buf, int len, struct desparams *desp)\\r\\n{\\r\\nDES_key_schedule ks;\\r\\nint enc;\\r\\nDES_set_key_unchecked(&desp->des_key, &ks);\\r\\nenc = (desp->des_dir == ENCRYPT) ? DES_ENCRYPT : DES_DECRYPT;\\r\\nif (desp->des_mode == CBC)\\r\\nDES_ecb_encrypt((const_DES_cblock *)desp->UDES.UDES_buf,\\r\\n(DES_cblock *)desp->UDES.UDES_buf, &ks, enc);\\r\\nelse {\\r\\nDES_ncbc_encrypt(desp->UDES.UDES_buf, desp->UDES.UDES_buf,\\r\\nlen, &ks, &desp->des_ivec, enc);\\r\\n#ifdef undef\\r\\na = (char *)&(desp->UDES.UDES_buf[len - 8]);\\r\\nb = (char *)&(desp->des_ivec[0]);\\r\\n*(a++) = *(b++);\\r\\n*(a++) = *(b++);\\r\\n*(a++) = *(b++);\\r\\n*(a++) = *(b++);\\r\\n*(a++) = *(b++);\\r\\n*(a++) = *(b++);\\r\\n*(a++) = *(b++);\\r\\n*(a++) = *(b++);\\r\\n#endif\\r\\n}\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_prime_c", "target": 0, "func": "int BN_GENCB_call(BN_GENCB *cb, int a, int b)\\r\\n{\\r\\nif (!cb)\\r\\nreturn 1;\\r\\nswitch (cb->ver) {\\r\\ncase 1:\\r\\nif (!cb->cb.cb_1)\\r\\nreturn 1;\\r\\ncb->cb.cb_1(a, b, cb->arg);\\r\\nreturn 1;\\r\\ncase 2:\\r\\nreturn cb->cb.cb_2(a, b, cb);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint BN_generate_prime_ex(BIGNUM *ret, int bits, int safe,\\r\\nconst BIGNUM *add, const BIGNUM *rem, BN_GENCB *cb)\\r\\n{\\r\\nBIGNUM *t;\\r\\nint found = 0;\\r\\nint i, j, c1 = 0;\\r\\nBN_CTX *ctx;\\r\\nint checks = BN_prime_checks_for_size(bits);\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\nBN_CTX_start(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\nif (!t)\\r\\ngoto err;\\r\\nloop:\\r\\nif (add == NULL) {\\r\\nif (!probable_prime(ret, bits))\\r\\ngoto err;\\r\\n} else {\\r\\nif (safe) {\\r\\nif (!probable_prime_dh_safe(ret, bits, add, rem, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!probable_prime_dh(ret, bits, add, rem, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_GENCB_call(cb, 0, c1++))\\r\\ngoto err;\\r\\nif (!safe) {\\r\\ni = BN_is_prime_fasttest_ex(ret, checks, ctx, 0, cb);\\r\\nif (i == -1)\\r\\ngoto err;\\r\\nif (i == 0)\\r\\ngoto loop;\\r\\n} else {\\r\\nif (!BN_rshift1(t, ret))\\r\\ngoto err;\\r\\nfor (i = 0; i < checks; i++) {\\r\\nj = BN_is_prime_fasttest_ex(ret, 1, ctx, 0, cb);\\r\\nif (j == -1)\\r\\ngoto err;\\r\\nif (j == 0)\\r\\ngoto loop;\\r\\nj = BN_is_prime_fasttest_ex(t, 1, ctx, 0, cb);\\r\\nif (j == -1)\\r\\ngoto err;\\r\\nif (j == 0)\\r\\ngoto loop;\\r\\nif (!BN_GENCB_call(cb, 2, c1 - 1))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nfound = 1;\\r\\nerr:\\r\\nif (ctx != NULL) {\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nbn_check_top(ret);\\r\\nreturn found;\\r\\n}\\r\\nint BN_is_prime_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed,\\r\\nBN_GENCB *cb)\\r\\n{\\r\\nreturn BN_is_prime_fasttest_ex(a, checks, ctx_passed, 0, cb);\\r\\n}\\r\\nint BN_is_prime_fasttest_ex(const BIGNUM *a, int checks, BN_CTX *ctx_passed,\\r\\nint do_trial_division, BN_GENCB *cb)\\r\\n{\\r\\nint i, j, ret = -1;\\r\\nint k;\\r\\nBN_CTX *ctx = NULL;\\r\\nBIGNUM *A1, *A1_odd, *check;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nconst BIGNUM *A = NULL;\\r\\nif (BN_cmp(a, BN_value_one()) <= 0)\\r\\nreturn 0;\\r\\nif (checks == BN_prime_checks)\\r\\nchecks = BN_prime_checks_for_size(BN_num_bits(a));\\r\\nif (!BN_is_odd(a))\\r\\nreturn BN_is_word(a, 2);\\r\\nif (do_trial_division) {\\r\\nfor (i = 1; i < NUMPRIMES; i++)\\r\\nif (BN_mod_word(a, primes[i]) == 0)\\r\\nreturn 0;\\r\\nif (!BN_GENCB_call(cb, 1, -1))\\r\\ngoto err;\\r\\n}\\r\\nif (ctx_passed != NULL)\\r\\nctx = ctx_passed;\\r\\nelse if ((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nBN_CTX_start(ctx);\\r\\nif (a->neg) {\\r\\nBIGNUM *t;\\r\\nif ((t = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nBN_copy(t, a);\\r\\nt->neg = 0;\\r\\nA = t;\\r\\n} else\\r\\nA = a;\\r\\nA1 = BN_CTX_get(ctx);\\r\\nA1_odd = BN_CTX_get(ctx);\\r\\ncheck = BN_CTX_get(ctx);\\r\\nif (check == NULL)\\r\\ngoto err;\\r\\nif (!BN_copy(A1, A))\\r\\ngoto err;\\r\\nif (!BN_sub_word(A1, 1))\\r\\ngoto err;\\r\\nif (BN_is_zero(A1)) {\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nk = 1;\\r\\nwhile (!BN_is_bit_set(A1, k))\\r\\nk++;\\r\\nif (!BN_rshift(A1_odd, A1, k))\\r\\ngoto err;\\r\\nmont = BN_MONT_CTX_new();\\r\\nif (mont == NULL)\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(mont, A, ctx))\\r\\ngoto err;\\r\\nfor (i = 0; i < checks; i++) {\\r\\nif (!BN_pseudo_rand_range(check, A1))\\r\\ngoto err;\\r\\nif (!BN_add_word(check, 1))\\r\\ngoto err;\\r\\nj = witness(check, A, A1, A1_odd, k, ctx, mont);\\r\\nif (j == -1)\\r\\ngoto err;\\r\\nif (j) {\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_GENCB_call(cb, 1, i))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx != NULL) {\\r\\nBN_CTX_end(ctx);\\r\\nif (ctx_passed == NULL)\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nif (mont != NULL)\\r\\nBN_MONT_CTX_free(mont);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int witness(BIGNUM *w, const BIGNUM *a, const BIGNUM *a1,\\r\\nconst BIGNUM *a1_odd, int k, BN_CTX *ctx,\\r\\nBN_MONT_CTX *mont)\\r\\n{\\r\\nif (!BN_mod_exp_mont(w, w, a1_odd, a, ctx, mont))\\r\\nreturn -1;\\r\\nif (BN_is_one(w))\\r\\nreturn 0;\\r\\nif (BN_cmp(w, a1) == 0)\\r\\nreturn 0;\\r\\nwhile (--k) {\\r\\nif (!BN_mod_mul(w, w, w, a, ctx))\\r\\nreturn -1;\\r\\nif (BN_is_one(w))\\r\\nreturn 1;\\r\\nif (BN_cmp(w, a1) == 0)\\r\\nreturn 0;\\r\\n}\\r\\nbn_check_top(w);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int probable_prime(BIGNUM *rnd, int bits)\\r\\n{\\r\\nint i;\\r\\nprime_t mods[NUMPRIMES];\\r\\nBN_ULONG delta, maxdelta;\\r\\nagain:\\r\\nif (!BN_rand(rnd, bits, 1, 1))\\r\\nreturn (0);\\r\\nfor (i = 1; i < NUMPRIMES; i++)\\r\\nmods[i] = (prime_t) BN_mod_word(rnd, (BN_ULONG)primes[i]);\\r\\nmaxdelta = BN_MASK2 - primes[NUMPRIMES - 1];\\r\\ndelta = 0;\\r\\nloop:for (i = 1; i < NUMPRIMES; i++) {\\r\\nif (((mods[i] + delta) % primes[i]) <= 1) {\\r\\ndelta += 2;\\r\\nif (delta > maxdelta)\\r\\ngoto again;\\r\\ngoto loop;\\r\\n}\\r\\n}\\r\\nif (!BN_add_word(rnd, delta))\\r\\nreturn (0);\\r\\nbn_check_top(rnd);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int probable_prime_dh(BIGNUM *rnd, int bits,\\r\\nconst BIGNUM *add, const BIGNUM *rem,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint i, ret = 0;\\r\\nBIGNUM *t1;\\r\\nBN_CTX_start(ctx);\\r\\nif ((t1 = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_rand(rnd, bits, 0, 1))\\r\\ngoto err;\\r\\nif (!BN_mod(t1, rnd, add, ctx))\\r\\ngoto err;\\r\\nif (!BN_sub(rnd, rnd, t1))\\r\\ngoto err;\\r\\nif (rem == NULL) {\\r\\nif (!BN_add_word(rnd, 1))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_add(rnd, rnd, rem))\\r\\ngoto err;\\r\\n}\\r\\nloop:for (i = 1; i < NUMPRIMES; i++) {\\r\\nif (BN_mod_word(rnd, (BN_ULONG)primes[i]) <= 1) {\\r\\nif (!BN_add(rnd, rnd, add))\\r\\ngoto err;\\r\\ngoto loop;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(rnd);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int probable_prime_dh_safe(BIGNUM *p, int bits, const BIGNUM *padd,\\r\\nconst BIGNUM *rem, BN_CTX *ctx)\\r\\n{\\r\\nint i, ret = 0;\\r\\nBIGNUM *t1, *qadd, *q;\\r\\nbits--;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nq = BN_CTX_get(ctx);\\r\\nqadd = BN_CTX_get(ctx);\\r\\nif (qadd == NULL)\\r\\ngoto err;\\r\\nif (!BN_rshift1(qadd, padd))\\r\\ngoto err;\\r\\nif (!BN_rand(q, bits, 0, 1))\\r\\ngoto err;\\r\\nif (!BN_mod(t1, q, qadd, ctx))\\r\\ngoto err;\\r\\nif (!BN_sub(q, q, t1))\\r\\ngoto err;\\r\\nif (rem == NULL) {\\r\\nif (!BN_add_word(q, 1))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_rshift1(t1, rem))\\r\\ngoto err;\\r\\nif (!BN_add(q, q, t1))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_lshift1(p, q))\\r\\ngoto err;\\r\\nif (!BN_add_word(p, 1))\\r\\ngoto err;\\r\\nloop:for (i = 1; i < NUMPRIMES; i++) {\\r\\nif ((BN_mod_word(p, (BN_ULONG)primes[i]) == 0) ||\\r\\n(BN_mod_word(q, (BN_ULONG)primes[i]) == 0)) {\\r\\nif (!BN_add(p, p, padd))\\r\\ngoto err;\\r\\nif (!BN_add(q, q, qadd))\\r\\ngoto err;\\r\\ngoto loop;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(p);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_gcm128_c", "target": 0, "func": "static void gcm_init_8bit(u128 Htable[256], u64 H[2])\\r\\n{\\r\\nint i, j;\\r\\nu128 V;\\r\\nHtable[0].hi = 0;\\r\\nHtable[0].lo = 0;\\r\\nV.hi = H[0];\\r\\nV.lo = H[1];\\r\\nfor (Htable[128] = V, i = 64; i > 0; i >>= 1) {\\r\\nREDUCE1BIT(V);\\r\\nHtable[i] = V;\\r\\n}\\r\\nfor (i = 2; i < 256; i <<= 1) {\\r\\nu128 *Hi = Htable + i, H0 = *Hi;\\r\\nfor (j = 1; j < i; ++j) {\\r\\nHi[j].hi = H0.hi ^ Htable[j].hi;\\r\\nHi[j].lo = H0.lo ^ Htable[j].lo;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic void gcm_gmult_8bit(u64 Xi[2], const u128 Htable[256])\\r\\n{\\r\\nu128 Z = { 0, 0 };\\r\\nconst u8 *xi = (const u8 *)Xi + 15;\\r\\nsize_t rem, n = *xi;\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nstatic const size_t rem_8bit[256] = {\\r\\nPACK(0x0000), PACK(0x01C2), PACK(0x0384), PACK(0x0246),\\r\\nPACK(0x0708), PACK(0x06CA), PACK(0x048C), PACK(0x054E),\\r\\nPACK(0x0E10), PACK(0x0FD2), PACK(0x0D94), PACK(0x0C56),\\r\\nPACK(0x0918), PACK(0x08DA), PACK(0x0A9C), PACK(0x0B5E),\\r\\nPACK(0x1C20), PACK(0x1DE2), PACK(0x1FA4), PACK(0x1E66),\\r\\nPACK(0x1B28), PACK(0x1AEA), PACK(0x18AC), PACK(0x196E),\\r\\nPACK(0x1230), PACK(0x13F2), PACK(0x11B4), PACK(0x1076),\\r\\nPACK(0x1538), PACK(0x14FA), PACK(0x16BC), PACK(0x177E),\\r\\nPACK(0x3840), PACK(0x3982), PACK(0x3BC4), PACK(0x3A06),\\r\\nPACK(0x3F48), PACK(0x3E8A), PACK(0x3CCC), PACK(0x3D0E),\\r\\nPACK(0x3650), PACK(0x3792), PACK(0x35D4), PACK(0x3416),\\r\\nPACK(0x3158), PACK(0x309A), PACK(0x32DC), PACK(0x331E),\\r\\nPACK(0x2460), PACK(0x25A2), PACK(0x27E4), PACK(0x2626),\\r\\nPACK(0x2368), PACK(0x22AA), PACK(0x20EC), PACK(0x212E),\\r\\nPACK(0x2A70), PACK(0x2BB2), PACK(0x29F4), PACK(0x2836),\\r\\nPACK(0x2D78), PACK(0x2CBA), PACK(0x2EFC), PACK(0x2F3E),\\r\\nPACK(0x7080), PACK(0x7142), PACK(0x7304), PACK(0x72C6),\\r\\nPACK(0x7788), PACK(0x764A), PACK(0x740C), PACK(0x75CE),\\r\\nPACK(0x7E90), PACK(0x7F52), PACK(0x7D14), PACK(0x7CD6),\\r\\nPACK(0x7998), PACK(0x785A), PACK(0x7A1C), PACK(0x7BDE),\\r\\nPACK(0x6CA0), PACK(0x6D62), PACK(0x6F24), PACK(0x6EE6),\\r\\nPACK(0x6BA8), PACK(0x6A6A), PACK(0x682C), PACK(0x69EE),\\r\\nPACK(0x62B0), PACK(0x6372), PACK(0x6134), PACK(0x60F6),\\r\\nPACK(0x65B8), PACK(0x647A), PACK(0x663C), PACK(0x67FE),\\r\\nPACK(0x48C0), PACK(0x4902), PACK(0x4B44), PACK(0x4A86),\\r\\nPACK(0x4FC8), PACK(0x4E0A), PACK(0x4C4C), PACK(0x4D8E),\\r\\nPACK(0x46D0), PACK(0x4712), PACK(0x4554), PACK(0x4496),\\r\\nPACK(0x41D8), PACK(0x401A), PACK(0x425C), PACK(0x439E),\\r\\nPACK(0x54E0), PACK(0x5522), PACK(0x5764), PACK(0x56A6),\\r\\nPACK(0x53E8), PACK(0x522A), PACK(0x506C), PACK(0x51AE),\\r\\nPACK(0x5AF0), PACK(0x5B32), PACK(0x5974), PACK(0x58B6),\\r\\nPACK(0x5DF8), PACK(0x5C3A), PACK(0x5E7C), PACK(0x5FBE),\\r\\nPACK(0xE100), PACK(0xE0C2), PACK(0xE284), PACK(0xE346),\\r\\nPACK(0xE608), PACK(0xE7CA), PACK(0xE58C), PACK(0xE44E),\\r\\nPACK(0xEF10), PACK(0xEED2), PACK(0xEC94), PACK(0xED56),\\r\\nPACK(0xE818), PACK(0xE9DA), PACK(0xEB9C), PACK(0xEA5E),\\r\\nPACK(0xFD20), PACK(0xFCE2), PACK(0xFEA4), PACK(0xFF66),\\r\\nPACK(0xFA28), PACK(0xFBEA), PACK(0xF9AC), PACK(0xF86E),\\r\\nPACK(0xF330), PACK(0xF2F2), PACK(0xF0B4), PACK(0xF176),\\r\\nPACK(0xF438), PACK(0xF5FA), PACK(0xF7BC), PACK(0xF67E),\\r\\nPACK(0xD940), PACK(0xD882), PACK(0xDAC4), PACK(0xDB06),\\r\\nPACK(0xDE48), PACK(0xDF8A), PACK(0xDDCC), PACK(0xDC0E),\\r\\nPACK(0xD750), PACK(0xD692), PACK(0xD4D4), PACK(0xD516),\\r\\nPACK(0xD058), PACK(0xD19A), PACK(0xD3DC), PACK(0xD21E),\\r\\nPACK(0xC560), PACK(0xC4A2), PACK(0xC6E4), PACK(0xC726),\\r\\nPACK(0xC268), PACK(0xC3AA), PACK(0xC1EC), PACK(0xC02E),\\r\\nPACK(0xCB70), PACK(0xCAB2), PACK(0xC8F4), PACK(0xC936),\\r\\nPACK(0xCC78), PACK(0xCDBA), PACK(0xCFFC), PACK(0xCE3E),\\r\\nPACK(0x9180), PACK(0x9042), PACK(0x9204), PACK(0x93C6),\\r\\nPACK(0x9688), PACK(0x974A), PACK(0x950C), PACK(0x94CE),\\r\\nPACK(0x9F90), PACK(0x9E52), PACK(0x9C14), PACK(0x9DD6),\\r\\nPACK(0x9898), PACK(0x995A), PACK(0x9B1C), PACK(0x9ADE),\\r\\nPACK(0x8DA0), PACK(0x8C62), PACK(0x8E24), PACK(0x8FE6),\\r\\nPACK(0x8AA8), PACK(0x8B6A), PACK(0x892C), PACK(0x88EE),\\r\\nPACK(0x83B0), PACK(0x8272), PACK(0x8034), PACK(0x81F6),\\r\\nPACK(0x84B8), PACK(0x857A), PACK(0x873C), PACK(0x86FE),\\r\\nPACK(0xA9C0), PACK(0xA802), PACK(0xAA44), PACK(0xAB86),\\r\\nPACK(0xAEC8), PACK(0xAF0A), PACK(0xAD4C), PACK(0xAC8E),\\r\\nPACK(0xA7D0), PACK(0xA612), PACK(0xA454), PACK(0xA596),\\r\\nPACK(0xA0D8), PACK(0xA11A), PACK(0xA35C), PACK(0xA29E),\\r\\nPACK(0xB5E0), PACK(0xB422), PACK(0xB664), PACK(0xB7A6),\\r\\nPACK(0xB2E8), PACK(0xB32A), PACK(0xB16C), PACK(0xB0AE),\\r\\nPACK(0xBBF0), PACK(0xBA32), PACK(0xB874), PACK(0xB9B6),\\r\\nPACK(0xBCF8), PACK(0xBD3A), PACK(0xBF7C), PACK(0xBEBE)\\r\\n};\\r\\nwhile (1) {\\r\\nZ.hi ^= Htable[n].hi;\\r\\nZ.lo ^= Htable[n].lo;\\r\\nif ((u8 *)Xi == xi)\\r\\nbreak;\\r\\nn = *(--xi);\\r\\nrem = (size_t)Z.lo & 0xff;\\r\\nZ.lo = (Z.hi << 56) | (Z.lo >> 8);\\r\\nZ.hi = (Z.hi >> 8);\\r\\nif (sizeof(size_t) == 8)\\r\\nZ.hi ^= rem_8bit[rem];\\r\\nelse\\r\\nZ.hi ^= (u64)rem_8bit[rem] << 32;\\r\\n}\\r\\nif (is_endian.little) {\\r\\n# ifdef BSWAP8\\r\\nXi[0] = BSWAP8(Z.hi);\\r\\nXi[1] = BSWAP8(Z.lo);\\r\\n# else\\r\\nu8 *p = (u8 *)Xi;\\r\\nu32 v;\\r\\nv = (u32)(Z.hi >> 32);\\r\\nPUTU32(p, v);\\r\\nv = (u32)(Z.hi);\\r\\nPUTU32(p + 4, v);\\r\\nv = (u32)(Z.lo >> 32);\\r\\nPUTU32(p + 8, v);\\r\\nv = (u32)(Z.lo);\\r\\nPUTU32(p + 12, v);\\r\\n# endif\\r\\n} else {\\r\\nXi[0] = Z.hi;\\r\\nXi[1] = Z.lo;\\r\\n}\\r\\n}\\r\\nstatic void gcm_init_4bit(u128 Htable[16], u64 H[2])\\r\\n{\\r\\nu128 V;\\r\\n# if defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nint i;\\r\\n# endif\\r\\nHtable[0].hi = 0;\\r\\nHtable[0].lo = 0;\\r\\nV.hi = H[0];\\r\\nV.lo = H[1];\\r\\n# if defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nfor (Htable[8] = V, i = 4; i > 0; i >>= 1) {\\r\\nREDUCE1BIT(V);\\r\\nHtable[i] = V;\\r\\n}\\r\\nfor (i = 2; i < 16; i <<= 1) {\\r\\nu128 *Hi = Htable + i;\\r\\nint j;\\r\\nfor (V = *Hi, j = 1; j < i; ++j) {\\r\\nHi[j].hi = V.hi ^ Htable[j].hi;\\r\\nHi[j].lo = V.lo ^ Htable[j].lo;\\r\\n}\\r\\n}\\r\\n# else\\r\\nHtable[8] = V;\\r\\nREDUCE1BIT(V);\\r\\nHtable[4] = V;\\r\\nREDUCE1BIT(V);\\r\\nHtable[2] = V;\\r\\nREDUCE1BIT(V);\\r\\nHtable[1] = V;\\r\\nHtable[3].hi = V.hi ^ Htable[2].hi, Htable[3].lo = V.lo ^ Htable[2].lo;\\r\\nV = Htable[4];\\r\\nHtable[5].hi = V.hi ^ Htable[1].hi, Htable[5].lo = V.lo ^ Htable[1].lo;\\r\\nHtable[6].hi = V.hi ^ Htable[2].hi, Htable[6].lo = V.lo ^ Htable[2].lo;\\r\\nHtable[7].hi = V.hi ^ Htable[3].hi, Htable[7].lo = V.lo ^ Htable[3].lo;\\r\\nV = Htable[8];\\r\\nHtable[9].hi = V.hi ^ Htable[1].hi, Htable[9].lo = V.lo ^ Htable[1].lo;\\r\\nHtable[10].hi = V.hi ^ Htable[2].hi, Htable[10].lo = V.lo ^ Htable[2].lo;\\r\\nHtable[11].hi = V.hi ^ Htable[3].hi, Htable[11].lo = V.lo ^ Htable[3].lo;\\r\\nHtable[12].hi = V.hi ^ Htable[4].hi, Htable[12].lo = V.lo ^ Htable[4].lo;\\r\\nHtable[13].hi = V.hi ^ Htable[5].hi, Htable[13].lo = V.lo ^ Htable[5].lo;\\r\\nHtable[14].hi = V.hi ^ Htable[6].hi, Htable[14].lo = V.lo ^ Htable[6].lo;\\r\\nHtable[15].hi = V.hi ^ Htable[7].hi, Htable[15].lo = V.lo ^ Htable[7].lo;\\r\\n# endif\\r\\n# if defined(GHASH_ASM) && (defined(__arm__) || defined(__arm))\\r\\n{\\r\\nint j;\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nif (is_endian.little)\\r\\nfor (j = 0; j < 16; ++j) {\\r\\nV = Htable[j];\\r\\nHtable[j].hi = V.lo;\\r\\nHtable[j].lo = V.hi;\\r\\n} else\\r\\nfor (j = 0; j < 16; ++j) {\\r\\nV = Htable[j];\\r\\nHtable[j].hi = V.lo << 32 | V.lo >> 32;\\r\\nHtable[j].lo = V.hi << 32 | V.hi >> 32;\\r\\n}\\r\\n}\\r\\n# endif\\r\\n}\\r\\nstatic void gcm_gmult_4bit(u64 Xi[2], const u128 Htable[16])\\r\\n{\\r\\nu128 Z;\\r\\nint cnt = 15;\\r\\nsize_t rem, nlo, nhi;\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nnlo = ((const u8 *)Xi)[15];\\r\\nnhi = nlo >> 4;\\r\\nnlo &= 0xf;\\r\\nZ.hi = Htable[nlo].hi;\\r\\nZ.lo = Htable[nlo].lo;\\r\\nwhile (1) {\\r\\nrem = (size_t)Z.lo & 0xf;\\r\\nZ.lo = (Z.hi << 60) | (Z.lo >> 4);\\r\\nZ.hi = (Z.hi >> 4);\\r\\nif (sizeof(size_t) == 8)\\r\\nZ.hi ^= rem_4bit[rem];\\r\\nelse\\r\\nZ.hi ^= (u64)rem_4bit[rem] << 32;\\r\\nZ.hi ^= Htable[nhi].hi;\\r\\nZ.lo ^= Htable[nhi].lo;\\r\\nif (--cnt < 0)\\r\\nbreak;\\r\\nnlo = ((const u8 *)Xi)[cnt];\\r\\nnhi = nlo >> 4;\\r\\nnlo &= 0xf;\\r\\nrem = (size_t)Z.lo & 0xf;\\r\\nZ.lo = (Z.hi << 60) | (Z.lo >> 4);\\r\\nZ.hi = (Z.hi >> 4);\\r\\nif (sizeof(size_t) == 8)\\r\\nZ.hi ^= rem_4bit[rem];\\r\\nelse\\r\\nZ.hi ^= (u64)rem_4bit[rem] << 32;\\r\\nZ.hi ^= Htable[nlo].hi;\\r\\nZ.lo ^= Htable[nlo].lo;\\r\\n}\\r\\nif (is_endian.little) {\\r\\n# ifdef BSWAP8\\r\\nXi[0] = BSWAP8(Z.hi);\\r\\nXi[1] = BSWAP8(Z.lo);\\r\\n# else\\r\\nu8 *p = (u8 *)Xi;\\r\\nu32 v;\\r\\nv = (u32)(Z.hi >> 32);\\r\\nPUTU32(p, v);\\r\\nv = (u32)(Z.hi);\\r\\nPUTU32(p + 4, v);\\r\\nv = (u32)(Z.lo >> 32);\\r\\nPUTU32(p + 8, v);\\r\\nv = (u32)(Z.lo);\\r\\nPUTU32(p + 12, v);\\r\\n# endif\\r\\n} else {\\r\\nXi[0] = Z.hi;\\r\\nXi[1] = Z.lo;\\r\\n}\\r\\n}\\r\\nstatic void gcm_ghash_4bit(u64 Xi[2], const u128 Htable[16],\\r\\nconst u8 *inp, size_t len)\\r\\n{\\r\\nu128 Z;\\r\\nint cnt;\\r\\nsize_t rem, nlo, nhi;\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\n# if 1\\r\\ndo {\\r\\ncnt = 15;\\r\\nnlo = ((const u8 *)Xi)[15];\\r\\nnlo ^= inp[15];\\r\\nnhi = nlo >> 4;\\r\\nnlo &= 0xf;\\r\\nZ.hi = Htable[nlo].hi;\\r\\nZ.lo = Htable[nlo].lo;\\r\\nwhile (1) {\\r\\nrem = (size_t)Z.lo & 0xf;\\r\\nZ.lo = (Z.hi << 60) | (Z.lo >> 4);\\r\\nZ.hi = (Z.hi >> 4);\\r\\nif (sizeof(size_t) == 8)\\r\\nZ.hi ^= rem_4bit[rem];\\r\\nelse\\r\\nZ.hi ^= (u64)rem_4bit[rem] << 32;\\r\\nZ.hi ^= Htable[nhi].hi;\\r\\nZ.lo ^= Htable[nhi].lo;\\r\\nif (--cnt < 0)\\r\\nbreak;\\r\\nnlo = ((const u8 *)Xi)[cnt];\\r\\nnlo ^= inp[cnt];\\r\\nnhi = nlo >> 4;\\r\\nnlo &= 0xf;\\r\\nrem = (size_t)Z.lo & 0xf;\\r\\nZ.lo = (Z.hi << 60) | (Z.lo >> 4);\\r\\nZ.hi = (Z.hi >> 4);\\r\\nif (sizeof(size_t) == 8)\\r\\nZ.hi ^= rem_4bit[rem];\\r\\nelse\\r\\nZ.hi ^= (u64)rem_4bit[rem] << 32;\\r\\nZ.hi ^= Htable[nlo].hi;\\r\\nZ.lo ^= Htable[nlo].lo;\\r\\n}\\r\\n# else\\r\\nu128 Hshr4[16];\\r\\nu8 Hshl4[16];\\r\\nstatic const unsigned short rem_8bit[256] = {\\r\\n0x0000, 0x01C2, 0x0384, 0x0246, 0x0708, 0x06CA, 0x048C, 0x054E,\\r\\n0x0E10, 0x0FD2, 0x0D94, 0x0C56, 0x0918, 0x08DA, 0x0A9C, 0x0B5E,\\r\\n0x1C20, 0x1DE2, 0x1FA4, 0x1E66, 0x1B28, 0x1AEA, 0x18AC, 0x196E,\\r\\n0x1230, 0x13F2, 0x11B4, 0x1076, 0x1538, 0x14FA, 0x16BC, 0x177E,\\r\\n0x3840, 0x3982, 0x3BC4, 0x3A06, 0x3F48, 0x3E8A, 0x3CCC, 0x3D0E,\\r\\n0x3650, 0x3792, 0x35D4, 0x3416, 0x3158, 0x309A, 0x32DC, 0x331E,\\r\\n0x2460, 0x25A2, 0x27E4, 0x2626, 0x2368, 0x22AA, 0x20EC, 0x212E,\\r\\n0x2A70, 0x2BB2, 0x29F4, 0x2836, 0x2D78, 0x2CBA, 0x2EFC, 0x2F3E,\\r\\n0x7080, 0x7142, 0x7304, 0x72C6, 0x7788, 0x764A, 0x740C, 0x75CE,\\r\\n0x7E90, 0x7F52, 0x7D14, 0x7CD6, 0x7998, 0x785A, 0x7A1C, 0x7BDE,\\r\\n0x6CA0, 0x6D62, 0x6F24, 0x6EE6, 0x6BA8, 0x6A6A, 0x682C, 0x69EE,\\r\\n0x62B0, 0x6372, 0x6134, 0x60F6, 0x65B8, 0x647A, 0x663C, 0x67FE,\\r\\n0x48C0, 0x4902, 0x4B44, 0x4A86, 0x4FC8, 0x4E0A, 0x4C4C, 0x4D8E,\\r\\n0x46D0, 0x4712, 0x4554, 0x4496, 0x41D8, 0x401A, 0x425C, 0x439E,\\r\\n0x54E0, 0x5522, 0x5764, 0x56A6, 0x53E8, 0x522A, 0x506C, 0x51AE,\\r\\n0x5AF0, 0x5B32, 0x5974, 0x58B6, 0x5DF8, 0x5C3A, 0x5E7C, 0x5FBE,\\r\\n0xE100, 0xE0C2, 0xE284, 0xE346, 0xE608, 0xE7CA, 0xE58C, 0xE44E,\\r\\n0xEF10, 0xEED2, 0xEC94, 0xED56, 0xE818, 0xE9DA, 0xEB9C, 0xEA5E,\\r\\n0xFD20, 0xFCE2, 0xFEA4, 0xFF66, 0xFA28, 0xFBEA, 0xF9AC, 0xF86E,\\r\\n0xF330, 0xF2F2, 0xF0B4, 0xF176, 0xF438, 0xF5FA, 0xF7BC, 0xF67E,\\r\\n0xD940, 0xD882, 0xDAC4, 0xDB06, 0xDE48, 0xDF8A, 0xDDCC, 0xDC0E,\\r\\n0xD750, 0xD692, 0xD4D4, 0xD516, 0xD058, 0xD19A, 0xD3DC, 0xD21E,\\r\\n0xC560, 0xC4A2, 0xC6E4, 0xC726, 0xC268, 0xC3AA, 0xC1EC, 0xC02E,\\r\\n0xCB70, 0xCAB2, 0xC8F4, 0xC936, 0xCC78, 0xCDBA, 0xCFFC, 0xCE3E,\\r\\n0x9180, 0x9042, 0x9204, 0x93C6, 0x9688, 0x974A, 0x950C, 0x94CE,\\r\\n0x9F90, 0x9E52, 0x9C14, 0x9DD6, 0x9898, 0x995A, 0x9B1C, 0x9ADE,\\r\\n0x8DA0, 0x8C62, 0x8E24, 0x8FE6, 0x8AA8, 0x8B6A, 0x892C, 0x88EE,\\r\\n0x83B0, 0x8272, 0x8034, 0x81F6, 0x84B8, 0x857A, 0x873C, 0x86FE,\\r\\n0xA9C0, 0xA802, 0xAA44, 0xAB86, 0xAEC8, 0xAF0A, 0xAD4C, 0xAC8E,\\r\\n0xA7D0, 0xA612, 0xA454, 0xA596, 0xA0D8, 0xA11A, 0xA35C, 0xA29E,\\r\\n0xB5E0, 0xB422, 0xB664, 0xB7A6, 0xB2E8, 0xB32A, 0xB16C, 0xB0AE,\\r\\n0xBBF0, 0xBA32, 0xB874, 0xB9B6, 0xBCF8, 0xBD3A, 0xBF7C, 0xBEBE\\r\\n};\\r\\nfor (cnt = 0; cnt < 16; ++cnt) {\\r\\nZ.hi = Htable[cnt].hi;\\r\\nZ.lo = Htable[cnt].lo;\\r\\nHshr4[cnt].lo = (Z.hi << 60) | (Z.lo >> 4);\\r\\nHshr4[cnt].hi = (Z.hi >> 4);\\r\\nHshl4[cnt] = (u8)(Z.lo << 4);\\r\\n}\\r\\ndo {\\r\\nfor (Z.lo = 0, Z.hi = 0, cnt = 15; cnt; --cnt) {\\r\\nnlo = ((const u8 *)Xi)[cnt];\\r\\nnlo ^= inp[cnt];\\r\\nnhi = nlo >> 4;\\r\\nnlo &= 0xf;\\r\\nZ.hi ^= Htable[nlo].hi;\\r\\nZ.lo ^= Htable[nlo].lo;\\r\\nrem = (size_t)Z.lo & 0xff;\\r\\nZ.lo = (Z.hi << 56) | (Z.lo >> 8);\\r\\nZ.hi = (Z.hi >> 8);\\r\\nZ.hi ^= Hshr4[nhi].hi;\\r\\nZ.lo ^= Hshr4[nhi].lo;\\r\\nZ.hi ^= (u64)rem_8bit[rem ^ Hshl4[nhi]] << 48;\\r\\n}\\r\\nnlo = ((const u8 *)Xi)[0];\\r\\nnlo ^= inp[0];\\r\\nnhi = nlo >> 4;\\r\\nnlo &= 0xf;\\r\\nZ.hi ^= Htable[nlo].hi;\\r\\nZ.lo ^= Htable[nlo].lo;\\r\\nrem = (size_t)Z.lo & 0xf;\\r\\nZ.lo = (Z.hi << 60) | (Z.lo >> 4);\\r\\nZ.hi = (Z.hi >> 4);\\r\\nZ.hi ^= Htable[nhi].hi;\\r\\nZ.lo ^= Htable[nhi].lo;\\r\\nZ.hi ^= ((u64)rem_8bit[rem << 4]) << 48;\\r\\n# endif\\r\\nif (is_endian.little) {\\r\\n# ifdef BSWAP8\\r\\nXi[0] = BSWAP8(Z.hi);\\r\\nXi[1] = BSWAP8(Z.lo);\\r\\n# else\\r\\nu8 *p = (u8 *)Xi;\\r\\nu32 v;\\r\\nv = (u32)(Z.hi >> 32);\\r\\nPUTU32(p, v);\\r\\nv = (u32)(Z.hi);\\r\\nPUTU32(p + 4, v);\\r\\nv = (u32)(Z.lo >> 32);\\r\\nPUTU32(p + 8, v);\\r\\nv = (u32)(Z.lo);\\r\\nPUTU32(p + 12, v);\\r\\n# endif\\r\\n} else {\\r\\nXi[0] = Z.hi;\\r\\nXi[1] = Z.lo;\\r\\n}\\r\\n} while (inp += 16, len -= 16);\\r\\n}\\r\\n# endif\\r\\n# else\\r\\nvoid gcm_gmult_4bit(u64 Xi[2], const u128 Htable[16]);\\r\\nstatic void gcm_gmult_1bit(u64 Xi[2], const u64 H[2])\\r\\n{\\r\\nu128 V, Z = { 0, 0 };\\r\\nlong X;\\r\\nint i, j;\\r\\nconst long *xi = (const long *)Xi;\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nV.hi = H[0];\\r\\nV.lo = H[1];\\r\\nfor (j = 0; j < 16 / sizeof(long); ++j) {\\r\\nif (is_endian.little) {\\r\\nif (sizeof(long) == 8) {\\r\\n# ifdef BSWAP8\\r\\nX = (long)(BSWAP8(xi[j]));\\r\\n# else\\r\\nconst u8 *p = (const u8 *)(xi + j);\\r\\nX = (long)((u64)GETU32(p) << 32 | GETU32(p + 4));\\r\\n# endif\\r\\n} else {\\r\\nconst u8 *p = (const u8 *)(xi + j);\\r\\nX = (long)GETU32(p);\\r\\n}\\r\\n} else\\r\\nX = xi[j];\\r\\nfor (i = 0; i < 8 * sizeof(long); ++i, X <<= 1) {\\r\\nu64 M = (u64)(X >> (8 * sizeof(long) - 1));\\r\\nZ.hi ^= V.hi & M;\\r\\nZ.lo ^= V.lo & M;\\r\\nREDUCE1BIT(V);\\r\\n}\\r\\n}\\r\\nif (is_endian.little) {\\r\\n# ifdef BSWAP8\\r\\nXi[0] = BSWAP8(Z.hi);\\r\\nXi[1] = BSWAP8(Z.lo);\\r\\n# else\\r\\nu8 *p = (u8 *)Xi;\\r\\nu32 v;\\r\\nv = (u32)(Z.hi >> 32);\\r\\nPUTU32(p, v);\\r\\nv = (u32)(Z.hi);\\r\\nPUTU32(p + 4, v);\\r\\nv = (u32)(Z.lo >> 32);\\r\\nPUTU32(p + 8, v);\\r\\nv = (u32)(Z.lo);\\r\\nPUTU32(p + 12, v);\\r\\n# endif\\r\\n} else {\\r\\nXi[0] = Z.hi;\\r\\nXi[1] = Z.lo;\\r\\n}\\r\\n}\\r\\nvoid CRYPTO_gcm128_setiv(GCM128_CONTEXT *ctx, const unsigned char *iv,\\r\\nsize_t len)\\r\\n{\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nunsigned int ctr;\\r\\n#ifdef GCM_FUNCREF_4BIT\\r\\nvoid (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;\\r\\n#endif\\r\\nctx->Yi.u[0] = 0;\\r\\nctx->Yi.u[1] = 0;\\r\\nctx->Xi.u[0] = 0;\\r\\nctx->Xi.u[1] = 0;\\r\\nctx->len.u[0] = 0;\\r\\nctx->len.u[1] = 0;\\r\\nctx->ares = 0;\\r\\nctx->mres = 0;\\r\\nif (len == 12) {\\r\\nmemcpy(ctx->Yi.c, iv, 12);\\r\\nctx->Yi.c[15] = 1;\\r\\nctr = 1;\\r\\n} else {\\r\\nsize_t i;\\r\\nu64 len0 = len;\\r\\nwhile (len >= 16) {\\r\\nfor (i = 0; i < 16; ++i)\\r\\nctx->Yi.c[i] ^= iv[i];\\r\\nGCM_MUL(ctx, Yi);\\r\\niv += 16;\\r\\nlen -= 16;\\r\\n}\\r\\nif (len) {\\r\\nfor (i = 0; i < len; ++i)\\r\\nctx->Yi.c[i] ^= iv[i];\\r\\nGCM_MUL(ctx, Yi);\\r\\n}\\r\\nlen0 <<= 3;\\r\\nif (is_endian.little) {\\r\\n#ifdef BSWAP8\\r\\nctx->Yi.u[1] ^= BSWAP8(len0);\\r\\n#else\\r\\nctx->Yi.c[8] ^= (u8)(len0 >> 56);\\r\\nctx->Yi.c[9] ^= (u8)(len0 >> 48);\\r\\nctx->Yi.c[10] ^= (u8)(len0 >> 40);\\r\\nctx->Yi.c[11] ^= (u8)(len0 >> 32);\\r\\nctx->Yi.c[12] ^= (u8)(len0 >> 24);\\r\\nctx->Yi.c[13] ^= (u8)(len0 >> 16);\\r\\nctx->Yi.c[14] ^= (u8)(len0 >> 8);\\r\\nctx->Yi.c[15] ^= (u8)(len0);\\r\\n#endif\\r\\n} else\\r\\nctx->Yi.u[1] ^= len0;\\r\\nGCM_MUL(ctx, Yi);\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctr = BSWAP4(ctx->Yi.d[3]);\\r\\n#else\\r\\nctr = GETU32(ctx->Yi.c + 12);\\r\\n#endif\\r\\nelse\\r\\nctr = ctx->Yi.d[3];\\r\\n}\\r\\n(*ctx->block) (ctx->Yi.c, ctx->EK0.c, ctx->key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n#else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n#endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\n}\\r\\nint CRYPTO_gcm128_aad(GCM128_CONTEXT *ctx, const unsigned char *aad,\\r\\nsize_t len)\\r\\n{\\r\\nsize_t i;\\r\\nunsigned int n;\\r\\nu64 alen = ctx->len.u[0];\\r\\n#ifdef GCM_FUNCREF_4BIT\\r\\nvoid (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;\\r\\n# ifdef GHASH\\r\\nvoid (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],\\r\\nconst u8 *inp, size_t len) = ctx->ghash;\\r\\n# endif\\r\\n#endif\\r\\nif (ctx->len.u[1])\\r\\nreturn -2;\\r\\nalen += len;\\r\\nif (alen > (U64(1) << 61) || (sizeof(len) == 8 && alen < len))\\r\\nreturn -1;\\r\\nctx->len.u[0] = alen;\\r\\nn = ctx->ares;\\r\\nif (n) {\\r\\nwhile (n && len) {\\r\\nctx->Xi.c[n] ^= *(aad++);\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\nif (n == 0)\\r\\nGCM_MUL(ctx, Xi);\\r\\nelse {\\r\\nctx->ares = n;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n#ifdef GHASH\\r\\nif ((i = (len & (size_t)-16))) {\\r\\nGHASH(ctx, aad, i);\\r\\naad += i;\\r\\nlen -= i;\\r\\n}\\r\\n#else\\r\\nwhile (len >= 16) {\\r\\nfor (i = 0; i < 16; ++i)\\r\\nctx->Xi.c[i] ^= aad[i];\\r\\nGCM_MUL(ctx, Xi);\\r\\naad += 16;\\r\\nlen -= 16;\\r\\n}\\r\\n#endif\\r\\nif (len) {\\r\\nn = (unsigned int)len;\\r\\nfor (i = 0; i < len; ++i)\\r\\nctx->Xi.c[i] ^= aad[i];\\r\\n}\\r\\nctx->ares = n;\\r\\nreturn 0;\\r\\n}\\r\\nint CRYPTO_gcm128_encrypt(GCM128_CONTEXT *ctx,\\r\\nconst unsigned char *in, unsigned char *out,\\r\\nsize_t len)\\r\\n{\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nunsigned int n, ctr;\\r\\nsize_t i;\\r\\nu64 mlen = ctx->len.u[1];\\r\\nblock128_f block = ctx->block;\\r\\nvoid *key = ctx->key;\\r\\n#ifdef GCM_FUNCREF_4BIT\\r\\nvoid (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;\\r\\n# ifdef GHASH\\r\\nvoid (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],\\r\\nconst u8 *inp, size_t len) = ctx->ghash;\\r\\n# endif\\r\\n#endif\\r\\n#if 0\\r\\nn = (unsigned int)mlen % 16;\\r\\n#endif\\r\\nmlen += len;\\r\\nif (mlen > ((U64(1) << 36) - 32) || (sizeof(len) == 8 && mlen < len))\\r\\nreturn -1;\\r\\nctx->len.u[1] = mlen;\\r\\nif (ctx->ares) {\\r\\nGCM_MUL(ctx, Xi);\\r\\nctx->ares = 0;\\r\\n}\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctr = BSWAP4(ctx->Yi.d[3]);\\r\\n#else\\r\\nctr = GETU32(ctx->Yi.c + 12);\\r\\n#endif\\r\\nelse\\r\\nctr = ctx->Yi.d[3];\\r\\nn = ctx->mres;\\r\\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nif (16 % sizeof(size_t) == 0) {\\r\\ndo {\\r\\nif (n) {\\r\\nwhile (n && len) {\\r\\nctx->Xi.c[n] ^= *(out++) = *(in++) ^ ctx->EKi.c[n];\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\nif (n == 0)\\r\\nGCM_MUL(ctx, Xi);\\r\\nelse {\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n# if defined(STRICT_ALIGNMENT)\\r\\nif (((size_t)in | (size_t)out) % sizeof(size_t) != 0)\\r\\nbreak;\\r\\n# endif\\r\\n# if defined(GHASH) && defined(GHASH_CHUNK)\\r\\nwhile (len >= GHASH_CHUNK) {\\r\\nsize_t j = GHASH_CHUNK;\\r\\nwhile (j) {\\r\\nsize_t *out_t = (size_t *)out;\\r\\nconst size_t *in_t = (const size_t *)in;\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nfor (i = 0; i < 16 / sizeof(size_t); ++i)\\r\\nout_t[i] = in_t[i] ^ ctx->EKi.t[i];\\r\\nout += 16;\\r\\nin += 16;\\r\\nj -= 16;\\r\\n}\\r\\nGHASH(ctx, out - GHASH_CHUNK, GHASH_CHUNK);\\r\\nlen -= GHASH_CHUNK;\\r\\n}\\r\\nif ((i = (len & (size_t)-16))) {\\r\\nsize_t j = i;\\r\\nwhile (len >= 16) {\\r\\nsize_t *out_t = (size_t *)out;\\r\\nconst size_t *in_t = (const size_t *)in;\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nfor (i = 0; i < 16 / sizeof(size_t); ++i)\\r\\nout_t[i] = in_t[i] ^ ctx->EKi.t[i];\\r\\nout += 16;\\r\\nin += 16;\\r\\nlen -= 16;\\r\\n}\\r\\nGHASH(ctx, out - j, j);\\r\\n}\\r\\n# else\\r\\nwhile (len >= 16) {\\r\\nsize_t *out_t = (size_t *)out;\\r\\nconst size_t *in_t = (const size_t *)in;\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nfor (i = 0; i < 16 / sizeof(size_t); ++i)\\r\\nctx->Xi.t[i] ^= out_t[i] = in_t[i] ^ ctx->EKi.t[i];\\r\\nGCM_MUL(ctx, Xi);\\r\\nout += 16;\\r\\nin += 16;\\r\\nlen -= 16;\\r\\n}\\r\\n# endif\\r\\nif (len) {\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nwhile (len--) {\\r\\nctx->Xi.c[n] ^= out[n] = in[n] ^ ctx->EKi.c[n];\\r\\n++n;\\r\\n}\\r\\n}\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n} while (0);\\r\\n}\\r\\n#endif\\r\\nfor (i = 0; i < len; ++i) {\\r\\nif (n == 0) {\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n#else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n#endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\n}\\r\\nctx->Xi.c[n] ^= out[i] = in[i] ^ ctx->EKi.c[n];\\r\\nn = (n + 1) % 16;\\r\\nif (n == 0)\\r\\nGCM_MUL(ctx, Xi);\\r\\n}\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n}\\r\\nint CRYPTO_gcm128_decrypt(GCM128_CONTEXT *ctx,\\r\\nconst unsigned char *in, unsigned char *out,\\r\\nsize_t len)\\r\\n{\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nunsigned int n, ctr;\\r\\nsize_t i;\\r\\nu64 mlen = ctx->len.u[1];\\r\\nblock128_f block = ctx->block;\\r\\nvoid *key = ctx->key;\\r\\n#ifdef GCM_FUNCREF_4BIT\\r\\nvoid (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;\\r\\n# ifdef GHASH\\r\\nvoid (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],\\r\\nconst u8 *inp, size_t len) = ctx->ghash;\\r\\n# endif\\r\\n#endif\\r\\nmlen += len;\\r\\nif (mlen > ((U64(1) << 36) - 32) || (sizeof(len) == 8 && mlen < len))\\r\\nreturn -1;\\r\\nctx->len.u[1] = mlen;\\r\\nif (ctx->ares) {\\r\\nGCM_MUL(ctx, Xi);\\r\\nctx->ares = 0;\\r\\n}\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctr = BSWAP4(ctx->Yi.d[3]);\\r\\n#else\\r\\nctr = GETU32(ctx->Yi.c + 12);\\r\\n#endif\\r\\nelse\\r\\nctr = ctx->Yi.d[3];\\r\\nn = ctx->mres;\\r\\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nif (16 % sizeof(size_t) == 0) {\\r\\ndo {\\r\\nif (n) {\\r\\nwhile (n && len) {\\r\\nu8 c = *(in++);\\r\\n*(out++) = c ^ ctx->EKi.c[n];\\r\\nctx->Xi.c[n] ^= c;\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\nif (n == 0)\\r\\nGCM_MUL(ctx, Xi);\\r\\nelse {\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n# if defined(STRICT_ALIGNMENT)\\r\\nif (((size_t)in | (size_t)out) % sizeof(size_t) != 0)\\r\\nbreak;\\r\\n# endif\\r\\n# if defined(GHASH) && defined(GHASH_CHUNK)\\r\\nwhile (len >= GHASH_CHUNK) {\\r\\nsize_t j = GHASH_CHUNK;\\r\\nGHASH(ctx, in, GHASH_CHUNK);\\r\\nwhile (j) {\\r\\nsize_t *out_t = (size_t *)out;\\r\\nconst size_t *in_t = (const size_t *)in;\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nfor (i = 0; i < 16 / sizeof(size_t); ++i)\\r\\nout_t[i] = in_t[i] ^ ctx->EKi.t[i];\\r\\nout += 16;\\r\\nin += 16;\\r\\nj -= 16;\\r\\n}\\r\\nlen -= GHASH_CHUNK;\\r\\n}\\r\\nif ((i = (len & (size_t)-16))) {\\r\\nGHASH(ctx, in, i);\\r\\nwhile (len >= 16) {\\r\\nsize_t *out_t = (size_t *)out;\\r\\nconst size_t *in_t = (const size_t *)in;\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nfor (i = 0; i < 16 / sizeof(size_t); ++i)\\r\\nout_t[i] = in_t[i] ^ ctx->EKi.t[i];\\r\\nout += 16;\\r\\nin += 16;\\r\\nlen -= 16;\\r\\n}\\r\\n}\\r\\n# else\\r\\nwhile (len >= 16) {\\r\\nsize_t *out_t = (size_t *)out;\\r\\nconst size_t *in_t = (const size_t *)in;\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nfor (i = 0; i < 16 / sizeof(size_t); ++i) {\\r\\nsize_t c = in[i];\\r\\nout[i] = c ^ ctx->EKi.t[i];\\r\\nctx->Xi.t[i] ^= c;\\r\\n}\\r\\nGCM_MUL(ctx, Xi);\\r\\nout += 16;\\r\\nin += 16;\\r\\nlen -= 16;\\r\\n}\\r\\n# endif\\r\\nif (len) {\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nwhile (len--) {\\r\\nu8 c = in[n];\\r\\nctx->Xi.c[n] ^= c;\\r\\nout[n] = c ^ ctx->EKi.c[n];\\r\\n++n;\\r\\n}\\r\\n}\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n} while (0);\\r\\n}\\r\\n#endif\\r\\nfor (i = 0; i < len; ++i) {\\r\\nu8 c;\\r\\nif (n == 0) {\\r\\n(*block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n#else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n#endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\n}\\r\\nc = in[i];\\r\\nout[i] = c ^ ctx->EKi.c[n];\\r\\nctx->Xi.c[n] ^= c;\\r\\nn = (n + 1) % 16;\\r\\nif (n == 0)\\r\\nGCM_MUL(ctx, Xi);\\r\\n}\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n}\\r\\nint CRYPTO_gcm128_encrypt_ctr32(GCM128_CONTEXT *ctx,\\r\\nconst unsigned char *in, unsigned char *out,\\r\\nsize_t len, ctr128_f stream)\\r\\n{\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nunsigned int n, ctr;\\r\\nsize_t i;\\r\\nu64 mlen = ctx->len.u[1];\\r\\nvoid *key = ctx->key;\\r\\n#ifdef GCM_FUNCREF_4BIT\\r\\nvoid (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;\\r\\n# ifdef GHASH\\r\\nvoid (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],\\r\\nconst u8 *inp, size_t len) = ctx->ghash;\\r\\n# endif\\r\\n#endif\\r\\nmlen += len;\\r\\nif (mlen > ((U64(1) << 36) - 32) || (sizeof(len) == 8 && mlen < len))\\r\\nreturn -1;\\r\\nctx->len.u[1] = mlen;\\r\\nif (ctx->ares) {\\r\\nGCM_MUL(ctx, Xi);\\r\\nctx->ares = 0;\\r\\n}\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctr = BSWAP4(ctx->Yi.d[3]);\\r\\n#else\\r\\nctr = GETU32(ctx->Yi.c + 12);\\r\\n#endif\\r\\nelse\\r\\nctr = ctx->Yi.d[3];\\r\\nn = ctx->mres;\\r\\nif (n) {\\r\\nwhile (n && len) {\\r\\nctx->Xi.c[n] ^= *(out++) = *(in++) ^ ctx->EKi.c[n];\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\nif (n == 0)\\r\\nGCM_MUL(ctx, Xi);\\r\\nelse {\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n#if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nwhile (len >= GHASH_CHUNK) {\\r\\n(*stream) (in, out, GHASH_CHUNK / 16, key, ctx->Yi.c);\\r\\nctr += GHASH_CHUNK / 16;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nGHASH(ctx, out, GHASH_CHUNK);\\r\\nout += GHASH_CHUNK;\\r\\nin += GHASH_CHUNK;\\r\\nlen -= GHASH_CHUNK;\\r\\n}\\r\\n#endif\\r\\nif ((i = (len & (size_t)-16))) {\\r\\nsize_t j = i / 16;\\r\\n(*stream) (in, out, j, key, ctx->Yi.c);\\r\\nctr += (unsigned int)j;\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n#else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n#endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nin += i;\\r\\nlen -= i;\\r\\n#if defined(GHASH)\\r\\nGHASH(ctx, out, i);\\r\\nout += i;\\r\\n#else\\r\\nwhile (j--) {\\r\\nfor (i = 0; i < 16; ++i)\\r\\nctx->Xi.c[i] ^= out[i];\\r\\nGCM_MUL(ctx, Xi);\\r\\nout += 16;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (len) {\\r\\n(*ctx->block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n#else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n#endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nwhile (len--) {\\r\\nctx->Xi.c[n] ^= out[n] = in[n] ^ ctx->EKi.c[n];\\r\\n++n;\\r\\n}\\r\\n}\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n}\\r\\nint CRYPTO_gcm128_decrypt_ctr32(GCM128_CONTEXT *ctx,\\r\\nconst unsigned char *in, unsigned char *out,\\r\\nsize_t len, ctr128_f stream)\\r\\n{\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nunsigned int n, ctr;\\r\\nsize_t i;\\r\\nu64 mlen = ctx->len.u[1];\\r\\nvoid *key = ctx->key;\\r\\n#ifdef GCM_FUNCREF_4BIT\\r\\nvoid (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;\\r\\n# ifdef GHASH\\r\\nvoid (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],\\r\\nconst u8 *inp, size_t len) = ctx->ghash;\\r\\n# endif\\r\\n#endif\\r\\nmlen += len;\\r\\nif (mlen > ((U64(1) << 36) - 32) || (sizeof(len) == 8 && mlen < len))\\r\\nreturn -1;\\r\\nctx->len.u[1] = mlen;\\r\\nif (ctx->ares) {\\r\\nGCM_MUL(ctx, Xi);\\r\\nctx->ares = 0;\\r\\n}\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctr = BSWAP4(ctx->Yi.d[3]);\\r\\n#else\\r\\nctr = GETU32(ctx->Yi.c + 12);\\r\\n#endif\\r\\nelse\\r\\nctr = ctx->Yi.d[3];\\r\\nn = ctx->mres;\\r\\nif (n) {\\r\\nwhile (n && len) {\\r\\nu8 c = *(in++);\\r\\n*(out++) = c ^ ctx->EKi.c[n];\\r\\nctx->Xi.c[n] ^= c;\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\nif (n == 0)\\r\\nGCM_MUL(ctx, Xi);\\r\\nelse {\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n#if defined(GHASH) && !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nwhile (len >= GHASH_CHUNK) {\\r\\nGHASH(ctx, in, GHASH_CHUNK);\\r\\n(*stream) (in, out, GHASH_CHUNK / 16, key, ctx->Yi.c);\\r\\nctr += GHASH_CHUNK / 16;\\r\\nif (is_endian.little)\\r\\n# ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n# else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n# endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nout += GHASH_CHUNK;\\r\\nin += GHASH_CHUNK;\\r\\nlen -= GHASH_CHUNK;\\r\\n}\\r\\n#endif\\r\\nif ((i = (len & (size_t)-16))) {\\r\\nsize_t j = i / 16;\\r\\n#if defined(GHASH)\\r\\nGHASH(ctx, in, i);\\r\\n#else\\r\\nwhile (j--) {\\r\\nsize_t k;\\r\\nfor (k = 0; k < 16; ++k)\\r\\nctx->Xi.c[k] ^= in[k];\\r\\nGCM_MUL(ctx, Xi);\\r\\nin += 16;\\r\\n}\\r\\nj = i / 16;\\r\\nin -= i;\\r\\n#endif\\r\\n(*stream) (in, out, j, key, ctx->Yi.c);\\r\\nctr += (unsigned int)j;\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n#else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n#endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nout += i;\\r\\nin += i;\\r\\nlen -= i;\\r\\n}\\r\\nif (len) {\\r\\n(*ctx->block) (ctx->Yi.c, ctx->EKi.c, key);\\r\\n++ctr;\\r\\nif (is_endian.little)\\r\\n#ifdef BSWAP4\\r\\nctx->Yi.d[3] = BSWAP4(ctr);\\r\\n#else\\r\\nPUTU32(ctx->Yi.c + 12, ctr);\\r\\n#endif\\r\\nelse\\r\\nctx->Yi.d[3] = ctr;\\r\\nwhile (len--) {\\r\\nu8 c = in[n];\\r\\nctx->Xi.c[n] ^= c;\\r\\nout[n] = c ^ ctx->EKi.c[n];\\r\\n++n;\\r\\n}\\r\\n}\\r\\nctx->mres = n;\\r\\nreturn 0;\\r\\n}\\r\\nint CRYPTO_gcm128_finish(GCM128_CONTEXT *ctx, const unsigned char *tag,\\r\\nsize_t len)\\r\\n{\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nu64 alen = ctx->len.u[0] << 3;\\r\\nu64 clen = ctx->len.u[1] << 3;\\r\\n#ifdef GCM_FUNCREF_4BIT\\r\\nvoid (*gcm_gmult_p) (u64 Xi[2], const u128 Htable[16]) = ctx->gmult;\\r\\n#endif\\r\\nif (ctx->mres || ctx->ares)\\r\\nGCM_MUL(ctx, Xi);\\r\\nif (is_endian.little) {\\r\\n#ifdef BSWAP8\\r\\nalen = BSWAP8(alen);\\r\\nclen = BSWAP8(clen);\\r\\n#else\\r\\nu8 *p = ctx->len.c;\\r\\nctx->len.u[0] = alen;\\r\\nctx->len.u[1] = clen;\\r\\nalen = (u64)GETU32(p) << 32 | GETU32(p + 4);\\r\\nclen = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\\r\\n#endif\\r\\n}\\r\\nctx->Xi.u[0] ^= alen;\\r\\nctx->Xi.u[1] ^= clen;\\r\\nGCM_MUL(ctx, Xi);\\r\\nctx->Xi.u[0] ^= ctx->EK0.u[0];\\r\\nctx->Xi.u[1] ^= ctx->EK0.u[1];\\r\\nif (tag && len <= sizeof(ctx->Xi))\\r\\nreturn memcmp(ctx->Xi.c, tag, len);\\r\\nelse\\r\\nreturn -1;\\r\\n}\\r\\nvoid CRYPTO_gcm128_tag(GCM128_CONTEXT *ctx, unsigned char *tag, size_t len)\\r\\n{\\r\\nCRYPTO_gcm128_finish(ctx, NULL, 0);\\r\\nmemcpy(tag, ctx->Xi.c,\\r\\nlen <= sizeof(ctx->Xi.c) ? len : sizeof(ctx->Xi.c));\\r\\n}\\r\\nGCM128_CONTEXT *CRYPTO_gcm128_new(void *key, block128_f block)\\r\\n{\\r\\nGCM128_CONTEXT *ret;\\r\\nif ((ret = (GCM128_CONTEXT *)OPENSSL_malloc(sizeof(GCM128_CONTEXT))))\\r\\nCRYPTO_gcm128_init(ret, key, block);\\r\\nreturn ret;\\r\\n}\\r\\nvoid CRYPTO_gcm128_release(GCM128_CONTEXT *ctx)\\r\\n{\\r\\nif (ctx) {\\r\\nOPENSSL_cleanse(ctx, sizeof(*ctx));\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\n}\\r\\nint main()\\r\\n{\\r\\nGCM128_CONTEXT ctx;\\r\\nAES_KEY key;\\r\\nint ret = 0;\\r\\nTEST_CASE(1);\\r\\nTEST_CASE(2);\\r\\nTEST_CASE(3);\\r\\nTEST_CASE(4);\\r\\nTEST_CASE(5);\\r\\nTEST_CASE(6);\\r\\nTEST_CASE(7);\\r\\nTEST_CASE(8);\\r\\nTEST_CASE(9);\\r\\nTEST_CASE(10);\\r\\nTEST_CASE(11);\\r\\nTEST_CASE(12);\\r\\nTEST_CASE(13);\\r\\nTEST_CASE(14);\\r\\nTEST_CASE(15);\\r\\nTEST_CASE(16);\\r\\nTEST_CASE(17);\\r\\nTEST_CASE(18);\\r\\nTEST_CASE(19);\\r\\nTEST_CASE(20);\\r\\n# ifdef OPENSSL_CPUID_OBJ\\r\\n{\\r\\nsize_t start, stop, gcm_t, ctr_t, OPENSSL_rdtsc();\\r\\nunion {\\r\\nu64 u;\\r\\nu8 c[1024];\\r\\n} buf;\\r\\nint i;\\r\\nAES_set_encrypt_key(K1, sizeof(K1) * 8, &key);\\r\\nCRYPTO_gcm128_init(&ctx, &key, (block128_f) AES_encrypt);\\r\\nCRYPTO_gcm128_setiv(&ctx, IV1, sizeof(IV1));\\r\\nCRYPTO_gcm128_encrypt(&ctx, buf.c, buf.c, sizeof(buf));\\r\\nstart = OPENSSL_rdtsc();\\r\\nCRYPTO_gcm128_encrypt(&ctx, buf.c, buf.c, sizeof(buf));\\r\\ngcm_t = OPENSSL_rdtsc() - start;\\r\\nCRYPTO_ctr128_encrypt(buf.c, buf.c, sizeof(buf),\\r\\n&key, ctx.Yi.c, ctx.EKi.c, &ctx.mres,\\r\\n(block128_f) AES_encrypt);\\r\\nstart = OPENSSL_rdtsc();\\r\\nCRYPTO_ctr128_encrypt(buf.c, buf.c, sizeof(buf),\\r\\n&key, ctx.Yi.c, ctx.EKi.c, &ctx.mres,\\r\\n(block128_f) AES_encrypt);\\r\\nctr_t = OPENSSL_rdtsc() - start;\\r\\nprintf(\"%.2f-%.2f=%.2f\\n\",\\r\\ngcm_t / (double)sizeof(buf),\\r\\nctr_t / (double)sizeof(buf),\\r\\n(gcm_t - ctr_t) / (double)sizeof(buf));\\r\\n# ifdef GHASH\\r\\n{\\r\\nvoid (*gcm_ghash_p) (u64 Xi[2], const u128 Htable[16],\\r\\nconst u8 *inp, size_t len) = ctx.ghash;\\r\\nGHASH((&ctx), buf.c, sizeof(buf));\\r\\nstart = OPENSSL_rdtsc();\\r\\nfor (i = 0; i < 100; ++i)\\r\\nGHASH((&ctx), buf.c, sizeof(buf));\\r\\ngcm_t = OPENSSL_rdtsc() - start;\\r\\nprintf(\"%.2f\\n\", gcm_t / (double)sizeof(buf) / (double)i);\\r\\n}\\r\\n# endif\\r\\n}\\r\\n# endif\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ui_err_c", "target": 0, "func": "void ERR_load_UI_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(UI_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, UI_str_functs);\\r\\nERR_load_strings(0, UI_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_stack_c", "target": 0, "func": "_STACK *sk_new(int (*c) (const void *, const void *))\\r\\n{\\r\\n_STACK *ret;\\r\\nint i;\\r\\nif ((ret = OPENSSL_malloc(sizeof(_STACK))) == NULL)\\r\\ngoto err;\\r\\nif ((ret->data = OPENSSL_malloc(sizeof(char *) * MIN_NODES)) == NULL)\\r\\ngoto err;\\r\\nfor (i = 0; i < MIN_NODES; i++)\\r\\nret->data[i] = NULL;\\r\\nret->comp = c;\\r\\nret->num_alloc = MIN_NODES;\\r\\nret->num = 0;\\r\\nret->sorted = 0;\\r\\nreturn (ret);\\r\\nerr:\\r\\nif (ret)\\r\\nOPENSSL_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nint sk_insert(_STACK *st, void *data, int loc)\\r\\n{\\r\\nchar **s;\\r\\nif (st == NULL)\\r\\nreturn 0;\\r\\nif (st->num_alloc <= st->num + 1) {\\r\\ns = OPENSSL_realloc((char *)st->data,\\r\\n(unsigned int)sizeof(char *) * st->num_alloc * 2);\\r\\nif (s == NULL)\\r\\nreturn (0);\\r\\nst->data = s;\\r\\nst->num_alloc *= 2;\\r\\n}\\r\\nif ((loc >= (int)st->num) || (loc < 0))\\r\\nst->data[st->num] = data;\\r\\nelse {\\r\\nint i;\\r\\nchar **f, **t;\\r\\nf = st->data;\\r\\nt = &(st->data[1]);\\r\\nfor (i = st->num; i >= loc; i--)\\r\\nt[i] = f[i];\\r\\n#ifdef undef\\r\\nmemmove(&(st->data[loc + 1]),\\r\\n&(st->data[loc]), sizeof(char *) * (st->num - loc));\\r\\n#endif\\r\\nst->data[loc] = data;\\r\\n}\\r\\nst->num++;\\r\\nst->sorted = 0;\\r\\nreturn (st->num);\\r\\n}\\r\\nvoid *sk_delete_ptr(_STACK *st, void *p)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < st->num; i++)\\r\\nif (st->data[i] == p)\\r\\nreturn (sk_delete(st, i));\\r\\nreturn (NULL);\\r\\n}\\r\\nvoid *sk_delete(_STACK *st, int loc)\\r\\n{\\r\\nchar *ret;\\r\\nint i, j;\\r\\nif (!st || (loc < 0) || (loc >= st->num))\\r\\nreturn NULL;\\r\\nret = st->data[loc];\\r\\nif (loc != st->num - 1) {\\r\\nj = st->num - 1;\\r\\nfor (i = loc; i < j; i++)\\r\\nst->data[i] = st->data[i + 1];\\r\\n}\\r\\nst->num--;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int internal_find(_STACK *st, void *data, int ret_val_options)\\r\\n{\\r\\nconst void *const *r;\\r\\nint i;\\r\\nif (st == NULL)\\r\\nreturn -1;\\r\\nif (st->comp == NULL) {\\r\\nfor (i = 0; i < st->num; i++)\\r\\nif (st->data[i] == data)\\r\\nreturn (i);\\r\\nreturn (-1);\\r\\n}\\r\\nsk_sort(st);\\r\\nif (data == NULL)\\r\\nreturn (-1);\\r\\nr = OBJ_bsearch_ex_(&data, st->data, st->num, sizeof(void *), st->comp,\\r\\nret_val_options);\\r\\nif (r == NULL)\\r\\nreturn (-1);\\r\\nreturn (int)((char **)r - st->data);\\r\\n}\\r\\nint sk_find(_STACK *st, void *data)\\r\\n{\\r\\nreturn internal_find(st, data, OBJ_BSEARCH_FIRST_VALUE_ON_MATCH);\\r\\n}\\r\\nint sk_find_ex(_STACK *st, void *data)\\r\\n{\\r\\nreturn internal_find(st, data, OBJ_BSEARCH_VALUE_ON_NOMATCH);\\r\\n}\\r\\nint sk_push(_STACK *st, void *data)\\r\\n{\\r\\nreturn (sk_insert(st, data, st->num));\\r\\n}\\r\\nint sk_unshift(_STACK *st, void *data)\\r\\n{\\r\\nreturn (sk_insert(st, data, 0));\\r\\n}\\r\\nvoid *sk_shift(_STACK *st)\\r\\n{\\r\\nif (st == NULL)\\r\\nreturn (NULL);\\r\\nif (st->num <= 0)\\r\\nreturn (NULL);\\r\\nreturn (sk_delete(st, 0));\\r\\n}\\r\\nvoid *sk_pop(_STACK *st)\\r\\n{\\r\\nif (st == NULL)\\r\\nreturn (NULL);\\r\\nif (st->num <= 0)\\r\\nreturn (NULL);\\r\\nreturn (sk_delete(st, st->num - 1));\\r\\n}\\r\\nvoid sk_zero(_STACK *st)\\r\\n{\\r\\nif (st == NULL)\\r\\nreturn;\\r\\nif (st->num <= 0)\\r\\nreturn;\\r\\nmemset((char *)st->data, 0, sizeof(st->data) * st->num);\\r\\nst->num = 0;\\r\\n}\\r\\nvoid sk_pop_free(_STACK *st, void (*func) (void *))\\r\\n{\\r\\nint i;\\r\\nif (st == NULL)\\r\\nreturn;\\r\\nfor (i = 0; i < st->num; i++)\\r\\nif (st->data[i] != NULL)\\r\\nfunc(st->data[i]);\\r\\nsk_free(st);\\r\\n}\\r\\nvoid sk_free(_STACK *st)\\r\\n{\\r\\nif (st == NULL)\\r\\nreturn;\\r\\nif (st->data != NULL)\\r\\nOPENSSL_free(st->data);\\r\\nOPENSSL_free(st);\\r\\n}\\r\\nint sk_num(const _STACK *st)\\r\\n{\\r\\nif (st == NULL)\\r\\nreturn -1;\\r\\nreturn st->num;\\r\\n}\\r\\nvoid *sk_value(const _STACK *st, int i)\\r\\n{\\r\\nif (!st || (i < 0) || (i >= st->num))\\r\\nreturn NULL;\\r\\nreturn st->data[i];\\r\\n}\\r\\nvoid *sk_set(_STACK *st, int i, void *value)\\r\\n{\\r\\nif (!st || (i < 0) || (i >= st->num))\\r\\nreturn NULL;\\r\\nreturn (st->data[i] = value);\\r\\n}\\r\\nvoid sk_sort(_STACK *st)\\r\\n{\\r\\nif (st && !st->sorted) {\\r\\nint (*comp_func) (const void *, const void *);\\r\\ncomp_func = (int (*)(const void *, const void *))(st->comp);\\r\\nqsort(st->data, st->num, sizeof(char *), comp_func);\\r\\nst->sorted = 1;\\r\\n}\\r\\n}\\r\\nint sk_is_sorted(const _STACK *st)\\r\\n{\\r\\nif (!st)\\r\\nreturn 1;\\r\\nreturn st->sorted;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pcy_map_c", "target": 0, "func": "int policy_cache_set_mapping(X509 *x, POLICY_MAPPINGS *maps)\\r\\n{\\r\\nPOLICY_MAPPING *map;\\r\\nX509_POLICY_DATA *data;\\r\\nX509_POLICY_CACHE *cache = x->policy_cache;\\r\\nint i;\\r\\nint ret = 0;\\r\\nif (sk_POLICY_MAPPING_num(maps) == 0) {\\r\\nret = -1;\\r\\ngoto bad_mapping;\\r\\n}\\r\\nfor (i = 0; i < sk_POLICY_MAPPING_num(maps); i++) {\\r\\nmap = sk_POLICY_MAPPING_value(maps, i);\\r\\nif ((OBJ_obj2nid(map->subjectDomainPolicy) == NID_any_policy)\\r\\n|| (OBJ_obj2nid(map->issuerDomainPolicy) == NID_any_policy)) {\\r\\nret = -1;\\r\\ngoto bad_mapping;\\r\\n}\\r\\ndata = policy_cache_find_data(cache, map->issuerDomainPolicy);\\r\\nif (!data && !cache->anyPolicy)\\r\\ncontinue;\\r\\nif (!data) {\\r\\ndata = policy_data_new(NULL, map->issuerDomainPolicy,\\r\\ncache->anyPolicy->flags\\r\\n& POLICY_DATA_FLAG_CRITICAL);\\r\\nif (!data)\\r\\ngoto bad_mapping;\\r\\ndata->qualifier_set = cache->anyPolicy->qualifier_set;\\r\\ndata->flags |= POLICY_DATA_FLAG_MAPPED_ANY;\\r\\ndata->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\\r\\nif (!sk_X509_POLICY_DATA_push(cache->data, data)) {\\r\\npolicy_data_free(data);\\r\\ngoto bad_mapping;\\r\\n}\\r\\n} else\\r\\ndata->flags |= POLICY_DATA_FLAG_MAPPED;\\r\\nif (!sk_ASN1_OBJECT_push(data->expected_policy_set,\\r\\nmap->subjectDomainPolicy))\\r\\ngoto bad_mapping;\\r\\nmap->subjectDomainPolicy = NULL;\\r\\n}\\r\\nret = 1;\\r\\nbad_mapping:\\r\\nif (ret == -1)\\r\\nx->ex_flags |= EXFLAG_INVALID_POLICY;\\r\\nsk_POLICY_MAPPING_pop_free(maps, POLICY_MAPPING_free);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_comp_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL;\\r\\nCMS_ContentInfo *cms = NULL;\\r\\nint ret = 1;\\r\\nint flags = CMS_STREAM;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\nin = BIO_new_file(\"comp.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\ncms = CMS_compress(in, NID_zlib_compression, flags);\\r\\nif (!cms)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smcomp.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!SMIME_write_CMS(out, cms, in, flags))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Compressing Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_des3_c", "target": 0, "func": "static int des_ede_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nBLOCK_CIPHER_ecb_loop()\\r\\nDES_ecb3_encrypt((const_DES_cblock *)(in + i),\\r\\n(DES_cblock *)(out + i),\\r\\n&data(ctx)->ks1, &data(ctx)->ks2,\\r\\n&data(ctx)->ks3, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nwhile (inl >= EVP_MAXCHUNK) {\\r\\nDES_ede3_ofb64_encrypt(in, out, (long)EVP_MAXCHUNK,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2,\\r\\n&data(ctx)->ks3, (DES_cblock *)ctx->iv,\\r\\n&ctx->num);\\r\\ninl -= EVP_MAXCHUNK;\\r\\nin += EVP_MAXCHUNK;\\r\\nout += EVP_MAXCHUNK;\\r\\n}\\r\\nif (inl)\\r\\nDES_ede3_ofb64_encrypt(in, out, (long)inl,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2,\\r\\n&data(ctx)->ks3, (DES_cblock *)ctx->iv,\\r\\n&ctx->num);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nDES_EDE_KEY *dat = data(ctx);\\r\\n# ifdef KSSL_DEBUG\\r\\n{\\r\\nint i;\\r\\nfprintf(stderr, \"des_ede_cbc_cipher(ctx=%p, buflen=%d)\\n\", ctx,\\r\\nctx->buf_len);\\r\\nfprintf(stderr, \"\\t iv= \");\\r\\nfor (i = 0; i < 8; i++)\\r\\nfprintf(stderr, \"%02X\", ctx->iv[i]);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n# endif\\r\\nif (dat->stream.cbc) {\\r\\n(*dat->stream.cbc) (in, out, inl, &dat->ks, ctx->iv);\\r\\nreturn 1;\\r\\n}\\r\\nwhile (inl >= EVP_MAXCHUNK) {\\r\\nDES_ede3_cbc_encrypt(in, out, (long)EVP_MAXCHUNK,\\r\\n&dat->ks1, &dat->ks2, &dat->ks3,\\r\\n(DES_cblock *)ctx->iv, ctx->encrypt);\\r\\ninl -= EVP_MAXCHUNK;\\r\\nin += EVP_MAXCHUNK;\\r\\nout += EVP_MAXCHUNK;\\r\\n}\\r\\nif (inl)\\r\\nDES_ede3_cbc_encrypt(in, out, (long)inl,\\r\\n&dat->ks1, &dat->ks2, &dat->ks3,\\r\\n(DES_cblock *)ctx->iv, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nwhile (inl >= EVP_MAXCHUNK) {\\r\\nDES_ede3_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2,\\r\\n&data(ctx)->ks3, (DES_cblock *)ctx->iv,\\r\\n&ctx->num, ctx->encrypt);\\r\\ninl -= EVP_MAXCHUNK;\\r\\nin += EVP_MAXCHUNK;\\r\\nout += EVP_MAXCHUNK;\\r\\n}\\r\\nif (inl)\\r\\nDES_ede3_cfb64_encrypt(in, out, (long)inl,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2,\\r\\n&data(ctx)->ks3, (DES_cblock *)ctx->iv,\\r\\n&ctx->num, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede3_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nsize_t n;\\r\\nunsigned char c[1], d[1];\\r\\nfor (n = 0; n < inl; ++n) {\\r\\nc[0] = (in[n / 8] & (1 << (7 - n % 8))) ? 0x80 : 0;\\r\\nDES_ede3_cfb_encrypt(c, d, 1, 1,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2,\\r\\n&data(ctx)->ks3, (DES_cblock *)ctx->iv,\\r\\nctx->encrypt);\\r\\nout[n / 8] = (out[n / 8] & ~(0x80 >> (unsigned int)(n % 8)))\\r\\n| ((d[0] & 0x80) >> (unsigned int)(n % 8));\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede3_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nwhile (inl >= EVP_MAXCHUNK) {\\r\\nDES_ede3_cfb_encrypt(in, out, 8, (long)EVP_MAXCHUNK,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2,\\r\\n&data(ctx)->ks3, (DES_cblock *)ctx->iv,\\r\\nctx->encrypt);\\r\\ninl -= EVP_MAXCHUNK;\\r\\nin += EVP_MAXCHUNK;\\r\\nout += EVP_MAXCHUNK;\\r\\n}\\r\\nif (inl)\\r\\nDES_ede3_cfb_encrypt(in, out, 8, (long)inl,\\r\\n&data(ctx)->ks1, &data(ctx)->ks2,\\r\\n&data(ctx)->ks3, (DES_cblock *)ctx->iv,\\r\\nctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES_cblock *deskey = (DES_cblock *)key;\\r\\nDES_EDE_KEY *dat = data(ctx);\\r\\ndat->stream.cbc = NULL;\\r\\n# if defined(SPARC_DES_CAPABLE)\\r\\nif (SPARC_DES_CAPABLE) {\\r\\nint mode = ctx->cipher->flags & EVP_CIPH_MODE;\\r\\nif (mode == EVP_CIPH_CBC_MODE) {\\r\\ndes_t4_key_expand(&deskey[0], &dat->ks1);\\r\\ndes_t4_key_expand(&deskey[1], &dat->ks2);\\r\\nmemcpy(&dat->ks3, &dat->ks1, sizeof(dat->ks1));\\r\\ndat->stream.cbc = enc ? des_t4_ede3_cbc_encrypt :\\r\\ndes_t4_ede3_cbc_decrypt;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# ifdef EVP_CHECK_DES_KEY\\r\\nif (DES_set_key_checked(&deskey[0], &dat->ks1)\\r\\n! !DES_set_key_checked(&deskey[1], &dat->ks2))\\r\\nreturn 0;\\r\\n# else\\r\\nDES_set_key_unchecked(&deskey[0], &dat->ks1);\\r\\nDES_set_key_unchecked(&deskey[1], &dat->ks2);\\r\\n# endif\\r\\nmemcpy(&dat->ks3, &dat->ks1, sizeof(dat->ks1));\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ede3_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES_cblock *deskey = (DES_cblock *)key;\\r\\nDES_EDE_KEY *dat = data(ctx);\\r\\n# ifdef KSSL_DEBUG\\r\\n{\\r\\nint i;\\r\\nfprintf(stderr, \"des_ede3_init_key(ctx=%p)\\n\", ctx);\\r\\nfprintf(stderr, \"\\tKEY= \");\\r\\nfor (i = 0; i < 24; i++)\\r\\nfprintf(stderr, \"%02X\", key[i]);\\r\\nfprintf(stderr, \"\\n\");\\r\\nif (iv) {\\r\\nfprintf(stderr, \"\\t IV= \");\\r\\nfor (i = 0; i < 8; i++)\\r\\nfprintf(stderr, \"%02X\", iv[i]);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n}\\r\\n# endif\\r\\ndat->stream.cbc = NULL;\\r\\n# if defined(SPARC_DES_CAPABLE)\\r\\nif (SPARC_DES_CAPABLE) {\\r\\nint mode = ctx->cipher->flags & EVP_CIPH_MODE;\\r\\nif (mode == EVP_CIPH_CBC_MODE) {\\r\\ndes_t4_key_expand(&deskey[0], &dat->ks1);\\r\\ndes_t4_key_expand(&deskey[1], &dat->ks2);\\r\\ndes_t4_key_expand(&deskey[2], &dat->ks3);\\r\\ndat->stream.cbc = enc ? des_t4_ede3_cbc_encrypt :\\r\\ndes_t4_ede3_cbc_decrypt;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# ifdef EVP_CHECK_DES_KEY\\r\\nif (DES_set_key_checked(&deskey[0], &dat->ks1)\\r\\n|| DES_set_key_checked(&deskey[1], &dat->ks2)\\r\\n|| DES_set_key_checked(&deskey[2], &dat->ks3))\\r\\nreturn 0;\\r\\n# else\\r\\nDES_set_key_unchecked(&deskey[0], &dat->ks1);\\r\\nDES_set_key_unchecked(&deskey[1], &dat->ks2);\\r\\nDES_set_key_unchecked(&deskey[2], &dat->ks3);\\r\\n# endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des3_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nDES_cblock *deskey = ptr;\\r\\nswitch (type) {\\r\\ncase EVP_CTRL_RAND_KEY:\\r\\nif (RAND_bytes(ptr, c->key_len) <= 0)\\r\\nreturn 0;\\r\\nDES_set_odd_parity(deskey);\\r\\nif (c->key_len >= 16)\\r\\nDES_set_odd_parity(deskey + 1);\\r\\nif (c->key_len >= 24)\\r\\nDES_set_odd_parity(deskey + 2);\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nconst EVP_CIPHER *EVP_des_ede(void)\\r\\n{\\r\\nreturn &des_ede_ecb;\\r\\n}\\r\\nconst EVP_CIPHER *EVP_des_ede3(void)\\r\\n{\\r\\nreturn &des_ede3_ecb;\\r\\n}\\r\\nstatic int des_ede3_unwrap(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nunsigned char icv[8], iv[8], sha1tmp[SHA_DIGEST_LENGTH];\\r\\nint rv = -1;\\r\\nif (inl < 24)\\r\\nreturn -1;\\r\\nif (!out)\\r\\nreturn inl - 16;\\r\\nmemcpy(ctx->iv, wrap_iv, 8);\\r\\ndes_ede_cbc_cipher(ctx, icv, in, 8);\\r\\nif (out == in) {\\r\\nmemmove(out, out + 8, inl - 8);\\r\\nin -= 8;\\r\\n}\\r\\ndes_ede_cbc_cipher(ctx, out, in + 8, inl - 16);\\r\\ndes_ede_cbc_cipher(ctx, iv, in + inl - 8, 8);\\r\\nBUF_reverse(icv, NULL, 8);\\r\\nBUF_reverse(out, NULL, inl - 16);\\r\\nBUF_reverse(ctx->iv, iv, 8);\\r\\ndes_ede_cbc_cipher(ctx, out, out, inl - 16);\\r\\ndes_ede_cbc_cipher(ctx, icv, icv, 8);\\r\\nSHA1(out, inl - 16, sha1tmp);\\r\\nif (!CRYPTO_memcmp(sha1tmp, icv, 8))\\r\\nrv = inl - 16;\\r\\nOPENSSL_cleanse(icv, 8);\\r\\nOPENSSL_cleanse(sha1tmp, SHA_DIGEST_LENGTH);\\r\\nOPENSSL_cleanse(iv, 8);\\r\\nOPENSSL_cleanse(ctx->iv, 8);\\r\\nif (rv == -1)\\r\\nOPENSSL_cleanse(out, inl - 16);\\r\\nreturn rv;\\r\\n}\\r\\nstatic int des_ede3_wrap(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nunsigned char sha1tmp[SHA_DIGEST_LENGTH];\\r\\nif (!out)\\r\\nreturn inl + 16;\\r\\nmemmove(out + 8, in, inl);\\r\\nSHA1(in, inl, sha1tmp);\\r\\nmemcpy(out + inl + 8, sha1tmp, 8);\\r\\nOPENSSL_cleanse(sha1tmp, SHA_DIGEST_LENGTH);\\r\\nRAND_bytes(ctx->iv, 8);\\r\\nmemcpy(out, ctx->iv, 8);\\r\\ndes_ede_cbc_cipher(ctx, out + 8, out + 8, inl + 8);\\r\\nBUF_reverse(out, NULL, inl + 16);\\r\\nmemcpy(ctx->iv, wrap_iv, 8);\\r\\ndes_ede_cbc_cipher(ctx, out, out, inl + 16);\\r\\nreturn inl + 16;\\r\\n}\\r\\nstatic int des_ede3_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nif (inl >= EVP_MAXCHUNK || inl % 8)\\r\\nreturn -1;\\r\\nif (ctx->encrypt)\\r\\nreturn des_ede3_wrap(ctx, out, in, inl);\\r\\nelse\\r\\nreturn des_ede3_unwrap(ctx, out, in, inl);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_des_ede3_wrap(void)\\r\\n{\\r\\nreturn &des3_wrap;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t_bitst_c", "target": 0, "func": "int ASN1_BIT_STRING_name_print(BIO *out, ASN1_BIT_STRING *bs,\\r\\nBIT_STRING_BITNAME *tbl, int indent)\\r\\n{\\r\\nBIT_STRING_BITNAME *bnam;\\r\\nchar first = 1;\\r\\nBIO_printf(out, \"%*s\", indent, \"\");\\r\\nfor (bnam = tbl; bnam->lname; bnam++) {\\r\\nif (ASN1_BIT_STRING_get_bit(bs, bnam->bitnum)) {\\r\\nif (!first)\\r\\nBIO_puts(out, \", \");\\r\\nBIO_puts(out, bnam->lname);\\r\\nfirst = 0;\\r\\n}\\r\\n}\\r\\nBIO_puts(out, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nint ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, char *name, int value,\\r\\nBIT_STRING_BITNAME *tbl)\\r\\n{\\r\\nint bitnum;\\r\\nbitnum = ASN1_BIT_STRING_num_asc(name, tbl);\\r\\nif (bitnum < 0)\\r\\nreturn 0;\\r\\nif (bs) {\\r\\nif (!ASN1_BIT_STRING_set_bit(bs, bitnum, value))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ASN1_BIT_STRING_num_asc(char *name, BIT_STRING_BITNAME *tbl)\\r\\n{\\r\\nBIT_STRING_BITNAME *bnam;\\r\\nfor (bnam = tbl; bnam->lname; bnam++) {\\r\\nif (!strcmp(bnam->sname, name) || !strcmp(bnam->lname, name))\\r\\nreturn bnam->bitnum;\\r\\n}\\r\\nreturn -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_mem_c", "target": 0, "func": "static void *default_malloc_ex(size_t num, const char *file, int line)\\r\\n{\\r\\nreturn malloc_func(num);\\r\\n}\\r\\nstatic void *default_realloc_ex(void *str, size_t num,\\r\\nconst char *file, int line)\\r\\n{\\r\\nreturn realloc_func(str, num);\\r\\n}\\r\\nstatic void *default_malloc_locked_ex(size_t num, const char *file, int line)\\r\\n{\\r\\nreturn malloc_locked_func(num);\\r\\n}\\r\\nint CRYPTO_set_mem_functions(void *(*m) (size_t), void *(*r) (void *, size_t),\\r\\nvoid (*f) (void *))\\r\\n{\\r\\nOPENSSL_init();\\r\\nif (!allow_customize)\\r\\nreturn 0;\\r\\nif ((m == 0) || (r == 0) || (f == 0))\\r\\nreturn 0;\\r\\nmalloc_func = m;\\r\\nmalloc_ex_func = default_malloc_ex;\\r\\nrealloc_func = r;\\r\\nrealloc_ex_func = default_realloc_ex;\\r\\nfree_func = f;\\r\\nmalloc_locked_func = m;\\r\\nmalloc_locked_ex_func = default_malloc_locked_ex;\\r\\nfree_locked_func = f;\\r\\nreturn 1;\\r\\n}\\r\\nint CRYPTO_set_mem_ex_functions(void *(*m) (size_t, const char *, int),\\r\\nvoid *(*r) (void *, size_t, const char *,\\r\\nint), void (*f) (void *))\\r\\n{\\r\\nif (!allow_customize)\\r\\nreturn 0;\\r\\nif ((m == 0) || (r == 0) || (f == 0))\\r\\nreturn 0;\\r\\nmalloc_func = 0;\\r\\nmalloc_ex_func = m;\\r\\nrealloc_func = 0;\\r\\nrealloc_ex_func = r;\\r\\nfree_func = f;\\r\\nmalloc_locked_func = 0;\\r\\nmalloc_locked_ex_func = m;\\r\\nfree_locked_func = f;\\r\\nreturn 1;\\r\\n}\\r\\nint CRYPTO_set_locked_mem_functions(void *(*m) (size_t), void (*f) (void *))\\r\\n{\\r\\nif (!allow_customize)\\r\\nreturn 0;\\r\\nif ((m == NULL) || (f == NULL))\\r\\nreturn 0;\\r\\nmalloc_locked_func = m;\\r\\nmalloc_locked_ex_func = default_malloc_locked_ex;\\r\\nfree_locked_func = f;\\r\\nreturn 1;\\r\\n}\\r\\nint CRYPTO_set_locked_mem_ex_functions(void *(*m) (size_t, const char *, int),\\r\\nvoid (*f) (void *))\\r\\n{\\r\\nif (!allow_customize)\\r\\nreturn 0;\\r\\nif ((m == NULL) || (f == NULL))\\r\\nreturn 0;\\r\\nmalloc_locked_func = 0;\\r\\nmalloc_locked_ex_func = m;\\r\\nfree_func = f;\\r\\nreturn 1;\\r\\n}\\r\\nint CRYPTO_set_mem_debug_functions(void (*m)\\r\\n(void *, int, const char *, int, int),\\r\\nvoid (*r) (void *, void *, int,\\r\\nconst char *, int, int),\\r\\nvoid (*f) (void *, int), void (*so) (long),\\r\\nlong (*go) (void))\\r\\n{\\r\\nif (!allow_customize_debug)\\r\\nreturn 0;\\r\\nOPENSSL_init();\\r\\nmalloc_debug_func = m;\\r\\nrealloc_debug_func = r;\\r\\nfree_debug_func = f;\\r\\nset_debug_options_func = so;\\r\\nget_debug_options_func = go;\\r\\nreturn 1;\\r\\n}\\r\\nvoid CRYPTO_get_mem_functions(void *(**m) (size_t),\\r\\nvoid *(**r) (void *, size_t),\\r\\nvoid (**f) (void *))\\r\\n{\\r\\nif (m != NULL)\\r\\n*m = (malloc_ex_func == default_malloc_ex) ? malloc_func : 0;\\r\\nif (r != NULL)\\r\\n*r = (realloc_ex_func == default_realloc_ex) ? realloc_func : 0;\\r\\nif (f != NULL)\\r\\n*f = free_func;\\r\\n}\\r\\nvoid CRYPTO_get_mem_ex_functions(void *(**m) (size_t, const char *, int),\\r\\nvoid *(**r) (void *, size_t, const char *,\\r\\nint), void (**f) (void *))\\r\\n{\\r\\nif (m != NULL)\\r\\n*m = (malloc_ex_func != default_malloc_ex) ? malloc_ex_func : 0;\\r\\nif (r != NULL)\\r\\n*r = (realloc_ex_func != default_realloc_ex) ? realloc_ex_func : 0;\\r\\nif (f != NULL)\\r\\n*f = free_func;\\r\\n}\\r\\nvoid CRYPTO_get_locked_mem_functions(void *(**m) (size_t),\\r\\nvoid (**f) (void *))\\r\\n{\\r\\nif (m != NULL)\\r\\n*m = (malloc_locked_ex_func == default_malloc_locked_ex) ?\\r\\nmalloc_locked_func : 0;\\r\\nif (f != NULL)\\r\\n*f = free_locked_func;\\r\\n}\\r\\nvoid CRYPTO_get_locked_mem_ex_functions(void\\r\\n*(**m) (size_t, const char *, int),\\r\\nvoid (**f) (void *))\\r\\n{\\r\\nif (m != NULL)\\r\\n*m = (malloc_locked_ex_func != default_malloc_locked_ex) ?\\r\\nmalloc_locked_ex_func : 0;\\r\\nif (f != NULL)\\r\\n*f = free_locked_func;\\r\\n}\\r\\nvoid CRYPTO_get_mem_debug_functions(void (**m)\\r\\n(void *, int, const char *, int, int),\\r\\nvoid (**r) (void *, void *, int,\\r\\nconst char *, int, int),\\r\\nvoid (**f) (void *, int),\\r\\nvoid (**so) (long), long (**go) (void))\\r\\n{\\r\\nif (m != NULL)\\r\\n*m = malloc_debug_func;\\r\\nif (r != NULL)\\r\\n*r = realloc_debug_func;\\r\\nif (f != NULL)\\r\\n*f = free_debug_func;\\r\\nif (so != NULL)\\r\\n*so = set_debug_options_func;\\r\\nif (go != NULL)\\r\\n*go = get_debug_options_func;\\r\\n}\\r\\nvoid *CRYPTO_malloc_locked(int num, const char *file, int line)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nif (num <= 0)\\r\\nreturn NULL;\\r\\nif (allow_customize)\\r\\nallow_customize = 0;\\r\\nif (malloc_debug_func != NULL) {\\r\\nif (allow_customize_debug)\\r\\nallow_customize_debug = 0;\\r\\nmalloc_debug_func(NULL, num, file, line, 0);\\r\\n}\\r\\nret = malloc_locked_ex_func(num, file, line);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: > 0x%p (%d)\\n\", ret, num);\\r\\n#endif\\r\\nif (malloc_debug_func != NULL)\\r\\nmalloc_debug_func(ret, num, file, line, 1);\\r\\n#ifndef OPENSSL_CPUID_OBJ\\r\\nif (ret && (num > 2048)) {\\r\\nextern unsigned char cleanse_ctr;\\r\\n((unsigned char *)ret)[0] = cleanse_ctr;\\r\\n}\\r\\n#endif\\r\\nreturn ret;\\r\\n}\\r\\nvoid CRYPTO_free_locked(void *str)\\r\\n{\\r\\nif (free_debug_func != NULL)\\r\\nfree_debug_func(str, 0);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: < 0x%p\\n\", str);\\r\\n#endif\\r\\nfree_locked_func(str);\\r\\nif (free_debug_func != NULL)\\r\\nfree_debug_func(NULL, 1);\\r\\n}\\r\\nvoid *CRYPTO_malloc(int num, const char *file, int line)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nif (num <= 0)\\r\\nreturn NULL;\\r\\nif (allow_customize)\\r\\nallow_customize = 0;\\r\\nif (malloc_debug_func != NULL) {\\r\\nif (allow_customize_debug)\\r\\nallow_customize_debug = 0;\\r\\nmalloc_debug_func(NULL, num, file, line, 0);\\r\\n}\\r\\nret = malloc_ex_func(num, file, line);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: > 0x%p (%d)\\n\", ret, num);\\r\\n#endif\\r\\nif (malloc_debug_func != NULL)\\r\\nmalloc_debug_func(ret, num, file, line, 1);\\r\\n#ifndef OPENSSL_CPUID_OBJ\\r\\nif (ret && (num > 2048)) {\\r\\nextern unsigned char cleanse_ctr;\\r\\n((unsigned char *)ret)[0] = cleanse_ctr;\\r\\n}\\r\\n#endif\\r\\nreturn ret;\\r\\n}\\r\\nchar *CRYPTO_strdup(const char *str, const char *file, int line)\\r\\n{\\r\\nchar *ret = CRYPTO_malloc(strlen(str) + 1, file, line);\\r\\nstrcpy(ret, str);\\r\\nreturn ret;\\r\\n}\\r\\nvoid *CRYPTO_realloc(void *str, int num, const char *file, int line)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nif (str == NULL)\\r\\nreturn CRYPTO_malloc(num, file, line);\\r\\nif (num <= 0)\\r\\nreturn NULL;\\r\\nif (realloc_debug_func != NULL)\\r\\nrealloc_debug_func(str, NULL, num, file, line, 0);\\r\\nret = realloc_ex_func(str, num, file, line);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: | 0x%p -> 0x%p (%d)\\n\", str,\\r\\nret, num);\\r\\n#endif\\r\\nif (realloc_debug_func != NULL)\\r\\nrealloc_debug_func(str, ret, num, file, line, 1);\\r\\nreturn ret;\\r\\n}\\r\\nvoid *CRYPTO_realloc_clean(void *str, int old_len, int num, const char *file,\\r\\nint line)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nif (str == NULL)\\r\\nreturn CRYPTO_malloc(num, file, line);\\r\\nif (num <= 0)\\r\\nreturn NULL;\\r\\nif (num < old_len)\\r\\nreturn NULL;\\r\\nif (realloc_debug_func != NULL)\\r\\nrealloc_debug_func(str, NULL, num, file, line, 0);\\r\\nret = malloc_ex_func(num, file, line);\\r\\nif (ret) {\\r\\nmemcpy(ret, str, old_len);\\r\\nOPENSSL_cleanse(str, old_len);\\r\\nfree_func(str);\\r\\n}\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr,\\r\\n\"LEVITTE_DEBUG_MEM: | 0x%p -> 0x%p (%d)\\n\",\\r\\nstr, ret, num);\\r\\n#endif\\r\\nif (realloc_debug_func != NULL)\\r\\nrealloc_debug_func(str, ret, num, file, line, 1);\\r\\nreturn ret;\\r\\n}\\r\\nvoid CRYPTO_free(void *str)\\r\\n{\\r\\nif (free_debug_func != NULL)\\r\\nfree_debug_func(str, 0);\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: < 0x%p\\n\", str);\\r\\n#endif\\r\\nfree_func(str);\\r\\nif (free_debug_func != NULL)\\r\\nfree_debug_func(NULL, 1);\\r\\n}\\r\\nvoid *CRYPTO_remalloc(void *a, int num, const char *file, int line)\\r\\n{\\r\\nif (a != NULL)\\r\\nOPENSSL_free(a);\\r\\na = (char *)OPENSSL_malloc(num);\\r\\nreturn (a);\\r\\n}\\r\\nvoid CRYPTO_set_mem_debug_options(long bits)\\r\\n{\\r\\nif (set_debug_options_func != NULL)\\r\\nset_debug_options_func(bits);\\r\\n}\\r\\nlong CRYPTO_get_mem_debug_options(void)\\r\\n{\\r\\nif (get_debug_options_func != NULL)\\r\\nreturn get_debug_options_func();\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_purp_c", "target": 0, "func": "static int xp_cmp(const X509_PURPOSE *const *a, const X509_PURPOSE *const *b)\\r\\n{\\r\\nreturn (*a)->purpose - (*b)->purpose;\\r\\n}\\r\\nint X509_check_purpose(X509 *x, int id, int ca)\\r\\n{\\r\\nint idx;\\r\\nconst X509_PURPOSE *pt;\\r\\nif (!(x->ex_flags & EXFLAG_SET)) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509);\\r\\nx509v3_cache_extensions(x);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509);\\r\\n}\\r\\nif (id == -1)\\r\\nreturn 1;\\r\\nidx = X509_PURPOSE_get_by_id(id);\\r\\nif (idx == -1)\\r\\nreturn -1;\\r\\npt = X509_PURPOSE_get0(idx);\\r\\nreturn pt->check_purpose(pt, x, ca);\\r\\n}\\r\\nint X509_PURPOSE_set(int *p, int purpose)\\r\\n{\\r\\nif (X509_PURPOSE_get_by_id(purpose) == -1) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_SET, X509V3_R_INVALID_PURPOSE);\\r\\nreturn 0;\\r\\n}\\r\\n*p = purpose;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_PURPOSE_get_count(void)\\r\\n{\\r\\nif (!xptable)\\r\\nreturn X509_PURPOSE_COUNT;\\r\\nreturn sk_X509_PURPOSE_num(xptable) + X509_PURPOSE_COUNT;\\r\\n}\\r\\nX509_PURPOSE *X509_PURPOSE_get0(int idx)\\r\\n{\\r\\nif (idx < 0)\\r\\nreturn NULL;\\r\\nif (idx < (int)X509_PURPOSE_COUNT)\\r\\nreturn xstandard + idx;\\r\\nreturn sk_X509_PURPOSE_value(xptable, idx - X509_PURPOSE_COUNT);\\r\\n}\\r\\nint X509_PURPOSE_get_by_sname(char *sname)\\r\\n{\\r\\nint i;\\r\\nX509_PURPOSE *xptmp;\\r\\nfor (i = 0; i < X509_PURPOSE_get_count(); i++) {\\r\\nxptmp = X509_PURPOSE_get0(i);\\r\\nif (!strcmp(xptmp->sname, sname))\\r\\nreturn i;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nint X509_PURPOSE_get_by_id(int purpose)\\r\\n{\\r\\nX509_PURPOSE tmp;\\r\\nint idx;\\r\\nif ((purpose >= X509_PURPOSE_MIN) && (purpose <= X509_PURPOSE_MAX))\\r\\nreturn purpose - X509_PURPOSE_MIN;\\r\\ntmp.purpose = purpose;\\r\\nif (!xptable)\\r\\nreturn -1;\\r\\nidx = sk_X509_PURPOSE_find(xptable, &tmp);\\r\\nif (idx == -1)\\r\\nreturn -1;\\r\\nreturn idx + X509_PURPOSE_COUNT;\\r\\n}\\r\\nint X509_PURPOSE_add(int id, int trust, int flags,\\r\\nint (*ck) (const X509_PURPOSE *, const X509 *, int),\\r\\nchar *name, char *sname, void *arg)\\r\\n{\\r\\nint idx;\\r\\nX509_PURPOSE *ptmp;\\r\\nflags &= ~X509_PURPOSE_DYNAMIC;\\r\\nflags |= X509_PURPOSE_DYNAMIC_NAME;\\r\\nidx = X509_PURPOSE_get_by_id(id);\\r\\nif (idx == -1) {\\r\\nif (!(ptmp = OPENSSL_malloc(sizeof(X509_PURPOSE)))) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nptmp->flags = X509_PURPOSE_DYNAMIC;\\r\\n} else\\r\\nptmp = X509_PURPOSE_get0(idx);\\r\\nif (ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) {\\r\\nOPENSSL_free(ptmp->name);\\r\\nOPENSSL_free(ptmp->sname);\\r\\n}\\r\\nptmp->name = BUF_strdup(name);\\r\\nptmp->sname = BUF_strdup(sname);\\r\\nif (!ptmp->name || !ptmp->sname) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nptmp->flags &= X509_PURPOSE_DYNAMIC;\\r\\nptmp->flags |= flags;\\r\\nptmp->purpose = id;\\r\\nptmp->trust = trust;\\r\\nptmp->check_purpose = ck;\\r\\nptmp->usr_data = arg;\\r\\nif (idx == -1) {\\r\\nif (!xptable && !(xptable = sk_X509_PURPOSE_new(xp_cmp))) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_X509_PURPOSE_push(xptable, ptmp)) {\\r\\nX509V3err(X509V3_F_X509_PURPOSE_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void xptable_free(X509_PURPOSE *p)\\r\\n{\\r\\nif (!p)\\r\\nreturn;\\r\\nif (p->flags & X509_PURPOSE_DYNAMIC) {\\r\\nif (p->flags & X509_PURPOSE_DYNAMIC_NAME) {\\r\\nOPENSSL_free(p->name);\\r\\nOPENSSL_free(p->sname);\\r\\n}\\r\\nOPENSSL_free(p);\\r\\n}\\r\\n}\\r\\nvoid X509_PURPOSE_cleanup(void)\\r\\n{\\r\\nunsigned int i;\\r\\nsk_X509_PURPOSE_pop_free(xptable, xptable_free);\\r\\nfor (i = 0; i < X509_PURPOSE_COUNT; i++)\\r\\nxptable_free(xstandard + i);\\r\\nxptable = NULL;\\r\\n}\\r\\nint X509_PURPOSE_get_id(X509_PURPOSE *xp)\\r\\n{\\r\\nreturn xp->purpose;\\r\\n}\\r\\nchar *X509_PURPOSE_get0_name(X509_PURPOSE *xp)\\r\\n{\\r\\nreturn xp->name;\\r\\n}\\r\\nchar *X509_PURPOSE_get0_sname(X509_PURPOSE *xp)\\r\\n{\\r\\nreturn xp->sname;\\r\\n}\\r\\nint X509_PURPOSE_get_trust(X509_PURPOSE *xp)\\r\\n{\\r\\nreturn xp->trust;\\r\\n}\\r\\nstatic int nid_cmp(const int *a, const int *b)\\r\\n{\\r\\nreturn *a - *b;\\r\\n}\\r\\nint X509_supported_extension(X509_EXTENSION *ex)\\r\\n{\\r\\nstatic const int supported_nids[] = {\\r\\nNID_netscape_cert_type,\\r\\nNID_key_usage,\\r\\nNID_subject_alt_name,\\r\\nNID_basic_constraints,\\r\\nNID_certificate_policies,\\r\\nNID_ext_key_usage,\\r\\n#ifndef OPENSSL_NO_RFC3779\\r\\nNID_sbgp_ipAddrBlock,\\r\\nNID_sbgp_autonomousSysNum,\\r\\n#endif\\r\\nNID_policy_constraints,\\r\\nNID_proxyCertInfo,\\r\\nNID_name_constraints,\\r\\nNID_policy_mappings,\\r\\nNID_inhibit_any_policy\\r\\n};\\r\\nint ex_nid = OBJ_obj2nid(X509_EXTENSION_get_object(ex));\\r\\nif (ex_nid == NID_undef)\\r\\nreturn 0;\\r\\nif (OBJ_bsearch_nid(&ex_nid, supported_nids,\\r\\nsizeof(supported_nids) / sizeof(int)))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic void setup_dp(X509 *x, DIST_POINT *dp)\\r\\n{\\r\\nX509_NAME *iname = NULL;\\r\\nint i;\\r\\nif (dp->reasons) {\\r\\nif (dp->reasons->length > 0)\\r\\ndp->dp_reasons = dp->reasons->data[0];\\r\\nif (dp->reasons->length > 1)\\r\\ndp->dp_reasons |= (dp->reasons->data[1] << 8);\\r\\ndp->dp_reasons &= CRLDP_ALL_REASONS;\\r\\n} else\\r\\ndp->dp_reasons = CRLDP_ALL_REASONS;\\r\\nif (!dp->distpoint || (dp->distpoint->type != 1))\\r\\nreturn;\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++) {\\r\\nGENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);\\r\\nif (gen->type == GEN_DIRNAME) {\\r\\niname = gen->d.directoryName;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!iname)\\r\\niname = X509_get_issuer_name(x);\\r\\nDIST_POINT_set_dpname(dp->distpoint, iname);\\r\\n}\\r\\nstatic void setup_crldp(X509 *x)\\r\\n{\\r\\nint i;\\r\\nx->crldp = X509_get_ext_d2i(x, NID_crl_distribution_points, NULL, NULL);\\r\\nfor (i = 0; i < sk_DIST_POINT_num(x->crldp); i++)\\r\\nsetup_dp(x, sk_DIST_POINT_value(x->crldp, i));\\r\\n}\\r\\nstatic void x509v3_cache_extensions(X509 *x)\\r\\n{\\r\\nBASIC_CONSTRAINTS *bs;\\r\\nPROXY_CERT_INFO_EXTENSION *pci;\\r\\nASN1_BIT_STRING *usage;\\r\\nASN1_BIT_STRING *ns;\\r\\nEXTENDED_KEY_USAGE *extusage;\\r\\nX509_EXTENSION *ex;\\r\\nint i;\\r\\nif (x->ex_flags & EXFLAG_SET)\\r\\nreturn;\\r\\n#ifndef OPENSSL_NO_SHA\\r\\nX509_digest(x, EVP_sha1(), x->sha1_hash, NULL);\\r\\n#endif\\r\\nif (!X509_get_version(x))\\r\\nx->ex_flags |= EXFLAG_V1;\\r\\nif ((bs = X509_get_ext_d2i(x, NID_basic_constraints, NULL, NULL))) {\\r\\nif (bs->ca)\\r\\nx->ex_flags |= EXFLAG_CA;\\r\\nif (bs->pathlen) {\\r\\nif ((bs->pathlen->type == V_ASN1_NEG_INTEGER)\\r\\n|| !bs->ca) {\\r\\nx->ex_flags |= EXFLAG_INVALID;\\r\\nx->ex_pathlen = 0;\\r\\n} else\\r\\nx->ex_pathlen = ASN1_INTEGER_get(bs->pathlen);\\r\\n} else\\r\\nx->ex_pathlen = -1;\\r\\nBASIC_CONSTRAINTS_free(bs);\\r\\nx->ex_flags |= EXFLAG_BCONS;\\r\\n}\\r\\nif ((pci = X509_get_ext_d2i(x, NID_proxyCertInfo, NULL, NULL))) {\\r\\nif (x->ex_flags & EXFLAG_CA\\r\\n|| X509_get_ext_by_NID(x, NID_subject_alt_name, -1) >= 0\\r\\n|| X509_get_ext_by_NID(x, NID_issuer_alt_name, -1) >= 0) {\\r\\nx->ex_flags |= EXFLAG_INVALID;\\r\\n}\\r\\nif (pci->pcPathLengthConstraint) {\\r\\nx->ex_pcpathlen = ASN1_INTEGER_get(pci->pcPathLengthConstraint);\\r\\n} else\\r\\nx->ex_pcpathlen = -1;\\r\\nPROXY_CERT_INFO_EXTENSION_free(pci);\\r\\nx->ex_flags |= EXFLAG_PROXY;\\r\\n}\\r\\nif ((usage = X509_get_ext_d2i(x, NID_key_usage, NULL, NULL))) {\\r\\nif (usage->length > 0) {\\r\\nx->ex_kusage = usage->data[0];\\r\\nif (usage->length > 1)\\r\\nx->ex_kusage |= usage->data[1] << 8;\\r\\n} else\\r\\nx->ex_kusage = 0;\\r\\nx->ex_flags |= EXFLAG_KUSAGE;\\r\\nASN1_BIT_STRING_free(usage);\\r\\n}\\r\\nx->ex_xkusage = 0;\\r\\nif ((extusage = X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL))) {\\r\\nx->ex_flags |= EXFLAG_XKUSAGE;\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {\\r\\nswitch (OBJ_obj2nid(sk_ASN1_OBJECT_value(extusage, i))) {\\r\\ncase NID_server_auth:\\r\\nx->ex_xkusage |= XKU_SSL_SERVER;\\r\\nbreak;\\r\\ncase NID_client_auth:\\r\\nx->ex_xkusage |= XKU_SSL_CLIENT;\\r\\nbreak;\\r\\ncase NID_email_protect:\\r\\nx->ex_xkusage |= XKU_SMIME;\\r\\nbreak;\\r\\ncase NID_code_sign:\\r\\nx->ex_xkusage |= XKU_CODE_SIGN;\\r\\nbreak;\\r\\ncase NID_ms_sgc:\\r\\ncase NID_ns_sgc:\\r\\nx->ex_xkusage |= XKU_SGC;\\r\\nbreak;\\r\\ncase NID_OCSP_sign:\\r\\nx->ex_xkusage |= XKU_OCSP_SIGN;\\r\\nbreak;\\r\\ncase NID_time_stamp:\\r\\nx->ex_xkusage |= XKU_TIMESTAMP;\\r\\nbreak;\\r\\ncase NID_dvcs:\\r\\nx->ex_xkusage |= XKU_DVCS;\\r\\nbreak;\\r\\ncase NID_anyExtendedKeyUsage:\\r\\nx->ex_xkusage |= XKU_ANYEKU;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nsk_ASN1_OBJECT_pop_free(extusage, ASN1_OBJECT_free);\\r\\n}\\r\\nif ((ns = X509_get_ext_d2i(x, NID_netscape_cert_type, NULL, NULL))) {\\r\\nif (ns->length > 0)\\r\\nx->ex_nscert = ns->data[0];\\r\\nelse\\r\\nx->ex_nscert = 0;\\r\\nx->ex_flags |= EXFLAG_NSCERT;\\r\\nASN1_BIT_STRING_free(ns);\\r\\n}\\r\\nx->skid = X509_get_ext_d2i(x, NID_subject_key_identifier, NULL, NULL);\\r\\nx->akid = X509_get_ext_d2i(x, NID_authority_key_identifier, NULL, NULL);\\r\\nif (!X509_NAME_cmp(X509_get_subject_name(x), X509_get_issuer_name(x))) {\\r\\nx->ex_flags |= EXFLAG_SI;\\r\\nif (X509_check_akid(x, x->akid) == X509_V_OK)\\r\\nx->ex_flags |= EXFLAG_SS;\\r\\n}\\r\\nx->altname = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);\\r\\nx->nc = X509_get_ext_d2i(x, NID_name_constraints, &i, NULL);\\r\\nif (!x->nc && (i != -1))\\r\\nx->ex_flags |= EXFLAG_INVALID;\\r\\nsetup_crldp(x);\\r\\n#ifndef OPENSSL_NO_RFC3779\\r\\nx->rfc3779_addr = X509_get_ext_d2i(x, NID_sbgp_ipAddrBlock, NULL, NULL);\\r\\nx->rfc3779_asid = X509_get_ext_d2i(x, NID_sbgp_autonomousSysNum,\\r\\nNULL, NULL);\\r\\n#endif\\r\\nfor (i = 0; i < X509_get_ext_count(x); i++) {\\r\\nex = X509_get_ext(x, i);\\r\\nif (OBJ_obj2nid(X509_EXTENSION_get_object(ex))\\r\\n== NID_freshest_crl)\\r\\nx->ex_flags |= EXFLAG_FRESHEST;\\r\\nif (!X509_EXTENSION_get_critical(ex))\\r\\ncontinue;\\r\\nif (!X509_supported_extension(ex)) {\\r\\nx->ex_flags |= EXFLAG_CRITICAL;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nx->ex_flags |= EXFLAG_SET;\\r\\n}\\r\\nstatic int check_ca(const X509 *x)\\r\\n{\\r\\nif (ku_reject(x, KU_KEY_CERT_SIGN))\\r\\nreturn 0;\\r\\nif (x->ex_flags & EXFLAG_BCONS) {\\r\\nif (x->ex_flags & EXFLAG_CA)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n} else {\\r\\nif ((x->ex_flags & V1_ROOT) == V1_ROOT)\\r\\nreturn 3;\\r\\nelse if (x->ex_flags & EXFLAG_KUSAGE)\\r\\nreturn 4;\\r\\nelse if (x->ex_flags & EXFLAG_NSCERT && x->ex_nscert & NS_ANY_CA)\\r\\nreturn 5;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nint X509_check_ca(X509 *x)\\r\\n{\\r\\nif (!(x->ex_flags & EXFLAG_SET)) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509);\\r\\nx509v3_cache_extensions(x);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509);\\r\\n}\\r\\nreturn check_ca(x);\\r\\n}\\r\\nstatic int check_ssl_ca(const X509 *x)\\r\\n{\\r\\nint ca_ret;\\r\\nca_ret = check_ca(x);\\r\\nif (!ca_ret)\\r\\nreturn 0;\\r\\nif (ca_ret != 5 || x->ex_nscert & NS_SSL_CA)\\r\\nreturn ca_ret;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nstatic int check_purpose_ssl_client(const X509_PURPOSE *xp, const X509 *x,\\r\\nint ca)\\r\\n{\\r\\nif (xku_reject(x, XKU_SSL_CLIENT))\\r\\nreturn 0;\\r\\nif (ca)\\r\\nreturn check_ssl_ca(x);\\r\\nif (ku_reject(x, KU_DIGITAL_SIGNATURE | KU_KEY_AGREEMENT))\\r\\nreturn 0;\\r\\nif (ns_reject(x, NS_SSL_CLIENT))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_purpose_ssl_server(const X509_PURPOSE *xp, const X509 *x,\\r\\nint ca)\\r\\n{\\r\\nif (xku_reject(x, XKU_SSL_SERVER | XKU_SGC))\\r\\nreturn 0;\\r\\nif (ca)\\r\\nreturn check_ssl_ca(x);\\r\\nif (ns_reject(x, NS_SSL_SERVER))\\r\\nreturn 0;\\r\\nif (ku_reject(x, KU_TLS))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_purpose_ns_ssl_server(const X509_PURPOSE *xp, const X509 *x,\\r\\nint ca)\\r\\n{\\r\\nint ret;\\r\\nret = check_purpose_ssl_server(xp, x, ca);\\r\\nif (!ret || ca)\\r\\nreturn ret;\\r\\nif (ku_reject(x, KU_KEY_ENCIPHERMENT))\\r\\nreturn 0;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int purpose_smime(const X509 *x, int ca)\\r\\n{\\r\\nif (xku_reject(x, XKU_SMIME))\\r\\nreturn 0;\\r\\nif (ca) {\\r\\nint ca_ret;\\r\\nca_ret = check_ca(x);\\r\\nif (!ca_ret)\\r\\nreturn 0;\\r\\nif (ca_ret != 5 || x->ex_nscert & NS_SMIME_CA)\\r\\nreturn ca_ret;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nif (x->ex_flags & EXFLAG_NSCERT) {\\r\\nif (x->ex_nscert & NS_SMIME)\\r\\nreturn 1;\\r\\nif (x->ex_nscert & NS_SSL_CLIENT)\\r\\nreturn 2;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_purpose_smime_sign(const X509_PURPOSE *xp, const X509 *x,\\r\\nint ca)\\r\\n{\\r\\nint ret;\\r\\nret = purpose_smime(x, ca);\\r\\nif (!ret || ca)\\r\\nreturn ret;\\r\\nif (ku_reject(x, KU_DIGITAL_SIGNATURE | KU_NON_REPUDIATION))\\r\\nreturn 0;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int check_purpose_smime_encrypt(const X509_PURPOSE *xp, const X509 *x,\\r\\nint ca)\\r\\n{\\r\\nint ret;\\r\\nret = purpose_smime(x, ca);\\r\\nif (!ret || ca)\\r\\nreturn ret;\\r\\nif (ku_reject(x, KU_KEY_ENCIPHERMENT))\\r\\nreturn 0;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int check_purpose_crl_sign(const X509_PURPOSE *xp, const X509 *x,\\r\\nint ca)\\r\\n{\\r\\nif (ca) {\\r\\nint ca_ret;\\r\\nif ((ca_ret = check_ca(x)) != 2)\\r\\nreturn ca_ret;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nif (ku_reject(x, KU_CRL_SIGN))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ocsp_helper(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nif (ca)\\r\\nreturn check_ca(x);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_purpose_timestamp_sign(const X509_PURPOSE *xp, const X509 *x,\\r\\nint ca)\\r\\n{\\r\\nint i_ext;\\r\\nif (ca)\\r\\nreturn check_ca(x);\\r\\nif ((x->ex_flags & EXFLAG_KUSAGE)\\r\\n&& ((x->ex_kusage & ~(KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE)) ||\\r\\n!(x->ex_kusage & (KU_NON_REPUDIATION | KU_DIGITAL_SIGNATURE))))\\r\\nreturn 0;\\r\\nif (!(x->ex_flags & EXFLAG_XKUSAGE) || x->ex_xkusage != XKU_TIMESTAMP)\\r\\nreturn 0;\\r\\ni_ext = X509_get_ext_by_NID((X509 *)x, NID_ext_key_usage, -1);\\r\\nif (i_ext >= 0) {\\r\\nX509_EXTENSION *ext = X509_get_ext((X509 *)x, i_ext);\\r\\nif (!X509_EXTENSION_get_critical(ext))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int no_check(const X509_PURPOSE *xp, const X509 *x, int ca)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nint X509_check_issued(X509 *issuer, X509 *subject)\\r\\n{\\r\\nif (X509_NAME_cmp(X509_get_subject_name(issuer),\\r\\nX509_get_issuer_name(subject)))\\r\\nreturn X509_V_ERR_SUBJECT_ISSUER_MISMATCH;\\r\\nx509v3_cache_extensions(issuer);\\r\\nx509v3_cache_extensions(subject);\\r\\nif (subject->akid) {\\r\\nint ret = X509_check_akid(issuer, subject->akid);\\r\\nif (ret != X509_V_OK)\\r\\nreturn ret;\\r\\n}\\r\\nif (subject->ex_flags & EXFLAG_PROXY) {\\r\\nif (ku_reject(issuer, KU_DIGITAL_SIGNATURE))\\r\\nreturn X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE;\\r\\n} else if (ku_reject(issuer, KU_KEY_CERT_SIGN))\\r\\nreturn X509_V_ERR_KEYUSAGE_NO_CERTSIGN;\\r\\nreturn X509_V_OK;\\r\\n}\\r\\nint X509_check_akid(X509 *issuer, AUTHORITY_KEYID *akid)\\r\\n{\\r\\nif (!akid)\\r\\nreturn X509_V_OK;\\r\\nif (akid->keyid && issuer->skid &&\\r\\nASN1_OCTET_STRING_cmp(akid->keyid, issuer->skid))\\r\\nreturn X509_V_ERR_AKID_SKID_MISMATCH;\\r\\nif (akid->serial &&\\r\\nASN1_INTEGER_cmp(X509_get_serialNumber(issuer), akid->serial))\\r\\nreturn X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;\\r\\nif (akid->issuer) {\\r\\nGENERAL_NAMES *gens;\\r\\nGENERAL_NAME *gen;\\r\\nX509_NAME *nm = NULL;\\r\\nint i;\\r\\ngens = akid->issuer;\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {\\r\\ngen = sk_GENERAL_NAME_value(gens, i);\\r\\nif (gen->type == GEN_DIRNAME) {\\r\\nnm = gen->d.dirn;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (nm && X509_NAME_cmp(nm, X509_get_issuer_name(issuer)))\\r\\nreturn X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;\\r\\n}\\r\\nreturn X509_V_OK;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_utctm_c", "target": 0, "func": "int asn1_utctime_to_tm(struct tm *tm, const ASN1_UTCTIME *d)\\r\\n{\\r\\nstatic const int min[8] = { 0, 1, 1, 0, 0, 0, 0, 0 };\\r\\nstatic const int max[8] = { 99, 12, 31, 23, 59, 59, 12, 59 };\\r\\nchar *a;\\r\\nint n, i, l, o;\\r\\nif (d->type != V_ASN1_UTCTIME)\\r\\nreturn (0);\\r\\nl = d->length;\\r\\na = (char *)d->data;\\r\\no = 0;\\r\\nif (l < 11)\\r\\ngoto err;\\r\\nfor (i = 0; i < 6; i++) {\\r\\nif ((i == 5) && ((a[o] == 'Z') || (a[o] == '+') || (a[o] == '-'))) {\\r\\ni++;\\r\\nif (tm)\\r\\ntm->tm_sec = 0;\\r\\nbreak;\\r\\n}\\r\\nif ((a[o] < '0') || (a[o] > '9'))\\r\\ngoto err;\\r\\nn = a[o] - '0';\\r\\nif (++o > l)\\r\\ngoto err;\\r\\nif ((a[o] < '0') || (a[o] > '9'))\\r\\ngoto err;\\r\\nn = (n * 10) + a[o] - '0';\\r\\nif (++o > l)\\r\\ngoto err;\\r\\nif ((n < min[i]) || (n > max[i]))\\r\\ngoto err;\\r\\nif (tm) {\\r\\nswitch (i) {\\r\\ncase 0:\\r\\ntm->tm_year = n < 50 ? n + 100 : n;\\r\\nbreak;\\r\\ncase 1:\\r\\ntm->tm_mon = n - 1;\\r\\nbreak;\\r\\ncase 2:\\r\\ntm->tm_mday = n;\\r\\nbreak;\\r\\ncase 3:\\r\\ntm->tm_hour = n;\\r\\nbreak;\\r\\ncase 4:\\r\\ntm->tm_min = n;\\r\\nbreak;\\r\\ncase 5:\\r\\ntm->tm_sec = n;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (a[o] == 'Z')\\r\\no++;\\r\\nelse if ((a[o] == '+') || (a[o] == '-')) {\\r\\nint offsign = a[o] == '-' ? -1 : 1, offset = 0;\\r\\no++;\\r\\nif (o + 4 > l)\\r\\ngoto err;\\r\\nfor (i = 6; i < 8; i++) {\\r\\nif ((a[o] < '0') || (a[o] > '9'))\\r\\ngoto err;\\r\\nn = a[o] - '0';\\r\\no++;\\r\\nif ((a[o] < '0') || (a[o] > '9'))\\r\\ngoto err;\\r\\nn = (n * 10) + a[o] - '0';\\r\\nif ((n < min[i]) || (n > max[i]))\\r\\ngoto err;\\r\\nif (tm) {\\r\\nif (i == 6)\\r\\noffset = n * 3600;\\r\\nelse if (i == 7)\\r\\noffset += n * 60;\\r\\n}\\r\\no++;\\r\\n}\\r\\nif (offset && !OPENSSL_gmtime_adj(tm, 0, offset * offsign))\\r\\nreturn 0;\\r\\n}\\r\\nreturn o == l;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint ASN1_UTCTIME_check(const ASN1_UTCTIME *d)\\r\\n{\\r\\nreturn asn1_utctime_to_tm(NULL, d);\\r\\n}\\r\\nint ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str)\\r\\n{\\r\\nASN1_UTCTIME t;\\r\\nt.type = V_ASN1_UTCTIME;\\r\\nt.length = strlen(str);\\r\\nt.data = (unsigned char *)str;\\r\\nif (ASN1_UTCTIME_check(&t)) {\\r\\nif (s != NULL) {\\r\\nif (!ASN1_STRING_set((ASN1_STRING *)s,\\r\\n(unsigned char *)str, t.length))\\r\\nreturn 0;\\r\\ns->type = V_ASN1_UTCTIME;\\r\\n}\\r\\nreturn (1);\\r\\n} else\\r\\nreturn (0);\\r\\n}\\r\\nASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t)\\r\\n{\\r\\nreturn ASN1_UTCTIME_adj(s, t, 0, 0);\\r\\n}\\r\\nASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,\\r\\nint offset_day, long offset_sec)\\r\\n{\\r\\nchar *p;\\r\\nstruct tm *ts;\\r\\nstruct tm data;\\r\\nsize_t len = 20;\\r\\nint free_s = 0;\\r\\nif (s == NULL) {\\r\\nfree_s = 1;\\r\\ns = M_ASN1_UTCTIME_new();\\r\\n}\\r\\nif (s == NULL)\\r\\ngoto err;\\r\\nts = OPENSSL_gmtime(&t, &data);\\r\\nif (ts == NULL)\\r\\ngoto err;\\r\\nif (offset_day || offset_sec) {\\r\\nif (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))\\r\\ngoto err;\\r\\n}\\r\\nif ((ts->tm_year < 50) || (ts->tm_year >= 150))\\r\\ngoto err;\\r\\np = (char *)s->data;\\r\\nif ((p == NULL) || ((size_t)s->length < len)) {\\r\\np = OPENSSL_malloc(len);\\r\\nif (p == NULL) {\\r\\nASN1err(ASN1_F_ASN1_UTCTIME_ADJ, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (s->data != NULL)\\r\\nOPENSSL_free(s->data);\\r\\ns->data = (unsigned char *)p;\\r\\n}\\r\\nBIO_snprintf(p, len, \"%02d%02d%02d%02d%02d%02dZ\", ts->tm_year % 100,\\r\\nts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min,\\r\\nts->tm_sec);\\r\\ns->length = strlen(p);\\r\\ns->type = V_ASN1_UTCTIME;\\r\\n#ifdef CHARSET_EBCDIC_not\\r\\nebcdic2ascii(s->data, s->data, s->length);\\r\\n#endif\\r\\nreturn (s);\\r\\nerr:\\r\\nif (free_s && s)\\r\\nM_ASN1_UTCTIME_free(s);\\r\\nreturn NULL;\\r\\n}\\r\\nint ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t)\\r\\n{\\r\\nstruct tm stm, ttm;\\r\\nint day, sec;\\r\\nif (!asn1_utctime_to_tm(&stm, s))\\r\\nreturn -2;\\r\\nif (!OPENSSL_gmtime(&t, &ttm))\\r\\nreturn -2;\\r\\nif (!OPENSSL_gmtime_diff(&day, &sec, &stm, &ttm))\\r\\nreturn -2;\\r\\nif (day > 0)\\r\\nreturn 1;\\r\\nif (day < 0)\\r\\nreturn -1;\\r\\nif (sec > 0)\\r\\nreturn 1;\\r\\nif (sec < 0)\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_aes_ofb_c", "target": 0, "func": "void AES_ofb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const AES_KEY *key,\\r\\nunsigned char *ivec, int *num)\\r\\n{\\r\\nCRYPTO_ofb128_encrypt(in, out, length, key, ivec, num,\\r\\n(block128_f) AES_encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_crl2p7_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i, badops = 0;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat;\\r\\nchar *infile, *outfile, *prog, *certfile;\\r\\nPKCS7 *p7 = NULL;\\r\\nPKCS7_SIGNED *p7s = NULL;\\r\\nX509_CRL *crl = NULL;\\r\\nSTACK_OF(OPENSSL_STRING) *certflst = NULL;\\r\\nSTACK_OF(X509_CRL) *crl_stack = NULL;\\r\\nSTACK_OF(X509) *cert_stack = NULL;\\r\\nint ret = 1, nocrl = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\ninfile = NULL;\\r\\noutfile = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-nocrl\") == 0) {\\r\\nnocrl = 1;\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-certfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!certflst)\\r\\ncertflst = sk_OPENSSL_STRING_new_null();\\r\\nif (!certflst)\\r\\ngoto end;\\r\\nif (!sk_OPENSSL_STRING_push(certflst, *(++argv))) {\\r\\nsk_OPENSSL_STRING_free(certflst);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile >outfile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -certfile arg certificates file of chain to a trusted CA\\n\");\\r\\nBIO_printf(bio_err, \" (can be used more than once)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -nocrl no crl to load, just certs from '-certfile'\\n\");\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!nocrl) {\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\ncrl = d2i_X509_CRL_bio(in, NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ncrl = PEM_read_bio_X509_CRL(in, NULL, NULL, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad input format specified for input crl\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (crl == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif ((p7 = PKCS7_new()) == NULL)\\r\\ngoto end;\\r\\nif ((p7s = PKCS7_SIGNED_new()) == NULL)\\r\\ngoto end;\\r\\np7->type = OBJ_nid2obj(NID_pkcs7_signed);\\r\\np7->d.sign = p7s;\\r\\np7s->contents->type = OBJ_nid2obj(NID_pkcs7_data);\\r\\nif (!ASN1_INTEGER_set(p7s->version, 1))\\r\\ngoto end;\\r\\nif ((crl_stack = sk_X509_CRL_new_null()) == NULL)\\r\\ngoto end;\\r\\np7s->crl = crl_stack;\\r\\nif (crl != NULL) {\\r\\nsk_X509_CRL_push(crl_stack, crl);\\r\\ncrl = NULL;\\r\\n}\\r\\nif ((cert_stack = sk_X509_new_null()) == NULL)\\r\\ngoto end;\\r\\np7s->cert = cert_stack;\\r\\nif (certflst)\\r\\nfor (i = 0; i < sk_OPENSSL_STRING_num(certflst); i++) {\\r\\ncertfile = sk_OPENSSL_STRING_value(certflst, i);\\r\\nif (add_certs_from_file(cert_stack, certfile) < 0) {\\r\\nBIO_printf(bio_err, \"error loading certificates\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nsk_OPENSSL_STRING_free(certflst);\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_PKCS7_bio(out, p7);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_PKCS7(out, p7);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write pkcs7 object\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (p7 != NULL)\\r\\nPKCS7_free(p7);\\r\\nif (crl != NULL)\\r\\nX509_CRL_free(crl);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cpt_err_c", "target": 0, "func": "void ERR_load_CRYPTO_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(CRYPTO_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, CRYPTO_str_functs);\\r\\nERR_load_strings(0, CRYPTO_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_info_c", "target": 0, "func": "X509_INFO *X509_INFO_new(void)\\r\\n{\\r\\nX509_INFO *ret = NULL;\\r\\nret = (X509_INFO *)OPENSSL_malloc(sizeof(X509_INFO));\\r\\nif (ret == NULL) {\\r\\nASN1err(ASN1_F_X509_INFO_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nret->enc_cipher.cipher = NULL;\\r\\nret->enc_len = 0;\\r\\nret->enc_data = NULL;\\r\\nret->references = 1;\\r\\nret->x509 = NULL;\\r\\nret->crl = NULL;\\r\\nret->x_pkey = NULL;\\r\\nreturn (ret);\\r\\n}\\r\\nvoid X509_INFO_free(X509_INFO *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&x->references, -1, CRYPTO_LOCK_X509_INFO);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_INFO\", x);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"X509_INFO_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (x->x509 != NULL)\\r\\nX509_free(x->x509);\\r\\nif (x->crl != NULL)\\r\\nX509_CRL_free(x->crl);\\r\\nif (x->x_pkey != NULL)\\r\\nX509_PKEY_free(x->x_pkey);\\r\\nif (x->enc_data != NULL)\\r\\nOPENSSL_free(x->enc_data);\\r\\nOPENSSL_free(x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_o_time_c", "target": 0, "func": "struct tm *OPENSSL_gmtime(const time_t *timer, struct tm *result)\\r\\n{\\r\\nstruct tm *ts = NULL;\\r\\n#if defined(OPENSSL_THREADS) && !defined(OPENSSL_SYS_WIN32) && !defined(OPENSSL_SYS_OS2) && (!defined(OPENSSL_SYS_VMS) || defined(gmtime_r)) && !defined(OPENSSL_SYS_MACOSX) && !defined(OPENSSL_SYS_SUNOS)\\r\\ngmtime_r(timer, result);\\r\\nts = result;\\r\\n#elif !defined(OPENSSL_SYS_VMS) || defined(VMS_GMTIME_OK)\\r\\nts = gmtime(timer);\\r\\nif (ts == NULL)\\r\\nreturn NULL;\\r\\nmemcpy(result, ts, sizeof(struct tm));\\r\\nts = result;\\r\\n#endif\\r\\n#if defined( OPENSSL_SYS_VMS) && !defined( VMS_GMTIME_OK)\\r\\nif (ts == NULL) {\\r\\nstatic $DESCRIPTOR(tabnam, \"LNM$DCL_LOGICAL\");\\r\\nstatic $DESCRIPTOR(lognam, \"SYS$TIMEZONE_DIFFERENTIAL\");\\r\\nchar logvalue[256];\\r\\nunsigned int reslen = 0;\\r\\nstruct {\\r\\nshort buflen;\\r\\nshort code;\\r\\nvoid *bufaddr;\\r\\nunsigned int *reslen;\\r\\n} itemlist[] = {\\r\\n{\\r\\n0, LNM$_STRING, 0, 0\\r\\n},\\r\\n{\\r\\n0, 0, 0, 0\\r\\n},\\r\\n};\\r\\nint status;\\r\\ntime_t t;\\r\\nitemlist[0].buflen = sizeof(logvalue);\\r\\nitemlist[0].bufaddr = logvalue;\\r\\nitemlist[0].reslen = &reslen;\\r\\nstatus = sys$trnlnm(0, &tabnam, &lognam, 0, itemlist);\\r\\nif (!(status & 1))\\r\\nreturn NULL;\\r\\nlogvalue[reslen] = '\\0';\\r\\nt = *timer;\\r\\n# if __CRTL_VER < 70000000 || defined _VMS_V6_SOURCE\\r\\nstatus = atoi(logvalue);\\r\\nt -= status;\\r\\n# endif\\r\\n{\\r\\nunsigned long unix_epoch[2] = { 1273708544, 8164711 };\\r\\nunsigned long deltatime[2];\\r\\nunsigned long systime[2];\\r\\nstruct vms_vectime {\\r\\nshort year, month, day, hour, minute, second, centi_second;\\r\\n} time_values;\\r\\nlong operation;\\r\\noperation = LIB$K_DELTA_SECONDS;\\r\\nstatus = lib$cvt_to_internal_time(&operation, &t, deltatime);\\r\\nstatus = lib$add_times(unix_epoch, deltatime, systime);\\r\\nstatus = sys$numtim(&time_values, systime);\\r\\nresult->tm_sec = time_values.second;\\r\\nresult->tm_min = time_values.minute;\\r\\nresult->tm_hour = time_values.hour;\\r\\nresult->tm_mday = time_values.day;\\r\\nresult->tm_mon = time_values.month - 1;\\r\\nresult->tm_year = time_values.year - 1900;\\r\\noperation = LIB$K_DAY_OF_WEEK;\\r\\nstatus = lib$cvt_from_internal_time(&operation,\\r\\n&result->tm_wday, systime);\\r\\nresult->tm_wday %= 7;\\r\\noperation = LIB$K_DAY_OF_YEAR;\\r\\nstatus = lib$cvt_from_internal_time(&operation,\\r\\n&result->tm_yday, systime);\\r\\nresult->tm_yday--;\\r\\nresult->tm_isdst = 0;\\r\\nts = result;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nreturn ts;\\r\\n}\\r\\nint OPENSSL_gmtime_adj(struct tm *tm, int off_day, long offset_sec)\\r\\n{\\r\\nint time_sec, time_year, time_month, time_day;\\r\\nlong time_jd;\\r\\nif (!julian_adj(tm, off_day, offset_sec, &time_jd, &time_sec))\\r\\nreturn 0;\\r\\njulian_to_date(time_jd, &time_year, &time_month, &time_day);\\r\\nif (time_year < 1900 || time_year > 9999)\\r\\nreturn 0;\\r\\ntm->tm_year = time_year - 1900;\\r\\ntm->tm_mon = time_month - 1;\\r\\ntm->tm_mday = time_day;\\r\\ntm->tm_hour = time_sec / 3600;\\r\\ntm->tm_min = (time_sec / 60) % 60;\\r\\ntm->tm_sec = time_sec % 60;\\r\\nreturn 1;\\r\\n}\\r\\nint OPENSSL_gmtime_diff(int *pday, int *psec,\\r\\nconst struct tm *from, const struct tm *to)\\r\\n{\\r\\nint from_sec, to_sec, diff_sec;\\r\\nlong from_jd, to_jd, diff_day;\\r\\nif (!julian_adj(from, 0, 0, &from_jd, &from_sec))\\r\\nreturn 0;\\r\\nif (!julian_adj(to, 0, 0, &to_jd, &to_sec))\\r\\nreturn 0;\\r\\ndiff_day = to_jd - from_jd;\\r\\ndiff_sec = to_sec - from_sec;\\r\\nif (diff_day > 0 && diff_sec < 0) {\\r\\ndiff_day--;\\r\\ndiff_sec += SECS_PER_DAY;\\r\\n}\\r\\nif (diff_day < 0 && diff_sec > 0) {\\r\\ndiff_day++;\\r\\ndiff_sec -= SECS_PER_DAY;\\r\\n}\\r\\nif (pday)\\r\\n*pday = (int)diff_day;\\r\\nif (psec)\\r\\n*psec = diff_sec;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int julian_adj(const struct tm *tm, int off_day, long offset_sec,\\r\\nlong *pday, int *psec)\\r\\n{\\r\\nint offset_hms, offset_day;\\r\\nlong time_jd;\\r\\nint time_year, time_month, time_day;\\r\\noffset_day = offset_sec / SECS_PER_DAY;\\r\\noffset_hms = offset_sec - (offset_day * SECS_PER_DAY);\\r\\noffset_day += off_day;\\r\\noffset_hms += tm->tm_hour * 3600 + tm->tm_min * 60 + tm->tm_sec;\\r\\nif (offset_hms >= SECS_PER_DAY) {\\r\\noffset_day++;\\r\\noffset_hms -= SECS_PER_DAY;\\r\\n} else if (offset_hms < 0) {\\r\\noffset_day--;\\r\\noffset_hms += SECS_PER_DAY;\\r\\n}\\r\\ntime_year = tm->tm_year + 1900;\\r\\ntime_month = tm->tm_mon + 1;\\r\\ntime_day = tm->tm_mday;\\r\\ntime_jd = date_to_julian(time_year, time_month, time_day);\\r\\ntime_jd += offset_day;\\r\\nif (time_jd < 0)\\r\\nreturn 0;\\r\\n*pday = time_jd;\\r\\n*psec = offset_hms;\\r\\nreturn 1;\\r\\n}\\r\\nstatic long date_to_julian(int y, int m, int d)\\r\\n{\\r\\nreturn (1461 * (y + 4800 + (m - 14) / 12)) / 4 +\\r\\n(367 * (m - 2 - 12 * ((m - 14) / 12))) / 12 -\\r\\n(3 * ((y + 4900 + (m - 14) / 12) / 100)) / 4 + d - 32075;\\r\\n}\\r\\nstatic void julian_to_date(long jd, int *y, int *m, int *d)\\r\\n{\\r\\nlong L = jd + 68569;\\r\\nlong n = (4 * L) / 146097;\\r\\nlong i, j;\\r\\nL = L - (146097 * n + 3) / 4;\\r\\ni = (4000 * (L + 1)) / 1461001;\\r\\nL = L - (1461 * i) / 4 + 31;\\r\\nj = (80 * L) / 2447;\\r\\n*d = L - (2447 * j) / 80;\\r\\nL = j / 11;\\r\\n*m = j + 2 - (12 * L);\\r\\n*y = 100 * (n - 49) + i + L;\\r\\n}\\r\\nint main(int argc, char **argv)\\r\\n{\\r\\nlong offset;\\r\\nfor (offset = 0; offset < 1000000; offset++) {\\r\\ncheck_time(offset);\\r\\ncheck_time(-offset);\\r\\ncheck_time(offset * 1000);\\r\\ncheck_time(-offset * 1000);\\r\\n}\\r\\n}\\r\\nint check_time(long offset)\\r\\n{\\r\\nstruct tm tm1, tm2, o1;\\r\\nint off_day, off_sec;\\r\\nlong toffset;\\r\\ntime_t t1, t2;\\r\\ntime(&t1);\\r\\nt2 = t1 + offset;\\r\\nOPENSSL_gmtime(&t2, &tm2);\\r\\nOPENSSL_gmtime(&t1, &tm1);\\r\\no1 = tm1;\\r\\nOPENSSL_gmtime_adj(&tm1, 0, offset);\\r\\nif ((tm1.tm_year != tm2.tm_year) ||\\r\\n(tm1.tm_mon != tm2.tm_mon) ||\\r\\n(tm1.tm_mday != tm2.tm_mday) ||\\r\\n(tm1.tm_hour != tm2.tm_hour) ||\\r\\n(tm1.tm_min != tm2.tm_min) || (tm1.tm_sec != tm2.tm_sec)) {\\r\\nfprintf(stderr, \"TIME ERROR!!\\n\");\\r\\nfprintf(stderr, \"Time1: %d/%d/%d, %d:%02d:%02d\\n\",\\r\\ntm2.tm_mday, tm2.tm_mon + 1, tm2.tm_year + 1900,\\r\\ntm2.tm_hour, tm2.tm_min, tm2.tm_sec);\\r\\nfprintf(stderr, \"Time2: %d/%d/%d, %d:%02d:%02d\\n\",\\r\\ntm1.tm_mday, tm1.tm_mon + 1, tm1.tm_year + 1900,\\r\\ntm1.tm_hour, tm1.tm_min, tm1.tm_sec);\\r\\nreturn 0;\\r\\n}\\r\\nOPENSSL_gmtime_diff(&o1, &tm1, &off_day, &off_sec);\\r\\ntoffset = (long)off_day *SECS_PER_DAY + off_sec;\\r\\nif (offset != toffset) {\\r\\nfprintf(stderr, \"TIME OFFSET ERROR!!\\n\");\\r\\nfprintf(stderr, \"Expected %ld, Got %ld (%d:%d)\\n\",\\r\\noffset, toffset, off_day, off_sec);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pmeth_gn_c", "target": 0, "func": "int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->paramgen) {\\r\\nEVPerr(EVP_F_EVP_PKEY_PARAMGEN_INIT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nctx->operation = EVP_PKEY_OP_PARAMGEN;\\r\\nif (!ctx->pmeth->paramgen_init)\\r\\nreturn 1;\\r\\nret = ctx->pmeth->paramgen_init(ctx);\\r\\nif (ret <= 0)\\r\\nctx->operation = EVP_PKEY_OP_UNDEFINED;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->paramgen) {\\r\\nEVPerr(EVP_F_EVP_PKEY_PARAMGEN,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nif (ctx->operation != EVP_PKEY_OP_PARAMGEN) {\\r\\nEVPerr(EVP_F_EVP_PKEY_PARAMGEN, EVP_R_OPERATON_NOT_INITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (!ppkey)\\r\\nreturn -1;\\r\\nif (!*ppkey)\\r\\n*ppkey = EVP_PKEY_new();\\r\\nret = ctx->pmeth->paramgen(ctx, *ppkey);\\r\\nif (ret <= 0) {\\r\\nEVP_PKEY_free(*ppkey);\\r\\n*ppkey = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->keygen) {\\r\\nEVPerr(EVP_F_EVP_PKEY_KEYGEN_INIT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nctx->operation = EVP_PKEY_OP_KEYGEN;\\r\\nif (!ctx->pmeth->keygen_init)\\r\\nreturn 1;\\r\\nret = ctx->pmeth->keygen_init(ctx);\\r\\nif (ret <= 0)\\r\\nctx->operation = EVP_PKEY_OP_UNDEFINED;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->keygen) {\\r\\nEVPerr(EVP_F_EVP_PKEY_KEYGEN,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nif (ctx->operation != EVP_PKEY_OP_KEYGEN) {\\r\\nEVPerr(EVP_F_EVP_PKEY_KEYGEN, EVP_R_OPERATON_NOT_INITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (!ppkey)\\r\\nreturn -1;\\r\\nif (!*ppkey)\\r\\n*ppkey = EVP_PKEY_new();\\r\\nret = ctx->pmeth->keygen(ctx, *ppkey);\\r\\nif (ret <= 0) {\\r\\nEVP_PKEY_free(*ppkey);\\r\\n*ppkey = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb)\\r\\n{\\r\\nctx->pkey_gencb = cb;\\r\\n}\\r\\nEVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nreturn ctx->pkey_gencb;\\r\\n}\\r\\nstatic int trans_cb(int a, int b, BN_GENCB *gcb)\\r\\n{\\r\\nEVP_PKEY_CTX *ctx = gcb->arg;\\r\\nctx->keygen_info[0] = a;\\r\\nctx->keygen_info[1] = b;\\r\\nreturn ctx->pkey_gencb(ctx);\\r\\n}\\r\\nvoid evp_pkey_set_cb_translate(BN_GENCB *cb, EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nBN_GENCB_set(cb, trans_cb, ctx)\\r\\n}\\r\\nint EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx)\\r\\n{\\r\\nif (idx == -1)\\r\\nreturn ctx->keygen_info_count;\\r\\nif (idx < 0 || idx > ctx->keygen_info_count)\\r\\nreturn 0;\\r\\nreturn ctx->keygen_info[idx];\\r\\n}\\r\\nEVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,\\r\\nconst unsigned char *key, int keylen)\\r\\n{\\r\\nEVP_PKEY_CTX *mac_ctx = NULL;\\r\\nEVP_PKEY *mac_key = NULL;\\r\\nmac_ctx = EVP_PKEY_CTX_new_id(type, e);\\r\\nif (!mac_ctx)\\r\\nreturn NULL;\\r\\nif (EVP_PKEY_keygen_init(mac_ctx) <= 0)\\r\\ngoto merr;\\r\\nif (EVP_PKEY_CTX_ctrl(mac_ctx, -1, EVP_PKEY_OP_KEYGEN,\\r\\nEVP_PKEY_CTRL_SET_MAC_KEY,\\r\\nkeylen, (void *)key) <= 0)\\r\\ngoto merr;\\r\\nif (EVP_PKEY_keygen(mac_ctx, &mac_key) <= 0)\\r\\ngoto merr;\\r\\nmerr:\\r\\nif (mac_ctx)\\r\\nEVP_PKEY_CTX_free(mac_ctx);\\r\\nreturn mac_key;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_key_c", "target": 1, "func": "int DH_generate_key(DH *dh)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(dh->meth->flags & DH_FLAG_FIPS_METHOD)\\r\\n&& !(dh->flags & DH_FLAG_NON_FIPS_ALLOW)) {\\r\\nDHerr(DH_F_DH_GENERATE_KEY, DH_R_NON_FIPS_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nreturn dh->meth->generate_key(dh);\\r\\n}\\r\\nint DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(dh->meth->flags & DH_FLAG_FIPS_METHOD)\\r\\n&& !(dh->flags & DH_FLAG_NON_FIPS_ALLOW)) {\\r\\nDHerr(DH_F_DH_COMPUTE_KEY, DH_R_NON_FIPS_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nreturn dh->meth->compute_key(key, pub_key, dh);\\r\\n}\\r\\nint DH_compute_key_padded(unsigned char *key, const BIGNUM *pub_key, DH *dh)\\r\\n{\\r\\nint rv, pad;\\r\\nrv = dh->meth->compute_key(key, pub_key, dh);\\r\\nif (rv <= 0)\\r\\nreturn rv;\\r\\npad = BN_num_bytes(dh->p) - rv;\\r\\nif (pad > 0) {\\r\\nmemmove(key + pad, key, rv);\\r\\nmemset(key, 0, pad);\\r\\n}\\r\\nreturn rv + pad;\\r\\n}\\r\\nconst DH_METHOD *DH_OpenSSL(void)\\r\\n{\\r\\nreturn &dh_ossl;\\r\\n}\\r\\nstatic int generate_key(DH *dh)\\r\\n{\\r\\nint ok = 0;\\r\\nint generate_new_key = 0;\\r\\nunsigned l;\\r\\nBN_CTX *ctx;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nBIGNUM *pub_key = NULL, *priv_key = NULL;\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\nif (dh->priv_key == NULL) {\\r\\npriv_key = BN_new();\\r\\nif (priv_key == NULL)\\r\\ngoto err;\\r\\ngenerate_new_key = 1;\\r\\n} else\\r\\npriv_key = dh->priv_key;\\r\\nif (dh->pub_key == NULL) {\\r\\npub_key = BN_new();\\r\\nif (pub_key == NULL)\\r\\ngoto err;\\r\\n} else\\r\\npub_key = dh->pub_key;\\r\\nif (dh->flags & DH_FLAG_CACHE_MONT_P) {\\r\\nmont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\\r\\nCRYPTO_LOCK_DH, dh->p, ctx);\\r\\nif (!mont)\\r\\ngoto err;\\r\\n}\\r\\nif (generate_new_key) {\\r\\nif (dh->q) {\\r\\ndo {\\r\\nif (!BN_rand_range(priv_key, dh->q))\\r\\ngoto err;\\r\\n}\\r\\nwhile (BN_is_zero(priv_key) || BN_is_one(priv_key));\\r\\n} else {\\r\\nl = dh->length ? dh->length : BN_num_bits(dh->p) - 1;\\r\\nif (!BN_rand(priv_key, l, 0, 0))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n{\\r\\nBIGNUM local_prk;\\r\\nBIGNUM *prk;\\r\\nif ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) == 0) {\\r\\nBN_init(&local_prk);\\r\\nprk = &local_prk;\\r\\nBN_with_flags(prk, priv_key, BN_FLG_CONSTTIME);\\r\\n} else\\r\\nprk = priv_key;\\r\\nif (!dh->meth->bn_mod_exp(dh, pub_key, dh->g, prk, dh->p, ctx, mont))\\r\\ngoto err;\\r\\n}\\r\\ndh->pub_key = pub_key;\\r\\ndh->priv_key = priv_key;\\r\\nok = 1;\\r\\nerr:\\r\\nif (ok != 1)\\r\\nDHerr(DH_F_GENERATE_KEY, ERR_R_BN_LIB);\\r\\nif ((pub_key != NULL) && (dh->pub_key == NULL))\\r\\nBN_free(pub_key);\\r\\nif ((priv_key != NULL) && (dh->priv_key == NULL))\\r\\nBN_free(priv_key);\\r\\nBN_CTX_free(ctx);\\r\\nreturn (ok);\\r\\n}\\r\\nstatic int compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\\r\\n{\\r\\nBN_CTX *ctx = NULL;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nBIGNUM *tmp;\\r\\nint ret = -1;\\r\\nint check_result;\\r\\nif (BN_num_bits(dh->p) > OPENSSL_DH_MAX_MODULUS_BITS) {\\r\\nDHerr(DH_F_COMPUTE_KEY, DH_R_MODULUS_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\nBN_CTX_start(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nif (dh->priv_key == NULL) {\\r\\nDHerr(DH_F_COMPUTE_KEY, DH_R_NO_PRIVATE_VALUE);\\r\\ngoto err;\\r\\n}\\r\\nif (dh->flags & DH_FLAG_CACHE_MONT_P) {\\r\\nmont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\\r\\nCRYPTO_LOCK_DH, dh->p, ctx);\\r\\nif ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) == 0) {\\r\\nBN_set_flags(dh->priv_key, BN_FLG_CONSTTIME);\\r\\n}\\r\\nif (!mont)\\r\\ngoto err;\\r\\n}\\r\\nif (!DH_check_pub_key(dh, pub_key, &check_result) || check_result) {\\r\\nDHerr(DH_F_COMPUTE_KEY, DH_R_INVALID_PUBKEY);\\r\\ngoto err;\\r\\n}\\r\\nif (!dh->\\r\\nmeth->bn_mod_exp(dh, tmp, pub_key, dh->priv_key, dh->p, ctx, mont)) {\\r\\nDHerr(DH_F_COMPUTE_KEY, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_bn2bin(tmp, key);\\r\\nerr:\\r\\nif (ctx != NULL) {\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int dh_bn_mod_exp(const DH *dh, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nif (a->top == 1 && ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) != 0)) {\\r\\nBN_ULONG A = a->d[0];\\r\\nreturn BN_mod_exp_mont_word(r, A, p, m, ctx, m_ctx);\\r\\n} else\\r\\nreturn BN_mod_exp_mont(r, a, p, m, ctx, m_ctx);\\r\\n}\\r\\nstatic int dh_init(DH *dh)\\r\\n{\\r\\ndh->flags |= DH_FLAG_CACHE_MONT_P;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int dh_finish(DH *dh)\\r\\n{\\r\\nif (dh->method_mont_p)\\r\\nBN_MONT_CTX_free(dh->method_mont_p);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_seed_ecb_c", "target": 0, "func": "void SEED_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst SEED_KEY_SCHEDULE *ks, int enc)\\r\\n{\\r\\nif (enc)\\r\\nSEED_encrypt(in, out, ks);\\r\\nelse\\r\\nSEED_decrypt(in, out, ks);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_qud_cksm_c", "target": 0, "func": "DES_LONG DES_quad_cksum(const unsigned char *input, DES_cblock output[],\\r\\nlong length, int out_count, DES_cblock *seed)\\r\\n{\\r\\nDES_LONG z0, z1, t0, t1;\\r\\nint i;\\r\\nlong l;\\r\\nconst unsigned char *cp;\\r\\n#ifdef _CRAY\\r\\nstruct lp_st {\\r\\nint a:32;\\r\\nint b:32;\\r\\n} *lp;\\r\\n#else\\r\\nDES_LONG *lp;\\r\\n#endif\\r\\nif (out_count < 1)\\r\\nout_count = 1;\\r\\n#ifdef _CRAY\\r\\nlp = (struct lp_st *)&(output[0])[0];\\r\\n#else\\r\\nlp = (DES_LONG *)&(output[0])[0];\\r\\n#endif\\r\\nz0 = Q_B0((*seed)[0]) | Q_B1((*seed)[1]) | Q_B2((*seed)[2]) |\\r\\nQ_B3((*seed)[3]);\\r\\nz1 = Q_B0((*seed)[4]) | Q_B1((*seed)[5]) | Q_B2((*seed)[6]) |\\r\\nQ_B3((*seed)[7]);\\r\\nfor (i = 0; ((i < 4) && (i < out_count)); i++) {\\r\\ncp = input;\\r\\nl = length;\\r\\nwhile (l > 0) {\\r\\nif (l > 1) {\\r\\nt0 = (DES_LONG)(*(cp++));\\r\\nt0 |= (DES_LONG)Q_B1(*(cp++));\\r\\nl--;\\r\\n} else\\r\\nt0 = (DES_LONG)(*(cp++));\\r\\nl--;\\r\\nt0 += z0;\\r\\nt0 &= 0xffffffffL;\\r\\nt1 = z1;\\r\\nz0 = ((((t0 * t0) & 0xffffffffL) + ((t1 * t1) & 0xffffffffL))\\r\\n& 0xffffffffL) % 0x7fffffffL;\\r\\nz1 = ((t0 * ((t1 + NOISE) & 0xffffffffL)) & 0xffffffffL) %\\r\\n0x7fffffffL;\\r\\n}\\r\\nif (lp != NULL) {\\r\\n#ifdef _CRAY\\r\\n(*lp).a = z0;\\r\\n(*lp).b = z1;\\r\\nlp++;\\r\\n#else\\r\\n*lp++ = z0;\\r\\n*lp++ = z1;\\r\\n#endif\\r\\n}\\r\\n}\\r\\nreturn (z0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cfb128_c", "target": 0, "func": "void CRYPTO_cfb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16], int *num,\\r\\nint enc, block128_f block)\\r\\n{\\r\\nunsigned int n;\\r\\nsize_t l = 0;\\r\\nassert(in && out && key && ivec && num);\\r\\nn = *num;\\r\\nif (enc) {\\r\\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nif (16 % sizeof(size_t) == 0) {\\r\\ndo {\\r\\nwhile (n && len) {\\r\\n*(out++) = ivec[n] ^= *(in++);\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\n# if defined(STRICT_ALIGNMENT)\\r\\nif (((size_t)in | (size_t)out | (size_t)ivec) %\\r\\nsizeof(size_t) != 0)\\r\\nbreak;\\r\\n# endif\\r\\nwhile (len >= 16) {\\r\\n(*block) (ivec, ivec, key);\\r\\nfor (; n < 16; n += sizeof(size_t)) {\\r\\n*(size_t *)(out + n) =\\r\\n*(size_t *)(ivec + n) ^= *(size_t *)(in + n);\\r\\n}\\r\\nlen -= 16;\\r\\nout += 16;\\r\\nin += 16;\\r\\nn = 0;\\r\\n}\\r\\nif (len) {\\r\\n(*block) (ivec, ivec, key);\\r\\nwhile (len--) {\\r\\nout[n] = ivec[n] ^= in[n];\\r\\n++n;\\r\\n}\\r\\n}\\r\\n*num = n;\\r\\nreturn;\\r\\n} while (0);\\r\\n}\\r\\n#endif\\r\\nwhile (l < len) {\\r\\nif (n == 0) {\\r\\n(*block) (ivec, ivec, key);\\r\\n}\\r\\nout[l] = ivec[n] ^= in[l];\\r\\n++l;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\n*num = n;\\r\\n} else {\\r\\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nif (16 % sizeof(size_t) == 0) {\\r\\ndo {\\r\\nwhile (n && len) {\\r\\nunsigned char c;\\r\\n*(out++) = ivec[n] ^ (c = *(in++));\\r\\nivec[n] = c;\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\n# if defined(STRICT_ALIGNMENT)\\r\\nif (((size_t)in | (size_t)out | (size_t)ivec) %\\r\\nsizeof(size_t) != 0)\\r\\nbreak;\\r\\n# endif\\r\\nwhile (len >= 16) {\\r\\n(*block) (ivec, ivec, key);\\r\\nfor (; n < 16; n += sizeof(size_t)) {\\r\\nsize_t t = *(size_t *)(in + n);\\r\\n*(size_t *)(out + n) = *(size_t *)(ivec + n) ^ t;\\r\\n*(size_t *)(ivec + n) = t;\\r\\n}\\r\\nlen -= 16;\\r\\nout += 16;\\r\\nin += 16;\\r\\nn = 0;\\r\\n}\\r\\nif (len) {\\r\\n(*block) (ivec, ivec, key);\\r\\nwhile (len--) {\\r\\nunsigned char c;\\r\\nout[n] = ivec[n] ^ (c = in[n]);\\r\\nivec[n] = c;\\r\\n++n;\\r\\n}\\r\\n}\\r\\n*num = n;\\r\\nreturn;\\r\\n} while (0);\\r\\n}\\r\\n#endif\\r\\nwhile (l < len) {\\r\\nunsigned char c;\\r\\nif (n == 0) {\\r\\n(*block) (ivec, ivec, key);\\r\\n}\\r\\nout[l] = ivec[n] ^ (c = in[l]);\\r\\nivec[n] = c;\\r\\n++l;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\n*num = n;\\r\\n}\\r\\n}\\r\\nstatic void cfbr_encrypt_block(const unsigned char *in, unsigned char *out,\\r\\nint nbits, const void *key,\\r\\nunsigned char ivec[16], int enc,\\r\\nblock128_f block)\\r\\n{\\r\\nint n, rem, num;\\r\\nunsigned char ovec[16 * 2 + 1];\\r\\nif (nbits <= 0 || nbits > 128)\\r\\nreturn;\\r\\nmemcpy(ovec, ivec, 16);\\r\\n(*block) (ivec, ivec, key);\\r\\nnum = (nbits + 7) / 8;\\r\\nif (enc)\\r\\nfor (n = 0; n < num; ++n)\\r\\nout[n] = (ovec[16 + n] = in[n] ^ ivec[n]);\\r\\nelse\\r\\nfor (n = 0; n < num; ++n)\\r\\nout[n] = (ovec[16 + n] = in[n]) ^ ivec[n];\\r\\nrem = nbits % 8;\\r\\nnum = nbits / 8;\\r\\nif (rem == 0)\\r\\nmemcpy(ivec, ovec + num, 16);\\r\\nelse\\r\\nfor (n = 0; n < 16; ++n)\\r\\nivec[n] = ovec[n + num] << rem | ovec[n + num + 1] >> (8 - rem);\\r\\n}\\r\\nvoid CRYPTO_cfb128_1_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t bits, const void *key,\\r\\nunsigned char ivec[16], int *num,\\r\\nint enc, block128_f block)\\r\\n{\\r\\nsize_t n;\\r\\nunsigned char c[1], d[1];\\r\\nassert(in && out && key && ivec && num);\\r\\nassert(*num == 0);\\r\\nfor (n = 0; n < bits; ++n) {\\r\\nc[0] = (in[n / 8] & (1 << (7 - n % 8))) ? 0x80 : 0;\\r\\ncfbr_encrypt_block(c, d, 1, key, ivec, enc, block);\\r\\nout[n / 8] = (out[n / 8] & ~(1 << (unsigned int)(7 - n % 8))) |\\r\\n((d[0] & 0x80) >> (unsigned int)(n % 8));\\r\\n}\\r\\n}\\r\\nvoid CRYPTO_cfb128_8_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const void *key,\\r\\nunsigned char ivec[16], int *num,\\r\\nint enc, block128_f block)\\r\\n{\\r\\nsize_t n;\\r\\nassert(in && out && key && ivec && num);\\r\\nassert(*num == 0);\\r\\nfor (n = 0; n < length; ++n)\\r\\ncfbr_encrypt_block(&in[n], &out[n], 8, key, ivec, enc, block);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_trs_c", "target": 0, "func": "static int tr_cmp(const X509_TRUST *const *a, const X509_TRUST *const *b)\\r\\n{\\r\\nreturn (*a)->trust - (*b)->trust;\\r\\n}\\r\\nint X509_check_trust(X509 *x, int id, int flags)\\r\\n{\\r\\nX509_TRUST *pt;\\r\\nint idx;\\r\\nif (id == -1)\\r\\nreturn 1;\\r\\nif (id == 0) {\\r\\nint rv;\\r\\nrv = obj_trust(NID_anyExtendedKeyUsage, x, 0);\\r\\nif (rv != X509_TRUST_UNTRUSTED)\\r\\nreturn rv;\\r\\nreturn trust_compat(NULL, x, 0);\\r\\n}\\r\\nidx = X509_TRUST_get_by_id(id);\\r\\nif (idx == -1)\\r\\nreturn default_trust(id, x, flags);\\r\\npt = X509_TRUST_get0(idx);\\r\\nreturn pt->check_trust(pt, x, flags);\\r\\n}\\r\\nint X509_TRUST_get_count(void)\\r\\n{\\r\\nif (!trtable)\\r\\nreturn X509_TRUST_COUNT;\\r\\nreturn sk_X509_TRUST_num(trtable) + X509_TRUST_COUNT;\\r\\n}\\r\\nX509_TRUST *X509_TRUST_get0(int idx)\\r\\n{\\r\\nif (idx < 0)\\r\\nreturn NULL;\\r\\nif (idx < (int)X509_TRUST_COUNT)\\r\\nreturn trstandard + idx;\\r\\nreturn sk_X509_TRUST_value(trtable, idx - X509_TRUST_COUNT);\\r\\n}\\r\\nint X509_TRUST_get_by_id(int id)\\r\\n{\\r\\nX509_TRUST tmp;\\r\\nint idx;\\r\\nif ((id >= X509_TRUST_MIN) && (id <= X509_TRUST_MAX))\\r\\nreturn id - X509_TRUST_MIN;\\r\\ntmp.trust = id;\\r\\nif (!trtable)\\r\\nreturn -1;\\r\\nidx = sk_X509_TRUST_find(trtable, &tmp);\\r\\nif (idx == -1)\\r\\nreturn -1;\\r\\nreturn idx + X509_TRUST_COUNT;\\r\\n}\\r\\nint X509_TRUST_set(int *t, int trust)\\r\\n{\\r\\nif (X509_TRUST_get_by_id(trust) == -1) {\\r\\nX509err(X509_F_X509_TRUST_SET, X509_R_INVALID_TRUST);\\r\\nreturn 0;\\r\\n}\\r\\n*t = trust;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_TRUST_add(int id, int flags, int (*ck) (X509_TRUST *, X509 *, int),\\r\\nchar *name, int arg1, void *arg2)\\r\\n{\\r\\nint idx;\\r\\nX509_TRUST *trtmp;\\r\\nflags &= ~X509_TRUST_DYNAMIC;\\r\\nflags |= X509_TRUST_DYNAMIC_NAME;\\r\\nidx = X509_TRUST_get_by_id(id);\\r\\nif (idx == -1) {\\r\\nif (!(trtmp = OPENSSL_malloc(sizeof(X509_TRUST)))) {\\r\\nX509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ntrtmp->flags = X509_TRUST_DYNAMIC;\\r\\n} else\\r\\ntrtmp = X509_TRUST_get0(idx);\\r\\nif (trtmp->flags & X509_TRUST_DYNAMIC_NAME)\\r\\nOPENSSL_free(trtmp->name);\\r\\nif (!(trtmp->name = BUF_strdup(name))) {\\r\\nX509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ntrtmp->flags &= X509_TRUST_DYNAMIC;\\r\\ntrtmp->flags |= flags;\\r\\ntrtmp->trust = id;\\r\\ntrtmp->check_trust = ck;\\r\\ntrtmp->arg1 = arg1;\\r\\ntrtmp->arg2 = arg2;\\r\\nif (idx == -1) {\\r\\nif (!trtable && !(trtable = sk_X509_TRUST_new(tr_cmp))) {\\r\\nX509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_X509_TRUST_push(trtable, trtmp)) {\\r\\nX509err(X509_F_X509_TRUST_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void trtable_free(X509_TRUST *p)\\r\\n{\\r\\nif (!p)\\r\\nreturn;\\r\\nif (p->flags & X509_TRUST_DYNAMIC) {\\r\\nif (p->flags & X509_TRUST_DYNAMIC_NAME)\\r\\nOPENSSL_free(p->name);\\r\\nOPENSSL_free(p);\\r\\n}\\r\\n}\\r\\nvoid X509_TRUST_cleanup(void)\\r\\n{\\r\\nunsigned int i;\\r\\nfor (i = 0; i < X509_TRUST_COUNT; i++)\\r\\ntrtable_free(trstandard + i);\\r\\nsk_X509_TRUST_pop_free(trtable, trtable_free);\\r\\ntrtable = NULL;\\r\\n}\\r\\nint X509_TRUST_get_flags(X509_TRUST *xp)\\r\\n{\\r\\nreturn xp->flags;\\r\\n}\\r\\nchar *X509_TRUST_get0_name(X509_TRUST *xp)\\r\\n{\\r\\nreturn xp->name;\\r\\n}\\r\\nint X509_TRUST_get_trust(X509_TRUST *xp)\\r\\n{\\r\\nreturn xp->trust;\\r\\n}\\r\\nstatic int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)\\r\\n{\\r\\nif (x->aux && (x->aux->trust || x->aux->reject))\\r\\nreturn obj_trust(trust->arg1, x, flags);\\r\\nreturn trust_compat(trust, x, flags);\\r\\n}\\r\\nstatic int trust_1oid(X509_TRUST *trust, X509 *x, int flags)\\r\\n{\\r\\nif (x->aux)\\r\\nreturn obj_trust(trust->arg1, x, flags);\\r\\nreturn X509_TRUST_UNTRUSTED;\\r\\n}\\r\\nstatic int trust_compat(X509_TRUST *trust, X509 *x, int flags)\\r\\n{\\r\\nX509_check_purpose(x, -1, 0);\\r\\nif (x->ex_flags & EXFLAG_SS)\\r\\nreturn X509_TRUST_TRUSTED;\\r\\nelse\\r\\nreturn X509_TRUST_UNTRUSTED;\\r\\n}\\r\\nstatic int obj_trust(int id, X509 *x, int flags)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nint i;\\r\\nX509_CERT_AUX *ax;\\r\\nax = x->aux;\\r\\nif (!ax)\\r\\nreturn X509_TRUST_UNTRUSTED;\\r\\nif (ax->reject) {\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(ax->reject); i++) {\\r\\nobj = sk_ASN1_OBJECT_value(ax->reject, i);\\r\\nif (OBJ_obj2nid(obj) == id)\\r\\nreturn X509_TRUST_REJECTED;\\r\\n}\\r\\n}\\r\\nif (ax->trust) {\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(ax->trust); i++) {\\r\\nobj = sk_ASN1_OBJECT_value(ax->trust, i);\\r\\nif (OBJ_obj2nid(obj) == id)\\r\\nreturn X509_TRUST_TRUSTED;\\r\\n}\\r\\n}\\r\\nreturn X509_TRUST_UNTRUSTED;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_aes_x86core_c", "target": 0, "func": "static void prefetch256(const void *table)\\r\\n{\\r\\nvolatile unsigned long *t=(void *)table,ret;\\r\\nunsigned long sum;\\r\\nint i;\\r\\nfor (sum=0,i=0;i<256/sizeof(t[0]);i+=32/sizeof(t[0])) sum ^= t[i];\\r\\nret = sum;\\r\\n}\\r\\nint AES_set_encrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key)\\r\\n{\\r\\nu32 *rk;\\r\\nint i = 0;\\r\\nu32 temp;\\r\\nif (!userKey || !key)\\r\\nreturn -1;\\r\\nif (bits != 128 && bits != 192 && bits != 256)\\r\\nreturn -2;\\r\\nrk = key->rd_key;\\r\\nif (bits==128)\\r\\nkey->rounds = 10;\\r\\nelse if (bits==192)\\r\\nkey->rounds = 12;\\r\\nelse\\r\\nkey->rounds = 14;\\r\\nrk[0] = GETU32(userKey );\\r\\nrk[1] = GETU32(userKey + 4);\\r\\nrk[2] = GETU32(userKey + 8);\\r\\nrk[3] = GETU32(userKey + 12);\\r\\nif (bits == 128) {\\r\\nwhile (1) {\\r\\ntemp = rk[3];\\r\\nrk[4] = rk[0] ^\\r\\n(Te4[(temp >> 8) & 0xff] ) ^\\r\\n(Te4[(temp >> 16) & 0xff] << 8) ^\\r\\n(Te4[(temp >> 24) ] << 16) ^\\r\\n(Te4[(temp ) & 0xff] << 24) ^\\r\\nrcon[i];\\r\\nrk[5] = rk[1] ^ rk[4];\\r\\nrk[6] = rk[2] ^ rk[5];\\r\\nrk[7] = rk[3] ^ rk[6];\\r\\nif (++i == 10) {\\r\\nreturn 0;\\r\\n}\\r\\nrk += 4;\\r\\n}\\r\\n}\\r\\nrk[4] = GETU32(userKey + 16);\\r\\nrk[5] = GETU32(userKey + 20);\\r\\nif (bits == 192) {\\r\\nwhile (1) {\\r\\ntemp = rk[ 5];\\r\\nrk[ 6] = rk[ 0] ^\\r\\n(Te4[(temp >> 8) & 0xff] ) ^\\r\\n(Te4[(temp >> 16) & 0xff] << 8) ^\\r\\n(Te4[(temp >> 24) ] << 16) ^\\r\\n(Te4[(temp ) & 0xff] << 24) ^\\r\\nrcon[i];\\r\\nrk[ 7] = rk[ 1] ^ rk[ 6];\\r\\nrk[ 8] = rk[ 2] ^ rk[ 7];\\r\\nrk[ 9] = rk[ 3] ^ rk[ 8];\\r\\nif (++i == 8) {\\r\\nreturn 0;\\r\\n}\\r\\nrk[10] = rk[ 4] ^ rk[ 9];\\r\\nrk[11] = rk[ 5] ^ rk[10];\\r\\nrk += 6;\\r\\n}\\r\\n}\\r\\nrk[6] = GETU32(userKey + 24);\\r\\nrk[7] = GETU32(userKey + 28);\\r\\nif (bits == 256) {\\r\\nwhile (1) {\\r\\ntemp = rk[ 7];\\r\\nrk[ 8] = rk[ 0] ^\\r\\n(Te4[(temp >> 8) & 0xff] ) ^\\r\\n(Te4[(temp >> 16) & 0xff] << 8) ^\\r\\n(Te4[(temp >> 24) ] << 16) ^\\r\\n(Te4[(temp ) & 0xff] << 24) ^\\r\\nrcon[i];\\r\\nrk[ 9] = rk[ 1] ^ rk[ 8];\\r\\nrk[10] = rk[ 2] ^ rk[ 9];\\r\\nrk[11] = rk[ 3] ^ rk[10];\\r\\nif (++i == 7) {\\r\\nreturn 0;\\r\\n}\\r\\ntemp = rk[11];\\r\\nrk[12] = rk[ 4] ^\\r\\n(Te4[(temp ) & 0xff] ) ^\\r\\n(Te4[(temp >> 8) & 0xff] << 8) ^\\r\\n(Te4[(temp >> 16) & 0xff] << 16) ^\\r\\n(Te4[(temp >> 24) ] << 24);\\r\\nrk[13] = rk[ 5] ^ rk[12];\\r\\nrk[14] = rk[ 6] ^ rk[13];\\r\\nrk[15] = rk[ 7] ^ rk[14];\\r\\nrk += 8;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint AES_set_decrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key)\\r\\n{\\r\\nu32 *rk;\\r\\nint i, j, status;\\r\\nu32 temp;\\r\\nstatus = AES_set_encrypt_key(userKey, bits, key);\\r\\nif (status < 0)\\r\\nreturn status;\\r\\nrk = key->rd_key;\\r\\nfor (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\\r\\ntemp = rk[i ]; rk[i ] = rk[j ]; rk[j ] = temp;\\r\\ntemp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\\r\\ntemp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\\r\\ntemp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\\r\\n}\\r\\nfor (i = 1; i < (key->rounds); i++) {\\r\\nrk += 4;\\r\\n#if 1\\r\\nfor (j = 0; j < 4; j++) {\\r\\nu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\\r\\ntp1 = rk[j];\\r\\nm = tp1 & 0x80808080;\\r\\ntp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\nm = tp2 & 0x80808080;\\r\\ntp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\nm = tp4 & 0x80808080;\\r\\ntp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\ntp9 = tp8 ^ tp1;\\r\\ntpb = tp9 ^ tp2;\\r\\ntpd = tp9 ^ tp4;\\r\\ntpe = tp8 ^ tp4 ^ tp2;\\r\\n#if defined(ROTATE)\\r\\nrk[j] = tpe ^ ROTATE(tpd,16) ^\\r\\nROTATE(tp9,8) ^ ROTATE(tpb,24);\\r\\n#else\\r\\nrk[j] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\\r\\n(tp9 >> 24) ^ (tp9 << 8) ^\\r\\n(tpb >> 8) ^ (tpb << 24);\\r\\n#endif\\r\\n}\\r\\n#else\\r\\nrk[0] =\\r\\nTd0[Te2[(rk[0] ) & 0xff] & 0xff] ^\\r\\nTd1[Te2[(rk[0] >> 8) & 0xff] & 0xff] ^\\r\\nTd2[Te2[(rk[0] >> 16) & 0xff] & 0xff] ^\\r\\nTd3[Te2[(rk[0] >> 24) ] & 0xff];\\r\\nrk[1] =\\r\\nTd0[Te2[(rk[1] ) & 0xff] & 0xff] ^\\r\\nTd1[Te2[(rk[1] >> 8) & 0xff] & 0xff] ^\\r\\nTd2[Te2[(rk[1] >> 16) & 0xff] & 0xff] ^\\r\\nTd3[Te2[(rk[1] >> 24) ] & 0xff];\\r\\nrk[2] =\\r\\nTd0[Te2[(rk[2] ) & 0xff] & 0xff] ^\\r\\nTd1[Te2[(rk[2] >> 8) & 0xff] & 0xff] ^\\r\\nTd2[Te2[(rk[2] >> 16) & 0xff] & 0xff] ^\\r\\nTd3[Te2[(rk[2] >> 24) ] & 0xff];\\r\\nrk[3] =\\r\\nTd0[Te2[(rk[3] ) & 0xff] & 0xff] ^\\r\\nTd1[Te2[(rk[3] >> 8) & 0xff] & 0xff] ^\\r\\nTd2[Te2[(rk[3] >> 16) & 0xff] & 0xff] ^\\r\\nTd3[Te2[(rk[3] >> 24) ] & 0xff];\\r\\n#endif\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid AES_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst AES_KEY *key)\\r\\n{\\r\\nconst u32 *rk;\\r\\nu32 s0, s1, s2, s3, t[4];\\r\\nint r;\\r\\nassert(in && out && key);\\r\\nrk = key->rd_key;\\r\\ns0 = GETU32(in ) ^ rk[0];\\r\\ns1 = GETU32(in + 4) ^ rk[1];\\r\\ns2 = GETU32(in + 8) ^ rk[2];\\r\\ns3 = GETU32(in + 12) ^ rk[3];\\r\\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\\r\\nprefetch256(Te4);\\r\\nt[0] = Te4[(s0 ) & 0xff] ^\\r\\nTe4[(s1 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s2 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s3 >> 24) ] << 24;\\r\\nt[1] = Te4[(s1 ) & 0xff] ^\\r\\nTe4[(s2 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s3 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s0 >> 24) ] << 24;\\r\\nt[2] = Te4[(s2 ) & 0xff] ^\\r\\nTe4[(s3 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s0 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s1 >> 24) ] << 24;\\r\\nt[3] = Te4[(s3 ) & 0xff] ^\\r\\nTe4[(s0 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s1 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s2 >> 24) ] << 24;\\r\\n{ int i;\\r\\nu32 r0, r1, r2;\\r\\nfor (i = 0; i < 4; i++) {\\r\\nr0 = t[i];\\r\\nr1 = r0 & 0x80808080;\\r\\nr2 = ((r0 & 0x7f7f7f7f) << 1) ^\\r\\n((r1 - (r1 >> 7)) & 0x1b1b1b1b);\\r\\n#if defined(ROTATE)\\r\\nt[i] = r2 ^ ROTATE(r2,24) ^ ROTATE(r0,24) ^\\r\\nROTATE(r0,16) ^ ROTATE(r0,8);\\r\\n#else\\r\\nt[i] = r2 ^ ((r2 ^ r0) << 24) ^ ((r2 ^ r0) >> 8) ^\\r\\n(r0 << 16) ^ (r0 >> 16) ^\\r\\n(r0 << 8) ^ (r0 >> 24);\\r\\n#endif\\r\\nt[i] ^= rk[4+i];\\r\\n}\\r\\n}\\r\\n#else\\r\\nt[0] = Te0[(s0 ) & 0xff] ^\\r\\nTe1[(s1 >> 8) & 0xff] ^\\r\\nTe2[(s2 >> 16) & 0xff] ^\\r\\nTe3[(s3 >> 24) ] ^\\r\\nrk[4];\\r\\nt[1] = Te0[(s1 ) & 0xff] ^\\r\\nTe1[(s2 >> 8) & 0xff] ^\\r\\nTe2[(s3 >> 16) & 0xff] ^\\r\\nTe3[(s0 >> 24) ] ^\\r\\nrk[5];\\r\\nt[2] = Te0[(s2 ) & 0xff] ^\\r\\nTe1[(s3 >> 8) & 0xff] ^\\r\\nTe2[(s0 >> 16) & 0xff] ^\\r\\nTe3[(s1 >> 24) ] ^\\r\\nrk[6];\\r\\nt[3] = Te0[(s3 ) & 0xff] ^\\r\\nTe1[(s0 >> 8) & 0xff] ^\\r\\nTe2[(s1 >> 16) & 0xff] ^\\r\\nTe3[(s2 >> 24) ] ^\\r\\nrk[7];\\r\\n#endif\\r\\ns0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\\r\\nfor (rk+=8,r=key->rounds-2; r>0; rk+=4,r--) {\\r\\n#if defined(AES_COMPACT_IN_INNER_ROUNDS)\\r\\nt[0] = Te4[(s0 ) & 0xff] ^\\r\\nTe4[(s1 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s2 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s3 >> 24) ] << 24;\\r\\nt[1] = Te4[(s1 ) & 0xff] ^\\r\\nTe4[(s2 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s3 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s0 >> 24) ] << 24;\\r\\nt[2] = Te4[(s2 ) & 0xff] ^\\r\\nTe4[(s3 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s0 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s1 >> 24) ] << 24;\\r\\nt[3] = Te4[(s3 ) & 0xff] ^\\r\\nTe4[(s0 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s1 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s2 >> 24) ] << 24;\\r\\n{\\r\\nint i;\\r\\nu32 r0, r1, r2;\\r\\nfor (i = 0; i < 4; i++) {\\r\\nr0 = t[i];\\r\\nr1 = r0 & 0x80808080;\\r\\nr2 = ((r0 & 0x7f7f7f7f) << 1) ^\\r\\n((r1 - (r1 >> 7)) & 0x1b1b1b1b);\\r\\n#if defined(ROTATE)\\r\\nt[i] = r2 ^ ROTATE(r2,24) ^ ROTATE(r0,24) ^\\r\\nROTATE(r0,16) ^ ROTATE(r0,8);\\r\\n#else\\r\\nt[i] = r2 ^ ((r2 ^ r0) << 24) ^ ((r2 ^ r0) >> 8) ^\\r\\n(r0 << 16) ^ (r0 >> 16) ^\\r\\n(r0 << 8) ^ (r0 >> 24);\\r\\n#endif\\r\\nt[i] ^= rk[i];\\r\\n}\\r\\n}\\r\\n#else\\r\\nt[0] = Te0[(s0 ) & 0xff] ^\\r\\nTe1[(s1 >> 8) & 0xff] ^\\r\\nTe2[(s2 >> 16) & 0xff] ^\\r\\nTe3[(s3 >> 24) ] ^\\r\\nrk[0];\\r\\nt[1] = Te0[(s1 ) & 0xff] ^\\r\\nTe1[(s2 >> 8) & 0xff] ^\\r\\nTe2[(s3 >> 16) & 0xff] ^\\r\\nTe3[(s0 >> 24) ] ^\\r\\nrk[1];\\r\\nt[2] = Te0[(s2 ) & 0xff] ^\\r\\nTe1[(s3 >> 8) & 0xff] ^\\r\\nTe2[(s0 >> 16) & 0xff] ^\\r\\nTe3[(s1 >> 24) ] ^\\r\\nrk[2];\\r\\nt[3] = Te0[(s3 ) & 0xff] ^\\r\\nTe1[(s0 >> 8) & 0xff] ^\\r\\nTe2[(s1 >> 16) & 0xff] ^\\r\\nTe3[(s2 >> 24) ] ^\\r\\nrk[3];\\r\\n#endif\\r\\ns0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\\r\\n}\\r\\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\\r\\nprefetch256(Te4);\\r\\n*(u32*)(out+0) =\\r\\nTe4[(s0 ) & 0xff] ^\\r\\nTe4[(s1 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s2 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s3 >> 24) ] << 24 ^\\r\\nrk[0];\\r\\n*(u32*)(out+4) =\\r\\nTe4[(s1 ) & 0xff] ^\\r\\nTe4[(s2 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s3 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s0 >> 24) ] << 24 ^\\r\\nrk[1];\\r\\n*(u32*)(out+8) =\\r\\nTe4[(s2 ) & 0xff] ^\\r\\nTe4[(s3 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s0 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s1 >> 24) ] << 24 ^\\r\\nrk[2];\\r\\n*(u32*)(out+12) =\\r\\nTe4[(s3 ) & 0xff] ^\\r\\nTe4[(s0 >> 8) & 0xff] << 8 ^\\r\\nTe4[(s1 >> 16) & 0xff] << 16 ^\\r\\nTe4[(s2 >> 24) ] << 24 ^\\r\\nrk[3];\\r\\n#else\\r\\n*(u32*)(out+0) =\\r\\n(Te2[(s0 ) & 0xff] & 0x000000ffU) ^\\r\\n(Te3[(s1 >> 8) & 0xff] & 0x0000ff00U) ^\\r\\n(Te0[(s2 >> 16) & 0xff] & 0x00ff0000U) ^\\r\\n(Te1[(s3 >> 24) ] & 0xff000000U) ^\\r\\nrk[0];\\r\\n*(u32*)(out+4) =\\r\\n(Te2[(s1 ) & 0xff] & 0x000000ffU) ^\\r\\n(Te3[(s2 >> 8) & 0xff] & 0x0000ff00U) ^\\r\\n(Te0[(s3 >> 16) & 0xff] & 0x00ff0000U) ^\\r\\n(Te1[(s0 >> 24) ] & 0xff000000U) ^\\r\\nrk[1];\\r\\n*(u32*)(out+8) =\\r\\n(Te2[(s2 ) & 0xff] & 0x000000ffU) ^\\r\\n(Te3[(s3 >> 8) & 0xff] & 0x0000ff00U) ^\\r\\n(Te0[(s0 >> 16) & 0xff] & 0x00ff0000U) ^\\r\\n(Te1[(s1 >> 24) ] & 0xff000000U) ^\\r\\nrk[2];\\r\\n*(u32*)(out+12) =\\r\\n(Te2[(s3 ) & 0xff] & 0x000000ffU) ^\\r\\n(Te3[(s0 >> 8) & 0xff] & 0x0000ff00U) ^\\r\\n(Te0[(s1 >> 16) & 0xff] & 0x00ff0000U) ^\\r\\n(Te1[(s2 >> 24) ] & 0xff000000U) ^\\r\\nrk[3];\\r\\n#endif\\r\\n}\\r\\nvoid AES_decrypt(const unsigned char *in, unsigned char *out,\\r\\nconst AES_KEY *key)\\r\\n{\\r\\nconst u32 *rk;\\r\\nu32 s0, s1, s2, s3, t[4];\\r\\nint r;\\r\\nassert(in && out && key);\\r\\nrk = key->rd_key;\\r\\ns0 = GETU32(in ) ^ rk[0];\\r\\ns1 = GETU32(in + 4) ^ rk[1];\\r\\ns2 = GETU32(in + 8) ^ rk[2];\\r\\ns3 = GETU32(in + 12) ^ rk[3];\\r\\n#if defined(AES_COMPACT_IN_OUTER_ROUNDS)\\r\\nprefetch256(Td4);\\r\\nt[0] = Td4[(s0 ) & 0xff] ^\\r\\nTd4[(s3 >> 8) & 0xff] << 8 ^\\r\\nTd4[(s2 >> 16) & 0xff] << 16 ^\\r\\nTd4[(s1 >> 24) ] << 24;\\r\\nt[1] = Td4[(s1 ) & 0xff] ^\\r\\nTd4[(s0 >> 8) & 0xff] << 8 ^\\r\\nTd4[(s3 >> 16) & 0xff] << 16 ^\\r\\nTd4[(s2 >> 24) ] << 24;\\r\\nt[2] = Td4[(s2 ) & 0xff] ^\\r\\nTd4[(s1 >> 8) & 0xff] << 8 ^\\r\\nTd4[(s0 >> 16) & 0xff] << 16 ^\\r\\nTd4[(s3 >> 24) ] << 24;\\r\\nt[3] = Td4[(s3 ) & 0xff] ^\\r\\nTd4[(s2 >> 8) & 0xff] << 8 ^\\r\\nTd4[(s1 >> 16) & 0xff] << 16 ^\\r\\nTd4[(s0 >> 24) ] << 24;\\r\\n{\\r\\nint i;\\r\\nu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\\r\\nfor (i = 0; i < 4; i++) {\\r\\ntp1 = t[i];\\r\\nm = tp1 & 0x80808080;\\r\\ntp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\nm = tp2 & 0x80808080;\\r\\ntp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\nm = tp4 & 0x80808080;\\r\\ntp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\ntp9 = tp8 ^ tp1;\\r\\ntpb = tp9 ^ tp2;\\r\\ntpd = tp9 ^ tp4;\\r\\ntpe = tp8 ^ tp4 ^ tp2;\\r\\n#if defined(ROTATE)\\r\\nt[i] = tpe ^ ROTATE(tpd,16) ^\\r\\nROTATE(tp9,8) ^ ROTATE(tpb,24);\\r\\n#else\\r\\nt[i] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\\r\\n(tp9 >> 24) ^ (tp9 << 8) ^\\r\\n(tpb >> 8) ^ (tpb << 24);\\r\\n#endif\\r\\nt[i] ^= rk[4+i];\\r\\n}\\r\\n}\\r\\n#else\\r\\nt[0] = Td0[(s0 ) & 0xff] ^\\r\\nTd1[(s3 >> 8) & 0xff] ^\\r\\nTd2[(s2 >> 16) & 0xff] ^\\r\\nTd3[(s1 >> 24) ] ^\\r\\nrk[4];\\r\\nt[1] = Td0[(s1 ) & 0xff] ^\\r\\nTd1[(s0 >> 8) & 0xff] ^\\r\\nTd2[(s3 >> 16) & 0xff] ^\\r\\nTd3[(s2 >> 24) ] ^\\r\\nrk[5];\\r\\nt[2] = Td0[(s2 ) & 0xff] ^\\r\\nTd1[(s1 >> 8) & 0xff] ^\\r\\nTd2[(s0 >> 16) & 0xff] ^\\r\\nTd3[(s3 >> 24) ] ^\\r\\nrk[6];\\r\\nt[3] = Td0[(s3 ) & 0xff] ^\\r\\nTd1[(s2 >> 8) & 0xff] ^\\r\\nTd2[(s1 >> 16) & 0xff] ^\\r\\nTd3[(s0 >> 24) ] ^\\r\\nrk[7];\\r\\n#endif\\r\\ns0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\\r\\nfor (rk+=8,r=key->rounds-2; r>0; rk+=4,r--) {\\r\\n#if defined(AES_COMPACT_IN_INNER_ROUNDS)\\r\\nt[0] = Td4[(s0 ) & 0xff] ^\\r\\nTd4[(s3 >> 8) & 0xff] << 8 ^\\r\\nTd4[(s2 >> 16) & 0xff] << 16 ^\\r\\nTd4[(s1 >> 24) ] << 24;\\r\\nt[1] = Td4[(s1 ) & 0xff] ^\\r\\nTd4[(s0 >> 8) & 0xff] << 8 ^\\r\\nTd4[(s3 >> 16) & 0xff] << 16 ^\\r\\nTd4[(s2 >> 24) ] << 24;\\r\\nt[2] = Td4[(s2 ) & 0xff] ^\\r\\nTd4[(s1 >> 8) & 0xff] << 8 ^\\r\\nTd4[(s0 >> 16) & 0xff] << 16 ^\\r\\nTd4[(s3 >> 24) ] << 24;\\r\\nt[3] = Td4[(s3 ) & 0xff] ^\\r\\nTd4[(s2 >> 8) & 0xff] << 8 ^\\r\\nTd4[(s1 >> 16) & 0xff] << 16 ^\\r\\nTd4[(s0 >> 24) ] << 24;\\r\\n{\\r\\nint i;\\r\\nu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\\r\\nfor (i = 0; i < 4; i++) {\\r\\ntp1 = t[i];\\r\\nm = tp1 & 0x80808080;\\r\\ntp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\nm = tp2 & 0x80808080;\\r\\ntp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\nm = tp4 & 0x80808080;\\r\\ntp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\ntp9 = tp8 ^ tp1;\\r\\ntpb = tp9 ^ tp2;\\r\\ntpd = tp9 ^ tp4;\\r\\ntpe = tp8 ^ tp4 ^ tp2;\\r\\n#if defined(ROTATE)\\r\\nt[i] = tpe ^ ROTATE(tpd,16) ^\\r\\nROTATE(tp9,8) ^ ROTATE(tpb,24);\\r\\n#else\\r\\nt[i] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\\r\\n(tp9 >> 24) ^ (tp9 << 8) ^\\r\\n(tpb >> 8) ^ (tpb << 24);\\r\\n#endif\\r\\nt[i] ^= rk[i];\\r\\n}\\r\\n}\\r\\n#else\\r\\nt[0] = Td0[(s0 ) & 0xff] ^\\r\\nTd1[(s3 >> 8) & 0xff] ^\\r\\nTd2[(s2 >> 16) & 0xff] ^\\r\\nTd3[(s1 >> 24) ] ^\\r\\nrk[0];\\r\\nt[1] = Td0[(s1 ) & 0xff] ^\\r\\nTd1[(s0 >> 8) & 0xff] ^\\r\\nTd2[(s3 >> 16) & 0xff] ^\\r\\nTd3[(s2 >> 24) ] ^\\r\\nrk[1];\\r\\nt[2] = Td0[(s2 ) & 0xff] ^\\r\\nTd1[(s1 >> 8) & 0xff] ^\\r\\nTd2[(s0 >> 16) & 0xff] ^\\r\\nTd3[(s3 >> 24) ] ^\\r\\nrk[2];\\r\\nt[3] = Td0[(s3 ) & 0xff] ^\\r\\nTd1[(s2 >> 8) & 0xff] ^\\r\\nTd2[(s1 >> 16) & 0xff] ^\\r\\nTd3[(s0 >> 24) ] ^\\r\\nrk[3];\\r\\n#endif\\r\\ns0 = t[0]; s1 = t[1]; s2 = t[2]; s3 = t[3];\\r\\n}\\r\\nprefetch256(Td4);\\r\\n*(u32*)(out+0) =\\r\\n(Td4[(s0 ) & 0xff]) ^\\r\\n(Td4[(s3 >> 8) & 0xff] << 8) ^\\r\\n(Td4[(s2 >> 16) & 0xff] << 16) ^\\r\\n(Td4[(s1 >> 24) ] << 24) ^\\r\\nrk[0];\\r\\n*(u32*)(out+4) =\\r\\n(Td4[(s1 ) & 0xff]) ^\\r\\n(Td4[(s0 >> 8) & 0xff] << 8) ^\\r\\n(Td4[(s3 >> 16) & 0xff] << 16) ^\\r\\n(Td4[(s2 >> 24) ] << 24) ^\\r\\nrk[1];\\r\\n*(u32*)(out+8) =\\r\\n(Td4[(s2 ) & 0xff]) ^\\r\\n(Td4[(s1 >> 8) & 0xff] << 8) ^\\r\\n(Td4[(s0 >> 16) & 0xff] << 16) ^\\r\\n(Td4[(s3 >> 24) ] << 24) ^\\r\\nrk[2];\\r\\n*(u32*)(out+12) =\\r\\n(Td4[(s3 ) & 0xff]) ^\\r\\n(Td4[(s2 >> 8) & 0xff] << 8) ^\\r\\n(Td4[(s1 >> 16) & 0xff] << 16) ^\\r\\n(Td4[(s0 >> 24) ] << 24) ^\\r\\nrk[3];\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_key_c", "target": 0, "func": "EC_KEY *EC_KEY_new(void)\\r\\n{\\r\\nEC_KEY *ret;\\r\\nret = (EC_KEY *)OPENSSL_malloc(sizeof(EC_KEY));\\r\\nif (ret == NULL) {\\r\\nECerr(EC_F_EC_KEY_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nret->version = 1;\\r\\nret->flags = 0;\\r\\nret->group = NULL;\\r\\nret->pub_key = NULL;\\r\\nret->priv_key = NULL;\\r\\nret->enc_flag = 0;\\r\\nret->conv_form = POINT_CONVERSION_UNCOMPRESSED;\\r\\nret->references = 1;\\r\\nret->method_data = NULL;\\r\\nreturn (ret);\\r\\n}\\r\\nEC_KEY *EC_KEY_new_by_curve_name(int nid)\\r\\n{\\r\\nEC_KEY *ret = EC_KEY_new();\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nret->group = EC_GROUP_new_by_curve_name(nid);\\r\\nif (ret->group == NULL) {\\r\\nEC_KEY_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid EC_KEY_free(EC_KEY *r)\\r\\n{\\r\\nint i;\\r\\nif (r == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_EC);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EC_KEY\", r);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"EC_KEY_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (r->group != NULL)\\r\\nEC_GROUP_free(r->group);\\r\\nif (r->pub_key != NULL)\\r\\nEC_POINT_free(r->pub_key);\\r\\nif (r->priv_key != NULL)\\r\\nBN_clear_free(r->priv_key);\\r\\nEC_EX_DATA_free_all_data(&r->method_data);\\r\\nOPENSSL_cleanse((void *)r, sizeof(EC_KEY));\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nEC_KEY *EC_KEY_copy(EC_KEY *dest, const EC_KEY *src)\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (dest == NULL || src == NULL) {\\r\\nECerr(EC_F_EC_KEY_COPY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (src->group) {\\r\\nconst EC_METHOD *meth = EC_GROUP_method_of(src->group);\\r\\nif (dest->group)\\r\\nEC_GROUP_free(dest->group);\\r\\ndest->group = EC_GROUP_new(meth);\\r\\nif (dest->group == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_GROUP_copy(dest->group, src->group))\\r\\nreturn NULL;\\r\\n}\\r\\nif (src->pub_key && src->group) {\\r\\nif (dest->pub_key)\\r\\nEC_POINT_free(dest->pub_key);\\r\\ndest->pub_key = EC_POINT_new(src->group);\\r\\nif (dest->pub_key == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_POINT_copy(dest->pub_key, src->pub_key))\\r\\nreturn NULL;\\r\\n}\\r\\nif (src->priv_key) {\\r\\nif (dest->priv_key == NULL) {\\r\\ndest->priv_key = BN_new();\\r\\nif (dest->priv_key == NULL)\\r\\nreturn NULL;\\r\\n}\\r\\nif (!BN_copy(dest->priv_key, src->priv_key))\\r\\nreturn NULL;\\r\\n}\\r\\nEC_EX_DATA_free_all_data(&dest->method_data);\\r\\nfor (d = src->method_data; d != NULL; d = d->next) {\\r\\nvoid *t = d->dup_func(d->data);\\r\\nif (t == NULL)\\r\\nreturn 0;\\r\\nif (!EC_EX_DATA_set_data\\r\\n(&dest->method_data, t, d->dup_func, d->free_func,\\r\\nd->clear_free_func))\\r\\nreturn 0;\\r\\n}\\r\\ndest->enc_flag = src->enc_flag;\\r\\ndest->conv_form = src->conv_form;\\r\\ndest->version = src->version;\\r\\ndest->flags = src->flags;\\r\\nreturn dest;\\r\\n}\\r\\nEC_KEY *EC_KEY_dup(const EC_KEY *ec_key)\\r\\n{\\r\\nEC_KEY *ret = EC_KEY_new();\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nif (EC_KEY_copy(ret, ec_key) == NULL) {\\r\\nEC_KEY_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint EC_KEY_up_ref(EC_KEY *r)\\r\\n{\\r\\nint i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_EC);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EC_KEY\", r);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (i < 2) {\\r\\nfprintf(stderr, \"EC_KEY_up, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nreturn ((i > 1) ? 1 : 0);\\r\\n}\\r\\nint EC_KEY_generate_key(EC_KEY *eckey)\\r\\n{\\r\\nint ok = 0;\\r\\nBN_CTX *ctx = NULL;\\r\\nBIGNUM *priv_key = NULL, *order = NULL;\\r\\nEC_POINT *pub_key = NULL;\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_ec_key_generate_key(eckey);\\r\\n#endif\\r\\nif (!eckey || !eckey->group) {\\r\\nECerr(EC_F_EC_KEY_GENERATE_KEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif ((order = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (eckey->priv_key == NULL) {\\r\\npriv_key = BN_new();\\r\\nif (priv_key == NULL)\\r\\ngoto err;\\r\\n} else\\r\\npriv_key = eckey->priv_key;\\r\\nif (!EC_GROUP_get_order(eckey->group, order, ctx))\\r\\ngoto err;\\r\\ndo\\r\\nif (!BN_rand_range(priv_key, order))\\r\\ngoto err;\\r\\nwhile (BN_is_zero(priv_key)) ;\\r\\nif (eckey->pub_key == NULL) {\\r\\npub_key = EC_POINT_new(eckey->group);\\r\\nif (pub_key == NULL)\\r\\ngoto err;\\r\\n} else\\r\\npub_key = eckey->pub_key;\\r\\nif (!EC_POINT_mul(eckey->group, pub_key, priv_key, NULL, NULL, ctx))\\r\\ngoto err;\\r\\neckey->priv_key = priv_key;\\r\\neckey->pub_key = pub_key;\\r\\nok = 1;\\r\\nerr:\\r\\nif (order)\\r\\nBN_free(order);\\r\\nif (pub_key != NULL && eckey->pub_key == NULL)\\r\\nEC_POINT_free(pub_key);\\r\\nif (priv_key != NULL && eckey->priv_key == NULL)\\r\\nBN_free(priv_key);\\r\\nif (ctx != NULL)\\r\\nBN_CTX_free(ctx);\\r\\nreturn (ok);\\r\\n}\\r\\nint EC_KEY_check_key(const EC_KEY *eckey)\\r\\n{\\r\\nint ok = 0;\\r\\nBN_CTX *ctx = NULL;\\r\\nconst BIGNUM *order = NULL;\\r\\nEC_POINT *point = NULL;\\r\\nif (!eckey || !eckey->group || !eckey->pub_key) {\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (EC_POINT_is_at_infinity(eckey->group, eckey->pub_key)) {\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_POINT_AT_INFINITY);\\r\\ngoto err;\\r\\n}\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif ((point = EC_POINT_new(eckey->group)) == NULL)\\r\\ngoto err;\\r\\nif (!EC_POINT_is_on_curve(eckey->group, eckey->pub_key, ctx)) {\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_POINT_IS_NOT_ON_CURVE);\\r\\ngoto err;\\r\\n}\\r\\norder = &eckey->group->order;\\r\\nif (BN_is_zero(order)) {\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_INVALID_GROUP_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_mul(eckey->group, point, NULL, eckey->pub_key, order, ctx)) {\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_is_at_infinity(eckey->group, point)) {\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_WRONG_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (eckey->priv_key) {\\r\\nif (BN_cmp(eckey->priv_key, order) >= 0) {\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_WRONG_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_mul(eckey->group, point, eckey->priv_key,\\r\\nNULL, NULL, ctx)) {\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_POINT_cmp(eckey->group, point, eckey->pub_key, ctx) != 0) {\\r\\nECerr(EC_F_EC_KEY_CHECK_KEY, EC_R_INVALID_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\nBN_CTX_free(ctx);\\r\\nif (point != NULL)\\r\\nEC_POINT_free(point);\\r\\nreturn (ok);\\r\\n}\\r\\nint EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,\\r\\nBIGNUM *y)\\r\\n{\\r\\nBN_CTX *ctx = NULL;\\r\\nBIGNUM *tx, *ty;\\r\\nEC_POINT *point = NULL;\\r\\nint ok = 0, tmp_nid, is_char_two = 0;\\r\\nif (!key || !key->group || !x || !y) {\\r\\nECerr(EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nctx = BN_CTX_new();\\r\\nif (!ctx)\\r\\ngoto err;\\r\\npoint = EC_POINT_new(key->group);\\r\\nif (!point)\\r\\ngoto err;\\r\\ntmp_nid = EC_METHOD_get_field_type(EC_GROUP_method_of(key->group));\\r\\nif (tmp_nid == NID_X9_62_characteristic_two_field)\\r\\nis_char_two = 1;\\r\\ntx = BN_CTX_get(ctx);\\r\\nty = BN_CTX_get(ctx);\\r\\n#ifndef OPENSSL_NO_EC2M\\r\\nif (is_char_two) {\\r\\nif (!EC_POINT_set_affine_coordinates_GF2m(key->group, point,\\r\\nx, y, ctx))\\r\\ngoto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(key->group, point,\\r\\ntx, ty, ctx))\\r\\ngoto err;\\r\\n} else\\r\\n#endif\\r\\n{\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(key->group, point,\\r\\nx, y, ctx))\\r\\ngoto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GFp(key->group, point,\\r\\ntx, ty, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (BN_cmp(x, tx) || BN_cmp(y, ty)) {\\r\\nECerr(EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES,\\r\\nEC_R_COORDINATES_OUT_OF_RANGE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_KEY_set_public_key(key, point))\\r\\ngoto err;\\r\\nif (EC_KEY_check_key(key) == 0)\\r\\ngoto err;\\r\\nok = 1;\\r\\nerr:\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nif (point)\\r\\nEC_POINT_free(point);\\r\\nreturn ok;\\r\\n}\\r\\nconst EC_GROUP *EC_KEY_get0_group(const EC_KEY *key)\\r\\n{\\r\\nreturn key->group;\\r\\n}\\r\\nint EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group)\\r\\n{\\r\\nif (key->group != NULL)\\r\\nEC_GROUP_free(key->group);\\r\\nkey->group = EC_GROUP_dup(group);\\r\\nreturn (key->group == NULL) ? 0 : 1;\\r\\n}\\r\\nconst BIGNUM *EC_KEY_get0_private_key(const EC_KEY *key)\\r\\n{\\r\\nreturn key->priv_key;\\r\\n}\\r\\nint EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *priv_key)\\r\\n{\\r\\nif (key->priv_key)\\r\\nBN_clear_free(key->priv_key);\\r\\nkey->priv_key = BN_dup(priv_key);\\r\\nreturn (key->priv_key == NULL) ? 0 : 1;\\r\\n}\\r\\nconst EC_POINT *EC_KEY_get0_public_key(const EC_KEY *key)\\r\\n{\\r\\nreturn key->pub_key;\\r\\n}\\r\\nint EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub_key)\\r\\n{\\r\\nif (key->pub_key != NULL)\\r\\nEC_POINT_free(key->pub_key);\\r\\nkey->pub_key = EC_POINT_dup(pub_key, key->group);\\r\\nreturn (key->pub_key == NULL) ? 0 : 1;\\r\\n}\\r\\nunsigned int EC_KEY_get_enc_flags(const EC_KEY *key)\\r\\n{\\r\\nreturn key->enc_flag;\\r\\n}\\r\\nvoid EC_KEY_set_enc_flags(EC_KEY *key, unsigned int flags)\\r\\n{\\r\\nkey->enc_flag = flags;\\r\\n}\\r\\npoint_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *key)\\r\\n{\\r\\nreturn key->conv_form;\\r\\n}\\r\\nvoid EC_KEY_set_conv_form(EC_KEY *key, point_conversion_form_t cform)\\r\\n{\\r\\nkey->conv_form = cform;\\r\\nif (key->group != NULL)\\r\\nEC_GROUP_set_point_conversion_form(key->group, cform);\\r\\n}\\r\\nvoid *EC_KEY_get_key_method_data(EC_KEY *key,\\r\\nvoid *(*dup_func) (void *),\\r\\nvoid (*free_func) (void *),\\r\\nvoid (*clear_free_func) (void *))\\r\\n{\\r\\nvoid *ret;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_EC);\\r\\nret =\\r\\nEC_EX_DATA_get_data(key->method_data, dup_func, free_func,\\r\\nclear_free_func);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_EC);\\r\\nreturn ret;\\r\\n}\\r\\nvoid *EC_KEY_insert_key_method_data(EC_KEY *key, void *data,\\r\\nvoid *(*dup_func) (void *),\\r\\nvoid (*free_func) (void *),\\r\\nvoid (*clear_free_func) (void *))\\r\\n{\\r\\nEC_EXTRA_DATA *ex_data;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EC);\\r\\nex_data =\\r\\nEC_EX_DATA_get_data(key->method_data, dup_func, free_func,\\r\\nclear_free_func);\\r\\nif (ex_data == NULL)\\r\\nEC_EX_DATA_set_data(&key->method_data, data, dup_func, free_func,\\r\\nclear_free_func);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EC);\\r\\nreturn ex_data;\\r\\n}\\r\\nvoid EC_KEY_set_asn1_flag(EC_KEY *key, int flag)\\r\\n{\\r\\nif (key->group != NULL)\\r\\nEC_GROUP_set_asn1_flag(key->group, flag);\\r\\n}\\r\\nint EC_KEY_precompute_mult(EC_KEY *key, BN_CTX *ctx)\\r\\n{\\r\\nif (key->group == NULL)\\r\\nreturn 0;\\r\\nreturn EC_GROUP_precompute_mult(key->group, ctx);\\r\\n}\\r\\nint EC_KEY_get_flags(const EC_KEY *key)\\r\\n{\\r\\nreturn key->flags;\\r\\n}\\r\\nvoid EC_KEY_set_flags(EC_KEY *key, int flags)\\r\\n{\\r\\nkey->flags |= flags;\\r\\n}\\r\\nvoid EC_KEY_clear_flags(EC_KEY *key, int flags)\\r\\n{\\r\\nkey->flags &= ~flags;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p5_pbev2_c", "target": 0, "func": "X509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen,\\r\\nint prf_nid, int keylen)\\r\\n{\\r\\nX509_ALGOR *keyfunc = NULL;\\r\\nPBKDF2PARAM *kdf = NULL;\\r\\nASN1_OCTET_STRING *osalt = NULL;\\r\\nif (!(kdf = PBKDF2PARAM_new()))\\r\\ngoto merr;\\r\\nif (!(osalt = M_ASN1_OCTET_STRING_new()))\\r\\ngoto merr;\\r\\nkdf->salt->value.octet_string = osalt;\\r\\nkdf->salt->type = V_ASN1_OCTET_STRING;\\r\\nif (!saltlen)\\r\\nsaltlen = PKCS5_SALT_LEN;\\r\\nif (!(osalt->data = OPENSSL_malloc(saltlen)))\\r\\ngoto merr;\\r\\nosalt->length = saltlen;\\r\\nif (salt)\\r\\nmemcpy(osalt->data, salt, saltlen);\\r\\nelse if (RAND_pseudo_bytes(osalt->data, saltlen) < 0)\\r\\ngoto merr;\\r\\nif (iter <= 0)\\r\\niter = PKCS5_DEFAULT_ITER;\\r\\nif (!ASN1_INTEGER_set(kdf->iter, iter))\\r\\ngoto merr;\\r\\nif (keylen > 0) {\\r\\nif (!(kdf->keylength = M_ASN1_INTEGER_new()))\\r\\ngoto merr;\\r\\nif (!ASN1_INTEGER_set(kdf->keylength, keylen))\\r\\ngoto merr;\\r\\n}\\r\\nif (prf_nid > 0 && prf_nid != NID_hmacWithSHA1) {\\r\\nkdf->prf = X509_ALGOR_new();\\r\\nif (!kdf->prf)\\r\\ngoto merr;\\r\\nX509_ALGOR_set0(kdf->prf, OBJ_nid2obj(prf_nid), V_ASN1_NULL, NULL);\\r\\n}\\r\\nkeyfunc = X509_ALGOR_new();\\r\\nif (!keyfunc)\\r\\ngoto merr;\\r\\nkeyfunc->algorithm = OBJ_nid2obj(NID_id_pbkdf2);\\r\\nif (!(keyfunc->parameter = ASN1_TYPE_new()))\\r\\ngoto merr;\\r\\nif (!ASN1_item_pack(kdf, ASN1_ITEM_rptr(PBKDF2PARAM),\\r\\n&keyfunc->parameter->value.sequence))\\r\\ngoto merr;\\r\\nkeyfunc->parameter->type = V_ASN1_SEQUENCE;\\r\\nPBKDF2PARAM_free(kdf);\\r\\nreturn keyfunc;\\r\\nmerr:\\r\\nASN1err(ASN1_F_PKCS5_PBKDF2_SET, ERR_R_MALLOC_FAILURE);\\r\\nPBKDF2PARAM_free(kdf);\\r\\nX509_ALGOR_free(keyfunc);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_saccept_c", "target": 0, "func": "void close_up()\\r\\n{\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\n}\\r\\nint main(argc, argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nchar *port = NULL;\\r\\nBIO *ssl_bio, *tmp;\\r\\nSSL_CTX *ctx;\\r\\nSSL *ssl;\\r\\nchar buf[512];\\r\\nint ret = 1, i;\\r\\nif (argc <= 1)\\r\\nport = \"*:4433\";\\r\\nelse\\r\\nport = argv[1];\\r\\nsignal(SIGINT, close_up);\\r\\nSSL_load_error_strings();\\r\\n#ifdef WATT32\\r\\ndbug_init();\\r\\nsock_init();\\r\\n#endif\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nctx = SSL_CTX_new(SSLv23_server_method());\\r\\nif (!SSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM))\\r\\ngoto err;\\r\\nif (!SSL_CTX_use_PrivateKey_file(ctx, CERT_FILE, SSL_FILETYPE_PEM))\\r\\ngoto err;\\r\\nif (!SSL_CTX_check_private_key(ctx))\\r\\ngoto err;\\r\\nssl = SSL_new(ctx);\\r\\nssl_bio = BIO_new_ssl(ctx, 0);\\r\\nif ((in = BIO_new_accept(port)) == NULL)\\r\\ngoto err;\\r\\nBIO_set_accept_bios(in, ssl_bio);\\r\\nagain:\\r\\nif (BIO_do_accept(in) <= 0)\\r\\ngoto err;\\r\\nfor (;;) {\\r\\ni = BIO_read(in, buf, 512);\\r\\nif (i == 0) {\\r\\nprintf(\"Done\\n\");\\r\\ntmp = BIO_pop(in);\\r\\nBIO_free_all(tmp);\\r\\ngoto again;\\r\\n}\\r\\nif (i < 0)\\r\\ngoto err;\\r\\nfwrite(buf, 1, i, stdout);\\r\\nfflush(stdout);\\r\\n}\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nexit(ret);\\r\\nreturn (!ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_gen_c", "target": 0, "func": "int DH_generate_parameters_ex(DH *ret, int prime_len, int generator,\\r\\nBN_GENCB *cb)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(ret->meth->flags & DH_FLAG_FIPS_METHOD)\\r\\n&& !(ret->flags & DH_FLAG_NON_FIPS_ALLOW)) {\\r\\nDHerr(DH_F_DH_GENERATE_PARAMETERS_EX, DH_R_NON_FIPS_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nif (ret->meth->generate_params)\\r\\nreturn ret->meth->generate_params(ret, prime_len, generator, cb);\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_dh_generate_parameters_ex(ret, prime_len, generator, cb);\\r\\n#endif\\r\\nreturn dh_builtin_genparams(ret, prime_len, generator, cb);\\r\\n}\\r\\nstatic int dh_builtin_genparams(DH *ret, int prime_len, int generator,\\r\\nBN_GENCB *cb)\\r\\n{\\r\\nBIGNUM *t1, *t2;\\r\\nint g, ok = -1;\\r\\nBN_CTX *ctx = NULL;\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nt2 = BN_CTX_get(ctx);\\r\\nif (t1 == NULL || t2 == NULL)\\r\\ngoto err;\\r\\nif (!ret->p && ((ret->p = BN_new()) == NULL))\\r\\ngoto err;\\r\\nif (!ret->g && ((ret->g = BN_new()) == NULL))\\r\\ngoto err;\\r\\nif (generator <= 1) {\\r\\nDHerr(DH_F_DH_BUILTIN_GENPARAMS, DH_R_BAD_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\nif (generator == DH_GENERATOR_2) {\\r\\nif (!BN_set_word(t1, 24))\\r\\ngoto err;\\r\\nif (!BN_set_word(t2, 11))\\r\\ngoto err;\\r\\ng = 2;\\r\\n}\\r\\n#if 0\\r\\nelse if (generator == DH_GENERATOR_3) {\\r\\nif (!BN_set_word(t1, 12))\\r\\ngoto err;\\r\\nif (!BN_set_word(t2, 5))\\r\\ngoto err;\\r\\ng = 3;\\r\\n}\\r\\n#endif\\r\\nelse if (generator == DH_GENERATOR_5) {\\r\\nif (!BN_set_word(t1, 10))\\r\\ngoto err;\\r\\nif (!BN_set_word(t2, 3))\\r\\ngoto err;\\r\\ng = 5;\\r\\n} else {\\r\\nif (!BN_set_word(t1, 2))\\r\\ngoto err;\\r\\nif (!BN_set_word(t2, 1))\\r\\ngoto err;\\r\\ng = generator;\\r\\n}\\r\\nif (!BN_generate_prime_ex(ret->p, prime_len, 1, t1, t2, cb))\\r\\ngoto err;\\r\\nif (!BN_GENCB_call(cb, 3, 0))\\r\\ngoto err;\\r\\nif (!BN_set_word(ret->g, g))\\r\\ngoto err;\\r\\nok = 1;\\r\\nerr:\\r\\nif (ok == -1) {\\r\\nDHerr(DH_F_DH_BUILTIN_GENPARAMS, ERR_R_BN_LIB);\\r\\nok = 0;\\r\\n}\\r\\nif (ctx != NULL) {\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nreturn ok;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_mult_c", "target": 1, "func": "static EC_PRE_COMP *ec_pre_comp_new(const EC_GROUP *group)\\r\\n{\\r\\nEC_PRE_COMP *ret = NULL;\\r\\nif (!group)\\r\\nreturn NULL;\\r\\nret = (EC_PRE_COMP *)OPENSSL_malloc(sizeof(EC_PRE_COMP));\\r\\nif (!ret) {\\r\\nECerr(EC_F_EC_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn ret;\\r\\n}\\r\\nret->group = group;\\r\\nret->blocksize = 8;\\r\\nret->numblocks = 0;\\r\\nret->w = 4;\\r\\nret->points = NULL;\\r\\nret->num = 0;\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nstatic void *ec_pre_comp_dup(void *src_)\\r\\n{\\r\\nEC_PRE_COMP *src = src_;\\r\\nCRYPTO_add(&src->references, 1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nreturn src_;\\r\\n}\\r\\nstatic void ec_pre_comp_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nEC_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nif (pre->points) {\\r\\nEC_POINT **p;\\r\\nfor (p = pre->points; *p != NULL; p++)\\r\\nEC_POINT_free(*p);\\r\\nOPENSSL_free(pre->points);\\r\\n}\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nstatic void ec_pre_comp_clear_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nEC_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nif (pre->points) {\\r\\nEC_POINT **p;\\r\\nfor (p = pre->points; *p != NULL; p++) {\\r\\nEC_POINT_clear_free(*p);\\r\\nOPENSSL_cleanse(p, sizeof *p);\\r\\n}\\r\\nOPENSSL_free(pre->points);\\r\\n}\\r\\nOPENSSL_cleanse(pre, sizeof *pre);\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nstatic signed char *compute_wNAF(const BIGNUM *scalar, int w, size_t *ret_len)\\r\\n{\\r\\nint window_val;\\r\\nint ok = 0;\\r\\nsigned char *r = NULL;\\r\\nint sign = 1;\\r\\nint bit, next_bit, mask;\\r\\nsize_t len = 0, j;\\r\\nif (BN_is_zero(scalar)) {\\r\\nr = OPENSSL_malloc(1);\\r\\nif (!r) {\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nr[0] = 0;\\r\\n*ret_len = 1;\\r\\nreturn r;\\r\\n}\\r\\nif (w <= 0 || w > 7) {\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nbit = 1 << w;\\r\\nnext_bit = bit << 1;\\r\\nmask = next_bit - 1;\\r\\nif (BN_is_negative(scalar)) {\\r\\nsign = -1;\\r\\n}\\r\\nif (scalar->d == NULL || scalar->top == 0) {\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nlen = BN_num_bits(scalar);\\r\\nr = OPENSSL_malloc(len + 1);\\r\\nif (r == NULL) {\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nwindow_val = scalar->d[0] & mask;\\r\\nj = 0;\\r\\nwhile ((window_val != 0) || (j + w + 1 < len)) {\\r\\nint digit = 0;\\r\\nif (window_val & 1) {\\r\\nif (window_val & bit) {\\r\\ndigit = window_val - next_bit;\\r\\n#if 1\\r\\nif (j + w + 1 >= len) {\\r\\ndigit = window_val & (mask >> 1);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\ndigit = window_val;\\r\\n}\\r\\nif (digit <= -bit || digit >= bit || !(digit & 1)) {\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwindow_val -= digit;\\r\\nif (window_val != 0 && window_val != next_bit\\r\\n&& window_val != bit) {\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nr[j++] = sign * digit;\\r\\nwindow_val >>= 1;\\r\\nwindow_val += bit * BN_is_bit_set(scalar, j + w);\\r\\nif (window_val > next_bit) {\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (j > len + 1) {\\r\\nECerr(EC_F_COMPUTE_WNAF, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nlen = j;\\r\\nok = 1;\\r\\nerr:\\r\\nif (!ok) {\\r\\nOPENSSL_free(r);\\r\\nr = NULL;\\r\\n}\\r\\nif (ok)\\r\\n*ret_len = len;\\r\\nreturn r;\\r\\n}\\r\\nint ec_wNAF_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\\r\\nsize_t num, const EC_POINT *points[], const BIGNUM *scalars[],\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nconst EC_POINT *generator = NULL;\\r\\nEC_POINT *tmp = NULL;\\r\\nsize_t totalnum;\\r\\nsize_t blocksize = 0, numblocks = 0;\\r\\nsize_t pre_points_per_block = 0;\\r\\nsize_t i, j;\\r\\nint k;\\r\\nint r_is_inverted = 0;\\r\\nint r_is_at_infinity = 1;\\r\\nsize_t *wsize = NULL;\\r\\nsigned char **wNAF = NULL;\\r\\nsize_t *wNAF_len = NULL;\\r\\nsize_t max_len = 0;\\r\\nsize_t num_val;\\r\\nEC_POINT **val = NULL;\\r\\nEC_POINT **v;\\r\\nEC_POINT ***val_sub = NULL;\\r\\nconst EC_PRE_COMP *pre_comp = NULL;\\r\\nint num_scalar = 0;\\r\\nint ret = 0;\\r\\nif (group->meth != r->meth) {\\r\\nECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif ((scalar == NULL) && (num == 0)) {\\r\\nreturn EC_POINT_set_to_infinity(group, r);\\r\\n}\\r\\nfor (i = 0; i < num; i++) {\\r\\nif (group->meth != points[i]->meth) {\\r\\nECerr(EC_F_EC_WNAF_MUL, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (scalar != NULL) {\\r\\ngenerator = EC_GROUP_get0_generator(group);\\r\\nif (generator == NULL) {\\r\\nECerr(EC_F_EC_WNAF_MUL, EC_R_UNDEFINED_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\npre_comp =\\r\\nEC_EX_DATA_get_data(group->extra_data, ec_pre_comp_dup,\\r\\nec_pre_comp_free, ec_pre_comp_clear_free);\\r\\nif (pre_comp && pre_comp->numblocks\\r\\n&& (EC_POINT_cmp(group, generator, pre_comp->points[0], ctx) ==\\r\\n0)) {\\r\\nblocksize = pre_comp->blocksize;\\r\\nnumblocks = (BN_num_bits(scalar) / blocksize) + 1;\\r\\nif (numblocks > pre_comp->numblocks)\\r\\nnumblocks = pre_comp->numblocks;\\r\\npre_points_per_block = (size_t)1 << (pre_comp->w - 1);\\r\\nif (pre_comp->num != (pre_comp->numblocks * pre_points_per_block)) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\npre_comp = NULL;\\r\\nnumblocks = 1;\\r\\nnum_scalar = 1;\\r\\n}\\r\\n}\\r\\ntotalnum = num + numblocks;\\r\\nwsize = OPENSSL_malloc(totalnum * sizeof wsize[0]);\\r\\nwNAF_len = OPENSSL_malloc(totalnum * sizeof wNAF_len[0]);\\r\\nwNAF = OPENSSL_malloc((totalnum + 1) * sizeof wNAF[0]);\\r\\nval_sub = OPENSSL_malloc(totalnum * sizeof val_sub[0]);\\r\\nif (wNAF)\\r\\nwNAF[0] = NULL;\\r\\nif (!wsize || !wNAF_len || !wNAF || !val_sub) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nnum_val = 0;\\r\\nfor (i = 0; i < num + num_scalar; i++) {\\r\\nsize_t bits;\\r\\nbits = i < num ? BN_num_bits(scalars[i]) : BN_num_bits(scalar);\\r\\nwsize[i] = EC_window_bits_for_scalar_size(bits);\\r\\nnum_val += (size_t)1 << (wsize[i] - 1);\\r\\nwNAF[i + 1] = NULL;\\r\\nwNAF[i] =\\r\\ncompute_wNAF((i < num ? scalars[i] : scalar), wsize[i],\\r\\n&wNAF_len[i]);\\r\\nif (wNAF[i] == NULL)\\r\\ngoto err;\\r\\nif (wNAF_len[i] > max_len)\\r\\nmax_len = wNAF_len[i];\\r\\n}\\r\\nif (numblocks) {\\r\\nif (pre_comp == NULL) {\\r\\nif (num_scalar != 1) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nsigned char *tmp_wNAF = NULL;\\r\\nsize_t tmp_len = 0;\\r\\nif (num_scalar != 0) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwsize[num] = pre_comp->w;\\r\\ntmp_wNAF = compute_wNAF(scalar, wsize[num], &tmp_len);\\r\\nif (!tmp_wNAF)\\r\\ngoto err;\\r\\nif (tmp_len <= max_len) {\\r\\nnumblocks = 1;\\r\\ntotalnum = num + 1;\\r\\nwNAF[num] = tmp_wNAF;\\r\\nwNAF[num + 1] = NULL;\\r\\nwNAF_len[num] = tmp_len;\\r\\nif (tmp_len > max_len)\\r\\nmax_len = tmp_len;\\r\\nval_sub[num] = pre_comp->points;\\r\\n} else {\\r\\nsigned char *pp;\\r\\nEC_POINT **tmp_points;\\r\\nif (tmp_len < numblocks * blocksize) {\\r\\nnumblocks = (tmp_len + blocksize - 1) / blocksize;\\r\\nif (numblocks > pre_comp->numblocks) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ntotalnum = num + numblocks;\\r\\n}\\r\\npp = tmp_wNAF;\\r\\ntmp_points = pre_comp->points;\\r\\nfor (i = num; i < totalnum; i++) {\\r\\nif (i < totalnum - 1) {\\r\\nwNAF_len[i] = blocksize;\\r\\nif (tmp_len < blocksize) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ntmp_len -= blocksize;\\r\\n} else\\r\\nwNAF_len[i] = tmp_len;\\r\\nwNAF[i + 1] = NULL;\\r\\nwNAF[i] = OPENSSL_malloc(wNAF_len[i]);\\r\\nif (wNAF[i] == NULL) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(tmp_wNAF);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(wNAF[i], pp, wNAF_len[i]);\\r\\nif (wNAF_len[i] > max_len)\\r\\nmax_len = wNAF_len[i];\\r\\nif (*tmp_points == NULL) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\nOPENSSL_free(tmp_wNAF);\\r\\ngoto err;\\r\\n}\\r\\nval_sub[i] = tmp_points;\\r\\ntmp_points += pre_points_per_block;\\r\\npp += blocksize;\\r\\n}\\r\\nOPENSSL_free(tmp_wNAF);\\r\\n}\\r\\n}\\r\\n}\\r\\nval = OPENSSL_malloc((num_val + 1) * sizeof val[0]);\\r\\nif (val == NULL) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nval[num_val] = NULL;\\r\\nv = val;\\r\\nfor (i = 0; i < num + num_scalar; i++) {\\r\\nval_sub[i] = v;\\r\\nfor (j = 0; j < ((size_t)1 << (wsize[i] - 1)); j++) {\\r\\n*v = EC_POINT_new(group);\\r\\nif (*v == NULL)\\r\\ngoto err;\\r\\nv++;\\r\\n}\\r\\n}\\r\\nif (!(v == val + num_val)) {\\r\\nECerr(EC_F_EC_WNAF_MUL, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!(tmp = EC_POINT_new(group)))\\r\\ngoto err;\\r\\nfor (i = 0; i < num + num_scalar; i++) {\\r\\nif (i < num) {\\r\\nif (!EC_POINT_copy(val_sub[i][0], points[i]))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!EC_POINT_copy(val_sub[i][0], generator))\\r\\ngoto err;\\r\\n}\\r\\nif (wsize[i] > 1) {\\r\\nif (!EC_POINT_dbl(group, tmp, val_sub[i][0], ctx))\\r\\ngoto err;\\r\\nfor (j = 1; j < ((size_t)1 << (wsize[i] - 1)); j++) {\\r\\nif (!EC_POINT_add\\r\\n(group, val_sub[i][j], val_sub[i][j - 1], tmp, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\n#if 1\\r\\nif (!EC_POINTs_make_affine(group, num_val, val, ctx))\\r\\ngoto err;\\r\\n#endif\\r\\nr_is_at_infinity = 1;\\r\\nfor (k = max_len - 1; k >= 0; k--) {\\r\\nif (!r_is_at_infinity) {\\r\\nif (!EC_POINT_dbl(group, r, r, ctx))\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < totalnum; i++) {\\r\\nif (wNAF_len[i] > (size_t)k) {\\r\\nint digit = wNAF[i][k];\\r\\nint is_neg;\\r\\nif (digit) {\\r\\nis_neg = digit < 0;\\r\\nif (is_neg)\\r\\ndigit = -digit;\\r\\nif (is_neg != r_is_inverted) {\\r\\nif (!r_is_at_infinity) {\\r\\nif (!EC_POINT_invert(group, r, ctx))\\r\\ngoto err;\\r\\n}\\r\\nr_is_inverted = !r_is_inverted;\\r\\n}\\r\\nif (r_is_at_infinity) {\\r\\nif (!EC_POINT_copy(r, val_sub[i][digit >> 1]))\\r\\ngoto err;\\r\\nr_is_at_infinity = 0;\\r\\n} else {\\r\\nif (!EC_POINT_add\\r\\n(group, r, r, val_sub[i][digit >> 1], ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nif (r_is_at_infinity) {\\r\\nif (!EC_POINT_set_to_infinity(group, r))\\r\\ngoto err;\\r\\n} else {\\r\\nif (r_is_inverted)\\r\\nif (!EC_POINT_invert(group, r, ctx))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (tmp != NULL)\\r\\nEC_POINT_free(tmp);\\r\\nif (wsize != NULL)\\r\\nOPENSSL_free(wsize);\\r\\nif (wNAF_len != NULL)\\r\\nOPENSSL_free(wNAF_len);\\r\\nif (wNAF != NULL) {\\r\\nsigned char **w;\\r\\nfor (w = wNAF; *w != NULL; w++)\\r\\nOPENSSL_free(*w);\\r\\nOPENSSL_free(wNAF);\\r\\n}\\r\\nif (val != NULL) {\\r\\nfor (v = val; *v != NULL; v++)\\r\\nEC_POINT_clear_free(*v);\\r\\nOPENSSL_free(val);\\r\\n}\\r\\nif (val_sub != NULL) {\\r\\nOPENSSL_free(val_sub);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint ec_wNAF_precompute_mult(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nconst EC_POINT *generator;\\r\\nEC_POINT *tmp_point = NULL, *base = NULL, **var;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *order;\\r\\nsize_t i, bits, w, pre_points_per_block, blocksize, numblocks, num;\\r\\nEC_POINT **points = NULL;\\r\\nEC_PRE_COMP *pre_comp;\\r\\nint ret = 0;\\r\\nEC_EX_DATA_free_data(&group->extra_data, ec_pre_comp_dup,\\r\\nec_pre_comp_free, ec_pre_comp_clear_free);\\r\\nif ((pre_comp = ec_pre_comp_new(group)) == NULL)\\r\\nreturn 0;\\r\\ngenerator = EC_GROUP_get0_generator(group);\\r\\nif (generator == NULL) {\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNDEFINED_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\norder = BN_CTX_get(ctx);\\r\\nif (order == NULL)\\r\\ngoto err;\\r\\nif (!EC_GROUP_get_order(group, order, ctx))\\r\\ngoto err;\\r\\nif (BN_is_zero(order)) {\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, EC_R_UNKNOWN_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nbits = BN_num_bits(order);\\r\\nblocksize = 8;\\r\\nw = 4;\\r\\nif (EC_window_bits_for_scalar_size(bits) > w) {\\r\\nw = EC_window_bits_for_scalar_size(bits);\\r\\n}\\r\\nnumblocks = (bits + blocksize - 1) / blocksize;\\r\\npre_points_per_block = (size_t)1 << (w - 1);\\r\\nnum = pre_points_per_block * numblocks;\\r\\npoints = OPENSSL_malloc(sizeof(EC_POINT *) * (num + 1));\\r\\nif (!points) {\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nvar = points;\\r\\nvar[num] = NULL;\\r\\nfor (i = 0; i < num; i++) {\\r\\nif ((var[i] = EC_POINT_new(group)) == NULL) {\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!(tmp_point = EC_POINT_new(group)) || !(base = EC_POINT_new(group))) {\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_copy(base, generator))\\r\\ngoto err;\\r\\nfor (i = 0; i < numblocks; i++) {\\r\\nsize_t j;\\r\\nif (!EC_POINT_dbl(group, tmp_point, base, ctx))\\r\\ngoto err;\\r\\nif (!EC_POINT_copy(*var++, base))\\r\\ngoto err;\\r\\nfor (j = 1; j < pre_points_per_block; j++, var++) {\\r\\nif (!EC_POINT_add(group, *var, tmp_point, *(var - 1), ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (i < numblocks - 1) {\\r\\nsize_t k;\\r\\nif (blocksize <= 2) {\\r\\nECerr(EC_F_EC_WNAF_PRECOMPUTE_MULT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_dbl(group, base, tmp_point, ctx))\\r\\ngoto err;\\r\\nfor (k = 2; k < blocksize; k++) {\\r\\nif (!EC_POINT_dbl(group, base, base, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!EC_POINTs_make_affine(group, num, points, ctx))\\r\\ngoto err;\\r\\npre_comp->group = group;\\r\\npre_comp->blocksize = blocksize;\\r\\npre_comp->numblocks = numblocks;\\r\\npre_comp->w = w;\\r\\npre_comp->points = points;\\r\\npoints = NULL;\\r\\npre_comp->num = num;\\r\\nif (!EC_EX_DATA_set_data(&group->extra_data, pre_comp,\\r\\nec_pre_comp_dup, ec_pre_comp_free,\\r\\nec_pre_comp_clear_free))\\r\\ngoto err;\\r\\npre_comp = NULL;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (pre_comp)\\r\\nec_pre_comp_free(pre_comp);\\r\\nif (points) {\\r\\nEC_POINT **p;\\r\\nfor (p = points; *p != NULL; p++)\\r\\nEC_POINT_free(*p);\\r\\nOPENSSL_free(points);\\r\\n}\\r\\nif (tmp_point)\\r\\nEC_POINT_free(tmp_point);\\r\\nif (base)\\r\\nEC_POINT_free(base);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_wNAF_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nif (EC_EX_DATA_get_data\\r\\n(group->extra_data, ec_pre_comp_dup, ec_pre_comp_free,\\r\\nec_pre_comp_clear_free) != NULL)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecb_enc_c", "target": 0, "func": "const char *DES_options(void)\\r\\n{\\r\\nstatic int init = 1;\\r\\nstatic char buf[32];\\r\\nif (init) {\\r\\nconst char *ptr, *unroll, *risc, *size;\\r\\n#ifdef DES_PTR\\r\\nptr = \"ptr\";\\r\\n#else\\r\\nptr = \"idx\";\\r\\n#endif\\r\\n#if defined(DES_RISC1) || defined(DES_RISC2)\\r\\n# ifdef DES_RISC1\\r\\nrisc = \"risc1\";\\r\\n# endif\\r\\n# ifdef DES_RISC2\\r\\nrisc = \"risc2\";\\r\\n# endif\\r\\n#else\\r\\nrisc = \"cisc\";\\r\\n#endif\\r\\n#ifdef DES_UNROLL\\r\\nunroll = \"16\";\\r\\n#else\\r\\nunroll = \"2\";\\r\\n#endif\\r\\nif (sizeof(DES_LONG) != sizeof(long))\\r\\nsize = \"int\";\\r\\nelse\\r\\nsize = \"long\";\\r\\nBIO_snprintf(buf, sizeof buf, \"des(%s,%s,%s,%s)\", ptr, risc, unroll,\\r\\nsize);\\r\\ninit = 0;\\r\\n}\\r\\nreturn (buf);\\r\\n}\\r\\nvoid DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output,\\r\\nDES_key_schedule *ks, int enc)\\r\\n{\\r\\nregister DES_LONG l;\\r\\nDES_LONG ll[2];\\r\\nconst unsigned char *in = &(*input)[0];\\r\\nunsigned char *out = &(*output)[0];\\r\\nc2l(in, l);\\r\\nll[0] = l;\\r\\nc2l(in, l);\\r\\nll[1] = l;\\r\\nDES_encrypt1(ll, ks, enc);\\r\\nl = ll[0];\\r\\nl2c(l, out);\\r\\nl = ll[1];\\r\\nl2c(l, out);\\r\\nl = ll[0] = ll[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pkread_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nFILE *fp;\\r\\nEVP_PKEY *pkey;\\r\\nX509 *cert;\\r\\nSTACK_OF(X509) *ca = NULL;\\r\\nPKCS12 *p12;\\r\\nint i;\\r\\nif (argc != 4) {\\r\\nfprintf(stderr, \"Usage: pkread p12file password opfile\\n\");\\r\\nexit(1);\\r\\n}\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\nif (!(fp = fopen(argv[1], \"rb\"))) {\\r\\nfprintf(stderr, \"Error opening file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\np12 = d2i_PKCS12_fp(fp, NULL);\\r\\nfclose(fp);\\r\\nif (!p12) {\\r\\nfprintf(stderr, \"Error reading PKCS#12 file\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\nif (!PKCS12_parse(p12, argv[2], &pkey, &cert, &ca)) {\\r\\nfprintf(stderr, \"Error parsing PKCS#12 file\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\nPKCS12_free(p12);\\r\\nif (!(fp = fopen(argv[3], \"w\"))) {\\r\\nfprintf(stderr, \"Error opening file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\nif (pkey) {\\r\\nfprintf(fp, \"***Private Key***\\n\");\\r\\nPEM_write_PrivateKey(fp, pkey, NULL, NULL, 0, NULL, NULL);\\r\\n}\\r\\nif (cert) {\\r\\nfprintf(fp, \"***User Certificate***\\n\");\\r\\nPEM_write_X509_AUX(fp, cert);\\r\\n}\\r\\nif (ca && sk_X509_num(ca)) {\\r\\nfprintf(fp, \"***Other Certificates***\\n\");\\r\\nfor (i = 0; i < sk_X509_num(ca); i++)\\r\\nPEM_write_X509_AUX(fp, sk_X509_value(ca, i));\\r\\n}\\r\\nfclose(fp);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_ameth_c", "target": 0, "func": "static int dsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\\r\\n{\\r\\nconst unsigned char *p, *pm;\\r\\nint pklen, pmlen;\\r\\nint ptype;\\r\\nvoid *pval;\\r\\nASN1_STRING *pstr;\\r\\nX509_ALGOR *palg;\\r\\nASN1_INTEGER *public_key = NULL;\\r\\nDSA *dsa = NULL;\\r\\nif (!X509_PUBKEY_get0_param(NULL, &p, &pklen, &palg, pubkey))\\r\\nreturn 0;\\r\\nX509_ALGOR_get0(NULL, &ptype, &pval, palg);\\r\\nif (ptype == V_ASN1_SEQUENCE) {\\r\\npstr = pval;\\r\\npm = pstr->data;\\r\\npmlen = pstr->length;\\r\\nif (!(dsa = d2i_DSAparams(NULL, &pm, pmlen))) {\\r\\nDSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n} else if ((ptype == V_ASN1_NULL) || (ptype == V_ASN1_UNDEF)) {\\r\\nif (!(dsa = DSA_new())) {\\r\\nDSAerr(DSA_F_DSA_PUB_DECODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nDSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_PARAMETER_ENCODING_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!(public_key = d2i_ASN1_INTEGER(NULL, &p, pklen))) {\\r\\nDSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!(dsa->pub_key = ASN1_INTEGER_to_BN(public_key, NULL))) {\\r\\nDSAerr(DSA_F_DSA_PUB_DECODE, DSA_R_BN_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nASN1_INTEGER_free(public_key);\\r\\nEVP_PKEY_assign_DSA(pkey, dsa);\\r\\nreturn 1;\\r\\nerr:\\r\\nif (public_key)\\r\\nASN1_INTEGER_free(public_key);\\r\\nif (dsa)\\r\\nDSA_free(dsa);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\\r\\n{\\r\\nDSA *dsa;\\r\\nvoid *pval = NULL;\\r\\nint ptype;\\r\\nunsigned char *penc = NULL;\\r\\nint penclen;\\r\\ndsa = pkey->pkey.dsa;\\r\\nif (pkey->save_parameters && dsa->p && dsa->q && dsa->g) {\\r\\nASN1_STRING *str;\\r\\nstr = ASN1_STRING_new();\\r\\nstr->length = i2d_DSAparams(dsa, &str->data);\\r\\nif (str->length <= 0) {\\r\\nDSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npval = str;\\r\\nptype = V_ASN1_SEQUENCE;\\r\\n} else\\r\\nptype = V_ASN1_UNDEF;\\r\\ndsa->write_params = 0;\\r\\npenclen = i2d_DSAPublicKey(dsa, &penc);\\r\\nif (penclen <= 0) {\\r\\nDSAerr(DSA_F_DSA_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(EVP_PKEY_DSA),\\r\\nptype, pval, penc, penclen))\\r\\nreturn 1;\\r\\nerr:\\r\\nif (penc)\\r\\nOPENSSL_free(penc);\\r\\nif (pval)\\r\\nASN1_STRING_free(pval);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nconst unsigned char *p, *pm;\\r\\nint pklen, pmlen;\\r\\nint ptype;\\r\\nvoid *pval;\\r\\nASN1_STRING *pstr;\\r\\nX509_ALGOR *palg;\\r\\nASN1_INTEGER *privkey = NULL;\\r\\nBN_CTX *ctx = NULL;\\r\\nSTACK_OF(ASN1_TYPE) *ndsa = NULL;\\r\\nDSA *dsa = NULL;\\r\\nif (!PKCS8_pkey_get0(NULL, &p, &pklen, &palg, p8))\\r\\nreturn 0;\\r\\nX509_ALGOR_get0(NULL, &ptype, &pval, palg);\\r\\nif (*p == (V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED)) {\\r\\nASN1_TYPE *t1, *t2;\\r\\nif (!(ndsa = d2i_ASN1_SEQUENCE_ANY(NULL, &p, pklen)))\\r\\ngoto decerr;\\r\\nif (sk_ASN1_TYPE_num(ndsa) != 2)\\r\\ngoto decerr;\\r\\nt1 = sk_ASN1_TYPE_value(ndsa, 0);\\r\\nt2 = sk_ASN1_TYPE_value(ndsa, 1);\\r\\nif (t1->type == V_ASN1_SEQUENCE) {\\r\\np8->broken = PKCS8_EMBEDDED_PARAM;\\r\\npval = t1->value.ptr;\\r\\n} else if (ptype == V_ASN1_SEQUENCE)\\r\\np8->broken = PKCS8_NS_DB;\\r\\nelse\\r\\ngoto decerr;\\r\\nif (t2->type != V_ASN1_INTEGER)\\r\\ngoto decerr;\\r\\nprivkey = t2->value.integer;\\r\\n} else {\\r\\nconst unsigned char *q = p;\\r\\nif (!(privkey = d2i_ASN1_INTEGER(NULL, &p, pklen)))\\r\\ngoto decerr;\\r\\nif (privkey->type == V_ASN1_NEG_INTEGER) {\\r\\np8->broken = PKCS8_NEG_PRIVKEY;\\r\\nASN1_INTEGER_free(privkey);\\r\\nif (!(privkey = d2i_ASN1_UINTEGER(NULL, &q, pklen)))\\r\\ngoto decerr;\\r\\n}\\r\\nif (ptype != V_ASN1_SEQUENCE)\\r\\ngoto decerr;\\r\\n}\\r\\npstr = pval;\\r\\npm = pstr->data;\\r\\npmlen = pstr->length;\\r\\nif (!(dsa = d2i_DSAparams(NULL, &pm, pmlen)))\\r\\ngoto decerr;\\r\\nif (!(dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL))) {\\r\\nDSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nif (!(dsa->pub_key = BN_new())) {\\r\\nDSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto dsaerr;\\r\\n}\\r\\nif (!(ctx = BN_CTX_new())) {\\r\\nDSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto dsaerr;\\r\\n}\\r\\nif (!BN_mod_exp(dsa->pub_key, dsa->g, dsa->priv_key, dsa->p, ctx)) {\\r\\nDSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);\\r\\ngoto dsaerr;\\r\\n}\\r\\nEVP_PKEY_assign_DSA(pkey, dsa);\\r\\nBN_CTX_free(ctx);\\r\\nif (ndsa)\\r\\nsk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);\\r\\nelse\\r\\nASN1_INTEGER_free(privkey);\\r\\nreturn 1;\\r\\ndecerr:\\r\\nDSAerr(DSA_F_DSA_PRIV_DECODE, EVP_R_DECODE_ERROR);\\r\\ndsaerr:\\r\\nBN_CTX_free(ctx);\\r\\nif (privkey)\\r\\nASN1_INTEGER_free(privkey);\\r\\nsk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);\\r\\nDSA_free(dsa);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\\r\\n{\\r\\nASN1_STRING *params = NULL;\\r\\nASN1_INTEGER *prkey = NULL;\\r\\nunsigned char *dp = NULL;\\r\\nint dplen;\\r\\nif (!pkey->pkey.dsa || !pkey->pkey.dsa->priv_key) {\\r\\nDSAerr(DSA_F_DSA_PRIV_ENCODE, DSA_R_MISSING_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\nparams = ASN1_STRING_new();\\r\\nif (!params) {\\r\\nDSAerr(DSA_F_DSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nparams->length = i2d_DSAparams(pkey->pkey.dsa, &params->data);\\r\\nif (params->length <= 0) {\\r\\nDSAerr(DSA_F_DSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nparams->type = V_ASN1_SEQUENCE;\\r\\nprkey = BN_to_ASN1_INTEGER(pkey->pkey.dsa->priv_key, NULL);\\r\\nif (!prkey) {\\r\\nDSAerr(DSA_F_DSA_PRIV_ENCODE, DSA_R_BN_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndplen = i2d_ASN1_INTEGER(prkey, &dp);\\r\\nASN1_INTEGER_free(prkey);\\r\\nif (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_dsa), 0,\\r\\nV_ASN1_SEQUENCE, params, dp, dplen))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nif (dp != NULL)\\r\\nOPENSSL_free(dp);\\r\\nif (params != NULL)\\r\\nASN1_STRING_free(params);\\r\\nif (prkey != NULL)\\r\\nASN1_INTEGER_free(prkey);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int int_dsa_size(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn (DSA_size(pkey->pkey.dsa));\\r\\n}\\r\\nstatic int dsa_bits(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn BN_num_bits(pkey->pkey.dsa->p);\\r\\n}\\r\\nstatic int dsa_missing_parameters(const EVP_PKEY *pkey)\\r\\n{\\r\\nDSA *dsa;\\r\\ndsa = pkey->pkey.dsa;\\r\\nif ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dsa_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)\\r\\n{\\r\\nBIGNUM *a;\\r\\nif ((a = BN_dup(from->pkey.dsa->p)) == NULL)\\r\\nreturn 0;\\r\\nif (to->pkey.dsa->p != NULL)\\r\\nBN_free(to->pkey.dsa->p);\\r\\nto->pkey.dsa->p = a;\\r\\nif ((a = BN_dup(from->pkey.dsa->q)) == NULL)\\r\\nreturn 0;\\r\\nif (to->pkey.dsa->q != NULL)\\r\\nBN_free(to->pkey.dsa->q);\\r\\nto->pkey.dsa->q = a;\\r\\nif ((a = BN_dup(from->pkey.dsa->g)) == NULL)\\r\\nreturn 0;\\r\\nif (to->pkey.dsa->g != NULL)\\r\\nBN_free(to->pkey.dsa->g);\\r\\nto->pkey.dsa->g = a;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int dsa_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nif (BN_cmp(a->pkey.dsa->p, b->pkey.dsa->p) ||\\r\\nBN_cmp(a->pkey.dsa->q, b->pkey.dsa->q) ||\\r\\nBN_cmp(a->pkey.dsa->g, b->pkey.dsa->g))\\r\\nreturn 0;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nstatic int dsa_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nif (BN_cmp(b->pkey.dsa->pub_key, a->pkey.dsa->pub_key) != 0)\\r\\nreturn 0;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nstatic void int_dsa_free(EVP_PKEY *pkey)\\r\\n{\\r\\nDSA_free(pkey->pkey.dsa);\\r\\n}\\r\\nstatic void update_buflen(const BIGNUM *b, size_t *pbuflen)\\r\\n{\\r\\nsize_t i;\\r\\nif (!b)\\r\\nreturn;\\r\\nif (*pbuflen < (i = (size_t)BN_num_bytes(b)))\\r\\n*pbuflen = i;\\r\\n}\\r\\nstatic int do_dsa_print(BIO *bp, const DSA *x, int off, int ptype)\\r\\n{\\r\\nunsigned char *m = NULL;\\r\\nint ret = 0;\\r\\nsize_t buf_len = 0;\\r\\nconst char *ktype = NULL;\\r\\nconst BIGNUM *priv_key, *pub_key;\\r\\nif (ptype == 2)\\r\\npriv_key = x->priv_key;\\r\\nelse\\r\\npriv_key = NULL;\\r\\nif (ptype > 0)\\r\\npub_key = x->pub_key;\\r\\nelse\\r\\npub_key = NULL;\\r\\nif (ptype == 2)\\r\\nktype = \"Private-Key\";\\r\\nelse if (ptype == 1)\\r\\nktype = \"Public-Key\";\\r\\nelse\\r\\nktype = \"DSA-Parameters\";\\r\\nupdate_buflen(x->p, &buf_len);\\r\\nupdate_buflen(x->q, &buf_len);\\r\\nupdate_buflen(x->g, &buf_len);\\r\\nupdate_buflen(priv_key, &buf_len);\\r\\nupdate_buflen(pub_key, &buf_len);\\r\\nm = (unsigned char *)OPENSSL_malloc(buf_len + 10);\\r\\nif (m == NULL) {\\r\\nDSAerr(DSA_F_DO_DSA_PRINT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (priv_key) {\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"%s: (%d bit)\\n\", ktype, BN_num_bits(x->p))\\r\\n<= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_bn_print(bp, \"priv:\", priv_key, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"pub: \", pub_key, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"P: \", x->p, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"Q: \", x->q, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"G: \", x->g, m, off))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (m != NULL)\\r\\nOPENSSL_free(m);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int dsa_param_decode(EVP_PKEY *pkey,\\r\\nconst unsigned char **pder, int derlen)\\r\\n{\\r\\nDSA *dsa;\\r\\nif (!(dsa = d2i_DSAparams(NULL, pder, derlen))) {\\r\\nDSAerr(DSA_F_DSA_PARAM_DECODE, ERR_R_DSA_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_assign_DSA(pkey, dsa);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int dsa_param_encode(const EVP_PKEY *pkey, unsigned char **pder)\\r\\n{\\r\\nreturn i2d_DSAparams(pkey->pkey.dsa, pder);\\r\\n}\\r\\nstatic int dsa_param_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_dsa_print(bp, pkey->pkey.dsa, indent, 0);\\r\\n}\\r\\nstatic int dsa_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_dsa_print(bp, pkey->pkey.dsa, indent, 1);\\r\\n}\\r\\nstatic int dsa_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_dsa_print(bp, pkey->pkey.dsa, indent, 2);\\r\\n}\\r\\nstatic int old_dsa_priv_decode(EVP_PKEY *pkey,\\r\\nconst unsigned char **pder, int derlen)\\r\\n{\\r\\nDSA *dsa;\\r\\nif (!(dsa = d2i_DSAPrivateKey(NULL, pder, derlen))) {\\r\\nDSAerr(DSA_F_OLD_DSA_PRIV_DECODE, ERR_R_DSA_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_assign_DSA(pkey, dsa);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int old_dsa_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)\\r\\n{\\r\\nreturn i2d_DSAPrivateKey(pkey->pkey.dsa, pder);\\r\\n}\\r\\nstatic int dsa_sig_print(BIO *bp, const X509_ALGOR *sigalg,\\r\\nconst ASN1_STRING *sig, int indent, ASN1_PCTX *pctx)\\r\\n{\\r\\nDSA_SIG *dsa_sig;\\r\\nconst unsigned char *p;\\r\\nif (!sig) {\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\nreturn 0;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\np = sig->data;\\r\\ndsa_sig = d2i_DSA_SIG(NULL, &p, sig->length);\\r\\nif (dsa_sig) {\\r\\nint rv = 0;\\r\\nsize_t buf_len = 0;\\r\\nunsigned char *m = NULL;\\r\\nupdate_buflen(dsa_sig->r, &buf_len);\\r\\nupdate_buflen(dsa_sig->s, &buf_len);\\r\\nm = OPENSSL_malloc(buf_len + 10);\\r\\nif (m == NULL) {\\r\\nDSAerr(DSA_F_DSA_SIG_PRINT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_write(bp, \"\\n\", 1) != 1)\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"r: \", dsa_sig->r, m, indent))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"s: \", dsa_sig->s, m, indent))\\r\\ngoto err;\\r\\nrv = 1;\\r\\nerr:\\r\\nif (m)\\r\\nOPENSSL_free(m);\\r\\nDSA_SIG_free(dsa_sig);\\r\\nreturn rv;\\r\\n}\\r\\nreturn X509_signature_dump(bp, sig, indent);\\r\\n}\\r\\nstatic int dsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)\\r\\n{\\r\\nswitch (op) {\\r\\ncase ASN1_PKEY_CTRL_PKCS7_SIGN:\\r\\nif (arg1 == 0) {\\r\\nint snid, hnid;\\r\\nX509_ALGOR *alg1, *alg2;\\r\\nPKCS7_SIGNER_INFO_get0_algs(arg2, NULL, &alg1, &alg2);\\r\\nif (alg1 == NULL || alg1->algorithm == NULL)\\r\\nreturn -1;\\r\\nhnid = OBJ_obj2nid(alg1->algorithm);\\r\\nif (hnid == NID_undef)\\r\\nreturn -1;\\r\\nif (!OBJ_find_sigid_by_algs(&snid, hnid, EVP_PKEY_id(pkey)))\\r\\nreturn -1;\\r\\nX509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);\\r\\n}\\r\\nreturn 1;\\r\\n#ifndef OPENSSL_NO_CMS\\r\\ncase ASN1_PKEY_CTRL_CMS_SIGN:\\r\\nif (arg1 == 0) {\\r\\nint snid, hnid;\\r\\nX509_ALGOR *alg1, *alg2;\\r\\nCMS_SignerInfo_get0_algs(arg2, NULL, NULL, &alg1, &alg2);\\r\\nif (alg1 == NULL || alg1->algorithm == NULL)\\r\\nreturn -1;\\r\\nhnid = OBJ_obj2nid(alg1->algorithm);\\r\\nif (hnid == NID_undef)\\r\\nreturn -1;\\r\\nif (!OBJ_find_sigid_by_algs(&snid, hnid, EVP_PKEY_id(pkey)))\\r\\nreturn -1;\\r\\nX509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);\\r\\n}\\r\\nreturn 1;\\r\\ncase ASN1_PKEY_CTRL_CMS_RI_TYPE:\\r\\n*(int *)arg2 = CMS_RECIPINFO_NONE;\\r\\nreturn 1;\\r\\n#endif\\r\\ncase ASN1_PKEY_CTRL_DEFAULT_MD_NID:\\r\\n*(int *)arg2 = NID_sha256;\\r\\nreturn 2;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_x931_c", "target": 0, "func": "int RSA_padding_add_X931(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nint j;\\r\\nunsigned char *p;\\r\\nj = tlen - flen - 2;\\r\\nif (j < 0) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_X931, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn -1;\\r\\n}\\r\\np = (unsigned char *)to;\\r\\nif (j == 0)\\r\\n*p++ = 0x6A;\\r\\nelse {\\r\\n*p++ = 0x6B;\\r\\nif (j > 1) {\\r\\nmemset(p, 0xBB, j - 1);\\r\\np += j - 1;\\r\\n}\\r\\n*p++ = 0xBA;\\r\\n}\\r\\nmemcpy(p, from, (unsigned int)flen);\\r\\np += flen;\\r\\n*p = 0xCC;\\r\\nreturn (1);\\r\\n}\\r\\nint RSA_padding_check_X931(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num)\\r\\n{\\r\\nint i = 0, j;\\r\\nconst unsigned char *p;\\r\\np = from;\\r\\nif ((num != flen) || ((*p != 0x6A) && (*p != 0x6B))) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_HEADER);\\r\\nreturn -1;\\r\\n}\\r\\nif (*p++ == 0x6B) {\\r\\nj = flen - 3;\\r\\nfor (i = 0; i < j; i++) {\\r\\nunsigned char c = *p++;\\r\\nif (c == 0xBA)\\r\\nbreak;\\r\\nif (c != 0xBB) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_PADDING);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nj -= i;\\r\\nif (i == 0) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_PADDING);\\r\\nreturn -1;\\r\\n}\\r\\n} else\\r\\nj = flen - 2;\\r\\nif (p[j] != 0xCC) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_X931, RSA_R_INVALID_TRAILER);\\r\\nreturn -1;\\r\\n}\\r\\nmemcpy(to, p, (unsigned int)j);\\r\\nreturn (j);\\r\\n}\\r\\nint RSA_X931_hash_id(int nid)\\r\\n{\\r\\nswitch (nid) {\\r\\ncase NID_sha1:\\r\\nreturn 0x33;\\r\\ncase NID_sha256:\\r\\nreturn 0x34;\\r\\ncase NID_sha384:\\r\\nreturn 0x36;\\r\\ncase NID_sha512:\\r\\nreturn 0x35;\\r\\n}\\r\\nreturn -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rand_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i, r, ret = 1;\\r\\nint badopt;\\r\\nchar *outfile = NULL;\\r\\nchar *inrand = NULL;\\r\\nint base64 = 0;\\r\\nint hex = 0;\\r\\nBIO *out = NULL;\\r\\nint num = -1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto err;\\r\\nbadopt = 0;\\r\\ni = 0;\\r\\nwhile (!badopt && argv[++i] != NULL) {\\r\\nif (strcmp(argv[i], \"-out\") == 0) {\\r\\nif ((argv[i + 1] != NULL) && (outfile == NULL))\\r\\noutfile = argv[++i];\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(argv[i], \"-engine\") == 0) {\\r\\nif ((argv[i + 1] != NULL) && (engine == NULL))\\r\\nengine = argv[++i];\\r\\nelse\\r\\nbadopt = 1;\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(argv[i], \"-rand\") == 0) {\\r\\nif ((argv[i + 1] != NULL) && (inrand == NULL))\\r\\ninrand = argv[++i];\\r\\nelse\\r\\nbadopt = 1;\\r\\n} else if (strcmp(argv[i], \"-base64\") == 0) {\\r\\nif (!base64)\\r\\nbase64 = 1;\\r\\nelse\\r\\nbadopt = 1;\\r\\n} else if (strcmp(argv[i], \"-hex\") == 0) {\\r\\nif (!hex)\\r\\nhex = 1;\\r\\nelse\\r\\nbadopt = 1;\\r\\n} else if (isdigit((unsigned char)argv[i][0])) {\\r\\nif (num < 0) {\\r\\nr = sscanf(argv[i], \"%d\", &num);\\r\\nif (r == 0 || num < 0)\\r\\nbadopt = 1;\\r\\n} else\\r\\nbadopt = 1;\\r\\n} else\\r\\nbadopt = 1;\\r\\n}\\r\\nif (hex && base64)\\r\\nbadopt = 1;\\r\\nif (num < 0)\\r\\nbadopt = 1;\\r\\nif (badopt) {\\r\\nBIO_printf(bio_err, \"Usage: rand [options] num\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-out file - write to file\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e - use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \"-rand file%cfile%c... - seed PRNG from files\\n\",\\r\\nLIST_SEPARATOR_CHAR, LIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err, \"-base64 - base64 encode output\\n\");\\r\\nBIO_printf(bio_err, \"-hex - hex encode output\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nout = BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\ngoto err;\\r\\nif (outfile != NULL)\\r\\nr = BIO_write_filename(out, outfile);\\r\\nelse {\\r\\nr = BIO_set_fp(out, stdout, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (r <= 0)\\r\\ngoto err;\\r\\nif (base64) {\\r\\nBIO *b64 = BIO_new(BIO_f_base64());\\r\\nif (b64 == NULL)\\r\\ngoto err;\\r\\nout = BIO_push(b64, out);\\r\\n}\\r\\nwhile (num > 0) {\\r\\nunsigned char buf[4096];\\r\\nint chunk;\\r\\nchunk = num;\\r\\nif (chunk > (int)sizeof(buf))\\r\\nchunk = sizeof buf;\\r\\nr = RAND_bytes(buf, chunk);\\r\\nif (r <= 0)\\r\\ngoto err;\\r\\nif (!hex)\\r\\nBIO_write(out, buf, chunk);\\r\\nelse {\\r\\nfor (i = 0; i < chunk; i++)\\r\\nBIO_printf(out, \"%02x\", buf[i]);\\r\\n}\\r\\nnum -= chunk;\\r\\n}\\r\\nif (hex)\\r\\nBIO_puts(out, \"\\n\");\\r\\n(void)BIO_flush(out);\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nret = 0;\\r\\nerr:\\r\\nERR_print_errors(bio_err);\\r\\nif (out)\\r\\nBIO_free_all(out);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_kdf_c", "target": 0, "func": "static int skip_asn1(unsigned char **pp, long *plen, int exptag)\\r\\n{\\r\\nconst unsigned char *q = *pp;\\r\\nint i, tag, xclass;\\r\\nlong tmplen;\\r\\ni = ASN1_get_object(&q, &tmplen, &tag, &xclass, *plen);\\r\\nif (i & 0x80)\\r\\nreturn 0;\\r\\nif (tag != exptag || xclass != V_ASN1_UNIVERSAL)\\r\\nreturn 0;\\r\\nif (tag == V_ASN1_OBJECT)\\r\\nq += tmplen;\\r\\n*plen -= q - *pp;\\r\\n*pp = (unsigned char *)q;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int dh_sharedinfo_encode(unsigned char **pder, unsigned char **pctr,\\r\\nASN1_OBJECT *key_oid, size_t outlen,\\r\\nconst unsigned char *ukm, size_t ukmlen)\\r\\n{\\r\\nunsigned char *p;\\r\\nint derlen;\\r\\nlong tlen;\\r\\nstatic unsigned char ctr[4] = { 0xF3, 0x17, 0x22, 0x53 };\\r\\nX509_ALGOR atmp;\\r\\nASN1_OCTET_STRING ctr_oct, ukm_oct, *pukm_oct;\\r\\nASN1_TYPE ctr_atype;\\r\\nif (ukmlen > DH_KDF_MAX || outlen > DH_KDF_MAX)\\r\\nreturn 0;\\r\\nctr_oct.data = ctr;\\r\\nctr_oct.length = 4;\\r\\nctr_oct.flags = 0;\\r\\nctr_oct.type = V_ASN1_OCTET_STRING;\\r\\nctr_atype.type = V_ASN1_OCTET_STRING;\\r\\nctr_atype.value.octet_string = &ctr_oct;\\r\\natmp.algorithm = key_oid;\\r\\natmp.parameter = &ctr_atype;\\r\\nif (ukm) {\\r\\nukm_oct.type = V_ASN1_OCTET_STRING;\\r\\nukm_oct.flags = 0;\\r\\nukm_oct.data = (unsigned char *)ukm;\\r\\nukm_oct.length = ukmlen;\\r\\npukm_oct = &ukm_oct;\\r\\n} else\\r\\npukm_oct = NULL;\\r\\nderlen = CMS_SharedInfo_encode(pder, &atmp, pukm_oct, outlen);\\r\\nif (derlen <= 0)\\r\\nreturn 0;\\r\\np = *pder;\\r\\ntlen = derlen;\\r\\nif (!skip_asn1(&p, &tlen, V_ASN1_SEQUENCE))\\r\\nreturn 0;\\r\\nif (!skip_asn1(&p, &tlen, V_ASN1_SEQUENCE))\\r\\nreturn 0;\\r\\nif (!skip_asn1(&p, &tlen, V_ASN1_OBJECT))\\r\\nreturn 0;\\r\\nif (!skip_asn1(&p, &tlen, V_ASN1_OCTET_STRING))\\r\\nreturn 0;\\r\\nif (CRYPTO_memcmp(p, ctr, 4))\\r\\nreturn 0;\\r\\n*pctr = p;\\r\\nreturn derlen;\\r\\n}\\r\\nint DH_KDF_X9_42(unsigned char *out, size_t outlen,\\r\\nconst unsigned char *Z, size_t Zlen,\\r\\nASN1_OBJECT *key_oid,\\r\\nconst unsigned char *ukm, size_t ukmlen, const EVP_MD *md)\\r\\n{\\r\\nEVP_MD_CTX mctx;\\r\\nint rv = 0;\\r\\nunsigned int i;\\r\\nsize_t mdlen;\\r\\nunsigned char *der = NULL, *ctr;\\r\\nint derlen;\\r\\nif (Zlen > DH_KDF_MAX)\\r\\nreturn 0;\\r\\nmdlen = EVP_MD_size(md);\\r\\nEVP_MD_CTX_init(&mctx);\\r\\nderlen = dh_sharedinfo_encode(&der, &ctr, key_oid, outlen, ukm, ukmlen);\\r\\nif (derlen == 0)\\r\\ngoto err;\\r\\nfor (i = 1;; i++) {\\r\\nunsigned char mtmp[EVP_MAX_MD_SIZE];\\r\\nEVP_DigestInit_ex(&mctx, md, NULL);\\r\\nif (!EVP_DigestUpdate(&mctx, Z, Zlen))\\r\\ngoto err;\\r\\nctr[3] = i & 0xFF;\\r\\nctr[2] = (i >> 8) & 0xFF;\\r\\nctr[1] = (i >> 16) & 0xFF;\\r\\nctr[0] = (i >> 24) & 0xFF;\\r\\nif (!EVP_DigestUpdate(&mctx, der, derlen))\\r\\ngoto err;\\r\\nif (outlen >= mdlen) {\\r\\nif (!EVP_DigestFinal(&mctx, out, NULL))\\r\\ngoto err;\\r\\noutlen -= mdlen;\\r\\nif (outlen == 0)\\r\\nbreak;\\r\\nout += mdlen;\\r\\n} else {\\r\\nif (!EVP_DigestFinal(&mctx, mtmp, NULL))\\r\\ngoto err;\\r\\nmemcpy(out, mtmp, outlen);\\r\\nOPENSSL_cleanse(mtmp, mdlen);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nrv = 1;\\r\\nerr:\\r\\nif (der)\\r\\nOPENSSL_free(der);\\r\\nEVP_MD_CTX_cleanup(&mctx);\\r\\nreturn rv;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_vpm_c", "target": 0, "func": "static char *str_copy(const char *s)\\r\\n{\\r\\nreturn OPENSSL_strdup(s);\\r\\n}\\r\\nstatic void str_free(char *s)\\r\\n{\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nstatic int int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\\r\\nconst char *name, size_t namelen)\\r\\n{\\r\\nchar *copy;\\r\\nif (namelen == 0)\\r\\nnamelen = name ? strlen(name) : 0;\\r\\nelse if (name && memchr(name, '\\0', namelen > 1 ? namelen - 1 : namelen))\\r\\nreturn 0;\\r\\nif (name && name[namelen - 1] == '\\0')\\r\\n--namelen;\\r\\nif (mode == SET_HOST && id->hosts) {\\r\\nstring_stack_free(id->hosts);\\r\\nid->hosts = NULL;\\r\\n}\\r\\nif (name == NULL || namelen == 0)\\r\\nreturn 1;\\r\\ncopy = BUF_strndup(name, namelen);\\r\\nif (copy == NULL)\\r\\nreturn 0;\\r\\nif (id->hosts == NULL &&\\r\\n(id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\\r\\nOPENSSL_free(copy);\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\\r\\nOPENSSL_free(copy);\\r\\nif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\\r\\nsk_OPENSSL_STRING_free(id->hosts);\\r\\nid->hosts = NULL;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void x509_verify_param_zero(X509_VERIFY_PARAM *param)\\r\\n{\\r\\nX509_VERIFY_PARAM_ID *paramid;\\r\\nif (!param)\\r\\nreturn;\\r\\nparam->name = NULL;\\r\\nparam->purpose = 0;\\r\\nparam->trust = 0;\\r\\nparam->inh_flags = 0;\\r\\nparam->flags = 0;\\r\\nparam->depth = -1;\\r\\nif (param->policies) {\\r\\nsk_ASN1_OBJECT_pop_free(param->policies, ASN1_OBJECT_free);\\r\\nparam->policies = NULL;\\r\\n}\\r\\nparamid = param->id;\\r\\nif (paramid->hosts) {\\r\\nstring_stack_free(paramid->hosts);\\r\\nparamid->hosts = NULL;\\r\\n}\\r\\nif (paramid->peername)\\r\\nOPENSSL_free(paramid->peername);\\r\\nif (paramid->email) {\\r\\nOPENSSL_free(paramid->email);\\r\\nparamid->email = NULL;\\r\\nparamid->emaillen = 0;\\r\\n}\\r\\nif (paramid->ip) {\\r\\nOPENSSL_free(paramid->ip);\\r\\nparamid->ip = NULL;\\r\\nparamid->iplen = 0;\\r\\n}\\r\\n}\\r\\nX509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void)\\r\\n{\\r\\nX509_VERIFY_PARAM *param;\\r\\nX509_VERIFY_PARAM_ID *paramid;\\r\\nparam = OPENSSL_malloc(sizeof(X509_VERIFY_PARAM));\\r\\nif (!param)\\r\\nreturn NULL;\\r\\nparamid = OPENSSL_malloc(sizeof(X509_VERIFY_PARAM));\\r\\nif (!paramid) {\\r\\nOPENSSL_free(param);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(param, 0, sizeof(X509_VERIFY_PARAM));\\r\\nmemset(paramid, 0, sizeof(X509_VERIFY_PARAM_ID));\\r\\nparam->id = paramid;\\r\\nx509_verify_param_zero(param);\\r\\nreturn param;\\r\\n}\\r\\nvoid X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param)\\r\\n{\\r\\nx509_verify_param_zero(param);\\r\\nOPENSSL_free(param->id);\\r\\nOPENSSL_free(param);\\r\\n}\\r\\nint X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *dest,\\r\\nconst X509_VERIFY_PARAM *src)\\r\\n{\\r\\nunsigned long inh_flags;\\r\\nint to_default, to_overwrite;\\r\\nX509_VERIFY_PARAM_ID *id;\\r\\nif (!src)\\r\\nreturn 1;\\r\\nid = src->id;\\r\\ninh_flags = dest->inh_flags | src->inh_flags;\\r\\nif (inh_flags & X509_VP_FLAG_ONCE)\\r\\ndest->inh_flags = 0;\\r\\nif (inh_flags & X509_VP_FLAG_LOCKED)\\r\\nreturn 1;\\r\\nif (inh_flags & X509_VP_FLAG_DEFAULT)\\r\\nto_default = 1;\\r\\nelse\\r\\nto_default = 0;\\r\\nif (inh_flags & X509_VP_FLAG_OVERWRITE)\\r\\nto_overwrite = 1;\\r\\nelse\\r\\nto_overwrite = 0;\\r\\nx509_verify_param_copy(purpose, 0);\\r\\nx509_verify_param_copy(trust, 0);\\r\\nx509_verify_param_copy(depth, -1);\\r\\nif (to_overwrite || !(dest->flags & X509_V_FLAG_USE_CHECK_TIME)) {\\r\\ndest->check_time = src->check_time;\\r\\ndest->flags &= ~X509_V_FLAG_USE_CHECK_TIME;\\r\\n}\\r\\nif (inh_flags & X509_VP_FLAG_RESET_FLAGS)\\r\\ndest->flags = 0;\\r\\ndest->flags |= src->flags;\\r\\nif (test_x509_verify_param_copy(policies, NULL)) {\\r\\nif (!X509_VERIFY_PARAM_set1_policies(dest, src->policies))\\r\\nreturn 0;\\r\\n}\\r\\nif (test_x509_verify_param_copy_id(hosts, NULL)) {\\r\\nif (dest->id->hosts) {\\r\\nstring_stack_free(dest->id->hosts);\\r\\ndest->id->hosts = NULL;\\r\\n}\\r\\nif (id->hosts) {\\r\\ndest->id->hosts =\\r\\nsk_OPENSSL_STRING_deep_copy(id->hosts, str_copy, str_free);\\r\\nif (dest->id->hosts == NULL)\\r\\nreturn 0;\\r\\ndest->id->hostflags = id->hostflags;\\r\\n}\\r\\n}\\r\\nif (test_x509_verify_param_copy_id(email, NULL)) {\\r\\nif (!X509_VERIFY_PARAM_set1_email(dest, id->email, id->emaillen))\\r\\nreturn 0;\\r\\n}\\r\\nif (test_x509_verify_param_copy_id(ip, NULL)) {\\r\\nif (!X509_VERIFY_PARAM_set1_ip(dest, id->ip, id->iplen))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint X509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to,\\r\\nconst X509_VERIFY_PARAM *from)\\r\\n{\\r\\nunsigned long save_flags = to->inh_flags;\\r\\nint ret;\\r\\nto->inh_flags |= X509_VP_FLAG_DEFAULT;\\r\\nret = X509_VERIFY_PARAM_inherit(to, from);\\r\\nto->inh_flags = save_flags;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int int_x509_param_set1(char **pdest, size_t *pdestlen,\\r\\nconst char *src, size_t srclen)\\r\\n{\\r\\nvoid *tmp;\\r\\nif (src) {\\r\\nif (srclen == 0) {\\r\\ntmp = BUF_strdup(src);\\r\\nsrclen = strlen(src);\\r\\n} else\\r\\ntmp = BUF_memdup(src, srclen);\\r\\nif (!tmp)\\r\\nreturn 0;\\r\\n} else {\\r\\ntmp = NULL;\\r\\nsrclen = 0;\\r\\n}\\r\\nif (*pdest)\\r\\nOPENSSL_free(*pdest);\\r\\n*pdest = tmp;\\r\\nif (pdestlen)\\r\\n*pdestlen = srclen;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param, const char *name)\\r\\n{\\r\\nif (param->name)\\r\\nOPENSSL_free(param->name);\\r\\nparam->name = BUF_strdup(name);\\r\\nif (param->name)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param, unsigned long flags)\\r\\n{\\r\\nparam->flags |= flags;\\r\\nif (flags & X509_V_FLAG_POLICY_MASK)\\r\\nparam->flags |= X509_V_FLAG_POLICY_CHECK;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param,\\r\\nunsigned long flags)\\r\\n{\\r\\nparam->flags &= ~flags;\\r\\nreturn 1;\\r\\n}\\r\\nunsigned long X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param)\\r\\n{\\r\\nreturn param->flags;\\r\\n}\\r\\nint X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose)\\r\\n{\\r\\nreturn X509_PURPOSE_set(&param->purpose, purpose);\\r\\n}\\r\\nint X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust)\\r\\n{\\r\\nreturn X509_TRUST_set(&param->trust, trust);\\r\\n}\\r\\nvoid X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth)\\r\\n{\\r\\nparam->depth = depth;\\r\\n}\\r\\nvoid X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t)\\r\\n{\\r\\nparam->check_time = t;\\r\\nparam->flags |= X509_V_FLAG_USE_CHECK_TIME;\\r\\n}\\r\\nint X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param,\\r\\nASN1_OBJECT *policy)\\r\\n{\\r\\nif (!param->policies) {\\r\\nparam->policies = sk_ASN1_OBJECT_new_null();\\r\\nif (!param->policies)\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_ASN1_OBJECT_push(param->policies, policy))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param,\\r\\nconst char *name, size_t namelen)\\r\\n{\\r\\nreturn int_x509_param_set_hosts(param->id, SET_HOST, name, namelen);\\r\\n}\\r\\nint X509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param,\\r\\nconst char *name, size_t namelen)\\r\\n{\\r\\nreturn int_x509_param_set_hosts(param->id, ADD_HOST, name, namelen);\\r\\n}\\r\\nvoid X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *param,\\r\\nunsigned int flags)\\r\\n{\\r\\nparam->id->hostflags = flags;\\r\\n}\\r\\nchar *X509_VERIFY_PARAM_get0_peername(X509_VERIFY_PARAM *param)\\r\\n{\\r\\nreturn param->id->peername;\\r\\n}\\r\\nint X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param,\\r\\nconst char *email, size_t emaillen)\\r\\n{\\r\\nreturn int_x509_param_set1(&param->id->email, &param->id->emaillen,\\r\\nemail, emaillen);\\r\\n}\\r\\nint X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param,\\r\\nconst unsigned char *ip, size_t iplen)\\r\\n{\\r\\nif (iplen != 0 && iplen != 4 && iplen != 16)\\r\\nreturn 0;\\r\\nreturn int_x509_param_set1((char **)&param->id->ip, &param->id->iplen,\\r\\n(char *)ip, iplen);\\r\\n}\\r\\nint X509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *param, const char *ipasc)\\r\\n{\\r\\nunsigned char ipout[16];\\r\\nsize_t iplen;\\r\\niplen = (size_t)a2i_ipadd(ipout, ipasc);\\r\\nif (iplen == 0)\\r\\nreturn 0;\\r\\nreturn X509_VERIFY_PARAM_set1_ip(param, ipout, iplen);\\r\\n}\\r\\nint X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param)\\r\\n{\\r\\nreturn param->depth;\\r\\n}\\r\\nconst char *X509_VERIFY_PARAM_get0_name(const X509_VERIFY_PARAM *param)\\r\\n{\\r\\nreturn param->name;\\r\\n}\\r\\nstatic int table_cmp(const X509_VERIFY_PARAM *a, const X509_VERIFY_PARAM *b)\\r\\n{\\r\\nreturn strcmp(a->name, b->name);\\r\\n}\\r\\nstatic int param_cmp(const X509_VERIFY_PARAM *const *a,\\r\\nconst X509_VERIFY_PARAM *const *b)\\r\\n{\\r\\nreturn strcmp((*a)->name, (*b)->name);\\r\\n}\\r\\nint X509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param)\\r\\n{\\r\\nint idx;\\r\\nX509_VERIFY_PARAM *ptmp;\\r\\nif (!param_table) {\\r\\nparam_table = sk_X509_VERIFY_PARAM_new(param_cmp);\\r\\nif (!param_table)\\r\\nreturn 0;\\r\\n} else {\\r\\nidx = sk_X509_VERIFY_PARAM_find(param_table, param);\\r\\nif (idx != -1) {\\r\\nptmp = sk_X509_VERIFY_PARAM_value(param_table, idx);\\r\\nX509_VERIFY_PARAM_free(ptmp);\\r\\n(void)sk_X509_VERIFY_PARAM_delete(param_table, idx);\\r\\n}\\r\\n}\\r\\nif (!sk_X509_VERIFY_PARAM_push(param_table, param))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_VERIFY_PARAM_get_count(void)\\r\\n{\\r\\nint num = sizeof(default_table) / sizeof(X509_VERIFY_PARAM);\\r\\nif (param_table)\\r\\nnum += sk_X509_VERIFY_PARAM_num(param_table);\\r\\nreturn num;\\r\\n}\\r\\nconst X509_VERIFY_PARAM *X509_VERIFY_PARAM_get0(int id)\\r\\n{\\r\\nint num = sizeof(default_table) / sizeof(X509_VERIFY_PARAM);\\r\\nif (id < num)\\r\\nreturn default_table + id;\\r\\nreturn sk_X509_VERIFY_PARAM_value(param_table, id - num);\\r\\n}\\r\\nconst X509_VERIFY_PARAM *X509_VERIFY_PARAM_lookup(const char *name)\\r\\n{\\r\\nint idx;\\r\\nX509_VERIFY_PARAM pm;\\r\\npm.name = (char *)name;\\r\\nif (param_table) {\\r\\nidx = sk_X509_VERIFY_PARAM_find(param_table, &pm);\\r\\nif (idx != -1)\\r\\nreturn sk_X509_VERIFY_PARAM_value(param_table, idx);\\r\\n}\\r\\nreturn OBJ_bsearch_table(&pm, default_table,\\r\\nsizeof(default_table) /\\r\\nsizeof(X509_VERIFY_PARAM));\\r\\n}\\r\\nvoid X509_VERIFY_PARAM_table_cleanup(void)\\r\\n{\\r\\nif (param_table)\\r\\nsk_X509_VERIFY_PARAM_pop_free(param_table, X509_VERIFY_PARAM_free);\\r\\nparam_table = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_lib_c", "target": 0, "func": "int TS_ASN1_INTEGER_print_bio(BIO *bio, const ASN1_INTEGER *num)\\r\\n{\\r\\nBIGNUM num_bn;\\r\\nint result = 0;\\r\\nchar *hex;\\r\\nBN_init(&num_bn);\\r\\nASN1_INTEGER_to_BN(num, &num_bn);\\r\\nif ((hex = BN_bn2hex(&num_bn))) {\\r\\nresult = BIO_write(bio, \"0x\", 2) > 0;\\r\\nresult = result && BIO_write(bio, hex, strlen(hex)) > 0;\\r\\nOPENSSL_free(hex);\\r\\n}\\r\\nBN_free(&num_bn);\\r\\nreturn result;\\r\\n}\\r\\nint TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\\r\\n{\\r\\nchar obj_txt[128];\\r\\nint len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\\r\\nBIO_write(bio, obj_txt, len);\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\nreturn 1;\\r\\n}\\r\\nint TS_X509_ALGOR_print_bio(BIO *bio, const X509_ALGOR *alg)\\r\\n{\\r\\nint i = OBJ_obj2nid(alg->algorithm);\\r\\nreturn BIO_printf(bio, \"Hash Algorithm: %s\\n\",\\r\\n(i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\\r\\n}\\r\\nint TS_MSG_IMPRINT_print_bio(BIO *bio, TS_MSG_IMPRINT *a)\\r\\n{\\r\\nconst ASN1_OCTET_STRING *msg;\\r\\nTS_X509_ALGOR_print_bio(bio, TS_MSG_IMPRINT_get_algo(a));\\r\\nBIO_printf(bio, \"Message data:\\n\");\\r\\nmsg = TS_MSG_IMPRINT_get_msg(a);\\r\\nBIO_dump_indent(bio, (const char *)M_ASN1_STRING_data(msg),\\r\\nM_ASN1_STRING_length(msg), 4);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_evp_asn1_c", "target": 0, "func": "int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len)\\r\\n{\\r\\nASN1_STRING *os;\\r\\nif ((os = M_ASN1_OCTET_STRING_new()) == NULL)\\r\\nreturn (0);\\r\\nif (!M_ASN1_OCTET_STRING_set(os, data, len)) {\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_TYPE_set(a, V_ASN1_OCTET_STRING, os);\\r\\nreturn (1);\\r\\n}\\r\\nint ASN1_TYPE_get_octetstring(ASN1_TYPE *a, unsigned char *data, int max_len)\\r\\n{\\r\\nint ret, num;\\r\\nunsigned char *p;\\r\\nif ((a->type != V_ASN1_OCTET_STRING) || (a->value.octet_string == NULL)) {\\r\\nASN1err(ASN1_F_ASN1_TYPE_GET_OCTETSTRING, ASN1_R_DATA_IS_WRONG);\\r\\nreturn (-1);\\r\\n}\\r\\np = M_ASN1_STRING_data(a->value.octet_string);\\r\\nret = M_ASN1_STRING_length(a->value.octet_string);\\r\\nif (ret < max_len)\\r\\nnum = ret;\\r\\nelse\\r\\nnum = max_len;\\r\\nmemcpy(data, p, num);\\r\\nreturn (ret);\\r\\n}\\r\\nint ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num, unsigned char *data,\\r\\nint len)\\r\\n{\\r\\nint n, size;\\r\\nASN1_OCTET_STRING os, *osp;\\r\\nASN1_INTEGER in;\\r\\nunsigned char *p;\\r\\nunsigned char buf[32];\\r\\nin.data = buf;\\r\\nin.length = 32;\\r\\nos.data = data;\\r\\nos.type = V_ASN1_OCTET_STRING;\\r\\nos.length = len;\\r\\nASN1_INTEGER_set(&in, num);\\r\\nn = i2d_ASN1_INTEGER(&in, NULL);\\r\\nn += M_i2d_ASN1_OCTET_STRING(&os, NULL);\\r\\nsize = ASN1_object_size(1, n, V_ASN1_SEQUENCE);\\r\\nif ((osp = ASN1_STRING_new()) == NULL)\\r\\nreturn (0);\\r\\nif (!ASN1_STRING_set(osp, NULL, size)) {\\r\\nASN1_STRING_free(osp);\\r\\nreturn (0);\\r\\n}\\r\\nM_ASN1_STRING_length_set(osp, size);\\r\\np = M_ASN1_STRING_data(osp);\\r\\nASN1_put_object(&p, 1, n, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\\r\\ni2d_ASN1_INTEGER(&in, &p);\\r\\nM_i2d_ASN1_OCTET_STRING(&os, &p);\\r\\nASN1_TYPE_set(a, V_ASN1_SEQUENCE, osp);\\r\\nreturn (1);\\r\\n}\\r\\nint ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a, long *num,\\r\\nunsigned char *data, int max_len)\\r\\n{\\r\\nint ret = -1, n;\\r\\nASN1_INTEGER *ai = NULL;\\r\\nASN1_OCTET_STRING *os = NULL;\\r\\nconst unsigned char *p;\\r\\nlong length;\\r\\nASN1_const_CTX c;\\r\\nif ((a->type != V_ASN1_SEQUENCE) || (a->value.sequence == NULL)) {\\r\\ngoto err;\\r\\n}\\r\\np = M_ASN1_STRING_data(a->value.sequence);\\r\\nlength = M_ASN1_STRING_length(a->value.sequence);\\r\\nc.pp = &p;\\r\\nc.p = p;\\r\\nc.max = p + length;\\r\\nc.error = ASN1_R_DATA_IS_WRONG;\\r\\nM_ASN1_D2I_start_sequence();\\r\\nc.q = c.p;\\r\\nif ((ai = d2i_ASN1_INTEGER(NULL, &c.p, c.slen)) == NULL)\\r\\ngoto err;\\r\\nc.slen -= (c.p - c.q);\\r\\nc.q = c.p;\\r\\nif ((os = d2i_ASN1_OCTET_STRING(NULL, &c.p, c.slen)) == NULL)\\r\\ngoto err;\\r\\nc.slen -= (c.p - c.q);\\r\\nif (!M_ASN1_D2I_end_sequence())\\r\\ngoto err;\\r\\nif (num != NULL)\\r\\n*num = ASN1_INTEGER_get(ai);\\r\\nret = M_ASN1_STRING_length(os);\\r\\nif (max_len > ret)\\r\\nn = ret;\\r\\nelse\\r\\nn = max_len;\\r\\nif (data != NULL)\\r\\nmemcpy(data, M_ASN1_STRING_data(os), n);\\r\\nif (0) {\\r\\nerr:\\r\\nASN1err(ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING, ASN1_R_DATA_IS_WRONG);\\r\\n}\\r\\nif (os != NULL)\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\nif (ai != NULL)\\r\\nM_ASN1_INTEGER_free(ai);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_mutl_c", "target": 0, "func": "int PKCS12_gen_mac(PKCS12 *p12, const char *pass, int passlen,\\r\\nunsigned char *mac, unsigned int *maclen)\\r\\n{\\r\\nconst EVP_MD *md_type;\\r\\nHMAC_CTX hmac;\\r\\nunsigned char key[EVP_MAX_MD_SIZE], *salt;\\r\\nint saltlen, iter;\\r\\nint md_size;\\r\\nif (!PKCS7_type_is_data(p12->authsafes)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_CONTENT_TYPE_NOT_DATA);\\r\\nreturn 0;\\r\\n}\\r\\nsalt = p12->mac->salt->data;\\r\\nsaltlen = p12->mac->salt->length;\\r\\nif (!p12->mac->iter)\\r\\niter = 1;\\r\\nelse\\r\\niter = ASN1_INTEGER_get(p12->mac->iter);\\r\\nif (!(md_type = EVP_get_digestbyobj(p12->mac->dinfo->algor->algorithm))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_UNKNOWN_DIGEST_ALGORITHM);\\r\\nreturn 0;\\r\\n}\\r\\nmd_size = EVP_MD_size(md_type);\\r\\nif (md_size < 0)\\r\\nreturn 0;\\r\\nif (!PKCS12_key_gen(pass, passlen, salt, saltlen, PKCS12_MAC_ID, iter,\\r\\nmd_size, key, md_type)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_GEN_MAC, PKCS12_R_KEY_GEN_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nHMAC_CTX_init(&hmac);\\r\\nif (!HMAC_Init_ex(&hmac, key, md_size, md_type, NULL)\\r\\n|| !HMAC_Update(&hmac, p12->authsafes->d.data->data,\\r\\np12->authsafes->d.data->length)\\r\\n|| !HMAC_Final(&hmac, mac, maclen)) {\\r\\nHMAC_CTX_cleanup(&hmac);\\r\\nreturn 0;\\r\\n}\\r\\nHMAC_CTX_cleanup(&hmac);\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen)\\r\\n{\\r\\nunsigned char mac[EVP_MAX_MD_SIZE];\\r\\nunsigned int maclen;\\r\\nif (p12->mac == NULL) {\\r\\nPKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_ABSENT);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_gen_mac(p12, pass, passlen, mac, &maclen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_GENERATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif ((maclen != (unsigned int)p12->mac->dinfo->digest->length)\\r\\n|| memcmp(mac, p12->mac->dinfo->digest->data, maclen))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_set_mac(PKCS12 *p12, const char *pass, int passlen,\\r\\nunsigned char *salt, int saltlen, int iter,\\r\\nconst EVP_MD *md_type)\\r\\n{\\r\\nunsigned char mac[EVP_MAX_MD_SIZE];\\r\\nunsigned int maclen;\\r\\nif (!md_type)\\r\\nmd_type = EVP_sha1();\\r\\nif (PKCS12_setup_mac(p12, iter, salt, saltlen, md_type) == PKCS12_ERROR) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_SETUP_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_gen_mac(p12, pass, passlen, mac, &maclen)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_GENERATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(M_ASN1_OCTET_STRING_set(p12->mac->dinfo->digest, mac, maclen))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SET_MAC, PKCS12_R_MAC_STRING_SET_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS12_setup_mac(PKCS12 *p12, int iter, unsigned char *salt, int saltlen,\\r\\nconst EVP_MD *md_type)\\r\\n{\\r\\nif (!(p12->mac = PKCS12_MAC_DATA_new()))\\r\\nreturn PKCS12_ERROR;\\r\\nif (iter > 1) {\\r\\nif (!(p12->mac->iter = M_ASN1_INTEGER_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ASN1_INTEGER_set(p12->mac->iter, iter)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (!saltlen)\\r\\nsaltlen = PKCS12_SALT_LEN;\\r\\np12->mac->salt->length = saltlen;\\r\\nif (!(p12->mac->salt->data = OPENSSL_malloc(saltlen))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!salt) {\\r\\nif (RAND_pseudo_bytes(p12->mac->salt->data, saltlen) < 0)\\r\\nreturn 0;\\r\\n} else\\r\\nmemcpy(p12->mac->salt->data, salt, saltlen);\\r\\np12->mac->dinfo->algor->algorithm = OBJ_nid2obj(EVP_MD_type(md_type));\\r\\nif (!(p12->mac->dinfo->algor->parameter = ASN1_TYPE_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_SETUP_MAC, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\np12->mac->dinfo->algor->parameter->type = V_ASN1_NULL;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_ok_c", "target": 0, "func": "BIO_METHOD *BIO_f_reliable(void)\\r\\n{\\r\\nreturn (&methods_ok);\\r\\n}\\r\\nstatic int ok_new(BIO *bi)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nctx = (BIO_OK_CTX *)OPENSSL_malloc(sizeof(BIO_OK_CTX));\\r\\nif (ctx == NULL)\\r\\nreturn (0);\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\nctx->buf_len_save = 0;\\r\\nctx->buf_off_save = 0;\\r\\nctx->cont = 1;\\r\\nctx->finished = 0;\\r\\nctx->blockout = 0;\\r\\nctx->sigio = 1;\\r\\nEVP_MD_CTX_init(&ctx->md);\\r\\nbi->init = 0;\\r\\nbi->ptr = (char *)ctx;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int ok_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nEVP_MD_CTX_cleanup(&((BIO_OK_CTX *)a->ptr)->md);\\r\\nOPENSSL_cleanse(a->ptr, sizeof(BIO_OK_CTX));\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr = NULL;\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int ok_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0, i, n;\\r\\nBIO_OK_CTX *ctx;\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nctx = (BIO_OK_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL) || (b->init == 0))\\r\\nreturn (0);\\r\\nwhile (outl > 0) {\\r\\nif (ctx->blockout) {\\r\\ni = ctx->buf_len - ctx->buf_off;\\r\\nif (i > outl)\\r\\ni = outl;\\r\\nmemcpy(out, &(ctx->buf[ctx->buf_off]), i);\\r\\nret += i;\\r\\nout += i;\\r\\noutl -= i;\\r\\nctx->buf_off += i;\\r\\nif (ctx->buf_len == ctx->buf_off) {\\r\\nctx->buf_off = 0;\\r\\nif (ctx->buf_len_save - ctx->buf_off_save > 0) {\\r\\nctx->buf_len = ctx->buf_len_save - ctx->buf_off_save;\\r\\nmemmove(ctx->buf, &(ctx->buf[ctx->buf_off_save]),\\r\\nctx->buf_len);\\r\\n} else {\\r\\nctx->buf_len = 0;\\r\\n}\\r\\nctx->blockout = 0;\\r\\n}\\r\\n}\\r\\nif (outl == 0)\\r\\nbreak;\\r\\nn = IOBS - ctx->buf_len;\\r\\ni = BIO_read(b->next_bio, &(ctx->buf[ctx->buf_len]), n);\\r\\nif (i <= 0)\\r\\nbreak;\\r\\nctx->buf_len += i;\\r\\nif (ctx->sigio == 1) {\\r\\nif (!sig_in(b)) {\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (ctx->sigio == 0) {\\r\\nif (!block_in(b)) {\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (ctx->cont <= 0)\\r\\nbreak;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ok_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret = 0, n, i;\\r\\nBIO_OK_CTX *ctx;\\r\\nif (inl <= 0)\\r\\nreturn inl;\\r\\nctx = (BIO_OK_CTX *)b->ptr;\\r\\nret = inl;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL) || (b->init == 0))\\r\\nreturn (0);\\r\\nif (ctx->sigio && !sig_out(b))\\r\\nreturn 0;\\r\\ndo {\\r\\nBIO_clear_retry_flags(b);\\r\\nn = ctx->buf_len - ctx->buf_off;\\r\\nwhile (ctx->blockout && n > 0) {\\r\\ni = BIO_write(b->next_bio, &(ctx->buf[ctx->buf_off]), n);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nif (!BIO_should_retry(b))\\r\\nctx->cont = 0;\\r\\nreturn (i);\\r\\n}\\r\\nctx->buf_off += i;\\r\\nn -= i;\\r\\n}\\r\\nctx->blockout = 0;\\r\\nif (ctx->buf_len == ctx->buf_off) {\\r\\nctx->buf_len = OK_BLOCK_BLOCK;\\r\\nctx->buf_off = 0;\\r\\n}\\r\\nif ((in == NULL) || (inl <= 0))\\r\\nreturn (0);\\r\\nn = (inl + ctx->buf_len > OK_BLOCK_SIZE + OK_BLOCK_BLOCK) ?\\r\\n(int)(OK_BLOCK_SIZE + OK_BLOCK_BLOCK - ctx->buf_len) : inl;\\r\\nmemcpy((unsigned char *)(&(ctx->buf[ctx->buf_len])),\\r\\n(unsigned char *)in, n);\\r\\nctx->buf_len += n;\\r\\ninl -= n;\\r\\nin += n;\\r\\nif (ctx->buf_len >= OK_BLOCK_SIZE + OK_BLOCK_BLOCK) {\\r\\nif (!block_out(b)) {\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n} while (inl > 0);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long ok_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD *md;\\r\\nconst EVP_MD **ppmd;\\r\\nlong ret = 1;\\r\\nint i;\\r\\nctx = b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\nctx->buf_len_save = 0;\\r\\nctx->buf_off_save = 0;\\r\\nctx->cont = 1;\\r\\nctx->finished = 0;\\r\\nctx->blockout = 0;\\r\\nctx->sigio = 1;\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret = 1;\\r\\nelse\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = ctx->blockout ? ctx->buf_len - ctx->buf_off : 0;\\r\\nif (ret <= 0)\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif (ctx->blockout == 0)\\r\\nif (!block_out(b))\\r\\nreturn 0;\\r\\nwhile (ctx->blockout) {\\r\\ni = ok_write(b, NULL, 0);\\r\\nif (i < 0) {\\r\\nret = i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nctx->finished = 1;\\r\\nctx->buf_off = ctx->buf_len = 0;\\r\\nctx->cont = (int)ret;\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret = (long)ctx->cont;\\r\\nbreak;\\r\\ncase BIO_C_SET_MD:\\r\\nmd = ptr;\\r\\nif (!EVP_DigestInit_ex(&ctx->md, md, NULL))\\r\\nreturn 0;\\r\\nb->init = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_MD:\\r\\nif (b->init) {\\r\\nppmd = ptr;\\r\\n*ppmd = ctx->md.digest;\\r\\n} else\\r\\nret = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long ok_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret = 1;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\nret = BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic void longswap(void *_ptr, size_t len)\\r\\n{\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nif (is_endian.little) {\\r\\nsize_t i;\\r\\nunsigned char *p = _ptr, c;\\r\\nfor (i = 0; i < len; i += 4) {\\r\\nc = p[0], p[0] = p[3], p[3] = c;\\r\\nc = p[1], p[1] = p[2], p[2] = c;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int sig_out(BIO *b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nctx = b->ptr;\\r\\nmd = &ctx->md;\\r\\nif (ctx->buf_len + 2 * md->digest->md_size > OK_BLOCK_SIZE)\\r\\nreturn 1;\\r\\nif (!EVP_DigestInit_ex(md, md->digest, NULL))\\r\\ngoto berr;\\r\\nRAND_pseudo_bytes(md->md_data, md->digest->md_size);\\r\\nmemcpy(&(ctx->buf[ctx->buf_len]), md->md_data, md->digest->md_size);\\r\\nlongswap(&(ctx->buf[ctx->buf_len]), md->digest->md_size);\\r\\nctx->buf_len += md->digest->md_size;\\r\\nif (!EVP_DigestUpdate(md, WELLKNOWN, strlen(WELLKNOWN)))\\r\\ngoto berr;\\r\\nif (!EVP_DigestFinal_ex(md, &(ctx->buf[ctx->buf_len]), NULL))\\r\\ngoto berr;\\r\\nctx->buf_len += md->digest->md_size;\\r\\nctx->blockout = 1;\\r\\nctx->sigio = 0;\\r\\nreturn 1;\\r\\nberr:\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int sig_in(BIO *b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nunsigned char tmp[EVP_MAX_MD_SIZE];\\r\\nint ret = 0;\\r\\nctx = b->ptr;\\r\\nmd = &ctx->md;\\r\\nif ((int)(ctx->buf_len - ctx->buf_off) < 2 * md->digest->md_size)\\r\\nreturn 1;\\r\\nif (!EVP_DigestInit_ex(md, md->digest, NULL))\\r\\ngoto berr;\\r\\nmemcpy(md->md_data, &(ctx->buf[ctx->buf_off]), md->digest->md_size);\\r\\nlongswap(md->md_data, md->digest->md_size);\\r\\nctx->buf_off += md->digest->md_size;\\r\\nif (!EVP_DigestUpdate(md, WELLKNOWN, strlen(WELLKNOWN)))\\r\\ngoto berr;\\r\\nif (!EVP_DigestFinal_ex(md, tmp, NULL))\\r\\ngoto berr;\\r\\nret = memcmp(&(ctx->buf[ctx->buf_off]), tmp, md->digest->md_size) == 0;\\r\\nctx->buf_off += md->digest->md_size;\\r\\nif (ret == 1) {\\r\\nctx->sigio = 0;\\r\\nif (ctx->buf_len != ctx->buf_off) {\\r\\nmemmove(ctx->buf, &(ctx->buf[ctx->buf_off]),\\r\\nctx->buf_len - ctx->buf_off);\\r\\n}\\r\\nctx->buf_len -= ctx->buf_off;\\r\\nctx->buf_off = 0;\\r\\n} else {\\r\\nctx->cont = 0;\\r\\n}\\r\\nreturn 1;\\r\\nberr:\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int block_out(BIO *b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nunsigned long tl;\\r\\nctx = b->ptr;\\r\\nmd = &ctx->md;\\r\\ntl = ctx->buf_len - OK_BLOCK_BLOCK;\\r\\nctx->buf[0] = (unsigned char)(tl >> 24);\\r\\nctx->buf[1] = (unsigned char)(tl >> 16);\\r\\nctx->buf[2] = (unsigned char)(tl >> 8);\\r\\nctx->buf[3] = (unsigned char)(tl);\\r\\nif (!EVP_DigestUpdate(md,\\r\\n(unsigned char *)&(ctx->buf[OK_BLOCK_BLOCK]), tl))\\r\\ngoto berr;\\r\\nif (!EVP_DigestFinal_ex(md, &(ctx->buf[ctx->buf_len]), NULL))\\r\\ngoto berr;\\r\\nctx->buf_len += md->digest->md_size;\\r\\nctx->blockout = 1;\\r\\nreturn 1;\\r\\nberr:\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int block_in(BIO *b)\\r\\n{\\r\\nBIO_OK_CTX *ctx;\\r\\nEVP_MD_CTX *md;\\r\\nunsigned long tl = 0;\\r\\nunsigned char tmp[EVP_MAX_MD_SIZE];\\r\\nctx = b->ptr;\\r\\nmd = &ctx->md;\\r\\nassert(sizeof(tl) >= OK_BLOCK_BLOCK);\\r\\ntl = ctx->buf[0];\\r\\ntl <<= 8;\\r\\ntl |= ctx->buf[1];\\r\\ntl <<= 8;\\r\\ntl |= ctx->buf[2];\\r\\ntl <<= 8;\\r\\ntl |= ctx->buf[3];\\r\\nif (ctx->buf_len < tl + OK_BLOCK_BLOCK + md->digest->md_size)\\r\\nreturn 1;\\r\\nif (!EVP_DigestUpdate(md,\\r\\n(unsigned char *)&(ctx->buf[OK_BLOCK_BLOCK]), tl))\\r\\ngoto berr;\\r\\nif (!EVP_DigestFinal_ex(md, tmp, NULL))\\r\\ngoto berr;\\r\\nif (memcmp(&(ctx->buf[tl + OK_BLOCK_BLOCK]), tmp, md->digest->md_size) ==\\r\\n0) {\\r\\nctx->buf_off_save = tl + OK_BLOCK_BLOCK + md->digest->md_size;\\r\\nctx->buf_len_save = ctx->buf_len;\\r\\nctx->buf_off = OK_BLOCK_BLOCK;\\r\\nctx->buf_len = tl + OK_BLOCK_BLOCK;\\r\\nctx->blockout = 1;\\r\\n} else {\\r\\nctx->cont = 0;\\r\\n}\\r\\nreturn 1;\\r\\nberr:\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_aes_c", "target": 1, "func": "static int aesni_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nint ret, mode;\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nmode = ctx->cipher->flags & EVP_CIPH_MODE;\\r\\nif ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)\\r\\n&& !enc) {\\r\\nret = aesni_set_decrypt_key(key, ctx->key_len * 8, ctx->cipher_data);\\r\\ndat->block = (block128_f) aesni_decrypt;\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) aesni_cbc_encrypt : NULL;\\r\\n} else {\\r\\nret = aesni_set_encrypt_key(key, ctx->key_len * 8, ctx->cipher_data);\\r\\ndat->block = (block128_f) aesni_encrypt;\\r\\nif (mode == EVP_CIPH_CBC_MODE)\\r\\ndat->stream.cbc = (cbc128_f) aesni_cbc_encrypt;\\r\\nelse if (mode == EVP_CIPH_CTR_MODE)\\r\\ndat->stream.ctr = (ctr128_f) aesni_ctr32_encrypt_blocks;\\r\\nelse\\r\\ndat->stream.cbc = NULL;\\r\\n}\\r\\nif (ret < 0) {\\r\\nEVPerr(EVP_F_AESNI_INIT_KEY, EVP_R_AES_KEY_SETUP_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aesni_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\naesni_cbc_encrypt(in, out, len, ctx->cipher_data, ctx->iv, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aesni_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nsize_t bl = ctx->cipher->block_size;\\r\\nif (len < bl)\\r\\nreturn 1;\\r\\naesni_ecb_encrypt(in, out, len, ctx->cipher_data, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aesni_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_GCM_CTX *gctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key) {\\r\\naesni_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks.ks);\\r\\nCRYPTO_gcm128_init(&gctx->gcm, &gctx->ks, (block128_f) aesni_encrypt);\\r\\ngctx->ctr = (ctr128_f) aesni_ctr32_encrypt_blocks;\\r\\nif (iv == NULL && gctx->iv_set)\\r\\niv = gctx->iv;\\r\\nif (iv) {\\r\\nCRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);\\r\\ngctx->iv_set = 1;\\r\\n}\\r\\ngctx->key_set = 1;\\r\\n} else {\\r\\nif (gctx->key_set)\\r\\nCRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);\\r\\nelse\\r\\nmemcpy(gctx->iv, iv, gctx->ivlen);\\r\\ngctx->iv_set = 1;\\r\\ngctx->iv_gen = 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aesni_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_XTS_CTX *xctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key) {\\r\\nif (enc) {\\r\\naesni_set_encrypt_key(key, ctx->key_len * 4, &xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) aesni_encrypt;\\r\\nxctx->stream = aesni_xts_encrypt;\\r\\n} else {\\r\\naesni_set_decrypt_key(key, ctx->key_len * 4, &xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) aesni_decrypt;\\r\\nxctx->stream = aesni_xts_decrypt;\\r\\n}\\r\\naesni_set_encrypt_key(key + ctx->key_len / 2,\\r\\nctx->key_len * 4, &xctx->ks2.ks);\\r\\nxctx->xts.block2 = (block128_f) aesni_encrypt;\\r\\nxctx->xts.key1 = &xctx->ks1;\\r\\n}\\r\\nif (iv) {\\r\\nxctx->xts.key2 = &xctx->ks2;\\r\\nmemcpy(ctx->iv, iv, 16);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aesni_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_CCM_CTX *cctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key) {\\r\\naesni_set_encrypt_key(key, ctx->key_len * 8, &cctx->ks.ks);\\r\\nCRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,\\r\\n&cctx->ks, (block128_f) aesni_encrypt);\\r\\ncctx->str = enc ? (ccm128_f) aesni_ccm64_encrypt_blocks :\\r\\n(ccm128_f) aesni_ccm64_decrypt_blocks;\\r\\ncctx->key_set = 1;\\r\\n}\\r\\nif (iv) {\\r\\nmemcpy(ctx->iv, iv, 15 - cctx->L);\\r\\ncctx->iv_set = 1;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_t4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nint ret, mode, bits;\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nmode = ctx->cipher->flags & EVP_CIPH_MODE;\\r\\nbits = ctx->key_len * 8;\\r\\nif ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)\\r\\n&& !enc) {\\r\\nret = 0;\\r\\naes_t4_set_decrypt_key(key, bits, ctx->cipher_data);\\r\\ndat->block = (block128_f) aes_t4_decrypt;\\r\\nswitch (bits) {\\r\\ncase 128:\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) aes128_t4_cbc_decrypt : NULL;\\r\\nbreak;\\r\\ncase 192:\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) aes192_t4_cbc_decrypt : NULL;\\r\\nbreak;\\r\\ncase 256:\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) aes256_t4_cbc_decrypt : NULL;\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\n}\\r\\n} else {\\r\\nret = 0;\\r\\naes_t4_set_encrypt_key(key, bits, ctx->cipher_data);\\r\\ndat->block = (block128_f) aes_t4_encrypt;\\r\\nswitch (bits) {\\r\\ncase 128:\\r\\nif (mode == EVP_CIPH_CBC_MODE)\\r\\ndat->stream.cbc = (cbc128_f) aes128_t4_cbc_encrypt;\\r\\nelse if (mode == EVP_CIPH_CTR_MODE)\\r\\ndat->stream.ctr = (ctr128_f) aes128_t4_ctr32_encrypt;\\r\\nelse\\r\\ndat->stream.cbc = NULL;\\r\\nbreak;\\r\\ncase 192:\\r\\nif (mode == EVP_CIPH_CBC_MODE)\\r\\ndat->stream.cbc = (cbc128_f) aes192_t4_cbc_encrypt;\\r\\nelse if (mode == EVP_CIPH_CTR_MODE)\\r\\ndat->stream.ctr = (ctr128_f) aes192_t4_ctr32_encrypt;\\r\\nelse\\r\\ndat->stream.cbc = NULL;\\r\\nbreak;\\r\\ncase 256:\\r\\nif (mode == EVP_CIPH_CBC_MODE)\\r\\ndat->stream.cbc = (cbc128_f) aes256_t4_cbc_encrypt;\\r\\nelse if (mode == EVP_CIPH_CTR_MODE)\\r\\ndat->stream.ctr = (ctr128_f) aes256_t4_ctr32_encrypt;\\r\\nelse\\r\\ndat->stream.cbc = NULL;\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\n}\\r\\n}\\r\\nif (ret < 0) {\\r\\nEVPerr(EVP_F_AES_T4_INIT_KEY, EVP_R_AES_KEY_SETUP_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_t4_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_GCM_CTX *gctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key) {\\r\\nint bits = ctx->key_len * 8;\\r\\naes_t4_set_encrypt_key(key, bits, &gctx->ks.ks);\\r\\nCRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,\\r\\n(block128_f) aes_t4_encrypt);\\r\\nswitch (bits) {\\r\\ncase 128:\\r\\ngctx->ctr = (ctr128_f) aes128_t4_ctr32_encrypt;\\r\\nbreak;\\r\\ncase 192:\\r\\ngctx->ctr = (ctr128_f) aes192_t4_ctr32_encrypt;\\r\\nbreak;\\r\\ncase 256:\\r\\ngctx->ctr = (ctr128_f) aes256_t4_ctr32_encrypt;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nif (iv == NULL && gctx->iv_set)\\r\\niv = gctx->iv;\\r\\nif (iv) {\\r\\nCRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);\\r\\ngctx->iv_set = 1;\\r\\n}\\r\\ngctx->key_set = 1;\\r\\n} else {\\r\\nif (gctx->key_set)\\r\\nCRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);\\r\\nelse\\r\\nmemcpy(gctx->iv, iv, gctx->ivlen);\\r\\ngctx->iv_set = 1;\\r\\ngctx->iv_gen = 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_t4_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_XTS_CTX *xctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key) {\\r\\nint bits = ctx->key_len * 4;\\r\\nxctx->stream = NULL;\\r\\nif (enc) {\\r\\naes_t4_set_encrypt_key(key, bits, &xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) aes_t4_encrypt;\\r\\nswitch (bits) {\\r\\ncase 128:\\r\\nxctx->stream = aes128_t4_xts_encrypt;\\r\\nbreak;\\r\\n# if 0\\r\\ncase 192:\\r\\nxctx->stream = aes192_t4_xts_encrypt;\\r\\nbreak;\\r\\n# endif\\r\\ncase 256:\\r\\nxctx->stream = aes256_t4_xts_encrypt;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n} else {\\r\\naes_t4_set_decrypt_key(key, ctx->key_len * 4, &xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) aes_t4_decrypt;\\r\\nswitch (bits) {\\r\\ncase 128:\\r\\nxctx->stream = aes128_t4_xts_decrypt;\\r\\nbreak;\\r\\n# if 0\\r\\ncase 192:\\r\\nxctx->stream = aes192_t4_xts_decrypt;\\r\\nbreak;\\r\\n# endif\\r\\ncase 256:\\r\\nxctx->stream = aes256_t4_xts_decrypt;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\naes_t4_set_encrypt_key(key + ctx->key_len / 2,\\r\\nctx->key_len * 4, &xctx->ks2.ks);\\r\\nxctx->xts.block2 = (block128_f) aes_t4_encrypt;\\r\\nxctx->xts.key1 = &xctx->ks1;\\r\\n}\\r\\nif (iv) {\\r\\nxctx->xts.key2 = &xctx->ks2;\\r\\nmemcpy(ctx->iv, iv, 16);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_t4_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_CCM_CTX *cctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key) {\\r\\nint bits = ctx->key_len * 8;\\r\\naes_t4_set_encrypt_key(key, bits, &cctx->ks.ks);\\r\\nCRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,\\r\\n&cctx->ks, (block128_f) aes_t4_encrypt);\\r\\n# if 0\\r\\nswitch (bits) {\\r\\ncase 128:\\r\\ncctx->str = enc ? (ccm128_f) aes128_t4_ccm64_encrypt :\\r\\n(ccm128_f) ae128_t4_ccm64_decrypt;\\r\\nbreak;\\r\\ncase 192:\\r\\ncctx->str = enc ? (ccm128_f) aes192_t4_ccm64_encrypt :\\r\\n(ccm128_f) ae192_t4_ccm64_decrypt;\\r\\nbreak;\\r\\ncase 256:\\r\\ncctx->str = enc ? (ccm128_f) aes256_t4_ccm64_encrypt :\\r\\n(ccm128_f) ae256_t4_ccm64_decrypt;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n# endif\\r\\ncctx->key_set = 1;\\r\\n}\\r\\nif (iv) {\\r\\nmemcpy(ctx->iv, iv, 15 - cctx->L);\\r\\ncctx->iv_set = 1;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nint ret, mode;\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nmode = ctx->cipher->flags & EVP_CIPH_MODE;\\r\\nif ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)\\r\\n&& !enc)\\r\\n# ifdef HWAES_CAPABLE\\r\\nif (HWAES_CAPABLE) {\\r\\nret = HWAES_set_decrypt_key(key, ctx->key_len * 8, &dat->ks.ks);\\r\\ndat->block = (block128_f) HWAES_decrypt;\\r\\ndat->stream.cbc = NULL;\\r\\n# ifdef HWAES_cbc_encrypt\\r\\nif (mode == EVP_CIPH_CBC_MODE)\\r\\ndat->stream.cbc = (cbc128_f) HWAES_cbc_encrypt;\\r\\n# endif\\r\\n} else\\r\\n# endif\\r\\n# ifdef BSAES_CAPABLE\\r\\nif (BSAES_CAPABLE && mode == EVP_CIPH_CBC_MODE) {\\r\\nret = AES_set_decrypt_key(key, ctx->key_len * 8, &dat->ks.ks);\\r\\ndat->block = (block128_f) AES_decrypt;\\r\\ndat->stream.cbc = (cbc128_f) bsaes_cbc_encrypt;\\r\\n} else\\r\\n# endif\\r\\n# ifdef VPAES_CAPABLE\\r\\nif (VPAES_CAPABLE) {\\r\\nret = vpaes_set_decrypt_key(key, ctx->key_len * 8, &dat->ks.ks);\\r\\ndat->block = (block128_f) vpaes_decrypt;\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) vpaes_cbc_encrypt : NULL;\\r\\n} else\\r\\n# endif\\r\\n{\\r\\nret = AES_set_decrypt_key(key, ctx->key_len * 8, &dat->ks.ks);\\r\\ndat->block = (block128_f) AES_decrypt;\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) AES_cbc_encrypt : NULL;\\r\\n} else\\r\\n# ifdef HWAES_CAPABLE\\r\\nif (HWAES_CAPABLE) {\\r\\nret = HWAES_set_encrypt_key(key, ctx->key_len * 8, &dat->ks.ks);\\r\\ndat->block = (block128_f) HWAES_encrypt;\\r\\ndat->stream.cbc = NULL;\\r\\n# ifdef HWAES_cbc_encrypt\\r\\nif (mode == EVP_CIPH_CBC_MODE)\\r\\ndat->stream.cbc = (cbc128_f) HWAES_cbc_encrypt;\\r\\nelse\\r\\n# endif\\r\\n# ifdef HWAES_ctr32_encrypt_blocks\\r\\nif (mode == EVP_CIPH_CTR_MODE)\\r\\ndat->stream.ctr = (ctr128_f) HWAES_ctr32_encrypt_blocks;\\r\\nelse\\r\\n# endif\\r\\n(void)0;\\r\\n} else\\r\\n# endif\\r\\n# ifdef BSAES_CAPABLE\\r\\nif (BSAES_CAPABLE && mode == EVP_CIPH_CTR_MODE) {\\r\\nret = AES_set_encrypt_key(key, ctx->key_len * 8, &dat->ks.ks);\\r\\ndat->block = (block128_f) AES_encrypt;\\r\\ndat->stream.ctr = (ctr128_f) bsaes_ctr32_encrypt_blocks;\\r\\n} else\\r\\n# endif\\r\\n# ifdef VPAES_CAPABLE\\r\\nif (VPAES_CAPABLE) {\\r\\nret = vpaes_set_encrypt_key(key, ctx->key_len * 8, &dat->ks.ks);\\r\\ndat->block = (block128_f) vpaes_encrypt;\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) vpaes_cbc_encrypt : NULL;\\r\\n} else\\r\\n# endif\\r\\n{\\r\\nret = AES_set_encrypt_key(key, ctx->key_len * 8, &dat->ks.ks);\\r\\ndat->block = (block128_f) AES_encrypt;\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) AES_cbc_encrypt : NULL;\\r\\n# ifdef AES_CTR_ASM\\r\\nif (mode == EVP_CIPH_CTR_MODE)\\r\\ndat->stream.ctr = (ctr128_f) AES_ctr32_encrypt;\\r\\n# endif\\r\\n}\\r\\nif (ret < 0) {\\r\\nEVPerr(EVP_F_AES_INIT_KEY, EVP_R_AES_KEY_SETUP_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nif (dat->stream.cbc)\\r\\n(*dat->stream.cbc) (in, out, len, &dat->ks, ctx->iv, ctx->encrypt);\\r\\nelse if (ctx->encrypt)\\r\\nCRYPTO_cbc128_encrypt(in, out, len, &dat->ks, ctx->iv, dat->block);\\r\\nelse\\r\\nCRYPTO_cbc128_decrypt(in, out, len, &dat->ks, ctx->iv, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nsize_t bl = ctx->cipher->block_size;\\r\\nsize_t i;\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nif (len < bl)\\r\\nreturn 1;\\r\\nfor (i = 0, len -= bl; i <= len; i += bl)\\r\\n(*dat->block) (in + i, out + i, &dat->ks);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nCRYPTO_ofb128_encrypt(in, out, len, &dat->ks,\\r\\nctx->iv, &ctx->num, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nCRYPTO_cfb128_encrypt(in, out, len, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nCRYPTO_cfb128_8_encrypt(in, out, len, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nif (ctx->flags & EVP_CIPH_FLAG_LENGTH_BITS) {\\r\\nCRYPTO_cfb128_1_encrypt(in, out, len, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nwhile (len >= MAXBITCHUNK) {\\r\\nCRYPTO_cfb128_1_encrypt(in, out, MAXBITCHUNK * 8, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nlen -= MAXBITCHUNK;\\r\\n}\\r\\nif (len)\\r\\nCRYPTO_cfb128_1_encrypt(in, out, len * 8, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_ctr_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nunsigned int num = ctx->num;\\r\\nEVP_AES_KEY *dat = (EVP_AES_KEY *) ctx->cipher_data;\\r\\nif (dat->stream.ctr)\\r\\nCRYPTO_ctr128_encrypt_ctr32(in, out, len, &dat->ks,\\r\\nctx->iv, ctx->buf, &num, dat->stream.ctr);\\r\\nelse\\r\\nCRYPTO_ctr128_encrypt(in, out, len, &dat->ks,\\r\\nctx->iv, ctx->buf, &num, dat->block);\\r\\nctx->num = (size_t)num;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_gcm_cleanup(EVP_CIPHER_CTX *c)\\r\\n{\\r\\nEVP_AES_GCM_CTX *gctx = c->cipher_data;\\r\\nOPENSSL_cleanse(&gctx->gcm, sizeof(gctx->gcm));\\r\\nif (gctx->iv != c->iv)\\r\\nOPENSSL_free(gctx->iv);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void ctr64_inc(unsigned char *counter)\\r\\n{\\r\\nint n = 8;\\r\\nunsigned char c;\\r\\ndo {\\r\\n--n;\\r\\nc = counter[n];\\r\\n++c;\\r\\ncounter[n] = c;\\r\\nif (c)\\r\\nreturn;\\r\\n} while (n);\\r\\n}\\r\\nstatic int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nEVP_AES_GCM_CTX *gctx = c->cipher_data;\\r\\nswitch (type) {\\r\\ncase EVP_CTRL_INIT:\\r\\ngctx->key_set = 0;\\r\\ngctx->iv_set = 0;\\r\\ngctx->ivlen = c->cipher->iv_len;\\r\\ngctx->iv = c->iv;\\r\\ngctx->taglen = -1;\\r\\ngctx->iv_gen = 0;\\r\\ngctx->tls_aad_len = -1;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GCM_SET_IVLEN:\\r\\nif (arg <= 0)\\r\\nreturn 0;\\r\\nif ((arg > EVP_MAX_IV_LENGTH) && (arg > gctx->ivlen)) {\\r\\nif (gctx->iv != c->iv)\\r\\nOPENSSL_free(gctx->iv);\\r\\ngctx->iv = OPENSSL_malloc(arg);\\r\\nif (!gctx->iv)\\r\\nreturn 0;\\r\\n}\\r\\ngctx->ivlen = arg;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GCM_SET_TAG:\\r\\nif (arg <= 0 || arg > 16 || c->encrypt)\\r\\nreturn 0;\\r\\nmemcpy(c->buf, ptr, arg);\\r\\ngctx->taglen = arg;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GCM_GET_TAG:\\r\\nif (arg <= 0 || arg > 16 || !c->encrypt || gctx->taglen < 0)\\r\\nreturn 0;\\r\\nmemcpy(ptr, c->buf, arg);\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GCM_SET_IV_FIXED:\\r\\nif (arg == -1) {\\r\\nmemcpy(gctx->iv, ptr, gctx->ivlen);\\r\\ngctx->iv_gen = 1;\\r\\nreturn 1;\\r\\n}\\r\\nif ((arg < 4) || (gctx->ivlen - arg) < 8)\\r\\nreturn 0;\\r\\nif (arg)\\r\\nmemcpy(gctx->iv, ptr, arg);\\r\\nif (c->encrypt && RAND_bytes(gctx->iv + arg, gctx->ivlen - arg) <= 0)\\r\\nreturn 0;\\r\\ngctx->iv_gen = 1;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GCM_IV_GEN:\\r\\nif (gctx->iv_gen == 0 || gctx->key_set == 0)\\r\\nreturn 0;\\r\\nCRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);\\r\\nif (arg <= 0 || arg > gctx->ivlen)\\r\\narg = gctx->ivlen;\\r\\nmemcpy(ptr, gctx->iv + gctx->ivlen - arg, arg);\\r\\nctr64_inc(gctx->iv + gctx->ivlen - 8);\\r\\ngctx->iv_set = 1;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GCM_SET_IV_INV:\\r\\nif (gctx->iv_gen == 0 || gctx->key_set == 0 || c->encrypt)\\r\\nreturn 0;\\r\\nmemcpy(gctx->iv + gctx->ivlen - arg, ptr, arg);\\r\\nCRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen);\\r\\ngctx->iv_set = 1;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_AEAD_TLS1_AAD:\\r\\nif (arg != 13)\\r\\nreturn 0;\\r\\nmemcpy(c->buf, ptr, arg);\\r\\ngctx->tls_aad_len = arg;\\r\\n{\\r\\nunsigned int len = c->buf[arg - 2] << 8 | c->buf[arg - 1];\\r\\nlen -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\\r\\nif (!c->encrypt)\\r\\nlen -= EVP_GCM_TLS_TAG_LEN;\\r\\nc->buf[arg - 2] = len >> 8;\\r\\nc->buf[arg - 1] = len & 0xff;\\r\\n}\\r\\nreturn EVP_GCM_TLS_TAG_LEN;\\r\\ncase EVP_CTRL_COPY:\\r\\n{\\r\\nEVP_CIPHER_CTX *out = ptr;\\r\\nEVP_AES_GCM_CTX *gctx_out = out->cipher_data;\\r\\nif (gctx->gcm.key) {\\r\\nif (gctx->gcm.key != &gctx->ks)\\r\\nreturn 0;\\r\\ngctx_out->gcm.key = &gctx_out->ks;\\r\\n}\\r\\nif (gctx->iv == c->iv)\\r\\ngctx_out->iv = out->iv;\\r\\nelse {\\r\\ngctx_out->iv = OPENSSL_malloc(gctx->ivlen);\\r\\nif (!gctx_out->iv)\\r\\nreturn 0;\\r\\nmemcpy(gctx_out->iv, gctx->iv, gctx->ivlen);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nstatic int aes_gcm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_GCM_CTX *gctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key) {\\r\\ndo {\\r\\n# ifdef HWAES_CAPABLE\\r\\nif (HWAES_CAPABLE) {\\r\\nHWAES_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks.ks);\\r\\nCRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,\\r\\n(block128_f) HWAES_encrypt);\\r\\n# ifdef HWAES_ctr32_encrypt_blocks\\r\\ngctx->ctr = (ctr128_f) HWAES_ctr32_encrypt_blocks;\\r\\n# else\\r\\ngctx->ctr = NULL;\\r\\n# endif\\r\\nbreak;\\r\\n} else\\r\\n# endif\\r\\n# ifdef BSAES_CAPABLE\\r\\nif (BSAES_CAPABLE) {\\r\\nAES_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks.ks);\\r\\nCRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,\\r\\n(block128_f) AES_encrypt);\\r\\ngctx->ctr = (ctr128_f) bsaes_ctr32_encrypt_blocks;\\r\\nbreak;\\r\\n} else\\r\\n# endif\\r\\n# ifdef VPAES_CAPABLE\\r\\nif (VPAES_CAPABLE) {\\r\\nvpaes_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks.ks);\\r\\nCRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,\\r\\n(block128_f) vpaes_encrypt);\\r\\ngctx->ctr = NULL;\\r\\nbreak;\\r\\n} else\\r\\n# endif\\r\\n(void)0;\\r\\nAES_set_encrypt_key(key, ctx->key_len * 8, &gctx->ks.ks);\\r\\nCRYPTO_gcm128_init(&gctx->gcm, &gctx->ks,\\r\\n(block128_f) AES_encrypt);\\r\\n# ifdef AES_CTR_ASM\\r\\ngctx->ctr = (ctr128_f) AES_ctr32_encrypt;\\r\\n# else\\r\\ngctx->ctr = NULL;\\r\\n# endif\\r\\n} while (0);\\r\\nif (iv == NULL && gctx->iv_set)\\r\\niv = gctx->iv;\\r\\nif (iv) {\\r\\nCRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);\\r\\ngctx->iv_set = 1;\\r\\n}\\r\\ngctx->key_set = 1;\\r\\n} else {\\r\\nif (gctx->key_set)\\r\\nCRYPTO_gcm128_setiv(&gctx->gcm, iv, gctx->ivlen);\\r\\nelse\\r\\nmemcpy(gctx->iv, iv, gctx->ivlen);\\r\\ngctx->iv_set = 1;\\r\\ngctx->iv_gen = 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_gcm_tls_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_GCM_CTX *gctx = ctx->cipher_data;\\r\\nint rv = -1;\\r\\nif (out != in\\r\\n|| len < (EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN))\\r\\nreturn -1;\\r\\nif (EVP_CIPHER_CTX_ctrl(ctx, ctx->encrypt ?\\r\\nEVP_CTRL_GCM_IV_GEN : EVP_CTRL_GCM_SET_IV_INV,\\r\\nEVP_GCM_TLS_EXPLICIT_IV_LEN, out) <= 0)\\r\\ngoto err;\\r\\nif (CRYPTO_gcm128_aad(&gctx->gcm, ctx->buf, gctx->tls_aad_len))\\r\\ngoto err;\\r\\nin += EVP_GCM_TLS_EXPLICIT_IV_LEN;\\r\\nout += EVP_GCM_TLS_EXPLICIT_IV_LEN;\\r\\nlen -= EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;\\r\\nif (ctx->encrypt) {\\r\\nif (gctx->ctr) {\\r\\nsize_t bulk = 0;\\r\\n# if defined(AES_GCM_ASM)\\r\\nif (len >= 32 && AES_GCM_ASM(gctx)) {\\r\\nif (CRYPTO_gcm128_encrypt(&gctx->gcm, NULL, NULL, 0))\\r\\nreturn -1;\\r\\nbulk = AES_gcm_encrypt(in, out, len,\\r\\ngctx->gcm.key,\\r\\ngctx->gcm.Yi.c, gctx->gcm.Xi.u);\\r\\ngctx->gcm.len.u[1] += bulk;\\r\\n}\\r\\n# endif\\r\\nif (CRYPTO_gcm128_encrypt_ctr32(&gctx->gcm,\\r\\nin + bulk,\\r\\nout + bulk,\\r\\nlen - bulk, gctx->ctr))\\r\\ngoto err;\\r\\n} else {\\r\\nsize_t bulk = 0;\\r\\n# if defined(AES_GCM_ASM2)\\r\\nif (len >= 32 && AES_GCM_ASM2(gctx)) {\\r\\nif (CRYPTO_gcm128_encrypt(&gctx->gcm, NULL, NULL, 0))\\r\\nreturn -1;\\r\\nbulk = AES_gcm_encrypt(in, out, len,\\r\\ngctx->gcm.key,\\r\\ngctx->gcm.Yi.c, gctx->gcm.Xi.u);\\r\\ngctx->gcm.len.u[1] += bulk;\\r\\n}\\r\\n# endif\\r\\nif (CRYPTO_gcm128_encrypt(&gctx->gcm,\\r\\nin + bulk, out + bulk, len - bulk))\\r\\ngoto err;\\r\\n}\\r\\nout += len;\\r\\nCRYPTO_gcm128_tag(&gctx->gcm, out, EVP_GCM_TLS_TAG_LEN);\\r\\nrv = len + EVP_GCM_TLS_EXPLICIT_IV_LEN + EVP_GCM_TLS_TAG_LEN;\\r\\n} else {\\r\\nif (gctx->ctr) {\\r\\nsize_t bulk = 0;\\r\\n# if defined(AES_GCM_ASM)\\r\\nif (len >= 16 && AES_GCM_ASM(gctx)) {\\r\\nif (CRYPTO_gcm128_decrypt(&gctx->gcm, NULL, NULL, 0))\\r\\nreturn -1;\\r\\nbulk = AES_gcm_decrypt(in, out, len,\\r\\ngctx->gcm.key,\\r\\ngctx->gcm.Yi.c, gctx->gcm.Xi.u);\\r\\ngctx->gcm.len.u[1] += bulk;\\r\\n}\\r\\n# endif\\r\\nif (CRYPTO_gcm128_decrypt_ctr32(&gctx->gcm,\\r\\nin + bulk,\\r\\nout + bulk,\\r\\nlen - bulk, gctx->ctr))\\r\\ngoto err;\\r\\n} else {\\r\\nsize_t bulk = 0;\\r\\n# if defined(AES_GCM_ASM2)\\r\\nif (len >= 16 && AES_GCM_ASM2(gctx)) {\\r\\nif (CRYPTO_gcm128_decrypt(&gctx->gcm, NULL, NULL, 0))\\r\\nreturn -1;\\r\\nbulk = AES_gcm_decrypt(in, out, len,\\r\\ngctx->gcm.key,\\r\\ngctx->gcm.Yi.c, gctx->gcm.Xi.u);\\r\\ngctx->gcm.len.u[1] += bulk;\\r\\n}\\r\\n# endif\\r\\nif (CRYPTO_gcm128_decrypt(&gctx->gcm,\\r\\nin + bulk, out + bulk, len - bulk))\\r\\ngoto err;\\r\\n}\\r\\nCRYPTO_gcm128_tag(&gctx->gcm, ctx->buf, EVP_GCM_TLS_TAG_LEN);\\r\\nif (memcmp(ctx->buf, in + len, EVP_GCM_TLS_TAG_LEN)) {\\r\\nOPENSSL_cleanse(out, len);\\r\\ngoto err;\\r\\n}\\r\\nrv = len;\\r\\n}\\r\\nerr:\\r\\ngctx->iv_set = 0;\\r\\ngctx->tls_aad_len = -1;\\r\\nreturn rv;\\r\\n}\\r\\nstatic int aes_gcm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_GCM_CTX *gctx = ctx->cipher_data;\\r\\nif (!gctx->key_set)\\r\\nreturn -1;\\r\\nif (gctx->tls_aad_len >= 0)\\r\\nreturn aes_gcm_tls_cipher(ctx, out, in, len);\\r\\nif (!gctx->iv_set)\\r\\nreturn -1;\\r\\nif (in) {\\r\\nif (out == NULL) {\\r\\nif (CRYPTO_gcm128_aad(&gctx->gcm, in, len))\\r\\nreturn -1;\\r\\n} else if (ctx->encrypt) {\\r\\nif (gctx->ctr) {\\r\\nsize_t bulk = 0;\\r\\n# if defined(AES_GCM_ASM)\\r\\nif (len >= 32 && AES_GCM_ASM(gctx)) {\\r\\nsize_t res = (16 - gctx->gcm.mres) % 16;\\r\\nif (CRYPTO_gcm128_encrypt(&gctx->gcm, in, out, res))\\r\\nreturn -1;\\r\\nbulk = AES_gcm_encrypt(in + res,\\r\\nout + res, len - res,\\r\\ngctx->gcm.key, gctx->gcm.Yi.c,\\r\\ngctx->gcm.Xi.u);\\r\\ngctx->gcm.len.u[1] += bulk;\\r\\nbulk += res;\\r\\n}\\r\\n# endif\\r\\nif (CRYPTO_gcm128_encrypt_ctr32(&gctx->gcm,\\r\\nin + bulk,\\r\\nout + bulk,\\r\\nlen - bulk, gctx->ctr))\\r\\nreturn -1;\\r\\n} else {\\r\\nsize_t bulk = 0;\\r\\n# if defined(AES_GCM_ASM2)\\r\\nif (len >= 32 && AES_GCM_ASM2(gctx)) {\\r\\nsize_t res = (16 - gctx->gcm.mres) % 16;\\r\\nif (CRYPTO_gcm128_encrypt(&gctx->gcm, in, out, res))\\r\\nreturn -1;\\r\\nbulk = AES_gcm_encrypt(in + res,\\r\\nout + res, len - res,\\r\\ngctx->gcm.key, gctx->gcm.Yi.c,\\r\\ngctx->gcm.Xi.u);\\r\\ngctx->gcm.len.u[1] += bulk;\\r\\nbulk += res;\\r\\n}\\r\\n# endif\\r\\nif (CRYPTO_gcm128_encrypt(&gctx->gcm,\\r\\nin + bulk, out + bulk, len - bulk))\\r\\nreturn -1;\\r\\n}\\r\\n} else {\\r\\nif (gctx->ctr) {\\r\\nsize_t bulk = 0;\\r\\n# if defined(AES_GCM_ASM)\\r\\nif (len >= 16 && AES_GCM_ASM(gctx)) {\\r\\nsize_t res = (16 - gctx->gcm.mres) % 16;\\r\\nif (CRYPTO_gcm128_decrypt(&gctx->gcm, in, out, res))\\r\\nreturn -1;\\r\\nbulk = AES_gcm_decrypt(in + res,\\r\\nout + res, len - res,\\r\\ngctx->gcm.key,\\r\\ngctx->gcm.Yi.c, gctx->gcm.Xi.u);\\r\\ngctx->gcm.len.u[1] += bulk;\\r\\nbulk += res;\\r\\n}\\r\\n# endif\\r\\nif (CRYPTO_gcm128_decrypt_ctr32(&gctx->gcm,\\r\\nin + bulk,\\r\\nout + bulk,\\r\\nlen - bulk, gctx->ctr))\\r\\nreturn -1;\\r\\n} else {\\r\\nsize_t bulk = 0;\\r\\n# if defined(AES_GCM_ASM2)\\r\\nif (len >= 16 && AES_GCM_ASM2(gctx)) {\\r\\nsize_t res = (16 - gctx->gcm.mres) % 16;\\r\\nif (CRYPTO_gcm128_decrypt(&gctx->gcm, in, out, res))\\r\\nreturn -1;\\r\\nbulk = AES_gcm_decrypt(in + res,\\r\\nout + res, len - res,\\r\\ngctx->gcm.key,\\r\\ngctx->gcm.Yi.c, gctx->gcm.Xi.u);\\r\\ngctx->gcm.len.u[1] += bulk;\\r\\nbulk += res;\\r\\n}\\r\\n# endif\\r\\nif (CRYPTO_gcm128_decrypt(&gctx->gcm,\\r\\nin + bulk, out + bulk, len - bulk))\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn len;\\r\\n} else {\\r\\nif (!ctx->encrypt) {\\r\\nif (gctx->taglen < 0)\\r\\nreturn -1;\\r\\nif (CRYPTO_gcm128_finish(&gctx->gcm, ctx->buf, gctx->taglen) != 0)\\r\\nreturn -1;\\r\\ngctx->iv_set = 0;\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_gcm128_tag(&gctx->gcm, ctx->buf, 16);\\r\\ngctx->taglen = 16;\\r\\ngctx->iv_set = 0;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nstatic int aes_xts_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nEVP_AES_XTS_CTX *xctx = c->cipher_data;\\r\\nif (type == EVP_CTRL_COPY) {\\r\\nEVP_CIPHER_CTX *out = ptr;\\r\\nEVP_AES_XTS_CTX *xctx_out = out->cipher_data;\\r\\nif (xctx->xts.key1) {\\r\\nif (xctx->xts.key1 != &xctx->ks1)\\r\\nreturn 0;\\r\\nxctx_out->xts.key1 = &xctx_out->ks1;\\r\\n}\\r\\nif (xctx->xts.key2) {\\r\\nif (xctx->xts.key2 != &xctx->ks2)\\r\\nreturn 0;\\r\\nxctx_out->xts.key2 = &xctx_out->ks2;\\r\\n}\\r\\nreturn 1;\\r\\n} else if (type != EVP_CTRL_INIT)\\r\\nreturn -1;\\r\\nxctx->xts.key1 = NULL;\\r\\nxctx->xts.key2 = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_xts_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_XTS_CTX *xctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key)\\r\\ndo {\\r\\n# ifdef AES_XTS_ASM\\r\\nxctx->stream = enc ? AES_xts_encrypt : AES_xts_decrypt;\\r\\n# else\\r\\nxctx->stream = NULL;\\r\\n# endif\\r\\n# ifdef HWAES_CAPABLE\\r\\nif (HWAES_CAPABLE) {\\r\\nif (enc) {\\r\\nHWAES_set_encrypt_key(key, ctx->key_len * 4,\\r\\n&xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) HWAES_encrypt;\\r\\n} else {\\r\\nHWAES_set_decrypt_key(key, ctx->key_len * 4,\\r\\n&xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) HWAES_decrypt;\\r\\n}\\r\\nHWAES_set_encrypt_key(key + ctx->key_len / 2,\\r\\nctx->key_len * 4, &xctx->ks2.ks);\\r\\nxctx->xts.block2 = (block128_f) HWAES_encrypt;\\r\\nxctx->xts.key1 = &xctx->ks1;\\r\\nbreak;\\r\\n} else\\r\\n# endif\\r\\n# ifdef BSAES_CAPABLE\\r\\nif (BSAES_CAPABLE)\\r\\nxctx->stream = enc ? bsaes_xts_encrypt : bsaes_xts_decrypt;\\r\\nelse\\r\\n# endif\\r\\n# ifdef VPAES_CAPABLE\\r\\nif (VPAES_CAPABLE) {\\r\\nif (enc) {\\r\\nvpaes_set_encrypt_key(key, ctx->key_len * 4,\\r\\n&xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) vpaes_encrypt;\\r\\n} else {\\r\\nvpaes_set_decrypt_key(key, ctx->key_len * 4,\\r\\n&xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) vpaes_decrypt;\\r\\n}\\r\\nvpaes_set_encrypt_key(key + ctx->key_len / 2,\\r\\nctx->key_len * 4, &xctx->ks2.ks);\\r\\nxctx->xts.block2 = (block128_f) vpaes_encrypt;\\r\\nxctx->xts.key1 = &xctx->ks1;\\r\\nbreak;\\r\\n} else\\r\\n# endif\\r\\n(void)0;\\r\\nif (enc) {\\r\\nAES_set_encrypt_key(key, ctx->key_len * 4, &xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) AES_encrypt;\\r\\n} else {\\r\\nAES_set_decrypt_key(key, ctx->key_len * 4, &xctx->ks1.ks);\\r\\nxctx->xts.block1 = (block128_f) AES_decrypt;\\r\\n}\\r\\nAES_set_encrypt_key(key + ctx->key_len / 2,\\r\\nctx->key_len * 4, &xctx->ks2.ks);\\r\\nxctx->xts.block2 = (block128_f) AES_encrypt;\\r\\nxctx->xts.key1 = &xctx->ks1;\\r\\n} while (0);\\r\\nif (iv) {\\r\\nxctx->xts.key2 = &xctx->ks2;\\r\\nmemcpy(ctx->iv, iv, 16);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_xts_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_XTS_CTX *xctx = ctx->cipher_data;\\r\\nif (!xctx->xts.key1 || !xctx->xts.key2)\\r\\nreturn 0;\\r\\nif (!out || !in || len < AES_BLOCK_SIZE)\\r\\nreturn 0;\\r\\nif (xctx->stream)\\r\\n(*xctx->stream) (in, out, len,\\r\\nxctx->xts.key1, xctx->xts.key2, ctx->iv);\\r\\nelse if (CRYPTO_xts128_encrypt(&xctx->xts, ctx->iv, in, out, len,\\r\\nctx->encrypt))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nEVP_AES_CCM_CTX *cctx = c->cipher_data;\\r\\nswitch (type) {\\r\\ncase EVP_CTRL_INIT:\\r\\ncctx->key_set = 0;\\r\\ncctx->iv_set = 0;\\r\\ncctx->L = 8;\\r\\ncctx->M = 12;\\r\\ncctx->tag_set = 0;\\r\\ncctx->len_set = 0;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_CCM_SET_IVLEN:\\r\\narg = 15 - arg;\\r\\ncase EVP_CTRL_CCM_SET_L:\\r\\nif (arg < 2 || arg > 8)\\r\\nreturn 0;\\r\\ncctx->L = arg;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_CCM_SET_TAG:\\r\\nif ((arg & 1) || arg < 4 || arg > 16)\\r\\nreturn 0;\\r\\nif ((c->encrypt && ptr) || (!c->encrypt && !ptr))\\r\\nreturn 0;\\r\\nif (ptr) {\\r\\ncctx->tag_set = 1;\\r\\nmemcpy(c->buf, ptr, arg);\\r\\n}\\r\\ncctx->M = arg;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_CCM_GET_TAG:\\r\\nif (!c->encrypt || !cctx->tag_set)\\r\\nreturn 0;\\r\\nif (!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg))\\r\\nreturn 0;\\r\\ncctx->tag_set = 0;\\r\\ncctx->iv_set = 0;\\r\\ncctx->len_set = 0;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_COPY:\\r\\n{\\r\\nEVP_CIPHER_CTX *out = ptr;\\r\\nEVP_AES_CCM_CTX *cctx_out = out->cipher_data;\\r\\nif (cctx->ccm.key) {\\r\\nif (cctx->ccm.key != &cctx->ks)\\r\\nreturn 0;\\r\\ncctx_out->ccm.key = &cctx_out->ks;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nstatic int aes_ccm_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_CCM_CTX *cctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key)\\r\\ndo {\\r\\n# ifdef HWAES_CAPABLE\\r\\nif (HWAES_CAPABLE) {\\r\\nHWAES_set_encrypt_key(key, ctx->key_len * 8, &cctx->ks.ks);\\r\\nCRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,\\r\\n&cctx->ks, (block128_f) HWAES_encrypt);\\r\\ncctx->str = NULL;\\r\\ncctx->key_set = 1;\\r\\nbreak;\\r\\n} else\\r\\n# endif\\r\\n# ifdef VPAES_CAPABLE\\r\\nif (VPAES_CAPABLE) {\\r\\nvpaes_set_encrypt_key(key, ctx->key_len * 8, &cctx->ks.ks);\\r\\nCRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,\\r\\n&cctx->ks, (block128_f) vpaes_encrypt);\\r\\ncctx->str = NULL;\\r\\ncctx->key_set = 1;\\r\\nbreak;\\r\\n}\\r\\n# endif\\r\\nAES_set_encrypt_key(key, ctx->key_len * 8, &cctx->ks.ks);\\r\\nCRYPTO_ccm128_init(&cctx->ccm, cctx->M, cctx->L,\\r\\n&cctx->ks, (block128_f) AES_encrypt);\\r\\ncctx->str = NULL;\\r\\ncctx->key_set = 1;\\r\\n} while (0);\\r\\nif (iv) {\\r\\nmemcpy(ctx->iv, iv, 15 - cctx->L);\\r\\ncctx->iv_set = 1;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_ccm_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_CCM_CTX *cctx = ctx->cipher_data;\\r\\nCCM128_CONTEXT *ccm = &cctx->ccm;\\r\\nif (!cctx->iv_set && !cctx->key_set)\\r\\nreturn -1;\\r\\nif (!ctx->encrypt && !cctx->tag_set)\\r\\nreturn -1;\\r\\nif (!out) {\\r\\nif (!in) {\\r\\nif (CRYPTO_ccm128_setiv(ccm, ctx->iv, 15 - cctx->L, len))\\r\\nreturn -1;\\r\\ncctx->len_set = 1;\\r\\nreturn len;\\r\\n}\\r\\nif (!cctx->len_set && len)\\r\\nreturn -1;\\r\\nCRYPTO_ccm128_aad(ccm, in, len);\\r\\nreturn len;\\r\\n}\\r\\nif (!in)\\r\\nreturn 0;\\r\\nif (!cctx->len_set) {\\r\\nif (CRYPTO_ccm128_setiv(ccm, ctx->iv, 15 - cctx->L, len))\\r\\nreturn -1;\\r\\ncctx->len_set = 1;\\r\\n}\\r\\nif (ctx->encrypt) {\\r\\nif (cctx->str ? CRYPTO_ccm128_encrypt_ccm64(ccm, in, out, len,\\r\\ncctx->str) :\\r\\nCRYPTO_ccm128_encrypt(ccm, in, out, len))\\r\\nreturn -1;\\r\\ncctx->tag_set = 1;\\r\\nreturn len;\\r\\n} else {\\r\\nint rv = -1;\\r\\nif (cctx->str ? !CRYPTO_ccm128_decrypt_ccm64(ccm, in, out, len,\\r\\ncctx->str) :\\r\\n!CRYPTO_ccm128_decrypt(ccm, in, out, len)) {\\r\\nunsigned char tag[16];\\r\\nif (CRYPTO_ccm128_tag(ccm, tag, cctx->M)) {\\r\\nif (!memcmp(tag, ctx->buf, cctx->M))\\r\\nrv = len;\\r\\n}\\r\\n}\\r\\nif (rv == -1)\\r\\nOPENSSL_cleanse(out, len);\\r\\ncctx->iv_set = 0;\\r\\ncctx->tag_set = 0;\\r\\ncctx->len_set = 0;\\r\\nreturn rv;\\r\\n}\\r\\n}\\r\\nstatic int aes_wrap_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_WRAP_CTX *wctx = ctx->cipher_data;\\r\\nif (!iv && !key)\\r\\nreturn 1;\\r\\nif (key) {\\r\\nif (ctx->encrypt)\\r\\nAES_set_encrypt_key(key, ctx->key_len * 8, &wctx->ks.ks);\\r\\nelse\\r\\nAES_set_decrypt_key(key, ctx->key_len * 8, &wctx->ks.ks);\\r\\nif (!iv)\\r\\nwctx->iv = NULL;\\r\\n}\\r\\nif (iv) {\\r\\nmemcpy(ctx->iv, iv, 8);\\r\\nwctx->iv = ctx->iv;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aes_wrap_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inlen)\\r\\n{\\r\\nEVP_AES_WRAP_CTX *wctx = ctx->cipher_data;\\r\\nsize_t rv;\\r\\nif (!in)\\r\\nreturn 0;\\r\\nif (inlen % 8)\\r\\nreturn -1;\\r\\nif (ctx->encrypt && inlen < 8)\\r\\nreturn -1;\\r\\nif (!ctx->encrypt && inlen < 16)\\r\\nreturn -1;\\r\\nif (!out) {\\r\\nif (ctx->encrypt)\\r\\nreturn inlen + 8;\\r\\nelse\\r\\nreturn inlen - 8;\\r\\n}\\r\\nif (ctx->encrypt)\\r\\nrv = CRYPTO_128_wrap(&wctx->ks.ks, wctx->iv, out, in, inlen,\\r\\n(block128_f) AES_encrypt);\\r\\nelse\\r\\nrv = CRYPTO_128_unwrap(&wctx->ks.ks, wctx->iv, out, in, inlen,\\r\\n(block128_f) AES_decrypt);\\r\\nreturn rv ? (int)rv : -1;\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_128_wrap(void)\\r\\n{\\r\\nreturn &aes_128_wrap;\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_192_wrap(void)\\r\\n{\\r\\nreturn &aes_192_wrap;\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_256_wrap(void)\\r\\n{\\r\\nreturn &aes_256_wrap;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_asn1pars_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i, badops = 0, offset = 0, ret = 1, j;\\r\\nunsigned int length = 0;\\r\\nlong num, tmplen;\\r\\nBIO *in = NULL, *out = NULL, *b64 = NULL, *derout = NULL;\\r\\nint informat, indent = 0, noout = 0, dump = 0;\\r\\nchar *infile = NULL, *str = NULL, *prog, *oidfile = NULL, *derfile = NULL;\\r\\nchar *genstr = NULL, *genconf = NULL;\\r\\nunsigned char *tmpbuf;\\r\\nconst unsigned char *ctmpbuf;\\r\\nBUF_MEM *buf = NULL;\\r\\nSTACK_OF(OPENSSL_STRING) *osk = NULL;\\r\\nASN1_TYPE *at = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nif ((osk = sk_OPENSSL_STRING_new_null()) == NULL) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nderfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-i\") == 0) {\\r\\nindent = 1;\\r\\n} else if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-oid\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noidfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-offset\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noffset = atoi(*(++argv));\\r\\n} else if (strcmp(*argv, \"-length\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nlength = atoi(*(++argv));\\r\\nif (length == 0)\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-dump\") == 0) {\\r\\ndump = -1;\\r\\n} else if (strcmp(*argv, \"-dlimit\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ndump = atoi(*(++argv));\\r\\nif (dump <= 0)\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-strparse\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsk_OPENSSL_STRING_push(osk, *(++argv));\\r\\n} else if (strcmp(*argv, \"-genstr\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ngenstr = *(++argv);\\r\\n} else if (strcmp(*argv, \"-genconf\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ngenconf = *(++argv);\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - one of DER PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -out arg output file (output format is always DER\\n\");\\r\\nBIO_printf(bio_err, \" -noout arg don't produce any output\\n\");\\r\\nBIO_printf(bio_err, \" -offset arg offset into file\\n\");\\r\\nBIO_printf(bio_err, \" -length arg length of section in file\\n\");\\r\\nBIO_printf(bio_err, \" -i indent entries\\n\");\\r\\nBIO_printf(bio_err, \" -dump dump unknown data in hex form\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -dlimit arg dump the first arg bytes of unknown data in hex form\\n\");\\r\\nBIO_printf(bio_err, \" -oid file file of extra oid definitions\\n\");\\r\\nBIO_printf(bio_err, \" -strparse offset\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" a series of these can be used to 'dig' into multiple\\n\");\\r\\nBIO_printf(bio_err, \" ASN1 blob wrappings\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -genstr str string to generate ASN1 structure from\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -genconf file file to generate ASN1 structure from\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\nif (oidfile != NULL) {\\r\\nif (BIO_read_filename(in, oidfile) <= 0) {\\r\\nBIO_printf(bio_err, \"problems opening %s\\n\", oidfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nOBJ_create_objects(in);\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (derfile) {\\r\\nif (!(derout = BIO_new_file(derfile, \"wb\"))) {\\r\\nBIO_printf(bio_err, \"problems opening %s\\n\", derfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif ((buf = BUF_MEM_new()) == NULL)\\r\\ngoto end;\\r\\nif (!BUF_MEM_grow(buf, BUFSIZ * 8))\\r\\ngoto end;\\r\\nif (genstr || genconf) {\\r\\nnum = do_generate(bio_err, genstr, genconf, buf);\\r\\nif (num < 0) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nelse {\\r\\nif (informat == FORMAT_PEM) {\\r\\nBIO *tmp;\\r\\nif ((b64 = BIO_new(BIO_f_base64())) == NULL)\\r\\ngoto end;\\r\\nBIO_push(b64, in);\\r\\ntmp = in;\\r\\nin = b64;\\r\\nb64 = tmp;\\r\\n}\\r\\nnum = 0;\\r\\nfor (;;) {\\r\\nif (!BUF_MEM_grow(buf, (int)num + BUFSIZ))\\r\\ngoto end;\\r\\ni = BIO_read(in, &(buf->data[num]), BUFSIZ);\\r\\nif (i <= 0)\\r\\nbreak;\\r\\nnum += i;\\r\\n}\\r\\n}\\r\\nstr = buf->data;\\r\\nif (sk_OPENSSL_STRING_num(osk)) {\\r\\ntmpbuf = (unsigned char *)str;\\r\\ntmplen = num;\\r\\nfor (i = 0; i < sk_OPENSSL_STRING_num(osk); i++) {\\r\\nASN1_TYPE *atmp;\\r\\nint typ;\\r\\nj = atoi(sk_OPENSSL_STRING_value(osk, i));\\r\\nif (j == 0) {\\r\\nBIO_printf(bio_err, \"'%s' is an invalid number\\n\",\\r\\nsk_OPENSSL_STRING_value(osk, i));\\r\\ncontinue;\\r\\n}\\r\\ntmpbuf += j;\\r\\ntmplen -= j;\\r\\natmp = at;\\r\\nctmpbuf = tmpbuf;\\r\\nat = d2i_ASN1_TYPE(NULL, &ctmpbuf, tmplen);\\r\\nASN1_TYPE_free(atmp);\\r\\nif (!at) {\\r\\nBIO_printf(bio_err, \"Error parsing structure\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ntyp = ASN1_TYPE_get(at);\\r\\nif ((typ == V_ASN1_OBJECT)\\r\\n|| (typ == V_ASN1_NULL)) {\\r\\nBIO_printf(bio_err, \"Can't parse %s type\\n\",\\r\\ntyp == V_ASN1_NULL ? \"NULL\" : \"OBJECT\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ntmpbuf = at->value.asn1_string->data;\\r\\ntmplen = at->value.asn1_string->length;\\r\\n}\\r\\nstr = (char *)tmpbuf;\\r\\nnum = tmplen;\\r\\n}\\r\\nif (offset >= num) {\\r\\nBIO_printf(bio_err, \"Error: offset too large\\n\");\\r\\ngoto end;\\r\\n}\\r\\nnum -= offset;\\r\\nif ((length == 0) || ((long)length > num))\\r\\nlength = (unsigned int)num;\\r\\nif (derout) {\\r\\nif (BIO_write(derout, str + offset, length) != (int)length) {\\r\\nBIO_printf(bio_err, \"Error writing output\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!noout &&\\r\\n!ASN1_parse_dump(out, (unsigned char *)&(str[offset]), length,\\r\\nindent, dump)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nBIO_free(derout);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (b64 != NULL)\\r\\nBIO_free(b64);\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nif (buf != NULL)\\r\\nBUF_MEM_free(buf);\\r\\nif (at != NULL)\\r\\nASN1_TYPE_free(at);\\r\\nif (osk != NULL)\\r\\nsk_OPENSSL_STRING_free(osk);\\r\\nOBJ_cleanup();\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int do_generate(BIO *bio, char *genstr, char *genconf, BUF_MEM *buf)\\r\\n{\\r\\nCONF *cnf = NULL;\\r\\nint len;\\r\\nlong errline;\\r\\nunsigned char *p;\\r\\nASN1_TYPE *atyp = NULL;\\r\\nif (genconf) {\\r\\ncnf = NCONF_new(NULL);\\r\\nif (!NCONF_load(cnf, genconf, &errline))\\r\\ngoto conferr;\\r\\nif (!genstr)\\r\\ngenstr = NCONF_get_string(cnf, \"default\", \"asn1\");\\r\\nif (!genstr) {\\r\\nBIO_printf(bio, \"Can't find 'asn1' in '%s'\\n\", genconf);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\natyp = ASN1_generate_nconf(genstr, cnf);\\r\\nNCONF_free(cnf);\\r\\ncnf = NULL;\\r\\nif (!atyp)\\r\\nreturn -1;\\r\\nlen = i2d_ASN1_TYPE(atyp, NULL);\\r\\nif (len <= 0)\\r\\ngoto err;\\r\\nif (!BUF_MEM_grow(buf, len))\\r\\ngoto err;\\r\\np = (unsigned char *)buf->data;\\r\\ni2d_ASN1_TYPE(atyp, &p);\\r\\nASN1_TYPE_free(atyp);\\r\\nreturn len;\\r\\nconferr:\\r\\nif (errline > 0)\\r\\nBIO_printf(bio, \"Error on line %ld of config file '%s'\\n\",\\r\\nerrline, genconf);\\r\\nelse\\r\\nBIO_printf(bio, \"Error loading config file '%s'\\n\", genconf);\\r\\nerr:\\r\\nNCONF_free(cnf);\\r\\nASN1_TYPE_free(atyp);\\r\\nreturn -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_buff_c", "target": 0, "func": "BIO_METHOD *BIO_f_buffer(void)\\r\\n{\\r\\nreturn (&methods_buffer);\\r\\n}\\r\\nstatic int buffer_new(BIO *bi)\\r\\n{\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nctx = (BIO_F_BUFFER_CTX *)OPENSSL_malloc(sizeof(BIO_F_BUFFER_CTX));\\r\\nif (ctx == NULL)\\r\\nreturn (0);\\r\\nctx->ibuf = (char *)OPENSSL_malloc(DEFAULT_BUFFER_SIZE);\\r\\nif (ctx->ibuf == NULL) {\\r\\nOPENSSL_free(ctx);\\r\\nreturn (0);\\r\\n}\\r\\nctx->obuf = (char *)OPENSSL_malloc(DEFAULT_BUFFER_SIZE);\\r\\nif (ctx->obuf == NULL) {\\r\\nOPENSSL_free(ctx->ibuf);\\r\\nOPENSSL_free(ctx);\\r\\nreturn (0);\\r\\n}\\r\\nctx->ibuf_size = DEFAULT_BUFFER_SIZE;\\r\\nctx->obuf_size = DEFAULT_BUFFER_SIZE;\\r\\nctx->ibuf_len = 0;\\r\\nctx->ibuf_off = 0;\\r\\nctx->obuf_len = 0;\\r\\nctx->obuf_off = 0;\\r\\nbi->init = 1;\\r\\nbi->ptr = (char *)ctx;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int buffer_free(BIO *a)\\r\\n{\\r\\nBIO_F_BUFFER_CTX *b;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nb = (BIO_F_BUFFER_CTX *)a->ptr;\\r\\nif (b->ibuf != NULL)\\r\\nOPENSSL_free(b->ibuf);\\r\\nif (b->obuf != NULL)\\r\\nOPENSSL_free(b->obuf);\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr = NULL;\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int buffer_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint i, num = 0;\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nctx = (BIO_F_BUFFER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL))\\r\\nreturn (0);\\r\\nnum = 0;\\r\\nBIO_clear_retry_flags(b);\\r\\nstart:\\r\\ni = ctx->ibuf_len;\\r\\nif (i != 0) {\\r\\nif (i > outl)\\r\\ni = outl;\\r\\nmemcpy(out, &(ctx->ibuf[ctx->ibuf_off]), i);\\r\\nctx->ibuf_off += i;\\r\\nctx->ibuf_len -= i;\\r\\nnum += i;\\r\\nif (outl == i)\\r\\nreturn (num);\\r\\noutl -= i;\\r\\nout += i;\\r\\n}\\r\\nif (outl > ctx->ibuf_size) {\\r\\nfor (;;) {\\r\\ni = BIO_read(b->next_bio, out, outl);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0)\\r\\nreturn ((num > 0) ? num : i);\\r\\nif (i == 0)\\r\\nreturn (num);\\r\\n}\\r\\nnum += i;\\r\\nif (outl == i)\\r\\nreturn (num);\\r\\nout += i;\\r\\noutl -= i;\\r\\n}\\r\\n}\\r\\ni = BIO_read(b->next_bio, ctx->ibuf, ctx->ibuf_size);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0)\\r\\nreturn ((num > 0) ? num : i);\\r\\nif (i == 0)\\r\\nreturn (num);\\r\\n}\\r\\nctx->ibuf_off = 0;\\r\\nctx->ibuf_len = i;\\r\\ngoto start;\\r\\n}\\r\\nstatic int buffer_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint i, num = 0;\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nif ((in == NULL) || (inl <= 0))\\r\\nreturn (0);\\r\\nctx = (BIO_F_BUFFER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL))\\r\\nreturn (0);\\r\\nBIO_clear_retry_flags(b);\\r\\nstart:\\r\\ni = ctx->obuf_size - (ctx->obuf_len + ctx->obuf_off);\\r\\nif (i >= inl) {\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_off + ctx->obuf_len]), in, inl);\\r\\nctx->obuf_len += inl;\\r\\nreturn (num + inl);\\r\\n}\\r\\nif (ctx->obuf_len != 0) {\\r\\nif (i > 0) {\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_off + ctx->obuf_len]), in, i);\\r\\nin += i;\\r\\ninl -= i;\\r\\nnum += i;\\r\\nctx->obuf_len += i;\\r\\n}\\r\\nfor (;;) {\\r\\ni = BIO_write(b->next_bio, &(ctx->obuf[ctx->obuf_off]),\\r\\nctx->obuf_len);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0)\\r\\nreturn ((num > 0) ? num : i);\\r\\nif (i == 0)\\r\\nreturn (num);\\r\\n}\\r\\nctx->obuf_off += i;\\r\\nctx->obuf_len -= i;\\r\\nif (ctx->obuf_len == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nctx->obuf_off = 0;\\r\\nwhile (inl >= ctx->obuf_size) {\\r\\ni = BIO_write(b->next_bio, in, inl);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nif (i < 0)\\r\\nreturn ((num > 0) ? num : i);\\r\\nif (i == 0)\\r\\nreturn (num);\\r\\n}\\r\\nnum += i;\\r\\nin += i;\\r\\ninl -= i;\\r\\nif (inl == 0)\\r\\nreturn (num);\\r\\n}\\r\\ngoto start;\\r\\n}\\r\\nstatic long buffer_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nlong ret = 1;\\r\\nchar *p1, *p2;\\r\\nint r, i, *ip;\\r\\nint ibs, obs;\\r\\nctx = (BIO_F_BUFFER_CTX *)b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->ibuf_off = 0;\\r\\nctx->ibuf_len = 0;\\r\\nctx->obuf_off = 0;\\r\\nctx->obuf_len = 0;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret = (long)ctx->obuf_len;\\r\\nbreak;\\r\\ncase BIO_C_GET_BUFF_NUM_LINES:\\r\\nret = 0;\\r\\np1 = ctx->ibuf;\\r\\nfor (i = 0; i < ctx->ibuf_len; i++) {\\r\\nif (p1[ctx->ibuf_off + i] == '\\n')\\r\\nret++;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = (long)ctx->obuf_len;\\r\\nif (ret == 0) {\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret = (long)ctx->ibuf_len;\\r\\nif (ret == 0) {\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_BUFF_READ_DATA:\\r\\nif (num > ctx->ibuf_size) {\\r\\np1 = OPENSSL_malloc((int)num);\\r\\nif (p1 == NULL)\\r\\ngoto malloc_error;\\r\\nif (ctx->ibuf != NULL)\\r\\nOPENSSL_free(ctx->ibuf);\\r\\nctx->ibuf = p1;\\r\\n}\\r\\nctx->ibuf_off = 0;\\r\\nctx->ibuf_len = (int)num;\\r\\nmemcpy(ctx->ibuf, ptr, (int)num);\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_SET_BUFF_SIZE:\\r\\nif (ptr != NULL) {\\r\\nip = (int *)ptr;\\r\\nif (*ip == 0) {\\r\\nibs = (int)num;\\r\\nobs = ctx->obuf_size;\\r\\n} else {\\r\\nibs = ctx->ibuf_size;\\r\\nobs = (int)num;\\r\\n}\\r\\n} else {\\r\\nibs = (int)num;\\r\\nobs = (int)num;\\r\\n}\\r\\np1 = ctx->ibuf;\\r\\np2 = ctx->obuf;\\r\\nif ((ibs > DEFAULT_BUFFER_SIZE) && (ibs != ctx->ibuf_size)) {\\r\\np1 = (char *)OPENSSL_malloc((int)num);\\r\\nif (p1 == NULL)\\r\\ngoto malloc_error;\\r\\n}\\r\\nif ((obs > DEFAULT_BUFFER_SIZE) && (obs != ctx->obuf_size)) {\\r\\np2 = (char *)OPENSSL_malloc((int)num);\\r\\nif (p2 == NULL) {\\r\\nif (p1 != ctx->ibuf)\\r\\nOPENSSL_free(p1);\\r\\ngoto malloc_error;\\r\\n}\\r\\n}\\r\\nif (ctx->ibuf != p1) {\\r\\nOPENSSL_free(ctx->ibuf);\\r\\nctx->ibuf = p1;\\r\\nctx->ibuf_off = 0;\\r\\nctx->ibuf_len = 0;\\r\\nctx->ibuf_size = ibs;\\r\\n}\\r\\nif (ctx->obuf != p2) {\\r\\nOPENSSL_free(ctx->obuf);\\r\\nctx->obuf = p2;\\r\\nctx->obuf_off = 0;\\r\\nctx->obuf_len = 0;\\r\\nctx->obuf_size = obs;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nif (ctx->obuf_len <= 0) {\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nfor (;;) {\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->obuf_len > 0) {\\r\\nr = BIO_write(b->next_bio,\\r\\n&(ctx->obuf[ctx->obuf_off]), ctx->obuf_len);\\r\\n#if 0\\r\\nfprintf(stderr, \"FLUSH [%3d] %3d -> %3d\\n\", ctx->obuf_off,\\r\\nctx->obuf_len, r);\\r\\n#endif\\r\\nBIO_copy_next_retry(b);\\r\\nif (r <= 0)\\r\\nreturn ((long)r);\\r\\nctx->obuf_off += r;\\r\\nctx->obuf_len -= r;\\r\\n} else {\\r\\nctx->obuf_len = 0;\\r\\nctx->obuf_off = 0;\\r\\nret = 1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio = (BIO *)ptr;\\r\\nif (!BIO_set_read_buffer_size(dbio, ctx->ibuf_size) ||\\r\\n!BIO_set_write_buffer_size(dbio, ctx->obuf_size))\\r\\nret = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\nmalloc_error:\\r\\nBIOerr(BIO_F_BUFFER_CTRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nstatic long buffer_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret = 1;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\nret = BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int buffer_gets(BIO *b, char *buf, int size)\\r\\n{\\r\\nBIO_F_BUFFER_CTX *ctx;\\r\\nint num = 0, i, flag;\\r\\nchar *p;\\r\\nctx = (BIO_F_BUFFER_CTX *)b->ptr;\\r\\nsize--;\\r\\nBIO_clear_retry_flags(b);\\r\\nfor (;;) {\\r\\nif (ctx->ibuf_len > 0) {\\r\\np = &(ctx->ibuf[ctx->ibuf_off]);\\r\\nflag = 0;\\r\\nfor (i = 0; (i < ctx->ibuf_len) && (i < size); i++) {\\r\\n*(buf++) = p[i];\\r\\nif (p[i] == '\\n') {\\r\\nflag = 1;\\r\\ni++;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nnum += i;\\r\\nsize -= i;\\r\\nctx->ibuf_len -= i;\\r\\nctx->ibuf_off += i;\\r\\nif (flag || size == 0) {\\r\\n*buf = '\\0';\\r\\nreturn (num);\\r\\n}\\r\\n} else {\\r\\ni = BIO_read(b->next_bio, ctx->ibuf, ctx->ibuf_size);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\n*buf = '\\0';\\r\\nif (i < 0)\\r\\nreturn ((num > 0) ? num : i);\\r\\nif (i == 0)\\r\\nreturn (num);\\r\\n}\\r\\nctx->ibuf_len = i;\\r\\nctx->ibuf_off = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int buffer_puts(BIO *b, const char *str)\\r\\n{\\r\\nreturn (buffer_write(b, str, strlen(str)));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cm_ameth_c", "target": 0, "func": "static int cmac_size(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn EVP_MAX_BLOCK_LENGTH;\\r\\n}\\r\\nstatic void cmac_key_free(EVP_PKEY *pkey)\\r\\n{\\r\\nCMAC_CTX *cmctx = (CMAC_CTX *)pkey->pkey.ptr;\\r\\nif (cmctx)\\r\\nCMAC_CTX_free(cmctx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pkeyutl_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL;\\r\\nchar *infile = NULL, *outfile = NULL, *sigfile = NULL;\\r\\nENGINE *e = NULL;\\r\\nint pkey_op = EVP_PKEY_OP_SIGN, key_type = KEY_PRIVKEY;\\r\\nint keyform = FORMAT_PEM, peerform = FORMAT_PEM;\\r\\nchar badarg = 0, rev = 0;\\r\\nchar hexdump = 0, asn1parse = 0;\\r\\nEVP_PKEY_CTX *ctx = NULL;\\r\\nchar *passargin = NULL;\\r\\nint keysize = -1;\\r\\nunsigned char *buf_in = NULL, *buf_out = NULL, *sig = NULL;\\r\\nsize_t buf_outlen;\\r\\nint buf_inlen = 0, siglen = -1;\\r\\nint ret = 1, rv = -1;\\r\\nargc--;\\r\\nargv++;\\r\\nif (!bio_err)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nERR_load_crypto_strings();\\r\\nOpenSSL_add_all_algorithms();\\r\\nwhile (argc >= 1) {\\r\\nif (!strcmp(*argv, \"-in\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\ninfile = *(++argv);\\r\\n} else if (!strcmp(*argv, \"-out\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\noutfile = *(++argv);\\r\\n} else if (!strcmp(*argv, \"-sigfile\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\nsigfile = *(++argv);\\r\\n} else if (!strcmp(*argv, \"-inkey\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse {\\r\\nctx = init_ctx(&keysize,\\r\\n*(++argv), keyform, key_type,\\r\\npassargin, pkey_op, e);\\r\\nif (!ctx) {\\r\\nBIO_puts(bio_err, \"Error initializing context\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nbadarg = 1;\\r\\n}\\r\\n}\\r\\n} else if (!strcmp(*argv, \"-peerkey\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse if (!setup_peer(bio_err, ctx, peerform, *(++argv)))\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*argv, \"-passin\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-peerform\") == 0) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\npeerform = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-keyform\") == 0) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\nkeyform = str2fmt(*(++argv));\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (!strcmp(*argv, \"-engine\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\ne = setup_engine(bio_err, *(++argv), 0);\\r\\n}\\r\\n#endif\\r\\nelse if (!strcmp(*argv, \"-pubin\"))\\r\\nkey_type = KEY_PUBKEY;\\r\\nelse if (!strcmp(*argv, \"-certin\"))\\r\\nkey_type = KEY_CERT;\\r\\nelse if (!strcmp(*argv, \"-asn1parse\"))\\r\\nasn1parse = 1;\\r\\nelse if (!strcmp(*argv, \"-hexdump\"))\\r\\nhexdump = 1;\\r\\nelse if (!strcmp(*argv, \"-sign\"))\\r\\npkey_op = EVP_PKEY_OP_SIGN;\\r\\nelse if (!strcmp(*argv, \"-verify\"))\\r\\npkey_op = EVP_PKEY_OP_VERIFY;\\r\\nelse if (!strcmp(*argv, \"-verifyrecover\"))\\r\\npkey_op = EVP_PKEY_OP_VERIFYRECOVER;\\r\\nelse if (!strcmp(*argv, \"-rev\"))\\r\\nrev = 1;\\r\\nelse if (!strcmp(*argv, \"-encrypt\"))\\r\\npkey_op = EVP_PKEY_OP_ENCRYPT;\\r\\nelse if (!strcmp(*argv, \"-decrypt\"))\\r\\npkey_op = EVP_PKEY_OP_DECRYPT;\\r\\nelse if (!strcmp(*argv, \"-derive\"))\\r\\npkey_op = EVP_PKEY_OP_DERIVE;\\r\\nelse if (strcmp(*argv, \"-pkeyopt\") == 0) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse if (!ctx) {\\r\\nBIO_puts(bio_err, \"-pkeyopt command before -inkey\\n\");\\r\\nbadarg = 1;\\r\\n} else if (pkey_ctrl_string(ctx, *(++argv)) <= 0) {\\r\\nBIO_puts(bio_err, \"parameter setting error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nbadarg = 1;\\r\\nif (badarg) {\\r\\nusage();\\r\\ngoto end;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (!ctx) {\\r\\nusage();\\r\\ngoto end;\\r\\n}\\r\\nif (sigfile && (pkey_op != EVP_PKEY_OP_VERIFY)) {\\r\\nBIO_puts(bio_err, \"Signature file specified for non verify\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!sigfile && (pkey_op == EVP_PKEY_OP_VERIFY)) {\\r\\nBIO_puts(bio_err, \"No signature file specified for verify\\n\");\\r\\ngoto end;\\r\\n}\\r\\napp_RAND_load_file(NULL, bio_err, 0);\\r\\nif (pkey_op != EVP_PKEY_OP_DERIVE) {\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file(infile, \"rb\"))) {\\r\\nBIO_puts(bio_err, \"Error Opening Input File\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\n}\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file(outfile, \"wb\"))) {\\r\\nBIO_printf(bio_err, \"Error Creating Output File\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (sigfile) {\\r\\nBIO *sigbio = BIO_new_file(sigfile, \"rb\");\\r\\nif (!sigbio) {\\r\\nBIO_printf(bio_err, \"Can't open signature file %s\\n\", sigfile);\\r\\ngoto end;\\r\\n}\\r\\nsiglen = bio_to_mem(&sig, keysize * 10, sigbio);\\r\\nBIO_free(sigbio);\\r\\nif (siglen <= 0) {\\r\\nBIO_printf(bio_err, \"Error reading signature data\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (in) {\\r\\nbuf_inlen = bio_to_mem(&buf_in, keysize * 10, in);\\r\\nif (buf_inlen <= 0) {\\r\\nBIO_printf(bio_err, \"Error reading input Data\\n\");\\r\\nexit(1);\\r\\n}\\r\\nif (rev) {\\r\\nsize_t i;\\r\\nunsigned char ctmp;\\r\\nsize_t l = (size_t)buf_inlen;\\r\\nfor (i = 0; i < l / 2; i++) {\\r\\nctmp = buf_in[i];\\r\\nbuf_in[i] = buf_in[l - 1 - i];\\r\\nbuf_in[l - 1 - i] = ctmp;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (pkey_op == EVP_PKEY_OP_VERIFY) {\\r\\nrv = EVP_PKEY_verify(ctx, sig, (size_t)siglen,\\r\\nbuf_in, (size_t)buf_inlen);\\r\\nif (rv == 0)\\r\\nBIO_puts(out, \"Signature Verification Failure\\n\");\\r\\nelse if (rv == 1)\\r\\nBIO_puts(out, \"Signature Verified Successfully\\n\");\\r\\nif (rv >= 0)\\r\\ngoto end;\\r\\n} else {\\r\\nrv = do_keyop(ctx, pkey_op, NULL, (size_t *)&buf_outlen,\\r\\nbuf_in, (size_t)buf_inlen);\\r\\nif (rv > 0) {\\r\\nbuf_out = OPENSSL_malloc(buf_outlen);\\r\\nif (!buf_out)\\r\\nrv = -1;\\r\\nelse\\r\\nrv = do_keyop(ctx, pkey_op,\\r\\nbuf_out, (size_t *)&buf_outlen,\\r\\nbuf_in, (size_t)buf_inlen);\\r\\n}\\r\\n}\\r\\nif (rv <= 0) {\\r\\nBIO_printf(bio_err, \"Public Key operation error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nif (asn1parse) {\\r\\nif (!ASN1_parse_dump(out, buf_out, buf_outlen, 1, -1))\\r\\nERR_print_errors(bio_err);\\r\\n} else if (hexdump)\\r\\nBIO_dump(out, (char *)buf_out, buf_outlen);\\r\\nelse\\r\\nBIO_write(out, buf_out, buf_outlen);\\r\\nend:\\r\\nif (ctx)\\r\\nEVP_PKEY_CTX_free(ctx);\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nif (buf_in)\\r\\nOPENSSL_free(buf_in);\\r\\nif (buf_out)\\r\\nOPENSSL_free(buf_out);\\r\\nif (sig)\\r\\nOPENSSL_free(sig);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void usage()\\r\\n{\\r\\nBIO_printf(bio_err, \"Usage: pkeyutl [options]\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-sigfile file signature file (verify operation only)\\n\");\\r\\nBIO_printf(bio_err, \"-inkey file input key\\n\");\\r\\nBIO_printf(bio_err, \"-keyform arg private key format - default PEM\\n\");\\r\\nBIO_printf(bio_err, \"-pubin input is a public key\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-certin input is a certificate carrying a public key\\n\");\\r\\nBIO_printf(bio_err, \"-pkeyopt X:Y public key options\\n\");\\r\\nBIO_printf(bio_err, \"-sign sign with private key\\n\");\\r\\nBIO_printf(bio_err, \"-verify verify with public key\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-verifyrecover verify with public key, recover original data\\n\");\\r\\nBIO_printf(bio_err, \"-encrypt encrypt with public key\\n\");\\r\\nBIO_printf(bio_err, \"-decrypt decrypt with private key\\n\");\\r\\nBIO_printf(bio_err, \"-derive derive shared secret\\n\");\\r\\nBIO_printf(bio_err, \"-hexdump hex dump output\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \"-passin arg pass phrase source\\n\");\\r\\n}\\r\\nstatic EVP_PKEY_CTX *init_ctx(int *pkeysize,\\r\\nchar *keyfile, int keyform, int key_type,\\r\\nchar *passargin, int pkey_op, ENGINE *e)\\r\\n{\\r\\nEVP_PKEY *pkey = NULL;\\r\\nEVP_PKEY_CTX *ctx = NULL;\\r\\nchar *passin = NULL;\\r\\nint rv = -1;\\r\\nX509 *x;\\r\\nif (((pkey_op == EVP_PKEY_OP_SIGN) || (pkey_op == EVP_PKEY_OP_DECRYPT)\\r\\n|| (pkey_op == EVP_PKEY_OP_DERIVE))\\r\\n&& (key_type != KEY_PRIVKEY)) {\\r\\nBIO_printf(bio_err, \"A private key is needed for this operation\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nswitch (key_type) {\\r\\ncase KEY_PRIVKEY:\\r\\npkey = load_key(bio_err, keyfile, keyform, 0,\\r\\npassin, e, \"Private Key\");\\r\\nbreak;\\r\\ncase KEY_PUBKEY:\\r\\npkey = load_pubkey(bio_err, keyfile, keyform, 0,\\r\\nNULL, e, \"Public Key\");\\r\\nbreak;\\r\\ncase KEY_CERT:\\r\\nx = load_cert(bio_err, keyfile, keyform, NULL, e, \"Certificate\");\\r\\nif (x) {\\r\\npkey = X509_get_pubkey(x);\\r\\nX509_free(x);\\r\\n}\\r\\nbreak;\\r\\n}\\r\\n*pkeysize = EVP_PKEY_size(pkey);\\r\\nif (!pkey)\\r\\ngoto end;\\r\\nctx = EVP_PKEY_CTX_new(pkey, e);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (!ctx)\\r\\ngoto end;\\r\\nswitch (pkey_op) {\\r\\ncase EVP_PKEY_OP_SIGN:\\r\\nrv = EVP_PKEY_sign_init(ctx);\\r\\nbreak;\\r\\ncase EVP_PKEY_OP_VERIFY:\\r\\nrv = EVP_PKEY_verify_init(ctx);\\r\\nbreak;\\r\\ncase EVP_PKEY_OP_VERIFYRECOVER:\\r\\nrv = EVP_PKEY_verify_recover_init(ctx);\\r\\nbreak;\\r\\ncase EVP_PKEY_OP_ENCRYPT:\\r\\nrv = EVP_PKEY_encrypt_init(ctx);\\r\\nbreak;\\r\\ncase EVP_PKEY_OP_DECRYPT:\\r\\nrv = EVP_PKEY_decrypt_init(ctx);\\r\\nbreak;\\r\\ncase EVP_PKEY_OP_DERIVE:\\r\\nrv = EVP_PKEY_derive_init(ctx);\\r\\nbreak;\\r\\n}\\r\\nif (rv <= 0) {\\r\\nEVP_PKEY_CTX_free(ctx);\\r\\nctx = NULL;\\r\\n}\\r\\nend:\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nreturn ctx;\\r\\n}\\r\\nstatic int setup_peer(BIO *err, EVP_PKEY_CTX *ctx, int peerform,\\r\\nconst char *file)\\r\\n{\\r\\nEVP_PKEY *peer = NULL;\\r\\nint ret;\\r\\nif (!ctx) {\\r\\nBIO_puts(err, \"-peerkey command before -inkey\\n\");\\r\\nreturn 0;\\r\\n}\\r\\npeer = load_pubkey(bio_err, file, peerform, 0, NULL, NULL, \"Peer Key\");\\r\\nif (!peer) {\\r\\nBIO_printf(bio_err, \"Error reading peer key %s\\n\", file);\\r\\nERR_print_errors(err);\\r\\nreturn 0;\\r\\n}\\r\\nret = EVP_PKEY_derive_set_peer(ctx, peer);\\r\\nEVP_PKEY_free(peer);\\r\\nif (ret <= 0)\\r\\nERR_print_errors(err);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int do_keyop(EVP_PKEY_CTX *ctx, int pkey_op,\\r\\nunsigned char *out, size_t *poutlen,\\r\\nunsigned char *in, size_t inlen)\\r\\n{\\r\\nint rv = 0;\\r\\nswitch (pkey_op) {\\r\\ncase EVP_PKEY_OP_VERIFYRECOVER:\\r\\nrv = EVP_PKEY_verify_recover(ctx, out, poutlen, in, inlen);\\r\\nbreak;\\r\\ncase EVP_PKEY_OP_SIGN:\\r\\nrv = EVP_PKEY_sign(ctx, out, poutlen, in, inlen);\\r\\nbreak;\\r\\ncase EVP_PKEY_OP_ENCRYPT:\\r\\nrv = EVP_PKEY_encrypt(ctx, out, poutlen, in, inlen);\\r\\nbreak;\\r\\ncase EVP_PKEY_OP_DECRYPT:\\r\\nrv = EVP_PKEY_decrypt(ctx, out, poutlen, in, inlen);\\r\\nbreak;\\r\\ncase EVP_PKEY_OP_DERIVE:\\r\\nrv = EVP_PKEY_derive(ctx, out, poutlen);\\r\\nbreak;\\r\\n}\\r\\nreturn rv;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dhparam_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nDH *dh = NULL;\\r\\nint i, badops = 0, text = 0;\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nint dsaparam = 0;\\r\\n# endif\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat, check = 0, noout = 0, C = 0, ret = 1;\\r\\nchar *infile, *outfile, *prog;\\r\\nchar *inrand = NULL;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n# endif\\r\\nint num = 0, g = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninfile = NULL;\\r\\noutfile = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-check\") == 0)\\r\\ncheck = 1;\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nelse if (strcmp(*argv, \"-dsaparam\") == 0)\\r\\ndsaparam = 1;\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-C\") == 0)\\r\\nC = 1;\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-2\") == 0)\\r\\ng = 2;\\r\\nelse if (strcmp(*argv, \"-5\") == 0)\\r\\ng = 5;\\r\\nelse if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninrand = *(++argv);\\r\\n} else if (((sscanf(*argv, \"%d\", &num) == 0) || (num <= 0)))\\r\\ngoto bad;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] [numbits]\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - one of DER PEM\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -outform arg output format - one of DER PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nBIO_printf(bio_err,\\r\\n\" -dsaparam read or generate DSA parameters, convert to DH\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \" -check check the DH parameters\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -text print a text form of the DH parameters\\n\");\\r\\nBIO_printf(bio_err, \" -C Output C code\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -2 generate parameters using 2 as the generator value\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -5 generate parameters using 5 as the generator value\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" numbits number of bits in to generate (default 2048)\\n\");\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\\r\\n\" - load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\nBIO_printf(bio_err, \" -noout no output\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (g && !num)\\r\\nnum = DEFBITS;\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nif (dsaparam) {\\r\\nif (g) {\\r\\nBIO_printf(bio_err,\\r\\n\"generator may not be chosen for DSA parameters\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\n# endif\\r\\n{\\r\\nif (num && !g)\\r\\ng = 2;\\r\\n}\\r\\nif (num) {\\r\\nBN_GENCB cb;\\r\\nBN_GENCB_set(&cb, dh_cb, bio_err);\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL) {\\r\\nBIO_printf(bio_err,\\r\\n\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nif (dsaparam) {\\r\\nDSA *dsa = DSA_new();\\r\\nBIO_printf(bio_err,\\r\\n\"Generating DSA parameters, %d bit long prime\\n\", num);\\r\\nif (!dsa\\r\\n|| !DSA_generate_parameters_ex(dsa, num, NULL, 0, NULL, NULL,\\r\\n&cb)) {\\r\\nif (dsa)\\r\\nDSA_free(dsa);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ndh = DSA_dup_DH(dsa);\\r\\nDSA_free(dsa);\\r\\nif (dh == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\n# endif\\r\\n{\\r\\ndh = DH_new();\\r\\nBIO_printf(bio_err,\\r\\n\"Generating DH parameters, %d bit long safe prime, generator %d\\n\",\\r\\nnum, g);\\r\\nBIO_printf(bio_err, \"This is going to take a long time\\n\");\\r\\nif (!dh || !DH_generate_parameters_ex(dh, num, g, &cb)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\n} else {\\r\\nin = BIO_new(BIO_s_file());\\r\\nif (in == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat != FORMAT_ASN1 && informat != FORMAT_PEM) {\\r\\nBIO_printf(bio_err, \"bad input format specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nif (dsaparam) {\\r\\nDSA *dsa;\\r\\nif (informat == FORMAT_ASN1)\\r\\ndsa = d2i_DSAparams_bio(in, NULL);\\r\\nelse\\r\\ndsa = PEM_read_bio_DSAparams(in, NULL, NULL, NULL);\\r\\nif (dsa == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load DSA parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ndh = DSA_dup_DH(dsa);\\r\\nDSA_free(dsa);\\r\\nif (dh == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\n# endif\\r\\n{\\r\\nif (informat == FORMAT_ASN1)\\r\\ndh = d2i_DHparams_bio(in, NULL);\\r\\nelse\\r\\ndh = PEM_read_bio_DHparams(in, NULL, NULL, NULL);\\r\\nif (dh == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load DH parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nout = BIO_new(BIO_s_file());\\r\\nif (out == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text) {\\r\\nDHparams_print(out, dh);\\r\\n}\\r\\nif (check) {\\r\\nif (!DH_check(dh, &i)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (i & DH_CHECK_P_NOT_PRIME)\\r\\nprintf(\"p value is not prime\\n\");\\r\\nif (i & DH_CHECK_P_NOT_SAFE_PRIME)\\r\\nprintf(\"p value is not a safe prime\\n\");\\r\\nif (i & DH_UNABLE_TO_CHECK_GENERATOR)\\r\\nprintf(\"unable to check the generator value\\n\");\\r\\nif (i & DH_NOT_SUITABLE_GENERATOR)\\r\\nprintf(\"the g value is not a generator\\n\");\\r\\nif (i == 0)\\r\\nprintf(\"DH parameters appear to be ok.\\n\");\\r\\n}\\r\\nif (C) {\\r\\nunsigned char *data;\\r\\nint len, l, bits;\\r\\nlen = BN_num_bytes(dh->p);\\r\\nbits = BN_num_bits(dh->p);\\r\\ndata = (unsigned char *)OPENSSL_malloc(len);\\r\\nif (data == NULL) {\\r\\nperror(\"OPENSSL_malloc\");\\r\\ngoto end;\\r\\n}\\r\\nprintf(\"#ifndef HEADER_DH_H\\n\"\\r\\n\"#include <openssl/dh.h>\\n\" \"#endif\\n\");\\r\\nprintf(\"DH *get_dh%d()\\n\\t{\\n\", bits);\\r\\nl = BN_bn2bin(dh->p, data);\\r\\nprintf(\"\\tstatic unsigned char dh%d_p[]={\", bits);\\r\\nfor (i = 0; i < l; i++) {\\r\\nif ((i % 12) == 0)\\r\\nprintf(\"\\n\\t\\t\");\\r\\nprintf(\"0x%02X,\", data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t\\t};\\n\");\\r\\nl = BN_bn2bin(dh->g, data);\\r\\nprintf(\"\\tstatic unsigned char dh%d_g[]={\", bits);\\r\\nfor (i = 0; i < l; i++) {\\r\\nif ((i % 12) == 0)\\r\\nprintf(\"\\n\\t\\t\");\\r\\nprintf(\"0x%02X,\", data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t\\t};\\n\");\\r\\nprintf(\"\\tDH *dh;\\n\\n\");\\r\\nprintf(\"\\tif ((dh=DH_new()) == NULL) return(NULL);\\n\");\\r\\nprintf(\"\\tdh->p=BN_bin2bn(dh%d_p,sizeof(dh%d_p),NULL);\\n\",\\r\\nbits, bits);\\r\\nprintf(\"\\tdh->g=BN_bin2bn(dh%d_g,sizeof(dh%d_g),NULL);\\n\",\\r\\nbits, bits);\\r\\nprintf(\"\\tif ((dh->p == NULL) || (dh->g == NULL))\\n\");\\r\\nprintf(\"\\t\\t{ DH_free(dh); return(NULL); }\\n\");\\r\\nif (dh->length)\\r\\nprintf(\"\\tdh->length = %ld;\\n\", dh->length);\\r\\nprintf(\"\\treturn(dh);\\n\\t}\\n\");\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nif (!noout) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_DHparams_bio(out, dh);\\r\\nelse if (outformat == FORMAT_PEM) {\\r\\nif (dh->q)\\r\\ni = PEM_write_bio_DHxparams(out, dh);\\r\\nelse\\r\\ni = PEM_write_bio_DHparams(out, dh);\\r\\n} else {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write DH parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (dh != NULL)\\r\\nDH_free(dh);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK dh_cb(int p, int n, BN_GENCB *cb)\\r\\n{\\r\\nchar c = '*';\\r\\nif (p == 0)\\r\\nc = '.';\\r\\nif (p == 1)\\r\\nc = '+';\\r\\nif (p == 2)\\r\\nc = '*';\\r\\nif (p == 3)\\r\\nc = '\\n';\\r\\nBIO_write(cb->arg, &c, 1);\\r\\n(void)BIO_flush(cb->arg);\\r\\n# ifdef LINT\\r\\np = n;\\r\\n# endif\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_spkac_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint i, badops = 0, ret = 1;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint verify = 0, noout = 0, pubkey = 0;\\r\\nchar *infile = NULL, *outfile = NULL, *prog;\\r\\nchar *passargin = NULL, *passin = NULL;\\r\\nconst char *spkac = \"SPKAC\", *spksect = \"default\";\\r\\nchar *spkstr = NULL;\\r\\nchar *challenge = NULL, *keyfile = NULL;\\r\\nCONF *conf = NULL;\\r\\nNETSCAPE_SPKI *spki = NULL;\\r\\nEVP_PKEY *pkey = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\napps_startup();\\r\\nif (!bio_err)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passin\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-key\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-challenge\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nchallenge = *(++argv);\\r\\n} else if (strcmp(*argv, \"-spkac\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nspkac = *(++argv);\\r\\n} else if (strcmp(*argv, \"-spksect\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nspksect = *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-pubkey\") == 0)\\r\\npubkey = 1;\\r\\nelse if (strcmp(*argv, \"-verify\") == 0)\\r\\nverify = 1;\\r\\nelse\\r\\nbadops = 1;\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options]\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -key arg create SPKAC using private key\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \" -challenge arg challenge string\\n\");\\r\\nBIO_printf(bio_err, \" -spkac arg alternative SPKAC name\\n\");\\r\\nBIO_printf(bio_err, \" -noout don't print SPKAC\\n\");\\r\\nBIO_printf(bio_err, \" -pubkey output public key\\n\");\\r\\nBIO_printf(bio_err, \" -verify verify SPKAC signature\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nif (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (keyfile) {\\r\\npkey = load_key(bio_err,\\r\\nstrcmp(keyfile, \"-\") ? keyfile : NULL,\\r\\nFORMAT_PEM, 1, passin, e, \"private key\");\\r\\nif (!pkey) {\\r\\ngoto end;\\r\\n}\\r\\nspki = NETSCAPE_SPKI_new();\\r\\nif (challenge)\\r\\nASN1_STRING_set(spki->spkac->challenge,\\r\\nchallenge, (int)strlen(challenge));\\r\\nNETSCAPE_SPKI_set_pubkey(spki, pkey);\\r\\nNETSCAPE_SPKI_sign(spki, pkey, EVP_md5());\\r\\nspkstr = NETSCAPE_SPKI_b64_encode(spki);\\r\\nif (outfile)\\r\\nout = BIO_new_file(outfile, \"w\");\\r\\nelse {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(out, \"SPKAC=%s\\n\", spkstr);\\r\\nOPENSSL_free(spkstr);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (infile)\\r\\nin = BIO_new_file(infile, \"r\");\\r\\nelse\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (!in) {\\r\\nBIO_printf(bio_err, \"Error opening input file\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nconf = NCONF_new(NULL);\\r\\ni = NCONF_load_bio(conf, in, NULL);\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"Error parsing config file\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nspkstr = NCONF_get_string(conf, spksect, spkac);\\r\\nif (!spkstr) {\\r\\nBIO_printf(bio_err, \"Can't find SPKAC called \\\"%s\\\"\\n\", spkac);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nspki = NETSCAPE_SPKI_b64_decode(spkstr, -1);\\r\\nif (!spki) {\\r\\nBIO_printf(bio_err, \"Error loading SPKAC\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile)\\r\\nout = BIO_new_file(outfile, \"w\");\\r\\nelse {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!noout)\\r\\nNETSCAPE_SPKI_print(out, spki);\\r\\npkey = NETSCAPE_SPKI_get_pubkey(spki);\\r\\nif (verify) {\\r\\ni = NETSCAPE_SPKI_verify(spki, pkey);\\r\\nif (i > 0)\\r\\nBIO_printf(bio_err, \"Signature OK\\n\");\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Signature Failure\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (pubkey)\\r\\nPEM_write_bio_PUBKEY(out, pkey);\\r\\nret = 0;\\r\\nend:\\r\\nNCONF_free(conf);\\r\\nNETSCAPE_SPKI_free(spki);\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_f_string_c", "target": 0, "func": "int i2a_ASN1_STRING(BIO *bp, ASN1_STRING *a, int type)\\r\\n{\\r\\nint i, n = 0;\\r\\nstatic const char *h = \"0123456789ABCDEF\";\\r\\nchar buf[2];\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (a->length == 0) {\\r\\nif (BIO_write(bp, \"0\", 1) != 1)\\r\\ngoto err;\\r\\nn = 1;\\r\\n} else {\\r\\nfor (i = 0; i < a->length; i++) {\\r\\nif ((i != 0) && (i % 35 == 0)) {\\r\\nif (BIO_write(bp, \"\\\\\\n\", 2) != 2)\\r\\ngoto err;\\r\\nn += 2;\\r\\n}\\r\\nbuf[0] = h[((unsigned char)a->data[i] >> 4) & 0x0f];\\r\\nbuf[1] = h[((unsigned char)a->data[i]) & 0x0f];\\r\\nif (BIO_write(bp, buf, 2) != 2)\\r\\ngoto err;\\r\\nn += 2;\\r\\n}\\r\\n}\\r\\nreturn (n);\\r\\nerr:\\r\\nreturn (-1);\\r\\n}\\r\\nint a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size)\\r\\n{\\r\\nint ret = 0;\\r\\nint i, j, k, m, n, again, bufsize;\\r\\nunsigned char *s = NULL, *sp;\\r\\nunsigned char *bufp;\\r\\nint num = 0, slen = 0, first = 1;\\r\\nbufsize = BIO_gets(bp, buf, size);\\r\\nfor (;;) {\\r\\nif (bufsize < 1) {\\r\\nif (first)\\r\\nbreak;\\r\\nelse\\r\\ngoto err_sl;\\r\\n}\\r\\nfirst = 0;\\r\\ni = bufsize;\\r\\nif (buf[i - 1] == '\\n')\\r\\nbuf[--i] = '\\0';\\r\\nif (i == 0)\\r\\ngoto err_sl;\\r\\nif (buf[i - 1] == '\\r')\\r\\nbuf[--i] = '\\0';\\r\\nif (i == 0)\\r\\ngoto err_sl;\\r\\nagain = (buf[i - 1] == '\\\\');\\r\\nfor (j = i - 1; j > 0; j--) {\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!(((buf[j] >= '0') && (buf[j] <= '9')) ||\\r\\n((buf[j] >= 'a') && (buf[j] <= 'f')) ||\\r\\n((buf[j] >= 'A') && (buf[j] <= 'F'))))\\r\\n#else\\r\\nif (!isxdigit(buf[j]))\\r\\n#endif\\r\\n{\\r\\ni = j;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf[i] = '\\0';\\r\\nif (i < 2)\\r\\ngoto err_sl;\\r\\nbufp = (unsigned char *)buf;\\r\\nk = 0;\\r\\ni -= again;\\r\\nif (i % 2 != 0) {\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING, ASN1_R_ODD_NUMBER_OF_CHARS);\\r\\ngoto err;\\r\\n}\\r\\ni /= 2;\\r\\nif (num + i > slen) {\\r\\nif (s == NULL)\\r\\nsp = (unsigned char *)OPENSSL_malloc((unsigned int)num +\\r\\ni * 2);\\r\\nelse\\r\\nsp = (unsigned char *)OPENSSL_realloc(s,\\r\\n(unsigned int)num +\\r\\ni * 2);\\r\\nif (sp == NULL) {\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING, ERR_R_MALLOC_FAILURE);\\r\\nif (s != NULL)\\r\\nOPENSSL_free(s);\\r\\ngoto err;\\r\\n}\\r\\ns = sp;\\r\\nslen = num + i * 2;\\r\\n}\\r\\nfor (j = 0; j < i; j++, k += 2) {\\r\\nfor (n = 0; n < 2; n++) {\\r\\nm = bufp[k + n];\\r\\nif ((m >= '0') && (m <= '9'))\\r\\nm -= '0';\\r\\nelse if ((m >= 'a') && (m <= 'f'))\\r\\nm = m - 'a' + 10;\\r\\nelse if ((m >= 'A') && (m <= 'F'))\\r\\nm = m - 'A' + 10;\\r\\nelse {\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING,\\r\\nASN1_R_NON_HEX_CHARACTERS);\\r\\ngoto err;\\r\\n}\\r\\ns[num + j] <<= 4;\\r\\ns[num + j] |= m;\\r\\n}\\r\\n}\\r\\nnum += i;\\r\\nif (again)\\r\\nbufsize = BIO_gets(bp, buf, size);\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nbs->length = num;\\r\\nbs->data = s;\\r\\nret = 1;\\r\\nerr:\\r\\nif (0) {\\r\\nerr_sl:\\r\\nASN1err(ASN1_F_A2I_ASN1_STRING, ASN1_R_SHORT_LINE);\\r\\n}\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec2_smpl_c", "target": 0, "func": "const EC_METHOD *EC_GF2m_simple_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nEC_FLAGS_DEFAULT_OCT,\\r\\nNID_X9_62_characteristic_two_field,\\r\\nec_GF2m_simple_group_init,\\r\\nec_GF2m_simple_group_finish,\\r\\nec_GF2m_simple_group_clear_finish,\\r\\nec_GF2m_simple_group_copy,\\r\\nec_GF2m_simple_group_set_curve,\\r\\nec_GF2m_simple_group_get_curve,\\r\\nec_GF2m_simple_group_get_degree,\\r\\nec_GF2m_simple_group_check_discriminant,\\r\\nec_GF2m_simple_point_init,\\r\\nec_GF2m_simple_point_finish,\\r\\nec_GF2m_simple_point_clear_finish,\\r\\nec_GF2m_simple_point_copy,\\r\\nec_GF2m_simple_point_set_to_infinity,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GF2m_simple_point_set_affine_coordinates,\\r\\nec_GF2m_simple_point_get_affine_coordinates,\\r\\n0, 0, 0,\\r\\nec_GF2m_simple_add,\\r\\nec_GF2m_simple_dbl,\\r\\nec_GF2m_simple_invert,\\r\\nec_GF2m_simple_is_at_infinity,\\r\\nec_GF2m_simple_is_on_curve,\\r\\nec_GF2m_simple_cmp,\\r\\nec_GF2m_simple_make_affine,\\r\\nec_GF2m_simple_points_make_affine,\\r\\nec_GF2m_simple_mul,\\r\\nec_GF2m_precompute_mult,\\r\\nec_GF2m_have_precompute_mult,\\r\\nec_GF2m_simple_field_mul,\\r\\nec_GF2m_simple_field_sqr,\\r\\nec_GF2m_simple_field_div,\\r\\n0 ,\\r\\n0 ,\\r\\n0\\r\\n};\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn fips_ec_gf2m_simple_method();\\r\\n# endif\\r\\nreturn &ret;\\r\\n}\\r\\nint ec_GF2m_simple_group_init(EC_GROUP *group)\\r\\n{\\r\\nBN_init(&group->field);\\r\\nBN_init(&group->a);\\r\\nBN_init(&group->b);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ec_GF2m_simple_group_finish(EC_GROUP *group)\\r\\n{\\r\\nBN_free(&group->field);\\r\\nBN_free(&group->a);\\r\\nBN_free(&group->b);\\r\\n}\\r\\nvoid ec_GF2m_simple_group_clear_finish(EC_GROUP *group)\\r\\n{\\r\\nBN_clear_free(&group->field);\\r\\nBN_clear_free(&group->a);\\r\\nBN_clear_free(&group->b);\\r\\ngroup->poly[0] = 0;\\r\\ngroup->poly[1] = 0;\\r\\ngroup->poly[2] = 0;\\r\\ngroup->poly[3] = 0;\\r\\ngroup->poly[4] = 0;\\r\\ngroup->poly[5] = -1;\\r\\n}\\r\\nint ec_GF2m_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\nint i;\\r\\nif (!BN_copy(&dest->field, &src->field))\\r\\nreturn 0;\\r\\nif (!BN_copy(&dest->a, &src->a))\\r\\nreturn 0;\\r\\nif (!BN_copy(&dest->b, &src->b))\\r\\nreturn 0;\\r\\ndest->poly[0] = src->poly[0];\\r\\ndest->poly[1] = src->poly[1];\\r\\ndest->poly[2] = src->poly[2];\\r\\ndest->poly[3] = src->poly[3];\\r\\ndest->poly[4] = src->poly[4];\\r\\ndest->poly[5] = src->poly[5];\\r\\nif (bn_wexpand(&dest->a, (int)(dest->poly[0] + BN_BITS2 - 1) / BN_BITS2)\\r\\n== NULL)\\r\\nreturn 0;\\r\\nif (bn_wexpand(&dest->b, (int)(dest->poly[0] + BN_BITS2 - 1) / BN_BITS2)\\r\\n== NULL)\\r\\nreturn 0;\\r\\nfor (i = dest->a.top; i < dest->a.dmax; i++)\\r\\ndest->a.d[i] = 0;\\r\\nfor (i = dest->b.top; i < dest->b.dmax; i++)\\r\\ndest->b.d[i] = 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GF2m_simple_group_set_curve(EC_GROUP *group,\\r\\nconst BIGNUM *p, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0, i;\\r\\nif (!BN_copy(&group->field, p))\\r\\ngoto err;\\r\\ni = BN_GF2m_poly2arr(&group->field, group->poly, 6) - 1;\\r\\nif ((i != 5) && (i != 3)) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE, EC_R_UNSUPPORTED_FIELD);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_GF2m_mod_arr(&group->a, a, group->poly))\\r\\ngoto err;\\r\\nif (bn_wexpand(&group->a, (int)(group->poly[0] + BN_BITS2 - 1) / BN_BITS2)\\r\\n== NULL)\\r\\ngoto err;\\r\\nfor (i = group->a.top; i < group->a.dmax; i++)\\r\\ngroup->a.d[i] = 0;\\r\\nif (!BN_GF2m_mod_arr(&group->b, b, group->poly))\\r\\ngoto err;\\r\\nif (bn_wexpand(&group->b, (int)(group->poly[0] + BN_BITS2 - 1) / BN_BITS2)\\r\\n== NULL)\\r\\ngoto err;\\r\\nfor (i = group->b.top; i < group->b.dmax; i++)\\r\\ngroup->b.d[i] = 0;\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p,\\r\\nBIGNUM *a, BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nif (p != NULL) {\\r\\nif (!BN_copy(p, &group->field))\\r\\nreturn 0;\\r\\n}\\r\\nif (a != NULL) {\\r\\nif (!BN_copy(a, &group->a))\\r\\ngoto err;\\r\\n}\\r\\nif (b != NULL) {\\r\\nif (!BN_copy(b, &group->b))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_group_get_degree(const EC_GROUP *group)\\r\\n{\\r\\nreturn BN_num_bits(&group->field) - 1;\\r\\n}\\r\\nint ec_GF2m_simple_group_check_discriminant(const EC_GROUP *group,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *b;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nif (b == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_arr(b, &group->b, group->poly))\\r\\ngoto err;\\r\\nif (BN_is_zero(b))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_point_init(EC_POINT *point)\\r\\n{\\r\\nBN_init(&point->X);\\r\\nBN_init(&point->Y);\\r\\nBN_init(&point->Z);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ec_GF2m_simple_point_finish(EC_POINT *point)\\r\\n{\\r\\nBN_free(&point->X);\\r\\nBN_free(&point->Y);\\r\\nBN_free(&point->Z);\\r\\n}\\r\\nvoid ec_GF2m_simple_point_clear_finish(EC_POINT *point)\\r\\n{\\r\\nBN_clear_free(&point->X);\\r\\nBN_clear_free(&point->Y);\\r\\nBN_clear_free(&point->Z);\\r\\npoint->Z_is_one = 0;\\r\\n}\\r\\nint ec_GF2m_simple_point_copy(EC_POINT *dest, const EC_POINT *src)\\r\\n{\\r\\nif (!BN_copy(&dest->X, &src->X))\\r\\nreturn 0;\\r\\nif (!BN_copy(&dest->Y, &src->Y))\\r\\nreturn 0;\\r\\nif (!BN_copy(&dest->Z, &src->Z))\\r\\nreturn 0;\\r\\ndest->Z_is_one = src->Z_is_one;\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GF2m_simple_point_set_to_infinity(const EC_GROUP *group,\\r\\nEC_POINT *point)\\r\\n{\\r\\npoint->Z_is_one = 0;\\r\\nBN_zero(&point->Z);\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GF2m_simple_point_set_affine_coordinates(const EC_GROUP *group,\\r\\nEC_POINT *point,\\r\\nconst BIGNUM *x,\\r\\nconst BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nif (x == NULL || y == NULL) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!BN_copy(&point->X, x))\\r\\ngoto err;\\r\\nBN_set_negative(&point->X, 0);\\r\\nif (!BN_copy(&point->Y, y))\\r\\ngoto err;\\r\\nBN_set_negative(&point->Y, 0);\\r\\nif (!BN_copy(&point->Z, BN_value_one()))\\r\\ngoto err;\\r\\nBN_set_negative(&point->Z, 0);\\r\\npoint->Z_is_one = 1;\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_point_get_affine_coordinates(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nif (EC_POINT_is_at_infinity(group, point)) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES,\\r\\nEC_R_POINT_AT_INFINITY);\\r\\nreturn 0;\\r\\n}\\r\\nif (BN_cmp(&point->Z, BN_value_one())) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (x != NULL) {\\r\\nif (!BN_copy(x, &point->X))\\r\\ngoto err;\\r\\nBN_set_negative(x, 0);\\r\\n}\\r\\nif (y != NULL) {\\r\\nif (!BN_copy(y, &point->Y))\\r\\ngoto err;\\r\\nBN_set_negative(y, 0);\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\\r\\nconst EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x0, *y0, *x1, *y1, *x2, *y2, *s, *t;\\r\\nint ret = 0;\\r\\nif (EC_POINT_is_at_infinity(group, a)) {\\r\\nif (!EC_POINT_copy(r, b))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (EC_POINT_is_at_infinity(group, b)) {\\r\\nif (!EC_POINT_copy(r, a))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx0 = BN_CTX_get(ctx);\\r\\ny0 = BN_CTX_get(ctx);\\r\\nx1 = BN_CTX_get(ctx);\\r\\ny1 = BN_CTX_get(ctx);\\r\\nx2 = BN_CTX_get(ctx);\\r\\ny2 = BN_CTX_get(ctx);\\r\\ns = BN_CTX_get(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\nif (t == NULL)\\r\\ngoto err;\\r\\nif (a->Z_is_one) {\\r\\nif (!BN_copy(x0, &a->X))\\r\\ngoto err;\\r\\nif (!BN_copy(y0, &a->Y))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, a, x0, y0, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (b->Z_is_one) {\\r\\nif (!BN_copy(x1, &b->X))\\r\\ngoto err;\\r\\nif (!BN_copy(y1, &b->Y))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, b, x1, y1, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (BN_GF2m_cmp(x0, x1)) {\\r\\nif (!BN_GF2m_add(t, x0, x1))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(s, y0, y1))\\r\\ngoto err;\\r\\nif (!group->meth->field_div(group, s, s, t, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, x2, s, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(x2, x2, &group->a))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(x2, x2, s))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(x2, x2, t))\\r\\ngoto err;\\r\\n} else {\\r\\nif (BN_GF2m_cmp(y0, y1) || BN_is_zero(x1)) {\\r\\nif (!EC_POINT_set_to_infinity(group, r))\\r\\ngoto err;\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (!group->meth->field_div(group, s, y1, x1, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(s, s, x1))\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, x2, s, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(x2, x2, s))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(x2, x2, &group->a))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_GF2m_add(y2, x1, x2))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, y2, y2, s, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(y2, y2, x2))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(y2, y2, y1))\\r\\ngoto err;\\r\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, r, x2, y2, ctx))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nreturn ec_GF2m_simple_add(group, r, a, a, ctx);\\r\\n}\\r\\nint ec_GF2m_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nif (EC_POINT_is_at_infinity(group, point) || BN_is_zero(&point->Y))\\r\\nreturn 1;\\r\\nif (!EC_POINT_make_affine(group, point, ctx))\\r\\nreturn 0;\\r\\nreturn BN_GF2m_add(&point->Y, &point->X, &point->Y);\\r\\n}\\r\\nint ec_GF2m_simple_is_at_infinity(const EC_GROUP *group,\\r\\nconst EC_POINT *point)\\r\\n{\\r\\nreturn BN_is_zero(&point->Z);\\r\\n}\\r\\nint ec_GF2m_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = -1;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *lh, *y2;\\r\\nint (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,\\r\\nconst BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nif (EC_POINT_is_at_infinity(group, point))\\r\\nreturn 1;\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\nif (!point->Z_is_one)\\r\\nreturn -1;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ny2 = BN_CTX_get(ctx);\\r\\nlh = BN_CTX_get(ctx);\\r\\nif (lh == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(lh, &point->X, &group->a))\\r\\ngoto err;\\r\\nif (!field_mul(group, lh, lh, &point->X, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(lh, lh, &point->Y))\\r\\ngoto err;\\r\\nif (!field_mul(group, lh, lh, &point->X, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(lh, lh, &group->b))\\r\\ngoto err;\\r\\nif (!field_sqr(group, y2, &point->Y, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(lh, lh, y2))\\r\\ngoto err;\\r\\nret = BN_is_zero(lh);\\r\\nerr:\\r\\nif (ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_cmp(const EC_GROUP *group, const EC_POINT *a,\\r\\nconst EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *aX, *aY, *bX, *bY;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint ret = -1;\\r\\nif (EC_POINT_is_at_infinity(group, a)) {\\r\\nreturn EC_POINT_is_at_infinity(group, b) ? 0 : 1;\\r\\n}\\r\\nif (EC_POINT_is_at_infinity(group, b))\\r\\nreturn 1;\\r\\nif (a->Z_is_one && b->Z_is_one) {\\r\\nreturn ((BN_cmp(&a->X, &b->X) == 0)\\r\\n&& BN_cmp(&a->Y, &b->Y) == 0) ? 0 : 1;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\naX = BN_CTX_get(ctx);\\r\\naY = BN_CTX_get(ctx);\\r\\nbX = BN_CTX_get(ctx);\\r\\nbY = BN_CTX_get(ctx);\\r\\nif (bY == NULL)\\r\\ngoto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, a, aX, aY, ctx))\\r\\ngoto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, b, bX, bY, ctx))\\r\\ngoto err;\\r\\nret = ((BN_cmp(aX, bX) == 0) && BN_cmp(aY, bY) == 0) ? 0 : 1;\\r\\nerr:\\r\\nif (ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_make_affine(const EC_GROUP *group, EC_POINT *point,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y;\\r\\nint ret = 0;\\r\\nif (point->Z_is_one || EC_POINT_is_at_infinity(group, point))\\r\\nreturn 1;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL)\\r\\ngoto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, point, x, y, ctx))\\r\\ngoto err;\\r\\nif (!BN_copy(&point->X, x))\\r\\ngoto err;\\r\\nif (!BN_copy(&point->Y, y))\\r\\ngoto err;\\r\\nif (!BN_one(&point->Z))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_points_make_affine(const EC_GROUP *group, size_t num,\\r\\nEC_POINT *points[], BN_CTX *ctx)\\r\\n{\\r\\nsize_t i;\\r\\nfor (i = 0; i < num; i++) {\\r\\nif (!group->meth->make_affine(group, points[i], ctx))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GF2m_simple_field_mul(const EC_GROUP *group, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_GF2m_mod_mul_arr(r, a, b, group->poly, ctx);\\r\\n}\\r\\nint ec_GF2m_simple_field_sqr(const EC_GROUP *group, BIGNUM *r,\\r\\nconst BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_GF2m_mod_sqr_arr(r, a, group->poly, ctx);\\r\\n}\\r\\nint ec_GF2m_simple_field_div(const EC_GROUP *group, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_GF2m_mod_div(r, a, b, &group->field, ctx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pem_sign_c", "target": 0, "func": "void PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)\\r\\n{\\r\\nEVP_DigestInit_ex(ctx, type, NULL);\\r\\n}\\r\\nvoid PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data, unsigned int count)\\r\\n{\\r\\nEVP_DigestUpdate(ctx, data, count);\\r\\n}\\r\\nint PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,\\r\\nunsigned int *siglen, EVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char *m;\\r\\nint i, ret = 0;\\r\\nunsigned int m_len;\\r\\nm = (unsigned char *)OPENSSL_malloc(EVP_PKEY_size(pkey) + 2);\\r\\nif (m == NULL) {\\r\\nPEMerr(PEM_F_PEM_SIGNFINAL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_SignFinal(ctx, m, &m_len, pkey) <= 0)\\r\\ngoto err;\\r\\ni = EVP_EncodeBlock(sigret, m, m_len);\\r\\n*siglen = i;\\r\\nret = 1;\\r\\nerr:\\r\\nif (m != NULL)\\r\\nOPENSSL_free(m);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_nseq_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nchar **args, *infile = NULL, *outfile = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint toseq = 0;\\r\\nX509 *x509 = NULL;\\r\\nNETSCAPE_CERT_SEQUENCE *seq = NULL;\\r\\nint i, ret = 1;\\r\\nint badarg = 0;\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nERR_load_crypto_strings();\\r\\nargs = argv + 1;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp(*args, \"-toseq\"))\\r\\ntoseq = 1;\\r\\nelse if (!strcmp(*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else\\r\\nbadarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\nBIO_printf(bio_err, \"Netscape certificate sequence utility\\n\");\\r\\nBIO_printf(bio_err, \"Usage nseq [options]\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err, \"-toseq output NS Sequence file\\n\");\\r\\nOPENSSL_EXIT(1);\\r\\n}\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file(infile, \"r\"))) {\\r\\nBIO_printf(bio_err, \"Can't open input file %s\\n\", infile);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file(outfile, \"w\"))) {\\r\\nBIO_printf(bio_err, \"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (toseq) {\\r\\nseq = NETSCAPE_CERT_SEQUENCE_new();\\r\\nseq->certs = sk_X509_new_null();\\r\\nwhile ((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL)))\\r\\nsk_X509_push(seq->certs, x509);\\r\\nif (!sk_X509_num(seq->certs)) {\\r\\nBIO_printf(bio_err, \"Error reading certs file %s\\n\", infile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nPEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (!(seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL))) {\\r\\nBIO_printf(bio_err, \"Error reading sequence file %s\\n\", infile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nfor (i = 0; i < sk_X509_num(seq->certs); i++) {\\r\\nx509 = sk_X509_value(seq->certs, i);\\r\\ndump_cert_text(out, x509);\\r\\nPEM_write_bio_X509(out, x509);\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nNETSCAPE_CERT_SEQUENCE_free(seq);\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_asn1_gen_c", "target": 0, "func": "ASN1_TYPE *ASN1_generate_nconf(char *str, CONF *nconf)\\r\\n{\\r\\nX509V3_CTX cnf;\\r\\nif (!nconf)\\r\\nreturn ASN1_generate_v3(str, NULL);\\r\\nX509V3_set_nconf(&cnf, nconf);\\r\\nreturn ASN1_generate_v3(str, &cnf);\\r\\n}\\r\\nASN1_TYPE *ASN1_generate_v3(char *str, X509V3_CTX *cnf)\\r\\n{\\r\\nASN1_TYPE *ret;\\r\\ntag_exp_arg asn1_tags;\\r\\ntag_exp_type *etmp;\\r\\nint i, len;\\r\\nunsigned char *orig_der = NULL, *new_der = NULL;\\r\\nconst unsigned char *cpy_start;\\r\\nunsigned char *p;\\r\\nconst unsigned char *cp;\\r\\nint cpy_len;\\r\\nlong hdr_len;\\r\\nint hdr_constructed = 0, hdr_tag, hdr_class;\\r\\nint r;\\r\\nasn1_tags.imp_tag = -1;\\r\\nasn1_tags.imp_class = -1;\\r\\nasn1_tags.format = ASN1_GEN_FORMAT_ASCII;\\r\\nasn1_tags.exp_count = 0;\\r\\nif (CONF_parse_list(str, ',', 1, asn1_cb, &asn1_tags) != 0)\\r\\nreturn NULL;\\r\\nif ((asn1_tags.utype == V_ASN1_SEQUENCE)\\r\\n|| (asn1_tags.utype == V_ASN1_SET)) {\\r\\nif (!cnf) {\\r\\nASN1err(ASN1_F_ASN1_GENERATE_V3,\\r\\nASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG);\\r\\nreturn NULL;\\r\\n}\\r\\nret = asn1_multi(asn1_tags.utype, asn1_tags.str, cnf);\\r\\n} else\\r\\nret = asn1_str2type(asn1_tags.str, asn1_tags.format, asn1_tags.utype);\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif ((asn1_tags.imp_tag == -1) && (asn1_tags.exp_count == 0))\\r\\nreturn ret;\\r\\ncpy_len = i2d_ASN1_TYPE(ret, &orig_der);\\r\\nASN1_TYPE_free(ret);\\r\\nret = NULL;\\r\\ncpy_start = orig_der;\\r\\nif (asn1_tags.imp_tag != -1) {\\r\\nr = ASN1_get_object(&cpy_start, &hdr_len, &hdr_tag, &hdr_class,\\r\\ncpy_len);\\r\\nif (r & 0x80)\\r\\ngoto err;\\r\\ncpy_len -= cpy_start - orig_der;\\r\\nif (r & 0x1) {\\r\\nhdr_constructed = 2;\\r\\nhdr_len = 0;\\r\\n} else\\r\\nhdr_constructed = r & V_ASN1_CONSTRUCTED;\\r\\nlen = ASN1_object_size(0, hdr_len, asn1_tags.imp_tag);\\r\\n} else\\r\\nlen = cpy_len;\\r\\nfor (i = 0, etmp = asn1_tags.exp_list + asn1_tags.exp_count - 1;\\r\\ni < asn1_tags.exp_count; i++, etmp--) {\\r\\nlen += etmp->exp_pad;\\r\\netmp->exp_len = len;\\r\\nlen = ASN1_object_size(0, len, etmp->exp_tag);\\r\\n}\\r\\nnew_der = OPENSSL_malloc(len);\\r\\nif (!new_der)\\r\\ngoto err;\\r\\np = new_der;\\r\\nfor (i = 0, etmp = asn1_tags.exp_list; i < asn1_tags.exp_count;\\r\\ni++, etmp++) {\\r\\nASN1_put_object(&p, etmp->exp_constructed, etmp->exp_len,\\r\\netmp->exp_tag, etmp->exp_class);\\r\\nif (etmp->exp_pad)\\r\\n*p++ = 0;\\r\\n}\\r\\nif (asn1_tags.imp_tag != -1) {\\r\\nif (asn1_tags.imp_class == V_ASN1_UNIVERSAL\\r\\n&& (asn1_tags.imp_tag == V_ASN1_SEQUENCE\\r\\n|| asn1_tags.imp_tag == V_ASN1_SET))\\r\\nhdr_constructed = V_ASN1_CONSTRUCTED;\\r\\nASN1_put_object(&p, hdr_constructed, hdr_len,\\r\\nasn1_tags.imp_tag, asn1_tags.imp_class);\\r\\n}\\r\\nmemcpy(p, cpy_start, cpy_len);\\r\\ncp = new_der;\\r\\nret = d2i_ASN1_TYPE(NULL, &cp, len);\\r\\nerr:\\r\\nif (orig_der)\\r\\nOPENSSL_free(orig_der);\\r\\nif (new_der)\\r\\nOPENSSL_free(new_der);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int asn1_cb(const char *elem, int len, void *bitstr)\\r\\n{\\r\\ntag_exp_arg *arg = bitstr;\\r\\nint i;\\r\\nint utype;\\r\\nint vlen = 0;\\r\\nconst char *p, *vstart = NULL;\\r\\nint tmp_tag, tmp_class;\\r\\nfor (i = 0, p = elem; i < len; p++, i++) {\\r\\nif (*p == ':') {\\r\\nvstart = p + 1;\\r\\nvlen = len - (vstart - elem);\\r\\nlen = p - elem;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nutype = asn1_str2tag(elem, len);\\r\\nif (utype == -1) {\\r\\nASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG);\\r\\nERR_add_error_data(2, \"tag=\", elem);\\r\\nreturn -1;\\r\\n}\\r\\nif (!(utype & ASN1_GEN_FLAG)) {\\r\\narg->utype = utype;\\r\\narg->str = vstart;\\r\\nif (!vstart && elem[len]) {\\r\\nASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE);\\r\\nreturn -1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nswitch (utype) {\\r\\ncase ASN1_GEN_FLAG_IMP:\\r\\nif (arg->imp_tag != -1) {\\r\\nASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING);\\r\\nreturn -1;\\r\\n}\\r\\nif (!parse_tagging(vstart, vlen, &arg->imp_tag, &arg->imp_class))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_EXP:\\r\\nif (!parse_tagging(vstart, vlen, &tmp_tag, &tmp_class))\\r\\nreturn -1;\\r\\nif (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_SEQWRAP:\\r\\nif (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_SETWRAP:\\r\\nif (!append_exp(arg, V_ASN1_SET, V_ASN1_UNIVERSAL, 1, 0, 1))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_BITWRAP:\\r\\nif (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_OCTWRAP:\\r\\nif (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1))\\r\\nreturn -1;\\r\\nbreak;\\r\\ncase ASN1_GEN_FLAG_FORMAT:\\r\\nif (!strncmp(vstart, \"ASCII\", 5))\\r\\narg->format = ASN1_GEN_FORMAT_ASCII;\\r\\nelse if (!strncmp(vstart, \"UTF8\", 4))\\r\\narg->format = ASN1_GEN_FORMAT_UTF8;\\r\\nelse if (!strncmp(vstart, \"HEX\", 3))\\r\\narg->format = ASN1_GEN_FORMAT_HEX;\\r\\nelse if (!strncmp(vstart, \"BITLIST\", 3))\\r\\narg->format = ASN1_GEN_FORMAT_BITLIST;\\r\\nelse {\\r\\nASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKOWN_FORMAT);\\r\\nreturn -1;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int parse_tagging(const char *vstart, int vlen, int *ptag, int *pclass)\\r\\n{\\r\\nchar erch[2];\\r\\nlong tag_num;\\r\\nchar *eptr;\\r\\nif (!vstart)\\r\\nreturn 0;\\r\\ntag_num = strtoul(vstart, &eptr, 10);\\r\\nif (eptr && *eptr && (eptr > vstart + vlen))\\r\\nreturn 0;\\r\\nif (tag_num < 0) {\\r\\nASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\n*ptag = tag_num;\\r\\nif (eptr)\\r\\nvlen -= eptr - vstart;\\r\\nelse\\r\\nvlen = 0;\\r\\nif (vlen) {\\r\\nswitch (*eptr) {\\r\\ncase 'U':\\r\\n*pclass = V_ASN1_UNIVERSAL;\\r\\nbreak;\\r\\ncase 'A':\\r\\n*pclass = V_ASN1_APPLICATION;\\r\\nbreak;\\r\\ncase 'P':\\r\\n*pclass = V_ASN1_PRIVATE;\\r\\nbreak;\\r\\ncase 'C':\\r\\n*pclass = V_ASN1_CONTEXT_SPECIFIC;\\r\\nbreak;\\r\\ndefault:\\r\\nerch[0] = *eptr;\\r\\nerch[1] = 0;\\r\\nASN1err(ASN1_F_PARSE_TAGGING, ASN1_R_INVALID_MODIFIER);\\r\\nERR_add_error_data(2, \"Char=\", erch);\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\n} else\\r\\n*pclass = V_ASN1_CONTEXT_SPECIFIC;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ASN1_TYPE *asn1_multi(int utype, const char *section, X509V3_CTX *cnf)\\r\\n{\\r\\nASN1_TYPE *ret = NULL;\\r\\nSTACK_OF(ASN1_TYPE) *sk = NULL;\\r\\nSTACK_OF(CONF_VALUE) *sect = NULL;\\r\\nunsigned char *der = NULL;\\r\\nint derlen;\\r\\nint i;\\r\\nsk = sk_ASN1_TYPE_new_null();\\r\\nif (!sk)\\r\\ngoto bad;\\r\\nif (section) {\\r\\nif (!cnf)\\r\\ngoto bad;\\r\\nsect = X509V3_get_section(cnf, (char *)section);\\r\\nif (!sect)\\r\\ngoto bad;\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(sect); i++) {\\r\\nASN1_TYPE *typ =\\r\\nASN1_generate_v3(sk_CONF_VALUE_value(sect, i)->value, cnf);\\r\\nif (!typ)\\r\\ngoto bad;\\r\\nif (!sk_ASN1_TYPE_push(sk, typ))\\r\\ngoto bad;\\r\\n}\\r\\n}\\r\\nif (utype == V_ASN1_SET)\\r\\nderlen = i2d_ASN1_SET_ANY(sk, &der);\\r\\nelse\\r\\nderlen = i2d_ASN1_SEQUENCE_ANY(sk, &der);\\r\\nif (derlen < 0)\\r\\ngoto bad;\\r\\nif (!(ret = ASN1_TYPE_new()))\\r\\ngoto bad;\\r\\nif (!(ret->value.asn1_string = ASN1_STRING_type_new(utype)))\\r\\ngoto bad;\\r\\nret->type = utype;\\r\\nret->value.asn1_string->data = der;\\r\\nret->value.asn1_string->length = derlen;\\r\\nder = NULL;\\r\\nbad:\\r\\nif (der)\\r\\nOPENSSL_free(der);\\r\\nif (sk)\\r\\nsk_ASN1_TYPE_pop_free(sk, ASN1_TYPE_free);\\r\\nif (sect)\\r\\nX509V3_section_free(cnf, sect);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int append_exp(tag_exp_arg *arg, int exp_tag, int exp_class,\\r\\nint exp_constructed, int exp_pad, int imp_ok)\\r\\n{\\r\\ntag_exp_type *exp_tmp;\\r\\nif ((arg->imp_tag != -1) && !imp_ok) {\\r\\nASN1err(ASN1_F_APPEND_EXP, ASN1_R_ILLEGAL_IMPLICIT_TAG);\\r\\nreturn 0;\\r\\n}\\r\\nif (arg->exp_count == ASN1_FLAG_EXP_MAX) {\\r\\nASN1err(ASN1_F_APPEND_EXP, ASN1_R_DEPTH_EXCEEDED);\\r\\nreturn 0;\\r\\n}\\r\\nexp_tmp = &arg->exp_list[arg->exp_count++];\\r\\nif (arg->imp_tag != -1) {\\r\\nexp_tmp->exp_tag = arg->imp_tag;\\r\\nexp_tmp->exp_class = arg->imp_class;\\r\\narg->imp_tag = -1;\\r\\narg->imp_class = -1;\\r\\n} else {\\r\\nexp_tmp->exp_tag = exp_tag;\\r\\nexp_tmp->exp_class = exp_class;\\r\\n}\\r\\nexp_tmp->exp_constructed = exp_constructed;\\r\\nexp_tmp->exp_pad = exp_pad;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_str2tag(const char *tagstr, int len)\\r\\n{\\r\\nunsigned int i;\\r\\nstatic const struct tag_name_st *tntmp, tnst[] = {\\r\\nASN1_GEN_STR(\"BOOL\", V_ASN1_BOOLEAN),\\r\\nASN1_GEN_STR(\"BOOLEAN\", V_ASN1_BOOLEAN),\\r\\nASN1_GEN_STR(\"NULL\", V_ASN1_NULL),\\r\\nASN1_GEN_STR(\"INT\", V_ASN1_INTEGER),\\r\\nASN1_GEN_STR(\"INTEGER\", V_ASN1_INTEGER),\\r\\nASN1_GEN_STR(\"ENUM\", V_ASN1_ENUMERATED),\\r\\nASN1_GEN_STR(\"ENUMERATED\", V_ASN1_ENUMERATED),\\r\\nASN1_GEN_STR(\"OID\", V_ASN1_OBJECT),\\r\\nASN1_GEN_STR(\"OBJECT\", V_ASN1_OBJECT),\\r\\nASN1_GEN_STR(\"UTCTIME\", V_ASN1_UTCTIME),\\r\\nASN1_GEN_STR(\"UTC\", V_ASN1_UTCTIME),\\r\\nASN1_GEN_STR(\"GENERALIZEDTIME\", V_ASN1_GENERALIZEDTIME),\\r\\nASN1_GEN_STR(\"GENTIME\", V_ASN1_GENERALIZEDTIME),\\r\\nASN1_GEN_STR(\"OCT\", V_ASN1_OCTET_STRING),\\r\\nASN1_GEN_STR(\"OCTETSTRING\", V_ASN1_OCTET_STRING),\\r\\nASN1_GEN_STR(\"BITSTR\", V_ASN1_BIT_STRING),\\r\\nASN1_GEN_STR(\"BITSTRING\", V_ASN1_BIT_STRING),\\r\\nASN1_GEN_STR(\"UNIVERSALSTRING\", V_ASN1_UNIVERSALSTRING),\\r\\nASN1_GEN_STR(\"UNIV\", V_ASN1_UNIVERSALSTRING),\\r\\nASN1_GEN_STR(\"IA5\", V_ASN1_IA5STRING),\\r\\nASN1_GEN_STR(\"IA5STRING\", V_ASN1_IA5STRING),\\r\\nASN1_GEN_STR(\"UTF8\", V_ASN1_UTF8STRING),\\r\\nASN1_GEN_STR(\"UTF8String\", V_ASN1_UTF8STRING),\\r\\nASN1_GEN_STR(\"BMP\", V_ASN1_BMPSTRING),\\r\\nASN1_GEN_STR(\"BMPSTRING\", V_ASN1_BMPSTRING),\\r\\nASN1_GEN_STR(\"VISIBLESTRING\", V_ASN1_VISIBLESTRING),\\r\\nASN1_GEN_STR(\"VISIBLE\", V_ASN1_VISIBLESTRING),\\r\\nASN1_GEN_STR(\"PRINTABLESTRING\", V_ASN1_PRINTABLESTRING),\\r\\nASN1_GEN_STR(\"PRINTABLE\", V_ASN1_PRINTABLESTRING),\\r\\nASN1_GEN_STR(\"T61\", V_ASN1_T61STRING),\\r\\nASN1_GEN_STR(\"T61STRING\", V_ASN1_T61STRING),\\r\\nASN1_GEN_STR(\"TELETEXSTRING\", V_ASN1_T61STRING),\\r\\nASN1_GEN_STR(\"GeneralString\", V_ASN1_GENERALSTRING),\\r\\nASN1_GEN_STR(\"GENSTR\", V_ASN1_GENERALSTRING),\\r\\nASN1_GEN_STR(\"NUMERIC\", V_ASN1_NUMERICSTRING),\\r\\nASN1_GEN_STR(\"NUMERICSTRING\", V_ASN1_NUMERICSTRING),\\r\\nASN1_GEN_STR(\"SEQUENCE\", V_ASN1_SEQUENCE),\\r\\nASN1_GEN_STR(\"SEQ\", V_ASN1_SEQUENCE),\\r\\nASN1_GEN_STR(\"SET\", V_ASN1_SET),\\r\\nASN1_GEN_STR(\"EXP\", ASN1_GEN_FLAG_EXP),\\r\\nASN1_GEN_STR(\"EXPLICIT\", ASN1_GEN_FLAG_EXP),\\r\\nASN1_GEN_STR(\"IMP\", ASN1_GEN_FLAG_IMP),\\r\\nASN1_GEN_STR(\"IMPLICIT\", ASN1_GEN_FLAG_IMP),\\r\\nASN1_GEN_STR(\"OCTWRAP\", ASN1_GEN_FLAG_OCTWRAP),\\r\\nASN1_GEN_STR(\"SEQWRAP\", ASN1_GEN_FLAG_SEQWRAP),\\r\\nASN1_GEN_STR(\"SETWRAP\", ASN1_GEN_FLAG_SETWRAP),\\r\\nASN1_GEN_STR(\"BITWRAP\", ASN1_GEN_FLAG_BITWRAP),\\r\\nASN1_GEN_STR(\"FORM\", ASN1_GEN_FLAG_FORMAT),\\r\\nASN1_GEN_STR(\"FORMAT\", ASN1_GEN_FLAG_FORMAT),\\r\\n};\\r\\nif (len == -1)\\r\\nlen = strlen(tagstr);\\r\\ntntmp = tnst;\\r\\nfor (i = 0; i < sizeof(tnst) / sizeof(struct tag_name_st); i++, tntmp++) {\\r\\nif ((len == tntmp->len) && !strncmp(tntmp->strnam, tagstr, len))\\r\\nreturn tntmp->tag;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nstatic ASN1_TYPE *asn1_str2type(const char *str, int format, int utype)\\r\\n{\\r\\nASN1_TYPE *atmp = NULL;\\r\\nCONF_VALUE vtmp;\\r\\nunsigned char *rdata;\\r\\nlong rdlen;\\r\\nint no_unused = 1;\\r\\nif (!(atmp = ASN1_TYPE_new())) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!str)\\r\\nstr = \"\";\\r\\nswitch (utype) {\\r\\ncase V_ASN1_NULL:\\r\\nif (str && *str) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_NULL_VALUE);\\r\\ngoto bad_form;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_BOOLEAN:\\r\\nif (format != ASN1_GEN_FORMAT_ASCII) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_NOT_ASCII_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nvtmp.name = NULL;\\r\\nvtmp.section = NULL;\\r\\nvtmp.value = (char *)str;\\r\\nif (!X509V3_get_value_bool(&vtmp, &atmp->value.boolean)) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BOOLEAN);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_ENUMERATED:\\r\\nif (format != ASN1_GEN_FORMAT_ASCII) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_INTEGER_NOT_ASCII_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (!(atmp->value.integer = s2i_ASN1_INTEGER(NULL, (char *)str))) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_INTEGER);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_OBJECT:\\r\\nif (format != ASN1_GEN_FORMAT_ASCII) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_OBJECT_NOT_ASCII_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (!(atmp->value.object = OBJ_txt2obj(str, 0))) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_OBJECT);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_UTCTIME:\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\nif (format != ASN1_GEN_FORMAT_ASCII) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_TIME_NOT_ASCII_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (!(atmp->value.asn1_string = ASN1_STRING_new())) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\ngoto bad_str;\\r\\n}\\r\\nif (!ASN1_STRING_set(atmp->value.asn1_string, str, -1)) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\ngoto bad_str;\\r\\n}\\r\\natmp->value.asn1_string->type = utype;\\r\\nif (!ASN1_TIME_check(atmp->value.asn1_string)) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_TIME_VALUE);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_BMPSTRING:\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\ncase V_ASN1_IA5STRING:\\r\\ncase V_ASN1_T61STRING:\\r\\ncase V_ASN1_UTF8STRING:\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\ncase V_ASN1_GENERALSTRING:\\r\\ncase V_ASN1_NUMERICSTRING:\\r\\nif (format == ASN1_GEN_FORMAT_ASCII)\\r\\nformat = MBSTRING_ASC;\\r\\nelse if (format == ASN1_GEN_FORMAT_UTF8)\\r\\nformat = MBSTRING_UTF8;\\r\\nelse {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (ASN1_mbstring_copy(&atmp->value.asn1_string, (unsigned char *)str,\\r\\n-1, format, ASN1_tag2bit(utype)) <= 0) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\ngoto bad_str;\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_BIT_STRING:\\r\\ncase V_ASN1_OCTET_STRING:\\r\\nif (!(atmp->value.asn1_string = ASN1_STRING_new())) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ERR_R_MALLOC_FAILURE);\\r\\ngoto bad_form;\\r\\n}\\r\\nif (format == ASN1_GEN_FORMAT_HEX) {\\r\\nif (!(rdata = string_to_hex((char *)str, &rdlen))) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_HEX);\\r\\ngoto bad_str;\\r\\n}\\r\\natmp->value.asn1_string->data = rdata;\\r\\natmp->value.asn1_string->length = rdlen;\\r\\natmp->value.asn1_string->type = utype;\\r\\n} else if (format == ASN1_GEN_FORMAT_ASCII)\\r\\nASN1_STRING_set(atmp->value.asn1_string, str, -1);\\r\\nelse if ((format == ASN1_GEN_FORMAT_BITLIST)\\r\\n&& (utype == V_ASN1_BIT_STRING)) {\\r\\nif (!CONF_parse_list\\r\\n(str, ',', 1, bitstr_cb, atmp->value.bit_string)) {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_LIST_ERROR);\\r\\ngoto bad_str;\\r\\n}\\r\\nno_unused = 0;\\r\\n} else {\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_ILLEGAL_BITSTRING_FORMAT);\\r\\ngoto bad_form;\\r\\n}\\r\\nif ((utype == V_ASN1_BIT_STRING) && no_unused) {\\r\\natmp->value.asn1_string->flags\\r\\n&= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\natmp->value.asn1_string->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nASN1err(ASN1_F_ASN1_STR2TYPE, ASN1_R_UNSUPPORTED_TYPE);\\r\\ngoto bad_str;\\r\\nbreak;\\r\\n}\\r\\natmp->type = utype;\\r\\nreturn atmp;\\r\\nbad_str:\\r\\nERR_add_error_data(2, \"string=\", str);\\r\\nbad_form:\\r\\nASN1_TYPE_free(atmp);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int bitstr_cb(const char *elem, int len, void *bitstr)\\r\\n{\\r\\nlong bitnum;\\r\\nchar *eptr;\\r\\nif (!elem)\\r\\nreturn 0;\\r\\nbitnum = strtoul(elem, &eptr, 10);\\r\\nif (eptr && *eptr && (eptr != elem + len))\\r\\nreturn 0;\\r\\nif (bitnum < 0) {\\r\\nASN1err(ASN1_F_BITSTR_CB, ASN1_R_INVALID_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ASN1_BIT_STRING_set_bit(bitstr, bitnum, 1)) {\\r\\nASN1err(ASN1_F_BITSTR_CB, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t1_lib_c", "target": 1, "func": "long tls1_default_timeout(void)\\r\\n{\\r\\nreturn (60 * 60 * 2);\\r\\n}\\r\\nint tls1_new(SSL *s)\\r\\n{\\r\\nif (!ssl3_new(s))\\r\\nreturn (0);\\r\\ns->method->ssl_clear(s);\\r\\nreturn (1);\\r\\n}\\r\\nvoid tls1_free(SSL *s)\\r\\n{\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s->tlsext_session_ticket) {\\r\\nOPENSSL_free(s->tlsext_session_ticket);\\r\\n}\\r\\n#endif\\r\\nssl3_free(s);\\r\\n}\\r\\nvoid tls1_clear(SSL *s)\\r\\n{\\r\\nssl3_clear(s);\\r\\ns->version = s->method->version;\\r\\n}\\r\\nint tls1_ec_curve_id2nid(int curve_id)\\r\\n{\\r\\nif ((curve_id < 1) || ((unsigned int)curve_id >\\r\\nsizeof(nid_list) / sizeof(nid_list[0])))\\r\\nreturn 0;\\r\\nreturn nid_list[curve_id - 1];\\r\\n}\\r\\nint tls1_ec_nid2curve_id(int nid)\\r\\n{\\r\\nswitch (nid) {\\r\\ncase NID_sect163k1:\\r\\nreturn 1;\\r\\ncase NID_sect163r1:\\r\\nreturn 2;\\r\\ncase NID_sect163r2:\\r\\nreturn 3;\\r\\ncase NID_sect193r1:\\r\\nreturn 4;\\r\\ncase NID_sect193r2:\\r\\nreturn 5;\\r\\ncase NID_sect233k1:\\r\\nreturn 6;\\r\\ncase NID_sect233r1:\\r\\nreturn 7;\\r\\ncase NID_sect239k1:\\r\\nreturn 8;\\r\\ncase NID_sect283k1:\\r\\nreturn 9;\\r\\ncase NID_sect283r1:\\r\\nreturn 10;\\r\\ncase NID_sect409k1:\\r\\nreturn 11;\\r\\ncase NID_sect409r1:\\r\\nreturn 12;\\r\\ncase NID_sect571k1:\\r\\nreturn 13;\\r\\ncase NID_sect571r1:\\r\\nreturn 14;\\r\\ncase NID_secp160k1:\\r\\nreturn 15;\\r\\ncase NID_secp160r1:\\r\\nreturn 16;\\r\\ncase NID_secp160r2:\\r\\nreturn 17;\\r\\ncase NID_secp192k1:\\r\\nreturn 18;\\r\\ncase NID_X9_62_prime192v1:\\r\\nreturn 19;\\r\\ncase NID_secp224k1:\\r\\nreturn 20;\\r\\ncase NID_secp224r1:\\r\\nreturn 21;\\r\\ncase NID_secp256k1:\\r\\nreturn 22;\\r\\ncase NID_X9_62_prime256v1:\\r\\nreturn 23;\\r\\ncase NID_secp384r1:\\r\\nreturn 24;\\r\\ncase NID_secp521r1:\\r\\nreturn 25;\\r\\ncase NID_brainpoolP256r1:\\r\\nreturn 26;\\r\\ncase NID_brainpoolP384r1:\\r\\nreturn 27;\\r\\ncase NID_brainpoolP512r1:\\r\\nreturn 28;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nstatic int tls1_get_curvelist(SSL *s, int sess,\\r\\nconst unsigned char **pcurves,\\r\\nsize_t *num_curves)\\r\\n{\\r\\nsize_t pcurveslen = 0;\\r\\nif (sess) {\\r\\n*pcurves = s->session->tlsext_ellipticcurvelist;\\r\\npcurveslen = s->session->tlsext_ellipticcurvelist_length;\\r\\n} else {\\r\\nswitch (tls1_suiteb(s)) {\\r\\ncase SSL_CERT_FLAG_SUITEB_128_LOS:\\r\\n*pcurves = suiteb_curves;\\r\\npcurveslen = sizeof(suiteb_curves);\\r\\nbreak;\\r\\ncase SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:\\r\\n*pcurves = suiteb_curves;\\r\\npcurveslen = 2;\\r\\nbreak;\\r\\ncase SSL_CERT_FLAG_SUITEB_192_LOS:\\r\\n*pcurves = suiteb_curves + 2;\\r\\npcurveslen = 2;\\r\\nbreak;\\r\\ndefault:\\r\\n*pcurves = s->tlsext_ellipticcurvelist;\\r\\npcurveslen = s->tlsext_ellipticcurvelist_length;\\r\\n}\\r\\nif (!*pcurves) {\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode()) {\\r\\n*pcurves = fips_curves_default;\\r\\n*pcurveslen = sizeof(fips_curves_default);\\r\\n} else\\r\\n# endif\\r\\n{\\r\\n*pcurves = eccurves_default;\\r\\npcurveslen = sizeof(eccurves_default);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (pcurveslen & 1) {\\r\\nSSLerr(SSL_F_TLS1_GET_CURVELIST, ERR_R_INTERNAL_ERROR);\\r\\n*num_curves = 0;\\r\\nreturn 0;\\r\\n} else {\\r\\n*num_curves = pcurveslen / 2;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nint tls1_check_curve(SSL *s, const unsigned char *p, size_t len)\\r\\n{\\r\\nconst unsigned char *curves;\\r\\nsize_t num_curves, i;\\r\\nunsigned int suiteb_flags = tls1_suiteb(s);\\r\\nif (len != 3 || p[0] != NAMED_CURVE_TYPE)\\r\\nreturn 0;\\r\\nif (suiteb_flags) {\\r\\nunsigned long cid = s->s3->tmp.new_cipher->id;\\r\\nif (p[1])\\r\\nreturn 0;\\r\\nif (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256) {\\r\\nif (p[2] != TLSEXT_curve_P_256)\\r\\nreturn 0;\\r\\n} else if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384) {\\r\\nif (p[2] != TLSEXT_curve_P_384)\\r\\nreturn 0;\\r\\n} else\\r\\nreturn 0;\\r\\n}\\r\\nif (!tls1_get_curvelist(s, 0, &curves, &num_curves))\\r\\nreturn 0;\\r\\nfor (i = 0; i < num_curves; i++, curves += 2) {\\r\\nif (p[1] == curves[0] && p[2] == curves[1])\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint tls1_shared_curve(SSL *s, int nmatch)\\r\\n{\\r\\nconst unsigned char *pref, *supp;\\r\\nsize_t num_pref, num_supp, i, j;\\r\\nint k;\\r\\nif (s->server == 0)\\r\\nreturn -1;\\r\\nif (nmatch == -2) {\\r\\nif (tls1_suiteb(s)) {\\r\\nunsigned long cid = s->s3->tmp.new_cipher->id;\\r\\nif (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)\\r\\nreturn NID_X9_62_prime256v1;\\r\\nif (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)\\r\\nreturn NID_secp384r1;\\r\\nreturn NID_undef;\\r\\n}\\r\\nnmatch = 0;\\r\\n}\\r\\nif (!tls1_get_curvelist\\r\\n(s, (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE) != 0, &supp,\\r\\n&num_supp))\\r\\nreturn nmatch == -1 ? 0 : NID_undef;\\r\\nif (!tls1_get_curvelist\\r\\n(s, !(s->options & SSL_OP_CIPHER_SERVER_PREFERENCE), &pref,\\r\\n&num_pref))\\r\\nreturn nmatch == -1 ? 0 : NID_undef;\\r\\nk = 0;\\r\\nfor (i = 0; i < num_pref; i++, pref += 2) {\\r\\nconst unsigned char *tsupp = supp;\\r\\nfor (j = 0; j < num_supp; j++, tsupp += 2) {\\r\\nif (pref[0] == tsupp[0] && pref[1] == tsupp[1]) {\\r\\nif (nmatch == k) {\\r\\nint id = (pref[0] << 8) | pref[1];\\r\\nreturn tls1_ec_curve_id2nid(id);\\r\\n}\\r\\nk++;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (nmatch == -1)\\r\\nreturn k;\\r\\nreturn NID_undef;\\r\\n}\\r\\nint tls1_set_curves(unsigned char **pext, size_t *pextlen,\\r\\nint *curves, size_t ncurves)\\r\\n{\\r\\nunsigned char *clist, *p;\\r\\nsize_t i;\\r\\nunsigned long dup_list = 0;\\r\\n# ifdef OPENSSL_NO_EC2M\\r\\nEC_GROUP *curve;\\r\\n# endif\\r\\nclist = OPENSSL_malloc(ncurves * 2);\\r\\nif (!clist)\\r\\nreturn 0;\\r\\nfor (i = 0, p = clist; i < ncurves; i++) {\\r\\nunsigned long idmask;\\r\\nint id;\\r\\nid = tls1_ec_nid2curve_id(curves[i]);\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && id > 25) {\\r\\nOPENSSL_free(clist);\\r\\nreturn 0;\\r\\n}\\r\\n# endif\\r\\n# ifdef OPENSSL_NO_EC2M\\r\\ncurve = EC_GROUP_new_by_curve_name(curves[i]);\\r\\nif (!curve || EC_METHOD_get_field_type(EC_GROUP_method_of(curve))\\r\\n== NID_X9_62_characteristic_two_field) {\\r\\nif (curve)\\r\\nEC_GROUP_free(curve);\\r\\nOPENSSL_free(clist);\\r\\nreturn 0;\\r\\n} else\\r\\nEC_GROUP_free(curve);\\r\\n# endif\\r\\nidmask = 1L << id;\\r\\nif (!id || (dup_list & idmask)) {\\r\\nOPENSSL_free(clist);\\r\\nreturn 0;\\r\\n}\\r\\ndup_list |= idmask;\\r\\ns2n(id, p);\\r\\n}\\r\\nif (*pext)\\r\\nOPENSSL_free(*pext);\\r\\n*pext = clist;\\r\\n*pextlen = ncurves * 2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int nid_cb(const char *elem, int len, void *arg)\\r\\n{\\r\\nnid_cb_st *narg = arg;\\r\\nsize_t i;\\r\\nint nid;\\r\\nchar etmp[20];\\r\\nif (narg->nidcnt == MAX_CURVELIST)\\r\\nreturn 0;\\r\\nif (len > (int)(sizeof(etmp) - 1))\\r\\nreturn 0;\\r\\nmemcpy(etmp, elem, len);\\r\\netmp[len] = 0;\\r\\nnid = EC_curve_nist2nid(etmp);\\r\\nif (nid == NID_undef)\\r\\nnid = OBJ_sn2nid(etmp);\\r\\nif (nid == NID_undef)\\r\\nnid = OBJ_ln2nid(etmp);\\r\\nif (nid == NID_undef)\\r\\nreturn 0;\\r\\nfor (i = 0; i < narg->nidcnt; i++)\\r\\nif (narg->nid_arr[i] == nid)\\r\\nreturn 0;\\r\\nnarg->nid_arr[narg->nidcnt++] = nid;\\r\\nreturn 1;\\r\\n}\\r\\nint tls1_set_curves_list(unsigned char **pext, size_t *pextlen,\\r\\nconst char *str)\\r\\n{\\r\\nnid_cb_st ncb;\\r\\nncb.nidcnt = 0;\\r\\nif (!CONF_parse_list(str, ':', 1, nid_cb, &ncb))\\r\\nreturn 0;\\r\\nif (pext == NULL)\\r\\nreturn 1;\\r\\nreturn tls1_set_curves(pext, pextlen, ncb.nid_arr, ncb.nidcnt);\\r\\n}\\r\\nstatic int tls1_set_ec_id(unsigned char *curve_id, unsigned char *comp_id,\\r\\nEC_KEY *ec)\\r\\n{\\r\\nint is_prime, id;\\r\\nconst EC_GROUP *grp;\\r\\nconst EC_METHOD *meth;\\r\\nif (!ec)\\r\\nreturn 0;\\r\\ngrp = EC_KEY_get0_group(ec);\\r\\nif (!grp)\\r\\nreturn 0;\\r\\nmeth = EC_GROUP_method_of(grp);\\r\\nif (!meth)\\r\\nreturn 0;\\r\\nif (EC_METHOD_get_field_type(meth) == NID_X9_62_prime_field)\\r\\nis_prime = 1;\\r\\nelse\\r\\nis_prime = 0;\\r\\nid = EC_GROUP_get_curve_name(grp);\\r\\nid = tls1_ec_nid2curve_id(id);\\r\\nif (id) {\\r\\ncurve_id[0] = 0;\\r\\ncurve_id[1] = (unsigned char)id;\\r\\n} else {\\r\\ncurve_id[0] = 0xff;\\r\\nif (is_prime)\\r\\ncurve_id[1] = 0x01;\\r\\nelse\\r\\ncurve_id[1] = 0x02;\\r\\n}\\r\\nif (comp_id) {\\r\\nif (EC_KEY_get0_public_key(ec) == NULL)\\r\\nreturn 0;\\r\\nif (EC_KEY_get_conv_form(ec) == POINT_CONVERSION_COMPRESSED) {\\r\\nif (is_prime)\\r\\n*comp_id = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime;\\r\\nelse\\r\\n*comp_id = TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2;\\r\\n} else\\r\\n*comp_id = TLSEXT_ECPOINTFORMAT_uncompressed;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tls1_check_ec_key(SSL *s,\\r\\nunsigned char *curve_id, unsigned char *comp_id)\\r\\n{\\r\\nconst unsigned char *pformats, *pcurves;\\r\\nsize_t num_formats, num_curves, i;\\r\\nint j;\\r\\nif (comp_id && s->session->tlsext_ecpointformatlist) {\\r\\npformats = s->session->tlsext_ecpointformatlist;\\r\\nnum_formats = s->session->tlsext_ecpointformatlist_length;\\r\\nfor (i = 0; i < num_formats; i++, pformats++) {\\r\\nif (*comp_id == *pformats)\\r\\nbreak;\\r\\n}\\r\\nif (i == num_formats)\\r\\nreturn 0;\\r\\n}\\r\\nif (!curve_id)\\r\\nreturn 1;\\r\\nfor (j = 0; j <= 1; j++) {\\r\\nif (!tls1_get_curvelist(s, j, &pcurves, &num_curves))\\r\\nreturn 0;\\r\\nfor (i = 0; i < num_curves; i++, pcurves += 2) {\\r\\nif (pcurves[0] == curve_id[0] && pcurves[1] == curve_id[1])\\r\\nbreak;\\r\\n}\\r\\nif (i == num_curves)\\r\\nreturn 0;\\r\\nif (!s->server)\\r\\nreturn 1;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void tls1_get_formatlist(SSL *s, const unsigned char **pformats,\\r\\nsize_t *num_formats)\\r\\n{\\r\\nif (s->tlsext_ecpointformatlist) {\\r\\n*pformats = s->tlsext_ecpointformatlist;\\r\\n*num_formats = s->tlsext_ecpointformatlist_length;\\r\\n} else {\\r\\n*pformats = ecformats_default;\\r\\nif (tls1_suiteb(s))\\r\\n*num_formats = sizeof(ecformats_default) - 1;\\r\\nelse\\r\\n*num_formats = sizeof(ecformats_default);\\r\\n}\\r\\n}\\r\\nstatic int tls1_check_cert_param(SSL *s, X509 *x, int set_ee_md)\\r\\n{\\r\\nunsigned char comp_id, curve_id[2];\\r\\nEVP_PKEY *pkey;\\r\\nint rv;\\r\\npkey = X509_get_pubkey(x);\\r\\nif (!pkey)\\r\\nreturn 0;\\r\\nif (pkey->type != EVP_PKEY_EC) {\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn 1;\\r\\n}\\r\\nrv = tls1_set_ec_id(curve_id, &comp_id, pkey->pkey.ec);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (!rv)\\r\\nreturn 0;\\r\\nrv = tls1_check_ec_key(s, s->server ? curve_id : NULL, &comp_id);\\r\\nif (!rv)\\r\\nreturn 0;\\r\\nif (set_ee_md && tls1_suiteb(s)) {\\r\\nint check_md;\\r\\nsize_t i;\\r\\nCERT *c = s->cert;\\r\\nif (curve_id[0])\\r\\nreturn 0;\\r\\nif (curve_id[1] == TLSEXT_curve_P_256)\\r\\ncheck_md = NID_ecdsa_with_SHA256;\\r\\nelse if (curve_id[1] == TLSEXT_curve_P_384)\\r\\ncheck_md = NID_ecdsa_with_SHA384;\\r\\nelse\\r\\nreturn 0;\\r\\nfor (i = 0; i < c->shared_sigalgslen; i++)\\r\\nif (check_md == c->shared_sigalgs[i].signandhash_nid)\\r\\nbreak;\\r\\nif (i == c->shared_sigalgslen)\\r\\nreturn 0;\\r\\nif (set_ee_md == 2) {\\r\\nif (check_md == NID_ecdsa_with_SHA256)\\r\\nc->pkeys[SSL_PKEY_ECC].digest = EVP_sha256();\\r\\nelse\\r\\nc->pkeys[SSL_PKEY_ECC].digest = EVP_sha384();\\r\\n}\\r\\n}\\r\\nreturn rv;\\r\\n}\\r\\nint tls1_check_ec_tmp_key(SSL *s, unsigned long cid)\\r\\n{\\r\\nunsigned char curve_id[2];\\r\\nEC_KEY *ec = s->cert->ecdh_tmp;\\r\\n# ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\\r\\nif (s->cert->cert_flags & SSL_CERT_FLAG_BROKEN_PROTOCOL)\\r\\nreturn 1;\\r\\n# endif\\r\\nif (tls1_suiteb(s)) {\\r\\nif (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)\\r\\ncurve_id[1] = TLSEXT_curve_P_256;\\r\\nelse if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)\\r\\ncurve_id[1] = TLSEXT_curve_P_384;\\r\\nelse\\r\\nreturn 0;\\r\\ncurve_id[0] = 0;\\r\\nif (!tls1_check_ec_key(s, curve_id, NULL))\\r\\nreturn 0;\\r\\nif (s->cert->ecdh_tmp_auto || s->cert->ecdh_tmp_cb)\\r\\nreturn 1;\\r\\nelse {\\r\\nunsigned char curve_tmp[2];\\r\\nif (!ec)\\r\\nreturn 0;\\r\\nif (!tls1_set_ec_id(curve_tmp, NULL, ec))\\r\\nreturn 0;\\r\\nif (!curve_tmp[0] || curve_tmp[1] == curve_id[1])\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (s->cert->ecdh_tmp_auto) {\\r\\nif (tls1_shared_curve(s, 0))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nif (!ec) {\\r\\nif (s->cert->ecdh_tmp_cb)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nif (!tls1_set_ec_id(curve_id, NULL, ec))\\r\\nreturn 0;\\r\\n# if 0\\r\\nreturn 1;\\r\\n# else\\r\\nreturn tls1_check_ec_key(s, curve_id, NULL);\\r\\n# endif\\r\\n}\\r\\nstatic int tls1_check_cert_param(SSL *s, X509 *x, int set_ee_md)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nsize_t tls12_get_psigalgs(SSL *s, const unsigned char **psigs)\\r\\n{\\r\\n# ifndef OPENSSL_NO_EC\\r\\nswitch (tls1_suiteb(s)) {\\r\\ncase SSL_CERT_FLAG_SUITEB_128_LOS:\\r\\n*psigs = suiteb_sigalgs;\\r\\nreturn sizeof(suiteb_sigalgs);\\r\\ncase SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:\\r\\n*psigs = suiteb_sigalgs;\\r\\nreturn 2;\\r\\ncase SSL_CERT_FLAG_SUITEB_192_LOS:\\r\\n*psigs = suiteb_sigalgs + 2;\\r\\nreturn 2;\\r\\n}\\r\\n# endif\\r\\nif (s->server && s->cert->client_sigalgs) {\\r\\n*psigs = s->cert->client_sigalgs;\\r\\nreturn s->cert->client_sigalgslen;\\r\\n} else if (s->cert->conf_sigalgs) {\\r\\n*psigs = s->cert->conf_sigalgs;\\r\\nreturn s->cert->conf_sigalgslen;\\r\\n} else {\\r\\n*psigs = tls12_sigalgs;\\r\\nreturn sizeof(tls12_sigalgs);\\r\\n}\\r\\n}\\r\\nint tls12_check_peer_sigalg(const EVP_MD **pmd, SSL *s,\\r\\nconst unsigned char *sig, EVP_PKEY *pkey)\\r\\n{\\r\\nconst unsigned char *sent_sigs;\\r\\nsize_t sent_sigslen, i;\\r\\nint sigalg = tls12_get_sigid(pkey);\\r\\nif (sigalg == -1)\\r\\nreturn -1;\\r\\nif (sigalg != (int)sig[1]) {\\r\\nSSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG, SSL_R_WRONG_SIGNATURE_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\n# ifndef OPENSSL_NO_EC\\r\\nif (pkey->type == EVP_PKEY_EC) {\\r\\nunsigned char curve_id[2], comp_id;\\r\\nif (!tls1_set_ec_id(curve_id, &comp_id, pkey->pkey.ec))\\r\\nreturn 0;\\r\\nif (!s->server && !tls1_check_ec_key(s, curve_id, &comp_id)) {\\r\\nSSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG, SSL_R_WRONG_CURVE);\\r\\nreturn 0;\\r\\n}\\r\\nif (tls1_suiteb(s)) {\\r\\nif (curve_id[0])\\r\\nreturn 0;\\r\\nif (curve_id[1] == TLSEXT_curve_P_256) {\\r\\nif (sig[0] != TLSEXT_hash_sha256) {\\r\\nSSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG,\\r\\nSSL_R_ILLEGAL_SUITEB_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\n} else if (curve_id[1] == TLSEXT_curve_P_384) {\\r\\nif (sig[0] != TLSEXT_hash_sha384) {\\r\\nSSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG,\\r\\nSSL_R_ILLEGAL_SUITEB_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\n} else\\r\\nreturn 0;\\r\\n}\\r\\n} else if (tls1_suiteb(s))\\r\\nreturn 0;\\r\\n# endif\\r\\nsent_sigslen = tls12_get_psigalgs(s, &sent_sigs);\\r\\nfor (i = 0; i < sent_sigslen; i += 2, sent_sigs += 2) {\\r\\nif (sig[0] == sent_sigs[0] && sig[1] == sent_sigs[1])\\r\\nbreak;\\r\\n}\\r\\nif (i == sent_sigslen\\r\\n&& (sig[0] != TLSEXT_hash_sha1\\r\\n|| s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)) {\\r\\nSSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG, SSL_R_WRONG_SIGNATURE_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\n*pmd = tls12_get_hash(sig[0]);\\r\\nif (*pmd == NULL) {\\r\\nSSLerr(SSL_F_TLS12_CHECK_PEER_SIGALG, SSL_R_UNKNOWN_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nif (s->session && s->session->sess_cert)\\r\\ns->session->sess_cert->peer_key->digest = *pmd;\\r\\nreturn 1;\\r\\n}\\r\\nvoid ssl_set_client_disabled(SSL *s)\\r\\n{\\r\\nCERT *c = s->cert;\\r\\nconst unsigned char *sigalgs;\\r\\nsize_t i, sigalgslen;\\r\\nint have_rsa = 0, have_dsa = 0, have_ecdsa = 0;\\r\\nc->mask_a = 0;\\r\\nc->mask_k = 0;\\r\\nif (!SSL_CLIENT_USE_TLS1_2_CIPHERS(s))\\r\\nc->mask_ssl = SSL_TLSV1_2;\\r\\nelse\\r\\nc->mask_ssl = 0;\\r\\nsigalgslen = tls12_get_psigalgs(s, &sigalgs);\\r\\nfor (i = 0; i < sigalgslen; i += 2, sigalgs += 2) {\\r\\nswitch (sigalgs[1]) {\\r\\n# ifndef OPENSSL_NO_RSA\\r\\ncase TLSEXT_signature_rsa:\\r\\nhave_rsa = 1;\\r\\nbreak;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DSA\\r\\ncase TLSEXT_signature_dsa:\\r\\nhave_dsa = 1;\\r\\nbreak;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ECDSA\\r\\ncase TLSEXT_signature_ecdsa:\\r\\nhave_ecdsa = 1;\\r\\nbreak;\\r\\n# endif\\r\\n}\\r\\n}\\r\\nif (!have_rsa) {\\r\\nc->mask_a |= SSL_aRSA;\\r\\nc->mask_k |= SSL_kDHr | SSL_kECDHr;\\r\\n}\\r\\nif (!have_dsa) {\\r\\nc->mask_a |= SSL_aDSS;\\r\\nc->mask_k |= SSL_kDHd;\\r\\n}\\r\\nif (!have_ecdsa) {\\r\\nc->mask_a |= SSL_aECDSA;\\r\\nc->mask_k |= SSL_kECDHe;\\r\\n}\\r\\n# ifndef OPENSSL_NO_KRB5\\r\\nif (!kssl_tgt_is_available(s->kssl_ctx)) {\\r\\nc->mask_a |= SSL_aKRB5;\\r\\nc->mask_k |= SSL_kKRB5;\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_PSK\\r\\nif (!s->psk_client_callback) {\\r\\nc->mask_a |= SSL_aPSK;\\r\\nc->mask_k |= SSL_kPSK;\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SRP\\r\\nif (!(s->srp_ctx.srp_Mask & SSL_kSRP)) {\\r\\nc->mask_a |= SSL_aSRP;\\r\\nc->mask_k |= SSL_kSRP;\\r\\n}\\r\\n# endif\\r\\nc->valid = 1;\\r\\n}\\r\\nunsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,\\r\\nunsigned char *limit, int *al)\\r\\n{\\r\\nint extdatalen = 0;\\r\\nunsigned char *orig = buf;\\r\\nunsigned char *ret = buf;\\r\\n# ifndef OPENSSL_NO_EC\\r\\nint using_ecc = 0;\\r\\nif (s->version >= TLS1_VERSION || SSL_IS_DTLS(s)) {\\r\\nint i;\\r\\nunsigned long alg_k, alg_a;\\r\\nSTACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);\\r\\nfor (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) {\\r\\nSSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);\\r\\nalg_k = c->algorithm_mkey;\\r\\nalg_a = c->algorithm_auth;\\r\\nif ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe)\\r\\n|| (alg_a & SSL_aECDSA))) {\\r\\nusing_ecc = 1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\n# endif\\r\\nif (s->client_version == SSL3_VERSION && !s->s3->send_connection_binding)\\r\\nreturn orig;\\r\\nret += 2;\\r\\nif (ret >= limit)\\r\\nreturn NULL;\\r\\nif (s->tlsext_hostname != NULL) {\\r\\nunsigned long size_str;\\r\\nlong lenmax;\\r\\nif ((lenmax = limit - ret - 9) < 0\\r\\n|| (size_str =\\r\\nstrlen(s->tlsext_hostname)) > (unsigned long)lenmax)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_server_name, ret);\\r\\ns2n(size_str + 5, ret);\\r\\ns2n(size_str + 3, ret);\\r\\n*(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;\\r\\ns2n(size_str, ret);\\r\\nmemcpy(ret, s->tlsext_hostname, size_str);\\r\\nret += size_str;\\r\\n}\\r\\nif (s->renegotiate) {\\r\\nint el;\\r\\nif (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {\\r\\nSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif ((limit - ret - 4 - el) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_renegotiate, ret);\\r\\ns2n(el, ret);\\r\\nif (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {\\r\\nSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nret += el;\\r\\n}\\r\\n# ifndef OPENSSL_NO_SRP\\r\\nif (s->srp_ctx.login != NULL) {\\r\\nint login_len = strlen(s->srp_ctx.login);\\r\\nif (login_len > 255 || login_len == 0) {\\r\\nSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif ((limit - ret - 5 - login_len) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_srp, ret);\\r\\ns2n(login_len + 1, ret);\\r\\n(*ret++) = (unsigned char)login_len;\\r\\nmemcpy(ret, s->srp_ctx.login, login_len);\\r\\nret += login_len;\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_EC\\r\\nif (using_ecc) {\\r\\nlong lenmax;\\r\\nconst unsigned char *pcurves, *pformats;\\r\\nsize_t num_curves, num_formats, curves_list_len;\\r\\ntls1_get_formatlist(s, &pformats, &num_formats);\\r\\nif ((lenmax = limit - ret - 5) < 0)\\r\\nreturn NULL;\\r\\nif (num_formats > (size_t)lenmax)\\r\\nreturn NULL;\\r\\nif (num_formats > 255) {\\r\\nSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\ns2n(TLSEXT_TYPE_ec_point_formats, ret);\\r\\ns2n(num_formats + 1, ret);\\r\\n*(ret++) = (unsigned char)num_formats;\\r\\nmemcpy(ret, pformats, num_formats);\\r\\nret += num_formats;\\r\\npcurves = s->tlsext_ellipticcurvelist;\\r\\nif (!tls1_get_curvelist(s, 0, &pcurves, &num_curves))\\r\\nreturn NULL;\\r\\nif ((lenmax = limit - ret - 6) < 0)\\r\\nreturn NULL;\\r\\nif (num_curves > (size_t)lenmax / 2)\\r\\nreturn NULL;\\r\\nif (num_curves > 65532 / 2) {\\r\\nSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\ncurves_list_len = 2 * num_curves;\\r\\ns2n(TLSEXT_TYPE_elliptic_curves, ret);\\r\\ns2n(curves_list_len + 2, ret);\\r\\ns2n(curves_list_len, ret);\\r\\nmemcpy(ret, pcurves, curves_list_len);\\r\\nret += curves_list_len;\\r\\n}\\r\\n# endif\\r\\nif (!(SSL_get_options(s) & SSL_OP_NO_TICKET)) {\\r\\nint ticklen;\\r\\nif (!s->new_session && s->session && s->session->tlsext_tick)\\r\\nticklen = s->session->tlsext_ticklen;\\r\\nelse if (s->session && s->tlsext_session_ticket &&\\r\\ns->tlsext_session_ticket->data) {\\r\\nticklen = s->tlsext_session_ticket->length;\\r\\ns->session->tlsext_tick = OPENSSL_malloc(ticklen);\\r\\nif (!s->session->tlsext_tick)\\r\\nreturn NULL;\\r\\nmemcpy(s->session->tlsext_tick,\\r\\ns->tlsext_session_ticket->data, ticklen);\\r\\ns->session->tlsext_ticklen = ticklen;\\r\\n} else\\r\\nticklen = 0;\\r\\nif (ticklen == 0 && s->tlsext_session_ticket &&\\r\\ns->tlsext_session_ticket->data == NULL)\\r\\ngoto skip_ext;\\r\\nif ((long)(limit - ret - 4 - ticklen) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_session_ticket, ret);\\r\\ns2n(ticklen, ret);\\r\\nif (ticklen) {\\r\\nmemcpy(ret, s->session->tlsext_tick, ticklen);\\r\\nret += ticklen;\\r\\n}\\r\\n}\\r\\nskip_ext:\\r\\nif (SSL_USE_SIGALGS(s)) {\\r\\nsize_t salglen;\\r\\nconst unsigned char *salg;\\r\\nsalglen = tls12_get_psigalgs(s, &salg);\\r\\nif ((size_t)(limit - ret) < salglen + 6)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_signature_algorithms, ret);\\r\\ns2n(salglen + 2, ret);\\r\\ns2n(salglen, ret);\\r\\nmemcpy(ret, salg, salglen);\\r\\nret += salglen;\\r\\n}\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nif (s->s3->client_opaque_prf_input != NULL) {\\r\\nsize_t col = s->s3->client_opaque_prf_input_len;\\r\\nif ((long)(limit - ret - 6 - col < 0))\\r\\nreturn NULL;\\r\\nif (col > 0xFFFD)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_opaque_prf_input, ret);\\r\\ns2n(col + 2, ret);\\r\\ns2n(col, ret);\\r\\nmemcpy(ret, s->s3->client_opaque_prf_input, col);\\r\\nret += col;\\r\\n}\\r\\n# endif\\r\\nif (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {\\r\\nint i;\\r\\nlong extlen, idlen, itmp;\\r\\nOCSP_RESPID *id;\\r\\nidlen = 0;\\r\\nfor (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {\\r\\nid = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\\r\\nitmp = i2d_OCSP_RESPID(id, NULL);\\r\\nif (itmp <= 0)\\r\\nreturn NULL;\\r\\nidlen += itmp + 2;\\r\\n}\\r\\nif (s->tlsext_ocsp_exts) {\\r\\nextlen = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL);\\r\\nif (extlen < 0)\\r\\nreturn NULL;\\r\\n} else\\r\\nextlen = 0;\\r\\nif ((long)(limit - ret - 7 - extlen - idlen) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_status_request, ret);\\r\\nif (extlen + idlen > 0xFFF0)\\r\\nreturn NULL;\\r\\ns2n(extlen + idlen + 5, ret);\\r\\n*(ret++) = TLSEXT_STATUSTYPE_ocsp;\\r\\ns2n(idlen, ret);\\r\\nfor (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {\\r\\nunsigned char *q = ret;\\r\\nid = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\\r\\nret += 2;\\r\\nitmp = i2d_OCSP_RESPID(id, &ret);\\r\\ns2n(itmp, q);\\r\\n}\\r\\ns2n(extlen, ret);\\r\\nif (extlen > 0)\\r\\ni2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);\\r\\n}\\r\\n# ifndef OPENSSL_NO_HEARTBEATS\\r\\nif ((limit - ret - 4 - 1) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_heartbeat, ret);\\r\\ns2n(1, ret);\\r\\nif (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)\\r\\n*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\\r\\nelse\\r\\n*(ret++) = SSL_TLSEXT_HB_ENABLED;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nif (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len) {\\r\\nif (limit - ret - 4 < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_next_proto_neg, ret);\\r\\ns2n(0, ret);\\r\\n}\\r\\n# endif\\r\\nif (s->alpn_client_proto_list && !s->s3->tmp.finish_md_len) {\\r\\nif ((size_t)(limit - ret) < 6 + s->alpn_client_proto_list_len)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);\\r\\ns2n(2 + s->alpn_client_proto_list_len, ret);\\r\\ns2n(s->alpn_client_proto_list_len, ret);\\r\\nmemcpy(ret, s->alpn_client_proto_list, s->alpn_client_proto_list_len);\\r\\nret += s->alpn_client_proto_list_len;\\r\\n}\\r\\n# ifndef OPENSSL_NO_SRTP\\r\\nif (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)) {\\r\\nint el;\\r\\nssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);\\r\\nif ((limit - ret - 4 - el) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_use_srtp, ret);\\r\\ns2n(el, ret);\\r\\nif (ssl_add_clienthello_use_srtp_ext(s, ret, &el, el)) {\\r\\nSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nret += el;\\r\\n}\\r\\n# endif\\r\\ncustom_ext_init(&s->cert->cli_ext);\\r\\nif (!custom_ext_add(s, 0, &ret, limit, al))\\r\\nreturn NULL;\\r\\nif (s->options & SSL_OP_TLSEXT_PADDING) {\\r\\nint hlen = ret - (unsigned char *)s->init_buf->data;\\r\\nif (s->state == SSL23_ST_CW_CLNT_HELLO_A)\\r\\nhlen -= 5;\\r\\nif (hlen > 0xff && hlen < 0x200) {\\r\\nhlen = 0x200 - hlen;\\r\\nif (hlen >= 4)\\r\\nhlen -= 4;\\r\\nelse\\r\\nhlen = 0;\\r\\ns2n(TLSEXT_TYPE_padding, ret);\\r\\ns2n(hlen, ret);\\r\\nmemset(ret, 0, hlen);\\r\\nret += hlen;\\r\\n}\\r\\n}\\r\\nif ((extdatalen = ret - orig - 2) == 0)\\r\\nreturn orig;\\r\\ns2n(extdatalen, orig);\\r\\nreturn ret;\\r\\n}\\r\\nunsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,\\r\\nunsigned char *limit, int *al)\\r\\n{\\r\\nint extdatalen = 0;\\r\\nunsigned char *orig = buf;\\r\\nunsigned char *ret = buf;\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nint next_proto_neg_seen;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_EC\\r\\nunsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\\r\\nunsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\\r\\nint using_ecc = (alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe))\\r\\n|| (alg_a & SSL_aECDSA);\\r\\nusing_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);\\r\\n# endif\\r\\nif (s->version == SSL3_VERSION && !s->s3->send_connection_binding)\\r\\nreturn orig;\\r\\nret += 2;\\r\\nif (ret >= limit)\\r\\nreturn NULL;\\r\\nif (!s->hit && s->servername_done == 1\\r\\n&& s->session->tlsext_hostname != NULL) {\\r\\nif ((long)(limit - ret - 4) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_server_name, ret);\\r\\ns2n(0, ret);\\r\\n}\\r\\nif (s->s3->send_connection_binding) {\\r\\nint el;\\r\\nif (!ssl_add_serverhello_renegotiate_ext(s, 0, &el, 0)) {\\r\\nSSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif ((limit - ret - 4 - el) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_renegotiate, ret);\\r\\ns2n(el, ret);\\r\\nif (!ssl_add_serverhello_renegotiate_ext(s, ret, &el, el)) {\\r\\nSSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nret += el;\\r\\n}\\r\\n# ifndef OPENSSL_NO_EC\\r\\nif (using_ecc) {\\r\\nconst unsigned char *plist;\\r\\nsize_t plistlen;\\r\\nlong lenmax;\\r\\ntls1_get_formatlist(s, &plist, &plistlen);\\r\\nif ((lenmax = limit - ret - 5) < 0)\\r\\nreturn NULL;\\r\\nif (plistlen > (size_t)lenmax)\\r\\nreturn NULL;\\r\\nif (plistlen > 255) {\\r\\nSSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\ns2n(TLSEXT_TYPE_ec_point_formats, ret);\\r\\ns2n(plistlen + 1, ret);\\r\\n*(ret++) = (unsigned char)plistlen;\\r\\nmemcpy(ret, plist, plistlen);\\r\\nret += plistlen;\\r\\n}\\r\\n# endif\\r\\nif (s->tlsext_ticket_expected && !(SSL_get_options(s) & SSL_OP_NO_TICKET)) {\\r\\nif ((long)(limit - ret - 4) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_session_ticket, ret);\\r\\ns2n(0, ret);\\r\\n}\\r\\nif (s->tlsext_status_expected) {\\r\\nif ((long)(limit - ret - 4) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_status_request, ret);\\r\\ns2n(0, ret);\\r\\n}\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nif (s->s3->server_opaque_prf_input != NULL) {\\r\\nsize_t sol = s->s3->server_opaque_prf_input_len;\\r\\nif ((long)(limit - ret - 6 - sol) < 0)\\r\\nreturn NULL;\\r\\nif (sol > 0xFFFD)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_opaque_prf_input, ret);\\r\\ns2n(sol + 2, ret);\\r\\ns2n(sol, ret);\\r\\nmemcpy(ret, s->s3->server_opaque_prf_input, sol);\\r\\nret += sol;\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SRTP\\r\\nif (SSL_IS_DTLS(s) && s->srtp_profile) {\\r\\nint el;\\r\\nssl_add_serverhello_use_srtp_ext(s, 0, &el, 0);\\r\\nif ((limit - ret - 4 - el) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_use_srtp, ret);\\r\\ns2n(el, ret);\\r\\nif (ssl_add_serverhello_use_srtp_ext(s, ret, &el, el)) {\\r\\nSSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nret += el;\\r\\n}\\r\\n# endif\\r\\nif (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80\\r\\n|| (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)\\r\\n&& (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) {\\r\\nconst unsigned char cryptopro_ext[36] = {\\r\\n0xfd, 0xe8,\\r\\n0x00, 0x20,\\r\\n0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,\\r\\n0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,\\r\\n0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,\\r\\n0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17\\r\\n};\\r\\nif (limit - ret < 36)\\r\\nreturn NULL;\\r\\nmemcpy(ret, cryptopro_ext, 36);\\r\\nret += 36;\\r\\n}\\r\\n# ifndef OPENSSL_NO_HEARTBEATS\\r\\nif (s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED) {\\r\\nif ((limit - ret - 4 - 1) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_heartbeat, ret);\\r\\ns2n(1, ret);\\r\\nif (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)\\r\\n*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\\r\\nelse\\r\\n*(ret++) = SSL_TLSEXT_HB_ENABLED;\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nnext_proto_neg_seen = s->s3->next_proto_neg_seen;\\r\\ns->s3->next_proto_neg_seen = 0;\\r\\nif (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) {\\r\\nconst unsigned char *npa;\\r\\nunsigned int npalen;\\r\\nint r;\\r\\nr = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,\\r\\ns->\\r\\nctx->next_protos_advertised_cb_arg);\\r\\nif (r == SSL_TLSEXT_ERR_OK) {\\r\\nif ((long)(limit - ret - 4 - npalen) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_next_proto_neg, ret);\\r\\ns2n(npalen, ret);\\r\\nmemcpy(ret, npa, npalen);\\r\\nret += npalen;\\r\\ns->s3->next_proto_neg_seen = 1;\\r\\n}\\r\\n}\\r\\n# endif\\r\\nif (!custom_ext_add(s, 1, &ret, limit, al))\\r\\nreturn NULL;\\r\\nif (s->s3->alpn_selected) {\\r\\nconst unsigned char *selected = s->s3->alpn_selected;\\r\\nunsigned len = s->s3->alpn_selected_len;\\r\\nif ((long)(limit - ret - 4 - 2 - 1 - len) < 0)\\r\\nreturn NULL;\\r\\ns2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);\\r\\ns2n(3 + len, ret);\\r\\ns2n(1 + len, ret);\\r\\n*ret++ = len;\\r\\nmemcpy(ret, selected, len);\\r\\nret += len;\\r\\n}\\r\\nif ((extdatalen = ret - orig - 2) == 0)\\r\\nreturn orig;\\r\\ns2n(extdatalen, orig);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void ssl_check_for_safari(SSL *s, const unsigned char *data,\\r\\nconst unsigned char *d, int n)\\r\\n{\\r\\nunsigned short type, size;\\r\\nstatic const unsigned char kSafariExtensionsBlock[] = {\\r\\n0x00, 0x0a,\\r\\n0x00, 0x08,\\r\\n0x00, 0x06,\\r\\n0x00, 0x17,\\r\\n0x00, 0x18,\\r\\n0x00, 0x19,\\r\\n0x00, 0x0b,\\r\\n0x00, 0x02,\\r\\n0x01,\\r\\n0x00,\\r\\n};\\r\\nstatic const unsigned char kSafariTLS12ExtensionsBlock[] = {\\r\\n0x00, 0x0d,\\r\\n0x00, 0x0c,\\r\\n0x00, 0x0a,\\r\\n0x05, 0x01,\\r\\n0x04, 0x01,\\r\\n0x02, 0x01,\\r\\n0x04, 0x03,\\r\\n0x02, 0x03,\\r\\n};\\r\\nif (data >= (d + n - 2))\\r\\nreturn;\\r\\ndata += 2;\\r\\nif (data > (d + n - 4))\\r\\nreturn;\\r\\nn2s(data, type);\\r\\nn2s(data, size);\\r\\nif (type != TLSEXT_TYPE_server_name)\\r\\nreturn;\\r\\nif (data + size > d + n)\\r\\nreturn;\\r\\ndata += size;\\r\\nif (TLS1_get_client_version(s) >= TLS1_2_VERSION) {\\r\\nconst size_t len1 = sizeof(kSafariExtensionsBlock);\\r\\nconst size_t len2 = sizeof(kSafariTLS12ExtensionsBlock);\\r\\nif (data + len1 + len2 != d + n)\\r\\nreturn;\\r\\nif (memcmp(data, kSafariExtensionsBlock, len1) != 0)\\r\\nreturn;\\r\\nif (memcmp(data + len1, kSafariTLS12ExtensionsBlock, len2) != 0)\\r\\nreturn;\\r\\n} else {\\r\\nconst size_t len = sizeof(kSafariExtensionsBlock);\\r\\nif (data + len != d + n)\\r\\nreturn;\\r\\nif (memcmp(data, kSafariExtensionsBlock, len) != 0)\\r\\nreturn;\\r\\n}\\r\\ns->s3->is_probably_safari = 1;\\r\\n}\\r\\nstatic int tls1_alpn_handle_client_hello(SSL *s, const unsigned char *data,\\r\\nunsigned data_len, int *al)\\r\\n{\\r\\nunsigned i;\\r\\nunsigned proto_len;\\r\\nconst unsigned char *selected;\\r\\nunsigned char selected_len;\\r\\nint r;\\r\\nif (s->ctx->alpn_select_cb == NULL)\\r\\nreturn 0;\\r\\nif (data_len < 2)\\r\\ngoto parse_error;\\r\\ni = ((unsigned)data[0]) << 8 | ((unsigned)data[1]);\\r\\ndata_len -= 2;\\r\\ndata += 2;\\r\\nif (data_len != i)\\r\\ngoto parse_error;\\r\\nif (data_len < 2)\\r\\ngoto parse_error;\\r\\nfor (i = 0; i < data_len;) {\\r\\nproto_len = data[i];\\r\\ni++;\\r\\nif (proto_len == 0)\\r\\ngoto parse_error;\\r\\nif (i + proto_len < i || i + proto_len > data_len)\\r\\ngoto parse_error;\\r\\ni += proto_len;\\r\\n}\\r\\nr = s->ctx->alpn_select_cb(s, &selected, &selected_len, data, data_len,\\r\\ns->ctx->alpn_select_cb_arg);\\r\\nif (r == SSL_TLSEXT_ERR_OK) {\\r\\nif (s->s3->alpn_selected)\\r\\nOPENSSL_free(s->s3->alpn_selected);\\r\\ns->s3->alpn_selected = OPENSSL_malloc(selected_len);\\r\\nif (!s->s3->alpn_selected) {\\r\\n*al = SSL_AD_INTERNAL_ERROR;\\r\\nreturn -1;\\r\\n}\\r\\nmemcpy(s->s3->alpn_selected, selected, selected_len);\\r\\ns->s3->alpn_selected_len = selected_len;\\r\\n}\\r\\nreturn 0;\\r\\nparse_error:\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn -1;\\r\\n}\\r\\nstatic int ssl_scan_clienthello_tlsext(SSL *s, unsigned char **p,\\r\\nunsigned char *d, int n, int *al)\\r\\n{\\r\\nunsigned short type;\\r\\nunsigned short size;\\r\\nunsigned short len;\\r\\nunsigned char *data = *p;\\r\\nint renegotiate_seen = 0;\\r\\ns->servername_done = 0;\\r\\ns->tlsext_status_type = -1;\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\ns->s3->next_proto_neg_seen = 0;\\r\\n# endif\\r\\nif (s->s3->alpn_selected) {\\r\\nOPENSSL_free(s->s3->alpn_selected);\\r\\ns->s3->alpn_selected = NULL;\\r\\n}\\r\\n# ifndef OPENSSL_NO_HEARTBEATS\\r\\ns->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\\r\\nSSL_TLSEXT_HB_DONT_SEND_REQUESTS);\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_EC\\r\\nif (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG)\\r\\nssl_check_for_safari(s, data, d, n);\\r\\n# endif\\r\\nif (s->cert->peer_sigalgs) {\\r\\nOPENSSL_free(s->cert->peer_sigalgs);\\r\\ns->cert->peer_sigalgs = NULL;\\r\\n}\\r\\n# ifndef OPENSSL_NO_SRP\\r\\nif (s->srp_ctx.login != NULL) {\\r\\nOPENSSL_free(s->srp_ctx.login);\\r\\ns->srp_ctx.login = NULL;\\r\\n}\\r\\n# endif\\r\\ns->srtp_profile = NULL;\\r\\nif (data >= (d + n - 2))\\r\\ngoto ri_check;\\r\\nn2s(data, len);\\r\\nif (data > (d + n - len))\\r\\ngoto ri_check;\\r\\nwhile (data <= (d + n - 4)) {\\r\\nn2s(data, type);\\r\\nn2s(data, size);\\r\\nif (data + size > (d + n))\\r\\ngoto ri_check;\\r\\n# if 0\\r\\nfprintf(stderr, \"Received extension type %d size %d\\n\", type, size);\\r\\n# endif\\r\\nif (s->tlsext_debug_cb)\\r\\ns->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg);\\r\\nif (type == TLSEXT_TYPE_server_name) {\\r\\nunsigned char *sdata;\\r\\nint servname_type;\\r\\nint dsize;\\r\\nif (size < 2) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nn2s(data, dsize);\\r\\nsize -= 2;\\r\\nif (dsize > size) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nsdata = data;\\r\\nwhile (dsize > 3) {\\r\\nservname_type = *(sdata++);\\r\\nn2s(sdata, len);\\r\\ndsize -= 3;\\r\\nif (len > dsize) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (s->servername_done == 0)\\r\\nswitch (servname_type) {\\r\\ncase TLSEXT_NAMETYPE_host_name:\\r\\nif (!s->hit) {\\r\\nif (s->session->tlsext_hostname) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (len > TLSEXT_MAXLEN_host_name) {\\r\\n*al = TLS1_AD_UNRECOGNIZED_NAME;\\r\\nreturn 0;\\r\\n}\\r\\nif ((s->session->tlsext_hostname =\\r\\nOPENSSL_malloc(len + 1)) == NULL) {\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(s->session->tlsext_hostname, sdata, len);\\r\\ns->session->tlsext_hostname[len] = '\\0';\\r\\nif (strlen(s->session->tlsext_hostname) != len) {\\r\\nOPENSSL_free(s->session->tlsext_hostname);\\r\\ns->session->tlsext_hostname = NULL;\\r\\n*al = TLS1_AD_UNRECOGNIZED_NAME;\\r\\nreturn 0;\\r\\n}\\r\\ns->servername_done = 1;\\r\\n} else\\r\\ns->servername_done = s->session->tlsext_hostname\\r\\n&& strlen(s->session->tlsext_hostname) == len\\r\\n&& strncmp(s->session->tlsext_hostname,\\r\\n(char *)sdata, len) == 0;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\ndsize -= len;\\r\\n}\\r\\nif (dsize != 0) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n# ifndef OPENSSL_NO_SRP\\r\\nelse if (type == TLSEXT_TYPE_srp) {\\r\\nif (size <= 0 || ((len = data[0])) != (size - 1)) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (s->srp_ctx.login != NULL) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif ((s->srp_ctx.login = OPENSSL_malloc(len + 1)) == NULL)\\r\\nreturn -1;\\r\\nmemcpy(s->srp_ctx.login, &data[1], len);\\r\\ns->srp_ctx.login[len] = '\\0';\\r\\nif (strlen(s->srp_ctx.login) != len) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_EC\\r\\nelse if (type == TLSEXT_TYPE_ec_point_formats) {\\r\\nunsigned char *sdata = data;\\r\\nint ecpointformatlist_length = *(sdata++);\\r\\nif (ecpointformatlist_length != size - 1 ||\\r\\necpointformatlist_length < 1) {\\r\\n*al = TLS1_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (!s->hit) {\\r\\nif (s->session->tlsext_ecpointformatlist) {\\r\\nOPENSSL_free(s->session->tlsext_ecpointformatlist);\\r\\ns->session->tlsext_ecpointformatlist = NULL;\\r\\n}\\r\\ns->session->tlsext_ecpointformatlist_length = 0;\\r\\nif ((s->session->tlsext_ecpointformatlist =\\r\\nOPENSSL_malloc(ecpointformatlist_length)) == NULL) {\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\ns->session->tlsext_ecpointformatlist_length =\\r\\necpointformatlist_length;\\r\\nmemcpy(s->session->tlsext_ecpointformatlist, sdata,\\r\\necpointformatlist_length);\\r\\n}\\r\\n# if 0\\r\\nfprintf(stderr,\\r\\n\"ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) \",\\r\\ns->session->tlsext_ecpointformatlist_length);\\r\\nsdata = s->session->tlsext_ecpointformatlist;\\r\\nfor (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)\\r\\nfprintf(stderr, \"%i \", *(sdata++));\\r\\nfprintf(stderr, \"\\n\");\\r\\n# endif\\r\\n} else if (type == TLSEXT_TYPE_elliptic_curves) {\\r\\nunsigned char *sdata = data;\\r\\nint ellipticcurvelist_length = (*(sdata++) << 8);\\r\\nellipticcurvelist_length += (*(sdata++));\\r\\nif (ellipticcurvelist_length != size - 2 ||\\r\\nellipticcurvelist_length < 1 ||\\r\\nellipticcurvelist_length & 1) {\\r\\n*al = TLS1_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (!s->hit) {\\r\\nif (s->session->tlsext_ellipticcurvelist) {\\r\\n*al = TLS1_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\ns->session->tlsext_ellipticcurvelist_length = 0;\\r\\nif ((s->session->tlsext_ellipticcurvelist =\\r\\nOPENSSL_malloc(ellipticcurvelist_length)) == NULL) {\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\ns->session->tlsext_ellipticcurvelist_length =\\r\\nellipticcurvelist_length;\\r\\nmemcpy(s->session->tlsext_ellipticcurvelist, sdata,\\r\\nellipticcurvelist_length);\\r\\n}\\r\\n# if 0\\r\\nfprintf(stderr,\\r\\n\"ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) \",\\r\\ns->session->tlsext_ellipticcurvelist_length);\\r\\nsdata = s->session->tlsext_ellipticcurvelist;\\r\\nfor (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++)\\r\\nfprintf(stderr, \"%i \", *(sdata++));\\r\\nfprintf(stderr, \"\\n\");\\r\\n# endif\\r\\n}\\r\\n# endif\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nelse if (type == TLSEXT_TYPE_opaque_prf_input) {\\r\\nunsigned char *sdata = data;\\r\\nif (size < 2) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nn2s(sdata, s->s3->client_opaque_prf_input_len);\\r\\nif (s->s3->client_opaque_prf_input_len != size - 2) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (s->s3->client_opaque_prf_input != NULL) {\\r\\nOPENSSL_free(s->s3->client_opaque_prf_input);\\r\\n}\\r\\nif (s->s3->client_opaque_prf_input_len == 0)\\r\\ns->s3->client_opaque_prf_input = OPENSSL_malloc(1);\\r\\nelse\\r\\ns->s3->client_opaque_prf_input =\\r\\nBUF_memdup(sdata, s->s3->client_opaque_prf_input_len);\\r\\nif (s->s3->client_opaque_prf_input == NULL) {\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n# endif\\r\\nelse if (type == TLSEXT_TYPE_session_ticket) {\\r\\nif (s->tls_session_ticket_ext_cb &&\\r\\n!s->tls_session_ticket_ext_cb(s, data, size,\\r\\ns->tls_session_ticket_ext_cb_arg))\\r\\n{\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n} else if (type == TLSEXT_TYPE_renegotiate) {\\r\\nif (!ssl_parse_clienthello_renegotiate_ext(s, data, size, al))\\r\\nreturn 0;\\r\\nrenegotiate_seen = 1;\\r\\n} else if (type == TLSEXT_TYPE_signature_algorithms) {\\r\\nint dsize;\\r\\nif (s->cert->peer_sigalgs || size < 2) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nn2s(data, dsize);\\r\\nsize -= 2;\\r\\nif (dsize != size || dsize & 1 || !dsize) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (!tls1_save_sigalgs(s, data, dsize)) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n} else if (type == TLSEXT_TYPE_status_request) {\\r\\nif (size < 5) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\ns->tlsext_status_type = *data++;\\r\\nsize--;\\r\\nif (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {\\r\\nconst unsigned char *sdata;\\r\\nint dsize;\\r\\nn2s(data, dsize);\\r\\nsize -= 2;\\r\\nif (dsize > size) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nwhile (dsize > 0) {\\r\\nOCSP_RESPID *id;\\r\\nint idsize;\\r\\nif (dsize < 4) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nn2s(data, idsize);\\r\\ndsize -= 2 + idsize;\\r\\nsize -= 2 + idsize;\\r\\nif (dsize < 0) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nsdata = data;\\r\\ndata += idsize;\\r\\nid = d2i_OCSP_RESPID(NULL, &sdata, idsize);\\r\\nif (!id) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (data != sdata) {\\r\\nOCSP_RESPID_free(id);\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (!s->tlsext_ocsp_ids\\r\\n&& !(s->tlsext_ocsp_ids =\\r\\nsk_OCSP_RESPID_new_null())) {\\r\\nOCSP_RESPID_free(id);\\r\\n*al = SSL_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {\\r\\nOCSP_RESPID_free(id);\\r\\n*al = SSL_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (size < 2) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nn2s(data, dsize);\\r\\nsize -= 2;\\r\\nif (dsize != size) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nsdata = data;\\r\\nif (dsize > 0) {\\r\\nif (s->tlsext_ocsp_exts) {\\r\\nsk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,\\r\\nX509_EXTENSION_free);\\r\\n}\\r\\ns->tlsext_ocsp_exts =\\r\\nd2i_X509_EXTENSIONS(NULL, &sdata, dsize);\\r\\nif (!s->tlsext_ocsp_exts || (data + dsize != sdata)) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nelse\\r\\ns->tlsext_status_type = -1;\\r\\n}\\r\\n# ifndef OPENSSL_NO_HEARTBEATS\\r\\nelse if (type == TLSEXT_TYPE_heartbeat) {\\r\\nswitch (data[0]) {\\r\\ncase 0x01:\\r\\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\\r\\nbreak;\\r\\ncase 0x02:\\r\\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\\r\\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\\r\\nbreak;\\r\\ndefault:\\r\\n*al = SSL_AD_ILLEGAL_PARAMETER;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nelse if (type == TLSEXT_TYPE_next_proto_neg &&\\r\\ns->s3->tmp.finish_md_len == 0 &&\\r\\ns->s3->alpn_selected == NULL) {\\r\\ns->s3->next_proto_neg_seen = 1;\\r\\n}\\r\\n# endif\\r\\nelse if (type == TLSEXT_TYPE_application_layer_protocol_negotiation &&\\r\\ns->ctx->alpn_select_cb && s->s3->tmp.finish_md_len == 0) {\\r\\nif (tls1_alpn_handle_client_hello(s, data, size, al) != 0)\\r\\nreturn 0;\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\ns->s3->next_proto_neg_seen = 0;\\r\\n# endif\\r\\n}\\r\\n# ifndef OPENSSL_NO_SRTP\\r\\nelse if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)\\r\\n&& type == TLSEXT_TYPE_use_srtp) {\\r\\nif (ssl_parse_clienthello_use_srtp_ext(s, data, size, al))\\r\\nreturn 0;\\r\\n}\\r\\n# endif\\r\\ndata += size;\\r\\n}\\r\\n*p = data;\\r\\nri_check:\\r\\nif (!renegotiate_seen && s->renegotiate &&\\r\\n!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\\r\\n*al = SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT,\\r\\nSSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_scan_clienthello_custom_tlsext(SSL *s,\\r\\nconst unsigned char *data,\\r\\nconst unsigned char *limit,\\r\\nint *al)\\r\\n{\\r\\nunsigned short type, size, len;\\r\\nif (s->hit || s->cert->srv_ext.meths_count == 0)\\r\\nreturn 1;\\r\\nif (data >= limit - 2)\\r\\nreturn 1;\\r\\nn2s(data, len);\\r\\nif (data > limit - len)\\r\\nreturn 1;\\r\\nwhile (data <= limit - 4) {\\r\\nn2s(data, type);\\r\\nn2s(data, size);\\r\\nif (data + size > limit)\\r\\nreturn 1;\\r\\nif (custom_ext_parse(s, 1 , type, data, size, al) <= 0)\\r\\nreturn 0;\\r\\ndata += size;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d,\\r\\nint n)\\r\\n{\\r\\nint al = -1;\\r\\nunsigned char *ptmp = *p;\\r\\nif (ssl_scan_clienthello_tlsext(s, p, d, n, &al) <= 0) {\\r\\nssl3_send_alert(s, SSL3_AL_FATAL, al);\\r\\nreturn 0;\\r\\n}\\r\\nif (ssl_check_clienthello_tlsext_early(s) <= 0) {\\r\\nSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT, SSL_R_CLIENTHELLO_TLSEXT);\\r\\nreturn 0;\\r\\n}\\r\\ncustom_ext_init(&s->cert->srv_ext);\\r\\nif (ssl_scan_clienthello_custom_tlsext(s, ptmp, d + n, &al) <= 0) {\\r\\nssl3_send_alert(s, SSL3_AL_FATAL, al);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic char ssl_next_proto_validate(unsigned char *d, unsigned len)\\r\\n{\\r\\nunsigned int off = 0;\\r\\nwhile (off < len) {\\r\\nif (d[off] == 0)\\r\\nreturn 0;\\r\\noff += d[off];\\r\\noff++;\\r\\n}\\r\\nreturn off == len;\\r\\n}\\r\\nstatic int ssl_scan_serverhello_tlsext(SSL *s, unsigned char **p,\\r\\nunsigned char *d, int n, int *al)\\r\\n{\\r\\nunsigned short length;\\r\\nunsigned short type;\\r\\nunsigned short size;\\r\\nunsigned char *data = *p;\\r\\nint tlsext_servername = 0;\\r\\nint renegotiate_seen = 0;\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\ns->s3->next_proto_neg_seen = 0;\\r\\n# endif\\r\\ns->tlsext_ticket_expected = 0;\\r\\nif (s->s3->alpn_selected) {\\r\\nOPENSSL_free(s->s3->alpn_selected);\\r\\ns->s3->alpn_selected = NULL;\\r\\n}\\r\\n# ifndef OPENSSL_NO_HEARTBEATS\\r\\ns->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |\\r\\nSSL_TLSEXT_HB_DONT_SEND_REQUESTS);\\r\\n# endif\\r\\nif (data >= (d + n - 2))\\r\\ngoto ri_check;\\r\\nn2s(data, length);\\r\\nif (data + length != d + n) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nwhile (data <= (d + n - 4)) {\\r\\nn2s(data, type);\\r\\nn2s(data, size);\\r\\nif (data + size > (d + n))\\r\\ngoto ri_check;\\r\\nif (s->tlsext_debug_cb)\\r\\ns->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);\\r\\nif (type == TLSEXT_TYPE_server_name) {\\r\\nif (s->tlsext_hostname == NULL || size > 0) {\\r\\n*al = TLS1_AD_UNRECOGNIZED_NAME;\\r\\nreturn 0;\\r\\n}\\r\\ntlsext_servername = 1;\\r\\n}\\r\\n# ifndef OPENSSL_NO_EC\\r\\nelse if (type == TLSEXT_TYPE_ec_point_formats) {\\r\\nunsigned char *sdata = data;\\r\\nint ecpointformatlist_length = *(sdata++);\\r\\nif (ecpointformatlist_length != size - 1) {\\r\\n*al = TLS1_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (!s->hit) {\\r\\ns->session->tlsext_ecpointformatlist_length = 0;\\r\\nif (s->session->tlsext_ecpointformatlist != NULL)\\r\\nOPENSSL_free(s->session->tlsext_ecpointformatlist);\\r\\nif ((s->session->tlsext_ecpointformatlist =\\r\\nOPENSSL_malloc(ecpointformatlist_length)) == NULL) {\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\ns->session->tlsext_ecpointformatlist_length =\\r\\necpointformatlist_length;\\r\\nmemcpy(s->session->tlsext_ecpointformatlist, sdata,\\r\\necpointformatlist_length);\\r\\n}\\r\\n# if 0\\r\\nfprintf(stderr,\\r\\n\"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist \");\\r\\nsdata = s->session->tlsext_ecpointformatlist;\\r\\nfor (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++)\\r\\nfprintf(stderr, \"%i \", *(sdata++));\\r\\nfprintf(stderr, \"\\n\");\\r\\n# endif\\r\\n}\\r\\n# endif\\r\\nelse if (type == TLSEXT_TYPE_session_ticket) {\\r\\nif (s->tls_session_ticket_ext_cb &&\\r\\n!s->tls_session_ticket_ext_cb(s, data, size,\\r\\ns->tls_session_ticket_ext_cb_arg))\\r\\n{\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif ((SSL_get_options(s) & SSL_OP_NO_TICKET)\\r\\n|| (size > 0)) {\\r\\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\\r\\nreturn 0;\\r\\n}\\r\\ns->tlsext_ticket_expected = 1;\\r\\n}\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nelse if (type == TLSEXT_TYPE_opaque_prf_input) {\\r\\nunsigned char *sdata = data;\\r\\nif (size < 2) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nn2s(sdata, s->s3->server_opaque_prf_input_len);\\r\\nif (s->s3->server_opaque_prf_input_len != size - 2) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (s->s3->server_opaque_prf_input != NULL) {\\r\\nOPENSSL_free(s->s3->server_opaque_prf_input);\\r\\n}\\r\\nif (s->s3->server_opaque_prf_input_len == 0) {\\r\\ns->s3->server_opaque_prf_input = OPENSSL_malloc(1);\\r\\n} else {\\r\\ns->s3->server_opaque_prf_input =\\r\\nBUF_memdup(sdata, s->s3->server_opaque_prf_input_len);\\r\\n}\\r\\nif (s->s3->server_opaque_prf_input == NULL) {\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n# endif\\r\\nelse if (type == TLSEXT_TYPE_status_request) {\\r\\nif ((s->tlsext_status_type == -1) || (size > 0)) {\\r\\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\\r\\nreturn 0;\\r\\n}\\r\\ns->tlsext_status_expected = 1;\\r\\n}\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nelse if (type == TLSEXT_TYPE_next_proto_neg &&\\r\\ns->s3->tmp.finish_md_len == 0) {\\r\\nunsigned char *selected;\\r\\nunsigned char selected_len;\\r\\nif (s->ctx->next_proto_select_cb == NULL) {\\r\\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\\r\\nreturn 0;\\r\\n}\\r\\nif (!ssl_next_proto_validate(data, size)) {\\r\\n*al = TLS1_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (s->\\r\\nctx->next_proto_select_cb(s, &selected, &selected_len, data,\\r\\nsize,\\r\\ns->ctx->next_proto_select_cb_arg) !=\\r\\nSSL_TLSEXT_ERR_OK) {\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\ns->next_proto_negotiated = OPENSSL_malloc(selected_len);\\r\\nif (!s->next_proto_negotiated) {\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(s->next_proto_negotiated, selected, selected_len);\\r\\ns->next_proto_negotiated_len = selected_len;\\r\\ns->s3->next_proto_neg_seen = 1;\\r\\n}\\r\\n# endif\\r\\nelse if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) {\\r\\nunsigned len;\\r\\nif (s->alpn_client_proto_list == NULL) {\\r\\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\\r\\nreturn 0;\\r\\n}\\r\\nif (size < 4) {\\r\\n*al = TLS1_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nlen = data[0];\\r\\nlen <<= 8;\\r\\nlen |= data[1];\\r\\nif (len != (unsigned)size - 2) {\\r\\n*al = TLS1_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nlen = data[2];\\r\\nif (len != (unsigned)size - 3) {\\r\\n*al = TLS1_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (s->s3->alpn_selected)\\r\\nOPENSSL_free(s->s3->alpn_selected);\\r\\ns->s3->alpn_selected = OPENSSL_malloc(len);\\r\\nif (!s->s3->alpn_selected) {\\r\\n*al = TLS1_AD_INTERNAL_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(s->s3->alpn_selected, data + 3, len);\\r\\ns->s3->alpn_selected_len = len;\\r\\n}\\r\\nelse if (type == TLSEXT_TYPE_renegotiate) {\\r\\nif (!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))\\r\\nreturn 0;\\r\\nrenegotiate_seen = 1;\\r\\n}\\r\\n# ifndef OPENSSL_NO_HEARTBEATS\\r\\nelse if (type == TLSEXT_TYPE_heartbeat) {\\r\\nswitch (data[0]) {\\r\\ncase 0x01:\\r\\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\\r\\nbreak;\\r\\ncase 0x02:\\r\\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;\\r\\ns->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\\r\\nbreak;\\r\\ndefault:\\r\\n*al = SSL_AD_ILLEGAL_PARAMETER;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SRTP\\r\\nelse if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {\\r\\nif (ssl_parse_serverhello_use_srtp_ext(s, data, size, al))\\r\\nreturn 0;\\r\\n}\\r\\n# endif\\r\\nelse if (custom_ext_parse(s, 0, type, data, size, al) <= 0)\\r\\nreturn 0;\\r\\ndata += size;\\r\\n}\\r\\nif (data != d + n) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (!s->hit && tlsext_servername == 1) {\\r\\nif (s->tlsext_hostname) {\\r\\nif (s->session->tlsext_hostname == NULL) {\\r\\ns->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);\\r\\nif (!s->session->tlsext_hostname) {\\r\\n*al = SSL_AD_UNRECOGNIZED_NAME;\\r\\nreturn 0;\\r\\n}\\r\\n} else {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\n*p = data;\\r\\nri_check:\\r\\nif (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)\\r\\n&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {\\r\\n*al = SSL_AD_HANDSHAKE_FAILURE;\\r\\nSSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,\\r\\nSSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_prepare_clienthello_tlsext(SSL *s)\\r\\n{\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\n{\\r\\nint r = 1;\\r\\nif (s->ctx->tlsext_opaque_prf_input_callback != 0) {\\r\\nr = s->ctx->tlsext_opaque_prf_input_callback(s, NULL, 0,\\r\\ns->\\r\\nctx->tlsext_opaque_prf_input_callback_arg);\\r\\nif (!r)\\r\\nreturn -1;\\r\\n}\\r\\nif (s->tlsext_opaque_prf_input != NULL) {\\r\\nif (s->s3->client_opaque_prf_input != NULL) {\\r\\nOPENSSL_free(s->s3->client_opaque_prf_input);\\r\\n}\\r\\nif (s->tlsext_opaque_prf_input_len == 0) {\\r\\ns->s3->client_opaque_prf_input = OPENSSL_malloc(1);\\r\\n} else {\\r\\ns->s3->client_opaque_prf_input =\\r\\nBUF_memdup(s->tlsext_opaque_prf_input,\\r\\ns->tlsext_opaque_prf_input_len);\\r\\n}\\r\\nif (s->s3->client_opaque_prf_input == NULL) {\\r\\nSSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,\\r\\nERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\ns->s3->client_opaque_prf_input_len =\\r\\ns->tlsext_opaque_prf_input_len;\\r\\n}\\r\\nif (r == 2)\\r\\ns->s3->server_opaque_prf_input_len =\\r\\ns->tlsext_opaque_prf_input_len;\\r\\n}\\r\\n# endif\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_prepare_serverhello_tlsext(SSL *s)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_check_clienthello_tlsext_early(SSL *s)\\r\\n{\\r\\nint ret = SSL_TLSEXT_ERR_NOACK;\\r\\nint al = SSL_AD_UNRECOGNIZED_NAME;\\r\\n# ifndef OPENSSL_NO_EC\\r\\n# endif\\r\\nif (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0)\\r\\nret =\\r\\ns->ctx->tlsext_servername_callback(s, &al,\\r\\ns->ctx->tlsext_servername_arg);\\r\\nelse if (s->initial_ctx != NULL\\r\\n&& s->initial_ctx->tlsext_servername_callback != 0)\\r\\nret =\\r\\ns->initial_ctx->tlsext_servername_callback(s, &al,\\r\\ns->\\r\\ninitial_ctx->tlsext_servername_arg);\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\n{\\r\\nint r = 1;\\r\\nif (s->ctx->tlsext_opaque_prf_input_callback != 0) {\\r\\nr = s->ctx->tlsext_opaque_prf_input_callback(s, NULL, 0,\\r\\ns->\\r\\nctx->tlsext_opaque_prf_input_callback_arg);\\r\\nif (!r) {\\r\\nret = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\nal = SSL_AD_INTERNAL_ERROR;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (s->s3->server_opaque_prf_input != NULL) {\\r\\nOPENSSL_free(s->s3->server_opaque_prf_input);\\r\\n}\\r\\ns->s3->server_opaque_prf_input = NULL;\\r\\nif (s->tlsext_opaque_prf_input != NULL) {\\r\\nif (s->s3->client_opaque_prf_input != NULL &&\\r\\ns->s3->client_opaque_prf_input_len ==\\r\\ns->tlsext_opaque_prf_input_len) {\\r\\nif (s->tlsext_opaque_prf_input_len == 0) {\\r\\ns->s3->server_opaque_prf_input = OPENSSL_malloc(1);\\r\\n} else {\\r\\ns->s3->server_opaque_prf_input =\\r\\nBUF_memdup(s->tlsext_opaque_prf_input,\\r\\ns->tlsext_opaque_prf_input_len);\\r\\n}\\r\\nif (s->s3->server_opaque_prf_input == NULL) {\\r\\nret = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\nal = SSL_AD_INTERNAL_ERROR;\\r\\ngoto err;\\r\\n}\\r\\ns->s3->server_opaque_prf_input_len =\\r\\ns->tlsext_opaque_prf_input_len;\\r\\n}\\r\\n}\\r\\nif (r == 2 && s->s3->server_opaque_prf_input == NULL) {\\r\\nret = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\nal = SSL_AD_HANDSHAKE_FAILURE;\\r\\n}\\r\\n}\\r\\nerr:\\r\\n# endif\\r\\nswitch (ret) {\\r\\ncase SSL_TLSEXT_ERR_ALERT_FATAL:\\r\\nssl3_send_alert(s, SSL3_AL_FATAL, al);\\r\\nreturn -1;\\r\\ncase SSL_TLSEXT_ERR_ALERT_WARNING:\\r\\nssl3_send_alert(s, SSL3_AL_WARNING, al);\\r\\nreturn 1;\\r\\ncase SSL_TLSEXT_ERR_NOACK:\\r\\ns->servername_done = 0;\\r\\ndefault:\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nint tls1_set_server_sigalgs(SSL *s)\\r\\n{\\r\\nint al;\\r\\nsize_t i;\\r\\nif (s->cert->shared_sigalgs) {\\r\\nOPENSSL_free(s->cert->shared_sigalgs);\\r\\ns->cert->shared_sigalgs = NULL;\\r\\n}\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++) {\\r\\ns->cert->pkeys[i].digest = NULL;\\r\\ns->cert->pkeys[i].valid_flags = 0;\\r\\n}\\r\\nif (s->cert->peer_sigalgs) {\\r\\nif (!tls1_process_sigalgs(s)) {\\r\\nSSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS, ERR_R_MALLOC_FAILURE);\\r\\nal = SSL_AD_INTERNAL_ERROR;\\r\\ngoto err;\\r\\n}\\r\\nif (!s->cert->shared_sigalgs) {\\r\\nSSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS,\\r\\nSSL_R_NO_SHARED_SIGATURE_ALGORITHMS);\\r\\nal = SSL_AD_ILLEGAL_PARAMETER;\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\nssl_cert_set_default_md(s->cert);\\r\\nreturn 1;\\r\\nerr:\\r\\nssl3_send_alert(s, SSL3_AL_FATAL, al);\\r\\nreturn 0;\\r\\n}\\r\\nint ssl_check_clienthello_tlsext_late(SSL *s)\\r\\n{\\r\\nint ret = SSL_TLSEXT_ERR_OK;\\r\\nint al;\\r\\nif ((s->tlsext_status_type != -1) && s->ctx && s->ctx->tlsext_status_cb) {\\r\\nint r;\\r\\nCERT_PKEY *certpkey;\\r\\ncertpkey = ssl_get_server_send_pkey(s);\\r\\nif (certpkey == NULL) {\\r\\ns->tlsext_status_expected = 0;\\r\\nreturn 1;\\r\\n}\\r\\ns->cert->key = certpkey;\\r\\nr = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);\\r\\nswitch (r) {\\r\\ncase SSL_TLSEXT_ERR_NOACK:\\r\\ns->tlsext_status_expected = 0;\\r\\nbreak;\\r\\ncase SSL_TLSEXT_ERR_OK:\\r\\nif (s->tlsext_ocsp_resp)\\r\\ns->tlsext_status_expected = 1;\\r\\nelse\\r\\ns->tlsext_status_expected = 0;\\r\\nbreak;\\r\\ncase SSL_TLSEXT_ERR_ALERT_FATAL:\\r\\nret = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\nal = SSL_AD_INTERNAL_ERROR;\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\ns->tlsext_status_expected = 0;\\r\\nerr:\\r\\nswitch (ret) {\\r\\ncase SSL_TLSEXT_ERR_ALERT_FATAL:\\r\\nssl3_send_alert(s, SSL3_AL_FATAL, al);\\r\\nreturn -1;\\r\\ncase SSL_TLSEXT_ERR_ALERT_WARNING:\\r\\nssl3_send_alert(s, SSL3_AL_WARNING, al);\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nint ssl_check_serverhello_tlsext(SSL *s)\\r\\n{\\r\\nint ret = SSL_TLSEXT_ERR_NOACK;\\r\\nint al = SSL_AD_UNRECOGNIZED_NAME;\\r\\n# ifndef OPENSSL_NO_EC\\r\\nunsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\\r\\nunsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\\r\\nif ((s->tlsext_ecpointformatlist != NULL)\\r\\n&& (s->tlsext_ecpointformatlist_length > 0)\\r\\n&& (s->session->tlsext_ecpointformatlist != NULL)\\r\\n&& (s->session->tlsext_ecpointformatlist_length > 0)\\r\\n&& ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe))\\r\\n|| (alg_a & SSL_aECDSA))) {\\r\\nsize_t i;\\r\\nunsigned char *list;\\r\\nint found_uncompressed = 0;\\r\\nlist = s->session->tlsext_ecpointformatlist;\\r\\nfor (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) {\\r\\nif (*(list++) == TLSEXT_ECPOINTFORMAT_uncompressed) {\\r\\nfound_uncompressed = 1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!found_uncompressed) {\\r\\nSSLerr(SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT,\\r\\nSSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nret = SSL_TLSEXT_ERR_OK;\\r\\n# endif\\r\\nif (s->ctx != NULL && s->ctx->tlsext_servername_callback != 0)\\r\\nret =\\r\\ns->ctx->tlsext_servername_callback(s, &al,\\r\\ns->ctx->tlsext_servername_arg);\\r\\nelse if (s->initial_ctx != NULL\\r\\n&& s->initial_ctx->tlsext_servername_callback != 0)\\r\\nret =\\r\\ns->initial_ctx->tlsext_servername_callback(s, &al,\\r\\ns->\\r\\ninitial_ctx->tlsext_servername_arg);\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nif (s->s3->server_opaque_prf_input_len > 0) {\\r\\nif (s->s3->server_opaque_prf_input == NULL) {\\r\\nret = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\nal = SSL_AD_HANDSHAKE_FAILURE;\\r\\n}\\r\\nif (s->s3->client_opaque_prf_input == NULL ||\\r\\ns->s3->client_opaque_prf_input_len !=\\r\\ns->s3->server_opaque_prf_input_len) {\\r\\nret = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\nal = SSL_AD_ILLEGAL_PARAMETER;\\r\\n}\\r\\n}\\r\\n# endif\\r\\nif ((s->tlsext_status_type != -1) && !(s->tlsext_status_expected)\\r\\n&& s->ctx && s->ctx->tlsext_status_cb) {\\r\\nint r;\\r\\nif (s->tlsext_ocsp_resp) {\\r\\nOPENSSL_free(s->tlsext_ocsp_resp);\\r\\ns->tlsext_ocsp_resp = NULL;\\r\\n}\\r\\ns->tlsext_ocsp_resplen = -1;\\r\\nr = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);\\r\\nif (r == 0) {\\r\\nal = SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE;\\r\\nret = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\n}\\r\\nif (r < 0) {\\r\\nal = SSL_AD_INTERNAL_ERROR;\\r\\nret = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\n}\\r\\n}\\r\\nswitch (ret) {\\r\\ncase SSL_TLSEXT_ERR_ALERT_FATAL:\\r\\nssl3_send_alert(s, SSL3_AL_FATAL, al);\\r\\nreturn -1;\\r\\ncase SSL_TLSEXT_ERR_ALERT_WARNING:\\r\\nssl3_send_alert(s, SSL3_AL_WARNING, al);\\r\\nreturn 1;\\r\\ncase SSL_TLSEXT_ERR_NOACK:\\r\\ns->servername_done = 0;\\r\\ndefault:\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nint ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d,\\r\\nint n)\\r\\n{\\r\\nint al = -1;\\r\\nif (s->version < SSL3_VERSION)\\r\\nreturn 1;\\r\\nif (ssl_scan_serverhello_tlsext(s, p, d, n, &al) <= 0) {\\r\\nssl3_send_alert(s, SSL3_AL_FATAL, al);\\r\\nreturn 0;\\r\\n}\\r\\nif (ssl_check_serverhello_tlsext(s) <= 0) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT, SSL_R_SERVERHELLO_TLSEXT);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint tls1_process_ticket(SSL *s, unsigned char *session_id, int len,\\r\\nconst unsigned char *limit, SSL_SESSION **ret)\\r\\n{\\r\\nconst unsigned char *p = session_id + len;\\r\\nunsigned short i;\\r\\n*ret = NULL;\\r\\ns->tlsext_ticket_expected = 0;\\r\\nif (SSL_get_options(s) & SSL_OP_NO_TICKET)\\r\\nreturn 0;\\r\\nif ((s->version <= SSL3_VERSION) || !limit)\\r\\nreturn 0;\\r\\nif (p >= limit)\\r\\nreturn -1;\\r\\nif (SSL_IS_DTLS(s)) {\\r\\ni = *(p++);\\r\\np += i;\\r\\nif (p >= limit)\\r\\nreturn -1;\\r\\n}\\r\\nn2s(p, i);\\r\\np += i;\\r\\nif (p >= limit)\\r\\nreturn -1;\\r\\ni = *(p++);\\r\\np += i;\\r\\nif (p > limit)\\r\\nreturn -1;\\r\\nif ((p + 2) >= limit)\\r\\nreturn 0;\\r\\nn2s(p, i);\\r\\nwhile ((p + 4) <= limit) {\\r\\nunsigned short type, size;\\r\\nn2s(p, type);\\r\\nn2s(p, size);\\r\\nif (p + size > limit)\\r\\nreturn 0;\\r\\nif (type == TLSEXT_TYPE_session_ticket) {\\r\\nint r;\\r\\nif (size == 0) {\\r\\ns->tlsext_ticket_expected = 1;\\r\\nreturn 1;\\r\\n}\\r\\nif (s->tls_session_secret_cb) {\\r\\nreturn 2;\\r\\n}\\r\\nr = tls_decrypt_ticket(s, p, size, session_id, len, ret);\\r\\nswitch (r) {\\r\\ncase 2:\\r\\ns->tlsext_ticket_expected = 1;\\r\\nreturn 2;\\r\\ncase 3:\\r\\nreturn r;\\r\\ncase 4:\\r\\ns->tlsext_ticket_expected = 1;\\r\\nreturn 3;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\np += size;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\\r\\nint eticklen, const unsigned char *sess_id,\\r\\nint sesslen, SSL_SESSION **psess)\\r\\n{\\r\\nSSL_SESSION *sess;\\r\\nunsigned char *sdec;\\r\\nconst unsigned char *p;\\r\\nint slen, mlen, renew_ticket = 0;\\r\\nunsigned char tick_hmac[EVP_MAX_MD_SIZE];\\r\\nHMAC_CTX hctx;\\r\\nEVP_CIPHER_CTX ctx;\\r\\nSSL_CTX *tctx = s->initial_ctx;\\r\\nif (eticklen < 48)\\r\\nreturn 2;\\r\\nHMAC_CTX_init(&hctx);\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nif (tctx->tlsext_ticket_key_cb) {\\r\\nunsigned char *nctick = (unsigned char *)etick;\\r\\nint rv = tctx->tlsext_ticket_key_cb(s, nctick, nctick + 16,\\r\\n&ctx, &hctx, 0);\\r\\nif (rv < 0)\\r\\nreturn -1;\\r\\nif (rv == 0)\\r\\nreturn 2;\\r\\nif (rv == 2)\\r\\nrenew_ticket = 1;\\r\\n} else {\\r\\nif (memcmp(etick, tctx->tlsext_tick_key_name, 16))\\r\\nreturn 2;\\r\\nHMAC_Init_ex(&hctx, tctx->tlsext_tick_hmac_key, 16,\\r\\ntlsext_tick_md(), NULL);\\r\\nEVP_DecryptInit_ex(&ctx, EVP_aes_128_cbc(), NULL,\\r\\ntctx->tlsext_tick_aes_key, etick + 16);\\r\\n}\\r\\nmlen = HMAC_size(&hctx);\\r\\nif (mlen < 0) {\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nreturn -1;\\r\\n}\\r\\neticklen -= mlen;\\r\\nHMAC_Update(&hctx, etick, eticklen);\\r\\nHMAC_Final(&hctx, tick_hmac, NULL);\\r\\nHMAC_CTX_cleanup(&hctx);\\r\\nif (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen)) {\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nreturn 2;\\r\\n}\\r\\np = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);\\r\\neticklen -= 16 + EVP_CIPHER_CTX_iv_length(&ctx);\\r\\nsdec = OPENSSL_malloc(eticklen);\\r\\nif (!sdec) {\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nreturn -1;\\r\\n}\\r\\nEVP_DecryptUpdate(&ctx, sdec, &slen, p, eticklen);\\r\\nif (EVP_DecryptFinal(&ctx, sdec + slen, &mlen) <= 0) {\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nOPENSSL_free(sdec);\\r\\nreturn 2;\\r\\n}\\r\\nslen += mlen;\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\np = sdec;\\r\\nsess = d2i_SSL_SESSION(NULL, &p, slen);\\r\\nOPENSSL_free(sdec);\\r\\nif (sess) {\\r\\nif (sesslen)\\r\\nmemcpy(sess->session_id, sess_id, sesslen);\\r\\nsess->session_id_length = sesslen;\\r\\n*psess = sess;\\r\\nif (renew_ticket)\\r\\nreturn 4;\\r\\nelse\\r\\nreturn 3;\\r\\n}\\r\\nERR_clear_error();\\r\\nreturn 2;\\r\\n}\\r\\nstatic int tls12_find_id(int nid, tls12_lookup *table, size_t tlen)\\r\\n{\\r\\nsize_t i;\\r\\nfor (i = 0; i < tlen; i++) {\\r\\nif (table[i].nid == nid)\\r\\nreturn table[i].id;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nstatic int tls12_find_nid(int id, tls12_lookup *table, size_t tlen)\\r\\n{\\r\\nsize_t i;\\r\\nfor (i = 0; i < tlen; i++) {\\r\\nif ((table[i].id) == id)\\r\\nreturn table[i].nid;\\r\\n}\\r\\nreturn NID_undef;\\r\\n}\\r\\nint tls12_get_sigandhash(unsigned char *p, const EVP_PKEY *pk,\\r\\nconst EVP_MD *md)\\r\\n{\\r\\nint sig_id, md_id;\\r\\nif (!md)\\r\\nreturn 0;\\r\\nmd_id = tls12_find_id(EVP_MD_type(md), tls12_md,\\r\\nsizeof(tls12_md) / sizeof(tls12_lookup));\\r\\nif (md_id == -1)\\r\\nreturn 0;\\r\\nsig_id = tls12_get_sigid(pk);\\r\\nif (sig_id == -1)\\r\\nreturn 0;\\r\\np[0] = (unsigned char)md_id;\\r\\np[1] = (unsigned char)sig_id;\\r\\nreturn 1;\\r\\n}\\r\\nint tls12_get_sigid(const EVP_PKEY *pk)\\r\\n{\\r\\nreturn tls12_find_id(pk->type, tls12_sig,\\r\\nsizeof(tls12_sig) / sizeof(tls12_lookup));\\r\\n}\\r\\nconst EVP_MD *tls12_get_hash(unsigned char hash_alg)\\r\\n{\\r\\nswitch (hash_alg) {\\r\\n# ifndef OPENSSL_NO_MD5\\r\\ncase TLSEXT_hash_md5:\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn NULL;\\r\\n# endif\\r\\nreturn EVP_md5();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SHA\\r\\ncase TLSEXT_hash_sha1:\\r\\nreturn EVP_sha1();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SHA256\\r\\ncase TLSEXT_hash_sha224:\\r\\nreturn EVP_sha224();\\r\\ncase TLSEXT_hash_sha256:\\r\\nreturn EVP_sha256();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SHA512\\r\\ncase TLSEXT_hash_sha384:\\r\\nreturn EVP_sha384();\\r\\ncase TLSEXT_hash_sha512:\\r\\nreturn EVP_sha512();\\r\\n# endif\\r\\ndefault:\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nstatic int tls12_get_pkey_idx(unsigned char sig_alg)\\r\\n{\\r\\nswitch (sig_alg) {\\r\\n# ifndef OPENSSL_NO_RSA\\r\\ncase TLSEXT_signature_rsa:\\r\\nreturn SSL_PKEY_RSA_SIGN;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DSA\\r\\ncase TLSEXT_signature_dsa:\\r\\nreturn SSL_PKEY_DSA_SIGN;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ECDSA\\r\\ncase TLSEXT_signature_ecdsa:\\r\\nreturn SSL_PKEY_ECC;\\r\\n# endif\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nstatic void tls1_lookup_sigalg(int *phash_nid, int *psign_nid,\\r\\nint *psignhash_nid, const unsigned char *data)\\r\\n{\\r\\nint sign_nid = 0, hash_nid = 0;\\r\\nif (!phash_nid && !psign_nid && !psignhash_nid)\\r\\nreturn;\\r\\nif (phash_nid || psignhash_nid) {\\r\\nhash_nid = tls12_find_nid(data[0], tls12_md,\\r\\nsizeof(tls12_md) / sizeof(tls12_lookup));\\r\\nif (phash_nid)\\r\\n*phash_nid = hash_nid;\\r\\n}\\r\\nif (psign_nid || psignhash_nid) {\\r\\nsign_nid = tls12_find_nid(data[1], tls12_sig,\\r\\nsizeof(tls12_sig) / sizeof(tls12_lookup));\\r\\nif (psign_nid)\\r\\n*psign_nid = sign_nid;\\r\\n}\\r\\nif (psignhash_nid) {\\r\\nif (sign_nid && hash_nid)\\r\\nOBJ_find_sigid_by_algs(psignhash_nid, hash_nid, sign_nid);\\r\\nelse\\r\\n*psignhash_nid = NID_undef;\\r\\n}\\r\\n}\\r\\nstatic int tls12_do_shared_sigalgs(TLS_SIGALGS *shsig,\\r\\nconst unsigned char *pref, size_t preflen,\\r\\nconst unsigned char *allow,\\r\\nsize_t allowlen)\\r\\n{\\r\\nconst unsigned char *ptmp, *atmp;\\r\\nsize_t i, j, nmatch = 0;\\r\\nfor (i = 0, ptmp = pref; i < preflen; i += 2, ptmp += 2) {\\r\\nif (tls12_get_hash(ptmp[0]) == NULL)\\r\\ncontinue;\\r\\nif (tls12_get_pkey_idx(ptmp[1]) == -1)\\r\\ncontinue;\\r\\nfor (j = 0, atmp = allow; j < allowlen; j += 2, atmp += 2) {\\r\\nif (ptmp[0] == atmp[0] && ptmp[1] == atmp[1]) {\\r\\nnmatch++;\\r\\nif (shsig) {\\r\\nshsig->rhash = ptmp[0];\\r\\nshsig->rsign = ptmp[1];\\r\\ntls1_lookup_sigalg(&shsig->hash_nid,\\r\\n&shsig->sign_nid,\\r\\n&shsig->signandhash_nid, ptmp);\\r\\nshsig++;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn nmatch;\\r\\n}\\r\\nstatic int tls1_set_shared_sigalgs(SSL *s)\\r\\n{\\r\\nconst unsigned char *pref, *allow, *conf;\\r\\nsize_t preflen, allowlen, conflen;\\r\\nsize_t nmatch;\\r\\nTLS_SIGALGS *salgs = NULL;\\r\\nCERT *c = s->cert;\\r\\nunsigned int is_suiteb = tls1_suiteb(s);\\r\\nif (c->shared_sigalgs) {\\r\\nOPENSSL_free(c->shared_sigalgs);\\r\\nc->shared_sigalgs = NULL;\\r\\n}\\r\\nif (!s->server && c->client_sigalgs && !is_suiteb) {\\r\\nconf = c->client_sigalgs;\\r\\nconflen = c->client_sigalgslen;\\r\\n} else if (c->conf_sigalgs && !is_suiteb) {\\r\\nconf = c->conf_sigalgs;\\r\\nconflen = c->conf_sigalgslen;\\r\\n} else\\r\\nconflen = tls12_get_psigalgs(s, &conf);\\r\\nif (s->options & SSL_OP_CIPHER_SERVER_PREFERENCE || is_suiteb) {\\r\\npref = conf;\\r\\npreflen = conflen;\\r\\nallow = c->peer_sigalgs;\\r\\nallowlen = c->peer_sigalgslen;\\r\\n} else {\\r\\nallow = conf;\\r\\nallowlen = conflen;\\r\\npref = c->peer_sigalgs;\\r\\npreflen = c->peer_sigalgslen;\\r\\n}\\r\\nnmatch = tls12_do_shared_sigalgs(NULL, pref, preflen, allow, allowlen);\\r\\nif (!nmatch)\\r\\nreturn 1;\\r\\nsalgs = OPENSSL_malloc(nmatch * sizeof(TLS_SIGALGS));\\r\\nif (!salgs)\\r\\nreturn 0;\\r\\nnmatch = tls12_do_shared_sigalgs(salgs, pref, preflen, allow, allowlen);\\r\\nc->shared_sigalgs = salgs;\\r\\nc->shared_sigalgslen = nmatch;\\r\\nreturn 1;\\r\\n}\\r\\nint tls1_save_sigalgs(SSL *s, const unsigned char *data, int dsize)\\r\\n{\\r\\nCERT *c = s->cert;\\r\\nif (!SSL_USE_SIGALGS(s))\\r\\nreturn 1;\\r\\nif (!c)\\r\\nreturn 0;\\r\\nif (c->peer_sigalgs)\\r\\nOPENSSL_free(c->peer_sigalgs);\\r\\nc->peer_sigalgs = OPENSSL_malloc(dsize);\\r\\nif (!c->peer_sigalgs)\\r\\nreturn 0;\\r\\nc->peer_sigalgslen = dsize;\\r\\nmemcpy(c->peer_sigalgs, data, dsize);\\r\\nreturn 1;\\r\\n}\\r\\nint tls1_process_sigalgs(SSL *s)\\r\\n{\\r\\nint idx;\\r\\nsize_t i;\\r\\nconst EVP_MD *md;\\r\\nCERT *c = s->cert;\\r\\nTLS_SIGALGS *sigptr;\\r\\nif (!tls1_set_shared_sigalgs(s))\\r\\nreturn 0;\\r\\n# ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\\r\\nif (s->cert->cert_flags & SSL_CERT_FLAG_BROKEN_PROTOCOL) {\\r\\nconst unsigned char *sigs = NULL;\\r\\nif (s->server)\\r\\nsigs = c->conf_sigalgs;\\r\\nelse\\r\\nsigs = c->client_sigalgs;\\r\\nif (sigs) {\\r\\nidx = tls12_get_pkey_idx(sigs[1]);\\r\\nmd = tls12_get_hash(sigs[0]);\\r\\nc->pkeys[idx].digest = md;\\r\\nc->pkeys[idx].valid_flags = CERT_PKEY_EXPLICIT_SIGN;\\r\\nif (idx == SSL_PKEY_RSA_SIGN) {\\r\\nc->pkeys[SSL_PKEY_RSA_ENC].valid_flags =\\r\\nCERT_PKEY_EXPLICIT_SIGN;\\r\\nc->pkeys[SSL_PKEY_RSA_ENC].digest = md;\\r\\n}\\r\\n}\\r\\n}\\r\\n# endif\\r\\nfor (i = 0, sigptr = c->shared_sigalgs;\\r\\ni < c->shared_sigalgslen; i++, sigptr++) {\\r\\nidx = tls12_get_pkey_idx(sigptr->rsign);\\r\\nif (idx > 0 && c->pkeys[idx].digest == NULL) {\\r\\nmd = tls12_get_hash(sigptr->rhash);\\r\\nc->pkeys[idx].digest = md;\\r\\nc->pkeys[idx].valid_flags = CERT_PKEY_EXPLICIT_SIGN;\\r\\nif (idx == SSL_PKEY_RSA_SIGN) {\\r\\nc->pkeys[SSL_PKEY_RSA_ENC].valid_flags =\\r\\nCERT_PKEY_EXPLICIT_SIGN;\\r\\nc->pkeys[SSL_PKEY_RSA_ENC].digest = md;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!(s->cert->cert_flags & SSL_CERT_FLAGS_CHECK_TLS_STRICT)) {\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nif (!c->pkeys[SSL_PKEY_DSA_SIGN].digest)\\r\\nc->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_sha1();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nif (!c->pkeys[SSL_PKEY_RSA_SIGN].digest) {\\r\\nc->pkeys[SSL_PKEY_RSA_SIGN].digest = EVP_sha1();\\r\\nc->pkeys[SSL_PKEY_RSA_ENC].digest = EVP_sha1();\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ECDSA\\r\\nif (!c->pkeys[SSL_PKEY_ECC].digest)\\r\\nc->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();\\r\\n# endif\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_get_sigalgs(SSL *s, int idx,\\r\\nint *psign, int *phash, int *psignhash,\\r\\nunsigned char *rsig, unsigned char *rhash)\\r\\n{\\r\\nconst unsigned char *psig = s->cert->peer_sigalgs;\\r\\nif (psig == NULL)\\r\\nreturn 0;\\r\\nif (idx >= 0) {\\r\\nidx <<= 1;\\r\\nif (idx >= (int)s->cert->peer_sigalgslen)\\r\\nreturn 0;\\r\\npsig += idx;\\r\\nif (rhash)\\r\\n*rhash = psig[0];\\r\\nif (rsig)\\r\\n*rsig = psig[1];\\r\\ntls1_lookup_sigalg(phash, psign, psignhash, psig);\\r\\n}\\r\\nreturn s->cert->peer_sigalgslen / 2;\\r\\n}\\r\\nint SSL_get_shared_sigalgs(SSL *s, int idx,\\r\\nint *psign, int *phash, int *psignhash,\\r\\nunsigned char *rsig, unsigned char *rhash)\\r\\n{\\r\\nTLS_SIGALGS *shsigalgs = s->cert->shared_sigalgs;\\r\\nif (!shsigalgs || idx >= (int)s->cert->shared_sigalgslen)\\r\\nreturn 0;\\r\\nshsigalgs += idx;\\r\\nif (phash)\\r\\n*phash = shsigalgs->hash_nid;\\r\\nif (psign)\\r\\n*psign = shsigalgs->sign_nid;\\r\\nif (psignhash)\\r\\n*psignhash = shsigalgs->signandhash_nid;\\r\\nif (rsig)\\r\\n*rsig = shsigalgs->rsign;\\r\\nif (rhash)\\r\\n*rhash = shsigalgs->rhash;\\r\\nreturn s->cert->shared_sigalgslen;\\r\\n}\\r\\nint tls1_process_heartbeat(SSL *s)\\r\\n{\\r\\nunsigned char *p = &s->s3->rrec.data[0], *pl;\\r\\nunsigned short hbtype;\\r\\nunsigned int payload;\\r\\nunsigned int padding = 16;\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,\\r\\n&s->s3->rrec.data[0], s->s3->rrec.length,\\r\\ns, s->msg_callback_arg);\\r\\nif (1 + 2 + 16 > s->s3->rrec.length)\\r\\nreturn 0;\\r\\nhbtype = *p++;\\r\\nn2s(p, payload);\\r\\nif (1 + 2 + payload + 16 > s->s3->rrec.length)\\r\\nreturn 0;\\r\\npl = p;\\r\\nif (hbtype == TLS1_HB_REQUEST) {\\r\\nunsigned char *buffer, *bp;\\r\\nint r;\\r\\nbuffer = OPENSSL_malloc(1 + 2 + payload + padding);\\r\\nbp = buffer;\\r\\n*bp++ = TLS1_HB_RESPONSE;\\r\\ns2n(payload, bp);\\r\\nmemcpy(bp, pl, payload);\\r\\nbp += payload;\\r\\nRAND_pseudo_bytes(bp, padding);\\r\\nr = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buffer,\\r\\n3 + payload + padding);\\r\\nif (r >= 0 && s->msg_callback)\\r\\ns->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,\\r\\nbuffer, 3 + payload + padding,\\r\\ns, s->msg_callback_arg);\\r\\nOPENSSL_free(buffer);\\r\\nif (r < 0)\\r\\nreturn r;\\r\\n} else if (hbtype == TLS1_HB_RESPONSE) {\\r\\nunsigned int seq;\\r\\nn2s(pl, seq);\\r\\nif (payload == 18 && seq == s->tlsext_hb_seq) {\\r\\ns->tlsext_hb_seq++;\\r\\ns->tlsext_hb_pending = 0;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint tls1_heartbeat(SSL *s)\\r\\n{\\r\\nunsigned char *buf, *p;\\r\\nint ret;\\r\\nunsigned int payload = 18;\\r\\nunsigned int padding = 16;\\r\\nif (!(s->tlsext_heartbeat & SSL_TLSEXT_HB_ENABLED) ||\\r\\ns->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_SEND_REQUESTS) {\\r\\nSSLerr(SSL_F_TLS1_HEARTBEAT, SSL_R_TLS_HEARTBEAT_PEER_DOESNT_ACCEPT);\\r\\nreturn -1;\\r\\n}\\r\\nif (s->tlsext_hb_pending) {\\r\\nSSLerr(SSL_F_TLS1_HEARTBEAT, SSL_R_TLS_HEARTBEAT_PENDING);\\r\\nreturn -1;\\r\\n}\\r\\nif (SSL_in_init(s) || s->in_handshake) {\\r\\nSSLerr(SSL_F_TLS1_HEARTBEAT, SSL_R_UNEXPECTED_MESSAGE);\\r\\nreturn -1;\\r\\n}\\r\\nOPENSSL_assert(payload + padding <= 16381);\\r\\nbuf = OPENSSL_malloc(1 + 2 + payload + padding);\\r\\np = buf;\\r\\n*p++ = TLS1_HB_REQUEST;\\r\\ns2n(payload, p);\\r\\ns2n(s->tlsext_hb_seq, p);\\r\\nRAND_pseudo_bytes(p, 16);\\r\\np += 16;\\r\\nRAND_pseudo_bytes(p, padding);\\r\\nret = ssl3_write_bytes(s, TLS1_RT_HEARTBEAT, buf, 3 + payload + padding);\\r\\nif (ret >= 0) {\\r\\nif (s->msg_callback)\\r\\ns->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,\\r\\nbuf, 3 + payload + padding,\\r\\ns, s->msg_callback_arg);\\r\\ns->tlsext_hb_pending = 1;\\r\\n}\\r\\nOPENSSL_free(buf);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int sig_cb(const char *elem, int len, void *arg)\\r\\n{\\r\\nsig_cb_st *sarg = arg;\\r\\nsize_t i;\\r\\nchar etmp[20], *p;\\r\\nint sig_alg, hash_alg;\\r\\nif (sarg->sigalgcnt == MAX_SIGALGLEN)\\r\\nreturn 0;\\r\\nif (len > (int)(sizeof(etmp) - 1))\\r\\nreturn 0;\\r\\nmemcpy(etmp, elem, len);\\r\\netmp[len] = 0;\\r\\np = strchr(etmp, '+');\\r\\nif (!p)\\r\\nreturn 0;\\r\\n*p = 0;\\r\\np++;\\r\\nif (!*p)\\r\\nreturn 0;\\r\\nif (!strcmp(etmp, \"RSA\"))\\r\\nsig_alg = EVP_PKEY_RSA;\\r\\nelse if (!strcmp(etmp, \"DSA\"))\\r\\nsig_alg = EVP_PKEY_DSA;\\r\\nelse if (!strcmp(etmp, \"ECDSA\"))\\r\\nsig_alg = EVP_PKEY_EC;\\r\\nelse\\r\\nreturn 0;\\r\\nhash_alg = OBJ_sn2nid(p);\\r\\nif (hash_alg == NID_undef)\\r\\nhash_alg = OBJ_ln2nid(p);\\r\\nif (hash_alg == NID_undef)\\r\\nreturn 0;\\r\\nfor (i = 0; i < sarg->sigalgcnt; i += 2) {\\r\\nif (sarg->sigalgs[i] == sig_alg && sarg->sigalgs[i + 1] == hash_alg)\\r\\nreturn 0;\\r\\n}\\r\\nsarg->sigalgs[sarg->sigalgcnt++] = hash_alg;\\r\\nsarg->sigalgs[sarg->sigalgcnt++] = sig_alg;\\r\\nreturn 1;\\r\\n}\\r\\nint tls1_set_sigalgs_list(CERT *c, const char *str, int client)\\r\\n{\\r\\nsig_cb_st sig;\\r\\nsig.sigalgcnt = 0;\\r\\nif (!CONF_parse_list(str, ':', 1, sig_cb, &sig))\\r\\nreturn 0;\\r\\nif (c == NULL)\\r\\nreturn 1;\\r\\nreturn tls1_set_sigalgs(c, sig.sigalgs, sig.sigalgcnt, client);\\r\\n}\\r\\nint tls1_set_sigalgs(CERT *c, const int *psig_nids, size_t salglen,\\r\\nint client)\\r\\n{\\r\\nunsigned char *sigalgs, *sptr;\\r\\nint rhash, rsign;\\r\\nsize_t i;\\r\\nif (salglen & 1)\\r\\nreturn 0;\\r\\nsigalgs = OPENSSL_malloc(salglen);\\r\\nif (sigalgs == NULL)\\r\\nreturn 0;\\r\\nfor (i = 0, sptr = sigalgs; i < salglen; i += 2) {\\r\\nrhash = tls12_find_id(*psig_nids++, tls12_md,\\r\\nsizeof(tls12_md) / sizeof(tls12_lookup));\\r\\nrsign = tls12_find_id(*psig_nids++, tls12_sig,\\r\\nsizeof(tls12_sig) / sizeof(tls12_lookup));\\r\\nif (rhash == -1 || rsign == -1)\\r\\ngoto err;\\r\\n*sptr++ = rhash;\\r\\n*sptr++ = rsign;\\r\\n}\\r\\nif (client) {\\r\\nif (c->client_sigalgs)\\r\\nOPENSSL_free(c->client_sigalgs);\\r\\nc->client_sigalgs = sigalgs;\\r\\nc->client_sigalgslen = salglen;\\r\\n} else {\\r\\nif (c->conf_sigalgs)\\r\\nOPENSSL_free(c->conf_sigalgs);\\r\\nc->conf_sigalgs = sigalgs;\\r\\nc->conf_sigalgslen = salglen;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nOPENSSL_free(sigalgs);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int tls1_check_sig_alg(CERT *c, X509 *x, int default_nid)\\r\\n{\\r\\nint sig_nid;\\r\\nsize_t i;\\r\\nif (default_nid == -1)\\r\\nreturn 1;\\r\\nsig_nid = X509_get_signature_nid(x);\\r\\nif (default_nid)\\r\\nreturn sig_nid == default_nid ? 1 : 0;\\r\\nfor (i = 0; i < c->shared_sigalgslen; i++)\\r\\nif (sig_nid == c->shared_sigalgs[i].signandhash_nid)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nvoid tls1_set_cert_validity(SSL *s)\\r\\n{\\r\\ntls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_RSA_ENC);\\r\\ntls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_RSA_SIGN);\\r\\ntls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_DSA_SIGN);\\r\\ntls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_DH_RSA);\\r\\ntls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_DH_DSA);\\r\\ntls1_check_chain(s, NULL, NULL, NULL, SSL_PKEY_ECC);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_lib_c", "target": 0, "func": "BIO *BIO_new(BIO_METHOD *method)\\r\\n{\\r\\nBIO *ret = NULL;\\r\\nret = (BIO *)OPENSSL_malloc(sizeof(BIO));\\r\\nif (ret == NULL) {\\r\\nBIOerr(BIO_F_BIO_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (!BIO_set(ret, method)) {\\r\\nOPENSSL_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint BIO_set(BIO *bio, BIO_METHOD *method)\\r\\n{\\r\\nbio->method = method;\\r\\nbio->callback = NULL;\\r\\nbio->cb_arg = NULL;\\r\\nbio->init = 0;\\r\\nbio->shutdown = 1;\\r\\nbio->flags = 0;\\r\\nbio->retry_reason = 0;\\r\\nbio->num = 0;\\r\\nbio->ptr = NULL;\\r\\nbio->prev_bio = NULL;\\r\\nbio->next_bio = NULL;\\r\\nbio->references = 1;\\r\\nbio->num_read = 0L;\\r\\nbio->num_write = 0L;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);\\r\\nif (method->create != NULL)\\r\\nif (!method->create(bio)) {\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nint BIO_free(BIO *a)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\ni = CRYPTO_add(&a->references, -1, CRYPTO_LOCK_BIO);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"BIO\", a);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn (1);\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"BIO_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif ((a->callback != NULL) &&\\r\\n((i = (int)a->callback(a, BIO_CB_FREE, NULL, 0, 0L, 1L)) <= 0))\\r\\nreturn (i);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, a, &a->ex_data);\\r\\nif ((a->method != NULL) && (a->method->destroy != NULL))\\r\\na->method->destroy(a);\\r\\nOPENSSL_free(a);\\r\\nreturn (1);\\r\\n}\\r\\nvoid BIO_vfree(BIO *a)\\r\\n{\\r\\nBIO_free(a);\\r\\n}\\r\\nvoid BIO_clear_flags(BIO *b, int flags)\\r\\n{\\r\\nb->flags &= ~flags;\\r\\n}\\r\\nint BIO_test_flags(const BIO *b, int flags)\\r\\n{\\r\\nreturn (b->flags & flags);\\r\\n}\\r\\nvoid BIO_set_flags(BIO *b, int flags)\\r\\n{\\r\\nb->flags |= flags;\\r\\n}\\r\\nvoid BIO_set_callback(BIO *b,\\r\\nlong (*cb) (struct bio_st *, int, const char *, int,\\r\\nlong, long))\\r\\n{\\r\\nb->callback = cb;\\r\\n}\\r\\nvoid BIO_set_callback_arg(BIO *b, char *arg)\\r\\n{\\r\\nb->cb_arg = arg;\\r\\n}\\r\\nchar *BIO_get_callback_arg(const BIO *b)\\r\\n{\\r\\nreturn b->cb_arg;\\r\\n}\\r\\nconst char *BIO_method_name(const BIO *b)\\r\\n{\\r\\nreturn b->method->name;\\r\\n}\\r\\nint BIO_method_type(const BIO *b)\\r\\n{\\r\\nreturn b->method->type;\\r\\n}\\r\\nint BIO_read(BIO *b, void *out, int outl)\\r\\n{\\r\\nint i;\\r\\nlong (*cb) (BIO *, int, const char *, int, long, long);\\r\\nif ((b == NULL) || (b->method == NULL) || (b->method->bread == NULL)) {\\r\\nBIOerr(BIO_F_BIO_READ, BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn (-2);\\r\\n}\\r\\ncb = b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((i = (int)cb(b, BIO_CB_READ, out, outl, 0L, 1L)) <= 0))\\r\\nreturn (i);\\r\\nif (!b->init) {\\r\\nBIOerr(BIO_F_BIO_READ, BIO_R_UNINITIALIZED);\\r\\nreturn (-2);\\r\\n}\\r\\ni = b->method->bread(b, out, outl);\\r\\nif (i > 0)\\r\\nb->num_read += (unsigned long)i;\\r\\nif (cb != NULL)\\r\\ni = (int)cb(b, BIO_CB_READ | BIO_CB_RETURN, out, outl, 0L, (long)i);\\r\\nreturn (i);\\r\\n}\\r\\nint BIO_write(BIO *b, const void *in, int inl)\\r\\n{\\r\\nint i;\\r\\nlong (*cb) (BIO *, int, const char *, int, long, long);\\r\\nif (b == NULL)\\r\\nreturn (0);\\r\\ncb = b->callback;\\r\\nif ((b->method == NULL) || (b->method->bwrite == NULL)) {\\r\\nBIOerr(BIO_F_BIO_WRITE, BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn (-2);\\r\\n}\\r\\nif ((cb != NULL) &&\\r\\n((i = (int)cb(b, BIO_CB_WRITE, in, inl, 0L, 1L)) <= 0))\\r\\nreturn (i);\\r\\nif (!b->init) {\\r\\nBIOerr(BIO_F_BIO_WRITE, BIO_R_UNINITIALIZED);\\r\\nreturn (-2);\\r\\n}\\r\\ni = b->method->bwrite(b, in, inl);\\r\\nif (i > 0)\\r\\nb->num_write += (unsigned long)i;\\r\\nif (cb != NULL)\\r\\ni = (int)cb(b, BIO_CB_WRITE | BIO_CB_RETURN, in, inl, 0L, (long)i);\\r\\nreturn (i);\\r\\n}\\r\\nint BIO_puts(BIO *b, const char *in)\\r\\n{\\r\\nint i;\\r\\nlong (*cb) (BIO *, int, const char *, int, long, long);\\r\\nif ((b == NULL) || (b->method == NULL) || (b->method->bputs == NULL)) {\\r\\nBIOerr(BIO_F_BIO_PUTS, BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn (-2);\\r\\n}\\r\\ncb = b->callback;\\r\\nif ((cb != NULL) && ((i = (int)cb(b, BIO_CB_PUTS, in, 0, 0L, 1L)) <= 0))\\r\\nreturn (i);\\r\\nif (!b->init) {\\r\\nBIOerr(BIO_F_BIO_PUTS, BIO_R_UNINITIALIZED);\\r\\nreturn (-2);\\r\\n}\\r\\ni = b->method->bputs(b, in);\\r\\nif (i > 0)\\r\\nb->num_write += (unsigned long)i;\\r\\nif (cb != NULL)\\r\\ni = (int)cb(b, BIO_CB_PUTS | BIO_CB_RETURN, in, 0, 0L, (long)i);\\r\\nreturn (i);\\r\\n}\\r\\nint BIO_gets(BIO *b, char *in, int inl)\\r\\n{\\r\\nint i;\\r\\nlong (*cb) (BIO *, int, const char *, int, long, long);\\r\\nif ((b == NULL) || (b->method == NULL) || (b->method->bgets == NULL)) {\\r\\nBIOerr(BIO_F_BIO_GETS, BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn (-2);\\r\\n}\\r\\ncb = b->callback;\\r\\nif ((cb != NULL) && ((i = (int)cb(b, BIO_CB_GETS, in, inl, 0L, 1L)) <= 0))\\r\\nreturn (i);\\r\\nif (!b->init) {\\r\\nBIOerr(BIO_F_BIO_GETS, BIO_R_UNINITIALIZED);\\r\\nreturn (-2);\\r\\n}\\r\\ni = b->method->bgets(b, in, inl);\\r\\nif (cb != NULL)\\r\\ni = (int)cb(b, BIO_CB_GETS | BIO_CB_RETURN, in, inl, 0L, (long)i);\\r\\nreturn (i);\\r\\n}\\r\\nint BIO_indent(BIO *b, int indent, int max)\\r\\n{\\r\\nif (indent < 0)\\r\\nindent = 0;\\r\\nif (indent > max)\\r\\nindent = max;\\r\\nwhile (indent--)\\r\\nif (BIO_puts(b, \" \") != 1)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nlong BIO_int_ctrl(BIO *b, int cmd, long larg, int iarg)\\r\\n{\\r\\nint i;\\r\\ni = iarg;\\r\\nreturn (BIO_ctrl(b, cmd, larg, (char *)&i));\\r\\n}\\r\\nchar *BIO_ptr_ctrl(BIO *b, int cmd, long larg)\\r\\n{\\r\\nchar *p = NULL;\\r\\nif (BIO_ctrl(b, cmd, larg, (char *)&p) <= 0)\\r\\nreturn (NULL);\\r\\nelse\\r\\nreturn (p);\\r\\n}\\r\\nlong BIO_ctrl(BIO *b, int cmd, long larg, void *parg)\\r\\n{\\r\\nlong ret;\\r\\nlong (*cb) (BIO *, int, const char *, int, long, long);\\r\\nif (b == NULL)\\r\\nreturn (0);\\r\\nif ((b->method == NULL) || (b->method->ctrl == NULL)) {\\r\\nBIOerr(BIO_F_BIO_CTRL, BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn (-2);\\r\\n}\\r\\ncb = b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((ret = cb(b, BIO_CB_CTRL, parg, cmd, larg, 1L)) <= 0))\\r\\nreturn (ret);\\r\\nret = b->method->ctrl(b, cmd, larg, parg);\\r\\nif (cb != NULL)\\r\\nret = cb(b, BIO_CB_CTRL | BIO_CB_RETURN, parg, cmd, larg, ret);\\r\\nreturn (ret);\\r\\n}\\r\\nlong BIO_callback_ctrl(BIO *b, int cmd,\\r\\nvoid (*fp) (struct bio_st *, int, const char *, int,\\r\\nlong, long))\\r\\n{\\r\\nlong ret;\\r\\nlong (*cb) (BIO *, int, const char *, int, long, long);\\r\\nif (b == NULL)\\r\\nreturn (0);\\r\\nif ((b->method == NULL) || (b->method->callback_ctrl == NULL)) {\\r\\nBIOerr(BIO_F_BIO_CALLBACK_CTRL, BIO_R_UNSUPPORTED_METHOD);\\r\\nreturn (-2);\\r\\n}\\r\\ncb = b->callback;\\r\\nif ((cb != NULL) &&\\r\\n((ret = cb(b, BIO_CB_CTRL, (void *)&fp, cmd, 0, 1L)) <= 0))\\r\\nreturn (ret);\\r\\nret = b->method->callback_ctrl(b, cmd, fp);\\r\\nif (cb != NULL)\\r\\nret = cb(b, BIO_CB_CTRL | BIO_CB_RETURN, (void *)&fp, cmd, 0, ret);\\r\\nreturn (ret);\\r\\n}\\r\\nsize_t BIO_ctrl_pending(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_CTRL_PENDING, 0, NULL);\\r\\n}\\r\\nsize_t BIO_ctrl_wpending(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_CTRL_WPENDING, 0, NULL);\\r\\n}\\r\\nBIO *BIO_push(BIO *b, BIO *bio)\\r\\n{\\r\\nBIO *lb;\\r\\nif (b == NULL)\\r\\nreturn (bio);\\r\\nlb = b;\\r\\nwhile (lb->next_bio != NULL)\\r\\nlb = lb->next_bio;\\r\\nlb->next_bio = bio;\\r\\nif (bio != NULL)\\r\\nbio->prev_bio = lb;\\r\\nBIO_ctrl(b, BIO_CTRL_PUSH, 0, lb);\\r\\nreturn (b);\\r\\n}\\r\\nBIO *BIO_pop(BIO *b)\\r\\n{\\r\\nBIO *ret;\\r\\nif (b == NULL)\\r\\nreturn (NULL);\\r\\nret = b->next_bio;\\r\\nBIO_ctrl(b, BIO_CTRL_POP, 0, b);\\r\\nif (b->prev_bio != NULL)\\r\\nb->prev_bio->next_bio = b->next_bio;\\r\\nif (b->next_bio != NULL)\\r\\nb->next_bio->prev_bio = b->prev_bio;\\r\\nb->next_bio = NULL;\\r\\nb->prev_bio = NULL;\\r\\nreturn (ret);\\r\\n}\\r\\nBIO *BIO_get_retry_BIO(BIO *bio, int *reason)\\r\\n{\\r\\nBIO *b, *last;\\r\\nb = last = bio;\\r\\nfor (;;) {\\r\\nif (!BIO_should_retry(b))\\r\\nbreak;\\r\\nlast = b;\\r\\nb = b->next_bio;\\r\\nif (b == NULL)\\r\\nbreak;\\r\\n}\\r\\nif (reason != NULL)\\r\\n*reason = last->retry_reason;\\r\\nreturn (last);\\r\\n}\\r\\nint BIO_get_retry_reason(BIO *bio)\\r\\n{\\r\\nreturn (bio->retry_reason);\\r\\n}\\r\\nBIO *BIO_find_type(BIO *bio, int type)\\r\\n{\\r\\nint mt, mask;\\r\\nif (!bio)\\r\\nreturn NULL;\\r\\nmask = type & 0xff;\\r\\ndo {\\r\\nif (bio->method != NULL) {\\r\\nmt = bio->method->type;\\r\\nif (!mask) {\\r\\nif (mt & type)\\r\\nreturn (bio);\\r\\n} else if (mt == type)\\r\\nreturn (bio);\\r\\n}\\r\\nbio = bio->next_bio;\\r\\n} while (bio != NULL);\\r\\nreturn (NULL);\\r\\n}\\r\\nBIO *BIO_next(BIO *b)\\r\\n{\\r\\nif (!b)\\r\\nreturn NULL;\\r\\nreturn b->next_bio;\\r\\n}\\r\\nvoid BIO_free_all(BIO *bio)\\r\\n{\\r\\nBIO *b;\\r\\nint ref;\\r\\nwhile (bio != NULL) {\\r\\nb = bio;\\r\\nref = b->references;\\r\\nbio = bio->next_bio;\\r\\nBIO_free(b);\\r\\nif (ref > 1)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nBIO *BIO_dup_chain(BIO *in)\\r\\n{\\r\\nBIO *ret = NULL, *eoc = NULL, *bio, *new_bio;\\r\\nfor (bio = in; bio != NULL; bio = bio->next_bio) {\\r\\nif ((new_bio = BIO_new(bio->method)) == NULL)\\r\\ngoto err;\\r\\nnew_bio->callback = bio->callback;\\r\\nnew_bio->cb_arg = bio->cb_arg;\\r\\nnew_bio->init = bio->init;\\r\\nnew_bio->shutdown = bio->shutdown;\\r\\nnew_bio->flags = bio->flags;\\r\\nnew_bio->num = bio->num;\\r\\nif (!BIO_dup_state(bio, (char *)new_bio)) {\\r\\nBIO_free(new_bio);\\r\\ngoto err;\\r\\n}\\r\\nif (!CRYPTO_dup_ex_data(CRYPTO_EX_INDEX_BIO, &new_bio->ex_data,\\r\\n&bio->ex_data))\\r\\ngoto err;\\r\\nif (ret == NULL) {\\r\\neoc = new_bio;\\r\\nret = eoc;\\r\\n} else {\\r\\nBIO_push(eoc, new_bio);\\r\\neoc = new_bio;\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nBIO_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nvoid BIO_copy_next_retry(BIO *b)\\r\\n{\\r\\nBIO_set_flags(b, BIO_get_retry_flags(b->next_bio));\\r\\nb->retry_reason = b->next_bio->retry_reason;\\r\\n}\\r\\nint BIO_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_BIO, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint BIO_set_ex_data(BIO *bio, int idx, void *data)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&(bio->ex_data), idx, data));\\r\\n}\\r\\nvoid *BIO_get_ex_data(BIO *bio, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&(bio->ex_data), idx));\\r\\n}\\r\\nunsigned long BIO_number_read(BIO *bio)\\r\\n{\\r\\nif (bio)\\r\\nreturn bio->num_read;\\r\\nreturn 0;\\r\\n}\\r\\nunsigned long BIO_number_written(BIO *bio)\\r\\n{\\r\\nif (bio)\\r\\nreturn bio->num_write;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_uid_c", "target": 0, "func": "int OPENSSL_issetugid(void)\\r\\n{\\r\\nreturn issetugid();\\r\\n}\\r\\nint OPENSSL_issetugid(void)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nint OPENSSL_issetugid(void)\\r\\n{\\r\\nif (getuid() != geteuid())\\r\\nreturn 1;\\r\\nif (getgid() != getegid())\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_LPdir_nyi_c", "target": 0, "func": "const char *LP_find_file(LP_DIR_CTX **ctx, const char *directory)\\r\\n{\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nint LP_find_file_end(LP_DIR_CTX **ctx)\\r\\n{\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t_pkey_c", "target": 0, "func": "int ASN1_bn_print(BIO *bp, const char *number, const BIGNUM *num,\\r\\nunsigned char *buf, int off)\\r\\n{\\r\\nint n, i;\\r\\nconst char *neg;\\r\\nif (num == NULL)\\r\\nreturn (1);\\r\\nneg = (BN_is_negative(num)) ? \"-\" : \"\";\\r\\nif (!BIO_indent(bp, off, 128))\\r\\nreturn 0;\\r\\nif (BN_is_zero(num)) {\\r\\nif (BIO_printf(bp, \"%s 0\\n\", number) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (BN_num_bytes(num) <= BN_BYTES) {\\r\\nif (BIO_printf(bp, \"%s %s%lu (%s0x%lx)\\n\", number, neg,\\r\\n(unsigned long)num->d[0], neg,\\r\\n(unsigned long)num->d[0])\\r\\n<= 0)\\r\\nreturn (0);\\r\\n} else {\\r\\nbuf[0] = 0;\\r\\nif (BIO_printf(bp, \"%s%s\", number,\\r\\n(neg[0] == '-') ? \" (Negative)\" : \"\") <= 0)\\r\\nreturn (0);\\r\\nn = BN_bn2bin(num, &buf[1]);\\r\\nif (buf[1] & 0x80)\\r\\nn++;\\r\\nelse\\r\\nbuf++;\\r\\nfor (i = 0; i < n; i++) {\\r\\nif ((i % 15) == 0) {\\r\\nif (BIO_puts(bp, \"\\n\") <= 0 || !BIO_indent(bp, off + 4, 128))\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_printf(bp, \"%02x%s\", buf[i], ((i + 1) == n) ? \"\" : \":\")\\r\\n<= 0)\\r\\nreturn (0);\\r\\n}\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_err_c", "target": 0, "func": "void ERR_load_RSA_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(RSA_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, RSA_str_functs);\\r\\nERR_load_strings(0, RSA_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_version_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i, ret = 0;\\r\\nint cflags = 0, version = 0, date = 0, options = 0, platform = 0, dir = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (argc == 1)\\r\\nversion = 1;\\r\\nfor (i = 1; i < argc; i++) {\\r\\nif (strcmp(argv[i], \"-v\") == 0)\\r\\nversion = 1;\\r\\nelse if (strcmp(argv[i], \"-b\") == 0)\\r\\ndate = 1;\\r\\nelse if (strcmp(argv[i], \"-f\") == 0)\\r\\ncflags = 1;\\r\\nelse if (strcmp(argv[i], \"-o\") == 0)\\r\\noptions = 1;\\r\\nelse if (strcmp(argv[i], \"-p\") == 0)\\r\\nplatform = 1;\\r\\nelse if (strcmp(argv[i], \"-d\") == 0)\\r\\ndir = 1;\\r\\nelse if (strcmp(argv[i], \"-a\") == 0)\\r\\ndate = version = cflags = options = platform = dir = 1;\\r\\nelse {\\r\\nBIO_printf(bio_err, \"usage:version -[avbofpd]\\n\");\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (version) {\\r\\nif (SSLeay() == SSLEAY_VERSION_NUMBER) {\\r\\nprintf(\"%s\\n\", SSLeay_version(SSLEAY_VERSION));\\r\\n} else {\\r\\nprintf(\"%s (Library: %s)\\n\",\\r\\nOPENSSL_VERSION_TEXT, SSLeay_version(SSLEAY_VERSION));\\r\\n}\\r\\n}\\r\\nif (date)\\r\\nprintf(\"%s\\n\", SSLeay_version(SSLEAY_BUILT_ON));\\r\\nif (platform)\\r\\nprintf(\"%s\\n\", SSLeay_version(SSLEAY_PLATFORM));\\r\\nif (options) {\\r\\nprintf(\"options: \");\\r\\nprintf(\"%s \", BN_options());\\r\\n#ifndef OPENSSL_NO_MD2\\r\\nprintf(\"%s \", MD2_options());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nprintf(\"%s \", RC4_options());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DES\\r\\nprintf(\"%s \", DES_options());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nprintf(\"%s \", idea_options());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_BF\\r\\nprintf(\"%s \", BF_options());\\r\\n#endif\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nif (cflags)\\r\\nprintf(\"%s\\n\", SSLeay_version(SSLEAY_CFLAGS));\\r\\nif (dir)\\r\\nprintf(\"%s\\n\", SSLeay_version(SSLEAY_DIR));\\r\\nend:\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tasn_prn_c", "target": 0, "func": "ASN1_PCTX *ASN1_PCTX_new(void)\\r\\n{\\r\\nASN1_PCTX *ret;\\r\\nret = OPENSSL_malloc(sizeof(ASN1_PCTX));\\r\\nif (ret == NULL) {\\r\\nASN1err(ASN1_F_ASN1_PCTX_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->flags = 0;\\r\\nret->nm_flags = 0;\\r\\nret->cert_flags = 0;\\r\\nret->oid_flags = 0;\\r\\nret->str_flags = 0;\\r\\nreturn ret;\\r\\n}\\r\\nvoid ASN1_PCTX_free(ASN1_PCTX *p)\\r\\n{\\r\\nOPENSSL_free(p);\\r\\n}\\r\\nunsigned long ASN1_PCTX_get_flags(ASN1_PCTX *p)\\r\\n{\\r\\nreturn p->flags;\\r\\n}\\r\\nvoid ASN1_PCTX_set_flags(ASN1_PCTX *p, unsigned long flags)\\r\\n{\\r\\np->flags = flags;\\r\\n}\\r\\nunsigned long ASN1_PCTX_get_nm_flags(ASN1_PCTX *p)\\r\\n{\\r\\nreturn p->nm_flags;\\r\\n}\\r\\nvoid ASN1_PCTX_set_nm_flags(ASN1_PCTX *p, unsigned long flags)\\r\\n{\\r\\np->nm_flags = flags;\\r\\n}\\r\\nunsigned long ASN1_PCTX_get_cert_flags(ASN1_PCTX *p)\\r\\n{\\r\\nreturn p->cert_flags;\\r\\n}\\r\\nvoid ASN1_PCTX_set_cert_flags(ASN1_PCTX *p, unsigned long flags)\\r\\n{\\r\\np->cert_flags = flags;\\r\\n}\\r\\nunsigned long ASN1_PCTX_get_oid_flags(ASN1_PCTX *p)\\r\\n{\\r\\nreturn p->oid_flags;\\r\\n}\\r\\nvoid ASN1_PCTX_set_oid_flags(ASN1_PCTX *p, unsigned long flags)\\r\\n{\\r\\np->oid_flags = flags;\\r\\n}\\r\\nunsigned long ASN1_PCTX_get_str_flags(ASN1_PCTX *p)\\r\\n{\\r\\nreturn p->str_flags;\\r\\n}\\r\\nvoid ASN1_PCTX_set_str_flags(ASN1_PCTX *p, unsigned long flags)\\r\\n{\\r\\np->str_flags = flags;\\r\\n}\\r\\nint ASN1_item_print(BIO *out, ASN1_VALUE *ifld, int indent,\\r\\nconst ASN1_ITEM *it, const ASN1_PCTX *pctx)\\r\\n{\\r\\nconst char *sname;\\r\\nif (pctx == NULL)\\r\\npctx = &default_pctx;\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_NO_STRUCT_NAME)\\r\\nsname = NULL;\\r\\nelse\\r\\nsname = it->sname;\\r\\nreturn asn1_item_print_ctx(out, &ifld, indent, it, NULL, sname, 0, pctx);\\r\\n}\\r\\nstatic int asn1_item_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,\\r\\nconst ASN1_ITEM *it,\\r\\nconst char *fname, const char *sname,\\r\\nint nohdr, const ASN1_PCTX *pctx)\\r\\n{\\r\\nconst ASN1_TEMPLATE *tt;\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nASN1_VALUE **tmpfld;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_aux_cb *asn1_cb;\\r\\nASN1_PRINT_ARG parg;\\r\\nint i;\\r\\nif (aux && aux->asn1_cb) {\\r\\nparg.out = out;\\r\\nparg.indent = indent;\\r\\nparg.pctx = pctx;\\r\\nasn1_cb = aux->asn1_cb;\\r\\n} else\\r\\nasn1_cb = 0;\\r\\nif (*fld == NULL) {\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_ABSENT) {\\r\\nif (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))\\r\\nreturn 0;\\r\\nif (BIO_puts(out, \"<ABSENT>\\n\") <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nswitch (it->itype) {\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates) {\\r\\nif (!asn1_template_print_ctx(out, fld, indent,\\r\\nit->templates, pctx))\\r\\nreturn 0;\\r\\n}\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nif (!asn1_primitive_print(out, fld, it, indent, fname, sname, pctx))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nif (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))\\r\\nreturn 0;\\r\\nef = it->funcs;\\r\\nif (ef && ef->asn1_ex_print) {\\r\\ni = ef->asn1_ex_print(out, fld, indent, \"\", pctx);\\r\\nif (!i)\\r\\nreturn 0;\\r\\nif ((i == 2) && (BIO_puts(out, \"\\n\") <= 0))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n} else if (sname &&\\r\\nBIO_printf(out, \":EXTERNAL TYPE %s\\n\", sname) <= 0)\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\n#if 0\\r\\nif (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))\\r\\nreturn 0;\\r\\n#endif\\r\\ni = asn1_get_choice_selector(fld, it);\\r\\nif ((i < 0) || (i >= it->tcount)) {\\r\\nif (BIO_printf(out, \"ERROR: selector [%d] invalid\\n\", i) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\ntt = it->templates + i;\\r\\ntmpfld = asn1_get_field_ptr(fld, tt);\\r\\nif (!asn1_template_print_ctx(out, tmpfld, indent, tt, pctx))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\nif (!nohdr && !asn1_print_fsname(out, indent, fname, sname, pctx))\\r\\nreturn 0;\\r\\nif (fname || sname) {\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE) {\\r\\nif (BIO_puts(out, \" {\\n\") <= 0)\\r\\nreturn 0;\\r\\n} else {\\r\\nif (BIO_puts(out, \"\\n\") <= 0)\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (asn1_cb) {\\r\\ni = asn1_cb(ASN1_OP_PRINT_PRE, fld, it, &parg);\\r\\nif (i == 0)\\r\\nreturn 0;\\r\\nif (i == 2)\\r\\nreturn 1;\\r\\n}\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {\\r\\nconst ASN1_TEMPLATE *seqtt;\\r\\nseqtt = asn1_do_adb(fld, tt, 1);\\r\\ntmpfld = asn1_get_field_ptr(fld, seqtt);\\r\\nif (!asn1_template_print_ctx(out, tmpfld,\\r\\nindent + 2, seqtt, pctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE) {\\r\\nif (BIO_printf(out, \"%*s}\\n\", indent, \"\") < 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (asn1_cb) {\\r\\ni = asn1_cb(ASN1_OP_PRINT_POST, fld, it, &parg);\\r\\nif (i == 0)\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_printf(out, \"Unprocessed type %d\\n\", it->itype);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint asn1_template_print_ctx(BIO *out, ASN1_VALUE **fld, int indent,\\r\\nconst ASN1_TEMPLATE *tt, const ASN1_PCTX *pctx)\\r\\n{\\r\\nint i, flags;\\r\\nconst char *sname, *fname;\\r\\nflags = tt->flags;\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME)\\r\\nsname = ASN1_ITEM_ptr(tt->item)->sname;\\r\\nelse\\r\\nsname = NULL;\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_NO_FIELD_NAME)\\r\\nfname = NULL;\\r\\nelse\\r\\nfname = tt->field_name;\\r\\nif (flags & ASN1_TFLG_SK_MASK) {\\r\\nchar *tname;\\r\\nASN1_VALUE *skitem;\\r\\nSTACK_OF(ASN1_VALUE) *stack;\\r\\nif (fname) {\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SSOF) {\\r\\nif (flags & ASN1_TFLG_SET_OF)\\r\\ntname = \"SET\";\\r\\nelse\\r\\ntname = \"SEQUENCE\";\\r\\nif (BIO_printf(out, \"%*s%s OF %s {\\n\",\\r\\nindent, \"\", tname, tt->field_name) <= 0)\\r\\nreturn 0;\\r\\n} else if (BIO_printf(out, \"%*s%s:\\n\", indent, \"\", fname) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nstack = (STACK_OF(ASN1_VALUE) *)*fld;\\r\\nfor (i = 0; i < sk_ASN1_VALUE_num(stack); i++) {\\r\\nif ((i > 0) && (BIO_puts(out, \"\\n\") <= 0))\\r\\nreturn 0;\\r\\nskitem = sk_ASN1_VALUE_value(stack, i);\\r\\nif (!asn1_item_print_ctx(out, &skitem, indent + 2,\\r\\nASN1_ITEM_ptr(tt->item), NULL, NULL, 1,\\r\\npctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (!i && BIO_printf(out, \"%*s<EMPTY>\\n\", indent + 2, \"\") <= 0)\\r\\nreturn 0;\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_SEQUENCE) {\\r\\nif (BIO_printf(out, \"%*s}\\n\", indent, \"\") <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nreturn asn1_item_print_ctx(out, fld, indent, ASN1_ITEM_ptr(tt->item),\\r\\nfname, sname, 0, pctx);\\r\\n}\\r\\nstatic int asn1_print_fsname(BIO *out, int indent,\\r\\nconst char *fname, const char *sname,\\r\\nconst ASN1_PCTX *pctx)\\r\\n{\\r\\nstatic char spaces[] = \" \";\\r\\nconst int nspaces = sizeof(spaces) - 1;\\r\\n#if 0\\r\\nif (!sname && !fname)\\r\\nreturn 1;\\r\\n#endif\\r\\nwhile (indent > nspaces) {\\r\\nif (BIO_write(out, spaces, nspaces) != nspaces)\\r\\nreturn 0;\\r\\nindent -= nspaces;\\r\\n}\\r\\nif (BIO_write(out, spaces, indent) != indent)\\r\\nreturn 0;\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_NO_STRUCT_NAME)\\r\\nsname = NULL;\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_NO_FIELD_NAME)\\r\\nfname = NULL;\\r\\nif (!sname && !fname)\\r\\nreturn 1;\\r\\nif (fname) {\\r\\nif (BIO_puts(out, fname) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (sname) {\\r\\nif (fname) {\\r\\nif (BIO_printf(out, \" (%s)\", sname) <= 0)\\r\\nreturn 0;\\r\\n} else {\\r\\nif (BIO_puts(out, sname) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (BIO_write(out, \": \", 2) != 2)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_print_boolean_ctx(BIO *out, int boolval,\\r\\nconst ASN1_PCTX *pctx)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (boolval) {\\r\\ncase -1:\\r\\nstr = \"BOOL ABSENT\";\\r\\nbreak;\\r\\ncase 0:\\r\\nstr = \"FALSE\";\\r\\nbreak;\\r\\ndefault:\\r\\nstr = \"TRUE\";\\r\\nbreak;\\r\\n}\\r\\nif (BIO_puts(out, str) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_print_integer_ctx(BIO *out, ASN1_INTEGER *str,\\r\\nconst ASN1_PCTX *pctx)\\r\\n{\\r\\nchar *s;\\r\\nint ret = 1;\\r\\ns = i2s_ASN1_INTEGER(NULL, str);\\r\\nif (BIO_puts(out, s) <= 0)\\r\\nret = 0;\\r\\nOPENSSL_free(s);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int asn1_print_oid_ctx(BIO *out, const ASN1_OBJECT *oid,\\r\\nconst ASN1_PCTX *pctx)\\r\\n{\\r\\nchar objbuf[80];\\r\\nconst char *ln;\\r\\nln = OBJ_nid2ln(OBJ_obj2nid(oid));\\r\\nif (!ln)\\r\\nln = \"\";\\r\\nOBJ_obj2txt(objbuf, sizeof objbuf, oid, 1);\\r\\nif (BIO_printf(out, \"%s (%s)\", ln, objbuf) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_print_obstring_ctx(BIO *out, ASN1_STRING *str, int indent,\\r\\nconst ASN1_PCTX *pctx)\\r\\n{\\r\\nif (str->type == V_ASN1_BIT_STRING) {\\r\\nif (BIO_printf(out, \" (%ld unused bits)\\n\", str->flags & 0x7) <= 0)\\r\\nreturn 0;\\r\\n} else if (BIO_puts(out, \"\\n\") <= 0)\\r\\nreturn 0;\\r\\nif ((str->length > 0)\\r\\n&& BIO_dump_indent(out, (char *)str->data, str->length,\\r\\nindent + 2) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_primitive_print(BIO *out, ASN1_VALUE **fld,\\r\\nconst ASN1_ITEM *it, int indent,\\r\\nconst char *fname, const char *sname,\\r\\nconst ASN1_PCTX *pctx)\\r\\n{\\r\\nlong utype;\\r\\nASN1_STRING *str;\\r\\nint ret = 1, needlf = 1;\\r\\nconst char *pname;\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf;\\r\\npf = it->funcs;\\r\\nif (!asn1_print_fsname(out, indent, fname, sname, pctx))\\r\\nreturn 0;\\r\\nif (pf && pf->prim_print)\\r\\nreturn pf->prim_print(out, fld, it, indent, pctx);\\r\\nstr = (ASN1_STRING *)*fld;\\r\\nif (it->itype == ASN1_ITYPE_MSTRING)\\r\\nutype = str->type & ~V_ASN1_NEG;\\r\\nelse\\r\\nutype = it->utype;\\r\\nif (utype == V_ASN1_ANY) {\\r\\nASN1_TYPE *atype = (ASN1_TYPE *)*fld;\\r\\nutype = atype->type;\\r\\nfld = &atype->value.asn1_value;\\r\\nstr = (ASN1_STRING *)*fld;\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_NO_ANY_TYPE)\\r\\npname = NULL;\\r\\nelse\\r\\npname = ASN1_tag2str(utype);\\r\\n} else {\\r\\nif (pctx->flags & ASN1_PCTX_FLAGS_SHOW_TYPE)\\r\\npname = ASN1_tag2str(utype);\\r\\nelse\\r\\npname = NULL;\\r\\n}\\r\\nif (utype == V_ASN1_NULL) {\\r\\nif (BIO_puts(out, \"NULL\\n\") <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (pname) {\\r\\nif (BIO_puts(out, pname) <= 0)\\r\\nreturn 0;\\r\\nif (BIO_puts(out, \":\") <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nswitch (utype) {\\r\\ncase V_ASN1_BOOLEAN:\\r\\n{\\r\\nint boolval = *(int *)fld;\\r\\nif (boolval == -1)\\r\\nboolval = it->size;\\r\\nret = asn1_print_boolean_ctx(out, boolval, pctx);\\r\\n}\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_ENUMERATED:\\r\\nret = asn1_print_integer_ctx(out, str, pctx);\\r\\nbreak;\\r\\ncase V_ASN1_UTCTIME:\\r\\nret = ASN1_UTCTIME_print(out, str);\\r\\nbreak;\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\nret = ASN1_GENERALIZEDTIME_print(out, str);\\r\\nbreak;\\r\\ncase V_ASN1_OBJECT:\\r\\nret = asn1_print_oid_ctx(out, (const ASN1_OBJECT *)*fld, pctx);\\r\\nbreak;\\r\\ncase V_ASN1_OCTET_STRING:\\r\\ncase V_ASN1_BIT_STRING:\\r\\nret = asn1_print_obstring_ctx(out, str, indent, pctx);\\r\\nneedlf = 0;\\r\\nbreak;\\r\\ncase V_ASN1_SEQUENCE:\\r\\ncase V_ASN1_SET:\\r\\ncase V_ASN1_OTHER:\\r\\nif (BIO_puts(out, \"\\n\") <= 0)\\r\\nreturn 0;\\r\\nif (ASN1_parse_dump(out, str->data, str->length, indent, 0) <= 0)\\r\\nret = 0;\\r\\nneedlf = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nret = ASN1_STRING_print_ex(out, str, pctx->str_flags);\\r\\n}\\r\\nif (!ret)\\r\\nreturn 0;\\r\\nif (needlf && BIO_puts(out, \"\\n\") <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_camellia_c", "target": 0, "func": "static int cmll_t4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nint ret, mode, bits;\\r\\nEVP_CAMELLIA_KEY *dat = (EVP_CAMELLIA_KEY *) ctx->cipher_data;\\r\\nmode = ctx->cipher->flags & EVP_CIPH_MODE;\\r\\nbits = ctx->key_len * 8;\\r\\ncmll_t4_set_key(key, bits, &dat->ks);\\r\\nif ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)\\r\\n&& !enc) {\\r\\nret = 0;\\r\\ndat->block = (block128_f) cmll_t4_decrypt;\\r\\nswitch (bits) {\\r\\ncase 128:\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) cmll128_t4_cbc_decrypt : NULL;\\r\\nbreak;\\r\\ncase 192:\\r\\ncase 256:\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) cmll256_t4_cbc_decrypt : NULL;\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\n}\\r\\n} else {\\r\\nret = 0;\\r\\ndat->block = (block128_f) cmll_t4_encrypt;\\r\\nswitch (bits) {\\r\\ncase 128:\\r\\nif (mode == EVP_CIPH_CBC_MODE)\\r\\ndat->stream.cbc = (cbc128_f) cmll128_t4_cbc_encrypt;\\r\\nelse if (mode == EVP_CIPH_CTR_MODE)\\r\\ndat->stream.ctr = (ctr128_f) cmll128_t4_ctr32_encrypt;\\r\\nelse\\r\\ndat->stream.cbc = NULL;\\r\\nbreak;\\r\\ncase 192:\\r\\ncase 256:\\r\\nif (mode == EVP_CIPH_CBC_MODE)\\r\\ndat->stream.cbc = (cbc128_f) cmll256_t4_cbc_encrypt;\\r\\nelse if (mode == EVP_CIPH_CTR_MODE)\\r\\ndat->stream.ctr = (ctr128_f) cmll256_t4_ctr32_encrypt;\\r\\nelse\\r\\ndat->stream.cbc = NULL;\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\n}\\r\\n}\\r\\nif (ret < 0) {\\r\\nEVPerr(EVP_F_CMLL_T4_INIT_KEY, EVP_R_CAMELLIA_KEY_SETUP_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nint ret, mode;\\r\\nEVP_CAMELLIA_KEY *dat = (EVP_CAMELLIA_KEY *) ctx->cipher_data;\\r\\nret = Camellia_set_key(key, ctx->key_len * 8, &dat->ks);\\r\\nif (ret < 0) {\\r\\nEVPerr(EVP_F_CAMELLIA_INIT_KEY, EVP_R_CAMELLIA_KEY_SETUP_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nmode = ctx->cipher->flags & EVP_CIPH_MODE;\\r\\nif ((mode == EVP_CIPH_ECB_MODE || mode == EVP_CIPH_CBC_MODE)\\r\\n&& !enc) {\\r\\ndat->block = (block128_f) Camellia_decrypt;\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) Camellia_cbc_encrypt : NULL;\\r\\n} else {\\r\\ndat->block = (block128_f) Camellia_encrypt;\\r\\ndat->stream.cbc = mode == EVP_CIPH_CBC_MODE ?\\r\\n(cbc128_f) Camellia_cbc_encrypt : NULL;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int camellia_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_CAMELLIA_KEY *dat = (EVP_CAMELLIA_KEY *) ctx->cipher_data;\\r\\nif (dat->stream.cbc)\\r\\n(*dat->stream.cbc) (in, out, len, &dat->ks, ctx->iv, ctx->encrypt);\\r\\nelse if (ctx->encrypt)\\r\\nCRYPTO_cbc128_encrypt(in, out, len, &dat->ks, ctx->iv, dat->block);\\r\\nelse\\r\\nCRYPTO_cbc128_decrypt(in, out, len, &dat->ks, ctx->iv, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int camellia_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nsize_t bl = ctx->cipher->block_size;\\r\\nsize_t i;\\r\\nEVP_CAMELLIA_KEY *dat = (EVP_CAMELLIA_KEY *) ctx->cipher_data;\\r\\nif (len < bl)\\r\\nreturn 1;\\r\\nfor (i = 0, len -= bl; i <= len; i += bl)\\r\\n(*dat->block) (in + i, out + i, &dat->ks);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int camellia_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_CAMELLIA_KEY *dat = (EVP_CAMELLIA_KEY *) ctx->cipher_data;\\r\\nCRYPTO_ofb128_encrypt(in, out, len, &dat->ks,\\r\\nctx->iv, &ctx->num, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int camellia_cfb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_CAMELLIA_KEY *dat = (EVP_CAMELLIA_KEY *) ctx->cipher_data;\\r\\nCRYPTO_cfb128_encrypt(in, out, len, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int camellia_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_CAMELLIA_KEY *dat = (EVP_CAMELLIA_KEY *) ctx->cipher_data;\\r\\nCRYPTO_cfb128_8_encrypt(in, out, len, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int camellia_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_CAMELLIA_KEY *dat = (EVP_CAMELLIA_KEY *) ctx->cipher_data;\\r\\nif (ctx->flags & EVP_CIPH_FLAG_LENGTH_BITS) {\\r\\nCRYPTO_cfb128_1_encrypt(in, out, len, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nreturn 1;\\r\\n}\\r\\nwhile (len >= MAXBITCHUNK) {\\r\\nCRYPTO_cfb128_1_encrypt(in, out, MAXBITCHUNK * 8, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nlen -= MAXBITCHUNK;\\r\\n}\\r\\nif (len)\\r\\nCRYPTO_cfb128_1_encrypt(in, out, len * 8, &dat->ks,\\r\\nctx->iv, &ctx->num, ctx->encrypt, dat->block);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_utl_c", "target": 0, "func": "unsigned char *OPENSSL_asc2uni(const char *asc, int asclen,\\r\\nunsigned char **uni, int *unilen)\\r\\n{\\r\\nint ulen, i;\\r\\nunsigned char *unitmp;\\r\\nif (asclen == -1)\\r\\nasclen = strlen(asc);\\r\\nulen = asclen * 2 + 2;\\r\\nif (!(unitmp = OPENSSL_malloc(ulen)))\\r\\nreturn NULL;\\r\\nfor (i = 0; i < ulen - 2; i += 2) {\\r\\nunitmp[i] = 0;\\r\\nunitmp[i + 1] = asc[i >> 1];\\r\\n}\\r\\nunitmp[ulen - 2] = 0;\\r\\nunitmp[ulen - 1] = 0;\\r\\nif (unilen)\\r\\n*unilen = ulen;\\r\\nif (uni)\\r\\n*uni = unitmp;\\r\\nreturn unitmp;\\r\\n}\\r\\nchar *OPENSSL_uni2asc(unsigned char *uni, int unilen)\\r\\n{\\r\\nint asclen, i;\\r\\nchar *asctmp;\\r\\nasclen = unilen / 2;\\r\\nif (!unilen || uni[unilen - 1])\\r\\nasclen++;\\r\\nuni++;\\r\\nif (!(asctmp = OPENSSL_malloc(asclen)))\\r\\nreturn NULL;\\r\\nfor (i = 0; i < unilen; i += 2)\\r\\nasctmp[i >> 1] = uni[i];\\r\\nasctmp[asclen - 1] = 0;\\r\\nreturn asctmp;\\r\\n}\\r\\nint i2d_PKCS12_bio(BIO *bp, PKCS12 *p12)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(PKCS12), bp, p12);\\r\\n}\\r\\nint i2d_PKCS12_fp(FILE *fp, PKCS12 *p12)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(PKCS12), fp, p12);\\r\\n}\\r\\nPKCS12 *d2i_PKCS12_bio(BIO *bp, PKCS12 **p12)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(PKCS12), bp, p12);\\r\\n}\\r\\nPKCS12 *d2i_PKCS12_fp(FILE *fp, PKCS12 **p12)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(PKCS12), fp, p12);\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_x5092certbag(X509 *x509)\\r\\n{\\r\\nreturn PKCS12_item_pack_safebag(x509, ASN1_ITEM_rptr(X509),\\r\\nNID_x509Certificate, NID_certBag);\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_x509crl2certbag(X509_CRL *crl)\\r\\n{\\r\\nreturn PKCS12_item_pack_safebag(crl, ASN1_ITEM_rptr(X509_CRL),\\r\\nNID_x509Crl, NID_crlBag);\\r\\n}\\r\\nX509 *PKCS12_certbag2x509(PKCS12_SAFEBAG *bag)\\r\\n{\\r\\nif (M_PKCS12_bag_type(bag) != NID_certBag)\\r\\nreturn NULL;\\r\\nif (M_PKCS12_cert_bag_type(bag) != NID_x509Certificate)\\r\\nreturn NULL;\\r\\nreturn ASN1_item_unpack(bag->value.bag->value.octet,\\r\\nASN1_ITEM_rptr(X509));\\r\\n}\\r\\nX509_CRL *PKCS12_certbag2x509crl(PKCS12_SAFEBAG *bag)\\r\\n{\\r\\nif (M_PKCS12_bag_type(bag) != NID_crlBag)\\r\\nreturn NULL;\\r\\nif (M_PKCS12_cert_bag_type(bag) != NID_x509Crl)\\r\\nreturn NULL;\\r\\nreturn ASN1_item_unpack(bag->value.bag->value.octet,\\r\\nASN1_ITEM_rptr(X509_CRL));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pmeth_fn_c", "target": 0, "func": "int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->sign) {\\r\\nEVPerr(EVP_F_EVP_PKEY_SIGN_INIT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nctx->operation = EVP_PKEY_OP_SIGN;\\r\\nif (!ctx->pmeth->sign_init)\\r\\nreturn 1;\\r\\nret = ctx->pmeth->sign_init(ctx);\\r\\nif (ret <= 0)\\r\\nctx->operation = EVP_PKEY_OP_UNDEFINED;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_sign(EVP_PKEY_CTX *ctx,\\r\\nunsigned char *sig, size_t *siglen,\\r\\nconst unsigned char *tbs, size_t tbslen)\\r\\n{\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->sign) {\\r\\nEVPerr(EVP_F_EVP_PKEY_SIGN,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nif (ctx->operation != EVP_PKEY_OP_SIGN) {\\r\\nEVPerr(EVP_F_EVP_PKEY_SIGN, EVP_R_OPERATON_NOT_INITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nM_check_autoarg(ctx, sig, siglen, EVP_F_EVP_PKEY_SIGN)\\r\\nreturn ctx->pmeth->sign(ctx, sig, siglen, tbs, tbslen);\\r\\n}\\r\\nint EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->verify) {\\r\\nEVPerr(EVP_F_EVP_PKEY_VERIFY_INIT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nctx->operation = EVP_PKEY_OP_VERIFY;\\r\\nif (!ctx->pmeth->verify_init)\\r\\nreturn 1;\\r\\nret = ctx->pmeth->verify_init(ctx);\\r\\nif (ret <= 0)\\r\\nctx->operation = EVP_PKEY_OP_UNDEFINED;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_verify(EVP_PKEY_CTX *ctx,\\r\\nconst unsigned char *sig, size_t siglen,\\r\\nconst unsigned char *tbs, size_t tbslen)\\r\\n{\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->verify) {\\r\\nEVPerr(EVP_F_EVP_PKEY_VERIFY,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nif (ctx->operation != EVP_PKEY_OP_VERIFY) {\\r\\nEVPerr(EVP_F_EVP_PKEY_VERIFY, EVP_R_OPERATON_NOT_INITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nreturn ctx->pmeth->verify(ctx, sig, siglen, tbs, tbslen);\\r\\n}\\r\\nint EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->verify_recover) {\\r\\nEVPerr(EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nctx->operation = EVP_PKEY_OP_VERIFYRECOVER;\\r\\nif (!ctx->pmeth->verify_recover_init)\\r\\nreturn 1;\\r\\nret = ctx->pmeth->verify_recover_init(ctx);\\r\\nif (ret <= 0)\\r\\nctx->operation = EVP_PKEY_OP_UNDEFINED;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,\\r\\nunsigned char *rout, size_t *routlen,\\r\\nconst unsigned char *sig, size_t siglen)\\r\\n{\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->verify_recover) {\\r\\nEVPerr(EVP_F_EVP_PKEY_VERIFY_RECOVER,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nif (ctx->operation != EVP_PKEY_OP_VERIFYRECOVER) {\\r\\nEVPerr(EVP_F_EVP_PKEY_VERIFY_RECOVER, EVP_R_OPERATON_NOT_INITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nM_check_autoarg(ctx, rout, routlen, EVP_F_EVP_PKEY_VERIFY_RECOVER)\\r\\nreturn ctx->pmeth->verify_recover(ctx, rout, routlen, sig, siglen);\\r\\n}\\r\\nint EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->encrypt) {\\r\\nEVPerr(EVP_F_EVP_PKEY_ENCRYPT_INIT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nctx->operation = EVP_PKEY_OP_ENCRYPT;\\r\\nif (!ctx->pmeth->encrypt_init)\\r\\nreturn 1;\\r\\nret = ctx->pmeth->encrypt_init(ctx);\\r\\nif (ret <= 0)\\r\\nctx->operation = EVP_PKEY_OP_UNDEFINED;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,\\r\\nunsigned char *out, size_t *outlen,\\r\\nconst unsigned char *in, size_t inlen)\\r\\n{\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->encrypt) {\\r\\nEVPerr(EVP_F_EVP_PKEY_ENCRYPT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nif (ctx->operation != EVP_PKEY_OP_ENCRYPT) {\\r\\nEVPerr(EVP_F_EVP_PKEY_ENCRYPT, EVP_R_OPERATON_NOT_INITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nM_check_autoarg(ctx, out, outlen, EVP_F_EVP_PKEY_ENCRYPT)\\r\\nreturn ctx->pmeth->encrypt(ctx, out, outlen, in, inlen);\\r\\n}\\r\\nint EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->decrypt) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DECRYPT_INIT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nctx->operation = EVP_PKEY_OP_DECRYPT;\\r\\nif (!ctx->pmeth->decrypt_init)\\r\\nreturn 1;\\r\\nret = ctx->pmeth->decrypt_init(ctx);\\r\\nif (ret <= 0)\\r\\nctx->operation = EVP_PKEY_OP_UNDEFINED;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\\r\\nunsigned char *out, size_t *outlen,\\r\\nconst unsigned char *in, size_t inlen)\\r\\n{\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->decrypt) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DECRYPT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nif (ctx->operation != EVP_PKEY_OP_DECRYPT) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DECRYPT, EVP_R_OPERATON_NOT_INITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nM_check_autoarg(ctx, out, outlen, EVP_F_EVP_PKEY_DECRYPT)\\r\\nreturn ctx->pmeth->decrypt(ctx, out, outlen, in, inlen);\\r\\n}\\r\\nint EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->derive) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DERIVE_INIT,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nctx->operation = EVP_PKEY_OP_DERIVE;\\r\\nif (!ctx->pmeth->derive_init)\\r\\nreturn 1;\\r\\nret = ctx->pmeth->derive_init(ctx);\\r\\nif (ret <= 0)\\r\\nctx->operation = EVP_PKEY_OP_UNDEFINED;\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth\\r\\n|| !(ctx->pmeth->derive || ctx->pmeth->encrypt || ctx->pmeth->decrypt)\\r\\n|| !ctx->pmeth->ctrl) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nif (ctx->operation != EVP_PKEY_OP_DERIVE\\r\\n&& ctx->operation != EVP_PKEY_OP_ENCRYPT\\r\\n&& ctx->operation != EVP_PKEY_OP_DECRYPT) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER,\\r\\nEVP_R_OPERATON_NOT_INITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nret = ctx->pmeth->ctrl(ctx, EVP_PKEY_CTRL_PEER_KEY, 0, peer);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\nif (ret == 2)\\r\\nreturn 1;\\r\\nif (!ctx->pkey) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_NO_KEY_SET);\\r\\nreturn -1;\\r\\n}\\r\\nif (ctx->pkey->type != peer->type) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_DIFFERENT_KEY_TYPES);\\r\\nreturn -1;\\r\\n}\\r\\nif (!EVP_PKEY_missing_parameters(peer) &&\\r\\n!EVP_PKEY_cmp_parameters(ctx->pkey, peer)) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DERIVE_SET_PEER, EVP_R_DIFFERENT_PARAMETERS);\\r\\nreturn -1;\\r\\n}\\r\\nif (ctx->peerkey)\\r\\nEVP_PKEY_free(ctx->peerkey);\\r\\nctx->peerkey = peer;\\r\\nret = ctx->pmeth->ctrl(ctx, EVP_PKEY_CTRL_PEER_KEY, 1, peer);\\r\\nif (ret <= 0) {\\r\\nctx->peerkey = NULL;\\r\\nreturn ret;\\r\\n}\\r\\nCRYPTO_add(&peer->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *pkeylen)\\r\\n{\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->derive) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DERIVE,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\n}\\r\\nif (ctx->operation != EVP_PKEY_OP_DERIVE) {\\r\\nEVPerr(EVP_F_EVP_PKEY_DERIVE, EVP_R_OPERATON_NOT_INITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nM_check_autoarg(ctx, key, pkeylen, EVP_F_EVP_PKEY_DERIVE)\\r\\nreturn ctx->pmeth->derive(ctx, key, pkeylen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_req_c", "target": 0, "func": "static int rinf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nX509_REQ_INFO *rinf = (X509_REQ_INFO *)*pval;\\r\\nif (operation == ASN1_OP_NEW_POST) {\\r\\nrinf->attributes = sk_X509_ATTRIBUTE_new_null();\\r\\nif (!rinf->attributes)\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc5_skey_c", "target": 0, "func": "void RC5_32_set_key(RC5_32_KEY *key, int len, const unsigned char *data,\\r\\nint rounds)\\r\\n{\\r\\nRC5_32_INT L[64], l, ll, A, B, *S, k;\\r\\nint i, j, m, c, t, ii, jj;\\r\\nif ((rounds != RC5_16_ROUNDS) &&\\r\\n(rounds != RC5_12_ROUNDS) && (rounds != RC5_8_ROUNDS))\\r\\nrounds = RC5_16_ROUNDS;\\r\\nkey->rounds = rounds;\\r\\nS = &(key->data[0]);\\r\\nj = 0;\\r\\nfor (i = 0; i <= (len - 8); i += 8) {\\r\\nc2l(data, l);\\r\\nL[j++] = l;\\r\\nc2l(data, l);\\r\\nL[j++] = l;\\r\\n}\\r\\nii = len - i;\\r\\nif (ii) {\\r\\nk = len & 0x07;\\r\\nc2ln(data, l, ll, k);\\r\\nL[j + 0] = l;\\r\\nL[j + 1] = ll;\\r\\n}\\r\\nc = (len + 3) / 4;\\r\\nt = (rounds + 1) * 2;\\r\\nS[0] = RC5_32_P;\\r\\nfor (i = 1; i < t; i++)\\r\\nS[i] = (S[i - 1] + RC5_32_Q) & RC5_32_MASK;\\r\\nj = (t > c) ? t : c;\\r\\nj *= 3;\\r\\nii = jj = 0;\\r\\nA = B = 0;\\r\\nfor (i = 0; i < j; i++) {\\r\\nk = (S[ii] + A + B) & RC5_32_MASK;\\r\\nA = S[ii] = ROTATE_l32(k, 3);\\r\\nm = (int)(A + B);\\r\\nk = (L[jj] + A + B) & RC5_32_MASK;\\r\\nB = L[jj] = ROTATE_l32(k, m);\\r\\nif (++ii >= t)\\r\\nii = 0;\\r\\nif (++jj >= c)\\r\\njj = 0;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_sign_c", "target": 0, "func": "DSA_SIG *DSA_do_sign(const unsigned char *dgst, int dlen, DSA *dsa)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(dsa->meth->flags & DSA_FLAG_FIPS_METHOD)\\r\\n&& !(dsa->flags & DSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nDSAerr(DSA_F_DSA_DO_SIGN, DSA_R_NON_FIPS_DSA_METHOD);\\r\\nreturn NULL;\\r\\n}\\r\\n#endif\\r\\nreturn dsa->meth->dsa_do_sign(dgst, dlen, dsa);\\r\\n}\\r\\nint DSA_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(dsa->meth->flags & DSA_FLAG_FIPS_METHOD)\\r\\n&& !(dsa->flags & DSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nDSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_NON_FIPS_DSA_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nreturn dsa->meth->dsa_sign_setup(dsa, ctx_in, kinvp, rp);\\r\\n}\\r\\nDSA_SIG *DSA_SIG_new(void)\\r\\n{\\r\\nDSA_SIG *sig;\\r\\nsig = OPENSSL_malloc(sizeof(DSA_SIG));\\r\\nif (!sig)\\r\\nreturn NULL;\\r\\nsig->r = NULL;\\r\\nsig->s = NULL;\\r\\nreturn sig;\\r\\n}\\r\\nvoid DSA_SIG_free(DSA_SIG *sig)\\r\\n{\\r\\nif (sig) {\\r\\nif (sig->r)\\r\\nBN_free(sig->r);\\r\\nif (sig->s)\\r\\nBN_free(sig->s);\\r\\nOPENSSL_free(sig);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_r2x_c", "target": 0, "func": "X509 *X509_REQ_to_X509(X509_REQ *r, int days, EVP_PKEY *pkey)\\r\\n{\\r\\nX509 *ret = NULL;\\r\\nX509_CINF *xi = NULL;\\r\\nX509_NAME *xn;\\r\\nif ((ret = X509_new()) == NULL) {\\r\\nX509err(X509_F_X509_REQ_TO_X509, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nxi = ret->cert_info;\\r\\nif (sk_X509_ATTRIBUTE_num(r->req_info->attributes) != 0) {\\r\\nif ((xi->version = M_ASN1_INTEGER_new()) == NULL)\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(xi->version, 2))\\r\\ngoto err;\\r\\n}\\r\\nxn = X509_REQ_get_subject_name(r);\\r\\nif (X509_set_subject_name(ret, X509_NAME_dup(xn)) == 0)\\r\\ngoto err;\\r\\nif (X509_set_issuer_name(ret, X509_NAME_dup(xn)) == 0)\\r\\ngoto err;\\r\\nif (X509_gmtime_adj(xi->validity->notBefore, 0) == NULL)\\r\\ngoto err;\\r\\nif (X509_gmtime_adj(xi->validity->notAfter, (long)60 * 60 * 24 * days) ==\\r\\nNULL)\\r\\ngoto err;\\r\\nX509_set_pubkey(ret, X509_REQ_get_pubkey(r));\\r\\nif (!X509_sign(ret, pkey, EVP_md5()))\\r\\ngoto err;\\r\\nif (0) {\\r\\nerr:\\r\\nX509_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_d2i_fp_c", "target": 0, "func": "void *ASN1_d2i_fp(void *(*xnew) (void), d2i_of_void *d2i, FILE *in, void **x)\\r\\n{\\r\\nBIO *b;\\r\\nvoid *ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nASN1err(ASN1_F_ASN1_D2I_FP, ERR_R_BUF_LIB);\\r\\nreturn (NULL);\\r\\n}\\r\\nBIO_set_fp(b, in, BIO_NOCLOSE);\\r\\nret = ASN1_d2i_bio(xnew, d2i, b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nvoid *ASN1_d2i_bio(void *(*xnew) (void), d2i_of_void *d2i, BIO *in, void **x)\\r\\n{\\r\\nBUF_MEM *b = NULL;\\r\\nconst unsigned char *p;\\r\\nvoid *ret = NULL;\\r\\nint len;\\r\\nlen = asn1_d2i_read_bio(in, &b);\\r\\nif (len < 0)\\r\\ngoto err;\\r\\np = (unsigned char *)b->data;\\r\\nret = d2i(x, &p, len);\\r\\nerr:\\r\\nif (b != NULL)\\r\\nBUF_MEM_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nvoid *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x)\\r\\n{\\r\\nBUF_MEM *b = NULL;\\r\\nconst unsigned char *p;\\r\\nvoid *ret = NULL;\\r\\nint len;\\r\\nlen = asn1_d2i_read_bio(in, &b);\\r\\nif (len < 0)\\r\\ngoto err;\\r\\np = (const unsigned char *)b->data;\\r\\nret = ASN1_item_d2i(x, &p, len, it);\\r\\nerr:\\r\\nif (b != NULL)\\r\\nBUF_MEM_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nvoid *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x)\\r\\n{\\r\\nBIO *b;\\r\\nchar *ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_D2I_FP, ERR_R_BUF_LIB);\\r\\nreturn (NULL);\\r\\n}\\r\\nBIO_set_fp(b, in, BIO_NOCLOSE);\\r\\nret = ASN1_item_d2i_bio(it, b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)\\r\\n{\\r\\nBUF_MEM *b;\\r\\nunsigned char *p;\\r\\nint i;\\r\\nASN1_const_CTX c;\\r\\nsize_t want = HEADER_SIZE;\\r\\nint eos = 0;\\r\\nsize_t off = 0;\\r\\nsize_t len = 0;\\r\\nb = BUF_MEM_new();\\r\\nif (b == NULL) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nERR_clear_error();\\r\\nfor (;;) {\\r\\nif (want >= (len - off)) {\\r\\nwant -= (len - off);\\r\\nif (len + want < len || !BUF_MEM_grow_clean(b, len + want)) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni = BIO_read(in, &(b->data[len]), want);\\r\\nif ((i < 0) && ((len - off) == 0)) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_NOT_ENOUGH_DATA);\\r\\ngoto err;\\r\\n}\\r\\nif (i > 0) {\\r\\nif (len + i < len) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nlen += i;\\r\\n}\\r\\n}\\r\\np = (unsigned char *)&(b->data[off]);\\r\\nc.p = p;\\r\\nc.inf = ASN1_get_object(&(c.p), &(c.slen), &(c.tag), &(c.xclass),\\r\\nlen - off);\\r\\nif (c.inf & 0x80) {\\r\\nunsigned long e;\\r\\ne = ERR_GET_REASON(ERR_peek_error());\\r\\nif (e != ASN1_R_TOO_LONG)\\r\\ngoto err;\\r\\nelse\\r\\nERR_clear_error();\\r\\n}\\r\\ni = c.p - p;\\r\\noff += i;\\r\\nif (c.inf & 1) {\\r\\neos++;\\r\\nif (eos < 0) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_HEADER_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nwant = HEADER_SIZE;\\r\\n} else if (eos && (c.slen == 0) && (c.tag == V_ASN1_EOC)) {\\r\\neos--;\\r\\nif (eos <= 0)\\r\\nbreak;\\r\\nelse\\r\\nwant = HEADER_SIZE;\\r\\n} else {\\r\\nwant = c.slen;\\r\\nif (want > (len - off)) {\\r\\nwant -= (len - off);\\r\\nif (want > INT_MAX ||\\r\\nlen + want < len) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\nif (!BUF_MEM_grow_clean(b, len + want)) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nwhile (want > 0) {\\r\\ni = BIO_read(in, &(b->data[len]), want);\\r\\nif (i <= 0) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO,\\r\\nASN1_R_NOT_ENOUGH_DATA);\\r\\ngoto err;\\r\\n}\\r\\nlen += i;\\r\\nwant -= i;\\r\\n}\\r\\n}\\r\\nif (off + c.slen < off) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\noff += c.slen;\\r\\nif (eos <= 0) {\\r\\nbreak;\\r\\n} else\\r\\nwant = HEADER_SIZE;\\r\\n}\\r\\n}\\r\\nif (off > INT_MAX) {\\r\\nASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);\\r\\ngoto err;\\r\\n}\\r\\n*pb = b;\\r\\nreturn off;\\r\\nerr:\\r\\nif (b != NULL)\\r\\nBUF_MEM_free(b);\\r\\nreturn -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_aes_cbc_hmac_sha1_c", "target": 0, "func": "static int aesni_cbc_hmac_sha1_init_key(EVP_CIPHER_CTX *ctx,\\r\\nconst unsigned char *inkey,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_HMAC_SHA1 *key = data(ctx);\\r\\nint ret;\\r\\nif (enc)\\r\\nret = aesni_set_encrypt_key(inkey, ctx->key_len * 8, &key->ks);\\r\\nelse\\r\\nret = aesni_set_decrypt_key(inkey, ctx->key_len * 8, &key->ks);\\r\\nSHA1_Init(&key->head);\\r\\nkey->tail = key->head;\\r\\nkey->md = key->head;\\r\\nkey->payload_length = NO_PAYLOAD_LENGTH;\\r\\nreturn ret < 0 ? 0 : 1;\\r\\n}\\r\\nstatic void sha1_update(SHA_CTX *c, const void *data, size_t len)\\r\\n{\\r\\nconst unsigned char *ptr = data;\\r\\nsize_t res;\\r\\nif ((res = c->num)) {\\r\\nres = SHA_CBLOCK - res;\\r\\nif (len < res)\\r\\nres = len;\\r\\nSHA1_Update(c, ptr, res);\\r\\nptr += res;\\r\\nlen -= res;\\r\\n}\\r\\nres = len % SHA_CBLOCK;\\r\\nlen -= res;\\r\\nif (len) {\\r\\nsha1_block_data_order(c, ptr, len / SHA_CBLOCK);\\r\\nptr += len;\\r\\nc->Nh += len >> 29;\\r\\nc->Nl += len <<= 3;\\r\\nif (c->Nl < (unsigned int)len)\\r\\nc->Nh++;\\r\\n}\\r\\nif (res)\\r\\nSHA1_Update(c, ptr, res);\\r\\n}\\r\\nstatic size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA1 *key,\\r\\nunsigned char *out,\\r\\nconst unsigned char *inp,\\r\\nsize_t inp_len, int n4x)\\r\\n{\\r\\nHASH_DESC hash_d[8], edges[8];\\r\\nCIPH_DESC ciph_d[8];\\r\\nunsigned char storage[sizeof(SHA1_MB_CTX) + 32];\\r\\nunion {\\r\\nu64 q[16];\\r\\nu32 d[32];\\r\\nu8 c[128];\\r\\n} blocks[8];\\r\\nSHA1_MB_CTX *ctx;\\r\\nunsigned int frag, last, packlen, i, x4 = 4 * n4x, minblocks, processed =\\r\\n0;\\r\\nsize_t ret = 0;\\r\\nu8 *IVs;\\r\\n# if defined(BSWAP8)\\r\\nu64 seqnum;\\r\\n# endif\\r\\nif (RAND_bytes((IVs = blocks[0].c), 16 * x4) <= 0)\\r\\nreturn 0;\\r\\nctx = (SHA1_MB_CTX *) (storage + 32 - ((size_t)storage % 32));\\r\\nfrag = (unsigned int)inp_len >> (1 + n4x);\\r\\nlast = (unsigned int)inp_len + frag - (frag << (1 + n4x));\\r\\nif (last > frag && ((last + 13 + 9) % 64) < (x4 - 1)) {\\r\\nfrag++;\\r\\nlast -= x4 - 1;\\r\\n}\\r\\npacklen = 5 + 16 + ((frag + 20 + 16) & -16);\\r\\nhash_d[0].ptr = inp;\\r\\nciph_d[0].inp = inp;\\r\\nciph_d[0].out = out + 5 + 16;\\r\\nmemcpy(ciph_d[0].out - 16, IVs, 16);\\r\\nmemcpy(ciph_d[0].iv, IVs, 16);\\r\\nIVs += 16;\\r\\nfor (i = 1; i < x4; i++) {\\r\\nciph_d[i].inp = hash_d[i].ptr = hash_d[i - 1].ptr + frag;\\r\\nciph_d[i].out = ciph_d[i - 1].out + packlen;\\r\\nmemcpy(ciph_d[i].out - 16, IVs, 16);\\r\\nmemcpy(ciph_d[i].iv, IVs, 16);\\r\\nIVs += 16;\\r\\n}\\r\\n# if defined(BSWAP8)\\r\\nmemcpy(blocks[0].c, key->md.data, 8);\\r\\nseqnum = BSWAP8(blocks[0].q[0]);\\r\\n# endif\\r\\nfor (i = 0; i < x4; i++) {\\r\\nunsigned int len = (i == (x4 - 1) ? last : frag);\\r\\n# if !defined(BSWAP8)\\r\\nunsigned int carry, j;\\r\\n# endif\\r\\nctx->A[i] = key->md.h0;\\r\\nctx->B[i] = key->md.h1;\\r\\nctx->C[i] = key->md.h2;\\r\\nctx->D[i] = key->md.h3;\\r\\nctx->E[i] = key->md.h4;\\r\\n# if defined(BSWAP8)\\r\\nblocks[i].q[0] = BSWAP8(seqnum + i);\\r\\n# else\\r\\nfor (carry = i, j = 8; j--;) {\\r\\nblocks[i].c[j] = ((u8 *)key->md.data)[j] + carry;\\r\\ncarry = (blocks[i].c[j] - carry) >> (sizeof(carry) * 8 - 1);\\r\\n}\\r\\n# endif\\r\\nblocks[i].c[8] = ((u8 *)key->md.data)[8];\\r\\nblocks[i].c[9] = ((u8 *)key->md.data)[9];\\r\\nblocks[i].c[10] = ((u8 *)key->md.data)[10];\\r\\nblocks[i].c[11] = (u8)(len >> 8);\\r\\nblocks[i].c[12] = (u8)(len);\\r\\nmemcpy(blocks[i].c + 13, hash_d[i].ptr, 64 - 13);\\r\\nhash_d[i].ptr += 64 - 13;\\r\\nhash_d[i].blocks = (len - (64 - 13)) / 64;\\r\\nedges[i].ptr = blocks[i].c;\\r\\nedges[i].blocks = 1;\\r\\n}\\r\\nsha1_multi_block(ctx, edges, n4x);\\r\\n# define MAXCHUNKSIZE 2048\\r\\n# if MAXCHUNKSIZE%64\\r\\n# error \"MAXCHUNKSIZE is not divisible by 64\"\\r\\n# elif MAXCHUNKSIZE\\r\\nminblocks = ((frag <= last ? frag : last) - (64 - 13)) / 64;\\r\\nif (minblocks > MAXCHUNKSIZE / 64) {\\r\\nfor (i = 0; i < x4; i++) {\\r\\nedges[i].ptr = hash_d[i].ptr;\\r\\nedges[i].blocks = MAXCHUNKSIZE / 64;\\r\\nciph_d[i].blocks = MAXCHUNKSIZE / 16;\\r\\n}\\r\\ndo {\\r\\nsha1_multi_block(ctx, edges, n4x);\\r\\naesni_multi_cbc_encrypt(ciph_d, &key->ks, n4x);\\r\\nfor (i = 0; i < x4; i++) {\\r\\nedges[i].ptr = hash_d[i].ptr += MAXCHUNKSIZE;\\r\\nhash_d[i].blocks -= MAXCHUNKSIZE / 64;\\r\\nedges[i].blocks = MAXCHUNKSIZE / 64;\\r\\nciph_d[i].inp += MAXCHUNKSIZE;\\r\\nciph_d[i].out += MAXCHUNKSIZE;\\r\\nciph_d[i].blocks = MAXCHUNKSIZE / 16;\\r\\nmemcpy(ciph_d[i].iv, ciph_d[i].out - 16, 16);\\r\\n}\\r\\nprocessed += MAXCHUNKSIZE;\\r\\nminblocks -= MAXCHUNKSIZE / 64;\\r\\n} while (minblocks > MAXCHUNKSIZE / 64);\\r\\n}\\r\\n# endif\\r\\n# undef MAXCHUNKSIZE\\r\\nsha1_multi_block(ctx, hash_d, n4x);\\r\\nmemset(blocks, 0, sizeof(blocks));\\r\\nfor (i = 0; i < x4; i++) {\\r\\nunsigned int len = (i == (x4 - 1) ? last : frag),\\r\\noff = hash_d[i].blocks * 64;\\r\\nconst unsigned char *ptr = hash_d[i].ptr + off;\\r\\noff = (len - processed) - (64 - 13) - off;\\r\\nmemcpy(blocks[i].c, ptr, off);\\r\\nblocks[i].c[off] = 0x80;\\r\\nlen += 64 + 13;\\r\\nlen *= 8;\\r\\nif (off < (64 - 8)) {\\r\\n# ifdef BSWAP4\\r\\nblocks[i].d[15] = BSWAP4(len);\\r\\n# else\\r\\nPUTU32(blocks[i].c + 60, len);\\r\\n# endif\\r\\nedges[i].blocks = 1;\\r\\n} else {\\r\\n# ifdef BSWAP4\\r\\nblocks[i].d[31] = BSWAP4(len);\\r\\n# else\\r\\nPUTU32(blocks[i].c + 124, len);\\r\\n# endif\\r\\nedges[i].blocks = 2;\\r\\n}\\r\\nedges[i].ptr = blocks[i].c;\\r\\n}\\r\\nsha1_multi_block(ctx, edges, n4x);\\r\\nmemset(blocks, 0, sizeof(blocks));\\r\\nfor (i = 0; i < x4; i++) {\\r\\n# ifdef BSWAP4\\r\\nblocks[i].d[0] = BSWAP4(ctx->A[i]);\\r\\nctx->A[i] = key->tail.h0;\\r\\nblocks[i].d[1] = BSWAP4(ctx->B[i]);\\r\\nctx->B[i] = key->tail.h1;\\r\\nblocks[i].d[2] = BSWAP4(ctx->C[i]);\\r\\nctx->C[i] = key->tail.h2;\\r\\nblocks[i].d[3] = BSWAP4(ctx->D[i]);\\r\\nctx->D[i] = key->tail.h3;\\r\\nblocks[i].d[4] = BSWAP4(ctx->E[i]);\\r\\nctx->E[i] = key->tail.h4;\\r\\nblocks[i].c[20] = 0x80;\\r\\nblocks[i].d[15] = BSWAP4((64 + 20) * 8);\\r\\n# else\\r\\nPUTU32(blocks[i].c + 0, ctx->A[i]);\\r\\nctx->A[i] = key->tail.h0;\\r\\nPUTU32(blocks[i].c + 4, ctx->B[i]);\\r\\nctx->B[i] = key->tail.h1;\\r\\nPUTU32(blocks[i].c + 8, ctx->C[i]);\\r\\nctx->C[i] = key->tail.h2;\\r\\nPUTU32(blocks[i].c + 12, ctx->D[i]);\\r\\nctx->D[i] = key->tail.h3;\\r\\nPUTU32(blocks[i].c + 16, ctx->E[i]);\\r\\nctx->E[i] = key->tail.h4;\\r\\nblocks[i].c[20] = 0x80;\\r\\nPUTU32(blocks[i].c + 60, (64 + 20) * 8);\\r\\n# endif\\r\\nedges[i].ptr = blocks[i].c;\\r\\nedges[i].blocks = 1;\\r\\n}\\r\\nsha1_multi_block(ctx, edges, n4x);\\r\\nfor (i = 0; i < x4; i++) {\\r\\nunsigned int len = (i == (x4 - 1) ? last : frag), pad, j;\\r\\nunsigned char *out0 = out;\\r\\nmemcpy(ciph_d[i].out, ciph_d[i].inp, len - processed);\\r\\nciph_d[i].inp = ciph_d[i].out;\\r\\nout += 5 + 16 + len;\\r\\nPUTU32(out + 0, ctx->A[i]);\\r\\nPUTU32(out + 4, ctx->B[i]);\\r\\nPUTU32(out + 8, ctx->C[i]);\\r\\nPUTU32(out + 12, ctx->D[i]);\\r\\nPUTU32(out + 16, ctx->E[i]);\\r\\nout += 20;\\r\\nlen += 20;\\r\\npad = 15 - len % 16;\\r\\nfor (j = 0; j <= pad; j++)\\r\\n*(out++) = pad;\\r\\nlen += pad + 1;\\r\\nciph_d[i].blocks = (len - processed) / 16;\\r\\nlen += 16;\\r\\nout0[0] = ((u8 *)key->md.data)[8];\\r\\nout0[1] = ((u8 *)key->md.data)[9];\\r\\nout0[2] = ((u8 *)key->md.data)[10];\\r\\nout0[3] = (u8)(len >> 8);\\r\\nout0[4] = (u8)(len);\\r\\nret += len + 5;\\r\\ninp += frag;\\r\\n}\\r\\naesni_multi_cbc_encrypt(ciph_d, &key->ks, n4x);\\r\\nOPENSSL_cleanse(blocks, sizeof(blocks));\\r\\nOPENSSL_cleanse(ctx, sizeof(*ctx));\\r\\nreturn ret;\\r\\n}\\r\\nstatic int aesni_cbc_hmac_sha1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_HMAC_SHA1 *key = data(ctx);\\r\\nunsigned int l;\\r\\nsize_t plen = key->payload_length, iv = 0,\\r\\nsha_off = 0;\\r\\n# if defined(STITCHED_CALL)\\r\\nsize_t aes_off = 0, blocks;\\r\\nsha_off = SHA_CBLOCK - key->md.num;\\r\\n# endif\\r\\nkey->payload_length = NO_PAYLOAD_LENGTH;\\r\\nif (len % AES_BLOCK_SIZE)\\r\\nreturn 0;\\r\\nif (ctx->encrypt) {\\r\\nif (plen == NO_PAYLOAD_LENGTH)\\r\\nplen = len;\\r\\nelse if (len !=\\r\\n((plen + SHA_DIGEST_LENGTH +\\r\\nAES_BLOCK_SIZE) & -AES_BLOCK_SIZE))\\r\\nreturn 0;\\r\\nelse if (key->aux.tls_ver >= TLS1_1_VERSION)\\r\\niv = AES_BLOCK_SIZE;\\r\\n# if defined(STITCHED_CALL)\\r\\nif (plen > (sha_off + iv)\\r\\n&& (blocks = (plen - (sha_off + iv)) / SHA_CBLOCK)) {\\r\\nSHA1_Update(&key->md, in + iv, sha_off);\\r\\naesni_cbc_sha1_enc(in, out, blocks, &key->ks,\\r\\nctx->iv, &key->md, in + iv + sha_off);\\r\\nblocks *= SHA_CBLOCK;\\r\\naes_off += blocks;\\r\\nsha_off += blocks;\\r\\nkey->md.Nh += blocks >> 29;\\r\\nkey->md.Nl += blocks <<= 3;\\r\\nif (key->md.Nl < (unsigned int)blocks)\\r\\nkey->md.Nh++;\\r\\n} else {\\r\\nsha_off = 0;\\r\\n}\\r\\n# endif\\r\\nsha_off += iv;\\r\\nSHA1_Update(&key->md, in + sha_off, plen - sha_off);\\r\\nif (plen != len) {\\r\\nif (in != out)\\r\\nmemcpy(out + aes_off, in + aes_off, plen - aes_off);\\r\\nSHA1_Final(out + plen, &key->md);\\r\\nkey->md = key->tail;\\r\\nSHA1_Update(&key->md, out + plen, SHA_DIGEST_LENGTH);\\r\\nSHA1_Final(out + plen, &key->md);\\r\\nplen += SHA_DIGEST_LENGTH;\\r\\nfor (l = len - plen - 1; plen < len; plen++)\\r\\nout[plen] = l;\\r\\naesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,\\r\\n&key->ks, ctx->iv, 1);\\r\\n} else {\\r\\naesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,\\r\\n&key->ks, ctx->iv, 1);\\r\\n}\\r\\n} else {\\r\\nunion {\\r\\nunsigned int u[SHA_DIGEST_LENGTH / sizeof(unsigned int)];\\r\\nunsigned char c[32 + SHA_DIGEST_LENGTH];\\r\\n} mac, *pmac;\\r\\npmac = (void *)(((size_t)mac.c + 31) & ((size_t)0 - 32));\\r\\nif (plen != NO_PAYLOAD_LENGTH) {\\r\\nsize_t inp_len, mask, j, i;\\r\\nunsigned int res, maxpad, pad, bitlen;\\r\\nint ret = 1;\\r\\nunion {\\r\\nunsigned int u[SHA_LBLOCK];\\r\\nunsigned char c[SHA_CBLOCK];\\r\\n} *data = (void *)key->md.data;\\r\\n# if defined(STITCHED_DECRYPT_CALL)\\r\\nunsigned char tail_iv[AES_BLOCK_SIZE];\\r\\nint stitch = 0;\\r\\n# endif\\r\\nif ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])\\r\\n>= TLS1_1_VERSION) {\\r\\nif (len < (AES_BLOCK_SIZE + SHA_DIGEST_LENGTH + 1))\\r\\nreturn 0;\\r\\nmemcpy(ctx->iv, in, AES_BLOCK_SIZE);\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\nlen -= AES_BLOCK_SIZE;\\r\\n} else if (len < (SHA_DIGEST_LENGTH + 1))\\r\\nreturn 0;\\r\\n# if defined(STITCHED_DECRYPT_CALL)\\r\\nif (len >= 1024 && ctx->key_len == 32) {\\r\\nmemcpy(tail_iv, in + len - 2 * AES_BLOCK_SIZE,\\r\\nAES_BLOCK_SIZE);\\r\\naesni_cbc_encrypt(in + len - AES_BLOCK_SIZE,\\r\\nout + len - AES_BLOCK_SIZE, AES_BLOCK_SIZE,\\r\\n&key->ks, tail_iv, 0);\\r\\nstitch = 1;\\r\\n} else\\r\\n# endif\\r\\naesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);\\r\\npad = out[len - 1];\\r\\nmaxpad = len - (SHA_DIGEST_LENGTH + 1);\\r\\nmaxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);\\r\\nmaxpad &= 255;\\r\\ninp_len = len - (SHA_DIGEST_LENGTH + pad + 1);\\r\\nmask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));\\r\\ninp_len &= mask;\\r\\nret &= (int)mask;\\r\\nkey->aux.tls_aad[plen - 2] = inp_len >> 8;\\r\\nkey->aux.tls_aad[plen - 1] = inp_len;\\r\\nkey->md = key->head;\\r\\nSHA1_Update(&key->md, key->aux.tls_aad, plen);\\r\\n# if defined(STITCHED_DECRYPT_CALL)\\r\\nif (stitch) {\\r\\nblocks = (len - (256 + 32 + SHA_CBLOCK)) / SHA_CBLOCK;\\r\\naes_off = len - AES_BLOCK_SIZE - blocks * SHA_CBLOCK;\\r\\nsha_off = SHA_CBLOCK - plen;\\r\\naesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);\\r\\nSHA1_Update(&key->md, out, sha_off);\\r\\naesni256_cbc_sha1_dec(in + aes_off,\\r\\nout + aes_off, blocks, &key->ks,\\r\\nctx->iv, &key->md, out + sha_off);\\r\\nsha_off += blocks *= SHA_CBLOCK;\\r\\nout += sha_off;\\r\\nlen -= sha_off;\\r\\ninp_len -= sha_off;\\r\\nkey->md.Nl += (blocks << 3);\\r\\nmemcpy(ctx->iv, tail_iv, AES_BLOCK_SIZE);\\r\\n}\\r\\n# endif\\r\\n# if 1\\r\\nlen -= SHA_DIGEST_LENGTH;\\r\\nif (len >= (256 + SHA_CBLOCK)) {\\r\\nj = (len - (256 + SHA_CBLOCK)) & (0 - SHA_CBLOCK);\\r\\nj += SHA_CBLOCK - key->md.num;\\r\\nSHA1_Update(&key->md, out, j);\\r\\nout += j;\\r\\nlen -= j;\\r\\ninp_len -= j;\\r\\n}\\r\\nbitlen = key->md.Nl + (inp_len << 3);\\r\\n# ifdef BSWAP4\\r\\nbitlen = BSWAP4(bitlen);\\r\\n# else\\r\\nmac.c[0] = 0;\\r\\nmac.c[1] = (unsigned char)(bitlen >> 16);\\r\\nmac.c[2] = (unsigned char)(bitlen >> 8);\\r\\nmac.c[3] = (unsigned char)bitlen;\\r\\nbitlen = mac.u[0];\\r\\n# endif\\r\\npmac->u[0] = 0;\\r\\npmac->u[1] = 0;\\r\\npmac->u[2] = 0;\\r\\npmac->u[3] = 0;\\r\\npmac->u[4] = 0;\\r\\nfor (res = key->md.num, j = 0; j < len; j++) {\\r\\nsize_t c = out[j];\\r\\nmask = (j - inp_len) >> (sizeof(j) * 8 - 8);\\r\\nc &= mask;\\r\\nc |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));\\r\\ndata->c[res++] = (unsigned char)c;\\r\\nif (res != SHA_CBLOCK)\\r\\ncontinue;\\r\\nmask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));\\r\\ndata->u[SHA_LBLOCK - 1] |= bitlen & mask;\\r\\nsha1_block_data_order(&key->md, data, 1);\\r\\nmask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));\\r\\npmac->u[0] |= key->md.h0 & mask;\\r\\npmac->u[1] |= key->md.h1 & mask;\\r\\npmac->u[2] |= key->md.h2 & mask;\\r\\npmac->u[3] |= key->md.h3 & mask;\\r\\npmac->u[4] |= key->md.h4 & mask;\\r\\nres = 0;\\r\\n}\\r\\nfor (i = res; i < SHA_CBLOCK; i++, j++)\\r\\ndata->c[i] = 0;\\r\\nif (res > SHA_CBLOCK - 8) {\\r\\nmask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));\\r\\ndata->u[SHA_LBLOCK - 1] |= bitlen & mask;\\r\\nsha1_block_data_order(&key->md, data, 1);\\r\\nmask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\\r\\npmac->u[0] |= key->md.h0 & mask;\\r\\npmac->u[1] |= key->md.h1 & mask;\\r\\npmac->u[2] |= key->md.h2 & mask;\\r\\npmac->u[3] |= key->md.h3 & mask;\\r\\npmac->u[4] |= key->md.h4 & mask;\\r\\nmemset(data, 0, SHA_CBLOCK);\\r\\nj += 64;\\r\\n}\\r\\ndata->u[SHA_LBLOCK - 1] = bitlen;\\r\\nsha1_block_data_order(&key->md, data, 1);\\r\\nmask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\\r\\npmac->u[0] |= key->md.h0 & mask;\\r\\npmac->u[1] |= key->md.h1 & mask;\\r\\npmac->u[2] |= key->md.h2 & mask;\\r\\npmac->u[3] |= key->md.h3 & mask;\\r\\npmac->u[4] |= key->md.h4 & mask;\\r\\n# ifdef BSWAP4\\r\\npmac->u[0] = BSWAP4(pmac->u[0]);\\r\\npmac->u[1] = BSWAP4(pmac->u[1]);\\r\\npmac->u[2] = BSWAP4(pmac->u[2]);\\r\\npmac->u[3] = BSWAP4(pmac->u[3]);\\r\\npmac->u[4] = BSWAP4(pmac->u[4]);\\r\\n# else\\r\\nfor (i = 0; i < 5; i++) {\\r\\nres = pmac->u[i];\\r\\npmac->c[4 * i + 0] = (unsigned char)(res >> 24);\\r\\npmac->c[4 * i + 1] = (unsigned char)(res >> 16);\\r\\npmac->c[4 * i + 2] = (unsigned char)(res >> 8);\\r\\npmac->c[4 * i + 3] = (unsigned char)res;\\r\\n}\\r\\n# endif\\r\\nlen += SHA_DIGEST_LENGTH;\\r\\n# else\\r\\nSHA1_Update(&key->md, out, inp_len);\\r\\nres = key->md.num;\\r\\nSHA1_Final(pmac->c, &key->md);\\r\\n{\\r\\nunsigned int inp_blocks, pad_blocks;\\r\\ninp_blocks =\\r\\n1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\\r\\nres += (unsigned int)(len - inp_len);\\r\\npad_blocks = res / SHA_CBLOCK;\\r\\nres %= SHA_CBLOCK;\\r\\npad_blocks +=\\r\\n1 + ((SHA_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\\r\\nfor (; inp_blocks < pad_blocks; inp_blocks++)\\r\\nsha1_block_data_order(&key->md, data, 1);\\r\\n}\\r\\n# endif\\r\\nkey->md = key->tail;\\r\\nSHA1_Update(&key->md, pmac->c, SHA_DIGEST_LENGTH);\\r\\nSHA1_Final(pmac->c, &key->md);\\r\\nout += inp_len;\\r\\nlen -= inp_len;\\r\\n# if 1\\r\\n{\\r\\nunsigned char *p = out + len - 1 - maxpad - SHA_DIGEST_LENGTH;\\r\\nsize_t off = out - p;\\r\\nunsigned int c, cmask;\\r\\nmaxpad += SHA_DIGEST_LENGTH;\\r\\nfor (res = 0, i = 0, j = 0; j < maxpad; j++) {\\r\\nc = p[j];\\r\\ncmask =\\r\\n((int)(j - off - SHA_DIGEST_LENGTH)) >> (sizeof(int) *\\r\\n8 - 1);\\r\\nres |= (c ^ pad) & ~cmask;\\r\\ncmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);\\r\\nres |= (c ^ pmac->c[i]) & cmask;\\r\\ni += 1 & cmask;\\r\\n}\\r\\nmaxpad -= SHA_DIGEST_LENGTH;\\r\\nres = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\\r\\nret &= (int)~res;\\r\\n}\\r\\n# else\\r\\nfor (res = 0, i = 0; i < SHA_DIGEST_LENGTH; i++)\\r\\nres |= out[i] ^ pmac->c[i];\\r\\nres = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\\r\\nret &= (int)~res;\\r\\npad = (pad & ~res) | (maxpad & res);\\r\\nout = out + len - 1 - pad;\\r\\nfor (res = 0, i = 0; i < pad; i++)\\r\\nres |= out[i] ^ pad;\\r\\nres = (0 - res) >> (sizeof(res) * 8 - 1);\\r\\nret &= (int)~res;\\r\\n# endif\\r\\nreturn ret;\\r\\n} else {\\r\\n# if defined(STITCHED_DECRYPT_CALL)\\r\\nif (len >= 1024 && ctx->key_len == 32) {\\r\\nif (sha_off %= SHA_CBLOCK)\\r\\nblocks = (len - 3 * SHA_CBLOCK) / SHA_CBLOCK;\\r\\nelse\\r\\nblocks = (len - 2 * SHA_CBLOCK) / SHA_CBLOCK;\\r\\naes_off = len - blocks * SHA_CBLOCK;\\r\\naesni_cbc_encrypt(in, out, aes_off, &key->ks, ctx->iv, 0);\\r\\nSHA1_Update(&key->md, out, sha_off);\\r\\naesni256_cbc_sha1_dec(in + aes_off,\\r\\nout + aes_off, blocks, &key->ks,\\r\\nctx->iv, &key->md, out + sha_off);\\r\\nsha_off += blocks *= SHA_CBLOCK;\\r\\nout += sha_off;\\r\\nlen -= sha_off;\\r\\nkey->md.Nh += blocks >> 29;\\r\\nkey->md.Nl += blocks <<= 3;\\r\\nif (key->md.Nl < (unsigned int)blocks)\\r\\nkey->md.Nh++;\\r\\n} else\\r\\n# endif\\r\\naesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);\\r\\nSHA1_Update(&key->md, out, len);\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aesni_cbc_hmac_sha1_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\\r\\nvoid *ptr)\\r\\n{\\r\\nEVP_AES_HMAC_SHA1 *key = data(ctx);\\r\\nswitch (type) {\\r\\ncase EVP_CTRL_AEAD_SET_MAC_KEY:\\r\\n{\\r\\nunsigned int i;\\r\\nunsigned char hmac_key[64];\\r\\nmemset(hmac_key, 0, sizeof(hmac_key));\\r\\nif (arg > (int)sizeof(hmac_key)) {\\r\\nSHA1_Init(&key->head);\\r\\nSHA1_Update(&key->head, ptr, arg);\\r\\nSHA1_Final(hmac_key, &key->head);\\r\\n} else {\\r\\nmemcpy(hmac_key, ptr, arg);\\r\\n}\\r\\nfor (i = 0; i < sizeof(hmac_key); i++)\\r\\nhmac_key[i] ^= 0x36;\\r\\nSHA1_Init(&key->head);\\r\\nSHA1_Update(&key->head, hmac_key, sizeof(hmac_key));\\r\\nfor (i = 0; i < sizeof(hmac_key); i++)\\r\\nhmac_key[i] ^= 0x36 ^ 0x5c;\\r\\nSHA1_Init(&key->tail);\\r\\nSHA1_Update(&key->tail, hmac_key, sizeof(hmac_key));\\r\\nOPENSSL_cleanse(hmac_key, sizeof(hmac_key));\\r\\nreturn 1;\\r\\n}\\r\\ncase EVP_CTRL_AEAD_TLS1_AAD:\\r\\n{\\r\\nunsigned char *p = ptr;\\r\\nunsigned int len = p[arg - 2] << 8 | p[arg - 1];\\r\\nif (ctx->encrypt) {\\r\\nkey->payload_length = len;\\r\\nif ((key->aux.tls_ver =\\r\\np[arg - 4] << 8 | p[arg - 3]) >= TLS1_1_VERSION) {\\r\\nlen -= AES_BLOCK_SIZE;\\r\\np[arg - 2] = len >> 8;\\r\\np[arg - 1] = len;\\r\\n}\\r\\nkey->md = key->head;\\r\\nSHA1_Update(&key->md, p, arg);\\r\\nreturn (int)(((len + SHA_DIGEST_LENGTH +\\r\\nAES_BLOCK_SIZE) & -AES_BLOCK_SIZE)\\r\\n- len);\\r\\n} else {\\r\\nif (arg > 13)\\r\\narg = 13;\\r\\nmemcpy(key->aux.tls_aad, ptr, arg);\\r\\nkey->payload_length = arg;\\r\\nreturn SHA_DIGEST_LENGTH;\\r\\n}\\r\\n}\\r\\n# if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\\r\\ncase EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE:\\r\\nreturn (int)(5 + 16 + ((arg + 20 + 16) & -16));\\r\\ncase EVP_CTRL_TLS1_1_MULTIBLOCK_AAD:\\r\\n{\\r\\nEVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param =\\r\\n(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *) ptr;\\r\\nunsigned int n4x = 1, x4;\\r\\nunsigned int frag, last, packlen, inp_len;\\r\\nif (arg < (int)sizeof(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM))\\r\\nreturn -1;\\r\\ninp_len = param->inp[11] << 8 | param->inp[12];\\r\\nif (ctx->encrypt) {\\r\\nif ((param->inp[9] << 8 | param->inp[10]) < TLS1_1_VERSION)\\r\\nreturn -1;\\r\\nif (inp_len) {\\r\\nif (inp_len < 4096)\\r\\nreturn 0;\\r\\nif (inp_len >= 8192 && OPENSSL_ia32cap_P[2] & (1 << 5))\\r\\nn4x = 2;\\r\\n} else if ((n4x = param->interleave / 4) && n4x <= 2)\\r\\ninp_len = param->len;\\r\\nelse\\r\\nreturn -1;\\r\\nkey->md = key->head;\\r\\nSHA1_Update(&key->md, param->inp, 13);\\r\\nx4 = 4 * n4x;\\r\\nn4x += 1;\\r\\nfrag = inp_len >> n4x;\\r\\nlast = inp_len + frag - (frag << n4x);\\r\\nif (last > frag && ((last + 13 + 9) % 64 < (x4 - 1))) {\\r\\nfrag++;\\r\\nlast -= x4 - 1;\\r\\n}\\r\\npacklen = 5 + 16 + ((frag + 20 + 16) & -16);\\r\\npacklen = (packlen << n4x) - packlen;\\r\\npacklen += 5 + 16 + ((last + 20 + 16) & -16);\\r\\nparam->interleave = x4;\\r\\nreturn (int)packlen;\\r\\n} else\\r\\nreturn -1;\\r\\n}\\r\\ncase EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT:\\r\\n{\\r\\nEVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param =\\r\\n(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *) ptr;\\r\\nreturn (int)tls1_1_multi_block_encrypt(key, param->out,\\r\\nparam->inp, param->len,\\r\\nparam->interleave / 4);\\r\\n}\\r\\ncase EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT:\\r\\n# endif\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void)\\r\\n{\\r\\nreturn (OPENSSL_ia32cap_P[1] & AESNI_CAPABLE ?\\r\\n&aesni_128_cbc_hmac_sha1_cipher : NULL);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void)\\r\\n{\\r\\nreturn (OPENSSL_ia32cap_P[1] & AESNI_CAPABLE ?\\r\\n&aesni_256_cbc_hmac_sha1_cipher : NULL);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_i2d_pr_c", "target": 0, "func": "int i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp)\\r\\n{\\r\\nif (a->ameth && a->ameth->old_priv_encode) {\\r\\nreturn a->ameth->old_priv_encode(a, pp);\\r\\n}\\r\\nif (a->ameth && a->ameth->priv_encode) {\\r\\nPKCS8_PRIV_KEY_INFO *p8 = EVP_PKEY2PKCS8(a);\\r\\nint ret = i2d_PKCS8_PRIV_KEY_INFO(p8, pp);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nreturn ret;\\r\\n}\\r\\nASN1err(ASN1_F_I2D_PRIVATEKEY, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);\\r\\nreturn (-1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x86_64-gcc_c", "target": 0, "func": "BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num,\\r\\nBN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1 = 0;\\r\\nif (num <= 0)\\r\\nreturn (c1);\\r\\nwhile (num & ~3) {\\r\\nmul_add(rp[0], ap[0], w, c1);\\r\\nmul_add(rp[1], ap[1], w, c1);\\r\\nmul_add(rp[2], ap[2], w, c1);\\r\\nmul_add(rp[3], ap[3], w, c1);\\r\\nap += 4;\\r\\nrp += 4;\\r\\nnum -= 4;\\r\\n}\\r\\nif (num) {\\r\\nmul_add(rp[0], ap[0], w, c1);\\r\\nif (--num == 0)\\r\\nreturn c1;\\r\\nmul_add(rp[1], ap[1], w, c1);\\r\\nif (--num == 0)\\r\\nreturn c1;\\r\\nmul_add(rp[2], ap[2], w, c1);\\r\\nreturn c1;\\r\\n}\\r\\nreturn (c1);\\r\\n}\\r\\nBN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1 = 0;\\r\\nif (num <= 0)\\r\\nreturn (c1);\\r\\nwhile (num & ~3) {\\r\\nmul(rp[0], ap[0], w, c1);\\r\\nmul(rp[1], ap[1], w, c1);\\r\\nmul(rp[2], ap[2], w, c1);\\r\\nmul(rp[3], ap[3], w, c1);\\r\\nap += 4;\\r\\nrp += 4;\\r\\nnum -= 4;\\r\\n}\\r\\nif (num) {\\r\\nmul(rp[0], ap[0], w, c1);\\r\\nif (--num == 0)\\r\\nreturn c1;\\r\\nmul(rp[1], ap[1], w, c1);\\r\\nif (--num == 0)\\r\\nreturn c1;\\r\\nmul(rp[2], ap[2], w, c1);\\r\\n}\\r\\nreturn (c1);\\r\\n}\\r\\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\\r\\n{\\r\\nif (n <= 0)\\r\\nreturn;\\r\\nwhile (n & ~3) {\\r\\nsqr(r[0], r[1], a[0]);\\r\\nsqr(r[2], r[3], a[1]);\\r\\nsqr(r[4], r[5], a[2]);\\r\\nsqr(r[6], r[7], a[3]);\\r\\na += 4;\\r\\nr += 8;\\r\\nn -= 4;\\r\\n}\\r\\nif (n) {\\r\\nsqr(r[0], r[1], a[0]);\\r\\nif (--n == 0)\\r\\nreturn;\\r\\nsqr(r[2], r[3], a[1]);\\r\\nif (--n == 0)\\r\\nreturn;\\r\\nsqr(r[4], r[5], a[2]);\\r\\n}\\r\\n}\\r\\nBN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)\\r\\n{\\r\\nBN_ULONG ret, waste;\\r\\nasm(\"divq %4\":\"=a\"(ret), \"=d\"(waste)\\r\\n: \"a\"(l), \"d\"(h), \"g\"(d)\\r\\n: \"cc\");\\r\\nreturn ret;\\r\\n}\\r\\nBN_ULONG bn_add_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nint n)\\r\\n{\\r\\nBN_ULONG ret;\\r\\nsize_t i = 0;\\r\\nif (n <= 0)\\r\\nreturn 0;\\r\\nasm volatile (\" subq %0,%0 \\n\"\\r\\n\" jmp 1f \\n\"\\r\\n\".p2align 4 \\n\"\\r\\n\"1: movq (%4,%2,8),%0 \\n\"\\r\\n\" adcq (%5,%2,8),%0 \\n\"\\r\\n\" movq %0,(%3,%2,8) \\n\"\\r\\n\" lea 1(%2),%2 \\n\"\\r\\n\" loop 1b \\n\"\\r\\n\" sbbq %0,%0 \\n\":\"=&r\" (ret), \"+c\"(n),\\r\\n\"+r\"(i)\\r\\n:\"r\"(rp), \"r\"(ap), \"r\"(bp)\\r\\n:\"cc\", \"memory\");\\r\\nreturn ret & 1;\\r\\n}\\r\\nBN_ULONG bn_sub_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nint n)\\r\\n{\\r\\nBN_ULONG ret;\\r\\nsize_t i = 0;\\r\\nif (n <= 0)\\r\\nreturn 0;\\r\\nasm volatile (\" subq %0,%0 \\n\"\\r\\n\" jmp 1f \\n\"\\r\\n\".p2align 4 \\n\"\\r\\n\"1: movq (%4,%2,8),%0 \\n\"\\r\\n\" sbbq (%5,%2,8),%0 \\n\"\\r\\n\" movq %0,(%3,%2,8) \\n\"\\r\\n\" lea 1(%2),%2 \\n\"\\r\\n\" loop 1b \\n\"\\r\\n\" sbbq %0,%0 \\n\":\"=&r\" (ret), \"+c\"(n),\\r\\n\"+r\"(i)\\r\\n:\"r\"(rp), \"r\"(ap), \"r\"(bp)\\r\\n:\"cc\", \"memory\");\\r\\nreturn ret & 1;\\r\\n}\\r\\nBN_ULONG bn_sub_words(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n)\\r\\n{\\r\\nBN_ULONG t1, t2;\\r\\nint c = 0;\\r\\nif (n <= 0)\\r\\nreturn ((BN_ULONG)0);\\r\\nfor (;;) {\\r\\nt1 = a[0];\\r\\nt2 = b[0];\\r\\nr[0] = (t1 - t2 - c) & BN_MASK2;\\r\\nif (t1 != t2)\\r\\nc = (t1 < t2);\\r\\nif (--n <= 0)\\r\\nbreak;\\r\\nt1 = a[1];\\r\\nt2 = b[1];\\r\\nr[1] = (t1 - t2 - c) & BN_MASK2;\\r\\nif (t1 != t2)\\r\\nc = (t1 < t2);\\r\\nif (--n <= 0)\\r\\nbreak;\\r\\nt1 = a[2];\\r\\nt2 = b[2];\\r\\nr[2] = (t1 - t2 - c) & BN_MASK2;\\r\\nif (t1 != t2)\\r\\nc = (t1 < t2);\\r\\nif (--n <= 0)\\r\\nbreak;\\r\\nt1 = a[3];\\r\\nt2 = b[3];\\r\\nr[3] = (t1 - t2 - c) & BN_MASK2;\\r\\nif (t1 != t2)\\r\\nc = (t1 < t2);\\r\\nif (--n <= 0)\\r\\nbreak;\\r\\na += 4;\\r\\nb += 4;\\r\\nr += 4;\\r\\n}\\r\\nreturn (c);\\r\\n}\\r\\nvoid bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nBN_ULONG c1, c2, c3;\\r\\nc1 = 0;\\r\\nc2 = 0;\\r\\nc3 = 0;\\r\\nmul_add_c(a[0], b[0], c1, c2, c3);\\r\\nr[0] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[0], b[1], c2, c3, c1);\\r\\nmul_add_c(a[1], b[0], c2, c3, c1);\\r\\nr[1] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[2], b[0], c3, c1, c2);\\r\\nmul_add_c(a[1], b[1], c3, c1, c2);\\r\\nmul_add_c(a[0], b[2], c3, c1, c2);\\r\\nr[2] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[0], b[3], c1, c2, c3);\\r\\nmul_add_c(a[1], b[2], c1, c2, c3);\\r\\nmul_add_c(a[2], b[1], c1, c2, c3);\\r\\nmul_add_c(a[3], b[0], c1, c2, c3);\\r\\nr[3] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[4], b[0], c2, c3, c1);\\r\\nmul_add_c(a[3], b[1], c2, c3, c1);\\r\\nmul_add_c(a[2], b[2], c2, c3, c1);\\r\\nmul_add_c(a[1], b[3], c2, c3, c1);\\r\\nmul_add_c(a[0], b[4], c2, c3, c1);\\r\\nr[4] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[0], b[5], c3, c1, c2);\\r\\nmul_add_c(a[1], b[4], c3, c1, c2);\\r\\nmul_add_c(a[2], b[3], c3, c1, c2);\\r\\nmul_add_c(a[3], b[2], c3, c1, c2);\\r\\nmul_add_c(a[4], b[1], c3, c1, c2);\\r\\nmul_add_c(a[5], b[0], c3, c1, c2);\\r\\nr[5] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[6], b[0], c1, c2, c3);\\r\\nmul_add_c(a[5], b[1], c1, c2, c3);\\r\\nmul_add_c(a[4], b[2], c1, c2, c3);\\r\\nmul_add_c(a[3], b[3], c1, c2, c3);\\r\\nmul_add_c(a[2], b[4], c1, c2, c3);\\r\\nmul_add_c(a[1], b[5], c1, c2, c3);\\r\\nmul_add_c(a[0], b[6], c1, c2, c3);\\r\\nr[6] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[0], b[7], c2, c3, c1);\\r\\nmul_add_c(a[1], b[6], c2, c3, c1);\\r\\nmul_add_c(a[2], b[5], c2, c3, c1);\\r\\nmul_add_c(a[3], b[4], c2, c3, c1);\\r\\nmul_add_c(a[4], b[3], c2, c3, c1);\\r\\nmul_add_c(a[5], b[2], c2, c3, c1);\\r\\nmul_add_c(a[6], b[1], c2, c3, c1);\\r\\nmul_add_c(a[7], b[0], c2, c3, c1);\\r\\nr[7] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[7], b[1], c3, c1, c2);\\r\\nmul_add_c(a[6], b[2], c3, c1, c2);\\r\\nmul_add_c(a[5], b[3], c3, c1, c2);\\r\\nmul_add_c(a[4], b[4], c3, c1, c2);\\r\\nmul_add_c(a[3], b[5], c3, c1, c2);\\r\\nmul_add_c(a[2], b[6], c3, c1, c2);\\r\\nmul_add_c(a[1], b[7], c3, c1, c2);\\r\\nr[8] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[2], b[7], c1, c2, c3);\\r\\nmul_add_c(a[3], b[6], c1, c2, c3);\\r\\nmul_add_c(a[4], b[5], c1, c2, c3);\\r\\nmul_add_c(a[5], b[4], c1, c2, c3);\\r\\nmul_add_c(a[6], b[3], c1, c2, c3);\\r\\nmul_add_c(a[7], b[2], c1, c2, c3);\\r\\nr[9] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[7], b[3], c2, c3, c1);\\r\\nmul_add_c(a[6], b[4], c2, c3, c1);\\r\\nmul_add_c(a[5], b[5], c2, c3, c1);\\r\\nmul_add_c(a[4], b[6], c2, c3, c1);\\r\\nmul_add_c(a[3], b[7], c2, c3, c1);\\r\\nr[10] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[4], b[7], c3, c1, c2);\\r\\nmul_add_c(a[5], b[6], c3, c1, c2);\\r\\nmul_add_c(a[6], b[5], c3, c1, c2);\\r\\nmul_add_c(a[7], b[4], c3, c1, c2);\\r\\nr[11] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[7], b[5], c1, c2, c3);\\r\\nmul_add_c(a[6], b[6], c1, c2, c3);\\r\\nmul_add_c(a[5], b[7], c1, c2, c3);\\r\\nr[12] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[6], b[7], c2, c3, c1);\\r\\nmul_add_c(a[7], b[6], c2, c3, c1);\\r\\nr[13] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[7], b[7], c3, c1, c2);\\r\\nr[14] = c3;\\r\\nr[15] = c1;\\r\\n}\\r\\nvoid bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nBN_ULONG c1, c2, c3;\\r\\nc1 = 0;\\r\\nc2 = 0;\\r\\nc3 = 0;\\r\\nmul_add_c(a[0], b[0], c1, c2, c3);\\r\\nr[0] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[0], b[1], c2, c3, c1);\\r\\nmul_add_c(a[1], b[0], c2, c3, c1);\\r\\nr[1] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[2], b[0], c3, c1, c2);\\r\\nmul_add_c(a[1], b[1], c3, c1, c2);\\r\\nmul_add_c(a[0], b[2], c3, c1, c2);\\r\\nr[2] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[0], b[3], c1, c2, c3);\\r\\nmul_add_c(a[1], b[2], c1, c2, c3);\\r\\nmul_add_c(a[2], b[1], c1, c2, c3);\\r\\nmul_add_c(a[3], b[0], c1, c2, c3);\\r\\nr[3] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[3], b[1], c2, c3, c1);\\r\\nmul_add_c(a[2], b[2], c2, c3, c1);\\r\\nmul_add_c(a[1], b[3], c2, c3, c1);\\r\\nr[4] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[2], b[3], c3, c1, c2);\\r\\nmul_add_c(a[3], b[2], c3, c1, c2);\\r\\nr[5] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[3], b[3], c1, c2, c3);\\r\\nr[6] = c1;\\r\\nr[7] = c2;\\r\\n}\\r\\nvoid bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG c1, c2, c3;\\r\\nc1 = 0;\\r\\nc2 = 0;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 0, c1, c2, c3);\\r\\nr[0] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c2(a, 1, 0, c2, c3, c1);\\r\\nr[1] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c(a, 1, c3, c1, c2);\\r\\nsqr_add_c2(a, 2, 0, c3, c1, c2);\\r\\nr[2] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c2(a, 3, 0, c1, c2, c3);\\r\\nsqr_add_c2(a, 2, 1, c1, c2, c3);\\r\\nr[3] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c(a, 2, c2, c3, c1);\\r\\nsqr_add_c2(a, 3, 1, c2, c3, c1);\\r\\nsqr_add_c2(a, 4, 0, c2, c3, c1);\\r\\nr[4] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c2(a, 5, 0, c3, c1, c2);\\r\\nsqr_add_c2(a, 4, 1, c3, c1, c2);\\r\\nsqr_add_c2(a, 3, 2, c3, c1, c2);\\r\\nr[5] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 3, c1, c2, c3);\\r\\nsqr_add_c2(a, 4, 2, c1, c2, c3);\\r\\nsqr_add_c2(a, 5, 1, c1, c2, c3);\\r\\nsqr_add_c2(a, 6, 0, c1, c2, c3);\\r\\nr[6] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c2(a, 7, 0, c2, c3, c1);\\r\\nsqr_add_c2(a, 6, 1, c2, c3, c1);\\r\\nsqr_add_c2(a, 5, 2, c2, c3, c1);\\r\\nsqr_add_c2(a, 4, 3, c2, c3, c1);\\r\\nr[7] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c(a, 4, c3, c1, c2);\\r\\nsqr_add_c2(a, 5, 3, c3, c1, c2);\\r\\nsqr_add_c2(a, 6, 2, c3, c1, c2);\\r\\nsqr_add_c2(a, 7, 1, c3, c1, c2);\\r\\nr[8] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c2(a, 7, 2, c1, c2, c3);\\r\\nsqr_add_c2(a, 6, 3, c1, c2, c3);\\r\\nsqr_add_c2(a, 5, 4, c1, c2, c3);\\r\\nr[9] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c(a, 5, c2, c3, c1);\\r\\nsqr_add_c2(a, 6, 4, c2, c3, c1);\\r\\nsqr_add_c2(a, 7, 3, c2, c3, c1);\\r\\nr[10] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c2(a, 7, 4, c3, c1, c2);\\r\\nsqr_add_c2(a, 6, 5, c3, c1, c2);\\r\\nr[11] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 6, c1, c2, c3);\\r\\nsqr_add_c2(a, 7, 5, c1, c2, c3);\\r\\nr[12] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c2(a, 7, 6, c2, c3, c1);\\r\\nr[13] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c(a, 7, c3, c1, c2);\\r\\nr[14] = c3;\\r\\nr[15] = c1;\\r\\n}\\r\\nvoid bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG c1, c2, c3;\\r\\nc1 = 0;\\r\\nc2 = 0;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 0, c1, c2, c3);\\r\\nr[0] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c2(a, 1, 0, c2, c3, c1);\\r\\nr[1] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c(a, 1, c3, c1, c2);\\r\\nsqr_add_c2(a, 2, 0, c3, c1, c2);\\r\\nr[2] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c2(a, 3, 0, c1, c2, c3);\\r\\nsqr_add_c2(a, 2, 1, c1, c2, c3);\\r\\nr[3] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c(a, 2, c2, c3, c1);\\r\\nsqr_add_c2(a, 3, 1, c2, c3, c1);\\r\\nr[4] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c2(a, 3, 2, c3, c1, c2);\\r\\nr[5] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 3, c1, c2, c3);\\r\\nr[6] = c1;\\r\\nr[7] = c2;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_lib_c", "target": 0, "func": "int SSL_clear(SSL *s)\\r\\n{\\r\\nif (s->method == NULL) {\\r\\nSSLerr(SSL_F_SSL_CLEAR, SSL_R_NO_METHOD_SPECIFIED);\\r\\nreturn (0);\\r\\n}\\r\\nif (ssl_clear_bad_session(s)) {\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session = NULL;\\r\\n}\\r\\ns->error = 0;\\r\\ns->hit = 0;\\r\\ns->shutdown = 0;\\r\\n#if 0\\r\\nif (s->renegotiate)\\r\\nreturn (1);\\r\\n#else\\r\\nif (s->renegotiate) {\\r\\nSSLerr(SSL_F_SSL_CLEAR, ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\ns->type = 0;\\r\\ns->state = SSL_ST_BEFORE | ((s->server) ? SSL_ST_ACCEPT : SSL_ST_CONNECT);\\r\\ns->version = s->method->version;\\r\\ns->client_version = s->version;\\r\\ns->rwstate = SSL_NOTHING;\\r\\ns->rstate = SSL_ST_READ_HEADER;\\r\\n#if 0\\r\\ns->read_ahead = s->ctx->read_ahead;\\r\\n#endif\\r\\nif (s->init_buf != NULL) {\\r\\nBUF_MEM_free(s->init_buf);\\r\\ns->init_buf = NULL;\\r\\n}\\r\\nssl_clear_cipher_ctx(s);\\r\\nssl_clear_hash_ctx(&s->read_hash);\\r\\nssl_clear_hash_ctx(&s->write_hash);\\r\\ns->first_packet = 0;\\r\\n#if 1\\r\\nif (!s->in_handshake && (s->session == NULL)\\r\\n&& (s->method != s->ctx->method)) {\\r\\ns->method->ssl_free(s);\\r\\ns->method = s->ctx->method;\\r\\nif (!s->method->ssl_new(s))\\r\\nreturn (0);\\r\\n} else\\r\\n#endif\\r\\ns->method->ssl_clear(s);\\r\\nreturn (1);\\r\\n}\\r\\nint SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *meth)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nctx->method = meth;\\r\\nsk = ssl_create_cipher_list(ctx->method, &(ctx->cipher_list),\\r\\n&(ctx->cipher_list_by_id),\\r\\nmeth->version ==\\r\\nSSL2_VERSION ? \"SSLv2\" :\\r\\nSSL_DEFAULT_CIPHER_LIST, ctx->cert);\\r\\nif ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= 0)) {\\r\\nSSLerr(SSL_F_SSL_CTX_SET_SSL_VERSION,\\r\\nSSL_R_SSL_LIBRARY_HAS_NO_CIPHERS);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nSSL *SSL_new(SSL_CTX *ctx)\\r\\n{\\r\\nSSL *s;\\r\\nif (ctx == NULL) {\\r\\nSSLerr(SSL_F_SSL_NEW, SSL_R_NULL_SSL_CTX);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (ctx->method == NULL) {\\r\\nSSLerr(SSL_F_SSL_NEW, SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);\\r\\nreturn (NULL);\\r\\n}\\r\\ns = (SSL *)OPENSSL_malloc(sizeof(SSL));\\r\\nif (s == NULL)\\r\\ngoto err;\\r\\nmemset(s, 0, sizeof(SSL));\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\ns->kssl_ctx = kssl_ctx_new();\\r\\n#endif\\r\\ns->options = ctx->options;\\r\\ns->mode = ctx->mode;\\r\\ns->max_cert_list = ctx->max_cert_list;\\r\\nif (ctx->cert != NULL) {\\r\\ns->cert = ssl_cert_dup(ctx->cert);\\r\\nif (s->cert == NULL)\\r\\ngoto err;\\r\\n} else\\r\\ns->cert = NULL;\\r\\ns->read_ahead = ctx->read_ahead;\\r\\ns->msg_callback = ctx->msg_callback;\\r\\ns->msg_callback_arg = ctx->msg_callback_arg;\\r\\ns->verify_mode = ctx->verify_mode;\\r\\n#if 0\\r\\ns->verify_depth = ctx->verify_depth;\\r\\n#endif\\r\\ns->sid_ctx_length = ctx->sid_ctx_length;\\r\\nOPENSSL_assert(s->sid_ctx_length <= sizeof s->sid_ctx);\\r\\nmemcpy(&s->sid_ctx, &ctx->sid_ctx, sizeof(s->sid_ctx));\\r\\ns->verify_callback = ctx->default_verify_callback;\\r\\ns->generate_session_id = ctx->generate_session_id;\\r\\ns->param = X509_VERIFY_PARAM_new();\\r\\nif (!s->param)\\r\\ngoto err;\\r\\nX509_VERIFY_PARAM_inherit(s->param, ctx->param);\\r\\n#if 0\\r\\ns->purpose = ctx->purpose;\\r\\ns->trust = ctx->trust;\\r\\n#endif\\r\\ns->quiet_shutdown = ctx->quiet_shutdown;\\r\\ns->max_send_fragment = ctx->max_send_fragment;\\r\\nCRYPTO_add(&ctx->references, 1, CRYPTO_LOCK_SSL_CTX);\\r\\ns->ctx = ctx;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\ns->tlsext_debug_cb = 0;\\r\\ns->tlsext_debug_arg = NULL;\\r\\ns->tlsext_ticket_expected = 0;\\r\\ns->tlsext_status_type = -1;\\r\\ns->tlsext_status_expected = 0;\\r\\ns->tlsext_ocsp_ids = NULL;\\r\\ns->tlsext_ocsp_exts = NULL;\\r\\ns->tlsext_ocsp_resp = NULL;\\r\\ns->tlsext_ocsp_resplen = -1;\\r\\nCRYPTO_add(&ctx->references, 1, CRYPTO_LOCK_SSL_CTX);\\r\\ns->initial_ctx = ctx;\\r\\n# ifndef OPENSSL_NO_EC\\r\\nif (ctx->tlsext_ecpointformatlist) {\\r\\ns->tlsext_ecpointformatlist =\\r\\nBUF_memdup(ctx->tlsext_ecpointformatlist,\\r\\nctx->tlsext_ecpointformatlist_length);\\r\\nif (!s->tlsext_ecpointformatlist)\\r\\ngoto err;\\r\\ns->tlsext_ecpointformatlist_length =\\r\\nctx->tlsext_ecpointformatlist_length;\\r\\n}\\r\\nif (ctx->tlsext_ellipticcurvelist) {\\r\\ns->tlsext_ellipticcurvelist =\\r\\nBUF_memdup(ctx->tlsext_ellipticcurvelist,\\r\\nctx->tlsext_ellipticcurvelist_length);\\r\\nif (!s->tlsext_ellipticcurvelist)\\r\\ngoto err;\\r\\ns->tlsext_ellipticcurvelist_length =\\r\\nctx->tlsext_ellipticcurvelist_length;\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\ns->next_proto_negotiated = NULL;\\r\\n# endif\\r\\nif (s->ctx->alpn_client_proto_list) {\\r\\ns->alpn_client_proto_list =\\r\\nOPENSSL_malloc(s->ctx->alpn_client_proto_list_len);\\r\\nif (s->alpn_client_proto_list == NULL)\\r\\ngoto err;\\r\\nmemcpy(s->alpn_client_proto_list, s->ctx->alpn_client_proto_list,\\r\\ns->ctx->alpn_client_proto_list_len);\\r\\ns->alpn_client_proto_list_len = s->ctx->alpn_client_proto_list_len;\\r\\n}\\r\\n#endif\\r\\ns->verify_result = X509_V_OK;\\r\\ns->method = ctx->method;\\r\\nif (!s->method->ssl_new(s))\\r\\ngoto err;\\r\\ns->references = 1;\\r\\ns->server = (ctx->method->ssl_accept == ssl_undefined_function) ? 0 : 1;\\r\\nSSL_clear(s);\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);\\r\\n#ifndef OPENSSL_NO_PSK\\r\\ns->psk_client_callback = ctx->psk_client_callback;\\r\\ns->psk_server_callback = ctx->psk_server_callback;\\r\\n#endif\\r\\nreturn (s);\\r\\nerr:\\r\\nif (s != NULL)\\r\\nSSL_free(s);\\r\\nSSLerr(SSL_F_SSL_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nint SSL_CTX_set_session_id_context(SSL_CTX *ctx, const unsigned char *sid_ctx,\\r\\nunsigned int sid_ctx_len)\\r\\n{\\r\\nif (sid_ctx_len > sizeof ctx->sid_ctx) {\\r\\nSSLerr(SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT,\\r\\nSSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nctx->sid_ctx_length = sid_ctx_len;\\r\\nmemcpy(ctx->sid_ctx, sid_ctx, sid_ctx_len);\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_set_session_id_context(SSL *ssl, const unsigned char *sid_ctx,\\r\\nunsigned int sid_ctx_len)\\r\\n{\\r\\nif (sid_ctx_len > SSL_MAX_SID_CTX_LENGTH) {\\r\\nSSLerr(SSL_F_SSL_SET_SESSION_ID_CONTEXT,\\r\\nSSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nssl->sid_ctx_length = sid_ctx_len;\\r\\nmemcpy(ssl->sid_ctx, sid_ctx, sid_ctx_len);\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nctx->generate_session_id = cb;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_set_generate_session_id(SSL *ssl, GEN_SESSION_CB cb)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL);\\r\\nssl->generate_session_id = cb;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL);\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_has_matching_session_id(const SSL *ssl, const unsigned char *id,\\r\\nunsigned int id_len)\\r\\n{\\r\\nSSL_SESSION r, *p;\\r\\nif (id_len > sizeof r.session_id)\\r\\nreturn 0;\\r\\nr.ssl_version = ssl->version;\\r\\nr.session_id_length = id_len;\\r\\nmemcpy(r.session_id, id, id_len);\\r\\nif ((r.ssl_version == SSL2_VERSION) &&\\r\\n(id_len < SSL2_SSL_SESSION_ID_LENGTH)) {\\r\\nmemset(r.session_id + id_len, 0, SSL2_SSL_SESSION_ID_LENGTH - id_len);\\r\\nr.session_id_length = SSL2_SSL_SESSION_ID_LENGTH;\\r\\n}\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\\r\\np = lh_SSL_SESSION_retrieve(ssl->ctx->sessions, &r);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nreturn (p != NULL);\\r\\n}\\r\\nint SSL_CTX_set_purpose(SSL_CTX *s, int purpose)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_purpose(s->param, purpose);\\r\\n}\\r\\nint SSL_set_purpose(SSL *s, int purpose)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_purpose(s->param, purpose);\\r\\n}\\r\\nint SSL_CTX_set_trust(SSL_CTX *s, int trust)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_trust(s->param, trust);\\r\\n}\\r\\nint SSL_set_trust(SSL *s, int trust)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_trust(s->param, trust);\\r\\n}\\r\\nint SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set1(ctx->param, vpm);\\r\\n}\\r\\nint SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set1(ssl->param, vpm);\\r\\n}\\r\\nX509_VERIFY_PARAM *SSL_CTX_get0_param(SSL_CTX *ctx)\\r\\n{\\r\\nreturn ctx->param;\\r\\n}\\r\\nX509_VERIFY_PARAM *SSL_get0_param(SSL *ssl)\\r\\n{\\r\\nreturn ssl->param;\\r\\n}\\r\\nvoid SSL_certs_clear(SSL *s)\\r\\n{\\r\\nssl_cert_clear_certs(s->cert);\\r\\n}\\r\\nvoid SSL_free(SSL *s)\\r\\n{\\r\\nint i;\\r\\nif (s == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&s->references, -1, CRYPTO_LOCK_SSL);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SSL\", s);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"SSL_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (s->param)\\r\\nX509_VERIFY_PARAM_free(s->param);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);\\r\\nif (s->bbio != NULL) {\\r\\nif (s->bbio == s->wbio) {\\r\\ns->wbio = BIO_pop(s->wbio);\\r\\n}\\r\\nBIO_free(s->bbio);\\r\\ns->bbio = NULL;\\r\\n}\\r\\nif (s->rbio != NULL)\\r\\nBIO_free_all(s->rbio);\\r\\nif ((s->wbio != NULL) && (s->wbio != s->rbio))\\r\\nBIO_free_all(s->wbio);\\r\\nif (s->init_buf != NULL)\\r\\nBUF_MEM_free(s->init_buf);\\r\\nif (s->cipher_list != NULL)\\r\\nsk_SSL_CIPHER_free(s->cipher_list);\\r\\nif (s->cipher_list_by_id != NULL)\\r\\nsk_SSL_CIPHER_free(s->cipher_list_by_id);\\r\\nif (s->session != NULL) {\\r\\nssl_clear_bad_session(s);\\r\\nSSL_SESSION_free(s->session);\\r\\n}\\r\\nssl_clear_cipher_ctx(s);\\r\\nssl_clear_hash_ctx(&s->read_hash);\\r\\nssl_clear_hash_ctx(&s->write_hash);\\r\\nif (s->cert != NULL)\\r\\nssl_cert_free(s->cert);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s->tlsext_hostname)\\r\\nOPENSSL_free(s->tlsext_hostname);\\r\\nif (s->initial_ctx)\\r\\nSSL_CTX_free(s->initial_ctx);\\r\\n# ifndef OPENSSL_NO_EC\\r\\nif (s->tlsext_ecpointformatlist)\\r\\nOPENSSL_free(s->tlsext_ecpointformatlist);\\r\\nif (s->tlsext_ellipticcurvelist)\\r\\nOPENSSL_free(s->tlsext_ellipticcurvelist);\\r\\n# endif\\r\\nif (s->tlsext_opaque_prf_input)\\r\\nOPENSSL_free(s->tlsext_opaque_prf_input);\\r\\nif (s->tlsext_ocsp_exts)\\r\\nsk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts, X509_EXTENSION_free);\\r\\nif (s->tlsext_ocsp_ids)\\r\\nsk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids, OCSP_RESPID_free);\\r\\nif (s->tlsext_ocsp_resp)\\r\\nOPENSSL_free(s->tlsext_ocsp_resp);\\r\\nif (s->alpn_client_proto_list)\\r\\nOPENSSL_free(s->alpn_client_proto_list);\\r\\n#endif\\r\\nif (s->client_CA != NULL)\\r\\nsk_X509_NAME_pop_free(s->client_CA, X509_NAME_free);\\r\\nif (s->method != NULL)\\r\\ns->method->ssl_free(s);\\r\\nif (s->ctx)\\r\\nSSL_CTX_free(s->ctx);\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (s->kssl_ctx != NULL)\\r\\nkssl_ctx_free(s->kssl_ctx);\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\\r\\nif (s->next_proto_negotiated)\\r\\nOPENSSL_free(s->next_proto_negotiated);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRTP\\r\\nif (s->srtp_profiles)\\r\\nsk_SRTP_PROTECTION_PROFILE_free(s->srtp_profiles);\\r\\n#endif\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nvoid SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio)\\r\\n{\\r\\nif (s->bbio != NULL) {\\r\\nif (s->wbio == s->bbio) {\\r\\ns->wbio = s->wbio->next_bio;\\r\\ns->bbio->next_bio = NULL;\\r\\n}\\r\\n}\\r\\nif ((s->rbio != NULL) && (s->rbio != rbio))\\r\\nBIO_free_all(s->rbio);\\r\\nif ((s->wbio != NULL) && (s->wbio != wbio) && (s->rbio != s->wbio))\\r\\nBIO_free_all(s->wbio);\\r\\ns->rbio = rbio;\\r\\ns->wbio = wbio;\\r\\n}\\r\\nBIO *SSL_get_rbio(const SSL *s)\\r\\n{\\r\\nreturn (s->rbio);\\r\\n}\\r\\nBIO *SSL_get_wbio(const SSL *s)\\r\\n{\\r\\nreturn (s->wbio);\\r\\n}\\r\\nint SSL_get_fd(const SSL *s)\\r\\n{\\r\\nreturn (SSL_get_rfd(s));\\r\\n}\\r\\nint SSL_get_rfd(const SSL *s)\\r\\n{\\r\\nint ret = -1;\\r\\nBIO *b, *r;\\r\\nb = SSL_get_rbio(s);\\r\\nr = BIO_find_type(b, BIO_TYPE_DESCRIPTOR);\\r\\nif (r != NULL)\\r\\nBIO_get_fd(r, &ret);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_get_wfd(const SSL *s)\\r\\n{\\r\\nint ret = -1;\\r\\nBIO *b, *r;\\r\\nb = SSL_get_wbio(s);\\r\\nr = BIO_find_type(b, BIO_TYPE_DESCRIPTOR);\\r\\nif (r != NULL)\\r\\nBIO_get_fd(r, &ret);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_set_fd(SSL *s, int fd)\\r\\n{\\r\\nint ret = 0;\\r\\nBIO *bio = NULL;\\r\\nbio = BIO_new(BIO_s_socket());\\r\\nif (bio == NULL) {\\r\\nSSLerr(SSL_F_SSL_SET_FD, ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_fd(bio, fd, BIO_NOCLOSE);\\r\\nSSL_set_bio(s, bio, bio);\\r\\nret = 1;\\r\\nerr:\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_set_wfd(SSL *s, int fd)\\r\\n{\\r\\nint ret = 0;\\r\\nBIO *bio = NULL;\\r\\nif ((s->rbio == NULL) || (BIO_method_type(s->rbio) != BIO_TYPE_SOCKET)\\r\\n|| ((int)BIO_get_fd(s->rbio, NULL) != fd)) {\\r\\nbio = BIO_new(BIO_s_socket());\\r\\nif (bio == NULL) {\\r\\nSSLerr(SSL_F_SSL_SET_WFD, ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_fd(bio, fd, BIO_NOCLOSE);\\r\\nSSL_set_bio(s, SSL_get_rbio(s), bio);\\r\\n} else\\r\\nSSL_set_bio(s, SSL_get_rbio(s), SSL_get_rbio(s));\\r\\nret = 1;\\r\\nerr:\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_set_rfd(SSL *s, int fd)\\r\\n{\\r\\nint ret = 0;\\r\\nBIO *bio = NULL;\\r\\nif ((s->wbio == NULL) || (BIO_method_type(s->wbio) != BIO_TYPE_SOCKET)\\r\\n|| ((int)BIO_get_fd(s->wbio, NULL) != fd)) {\\r\\nbio = BIO_new(BIO_s_socket());\\r\\nif (bio == NULL) {\\r\\nSSLerr(SSL_F_SSL_SET_RFD, ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_fd(bio, fd, BIO_NOCLOSE);\\r\\nSSL_set_bio(s, bio, SSL_get_wbio(s));\\r\\n} else\\r\\nSSL_set_bio(s, SSL_get_wbio(s), SSL_get_wbio(s));\\r\\nret = 1;\\r\\nerr:\\r\\nreturn (ret);\\r\\n}\\r\\nsize_t SSL_get_finished(const SSL *s, void *buf, size_t count)\\r\\n{\\r\\nsize_t ret = 0;\\r\\nif (s->s3 != NULL) {\\r\\nret = s->s3->tmp.finish_md_len;\\r\\nif (count > ret)\\r\\ncount = ret;\\r\\nmemcpy(buf, s->s3->tmp.finish_md, count);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nsize_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count)\\r\\n{\\r\\nsize_t ret = 0;\\r\\nif (s->s3 != NULL) {\\r\\nret = s->s3->tmp.peer_finish_md_len;\\r\\nif (count > ret)\\r\\ncount = ret;\\r\\nmemcpy(buf, s->s3->tmp.peer_finish_md, count);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint SSL_get_verify_mode(const SSL *s)\\r\\n{\\r\\nreturn (s->verify_mode);\\r\\n}\\r\\nint SSL_get_verify_depth(const SSL *s)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_get_depth(s->param);\\r\\n}\\r\\nint SSL_CTX_get_verify_mode(const SSL_CTX *ctx)\\r\\n{\\r\\nreturn (ctx->verify_mode);\\r\\n}\\r\\nint SSL_CTX_get_verify_depth(const SSL_CTX *ctx)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_get_depth(ctx->param);\\r\\n}\\r\\nvoid SSL_set_verify(SSL *s, int mode,\\r\\nint (*callback) (int ok, X509_STORE_CTX *ctx))\\r\\n{\\r\\ns->verify_mode = mode;\\r\\nif (callback != NULL)\\r\\ns->verify_callback = callback;\\r\\n}\\r\\nvoid SSL_set_verify_depth(SSL *s, int depth)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_depth(s->param, depth);\\r\\n}\\r\\nvoid SSL_set_read_ahead(SSL *s, int yes)\\r\\n{\\r\\ns->read_ahead = yes;\\r\\n}\\r\\nint SSL_get_read_ahead(const SSL *s)\\r\\n{\\r\\nreturn (s->read_ahead);\\r\\n}\\r\\nint SSL_pending(const SSL *s)\\r\\n{\\r\\nreturn (s->method->ssl_pending(s));\\r\\n}\\r\\nX509 *SSL_get_peer_certificate(const SSL *s)\\r\\n{\\r\\nX509 *r;\\r\\nif ((s == NULL) || (s->session == NULL))\\r\\nr = NULL;\\r\\nelse\\r\\nr = s->session->peer;\\r\\nif (r == NULL)\\r\\nreturn (r);\\r\\nCRYPTO_add(&r->references, 1, CRYPTO_LOCK_X509);\\r\\nreturn (r);\\r\\n}\\r\\nint SSL_CTX_check_private_key(const SSL_CTX *ctx)\\r\\n{\\r\\nif ((ctx == NULL) ||\\r\\n(ctx->cert == NULL) || (ctx->cert->key->x509 == NULL)) {\\r\\nSSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,\\r\\nSSL_R_NO_CERTIFICATE_ASSIGNED);\\r\\nreturn (0);\\r\\n}\\r\\nif (ctx->cert->key->privatekey == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_CHECK_PRIVATE_KEY,\\r\\nSSL_R_NO_PRIVATE_KEY_ASSIGNED);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (X509_check_private_key\\r\\n(ctx->cert->key->x509, ctx->cert->key->privatekey));\\r\\n}\\r\\nint SSL_check_private_key(const SSL *ssl)\\r\\n{\\r\\nif (ssl == NULL) {\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (ssl->cert == NULL) {\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY, SSL_R_NO_CERTIFICATE_ASSIGNED);\\r\\nreturn 0;\\r\\n}\\r\\nif (ssl->cert->key->x509 == NULL) {\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY, SSL_R_NO_CERTIFICATE_ASSIGNED);\\r\\nreturn (0);\\r\\n}\\r\\nif (ssl->cert->key->privatekey == NULL) {\\r\\nSSLerr(SSL_F_SSL_CHECK_PRIVATE_KEY, SSL_R_NO_PRIVATE_KEY_ASSIGNED);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (X509_check_private_key(ssl->cert->key->x509,\\r\\nssl->cert->key->privatekey));\\r\\n}\\r\\nint SSL_accept(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\nSSL_set_accept_state(s);\\r\\nreturn (s->method->ssl_accept(s));\\r\\n}\\r\\nint SSL_connect(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == 0)\\r\\nSSL_set_connect_state(s);\\r\\nreturn (s->method->ssl_connect(s));\\r\\n}\\r\\nlong SSL_get_default_timeout(const SSL *s)\\r\\n{\\r\\nreturn (s->method->get_timeout());\\r\\n}\\r\\nint SSL_read(SSL *s, void *buf, int num)\\r\\n{\\r\\nif (s->handshake_func == 0) {\\r\\nSSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\\r\\ns->rwstate = SSL_NOTHING;\\r\\nreturn (0);\\r\\n}\\r\\nreturn (s->method->ssl_read(s, buf, num));\\r\\n}\\r\\nint SSL_peek(SSL *s, void *buf, int num)\\r\\n{\\r\\nif (s->handshake_func == 0) {\\r\\nSSLerr(SSL_F_SSL_PEEK, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (s->shutdown & SSL_RECEIVED_SHUTDOWN) {\\r\\nreturn (0);\\r\\n}\\r\\nreturn (s->method->ssl_peek(s, buf, num));\\r\\n}\\r\\nint SSL_write(SSL *s, const void *buf, int num)\\r\\n{\\r\\nif (s->handshake_func == 0) {\\r\\nSSLerr(SSL_F_SSL_WRITE, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif (s->shutdown & SSL_SENT_SHUTDOWN) {\\r\\ns->rwstate = SSL_NOTHING;\\r\\nSSLerr(SSL_F_SSL_WRITE, SSL_R_PROTOCOL_IS_SHUTDOWN);\\r\\nreturn (-1);\\r\\n}\\r\\nreturn (s->method->ssl_write(s, buf, num));\\r\\n}\\r\\nint SSL_shutdown(SSL *s)\\r\\n{\\r\\nif (s->handshake_func == 0) {\\r\\nSSLerr(SSL_F_SSL_SHUTDOWN, SSL_R_UNINITIALIZED);\\r\\nreturn -1;\\r\\n}\\r\\nif ((s != NULL) && !SSL_in_init(s))\\r\\nreturn (s->method->ssl_shutdown(s));\\r\\nelse\\r\\nreturn (1);\\r\\n}\\r\\nint SSL_renegotiate(SSL *s)\\r\\n{\\r\\nif (s->renegotiate == 0)\\r\\ns->renegotiate = 1;\\r\\ns->new_session = 1;\\r\\nreturn (s->method->ssl_renegotiate(s));\\r\\n}\\r\\nint SSL_renegotiate_abbreviated(SSL *s)\\r\\n{\\r\\nif (s->renegotiate == 0)\\r\\ns->renegotiate = 1;\\r\\ns->new_session = 0;\\r\\nreturn (s->method->ssl_renegotiate(s));\\r\\n}\\r\\nint SSL_renegotiate_pending(SSL *s)\\r\\n{\\r\\nreturn (s->renegotiate != 0);\\r\\n}\\r\\nlong SSL_ctrl(SSL *s, int cmd, long larg, void *parg)\\r\\n{\\r\\nlong l;\\r\\nswitch (cmd) {\\r\\ncase SSL_CTRL_GET_READ_AHEAD:\\r\\nreturn (s->read_ahead);\\r\\ncase SSL_CTRL_SET_READ_AHEAD:\\r\\nl = s->read_ahead;\\r\\ns->read_ahead = larg;\\r\\nreturn (l);\\r\\ncase SSL_CTRL_SET_MSG_CALLBACK_ARG:\\r\\ns->msg_callback_arg = parg;\\r\\nreturn 1;\\r\\ncase SSL_CTRL_OPTIONS:\\r\\nreturn (s->options |= larg);\\r\\ncase SSL_CTRL_CLEAR_OPTIONS:\\r\\nreturn (s->options &= ~larg);\\r\\ncase SSL_CTRL_MODE:\\r\\nreturn (s->mode |= larg);\\r\\ncase SSL_CTRL_CLEAR_MODE:\\r\\nreturn (s->mode &= ~larg);\\r\\ncase SSL_CTRL_GET_MAX_CERT_LIST:\\r\\nreturn (s->max_cert_list);\\r\\ncase SSL_CTRL_SET_MAX_CERT_LIST:\\r\\nl = s->max_cert_list;\\r\\ns->max_cert_list = larg;\\r\\nreturn (l);\\r\\ncase SSL_CTRL_SET_MAX_SEND_FRAGMENT:\\r\\nif (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)\\r\\nreturn 0;\\r\\ns->max_send_fragment = larg;\\r\\nreturn 1;\\r\\ncase SSL_CTRL_GET_RI_SUPPORT:\\r\\nif (s->s3)\\r\\nreturn s->s3->send_connection_binding;\\r\\nelse\\r\\nreturn 0;\\r\\ncase SSL_CTRL_CERT_FLAGS:\\r\\nreturn (s->cert->cert_flags |= larg);\\r\\ncase SSL_CTRL_CLEAR_CERT_FLAGS:\\r\\nreturn (s->cert->cert_flags &= ~larg);\\r\\ncase SSL_CTRL_GET_RAW_CIPHERLIST:\\r\\nif (parg) {\\r\\nif (s->cert->ciphers_raw == NULL)\\r\\nreturn 0;\\r\\n*(unsigned char **)parg = s->cert->ciphers_raw;\\r\\nreturn (int)s->cert->ciphers_rawlen;\\r\\n} else\\r\\nreturn ssl_put_cipher_by_char(s, NULL, NULL);\\r\\ndefault:\\r\\nreturn (s->method->ssl_ctrl(s, cmd, larg, parg));\\r\\n}\\r\\n}\\r\\nlong SSL_callback_ctrl(SSL *s, int cmd, void (*fp) (void))\\r\\n{\\r\\nswitch (cmd) {\\r\\ncase SSL_CTRL_SET_MSG_CALLBACK:\\r\\ns->msg_callback = (void (*)\\r\\n(int write_p, int version, int content_type,\\r\\nconst void *buf, size_t len, SSL *ssl,\\r\\nvoid *arg))(fp);\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn (s->method->ssl_callback_ctrl(s, cmd, fp));\\r\\n}\\r\\n}\\r\\nlong SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg)\\r\\n{\\r\\nlong l;\\r\\nif (ctx == NULL) {\\r\\nswitch (cmd) {\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase SSL_CTRL_SET_CURVES_LIST:\\r\\nreturn tls1_set_curves_list(NULL, NULL, parg);\\r\\n#endif\\r\\ncase SSL_CTRL_SET_SIGALGS_LIST:\\r\\ncase SSL_CTRL_SET_CLIENT_SIGALGS_LIST:\\r\\nreturn tls1_set_sigalgs_list(NULL, parg, 0);\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nswitch (cmd) {\\r\\ncase SSL_CTRL_GET_READ_AHEAD:\\r\\nreturn (ctx->read_ahead);\\r\\ncase SSL_CTRL_SET_READ_AHEAD:\\r\\nl = ctx->read_ahead;\\r\\nctx->read_ahead = larg;\\r\\nreturn (l);\\r\\ncase SSL_CTRL_SET_MSG_CALLBACK_ARG:\\r\\nctx->msg_callback_arg = parg;\\r\\nreturn 1;\\r\\ncase SSL_CTRL_GET_MAX_CERT_LIST:\\r\\nreturn (ctx->max_cert_list);\\r\\ncase SSL_CTRL_SET_MAX_CERT_LIST:\\r\\nl = ctx->max_cert_list;\\r\\nctx->max_cert_list = larg;\\r\\nreturn (l);\\r\\ncase SSL_CTRL_SET_SESS_CACHE_SIZE:\\r\\nl = ctx->session_cache_size;\\r\\nctx->session_cache_size = larg;\\r\\nreturn (l);\\r\\ncase SSL_CTRL_GET_SESS_CACHE_SIZE:\\r\\nreturn (ctx->session_cache_size);\\r\\ncase SSL_CTRL_SET_SESS_CACHE_MODE:\\r\\nl = ctx->session_cache_mode;\\r\\nctx->session_cache_mode = larg;\\r\\nreturn (l);\\r\\ncase SSL_CTRL_GET_SESS_CACHE_MODE:\\r\\nreturn (ctx->session_cache_mode);\\r\\ncase SSL_CTRL_SESS_NUMBER:\\r\\nreturn (lh_SSL_SESSION_num_items(ctx->sessions));\\r\\ncase SSL_CTRL_SESS_CONNECT:\\r\\nreturn (ctx->stats.sess_connect);\\r\\ncase SSL_CTRL_SESS_CONNECT_GOOD:\\r\\nreturn (ctx->stats.sess_connect_good);\\r\\ncase SSL_CTRL_SESS_CONNECT_RENEGOTIATE:\\r\\nreturn (ctx->stats.sess_connect_renegotiate);\\r\\ncase SSL_CTRL_SESS_ACCEPT:\\r\\nreturn (ctx->stats.sess_accept);\\r\\ncase SSL_CTRL_SESS_ACCEPT_GOOD:\\r\\nreturn (ctx->stats.sess_accept_good);\\r\\ncase SSL_CTRL_SESS_ACCEPT_RENEGOTIATE:\\r\\nreturn (ctx->stats.sess_accept_renegotiate);\\r\\ncase SSL_CTRL_SESS_HIT:\\r\\nreturn (ctx->stats.sess_hit);\\r\\ncase SSL_CTRL_SESS_CB_HIT:\\r\\nreturn (ctx->stats.sess_cb_hit);\\r\\ncase SSL_CTRL_SESS_MISSES:\\r\\nreturn (ctx->stats.sess_miss);\\r\\ncase SSL_CTRL_SESS_TIMEOUTS:\\r\\nreturn (ctx->stats.sess_timeout);\\r\\ncase SSL_CTRL_SESS_CACHE_FULL:\\r\\nreturn (ctx->stats.sess_cache_full);\\r\\ncase SSL_CTRL_OPTIONS:\\r\\nreturn (ctx->options |= larg);\\r\\ncase SSL_CTRL_CLEAR_OPTIONS:\\r\\nreturn (ctx->options &= ~larg);\\r\\ncase SSL_CTRL_MODE:\\r\\nreturn (ctx->mode |= larg);\\r\\ncase SSL_CTRL_CLEAR_MODE:\\r\\nreturn (ctx->mode &= ~larg);\\r\\ncase SSL_CTRL_SET_MAX_SEND_FRAGMENT:\\r\\nif (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)\\r\\nreturn 0;\\r\\nctx->max_send_fragment = larg;\\r\\nreturn 1;\\r\\ncase SSL_CTRL_CERT_FLAGS:\\r\\nreturn (ctx->cert->cert_flags |= larg);\\r\\ncase SSL_CTRL_CLEAR_CERT_FLAGS:\\r\\nreturn (ctx->cert->cert_flags &= ~larg);\\r\\ndefault:\\r\\nreturn (ctx->method->ssl_ctx_ctrl(ctx, cmd, larg, parg));\\r\\n}\\r\\n}\\r\\nlong SSL_CTX_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp) (void))\\r\\n{\\r\\nswitch (cmd) {\\r\\ncase SSL_CTRL_SET_MSG_CALLBACK:\\r\\nctx->msg_callback = (void (*)\\r\\n(int write_p, int version, int content_type,\\r\\nconst void *buf, size_t len, SSL *ssl,\\r\\nvoid *arg))(fp);\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn (ctx->method->ssl_ctx_callback_ctrl(ctx, cmd, fp));\\r\\n}\\r\\n}\\r\\nint ssl_cipher_id_cmp(const SSL_CIPHER *a, const SSL_CIPHER *b)\\r\\n{\\r\\nlong l;\\r\\nl = a->id - b->id;\\r\\nif (l == 0L)\\r\\nreturn (0);\\r\\nelse\\r\\nreturn ((l > 0) ? 1 : -1);\\r\\n}\\r\\nint ssl_cipher_ptr_id_cmp(const SSL_CIPHER *const *ap,\\r\\nconst SSL_CIPHER *const *bp)\\r\\n{\\r\\nlong l;\\r\\nl = (*ap)->id - (*bp)->id;\\r\\nif (l == 0L)\\r\\nreturn (0);\\r\\nelse\\r\\nreturn ((l > 0) ? 1 : -1);\\r\\n}\\r\\nchar *SSL_get_cipher_list(const SSL *s, int n)\\r\\n{\\r\\nSSL_CIPHER *c;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nif (s == NULL)\\r\\nreturn (NULL);\\r\\nsk = SSL_get_ciphers(s);\\r\\nif ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))\\r\\nreturn (NULL);\\r\\nc = sk_SSL_CIPHER_value(sk, n);\\r\\nif (c == NULL)\\r\\nreturn (NULL);\\r\\nreturn (c->name);\\r\\n}\\r\\nint SSL_CTX_set_cipher_list(SSL_CTX *ctx, const char *str)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nsk = ssl_create_cipher_list(ctx->method, &ctx->cipher_list,\\r\\n&ctx->cipher_list_by_id, str, ctx->cert);\\r\\nif (sk == NULL)\\r\\nreturn 0;\\r\\nelse if (sk_SSL_CIPHER_num(sk) == 0) {\\r\\nSSLerr(SSL_F_SSL_CTX_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_set_cipher_list(SSL *s, const char *str)\\r\\n{\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nsk = ssl_create_cipher_list(s->ctx->method, &s->cipher_list,\\r\\n&s->cipher_list_by_id, str, s->cert);\\r\\nif (sk == NULL)\\r\\nreturn 0;\\r\\nelse if (sk_SSL_CIPHER_num(sk) == 0) {\\r\\nSSLerr(SSL_F_SSL_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nchar *SSL_get_shared_ciphers(const SSL *s, char *buf, int len)\\r\\n{\\r\\nchar *p;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nSSL_CIPHER *c;\\r\\nint i;\\r\\nif ((s->session == NULL) || (s->session->ciphers == NULL) || (len < 2))\\r\\nreturn (NULL);\\r\\np = buf;\\r\\nsk = s->session->ciphers;\\r\\nif (sk_SSL_CIPHER_num(sk) == 0)\\r\\nreturn NULL;\\r\\nfor (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {\\r\\nint n;\\r\\nc = sk_SSL_CIPHER_value(sk, i);\\r\\nn = strlen(c->name);\\r\\nif (n + 1 > len) {\\r\\nif (p != buf)\\r\\n--p;\\r\\n*p = '\\0';\\r\\nreturn buf;\\r\\n}\\r\\nstrcpy(p, c->name);\\r\\np += n;\\r\\n*(p++) = ':';\\r\\nlen -= n + 1;\\r\\n}\\r\\np[-1] = '\\0';\\r\\nreturn (buf);\\r\\n}\\r\\nchar *SSL_get_servername(const SSL *s, const int type)\\r\\n{\\r\\nif (type != TLSEXT_NAMETYPE_host_name)\\r\\nreturn NULL;\\r\\nreturn s->session && !s->tlsext_hostname ?\\r\\ns->session->tlsext_hostname : s->tlsext_hostname;\\r\\n}\\r\\nint SSL_get_servername_type(const SSL *s)\\r\\n{\\r\\nif (s->session\\r\\n&& (!s->tlsext_hostname ? s->session->\\r\\ntlsext_hostname : s->tlsext_hostname))\\r\\nreturn TLSEXT_NAMETYPE_host_name;\\r\\nreturn -1;\\r\\n}\\r\\nint SSL_select_next_proto(unsigned char **out, unsigned char *outlen,\\r\\nconst unsigned char *server,\\r\\nunsigned int server_len,\\r\\nconst unsigned char *client,\\r\\nunsigned int client_len)\\r\\n{\\r\\nunsigned int i, j;\\r\\nconst unsigned char *result;\\r\\nint status = OPENSSL_NPN_UNSUPPORTED;\\r\\nfor (i = 0; i < server_len;) {\\r\\nfor (j = 0; j < client_len;) {\\r\\nif (server[i] == client[j] &&\\r\\nmemcmp(&server[i + 1], &client[j + 1], server[i]) == 0) {\\r\\nresult = &server[i];\\r\\nstatus = OPENSSL_NPN_NEGOTIATED;\\r\\ngoto found;\\r\\n}\\r\\nj += client[j];\\r\\nj++;\\r\\n}\\r\\ni += server[i];\\r\\ni++;\\r\\n}\\r\\nresult = client;\\r\\nstatus = OPENSSL_NPN_NO_OVERLAP;\\r\\nfound:\\r\\n*out = (unsigned char *)result + 1;\\r\\n*outlen = result[0];\\r\\nreturn status;\\r\\n}\\r\\nvoid SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data,\\r\\nunsigned *len)\\r\\n{\\r\\n*data = s->next_proto_negotiated;\\r\\nif (!*data) {\\r\\n*len = 0;\\r\\n} else {\\r\\n*len = s->next_proto_negotiated_len;\\r\\n}\\r\\n}\\r\\nvoid SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *ctx,\\r\\nint (*cb) (SSL *ssl,\\r\\nconst unsigned char\\r\\n**out,\\r\\nunsigned int *outlen,\\r\\nvoid *arg), void *arg)\\r\\n{\\r\\nctx->next_protos_advertised_cb = cb;\\r\\nctx->next_protos_advertised_cb_arg = arg;\\r\\n}\\r\\nvoid SSL_CTX_set_next_proto_select_cb(SSL_CTX *ctx,\\r\\nint (*cb) (SSL *s, unsigned char **out,\\r\\nunsigned char *outlen,\\r\\nconst unsigned char *in,\\r\\nunsigned int inlen,\\r\\nvoid *arg), void *arg)\\r\\n{\\r\\nctx->next_proto_select_cb = cb;\\r\\nctx->next_proto_select_cb_arg = arg;\\r\\n}\\r\\nint SSL_CTX_set_alpn_protos(SSL_CTX *ctx, const unsigned char *protos,\\r\\nunsigned protos_len)\\r\\n{\\r\\nif (ctx->alpn_client_proto_list)\\r\\nOPENSSL_free(ctx->alpn_client_proto_list);\\r\\nctx->alpn_client_proto_list = OPENSSL_malloc(protos_len);\\r\\nif (!ctx->alpn_client_proto_list)\\r\\nreturn 1;\\r\\nmemcpy(ctx->alpn_client_proto_list, protos, protos_len);\\r\\nctx->alpn_client_proto_list_len = protos_len;\\r\\nreturn 0;\\r\\n}\\r\\nint SSL_set_alpn_protos(SSL *ssl, const unsigned char *protos,\\r\\nunsigned protos_len)\\r\\n{\\r\\nif (ssl->alpn_client_proto_list)\\r\\nOPENSSL_free(ssl->alpn_client_proto_list);\\r\\nssl->alpn_client_proto_list = OPENSSL_malloc(protos_len);\\r\\nif (!ssl->alpn_client_proto_list)\\r\\nreturn 1;\\r\\nmemcpy(ssl->alpn_client_proto_list, protos, protos_len);\\r\\nssl->alpn_client_proto_list_len = protos_len;\\r\\nreturn 0;\\r\\n}\\r\\nvoid SSL_CTX_set_alpn_select_cb(SSL_CTX *ctx,\\r\\nint (*cb) (SSL *ssl,\\r\\nconst unsigned char **out,\\r\\nunsigned char *outlen,\\r\\nconst unsigned char *in,\\r\\nunsigned int inlen,\\r\\nvoid *arg), void *arg)\\r\\n{\\r\\nctx->alpn_select_cb = cb;\\r\\nctx->alpn_select_cb_arg = arg;\\r\\n}\\r\\nvoid SSL_get0_alpn_selected(const SSL *ssl, const unsigned char **data,\\r\\nunsigned *len)\\r\\n{\\r\\n*data = NULL;\\r\\nif (ssl->s3)\\r\\n*data = ssl->s3->alpn_selected;\\r\\nif (*data == NULL)\\r\\n*len = 0;\\r\\nelse\\r\\n*len = ssl->s3->alpn_selected_len;\\r\\n}\\r\\nint SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,\\r\\nconst char *label, size_t llen,\\r\\nconst unsigned char *p, size_t plen,\\r\\nint use_context)\\r\\n{\\r\\nif (s->version < TLS1_VERSION)\\r\\nreturn -1;\\r\\nreturn s->method->ssl3_enc->export_keying_material(s, out, olen, label,\\r\\nllen, p, plen,\\r\\nuse_context);\\r\\n}\\r\\nstatic unsigned long ssl_session_hash(const SSL_SESSION *a)\\r\\n{\\r\\nunsigned long l;\\r\\nl = (unsigned long)\\r\\n((unsigned int)a->session_id[0]) |\\r\\n((unsigned int)a->session_id[1] << 8L) |\\r\\n((unsigned long)a->session_id[2] << 16L) |\\r\\n((unsigned long)a->session_id[3] << 24L);\\r\\nreturn (l);\\r\\n}\\r\\nstatic int ssl_session_cmp(const SSL_SESSION *a, const SSL_SESSION *b)\\r\\n{\\r\\nif (a->ssl_version != b->ssl_version)\\r\\nreturn (1);\\r\\nif (a->session_id_length != b->session_id_length)\\r\\nreturn (1);\\r\\nreturn (memcmp(a->session_id, b->session_id, a->session_id_length));\\r\\n}\\r\\nvoid ssl_buf_freelist_free(SSL3_BUF_FREELIST *list)\\r\\n{\\r\\nSSL3_BUF_FREELIST_ENTRY *ent, *next;\\r\\nfor (ent = list->head; ent; ent = next) {\\r\\nnext = ent->next;\\r\\nOPENSSL_free(ent);\\r\\n}\\r\\nOPENSSL_free(list);\\r\\n}\\r\\nvoid SSL_CTX_free(SSL_CTX *a)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&a->references, -1, CRYPTO_LOCK_SSL_CTX);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SSL_CTX\", a);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"SSL_CTX_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (a->param)\\r\\nX509_VERIFY_PARAM_free(a->param);\\r\\nif (a->sessions != NULL)\\r\\nSSL_CTX_flush_sessions(a, 0);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_CTX, a, &a->ex_data);\\r\\nif (a->sessions != NULL)\\r\\nlh_SSL_SESSION_free(a->sessions);\\r\\nif (a->cert_store != NULL)\\r\\nX509_STORE_free(a->cert_store);\\r\\nif (a->cipher_list != NULL)\\r\\nsk_SSL_CIPHER_free(a->cipher_list);\\r\\nif (a->cipher_list_by_id != NULL)\\r\\nsk_SSL_CIPHER_free(a->cipher_list_by_id);\\r\\nif (a->cert != NULL)\\r\\nssl_cert_free(a->cert);\\r\\nif (a->client_CA != NULL)\\r\\nsk_X509_NAME_pop_free(a->client_CA, X509_NAME_free);\\r\\nif (a->extra_certs != NULL)\\r\\nsk_X509_pop_free(a->extra_certs, X509_free);\\r\\n#if 0\\r\\nif (a->comp_methods != NULL)\\r\\nsk_SSL_COMP_pop_free(a->comp_methods, SSL_COMP_free);\\r\\n#else\\r\\na->comp_methods = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRTP\\r\\nif (a->srtp_profiles)\\r\\nsk_SRTP_PROTECTION_PROFILE_free(a->srtp_profiles);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nif (a->psk_identity_hint)\\r\\nOPENSSL_free(a->psk_identity_hint);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nSSL_CTX_SRP_CTX_free(a);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (a->client_cert_engine)\\r\\nENGINE_finish(a->client_cert_engine);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_BUF_FREELISTS\\r\\nif (a->wbuf_freelist)\\r\\nssl_buf_freelist_free(a->wbuf_freelist);\\r\\nif (a->rbuf_freelist)\\r\\nssl_buf_freelist_free(a->rbuf_freelist);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\n# ifndef OPENSSL_NO_EC\\r\\nif (a->tlsext_ecpointformatlist)\\r\\nOPENSSL_free(a->tlsext_ecpointformatlist);\\r\\nif (a->tlsext_ellipticcurvelist)\\r\\nOPENSSL_free(a->tlsext_ellipticcurvelist);\\r\\n# endif\\r\\nif (a->alpn_client_proto_list != NULL)\\r\\nOPENSSL_free(a->alpn_client_proto_list);\\r\\n#endif\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nvoid SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb)\\r\\n{\\r\\nctx->default_passwd_callback = cb;\\r\\n}\\r\\nvoid SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u)\\r\\n{\\r\\nctx->default_passwd_callback_userdata = u;\\r\\n}\\r\\nvoid SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx,\\r\\nint (*cb) (X509_STORE_CTX *, void *),\\r\\nvoid *arg)\\r\\n{\\r\\nctx->app_verify_callback = cb;\\r\\nctx->app_verify_arg = arg;\\r\\n}\\r\\nvoid SSL_CTX_set_verify(SSL_CTX *ctx, int mode,\\r\\nint (*cb) (int, X509_STORE_CTX *))\\r\\n{\\r\\nctx->verify_mode = mode;\\r\\nctx->default_verify_callback = cb;\\r\\n}\\r\\nvoid SSL_CTX_set_verify_depth(SSL_CTX *ctx, int depth)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_depth(ctx->param, depth);\\r\\n}\\r\\nvoid SSL_CTX_set_cert_cb(SSL_CTX *c, int (*cb) (SSL *ssl, void *arg),\\r\\nvoid *arg)\\r\\n{\\r\\nssl_cert_set_cert_cb(c->cert, cb, arg);\\r\\n}\\r\\nvoid SSL_set_cert_cb(SSL *s, int (*cb) (SSL *ssl, void *arg), void *arg)\\r\\n{\\r\\nssl_cert_set_cert_cb(s->cert, cb, arg);\\r\\n}\\r\\nvoid ssl_set_cert_masks(CERT *c, const SSL_CIPHER *cipher)\\r\\n{\\r\\nCERT_PKEY *cpk;\\r\\nint rsa_enc, rsa_tmp, rsa_sign, dh_tmp, dh_rsa, dh_dsa, dsa_sign;\\r\\nint rsa_enc_export, dh_rsa_export, dh_dsa_export;\\r\\nint rsa_tmp_export, dh_tmp_export, kl;\\r\\nunsigned long mask_k, mask_a, emask_k, emask_a;\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nint have_ecc_cert, ecdsa_ok, ecc_pkey_size;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nint have_ecdh_tmp, ecdh_ok;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nX509 *x = NULL;\\r\\nEVP_PKEY *ecc_pkey = NULL;\\r\\nint signature_nid = 0, pk_nid = 0, md_nid = 0;\\r\\n#endif\\r\\nif (c == NULL)\\r\\nreturn;\\r\\nkl = SSL_C_EXPORT_PKEYLENGTH(cipher);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nrsa_tmp = (c->rsa_tmp != NULL || c->rsa_tmp_cb != NULL);\\r\\nrsa_tmp_export = (c->rsa_tmp_cb != NULL ||\\r\\n(rsa_tmp && RSA_size(c->rsa_tmp) * 8 <= kl));\\r\\n#else\\r\\nrsa_tmp = rsa_tmp_export = 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\ndh_tmp = (c->dh_tmp != NULL || c->dh_tmp_cb != NULL);\\r\\ndh_tmp_export = (c->dh_tmp_cb != NULL ||\\r\\n(dh_tmp && DH_size(c->dh_tmp) * 8 <= kl));\\r\\n#else\\r\\ndh_tmp = dh_tmp_export = 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nhave_ecdh_tmp = (c->ecdh_tmp || c->ecdh_tmp_cb || c->ecdh_tmp_auto);\\r\\n#endif\\r\\ncpk = &(c->pkeys[SSL_PKEY_RSA_ENC]);\\r\\nrsa_enc = cpk->valid_flags & CERT_PKEY_VALID;\\r\\nrsa_enc_export = (rsa_enc && EVP_PKEY_size(cpk->privatekey) * 8 <= kl);\\r\\ncpk = &(c->pkeys[SSL_PKEY_RSA_SIGN]);\\r\\nrsa_sign = cpk->valid_flags & CERT_PKEY_SIGN;\\r\\ncpk = &(c->pkeys[SSL_PKEY_DSA_SIGN]);\\r\\ndsa_sign = cpk->valid_flags & CERT_PKEY_SIGN;\\r\\ncpk = &(c->pkeys[SSL_PKEY_DH_RSA]);\\r\\ndh_rsa = cpk->valid_flags & CERT_PKEY_VALID;\\r\\ndh_rsa_export = (dh_rsa && EVP_PKEY_size(cpk->privatekey) * 8 <= kl);\\r\\ncpk = &(c->pkeys[SSL_PKEY_DH_DSA]);\\r\\ndh_dsa = cpk->valid_flags & CERT_PKEY_VALID;\\r\\ndh_dsa_export = (dh_dsa && EVP_PKEY_size(cpk->privatekey) * 8 <= kl);\\r\\ncpk = &(c->pkeys[SSL_PKEY_ECC]);\\r\\n#ifndef OPENSSL_NO_EC\\r\\nhave_ecc_cert = cpk->valid_flags & CERT_PKEY_VALID;\\r\\n#endif\\r\\nmask_k = 0;\\r\\nmask_a = 0;\\r\\nemask_k = 0;\\r\\nemask_a = 0;\\r\\n#ifdef CIPHER_DEBUG\\r\\nfprintf(stderr,\\r\\n\"rt=%d rte=%d dht=%d ecdht=%d re=%d ree=%d rs=%d ds=%d dhr=%d dhd=%d\\n\",\\r\\nrsa_tmp, rsa_tmp_export, dh_tmp, have_ecdh_tmp, rsa_enc,\\r\\nrsa_enc_export, rsa_sign, dsa_sign, dh_rsa, dh_dsa);\\r\\n#endif\\r\\ncpk = &(c->pkeys[SSL_PKEY_GOST01]);\\r\\nif (cpk->x509 != NULL && cpk->privatekey != NULL) {\\r\\nmask_k |= SSL_kGOST;\\r\\nmask_a |= SSL_aGOST01;\\r\\n}\\r\\ncpk = &(c->pkeys[SSL_PKEY_GOST94]);\\r\\nif (cpk->x509 != NULL && cpk->privatekey != NULL) {\\r\\nmask_k |= SSL_kGOST;\\r\\nmask_a |= SSL_aGOST94;\\r\\n}\\r\\nif (rsa_enc || (rsa_tmp && rsa_sign))\\r\\nmask_k |= SSL_kRSA;\\r\\nif (rsa_enc_export || (rsa_tmp_export && (rsa_sign || rsa_enc)))\\r\\nemask_k |= SSL_kRSA;\\r\\n#if 0\\r\\nif ((dh_tmp || dh_rsa || dh_dsa) && (rsa_enc || rsa_sign || dsa_sign))\\r\\nmask_k |= SSL_kEDH;\\r\\nif ((dh_tmp_export || dh_rsa_export || dh_dsa_export) &&\\r\\n(rsa_enc || rsa_sign || dsa_sign))\\r\\nemask_k |= SSL_kEDH;\\r\\n#endif\\r\\nif (dh_tmp_export)\\r\\nemask_k |= SSL_kEDH;\\r\\nif (dh_tmp)\\r\\nmask_k |= SSL_kEDH;\\r\\nif (dh_rsa)\\r\\nmask_k |= SSL_kDHr;\\r\\nif (dh_rsa_export)\\r\\nemask_k |= SSL_kDHr;\\r\\nif (dh_dsa)\\r\\nmask_k |= SSL_kDHd;\\r\\nif (dh_dsa_export)\\r\\nemask_k |= SSL_kDHd;\\r\\nif (emask_k & (SSL_kDHr | SSL_kDHd))\\r\\nmask_a |= SSL_aDH;\\r\\nif (rsa_enc || rsa_sign) {\\r\\nmask_a |= SSL_aRSA;\\r\\nemask_a |= SSL_aRSA;\\r\\n}\\r\\nif (dsa_sign) {\\r\\nmask_a |= SSL_aDSS;\\r\\nemask_a |= SSL_aDSS;\\r\\n}\\r\\nmask_a |= SSL_aNULL;\\r\\nemask_a |= SSL_aNULL;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nmask_k |= SSL_kKRB5;\\r\\nmask_a |= SSL_aKRB5;\\r\\nemask_k |= SSL_kKRB5;\\r\\nemask_a |= SSL_aKRB5;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (have_ecc_cert) {\\r\\ncpk = &c->pkeys[SSL_PKEY_ECC];\\r\\nx = cpk->x509;\\r\\nX509_check_purpose(x, -1, 0);\\r\\n# ifndef OPENSSL_NO_ECDH\\r\\necdh_ok = (x->ex_flags & EXFLAG_KUSAGE) ?\\r\\n(x->ex_kusage & X509v3_KU_KEY_AGREEMENT) : 1;\\r\\n# endif\\r\\necdsa_ok = (x->ex_flags & EXFLAG_KUSAGE) ?\\r\\n(x->ex_kusage & X509v3_KU_DIGITAL_SIGNATURE) : 1;\\r\\nif (!(cpk->valid_flags & CERT_PKEY_SIGN))\\r\\necdsa_ok = 0;\\r\\necc_pkey = X509_get_pubkey(x);\\r\\necc_pkey_size = (ecc_pkey != NULL) ? EVP_PKEY_bits(ecc_pkey) : 0;\\r\\nEVP_PKEY_free(ecc_pkey);\\r\\nif ((x->sig_alg) && (x->sig_alg->algorithm)) {\\r\\nsignature_nid = OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nOBJ_find_sigid_algs(signature_nid, &md_nid, &pk_nid);\\r\\n}\\r\\n# ifndef OPENSSL_NO_ECDH\\r\\nif (ecdh_ok) {\\r\\nif (pk_nid == NID_rsaEncryption || pk_nid == NID_rsa) {\\r\\nmask_k |= SSL_kECDHr;\\r\\nmask_a |= SSL_aECDH;\\r\\nif (ecc_pkey_size <= 163) {\\r\\nemask_k |= SSL_kECDHr;\\r\\nemask_a |= SSL_aECDH;\\r\\n}\\r\\n}\\r\\nif (pk_nid == NID_X9_62_id_ecPublicKey) {\\r\\nmask_k |= SSL_kECDHe;\\r\\nmask_a |= SSL_aECDH;\\r\\nif (ecc_pkey_size <= 163) {\\r\\nemask_k |= SSL_kECDHe;\\r\\nemask_a |= SSL_aECDH;\\r\\n}\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ECDSA\\r\\nif (ecdsa_ok) {\\r\\nmask_a |= SSL_aECDSA;\\r\\nemask_a |= SSL_aECDSA;\\r\\n}\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (have_ecdh_tmp) {\\r\\nmask_k |= SSL_kEECDH;\\r\\nemask_k |= SSL_kEECDH;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nmask_k |= SSL_kPSK;\\r\\nmask_a |= SSL_aPSK;\\r\\nemask_k |= SSL_kPSK;\\r\\nemask_a |= SSL_aPSK;\\r\\n#endif\\r\\nc->mask_k = mask_k;\\r\\nc->mask_a = mask_a;\\r\\nc->export_mask_k = emask_k;\\r\\nc->export_mask_a = emask_a;\\r\\nc->valid = 1;\\r\\n}\\r\\nint ssl_check_srvr_ecc_cert_and_alg(X509 *x, SSL *s)\\r\\n{\\r\\nunsigned long alg_k, alg_a;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nint keysize = 0;\\r\\nint signature_nid = 0, md_nid = 0, pk_nid = 0;\\r\\nconst SSL_CIPHER *cs = s->s3->tmp.new_cipher;\\r\\nalg_k = cs->algorithm_mkey;\\r\\nalg_a = cs->algorithm_auth;\\r\\nif (SSL_C_IS_EXPORT(cs)) {\\r\\npkey = X509_get_pubkey(x);\\r\\nif (pkey == NULL)\\r\\nreturn 0;\\r\\nkeysize = EVP_PKEY_bits(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (keysize > 163)\\r\\nreturn 0;\\r\\n}\\r\\nX509_check_purpose(x, -1, 0);\\r\\nif ((x->sig_alg) && (x->sig_alg->algorithm)) {\\r\\nsignature_nid = OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nOBJ_find_sigid_algs(signature_nid, &md_nid, &pk_nid);\\r\\n}\\r\\nif (alg_k & SSL_kECDHe || alg_k & SSL_kECDHr) {\\r\\nif (ku_reject(x, X509v3_KU_KEY_AGREEMENT)) {\\r\\nSSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG,\\r\\nSSL_R_ECC_CERT_NOT_FOR_KEY_AGREEMENT);\\r\\nreturn 0;\\r\\n}\\r\\nif ((alg_k & SSL_kECDHe) && TLS1_get_version(s) < TLS1_2_VERSION) {\\r\\nif (pk_nid != NID_X9_62_id_ecPublicKey) {\\r\\nSSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG,\\r\\nSSL_R_ECC_CERT_SHOULD_HAVE_SHA1_SIGNATURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif ((alg_k & SSL_kECDHr) && TLS1_get_version(s) < TLS1_2_VERSION) {\\r\\nif (pk_nid != NID_rsaEncryption && pk_nid != NID_rsa) {\\r\\nSSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG,\\r\\nSSL_R_ECC_CERT_SHOULD_HAVE_RSA_SIGNATURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (alg_a & SSL_aECDSA) {\\r\\nif (ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE)) {\\r\\nSSLerr(SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG,\\r\\nSSL_R_ECC_CERT_NOT_FOR_SIGNING);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_get_server_cert_index(const SSL *s)\\r\\n{\\r\\nint idx;\\r\\nidx = ssl_cipher_get_cert_index(s->s3->tmp.new_cipher);\\r\\nif (idx == SSL_PKEY_RSA_ENC && !s->cert->pkeys[SSL_PKEY_RSA_ENC].x509)\\r\\nidx = SSL_PKEY_RSA_SIGN;\\r\\nif (idx == -1)\\r\\nSSLerr(SSL_F_SSL_GET_SERVER_CERT_INDEX, ERR_R_INTERNAL_ERROR);\\r\\nreturn idx;\\r\\n}\\r\\nCERT_PKEY *ssl_get_server_send_pkey(const SSL *s)\\r\\n{\\r\\nCERT *c;\\r\\nint i;\\r\\nc = s->cert;\\r\\nif (!s->s3 || !s->s3->tmp.new_cipher)\\r\\nreturn NULL;\\r\\nssl_set_cert_masks(c, s->s3->tmp.new_cipher);\\r\\n#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\\r\\nif (c->cert_flags & SSL_CERT_FLAG_BROKEN_PROTOCOL)\\r\\nreturn c->key;\\r\\n#endif\\r\\ni = ssl_get_server_cert_index(s);\\r\\nif (i < 0)\\r\\nreturn NULL;\\r\\nreturn &c->pkeys[i];\\r\\n}\\r\\nEVP_PKEY *ssl_get_sign_pkey(SSL *s, const SSL_CIPHER *cipher,\\r\\nconst EVP_MD **pmd)\\r\\n{\\r\\nunsigned long alg_a;\\r\\nCERT *c;\\r\\nint idx = -1;\\r\\nalg_a = cipher->algorithm_auth;\\r\\nc = s->cert;\\r\\n#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\\r\\nif (c->cert_flags & SSL_CERT_FLAG_BROKEN_PROTOCOL)\\r\\nidx = c->key - c->pkeys;\\r\\nelse\\r\\n#endif\\r\\nif ((alg_a & SSL_aDSS) &&\\r\\n(c->pkeys[SSL_PKEY_DSA_SIGN].privatekey != NULL))\\r\\nidx = SSL_PKEY_DSA_SIGN;\\r\\nelse if (alg_a & SSL_aRSA) {\\r\\nif (c->pkeys[SSL_PKEY_RSA_SIGN].privatekey != NULL)\\r\\nidx = SSL_PKEY_RSA_SIGN;\\r\\nelse if (c->pkeys[SSL_PKEY_RSA_ENC].privatekey != NULL)\\r\\nidx = SSL_PKEY_RSA_ENC;\\r\\n} else if ((alg_a & SSL_aECDSA) &&\\r\\n(c->pkeys[SSL_PKEY_ECC].privatekey != NULL))\\r\\nidx = SSL_PKEY_ECC;\\r\\nif (idx == -1) {\\r\\nSSLerr(SSL_F_SSL_GET_SIGN_PKEY, ERR_R_INTERNAL_ERROR);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (pmd)\\r\\n*pmd = c->pkeys[idx].digest;\\r\\nreturn c->pkeys[idx].privatekey;\\r\\n}\\r\\nint ssl_get_server_cert_serverinfo(SSL *s, const unsigned char **serverinfo,\\r\\nsize_t *serverinfo_length)\\r\\n{\\r\\nCERT *c = NULL;\\r\\nint i = 0;\\r\\n*serverinfo_length = 0;\\r\\nc = s->cert;\\r\\ni = ssl_get_server_cert_index(s);\\r\\nif (i == -1)\\r\\nreturn 0;\\r\\nif (c->pkeys[i].serverinfo == NULL)\\r\\nreturn 0;\\r\\n*serverinfo = c->pkeys[i].serverinfo;\\r\\n*serverinfo_length = c->pkeys[i].serverinfo_length;\\r\\nreturn 1;\\r\\n}\\r\\nvoid ssl_update_cache(SSL *s, int mode)\\r\\n{\\r\\nint i;\\r\\nif (s->session->session_id_length == 0)\\r\\nreturn;\\r\\ni = s->session_ctx->session_cache_mode;\\r\\nif ((i & mode) && (!s->hit)\\r\\n&& ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE)\\r\\n|| SSL_CTX_add_session(s->session_ctx, s->session))\\r\\n&& (s->session_ctx->new_session_cb != NULL)) {\\r\\nCRYPTO_add(&s->session->references, 1, CRYPTO_LOCK_SSL_SESSION);\\r\\nif (!s->session_ctx->new_session_cb(s, s->session))\\r\\nSSL_SESSION_free(s->session);\\r\\n}\\r\\nif ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\\r\\nif ((((mode & SSL_SESS_CACHE_CLIENT)\\r\\n? s->session_ctx->stats.sess_connect_good\\r\\n: s->session_ctx->stats.sess_accept_good) & 0xff) == 0xff) {\\r\\nSSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\\r\\n}\\r\\n}\\r\\n}\\r\\nconst SSL_METHOD *SSL_CTX_get_ssl_method(SSL_CTX *ctx)\\r\\n{\\r\\nreturn ctx->method;\\r\\n}\\r\\nconst SSL_METHOD *SSL_get_ssl_method(SSL *s)\\r\\n{\\r\\nreturn (s->method);\\r\\n}\\r\\nint SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)\\r\\n{\\r\\nint conn = -1;\\r\\nint ret = 1;\\r\\nif (s->method != meth) {\\r\\nif (s->handshake_func != NULL)\\r\\nconn = (s->handshake_func == s->method->ssl_connect);\\r\\nif (s->method->version == meth->version)\\r\\ns->method = meth;\\r\\nelse {\\r\\ns->method->ssl_free(s);\\r\\ns->method = meth;\\r\\nret = s->method->ssl_new(s);\\r\\n}\\r\\nif (conn == 1)\\r\\ns->handshake_func = meth->ssl_connect;\\r\\nelse if (conn == 0)\\r\\ns->handshake_func = meth->ssl_accept;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_get_error(const SSL *s, int i)\\r\\n{\\r\\nint reason;\\r\\nunsigned long l;\\r\\nBIO *bio;\\r\\nif (i > 0)\\r\\nreturn (SSL_ERROR_NONE);\\r\\nif ((l = ERR_peek_error()) != 0) {\\r\\nif (ERR_GET_LIB(l) == ERR_LIB_SYS)\\r\\nreturn (SSL_ERROR_SYSCALL);\\r\\nelse\\r\\nreturn (SSL_ERROR_SSL);\\r\\n}\\r\\nif ((i < 0) && SSL_want_read(s)) {\\r\\nbio = SSL_get_rbio(s);\\r\\nif (BIO_should_read(bio))\\r\\nreturn (SSL_ERROR_WANT_READ);\\r\\nelse if (BIO_should_write(bio))\\r\\nreturn (SSL_ERROR_WANT_WRITE);\\r\\nelse if (BIO_should_io_special(bio)) {\\r\\nreason = BIO_get_retry_reason(bio);\\r\\nif (reason == BIO_RR_CONNECT)\\r\\nreturn (SSL_ERROR_WANT_CONNECT);\\r\\nelse if (reason == BIO_RR_ACCEPT)\\r\\nreturn (SSL_ERROR_WANT_ACCEPT);\\r\\nelse\\r\\nreturn (SSL_ERROR_SYSCALL);\\r\\n}\\r\\n}\\r\\nif ((i < 0) && SSL_want_write(s)) {\\r\\nbio = SSL_get_wbio(s);\\r\\nif (BIO_should_write(bio))\\r\\nreturn (SSL_ERROR_WANT_WRITE);\\r\\nelse if (BIO_should_read(bio))\\r\\nreturn (SSL_ERROR_WANT_READ);\\r\\nelse if (BIO_should_io_special(bio)) {\\r\\nreason = BIO_get_retry_reason(bio);\\r\\nif (reason == BIO_RR_CONNECT)\\r\\nreturn (SSL_ERROR_WANT_CONNECT);\\r\\nelse if (reason == BIO_RR_ACCEPT)\\r\\nreturn (SSL_ERROR_WANT_ACCEPT);\\r\\nelse\\r\\nreturn (SSL_ERROR_SYSCALL);\\r\\n}\\r\\n}\\r\\nif ((i < 0) && SSL_want_x509_lookup(s)) {\\r\\nreturn (SSL_ERROR_WANT_X509_LOOKUP);\\r\\n}\\r\\nif (i == 0) {\\r\\nif (s->version == SSL2_VERSION) {\\r\\nreturn (SSL_ERROR_ZERO_RETURN);\\r\\n} else {\\r\\nif ((s->shutdown & SSL_RECEIVED_SHUTDOWN) &&\\r\\n(s->s3->warn_alert == SSL_AD_CLOSE_NOTIFY))\\r\\nreturn (SSL_ERROR_ZERO_RETURN);\\r\\n}\\r\\n}\\r\\nreturn (SSL_ERROR_SYSCALL);\\r\\n}\\r\\nint SSL_do_handshake(SSL *s)\\r\\n{\\r\\nint ret = 1;\\r\\nif (s->handshake_func == NULL) {\\r\\nSSLerr(SSL_F_SSL_DO_HANDSHAKE, SSL_R_CONNECTION_TYPE_NOT_SET);\\r\\nreturn (-1);\\r\\n}\\r\\ns->method->ssl_renegotiate_check(s);\\r\\nif (SSL_in_init(s) || SSL_in_before(s)) {\\r\\nret = s->handshake_func(s);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid SSL_set_accept_state(SSL *s)\\r\\n{\\r\\ns->server = 1;\\r\\ns->shutdown = 0;\\r\\ns->state = SSL_ST_ACCEPT | SSL_ST_BEFORE;\\r\\ns->handshake_func = s->method->ssl_accept;\\r\\nssl_clear_cipher_ctx(s);\\r\\nssl_clear_hash_ctx(&s->read_hash);\\r\\nssl_clear_hash_ctx(&s->write_hash);\\r\\n}\\r\\nvoid SSL_set_connect_state(SSL *s)\\r\\n{\\r\\ns->server = 0;\\r\\ns->shutdown = 0;\\r\\ns->state = SSL_ST_CONNECT | SSL_ST_BEFORE;\\r\\ns->handshake_func = s->method->ssl_connect;\\r\\nssl_clear_cipher_ctx(s);\\r\\nssl_clear_hash_ctx(&s->read_hash);\\r\\nssl_clear_hash_ctx(&s->write_hash);\\r\\n}\\r\\nint ssl_undefined_function(SSL *s)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_UNDEFINED_FUNCTION, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (0);\\r\\n}\\r\\nint ssl_undefined_void_function(void)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_UNDEFINED_VOID_FUNCTION,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (0);\\r\\n}\\r\\nint ssl_undefined_const_function(const SSL *s)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_UNDEFINED_CONST_FUNCTION,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (0);\\r\\n}\\r\\nSSL_METHOD *ssl_bad_method(int ver)\\r\\n{\\r\\nSSLerr(SSL_F_SSL_BAD_METHOD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (NULL);\\r\\n}\\r\\nconst char *SSL_get_version(const SSL *s)\\r\\n{\\r\\nif (s->version == TLS1_2_VERSION)\\r\\nreturn (\"TLSv1.2\");\\r\\nelse if (s->version == TLS1_1_VERSION)\\r\\nreturn (\"TLSv1.1\");\\r\\nelse if (s->version == TLS1_VERSION)\\r\\nreturn (\"TLSv1\");\\r\\nelse if (s->version == SSL3_VERSION)\\r\\nreturn (\"SSLv3\");\\r\\nelse if (s->version == SSL2_VERSION)\\r\\nreturn (\"SSLv2\");\\r\\nelse\\r\\nreturn (\"unknown\");\\r\\n}\\r\\nSSL *SSL_dup(SSL *s)\\r\\n{\\r\\nSTACK_OF(X509_NAME) *sk;\\r\\nX509_NAME *xn;\\r\\nSSL *ret;\\r\\nint i;\\r\\nif ((ret = SSL_new(SSL_get_SSL_CTX(s))) == NULL)\\r\\nreturn (NULL);\\r\\nret->version = s->version;\\r\\nret->type = s->type;\\r\\nret->method = s->method;\\r\\nif (s->session != NULL) {\\r\\nSSL_copy_session_id(ret, s);\\r\\n} else {\\r\\nret->method->ssl_free(ret);\\r\\nret->method = s->method;\\r\\nret->method->ssl_new(ret);\\r\\nif (s->cert != NULL) {\\r\\nif (ret->cert != NULL) {\\r\\nssl_cert_free(ret->cert);\\r\\n}\\r\\nret->cert = ssl_cert_dup(s->cert);\\r\\nif (ret->cert == NULL)\\r\\ngoto err;\\r\\n}\\r\\nSSL_set_session_id_context(ret, s->sid_ctx, s->sid_ctx_length);\\r\\n}\\r\\nret->options = s->options;\\r\\nret->mode = s->mode;\\r\\nSSL_set_max_cert_list(ret, SSL_get_max_cert_list(s));\\r\\nSSL_set_read_ahead(ret, SSL_get_read_ahead(s));\\r\\nret->msg_callback = s->msg_callback;\\r\\nret->msg_callback_arg = s->msg_callback_arg;\\r\\nSSL_set_verify(ret, SSL_get_verify_mode(s), SSL_get_verify_callback(s));\\r\\nSSL_set_verify_depth(ret, SSL_get_verify_depth(s));\\r\\nret->generate_session_id = s->generate_session_id;\\r\\nSSL_set_info_callback(ret, SSL_get_info_callback(s));\\r\\nret->debug = s->debug;\\r\\nif (!CRYPTO_dup_ex_data(CRYPTO_EX_INDEX_SSL, &ret->ex_data, &s->ex_data))\\r\\ngoto err;\\r\\nif (s->rbio != NULL) {\\r\\nif (!BIO_dup_state(s->rbio, (char *)&ret->rbio))\\r\\ngoto err;\\r\\n}\\r\\nif (s->wbio != NULL) {\\r\\nif (s->wbio != s->rbio) {\\r\\nif (!BIO_dup_state(s->wbio, (char *)&ret->wbio))\\r\\ngoto err;\\r\\n} else\\r\\nret->wbio = ret->rbio;\\r\\n}\\r\\nret->rwstate = s->rwstate;\\r\\nret->in_handshake = s->in_handshake;\\r\\nret->handshake_func = s->handshake_func;\\r\\nret->server = s->server;\\r\\nret->renegotiate = s->renegotiate;\\r\\nret->new_session = s->new_session;\\r\\nret->quiet_shutdown = s->quiet_shutdown;\\r\\nret->shutdown = s->shutdown;\\r\\nret->state = s->state;\\r\\nret->rstate = s->rstate;\\r\\nret->init_num = 0;\\r\\nret->hit = s->hit;\\r\\nX509_VERIFY_PARAM_inherit(ret->param, s->param);\\r\\nif (s->cipher_list != NULL) {\\r\\nif ((ret->cipher_list = sk_SSL_CIPHER_dup(s->cipher_list)) == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (s->cipher_list_by_id != NULL)\\r\\nif ((ret->cipher_list_by_id = sk_SSL_CIPHER_dup(s->cipher_list_by_id))\\r\\n== NULL)\\r\\ngoto err;\\r\\nif (s->client_CA != NULL) {\\r\\nif ((sk = sk_X509_NAME_dup(s->client_CA)) == NULL)\\r\\ngoto err;\\r\\nret->client_CA = sk;\\r\\nfor (i = 0; i < sk_X509_NAME_num(sk); i++) {\\r\\nxn = sk_X509_NAME_value(sk, i);\\r\\nif (sk_X509_NAME_set(sk, i, X509_NAME_dup(xn)) == NULL) {\\r\\nX509_NAME_free(xn);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (0) {\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nSSL_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid ssl_clear_cipher_ctx(SSL *s)\\r\\n{\\r\\nif (s->enc_read_ctx != NULL) {\\r\\nEVP_CIPHER_CTX_cleanup(s->enc_read_ctx);\\r\\nOPENSSL_free(s->enc_read_ctx);\\r\\ns->enc_read_ctx = NULL;\\r\\n}\\r\\nif (s->enc_write_ctx != NULL) {\\r\\nEVP_CIPHER_CTX_cleanup(s->enc_write_ctx);\\r\\nOPENSSL_free(s->enc_write_ctx);\\r\\ns->enc_write_ctx = NULL;\\r\\n}\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nif (s->expand != NULL) {\\r\\nCOMP_CTX_free(s->expand);\\r\\ns->expand = NULL;\\r\\n}\\r\\nif (s->compress != NULL) {\\r\\nCOMP_CTX_free(s->compress);\\r\\ns->compress = NULL;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nX509 *SSL_get_certificate(const SSL *s)\\r\\n{\\r\\nif (s->cert != NULL)\\r\\nreturn (s->cert->key->x509);\\r\\nelse\\r\\nreturn (NULL);\\r\\n}\\r\\nEVP_PKEY *SSL_get_privatekey(const SSL *s)\\r\\n{\\r\\nif (s->cert != NULL)\\r\\nreturn (s->cert->key->privatekey);\\r\\nelse\\r\\nreturn (NULL);\\r\\n}\\r\\nX509 *SSL_CTX_get0_certificate(const SSL_CTX *ctx)\\r\\n{\\r\\nif (ctx->cert != NULL)\\r\\nreturn ctx->cert->key->x509;\\r\\nelse\\r\\nreturn NULL;\\r\\n}\\r\\nEVP_PKEY *SSL_CTX_get0_privatekey(const SSL_CTX *ctx)\\r\\n{\\r\\nif (ctx->cert != NULL)\\r\\nreturn ctx->cert->key->privatekey;\\r\\nelse\\r\\nreturn NULL;\\r\\n}\\r\\nconst SSL_CIPHER *SSL_get_current_cipher(const SSL *s)\\r\\n{\\r\\nif ((s->session != NULL) && (s->session->cipher != NULL))\\r\\nreturn (s->session->cipher);\\r\\nreturn (NULL);\\r\\n}\\r\\nconst void *SSL_get_current_compression(SSL *s)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nconst void *SSL_get_current_expansion(SSL *s)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nconst COMP_METHOD *SSL_get_current_compression(SSL *s)\\r\\n{\\r\\nif (s->compress != NULL)\\r\\nreturn (s->compress->meth);\\r\\nreturn (NULL);\\r\\n}\\r\\nconst COMP_METHOD *SSL_get_current_expansion(SSL *s)\\r\\n{\\r\\nif (s->expand != NULL)\\r\\nreturn (s->expand->meth);\\r\\nreturn (NULL);\\r\\n}\\r\\nint ssl_init_wbio_buffer(SSL *s, int push)\\r\\n{\\r\\nBIO *bbio;\\r\\nif (s->bbio == NULL) {\\r\\nbbio = BIO_new(BIO_f_buffer());\\r\\nif (bbio == NULL)\\r\\nreturn (0);\\r\\ns->bbio = bbio;\\r\\n} else {\\r\\nbbio = s->bbio;\\r\\nif (s->bbio == s->wbio)\\r\\ns->wbio = BIO_pop(s->wbio);\\r\\n}\\r\\n(void)BIO_reset(bbio);\\r\\nif (!BIO_set_read_buffer_size(bbio, 1)) {\\r\\nSSLerr(SSL_F_SSL_INIT_WBIO_BUFFER, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nif (push) {\\r\\nif (s->wbio != bbio)\\r\\ns->wbio = BIO_push(bbio, s->wbio);\\r\\n} else {\\r\\nif (s->wbio == bbio)\\r\\ns->wbio = BIO_pop(bbio);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nvoid ssl_free_wbio_buffer(SSL *s)\\r\\n{\\r\\nif (s->bbio == NULL)\\r\\nreturn;\\r\\nif (s->bbio == s->wbio) {\\r\\ns->wbio = BIO_pop(s->wbio);\\r\\n#ifdef REF_CHECK\\r\\nassert(s->wbio != NULL);\\r\\n#endif\\r\\n}\\r\\nBIO_free(s->bbio);\\r\\ns->bbio = NULL;\\r\\n}\\r\\nvoid SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx, int mode)\\r\\n{\\r\\nctx->quiet_shutdown = mode;\\r\\n}\\r\\nint SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx)\\r\\n{\\r\\nreturn (ctx->quiet_shutdown);\\r\\n}\\r\\nvoid SSL_set_quiet_shutdown(SSL *s, int mode)\\r\\n{\\r\\ns->quiet_shutdown = mode;\\r\\n}\\r\\nint SSL_get_quiet_shutdown(const SSL *s)\\r\\n{\\r\\nreturn (s->quiet_shutdown);\\r\\n}\\r\\nvoid SSL_set_shutdown(SSL *s, int mode)\\r\\n{\\r\\ns->shutdown = mode;\\r\\n}\\r\\nint SSL_get_shutdown(const SSL *s)\\r\\n{\\r\\nreturn (s->shutdown);\\r\\n}\\r\\nint SSL_version(const SSL *s)\\r\\n{\\r\\nreturn (s->version);\\r\\n}\\r\\nSSL_CTX *SSL_get_SSL_CTX(const SSL *ssl)\\r\\n{\\r\\nreturn (ssl->ctx);\\r\\n}\\r\\nSSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX *ctx)\\r\\n{\\r\\nCERT *ocert = ssl->cert;\\r\\nif (ssl->ctx == ctx)\\r\\nreturn ssl->ctx;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (ctx == NULL)\\r\\nctx = ssl->initial_ctx;\\r\\n#endif\\r\\nssl->cert = ssl_cert_dup(ctx->cert);\\r\\nif (ocert) {\\r\\nif (ssl->server) {\\r\\nssl->cert->peer_sigalgs = ocert->peer_sigalgs;\\r\\nssl->cert->peer_sigalgslen = ocert->peer_sigalgslen;\\r\\nocert->peer_sigalgs = NULL;\\r\\nssl->cert->ciphers_raw = ocert->ciphers_raw;\\r\\nssl->cert->ciphers_rawlen = ocert->ciphers_rawlen;\\r\\nocert->ciphers_raw = NULL;\\r\\n}\\r\\nssl_cert_free(ocert);\\r\\n}\\r\\nOPENSSL_assert(ssl->sid_ctx_length <= sizeof(ssl->sid_ctx));\\r\\nif ((ssl->ctx != NULL) &&\\r\\n(ssl->sid_ctx_length == ssl->ctx->sid_ctx_length) &&\\r\\n(memcmp(ssl->sid_ctx, ssl->ctx->sid_ctx, ssl->sid_ctx_length) == 0)) {\\r\\nssl->sid_ctx_length = ctx->sid_ctx_length;\\r\\nmemcpy(&ssl->sid_ctx, &ctx->sid_ctx, sizeof(ssl->sid_ctx));\\r\\n}\\r\\nCRYPTO_add(&ctx->references, 1, CRYPTO_LOCK_SSL_CTX);\\r\\nif (ssl->ctx != NULL)\\r\\nSSL_CTX_free(ssl->ctx);\\r\\nssl->ctx = ctx;\\r\\nreturn (ssl->ctx);\\r\\n}\\r\\nint SSL_CTX_set_default_verify_paths(SSL_CTX *ctx)\\r\\n{\\r\\nreturn (X509_STORE_set_default_paths(ctx->cert_store));\\r\\n}\\r\\nint SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,\\r\\nconst char *CApath)\\r\\n{\\r\\nreturn (X509_STORE_load_locations(ctx->cert_store, CAfile, CApath));\\r\\n}\\r\\nvoid SSL_set_info_callback(SSL *ssl,\\r\\nvoid (*cb) (const SSL *ssl, int type, int val))\\r\\n{\\r\\nssl->info_callback = cb;\\r\\n}\\r\\nint SSL_state(const SSL *ssl)\\r\\n{\\r\\nreturn (ssl->state);\\r\\n}\\r\\nvoid SSL_set_state(SSL *ssl, int state)\\r\\n{\\r\\nssl->state = state;\\r\\n}\\r\\nvoid SSL_set_verify_result(SSL *ssl, long arg)\\r\\n{\\r\\nssl->verify_result = arg;\\r\\n}\\r\\nlong SSL_get_verify_result(const SSL *ssl)\\r\\n{\\r\\nreturn (ssl->verify_result);\\r\\n}\\r\\nint SSL_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint SSL_set_ex_data(SSL *s, int idx, void *arg)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&s->ex_data, idx, arg));\\r\\n}\\r\\nvoid *SSL_get_ex_data(const SSL *s, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&s->ex_data, idx));\\r\\n}\\r\\nint SSL_CTX_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint SSL_CTX_set_ex_data(SSL_CTX *s, int idx, void *arg)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&s->ex_data, idx, arg));\\r\\n}\\r\\nvoid *SSL_CTX_get_ex_data(const SSL_CTX *s, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&s->ex_data, idx));\\r\\n}\\r\\nint ssl_ok(SSL *s)\\r\\n{\\r\\nreturn (1);\\r\\n}\\r\\nX509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *ctx)\\r\\n{\\r\\nreturn (ctx->cert_store);\\r\\n}\\r\\nvoid SSL_CTX_set_cert_store(SSL_CTX *ctx, X509_STORE *store)\\r\\n{\\r\\nif (ctx->cert_store != NULL)\\r\\nX509_STORE_free(ctx->cert_store);\\r\\nctx->cert_store = store;\\r\\n}\\r\\nint SSL_want(const SSL *s)\\r\\n{\\r\\nreturn (s->rwstate);\\r\\n}\\r\\nvoid SSL_CTX_set_tmp_rsa_callback(SSL_CTX *ctx, RSA *(*cb) (SSL *ssl,\\r\\nint is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_TMP_RSA_CB, (void (*)(void))cb);\\r\\n}\\r\\nvoid SSL_set_tmp_rsa_callback(SSL *ssl, RSA *(*cb) (SSL *ssl,\\r\\nint is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_callback_ctrl(ssl, SSL_CTRL_SET_TMP_RSA_CB, (void (*)(void))cb);\\r\\n}\\r\\nRSA *cb(SSL *ssl, int is_export, int keylength)\\r\\n{\\r\\n}\\r\\nvoid SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,\\r\\nDH *(*dh) (SSL *ssl, int is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_TMP_DH_CB, (void (*)(void))dh);\\r\\n}\\r\\nvoid SSL_set_tmp_dh_callback(SSL *ssl, DH *(*dh) (SSL *ssl, int is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_callback_ctrl(ssl, SSL_CTRL_SET_TMP_DH_CB, (void (*)(void))dh);\\r\\n}\\r\\nvoid SSL_CTX_set_tmp_ecdh_callback(SSL_CTX *ctx,\\r\\nEC_KEY *(*ecdh) (SSL *ssl, int is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_TMP_ECDH_CB,\\r\\n(void (*)(void))ecdh);\\r\\n}\\r\\nvoid SSL_set_tmp_ecdh_callback(SSL *ssl,\\r\\nEC_KEY *(*ecdh) (SSL *ssl, int is_export,\\r\\nint keylength))\\r\\n{\\r\\nSSL_callback_ctrl(ssl, SSL_CTRL_SET_TMP_ECDH_CB, (void (*)(void))ecdh);\\r\\n}\\r\\nint SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint)\\r\\n{\\r\\nif (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT,\\r\\nSSL_R_DATA_LENGTH_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx->psk_identity_hint != NULL)\\r\\nOPENSSL_free(ctx->psk_identity_hint);\\r\\nif (identity_hint != NULL) {\\r\\nctx->psk_identity_hint = BUF_strdup(identity_hint);\\r\\nif (ctx->psk_identity_hint == NULL)\\r\\nreturn 0;\\r\\n} else\\r\\nctx->psk_identity_hint = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_use_psk_identity_hint(SSL *s, const char *identity_hint)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn 0;\\r\\nif (s->session == NULL)\\r\\nreturn 1;\\r\\nif (identity_hint != NULL && strlen(identity_hint) > PSK_MAX_IDENTITY_LEN) {\\r\\nSSLerr(SSL_F_SSL_USE_PSK_IDENTITY_HINT, SSL_R_DATA_LENGTH_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nif (s->session->psk_identity_hint != NULL)\\r\\nOPENSSL_free(s->session->psk_identity_hint);\\r\\nif (identity_hint != NULL) {\\r\\ns->session->psk_identity_hint = BUF_strdup(identity_hint);\\r\\nif (s->session->psk_identity_hint == NULL)\\r\\nreturn 0;\\r\\n} else\\r\\ns->session->psk_identity_hint = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nconst char *SSL_get_psk_identity_hint(const SSL *s)\\r\\n{\\r\\nif (s == NULL || s->session == NULL)\\r\\nreturn NULL;\\r\\nreturn (s->session->psk_identity_hint);\\r\\n}\\r\\nconst char *SSL_get_psk_identity(const SSL *s)\\r\\n{\\r\\nif (s == NULL || s->session == NULL)\\r\\nreturn NULL;\\r\\nreturn (s->session->psk_identity);\\r\\n}\\r\\nvoid SSL_CTX_set_msg_callback(SSL_CTX *ctx,\\r\\nvoid (*cb) (int write_p, int version,\\r\\nint content_type, const void *buf,\\r\\nsize_t len, SSL *ssl, void *arg))\\r\\n{\\r\\nSSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);\\r\\n}\\r\\nvoid SSL_set_msg_callback(SSL *ssl,\\r\\nvoid (*cb) (int write_p, int version,\\r\\nint content_type, const void *buf,\\r\\nsize_t len, SSL *ssl, void *arg))\\r\\n{\\r\\nSSL_callback_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK, (void (*)(void))cb);\\r\\n}\\r\\nEVP_MD_CTX *ssl_replace_hash(EVP_MD_CTX **hash, const EVP_MD *md)\\r\\n{\\r\\nssl_clear_hash_ctx(hash);\\r\\n*hash = EVP_MD_CTX_create();\\r\\nif (md)\\r\\nEVP_DigestInit_ex(*hash, md, NULL);\\r\\nreturn *hash;\\r\\n}\\r\\nvoid ssl_clear_hash_ctx(EVP_MD_CTX **hash)\\r\\n{\\r\\nif (*hash)\\r\\nEVP_MD_CTX_destroy(*hash);\\r\\n*hash = NULL;\\r\\n}\\r\\nvoid SSL_set_debug(SSL *s, int debug)\\r\\n{\\r\\ns->debug = debug;\\r\\n}\\r\\nint SSL_cache_hit(SSL *s)\\r\\n{\\r\\nreturn s->hit;\\r\\n}\\r\\nint SSL_is_server(SSL *s)\\r\\n{\\r\\nreturn s->server;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_ssl_c", "target": 0, "func": "BIO_METHOD *BIO_f_ssl(void)\\r\\n{\\r\\nreturn (&methods_sslp);\\r\\n}\\r\\nstatic int ssl_new(BIO *bi)\\r\\n{\\r\\nBIO_SSL *bs;\\r\\nbs = (BIO_SSL *)OPENSSL_malloc(sizeof(BIO_SSL));\\r\\nif (bs == NULL) {\\r\\nBIOerr(BIO_F_SSL_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nmemset(bs, 0, sizeof(BIO_SSL));\\r\\nbi->init = 0;\\r\\nbi->ptr = (char *)bs;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int ssl_free(BIO *a)\\r\\n{\\r\\nBIO_SSL *bs;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nbs = (BIO_SSL *)a->ptr;\\r\\nif (bs->ssl != NULL)\\r\\nSSL_shutdown(bs->ssl);\\r\\nif (a->shutdown) {\\r\\nif (a->init && (bs->ssl != NULL))\\r\\nSSL_free(bs->ssl);\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\n}\\r\\nif (a->ptr != NULL)\\r\\nOPENSSL_free(a->ptr);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int ssl_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 1;\\r\\nBIO_SSL *sb;\\r\\nSSL *ssl;\\r\\nint retry_reason = 0;\\r\\nint r = 0;\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nsb = (BIO_SSL *)b->ptr;\\r\\nssl = sb->ssl;\\r\\nBIO_clear_retry_flags(b);\\r\\n#if 0\\r\\nif (!SSL_is_init_finished(ssl)) {\\r\\nif (ret > 0) {\\r\\noutflags = (BIO_FLAGS_READ | BIO_FLAGS_SHOULD_RETRY);\\r\\nret = -1;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret = SSL_read(ssl, out, outl);\\r\\nswitch (SSL_get_error(ssl, ret)) {\\r\\ncase SSL_ERROR_NONE:\\r\\nif (ret <= 0)\\r\\nbreak;\\r\\nif (sb->renegotiate_count > 0) {\\r\\nsb->byte_count += ret;\\r\\nif (sb->byte_count > sb->renegotiate_count) {\\r\\nsb->byte_count = 0;\\r\\nsb->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\nr = 1;\\r\\n}\\r\\n}\\r\\nif ((sb->renegotiate_timeout > 0) && (!r)) {\\r\\nunsigned long tm;\\r\\ntm = (unsigned long)time(NULL);\\r\\nif (tm > sb->last_time + sb->renegotiate_timeout) {\\r\\nsb->last_time = tm;\\r\\nsb->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_set_retry_read(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_set_retry_write(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason = BIO_RR_SSL_X509_LOOKUP;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_ACCEPT:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason = BIO_RR_ACCEPT;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_CONNECT:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason = BIO_RR_CONNECT;\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nb->retry_reason = retry_reason;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ssl_write(BIO *b, const char *out, int outl)\\r\\n{\\r\\nint ret, r = 0;\\r\\nint retry_reason = 0;\\r\\nSSL *ssl;\\r\\nBIO_SSL *bs;\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nbs = (BIO_SSL *)b->ptr;\\r\\nssl = bs->ssl;\\r\\nBIO_clear_retry_flags(b);\\r\\nret = SSL_write(ssl, out, outl);\\r\\nswitch (SSL_get_error(ssl, ret)) {\\r\\ncase SSL_ERROR_NONE:\\r\\nif (ret <= 0)\\r\\nbreak;\\r\\nif (bs->renegotiate_count > 0) {\\r\\nbs->byte_count += ret;\\r\\nif (bs->byte_count > bs->renegotiate_count) {\\r\\nbs->byte_count = 0;\\r\\nbs->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\nr = 1;\\r\\n}\\r\\n}\\r\\nif ((bs->renegotiate_timeout > 0) && (!r)) {\\r\\nunsigned long tm;\\r\\ntm = (unsigned long)time(NULL);\\r\\nif (tm > bs->last_time + bs->renegotiate_timeout) {\\r\\nbs->last_time = tm;\\r\\nbs->num_renegotiates++;\\r\\nSSL_renegotiate(ssl);\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_set_retry_write(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_set_retry_read(b);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason = BIO_RR_SSL_X509_LOOKUP;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_CONNECT:\\r\\nBIO_set_retry_special(b);\\r\\nretry_reason = BIO_RR_CONNECT;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nb->retry_reason = retry_reason;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long ssl_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nSSL **sslp, *ssl;\\r\\nBIO_SSL *bs;\\r\\nBIO *dbio, *bio;\\r\\nlong ret = 1;\\r\\nbs = (BIO_SSL *)b->ptr;\\r\\nssl = bs->ssl;\\r\\nif ((ssl == NULL) && (cmd != BIO_C_SET_SSL))\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nSSL_shutdown(ssl);\\r\\nif (ssl->handshake_func == ssl->method->ssl_connect)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse if (ssl->handshake_func == ssl->method->ssl_accept)\\r\\nSSL_set_accept_state(ssl);\\r\\nSSL_clear(ssl);\\r\\nif (b->next_bio != NULL)\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nelse if (ssl->rbio != NULL)\\r\\nret = BIO_ctrl(ssl->rbio, cmd, num, ptr);\\r\\nelse\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_C_SSL_MODE:\\r\\nif (num)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse\\r\\nSSL_set_accept_state(ssl);\\r\\nbreak;\\r\\ncase BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT:\\r\\nret = bs->renegotiate_timeout;\\r\\nif (num < 60)\\r\\nnum = 5;\\r\\nbs->renegotiate_timeout = (unsigned long)num;\\r\\nbs->last_time = (unsigned long)time(NULL);\\r\\nbreak;\\r\\ncase BIO_C_SET_SSL_RENEGOTIATE_BYTES:\\r\\nret = bs->renegotiate_count;\\r\\nif ((long)num >= 512)\\r\\nbs->renegotiate_count = (unsigned long)num;\\r\\nbreak;\\r\\ncase BIO_C_GET_SSL_NUM_RENEGOTIATES:\\r\\nret = bs->num_renegotiates;\\r\\nbreak;\\r\\ncase BIO_C_SET_SSL:\\r\\nif (ssl != NULL) {\\r\\nssl_free(b);\\r\\nif (!ssl_new(b))\\r\\nreturn 0;\\r\\n}\\r\\nb->shutdown = (int)num;\\r\\nssl = (SSL *)ptr;\\r\\n((BIO_SSL *)b->ptr)->ssl = ssl;\\r\\nbio = SSL_get_rbio(ssl);\\r\\nif (bio != NULL) {\\r\\nif (b->next_bio != NULL)\\r\\nBIO_push(bio, b->next_bio);\\r\\nb->next_bio = bio;\\r\\nCRYPTO_add(&bio->references, 1, CRYPTO_LOCK_BIO);\\r\\n}\\r\\nb->init = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_SSL:\\r\\nif (ptr != NULL) {\\r\\nsslp = (SSL **)ptr;\\r\\n*sslp = ssl;\\r\\n} else\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown = (int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = BIO_ctrl(ssl->wbio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret = SSL_pending(ssl);\\r\\nif (ret == 0)\\r\\nret = BIO_pending(ssl->rbio);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(ssl->wbio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_PUSH:\\r\\nif ((b->next_bio != NULL) && (b->next_bio != ssl->rbio)) {\\r\\nSSL_set_bio(ssl, b->next_bio, b->next_bio);\\r\\nCRYPTO_add(&b->next_bio->references, 1, CRYPTO_LOCK_BIO);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_POP:\\r\\nif (b == ptr) {\\r\\nif (ssl->rbio != ssl->wbio)\\r\\nBIO_free_all(ssl->wbio);\\r\\nif (b->next_bio != NULL)\\r\\nCRYPTO_add(&b->next_bio->references, -1, CRYPTO_LOCK_BIO);\\r\\nssl->wbio = NULL;\\r\\nssl->rbio = NULL;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nb->retry_reason = 0;\\r\\nret = (int)SSL_do_handshake(ssl);\\r\\nswitch (SSL_get_error(ssl, (int)ret)) {\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_set_flags(b, BIO_FLAGS_READ | BIO_FLAGS_SHOULD_RETRY);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_set_flags(b, BIO_FLAGS_WRITE | BIO_FLAGS_SHOULD_RETRY);\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_CONNECT:\\r\\nBIO_set_flags(b, BIO_FLAGS_IO_SPECIAL | BIO_FLAGS_SHOULD_RETRY);\\r\\nb->retry_reason = b->next_bio->retry_reason;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio = (BIO *)ptr;\\r\\nif (((BIO_SSL *)dbio->ptr)->ssl != NULL)\\r\\nSSL_free(((BIO_SSL *)dbio->ptr)->ssl);\\r\\n((BIO_SSL *)dbio->ptr)->ssl = SSL_dup(ssl);\\r\\n((BIO_SSL *)dbio->ptr)->renegotiate_count =\\r\\n((BIO_SSL *)b->ptr)->renegotiate_count;\\r\\n((BIO_SSL *)dbio->ptr)->byte_count = ((BIO_SSL *)b->ptr)->byte_count;\\r\\n((BIO_SSL *)dbio->ptr)->renegotiate_timeout =\\r\\n((BIO_SSL *)b->ptr)->renegotiate_timeout;\\r\\n((BIO_SSL *)dbio->ptr)->last_time = ((BIO_SSL *)b->ptr)->last_time;\\r\\nret = (((BIO_SSL *)dbio->ptr)->ssl != NULL);\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nret = BIO_ctrl(ssl->rbio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\n{\\r\\n#if 0\\r\\nSSLerr(SSL_F_SSL_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nret = -1;\\r\\n#else\\r\\nret = 0;\\r\\n#endif\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CALLBACK:\\r\\n{\\r\\nvoid (**fptr) (const SSL *xssl, int type, int val);\\r\\nfptr = (void (**)(const SSL *xssl, int type, int val))ptr;\\r\\n*fptr = SSL_get_info_callback(ssl);\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret = BIO_ctrl(ssl->rbio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long ssl_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nSSL *ssl;\\r\\nBIO_SSL *bs;\\r\\nlong ret = 1;\\r\\nbs = (BIO_SSL *)b->ptr;\\r\\nssl = bs->ssl;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\n{\\r\\nSSL_set_info_callback(ssl, (void (*)(const SSL *, int, int))fp);\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret = BIO_callback_ctrl(ssl->rbio, cmd, fp);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ssl_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = BIO_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}\\r\\nBIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx)\\r\\n{\\r\\n#ifndef OPENSSL_NO_SOCK\\r\\nBIO *ret = NULL, *buf = NULL, *ssl = NULL;\\r\\nif ((buf = BIO_new(BIO_f_buffer())) == NULL)\\r\\nreturn (NULL);\\r\\nif ((ssl = BIO_new_ssl_connect(ctx)) == NULL)\\r\\ngoto err;\\r\\nif ((ret = BIO_push(buf, ssl)) == NULL)\\r\\ngoto err;\\r\\nreturn (ret);\\r\\nerr:\\r\\nif (buf != NULL)\\r\\nBIO_free(buf);\\r\\nif (ssl != NULL)\\r\\nBIO_free(ssl);\\r\\n#endif\\r\\nreturn (NULL);\\r\\n}\\r\\nBIO *BIO_new_ssl_connect(SSL_CTX *ctx)\\r\\n{\\r\\n#ifndef OPENSSL_NO_SOCK\\r\\nBIO *ret = NULL, *con = NULL, *ssl = NULL;\\r\\nif ((con = BIO_new(BIO_s_connect())) == NULL)\\r\\nreturn (NULL);\\r\\nif ((ssl = BIO_new_ssl(ctx, 1)) == NULL)\\r\\ngoto err;\\r\\nif ((ret = BIO_push(ssl, con)) == NULL)\\r\\ngoto err;\\r\\nreturn (ret);\\r\\nerr:\\r\\nif (con != NULL)\\r\\nBIO_free(con);\\r\\n#endif\\r\\nreturn (NULL);\\r\\n}\\r\\nBIO *BIO_new_ssl(SSL_CTX *ctx, int client)\\r\\n{\\r\\nBIO *ret;\\r\\nSSL *ssl;\\r\\nif ((ret = BIO_new(BIO_f_ssl())) == NULL)\\r\\nreturn (NULL);\\r\\nif ((ssl = SSL_new(ctx)) == NULL) {\\r\\nBIO_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (client)\\r\\nSSL_set_connect_state(ssl);\\r\\nelse\\r\\nSSL_set_accept_state(ssl);\\r\\nBIO_set_ssl(ret, ssl, BIO_CLOSE);\\r\\nreturn (ret);\\r\\n}\\r\\nint BIO_ssl_copy_session_id(BIO *t, BIO *f)\\r\\n{\\r\\nt = BIO_find_type(t, BIO_TYPE_SSL);\\r\\nf = BIO_find_type(f, BIO_TYPE_SSL);\\r\\nif ((t == NULL) || (f == NULL))\\r\\nreturn (0);\\r\\nif ((((BIO_SSL *)t->ptr)->ssl == NULL) ||\\r\\n(((BIO_SSL *)f->ptr)->ssl == NULL))\\r\\nreturn (0);\\r\\nSSL_copy_session_id(((BIO_SSL *)t->ptr)->ssl, ((BIO_SSL *)f->ptr)->ssl);\\r\\nreturn (1);\\r\\n}\\r\\nvoid BIO_ssl_shutdown(BIO *b)\\r\\n{\\r\\nSSL *s;\\r\\nwhile (b != NULL) {\\r\\nif (b->method->type == BIO_TYPE_SSL) {\\r\\ns = ((BIO_SSL *)b->ptr)->ssl;\\r\\nSSL_shutdown(s);\\r\\nbreak;\\r\\n}\\r\\nb = b->next_bio;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_ocsp_c", "target": 0, "func": "static int i2r_ocsp_crlid(const X509V3_EXT_METHOD *method, void *in, BIO *bp,\\r\\nint ind)\\r\\n{\\r\\nOCSP_CRLID *a = in;\\r\\nif (a->crlUrl) {\\r\\nif (BIO_printf(bp, \"%*scrlUrl: \", ind, \"\") <= 0)\\r\\ngoto err;\\r\\nif (!ASN1_STRING_print(bp, (ASN1_STRING *)a->crlUrl))\\r\\ngoto err;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (a->crlNum) {\\r\\nif (BIO_printf(bp, \"%*scrlNum: \", ind, \"\") <= 0)\\r\\ngoto err;\\r\\nif (i2a_ASN1_INTEGER(bp, a->crlNum) <= 0)\\r\\ngoto err;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (a->crlTime) {\\r\\nif (BIO_printf(bp, \"%*scrlTime: \", ind, \"\") <= 0)\\r\\ngoto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp, a->crlTime))\\r\\ngoto err;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nstatic int i2r_ocsp_acutoff(const X509V3_EXT_METHOD *method, void *cutoff,\\r\\nBIO *bp, int ind)\\r\\n{\\r\\nif (BIO_printf(bp, \"%*s\", ind, \"\") <= 0)\\r\\nreturn 0;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp, cutoff))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int i2r_object(const X509V3_EXT_METHOD *method, void *oid, BIO *bp,\\r\\nint ind)\\r\\n{\\r\\nif (BIO_printf(bp, \"%*s\", ind, \"\") <= 0)\\r\\nreturn 0;\\r\\nif (i2a_ASN1_OBJECT(bp, oid) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void *ocsp_nonce_new(void)\\r\\n{\\r\\nreturn ASN1_OCTET_STRING_new();\\r\\n}\\r\\nstatic int i2d_ocsp_nonce(void *a, unsigned char **pp)\\r\\n{\\r\\nASN1_OCTET_STRING *os = a;\\r\\nif (pp) {\\r\\nmemcpy(*pp, os->data, os->length);\\r\\n*pp += os->length;\\r\\n}\\r\\nreturn os->length;\\r\\n}\\r\\nstatic void *d2i_ocsp_nonce(void *a, const unsigned char **pp, long length)\\r\\n{\\r\\nASN1_OCTET_STRING *os, **pos;\\r\\npos = a;\\r\\nif (!pos || !*pos)\\r\\nos = ASN1_OCTET_STRING_new();\\r\\nelse\\r\\nos = *pos;\\r\\nif (!ASN1_OCTET_STRING_set(os, *pp, length))\\r\\ngoto err;\\r\\n*pp += length;\\r\\nif (pos)\\r\\n*pos = os;\\r\\nreturn os;\\r\\nerr:\\r\\nif (os && (!pos || (*pos != os)))\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\nOCSPerr(OCSP_F_D2I_OCSP_NONCE, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic void ocsp_nonce_free(void *a)\\r\\n{\\r\\nM_ASN1_OCTET_STRING_free(a);\\r\\n}\\r\\nstatic int i2r_ocsp_nonce(const X509V3_EXT_METHOD *method, void *nonce,\\r\\nBIO *out, int indent)\\r\\n{\\r\\nif (BIO_printf(out, \"%*s\", indent, \"\") <= 0)\\r\\nreturn 0;\\r\\nif (i2a_ASN1_STRING(out, nonce, V_ASN1_OCTET_STRING) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int i2r_ocsp_nocheck(const X509V3_EXT_METHOD *method, void *nocheck,\\r\\nBIO *out, int indent)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic void *s2i_ocsp_nocheck(const X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, const char *str)\\r\\n{\\r\\nreturn ASN1_NULL_new();\\r\\n}\\r\\nstatic int i2r_ocsp_serviceloc(const X509V3_EXT_METHOD *method, void *in,\\r\\nBIO *bp, int ind)\\r\\n{\\r\\nint i;\\r\\nOCSP_SERVICELOC *a = in;\\r\\nACCESS_DESCRIPTION *ad;\\r\\nif (BIO_printf(bp, \"%*sIssuer: \", ind, \"\") <= 0)\\r\\ngoto err;\\r\\nif (X509_NAME_print_ex(bp, a->issuer, 0, XN_FLAG_ONELINE) <= 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < sk_ACCESS_DESCRIPTION_num(a->locator); i++) {\\r\\nad = sk_ACCESS_DESCRIPTION_value(a->locator, i);\\r\\nif (BIO_printf(bp, \"\\n%*s\", (2 * ind), \"\") <= 0)\\r\\ngoto err;\\r\\nif (i2a_ASN1_OBJECT(bp, ad->method) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \" - \") <= 0)\\r\\ngoto err;\\r\\nif (GENERAL_NAME_print(bp, ad->location) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_ameth_c", "target": 0, "func": "static int eckey_param2type(int *pptype, void **ppval, EC_KEY *ec_key)\\r\\n{\\r\\nconst EC_GROUP *group;\\r\\nint nid;\\r\\nif (ec_key == NULL || (group = EC_KEY_get0_group(ec_key)) == NULL) {\\r\\nECerr(EC_F_ECKEY_PARAM2TYPE, EC_R_MISSING_PARAMETERS);\\r\\nreturn 0;\\r\\n}\\r\\nif (EC_GROUP_get_asn1_flag(group)\\r\\n&& (nid = EC_GROUP_get_curve_name(group)))\\r\\n{\\r\\n*ppval = OBJ_nid2obj(nid);\\r\\n*pptype = V_ASN1_OBJECT;\\r\\n} else {\\r\\nASN1_STRING *pstr = NULL;\\r\\npstr = ASN1_STRING_new();\\r\\nif (!pstr)\\r\\nreturn 0;\\r\\npstr->length = i2d_ECParameters(ec_key, &pstr->data);\\r\\nif (pstr->length <= 0) {\\r\\nASN1_STRING_free(pstr);\\r\\nECerr(EC_F_ECKEY_PARAM2TYPE, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n*ppval = pstr;\\r\\n*pptype = V_ASN1_SEQUENCE;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int eckey_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\\r\\n{\\r\\nEC_KEY *ec_key = pkey->pkey.ec;\\r\\nvoid *pval = NULL;\\r\\nint ptype;\\r\\nunsigned char *penc = NULL, *p;\\r\\nint penclen;\\r\\nif (!eckey_param2type(&ptype, &pval, ec_key)) {\\r\\nECerr(EC_F_ECKEY_PUB_ENCODE, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\npenclen = i2o_ECPublicKey(ec_key, NULL);\\r\\nif (penclen <= 0)\\r\\ngoto err;\\r\\npenc = OPENSSL_malloc(penclen);\\r\\nif (!penc)\\r\\ngoto err;\\r\\np = penc;\\r\\npenclen = i2o_ECPublicKey(ec_key, &p);\\r\\nif (penclen <= 0)\\r\\ngoto err;\\r\\nif (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(EVP_PKEY_EC),\\r\\nptype, pval, penc, penclen))\\r\\nreturn 1;\\r\\nerr:\\r\\nif (ptype == V_ASN1_OBJECT)\\r\\nASN1_OBJECT_free(pval);\\r\\nelse\\r\\nASN1_STRING_free(pval);\\r\\nif (penc)\\r\\nOPENSSL_free(penc);\\r\\nreturn 0;\\r\\n}\\r\\nstatic EC_KEY *eckey_type2param(int ptype, void *pval)\\r\\n{\\r\\nEC_KEY *eckey = NULL;\\r\\nif (ptype == V_ASN1_SEQUENCE) {\\r\\nASN1_STRING *pstr = pval;\\r\\nconst unsigned char *pm = NULL;\\r\\nint pmlen;\\r\\npm = pstr->data;\\r\\npmlen = pstr->length;\\r\\nif (!(eckey = d2i_ECParameters(NULL, &pm, pmlen))) {\\r\\nECerr(EC_F_ECKEY_TYPE2PARAM, EC_R_DECODE_ERROR);\\r\\ngoto ecerr;\\r\\n}\\r\\n} else if (ptype == V_ASN1_OBJECT) {\\r\\nASN1_OBJECT *poid = pval;\\r\\nEC_GROUP *group;\\r\\nif ((eckey = EC_KEY_new()) == NULL) {\\r\\nECerr(EC_F_ECKEY_TYPE2PARAM, ERR_R_MALLOC_FAILURE);\\r\\ngoto ecerr;\\r\\n}\\r\\ngroup = EC_GROUP_new_by_curve_name(OBJ_obj2nid(poid));\\r\\nif (group == NULL)\\r\\ngoto ecerr;\\r\\nEC_GROUP_set_asn1_flag(group, OPENSSL_EC_NAMED_CURVE);\\r\\nif (EC_KEY_set_group(eckey, group) == 0)\\r\\ngoto ecerr;\\r\\nEC_GROUP_free(group);\\r\\n} else {\\r\\nECerr(EC_F_ECKEY_TYPE2PARAM, EC_R_DECODE_ERROR);\\r\\ngoto ecerr;\\r\\n}\\r\\nreturn eckey;\\r\\necerr:\\r\\nif (eckey)\\r\\nEC_KEY_free(eckey);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int eckey_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\\r\\n{\\r\\nconst unsigned char *p = NULL;\\r\\nvoid *pval;\\r\\nint ptype, pklen;\\r\\nEC_KEY *eckey = NULL;\\r\\nX509_ALGOR *palg;\\r\\nif (!X509_PUBKEY_get0_param(NULL, &p, &pklen, &palg, pubkey))\\r\\nreturn 0;\\r\\nX509_ALGOR_get0(NULL, &ptype, &pval, palg);\\r\\neckey = eckey_type2param(ptype, pval);\\r\\nif (!eckey) {\\r\\nECerr(EC_F_ECKEY_PUB_DECODE, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nif (!o2i_ECPublicKey(&eckey, &p, pklen)) {\\r\\nECerr(EC_F_ECKEY_PUB_DECODE, EC_R_DECODE_ERROR);\\r\\ngoto ecerr;\\r\\n}\\r\\nEVP_PKEY_assign_EC_KEY(pkey, eckey);\\r\\nreturn 1;\\r\\necerr:\\r\\nif (eckey)\\r\\nEC_KEY_free(eckey);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int eckey_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nint r;\\r\\nconst EC_GROUP *group = EC_KEY_get0_group(b->pkey.ec);\\r\\nconst EC_POINT *pa = EC_KEY_get0_public_key(a->pkey.ec),\\r\\n*pb = EC_KEY_get0_public_key(b->pkey.ec);\\r\\nr = EC_POINT_cmp(group, pa, pb, NULL);\\r\\nif (r == 0)\\r\\nreturn 1;\\r\\nif (r == 1)\\r\\nreturn 0;\\r\\nreturn -2;\\r\\n}\\r\\nstatic int eckey_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nconst unsigned char *p = NULL;\\r\\nvoid *pval;\\r\\nint ptype, pklen;\\r\\nEC_KEY *eckey = NULL;\\r\\nX509_ALGOR *palg;\\r\\nif (!PKCS8_pkey_get0(NULL, &p, &pklen, &palg, p8))\\r\\nreturn 0;\\r\\nX509_ALGOR_get0(NULL, &ptype, &pval, palg);\\r\\neckey = eckey_type2param(ptype, pval);\\r\\nif (!eckey)\\r\\ngoto ecliberr;\\r\\nif (!d2i_ECPrivateKey(&eckey, &p, pklen)) {\\r\\nECerr(EC_F_ECKEY_PRIV_DECODE, EC_R_DECODE_ERROR);\\r\\ngoto ecerr;\\r\\n}\\r\\nif (EC_KEY_get0_public_key(eckey) == NULL) {\\r\\nconst BIGNUM *priv_key;\\r\\nconst EC_GROUP *group;\\r\\nEC_POINT *pub_key;\\r\\ngroup = EC_KEY_get0_group(eckey);\\r\\npub_key = EC_POINT_new(group);\\r\\nif (pub_key == NULL) {\\r\\nECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);\\r\\ngoto ecliberr;\\r\\n}\\r\\nif (!EC_POINT_copy(pub_key, EC_GROUP_get0_generator(group))) {\\r\\nEC_POINT_free(pub_key);\\r\\nECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);\\r\\ngoto ecliberr;\\r\\n}\\r\\npriv_key = EC_KEY_get0_private_key(eckey);\\r\\nif (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, NULL)) {\\r\\nEC_POINT_free(pub_key);\\r\\nECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);\\r\\ngoto ecliberr;\\r\\n}\\r\\nif (EC_KEY_set_public_key(eckey, pub_key) == 0) {\\r\\nEC_POINT_free(pub_key);\\r\\nECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);\\r\\ngoto ecliberr;\\r\\n}\\r\\nEC_POINT_free(pub_key);\\r\\n}\\r\\nEVP_PKEY_assign_EC_KEY(pkey, eckey);\\r\\nreturn 1;\\r\\necliberr:\\r\\nECerr(EC_F_ECKEY_PRIV_DECODE, ERR_R_EC_LIB);\\r\\necerr:\\r\\nif (eckey)\\r\\nEC_KEY_free(eckey);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int eckey_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\\r\\n{\\r\\nEC_KEY *ec_key;\\r\\nunsigned char *ep, *p;\\r\\nint eplen, ptype;\\r\\nvoid *pval;\\r\\nunsigned int tmp_flags, old_flags;\\r\\nec_key = pkey->pkey.ec;\\r\\nif (!eckey_param2type(&ptype, &pval, ec_key)) {\\r\\nECerr(EC_F_ECKEY_PRIV_ENCODE, EC_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nold_flags = EC_KEY_get_enc_flags(ec_key);\\r\\ntmp_flags = old_flags | EC_PKEY_NO_PARAMETERS;\\r\\nEC_KEY_set_enc_flags(ec_key, tmp_flags);\\r\\neplen = i2d_ECPrivateKey(ec_key, NULL);\\r\\nif (!eplen) {\\r\\nEC_KEY_set_enc_flags(ec_key, old_flags);\\r\\nECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nep = (unsigned char *)OPENSSL_malloc(eplen);\\r\\nif (!ep) {\\r\\nEC_KEY_set_enc_flags(ec_key, old_flags);\\r\\nECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\np = ep;\\r\\nif (!i2d_ECPrivateKey(ec_key, &p)) {\\r\\nEC_KEY_set_enc_flags(ec_key, old_flags);\\r\\nOPENSSL_free(ep);\\r\\nECerr(EC_F_ECKEY_PRIV_ENCODE, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nEC_KEY_set_enc_flags(ec_key, old_flags);\\r\\nif (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_X9_62_id_ecPublicKey), 0,\\r\\nptype, pval, ep, eplen))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_ec_size(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn ECDSA_size(pkey->pkey.ec);\\r\\n}\\r\\nstatic int ec_bits(const EVP_PKEY *pkey)\\r\\n{\\r\\nBIGNUM *order = BN_new();\\r\\nconst EC_GROUP *group;\\r\\nint ret;\\r\\nif (!order) {\\r\\nERR_clear_error();\\r\\nreturn 0;\\r\\n}\\r\\ngroup = EC_KEY_get0_group(pkey->pkey.ec);\\r\\nif (!EC_GROUP_get_order(group, order, NULL)) {\\r\\nERR_clear_error();\\r\\nreturn 0;\\r\\n}\\r\\nret = BN_num_bits(order);\\r\\nBN_free(order);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ec_missing_parameters(const EVP_PKEY *pkey)\\r\\n{\\r\\nif (EC_KEY_get0_group(pkey->pkey.ec) == NULL)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ec_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)\\r\\n{\\r\\nEC_GROUP *group = EC_GROUP_dup(EC_KEY_get0_group(from->pkey.ec));\\r\\nif (group == NULL)\\r\\nreturn 0;\\r\\nif (EC_KEY_set_group(to->pkey.ec, group) == 0)\\r\\nreturn 0;\\r\\nEC_GROUP_free(group);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ec_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nconst EC_GROUP *group_a = EC_KEY_get0_group(a->pkey.ec),\\r\\n*group_b = EC_KEY_get0_group(b->pkey.ec);\\r\\nif (EC_GROUP_cmp(group_a, group_b, NULL))\\r\\nreturn 0;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nstatic void int_ec_free(EVP_PKEY *pkey)\\r\\n{\\r\\nEC_KEY_free(pkey->pkey.ec);\\r\\n}\\r\\nstatic int do_EC_KEY_print(BIO *bp, const EC_KEY *x, int off, int ktype)\\r\\n{\\r\\nunsigned char *buffer = NULL;\\r\\nconst char *ecstr;\\r\\nsize_t buf_len = 0, i;\\r\\nint ret = 0, reason = ERR_R_BIO_LIB;\\r\\nBIGNUM *pub_key = NULL, *order = NULL;\\r\\nBN_CTX *ctx = NULL;\\r\\nconst EC_GROUP *group;\\r\\nconst EC_POINT *public_key;\\r\\nconst BIGNUM *priv_key;\\r\\nif (x == NULL || (group = EC_KEY_get0_group(x)) == NULL) {\\r\\nreason = ERR_R_PASSED_NULL_PARAMETER;\\r\\ngoto err;\\r\\n}\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL) {\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (ktype > 0) {\\r\\npublic_key = EC_KEY_get0_public_key(x);\\r\\nif (public_key != NULL) {\\r\\nif ((pub_key = EC_POINT_point2bn(group, public_key,\\r\\nEC_KEY_get_conv_form(x), NULL,\\r\\nctx)) == NULL) {\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\nbuf_len = (size_t)BN_num_bytes(pub_key);\\r\\n}\\r\\n}\\r\\nif (ktype == 2) {\\r\\npriv_key = EC_KEY_get0_private_key(x);\\r\\nif (priv_key && (i = (size_t)BN_num_bytes(priv_key)) > buf_len)\\r\\nbuf_len = i;\\r\\n} else\\r\\npriv_key = NULL;\\r\\nif (ktype > 0) {\\r\\nbuf_len += 10;\\r\\nif ((buffer = OPENSSL_malloc(buf_len)) == NULL) {\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (ktype == 2)\\r\\necstr = \"Private-Key\";\\r\\nelse if (ktype == 1)\\r\\necstr = \"Public-Key\";\\r\\nelse\\r\\necstr = \"ECDSA-Parameters\";\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nif ((order = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (!EC_GROUP_get_order(group, order, NULL))\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"%s: (%d bit)\\n\", ecstr, BN_num_bits(order)) <= 0)\\r\\ngoto err;\\r\\nif ((priv_key != NULL) && !ASN1_bn_print(bp, \"priv:\", priv_key,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\nif ((pub_key != NULL) && !ASN1_bn_print(bp, \"pub: \", pub_key,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\nif (!ECPKParameters_print(bp, group, off))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret)\\r\\nECerr(EC_F_DO_EC_KEY_PRINT, reason);\\r\\nif (pub_key)\\r\\nBN_free(pub_key);\\r\\nif (order)\\r\\nBN_free(order);\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nif (buffer != NULL)\\r\\nOPENSSL_free(buffer);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int eckey_param_decode(EVP_PKEY *pkey,\\r\\nconst unsigned char **pder, int derlen)\\r\\n{\\r\\nEC_KEY *eckey;\\r\\nif (!(eckey = d2i_ECParameters(NULL, pder, derlen))) {\\r\\nECerr(EC_F_ECKEY_PARAM_DECODE, ERR_R_EC_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_assign_EC_KEY(pkey, eckey);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int eckey_param_encode(const EVP_PKEY *pkey, unsigned char **pder)\\r\\n{\\r\\nreturn i2d_ECParameters(pkey->pkey.ec, pder);\\r\\n}\\r\\nstatic int eckey_param_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_EC_KEY_print(bp, pkey->pkey.ec, indent, 0);\\r\\n}\\r\\nstatic int eckey_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_EC_KEY_print(bp, pkey->pkey.ec, indent, 1);\\r\\n}\\r\\nstatic int eckey_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_EC_KEY_print(bp, pkey->pkey.ec, indent, 2);\\r\\n}\\r\\nstatic int old_ec_priv_decode(EVP_PKEY *pkey,\\r\\nconst unsigned char **pder, int derlen)\\r\\n{\\r\\nEC_KEY *ec;\\r\\nif (!(ec = d2i_ECPrivateKey(NULL, pder, derlen))) {\\r\\nECerr(EC_F_OLD_EC_PRIV_DECODE, EC_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_assign_EC_KEY(pkey, ec);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int old_ec_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)\\r\\n{\\r\\nreturn i2d_ECPrivateKey(pkey->pkey.ec, pder);\\r\\n}\\r\\nstatic int ec_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)\\r\\n{\\r\\nswitch (op) {\\r\\ncase ASN1_PKEY_CTRL_PKCS7_SIGN:\\r\\nif (arg1 == 0) {\\r\\nint snid, hnid;\\r\\nX509_ALGOR *alg1, *alg2;\\r\\nPKCS7_SIGNER_INFO_get0_algs(arg2, NULL, &alg1, &alg2);\\r\\nif (alg1 == NULL || alg1->algorithm == NULL)\\r\\nreturn -1;\\r\\nhnid = OBJ_obj2nid(alg1->algorithm);\\r\\nif (hnid == NID_undef)\\r\\nreturn -1;\\r\\nif (!OBJ_find_sigid_by_algs(&snid, hnid, EVP_PKEY_id(pkey)))\\r\\nreturn -1;\\r\\nX509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);\\r\\n}\\r\\nreturn 1;\\r\\n#ifndef OPENSSL_NO_CMS\\r\\ncase ASN1_PKEY_CTRL_CMS_SIGN:\\r\\nif (arg1 == 0) {\\r\\nint snid, hnid;\\r\\nX509_ALGOR *alg1, *alg2;\\r\\nCMS_SignerInfo_get0_algs(arg2, NULL, NULL, &alg1, &alg2);\\r\\nif (alg1 == NULL || alg1->algorithm == NULL)\\r\\nreturn -1;\\r\\nhnid = OBJ_obj2nid(alg1->algorithm);\\r\\nif (hnid == NID_undef)\\r\\nreturn -1;\\r\\nif (!OBJ_find_sigid_by_algs(&snid, hnid, EVP_PKEY_id(pkey)))\\r\\nreturn -1;\\r\\nX509_ALGOR_set0(alg2, OBJ_nid2obj(snid), V_ASN1_UNDEF, 0);\\r\\n}\\r\\nreturn 1;\\r\\ncase ASN1_PKEY_CTRL_CMS_ENVELOPE:\\r\\nif (arg1 == 1)\\r\\nreturn ecdh_cms_decrypt(arg2);\\r\\nelse if (arg1 == 0)\\r\\nreturn ecdh_cms_encrypt(arg2);\\r\\nreturn -2;\\r\\ncase ASN1_PKEY_CTRL_CMS_RI_TYPE:\\r\\n*(int *)arg2 = CMS_RECIPINFO_AGREE;\\r\\nreturn 1;\\r\\n#endif\\r\\ncase ASN1_PKEY_CTRL_DEFAULT_MD_NID:\\r\\n*(int *)arg2 = NID_sha256;\\r\\nreturn 2;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\n}\\r\\nstatic int ecdh_cms_set_peerkey(EVP_PKEY_CTX *pctx,\\r\\nX509_ALGOR *alg, ASN1_BIT_STRING *pubkey)\\r\\n{\\r\\nASN1_OBJECT *aoid;\\r\\nint atype;\\r\\nvoid *aval;\\r\\nint rv = 0;\\r\\nEVP_PKEY *pkpeer = NULL;\\r\\nEC_KEY *ecpeer = NULL;\\r\\nconst unsigned char *p;\\r\\nint plen;\\r\\nX509_ALGOR_get0(&aoid, &atype, &aval, alg);\\r\\nif (OBJ_obj2nid(aoid) != NID_X9_62_id_ecPublicKey)\\r\\ngoto err;\\r\\nif (atype == V_ASN1_UNDEF || atype == V_ASN1_NULL) {\\r\\nconst EC_GROUP *grp;\\r\\nEVP_PKEY *pk;\\r\\npk = EVP_PKEY_CTX_get0_pkey(pctx);\\r\\nif (!pk)\\r\\ngoto err;\\r\\ngrp = EC_KEY_get0_group(pk->pkey.ec);\\r\\necpeer = EC_KEY_new();\\r\\nif (!ecpeer)\\r\\ngoto err;\\r\\nif (!EC_KEY_set_group(ecpeer, grp))\\r\\ngoto err;\\r\\n} else {\\r\\necpeer = eckey_type2param(atype, aval);\\r\\nif (!ecpeer)\\r\\ngoto err;\\r\\n}\\r\\nplen = ASN1_STRING_length(pubkey);\\r\\np = ASN1_STRING_data(pubkey);\\r\\nif (!p || !plen)\\r\\ngoto err;\\r\\nif (!o2i_ECPublicKey(&ecpeer, &p, plen))\\r\\ngoto err;\\r\\npkpeer = EVP_PKEY_new();\\r\\nif (!pkpeer)\\r\\ngoto err;\\r\\nEVP_PKEY_set1_EC_KEY(pkpeer, ecpeer);\\r\\nif (EVP_PKEY_derive_set_peer(pctx, pkpeer) > 0)\\r\\nrv = 1;\\r\\nerr:\\r\\nif (ecpeer)\\r\\nEC_KEY_free(ecpeer);\\r\\nif (pkpeer)\\r\\nEVP_PKEY_free(pkpeer);\\r\\nreturn rv;\\r\\n}\\r\\nstatic int ecdh_cms_set_kdf_param(EVP_PKEY_CTX *pctx, int eckdf_nid)\\r\\n{\\r\\nint kdf_nid, kdfmd_nid, cofactor;\\r\\nconst EVP_MD *kdf_md;\\r\\nif (eckdf_nid == NID_undef)\\r\\nreturn 0;\\r\\nif (!OBJ_find_sigid_algs(eckdf_nid, &kdfmd_nid, &kdf_nid))\\r\\nreturn 0;\\r\\nif (kdf_nid == NID_dh_std_kdf)\\r\\ncofactor = 0;\\r\\nelse if (kdf_nid == NID_dh_cofactor_kdf)\\r\\ncofactor = 1;\\r\\nelse\\r\\nreturn 0;\\r\\nif (EVP_PKEY_CTX_set_ecdh_cofactor_mode(pctx, cofactor) <= 0)\\r\\nreturn 0;\\r\\nif (EVP_PKEY_CTX_set_ecdh_kdf_type(pctx, EVP_PKEY_ECDH_KDF_X9_62) <= 0)\\r\\nreturn 0;\\r\\nkdf_md = EVP_get_digestbynid(kdfmd_nid);\\r\\nif (!kdf_md)\\r\\nreturn 0;\\r\\nif (EVP_PKEY_CTX_set_ecdh_kdf_md(pctx, kdf_md) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ecdh_cms_set_shared_info(EVP_PKEY_CTX *pctx, CMS_RecipientInfo *ri)\\r\\n{\\r\\nint rv = 0;\\r\\nX509_ALGOR *alg, *kekalg = NULL;\\r\\nASN1_OCTET_STRING *ukm;\\r\\nconst unsigned char *p;\\r\\nunsigned char *der = NULL;\\r\\nint plen, keylen;\\r\\nconst EVP_CIPHER *kekcipher;\\r\\nEVP_CIPHER_CTX *kekctx;\\r\\nif (!CMS_RecipientInfo_kari_get0_alg(ri, &alg, &ukm))\\r\\nreturn 0;\\r\\nif (!ecdh_cms_set_kdf_param(pctx, OBJ_obj2nid(alg->algorithm))) {\\r\\nECerr(EC_F_ECDH_CMS_SET_SHARED_INFO, EC_R_KDF_PARAMETER_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (alg->parameter->type != V_ASN1_SEQUENCE)\\r\\nreturn 0;\\r\\np = alg->parameter->value.sequence->data;\\r\\nplen = alg->parameter->value.sequence->length;\\r\\nkekalg = d2i_X509_ALGOR(NULL, &p, plen);\\r\\nif (!kekalg)\\r\\ngoto err;\\r\\nkekctx = CMS_RecipientInfo_kari_get0_ctx(ri);\\r\\nif (!kekctx)\\r\\ngoto err;\\r\\nkekcipher = EVP_get_cipherbyobj(kekalg->algorithm);\\r\\nif (!kekcipher || EVP_CIPHER_mode(kekcipher) != EVP_CIPH_WRAP_MODE)\\r\\ngoto err;\\r\\nif (!EVP_EncryptInit_ex(kekctx, kekcipher, NULL, NULL, NULL))\\r\\ngoto err;\\r\\nif (EVP_CIPHER_asn1_to_param(kekctx, kekalg->parameter) <= 0)\\r\\ngoto err;\\r\\nkeylen = EVP_CIPHER_CTX_key_length(kekctx);\\r\\nif (EVP_PKEY_CTX_set_ecdh_kdf_outlen(pctx, keylen) <= 0)\\r\\ngoto err;\\r\\nplen = CMS_SharedInfo_encode(&der, kekalg, ukm, keylen);\\r\\nif (!plen)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set0_ecdh_kdf_ukm(pctx, der, plen) <= 0)\\r\\ngoto err;\\r\\nder = NULL;\\r\\nrv = 1;\\r\\nerr:\\r\\nif (kekalg)\\r\\nX509_ALGOR_free(kekalg);\\r\\nif (der)\\r\\nOPENSSL_free(der);\\r\\nreturn rv;\\r\\n}\\r\\nstatic int ecdh_cms_decrypt(CMS_RecipientInfo *ri)\\r\\n{\\r\\nEVP_PKEY_CTX *pctx;\\r\\npctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\\r\\nif (!pctx)\\r\\nreturn 0;\\r\\nif (!EVP_PKEY_CTX_get0_peerkey(pctx)) {\\r\\nX509_ALGOR *alg;\\r\\nASN1_BIT_STRING *pubkey;\\r\\nif (!CMS_RecipientInfo_kari_get0_orig_id(ri, &alg, &pubkey,\\r\\nNULL, NULL, NULL))\\r\\nreturn 0;\\r\\nif (!alg || !pubkey)\\r\\nreturn 0;\\r\\nif (!ecdh_cms_set_peerkey(pctx, alg, pubkey)) {\\r\\nECerr(EC_F_ECDH_CMS_DECRYPT, EC_R_PEER_KEY_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (!ecdh_cms_set_shared_info(pctx, ri)) {\\r\\nECerr(EC_F_ECDH_CMS_DECRYPT, EC_R_SHARED_INFO_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ecdh_cms_encrypt(CMS_RecipientInfo *ri)\\r\\n{\\r\\nEVP_PKEY_CTX *pctx;\\r\\nEVP_PKEY *pkey;\\r\\nEVP_CIPHER_CTX *ctx;\\r\\nint keylen;\\r\\nX509_ALGOR *talg, *wrap_alg = NULL;\\r\\nASN1_OBJECT *aoid;\\r\\nASN1_BIT_STRING *pubkey;\\r\\nASN1_STRING *wrap_str;\\r\\nASN1_OCTET_STRING *ukm;\\r\\nunsigned char *penc = NULL;\\r\\nint penclen;\\r\\nint rv = 0;\\r\\nint ecdh_nid, kdf_type, kdf_nid, wrap_nid;\\r\\nconst EVP_MD *kdf_md;\\r\\npctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\\r\\nif (!pctx)\\r\\nreturn 0;\\r\\npkey = EVP_PKEY_CTX_get0_pkey(pctx);\\r\\nif (!CMS_RecipientInfo_kari_get0_orig_id(ri, &talg, &pubkey,\\r\\nNULL, NULL, NULL))\\r\\ngoto err;\\r\\nX509_ALGOR_get0(&aoid, NULL, NULL, talg);\\r\\nif (aoid == OBJ_nid2obj(NID_undef)) {\\r\\nEC_KEY *eckey = pkey->pkey.ec;\\r\\nunsigned char *p;\\r\\npenclen = i2o_ECPublicKey(eckey, NULL);\\r\\nif (penclen <= 0)\\r\\ngoto err;\\r\\npenc = OPENSSL_malloc(penclen);\\r\\nif (!penc)\\r\\ngoto err;\\r\\np = penc;\\r\\npenclen = i2o_ECPublicKey(eckey, &p);\\r\\nif (penclen <= 0)\\r\\ngoto err;\\r\\nASN1_STRING_set0(pubkey, penc, penclen);\\r\\npubkey->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\npubkey->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\npenc = NULL;\\r\\nX509_ALGOR_set0(talg, OBJ_nid2obj(NID_X9_62_id_ecPublicKey),\\r\\nV_ASN1_UNDEF, NULL);\\r\\n}\\r\\nkdf_type = EVP_PKEY_CTX_get_ecdh_kdf_type(pctx);\\r\\nif (kdf_type <= 0)\\r\\ngoto err;\\r\\nif (!EVP_PKEY_CTX_get_ecdh_kdf_md(pctx, &kdf_md))\\r\\ngoto err;\\r\\necdh_nid = EVP_PKEY_CTX_get_ecdh_cofactor_mode(pctx);\\r\\nif (ecdh_nid < 0)\\r\\ngoto err;\\r\\nelse if (ecdh_nid == 0)\\r\\necdh_nid = NID_dh_std_kdf;\\r\\nelse if (ecdh_nid == 1)\\r\\necdh_nid = NID_dh_cofactor_kdf;\\r\\nif (kdf_type == EVP_PKEY_ECDH_KDF_NONE) {\\r\\nkdf_type = EVP_PKEY_ECDH_KDF_X9_62;\\r\\nif (EVP_PKEY_CTX_set_ecdh_kdf_type(pctx, kdf_type) <= 0)\\r\\ngoto err;\\r\\n} else\\r\\ngoto err;\\r\\nif (kdf_md == NULL) {\\r\\nkdf_md = EVP_sha1();\\r\\nif (EVP_PKEY_CTX_set_ecdh_kdf_md(pctx, kdf_md) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!CMS_RecipientInfo_kari_get0_alg(ri, &talg, &ukm))\\r\\ngoto err;\\r\\nif (!OBJ_find_sigid_by_algs(&kdf_nid, EVP_MD_type(kdf_md), ecdh_nid))\\r\\ngoto err;\\r\\nctx = CMS_RecipientInfo_kari_get0_ctx(ri);\\r\\nwrap_nid = EVP_CIPHER_CTX_type(ctx);\\r\\nkeylen = EVP_CIPHER_CTX_key_length(ctx);\\r\\nwrap_alg = X509_ALGOR_new();\\r\\nif (!wrap_alg)\\r\\ngoto err;\\r\\nwrap_alg->algorithm = OBJ_nid2obj(wrap_nid);\\r\\nwrap_alg->parameter = ASN1_TYPE_new();\\r\\nif (!wrap_alg->parameter)\\r\\ngoto err;\\r\\nif (EVP_CIPHER_param_to_asn1(ctx, wrap_alg->parameter) <= 0)\\r\\ngoto err;\\r\\nif (ASN1_TYPE_get(wrap_alg->parameter) == NID_undef) {\\r\\nASN1_TYPE_free(wrap_alg->parameter);\\r\\nwrap_alg->parameter = NULL;\\r\\n}\\r\\nif (EVP_PKEY_CTX_set_ecdh_kdf_outlen(pctx, keylen) <= 0)\\r\\ngoto err;\\r\\npenclen = CMS_SharedInfo_encode(&penc, wrap_alg, ukm, keylen);\\r\\nif (!penclen)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set0_ecdh_kdf_ukm(pctx, penc, penclen) <= 0)\\r\\ngoto err;\\r\\npenc = NULL;\\r\\npenclen = i2d_X509_ALGOR(wrap_alg, &penc);\\r\\nif (!penc || !penclen)\\r\\ngoto err;\\r\\nwrap_str = ASN1_STRING_new();\\r\\nif (!wrap_str)\\r\\ngoto err;\\r\\nASN1_STRING_set0(wrap_str, penc, penclen);\\r\\npenc = NULL;\\r\\nX509_ALGOR_set0(talg, OBJ_nid2obj(kdf_nid), V_ASN1_SEQUENCE, wrap_str);\\r\\nrv = 1;\\r\\nerr:\\r\\nif (penc)\\r\\nOPENSSL_free(penc);\\r\\nif (wrap_alg)\\r\\nX509_ALGOR_free(wrap_alg);\\r\\nreturn rv;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_req_utils_c", "target": 0, "func": "int TS_REQ_set_version(TS_REQ *a, long version)\\r\\n{\\r\\nreturn ASN1_INTEGER_set(a->version, version);\\r\\n}\\r\\nlong TS_REQ_get_version(const TS_REQ *a)\\r\\n{\\r\\nreturn ASN1_INTEGER_get(a->version);\\r\\n}\\r\\nint TS_REQ_set_msg_imprint(TS_REQ *a, TS_MSG_IMPRINT *msg_imprint)\\r\\n{\\r\\nTS_MSG_IMPRINT *new_msg_imprint;\\r\\nif (a->msg_imprint == msg_imprint)\\r\\nreturn 1;\\r\\nnew_msg_imprint = TS_MSG_IMPRINT_dup(msg_imprint);\\r\\nif (new_msg_imprint == NULL) {\\r\\nTSerr(TS_F_TS_REQ_SET_MSG_IMPRINT, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nTS_MSG_IMPRINT_free(a->msg_imprint);\\r\\na->msg_imprint = new_msg_imprint;\\r\\nreturn 1;\\r\\n}\\r\\nTS_MSG_IMPRINT *TS_REQ_get_msg_imprint(TS_REQ *a)\\r\\n{\\r\\nreturn a->msg_imprint;\\r\\n}\\r\\nint TS_MSG_IMPRINT_set_algo(TS_MSG_IMPRINT *a, X509_ALGOR *alg)\\r\\n{\\r\\nX509_ALGOR *new_alg;\\r\\nif (a->hash_algo == alg)\\r\\nreturn 1;\\r\\nnew_alg = X509_ALGOR_dup(alg);\\r\\nif (new_alg == NULL) {\\r\\nTSerr(TS_F_TS_MSG_IMPRINT_SET_ALGO, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nX509_ALGOR_free(a->hash_algo);\\r\\na->hash_algo = new_alg;\\r\\nreturn 1;\\r\\n}\\r\\nX509_ALGOR *TS_MSG_IMPRINT_get_algo(TS_MSG_IMPRINT *a)\\r\\n{\\r\\nreturn a->hash_algo;\\r\\n}\\r\\nint TS_MSG_IMPRINT_set_msg(TS_MSG_IMPRINT *a, unsigned char *d, int len)\\r\\n{\\r\\nreturn ASN1_OCTET_STRING_set(a->hashed_msg, d, len);\\r\\n}\\r\\nASN1_OCTET_STRING *TS_MSG_IMPRINT_get_msg(TS_MSG_IMPRINT *a)\\r\\n{\\r\\nreturn a->hashed_msg;\\r\\n}\\r\\nint TS_REQ_set_policy_id(TS_REQ *a, ASN1_OBJECT *policy)\\r\\n{\\r\\nASN1_OBJECT *new_policy;\\r\\nif (a->policy_id == policy)\\r\\nreturn 1;\\r\\nnew_policy = OBJ_dup(policy);\\r\\nif (new_policy == NULL) {\\r\\nTSerr(TS_F_TS_REQ_SET_POLICY_ID, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_OBJECT_free(a->policy_id);\\r\\na->policy_id = new_policy;\\r\\nreturn 1;\\r\\n}\\r\\nASN1_OBJECT *TS_REQ_get_policy_id(TS_REQ *a)\\r\\n{\\r\\nreturn a->policy_id;\\r\\n}\\r\\nint TS_REQ_set_nonce(TS_REQ *a, const ASN1_INTEGER *nonce)\\r\\n{\\r\\nASN1_INTEGER *new_nonce;\\r\\nif (a->nonce == nonce)\\r\\nreturn 1;\\r\\nnew_nonce = ASN1_INTEGER_dup(nonce);\\r\\nif (new_nonce == NULL) {\\r\\nTSerr(TS_F_TS_REQ_SET_NONCE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_INTEGER_free(a->nonce);\\r\\na->nonce = new_nonce;\\r\\nreturn 1;\\r\\n}\\r\\nconst ASN1_INTEGER *TS_REQ_get_nonce(const TS_REQ *a)\\r\\n{\\r\\nreturn a->nonce;\\r\\n}\\r\\nint TS_REQ_set_cert_req(TS_REQ *a, int cert_req)\\r\\n{\\r\\na->cert_req = cert_req ? 0xFF : 0x00;\\r\\nreturn 1;\\r\\n}\\r\\nint TS_REQ_get_cert_req(const TS_REQ *a)\\r\\n{\\r\\nreturn a->cert_req ? 1 : 0;\\r\\n}\\r\\nvoid TS_REQ_ext_free(TS_REQ *a)\\r\\n{\\r\\nif (!a)\\r\\nreturn;\\r\\nsk_X509_EXTENSION_pop_free(a->extensions, X509_EXTENSION_free);\\r\\na->extensions = NULL;\\r\\n}\\r\\nint TS_REQ_get_ext_count(TS_REQ *a)\\r\\n{\\r\\nreturn X509v3_get_ext_count(a->extensions);\\r\\n}\\r\\nint TS_REQ_get_ext_by_NID(TS_REQ *a, int nid, int lastpos)\\r\\n{\\r\\nreturn X509v3_get_ext_by_NID(a->extensions, nid, lastpos);\\r\\n}\\r\\nint TS_REQ_get_ext_by_OBJ(TS_REQ *a, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn X509v3_get_ext_by_OBJ(a->extensions, obj, lastpos);\\r\\n}\\r\\nint TS_REQ_get_ext_by_critical(TS_REQ *a, int crit, int lastpos)\\r\\n{\\r\\nreturn X509v3_get_ext_by_critical(a->extensions, crit, lastpos);\\r\\n}\\r\\nX509_EXTENSION *TS_REQ_get_ext(TS_REQ *a, int loc)\\r\\n{\\r\\nreturn X509v3_get_ext(a->extensions, loc);\\r\\n}\\r\\nX509_EXTENSION *TS_REQ_delete_ext(TS_REQ *a, int loc)\\r\\n{\\r\\nreturn X509v3_delete_ext(a->extensions, loc);\\r\\n}\\r\\nint TS_REQ_add_ext(TS_REQ *a, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn X509v3_add_ext(&a->extensions, ex, loc) != NULL;\\r\\n}\\r\\nvoid *TS_REQ_get_ext_d2i(TS_REQ *a, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(a->extensions, nid, crit, idx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p_sign_c", "target": 0, "func": "void EVP_SignInit(EVP_MD_CTX *ctx, EVP_MD *type)\\r\\n{\\r\\nEVP_DigestInit_ex(ctx, type);\\r\\n}\\r\\nvoid EVP_SignUpdate(EVP_MD_CTX *ctx, unsigned char *data, unsigned int count)\\r\\n{\\r\\nEVP_DigestUpdate(ctx, data, count);\\r\\n}\\r\\nint EVP_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,\\r\\nunsigned int *siglen, EVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char m[EVP_MAX_MD_SIZE];\\r\\nunsigned int m_len;\\r\\nint i = 0, ok = 0, v;\\r\\nEVP_MD_CTX tmp_ctx;\\r\\nEVP_PKEY_CTX *pkctx = NULL;\\r\\n*siglen = 0;\\r\\nEVP_MD_CTX_init(&tmp_ctx);\\r\\nif (!EVP_MD_CTX_copy_ex(&tmp_ctx, ctx))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&tmp_ctx, &(m[0]), &m_len))\\r\\ngoto err;\\r\\nEVP_MD_CTX_cleanup(&tmp_ctx);\\r\\nif (ctx->digest->flags & EVP_MD_FLAG_PKEY_METHOD_SIGNATURE) {\\r\\nsize_t sltmp = (size_t)EVP_PKEY_size(pkey);\\r\\ni = 0;\\r\\npkctx = EVP_PKEY_CTX_new(pkey, NULL);\\r\\nif (!pkctx)\\r\\ngoto err;\\r\\nif (EVP_PKEY_sign_init(pkctx) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set_signature_md(pkctx, ctx->digest) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_sign(pkctx, sigret, &sltmp, m, m_len) <= 0)\\r\\ngoto err;\\r\\n*siglen = sltmp;\\r\\ni = 1;\\r\\nerr:\\r\\nEVP_PKEY_CTX_free(pkctx);\\r\\nreturn i;\\r\\n}\\r\\nfor (i = 0; i < 4; i++) {\\r\\nv = ctx->digest->required_pkey_type[i];\\r\\nif (v == 0)\\r\\nbreak;\\r\\nif (pkey->type == v) {\\r\\nok = 1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ok) {\\r\\nEVPerr(EVP_F_EVP_SIGNFINAL, EVP_R_WRONG_PUBLIC_KEY_TYPE);\\r\\nreturn (0);\\r\\n}\\r\\nif (ctx->digest->sign == NULL) {\\r\\nEVPerr(EVP_F_EVP_SIGNFINAL, EVP_R_NO_SIGN_FUNCTION_CONFIGURED);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (ctx->digest->sign(ctx->digest->type, m, m_len, sigret, siglen,\\r\\npkey->pkey.ptr));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_check_c", "target": 0, "func": "int DH_check(const DH *dh, int *ret)\\r\\n{\\r\\nint ok = 0;\\r\\nBN_CTX *ctx = NULL;\\r\\nBN_ULONG l;\\r\\nBIGNUM *t1 = NULL, *t2 = NULL;\\r\\n*ret = 0;\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nif (t1 == NULL)\\r\\ngoto err;\\r\\nt2 = BN_CTX_get(ctx);\\r\\nif (t2 == NULL)\\r\\ngoto err;\\r\\nif (dh->q) {\\r\\nif (BN_cmp(dh->g, BN_value_one()) <= 0)\\r\\n*ret |= DH_NOT_SUITABLE_GENERATOR;\\r\\nelse if (BN_cmp(dh->g, dh->p) >= 0)\\r\\n*ret |= DH_NOT_SUITABLE_GENERATOR;\\r\\nelse {\\r\\nif (!BN_mod_exp(t1, dh->g, dh->q, dh->p, ctx))\\r\\ngoto err;\\r\\nif (!BN_is_one(t1))\\r\\n*ret |= DH_NOT_SUITABLE_GENERATOR;\\r\\n}\\r\\nif (!BN_is_prime_ex(dh->q, BN_prime_checks, ctx, NULL))\\r\\n*ret |= DH_CHECK_Q_NOT_PRIME;\\r\\nif (!BN_div(t1, t2, dh->p, dh->q, ctx))\\r\\ngoto err;\\r\\nif (!BN_is_one(t2))\\r\\n*ret |= DH_CHECK_INVALID_Q_VALUE;\\r\\nif (dh->j && BN_cmp(dh->j, t1))\\r\\n*ret |= DH_CHECK_INVALID_J_VALUE;\\r\\n} else if (BN_is_word(dh->g, DH_GENERATOR_2)) {\\r\\nl = BN_mod_word(dh->p, 24);\\r\\nif (l != 11)\\r\\n*ret |= DH_NOT_SUITABLE_GENERATOR;\\r\\n}\\r\\n#if 0\\r\\nelse if (BN_is_word(dh->g, DH_GENERATOR_3)) {\\r\\nl = BN_mod_word(dh->p, 12);\\r\\nif (l != 5)\\r\\n*ret |= DH_NOT_SUITABLE_GENERATOR;\\r\\n}\\r\\n#endif\\r\\nelse if (BN_is_word(dh->g, DH_GENERATOR_5)) {\\r\\nl = BN_mod_word(dh->p, 10);\\r\\nif ((l != 3) && (l != 7))\\r\\n*ret |= DH_NOT_SUITABLE_GENERATOR;\\r\\n} else\\r\\n*ret |= DH_UNABLE_TO_CHECK_GENERATOR;\\r\\nif (!BN_is_prime_ex(dh->p, BN_prime_checks, ctx, NULL))\\r\\n*ret |= DH_CHECK_P_NOT_PRIME;\\r\\nelse if (!dh->q) {\\r\\nif (!BN_rshift1(t1, dh->p))\\r\\ngoto err;\\r\\nif (!BN_is_prime_ex(t1, BN_prime_checks, ctx, NULL))\\r\\n*ret |= DH_CHECK_P_NOT_SAFE_PRIME;\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (ctx != NULL) {\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nreturn (ok);\\r\\n}\\r\\nint DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)\\r\\n{\\r\\nint ok = 0;\\r\\nBIGNUM *q = NULL;\\r\\n*ret = 0;\\r\\nq = BN_new();\\r\\nif (q == NULL)\\r\\ngoto err;\\r\\nBN_set_word(q, 1);\\r\\nif (BN_cmp(pub_key, q) <= 0)\\r\\n*ret |= DH_CHECK_PUBKEY_TOO_SMALL;\\r\\nBN_copy(q, dh->p);\\r\\nBN_sub_word(q, 1);\\r\\nif (BN_cmp(pub_key, q) >= 0)\\r\\n*ret |= DH_CHECK_PUBKEY_TOO_LARGE;\\r\\nok = 1;\\r\\nerr:\\r\\nif (q != NULL)\\r\\nBN_free(q);\\r\\nreturn (ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_i_cfb64_c", "target": 0, "func": "void idea_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, IDEA_KEY_SCHEDULE *schedule,\\r\\nunsigned char *ivec, int *num, int encrypt)\\r\\n{\\r\\nregister unsigned long v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv, c, cc;\\r\\niv = (unsigned char *)ivec;\\r\\nif (encrypt) {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nn2l(iv, v0);\\r\\nti[0] = v0;\\r\\nn2l(iv, v1);\\r\\nti[1] = v1;\\r\\nidea_encrypt((unsigned long *)ti, schedule);\\r\\niv = (unsigned char *)ivec;\\r\\nt = ti[0];\\r\\nl2n(t, iv);\\r\\nt = ti[1];\\r\\nl2n(t, iv);\\r\\niv = (unsigned char *)ivec;\\r\\n}\\r\\nc = *(in++) ^ iv[n];\\r\\n*(out++) = c;\\r\\niv[n] = c;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n} else {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nn2l(iv, v0);\\r\\nti[0] = v0;\\r\\nn2l(iv, v1);\\r\\nti[1] = v1;\\r\\nidea_encrypt((unsigned long *)ti, schedule);\\r\\niv = (unsigned char *)ivec;\\r\\nt = ti[0];\\r\\nl2n(t, iv);\\r\\nt = ti[1];\\r\\nl2n(t, iv);\\r\\niv = (unsigned char *)ivec;\\r\\n}\\r\\ncc = *(in++);\\r\\nc = iv[n];\\r\\niv[n] = cc;\\r\\n*(out++) = c ^ cc;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n}\\r\\nv0 = v1 = ti[0] = ti[1] = t = c = cc = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ppccap_c", "target": 0, "func": "int bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0, int num)\\r\\n{\\r\\nint bn_mul_mont_fpu64(BN_ULONG *rp, const BN_ULONG *ap,\\r\\nconst BN_ULONG *bp, const BN_ULONG *np,\\r\\nconst BN_ULONG *n0, int num);\\r\\nint bn_mul_mont_int(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0, int num);\\r\\nif (sizeof(size_t) == 4) {\\r\\n# if 1 || (defined(__APPLE__) && defined(__MACH__))\\r\\nif (num >= 8 && (num & 3) == 0 && (OPENSSL_ppccap_P & PPC_FPU64))\\r\\nreturn bn_mul_mont_fpu64(rp, ap, bp, np, n0, num);\\r\\n# else\\r\\nif (num >= 32 && (num & 3) == 0 && (OPENSSL_ppccap_P & PPC_FPU64)) {\\r\\nsigset_t oset;\\r\\nint ret;\\r\\nsigprocmask(SIG_SETMASK, &all_masked, &oset);\\r\\nret = bn_mul_mont_fpu64(rp, ap, bp, np, n0, num);\\r\\nsigprocmask(SIG_SETMASK, &oset, NULL);\\r\\nreturn ret;\\r\\n}\\r\\n# endif\\r\\n} else if ((OPENSSL_ppccap_P & PPC_FPU64))\\r\\nreturn bn_mul_mont_fpu64(rp, ap, bp, np, n0, num);\\r\\nreturn bn_mul_mont_int(rp, ap, bp, np, n0, num);\\r\\n}\\r\\nvoid sha256_block_data_order(void *ctx, const void *inp, size_t len)\\r\\n{\\r\\nOPENSSL_ppccap_P & PPC_CRYPTO207 ? sha256_block_p8(ctx, inp, len) :\\r\\nsha256_block_ppc(ctx, inp, len);\\r\\n}\\r\\nvoid sha512_block_data_order(void *ctx, const void *inp, size_t len)\\r\\n{\\r\\nOPENSSL_ppccap_P & PPC_CRYPTO207 ? sha512_block_p8(ctx, inp, len) :\\r\\nsha512_block_ppc(ctx, inp, len);\\r\\n}\\r\\nstatic void ill_handler(int sig)\\r\\n{\\r\\nsiglongjmp(ill_jmp, sig);\\r\\n}\\r\\nvoid OPENSSL_cpuid_setup(void)\\r\\n{\\r\\nchar *e;\\r\\nstruct sigaction ill_oact, ill_act;\\r\\nsigset_t oset;\\r\\nstatic int trigger = 0;\\r\\nif (trigger)\\r\\nreturn;\\r\\ntrigger = 1;\\r\\nsigfillset(&all_masked);\\r\\nsigdelset(&all_masked, SIGILL);\\r\\nsigdelset(&all_masked, SIGTRAP);\\r\\n#ifdef SIGEMT\\r\\nsigdelset(&all_masked, SIGEMT);\\r\\n#endif\\r\\nsigdelset(&all_masked, SIGFPE);\\r\\nsigdelset(&all_masked, SIGBUS);\\r\\nsigdelset(&all_masked, SIGSEGV);\\r\\nif ((e = getenv(\"OPENSSL_ppccap\"))) {\\r\\nOPENSSL_ppccap_P = strtoul(e, NULL, 0);\\r\\nreturn;\\r\\n}\\r\\nOPENSSL_ppccap_P = 0;\\r\\n#if defined(_AIX)\\r\\nif (sizeof(size_t) == 4) {\\r\\nstruct utsname uts;\\r\\n# if defined(_SC_AIX_KERNEL_BITMODE)\\r\\nif (sysconf(_SC_AIX_KERNEL_BITMODE) != 64)\\r\\nreturn;\\r\\n# endif\\r\\nif (uname(&uts) != 0 || atoi(uts.version) < 6)\\r\\nreturn;\\r\\n}\\r\\n#endif\\r\\nmemset(&ill_act, 0, sizeof(ill_act));\\r\\nill_act.sa_handler = ill_handler;\\r\\nill_act.sa_mask = all_masked;\\r\\nsigprocmask(SIG_SETMASK, &ill_act.sa_mask, &oset);\\r\\nsigaction(SIGILL, &ill_act, &ill_oact);\\r\\nif (sizeof(size_t) == 4) {\\r\\n#ifdef __linux\\r\\nstruct utsname uts;\\r\\nif (uname(&uts) == 0 && strcmp(uts.machine, \"ppc64\") == 0)\\r\\n#endif\\r\\nif (sigsetjmp(ill_jmp, 1) == 0) {\\r\\nOPENSSL_ppc64_probe();\\r\\nOPENSSL_ppccap_P |= PPC_FPU64;\\r\\n}\\r\\n} else {\\r\\n}\\r\\nif (sigsetjmp(ill_jmp, 1) == 0) {\\r\\nOPENSSL_altivec_probe();\\r\\nOPENSSL_ppccap_P |= PPC_ALTIVEC;\\r\\nif (sigsetjmp(ill_jmp, 1) == 0) {\\r\\nOPENSSL_crypto207_probe();\\r\\nOPENSSL_ppccap_P |= PPC_CRYPTO207;\\r\\n}\\r\\n}\\r\\nsigaction(SIGILL, &ill_oact, NULL);\\r\\nsigprocmask(SIG_SETMASK, &oset, NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ocsp_vfy_c", "target": 0, "func": "static int ocsp_check_delegated(X509 *x, int flags)\\r\\n{\\r\\nX509_check_purpose(x, -1, 0);\\r\\nif ((x->ex_flags & EXFLAG_XKUSAGE) && (x->ex_xkusage & XKU_OCSP_SIGN))\\r\\nreturn 1;\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_DELEGATED, OCSP_R_MISSING_OCSPSIGNING_USAGE);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_err_c", "target": 0, "func": "void ERR_load_TS_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(TS_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, TS_str_functs);\\r\\nERR_load_strings(0, TS_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_asn1_c", "target": 0, "func": "int i2d_TS_MSG_IMPRINT_bio(BIO *bp, TS_MSG_IMPRINT *a)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of_const(TS_MSG_IMPRINT, i2d_TS_MSG_IMPRINT, bp, a);\\r\\n}\\r\\nTS_MSG_IMPRINT *d2i_TS_MSG_IMPRINT_fp(FILE *fp, TS_MSG_IMPRINT **a)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(TS_MSG_IMPRINT, TS_MSG_IMPRINT_new,\\r\\nd2i_TS_MSG_IMPRINT, fp, a);\\r\\n}\\r\\nint i2d_TS_MSG_IMPRINT_fp(FILE *fp, TS_MSG_IMPRINT *a)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of_const(TS_MSG_IMPRINT, i2d_TS_MSG_IMPRINT, fp, a);\\r\\n}\\r\\nint i2d_TS_REQ_bio(BIO *bp, TS_REQ *a)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of_const(TS_REQ, i2d_TS_REQ, bp, a);\\r\\n}\\r\\nTS_REQ *d2i_TS_REQ_fp(FILE *fp, TS_REQ **a)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(TS_REQ, TS_REQ_new, d2i_TS_REQ, fp, a);\\r\\n}\\r\\nint i2d_TS_REQ_fp(FILE *fp, TS_REQ *a)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of_const(TS_REQ, i2d_TS_REQ, fp, a);\\r\\n}\\r\\nint i2d_TS_TST_INFO_bio(BIO *bp, TS_TST_INFO *a)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of_const(TS_TST_INFO, i2d_TS_TST_INFO, bp, a);\\r\\n}\\r\\nTS_TST_INFO *d2i_TS_TST_INFO_fp(FILE *fp, TS_TST_INFO **a)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(TS_TST_INFO, TS_TST_INFO_new, d2i_TS_TST_INFO, fp,\\r\\na);\\r\\n}\\r\\nint i2d_TS_TST_INFO_fp(FILE *fp, TS_TST_INFO *a)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of_const(TS_TST_INFO, i2d_TS_TST_INFO, fp, a);\\r\\n}\\r\\nint ts_resp_cb(int op, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nTS_RESP *ts_resp = (TS_RESP *)*pval;\\r\\nif (op == ASN1_OP_NEW_POST) {\\r\\nts_resp->tst_info = NULL;\\r\\n} else if (op == ASN1_OP_FREE_POST) {\\r\\nif (ts_resp->tst_info != NULL)\\r\\nTS_TST_INFO_free(ts_resp->tst_info);\\r\\n} else if (op == ASN1_OP_D2I_POST) {\\r\\nif (ts_resp_set_tst_info(ts_resp) == 0)\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint i2d_TS_RESP_bio(BIO *bp, TS_RESP *a)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of_const(TS_RESP, i2d_TS_RESP, bp, a);\\r\\n}\\r\\nTS_RESP *d2i_TS_RESP_fp(FILE *fp, TS_RESP **a)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(TS_RESP, TS_RESP_new, d2i_TS_RESP, fp, a);\\r\\n}\\r\\nint i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of_const(TS_RESP, i2d_TS_RESP, fp, a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_dgram_c", "target": 0, "func": "BIO_METHOD *BIO_s_datagram(void)\\r\\n{\\r\\nreturn (&methods_dgramp);\\r\\n}\\r\\nBIO *BIO_new_dgram(int fd, int close_flag)\\r\\n{\\r\\nBIO *ret;\\r\\nret = BIO_new(BIO_s_datagram());\\r\\nif (ret == NULL)\\r\\nreturn (NULL);\\r\\nBIO_set_fd(ret, fd, close_flag);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int dgram_new(BIO *bi)\\r\\n{\\r\\nbio_dgram_data *data = NULL;\\r\\nbi->init = 0;\\r\\nbi->num = 0;\\r\\ndata = OPENSSL_malloc(sizeof(bio_dgram_data));\\r\\nif (data == NULL)\\r\\nreturn 0;\\r\\nmemset(data, 0x00, sizeof(bio_dgram_data));\\r\\nbi->ptr = data;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int dgram_free(BIO *a)\\r\\n{\\r\\nbio_dgram_data *data;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (!dgram_clear(a))\\r\\nreturn 0;\\r\\ndata = (bio_dgram_data *)a->ptr;\\r\\nif (data != NULL)\\r\\nOPENSSL_free(data);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int dgram_clear(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (a->shutdown) {\\r\\nif (a->init) {\\r\\nSHUTDOWN2(a->num);\\r\\n}\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic void dgram_adjust_rcv_timeout(BIO *b)\\r\\n{\\r\\n# if defined(SO_RCVTIMEO)\\r\\nbio_dgram_data *data = (bio_dgram_data *)b->ptr;\\r\\nunion {\\r\\nsize_t s;\\r\\nint i;\\r\\n} sz = {\\r\\n0\\r\\n};\\r\\nif (data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0) {\\r\\nstruct timeval timenow, timeleft;\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\nint timeout;\\r\\nsz.i = sizeof(timeout);\\r\\nif (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\\r\\n(void *)&timeout, &sz.i) < 0) {\\r\\nperror(\"getsockopt\");\\r\\n} else {\\r\\ndata->socket_timeout.tv_sec = timeout / 1000;\\r\\ndata->socket_timeout.tv_usec = (timeout % 1000) * 1000;\\r\\n}\\r\\n# else\\r\\nsz.i = sizeof(data->socket_timeout);\\r\\nif (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\\r\\n&(data->socket_timeout), (void *)&sz) < 0) {\\r\\nperror(\"getsockopt\");\\r\\n} else if (sizeof(sz.s) != sizeof(sz.i) && sz.i == 0)\\r\\nOPENSSL_assert(sz.s <= sizeof(data->socket_timeout));\\r\\n# endif\\r\\nget_current_time(&timenow);\\r\\nmemcpy(&timeleft, &(data->next_timeout), sizeof(struct timeval));\\r\\ntimeleft.tv_sec -= timenow.tv_sec;\\r\\ntimeleft.tv_usec -= timenow.tv_usec;\\r\\nif (timeleft.tv_usec < 0) {\\r\\ntimeleft.tv_sec--;\\r\\ntimeleft.tv_usec += 1000000;\\r\\n}\\r\\nif (timeleft.tv_sec < 0) {\\r\\ntimeleft.tv_sec = 0;\\r\\ntimeleft.tv_usec = 1;\\r\\n}\\r\\nif ((data->socket_timeout.tv_sec == 0\\r\\n&& data->socket_timeout.tv_usec == 0)\\r\\n|| (data->socket_timeout.tv_sec > timeleft.tv_sec)\\r\\n|| (data->socket_timeout.tv_sec == timeleft.tv_sec\\r\\n&& data->socket_timeout.tv_usec >= timeleft.tv_usec)) {\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\ntimeout = timeleft.tv_sec * 1000 + timeleft.tv_usec / 1000;\\r\\nif (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\\r\\n(void *)&timeout, sizeof(timeout)) < 0) {\\r\\nperror(\"setsockopt\");\\r\\n}\\r\\n# else\\r\\nif (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, &timeleft,\\r\\nsizeof(struct timeval)) < 0) {\\r\\nperror(\"setsockopt\");\\r\\n}\\r\\n# endif\\r\\n}\\r\\n}\\r\\n# endif\\r\\n}\\r\\nstatic void dgram_reset_rcv_timeout(BIO *b)\\r\\n{\\r\\n# if defined(SO_RCVTIMEO)\\r\\nbio_dgram_data *data = (bio_dgram_data *)b->ptr;\\r\\nif (data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0) {\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\nint timeout = data->socket_timeout.tv_sec * 1000 +\\r\\ndata->socket_timeout.tv_usec / 1000;\\r\\nif (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\\r\\n(void *)&timeout, sizeof(timeout)) < 0) {\\r\\nperror(\"setsockopt\");\\r\\n}\\r\\n# else\\r\\nif (setsockopt\\r\\n(b->num, SOL_SOCKET, SO_RCVTIMEO, &(data->socket_timeout),\\r\\nsizeof(struct timeval)) < 0) {\\r\\nperror(\"setsockopt\");\\r\\n}\\r\\n# endif\\r\\n}\\r\\n# endif\\r\\n}\\r\\nstatic int dgram_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nbio_dgram_data *data = (bio_dgram_data *)b->ptr;\\r\\nstruct {\\r\\nunion {\\r\\nsize_t s;\\r\\nint i;\\r\\n} len;\\r\\nunion {\\r\\nstruct sockaddr sa;\\r\\nstruct sockaddr_in sa_in;\\r\\n# if OPENSSL_USE_IPV6\\r\\nstruct sockaddr_in6 sa_in6;\\r\\n# endif\\r\\n} peer;\\r\\n} sa;\\r\\nsa.len.s = 0;\\r\\nsa.len.i = sizeof(sa.peer);\\r\\nif (out != NULL) {\\r\\nclear_socket_error();\\r\\nmemset(&sa.peer, 0x00, sizeof(sa.peer));\\r\\ndgram_adjust_rcv_timeout(b);\\r\\nret = recvfrom(b->num, out, outl, 0, &sa.peer.sa, (void *)&sa.len);\\r\\nif (sizeof(sa.len.i) != sizeof(sa.len.s) && sa.len.i == 0) {\\r\\nOPENSSL_assert(sa.len.s <= sizeof(sa.peer));\\r\\nsa.len.i = (int)sa.len.s;\\r\\n}\\r\\nif (!data->connected && ret >= 0)\\r\\nBIO_ctrl(b, BIO_CTRL_DGRAM_SET_PEER, 0, &sa.peer);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret < 0) {\\r\\nif (BIO_dgram_should_retry(ret)) {\\r\\nBIO_set_retry_read(b);\\r\\ndata->_errno = get_last_socket_error();\\r\\n}\\r\\n}\\r\\ndgram_reset_rcv_timeout(b);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int dgram_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nbio_dgram_data *data = (bio_dgram_data *)b->ptr;\\r\\nclear_socket_error();\\r\\nif (data->connected)\\r\\nret = writesocket(b->num, in, inl);\\r\\nelse {\\r\\nint peerlen = sizeof(data->peer);\\r\\nif (data->peer.sa.sa_family == AF_INET)\\r\\npeerlen = sizeof(data->peer.sa_in);\\r\\n# if OPENSSL_USE_IPV6\\r\\nelse if (data->peer.sa.sa_family == AF_INET6)\\r\\npeerlen = sizeof(data->peer.sa_in6);\\r\\n# endif\\r\\n# if defined(NETWARE_CLIB) && defined(NETWARE_BSDSOCK)\\r\\nret = sendto(b->num, (char *)in, inl, 0, &data->peer.sa, peerlen);\\r\\n# else\\r\\nret = sendto(b->num, in, inl, 0, &data->peer.sa, peerlen);\\r\\n# endif\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0) {\\r\\nif (BIO_dgram_should_retry(ret)) {\\r\\nBIO_set_retry_write(b);\\r\\ndata->_errno = get_last_socket_error();\\r\\n# if 0\\r\\nif (data->_errno == EMSGSIZE)\\r\\nBIO_ctrl(b, BIO_CTRL_DGRAM_QUERY_MTU, 0, NULL);\\r\\n# endif\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long dgram_get_mtu_overhead(bio_dgram_data *data)\\r\\n{\\r\\nlong ret;\\r\\nswitch (data->peer.sa.sa_family) {\\r\\ncase AF_INET:\\r\\nret = 28;\\r\\nbreak;\\r\\n# if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\n# ifdef IN6_IS_ADDR_V4MAPPED\\r\\nif (IN6_IS_ADDR_V4MAPPED(&data->peer.sa_in6.sin6_addr))\\r\\nret = 28;\\r\\nelse\\r\\n# endif\\r\\nret = 48;\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nret = 28;\\r\\nbreak;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic long dgram_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret = 1;\\r\\nint *ip;\\r\\nstruct sockaddr *to = NULL;\\r\\nbio_dgram_data *data = NULL;\\r\\nint sockopt_val = 0;\\r\\n# if defined(OPENSSL_SYS_LINUX) && (defined(IP_MTU_DISCOVER) || defined(IP_MTU))\\r\\nsocklen_t sockopt_len;\\r\\nsocklen_t addr_len;\\r\\nunion {\\r\\nstruct sockaddr sa;\\r\\nstruct sockaddr_in s4;\\r\\n# if OPENSSL_USE_IPV6\\r\\nstruct sockaddr_in6 s6;\\r\\n# endif\\r\\n} addr;\\r\\n# endif\\r\\ndata = (bio_dgram_data *)b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nnum = 0;\\r\\ncase BIO_C_FILE_SEEK:\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_C_FILE_TELL:\\r\\ncase BIO_CTRL_INFO:\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\ndgram_clear(b);\\r\\nb->num = *((int *)ptr);\\r\\nb->shutdown = (int)num;\\r\\nb->init = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init) {\\r\\nip = (int *)ptr;\\r\\nif (ip != NULL)\\r\\n*ip = b->num;\\r\\nret = b->num;\\r\\n} else\\r\\nret = -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown = (int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_CONNECT:\\r\\nto = (struct sockaddr *)ptr;\\r\\n# if 0\\r\\nif (connect(b->num, to, sizeof(struct sockaddr)) < 0) {\\r\\nperror(\"connect\");\\r\\nret = 0;\\r\\n} else {\\r\\n# endif\\r\\nswitch (to->sa_family) {\\r\\ncase AF_INET:\\r\\nmemcpy(&data->peer, to, sizeof(data->peer.sa_in));\\r\\nbreak;\\r\\n# if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\nmemcpy(&data->peer, to, sizeof(data->peer.sa_in6));\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nmemcpy(&data->peer, to, sizeof(data->peer.sa));\\r\\nbreak;\\r\\n}\\r\\n# if 0\\r\\n}\\r\\n# endif\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_MTU_DISCOVER:\\r\\n# if defined(OPENSSL_SYS_LINUX) && defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DO)\\r\\naddr_len = (socklen_t) sizeof(addr);\\r\\nmemset((void *)&addr, 0, sizeof(addr));\\r\\nif (getsockname(b->num, &addr.sa, &addr_len) < 0) {\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nswitch (addr.sa.sa_family) {\\r\\ncase AF_INET:\\r\\nsockopt_val = IP_PMTUDISC_DO;\\r\\nif ((ret = setsockopt(b->num, IPPROTO_IP, IP_MTU_DISCOVER,\\r\\n&sockopt_val, sizeof(sockopt_val))) < 0)\\r\\nperror(\"setsockopt\");\\r\\nbreak;\\r\\n# if OPENSSL_USE_IPV6 && defined(IPV6_MTU_DISCOVER) && defined(IPV6_PMTUDISC_DO)\\r\\ncase AF_INET6:\\r\\nsockopt_val = IPV6_PMTUDISC_DO;\\r\\nif ((ret = setsockopt(b->num, IPPROTO_IPV6, IPV6_MTU_DISCOVER,\\r\\n&sockopt_val, sizeof(sockopt_val))) < 0)\\r\\nperror(\"setsockopt\");\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nret = -1;\\r\\nbreak;\\r\\n}\\r\\nret = -1;\\r\\n# else\\r\\nbreak;\\r\\n# endif\\r\\ncase BIO_CTRL_DGRAM_QUERY_MTU:\\r\\n# if defined(OPENSSL_SYS_LINUX) && defined(IP_MTU)\\r\\naddr_len = (socklen_t) sizeof(addr);\\r\\nmemset((void *)&addr, 0, sizeof(addr));\\r\\nif (getsockname(b->num, &addr.sa, &addr_len) < 0) {\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nsockopt_len = sizeof(sockopt_val);\\r\\nswitch (addr.sa.sa_family) {\\r\\ncase AF_INET:\\r\\nif ((ret =\\r\\ngetsockopt(b->num, IPPROTO_IP, IP_MTU, (void *)&sockopt_val,\\r\\n&sockopt_len)) < 0 || sockopt_val < 0) {\\r\\nret = 0;\\r\\n} else {\\r\\ndata->mtu = sockopt_val - 8 - 20;\\r\\nret = data->mtu;\\r\\n}\\r\\nbreak;\\r\\n# if OPENSSL_USE_IPV6 && defined(IPV6_MTU)\\r\\ncase AF_INET6:\\r\\nif ((ret =\\r\\ngetsockopt(b->num, IPPROTO_IPV6, IPV6_MTU,\\r\\n(void *)&sockopt_val, &sockopt_len)) < 0\\r\\n|| sockopt_val < 0) {\\r\\nret = 0;\\r\\n} else {\\r\\ndata->mtu = sockopt_val - 8 - 40;\\r\\nret = data->mtu;\\r\\n}\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\n# else\\r\\nret = 0;\\r\\n# endif\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_FALLBACK_MTU:\\r\\nret = -dgram_get_mtu_overhead(data);\\r\\nswitch (data->peer.sa.sa_family) {\\r\\ncase AF_INET:\\r\\nret += 576;\\r\\nbreak;\\r\\n# if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\n# ifdef IN6_IS_ADDR_V4MAPPED\\r\\nif (IN6_IS_ADDR_V4MAPPED(&data->peer.sa_in6.sin6_addr))\\r\\nret += 576;\\r\\nelse\\r\\n# endif\\r\\nret += 1280;\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nret += 576;\\r\\nbreak;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_MTU:\\r\\nreturn data->mtu;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_MTU:\\r\\ndata->mtu = num;\\r\\nret = num;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_CONNECTED:\\r\\nto = (struct sockaddr *)ptr;\\r\\nif (to != NULL) {\\r\\ndata->connected = 1;\\r\\nswitch (to->sa_family) {\\r\\ncase AF_INET:\\r\\nmemcpy(&data->peer, to, sizeof(data->peer.sa_in));\\r\\nbreak;\\r\\n# if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\nmemcpy(&data->peer, to, sizeof(data->peer.sa_in6));\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nmemcpy(&data->peer, to, sizeof(data->peer.sa));\\r\\nbreak;\\r\\n}\\r\\n} else {\\r\\ndata->connected = 0;\\r\\nmemset(&(data->peer), 0x00, sizeof(data->peer));\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_PEER:\\r\\nswitch (data->peer.sa.sa_family) {\\r\\ncase AF_INET:\\r\\nret = sizeof(data->peer.sa_in);\\r\\nbreak;\\r\\n# if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\nret = sizeof(data->peer.sa_in6);\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nret = sizeof(data->peer.sa);\\r\\nbreak;\\r\\n}\\r\\nif (num == 0 || num > ret)\\r\\nnum = ret;\\r\\nmemcpy(ptr, &data->peer, (ret = num));\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_PEER:\\r\\nto = (struct sockaddr *)ptr;\\r\\nswitch (to->sa_family) {\\r\\ncase AF_INET:\\r\\nmemcpy(&data->peer, to, sizeof(data->peer.sa_in));\\r\\nbreak;\\r\\n# if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\nmemcpy(&data->peer, to, sizeof(data->peer.sa_in6));\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nmemcpy(&data->peer, to, sizeof(data->peer.sa));\\r\\nbreak;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT:\\r\\nmemcpy(&(data->next_timeout), ptr, sizeof(struct timeval));\\r\\nbreak;\\r\\n# if defined(SO_RCVTIMEO)\\r\\ncase BIO_CTRL_DGRAM_SET_RECV_TIMEOUT:\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\n{\\r\\nstruct timeval *tv = (struct timeval *)ptr;\\r\\nint timeout = tv->tv_sec * 1000 + tv->tv_usec / 1000;\\r\\nif (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\\r\\n(void *)&timeout, sizeof(timeout)) < 0) {\\r\\nperror(\"setsockopt\");\\r\\nret = -1;\\r\\n}\\r\\n}\\r\\n# else\\r\\nif (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, ptr,\\r\\nsizeof(struct timeval)) < 0) {\\r\\nperror(\"setsockopt\");\\r\\nret = -1;\\r\\n}\\r\\n# endif\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_RECV_TIMEOUT:\\r\\n{\\r\\nunion {\\r\\nsize_t s;\\r\\nint i;\\r\\n} sz = {\\r\\n0\\r\\n};\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\nint timeout;\\r\\nstruct timeval *tv = (struct timeval *)ptr;\\r\\nsz.i = sizeof(timeout);\\r\\nif (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\\r\\n(void *)&timeout, &sz.i) < 0) {\\r\\nperror(\"getsockopt\");\\r\\nret = -1;\\r\\n} else {\\r\\ntv->tv_sec = timeout / 1000;\\r\\ntv->tv_usec = (timeout % 1000) * 1000;\\r\\nret = sizeof(*tv);\\r\\n}\\r\\n# else\\r\\nsz.i = sizeof(struct timeval);\\r\\nif (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\\r\\nptr, (void *)&sz) < 0) {\\r\\nperror(\"getsockopt\");\\r\\nret = -1;\\r\\n} else if (sizeof(sz.s) != sizeof(sz.i) && sz.i == 0) {\\r\\nOPENSSL_assert(sz.s <= sizeof(struct timeval));\\r\\nret = (int)sz.s;\\r\\n} else\\r\\nret = sz.i;\\r\\n# endif\\r\\n}\\r\\nbreak;\\r\\n# endif\\r\\n# if defined(SO_SNDTIMEO)\\r\\ncase BIO_CTRL_DGRAM_SET_SEND_TIMEOUT:\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\n{\\r\\nstruct timeval *tv = (struct timeval *)ptr;\\r\\nint timeout = tv->tv_sec * 1000 + tv->tv_usec / 1000;\\r\\nif (setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,\\r\\n(void *)&timeout, sizeof(timeout)) < 0) {\\r\\nperror(\"setsockopt\");\\r\\nret = -1;\\r\\n}\\r\\n}\\r\\n# else\\r\\nif (setsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO, ptr,\\r\\nsizeof(struct timeval)) < 0) {\\r\\nperror(\"setsockopt\");\\r\\nret = -1;\\r\\n}\\r\\n# endif\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_SEND_TIMEOUT:\\r\\n{\\r\\nunion {\\r\\nsize_t s;\\r\\nint i;\\r\\n} sz = {\\r\\n0\\r\\n};\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\nint timeout;\\r\\nstruct timeval *tv = (struct timeval *)ptr;\\r\\nsz.i = sizeof(timeout);\\r\\nif (getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,\\r\\n(void *)&timeout, &sz.i) < 0) {\\r\\nperror(\"getsockopt\");\\r\\nret = -1;\\r\\n} else {\\r\\ntv->tv_sec = timeout / 1000;\\r\\ntv->tv_usec = (timeout % 1000) * 1000;\\r\\nret = sizeof(*tv);\\r\\n}\\r\\n# else\\r\\nsz.i = sizeof(struct timeval);\\r\\nif (getsockopt(b->num, SOL_SOCKET, SO_SNDTIMEO,\\r\\nptr, (void *)&sz) < 0) {\\r\\nperror(\"getsockopt\");\\r\\nret = -1;\\r\\n} else if (sizeof(sz.s) != sizeof(sz.i) && sz.i == 0) {\\r\\nOPENSSL_assert(sz.s <= sizeof(struct timeval));\\r\\nret = (int)sz.s;\\r\\n} else\\r\\nret = sz.i;\\r\\n# endif\\r\\n}\\r\\nbreak;\\r\\n# endif\\r\\ncase BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP:\\r\\ncase BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP:\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\nif (data->_errno == WSAETIMEDOUT)\\r\\n# else\\r\\nif (data->_errno == EAGAIN)\\r\\n# endif\\r\\n{\\r\\nret = 1;\\r\\ndata->_errno = 0;\\r\\n} else\\r\\nret = 0;\\r\\nbreak;\\r\\n# ifdef EMSGSIZE\\r\\ncase BIO_CTRL_DGRAM_MTU_EXCEEDED:\\r\\nif (data->_errno == EMSGSIZE) {\\r\\nret = 1;\\r\\ndata->_errno = 0;\\r\\n} else\\r\\nret = 0;\\r\\nbreak;\\r\\n# endif\\r\\ncase BIO_CTRL_DGRAM_SET_DONT_FRAG:\\r\\nsockopt_val = num ? 1 : 0;\\r\\nswitch (data->peer.sa.sa_family) {\\r\\ncase AF_INET:\\r\\n# if defined(IP_DONTFRAG)\\r\\nif ((ret = setsockopt(b->num, IPPROTO_IP, IP_DONTFRAG,\\r\\n&sockopt_val, sizeof(sockopt_val))) < 0) {\\r\\nperror(\"setsockopt\");\\r\\nret = -1;\\r\\n}\\r\\n# elif defined(OPENSSL_SYS_LINUX) && defined(IP_MTUDISCOVER)\\r\\nif ((sockopt_val = num ? IP_PMTUDISC_PROBE : IP_PMTUDISC_DONT),\\r\\n(ret = setsockopt(b->num, IPPROTO_IP, IP_MTU_DISCOVER,\\r\\n&sockopt_val, sizeof(sockopt_val))) < 0) {\\r\\nperror(\"setsockopt\");\\r\\nret = -1;\\r\\n}\\r\\n# elif defined(OPENSSL_SYS_WINDOWS) && defined(IP_DONTFRAGMENT)\\r\\nif ((ret = setsockopt(b->num, IPPROTO_IP, IP_DONTFRAGMENT,\\r\\n(const char *)&sockopt_val,\\r\\nsizeof(sockopt_val))) < 0) {\\r\\nperror(\"setsockopt\");\\r\\nret = -1;\\r\\n}\\r\\n# else\\r\\nret = -1;\\r\\n# endif\\r\\nbreak;\\r\\n# if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\n# if defined(IPV6_DONTFRAG)\\r\\nif ((ret = setsockopt(b->num, IPPROTO_IPV6, IPV6_DONTFRAG,\\r\\n(const void *)&sockopt_val,\\r\\nsizeof(sockopt_val))) < 0) {\\r\\nperror(\"setsockopt\");\\r\\nret = -1;\\r\\n}\\r\\n# elif defined(OPENSSL_SYS_LINUX) && defined(IPV6_MTUDISCOVER)\\r\\nif ((sockopt_val = num ? IP_PMTUDISC_PROBE : IP_PMTUDISC_DONT),\\r\\n(ret = setsockopt(b->num, IPPROTO_IPV6, IPV6_MTU_DISCOVER,\\r\\n&sockopt_val, sizeof(sockopt_val))) < 0) {\\r\\nperror(\"setsockopt\");\\r\\nret = -1;\\r\\n}\\r\\n# else\\r\\nret = -1;\\r\\n# endif\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nret = -1;\\r\\nbreak;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_MTU_OVERHEAD:\\r\\nret = dgram_get_mtu_overhead(data);\\r\\nbreak;\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int dgram_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = dgram_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}\\r\\nBIO_METHOD *BIO_s_datagram_sctp(void)\\r\\n{\\r\\nreturn (&methods_dgramp_sctp);\\r\\n}\\r\\nBIO *BIO_new_dgram_sctp(int fd, int close_flag)\\r\\n{\\r\\nBIO *bio;\\r\\nint ret, optval = 20000;\\r\\nint auth_data = 0, auth_forward = 0;\\r\\nunsigned char *p;\\r\\nstruct sctp_authchunk auth;\\r\\nstruct sctp_authchunks *authchunks;\\r\\nsocklen_t sockopt_len;\\r\\n# ifdef SCTP_AUTHENTICATION_EVENT\\r\\n# ifdef SCTP_EVENT\\r\\nstruct sctp_event event;\\r\\n# else\\r\\nstruct sctp_event_subscribe event;\\r\\n# endif\\r\\n# endif\\r\\nbio = BIO_new(BIO_s_datagram_sctp());\\r\\nif (bio == NULL)\\r\\nreturn (NULL);\\r\\nBIO_set_fd(bio, fd, close_flag);\\r\\nauth.sauth_chunk = OPENSSL_SCTP_DATA_CHUNK_TYPE;\\r\\nret =\\r\\nsetsockopt(fd, IPPROTO_SCTP, SCTP_AUTH_CHUNK, &auth,\\r\\nsizeof(struct sctp_authchunk));\\r\\nif (ret < 0) {\\r\\nBIO_vfree(bio);\\r\\nreturn (NULL);\\r\\n}\\r\\nauth.sauth_chunk = OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE;\\r\\nret =\\r\\nsetsockopt(fd, IPPROTO_SCTP, SCTP_AUTH_CHUNK, &auth,\\r\\nsizeof(struct sctp_authchunk));\\r\\nif (ret < 0) {\\r\\nBIO_vfree(bio);\\r\\nreturn (NULL);\\r\\n}\\r\\nsockopt_len = (socklen_t) (sizeof(sctp_assoc_t) + 256 * sizeof(uint8_t));\\r\\nauthchunks = OPENSSL_malloc(sockopt_len);\\r\\nmemset(authchunks, 0, sizeof(sockopt_len));\\r\\nret =\\r\\ngetsockopt(fd, IPPROTO_SCTP, SCTP_LOCAL_AUTH_CHUNKS, authchunks,\\r\\n&sockopt_len);\\r\\nif (ret < 0) {\\r\\nOPENSSL_free(authchunks);\\r\\nBIO_vfree(bio);\\r\\nreturn (NULL);\\r\\n}\\r\\nfor (p = (unsigned char *)authchunks->gauth_chunks;\\r\\np < (unsigned char *)authchunks + sockopt_len;\\r\\np += sizeof(uint8_t)) {\\r\\nif (*p == OPENSSL_SCTP_DATA_CHUNK_TYPE)\\r\\nauth_data = 1;\\r\\nif (*p == OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE)\\r\\nauth_forward = 1;\\r\\n}\\r\\nOPENSSL_free(authchunks);\\r\\nOPENSSL_assert(auth_data);\\r\\nOPENSSL_assert(auth_forward);\\r\\n# ifdef SCTP_AUTHENTICATION_EVENT\\r\\n# ifdef SCTP_EVENT\\r\\nmemset(&event, 0, sizeof(struct sctp_event));\\r\\nevent.se_assoc_id = 0;\\r\\nevent.se_type = SCTP_AUTHENTICATION_EVENT;\\r\\nevent.se_on = 1;\\r\\nret =\\r\\nsetsockopt(fd, IPPROTO_SCTP, SCTP_EVENT, &event,\\r\\nsizeof(struct sctp_event));\\r\\nif (ret < 0) {\\r\\nBIO_vfree(bio);\\r\\nreturn (NULL);\\r\\n}\\r\\n# else\\r\\nsockopt_len = (socklen_t) sizeof(struct sctp_event_subscribe);\\r\\nret = getsockopt(fd, IPPROTO_SCTP, SCTP_EVENTS, &event, &sockopt_len);\\r\\nif (ret < 0) {\\r\\nBIO_vfree(bio);\\r\\nreturn (NULL);\\r\\n}\\r\\nevent.sctp_authentication_event = 1;\\r\\nret =\\r\\nsetsockopt(fd, IPPROTO_SCTP, SCTP_EVENTS, &event,\\r\\nsizeof(struct sctp_event_subscribe));\\r\\nif (ret < 0) {\\r\\nBIO_vfree(bio);\\r\\nreturn (NULL);\\r\\n}\\r\\n# endif\\r\\n# endif\\r\\nret =\\r\\nsetsockopt(fd, IPPROTO_SCTP, SCTP_PARTIAL_DELIVERY_POINT, &optval,\\r\\nsizeof(optval));\\r\\nif (ret < 0) {\\r\\nBIO_vfree(bio);\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (bio);\\r\\n}\\r\\nint BIO_dgram_is_sctp(BIO *bio)\\r\\n{\\r\\nreturn (BIO_method_type(bio) == BIO_TYPE_DGRAM_SCTP);\\r\\n}\\r\\nstatic int dgram_sctp_new(BIO *bi)\\r\\n{\\r\\nbio_dgram_sctp_data *data = NULL;\\r\\nbi->init = 0;\\r\\nbi->num = 0;\\r\\ndata = OPENSSL_malloc(sizeof(bio_dgram_sctp_data));\\r\\nif (data == NULL)\\r\\nreturn 0;\\r\\nmemset(data, 0x00, sizeof(bio_dgram_sctp_data));\\r\\n# ifdef SCTP_PR_SCTP_NONE\\r\\ndata->prinfo.pr_policy = SCTP_PR_SCTP_NONE;\\r\\n# endif\\r\\nbi->ptr = data;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int dgram_sctp_free(BIO *a)\\r\\n{\\r\\nbio_dgram_sctp_data *data;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (!dgram_clear(a))\\r\\nreturn 0;\\r\\ndata = (bio_dgram_sctp_data *) a->ptr;\\r\\nif (data != NULL) {\\r\\nif (data->saved_message.data != NULL)\\r\\nOPENSSL_free(data->saved_message.data);\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nvoid dgram_sctp_handle_auth_free_key_event(BIO *b,\\r\\nunion sctp_notification *snp)\\r\\n{\\r\\nint ret;\\r\\nstruct sctp_authkey_event *authkeyevent = &snp->sn_auth_event;\\r\\nif (authkeyevent->auth_indication == SCTP_AUTH_FREE_KEY) {\\r\\nstruct sctp_authkeyid authkeyid;\\r\\nauthkeyid.scact_keynumber = authkeyevent->auth_keynumber;\\r\\nret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_DELETE_KEY,\\r\\n&authkeyid, sizeof(struct sctp_authkeyid));\\r\\n}\\r\\n}\\r\\nstatic int dgram_sctp_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0, n = 0, i, optval;\\r\\nsocklen_t optlen;\\r\\nbio_dgram_sctp_data *data = (bio_dgram_sctp_data *) b->ptr;\\r\\nunion sctp_notification *snp;\\r\\nstruct msghdr msg;\\r\\nstruct iovec iov;\\r\\nstruct cmsghdr *cmsg;\\r\\nchar cmsgbuf[512];\\r\\nif (out != NULL) {\\r\\nclear_socket_error();\\r\\ndo {\\r\\nmemset(&data->rcvinfo, 0x00,\\r\\nsizeof(struct bio_dgram_sctp_rcvinfo));\\r\\niov.iov_base = out;\\r\\niov.iov_len = outl;\\r\\nmsg.msg_name = NULL;\\r\\nmsg.msg_namelen = 0;\\r\\nmsg.msg_iov = &iov;\\r\\nmsg.msg_iovlen = 1;\\r\\nmsg.msg_control = cmsgbuf;\\r\\nmsg.msg_controllen = 512;\\r\\nmsg.msg_flags = 0;\\r\\nn = recvmsg(b->num, &msg, 0);\\r\\nif (n <= 0) {\\r\\nif (n < 0)\\r\\nret = n;\\r\\nbreak;\\r\\n}\\r\\nif (msg.msg_controllen > 0) {\\r\\nfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg;\\r\\ncmsg = CMSG_NXTHDR(&msg, cmsg)) {\\r\\nif (cmsg->cmsg_level != IPPROTO_SCTP)\\r\\ncontinue;\\r\\n# ifdef SCTP_RCVINFO\\r\\nif (cmsg->cmsg_type == SCTP_RCVINFO) {\\r\\nstruct sctp_rcvinfo *rcvinfo;\\r\\nrcvinfo = (struct sctp_rcvinfo *)CMSG_DATA(cmsg);\\r\\ndata->rcvinfo.rcv_sid = rcvinfo->rcv_sid;\\r\\ndata->rcvinfo.rcv_ssn = rcvinfo->rcv_ssn;\\r\\ndata->rcvinfo.rcv_flags = rcvinfo->rcv_flags;\\r\\ndata->rcvinfo.rcv_ppid = rcvinfo->rcv_ppid;\\r\\ndata->rcvinfo.rcv_tsn = rcvinfo->rcv_tsn;\\r\\ndata->rcvinfo.rcv_cumtsn = rcvinfo->rcv_cumtsn;\\r\\ndata->rcvinfo.rcv_context = rcvinfo->rcv_context;\\r\\n}\\r\\n# endif\\r\\n# ifdef SCTP_SNDRCV\\r\\nif (cmsg->cmsg_type == SCTP_SNDRCV) {\\r\\nstruct sctp_sndrcvinfo *sndrcvinfo;\\r\\nsndrcvinfo =\\r\\n(struct sctp_sndrcvinfo *)CMSG_DATA(cmsg);\\r\\ndata->rcvinfo.rcv_sid = sndrcvinfo->sinfo_stream;\\r\\ndata->rcvinfo.rcv_ssn = sndrcvinfo->sinfo_ssn;\\r\\ndata->rcvinfo.rcv_flags = sndrcvinfo->sinfo_flags;\\r\\ndata->rcvinfo.rcv_ppid = sndrcvinfo->sinfo_ppid;\\r\\ndata->rcvinfo.rcv_tsn = sndrcvinfo->sinfo_tsn;\\r\\ndata->rcvinfo.rcv_cumtsn = sndrcvinfo->sinfo_cumtsn;\\r\\ndata->rcvinfo.rcv_context = sndrcvinfo->sinfo_context;\\r\\n}\\r\\n# endif\\r\\n}\\r\\n}\\r\\nif (msg.msg_flags & MSG_NOTIFICATION) {\\r\\nsnp = (union sctp_notification *)out;\\r\\nif (snp->sn_header.sn_type == SCTP_SENDER_DRY_EVENT) {\\r\\n# ifdef SCTP_EVENT\\r\\nstruct sctp_event event;\\r\\n# else\\r\\nstruct sctp_event_subscribe event;\\r\\nsocklen_t eventsize;\\r\\n# endif\\r\\nif (data->saved_message.length > 0) {\\r\\ndgram_sctp_write(data->saved_message.bio,\\r\\ndata->saved_message.data,\\r\\ndata->saved_message.length);\\r\\nOPENSSL_free(data->saved_message.data);\\r\\ndata->saved_message.data = NULL;\\r\\ndata->saved_message.length = 0;\\r\\n}\\r\\n# ifdef SCTP_EVENT\\r\\nmemset(&event, 0, sizeof(struct sctp_event));\\r\\nevent.se_assoc_id = 0;\\r\\nevent.se_type = SCTP_SENDER_DRY_EVENT;\\r\\nevent.se_on = 0;\\r\\ni = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENT, &event,\\r\\nsizeof(struct sctp_event));\\r\\nif (i < 0) {\\r\\nret = i;\\r\\nbreak;\\r\\n}\\r\\n# else\\r\\neventsize = sizeof(struct sctp_event_subscribe);\\r\\ni = getsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event,\\r\\n&eventsize);\\r\\nif (i < 0) {\\r\\nret = i;\\r\\nbreak;\\r\\n}\\r\\nevent.sctp_sender_dry_event = 0;\\r\\ni = setsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event,\\r\\nsizeof(struct sctp_event_subscribe));\\r\\nif (i < 0) {\\r\\nret = i;\\r\\nbreak;\\r\\n}\\r\\n# endif\\r\\n}\\r\\n# ifdef SCTP_AUTHENTICATION_EVENT\\r\\nif (snp->sn_header.sn_type == SCTP_AUTHENTICATION_EVENT)\\r\\ndgram_sctp_handle_auth_free_key_event(b, snp);\\r\\n# endif\\r\\nif (data->handle_notifications != NULL)\\r\\ndata->handle_notifications(b, data->notification_context,\\r\\n(void *)out);\\r\\nmemset(out, 0, outl);\\r\\n} else\\r\\nret += n;\\r\\n}\\r\\nwhile ((msg.msg_flags & MSG_NOTIFICATION) && (msg.msg_flags & MSG_EOR)\\r\\n&& (ret < outl));\\r\\nif (ret > 0 && !(msg.msg_flags & MSG_EOR)) {\\r\\nif (ret == outl)\\r\\nreturn -1;\\r\\noptlen = (socklen_t) sizeof(int);\\r\\nret = getsockopt(b->num, SOL_SOCKET, SO_RCVBUF, &optval, &optlen);\\r\\nif (ret >= 0)\\r\\nOPENSSL_assert(optval >= 18445);\\r\\noptlen = (socklen_t) sizeof(int);\\r\\nret =\\r\\ngetsockopt(b->num, IPPROTO_SCTP, SCTP_PARTIAL_DELIVERY_POINT,\\r\\n&optval, &optlen);\\r\\nif (ret >= 0)\\r\\nOPENSSL_assert(optval >= 18445);\\r\\nOPENSSL_assert(!(msg.msg_flags & MSG_NOTIFICATION));\\r\\nmemset(out, 0, outl);\\r\\nBIO_set_retry_read(b);\\r\\nreturn -1;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret < 0) {\\r\\nif (BIO_dgram_should_retry(ret)) {\\r\\nBIO_set_retry_read(b);\\r\\ndata->_errno = get_last_socket_error();\\r\\n}\\r\\n}\\r\\nif (!data->peer_auth_tested) {\\r\\nint ii, auth_data = 0, auth_forward = 0;\\r\\nunsigned char *p;\\r\\nstruct sctp_authchunks *authchunks;\\r\\noptlen =\\r\\n(socklen_t) (sizeof(sctp_assoc_t) + 256 * sizeof(uint8_t));\\r\\nauthchunks = OPENSSL_malloc(optlen);\\r\\nmemset(authchunks, 0, sizeof(optlen));\\r\\nii = getsockopt(b->num, IPPROTO_SCTP, SCTP_PEER_AUTH_CHUNKS,\\r\\nauthchunks, &optlen);\\r\\nif (ii >= 0)\\r\\nfor (p = (unsigned char *)authchunks->gauth_chunks;\\r\\np < (unsigned char *)authchunks + optlen;\\r\\np += sizeof(uint8_t)) {\\r\\nif (*p == OPENSSL_SCTP_DATA_CHUNK_TYPE)\\r\\nauth_data = 1;\\r\\nif (*p == OPENSSL_SCTP_FORWARD_CUM_TSN_CHUNK_TYPE)\\r\\nauth_forward = 1;\\r\\n}\\r\\nOPENSSL_free(authchunks);\\r\\nif (!auth_data || !auth_forward) {\\r\\nBIOerr(BIO_F_DGRAM_SCTP_READ, BIO_R_CONNECT_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\ndata->peer_auth_tested = 1;\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int dgram_sctp_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nbio_dgram_sctp_data *data = (bio_dgram_sctp_data *) b->ptr;\\r\\nstruct bio_dgram_sctp_sndinfo *sinfo = &(data->sndinfo);\\r\\nstruct bio_dgram_sctp_prinfo *pinfo = &(data->prinfo);\\r\\nstruct bio_dgram_sctp_sndinfo handshake_sinfo;\\r\\nstruct iovec iov[1];\\r\\nstruct msghdr msg;\\r\\nstruct cmsghdr *cmsg;\\r\\n# if defined(SCTP_SNDINFO) && defined(SCTP_PRINFO)\\r\\nchar cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndinfo)) +\\r\\nCMSG_SPACE(sizeof(struct sctp_prinfo))];\\r\\nstruct sctp_sndinfo *sndinfo;\\r\\nstruct sctp_prinfo *prinfo;\\r\\n# else\\r\\nchar cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndrcvinfo))];\\r\\nstruct sctp_sndrcvinfo *sndrcvinfo;\\r\\n# endif\\r\\nclear_socket_error();\\r\\nif (in[0] != 23) {\\r\\nmemset(&handshake_sinfo, 0x00, sizeof(struct bio_dgram_sctp_sndinfo));\\r\\n# ifdef SCTP_SACK_IMMEDIATELY\\r\\nhandshake_sinfo.snd_flags = SCTP_SACK_IMMEDIATELY;\\r\\n# endif\\r\\nsinfo = &handshake_sinfo;\\r\\n}\\r\\nif (data->save_shutdown && !BIO_dgram_sctp_wait_for_dry(b)) {\\r\\ndata->saved_message.bio = b;\\r\\nif (data->saved_message.data)\\r\\nOPENSSL_free(data->saved_message.data);\\r\\ndata->saved_message.data = OPENSSL_malloc(inl);\\r\\nmemcpy(data->saved_message.data, in, inl);\\r\\ndata->saved_message.length = inl;\\r\\nreturn inl;\\r\\n}\\r\\niov[0].iov_base = (char *)in;\\r\\niov[0].iov_len = inl;\\r\\nmsg.msg_name = NULL;\\r\\nmsg.msg_namelen = 0;\\r\\nmsg.msg_iov = iov;\\r\\nmsg.msg_iovlen = 1;\\r\\nmsg.msg_control = (caddr_t) cmsgbuf;\\r\\nmsg.msg_controllen = 0;\\r\\nmsg.msg_flags = 0;\\r\\n# if defined(SCTP_SNDINFO) && defined(SCTP_PRINFO)\\r\\ncmsg = (struct cmsghdr *)cmsgbuf;\\r\\ncmsg->cmsg_level = IPPROTO_SCTP;\\r\\ncmsg->cmsg_type = SCTP_SNDINFO;\\r\\ncmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndinfo));\\r\\nsndinfo = (struct sctp_sndinfo *)CMSG_DATA(cmsg);\\r\\nmemset(sndinfo, 0, sizeof(struct sctp_sndinfo));\\r\\nsndinfo->snd_sid = sinfo->snd_sid;\\r\\nsndinfo->snd_flags = sinfo->snd_flags;\\r\\nsndinfo->snd_ppid = sinfo->snd_ppid;\\r\\nsndinfo->snd_context = sinfo->snd_context;\\r\\nmsg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndinfo));\\r\\ncmsg =\\r\\n(struct cmsghdr *)&cmsgbuf[CMSG_SPACE(sizeof(struct sctp_sndinfo))];\\r\\ncmsg->cmsg_level = IPPROTO_SCTP;\\r\\ncmsg->cmsg_type = SCTP_PRINFO;\\r\\ncmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_prinfo));\\r\\nprinfo = (struct sctp_prinfo *)CMSG_DATA(cmsg);\\r\\nmemset(prinfo, 0, sizeof(struct sctp_prinfo));\\r\\nprinfo->pr_policy = pinfo->pr_policy;\\r\\nprinfo->pr_value = pinfo->pr_value;\\r\\nmsg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_prinfo));\\r\\n# else\\r\\ncmsg = (struct cmsghdr *)cmsgbuf;\\r\\ncmsg->cmsg_level = IPPROTO_SCTP;\\r\\ncmsg->cmsg_type = SCTP_SNDRCV;\\r\\ncmsg->cmsg_len = CMSG_LEN(sizeof(struct sctp_sndrcvinfo));\\r\\nsndrcvinfo = (struct sctp_sndrcvinfo *)CMSG_DATA(cmsg);\\r\\nmemset(sndrcvinfo, 0, sizeof(struct sctp_sndrcvinfo));\\r\\nsndrcvinfo->sinfo_stream = sinfo->snd_sid;\\r\\nsndrcvinfo->sinfo_flags = sinfo->snd_flags;\\r\\n# ifdef __FreeBSD__\\r\\nsndrcvinfo->sinfo_flags |= pinfo->pr_policy;\\r\\n# endif\\r\\nsndrcvinfo->sinfo_ppid = sinfo->snd_ppid;\\r\\nsndrcvinfo->sinfo_context = sinfo->snd_context;\\r\\nsndrcvinfo->sinfo_timetolive = pinfo->pr_value;\\r\\nmsg.msg_controllen += CMSG_SPACE(sizeof(struct sctp_sndrcvinfo));\\r\\n# endif\\r\\nret = sendmsg(b->num, &msg, 0);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0) {\\r\\nif (BIO_dgram_should_retry(ret)) {\\r\\nBIO_set_retry_write(b);\\r\\ndata->_errno = get_last_socket_error();\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long dgram_sctp_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret = 1;\\r\\nbio_dgram_sctp_data *data = NULL;\\r\\nsocklen_t sockopt_len = 0;\\r\\nstruct sctp_authkeyid authkeyid;\\r\\nstruct sctp_authkey *authkey = NULL;\\r\\ndata = (bio_dgram_sctp_data *) b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_DGRAM_QUERY_MTU:\\r\\ndata->mtu = 16384;\\r\\nret = data->mtu;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_MTU:\\r\\ndata->mtu = 16384;\\r\\nret = data->mtu;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_CONNECTED:\\r\\ncase BIO_CTRL_DGRAM_CONNECT:\\r\\nret = -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT:\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_GET_MTU_OVERHEAD:\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE:\\r\\nif (num > 0)\\r\\ndata->in_handshake = 1;\\r\\nelse\\r\\ndata->in_handshake = 0;\\r\\nret =\\r\\nsetsockopt(b->num, IPPROTO_SCTP, SCTP_NODELAY,\\r\\n&data->in_handshake, sizeof(int));\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_ADD_AUTH_KEY:\\r\\nsockopt_len = sizeof(struct sctp_authkeyid);\\r\\nret =\\r\\ngetsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY, &authkeyid,\\r\\n&sockopt_len);\\r\\nif (ret < 0)\\r\\nbreak;\\r\\nsockopt_len = sizeof(struct sctp_authkey) + 64 * sizeof(uint8_t);\\r\\nauthkey = OPENSSL_malloc(sockopt_len);\\r\\nif (authkey == NULL) {\\r\\nret = -1;\\r\\nbreak;\\r\\n}\\r\\nmemset(authkey, 0x00, sockopt_len);\\r\\nauthkey->sca_keynumber = authkeyid.scact_keynumber + 1;\\r\\n# ifndef __FreeBSD__\\r\\nauthkey->sca_keylength = 64;\\r\\n# endif\\r\\nmemcpy(&authkey->sca_key[0], ptr, 64 * sizeof(uint8_t));\\r\\nret =\\r\\nsetsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_KEY, authkey,\\r\\nsockopt_len);\\r\\nOPENSSL_free(authkey);\\r\\nauthkey = NULL;\\r\\nif (ret < 0)\\r\\nbreak;\\r\\nret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY,\\r\\n&authkeyid, sizeof(struct sctp_authkeyid));\\r\\nif (ret < 0)\\r\\nbreak;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_NEXT_AUTH_KEY:\\r\\nsockopt_len = sizeof(struct sctp_authkeyid);\\r\\nret =\\r\\ngetsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY, &authkeyid,\\r\\n&sockopt_len);\\r\\nif (ret < 0)\\r\\nbreak;\\r\\nauthkeyid.scact_keynumber = authkeyid.scact_keynumber + 1;\\r\\nret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY,\\r\\n&authkeyid, sizeof(struct sctp_authkeyid));\\r\\nif (ret < 0)\\r\\nbreak;\\r\\ndata->ccs_sent = 1;\\r\\ncase BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD:\\r\\nif (cmd == BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD)\\r\\ndata->ccs_rcvd = 1;\\r\\nif (data->ccs_rcvd == 1 && data->ccs_sent == 1) {\\r\\nsockopt_len = sizeof(struct sctp_authkeyid);\\r\\nret =\\r\\ngetsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_ACTIVE_KEY,\\r\\n&authkeyid, &sockopt_len);\\r\\nif (ret < 0)\\r\\nbreak;\\r\\nauthkeyid.scact_keynumber = authkeyid.scact_keynumber - 1;\\r\\n# ifdef SCTP_AUTH_DEACTIVATE_KEY\\r\\nsockopt_len = sizeof(struct sctp_authkeyid);\\r\\nret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_DEACTIVATE_KEY,\\r\\n&authkeyid, sockopt_len);\\r\\nif (ret < 0)\\r\\nbreak;\\r\\n# endif\\r\\n# ifndef SCTP_AUTHENTICATION_EVENT\\r\\nif (authkeyid.scact_keynumber > 0) {\\r\\nauthkeyid.scact_keynumber = authkeyid.scact_keynumber - 1;\\r\\nret = setsockopt(b->num, IPPROTO_SCTP, SCTP_AUTH_DELETE_KEY,\\r\\n&authkeyid, sizeof(struct sctp_authkeyid));\\r\\nif (ret < 0)\\r\\nbreak;\\r\\n}\\r\\n# endif\\r\\ndata->ccs_rcvd = 0;\\r\\ndata->ccs_sent = 0;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_GET_SNDINFO:\\r\\nif (num > (long)sizeof(struct bio_dgram_sctp_sndinfo))\\r\\nnum = sizeof(struct bio_dgram_sctp_sndinfo);\\r\\nmemcpy(ptr, &(data->sndinfo), num);\\r\\nret = num;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_SET_SNDINFO:\\r\\nif (num > (long)sizeof(struct bio_dgram_sctp_sndinfo))\\r\\nnum = sizeof(struct bio_dgram_sctp_sndinfo);\\r\\nmemcpy(&(data->sndinfo), ptr, num);\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_GET_RCVINFO:\\r\\nif (num > (long)sizeof(struct bio_dgram_sctp_rcvinfo))\\r\\nnum = sizeof(struct bio_dgram_sctp_rcvinfo);\\r\\nmemcpy(ptr, &data->rcvinfo, num);\\r\\nret = num;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_SET_RCVINFO:\\r\\nif (num > (long)sizeof(struct bio_dgram_sctp_rcvinfo))\\r\\nnum = sizeof(struct bio_dgram_sctp_rcvinfo);\\r\\nmemcpy(&(data->rcvinfo), ptr, num);\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_GET_PRINFO:\\r\\nif (num > (long)sizeof(struct bio_dgram_sctp_prinfo))\\r\\nnum = sizeof(struct bio_dgram_sctp_prinfo);\\r\\nmemcpy(ptr, &(data->prinfo), num);\\r\\nret = num;\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_SET_PRINFO:\\r\\nif (num > (long)sizeof(struct bio_dgram_sctp_prinfo))\\r\\nnum = sizeof(struct bio_dgram_sctp_prinfo);\\r\\nmemcpy(&(data->prinfo), ptr, num);\\r\\nbreak;\\r\\ncase BIO_CTRL_DGRAM_SCTP_SAVE_SHUTDOWN:\\r\\nif (num > 0)\\r\\ndata->save_shutdown = 1;\\r\\nelse\\r\\ndata->save_shutdown = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nret = dgram_ctrl(b, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint BIO_dgram_sctp_notification_cb(BIO *b,\\r\\nvoid (*handle_notifications) (BIO *bio,\\r\\nvoid\\r\\n*context,\\r\\nvoid *buf),\\r\\nvoid *context)\\r\\n{\\r\\nbio_dgram_sctp_data *data = (bio_dgram_sctp_data *) b->ptr;\\r\\nif (handle_notifications != NULL) {\\r\\ndata->handle_notifications = handle_notifications;\\r\\ndata->notification_context = context;\\r\\n} else\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n}\\r\\nint BIO_dgram_sctp_wait_for_dry(BIO *b)\\r\\n{\\r\\nint is_dry = 0;\\r\\nint n, sockflags, ret;\\r\\nunion sctp_notification snp;\\r\\nstruct msghdr msg;\\r\\nstruct iovec iov;\\r\\n# ifdef SCTP_EVENT\\r\\nstruct sctp_event event;\\r\\n# else\\r\\nstruct sctp_event_subscribe event;\\r\\nsocklen_t eventsize;\\r\\n# endif\\r\\nbio_dgram_sctp_data *data = (bio_dgram_sctp_data *) b->ptr;\\r\\n# ifdef SCTP_EVENT\\r\\nmemset(&event, 0, sizeof(struct sctp_event));\\r\\nevent.se_assoc_id = 0;\\r\\nevent.se_type = SCTP_SENDER_DRY_EVENT;\\r\\nevent.se_on = 1;\\r\\nret =\\r\\nsetsockopt(b->num, IPPROTO_SCTP, SCTP_EVENT, &event,\\r\\nsizeof(struct sctp_event));\\r\\n# else\\r\\neventsize = sizeof(struct sctp_event_subscribe);\\r\\nret = getsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event, &eventsize);\\r\\nif (ret < 0)\\r\\nreturn -1;\\r\\nevent.sctp_sender_dry_event = 1;\\r\\nret =\\r\\nsetsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event,\\r\\nsizeof(struct sctp_event_subscribe));\\r\\n# endif\\r\\nif (ret < 0)\\r\\nreturn -1;\\r\\nmemset(&snp, 0x00, sizeof(union sctp_notification));\\r\\niov.iov_base = (char *)&snp;\\r\\niov.iov_len = sizeof(union sctp_notification);\\r\\nmsg.msg_name = NULL;\\r\\nmsg.msg_namelen = 0;\\r\\nmsg.msg_iov = &iov;\\r\\nmsg.msg_iovlen = 1;\\r\\nmsg.msg_control = NULL;\\r\\nmsg.msg_controllen = 0;\\r\\nmsg.msg_flags = 0;\\r\\nn = recvmsg(b->num, &msg, MSG_PEEK);\\r\\nif (n <= 0) {\\r\\nif ((n < 0) && (get_last_socket_error() != EAGAIN)\\r\\n&& (get_last_socket_error() != EWOULDBLOCK))\\r\\nreturn -1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nwhile (msg.msg_flags & MSG_NOTIFICATION) {\\r\\nmemset(&snp, 0x00, sizeof(union sctp_notification));\\r\\niov.iov_base = (char *)&snp;\\r\\niov.iov_len = sizeof(union sctp_notification);\\r\\nmsg.msg_name = NULL;\\r\\nmsg.msg_namelen = 0;\\r\\nmsg.msg_iov = &iov;\\r\\nmsg.msg_iovlen = 1;\\r\\nmsg.msg_control = NULL;\\r\\nmsg.msg_controllen = 0;\\r\\nmsg.msg_flags = 0;\\r\\nn = recvmsg(b->num, &msg, 0);\\r\\nif (n <= 0) {\\r\\nif ((n < 0) && (get_last_socket_error() != EAGAIN)\\r\\n&& (get_last_socket_error() != EWOULDBLOCK))\\r\\nreturn -1;\\r\\nelse\\r\\nreturn is_dry;\\r\\n}\\r\\nif (snp.sn_header.sn_type == SCTP_SENDER_DRY_EVENT) {\\r\\nis_dry = 1;\\r\\n# ifdef SCTP_EVENT\\r\\nmemset(&event, 0, sizeof(struct sctp_event));\\r\\nevent.se_assoc_id = 0;\\r\\nevent.se_type = SCTP_SENDER_DRY_EVENT;\\r\\nevent.se_on = 0;\\r\\nret =\\r\\nsetsockopt(b->num, IPPROTO_SCTP, SCTP_EVENT, &event,\\r\\nsizeof(struct sctp_event));\\r\\n# else\\r\\neventsize = (socklen_t) sizeof(struct sctp_event_subscribe);\\r\\nret =\\r\\ngetsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event,\\r\\n&eventsize);\\r\\nif (ret < 0)\\r\\nreturn -1;\\r\\nevent.sctp_sender_dry_event = 0;\\r\\nret =\\r\\nsetsockopt(b->num, IPPROTO_SCTP, SCTP_EVENTS, &event,\\r\\nsizeof(struct sctp_event_subscribe));\\r\\n# endif\\r\\nif (ret < 0)\\r\\nreturn -1;\\r\\n}\\r\\n# ifdef SCTP_AUTHENTICATION_EVENT\\r\\nif (snp.sn_header.sn_type == SCTP_AUTHENTICATION_EVENT)\\r\\ndgram_sctp_handle_auth_free_key_event(b, &snp);\\r\\n# endif\\r\\nif (data->handle_notifications != NULL)\\r\\ndata->handle_notifications(b, data->notification_context,\\r\\n(void *)&snp);\\r\\nmemset(&snp, 0x00, sizeof(union sctp_notification));\\r\\niov.iov_base = (char *)&snp;\\r\\niov.iov_len = sizeof(union sctp_notification);\\r\\nmsg.msg_name = NULL;\\r\\nmsg.msg_namelen = 0;\\r\\nmsg.msg_iov = &iov;\\r\\nmsg.msg_iovlen = 1;\\r\\nmsg.msg_control = NULL;\\r\\nmsg.msg_controllen = 0;\\r\\nmsg.msg_flags = 0;\\r\\nif (is_dry) {\\r\\nsockflags = fcntl(b->num, F_GETFL, 0);\\r\\nfcntl(b->num, F_SETFL, O_NONBLOCK);\\r\\n}\\r\\nn = recvmsg(b->num, &msg, MSG_PEEK);\\r\\nif (is_dry) {\\r\\nfcntl(b->num, F_SETFL, sockflags);\\r\\n}\\r\\nif (n <= 0) {\\r\\nif ((n < 0) && (get_last_socket_error() != EAGAIN)\\r\\n&& (get_last_socket_error() != EWOULDBLOCK))\\r\\nreturn -1;\\r\\nelse\\r\\nreturn is_dry;\\r\\n}\\r\\n}\\r\\nreturn is_dry;\\r\\n}\\r\\nint BIO_dgram_sctp_msg_waiting(BIO *b)\\r\\n{\\r\\nint n, sockflags;\\r\\nunion sctp_notification snp;\\r\\nstruct msghdr msg;\\r\\nstruct iovec iov;\\r\\nbio_dgram_sctp_data *data = (bio_dgram_sctp_data *) b->ptr;\\r\\ndo {\\r\\nmemset(&snp, 0x00, sizeof(union sctp_notification));\\r\\niov.iov_base = (char *)&snp;\\r\\niov.iov_len = sizeof(union sctp_notification);\\r\\nmsg.msg_name = NULL;\\r\\nmsg.msg_namelen = 0;\\r\\nmsg.msg_iov = &iov;\\r\\nmsg.msg_iovlen = 1;\\r\\nmsg.msg_control = NULL;\\r\\nmsg.msg_controllen = 0;\\r\\nmsg.msg_flags = 0;\\r\\nsockflags = fcntl(b->num, F_GETFL, 0);\\r\\nfcntl(b->num, F_SETFL, O_NONBLOCK);\\r\\nn = recvmsg(b->num, &msg, MSG_PEEK);\\r\\nfcntl(b->num, F_SETFL, sockflags);\\r\\nif (n > 0 && (msg.msg_flags & MSG_NOTIFICATION)) {\\r\\n# ifdef SCTP_AUTHENTICATION_EVENT\\r\\nif (snp.sn_header.sn_type == SCTP_AUTHENTICATION_EVENT)\\r\\ndgram_sctp_handle_auth_free_key_event(b, &snp);\\r\\n# endif\\r\\nmemset(&snp, 0x00, sizeof(union sctp_notification));\\r\\niov.iov_base = (char *)&snp;\\r\\niov.iov_len = sizeof(union sctp_notification);\\r\\nmsg.msg_name = NULL;\\r\\nmsg.msg_namelen = 0;\\r\\nmsg.msg_iov = &iov;\\r\\nmsg.msg_iovlen = 1;\\r\\nmsg.msg_control = NULL;\\r\\nmsg.msg_controllen = 0;\\r\\nmsg.msg_flags = 0;\\r\\nn = recvmsg(b->num, &msg, 0);\\r\\nif (data->handle_notifications != NULL)\\r\\ndata->handle_notifications(b, data->notification_context,\\r\\n(void *)&snp);\\r\\n}\\r\\n} while (n > 0 && (msg.msg_flags & MSG_NOTIFICATION));\\r\\nif (n > 0)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dgram_sctp_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = dgram_sctp_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int BIO_dgram_should_retry(int i)\\r\\n{\\r\\nint err;\\r\\nif ((i == 0) || (i == -1)) {\\r\\nerr = get_last_socket_error();\\r\\n# if defined(OPENSSL_SYS_WINDOWS)\\r\\n# endif\\r\\nreturn (BIO_dgram_non_fatal_error(err));\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nint BIO_dgram_non_fatal_error(int err)\\r\\n{\\r\\nswitch (err) {\\r\\n# if defined(OPENSSL_SYS_WINDOWS)\\r\\n# if defined(WSAEWOULDBLOCK)\\r\\ncase WSAEWOULDBLOCK:\\r\\n# endif\\r\\n# if 0\\r\\n# if defined(WSAENOTCONN)\\r\\ncase WSAENOTCONN:\\r\\n# endif\\r\\n# endif\\r\\n# endif\\r\\n# ifdef EWOULDBLOCK\\r\\n# ifdef WSAEWOULDBLOCK\\r\\n# if WSAEWOULDBLOCK != EWOULDBLOCK\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n# else\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n# endif\\r\\n# ifdef EINTR\\r\\ncase EINTR:\\r\\n# endif\\r\\n# ifdef EAGAIN\\r\\n# if EWOULDBLOCK != EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\n# endif\\r\\n# ifdef EPROTO\\r\\ncase EPROTO:\\r\\n# endif\\r\\n# ifdef EINPROGRESS\\r\\ncase EINPROGRESS:\\r\\n# endif\\r\\n# ifdef EALREADY\\r\\ncase EALREADY:\\r\\n# endif\\r\\nreturn (1);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nstatic void get_current_time(struct timeval *t)\\r\\n{\\r\\n# if defined(_WIN32)\\r\\nSYSTEMTIME st;\\r\\nunion {\\r\\nunsigned __int64 ul;\\r\\nFILETIME ft;\\r\\n} now;\\r\\nGetSystemTime(&st);\\r\\nSystemTimeToFileTime(&st, &now.ft);\\r\\n# ifdef __MINGW32__\\r\\nnow.ul -= 116444736000000000ULL;\\r\\n# else\\r\\nnow.ul -= 116444736000000000UI64;\\r\\n# endif\\r\\nt->tv_sec = (long)(now.ul / 10000000);\\r\\nt->tv_usec = ((int)(now.ul % 10000000)) / 10;\\r\\n# elif defined(OPENSSL_SYS_VMS)\\r\\nstruct timeb tb;\\r\\nftime(&tb);\\r\\nt->tv_sec = (long)tb.time;\\r\\nt->tv_usec = (long)tb.millitm * 1000;\\r\\n# else\\r\\ngettimeofday(t, NULL);\\r\\n# endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_mdc2dgst_c", "target": 0, "func": "int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)\\r\\n{\\r\\nsize_t i, j;\\r\\ni = c->num;\\r\\nif (i != 0) {\\r\\nif (i + len < MDC2_BLOCK) {\\r\\nmemcpy(&(c->data[i]), in, len);\\r\\nc->num += (int)len;\\r\\nreturn 1;\\r\\n} else {\\r\\nj = MDC2_BLOCK - i;\\r\\nmemcpy(&(c->data[i]), in, j);\\r\\nlen -= j;\\r\\nin += j;\\r\\nc->num = 0;\\r\\nmdc2_body(c, &(c->data[0]), MDC2_BLOCK);\\r\\n}\\r\\n}\\r\\ni = len & ~((size_t)MDC2_BLOCK - 1);\\r\\nif (i > 0)\\r\\nmdc2_body(c, in, i);\\r\\nj = len - i;\\r\\nif (j > 0) {\\r\\nmemcpy(&(c->data[0]), &(in[i]), j);\\r\\nc->num = (int)j;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void mdc2_body(MDC2_CTX *c, const unsigned char *in, size_t len)\\r\\n{\\r\\nregister DES_LONG tin0, tin1;\\r\\nregister DES_LONG ttin0, ttin1;\\r\\nDES_LONG d[2], dd[2];\\r\\nDES_key_schedule k;\\r\\nunsigned char *p;\\r\\nsize_t i;\\r\\nfor (i = 0; i < len; i += 8) {\\r\\nc2l(in, tin0);\\r\\nd[0] = dd[0] = tin0;\\r\\nc2l(in, tin1);\\r\\nd[1] = dd[1] = tin1;\\r\\nc->h[0] = (c->h[0] & 0x9f) | 0x40;\\r\\nc->hh[0] = (c->hh[0] & 0x9f) | 0x20;\\r\\nDES_set_odd_parity(&c->h);\\r\\nDES_set_key_unchecked(&c->h, &k);\\r\\nDES_encrypt1(d, &k, 1);\\r\\nDES_set_odd_parity(&c->hh);\\r\\nDES_set_key_unchecked(&c->hh, &k);\\r\\nDES_encrypt1(dd, &k, 1);\\r\\nttin0 = tin0 ^ dd[0];\\r\\nttin1 = tin1 ^ dd[1];\\r\\ntin0 ^= d[0];\\r\\ntin1 ^= d[1];\\r\\np = c->h;\\r\\nl2c(tin0, p);\\r\\nl2c(ttin1, p);\\r\\np = c->hh;\\r\\nl2c(ttin0, p);\\r\\nl2c(tin1, p);\\r\\n}\\r\\n}\\r\\nint MDC2_Final(unsigned char *md, MDC2_CTX *c)\\r\\n{\\r\\nunsigned int i;\\r\\nint j;\\r\\ni = c->num;\\r\\nj = c->pad_type;\\r\\nif ((i > 0) || (j == 2)) {\\r\\nif (j == 2)\\r\\nc->data[i++] = 0x80;\\r\\nmemset(&(c->data[i]), 0, MDC2_BLOCK - i);\\r\\nmdc2_body(c, c->data, MDC2_BLOCK);\\r\\n}\\r\\nmemcpy(md, (char *)c->h, MDC2_BLOCK);\\r\\nmemcpy(&(md[MDC2_BLOCK]), (char *)c->hh, MDC2_BLOCK);\\r\\nreturn 1;\\r\\n}\\r\\nmain()\\r\\n{\\r\\nunsigned char md[MDC2_DIGEST_LENGTH];\\r\\nint i;\\r\\nMDC2_CTX c;\\r\\nstatic char *text = \"Now is the time for all \";\\r\\nMDC2_Init(&c);\\r\\nMDC2_Update(&c, text, strlen(text));\\r\\nMDC2_Final(&(md[0]), &c);\\r\\nfor (i = 0; i < MDC2_DIGEST_LENGTH; i++)\\r\\nprintf(\"%02X\", md[i]);\\r\\nprintf(\"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_verify_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint i, ret = 1, badarg = 0;\\r\\nchar *CApath = NULL, *CAfile = NULL;\\r\\nchar *untfile = NULL, *trustfile = NULL, *crlfile = NULL;\\r\\nSTACK_OF(X509) *untrusted = NULL, *trusted = NULL;\\r\\nSTACK_OF(X509_CRL) *crls = NULL;\\r\\nX509_STORE *cert_ctx = NULL;\\r\\nX509_LOOKUP *lookup = NULL;\\r\\nX509_VERIFY_PARAM *vpm = NULL;\\r\\nint crl_download = 0;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\ncert_ctx = X509_STORE_new();\\r\\nif (cert_ctx == NULL)\\r\\ngoto end;\\r\\nX509_STORE_set_verify_cb(cert_ctx, cb);\\r\\nERR_load_crypto_strings();\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nargc--;\\r\\nargv++;\\r\\nfor (;;) {\\r\\nif (argc >= 1) {\\r\\nif (strcmp(*argv, \"-CApath\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto end;\\r\\nCApath = *(++argv);\\r\\n} else if (strcmp(*argv, \"-CAfile\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto end;\\r\\nCAfile = *(++argv);\\r\\n} else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm)) {\\r\\nif (badarg)\\r\\ngoto end;\\r\\ncontinue;\\r\\n} else if (strcmp(*argv, \"-untrusted\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto end;\\r\\nuntfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-trusted\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto end;\\r\\ntrustfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-CRLfile\") == 0) {\\r\\nif (argc-- < 1)\\r\\ngoto end;\\r\\ncrlfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-crl_download\") == 0)\\r\\ncrl_download = 1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto end;\\r\\nengine = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-help\") == 0)\\r\\ngoto end;\\r\\nelse if (strcmp(*argv, \"-verbose\") == 0)\\r\\nv_verbose = 1;\\r\\nelse if (argv[0][0] == '-')\\r\\ngoto end;\\r\\nelse\\r\\nbreak;\\r\\nargc--;\\r\\nargv++;\\r\\n} else\\r\\nbreak;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (vpm)\\r\\nX509_STORE_set1_param(cert_ctx, vpm);\\r\\nlookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_file());\\r\\nif (lookup == NULL)\\r\\nabort();\\r\\nif (CAfile) {\\r\\ni = X509_LOOKUP_load_file(lookup, CAfile, X509_FILETYPE_PEM);\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"Error loading file %s\\n\", CAfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nX509_LOOKUP_load_file(lookup, NULL, X509_FILETYPE_DEFAULT);\\r\\nlookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL)\\r\\nabort();\\r\\nif (CApath) {\\r\\ni = X509_LOOKUP_add_dir(lookup, CApath, X509_FILETYPE_PEM);\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"Error loading directory %s\\n\", CApath);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nX509_LOOKUP_add_dir(lookup, NULL, X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nif (untfile) {\\r\\nuntrusted = load_certs(bio_err, untfile, FORMAT_PEM,\\r\\nNULL, e, \"untrusted certificates\");\\r\\nif (!untrusted)\\r\\ngoto end;\\r\\n}\\r\\nif (trustfile) {\\r\\ntrusted = load_certs(bio_err, trustfile, FORMAT_PEM,\\r\\nNULL, e, \"trusted certificates\");\\r\\nif (!trusted)\\r\\ngoto end;\\r\\n}\\r\\nif (crlfile) {\\r\\ncrls = load_crls(bio_err, crlfile, FORMAT_PEM, NULL, e, \"other CRLs\");\\r\\nif (!crls)\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nif (crl_download)\\r\\nstore_setup_crl_download(cert_ctx);\\r\\nif (argc < 1) {\\r\\nif (1 != check(cert_ctx, NULL, untrusted, trusted, crls, e))\\r\\nret = -1;\\r\\n} else {\\r\\nfor (i = 0; i < argc; i++)\\r\\nif (1 != check(cert_ctx, argv[i], untrusted, trusted, crls, e))\\r\\nret = -1;\\r\\n}\\r\\nend:\\r\\nif (ret == 1) {\\r\\nBIO_printf(bio_err,\\r\\n\"usage: verify [-verbose] [-CApath path] [-CAfile file] [-purpose purpose] [-crl_check]\");\\r\\nBIO_printf(bio_err, \" [-attime timestamp]\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err, \" [-engine e]\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \" cert1 cert2 ...\\n\");\\r\\nBIO_printf(bio_err, \"recognized usages:\\n\");\\r\\nfor (i = 0; i < X509_PURPOSE_get_count(); i++) {\\r\\nX509_PURPOSE *ptmp;\\r\\nptmp = X509_PURPOSE_get0(i);\\r\\nBIO_printf(bio_err, \"\\t%-10s\\t%s\\n\",\\r\\nX509_PURPOSE_get0_sname(ptmp),\\r\\nX509_PURPOSE_get0_name(ptmp));\\r\\n}\\r\\n}\\r\\nif (vpm)\\r\\nX509_VERIFY_PARAM_free(vpm);\\r\\nif (cert_ctx != NULL)\\r\\nX509_STORE_free(cert_ctx);\\r\\nsk_X509_pop_free(untrusted, X509_free);\\r\\nsk_X509_pop_free(trusted, X509_free);\\r\\nsk_X509_CRL_pop_free(crls, X509_CRL_free);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret < 0 ? 2 : ret);\\r\\n}\\r\\nstatic int MS_CALLBACK cb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nint cert_error = X509_STORE_CTX_get_error(ctx);\\r\\nX509 *current_cert = X509_STORE_CTX_get_current_cert(ctx);\\r\\nif (!ok) {\\r\\nif (current_cert) {\\r\\nX509_NAME_print_ex_fp(stdout,\\r\\nX509_get_subject_name(current_cert),\\r\\n0, XN_FLAG_ONELINE);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nprintf(\"%serror %d at %d depth lookup:%s\\n\",\\r\\nX509_STORE_CTX_get0_parent_ctx(ctx) ? \"[CRL path]\" : \"\",\\r\\ncert_error,\\r\\nX509_STORE_CTX_get_error_depth(ctx),\\r\\nX509_verify_cert_error_string(cert_error));\\r\\nswitch (cert_error) {\\r\\ncase X509_V_ERR_NO_EXPLICIT_POLICY:\\r\\npolicies_print(NULL, ctx);\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\ncase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\\r\\ncase X509_V_ERR_INVALID_CA:\\r\\ncase X509_V_ERR_INVALID_NON_CA:\\r\\ncase X509_V_ERR_PATH_LENGTH_EXCEEDED:\\r\\ncase X509_V_ERR_INVALID_PURPOSE:\\r\\ncase X509_V_ERR_CRL_HAS_EXPIRED:\\r\\ncase X509_V_ERR_CRL_NOT_YET_VALID:\\r\\ncase X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:\\r\\nok = 1;\\r\\n}\\r\\nreturn ok;\\r\\n}\\r\\nif (cert_error == X509_V_OK && ok == 2)\\r\\npolicies_print(NULL, ctx);\\r\\nif (!v_verbose)\\r\\nERR_clear_error();\\r\\nreturn (ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_object_c", "target": 0, "func": "int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned char **pp)\\r\\n{\\r\\nunsigned char *p;\\r\\nint objsize;\\r\\nif ((a == NULL) || (a->data == NULL))\\r\\nreturn (0);\\r\\nobjsize = ASN1_object_size(0, a->length, V_ASN1_OBJECT);\\r\\nif (pp == NULL)\\r\\nreturn objsize;\\r\\np = *pp;\\r\\nASN1_put_object(&p, 0, a->length, V_ASN1_OBJECT, V_ASN1_UNIVERSAL);\\r\\nmemcpy(p, a->data, a->length);\\r\\np += a->length;\\r\\n*pp = p;\\r\\nreturn (objsize);\\r\\n}\\r\\nint a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num)\\r\\n{\\r\\nint i, first, len = 0, c, use_bn;\\r\\nchar ftmp[24], *tmp = ftmp;\\r\\nint tmpsize = sizeof ftmp;\\r\\nconst char *p;\\r\\nunsigned long l;\\r\\nBIGNUM *bl = NULL;\\r\\nif (num == 0)\\r\\nreturn (0);\\r\\nelse if (num == -1)\\r\\nnum = strlen(buf);\\r\\np = buf;\\r\\nc = *(p++);\\r\\nnum--;\\r\\nif ((c >= '0') && (c <= '2')) {\\r\\nfirst = c - '0';\\r\\n} else {\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_FIRST_NUM_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif (num <= 0) {\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_MISSING_SECOND_NUMBER);\\r\\ngoto err;\\r\\n}\\r\\nc = *(p++);\\r\\nnum--;\\r\\nfor (;;) {\\r\\nif (num <= 0)\\r\\nbreak;\\r\\nif ((c != '.') && (c != ' ')) {\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_INVALID_SEPARATOR);\\r\\ngoto err;\\r\\n}\\r\\nl = 0;\\r\\nuse_bn = 0;\\r\\nfor (;;) {\\r\\nif (num <= 0)\\r\\nbreak;\\r\\nnum--;\\r\\nc = *(p++);\\r\\nif ((c == ' ') || (c == '.'))\\r\\nbreak;\\r\\nif ((c < '0') || (c > '9')) {\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_INVALID_DIGIT);\\r\\ngoto err;\\r\\n}\\r\\nif (!use_bn && l >= ((ULONG_MAX - 80) / 10L)) {\\r\\nuse_bn = 1;\\r\\nif (!bl)\\r\\nbl = BN_new();\\r\\nif (!bl || !BN_set_word(bl, l))\\r\\ngoto err;\\r\\n}\\r\\nif (use_bn) {\\r\\nif (!BN_mul_word(bl, 10L)\\r\\n|| !BN_add_word(bl, c - '0'))\\r\\ngoto err;\\r\\n} else\\r\\nl = l * 10L + (long)(c - '0');\\r\\n}\\r\\nif (len == 0) {\\r\\nif ((first < 2) && (l >= 40)) {\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT,\\r\\nASN1_R_SECOND_NUMBER_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif (use_bn) {\\r\\nif (!BN_add_word(bl, first * 40))\\r\\ngoto err;\\r\\n} else\\r\\nl += (long)first *40;\\r\\n}\\r\\ni = 0;\\r\\nif (use_bn) {\\r\\nint blsize;\\r\\nblsize = BN_num_bits(bl);\\r\\nblsize = (blsize + 6) / 7;\\r\\nif (blsize > tmpsize) {\\r\\nif (tmp != ftmp)\\r\\nOPENSSL_free(tmp);\\r\\ntmpsize = blsize + 32;\\r\\ntmp = OPENSSL_malloc(tmpsize);\\r\\nif (!tmp)\\r\\ngoto err;\\r\\n}\\r\\nwhile (blsize--)\\r\\ntmp[i++] = (unsigned char)BN_div_word(bl, 0x80L);\\r\\n} else {\\r\\nfor (;;) {\\r\\ntmp[i++] = (unsigned char)l & 0x7f;\\r\\nl >>= 7L;\\r\\nif (l == 0L)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (out != NULL) {\\r\\nif (len + i > olen) {\\r\\nASN1err(ASN1_F_A2D_ASN1_OBJECT, ASN1_R_BUFFER_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nwhile (--i > 0)\\r\\nout[len++] = tmp[i] | 0x80;\\r\\nout[len++] = tmp[0];\\r\\n} else\\r\\nlen += i;\\r\\n}\\r\\nif (tmp != ftmp)\\r\\nOPENSSL_free(tmp);\\r\\nif (bl)\\r\\nBN_free(bl);\\r\\nreturn (len);\\r\\nerr:\\r\\nif (tmp != ftmp)\\r\\nOPENSSL_free(tmp);\\r\\nif (bl)\\r\\nBN_free(bl);\\r\\nreturn (0);\\r\\n}\\r\\nint i2t_ASN1_OBJECT(char *buf, int buf_len, ASN1_OBJECT *a)\\r\\n{\\r\\nreturn OBJ_obj2txt(buf, buf_len, a, 0);\\r\\n}\\r\\nint i2a_ASN1_OBJECT(BIO *bp, ASN1_OBJECT *a)\\r\\n{\\r\\nchar buf[80], *p = buf;\\r\\nint i;\\r\\nif ((a == NULL) || (a->data == NULL))\\r\\nreturn (BIO_write(bp, \"NULL\", 4));\\r\\ni = i2t_ASN1_OBJECT(buf, sizeof buf, a);\\r\\nif (i > (int)(sizeof(buf) - 1)) {\\r\\np = OPENSSL_malloc(i + 1);\\r\\nif (!p)\\r\\nreturn -1;\\r\\ni2t_ASN1_OBJECT(p, i + 1, a);\\r\\n}\\r\\nif (i <= 0)\\r\\nreturn BIO_write(bp, \"<INVALID>\", 9);\\r\\nBIO_write(bp, p, i);\\r\\nif (p != buf)\\r\\nOPENSSL_free(p);\\r\\nreturn (i);\\r\\n}\\r\\nASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nlong len;\\r\\nint tag, xclass;\\r\\nint inf, i;\\r\\nASN1_OBJECT *ret = NULL;\\r\\np = *pp;\\r\\ninf = ASN1_get_object(&p, &len, &tag, &xclass, length);\\r\\nif (inf & 0x80) {\\r\\ni = ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_OBJECT) {\\r\\ni = ASN1_R_EXPECTING_AN_OBJECT;\\r\\ngoto err;\\r\\n}\\r\\nret = c2i_ASN1_OBJECT(a, &p, len);\\r\\nif (ret)\\r\\n*pp = p;\\r\\nreturn ret;\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_OBJECT, i);\\r\\nreturn (NULL);\\r\\n}\\r\\nASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\\r\\nlong len)\\r\\n{\\r\\nASN1_OBJECT *ret = NULL;\\r\\nconst unsigned char *p;\\r\\nunsigned char *data;\\r\\nint i, length;\\r\\nif (len <= 0 || len > INT_MAX || pp == NULL || (p = *pp) == NULL ||\\r\\np[len - 1] & 0x80) {\\r\\nASN1err(ASN1_F_C2I_ASN1_OBJECT, ASN1_R_INVALID_OBJECT_ENCODING);\\r\\nreturn NULL;\\r\\n}\\r\\nlength = (int)len;\\r\\nfor (i = 0; i < length; i++, p++) {\\r\\nif (*p == 0x80 && (!i || !(p[-1] & 0x80))) {\\r\\nASN1err(ASN1_F_C2I_ASN1_OBJECT, ASN1_R_INVALID_OBJECT_ENCODING);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nif ((a == NULL) || ((*a) == NULL) ||\\r\\n!((*a)->flags & ASN1_OBJECT_FLAG_DYNAMIC)) {\\r\\nif ((ret = ASN1_OBJECT_new()) == NULL)\\r\\nreturn (NULL);\\r\\n} else\\r\\nret = (*a);\\r\\np = *pp;\\r\\ndata = (unsigned char *)ret->data;\\r\\nret->data = NULL;\\r\\nif ((data == NULL) || (ret->length < length)) {\\r\\nret->length = 0;\\r\\nif (data != NULL)\\r\\nOPENSSL_free(data);\\r\\ndata = (unsigned char *)OPENSSL_malloc(length);\\r\\nif (data == NULL) {\\r\\ni = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nret->flags |= ASN1_OBJECT_FLAG_DYNAMIC_DATA;\\r\\n}\\r\\nmemcpy(data, p, length);\\r\\nret->data = data;\\r\\nret->length = length;\\r\\nret->sn = NULL;\\r\\nret->ln = NULL;\\r\\np += length;\\r\\nif (a != NULL)\\r\\n(*a) = ret;\\r\\n*pp = p;\\r\\nreturn (ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_C2I_ASN1_OBJECT, i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nASN1_OBJECT_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nASN1_OBJECT *ASN1_OBJECT_new(void)\\r\\n{\\r\\nASN1_OBJECT *ret;\\r\\nret = (ASN1_OBJECT *)OPENSSL_malloc(sizeof(ASN1_OBJECT));\\r\\nif (ret == NULL) {\\r\\nASN1err(ASN1_F_ASN1_OBJECT_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nret->length = 0;\\r\\nret->data = NULL;\\r\\nret->nid = 0;\\r\\nret->sn = NULL;\\r\\nret->ln = NULL;\\r\\nret->flags = ASN1_OBJECT_FLAG_DYNAMIC;\\r\\nreturn (ret);\\r\\n}\\r\\nvoid ASN1_OBJECT_free(ASN1_OBJECT *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn;\\r\\nif (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_STRINGS) {\\r\\n#ifndef CONST_STRICT\\r\\nif (a->sn != NULL)\\r\\nOPENSSL_free((void *)a->sn);\\r\\nif (a->ln != NULL)\\r\\nOPENSSL_free((void *)a->ln);\\r\\n#endif\\r\\na->sn = a->ln = NULL;\\r\\n}\\r\\nif (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_DATA) {\\r\\nif (a->data != NULL)\\r\\nOPENSSL_free((void *)a->data);\\r\\na->data = NULL;\\r\\na->length = 0;\\r\\n}\\r\\nif (a->flags & ASN1_OBJECT_FLAG_DYNAMIC)\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nASN1_OBJECT *ASN1_OBJECT_create(int nid, unsigned char *data, int len,\\r\\nconst char *sn, const char *ln)\\r\\n{\\r\\nASN1_OBJECT o;\\r\\no.sn = sn;\\r\\no.ln = ln;\\r\\no.data = data;\\r\\no.nid = nid;\\r\\no.length = len;\\r\\no.flags = ASN1_OBJECT_FLAG_DYNAMIC | ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |\\r\\nASN1_OBJECT_FLAG_DYNAMIC_DATA;\\r\\nreturn (OBJ_dup(&o));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec2_mult_c", "target": 0, "func": "static int gf2m_Mdouble(const EC_GROUP *group, BIGNUM *x, BIGNUM *z,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t1;\\r\\nint ret = 0;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nif (t1 == NULL)\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, x, x, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, t1, z, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, z, x, t1, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, x, x, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, t1, t1, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, t1, &group->b, t1, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(x, x, t1))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int gf2m_Madd(const EC_GROUP *group, const BIGNUM *x, BIGNUM *x1,\\r\\nBIGNUM *z1, const BIGNUM *x2, const BIGNUM *z2,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t1, *t2;\\r\\nint ret = 0;\\r\\nBN_CTX_start(ctx);\\r\\nt1 = BN_CTX_get(ctx);\\r\\nt2 = BN_CTX_get(ctx);\\r\\nif (t2 == NULL)\\r\\ngoto err;\\r\\nif (!BN_copy(t1, x))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, x1, x1, z2, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, z1, z1, x2, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, t2, x1, z1, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(z1, z1, x1))\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, z1, z1, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, x1, z1, t1, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(x1, x1, t2))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int gf2m_Mxy(const EC_GROUP *group, const BIGNUM *x, const BIGNUM *y,\\r\\nBIGNUM *x1, BIGNUM *z1, BIGNUM *x2, BIGNUM *z2,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t3, *t4, *t5;\\r\\nint ret = 0;\\r\\nif (BN_is_zero(z1)) {\\r\\nBN_zero(x2);\\r\\nBN_zero(z2);\\r\\nreturn 1;\\r\\n}\\r\\nif (BN_is_zero(z2)) {\\r\\nif (!BN_copy(x2, x))\\r\\nreturn 0;\\r\\nif (!BN_GF2m_add(z2, x, y))\\r\\nreturn 0;\\r\\nreturn 2;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nt3 = BN_CTX_get(ctx);\\r\\nt4 = BN_CTX_get(ctx);\\r\\nt5 = BN_CTX_get(ctx);\\r\\nif (t5 == NULL)\\r\\ngoto err;\\r\\nif (!BN_one(t5))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, t3, z1, z2, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, z1, z1, x, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(z1, z1, x1))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, z2, z2, x, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, x1, z2, x1, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(z2, z2, x2))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, z2, z2, z1, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, t4, x, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(t4, t4, y))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, t4, t4, t3, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(t4, t4, z2))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, t3, t3, x, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_div(group, t3, t5, t3, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, t4, t3, t4, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, x2, x1, t3, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(z2, x2, x))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, z2, z2, t4, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(z2, z2, y))\\r\\ngoto err;\\r\\nret = 2;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ec_GF2m_montgomery_point_multiply(const EC_GROUP *group,\\r\\nEC_POINT *r,\\r\\nconst BIGNUM *scalar,\\r\\nconst EC_POINT *point,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *x1, *x2, *z1, *z2;\\r\\nint ret = 0, i;\\r\\nBN_ULONG mask, word;\\r\\nif (r == point) {\\r\\nECerr(EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY, EC_R_INVALID_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\nif ((scalar == NULL) || BN_is_zero(scalar) || (point == NULL) ||\\r\\nEC_POINT_is_at_infinity(group, point)) {\\r\\nreturn EC_POINT_set_to_infinity(group, r);\\r\\n}\\r\\nif (!point->Z_is_one)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nx1 = BN_CTX_get(ctx);\\r\\nz1 = BN_CTX_get(ctx);\\r\\nif (z1 == NULL)\\r\\ngoto err;\\r\\nx2 = &r->X;\\r\\nz2 = &r->Y;\\r\\nbn_wexpand(x1, group->field.top);\\r\\nbn_wexpand(z1, group->field.top);\\r\\nbn_wexpand(x2, group->field.top);\\r\\nbn_wexpand(z2, group->field.top);\\r\\nif (!BN_GF2m_mod_arr(x1, &point->X, group->poly))\\r\\ngoto err;\\r\\nif (!BN_one(z1))\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, z2, x1, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_sqr(group, x2, z2, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(x2, x2, &group->b))\\r\\ngoto err;\\r\\ni = scalar->top - 1;\\r\\nmask = BN_TBIT;\\r\\nword = scalar->d[i];\\r\\nwhile (!(word & mask))\\r\\nmask >>= 1;\\r\\nmask >>= 1;\\r\\nif (!mask) {\\r\\ni--;\\r\\nmask = BN_TBIT;\\r\\n}\\r\\nfor (; i >= 0; i--) {\\r\\nword = scalar->d[i];\\r\\nwhile (mask) {\\r\\nBN_consttime_swap(word & mask, x1, x2, group->field.top);\\r\\nBN_consttime_swap(word & mask, z1, z2, group->field.top);\\r\\nif (!gf2m_Madd(group, &point->X, x2, z2, x1, z1, ctx))\\r\\ngoto err;\\r\\nif (!gf2m_Mdouble(group, x1, z1, ctx))\\r\\ngoto err;\\r\\nBN_consttime_swap(word & mask, x1, x2, group->field.top);\\r\\nBN_consttime_swap(word & mask, z1, z2, group->field.top);\\r\\nmask >>= 1;\\r\\n}\\r\\nmask = BN_TBIT;\\r\\n}\\r\\ni = gf2m_Mxy(group, &point->X, &point->Y, x1, z1, x2, z2, ctx);\\r\\nif (i == 0)\\r\\ngoto err;\\r\\nelse if (i == 1) {\\r\\nif (!EC_POINT_set_to_infinity(group, r))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_one(&r->Z))\\r\\ngoto err;\\r\\nr->Z_is_one = 1;\\r\\n}\\r\\nBN_set_negative(&r->X, 0);\\r\\nBN_set_negative(&r->Y, 0);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_simple_mul(const EC_GROUP *group, EC_POINT *r,\\r\\nconst BIGNUM *scalar, size_t num,\\r\\nconst EC_POINT *points[], const BIGNUM *scalars[],\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint ret = 0;\\r\\nsize_t i;\\r\\nEC_POINT *p = NULL;\\r\\nEC_POINT *acc = NULL;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif ((scalar && (num > 1)) || (num > 2)\\r\\n|| (num == 0 && EC_GROUP_have_precompute_mult(group))) {\\r\\nret = ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);\\r\\ngoto err;\\r\\n}\\r\\nif ((p = EC_POINT_new(group)) == NULL)\\r\\ngoto err;\\r\\nif ((acc = EC_POINT_new(group)) == NULL)\\r\\ngoto err;\\r\\nif (!EC_POINT_set_to_infinity(group, acc))\\r\\ngoto err;\\r\\nif (scalar) {\\r\\nif (!ec_GF2m_montgomery_point_multiply\\r\\n(group, p, scalar, group->generator, ctx))\\r\\ngoto err;\\r\\nif (BN_is_negative(scalar))\\r\\nif (!group->meth->invert(group, p, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->add(group, acc, acc, p, ctx))\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < num; i++) {\\r\\nif (!ec_GF2m_montgomery_point_multiply\\r\\n(group, p, scalars[i], points[i], ctx))\\r\\ngoto err;\\r\\nif (BN_is_negative(scalars[i]))\\r\\nif (!group->meth->invert(group, p, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->add(group, acc, acc, p, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_copy(r, acc))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (p)\\r\\nEC_POINT_free(p);\\r\\nif (acc)\\r\\nEC_POINT_free(acc);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GF2m_precompute_mult(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nreturn ec_wNAF_precompute_mult(group, ctx);\\r\\n}\\r\\nint ec_GF2m_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nreturn ec_wNAF_have_precompute_mult(group);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_nbio_c", "target": 0, "func": "BIO_METHOD *BIO_f_nbio_test(void)\\r\\n{\\r\\nreturn (&methods_nbiof);\\r\\n}\\r\\nstatic int nbiof_new(BIO *bi)\\r\\n{\\r\\nNBIO_TEST *nt;\\r\\nif (!(nt = (NBIO_TEST *)OPENSSL_malloc(sizeof(NBIO_TEST))))\\r\\nreturn (0);\\r\\nnt->lrn = -1;\\r\\nnt->lwn = -1;\\r\\nbi->ptr = (char *)nt;\\r\\nbi->init = 1;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int nbiof_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (a->ptr != NULL)\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr = NULL;\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int nbiof_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\n#if 1\\r\\nint num;\\r\\nunsigned char n;\\r\\n#endif\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nBIO_clear_retry_flags(b);\\r\\n#if 1\\r\\nRAND_pseudo_bytes(&n, 1);\\r\\nnum = (n & 0x07);\\r\\nif (outl > num)\\r\\noutl = num;\\r\\nif (num == 0) {\\r\\nret = -1;\\r\\nBIO_set_retry_read(b);\\r\\n} else\\r\\n#endif\\r\\n{\\r\\nret = BIO_read(b->next_bio, out, outl);\\r\\nif (ret < 0)\\r\\nBIO_copy_next_retry(b);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int nbiof_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nNBIO_TEST *nt;\\r\\nint ret = 0;\\r\\nint num;\\r\\nunsigned char n;\\r\\nif ((in == NULL) || (inl <= 0))\\r\\nreturn (0);\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nnt = (NBIO_TEST *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\n#if 1\\r\\nif (nt->lwn > 0) {\\r\\nnum = nt->lwn;\\r\\nnt->lwn = 0;\\r\\n} else {\\r\\nRAND_pseudo_bytes(&n, 1);\\r\\nnum = (n & 7);\\r\\n}\\r\\nif (inl > num)\\r\\ninl = num;\\r\\nif (num == 0) {\\r\\nret = -1;\\r\\nBIO_set_retry_write(b);\\r\\n} else\\r\\n#endif\\r\\n{\\r\\nret = BIO_write(b->next_bio, in, inl);\\r\\nif (ret < 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nnt->lwn = inl;\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long nbiof_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nret = 0L;\\r\\nbreak;\\r\\ndefault:\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long nbiof_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret = 1;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\nret = BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int nbiof_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nif (bp->next_bio == NULL)\\r\\nreturn (0);\\r\\nreturn (BIO_gets(bp->next_bio, buf, size));\\r\\n}\\r\\nstatic int nbiof_puts(BIO *bp, const char *str)\\r\\n{\\r\\nif (bp->next_bio == NULL)\\r\\nreturn (0);\\r\\nreturn (BIO_puts(bp->next_bio, str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t_crl_c", "target": 0, "func": "int X509_CRL_print_fp(FILE *fp, X509_CRL *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nX509err(X509_F_X509_CRL_PRINT_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = X509_CRL_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint X509_CRL_print(BIO *out, X509_CRL *x)\\r\\n{\\r\\nSTACK_OF(X509_REVOKED) *rev;\\r\\nX509_REVOKED *r;\\r\\nlong l;\\r\\nint i;\\r\\nchar *p;\\r\\nBIO_printf(out, \"Certificate Revocation List (CRL):\\n\");\\r\\nl = X509_CRL_get_version(x);\\r\\nBIO_printf(out, \"%8sVersion %lu (0x%lx)\\n\", \"\", l + 1, l);\\r\\ni = OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nX509_signature_print(out, x->sig_alg, NULL);\\r\\np = X509_NAME_oneline(X509_CRL_get_issuer(x), NULL, 0);\\r\\nBIO_printf(out, \"%8sIssuer: %s\\n\", \"\", p);\\r\\nOPENSSL_free(p);\\r\\nBIO_printf(out, \"%8sLast Update: \", \"\");\\r\\nASN1_TIME_print(out, X509_CRL_get_lastUpdate(x));\\r\\nBIO_printf(out, \"\\n%8sNext Update: \", \"\");\\r\\nif (X509_CRL_get_nextUpdate(x))\\r\\nASN1_TIME_print(out, X509_CRL_get_nextUpdate(x));\\r\\nelse\\r\\nBIO_printf(out, \"NONE\");\\r\\nBIO_printf(out, \"\\n\");\\r\\nX509V3_extensions_print(out, \"CRL extensions\", x->crl->extensions, 0, 8);\\r\\nrev = X509_CRL_get_REVOKED(x);\\r\\nif (sk_X509_REVOKED_num(rev) > 0)\\r\\nBIO_printf(out, \"Revoked Certificates:\\n\");\\r\\nelse\\r\\nBIO_printf(out, \"No Revoked Certificates.\\n\");\\r\\nfor (i = 0; i < sk_X509_REVOKED_num(rev); i++) {\\r\\nr = sk_X509_REVOKED_value(rev, i);\\r\\nBIO_printf(out, \" Serial Number: \");\\r\\ni2a_ASN1_INTEGER(out, r->serialNumber);\\r\\nBIO_printf(out, \"\\n Revocation Date: \");\\r\\nASN1_TIME_print(out, r->revocationDate);\\r\\nBIO_printf(out, \"\\n\");\\r\\nX509V3_extensions_print(out, \"CRL entry extensions\",\\r\\nr->extensions, 0, 8);\\r\\n}\\r\\nX509_signature_print(out, x->sig_alg, x->signature);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_bf_c", "target": 0, "func": "static int bf_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nBF_set_key(&data(ctx)->ks, EVP_CIPHER_CTX_key_length(ctx), key);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_pci_c", "target": 0, "func": "static int i2r_pci(X509V3_EXT_METHOD *method, PROXY_CERT_INFO_EXTENSION *pci,\\r\\nBIO *out, int indent)\\r\\n{\\r\\nBIO_printf(out, \"%*sPath Length Constraint: \", indent, \"\");\\r\\nif (pci->pcPathLengthConstraint)\\r\\ni2a_ASN1_INTEGER(out, pci->pcPathLengthConstraint);\\r\\nelse\\r\\nBIO_printf(out, \"infinite\");\\r\\nBIO_puts(out, \"\\n\");\\r\\nBIO_printf(out, \"%*sPolicy Language: \", indent, \"\");\\r\\ni2a_ASN1_OBJECT(out, pci->proxyPolicy->policyLanguage);\\r\\nBIO_puts(out, \"\\n\");\\r\\nif (pci->proxyPolicy->policy && pci->proxyPolicy->policy->data)\\r\\nBIO_printf(out, \"%*sPolicy Text: %s\\n\", indent, \"\",\\r\\npci->proxyPolicy->policy->data);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int process_pci_value(CONF_VALUE *val,\\r\\nASN1_OBJECT **language, ASN1_INTEGER **pathlen,\\r\\nASN1_OCTET_STRING **policy)\\r\\n{\\r\\nint free_policy = 0;\\r\\nif (strcmp(val->name, \"language\") == 0) {\\r\\nif (*language) {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,\\r\\nX509V3_R_POLICY_LANGUAGE_ALREADY_DEFINED);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(*language = OBJ_txt2obj(val->value, 0))) {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,\\r\\nX509V3_R_INVALID_OBJECT_IDENTIFIER);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\n} else if (strcmp(val->name, \"pathlen\") == 0) {\\r\\nif (*pathlen) {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,\\r\\nX509V3_R_POLICY_PATH_LENGTH_ALREADY_DEFINED);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\nif (!X509V3_get_value_int(val, pathlen)) {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,\\r\\nX509V3_R_POLICY_PATH_LENGTH);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\n} else if (strcmp(val->name, \"policy\") == 0) {\\r\\nunsigned char *tmp_data = NULL;\\r\\nlong val_len;\\r\\nif (!*policy) {\\r\\n*policy = ASN1_OCTET_STRING_new();\\r\\nif (!*policy) {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_MALLOC_FAILURE);\\r\\nX509V3_conf_err(val);\\r\\nreturn 0;\\r\\n}\\r\\nfree_policy = 1;\\r\\n}\\r\\nif (strncmp(val->value, \"hex:\", 4) == 0) {\\r\\nunsigned char *tmp_data2 =\\r\\nstring_to_hex(val->value + 4, &val_len);\\r\\nif (!tmp_data2) {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,\\r\\nX509V3_R_ILLEGAL_HEX_DIGIT);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\ntmp_data = OPENSSL_realloc((*policy)->data,\\r\\n(*policy)->length + val_len + 1);\\r\\nif (tmp_data) {\\r\\n(*policy)->data = tmp_data;\\r\\nmemcpy(&(*policy)->data[(*policy)->length],\\r\\ntmp_data2, val_len);\\r\\n(*policy)->length += val_len;\\r\\n(*policy)->data[(*policy)->length] = '\\0';\\r\\n} else {\\r\\nOPENSSL_free(tmp_data2);\\r\\n(*policy)->data = NULL;\\r\\n(*policy)->length = 0;\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_MALLOC_FAILURE);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\nOPENSSL_free(tmp_data2);\\r\\n} else if (strncmp(val->value, \"file:\", 5) == 0) {\\r\\nunsigned char buf[2048];\\r\\nint n;\\r\\nBIO *b = BIO_new_file(val->value + 5, \"r\");\\r\\nif (!b) {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_BIO_LIB);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\nwhile ((n = BIO_read(b, buf, sizeof(buf))) > 0\\r\\n|| (n == 0 && BIO_should_retry(b))) {\\r\\nif (!n)\\r\\ncontinue;\\r\\ntmp_data = OPENSSL_realloc((*policy)->data,\\r\\n(*policy)->length + n + 1);\\r\\nif (!tmp_data)\\r\\nbreak;\\r\\n(*policy)->data = tmp_data;\\r\\nmemcpy(&(*policy)->data[(*policy)->length], buf, n);\\r\\n(*policy)->length += n;\\r\\n(*policy)->data[(*policy)->length] = '\\0';\\r\\n}\\r\\nBIO_free_all(b);\\r\\nif (n < 0) {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_BIO_LIB);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\n} else if (strncmp(val->value, \"text:\", 5) == 0) {\\r\\nval_len = strlen(val->value + 5);\\r\\ntmp_data = OPENSSL_realloc((*policy)->data,\\r\\n(*policy)->length + val_len + 1);\\r\\nif (tmp_data) {\\r\\n(*policy)->data = tmp_data;\\r\\nmemcpy(&(*policy)->data[(*policy)->length],\\r\\nval->value + 5, val_len);\\r\\n(*policy)->length += val_len;\\r\\n(*policy)->data[(*policy)->length] = '\\0';\\r\\n} else {\\r\\n(*policy)->data = NULL;\\r\\n(*policy)->length = 0;\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_MALLOC_FAILURE);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE,\\r\\nX509V3_R_INCORRECT_POLICY_SYNTAX_TAG);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\nif (!tmp_data) {\\r\\nX509V3err(X509V3_F_PROCESS_PCI_VALUE, ERR_R_MALLOC_FAILURE);\\r\\nX509V3_conf_err(val);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nif (free_policy) {\\r\\nASN1_OCTET_STRING_free(*policy);\\r\\n*policy = NULL;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic PROXY_CERT_INFO_EXTENSION *r2i_pci(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *value)\\r\\n{\\r\\nPROXY_CERT_INFO_EXTENSION *pci = NULL;\\r\\nSTACK_OF(CONF_VALUE) *vals;\\r\\nASN1_OBJECT *language = NULL;\\r\\nASN1_INTEGER *pathlen = NULL;\\r\\nASN1_OCTET_STRING *policy = NULL;\\r\\nint i, j;\\r\\nvals = X509V3_parse_list(value);\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(vals); i++) {\\r\\nCONF_VALUE *cnf = sk_CONF_VALUE_value(vals, i);\\r\\nif (!cnf->name || (*cnf->name != '@' && !cnf->value)) {\\r\\nX509V3err(X509V3_F_R2I_PCI,\\r\\nX509V3_R_INVALID_PROXY_POLICY_SETTING);\\r\\nX509V3_conf_err(cnf);\\r\\ngoto err;\\r\\n}\\r\\nif (*cnf->name == '@') {\\r\\nSTACK_OF(CONF_VALUE) *sect;\\r\\nint success_p = 1;\\r\\nsect = X509V3_get_section(ctx, cnf->name + 1);\\r\\nif (!sect) {\\r\\nX509V3err(X509V3_F_R2I_PCI, X509V3_R_INVALID_SECTION);\\r\\nX509V3_conf_err(cnf);\\r\\ngoto err;\\r\\n}\\r\\nfor (j = 0; success_p && j < sk_CONF_VALUE_num(sect); j++) {\\r\\nsuccess_p =\\r\\nprocess_pci_value(sk_CONF_VALUE_value(sect, j),\\r\\n&language, &pathlen, &policy);\\r\\n}\\r\\nX509V3_section_free(ctx, sect);\\r\\nif (!success_p)\\r\\ngoto err;\\r\\n} else {\\r\\nif (!process_pci_value(cnf, &language, &pathlen, &policy)) {\\r\\nX509V3_conf_err(cnf);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!language) {\\r\\nX509V3err(X509V3_F_R2I_PCI,\\r\\nX509V3_R_NO_PROXY_CERT_POLICY_LANGUAGE_DEFINED);\\r\\ngoto err;\\r\\n}\\r\\ni = OBJ_obj2nid(language);\\r\\nif ((i == NID_Independent || i == NID_id_ppl_inheritAll) && policy) {\\r\\nX509V3err(X509V3_F_R2I_PCI,\\r\\nX509V3_R_POLICY_WHEN_PROXY_LANGUAGE_REQUIRES_NO_POLICY);\\r\\ngoto err;\\r\\n}\\r\\npci = PROXY_CERT_INFO_EXTENSION_new();\\r\\nif (!pci) {\\r\\nX509V3err(X509V3_F_R2I_PCI, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npci->proxyPolicy->policyLanguage = language;\\r\\nlanguage = NULL;\\r\\npci->proxyPolicy->policy = policy;\\r\\npolicy = NULL;\\r\\npci->pcPathLengthConstraint = pathlen;\\r\\npathlen = NULL;\\r\\ngoto end;\\r\\nerr:\\r\\nif (language) {\\r\\nASN1_OBJECT_free(language);\\r\\nlanguage = NULL;\\r\\n}\\r\\nif (pathlen) {\\r\\nASN1_INTEGER_free(pathlen);\\r\\npathlen = NULL;\\r\\n}\\r\\nif (policy) {\\r\\nASN1_OCTET_STRING_free(policy);\\r\\npolicy = NULL;\\r\\n}\\r\\nif (pci) {\\r\\nPROXY_CERT_INFO_EXTENSION_free(pci);\\r\\npci = NULL;\\r\\n}\\r\\nend:\\r\\nsk_CONF_VALUE_pop_free(vals, X509V3_conf_free);\\r\\nreturn pci;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_io_c", "target": 0, "func": "int CMS_stream(unsigned char ***boundary, CMS_ContentInfo *cms)\\r\\n{\\r\\nASN1_OCTET_STRING **pos;\\r\\npos = CMS_get0_content(cms);\\r\\nif (!pos)\\r\\nreturn 0;\\r\\nif (!*pos)\\r\\n*pos = ASN1_OCTET_STRING_new();\\r\\nif (*pos) {\\r\\n(*pos)->flags |= ASN1_STRING_FLAG_NDEF;\\r\\n(*pos)->flags &= ~ASN1_STRING_FLAG_CONT;\\r\\n*boundary = &(*pos)->data;\\r\\nreturn 1;\\r\\n}\\r\\nCMSerr(CMS_F_CMS_STREAM, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nCMS_ContentInfo *d2i_CMS_bio(BIO *bp, CMS_ContentInfo **cms)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(CMS_ContentInfo), bp, cms);\\r\\n}\\r\\nint i2d_CMS_bio(BIO *bp, CMS_ContentInfo *cms)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(CMS_ContentInfo), bp, cms);\\r\\n}\\r\\nBIO *BIO_new_CMS(BIO *out, CMS_ContentInfo *cms)\\r\\n{\\r\\nreturn BIO_new_NDEF(out, (ASN1_VALUE *)cms,\\r\\nASN1_ITEM_rptr(CMS_ContentInfo));\\r\\n}\\r\\nint i2d_CMS_bio_stream(BIO *out, CMS_ContentInfo *cms, BIO *in, int flags)\\r\\n{\\r\\nreturn i2d_ASN1_bio_stream(out, (ASN1_VALUE *)cms, in, flags,\\r\\nASN1_ITEM_rptr(CMS_ContentInfo));\\r\\n}\\r\\nint PEM_write_bio_CMS_stream(BIO *out, CMS_ContentInfo *cms, BIO *in,\\r\\nint flags)\\r\\n{\\r\\nreturn PEM_write_bio_ASN1_stream(out, (ASN1_VALUE *)cms, in, flags,\\r\\n\"CMS\", ASN1_ITEM_rptr(CMS_ContentInfo));\\r\\n}\\r\\nint SMIME_write_CMS(BIO *bio, CMS_ContentInfo *cms, BIO *data, int flags)\\r\\n{\\r\\nSTACK_OF(X509_ALGOR) *mdalgs;\\r\\nint ctype_nid = OBJ_obj2nid(cms->contentType);\\r\\nint econt_nid = OBJ_obj2nid(CMS_get0_eContentType(cms));\\r\\nif (ctype_nid == NID_pkcs7_signed)\\r\\nmdalgs = cms->d.signedData->digestAlgorithms;\\r\\nelse\\r\\nmdalgs = NULL;\\r\\nreturn SMIME_write_ASN1(bio, (ASN1_VALUE *)cms, data, flags,\\r\\nctype_nid, econt_nid, mdalgs,\\r\\nASN1_ITEM_rptr(CMS_ContentInfo));\\r\\n}\\r\\nCMS_ContentInfo *SMIME_read_CMS(BIO *bio, BIO **bcont)\\r\\n{\\r\\nreturn (CMS_ContentInfo *)SMIME_read_ASN1(bio, bcont,\\r\\nASN1_ITEM_rptr\\r\\n(CMS_ContentInfo));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_sess_c", "target": 0, "func": "SSL_SESSION *SSL_get_session(const SSL *ssl)\\r\\n{\\r\\nreturn (ssl->session);\\r\\n}\\r\\nSSL_SESSION *SSL_get1_session(SSL *ssl)\\r\\n{\\r\\nSSL_SESSION *sess;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_SESSION);\\r\\nsess = ssl->session;\\r\\nif (sess)\\r\\nsess->references++;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_SESSION);\\r\\nreturn (sess);\\r\\n}\\r\\nint SSL_SESSION_get_ex_new_index(long argl, void *argp,\\r\\nCRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint SSL_SESSION_set_ex_data(SSL_SESSION *s, int idx, void *arg)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&s->ex_data, idx, arg));\\r\\n}\\r\\nvoid *SSL_SESSION_get_ex_data(const SSL_SESSION *s, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&s->ex_data, idx));\\r\\n}\\r\\nSSL_SESSION *SSL_SESSION_new(void)\\r\\n{\\r\\nSSL_SESSION *ss;\\r\\nss = (SSL_SESSION *)OPENSSL_malloc(sizeof(SSL_SESSION));\\r\\nif (ss == NULL) {\\r\\nSSLerr(SSL_F_SSL_SESSION_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nmemset(ss, 0, sizeof(SSL_SESSION));\\r\\nss->verify_result = 1;\\r\\nss->references = 1;\\r\\nss->timeout = 60 * 5 + 4;\\r\\nss->time = (unsigned long)time(NULL);\\r\\nss->prev = NULL;\\r\\nss->next = NULL;\\r\\nss->compress_meth = 0;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nss->tlsext_hostname = NULL;\\r\\n# ifndef OPENSSL_NO_EC\\r\\nss->tlsext_ecpointformatlist_length = 0;\\r\\nss->tlsext_ecpointformatlist = NULL;\\r\\nss->tlsext_ellipticcurvelist_length = 0;\\r\\nss->tlsext_ellipticcurvelist = NULL;\\r\\n# endif\\r\\n#endif\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nss->psk_identity_hint = NULL;\\r\\nss->psk_identity = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nss->srp_username = NULL;\\r\\n#endif\\r\\nreturn (ss);\\r\\n}\\r\\nconst unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s,\\r\\nunsigned int *len)\\r\\n{\\r\\nif (len)\\r\\n*len = s->session_id_length;\\r\\nreturn s->session_id;\\r\\n}\\r\\nunsigned int SSL_SESSION_get_compress_id(const SSL_SESSION *s)\\r\\n{\\r\\nreturn s->compress_meth;\\r\\n}\\r\\nstatic int def_generate_session_id(const SSL *ssl, unsigned char *id,\\r\\nunsigned int *id_len)\\r\\n{\\r\\nunsigned int retry = 0;\\r\\ndo\\r\\nif (RAND_pseudo_bytes(id, *id_len) <= 0)\\r\\nreturn 0;\\r\\nwhile (SSL_has_matching_session_id(ssl, id, *id_len) &&\\r\\n(++retry < MAX_SESS_ID_ATTEMPTS)) ;\\r\\nif (retry < MAX_SESS_ID_ATTEMPTS)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint ssl_get_new_session(SSL *s, int session)\\r\\n{\\r\\nunsigned int tmp;\\r\\nSSL_SESSION *ss = NULL;\\r\\nGEN_SESSION_CB cb = def_generate_session_id;\\r\\nif ((ss = SSL_SESSION_new()) == NULL)\\r\\nreturn (0);\\r\\nif (s->session_ctx->session_timeout == 0)\\r\\nss->timeout = SSL_get_default_timeout(s);\\r\\nelse\\r\\nss->timeout = s->session_ctx->session_timeout;\\r\\nif (s->session != NULL) {\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session = NULL;\\r\\n}\\r\\nif (session) {\\r\\nif (s->version == SSL2_VERSION) {\\r\\nss->ssl_version = SSL2_VERSION;\\r\\nss->session_id_length = SSL2_SSL_SESSION_ID_LENGTH;\\r\\n} else if (s->version == SSL3_VERSION) {\\r\\nss->ssl_version = SSL3_VERSION;\\r\\nss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\\r\\n} else if (s->version == TLS1_VERSION) {\\r\\nss->ssl_version = TLS1_VERSION;\\r\\nss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\\r\\n} else if (s->version == TLS1_1_VERSION) {\\r\\nss->ssl_version = TLS1_1_VERSION;\\r\\nss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\\r\\n} else if (s->version == TLS1_2_VERSION) {\\r\\nss->ssl_version = TLS1_2_VERSION;\\r\\nss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\\r\\n} else if (s->version == DTLS1_BAD_VER) {\\r\\nss->ssl_version = DTLS1_BAD_VER;\\r\\nss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\\r\\n} else if (s->version == DTLS1_VERSION) {\\r\\nss->ssl_version = DTLS1_VERSION;\\r\\nss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\\r\\n} else if (s->version == DTLS1_2_VERSION) {\\r\\nss->ssl_version = DTLS1_2_VERSION;\\r\\nss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;\\r\\n} else {\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn (0);\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s->tlsext_ticket_expected) {\\r\\nss->session_id_length = 0;\\r\\ngoto sess_id_done;\\r\\n}\\r\\n#endif\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nif (s->generate_session_id)\\r\\ncb = s->generate_session_id;\\r\\nelse if (s->session_ctx->generate_session_id)\\r\\ncb = s->session_ctx->generate_session_id;\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\ntmp = ss->session_id_length;\\r\\nif (!cb(s, ss->session_id, &tmp)) {\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION,\\r\\nSSL_R_SSL_SESSION_ID_CALLBACK_FAILED);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn (0);\\r\\n}\\r\\nif (!tmp || (tmp > ss->session_id_length)) {\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION,\\r\\nSSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn (0);\\r\\n}\\r\\nif ((tmp < ss->session_id_length) && (s->version == SSL2_VERSION))\\r\\nmemset(ss->session_id + tmp, 0, ss->session_id_length - tmp);\\r\\nelse\\r\\nss->session_id_length = tmp;\\r\\nif (SSL_has_matching_session_id(s, ss->session_id,\\r\\nss->session_id_length)) {\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION, SSL_R_SSL_SESSION_ID_CONFLICT);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn (0);\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nsess_id_done:\\r\\nif (s->tlsext_hostname) {\\r\\nss->tlsext_hostname = BUF_strdup(s->tlsext_hostname);\\r\\nif (ss->tlsext_hostname == NULL) {\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nss->session_id_length = 0;\\r\\n}\\r\\nif (s->sid_ctx_length > sizeof ss->sid_ctx) {\\r\\nSSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);\\r\\nSSL_SESSION_free(ss);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(ss->sid_ctx, s->sid_ctx, s->sid_ctx_length);\\r\\nss->sid_ctx_length = s->sid_ctx_length;\\r\\ns->session = ss;\\r\\nss->ssl_version = s->version;\\r\\nss->verify_result = X509_V_OK;\\r\\nreturn (1);\\r\\n}\\r\\nint ssl_get_prev_session(SSL *s, unsigned char *session_id, int len,\\r\\nconst unsigned char *limit)\\r\\n{\\r\\nSSL_SESSION *ret = NULL;\\r\\nint fatal = 0;\\r\\nint try_session_cache = 1;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nint r;\\r\\n#endif\\r\\nif (len > SSL_MAX_SSL_SESSION_ID_LENGTH)\\r\\ngoto err;\\r\\nif (len == 0)\\r\\ntry_session_cache = 0;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nr = tls1_process_ticket(s, session_id, len, limit, &ret);\\r\\nswitch (r) {\\r\\ncase -1:\\r\\nfatal = 1;\\r\\ngoto err;\\r\\ncase 0:\\r\\ncase 1:\\r\\nbreak;\\r\\ncase 2:\\r\\ncase 3:\\r\\ntry_session_cache = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (try_session_cache &&\\r\\nret == NULL &&\\r\\n!(s->session_ctx->session_cache_mode &\\r\\nSSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) {\\r\\nSSL_SESSION data;\\r\\ndata.ssl_version = s->version;\\r\\ndata.session_id_length = len;\\r\\nif (len == 0)\\r\\nreturn 0;\\r\\nmemcpy(data.session_id, session_id, len);\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nret = lh_SSL_SESSION_retrieve(s->session_ctx->sessions, &data);\\r\\nif (ret != NULL) {\\r\\nCRYPTO_add(&ret->references, 1, CRYPTO_LOCK_SSL_SESSION);\\r\\n}\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nif (ret == NULL)\\r\\ns->session_ctx->stats.sess_miss++;\\r\\n}\\r\\nif (try_session_cache &&\\r\\nret == NULL && s->session_ctx->get_session_cb != NULL) {\\r\\nint copy = 1;\\r\\nif ((ret = s->session_ctx->get_session_cb(s, session_id, len, &copy))) {\\r\\ns->session_ctx->stats.sess_cb_hit++;\\r\\nif (copy)\\r\\nCRYPTO_add(&ret->references, 1, CRYPTO_LOCK_SSL_SESSION);\\r\\nif (!\\r\\n(s->session_ctx->session_cache_mode &\\r\\nSSL_SESS_CACHE_NO_INTERNAL_STORE))\\r\\nSSL_CTX_add_session(s->session_ctx, ret);\\r\\n}\\r\\n}\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\nif (ret->sid_ctx_length != s->sid_ctx_length\\r\\n|| memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) {\\r\\ngoto err;\\r\\n}\\r\\nif ((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0) {\\r\\nSSLerr(SSL_F_SSL_GET_PREV_SESSION,\\r\\nSSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);\\r\\nfatal = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (ret->cipher == NULL) {\\r\\nunsigned char buf[5], *p;\\r\\nunsigned long l;\\r\\np = buf;\\r\\nl = ret->cipher_id;\\r\\nl2n(l, p);\\r\\nif ((ret->ssl_version >> 8) >= SSL3_VERSION_MAJOR)\\r\\nret->cipher = ssl_get_cipher_by_char(s, &(buf[2]));\\r\\nelse\\r\\nret->cipher = ssl_get_cipher_by_char(s, &(buf[1]));\\r\\nif (ret->cipher == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (ret->timeout < (long)(time(NULL) - ret->time)) {\\r\\ns->session_ctx->stats.sess_timeout++;\\r\\nif (try_session_cache) {\\r\\nSSL_CTX_remove_session(s->session_ctx, ret);\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\ns->session_ctx->stats.sess_hit++;\\r\\nif (s->session != NULL)\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session = ret;\\r\\ns->verify_result = s->session->verify_result;\\r\\nreturn 1;\\r\\nerr:\\r\\nif (ret != NULL) {\\r\\nSSL_SESSION_free(ret);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (!try_session_cache) {\\r\\ns->tlsext_ticket_expected = 1;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (fatal)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *c)\\r\\n{\\r\\nint ret = 0;\\r\\nSSL_SESSION *s;\\r\\nCRYPTO_add(&c->references, 1, CRYPTO_LOCK_SSL_SESSION);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\ns = lh_SSL_SESSION_insert(ctx->sessions, c);\\r\\nif (s != NULL && s != c) {\\r\\nSSL_SESSION_list_remove(ctx, s);\\r\\nSSL_SESSION_free(s);\\r\\ns = NULL;\\r\\n}\\r\\nif (s == NULL)\\r\\nSSL_SESSION_list_add(ctx, c);\\r\\nif (s != NULL) {\\r\\nSSL_SESSION_free(s);\\r\\nret = 0;\\r\\n} else {\\r\\nret = 1;\\r\\nif (SSL_CTX_sess_get_cache_size(ctx) > 0) {\\r\\nwhile (SSL_CTX_sess_number(ctx) >\\r\\nSSL_CTX_sess_get_cache_size(ctx)) {\\r\\nif (!remove_session_lock(ctx, ctx->session_cache_tail, 0))\\r\\nbreak;\\r\\nelse\\r\\nctx->stats.sess_cache_full++;\\r\\n}\\r\\n}\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *c)\\r\\n{\\r\\nreturn remove_session_lock(ctx, c, 1);\\r\\n}\\r\\nstatic int remove_session_lock(SSL_CTX *ctx, SSL_SESSION *c, int lck)\\r\\n{\\r\\nSSL_SESSION *r;\\r\\nint ret = 0;\\r\\nif ((c != NULL) && (c->session_id_length != 0)) {\\r\\nif (lck)\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nif ((r = lh_SSL_SESSION_retrieve(ctx->sessions, c)) == c) {\\r\\nret = 1;\\r\\nr = lh_SSL_SESSION_delete(ctx->sessions, c);\\r\\nSSL_SESSION_list_remove(ctx, c);\\r\\n}\\r\\nif (lck)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nif (ret) {\\r\\nr->not_resumable = 1;\\r\\nif (ctx->remove_session_cb != NULL)\\r\\nctx->remove_session_cb(ctx, r);\\r\\nSSL_SESSION_free(r);\\r\\n}\\r\\n} else\\r\\nret = 0;\\r\\nreturn (ret);\\r\\n}\\r\\nvoid SSL_SESSION_free(SSL_SESSION *ss)\\r\\n{\\r\\nint i;\\r\\nif (ss == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&ss->references, -1, CRYPTO_LOCK_SSL_SESSION);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SSL_SESSION\", ss);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"SSL_SESSION_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);\\r\\nOPENSSL_cleanse(ss->key_arg, sizeof ss->key_arg);\\r\\nOPENSSL_cleanse(ss->master_key, sizeof ss->master_key);\\r\\nOPENSSL_cleanse(ss->session_id, sizeof ss->session_id);\\r\\nif (ss->sess_cert != NULL)\\r\\nssl_sess_cert_free(ss->sess_cert);\\r\\nif (ss->peer != NULL)\\r\\nX509_free(ss->peer);\\r\\nif (ss->ciphers != NULL)\\r\\nsk_SSL_CIPHER_free(ss->ciphers);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (ss->tlsext_hostname != NULL)\\r\\nOPENSSL_free(ss->tlsext_hostname);\\r\\nif (ss->tlsext_tick != NULL)\\r\\nOPENSSL_free(ss->tlsext_tick);\\r\\n# ifndef OPENSSL_NO_EC\\r\\nss->tlsext_ecpointformatlist_length = 0;\\r\\nif (ss->tlsext_ecpointformatlist != NULL)\\r\\nOPENSSL_free(ss->tlsext_ecpointformatlist);\\r\\nss->tlsext_ellipticcurvelist_length = 0;\\r\\nif (ss->tlsext_ellipticcurvelist != NULL)\\r\\nOPENSSL_free(ss->tlsext_ellipticcurvelist);\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nif (ss->psk_identity_hint != NULL)\\r\\nOPENSSL_free(ss->psk_identity_hint);\\r\\nif (ss->psk_identity != NULL)\\r\\nOPENSSL_free(ss->psk_identity);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nif (ss->srp_username != NULL)\\r\\nOPENSSL_free(ss->srp_username);\\r\\n#endif\\r\\nOPENSSL_cleanse(ss, sizeof(*ss));\\r\\nOPENSSL_free(ss);\\r\\n}\\r\\nint SSL_set_session(SSL *s, SSL_SESSION *session)\\r\\n{\\r\\nint ret = 0;\\r\\nconst SSL_METHOD *meth;\\r\\nif (session != NULL) {\\r\\nmeth = s->ctx->method->get_ssl_method(session->ssl_version);\\r\\nif (meth == NULL)\\r\\nmeth = s->method->get_ssl_method(session->ssl_version);\\r\\nif (meth == NULL) {\\r\\nSSLerr(SSL_F_SSL_SET_SESSION, SSL_R_UNABLE_TO_FIND_SSL_METHOD);\\r\\nreturn (0);\\r\\n}\\r\\nif (meth != s->method) {\\r\\nif (!SSL_set_ssl_method(s, meth))\\r\\nreturn (0);\\r\\n}\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (s->kssl_ctx && !s->kssl_ctx->client_princ &&\\r\\nsession->krb5_client_princ_len > 0) {\\r\\ns->kssl_ctx->client_princ =\\r\\n(char *)OPENSSL_malloc(session->krb5_client_princ_len + 1);\\r\\nmemcpy(s->kssl_ctx->client_princ, session->krb5_client_princ,\\r\\nsession->krb5_client_princ_len);\\r\\ns->kssl_ctx->client_princ[session->krb5_client_princ_len] = '\\0';\\r\\n}\\r\\n#endif\\r\\nCRYPTO_add(&session->references, 1, CRYPTO_LOCK_SSL_SESSION);\\r\\nif (s->session != NULL)\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session = session;\\r\\ns->verify_result = s->session->verify_result;\\r\\nret = 1;\\r\\n} else {\\r\\nif (s->session != NULL) {\\r\\nSSL_SESSION_free(s->session);\\r\\ns->session = NULL;\\r\\n}\\r\\nmeth = s->ctx->method;\\r\\nif (meth != s->method) {\\r\\nif (!SSL_set_ssl_method(s, meth))\\r\\nreturn (0);\\r\\n}\\r\\nret = 1;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nlong SSL_SESSION_set_timeout(SSL_SESSION *s, long t)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn (0);\\r\\ns->timeout = t;\\r\\nreturn (1);\\r\\n}\\r\\nlong SSL_SESSION_get_timeout(const SSL_SESSION *s)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn (0);\\r\\nreturn (s->timeout);\\r\\n}\\r\\nlong SSL_SESSION_get_time(const SSL_SESSION *s)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn (0);\\r\\nreturn (s->time);\\r\\n}\\r\\nlong SSL_SESSION_set_time(SSL_SESSION *s, long t)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn (0);\\r\\ns->time = t;\\r\\nreturn (t);\\r\\n}\\r\\nX509 *SSL_SESSION_get0_peer(SSL_SESSION *s)\\r\\n{\\r\\nreturn s->peer;\\r\\n}\\r\\nint SSL_SESSION_set1_id_context(SSL_SESSION *s, const unsigned char *sid_ctx,\\r\\nunsigned int sid_ctx_len)\\r\\n{\\r\\nif (sid_ctx_len > SSL_MAX_SID_CTX_LENGTH) {\\r\\nSSLerr(SSL_F_SSL_SESSION_SET1_ID_CONTEXT,\\r\\nSSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\ns->sid_ctx_length = sid_ctx_len;\\r\\nmemcpy(s->sid_ctx, sid_ctx, sid_ctx_len);\\r\\nreturn 1;\\r\\n}\\r\\nlong SSL_CTX_set_timeout(SSL_CTX *s, long t)\\r\\n{\\r\\nlong l;\\r\\nif (s == NULL)\\r\\nreturn (0);\\r\\nl = s->session_timeout;\\r\\ns->session_timeout = t;\\r\\nreturn (l);\\r\\n}\\r\\nlong SSL_CTX_get_timeout(const SSL_CTX *s)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn (0);\\r\\nreturn (s->session_timeout);\\r\\n}\\r\\nint SSL_set_session_ticket_ext_cb(SSL *s, tls_session_ticket_ext_cb_fn cb,\\r\\nvoid *arg)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn (0);\\r\\ns->tls_session_ticket_ext_cb = cb;\\r\\ns->tls_session_ticket_ext_cb_arg = arg;\\r\\nreturn (1);\\r\\n}\\r\\nint SSL_set_session_ticket_ext(SSL *s, void *ext_data, int ext_len)\\r\\n{\\r\\nif (s->version >= TLS1_VERSION) {\\r\\nif (s->tlsext_session_ticket) {\\r\\nOPENSSL_free(s->tlsext_session_ticket);\\r\\ns->tlsext_session_ticket = NULL;\\r\\n}\\r\\ns->tlsext_session_ticket =\\r\\nOPENSSL_malloc(sizeof(TLS_SESSION_TICKET_EXT) + ext_len);\\r\\nif (!s->tlsext_session_ticket) {\\r\\nSSLerr(SSL_F_SSL_SET_SESSION_TICKET_EXT, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (ext_data) {\\r\\ns->tlsext_session_ticket->length = ext_len;\\r\\ns->tlsext_session_ticket->data = s->tlsext_session_ticket + 1;\\r\\nmemcpy(s->tlsext_session_ticket->data, ext_data, ext_len);\\r\\n} else {\\r\\ns->tlsext_session_ticket->length = 0;\\r\\ns->tlsext_session_ticket->data = NULL;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic void timeout_doall_arg(SSL_SESSION *s, TIMEOUT_PARAM *p)\\r\\n{\\r\\nif ((p->time == 0) || (p->time > (s->time + s->timeout))) {\\r\\n(void)lh_SSL_SESSION_delete(p->cache, s);\\r\\nSSL_SESSION_list_remove(p->ctx, s);\\r\\ns->not_resumable = 1;\\r\\nif (p->ctx->remove_session_cb != NULL)\\r\\np->ctx->remove_session_cb(p->ctx, s);\\r\\nSSL_SESSION_free(s);\\r\\n}\\r\\n}\\r\\nstatic void SSL_SESSION_list_remove(SSL_CTX *ctx, SSL_SESSION *s)\\r\\n{\\r\\nif ((s->next == NULL) || (s->prev == NULL))\\r\\nreturn;\\r\\nif (s->next == (SSL_SESSION *)&(ctx->session_cache_tail)) {\\r\\nif (s->prev == (SSL_SESSION *)&(ctx->session_cache_head)) {\\r\\nctx->session_cache_head = NULL;\\r\\nctx->session_cache_tail = NULL;\\r\\n} else {\\r\\nctx->session_cache_tail = s->prev;\\r\\ns->prev->next = (SSL_SESSION *)&(ctx->session_cache_tail);\\r\\n}\\r\\n} else {\\r\\nif (s->prev == (SSL_SESSION *)&(ctx->session_cache_head)) {\\r\\nctx->session_cache_head = s->next;\\r\\ns->next->prev = (SSL_SESSION *)&(ctx->session_cache_head);\\r\\n} else {\\r\\ns->next->prev = s->prev;\\r\\ns->prev->next = s->next;\\r\\n}\\r\\n}\\r\\ns->prev = s->next = NULL;\\r\\n}\\r\\nstatic void SSL_SESSION_list_add(SSL_CTX *ctx, SSL_SESSION *s)\\r\\n{\\r\\nif ((s->next != NULL) && (s->prev != NULL))\\r\\nSSL_SESSION_list_remove(ctx, s);\\r\\nif (ctx->session_cache_head == NULL) {\\r\\nctx->session_cache_head = s;\\r\\nctx->session_cache_tail = s;\\r\\ns->prev = (SSL_SESSION *)&(ctx->session_cache_head);\\r\\ns->next = (SSL_SESSION *)&(ctx->session_cache_tail);\\r\\n} else {\\r\\ns->next = ctx->session_cache_head;\\r\\ns->next->prev = s;\\r\\ns->prev = (SSL_SESSION *)&(ctx->session_cache_head);\\r\\nctx->session_cache_head = s;\\r\\n}\\r\\n}\\r\\nvoid SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,\\r\\nint (*cb) (struct ssl_st *ssl,\\r\\nSSL_SESSION *sess))\\r\\n{\\r\\nctx->new_session_cb = cb;\\r\\n}\\r\\nvoid SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,\\r\\nvoid (*cb) (SSL_CTX *ctx, SSL_SESSION *sess))\\r\\n{\\r\\nctx->remove_session_cb = cb;\\r\\n}\\r\\nvoid SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,\\r\\nSSL_SESSION *(*cb) (struct ssl_st *ssl,\\r\\nunsigned char *data, int len,\\r\\nint *copy))\\r\\n{\\r\\nctx->get_session_cb = cb;\\r\\n}\\r\\nvoid SSL_CTX_set_info_callback(SSL_CTX *ctx,\\r\\nvoid (*cb) (const SSL *ssl, int type, int val))\\r\\n{\\r\\nctx->info_callback = cb;\\r\\n}\\r\\nvoid SSL_CTX_set_client_cert_cb(SSL_CTX *ctx,\\r\\nint (*cb) (SSL *ssl, X509 **x509,\\r\\nEVP_PKEY **pkey))\\r\\n{\\r\\nctx->client_cert_cb = cb;\\r\\n}\\r\\nint SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e)\\r\\n{\\r\\nif (!ENGINE_init(e)) {\\r\\nSSLerr(SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE, ERR_R_ENGINE_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ENGINE_get_ssl_client_cert_function(e)) {\\r\\nSSLerr(SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE,\\r\\nSSL_R_NO_CLIENT_CERT_METHOD);\\r\\nENGINE_finish(e);\\r\\nreturn 0;\\r\\n}\\r\\nctx->client_cert_engine = e;\\r\\nreturn 1;\\r\\n}\\r\\nvoid SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx,\\r\\nint (*cb) (SSL *ssl,\\r\\nunsigned char *cookie,\\r\\nunsigned int *cookie_len))\\r\\n{\\r\\nctx->app_gen_cookie_cb = cb;\\r\\n}\\r\\nvoid SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx,\\r\\nint (*cb) (SSL *ssl, unsigned char *cookie,\\r\\nunsigned int cookie_len))\\r\\n{\\r\\nctx->app_verify_cookie_cb = cb;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_evp_lib_c", "target": 0, "func": "int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint ret;\\r\\nif (c->cipher->set_asn1_parameters != NULL)\\r\\nret = c->cipher->set_asn1_parameters(c, type);\\r\\nelse if (c->cipher->flags & EVP_CIPH_FLAG_DEFAULT_ASN1) {\\r\\nif (EVP_CIPHER_CTX_mode(c) == EVP_CIPH_WRAP_MODE) {\\r\\nASN1_TYPE_set(type, V_ASN1_NULL, NULL);\\r\\nret = 1;\\r\\n} else\\r\\nret = EVP_CIPHER_set_asn1_iv(c, type);\\r\\n} else\\r\\nret = -1;\\r\\nreturn (ret);\\r\\n}\\r\\nint EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint ret;\\r\\nif (c->cipher->get_asn1_parameters != NULL)\\r\\nret = c->cipher->get_asn1_parameters(c, type);\\r\\nelse if (c->cipher->flags & EVP_CIPH_FLAG_DEFAULT_ASN1) {\\r\\nif (EVP_CIPHER_CTX_mode(c) == EVP_CIPH_WRAP_MODE)\\r\\nreturn 1;\\r\\nret = EVP_CIPHER_get_asn1_iv(c, type);\\r\\n} else\\r\\nret = -1;\\r\\nreturn (ret);\\r\\n}\\r\\nint EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint i = 0;\\r\\nunsigned int l;\\r\\nif (type != NULL) {\\r\\nl = EVP_CIPHER_CTX_iv_length(c);\\r\\nOPENSSL_assert(l <= sizeof(c->iv));\\r\\ni = ASN1_TYPE_get_octetstring(type, c->oiv, l);\\r\\nif (i != (int)l)\\r\\nreturn (-1);\\r\\nelse if (i > 0)\\r\\nmemcpy(c->iv, c->oiv, l);\\r\\n}\\r\\nreturn (i);\\r\\n}\\r\\nint EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nint i = 0;\\r\\nunsigned int j;\\r\\nif (type != NULL) {\\r\\nj = EVP_CIPHER_CTX_iv_length(c);\\r\\nOPENSSL_assert(j <= sizeof(c->iv));\\r\\ni = ASN1_TYPE_set_octetstring(type, c->oiv, j);\\r\\n}\\r\\nreturn (i);\\r\\n}\\r\\nint EVP_CIPHER_type(const EVP_CIPHER *ctx)\\r\\n{\\r\\nint nid;\\r\\nASN1_OBJECT *otmp;\\r\\nnid = EVP_CIPHER_nid(ctx);\\r\\nswitch (nid) {\\r\\ncase NID_rc2_cbc:\\r\\ncase NID_rc2_64_cbc:\\r\\ncase NID_rc2_40_cbc:\\r\\nreturn NID_rc2_cbc;\\r\\ncase NID_rc4:\\r\\ncase NID_rc4_40:\\r\\nreturn NID_rc4;\\r\\ncase NID_aes_128_cfb128:\\r\\ncase NID_aes_128_cfb8:\\r\\ncase NID_aes_128_cfb1:\\r\\nreturn NID_aes_128_cfb128;\\r\\ncase NID_aes_192_cfb128:\\r\\ncase NID_aes_192_cfb8:\\r\\ncase NID_aes_192_cfb1:\\r\\nreturn NID_aes_192_cfb128;\\r\\ncase NID_aes_256_cfb128:\\r\\ncase NID_aes_256_cfb8:\\r\\ncase NID_aes_256_cfb1:\\r\\nreturn NID_aes_256_cfb128;\\r\\ncase NID_des_cfb64:\\r\\ncase NID_des_cfb8:\\r\\ncase NID_des_cfb1:\\r\\nreturn NID_des_cfb64;\\r\\ncase NID_des_ede3_cfb64:\\r\\ncase NID_des_ede3_cfb8:\\r\\ncase NID_des_ede3_cfb1:\\r\\nreturn NID_des_cfb64;\\r\\ndefault:\\r\\notmp = OBJ_nid2obj(nid);\\r\\nif (!otmp || !otmp->data)\\r\\nnid = NID_undef;\\r\\nASN1_OBJECT_free(otmp);\\r\\nreturn nid;\\r\\n}\\r\\n}\\r\\nint EVP_CIPHER_block_size(const EVP_CIPHER *e)\\r\\n{\\r\\nreturn e->block_size;\\r\\n}\\r\\nint EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nreturn ctx->cipher->block_size;\\r\\n}\\r\\nint EVP_Cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, unsigned int inl)\\r\\n{\\r\\nreturn ctx->cipher->do_cipher(ctx, out, in, inl);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nreturn ctx->cipher;\\r\\n}\\r\\nunsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nconst EVP_CIPHER *fcipher;\\r\\nfcipher = evp_get_fips_cipher(cipher);\\r\\nif (fcipher && fcipher->flags & EVP_CIPH_FLAG_FIPS)\\r\\nreturn cipher->flags | EVP_CIPH_FLAG_FIPS;\\r\\n#endif\\r\\nreturn cipher->flags;\\r\\n}\\r\\nunsigned long EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nreturn EVP_CIPHER_flags(ctx->cipher);\\r\\n#else\\r\\nreturn ctx->cipher->flags;\\r\\n#endif\\r\\n}\\r\\nvoid *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nreturn ctx->app_data;\\r\\n}\\r\\nvoid EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data)\\r\\n{\\r\\nctx->app_data = data;\\r\\n}\\r\\nint EVP_CIPHER_iv_length(const EVP_CIPHER *cipher)\\r\\n{\\r\\nreturn cipher->iv_len;\\r\\n}\\r\\nint EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nreturn ctx->cipher->iv_len;\\r\\n}\\r\\nint EVP_CIPHER_key_length(const EVP_CIPHER *cipher)\\r\\n{\\r\\nreturn cipher->key_len;\\r\\n}\\r\\nint EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nreturn ctx->key_len;\\r\\n}\\r\\nint EVP_CIPHER_nid(const EVP_CIPHER *cipher)\\r\\n{\\r\\nreturn cipher->nid;\\r\\n}\\r\\nint EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nreturn ctx->cipher->nid;\\r\\n}\\r\\nint EVP_MD_block_size(const EVP_MD *md)\\r\\n{\\r\\nreturn md->block_size;\\r\\n}\\r\\nint EVP_MD_type(const EVP_MD *md)\\r\\n{\\r\\nreturn md->type;\\r\\n}\\r\\nint EVP_MD_pkey_type(const EVP_MD *md)\\r\\n{\\r\\nreturn md->pkey_type;\\r\\n}\\r\\nint EVP_MD_size(const EVP_MD *md)\\r\\n{\\r\\nif (!md) {\\r\\nEVPerr(EVP_F_EVP_MD_SIZE, EVP_R_MESSAGE_DIGEST_IS_NULL);\\r\\nreturn -1;\\r\\n}\\r\\nreturn md->md_size;\\r\\n}\\r\\nconst EVP_MD *evp_get_fips_md(const EVP_MD *md)\\r\\n{\\r\\nint nid = EVP_MD_type(md);\\r\\nif (nid == NID_dsa)\\r\\nreturn FIPS_evp_dss1();\\r\\nelse if (nid == NID_dsaWithSHA)\\r\\nreturn FIPS_evp_dss();\\r\\nelse if (nid == NID_ecdsa_with_SHA1)\\r\\nreturn FIPS_evp_ecdsa();\\r\\nelse\\r\\nreturn FIPS_get_digestbynid(nid);\\r\\n}\\r\\nconst EVP_CIPHER *evp_get_fips_cipher(const EVP_CIPHER *cipher)\\r\\n{\\r\\nint nid = cipher->nid;\\r\\nif (nid == NID_undef)\\r\\nreturn FIPS_evp_enc_null();\\r\\nelse\\r\\nreturn FIPS_get_cipherbynid(nid);\\r\\n}\\r\\nunsigned long EVP_MD_flags(const EVP_MD *md)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nconst EVP_MD *fmd;\\r\\nfmd = evp_get_fips_md(md);\\r\\nif (fmd && fmd->flags & EVP_MD_FLAG_FIPS)\\r\\nreturn md->flags | EVP_MD_FLAG_FIPS;\\r\\n#endif\\r\\nreturn md->flags;\\r\\n}\\r\\nconst EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx)\\r\\n{\\r\\nif (!ctx)\\r\\nreturn NULL;\\r\\nreturn ctx->digest;\\r\\n}\\r\\nvoid EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags)\\r\\n{\\r\\nctx->flags |= flags;\\r\\n}\\r\\nvoid EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags)\\r\\n{\\r\\nctx->flags &= ~flags;\\r\\n}\\r\\nint EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx, int flags)\\r\\n{\\r\\nreturn (ctx->flags & flags);\\r\\n}\\r\\nvoid EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags)\\r\\n{\\r\\nctx->flags |= flags;\\r\\n}\\r\\nvoid EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags)\\r\\n{\\r\\nctx->flags &= ~flags;\\r\\n}\\r\\nint EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx, int flags)\\r\\n{\\r\\nreturn (ctx->flags & flags);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_smenc_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL;\\r\\nX509 *rcert = NULL;\\r\\nSTACK_OF(X509) *recips = NULL;\\r\\nPKCS7 *p7 = NULL;\\r\\nint ret = 1;\\r\\nint flags = PKCS7_STREAM;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\ntbio = BIO_new_file(\"signer.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nrcert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nif (!rcert)\\r\\ngoto err;\\r\\nrecips = sk_X509_new_null();\\r\\nif (!recips || !sk_X509_push(recips, rcert))\\r\\ngoto err;\\r\\nrcert = NULL;\\r\\nin = BIO_new_file(\"encr.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\np7 = PKCS7_encrypt(recips, in, EVP_des_ede3_cbc(), flags);\\r\\nif (!p7)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smencr.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!SMIME_write_PKCS7(out, p7, in, flags))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Encrypting Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (p7)\\r\\nPKCS7_free(p7);\\r\\nif (rcert)\\r\\nX509_free(rcert);\\r\\nif (recips)\\r\\nsk_X509_pop_free(recips, X509_free);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_decr_c", "target": 0, "func": "unsigned char *PKCS12_pbe_crypt(X509_ALGOR *algor, const char *pass,\\r\\nint passlen, unsigned char *in, int inlen,\\r\\nunsigned char **data, int *datalen, int en_de)\\r\\n{\\r\\nunsigned char *out;\\r\\nint outlen, i;\\r\\nEVP_CIPHER_CTX ctx;\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nif (!EVP_PBE_CipherInit(algor->algorithm, pass, passlen,\\r\\nalgor->parameter, &ctx, en_de)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,\\r\\nPKCS12_R_PKCS12_ALGOR_CIPHERINIT_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(out = OPENSSL_malloc(inlen + EVP_CIPHER_CTX_block_size(&ctx)))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_CipherUpdate(&ctx, out, &i, in, inlen)) {\\r\\nOPENSSL_free(out);\\r\\nout = NULL;\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT, ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\noutlen = i;\\r\\nif (!EVP_CipherFinal_ex(&ctx, out + i, &i)) {\\r\\nOPENSSL_free(out);\\r\\nout = NULL;\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_CRYPT,\\r\\nPKCS12_R_PKCS12_CIPHERFINAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\noutlen += i;\\r\\nif (datalen)\\r\\n*datalen = outlen;\\r\\nif (data)\\r\\n*data = out;\\r\\nerr:\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nreturn out;\\r\\n}\\r\\nvoid *PKCS12_item_decrypt_d2i(X509_ALGOR *algor, const ASN1_ITEM *it,\\r\\nconst char *pass, int passlen,\\r\\nASN1_OCTET_STRING *oct, int zbuf)\\r\\n{\\r\\nunsigned char *out;\\r\\nconst unsigned char *p;\\r\\nvoid *ret;\\r\\nint outlen;\\r\\nif (!PKCS12_pbe_crypt(algor, pass, passlen, oct->data, oct->length,\\r\\n&out, &outlen, 0)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_DECRYPT_D2I,\\r\\nPKCS12_R_PKCS12_PBE_CRYPT_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\np = out;\\r\\n#ifdef DEBUG_DECRYPT\\r\\n{\\r\\nFILE *op;\\r\\nchar fname[30];\\r\\nstatic int fnm = 1;\\r\\nsprintf(fname, \"DER%d\", fnm++);\\r\\nop = fopen(fname, \"wb\");\\r\\nfwrite(p, 1, outlen, op);\\r\\nfclose(op);\\r\\n}\\r\\n#endif\\r\\nret = ASN1_item_d2i(NULL, &p, outlen, it);\\r\\nif (zbuf)\\r\\nOPENSSL_cleanse(out, outlen);\\r\\nif (!ret)\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_DECRYPT_D2I, PKCS12_R_DECODE_ERROR);\\r\\nOPENSSL_free(out);\\r\\nreturn ret;\\r\\n}\\r\\nASN1_OCTET_STRING *PKCS12_item_i2d_encrypt(X509_ALGOR *algor,\\r\\nconst ASN1_ITEM *it,\\r\\nconst char *pass, int passlen,\\r\\nvoid *obj, int zbuf)\\r\\n{\\r\\nASN1_OCTET_STRING *oct = NULL;\\r\\nunsigned char *in = NULL;\\r\\nint inlen;\\r\\nif (!(oct = M_ASN1_OCTET_STRING_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ninlen = ASN1_item_i2d(obj, &in, it);\\r\\nif (!in) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT, PKCS12_R_ENCODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!PKCS12_pbe_crypt(algor, pass, passlen, in, inlen, &oct->data,\\r\\n&oct->length, 1)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT, PKCS12_R_ENCRYPT_ERROR);\\r\\nOPENSSL_free(in);\\r\\ngoto err;\\r\\n}\\r\\nif (zbuf)\\r\\nOPENSSL_cleanse(in, inlen);\\r\\nOPENSSL_free(in);\\r\\nreturn oct;\\r\\nerr:\\r\\nif (oct)\\r\\nASN1_OCTET_STRING_free(oct);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ofb_enc_c", "target": 0, "func": "void DES_ofb_encrypt(const unsigned char *in, unsigned char *out, int numbits,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nDES_cblock *ivec)\\r\\n{\\r\\nregister DES_LONG d0, d1, vv0, vv1, v0, v1, n = (numbits + 7) / 8;\\r\\nregister DES_LONG mask0, mask1;\\r\\nregister long l = length;\\r\\nregister int num = numbits;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nif (num > 64)\\r\\nreturn;\\r\\nif (num > 32) {\\r\\nmask0 = 0xffffffffL;\\r\\nif (num >= 64)\\r\\nmask1 = mask0;\\r\\nelse\\r\\nmask1 = (1L << (num - 32)) - 1;\\r\\n} else {\\r\\nif (num == 32)\\r\\nmask0 = 0xffffffffL;\\r\\nelse\\r\\nmask0 = (1L << num) - 1;\\r\\nmask1 = 0x00000000L;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\nwhile (l-- > 0) {\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\nDES_encrypt1((DES_LONG *)ti, schedule, DES_ENCRYPT);\\r\\nvv0 = ti[0];\\r\\nvv1 = ti[1];\\r\\nc2ln(in, d0, d1, n);\\r\\nin += n;\\r\\nd0 = (d0 ^ vv0) & mask0;\\r\\nd1 = (d1 ^ vv1) & mask1;\\r\\nl2cn(d0, d1, out, n);\\r\\nout += n;\\r\\nif (num == 32) {\\r\\nv0 = v1;\\r\\nv1 = vv0;\\r\\n} else if (num == 64) {\\r\\nv0 = vv0;\\r\\nv1 = vv1;\\r\\n} else if (num > 32) {\\r\\nv0 = ((v1 >> (num - 32)) | (vv0 << (64 - num))) & 0xffffffffL;\\r\\nv1 = ((vv0 >> (num - 32)) | (vv1 << (64 - num))) & 0xffffffffL;\\r\\n} else {\\r\\nv0 = ((v0 >> num) | (v1 << (32 - num))) & 0xffffffffL;\\r\\nv1 = ((v1 >> num) | (vv0 << (32 - num))) & 0xffffffffL;\\r\\n}\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\nv0 = v1 = d0 = d1 = ti[0] = ti[1] = vv0 = vv1 = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecp_nistp521_c", "target": 0, "func": "static void bin66_to_felem(felem out, const u8 in[66])\\r\\n{\\r\\nout[0] = (*((limb *) & in[0])) & bottom58bits;\\r\\nout[1] = (*((limb *) & in[7]) >> 2) & bottom58bits;\\r\\nout[2] = (*((limb *) & in[14]) >> 4) & bottom58bits;\\r\\nout[3] = (*((limb *) & in[21]) >> 6) & bottom58bits;\\r\\nout[4] = (*((limb *) & in[29])) & bottom58bits;\\r\\nout[5] = (*((limb *) & in[36]) >> 2) & bottom58bits;\\r\\nout[6] = (*((limb *) & in[43]) >> 4) & bottom58bits;\\r\\nout[7] = (*((limb *) & in[50]) >> 6) & bottom58bits;\\r\\nout[8] = (*((limb *) & in[58])) & bottom57bits;\\r\\n}\\r\\nstatic void felem_to_bin66(u8 out[66], const felem in)\\r\\n{\\r\\nmemset(out, 0, 66);\\r\\n(*((limb *) & out[0])) = in[0];\\r\\n(*((limb *) & out[7])) |= in[1] << 2;\\r\\n(*((limb *) & out[14])) |= in[2] << 4;\\r\\n(*((limb *) & out[21])) |= in[3] << 6;\\r\\n(*((limb *) & out[29])) = in[4];\\r\\n(*((limb *) & out[36])) |= in[5] << 2;\\r\\n(*((limb *) & out[43])) |= in[6] << 4;\\r\\n(*((limb *) & out[50])) |= in[7] << 6;\\r\\n(*((limb *) & out[58])) = in[8];\\r\\n}\\r\\nstatic void flip_endian(u8 *out, const u8 *in, unsigned len)\\r\\n{\\r\\nunsigned i;\\r\\nfor (i = 0; i < len; ++i)\\r\\nout[i] = in[len - 1 - i];\\r\\n}\\r\\nstatic int BN_to_felem(felem out, const BIGNUM *bn)\\r\\n{\\r\\nfelem_bytearray b_in;\\r\\nfelem_bytearray b_out;\\r\\nunsigned num_bytes;\\r\\nmemset(b_out, 0, sizeof b_out);\\r\\nnum_bytes = BN_num_bytes(bn);\\r\\nif (num_bytes > sizeof b_out) {\\r\\nECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\nif (BN_is_negative(bn)) {\\r\\nECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\nnum_bytes = BN_bn2bin(bn, b_in);\\r\\nflip_endian(b_out, b_in, num_bytes);\\r\\nbin66_to_felem(out, b_out);\\r\\nreturn 1;\\r\\n}\\r\\nstatic BIGNUM *felem_to_BN(BIGNUM *out, const felem in)\\r\\n{\\r\\nfelem_bytearray b_in, b_out;\\r\\nfelem_to_bin66(b_in, in);\\r\\nflip_endian(b_out, b_in, sizeof b_out);\\r\\nreturn BN_bin2bn(b_out, sizeof b_out, out);\\r\\n}\\r\\nstatic void felem_one(felem out)\\r\\n{\\r\\nout[0] = 1;\\r\\nout[1] = 0;\\r\\nout[2] = 0;\\r\\nout[3] = 0;\\r\\nout[4] = 0;\\r\\nout[5] = 0;\\r\\nout[6] = 0;\\r\\nout[7] = 0;\\r\\nout[8] = 0;\\r\\n}\\r\\nstatic void felem_assign(felem out, const felem in)\\r\\n{\\r\\nout[0] = in[0];\\r\\nout[1] = in[1];\\r\\nout[2] = in[2];\\r\\nout[3] = in[3];\\r\\nout[4] = in[4];\\r\\nout[5] = in[5];\\r\\nout[6] = in[6];\\r\\nout[7] = in[7];\\r\\nout[8] = in[8];\\r\\n}\\r\\nstatic void felem_sum64(felem out, const felem in)\\r\\n{\\r\\nout[0] += in[0];\\r\\nout[1] += in[1];\\r\\nout[2] += in[2];\\r\\nout[3] += in[3];\\r\\nout[4] += in[4];\\r\\nout[5] += in[5];\\r\\nout[6] += in[6];\\r\\nout[7] += in[7];\\r\\nout[8] += in[8];\\r\\n}\\r\\nstatic void felem_scalar(felem out, const felem in, limb scalar)\\r\\n{\\r\\nout[0] = in[0] * scalar;\\r\\nout[1] = in[1] * scalar;\\r\\nout[2] = in[2] * scalar;\\r\\nout[3] = in[3] * scalar;\\r\\nout[4] = in[4] * scalar;\\r\\nout[5] = in[5] * scalar;\\r\\nout[6] = in[6] * scalar;\\r\\nout[7] = in[7] * scalar;\\r\\nout[8] = in[8] * scalar;\\r\\n}\\r\\nstatic void felem_scalar64(felem out, limb scalar)\\r\\n{\\r\\nout[0] *= scalar;\\r\\nout[1] *= scalar;\\r\\nout[2] *= scalar;\\r\\nout[3] *= scalar;\\r\\nout[4] *= scalar;\\r\\nout[5] *= scalar;\\r\\nout[6] *= scalar;\\r\\nout[7] *= scalar;\\r\\nout[8] *= scalar;\\r\\n}\\r\\nstatic void felem_scalar128(largefelem out, limb scalar)\\r\\n{\\r\\nout[0] *= scalar;\\r\\nout[1] *= scalar;\\r\\nout[2] *= scalar;\\r\\nout[3] *= scalar;\\r\\nout[4] *= scalar;\\r\\nout[5] *= scalar;\\r\\nout[6] *= scalar;\\r\\nout[7] *= scalar;\\r\\nout[8] *= scalar;\\r\\n}\\r\\nstatic void felem_neg(felem out, const felem in)\\r\\n{\\r\\nstatic const limb two62m3 = (((limb) 1) << 62) - (((limb) 1) << 5);\\r\\nstatic const limb two62m2 = (((limb) 1) << 62) - (((limb) 1) << 4);\\r\\nout[0] = two62m3 - in[0];\\r\\nout[1] = two62m2 - in[1];\\r\\nout[2] = two62m2 - in[2];\\r\\nout[3] = two62m2 - in[3];\\r\\nout[4] = two62m2 - in[4];\\r\\nout[5] = two62m2 - in[5];\\r\\nout[6] = two62m2 - in[6];\\r\\nout[7] = two62m2 - in[7];\\r\\nout[8] = two62m2 - in[8];\\r\\n}\\r\\nstatic void felem_diff64(felem out, const felem in)\\r\\n{\\r\\nstatic const limb two62m3 = (((limb) 1) << 62) - (((limb) 1) << 5);\\r\\nstatic const limb two62m2 = (((limb) 1) << 62) - (((limb) 1) << 4);\\r\\nout[0] += two62m3 - in[0];\\r\\nout[1] += two62m2 - in[1];\\r\\nout[2] += two62m2 - in[2];\\r\\nout[3] += two62m2 - in[3];\\r\\nout[4] += two62m2 - in[4];\\r\\nout[5] += two62m2 - in[5];\\r\\nout[6] += two62m2 - in[6];\\r\\nout[7] += two62m2 - in[7];\\r\\nout[8] += two62m2 - in[8];\\r\\n}\\r\\nstatic void felem_diff_128_64(largefelem out, const felem in)\\r\\n{\\r\\nstatic const limb two63m6 = (((limb) 1) << 62) - (((limb) 1) << 5);\\r\\nstatic const limb two63m5 = (((limb) 1) << 62) - (((limb) 1) << 4);\\r\\nout[0] += two63m6 - in[0];\\r\\nout[1] += two63m5 - in[1];\\r\\nout[2] += two63m5 - in[2];\\r\\nout[3] += two63m5 - in[3];\\r\\nout[4] += two63m5 - in[4];\\r\\nout[5] += two63m5 - in[5];\\r\\nout[6] += two63m5 - in[6];\\r\\nout[7] += two63m5 - in[7];\\r\\nout[8] += two63m5 - in[8];\\r\\n}\\r\\nstatic void felem_diff128(largefelem out, const largefelem in)\\r\\n{\\r\\nstatic const uint128_t two127m70 =\\r\\n(((uint128_t) 1) << 127) - (((uint128_t) 1) << 70);\\r\\nstatic const uint128_t two127m69 =\\r\\n(((uint128_t) 1) << 127) - (((uint128_t) 1) << 69);\\r\\nout[0] += (two127m70 - in[0]);\\r\\nout[1] += (two127m69 - in[1]);\\r\\nout[2] += (two127m69 - in[2]);\\r\\nout[3] += (two127m69 - in[3]);\\r\\nout[4] += (two127m69 - in[4]);\\r\\nout[5] += (two127m69 - in[5]);\\r\\nout[6] += (two127m69 - in[6]);\\r\\nout[7] += (two127m69 - in[7]);\\r\\nout[8] += (two127m69 - in[8]);\\r\\n}\\r\\nstatic void felem_square(largefelem out, const felem in)\\r\\n{\\r\\nfelem inx2, inx4;\\r\\nfelem_scalar(inx2, in, 2);\\r\\nfelem_scalar(inx4, in, 4);\\r\\nout[0] = ((uint128_t) in[0]) * in[0];\\r\\nout[1] = ((uint128_t) in[0]) * inx2[1];\\r\\nout[2] = ((uint128_t) in[0]) * inx2[2] + ((uint128_t) in[1]) * in[1];\\r\\nout[3] = ((uint128_t) in[0]) * inx2[3] + ((uint128_t) in[1]) * inx2[2];\\r\\nout[4] = ((uint128_t) in[0]) * inx2[4] +\\r\\n((uint128_t) in[1]) * inx2[3] + ((uint128_t) in[2]) * in[2];\\r\\nout[5] = ((uint128_t) in[0]) * inx2[5] +\\r\\n((uint128_t) in[1]) * inx2[4] + ((uint128_t) in[2]) * inx2[3];\\r\\nout[6] = ((uint128_t) in[0]) * inx2[6] +\\r\\n((uint128_t) in[1]) * inx2[5] +\\r\\n((uint128_t) in[2]) * inx2[4] + ((uint128_t) in[3]) * in[3];\\r\\nout[7] = ((uint128_t) in[0]) * inx2[7] +\\r\\n((uint128_t) in[1]) * inx2[6] +\\r\\n((uint128_t) in[2]) * inx2[5] + ((uint128_t) in[3]) * inx2[4];\\r\\nout[8] = ((uint128_t) in[0]) * inx2[8] +\\r\\n((uint128_t) in[1]) * inx2[7] +\\r\\n((uint128_t) in[2]) * inx2[6] +\\r\\n((uint128_t) in[3]) * inx2[5] + ((uint128_t) in[4]) * in[4];\\r\\nout[0] += ((uint128_t) in[1]) * inx4[8] +\\r\\n((uint128_t) in[2]) * inx4[7] +\\r\\n((uint128_t) in[3]) * inx4[6] + ((uint128_t) in[4]) * inx4[5];\\r\\nout[1] += ((uint128_t) in[2]) * inx4[8] +\\r\\n((uint128_t) in[3]) * inx4[7] +\\r\\n((uint128_t) in[4]) * inx4[6] + ((uint128_t) in[5]) * inx2[5];\\r\\nout[2] += ((uint128_t) in[3]) * inx4[8] +\\r\\n((uint128_t) in[4]) * inx4[7] + ((uint128_t) in[5]) * inx4[6];\\r\\nout[3] += ((uint128_t) in[4]) * inx4[8] +\\r\\n((uint128_t) in[5]) * inx4[7] + ((uint128_t) in[6]) * inx2[6];\\r\\nout[4] += ((uint128_t) in[5]) * inx4[8] + ((uint128_t) in[6]) * inx4[7];\\r\\nout[5] += ((uint128_t) in[6]) * inx4[8] + ((uint128_t) in[7]) * inx2[7];\\r\\nout[6] += ((uint128_t) in[7]) * inx4[8];\\r\\nout[7] += ((uint128_t) in[8]) * inx2[8];\\r\\n}\\r\\nstatic void felem_mul(largefelem out, const felem in1, const felem in2)\\r\\n{\\r\\nfelem in2x2;\\r\\nfelem_scalar(in2x2, in2, 2);\\r\\nout[0] = ((uint128_t) in1[0]) * in2[0];\\r\\nout[1] = ((uint128_t) in1[0]) * in2[1] + ((uint128_t) in1[1]) * in2[0];\\r\\nout[2] = ((uint128_t) in1[0]) * in2[2] +\\r\\n((uint128_t) in1[1]) * in2[1] + ((uint128_t) in1[2]) * in2[0];\\r\\nout[3] = ((uint128_t) in1[0]) * in2[3] +\\r\\n((uint128_t) in1[1]) * in2[2] +\\r\\n((uint128_t) in1[2]) * in2[1] + ((uint128_t) in1[3]) * in2[0];\\r\\nout[4] = ((uint128_t) in1[0]) * in2[4] +\\r\\n((uint128_t) in1[1]) * in2[3] +\\r\\n((uint128_t) in1[2]) * in2[2] +\\r\\n((uint128_t) in1[3]) * in2[1] + ((uint128_t) in1[4]) * in2[0];\\r\\nout[5] = ((uint128_t) in1[0]) * in2[5] +\\r\\n((uint128_t) in1[1]) * in2[4] +\\r\\n((uint128_t) in1[2]) * in2[3] +\\r\\n((uint128_t) in1[3]) * in2[2] +\\r\\n((uint128_t) in1[4]) * in2[1] + ((uint128_t) in1[5]) * in2[0];\\r\\nout[6] = ((uint128_t) in1[0]) * in2[6] +\\r\\n((uint128_t) in1[1]) * in2[5] +\\r\\n((uint128_t) in1[2]) * in2[4] +\\r\\n((uint128_t) in1[3]) * in2[3] +\\r\\n((uint128_t) in1[4]) * in2[2] +\\r\\n((uint128_t) in1[5]) * in2[1] + ((uint128_t) in1[6]) * in2[0];\\r\\nout[7] = ((uint128_t) in1[0]) * in2[7] +\\r\\n((uint128_t) in1[1]) * in2[6] +\\r\\n((uint128_t) in1[2]) * in2[5] +\\r\\n((uint128_t) in1[3]) * in2[4] +\\r\\n((uint128_t) in1[4]) * in2[3] +\\r\\n((uint128_t) in1[5]) * in2[2] +\\r\\n((uint128_t) in1[6]) * in2[1] + ((uint128_t) in1[7]) * in2[0];\\r\\nout[8] = ((uint128_t) in1[0]) * in2[8] +\\r\\n((uint128_t) in1[1]) * in2[7] +\\r\\n((uint128_t) in1[2]) * in2[6] +\\r\\n((uint128_t) in1[3]) * in2[5] +\\r\\n((uint128_t) in1[4]) * in2[4] +\\r\\n((uint128_t) in1[5]) * in2[3] +\\r\\n((uint128_t) in1[6]) * in2[2] +\\r\\n((uint128_t) in1[7]) * in2[1] + ((uint128_t) in1[8]) * in2[0];\\r\\nout[0] += ((uint128_t) in1[1]) * in2x2[8] +\\r\\n((uint128_t) in1[2]) * in2x2[7] +\\r\\n((uint128_t) in1[3]) * in2x2[6] +\\r\\n((uint128_t) in1[4]) * in2x2[5] +\\r\\n((uint128_t) in1[5]) * in2x2[4] +\\r\\n((uint128_t) in1[6]) * in2x2[3] +\\r\\n((uint128_t) in1[7]) * in2x2[2] + ((uint128_t) in1[8]) * in2x2[1];\\r\\nout[1] += ((uint128_t) in1[2]) * in2x2[8] +\\r\\n((uint128_t) in1[3]) * in2x2[7] +\\r\\n((uint128_t) in1[4]) * in2x2[6] +\\r\\n((uint128_t) in1[5]) * in2x2[5] +\\r\\n((uint128_t) in1[6]) * in2x2[4] +\\r\\n((uint128_t) in1[7]) * in2x2[3] + ((uint128_t) in1[8]) * in2x2[2];\\r\\nout[2] += ((uint128_t) in1[3]) * in2x2[8] +\\r\\n((uint128_t) in1[4]) * in2x2[7] +\\r\\n((uint128_t) in1[5]) * in2x2[6] +\\r\\n((uint128_t) in1[6]) * in2x2[5] +\\r\\n((uint128_t) in1[7]) * in2x2[4] + ((uint128_t) in1[8]) * in2x2[3];\\r\\nout[3] += ((uint128_t) in1[4]) * in2x2[8] +\\r\\n((uint128_t) in1[5]) * in2x2[7] +\\r\\n((uint128_t) in1[6]) * in2x2[6] +\\r\\n((uint128_t) in1[7]) * in2x2[5] + ((uint128_t) in1[8]) * in2x2[4];\\r\\nout[4] += ((uint128_t) in1[5]) * in2x2[8] +\\r\\n((uint128_t) in1[6]) * in2x2[7] +\\r\\n((uint128_t) in1[7]) * in2x2[6] + ((uint128_t) in1[8]) * in2x2[5];\\r\\nout[5] += ((uint128_t) in1[6]) * in2x2[8] +\\r\\n((uint128_t) in1[7]) * in2x2[7] + ((uint128_t) in1[8]) * in2x2[6];\\r\\nout[6] += ((uint128_t) in1[7]) * in2x2[8] +\\r\\n((uint128_t) in1[8]) * in2x2[7];\\r\\nout[7] += ((uint128_t) in1[8]) * in2x2[8];\\r\\n}\\r\\nstatic void felem_reduce(felem out, const largefelem in)\\r\\n{\\r\\nu64 overflow1, overflow2;\\r\\nout[0] = ((limb) in[0]) & bottom58bits;\\r\\nout[1] = ((limb) in[1]) & bottom58bits;\\r\\nout[2] = ((limb) in[2]) & bottom58bits;\\r\\nout[3] = ((limb) in[3]) & bottom58bits;\\r\\nout[4] = ((limb) in[4]) & bottom58bits;\\r\\nout[5] = ((limb) in[5]) & bottom58bits;\\r\\nout[6] = ((limb) in[6]) & bottom58bits;\\r\\nout[7] = ((limb) in[7]) & bottom58bits;\\r\\nout[8] = ((limb) in[8]) & bottom58bits;\\r\\nout[1] += ((limb) in[0]) >> 58;\\r\\nout[1] += (((limb) (in[0] >> 64)) & bottom52bits) << 6;\\r\\nout[2] += ((limb) (in[0] >> 64)) >> 52;\\r\\nout[2] += ((limb) in[1]) >> 58;\\r\\nout[2] += (((limb) (in[1] >> 64)) & bottom52bits) << 6;\\r\\nout[3] += ((limb) (in[1] >> 64)) >> 52;\\r\\nout[3] += ((limb) in[2]) >> 58;\\r\\nout[3] += (((limb) (in[2] >> 64)) & bottom52bits) << 6;\\r\\nout[4] += ((limb) (in[2] >> 64)) >> 52;\\r\\nout[4] += ((limb) in[3]) >> 58;\\r\\nout[4] += (((limb) (in[3] >> 64)) & bottom52bits) << 6;\\r\\nout[5] += ((limb) (in[3] >> 64)) >> 52;\\r\\nout[5] += ((limb) in[4]) >> 58;\\r\\nout[5] += (((limb) (in[4] >> 64)) & bottom52bits) << 6;\\r\\nout[6] += ((limb) (in[4] >> 64)) >> 52;\\r\\nout[6] += ((limb) in[5]) >> 58;\\r\\nout[6] += (((limb) (in[5] >> 64)) & bottom52bits) << 6;\\r\\nout[7] += ((limb) (in[5] >> 64)) >> 52;\\r\\nout[7] += ((limb) in[6]) >> 58;\\r\\nout[7] += (((limb) (in[6] >> 64)) & bottom52bits) << 6;\\r\\nout[8] += ((limb) (in[6] >> 64)) >> 52;\\r\\nout[8] += ((limb) in[7]) >> 58;\\r\\nout[8] += (((limb) (in[7] >> 64)) & bottom52bits) << 6;\\r\\noverflow1 = ((limb) (in[7] >> 64)) >> 52;\\r\\noverflow1 += ((limb) in[8]) >> 58;\\r\\noverflow1 += (((limb) (in[8] >> 64)) & bottom52bits) << 6;\\r\\noverflow2 = ((limb) (in[8] >> 64)) >> 52;\\r\\noverflow1 <<= 1;\\r\\noverflow2 <<= 1;\\r\\nout[0] += overflow1;\\r\\nout[1] += overflow2;\\r\\nout[1] += out[0] >> 58;\\r\\nout[0] &= bottom58bits;\\r\\n}\\r\\nstatic void felem_square_reduce(felem out, const felem in)\\r\\n{\\r\\nlargefelem tmp;\\r\\nfelem_square(tmp, in);\\r\\nfelem_reduce(out, tmp);\\r\\n}\\r\\nstatic void felem_mul_reduce(felem out, const felem in1, const felem in2)\\r\\n{\\r\\nlargefelem tmp;\\r\\nfelem_mul(tmp, in1, in2);\\r\\nfelem_reduce(out, tmp);\\r\\n}\\r\\nstatic void felem_inv(felem out, const felem in)\\r\\n{\\r\\nfelem ftmp, ftmp2, ftmp3, ftmp4;\\r\\nlargefelem tmp;\\r\\nunsigned i;\\r\\nfelem_square(tmp, in);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, in, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_assign(ftmp2, ftmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, in, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp2, ftmp3);\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp4, ftmp3);\\r\\nfelem_mul(tmp, ftmp3, ftmp);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\nfelem_square(tmp, ftmp4);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp2, ftmp3);\\r\\nfor (i = 0; i < 8; i++) {\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp2, ftmp3);\\r\\nfor (i = 0; i < 16; i++) {\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp2, ftmp3);\\r\\nfor (i = 0; i < 32; i++) {\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp2, ftmp3);\\r\\nfor (i = 0; i < 64; i++) {\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp2, ftmp3);\\r\\nfor (i = 0; i < 128; i++) {\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp2, ftmp3);\\r\\nfor (i = 0; i < 256; i++) {\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfor (i = 0; i < 9; i++) {\\r\\nfelem_square(tmp, ftmp3);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp3, ftmp4);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_mul(tmp, ftmp3, in);\\r\\nfelem_reduce(out, tmp);\\r\\n}\\r\\nstatic limb felem_is_zero(const felem in)\\r\\n{\\r\\nfelem ftmp;\\r\\nlimb is_zero, is_p;\\r\\nfelem_assign(ftmp, in);\\r\\nftmp[0] += ftmp[8] >> 57;\\r\\nftmp[8] &= bottom57bits;\\r\\nftmp[1] += ftmp[0] >> 58;\\r\\nftmp[0] &= bottom58bits;\\r\\nftmp[2] += ftmp[1] >> 58;\\r\\nftmp[1] &= bottom58bits;\\r\\nftmp[3] += ftmp[2] >> 58;\\r\\nftmp[2] &= bottom58bits;\\r\\nftmp[4] += ftmp[3] >> 58;\\r\\nftmp[3] &= bottom58bits;\\r\\nftmp[5] += ftmp[4] >> 58;\\r\\nftmp[4] &= bottom58bits;\\r\\nftmp[6] += ftmp[5] >> 58;\\r\\nftmp[5] &= bottom58bits;\\r\\nftmp[7] += ftmp[6] >> 58;\\r\\nftmp[6] &= bottom58bits;\\r\\nftmp[8] += ftmp[7] >> 58;\\r\\nftmp[7] &= bottom58bits;\\r\\nis_zero = 0;\\r\\nis_zero |= ftmp[0];\\r\\nis_zero |= ftmp[1];\\r\\nis_zero |= ftmp[2];\\r\\nis_zero |= ftmp[3];\\r\\nis_zero |= ftmp[4];\\r\\nis_zero |= ftmp[5];\\r\\nis_zero |= ftmp[6];\\r\\nis_zero |= ftmp[7];\\r\\nis_zero |= ftmp[8];\\r\\nis_zero--;\\r\\nis_zero = ((s64) is_zero) >> 63;\\r\\nis_p = ftmp[0] ^ kPrime[0];\\r\\nis_p |= ftmp[1] ^ kPrime[1];\\r\\nis_p |= ftmp[2] ^ kPrime[2];\\r\\nis_p |= ftmp[3] ^ kPrime[3];\\r\\nis_p |= ftmp[4] ^ kPrime[4];\\r\\nis_p |= ftmp[5] ^ kPrime[5];\\r\\nis_p |= ftmp[6] ^ kPrime[6];\\r\\nis_p |= ftmp[7] ^ kPrime[7];\\r\\nis_p |= ftmp[8] ^ kPrime[8];\\r\\nis_p--;\\r\\nis_p = ((s64) is_p) >> 63;\\r\\nis_zero |= is_p;\\r\\nreturn is_zero;\\r\\n}\\r\\nstatic int felem_is_zero_int(const felem in)\\r\\n{\\r\\nreturn (int)(felem_is_zero(in) & ((limb) 1));\\r\\n}\\r\\nstatic void felem_contract(felem out, const felem in)\\r\\n{\\r\\nlimb is_p, is_greater, sign;\\r\\nstatic const limb two58 = ((limb) 1) << 58;\\r\\nfelem_assign(out, in);\\r\\nout[0] += out[8] >> 57;\\r\\nout[8] &= bottom57bits;\\r\\nout[1] += out[0] >> 58;\\r\\nout[0] &= bottom58bits;\\r\\nout[2] += out[1] >> 58;\\r\\nout[1] &= bottom58bits;\\r\\nout[3] += out[2] >> 58;\\r\\nout[2] &= bottom58bits;\\r\\nout[4] += out[3] >> 58;\\r\\nout[3] &= bottom58bits;\\r\\nout[5] += out[4] >> 58;\\r\\nout[4] &= bottom58bits;\\r\\nout[6] += out[5] >> 58;\\r\\nout[5] &= bottom58bits;\\r\\nout[7] += out[6] >> 58;\\r\\nout[6] &= bottom58bits;\\r\\nout[8] += out[7] >> 58;\\r\\nout[7] &= bottom58bits;\\r\\nis_p = out[0] ^ kPrime[0];\\r\\nis_p |= out[1] ^ kPrime[1];\\r\\nis_p |= out[2] ^ kPrime[2];\\r\\nis_p |= out[3] ^ kPrime[3];\\r\\nis_p |= out[4] ^ kPrime[4];\\r\\nis_p |= out[5] ^ kPrime[5];\\r\\nis_p |= out[6] ^ kPrime[6];\\r\\nis_p |= out[7] ^ kPrime[7];\\r\\nis_p |= out[8] ^ kPrime[8];\\r\\nis_p--;\\r\\nis_p &= is_p << 32;\\r\\nis_p &= is_p << 16;\\r\\nis_p &= is_p << 8;\\r\\nis_p &= is_p << 4;\\r\\nis_p &= is_p << 2;\\r\\nis_p &= is_p << 1;\\r\\nis_p = ((s64) is_p) >> 63;\\r\\nis_p = ~is_p;\\r\\nout[0] &= is_p;\\r\\nout[1] &= is_p;\\r\\nout[2] &= is_p;\\r\\nout[3] &= is_p;\\r\\nout[4] &= is_p;\\r\\nout[5] &= is_p;\\r\\nout[6] &= is_p;\\r\\nout[7] &= is_p;\\r\\nout[8] &= is_p;\\r\\nis_greater = out[8] >> 57;\\r\\nis_greater |= is_greater << 32;\\r\\nis_greater |= is_greater << 16;\\r\\nis_greater |= is_greater << 8;\\r\\nis_greater |= is_greater << 4;\\r\\nis_greater |= is_greater << 2;\\r\\nis_greater |= is_greater << 1;\\r\\nis_greater = ((s64) is_greater) >> 63;\\r\\nout[0] -= kPrime[0] & is_greater;\\r\\nout[1] -= kPrime[1] & is_greater;\\r\\nout[2] -= kPrime[2] & is_greater;\\r\\nout[3] -= kPrime[3] & is_greater;\\r\\nout[4] -= kPrime[4] & is_greater;\\r\\nout[5] -= kPrime[5] & is_greater;\\r\\nout[6] -= kPrime[6] & is_greater;\\r\\nout[7] -= kPrime[7] & is_greater;\\r\\nout[8] -= kPrime[8] & is_greater;\\r\\nsign = -(out[0] >> 63);\\r\\nout[0] += (two58 & sign);\\r\\nout[1] -= (1 & sign);\\r\\nsign = -(out[1] >> 63);\\r\\nout[1] += (two58 & sign);\\r\\nout[2] -= (1 & sign);\\r\\nsign = -(out[2] >> 63);\\r\\nout[2] += (two58 & sign);\\r\\nout[3] -= (1 & sign);\\r\\nsign = -(out[3] >> 63);\\r\\nout[3] += (two58 & sign);\\r\\nout[4] -= (1 & sign);\\r\\nsign = -(out[4] >> 63);\\r\\nout[4] += (two58 & sign);\\r\\nout[5] -= (1 & sign);\\r\\nsign = -(out[0] >> 63);\\r\\nout[5] += (two58 & sign);\\r\\nout[6] -= (1 & sign);\\r\\nsign = -(out[6] >> 63);\\r\\nout[6] += (two58 & sign);\\r\\nout[7] -= (1 & sign);\\r\\nsign = -(out[7] >> 63);\\r\\nout[7] += (two58 & sign);\\r\\nout[8] -= (1 & sign);\\r\\nsign = -(out[5] >> 63);\\r\\nout[5] += (two58 & sign);\\r\\nout[6] -= (1 & sign);\\r\\nsign = -(out[6] >> 63);\\r\\nout[6] += (two58 & sign);\\r\\nout[7] -= (1 & sign);\\r\\nsign = -(out[7] >> 63);\\r\\nout[7] += (two58 & sign);\\r\\nout[8] -= (1 & sign);\\r\\n}\\r\\nstatic void\\r\\npoint_double(felem x_out, felem y_out, felem z_out,\\r\\nconst felem x_in, const felem y_in, const felem z_in)\\r\\n{\\r\\nlargefelem tmp, tmp2;\\r\\nfelem delta, gamma, beta, alpha, ftmp, ftmp2;\\r\\nfelem_assign(ftmp, x_in);\\r\\nfelem_assign(ftmp2, x_in);\\r\\nfelem_square(tmp, z_in);\\r\\nfelem_reduce(delta, tmp);\\r\\nfelem_square(tmp, y_in);\\r\\nfelem_reduce(gamma, tmp);\\r\\nfelem_mul(tmp, x_in, gamma);\\r\\nfelem_reduce(beta, tmp);\\r\\nfelem_diff64(ftmp, delta);\\r\\nfelem_sum64(ftmp2, delta);\\r\\nfelem_scalar64(ftmp2, 3);\\r\\nfelem_mul(tmp, ftmp, ftmp2);\\r\\nfelem_reduce(alpha, tmp);\\r\\nfelem_square(tmp, alpha);\\r\\nfelem_assign(ftmp, beta);\\r\\nfelem_scalar64(ftmp, 8);\\r\\nfelem_diff_128_64(tmp, ftmp);\\r\\nfelem_reduce(x_out, tmp);\\r\\nfelem_sum64(delta, gamma);\\r\\nfelem_assign(ftmp, y_in);\\r\\nfelem_sum64(ftmp, z_in);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_diff_128_64(tmp, delta);\\r\\nfelem_reduce(z_out, tmp);\\r\\nfelem_scalar64(beta, 4);\\r\\nfelem_diff64(beta, x_out);\\r\\nfelem_mul(tmp, alpha, beta);\\r\\nfelem_square(tmp2, gamma);\\r\\nfelem_scalar128(tmp2, 8);\\r\\nfelem_diff128(tmp, tmp2);\\r\\nfelem_reduce(y_out, tmp);\\r\\n}\\r\\nstatic void copy_conditional(felem out, const felem in, limb mask)\\r\\n{\\r\\nunsigned i;\\r\\nfor (i = 0; i < NLIMBS; ++i) {\\r\\nconst limb tmp = mask & (in[i] ^ out[i]);\\r\\nout[i] ^= tmp;\\r\\n}\\r\\n}\\r\\nstatic void point_add(felem x3, felem y3, felem z3,\\r\\nconst felem x1, const felem y1, const felem z1,\\r\\nconst int mixed, const felem x2, const felem y2,\\r\\nconst felem z2)\\r\\n{\\r\\nfelem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\\r\\nlargefelem tmp, tmp2;\\r\\nlimb x_equal, y_equal, z1_is_zero, z2_is_zero;\\r\\nz1_is_zero = felem_is_zero(z1);\\r\\nz2_is_zero = felem_is_zero(z2);\\r\\nfelem_square(tmp, z1);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nif (!mixed) {\\r\\nfelem_square(tmp, z2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, x1, ftmp2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp5, z1);\\r\\nfelem_sum64(ftmp5, z2);\\r\\nfelem_square(tmp, ftmp5);\\r\\nfelem_diff_128_64(tmp, ftmp);\\r\\nfelem_diff_128_64(tmp, ftmp2);\\r\\nfelem_reduce(ftmp5, tmp);\\r\\nfelem_mul(tmp, ftmp2, z2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, y1, ftmp2);\\r\\nfelem_reduce(ftmp6, tmp);\\r\\n} else {\\r\\nfelem_assign(ftmp3, x1);\\r\\nfelem_scalar(ftmp5, z1, 2);\\r\\nfelem_assign(ftmp6, y1);\\r\\n}\\r\\nfelem_mul(tmp, x2, ftmp);\\r\\nfelem_diff_128_64(tmp, ftmp3);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\nx_equal = felem_is_zero(ftmp4);\\r\\nfelem_mul(tmp, ftmp5, ftmp4);\\r\\nfelem_reduce(z_out, tmp);\\r\\nfelem_mul(tmp, ftmp, z1);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, y2, ftmp);\\r\\nfelem_diff_128_64(tmp, ftmp6);\\r\\nfelem_reduce(ftmp5, tmp);\\r\\ny_equal = felem_is_zero(ftmp5);\\r\\nfelem_scalar64(ftmp5, 2);\\r\\nif (x_equal && y_equal && !z1_is_zero && !z2_is_zero) {\\r\\npoint_double(x3, y3, z3, x1, y1, z1);\\r\\nreturn;\\r\\n}\\r\\nfelem_assign(ftmp, ftmp4);\\r\\nfelem_scalar64(ftmp, 2);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, ftmp4, ftmp);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, ftmp3, ftmp);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\nfelem_square(tmp, ftmp5);\\r\\nfelem_diff_128_64(tmp, ftmp2);\\r\\nfelem_assign(ftmp3, ftmp4);\\r\\nfelem_scalar64(ftmp4, 2);\\r\\nfelem_diff_128_64(tmp, ftmp4);\\r\\nfelem_reduce(x_out, tmp);\\r\\nfelem_diff64(ftmp3, x_out);\\r\\nfelem_mul(tmp, ftmp5, ftmp3);\\r\\nfelem_mul(tmp2, ftmp6, ftmp2);\\r\\nfelem_scalar128(tmp2, 2);\\r\\nfelem_diff128(tmp, tmp2);\\r\\nfelem_reduce(y_out, tmp);\\r\\ncopy_conditional(x_out, x2, z1_is_zero);\\r\\ncopy_conditional(x_out, x1, z2_is_zero);\\r\\ncopy_conditional(y_out, y2, z1_is_zero);\\r\\ncopy_conditional(y_out, y1, z2_is_zero);\\r\\ncopy_conditional(z_out, z2, z1_is_zero);\\r\\ncopy_conditional(z_out, z1, z2_is_zero);\\r\\nfelem_assign(x3, x_out);\\r\\nfelem_assign(y3, y_out);\\r\\nfelem_assign(z3, z_out);\\r\\n}\\r\\nstatic void select_point(const limb idx, unsigned int size,\\r\\nconst felem pre_comp[][3], felem out[3])\\r\\n{\\r\\nunsigned i, j;\\r\\nlimb *outlimbs = &out[0][0];\\r\\nmemset(outlimbs, 0, 3 * sizeof(felem));\\r\\nfor (i = 0; i < size; i++) {\\r\\nconst limb *inlimbs = &pre_comp[i][0][0];\\r\\nlimb mask = i ^ idx;\\r\\nmask |= mask >> 4;\\r\\nmask |= mask >> 2;\\r\\nmask |= mask >> 1;\\r\\nmask &= 1;\\r\\nmask--;\\r\\nfor (j = 0; j < NLIMBS * 3; j++)\\r\\noutlimbs[j] |= inlimbs[j] & mask;\\r\\n}\\r\\n}\\r\\nstatic char get_bit(const felem_bytearray in, int i)\\r\\n{\\r\\nif (i < 0)\\r\\nreturn 0;\\r\\nreturn (in[i >> 3] >> (i & 7)) & 1;\\r\\n}\\r\\nstatic void batch_mul(felem x_out, felem y_out, felem z_out,\\r\\nconst felem_bytearray scalars[],\\r\\nconst unsigned num_points, const u8 *g_scalar,\\r\\nconst int mixed, const felem pre_comp[][17][3],\\r\\nconst felem g_pre_comp[16][3])\\r\\n{\\r\\nint i, skip;\\r\\nunsigned num, gen_mul = (g_scalar != NULL);\\r\\nfelem nq[3], tmp[4];\\r\\nlimb bits;\\r\\nu8 sign, digit;\\r\\nmemset(nq, 0, 3 * sizeof(felem));\\r\\nskip = 1;\\r\\nfor (i = (num_points ? 520 : 130); i >= 0; --i) {\\r\\nif (!skip)\\r\\npoint_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\\r\\nif (gen_mul && (i <= 130)) {\\r\\nbits = get_bit(g_scalar, i + 390) << 3;\\r\\nif (i < 130) {\\r\\nbits |= get_bit(g_scalar, i + 260) << 2;\\r\\nbits |= get_bit(g_scalar, i + 130) << 1;\\r\\nbits |= get_bit(g_scalar, i);\\r\\n}\\r\\nselect_point(bits, 16, g_pre_comp, tmp);\\r\\nif (!skip) {\\r\\npoint_add(nq[0], nq[1], nq[2],\\r\\nnq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\\r\\n} else {\\r\\nmemcpy(nq, tmp, 3 * sizeof(felem));\\r\\nskip = 0;\\r\\n}\\r\\n}\\r\\nif (num_points && (i % 5 == 0)) {\\r\\nfor (num = 0; num < num_points; ++num) {\\r\\nbits = get_bit(scalars[num], i + 4) << 5;\\r\\nbits |= get_bit(scalars[num], i + 3) << 4;\\r\\nbits |= get_bit(scalars[num], i + 2) << 3;\\r\\nbits |= get_bit(scalars[num], i + 1) << 2;\\r\\nbits |= get_bit(scalars[num], i) << 1;\\r\\nbits |= get_bit(scalars[num], i - 1);\\r\\nec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\\r\\nselect_point(digit, 17, pre_comp[num], tmp);\\r\\nfelem_neg(tmp[3], tmp[1]);\\r\\ncopy_conditional(tmp[1], tmp[3], (-(limb) sign));\\r\\nif (!skip) {\\r\\npoint_add(nq[0], nq[1], nq[2],\\r\\nnq[0], nq[1], nq[2],\\r\\nmixed, tmp[0], tmp[1], tmp[2]);\\r\\n} else {\\r\\nmemcpy(nq, tmp, 3 * sizeof(felem));\\r\\nskip = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nfelem_assign(x_out, nq[0]);\\r\\nfelem_assign(y_out, nq[1]);\\r\\nfelem_assign(z_out, nq[2]);\\r\\n}\\r\\nconst EC_METHOD *EC_GFp_nistp521_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nEC_FLAGS_DEFAULT_OCT,\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_nistp521_group_init,\\r\\nec_GFp_simple_group_finish,\\r\\nec_GFp_simple_group_clear_finish,\\r\\nec_GFp_nist_group_copy,\\r\\nec_GFp_nistp521_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\nec_GFp_nistp521_point_get_affine_coordinates,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\nec_GFp_nistp521_points_mul,\\r\\nec_GFp_nistp521_precompute_mult,\\r\\nec_GFp_nistp521_have_precompute_mult,\\r\\nec_GFp_nist_field_mul,\\r\\nec_GFp_nist_field_sqr,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\n0\\r\\n};\\r\\nreturn &ret;\\r\\n}\\r\\nstatic NISTP521_PRE_COMP *nistp521_pre_comp_new()\\r\\n{\\r\\nNISTP521_PRE_COMP *ret = NULL;\\r\\nret = (NISTP521_PRE_COMP *) OPENSSL_malloc(sizeof(NISTP521_PRE_COMP));\\r\\nif (!ret) {\\r\\nECerr(EC_F_NISTP521_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn ret;\\r\\n}\\r\\nmemset(ret->g_pre_comp, 0, sizeof(ret->g_pre_comp));\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nstatic void *nistp521_pre_comp_dup(void *src_)\\r\\n{\\r\\nNISTP521_PRE_COMP *src = src_;\\r\\nCRYPTO_add(&src->references, 1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nreturn src_;\\r\\n}\\r\\nstatic void nistp521_pre_comp_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nNISTP521_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nstatic void nistp521_pre_comp_clear_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nNISTP521_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nOPENSSL_cleanse(pre, sizeof(*pre));\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nint ec_GFp_nistp521_group_init(EC_GROUP *group)\\r\\n{\\r\\nint ret;\\r\\nret = ec_GFp_simple_group_init(group);\\r\\ngroup->a_is_minus3 = 1;\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp521_group_set_curve(EC_GROUP *group, const BIGNUM *p,\\r\\nconst BIGNUM *a, const BIGNUM *b,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *curve_p, *curve_a, *curve_b;\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (((curve_p = BN_CTX_get(ctx)) == NULL) ||\\r\\n((curve_a = BN_CTX_get(ctx)) == NULL) ||\\r\\n((curve_b = BN_CTX_get(ctx)) == NULL))\\r\\ngoto err;\\r\\nBN_bin2bn(nistp521_curve_params[0], sizeof(felem_bytearray), curve_p);\\r\\nBN_bin2bn(nistp521_curve_params[1], sizeof(felem_bytearray), curve_a);\\r\\nBN_bin2bn(nistp521_curve_params[2], sizeof(felem_bytearray), curve_b);\\r\\nif ((BN_cmp(curve_p, p)) || (BN_cmp(curve_a, a)) || (BN_cmp(curve_b, b))) {\\r\\nECerr(EC_F_EC_GFP_NISTP521_GROUP_SET_CURVE,\\r\\nEC_R_WRONG_CURVE_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\ngroup->field_mod_func = BN_nist_mod_521;\\r\\nret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp521_point_get_affine_coordinates(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nfelem z1, z2, x_in, y_in, x_out, y_out;\\r\\nlargefelem tmp;\\r\\nif (EC_POINT_is_at_infinity(group, point)) {\\r\\nECerr(EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES,\\r\\nEC_R_POINT_AT_INFINITY);\\r\\nreturn 0;\\r\\n}\\r\\nif ((!BN_to_felem(x_in, &point->X)) || (!BN_to_felem(y_in, &point->Y)) ||\\r\\n(!BN_to_felem(z1, &point->Z)))\\r\\nreturn 0;\\r\\nfelem_inv(z2, z1);\\r\\nfelem_square(tmp, z2);\\r\\nfelem_reduce(z1, tmp);\\r\\nfelem_mul(tmp, x_in, z1);\\r\\nfelem_reduce(x_in, tmp);\\r\\nfelem_contract(x_out, x_in);\\r\\nif (x != NULL) {\\r\\nif (!felem_to_BN(x, x_out)) {\\r\\nECerr(EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES,\\r\\nERR_R_BN_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nfelem_mul(tmp, z1, z2);\\r\\nfelem_reduce(z1, tmp);\\r\\nfelem_mul(tmp, y_in, z1);\\r\\nfelem_reduce(y_in, tmp);\\r\\nfelem_contract(y_out, y_in);\\r\\nif (y != NULL) {\\r\\nif (!felem_to_BN(y, y_out)) {\\r\\nECerr(EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES,\\r\\nERR_R_BN_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void make_points_affine(size_t num, felem points[][3],\\r\\nfelem tmp_felems[])\\r\\n{\\r\\nec_GFp_nistp_points_make_affine_internal(num,\\r\\npoints,\\r\\nsizeof(felem),\\r\\ntmp_felems,\\r\\n(void (*)(void *))felem_one,\\r\\n(int (*)(const void *))\\r\\nfelem_is_zero_int,\\r\\n(void (*)(void *, const void *))\\r\\nfelem_assign,\\r\\n(void (*)(void *, const void *))\\r\\nfelem_square_reduce, (void (*)\\r\\n(void *,\\r\\nconst void\\r\\n*,\\r\\nconst void\\r\\n*))\\r\\nfelem_mul_reduce,\\r\\n(void (*)(void *, const void *))\\r\\nfelem_inv,\\r\\n(void (*)(void *, const void *))\\r\\nfelem_contract);\\r\\n}\\r\\nint ec_GFp_nistp521_points_mul(const EC_GROUP *group, EC_POINT *r,\\r\\nconst BIGNUM *scalar, size_t num,\\r\\nconst EC_POINT *points[],\\r\\nconst BIGNUM *scalars[], BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nint j;\\r\\nint mixed = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y, *z, *tmp_scalar;\\r\\nfelem_bytearray g_secret;\\r\\nfelem_bytearray *secrets = NULL;\\r\\nfelem(*pre_comp)[17][3] = NULL;\\r\\nfelem *tmp_felems = NULL;\\r\\nfelem_bytearray tmp;\\r\\nunsigned i, num_bytes;\\r\\nint have_pre_comp = 0;\\r\\nsize_t num_points = num;\\r\\nfelem x_in, y_in, z_in, x_out, y_out, z_out;\\r\\nNISTP521_PRE_COMP *pre = NULL;\\r\\nfelem(*g_pre_comp)[3] = NULL;\\r\\nEC_POINT *generator = NULL;\\r\\nconst EC_POINT *p = NULL;\\r\\nconst BIGNUM *p_scalar = NULL;\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (((x = BN_CTX_get(ctx)) == NULL) ||\\r\\n((y = BN_CTX_get(ctx)) == NULL) ||\\r\\n((z = BN_CTX_get(ctx)) == NULL) ||\\r\\n((tmp_scalar = BN_CTX_get(ctx)) == NULL))\\r\\ngoto err;\\r\\nif (scalar != NULL) {\\r\\npre = EC_EX_DATA_get_data(group->extra_data,\\r\\nnistp521_pre_comp_dup,\\r\\nnistp521_pre_comp_free,\\r\\nnistp521_pre_comp_clear_free);\\r\\nif (pre)\\r\\ng_pre_comp = &pre->g_pre_comp[0];\\r\\nelse\\r\\ng_pre_comp = (felem(*)[3]) gmul;\\r\\ngenerator = EC_POINT_new(group);\\r\\nif (generator == NULL)\\r\\ngoto err;\\r\\nif (!felem_to_BN(x, g_pre_comp[1][0]) ||\\r\\n!felem_to_BN(y, g_pre_comp[1][1]) ||\\r\\n!felem_to_BN(z, g_pre_comp[1][2])) {\\r\\nECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_set_Jprojective_coordinates_GFp(group,\\r\\ngenerator, x, y, z,\\r\\nctx))\\r\\ngoto err;\\r\\nif (0 == EC_POINT_cmp(group, generator, group->generator, ctx))\\r\\nhave_pre_comp = 1;\\r\\nelse\\r\\nnum_points++;\\r\\n}\\r\\nif (num_points > 0) {\\r\\nif (num_points >= 2) {\\r\\nmixed = 1;\\r\\n}\\r\\nsecrets = OPENSSL_malloc(num_points * sizeof(felem_bytearray));\\r\\npre_comp = OPENSSL_malloc(num_points * 17 * 3 * sizeof(felem));\\r\\nif (mixed)\\r\\ntmp_felems =\\r\\nOPENSSL_malloc((num_points * 17 + 1) * sizeof(felem));\\r\\nif ((secrets == NULL) || (pre_comp == NULL)\\r\\n|| (mixed && (tmp_felems == NULL))) {\\r\\nECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemset(secrets, 0, num_points * sizeof(felem_bytearray));\\r\\nmemset(pre_comp, 0, num_points * 17 * 3 * sizeof(felem));\\r\\nfor (i = 0; i < num_points; ++i) {\\r\\nif (i == num)\\r\\n{\\r\\np = EC_GROUP_get0_generator(group);\\r\\np_scalar = scalar;\\r\\n} else\\r\\n{\\r\\np = points[i];\\r\\np_scalar = scalars[i];\\r\\n}\\r\\nif ((p_scalar != NULL) && (p != NULL)) {\\r\\nif ((BN_num_bits(p_scalar) > 521)\\r\\n|| (BN_is_negative(p_scalar))) {\\r\\nif (!BN_nnmod(tmp_scalar, p_scalar, &group->order, ctx)) {\\r\\nECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nnum_bytes = BN_bn2bin(tmp_scalar, tmp);\\r\\n} else\\r\\nnum_bytes = BN_bn2bin(p_scalar, tmp);\\r\\nflip_endian(secrets[i], tmp, num_bytes);\\r\\nif ((!BN_to_felem(x_out, &p->X)) ||\\r\\n(!BN_to_felem(y_out, &p->Y)) ||\\r\\n(!BN_to_felem(z_out, &p->Z)))\\r\\ngoto err;\\r\\nmemcpy(pre_comp[i][1][0], x_out, sizeof(felem));\\r\\nmemcpy(pre_comp[i][1][1], y_out, sizeof(felem));\\r\\nmemcpy(pre_comp[i][1][2], z_out, sizeof(felem));\\r\\nfor (j = 2; j <= 16; ++j) {\\r\\nif (j & 1) {\\r\\npoint_add(pre_comp[i][j][0], pre_comp[i][j][1],\\r\\npre_comp[i][j][2], pre_comp[i][1][0],\\r\\npre_comp[i][1][1], pre_comp[i][1][2], 0,\\r\\npre_comp[i][j - 1][0],\\r\\npre_comp[i][j - 1][1],\\r\\npre_comp[i][j - 1][2]);\\r\\n} else {\\r\\npoint_double(pre_comp[i][j][0], pre_comp[i][j][1],\\r\\npre_comp[i][j][2], pre_comp[i][j / 2][0],\\r\\npre_comp[i][j / 2][1],\\r\\npre_comp[i][j / 2][2]);\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nif (mixed)\\r\\nmake_points_affine(num_points * 17, pre_comp[0], tmp_felems);\\r\\n}\\r\\nif ((scalar != NULL) && (have_pre_comp)) {\\r\\nmemset(g_secret, 0, sizeof(g_secret));\\r\\nif ((BN_num_bits(scalar) > 521) || (BN_is_negative(scalar))) {\\r\\nif (!BN_nnmod(tmp_scalar, scalar, &group->order, ctx)) {\\r\\nECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nnum_bytes = BN_bn2bin(tmp_scalar, tmp);\\r\\n} else\\r\\nnum_bytes = BN_bn2bin(scalar, tmp);\\r\\nflip_endian(g_secret, tmp, num_bytes);\\r\\nbatch_mul(x_out, y_out, z_out,\\r\\n(const felem_bytearray(*))secrets, num_points,\\r\\ng_secret,\\r\\nmixed, (const felem(*)[17][3])pre_comp,\\r\\n(const felem(*)[3])g_pre_comp);\\r\\n} else\\r\\nbatch_mul(x_out, y_out, z_out,\\r\\n(const felem_bytearray(*))secrets, num_points,\\r\\nNULL, mixed, (const felem(*)[17][3])pre_comp, NULL);\\r\\nfelem_contract(x_in, x_out);\\r\\nfelem_contract(y_in, y_out);\\r\\nfelem_contract(z_in, z_out);\\r\\nif ((!felem_to_BN(x, x_in)) || (!felem_to_BN(y, y_in)) ||\\r\\n(!felem_to_BN(z, z_in))) {\\r\\nECerr(EC_F_EC_GFP_NISTP521_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret = EC_POINT_set_Jprojective_coordinates_GFp(group, r, x, y, z, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (generator != NULL)\\r\\nEC_POINT_free(generator);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (secrets != NULL)\\r\\nOPENSSL_free(secrets);\\r\\nif (pre_comp != NULL)\\r\\nOPENSSL_free(pre_comp);\\r\\nif (tmp_felems != NULL)\\r\\nOPENSSL_free(tmp_felems);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp521_precompute_mult(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nNISTP521_PRE_COMP *pre = NULL;\\r\\nint i, j;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y;\\r\\nEC_POINT *generator = NULL;\\r\\nfelem tmp_felems[16];\\r\\nEC_EX_DATA_free_data(&group->extra_data, nistp521_pre_comp_dup,\\r\\nnistp521_pre_comp_free,\\r\\nnistp521_pre_comp_clear_free);\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (((x = BN_CTX_get(ctx)) == NULL) || ((y = BN_CTX_get(ctx)) == NULL))\\r\\ngoto err;\\r\\nif (group->generator == NULL)\\r\\ngoto err;\\r\\ngenerator = EC_POINT_new(group);\\r\\nif (generator == NULL)\\r\\ngoto err;\\r\\nBN_bin2bn(nistp521_curve_params[3], sizeof(felem_bytearray), x);\\r\\nBN_bin2bn(nistp521_curve_params[4], sizeof(felem_bytearray), y);\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, generator, x, y, ctx))\\r\\ngoto err;\\r\\nif ((pre = nistp521_pre_comp_new()) == NULL)\\r\\ngoto err;\\r\\nif (0 == EC_POINT_cmp(group, generator, group->generator, ctx)) {\\r\\nmemcpy(pre->g_pre_comp, gmul, sizeof(pre->g_pre_comp));\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif ((!BN_to_felem(pre->g_pre_comp[1][0], &group->generator->X)) ||\\r\\n(!BN_to_felem(pre->g_pre_comp[1][1], &group->generator->Y)) ||\\r\\n(!BN_to_felem(pre->g_pre_comp[1][2], &group->generator->Z)))\\r\\ngoto err;\\r\\nfor (i = 1; i <= 4; i <<= 1) {\\r\\npoint_double(pre->g_pre_comp[2 * i][0], pre->g_pre_comp[2 * i][1],\\r\\npre->g_pre_comp[2 * i][2], pre->g_pre_comp[i][0],\\r\\npre->g_pre_comp[i][1], pre->g_pre_comp[i][2]);\\r\\nfor (j = 0; j < 129; ++j) {\\r\\npoint_double(pre->g_pre_comp[2 * i][0],\\r\\npre->g_pre_comp[2 * i][1],\\r\\npre->g_pre_comp[2 * i][2],\\r\\npre->g_pre_comp[2 * i][0],\\r\\npre->g_pre_comp[2 * i][1],\\r\\npre->g_pre_comp[2 * i][2]);\\r\\n}\\r\\n}\\r\\nmemset(pre->g_pre_comp[0], 0, sizeof(pre->g_pre_comp[0]));\\r\\npoint_add(pre->g_pre_comp[6][0], pre->g_pre_comp[6][1],\\r\\npre->g_pre_comp[6][2], pre->g_pre_comp[4][0],\\r\\npre->g_pre_comp[4][1], pre->g_pre_comp[4][2],\\r\\n0, pre->g_pre_comp[2][0], pre->g_pre_comp[2][1],\\r\\npre->g_pre_comp[2][2]);\\r\\npoint_add(pre->g_pre_comp[10][0], pre->g_pre_comp[10][1],\\r\\npre->g_pre_comp[10][2], pre->g_pre_comp[8][0],\\r\\npre->g_pre_comp[8][1], pre->g_pre_comp[8][2],\\r\\n0, pre->g_pre_comp[2][0], pre->g_pre_comp[2][1],\\r\\npre->g_pre_comp[2][2]);\\r\\npoint_add(pre->g_pre_comp[12][0], pre->g_pre_comp[12][1],\\r\\npre->g_pre_comp[12][2], pre->g_pre_comp[8][0],\\r\\npre->g_pre_comp[8][1], pre->g_pre_comp[8][2],\\r\\n0, pre->g_pre_comp[4][0], pre->g_pre_comp[4][1],\\r\\npre->g_pre_comp[4][2]);\\r\\npoint_add(pre->g_pre_comp[14][0], pre->g_pre_comp[14][1],\\r\\npre->g_pre_comp[14][2], pre->g_pre_comp[12][0],\\r\\npre->g_pre_comp[12][1], pre->g_pre_comp[12][2],\\r\\n0, pre->g_pre_comp[2][0], pre->g_pre_comp[2][1],\\r\\npre->g_pre_comp[2][2]);\\r\\nfor (i = 1; i < 8; ++i) {\\r\\npoint_add(pre->g_pre_comp[2 * i + 1][0],\\r\\npre->g_pre_comp[2 * i + 1][1],\\r\\npre->g_pre_comp[2 * i + 1][2], pre->g_pre_comp[2 * i][0],\\r\\npre->g_pre_comp[2 * i][1], pre->g_pre_comp[2 * i][2], 0,\\r\\npre->g_pre_comp[1][0], pre->g_pre_comp[1][1],\\r\\npre->g_pre_comp[1][2]);\\r\\n}\\r\\nmake_points_affine(15, &(pre->g_pre_comp[1]), tmp_felems);\\r\\nif (!EC_EX_DATA_set_data(&group->extra_data, pre, nistp521_pre_comp_dup,\\r\\nnistp521_pre_comp_free,\\r\\nnistp521_pre_comp_clear_free))\\r\\ngoto err;\\r\\nret = 1;\\r\\npre = NULL;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (generator != NULL)\\r\\nEC_POINT_free(generator);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (pre)\\r\\nnistp521_pre_comp_free(pre);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp521_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nif (EC_EX_DATA_get_data(group->extra_data, nistp521_pre_comp_dup,\\r\\nnistp521_pre_comp_free,\\r\\nnistp521_pre_comp_clear_free)\\r\\n!= NULL)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_lib_c", "target": 0, "func": "int X509V3_EXT_add(X509V3_EXT_METHOD *ext)\\r\\n{\\r\\nif (!ext_list && !(ext_list = sk_X509V3_EXT_METHOD_new(ext_cmp))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_X509V3_EXT_METHOD_push(ext_list, ext)) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ext_cmp(const X509V3_EXT_METHOD *const *a,\\r\\nconst X509V3_EXT_METHOD *const *b)\\r\\n{\\r\\nreturn ((*a)->ext_nid - (*b)->ext_nid);\\r\\n}\\r\\nconst X509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid)\\r\\n{\\r\\nX509V3_EXT_METHOD tmp;\\r\\nconst X509V3_EXT_METHOD *t = &tmp, *const *ret;\\r\\nint idx;\\r\\nif (nid < 0)\\r\\nreturn NULL;\\r\\ntmp.ext_nid = nid;\\r\\nret = OBJ_bsearch_ext(&t, standard_exts, STANDARD_EXTENSION_COUNT);\\r\\nif (ret)\\r\\nreturn *ret;\\r\\nif (!ext_list)\\r\\nreturn NULL;\\r\\nidx = sk_X509V3_EXT_METHOD_find(ext_list, &tmp);\\r\\nif (idx == -1)\\r\\nreturn NULL;\\r\\nreturn sk_X509V3_EXT_METHOD_value(ext_list, idx);\\r\\n}\\r\\nconst X509V3_EXT_METHOD *X509V3_EXT_get(X509_EXTENSION *ext)\\r\\n{\\r\\nint nid;\\r\\nif ((nid = OBJ_obj2nid(ext->object)) == NID_undef)\\r\\nreturn NULL;\\r\\nreturn X509V3_EXT_get_nid(nid);\\r\\n}\\r\\nint X509V3_EXT_free(int nid, void *ext_data)\\r\\n{\\r\\nconst X509V3_EXT_METHOD *ext_method = X509V3_EXT_get_nid(nid);\\r\\nif (ext_method == NULL) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_FREE,\\r\\nX509V3_R_CANNOT_FIND_FREE_FUNCTION);\\r\\nreturn 0;\\r\\n}\\r\\nif (ext_method->it != NULL)\\r\\nASN1_item_free(ext_data, ASN1_ITEM_ptr(ext_method->it));\\r\\nelse if (ext_method->ext_free != NULL)\\r\\next_method->ext_free(ext_data);\\r\\nelse {\\r\\nX509V3err(X509V3_F_X509V3_EXT_FREE,\\r\\nX509V3_R_CANNOT_FIND_FREE_FUNCTION);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint X509V3_EXT_add_list(X509V3_EXT_METHOD *extlist)\\r\\n{\\r\\nfor (; extlist->ext_nid != -1; extlist++)\\r\\nif (!X509V3_EXT_add(extlist))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint X509V3_EXT_add_alias(int nid_to, int nid_from)\\r\\n{\\r\\nconst X509V3_EXT_METHOD *ext;\\r\\nX509V3_EXT_METHOD *tmpext;\\r\\nif (!(ext = X509V3_EXT_get_nid(nid_from))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS,\\r\\nX509V3_R_EXTENSION_NOT_FOUND);\\r\\nreturn 0;\\r\\n}\\r\\nif (!\\r\\n(tmpext =\\r\\n(X509V3_EXT_METHOD *)OPENSSL_malloc(sizeof(X509V3_EXT_METHOD)))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_ADD_ALIAS, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n*tmpext = *ext;\\r\\ntmpext->ext_nid = nid_to;\\r\\ntmpext->ext_flags |= X509V3_EXT_DYNAMIC;\\r\\nreturn X509V3_EXT_add(tmpext);\\r\\n}\\r\\nvoid X509V3_EXT_cleanup(void)\\r\\n{\\r\\nsk_X509V3_EXT_METHOD_pop_free(ext_list, ext_list_free);\\r\\next_list = NULL;\\r\\n}\\r\\nstatic void ext_list_free(X509V3_EXT_METHOD *ext)\\r\\n{\\r\\nif (ext->ext_flags & X509V3_EXT_DYNAMIC)\\r\\nOPENSSL_free(ext);\\r\\n}\\r\\nint X509V3_add_standard_extensions(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nvoid *X509V3_EXT_d2i(X509_EXTENSION *ext)\\r\\n{\\r\\nconst X509V3_EXT_METHOD *method;\\r\\nconst unsigned char *p;\\r\\nif (!(method = X509V3_EXT_get(ext)))\\r\\nreturn NULL;\\r\\np = ext->value->data;\\r\\nif (method->it)\\r\\nreturn ASN1_item_d2i(NULL, &p, ext->value->length,\\r\\nASN1_ITEM_ptr(method->it));\\r\\nreturn method->d2i(NULL, &p, ext->value->length);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_uplink_c", "target": 0, "func": "static void unimplemented(void)\\r\\n{\\r\\nOPENSSL_showfatal(sizeof(TCHAR) == sizeof(char) ? \"%s\\n\" : \"%S\\n\", msg);\\r\\nExitProcess(1);\\r\\n}\\r\\nvoid OPENSSL_Uplink(volatile void **table, int index)\\r\\n{\\r\\nstatic HMODULE volatile apphandle = NULL;\\r\\nstatic void **volatile applinktable = NULL;\\r\\nint len;\\r\\nvoid (*func) (void) = unimplemented;\\r\\nHANDLE h;\\r\\nvoid **p;\\r\\ndo {\\r\\nlen = _sntprintf(msg, sizeof(msg) / sizeof(TCHAR),\\r\\n_T(\"OPENSSL_Uplink(%p,%02X): \"), table, index);\\r\\n_tcscpy(msg + len, _T(\"unimplemented function\"));\\r\\nif ((h = apphandle) == NULL) {\\r\\nif ((h = GetModuleHandle(NULL)) == NULL) {\\r\\napphandle = (HMODULE) - 1;\\r\\n_tcscpy(msg + len, _T(\"no host application\"));\\r\\nbreak;\\r\\n}\\r\\napphandle = h;\\r\\n}\\r\\nif ((h = apphandle) == (HMODULE) - 1)\\r\\nbreak;\\r\\nif (applinktable == NULL) {\\r\\nvoid **(*applink) ();\\r\\napplink = (void **(*)())GetProcAddress(h, \"OPENSSL_Applink\");\\r\\nif (applink == NULL) {\\r\\napphandle = (HMODULE) - 1;\\r\\n_tcscpy(msg + len, _T(\"no OPENSSL_Applink\"));\\r\\nbreak;\\r\\n}\\r\\np = (*applink) ();\\r\\nif (p == NULL) {\\r\\napphandle = (HMODULE) - 1;\\r\\n_tcscpy(msg + len, _T(\"no ApplinkTable\"));\\r\\nbreak;\\r\\n}\\r\\napplinktable = p;\\r\\n} else\\r\\np = applinktable;\\r\\nif (index > (int)p[0])\\r\\nbreak;\\r\\nif (p[index])\\r\\nfunc = p[index];\\r\\n} while (0);\\r\\ntable[index] = func;\\r\\n}\\r\\nmain()\\r\\n{\\r\\nUP_fprintf(UP_stdout, \"hello, world!\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_def_c", "target": 0, "func": "const char *X509_get_default_private_dir(void)\\r\\n{\\r\\nreturn (X509_PRIVATE_DIR);\\r\\n}\\r\\nconst char *X509_get_default_cert_area(void)\\r\\n{\\r\\nreturn (X509_CERT_AREA);\\r\\n}\\r\\nconst char *X509_get_default_cert_dir(void)\\r\\n{\\r\\nreturn (X509_CERT_DIR);\\r\\n}\\r\\nconst char *X509_get_default_cert_file(void)\\r\\n{\\r\\nreturn (X509_CERT_FILE);\\r\\n}\\r\\nconst char *X509_get_default_cert_dir_env(void)\\r\\n{\\r\\nreturn (X509_CERT_DIR_EVP);\\r\\n}\\r\\nconst char *X509_get_default_cert_file_env(void)\\r\\n{\\r\\nreturn (X509_CERT_FILE_EVP);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_skey_c", "target": 0, "func": "char *i2s_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method, ASN1_OCTET_STRING *oct)\\r\\n{\\r\\nreturn hex_to_string(oct->data, oct->length);\\r\\n}\\r\\nASN1_OCTET_STRING *s2i_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *oct;\\r\\nlong length;\\r\\nif (!(oct = M_ASN1_OCTET_STRING_new())) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_OCTET_STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(oct->data = string_to_hex(str, &length))) {\\r\\nM_ASN1_OCTET_STRING_free(oct);\\r\\nreturn NULL;\\r\\n}\\r\\noct->length = length;\\r\\nreturn oct;\\r\\n}\\r\\nstatic ASN1_OCTET_STRING *s2i_skey_id(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *str)\\r\\n{\\r\\nASN1_OCTET_STRING *oct;\\r\\nASN1_BIT_STRING *pk;\\r\\nunsigned char pkey_dig[EVP_MAX_MD_SIZE];\\r\\nunsigned int diglen;\\r\\nif (strcmp(str, \"hash\"))\\r\\nreturn s2i_ASN1_OCTET_STRING(method, ctx, str);\\r\\nif (!(oct = M_ASN1_OCTET_STRING_new())) {\\r\\nX509V3err(X509V3_F_S2I_SKEY_ID, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (ctx && (ctx->flags == CTX_TEST))\\r\\nreturn oct;\\r\\nif (!ctx || (!ctx->subject_req && !ctx->subject_cert)) {\\r\\nX509V3err(X509V3_F_S2I_SKEY_ID, X509V3_R_NO_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (ctx->subject_req)\\r\\npk = ctx->subject_req->req_info->pubkey->public_key;\\r\\nelse\\r\\npk = ctx->subject_cert->cert_info->key->public_key;\\r\\nif (!pk) {\\r\\nX509V3err(X509V3_F_S2I_SKEY_ID, X509V3_R_NO_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_Digest\\r\\n(pk->data, pk->length, pkey_dig, &diglen, EVP_sha1(), NULL))\\r\\ngoto err;\\r\\nif (!M_ASN1_OCTET_STRING_set(oct, pkey_dig, diglen)) {\\r\\nX509V3err(X509V3_F_S2I_SKEY_ID, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nreturn oct;\\r\\nerr:\\r\\nM_ASN1_OCTET_STRING_free(oct);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsaparam_c", "target": 0, "func": "static void timebomb_sigalarm(int foo)\\r\\n{\\r\\nstop_keygen_flag = 1;\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nDSA *dsa = NULL;\\r\\nint i, badops = 0, text = 0;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat, noout = 0, C = 0, ret = 1;\\r\\nchar *infile, *outfile, *prog, *inrand = NULL;\\r\\nint numbits = -1, num, genkey = 0;\\r\\nint need_rand = 0;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n# endif\\r\\n# ifdef GENCB_TEST\\r\\nint timebomb = 0;\\r\\n# endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninfile = NULL;\\r\\noutfile = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n# endif\\r\\n# ifdef GENCB_TEST\\r\\nelse if (strcmp(*argv, \"-timebomb\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ntimebomb = atoi(*(++argv));\\r\\n}\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv, \"-C\") == 0)\\r\\nC = 1;\\r\\nelse if (strcmp(*argv, \"-genkey\") == 0) {\\r\\ngenkey = 1;\\r\\nneed_rand = 1;\\r\\n} else if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninrand = *(++argv);\\r\\nneed_rand = 1;\\r\\n} else if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (sscanf(*argv, \"%d\", &num) == 1) {\\r\\nnumbits = num;\\r\\nneed_rand = 1;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] [bits] <infile >outfile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\nBIO_printf(bio_err, \" -text print as text\\n\");\\r\\nBIO_printf(bio_err, \" -C Output C code\\n\");\\r\\nBIO_printf(bio_err, \" -noout no output\\n\");\\r\\nBIO_printf(bio_err, \" -genkey generate a DSA key\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -rand files to use for random number input\\n\");\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n# endif\\r\\n# ifdef GENCB_TEST\\r\\nBIO_printf(bio_err,\\r\\n\" -timebomb n interrupt keygen after <n> seconds\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err,\\r\\n\" number number of bits to use for generating private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (need_rand) {\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n}\\r\\nif (numbits > 0) {\\r\\nBN_GENCB cb;\\r\\nBN_GENCB_set(&cb, dsa_cb, bio_err);\\r\\nassert(need_rand);\\r\\ndsa = DSA_new();\\r\\nif (!dsa) {\\r\\nBIO_printf(bio_err, \"Error allocating DSA object\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err, \"Generating DSA parameters, %d bit long prime\\n\",\\r\\nnum);\\r\\nBIO_printf(bio_err, \"This could take some time\\n\");\\r\\n# ifdef GENCB_TEST\\r\\nif (timebomb > 0) {\\r\\nstruct sigaction act;\\r\\nact.sa_handler = timebomb_sigalarm;\\r\\nact.sa_flags = 0;\\r\\nBIO_printf(bio_err,\\r\\n\"(though I'll stop it if not done within %d secs)\\n\",\\r\\ntimebomb);\\r\\nif (sigaction(SIGALRM, &act, NULL) != 0) {\\r\\nBIO_printf(bio_err, \"Error, couldn't set SIGALRM handler\\n\");\\r\\ngoto end;\\r\\n}\\r\\nalarm(timebomb);\\r\\n}\\r\\n# endif\\r\\nif (!DSA_generate_parameters_ex(dsa, num, NULL, 0, NULL, NULL, &cb)) {\\r\\n# ifdef GENCB_TEST\\r\\nif (stop_keygen_flag) {\\r\\nBIO_printf(bio_err, \"DSA key generation time-stopped\\n\");\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\n# endif\\r\\nERR_print_errors(bio_err);\\r\\nBIO_printf(bio_err, \"Error, DSA key generation failed\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else if (informat == FORMAT_ASN1)\\r\\ndsa = d2i_DSAparams_bio(in, NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ndsa = PEM_read_bio_DSAparams(in, NULL, NULL, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad input format specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (dsa == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load DSA parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (text) {\\r\\nDSAparams_print(out, dsa);\\r\\n}\\r\\nif (C) {\\r\\nunsigned char *data;\\r\\nint l, len, bits_p;\\r\\nlen = BN_num_bytes(dsa->p);\\r\\nbits_p = BN_num_bits(dsa->p);\\r\\ndata = (unsigned char *)OPENSSL_malloc(len + 20);\\r\\nif (data == NULL) {\\r\\nperror(\"OPENSSL_malloc\");\\r\\ngoto end;\\r\\n}\\r\\nl = BN_bn2bin(dsa->p, data);\\r\\nprintf(\"static unsigned char dsa%d_p[]={\", bits_p);\\r\\nfor (i = 0; i < l; i++) {\\r\\nif ((i % 12) == 0)\\r\\nprintf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\", data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\");\\r\\nl = BN_bn2bin(dsa->q, data);\\r\\nprintf(\"static unsigned char dsa%d_q[]={\", bits_p);\\r\\nfor (i = 0; i < l; i++) {\\r\\nif ((i % 12) == 0)\\r\\nprintf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\", data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\");\\r\\nl = BN_bn2bin(dsa->g, data);\\r\\nprintf(\"static unsigned char dsa%d_g[]={\", bits_p);\\r\\nfor (i = 0; i < l; i++) {\\r\\nif ((i % 12) == 0)\\r\\nprintf(\"\\n\\t\");\\r\\nprintf(\"0x%02X,\", data[i]);\\r\\n}\\r\\nprintf(\"\\n\\t};\\n\\n\");\\r\\nprintf(\"DSA *get_dsa%d()\\n\\t{\\n\", bits_p);\\r\\nprintf(\"\\tDSA *dsa;\\n\\n\");\\r\\nprintf(\"\\tif ((dsa=DSA_new()) == NULL) return(NULL);\\n\");\\r\\nprintf(\"\\tdsa->p=BN_bin2bn(dsa%d_p,sizeof(dsa%d_p),NULL);\\n\",\\r\\nbits_p, bits_p);\\r\\nprintf(\"\\tdsa->q=BN_bin2bn(dsa%d_q,sizeof(dsa%d_q),NULL);\\n\",\\r\\nbits_p, bits_p);\\r\\nprintf(\"\\tdsa->g=BN_bin2bn(dsa%d_g,sizeof(dsa%d_g),NULL);\\n\",\\r\\nbits_p, bits_p);\\r\\nprintf\\r\\n(\"\\tif ((dsa->p == NULL) || (dsa->q == NULL) || (dsa->g == NULL))\\n\");\\r\\nprintf(\"\\t\\t{ DSA_free(dsa); return(NULL); }\\n\");\\r\\nprintf(\"\\treturn(dsa);\\n\\t}\\n\");\\r\\n}\\r\\nif (!noout) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_DSAparams_bio(out, dsa);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_DSAparams(out, dsa);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write DSA parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (genkey) {\\r\\nDSA *dsakey;\\r\\nassert(need_rand);\\r\\nif ((dsakey = DSAparams_dup(dsa)) == NULL)\\r\\ngoto end;\\r\\nif (!DSA_generate_key(dsakey)) {\\r\\nERR_print_errors(bio_err);\\r\\nDSA_free(dsakey);\\r\\ngoto end;\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_DSAPrivateKey_bio(out, dsakey);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_DSAPrivateKey(out, dsakey, NULL, NULL, 0, NULL,\\r\\nNULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\nDSA_free(dsakey);\\r\\ngoto end;\\r\\n}\\r\\nDSA_free(dsakey);\\r\\n}\\r\\nif (need_rand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nret = 0;\\r\\nend:\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (dsa != NULL)\\r\\nDSA_free(dsa);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK dsa_cb(int p, int n, BN_GENCB *cb)\\r\\n{\\r\\nchar c = '*';\\r\\nif (p == 0)\\r\\nc = '.';\\r\\nif (p == 1)\\r\\nc = '+';\\r\\nif (p == 2)\\r\\nc = '*';\\r\\nif (p == 3)\\r\\nc = '\\n';\\r\\nBIO_write(cb->arg, &c, 1);\\r\\n(void)BIO_flush(cb->arg);\\r\\n# ifdef LINT\\r\\np = n;\\r\\n# endif\\r\\n# ifdef GENCB_TEST\\r\\nif (stop_keygen_flag)\\r\\nreturn 0;\\r\\n# endif\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_smsign2_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL;\\r\\nX509 *scert = NULL, *scert2 = NULL;\\r\\nEVP_PKEY *skey = NULL, *skey2 = NULL;\\r\\nPKCS7 *p7 = NULL;\\r\\nint ret = 1;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\ntbio = BIO_new_file(\"signer.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nscert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nBIO_reset(tbio);\\r\\nskey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);\\r\\nBIO_free(tbio);\\r\\ntbio = BIO_new_file(\"signer2.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nscert2 = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nBIO_reset(tbio);\\r\\nskey2 = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);\\r\\nif (!scert2 || !skey2)\\r\\ngoto err;\\r\\nin = BIO_new_file(\"sign.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\np7 = PKCS7_sign(NULL, NULL, NULL, in, PKCS7_STREAM | PKCS7_PARTIAL);\\r\\nif (!p7)\\r\\ngoto err;\\r\\nif (!PKCS7_sign_add_signer(p7, scert, skey, NULL, 0))\\r\\ngoto err;\\r\\nif (!PKCS7_sign_add_signer(p7, scert2, skey2, NULL, 0))\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smout.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!SMIME_write_PKCS7(out, p7, in, PKCS7_STREAM))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Signing Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (p7)\\r\\nPKCS7_free(p7);\\r\\nif (scert)\\r\\nX509_free(scert);\\r\\nif (skey)\\r\\nEVP_PKEY_free(skey);\\r\\nif (scert2)\\r\\nX509_free(scert2);\\r\\nif (skey)\\r\\nEVP_PKEY_free(skey2);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_ncons_c", "target": 0, "func": "int i2r_NAME_CONSTRAINTS(const X509V3_EXT_METHOD *method, void *a,\\r\\nBIO *bp, int ind)\\r\\n{\\r\\nNAME_CONSTRAINTS *ncons = a;\\r\\ndo_i2r_name_constraints(method, ncons->permittedSubtrees,\\r\\nbp, ind, \"Permitted\");\\r\\ndo_i2r_name_constraints(method, ncons->excludedSubtrees,\\r\\nbp, ind, \"Excluded\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic int print_nc_ipadd(BIO *bp, ASN1_OCTET_STRING *ip)\\r\\n{\\r\\nint i, len;\\r\\nunsigned char *p;\\r\\np = ip->data;\\r\\nlen = ip->length;\\r\\nBIO_puts(bp, \"IP:\");\\r\\nif (len == 8) {\\r\\nBIO_printf(bp, \"%d.%d.%d.%d/%d.%d.%d.%d\",\\r\\np[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);\\r\\n} else if (len == 32) {\\r\\nfor (i = 0; i < 16; i++) {\\r\\nBIO_printf(bp, \"%X\", p[0] << 8 | p[1]);\\r\\np += 2;\\r\\nif (i == 7)\\r\\nBIO_puts(bp, \"/\");\\r\\nelse if (i != 15)\\r\\nBIO_puts(bp, \":\");\\r\\n}\\r\\n} else\\r\\nBIO_printf(bp, \"IP Address:<invalid>\");\\r\\nreturn 1;\\r\\n}\\r\\nint NAME_CONSTRAINTS_check(X509 *x, NAME_CONSTRAINTS *nc)\\r\\n{\\r\\nint r, i;\\r\\nX509_NAME *nm;\\r\\nnm = X509_get_subject_name(x);\\r\\nif (X509_NAME_entry_count(nm) > 0) {\\r\\nGENERAL_NAME gntmp;\\r\\ngntmp.type = GEN_DIRNAME;\\r\\ngntmp.d.directoryName = nm;\\r\\nr = nc_match(&gntmp, nc);\\r\\nif (r != X509_V_OK)\\r\\nreturn r;\\r\\ngntmp.type = GEN_EMAIL;\\r\\nfor (i = -1;;) {\\r\\nX509_NAME_ENTRY *ne;\\r\\ni = X509_NAME_get_index_by_NID(nm, NID_pkcs9_emailAddress, i);\\r\\nif (i == -1)\\r\\nbreak;\\r\\nne = X509_NAME_get_entry(nm, i);\\r\\ngntmp.d.rfc822Name = X509_NAME_ENTRY_get_data(ne);\\r\\nif (gntmp.d.rfc822Name->type != V_ASN1_IA5STRING)\\r\\nreturn X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\\r\\nr = nc_match(&gntmp, nc);\\r\\nif (r != X509_V_OK)\\r\\nreturn r;\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(x->altname); i++) {\\r\\nGENERAL_NAME *gen = sk_GENERAL_NAME_value(x->altname, i);\\r\\nr = nc_match(gen, nc);\\r\\nif (r != X509_V_OK)\\r\\nreturn r;\\r\\n}\\r\\nreturn X509_V_OK;\\r\\n}\\r\\nstatic int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc)\\r\\n{\\r\\nGENERAL_SUBTREE *sub;\\r\\nint i, r, match = 0;\\r\\nfor (i = 0; i < sk_GENERAL_SUBTREE_num(nc->permittedSubtrees); i++) {\\r\\nsub = sk_GENERAL_SUBTREE_value(nc->permittedSubtrees, i);\\r\\nif (gen->type != sub->base->type)\\r\\ncontinue;\\r\\nif (sub->minimum || sub->maximum)\\r\\nreturn X509_V_ERR_SUBTREE_MINMAX;\\r\\nif (match == 2)\\r\\ncontinue;\\r\\nif (match == 0)\\r\\nmatch = 1;\\r\\nr = nc_match_single(gen, sub->base);\\r\\nif (r == X509_V_OK)\\r\\nmatch = 2;\\r\\nelse if (r != X509_V_ERR_PERMITTED_VIOLATION)\\r\\nreturn r;\\r\\n}\\r\\nif (match == 1)\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\nfor (i = 0; i < sk_GENERAL_SUBTREE_num(nc->excludedSubtrees); i++) {\\r\\nsub = sk_GENERAL_SUBTREE_value(nc->excludedSubtrees, i);\\r\\nif (gen->type != sub->base->type)\\r\\ncontinue;\\r\\nif (sub->minimum || sub->maximum)\\r\\nreturn X509_V_ERR_SUBTREE_MINMAX;\\r\\nr = nc_match_single(gen, sub->base);\\r\\nif (r == X509_V_OK)\\r\\nreturn X509_V_ERR_EXCLUDED_VIOLATION;\\r\\nelse if (r != X509_V_ERR_PERMITTED_VIOLATION)\\r\\nreturn r;\\r\\n}\\r\\nreturn X509_V_OK;\\r\\n}\\r\\nstatic int nc_match_single(GENERAL_NAME *gen, GENERAL_NAME *base)\\r\\n{\\r\\nswitch (base->type) {\\r\\ncase GEN_DIRNAME:\\r\\nreturn nc_dn(gen->d.directoryName, base->d.directoryName);\\r\\ncase GEN_DNS:\\r\\nreturn nc_dns(gen->d.dNSName, base->d.dNSName);\\r\\ncase GEN_EMAIL:\\r\\nreturn nc_email(gen->d.rfc822Name, base->d.rfc822Name);\\r\\ncase GEN_URI:\\r\\nreturn nc_uri(gen->d.uniformResourceIdentifier,\\r\\nbase->d.uniformResourceIdentifier);\\r\\ndefault:\\r\\nreturn X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE;\\r\\n}\\r\\n}\\r\\nstatic int nc_dn(X509_NAME *nm, X509_NAME *base)\\r\\n{\\r\\nif (nm->modified && i2d_X509_NAME(nm, NULL) < 0)\\r\\nreturn X509_V_ERR_OUT_OF_MEM;\\r\\nif (base->modified && i2d_X509_NAME(base, NULL) < 0)\\r\\nreturn X509_V_ERR_OUT_OF_MEM;\\r\\nif (base->canon_enclen > nm->canon_enclen)\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\nif (memcmp(base->canon_enc, nm->canon_enc, base->canon_enclen))\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\nreturn X509_V_OK;\\r\\n}\\r\\nstatic int nc_dns(ASN1_IA5STRING *dns, ASN1_IA5STRING *base)\\r\\n{\\r\\nchar *baseptr = (char *)base->data;\\r\\nchar *dnsptr = (char *)dns->data;\\r\\nif (!*baseptr)\\r\\nreturn X509_V_OK;\\r\\nif (dns->length > base->length) {\\r\\ndnsptr += dns->length - base->length;\\r\\nif (*baseptr != '.' && dnsptr[-1] != '.')\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\n}\\r\\nif (strcasecmp(baseptr, dnsptr))\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\nreturn X509_V_OK;\\r\\n}\\r\\nstatic int nc_email(ASN1_IA5STRING *eml, ASN1_IA5STRING *base)\\r\\n{\\r\\nconst char *baseptr = (char *)base->data;\\r\\nconst char *emlptr = (char *)eml->data;\\r\\nconst char *baseat = strchr(baseptr, '@');\\r\\nconst char *emlat = strchr(emlptr, '@');\\r\\nif (!emlat)\\r\\nreturn X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\\r\\nif (!baseat && (*baseptr == '.')) {\\r\\nif (eml->length > base->length) {\\r\\nemlptr += eml->length - base->length;\\r\\nif (!strcasecmp(baseptr, emlptr))\\r\\nreturn X509_V_OK;\\r\\n}\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\n}\\r\\nif (baseat) {\\r\\nif (baseat != baseptr) {\\r\\nif ((baseat - baseptr) != (emlat - emlptr))\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\nif (strncmp(baseptr, emlptr, emlat - emlptr))\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\n}\\r\\nbaseptr = baseat + 1;\\r\\n}\\r\\nemlptr = emlat + 1;\\r\\nif (strcasecmp(baseptr, emlptr))\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\nreturn X509_V_OK;\\r\\n}\\r\\nstatic int nc_uri(ASN1_IA5STRING *uri, ASN1_IA5STRING *base)\\r\\n{\\r\\nconst char *baseptr = (char *)base->data;\\r\\nconst char *hostptr = (char *)uri->data;\\r\\nconst char *p = strchr(hostptr, ':');\\r\\nint hostlen;\\r\\nif (!p || (p[1] != '/') || (p[2] != '/'))\\r\\nreturn X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\\r\\nhostptr = p + 3;\\r\\np = strchr(hostptr, ':');\\r\\nif (!p)\\r\\np = strchr(hostptr, '/');\\r\\nif (!p)\\r\\nhostlen = strlen(hostptr);\\r\\nelse\\r\\nhostlen = p - hostptr;\\r\\nif (hostlen == 0)\\r\\nreturn X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\\r\\nif (*baseptr == '.') {\\r\\nif (hostlen > base->length) {\\r\\np = hostptr + hostlen - base->length;\\r\\nif (!strncasecmp(p, baseptr, base->length))\\r\\nreturn X509_V_OK;\\r\\n}\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\n}\\r\\nif ((base->length != (int)hostlen)\\r\\n|| strncasecmp(hostptr, baseptr, hostlen))\\r\\nreturn X509_V_ERR_PERMITTED_VIOLATION;\\r\\nreturn X509_V_OK;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_srp_c", "target": 0, "func": "static int get_index(CA_DB *db, char *id, char type)\\r\\n{\\r\\nchar **pp;\\r\\nint i;\\r\\nif (id == NULL)\\r\\nreturn -1;\\r\\nif (type == DB_SRP_INDEX)\\r\\nfor (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\\r\\npp = sk_OPENSSL_PSTRING_value(db->db->data, i);\\r\\nif (pp[DB_srptype][0] == DB_SRP_INDEX\\r\\n&& !strcmp(id, pp[DB_srpid]))\\r\\nreturn i;\\r\\n} else\\r\\nfor (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\\r\\npp = sk_OPENSSL_PSTRING_value(db->db->data, i);\\r\\nif (pp[DB_srptype][0] != DB_SRP_INDEX\\r\\n&& !strcmp(id, pp[DB_srpid]))\\r\\nreturn i;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nstatic void print_entry(CA_DB *db, BIO *bio, int indx, int verbose, char *s)\\r\\n{\\r\\nif (indx >= 0 && verbose) {\\r\\nint j;\\r\\nchar **pp = sk_OPENSSL_PSTRING_value(db->db->data, indx);\\r\\nBIO_printf(bio, \"%s \\\"%s\\\"\\n\", s, pp[DB_srpid]);\\r\\nfor (j = 0; j < DB_NUMBER; j++) {\\r\\nBIO_printf(bio_err, \" %d = \\\"%s\\\"\\n\", j, pp[j]);\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic void print_index(CA_DB *db, BIO *bio, int indexindex, int verbose)\\r\\n{\\r\\nprint_entry(db, bio, indexindex, verbose, \"g N entry\");\\r\\n}\\r\\nstatic void print_user(CA_DB *db, BIO *bio, int userindex, int verbose)\\r\\n{\\r\\nif (verbose > 0) {\\r\\nchar **pp = sk_OPENSSL_PSTRING_value(db->db->data, userindex);\\r\\nif (pp[DB_srptype][0] != 'I') {\\r\\nprint_entry(db, bio, userindex, verbose, \"User entry\");\\r\\nprint_entry(db, bio, get_index(db, pp[DB_srpgN], 'I'), verbose,\\r\\n\"g N entry\");\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int update_index(CA_DB *db, BIO *bio, char **row)\\r\\n{\\r\\nchar **irow;\\r\\nint i;\\r\\nif ((irow =\\r\\n(char **)OPENSSL_malloc(sizeof(char *) * (DB_NUMBER + 1))) == NULL) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < DB_NUMBER; i++) {\\r\\nirow[i] = row[i];\\r\\nrow[i] = NULL;\\r\\n}\\r\\nirow[DB_NUMBER] = NULL;\\r\\nif (!TXT_DB_insert(db->db, irow)) {\\r\\nBIO_printf(bio, \"failed to update srpvfile\\n\");\\r\\nBIO_printf(bio, \"TXT_DB error number %ld\\n\", db->db->error);\\r\\nOPENSSL_free(irow);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void lookup_fail(const char *name, char *tag)\\r\\n{\\r\\nBIO_printf(bio_err, \"variable lookup failed for %s::%s\\n\", name, tag);\\r\\n}\\r\\nstatic char *srp_verify_user(const char *user, const char *srp_verifier,\\r\\nchar *srp_usersalt, const char *g, const char *N,\\r\\nconst char *passin, BIO *bio, int verbose)\\r\\n{\\r\\nchar password[1024];\\r\\nPW_CB_DATA cb_tmp;\\r\\nchar *verifier = NULL;\\r\\nchar *gNid = NULL;\\r\\ncb_tmp.prompt_info = user;\\r\\ncb_tmp.password = passin;\\r\\nif (password_callback(password, 1024, 0, &cb_tmp) > 0) {\\r\\nVERBOSE BIO_printf(bio,\\r\\n\"Validating\\n user=\\\"%s\\\"\\n srp_verifier=\\\"%s\\\"\\n srp_usersalt=\\\"%s\\\"\\n g=\\\"%s\\\"\\n N=\\\"%s\\\"\\n\",\\r\\nuser, srp_verifier, srp_usersalt, g, N);\\r\\nBIO_printf(bio, \"Pass %s\\n\", password);\\r\\nif (!\\r\\n(gNid =\\r\\nSRP_create_verifier(user, password, &srp_usersalt, &verifier, N,\\r\\ng))) {\\r\\nBIO_printf(bio, \"Internal error validating SRP verifier\\n\");\\r\\n} else {\\r\\nif (strcmp(verifier, srp_verifier))\\r\\ngNid = NULL;\\r\\nOPENSSL_free(verifier);\\r\\n}\\r\\n}\\r\\nreturn gNid;\\r\\n}\\r\\nstatic char *srp_create_user(char *user, char **srp_verifier,\\r\\nchar **srp_usersalt, char *g, char *N,\\r\\nchar *passout, BIO *bio, int verbose)\\r\\n{\\r\\nchar password[1024];\\r\\nPW_CB_DATA cb_tmp;\\r\\nchar *gNid = NULL;\\r\\nchar *salt = NULL;\\r\\ncb_tmp.prompt_info = user;\\r\\ncb_tmp.password = passout;\\r\\nif (password_callback(password, 1024, 1, &cb_tmp) > 0) {\\r\\nVERBOSE BIO_printf(bio,\\r\\n\"Creating\\n user=\\\"%s\\\"\\n g=\\\"%s\\\"\\n N=\\\"%s\\\"\\n\",\\r\\nuser, g, N);\\r\\nif (!\\r\\n(gNid =\\r\\nSRP_create_verifier(user, password, &salt, srp_verifier, N,\\r\\ng))) {\\r\\nBIO_printf(bio, \"Internal error creating SRP verifier\\n\");\\r\\n} else\\r\\n*srp_usersalt = salt;\\r\\nVVERBOSE BIO_printf(bio, \"gNid=%s salt =\\\"%s\\\"\\n verifier =\\\"%s\\\"\\n\",\\r\\ngNid, salt, *srp_verifier);\\r\\n}\\r\\nreturn gNid;\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nint add_user = 0;\\r\\nint list_user = 0;\\r\\nint delete_user = 0;\\r\\nint modify_user = 0;\\r\\nchar *user = NULL;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\nchar *gN = NULL;\\r\\nint gNindex = -1;\\r\\nchar **gNrow = NULL;\\r\\nint maxgN = -1;\\r\\nchar *userinfo = NULL;\\r\\nint badops = 0;\\r\\nint ret = 1;\\r\\nint errors = 0;\\r\\nint verbose = 0;\\r\\nint doupdatedb = 0;\\r\\nchar *configfile = NULL;\\r\\nchar *dbfile = NULL;\\r\\nCA_DB *db = NULL;\\r\\nchar **pp;\\r\\nint i;\\r\\nlong errorline = -1;\\r\\nchar *randfile = NULL;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n# endif\\r\\nchar *tofree = NULL;\\r\\nDB_ATTR db_attr;\\r\\n# ifdef EFENCE\\r\\nEF_PROTECT_FREE = 1;\\r\\nEF_PROTECT_BELOW = 1;\\r\\nEF_ALIGNMENT = 0;\\r\\n# endif\\r\\napps_startup();\\r\\nconf = NULL;\\r\\nsection = NULL;\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1 && badops == 0) {\\r\\nif (strcmp(*argv, \"-verbose\") == 0)\\r\\nverbose++;\\r\\nelse if (strcmp(*argv, \"-config\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nconfigfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-name\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsection = *(++argv);\\r\\n} else if (strcmp(*argv, \"-srpvfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ndbfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-add\") == 0)\\r\\nadd_user = 1;\\r\\nelse if (strcmp(*argv, \"-delete\") == 0)\\r\\ndelete_user = 1;\\r\\nelse if (strcmp(*argv, \"-modify\") == 0)\\r\\nmodify_user = 1;\\r\\nelse if (strcmp(*argv, \"-list\") == 0)\\r\\nlist_user = 1;\\r\\nelse if (strcmp(*argv, \"-gn\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ngN = *(++argv);\\r\\n} else if (strcmp(*argv, \"-userinfo\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nuserinfo = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passin\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passout\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargout = *(++argv);\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n# endif\\r\\nelse if (**argv == '-') {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n} else\\r\\nbreak;\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (dbfile && configfile) {\\r\\nBIO_printf(bio_err,\\r\\n\"-dbfile and -configfile cannot be specified together.\\n\");\\r\\nbadops = 1;\\r\\n}\\r\\nif (add_user + delete_user + modify_user + list_user != 1) {\\r\\nBIO_printf(bio_err,\\r\\n\"Exactly one of the options -add, -delete, -modify -list must be specified.\\n\");\\r\\nbadops = 1;\\r\\n}\\r\\nif (delete_user + modify_user + delete_user == 1 && argc <= 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"Need at least one user for options -add, -delete, -modify. \\n\");\\r\\nbadops = 1;\\r\\n}\\r\\nif ((passin || passout) && argc != 1) {\\r\\nBIO_printf(bio_err,\\r\\n\"-passin, -passout arguments only valid with one user.\\n\");\\r\\nbadops = 1;\\r\\n}\\r\\nif (badops) {\\r\\nfor (pp = srp_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err, \"%s\", *pp);\\r\\nBIO_printf(bio_err, \" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\\r\\n\" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\ngoto err;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (!dbfile) {\\r\\ntofree = NULL;\\r\\nif (configfile == NULL)\\r\\nconfigfile = getenv(\"OPENSSL_CONF\");\\r\\nif (configfile == NULL)\\r\\nconfigfile = getenv(\"SSLEAY_CONF\");\\r\\nif (configfile == NULL) {\\r\\nconst char *s = X509_get_default_cert_area();\\r\\nsize_t len;\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\nlen = strlen(s) + sizeof(CONFIG_FILE);\\r\\ntofree = OPENSSL_malloc(len);\\r\\nstrcpy(tofree, s);\\r\\n# else\\r\\nlen = strlen(s) + sizeof(CONFIG_FILE) + 1;\\r\\ntofree = OPENSSL_malloc(len);\\r\\nBUF_strlcpy(tofree, s, len);\\r\\nBUF_strlcat(tofree, \"/\", len);\\r\\n# endif\\r\\nBUF_strlcat(tofree, CONFIG_FILE, len);\\r\\nconfigfile = tofree;\\r\\n}\\r\\nVERBOSE BIO_printf(bio_err, \"Using configuration from %s\\n\",\\r\\nconfigfile);\\r\\nconf = NCONF_new(NULL);\\r\\nif (NCONF_load(conf, configfile, &errorline) <= 0) {\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err, \"error loading the config file '%s'\\n\",\\r\\nconfigfile);\\r\\nelse\\r\\nBIO_printf(bio_err, \"error on line %ld of config file '%s'\\n\",\\r\\nerrorline, configfile);\\r\\ngoto err;\\r\\n}\\r\\nif (tofree) {\\r\\nOPENSSL_free(tofree);\\r\\ntofree = NULL;\\r\\n}\\r\\nif (!load_config(bio_err, conf))\\r\\ngoto err;\\r\\nif (section == NULL) {\\r\\nVERBOSE BIO_printf(bio_err,\\r\\n\"trying to read \" ENV_DEFAULT_SRP\\r\\n\" in \\\" BASE_SECTION \\\"\\n\");\\r\\nsection = NCONF_get_string(conf, BASE_SECTION, ENV_DEFAULT_SRP);\\r\\nif (section == NULL) {\\r\\nlookup_fail(BASE_SECTION, ENV_DEFAULT_SRP);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (randfile == NULL && conf)\\r\\nrandfile = NCONF_get_string(conf, BASE_SECTION, \"RANDFILE\");\\r\\nVERBOSE BIO_printf(bio_err,\\r\\n\"trying to read \" ENV_DATABASE\\r\\n\" in section \\\"%s\\\"\\n\", section);\\r\\nif ((dbfile = NCONF_get_string(conf, section, ENV_DATABASE)) == NULL) {\\r\\nlookup_fail(section, ENV_DATABASE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (randfile == NULL)\\r\\nERR_clear_error();\\r\\nelse\\r\\napp_RAND_load_file(randfile, bio_err, 0);\\r\\nVERBOSE BIO_printf(bio_err, \"Trying to read SRP verifier file \\\"%s\\\"\\n\",\\r\\ndbfile);\\r\\ndb = load_index(dbfile, &db_attr);\\r\\nif (db == NULL)\\r\\ngoto err;\\r\\nfor (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\\r\\npp = sk_OPENSSL_PSTRING_value(db->db->data, i);\\r\\nif (pp[DB_srptype][0] == DB_SRP_INDEX) {\\r\\nmaxgN = i;\\r\\nif (gNindex < 0 && gN != NULL && !strcmp(gN, pp[DB_srpid]))\\r\\ngNindex = i;\\r\\nprint_index(db, bio_err, i, verbose > 1);\\r\\n}\\r\\n}\\r\\nVERBOSE BIO_printf(bio_err, \"Database initialised\\n\");\\r\\nif (gNindex >= 0) {\\r\\ngNrow = sk_OPENSSL_PSTRING_value(db->db->data, gNindex);\\r\\nprint_entry(db, bio_err, gNindex, verbose > 1, \"Default g and N\");\\r\\n} else if (maxgN > 0 && !SRP_get_default_gN(gN)) {\\r\\nBIO_printf(bio_err, \"No g and N value for index \\\"%s\\\"\\n\", gN);\\r\\ngoto err;\\r\\n} else {\\r\\nVERBOSE BIO_printf(bio_err, \"Database has no g N information.\\n\");\\r\\ngNrow = NULL;\\r\\n}\\r\\nVVERBOSE BIO_printf(bio_err, \"Starting user processing\\n\");\\r\\nif (argc > 0)\\r\\nuser = *(argv++);\\r\\nwhile (list_user || user) {\\r\\nint userindex = -1;\\r\\nif (user)\\r\\nVVERBOSE BIO_printf(bio_err, \"Processing user \\\"%s\\\"\\n\", user);\\r\\nif ((userindex = get_index(db, user, 'U')) >= 0) {\\r\\nprint_user(db, bio_err, userindex, (verbose > 0) || list_user);\\r\\n}\\r\\nif (list_user) {\\r\\nif (user == NULL) {\\r\\nBIO_printf(bio_err, \"List all users\\n\");\\r\\nfor (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\\r\\nprint_user(db, bio_err, i, 1);\\r\\n}\\r\\nlist_user = 0;\\r\\n} else if (userindex < 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"user \\\"%s\\\" does not exist, ignored. t\\n\", user);\\r\\nerrors++;\\r\\n}\\r\\n} else if (add_user) {\\r\\nif (userindex >= 0) {\\r\\nchar **row =\\r\\nsk_OPENSSL_PSTRING_value(db->db->data, userindex);\\r\\nBIO_printf(bio_err, \"user \\\"%s\\\" reactivated.\\n\", user);\\r\\nrow[DB_srptype][0] = 'V';\\r\\ndoupdatedb = 1;\\r\\n} else {\\r\\nchar *row[DB_NUMBER];\\r\\nchar *gNid;\\r\\nrow[DB_srpverifier] = NULL;\\r\\nrow[DB_srpsalt] = NULL;\\r\\nrow[DB_srpinfo] = NULL;\\r\\nif (!\\r\\n(gNid =\\r\\nsrp_create_user(user, &(row[DB_srpverifier]),\\r\\n&(row[DB_srpsalt]),\\r\\ngNrow ? gNrow[DB_srpsalt] : gN,\\r\\ngNrow ? gNrow[DB_srpverifier] : NULL,\\r\\npassout, bio_err, verbose))) {\\r\\nBIO_printf(bio_err,\\r\\n\"Cannot create srp verifier for user \\\"%s\\\", operation abandoned .\\n\",\\r\\nuser);\\r\\nerrors++;\\r\\ngoto err;\\r\\n}\\r\\nrow[DB_srpid] = BUF_strdup(user);\\r\\nrow[DB_srptype] = BUF_strdup(\"v\");\\r\\nrow[DB_srpgN] = BUF_strdup(gNid);\\r\\nif (!row[DB_srpid] || !row[DB_srpgN] || !row[DB_srptype]\\r\\n|| !row[DB_srpverifier] || !row[DB_srpsalt] || (userinfo\\r\\n&&\\r\\n(!(row\\r\\n[DB_srpinfo]\\r\\n=\\r\\nBUF_strdup\\r\\n(userinfo))))\\r\\n|| !update_index(db, bio_err, row)) {\\r\\nif (row[DB_srpid])\\r\\nOPENSSL_free(row[DB_srpid]);\\r\\nif (row[DB_srpgN])\\r\\nOPENSSL_free(row[DB_srpgN]);\\r\\nif (row[DB_srpinfo])\\r\\nOPENSSL_free(row[DB_srpinfo]);\\r\\nif (row[DB_srptype])\\r\\nOPENSSL_free(row[DB_srptype]);\\r\\nif (row[DB_srpverifier])\\r\\nOPENSSL_free(row[DB_srpverifier]);\\r\\nif (row[DB_srpsalt])\\r\\nOPENSSL_free(row[DB_srpsalt]);\\r\\ngoto err;\\r\\n}\\r\\ndoupdatedb = 1;\\r\\n}\\r\\n} else if (modify_user) {\\r\\nif (userindex < 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"user \\\"%s\\\" does not exist, operation ignored.\\n\",\\r\\nuser);\\r\\nerrors++;\\r\\n} else {\\r\\nchar **row =\\r\\nsk_OPENSSL_PSTRING_value(db->db->data, userindex);\\r\\nchar type = row[DB_srptype][0];\\r\\nif (type == 'v') {\\r\\nBIO_printf(bio_err,\\r\\n\"user \\\"%s\\\" already updated, operation ignored.\\n\",\\r\\nuser);\\r\\nerrors++;\\r\\n} else {\\r\\nchar *gNid;\\r\\nif (row[DB_srptype][0] == 'V') {\\r\\nint user_gN;\\r\\nchar **irow = NULL;\\r\\nVERBOSE BIO_printf(bio_err,\\r\\n\"Verifying password for user \\\"%s\\\"\\n\",\\r\\nuser);\\r\\nif ((user_gN =\\r\\nget_index(db, row[DB_srpgN], DB_SRP_INDEX)) >= 0)\\r\\nirow =\\r\\n(char **)sk_OPENSSL_PSTRING_value(db->\\r\\ndb->data,\\r\\nuserindex);\\r\\nif (!srp_verify_user\\r\\n(user, row[DB_srpverifier], row[DB_srpsalt],\\r\\nirow ? irow[DB_srpsalt] : row[DB_srpgN],\\r\\nirow ? irow[DB_srpverifier] : NULL, passin,\\r\\nbio_err, verbose)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Invalid password for user \\\"%s\\\", operation abandoned.\\n\",\\r\\nuser);\\r\\nerrors++;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nVERBOSE BIO_printf(bio_err,\\r\\n\"Password for user \\\"%s\\\" ok.\\n\",\\r\\nuser);\\r\\nif (!\\r\\n(gNid =\\r\\nsrp_create_user(user, &(row[DB_srpverifier]),\\r\\n&(row[DB_srpsalt]),\\r\\ngNrow ? gNrow[DB_srpsalt] : NULL,\\r\\ngNrow ? gNrow[DB_srpverifier] : NULL,\\r\\npassout, bio_err, verbose))) {\\r\\nBIO_printf(bio_err,\\r\\n\"Cannot create srp verifier for user \\\"%s\\\", operation abandoned.\\n\",\\r\\nuser);\\r\\nerrors++;\\r\\ngoto err;\\r\\n}\\r\\nrow[DB_srptype][0] = 'v';\\r\\nrow[DB_srpgN] = BUF_strdup(gNid);\\r\\nif (!row[DB_srpid] || !row[DB_srpgN] || !row[DB_srptype]\\r\\n|| !row[DB_srpverifier] || !row[DB_srpsalt]\\r\\n|| (userinfo\\r\\n&& (!(row[DB_srpinfo] = BUF_strdup(userinfo)))))\\r\\ngoto err;\\r\\ndoupdatedb = 1;\\r\\n}\\r\\n}\\r\\n} else if (delete_user) {\\r\\nif (userindex < 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"user \\\"%s\\\" does not exist, operation ignored. t\\n\",\\r\\nuser);\\r\\nerrors++;\\r\\n} else {\\r\\nchar **xpp =\\r\\nsk_OPENSSL_PSTRING_value(db->db->data, userindex);\\r\\nBIO_printf(bio_err, \"user \\\"%s\\\" revoked. t\\n\", user);\\r\\nxpp[DB_srptype][0] = 'R';\\r\\ndoupdatedb = 1;\\r\\n}\\r\\n}\\r\\nif (--argc > 0)\\r\\nuser = *(argv++);\\r\\nelse {\\r\\nuser = NULL;\\r\\nlist_user = 0;\\r\\n}\\r\\n}\\r\\nVERBOSE BIO_printf(bio_err, \"User procession done.\\n\");\\r\\nif (doupdatedb) {\\r\\nfor (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\\r\\npp = sk_OPENSSL_PSTRING_value(db->db->data, i);\\r\\nif (pp[DB_srptype][0] == 'v') {\\r\\npp[DB_srptype][0] = 'V';\\r\\nprint_user(db, bio_err, i, verbose);\\r\\n}\\r\\n}\\r\\nVERBOSE BIO_printf(bio_err, \"Trying to update srpvfile.\\n\");\\r\\nif (!save_index(dbfile, \"new\", db))\\r\\ngoto err;\\r\\nVERBOSE BIO_printf(bio_err, \"Temporary srpvfile created.\\n\");\\r\\nif (!rotate_index(dbfile, \"new\", \"old\"))\\r\\ngoto err;\\r\\nVERBOSE BIO_printf(bio_err, \"srpvfile updated.\\n\");\\r\\n}\\r\\nret = (errors != 0);\\r\\nerr:\\r\\nif (errors != 0)\\r\\nVERBOSE BIO_printf(bio_err, \"User errors %d.\\n\", errors);\\r\\nVERBOSE BIO_printf(bio_err, \"SRP terminating with code %d.\\n\", ret);\\r\\nif (tofree)\\r\\nOPENSSL_free(tofree);\\r\\nif (ret)\\r\\nERR_print_errors(bio_err);\\r\\nif (randfile)\\r\\napp_RAND_write_file(randfile, bio_err);\\r\\nif (conf)\\r\\nNCONF_free(conf);\\r\\nif (db)\\r\\nfree_index(db);\\r\\nOBJ_cleanup();\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_evp_pkey_c", "target": 0, "func": "EVP_PKEY *EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nEVP_PKEY *pkey = NULL;\\r\\nASN1_OBJECT *algoid;\\r\\nchar obj_tmp[80];\\r\\nif (!PKCS8_pkey_get0(&algoid, NULL, NULL, NULL, p8))\\r\\nreturn NULL;\\r\\nif (!(pkey = EVP_PKEY_new())) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!EVP_PKEY_set_type(pkey, OBJ_obj2nid(algoid))) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);\\r\\ni2t_ASN1_OBJECT(obj_tmp, 80, algoid);\\r\\nERR_add_error_data(2, \"TYPE=\", obj_tmp);\\r\\ngoto error;\\r\\n}\\r\\nif (pkey->ameth->priv_decode) {\\r\\nif (!pkey->ameth->priv_decode(pkey, p8)) {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_PRIVATE_KEY_DECODE_ERROR);\\r\\ngoto error;\\r\\n}\\r\\n} else {\\r\\nEVPerr(EVP_F_EVP_PKCS82PKEY, EVP_R_METHOD_NOT_SUPPORTED);\\r\\ngoto error;\\r\\n}\\r\\nreturn pkey;\\r\\nerror:\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn NULL;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey)\\r\\n{\\r\\nreturn EVP_PKEY2PKCS8_broken(pkey, PKCS8_OK);\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8_broken(EVP_PKEY *pkey, int broken)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nif (!(p8 = PKCS8_PRIV_KEY_INFO_new())) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\np8->broken = broken;\\r\\nif (pkey->ameth) {\\r\\nif (pkey->ameth->priv_encode) {\\r\\nif (!pkey->ameth->priv_encode(p8, pkey)) {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,\\r\\nEVP_R_PRIVATE_KEY_ENCODE_ERROR);\\r\\ngoto error;\\r\\n}\\r\\n} else {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN, EVP_R_METHOD_NOT_SUPPORTED);\\r\\ngoto error;\\r\\n}\\r\\n} else {\\r\\nEVPerr(EVP_F_EVP_PKEY2PKCS8_BROKEN,\\r\\nEVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM);\\r\\ngoto error;\\r\\n}\\r\\nRAND_add(p8->pkey->value.octet_string->data,\\r\\np8->pkey->value.octet_string->length, 0.0);\\r\\nreturn p8;\\r\\nerror:\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nreturn NULL;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *PKCS8_set_broken(PKCS8_PRIV_KEY_INFO *p8, int broken)\\r\\n{\\r\\nswitch (broken) {\\r\\ncase PKCS8_OK:\\r\\np8->broken = PKCS8_OK;\\r\\nreturn p8;\\r\\nbreak;\\r\\ncase PKCS8_NO_OCTET:\\r\\np8->broken = PKCS8_NO_OCTET;\\r\\np8->pkey->type = V_ASN1_SEQUENCE;\\r\\nreturn p8;\\r\\nbreak;\\r\\ndefault:\\r\\nEVPerr(EVP_F_PKCS8_SET_BROKEN, EVP_R_PKCS8_UNKNOWN_BROKEN_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nint EVP_PKEY_get_attr_count(const EVP_PKEY *key)\\r\\n{\\r\\nreturn X509at_get_attr_count(key->attributes);\\r\\n}\\r\\nint EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid, int lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_NID(key->attributes, nid, lastpos);\\r\\n}\\r\\nint EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_OBJ(key->attributes, obj, lastpos);\\r\\n}\\r\\nX509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *key, int loc)\\r\\n{\\r\\nreturn X509at_get_attr(key->attributes, loc);\\r\\n}\\r\\nX509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *key, int loc)\\r\\n{\\r\\nreturn X509at_delete_attr(key->attributes, loc);\\r\\n}\\r\\nint EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif (X509at_add1_attr(&key->attributes, attr))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key,\\r\\nconst ASN1_OBJECT *obj, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_OBJ(&key->attributes, obj, type, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key,\\r\\nint nid, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&key->attributes, nid, type, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key,\\r\\nconst char *attrname, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_txt(&key->attributes, attrname, type, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_smsign_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL;\\r\\nX509 *scert = NULL;\\r\\nEVP_PKEY *skey = NULL;\\r\\nPKCS7 *p7 = NULL;\\r\\nint ret = 1;\\r\\nint flags = PKCS7_DETACHED | PKCS7_STREAM;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\ntbio = BIO_new_file(\"signer.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nscert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nBIO_reset(tbio);\\r\\nskey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);\\r\\nif (!scert || !skey)\\r\\ngoto err;\\r\\nin = BIO_new_file(\"sign.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\np7 = PKCS7_sign(scert, skey, NULL, in, flags);\\r\\nif (!p7)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smout.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!(flags & PKCS7_STREAM))\\r\\nBIO_reset(in);\\r\\nif (!SMIME_write_PKCS7(out, p7, in, flags))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Signing Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (p7)\\r\\nPKCS7_free(p7);\\r\\nif (scert)\\r\\nX509_free(scert);\\r\\nif (skey)\\r\\nEVP_PKEY_free(skey);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pcy_data_c", "target": 0, "func": "void policy_data_free(X509_POLICY_DATA *data)\\r\\n{\\r\\nASN1_OBJECT_free(data->valid_policy);\\r\\nif (!(data->flags & POLICY_DATA_FLAG_SHARED_QUALIFIERS))\\r\\nsk_POLICYQUALINFO_pop_free(data->qualifier_set, POLICYQUALINFO_free);\\r\\nsk_ASN1_OBJECT_pop_free(data->expected_policy_set, ASN1_OBJECT_free);\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nX509_POLICY_DATA *policy_data_new(POLICYINFO *policy,\\r\\nconst ASN1_OBJECT *cid, int crit)\\r\\n{\\r\\nX509_POLICY_DATA *ret;\\r\\nASN1_OBJECT *id;\\r\\nif (!policy && !cid)\\r\\nreturn NULL;\\r\\nif (cid) {\\r\\nid = OBJ_dup(cid);\\r\\nif (!id)\\r\\nreturn NULL;\\r\\n} else\\r\\nid = NULL;\\r\\nret = OPENSSL_malloc(sizeof(X509_POLICY_DATA));\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nret->expected_policy_set = sk_ASN1_OBJECT_new_null();\\r\\nif (!ret->expected_policy_set) {\\r\\nOPENSSL_free(ret);\\r\\nif (id)\\r\\nASN1_OBJECT_free(id);\\r\\nreturn NULL;\\r\\n}\\r\\nif (crit)\\r\\nret->flags = POLICY_DATA_FLAG_CRITICAL;\\r\\nelse\\r\\nret->flags = 0;\\r\\nif (id)\\r\\nret->valid_policy = id;\\r\\nelse {\\r\\nret->valid_policy = policy->policyid;\\r\\npolicy->policyid = NULL;\\r\\n}\\r\\nif (policy) {\\r\\nret->qualifier_set = policy->qualifiers;\\r\\npolicy->qualifiers = NULL;\\r\\n} else\\r\\nret->qualifier_set = NULL;\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rand_lib_c", "target": 1, "func": "int RAND_set_rand_method(const RAND_METHOD *meth)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (funct_ref) {\\r\\nENGINE_finish(funct_ref);\\r\\nfunct_ref = NULL;\\r\\n}\\r\\n#endif\\r\\ndefault_RAND_meth = meth;\\r\\nreturn 1;\\r\\n}\\r\\nconst RAND_METHOD *RAND_get_rand_method(void)\\r\\n{\\r\\nif (!default_RAND_meth) {\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = ENGINE_get_default_RAND();\\r\\nif (e) {\\r\\ndefault_RAND_meth = ENGINE_get_RAND(e);\\r\\nif (!default_RAND_meth) {\\r\\nENGINE_finish(e);\\r\\ne = NULL;\\r\\n}\\r\\n}\\r\\nif (e)\\r\\nfunct_ref = e;\\r\\nelse\\r\\n#endif\\r\\ndefault_RAND_meth = RAND_SSLeay();\\r\\n}\\r\\nreturn default_RAND_meth;\\r\\n}\\r\\nint RAND_set_rand_engine(ENGINE *engine)\\r\\n{\\r\\nconst RAND_METHOD *tmp_meth = NULL;\\r\\nif (engine) {\\r\\nif (!ENGINE_init(engine))\\r\\nreturn 0;\\r\\ntmp_meth = ENGINE_get_RAND(engine);\\r\\nif (!tmp_meth) {\\r\\nENGINE_finish(engine);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nRAND_set_rand_method(tmp_meth);\\r\\nfunct_ref = engine;\\r\\nreturn 1;\\r\\n}\\r\\nvoid RAND_cleanup(void)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->cleanup)\\r\\nmeth->cleanup();\\r\\nRAND_set_rand_method(NULL);\\r\\n}\\r\\nvoid RAND_seed(const void *buf, int num)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->seed)\\r\\nmeth->seed(buf, num);\\r\\n}\\r\\nvoid RAND_add(const void *buf, int num, double entropy)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->add)\\r\\nmeth->add(buf, num, entropy);\\r\\n}\\r\\nint RAND_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->bytes)\\r\\nreturn meth->bytes(buf, num);\\r\\nreturn (-1);\\r\\n}\\r\\nint RAND_pseudo_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->pseudorand)\\r\\nreturn meth->pseudorand(buf, num);\\r\\nreturn (-1);\\r\\n}\\r\\nint RAND_status(void)\\r\\n{\\r\\nconst RAND_METHOD *meth = RAND_get_rand_method();\\r\\nif (meth && meth->status)\\r\\nreturn meth->status();\\r\\nreturn 0;\\r\\n}\\r\\nstatic size_t drbg_get_entropy(DRBG_CTX *ctx, unsigned char **pout,\\r\\nint entropy, size_t min_len, size_t max_len)\\r\\n{\\r\\nmin_len = ((min_len + 19) / 20) * 20;\\r\\n*pout = OPENSSL_malloc(min_len);\\r\\nif (!*pout)\\r\\nreturn 0;\\r\\nif (ssleay_rand_bytes(*pout, min_len, 0, 0) <= 0) {\\r\\nOPENSSL_free(*pout);\\r\\n*pout = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nreturn min_len;\\r\\n}\\r\\nstatic void drbg_free_entropy(DRBG_CTX *ctx, unsigned char *out, size_t olen)\\r\\n{\\r\\nif (out) {\\r\\nOPENSSL_cleanse(out, olen);\\r\\nOPENSSL_free(out);\\r\\n}\\r\\n}\\r\\nstatic size_t drbg_get_adin(DRBG_CTX *ctx, unsigned char **pout)\\r\\n{\\r\\nstatic unsigned char buf[16];\\r\\nstatic unsigned long counter;\\r\\nFIPS_get_timevec(buf, &counter);\\r\\n*pout = buf;\\r\\nreturn sizeof(buf);\\r\\n}\\r\\nstatic int drbg_rand_add(DRBG_CTX *ctx, const void *in, int inlen,\\r\\ndouble entropy)\\r\\n{\\r\\nRAND_SSLeay()->add(in, inlen, entropy);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int drbg_rand_seed(DRBG_CTX *ctx, const void *in, int inlen)\\r\\n{\\r\\nRAND_SSLeay()->seed(in, inlen);\\r\\nreturn 1;\\r\\n}\\r\\nvoid RAND_set_fips_drbg_type(int type, int flags)\\r\\n{\\r\\nfips_drbg_type = type;\\r\\nfips_drbg_flags = flags;\\r\\n}\\r\\nint RAND_init_fips(void)\\r\\n{\\r\\nDRBG_CTX *dctx;\\r\\nsize_t plen;\\r\\nunsigned char pers[32], *p;\\r\\n# ifndef OPENSSL_ALLOW_DUAL_EC_DRBG\\r\\nif (fips_drbg_type >> 16) {\\r\\nRANDerr(RAND_F_RAND_INIT_FIPS, RAND_R_DUAL_EC_DRBG_DISABLED);\\r\\nreturn 0;\\r\\n}\\r\\n# endif\\r\\ndctx = FIPS_get_default_drbg();\\r\\nif (FIPS_drbg_init(dctx, fips_drbg_type, fips_drbg_flags) <= 0) {\\r\\nRANDerr(RAND_F_RAND_INIT_FIPS, RAND_R_ERROR_INITIALISING_DRBG);\\r\\nreturn 0;\\r\\n}\\r\\nFIPS_drbg_set_callbacks(dctx,\\r\\ndrbg_get_entropy, drbg_free_entropy, 20,\\r\\ndrbg_get_entropy, drbg_free_entropy);\\r\\nFIPS_drbg_set_rand_callbacks(dctx, drbg_get_adin, 0,\\r\\ndrbg_rand_seed, drbg_rand_add);\\r\\nstrcpy((char *)pers, \"OpenSSL DRBG2.0\");\\r\\nplen = drbg_get_adin(dctx, &p);\\r\\nmemcpy(pers + 16, p, plen);\\r\\nif (FIPS_drbg_instantiate(dctx, pers, sizeof(pers)) <= 0) {\\r\\nRANDerr(RAND_F_RAND_INIT_FIPS, RAND_R_ERROR_INSTANTIATING_DRBG);\\r\\nreturn 0;\\r\\n}\\r\\nFIPS_rand_set_method(FIPS_drbg_method());\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_asm_c", "target": 0, "func": "BN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num,\\r\\nBN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1 = 0;\\r\\nassert(num >= 0);\\r\\nif (num <= 0)\\r\\nreturn (c1);\\r\\n# ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nwhile (num & ~3) {\\r\\nmul_add(rp[0], ap[0], w, c1);\\r\\nmul_add(rp[1], ap[1], w, c1);\\r\\nmul_add(rp[2], ap[2], w, c1);\\r\\nmul_add(rp[3], ap[3], w, c1);\\r\\nap += 4;\\r\\nrp += 4;\\r\\nnum -= 4;\\r\\n}\\r\\n# endif\\r\\nwhile (num) {\\r\\nmul_add(rp[0], ap[0], w, c1);\\r\\nap++;\\r\\nrp++;\\r\\nnum--;\\r\\n}\\r\\nreturn (c1);\\r\\n}\\r\\nBN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG c1 = 0;\\r\\nassert(num >= 0);\\r\\nif (num <= 0)\\r\\nreturn (c1);\\r\\n# ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nwhile (num & ~3) {\\r\\nmul(rp[0], ap[0], w, c1);\\r\\nmul(rp[1], ap[1], w, c1);\\r\\nmul(rp[2], ap[2], w, c1);\\r\\nmul(rp[3], ap[3], w, c1);\\r\\nap += 4;\\r\\nrp += 4;\\r\\nnum -= 4;\\r\\n}\\r\\n# endif\\r\\nwhile (num) {\\r\\nmul(rp[0], ap[0], w, c1);\\r\\nap++;\\r\\nrp++;\\r\\nnum--;\\r\\n}\\r\\nreturn (c1);\\r\\n}\\r\\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\\r\\n{\\r\\nassert(n >= 0);\\r\\nif (n <= 0)\\r\\nreturn;\\r\\n# ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nwhile (n & ~3) {\\r\\nsqr(r[0], r[1], a[0]);\\r\\nsqr(r[2], r[3], a[1]);\\r\\nsqr(r[4], r[5], a[2]);\\r\\nsqr(r[6], r[7], a[3]);\\r\\na += 4;\\r\\nr += 8;\\r\\nn -= 4;\\r\\n}\\r\\n# endif\\r\\nwhile (n) {\\r\\nsqr(r[0], r[1], a[0]);\\r\\na++;\\r\\nr += 2;\\r\\nn--;\\r\\n}\\r\\n}\\r\\nBN_ULONG bn_mul_add_words(BN_ULONG *rp, const BN_ULONG *ap, int num,\\r\\nBN_ULONG w)\\r\\n{\\r\\nBN_ULONG c = 0;\\r\\nBN_ULONG bl, bh;\\r\\nassert(num >= 0);\\r\\nif (num <= 0)\\r\\nreturn ((BN_ULONG)0);\\r\\nbl = LBITS(w);\\r\\nbh = HBITS(w);\\r\\n# ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nwhile (num & ~3) {\\r\\nmul_add(rp[0], ap[0], bl, bh, c);\\r\\nmul_add(rp[1], ap[1], bl, bh, c);\\r\\nmul_add(rp[2], ap[2], bl, bh, c);\\r\\nmul_add(rp[3], ap[3], bl, bh, c);\\r\\nap += 4;\\r\\nrp += 4;\\r\\nnum -= 4;\\r\\n}\\r\\n# endif\\r\\nwhile (num) {\\r\\nmul_add(rp[0], ap[0], bl, bh, c);\\r\\nap++;\\r\\nrp++;\\r\\nnum--;\\r\\n}\\r\\nreturn (c);\\r\\n}\\r\\nBN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG carry = 0;\\r\\nBN_ULONG bl, bh;\\r\\nassert(num >= 0);\\r\\nif (num <= 0)\\r\\nreturn ((BN_ULONG)0);\\r\\nbl = LBITS(w);\\r\\nbh = HBITS(w);\\r\\n# ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nwhile (num & ~3) {\\r\\nmul(rp[0], ap[0], bl, bh, carry);\\r\\nmul(rp[1], ap[1], bl, bh, carry);\\r\\nmul(rp[2], ap[2], bl, bh, carry);\\r\\nmul(rp[3], ap[3], bl, bh, carry);\\r\\nap += 4;\\r\\nrp += 4;\\r\\nnum -= 4;\\r\\n}\\r\\n# endif\\r\\nwhile (num) {\\r\\nmul(rp[0], ap[0], bl, bh, carry);\\r\\nap++;\\r\\nrp++;\\r\\nnum--;\\r\\n}\\r\\nreturn (carry);\\r\\n}\\r\\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\\r\\n{\\r\\nassert(n >= 0);\\r\\nif (n <= 0)\\r\\nreturn;\\r\\n# ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nwhile (n & ~3) {\\r\\nsqr64(r[0], r[1], a[0]);\\r\\nsqr64(r[2], r[3], a[1]);\\r\\nsqr64(r[4], r[5], a[2]);\\r\\nsqr64(r[6], r[7], a[3]);\\r\\na += 4;\\r\\nr += 8;\\r\\nn -= 4;\\r\\n}\\r\\n# endif\\r\\nwhile (n) {\\r\\nsqr64(r[0], r[1], a[0]);\\r\\na++;\\r\\nr += 2;\\r\\nn--;\\r\\n}\\r\\n}\\r\\nBN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)\\r\\n{\\r\\nreturn ((BN_ULONG)(((((BN_ULLONG) h) << BN_BITS2) | l) / (BN_ULLONG) d));\\r\\n}\\r\\nBN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d)\\r\\n{\\r\\nBN_ULONG dh, dl, q, ret = 0, th, tl, t;\\r\\nint i, count = 2;\\r\\nif (d == 0)\\r\\nreturn (BN_MASK2);\\r\\ni = BN_num_bits_word(d);\\r\\nassert((i == BN_BITS2) || (h <= (BN_ULONG)1 << i));\\r\\ni = BN_BITS2 - i;\\r\\nif (h >= d)\\r\\nh -= d;\\r\\nif (i) {\\r\\nd <<= i;\\r\\nh = (h << i) | (l >> (BN_BITS2 - i));\\r\\nl <<= i;\\r\\n}\\r\\ndh = (d & BN_MASK2h) >> BN_BITS4;\\r\\ndl = (d & BN_MASK2l);\\r\\nfor (;;) {\\r\\nif ((h >> BN_BITS4) == dh)\\r\\nq = BN_MASK2l;\\r\\nelse\\r\\nq = h / dh;\\r\\nth = q * dh;\\r\\ntl = dl * q;\\r\\nfor (;;) {\\r\\nt = h - th;\\r\\nif ((t & BN_MASK2h) ||\\r\\n((tl) <= ((t << BN_BITS4) | ((l & BN_MASK2h) >> BN_BITS4))))\\r\\nbreak;\\r\\nq--;\\r\\nth -= dh;\\r\\ntl -= dl;\\r\\n}\\r\\nt = (tl >> BN_BITS4);\\r\\ntl = (tl << BN_BITS4) & BN_MASK2h;\\r\\nth += t;\\r\\nif (l < tl)\\r\\nth++;\\r\\nl -= tl;\\r\\nif (h < th) {\\r\\nh += d;\\r\\nq--;\\r\\n}\\r\\nh -= th;\\r\\nif (--count == 0)\\r\\nbreak;\\r\\nret = q << BN_BITS4;\\r\\nh = ((h << BN_BITS4) | (l >> BN_BITS4)) & BN_MASK2;\\r\\nl = (l & BN_MASK2l) << BN_BITS4;\\r\\n}\\r\\nret |= q;\\r\\nreturn (ret);\\r\\n}\\r\\nBN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\\r\\nint n)\\r\\n{\\r\\nBN_ULLONG ll = 0;\\r\\nassert(n >= 0);\\r\\nif (n <= 0)\\r\\nreturn ((BN_ULONG)0);\\r\\n# ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nwhile (n & ~3) {\\r\\nll += (BN_ULLONG) a[0] + b[0];\\r\\nr[0] = (BN_ULONG)ll & BN_MASK2;\\r\\nll >>= BN_BITS2;\\r\\nll += (BN_ULLONG) a[1] + b[1];\\r\\nr[1] = (BN_ULONG)ll & BN_MASK2;\\r\\nll >>= BN_BITS2;\\r\\nll += (BN_ULLONG) a[2] + b[2];\\r\\nr[2] = (BN_ULONG)ll & BN_MASK2;\\r\\nll >>= BN_BITS2;\\r\\nll += (BN_ULLONG) a[3] + b[3];\\r\\nr[3] = (BN_ULONG)ll & BN_MASK2;\\r\\nll >>= BN_BITS2;\\r\\na += 4;\\r\\nb += 4;\\r\\nr += 4;\\r\\nn -= 4;\\r\\n}\\r\\n# endif\\r\\nwhile (n) {\\r\\nll += (BN_ULLONG) a[0] + b[0];\\r\\nr[0] = (BN_ULONG)ll & BN_MASK2;\\r\\nll >>= BN_BITS2;\\r\\na++;\\r\\nb++;\\r\\nr++;\\r\\nn--;\\r\\n}\\r\\nreturn ((BN_ULONG)ll);\\r\\n}\\r\\nBN_ULONG bn_add_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\\r\\nint n)\\r\\n{\\r\\nBN_ULONG c, l, t;\\r\\nassert(n >= 0);\\r\\nif (n <= 0)\\r\\nreturn ((BN_ULONG)0);\\r\\nc = 0;\\r\\n# ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nwhile (n & ~3) {\\r\\nt = a[0];\\r\\nt = (t + c) & BN_MASK2;\\r\\nc = (t < c);\\r\\nl = (t + b[0]) & BN_MASK2;\\r\\nc += (l < t);\\r\\nr[0] = l;\\r\\nt = a[1];\\r\\nt = (t + c) & BN_MASK2;\\r\\nc = (t < c);\\r\\nl = (t + b[1]) & BN_MASK2;\\r\\nc += (l < t);\\r\\nr[1] = l;\\r\\nt = a[2];\\r\\nt = (t + c) & BN_MASK2;\\r\\nc = (t < c);\\r\\nl = (t + b[2]) & BN_MASK2;\\r\\nc += (l < t);\\r\\nr[2] = l;\\r\\nt = a[3];\\r\\nt = (t + c) & BN_MASK2;\\r\\nc = (t < c);\\r\\nl = (t + b[3]) & BN_MASK2;\\r\\nc += (l < t);\\r\\nr[3] = l;\\r\\na += 4;\\r\\nb += 4;\\r\\nr += 4;\\r\\nn -= 4;\\r\\n}\\r\\n# endif\\r\\nwhile (n) {\\r\\nt = a[0];\\r\\nt = (t + c) & BN_MASK2;\\r\\nc = (t < c);\\r\\nl = (t + b[0]) & BN_MASK2;\\r\\nc += (l < t);\\r\\nr[0] = l;\\r\\na++;\\r\\nb++;\\r\\nr++;\\r\\nn--;\\r\\n}\\r\\nreturn ((BN_ULONG)c);\\r\\n}\\r\\nBN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\\r\\nint n)\\r\\n{\\r\\nBN_ULONG t1, t2;\\r\\nint c = 0;\\r\\nassert(n >= 0);\\r\\nif (n <= 0)\\r\\nreturn ((BN_ULONG)0);\\r\\n#ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nwhile (n & ~3) {\\r\\nt1 = a[0];\\r\\nt2 = b[0];\\r\\nr[0] = (t1 - t2 - c) & BN_MASK2;\\r\\nif (t1 != t2)\\r\\nc = (t1 < t2);\\r\\nt1 = a[1];\\r\\nt2 = b[1];\\r\\nr[1] = (t1 - t2 - c) & BN_MASK2;\\r\\nif (t1 != t2)\\r\\nc = (t1 < t2);\\r\\nt1 = a[2];\\r\\nt2 = b[2];\\r\\nr[2] = (t1 - t2 - c) & BN_MASK2;\\r\\nif (t1 != t2)\\r\\nc = (t1 < t2);\\r\\nt1 = a[3];\\r\\nt2 = b[3];\\r\\nr[3] = (t1 - t2 - c) & BN_MASK2;\\r\\nif (t1 != t2)\\r\\nc = (t1 < t2);\\r\\na += 4;\\r\\nb += 4;\\r\\nr += 4;\\r\\nn -= 4;\\r\\n}\\r\\n#endif\\r\\nwhile (n) {\\r\\nt1 = a[0];\\r\\nt2 = b[0];\\r\\nr[0] = (t1 - t2 - c) & BN_MASK2;\\r\\nif (t1 != t2)\\r\\nc = (t1 < t2);\\r\\na++;\\r\\nb++;\\r\\nr++;\\r\\nn--;\\r\\n}\\r\\nreturn (c);\\r\\n}\\r\\nvoid bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nBN_ULONG c1, c2, c3;\\r\\nc1 = 0;\\r\\nc2 = 0;\\r\\nc3 = 0;\\r\\nmul_add_c(a[0], b[0], c1, c2, c3);\\r\\nr[0] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[0], b[1], c2, c3, c1);\\r\\nmul_add_c(a[1], b[0], c2, c3, c1);\\r\\nr[1] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[2], b[0], c3, c1, c2);\\r\\nmul_add_c(a[1], b[1], c3, c1, c2);\\r\\nmul_add_c(a[0], b[2], c3, c1, c2);\\r\\nr[2] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[0], b[3], c1, c2, c3);\\r\\nmul_add_c(a[1], b[2], c1, c2, c3);\\r\\nmul_add_c(a[2], b[1], c1, c2, c3);\\r\\nmul_add_c(a[3], b[0], c1, c2, c3);\\r\\nr[3] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[4], b[0], c2, c3, c1);\\r\\nmul_add_c(a[3], b[1], c2, c3, c1);\\r\\nmul_add_c(a[2], b[2], c2, c3, c1);\\r\\nmul_add_c(a[1], b[3], c2, c3, c1);\\r\\nmul_add_c(a[0], b[4], c2, c3, c1);\\r\\nr[4] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[0], b[5], c3, c1, c2);\\r\\nmul_add_c(a[1], b[4], c3, c1, c2);\\r\\nmul_add_c(a[2], b[3], c3, c1, c2);\\r\\nmul_add_c(a[3], b[2], c3, c1, c2);\\r\\nmul_add_c(a[4], b[1], c3, c1, c2);\\r\\nmul_add_c(a[5], b[0], c3, c1, c2);\\r\\nr[5] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[6], b[0], c1, c2, c3);\\r\\nmul_add_c(a[5], b[1], c1, c2, c3);\\r\\nmul_add_c(a[4], b[2], c1, c2, c3);\\r\\nmul_add_c(a[3], b[3], c1, c2, c3);\\r\\nmul_add_c(a[2], b[4], c1, c2, c3);\\r\\nmul_add_c(a[1], b[5], c1, c2, c3);\\r\\nmul_add_c(a[0], b[6], c1, c2, c3);\\r\\nr[6] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[0], b[7], c2, c3, c1);\\r\\nmul_add_c(a[1], b[6], c2, c3, c1);\\r\\nmul_add_c(a[2], b[5], c2, c3, c1);\\r\\nmul_add_c(a[3], b[4], c2, c3, c1);\\r\\nmul_add_c(a[4], b[3], c2, c3, c1);\\r\\nmul_add_c(a[5], b[2], c2, c3, c1);\\r\\nmul_add_c(a[6], b[1], c2, c3, c1);\\r\\nmul_add_c(a[7], b[0], c2, c3, c1);\\r\\nr[7] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[7], b[1], c3, c1, c2);\\r\\nmul_add_c(a[6], b[2], c3, c1, c2);\\r\\nmul_add_c(a[5], b[3], c3, c1, c2);\\r\\nmul_add_c(a[4], b[4], c3, c1, c2);\\r\\nmul_add_c(a[3], b[5], c3, c1, c2);\\r\\nmul_add_c(a[2], b[6], c3, c1, c2);\\r\\nmul_add_c(a[1], b[7], c3, c1, c2);\\r\\nr[8] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[2], b[7], c1, c2, c3);\\r\\nmul_add_c(a[3], b[6], c1, c2, c3);\\r\\nmul_add_c(a[4], b[5], c1, c2, c3);\\r\\nmul_add_c(a[5], b[4], c1, c2, c3);\\r\\nmul_add_c(a[6], b[3], c1, c2, c3);\\r\\nmul_add_c(a[7], b[2], c1, c2, c3);\\r\\nr[9] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[7], b[3], c2, c3, c1);\\r\\nmul_add_c(a[6], b[4], c2, c3, c1);\\r\\nmul_add_c(a[5], b[5], c2, c3, c1);\\r\\nmul_add_c(a[4], b[6], c2, c3, c1);\\r\\nmul_add_c(a[3], b[7], c2, c3, c1);\\r\\nr[10] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[4], b[7], c3, c1, c2);\\r\\nmul_add_c(a[5], b[6], c3, c1, c2);\\r\\nmul_add_c(a[6], b[5], c3, c1, c2);\\r\\nmul_add_c(a[7], b[4], c3, c1, c2);\\r\\nr[11] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[7], b[5], c1, c2, c3);\\r\\nmul_add_c(a[6], b[6], c1, c2, c3);\\r\\nmul_add_c(a[5], b[7], c1, c2, c3);\\r\\nr[12] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[6], b[7], c2, c3, c1);\\r\\nmul_add_c(a[7], b[6], c2, c3, c1);\\r\\nr[13] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[7], b[7], c3, c1, c2);\\r\\nr[14] = c3;\\r\\nr[15] = c1;\\r\\n}\\r\\nvoid bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nBN_ULONG c1, c2, c3;\\r\\nc1 = 0;\\r\\nc2 = 0;\\r\\nc3 = 0;\\r\\nmul_add_c(a[0], b[0], c1, c2, c3);\\r\\nr[0] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[0], b[1], c2, c3, c1);\\r\\nmul_add_c(a[1], b[0], c2, c3, c1);\\r\\nr[1] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[2], b[0], c3, c1, c2);\\r\\nmul_add_c(a[1], b[1], c3, c1, c2);\\r\\nmul_add_c(a[0], b[2], c3, c1, c2);\\r\\nr[2] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[0], b[3], c1, c2, c3);\\r\\nmul_add_c(a[1], b[2], c1, c2, c3);\\r\\nmul_add_c(a[2], b[1], c1, c2, c3);\\r\\nmul_add_c(a[3], b[0], c1, c2, c3);\\r\\nr[3] = c1;\\r\\nc1 = 0;\\r\\nmul_add_c(a[3], b[1], c2, c3, c1);\\r\\nmul_add_c(a[2], b[2], c2, c3, c1);\\r\\nmul_add_c(a[1], b[3], c2, c3, c1);\\r\\nr[4] = c2;\\r\\nc2 = 0;\\r\\nmul_add_c(a[2], b[3], c3, c1, c2);\\r\\nmul_add_c(a[3], b[2], c3, c1, c2);\\r\\nr[5] = c3;\\r\\nc3 = 0;\\r\\nmul_add_c(a[3], b[3], c1, c2, c3);\\r\\nr[6] = c1;\\r\\nr[7] = c2;\\r\\n}\\r\\nvoid bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG c1, c2, c3;\\r\\nc1 = 0;\\r\\nc2 = 0;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 0, c1, c2, c3);\\r\\nr[0] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c2(a, 1, 0, c2, c3, c1);\\r\\nr[1] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c(a, 1, c3, c1, c2);\\r\\nsqr_add_c2(a, 2, 0, c3, c1, c2);\\r\\nr[2] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c2(a, 3, 0, c1, c2, c3);\\r\\nsqr_add_c2(a, 2, 1, c1, c2, c3);\\r\\nr[3] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c(a, 2, c2, c3, c1);\\r\\nsqr_add_c2(a, 3, 1, c2, c3, c1);\\r\\nsqr_add_c2(a, 4, 0, c2, c3, c1);\\r\\nr[4] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c2(a, 5, 0, c3, c1, c2);\\r\\nsqr_add_c2(a, 4, 1, c3, c1, c2);\\r\\nsqr_add_c2(a, 3, 2, c3, c1, c2);\\r\\nr[5] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 3, c1, c2, c3);\\r\\nsqr_add_c2(a, 4, 2, c1, c2, c3);\\r\\nsqr_add_c2(a, 5, 1, c1, c2, c3);\\r\\nsqr_add_c2(a, 6, 0, c1, c2, c3);\\r\\nr[6] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c2(a, 7, 0, c2, c3, c1);\\r\\nsqr_add_c2(a, 6, 1, c2, c3, c1);\\r\\nsqr_add_c2(a, 5, 2, c2, c3, c1);\\r\\nsqr_add_c2(a, 4, 3, c2, c3, c1);\\r\\nr[7] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c(a, 4, c3, c1, c2);\\r\\nsqr_add_c2(a, 5, 3, c3, c1, c2);\\r\\nsqr_add_c2(a, 6, 2, c3, c1, c2);\\r\\nsqr_add_c2(a, 7, 1, c3, c1, c2);\\r\\nr[8] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c2(a, 7, 2, c1, c2, c3);\\r\\nsqr_add_c2(a, 6, 3, c1, c2, c3);\\r\\nsqr_add_c2(a, 5, 4, c1, c2, c3);\\r\\nr[9] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c(a, 5, c2, c3, c1);\\r\\nsqr_add_c2(a, 6, 4, c2, c3, c1);\\r\\nsqr_add_c2(a, 7, 3, c2, c3, c1);\\r\\nr[10] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c2(a, 7, 4, c3, c1, c2);\\r\\nsqr_add_c2(a, 6, 5, c3, c1, c2);\\r\\nr[11] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 6, c1, c2, c3);\\r\\nsqr_add_c2(a, 7, 5, c1, c2, c3);\\r\\nr[12] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c2(a, 7, 6, c2, c3, c1);\\r\\nr[13] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c(a, 7, c3, c1, c2);\\r\\nr[14] = c3;\\r\\nr[15] = c1;\\r\\n}\\r\\nvoid bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG c1, c2, c3;\\r\\nc1 = 0;\\r\\nc2 = 0;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 0, c1, c2, c3);\\r\\nr[0] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c2(a, 1, 0, c2, c3, c1);\\r\\nr[1] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c(a, 1, c3, c1, c2);\\r\\nsqr_add_c2(a, 2, 0, c3, c1, c2);\\r\\nr[2] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c2(a, 3, 0, c1, c2, c3);\\r\\nsqr_add_c2(a, 2, 1, c1, c2, c3);\\r\\nr[3] = c1;\\r\\nc1 = 0;\\r\\nsqr_add_c(a, 2, c2, c3, c1);\\r\\nsqr_add_c2(a, 3, 1, c2, c3, c1);\\r\\nr[4] = c2;\\r\\nc2 = 0;\\r\\nsqr_add_c2(a, 3, 2, c3, c1, c2);\\r\\nr[5] = c3;\\r\\nc3 = 0;\\r\\nsqr_add_c(a, 3, c1, c2, c3);\\r\\nr[6] = c1;\\r\\nr[7] = c2;\\r\\n}\\r\\nint bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0p, int num)\\r\\n{\\r\\nBN_ULONG c0, c1, ml, *tp, n0;\\r\\n# ifdef mul64\\r\\nBN_ULONG mh;\\r\\n# endif\\r\\nvolatile BN_ULONG *vp;\\r\\nint i = 0, j;\\r\\n# if 0\\r\\nif (ap == bp)\\r\\nreturn bn_sqr_mont(rp, ap, np, n0p, num);\\r\\n# endif\\r\\nvp = tp = alloca((num + 2) * sizeof(BN_ULONG));\\r\\nn0 = *n0p;\\r\\nc0 = 0;\\r\\nml = bp[0];\\r\\n# ifdef mul64\\r\\nmh = HBITS(ml);\\r\\nml = LBITS(ml);\\r\\nfor (j = 0; j < num; ++j)\\r\\nmul(tp[j], ap[j], ml, mh, c0);\\r\\n# else\\r\\nfor (j = 0; j < num; ++j)\\r\\nmul(tp[j], ap[j], ml, c0);\\r\\n# endif\\r\\ntp[num] = c0;\\r\\ntp[num + 1] = 0;\\r\\ngoto enter;\\r\\nfor (i = 0; i < num; i++) {\\r\\nc0 = 0;\\r\\nml = bp[i];\\r\\n# ifdef mul64\\r\\nmh = HBITS(ml);\\r\\nml = LBITS(ml);\\r\\nfor (j = 0; j < num; ++j)\\r\\nmul_add(tp[j], ap[j], ml, mh, c0);\\r\\n# else\\r\\nfor (j = 0; j < num; ++j)\\r\\nmul_add(tp[j], ap[j], ml, c0);\\r\\n# endif\\r\\nc1 = (tp[num] + c0) & BN_MASK2;\\r\\ntp[num] = c1;\\r\\ntp[num + 1] = (c1 < c0 ? 1 : 0);\\r\\nenter:\\r\\nc1 = tp[0];\\r\\nml = (c1 * n0) & BN_MASK2;\\r\\nc0 = 0;\\r\\n# ifdef mul64\\r\\nmh = HBITS(ml);\\r\\nml = LBITS(ml);\\r\\nmul_add(c1, np[0], ml, mh, c0);\\r\\n# else\\r\\nmul_add(c1, ml, np[0], c0);\\r\\n# endif\\r\\nfor (j = 1; j < num; j++) {\\r\\nc1 = tp[j];\\r\\n# ifdef mul64\\r\\nmul_add(c1, np[j], ml, mh, c0);\\r\\n# else\\r\\nmul_add(c1, ml, np[j], c0);\\r\\n# endif\\r\\ntp[j - 1] = c1 & BN_MASK2;\\r\\n}\\r\\nc1 = (tp[num] + c0) & BN_MASK2;\\r\\ntp[num - 1] = c1;\\r\\ntp[num] = tp[num + 1] + (c1 < c0 ? 1 : 0);\\r\\n}\\r\\nif (tp[num] != 0 || tp[num - 1] >= np[num - 1]) {\\r\\nc0 = bn_sub_words(rp, tp, np, num);\\r\\nif (tp[num] != 0 || c0 == 0) {\\r\\nfor (i = 0; i < num + 2; i++)\\r\\nvp[i] = 0;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < num; i++)\\r\\nrp[i] = tp[i], vp[i] = 0;\\r\\nvp[num] = 0;\\r\\nvp[num + 1] = 0;\\r\\nreturn 1;\\r\\n}\\r\\nint bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0, int num)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nvoid bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG t[8];\\r\\nbn_sqr_normal(r, a, 4, t);\\r\\n}\\r\\nvoid bn_sqr_comba8(BN_ULONG *r, const BN_ULONG *a)\\r\\n{\\r\\nBN_ULONG t[16];\\r\\nbn_sqr_normal(r, a, 8, t);\\r\\n}\\r\\nvoid bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nr[4] = bn_mul_words(&(r[0]), a, 4, b[0]);\\r\\nr[5] = bn_mul_add_words(&(r[1]), a, 4, b[1]);\\r\\nr[6] = bn_mul_add_words(&(r[2]), a, 4, b[2]);\\r\\nr[7] = bn_mul_add_words(&(r[3]), a, 4, b[3]);\\r\\n}\\r\\nvoid bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\\r\\n{\\r\\nr[8] = bn_mul_words(&(r[0]), a, 8, b[0]);\\r\\nr[9] = bn_mul_add_words(&(r[1]), a, 8, b[1]);\\r\\nr[10] = bn_mul_add_words(&(r[2]), a, 8, b[2]);\\r\\nr[11] = bn_mul_add_words(&(r[3]), a, 8, b[3]);\\r\\nr[12] = bn_mul_add_words(&(r[4]), a, 8, b[4]);\\r\\nr[13] = bn_mul_add_words(&(r[5]), a, 8, b[5]);\\r\\nr[14] = bn_mul_add_words(&(r[6]), a, 8, b[6]);\\r\\nr[15] = bn_mul_add_words(&(r[7]), a, 8, b[7]);\\r\\n}\\r\\nint bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0p, int num)\\r\\n{\\r\\nBN_ULONG c0, c1, *tp, n0 = *n0p;\\r\\nvolatile BN_ULONG *vp;\\r\\nint i = 0, j;\\r\\nvp = tp = alloca((num + 2) * sizeof(BN_ULONG));\\r\\nfor (i = 0; i <= num; i++)\\r\\ntp[i] = 0;\\r\\nfor (i = 0; i < num; i++) {\\r\\nc0 = bn_mul_add_words(tp, ap, num, bp[i]);\\r\\nc1 = (tp[num] + c0) & BN_MASK2;\\r\\ntp[num] = c1;\\r\\ntp[num + 1] = (c1 < c0 ? 1 : 0);\\r\\nc0 = bn_mul_add_words(tp, np, num, tp[0] * n0);\\r\\nc1 = (tp[num] + c0) & BN_MASK2;\\r\\ntp[num] = c1;\\r\\ntp[num + 1] += (c1 < c0 ? 1 : 0);\\r\\nfor (j = 0; j <= num; j++)\\r\\ntp[j] = tp[j + 1];\\r\\n}\\r\\nif (tp[num] != 0 || tp[num - 1] >= np[num - 1]) {\\r\\nc0 = bn_sub_words(rp, tp, np, num);\\r\\nif (tp[num] != 0 || c0 == 0) {\\r\\nfor (i = 0; i < num + 2; i++)\\r\\nvp[i] = 0;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < num; i++)\\r\\nrp[i] = tp[i], vp[i] = 0;\\r\\nvp[num] = 0;\\r\\nvp[num + 1] = 0;\\r\\nreturn 1;\\r\\n}\\r\\nint bn_mul_mont(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,\\r\\nconst BN_ULONG *np, const BN_ULONG *n0, int num)\\r\\n{\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_none_c", "target": 0, "func": "int RSA_padding_add_none(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nif (flen > tlen) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_NONE, RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn (0);\\r\\n}\\r\\nif (flen < tlen) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_NONE, RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE);\\r\\nreturn (0);\\r\\n}\\r\\nmemcpy(to, from, (unsigned int)flen);\\r\\nreturn (1);\\r\\n}\\r\\nint RSA_padding_check_none(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num)\\r\\n{\\r\\nif (flen > tlen) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_NONE, RSA_R_DATA_TOO_LARGE);\\r\\nreturn (-1);\\r\\n}\\r\\nmemset(to, 0, tlen - flen);\\r\\nmemcpy(to + tlen - flen, from, flen);\\r\\nreturn (tlen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_srp_vfy_c", "target": 0, "func": "static int t_fromb64(unsigned char *a, const char *src)\\r\\n{\\r\\nchar *loc;\\r\\nint i, j;\\r\\nint size;\\r\\nwhile (*src && (*src == ' ' || *src == '\\t' || *src == '\\n'))\\r\\n++src;\\r\\nsize = strlen(src);\\r\\ni = 0;\\r\\nwhile (i < size) {\\r\\nloc = strchr(b64table, src[i]);\\r\\nif (loc == (char *)0)\\r\\nbreak;\\r\\nelse\\r\\na[i] = loc - b64table;\\r\\n++i;\\r\\n}\\r\\nif (i == 0)\\r\\nreturn 0;\\r\\nsize = i;\\r\\ni = size - 1;\\r\\nj = size;\\r\\nwhile (1) {\\r\\na[j] = a[i];\\r\\nif (--i < 0)\\r\\nbreak;\\r\\na[j] |= (a[i] & 3) << 6;\\r\\n--j;\\r\\na[j] = (unsigned char)((a[i] & 0x3c) >> 2);\\r\\nif (--i < 0)\\r\\nbreak;\\r\\na[j] |= (a[i] & 0xf) << 4;\\r\\n--j;\\r\\na[j] = (unsigned char)((a[i] & 0x30) >> 4);\\r\\nif (--i < 0)\\r\\nbreak;\\r\\na[j] |= (a[i] << 2);\\r\\na[--j] = 0;\\r\\nif (--i < 0)\\r\\nbreak;\\r\\n}\\r\\nwhile (a[j] == 0 && j <= size)\\r\\n++j;\\r\\ni = 0;\\r\\nwhile (j <= size)\\r\\na[i++] = a[j++];\\r\\nreturn i;\\r\\n}\\r\\nstatic char *t_tob64(char *dst, const unsigned char *src, int size)\\r\\n{\\r\\nint c, pos = size % 3;\\r\\nunsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;\\r\\nchar *olddst = dst;\\r\\nswitch (pos) {\\r\\ncase 1:\\r\\nb2 = src[0];\\r\\nbreak;\\r\\ncase 2:\\r\\nb1 = src[0];\\r\\nb2 = src[1];\\r\\nbreak;\\r\\n}\\r\\nwhile (1) {\\r\\nc = (b0 & 0xfc) >> 2;\\r\\nif (notleading || c != 0) {\\r\\n*dst++ = b64table[c];\\r\\nnotleading = 1;\\r\\n}\\r\\nc = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);\\r\\nif (notleading || c != 0) {\\r\\n*dst++ = b64table[c];\\r\\nnotleading = 1;\\r\\n}\\r\\nc = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);\\r\\nif (notleading || c != 0) {\\r\\n*dst++ = b64table[c];\\r\\nnotleading = 1;\\r\\n}\\r\\nc = b2 & 0x3f;\\r\\nif (notleading || c != 0) {\\r\\n*dst++ = b64table[c];\\r\\nnotleading = 1;\\r\\n}\\r\\nif (pos >= size)\\r\\nbreak;\\r\\nelse {\\r\\nb0 = src[pos++];\\r\\nb1 = src[pos++];\\r\\nb2 = src[pos++];\\r\\n}\\r\\n}\\r\\n*dst++ = '\\0';\\r\\nreturn olddst;\\r\\n}\\r\\nstatic void SRP_user_pwd_free(SRP_user_pwd *user_pwd)\\r\\n{\\r\\nif (user_pwd == NULL)\\r\\nreturn;\\r\\nBN_free(user_pwd->s);\\r\\nBN_clear_free(user_pwd->v);\\r\\nOPENSSL_free(user_pwd->id);\\r\\nOPENSSL_free(user_pwd->info);\\r\\nOPENSSL_free(user_pwd);\\r\\n}\\r\\nstatic SRP_user_pwd *SRP_user_pwd_new()\\r\\n{\\r\\nSRP_user_pwd *ret = OPENSSL_malloc(sizeof(SRP_user_pwd));\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nret->N = NULL;\\r\\nret->g = NULL;\\r\\nret->s = NULL;\\r\\nret->v = NULL;\\r\\nret->id = NULL;\\r\\nret->info = NULL;\\r\\nreturn ret;\\r\\n}\\r\\nstatic void SRP_user_pwd_set_gN(SRP_user_pwd *vinfo, const BIGNUM *g,\\r\\nconst BIGNUM *N)\\r\\n{\\r\\nvinfo->N = N;\\r\\nvinfo->g = g;\\r\\n}\\r\\nstatic int SRP_user_pwd_set_ids(SRP_user_pwd *vinfo, const char *id,\\r\\nconst char *info)\\r\\n{\\r\\nif (id != NULL && NULL == (vinfo->id = BUF_strdup(id)))\\r\\nreturn 0;\\r\\nreturn (info == NULL || NULL != (vinfo->info = BUF_strdup(info)));\\r\\n}\\r\\nstatic int SRP_user_pwd_set_sv(SRP_user_pwd *vinfo, const char *s,\\r\\nconst char *v)\\r\\n{\\r\\nunsigned char tmp[MAX_LEN];\\r\\nint len;\\r\\nif (strlen(s) > MAX_LEN || strlen(v) > MAX_LEN)\\r\\nreturn 0;\\r\\nlen = t_fromb64(tmp, v);\\r\\nif (NULL == (vinfo->v = BN_bin2bn(tmp, len, NULL)))\\r\\nreturn 0;\\r\\nlen = t_fromb64(tmp, s);\\r\\nreturn ((vinfo->s = BN_bin2bn(tmp, len, NULL)) != NULL);\\r\\n}\\r\\nstatic int SRP_user_pwd_set_sv_BN(SRP_user_pwd *vinfo, BIGNUM *s, BIGNUM *v)\\r\\n{\\r\\nvinfo->v = v;\\r\\nvinfo->s = s;\\r\\nreturn (vinfo->s != NULL && vinfo->v != NULL);\\r\\n}\\r\\nSRP_VBASE *SRP_VBASE_new(char *seed_key)\\r\\n{\\r\\nSRP_VBASE *vb = (SRP_VBASE *)OPENSSL_malloc(sizeof(SRP_VBASE));\\r\\nif (vb == NULL)\\r\\nreturn NULL;\\r\\nif (!(vb->users_pwd = sk_SRP_user_pwd_new_null()) ||\\r\\n!(vb->gN_cache = sk_SRP_gN_cache_new_null())) {\\r\\nOPENSSL_free(vb);\\r\\nreturn NULL;\\r\\n}\\r\\nvb->default_g = NULL;\\r\\nvb->default_N = NULL;\\r\\nvb->seed_key = NULL;\\r\\nif ((seed_key != NULL) && (vb->seed_key = BUF_strdup(seed_key)) == NULL) {\\r\\nsk_SRP_user_pwd_free(vb->users_pwd);\\r\\nsk_SRP_gN_cache_free(vb->gN_cache);\\r\\nOPENSSL_free(vb);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn vb;\\r\\n}\\r\\nint SRP_VBASE_free(SRP_VBASE *vb)\\r\\n{\\r\\nsk_SRP_user_pwd_pop_free(vb->users_pwd, SRP_user_pwd_free);\\r\\nsk_SRP_gN_cache_free(vb->gN_cache);\\r\\nOPENSSL_free(vb->seed_key);\\r\\nOPENSSL_free(vb);\\r\\nreturn 0;\\r\\n}\\r\\nstatic SRP_gN_cache *SRP_gN_new_init(const char *ch)\\r\\n{\\r\\nunsigned char tmp[MAX_LEN];\\r\\nint len;\\r\\nSRP_gN_cache *newgN =\\r\\n(SRP_gN_cache *)OPENSSL_malloc(sizeof(SRP_gN_cache));\\r\\nif (newgN == NULL)\\r\\nreturn NULL;\\r\\nif ((newgN->b64_bn = BUF_strdup(ch)) == NULL)\\r\\ngoto err;\\r\\nlen = t_fromb64(tmp, ch);\\r\\nif ((newgN->bn = BN_bin2bn(tmp, len, NULL)))\\r\\nreturn newgN;\\r\\nOPENSSL_free(newgN->b64_bn);\\r\\nerr:\\r\\nOPENSSL_free(newgN);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic void SRP_gN_free(SRP_gN_cache *gN_cache)\\r\\n{\\r\\nif (gN_cache == NULL)\\r\\nreturn;\\r\\nOPENSSL_free(gN_cache->b64_bn);\\r\\nBN_free(gN_cache->bn);\\r\\nOPENSSL_free(gN_cache);\\r\\n}\\r\\nint SRP_VBASE_init(SRP_VBASE *vb, char *verifier_file)\\r\\n{\\r\\nint error_code;\\r\\nSTACK_OF(SRP_gN) *SRP_gN_tab = sk_SRP_gN_new_null();\\r\\nchar *last_index = NULL;\\r\\nint i;\\r\\nchar **pp;\\r\\nSRP_gN *gN = NULL;\\r\\nSRP_user_pwd *user_pwd = NULL;\\r\\nTXT_DB *tmpdb = NULL;\\r\\nBIO *in = BIO_new(BIO_s_file());\\r\\nerror_code = SRP_ERR_OPEN_FILE;\\r\\nif (in == NULL || BIO_read_filename(in, verifier_file) <= 0)\\r\\ngoto err;\\r\\nerror_code = SRP_ERR_VBASE_INCOMPLETE_FILE;\\r\\nif ((tmpdb = TXT_DB_read(in, DB_NUMBER)) == NULL)\\r\\ngoto err;\\r\\nerror_code = SRP_ERR_MEMORY;\\r\\nif (vb->seed_key) {\\r\\nlast_index = SRP_get_default_gN(NULL)->id;\\r\\n}\\r\\nfor (i = 0; i < sk_OPENSSL_PSTRING_num(tmpdb->data); i++) {\\r\\npp = sk_OPENSSL_PSTRING_value(tmpdb->data, i);\\r\\nif (pp[DB_srptype][0] == DB_SRP_INDEX) {\\r\\nif ((gN = (SRP_gN *) OPENSSL_malloc(sizeof(SRP_gN))) == NULL)\\r\\ngoto err;\\r\\nif (!(gN->id = BUF_strdup(pp[DB_srpid]))\\r\\n|| !(gN->N =\\r\\nSRP_gN_place_bn(vb->gN_cache, pp[DB_srpverifier]))\\r\\n|| !(gN->g = SRP_gN_place_bn(vb->gN_cache, pp[DB_srpsalt]))\\r\\n|| sk_SRP_gN_insert(SRP_gN_tab, gN, 0) == 0)\\r\\ngoto err;\\r\\ngN = NULL;\\r\\nif (vb->seed_key != NULL) {\\r\\nlast_index = pp[DB_srpid];\\r\\n}\\r\\n} else if (pp[DB_srptype][0] == DB_SRP_VALID) {\\r\\nSRP_gN *lgN;\\r\\nif ((lgN = SRP_get_gN_by_id(pp[DB_srpgN], SRP_gN_tab)) != NULL) {\\r\\nerror_code = SRP_ERR_MEMORY;\\r\\nif ((user_pwd = SRP_user_pwd_new()) == NULL)\\r\\ngoto err;\\r\\nSRP_user_pwd_set_gN(user_pwd, lgN->g, lgN->N);\\r\\nif (!SRP_user_pwd_set_ids\\r\\n(user_pwd, pp[DB_srpid], pp[DB_srpinfo]))\\r\\ngoto err;\\r\\nerror_code = SRP_ERR_VBASE_BN_LIB;\\r\\nif (!SRP_user_pwd_set_sv\\r\\n(user_pwd, pp[DB_srpsalt], pp[DB_srpverifier]))\\r\\ngoto err;\\r\\nif (sk_SRP_user_pwd_insert(vb->users_pwd, user_pwd, 0) == 0)\\r\\ngoto err;\\r\\nuser_pwd = NULL;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (last_index != NULL) {\\r\\nif (((gN = SRP_get_gN_by_id(last_index, SRP_gN_tab)) == NULL)) {\\r\\nerror_code = SRP_ERR_VBASE_BN_LIB;\\r\\ngoto err;\\r\\n}\\r\\nvb->default_g = gN->g;\\r\\nvb->default_N = gN->N;\\r\\ngN = NULL;\\r\\n}\\r\\nerror_code = SRP_NO_ERROR;\\r\\nerr:\\r\\nif (gN != NULL) {\\r\\nOPENSSL_free(gN->id);\\r\\nOPENSSL_free(gN);\\r\\n}\\r\\nSRP_user_pwd_free(user_pwd);\\r\\nif (tmpdb)\\r\\nTXT_DB_free(tmpdb);\\r\\nif (in)\\r\\nBIO_free_all(in);\\r\\nsk_SRP_gN_free(SRP_gN_tab);\\r\\nreturn error_code;\\r\\n}\\r\\nSRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)\\r\\n{\\r\\nint i;\\r\\nSRP_user_pwd *user;\\r\\nunsigned char digv[SHA_DIGEST_LENGTH];\\r\\nunsigned char digs[SHA_DIGEST_LENGTH];\\r\\nEVP_MD_CTX ctxt;\\r\\nif (vb == NULL)\\r\\nreturn NULL;\\r\\nfor (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {\\r\\nuser = sk_SRP_user_pwd_value(vb->users_pwd, i);\\r\\nif (strcmp(user->id, username) == 0)\\r\\nreturn user;\\r\\n}\\r\\nif ((vb->seed_key == NULL) ||\\r\\n(vb->default_g == NULL) || (vb->default_N == NULL))\\r\\nreturn NULL;\\r\\nif ((user = SRP_user_pwd_new()) == NULL)\\r\\nreturn NULL;\\r\\nSRP_user_pwd_set_gN(user, vb->default_g, vb->default_N);\\r\\nif (!SRP_user_pwd_set_ids(user, username, NULL))\\r\\ngoto err;\\r\\nRAND_pseudo_bytes(digv, SHA_DIGEST_LENGTH);\\r\\nEVP_MD_CTX_init(&ctxt);\\r\\nEVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);\\r\\nEVP_DigestUpdate(&ctxt, vb->seed_key, strlen(vb->seed_key));\\r\\nEVP_DigestUpdate(&ctxt, username, strlen(username));\\r\\nEVP_DigestFinal_ex(&ctxt, digs, NULL);\\r\\nEVP_MD_CTX_cleanup(&ctxt);\\r\\nif (SRP_user_pwd_set_sv_BN\\r\\n(user, BN_bin2bn(digs, SHA_DIGEST_LENGTH, NULL),\\r\\nBN_bin2bn(digv, SHA_DIGEST_LENGTH, NULL)))\\r\\nreturn user;\\r\\nerr:SRP_user_pwd_free(user);\\r\\nreturn NULL;\\r\\n}\\r\\nchar *SRP_create_verifier(const char *user, const char *pass, char **salt,\\r\\nchar **verifier, const char *N, const char *g)\\r\\n{\\r\\nint len;\\r\\nchar *result = NULL;\\r\\nchar *vf;\\r\\nBIGNUM *N_bn = NULL, *g_bn = NULL, *s = NULL, *v = NULL;\\r\\nunsigned char tmp[MAX_LEN];\\r\\nunsigned char tmp2[MAX_LEN];\\r\\nchar *defgNid = NULL;\\r\\nif ((user == NULL) ||\\r\\n(pass == NULL) || (salt == NULL) || (verifier == NULL))\\r\\ngoto err;\\r\\nif (N) {\\r\\nif (!(len = t_fromb64(tmp, N)))\\r\\ngoto err;\\r\\nN_bn = BN_bin2bn(tmp, len, NULL);\\r\\nif (!(len = t_fromb64(tmp, g)))\\r\\ngoto err;\\r\\ng_bn = BN_bin2bn(tmp, len, NULL);\\r\\ndefgNid = \"*\";\\r\\n} else {\\r\\nSRP_gN *gN = SRP_get_gN_by_id(g, NULL);\\r\\nif (gN == NULL)\\r\\ngoto err;\\r\\nN_bn = gN->N;\\r\\ng_bn = gN->g;\\r\\ndefgNid = gN->id;\\r\\n}\\r\\nif (*salt == NULL) {\\r\\nRAND_pseudo_bytes(tmp2, SRP_RANDOM_SALT_LEN);\\r\\ns = BN_bin2bn(tmp2, SRP_RANDOM_SALT_LEN, NULL);\\r\\n} else {\\r\\nif (!(len = t_fromb64(tmp2, *salt)))\\r\\ngoto err;\\r\\ns = BN_bin2bn(tmp2, len, NULL);\\r\\n}\\r\\nif (!SRP_create_verifier_BN(user, pass, &s, &v, N_bn, g_bn))\\r\\ngoto err;\\r\\nBN_bn2bin(v, tmp);\\r\\nif (((vf = OPENSSL_malloc(BN_num_bytes(v) * 2)) == NULL))\\r\\ngoto err;\\r\\nt_tob64(vf, tmp, BN_num_bytes(v));\\r\\n*verifier = vf;\\r\\nif (*salt == NULL) {\\r\\nchar *tmp_salt;\\r\\nif ((tmp_salt = OPENSSL_malloc(SRP_RANDOM_SALT_LEN * 2)) == NULL) {\\r\\nOPENSSL_free(vf);\\r\\ngoto err;\\r\\n}\\r\\nt_tob64(tmp_salt, tmp2, SRP_RANDOM_SALT_LEN);\\r\\n*salt = tmp_salt;\\r\\n}\\r\\nresult = defgNid;\\r\\nerr:\\r\\nif (N) {\\r\\nBN_free(N_bn);\\r\\nBN_free(g_bn);\\r\\n}\\r\\nreturn result;\\r\\n}\\r\\nint SRP_create_verifier_BN(const char *user, const char *pass, BIGNUM **salt,\\r\\nBIGNUM **verifier, BIGNUM *N, BIGNUM *g)\\r\\n{\\r\\nint result = 0;\\r\\nBIGNUM *x = NULL;\\r\\nBN_CTX *bn_ctx = BN_CTX_new();\\r\\nunsigned char tmp2[MAX_LEN];\\r\\nif ((user == NULL) ||\\r\\n(pass == NULL) ||\\r\\n(salt == NULL) ||\\r\\n(verifier == NULL) || (N == NULL) || (g == NULL) || (bn_ctx == NULL))\\r\\ngoto err;\\r\\nsrp_bn_print(N);\\r\\nsrp_bn_print(g);\\r\\nif (*salt == NULL) {\\r\\nRAND_pseudo_bytes(tmp2, SRP_RANDOM_SALT_LEN);\\r\\n*salt = BN_bin2bn(tmp2, SRP_RANDOM_SALT_LEN, NULL);\\r\\n}\\r\\nx = SRP_Calc_x(*salt, user, pass);\\r\\n*verifier = BN_new();\\r\\nif (*verifier == NULL)\\r\\ngoto err;\\r\\nif (!BN_mod_exp(*verifier, g, x, N, bn_ctx)) {\\r\\nBN_clear_free(*verifier);\\r\\ngoto err;\\r\\n}\\r\\nsrp_bn_print(*verifier);\\r\\nresult = 1;\\r\\nerr:\\r\\nBN_clear_free(x);\\r\\nBN_CTX_free(bn_ctx);\\r\\nreturn result;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc2_skey_c", "target": 0, "func": "void RC2_set_key(RC2_KEY *key, int len, const unsigned char *data, int bits)\\r\\n#ifdef OPENSSL_FIPS\\r\\n{\\r\\nfips_cipher_abort(RC2);\\r\\nprivate_RC2_set_key(key, len, data, bits);\\r\\n}\\r\\nvoid private_RC2_set_key(RC2_KEY *key, int len, const unsigned char *data,\\r\\nint bits)\\r\\n#endif\\r\\n{\\r\\nint i, j;\\r\\nunsigned char *k;\\r\\nRC2_INT *ki;\\r\\nunsigned int c, d;\\r\\nk = (unsigned char *)&(key->data[0]);\\r\\n*k = 0;\\r\\nif (len > 128)\\r\\nlen = 128;\\r\\nif (bits <= 0)\\r\\nbits = 1024;\\r\\nif (bits > 1024)\\r\\nbits = 1024;\\r\\nfor (i = 0; i < len; i++)\\r\\nk[i] = data[i];\\r\\nd = k[len - 1];\\r\\nj = 0;\\r\\nfor (i = len; i < 128; i++, j++) {\\r\\nd = key_table[(k[j] + d) & 0xff];\\r\\nk[i] = d;\\r\\n}\\r\\nj = (bits + 7) >> 3;\\r\\ni = 128 - j;\\r\\nc = (0xff >> (-bits & 0x07));\\r\\nd = key_table[k[i] & c];\\r\\nk[i] = d;\\r\\nwhile (i--) {\\r\\nd = key_table[k[i + j] ^ d];\\r\\nk[i] = d;\\r\\n}\\r\\nki = &(key->data[63]);\\r\\nfor (i = 127; i >= 0; i -= 2)\\r\\n*(ki--) = ((k[i] << 8) | k[i - 1]) & 0xffff;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_crl_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nunsigned long nmflag = 0;\\r\\nX509_CRL *x = NULL;\\r\\nchar *CAfile = NULL, *CApath = NULL;\\r\\nint ret = 1, i, num, badops = 0, badsig = 0;\\r\\nBIO *out = NULL;\\r\\nint informat, outformat, keyformat;\\r\\nchar *infile = NULL, *outfile = NULL, *crldiff = NULL, *keyfile = NULL;\\r\\nint hash = 0, issuer = 0, lastupdate = 0, nextupdate = 0, noout =\\r\\n0, text = 0;\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nint hash_old = 0;\\r\\n#endif\\r\\nint fingerprint = 0, crlnumber = 0;\\r\\nconst char **pp;\\r\\nX509_STORE *store = NULL;\\r\\nX509_STORE_CTX ctx;\\r\\nX509_LOOKUP *lookup = NULL;\\r\\nX509_OBJECT xobj;\\r\\nEVP_PKEY *pkey;\\r\\nint do_ver = 0;\\r\\nconst EVP_MD *md_alg, *digest = EVP_sha1();\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nif (bio_out == NULL)\\r\\nif ((bio_out = BIO_new(BIO_s_file())) != NULL) {\\r\\nBIO_set_fp(bio_out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nbio_out = BIO_push(tmpbio, bio_out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nkeyformat = FORMAT_PEM;\\r\\nargc--;\\r\\nargv++;\\r\\nnum = 0;\\r\\nwhile (argc >= 1) {\\r\\n#ifdef undef\\r\\nif (strcmp(*argv, \"-p\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!args_from_file(++argv, Nargc, Nargv)) {\\r\\ngoto end;\\r\\n}\\r\\n*/}\\r\\n#endif\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-gendelta\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncrldiff = *(++argv);\\r\\n} else if (strcmp(*argv, \"-key\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keyform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-CApath\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCApath = *(++argv);\\r\\ndo_ver = 1;\\r\\n} else if (strcmp(*argv, \"-CAfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCAfile = *(++argv);\\r\\ndo_ver = 1;\\r\\n} else if (strcmp(*argv, \"-verify\") == 0)\\r\\ndo_ver = 1;\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv, \"-hash\") == 0)\\r\\nhash = ++num;\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nelse if (strcmp(*argv, \"-hash_old\") == 0)\\r\\nhash_old = ++num;\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-nameopt\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!set_name_ex(&nmflag, *(++argv)))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-issuer\") == 0)\\r\\nissuer = ++num;\\r\\nelse if (strcmp(*argv, \"-lastupdate\") == 0)\\r\\nlastupdate = ++num;\\r\\nelse if (strcmp(*argv, \"-nextupdate\") == 0)\\r\\nnextupdate = ++num;\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = ++num;\\r\\nelse if (strcmp(*argv, \"-fingerprint\") == 0)\\r\\nfingerprint = ++num;\\r\\nelse if (strcmp(*argv, \"-crlnumber\") == 0)\\r\\ncrlnumber = ++num;\\r\\nelse if (strcmp(*argv, \"-badsig\") == 0)\\r\\nbadsig = 1;\\r\\nelse if ((md_alg = EVP_get_digestbyname(*argv + 1))) {\\r\\ndigest = md_alg;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nfor (pp = crl_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err, \"%s\", *pp);\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nx = load_crl(infile, informat);\\r\\nif (x == NULL) {\\r\\ngoto end;\\r\\n}\\r\\nif (do_ver) {\\r\\nstore = X509_STORE_new();\\r\\nlookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());\\r\\nif (lookup == NULL)\\r\\ngoto end;\\r\\nif (!X509_LOOKUP_load_file(lookup, CAfile, X509_FILETYPE_PEM))\\r\\nX509_LOOKUP_load_file(lookup, NULL, X509_FILETYPE_DEFAULT);\\r\\nlookup = X509_STORE_add_lookup(store, X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL)\\r\\ngoto end;\\r\\nif (!X509_LOOKUP_add_dir(lookup, CApath, X509_FILETYPE_PEM))\\r\\nX509_LOOKUP_add_dir(lookup, NULL, X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nif (!X509_STORE_CTX_init(&ctx, store, NULL, NULL)) {\\r\\nBIO_printf(bio_err, \"Error initialising X509 store\\n\");\\r\\ngoto end;\\r\\n}\\r\\ni = X509_STORE_get_by_subject(&ctx, X509_LU_X509,\\r\\nX509_CRL_get_issuer(x), &xobj);\\r\\nif (i <= 0) {\\r\\nBIO_printf(bio_err, \"Error getting CRL issuer certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\npkey = X509_get_pubkey(xobj.data.x509);\\r\\nX509_OBJECT_free_contents(&xobj);\\r\\nif (!pkey) {\\r\\nBIO_printf(bio_err, \"Error getting CRL issuer public key\\n\");\\r\\ngoto end;\\r\\n}\\r\\ni = X509_CRL_verify(x, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (i < 0)\\r\\ngoto end;\\r\\nif (i == 0)\\r\\nBIO_printf(bio_err, \"verify failure\\n\");\\r\\nelse\\r\\nBIO_printf(bio_err, \"verify OK\\n\");\\r\\n}\\r\\nif (crldiff) {\\r\\nX509_CRL *newcrl, *delta;\\r\\nif (!keyfile) {\\r\\nBIO_puts(bio_err, \"Missing CRL signing key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nnewcrl = load_crl(crldiff, informat);\\r\\nif (!newcrl)\\r\\ngoto end;\\r\\npkey = load_key(bio_err, keyfile, keyformat, 0, NULL, NULL,\\r\\n\"CRL signing key\");\\r\\nif (!pkey) {\\r\\nX509_CRL_free(newcrl);\\r\\ngoto end;\\r\\n}\\r\\ndelta = X509_CRL_diff(x, newcrl, pkey, digest, 0);\\r\\nX509_CRL_free(newcrl);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (delta) {\\r\\nX509_CRL_free(x);\\r\\nx = delta;\\r\\n} else {\\r\\nBIO_puts(bio_err, \"Error creating delta CRL\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (num) {\\r\\nfor (i = 1; i <= num; i++) {\\r\\nif (issuer == i) {\\r\\nprint_name(bio_out, \"issuer=\", X509_CRL_get_issuer(x),\\r\\nnmflag);\\r\\n}\\r\\nif (crlnumber == i) {\\r\\nASN1_INTEGER *crlnum;\\r\\ncrlnum = X509_CRL_get_ext_d2i(x, NID_crl_number, NULL, NULL);\\r\\nBIO_printf(bio_out, \"crlNumber=\");\\r\\nif (crlnum) {\\r\\ni2a_ASN1_INTEGER(bio_out, crlnum);\\r\\nASN1_INTEGER_free(crlnum);\\r\\n} else\\r\\nBIO_puts(bio_out, \"<NONE>\");\\r\\nBIO_printf(bio_out, \"\\n\");\\r\\n}\\r\\nif (hash == i) {\\r\\nBIO_printf(bio_out, \"%08lx\\n\",\\r\\nX509_NAME_hash(X509_CRL_get_issuer(x)));\\r\\n}\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nif (hash_old == i) {\\r\\nBIO_printf(bio_out, \"%08lx\\n\",\\r\\nX509_NAME_hash_old(X509_CRL_get_issuer(x)));\\r\\n}\\r\\n#endif\\r\\nif (lastupdate == i) {\\r\\nBIO_printf(bio_out, \"lastUpdate=\");\\r\\nASN1_TIME_print(bio_out, X509_CRL_get_lastUpdate(x));\\r\\nBIO_printf(bio_out, \"\\n\");\\r\\n}\\r\\nif (nextupdate == i) {\\r\\nBIO_printf(bio_out, \"nextUpdate=\");\\r\\nif (X509_CRL_get_nextUpdate(x))\\r\\nASN1_TIME_print(bio_out, X509_CRL_get_nextUpdate(x));\\r\\nelse\\r\\nBIO_printf(bio_out, \"NONE\");\\r\\nBIO_printf(bio_out, \"\\n\");\\r\\n}\\r\\nif (fingerprint == i) {\\r\\nint j;\\r\\nunsigned int n;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nif (!X509_CRL_digest(x, digest, md, &n)) {\\r\\nBIO_printf(bio_err, \"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_out, \"%s Fingerprint=\",\\r\\nOBJ_nid2sn(EVP_MD_type(digest)));\\r\\nfor (j = 0; j < (int)n; j++) {\\r\\nBIO_printf(bio_out, \"%02X%c\", md[j], (j + 1 == (int)n)\\r\\n? '\\n' : ':');\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nout = BIO_new(BIO_s_file());\\r\\nif (out == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text)\\r\\nX509_CRL_print(out, x);\\r\\nif (noout) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (badsig)\\r\\nx->signature->data[x->signature->length - 1] ^= 0x1;\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = (int)i2d_X509_CRL_bio(out, x);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_X509_CRL(out, x);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write CRL\\n\");\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nBIO_free_all(out);\\r\\nBIO_free_all(bio_out);\\r\\nbio_out = NULL;\\r\\nX509_CRL_free(x);\\r\\nif (store) {\\r\\nX509_STORE_CTX_cleanup(&ctx);\\r\\nX509_STORE_free(store);\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_pmeth_c", "target": 0, "func": "static int pkey_dh_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nDH_PKEY_CTX *dctx;\\r\\ndctx = OPENSSL_malloc(sizeof(DH_PKEY_CTX));\\r\\nif (!dctx)\\r\\nreturn 0;\\r\\ndctx->prime_len = 1024;\\r\\ndctx->subprime_len = -1;\\r\\ndctx->generator = 2;\\r\\ndctx->use_dsa = 0;\\r\\ndctx->md = NULL;\\r\\ndctx->rfc5114_param = 0;\\r\\ndctx->kdf_type = EVP_PKEY_DH_KDF_NONE;\\r\\ndctx->kdf_oid = NULL;\\r\\ndctx->kdf_md = NULL;\\r\\ndctx->kdf_ukm = NULL;\\r\\ndctx->kdf_ukmlen = 0;\\r\\ndctx->kdf_outlen = 0;\\r\\nctx->data = dctx;\\r\\nctx->keygen_info = dctx->gentmp;\\r\\nctx->keygen_info_count = 2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_dh_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)\\r\\n{\\r\\nDH_PKEY_CTX *dctx, *sctx;\\r\\nif (!pkey_dh_init(dst))\\r\\nreturn 0;\\r\\nsctx = src->data;\\r\\ndctx = dst->data;\\r\\ndctx->prime_len = sctx->prime_len;\\r\\ndctx->subprime_len = sctx->subprime_len;\\r\\ndctx->generator = sctx->generator;\\r\\ndctx->use_dsa = sctx->use_dsa;\\r\\ndctx->md = sctx->md;\\r\\ndctx->rfc5114_param = sctx->rfc5114_param;\\r\\ndctx->kdf_type = sctx->kdf_type;\\r\\ndctx->kdf_oid = OBJ_dup(sctx->kdf_oid);\\r\\nif (!dctx->kdf_oid)\\r\\nreturn 0;\\r\\ndctx->kdf_md = sctx->kdf_md;\\r\\nif (dctx->kdf_ukm) {\\r\\ndctx->kdf_ukm = BUF_memdup(sctx->kdf_ukm, sctx->kdf_ukmlen);\\r\\ndctx->kdf_ukmlen = sctx->kdf_ukmlen;\\r\\n}\\r\\ndctx->kdf_outlen = sctx->kdf_outlen;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void pkey_dh_cleanup(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nDH_PKEY_CTX *dctx = ctx->data;\\r\\nif (dctx) {\\r\\nif (dctx->kdf_ukm)\\r\\nOPENSSL_free(dctx->kdf_ukm);\\r\\nif (dctx->kdf_oid)\\r\\nASN1_OBJECT_free(dctx->kdf_oid);\\r\\nOPENSSL_free(dctx);\\r\\n}\\r\\n}\\r\\nstatic int pkey_dh_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)\\r\\n{\\r\\nDH_PKEY_CTX *dctx = ctx->data;\\r\\nswitch (type) {\\r\\ncase EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN:\\r\\nif (p1 < 256)\\r\\nreturn -2;\\r\\ndctx->prime_len = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN:\\r\\nif (dctx->use_dsa == 0)\\r\\nreturn -2;\\r\\ndctx->subprime_len = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DH_PARAMGEN_GENERATOR:\\r\\nif (dctx->use_dsa)\\r\\nreturn -2;\\r\\ndctx->generator = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DH_PARAMGEN_TYPE:\\r\\n#ifdef OPENSSL_NO_DSA\\r\\nif (p1 != 0)\\r\\nreturn -2;\\r\\n#else\\r\\nif (p1 < 0 || p1 > 2)\\r\\nreturn -2;\\r\\n#endif\\r\\ndctx->use_dsa = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DH_RFC5114:\\r\\nif (p1 < 1 || p1 > 3)\\r\\nreturn -2;\\r\\ndctx->rfc5114_param = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_PEER_KEY:\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DH_KDF_TYPE:\\r\\nif (p1 == -2)\\r\\nreturn dctx->kdf_type;\\r\\nif (p1 != EVP_PKEY_DH_KDF_NONE && p1 != EVP_PKEY_DH_KDF_X9_42)\\r\\nreturn -2;\\r\\ndctx->kdf_type = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DH_KDF_MD:\\r\\ndctx->kdf_md = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_DH_KDF_MD:\\r\\n*(const EVP_MD **)p2 = dctx->kdf_md;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DH_KDF_OUTLEN:\\r\\nif (p1 <= 0)\\r\\nreturn -2;\\r\\ndctx->kdf_outlen = (size_t)p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_DH_KDF_OUTLEN:\\r\\n*(int *)p2 = dctx->kdf_outlen;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DH_KDF_UKM:\\r\\nif (dctx->kdf_ukm)\\r\\nOPENSSL_free(dctx->kdf_ukm);\\r\\ndctx->kdf_ukm = p2;\\r\\nif (p2)\\r\\ndctx->kdf_ukmlen = p1;\\r\\nelse\\r\\ndctx->kdf_ukmlen = 0;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_DH_KDF_UKM:\\r\\n*(unsigned char **)p2 = dctx->kdf_ukm;\\r\\nreturn dctx->kdf_ukmlen;\\r\\ncase EVP_PKEY_CTRL_DH_KDF_OID:\\r\\nif (dctx->kdf_oid)\\r\\nASN1_OBJECT_free(dctx->kdf_oid);\\r\\ndctx->kdf_oid = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_DH_KDF_OID:\\r\\n*(ASN1_OBJECT **)p2 = dctx->kdf_oid;\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\n}\\r\\nstatic int pkey_dh_ctrl_str(EVP_PKEY_CTX *ctx,\\r\\nconst char *type, const char *value)\\r\\n{\\r\\nif (!strcmp(type, \"dh_paramgen_prime_len\")) {\\r\\nint len;\\r\\nlen = atoi(value);\\r\\nreturn EVP_PKEY_CTX_set_dh_paramgen_prime_len(ctx, len);\\r\\n}\\r\\nif (!strcmp(type, \"dh_rfc5114\")) {\\r\\nDH_PKEY_CTX *dctx = ctx->data;\\r\\nint len;\\r\\nlen = atoi(value);\\r\\nif (len < 0 || len > 3)\\r\\nreturn -2;\\r\\ndctx->rfc5114_param = len;\\r\\nreturn 1;\\r\\n}\\r\\nif (!strcmp(type, \"dh_paramgen_generator\")) {\\r\\nint len;\\r\\nlen = atoi(value);\\r\\nreturn EVP_PKEY_CTX_set_dh_paramgen_generator(ctx, len);\\r\\n}\\r\\nif (!strcmp(type, \"dh_paramgen_subprime_len\")) {\\r\\nint len;\\r\\nlen = atoi(value);\\r\\nreturn EVP_PKEY_CTX_set_dh_paramgen_subprime_len(ctx, len);\\r\\n}\\r\\nif (!strcmp(type, \"dh_paramgen_type\")) {\\r\\nint typ;\\r\\ntyp = atoi(value);\\r\\nreturn EVP_PKEY_CTX_set_dh_paramgen_type(ctx, typ);\\r\\n}\\r\\nreturn -2;\\r\\n}\\r\\nstatic DSA *dsa_dh_generate(DH_PKEY_CTX *dctx, BN_GENCB *pcb)\\r\\n{\\r\\nDSA *ret;\\r\\nint rv = 0;\\r\\nint prime_len = dctx->prime_len;\\r\\nint subprime_len = dctx->subprime_len;\\r\\nconst EVP_MD *md = dctx->md;\\r\\nif (dctx->use_dsa > 2)\\r\\nreturn NULL;\\r\\nret = DSA_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (subprime_len == -1) {\\r\\nif (prime_len >= 2048)\\r\\nsubprime_len = 256;\\r\\nelse\\r\\nsubprime_len = 160;\\r\\n}\\r\\nif (md == NULL) {\\r\\nif (prime_len >= 2048)\\r\\nmd = EVP_sha256();\\r\\nelse\\r\\nmd = EVP_sha1();\\r\\n}\\r\\nif (dctx->use_dsa == 1)\\r\\nrv = dsa_builtin_paramgen(ret, prime_len, subprime_len, md,\\r\\nNULL, 0, NULL, NULL, NULL, pcb);\\r\\nelse if (dctx->use_dsa == 2)\\r\\nrv = dsa_builtin_paramgen2(ret, prime_len, subprime_len, md,\\r\\nNULL, 0, -1, NULL, NULL, NULL, pcb);\\r\\nif (rv <= 0) {\\r\\nDSA_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int pkey_dh_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nDH *dh = NULL;\\r\\nDH_PKEY_CTX *dctx = ctx->data;\\r\\nBN_GENCB *pcb, cb;\\r\\nint ret;\\r\\nif (dctx->rfc5114_param) {\\r\\nswitch (dctx->rfc5114_param) {\\r\\ncase 1:\\r\\ndh = DH_get_1024_160();\\r\\nbreak;\\r\\ncase 2:\\r\\ndh = DH_get_2048_224();\\r\\nbreak;\\r\\ncase 3:\\r\\ndh = DH_get_2048_256();\\r\\nbreak;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\nEVP_PKEY_assign(pkey, EVP_PKEY_DHX, dh);\\r\\nreturn 1;\\r\\n}\\r\\nif (ctx->pkey_gencb) {\\r\\npcb = &cb;\\r\\nevp_pkey_set_cb_translate(pcb, ctx);\\r\\n} else\\r\\npcb = NULL;\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (dctx->use_dsa) {\\r\\nDSA *dsa_dh;\\r\\ndsa_dh = dsa_dh_generate(dctx, pcb);\\r\\nif (!dsa_dh)\\r\\nreturn 0;\\r\\ndh = DSA_dup_DH(dsa_dh);\\r\\nDSA_free(dsa_dh);\\r\\nif (!dh)\\r\\nreturn 0;\\r\\nEVP_PKEY_assign(pkey, EVP_PKEY_DHX, dh);\\r\\nreturn 1;\\r\\n}\\r\\n#endif\\r\\ndh = DH_new();\\r\\nif (!dh)\\r\\nreturn 0;\\r\\nret = DH_generate_parameters_ex(dh,\\r\\ndctx->prime_len, dctx->generator, pcb);\\r\\nif (ret)\\r\\nEVP_PKEY_assign_DH(pkey, dh);\\r\\nelse\\r\\nDH_free(dh);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int pkey_dh_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nDH *dh = NULL;\\r\\nif (ctx->pkey == NULL) {\\r\\nDHerr(DH_F_PKEY_DH_KEYGEN, DH_R_NO_PARAMETERS_SET);\\r\\nreturn 0;\\r\\n}\\r\\ndh = DH_new();\\r\\nif (!dh)\\r\\nreturn 0;\\r\\nEVP_PKEY_assign(pkey, ctx->pmeth->pkey_id, dh);\\r\\nif (!EVP_PKEY_copy_parameters(pkey, ctx->pkey))\\r\\nreturn 0;\\r\\nreturn DH_generate_key(pkey->pkey.dh);\\r\\n}\\r\\nstatic int pkey_dh_derive(EVP_PKEY_CTX *ctx, unsigned char *key,\\r\\nsize_t *keylen)\\r\\n{\\r\\nint ret;\\r\\nDH *dh;\\r\\nDH_PKEY_CTX *dctx = ctx->data;\\r\\nBIGNUM *dhpub;\\r\\nif (!ctx->pkey || !ctx->peerkey) {\\r\\nDHerr(DH_F_PKEY_DH_DERIVE, DH_R_KEYS_NOT_SET);\\r\\nreturn 0;\\r\\n}\\r\\ndh = ctx->pkey->pkey.dh;\\r\\ndhpub = ctx->peerkey->pkey.dh->pub_key;\\r\\nif (dctx->kdf_type == EVP_PKEY_DH_KDF_NONE) {\\r\\nif (key == NULL) {\\r\\n*keylen = DH_size(dh);\\r\\nreturn 1;\\r\\n}\\r\\nret = DH_compute_key(key, dhpub, dh);\\r\\nif (ret < 0)\\r\\nreturn ret;\\r\\n*keylen = ret;\\r\\nreturn 1;\\r\\n} else if (dctx->kdf_type == EVP_PKEY_DH_KDF_X9_42) {\\r\\nunsigned char *Z = NULL;\\r\\nsize_t Zlen = 0;\\r\\nif (!dctx->kdf_outlen || !dctx->kdf_oid)\\r\\nreturn 0;\\r\\nif (key == NULL) {\\r\\n*keylen = dctx->kdf_outlen;\\r\\nreturn 1;\\r\\n}\\r\\nif (*keylen != dctx->kdf_outlen)\\r\\nreturn 0;\\r\\nret = 0;\\r\\nZlen = DH_size(dh);\\r\\nZ = OPENSSL_malloc(Zlen);\\r\\nif (DH_compute_key_padded(Z, dhpub, dh) <= 0)\\r\\ngoto err;\\r\\nif (!DH_KDF_X9_42(key, *keylen, Z, Zlen, dctx->kdf_oid,\\r\\ndctx->kdf_ukm, dctx->kdf_ukmlen, dctx->kdf_md))\\r\\ngoto err;\\r\\n*keylen = dctx->kdf_outlen;\\r\\nret = 1;\\r\\nerr:\\r\\nif (Z) {\\r\\nOPENSSL_cleanse(Z, Zlen);\\r\\nOPENSSL_free(Z);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_kari_c", "target": 0, "func": "int CMS_RecipientInfo_kari_get0_alg(CMS_RecipientInfo *ri,\\r\\nX509_ALGOR **palg,\\r\\nASN1_OCTET_STRING **pukm)\\r\\n{\\r\\nif (ri->type != CMS_RECIPINFO_AGREE) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ALG,\\r\\nCMS_R_NOT_KEY_AGREEMENT);\\r\\nreturn 0;\\r\\n}\\r\\nif (palg)\\r\\n*palg = ri->d.kari->keyEncryptionAlgorithm;\\r\\nif (pukm)\\r\\n*pukm = ri->d.kari->ukm;\\r\\nreturn 1;\\r\\n}\\r\\nint CMS_RecipientInfo_kari_orig_id_cmp(CMS_RecipientInfo *ri, X509 *cert)\\r\\n{\\r\\nCMS_OriginatorIdentifierOrKey *oik;\\r\\nif (ri->type != CMS_RECIPINFO_AGREE) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KARI_ORIG_ID_CMP,\\r\\nCMS_R_NOT_KEY_AGREEMENT);\\r\\nreturn -2;\\r\\n}\\r\\noik = ri->d.kari->originator;\\r\\nif (oik->type == CMS_OIK_ISSUER_SERIAL)\\r\\nreturn cms_ias_cert_cmp(oik->d.issuerAndSerialNumber, cert);\\r\\nelse if (oik->type == CMS_OIK_KEYIDENTIFIER)\\r\\nreturn cms_keyid_cert_cmp(oik->d.subjectKeyIdentifier, cert);\\r\\nreturn -1;\\r\\n}\\r\\nint CMS_RecipientEncryptedKey_get0_id(CMS_RecipientEncryptedKey *rek,\\r\\nASN1_OCTET_STRING **keyid,\\r\\nASN1_GENERALIZEDTIME **tm,\\r\\nCMS_OtherKeyAttribute **other,\\r\\nX509_NAME **issuer, ASN1_INTEGER **sno)\\r\\n{\\r\\nCMS_KeyAgreeRecipientIdentifier *rid = rek->rid;\\r\\nif (rid->type == CMS_REK_ISSUER_SERIAL) {\\r\\nif (issuer)\\r\\n*issuer = rid->d.issuerAndSerialNumber->issuer;\\r\\nif (sno)\\r\\n*sno = rid->d.issuerAndSerialNumber->serialNumber;\\r\\nif (keyid)\\r\\n*keyid = NULL;\\r\\nif (tm)\\r\\n*tm = NULL;\\r\\nif (other)\\r\\n*other = NULL;\\r\\n} else if (rid->type == CMS_REK_KEYIDENTIFIER) {\\r\\nif (keyid)\\r\\n*keyid = rid->d.rKeyId->subjectKeyIdentifier;\\r\\nif (tm)\\r\\n*tm = rid->d.rKeyId->date;\\r\\nif (other)\\r\\n*other = rid->d.rKeyId->other;\\r\\nif (issuer)\\r\\n*issuer = NULL;\\r\\nif (sno)\\r\\n*sno = NULL;\\r\\n} else\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint CMS_RecipientEncryptedKey_cert_cmp(CMS_RecipientEncryptedKey *rek,\\r\\nX509 *cert)\\r\\n{\\r\\nCMS_KeyAgreeRecipientIdentifier *rid = rek->rid;\\r\\nif (rid->type == CMS_REK_ISSUER_SERIAL)\\r\\nreturn cms_ias_cert_cmp(rid->d.issuerAndSerialNumber, cert);\\r\\nelse if (rid->type == CMS_REK_KEYIDENTIFIER)\\r\\nreturn cms_keyid_cert_cmp(rid->d.rKeyId->subjectKeyIdentifier, cert);\\r\\nelse\\r\\nreturn -1;\\r\\n}\\r\\nint CMS_RecipientInfo_kari_set0_pkey(CMS_RecipientInfo *ri, EVP_PKEY *pk)\\r\\n{\\r\\nEVP_PKEY_CTX *pctx;\\r\\nCMS_KeyAgreeRecipientInfo *kari = ri->d.kari;\\r\\nif (kari->pctx) {\\r\\nEVP_PKEY_CTX_free(kari->pctx);\\r\\nkari->pctx = NULL;\\r\\n}\\r\\nif (!pk)\\r\\nreturn 1;\\r\\npctx = EVP_PKEY_CTX_new(pk, NULL);\\r\\nif (!pctx || !EVP_PKEY_derive_init(pctx))\\r\\ngoto err;\\r\\nkari->pctx = pctx;\\r\\nreturn 1;\\r\\nerr:\\r\\nif (pctx)\\r\\nEVP_PKEY_CTX_free(pctx);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_CIPHER_CTX *CMS_RecipientInfo_kari_get0_ctx(CMS_RecipientInfo *ri)\\r\\n{\\r\\nif (ri->type == CMS_RECIPINFO_AGREE)\\r\\nreturn &ri->d.kari->ctx;\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int cms_kek_cipher(unsigned char **pout, size_t *poutlen,\\r\\nconst unsigned char *in, size_t inlen,\\r\\nCMS_KeyAgreeRecipientInfo *kari, int enc)\\r\\n{\\r\\nunsigned char kek[EVP_MAX_KEY_LENGTH];\\r\\nsize_t keklen;\\r\\nint rv = 0;\\r\\nunsigned char *out = NULL;\\r\\nint outlen;\\r\\nkeklen = EVP_CIPHER_CTX_key_length(&kari->ctx);\\r\\nif (keklen > EVP_MAX_KEY_LENGTH)\\r\\nreturn 0;\\r\\nif (EVP_PKEY_derive(kari->pctx, kek, &keklen) <= 0)\\r\\ngoto err;\\r\\nif (!EVP_CipherInit_ex(&kari->ctx, NULL, NULL, kek, NULL, enc))\\r\\ngoto err;\\r\\nif (!EVP_CipherUpdate(&kari->ctx, NULL, &outlen, in, inlen))\\r\\ngoto err;\\r\\nout = OPENSSL_malloc(outlen);\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!EVP_CipherUpdate(&kari->ctx, out, &outlen, in, inlen))\\r\\ngoto err;\\r\\n*pout = out;\\r\\n*poutlen = (size_t)outlen;\\r\\nrv = 1;\\r\\nerr:\\r\\nOPENSSL_cleanse(kek, keklen);\\r\\nif (!rv && out)\\r\\nOPENSSL_free(out);\\r\\nEVP_CIPHER_CTX_cleanup(&kari->ctx);\\r\\nEVP_PKEY_CTX_free(kari->pctx);\\r\\nkari->pctx = NULL;\\r\\nreturn rv;\\r\\n}\\r\\nint CMS_RecipientInfo_kari_decrypt(CMS_ContentInfo *cms,\\r\\nCMS_RecipientInfo *ri,\\r\\nCMS_RecipientEncryptedKey *rek)\\r\\n{\\r\\nint rv = 0;\\r\\nunsigned char *enckey = NULL, *cek = NULL;\\r\\nsize_t enckeylen;\\r\\nsize_t ceklen;\\r\\nCMS_EncryptedContentInfo *ec;\\r\\nenckeylen = rek->encryptedKey->length;\\r\\nenckey = rek->encryptedKey->data;\\r\\nif (!cms_env_asn1_ctrl(ri, 1))\\r\\ngoto err;\\r\\nif (!cms_kek_cipher(&cek, &ceklen, enckey, enckeylen, ri->d.kari, 0))\\r\\ngoto err;\\r\\nec = cms->d.envelopedData->encryptedContentInfo;\\r\\nif (ec->key) {\\r\\nOPENSSL_cleanse(ec->key, ec->keylen);\\r\\nOPENSSL_free(ec->key);\\r\\n}\\r\\nec->key = cek;\\r\\nec->keylen = ceklen;\\r\\ncek = NULL;\\r\\nrv = 1;\\r\\nerr:\\r\\nif (cek)\\r\\nOPENSSL_free(cek);\\r\\nreturn rv;\\r\\n}\\r\\nstatic int cms_kari_create_ephemeral_key(CMS_KeyAgreeRecipientInfo *kari,\\r\\nEVP_PKEY *pk)\\r\\n{\\r\\nEVP_PKEY_CTX *pctx = NULL;\\r\\nEVP_PKEY *ekey = NULL;\\r\\nint rv = 0;\\r\\npctx = EVP_PKEY_CTX_new(pk, NULL);\\r\\nif (!pctx)\\r\\ngoto err;\\r\\nif (EVP_PKEY_keygen_init(pctx) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_keygen(pctx, &ekey) <= 0)\\r\\ngoto err;\\r\\nEVP_PKEY_CTX_free(pctx);\\r\\npctx = EVP_PKEY_CTX_new(ekey, NULL);\\r\\nif (!pctx)\\r\\ngoto err;\\r\\nif (EVP_PKEY_derive_init(pctx) <= 0)\\r\\ngoto err;\\r\\nkari->pctx = pctx;\\r\\nrv = 1;\\r\\nerr:\\r\\nif (!rv && pctx)\\r\\nEVP_PKEY_CTX_free(pctx);\\r\\nif (ekey)\\r\\nEVP_PKEY_free(ekey);\\r\\nreturn rv;\\r\\n}\\r\\nint cms_RecipientInfo_kari_init(CMS_RecipientInfo *ri, X509 *recip,\\r\\nEVP_PKEY *pk, unsigned int flags)\\r\\n{\\r\\nCMS_KeyAgreeRecipientInfo *kari;\\r\\nCMS_RecipientEncryptedKey *rek = NULL;\\r\\nri->d.kari = M_ASN1_new_of(CMS_KeyAgreeRecipientInfo);\\r\\nif (!ri->d.kari)\\r\\nreturn 0;\\r\\nri->type = CMS_RECIPINFO_AGREE;\\r\\nkari = ri->d.kari;\\r\\nkari->version = 3;\\r\\nrek = M_ASN1_new_of(CMS_RecipientEncryptedKey);\\r\\nif (!sk_CMS_RecipientEncryptedKey_push(kari->recipientEncryptedKeys, rek)) {\\r\\nM_ASN1_free_of(rek, CMS_RecipientEncryptedKey);\\r\\nreturn 0;\\r\\n}\\r\\nif (flags & CMS_USE_KEYID) {\\r\\nrek->rid->type = CMS_REK_KEYIDENTIFIER;\\r\\nif (!cms_set1_keyid(&rek->rid->d.rKeyId->subjectKeyIdentifier, recip))\\r\\nreturn 0;\\r\\n} else {\\r\\nrek->rid->type = CMS_REK_ISSUER_SERIAL;\\r\\nif (!cms_set1_ias(&rek->rid->d.issuerAndSerialNumber, recip))\\r\\nreturn 0;\\r\\n}\\r\\nif (!cms_kari_create_ephemeral_key(kari, pk))\\r\\nreturn 0;\\r\\nCRYPTO_add(&pk->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\nrek->pkey = pk;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cms_wrap_init(CMS_KeyAgreeRecipientInfo *kari,\\r\\nconst EVP_CIPHER *cipher)\\r\\n{\\r\\nEVP_CIPHER_CTX *ctx = &kari->ctx;\\r\\nconst EVP_CIPHER *kekcipher;\\r\\nint keylen = EVP_CIPHER_key_length(cipher);\\r\\nkekcipher = EVP_CIPHER_CTX_cipher(ctx);\\r\\nif (kekcipher) {\\r\\nif (EVP_CIPHER_CTX_mode(ctx) != EVP_CIPH_WRAP_MODE)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (EVP_CIPHER_type(cipher) == NID_des_ede3_cbc)\\r\\nkekcipher = EVP_des_ede3_wrap();\\r\\nelse if (keylen <= 16)\\r\\nkekcipher = EVP_aes_128_wrap();\\r\\nelse if (keylen <= 24)\\r\\nkekcipher = EVP_aes_192_wrap();\\r\\nelse\\r\\nkekcipher = EVP_aes_256_wrap();\\r\\nreturn EVP_EncryptInit_ex(ctx, kekcipher, NULL, NULL, NULL);\\r\\n}\\r\\nint cms_RecipientInfo_kari_encrypt(CMS_ContentInfo *cms,\\r\\nCMS_RecipientInfo *ri)\\r\\n{\\r\\nCMS_KeyAgreeRecipientInfo *kari;\\r\\nCMS_EncryptedContentInfo *ec;\\r\\nCMS_RecipientEncryptedKey *rek;\\r\\nSTACK_OF(CMS_RecipientEncryptedKey) *reks;\\r\\nint i;\\r\\nif (ri->type != CMS_RECIPINFO_AGREE) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KARI_ENCRYPT, CMS_R_NOT_KEY_AGREEMENT);\\r\\nreturn 0;\\r\\n}\\r\\nkari = ri->d.kari;\\r\\nreks = kari->recipientEncryptedKeys;\\r\\nec = cms->d.envelopedData->encryptedContentInfo;\\r\\nif (!cms_wrap_init(kari, ec->cipher))\\r\\nreturn 0;\\r\\nif (kari->originator->type == -1) {\\r\\nCMS_OriginatorIdentifierOrKey *oik = kari->originator;\\r\\noik->type = CMS_OIK_PUBKEY;\\r\\noik->d.originatorKey = M_ASN1_new_of(CMS_OriginatorPublicKey);\\r\\nif (!oik->d.originatorKey)\\r\\nreturn 0;\\r\\n}\\r\\nif (!cms_env_asn1_ctrl(ri, 0))\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_CMS_RecipientEncryptedKey_num(reks); i++) {\\r\\nunsigned char *enckey;\\r\\nsize_t enckeylen;\\r\\nrek = sk_CMS_RecipientEncryptedKey_value(reks, i);\\r\\nif (EVP_PKEY_derive_set_peer(kari->pctx, rek->pkey) <= 0)\\r\\nreturn 0;\\r\\nif (!cms_kek_cipher(&enckey, &enckeylen, ec->key, ec->keylen,\\r\\nkari, 1))\\r\\nreturn 0;\\r\\nASN1_STRING_set0(rek->encryptedKey, enckey, enckeylen);\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t1_reneg_c", "target": 0, "func": "int ssl_add_clienthello_renegotiate_ext(SSL *s, unsigned char *p, int *len,\\r\\nint maxlen)\\r\\n{\\r\\nif (p) {\\r\\nif ((s->s3->previous_client_finished_len + 1) > maxlen) {\\r\\nSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATE_EXT_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\n*p = s->s3->previous_client_finished_len;\\r\\np++;\\r\\nmemcpy(p, s->s3->previous_client_finished,\\r\\ns->s3->previous_client_finished_len);\\r\\n#ifdef OPENSSL_RI_DEBUG\\r\\nfprintf(stderr, \"%s RI extension sent by client\\n\",\\r\\ns->s3->previous_client_finished_len ? \"Non-empty\" : \"Empty\");\\r\\n#endif\\r\\n}\\r\\n*len = s->s3->previous_client_finished_len + 1;\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_parse_clienthello_renegotiate_ext(SSL *s, unsigned char *d, int len,\\r\\nint *al)\\r\\n{\\r\\nint ilen;\\r\\nif (len < 1) {\\r\\nSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATION_ENCODING_ERR);\\r\\n*al = SSL_AD_ILLEGAL_PARAMETER;\\r\\nreturn 0;\\r\\n}\\r\\nilen = *d;\\r\\nd++;\\r\\nif ((ilen + 1) != len) {\\r\\nSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATION_ENCODING_ERR);\\r\\n*al = SSL_AD_ILLEGAL_PARAMETER;\\r\\nreturn 0;\\r\\n}\\r\\nif (ilen != s->s3->previous_client_finished_len) {\\r\\nSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATION_MISMATCH);\\r\\n*al = SSL_AD_HANDSHAKE_FAILURE;\\r\\nreturn 0;\\r\\n}\\r\\nif (memcmp(d, s->s3->previous_client_finished,\\r\\ns->s3->previous_client_finished_len)) {\\r\\nSSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATION_MISMATCH);\\r\\n*al = SSL_AD_HANDSHAKE_FAILURE;\\r\\nreturn 0;\\r\\n}\\r\\n#ifdef OPENSSL_RI_DEBUG\\r\\nfprintf(stderr, \"%s RI extension received by server\\n\",\\r\\nilen ? \"Non-empty\" : \"Empty\");\\r\\n#endif\\r\\ns->s3->send_connection_binding = 1;\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_add_serverhello_renegotiate_ext(SSL *s, unsigned char *p, int *len,\\r\\nint maxlen)\\r\\n{\\r\\nif (p) {\\r\\nif ((s->s3->previous_client_finished_len +\\r\\ns->s3->previous_server_finished_len + 1) > maxlen) {\\r\\nSSLerr(SSL_F_SSL_ADD_SERVERHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATE_EXT_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\n*p = s->s3->previous_client_finished_len +\\r\\ns->s3->previous_server_finished_len;\\r\\np++;\\r\\nmemcpy(p, s->s3->previous_client_finished,\\r\\ns->s3->previous_client_finished_len);\\r\\np += s->s3->previous_client_finished_len;\\r\\nmemcpy(p, s->s3->previous_server_finished,\\r\\ns->s3->previous_server_finished_len);\\r\\n#ifdef OPENSSL_RI_DEBUG\\r\\nfprintf(stderr, \"%s RI extension sent by server\\n\",\\r\\ns->s3->previous_client_finished_len ? \"Non-empty\" : \"Empty\");\\r\\n#endif\\r\\n}\\r\\n*len = s->s3->previous_client_finished_len\\r\\n+ s->s3->previous_server_finished_len + 1;\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_parse_serverhello_renegotiate_ext(SSL *s, unsigned char *d, int len,\\r\\nint *al)\\r\\n{\\r\\nint expected_len = s->s3->previous_client_finished_len\\r\\n+ s->s3->previous_server_finished_len;\\r\\nint ilen;\\r\\nOPENSSL_assert(!expected_len || s->s3->previous_client_finished_len);\\r\\nOPENSSL_assert(!expected_len || s->s3->previous_server_finished_len);\\r\\nif (len < 1) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATION_ENCODING_ERR);\\r\\n*al = SSL_AD_ILLEGAL_PARAMETER;\\r\\nreturn 0;\\r\\n}\\r\\nilen = *d;\\r\\nd++;\\r\\nif (ilen + 1 != len) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATION_ENCODING_ERR);\\r\\n*al = SSL_AD_ILLEGAL_PARAMETER;\\r\\nreturn 0;\\r\\n}\\r\\nif (ilen != expected_len) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATION_MISMATCH);\\r\\n*al = SSL_AD_HANDSHAKE_FAILURE;\\r\\nreturn 0;\\r\\n}\\r\\nif (memcmp(d, s->s3->previous_client_finished,\\r\\ns->s3->previous_client_finished_len)) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATION_MISMATCH);\\r\\n*al = SSL_AD_HANDSHAKE_FAILURE;\\r\\nreturn 0;\\r\\n}\\r\\nd += s->s3->previous_client_finished_len;\\r\\nif (memcmp(d, s->s3->previous_server_finished,\\r\\ns->s3->previous_server_finished_len)) {\\r\\nSSLerr(SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT,\\r\\nSSL_R_RENEGOTIATION_MISMATCH);\\r\\n*al = SSL_AD_ILLEGAL_PARAMETER;\\r\\nreturn 0;\\r\\n}\\r\\n#ifdef OPENSSL_RI_DEBUG\\r\\nfprintf(stderr, \"%s RI extension received by client\\n\",\\r\\nilen ? \"Non-empty\" : \"Empty\");\\r\\n#endif\\r\\ns->s3->send_connection_binding = 1;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_err_c", "target": 0, "func": "void ERR_load_ENGINE_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(ENGINE_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, ENGINE_str_functs);\\r\\nERR_load_strings(0, ENGINE_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_utf8_c", "target": 0, "func": "int UTF8_getc(const unsigned char *str, int len, unsigned long *val)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nunsigned long value;\\r\\nint ret;\\r\\nif (len <= 0)\\r\\nreturn 0;\\r\\np = str;\\r\\nif ((*p & 0x80) == 0) {\\r\\nvalue = *p++ & 0x7f;\\r\\nret = 1;\\r\\n} else if ((*p & 0xe0) == 0xc0) {\\r\\nif (len < 2)\\r\\nreturn -1;\\r\\nif ((p[1] & 0xc0) != 0x80)\\r\\nreturn -3;\\r\\nvalue = (*p++ & 0x1f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif (value < 0x80)\\r\\nreturn -4;\\r\\nret = 2;\\r\\n} else if ((*p & 0xf0) == 0xe0) {\\r\\nif (len < 3)\\r\\nreturn -1;\\r\\nif (((p[1] & 0xc0) != 0x80)\\r\\n|| ((p[2] & 0xc0) != 0x80))\\r\\nreturn -3;\\r\\nvalue = (*p++ & 0xf) << 12;\\r\\nvalue |= (*p++ & 0x3f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif (value < 0x800)\\r\\nreturn -4;\\r\\nret = 3;\\r\\n} else if ((*p & 0xf8) == 0xf0) {\\r\\nif (len < 4)\\r\\nreturn -1;\\r\\nif (((p[1] & 0xc0) != 0x80)\\r\\n|| ((p[2] & 0xc0) != 0x80)\\r\\n|| ((p[3] & 0xc0) != 0x80))\\r\\nreturn -3;\\r\\nvalue = ((unsigned long)(*p++ & 0x7)) << 18;\\r\\nvalue |= (*p++ & 0x3f) << 12;\\r\\nvalue |= (*p++ & 0x3f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif (value < 0x10000)\\r\\nreturn -4;\\r\\nret = 4;\\r\\n} else if ((*p & 0xfc) == 0xf8) {\\r\\nif (len < 5)\\r\\nreturn -1;\\r\\nif (((p[1] & 0xc0) != 0x80)\\r\\n|| ((p[2] & 0xc0) != 0x80)\\r\\n|| ((p[3] & 0xc0) != 0x80)\\r\\n|| ((p[4] & 0xc0) != 0x80))\\r\\nreturn -3;\\r\\nvalue = ((unsigned long)(*p++ & 0x3)) << 24;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 18;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 12;\\r\\nvalue |= (*p++ & 0x3f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif (value < 0x200000)\\r\\nreturn -4;\\r\\nret = 5;\\r\\n} else if ((*p & 0xfe) == 0xfc) {\\r\\nif (len < 6)\\r\\nreturn -1;\\r\\nif (((p[1] & 0xc0) != 0x80)\\r\\n|| ((p[2] & 0xc0) != 0x80)\\r\\n|| ((p[3] & 0xc0) != 0x80)\\r\\n|| ((p[4] & 0xc0) != 0x80)\\r\\n|| ((p[5] & 0xc0) != 0x80))\\r\\nreturn -3;\\r\\nvalue = ((unsigned long)(*p++ & 0x1)) << 30;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 24;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 18;\\r\\nvalue |= ((unsigned long)(*p++ & 0x3f)) << 12;\\r\\nvalue |= (*p++ & 0x3f) << 6;\\r\\nvalue |= *p++ & 0x3f;\\r\\nif (value < 0x4000000)\\r\\nreturn -4;\\r\\nret = 6;\\r\\n} else\\r\\nreturn -2;\\r\\n*val = value;\\r\\nreturn ret;\\r\\n}\\r\\nint UTF8_putc(unsigned char *str, int len, unsigned long value)\\r\\n{\\r\\nif (!str)\\r\\nlen = 6;\\r\\nelse if (len <= 0)\\r\\nreturn -1;\\r\\nif (value < 0x80) {\\r\\nif (str)\\r\\n*str = (unsigned char)value;\\r\\nreturn 1;\\r\\n}\\r\\nif (value < 0x800) {\\r\\nif (len < 2)\\r\\nreturn -1;\\r\\nif (str) {\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x1f) | 0xc0);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 2;\\r\\n}\\r\\nif (value < 0x10000) {\\r\\nif (len < 3)\\r\\nreturn -1;\\r\\nif (str) {\\r\\n*str++ = (unsigned char)(((value >> 12) & 0xf) | 0xe0);\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 3;\\r\\n}\\r\\nif (value < 0x200000) {\\r\\nif (len < 4)\\r\\nreturn -1;\\r\\nif (str) {\\r\\n*str++ = (unsigned char)(((value >> 18) & 0x7) | 0xf0);\\r\\n*str++ = (unsigned char)(((value >> 12) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 4;\\r\\n}\\r\\nif (value < 0x4000000) {\\r\\nif (len < 5)\\r\\nreturn -1;\\r\\nif (str) {\\r\\n*str++ = (unsigned char)(((value >> 24) & 0x3) | 0xf8);\\r\\n*str++ = (unsigned char)(((value >> 18) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 12) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 5;\\r\\n}\\r\\nif (len < 6)\\r\\nreturn -1;\\r\\nif (str) {\\r\\n*str++ = (unsigned char)(((value >> 30) & 0x1) | 0xfc);\\r\\n*str++ = (unsigned char)(((value >> 24) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 18) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 12) & 0x3f) | 0x80);\\r\\n*str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);\\r\\n*str = (unsigned char)((value & 0x3f) | 0x80);\\r\\n}\\r\\nreturn 6;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_bitstr_c", "target": 0, "func": "int ASN1_BIT_STRING_set(ASN1_BIT_STRING *x, unsigned char *d, int len)\\r\\n{\\r\\nreturn M_ASN1_BIT_STRING_set(x, d, len);\\r\\n}\\r\\nint i2c_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned char **pp)\\r\\n{\\r\\nint ret, j, bits, len;\\r\\nunsigned char *p, *d;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nlen = a->length;\\r\\nif (len > 0) {\\r\\nif (a->flags & ASN1_STRING_FLAG_BITS_LEFT) {\\r\\nbits = (int)a->flags & 0x07;\\r\\n} else {\\r\\nfor (; len > 0; len--) {\\r\\nif (a->data[len - 1])\\r\\nbreak;\\r\\n}\\r\\nj = a->data[len - 1];\\r\\nif (j & 0x01)\\r\\nbits = 0;\\r\\nelse if (j & 0x02)\\r\\nbits = 1;\\r\\nelse if (j & 0x04)\\r\\nbits = 2;\\r\\nelse if (j & 0x08)\\r\\nbits = 3;\\r\\nelse if (j & 0x10)\\r\\nbits = 4;\\r\\nelse if (j & 0x20)\\r\\nbits = 5;\\r\\nelse if (j & 0x40)\\r\\nbits = 6;\\r\\nelse if (j & 0x80)\\r\\nbits = 7;\\r\\nelse\\r\\nbits = 0;\\r\\n}\\r\\n} else\\r\\nbits = 0;\\r\\nret = 1 + len;\\r\\nif (pp == NULL)\\r\\nreturn (ret);\\r\\np = *pp;\\r\\n*(p++) = (unsigned char)bits;\\r\\nd = a->data;\\r\\nmemcpy(p, d, len);\\r\\np += len;\\r\\nif (len > 0)\\r\\np[-1] &= (0xff << bits);\\r\\n*pp = p;\\r\\nreturn (ret);\\r\\n}\\r\\nASN1_BIT_STRING *c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a,\\r\\nconst unsigned char **pp, long len)\\r\\n{\\r\\nASN1_BIT_STRING *ret = NULL;\\r\\nconst unsigned char *p;\\r\\nunsigned char *s;\\r\\nint i;\\r\\nif (len < 1) {\\r\\ni = ASN1_R_STRING_TOO_SHORT;\\r\\ngoto err;\\r\\n}\\r\\nif ((a == NULL) || ((*a) == NULL)) {\\r\\nif ((ret = M_ASN1_BIT_STRING_new()) == NULL)\\r\\nreturn (NULL);\\r\\n} else\\r\\nret = (*a);\\r\\np = *pp;\\r\\ni = *(p++);\\r\\nif (i > 7) {\\r\\ni = ASN1_R_INVALID_BIT_STRING_BITS_LEFT;\\r\\ngoto err;\\r\\n}\\r\\nret->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\nret->flags |= (ASN1_STRING_FLAG_BITS_LEFT | i);\\r\\nif (len-- > 1) {\\r\\ns = (unsigned char *)OPENSSL_malloc((int)len);\\r\\nif (s == NULL) {\\r\\ni = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(s, p, (int)len);\\r\\ns[len - 1] &= (0xff << i);\\r\\np += len;\\r\\n} else\\r\\ns = NULL;\\r\\nret->length = (int)len;\\r\\nif (ret->data != NULL)\\r\\nOPENSSL_free(ret->data);\\r\\nret->data = s;\\r\\nret->type = V_ASN1_BIT_STRING;\\r\\nif (a != NULL)\\r\\n(*a) = ret;\\r\\n*pp = p;\\r\\nreturn (ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_C2I_ASN1_BIT_STRING, i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nM_ASN1_BIT_STRING_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nint ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value)\\r\\n{\\r\\nint w, v, iv;\\r\\nunsigned char *c;\\r\\nw = n / 8;\\r\\nv = 1 << (7 - (n & 0x07));\\r\\niv = ~v;\\r\\nif (!value)\\r\\nv = 0;\\r\\nif (a == NULL)\\r\\nreturn 0;\\r\\na->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\nif ((a->length < (w + 1)) || (a->data == NULL)) {\\r\\nif (!value)\\r\\nreturn (1);\\r\\nif (a->data == NULL)\\r\\nc = (unsigned char *)OPENSSL_malloc(w + 1);\\r\\nelse\\r\\nc = (unsigned char *)OPENSSL_realloc_clean(a->data,\\r\\na->length, w + 1);\\r\\nif (c == NULL) {\\r\\nASN1err(ASN1_F_ASN1_BIT_STRING_SET_BIT, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (w + 1 - a->length > 0)\\r\\nmemset(c + a->length, 0, w + 1 - a->length);\\r\\na->data = c;\\r\\na->length = w + 1;\\r\\n}\\r\\na->data[w] = ((a->data[w]) & iv) | v;\\r\\nwhile ((a->length > 0) && (a->data[a->length - 1] == 0))\\r\\na->length--;\\r\\nreturn (1);\\r\\n}\\r\\nint ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *a, int n)\\r\\n{\\r\\nint w, v;\\r\\nw = n / 8;\\r\\nv = 1 << (7 - (n & 0x07));\\r\\nif ((a == NULL) || (a->length < (w + 1)) || (a->data == NULL))\\r\\nreturn (0);\\r\\nreturn ((a->data[w] & v) != 0);\\r\\n}\\r\\nint ASN1_BIT_STRING_check(ASN1_BIT_STRING *a,\\r\\nunsigned char *flags, int flags_len)\\r\\n{\\r\\nint i, ok;\\r\\nif (!a || !a->data)\\r\\nreturn 1;\\r\\nok = 1;\\r\\nfor (i = 0; i < a->length && ok; ++i) {\\r\\nunsigned char mask = i < flags_len ? ~flags[i] : 0xff;\\r\\nok = (a->data[i] & mask) == 0;\\r\\n}\\r\\nreturn ok;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_old_c", "target": 0, "func": "const EVP_CIPHER *EVP_bf_cfb(void)\\r\\n{\\r\\nreturn EVP_bf_cfb64();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_des_cfb(void)\\r\\n{\\r\\nreturn EVP_des_cfb64();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_des_ede3_cfb(void)\\r\\n{\\r\\nreturn EVP_des_ede3_cfb64();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_des_ede_cfb(void)\\r\\n{\\r\\nreturn EVP_des_ede_cfb64();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_idea_cfb(void)\\r\\n{\\r\\nreturn EVP_idea_cfb64();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_rc2_cfb(void)\\r\\n{\\r\\nreturn EVP_rc2_cfb64();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_cast5_cfb(void)\\r\\n{\\r\\nreturn EVP_cast5_cfb64();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_rc5_32_12_16_cfb(void)\\r\\n{\\r\\nreturn EVP_rc5_32_12_16_cfb64();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_128_cfb(void)\\r\\n{\\r\\nreturn EVP_aes_128_cfb128();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_192_cfb(void)\\r\\n{\\r\\nreturn EVP_aes_192_cfb128();\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_256_cfb(void)\\r\\n{\\r\\nreturn EVP_aes_256_cfb128();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_crpt_c", "target": 0, "func": "void PKCS12_PBE_add(void)\\r\\n{\\r\\n}\\r\\nint PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\\r\\nASN1_TYPE *param, const EVP_CIPHER *cipher,\\r\\nconst EVP_MD *md, int en_de)\\r\\n{\\r\\nPBEPARAM *pbe;\\r\\nint saltlen, iter, ret;\\r\\nunsigned char *salt;\\r\\nconst unsigned char *pbuf;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];\\r\\nif (param == NULL || param->type != V_ASN1_SEQUENCE ||\\r\\nparam->value.sequence == NULL) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN, PKCS12_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\npbuf = param->value.sequence->data;\\r\\nif (!(pbe = d2i_PBEPARAM(NULL, &pbuf, param->value.sequence->length))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN, PKCS12_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!pbe->iter)\\r\\niter = 1;\\r\\nelse\\r\\niter = ASN1_INTEGER_get(pbe->iter);\\r\\nsalt = pbe->salt->data;\\r\\nsaltlen = pbe->salt->length;\\r\\nif (!PKCS12_key_gen(pass, passlen, salt, saltlen, PKCS12_KEY_ID,\\r\\niter, EVP_CIPHER_key_length(cipher), key, md)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN, PKCS12_R_KEY_GEN_ERROR);\\r\\nPBEPARAM_free(pbe);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_key_gen(pass, passlen, salt, saltlen, PKCS12_IV_ID,\\r\\niter, EVP_CIPHER_iv_length(cipher), iv, md)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN, PKCS12_R_IV_GEN_ERROR);\\r\\nPBEPARAM_free(pbe);\\r\\nreturn 0;\\r\\n}\\r\\nPBEPARAM_free(pbe);\\r\\nret = EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, en_de);\\r\\nOPENSSL_cleanse(key, EVP_MAX_KEY_LENGTH);\\r\\nOPENSSL_cleanse(iv, EVP_MAX_IV_LENGTH);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_lib_c", "target": 1, "func": "EC_GROUP *EC_GROUP_new(const EC_METHOD *meth)\\r\\n{\\r\\nEC_GROUP *ret;\\r\\nif (meth == NULL) {\\r\\nECerr(EC_F_EC_GROUP_NEW, EC_R_SLOT_FULL);\\r\\nreturn NULL;\\r\\n}\\r\\nif (meth->group_init == 0) {\\r\\nECerr(EC_F_EC_GROUP_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn NULL;\\r\\n}\\r\\nret = OPENSSL_malloc(sizeof *ret);\\r\\nif (ret == NULL) {\\r\\nECerr(EC_F_EC_GROUP_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->meth = meth;\\r\\nret->extra_data = NULL;\\r\\nret->mont_data = NULL;\\r\\nret->generator = NULL;\\r\\nBN_init(&ret->order);\\r\\nBN_init(&ret->cofactor);\\r\\nret->curve_name = 0;\\r\\nret->asn1_flag = ~EC_GROUP_ASN1_FLAG_MASK;\\r\\nret->asn1_form = POINT_CONVERSION_UNCOMPRESSED;\\r\\nret->seed = NULL;\\r\\nret->seed_len = 0;\\r\\nif (!meth->group_init(ret)) {\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid EC_GROUP_free(EC_GROUP *group)\\r\\n{\\r\\nif (!group)\\r\\nreturn;\\r\\nif (group->meth->group_finish != 0)\\r\\ngroup->meth->group_finish(group);\\r\\nEC_EX_DATA_free_all_data(&group->extra_data);\\r\\nif (EC_GROUP_VERSION(group) && group->mont_data)\\r\\nBN_MONT_CTX_free(group->mont_data);\\r\\nif (group->generator != NULL)\\r\\nEC_POINT_free(group->generator);\\r\\nBN_free(&group->order);\\r\\nBN_free(&group->cofactor);\\r\\nif (group->seed)\\r\\nOPENSSL_free(group->seed);\\r\\nOPENSSL_free(group);\\r\\n}\\r\\nvoid EC_GROUP_clear_free(EC_GROUP *group)\\r\\n{\\r\\nif (!group)\\r\\nreturn;\\r\\nif (group->meth->group_clear_finish != 0)\\r\\ngroup->meth->group_clear_finish(group);\\r\\nelse if (group->meth->group_finish != 0)\\r\\ngroup->meth->group_finish(group);\\r\\nEC_EX_DATA_clear_free_all_data(&group->extra_data);\\r\\nif (EC_GROUP_VERSION(group) && group->mont_data)\\r\\nBN_MONT_CTX_free(group->mont_data);\\r\\nif (group->generator != NULL)\\r\\nEC_POINT_clear_free(group->generator);\\r\\nBN_clear_free(&group->order);\\r\\nBN_clear_free(&group->cofactor);\\r\\nif (group->seed) {\\r\\nOPENSSL_cleanse(group->seed, group->seed_len);\\r\\nOPENSSL_free(group->seed);\\r\\n}\\r\\nOPENSSL_cleanse(group, sizeof *group);\\r\\nOPENSSL_free(group);\\r\\n}\\r\\nint EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (dest->meth->group_copy == 0) {\\r\\nECerr(EC_F_EC_GROUP_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (dest->meth != src->meth) {\\r\\nECerr(EC_F_EC_GROUP_COPY, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif (dest == src)\\r\\nreturn 1;\\r\\nEC_EX_DATA_free_all_data(&dest->extra_data);\\r\\nfor (d = src->extra_data; d != NULL; d = d->next) {\\r\\nvoid *t = d->dup_func(d->data);\\r\\nif (t == NULL)\\r\\nreturn 0;\\r\\nif (!EC_EX_DATA_set_data\\r\\n(&dest->extra_data, t, d->dup_func, d->free_func,\\r\\nd->clear_free_func))\\r\\nreturn 0;\\r\\n}\\r\\nif (EC_GROUP_VERSION(src) && src->mont_data != NULL) {\\r\\nif (dest->mont_data == NULL) {\\r\\ndest->mont_data = BN_MONT_CTX_new();\\r\\nif (dest->mont_data == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (!BN_MONT_CTX_copy(dest->mont_data, src->mont_data))\\r\\nreturn 0;\\r\\n} else {\\r\\nif (EC_GROUP_VERSION(dest) && dest->mont_data != NULL) {\\r\\nBN_MONT_CTX_free(dest->mont_data);\\r\\ndest->mont_data = NULL;\\r\\n}\\r\\n}\\r\\nif (src->generator != NULL) {\\r\\nif (dest->generator == NULL) {\\r\\ndest->generator = EC_POINT_new(dest);\\r\\nif (dest->generator == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (!EC_POINT_copy(dest->generator, src->generator))\\r\\nreturn 0;\\r\\n} else {\\r\\nif (dest->generator != NULL) {\\r\\nEC_POINT_clear_free(dest->generator);\\r\\ndest->generator = NULL;\\r\\n}\\r\\n}\\r\\nif (!BN_copy(&dest->order, &src->order))\\r\\nreturn 0;\\r\\nif (!BN_copy(&dest->cofactor, &src->cofactor))\\r\\nreturn 0;\\r\\ndest->curve_name = src->curve_name;\\r\\ndest->asn1_flag = src->asn1_flag;\\r\\ndest->asn1_form = src->asn1_form;\\r\\nif (src->seed) {\\r\\nif (dest->seed)\\r\\nOPENSSL_free(dest->seed);\\r\\ndest->seed = OPENSSL_malloc(src->seed_len);\\r\\nif (dest->seed == NULL)\\r\\nreturn 0;\\r\\nif (!memcpy(dest->seed, src->seed, src->seed_len))\\r\\nreturn 0;\\r\\ndest->seed_len = src->seed_len;\\r\\n} else {\\r\\nif (dest->seed)\\r\\nOPENSSL_free(dest->seed);\\r\\ndest->seed = NULL;\\r\\ndest->seed_len = 0;\\r\\n}\\r\\nreturn dest->meth->group_copy(dest, src);\\r\\n}\\r\\nEC_GROUP *EC_GROUP_dup(const EC_GROUP *a)\\r\\n{\\r\\nEC_GROUP *t = NULL;\\r\\nint ok = 0;\\r\\nif (a == NULL)\\r\\nreturn NULL;\\r\\nif ((t = EC_GROUP_new(a->meth)) == NULL)\\r\\nreturn (NULL);\\r\\nif (!EC_GROUP_copy(t, a))\\r\\ngoto err;\\r\\nok = 1;\\r\\nerr:\\r\\nif (!ok) {\\r\\nif (t)\\r\\nEC_GROUP_free(t);\\r\\nreturn NULL;\\r\\n} else\\r\\nreturn t;\\r\\n}\\r\\nconst EC_METHOD *EC_GROUP_method_of(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->meth;\\r\\n}\\r\\nint EC_METHOD_get_field_type(const EC_METHOD *meth)\\r\\n{\\r\\nreturn meth->field_type;\\r\\n}\\r\\nint EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,\\r\\nconst BIGNUM *order, const BIGNUM *cofactor)\\r\\n{\\r\\nif (generator == NULL) {\\r\\nECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->generator == NULL) {\\r\\ngroup->generator = EC_POINT_new(group);\\r\\nif (group->generator == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (!EC_POINT_copy(group->generator, generator))\\r\\nreturn 0;\\r\\nif (order != NULL) {\\r\\nif (!BN_copy(&group->order, order))\\r\\nreturn 0;\\r\\n} else\\r\\nBN_zero(&group->order);\\r\\nif (cofactor != NULL) {\\r\\nif (!BN_copy(&group->cofactor, cofactor))\\r\\nreturn 0;\\r\\n} else\\r\\nBN_zero(&group->cofactor);\\r\\nec_precompute_mont_data(group);\\r\\nreturn 1;\\r\\n}\\r\\nconst EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->generator;\\r\\n}\\r\\nBN_MONT_CTX *EC_GROUP_get_mont_data(const EC_GROUP *group)\\r\\n{\\r\\nreturn EC_GROUP_VERSION(group) ? group->mont_data : NULL;\\r\\n}\\r\\nint EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_copy(order, &group->order))\\r\\nreturn 0;\\r\\nreturn !BN_is_zero(order);\\r\\n}\\r\\nint EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (!BN_copy(cofactor, &group->cofactor))\\r\\nreturn 0;\\r\\nreturn !BN_is_zero(&group->cofactor);\\r\\n}\\r\\nvoid EC_GROUP_set_curve_name(EC_GROUP *group, int nid)\\r\\n{\\r\\ngroup->curve_name = nid;\\r\\n}\\r\\nint EC_GROUP_get_curve_name(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->curve_name;\\r\\n}\\r\\nvoid EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag)\\r\\n{\\r\\ngroup->asn1_flag &= ~EC_GROUP_ASN1_FLAG_MASK;\\r\\ngroup->asn1_flag |= flag & EC_GROUP_ASN1_FLAG_MASK;\\r\\n}\\r\\nint EC_GROUP_get_asn1_flag(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->asn1_flag & EC_GROUP_ASN1_FLAG_MASK;\\r\\n}\\r\\nvoid EC_GROUP_set_point_conversion_form(EC_GROUP *group,\\r\\npoint_conversion_form_t form)\\r\\n{\\r\\ngroup->asn1_form = form;\\r\\n}\\r\\npoint_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP\\r\\n*group)\\r\\n{\\r\\nreturn group->asn1_form;\\r\\n}\\r\\nsize_t EC_GROUP_set_seed(EC_GROUP *group, const unsigned char *p, size_t len)\\r\\n{\\r\\nif (group->seed) {\\r\\nOPENSSL_free(group->seed);\\r\\ngroup->seed = NULL;\\r\\ngroup->seed_len = 0;\\r\\n}\\r\\nif (!len || !p)\\r\\nreturn 1;\\r\\nif ((group->seed = OPENSSL_malloc(len)) == NULL)\\r\\nreturn 0;\\r\\nmemcpy(group->seed, p, len);\\r\\ngroup->seed_len = len;\\r\\nreturn len;\\r\\n}\\r\\nunsigned char *EC_GROUP_get0_seed(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->seed;\\r\\n}\\r\\nsize_t EC_GROUP_get_seed_len(const EC_GROUP *group)\\r\\n{\\r\\nreturn group->seed_len;\\r\\n}\\r\\nint EC_GROUP_set_curve_GFp(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_set_curve == 0) {\\r\\nECerr(EC_F_EC_GROUP_SET_CURVE_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_set_curve(group, p, a, b, ctx);\\r\\n}\\r\\nint EC_GROUP_get_curve_GFp(const EC_GROUP *group, BIGNUM *p, BIGNUM *a,\\r\\nBIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_get_curve == 0) {\\r\\nECerr(EC_F_EC_GROUP_GET_CURVE_GFP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_get_curve(group, p, a, b, ctx);\\r\\n}\\r\\nint EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_set_curve == 0) {\\r\\nECerr(EC_F_EC_GROUP_SET_CURVE_GF2M,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_set_curve(group, p, a, b, ctx);\\r\\n}\\r\\nint EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a,\\r\\nBIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_get_curve == 0) {\\r\\nECerr(EC_F_EC_GROUP_GET_CURVE_GF2M,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_get_curve(group, p, a, b, ctx);\\r\\n}\\r\\nint EC_GROUP_get_degree(const EC_GROUP *group)\\r\\n{\\r\\nif (group->meth->group_get_degree == 0) {\\r\\nECerr(EC_F_EC_GROUP_GET_DEGREE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_get_degree(group);\\r\\n}\\r\\nint EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->group_check_discriminant == 0) {\\r\\nECerr(EC_F_EC_GROUP_CHECK_DISCRIMINANT,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->group_check_discriminant(group, ctx);\\r\\n}\\r\\nint EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx)\\r\\n{\\r\\nint r = 0;\\r\\nBIGNUM *a1, *a2, *a3, *b1, *b2, *b3;\\r\\nBN_CTX *ctx_new = NULL;\\r\\nif (EC_METHOD_get_field_type(EC_GROUP_method_of(a)) !=\\r\\nEC_METHOD_get_field_type(EC_GROUP_method_of(b)))\\r\\nreturn 1;\\r\\nif (EC_GROUP_get_curve_name(a) && EC_GROUP_get_curve_name(b) &&\\r\\nEC_GROUP_get_curve_name(a) != EC_GROUP_get_curve_name(b))\\r\\nreturn 1;\\r\\nif (!ctx)\\r\\nctx_new = ctx = BN_CTX_new();\\r\\nif (!ctx)\\r\\nreturn -1;\\r\\nBN_CTX_start(ctx);\\r\\na1 = BN_CTX_get(ctx);\\r\\na2 = BN_CTX_get(ctx);\\r\\na3 = BN_CTX_get(ctx);\\r\\nb1 = BN_CTX_get(ctx);\\r\\nb2 = BN_CTX_get(ctx);\\r\\nb3 = BN_CTX_get(ctx);\\r\\nif (!b3) {\\r\\nBN_CTX_end(ctx);\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx);\\r\\nreturn -1;\\r\\n}\\r\\nif (!a->meth->group_get_curve(a, a1, a2, a3, ctx) ||\\r\\n!b->meth->group_get_curve(b, b1, b2, b3, ctx))\\r\\nr = 1;\\r\\nif (r || BN_cmp(a1, b1) || BN_cmp(a2, b2) || BN_cmp(a3, b3))\\r\\nr = 1;\\r\\nif (r || EC_POINT_cmp(a, EC_GROUP_get0_generator(a),\\r\\nEC_GROUP_get0_generator(b), ctx))\\r\\nr = 1;\\r\\nif (!r) {\\r\\nif (!EC_GROUP_get_order(a, a1, ctx) ||\\r\\n!EC_GROUP_get_order(b, b1, ctx) ||\\r\\n!EC_GROUP_get_cofactor(a, a2, ctx) ||\\r\\n!EC_GROUP_get_cofactor(b, b2, ctx)) {\\r\\nBN_CTX_end(ctx);\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx);\\r\\nreturn -1;\\r\\n}\\r\\nif (BN_cmp(a1, b1) || BN_cmp(a2, b2))\\r\\nr = 1;\\r\\n}\\r\\nBN_CTX_end(ctx);\\r\\nif (ctx_new)\\r\\nBN_CTX_free(ctx);\\r\\nreturn r;\\r\\n}\\r\\nint EC_EX_DATA_set_data(EC_EXTRA_DATA **ex_data, void *data,\\r\\nvoid *(*dup_func) (void *),\\r\\nvoid (*free_func) (void *),\\r\\nvoid (*clear_free_func) (void *))\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (ex_data == NULL)\\r\\nreturn 0;\\r\\nfor (d = *ex_data; d != NULL; d = d->next) {\\r\\nif (d->dup_func == dup_func && d->free_func == free_func\\r\\n&& d->clear_free_func == clear_free_func) {\\r\\nECerr(EC_F_EC_EX_DATA_SET_DATA, EC_R_SLOT_FULL);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (data == NULL)\\r\\nreturn 1;\\r\\nd = OPENSSL_malloc(sizeof *d);\\r\\nif (d == NULL)\\r\\nreturn 0;\\r\\nd->data = data;\\r\\nd->dup_func = dup_func;\\r\\nd->free_func = free_func;\\r\\nd->clear_free_func = clear_free_func;\\r\\nd->next = *ex_data;\\r\\n*ex_data = d;\\r\\nreturn 1;\\r\\n}\\r\\nvoid *EC_EX_DATA_get_data(const EC_EXTRA_DATA *ex_data,\\r\\nvoid *(*dup_func) (void *),\\r\\nvoid (*free_func) (void *),\\r\\nvoid (*clear_free_func) (void *))\\r\\n{\\r\\nconst EC_EXTRA_DATA *d;\\r\\nfor (d = ex_data; d != NULL; d = d->next) {\\r\\nif (d->dup_func == dup_func && d->free_func == free_func\\r\\n&& d->clear_free_func == clear_free_func)\\r\\nreturn d->data;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nvoid EC_EX_DATA_free_data(EC_EXTRA_DATA **ex_data,\\r\\nvoid *(*dup_func) (void *),\\r\\nvoid (*free_func) (void *),\\r\\nvoid (*clear_free_func) (void *))\\r\\n{\\r\\nEC_EXTRA_DATA **p;\\r\\nif (ex_data == NULL)\\r\\nreturn;\\r\\nfor (p = ex_data; *p != NULL; p = &((*p)->next)) {\\r\\nif ((*p)->dup_func == dup_func && (*p)->free_func == free_func\\r\\n&& (*p)->clear_free_func == clear_free_func) {\\r\\nEC_EXTRA_DATA *next = (*p)->next;\\r\\n(*p)->free_func((*p)->data);\\r\\nOPENSSL_free(*p);\\r\\n*p = next;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid EC_EX_DATA_clear_free_data(EC_EXTRA_DATA **ex_data,\\r\\nvoid *(*dup_func) (void *),\\r\\nvoid (*free_func) (void *),\\r\\nvoid (*clear_free_func) (void *))\\r\\n{\\r\\nEC_EXTRA_DATA **p;\\r\\nif (ex_data == NULL)\\r\\nreturn;\\r\\nfor (p = ex_data; *p != NULL; p = &((*p)->next)) {\\r\\nif ((*p)->dup_func == dup_func && (*p)->free_func == free_func\\r\\n&& (*p)->clear_free_func == clear_free_func) {\\r\\nEC_EXTRA_DATA *next = (*p)->next;\\r\\n(*p)->clear_free_func((*p)->data);\\r\\nOPENSSL_free(*p);\\r\\n*p = next;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid EC_EX_DATA_free_all_data(EC_EXTRA_DATA **ex_data)\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (ex_data == NULL)\\r\\nreturn;\\r\\nd = *ex_data;\\r\\nwhile (d) {\\r\\nEC_EXTRA_DATA *next = d->next;\\r\\nd->free_func(d->data);\\r\\nOPENSSL_free(d);\\r\\nd = next;\\r\\n}\\r\\n*ex_data = NULL;\\r\\n}\\r\\nvoid EC_EX_DATA_clear_free_all_data(EC_EXTRA_DATA **ex_data)\\r\\n{\\r\\nEC_EXTRA_DATA *d;\\r\\nif (ex_data == NULL)\\r\\nreturn;\\r\\nd = *ex_data;\\r\\nwhile (d) {\\r\\nEC_EXTRA_DATA *next = d->next;\\r\\nd->clear_free_func(d->data);\\r\\nOPENSSL_free(d);\\r\\nd = next;\\r\\n}\\r\\n*ex_data = NULL;\\r\\n}\\r\\nEC_POINT *EC_POINT_new(const EC_GROUP *group)\\r\\n{\\r\\nEC_POINT *ret;\\r\\nif (group == NULL) {\\r\\nECerr(EC_F_EC_POINT_NEW, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (group->meth->point_init == 0) {\\r\\nECerr(EC_F_EC_POINT_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn NULL;\\r\\n}\\r\\nret = OPENSSL_malloc(sizeof *ret);\\r\\nif (ret == NULL) {\\r\\nECerr(EC_F_EC_POINT_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->meth = group->meth;\\r\\nif (!ret->meth->point_init(ret)) {\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid EC_POINT_free(EC_POINT *point)\\r\\n{\\r\\nif (!point)\\r\\nreturn;\\r\\nif (point->meth->point_finish != 0)\\r\\npoint->meth->point_finish(point);\\r\\nOPENSSL_free(point);\\r\\n}\\r\\nvoid EC_POINT_clear_free(EC_POINT *point)\\r\\n{\\r\\nif (!point)\\r\\nreturn;\\r\\nif (point->meth->point_clear_finish != 0)\\r\\npoint->meth->point_clear_finish(point);\\r\\nelse if (point->meth->point_finish != 0)\\r\\npoint->meth->point_finish(point);\\r\\nOPENSSL_cleanse(point, sizeof *point);\\r\\nOPENSSL_free(point);\\r\\n}\\r\\nint EC_POINT_copy(EC_POINT *dest, const EC_POINT *src)\\r\\n{\\r\\nif (dest->meth->point_copy == 0) {\\r\\nECerr(EC_F_EC_POINT_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (dest->meth != src->meth) {\\r\\nECerr(EC_F_EC_POINT_COPY, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif (dest == src)\\r\\nreturn 1;\\r\\nreturn dest->meth->point_copy(dest, src);\\r\\n}\\r\\nEC_POINT *EC_POINT_dup(const EC_POINT *a, const EC_GROUP *group)\\r\\n{\\r\\nEC_POINT *t;\\r\\nint r;\\r\\nif (a == NULL)\\r\\nreturn NULL;\\r\\nt = EC_POINT_new(group);\\r\\nif (t == NULL)\\r\\nreturn (NULL);\\r\\nr = EC_POINT_copy(t, a);\\r\\nif (!r) {\\r\\nEC_POINT_free(t);\\r\\nreturn NULL;\\r\\n} else\\r\\nreturn t;\\r\\n}\\r\\nconst EC_METHOD *EC_POINT_method_of(const EC_POINT *point)\\r\\n{\\r\\nreturn point->meth;\\r\\n}\\r\\nint EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point)\\r\\n{\\r\\nif (group->meth->point_set_to_infinity == 0) {\\r\\nECerr(EC_F_EC_POINT_SET_TO_INFINITY,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_SET_TO_INFINITY, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_to_infinity(group, point);\\r\\n}\\r\\nint EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,\\r\\nEC_POINT *point, const BIGNUM *x,\\r\\nconst BIGNUM *y, const BIGNUM *z,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_Jprojective_coordinates_GFp == 0) {\\r\\nECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,\\r\\nEC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_Jprojective_coordinates_GFp(group, point, x,\\r\\ny, z, ctx);\\r\\n}\\r\\nint EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,\\r\\nconst EC_POINT *point, BIGNUM *x,\\r\\nBIGNUM *y, BIGNUM *z,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_get_Jprojective_coordinates_GFp == 0) {\\r\\nECerr(EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP,\\r\\nEC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_get_Jprojective_coordinates_GFp(group, point, x,\\r\\ny, z, ctx);\\r\\n}\\r\\nint EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group,\\r\\nEC_POINT *point, const BIGNUM *x,\\r\\nconst BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_affine_coordinates == 0) {\\r\\nECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP,\\r\\nEC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_affine_coordinates(group, point, x, y, ctx);\\r\\n}\\r\\nint EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group,\\r\\nEC_POINT *point, const BIGNUM *x,\\r\\nconst BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_affine_coordinates == 0) {\\r\\nECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M,\\r\\nEC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_set_affine_coordinates(group, point, x, y, ctx);\\r\\n}\\r\\nint EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group,\\r\\nconst EC_POINT *point, BIGNUM *x,\\r\\nBIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_get_affine_coordinates == 0) {\\r\\nECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP,\\r\\nEC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_get_affine_coordinates(group, point, x, y, ctx);\\r\\n}\\r\\nint EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group,\\r\\nconst EC_POINT *point, BIGNUM *x,\\r\\nBIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_get_affine_coordinates == 0) {\\r\\nECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M,\\r\\nEC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->point_get_affine_coordinates(group, point, x, y, ctx);\\r\\n}\\r\\nint EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\\r\\nconst EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->add == 0) {\\r\\nECerr(EC_F_EC_POINT_ADD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif ((group->meth != r->meth) || (r->meth != a->meth)\\r\\n|| (a->meth != b->meth)) {\\r\\nECerr(EC_F_EC_POINT_ADD, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->add(group, r, a, b, ctx);\\r\\n}\\r\\nint EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->dbl == 0) {\\r\\nECerr(EC_F_EC_POINT_DBL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif ((group->meth != r->meth) || (r->meth != a->meth)) {\\r\\nECerr(EC_F_EC_POINT_DBL, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->dbl(group, r, a, ctx);\\r\\n}\\r\\nint EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->invert == 0) {\\r\\nECerr(EC_F_EC_POINT_INVERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != a->meth) {\\r\\nECerr(EC_F_EC_POINT_INVERT, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->invert(group, a, ctx);\\r\\n}\\r\\nint EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)\\r\\n{\\r\\nif (group->meth->is_at_infinity == 0) {\\r\\nECerr(EC_F_EC_POINT_IS_AT_INFINITY,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_IS_AT_INFINITY, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->is_at_infinity(group, point);\\r\\n}\\r\\nint EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->is_on_curve == 0) {\\r\\nECerr(EC_F_EC_POINT_IS_ON_CURVE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_IS_ON_CURVE, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->is_on_curve(group, point, ctx);\\r\\n}\\r\\nint EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_cmp == 0) {\\r\\nECerr(EC_F_EC_POINT_CMP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn -1;\\r\\n}\\r\\nif ((group->meth != a->meth) || (a->meth != b->meth)) {\\r\\nECerr(EC_F_EC_POINT_CMP, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn -1;\\r\\n}\\r\\nreturn group->meth->point_cmp(group, a, b, ctx);\\r\\n}\\r\\nint EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->make_affine == 0) {\\r\\nECerr(EC_F_EC_POINT_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nreturn group->meth->make_affine(group, point, ctx);\\r\\n}\\r\\nint EC_POINTs_make_affine(const EC_GROUP *group, size_t num,\\r\\nEC_POINT *points[], BN_CTX *ctx)\\r\\n{\\r\\nsize_t i;\\r\\nif (group->meth->points_make_affine == 0) {\\r\\nECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < num; i++) {\\r\\nif (group->meth != points[i]->meth) {\\r\\nECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn group->meth->points_make_affine(group, num, points, ctx);\\r\\n}\\r\\nint EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar,\\r\\nsize_t num, const EC_POINT *points[],\\r\\nconst BIGNUM *scalars[], BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->mul == 0)\\r\\nreturn ec_wNAF_mul(group, r, scalar, num, points, scalars, ctx);\\r\\nreturn group->meth->mul(group, r, scalar, num, points, scalars, ctx);\\r\\n}\\r\\nint EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,\\r\\nconst EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)\\r\\n{\\r\\nconst EC_POINT *points[1];\\r\\nconst BIGNUM *scalars[1];\\r\\npoints[0] = point;\\r\\nscalars[0] = p_scalar;\\r\\nreturn EC_POINTs_mul(group, r, g_scalar,\\r\\n(point != NULL\\r\\n&& p_scalar != NULL), points, scalars, ctx);\\r\\n}\\r\\nint EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->mul == 0)\\r\\nreturn ec_wNAF_precompute_mult(group, ctx);\\r\\nif (group->meth->precompute_mult != 0)\\r\\nreturn group->meth->precompute_mult(group, ctx);\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint EC_GROUP_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nif (group->meth->mul == 0)\\r\\nreturn ec_wNAF_have_precompute_mult(group);\\r\\nif (group->meth->have_precompute_mult != 0)\\r\\nreturn group->meth->have_precompute_mult(group);\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint ec_precompute_mont_data(EC_GROUP *group)\\r\\n{\\r\\nBN_CTX *ctx = BN_CTX_new();\\r\\nint ret = 0;\\r\\nif (!EC_GROUP_VERSION(group))\\r\\ngoto err;\\r\\nif (group->mont_data) {\\r\\nBN_MONT_CTX_free(group->mont_data);\\r\\ngroup->mont_data = NULL;\\r\\n}\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\ngroup->mont_data = BN_MONT_CTX_new();\\r\\nif (!group->mont_data)\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(group->mont_data, &group->order, ctx)) {\\r\\nBN_MONT_CTX_free(group->mont_data);\\r\\ngroup->mont_data = NULL;\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_null_c", "target": 0, "func": "const EVP_CIPHER *EVP_enc_null(void)\\r\\n{\\r\\nreturn (&n_cipher);\\r\\n}\\r\\nstatic int null_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int null_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nif (in != out)\\r\\nmemcpy((char *)out, (const char *)in, inl);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rmd_dgst_c", "target": 0, "func": "void ripemd160_block_data_order(RIPEMD160_CTX *ctx, const void *p, size_t num)\\r\\n{\\r\\nconst unsigned char *data = p;\\r\\nregister unsigned MD32_REG_T A, B, C, D, E;\\r\\nunsigned MD32_REG_T a, b, c, d, e, l;\\r\\n# ifndef MD32_XARRAY\\r\\nunsigned MD32_REG_T XX0, XX1, XX2, XX3, XX4, XX5, XX6, XX7,\\r\\nXX8, XX9, XX10, XX11, XX12, XX13, XX14, XX15;\\r\\n# define X(i) XX##i\\r\\n# else\\r\\nRIPEMD160_LONG XX[16];\\r\\n# define X(i) XX[i]\\r\\n# endif\\r\\nfor (; num--;) {\\r\\nA = ctx->A;\\r\\nB = ctx->B;\\r\\nC = ctx->C;\\r\\nD = ctx->D;\\r\\nE = ctx->E;\\r\\n(void)HOST_c2l(data, l);\\r\\nX(0) = l;\\r\\n(void)HOST_c2l(data, l);\\r\\nX(1) = l;\\r\\nRIP1(A, B, C, D, E, WL00, SL00);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(2) = l;\\r\\nRIP1(E, A, B, C, D, WL01, SL01);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(3) = l;\\r\\nRIP1(D, E, A, B, C, WL02, SL02);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(4) = l;\\r\\nRIP1(C, D, E, A, B, WL03, SL03);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(5) = l;\\r\\nRIP1(B, C, D, E, A, WL04, SL04);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(6) = l;\\r\\nRIP1(A, B, C, D, E, WL05, SL05);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(7) = l;\\r\\nRIP1(E, A, B, C, D, WL06, SL06);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(8) = l;\\r\\nRIP1(D, E, A, B, C, WL07, SL07);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(9) = l;\\r\\nRIP1(C, D, E, A, B, WL08, SL08);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(10) = l;\\r\\nRIP1(B, C, D, E, A, WL09, SL09);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(11) = l;\\r\\nRIP1(A, B, C, D, E, WL10, SL10);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(12) = l;\\r\\nRIP1(E, A, B, C, D, WL11, SL11);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(13) = l;\\r\\nRIP1(D, E, A, B, C, WL12, SL12);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(14) = l;\\r\\nRIP1(C, D, E, A, B, WL13, SL13);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(15) = l;\\r\\nRIP1(B, C, D, E, A, WL14, SL14);\\r\\nRIP1(A, B, C, D, E, WL15, SL15);\\r\\nRIP2(E, A, B, C, D, WL16, SL16, KL1);\\r\\nRIP2(D, E, A, B, C, WL17, SL17, KL1);\\r\\nRIP2(C, D, E, A, B, WL18, SL18, KL1);\\r\\nRIP2(B, C, D, E, A, WL19, SL19, KL1);\\r\\nRIP2(A, B, C, D, E, WL20, SL20, KL1);\\r\\nRIP2(E, A, B, C, D, WL21, SL21, KL1);\\r\\nRIP2(D, E, A, B, C, WL22, SL22, KL1);\\r\\nRIP2(C, D, E, A, B, WL23, SL23, KL1);\\r\\nRIP2(B, C, D, E, A, WL24, SL24, KL1);\\r\\nRIP2(A, B, C, D, E, WL25, SL25, KL1);\\r\\nRIP2(E, A, B, C, D, WL26, SL26, KL1);\\r\\nRIP2(D, E, A, B, C, WL27, SL27, KL1);\\r\\nRIP2(C, D, E, A, B, WL28, SL28, KL1);\\r\\nRIP2(B, C, D, E, A, WL29, SL29, KL1);\\r\\nRIP2(A, B, C, D, E, WL30, SL30, KL1);\\r\\nRIP2(E, A, B, C, D, WL31, SL31, KL1);\\r\\nRIP3(D, E, A, B, C, WL32, SL32, KL2);\\r\\nRIP3(C, D, E, A, B, WL33, SL33, KL2);\\r\\nRIP3(B, C, D, E, A, WL34, SL34, KL2);\\r\\nRIP3(A, B, C, D, E, WL35, SL35, KL2);\\r\\nRIP3(E, A, B, C, D, WL36, SL36, KL2);\\r\\nRIP3(D, E, A, B, C, WL37, SL37, KL2);\\r\\nRIP3(C, D, E, A, B, WL38, SL38, KL2);\\r\\nRIP3(B, C, D, E, A, WL39, SL39, KL2);\\r\\nRIP3(A, B, C, D, E, WL40, SL40, KL2);\\r\\nRIP3(E, A, B, C, D, WL41, SL41, KL2);\\r\\nRIP3(D, E, A, B, C, WL42, SL42, KL2);\\r\\nRIP3(C, D, E, A, B, WL43, SL43, KL2);\\r\\nRIP3(B, C, D, E, A, WL44, SL44, KL2);\\r\\nRIP3(A, B, C, D, E, WL45, SL45, KL2);\\r\\nRIP3(E, A, B, C, D, WL46, SL46, KL2);\\r\\nRIP3(D, E, A, B, C, WL47, SL47, KL2);\\r\\nRIP4(C, D, E, A, B, WL48, SL48, KL3);\\r\\nRIP4(B, C, D, E, A, WL49, SL49, KL3);\\r\\nRIP4(A, B, C, D, E, WL50, SL50, KL3);\\r\\nRIP4(E, A, B, C, D, WL51, SL51, KL3);\\r\\nRIP4(D, E, A, B, C, WL52, SL52, KL3);\\r\\nRIP4(C, D, E, A, B, WL53, SL53, KL3);\\r\\nRIP4(B, C, D, E, A, WL54, SL54, KL3);\\r\\nRIP4(A, B, C, D, E, WL55, SL55, KL3);\\r\\nRIP4(E, A, B, C, D, WL56, SL56, KL3);\\r\\nRIP4(D, E, A, B, C, WL57, SL57, KL3);\\r\\nRIP4(C, D, E, A, B, WL58, SL58, KL3);\\r\\nRIP4(B, C, D, E, A, WL59, SL59, KL3);\\r\\nRIP4(A, B, C, D, E, WL60, SL60, KL3);\\r\\nRIP4(E, A, B, C, D, WL61, SL61, KL3);\\r\\nRIP4(D, E, A, B, C, WL62, SL62, KL3);\\r\\nRIP4(C, D, E, A, B, WL63, SL63, KL3);\\r\\nRIP5(B, C, D, E, A, WL64, SL64, KL4);\\r\\nRIP5(A, B, C, D, E, WL65, SL65, KL4);\\r\\nRIP5(E, A, B, C, D, WL66, SL66, KL4);\\r\\nRIP5(D, E, A, B, C, WL67, SL67, KL4);\\r\\nRIP5(C, D, E, A, B, WL68, SL68, KL4);\\r\\nRIP5(B, C, D, E, A, WL69, SL69, KL4);\\r\\nRIP5(A, B, C, D, E, WL70, SL70, KL4);\\r\\nRIP5(E, A, B, C, D, WL71, SL71, KL4);\\r\\nRIP5(D, E, A, B, C, WL72, SL72, KL4);\\r\\nRIP5(C, D, E, A, B, WL73, SL73, KL4);\\r\\nRIP5(B, C, D, E, A, WL74, SL74, KL4);\\r\\nRIP5(A, B, C, D, E, WL75, SL75, KL4);\\r\\nRIP5(E, A, B, C, D, WL76, SL76, KL4);\\r\\nRIP5(D, E, A, B, C, WL77, SL77, KL4);\\r\\nRIP5(C, D, E, A, B, WL78, SL78, KL4);\\r\\nRIP5(B, C, D, E, A, WL79, SL79, KL4);\\r\\na = A;\\r\\nb = B;\\r\\nc = C;\\r\\nd = D;\\r\\ne = E;\\r\\nA = ctx->A;\\r\\nB = ctx->B;\\r\\nC = ctx->C;\\r\\nD = ctx->D;\\r\\nE = ctx->E;\\r\\nRIP5(A, B, C, D, E, WR00, SR00, KR0);\\r\\nRIP5(E, A, B, C, D, WR01, SR01, KR0);\\r\\nRIP5(D, E, A, B, C, WR02, SR02, KR0);\\r\\nRIP5(C, D, E, A, B, WR03, SR03, KR0);\\r\\nRIP5(B, C, D, E, A, WR04, SR04, KR0);\\r\\nRIP5(A, B, C, D, E, WR05, SR05, KR0);\\r\\nRIP5(E, A, B, C, D, WR06, SR06, KR0);\\r\\nRIP5(D, E, A, B, C, WR07, SR07, KR0);\\r\\nRIP5(C, D, E, A, B, WR08, SR08, KR0);\\r\\nRIP5(B, C, D, E, A, WR09, SR09, KR0);\\r\\nRIP5(A, B, C, D, E, WR10, SR10, KR0);\\r\\nRIP5(E, A, B, C, D, WR11, SR11, KR0);\\r\\nRIP5(D, E, A, B, C, WR12, SR12, KR0);\\r\\nRIP5(C, D, E, A, B, WR13, SR13, KR0);\\r\\nRIP5(B, C, D, E, A, WR14, SR14, KR0);\\r\\nRIP5(A, B, C, D, E, WR15, SR15, KR0);\\r\\nRIP4(E, A, B, C, D, WR16, SR16, KR1);\\r\\nRIP4(D, E, A, B, C, WR17, SR17, KR1);\\r\\nRIP4(C, D, E, A, B, WR18, SR18, KR1);\\r\\nRIP4(B, C, D, E, A, WR19, SR19, KR1);\\r\\nRIP4(A, B, C, D, E, WR20, SR20, KR1);\\r\\nRIP4(E, A, B, C, D, WR21, SR21, KR1);\\r\\nRIP4(D, E, A, B, C, WR22, SR22, KR1);\\r\\nRIP4(C, D, E, A, B, WR23, SR23, KR1);\\r\\nRIP4(B, C, D, E, A, WR24, SR24, KR1);\\r\\nRIP4(A, B, C, D, E, WR25, SR25, KR1);\\r\\nRIP4(E, A, B, C, D, WR26, SR26, KR1);\\r\\nRIP4(D, E, A, B, C, WR27, SR27, KR1);\\r\\nRIP4(C, D, E, A, B, WR28, SR28, KR1);\\r\\nRIP4(B, C, D, E, A, WR29, SR29, KR1);\\r\\nRIP4(A, B, C, D, E, WR30, SR30, KR1);\\r\\nRIP4(E, A, B, C, D, WR31, SR31, KR1);\\r\\nRIP3(D, E, A, B, C, WR32, SR32, KR2);\\r\\nRIP3(C, D, E, A, B, WR33, SR33, KR2);\\r\\nRIP3(B, C, D, E, A, WR34, SR34, KR2);\\r\\nRIP3(A, B, C, D, E, WR35, SR35, KR2);\\r\\nRIP3(E, A, B, C, D, WR36, SR36, KR2);\\r\\nRIP3(D, E, A, B, C, WR37, SR37, KR2);\\r\\nRIP3(C, D, E, A, B, WR38, SR38, KR2);\\r\\nRIP3(B, C, D, E, A, WR39, SR39, KR2);\\r\\nRIP3(A, B, C, D, E, WR40, SR40, KR2);\\r\\nRIP3(E, A, B, C, D, WR41, SR41, KR2);\\r\\nRIP3(D, E, A, B, C, WR42, SR42, KR2);\\r\\nRIP3(C, D, E, A, B, WR43, SR43, KR2);\\r\\nRIP3(B, C, D, E, A, WR44, SR44, KR2);\\r\\nRIP3(A, B, C, D, E, WR45, SR45, KR2);\\r\\nRIP3(E, A, B, C, D, WR46, SR46, KR2);\\r\\nRIP3(D, E, A, B, C, WR47, SR47, KR2);\\r\\nRIP2(C, D, E, A, B, WR48, SR48, KR3);\\r\\nRIP2(B, C, D, E, A, WR49, SR49, KR3);\\r\\nRIP2(A, B, C, D, E, WR50, SR50, KR3);\\r\\nRIP2(E, A, B, C, D, WR51, SR51, KR3);\\r\\nRIP2(D, E, A, B, C, WR52, SR52, KR3);\\r\\nRIP2(C, D, E, A, B, WR53, SR53, KR3);\\r\\nRIP2(B, C, D, E, A, WR54, SR54, KR3);\\r\\nRIP2(A, B, C, D, E, WR55, SR55, KR3);\\r\\nRIP2(E, A, B, C, D, WR56, SR56, KR3);\\r\\nRIP2(D, E, A, B, C, WR57, SR57, KR3);\\r\\nRIP2(C, D, E, A, B, WR58, SR58, KR3);\\r\\nRIP2(B, C, D, E, A, WR59, SR59, KR3);\\r\\nRIP2(A, B, C, D, E, WR60, SR60, KR3);\\r\\nRIP2(E, A, B, C, D, WR61, SR61, KR3);\\r\\nRIP2(D, E, A, B, C, WR62, SR62, KR3);\\r\\nRIP2(C, D, E, A, B, WR63, SR63, KR3);\\r\\nRIP1(B, C, D, E, A, WR64, SR64);\\r\\nRIP1(A, B, C, D, E, WR65, SR65);\\r\\nRIP1(E, A, B, C, D, WR66, SR66);\\r\\nRIP1(D, E, A, B, C, WR67, SR67);\\r\\nRIP1(C, D, E, A, B, WR68, SR68);\\r\\nRIP1(B, C, D, E, A, WR69, SR69);\\r\\nRIP1(A, B, C, D, E, WR70, SR70);\\r\\nRIP1(E, A, B, C, D, WR71, SR71);\\r\\nRIP1(D, E, A, B, C, WR72, SR72);\\r\\nRIP1(C, D, E, A, B, WR73, SR73);\\r\\nRIP1(B, C, D, E, A, WR74, SR74);\\r\\nRIP1(A, B, C, D, E, WR75, SR75);\\r\\nRIP1(E, A, B, C, D, WR76, SR76);\\r\\nRIP1(D, E, A, B, C, WR77, SR77);\\r\\nRIP1(C, D, E, A, B, WR78, SR78);\\r\\nRIP1(B, C, D, E, A, WR79, SR79);\\r\\nD = ctx->B + c + D;\\r\\nctx->B = ctx->C + d + E;\\r\\nctx->C = ctx->D + e + A;\\r\\nctx->D = ctx->E + a + B;\\r\\nctx->E = ctx->A + b + C;\\r\\nctx->A = D;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_cast_c", "target": 0, "func": "static int cast_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nCAST_set_key(&data(ctx)->ks, EVP_CIPHER_CTX_key_length(ctx), key);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_s_time_c", "target": 0, "func": "static void s_time_init(void)\\r\\n{\\r\\nhost = SSL_CONNECT_NAME;\\r\\nt_cert_file = NULL;\\r\\nt_key_file = NULL;\\r\\nCApath = NULL;\\r\\nCAfile = NULL;\\r\\ntm_cipher = NULL;\\r\\ntm_verify = SSL_VERIFY_NONE;\\r\\nmaxTime = SECONDS;\\r\\ntm_ctx = NULL;\\r\\ns_time_meth = NULL;\\r\\ns_www_path = NULL;\\r\\nbytes_read = 0;\\r\\nst_bugs = 0;\\r\\nperform = 0;\\r\\n#ifdef FIONBIO\\r\\nt_nbio = 0;\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_WIN32\\r\\nexitNow = 0;\\r\\n#endif\\r\\n}\\r\\nstatic void s_time_usage(void)\\r\\n{\\r\\nstatic char umsg[] = \"\\\\r\\n-time arg - max number of seconds to collect data, default %d\\n\\\\r\\n-verify arg - turn on peer certificate verification, arg == depth\\n\\\\r\\n-cert arg - certificate file to use, PEM format assumed\\n\\\\r\\n-key arg - RSA file to use, PEM format assumed, key is in cert file\\n\\\\r\\nfile if not specified by this option\\n\\\\r\\n-CApath arg - PEM format directory of CA's\\n\\\\r\\n-CAfile arg - PEM format file of CA's\\n\\\\r\\n-cipher - preferred cipher to use, play with 'openssl ciphers'\\n\\n\";\\r\\nprintf(\"usage: s_time <args>\\n\\n\");\\r\\nprintf(\"-connect host:port - host:port to connect to (default is %s)\\n\",\\r\\nSSL_CONNECT_NAME);\\r\\n#ifdef FIONBIO\\r\\nprintf(\"-nbio - Run with non-blocking IO\\n\");\\r\\nprintf(\"-ssl2 - Just use SSLv2\\n\");\\r\\nprintf(\"-ssl3 - Just use SSLv3\\n\");\\r\\nprintf(\"-bugs - Turn on SSL bug compatibility\\n\");\\r\\nprintf(\"-new - Just time new connections\\n\");\\r\\nprintf(\"-reuse - Just time connection reuse\\n\");\\r\\nprintf(\"-www page - Retrieve 'page' from the site\\n\");\\r\\n#endif\\r\\nprintf(umsg, SECONDS);\\r\\n}\\r\\nstatic int parseArgs(int argc, char **argv)\\r\\n{\\r\\nint badop = 0;\\r\\nverify_depth = 0;\\r\\nverify_error = X509_V_OK;\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-connect\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nhost = *(++argv);\\r\\n}\\r\\n#if 0\\r\\nelse if (strcmp(*argv, \"-host\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nhost = *(++argv);\\r\\n} else if (strcmp(*argv, \"-port\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nport = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-reuse\") == 0)\\r\\nperform = 2;\\r\\nelse if (strcmp(*argv, \"-new\") == 0)\\r\\nperform = 1;\\r\\nelse if (strcmp(*argv, \"-verify\") == 0) {\\r\\ntm_verify = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nverify_depth = atoi(*(++argv));\\r\\nBIO_printf(bio_err, \"verify depth is %d\\n\", verify_depth);\\r\\n} else if (strcmp(*argv, \"-cert\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nt_cert_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-key\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nt_key_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-CApath\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCApath = *(++argv);\\r\\n} else if (strcmp(*argv, \"-CAfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCAfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-cipher\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ntm_cipher = *(++argv);\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nelse if (strcmp(*argv, \"-nbio\") == 0) {\\r\\nt_nbio = 1;\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-www\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_www_path = *(++argv);\\r\\nif (strlen(s_www_path) > MYBUFSIZ - 100) {\\r\\nBIO_printf(bio_err, \"-www option too long\\n\");\\r\\nbadop = 1;\\r\\n}\\r\\n} else if (strcmp(*argv, \"-bugs\") == 0)\\r\\nst_bugs = 1;\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nelse if (strcmp(*argv, \"-ssl2\") == 0)\\r\\ns_time_meth = SSLv2_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\nelse if (strcmp(*argv, \"-ssl3\") == 0)\\r\\ns_time_meth = SSLv3_client_method();\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-time\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nmaxTime = atoi(*(++argv));\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadop = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (perform == 0)\\r\\nperform = 3;\\r\\nif (badop) {\\r\\nbad:\\r\\ns_time_usage();\\r\\nreturn -1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic double tm_Time_F(int s)\\r\\n{\\r\\nreturn app_tminterval(s, 1);\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\ndouble totalTime = 0.0;\\r\\nint nConn = 0;\\r\\nSSL *scon = NULL;\\r\\nlong finishtime = 0;\\r\\nint ret = 1, i;\\r\\nMS_STATIC char buf[1024 * 8];\\r\\nint ver;\\r\\napps_startup();\\r\\ns_time_init();\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\ns_time_meth = SSLv23_client_method();\\r\\nif (parseArgs(argc, argv) < 0)\\r\\ngoto end;\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nif ((tm_ctx = SSL_CTX_new(s_time_meth)) == NULL)\\r\\nreturn (1);\\r\\nSSL_CTX_set_quiet_shutdown(tm_ctx, 1);\\r\\nif (st_bugs)\\r\\nSSL_CTX_set_options(tm_ctx, SSL_OP_ALL);\\r\\nSSL_CTX_set_cipher_list(tm_ctx, tm_cipher);\\r\\nif (!set_cert_stuff(tm_ctx, t_cert_file, t_key_file))\\r\\ngoto end;\\r\\nSSL_load_error_strings();\\r\\nif ((!SSL_CTX_load_verify_locations(tm_ctx, CAfile, CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(tm_ctx))) {\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif (tm_cipher == NULL)\\r\\ntm_cipher = getenv(\"SSL_CIPHER\");\\r\\nif (tm_cipher == NULL) {\\r\\nfprintf(stderr, \"No CIPHER specified\\n\");\\r\\n}\\r\\nif (!(perform & 1))\\r\\ngoto next;\\r\\nprintf(\"Collecting connection statistics for %d seconds\\n\", maxTime);\\r\\nbytes_read = 0;\\r\\nfinishtime = (long)time(NULL) + maxTime;\\r\\ntm_Time_F(START);\\r\\nfor (;;) {\\r\\nif (finishtime < (long)time(NULL))\\r\\nbreak;\\r\\n#ifdef WIN32_STUFF\\r\\nif (flushWinMsgs(0) == -1)\\r\\ngoto end;\\r\\nif (waitingToDie || exitNow)\\r\\ngoto end;\\r\\n#endif\\r\\nif ((scon = doConnection(NULL)) == NULL)\\r\\ngoto end;\\r\\nif (s_www_path != NULL) {\\r\\nBIO_snprintf(buf, sizeof buf, \"GET %s HTTP/1.0\\r\\n\\r\\n\",\\r\\ns_www_path);\\r\\nSSL_write(scon, buf, strlen(buf));\\r\\nwhile ((i = SSL_read(scon, buf, sizeof(buf))) > 0)\\r\\nbytes_read += i;\\r\\n}\\r\\n#ifdef NO_SHUTDOWN\\r\\nSSL_set_shutdown(scon, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(scon);\\r\\n#endif\\r\\nSHUTDOWN2(SSL_get_fd(scon));\\r\\nnConn += 1;\\r\\nif (SSL_session_reused(scon))\\r\\nver = 'r';\\r\\nelse {\\r\\nver = SSL_version(scon);\\r\\nif (ver == TLS1_VERSION)\\r\\nver = 't';\\r\\nelse if (ver == SSL3_VERSION)\\r\\nver = '3';\\r\\nelse if (ver == SSL2_VERSION)\\r\\nver = '2';\\r\\nelse\\r\\nver = '*';\\r\\n}\\r\\nfputc(ver, stdout);\\r\\nfflush(stdout);\\r\\nSSL_free(scon);\\r\\nscon = NULL;\\r\\n}\\r\\ntotalTime += tm_Time_F(STOP);\\r\\ni = (int)((long)time(NULL) - finishtime + maxTime);\\r\\nprintf\\r\\n(\"\\n\\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\\n\",\\r\\nnConn, totalTime, ((double)nConn / totalTime), bytes_read);\\r\\nprintf\\r\\n(\"%d connections in %ld real seconds, %ld bytes read per connection\\n\",\\r\\nnConn, (long)time(NULL) - finishtime + maxTime, bytes_read / nConn);\\r\\nnext:\\r\\nif (!(perform & 2))\\r\\ngoto end;\\r\\nprintf(\"\\n\\nNow timing with session id reuse.\\n\");\\r\\nif ((scon = doConnection(NULL)) == NULL) {\\r\\nfprintf(stderr, \"Unable to get connection\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (s_www_path != NULL) {\\r\\nBIO_snprintf(buf, sizeof buf, \"GET %s HTTP/1.0\\r\\n\\r\\n\", s_www_path);\\r\\nSSL_write(scon, buf, strlen(buf));\\r\\nwhile (SSL_read(scon, buf, sizeof(buf)) > 0) ;\\r\\n}\\r\\n#ifdef NO_SHUTDOWN\\r\\nSSL_set_shutdown(scon, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(scon);\\r\\n#endif\\r\\nSHUTDOWN2(SSL_get_fd(scon));\\r\\nnConn = 0;\\r\\ntotalTime = 0.0;\\r\\nfinishtime = (long)time(NULL) + maxTime;\\r\\nprintf(\"starting\\n\");\\r\\nbytes_read = 0;\\r\\ntm_Time_F(START);\\r\\nfor (;;) {\\r\\nif (finishtime < (long)time(NULL))\\r\\nbreak;\\r\\n#ifdef WIN32_STUFF\\r\\nif (flushWinMsgs(0) == -1)\\r\\ngoto end;\\r\\nif (waitingToDie || exitNow)\\r\\ngoto end;\\r\\n#endif\\r\\nif ((doConnection(scon)) == NULL)\\r\\ngoto end;\\r\\nif (s_www_path) {\\r\\nBIO_snprintf(buf, sizeof buf, \"GET %s HTTP/1.0\\r\\n\\r\\n\",\\r\\ns_www_path);\\r\\nSSL_write(scon, buf, strlen(buf));\\r\\nwhile ((i = SSL_read(scon, buf, sizeof(buf))) > 0)\\r\\nbytes_read += i;\\r\\n}\\r\\n#ifdef NO_SHUTDOWN\\r\\nSSL_set_shutdown(scon, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(scon);\\r\\n#endif\\r\\nSHUTDOWN2(SSL_get_fd(scon));\\r\\nnConn += 1;\\r\\nif (SSL_session_reused(scon))\\r\\nver = 'r';\\r\\nelse {\\r\\nver = SSL_version(scon);\\r\\nif (ver == TLS1_VERSION)\\r\\nver = 't';\\r\\nelse if (ver == SSL3_VERSION)\\r\\nver = '3';\\r\\nelse if (ver == SSL2_VERSION)\\r\\nver = '2';\\r\\nelse\\r\\nver = '*';\\r\\n}\\r\\nfputc(ver, stdout);\\r\\nfflush(stdout);\\r\\n}\\r\\ntotalTime += tm_Time_F(STOP);\\r\\nprintf\\r\\n(\"\\n\\n%d connections in %.2fs; %.2f connections/user sec, bytes read %ld\\n\",\\r\\nnConn, totalTime, ((double)nConn / totalTime), bytes_read);\\r\\nprintf\\r\\n(\"%d connections in %ld real seconds, %ld bytes read per connection\\n\",\\r\\nnConn, (long)time(NULL) - finishtime + maxTime, bytes_read / nConn);\\r\\nret = 0;\\r\\nend:\\r\\nif (scon != NULL)\\r\\nSSL_free(scon);\\r\\nif (tm_ctx != NULL) {\\r\\nSSL_CTX_free(tm_ctx);\\r\\ntm_ctx = NULL;\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic SSL *doConnection(SSL *scon)\\r\\n{\\r\\nBIO *conn;\\r\\nSSL *serverCon;\\r\\nint width, i;\\r\\nfd_set readfds;\\r\\nif ((conn = BIO_new(BIO_s_connect())) == NULL)\\r\\nreturn (NULL);\\r\\nBIO_set_conn_hostname(conn, host);\\r\\nif (scon == NULL)\\r\\nserverCon = SSL_new(tm_ctx);\\r\\nelse {\\r\\nserverCon = scon;\\r\\nSSL_set_connect_state(serverCon);\\r\\n}\\r\\nSSL_set_bio(serverCon, conn, conn);\\r\\n#if 0\\r\\nif (scon != NULL)\\r\\nSSL_set_session(serverCon, SSL_get_session(scon));\\r\\n#endif\\r\\nfor (;;) {\\r\\ni = SSL_connect(serverCon);\\r\\nif (BIO_sock_should_retry(i)) {\\r\\nBIO_printf(bio_err, \"DELAY\\n\");\\r\\ni = SSL_get_fd(serverCon);\\r\\nwidth = i + 1;\\r\\nFD_ZERO(&readfds);\\r\\nopenssl_fdset(i, &readfds);\\r\\nselect(width, (void *)&readfds, NULL, NULL, NULL);\\r\\ncontinue;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nif (i <= 0) {\\r\\nBIO_printf(bio_err, \"ERROR\\n\");\\r\\nif (verify_error != X509_V_OK)\\r\\nBIO_printf(bio_err, \"verify error:%s\\n\",\\r\\nX509_verify_cert_error_string(verify_error));\\r\\nelse\\r\\nERR_print_errors(bio_err);\\r\\nif (scon == NULL)\\r\\nSSL_free(serverCon);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn serverCon;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_err_c", "target": 0, "func": "void ERR_load_DSA_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(DSA_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, DSA_str_functs);\\r\\nERR_load_strings(0, DSA_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_conf_err_c", "target": 0, "func": "void ERR_load_CONF_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(CONF_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, CONF_str_functs);\\r\\nERR_load_strings(0, CONF_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_asn1_c", "target": 0, "func": "BIO_METHOD *BIO_f_asn1(void)\\r\\n{\\r\\nreturn (&methods_asn1);\\r\\n}\\r\\nstatic int asn1_bio_new(BIO *b)\\r\\n{\\r\\nBIO_ASN1_BUF_CTX *ctx;\\r\\nctx = OPENSSL_malloc(sizeof(BIO_ASN1_BUF_CTX));\\r\\nif (!ctx)\\r\\nreturn 0;\\r\\nif (!asn1_bio_init(ctx, DEFAULT_ASN1_BUF_SIZE)) {\\r\\nOPENSSL_free(ctx);\\r\\nreturn 0;\\r\\n}\\r\\nb->init = 1;\\r\\nb->ptr = (char *)ctx;\\r\\nb->flags = 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_bio_init(BIO_ASN1_BUF_CTX *ctx, int size)\\r\\n{\\r\\nctx->buf = OPENSSL_malloc(size);\\r\\nif (!ctx->buf)\\r\\nreturn 0;\\r\\nctx->bufsize = size;\\r\\nctx->bufpos = 0;\\r\\nctx->buflen = 0;\\r\\nctx->copylen = 0;\\r\\nctx->asn1_class = V_ASN1_UNIVERSAL;\\r\\nctx->asn1_tag = V_ASN1_OCTET_STRING;\\r\\nctx->ex_buf = 0;\\r\\nctx->ex_pos = 0;\\r\\nctx->ex_len = 0;\\r\\nctx->state = ASN1_STATE_START;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_bio_free(BIO *b)\\r\\n{\\r\\nBIO_ASN1_BUF_CTX *ctx;\\r\\nctx = (BIO_ASN1_BUF_CTX *)b->ptr;\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\nif (ctx->buf)\\r\\nOPENSSL_free(ctx->buf);\\r\\nOPENSSL_free(ctx);\\r\\nb->init = 0;\\r\\nb->ptr = NULL;\\r\\nb->flags = 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_bio_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nBIO_ASN1_BUF_CTX *ctx;\\r\\nint wrmax, wrlen, ret;\\r\\nunsigned char *p;\\r\\nif (!in || (inl < 0) || (b->next_bio == NULL))\\r\\nreturn 0;\\r\\nctx = (BIO_ASN1_BUF_CTX *)b->ptr;\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\nwrlen = 0;\\r\\nret = -1;\\r\\nfor (;;) {\\r\\nswitch (ctx->state) {\\r\\ncase ASN1_STATE_START:\\r\\nif (!asn1_bio_setup_ex(b, ctx, ctx->prefix,\\r\\nASN1_STATE_PRE_COPY, ASN1_STATE_HEADER))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase ASN1_STATE_PRE_COPY:\\r\\nret = asn1_bio_flush_ex(b, ctx, ctx->prefix_free,\\r\\nASN1_STATE_HEADER);\\r\\nif (ret <= 0)\\r\\ngoto done;\\r\\nbreak;\\r\\ncase ASN1_STATE_HEADER:\\r\\nctx->buflen = ASN1_object_size(0, inl, ctx->asn1_tag) - inl;\\r\\nOPENSSL_assert(ctx->buflen <= ctx->bufsize);\\r\\np = ctx->buf;\\r\\nASN1_put_object(&p, 0, inl, ctx->asn1_tag, ctx->asn1_class);\\r\\nctx->copylen = inl;\\r\\nctx->state = ASN1_STATE_HEADER_COPY;\\r\\nbreak;\\r\\ncase ASN1_STATE_HEADER_COPY:\\r\\nret = BIO_write(b->next_bio, ctx->buf + ctx->bufpos, ctx->buflen);\\r\\nif (ret <= 0)\\r\\ngoto done;\\r\\nctx->buflen -= ret;\\r\\nif (ctx->buflen)\\r\\nctx->bufpos += ret;\\r\\nelse {\\r\\nctx->bufpos = 0;\\r\\nctx->state = ASN1_STATE_DATA_COPY;\\r\\n}\\r\\nbreak;\\r\\ncase ASN1_STATE_DATA_COPY:\\r\\nif (inl > ctx->copylen)\\r\\nwrmax = ctx->copylen;\\r\\nelse\\r\\nwrmax = inl;\\r\\nret = BIO_write(b->next_bio, in, wrmax);\\r\\nif (ret <= 0)\\r\\nbreak;\\r\\nwrlen += ret;\\r\\nctx->copylen -= ret;\\r\\nin += ret;\\r\\ninl -= ret;\\r\\nif (ctx->copylen == 0)\\r\\nctx->state = ASN1_STATE_HEADER;\\r\\nif (inl == 0)\\r\\ngoto done;\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\ndone:\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (wrlen > 0) ? wrlen : ret;\\r\\n}\\r\\nstatic int asn1_bio_flush_ex(BIO *b, BIO_ASN1_BUF_CTX *ctx,\\r\\nasn1_ps_func *cleanup, asn1_bio_state_t next)\\r\\n{\\r\\nint ret;\\r\\nif (ctx->ex_len <= 0)\\r\\nreturn 1;\\r\\nfor (;;) {\\r\\nret = BIO_write(b->next_bio, ctx->ex_buf + ctx->ex_pos, ctx->ex_len);\\r\\nif (ret <= 0)\\r\\nbreak;\\r\\nctx->ex_len -= ret;\\r\\nif (ctx->ex_len > 0)\\r\\nctx->ex_pos += ret;\\r\\nelse {\\r\\nif (cleanup)\\r\\ncleanup(b, &ctx->ex_buf, &ctx->ex_len, &ctx->ex_arg);\\r\\nctx->state = next;\\r\\nctx->ex_pos = 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int asn1_bio_setup_ex(BIO *b, BIO_ASN1_BUF_CTX *ctx,\\r\\nasn1_ps_func *setup,\\r\\nasn1_bio_state_t ex_state,\\r\\nasn1_bio_state_t other_state)\\r\\n{\\r\\nif (setup && !setup(b, &ctx->ex_buf, &ctx->ex_len, &ctx->ex_arg)) {\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx->ex_len > 0)\\r\\nctx->state = ex_state;\\r\\nelse\\r\\nctx->state = other_state;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_bio_read(BIO *b, char *in, int inl)\\r\\n{\\r\\nif (!b->next_bio)\\r\\nreturn 0;\\r\\nreturn BIO_read(b->next_bio, in, inl);\\r\\n}\\r\\nstatic int asn1_bio_puts(BIO *b, const char *str)\\r\\n{\\r\\nreturn asn1_bio_write(b, str, strlen(str));\\r\\n}\\r\\nstatic int asn1_bio_gets(BIO *b, char *str, int size)\\r\\n{\\r\\nif (!b->next_bio)\\r\\nreturn 0;\\r\\nreturn BIO_gets(b->next_bio, str, size);\\r\\n}\\r\\nstatic long asn1_bio_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nreturn BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\n}\\r\\nstatic long asn1_bio_ctrl(BIO *b, int cmd, long arg1, void *arg2)\\r\\n{\\r\\nBIO_ASN1_BUF_CTX *ctx;\\r\\nBIO_ASN1_EX_FUNCS *ex_func;\\r\\nlong ret = 1;\\r\\nctx = (BIO_ASN1_BUF_CTX *)b->ptr;\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\nswitch (cmd) {\\r\\ncase BIO_C_SET_PREFIX:\\r\\nex_func = arg2;\\r\\nctx->prefix = ex_func->ex_func;\\r\\nctx->prefix_free = ex_func->ex_free_func;\\r\\nbreak;\\r\\ncase BIO_C_GET_PREFIX:\\r\\nex_func = arg2;\\r\\nex_func->ex_func = ctx->prefix;\\r\\nex_func->ex_free_func = ctx->prefix_free;\\r\\nbreak;\\r\\ncase BIO_C_SET_SUFFIX:\\r\\nex_func = arg2;\\r\\nctx->suffix = ex_func->ex_func;\\r\\nctx->suffix_free = ex_func->ex_free_func;\\r\\nbreak;\\r\\ncase BIO_C_GET_SUFFIX:\\r\\nex_func = arg2;\\r\\nex_func->ex_func = ctx->suffix;\\r\\nex_func->ex_free_func = ctx->suffix_free;\\r\\nbreak;\\r\\ncase BIO_C_SET_EX_ARG:\\r\\nctx->ex_arg = arg2;\\r\\nbreak;\\r\\ncase BIO_C_GET_EX_ARG:\\r\\n*(void **)arg2 = ctx->ex_arg;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif (!b->next_bio)\\r\\nreturn 0;\\r\\nif (ctx->state == ASN1_STATE_HEADER) {\\r\\nif (!asn1_bio_setup_ex(b, ctx, ctx->suffix,\\r\\nASN1_STATE_POST_COPY, ASN1_STATE_DONE))\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx->state == ASN1_STATE_POST_COPY) {\\r\\nret = asn1_bio_flush_ex(b, ctx, ctx->suffix_free,\\r\\nASN1_STATE_DONE);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\n}\\r\\nif (ctx->state == ASN1_STATE_DONE)\\r\\nreturn BIO_ctrl(b->next_bio, cmd, arg1, arg2);\\r\\nelse {\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nif (!b->next_bio)\\r\\nreturn 0;\\r\\nreturn BIO_ctrl(b->next_bio, cmd, arg1, arg2);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int asn1_bio_set_ex(BIO *b, int cmd,\\r\\nasn1_ps_func *ex_func, asn1_ps_func *ex_free_func)\\r\\n{\\r\\nBIO_ASN1_EX_FUNCS extmp;\\r\\nextmp.ex_func = ex_func;\\r\\nextmp.ex_free_func = ex_free_func;\\r\\nreturn BIO_ctrl(b, cmd, 0, &extmp);\\r\\n}\\r\\nstatic int asn1_bio_get_ex(BIO *b, int cmd,\\r\\nasn1_ps_func **ex_func,\\r\\nasn1_ps_func **ex_free_func)\\r\\n{\\r\\nBIO_ASN1_EX_FUNCS extmp;\\r\\nint ret;\\r\\nret = BIO_ctrl(b, cmd, 0, &extmp);\\r\\nif (ret > 0) {\\r\\n*ex_func = extmp.ex_func;\\r\\n*ex_free_func = extmp.ex_free_func;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint BIO_asn1_set_prefix(BIO *b, asn1_ps_func *prefix,\\r\\nasn1_ps_func *prefix_free)\\r\\n{\\r\\nreturn asn1_bio_set_ex(b, BIO_C_SET_PREFIX, prefix, prefix_free);\\r\\n}\\r\\nint BIO_asn1_get_prefix(BIO *b, asn1_ps_func **pprefix,\\r\\nasn1_ps_func **pprefix_free)\\r\\n{\\r\\nreturn asn1_bio_get_ex(b, BIO_C_GET_PREFIX, pprefix, pprefix_free);\\r\\n}\\r\\nint BIO_asn1_set_suffix(BIO *b, asn1_ps_func *suffix,\\r\\nasn1_ps_func *suffix_free)\\r\\n{\\r\\nreturn asn1_bio_set_ex(b, BIO_C_SET_SUFFIX, suffix, suffix_free);\\r\\n}\\r\\nint BIO_asn1_get_suffix(BIO *b, asn1_ps_func **psuffix,\\r\\nasn1_ps_func **psuffix_free)\\r\\n{\\r\\nreturn asn1_bio_get_ex(b, BIO_C_GET_SUFFIX, psuffix, psuffix_free);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_init_c", "target": 0, "func": "int engine_unlocked_init(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nif ((e->funct_ref == 0) && e->init)\\r\\nto_return = e->init(e);\\r\\nif (to_return) {\\r\\ne->struct_ref++;\\r\\ne->funct_ref++;\\r\\nengine_ref_debug(e, 0, 1)\\r\\nengine_ref_debug(e, 1, 1)\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nint engine_unlocked_finish(ENGINE *e, int unlock_for_handlers)\\r\\n{\\r\\nint to_return = 1;\\r\\ne->funct_ref--;\\r\\nengine_ref_debug(e, 1, -1);\\r\\nif ((e->funct_ref == 0) && e->finish) {\\r\\nif (unlock_for_handlers)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nto_return = e->finish(e);\\r\\nif (unlock_for_handlers)\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (!to_return)\\r\\nreturn 0;\\r\\n}\\r\\n#ifdef REF_CHECK\\r\\nif (e->funct_ref < 0) {\\r\\nfprintf(stderr, \"ENGINE_finish, bad functional reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (!engine_free_util(e, 0)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_UNLOCKED_FINISH, ENGINE_R_FINISH_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nint ENGINE_init(ENGINE *e)\\r\\n{\\r\\nint ret;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_INIT, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nret = engine_unlocked_init(e);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn ret;\\r\\n}\\r\\nint ENGINE_finish(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_FINISH, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nto_return = engine_unlocked_finish(e, 1);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nif (!to_return) {\\r\\nENGINEerr(ENGINE_F_ENGINE_FINISH, ENGINE_R_FINISH_FAILED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn to_return;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ctr128_c", "target": 0, "func": "static void ctr128_inc(unsigned char *counter)\\r\\n{\\r\\nu32 n = 16;\\r\\nu8 c;\\r\\ndo {\\r\\n--n;\\r\\nc = counter[n];\\r\\n++c;\\r\\ncounter[n] = c;\\r\\nif (c)\\r\\nreturn;\\r\\n} while (n);\\r\\n}\\r\\nstatic void ctr128_inc_aligned(unsigned char *counter)\\r\\n{\\r\\nsize_t *data, c, n;\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nif (is_endian.little) {\\r\\nctr128_inc(counter);\\r\\nreturn;\\r\\n}\\r\\ndata = (size_t *)counter;\\r\\nn = 16 / sizeof(size_t);\\r\\ndo {\\r\\n--n;\\r\\nc = data[n];\\r\\n++c;\\r\\ndata[n] = c;\\r\\nif (c)\\r\\nreturn;\\r\\n} while (n);\\r\\n}\\r\\nvoid CRYPTO_ctr128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16],\\r\\nunsigned char ecount_buf[16], unsigned int *num,\\r\\nblock128_f block)\\r\\n{\\r\\nunsigned int n;\\r\\nsize_t l = 0;\\r\\nassert(in && out && key && ecount_buf && num);\\r\\nassert(*num < 16);\\r\\nn = *num;\\r\\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nif (16 % sizeof(size_t) == 0) {\\r\\ndo {\\r\\nwhile (n && len) {\\r\\n*(out++) = *(in++) ^ ecount_buf[n];\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\n# if defined(STRICT_ALIGNMENT)\\r\\nif (((size_t)in | (size_t)out | (size_t)ivec) % sizeof(size_t) !=\\r\\n0)\\r\\nbreak;\\r\\n# endif\\r\\nwhile (len >= 16) {\\r\\n(*block) (ivec, ecount_buf, key);\\r\\nctr128_inc_aligned(ivec);\\r\\nfor (; n < 16; n += sizeof(size_t))\\r\\n*(size_t *)(out + n) =\\r\\n*(size_t *)(in + n) ^ *(size_t *)(ecount_buf + n);\\r\\nlen -= 16;\\r\\nout += 16;\\r\\nin += 16;\\r\\nn = 0;\\r\\n}\\r\\nif (len) {\\r\\n(*block) (ivec, ecount_buf, key);\\r\\nctr128_inc_aligned(ivec);\\r\\nwhile (len--) {\\r\\nout[n] = in[n] ^ ecount_buf[n];\\r\\n++n;\\r\\n}\\r\\n}\\r\\n*num = n;\\r\\nreturn;\\r\\n} while (0);\\r\\n}\\r\\n#endif\\r\\nwhile (l < len) {\\r\\nif (n == 0) {\\r\\n(*block) (ivec, ecount_buf, key);\\r\\nctr128_inc(ivec);\\r\\n}\\r\\nout[l] = in[l] ^ ecount_buf[n];\\r\\n++l;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\n*num = n;\\r\\n}\\r\\nstatic void ctr96_inc(unsigned char *counter)\\r\\n{\\r\\nu32 n = 12;\\r\\nu8 c;\\r\\ndo {\\r\\n--n;\\r\\nc = counter[n];\\r\\n++c;\\r\\ncounter[n] = c;\\r\\nif (c)\\r\\nreturn;\\r\\n} while (n);\\r\\n}\\r\\nvoid CRYPTO_ctr128_encrypt_ctr32(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16],\\r\\nunsigned char ecount_buf[16],\\r\\nunsigned int *num, ctr128_f func)\\r\\n{\\r\\nunsigned int n, ctr32;\\r\\nassert(in && out && key && ecount_buf && num);\\r\\nassert(*num < 16);\\r\\nn = *num;\\r\\nwhile (n && len) {\\r\\n*(out++) = *(in++) ^ ecount_buf[n];\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\nctr32 = GETU32(ivec + 12);\\r\\nwhile (len >= 16) {\\r\\nsize_t blocks = len / 16;\\r\\nif (sizeof(size_t) > sizeof(unsigned int) && blocks > (1U << 28))\\r\\nblocks = (1U << 28);\\r\\nctr32 += (u32)blocks;\\r\\nif (ctr32 < blocks) {\\r\\nblocks -= ctr32;\\r\\nctr32 = 0;\\r\\n}\\r\\n(*func) (in, out, blocks, key, ivec);\\r\\nPUTU32(ivec + 12, ctr32);\\r\\nif (ctr32 == 0)\\r\\nctr96_inc(ivec);\\r\\nblocks *= 16;\\r\\nlen -= blocks;\\r\\nout += blocks;\\r\\nin += blocks;\\r\\n}\\r\\nif (len) {\\r\\nmemset(ecount_buf, 0, 16);\\r\\n(*func) (ecount_buf, ecount_buf, 1, key, ivec);\\r\\n++ctr32;\\r\\nPUTU32(ivec + 12, ctr32);\\r\\nif (ctr32 == 0)\\r\\nctr96_inc(ivec);\\r\\nwhile (len--) {\\r\\nout[n] = in[n] ^ ecount_buf[n];\\r\\n++n;\\r\\n}\\r\\n}\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_conf_sap_c", "target": 0, "func": "void OPENSSL_config(const char *config_name)\\r\\n{\\r\\nif (openssl_configured)\\r\\nreturn;\\r\\nOPENSSL_load_builtin_modules();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE_load_builtin_engines();\\r\\n#endif\\r\\nERR_clear_error();\\r\\nif (CONF_modules_load_file(NULL, config_name,\\r\\nCONF_MFLAGS_DEFAULT_SECTION |\\r\\nCONF_MFLAGS_IGNORE_MISSING_FILE) <= 0) {\\r\\nBIO *bio_err;\\r\\nERR_load_crypto_strings();\\r\\nif ((bio_err = BIO_new_fp(stderr, BIO_NOCLOSE)) != NULL) {\\r\\nBIO_printf(bio_err, \"Auto configuration failed\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nBIO_free(bio_err);\\r\\n}\\r\\nexit(1);\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nvoid OPENSSL_no_config()\\r\\n{\\r\\nopenssl_configured = 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_gen_c", "target": 1, "func": "int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)\\r\\n&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nRSAerr(RSA_F_RSA_GENERATE_KEY_EX, RSA_R_NON_FIPS_RSA_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nif (rsa->meth->rsa_keygen)\\r\\nreturn rsa->meth->rsa_keygen(rsa, bits, e_value, cb);\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_rsa_generate_key_ex(rsa, bits, e_value, cb);\\r\\n#endif\\r\\nreturn rsa_builtin_keygen(rsa, bits, e_value, cb);\\r\\n}\\r\\nstatic int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,\\r\\nBN_GENCB *cb)\\r\\n{\\r\\nBIGNUM *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *tmp;\\r\\nBIGNUM local_r0, local_d, local_p;\\r\\nBIGNUM *pr0, *d, *p;\\r\\nint bitsp, bitsq, ok = -1, n = 0;\\r\\nBN_CTX *ctx = NULL;\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\nBN_CTX_start(ctx);\\r\\nr0 = BN_CTX_get(ctx);\\r\\nr1 = BN_CTX_get(ctx);\\r\\nr2 = BN_CTX_get(ctx);\\r\\nr3 = BN_CTX_get(ctx);\\r\\nif (r3 == NULL)\\r\\ngoto err;\\r\\nbitsp = (bits + 1) / 2;\\r\\nbitsq = bits - bitsp;\\r\\nif (!rsa->n && ((rsa->n = BN_new()) == NULL))\\r\\ngoto err;\\r\\nif (!rsa->d && ((rsa->d = BN_new()) == NULL))\\r\\ngoto err;\\r\\nif (!rsa->e && ((rsa->e = BN_new()) == NULL))\\r\\ngoto err;\\r\\nif (!rsa->p && ((rsa->p = BN_new()) == NULL))\\r\\ngoto err;\\r\\nif (!rsa->q && ((rsa->q = BN_new()) == NULL))\\r\\ngoto err;\\r\\nif (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))\\r\\ngoto err;\\r\\nif (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))\\r\\ngoto err;\\r\\nif (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))\\r\\ngoto err;\\r\\nBN_copy(rsa->e, e_value);\\r\\nfor (;;) {\\r\\nif (!BN_generate_prime_ex(rsa->p, bitsp, 0, NULL, NULL, cb))\\r\\ngoto err;\\r\\nif (!BN_sub(r2, rsa->p, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_gcd(r1, r2, rsa->e, ctx))\\r\\ngoto err;\\r\\nif (BN_is_one(r1))\\r\\nbreak;\\r\\nif (!BN_GENCB_call(cb, 2, n++))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_GENCB_call(cb, 3, 0))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nunsigned int degenerate = 0;\\r\\ndo {\\r\\nif (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))\\r\\ngoto err;\\r\\n} while ((BN_cmp(rsa->p, rsa->q) == 0) && (++degenerate < 3));\\r\\nif (degenerate == 3) {\\r\\nok = 0;\\r\\nRSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_sub(r2, rsa->q, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_gcd(r1, r2, rsa->e, ctx))\\r\\ngoto err;\\r\\nif (BN_is_one(r1))\\r\\nbreak;\\r\\nif (!BN_GENCB_call(cb, 2, n++))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_GENCB_call(cb, 3, 1))\\r\\ngoto err;\\r\\nif (BN_cmp(rsa->p, rsa->q) < 0) {\\r\\ntmp = rsa->p;\\r\\nrsa->p = rsa->q;\\r\\nrsa->q = tmp;\\r\\n}\\r\\nif (!BN_mul(rsa->n, rsa->p, rsa->q, ctx))\\r\\ngoto err;\\r\\nif (!BN_sub(r1, rsa->p, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_sub(r2, rsa->q, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_mul(r0, r1, r2, ctx))\\r\\ngoto err;\\r\\nif (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\\r\\npr0 = &local_r0;\\r\\nBN_with_flags(pr0, r0, BN_FLG_CONSTTIME);\\r\\n} else\\r\\npr0 = r0;\\r\\nif (!BN_mod_inverse(rsa->d, rsa->e, pr0, ctx))\\r\\ngoto err;\\r\\nif (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\\r\\nd = &local_d;\\r\\nBN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\\r\\n} else\\r\\nd = rsa->d;\\r\\nif (!BN_mod(rsa->dmp1, d, r1, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod(rsa->dmq1, d, r2, ctx))\\r\\ngoto err;\\r\\nif (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\\r\\np = &local_p;\\r\\nBN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);\\r\\n} else\\r\\np = rsa->p;\\r\\nif (!BN_mod_inverse(rsa->iqmp, rsa->q, p, ctx))\\r\\ngoto err;\\r\\nok = 1;\\r\\nerr:\\r\\nif (ok == -1) {\\r\\nRSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);\\r\\nok = 0;\\r\\n}\\r\\nif (ctx != NULL) {\\r\\nBN_CTX_end(ctx);\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nreturn ok;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_lh_stats_c", "target": 0, "func": "void lh_stats(LHASH *lh, FILE *out)\\r\\n{\\r\\nfprintf(out, \"num_items = %lu\\n\", lh->num_items);\\r\\nfprintf(out, \"num_nodes = %u\\n\", lh->num_nodes);\\r\\nfprintf(out, \"num_alloc_nodes = %u\\n\", lh->num_alloc_nodes);\\r\\nfprintf(out, \"num_expands = %lu\\n\", lh->num_expands);\\r\\nfprintf(out, \"num_expand_reallocs = %lu\\n\", lh->num_expand_reallocs);\\r\\nfprintf(out, \"num_contracts = %lu\\n\", lh->num_contracts);\\r\\nfprintf(out, \"num_contract_reallocs = %lu\\n\", lh->num_contract_reallocs);\\r\\nfprintf(out, \"num_hash_calls = %lu\\n\", lh->num_hash_calls);\\r\\nfprintf(out, \"num_comp_calls = %lu\\n\", lh->num_comp_calls);\\r\\nfprintf(out, \"num_insert = %lu\\n\", lh->num_insert);\\r\\nfprintf(out, \"num_replace = %lu\\n\", lh->num_replace);\\r\\nfprintf(out, \"num_delete = %lu\\n\", lh->num_delete);\\r\\nfprintf(out, \"num_no_delete = %lu\\n\", lh->num_no_delete);\\r\\nfprintf(out, \"num_retrieve = %lu\\n\", lh->num_retrieve);\\r\\nfprintf(out, \"num_retrieve_miss = %lu\\n\", lh->num_retrieve_miss);\\r\\nfprintf(out, \"num_hash_comps = %lu\\n\", lh->num_hash_comps);\\r\\n# if 0\\r\\nfprintf(out, \"p = %u\\n\", lh->p);\\r\\nfprintf(out, \"pmax = %u\\n\", lh->pmax);\\r\\nfprintf(out, \"up_load = %lu\\n\", lh->up_load);\\r\\nfprintf(out, \"down_load = %lu\\n\", lh->down_load);\\r\\n# endif\\r\\n}\\r\\nvoid lh_node_stats(LHASH *lh, FILE *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned int i, num;\\r\\nfor (i = 0; i < lh->num_nodes; i++) {\\r\\nfor (n = lh->b[i], num = 0; n != NULL; n = n->next)\\r\\nnum++;\\r\\nfprintf(out, \"node %6u -> %3u\\n\", i, num);\\r\\n}\\r\\n}\\r\\nvoid lh_node_usage_stats(LHASH *lh, FILE *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned long num;\\r\\nunsigned int i;\\r\\nunsigned long total = 0, n_used = 0;\\r\\nfor (i = 0; i < lh->num_nodes; i++) {\\r\\nfor (n = lh->b[i], num = 0; n != NULL; n = n->next)\\r\\nnum++;\\r\\nif (num != 0) {\\r\\nn_used++;\\r\\ntotal += num;\\r\\n}\\r\\n}\\r\\nfprintf(out, \"%lu nodes used out of %u\\n\", n_used, lh->num_nodes);\\r\\nfprintf(out, \"%lu items\\n\", total);\\r\\nif (n_used == 0)\\r\\nreturn;\\r\\nfprintf(out, \"load %d.%02d actual load %d.%02d\\n\",\\r\\n(int)(total / lh->num_nodes),\\r\\n(int)((total % lh->num_nodes) * 100 / lh->num_nodes),\\r\\n(int)(total / n_used), (int)((total % n_used) * 100 / n_used));\\r\\n}\\r\\nvoid lh_stats(const _LHASH *lh, FILE *fp)\\r\\n{\\r\\nBIO *bp;\\r\\nbp = BIO_new(BIO_s_file());\\r\\nif (bp == NULL)\\r\\ngoto end;\\r\\nBIO_set_fp(bp, fp, BIO_NOCLOSE);\\r\\nlh_stats_bio(lh, bp);\\r\\nBIO_free(bp);\\r\\nend:;\\r\\n}\\r\\nvoid lh_node_stats(const _LHASH *lh, FILE *fp)\\r\\n{\\r\\nBIO *bp;\\r\\nbp = BIO_new(BIO_s_file());\\r\\nif (bp == NULL)\\r\\ngoto end;\\r\\nBIO_set_fp(bp, fp, BIO_NOCLOSE);\\r\\nlh_node_stats_bio(lh, bp);\\r\\nBIO_free(bp);\\r\\nend:;\\r\\n}\\r\\nvoid lh_node_usage_stats(const _LHASH *lh, FILE *fp)\\r\\n{\\r\\nBIO *bp;\\r\\nbp = BIO_new(BIO_s_file());\\r\\nif (bp == NULL)\\r\\ngoto end;\\r\\nBIO_set_fp(bp, fp, BIO_NOCLOSE);\\r\\nlh_node_usage_stats_bio(lh, bp);\\r\\nBIO_free(bp);\\r\\nend:;\\r\\n}\\r\\nvoid lh_stats_bio(const _LHASH *lh, BIO *out)\\r\\n{\\r\\nBIO_printf(out, \"num_items = %lu\\n\", lh->num_items);\\r\\nBIO_printf(out, \"num_nodes = %u\\n\", lh->num_nodes);\\r\\nBIO_printf(out, \"num_alloc_nodes = %u\\n\", lh->num_alloc_nodes);\\r\\nBIO_printf(out, \"num_expands = %lu\\n\", lh->num_expands);\\r\\nBIO_printf(out, \"num_expand_reallocs = %lu\\n\", lh->num_expand_reallocs);\\r\\nBIO_printf(out, \"num_contracts = %lu\\n\", lh->num_contracts);\\r\\nBIO_printf(out, \"num_contract_reallocs = %lu\\n\",\\r\\nlh->num_contract_reallocs);\\r\\nBIO_printf(out, \"num_hash_calls = %lu\\n\", lh->num_hash_calls);\\r\\nBIO_printf(out, \"num_comp_calls = %lu\\n\", lh->num_comp_calls);\\r\\nBIO_printf(out, \"num_insert = %lu\\n\", lh->num_insert);\\r\\nBIO_printf(out, \"num_replace = %lu\\n\", lh->num_replace);\\r\\nBIO_printf(out, \"num_delete = %lu\\n\", lh->num_delete);\\r\\nBIO_printf(out, \"num_no_delete = %lu\\n\", lh->num_no_delete);\\r\\nBIO_printf(out, \"num_retrieve = %lu\\n\", lh->num_retrieve);\\r\\nBIO_printf(out, \"num_retrieve_miss = %lu\\n\", lh->num_retrieve_miss);\\r\\nBIO_printf(out, \"num_hash_comps = %lu\\n\", lh->num_hash_comps);\\r\\n# if 0\\r\\nBIO_printf(out, \"p = %u\\n\", lh->p);\\r\\nBIO_printf(out, \"pmax = %u\\n\", lh->pmax);\\r\\nBIO_printf(out, \"up_load = %lu\\n\", lh->up_load);\\r\\nBIO_printf(out, \"down_load = %lu\\n\", lh->down_load);\\r\\n# endif\\r\\n}\\r\\nvoid lh_node_stats_bio(const _LHASH *lh, BIO *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned int i, num;\\r\\nfor (i = 0; i < lh->num_nodes; i++) {\\r\\nfor (n = lh->b[i], num = 0; n != NULL; n = n->next)\\r\\nnum++;\\r\\nBIO_printf(out, \"node %6u -> %3u\\n\", i, num);\\r\\n}\\r\\n}\\r\\nvoid lh_node_usage_stats_bio(const _LHASH *lh, BIO *out)\\r\\n{\\r\\nLHASH_NODE *n;\\r\\nunsigned long num;\\r\\nunsigned int i;\\r\\nunsigned long total = 0, n_used = 0;\\r\\nfor (i = 0; i < lh->num_nodes; i++) {\\r\\nfor (n = lh->b[i], num = 0; n != NULL; n = n->next)\\r\\nnum++;\\r\\nif (num != 0) {\\r\\nn_used++;\\r\\ntotal += num;\\r\\n}\\r\\n}\\r\\nBIO_printf(out, \"%lu nodes used out of %u\\n\", n_used, lh->num_nodes);\\r\\nBIO_printf(out, \"%lu items\\n\", total);\\r\\nif (n_used == 0)\\r\\nreturn;\\r\\nBIO_printf(out, \"load %d.%02d actual load %d.%02d\\n\",\\r\\n(int)(total / lh->num_nodes),\\r\\n(int)((total % lh->num_nodes) * 100 / lh->num_nodes),\\r\\n(int)(total / n_used), (int)((total % n_used) * 100 / n_used));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_digest_c", "target": 0, "func": "void EVP_MD_CTX_init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nmemset(ctx, '\\0', sizeof *ctx);\\r\\n}\\r\\nEVP_MD_CTX *EVP_MD_CTX_create(void)\\r\\n{\\r\\nEVP_MD_CTX *ctx = OPENSSL_malloc(sizeof *ctx);\\r\\nif (ctx)\\r\\nEVP_MD_CTX_init(ctx);\\r\\nreturn ctx;\\r\\n}\\r\\nint EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type)\\r\\n{\\r\\nEVP_MD_CTX_init(ctx);\\r\\nreturn EVP_DigestInit_ex(ctx, type, NULL);\\r\\n}\\r\\nint EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)\\r\\n{\\r\\nEVP_MD_CTX_clear_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode()) {\\r\\nconst EVP_MD *fipsmd;\\r\\nif (type) {\\r\\nfipsmd = evp_get_fips_md(type);\\r\\nif (fipsmd)\\r\\ntype = fipsmd;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ctx->engine && ctx->digest && (!type ||\\r\\n(type\\r\\n&& (type->type ==\\r\\nctx->digest->type))))\\r\\ngoto skip_to_init;\\r\\nif (type) {\\r\\nif (ctx->engine)\\r\\nENGINE_finish(ctx->engine);\\r\\nif (impl) {\\r\\nif (!ENGINE_init(impl)) {\\r\\nEVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n} else\\r\\nimpl = ENGINE_get_digest_engine(type->type);\\r\\nif (impl) {\\r\\nconst EVP_MD *d = ENGINE_get_digest(impl, type->type);\\r\\nif (!d) {\\r\\nEVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);\\r\\nENGINE_finish(impl);\\r\\nreturn 0;\\r\\n}\\r\\ntype = d;\\r\\nctx->engine = impl;\\r\\n} else\\r\\nctx->engine = NULL;\\r\\n} else if (!ctx->digest) {\\r\\nEVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_NO_DIGEST_SET);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nif (ctx->digest != type) {\\r\\nif (ctx->digest && ctx->digest->ctx_size)\\r\\nOPENSSL_free(ctx->md_data);\\r\\nctx->digest = type;\\r\\nif (!(ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) && type->ctx_size) {\\r\\nctx->update = type->update;\\r\\nctx->md_data = OPENSSL_malloc(type->ctx_size);\\r\\nif (ctx->md_data == NULL) {\\r\\nEVPerr(EVP_F_EVP_DIGESTINIT_EX, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nskip_to_init:\\r\\n#endif\\r\\nif (ctx->pctx) {\\r\\nint r;\\r\\nr = EVP_PKEY_CTX_ctrl(ctx->pctx, -1, EVP_PKEY_OP_TYPE_SIG,\\r\\nEVP_PKEY_CTRL_DIGESTINIT, 0, ctx);\\r\\nif (r <= 0 && (r != -2))\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx->flags & EVP_MD_CTX_FLAG_NO_INIT)\\r\\nreturn 1;\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode()) {\\r\\nif (FIPS_digestinit(ctx, type))\\r\\nreturn 1;\\r\\nOPENSSL_free(ctx->md_data);\\r\\nctx->md_data = NULL;\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nreturn ctx->digest->init(ctx);\\r\\n}\\r\\nint EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nreturn FIPS_digestupdate(ctx, data, count);\\r\\n#else\\r\\nreturn ctx->update(ctx, data, count);\\r\\n#endif\\r\\n}\\r\\nint EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *size)\\r\\n{\\r\\nint ret;\\r\\nret = EVP_DigestFinal_ex(ctx, md, size);\\r\\nEVP_MD_CTX_cleanup(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *size)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nreturn FIPS_digestfinal(ctx, md, size);\\r\\n#else\\r\\nint ret;\\r\\nOPENSSL_assert(ctx->digest->md_size <= EVP_MAX_MD_SIZE);\\r\\nret = ctx->digest->final(ctx, md);\\r\\nif (size != NULL)\\r\\n*size = ctx->digest->md_size;\\r\\nif (ctx->digest->cleanup) {\\r\\nctx->digest->cleanup(ctx);\\r\\nEVP_MD_CTX_set_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);\\r\\n}\\r\\nmemset(ctx->md_data, 0, ctx->digest->ctx_size);\\r\\nreturn ret;\\r\\n#endif\\r\\n}\\r\\nint EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in)\\r\\n{\\r\\nEVP_MD_CTX_init(out);\\r\\nreturn EVP_MD_CTX_copy_ex(out, in);\\r\\n}\\r\\nint EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)\\r\\n{\\r\\nunsigned char *tmp_buf;\\r\\nif ((in == NULL) || (in->digest == NULL)) {\\r\\nEVPerr(EVP_F_EVP_MD_CTX_COPY_EX, EVP_R_INPUT_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (in->engine && !ENGINE_init(in->engine)) {\\r\\nEVPerr(EVP_F_EVP_MD_CTX_COPY_EX, ERR_R_ENGINE_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nif (out->digest == in->digest) {\\r\\ntmp_buf = out->md_data;\\r\\nEVP_MD_CTX_set_flags(out, EVP_MD_CTX_FLAG_REUSE);\\r\\n} else\\r\\ntmp_buf = NULL;\\r\\nEVP_MD_CTX_cleanup(out);\\r\\nmemcpy(out, in, sizeof *out);\\r\\nif (in->md_data && out->digest->ctx_size) {\\r\\nif (tmp_buf)\\r\\nout->md_data = tmp_buf;\\r\\nelse {\\r\\nout->md_data = OPENSSL_malloc(out->digest->ctx_size);\\r\\nif (!out->md_data) {\\r\\nEVPerr(EVP_F_EVP_MD_CTX_COPY_EX, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nmemcpy(out->md_data, in->md_data, out->digest->ctx_size);\\r\\n}\\r\\nout->update = in->update;\\r\\nif (in->pctx) {\\r\\nout->pctx = EVP_PKEY_CTX_dup(in->pctx);\\r\\nif (!out->pctx) {\\r\\nEVP_MD_CTX_cleanup(out);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (out->digest->copy)\\r\\nreturn out->digest->copy(out, in);\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_Digest(const void *data, size_t count,\\r\\nunsigned char *md, unsigned int *size, const EVP_MD *type,\\r\\nENGINE *impl)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nint ret;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_ONESHOT);\\r\\nret = EVP_DigestInit_ex(&ctx, type, impl)\\r\\n&& EVP_DigestUpdate(&ctx, data, count)\\r\\n&& EVP_DigestFinal_ex(&ctx, md, size);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn ret;\\r\\n}\\r\\nvoid EVP_MD_CTX_destroy(EVP_MD_CTX *ctx)\\r\\n{\\r\\nif (ctx) {\\r\\nEVP_MD_CTX_cleanup(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\n}\\r\\nint EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx)\\r\\n{\\r\\n#ifndef OPENSSL_FIPS\\r\\nif (ctx->digest && ctx->digest->cleanup\\r\\n&& !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_CLEANED))\\r\\nctx->digest->cleanup(ctx);\\r\\nif (ctx->digest && ctx->digest->ctx_size && ctx->md_data\\r\\n&& !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_REUSE)) {\\r\\nOPENSSL_cleanse(ctx->md_data, ctx->digest->ctx_size);\\r\\nOPENSSL_free(ctx->md_data);\\r\\n}\\r\\n#endif\\r\\nif (ctx->pctx)\\r\\nEVP_PKEY_CTX_free(ctx->pctx);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ctx->engine)\\r\\nENGINE_finish(ctx->engine);\\r\\n#endif\\r\\n#ifdef OPENSSL_FIPS\\r\\nFIPS_md_ctx_cleanup(ctx);\\r\\n#endif\\r\\nmemset(ctx, '\\0', sizeof *ctx);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509type_c", "target": 0, "func": "int X509_certificate_type(X509 *x, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret = 0, i;\\r\\nif (x == NULL)\\r\\nreturn (0);\\r\\nif (pkey == NULL)\\r\\npk = X509_get_pubkey(x);\\r\\nelse\\r\\npk = pkey;\\r\\nif (pk == NULL)\\r\\nreturn (0);\\r\\nswitch (pk->type) {\\r\\ncase EVP_PKEY_RSA:\\r\\nret = EVP_PK_RSA | EVP_PKT_SIGN;\\r\\nret |= EVP_PKT_ENC;\\r\\nbreak;\\r\\ncase EVP_PKEY_DSA:\\r\\nret = EVP_PK_DSA | EVP_PKT_SIGN;\\r\\nbreak;\\r\\ncase EVP_PKEY_EC:\\r\\nret = EVP_PK_EC | EVP_PKT_SIGN | EVP_PKT_EXCH;\\r\\nbreak;\\r\\ncase EVP_PKEY_DH:\\r\\nret = EVP_PK_DH | EVP_PKT_EXCH;\\r\\nbreak;\\r\\ncase NID_id_GostR3410_94:\\r\\ncase NID_id_GostR3410_2001:\\r\\nret = EVP_PKT_EXCH | EVP_PKT_SIGN;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\ni = OBJ_obj2nid(x->sig_alg->algorithm);\\r\\nif (i && OBJ_find_sigid_algs(i, NULL, &i)) {\\r\\nswitch (i) {\\r\\ncase NID_rsaEncryption:\\r\\ncase NID_rsa:\\r\\nret |= EVP_PKS_RSA;\\r\\nbreak;\\r\\ncase NID_dsa:\\r\\ncase NID_dsa_2:\\r\\nret |= EVP_PKS_DSA;\\r\\nbreak;\\r\\ncase NID_X9_62_id_ecPublicKey:\\r\\nret |= EVP_PKS_EC;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (EVP_PKEY_size(pk) <= 1024 / 8)\\r\\nret |= EVP_PKT_EXP;\\r\\nif (pkey == NULL)\\r\\nEVP_PKEY_free(pk);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p5_crpt2_c", "target": 0, "func": "int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,\\r\\nconst unsigned char *salt, int saltlen, int iter,\\r\\nconst EVP_MD *digest, int keylen, unsigned char *out)\\r\\n{\\r\\nunsigned char digtmp[EVP_MAX_MD_SIZE], *p, itmp[4];\\r\\nint cplen, j, k, tkeylen, mdlen;\\r\\nunsigned long i = 1;\\r\\nHMAC_CTX hctx_tpl, hctx;\\r\\nmdlen = EVP_MD_size(digest);\\r\\nif (mdlen < 0)\\r\\nreturn 0;\\r\\nHMAC_CTX_init(&hctx_tpl);\\r\\np = out;\\r\\ntkeylen = keylen;\\r\\nif (!pass)\\r\\npasslen = 0;\\r\\nelse if (passlen == -1)\\r\\npasslen = strlen(pass);\\r\\nif (!HMAC_Init_ex(&hctx_tpl, pass, passlen, digest, NULL)) {\\r\\nHMAC_CTX_cleanup(&hctx_tpl);\\r\\nreturn 0;\\r\\n}\\r\\nwhile (tkeylen) {\\r\\nif (tkeylen > mdlen)\\r\\ncplen = mdlen;\\r\\nelse\\r\\ncplen = tkeylen;\\r\\nitmp[0] = (unsigned char)((i >> 24) & 0xff);\\r\\nitmp[1] = (unsigned char)((i >> 16) & 0xff);\\r\\nitmp[2] = (unsigned char)((i >> 8) & 0xff);\\r\\nitmp[3] = (unsigned char)(i & 0xff);\\r\\nif (!HMAC_CTX_copy(&hctx, &hctx_tpl)) {\\r\\nHMAC_CTX_cleanup(&hctx_tpl);\\r\\nreturn 0;\\r\\n}\\r\\nif (!HMAC_Update(&hctx, salt, saltlen)\\r\\n|| !HMAC_Update(&hctx, itmp, 4)\\r\\n|| !HMAC_Final(&hctx, digtmp, NULL)) {\\r\\nHMAC_CTX_cleanup(&hctx_tpl);\\r\\nHMAC_CTX_cleanup(&hctx);\\r\\nreturn 0;\\r\\n}\\r\\nHMAC_CTX_cleanup(&hctx);\\r\\nmemcpy(p, digtmp, cplen);\\r\\nfor (j = 1; j < iter; j++) {\\r\\nif (!HMAC_CTX_copy(&hctx, &hctx_tpl)) {\\r\\nHMAC_CTX_cleanup(&hctx_tpl);\\r\\nreturn 0;\\r\\n}\\r\\nif (!HMAC_Update(&hctx, digtmp, mdlen)\\r\\n|| !HMAC_Final(&hctx, digtmp, NULL)) {\\r\\nHMAC_CTX_cleanup(&hctx_tpl);\\r\\nHMAC_CTX_cleanup(&hctx);\\r\\nreturn 0;\\r\\n}\\r\\nHMAC_CTX_cleanup(&hctx);\\r\\nfor (k = 0; k < cplen; k++)\\r\\np[k] ^= digtmp[k];\\r\\n}\\r\\ntkeylen -= cplen;\\r\\ni++;\\r\\np += cplen;\\r\\n}\\r\\nHMAC_CTX_cleanup(&hctx_tpl);\\r\\n# ifdef DEBUG_PKCS5V2\\r\\nfprintf(stderr, \"Password:\\n\");\\r\\nh__dump(pass, passlen);\\r\\nfprintf(stderr, \"Salt:\\n\");\\r\\nh__dump(salt, saltlen);\\r\\nfprintf(stderr, \"Iteration count %d\\n\", iter);\\r\\nfprintf(stderr, \"Key:\\n\");\\r\\nh__dump(out, keylen);\\r\\n# endif\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,\\r\\nconst unsigned char *salt, int saltlen, int iter,\\r\\nint keylen, unsigned char *out)\\r\\n{\\r\\nreturn PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, EVP_sha1(),\\r\\nkeylen, out);\\r\\n}\\r\\nmain()\\r\\n{\\r\\nunsigned char out[4];\\r\\nunsigned char salt[] = { 0x12, 0x34, 0x56, 0x78 };\\r\\nPKCS5_PBKDF2_HMAC_SHA1(\"password\", -1, salt, 4, 5, 4, out);\\r\\nfprintf(stderr, \"Out %02X %02X %02X %02X\\n\",\\r\\nout[0], out[1], out[2], out[3]);\\r\\n}\\r\\nint PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,\\r\\nASN1_TYPE *param, const EVP_CIPHER *c,\\r\\nconst EVP_MD *md, int en_de)\\r\\n{\\r\\nconst unsigned char *pbuf;\\r\\nint plen;\\r\\nPBE2PARAM *pbe2 = NULL;\\r\\nconst EVP_CIPHER *cipher;\\r\\nint rv = 0;\\r\\nif (param == NULL || param->type != V_ASN1_SEQUENCE ||\\r\\nparam->value.sequence == NULL) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\npbuf = param->value.sequence->data;\\r\\nplen = param->value.sequence->length;\\r\\nif (!(pbe2 = d2i_PBE2PARAM(NULL, &pbuf, plen))) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (OBJ_obj2nid(pbe2->keyfunc->algorithm) != NID_id_pbkdf2) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN,\\r\\nEVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION);\\r\\ngoto err;\\r\\n}\\r\\ncipher = EVP_get_cipherbyobj(pbe2->encryption->algorithm);\\r\\nif (!cipher) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_UNSUPPORTED_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, en_de))\\r\\ngoto err;\\r\\nif (EVP_CIPHER_asn1_to_param(ctx, pbe2->encryption->parameter) < 0) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBE_KEYIVGEN, EVP_R_CIPHER_PARAMETER_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nrv = PKCS5_v2_PBKDF2_keyivgen(ctx, pass, passlen,\\r\\npbe2->keyfunc->parameter, c, md, en_de);\\r\\nerr:\\r\\nPBE2PARAM_free(pbe2);\\r\\nreturn rv;\\r\\n}\\r\\nint PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,\\r\\nint passlen, ASN1_TYPE *param,\\r\\nconst EVP_CIPHER *c, const EVP_MD *md, int en_de)\\r\\n{\\r\\nunsigned char *salt, key[EVP_MAX_KEY_LENGTH];\\r\\nconst unsigned char *pbuf;\\r\\nint saltlen, iter, plen;\\r\\nint rv = 0;\\r\\nunsigned int keylen = 0;\\r\\nint prf_nid, hmac_md_nid;\\r\\nPBKDF2PARAM *kdf = NULL;\\r\\nconst EVP_MD *prfmd;\\r\\nif (EVP_CIPHER_CTX_cipher(ctx) == NULL) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_NO_CIPHER_SET);\\r\\ngoto err;\\r\\n}\\r\\nkeylen = EVP_CIPHER_CTX_key_length(ctx);\\r\\nOPENSSL_assert(keylen <= sizeof key);\\r\\nif (!param || (param->type != V_ASN1_SEQUENCE)) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\npbuf = param->value.sequence->data;\\r\\nplen = param->value.sequence->length;\\r\\nif (!(kdf = d2i_PBKDF2PARAM(NULL, &pbuf, plen))) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nkeylen = EVP_CIPHER_CTX_key_length(ctx);\\r\\nif (kdf->keylength && (ASN1_INTEGER_get(kdf->keylength) != (int)keylen)) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_KEYLENGTH);\\r\\ngoto err;\\r\\n}\\r\\nif (kdf->prf)\\r\\nprf_nid = OBJ_obj2nid(kdf->prf->algorithm);\\r\\nelse\\r\\nprf_nid = NID_hmacWithSHA1;\\r\\nif (!EVP_PBE_find(EVP_PBE_TYPE_PRF, prf_nid, NULL, &hmac_md_nid, 0)) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);\\r\\ngoto err;\\r\\n}\\r\\nprfmd = EVP_get_digestbynid(hmac_md_nid);\\r\\nif (prfmd == NULL) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_PRF);\\r\\ngoto err;\\r\\n}\\r\\nif (kdf->salt->type != V_ASN1_OCTET_STRING) {\\r\\nEVPerr(EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN, EVP_R_UNSUPPORTED_SALT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nsalt = kdf->salt->value.octet_string->data;\\r\\nsaltlen = kdf->salt->value.octet_string->length;\\r\\niter = ASN1_INTEGER_get(kdf->iter);\\r\\nif (!PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, prfmd,\\r\\nkeylen, key))\\r\\ngoto err;\\r\\nrv = EVP_CipherInit_ex(ctx, NULL, NULL, key, NULL, en_de);\\r\\nerr:\\r\\nOPENSSL_cleanse(key, keylen);\\r\\nPBKDF2PARAM_free(kdf);\\r\\nreturn rv;\\r\\n}\\r\\nstatic void h__dump(const unsigned char *p, int len)\\r\\n{\\r\\nfor (; len--; p++)\\r\\nfprintf(stderr, \"%02X \", *p);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint operation = 0;\\r\\nint ret = 0;\\r\\nchar **args;\\r\\nconst char *inmode = \"r\", *outmode = \"w\";\\r\\nchar *infile = NULL, *outfile = NULL, *rctfile = NULL;\\r\\nchar *signerfile = NULL, *recipfile = NULL;\\r\\nSTACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\\r\\nchar *certfile = NULL, *keyfile = NULL, *contfile = NULL;\\r\\nchar *certsoutfile = NULL;\\r\\nconst EVP_CIPHER *cipher = NULL, *wrap_cipher = NULL;\\r\\nCMS_ContentInfo *cms = NULL, *rcms = NULL;\\r\\nX509_STORE *store = NULL;\\r\\nX509 *cert = NULL, *recip = NULL, *signer = NULL;\\r\\nEVP_PKEY *key = NULL;\\r\\nSTACK_OF(X509) *encerts = NULL, *other = NULL;\\r\\nBIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;\\r\\nint badarg = 0;\\r\\nint flags = CMS_DETACHED, noout = 0, print = 0;\\r\\nint verify_retcode = 0;\\r\\nint rr_print = 0, rr_allorfirst = -1;\\r\\nSTACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;\\r\\nCMS_ReceiptRequest *rr = NULL;\\r\\nchar *to = NULL, *from = NULL, *subject = NULL;\\r\\nchar *CAfile = NULL, *CApath = NULL;\\r\\nchar *passargin = NULL, *passin = NULL;\\r\\nchar *inrand = NULL;\\r\\nint need_rand = 0;\\r\\nconst EVP_MD *sign_md = NULL;\\r\\nint informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\\r\\nint rctformat = FORMAT_SMIME, keyform = FORMAT_PEM;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n# endif\\r\\nunsigned char *secret_key = NULL, *secret_keyid = NULL;\\r\\nunsigned char *pwri_pass = NULL, *pwri_tmp = NULL;\\r\\nsize_t secret_keylen = 0, secret_keyidlen = 0;\\r\\ncms_key_param *key_first = NULL, *key_param = NULL;\\r\\nASN1_OBJECT *econtent_type = NULL;\\r\\nX509_VERIFY_PARAM *vpm = NULL;\\r\\nargs = argv + 1;\\r\\nret = 1;\\r\\napps_startup();\\r\\nif (bio_err == NULL) {\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n}\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp(*args, \"-encrypt\"))\\r\\noperation = SMIME_ENCRYPT;\\r\\nelse if (!strcmp(*args, \"-decrypt\"))\\r\\noperation = SMIME_DECRYPT;\\r\\nelse if (!strcmp(*args, \"-sign\"))\\r\\noperation = SMIME_SIGN;\\r\\nelse if (!strcmp(*args, \"-sign_receipt\"))\\r\\noperation = SMIME_SIGN_RECEIPT;\\r\\nelse if (!strcmp(*args, \"-resign\"))\\r\\noperation = SMIME_RESIGN;\\r\\nelse if (!strcmp(*args, \"-verify\"))\\r\\noperation = SMIME_VERIFY;\\r\\nelse if (!strcmp(*args, \"-verify_retcode\"))\\r\\nverify_retcode = 1;\\r\\nelse if (!strcmp(*args, \"-verify_receipt\")) {\\r\\noperation = SMIME_VERIFY_RECEIPT;\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nargs++;\\r\\nrctfile = *args;\\r\\n} else if (!strcmp(*args, \"-cmsout\"))\\r\\noperation = SMIME_CMSOUT;\\r\\nelse if (!strcmp(*args, \"-data_out\"))\\r\\noperation = SMIME_DATAOUT;\\r\\nelse if (!strcmp(*args, \"-data_create\"))\\r\\noperation = SMIME_DATA_CREATE;\\r\\nelse if (!strcmp(*args, \"-digest_verify\"))\\r\\noperation = SMIME_DIGEST_VERIFY;\\r\\nelse if (!strcmp(*args, \"-digest_create\"))\\r\\noperation = SMIME_DIGEST_CREATE;\\r\\nelse if (!strcmp(*args, \"-compress\"))\\r\\noperation = SMIME_COMPRESS;\\r\\nelse if (!strcmp(*args, \"-uncompress\"))\\r\\noperation = SMIME_UNCOMPRESS;\\r\\nelse if (!strcmp(*args, \"-EncryptedData_decrypt\"))\\r\\noperation = SMIME_ENCRYPTED_DECRYPT;\\r\\nelse if (!strcmp(*args, \"-EncryptedData_encrypt\"))\\r\\noperation = SMIME_ENCRYPTED_ENCRYPT;\\r\\n# ifndef OPENSSL_NO_DES\\r\\nelse if (!strcmp(*args, \"-des3\"))\\r\\ncipher = EVP_des_ede3_cbc();\\r\\nelse if (!strcmp(*args, \"-des\"))\\r\\ncipher = EVP_des_cbc();\\r\\nelse if (!strcmp(*args, \"-des3-wrap\"))\\r\\nwrap_cipher = EVP_des_ede3_wrap();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nelse if (!strcmp(*args, \"-seed\"))\\r\\ncipher = EVP_seed_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_RC2\\r\\nelse if (!strcmp(*args, \"-rc2-40\"))\\r\\ncipher = EVP_rc2_40_cbc();\\r\\nelse if (!strcmp(*args, \"-rc2-128\"))\\r\\ncipher = EVP_rc2_cbc();\\r\\nelse if (!strcmp(*args, \"-rc2-64\"))\\r\\ncipher = EVP_rc2_64_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nelse if (!strcmp(*args, \"-aes128\"))\\r\\ncipher = EVP_aes_128_cbc();\\r\\nelse if (!strcmp(*args, \"-aes192\"))\\r\\ncipher = EVP_aes_192_cbc();\\r\\nelse if (!strcmp(*args, \"-aes256\"))\\r\\ncipher = EVP_aes_256_cbc();\\r\\nelse if (!strcmp(*args, \"-aes128-wrap\"))\\r\\nwrap_cipher = EVP_aes_128_wrap();\\r\\nelse if (!strcmp(*args, \"-aes192-wrap\"))\\r\\nwrap_cipher = EVP_aes_192_wrap();\\r\\nelse if (!strcmp(*args, \"-aes256-wrap\"))\\r\\nwrap_cipher = EVP_aes_256_wrap();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nelse if (!strcmp(*args, \"-camellia128\"))\\r\\ncipher = EVP_camellia_128_cbc();\\r\\nelse if (!strcmp(*args, \"-camellia192\"))\\r\\ncipher = EVP_camellia_192_cbc();\\r\\nelse if (!strcmp(*args, \"-camellia256\"))\\r\\ncipher = EVP_camellia_256_cbc();\\r\\n# endif\\r\\nelse if (!strcmp(*args, \"-debug_decrypt\"))\\r\\nflags |= CMS_DEBUG_DECRYPT;\\r\\nelse if (!strcmp(*args, \"-text\"))\\r\\nflags |= CMS_TEXT;\\r\\nelse if (!strcmp(*args, \"-nointern\"))\\r\\nflags |= CMS_NOINTERN;\\r\\nelse if (!strcmp(*args, \"-noverify\")\\r\\n|| !strcmp(*args, \"-no_signer_cert_verify\"))\\r\\nflags |= CMS_NO_SIGNER_CERT_VERIFY;\\r\\nelse if (!strcmp(*args, \"-nocerts\"))\\r\\nflags |= CMS_NOCERTS;\\r\\nelse if (!strcmp(*args, \"-noattr\"))\\r\\nflags |= CMS_NOATTR;\\r\\nelse if (!strcmp(*args, \"-nodetach\"))\\r\\nflags &= ~CMS_DETACHED;\\r\\nelse if (!strcmp(*args, \"-nosmimecap\"))\\r\\nflags |= CMS_NOSMIMECAP;\\r\\nelse if (!strcmp(*args, \"-binary\"))\\r\\nflags |= CMS_BINARY;\\r\\nelse if (!strcmp(*args, \"-keyid\"))\\r\\nflags |= CMS_USE_KEYID;\\r\\nelse if (!strcmp(*args, \"-nosigs\"))\\r\\nflags |= CMS_NOSIGS;\\r\\nelse if (!strcmp(*args, \"-no_content_verify\"))\\r\\nflags |= CMS_NO_CONTENT_VERIFY;\\r\\nelse if (!strcmp(*args, \"-no_attr_verify\"))\\r\\nflags |= CMS_NO_ATTR_VERIFY;\\r\\nelse if (!strcmp(*args, \"-stream\"))\\r\\nflags |= CMS_STREAM;\\r\\nelse if (!strcmp(*args, \"-indef\"))\\r\\nflags |= CMS_STREAM;\\r\\nelse if (!strcmp(*args, \"-noindef\"))\\r\\nflags &= ~CMS_STREAM;\\r\\nelse if (!strcmp(*args, \"-nooldmime\"))\\r\\nflags |= CMS_NOOLDMIMETYPE;\\r\\nelse if (!strcmp(*args, \"-crlfeol\"))\\r\\nflags |= CMS_CRLFEOL;\\r\\nelse if (!strcmp(*args, \"-noout\"))\\r\\nnoout = 1;\\r\\nelse if (!strcmp(*args, \"-receipt_request_print\"))\\r\\nrr_print = 1;\\r\\nelse if (!strcmp(*args, \"-receipt_request_all\"))\\r\\nrr_allorfirst = 0;\\r\\nelse if (!strcmp(*args, \"-receipt_request_first\"))\\r\\nrr_allorfirst = 1;\\r\\nelse if (!strcmp(*args, \"-receipt_request_from\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nargs++;\\r\\nif (!rr_from)\\r\\nrr_from = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(rr_from, *args);\\r\\n} else if (!strcmp(*args, \"-receipt_request_to\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nargs++;\\r\\nif (!rr_to)\\r\\nrr_to = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(rr_to, *args);\\r\\n} else if (!strcmp(*args, \"-print\")) {\\r\\nnoout = 1;\\r\\nprint = 1;\\r\\n} else if (!strcmp(*args, \"-secretkey\")) {\\r\\nlong ltmp;\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nargs++;\\r\\nsecret_key = string_to_hex(*args, &ltmp);\\r\\nif (!secret_key) {\\r\\nBIO_printf(bio_err, \"Invalid key %s\\n\", *args);\\r\\ngoto argerr;\\r\\n}\\r\\nsecret_keylen = (size_t)ltmp;\\r\\n} else if (!strcmp(*args, \"-secretkeyid\")) {\\r\\nlong ltmp;\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nargs++;\\r\\nsecret_keyid = string_to_hex(*args, &ltmp);\\r\\nif (!secret_keyid) {\\r\\nBIO_printf(bio_err, \"Invalid id %s\\n\", *args);\\r\\ngoto argerr;\\r\\n}\\r\\nsecret_keyidlen = (size_t)ltmp;\\r\\n} else if (!strcmp(*args, \"-pwri_password\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nargs++;\\r\\npwri_pass = (unsigned char *)*args;\\r\\n} else if (!strcmp(*args, \"-econtent_type\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nargs++;\\r\\necontent_type = OBJ_txt2obj(*args, 0);\\r\\nif (!econtent_type) {\\r\\nBIO_printf(bio_err, \"Invalid OID %s\\n\", *args);\\r\\ngoto argerr;\\r\\n}\\r\\n} else if (!strcmp(*args, \"-rand\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nargs++;\\r\\ninrand = *args;\\r\\nneed_rand = 1;\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nelse if (!strcmp(*args, \"-engine\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nengine = *++args;\\r\\n}\\r\\n# endif\\r\\nelse if (!strcmp(*args, \"-passin\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\npassargin = *++args;\\r\\n} else if (!strcmp(*args, \"-to\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nto = *++args;\\r\\n} else if (!strcmp(*args, \"-from\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nfrom = *++args;\\r\\n} else if (!strcmp(*args, \"-subject\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nsubject = *++args;\\r\\n} else if (!strcmp(*args, \"-signer\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nif (signerfile) {\\r\\nif (!sksigners)\\r\\nsksigners = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(sksigners, signerfile);\\r\\nif (!keyfile)\\r\\nkeyfile = signerfile;\\r\\nif (!skkeys)\\r\\nskkeys = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(skkeys, keyfile);\\r\\nkeyfile = NULL;\\r\\n}\\r\\nsignerfile = *++args;\\r\\n} else if (!strcmp(*args, \"-recip\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nif (operation == SMIME_ENCRYPT) {\\r\\nif (!encerts)\\r\\nencerts = sk_X509_new_null();\\r\\ncert = load_cert(bio_err, *++args, FORMAT_PEM,\\r\\nNULL, e, \"recipient certificate file\");\\r\\nif (!cert)\\r\\ngoto end;\\r\\nsk_X509_push(encerts, cert);\\r\\ncert = NULL;\\r\\n} else\\r\\nrecipfile = *++args;\\r\\n} else if (!strcmp(*args, \"-certsout\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\ncertsoutfile = *++args;\\r\\n} else if (!strcmp(*args, \"-md\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nsign_md = EVP_get_digestbyname(*++args);\\r\\nif (sign_md == NULL) {\\r\\nBIO_printf(bio_err, \"Unknown digest %s\\n\", *args);\\r\\ngoto argerr;\\r\\n}\\r\\n} else if (!strcmp(*args, \"-inkey\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nif (keyfile) {\\r\\nif (!signerfile) {\\r\\nBIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\\r\\ngoto argerr;\\r\\n}\\r\\nif (!sksigners)\\r\\nsksigners = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(sksigners, signerfile);\\r\\nsignerfile = NULL;\\r\\nif (!skkeys)\\r\\nskkeys = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(skkeys, keyfile);\\r\\n}\\r\\nkeyfile = *++args;\\r\\n} else if (!strcmp(*args, \"-keyform\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nkeyform = str2fmt(*++args);\\r\\n} else if (!strcmp(*args, \"-keyopt\")) {\\r\\nint keyidx = -1;\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nif (operation == SMIME_ENCRYPT) {\\r\\nif (encerts)\\r\\nkeyidx += sk_X509_num(encerts);\\r\\n} else {\\r\\nif (keyfile || signerfile)\\r\\nkeyidx++;\\r\\nif (skkeys)\\r\\nkeyidx += sk_OPENSSL_STRING_num(skkeys);\\r\\n}\\r\\nif (keyidx < 0) {\\r\\nBIO_printf(bio_err, \"No key specified\\n\");\\r\\ngoto argerr;\\r\\n}\\r\\nif (key_param == NULL || key_param->idx != keyidx) {\\r\\ncms_key_param *nparam;\\r\\nnparam = OPENSSL_malloc(sizeof(cms_key_param));\\r\\nnparam->idx = keyidx;\\r\\nnparam->param = sk_OPENSSL_STRING_new_null();\\r\\nnparam->next = NULL;\\r\\nif (key_first == NULL)\\r\\nkey_first = nparam;\\r\\nelse\\r\\nkey_param->next = nparam;\\r\\nkey_param = nparam;\\r\\n}\\r\\nsk_OPENSSL_STRING_push(key_param->param, *++args);\\r\\n} else if (!strcmp(*args, \"-rctform\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nrctformat = str2fmt(*++args);\\r\\n} else if (!strcmp(*args, \"-certfile\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\ncertfile = *++args;\\r\\n} else if (!strcmp(*args, \"-CAfile\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nCAfile = *++args;\\r\\n} else if (!strcmp(*args, \"-CApath\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\nCApath = *++args;\\r\\n} else if (!strcmp(*args, \"-in\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\ninfile = *++args;\\r\\n} else if (!strcmp(*args, \"-inform\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\ninformat = str2fmt(*++args);\\r\\n} else if (!strcmp(*args, \"-outform\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\noutformat = str2fmt(*++args);\\r\\n} else if (!strcmp(*args, \"-out\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\noutfile = *++args;\\r\\n} else if (!strcmp(*args, \"-content\")) {\\r\\nif (!args[1])\\r\\ngoto argerr;\\r\\ncontfile = *++args;\\r\\n} else if (args_verify(&args, NULL, &badarg, bio_err, &vpm))\\r\\ncontinue;\\r\\nelse if ((cipher = EVP_get_cipherbyname(*args + 1)) == NULL)\\r\\nbadarg = 1;\\r\\nargs++;\\r\\n}\\r\\nif (((rr_allorfirst != -1) || rr_from) && !rr_to) {\\r\\nBIO_puts(bio_err, \"No Signed Receipts Recipients\\n\");\\r\\ngoto argerr;\\r\\n}\\r\\nif (!(operation & SMIME_SIGNERS) && (rr_to || rr_from)) {\\r\\nBIO_puts(bio_err, \"Signed receipts only allowed with -sign\\n\");\\r\\ngoto argerr;\\r\\n}\\r\\nif (!(operation & SMIME_SIGNERS) && (skkeys || sksigners)) {\\r\\nBIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\\r\\ngoto argerr;\\r\\n}\\r\\nif (operation & SMIME_SIGNERS) {\\r\\nif (keyfile && !signerfile) {\\r\\nBIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\\r\\ngoto argerr;\\r\\n}\\r\\nif (signerfile) {\\r\\nif (!sksigners)\\r\\nsksigners = sk_OPENSSL_STRING_new_null();\\r\\nsk_OPENSSL_STRING_push(sksigners, signerfile);\\r\\nif (!skkeys)\\r\\nskkeys = sk_OPENSSL_STRING_new_null();\\r\\nif (!keyfile)\\r\\nkeyfile = signerfile;\\r\\nsk_OPENSSL_STRING_push(skkeys, keyfile);\\r\\n}\\r\\nif (!sksigners) {\\r\\nBIO_printf(bio_err, \"No signer certificate specified\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\nsignerfile = NULL;\\r\\nkeyfile = NULL;\\r\\nneed_rand = 1;\\r\\n}\\r\\nelse if (operation == SMIME_DECRYPT) {\\r\\nif (!recipfile && !keyfile && !secret_key && !pwri_pass) {\\r\\nBIO_printf(bio_err,\\r\\n\"No recipient certificate or key specified\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\n} else if (operation == SMIME_ENCRYPT) {\\r\\nif (!*args && !secret_key && !pwri_pass && !encerts) {\\r\\nBIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\nneed_rand = 1;\\r\\n} else if (!operation)\\r\\nbadarg = 1;\\r\\nif (badarg) {\\r\\nargerr:\\r\\nBIO_printf(bio_err, \"Usage cms [options] cert.pem ...\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-encrypt encrypt message\\n\");\\r\\nBIO_printf(bio_err, \"-decrypt decrypt encrypted message\\n\");\\r\\nBIO_printf(bio_err, \"-sign sign message\\n\");\\r\\nBIO_printf(bio_err, \"-verify verify signed message\\n\");\\r\\nBIO_printf(bio_err, \"-cmsout output CMS structure\\n\");\\r\\n# ifndef OPENSSL_NO_DES\\r\\nBIO_printf(bio_err, \"-des3 encrypt with triple DES\\n\");\\r\\nBIO_printf(bio_err, \"-des encrypt with DES\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nBIO_printf(bio_err, \"-seed encrypt with SEED\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_RC2\\r\\nBIO_printf(bio_err, \"-rc2-40 encrypt with RC2-40 (default)\\n\");\\r\\nBIO_printf(bio_err, \"-rc2-64 encrypt with RC2-64\\n\");\\r\\nBIO_printf(bio_err, \"-rc2-128 encrypt with RC2-128\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err, \"-aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc aes\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nBIO_printf(bio_err, \"-camellia128, -camellia192, -camellia256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc camellia\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err,\\r\\n\"-nointern don't search certificates in message for signer\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nosigs don't verify message signature\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-noverify don't verify signers certificate\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nocerts don't include signers certificate when signing\\n\");\\r\\nBIO_printf(bio_err, \"-nodetach use opaque signing\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-noattr don't include any signed attributes\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-binary don't translate message to text\\n\");\\r\\nBIO_printf(bio_err, \"-certfile file other certificates file\\n\");\\r\\nBIO_printf(bio_err, \"-certsout file certificate output file\\n\");\\r\\nBIO_printf(bio_err, \"-signer file signer certificate file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-recip file recipient certificate file for decryption\\n\");\\r\\nBIO_printf(bio_err, \"-keyid use subject key identifier\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-inform arg input format SMIME (default), PEM or DER\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-inkey file input private key (if not signer or recipient)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-keyform arg input private key format (PEM or ENGINE)\\n\");\\r\\nBIO_printf(bio_err, \"-keyopt nm:v set public key parameters\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-outform arg output format SMIME (default), PEM or DER\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-content file supply or override content for detached signature\\n\");\\r\\nBIO_printf(bio_err, \"-to addr to address\\n\");\\r\\nBIO_printf(bio_err, \"-from ad from address\\n\");\\r\\nBIO_printf(bio_err, \"-subject s subject\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-text include or delete text MIME headers\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-CApath dir trusted certificates directory\\n\");\\r\\nBIO_printf(bio_err, \"-CAfile file trusted certificates file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-crl_check check revocation status of signer's certificate using CRLs\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-crl_check_all check revocation status of signer's certificate chain using CRLs\\n\");\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \"-passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \"-rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\\r\\n\" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"cert.pem recipient certificate(s) for encryption\\n\");\\r\\ngoto end;\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (need_rand) {\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n}\\r\\nret = 2;\\r\\nif (!(operation & SMIME_SIGNERS))\\r\\nflags &= ~CMS_DETACHED;\\r\\nif (operation & SMIME_OP) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\noutmode = \"wb\";\\r\\n} else {\\r\\nif (flags & CMS_BINARY)\\r\\noutmode = \"wb\";\\r\\n}\\r\\nif (operation & SMIME_IP) {\\r\\nif (informat == FORMAT_ASN1)\\r\\ninmode = \"rb\";\\r\\n} else {\\r\\nif (flags & CMS_BINARY)\\r\\ninmode = \"rb\";\\r\\n}\\r\\nif (operation == SMIME_ENCRYPT) {\\r\\nif (!cipher) {\\r\\n# ifndef OPENSSL_NO_DES\\r\\ncipher = EVP_des_ede3_cbc();\\r\\n# else\\r\\nBIO_printf(bio_err, \"No cipher selected\\n\");\\r\\ngoto end;\\r\\n# endif\\r\\n}\\r\\nif (secret_key && !secret_keyid) {\\r\\nBIO_printf(bio_err, \"No secret key id\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (*args && !encerts)\\r\\nencerts = sk_X509_new_null();\\r\\nwhile (*args) {\\r\\nif (!(cert = load_cert(bio_err, *args, FORMAT_PEM,\\r\\nNULL, e, \"recipient certificate file\")))\\r\\ngoto end;\\r\\nsk_X509_push(encerts, cert);\\r\\ncert = NULL;\\r\\nargs++;\\r\\n}\\r\\n}\\r\\nif (certfile) {\\r\\nif (!(other = load_certs(bio_err, certfile, FORMAT_PEM, NULL,\\r\\ne, \"certificate file\"))) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (recipfile && (operation == SMIME_DECRYPT)) {\\r\\nif (!(recip = load_cert(bio_err, recipfile, FORMAT_PEM, NULL,\\r\\ne, \"recipient certificate file\"))) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (operation == SMIME_SIGN_RECEIPT) {\\r\\nif (!(signer = load_cert(bio_err, signerfile, FORMAT_PEM, NULL,\\r\\ne, \"receipt signer certificate file\"))) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (operation == SMIME_DECRYPT) {\\r\\nif (!keyfile)\\r\\nkeyfile = recipfile;\\r\\n} else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {\\r\\nif (!keyfile)\\r\\nkeyfile = signerfile;\\r\\n} else\\r\\nkeyfile = NULL;\\r\\nif (keyfile) {\\r\\nkey = load_key(bio_err, keyfile, keyform, 0, passin, e,\\r\\n\"signing key file\");\\r\\nif (!key)\\r\\ngoto end;\\r\\n}\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file(infile, inmode))) {\\r\\nBIO_printf(bio_err, \"Can't open input file %s\\n\", infile);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (operation & SMIME_IP) {\\r\\nif (informat == FORMAT_SMIME)\\r\\ncms = SMIME_read_CMS(in, &indata);\\r\\nelse if (informat == FORMAT_PEM)\\r\\ncms = PEM_read_bio_CMS(in, NULL, NULL, NULL);\\r\\nelse if (informat == FORMAT_ASN1)\\r\\ncms = d2i_CMS_bio(in, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad input format for CMS file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!cms) {\\r\\nBIO_printf(bio_err, \"Error reading S/MIME message\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (contfile) {\\r\\nBIO_free(indata);\\r\\nif (!(indata = BIO_new_file(contfile, \"rb\"))) {\\r\\nBIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (certsoutfile) {\\r\\nSTACK_OF(X509) *allcerts;\\r\\nallcerts = CMS_get1_certs(cms);\\r\\nif (!save_certs(certsoutfile, allcerts)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error writing certs to %s\\n\", certsoutfile);\\r\\nret = 5;\\r\\ngoto end;\\r\\n}\\r\\nsk_X509_pop_free(allcerts, X509_free);\\r\\n}\\r\\n}\\r\\nif (rctfile) {\\r\\nchar *rctmode = (rctformat == FORMAT_ASN1) ? \"rb\" : \"r\";\\r\\nif (!(rctin = BIO_new_file(rctfile, rctmode))) {\\r\\nBIO_printf(bio_err, \"Can't open receipt file %s\\n\", rctfile);\\r\\ngoto end;\\r\\n}\\r\\nif (rctformat == FORMAT_SMIME)\\r\\nrcms = SMIME_read_CMS(rctin, NULL);\\r\\nelse if (rctformat == FORMAT_PEM)\\r\\nrcms = PEM_read_bio_CMS(rctin, NULL, NULL, NULL);\\r\\nelse if (rctformat == FORMAT_ASN1)\\r\\nrcms = d2i_CMS_bio(rctin, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad input format for receipt\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!rcms) {\\r\\nBIO_printf(bio_err, \"Error reading receipt\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file(outfile, outmode))) {\\r\\nBIO_printf(bio_err, \"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n}\\r\\nif ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {\\r\\nif (!(store = setup_verify(bio_err, CAfile, CApath)))\\r\\ngoto end;\\r\\nX509_STORE_set_verify_cb(store, cms_cb);\\r\\nif (vpm)\\r\\nX509_STORE_set1_param(store, vpm);\\r\\n}\\r\\nret = 3;\\r\\nif (operation == SMIME_DATA_CREATE) {\\r\\ncms = CMS_data_create(in, flags);\\r\\n} else if (operation == SMIME_DIGEST_CREATE) {\\r\\ncms = CMS_digest_create(in, sign_md, flags);\\r\\n} else if (operation == SMIME_COMPRESS) {\\r\\ncms = CMS_compress(in, -1, flags);\\r\\n} else if (operation == SMIME_ENCRYPT) {\\r\\nint i;\\r\\nflags |= CMS_PARTIAL;\\r\\ncms = CMS_encrypt(NULL, in, cipher, flags);\\r\\nif (!cms)\\r\\ngoto end;\\r\\nfor (i = 0; i < sk_X509_num(encerts); i++) {\\r\\nCMS_RecipientInfo *ri;\\r\\ncms_key_param *kparam;\\r\\nint tflags = flags;\\r\\nX509 *x = sk_X509_value(encerts, i);\\r\\nfor (kparam = key_first; kparam; kparam = kparam->next) {\\r\\nif (kparam->idx == i) {\\r\\ntflags |= CMS_KEY_PARAM;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nri = CMS_add1_recipient_cert(cms, x, tflags);\\r\\nif (!ri)\\r\\ngoto end;\\r\\nif (kparam) {\\r\\nEVP_PKEY_CTX *pctx;\\r\\npctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\\r\\nif (!cms_set_pkey_param(pctx, kparam->param))\\r\\ngoto end;\\r\\n}\\r\\nif (CMS_RecipientInfo_type(ri) == CMS_RECIPINFO_AGREE\\r\\n&& wrap_cipher) {\\r\\nEVP_CIPHER_CTX *wctx;\\r\\nwctx = CMS_RecipientInfo_kari_get0_ctx(ri);\\r\\nEVP_EncryptInit_ex(wctx, wrap_cipher, NULL, NULL, NULL);\\r\\n}\\r\\n}\\r\\nif (secret_key) {\\r\\nif (!CMS_add0_recipient_key(cms, NID_undef,\\r\\nsecret_key, secret_keylen,\\r\\nsecret_keyid, secret_keyidlen,\\r\\nNULL, NULL, NULL))\\r\\ngoto end;\\r\\nsecret_key = NULL;\\r\\nsecret_keyid = NULL;\\r\\n}\\r\\nif (pwri_pass) {\\r\\npwri_tmp = (unsigned char *)BUF_strdup((char *)pwri_pass);\\r\\nif (!pwri_tmp)\\r\\ngoto end;\\r\\nif (!CMS_add0_recipient_password(cms,\\r\\n-1, NID_undef, NID_undef,\\r\\npwri_tmp, -1, NULL))\\r\\ngoto end;\\r\\npwri_tmp = NULL;\\r\\n}\\r\\nif (!(flags & CMS_STREAM)) {\\r\\nif (!CMS_final(cms, in, NULL, flags))\\r\\ngoto end;\\r\\n}\\r\\n} else if (operation == SMIME_ENCRYPTED_ENCRYPT) {\\r\\ncms = CMS_EncryptedData_encrypt(in, cipher,\\r\\nsecret_key, secret_keylen, flags);\\r\\n} else if (operation == SMIME_SIGN_RECEIPT) {\\r\\nCMS_ContentInfo *srcms = NULL;\\r\\nSTACK_OF(CMS_SignerInfo) *sis;\\r\\nCMS_SignerInfo *si;\\r\\nsis = CMS_get0_SignerInfos(cms);\\r\\nif (!sis)\\r\\ngoto end;\\r\\nsi = sk_CMS_SignerInfo_value(sis, 0);\\r\\nsrcms = CMS_sign_receipt(si, signer, key, other, flags);\\r\\nif (!srcms)\\r\\ngoto end;\\r\\nCMS_ContentInfo_free(cms);\\r\\ncms = srcms;\\r\\n} else if (operation & SMIME_SIGNERS) {\\r\\nint i;\\r\\nif (operation == SMIME_SIGN) {\\r\\nif (flags & CMS_DETACHED) {\\r\\nif (outformat == FORMAT_SMIME)\\r\\nflags |= CMS_STREAM;\\r\\n}\\r\\nflags |= CMS_PARTIAL;\\r\\ncms = CMS_sign(NULL, NULL, other, in, flags);\\r\\nif (!cms)\\r\\ngoto end;\\r\\nif (econtent_type)\\r\\nCMS_set1_eContentType(cms, econtent_type);\\r\\nif (rr_to) {\\r\\nrr = make_receipt_request(rr_to, rr_allorfirst, rr_from);\\r\\nif (!rr) {\\r\\nBIO_puts(bio_err,\\r\\n\"Signed Receipt Request Creation Error\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n} else\\r\\nflags |= CMS_REUSE_DIGEST;\\r\\nfor (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\\r\\nCMS_SignerInfo *si;\\r\\ncms_key_param *kparam;\\r\\nint tflags = flags;\\r\\nsignerfile = sk_OPENSSL_STRING_value(sksigners, i);\\r\\nkeyfile = sk_OPENSSL_STRING_value(skkeys, i);\\r\\nsigner = load_cert(bio_err, signerfile, FORMAT_PEM, NULL,\\r\\ne, \"signer certificate\");\\r\\nif (!signer)\\r\\ngoto end;\\r\\nkey = load_key(bio_err, keyfile, keyform, 0, passin, e,\\r\\n\"signing key file\");\\r\\nif (!key)\\r\\ngoto end;\\r\\nfor (kparam = key_first; kparam; kparam = kparam->next) {\\r\\nif (kparam->idx == i) {\\r\\ntflags |= CMS_KEY_PARAM;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nsi = CMS_add1_signer(cms, signer, key, sign_md, tflags);\\r\\nif (!si)\\r\\ngoto end;\\r\\nif (kparam) {\\r\\nEVP_PKEY_CTX *pctx;\\r\\npctx = CMS_SignerInfo_get0_pkey_ctx(si);\\r\\nif (!cms_set_pkey_param(pctx, kparam->param))\\r\\ngoto end;\\r\\n}\\r\\nif (rr && !CMS_add1_ReceiptRequest(si, rr))\\r\\ngoto end;\\r\\nX509_free(signer);\\r\\nsigner = NULL;\\r\\nEVP_PKEY_free(key);\\r\\nkey = NULL;\\r\\n}\\r\\nif ((operation == SMIME_SIGN) && !(flags & CMS_STREAM)) {\\r\\nif (!CMS_final(cms, in, NULL, flags))\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!cms) {\\r\\nBIO_printf(bio_err, \"Error creating CMS structure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nret = 4;\\r\\nif (operation == SMIME_DECRYPT) {\\r\\nif (flags & CMS_DEBUG_DECRYPT)\\r\\nCMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);\\r\\nif (secret_key) {\\r\\nif (!CMS_decrypt_set1_key(cms,\\r\\nsecret_key, secret_keylen,\\r\\nsecret_keyid, secret_keyidlen)) {\\r\\nBIO_puts(bio_err, \"Error decrypting CMS using secret key\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (key) {\\r\\nif (!CMS_decrypt_set1_pkey(cms, key, recip)) {\\r\\nBIO_puts(bio_err, \"Error decrypting CMS using private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (pwri_pass) {\\r\\nif (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {\\r\\nBIO_puts(bio_err, \"Error decrypting CMS using password\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {\\r\\nBIO_printf(bio_err, \"Error decrypting CMS structure\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else if (operation == SMIME_DATAOUT) {\\r\\nif (!CMS_data(cms, out, flags))\\r\\ngoto end;\\r\\n} else if (operation == SMIME_UNCOMPRESS) {\\r\\nif (!CMS_uncompress(cms, indata, out, flags))\\r\\ngoto end;\\r\\n} else if (operation == SMIME_DIGEST_VERIFY) {\\r\\nif (CMS_digest_verify(cms, indata, out, flags) > 0)\\r\\nBIO_printf(bio_err, \"Verification successful\\n\");\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Verification failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else if (operation == SMIME_ENCRYPTED_DECRYPT) {\\r\\nif (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,\\r\\nindata, out, flags))\\r\\ngoto end;\\r\\n} else if (operation == SMIME_VERIFY) {\\r\\nif (CMS_verify(cms, other, store, indata, out, flags) > 0)\\r\\nBIO_printf(bio_err, \"Verification successful\\n\");\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Verification failure\\n\");\\r\\nif (verify_retcode)\\r\\nret = verify_err + 32;\\r\\ngoto end;\\r\\n}\\r\\nif (signerfile) {\\r\\nSTACK_OF(X509) *signers;\\r\\nsigners = CMS_get0_signers(cms);\\r\\nif (!save_certs(signerfile, signers)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error writing signers to %s\\n\", signerfile);\\r\\nret = 5;\\r\\ngoto end;\\r\\n}\\r\\nsk_X509_free(signers);\\r\\n}\\r\\nif (rr_print)\\r\\nreceipt_request_print(bio_err, cms);\\r\\n} else if (operation == SMIME_VERIFY_RECEIPT) {\\r\\nif (CMS_verify_receipt(rcms, cms, other, store, flags) > 0)\\r\\nBIO_printf(bio_err, \"Verification successful\\n\");\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Verification failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nif (noout) {\\r\\nif (print)\\r\\nCMS_ContentInfo_print_ctx(out, cms, 0, NULL);\\r\\n} else if (outformat == FORMAT_SMIME) {\\r\\nif (to)\\r\\nBIO_printf(out, \"To: %s\\n\", to);\\r\\nif (from)\\r\\nBIO_printf(out, \"From: %s\\n\", from);\\r\\nif (subject)\\r\\nBIO_printf(out, \"Subject: %s\\n\", subject);\\r\\nif (operation == SMIME_RESIGN)\\r\\nret = SMIME_write_CMS(out, cms, indata, flags);\\r\\nelse\\r\\nret = SMIME_write_CMS(out, cms, in, flags);\\r\\n} else if (outformat == FORMAT_PEM)\\r\\nret = PEM_write_bio_CMS_stream(out, cms, in, flags);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\nret = i2d_CMS_bio_stream(out, cms, in, flags);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad output format for CMS file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (ret <= 0) {\\r\\nret = 6;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (ret)\\r\\nERR_print_errors(bio_err);\\r\\nif (need_rand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nsk_X509_pop_free(encerts, X509_free);\\r\\nsk_X509_pop_free(other, X509_free);\\r\\nif (vpm)\\r\\nX509_VERIFY_PARAM_free(vpm);\\r\\nif (sksigners)\\r\\nsk_OPENSSL_STRING_free(sksigners);\\r\\nif (skkeys)\\r\\nsk_OPENSSL_STRING_free(skkeys);\\r\\nif (secret_key)\\r\\nOPENSSL_free(secret_key);\\r\\nif (secret_keyid)\\r\\nOPENSSL_free(secret_keyid);\\r\\nif (pwri_tmp)\\r\\nOPENSSL_free(pwri_tmp);\\r\\nif (econtent_type)\\r\\nASN1_OBJECT_free(econtent_type);\\r\\nif (rr)\\r\\nCMS_ReceiptRequest_free(rr);\\r\\nif (rr_to)\\r\\nsk_OPENSSL_STRING_free(rr_to);\\r\\nif (rr_from)\\r\\nsk_OPENSSL_STRING_free(rr_from);\\r\\nfor (key_param = key_first; key_param;) {\\r\\ncms_key_param *tparam;\\r\\nsk_OPENSSL_STRING_free(key_param->param);\\r\\ntparam = key_param->next;\\r\\nOPENSSL_free(key_param);\\r\\nkey_param = tparam;\\r\\n}\\r\\nX509_STORE_free(store);\\r\\nX509_free(cert);\\r\\nX509_free(recip);\\r\\nX509_free(signer);\\r\\nEVP_PKEY_free(key);\\r\\nCMS_ContentInfo_free(cms);\\r\\nCMS_ContentInfo_free(rcms);\\r\\nBIO_free(rctin);\\r\\nBIO_free(in);\\r\\nBIO_free(indata);\\r\\nBIO_free_all(out);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int cms_cb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nint error;\\r\\nerror = X509_STORE_CTX_get_error(ctx);\\r\\nverify_err = error;\\r\\nif ((error != X509_V_ERR_NO_EXPLICIT_POLICY)\\r\\n&& ((error != X509_V_OK) || (ok != 2)))\\r\\nreturn ok;\\r\\npolicies_print(NULL, ctx);\\r\\nreturn ok;\\r\\n}\\r\\nstatic void receipt_request_print(BIO *out, CMS_ContentInfo *cms)\\r\\n{\\r\\nSTACK_OF(CMS_SignerInfo) *sis;\\r\\nCMS_SignerInfo *si;\\r\\nCMS_ReceiptRequest *rr;\\r\\nint allorfirst;\\r\\nSTACK_OF(GENERAL_NAMES) *rto, *rlist;\\r\\nASN1_STRING *scid;\\r\\nint i, rv;\\r\\nsis = CMS_get0_SignerInfos(cms);\\r\\nfor (i = 0; i < sk_CMS_SignerInfo_num(sis); i++) {\\r\\nsi = sk_CMS_SignerInfo_value(sis, i);\\r\\nrv = CMS_get1_ReceiptRequest(si, &rr);\\r\\nBIO_printf(bio_err, \"Signer %d:\\n\", i + 1);\\r\\nif (rv == 0)\\r\\nBIO_puts(bio_err, \" No Receipt Request\\n\");\\r\\nelse if (rv < 0) {\\r\\nBIO_puts(bio_err, \" Receipt Request Parse Error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n} else {\\r\\nchar *id;\\r\\nint idlen;\\r\\nCMS_ReceiptRequest_get0_values(rr, &scid, &allorfirst,\\r\\n&rlist, &rto);\\r\\nBIO_puts(out, \" Signed Content ID:\\n\");\\r\\nidlen = ASN1_STRING_length(scid);\\r\\nid = (char *)ASN1_STRING_data(scid);\\r\\nBIO_dump_indent(out, id, idlen, 4);\\r\\nBIO_puts(out, \" Receipts From\");\\r\\nif (rlist) {\\r\\nBIO_puts(out, \" List:\\n\");\\r\\ngnames_stack_print(out, rlist);\\r\\n} else if (allorfirst == 1)\\r\\nBIO_puts(out, \": First Tier\\n\");\\r\\nelse if (allorfirst == 0)\\r\\nBIO_puts(out, \": All\\n\");\\r\\nelse\\r\\nBIO_printf(out, \" Unknown (%d)\\n\", allorfirst);\\r\\nBIO_puts(out, \" Receipts To:\\n\");\\r\\ngnames_stack_print(out, rto);\\r\\n}\\r\\nif (rr)\\r\\nCMS_ReceiptRequest_free(rr);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ui_lib_c", "target": 0, "func": "UI *UI_new(void)\\r\\n{\\r\\nreturn (UI_new_method(NULL));\\r\\n}\\r\\nUI *UI_new_method(const UI_METHOD *method)\\r\\n{\\r\\nUI *ret;\\r\\nret = (UI *)OPENSSL_malloc(sizeof(UI));\\r\\nif (ret == NULL) {\\r\\nUIerr(UI_F_UI_NEW_METHOD, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (method == NULL)\\r\\nret->meth = UI_get_default_method();\\r\\nelse\\r\\nret->meth = method;\\r\\nret->strings = NULL;\\r\\nret->user_data = NULL;\\r\\nret->flags = 0;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_UI, ret, &ret->ex_data);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void free_string(UI_STRING *uis)\\r\\n{\\r\\nif (uis->flags & OUT_STRING_FREEABLE) {\\r\\nOPENSSL_free((char *)uis->out_string);\\r\\nswitch (uis->type) {\\r\\ncase UIT_BOOLEAN:\\r\\nOPENSSL_free((char *)uis->_.boolean_data.action_desc);\\r\\nOPENSSL_free((char *)uis->_.boolean_data.ok_chars);\\r\\nOPENSSL_free((char *)uis->_.boolean_data.cancel_chars);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nOPENSSL_free(uis);\\r\\n}\\r\\nvoid UI_free(UI *ui)\\r\\n{\\r\\nif (ui == NULL)\\r\\nreturn;\\r\\nsk_UI_STRING_pop_free(ui->strings, free_string);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_UI, ui, &ui->ex_data);\\r\\nOPENSSL_free(ui);\\r\\n}\\r\\nstatic int allocate_string_stack(UI *ui)\\r\\n{\\r\\nif (ui->strings == NULL) {\\r\\nui->strings = sk_UI_STRING_new_null();\\r\\nif (ui->strings == NULL) {\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic UI_STRING *general_allocate_prompt(UI *ui, const char *prompt,\\r\\nint prompt_freeable,\\r\\nenum UI_string_types type,\\r\\nint input_flags, char *result_buf)\\r\\n{\\r\\nUI_STRING *ret = NULL;\\r\\nif (prompt == NULL) {\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_PROMPT, ERR_R_PASSED_NULL_PARAMETER);\\r\\n} else if ((type == UIT_PROMPT || type == UIT_VERIFY\\r\\n|| type == UIT_BOOLEAN) && result_buf == NULL) {\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_PROMPT, UI_R_NO_RESULT_BUFFER);\\r\\n} else if ((ret = (UI_STRING *)OPENSSL_malloc(sizeof(UI_STRING)))) {\\r\\nret->out_string = prompt;\\r\\nret->flags = prompt_freeable ? OUT_STRING_FREEABLE : 0;\\r\\nret->input_flags = input_flags;\\r\\nret->type = type;\\r\\nret->result_buf = result_buf;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int general_allocate_string(UI *ui, const char *prompt,\\r\\nint prompt_freeable,\\r\\nenum UI_string_types type, int input_flags,\\r\\nchar *result_buf, int minsize, int maxsize,\\r\\nconst char *test_buf)\\r\\n{\\r\\nint ret = -1;\\r\\nUI_STRING *s = general_allocate_prompt(ui, prompt, prompt_freeable,\\r\\ntype, input_flags, result_buf);\\r\\nif (s) {\\r\\nif (allocate_string_stack(ui) >= 0) {\\r\\ns->_.string_data.result_minsize = minsize;\\r\\ns->_.string_data.result_maxsize = maxsize;\\r\\ns->_.string_data.test_buf = test_buf;\\r\\nret = sk_UI_STRING_push(ui->strings, s);\\r\\nif (ret <= 0)\\r\\nret--;\\r\\n} else\\r\\nfree_string(s);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int general_allocate_boolean(UI *ui,\\r\\nconst char *prompt,\\r\\nconst char *action_desc,\\r\\nconst char *ok_chars,\\r\\nconst char *cancel_chars,\\r\\nint prompt_freeable,\\r\\nenum UI_string_types type,\\r\\nint input_flags, char *result_buf)\\r\\n{\\r\\nint ret = -1;\\r\\nUI_STRING *s;\\r\\nconst char *p;\\r\\nif (ok_chars == NULL) {\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN, ERR_R_PASSED_NULL_PARAMETER);\\r\\n} else if (cancel_chars == NULL) {\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN, ERR_R_PASSED_NULL_PARAMETER);\\r\\n} else {\\r\\nfor (p = ok_chars; *p; p++) {\\r\\nif (strchr(cancel_chars, *p)) {\\r\\nUIerr(UI_F_GENERAL_ALLOCATE_BOOLEAN,\\r\\nUI_R_COMMON_OK_AND_CANCEL_CHARACTERS);\\r\\n}\\r\\n}\\r\\ns = general_allocate_prompt(ui, prompt, prompt_freeable,\\r\\ntype, input_flags, result_buf);\\r\\nif (s) {\\r\\nif (allocate_string_stack(ui) >= 0) {\\r\\ns->_.boolean_data.action_desc = action_desc;\\r\\ns->_.boolean_data.ok_chars = ok_chars;\\r\\ns->_.boolean_data.cancel_chars = cancel_chars;\\r\\nret = sk_UI_STRING_push(ui->strings, s);\\r\\nif (ret <= 0)\\r\\nret--;\\r\\n} else\\r\\nfree_string(s);\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint UI_add_input_string(UI *ui, const char *prompt, int flags,\\r\\nchar *result_buf, int minsize, int maxsize)\\r\\n{\\r\\nreturn general_allocate_string(ui, prompt, 0,\\r\\nUIT_PROMPT, flags, result_buf, minsize,\\r\\nmaxsize, NULL);\\r\\n}\\r\\nint UI_dup_input_string(UI *ui, const char *prompt, int flags,\\r\\nchar *result_buf, int minsize, int maxsize)\\r\\n{\\r\\nchar *prompt_copy = NULL;\\r\\nif (prompt) {\\r\\nprompt_copy = BUF_strdup(prompt);\\r\\nif (prompt_copy == NULL) {\\r\\nUIerr(UI_F_UI_DUP_INPUT_STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_string(ui, prompt_copy, 1,\\r\\nUIT_PROMPT, flags, result_buf, minsize,\\r\\nmaxsize, NULL);\\r\\n}\\r\\nint UI_add_verify_string(UI *ui, const char *prompt, int flags,\\r\\nchar *result_buf, int minsize, int maxsize,\\r\\nconst char *test_buf)\\r\\n{\\r\\nreturn general_allocate_string(ui, prompt, 0,\\r\\nUIT_VERIFY, flags, result_buf, minsize,\\r\\nmaxsize, test_buf);\\r\\n}\\r\\nint UI_dup_verify_string(UI *ui, const char *prompt, int flags,\\r\\nchar *result_buf, int minsize, int maxsize,\\r\\nconst char *test_buf)\\r\\n{\\r\\nchar *prompt_copy = NULL;\\r\\nif (prompt) {\\r\\nprompt_copy = BUF_strdup(prompt);\\r\\nif (prompt_copy == NULL) {\\r\\nUIerr(UI_F_UI_DUP_VERIFY_STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_string(ui, prompt_copy, 1,\\r\\nUIT_VERIFY, flags, result_buf, minsize,\\r\\nmaxsize, test_buf);\\r\\n}\\r\\nint UI_add_input_boolean(UI *ui, const char *prompt, const char *action_desc,\\r\\nconst char *ok_chars, const char *cancel_chars,\\r\\nint flags, char *result_buf)\\r\\n{\\r\\nreturn general_allocate_boolean(ui, prompt, action_desc,\\r\\nok_chars, cancel_chars, 0, UIT_BOOLEAN,\\r\\nflags, result_buf);\\r\\n}\\r\\nint UI_dup_input_boolean(UI *ui, const char *prompt, const char *action_desc,\\r\\nconst char *ok_chars, const char *cancel_chars,\\r\\nint flags, char *result_buf)\\r\\n{\\r\\nchar *prompt_copy = NULL;\\r\\nchar *action_desc_copy = NULL;\\r\\nchar *ok_chars_copy = NULL;\\r\\nchar *cancel_chars_copy = NULL;\\r\\nif (prompt) {\\r\\nprompt_copy = BUF_strdup(prompt);\\r\\nif (prompt_copy == NULL) {\\r\\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (action_desc) {\\r\\naction_desc_copy = BUF_strdup(action_desc);\\r\\nif (action_desc_copy == NULL) {\\r\\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (ok_chars) {\\r\\nok_chars_copy = BUF_strdup(ok_chars);\\r\\nif (ok_chars_copy == NULL) {\\r\\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (cancel_chars) {\\r\\ncancel_chars_copy = BUF_strdup(cancel_chars);\\r\\nif (cancel_chars_copy == NULL) {\\r\\nUIerr(UI_F_UI_DUP_INPUT_BOOLEAN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_boolean(ui, prompt_copy, action_desc_copy,\\r\\nok_chars_copy, cancel_chars_copy, 1,\\r\\nUIT_BOOLEAN, flags, result_buf);\\r\\nerr:\\r\\nif (prompt_copy)\\r\\nOPENSSL_free(prompt_copy);\\r\\nif (action_desc_copy)\\r\\nOPENSSL_free(action_desc_copy);\\r\\nif (ok_chars_copy)\\r\\nOPENSSL_free(ok_chars_copy);\\r\\nif (cancel_chars_copy)\\r\\nOPENSSL_free(cancel_chars_copy);\\r\\nreturn -1;\\r\\n}\\r\\nint UI_add_info_string(UI *ui, const char *text)\\r\\n{\\r\\nreturn general_allocate_string(ui, text, 0, UIT_INFO, 0, NULL, 0, 0,\\r\\nNULL);\\r\\n}\\r\\nint UI_dup_info_string(UI *ui, const char *text)\\r\\n{\\r\\nchar *text_copy = NULL;\\r\\nif (text) {\\r\\ntext_copy = BUF_strdup(text);\\r\\nif (text_copy == NULL) {\\r\\nUIerr(UI_F_UI_DUP_INFO_STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_string(ui, text_copy, 1, UIT_INFO, 0, NULL,\\r\\n0, 0, NULL);\\r\\n}\\r\\nint UI_add_error_string(UI *ui, const char *text)\\r\\n{\\r\\nreturn general_allocate_string(ui, text, 0, UIT_ERROR, 0, NULL, 0, 0,\\r\\nNULL);\\r\\n}\\r\\nint UI_dup_error_string(UI *ui, const char *text)\\r\\n{\\r\\nchar *text_copy = NULL;\\r\\nif (text) {\\r\\ntext_copy = BUF_strdup(text);\\r\\nif (text_copy == NULL) {\\r\\nUIerr(UI_F_UI_DUP_ERROR_STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nreturn general_allocate_string(ui, text_copy, 1, UIT_ERROR, 0, NULL,\\r\\n0, 0, NULL);\\r\\n}\\r\\nchar *UI_construct_prompt(UI *ui, const char *object_desc,\\r\\nconst char *object_name)\\r\\n{\\r\\nchar *prompt = NULL;\\r\\nif (ui->meth->ui_construct_prompt)\\r\\nprompt = ui->meth->ui_construct_prompt(ui, object_desc, object_name);\\r\\nelse {\\r\\nchar prompt1[] = \"Enter \";\\r\\nchar prompt2[] = \" for \";\\r\\nchar prompt3[] = \":\";\\r\\nint len = 0;\\r\\nif (object_desc == NULL)\\r\\nreturn NULL;\\r\\nlen = sizeof(prompt1) - 1 + strlen(object_desc);\\r\\nif (object_name)\\r\\nlen += sizeof(prompt2) - 1 + strlen(object_name);\\r\\nlen += sizeof(prompt3) - 1;\\r\\nprompt = (char *)OPENSSL_malloc(len + 1);\\r\\nBUF_strlcpy(prompt, prompt1, len + 1);\\r\\nBUF_strlcat(prompt, object_desc, len + 1);\\r\\nif (object_name) {\\r\\nBUF_strlcat(prompt, prompt2, len + 1);\\r\\nBUF_strlcat(prompt, object_name, len + 1);\\r\\n}\\r\\nBUF_strlcat(prompt, prompt3, len + 1);\\r\\n}\\r\\nreturn prompt;\\r\\n}\\r\\nvoid *UI_add_user_data(UI *ui, void *user_data)\\r\\n{\\r\\nvoid *old_data = ui->user_data;\\r\\nui->user_data = user_data;\\r\\nreturn old_data;\\r\\n}\\r\\nvoid *UI_get0_user_data(UI *ui)\\r\\n{\\r\\nreturn ui->user_data;\\r\\n}\\r\\nconst char *UI_get0_result(UI *ui, int i)\\r\\n{\\r\\nif (i < 0) {\\r\\nUIerr(UI_F_UI_GET0_RESULT, UI_R_INDEX_TOO_SMALL);\\r\\nreturn NULL;\\r\\n}\\r\\nif (i >= sk_UI_STRING_num(ui->strings)) {\\r\\nUIerr(UI_F_UI_GET0_RESULT, UI_R_INDEX_TOO_LARGE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn UI_get0_result_string(sk_UI_STRING_value(ui->strings, i));\\r\\n}\\r\\nstatic int print_error(const char *str, size_t len, UI *ui)\\r\\n{\\r\\nUI_STRING uis;\\r\\nmemset(&uis, 0, sizeof(uis));\\r\\nuis.type = UIT_ERROR;\\r\\nuis.out_string = str;\\r\\nif (ui->meth->ui_write_string && !ui->meth->ui_write_string(ui, &uis))\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n}\\r\\nint UI_process(UI *ui)\\r\\n{\\r\\nint i, ok = 0;\\r\\nif (ui->meth->ui_open_session && !ui->meth->ui_open_session(ui))\\r\\nreturn -1;\\r\\nif (ui->flags & UI_FLAG_PRINT_ERRORS)\\r\\nERR_print_errors_cb((int (*)(const char *, size_t, void *))\\r\\nprint_error, (void *)ui);\\r\\nfor (i = 0; i < sk_UI_STRING_num(ui->strings); i++) {\\r\\nif (ui->meth->ui_write_string\\r\\n&& !ui->meth->ui_write_string(ui,\\r\\nsk_UI_STRING_value(ui->strings, i)))\\r\\n{\\r\\nok = -1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (ui->meth->ui_flush)\\r\\nswitch (ui->meth->ui_flush(ui)) {\\r\\ncase -1:\\r\\nok = -2;\\r\\ngoto err;\\r\\ncase 0:\\r\\nok = -1;\\r\\ngoto err;\\r\\ndefault:\\r\\nok = 0;\\r\\nbreak;\\r\\n}\\r\\nfor (i = 0; i < sk_UI_STRING_num(ui->strings); i++) {\\r\\nif (ui->meth->ui_read_string) {\\r\\nswitch (ui->meth->ui_read_string(ui,\\r\\nsk_UI_STRING_value(ui->strings,\\r\\ni))) {\\r\\ncase -1:\\r\\nok = -2;\\r\\ngoto err;\\r\\ncase 0:\\r\\nok = -1;\\r\\ngoto err;\\r\\ndefault:\\r\\nok = 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (ui->meth->ui_close_session && !ui->meth->ui_close_session(ui))\\r\\nreturn -1;\\r\\nreturn ok;\\r\\n}\\r\\nint UI_ctrl(UI *ui, int cmd, long i, void *p, void (*f) (void))\\r\\n{\\r\\nif (ui == NULL) {\\r\\nUIerr(UI_F_UI_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn -1;\\r\\n}\\r\\nswitch (cmd) {\\r\\ncase UI_CTRL_PRINT_ERRORS:\\r\\n{\\r\\nint save_flag = ! !(ui->flags & UI_FLAG_PRINT_ERRORS);\\r\\nif (i)\\r\\nui->flags |= UI_FLAG_PRINT_ERRORS;\\r\\nelse\\r\\nui->flags &= ~UI_FLAG_PRINT_ERRORS;\\r\\nreturn save_flag;\\r\\n}\\r\\ncase UI_CTRL_IS_REDOABLE:\\r\\nreturn ! !(ui->flags & UI_FLAG_REDOABLE);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nUIerr(UI_F_UI_CTRL, UI_R_UNKNOWN_CONTROL_COMMAND);\\r\\nreturn -1;\\r\\n}\\r\\nint UI_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_UI, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint UI_set_ex_data(UI *r, int idx, void *arg)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&r->ex_data, idx, arg));\\r\\n}\\r\\nvoid *UI_get_ex_data(UI *r, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&r->ex_data, idx));\\r\\n}\\r\\nvoid UI_set_default_method(const UI_METHOD *meth)\\r\\n{\\r\\ndefault_UI_meth = meth;\\r\\n}\\r\\nconst UI_METHOD *UI_get_default_method(void)\\r\\n{\\r\\nif (default_UI_meth == NULL) {\\r\\ndefault_UI_meth = UI_OpenSSL();\\r\\n}\\r\\nreturn default_UI_meth;\\r\\n}\\r\\nconst UI_METHOD *UI_get_method(UI *ui)\\r\\n{\\r\\nreturn ui->meth;\\r\\n}\\r\\nconst UI_METHOD *UI_set_method(UI *ui, const UI_METHOD *meth)\\r\\n{\\r\\nui->meth = meth;\\r\\nreturn ui->meth;\\r\\n}\\r\\nUI_METHOD *UI_create_method(char *name)\\r\\n{\\r\\nUI_METHOD *ui_method = (UI_METHOD *)OPENSSL_malloc(sizeof(UI_METHOD));\\r\\nif (ui_method) {\\r\\nmemset(ui_method, 0, sizeof(*ui_method));\\r\\nui_method->name = BUF_strdup(name);\\r\\n}\\r\\nreturn ui_method;\\r\\n}\\r\\nvoid UI_destroy_method(UI_METHOD *ui_method)\\r\\n{\\r\\nOPENSSL_free(ui_method->name);\\r\\nui_method->name = NULL;\\r\\nOPENSSL_free(ui_method);\\r\\n}\\r\\nint UI_method_set_opener(UI_METHOD *method, int (*opener) (UI *ui))\\r\\n{\\r\\nif (method) {\\r\\nmethod->ui_open_session = opener;\\r\\nreturn 0;\\r\\n} else\\r\\nreturn -1;\\r\\n}\\r\\nint UI_method_set_writer(UI_METHOD *method,\\r\\nint (*writer) (UI *ui, UI_STRING *uis))\\r\\n{\\r\\nif (method) {\\r\\nmethod->ui_write_string = writer;\\r\\nreturn 0;\\r\\n} else\\r\\nreturn -1;\\r\\n}\\r\\nint UI_method_set_flusher(UI_METHOD *method, int (*flusher) (UI *ui))\\r\\n{\\r\\nif (method) {\\r\\nmethod->ui_flush = flusher;\\r\\nreturn 0;\\r\\n} else\\r\\nreturn -1;\\r\\n}\\r\\nint UI_method_set_reader(UI_METHOD *method,\\r\\nint (*reader) (UI *ui, UI_STRING *uis))\\r\\n{\\r\\nif (method) {\\r\\nmethod->ui_read_string = reader;\\r\\nreturn 0;\\r\\n} else\\r\\nreturn -1;\\r\\n}\\r\\nint UI_method_set_closer(UI_METHOD *method, int (*closer) (UI *ui))\\r\\n{\\r\\nif (method) {\\r\\nmethod->ui_close_session = closer;\\r\\nreturn 0;\\r\\n} else\\r\\nreturn -1;\\r\\n}\\r\\nint UI_method_set_prompt_constructor(UI_METHOD *method,\\r\\nchar *(*prompt_constructor) (UI *ui,\\r\\nconst char\\r\\n*object_desc,\\r\\nconst char\\r\\n*object_name))\\r\\n{\\r\\nif (method) {\\r\\nmethod->ui_construct_prompt = prompt_constructor;\\r\\nreturn 0;\\r\\n} else\\r\\nreturn -1;\\r\\n}\\r\\nenum UI_string_types UI_get_string_type(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn UIT_NONE;\\r\\nreturn uis->type;\\r\\n}\\r\\nint UI_get_input_flags(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn 0;\\r\\nreturn uis->input_flags;\\r\\n}\\r\\nconst char *UI_get0_output_string(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn NULL;\\r\\nreturn uis->out_string;\\r\\n}\\r\\nconst char *UI_get0_action_string(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn NULL;\\r\\nswitch (uis->type) {\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_BOOLEAN:\\r\\nreturn uis->_.boolean_data.action_desc;\\r\\ndefault:\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nconst char *UI_get0_result_string(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn NULL;\\r\\nswitch (uis->type) {\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\nreturn uis->result_buf;\\r\\ndefault:\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nconst char *UI_get0_test_string(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn NULL;\\r\\nswitch (uis->type) {\\r\\ncase UIT_VERIFY:\\r\\nreturn uis->_.string_data.test_buf;\\r\\ndefault:\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nint UI_get_result_minsize(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn -1;\\r\\nswitch (uis->type) {\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\nreturn uis->_.string_data.result_minsize;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nint UI_get_result_maxsize(UI_STRING *uis)\\r\\n{\\r\\nif (!uis)\\r\\nreturn -1;\\r\\nswitch (uis->type) {\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\nreturn uis->_.string_data.result_maxsize;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nint UI_set_result(UI *ui, UI_STRING *uis, const char *result)\\r\\n{\\r\\nint l = strlen(result);\\r\\nui->flags &= ~UI_FLAG_REDOABLE;\\r\\nif (!uis)\\r\\nreturn -1;\\r\\nswitch (uis->type) {\\r\\ncase UIT_PROMPT:\\r\\ncase UIT_VERIFY:\\r\\n{\\r\\nchar number1[DECIMAL_SIZE(uis->_.string_data.result_minsize) + 1];\\r\\nchar number2[DECIMAL_SIZE(uis->_.string_data.result_maxsize) + 1];\\r\\nBIO_snprintf(number1, sizeof(number1), \"%d\",\\r\\nuis->_.string_data.result_minsize);\\r\\nBIO_snprintf(number2, sizeof(number2), \"%d\",\\r\\nuis->_.string_data.result_maxsize);\\r\\nif (l < uis->_.string_data.result_minsize) {\\r\\nui->flags |= UI_FLAG_REDOABLE;\\r\\nUIerr(UI_F_UI_SET_RESULT, UI_R_RESULT_TOO_SMALL);\\r\\nERR_add_error_data(5, \"You must type in \",\\r\\nnumber1, \" to \", number2, \" characters\");\\r\\nreturn -1;\\r\\n}\\r\\nif (l > uis->_.string_data.result_maxsize) {\\r\\nui->flags |= UI_FLAG_REDOABLE;\\r\\nUIerr(UI_F_UI_SET_RESULT, UI_R_RESULT_TOO_LARGE);\\r\\nERR_add_error_data(5, \"You must type in \",\\r\\nnumber1, \" to \", number2, \" characters\");\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif (!uis->result_buf) {\\r\\nUIerr(UI_F_UI_SET_RESULT, UI_R_NO_RESULT_BUFFER);\\r\\nreturn -1;\\r\\n}\\r\\nBUF_strlcpy(uis->result_buf, result,\\r\\nuis->_.string_data.result_maxsize + 1);\\r\\nbreak;\\r\\ncase UIT_BOOLEAN:\\r\\n{\\r\\nconst char *p;\\r\\nif (!uis->result_buf) {\\r\\nUIerr(UI_F_UI_SET_RESULT, UI_R_NO_RESULT_BUFFER);\\r\\nreturn -1;\\r\\n}\\r\\nuis->result_buf[0] = '\\0';\\r\\nfor (p = result; *p; p++) {\\r\\nif (strchr(uis->_.boolean_data.ok_chars, *p)) {\\r\\nuis->result_buf[0] = uis->_.boolean_data.ok_chars[0];\\r\\nbreak;\\r\\n}\\r\\nif (strchr(uis->_.boolean_data.cancel_chars, *p)) {\\r\\nuis->result_buf[0] = uis->_.boolean_data.cancel_chars[0];\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_rdrand_c", "target": 0, "func": "static int get_random_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nsize_t rnd;\\r\\nwhile (num >= (int)sizeof(size_t)) {\\r\\nif ((rnd = OPENSSL_ia32_rdrand()) == 0)\\r\\nreturn 0;\\r\\n*((size_t *)buf) = rnd;\\r\\nbuf += sizeof(size_t);\\r\\nnum -= sizeof(size_t);\\r\\n}\\r\\nif (num) {\\r\\nif ((rnd = OPENSSL_ia32_rdrand()) == 0)\\r\\nreturn 0;\\r\\nmemcpy(buf, &rnd, num);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int random_status(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rdrand_init(ENGINE *e)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_helper(ENGINE *e)\\r\\n{\\r\\nif (!ENGINE_set_id(e, engine_e_rdrand_id) ||\\r\\n!ENGINE_set_name(e, engine_e_rdrand_name) ||\\r\\n!ENGINE_set_flags(e, ENGINE_FLAGS_NO_REGISTER_ALL) ||\\r\\n!ENGINE_set_init_function(e, rdrand_init) ||\\r\\n!ENGINE_set_RAND(e, &rdrand_meth))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *ENGINE_rdrand(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!bind_helper(ret)) {\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_rdrand(void)\\r\\n{\\r\\nextern unsigned int OPENSSL_ia32cap_P[];\\r\\nif (OPENSSL_ia32cap_P[1] & (1 << (62 - 32))) {\\r\\nENGINE *toadd = ENGINE_rdrand();\\r\\nif (!toadd)\\r\\nreturn;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\nvoid ENGINE_load_rdrand(void)\\r\\n{\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_vfy_c", "target": 1, "func": "static int null_callback(int ok, X509_STORE_CTX *e)\\r\\n{\\r\\nreturn ok;\\r\\n}\\r\\nstatic int cert_self_signed(X509 *x)\\r\\n{\\r\\nX509_check_purpose(x, -1, 0);\\r\\nif (x->ex_flags & EXFLAG_SS)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nstatic X509 *lookup_cert_match(X509_STORE_CTX *ctx, X509 *x)\\r\\n{\\r\\nSTACK_OF(X509) *certs;\\r\\nX509 *xtmp = NULL;\\r\\nint i;\\r\\ncerts = ctx->lookup_certs(ctx, X509_get_subject_name(x));\\r\\nif (certs == NULL)\\r\\nreturn NULL;\\r\\nfor (i = 0; i < sk_X509_num(certs); i++) {\\r\\nxtmp = sk_X509_value(certs, i);\\r\\nif (!X509_cmp(xtmp, x))\\r\\nbreak;\\r\\n}\\r\\nif (i < sk_X509_num(certs))\\r\\nCRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\\r\\nelse\\r\\nxtmp = NULL;\\r\\nsk_X509_pop_free(certs, X509_free);\\r\\nreturn xtmp;\\r\\n}\\r\\nint X509_verify_cert(X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509 *x, *xtmp, *chain_ss = NULL;\\r\\nint bad_chain = 0;\\r\\nX509_VERIFY_PARAM *param = ctx->param;\\r\\nint depth, i, ok = 0;\\r\\nint num;\\r\\nint (*cb) (int xok, X509_STORE_CTX *xctx);\\r\\nSTACK_OF(X509) *sktmp = NULL;\\r\\nif (ctx->cert == NULL) {\\r\\nX509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\\r\\nreturn -1;\\r\\n}\\r\\ncb = ctx->verify_cb;\\r\\nif (ctx->chain == NULL) {\\r\\nif (((ctx->chain = sk_X509_new_null()) == NULL) ||\\r\\n(!sk_X509_push(ctx->chain, ctx->cert))) {\\r\\nX509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nCRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);\\r\\nctx->last_untrusted = 1;\\r\\n}\\r\\nif (ctx->untrusted != NULL\\r\\n&& (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\\r\\nX509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nnum = sk_X509_num(ctx->chain);\\r\\nx = sk_X509_value(ctx->chain, num - 1);\\r\\ndepth = param->depth;\\r\\nfor (;;) {\\r\\nif (depth < num)\\r\\nbreak;\\r\\nif (cert_self_signed(x))\\r\\nbreak;\\r\\nif (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {\\r\\nok = ctx->get_issuer(&xtmp, ctx, x);\\r\\nif (ok < 0)\\r\\nreturn ok;\\r\\nif (ok > 0) {\\r\\nX509_free(xtmp);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (ctx->untrusted != NULL) {\\r\\nxtmp = find_issuer(ctx, sktmp, x);\\r\\nif (xtmp != NULL) {\\r\\nif (!sk_X509_push(ctx->chain, xtmp)) {\\r\\nX509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nCRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\\r\\n(void)sk_X509_delete_ptr(sktmp, xtmp);\\r\\nctx->last_untrusted++;\\r\\nx = xtmp;\\r\\nnum++;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\n}\\r\\ni = sk_X509_num(ctx->chain);\\r\\nx = sk_X509_value(ctx->chain, i - 1);\\r\\nif (cert_self_signed(x)) {\\r\\nif (sk_X509_num(ctx->chain) == 1) {\\r\\nok = ctx->get_issuer(&xtmp, ctx, x);\\r\\nif ((ok <= 0) || X509_cmp(x, xtmp)) {\\r\\nctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\\r\\nctx->current_cert = x;\\r\\nctx->error_depth = i - 1;\\r\\nif (ok == 1)\\r\\nX509_free(xtmp);\\r\\nbad_chain = 1;\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n} else {\\r\\nX509_free(x);\\r\\nx = xtmp;\\r\\n(void)sk_X509_set(ctx->chain, i - 1, x);\\r\\nctx->last_untrusted = 0;\\r\\n}\\r\\n} else {\\r\\nchain_ss = sk_X509_pop(ctx->chain);\\r\\nctx->last_untrusted--;\\r\\nnum--;\\r\\nx = sk_X509_value(ctx->chain, num - 1);\\r\\n}\\r\\n}\\r\\nfor (;;) {\\r\\nif (depth < num)\\r\\nbreak;\\r\\nif (cert_self_signed(x))\\r\\nbreak;\\r\\nok = ctx->get_issuer(&xtmp, ctx, x);\\r\\nif (ok < 0)\\r\\nreturn ok;\\r\\nif (ok == 0)\\r\\nbreak;\\r\\nx = xtmp;\\r\\nif (!sk_X509_push(ctx->chain, x)) {\\r\\nX509_free(xtmp);\\r\\nX509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nnum++;\\r\\n}\\r\\ni = check_trust(ctx);\\r\\nif (i == X509_TRUST_REJECTED)\\r\\ngoto end;\\r\\nif (i != X509_TRUST_TRUSTED && !bad_chain) {\\r\\nif ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\\r\\nif (ctx->last_untrusted >= num)\\r\\nctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\\r\\nelse\\r\\nctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\\r\\nctx->current_cert = x;\\r\\n} else {\\r\\nsk_X509_push(ctx->chain, chain_ss);\\r\\nnum++;\\r\\nctx->last_untrusted = num;\\r\\nctx->current_cert = chain_ss;\\r\\nctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\\r\\nchain_ss = NULL;\\r\\n}\\r\\nctx->error_depth = num - 1;\\r\\nbad_chain = 1;\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n}\\r\\nok = check_chain_extensions(ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\nok = check_name_constraints(ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\nok = check_id(ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\nX509_get_pubkey_parameters(NULL, ctx->chain);\\r\\nok = ctx->check_revocation(ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\ni = X509_chain_check_suiteb(&ctx->error_depth, NULL, ctx->chain,\\r\\nctx->param->flags);\\r\\nif (i != X509_V_OK) {\\r\\nctx->error = i;\\r\\nctx->current_cert = sk_X509_value(ctx->chain, ctx->error_depth);\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n}\\r\\nif (ctx->verify != NULL)\\r\\nok = ctx->verify(ctx);\\r\\nelse\\r\\nok = internal_verify(ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n#ifndef OPENSSL_NO_RFC3779\\r\\nok = v3_asid_validate_path(ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\nok = v3_addr_validate_path(ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n#endif\\r\\nif (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\\r\\nok = ctx->check_policy(ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\nif (0) {\\r\\nend:\\r\\nX509_get_pubkey_parameters(NULL, ctx->chain);\\r\\n}\\r\\nif (sktmp != NULL)\\r\\nsk_X509_free(sktmp);\\r\\nif (chain_ss != NULL)\\r\\nX509_free(chain_ss);\\r\\nreturn ok;\\r\\n}\\r\\nstatic int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)\\r\\n{\\r\\nint ret;\\r\\nret = X509_check_issued(issuer, x);\\r\\nif (ret == X509_V_OK)\\r\\nreturn 1;\\r\\nif (!(ctx->param->flags & X509_V_FLAG_CB_ISSUER_CHECK))\\r\\nreturn 0;\\r\\nctx->error = ret;\\r\\nctx->current_cert = x;\\r\\nctx->current_issuer = issuer;\\r\\nreturn ctx->verify_cb(0, ctx);\\r\\n}\\r\\nstatic int get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)\\r\\n{\\r\\n*issuer = find_issuer(ctx, ctx->other_ctx, x);\\r\\nif (*issuer) {\\r\\nCRYPTO_add(&(*issuer)->references, 1, CRYPTO_LOCK_X509);\\r\\nreturn 1;\\r\\n} else\\r\\nreturn 0;\\r\\n}\\r\\nstatic int check_chain_extensions(X509_STORE_CTX *ctx)\\r\\n{\\r\\n#ifdef OPENSSL_NO_CHAIN_VERIFY\\r\\nreturn 1;\\r\\n#else\\r\\nint i, ok = 0, must_be_ca, plen = 0;\\r\\nX509 *x;\\r\\nint (*cb) (int xok, X509_STORE_CTX *xctx);\\r\\nint proxy_path_length = 0;\\r\\nint purpose;\\r\\nint allow_proxy_certs;\\r\\ncb = ctx->verify_cb;\\r\\nmust_be_ca = -1;\\r\\nif (ctx->parent) {\\r\\nallow_proxy_certs = 0;\\r\\npurpose = X509_PURPOSE_CRL_SIGN;\\r\\n} else {\\r\\nallow_proxy_certs =\\r\\n! !(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);\\r\\nif (getenv(\"OPENSSL_ALLOW_PROXY_CERTS\"))\\r\\nallow_proxy_certs = 1;\\r\\npurpose = ctx->param->purpose;\\r\\n}\\r\\nfor (i = 0; i < ctx->last_untrusted; i++) {\\r\\nint ret;\\r\\nx = sk_X509_value(ctx->chain, i);\\r\\nif (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)\\r\\n&& (x->ex_flags & EXFLAG_CRITICAL)) {\\r\\nctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n}\\r\\nif (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {\\r\\nctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n}\\r\\nret = X509_check_ca(x);\\r\\nswitch (must_be_ca) {\\r\\ncase -1:\\r\\nif ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\\r\\n&& (ret != 1) && (ret != 0)) {\\r\\nret = 0;\\r\\nctx->error = X509_V_ERR_INVALID_CA;\\r\\n} else\\r\\nret = 1;\\r\\nbreak;\\r\\ncase 0:\\r\\nif (ret != 0) {\\r\\nret = 0;\\r\\nctx->error = X509_V_ERR_INVALID_NON_CA;\\r\\n} else\\r\\nret = 1;\\r\\nbreak;\\r\\ndefault:\\r\\nif ((ret == 0)\\r\\n|| ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\\r\\n&& (ret != 1))) {\\r\\nret = 0;\\r\\nctx->error = X509_V_ERR_INVALID_CA;\\r\\n} else\\r\\nret = 1;\\r\\nbreak;\\r\\n}\\r\\nif (ret == 0) {\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n}\\r\\nif (ctx->param->purpose > 0) {\\r\\nret = X509_check_purpose(x, purpose, must_be_ca > 0);\\r\\nif ((ret == 0)\\r\\n|| ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\\r\\n&& (ret != 1))) {\\r\\nctx->error = X509_V_ERR_INVALID_PURPOSE;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif ((i > 1) && !(x->ex_flags & EXFLAG_SI)\\r\\n&& (x->ex_pathlen != -1)\\r\\n&& (plen > (x->ex_pathlen + proxy_path_length + 1))) {\\r\\nctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n}\\r\\nif (!(x->ex_flags & EXFLAG_SI))\\r\\nplen++;\\r\\nif (x->ex_flags & EXFLAG_PROXY) {\\r\\nif (x->ex_pcpathlen != -1 && i > x->ex_pcpathlen) {\\r\\nctx->error = X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n}\\r\\nproxy_path_length++;\\r\\nmust_be_ca = 0;\\r\\n} else\\r\\nmust_be_ca = 1;\\r\\n}\\r\\nok = 1;\\r\\nend:\\r\\nreturn ok;\\r\\n#endif\\r\\n}\\r\\nstatic int check_name_constraints(X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509 *x;\\r\\nint i, j, rv;\\r\\nfor (i = sk_X509_num(ctx->chain) - 1; i >= 0; i--) {\\r\\nx = sk_X509_value(ctx->chain, i);\\r\\nif (i && (x->ex_flags & EXFLAG_SI))\\r\\ncontinue;\\r\\nfor (j = sk_X509_num(ctx->chain) - 1; j > i; j--) {\\r\\nNAME_CONSTRAINTS *nc = sk_X509_value(ctx->chain, j)->nc;\\r\\nif (nc) {\\r\\nrv = NAME_CONSTRAINTS_check(x, nc);\\r\\nif (rv != X509_V_OK) {\\r\\nctx->error = rv;\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_id_error(X509_STORE_CTX *ctx, int errcode)\\r\\n{\\r\\nctx->error = errcode;\\r\\nctx->current_cert = ctx->cert;\\r\\nctx->error_depth = 0;\\r\\nreturn ctx->verify_cb(0, ctx);\\r\\n}\\r\\nstatic int check_hosts(X509 *x, X509_VERIFY_PARAM_ID *id)\\r\\n{\\r\\nint i;\\r\\nint n = sk_OPENSSL_STRING_num(id->hosts);\\r\\nchar *name;\\r\\nfor (i = 0; i < n; ++i) {\\r\\nname = sk_OPENSSL_STRING_value(id->hosts, i);\\r\\nif (X509_check_host(x, name, 0, id->hostflags, &id->peername) > 0)\\r\\nreturn 1;\\r\\n}\\r\\nreturn n == 0;\\r\\n}\\r\\nstatic int check_id(X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509_VERIFY_PARAM *vpm = ctx->param;\\r\\nX509_VERIFY_PARAM_ID *id = vpm->id;\\r\\nX509 *x = ctx->cert;\\r\\nif (id->hosts && check_hosts(x, id) <= 0) {\\r\\nif (!check_id_error(ctx, X509_V_ERR_HOSTNAME_MISMATCH))\\r\\nreturn 0;\\r\\n}\\r\\nif (id->email && X509_check_email(x, id->email, id->emaillen, 0) <= 0) {\\r\\nif (!check_id_error(ctx, X509_V_ERR_EMAIL_MISMATCH))\\r\\nreturn 0;\\r\\n}\\r\\nif (id->ip && X509_check_ip(x, id->ip, id->iplen, 0) <= 0) {\\r\\nif (!check_id_error(ctx, X509_V_ERR_IP_ADDRESS_MISMATCH))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_trust(X509_STORE_CTX *ctx)\\r\\n{\\r\\nint i, ok;\\r\\nX509 *x = NULL;\\r\\nint (*cb) (int xok, X509_STORE_CTX *xctx);\\r\\ncb = ctx->verify_cb;\\r\\nfor (i = ctx->last_untrusted; i < sk_X509_num(ctx->chain); i++) {\\r\\nx = sk_X509_value(ctx->chain, i);\\r\\nok = X509_check_trust(x, ctx->param->trust, 0);\\r\\nif (ok == X509_TRUST_TRUSTED)\\r\\nreturn X509_TRUST_TRUSTED;\\r\\nif (ok == X509_TRUST_REJECTED) {\\r\\nctx->error_depth = i;\\r\\nctx->current_cert = x;\\r\\nctx->error = X509_V_ERR_CERT_REJECTED;\\r\\nok = cb(0, ctx);\\r\\nif (!ok)\\r\\nreturn X509_TRUST_REJECTED;\\r\\n}\\r\\n}\\r\\nif (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\\r\\nX509 *mx;\\r\\nif (ctx->last_untrusted < sk_X509_num(ctx->chain))\\r\\nreturn X509_TRUST_TRUSTED;\\r\\nx = sk_X509_value(ctx->chain, 0);\\r\\nmx = lookup_cert_match(ctx, x);\\r\\nif (mx) {\\r\\n(void)sk_X509_set(ctx->chain, 0, mx);\\r\\nX509_free(x);\\r\\nctx->last_untrusted = 0;\\r\\nreturn X509_TRUST_TRUSTED;\\r\\n}\\r\\n}\\r\\nreturn X509_TRUST_UNTRUSTED;\\r\\n}\\r\\nstatic int check_revocation(X509_STORE_CTX *ctx)\\r\\n{\\r\\nint i, last, ok;\\r\\nif (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK))\\r\\nreturn 1;\\r\\nif (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL)\\r\\nlast = sk_X509_num(ctx->chain) - 1;\\r\\nelse {\\r\\nif (ctx->parent)\\r\\nreturn 1;\\r\\nlast = 0;\\r\\n}\\r\\nfor (i = 0; i <= last; i++) {\\r\\nctx->error_depth = i;\\r\\nok = check_cert(ctx);\\r\\nif (!ok)\\r\\nreturn ok;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_cert(X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509_CRL *crl = NULL, *dcrl = NULL;\\r\\nX509 *x;\\r\\nint ok, cnum;\\r\\nunsigned int last_reasons;\\r\\ncnum = ctx->error_depth;\\r\\nx = sk_X509_value(ctx->chain, cnum);\\r\\nctx->current_cert = x;\\r\\nctx->current_issuer = NULL;\\r\\nctx->current_crl_score = 0;\\r\\nctx->current_reasons = 0;\\r\\nwhile (ctx->current_reasons != CRLDP_ALL_REASONS) {\\r\\nlast_reasons = ctx->current_reasons;\\r\\nif (ctx->get_crl)\\r\\nok = ctx->get_crl(ctx, &crl, x);\\r\\nelse\\r\\nok = get_crl_delta(ctx, &crl, &dcrl, x);\\r\\nif (!ok) {\\r\\nctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\ngoto err;\\r\\n}\\r\\nctx->current_crl = crl;\\r\\nok = ctx->check_crl(ctx, crl);\\r\\nif (!ok)\\r\\ngoto err;\\r\\nif (dcrl) {\\r\\nok = ctx->check_crl(ctx, dcrl);\\r\\nif (!ok)\\r\\ngoto err;\\r\\nok = ctx->cert_crl(ctx, dcrl, x);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n} else\\r\\nok = 1;\\r\\nif (ok != 2) {\\r\\nok = ctx->cert_crl(ctx, crl, x);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n}\\r\\nX509_CRL_free(crl);\\r\\nX509_CRL_free(dcrl);\\r\\ncrl = NULL;\\r\\ndcrl = NULL;\\r\\nif (last_reasons == ctx->current_reasons) {\\r\\nctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nerr:\\r\\nX509_CRL_free(crl);\\r\\nX509_CRL_free(dcrl);\\r\\nctx->current_crl = NULL;\\r\\nreturn ok;\\r\\n}\\r\\nstatic int check_crl_time(X509_STORE_CTX *ctx, X509_CRL *crl, int notify)\\r\\n{\\r\\ntime_t *ptime;\\r\\nint i;\\r\\nif (notify)\\r\\nctx->current_crl = crl;\\r\\nif (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)\\r\\nptime = &ctx->param->check_time;\\r\\nelse\\r\\nptime = NULL;\\r\\ni = X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);\\r\\nif (i == 0) {\\r\\nif (!notify)\\r\\nreturn 0;\\r\\nctx->error = X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (i > 0) {\\r\\nif (!notify)\\r\\nreturn 0;\\r\\nctx->error = X509_V_ERR_CRL_NOT_YET_VALID;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (X509_CRL_get_nextUpdate(crl)) {\\r\\ni = X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);\\r\\nif (i == 0) {\\r\\nif (!notify)\\r\\nreturn 0;\\r\\nctx->error = X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif ((i < 0) && !(ctx->current_crl_score & CRL_SCORE_TIME_DELTA)) {\\r\\nif (!notify)\\r\\nreturn 0;\\r\\nctx->error = X509_V_ERR_CRL_HAS_EXPIRED;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (notify)\\r\\nctx->current_crl = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int crl_extension_match(X509_CRL *a, X509_CRL *b, int nid)\\r\\n{\\r\\nASN1_OCTET_STRING *exta, *extb;\\r\\nint i;\\r\\ni = X509_CRL_get_ext_by_NID(a, nid, -1);\\r\\nif (i >= 0) {\\r\\nif (X509_CRL_get_ext_by_NID(a, nid, i) != -1)\\r\\nreturn 0;\\r\\nexta = X509_EXTENSION_get_data(X509_CRL_get_ext(a, i));\\r\\n} else\\r\\nexta = NULL;\\r\\ni = X509_CRL_get_ext_by_NID(b, nid, -1);\\r\\nif (i >= 0) {\\r\\nif (X509_CRL_get_ext_by_NID(b, nid, i) != -1)\\r\\nreturn 0;\\r\\nextb = X509_EXTENSION_get_data(X509_CRL_get_ext(b, i));\\r\\n} else\\r\\nextb = NULL;\\r\\nif (!exta && !extb)\\r\\nreturn 1;\\r\\nif (!exta || !extb)\\r\\nreturn 0;\\r\\nif (ASN1_OCTET_STRING_cmp(exta, extb))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_delta_base(X509_CRL *delta, X509_CRL *base)\\r\\n{\\r\\nif (!delta->base_crl_number)\\r\\nreturn 0;\\r\\nif (!base->crl_number)\\r\\nreturn 0;\\r\\nif (X509_NAME_cmp(X509_CRL_get_issuer(base), X509_CRL_get_issuer(delta)))\\r\\nreturn 0;\\r\\nif (!crl_extension_match(delta, base, NID_authority_key_identifier))\\r\\nreturn 0;\\r\\nif (!crl_extension_match(delta, base, NID_issuing_distribution_point))\\r\\nreturn 0;\\r\\nif (ASN1_INTEGER_cmp(delta->base_crl_number, base->crl_number) > 0)\\r\\nreturn 0;\\r\\nif (ASN1_INTEGER_cmp(delta->crl_number, base->crl_number) > 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,\\r\\nunsigned int *preasons, X509_CRL *crl, X509 *x)\\r\\n{\\r\\nint crl_score = 0;\\r\\nunsigned int tmp_reasons = *preasons, crl_reasons;\\r\\nif (crl->idp_flags & IDP_INVALID)\\r\\nreturn 0;\\r\\nif (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT)) {\\r\\nif (crl->idp_flags & (IDP_INDIRECT | IDP_REASONS))\\r\\nreturn 0;\\r\\n} else if (crl->idp_flags & IDP_REASONS) {\\r\\nif (!(crl->idp_reasons & ~tmp_reasons))\\r\\nreturn 0;\\r\\n}\\r\\nelse if (crl->base_crl_number)\\r\\nreturn 0;\\r\\nif (X509_NAME_cmp(X509_get_issuer_name(x), X509_CRL_get_issuer(crl))) {\\r\\nif (!(crl->idp_flags & IDP_INDIRECT))\\r\\nreturn 0;\\r\\n} else\\r\\ncrl_score |= CRL_SCORE_ISSUER_NAME;\\r\\nif (!(crl->flags & EXFLAG_CRITICAL))\\r\\ncrl_score |= CRL_SCORE_NOCRITICAL;\\r\\nif (check_crl_time(ctx, crl, 0))\\r\\ncrl_score |= CRL_SCORE_TIME;\\r\\ncrl_akid_check(ctx, crl, pissuer, &crl_score);\\r\\nif (!(crl_score & CRL_SCORE_AKID))\\r\\nreturn 0;\\r\\nif (crl_crldp_check(x, crl, crl_score, &crl_reasons)) {\\r\\nif (!(crl_reasons & ~tmp_reasons))\\r\\nreturn 0;\\r\\ntmp_reasons |= crl_reasons;\\r\\ncrl_score |= CRL_SCORE_SCOPE;\\r\\n}\\r\\n*preasons = tmp_reasons;\\r\\nreturn crl_score;\\r\\n}\\r\\nstatic void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl,\\r\\nX509 **pissuer, int *pcrl_score)\\r\\n{\\r\\nX509 *crl_issuer = NULL;\\r\\nX509_NAME *cnm = X509_CRL_get_issuer(crl);\\r\\nint cidx = ctx->error_depth;\\r\\nint i;\\r\\nif (cidx != sk_X509_num(ctx->chain) - 1)\\r\\ncidx++;\\r\\ncrl_issuer = sk_X509_value(ctx->chain, cidx);\\r\\nif (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {\\r\\nif (*pcrl_score & CRL_SCORE_ISSUER_NAME) {\\r\\n*pcrl_score |= CRL_SCORE_AKID | CRL_SCORE_ISSUER_CERT;\\r\\n*pissuer = crl_issuer;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\nfor (cidx++; cidx < sk_X509_num(ctx->chain); cidx++) {\\r\\ncrl_issuer = sk_X509_value(ctx->chain, cidx);\\r\\nif (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))\\r\\ncontinue;\\r\\nif (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {\\r\\n*pcrl_score |= CRL_SCORE_AKID | CRL_SCORE_SAME_PATH;\\r\\n*pissuer = crl_issuer;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\nif (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT))\\r\\nreturn;\\r\\nfor (i = 0; i < sk_X509_num(ctx->untrusted); i++) {\\r\\ncrl_issuer = sk_X509_value(ctx->untrusted, i);\\r\\nif (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))\\r\\ncontinue;\\r\\nif (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {\\r\\n*pissuer = crl_issuer;\\r\\n*pcrl_score |= CRL_SCORE_AKID;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int check_crl_path(X509_STORE_CTX *ctx, X509 *x)\\r\\n{\\r\\nX509_STORE_CTX crl_ctx;\\r\\nint ret;\\r\\nif (ctx->parent)\\r\\nreturn 0;\\r\\nif (!X509_STORE_CTX_init(&crl_ctx, ctx->ctx, x, ctx->untrusted))\\r\\nreturn -1;\\r\\ncrl_ctx.crls = ctx->crls;\\r\\nX509_STORE_CTX_set0_param(&crl_ctx, ctx->param);\\r\\ncrl_ctx.parent = ctx;\\r\\ncrl_ctx.verify_cb = ctx->verify_cb;\\r\\nret = X509_verify_cert(&crl_ctx);\\r\\nif (ret <= 0)\\r\\ngoto err;\\r\\nret = check_crl_chain(ctx, ctx->chain, crl_ctx.chain);\\r\\nerr:\\r\\nX509_STORE_CTX_cleanup(&crl_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int idp_check_dp(DIST_POINT_NAME *a, DIST_POINT_NAME *b)\\r\\n{\\r\\nX509_NAME *nm = NULL;\\r\\nGENERAL_NAMES *gens = NULL;\\r\\nGENERAL_NAME *gena, *genb;\\r\\nint i, j;\\r\\nif (!a || !b)\\r\\nreturn 1;\\r\\nif (a->type == 1) {\\r\\nif (!a->dpname)\\r\\nreturn 0;\\r\\nif (b->type == 1) {\\r\\nif (!b->dpname)\\r\\nreturn 0;\\r\\nif (!X509_NAME_cmp(a->dpname, b->dpname))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nnm = a->dpname;\\r\\ngens = b->name.fullname;\\r\\n} else if (b->type == 1) {\\r\\nif (!b->dpname)\\r\\nreturn 0;\\r\\ngens = a->name.fullname;\\r\\nnm = b->dpname;\\r\\n}\\r\\nif (nm) {\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {\\r\\ngena = sk_GENERAL_NAME_value(gens, i);\\r\\nif (gena->type != GEN_DIRNAME)\\r\\ncontinue;\\r\\nif (!X509_NAME_cmp(nm, gena->d.directoryName))\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(a->name.fullname); i++) {\\r\\ngena = sk_GENERAL_NAME_value(a->name.fullname, i);\\r\\nfor (j = 0; j < sk_GENERAL_NAME_num(b->name.fullname); j++) {\\r\\ngenb = sk_GENERAL_NAME_value(b->name.fullname, j);\\r\\nif (!GENERAL_NAME_cmp(gena, genb))\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int crldp_check_crlissuer(DIST_POINT *dp, X509_CRL *crl, int crl_score)\\r\\n{\\r\\nint i;\\r\\nX509_NAME *nm = X509_CRL_get_issuer(crl);\\r\\nif (!dp->CRLissuer)\\r\\nreturn ! !(crl_score & CRL_SCORE_ISSUER_NAME);\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++) {\\r\\nGENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);\\r\\nif (gen->type != GEN_DIRNAME)\\r\\ncontinue;\\r\\nif (!X509_NAME_cmp(gen->d.directoryName, nm))\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,\\r\\nunsigned int *preasons)\\r\\n{\\r\\nint i;\\r\\nif (crl->idp_flags & IDP_ONLYATTR)\\r\\nreturn 0;\\r\\nif (x->ex_flags & EXFLAG_CA) {\\r\\nif (crl->idp_flags & IDP_ONLYUSER)\\r\\nreturn 0;\\r\\n} else {\\r\\nif (crl->idp_flags & IDP_ONLYCA)\\r\\nreturn 0;\\r\\n}\\r\\n*preasons = crl->idp_reasons;\\r\\nfor (i = 0; i < sk_DIST_POINT_num(x->crldp); i++) {\\r\\nDIST_POINT *dp = sk_DIST_POINT_value(x->crldp, i);\\r\\nif (crldp_check_crlissuer(dp, crl, crl_score)) {\\r\\nif (!crl->idp || idp_check_dp(dp->distpoint, crl->idp->distpoint)) {\\r\\n*preasons &= dp->dp_reasons;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\n}\\r\\nif ((!crl->idp || !crl->idp->distpoint)\\r\\n&& (crl_score & CRL_SCORE_ISSUER_NAME))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int get_crl_delta(X509_STORE_CTX *ctx,\\r\\nX509_CRL **pcrl, X509_CRL **pdcrl, X509 *x)\\r\\n{\\r\\nint ok;\\r\\nX509 *issuer = NULL;\\r\\nint crl_score = 0;\\r\\nunsigned int reasons;\\r\\nX509_CRL *crl = NULL, *dcrl = NULL;\\r\\nSTACK_OF(X509_CRL) *skcrl;\\r\\nX509_NAME *nm = X509_get_issuer_name(x);\\r\\nreasons = ctx->current_reasons;\\r\\nok = get_crl_sk(ctx, &crl, &dcrl,\\r\\n&issuer, &crl_score, &reasons, ctx->crls);\\r\\nif (ok)\\r\\ngoto done;\\r\\nskcrl = ctx->lookup_crls(ctx, nm);\\r\\nif (!skcrl && crl)\\r\\ngoto done;\\r\\nget_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons, skcrl);\\r\\nsk_X509_CRL_pop_free(skcrl, X509_CRL_free);\\r\\ndone:\\r\\nif (crl) {\\r\\nctx->current_issuer = issuer;\\r\\nctx->current_crl_score = crl_score;\\r\\nctx->current_reasons = reasons;\\r\\n*pcrl = crl;\\r\\n*pdcrl = dcrl;\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int check_crl(X509_STORE_CTX *ctx, X509_CRL *crl)\\r\\n{\\r\\nX509 *issuer = NULL;\\r\\nEVP_PKEY *ikey = NULL;\\r\\nint ok = 0, chnum, cnum;\\r\\ncnum = ctx->error_depth;\\r\\nchnum = sk_X509_num(ctx->chain) - 1;\\r\\nif (ctx->current_issuer)\\r\\nissuer = ctx->current_issuer;\\r\\nelse if (cnum < chnum)\\r\\nissuer = sk_X509_value(ctx->chain, cnum + 1);\\r\\nelse {\\r\\nissuer = sk_X509_value(ctx->chain, chnum);\\r\\nif (!ctx->check_issued(ctx, issuer, issuer)) {\\r\\nctx->error = X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (issuer) {\\r\\nif (!crl->base_crl_number) {\\r\\nif ((issuer->ex_flags & EXFLAG_KUSAGE) &&\\r\\n!(issuer->ex_kusage & KU_CRL_SIGN)) {\\r\\nctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n}\\r\\nif (!(ctx->current_crl_score & CRL_SCORE_SCOPE)) {\\r\\nctx->error = X509_V_ERR_DIFFERENT_CRL_SCOPE;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n}\\r\\nif (!(ctx->current_crl_score & CRL_SCORE_SAME_PATH)) {\\r\\nif (check_crl_path(ctx, ctx->current_issuer) <= 0) {\\r\\nctx->error = X509_V_ERR_CRL_PATH_VALIDATION_ERROR;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (crl->idp_flags & IDP_INVALID) {\\r\\nctx->error = X509_V_ERR_INVALID_EXTENSION;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!(ctx->current_crl_score & CRL_SCORE_TIME)) {\\r\\nok = check_crl_time(ctx, crl, 1);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n}\\r\\nikey = X509_get_pubkey(issuer);\\r\\nif (!ikey) {\\r\\nctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n} else {\\r\\nint rv;\\r\\nrv = X509_CRL_check_suiteb(crl, ikey, ctx->param->flags);\\r\\nif (rv != X509_V_OK) {\\r\\nctx->error = rv;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n}\\r\\nif (X509_CRL_verify(crl, ikey) <= 0) {\\r\\nctx->error = X509_V_ERR_CRL_SIGNATURE_FAILURE;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nEVP_PKEY_free(ikey);\\r\\nreturn ok;\\r\\n}\\r\\nstatic int cert_crl(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x)\\r\\n{\\r\\nint ok;\\r\\nX509_REVOKED *rev;\\r\\nif (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)\\r\\n&& (crl->flags & EXFLAG_CRITICAL)) {\\r\\nctx->error = X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\nreturn 0;\\r\\n}\\r\\nif (X509_CRL_get0_by_cert(crl, &rev, x)) {\\r\\nif (rev->reason == CRL_REASON_REMOVE_FROM_CRL)\\r\\nreturn 2;\\r\\nctx->error = X509_V_ERR_CERT_REVOKED;\\r\\nok = ctx->verify_cb(0, ctx);\\r\\nif (!ok)\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_policy(X509_STORE_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nif (ctx->parent)\\r\\nreturn 1;\\r\\nret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\\r\\nctx->param->policies, ctx->param->flags);\\r\\nif (ret == 0) {\\r\\nX509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (ret == -1) {\\r\\nX509 *x;\\r\\nint i;\\r\\nfor (i = 1; i < sk_X509_num(ctx->chain); i++) {\\r\\nx = sk_X509_value(ctx->chain, i);\\r\\nif (!(x->ex_flags & EXFLAG_INVALID_POLICY))\\r\\ncontinue;\\r\\nctx->current_cert = x;\\r\\nctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nif (ret == -2) {\\r\\nctx->current_cert = NULL;\\r\\nctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\\r\\nreturn ctx->verify_cb(0, ctx);\\r\\n}\\r\\nif (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {\\r\\nctx->current_cert = NULL;\\r\\nctx->error = X509_V_OK;\\r\\nif (!ctx->verify_cb(2, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_cert_time(X509_STORE_CTX *ctx, X509 *x)\\r\\n{\\r\\ntime_t *ptime;\\r\\nint i;\\r\\nif (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)\\r\\nptime = &ctx->param->check_time;\\r\\nelse\\r\\nptime = NULL;\\r\\ni = X509_cmp_time(X509_get_notBefore(x), ptime);\\r\\nif (i == 0) {\\r\\nctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\\r\\nctx->current_cert = x;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (i > 0) {\\r\\nctx->error = X509_V_ERR_CERT_NOT_YET_VALID;\\r\\nctx->current_cert = x;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\ni = X509_cmp_time(X509_get_notAfter(x), ptime);\\r\\nif (i == 0) {\\r\\nctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\\r\\nctx->current_cert = x;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nif (i < 0) {\\r\\nctx->error = X509_V_ERR_CERT_HAS_EXPIRED;\\r\\nctx->current_cert = x;\\r\\nif (!ctx->verify_cb(0, ctx))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int internal_verify(X509_STORE_CTX *ctx)\\r\\n{\\r\\nint ok = 0, n;\\r\\nX509 *xs, *xi;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nint (*cb) (int xok, X509_STORE_CTX *xctx);\\r\\ncb = ctx->verify_cb;\\r\\nn = sk_X509_num(ctx->chain);\\r\\nctx->error_depth = n - 1;\\r\\nn--;\\r\\nxi = sk_X509_value(ctx->chain, n);\\r\\nif (ctx->check_issued(ctx, xi, xi))\\r\\nxs = xi;\\r\\nelse {\\r\\nif (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {\\r\\nxs = xi;\\r\\ngoto check_cert;\\r\\n}\\r\\nif (n <= 0) {\\r\\nctx->error = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\\r\\nctx->current_cert = xi;\\r\\nok = cb(0, ctx);\\r\\ngoto end;\\r\\n} else {\\r\\nn--;\\r\\nctx->error_depth = n;\\r\\nxs = sk_X509_value(ctx->chain, n);\\r\\n}\\r\\n}\\r\\nwhile (n >= 0) {\\r\\nctx->error_depth = n;\\r\\nif (!xs->valid\\r\\n&& (xs != xi\\r\\n|| (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {\\r\\nif ((pkey = X509_get_pubkey(xi)) == NULL) {\\r\\nctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\\r\\nctx->current_cert = xi;\\r\\nok = (*cb) (0, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\n} else if (X509_verify(xs, pkey) <= 0) {\\r\\nctx->error = X509_V_ERR_CERT_SIGNATURE_FAILURE;\\r\\nctx->current_cert = xs;\\r\\nok = (*cb) (0, ctx);\\r\\nif (!ok) {\\r\\nEVP_PKEY_free(pkey);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nEVP_PKEY_free(pkey);\\r\\npkey = NULL;\\r\\n}\\r\\nxs->valid = 1;\\r\\ncheck_cert:\\r\\nok = check_cert_time(ctx, xs);\\r\\nif (!ok)\\r\\ngoto end;\\r\\nctx->current_issuer = xi;\\r\\nctx->current_cert = xs;\\r\\nok = (*cb) (1, ctx);\\r\\nif (!ok)\\r\\ngoto end;\\r\\nn--;\\r\\nif (n >= 0) {\\r\\nxi = xs;\\r\\nxs = sk_X509_value(ctx->chain, n);\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nend:\\r\\nreturn ok;\\r\\n}\\r\\nint X509_cmp_current_time(const ASN1_TIME *ctm)\\r\\n{\\r\\nreturn X509_cmp_time(ctm, NULL);\\r\\n}\\r\\nint X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\\r\\n{\\r\\nchar *str;\\r\\nASN1_TIME atm;\\r\\nlong offset;\\r\\nchar buff1[24], buff2[24], *p;\\r\\nint i, j;\\r\\np = buff1;\\r\\ni = ctm->length;\\r\\nstr = (char *)ctm->data;\\r\\nif (ctm->type == V_ASN1_UTCTIME) {\\r\\nif ((i < 11) || (i > 17))\\r\\nreturn 0;\\r\\nmemcpy(p, str, 10);\\r\\np += 10;\\r\\nstr += 10;\\r\\n} else {\\r\\nif (i < 13)\\r\\nreturn 0;\\r\\nmemcpy(p, str, 12);\\r\\np += 12;\\r\\nstr += 12;\\r\\n}\\r\\nif ((*str == 'Z') || (*str == '-') || (*str == '+')) {\\r\\n*(p++) = '0';\\r\\n*(p++) = '0';\\r\\n} else {\\r\\n*(p++) = *(str++);\\r\\n*(p++) = *(str++);\\r\\nif (*str == '.') {\\r\\nstr++;\\r\\nwhile ((*str >= '0') && (*str <= '9'))\\r\\nstr++;\\r\\n}\\r\\n}\\r\\n*(p++) = 'Z';\\r\\n*(p++) = '\\0';\\r\\nif (*str == 'Z')\\r\\noffset = 0;\\r\\nelse {\\r\\nif ((*str != '+') && (*str != '-'))\\r\\nreturn 0;\\r\\noffset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\\r\\noffset += (str[3] - '0') * 10 + (str[4] - '0');\\r\\nif (*str == '-')\\r\\noffset = -offset;\\r\\n}\\r\\natm.type = ctm->type;\\r\\natm.flags = 0;\\r\\natm.length = sizeof(buff2);\\r\\natm.data = (unsigned char *)buff2;\\r\\nif (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\\r\\nreturn 0;\\r\\nif (ctm->type == V_ASN1_UTCTIME) {\\r\\ni = (buff1[0] - '0') * 10 + (buff1[1] - '0');\\r\\nif (i < 50)\\r\\ni += 100;\\r\\nj = (buff2[0] - '0') * 10 + (buff2[1] - '0');\\r\\nif (j < 50)\\r\\nj += 100;\\r\\nif (i < j)\\r\\nreturn -1;\\r\\nif (i > j)\\r\\nreturn 1;\\r\\n}\\r\\ni = strcmp(buff1, buff2);\\r\\nif (i == 0)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn i;\\r\\n}\\r\\nASN1_TIME *X509_gmtime_adj(ASN1_TIME *s, long adj)\\r\\n{\\r\\nreturn X509_time_adj(s, adj, NULL);\\r\\n}\\r\\nASN1_TIME *X509_time_adj(ASN1_TIME *s, long offset_sec, time_t *in_tm)\\r\\n{\\r\\nreturn X509_time_adj_ex(s, 0, offset_sec, in_tm);\\r\\n}\\r\\nASN1_TIME *X509_time_adj_ex(ASN1_TIME *s,\\r\\nint offset_day, long offset_sec, time_t *in_tm)\\r\\n{\\r\\ntime_t t;\\r\\nif (in_tm)\\r\\nt = *in_tm;\\r\\nelse\\r\\ntime(&t);\\r\\nif (s && !(s->flags & ASN1_STRING_FLAG_MSTRING)) {\\r\\nif (s->type == V_ASN1_UTCTIME)\\r\\nreturn ASN1_UTCTIME_adj(s, t, offset_day, offset_sec);\\r\\nif (s->type == V_ASN1_GENERALIZEDTIME)\\r\\nreturn ASN1_GENERALIZEDTIME_adj(s, t, offset_day, offset_sec);\\r\\n}\\r\\nreturn ASN1_TIME_adj(s, t, offset_day, offset_sec);\\r\\n}\\r\\nX509_CRL *X509_CRL_diff(X509_CRL *base, X509_CRL *newer,\\r\\nEVP_PKEY *skey, const EVP_MD *md, unsigned int flags)\\r\\n{\\r\\nX509_CRL *crl = NULL;\\r\\nint i;\\r\\nSTACK_OF(X509_REVOKED) *revs = NULL;\\r\\nif (base->base_crl_number || newer->base_crl_number) {\\r\\nX509err(X509_F_X509_CRL_DIFF, X509_R_CRL_ALREADY_DELTA);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!base->crl_number || !newer->crl_number) {\\r\\nX509err(X509_F_X509_CRL_DIFF, X509_R_NO_CRL_NUMBER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (X509_NAME_cmp(X509_CRL_get_issuer(base), X509_CRL_get_issuer(newer))) {\\r\\nX509err(X509_F_X509_CRL_DIFF, X509_R_ISSUER_MISMATCH);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!crl_extension_match(base, newer, NID_authority_key_identifier)) {\\r\\nX509err(X509_F_X509_CRL_DIFF, X509_R_AKID_MISMATCH);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!crl_extension_match(base, newer, NID_issuing_distribution_point)) {\\r\\nX509err(X509_F_X509_CRL_DIFF, X509_R_IDP_MISMATCH);\\r\\nreturn NULL;\\r\\n}\\r\\nif (ASN1_INTEGER_cmp(newer->crl_number, base->crl_number) <= 0) {\\r\\nX509err(X509_F_X509_CRL_DIFF, X509_R_NEWER_CRL_NOT_NEWER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (skey && (X509_CRL_verify(base, skey) <= 0 ||\\r\\nX509_CRL_verify(newer, skey) <= 0)) {\\r\\nX509err(X509_F_X509_CRL_DIFF, X509_R_CRL_VERIFY_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\ncrl = X509_CRL_new();\\r\\nif (!crl || !X509_CRL_set_version(crl, 1))\\r\\ngoto memerr;\\r\\nif (!X509_CRL_set_issuer_name(crl, X509_CRL_get_issuer(newer)))\\r\\ngoto memerr;\\r\\nif (!X509_CRL_set_lastUpdate(crl, X509_CRL_get_lastUpdate(newer)))\\r\\ngoto memerr;\\r\\nif (!X509_CRL_set_nextUpdate(crl, X509_CRL_get_nextUpdate(newer)))\\r\\ngoto memerr;\\r\\nif (!X509_CRL_add1_ext_i2d(crl, NID_delta_crl, base->crl_number, 1, 0))\\r\\ngoto memerr;\\r\\nfor (i = 0; i < X509_CRL_get_ext_count(newer); i++) {\\r\\nX509_EXTENSION *ext;\\r\\next = X509_CRL_get_ext(newer, i);\\r\\nif (!X509_CRL_add_ext(crl, ext, -1))\\r\\ngoto memerr;\\r\\n}\\r\\nrevs = X509_CRL_get_REVOKED(newer);\\r\\nfor (i = 0; i < sk_X509_REVOKED_num(revs); i++) {\\r\\nX509_REVOKED *rvn, *rvtmp;\\r\\nrvn = sk_X509_REVOKED_value(revs, i);\\r\\nif (!X509_CRL_get0_by_serial(base, &rvtmp, rvn->serialNumber)) {\\r\\nrvtmp = X509_REVOKED_dup(rvn);\\r\\nif (!rvtmp)\\r\\ngoto memerr;\\r\\nif (!X509_CRL_add0_revoked(crl, rvtmp)) {\\r\\nX509_REVOKED_free(rvtmp);\\r\\ngoto memerr;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (skey && md && !X509_CRL_sign(crl, skey, md))\\r\\ngoto memerr;\\r\\nreturn crl;\\r\\nmemerr:\\r\\nX509err(X509_F_X509_CRL_DIFF, ERR_R_MALLOC_FAILURE);\\r\\nif (crl)\\r\\nX509_CRL_free(crl);\\r\\nreturn NULL;\\r\\n}\\r\\nint X509_STORE_CTX_get_ex_new_index(long argl, void *argp,\\r\\nCRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)\\r\\n{\\r\\nreturn CRYPTO_set_ex_data(&ctx->ex_data, idx, data);\\r\\n}\\r\\nvoid *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)\\r\\n{\\r\\nreturn CRYPTO_get_ex_data(&ctx->ex_data, idx);\\r\\n}\\r\\nint X509_STORE_CTX_get_error(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->error;\\r\\n}\\r\\nvoid X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)\\r\\n{\\r\\nctx->error = err;\\r\\n}\\r\\nint X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->error_depth;\\r\\n}\\r\\nX509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->current_cert;\\r\\n}\\r\\nX509_CRL *X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->current_crl;\\r\\n}\\r\\nX509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->parent;\\r\\n}\\r\\nvoid X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)\\r\\n{\\r\\nctx->cert = x;\\r\\n}\\r\\nint X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)\\r\\n{\\r\\nreturn X509_STORE_CTX_purpose_inherit(ctx, 0, purpose, 0);\\r\\n}\\r\\nint X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)\\r\\n{\\r\\nreturn X509_STORE_CTX_purpose_inherit(ctx, 0, 0, trust);\\r\\n}\\r\\nint X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,\\r\\nint purpose, int trust)\\r\\n{\\r\\nint idx;\\r\\nif (!purpose)\\r\\npurpose = def_purpose;\\r\\nif (purpose) {\\r\\nX509_PURPOSE *ptmp;\\r\\nidx = X509_PURPOSE_get_by_id(purpose);\\r\\nif (idx == -1) {\\r\\nX509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,\\r\\nX509_R_UNKNOWN_PURPOSE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nptmp = X509_PURPOSE_get0(idx);\\r\\nif (ptmp->trust == X509_TRUST_DEFAULT) {\\r\\nidx = X509_PURPOSE_get_by_id(def_purpose);\\r\\nif (idx == -1) {\\r\\nX509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,\\r\\nX509_R_UNKNOWN_PURPOSE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nptmp = X509_PURPOSE_get0(idx);\\r\\n}\\r\\nif (!trust)\\r\\ntrust = ptmp->trust;\\r\\n}\\r\\nif (trust) {\\r\\nidx = X509_TRUST_get_by_id(trust);\\r\\nif (idx == -1) {\\r\\nX509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,\\r\\nX509_R_UNKNOWN_TRUST_ID);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (purpose && !ctx->param->purpose)\\r\\nctx->param->purpose = purpose;\\r\\nif (trust && !ctx->param->trust)\\r\\nctx->param->trust = trust;\\r\\nreturn 1;\\r\\n}\\r\\nX509_STORE_CTX *X509_STORE_CTX_new(void)\\r\\n{\\r\\nX509_STORE_CTX *ctx;\\r\\nctx = (X509_STORE_CTX *)OPENSSL_malloc(sizeof(X509_STORE_CTX));\\r\\nif (!ctx) {\\r\\nX509err(X509_F_X509_STORE_CTX_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(ctx, 0, sizeof(X509_STORE_CTX));\\r\\nreturn ctx;\\r\\n}\\r\\nvoid X509_STORE_CTX_free(X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509_STORE_CTX_cleanup(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nvoid X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\\r\\n{\\r\\nif (ctx->cleanup)\\r\\nctx->cleanup(ctx);\\r\\nif (ctx->param != NULL) {\\r\\nif (ctx->parent == NULL)\\r\\nX509_VERIFY_PARAM_free(ctx->param);\\r\\nctx->param = NULL;\\r\\n}\\r\\nif (ctx->tree != NULL) {\\r\\nX509_policy_tree_free(ctx->tree);\\r\\nctx->tree = NULL;\\r\\n}\\r\\nif (ctx->chain != NULL) {\\r\\nsk_X509_pop_free(ctx->chain, X509_free);\\r\\nctx->chain = NULL;\\r\\n}\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));\\r\\nmemset(&ctx->ex_data, 0, sizeof(CRYPTO_EX_DATA));\\r\\n}\\r\\nvoid X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_depth(ctx->param, depth);\\r\\n}\\r\\nvoid X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_flags(ctx->param, flags);\\r\\n}\\r\\nvoid X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags,\\r\\ntime_t t)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_time(ctx->param, t);\\r\\n}\\r\\nvoid X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,\\r\\nint (*verify_cb) (int, X509_STORE_CTX *))\\r\\n{\\r\\nctx->verify_cb = verify_cb;\\r\\n}\\r\\nX509_POLICY_TREE *X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->tree;\\r\\n}\\r\\nint X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->explicit_policy;\\r\\n}\\r\\nint X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)\\r\\n{\\r\\nconst X509_VERIFY_PARAM *param;\\r\\nparam = X509_VERIFY_PARAM_lookup(name);\\r\\nif (!param)\\r\\nreturn 0;\\r\\nreturn X509_VERIFY_PARAM_inherit(ctx->param, param);\\r\\n}\\r\\nX509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->param;\\r\\n}\\r\\nvoid X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)\\r\\n{\\r\\nif (ctx->param)\\r\\nX509_VERIFY_PARAM_free(ctx->param);\\r\\nctx->param = param;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc2ofb64_c", "target": 0, "func": "void RC2_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC2_KEY *schedule, unsigned char *ivec,\\r\\nint *num)\\r\\n{\\r\\nregister unsigned long v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv;\\r\\nint save = 0;\\r\\niv = (unsigned char *)ivec;\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\ndp = (char *)d;\\r\\nl2c(v0, dp);\\r\\nl2c(v1, dp);\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nRC2_encrypt((unsigned long *)ti, schedule);\\r\\ndp = (char *)d;\\r\\nt = ti[0];\\r\\nl2c(t, dp);\\r\\nt = ti[1];\\r\\nl2c(t, dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++) = *(in++) ^ d[n];\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\nif (save) {\\r\\nv0 = ti[0];\\r\\nv1 = ti[1];\\r\\niv = (unsigned char *)ivec;\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\n}\\r\\nt = v0 = v1 = ti[0] = ti[1] = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pem_lib_c", "target": 0, "func": "int PEM_def_callback(char *buf, int num, int w, void *key)\\r\\n{\\r\\n#ifdef OPENSSL_NO_FP_API\\r\\nPEMerr(PEM_F_PEM_DEF_CALLBACK, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn (-1);\\r\\n#else\\r\\nint i, j;\\r\\nconst char *prompt;\\r\\nif (key) {\\r\\ni = strlen(key);\\r\\ni = (i > num) ? num : i;\\r\\nmemcpy(buf, key, i);\\r\\nreturn (i);\\r\\n}\\r\\nprompt = EVP_get_pw_prompt();\\r\\nif (prompt == NULL)\\r\\nprompt = \"Enter PEM pass phrase:\";\\r\\nfor (;;) {\\r\\ni = EVP_read_pw_string_min(buf, MIN_LENGTH, num, prompt, w);\\r\\nif (i != 0) {\\r\\nPEMerr(PEM_F_PEM_DEF_CALLBACK, PEM_R_PROBLEMS_GETTING_PASSWORD);\\r\\nmemset(buf, 0, (unsigned int)num);\\r\\nreturn (-1);\\r\\n}\\r\\nj = strlen(buf);\\r\\nif (j < MIN_LENGTH) {\\r\\nfprintf(stderr,\\r\\n\"phrase is too short, needs to be at least %d chars\\n\",\\r\\nMIN_LENGTH);\\r\\n} else\\r\\nbreak;\\r\\n}\\r\\nreturn (j);\\r\\n#endif\\r\\n}\\r\\nvoid PEM_proc_type(char *buf, int type)\\r\\n{\\r\\nconst char *str;\\r\\nif (type == PEM_TYPE_ENCRYPTED)\\r\\nstr = \"ENCRYPTED\";\\r\\nelse if (type == PEM_TYPE_MIC_CLEAR)\\r\\nstr = \"MIC-CLEAR\";\\r\\nelse if (type == PEM_TYPE_MIC_ONLY)\\r\\nstr = \"MIC-ONLY\";\\r\\nelse\\r\\nstr = \"BAD-TYPE\";\\r\\nBUF_strlcat(buf, \"Proc-Type: 4,\", PEM_BUFSIZE);\\r\\nBUF_strlcat(buf, str, PEM_BUFSIZE);\\r\\nBUF_strlcat(buf, \"\\n\", PEM_BUFSIZE);\\r\\n}\\r\\nvoid PEM_dek_info(char *buf, const char *type, int len, char *str)\\r\\n{\\r\\nstatic const unsigned char map[17] = \"0123456789ABCDEF\";\\r\\nlong i;\\r\\nint j;\\r\\nBUF_strlcat(buf, \"DEK-Info: \", PEM_BUFSIZE);\\r\\nBUF_strlcat(buf, type, PEM_BUFSIZE);\\r\\nBUF_strlcat(buf, \",\", PEM_BUFSIZE);\\r\\nj = strlen(buf);\\r\\nif (j + (len * 2) + 1 > PEM_BUFSIZE)\\r\\nreturn;\\r\\nfor (i = 0; i < len; i++) {\\r\\nbuf[j + i * 2] = map[(str[i] >> 4) & 0x0f];\\r\\nbuf[j + i * 2 + 1] = map[(str[i]) & 0x0f];\\r\\n}\\r\\nbuf[j + i * 2] = '\\n';\\r\\nbuf[j + i * 2 + 1] = '\\0';\\r\\n}\\r\\nvoid *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *b;\\r\\nvoid *ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nPEMerr(PEM_F_PEM_ASN1_READ, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = PEM_ASN1_read_bio(d2i, name, b, x, cb, u);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int check_pem(const char *nm, const char *name)\\r\\n{\\r\\nif (!strcmp(nm, name))\\r\\nreturn 1;\\r\\nif (!strcmp(name, PEM_STRING_EVP_PKEY)) {\\r\\nint slen;\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nif (!strcmp(nm, PEM_STRING_PKCS8))\\r\\nreturn 1;\\r\\nif (!strcmp(nm, PEM_STRING_PKCS8INF))\\r\\nreturn 1;\\r\\nslen = pem_check_suffix(nm, \"PRIVATE KEY\");\\r\\nif (slen > 0) {\\r\\nameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);\\r\\nif (ameth && ameth->old_priv_decode)\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nif (!strcmp(name, PEM_STRING_PARAMETERS)) {\\r\\nint slen;\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nslen = pem_check_suffix(nm, \"PARAMETERS\");\\r\\nif (slen > 0) {\\r\\nENGINE *e;\\r\\nameth = EVP_PKEY_asn1_find_str(&e, nm, slen);\\r\\nif (ameth) {\\r\\nint r;\\r\\nif (ameth->param_decode)\\r\\nr = 1;\\r\\nelse\\r\\nr = 0;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (e)\\r\\nENGINE_finish(e);\\r\\n#endif\\r\\nreturn r;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nif (!strcmp(nm, PEM_STRING_DHXPARAMS) &&\\r\\n!strcmp(name, PEM_STRING_DHPARAMS))\\r\\nreturn 1;\\r\\nif (!strcmp(nm, PEM_STRING_X509_OLD) && !strcmp(name, PEM_STRING_X509))\\r\\nreturn 1;\\r\\nif (!strcmp(nm, PEM_STRING_X509_REQ_OLD) &&\\r\\n!strcmp(name, PEM_STRING_X509_REQ))\\r\\nreturn 1;\\r\\nif (!strcmp(nm, PEM_STRING_X509) &&\\r\\n!strcmp(name, PEM_STRING_X509_TRUSTED))\\r\\nreturn 1;\\r\\nif (!strcmp(nm, PEM_STRING_X509_OLD) &&\\r\\n!strcmp(name, PEM_STRING_X509_TRUSTED))\\r\\nreturn 1;\\r\\nif (!strcmp(nm, PEM_STRING_X509) && !strcmp(name, PEM_STRING_PKCS7))\\r\\nreturn 1;\\r\\nif (!strcmp(nm, PEM_STRING_PKCS7_SIGNED) &&\\r\\n!strcmp(name, PEM_STRING_PKCS7))\\r\\nreturn 1;\\r\\n#ifndef OPENSSL_NO_CMS\\r\\nif (!strcmp(nm, PEM_STRING_X509) && !strcmp(name, PEM_STRING_CMS))\\r\\nreturn 1;\\r\\nif (!strcmp(nm, PEM_STRING_PKCS7) && !strcmp(name, PEM_STRING_CMS))\\r\\nreturn 1;\\r\\n#endif\\r\\nreturn 0;\\r\\n}\\r\\nint PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,\\r\\nconst char *name, BIO *bp, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_CIPHER_INFO cipher;\\r\\nchar *nm = NULL, *header = NULL;\\r\\nunsigned char *data = NULL;\\r\\nlong len;\\r\\nint ret = 0;\\r\\nfor (;;) {\\r\\nif (!PEM_read_bio(bp, &nm, &header, &data, &len)) {\\r\\nif (ERR_GET_REASON(ERR_peek_error()) == PEM_R_NO_START_LINE)\\r\\nERR_add_error_data(2, \"Expecting: \", name);\\r\\nreturn 0;\\r\\n}\\r\\nif (check_pem(nm, name))\\r\\nbreak;\\r\\nOPENSSL_free(nm);\\r\\nOPENSSL_free(header);\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nif (!PEM_get_EVP_CIPHER_INFO(header, &cipher))\\r\\ngoto err;\\r\\nif (!PEM_do_header(&cipher, data, &len, cb, u))\\r\\ngoto err;\\r\\n*pdata = data;\\r\\n*plen = len;\\r\\nif (pnm)\\r\\n*pnm = nm;\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret || !pnm)\\r\\nOPENSSL_free(nm);\\r\\nOPENSSL_free(header);\\r\\nif (!ret)\\r\\nOPENSSL_free(data);\\r\\nreturn ret;\\r\\n}\\r\\nint PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,\\r\\nvoid *x, const EVP_CIPHER *enc, unsigned char *kstr,\\r\\nint klen, pem_password_cb *callback, void *u)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = PEM_ASN1_write_bio(i2d, name, b, x, enc, kstr, klen, callback, u);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp,\\r\\nvoid *x, const EVP_CIPHER *enc, unsigned char *kstr,\\r\\nint klen, pem_password_cb *callback, void *u)\\r\\n{\\r\\nEVP_CIPHER_CTX ctx;\\r\\nint dsize = 0, i, j, ret = 0;\\r\\nunsigned char *p, *data = NULL;\\r\\nconst char *objstr = NULL;\\r\\nchar buf[PEM_BUFSIZE];\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nif (enc != NULL) {\\r\\nobjstr = OBJ_nid2sn(EVP_CIPHER_nid(enc));\\r\\nif (objstr == NULL) {\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO, PEM_R_UNSUPPORTED_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((dsize = i2d(x, NULL)) < 0) {\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_ASN1_LIB);\\r\\ndsize = 0;\\r\\ngoto err;\\r\\n}\\r\\ndata = (unsigned char *)OPENSSL_malloc((unsigned int)dsize + 20);\\r\\nif (data == NULL) {\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np = data;\\r\\ni = i2d(x, &p);\\r\\nif (enc != NULL) {\\r\\nif (kstr == NULL) {\\r\\nif (callback == NULL)\\r\\nklen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);\\r\\nelse\\r\\nklen = (*callback) (buf, PEM_BUFSIZE, 1, u);\\r\\nif (klen <= 0) {\\r\\nPEMerr(PEM_F_PEM_ASN1_WRITE_BIO, PEM_R_READ_KEY);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, klen);\\r\\n#endif\\r\\nkstr = (unsigned char *)buf;\\r\\n}\\r\\nRAND_add(data, i, 0);\\r\\nOPENSSL_assert(enc->iv_len <= (int)sizeof(iv));\\r\\nif (RAND_pseudo_bytes(iv, enc->iv_len) < 0)\\r\\ngoto err;\\r\\nif (!EVP_BytesToKey(enc, EVP_md5(), iv, kstr, klen, 1, key, NULL))\\r\\ngoto err;\\r\\nif (kstr == (unsigned char *)buf)\\r\\nOPENSSL_cleanse(buf, PEM_BUFSIZE);\\r\\nOPENSSL_assert(strlen(objstr) + 23 + 2 * enc->iv_len + 13 <=\\r\\nsizeof buf);\\r\\nbuf[0] = '\\0';\\r\\nPEM_proc_type(buf, PEM_TYPE_ENCRYPTED);\\r\\nPEM_dek_info(buf, objstr, enc->iv_len, (char *)iv);\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nret = 1;\\r\\nif (!EVP_EncryptInit_ex(&ctx, enc, NULL, key, iv)\\r\\n|| !EVP_EncryptUpdate(&ctx, data, &j, data, i)\\r\\n|| !EVP_EncryptFinal_ex(&ctx, &(data[j]), &i))\\r\\nret = 0;\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nif (ret == 0)\\r\\ngoto err;\\r\\ni += j;\\r\\n} else {\\r\\nret = 1;\\r\\nbuf[0] = '\\0';\\r\\n}\\r\\ni = PEM_write_bio(bp, name, buf, data, i);\\r\\nif (i <= 0)\\r\\nret = 0;\\r\\nerr:\\r\\nOPENSSL_cleanse(key, sizeof(key));\\r\\nOPENSSL_cleanse(iv, sizeof(iv));\\r\\nOPENSSL_cleanse((char *)&ctx, sizeof(ctx));\\r\\nOPENSSL_cleanse(buf, PEM_BUFSIZE);\\r\\nif (data != NULL) {\\r\\nOPENSSL_cleanse(data, (unsigned int)dsize);\\r\\nOPENSSL_free(data);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *plen,\\r\\npem_password_cb *callback, void *u)\\r\\n{\\r\\nint i = 0, j, o, klen;\\r\\nlong len;\\r\\nEVP_CIPHER_CTX ctx;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nchar buf[PEM_BUFSIZE];\\r\\nlen = *plen;\\r\\nif (cipher->cipher == NULL)\\r\\nreturn (1);\\r\\nif (callback == NULL)\\r\\nklen = PEM_def_callback(buf, PEM_BUFSIZE, 0, u);\\r\\nelse\\r\\nklen = callback(buf, PEM_BUFSIZE, 0, u);\\r\\nif (klen <= 0) {\\r\\nPEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_PASSWORD_READ);\\r\\nreturn (0);\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, klen);\\r\\n#endif\\r\\nif (!EVP_BytesToKey(cipher->cipher, EVP_md5(), &(cipher->iv[0]),\\r\\n(unsigned char *)buf, klen, 1, key, NULL))\\r\\nreturn 0;\\r\\nj = (int)len;\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\no = EVP_DecryptInit_ex(&ctx, cipher->cipher, NULL, key, &(cipher->iv[0]));\\r\\nif (o)\\r\\no = EVP_DecryptUpdate(&ctx, data, &i, data, j);\\r\\nif (o)\\r\\no = EVP_DecryptFinal_ex(&ctx, &(data[i]), &j);\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nOPENSSL_cleanse((char *)buf, sizeof(buf));\\r\\nOPENSSL_cleanse((char *)key, sizeof(key));\\r\\nif (o)\\r\\nj += i;\\r\\nelse {\\r\\nPEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_DECRYPT);\\r\\nreturn (0);\\r\\n}\\r\\n*plen = j;\\r\\nreturn (1);\\r\\n}\\r\\nint PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)\\r\\n{\\r\\nconst EVP_CIPHER *enc = NULL;\\r\\nchar *p, c;\\r\\nchar **header_pp = &header;\\r\\ncipher->cipher = NULL;\\r\\nif ((header == NULL) || (*header == '\\0') || (*header == '\\n'))\\r\\nreturn (1);\\r\\nif (strncmp(header, \"Proc-Type: \", 11) != 0) {\\r\\nPEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_PROC_TYPE);\\r\\nreturn (0);\\r\\n}\\r\\nheader += 11;\\r\\nif (*header != '4')\\r\\nreturn (0);\\r\\nheader++;\\r\\nif (*header != ',')\\r\\nreturn (0);\\r\\nheader++;\\r\\nif (strncmp(header, \"ENCRYPTED\", 9) != 0) {\\r\\nPEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_ENCRYPTED);\\r\\nreturn (0);\\r\\n}\\r\\nfor (; (*header != '\\n') && (*header != '\\0'); header++) ;\\r\\nif (*header == '\\0') {\\r\\nPEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_SHORT_HEADER);\\r\\nreturn (0);\\r\\n}\\r\\nheader++;\\r\\nif (strncmp(header, \"DEK-Info: \", 10) != 0) {\\r\\nPEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_DEK_INFO);\\r\\nreturn (0);\\r\\n}\\r\\nheader += 10;\\r\\np = header;\\r\\nfor (;;) {\\r\\nc = *header;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!(((c >= 'A') && (c <= 'Z')) || (c == '-') ||\\r\\n((c >= '0') && (c <= '9'))))\\r\\nbreak;\\r\\n#else\\r\\nif (!(isupper(c) || (c == '-') || isdigit(c)))\\r\\nbreak;\\r\\n#endif\\r\\nheader++;\\r\\n}\\r\\n*header = '\\0';\\r\\ncipher->cipher = enc = EVP_get_cipherbyname(p);\\r\\n*header = c;\\r\\nheader++;\\r\\nif (enc == NULL) {\\r\\nPEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_UNSUPPORTED_ENCRYPTION);\\r\\nreturn (0);\\r\\n}\\r\\nif (!load_iv(header_pp, &(cipher->iv[0]), enc->iv_len))\\r\\nreturn (0);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int load_iv(char **fromp, unsigned char *to, int num)\\r\\n{\\r\\nint v, i;\\r\\nchar *from;\\r\\nfrom = *fromp;\\r\\nfor (i = 0; i < num; i++)\\r\\nto[i] = 0;\\r\\nnum *= 2;\\r\\nfor (i = 0; i < num; i++) {\\r\\nif ((*from >= '0') && (*from <= '9'))\\r\\nv = *from - '0';\\r\\nelse if ((*from >= 'A') && (*from <= 'F'))\\r\\nv = *from - 'A' + 10;\\r\\nelse if ((*from >= 'a') && (*from <= 'f'))\\r\\nv = *from - 'a' + 10;\\r\\nelse {\\r\\nPEMerr(PEM_F_LOAD_IV, PEM_R_BAD_IV_CHARS);\\r\\nreturn (0);\\r\\n}\\r\\nfrom++;\\r\\nto[i / 2] |= v << (long)((!(i & 1)) * 4);\\r\\n}\\r\\n*fromp = from;\\r\\nreturn (1);\\r\\n}\\r\\nint PEM_write(FILE *fp, const char *name, const char *header,\\r\\nconst unsigned char *data, long len)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nPEMerr(PEM_F_PEM_WRITE, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = PEM_write_bio(b, name, header, data, len);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint PEM_write_bio(BIO *bp, const char *name, const char *header,\\r\\nconst unsigned char *data, long len)\\r\\n{\\r\\nint nlen, n, i, j, outl;\\r\\nunsigned char *buf = NULL;\\r\\nEVP_ENCODE_CTX ctx;\\r\\nint reason = ERR_R_BUF_LIB;\\r\\nEVP_EncodeInit(&ctx);\\r\\nnlen = strlen(name);\\r\\nif ((BIO_write(bp, \"-----BEGIN \", 11) != 11) ||\\r\\n(BIO_write(bp, name, nlen) != nlen) ||\\r\\n(BIO_write(bp, \"-----\\n\", 6) != 6))\\r\\ngoto err;\\r\\ni = strlen(header);\\r\\nif (i > 0) {\\r\\nif ((BIO_write(bp, header, i) != i) || (BIO_write(bp, \"\\n\", 1) != 1))\\r\\ngoto err;\\r\\n}\\r\\nbuf = OPENSSL_malloc(PEM_BUFSIZE * 8);\\r\\nif (buf == NULL) {\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\ni = j = 0;\\r\\nwhile (len > 0) {\\r\\nn = (int)((len > (PEM_BUFSIZE * 5)) ? (PEM_BUFSIZE * 5) : len);\\r\\nEVP_EncodeUpdate(&ctx, buf, &outl, &(data[j]), n);\\r\\nif ((outl) && (BIO_write(bp, (char *)buf, outl) != outl))\\r\\ngoto err;\\r\\ni += outl;\\r\\nlen -= n;\\r\\nj += n;\\r\\n}\\r\\nEVP_EncodeFinal(&ctx, buf, &outl);\\r\\nif ((outl > 0) && (BIO_write(bp, (char *)buf, outl) != outl))\\r\\ngoto err;\\r\\nOPENSSL_cleanse(buf, PEM_BUFSIZE * 8);\\r\\nOPENSSL_free(buf);\\r\\nbuf = NULL;\\r\\nif ((BIO_write(bp, \"-----END \", 9) != 9) ||\\r\\n(BIO_write(bp, name, nlen) != nlen) ||\\r\\n(BIO_write(bp, \"-----\\n\", 6) != 6))\\r\\ngoto err;\\r\\nreturn (i + outl);\\r\\nerr:\\r\\nif (buf) {\\r\\nOPENSSL_cleanse(buf, PEM_BUFSIZE * 8);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nPEMerr(PEM_F_PEM_WRITE_BIO, reason);\\r\\nreturn (0);\\r\\n}\\r\\nint PEM_read(FILE *fp, char **name, char **header, unsigned char **data,\\r\\nlong *len)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nPEMerr(PEM_F_PEM_READ, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = PEM_read_bio(b, name, header, data, len);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint PEM_read_bio(BIO *bp, char **name, char **header, unsigned char **data,\\r\\nlong *len)\\r\\n{\\r\\nEVP_ENCODE_CTX ctx;\\r\\nint end = 0, i, k, bl = 0, hl = 0, nohead = 0;\\r\\nchar buf[256];\\r\\nBUF_MEM *nameB;\\r\\nBUF_MEM *headerB;\\r\\nBUF_MEM *dataB, *tmpB;\\r\\nnameB = BUF_MEM_new();\\r\\nheaderB = BUF_MEM_new();\\r\\ndataB = BUF_MEM_new();\\r\\nif ((nameB == NULL) || (headerB == NULL) || (dataB == NULL)) {\\r\\nBUF_MEM_free(nameB);\\r\\nBUF_MEM_free(headerB);\\r\\nBUF_MEM_free(dataB);\\r\\nPEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nbuf[254] = '\\0';\\r\\nfor (;;) {\\r\\ni = BIO_gets(bp, buf, 254);\\r\\nif (i <= 0) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO, PEM_R_NO_START_LINE);\\r\\ngoto err;\\r\\n}\\r\\nwhile ((i >= 0) && (buf[i] <= ' '))\\r\\ni--;\\r\\nbuf[++i] = '\\n';\\r\\nbuf[++i] = '\\0';\\r\\nif (strncmp(buf, \"-----BEGIN \", 11) == 0) {\\r\\ni = strlen(&(buf[11]));\\r\\nif (strncmp(&(buf[11 + i - 6]), \"-----\\n\", 6) != 0)\\r\\ncontinue;\\r\\nif (!BUF_MEM_grow(nameB, i + 9)) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(nameB->data, &(buf[11]), i - 6);\\r\\nnameB->data[i - 6] = '\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nhl = 0;\\r\\nif (!BUF_MEM_grow(headerB, 256)) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nheaderB->data[0] = '\\0';\\r\\nfor (;;) {\\r\\ni = BIO_gets(bp, buf, 254);\\r\\nif (i <= 0)\\r\\nbreak;\\r\\nwhile ((i >= 0) && (buf[i] <= ' '))\\r\\ni--;\\r\\nbuf[++i] = '\\n';\\r\\nbuf[++i] = '\\0';\\r\\nif (buf[0] == '\\n')\\r\\nbreak;\\r\\nif (!BUF_MEM_grow(headerB, hl + i + 9)) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (strncmp(buf, \"-----END \", 9) == 0) {\\r\\nnohead = 1;\\r\\nbreak;\\r\\n}\\r\\nmemcpy(&(headerB->data[hl]), buf, i);\\r\\nheaderB->data[hl + i] = '\\0';\\r\\nhl += i;\\r\\n}\\r\\nbl = 0;\\r\\nif (!BUF_MEM_grow(dataB, 1024)) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ndataB->data[0] = '\\0';\\r\\nif (!nohead) {\\r\\nfor (;;) {\\r\\ni = BIO_gets(bp, buf, 254);\\r\\nif (i <= 0)\\r\\nbreak;\\r\\nwhile ((i >= 0) && (buf[i] <= ' '))\\r\\ni--;\\r\\nbuf[++i] = '\\n';\\r\\nbuf[++i] = '\\0';\\r\\nif (i != 65)\\r\\nend = 1;\\r\\nif (strncmp(buf, \"-----END \", 9) == 0)\\r\\nbreak;\\r\\nif (i > 65)\\r\\nbreak;\\r\\nif (!BUF_MEM_grow_clean(dataB, i + bl + 9)) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(&(dataB->data[bl]), buf, i);\\r\\ndataB->data[bl + i] = '\\0';\\r\\nbl += i;\\r\\nif (end) {\\r\\nbuf[0] = '\\0';\\r\\ni = BIO_gets(bp, buf, 254);\\r\\nif (i <= 0)\\r\\nbreak;\\r\\nwhile ((i >= 0) && (buf[i] <= ' '))\\r\\ni--;\\r\\nbuf[++i] = '\\n';\\r\\nbuf[++i] = '\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n} else {\\r\\ntmpB = headerB;\\r\\nheaderB = dataB;\\r\\ndataB = tmpB;\\r\\nbl = hl;\\r\\n}\\r\\ni = strlen(nameB->data);\\r\\nif ((strncmp(buf, \"-----END \", 9) != 0) ||\\r\\n(strncmp(nameB->data, &(buf[9]), i) != 0) ||\\r\\n(strncmp(&(buf[9 + i]), \"-----\\n\", 6) != 0)) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_END_LINE);\\r\\ngoto err;\\r\\n}\\r\\nEVP_DecodeInit(&ctx);\\r\\ni = EVP_DecodeUpdate(&ctx,\\r\\n(unsigned char *)dataB->data, &bl,\\r\\n(unsigned char *)dataB->data, bl);\\r\\nif (i < 0) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);\\r\\ngoto err;\\r\\n}\\r\\ni = EVP_DecodeFinal(&ctx, (unsigned char *)&(dataB->data[bl]), &k);\\r\\nif (i < 0) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);\\r\\ngoto err;\\r\\n}\\r\\nbl += k;\\r\\nif (bl == 0)\\r\\ngoto err;\\r\\n*name = nameB->data;\\r\\n*header = headerB->data;\\r\\n*data = (unsigned char *)dataB->data;\\r\\n*len = bl;\\r\\nOPENSSL_free(nameB);\\r\\nOPENSSL_free(headerB);\\r\\nOPENSSL_free(dataB);\\r\\nreturn (1);\\r\\nerr:\\r\\nBUF_MEM_free(nameB);\\r\\nBUF_MEM_free(headerB);\\r\\nBUF_MEM_free(dataB);\\r\\nreturn (0);\\r\\n}\\r\\nint pem_check_suffix(const char *pem_str, const char *suffix)\\r\\n{\\r\\nint pem_len = strlen(pem_str);\\r\\nint suffix_len = strlen(suffix);\\r\\nconst char *p;\\r\\nif (suffix_len + 1 >= pem_len)\\r\\nreturn 0;\\r\\np = pem_str + pem_len - suffix_len;\\r\\nif (strcmp(p, suffix))\\r\\nreturn 0;\\r\\np--;\\r\\nif (*p != ' ')\\r\\nreturn 0;\\r\\nreturn p - pem_str;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_set_key_c", "target": 0, "func": "void DES_set_odd_parity(DES_cblock *key)\\r\\n{\\r\\nunsigned int i;\\r\\nfor (i = 0; i < DES_KEY_SZ; i++)\\r\\n(*key)[i] = odd_parity[(*key)[i]];\\r\\n}\\r\\nint DES_check_key_parity(const_DES_cblock *key)\\r\\n{\\r\\nunsigned int i;\\r\\nfor (i = 0; i < DES_KEY_SZ; i++) {\\r\\nif ((*key)[i] != odd_parity[(*key)[i]])\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nint DES_is_weak_key(const_DES_cblock *key)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < NUM_WEAK_KEY; i++)\\r\\nif (memcmp(weak_keys[i], key, sizeof(DES_cblock)) == 0)\\r\\nreturn (1);\\r\\nreturn (0);\\r\\n}\\r\\nint DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule)\\r\\n{\\r\\nif (DES_check_key) {\\r\\nreturn DES_set_key_checked(key, schedule);\\r\\n} else {\\r\\nDES_set_key_unchecked(key, schedule);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nint DES_set_key_checked(const_DES_cblock *key, DES_key_schedule *schedule)\\r\\n{\\r\\nif (!DES_check_key_parity(key))\\r\\nreturn (-1);\\r\\nif (DES_is_weak_key(key))\\r\\nreturn (-2);\\r\\nDES_set_key_unchecked(key, schedule);\\r\\nreturn 0;\\r\\n}\\r\\nvoid DES_set_key_unchecked(const_DES_cblock *key, DES_key_schedule *schedule)\\r\\n#ifdef OPENSSL_FIPS\\r\\n{\\r\\nfips_cipher_abort(DES);\\r\\nprivate_DES_set_key_unchecked(key, schedule);\\r\\n}\\r\\nvoid private_DES_set_key_unchecked(const_DES_cblock *key,\\r\\nDES_key_schedule *schedule)\\r\\n#endif\\r\\n{\\r\\nstatic const int shifts2[16] =\\r\\n{ 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0 };\\r\\nregister DES_LONG c, d, t, s, t2;\\r\\nregister const unsigned char *in;\\r\\nregister DES_LONG *k;\\r\\nregister int i;\\r\\n#ifdef OPENBSD_DEV_CRYPTO\\r\\nmemcpy(schedule->key, key, sizeof schedule->key);\\r\\nschedule->session = NULL;\\r\\n#endif\\r\\nk = &schedule->ks->deslong[0];\\r\\nin = &(*key)[0];\\r\\nc2l(in, c);\\r\\nc2l(in, d);\\r\\nPERM_OP(d, c, t, 4, 0x0f0f0f0fL);\\r\\nHPERM_OP(c, t, -2, 0xcccc0000L);\\r\\nHPERM_OP(d, t, -2, 0xcccc0000L);\\r\\nPERM_OP(d, c, t, 1, 0x55555555L);\\r\\nPERM_OP(c, d, t, 8, 0x00ff00ffL);\\r\\nPERM_OP(d, c, t, 1, 0x55555555L);\\r\\nd = (((d & 0x000000ffL) << 16L) | (d & 0x0000ff00L) |\\r\\n((d & 0x00ff0000L) >> 16L) | ((c & 0xf0000000L) >> 4L));\\r\\nc &= 0x0fffffffL;\\r\\nfor (i = 0; i < ITERATIONS; i++) {\\r\\nif (shifts2[i]) {\\r\\nc = ((c >> 2L) | (c << 26L));\\r\\nd = ((d >> 2L) | (d << 26L));\\r\\n} else {\\r\\nc = ((c >> 1L) | (c << 27L));\\r\\nd = ((d >> 1L) | (d << 27L));\\r\\n}\\r\\nc &= 0x0fffffffL;\\r\\nd &= 0x0fffffffL;\\r\\ns = des_skb[0][(c) & 0x3f] |\\r\\ndes_skb[1][((c >> 6L) & 0x03) | ((c >> 7L) & 0x3c)] |\\r\\ndes_skb[2][((c >> 13L) & 0x0f) | ((c >> 14L) & 0x30)] |\\r\\ndes_skb[3][((c >> 20L) & 0x01) | ((c >> 21L) & 0x06) |\\r\\n((c >> 22L) & 0x38)];\\r\\nt = des_skb[4][(d) & 0x3f] |\\r\\ndes_skb[5][((d >> 7L) & 0x03) | ((d >> 8L) & 0x3c)] |\\r\\ndes_skb[6][(d >> 15L) & 0x3f] |\\r\\ndes_skb[7][((d >> 21L) & 0x0f) | ((d >> 22L) & 0x30)];\\r\\nt2 = ((t << 16L) | (s & 0x0000ffffL)) & 0xffffffffL;\\r\\n*(k++) = ROTATE(t2, 30) & 0xffffffffL;\\r\\nt2 = ((s >> 16L) | (t & 0xffff0000L));\\r\\n*(k++) = ROTATE(t2, 26) & 0xffffffffL;\\r\\n}\\r\\n}\\r\\nint DES_key_sched(const_DES_cblock *key, DES_key_schedule *schedule)\\r\\n{\\r\\nreturn (DES_set_key(key, schedule));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_err_c", "target": 0, "func": "void ERR_load_BIO_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(BIO_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, BIO_str_functs);\\r\\nERR_load_strings(0, BIO_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_comp_err_c", "target": 0, "func": "void ERR_load_COMP_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(COMP_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, COMP_str_functs);\\r\\nERR_load_strings(0, COMP_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_req_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL, *gen_eng = NULL;\\r\\nunsigned long nmflag = 0, reqflag = 0;\\r\\nint ex = 1, x509 = 0, days = 30;\\r\\nX509 *x509ss = NULL;\\r\\nX509_REQ *req = NULL;\\r\\nEVP_PKEY_CTX *genctx = NULL;\\r\\nconst char *keyalg = NULL;\\r\\nchar *keyalgstr = NULL;\\r\\nSTACK_OF(OPENSSL_STRING) *pkeyopts = NULL, *sigopts = NULL;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nint i = 0, badops = 0, newreq = 0, verbose = 0, pkey_type = -1;\\r\\nlong newkey = -1;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat, verify = 0, noout = 0, text = 0, keyform =\\r\\nFORMAT_PEM;\\r\\nint nodes = 0, kludge = 0, newhdr = 0, subject = 0, pubkey = 0;\\r\\nchar *infile, *outfile, *prog, *keyfile = NULL, *template =\\r\\nNULL, *keyout = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nchar *extensions = NULL;\\r\\nchar *req_exts = NULL;\\r\\nconst EVP_CIPHER *cipher = NULL;\\r\\nASN1_INTEGER *serial = NULL;\\r\\nint modulus = 0;\\r\\nchar *inrand = NULL;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\nchar *p;\\r\\nchar *subj = NULL;\\r\\nint multirdn = 0;\\r\\nconst EVP_MD *md_alg = NULL, *digest = NULL;\\r\\nunsigned long chtype = MBSTRING_ASC;\\r\\n#ifndef MONOLITH\\r\\nchar *to_free;\\r\\nlong errline;\\r\\n#endif\\r\\nreq_conf = NULL;\\r\\n#ifndef OPENSSL_NO_DES\\r\\ncipher = EVP_des_ede3_cbc();\\r\\n#endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\ninfile = NULL;\\r\\noutfile = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keygen_engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ngen_eng = ENGINE_by_id(*(++argv));\\r\\nif (gen_eng == NULL) {\\r\\nBIO_printf(bio_err, \"Can't find keygen engine %s\\n\", *argv);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-key\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-pubkey\") == 0) {\\r\\npubkey = 1;\\r\\n} else if (strcmp(*argv, \"-new\") == 0) {\\r\\nnewreq = 1;\\r\\n} else if (strcmp(*argv, \"-config\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ntemplate = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keyform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyform = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keyout\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyout = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passin\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passout\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargout = *(++argv);\\r\\n} else if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninrand = *(++argv);\\r\\n} else if (strcmp(*argv, \"-newkey\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyalg = *(++argv);\\r\\nnewreq = 1;\\r\\n} else if (strcmp(*argv, \"-pkeyopt\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!pkeyopts)\\r\\npkeyopts = sk_OPENSSL_STRING_new_null();\\r\\nif (!pkeyopts || !sk_OPENSSL_STRING_push(pkeyopts, *(++argv)))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-sigopt\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!sigopts)\\r\\nsigopts = sk_OPENSSL_STRING_new_null();\\r\\nif (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-batch\") == 0)\\r\\nbatch = 1;\\r\\nelse if (strcmp(*argv, \"-newhdr\") == 0)\\r\\nnewhdr = 1;\\r\\nelse if (strcmp(*argv, \"-modulus\") == 0)\\r\\nmodulus = 1;\\r\\nelse if (strcmp(*argv, \"-verify\") == 0)\\r\\nverify = 1;\\r\\nelse if (strcmp(*argv, \"-nodes\") == 0)\\r\\nnodes = 1;\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-verbose\") == 0)\\r\\nverbose = 1;\\r\\nelse if (strcmp(*argv, \"-utf8\") == 0)\\r\\nchtype = MBSTRING_UTF8;\\r\\nelse if (strcmp(*argv, \"-nameopt\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!set_name_ex(&nmflag, *(++argv)))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-reqopt\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!set_cert_ex(&reqflag, *(++argv)))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-subject\") == 0)\\r\\nsubject = 1;\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv, \"-x509\") == 0)\\r\\nx509 = 1;\\r\\nelse if (strcmp(*argv, \"-asn1-kludge\") == 0)\\r\\nkludge = 1;\\r\\nelse if (strcmp(*argv, \"-no-asn1-kludge\") == 0)\\r\\nkludge = 0;\\r\\nelse if (strcmp(*argv, \"-subj\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsubj = *(++argv);\\r\\n} else if (strcmp(*argv, \"-multivalue-rdn\") == 0)\\r\\nmultirdn = 1;\\r\\nelse if (strcmp(*argv, \"-days\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ndays = atoi(*(++argv));\\r\\nif (days == 0)\\r\\ndays = 30;\\r\\n} else if (strcmp(*argv, \"-set_serial\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nserial = s2i_ASN1_INTEGER(NULL, *(++argv));\\r\\nif (!serial)\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-extensions\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nextensions = *(++argv);\\r\\n} else if (strcmp(*argv, \"-reqexts\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nreq_exts = *(++argv);\\r\\n} else if ((md_alg = EVP_get_digestbyname(&((*argv)[1]))) != NULL) {\\r\\ndigest = md_alg;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile >outfile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\nBIO_printf(bio_err, \" -text text form of request\\n\");\\r\\nBIO_printf(bio_err, \" -pubkey output public key\\n\");\\r\\nBIO_printf(bio_err, \" -noout do not output REQ\\n\");\\r\\nBIO_printf(bio_err, \" -verify verify signature on REQ\\n\");\\r\\nBIO_printf(bio_err, \" -modulus RSA modulus\\n\");\\r\\nBIO_printf(bio_err, \" -nodes don't encrypt the output key\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e use engine e, possibly a hardware device\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \" -subject output the request's subject\\n\");\\r\\nBIO_printf(bio_err, \" -passin private key password source\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -key file use the private key contained in file\\n\");\\r\\nBIO_printf(bio_err, \" -keyform arg key file format\\n\");\\r\\nBIO_printf(bio_err, \" -keyout arg file to send the key to\\n\");\\r\\nBIO_printf(bio_err, \" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\\r\\n\" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -newkey rsa:bits generate a new RSA key of 'bits' in size\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -newkey dsa:file generate a new DSA key, parameters taken from CA in 'file'\\n\");\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nBIO_printf(bio_err,\\r\\n\" -newkey ec:file generate a new EC key, parameters taken from CA in 'file'\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\\r\\n\" -[digest] Digest to sign with (md5, sha1, md2, mdc2, md4)\\n\");\\r\\nBIO_printf(bio_err, \" -config file request template file.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -subj arg set or modify request subject\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -multivalue-rdn enable support for multivalued RDNs\\n\");\\r\\nBIO_printf(bio_err, \" -new new request.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -batch do not ask anything during request generation\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -x509 output a x509 structure instead of a cert. req.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -days number of days a certificate generated by -x509 is valid for.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -set_serial serial number to use for a certificate generated by -x509.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -newhdr output \\\"NEW\\\" in the header lines\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -asn1-kludge Output the 'request' in a format that is wrong but some CA's\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" have been reported as requiring\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -extensions .. specify certificate extension section (override value in config file)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -reqexts .. specify request extension section (override value in config file)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -utf8 input characters are UTF8 (default ASCII)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -nameopt arg - various certificate name options\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -reqopt arg - various request text options\\n\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nif (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#ifndef MONOLITH\\r\\np = getenv(\"OPENSSL_CONF\");\\r\\nif (p == NULL)\\r\\np = getenv(\"SSLEAY_CONF\");\\r\\nif (p == NULL)\\r\\np = to_free = make_config_name();\\r\\ndefault_config_file = p;\\r\\nconfig = NCONF_new(NULL);\\r\\ni = NCONF_load(config, p, &errline);\\r\\n#endif\\r\\nif (template != NULL) {\\r\\nlong errline = -1;\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"Using configuration from %s\\n\", template);\\r\\nreq_conf = NCONF_new(NULL);\\r\\ni = NCONF_load(req_conf, template, &errline);\\r\\nif (i == 0) {\\r\\nBIO_printf(bio_err, \"error on line %ld of %s\\n\", errline,\\r\\ntemplate);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nreq_conf = config;\\r\\nif (req_conf == NULL) {\\r\\nBIO_printf(bio_err, \"Unable to load config info from %s\\n\",\\r\\ndefault_config_file);\\r\\nif (newreq)\\r\\ngoto end;\\r\\n} else if (verbose)\\r\\nBIO_printf(bio_err, \"Using configuration from %s\\n\",\\r\\ndefault_config_file);\\r\\n}\\r\\nif (req_conf != NULL) {\\r\\nif (!load_config(bio_err, req_conf))\\r\\ngoto end;\\r\\np = NCONF_get_string(req_conf, NULL, \"oid_file\");\\r\\nif (p == NULL)\\r\\nERR_clear_error();\\r\\nif (p != NULL) {\\r\\nBIO *oid_bio;\\r\\noid_bio = BIO_new_file(p, \"r\");\\r\\nif (oid_bio == NULL) {\\r\\n} else {\\r\\nOBJ_create_objects(oid_bio);\\r\\nBIO_free(oid_bio);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!add_oid_section(bio_err, req_conf))\\r\\ngoto end;\\r\\nif (md_alg == NULL) {\\r\\np = NCONF_get_string(req_conf, SECTION, \"default_md\");\\r\\nif (p == NULL)\\r\\nERR_clear_error();\\r\\nif (p != NULL) {\\r\\nif ((md_alg = EVP_get_digestbyname(p)) != NULL)\\r\\ndigest = md_alg;\\r\\n}\\r\\n}\\r\\nif (!extensions) {\\r\\nextensions = NCONF_get_string(req_conf, SECTION, V3_EXTENSIONS);\\r\\nif (!extensions)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (extensions) {\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_nconf(&ctx, req_conf);\\r\\nif (!X509V3_EXT_add_nconf(req_conf, &ctx, extensions, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\", extensions);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!passin) {\\r\\npassin = NCONF_get_string(req_conf, SECTION, \"input_password\");\\r\\nif (!passin)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (!passout) {\\r\\npassout = NCONF_get_string(req_conf, SECTION, \"output_password\");\\r\\nif (!passout)\\r\\nERR_clear_error();\\r\\n}\\r\\np = NCONF_get_string(req_conf, SECTION, STRING_MASK);\\r\\nif (!p)\\r\\nERR_clear_error();\\r\\nif (p && !ASN1_STRING_set_default_mask_asc(p)) {\\r\\nBIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", p);\\r\\ngoto end;\\r\\n}\\r\\nif (chtype != MBSTRING_UTF8) {\\r\\np = NCONF_get_string(req_conf, SECTION, UTF8_IN);\\r\\nif (!p)\\r\\nERR_clear_error();\\r\\nelse if (!strcmp(p, \"yes\"))\\r\\nchtype = MBSTRING_UTF8;\\r\\n}\\r\\nif (!req_exts) {\\r\\nreq_exts = NCONF_get_string(req_conf, SECTION, REQ_EXTENSIONS);\\r\\nif (!req_exts)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (req_exts) {\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_nconf(&ctx, req_conf);\\r\\nif (!X509V3_EXT_add_nconf(req_conf, &ctx, req_exts, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading request extension section %s\\n\",\\r\\nreq_exts);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL))\\r\\ngoto end;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (keyfile != NULL) {\\r\\npkey = load_key(bio_err, keyfile, keyform, 0, passin, e,\\r\\n\"Private Key\");\\r\\nif (!pkey) {\\r\\ngoto end;\\r\\n} else {\\r\\nchar *randfile = NCONF_get_string(req_conf, SECTION, \"RANDFILE\");\\r\\nif (randfile == NULL)\\r\\nERR_clear_error();\\r\\napp_RAND_load_file(randfile, bio_err, 0);\\r\\n}\\r\\n}\\r\\nif (newreq && (pkey == NULL)) {\\r\\nchar *randfile = NCONF_get_string(req_conf, SECTION, \"RANDFILE\");\\r\\nif (randfile == NULL)\\r\\nERR_clear_error();\\r\\napp_RAND_load_file(randfile, bio_err, 0);\\r\\nif (inrand)\\r\\napp_RAND_load_files(inrand);\\r\\nif (!NCONF_get_number(req_conf, SECTION, BITS, &newkey)) {\\r\\nnewkey = DEFAULT_KEY_LENGTH;\\r\\n}\\r\\nif (keyalg) {\\r\\ngenctx = set_keygen_ctx(bio_err, keyalg, &pkey_type, &newkey,\\r\\n&keyalgstr, gen_eng);\\r\\nif (!genctx)\\r\\ngoto end;\\r\\n}\\r\\nif (newkey < MIN_KEY_LENGTH\\r\\n&& (pkey_type == EVP_PKEY_RSA || pkey_type == EVP_PKEY_DSA)) {\\r\\nBIO_printf(bio_err, \"private key length is too short,\\n\");\\r\\nBIO_printf(bio_err, \"it needs to be at least %d bits, not %ld\\n\",\\r\\nMIN_KEY_LENGTH, newkey);\\r\\ngoto end;\\r\\n}\\r\\nif (!genctx) {\\r\\ngenctx = set_keygen_ctx(bio_err, NULL, &pkey_type, &newkey,\\r\\n&keyalgstr, gen_eng);\\r\\nif (!genctx)\\r\\ngoto end;\\r\\n}\\r\\nif (pkeyopts) {\\r\\nchar *genopt;\\r\\nfor (i = 0; i < sk_OPENSSL_STRING_num(pkeyopts); i++) {\\r\\ngenopt = sk_OPENSSL_STRING_value(pkeyopts, i);\\r\\nif (pkey_ctrl_string(genctx, genopt) <= 0) {\\r\\nBIO_printf(bio_err, \"parameter error \\\"%s\\\"\\n\", genopt);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err, \"Generating a %ld bit %s private key\\n\",\\r\\nnewkey, keyalgstr);\\r\\nEVP_PKEY_CTX_set_cb(genctx, genpkey_cb);\\r\\nEVP_PKEY_CTX_set_app_data(genctx, bio_err);\\r\\nif (EVP_PKEY_keygen(genctx, &pkey) <= 0) {\\r\\nBIO_puts(bio_err, \"Error Generating Key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nEVP_PKEY_CTX_free(genctx);\\r\\ngenctx = NULL;\\r\\napp_RAND_write_file(randfile, bio_err);\\r\\nif (keyout == NULL) {\\r\\nkeyout = NCONF_get_string(req_conf, SECTION, KEYFILE);\\r\\nif (keyout == NULL)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (keyout == NULL) {\\r\\nBIO_printf(bio_err, \"writing new private key to stdout\\n\");\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nBIO_printf(bio_err, \"writing new private key to '%s'\\n\", keyout);\\r\\nif (BIO_write_filename(out, keyout) <= 0) {\\r\\nperror(keyout);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\np = NCONF_get_string(req_conf, SECTION, \"encrypt_rsa_key\");\\r\\nif (p == NULL) {\\r\\nERR_clear_error();\\r\\np = NCONF_get_string(req_conf, SECTION, \"encrypt_key\");\\r\\nif (p == NULL)\\r\\nERR_clear_error();\\r\\n}\\r\\nif ((p != NULL) && (strcmp(p, \"no\") == 0))\\r\\ncipher = NULL;\\r\\nif (nodes)\\r\\ncipher = NULL;\\r\\ni = 0;\\r\\nloop:\\r\\nif (!PEM_write_bio_PrivateKey(out, pkey, cipher,\\r\\nNULL, 0, NULL, passout)) {\\r\\nif ((ERR_GET_REASON(ERR_peek_error()) ==\\r\\nPEM_R_PROBLEMS_GETTING_PASSWORD) && (i < 3)) {\\r\\nERR_clear_error();\\r\\ni++;\\r\\ngoto loop;\\r\\n}\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err, \"-----\\n\");\\r\\n}\\r\\nif (!newreq) {\\r\\nkludge = -1;\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (informat == FORMAT_ASN1)\\r\\nreq = d2i_X509_REQ_bio(in, NULL);\\r\\nelse if (informat == FORMAT_PEM)\\r\\nreq = PEM_read_bio_X509_REQ(in, NULL, NULL, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err,\\r\\n\"bad input format specified for X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (req == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (newreq || x509) {\\r\\nif (pkey == NULL) {\\r\\nBIO_printf(bio_err, \"you need to specify a private key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (req == NULL) {\\r\\nreq = X509_REQ_new();\\r\\nif (req == NULL) {\\r\\ngoto end;\\r\\n}\\r\\ni = make_REQ(req, pkey, subj, multirdn, !x509, chtype);\\r\\nsubj = NULL;\\r\\nif ((kludge > 0)\\r\\n&& !sk_X509_ATTRIBUTE_num(req->req_info->attributes)) {\\r\\nsk_X509_ATTRIBUTE_free(req->req_info->attributes);\\r\\nreq->req_info->attributes = NULL;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"problems making Certificate Request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (x509) {\\r\\nEVP_PKEY *tmppkey;\\r\\nX509V3_CTX ext_ctx;\\r\\nif ((x509ss = X509_new()) == NULL)\\r\\ngoto end;\\r\\nif (extensions && !X509_set_version(x509ss, 2))\\r\\ngoto end;\\r\\nif (serial) {\\r\\nif (!X509_set_serialNumber(x509ss, serial))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!rand_serial(NULL, X509_get_serialNumber(x509ss)))\\r\\ngoto end;\\r\\n}\\r\\nif (!X509_set_issuer_name(x509ss, X509_REQ_get_subject_name(req)))\\r\\ngoto end;\\r\\nif (!X509_gmtime_adj(X509_get_notBefore(x509ss), 0))\\r\\ngoto end;\\r\\nif (!X509_time_adj_ex(X509_get_notAfter(x509ss), days, 0, NULL))\\r\\ngoto end;\\r\\nif (!X509_set_subject_name\\r\\n(x509ss, X509_REQ_get_subject_name(req)))\\r\\ngoto end;\\r\\ntmppkey = X509_REQ_get_pubkey(req);\\r\\nif (!tmppkey || !X509_set_pubkey(x509ss, tmppkey))\\r\\ngoto end;\\r\\nEVP_PKEY_free(tmppkey);\\r\\nX509V3_set_ctx(&ext_ctx, x509ss, x509ss, NULL, NULL, 0);\\r\\nX509V3_set_nconf(&ext_ctx, req_conf);\\r\\nif (extensions && !X509V3_EXT_add_nconf(req_conf,\\r\\n&ext_ctx, extensions,\\r\\nx509ss)) {\\r\\nBIO_printf(bio_err, \"Error Loading extension section %s\\n\",\\r\\nextensions);\\r\\ngoto end;\\r\\n}\\r\\ni = do_X509_sign(bio_err, x509ss, pkey, digest, sigopts);\\r\\nif (!i) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nX509V3_CTX ext_ctx;\\r\\nX509V3_set_ctx(&ext_ctx, NULL, NULL, req, NULL, 0);\\r\\nX509V3_set_nconf(&ext_ctx, req_conf);\\r\\nif (req_exts && !X509V3_EXT_REQ_add_nconf(req_conf,\\r\\n&ext_ctx, req_exts,\\r\\nreq)) {\\r\\nBIO_printf(bio_err, \"Error Loading extension section %s\\n\",\\r\\nreq_exts);\\r\\ngoto end;\\r\\n}\\r\\ni = do_X509_REQ_sign(bio_err, req, pkey, digest, sigopts);\\r\\nif (!i) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (subj && x509) {\\r\\nBIO_printf(bio_err, \"Cannot modifiy certificate subject\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (subj && !x509) {\\r\\nif (verbose) {\\r\\nBIO_printf(bio_err, \"Modifying Request's Subject\\n\");\\r\\nprint_name(bio_err, \"old subject=\",\\r\\nX509_REQ_get_subject_name(req), nmflag);\\r\\n}\\r\\nif (build_subject(req, subj, chtype, multirdn) == 0) {\\r\\nBIO_printf(bio_err, \"ERROR: cannot modify subject\\n\");\\r\\nex = 1;\\r\\ngoto end;\\r\\n}\\r\\nreq->req_info->enc.modified = 1;\\r\\nif (verbose) {\\r\\nprint_name(bio_err, \"new subject=\",\\r\\nX509_REQ_get_subject_name(req), nmflag);\\r\\n}\\r\\n}\\r\\nif (verify && !x509) {\\r\\nint tmp = 0;\\r\\nif (pkey == NULL) {\\r\\npkey = X509_REQ_get_pubkey(req);\\r\\ntmp = 1;\\r\\nif (pkey == NULL)\\r\\ngoto end;\\r\\n}\\r\\ni = X509_REQ_verify(req, pkey);\\r\\nif (tmp) {\\r\\nEVP_PKEY_free(pkey);\\r\\npkey = NULL;\\r\\n}\\r\\nif (i < 0) {\\r\\ngoto end;\\r\\n} else if (i == 0) {\\r\\nBIO_printf(bio_err, \"verify failure\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n} else\\r\\nBIO_printf(bio_err, \"verify OK\\n\");\\r\\n}\\r\\nif (noout && !text && !modulus && !subject && !pubkey) {\\r\\nex = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nif ((keyout != NULL) && (strcmp(outfile, keyout) == 0))\\r\\ni = (int)BIO_append_filename(out, outfile);\\r\\nelse\\r\\ni = (int)BIO_write_filename(out, outfile);\\r\\nif (!i) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (pubkey) {\\r\\nEVP_PKEY *tpubkey;\\r\\ntpubkey = X509_REQ_get_pubkey(req);\\r\\nif (tpubkey == NULL) {\\r\\nBIO_printf(bio_err, \"Error getting public key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nPEM_write_bio_PUBKEY(out, tpubkey);\\r\\nEVP_PKEY_free(tpubkey);\\r\\n}\\r\\nif (text) {\\r\\nif (x509)\\r\\nX509_print_ex(out, x509ss, nmflag, reqflag);\\r\\nelse\\r\\nX509_REQ_print_ex(out, req, nmflag, reqflag);\\r\\n}\\r\\nif (subject) {\\r\\nif (x509)\\r\\nprint_name(out, \"subject=\", X509_get_subject_name(x509ss),\\r\\nnmflag);\\r\\nelse\\r\\nprint_name(out, \"subject=\", X509_REQ_get_subject_name(req),\\r\\nnmflag);\\r\\n}\\r\\nif (modulus) {\\r\\nEVP_PKEY *tpubkey;\\r\\nif (x509)\\r\\ntpubkey = X509_get_pubkey(x509ss);\\r\\nelse\\r\\ntpubkey = X509_REQ_get_pubkey(req);\\r\\nif (tpubkey == NULL) {\\r\\nfprintf(stdout, \"Modulus=unavailable\\n\");\\r\\ngoto end;\\r\\n}\\r\\nfprintf(stdout, \"Modulus=\");\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (EVP_PKEY_base_id(tpubkey) == EVP_PKEY_RSA)\\r\\nBN_print(out, tpubkey->pkey.rsa->n);\\r\\nelse\\r\\n#endif\\r\\nfprintf(stdout, \"Wrong Algorithm type\");\\r\\nEVP_PKEY_free(tpubkey);\\r\\nfprintf(stdout, \"\\n\");\\r\\n}\\r\\nif (!noout && !x509) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_X509_REQ_bio(out, req);\\r\\nelse if (outformat == FORMAT_PEM) {\\r\\nif (newhdr)\\r\\ni = PEM_write_bio_X509_REQ_NEW(out, req);\\r\\nelse\\r\\ni = PEM_write_bio_X509_REQ(out, req);\\r\\n} else {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write X509 request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!noout && x509 && (x509ss != NULL)) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_X509_bio(out, x509ss);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_X509(out, x509ss);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write X509 certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nex = 0;\\r\\nend:\\r\\n#ifndef MONOLITH\\r\\nif (to_free)\\r\\nOPENSSL_free(to_free);\\r\\n#endif\\r\\nif (ex) {\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif ((req_conf != NULL) && (req_conf != config))\\r\\nNCONF_free(req_conf);\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (genctx)\\r\\nEVP_PKEY_CTX_free(genctx);\\r\\nif (pkeyopts)\\r\\nsk_OPENSSL_STRING_free(pkeyopts);\\r\\nif (sigopts)\\r\\nsk_OPENSSL_STRING_free(sigopts);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (gen_eng)\\r\\nENGINE_free(gen_eng);\\r\\n#endif\\r\\nif (keyalgstr)\\r\\nOPENSSL_free(keyalgstr);\\r\\nX509_REQ_free(req);\\r\\nX509_free(x509ss);\\r\\nASN1_INTEGER_free(serial);\\r\\nif (passargin && passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passargout && passout)\\r\\nOPENSSL_free(passout);\\r\\nOBJ_cleanup();\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ex);\\r\\n}\\r\\nstatic int make_REQ(X509_REQ *req, EVP_PKEY *pkey, char *subj, int multirdn,\\r\\nint attribs, unsigned long chtype)\\r\\n{\\r\\nint ret = 0, i;\\r\\nchar no_prompt = 0;\\r\\nSTACK_OF(CONF_VALUE) *dn_sk, *attr_sk = NULL;\\r\\nchar *tmp, *dn_sect, *attr_sect;\\r\\ntmp = NCONF_get_string(req_conf, SECTION, PROMPT);\\r\\nif (tmp == NULL)\\r\\nERR_clear_error();\\r\\nif ((tmp != NULL) && !strcmp(tmp, \"no\"))\\r\\nno_prompt = 1;\\r\\ndn_sect = NCONF_get_string(req_conf, SECTION, DISTINGUISHED_NAME);\\r\\nif (dn_sect == NULL) {\\r\\nBIO_printf(bio_err, \"unable to find '%s' in config\\n\",\\r\\nDISTINGUISHED_NAME);\\r\\ngoto err;\\r\\n}\\r\\ndn_sk = NCONF_get_section(req_conf, dn_sect);\\r\\nif (dn_sk == NULL) {\\r\\nBIO_printf(bio_err, \"unable to get '%s' section\\n\", dn_sect);\\r\\ngoto err;\\r\\n}\\r\\nattr_sect = NCONF_get_string(req_conf, SECTION, ATTRIBUTES);\\r\\nif (attr_sect == NULL) {\\r\\nERR_clear_error();\\r\\nattr_sk = NULL;\\r\\n} else {\\r\\nattr_sk = NCONF_get_section(req_conf, attr_sect);\\r\\nif (attr_sk == NULL) {\\r\\nBIO_printf(bio_err, \"unable to get '%s' section\\n\", attr_sect);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!X509_REQ_set_version(req, 0L))\\r\\ngoto err;\\r\\nif (no_prompt)\\r\\ni = auto_info(req, dn_sk, attr_sk, attribs, chtype);\\r\\nelse {\\r\\nif (subj)\\r\\ni = build_subject(req, subj, chtype, multirdn);\\r\\nelse\\r\\ni = prompt_info(req, dn_sk, dn_sect, attr_sk, attr_sect, attribs,\\r\\nchtype);\\r\\n}\\r\\nif (!i)\\r\\ngoto err;\\r\\nif (!X509_REQ_set_pubkey(req, pkey))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int build_subject(X509_REQ *req, char *subject, unsigned long chtype,\\r\\nint multirdn)\\r\\n{\\r\\nX509_NAME *n;\\r\\nif (!(n = parse_name(subject, chtype, multirdn)))\\r\\nreturn 0;\\r\\nif (!X509_REQ_set_subject_name(req, n)) {\\r\\nX509_NAME_free(n);\\r\\nreturn 0;\\r\\n}\\r\\nX509_NAME_free(n);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int add_DN_object(X509_NAME *n, char *text, const char *def,\\r\\nchar *value, int nid, int n_min, int n_max,\\r\\nunsigned long chtype, int mval)\\r\\n{\\r\\nint i, ret = 0;\\r\\nMS_STATIC char buf[1024];\\r\\nstart:\\r\\nif (!batch)\\r\\nBIO_printf(bio_err, \"%s [%s]:\", text, def);\\r\\n(void)BIO_flush(bio_err);\\r\\nif (value != NULL) {\\r\\nBUF_strlcpy(buf, value, sizeof buf);\\r\\nBUF_strlcat(buf, \"\\n\", sizeof buf);\\r\\nBIO_printf(bio_err, \"%s\\n\", value);\\r\\n} else {\\r\\nbuf[0] = '\\0';\\r\\nif (!batch) {\\r\\nif (!fgets(buf, sizeof buf, stdin))\\r\\nreturn 0;\\r\\n} else {\\r\\nbuf[0] = '\\n';\\r\\nbuf[1] = '\\0';\\r\\n}\\r\\n}\\r\\nif (buf[0] == '\\0')\\r\\nreturn (0);\\r\\nelse if (buf[0] == '\\n') {\\r\\nif ((def == NULL) || (def[0] == '\\0'))\\r\\nreturn (1);\\r\\nBUF_strlcpy(buf, def, sizeof buf);\\r\\nBUF_strlcat(buf, \"\\n\", sizeof buf);\\r\\n} else if ((buf[0] == '.') && (buf[1] == '\\n'))\\r\\nreturn (1);\\r\\ni = strlen(buf);\\r\\nif (buf[i - 1] != '\\n') {\\r\\nBIO_printf(bio_err, \"weird input :-(\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nbuf[--i] = '\\0';\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, i);\\r\\n#endif\\r\\nif (!req_check_len(i, n_min, n_max)) {\\r\\nif (batch || value)\\r\\nreturn 0;\\r\\ngoto start;\\r\\n}\\r\\nif (!X509_NAME_add_entry_by_NID(n, nid, chtype,\\r\\n(unsigned char *)buf, -1, -1, mval))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int add_attribute_object(X509_REQ *req, char *text, const char *def,\\r\\nchar *value, int nid, int n_min,\\r\\nint n_max, unsigned long chtype)\\r\\n{\\r\\nint i;\\r\\nstatic char buf[1024];\\r\\nstart:\\r\\nif (!batch)\\r\\nBIO_printf(bio_err, \"%s [%s]:\", text, def);\\r\\n(void)BIO_flush(bio_err);\\r\\nif (value != NULL) {\\r\\nBUF_strlcpy(buf, value, sizeof buf);\\r\\nBUF_strlcat(buf, \"\\n\", sizeof buf);\\r\\nBIO_printf(bio_err, \"%s\\n\", value);\\r\\n} else {\\r\\nbuf[0] = '\\0';\\r\\nif (!batch) {\\r\\nif (!fgets(buf, sizeof buf, stdin))\\r\\nreturn 0;\\r\\n} else {\\r\\nbuf[0] = '\\n';\\r\\nbuf[1] = '\\0';\\r\\n}\\r\\n}\\r\\nif (buf[0] == '\\0')\\r\\nreturn (0);\\r\\nelse if (buf[0] == '\\n') {\\r\\nif ((def == NULL) || (def[0] == '\\0'))\\r\\nreturn (1);\\r\\nBUF_strlcpy(buf, def, sizeof buf);\\r\\nBUF_strlcat(buf, \"\\n\", sizeof buf);\\r\\n} else if ((buf[0] == '.') && (buf[1] == '\\n'))\\r\\nreturn (1);\\r\\ni = strlen(buf);\\r\\nif (buf[i - 1] != '\\n') {\\r\\nBIO_printf(bio_err, \"weird input :-(\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nbuf[--i] = '\\0';\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, i);\\r\\n#endif\\r\\nif (!req_check_len(i, n_min, n_max)) {\\r\\nif (batch || value)\\r\\nreturn 0;\\r\\ngoto start;\\r\\n}\\r\\nif (!X509_REQ_add1_attr_by_NID(req, nid, chtype,\\r\\n(unsigned char *)buf, -1)) {\\r\\nBIO_printf(bio_err, \"Error adding attribute\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nreturn (1);\\r\\nerr:\\r\\nreturn (0);\\r\\n}\\r\\nstatic int req_check_len(int len, int n_min, int n_max)\\r\\n{\\r\\nif ((n_min > 0) && (len < n_min)) {\\r\\nBIO_printf(bio_err,\\r\\n\"string is too short, it needs to be at least %d bytes long\\n\",\\r\\nn_min);\\r\\nreturn (0);\\r\\n}\\r\\nif ((n_max >= 0) && (len > n_max)) {\\r\\nBIO_printf(bio_err,\\r\\n\"string is too long, it needs to be less than %d bytes long\\n\",\\r\\nn_max);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int check_end(const char *str, const char *end)\\r\\n{\\r\\nint elen, slen;\\r\\nconst char *tmp;\\r\\nelen = strlen(end);\\r\\nslen = strlen(str);\\r\\nif (elen > slen)\\r\\nreturn 1;\\r\\ntmp = str + slen - elen;\\r\\nreturn strcmp(tmp, end);\\r\\n}\\r\\nstatic EVP_PKEY_CTX *set_keygen_ctx(BIO *err, const char *gstr,\\r\\nint *pkey_type, long *pkeylen,\\r\\nchar **palgnam, ENGINE *keygen_engine)\\r\\n{\\r\\nEVP_PKEY_CTX *gctx = NULL;\\r\\nEVP_PKEY *param = NULL;\\r\\nlong keylen = -1;\\r\\nBIO *pbio = NULL;\\r\\nconst char *paramfile = NULL;\\r\\nif (gstr == NULL) {\\r\\n*pkey_type = EVP_PKEY_RSA;\\r\\nkeylen = *pkeylen;\\r\\n} else if (gstr[0] >= '0' && gstr[0] <= '9') {\\r\\n*pkey_type = EVP_PKEY_RSA;\\r\\nkeylen = atol(gstr);\\r\\n*pkeylen = keylen;\\r\\n} else if (!strncmp(gstr, \"param:\", 6))\\r\\nparamfile = gstr + 6;\\r\\nelse {\\r\\nconst char *p = strchr(gstr, ':');\\r\\nint len;\\r\\nENGINE *tmpeng;\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nif (p)\\r\\nlen = p - gstr;\\r\\nelse\\r\\nlen = strlen(gstr);\\r\\nameth = EVP_PKEY_asn1_find_str(&tmpeng, gstr, len);\\r\\nif (!ameth) {\\r\\nBIO_printf(err, \"Unknown algorithm %.*s\\n\", len, gstr);\\r\\nreturn NULL;\\r\\n}\\r\\nEVP_PKEY_asn1_get0_info(NULL, pkey_type, NULL, NULL, NULL, ameth);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (tmpeng)\\r\\nENGINE_finish(tmpeng);\\r\\n#endif\\r\\nif (*pkey_type == EVP_PKEY_RSA) {\\r\\nif (p) {\\r\\nkeylen = atol(p + 1);\\r\\n*pkeylen = keylen;\\r\\n} else\\r\\nkeylen = *pkeylen;\\r\\n} else if (p)\\r\\nparamfile = p + 1;\\r\\n}\\r\\nif (paramfile) {\\r\\npbio = BIO_new_file(paramfile, \"r\");\\r\\nif (!pbio) {\\r\\nBIO_printf(err, \"Can't open parameter file %s\\n\", paramfile);\\r\\nreturn NULL;\\r\\n}\\r\\nparam = PEM_read_bio_Parameters(pbio, NULL);\\r\\nif (!param) {\\r\\nX509 *x;\\r\\n(void)BIO_reset(pbio);\\r\\nx = PEM_read_bio_X509(pbio, NULL, NULL, NULL);\\r\\nif (x) {\\r\\nparam = X509_get_pubkey(x);\\r\\nX509_free(x);\\r\\n}\\r\\n}\\r\\nBIO_free(pbio);\\r\\nif (!param) {\\r\\nBIO_printf(err, \"Error reading parameter file %s\\n\", paramfile);\\r\\nreturn NULL;\\r\\n}\\r\\nif (*pkey_type == -1)\\r\\n*pkey_type = EVP_PKEY_id(param);\\r\\nelse if (*pkey_type != EVP_PKEY_base_id(param)) {\\r\\nBIO_printf(err, \"Key Type does not match parameters\\n\");\\r\\nEVP_PKEY_free(param);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nif (palgnam) {\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nENGINE *tmpeng;\\r\\nconst char *anam;\\r\\nameth = EVP_PKEY_asn1_find(&tmpeng, *pkey_type);\\r\\nif (!ameth) {\\r\\nBIO_puts(err, \"Internal error: can't find key algorithm\\n\");\\r\\nreturn NULL;\\r\\n}\\r\\nEVP_PKEY_asn1_get0_info(NULL, NULL, NULL, NULL, &anam, ameth);\\r\\n*palgnam = BUF_strdup(anam);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (tmpeng)\\r\\nENGINE_finish(tmpeng);\\r\\n#endif\\r\\n}\\r\\nif (param) {\\r\\ngctx = EVP_PKEY_CTX_new(param, keygen_engine);\\r\\n*pkeylen = EVP_PKEY_bits(param);\\r\\nEVP_PKEY_free(param);\\r\\n} else\\r\\ngctx = EVP_PKEY_CTX_new_id(*pkey_type, keygen_engine);\\r\\nif (!gctx) {\\r\\nBIO_puts(err, \"Error allocating keygen context\\n\");\\r\\nERR_print_errors(err);\\r\\nreturn NULL;\\r\\n}\\r\\nif (EVP_PKEY_keygen_init(gctx) <= 0) {\\r\\nBIO_puts(err, \"Error initializing keygen context\\n\");\\r\\nERR_print_errors(err);\\r\\nreturn NULL;\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif ((*pkey_type == EVP_PKEY_RSA) && (keylen != -1)) {\\r\\nif (EVP_PKEY_CTX_set_rsa_keygen_bits(gctx, keylen) <= 0) {\\r\\nBIO_puts(err, \"Error setting RSA keysize\\n\");\\r\\nERR_print_errors(err);\\r\\nEVP_PKEY_CTX_free(gctx);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nreturn gctx;\\r\\n}\\r\\nstatic int genpkey_cb(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nchar c = '*';\\r\\nBIO *b = EVP_PKEY_CTX_get_app_data(ctx);\\r\\nint p;\\r\\np = EVP_PKEY_CTX_get_keygen_info(ctx, 0);\\r\\nif (p == 0)\\r\\nc = '.';\\r\\nif (p == 1)\\r\\nc = '+';\\r\\nif (p == 2)\\r\\nc = '*';\\r\\nif (p == 3)\\r\\nc = '\\n';\\r\\nBIO_write(b, &c, 1);\\r\\n(void)BIO_flush(b);\\r\\n#ifdef LINT\\r\\np = n;\\r\\n#endif\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_npas_c", "target": 0, "func": "int PKCS12_newpass(PKCS12 *p12, char *oldpass, char *newpass)\\r\\n{\\r\\nif (!p12) {\\r\\nPKCS12err(PKCS12_F_PKCS12_NEWPASS,\\r\\nPKCS12_R_INVALID_NULL_PKCS12_POINTER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS12_verify_mac(p12, oldpass, -1)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_NEWPASS, PKCS12_R_MAC_VERIFY_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!newpass_p12(p12, oldpass, newpass)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_NEWPASS, PKCS12_R_PARSE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int newpass_p12(PKCS12 *p12, char *oldpass, char *newpass)\\r\\n{\\r\\nSTACK_OF(PKCS7) *asafes, *newsafes;\\r\\nSTACK_OF(PKCS12_SAFEBAG) *bags;\\r\\nint i, bagnid, pbe_nid = 0, pbe_iter = 0, pbe_saltlen = 0;\\r\\nPKCS7 *p7, *p7new;\\r\\nASN1_OCTET_STRING *p12_data_tmp = NULL, *macnew = NULL;\\r\\nunsigned char mac[EVP_MAX_MD_SIZE];\\r\\nunsigned int maclen;\\r\\nif (!(asafes = PKCS12_unpack_authsafes(p12)))\\r\\nreturn 0;\\r\\nif (!(newsafes = sk_PKCS7_new_null()))\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_PKCS7_num(asafes); i++) {\\r\\np7 = sk_PKCS7_value(asafes, i);\\r\\nbagnid = OBJ_obj2nid(p7->type);\\r\\nif (bagnid == NID_pkcs7_data) {\\r\\nbags = PKCS12_unpack_p7data(p7);\\r\\n} else if (bagnid == NID_pkcs7_encrypted) {\\r\\nbags = PKCS12_unpack_p7encdata(p7, oldpass, -1);\\r\\nif (!alg_get(p7->d.encrypted->enc_data->algorithm,\\r\\n&pbe_nid, &pbe_iter, &pbe_saltlen)) {\\r\\nsk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nbags = NULL;\\r\\n}\\r\\n} else\\r\\ncontinue;\\r\\nif (!bags) {\\r\\nsk_PKCS7_pop_free(asafes, PKCS7_free);\\r\\nreturn 0;\\r\\n}\\r\\nif (!newpass_bags(bags, oldpass, newpass)) {\\r\\nsk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nsk_PKCS7_pop_free(asafes, PKCS7_free);\\r\\nreturn 0;\\r\\n}\\r\\nif (bagnid == NID_pkcs7_data)\\r\\np7new = PKCS12_pack_p7data(bags);\\r\\nelse\\r\\np7new = PKCS12_pack_p7encdata(pbe_nid, newpass, -1, NULL,\\r\\npbe_saltlen, pbe_iter, bags);\\r\\nsk_PKCS12_SAFEBAG_pop_free(bags, PKCS12_SAFEBAG_free);\\r\\nif (!p7new) {\\r\\nsk_PKCS7_pop_free(asafes, PKCS7_free);\\r\\nreturn 0;\\r\\n}\\r\\nsk_PKCS7_push(newsafes, p7new);\\r\\n}\\r\\nsk_PKCS7_pop_free(asafes, PKCS7_free);\\r\\np12_data_tmp = p12->authsafes->d.data;\\r\\nif (!(p12->authsafes->d.data = ASN1_OCTET_STRING_new()))\\r\\ngoto saferr;\\r\\nif (!PKCS12_pack_authsafes(p12, newsafes))\\r\\ngoto saferr;\\r\\nif (!PKCS12_gen_mac(p12, newpass, -1, mac, &maclen))\\r\\ngoto saferr;\\r\\nif (!(macnew = ASN1_OCTET_STRING_new()))\\r\\ngoto saferr;\\r\\nif (!ASN1_OCTET_STRING_set(macnew, mac, maclen))\\r\\ngoto saferr;\\r\\nASN1_OCTET_STRING_free(p12->mac->dinfo->digest);\\r\\np12->mac->dinfo->digest = macnew;\\r\\nASN1_OCTET_STRING_free(p12_data_tmp);\\r\\nreturn 1;\\r\\nsaferr:\\r\\nASN1_OCTET_STRING_free(p12->authsafes->d.data);\\r\\nASN1_OCTET_STRING_free(macnew);\\r\\np12->authsafes->d.data = p12_data_tmp;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int newpass_bag(PKCS12_SAFEBAG *bag, char *oldpass, char *newpass)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8;\\r\\nX509_SIG *p8new;\\r\\nint p8_nid, p8_saltlen, p8_iter;\\r\\nif (M_PKCS12_bag_type(bag) != NID_pkcs8ShroudedKeyBag)\\r\\nreturn 1;\\r\\nif (!(p8 = PKCS8_decrypt(bag->value.shkeybag, oldpass, -1)))\\r\\nreturn 0;\\r\\nif (!alg_get(bag->value.shkeybag->algor, &p8_nid, &p8_iter, &p8_saltlen))\\r\\nreturn 0;\\r\\nif (!(p8new = PKCS8_encrypt(p8_nid, NULL, newpass, -1, NULL, p8_saltlen,\\r\\np8_iter, p8)))\\r\\nreturn 0;\\r\\nX509_SIG_free(bag->value.shkeybag);\\r\\nbag->value.shkeybag = p8new;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int alg_get(X509_ALGOR *alg, int *pnid, int *piter, int *psaltlen)\\r\\n{\\r\\nPBEPARAM *pbe;\\r\\nconst unsigned char *p;\\r\\np = alg->parameter->value.sequence->data;\\r\\npbe = d2i_PBEPARAM(NULL, &p, alg->parameter->value.sequence->length);\\r\\nif (!pbe)\\r\\nreturn 0;\\r\\n*pnid = OBJ_obj2nid(alg->algorithm);\\r\\n*piter = ASN1_INTEGER_get(pbe->iter);\\r\\n*psaltlen = pbe->salt->length;\\r\\nPBEPARAM_free(pbe);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_x509_c", "target": 0, "func": "static int x509_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nX509 *ret = (X509 *)*pval;\\r\\nswitch (operation) {\\r\\ncase ASN1_OP_NEW_POST:\\r\\nret->valid = 0;\\r\\nret->name = NULL;\\r\\nret->ex_flags = 0;\\r\\nret->ex_pathlen = -1;\\r\\nret->skid = NULL;\\r\\nret->akid = NULL;\\r\\n#ifndef OPENSSL_NO_RFC3779\\r\\nret->rfc3779_addr = NULL;\\r\\nret->rfc3779_asid = NULL;\\r\\n#endif\\r\\nret->aux = NULL;\\r\\nret->crldp = NULL;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509, ret, &ret->ex_data);\\r\\nbreak;\\r\\ncase ASN1_OP_D2I_POST:\\r\\nif (ret->name != NULL)\\r\\nOPENSSL_free(ret->name);\\r\\nret->name = X509_NAME_oneline(ret->cert_info->subject, NULL, 0);\\r\\nbreak;\\r\\ncase ASN1_OP_FREE_POST:\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509, ret, &ret->ex_data);\\r\\nX509_CERT_AUX_free(ret->aux);\\r\\nASN1_OCTET_STRING_free(ret->skid);\\r\\nAUTHORITY_KEYID_free(ret->akid);\\r\\nCRL_DIST_POINTS_free(ret->crldp);\\r\\npolicy_cache_free(ret->policy_cache);\\r\\nGENERAL_NAMES_free(ret->altname);\\r\\nNAME_CONSTRAINTS_free(ret->nc);\\r\\n#ifndef OPENSSL_NO_RFC3779\\r\\nsk_IPAddressFamily_pop_free(ret->rfc3779_addr, IPAddressFamily_free);\\r\\nASIdentifiers_free(ret->rfc3779_asid);\\r\\n#endif\\r\\nif (ret->name != NULL)\\r\\nOPENSSL_free(ret->name);\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint X509_set_ex_data(X509 *r, int idx, void *arg)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&r->ex_data, idx, arg));\\r\\n}\\r\\nvoid *X509_get_ex_data(X509 *r, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&r->ex_data, idx));\\r\\n}\\r\\nX509 *d2i_X509_AUX(X509 **a, const unsigned char **pp, long length)\\r\\n{\\r\\nconst unsigned char *q;\\r\\nX509 *ret;\\r\\nq = *pp;\\r\\nret = d2i_X509(a, pp, length);\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nlength -= *pp - q;\\r\\nif (!length)\\r\\nreturn ret;\\r\\nif (!d2i_X509_CERT_AUX(&ret->aux, pp, length))\\r\\ngoto err;\\r\\nreturn ret;\\r\\nerr:\\r\\nX509_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nint i2d_X509_AUX(X509 *a, unsigned char **pp)\\r\\n{\\r\\nint length;\\r\\nlength = i2d_X509(a, pp);\\r\\nif (a)\\r\\nlength += i2d_X509_CERT_AUX(a->aux, pp);\\r\\nreturn length;\\r\\n}\\r\\nint i2d_re_X509_tbs(X509 *x, unsigned char **pp)\\r\\n{\\r\\nx->cert_info->enc.modified = 1;\\r\\nreturn i2d_X509_CINF(x->cert_info, pp);\\r\\n}\\r\\nvoid X509_get0_signature(ASN1_BIT_STRING **psig, X509_ALGOR **palg,\\r\\nconst X509 *x)\\r\\n{\\r\\nif (psig)\\r\\n*psig = x->signature;\\r\\nif (palg)\\r\\n*palg = x->sig_alg;\\r\\n}\\r\\nint X509_get_signature_nid(const X509 *x)\\r\\n{\\r\\nreturn OBJ_obj2nid(x->sig_alg->algorithm);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_asid_c", "target": 0, "func": "int i2r_ASIdentifiers(const X509V3_EXT_METHOD *method,\\r\\nvoid *ext, BIO *out, int indent)\\r\\n{\\r\\nASIdentifiers *asid = ext;\\r\\nreturn (i2r_ASIdentifierChoice(out, asid->asnum, indent,\\r\\n\"Autonomous System Numbers\") &&\\r\\ni2r_ASIdentifierChoice(out, asid->rdi, indent,\\r\\n\"Routing Domain Identifiers\"));\\r\\n}\\r\\nstatic int ASIdOrRange_cmp(const ASIdOrRange *const *a_,\\r\\nconst ASIdOrRange *const *b_)\\r\\n{\\r\\nconst ASIdOrRange *a = *a_, *b = *b_;\\r\\nOPENSSL_assert((a->type == ASIdOrRange_id && a->u.id != NULL) ||\\r\\n(a->type == ASIdOrRange_range && a->u.range != NULL &&\\r\\na->u.range->min != NULL && a->u.range->max != NULL));\\r\\nOPENSSL_assert((b->type == ASIdOrRange_id && b->u.id != NULL) ||\\r\\n(b->type == ASIdOrRange_range && b->u.range != NULL &&\\r\\nb->u.range->min != NULL && b->u.range->max != NULL));\\r\\nif (a->type == ASIdOrRange_id && b->type == ASIdOrRange_id)\\r\\nreturn ASN1_INTEGER_cmp(a->u.id, b->u.id);\\r\\nif (a->type == ASIdOrRange_range && b->type == ASIdOrRange_range) {\\r\\nint r = ASN1_INTEGER_cmp(a->u.range->min, b->u.range->min);\\r\\nreturn r != 0 ? r : ASN1_INTEGER_cmp(a->u.range->max,\\r\\nb->u.range->max);\\r\\n}\\r\\nif (a->type == ASIdOrRange_id)\\r\\nreturn ASN1_INTEGER_cmp(a->u.id, b->u.range->min);\\r\\nelse\\r\\nreturn ASN1_INTEGER_cmp(a->u.range->min, b->u.id);\\r\\n}\\r\\nint v3_asid_add_inherit(ASIdentifiers *asid, int which)\\r\\n{\\r\\nASIdentifierChoice **choice;\\r\\nif (asid == NULL)\\r\\nreturn 0;\\r\\nswitch (which) {\\r\\ncase V3_ASID_ASNUM:\\r\\nchoice = &asid->asnum;\\r\\nbreak;\\r\\ncase V3_ASID_RDI:\\r\\nchoice = &asid->rdi;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nif (*choice == NULL) {\\r\\nif ((*choice = ASIdentifierChoice_new()) == NULL)\\r\\nreturn 0;\\r\\nOPENSSL_assert((*choice)->u.inherit == NULL);\\r\\nif (((*choice)->u.inherit = ASN1_NULL_new()) == NULL)\\r\\nreturn 0;\\r\\n(*choice)->type = ASIdentifierChoice_inherit;\\r\\n}\\r\\nreturn (*choice)->type == ASIdentifierChoice_inherit;\\r\\n}\\r\\nint v3_asid_add_id_or_range(ASIdentifiers *asid,\\r\\nint which, ASN1_INTEGER *min, ASN1_INTEGER *max)\\r\\n{\\r\\nASIdentifierChoice **choice;\\r\\nASIdOrRange *aor;\\r\\nif (asid == NULL)\\r\\nreturn 0;\\r\\nswitch (which) {\\r\\ncase V3_ASID_ASNUM:\\r\\nchoice = &asid->asnum;\\r\\nbreak;\\r\\ncase V3_ASID_RDI:\\r\\nchoice = &asid->rdi;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nif (*choice != NULL && (*choice)->type == ASIdentifierChoice_inherit)\\r\\nreturn 0;\\r\\nif (*choice == NULL) {\\r\\nif ((*choice = ASIdentifierChoice_new()) == NULL)\\r\\nreturn 0;\\r\\nOPENSSL_assert((*choice)->u.asIdsOrRanges == NULL);\\r\\n(*choice)->u.asIdsOrRanges = sk_ASIdOrRange_new(ASIdOrRange_cmp);\\r\\nif ((*choice)->u.asIdsOrRanges == NULL)\\r\\nreturn 0;\\r\\n(*choice)->type = ASIdentifierChoice_asIdsOrRanges;\\r\\n}\\r\\nif ((aor = ASIdOrRange_new()) == NULL)\\r\\nreturn 0;\\r\\nif (max == NULL) {\\r\\naor->type = ASIdOrRange_id;\\r\\naor->u.id = min;\\r\\n} else {\\r\\naor->type = ASIdOrRange_range;\\r\\nif ((aor->u.range = ASRange_new()) == NULL)\\r\\ngoto err;\\r\\nASN1_INTEGER_free(aor->u.range->min);\\r\\naor->u.range->min = min;\\r\\nASN1_INTEGER_free(aor->u.range->max);\\r\\naor->u.range->max = max;\\r\\n}\\r\\nif (!(sk_ASIdOrRange_push((*choice)->u.asIdsOrRanges, aor)))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nASIdOrRange_free(aor);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void extract_min_max(ASIdOrRange *aor,\\r\\nASN1_INTEGER **min, ASN1_INTEGER **max)\\r\\n{\\r\\nOPENSSL_assert(aor != NULL && min != NULL && max != NULL);\\r\\nswitch (aor->type) {\\r\\ncase ASIdOrRange_id:\\r\\n*min = aor->u.id;\\r\\n*max = aor->u.id;\\r\\nreturn;\\r\\ncase ASIdOrRange_range:\\r\\n*min = aor->u.range->min;\\r\\n*max = aor->u.range->max;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\nstatic int ASIdentifierChoice_is_canonical(ASIdentifierChoice *choice)\\r\\n{\\r\\nASN1_INTEGER *a_max_plus_one = NULL;\\r\\nBIGNUM *bn = NULL;\\r\\nint i, ret = 0;\\r\\nif (choice == NULL || choice->type == ASIdentifierChoice_inherit)\\r\\nreturn 1;\\r\\nif (choice->type != ASIdentifierChoice_asIdsOrRanges ||\\r\\nsk_ASIdOrRange_num(choice->u.asIdsOrRanges) == 0)\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_ASIdOrRange_num(choice->u.asIdsOrRanges) - 1; i++) {\\r\\nASIdOrRange *a = sk_ASIdOrRange_value(choice->u.asIdsOrRanges, i);\\r\\nASIdOrRange *b = sk_ASIdOrRange_value(choice->u.asIdsOrRanges, i + 1);\\r\\nASN1_INTEGER *a_min, *a_max, *b_min, *b_max;\\r\\nextract_min_max(a, &a_min, &a_max);\\r\\nextract_min_max(b, &b_min, &b_max);\\r\\nif (ASN1_INTEGER_cmp(a_min, b_min) >= 0 ||\\r\\nASN1_INTEGER_cmp(a_min, a_max) > 0 ||\\r\\nASN1_INTEGER_cmp(b_min, b_max) > 0)\\r\\ngoto done;\\r\\nif ((bn == NULL && (bn = BN_new()) == NULL) ||\\r\\nASN1_INTEGER_to_BN(a_max, bn) == NULL ||\\r\\n!BN_add_word(bn, 1) ||\\r\\n(a_max_plus_one =\\r\\nBN_to_ASN1_INTEGER(bn, a_max_plus_one)) == NULL) {\\r\\nX509V3err(X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto done;\\r\\n}\\r\\nif (ASN1_INTEGER_cmp(a_max_plus_one, b_min) >= 0)\\r\\ngoto done;\\r\\n}\\r\\ni = sk_ASIdOrRange_num(choice->u.asIdsOrRanges) - 1;\\r\\n{\\r\\nASIdOrRange *a = sk_ASIdOrRange_value(choice->u.asIdsOrRanges, i);\\r\\nASN1_INTEGER *a_min, *a_max;\\r\\nif (a != NULL && a->type == ASIdOrRange_range) {\\r\\nextract_min_max(a, &a_min, &a_max);\\r\\nif (ASN1_INTEGER_cmp(a_min, a_max) > 0)\\r\\ngoto done;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\ndone:\\r\\nASN1_INTEGER_free(a_max_plus_one);\\r\\nBN_free(bn);\\r\\nreturn ret;\\r\\n}\\r\\nint v3_asid_is_canonical(ASIdentifiers *asid)\\r\\n{\\r\\nreturn (asid == NULL ||\\r\\n(ASIdentifierChoice_is_canonical(asid->asnum) &&\\r\\nASIdentifierChoice_is_canonical(asid->rdi)));\\r\\n}\\r\\nstatic int ASIdentifierChoice_canonize(ASIdentifierChoice *choice)\\r\\n{\\r\\nASN1_INTEGER *a_max_plus_one = NULL;\\r\\nBIGNUM *bn = NULL;\\r\\nint i, ret = 0;\\r\\nif (choice == NULL || choice->type == ASIdentifierChoice_inherit)\\r\\nreturn 1;\\r\\nif (choice->type != ASIdentifierChoice_asIdsOrRanges ||\\r\\nsk_ASIdOrRange_num(choice->u.asIdsOrRanges) == 0) {\\r\\nX509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,\\r\\nX509V3_R_EXTENSION_VALUE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nsk_ASIdOrRange_sort(choice->u.asIdsOrRanges);\\r\\nfor (i = 0; i < sk_ASIdOrRange_num(choice->u.asIdsOrRanges) - 1; i++) {\\r\\nASIdOrRange *a = sk_ASIdOrRange_value(choice->u.asIdsOrRanges, i);\\r\\nASIdOrRange *b = sk_ASIdOrRange_value(choice->u.asIdsOrRanges, i + 1);\\r\\nASN1_INTEGER *a_min, *a_max, *b_min, *b_max;\\r\\nextract_min_max(a, &a_min, &a_max);\\r\\nextract_min_max(b, &b_min, &b_max);\\r\\nOPENSSL_assert(ASN1_INTEGER_cmp(a_min, b_min) <= 0);\\r\\nif (ASN1_INTEGER_cmp(a_min, a_max) > 0 ||\\r\\nASN1_INTEGER_cmp(b_min, b_max) > 0)\\r\\ngoto done;\\r\\nif (ASN1_INTEGER_cmp(a_max, b_min) >= 0) {\\r\\nX509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,\\r\\nX509V3_R_EXTENSION_VALUE_ERROR);\\r\\ngoto done;\\r\\n}\\r\\nif ((bn == NULL && (bn = BN_new()) == NULL) ||\\r\\nASN1_INTEGER_to_BN(a_max, bn) == NULL ||\\r\\n!BN_add_word(bn, 1) ||\\r\\n(a_max_plus_one =\\r\\nBN_to_ASN1_INTEGER(bn, a_max_plus_one)) == NULL) {\\r\\nX509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto done;\\r\\n}\\r\\nif (ASN1_INTEGER_cmp(a_max_plus_one, b_min) == 0) {\\r\\nASRange *r;\\r\\nswitch (a->type) {\\r\\ncase ASIdOrRange_id:\\r\\nif ((r = OPENSSL_malloc(sizeof(ASRange))) == NULL) {\\r\\nX509V3err(X509V3_F_ASIDENTIFIERCHOICE_CANONIZE,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto done;\\r\\n}\\r\\nr->min = a_min;\\r\\nr->max = b_max;\\r\\na->type = ASIdOrRange_range;\\r\\na->u.range = r;\\r\\nbreak;\\r\\ncase ASIdOrRange_range:\\r\\nASN1_INTEGER_free(a->u.range->max);\\r\\na->u.range->max = b_max;\\r\\nbreak;\\r\\n}\\r\\nswitch (b->type) {\\r\\ncase ASIdOrRange_id:\\r\\nb->u.id = NULL;\\r\\nbreak;\\r\\ncase ASIdOrRange_range:\\r\\nb->u.range->max = NULL;\\r\\nbreak;\\r\\n}\\r\\nASIdOrRange_free(b);\\r\\n(void)sk_ASIdOrRange_delete(choice->u.asIdsOrRanges, i + 1);\\r\\ni--;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\ni = sk_ASIdOrRange_num(choice->u.asIdsOrRanges) - 1;\\r\\n{\\r\\nASIdOrRange *a = sk_ASIdOrRange_value(choice->u.asIdsOrRanges, i);\\r\\nASN1_INTEGER *a_min, *a_max;\\r\\nif (a != NULL && a->type == ASIdOrRange_range) {\\r\\nextract_min_max(a, &a_min, &a_max);\\r\\nif (ASN1_INTEGER_cmp(a_min, a_max) > 0)\\r\\ngoto done;\\r\\n}\\r\\n}\\r\\nOPENSSL_assert(ASIdentifierChoice_is_canonical(choice));\\r\\nret = 1;\\r\\ndone:\\r\\nASN1_INTEGER_free(a_max_plus_one);\\r\\nBN_free(bn);\\r\\nreturn ret;\\r\\n}\\r\\nint v3_asid_canonize(ASIdentifiers *asid)\\r\\n{\\r\\nreturn (asid == NULL ||\\r\\n(ASIdentifierChoice_canonize(asid->asnum) &&\\r\\nASIdentifierChoice_canonize(asid->rdi)));\\r\\n}\\r\\nint v3_asid_inherits(ASIdentifiers *asid)\\r\\n{\\r\\nreturn (asid != NULL &&\\r\\n((asid->asnum != NULL &&\\r\\nasid->asnum->type == ASIdentifierChoice_inherit) ||\\r\\n(asid->rdi != NULL &&\\r\\nasid->rdi->type == ASIdentifierChoice_inherit)));\\r\\n}\\r\\nstatic int asid_contains(ASIdOrRanges *parent, ASIdOrRanges *child)\\r\\n{\\r\\nASN1_INTEGER *p_min, *p_max, *c_min, *c_max;\\r\\nint p, c;\\r\\nif (child == NULL || parent == child)\\r\\nreturn 1;\\r\\nif (parent == NULL)\\r\\nreturn 0;\\r\\np = 0;\\r\\nfor (c = 0; c < sk_ASIdOrRange_num(child); c++) {\\r\\nextract_min_max(sk_ASIdOrRange_value(child, c), &c_min, &c_max);\\r\\nfor (;; p++) {\\r\\nif (p >= sk_ASIdOrRange_num(parent))\\r\\nreturn 0;\\r\\nextract_min_max(sk_ASIdOrRange_value(parent, p), &p_min, &p_max);\\r\\nif (ASN1_INTEGER_cmp(p_max, c_max) < 0)\\r\\ncontinue;\\r\\nif (ASN1_INTEGER_cmp(p_min, c_min) > 0)\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint v3_asid_subset(ASIdentifiers *a, ASIdentifiers *b)\\r\\n{\\r\\nreturn (a == NULL ||\\r\\na == b ||\\r\\n(b != NULL &&\\r\\n!v3_asid_inherits(a) &&\\r\\n!v3_asid_inherits(b) &&\\r\\nasid_contains(b->asnum->u.asIdsOrRanges,\\r\\na->asnum->u.asIdsOrRanges) &&\\r\\nasid_contains(b->rdi->u.asIdsOrRanges,\\r\\na->rdi->u.asIdsOrRanges)));\\r\\n}\\r\\nint v3_asid_validate_path(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn v3_asid_validate_path_internal(ctx, ctx->chain, NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_obj_xref_c", "target": 0, "func": "static int sig_cmp(const nid_triple *a, const nid_triple *b)\\r\\n{\\r\\nreturn a->sign_id - b->sign_id;\\r\\n}\\r\\nstatic int sig_sk_cmp(const nid_triple *const *a, const nid_triple *const *b)\\r\\n{\\r\\nreturn (*a)->sign_id - (*b)->sign_id;\\r\\n}\\r\\nstatic int sigx_cmp(const nid_triple *const *a, const nid_triple *const *b)\\r\\n{\\r\\nint ret;\\r\\nret = (*a)->hash_id - (*b)->hash_id;\\r\\nif (ret)\\r\\nreturn ret;\\r\\nreturn (*a)->pkey_id - (*b)->pkey_id;\\r\\n}\\r\\nint OBJ_find_sigid_algs(int signid, int *pdig_nid, int *ppkey_nid)\\r\\n{\\r\\nnid_triple tmp;\\r\\nconst nid_triple *rv = NULL;\\r\\ntmp.sign_id = signid;\\r\\nif (sig_app) {\\r\\nint idx = sk_nid_triple_find(sig_app, &tmp);\\r\\nif (idx >= 0)\\r\\nrv = sk_nid_triple_value(sig_app, idx);\\r\\n}\\r\\n#ifndef OBJ_XREF_TEST2\\r\\nif (rv == NULL) {\\r\\nrv = OBJ_bsearch_sig(&tmp, sigoid_srt,\\r\\nsizeof(sigoid_srt) / sizeof(nid_triple));\\r\\n}\\r\\n#endif\\r\\nif (rv == NULL)\\r\\nreturn 0;\\r\\nif (pdig_nid)\\r\\n*pdig_nid = rv->hash_id;\\r\\nif (ppkey_nid)\\r\\n*ppkey_nid = rv->pkey_id;\\r\\nreturn 1;\\r\\n}\\r\\nint OBJ_find_sigid_by_algs(int *psignid, int dig_nid, int pkey_nid)\\r\\n{\\r\\nnid_triple tmp;\\r\\nconst nid_triple *t = &tmp;\\r\\nconst nid_triple **rv = NULL;\\r\\ntmp.hash_id = dig_nid;\\r\\ntmp.pkey_id = pkey_nid;\\r\\nif (sigx_app) {\\r\\nint idx = sk_nid_triple_find(sigx_app, &tmp);\\r\\nif (idx >= 0) {\\r\\nt = sk_nid_triple_value(sigx_app, idx);\\r\\nrv = &t;\\r\\n}\\r\\n}\\r\\n#ifndef OBJ_XREF_TEST2\\r\\nif (rv == NULL) {\\r\\nrv = OBJ_bsearch_sigx(&t, sigoid_srt_xref,\\r\\nsizeof(sigoid_srt_xref) / sizeof(nid_triple *)\\r\\n);\\r\\n}\\r\\n#endif\\r\\nif (rv == NULL)\\r\\nreturn 0;\\r\\nif (psignid)\\r\\n*psignid = (*rv)->sign_id;\\r\\nreturn 1;\\r\\n}\\r\\nint OBJ_add_sigid(int signid, int dig_id, int pkey_id)\\r\\n{\\r\\nnid_triple *ntr;\\r\\nif (!sig_app)\\r\\nsig_app = sk_nid_triple_new(sig_sk_cmp);\\r\\nif (!sig_app)\\r\\nreturn 0;\\r\\nif (!sigx_app)\\r\\nsigx_app = sk_nid_triple_new(sigx_cmp);\\r\\nif (!sigx_app)\\r\\nreturn 0;\\r\\nntr = OPENSSL_malloc(sizeof(int) * 3);\\r\\nif (!ntr)\\r\\nreturn 0;\\r\\nntr->sign_id = signid;\\r\\nntr->hash_id = dig_id;\\r\\nntr->pkey_id = pkey_id;\\r\\nif (!sk_nid_triple_push(sig_app, ntr)) {\\r\\nOPENSSL_free(ntr);\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_nid_triple_push(sigx_app, ntr))\\r\\nreturn 0;\\r\\nsk_nid_triple_sort(sig_app);\\r\\nsk_nid_triple_sort(sigx_app);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void sid_free(nid_triple *tt)\\r\\n{\\r\\nOPENSSL_free(tt);\\r\\n}\\r\\nvoid OBJ_sigid_free(void)\\r\\n{\\r\\nif (sig_app) {\\r\\nsk_nid_triple_pop_free(sig_app, sid_free);\\r\\nsig_app = NULL;\\r\\n}\\r\\nif (sigx_app) {\\r\\nsk_nid_triple_free(sigx_app);\\r\\nsigx_app = NULL;\\r\\n}\\r\\n}\\r\\nmain()\\r\\n{\\r\\nint n1, n2, n3;\\r\\nint i, rv;\\r\\n# ifdef OBJ_XREF_TEST2\\r\\nfor (i = 0; i < sizeof(sigoid_srt) / sizeof(nid_triple); i++) {\\r\\nOBJ_add_sigid(sigoid_srt[i][0], sigoid_srt[i][1], sigoid_srt[i][2]);\\r\\n}\\r\\n# endif\\r\\nfor (i = 0; i < sizeof(sigoid_srt) / sizeof(nid_triple); i++) {\\r\\nn1 = sigoid_srt[i][0];\\r\\nrv = OBJ_find_sigid_algs(n1, &n2, &n3);\\r\\nprintf(\"Forward: %d, %s %s %s\\n\", rv,\\r\\nOBJ_nid2ln(n1), OBJ_nid2ln(n2), OBJ_nid2ln(n3));\\r\\nn1 = 0;\\r\\nrv = OBJ_find_sigid_by_algs(&n1, n2, n3);\\r\\nprintf(\"Reverse: %d, %s %s %s\\n\", rv,\\r\\nOBJ_nid2ln(n1), OBJ_nid2ln(n2), OBJ_nid2ln(n3));\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dso_dlfcn_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_dlfcn(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nDSO_METHOD *DSO_METHOD_dlfcn(void)\\r\\n{\\r\\nreturn (&dso_meth_dlfcn);\\r\\n}\\r\\nstatic int dlfcn_load(DSO *dso)\\r\\n{\\r\\nvoid *ptr = NULL;\\r\\nchar *filename = DSO_convert_filename(dso, NULL);\\r\\nint flags = DLOPEN_FLAG;\\r\\nif (filename == NULL) {\\r\\nDSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\n# ifdef RTLD_GLOBAL\\r\\nif (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)\\r\\nflags |= RTLD_GLOBAL;\\r\\n# endif\\r\\nptr = dlopen(filename, flags);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);\\r\\nERR_add_error_data(4, \"filename(\", filename, \"): \", dlerror());\\r\\ngoto err;\\r\\n}\\r\\nif (!sk_void_push(dso->meth_data, (char *)ptr)) {\\r\\nDSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndso->loaded_filename = filename;\\r\\nreturn (1);\\r\\nerr:\\r\\nif (filename != NULL)\\r\\nOPENSSL_free(filename);\\r\\nif (ptr != NULL)\\r\\ndlclose(ptr);\\r\\nreturn (0);\\r\\n}\\r\\nstatic int dlfcn_unload(DSO *dso)\\r\\n{\\r\\nvoid *ptr;\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (sk_void_num(dso->meth_data) < 1)\\r\\nreturn (1);\\r\\nptr = sk_void_pop(dso->meth_data);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);\\r\\nsk_void_push(dso->meth_data, ptr);\\r\\nreturn (0);\\r\\n}\\r\\ndlclose(ptr);\\r\\nreturn (1);\\r\\n}\\r\\nstatic void *dlfcn_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nvoid *ptr, *sym;\\r\\nif ((dso == NULL) || (symname == NULL)) {\\r\\nDSOerr(DSO_F_DLFCN_BIND_VAR, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (sk_void_num(dso->meth_data) < 1) {\\r\\nDSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_STACK_ERROR);\\r\\nreturn (NULL);\\r\\n}\\r\\nptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_NULL_HANDLE);\\r\\nreturn (NULL);\\r\\n}\\r\\nsym = dlsym(ptr, symname);\\r\\nif (sym == NULL) {\\r\\nDSOerr(DSO_F_DLFCN_BIND_VAR, DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (sym);\\r\\n}\\r\\nstatic DSO_FUNC_TYPE dlfcn_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nvoid *ptr;\\r\\nunion {\\r\\nDSO_FUNC_TYPE sym;\\r\\nvoid *dlret;\\r\\n} u;\\r\\nif ((dso == NULL) || (symname == NULL)) {\\r\\nDSOerr(DSO_F_DLFCN_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (sk_void_num(dso->meth_data) < 1) {\\r\\nDSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_STACK_ERROR);\\r\\nreturn (NULL);\\r\\n}\\r\\nptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_NULL_HANDLE);\\r\\nreturn (NULL);\\r\\n}\\r\\nu.dlret = dlsym(ptr, symname);\\r\\nif (u.dlret == NULL) {\\r\\nDSOerr(DSO_F_DLFCN_BIND_FUNC, DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(4, \"symname(\", symname, \"): \", dlerror());\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn u.sym;\\r\\n}\\r\\nstatic char *dlfcn_merger(DSO *dso, const char *filespec1,\\r\\nconst char *filespec2)\\r\\n{\\r\\nchar *merged;\\r\\nif (!filespec1 && !filespec2) {\\r\\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\\r\\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\\r\\nif (!merged) {\\r\\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nstrcpy(merged, filespec1);\\r\\n}\\r\\nelse if (!filespec1) {\\r\\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\\r\\nif (!merged) {\\r\\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\n} else\\r\\n{\\r\\nint spec2len, len;\\r\\nspec2len = strlen(filespec2);\\r\\nlen = spec2len + (filespec1 ? strlen(filespec1) : 0);\\r\\nif (filespec2 && filespec2[spec2len - 1] == '/') {\\r\\nspec2len--;\\r\\nlen--;\\r\\n}\\r\\nmerged = OPENSSL_malloc(len + 2);\\r\\nif (!merged) {\\r\\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\nmerged[spec2len] = '/';\\r\\nstrcpy(&merged[spec2len + 1], filespec1);\\r\\n}\\r\\nreturn (merged);\\r\\n}\\r\\nstatic char *dlfcn_name_converter(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *translated;\\r\\nint len, rsize, transform;\\r\\nlen = strlen(filename);\\r\\nrsize = len + 1;\\r\\ntransform = (strstr(filename, \"/\") == NULL);\\r\\nif (transform) {\\r\\nrsize += DSO_extlen;\\r\\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\\r\\nrsize += 3;\\r\\n}\\r\\ntranslated = OPENSSL_malloc(rsize);\\r\\nif (translated == NULL) {\\r\\nDSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (transform) {\\r\\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\\r\\nsprintf(translated, \"lib%s\" DSO_ext, filename);\\r\\nelse\\r\\nsprintf(translated, \"%s\" DSO_ext, filename);\\r\\n} else\\r\\nsprintf(translated, \"%s\", filename);\\r\\nreturn (translated);\\r\\n}\\r\\nstatic int dladdr(void *address, Dl_info *dl)\\r\\n{\\r\\nvoid *v;\\r\\nv = _rld_new_interface(_RLD_DLADDR, address, dl);\\r\\nreturn (int)v;\\r\\n}\\r\\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz)\\r\\n{\\r\\n# ifdef HAVE_DLINFO\\r\\nDl_info dli;\\r\\nint len;\\r\\nif (addr == NULL) {\\r\\nunion {\\r\\nint (*f) (void *, char *, int);\\r\\nvoid *p;\\r\\n} t = {\\r\\ndlfcn_pathbyaddr\\r\\n};\\r\\naddr = t.p;\\r\\n}\\r\\nif (dladdr(addr, &dli)) {\\r\\nlen = (int)strlen(dli.dli_fname);\\r\\nif (sz <= 0)\\r\\nreturn len + 1;\\r\\nif (len >= sz)\\r\\nlen = sz - 1;\\r\\nmemcpy(path, dli.dli_fname, len);\\r\\npath[len++] = 0;\\r\\nreturn len;\\r\\n}\\r\\nERR_add_error_data(2, \"dlfcn_pathbyaddr(): \", dlerror());\\r\\n# endif\\r\\nreturn -1;\\r\\n}\\r\\nstatic void *dlfcn_globallookup(const char *name)\\r\\n{\\r\\nvoid *ret = NULL, *handle = dlopen(NULL, RTLD_LAZY);\\r\\nif (handle) {\\r\\nret = dlsym(handle, name);\\r\\ndlclose(handle);\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_md2_one_c", "target": 0, "func": "unsigned char *MD2(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nMD2_CTX c;\\r\\nstatic unsigned char m[MD2_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nif (!MD2_Init(&c))\\r\\nreturn NULL;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nMD2_Update(&c, d, n);\\r\\n#else\\r\\n{\\r\\nchar temp[1024];\\r\\nunsigned long chunk;\\r\\nwhile (n > 0) {\\r\\nchunk = (n > sizeof(temp)) ? sizeof(temp) : n;\\r\\nebcdic2ascii(temp, d, chunk);\\r\\nMD2_Update(&c, temp, chunk);\\r\\nn -= chunk;\\r\\nd += chunk;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nMD2_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_md5_dgst_c", "target": 0, "func": "void md5_block_data_order(MD5_CTX *c, const void *data_, size_t num)\\r\\n{\\r\\nconst unsigned char *data = data_;\\r\\nregister unsigned MD32_REG_T A, B, C, D, l;\\r\\n# ifndef MD32_XARRAY\\r\\nunsigned MD32_REG_T XX0, XX1, XX2, XX3, XX4, XX5, XX6, XX7,\\r\\nXX8, XX9, XX10, XX11, XX12, XX13, XX14, XX15;\\r\\n# define X(i) XX##i\\r\\n# else\\r\\nMD5_LONG XX[MD5_LBLOCK];\\r\\n# define X(i) XX[i]\\r\\n# endif\\r\\nA = c->A;\\r\\nB = c->B;\\r\\nC = c->C;\\r\\nD = c->D;\\r\\nfor (; num--;) {\\r\\nHOST_c2l(data, l);\\r\\nX(0) = l;\\r\\nHOST_c2l(data, l);\\r\\nX(1) = l;\\r\\nR0(A, B, C, D, X(0), 7, 0xd76aa478L);\\r\\nHOST_c2l(data, l);\\r\\nX(2) = l;\\r\\nR0(D, A, B, C, X(1), 12, 0xe8c7b756L);\\r\\nHOST_c2l(data, l);\\r\\nX(3) = l;\\r\\nR0(C, D, A, B, X(2), 17, 0x242070dbL);\\r\\nHOST_c2l(data, l);\\r\\nX(4) = l;\\r\\nR0(B, C, D, A, X(3), 22, 0xc1bdceeeL);\\r\\nHOST_c2l(data, l);\\r\\nX(5) = l;\\r\\nR0(A, B, C, D, X(4), 7, 0xf57c0fafL);\\r\\nHOST_c2l(data, l);\\r\\nX(6) = l;\\r\\nR0(D, A, B, C, X(5), 12, 0x4787c62aL);\\r\\nHOST_c2l(data, l);\\r\\nX(7) = l;\\r\\nR0(C, D, A, B, X(6), 17, 0xa8304613L);\\r\\nHOST_c2l(data, l);\\r\\nX(8) = l;\\r\\nR0(B, C, D, A, X(7), 22, 0xfd469501L);\\r\\nHOST_c2l(data, l);\\r\\nX(9) = l;\\r\\nR0(A, B, C, D, X(8), 7, 0x698098d8L);\\r\\nHOST_c2l(data, l);\\r\\nX(10) = l;\\r\\nR0(D, A, B, C, X(9), 12, 0x8b44f7afL);\\r\\nHOST_c2l(data, l);\\r\\nX(11) = l;\\r\\nR0(C, D, A, B, X(10), 17, 0xffff5bb1L);\\r\\nHOST_c2l(data, l);\\r\\nX(12) = l;\\r\\nR0(B, C, D, A, X(11), 22, 0x895cd7beL);\\r\\nHOST_c2l(data, l);\\r\\nX(13) = l;\\r\\nR0(A, B, C, D, X(12), 7, 0x6b901122L);\\r\\nHOST_c2l(data, l);\\r\\nX(14) = l;\\r\\nR0(D, A, B, C, X(13), 12, 0xfd987193L);\\r\\nHOST_c2l(data, l);\\r\\nX(15) = l;\\r\\nR0(C, D, A, B, X(14), 17, 0xa679438eL);\\r\\nR0(B, C, D, A, X(15), 22, 0x49b40821L);\\r\\nR1(A, B, C, D, X(1), 5, 0xf61e2562L);\\r\\nR1(D, A, B, C, X(6), 9, 0xc040b340L);\\r\\nR1(C, D, A, B, X(11), 14, 0x265e5a51L);\\r\\nR1(B, C, D, A, X(0), 20, 0xe9b6c7aaL);\\r\\nR1(A, B, C, D, X(5), 5, 0xd62f105dL);\\r\\nR1(D, A, B, C, X(10), 9, 0x02441453L);\\r\\nR1(C, D, A, B, X(15), 14, 0xd8a1e681L);\\r\\nR1(B, C, D, A, X(4), 20, 0xe7d3fbc8L);\\r\\nR1(A, B, C, D, X(9), 5, 0x21e1cde6L);\\r\\nR1(D, A, B, C, X(14), 9, 0xc33707d6L);\\r\\nR1(C, D, A, B, X(3), 14, 0xf4d50d87L);\\r\\nR1(B, C, D, A, X(8), 20, 0x455a14edL);\\r\\nR1(A, B, C, D, X(13), 5, 0xa9e3e905L);\\r\\nR1(D, A, B, C, X(2), 9, 0xfcefa3f8L);\\r\\nR1(C, D, A, B, X(7), 14, 0x676f02d9L);\\r\\nR1(B, C, D, A, X(12), 20, 0x8d2a4c8aL);\\r\\nR2(A, B, C, D, X(5), 4, 0xfffa3942L);\\r\\nR2(D, A, B, C, X(8), 11, 0x8771f681L);\\r\\nR2(C, D, A, B, X(11), 16, 0x6d9d6122L);\\r\\nR2(B, C, D, A, X(14), 23, 0xfde5380cL);\\r\\nR2(A, B, C, D, X(1), 4, 0xa4beea44L);\\r\\nR2(D, A, B, C, X(4), 11, 0x4bdecfa9L);\\r\\nR2(C, D, A, B, X(7), 16, 0xf6bb4b60L);\\r\\nR2(B, C, D, A, X(10), 23, 0xbebfbc70L);\\r\\nR2(A, B, C, D, X(13), 4, 0x289b7ec6L);\\r\\nR2(D, A, B, C, X(0), 11, 0xeaa127faL);\\r\\nR2(C, D, A, B, X(3), 16, 0xd4ef3085L);\\r\\nR2(B, C, D, A, X(6), 23, 0x04881d05L);\\r\\nR2(A, B, C, D, X(9), 4, 0xd9d4d039L);\\r\\nR2(D, A, B, C, X(12), 11, 0xe6db99e5L);\\r\\nR2(C, D, A, B, X(15), 16, 0x1fa27cf8L);\\r\\nR2(B, C, D, A, X(2), 23, 0xc4ac5665L);\\r\\nR3(A, B, C, D, X(0), 6, 0xf4292244L);\\r\\nR3(D, A, B, C, X(7), 10, 0x432aff97L);\\r\\nR3(C, D, A, B, X(14), 15, 0xab9423a7L);\\r\\nR3(B, C, D, A, X(5), 21, 0xfc93a039L);\\r\\nR3(A, B, C, D, X(12), 6, 0x655b59c3L);\\r\\nR3(D, A, B, C, X(3), 10, 0x8f0ccc92L);\\r\\nR3(C, D, A, B, X(10), 15, 0xffeff47dL);\\r\\nR3(B, C, D, A, X(1), 21, 0x85845dd1L);\\r\\nR3(A, B, C, D, X(8), 6, 0x6fa87e4fL);\\r\\nR3(D, A, B, C, X(15), 10, 0xfe2ce6e0L);\\r\\nR3(C, D, A, B, X(6), 15, 0xa3014314L);\\r\\nR3(B, C, D, A, X(13), 21, 0x4e0811a1L);\\r\\nR3(A, B, C, D, X(4), 6, 0xf7537e82L);\\r\\nR3(D, A, B, C, X(11), 10, 0xbd3af235L);\\r\\nR3(C, D, A, B, X(2), 15, 0x2ad7d2bbL);\\r\\nR3(B, C, D, A, X(9), 21, 0xeb86d391L);\\r\\nA = c->A += A;\\r\\nB = c->B += B;\\r\\nC = c->C += C;\\r\\nD = c->D += D;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_const_c", "target": 0, "func": "BIGNUM *get_rfc2409_prime_768(BIGNUM *bn)\\r\\n{\\r\\nstatic const unsigned char RFC2409_PRIME_768[] = {\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\\r\\n0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\\r\\n0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\\r\\n0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\\r\\n0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\\r\\n0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\\r\\n0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\\r\\n0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\\r\\n0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\\r\\n0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x3A, 0x36, 0x20,\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n};\\r\\nreturn BN_bin2bn(RFC2409_PRIME_768, sizeof(RFC2409_PRIME_768), bn);\\r\\n}\\r\\nBIGNUM *get_rfc2409_prime_1024(BIGNUM *bn)\\r\\n{\\r\\nstatic const unsigned char RFC2409_PRIME_1024[] = {\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\\r\\n0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\\r\\n0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\\r\\n0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\\r\\n0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\\r\\n0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\\r\\n0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\\r\\n0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\\r\\n0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\\r\\n0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\\r\\n0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\\r\\n0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\\r\\n0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\\r\\n0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81,\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n};\\r\\nreturn BN_bin2bn(RFC2409_PRIME_1024, sizeof(RFC2409_PRIME_1024), bn);\\r\\n}\\r\\nBIGNUM *get_rfc3526_prime_1536(BIGNUM *bn)\\r\\n{\\r\\nstatic const unsigned char RFC3526_PRIME_1536[] = {\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\\r\\n0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\\r\\n0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\\r\\n0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\\r\\n0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\\r\\n0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\\r\\n0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\\r\\n0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\\r\\n0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\\r\\n0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\\r\\n0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\\r\\n0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\\r\\n0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\\r\\n0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\\r\\n0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\\r\\n0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\\r\\n0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\\r\\n0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\\r\\n0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\\r\\n0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\\r\\n0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\\r\\n0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x23, 0x73, 0x27,\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n};\\r\\nreturn BN_bin2bn(RFC3526_PRIME_1536, sizeof(RFC3526_PRIME_1536), bn);\\r\\n}\\r\\nBIGNUM *get_rfc3526_prime_2048(BIGNUM *bn)\\r\\n{\\r\\nstatic const unsigned char RFC3526_PRIME_2048[] = {\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\\r\\n0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\\r\\n0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\\r\\n0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\\r\\n0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\\r\\n0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\\r\\n0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\\r\\n0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\\r\\n0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\\r\\n0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\\r\\n0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\\r\\n0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\\r\\n0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\\r\\n0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\\r\\n0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\\r\\n0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\\r\\n0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\\r\\n0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\\r\\n0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\\r\\n0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\\r\\n0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\\r\\n0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\\r\\n0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\\r\\n0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\\r\\n0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\\r\\n0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\\r\\n0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\\r\\n0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\\r\\n0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\\r\\n0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68,\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n};\\r\\nreturn BN_bin2bn(RFC3526_PRIME_2048, sizeof(RFC3526_PRIME_2048), bn);\\r\\n}\\r\\nBIGNUM *get_rfc3526_prime_3072(BIGNUM *bn)\\r\\n{\\r\\nstatic const unsigned char RFC3526_PRIME_3072[] = {\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\\r\\n0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\\r\\n0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\\r\\n0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\\r\\n0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\\r\\n0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\\r\\n0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\\r\\n0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\\r\\n0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\\r\\n0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\\r\\n0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\\r\\n0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\\r\\n0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\\r\\n0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\\r\\n0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\\r\\n0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\\r\\n0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\\r\\n0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\\r\\n0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\\r\\n0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\\r\\n0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\\r\\n0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\\r\\n0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\\r\\n0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\\r\\n0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\\r\\n0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\\r\\n0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\\r\\n0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\\r\\n0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\\r\\n0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D,\\r\\n0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\\r\\n0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64,\\r\\n0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\\r\\n0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D,\\r\\n0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\\r\\n0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7,\\r\\n0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\\r\\n0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B,\\r\\n0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\\r\\n0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64,\\r\\n0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\\r\\n0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C,\\r\\n0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\\r\\n0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31,\\r\\n0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\\r\\n0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x3A, 0xD2, 0xCA,\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n};\\r\\nreturn BN_bin2bn(RFC3526_PRIME_3072, sizeof(RFC3526_PRIME_3072), bn);\\r\\n}\\r\\nBIGNUM *get_rfc3526_prime_4096(BIGNUM *bn)\\r\\n{\\r\\nstatic const unsigned char RFC3526_PRIME_4096[] = {\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\\r\\n0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\\r\\n0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\\r\\n0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\\r\\n0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\\r\\n0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\\r\\n0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\\r\\n0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\\r\\n0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\\r\\n0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\\r\\n0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\\r\\n0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\\r\\n0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\\r\\n0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\\r\\n0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\\r\\n0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\\r\\n0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\\r\\n0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\\r\\n0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\\r\\n0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\\r\\n0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\\r\\n0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\\r\\n0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\\r\\n0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\\r\\n0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\\r\\n0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\\r\\n0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\\r\\n0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\\r\\n0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\\r\\n0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D,\\r\\n0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\\r\\n0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64,\\r\\n0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\\r\\n0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D,\\r\\n0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\\r\\n0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7,\\r\\n0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\\r\\n0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B,\\r\\n0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\\r\\n0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64,\\r\\n0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\\r\\n0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C,\\r\\n0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\\r\\n0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31,\\r\\n0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\\r\\n0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01,\\r\\n0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,\\r\\n0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26,\\r\\n0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,\\r\\n0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA,\\r\\n0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,\\r\\n0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9,\\r\\n0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,\\r\\n0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D,\\r\\n0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,\\r\\n0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED,\\r\\n0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,\\r\\n0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C,\\r\\n0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,\\r\\n0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1,\\r\\n0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,\\r\\n0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x06, 0x31, 0x99,\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n};\\r\\nreturn BN_bin2bn(RFC3526_PRIME_4096, sizeof(RFC3526_PRIME_4096), bn);\\r\\n}\\r\\nBIGNUM *get_rfc3526_prime_6144(BIGNUM *bn)\\r\\n{\\r\\nstatic const unsigned char RFC3526_PRIME_6144[] = {\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\\r\\n0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\\r\\n0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\\r\\n0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\\r\\n0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\\r\\n0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\\r\\n0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\\r\\n0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\\r\\n0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\\r\\n0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\\r\\n0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\\r\\n0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\\r\\n0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\\r\\n0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\\r\\n0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\\r\\n0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\\r\\n0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\\r\\n0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\\r\\n0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\\r\\n0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\\r\\n0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\\r\\n0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\\r\\n0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\\r\\n0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\\r\\n0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\\r\\n0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\\r\\n0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\\r\\n0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\\r\\n0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\\r\\n0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D,\\r\\n0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\\r\\n0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64,\\r\\n0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\\r\\n0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D,\\r\\n0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\\r\\n0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7,\\r\\n0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\\r\\n0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B,\\r\\n0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\\r\\n0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64,\\r\\n0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\\r\\n0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C,\\r\\n0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\\r\\n0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31,\\r\\n0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\\r\\n0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01,\\r\\n0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,\\r\\n0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26,\\r\\n0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,\\r\\n0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA,\\r\\n0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,\\r\\n0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9,\\r\\n0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,\\r\\n0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D,\\r\\n0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,\\r\\n0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED,\\r\\n0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,\\r\\n0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C,\\r\\n0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,\\r\\n0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1,\\r\\n0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,\\r\\n0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x02, 0x84, 0x92,\\r\\n0x36, 0xC3, 0xFA, 0xB4, 0xD2, 0x7C, 0x70, 0x26,\\r\\n0xC1, 0xD4, 0xDC, 0xB2, 0x60, 0x26, 0x46, 0xDE,\\r\\n0xC9, 0x75, 0x1E, 0x76, 0x3D, 0xBA, 0x37, 0xBD,\\r\\n0xF8, 0xFF, 0x94, 0x06, 0xAD, 0x9E, 0x53, 0x0E,\\r\\n0xE5, 0xDB, 0x38, 0x2F, 0x41, 0x30, 0x01, 0xAE,\\r\\n0xB0, 0x6A, 0x53, 0xED, 0x90, 0x27, 0xD8, 0x31,\\r\\n0x17, 0x97, 0x27, 0xB0, 0x86, 0x5A, 0x89, 0x18,\\r\\n0xDA, 0x3E, 0xDB, 0xEB, 0xCF, 0x9B, 0x14, 0xED,\\r\\n0x44, 0xCE, 0x6C, 0xBA, 0xCE, 0xD4, 0xBB, 0x1B,\\r\\n0xDB, 0x7F, 0x14, 0x47, 0xE6, 0xCC, 0x25, 0x4B,\\r\\n0x33, 0x20, 0x51, 0x51, 0x2B, 0xD7, 0xAF, 0x42,\\r\\n0x6F, 0xB8, 0xF4, 0x01, 0x37, 0x8C, 0xD2, 0xBF,\\r\\n0x59, 0x83, 0xCA, 0x01, 0xC6, 0x4B, 0x92, 0xEC,\\r\\n0xF0, 0x32, 0xEA, 0x15, 0xD1, 0x72, 0x1D, 0x03,\\r\\n0xF4, 0x82, 0xD7, 0xCE, 0x6E, 0x74, 0xFE, 0xF6,\\r\\n0xD5, 0x5E, 0x70, 0x2F, 0x46, 0x98, 0x0C, 0x82,\\r\\n0xB5, 0xA8, 0x40, 0x31, 0x90, 0x0B, 0x1C, 0x9E,\\r\\n0x59, 0xE7, 0xC9, 0x7F, 0xBE, 0xC7, 0xE8, 0xF3,\\r\\n0x23, 0xA9, 0x7A, 0x7E, 0x36, 0xCC, 0x88, 0xBE,\\r\\n0x0F, 0x1D, 0x45, 0xB7, 0xFF, 0x58, 0x5A, 0xC5,\\r\\n0x4B, 0xD4, 0x07, 0xB2, 0x2B, 0x41, 0x54, 0xAA,\\r\\n0xCC, 0x8F, 0x6D, 0x7E, 0xBF, 0x48, 0xE1, 0xD8,\\r\\n0x14, 0xCC, 0x5E, 0xD2, 0x0F, 0x80, 0x37, 0xE0,\\r\\n0xA7, 0x97, 0x15, 0xEE, 0xF2, 0x9B, 0xE3, 0x28,\\r\\n0x06, 0xA1, 0xD5, 0x8B, 0xB7, 0xC5, 0xDA, 0x76,\\r\\n0xF5, 0x50, 0xAA, 0x3D, 0x8A, 0x1F, 0xBF, 0xF0,\\r\\n0xEB, 0x19, 0xCC, 0xB1, 0xA3, 0x13, 0xD5, 0x5C,\\r\\n0xDA, 0x56, 0xC9, 0xEC, 0x2E, 0xF2, 0x96, 0x32,\\r\\n0x38, 0x7F, 0xE8, 0xD7, 0x6E, 0x3C, 0x04, 0x68,\\r\\n0x04, 0x3E, 0x8F, 0x66, 0x3F, 0x48, 0x60, 0xEE,\\r\\n0x12, 0xBF, 0x2D, 0x5B, 0x0B, 0x74, 0x74, 0xD6,\\r\\n0xE6, 0x94, 0xF9, 0x1E, 0x6D, 0xCC, 0x40, 0x24,\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n};\\r\\nreturn BN_bin2bn(RFC3526_PRIME_6144, sizeof(RFC3526_PRIME_6144), bn);\\r\\n}\\r\\nBIGNUM *get_rfc3526_prime_8192(BIGNUM *bn)\\r\\n{\\r\\nstatic const unsigned char RFC3526_PRIME_8192[] = {\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\\r\\n0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\\r\\n0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\\r\\n0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\\r\\n0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\\r\\n0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\\r\\n0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\\r\\n0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\\r\\n0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\\r\\n0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\\r\\n0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\\r\\n0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\\r\\n0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\\r\\n0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\\r\\n0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\\r\\n0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\\r\\n0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\\r\\n0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\\r\\n0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\\r\\n0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\\r\\n0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\\r\\n0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\\r\\n0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\\r\\n0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\\r\\n0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\\r\\n0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\\r\\n0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\\r\\n0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\\r\\n0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\\r\\n0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D,\\r\\n0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\\r\\n0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64,\\r\\n0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\\r\\n0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D,\\r\\n0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\\r\\n0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7,\\r\\n0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\\r\\n0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B,\\r\\n0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\\r\\n0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64,\\r\\n0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\\r\\n0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C,\\r\\n0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\\r\\n0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31,\\r\\n0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\\r\\n0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01,\\r\\n0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,\\r\\n0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26,\\r\\n0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,\\r\\n0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA,\\r\\n0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,\\r\\n0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9,\\r\\n0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,\\r\\n0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D,\\r\\n0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,\\r\\n0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED,\\r\\n0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,\\r\\n0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C,\\r\\n0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,\\r\\n0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1,\\r\\n0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,\\r\\n0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x02, 0x84, 0x92,\\r\\n0x36, 0xC3, 0xFA, 0xB4, 0xD2, 0x7C, 0x70, 0x26,\\r\\n0xC1, 0xD4, 0xDC, 0xB2, 0x60, 0x26, 0x46, 0xDE,\\r\\n0xC9, 0x75, 0x1E, 0x76, 0x3D, 0xBA, 0x37, 0xBD,\\r\\n0xF8, 0xFF, 0x94, 0x06, 0xAD, 0x9E, 0x53, 0x0E,\\r\\n0xE5, 0xDB, 0x38, 0x2F, 0x41, 0x30, 0x01, 0xAE,\\r\\n0xB0, 0x6A, 0x53, 0xED, 0x90, 0x27, 0xD8, 0x31,\\r\\n0x17, 0x97, 0x27, 0xB0, 0x86, 0x5A, 0x89, 0x18,\\r\\n0xDA, 0x3E, 0xDB, 0xEB, 0xCF, 0x9B, 0x14, 0xED,\\r\\n0x44, 0xCE, 0x6C, 0xBA, 0xCE, 0xD4, 0xBB, 0x1B,\\r\\n0xDB, 0x7F, 0x14, 0x47, 0xE6, 0xCC, 0x25, 0x4B,\\r\\n0x33, 0x20, 0x51, 0x51, 0x2B, 0xD7, 0xAF, 0x42,\\r\\n0x6F, 0xB8, 0xF4, 0x01, 0x37, 0x8C, 0xD2, 0xBF,\\r\\n0x59, 0x83, 0xCA, 0x01, 0xC6, 0x4B, 0x92, 0xEC,\\r\\n0xF0, 0x32, 0xEA, 0x15, 0xD1, 0x72, 0x1D, 0x03,\\r\\n0xF4, 0x82, 0xD7, 0xCE, 0x6E, 0x74, 0xFE, 0xF6,\\r\\n0xD5, 0x5E, 0x70, 0x2F, 0x46, 0x98, 0x0C, 0x82,\\r\\n0xB5, 0xA8, 0x40, 0x31, 0x90, 0x0B, 0x1C, 0x9E,\\r\\n0x59, 0xE7, 0xC9, 0x7F, 0xBE, 0xC7, 0xE8, 0xF3,\\r\\n0x23, 0xA9, 0x7A, 0x7E, 0x36, 0xCC, 0x88, 0xBE,\\r\\n0x0F, 0x1D, 0x45, 0xB7, 0xFF, 0x58, 0x5A, 0xC5,\\r\\n0x4B, 0xD4, 0x07, 0xB2, 0x2B, 0x41, 0x54, 0xAA,\\r\\n0xCC, 0x8F, 0x6D, 0x7E, 0xBF, 0x48, 0xE1, 0xD8,\\r\\n0x14, 0xCC, 0x5E, 0xD2, 0x0F, 0x80, 0x37, 0xE0,\\r\\n0xA7, 0x97, 0x15, 0xEE, 0xF2, 0x9B, 0xE3, 0x28,\\r\\n0x06, 0xA1, 0xD5, 0x8B, 0xB7, 0xC5, 0xDA, 0x76,\\r\\n0xF5, 0x50, 0xAA, 0x3D, 0x8A, 0x1F, 0xBF, 0xF0,\\r\\n0xEB, 0x19, 0xCC, 0xB1, 0xA3, 0x13, 0xD5, 0x5C,\\r\\n0xDA, 0x56, 0xC9, 0xEC, 0x2E, 0xF2, 0x96, 0x32,\\r\\n0x38, 0x7F, 0xE8, 0xD7, 0x6E, 0x3C, 0x04, 0x68,\\r\\n0x04, 0x3E, 0x8F, 0x66, 0x3F, 0x48, 0x60, 0xEE,\\r\\n0x12, 0xBF, 0x2D, 0x5B, 0x0B, 0x74, 0x74, 0xD6,\\r\\n0xE6, 0x94, 0xF9, 0x1E, 0x6D, 0xBE, 0x11, 0x59,\\r\\n0x74, 0xA3, 0x92, 0x6F, 0x12, 0xFE, 0xE5, 0xE4,\\r\\n0x38, 0x77, 0x7C, 0xB6, 0xA9, 0x32, 0xDF, 0x8C,\\r\\n0xD8, 0xBE, 0xC4, 0xD0, 0x73, 0xB9, 0x31, 0xBA,\\r\\n0x3B, 0xC8, 0x32, 0xB6, 0x8D, 0x9D, 0xD3, 0x00,\\r\\n0x74, 0x1F, 0xA7, 0xBF, 0x8A, 0xFC, 0x47, 0xED,\\r\\n0x25, 0x76, 0xF6, 0x93, 0x6B, 0xA4, 0x24, 0x66,\\r\\n0x3A, 0xAB, 0x63, 0x9C, 0x5A, 0xE4, 0xF5, 0x68,\\r\\n0x34, 0x23, 0xB4, 0x74, 0x2B, 0xF1, 0xC9, 0x78,\\r\\n0x23, 0x8F, 0x16, 0xCB, 0xE3, 0x9D, 0x65, 0x2D,\\r\\n0xE3, 0xFD, 0xB8, 0xBE, 0xFC, 0x84, 0x8A, 0xD9,\\r\\n0x22, 0x22, 0x2E, 0x04, 0xA4, 0x03, 0x7C, 0x07,\\r\\n0x13, 0xEB, 0x57, 0xA8, 0x1A, 0x23, 0xF0, 0xC7,\\r\\n0x34, 0x73, 0xFC, 0x64, 0x6C, 0xEA, 0x30, 0x6B,\\r\\n0x4B, 0xCB, 0xC8, 0x86, 0x2F, 0x83, 0x85, 0xDD,\\r\\n0xFA, 0x9D, 0x4B, 0x7F, 0xA2, 0xC0, 0x87, 0xE8,\\r\\n0x79, 0x68, 0x33, 0x03, 0xED, 0x5B, 0xDD, 0x3A,\\r\\n0x06, 0x2B, 0x3C, 0xF5, 0xB3, 0xA2, 0x78, 0xA6,\\r\\n0x6D, 0x2A, 0x13, 0xF8, 0x3F, 0x44, 0xF8, 0x2D,\\r\\n0xDF, 0x31, 0x0E, 0xE0, 0x74, 0xAB, 0x6A, 0x36,\\r\\n0x45, 0x97, 0xE8, 0x99, 0xA0, 0x25, 0x5D, 0xC1,\\r\\n0x64, 0xF3, 0x1C, 0xC5, 0x08, 0x46, 0x85, 0x1D,\\r\\n0xF9, 0xAB, 0x48, 0x19, 0x5D, 0xED, 0x7E, 0xA1,\\r\\n0xB1, 0xD5, 0x10, 0xBD, 0x7E, 0xE7, 0x4D, 0x73,\\r\\n0xFA, 0xF3, 0x6B, 0xC3, 0x1E, 0xCF, 0xA2, 0x68,\\r\\n0x35, 0x90, 0x46, 0xF4, 0xEB, 0x87, 0x9F, 0x92,\\r\\n0x40, 0x09, 0x43, 0x8B, 0x48, 0x1C, 0x6C, 0xD7,\\r\\n0x88, 0x9A, 0x00, 0x2E, 0xD5, 0xEE, 0x38, 0x2B,\\r\\n0xC9, 0x19, 0x0D, 0xA6, 0xFC, 0x02, 0x6E, 0x47,\\r\\n0x95, 0x58, 0xE4, 0x47, 0x56, 0x77, 0xE9, 0xAA,\\r\\n0x9E, 0x30, 0x50, 0xE2, 0x76, 0x56, 0x94, 0xDF,\\r\\n0xC8, 0x1F, 0x56, 0xE8, 0x80, 0xB9, 0x6E, 0x71,\\r\\n0x60, 0xC9, 0x80, 0xDD, 0x98, 0xED, 0xD3, 0xDF,\\r\\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\\r\\n};\\r\\nreturn BN_bin2bn(RFC3526_PRIME_8192, sizeof(RFC3526_PRIME_8192), bn);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_oct_c", "target": 0, "func": "int EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group,\\r\\nEC_POINT *point, const BIGNUM *x,\\r\\nint y_bit, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_compressed_coordinates == 0\\r\\n&& !(group->meth->flags & EC_FLAGS_DEFAULT_OCT)) {\\r\\nECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP,\\r\\nEC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth->flags & EC_FLAGS_DEFAULT_OCT) {\\r\\nif (group->meth->field_type == NID_X9_62_prime_field)\\r\\nreturn ec_GFp_simple_set_compressed_coordinates(group, point, x,\\r\\ny_bit, ctx);\\r\\nelse\\r\\n#ifdef OPENSSL_NO_EC2M\\r\\n{\\r\\nECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP,\\r\\nEC_R_GF2M_NOT_SUPPORTED);\\r\\nreturn 0;\\r\\n}\\r\\n#else\\r\\nreturn ec_GF2m_simple_set_compressed_coordinates(group, point, x,\\r\\ny_bit, ctx);\\r\\n#endif\\r\\n}\\r\\nreturn group->meth->point_set_compressed_coordinates(group, point, x,\\r\\ny_bit, ctx);\\r\\n}\\r\\nint EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group,\\r\\nEC_POINT *point, const BIGNUM *x,\\r\\nint y_bit, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point_set_compressed_coordinates == 0\\r\\n&& !(group->meth->flags & EC_FLAGS_DEFAULT_OCT)) {\\r\\nECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M,\\r\\nERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M,\\r\\nEC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth->flags & EC_FLAGS_DEFAULT_OCT) {\\r\\nif (group->meth->field_type == NID_X9_62_prime_field)\\r\\nreturn ec_GFp_simple_set_compressed_coordinates(group, point, x,\\r\\ny_bit, ctx);\\r\\nelse\\r\\nreturn ec_GF2m_simple_set_compressed_coordinates(group, point, x,\\r\\ny_bit, ctx);\\r\\n}\\r\\nreturn group->meth->point_set_compressed_coordinates(group, point, x,\\r\\ny_bit, ctx);\\r\\n}\\r\\nsize_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *point,\\r\\npoint_conversion_form_t form, unsigned char *buf,\\r\\nsize_t len, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->point2oct == 0\\r\\n&& !(group->meth->flags & EC_FLAGS_DEFAULT_OCT)) {\\r\\nECerr(EC_F_EC_POINT_POINT2OCT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_POINT2OCT, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth->flags & EC_FLAGS_DEFAULT_OCT) {\\r\\nif (group->meth->field_type == NID_X9_62_prime_field)\\r\\nreturn ec_GFp_simple_point2oct(group, point, form, buf, len, ctx);\\r\\nelse\\r\\n#ifdef OPENSSL_NO_EC2M\\r\\n{\\r\\nECerr(EC_F_EC_POINT_POINT2OCT, EC_R_GF2M_NOT_SUPPORTED);\\r\\nreturn 0;\\r\\n}\\r\\n#else\\r\\nreturn ec_GF2m_simple_point2oct(group, point,\\r\\nform, buf, len, ctx);\\r\\n#endif\\r\\n}\\r\\nreturn group->meth->point2oct(group, point, form, buf, len, ctx);\\r\\n}\\r\\nint EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *point,\\r\\nconst unsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\nif (group->meth->oct2point == 0\\r\\n&& !(group->meth->flags & EC_FLAGS_DEFAULT_OCT)) {\\r\\nECerr(EC_F_EC_POINT_OCT2POINT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth != point->meth) {\\r\\nECerr(EC_F_EC_POINT_OCT2POINT, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif (group->meth->flags & EC_FLAGS_DEFAULT_OCT) {\\r\\nif (group->meth->field_type == NID_X9_62_prime_field)\\r\\nreturn ec_GFp_simple_oct2point(group, point, buf, len, ctx);\\r\\nelse\\r\\n#ifdef OPENSSL_NO_EC2M\\r\\n{\\r\\nECerr(EC_F_EC_POINT_OCT2POINT, EC_R_GF2M_NOT_SUPPORTED);\\r\\nreturn 0;\\r\\n}\\r\\n#else\\r\\nreturn ec_GF2m_simple_oct2point(group, point, buf, len, ctx);\\r\\n#endif\\r\\n}\\r\\nreturn group->meth->oct2point(group, point, buf, len, ctx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_app_rand_c", "target": 0, "func": "int app_RAND_load_file(const char *file, BIO *bio_e, int dont_warn)\\r\\n{\\r\\nint consider_randfile = (file == NULL);\\r\\nchar buffer[200];\\r\\n#ifdef OPENSSL_SYS_WINDOWS\\r\\nBIO_printf(bio_e, \"Loading 'screen' into random state -\");\\r\\nBIO_flush(bio_e);\\r\\nRAND_screen();\\r\\nBIO_printf(bio_e, \" done\\n\");\\r\\n#endif\\r\\nif (file == NULL)\\r\\nfile = RAND_file_name(buffer, sizeof buffer);\\r\\nelse if (RAND_egd(file) > 0) {\\r\\negdsocket = 1;\\r\\nreturn 1;\\r\\n}\\r\\nif (file == NULL || !RAND_load_file(file, -1)) {\\r\\nif (RAND_status() == 0) {\\r\\nif (!dont_warn) {\\r\\nBIO_printf(bio_e, \"unable to load 'random state'\\n\");\\r\\nBIO_printf(bio_e,\\r\\n\"This means that the random number generator has not been seeded\\n\");\\r\\nBIO_printf(bio_e, \"with much random data.\\n\");\\r\\nif (consider_randfile) {\\r\\nBIO_printf(bio_e,\\r\\n\"Consider setting the RANDFILE environment variable to point at a file that\\n\");\\r\\nBIO_printf(bio_e,\\r\\n\"'random' data can be kept in (the file will be overwritten).\\n\");\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nseeded = 1;\\r\\nreturn 1;\\r\\n}\\r\\nlong app_RAND_load_files(char *name)\\r\\n{\\r\\nchar *p, *n;\\r\\nint last;\\r\\nlong tot = 0;\\r\\nint egd;\\r\\nfor (;;) {\\r\\nlast = 0;\\r\\nfor (p = name; ((*p != '\\0') && (*p != LIST_SEPARATOR_CHAR)); p++) ;\\r\\nif (*p == '\\0')\\r\\nlast = 1;\\r\\n*p = '\\0';\\r\\nn = name;\\r\\nname = p + 1;\\r\\nif (*n == '\\0')\\r\\nbreak;\\r\\negd = RAND_egd(n);\\r\\nif (egd > 0)\\r\\ntot += egd;\\r\\nelse\\r\\ntot += RAND_load_file(n, -1);\\r\\nif (last)\\r\\nbreak;\\r\\n}\\r\\nif (tot > 512)\\r\\napp_RAND_allow_write_file();\\r\\nreturn (tot);\\r\\n}\\r\\nint app_RAND_write_file(const char *file, BIO *bio_e)\\r\\n{\\r\\nchar buffer[200];\\r\\nif (egdsocket || !seeded)\\r\\nreturn 0;\\r\\nif (file == NULL)\\r\\nfile = RAND_file_name(buffer, sizeof buffer);\\r\\nif (file == NULL || !RAND_write_file(file)) {\\r\\nBIO_printf(bio_e, \"unable to write 'random state'\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid app_RAND_allow_write_file(void)\\r\\n{\\r\\nseeded = 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tls_srp_c", "target": 0, "func": "int SSL_CTX_SRP_CTX_free(struct ssl_ctx_st *ctx)\\r\\n{\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\nOPENSSL_free(ctx->srp_ctx.login);\\r\\nBN_free(ctx->srp_ctx.N);\\r\\nBN_free(ctx->srp_ctx.g);\\r\\nBN_free(ctx->srp_ctx.s);\\r\\nBN_free(ctx->srp_ctx.B);\\r\\nBN_free(ctx->srp_ctx.A);\\r\\nBN_free(ctx->srp_ctx.a);\\r\\nBN_free(ctx->srp_ctx.b);\\r\\nBN_free(ctx->srp_ctx.v);\\r\\nctx->srp_ctx.TLS_ext_srp_username_callback = NULL;\\r\\nctx->srp_ctx.SRP_cb_arg = NULL;\\r\\nctx->srp_ctx.SRP_verify_param_callback = NULL;\\r\\nctx->srp_ctx.SRP_give_srp_client_pwd_callback = NULL;\\r\\nctx->srp_ctx.N = NULL;\\r\\nctx->srp_ctx.g = NULL;\\r\\nctx->srp_ctx.s = NULL;\\r\\nctx->srp_ctx.B = NULL;\\r\\nctx->srp_ctx.A = NULL;\\r\\nctx->srp_ctx.a = NULL;\\r\\nctx->srp_ctx.b = NULL;\\r\\nctx->srp_ctx.v = NULL;\\r\\nctx->srp_ctx.login = NULL;\\r\\nctx->srp_ctx.info = NULL;\\r\\nctx->srp_ctx.strength = SRP_MINIMAL_N;\\r\\nctx->srp_ctx.srp_Mask = 0;\\r\\nreturn (1);\\r\\n}\\r\\nint SSL_SRP_CTX_free(struct ssl_st *s)\\r\\n{\\r\\nif (s == NULL)\\r\\nreturn 0;\\r\\nOPENSSL_free(s->srp_ctx.login);\\r\\nBN_free(s->srp_ctx.N);\\r\\nBN_free(s->srp_ctx.g);\\r\\nBN_free(s->srp_ctx.s);\\r\\nBN_free(s->srp_ctx.B);\\r\\nBN_free(s->srp_ctx.A);\\r\\nBN_free(s->srp_ctx.a);\\r\\nBN_free(s->srp_ctx.b);\\r\\nBN_free(s->srp_ctx.v);\\r\\ns->srp_ctx.TLS_ext_srp_username_callback = NULL;\\r\\ns->srp_ctx.SRP_cb_arg = NULL;\\r\\ns->srp_ctx.SRP_verify_param_callback = NULL;\\r\\ns->srp_ctx.SRP_give_srp_client_pwd_callback = NULL;\\r\\ns->srp_ctx.N = NULL;\\r\\ns->srp_ctx.g = NULL;\\r\\ns->srp_ctx.s = NULL;\\r\\ns->srp_ctx.B = NULL;\\r\\ns->srp_ctx.A = NULL;\\r\\ns->srp_ctx.a = NULL;\\r\\ns->srp_ctx.b = NULL;\\r\\ns->srp_ctx.v = NULL;\\r\\ns->srp_ctx.login = NULL;\\r\\ns->srp_ctx.info = NULL;\\r\\ns->srp_ctx.strength = SRP_MINIMAL_N;\\r\\ns->srp_ctx.srp_Mask = 0;\\r\\nreturn (1);\\r\\n}\\r\\nint SSL_SRP_CTX_init(struct ssl_st *s)\\r\\n{\\r\\nSSL_CTX *ctx;\\r\\nif ((s == NULL) || ((ctx = s->ctx) == NULL))\\r\\nreturn 0;\\r\\ns->srp_ctx.SRP_cb_arg = ctx->srp_ctx.SRP_cb_arg;\\r\\ns->srp_ctx.TLS_ext_srp_username_callback =\\r\\nctx->srp_ctx.TLS_ext_srp_username_callback;\\r\\ns->srp_ctx.SRP_verify_param_callback =\\r\\nctx->srp_ctx.SRP_verify_param_callback;\\r\\ns->srp_ctx.SRP_give_srp_client_pwd_callback =\\r\\nctx->srp_ctx.SRP_give_srp_client_pwd_callback;\\r\\ns->srp_ctx.N = NULL;\\r\\ns->srp_ctx.g = NULL;\\r\\ns->srp_ctx.s = NULL;\\r\\ns->srp_ctx.B = NULL;\\r\\ns->srp_ctx.A = NULL;\\r\\ns->srp_ctx.a = NULL;\\r\\ns->srp_ctx.b = NULL;\\r\\ns->srp_ctx.v = NULL;\\r\\ns->srp_ctx.login = NULL;\\r\\ns->srp_ctx.info = ctx->srp_ctx.info;\\r\\ns->srp_ctx.strength = ctx->srp_ctx.strength;\\r\\nif (((ctx->srp_ctx.N != NULL) &&\\r\\n((s->srp_ctx.N = BN_dup(ctx->srp_ctx.N)) == NULL)) ||\\r\\n((ctx->srp_ctx.g != NULL) &&\\r\\n((s->srp_ctx.g = BN_dup(ctx->srp_ctx.g)) == NULL)) ||\\r\\n((ctx->srp_ctx.s != NULL) &&\\r\\n((s->srp_ctx.s = BN_dup(ctx->srp_ctx.s)) == NULL)) ||\\r\\n((ctx->srp_ctx.B != NULL) &&\\r\\n((s->srp_ctx.B = BN_dup(ctx->srp_ctx.B)) == NULL)) ||\\r\\n((ctx->srp_ctx.A != NULL) &&\\r\\n((s->srp_ctx.A = BN_dup(ctx->srp_ctx.A)) == NULL)) ||\\r\\n((ctx->srp_ctx.a != NULL) &&\\r\\n((s->srp_ctx.a = BN_dup(ctx->srp_ctx.a)) == NULL)) ||\\r\\n((ctx->srp_ctx.v != NULL) &&\\r\\n((s->srp_ctx.v = BN_dup(ctx->srp_ctx.v)) == NULL)) ||\\r\\n((ctx->srp_ctx.b != NULL) &&\\r\\n((s->srp_ctx.b = BN_dup(ctx->srp_ctx.b)) == NULL))) {\\r\\nSSLerr(SSL_F_SSL_SRP_CTX_INIT, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif ((ctx->srp_ctx.login != NULL) &&\\r\\n((s->srp_ctx.login = BUF_strdup(ctx->srp_ctx.login)) == NULL)) {\\r\\nSSLerr(SSL_F_SSL_SRP_CTX_INIT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ns->srp_ctx.srp_Mask = ctx->srp_ctx.srp_Mask;\\r\\nreturn (1);\\r\\nerr:\\r\\nOPENSSL_free(s->srp_ctx.login);\\r\\nBN_free(s->srp_ctx.N);\\r\\nBN_free(s->srp_ctx.g);\\r\\nBN_free(s->srp_ctx.s);\\r\\nBN_free(s->srp_ctx.B);\\r\\nBN_free(s->srp_ctx.A);\\r\\nBN_free(s->srp_ctx.a);\\r\\nBN_free(s->srp_ctx.b);\\r\\nBN_free(s->srp_ctx.v);\\r\\nreturn (0);\\r\\n}\\r\\nint SSL_CTX_SRP_CTX_init(struct ssl_ctx_st *ctx)\\r\\n{\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\nctx->srp_ctx.SRP_cb_arg = NULL;\\r\\nctx->srp_ctx.TLS_ext_srp_username_callback = NULL;\\r\\nctx->srp_ctx.SRP_verify_param_callback = NULL;\\r\\nctx->srp_ctx.SRP_give_srp_client_pwd_callback = NULL;\\r\\nctx->srp_ctx.N = NULL;\\r\\nctx->srp_ctx.g = NULL;\\r\\nctx->srp_ctx.s = NULL;\\r\\nctx->srp_ctx.B = NULL;\\r\\nctx->srp_ctx.A = NULL;\\r\\nctx->srp_ctx.a = NULL;\\r\\nctx->srp_ctx.b = NULL;\\r\\nctx->srp_ctx.v = NULL;\\r\\nctx->srp_ctx.login = NULL;\\r\\nctx->srp_ctx.srp_Mask = 0;\\r\\nctx->srp_ctx.info = NULL;\\r\\nctx->srp_ctx.strength = SRP_MINIMAL_N;\\r\\nreturn (1);\\r\\n}\\r\\nint SSL_srp_server_param_with_username(SSL *s, int *ad)\\r\\n{\\r\\nunsigned char b[SSL_MAX_MASTER_KEY_LENGTH];\\r\\nint al;\\r\\n*ad = SSL_AD_UNKNOWN_PSK_IDENTITY;\\r\\nif ((s->srp_ctx.TLS_ext_srp_username_callback != NULL) &&\\r\\n((al =\\r\\ns->srp_ctx.TLS_ext_srp_username_callback(s, ad,\\r\\ns->srp_ctx.SRP_cb_arg)) !=\\r\\nSSL_ERROR_NONE))\\r\\nreturn al;\\r\\n*ad = SSL_AD_INTERNAL_ERROR;\\r\\nif ((s->srp_ctx.N == NULL) ||\\r\\n(s->srp_ctx.g == NULL) ||\\r\\n(s->srp_ctx.s == NULL) || (s->srp_ctx.v == NULL))\\r\\nreturn SSL3_AL_FATAL;\\r\\nif (RAND_bytes(b, sizeof(b)) <= 0)\\r\\nreturn SSL3_AL_FATAL;\\r\\ns->srp_ctx.b = BN_bin2bn(b, sizeof(b), NULL);\\r\\nOPENSSL_cleanse(b, sizeof(b));\\r\\nreturn ((s->srp_ctx.B =\\r\\nSRP_Calc_B(s->srp_ctx.b, s->srp_ctx.N, s->srp_ctx.g,\\r\\ns->srp_ctx.v)) !=\\r\\nNULL) ? SSL_ERROR_NONE : SSL3_AL_FATAL;\\r\\n}\\r\\nint SSL_set_srp_server_param_pw(SSL *s, const char *user, const char *pass,\\r\\nconst char *grp)\\r\\n{\\r\\nSRP_gN *GN = SRP_get_default_gN(grp);\\r\\nif (GN == NULL)\\r\\nreturn -1;\\r\\ns->srp_ctx.N = BN_dup(GN->N);\\r\\ns->srp_ctx.g = BN_dup(GN->g);\\r\\nif (s->srp_ctx.v != NULL) {\\r\\nBN_clear_free(s->srp_ctx.v);\\r\\ns->srp_ctx.v = NULL;\\r\\n}\\r\\nif (s->srp_ctx.s != NULL) {\\r\\nBN_clear_free(s->srp_ctx.s);\\r\\ns->srp_ctx.s = NULL;\\r\\n}\\r\\nif (!SRP_create_verifier_BN\\r\\n(user, pass, &s->srp_ctx.s, &s->srp_ctx.v, GN->N, GN->g))\\r\\nreturn -1;\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_set_srp_server_param(SSL *s, const BIGNUM *N, const BIGNUM *g,\\r\\nBIGNUM *sa, BIGNUM *v, char *info)\\r\\n{\\r\\nif (N != NULL) {\\r\\nif (s->srp_ctx.N != NULL) {\\r\\nif (!BN_copy(s->srp_ctx.N, N)) {\\r\\nBN_free(s->srp_ctx.N);\\r\\ns->srp_ctx.N = NULL;\\r\\n}\\r\\n} else\\r\\ns->srp_ctx.N = BN_dup(N);\\r\\n}\\r\\nif (g != NULL) {\\r\\nif (s->srp_ctx.g != NULL) {\\r\\nif (!BN_copy(s->srp_ctx.g, g)) {\\r\\nBN_free(s->srp_ctx.g);\\r\\ns->srp_ctx.g = NULL;\\r\\n}\\r\\n} else\\r\\ns->srp_ctx.g = BN_dup(g);\\r\\n}\\r\\nif (sa != NULL) {\\r\\nif (s->srp_ctx.s != NULL) {\\r\\nif (!BN_copy(s->srp_ctx.s, sa)) {\\r\\nBN_free(s->srp_ctx.s);\\r\\ns->srp_ctx.s = NULL;\\r\\n}\\r\\n} else\\r\\ns->srp_ctx.s = BN_dup(sa);\\r\\n}\\r\\nif (v != NULL) {\\r\\nif (s->srp_ctx.v != NULL) {\\r\\nif (!BN_copy(s->srp_ctx.v, v)) {\\r\\nBN_free(s->srp_ctx.v);\\r\\ns->srp_ctx.v = NULL;\\r\\n}\\r\\n} else\\r\\ns->srp_ctx.v = BN_dup(v);\\r\\n}\\r\\ns->srp_ctx.info = info;\\r\\nif (!(s->srp_ctx.N) ||\\r\\n!(s->srp_ctx.g) || !(s->srp_ctx.s) || !(s->srp_ctx.v))\\r\\nreturn -1;\\r\\nreturn 1;\\r\\n}\\r\\nint SRP_generate_server_master_secret(SSL *s, unsigned char *master_key)\\r\\n{\\r\\nBIGNUM *K = NULL, *u = NULL;\\r\\nint ret = -1, tmp_len;\\r\\nunsigned char *tmp = NULL;\\r\\nif (!SRP_Verify_A_mod_N(s->srp_ctx.A, s->srp_ctx.N))\\r\\ngoto err;\\r\\nif (!(u = SRP_Calc_u(s->srp_ctx.A, s->srp_ctx.B, s->srp_ctx.N)))\\r\\ngoto err;\\r\\nif (!\\r\\n(K =\\r\\nSRP_Calc_server_key(s->srp_ctx.A, s->srp_ctx.v, u, s->srp_ctx.b,\\r\\ns->srp_ctx.N)))\\r\\ngoto err;\\r\\ntmp_len = BN_num_bytes(K);\\r\\nif ((tmp = OPENSSL_malloc(tmp_len)) == NULL)\\r\\ngoto err;\\r\\nBN_bn2bin(K, tmp);\\r\\nret =\\r\\ns->method->ssl3_enc->generate_master_secret(s, master_key, tmp,\\r\\ntmp_len);\\r\\nerr:\\r\\nif (tmp) {\\r\\nOPENSSL_cleanse(tmp, tmp_len);\\r\\nOPENSSL_free(tmp);\\r\\n}\\r\\nBN_clear_free(K);\\r\\nBN_clear_free(u);\\r\\nreturn ret;\\r\\n}\\r\\nint SRP_generate_client_master_secret(SSL *s, unsigned char *master_key)\\r\\n{\\r\\nBIGNUM *x = NULL, *u = NULL, *K = NULL;\\r\\nint ret = -1, tmp_len;\\r\\nchar *passwd = NULL;\\r\\nunsigned char *tmp = NULL;\\r\\nif (SRP_Verify_B_mod_N(s->srp_ctx.B, s->srp_ctx.N) == 0)\\r\\ngoto err;\\r\\nif (!(u = SRP_Calc_u(s->srp_ctx.A, s->srp_ctx.B, s->srp_ctx.N)))\\r\\ngoto err;\\r\\nif (s->srp_ctx.SRP_give_srp_client_pwd_callback == NULL)\\r\\ngoto err;\\r\\nif (!\\r\\n(passwd =\\r\\ns->srp_ctx.SRP_give_srp_client_pwd_callback(s,\\r\\ns->srp_ctx.SRP_cb_arg)))\\r\\ngoto err;\\r\\nif (!(x = SRP_Calc_x(s->srp_ctx.s, s->srp_ctx.login, passwd)))\\r\\ngoto err;\\r\\nif (!\\r\\n(K =\\r\\nSRP_Calc_client_key(s->srp_ctx.N, s->srp_ctx.B, s->srp_ctx.g, x,\\r\\ns->srp_ctx.a, u)))\\r\\ngoto err;\\r\\ntmp_len = BN_num_bytes(K);\\r\\nif ((tmp = OPENSSL_malloc(tmp_len)) == NULL)\\r\\ngoto err;\\r\\nBN_bn2bin(K, tmp);\\r\\nret =\\r\\ns->method->ssl3_enc->generate_master_secret(s, master_key, tmp,\\r\\ntmp_len);\\r\\nerr:\\r\\nif (tmp) {\\r\\nOPENSSL_cleanse(tmp, tmp_len);\\r\\nOPENSSL_free(tmp);\\r\\n}\\r\\nBN_clear_free(K);\\r\\nBN_clear_free(x);\\r\\nif (passwd) {\\r\\nOPENSSL_cleanse(passwd, strlen(passwd));\\r\\nOPENSSL_free(passwd);\\r\\n}\\r\\nBN_clear_free(u);\\r\\nreturn ret;\\r\\n}\\r\\nint srp_verify_server_param(SSL *s, int *al)\\r\\n{\\r\\nSRP_CTX *srp = &s->srp_ctx;\\r\\nif (BN_ucmp(srp->g, srp->N) >= 0 || BN_ucmp(srp->B, srp->N) >= 0\\r\\n|| BN_is_zero(srp->B)) {\\r\\n*al = SSL3_AD_ILLEGAL_PARAMETER;\\r\\nreturn 0;\\r\\n}\\r\\nif (BN_num_bits(srp->N) < srp->strength) {\\r\\n*al = TLS1_AD_INSUFFICIENT_SECURITY;\\r\\nreturn 0;\\r\\n}\\r\\nif (srp->SRP_verify_param_callback) {\\r\\nif (srp->SRP_verify_param_callback(s, srp->SRP_cb_arg) <= 0) {\\r\\n*al = TLS1_AD_INSUFFICIENT_SECURITY;\\r\\nreturn 0;\\r\\n}\\r\\n} else if (!SRP_check_known_gN_param(srp->g, srp->N)) {\\r\\n*al = TLS1_AD_INSUFFICIENT_SECURITY;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SRP_Calc_A_param(SSL *s)\\r\\n{\\r\\nunsigned char rnd[SSL_MAX_MASTER_KEY_LENGTH];\\r\\nRAND_bytes(rnd, sizeof(rnd));\\r\\ns->srp_ctx.a = BN_bin2bn(rnd, sizeof(rnd), s->srp_ctx.a);\\r\\nOPENSSL_cleanse(rnd, sizeof(rnd));\\r\\nif (!\\r\\n(s->srp_ctx.A = SRP_Calc_A(s->srp_ctx.a, s->srp_ctx.N, s->srp_ctx.g)))\\r\\nreturn -1;\\r\\nreturn 1;\\r\\n}\\r\\nBIGNUM *SSL_get_srp_g(SSL *s)\\r\\n{\\r\\nif (s->srp_ctx.g != NULL)\\r\\nreturn s->srp_ctx.g;\\r\\nreturn s->ctx->srp_ctx.g;\\r\\n}\\r\\nBIGNUM *SSL_get_srp_N(SSL *s)\\r\\n{\\r\\nif (s->srp_ctx.N != NULL)\\r\\nreturn s->srp_ctx.N;\\r\\nreturn s->ctx->srp_ctx.N;\\r\\n}\\r\\nchar *SSL_get_srp_username(SSL *s)\\r\\n{\\r\\nif (s->srp_ctx.login != NULL)\\r\\nreturn s->srp_ctx.login;\\r\\nreturn s->ctx->srp_ctx.login;\\r\\n}\\r\\nchar *SSL_get_srp_userinfo(SSL *s)\\r\\n{\\r\\nif (s->srp_ctx.info != NULL)\\r\\nreturn s->srp_ctx.info;\\r\\nreturn s->ctx->srp_ctx.info;\\r\\n}\\r\\nint SSL_CTX_set_srp_username(SSL_CTX *ctx, char *name)\\r\\n{\\r\\nreturn tls1_ctx_ctrl(ctx, SSL_CTRL_SET_TLS_EXT_SRP_USERNAME, 0, name);\\r\\n}\\r\\nint SSL_CTX_set_srp_password(SSL_CTX *ctx, char *password)\\r\\n{\\r\\nreturn tls1_ctx_ctrl(ctx, SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD, 0, password);\\r\\n}\\r\\nint SSL_CTX_set_srp_strength(SSL_CTX *ctx, int strength)\\r\\n{\\r\\nreturn tls1_ctx_ctrl(ctx, SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH, strength,\\r\\nNULL);\\r\\n}\\r\\nint SSL_CTX_set_srp_verify_param_callback(SSL_CTX *ctx,\\r\\nint (*cb) (SSL *, void *))\\r\\n{\\r\\nreturn tls1_ctx_callback_ctrl(ctx, SSL_CTRL_SET_SRP_VERIFY_PARAM_CB,\\r\\n(void (*)(void))cb);\\r\\n}\\r\\nint SSL_CTX_set_srp_cb_arg(SSL_CTX *ctx, void *arg)\\r\\n{\\r\\nreturn tls1_ctx_ctrl(ctx, SSL_CTRL_SET_SRP_ARG, 0, arg);\\r\\n}\\r\\nint SSL_CTX_set_srp_username_callback(SSL_CTX *ctx,\\r\\nint (*cb) (SSL *, int *, void *))\\r\\n{\\r\\nreturn tls1_ctx_callback_ctrl(ctx, SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB,\\r\\n(void (*)(void))cb);\\r\\n}\\r\\nint SSL_CTX_set_srp_client_pwd_callback(SSL_CTX *ctx,\\r\\nchar *(*cb) (SSL *, void *))\\r\\n{\\r\\nreturn tls1_ctx_callback_ctrl(ctx, SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB,\\r\\n(void (*)(void))cb);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_chil_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nconst RSA_METHOD *meth1;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DH\\r\\nconst DH_METHOD *meth2;\\r\\n# endif\\r\\nif (!ENGINE_set_id(e, engine_hwcrhk_id) ||\\r\\n!ENGINE_set_name(e, engine_hwcrhk_name) ||\\r\\n# ifndef OPENSSL_NO_RSA\\r\\n!ENGINE_set_RSA(e, &hwcrhk_rsa) ||\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DH\\r\\n!ENGINE_set_DH(e, &hwcrhk_dh) ||\\r\\n# endif\\r\\n!ENGINE_set_RAND(e, &hwcrhk_rand) ||\\r\\n!ENGINE_set_destroy_function(e, hwcrhk_destroy) ||\\r\\n!ENGINE_set_init_function(e, hwcrhk_init) ||\\r\\n!ENGINE_set_finish_function(e, hwcrhk_finish) ||\\r\\n!ENGINE_set_ctrl_function(e, hwcrhk_ctrl) ||\\r\\n!ENGINE_set_load_privkey_function(e, hwcrhk_load_privkey) ||\\r\\n!ENGINE_set_load_pubkey_function(e, hwcrhk_load_pubkey) ||\\r\\n!ENGINE_set_cmd_defns(e, hwcrhk_cmd_defns))\\r\\nreturn 0;\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nmeth1 = RSA_PKCS1_SSLeay();\\r\\nhwcrhk_rsa.rsa_pub_enc = meth1->rsa_pub_enc;\\r\\nhwcrhk_rsa.rsa_pub_dec = meth1->rsa_pub_dec;\\r\\nhwcrhk_rsa.rsa_priv_enc = meth1->rsa_priv_enc;\\r\\nhwcrhk_rsa.rsa_priv_dec = meth1->rsa_priv_dec;\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DH\\r\\nmeth2 = DH_OpenSSL();\\r\\nhwcrhk_dh.generate_key = meth2->generate_key;\\r\\nhwcrhk_dh.compute_key = meth2->compute_key;\\r\\n# endif\\r\\nERR_load_HWCRHK_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_chil(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!bind_helper(ret)) {\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_chil(void)\\r\\n{\\r\\nENGINE *toadd = engine_chil();\\r\\nif (!toadd)\\r\\nreturn;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic void free_HWCRHK_LIBNAME(void)\\r\\n{\\r\\nif (HWCRHK_LIBNAME)\\r\\nOPENSSL_free((void *)HWCRHK_LIBNAME);\\r\\nHWCRHK_LIBNAME = NULL;\\r\\n}\\r\\nstatic const char *get_HWCRHK_LIBNAME(void)\\r\\n{\\r\\nif (HWCRHK_LIBNAME)\\r\\nreturn HWCRHK_LIBNAME;\\r\\nreturn \"nfhwcrhk\";\\r\\n}\\r\\nstatic long set_HWCRHK_LIBNAME(const char *name)\\r\\n{\\r\\nfree_HWCRHK_LIBNAME();\\r\\nreturn (((HWCRHK_LIBNAME = BUF_strdup(name)) != NULL) ? 1 : 0);\\r\\n}\\r\\nstatic int get_context(HWCryptoHook_ContextHandle * hac,\\r\\nHWCryptoHook_CallerContext * cac)\\r\\n{\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\n*hac = p_hwcrhk_Init(&hwcrhk_globals, sizeof(hwcrhk_globals), &rmsg, cac);\\r\\nif (!*hac)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void release_context(HWCryptoHook_ContextHandle hac)\\r\\n{\\r\\np_hwcrhk_Finish(hac);\\r\\n}\\r\\nstatic int hwcrhk_destroy(ENGINE *e)\\r\\n{\\r\\nfree_HWCRHK_LIBNAME();\\r\\nERR_unload_HWCRHK_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int hwcrhk_init(ENGINE *e)\\r\\n{\\r\\nHWCryptoHook_Init_t *p1;\\r\\nHWCryptoHook_Finish_t *p2;\\r\\nHWCryptoHook_ModExp_t *p3;\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nHWCryptoHook_RSA_t *p4;\\r\\nHWCryptoHook_RSALoadKey_t *p5;\\r\\nHWCryptoHook_RSAGetPublicKey_t *p6;\\r\\nHWCryptoHook_RSAUnloadKey_t *p7;\\r\\n# endif\\r\\nHWCryptoHook_RandomBytes_t *p8;\\r\\nHWCryptoHook_ModExpCRT_t *p9;\\r\\nif (hwcrhk_dso != NULL) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nhwcrhk_dso = DSO_load(NULL, get_HWCRHK_LIBNAME(), NULL, 0);\\r\\nif (hwcrhk_dso == NULL) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!(p1 = (HWCryptoHook_Init_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_Init)) ||\\r\\n!(p2 = (HWCryptoHook_Finish_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_Finish)) ||\\r\\n!(p3 = (HWCryptoHook_ModExp_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_ModExp)) ||\\r\\n# ifndef OPENSSL_NO_RSA\\r\\n!(p4 = (HWCryptoHook_RSA_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RSA)) ||\\r\\n!(p5 = (HWCryptoHook_RSALoadKey_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RSALoadKey)) ||\\r\\n!(p6 = (HWCryptoHook_RSAGetPublicKey_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RSAGetPublicKey)) ||\\r\\n!(p7 = (HWCryptoHook_RSAUnloadKey_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RSAUnloadKey)) ||\\r\\n# endif\\r\\n!(p8 = (HWCryptoHook_RandomBytes_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_RandomBytes)) ||\\r\\n!(p9 = (HWCryptoHook_ModExpCRT_t *)\\r\\nDSO_bind_func(hwcrhk_dso, n_hwcrhk_ModExpCRT))) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_DSO_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np_hwcrhk_Init = p1;\\r\\np_hwcrhk_Finish = p2;\\r\\np_hwcrhk_ModExp = p3;\\r\\n# ifndef OPENSSL_NO_RSA\\r\\np_hwcrhk_RSA = p4;\\r\\np_hwcrhk_RSALoadKey = p5;\\r\\np_hwcrhk_RSAGetPublicKey = p6;\\r\\np_hwcrhk_RSAUnloadKey = p7;\\r\\n# endif\\r\\np_hwcrhk_RandomBytes = p8;\\r\\np_hwcrhk_ModExpCRT = p9;\\r\\nif (disable_mutex_callbacks == 0) {\\r\\nif (CRYPTO_get_dynlock_create_callback() != NULL &&\\r\\nCRYPTO_get_dynlock_lock_callback() != NULL &&\\r\\nCRYPTO_get_dynlock_destroy_callback() != NULL) {\\r\\nhwcrhk_globals.mutex_init = hwcrhk_mutex_init;\\r\\nhwcrhk_globals.mutex_acquire = hwcrhk_mutex_lock;\\r\\nhwcrhk_globals.mutex_release = hwcrhk_mutex_unlock;\\r\\nhwcrhk_globals.mutex_destroy = hwcrhk_mutex_destroy;\\r\\n}\\r\\n}\\r\\nif (!get_context(&hwcrhk_context, &password_context)) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_UNIT_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nif (hndidx_rsa == -1)\\r\\nhndidx_rsa = RSA_get_ex_new_index(0,\\r\\n\"nFast HWCryptoHook RSA key handle\",\\r\\nNULL, NULL, NULL);\\r\\n# endif\\r\\nreturn 1;\\r\\nerr:\\r\\nif (hwcrhk_dso)\\r\\nDSO_free(hwcrhk_dso);\\r\\nhwcrhk_dso = NULL;\\r\\np_hwcrhk_Init = NULL;\\r\\np_hwcrhk_Finish = NULL;\\r\\np_hwcrhk_ModExp = NULL;\\r\\n# ifndef OPENSSL_NO_RSA\\r\\np_hwcrhk_RSA = NULL;\\r\\np_hwcrhk_RSALoadKey = NULL;\\r\\np_hwcrhk_RSAGetPublicKey = NULL;\\r\\np_hwcrhk_RSAUnloadKey = NULL;\\r\\n# endif\\r\\np_hwcrhk_ModExpCRT = NULL;\\r\\np_hwcrhk_RandomBytes = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int hwcrhk_finish(ENGINE *e)\\r\\n{\\r\\nint to_return = 1;\\r\\nfree_HWCRHK_LIBNAME();\\r\\nif (hwcrhk_dso == NULL) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_FINISH, HWCRHK_R_NOT_LOADED);\\r\\nto_return = 0;\\r\\ngoto err;\\r\\n}\\r\\nrelease_context(hwcrhk_context);\\r\\nif (!DSO_free(hwcrhk_dso)) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_FINISH, HWCRHK_R_DSO_FAILURE);\\r\\nto_return = 0;\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (logstream)\\r\\nBIO_free(logstream);\\r\\nhwcrhk_dso = NULL;\\r\\np_hwcrhk_Init = NULL;\\r\\np_hwcrhk_Finish = NULL;\\r\\np_hwcrhk_ModExp = NULL;\\r\\n# ifndef OPENSSL_NO_RSA\\r\\np_hwcrhk_RSA = NULL;\\r\\np_hwcrhk_RSALoadKey = NULL;\\r\\np_hwcrhk_RSAGetPublicKey = NULL;\\r\\np_hwcrhk_RSAUnloadKey = NULL;\\r\\n# endif\\r\\np_hwcrhk_ModExpCRT = NULL;\\r\\np_hwcrhk_RandomBytes = NULL;\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int hwcrhk_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))\\r\\n{\\r\\nint to_return = 1;\\r\\nswitch (cmd) {\\r\\ncase HWCRHK_CMD_SO_PATH:\\r\\nif (hwcrhk_dso) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_CTRL, HWCRHK_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nif (p == NULL) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nreturn set_HWCRHK_LIBNAME((const char *)p);\\r\\ncase ENGINE_CTRL_SET_LOGSTREAM:\\r\\n{\\r\\nBIO *bio = (BIO *)p;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (logstream) {\\r\\nBIO_free(logstream);\\r\\nlogstream = NULL;\\r\\n}\\r\\nif (CRYPTO_add(&bio->references, 1, CRYPTO_LOCK_BIO) > 1)\\r\\nlogstream = bio;\\r\\nelse\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_CTRL, HWCRHK_R_BIO_WAS_FREED);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_SET_PASSWORD_CALLBACK:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\npassword_context.password_callback = (pem_password_cb *)f;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_SET_USER_INTERFACE:\\r\\ncase HWCRHK_CMD_SET_USER_INTERFACE:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\npassword_context.ui_method = (UI_METHOD *)p;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_SET_CALLBACK_DATA:\\r\\ncase HWCRHK_CMD_SET_CALLBACK_DATA:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\npassword_context.callback_data = p;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_CHIL_SET_FORKCHECK:\\r\\ncase HWCRHK_CMD_FORK_CHECK:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (i)\\r\\nhwcrhk_globals.flags |= HWCryptoHook_InitFlags_SimpleForkCheck;\\r\\nelse\\r\\nhwcrhk_globals.flags &= ~HWCryptoHook_InitFlags_SimpleForkCheck;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase ENGINE_CTRL_CHIL_NO_LOCKING:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\ndisable_mutex_callbacks = 1;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ncase HWCRHK_CMD_THREAD_LOCKING:\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\ndisable_mutex_callbacks = ((i == 0) ? 0 : 1);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nbreak;\\r\\ndefault:\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_CTRL,\\r\\nHWCRHK_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nto_return = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn to_return;\\r\\n}\\r\\nstatic EVP_PKEY *hwcrhk_load_privkey(ENGINE *eng, const char *key_id,\\r\\nUI_METHOD *ui_method,\\r\\nvoid *callback_data)\\r\\n{\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nRSA *rtmp = NULL;\\r\\n# endif\\r\\nEVP_PKEY *res = NULL;\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nHWCryptoHook_MPI e, n;\\r\\nHWCryptoHook_RSAKeyHandle *hptr;\\r\\n# endif\\r\\n# if !defined(OPENSSL_NO_RSA)\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\nHWCryptoHook_PassphraseContext ppctx;\\r\\n# endif\\r\\n# if !defined(OPENSSL_NO_RSA)\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\n# endif\\r\\nif (!hwcrhk_context) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY, HWCRHK_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nhptr = OPENSSL_malloc(sizeof(HWCryptoHook_RSAKeyHandle));\\r\\nif (!hptr) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nppctx.ui_method = ui_method;\\r\\nppctx.callback_data = callback_data;\\r\\nif (p_hwcrhk_RSALoadKey(hwcrhk_context, key_id, hptr, &rmsg, &ppctx)) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY, HWCRHK_R_CHIL_ERROR);\\r\\nERR_add_error_data(1, rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nif (!*hptr) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY, HWCRHK_R_NO_KEY);\\r\\ngoto err;\\r\\n}\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nrtmp = RSA_new_method(eng);\\r\\nRSA_set_ex_data(rtmp, hndidx_rsa, (char *)hptr);\\r\\nrtmp->e = BN_new();\\r\\nrtmp->n = BN_new();\\r\\nrtmp->flags |= RSA_FLAG_EXT_PKEY;\\r\\nMPI2BN(rtmp->e, e);\\r\\nMPI2BN(rtmp->n, n);\\r\\nif (p_hwcrhk_RSAGetPublicKey(*hptr, &n, &e, &rmsg)\\r\\n!= HWCRYPTOHOOK_ERROR_MPISIZE) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY, HWCRHK_R_CHIL_ERROR);\\r\\nERR_add_error_data(1, rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nbn_expand2(rtmp->e, e.size / sizeof(BN_ULONG));\\r\\nbn_expand2(rtmp->n, n.size / sizeof(BN_ULONG));\\r\\nMPI2BN(rtmp->e, e);\\r\\nMPI2BN(rtmp->n, n);\\r\\nif (p_hwcrhk_RSAGetPublicKey(*hptr, &n, &e, &rmsg)) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY, HWCRHK_R_CHIL_ERROR);\\r\\nERR_add_error_data(1, rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nrtmp->e->top = e.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(rtmp->e);\\r\\nrtmp->n->top = n.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(rtmp->n);\\r\\nres = EVP_PKEY_new();\\r\\nEVP_PKEY_assign_RSA(res, rtmp);\\r\\n# endif\\r\\nif (!res)\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PRIVKEY,\\r\\nHWCRHK_R_PRIVATE_KEY_ALGORITHMS_DISABLED);\\r\\nreturn res;\\r\\nerr:\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nif (rtmp)\\r\\nRSA_free(rtmp);\\r\\n# endif\\r\\nreturn NULL;\\r\\n}\\r\\nstatic EVP_PKEY *hwcrhk_load_pubkey(ENGINE *eng, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nEVP_PKEY *res = NULL;\\r\\n# ifndef OPENSSL_NO_RSA\\r\\nres = hwcrhk_load_privkey(eng, key_id, ui_method, callback_data);\\r\\n# endif\\r\\nif (res)\\r\\nswitch (res->type) {\\r\\n# ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\n{\\r\\nRSA *rsa = NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EVP_PKEY);\\r\\nrsa = res->pkey.rsa;\\r\\nres->pkey.rsa = RSA_new();\\r\\nres->pkey.rsa->n = rsa->n;\\r\\nres->pkey.rsa->e = rsa->e;\\r\\nrsa->n = NULL;\\r\\nrsa->e = NULL;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EVP_PKEY);\\r\\nRSA_free(rsa);\\r\\n}\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_LOAD_PUBKEY,\\r\\nHWCRHK_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\ngoto err;\\r\\n}\\r\\nreturn res;\\r\\nerr:\\r\\nif (res)\\r\\nEVP_PKEY_free(res);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int hwcrhk_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\nHWCryptoHook_MPI m_a, m_p, m_n, m_r;\\r\\nint to_return, ret;\\r\\nto_return = 0;\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\nif (!hwcrhk_context) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_MOD_EXP, HWCRHK_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\nbn_expand2(r, m->top);\\r\\nBN2MPI(m_a, a);\\r\\nBN2MPI(m_p, p);\\r\\nBN2MPI(m_n, m);\\r\\nMPI2BN(r, m_r);\\r\\nret = p_hwcrhk_ModExp(hwcrhk_context, m_a, m_p, m_n, &m_r, &rmsg);\\r\\nr->top = m_r.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(r);\\r\\nif (ret < 0) {\\r\\nif (ret == HWCRYPTOHOOK_ERROR_FALLBACK) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_MOD_EXP, HWCRHK_R_REQUEST_FALLBACK);\\r\\n} else {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_MOD_EXP, HWCRHK_R_REQUEST_FAILED);\\r\\n}\\r\\nERR_add_error_data(1, rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int hwcrhk_rsa_mod_exp(BIGNUM *r, const BIGNUM *I, RSA *rsa,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\nHWCryptoHook_RSAKeyHandle *hptr;\\r\\nint to_return = 0, ret;\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\nif (!hwcrhk_context) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP, HWCRHK_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\nif ((hptr =\\r\\n(HWCryptoHook_RSAKeyHandle *) RSA_get_ex_data(rsa, hndidx_rsa))\\r\\n!= NULL) {\\r\\nHWCryptoHook_MPI m_a, m_r;\\r\\nif (!rsa->n) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nbn_expand2(r, rsa->n->top);\\r\\nBN2MPI(m_a, I);\\r\\nMPI2BN(r, m_r);\\r\\nret = p_hwcrhk_RSA(m_a, *hptr, &m_r, &rmsg);\\r\\nr->top = m_r.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(r);\\r\\nif (ret < 0) {\\r\\nif (ret == HWCRYPTOHOOK_ERROR_FALLBACK) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_REQUEST_FALLBACK);\\r\\n} else {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_REQUEST_FAILED);\\r\\n}\\r\\nERR_add_error_data(1, rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nHWCryptoHook_MPI m_a, m_p, m_q, m_dmp1, m_dmq1, m_iqmp, m_r;\\r\\nif (!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_MISSING_KEY_COMPONENTS);\\r\\ngoto err;\\r\\n}\\r\\nbn_expand2(r, rsa->n->top);\\r\\nBN2MPI(m_a, I);\\r\\nBN2MPI(m_p, rsa->p);\\r\\nBN2MPI(m_q, rsa->q);\\r\\nBN2MPI(m_dmp1, rsa->dmp1);\\r\\nBN2MPI(m_dmq1, rsa->dmq1);\\r\\nBN2MPI(m_iqmp, rsa->iqmp);\\r\\nMPI2BN(r, m_r);\\r\\nret = p_hwcrhk_ModExpCRT(hwcrhk_context, m_a, m_p, m_q,\\r\\nm_dmp1, m_dmq1, m_iqmp, &m_r, &rmsg);\\r\\nr->top = m_r.size / sizeof(BN_ULONG);\\r\\nbn_fix_top(r);\\r\\nif (ret < 0) {\\r\\nif (ret == HWCRYPTOHOOK_ERROR_FALLBACK) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_REQUEST_FALLBACK);\\r\\n} else {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RSA_MOD_EXP,\\r\\nHWCRHK_R_REQUEST_FAILED);\\r\\n}\\r\\nERR_add_error_data(1, rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int hwcrhk_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn hwcrhk_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int hwcrhk_rsa_finish(RSA *rsa)\\r\\n{\\r\\nHWCryptoHook_RSAKeyHandle *hptr;\\r\\nhptr = RSA_get_ex_data(rsa, hndidx_rsa);\\r\\nif (hptr) {\\r\\np_hwcrhk_RSAUnloadKey(*hptr, NULL);\\r\\nOPENSSL_free(hptr);\\r\\nRSA_set_ex_data(rsa, hndidx_rsa, NULL);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int hwcrhk_mod_exp_dh(const DH *dh, BIGNUM *r,\\r\\nconst BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn hwcrhk_mod_exp(r, a, p, m, ctx);\\r\\n}\\r\\nstatic int hwcrhk_rand_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nchar tempbuf[1024];\\r\\nHWCryptoHook_ErrMsgBuf rmsg;\\r\\nint to_return = 0;\\r\\nint ret;\\r\\nrmsg.buf = tempbuf;\\r\\nrmsg.size = sizeof(tempbuf);\\r\\nif (!hwcrhk_context) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RAND_BYTES, HWCRHK_R_NOT_INITIALISED);\\r\\ngoto err;\\r\\n}\\r\\nret = p_hwcrhk_RandomBytes(hwcrhk_context, buf, num, &rmsg);\\r\\nif (ret < 0) {\\r\\nif (ret == HWCRYPTOHOOK_ERROR_FALLBACK) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RAND_BYTES, HWCRHK_R_REQUEST_FALLBACK);\\r\\n} else {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_RAND_BYTES, HWCRHK_R_REQUEST_FAILED);\\r\\n}\\r\\nERR_add_error_data(1, rmsg.buf);\\r\\ngoto err;\\r\\n}\\r\\nto_return = 1;\\r\\nerr:\\r\\nreturn to_return;\\r\\n}\\r\\nstatic int hwcrhk_rand_status(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int hwcrhk_mutex_init(HWCryptoHook_Mutex * mt,\\r\\nHWCryptoHook_CallerContext * cactx)\\r\\n{\\r\\nmt->lockid = CRYPTO_get_new_dynlockid();\\r\\nif (mt->lockid == 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int hwcrhk_mutex_lock(HWCryptoHook_Mutex * mt)\\r\\n{\\r\\nCRYPTO_w_lock(mt->lockid);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void hwcrhk_mutex_unlock(HWCryptoHook_Mutex * mt)\\r\\n{\\r\\nCRYPTO_w_unlock(mt->lockid);\\r\\n}\\r\\nstatic void hwcrhk_mutex_destroy(HWCryptoHook_Mutex * mt)\\r\\n{\\r\\nCRYPTO_destroy_dynlockid(mt->lockid);\\r\\n}\\r\\nstatic int hwcrhk_get_pass(const char *prompt_info,\\r\\nint *len_io, char *buf,\\r\\nHWCryptoHook_PassphraseContext * ppctx,\\r\\nHWCryptoHook_CallerContext * cactx)\\r\\n{\\r\\npem_password_cb *callback = NULL;\\r\\nvoid *callback_data = NULL;\\r\\nUI_METHOD *ui_method = NULL;\\r\\nif (prompt_info && !*prompt_info)\\r\\nprompt_info = NULL;\\r\\nif (cactx) {\\r\\nif (cactx->ui_method)\\r\\nui_method = cactx->ui_method;\\r\\nif (cactx->password_callback)\\r\\ncallback = cactx->password_callback;\\r\\nif (cactx->callback_data)\\r\\ncallback_data = cactx->callback_data;\\r\\n}\\r\\nif (ppctx) {\\r\\nif (ppctx->ui_method) {\\r\\nui_method = ppctx->ui_method;\\r\\ncallback = NULL;\\r\\n}\\r\\nif (ppctx->callback_data)\\r\\ncallback_data = ppctx->callback_data;\\r\\n}\\r\\nif (callback == NULL && ui_method == NULL) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_GET_PASS, HWCRHK_R_NO_CALLBACK);\\r\\nreturn -1;\\r\\n}\\r\\nif (ui_method) {\\r\\nUI *ui = UI_new_method(ui_method);\\r\\nif (ui) {\\r\\nint ok;\\r\\nchar *prompt = UI_construct_prompt(ui,\\r\\n\"pass phrase\", prompt_info);\\r\\nok = UI_add_input_string(ui, prompt,\\r\\nUI_INPUT_FLAG_DEFAULT_PWD,\\r\\nbuf, 0, (*len_io) - 1);\\r\\nUI_add_user_data(ui, callback_data);\\r\\nUI_ctrl(ui, UI_CTRL_PRINT_ERRORS, 1, 0, 0);\\r\\nif (ok >= 0)\\r\\ndo {\\r\\nok = UI_process(ui);\\r\\n}\\r\\nwhile (ok < 0 && UI_ctrl(ui, UI_CTRL_IS_REDOABLE, 0, 0, 0));\\r\\nif (ok >= 0)\\r\\n*len_io = strlen(buf);\\r\\nUI_free(ui);\\r\\nOPENSSL_free(prompt);\\r\\n}\\r\\n} else {\\r\\n*len_io = callback(buf, *len_io, 0, callback_data);\\r\\n}\\r\\nif (!*len_io)\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int hwcrhk_insert_card(const char *prompt_info,\\r\\nconst char *wrong_info,\\r\\nHWCryptoHook_PassphraseContext * ppctx,\\r\\nHWCryptoHook_CallerContext * cactx)\\r\\n{\\r\\nint ok = -1;\\r\\nUI *ui;\\r\\nvoid *callback_data = NULL;\\r\\nUI_METHOD *ui_method = NULL;\\r\\nif (cactx) {\\r\\nif (cactx->ui_method)\\r\\nui_method = cactx->ui_method;\\r\\nif (cactx->callback_data)\\r\\ncallback_data = cactx->callback_data;\\r\\n}\\r\\nif (ppctx) {\\r\\nif (ppctx->ui_method)\\r\\nui_method = ppctx->ui_method;\\r\\nif (ppctx->callback_data)\\r\\ncallback_data = ppctx->callback_data;\\r\\n}\\r\\nif (ui_method == NULL) {\\r\\nHWCRHKerr(HWCRHK_F_HWCRHK_INSERT_CARD, HWCRHK_R_NO_CALLBACK);\\r\\nreturn -1;\\r\\n}\\r\\nui = UI_new_method(ui_method);\\r\\nif (ui) {\\r\\nchar answer;\\r\\nchar buf[BUFSIZ];\\r\\nif (wrong_info && *wrong_info)\\r\\nBIO_snprintf(buf, sizeof(buf) - 1,\\r\\n\"Current card: \\\"%s\\\"\\n\", wrong_info);\\r\\nelse\\r\\nbuf[0] = 0;\\r\\nok = UI_dup_info_string(ui, buf);\\r\\nif (ok >= 0 && prompt_info) {\\r\\nBIO_snprintf(buf, sizeof(buf) - 1,\\r\\n\"Insert card \\\"%s\\\"\", prompt_info);\\r\\nok = UI_dup_input_boolean(ui, buf,\\r\\n\"\\n then hit <enter> or C<enter> to cancel\\n\",\\r\\n\"\\r\\n\", \"Cc\", UI_INPUT_FLAG_ECHO,\\r\\n&answer);\\r\\n}\\r\\nUI_add_user_data(ui, callback_data);\\r\\nif (ok >= 0)\\r\\nok = UI_process(ui);\\r\\nUI_free(ui);\\r\\nif (ok == -2 || (ok >= 0 && answer == 'C'))\\r\\nok = 1;\\r\\nelse if (ok < 0)\\r\\nok = -1;\\r\\nelse\\r\\nok = 0;\\r\\n}\\r\\nreturn ok;\\r\\n}\\r\\nstatic void hwcrhk_log_message(void *logstr, const char *message)\\r\\n{\\r\\nBIO *lstream = NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_BIO);\\r\\nif (logstr)\\r\\nlstream = *(BIO **)logstr;\\r\\nif (lstream) {\\r\\nBIO_printf(lstream, \"%s\\n\", message);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_BIO);\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif (id && (strcmp(id, engine_hwcrhk_id) != 0) &&\\r\\n(strcmp(id, engine_hwcrhk_id_alt) != 0))\\r\\nreturn 0;\\r\\nif (!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_b_print_c", "target": 0, "func": "static void\\r\\n_dopr(char **sbuffer,\\r\\nchar **buffer,\\r\\nsize_t *maxlen,\\r\\nsize_t *retlen, int *truncated, const char *format, va_list args)\\r\\n{\\r\\nchar ch;\\r\\nLLONG value;\\r\\nLDOUBLE fvalue;\\r\\nchar *strvalue;\\r\\nint min;\\r\\nint max;\\r\\nint state;\\r\\nint flags;\\r\\nint cflags;\\r\\nsize_t currlen;\\r\\nstate = DP_S_DEFAULT;\\r\\nflags = currlen = cflags = min = 0;\\r\\nmax = -1;\\r\\nch = *format++;\\r\\nwhile (state != DP_S_DONE) {\\r\\nif (ch == '\\0' || (buffer == NULL && currlen >= *maxlen))\\r\\nstate = DP_S_DONE;\\r\\nswitch (state) {\\r\\ncase DP_S_DEFAULT:\\r\\nif (ch == '%')\\r\\nstate = DP_S_FLAGS;\\r\\nelse\\r\\ndoapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase DP_S_FLAGS:\\r\\nswitch (ch) {\\r\\ncase '-':\\r\\nflags |= DP_F_MINUS;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase '+':\\r\\nflags |= DP_F_PLUS;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase ' ':\\r\\nflags |= DP_F_SPACE;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase '#':\\r\\nflags |= DP_F_NUM;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase '0':\\r\\nflags |= DP_F_ZERO;\\r\\nch = *format++;\\r\\nbreak;\\r\\ndefault:\\r\\nstate = DP_S_MIN;\\r\\nbreak;\\r\\n}\\r\\nbreak;\\r\\ncase DP_S_MIN:\\r\\nif (isdigit((unsigned char)ch)) {\\r\\nmin = 10 * min + char_to_int(ch);\\r\\nch = *format++;\\r\\n} else if (ch == '*') {\\r\\nmin = va_arg(args, int);\\r\\nch = *format++;\\r\\nstate = DP_S_DOT;\\r\\n} else\\r\\nstate = DP_S_DOT;\\r\\nbreak;\\r\\ncase DP_S_DOT:\\r\\nif (ch == '.') {\\r\\nstate = DP_S_MAX;\\r\\nch = *format++;\\r\\n} else\\r\\nstate = DP_S_MOD;\\r\\nbreak;\\r\\ncase DP_S_MAX:\\r\\nif (isdigit((unsigned char)ch)) {\\r\\nif (max < 0)\\r\\nmax = 0;\\r\\nmax = 10 * max + char_to_int(ch);\\r\\nch = *format++;\\r\\n} else if (ch == '*') {\\r\\nmax = va_arg(args, int);\\r\\nch = *format++;\\r\\nstate = DP_S_MOD;\\r\\n} else\\r\\nstate = DP_S_MOD;\\r\\nbreak;\\r\\ncase DP_S_MOD:\\r\\nswitch (ch) {\\r\\ncase 'h':\\r\\ncflags = DP_C_SHORT;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase 'l':\\r\\nif (*format == 'l') {\\r\\ncflags = DP_C_LLONG;\\r\\nformat++;\\r\\n} else\\r\\ncflags = DP_C_LONG;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase 'q':\\r\\ncflags = DP_C_LLONG;\\r\\nch = *format++;\\r\\nbreak;\\r\\ncase 'L':\\r\\ncflags = DP_C_LDOUBLE;\\r\\nch = *format++;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nstate = DP_S_CONV;\\r\\nbreak;\\r\\ncase DP_S_CONV:\\r\\nswitch (ch) {\\r\\ncase 'd':\\r\\ncase 'i':\\r\\nswitch (cflags) {\\r\\ncase DP_C_SHORT:\\r\\nvalue = (short int)va_arg(args, int);\\r\\nbreak;\\r\\ncase DP_C_LONG:\\r\\nvalue = va_arg(args, long int);\\r\\nbreak;\\r\\ncase DP_C_LLONG:\\r\\nvalue = va_arg(args, LLONG);\\r\\nbreak;\\r\\ndefault:\\r\\nvalue = va_arg(args, int);\\r\\nbreak;\\r\\n}\\r\\nfmtint(sbuffer, buffer, &currlen, maxlen,\\r\\nvalue, 10, min, max, flags);\\r\\nbreak;\\r\\ncase 'X':\\r\\nflags |= DP_F_UP;\\r\\ncase 'x':\\r\\ncase 'o':\\r\\ncase 'u':\\r\\nflags |= DP_F_UNSIGNED;\\r\\nswitch (cflags) {\\r\\ncase DP_C_SHORT:\\r\\nvalue = (unsigned short int)va_arg(args, unsigned int);\\r\\nbreak;\\r\\ncase DP_C_LONG:\\r\\nvalue = (LLONG) va_arg(args, unsigned long int);\\r\\nbreak;\\r\\ncase DP_C_LLONG:\\r\\nvalue = va_arg(args, unsigned LLONG);\\r\\nbreak;\\r\\ndefault:\\r\\nvalue = (LLONG) va_arg(args, unsigned int);\\r\\nbreak;\\r\\n}\\r\\nfmtint(sbuffer, buffer, &currlen, maxlen, value,\\r\\nch == 'o' ? 8 : (ch == 'u' ? 10 : 16),\\r\\nmin, max, flags);\\r\\nbreak;\\r\\ncase 'f':\\r\\nif (cflags == DP_C_LDOUBLE)\\r\\nfvalue = va_arg(args, LDOUBLE);\\r\\nelse\\r\\nfvalue = va_arg(args, double);\\r\\nfmtfp(sbuffer, buffer, &currlen, maxlen,\\r\\nfvalue, min, max, flags);\\r\\nbreak;\\r\\ncase 'E':\\r\\nflags |= DP_F_UP;\\r\\ncase 'e':\\r\\nif (cflags == DP_C_LDOUBLE)\\r\\nfvalue = va_arg(args, LDOUBLE);\\r\\nelse\\r\\nfvalue = va_arg(args, double);\\r\\nbreak;\\r\\ncase 'G':\\r\\nflags |= DP_F_UP;\\r\\ncase 'g':\\r\\nif (cflags == DP_C_LDOUBLE)\\r\\nfvalue = va_arg(args, LDOUBLE);\\r\\nelse\\r\\nfvalue = va_arg(args, double);\\r\\nbreak;\\r\\ncase 'c':\\r\\ndoapr_outch(sbuffer, buffer, &currlen, maxlen,\\r\\nva_arg(args, int));\\r\\nbreak;\\r\\ncase 's':\\r\\nstrvalue = va_arg(args, char *);\\r\\nif (max < 0) {\\r\\nif (buffer)\\r\\nmax = INT_MAX;\\r\\nelse\\r\\nmax = *maxlen;\\r\\n}\\r\\nfmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,\\r\\nflags, min, max);\\r\\nbreak;\\r\\ncase 'p':\\r\\nvalue = (long)va_arg(args, void *);\\r\\nfmtint(sbuffer, buffer, &currlen, maxlen,\\r\\nvalue, 16, min, max, flags | DP_F_NUM);\\r\\nbreak;\\r\\ncase 'n':\\r\\nif (cflags == DP_C_SHORT) {\\r\\nshort int *num;\\r\\nnum = va_arg(args, short int *);\\r\\n*num = currlen;\\r\\n} else if (cflags == DP_C_LONG) {\\r\\nlong int *num;\\r\\nnum = va_arg(args, long int *);\\r\\n*num = (long int)currlen;\\r\\n} else if (cflags == DP_C_LLONG) {\\r\\nLLONG *num;\\r\\nnum = va_arg(args, LLONG *);\\r\\n*num = (LLONG) currlen;\\r\\n} else {\\r\\nint *num;\\r\\nnum = va_arg(args, int *);\\r\\n*num = currlen;\\r\\n}\\r\\nbreak;\\r\\ncase '%':\\r\\ndoapr_outch(sbuffer, buffer, &currlen, maxlen, ch);\\r\\nbreak;\\r\\ncase 'w':\\r\\nch = *format++;\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nch = *format++;\\r\\nstate = DP_S_DEFAULT;\\r\\nflags = cflags = min = 0;\\r\\nmax = -1;\\r\\nbreak;\\r\\ncase DP_S_DONE:\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n*truncated = (currlen > *maxlen - 1);\\r\\nif (*truncated)\\r\\ncurrlen = *maxlen - 1;\\r\\ndoapr_outch(sbuffer, buffer, &currlen, maxlen, '\\0');\\r\\n*retlen = currlen - 1;\\r\\nreturn;\\r\\n}\\r\\nstatic void\\r\\nfmtstr(char **sbuffer,\\r\\nchar **buffer,\\r\\nsize_t *currlen,\\r\\nsize_t *maxlen, const char *value, int flags, int min, int max)\\r\\n{\\r\\nint padlen, strln;\\r\\nint cnt = 0;\\r\\nif (value == 0)\\r\\nvalue = \"<NULL>\";\\r\\nfor (strln = 0; value[strln]; ++strln) ;\\r\\npadlen = min - strln;\\r\\nif (padlen < 0)\\r\\npadlen = 0;\\r\\nif (flags & DP_F_MINUS)\\r\\npadlen = -padlen;\\r\\nwhile ((padlen > 0) && (cnt < max)) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n--padlen;\\r\\n++cnt;\\r\\n}\\r\\nwhile (*value && (cnt < max)) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, *value++);\\r\\n++cnt;\\r\\n}\\r\\nwhile ((padlen < 0) && (cnt < max)) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n++padlen;\\r\\n++cnt;\\r\\n}\\r\\n}\\r\\nstatic void\\r\\nfmtint(char **sbuffer,\\r\\nchar **buffer,\\r\\nsize_t *currlen,\\r\\nsize_t *maxlen, LLONG value, int base, int min, int max, int flags)\\r\\n{\\r\\nint signvalue = 0;\\r\\nconst char *prefix = \"\";\\r\\nunsigned LLONG uvalue;\\r\\nchar convert[DECIMAL_SIZE(value) + 3];\\r\\nint place = 0;\\r\\nint spadlen = 0;\\r\\nint zpadlen = 0;\\r\\nint caps = 0;\\r\\nif (max < 0)\\r\\nmax = 0;\\r\\nuvalue = value;\\r\\nif (!(flags & DP_F_UNSIGNED)) {\\r\\nif (value < 0) {\\r\\nsignvalue = '-';\\r\\nuvalue = -value;\\r\\n} else if (flags & DP_F_PLUS)\\r\\nsignvalue = '+';\\r\\nelse if (flags & DP_F_SPACE)\\r\\nsignvalue = ' ';\\r\\n}\\r\\nif (flags & DP_F_NUM) {\\r\\nif (base == 8)\\r\\nprefix = \"0\";\\r\\nif (base == 16)\\r\\nprefix = \"0x\";\\r\\n}\\r\\nif (flags & DP_F_UP)\\r\\ncaps = 1;\\r\\ndo {\\r\\nconvert[place++] = (caps ? \"0123456789ABCDEF\" : \"0123456789abcdef\")\\r\\n[uvalue % (unsigned)base];\\r\\nuvalue = (uvalue / (unsigned)base);\\r\\n} while (uvalue && (place < (int)sizeof(convert)));\\r\\nif (place == sizeof(convert))\\r\\nplace--;\\r\\nconvert[place] = 0;\\r\\nzpadlen = max - place;\\r\\nspadlen =\\r\\nmin - OSSL_MAX(max, place) - (signvalue ? 1 : 0) - strlen(prefix);\\r\\nif (zpadlen < 0)\\r\\nzpadlen = 0;\\r\\nif (spadlen < 0)\\r\\nspadlen = 0;\\r\\nif (flags & DP_F_ZERO) {\\r\\nzpadlen = OSSL_MAX(zpadlen, spadlen);\\r\\nspadlen = 0;\\r\\n}\\r\\nif (flags & DP_F_MINUS)\\r\\nspadlen = -spadlen;\\r\\nwhile (spadlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n--spadlen;\\r\\n}\\r\\nif (signvalue)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);\\r\\nwhile (*prefix) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, *prefix);\\r\\nprefix++;\\r\\n}\\r\\nif (zpadlen > 0) {\\r\\nwhile (zpadlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '0');\\r\\n--zpadlen;\\r\\n}\\r\\n}\\r\\nwhile (place > 0)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, convert[--place]);\\r\\nwhile (spadlen < 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n++spadlen;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nstatic LDOUBLE abs_val(LDOUBLE value)\\r\\n{\\r\\nLDOUBLE result = value;\\r\\nif (value < 0)\\r\\nresult = -value;\\r\\nreturn result;\\r\\n}\\r\\nstatic LDOUBLE pow_10(int in_exp)\\r\\n{\\r\\nLDOUBLE result = 1;\\r\\nwhile (in_exp) {\\r\\nresult *= 10;\\r\\nin_exp--;\\r\\n}\\r\\nreturn result;\\r\\n}\\r\\nstatic long roundv(LDOUBLE value)\\r\\n{\\r\\nlong intpart;\\r\\nintpart = (long)value;\\r\\nvalue = value - intpart;\\r\\nif (value >= 0.5)\\r\\nintpart++;\\r\\nreturn intpart;\\r\\n}\\r\\nstatic void\\r\\nfmtfp(char **sbuffer,\\r\\nchar **buffer,\\r\\nsize_t *currlen,\\r\\nsize_t *maxlen, LDOUBLE fvalue, int min, int max, int flags)\\r\\n{\\r\\nint signvalue = 0;\\r\\nLDOUBLE ufvalue;\\r\\nchar iconvert[20];\\r\\nchar fconvert[20];\\r\\nint iplace = 0;\\r\\nint fplace = 0;\\r\\nint padlen = 0;\\r\\nint zpadlen = 0;\\r\\nint caps = 0;\\r\\nlong intpart;\\r\\nlong fracpart;\\r\\nlong max10;\\r\\nif (max < 0)\\r\\nmax = 6;\\r\\nufvalue = abs_val(fvalue);\\r\\nif (fvalue < 0)\\r\\nsignvalue = '-';\\r\\nelse if (flags & DP_F_PLUS)\\r\\nsignvalue = '+';\\r\\nelse if (flags & DP_F_SPACE)\\r\\nsignvalue = ' ';\\r\\nintpart = (long)ufvalue;\\r\\nif (max > 9)\\r\\nmax = 9;\\r\\nmax10 = roundv(pow_10(max));\\r\\nfracpart = roundv(pow_10(max) * (ufvalue - intpart));\\r\\nif (fracpart >= max10) {\\r\\nintpart++;\\r\\nfracpart -= max10;\\r\\n}\\r\\ndo {\\r\\niconvert[iplace++] =\\r\\n(caps ? \"0123456789ABCDEF\" : \"0123456789abcdef\")[intpart % 10];\\r\\nintpart = (intpart / 10);\\r\\n} while (intpart && (iplace < (int)sizeof(iconvert)));\\r\\nif (iplace == sizeof iconvert)\\r\\niplace--;\\r\\niconvert[iplace] = 0;\\r\\ndo {\\r\\nfconvert[fplace++] =\\r\\n(caps ? \"0123456789ABCDEF\" : \"0123456789abcdef\")[fracpart % 10];\\r\\nfracpart = (fracpart / 10);\\r\\n} while (fplace < max);\\r\\nif (fplace == sizeof fconvert)\\r\\nfplace--;\\r\\nfconvert[fplace] = 0;\\r\\npadlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);\\r\\nzpadlen = max - fplace;\\r\\nif (zpadlen < 0)\\r\\nzpadlen = 0;\\r\\nif (padlen < 0)\\r\\npadlen = 0;\\r\\nif (flags & DP_F_MINUS)\\r\\npadlen = -padlen;\\r\\nif ((flags & DP_F_ZERO) && (padlen > 0)) {\\r\\nif (signvalue) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);\\r\\n--padlen;\\r\\nsignvalue = 0;\\r\\n}\\r\\nwhile (padlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '0');\\r\\n--padlen;\\r\\n}\\r\\n}\\r\\nwhile (padlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n--padlen;\\r\\n}\\r\\nif (signvalue)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, signvalue);\\r\\nwhile (iplace > 0)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, iconvert[--iplace]);\\r\\nif (max > 0 || (flags & DP_F_NUM)) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '.');\\r\\nwhile (fplace > 0)\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, fconvert[--fplace]);\\r\\n}\\r\\nwhile (zpadlen > 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, '0');\\r\\n--zpadlen;\\r\\n}\\r\\nwhile (padlen < 0) {\\r\\ndoapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\\r\\n++padlen;\\r\\n}\\r\\n}\\r\\nstatic void\\r\\ndoapr_outch(char **sbuffer,\\r\\nchar **buffer, size_t *currlen, size_t *maxlen, int c)\\r\\n{\\r\\nassert(*sbuffer != NULL || buffer != NULL);\\r\\nif (buffer) {\\r\\nwhile (*currlen >= *maxlen) {\\r\\nif (*buffer == NULL) {\\r\\nif (*maxlen == 0)\\r\\n*maxlen = 1024;\\r\\n*buffer = OPENSSL_malloc(*maxlen);\\r\\nif (*currlen > 0) {\\r\\nassert(*sbuffer != NULL);\\r\\nmemcpy(*buffer, *sbuffer, *currlen);\\r\\n}\\r\\n*sbuffer = NULL;\\r\\n} else {\\r\\n*maxlen += 1024;\\r\\n*buffer = OPENSSL_realloc(*buffer, *maxlen);\\r\\n}\\r\\n}\\r\\nassert(*sbuffer != NULL || *buffer != NULL);\\r\\n}\\r\\nif (*currlen < *maxlen) {\\r\\nif (*sbuffer)\\r\\n(*sbuffer)[(*currlen)++] = (char)c;\\r\\nelse\\r\\n(*buffer)[(*currlen)++] = (char)c;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nint BIO_printf(BIO *bio, const char *format, ...)\\r\\n{\\r\\nva_list args;\\r\\nint ret;\\r\\nva_start(args, format);\\r\\nret = BIO_vprintf(bio, format, args);\\r\\nva_end(args);\\r\\nreturn (ret);\\r\\n}\\r\\nint BIO_vprintf(BIO *bio, const char *format, va_list args)\\r\\n{\\r\\nint ret;\\r\\nsize_t retlen;\\r\\nchar hugebuf[1024 * 2];\\r\\nchar *hugebufp = hugebuf;\\r\\nsize_t hugebufsize = sizeof(hugebuf);\\r\\nchar *dynbuf = NULL;\\r\\nint ignored;\\r\\ndynbuf = NULL;\\r\\nCRYPTO_push_info(\"doapr()\");\\r\\n_dopr(&hugebufp, &dynbuf, &hugebufsize, &retlen, &ignored, format, args);\\r\\nif (dynbuf) {\\r\\nret = BIO_write(bio, dynbuf, (int)retlen);\\r\\nOPENSSL_free(dynbuf);\\r\\n} else {\\r\\nret = BIO_write(bio, hugebuf, (int)retlen);\\r\\n}\\r\\nCRYPTO_pop_info();\\r\\nreturn (ret);\\r\\n}\\r\\nint BIO_snprintf(char *buf, size_t n, const char *format, ...)\\r\\n{\\r\\nva_list args;\\r\\nint ret;\\r\\nva_start(args, format);\\r\\nret = BIO_vsnprintf(buf, n, format, args);\\r\\nva_end(args);\\r\\nreturn (ret);\\r\\n}\\r\\nint BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)\\r\\n{\\r\\nsize_t retlen;\\r\\nint truncated;\\r\\n_dopr(&buf, NULL, &n, &retlen, &truncated, format, args);\\r\\nif (truncated)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn (retlen <= INT_MAX) ? (int)retlen : -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_prn_c", "target": 0, "func": "int X509V3_EXT_print(BIO *out, X509_EXTENSION *ext, unsigned long flag,\\r\\nint indent)\\r\\n{\\r\\nvoid *ext_str = NULL;\\r\\nchar *value = NULL;\\r\\nconst unsigned char *p;\\r\\nconst X509V3_EXT_METHOD *method;\\r\\nSTACK_OF(CONF_VALUE) *nval = NULL;\\r\\nint ok = 1;\\r\\nif (!(method = X509V3_EXT_get(ext)))\\r\\nreturn unknown_ext_print(out, ext, flag, indent, 0);\\r\\np = ext->value->data;\\r\\nif (method->it)\\r\\next_str =\\r\\nASN1_item_d2i(NULL, &p, ext->value->length,\\r\\nASN1_ITEM_ptr(method->it));\\r\\nelse\\r\\next_str = method->d2i(NULL, &p, ext->value->length);\\r\\nif (!ext_str)\\r\\nreturn unknown_ext_print(out, ext, flag, indent, 1);\\r\\nif (method->i2s) {\\r\\nif (!(value = method->i2s(method, ext_str))) {\\r\\nok = 0;\\r\\ngoto err;\\r\\n}\\r\\n#ifndef CHARSET_EBCDIC\\r\\nBIO_printf(out, \"%*s%s\", indent, \"\", value);\\r\\n#else\\r\\n{\\r\\nint len;\\r\\nchar *tmp;\\r\\nlen = strlen(value) + 1;\\r\\ntmp = OPENSSL_malloc(len);\\r\\nif (tmp) {\\r\\nascii2ebcdic(tmp, value, len);\\r\\nBIO_printf(out, \"%*s%s\", indent, \"\", tmp);\\r\\nOPENSSL_free(tmp);\\r\\n}\\r\\n}\\r\\n#endif\\r\\n} else if (method->i2v) {\\r\\nif (!(nval = method->i2v(method, ext_str, NULL))) {\\r\\nok = 0;\\r\\ngoto err;\\r\\n}\\r\\nX509V3_EXT_val_prn(out, nval, indent,\\r\\nmethod->ext_flags & X509V3_EXT_MULTILINE);\\r\\n} else if (method->i2r) {\\r\\nif (!method->i2r(method, ext_str, out, indent))\\r\\nok = 0;\\r\\n} else\\r\\nok = 0;\\r\\nerr:\\r\\nsk_CONF_VALUE_pop_free(nval, X509V3_conf_free);\\r\\nif (value)\\r\\nOPENSSL_free(value);\\r\\nif (method->it)\\r\\nASN1_item_free(ext_str, ASN1_ITEM_ptr(method->it));\\r\\nelse\\r\\nmethod->ext_free(ext_str);\\r\\nreturn ok;\\r\\n}\\r\\nstatic int unknown_ext_print(BIO *out, X509_EXTENSION *ext,\\r\\nunsigned long flag, int indent, int supported)\\r\\n{\\r\\nswitch (flag & X509V3_EXT_UNKNOWN_MASK) {\\r\\ncase X509V3_EXT_DEFAULT:\\r\\nreturn 0;\\r\\ncase X509V3_EXT_ERROR_UNKNOWN:\\r\\nif (supported)\\r\\nBIO_printf(out, \"%*s<Parse Error>\", indent, \"\");\\r\\nelse\\r\\nBIO_printf(out, \"%*s<Not Supported>\", indent, \"\");\\r\\nreturn 1;\\r\\ncase X509V3_EXT_PARSE_UNKNOWN:\\r\\nreturn ASN1_parse_dump(out,\\r\\next->value->data, ext->value->length, indent,\\r\\n-1);\\r\\ncase X509V3_EXT_DUMP_UNKNOWN:\\r\\nreturn BIO_dump_indent(out, (char *)ext->value->data,\\r\\next->value->length, indent);\\r\\ndefault:\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nint X509V3_EXT_print_fp(FILE *fp, X509_EXTENSION *ext, int flag, int indent)\\r\\n{\\r\\nBIO *bio_tmp;\\r\\nint ret;\\r\\nif (!(bio_tmp = BIO_new_fp(fp, BIO_NOCLOSE)))\\r\\nreturn 0;\\r\\nret = X509V3_EXT_print(bio_tmp, ext, flag, indent);\\r\\nBIO_free(bio_tmp);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_enc_c", "target": 0, "func": "BIO *cms_EncryptedContent_init_bio(CMS_EncryptedContentInfo *ec)\\r\\n{\\r\\nBIO *b;\\r\\nEVP_CIPHER_CTX *ctx;\\r\\nconst EVP_CIPHER *ciph;\\r\\nX509_ALGOR *calg = ec->contentEncryptionAlgorithm;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH], *piv = NULL;\\r\\nunsigned char *tkey = NULL;\\r\\nsize_t tkeylen = 0;\\r\\nint ok = 0;\\r\\nint enc, keep_key = 0;\\r\\nenc = ec->cipher ? 1 : 0;\\r\\nb = BIO_new(BIO_f_cipher());\\r\\nif (!b) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nBIO_get_cipher_ctx(b, &ctx);\\r\\nif (enc) {\\r\\nciph = ec->cipher;\\r\\nif (ec->key)\\r\\nec->cipher = NULL;\\r\\n} else {\\r\\nciph = EVP_get_cipherbyobj(calg->algorithm);\\r\\nif (!ciph) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO, CMS_R_UNKNOWN_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (EVP_CipherInit_ex(ctx, ciph, NULL, NULL, NULL, enc) <= 0) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,\\r\\nCMS_R_CIPHER_INITIALISATION_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (enc) {\\r\\nint ivlen;\\r\\ncalg->algorithm = OBJ_nid2obj(EVP_CIPHER_CTX_type(ctx));\\r\\nivlen = EVP_CIPHER_CTX_iv_length(ctx);\\r\\nif (ivlen > 0) {\\r\\nif (RAND_pseudo_bytes(iv, ivlen) <= 0)\\r\\ngoto err;\\r\\npiv = iv;\\r\\n}\\r\\n} else if (EVP_CIPHER_asn1_to_param(ctx, calg->parameter) <= 0) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,\\r\\nCMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ntkeylen = EVP_CIPHER_CTX_key_length(ctx);\\r\\nif (!enc || !ec->key) {\\r\\ntkey = OPENSSL_malloc(tkeylen);\\r\\nif (!tkey) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_CIPHER_CTX_rand_key(ctx, tkey) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!ec->key) {\\r\\nec->key = tkey;\\r\\nec->keylen = tkeylen;\\r\\ntkey = NULL;\\r\\nif (enc)\\r\\nkeep_key = 1;\\r\\nelse\\r\\nERR_clear_error();\\r\\n}\\r\\nif (ec->keylen != tkeylen) {\\r\\nif (EVP_CIPHER_CTX_set_key_length(ctx, ec->keylen) <= 0) {\\r\\nif (enc || ec->debug) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,\\r\\nCMS_R_INVALID_KEY_LENGTH);\\r\\ngoto err;\\r\\n} else {\\r\\nOPENSSL_cleanse(ec->key, ec->keylen);\\r\\nOPENSSL_free(ec->key);\\r\\nec->key = tkey;\\r\\nec->keylen = tkeylen;\\r\\ntkey = NULL;\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\n}\\r\\nif (EVP_CipherInit_ex(ctx, NULL, NULL, ec->key, piv, enc) <= 0) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,\\r\\nCMS_R_CIPHER_INITIALISATION_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (piv) {\\r\\ncalg->parameter = ASN1_TYPE_new();\\r\\nif (!calg->parameter) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_CIPHER_param_to_asn1(ctx, calg->parameter) <= 0) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO,\\r\\nCMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (ec->key && !keep_key) {\\r\\nOPENSSL_cleanse(ec->key, ec->keylen);\\r\\nOPENSSL_free(ec->key);\\r\\nec->key = NULL;\\r\\n}\\r\\nif (tkey) {\\r\\nOPENSSL_cleanse(tkey, tkeylen);\\r\\nOPENSSL_free(tkey);\\r\\n}\\r\\nif (ok)\\r\\nreturn b;\\r\\nBIO_free(b);\\r\\nreturn NULL;\\r\\n}\\r\\nint cms_EncryptedContent_init(CMS_EncryptedContentInfo *ec,\\r\\nconst EVP_CIPHER *cipher,\\r\\nconst unsigned char *key, size_t keylen)\\r\\n{\\r\\nec->cipher = cipher;\\r\\nif (key) {\\r\\nec->key = OPENSSL_malloc(keylen);\\r\\nif (!ec->key)\\r\\nreturn 0;\\r\\nmemcpy(ec->key, key, keylen);\\r\\n}\\r\\nec->keylen = keylen;\\r\\nif (cipher)\\r\\nec->contentType = OBJ_nid2obj(NID_pkcs7_data);\\r\\nreturn 1;\\r\\n}\\r\\nint CMS_EncryptedData_set1_key(CMS_ContentInfo *cms, const EVP_CIPHER *ciph,\\r\\nconst unsigned char *key, size_t keylen)\\r\\n{\\r\\nCMS_EncryptedContentInfo *ec;\\r\\nif (!key || !keylen) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY, CMS_R_NO_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nif (ciph) {\\r\\ncms->d.encryptedData = M_ASN1_new_of(CMS_EncryptedData);\\r\\nif (!cms->d.encryptedData) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ncms->contentType = OBJ_nid2obj(NID_pkcs7_encrypted);\\r\\ncms->d.encryptedData->version = 0;\\r\\n} else if (OBJ_obj2nid(cms->contentType) != NID_pkcs7_encrypted) {\\r\\nCMSerr(CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY, CMS_R_NOT_ENCRYPTED_DATA);\\r\\nreturn 0;\\r\\n}\\r\\nec = cms->d.encryptedData->encryptedContentInfo;\\r\\nreturn cms_EncryptedContent_init(ec, ciph, key, keylen);\\r\\n}\\r\\nBIO *cms_EncryptedData_init_bio(CMS_ContentInfo *cms)\\r\\n{\\r\\nCMS_EncryptedData *enc = cms->d.encryptedData;\\r\\nif (enc->encryptedContentInfo->cipher && enc->unprotectedAttrs)\\r\\nenc->version = 2;\\r\\nreturn cms_EncryptedContent_init_bio(enc->encryptedContentInfo);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_c_ecb_c", "target": 0, "func": "void CAST_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst CAST_KEY *ks, int enc)\\r\\n{\\r\\nCAST_LONG l, d[2];\\r\\nn2l(in, l);\\r\\nd[0] = l;\\r\\nn2l(in, l);\\r\\nd[1] = l;\\r\\nif (enc)\\r\\nCAST_encrypt(d, ks);\\r\\nelse\\r\\nCAST_decrypt(d, ks);\\r\\nl = d[0];\\r\\nl2n(l, out);\\r\\nl = d[1];\\r\\nl2n(l, out);\\r\\nl = d[0] = d[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_recp_c", "target": 0, "func": "void BN_RECP_CTX_init(BN_RECP_CTX *recp)\\r\\n{\\r\\nBN_init(&(recp->N));\\r\\nBN_init(&(recp->Nr));\\r\\nrecp->num_bits = 0;\\r\\nrecp->flags = 0;\\r\\n}\\r\\nBN_RECP_CTX *BN_RECP_CTX_new(void)\\r\\n{\\r\\nBN_RECP_CTX *ret;\\r\\nif ((ret = (BN_RECP_CTX *)OPENSSL_malloc(sizeof(BN_RECP_CTX))) == NULL)\\r\\nreturn (NULL);\\r\\nBN_RECP_CTX_init(ret);\\r\\nret->flags = BN_FLG_MALLOCED;\\r\\nreturn (ret);\\r\\n}\\r\\nvoid BN_RECP_CTX_free(BN_RECP_CTX *recp)\\r\\n{\\r\\nif (recp == NULL)\\r\\nreturn;\\r\\nBN_free(&(recp->N));\\r\\nBN_free(&(recp->Nr));\\r\\nif (recp->flags & BN_FLG_MALLOCED)\\r\\nOPENSSL_free(recp);\\r\\n}\\r\\nint BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *d, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_copy(&(recp->N), d))\\r\\nreturn 0;\\r\\nBN_zero(&(recp->Nr));\\r\\nrecp->num_bits = BN_num_bits(d);\\r\\nrecp->shift = 0;\\r\\nreturn (1);\\r\\n}\\r\\nint BN_mod_mul_reciprocal(BIGNUM *r, const BIGNUM *x, const BIGNUM *y,\\r\\nBN_RECP_CTX *recp, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *a;\\r\\nconst BIGNUM *ca;\\r\\nBN_CTX_start(ctx);\\r\\nif ((a = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (y != NULL) {\\r\\nif (x == y) {\\r\\nif (!BN_sqr(a, x, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mul(a, x, y, ctx))\\r\\ngoto err;\\r\\n}\\r\\nca = a;\\r\\n} else\\r\\nca = x;\\r\\nret = BN_div_recp(NULL, r, ca, recp, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(r);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_div_recp(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m,\\r\\nBN_RECP_CTX *recp, BN_CTX *ctx)\\r\\n{\\r\\nint i, j, ret = 0;\\r\\nBIGNUM *a, *b, *d, *r;\\r\\nBN_CTX_start(ctx);\\r\\na = BN_CTX_get(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nif (dv != NULL)\\r\\nd = dv;\\r\\nelse\\r\\nd = BN_CTX_get(ctx);\\r\\nif (rem != NULL)\\r\\nr = rem;\\r\\nelse\\r\\nr = BN_CTX_get(ctx);\\r\\nif (a == NULL || b == NULL || d == NULL || r == NULL)\\r\\ngoto err;\\r\\nif (BN_ucmp(m, &(recp->N)) < 0) {\\r\\nBN_zero(d);\\r\\nif (!BN_copy(r, m))\\r\\nreturn 0;\\r\\nBN_CTX_end(ctx);\\r\\nreturn (1);\\r\\n}\\r\\ni = BN_num_bits(m);\\r\\nj = recp->num_bits << 1;\\r\\nif (j > i)\\r\\ni = j;\\r\\nif (i != recp->shift)\\r\\nrecp->shift = BN_reciprocal(&(recp->Nr), &(recp->N), i, ctx);\\r\\nif (recp->shift == -1)\\r\\ngoto err;\\r\\nif (!BN_rshift(a, m, recp->num_bits))\\r\\ngoto err;\\r\\nif (!BN_mul(b, a, &(recp->Nr), ctx))\\r\\ngoto err;\\r\\nif (!BN_rshift(d, b, i - recp->num_bits))\\r\\ngoto err;\\r\\nd->neg = 0;\\r\\nif (!BN_mul(b, &(recp->N), d, ctx))\\r\\ngoto err;\\r\\nif (!BN_usub(r, m, b))\\r\\ngoto err;\\r\\nr->neg = 0;\\r\\n#if 1\\r\\nj = 0;\\r\\nwhile (BN_ucmp(r, &(recp->N)) >= 0) {\\r\\nif (j++ > 2) {\\r\\nBNerr(BN_F_BN_DIV_RECP, BN_R_BAD_RECIPROCAL);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_usub(r, r, &(recp->N)))\\r\\ngoto err;\\r\\nif (!BN_add_word(d, 1))\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\nr->neg = BN_is_zero(r) ? 0 : m->neg;\\r\\nd->neg = m->neg ^ recp->N.neg;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(dv);\\r\\nbn_check_top(rem);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_reciprocal(BIGNUM *r, const BIGNUM *m, int len, BN_CTX *ctx)\\r\\n{\\r\\nint ret = -1;\\r\\nBIGNUM *t;\\r\\nBN_CTX_start(ctx);\\r\\nif ((t = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_set_bit(t, len))\\r\\ngoto err;\\r\\nif (!BN_div(r, NULL, t, m, ctx))\\r\\ngoto err;\\r\\nret = len;\\r\\nerr:\\r\\nbn_check_top(r);\\r\\nBN_CTX_end(ctx);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc2_ecb_c", "target": 0, "func": "void RC2_ecb_encrypt(const unsigned char *in, unsigned char *out, RC2_KEY *ks,\\r\\nint encrypt)\\r\\n{\\r\\nunsigned long l, d[2];\\r\\nc2l(in, l);\\r\\nd[0] = l;\\r\\nc2l(in, l);\\r\\nd[1] = l;\\r\\nif (encrypt)\\r\\nRC2_encrypt(d, ks);\\r\\nelse\\r\\nRC2_decrypt(d, ks);\\r\\nl = d[0];\\r\\nl2c(l, out);\\r\\nl = d[1];\\r\\nl2c(l, out);\\r\\nl = d[0] = d[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_ndef_c", "target": 0, "func": "BIO *BIO_new_NDEF(BIO *out, ASN1_VALUE *val, const ASN1_ITEM *it)\\r\\n{\\r\\nNDEF_SUPPORT *ndef_aux = NULL;\\r\\nBIO *asn_bio = NULL;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_STREAM_ARG sarg;\\r\\nif (!aux || !aux->asn1_cb) {\\r\\nASN1err(ASN1_F_BIO_NEW_NDEF, ASN1_R_STREAMING_NOT_SUPPORTED);\\r\\nreturn NULL;\\r\\n}\\r\\nndef_aux = OPENSSL_malloc(sizeof(NDEF_SUPPORT));\\r\\nasn_bio = BIO_new(BIO_f_asn1());\\r\\nout = BIO_push(asn_bio, out);\\r\\nif (!ndef_aux || !asn_bio || !out)\\r\\ngoto err;\\r\\nBIO_asn1_set_prefix(asn_bio, ndef_prefix, ndef_prefix_free);\\r\\nBIO_asn1_set_suffix(asn_bio, ndef_suffix, ndef_suffix_free);\\r\\nsarg.out = out;\\r\\nsarg.ndef_bio = NULL;\\r\\nsarg.boundary = NULL;\\r\\nif (aux->asn1_cb(ASN1_OP_STREAM_PRE, &val, it, &sarg) <= 0)\\r\\ngoto err;\\r\\nndef_aux->val = val;\\r\\nndef_aux->it = it;\\r\\nndef_aux->ndef_bio = sarg.ndef_bio;\\r\\nndef_aux->boundary = sarg.boundary;\\r\\nndef_aux->out = out;\\r\\nBIO_ctrl(asn_bio, BIO_C_SET_EX_ARG, 0, ndef_aux);\\r\\nreturn sarg.ndef_bio;\\r\\nerr:\\r\\nif (asn_bio)\\r\\nBIO_free(asn_bio);\\r\\nif (ndef_aux)\\r\\nOPENSSL_free(ndef_aux);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int ndef_prefix(BIO *b, unsigned char **pbuf, int *plen, void *parg)\\r\\n{\\r\\nNDEF_SUPPORT *ndef_aux;\\r\\nunsigned char *p;\\r\\nint derlen;\\r\\nif (!parg)\\r\\nreturn 0;\\r\\nndef_aux = *(NDEF_SUPPORT **)parg;\\r\\nderlen = ASN1_item_ndef_i2d(ndef_aux->val, NULL, ndef_aux->it);\\r\\np = OPENSSL_malloc(derlen);\\r\\nndef_aux->derbuf = p;\\r\\n*pbuf = p;\\r\\nderlen = ASN1_item_ndef_i2d(ndef_aux->val, &p, ndef_aux->it);\\r\\nif (!*ndef_aux->boundary)\\r\\nreturn 0;\\r\\n*plen = *ndef_aux->boundary - *pbuf;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ndef_prefix_free(BIO *b, unsigned char **pbuf, int *plen,\\r\\nvoid *parg)\\r\\n{\\r\\nNDEF_SUPPORT *ndef_aux;\\r\\nif (!parg)\\r\\nreturn 0;\\r\\nndef_aux = *(NDEF_SUPPORT **)parg;\\r\\nif (ndef_aux->derbuf)\\r\\nOPENSSL_free(ndef_aux->derbuf);\\r\\nndef_aux->derbuf = NULL;\\r\\n*pbuf = NULL;\\r\\n*plen = 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ndef_suffix_free(BIO *b, unsigned char **pbuf, int *plen,\\r\\nvoid *parg)\\r\\n{\\r\\nNDEF_SUPPORT **pndef_aux = (NDEF_SUPPORT **)parg;\\r\\nif (!ndef_prefix_free(b, pbuf, plen, parg))\\r\\nreturn 0;\\r\\nOPENSSL_free(*pndef_aux);\\r\\n*pndef_aux = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ndef_suffix(BIO *b, unsigned char **pbuf, int *plen, void *parg)\\r\\n{\\r\\nNDEF_SUPPORT *ndef_aux;\\r\\nunsigned char *p;\\r\\nint derlen;\\r\\nconst ASN1_AUX *aux;\\r\\nASN1_STREAM_ARG sarg;\\r\\nif (!parg)\\r\\nreturn 0;\\r\\nndef_aux = *(NDEF_SUPPORT **)parg;\\r\\naux = ndef_aux->it->funcs;\\r\\nsarg.ndef_bio = ndef_aux->ndef_bio;\\r\\nsarg.out = ndef_aux->out;\\r\\nsarg.boundary = ndef_aux->boundary;\\r\\nif (aux->asn1_cb(ASN1_OP_STREAM_POST,\\r\\n&ndef_aux->val, ndef_aux->it, &sarg) <= 0)\\r\\nreturn 0;\\r\\nderlen = ASN1_item_ndef_i2d(ndef_aux->val, NULL, ndef_aux->it);\\r\\np = OPENSSL_malloc(derlen);\\r\\nndef_aux->derbuf = p;\\r\\n*pbuf = p;\\r\\nderlen = ASN1_item_ndef_i2d(ndef_aux->val, &p, ndef_aux->it);\\r\\nif (!*ndef_aux->boundary)\\r\\nreturn 0;\\r\\n*pbuf = *ndef_aux->boundary;\\r\\n*plen = derlen - (*ndef_aux->boundary - ndef_aux->derbuf);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_aes_cbc_c", "target": 0, "func": "void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const AES_KEY *key,\\r\\nunsigned char *ivec, const int enc)\\r\\n{\\r\\nif (enc)\\r\\nCRYPTO_cbc128_encrypt(in, out, len, key, ivec,\\r\\n(block128_f) AES_encrypt);\\r\\nelse\\r\\nCRYPTO_cbc128_decrypt(in, out, len, key, ivec,\\r\\n(block128_f) AES_decrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_m_sigver_c", "target": 0, "func": "static int do_sigver_init(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\\r\\nconst EVP_MD *type, ENGINE *e, EVP_PKEY *pkey,\\r\\nint ver)\\r\\n{\\r\\nif (ctx->pctx == NULL)\\r\\nctx->pctx = EVP_PKEY_CTX_new(pkey, e);\\r\\nif (ctx->pctx == NULL)\\r\\nreturn 0;\\r\\nif (!(ctx->pctx->pmeth->flags & EVP_PKEY_FLAG_SIGCTX_CUSTOM)) {\\r\\nif (type == NULL) {\\r\\nint def_nid;\\r\\nif (EVP_PKEY_get_default_digest_nid(pkey, &def_nid) > 0)\\r\\ntype = EVP_get_digestbynid(def_nid);\\r\\n}\\r\\nif (type == NULL) {\\r\\nEVPerr(EVP_F_DO_SIGVER_INIT, EVP_R_NO_DEFAULT_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (ver) {\\r\\nif (ctx->pctx->pmeth->verifyctx_init) {\\r\\nif (ctx->pctx->pmeth->verifyctx_init(ctx->pctx, ctx) <= 0)\\r\\nreturn 0;\\r\\nctx->pctx->operation = EVP_PKEY_OP_VERIFYCTX;\\r\\n} else if (EVP_PKEY_verify_init(ctx->pctx) <= 0)\\r\\nreturn 0;\\r\\n} else {\\r\\nif (ctx->pctx->pmeth->signctx_init) {\\r\\nif (ctx->pctx->pmeth->signctx_init(ctx->pctx, ctx) <= 0)\\r\\nreturn 0;\\r\\nctx->pctx->operation = EVP_PKEY_OP_SIGNCTX;\\r\\n} else if (EVP_PKEY_sign_init(ctx->pctx) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (EVP_PKEY_CTX_set_signature_md(ctx->pctx, type) <= 0)\\r\\nreturn 0;\\r\\nif (pctx)\\r\\n*pctx = ctx->pctx;\\r\\nif (ctx->pctx->pmeth->flags & EVP_PKEY_FLAG_SIGCTX_CUSTOM)\\r\\nreturn 1;\\r\\nif (!EVP_DigestInit_ex(ctx, type, e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\\r\\nconst EVP_MD *type, ENGINE *e, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn do_sigver_init(ctx, pctx, type, e, pkey, 0);\\r\\n}\\r\\nint EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,\\r\\nconst EVP_MD *type, ENGINE *e, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn do_sigver_init(ctx, pctx, type, e, pkey, 1);\\r\\n}\\r\\nint EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,\\r\\nsize_t *siglen)\\r\\n{\\r\\nint sctx, r = 0;\\r\\nEVP_PKEY_CTX *pctx = ctx->pctx;\\r\\nif (pctx->pmeth->flags & EVP_PKEY_FLAG_SIGCTX_CUSTOM) {\\r\\nEVP_PKEY_CTX *dctx;\\r\\nif (!sigret)\\r\\nreturn pctx->pmeth->signctx(pctx, sigret, siglen, ctx);\\r\\ndctx = EVP_PKEY_CTX_dup(ctx->pctx);\\r\\nif (!dctx)\\r\\nreturn 0;\\r\\nr = dctx->pmeth->signctx(dctx, sigret, siglen, ctx);\\r\\nEVP_PKEY_CTX_free(dctx);\\r\\nreturn r;\\r\\n}\\r\\nif (pctx->pmeth->signctx)\\r\\nsctx = 1;\\r\\nelse\\r\\nsctx = 0;\\r\\nif (sigret) {\\r\\nEVP_MD_CTX tmp_ctx;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nunsigned int mdlen;\\r\\nEVP_MD_CTX_init(&tmp_ctx);\\r\\nif (!EVP_MD_CTX_copy_ex(&tmp_ctx, ctx))\\r\\nreturn 0;\\r\\nif (sctx)\\r\\nr = tmp_ctx.pctx->pmeth->signctx(tmp_ctx.pctx,\\r\\nsigret, siglen, &tmp_ctx);\\r\\nelse\\r\\nr = EVP_DigestFinal_ex(&tmp_ctx, md, &mdlen);\\r\\nEVP_MD_CTX_cleanup(&tmp_ctx);\\r\\nif (sctx || !r)\\r\\nreturn r;\\r\\nif (EVP_PKEY_sign(ctx->pctx, sigret, siglen, md, mdlen) <= 0)\\r\\nreturn 0;\\r\\n} else {\\r\\nif (sctx) {\\r\\nif (pctx->pmeth->signctx(pctx, sigret, siglen, ctx) <= 0)\\r\\nreturn 0;\\r\\n} else {\\r\\nint s = EVP_MD_size(ctx->digest);\\r\\nif (s < 0 || EVP_PKEY_sign(pctx, sigret, siglen, NULL, s) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sig,\\r\\nsize_t siglen)\\r\\n{\\r\\nEVP_MD_CTX tmp_ctx;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nint r;\\r\\nunsigned int mdlen;\\r\\nint vctx;\\r\\nif (ctx->pctx->pmeth->verifyctx)\\r\\nvctx = 1;\\r\\nelse\\r\\nvctx = 0;\\r\\nEVP_MD_CTX_init(&tmp_ctx);\\r\\nif (!EVP_MD_CTX_copy_ex(&tmp_ctx, ctx))\\r\\nreturn -1;\\r\\nif (vctx) {\\r\\nr = tmp_ctx.pctx->pmeth->verifyctx(tmp_ctx.pctx,\\r\\nsig, siglen, &tmp_ctx);\\r\\n} else\\r\\nr = EVP_DigestFinal_ex(&tmp_ctx, md, &mdlen);\\r\\nEVP_MD_CTX_cleanup(&tmp_ctx);\\r\\nif (vctx || !r)\\r\\nreturn r;\\r\\nreturn EVP_PKEY_verify(ctx->pctx, sig, siglen, md, mdlen);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_asn1_c", "target": 0, "func": "static int rsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nif (operation == ASN1_OP_NEW_PRE) {\\r\\n*pval = (ASN1_VALUE *)RSA_new();\\r\\nif (*pval)\\r\\nreturn 2;\\r\\nreturn 0;\\r\\n} else if (operation == ASN1_OP_FREE_PRE) {\\r\\nRSA_free((RSA *)*pval);\\r\\n*pval = NULL;\\r\\nreturn 2;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nRSA *RSAPrivateKey_dup(RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_dup(ASN1_ITEM_rptr(RSAPrivateKey), rsa);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_prime_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint hex = 0;\\r\\nint checks = 20;\\r\\nint generate = 0;\\r\\nint bits = 0;\\r\\nint safe = 0;\\r\\nBIGNUM *bn = NULL;\\r\\nBIO *bio_out;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n--argc;\\r\\n++argv;\\r\\nwhile (argc >= 1 && **argv == '-') {\\r\\nif (!strcmp(*argv, \"-hex\"))\\r\\nhex = 1;\\r\\nelse if (!strcmp(*argv, \"-generate\"))\\r\\ngenerate = 1;\\r\\nelse if (!strcmp(*argv, \"-bits\"))\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nelse\\r\\nbits = atoi(*++argv);\\r\\nelse if (!strcmp(*argv, \"-safe\"))\\r\\nsafe = 1;\\r\\nelse if (!strcmp(*argv, \"-checks\"))\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nelse\\r\\nchecks = atoi(*++argv);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Unknown option '%s'\\n\", *argv);\\r\\ngoto bad;\\r\\n}\\r\\n--argc;\\r\\n++argv;\\r\\n}\\r\\nif (argv[0] == NULL && !generate) {\\r\\nBIO_printf(bio_err, \"No prime specified\\n\");\\r\\ngoto bad;\\r\\n}\\r\\nif ((bio_out = BIO_new(BIO_s_file())) != NULL) {\\r\\nBIO_set_fp(bio_out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nbio_out = BIO_push(tmpbio, bio_out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (generate) {\\r\\nchar *s;\\r\\nif (!bits) {\\r\\nBIO_printf(bio_err, \"Specifiy the number of bits.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nbn = BN_new();\\r\\nBN_generate_prime_ex(bn, bits, safe, NULL, NULL, NULL);\\r\\ns = hex ? BN_bn2hex(bn) : BN_bn2dec(bn);\\r\\nBIO_printf(bio_out, \"%s\\n\", s);\\r\\nOPENSSL_free(s);\\r\\n} else {\\r\\nif (hex)\\r\\nBN_hex2bn(&bn, argv[0]);\\r\\nelse\\r\\nBN_dec2bn(&bn, argv[0]);\\r\\nBN_print(bio_out, bn);\\r\\nBIO_printf(bio_out, \" is %sprime\\n\",\\r\\nBN_is_prime_ex(bn, checks, NULL, NULL) ? \"\" : \"not \");\\r\\n}\\r\\nBN_free(bn);\\r\\nBIO_free_all(bio_out);\\r\\nreturn 0;\\r\\nbad:\\r\\nBIO_printf(bio_err, \"options are\\n\");\\r\\nBIO_printf(bio_err, \"%-14s hex\\n\", \"-hex\");\\r\\nBIO_printf(bio_err, \"%-14s number of checks\\n\", \"-checks <n>\");\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_c_zlib_c", "target": 0, "func": "static void *zlib_zalloc(void *opaque, unsigned int no, unsigned int size)\\r\\n{\\r\\nvoid *p;\\r\\np = OPENSSL_malloc(no * size);\\r\\nif (p)\\r\\nmemset(p, 0, no * size);\\r\\nreturn p;\\r\\n}\\r\\nstatic void zlib_zfree(void *opaque, void *address)\\r\\n{\\r\\nOPENSSL_free(address);\\r\\n}\\r\\nstatic int zlib_stateful_init(COMP_CTX *ctx)\\r\\n{\\r\\nint err;\\r\\nstruct zlib_state *state =\\r\\n(struct zlib_state *)OPENSSL_malloc(sizeof(struct zlib_state));\\r\\nif (state == NULL)\\r\\ngoto err;\\r\\nstate->istream.zalloc = zlib_zalloc;\\r\\nstate->istream.zfree = zlib_zfree;\\r\\nstate->istream.opaque = Z_NULL;\\r\\nstate->istream.next_in = Z_NULL;\\r\\nstate->istream.next_out = Z_NULL;\\r\\nstate->istream.avail_in = 0;\\r\\nstate->istream.avail_out = 0;\\r\\nerr = inflateInit_(&state->istream, ZLIB_VERSION, sizeof(z_stream));\\r\\nif (err != Z_OK)\\r\\ngoto err;\\r\\nstate->ostream.zalloc = zlib_zalloc;\\r\\nstate->ostream.zfree = zlib_zfree;\\r\\nstate->ostream.opaque = Z_NULL;\\r\\nstate->ostream.next_in = Z_NULL;\\r\\nstate->ostream.next_out = Z_NULL;\\r\\nstate->ostream.avail_in = 0;\\r\\nstate->ostream.avail_out = 0;\\r\\nerr = deflateInit_(&state->ostream, Z_DEFAULT_COMPRESSION,\\r\\nZLIB_VERSION, sizeof(z_stream));\\r\\nif (err != Z_OK)\\r\\ngoto err;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_COMP, ctx, &ctx->ex_data);\\r\\nCRYPTO_set_ex_data(&ctx->ex_data, zlib_stateful_ex_idx, state);\\r\\nreturn 1;\\r\\nerr:\\r\\nif (state)\\r\\nOPENSSL_free(state);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void zlib_stateful_finish(COMP_CTX *ctx)\\r\\n{\\r\\nstruct zlib_state *state =\\r\\n(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\\r\\nzlib_stateful_ex_idx);\\r\\ninflateEnd(&state->istream);\\r\\ndeflateEnd(&state->ostream);\\r\\nOPENSSL_free(state);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP, ctx, &ctx->ex_data);\\r\\n}\\r\\nstatic int zlib_stateful_compress_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in,\\r\\nunsigned int ilen)\\r\\n{\\r\\nint err = Z_OK;\\r\\nstruct zlib_state *state =\\r\\n(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\\r\\nzlib_stateful_ex_idx);\\r\\nif (state == NULL)\\r\\nreturn -1;\\r\\nstate->ostream.next_in = in;\\r\\nstate->ostream.avail_in = ilen;\\r\\nstate->ostream.next_out = out;\\r\\nstate->ostream.avail_out = olen;\\r\\nif (ilen > 0)\\r\\nerr = deflate(&state->ostream, Z_SYNC_FLUSH);\\r\\nif (err != Z_OK)\\r\\nreturn -1;\\r\\n# ifdef DEBUG_ZLIB\\r\\nfprintf(stderr, \"compress(%4d)->%4d %s\\n\",\\r\\nilen, olen - state->ostream.avail_out,\\r\\n(ilen != olen - state->ostream.avail_out) ? \"zlib\" : \"clear\");\\r\\n# endif\\r\\nreturn olen - state->ostream.avail_out;\\r\\n}\\r\\nstatic int zlib_stateful_expand_block(COMP_CTX *ctx, unsigned char *out,\\r\\nunsigned int olen, unsigned char *in,\\r\\nunsigned int ilen)\\r\\n{\\r\\nint err = Z_OK;\\r\\nstruct zlib_state *state =\\r\\n(struct zlib_state *)CRYPTO_get_ex_data(&ctx->ex_data,\\r\\nzlib_stateful_ex_idx);\\r\\nif (state == NULL)\\r\\nreturn 0;\\r\\nstate->istream.next_in = in;\\r\\nstate->istream.avail_in = ilen;\\r\\nstate->istream.next_out = out;\\r\\nstate->istream.avail_out = olen;\\r\\nif (ilen > 0)\\r\\nerr = inflate(&state->istream, Z_SYNC_FLUSH);\\r\\nif (err != Z_OK)\\r\\nreturn -1;\\r\\n# ifdef DEBUG_ZLIB\\r\\nfprintf(stderr, \"expand(%4d)->%4d %s\\n\",\\r\\nilen, olen - state->istream.avail_out,\\r\\n(ilen != olen - state->istream.avail_out) ? \"zlib\" : \"clear\");\\r\\n# endif\\r\\nreturn olen - state->istream.avail_out;\\r\\n}\\r\\nCOMP_METHOD *COMP_zlib(void)\\r\\n{\\r\\nCOMP_METHOD *meth = &zlib_method_nozlib;\\r\\n#ifdef ZLIB_SHARED\\r\\nif (!zlib_loaded) {\\r\\n# if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)\\r\\nzlib_dso = DSO_load(NULL, \"ZLIB1\", NULL, 0);\\r\\n# else\\r\\nzlib_dso = DSO_load(NULL, \"z\", NULL, 0);\\r\\n# endif\\r\\nif (zlib_dso != NULL) {\\r\\np_compress = (compress_ft) DSO_bind_func(zlib_dso, \"compress\");\\r\\np_inflateEnd\\r\\n= (inflateEnd_ft) DSO_bind_func(zlib_dso, \"inflateEnd\");\\r\\np_inflate = (inflate_ft) DSO_bind_func(zlib_dso, \"inflate\");\\r\\np_inflateInit_\\r\\n= (inflateInit__ft) DSO_bind_func(zlib_dso, \"inflateInit_\");\\r\\np_deflateEnd\\r\\n= (deflateEnd_ft) DSO_bind_func(zlib_dso, \"deflateEnd\");\\r\\np_deflate = (deflate_ft) DSO_bind_func(zlib_dso, \"deflate\");\\r\\np_deflateInit_\\r\\n= (deflateInit__ft) DSO_bind_func(zlib_dso, \"deflateInit_\");\\r\\np_zError = (zError__ft) DSO_bind_func(zlib_dso, \"zError\");\\r\\nif (p_compress && p_inflateEnd && p_inflate\\r\\n&& p_inflateInit_ && p_deflateEnd\\r\\n&& p_deflate && p_deflateInit_ && p_zError)\\r\\nzlib_loaded++;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifdef ZLIB_SHARED\\r\\nif (zlib_loaded)\\r\\n#endif\\r\\n#if defined(ZLIB) || defined(ZLIB_SHARED)\\r\\n{\\r\\nif (zlib_stateful_ex_idx == -1) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_COMP);\\r\\nif (zlib_stateful_ex_idx == -1)\\r\\nzlib_stateful_ex_idx =\\r\\nCRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_COMP,\\r\\n0, NULL, NULL, NULL, NULL);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_COMP);\\r\\nif (zlib_stateful_ex_idx == -1)\\r\\ngoto err;\\r\\n}\\r\\nmeth = &zlib_stateful_method;\\r\\n}\\r\\nerr:\\r\\n#endif\\r\\nreturn (meth);\\r\\n}\\r\\nvoid COMP_zlib_cleanup(void)\\r\\n{\\r\\n#ifdef ZLIB_SHARED\\r\\nif (zlib_dso)\\r\\nDSO_free(zlib_dso);\\r\\n#endif\\r\\n}\\r\\nBIO_METHOD *BIO_f_zlib(void)\\r\\n{\\r\\nreturn &bio_meth_zlib;\\r\\n}\\r\\nstatic int bio_zlib_new(BIO *bi)\\r\\n{\\r\\nBIO_ZLIB_CTX *ctx;\\r\\n# ifdef ZLIB_SHARED\\r\\n(void)COMP_zlib();\\r\\nif (!zlib_loaded) {\\r\\nCOMPerr(COMP_F_BIO_ZLIB_NEW, COMP_R_ZLIB_NOT_SUPPORTED);\\r\\nreturn 0;\\r\\n}\\r\\n# endif\\r\\nctx = OPENSSL_malloc(sizeof(BIO_ZLIB_CTX));\\r\\nif (!ctx) {\\r\\nCOMPerr(COMP_F_BIO_ZLIB_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nctx->ibuf = NULL;\\r\\nctx->obuf = NULL;\\r\\nctx->ibufsize = ZLIB_DEFAULT_BUFSIZE;\\r\\nctx->obufsize = ZLIB_DEFAULT_BUFSIZE;\\r\\nctx->zin.zalloc = Z_NULL;\\r\\nctx->zin.zfree = Z_NULL;\\r\\nctx->zin.next_in = NULL;\\r\\nctx->zin.avail_in = 0;\\r\\nctx->zin.next_out = NULL;\\r\\nctx->zin.avail_out = 0;\\r\\nctx->zout.zalloc = Z_NULL;\\r\\nctx->zout.zfree = Z_NULL;\\r\\nctx->zout.next_in = NULL;\\r\\nctx->zout.avail_in = 0;\\r\\nctx->zout.next_out = NULL;\\r\\nctx->zout.avail_out = 0;\\r\\nctx->odone = 0;\\r\\nctx->comp_level = Z_DEFAULT_COMPRESSION;\\r\\nbi->init = 1;\\r\\nbi->ptr = (char *)ctx;\\r\\nbi->flags = 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bio_zlib_free(BIO *bi)\\r\\n{\\r\\nBIO_ZLIB_CTX *ctx;\\r\\nif (!bi)\\r\\nreturn 0;\\r\\nctx = (BIO_ZLIB_CTX *) bi->ptr;\\r\\nif (ctx->ibuf) {\\r\\ninflateEnd(&ctx->zin);\\r\\nOPENSSL_free(ctx->ibuf);\\r\\n}\\r\\nif (ctx->obuf) {\\r\\ndeflateEnd(&ctx->zout);\\r\\nOPENSSL_free(ctx->obuf);\\r\\n}\\r\\nOPENSSL_free(ctx);\\r\\nbi->ptr = NULL;\\r\\nbi->init = 0;\\r\\nbi->flags = 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bio_zlib_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nBIO_ZLIB_CTX *ctx;\\r\\nint ret;\\r\\nz_stream *zin;\\r\\nif (!out || !outl)\\r\\nreturn 0;\\r\\nctx = (BIO_ZLIB_CTX *) b->ptr;\\r\\nzin = &ctx->zin;\\r\\nBIO_clear_retry_flags(b);\\r\\nif (!ctx->ibuf) {\\r\\nctx->ibuf = OPENSSL_malloc(ctx->ibufsize);\\r\\nif (!ctx->ibuf) {\\r\\nCOMPerr(COMP_F_BIO_ZLIB_READ, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ninflateInit(zin);\\r\\nzin->next_in = ctx->ibuf;\\r\\nzin->avail_in = 0;\\r\\n}\\r\\nzin->next_out = (unsigned char *)out;\\r\\nzin->avail_out = (unsigned int)outl;\\r\\nfor (;;) {\\r\\nwhile (zin->avail_in) {\\r\\nret = inflate(zin, 0);\\r\\nif ((ret != Z_OK) && (ret != Z_STREAM_END)) {\\r\\nCOMPerr(COMP_F_BIO_ZLIB_READ, COMP_R_ZLIB_INFLATE_ERROR);\\r\\nERR_add_error_data(2, \"zlib error:\", zError(ret));\\r\\nreturn 0;\\r\\n}\\r\\nif ((ret == Z_STREAM_END) || !zin->avail_out)\\r\\nreturn outl - zin->avail_out;\\r\\n}\\r\\nret = BIO_read(b->next_bio, ctx->ibuf, ctx->ibufsize);\\r\\nif (ret <= 0) {\\r\\nint tot = outl - zin->avail_out;\\r\\nBIO_copy_next_retry(b);\\r\\nif (ret < 0)\\r\\nreturn (tot > 0) ? tot : ret;\\r\\nreturn tot;\\r\\n}\\r\\nzin->avail_in = ret;\\r\\nzin->next_in = ctx->ibuf;\\r\\n}\\r\\n}\\r\\nstatic int bio_zlib_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nBIO_ZLIB_CTX *ctx;\\r\\nint ret;\\r\\nz_stream *zout;\\r\\nif (!in || !inl)\\r\\nreturn 0;\\r\\nctx = (BIO_ZLIB_CTX *) b->ptr;\\r\\nif (ctx->odone)\\r\\nreturn 0;\\r\\nzout = &ctx->zout;\\r\\nBIO_clear_retry_flags(b);\\r\\nif (!ctx->obuf) {\\r\\nctx->obuf = OPENSSL_malloc(ctx->obufsize);\\r\\nif (!ctx->obuf) {\\r\\nCOMPerr(COMP_F_BIO_ZLIB_WRITE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nctx->optr = ctx->obuf;\\r\\nctx->ocount = 0;\\r\\ndeflateInit(zout, ctx->comp_level);\\r\\nzout->next_out = ctx->obuf;\\r\\nzout->avail_out = ctx->obufsize;\\r\\n}\\r\\nzout->next_in = (void *)in;\\r\\nzout->avail_in = inl;\\r\\nfor (;;) {\\r\\nwhile (ctx->ocount) {\\r\\nret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);\\r\\nif (ret <= 0) {\\r\\nint tot = inl - zout->avail_in;\\r\\nBIO_copy_next_retry(b);\\r\\nif (ret < 0)\\r\\nreturn (tot > 0) ? tot : ret;\\r\\nreturn tot;\\r\\n}\\r\\nctx->optr += ret;\\r\\nctx->ocount -= ret;\\r\\n}\\r\\nif (!zout->avail_in)\\r\\nreturn inl;\\r\\nctx->optr = ctx->obuf;\\r\\nzout->next_out = ctx->obuf;\\r\\nzout->avail_out = ctx->obufsize;\\r\\nret = deflate(zout, 0);\\r\\nif (ret != Z_OK) {\\r\\nCOMPerr(COMP_F_BIO_ZLIB_WRITE, COMP_R_ZLIB_DEFLATE_ERROR);\\r\\nERR_add_error_data(2, \"zlib error:\", zError(ret));\\r\\nreturn 0;\\r\\n}\\r\\nctx->ocount = ctx->obufsize - zout->avail_out;\\r\\n}\\r\\n}\\r\\nstatic int bio_zlib_flush(BIO *b)\\r\\n{\\r\\nBIO_ZLIB_CTX *ctx;\\r\\nint ret;\\r\\nz_stream *zout;\\r\\nctx = (BIO_ZLIB_CTX *) b->ptr;\\r\\nif (!ctx->obuf || (ctx->odone && !ctx->ocount))\\r\\nreturn 1;\\r\\nzout = &ctx->zout;\\r\\nBIO_clear_retry_flags(b);\\r\\nzout->next_in = NULL;\\r\\nzout->avail_in = 0;\\r\\nfor (;;) {\\r\\nwhile (ctx->ocount) {\\r\\nret = BIO_write(b->next_bio, ctx->optr, ctx->ocount);\\r\\nif (ret <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nreturn ret;\\r\\n}\\r\\nctx->optr += ret;\\r\\nctx->ocount -= ret;\\r\\n}\\r\\nif (ctx->odone)\\r\\nreturn 1;\\r\\nctx->optr = ctx->obuf;\\r\\nzout->next_out = ctx->obuf;\\r\\nzout->avail_out = ctx->obufsize;\\r\\nret = deflate(zout, Z_FINISH);\\r\\nif (ret == Z_STREAM_END)\\r\\nctx->odone = 1;\\r\\nelse if (ret != Z_OK) {\\r\\nCOMPerr(COMP_F_BIO_ZLIB_FLUSH, COMP_R_ZLIB_DEFLATE_ERROR);\\r\\nERR_add_error_data(2, \"zlib error:\", zError(ret));\\r\\nreturn 0;\\r\\n}\\r\\nctx->ocount = ctx->obufsize - zout->avail_out;\\r\\n}\\r\\n}\\r\\nstatic long bio_zlib_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO_ZLIB_CTX *ctx;\\r\\nint ret, *ip;\\r\\nint ibs, obs;\\r\\nif (!b->next_bio)\\r\\nreturn 0;\\r\\nctx = (BIO_ZLIB_CTX *) b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->ocount = 0;\\r\\nctx->odone = 0;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret = bio_zlib_flush(b);\\r\\nif (ret > 0)\\r\\nret = BIO_flush(b->next_bio);\\r\\nbreak;\\r\\ncase BIO_C_SET_BUFF_SIZE:\\r\\nibs = -1;\\r\\nobs = -1;\\r\\nif (ptr != NULL) {\\r\\nip = ptr;\\r\\nif (*ip == 0)\\r\\nibs = (int)num;\\r\\nelse\\r\\nobs = (int)num;\\r\\n} else {\\r\\nibs = (int)num;\\r\\nobs = ibs;\\r\\n}\\r\\nif (ibs != -1) {\\r\\nif (ctx->ibuf) {\\r\\nOPENSSL_free(ctx->ibuf);\\r\\nctx->ibuf = NULL;\\r\\n}\\r\\nctx->ibufsize = ibs;\\r\\n}\\r\\nif (obs != -1) {\\r\\nif (ctx->obuf) {\\r\\nOPENSSL_free(ctx->obuf);\\r\\nctx->obuf = NULL;\\r\\n}\\r\\nctx->obufsize = obs;\\r\\n}\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ndefault:\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic long bio_zlib_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nif (!b->next_bio)\\r\\nreturn 0;\\r\\nreturn BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_enc_c", "target": 0, "func": "static void show_ciphers(const OBJ_NAME *name, void *bio_)\\r\\n{\\r\\nBIO *bio = bio_;\\r\\nstatic int n;\\r\\nif (!islower((unsigned char)*name->name))\\r\\nreturn;\\r\\nBIO_printf(bio, \"-%-25s\", name->name);\\r\\nif (++n == 3) {\\r\\nBIO_printf(bio, \"\\n\");\\r\\nn = 0;\\r\\n} else\\r\\nBIO_printf(bio, \" \");\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nstatic const char magic[] = \"Salted__\";\\r\\nchar mbuf[sizeof magic - 1];\\r\\nchar *strbuf = NULL;\\r\\nunsigned char *buff = NULL, *bufsize = NULL;\\r\\nint bsize = BSIZE, verbose = 0;\\r\\nint ret = 1, inl;\\r\\nint nopad = 0;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char salt[PKCS5_SALT_LEN];\\r\\nchar *str = NULL, *passarg = NULL, *pass = NULL;\\r\\nchar *hkey = NULL, *hiv = NULL, *hsalt = NULL;\\r\\nchar *md = NULL;\\r\\nint enc = 1, printkey = 0, i, base64 = 0;\\r\\n#ifdef ZLIB\\r\\nint do_zlib = 0;\\r\\nBIO *bzl = NULL;\\r\\n#endif\\r\\nint debug = 0, olb64 = 0, nosalt = 0;\\r\\nconst EVP_CIPHER *cipher = NULL, *c;\\r\\nEVP_CIPHER_CTX *ctx = NULL;\\r\\nchar *inf = NULL, *outf = NULL;\\r\\nBIO *in = NULL, *out = NULL, *b64 = NULL, *benc = NULL, *rbio =\\r\\nNULL, *wbio = NULL;\\r\\n#define PROG_NAME_SIZE 39\\r\\nchar pname[PROG_NAME_SIZE + 1];\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nconst EVP_MD *dgst = NULL;\\r\\nint non_fips_allow = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nprogram_name(argv[0], pname, sizeof pname);\\r\\nif (strcmp(pname, \"base64\") == 0)\\r\\nbase64 = 1;\\r\\n#ifdef ZLIB\\r\\nif (strcmp(pname, \"zlib\") == 0)\\r\\ndo_zlib = 1;\\r\\n#endif\\r\\ncipher = EVP_get_cipherbyname(pname);\\r\\n#ifdef ZLIB\\r\\nif (!do_zlib && !base64 && (cipher == NULL)\\r\\n&& (strcmp(pname, \"enc\") != 0))\\r\\n#else\\r\\nif (!base64 && (cipher == NULL) && (strcmp(pname, \"enc\") != 0))\\r\\n#endif\\r\\n{\\r\\nBIO_printf(bio_err, \"%s is an unknown cipher\\n\", pname);\\r\\ngoto bad;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-e\") == 0)\\r\\nenc = 1;\\r\\nelse if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninf = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutf = *(++argv);\\r\\n} else if (strcmp(*argv, \"-pass\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassarg = *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-d\") == 0)\\r\\nenc = 0;\\r\\nelse if (strcmp(*argv, \"-p\") == 0)\\r\\nprintkey = 1;\\r\\nelse if (strcmp(*argv, \"-v\") == 0)\\r\\nverbose = 1;\\r\\nelse if (strcmp(*argv, \"-nopad\") == 0)\\r\\nnopad = 1;\\r\\nelse if (strcmp(*argv, \"-salt\") == 0)\\r\\nnosalt = 0;\\r\\nelse if (strcmp(*argv, \"-nosalt\") == 0)\\r\\nnosalt = 1;\\r\\nelse if (strcmp(*argv, \"-debug\") == 0)\\r\\ndebug = 1;\\r\\nelse if (strcmp(*argv, \"-P\") == 0)\\r\\nprintkey = 2;\\r\\nelse if (strcmp(*argv, \"-A\") == 0)\\r\\nolb64 = 1;\\r\\nelse if (strcmp(*argv, \"-a\") == 0)\\r\\nbase64 = 1;\\r\\nelse if (strcmp(*argv, \"-base64\") == 0)\\r\\nbase64 = 1;\\r\\n#ifdef ZLIB\\r\\nelse if (strcmp(*argv, \"-z\") == 0)\\r\\ndo_zlib = 1;\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-bufsize\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nbufsize = (unsigned char *)*(++argv);\\r\\n} else if (strcmp(*argv, \"-k\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nstr = *(++argv);\\r\\n} else if (strcmp(*argv, \"-kfile\") == 0) {\\r\\nstatic char buf[128];\\r\\nFILE *infile;\\r\\nchar *file;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nfile = *(++argv);\\r\\ninfile = fopen(file, \"r\");\\r\\nif (infile == NULL) {\\r\\nBIO_printf(bio_err, \"unable to read key from '%s'\\n\", file);\\r\\ngoto bad;\\r\\n}\\r\\nbuf[0] = '\\0';\\r\\nif (!fgets(buf, sizeof buf, infile)) {\\r\\nBIO_printf(bio_err, \"unable to read key from '%s'\\n\", file);\\r\\ngoto bad;\\r\\n}\\r\\nfclose(infile);\\r\\ni = strlen(buf);\\r\\nif ((i > 0) && ((buf[i - 1] == '\\n') || (buf[i - 1] == '\\r')))\\r\\nbuf[--i] = '\\0';\\r\\nif ((i > 0) && ((buf[i - 1] == '\\n') || (buf[i - 1] == '\\r')))\\r\\nbuf[--i] = '\\0';\\r\\nif (i < 1) {\\r\\nBIO_printf(bio_err, \"zero length password\\n\");\\r\\ngoto bad;\\r\\n}\\r\\nstr = buf;\\r\\n} else if (strcmp(*argv, \"-K\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nhkey = *(++argv);\\r\\n} else if (strcmp(*argv, \"-S\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nhsalt = *(++argv);\\r\\n} else if (strcmp(*argv, \"-iv\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nhiv = *(++argv);\\r\\n} else if (strcmp(*argv, \"-md\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nmd = *(++argv);\\r\\n} else if (strcmp(*argv, \"-non-fips-allow\") == 0)\\r\\nnon_fips_allow = 1;\\r\\nelse if ((argv[0][0] == '-') &&\\r\\n((c = EVP_get_cipherbyname(&(argv[0][1]))) != NULL)) {\\r\\ncipher = c;\\r\\n} else if (strcmp(*argv, \"-none\") == 0)\\r\\ncipher = NULL;\\r\\nelse {\\r\\nBIO_printf(bio_err, \"unknown option '%s'\\n\", *argv);\\r\\nbad:\\r\\nBIO_printf(bio_err, \"options are\\n\");\\r\\nBIO_printf(bio_err, \"%-14s input file\\n\", \"-in <file>\");\\r\\nBIO_printf(bio_err, \"%-14s output file\\n\", \"-out <file>\");\\r\\nBIO_printf(bio_err, \"%-14s pass phrase source\\n\", \"-pass <arg>\");\\r\\nBIO_printf(bio_err, \"%-14s encrypt\\n\", \"-e\");\\r\\nBIO_printf(bio_err, \"%-14s decrypt\\n\", \"-d\");\\r\\nBIO_printf(bio_err,\\r\\n\"%-14s base64 encode/decode, depending on encryption flag\\n\",\\r\\n\"-a/-base64\");\\r\\nBIO_printf(bio_err, \"%-14s passphrase is the next argument\\n\",\\r\\n\"-k\");\\r\\nBIO_printf(bio_err,\\r\\n\"%-14s passphrase is the first line of the file argument\\n\",\\r\\n\"-kfile\");\\r\\nBIO_printf(bio_err,\\r\\n\"%-14s the next argument is the md to use to create a key\\n\",\\r\\n\"-md\");\\r\\nBIO_printf(bio_err,\\r\\n\"%-14s from a passphrase. One of md2, md5, sha or sha1\\n\",\\r\\n\"\");\\r\\nBIO_printf(bio_err, \"%-14s salt in hex is the next argument\\n\",\\r\\n\"-S\");\\r\\nBIO_printf(bio_err, \"%-14s key/iv in hex is the next argument\\n\",\\r\\n\"-K/-iv\");\\r\\nBIO_printf(bio_err, \"%-14s print the iv/key (then exit if -P)\\n\",\\r\\n\"-[pP]\");\\r\\nBIO_printf(bio_err, \"%-14s buffer size\\n\", \"-bufsize <n>\");\\r\\nBIO_printf(bio_err, \"%-14s disable standard block padding\\n\",\\r\\n\"-nopad\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"%-14s use engine e, possibly a hardware device.\\n\",\\r\\n\"-engine e\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \"Cipher Types\\n\");\\r\\nOBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_CIPHER_METH,\\r\\nshow_ciphers, bio_err);\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\ngoto end;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (cipher && EVP_CIPHER_flags(cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) {\\r\\nBIO_printf(bio_err,\\r\\n\"AEAD ciphers not supported by the enc utility\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (cipher && (EVP_CIPHER_mode(cipher) == EVP_CIPH_XTS_MODE)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Ciphers in XTS mode are not supported by the enc utility\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (md && (dgst = EVP_get_digestbyname(md)) == NULL) {\\r\\nBIO_printf(bio_err, \"%s is an unsupported message digest type\\n\", md);\\r\\ngoto end;\\r\\n}\\r\\nif (dgst == NULL) {\\r\\ndgst = EVP_md5();\\r\\n}\\r\\nif (bufsize != NULL) {\\r\\nunsigned long n;\\r\\nfor (n = 0; *bufsize; bufsize++) {\\r\\ni = *bufsize;\\r\\nif ((i <= '9') && (i >= '0'))\\r\\nn = n * 10 + i - '0';\\r\\nelse if (i == 'k') {\\r\\nn *= 1024;\\r\\nbufsize++;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (*bufsize != '\\0') {\\r\\nBIO_printf(bio_err, \"invalid 'bufsize' specified.\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (base64 && n < 80)\\r\\nn = 80;\\r\\nbsize = (int)n;\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"bufsize=%d\\n\", bsize);\\r\\n}\\r\\nstrbuf = OPENSSL_malloc(SIZE);\\r\\nbuff = (unsigned char *)OPENSSL_malloc(EVP_ENCODE_LENGTH(bsize));\\r\\nif ((buff == NULL) || (strbuf == NULL)) {\\r\\nBIO_printf(bio_err, \"OPENSSL_malloc failure %ld\\n\",\\r\\n(long)EVP_ENCODE_LENGTH(bsize));\\r\\ngoto end;\\r\\n}\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (debug) {\\r\\nBIO_set_callback(in, BIO_debug_callback);\\r\\nBIO_set_callback(out, BIO_debug_callback);\\r\\nBIO_set_callback_arg(in, (char *)bio_err);\\r\\nBIO_set_callback_arg(out, (char *)bio_err);\\r\\n}\\r\\nif (inf == NULL) {\\r\\n#ifndef OPENSSL_NO_SETVBUF_IONBF\\r\\nif (bufsize != NULL)\\r\\nsetvbuf(stdin, (char *)NULL, _IONBF, 0);\\r\\n#endif\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\n} else {\\r\\nif (BIO_read_filename(in, inf) <= 0) {\\r\\nperror(inf);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!str && passarg) {\\r\\nif (!app_passwd(bio_err, passarg, NULL, &pass, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nstr = pass;\\r\\n}\\r\\nif ((str == NULL) && (cipher != NULL) && (hkey == NULL)) {\\r\\nfor (;;) {\\r\\nchar buf[200];\\r\\nBIO_snprintf(buf, sizeof buf, \"enter %s %s password:\",\\r\\nOBJ_nid2ln(EVP_CIPHER_nid(cipher)),\\r\\n(enc) ? \"encryption\" : \"decryption\");\\r\\nstrbuf[0] = '\\0';\\r\\ni = EVP_read_pw_string((char *)strbuf, SIZE, buf, enc);\\r\\nif (i == 0) {\\r\\nif (strbuf[0] == '\\0') {\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nstr = strbuf;\\r\\nbreak;\\r\\n}\\r\\nif (i < 0) {\\r\\nBIO_printf(bio_err, \"bad password read\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (outf == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n#ifndef OPENSSL_NO_SETVBUF_IONBF\\r\\nif (bufsize != NULL)\\r\\nsetvbuf(stdout, (char *)NULL, _IONBF, 0);\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outf) <= 0) {\\r\\nperror(outf);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nrbio = in;\\r\\nwbio = out;\\r\\n#ifdef ZLIB\\r\\nif (do_zlib) {\\r\\nif ((bzl = BIO_new(BIO_f_zlib())) == NULL)\\r\\ngoto end;\\r\\nif (enc)\\r\\nwbio = BIO_push(bzl, wbio);\\r\\nelse\\r\\nrbio = BIO_push(bzl, rbio);\\r\\n}\\r\\n#endif\\r\\nif (base64) {\\r\\nif ((b64 = BIO_new(BIO_f_base64())) == NULL)\\r\\ngoto end;\\r\\nif (debug) {\\r\\nBIO_set_callback(b64, BIO_debug_callback);\\r\\nBIO_set_callback_arg(b64, (char *)bio_err);\\r\\n}\\r\\nif (olb64)\\r\\nBIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\\r\\nif (enc)\\r\\nwbio = BIO_push(b64, wbio);\\r\\nelse\\r\\nrbio = BIO_push(b64, rbio);\\r\\n}\\r\\nif (cipher != NULL) {\\r\\nif (str != NULL) {\\r\\nunsigned char *sptr;\\r\\nif (nosalt)\\r\\nsptr = NULL;\\r\\nelse {\\r\\nif (enc) {\\r\\nif (hsalt) {\\r\\nif (!set_hex(hsalt, salt, sizeof salt)) {\\r\\nBIO_printf(bio_err, \"invalid hex salt value\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else if (RAND_pseudo_bytes(salt, sizeof salt) < 0)\\r\\ngoto end;\\r\\nif ((printkey != 2)\\r\\n&& (BIO_write(wbio, magic,\\r\\nsizeof magic - 1) != sizeof magic - 1\\r\\n|| BIO_write(wbio,\\r\\n(char *)salt,\\r\\nsizeof salt) != sizeof salt)) {\\r\\nBIO_printf(bio_err, \"error writing output file\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else if (BIO_read(rbio, mbuf, sizeof mbuf) != sizeof mbuf\\r\\n|| BIO_read(rbio,\\r\\n(unsigned char *)salt,\\r\\nsizeof salt) != sizeof salt) {\\r\\nBIO_printf(bio_err, \"error reading input file\\n\");\\r\\ngoto end;\\r\\n} else if (memcmp(mbuf, magic, sizeof magic - 1)) {\\r\\nBIO_printf(bio_err, \"bad magic number\\n\");\\r\\ngoto end;\\r\\n}\\r\\nsptr = salt;\\r\\n}\\r\\nEVP_BytesToKey(cipher, dgst, sptr,\\r\\n(unsigned char *)str, strlen(str), 1, key, iv);\\r\\nif (str == strbuf)\\r\\nOPENSSL_cleanse(str, SIZE);\\r\\nelse\\r\\nOPENSSL_cleanse(str, strlen(str));\\r\\n}\\r\\nif ((hiv != NULL) && !set_hex(hiv, iv, sizeof iv)) {\\r\\nBIO_printf(bio_err, \"invalid hex iv value\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((hiv == NULL) && (str == NULL)\\r\\n&& EVP_CIPHER_iv_length(cipher) != 0) {\\r\\nBIO_printf(bio_err, \"iv undefined\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((hkey != NULL) && !set_hex(hkey, key, sizeof key)) {\\r\\nBIO_printf(bio_err, \"invalid hex key value\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((benc = BIO_new(BIO_f_cipher())) == NULL)\\r\\ngoto end;\\r\\nBIO_get_cipher_ctx(benc, &ctx);\\r\\nif (non_fips_allow)\\r\\nEVP_CIPHER_CTX_set_flags(ctx, EVP_CIPH_FLAG_NON_FIPS_ALLOW);\\r\\nif (!EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, enc)) {\\r\\nBIO_printf(bio_err, \"Error setting cipher %s\\n\",\\r\\nEVP_CIPHER_name(cipher));\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (nopad)\\r\\nEVP_CIPHER_CTX_set_padding(ctx, 0);\\r\\nif (!EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, enc)) {\\r\\nBIO_printf(bio_err, \"Error setting cipher %s\\n\",\\r\\nEVP_CIPHER_name(cipher));\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (debug) {\\r\\nBIO_set_callback(benc, BIO_debug_callback);\\r\\nBIO_set_callback_arg(benc, (char *)bio_err);\\r\\n}\\r\\nif (printkey) {\\r\\nif (!nosalt) {\\r\\nprintf(\"salt=\");\\r\\nfor (i = 0; i < (int)sizeof(salt); i++)\\r\\nprintf(\"%02X\", salt[i]);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nif (cipher->key_len > 0) {\\r\\nprintf(\"key=\");\\r\\nfor (i = 0; i < cipher->key_len; i++)\\r\\nprintf(\"%02X\", key[i]);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nif (cipher->iv_len > 0) {\\r\\nprintf(\"iv =\");\\r\\nfor (i = 0; i < cipher->iv_len; i++)\\r\\nprintf(\"%02X\", iv[i]);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nif (printkey == 2) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (benc != NULL)\\r\\nwbio = BIO_push(benc, wbio);\\r\\nfor (;;) {\\r\\ninl = BIO_read(rbio, (char *)buff, bsize);\\r\\nif (inl <= 0)\\r\\nbreak;\\r\\nif (BIO_write(wbio, (char *)buff, inl) != inl) {\\r\\nBIO_printf(bio_err, \"error writing output file\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!BIO_flush(wbio)) {\\r\\nBIO_printf(bio_err, \"bad decrypt\\n\");\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nif (verbose) {\\r\\nBIO_printf(bio_err, \"bytes read :%8ld\\n\", BIO_number_read(in));\\r\\nBIO_printf(bio_err, \"bytes written:%8ld\\n\", BIO_number_written(out));\\r\\n}\\r\\nend:\\r\\nERR_print_errors(bio_err);\\r\\nif (strbuf != NULL)\\r\\nOPENSSL_free(strbuf);\\r\\nif (buff != NULL)\\r\\nOPENSSL_free(buff);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (benc != NULL)\\r\\nBIO_free(benc);\\r\\nif (b64 != NULL)\\r\\nBIO_free(b64);\\r\\n#ifdef ZLIB\\r\\nif (bzl != NULL)\\r\\nBIO_free(bzl);\\r\\n#endif\\r\\nif (pass)\\r\\nOPENSSL_free(pass);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nint set_hex(char *in, unsigned char *out, int size)\\r\\n{\\r\\nint i, n;\\r\\nunsigned char j;\\r\\nn = strlen(in);\\r\\nif (n > (size * 2)) {\\r\\nBIO_printf(bio_err, \"hex string is too long\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nmemset(out, 0, size);\\r\\nfor (i = 0; i < n; i++) {\\r\\nj = (unsigned char)*in;\\r\\n*(in++) = '\\0';\\r\\nif (j == 0)\\r\\nbreak;\\r\\nif ((j >= '0') && (j <= '9'))\\r\\nj -= '0';\\r\\nelse if ((j >= 'A') && (j <= 'F'))\\r\\nj = j - 'A' + 10;\\r\\nelse if ((j >= 'a') && (j <= 'f'))\\r\\nj = j - 'a' + 10;\\r\\nelse {\\r\\nBIO_printf(bio_err, \"non-hex digit\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nif (i & 1)\\r\\nout[i / 2] |= j;\\r\\nelse\\r\\nout[i / 2] = (j << 4);\\r\\n}\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_att_c", "target": 0, "func": "int CMS_signed_get_attr_count(const CMS_SignerInfo *si)\\r\\n{\\r\\nreturn X509at_get_attr_count(si->signedAttrs);\\r\\n}\\r\\nint CMS_signed_get_attr_by_NID(const CMS_SignerInfo *si, int nid, int lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_NID(si->signedAttrs, nid, lastpos);\\r\\n}\\r\\nint CMS_signed_get_attr_by_OBJ(const CMS_SignerInfo *si, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_OBJ(si->signedAttrs, obj, lastpos);\\r\\n}\\r\\nX509_ATTRIBUTE *CMS_signed_get_attr(const CMS_SignerInfo *si, int loc)\\r\\n{\\r\\nreturn X509at_get_attr(si->signedAttrs, loc);\\r\\n}\\r\\nX509_ATTRIBUTE *CMS_signed_delete_attr(CMS_SignerInfo *si, int loc)\\r\\n{\\r\\nreturn X509at_delete_attr(si->signedAttrs, loc);\\r\\n}\\r\\nint CMS_signed_add1_attr(CMS_SignerInfo *si, X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif (X509at_add1_attr(&si->signedAttrs, attr))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_signed_add1_attr_by_OBJ(CMS_SignerInfo *si,\\r\\nconst ASN1_OBJECT *obj, int type,\\r\\nconst void *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_OBJ(&si->signedAttrs, obj, type, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_signed_add1_attr_by_NID(CMS_SignerInfo *si,\\r\\nint nid, int type, const void *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&si->signedAttrs, nid, type, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_signed_add1_attr_by_txt(CMS_SignerInfo *si,\\r\\nconst char *attrname, int type,\\r\\nconst void *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_txt(&si->signedAttrs, attrname, type, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nvoid *CMS_signed_get0_data_by_OBJ(CMS_SignerInfo *si, ASN1_OBJECT *oid,\\r\\nint lastpos, int type)\\r\\n{\\r\\nreturn X509at_get0_data_by_OBJ(si->signedAttrs, oid, lastpos, type);\\r\\n}\\r\\nint CMS_unsigned_get_attr_count(const CMS_SignerInfo *si)\\r\\n{\\r\\nreturn X509at_get_attr_count(si->unsignedAttrs);\\r\\n}\\r\\nint CMS_unsigned_get_attr_by_NID(const CMS_SignerInfo *si, int nid,\\r\\nint lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_NID(si->unsignedAttrs, nid, lastpos);\\r\\n}\\r\\nint CMS_unsigned_get_attr_by_OBJ(const CMS_SignerInfo *si, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_OBJ(si->unsignedAttrs, obj, lastpos);\\r\\n}\\r\\nX509_ATTRIBUTE *CMS_unsigned_get_attr(const CMS_SignerInfo *si, int loc)\\r\\n{\\r\\nreturn X509at_get_attr(si->unsignedAttrs, loc);\\r\\n}\\r\\nX509_ATTRIBUTE *CMS_unsigned_delete_attr(CMS_SignerInfo *si, int loc)\\r\\n{\\r\\nreturn X509at_delete_attr(si->unsignedAttrs, loc);\\r\\n}\\r\\nint CMS_unsigned_add1_attr(CMS_SignerInfo *si, X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif (X509at_add1_attr(&si->unsignedAttrs, attr))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_unsigned_add1_attr_by_OBJ(CMS_SignerInfo *si,\\r\\nconst ASN1_OBJECT *obj, int type,\\r\\nconst void *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_OBJ(&si->unsignedAttrs, obj, type, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_unsigned_add1_attr_by_NID(CMS_SignerInfo *si,\\r\\nint nid, int type,\\r\\nconst void *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&si->unsignedAttrs, nid, type, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_unsigned_add1_attr_by_txt(CMS_SignerInfo *si,\\r\\nconst char *attrname, int type,\\r\\nconst void *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_txt(&si->unsignedAttrs, attrname,\\r\\ntype, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nvoid *CMS_unsigned_get0_data_by_OBJ(CMS_SignerInfo *si, ASN1_OBJECT *oid,\\r\\nint lastpos, int type)\\r\\n{\\r\\nreturn X509at_get0_data_by_OBJ(si->unsignedAttrs, oid, lastpos, type);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_by_dir_c", "target": 0, "func": "X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void)\\r\\n{\\r\\nreturn (&x509_dir_lookup);\\r\\n}\\r\\nstatic int dir_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\\r\\nchar **retp)\\r\\n{\\r\\nint ret = 0;\\r\\nBY_DIR *ld;\\r\\nchar *dir = NULL;\\r\\nld = (BY_DIR *)ctx->method_data;\\r\\nswitch (cmd) {\\r\\ncase X509_L_ADD_DIR:\\r\\nif (argl == X509_FILETYPE_DEFAULT) {\\r\\ndir = (char *)getenv(X509_get_default_cert_dir_env());\\r\\nif (dir)\\r\\nret = add_cert_dir(ld, dir, X509_FILETYPE_PEM);\\r\\nelse\\r\\nret = add_cert_dir(ld, X509_get_default_cert_dir(),\\r\\nX509_FILETYPE_PEM);\\r\\nif (!ret) {\\r\\nX509err(X509_F_DIR_CTRL, X509_R_LOADING_CERT_DIR);\\r\\n}\\r\\n} else\\r\\nret = add_cert_dir(ld, argp, (int)argl);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int new_dir(X509_LOOKUP *lu)\\r\\n{\\r\\nBY_DIR *a;\\r\\nif ((a = (BY_DIR *)OPENSSL_malloc(sizeof(BY_DIR))) == NULL)\\r\\nreturn (0);\\r\\nif ((a->buffer = BUF_MEM_new()) == NULL) {\\r\\nOPENSSL_free(a);\\r\\nreturn (0);\\r\\n}\\r\\na->dirs = NULL;\\r\\nlu->method_data = (char *)a;\\r\\nreturn (1);\\r\\n}\\r\\nstatic void by_dir_hash_free(BY_DIR_HASH *hash)\\r\\n{\\r\\nOPENSSL_free(hash);\\r\\n}\\r\\nstatic int by_dir_hash_cmp(const BY_DIR_HASH *const *a,\\r\\nconst BY_DIR_HASH *const *b)\\r\\n{\\r\\nif ((*a)->hash > (*b)->hash)\\r\\nreturn 1;\\r\\nif ((*a)->hash < (*b)->hash)\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic void by_dir_entry_free(BY_DIR_ENTRY *ent)\\r\\n{\\r\\nif (ent->dir)\\r\\nOPENSSL_free(ent->dir);\\r\\nif (ent->hashes)\\r\\nsk_BY_DIR_HASH_pop_free(ent->hashes, by_dir_hash_free);\\r\\nOPENSSL_free(ent);\\r\\n}\\r\\nstatic void free_dir(X509_LOOKUP *lu)\\r\\n{\\r\\nBY_DIR *a;\\r\\na = (BY_DIR *)lu->method_data;\\r\\nif (a->dirs != NULL)\\r\\nsk_BY_DIR_ENTRY_pop_free(a->dirs, by_dir_entry_free);\\r\\nif (a->buffer != NULL)\\r\\nBUF_MEM_free(a->buffer);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nstatic int add_cert_dir(BY_DIR *ctx, const char *dir, int type)\\r\\n{\\r\\nint j, len;\\r\\nconst char *s, *ss, *p;\\r\\nif (dir == NULL || !*dir) {\\r\\nX509err(X509_F_ADD_CERT_DIR, X509_R_INVALID_DIRECTORY);\\r\\nreturn 0;\\r\\n}\\r\\ns = dir;\\r\\np = s;\\r\\ndo {\\r\\nif ((*p == LIST_SEPARATOR_CHAR) || (*p == '\\0')) {\\r\\nBY_DIR_ENTRY *ent;\\r\\nss = s;\\r\\ns = p + 1;\\r\\nlen = (int)(p - ss);\\r\\nif (len == 0)\\r\\ncontinue;\\r\\nfor (j = 0; j < sk_BY_DIR_ENTRY_num(ctx->dirs); j++) {\\r\\nent = sk_BY_DIR_ENTRY_value(ctx->dirs, j);\\r\\nif (strlen(ent->dir) == (size_t)len &&\\r\\nstrncmp(ent->dir, ss, (unsigned int)len) == 0)\\r\\nbreak;\\r\\n}\\r\\nif (j < sk_BY_DIR_ENTRY_num(ctx->dirs))\\r\\ncontinue;\\r\\nif (ctx->dirs == NULL) {\\r\\nctx->dirs = sk_BY_DIR_ENTRY_new_null();\\r\\nif (!ctx->dirs) {\\r\\nX509err(X509_F_ADD_CERT_DIR, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nent = OPENSSL_malloc(sizeof(BY_DIR_ENTRY));\\r\\nif (!ent)\\r\\nreturn 0;\\r\\nent->dir_type = type;\\r\\nent->hashes = sk_BY_DIR_HASH_new(by_dir_hash_cmp);\\r\\nent->dir = OPENSSL_malloc((unsigned int)len + 1);\\r\\nif (!ent->dir || !ent->hashes) {\\r\\nby_dir_entry_free(ent);\\r\\nreturn 0;\\r\\n}\\r\\nstrncpy(ent->dir, ss, (unsigned int)len);\\r\\nent->dir[len] = '\\0';\\r\\nif (!sk_BY_DIR_ENTRY_push(ctx->dirs, ent)) {\\r\\nby_dir_entry_free(ent);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n} while (*p++ != '\\0');\\r\\nreturn 1;\\r\\n}\\r\\nstatic int get_cert_by_subject(X509_LOOKUP *xl, int type, X509_NAME *name,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nBY_DIR *ctx;\\r\\nunion {\\r\\nstruct {\\r\\nX509 st_x509;\\r\\nX509_CINF st_x509_cinf;\\r\\n} x509;\\r\\nstruct {\\r\\nX509_CRL st_crl;\\r\\nX509_CRL_INFO st_crl_info;\\r\\n} crl;\\r\\n} data;\\r\\nint ok = 0;\\r\\nint i, j, k;\\r\\nunsigned long h;\\r\\nBUF_MEM *b = NULL;\\r\\nX509_OBJECT stmp, *tmp;\\r\\nconst char *postfix = \"\";\\r\\nif (name == NULL)\\r\\nreturn (0);\\r\\nstmp.type = type;\\r\\nif (type == X509_LU_X509) {\\r\\ndata.x509.st_x509.cert_info = &data.x509.st_x509_cinf;\\r\\ndata.x509.st_x509_cinf.subject = name;\\r\\nstmp.data.x509 = &data.x509.st_x509;\\r\\npostfix = \"\";\\r\\n} else if (type == X509_LU_CRL) {\\r\\ndata.crl.st_crl.crl = &data.crl.st_crl_info;\\r\\ndata.crl.st_crl_info.issuer = name;\\r\\nstmp.data.crl = &data.crl.st_crl;\\r\\npostfix = \"r\";\\r\\n} else {\\r\\nX509err(X509_F_GET_CERT_BY_SUBJECT, X509_R_WRONG_LOOKUP_TYPE);\\r\\ngoto finish;\\r\\n}\\r\\nif ((b = BUF_MEM_new()) == NULL) {\\r\\nX509err(X509_F_GET_CERT_BY_SUBJECT, ERR_R_BUF_LIB);\\r\\ngoto finish;\\r\\n}\\r\\nctx = (BY_DIR *)xl->method_data;\\r\\nh = X509_NAME_hash(name);\\r\\nfor (i = 0; i < sk_BY_DIR_ENTRY_num(ctx->dirs); i++) {\\r\\nBY_DIR_ENTRY *ent;\\r\\nint idx;\\r\\nBY_DIR_HASH htmp, *hent;\\r\\nent = sk_BY_DIR_ENTRY_value(ctx->dirs, i);\\r\\nj = strlen(ent->dir) + 1 + 8 + 6 + 1 + 1;\\r\\nif (!BUF_MEM_grow(b, j)) {\\r\\nX509err(X509_F_GET_CERT_BY_SUBJECT, ERR_R_MALLOC_FAILURE);\\r\\ngoto finish;\\r\\n}\\r\\nif (type == X509_LU_CRL && ent->hashes) {\\r\\nhtmp.hash = h;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_X509_STORE);\\r\\nidx = sk_BY_DIR_HASH_find(ent->hashes, &htmp);\\r\\nif (idx >= 0) {\\r\\nhent = sk_BY_DIR_HASH_value(ent->hashes, idx);\\r\\nk = hent->suffix;\\r\\n} else {\\r\\nhent = NULL;\\r\\nk = 0;\\r\\n}\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_X509_STORE);\\r\\n} else {\\r\\nk = 0;\\r\\nhent = NULL;\\r\\n}\\r\\nfor (;;) {\\r\\nchar c = '/';\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nc = ent->dir[strlen(ent->dir) - 1];\\r\\nif (c != ':' && c != '>' && c != ']') {\\r\\nc = ':';\\r\\n} else {\\r\\nc = '\\0';\\r\\n}\\r\\n#endif\\r\\nif (c == '\\0') {\\r\\nBIO_snprintf(b->data, b->max,\\r\\n\"%s%08lx.%s%d\", ent->dir, h, postfix, k);\\r\\n} else {\\r\\nBIO_snprintf(b->data, b->max,\\r\\n\"%s%c%08lx.%s%d\", ent->dir, c, h, postfix, k);\\r\\n}\\r\\n#ifndef OPENSSL_NO_POSIX_IO\\r\\n# ifdef _WIN32\\r\\n# define stat _stat\\r\\n# endif\\r\\n{\\r\\nstruct stat st;\\r\\nif (stat(b->data, &st) < 0)\\r\\nbreak;\\r\\n}\\r\\n#endif\\r\\nif (type == X509_LU_X509) {\\r\\nif ((X509_load_cert_file(xl, b->data, ent->dir_type)) == 0)\\r\\nbreak;\\r\\n} else if (type == X509_LU_CRL) {\\r\\nif ((X509_load_crl_file(xl, b->data, ent->dir_type)) == 0)\\r\\nbreak;\\r\\n}\\r\\nk++;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\\r\\nj = sk_X509_OBJECT_find(xl->store_ctx->objs, &stmp);\\r\\nif (j != -1)\\r\\ntmp = sk_X509_OBJECT_value(xl->store_ctx->objs, j);\\r\\nelse\\r\\ntmp = NULL;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nif (type == X509_LU_CRL) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\\r\\nif (!hent) {\\r\\nhtmp.hash = h;\\r\\nidx = sk_BY_DIR_HASH_find(ent->hashes, &htmp);\\r\\nif (idx >= 0)\\r\\nhent = sk_BY_DIR_HASH_value(ent->hashes, idx);\\r\\n}\\r\\nif (!hent) {\\r\\nhent = OPENSSL_malloc(sizeof(BY_DIR_HASH));\\r\\nhent->hash = h;\\r\\nhent->suffix = k;\\r\\nif (!sk_BY_DIR_HASH_push(ent->hashes, hent)) {\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nOPENSSL_free(hent);\\r\\nok = 0;\\r\\ngoto finish;\\r\\n}\\r\\n} else if (hent->suffix < k)\\r\\nhent->suffix = k;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\n}\\r\\nif (tmp != NULL) {\\r\\nok = 1;\\r\\nret->type = tmp->type;\\r\\nmemcpy(&ret->data, &tmp->data, sizeof(ret->data));\\r\\ngoto finish;\\r\\n}\\r\\n}\\r\\nfinish:\\r\\nif (b != NULL)\\r\\nBUF_MEM_free(b);\\r\\nreturn (ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_env_c", "target": 1, "func": "CMS_EnvelopedData *cms_get0_enveloped(CMS_ContentInfo *cms)\\r\\n{\\r\\nif (OBJ_obj2nid(cms->contentType) != NID_pkcs7_enveloped) {\\r\\nCMSerr(CMS_F_CMS_GET0_ENVELOPED,\\r\\nCMS_R_CONTENT_TYPE_NOT_ENVELOPED_DATA);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn cms->d.envelopedData;\\r\\n}\\r\\nstatic CMS_EnvelopedData *cms_enveloped_data_init(CMS_ContentInfo *cms)\\r\\n{\\r\\nif (cms->d.other == NULL) {\\r\\ncms->d.envelopedData = M_ASN1_new_of(CMS_EnvelopedData);\\r\\nif (!cms->d.envelopedData) {\\r\\nCMSerr(CMS_F_CMS_ENVELOPED_DATA_INIT, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\ncms->d.envelopedData->version = 0;\\r\\ncms->d.envelopedData->encryptedContentInfo->contentType =\\r\\nOBJ_nid2obj(NID_pkcs7_data);\\r\\nASN1_OBJECT_free(cms->contentType);\\r\\ncms->contentType = OBJ_nid2obj(NID_pkcs7_enveloped);\\r\\nreturn cms->d.envelopedData;\\r\\n}\\r\\nreturn cms_get0_enveloped(cms);\\r\\n}\\r\\nint cms_env_asn1_ctrl(CMS_RecipientInfo *ri, int cmd)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nint i;\\r\\nif (ri->type == CMS_RECIPINFO_TRANS)\\r\\npkey = ri->d.ktri->pkey;\\r\\nelse if (ri->type == CMS_RECIPINFO_AGREE) {\\r\\nEVP_PKEY_CTX *pctx = ri->d.kari->pctx;\\r\\nif (!pctx)\\r\\nreturn 0;\\r\\npkey = EVP_PKEY_CTX_get0_pkey(pctx);\\r\\nif (!pkey)\\r\\nreturn 0;\\r\\n} else\\r\\nreturn 0;\\r\\nif (!pkey->ameth || !pkey->ameth->pkey_ctrl)\\r\\nreturn 1;\\r\\ni = pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_CMS_ENVELOPE, cmd, ri);\\r\\nif (i == -2) {\\r\\nCMSerr(CMS_F_CMS_ENV_ASN1_CTRL,\\r\\nCMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\nif (i <= 0) {\\r\\nCMSerr(CMS_F_CMS_ENV_ASN1_CTRL, CMS_R_CTRL_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nEVP_PKEY_CTX *CMS_RecipientInfo_get0_pkey_ctx(CMS_RecipientInfo *ri)\\r\\n{\\r\\nif (ri->type == CMS_RECIPINFO_TRANS)\\r\\nreturn ri->d.ktri->pctx;\\r\\nelse if (ri->type == CMS_RECIPINFO_AGREE)\\r\\nreturn ri->d.kari->pctx;\\r\\nreturn NULL;\\r\\n}\\r\\nCMS_ContentInfo *CMS_EnvelopedData_create(const EVP_CIPHER *cipher)\\r\\n{\\r\\nCMS_ContentInfo *cms;\\r\\nCMS_EnvelopedData *env;\\r\\ncms = CMS_ContentInfo_new();\\r\\nif (!cms)\\r\\ngoto merr;\\r\\nenv = cms_enveloped_data_init(cms);\\r\\nif (!env)\\r\\ngoto merr;\\r\\nif (!cms_EncryptedContent_init(env->encryptedContentInfo,\\r\\ncipher, NULL, 0))\\r\\ngoto merr;\\r\\nreturn cms;\\r\\nmerr:\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nCMSerr(CMS_F_CMS_ENVELOPEDDATA_CREATE, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int cms_RecipientInfo_ktri_init(CMS_RecipientInfo *ri, X509 *recip,\\r\\nEVP_PKEY *pk, unsigned int flags)\\r\\n{\\r\\nCMS_KeyTransRecipientInfo *ktri;\\r\\nint idtype;\\r\\nri->d.ktri = M_ASN1_new_of(CMS_KeyTransRecipientInfo);\\r\\nif (!ri->d.ktri)\\r\\nreturn 0;\\r\\nri->type = CMS_RECIPINFO_TRANS;\\r\\nktri = ri->d.ktri;\\r\\nif (flags & CMS_USE_KEYID) {\\r\\nktri->version = 2;\\r\\nidtype = CMS_RECIPINFO_KEYIDENTIFIER;\\r\\n} else {\\r\\nktri->version = 0;\\r\\nidtype = CMS_RECIPINFO_ISSUER_SERIAL;\\r\\n}\\r\\nif (!cms_set1_SignerIdentifier(ktri->rid, recip, idtype))\\r\\nreturn 0;\\r\\nCRYPTO_add(&recip->references, 1, CRYPTO_LOCK_X509);\\r\\nCRYPTO_add(&pk->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\nktri->pkey = pk;\\r\\nktri->recip = recip;\\r\\nif (flags & CMS_KEY_PARAM) {\\r\\nktri->pctx = EVP_PKEY_CTX_new(ktri->pkey, NULL);\\r\\nif (!ktri->pctx)\\r\\nreturn 0;\\r\\nif (EVP_PKEY_encrypt_init(ktri->pctx) <= 0)\\r\\nreturn 0;\\r\\n} else if (!cms_env_asn1_ctrl(ri, 0))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nCMS_RecipientInfo *CMS_add1_recipient_cert(CMS_ContentInfo *cms,\\r\\nX509 *recip, unsigned int flags)\\r\\n{\\r\\nCMS_RecipientInfo *ri = NULL;\\r\\nCMS_EnvelopedData *env;\\r\\nEVP_PKEY *pk = NULL;\\r\\nenv = cms_get0_enveloped(cms);\\r\\nif (!env)\\r\\ngoto err;\\r\\nri = M_ASN1_new_of(CMS_RecipientInfo);\\r\\nif (!ri)\\r\\ngoto merr;\\r\\npk = X509_get_pubkey(recip);\\r\\nif (!pk) {\\r\\nCMSerr(CMS_F_CMS_ADD1_RECIPIENT_CERT, CMS_R_ERROR_GETTING_PUBLIC_KEY);\\r\\ngoto err;\\r\\n}\\r\\nswitch (cms_pkey_get_ri_type(pk)) {\\r\\ncase CMS_RECIPINFO_TRANS:\\r\\nif (!cms_RecipientInfo_ktri_init(ri, recip, pk, flags))\\r\\ngoto err;\\r\\nbreak;\\r\\ncase CMS_RECIPINFO_AGREE:\\r\\nif (!cms_RecipientInfo_kari_init(ri, recip, pk, flags))\\r\\ngoto err;\\r\\nbreak;\\r\\ndefault:\\r\\nCMSerr(CMS_F_CMS_ADD1_RECIPIENT_CERT,\\r\\nCMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (!sk_CMS_RecipientInfo_push(env->recipientInfos, ri))\\r\\ngoto merr;\\r\\nEVP_PKEY_free(pk);\\r\\nreturn ri;\\r\\nmerr:\\r\\nCMSerr(CMS_F_CMS_ADD1_RECIPIENT_CERT, ERR_R_MALLOC_FAILURE);\\r\\nerr:\\r\\nif (ri)\\r\\nM_ASN1_free_of(ri, CMS_RecipientInfo);\\r\\nif (pk)\\r\\nEVP_PKEY_free(pk);\\r\\nreturn NULL;\\r\\n}\\r\\nint CMS_RecipientInfo_ktri_get0_algs(CMS_RecipientInfo *ri,\\r\\nEVP_PKEY **pk, X509 **recip,\\r\\nX509_ALGOR **palg)\\r\\n{\\r\\nCMS_KeyTransRecipientInfo *ktri;\\r\\nif (ri->type != CMS_RECIPINFO_TRANS) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_ALGS,\\r\\nCMS_R_NOT_KEY_TRANSPORT);\\r\\nreturn 0;\\r\\n}\\r\\nktri = ri->d.ktri;\\r\\nif (pk)\\r\\n*pk = ktri->pkey;\\r\\nif (recip)\\r\\n*recip = ktri->recip;\\r\\nif (palg)\\r\\n*palg = ktri->keyEncryptionAlgorithm;\\r\\nreturn 1;\\r\\n}\\r\\nint CMS_RecipientInfo_ktri_get0_signer_id(CMS_RecipientInfo *ri,\\r\\nASN1_OCTET_STRING **keyid,\\r\\nX509_NAME **issuer,\\r\\nASN1_INTEGER **sno)\\r\\n{\\r\\nCMS_KeyTransRecipientInfo *ktri;\\r\\nif (ri->type != CMS_RECIPINFO_TRANS) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_SIGNER_ID,\\r\\nCMS_R_NOT_KEY_TRANSPORT);\\r\\nreturn 0;\\r\\n}\\r\\nktri = ri->d.ktri;\\r\\nreturn cms_SignerIdentifier_get0_signer_id(ktri->rid, keyid, issuer, sno);\\r\\n}\\r\\nint CMS_RecipientInfo_ktri_cert_cmp(CMS_RecipientInfo *ri, X509 *cert)\\r\\n{\\r\\nif (ri->type != CMS_RECIPINFO_TRANS) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_CERT_CMP,\\r\\nCMS_R_NOT_KEY_TRANSPORT);\\r\\nreturn -2;\\r\\n}\\r\\nreturn cms_SignerIdentifier_cert_cmp(ri->d.ktri->rid, cert);\\r\\n}\\r\\nint CMS_RecipientInfo_set0_pkey(CMS_RecipientInfo *ri, EVP_PKEY *pkey)\\r\\n{\\r\\nif (ri->type != CMS_RECIPINFO_TRANS) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_SET0_PKEY, CMS_R_NOT_KEY_TRANSPORT);\\r\\nreturn 0;\\r\\n}\\r\\nri->d.ktri->pkey = pkey;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cms_RecipientInfo_ktri_encrypt(CMS_ContentInfo *cms,\\r\\nCMS_RecipientInfo *ri)\\r\\n{\\r\\nCMS_KeyTransRecipientInfo *ktri;\\r\\nCMS_EncryptedContentInfo *ec;\\r\\nEVP_PKEY_CTX *pctx;\\r\\nunsigned char *ek = NULL;\\r\\nsize_t eklen;\\r\\nint ret = 0;\\r\\nif (ri->type != CMS_RECIPINFO_TRANS) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT, CMS_R_NOT_KEY_TRANSPORT);\\r\\nreturn 0;\\r\\n}\\r\\nktri = ri->d.ktri;\\r\\nec = cms->d.envelopedData->encryptedContentInfo;\\r\\npctx = ktri->pctx;\\r\\nif (pctx) {\\r\\nif (!cms_env_asn1_ctrl(ri, 0))\\r\\ngoto err;\\r\\n} else {\\r\\npctx = EVP_PKEY_CTX_new(ktri->pkey, NULL);\\r\\nif (!pctx)\\r\\nreturn 0;\\r\\nif (EVP_PKEY_encrypt_init(pctx) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_ENCRYPT,\\r\\nEVP_PKEY_CTRL_CMS_ENCRYPT, 0, ri) <= 0) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT, CMS_R_CTRL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_encrypt(pctx, NULL, &eklen, ec->key, ec->keylen) <= 0)\\r\\ngoto err;\\r\\nek = OPENSSL_malloc(eklen);\\r\\nif (ek == NULL) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_encrypt(pctx, ek, &eklen, ec->key, ec->keylen) <= 0)\\r\\ngoto err;\\r\\nASN1_STRING_set0(ktri->encryptedKey, ek, eklen);\\r\\nek = NULL;\\r\\nret = 1;\\r\\nerr:\\r\\nif (pctx) {\\r\\nEVP_PKEY_CTX_free(pctx);\\r\\nktri->pctx = NULL;\\r\\n}\\r\\nif (ek)\\r\\nOPENSSL_free(ek);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,\\r\\nCMS_RecipientInfo *ri)\\r\\n{\\r\\nCMS_KeyTransRecipientInfo *ktri = ri->d.ktri;\\r\\nEVP_PKEY *pkey = ktri->pkey;\\r\\nunsigned char *ek = NULL;\\r\\nsize_t eklen;\\r\\nint ret = 0;\\r\\nCMS_EncryptedContentInfo *ec;\\r\\nec = cms->d.envelopedData->encryptedContentInfo;\\r\\nif (ktri->pkey == NULL) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_NO_PRIVATE_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nktri->pctx = EVP_PKEY_CTX_new(pkey, NULL);\\r\\nif (!ktri->pctx)\\r\\nreturn 0;\\r\\nif (EVP_PKEY_decrypt_init(ktri->pctx) <= 0)\\r\\ngoto err;\\r\\nif (!cms_env_asn1_ctrl(ri, 1))\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_ctrl(ktri->pctx, -1, EVP_PKEY_OP_DECRYPT,\\r\\nEVP_PKEY_CTRL_CMS_DECRYPT, 0, ri) <= 0) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CTRL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_decrypt(ktri->pctx, NULL, &eklen,\\r\\nktri->encryptedKey->data,\\r\\nktri->encryptedKey->length) <= 0)\\r\\ngoto err;\\r\\nek = OPENSSL_malloc(eklen);\\r\\nif (ek == NULL) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_decrypt(ktri->pctx, ek, &eklen,\\r\\nktri->encryptedKey->data,\\r\\nktri->encryptedKey->length) <= 0) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CMS_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nif (ec->key) {\\r\\nOPENSSL_cleanse(ec->key, ec->keylen);\\r\\nOPENSSL_free(ec->key);\\r\\n}\\r\\nec->key = ek;\\r\\nec->keylen = eklen;\\r\\nerr:\\r\\nif (ktri->pctx) {\\r\\nEVP_PKEY_CTX_free(ktri->pctx);\\r\\nktri->pctx = NULL;\\r\\n}\\r\\nif (!ret && ek)\\r\\nOPENSSL_free(ek);\\r\\nreturn ret;\\r\\n}\\r\\nint CMS_RecipientInfo_kekri_id_cmp(CMS_RecipientInfo *ri,\\r\\nconst unsigned char *id, size_t idlen)\\r\\n{\\r\\nASN1_OCTET_STRING tmp_os;\\r\\nCMS_KEKRecipientInfo *kekri;\\r\\nif (ri->type != CMS_RECIPINFO_KEK) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ID_CMP, CMS_R_NOT_KEK);\\r\\nreturn -2;\\r\\n}\\r\\nkekri = ri->d.kekri;\\r\\ntmp_os.type = V_ASN1_OCTET_STRING;\\r\\ntmp_os.flags = 0;\\r\\ntmp_os.data = (unsigned char *)id;\\r\\ntmp_os.length = (int)idlen;\\r\\nreturn ASN1_OCTET_STRING_cmp(&tmp_os, kekri->kekid->keyIdentifier);\\r\\n}\\r\\nstatic size_t aes_wrap_keylen(int nid)\\r\\n{\\r\\nswitch (nid) {\\r\\ncase NID_id_aes128_wrap:\\r\\nreturn 16;\\r\\ncase NID_id_aes192_wrap:\\r\\nreturn 24;\\r\\ncase NID_id_aes256_wrap:\\r\\nreturn 32;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nCMS_RecipientInfo *CMS_add0_recipient_key(CMS_ContentInfo *cms, int nid,\\r\\nunsigned char *key, size_t keylen,\\r\\nunsigned char *id, size_t idlen,\\r\\nASN1_GENERALIZEDTIME *date,\\r\\nASN1_OBJECT *otherTypeId,\\r\\nASN1_TYPE *otherType)\\r\\n{\\r\\nCMS_RecipientInfo *ri = NULL;\\r\\nCMS_EnvelopedData *env;\\r\\nCMS_KEKRecipientInfo *kekri;\\r\\nenv = cms_get0_enveloped(cms);\\r\\nif (!env)\\r\\ngoto err;\\r\\nif (nid == NID_undef) {\\r\\nswitch (keylen) {\\r\\ncase 16:\\r\\nnid = NID_id_aes128_wrap;\\r\\nbreak;\\r\\ncase 24:\\r\\nnid = NID_id_aes192_wrap;\\r\\nbreak;\\r\\ncase 32:\\r\\nnid = NID_id_aes256_wrap;\\r\\nbreak;\\r\\ndefault:\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_KEY, CMS_R_INVALID_KEY_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nsize_t exp_keylen = aes_wrap_keylen(nid);\\r\\nif (!exp_keylen) {\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_KEY,\\r\\nCMS_R_UNSUPPORTED_KEK_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nif (keylen != exp_keylen) {\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_KEY, CMS_R_INVALID_KEY_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nri = M_ASN1_new_of(CMS_RecipientInfo);\\r\\nif (!ri)\\r\\ngoto merr;\\r\\nri->d.kekri = M_ASN1_new_of(CMS_KEKRecipientInfo);\\r\\nif (!ri->d.kekri)\\r\\ngoto merr;\\r\\nri->type = CMS_RECIPINFO_KEK;\\r\\nkekri = ri->d.kekri;\\r\\nif (otherTypeId) {\\r\\nkekri->kekid->other = M_ASN1_new_of(CMS_OtherKeyAttribute);\\r\\nif (kekri->kekid->other == NULL)\\r\\ngoto merr;\\r\\n}\\r\\nif (!sk_CMS_RecipientInfo_push(env->recipientInfos, ri))\\r\\ngoto merr;\\r\\nkekri->version = 4;\\r\\nkekri->key = key;\\r\\nkekri->keylen = keylen;\\r\\nASN1_STRING_set0(kekri->kekid->keyIdentifier, id, idlen);\\r\\nkekri->kekid->date = date;\\r\\nif (kekri->kekid->other) {\\r\\nkekri->kekid->other->keyAttrId = otherTypeId;\\r\\nkekri->kekid->other->keyAttr = otherType;\\r\\n}\\r\\nX509_ALGOR_set0(kekri->keyEncryptionAlgorithm,\\r\\nOBJ_nid2obj(nid), V_ASN1_UNDEF, NULL);\\r\\nreturn ri;\\r\\nmerr:\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_KEY, ERR_R_MALLOC_FAILURE);\\r\\nerr:\\r\\nif (ri)\\r\\nM_ASN1_free_of(ri, CMS_RecipientInfo);\\r\\nreturn NULL;\\r\\n}\\r\\nint CMS_RecipientInfo_kekri_get0_id(CMS_RecipientInfo *ri,\\r\\nX509_ALGOR **palg,\\r\\nASN1_OCTET_STRING **pid,\\r\\nASN1_GENERALIZEDTIME **pdate,\\r\\nASN1_OBJECT **potherid,\\r\\nASN1_TYPE **pothertype)\\r\\n{\\r\\nCMS_KEKIdentifier *rkid;\\r\\nif (ri->type != CMS_RECIPINFO_KEK) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_GET0_ID, CMS_R_NOT_KEK);\\r\\nreturn 0;\\r\\n}\\r\\nrkid = ri->d.kekri->kekid;\\r\\nif (palg)\\r\\n*palg = ri->d.kekri->keyEncryptionAlgorithm;\\r\\nif (pid)\\r\\n*pid = rkid->keyIdentifier;\\r\\nif (pdate)\\r\\n*pdate = rkid->date;\\r\\nif (potherid) {\\r\\nif (rkid->other)\\r\\n*potherid = rkid->other->keyAttrId;\\r\\nelse\\r\\n*potherid = NULL;\\r\\n}\\r\\nif (pothertype) {\\r\\nif (rkid->other)\\r\\n*pothertype = rkid->other->keyAttr;\\r\\nelse\\r\\n*pothertype = NULL;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint CMS_RecipientInfo_set0_key(CMS_RecipientInfo *ri,\\r\\nunsigned char *key, size_t keylen)\\r\\n{\\r\\nCMS_KEKRecipientInfo *kekri;\\r\\nif (ri->type != CMS_RECIPINFO_KEK) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_SET0_KEY, CMS_R_NOT_KEK);\\r\\nreturn 0;\\r\\n}\\r\\nkekri = ri->d.kekri;\\r\\nkekri->key = key;\\r\\nkekri->keylen = keylen;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cms_RecipientInfo_kekri_encrypt(CMS_ContentInfo *cms,\\r\\nCMS_RecipientInfo *ri)\\r\\n{\\r\\nCMS_EncryptedContentInfo *ec;\\r\\nCMS_KEKRecipientInfo *kekri;\\r\\nAES_KEY actx;\\r\\nunsigned char *wkey = NULL;\\r\\nint wkeylen;\\r\\nint r = 0;\\r\\nec = cms->d.envelopedData->encryptedContentInfo;\\r\\nkekri = ri->d.kekri;\\r\\nif (!kekri->key) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT, CMS_R_NO_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nif (AES_set_encrypt_key(kekri->key, kekri->keylen << 3, &actx)) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT,\\r\\nCMS_R_ERROR_SETTING_KEY);\\r\\ngoto err;\\r\\n}\\r\\nwkey = OPENSSL_malloc(ec->keylen + 8);\\r\\nif (!wkey) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nwkeylen = AES_wrap_key(&actx, NULL, wkey, ec->key, ec->keylen);\\r\\nif (wkeylen <= 0) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT, CMS_R_WRAP_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nASN1_STRING_set0(kekri->encryptedKey, wkey, wkeylen);\\r\\nr = 1;\\r\\nerr:\\r\\nif (!r && wkey)\\r\\nOPENSSL_free(wkey);\\r\\nOPENSSL_cleanse(&actx, sizeof(actx));\\r\\nreturn r;\\r\\n}\\r\\nstatic int cms_RecipientInfo_kekri_decrypt(CMS_ContentInfo *cms,\\r\\nCMS_RecipientInfo *ri)\\r\\n{\\r\\nCMS_EncryptedContentInfo *ec;\\r\\nCMS_KEKRecipientInfo *kekri;\\r\\nAES_KEY actx;\\r\\nunsigned char *ukey = NULL;\\r\\nint ukeylen;\\r\\nint r = 0, wrap_nid;\\r\\nec = cms->d.envelopedData->encryptedContentInfo;\\r\\nkekri = ri->d.kekri;\\r\\nif (!kekri->key) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT, CMS_R_NO_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nwrap_nid = OBJ_obj2nid(kekri->keyEncryptionAlgorithm->algorithm);\\r\\nif (aes_wrap_keylen(wrap_nid) != kekri->keylen) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT,\\r\\nCMS_R_INVALID_KEY_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\nif (kekri->encryptedKey->length < 16) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT,\\r\\nCMS_R_INVALID_ENCRYPTED_KEY_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nif (AES_set_decrypt_key(kekri->key, kekri->keylen << 3, &actx)) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT,\\r\\nCMS_R_ERROR_SETTING_KEY);\\r\\ngoto err;\\r\\n}\\r\\nukey = OPENSSL_malloc(kekri->encryptedKey->length - 8);\\r\\nif (!ukey) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nukeylen = AES_unwrap_key(&actx, NULL, ukey,\\r\\nkekri->encryptedKey->data,\\r\\nkekri->encryptedKey->length);\\r\\nif (ukeylen <= 0) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT, CMS_R_UNWRAP_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nec->key = ukey;\\r\\nec->keylen = ukeylen;\\r\\nr = 1;\\r\\nerr:\\r\\nif (!r && ukey)\\r\\nOPENSSL_free(ukey);\\r\\nOPENSSL_cleanse(&actx, sizeof(actx));\\r\\nreturn r;\\r\\n}\\r\\nint CMS_RecipientInfo_decrypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri)\\r\\n{\\r\\nswitch (ri->type) {\\r\\ncase CMS_RECIPINFO_TRANS:\\r\\nreturn cms_RecipientInfo_ktri_decrypt(cms, ri);\\r\\ncase CMS_RECIPINFO_KEK:\\r\\nreturn cms_RecipientInfo_kekri_decrypt(cms, ri);\\r\\ncase CMS_RECIPINFO_PASS:\\r\\nreturn cms_RecipientInfo_pwri_crypt(cms, ri, 0);\\r\\ndefault:\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_DECRYPT,\\r\\nCMS_R_UNSUPPORTED_RECPIENTINFO_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nint CMS_RecipientInfo_encrypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri)\\r\\n{\\r\\nswitch (ri->type) {\\r\\ncase CMS_RECIPINFO_TRANS:\\r\\nreturn cms_RecipientInfo_ktri_encrypt(cms, ri);\\r\\ncase CMS_RECIPINFO_AGREE:\\r\\nreturn cms_RecipientInfo_kari_encrypt(cms, ri);\\r\\ncase CMS_RECIPINFO_KEK:\\r\\nreturn cms_RecipientInfo_kekri_encrypt(cms, ri);\\r\\nbreak;\\r\\ncase CMS_RECIPINFO_PASS:\\r\\nreturn cms_RecipientInfo_pwri_crypt(cms, ri, 1);\\r\\nbreak;\\r\\ndefault:\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_ENCRYPT,\\r\\nCMS_R_UNSUPPORTED_RECIPIENT_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nstatic void cms_env_set_originfo_version(CMS_EnvelopedData *env)\\r\\n{\\r\\nCMS_OriginatorInfo *org = env->originatorInfo;\\r\\nint i;\\r\\nif (org == NULL)\\r\\nreturn;\\r\\nfor (i = 0; i < sk_CMS_CertificateChoices_num(org->certificates); i++) {\\r\\nCMS_CertificateChoices *cch;\\r\\ncch = sk_CMS_CertificateChoices_value(org->certificates, i);\\r\\nif (cch->type == CMS_CERTCHOICE_OTHER) {\\r\\nenv->version = 4;\\r\\nreturn;\\r\\n} else if (cch->type == CMS_CERTCHOICE_V2ACERT) {\\r\\nif (env->version < 3)\\r\\nenv->version = 3;\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < sk_CMS_RevocationInfoChoice_num(org->crls); i++) {\\r\\nCMS_RevocationInfoChoice *rch;\\r\\nrch = sk_CMS_RevocationInfoChoice_value(org->crls, i);\\r\\nif (rch->type == CMS_REVCHOICE_OTHER) {\\r\\nenv->version = 4;\\r\\nreturn;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic void cms_env_set_version(CMS_EnvelopedData *env)\\r\\n{\\r\\nint i;\\r\\nCMS_RecipientInfo *ri;\\r\\nif (env->version >= 4)\\r\\nreturn;\\r\\ncms_env_set_originfo_version(env);\\r\\nif (env->version >= 3)\\r\\nreturn;\\r\\nfor (i = 0; i < sk_CMS_RecipientInfo_num(env->recipientInfos); i++) {\\r\\nri = sk_CMS_RecipientInfo_value(env->recipientInfos, i);\\r\\nif (ri->type == CMS_RECIPINFO_PASS || ri->type == CMS_RECIPINFO_OTHER) {\\r\\nenv->version = 3;\\r\\nreturn;\\r\\n} else if (ri->type != CMS_RECIPINFO_TRANS\\r\\n|| ri->d.ktri->version != 0) {\\r\\nenv->version = 2;\\r\\n}\\r\\n}\\r\\nif (env->version == 2)\\r\\nreturn;\\r\\nif (env->originatorInfo || env->unprotectedAttrs)\\r\\nenv->version = 2;\\r\\nenv->version = 0;\\r\\n}\\r\\nBIO *cms_EnvelopedData_init_bio(CMS_ContentInfo *cms)\\r\\n{\\r\\nCMS_EncryptedContentInfo *ec;\\r\\nSTACK_OF(CMS_RecipientInfo) *rinfos;\\r\\nCMS_RecipientInfo *ri;\\r\\nint i, ok = 0;\\r\\nBIO *ret;\\r\\nec = cms->d.envelopedData->encryptedContentInfo;\\r\\nret = cms_EncryptedContent_init_bio(ec);\\r\\nif (!ret || !ec->cipher)\\r\\nreturn ret;\\r\\nrinfos = cms->d.envelopedData->recipientInfos;\\r\\nfor (i = 0; i < sk_CMS_RecipientInfo_num(rinfos); i++) {\\r\\nri = sk_CMS_RecipientInfo_value(rinfos, i);\\r\\nif (CMS_RecipientInfo_encrypt(cms, ri) <= 0) {\\r\\nCMSerr(CMS_F_CMS_ENVELOPEDDATA_INIT_BIO,\\r\\nCMS_R_ERROR_SETTING_RECIPIENTINFO);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ncms_env_set_version(cms->d.envelopedData);\\r\\nok = 1;\\r\\nerr:\\r\\nec->cipher = NULL;\\r\\nif (ec->key) {\\r\\nOPENSSL_cleanse(ec->key, ec->keylen);\\r\\nOPENSSL_free(ec->key);\\r\\nec->key = NULL;\\r\\nec->keylen = 0;\\r\\n}\\r\\nif (ok)\\r\\nreturn ret;\\r\\nBIO_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nint cms_pkey_get_ri_type(EVP_PKEY *pk)\\r\\n{\\r\\nif (pk->ameth && pk->ameth->pkey_ctrl) {\\r\\nint i, r;\\r\\ni = pk->ameth->pkey_ctrl(pk, ASN1_PKEY_CTRL_CMS_RI_TYPE, 0, &r);\\r\\nif (i > 0)\\r\\nreturn r;\\r\\n}\\r\\nreturn CMS_RECIPINFO_TRANS;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_cfb64_c", "target": 0, "func": "void BF_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, const BF_KEY *schedule,\\r\\nunsigned char *ivec, int *num, int encrypt)\\r\\n{\\r\\nregister BF_LONG v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nBF_LONG ti[2];\\r\\nunsigned char *iv, c, cc;\\r\\niv = (unsigned char *)ivec;\\r\\nif (encrypt) {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nn2l(iv, v0);\\r\\nti[0] = v0;\\r\\nn2l(iv, v1);\\r\\nti[1] = v1;\\r\\nBF_encrypt((BF_LONG *)ti, schedule);\\r\\niv = (unsigned char *)ivec;\\r\\nt = ti[0];\\r\\nl2n(t, iv);\\r\\nt = ti[1];\\r\\nl2n(t, iv);\\r\\niv = (unsigned char *)ivec;\\r\\n}\\r\\nc = *(in++) ^ iv[n];\\r\\n*(out++) = c;\\r\\niv[n] = c;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n} else {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nn2l(iv, v0);\\r\\nti[0] = v0;\\r\\nn2l(iv, v1);\\r\\nti[1] = v1;\\r\\nBF_encrypt((BF_LONG *)ti, schedule);\\r\\niv = (unsigned char *)ivec;\\r\\nt = ti[0];\\r\\nl2n(t, iv);\\r\\nt = ti[1];\\r\\nl2n(t, iv);\\r\\niv = (unsigned char *)ivec;\\r\\n}\\r\\ncc = *(in++);\\r\\nc = iv[n];\\r\\niv[n] = cc;\\r\\n*(out++) = c ^ cc;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n}\\r\\nv0 = v1 = ti[0] = ti[1] = t = c = cc = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_cvt_c", "target": 0, "func": "EC_GROUP *EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nconst EC_METHOD *meth;\\r\\nEC_GROUP *ret;\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_ec_group_new_curve_gfp(p, a, b, ctx);\\r\\n#endif\\r\\n#if defined(OPENSSL_BN_ASM_MONT)\\r\\nmeth = EC_GFp_mont_method();\\r\\n#else\\r\\nmeth = EC_GFp_nist_method();\\r\\n#endif\\r\\nret = EC_GROUP_new(meth);\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_GROUP_set_curve_GFp(ret, p, a, b, ctx)) {\\r\\nunsigned long err;\\r\\nerr = ERR_peek_last_error();\\r\\nif (!(ERR_GET_LIB(err) == ERR_LIB_EC &&\\r\\n((ERR_GET_REASON(err) == EC_R_NOT_A_NIST_PRIME) ||\\r\\n(ERR_GET_REASON(err) == EC_R_NOT_A_SUPPORTED_NIST_PRIME)))) {\\r\\nEC_GROUP_clear_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nERR_clear_error();\\r\\nEC_GROUP_clear_free(ret);\\r\\nmeth = EC_GFp_mont_method();\\r\\nret = EC_GROUP_new(meth);\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_GROUP_set_curve_GFp(ret, p, a, b, ctx)) {\\r\\nEC_GROUP_clear_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nEC_GROUP *EC_GROUP_new_curve_GF2m(const BIGNUM *p, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nconst EC_METHOD *meth;\\r\\nEC_GROUP *ret;\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_ec_group_new_curve_gf2m(p, a, b, ctx);\\r\\n# endif\\r\\nmeth = EC_GF2m_simple_method();\\r\\nret = EC_GROUP_new(meth);\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_GROUP_set_curve_GF2m(ret, p, a, b, ctx)) {\\r\\nEC_GROUP_clear_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509name_c", "target": 0, "func": "int X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf, int len)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nobj = OBJ_nid2obj(nid);\\r\\nif (obj == NULL)\\r\\nreturn (-1);\\r\\nreturn (X509_NAME_get_text_by_OBJ(name, obj, buf, len));\\r\\n}\\r\\nint X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, char *buf,\\r\\nint len)\\r\\n{\\r\\nint i;\\r\\nASN1_STRING *data;\\r\\ni = X509_NAME_get_index_by_OBJ(name, obj, -1);\\r\\nif (i < 0)\\r\\nreturn (-1);\\r\\ndata = X509_NAME_ENTRY_get_data(X509_NAME_get_entry(name, i));\\r\\ni = (data->length > (len - 1)) ? (len - 1) : data->length;\\r\\nif (buf == NULL)\\r\\nreturn (data->length);\\r\\nmemcpy(buf, data->data, i);\\r\\nbuf[i] = '\\0';\\r\\nreturn (i);\\r\\n}\\r\\nint X509_NAME_entry_count(X509_NAME *name)\\r\\n{\\r\\nif (name == NULL)\\r\\nreturn (0);\\r\\nreturn (sk_X509_NAME_ENTRY_num(name->entries));\\r\\n}\\r\\nint X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nobj = OBJ_nid2obj(nid);\\r\\nif (obj == NULL)\\r\\nreturn (-2);\\r\\nreturn (X509_NAME_get_index_by_OBJ(name, obj, lastpos));\\r\\n}\\r\\nint X509_NAME_get_index_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nint n;\\r\\nX509_NAME_ENTRY *ne;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nif (name == NULL)\\r\\nreturn (-1);\\r\\nif (lastpos < 0)\\r\\nlastpos = -1;\\r\\nsk = name->entries;\\r\\nn = sk_X509_NAME_ENTRY_num(sk);\\r\\nfor (lastpos++; lastpos < n; lastpos++) {\\r\\nne = sk_X509_NAME_ENTRY_value(sk, lastpos);\\r\\nif (OBJ_cmp(ne->object, obj) == 0)\\r\\nreturn (lastpos);\\r\\n}\\r\\nreturn (-1);\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name, int loc)\\r\\n{\\r\\nif (name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc\\r\\n|| loc < 0)\\r\\nreturn (NULL);\\r\\nelse\\r\\nreturn (sk_X509_NAME_ENTRY_value(name->entries, loc));\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc)\\r\\n{\\r\\nX509_NAME_ENTRY *ret;\\r\\nint i, n, set_prev, set_next;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nif (name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc\\r\\n|| loc < 0)\\r\\nreturn (NULL);\\r\\nsk = name->entries;\\r\\nret = sk_X509_NAME_ENTRY_delete(sk, loc);\\r\\nn = sk_X509_NAME_ENTRY_num(sk);\\r\\nname->modified = 1;\\r\\nif (loc == n)\\r\\nreturn (ret);\\r\\nif (loc != 0)\\r\\nset_prev = (sk_X509_NAME_ENTRY_value(sk, loc - 1))->set;\\r\\nelse\\r\\nset_prev = ret->set - 1;\\r\\nset_next = sk_X509_NAME_ENTRY_value(sk, loc)->set;\\r\\nif (set_prev + 1 < set_next)\\r\\nfor (i = loc; i < n; i++)\\r\\nsk_X509_NAME_ENTRY_value(sk, i)->set--;\\r\\nreturn (ret);\\r\\n}\\r\\nint X509_NAME_add_entry_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int type,\\r\\nunsigned char *bytes, int len, int loc,\\r\\nint set)\\r\\n{\\r\\nX509_NAME_ENTRY *ne;\\r\\nint ret;\\r\\nne = X509_NAME_ENTRY_create_by_OBJ(NULL, obj, type, bytes, len);\\r\\nif (!ne)\\r\\nreturn 0;\\r\\nret = X509_NAME_add_entry(name, ne, loc, set);\\r\\nX509_NAME_ENTRY_free(ne);\\r\\nreturn ret;\\r\\n}\\r\\nint X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type,\\r\\nunsigned char *bytes, int len, int loc,\\r\\nint set)\\r\\n{\\r\\nX509_NAME_ENTRY *ne;\\r\\nint ret;\\r\\nne = X509_NAME_ENTRY_create_by_NID(NULL, nid, type, bytes, len);\\r\\nif (!ne)\\r\\nreturn 0;\\r\\nret = X509_NAME_add_entry(name, ne, loc, set);\\r\\nX509_NAME_ENTRY_free(ne);\\r\\nreturn ret;\\r\\n}\\r\\nint X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type,\\r\\nconst unsigned char *bytes, int len, int loc,\\r\\nint set)\\r\\n{\\r\\nX509_NAME_ENTRY *ne;\\r\\nint ret;\\r\\nne = X509_NAME_ENTRY_create_by_txt(NULL, field, type, bytes, len);\\r\\nif (!ne)\\r\\nreturn 0;\\r\\nret = X509_NAME_add_entry(name, ne, loc, set);\\r\\nX509_NAME_ENTRY_free(ne);\\r\\nreturn ret;\\r\\n}\\r\\nint X509_NAME_add_entry(X509_NAME *name, X509_NAME_ENTRY *ne, int loc,\\r\\nint set)\\r\\n{\\r\\nX509_NAME_ENTRY *new_name = NULL;\\r\\nint n, i, inc;\\r\\nSTACK_OF(X509_NAME_ENTRY) *sk;\\r\\nif (name == NULL)\\r\\nreturn (0);\\r\\nsk = name->entries;\\r\\nn = sk_X509_NAME_ENTRY_num(sk);\\r\\nif (loc > n)\\r\\nloc = n;\\r\\nelse if (loc < 0)\\r\\nloc = n;\\r\\nname->modified = 1;\\r\\nif (set == -1) {\\r\\nif (loc == 0) {\\r\\nset = 0;\\r\\ninc = 1;\\r\\n} else {\\r\\nset = sk_X509_NAME_ENTRY_value(sk, loc - 1)->set;\\r\\ninc = 0;\\r\\n}\\r\\n} else {\\r\\nif (loc >= n) {\\r\\nif (loc != 0)\\r\\nset = sk_X509_NAME_ENTRY_value(sk, loc - 1)->set + 1;\\r\\nelse\\r\\nset = 0;\\r\\n} else\\r\\nset = sk_X509_NAME_ENTRY_value(sk, loc)->set;\\r\\ninc = (set == 0) ? 1 : 0;\\r\\n}\\r\\nif ((new_name = X509_NAME_ENTRY_dup(ne)) == NULL)\\r\\ngoto err;\\r\\nnew_name->set = set;\\r\\nif (!sk_X509_NAME_ENTRY_insert(sk, new_name, loc)) {\\r\\nX509err(X509_F_X509_NAME_ADD_ENTRY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (inc) {\\r\\nn = sk_X509_NAME_ENTRY_num(sk);\\r\\nfor (i = loc + 1; i < n; i++)\\r\\nsk_X509_NAME_ENTRY_value(sk, i - 1)->set += 1;\\r\\n}\\r\\nreturn (1);\\r\\nerr:\\r\\nif (new_name != NULL)\\r\\nX509_NAME_ENTRY_free(new_name);\\r\\nreturn (0);\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne,\\r\\nconst char *field, int type,\\r\\nconst unsigned char *bytes,\\r\\nint len)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nX509_NAME_ENTRY *nentry;\\r\\nobj = OBJ_txt2obj(field, 0);\\r\\nif (obj == NULL) {\\r\\nX509err(X509_F_X509_NAME_ENTRY_CREATE_BY_TXT,\\r\\nX509_R_INVALID_FIELD_NAME);\\r\\nERR_add_error_data(2, \"name=\", field);\\r\\nreturn (NULL);\\r\\n}\\r\\nnentry = X509_NAME_ENTRY_create_by_OBJ(ne, obj, type, bytes, len);\\r\\nASN1_OBJECT_free(obj);\\r\\nreturn nentry;\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid,\\r\\nint type, unsigned char *bytes,\\r\\nint len)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nX509_NAME_ENTRY *nentry;\\r\\nobj = OBJ_nid2obj(nid);\\r\\nif (obj == NULL) {\\r\\nX509err(X509_F_X509_NAME_ENTRY_CREATE_BY_NID, X509_R_UNKNOWN_NID);\\r\\nreturn (NULL);\\r\\n}\\r\\nnentry = X509_NAME_ENTRY_create_by_OBJ(ne, obj, type, bytes, len);\\r\\nASN1_OBJECT_free(obj);\\r\\nreturn nentry;\\r\\n}\\r\\nX509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne,\\r\\nASN1_OBJECT *obj, int type,\\r\\nconst unsigned char *bytes,\\r\\nint len)\\r\\n{\\r\\nX509_NAME_ENTRY *ret;\\r\\nif ((ne == NULL) || (*ne == NULL)) {\\r\\nif ((ret = X509_NAME_ENTRY_new()) == NULL)\\r\\nreturn (NULL);\\r\\n} else\\r\\nret = *ne;\\r\\nif (!X509_NAME_ENTRY_set_object(ret, obj))\\r\\ngoto err;\\r\\nif (!X509_NAME_ENTRY_set_data(ret, type, bytes, len))\\r\\ngoto err;\\r\\nif ((ne != NULL) && (*ne == NULL))\\r\\n*ne = ret;\\r\\nreturn (ret);\\r\\nerr:\\r\\nif ((ne == NULL) || (ret != *ne))\\r\\nX509_NAME_ENTRY_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nint X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, ASN1_OBJECT *obj)\\r\\n{\\r\\nif ((ne == NULL) || (obj == NULL)) {\\r\\nX509err(X509_F_X509_NAME_ENTRY_SET_OBJECT,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nASN1_OBJECT_free(ne->object);\\r\\nne->object = OBJ_dup(obj);\\r\\nreturn ((ne->object == NULL) ? 0 : 1);\\r\\n}\\r\\nint X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nint i;\\r\\nif ((ne == NULL) || ((bytes == NULL) && (len != 0)))\\r\\nreturn (0);\\r\\nif ((type > 0) && (type & MBSTRING_FLAG))\\r\\nreturn ASN1_STRING_set_by_NID(&ne->value, bytes,\\r\\nlen, type,\\r\\nOBJ_obj2nid(ne->object)) ? 1 : 0;\\r\\nif (len < 0)\\r\\nlen = strlen((const char *)bytes);\\r\\ni = ASN1_STRING_set(ne->value, bytes, len);\\r\\nif (!i)\\r\\nreturn (0);\\r\\nif (type != V_ASN1_UNDEF) {\\r\\nif (type == V_ASN1_APP_CHOOSE)\\r\\nne->value->type = ASN1_PRINTABLE_type(bytes, len);\\r\\nelse\\r\\nne->value->type = type;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nASN1_OBJECT *X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *ne)\\r\\n{\\r\\nif (ne == NULL)\\r\\nreturn (NULL);\\r\\nreturn (ne->object);\\r\\n}\\r\\nASN1_STRING *X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *ne)\\r\\n{\\r\\nif (ne == NULL)\\r\\nreturn (NULL);\\r\\nreturn (ne->value);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pmeth_lib_c", "target": 0, "func": "static int pmeth_cmp(const EVP_PKEY_METHOD *const *a,\\r\\nconst EVP_PKEY_METHOD *const *b)\\r\\n{\\r\\nreturn ((*a)->pkey_id - (*b)->pkey_id);\\r\\n}\\r\\nconst EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type)\\r\\n{\\r\\nEVP_PKEY_METHOD tmp;\\r\\nconst EVP_PKEY_METHOD *t = &tmp, **ret;\\r\\ntmp.pkey_id = type;\\r\\nif (app_pkey_methods) {\\r\\nint idx;\\r\\nidx = sk_EVP_PKEY_METHOD_find(app_pkey_methods, &tmp);\\r\\nif (idx >= 0)\\r\\nreturn sk_EVP_PKEY_METHOD_value(app_pkey_methods, idx);\\r\\n}\\r\\nret = OBJ_bsearch_pmeth(&t, standard_methods,\\r\\nsizeof(standard_methods) /\\r\\nsizeof(EVP_PKEY_METHOD *));\\r\\nif (!ret || !*ret)\\r\\nreturn NULL;\\r\\nreturn *ret;\\r\\n}\\r\\nstatic EVP_PKEY_CTX *int_ctx_new(EVP_PKEY *pkey, ENGINE *e, int id)\\r\\n{\\r\\nEVP_PKEY_CTX *ret;\\r\\nconst EVP_PKEY_METHOD *pmeth;\\r\\nif (id == -1) {\\r\\nif (!pkey || !pkey->ameth)\\r\\nreturn NULL;\\r\\nid = pkey->ameth->pkey_id;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (pkey && pkey->engine)\\r\\ne = pkey->engine;\\r\\nif (e) {\\r\\nif (!ENGINE_init(e)) {\\r\\nEVPerr(EVP_F_INT_CTX_NEW, ERR_R_ENGINE_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\n} else\\r\\ne = ENGINE_get_pkey_meth_engine(id);\\r\\nif (e)\\r\\npmeth = ENGINE_get_pkey_meth(e, id);\\r\\nelse\\r\\n#endif\\r\\npmeth = EVP_PKEY_meth_find(id);\\r\\nif (pmeth == NULL) {\\r\\nEVPerr(EVP_F_INT_CTX_NEW, EVP_R_UNSUPPORTED_ALGORITHM);\\r\\nreturn NULL;\\r\\n}\\r\\nret = OPENSSL_malloc(sizeof(EVP_PKEY_CTX));\\r\\nif (!ret) {\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (e)\\r\\nENGINE_finish(e);\\r\\n#endif\\r\\nEVPerr(EVP_F_INT_CTX_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->engine = e;\\r\\nret->pmeth = pmeth;\\r\\nret->operation = EVP_PKEY_OP_UNDEFINED;\\r\\nret->pkey = pkey;\\r\\nret->peerkey = NULL;\\r\\nret->pkey_gencb = 0;\\r\\nif (pkey)\\r\\nCRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\nret->data = NULL;\\r\\nif (pmeth->init) {\\r\\nif (pmeth->init(ret) <= 0) {\\r\\nEVP_PKEY_CTX_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nEVP_PKEY_METHOD *EVP_PKEY_meth_new(int id, int flags)\\r\\n{\\r\\nEVP_PKEY_METHOD *pmeth;\\r\\npmeth = OPENSSL_malloc(sizeof(EVP_PKEY_METHOD));\\r\\nif (!pmeth)\\r\\nreturn NULL;\\r\\nmemset(pmeth, 0, sizeof(EVP_PKEY_METHOD));\\r\\npmeth->pkey_id = id;\\r\\npmeth->flags = flags | EVP_PKEY_FLAG_DYNAMIC;\\r\\npmeth->init = 0;\\r\\npmeth->copy = 0;\\r\\npmeth->cleanup = 0;\\r\\npmeth->paramgen_init = 0;\\r\\npmeth->paramgen = 0;\\r\\npmeth->keygen_init = 0;\\r\\npmeth->keygen = 0;\\r\\npmeth->sign_init = 0;\\r\\npmeth->sign = 0;\\r\\npmeth->verify_init = 0;\\r\\npmeth->verify = 0;\\r\\npmeth->verify_recover_init = 0;\\r\\npmeth->verify_recover = 0;\\r\\npmeth->signctx_init = 0;\\r\\npmeth->signctx = 0;\\r\\npmeth->verifyctx_init = 0;\\r\\npmeth->verifyctx = 0;\\r\\npmeth->encrypt_init = 0;\\r\\npmeth->encrypt = 0;\\r\\npmeth->decrypt_init = 0;\\r\\npmeth->decrypt = 0;\\r\\npmeth->derive_init = 0;\\r\\npmeth->derive = 0;\\r\\npmeth->ctrl = 0;\\r\\npmeth->ctrl_str = 0;\\r\\nreturn pmeth;\\r\\n}\\r\\nvoid EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,\\r\\nconst EVP_PKEY_METHOD *meth)\\r\\n{\\r\\nif (ppkey_id)\\r\\n*ppkey_id = meth->pkey_id;\\r\\nif (pflags)\\r\\n*pflags = meth->flags;\\r\\n}\\r\\nvoid EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src)\\r\\n{\\r\\ndst->init = src->init;\\r\\ndst->copy = src->copy;\\r\\ndst->cleanup = src->cleanup;\\r\\ndst->paramgen_init = src->paramgen_init;\\r\\ndst->paramgen = src->paramgen;\\r\\ndst->keygen_init = src->keygen_init;\\r\\ndst->keygen = src->keygen;\\r\\ndst->sign_init = src->sign_init;\\r\\ndst->sign = src->sign;\\r\\ndst->verify_init = src->verify_init;\\r\\ndst->verify = src->verify;\\r\\ndst->verify_recover_init = src->verify_recover_init;\\r\\ndst->verify_recover = src->verify_recover;\\r\\ndst->signctx_init = src->signctx_init;\\r\\ndst->signctx = src->signctx;\\r\\ndst->verifyctx_init = src->verifyctx_init;\\r\\ndst->verifyctx = src->verifyctx;\\r\\ndst->encrypt_init = src->encrypt_init;\\r\\ndst->encrypt = src->encrypt;\\r\\ndst->decrypt_init = src->decrypt_init;\\r\\ndst->decrypt = src->decrypt;\\r\\ndst->derive_init = src->derive_init;\\r\\ndst->derive = src->derive;\\r\\ndst->ctrl = src->ctrl;\\r\\ndst->ctrl_str = src->ctrl_str;\\r\\n}\\r\\nvoid EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth)\\r\\n{\\r\\nif (pmeth && (pmeth->flags & EVP_PKEY_FLAG_DYNAMIC))\\r\\nOPENSSL_free(pmeth);\\r\\n}\\r\\nEVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e)\\r\\n{\\r\\nreturn int_ctx_new(pkey, e, -1);\\r\\n}\\r\\nEVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e)\\r\\n{\\r\\nreturn int_ctx_new(NULL, e, id);\\r\\n}\\r\\nEVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *pctx)\\r\\n{\\r\\nEVP_PKEY_CTX *rctx;\\r\\nif (!pctx->pmeth || !pctx->pmeth->copy)\\r\\nreturn NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (pctx->engine && !ENGINE_init(pctx->engine)) {\\r\\nEVPerr(EVP_F_EVP_PKEY_CTX_DUP, ERR_R_ENGINE_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\nrctx = OPENSSL_malloc(sizeof(EVP_PKEY_CTX));\\r\\nif (!rctx)\\r\\nreturn NULL;\\r\\nrctx->pmeth = pctx->pmeth;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nrctx->engine = pctx->engine;\\r\\n#endif\\r\\nif (pctx->pkey)\\r\\nCRYPTO_add(&pctx->pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\nrctx->pkey = pctx->pkey;\\r\\nif (pctx->peerkey)\\r\\nCRYPTO_add(&pctx->peerkey->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\nrctx->peerkey = pctx->peerkey;\\r\\nrctx->data = NULL;\\r\\nrctx->app_data = NULL;\\r\\nrctx->operation = pctx->operation;\\r\\nif (pctx->pmeth->copy(rctx, pctx) > 0)\\r\\nreturn rctx;\\r\\nEVP_PKEY_CTX_free(rctx);\\r\\nreturn NULL;\\r\\n}\\r\\nint EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth)\\r\\n{\\r\\nif (app_pkey_methods == NULL) {\\r\\napp_pkey_methods = sk_EVP_PKEY_METHOD_new(pmeth_cmp);\\r\\nif (!app_pkey_methods)\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_EVP_PKEY_METHOD_push(app_pkey_methods, pmeth))\\r\\nreturn 0;\\r\\nsk_EVP_PKEY_METHOD_sort(app_pkey_methods);\\r\\nreturn 1;\\r\\n}\\r\\nvoid EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nif (ctx == NULL)\\r\\nreturn;\\r\\nif (ctx->pmeth && ctx->pmeth->cleanup)\\r\\nctx->pmeth->cleanup(ctx);\\r\\nif (ctx->pkey)\\r\\nEVP_PKEY_free(ctx->pkey);\\r\\nif (ctx->peerkey)\\r\\nEVP_PKEY_free(ctx->peerkey);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ctx->engine)\\r\\nENGINE_finish(ctx->engine);\\r\\n#endif\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nint EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,\\r\\nint cmd, int p1, void *p2)\\r\\n{\\r\\nint ret;\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->ctrl) {\\r\\nEVPerr(EVP_F_EVP_PKEY_CTX_CTRL, EVP_R_COMMAND_NOT_SUPPORTED);\\r\\nreturn -2;\\r\\n}\\r\\nif ((keytype != -1) && (ctx->pmeth->pkey_id != keytype))\\r\\nreturn -1;\\r\\nif (ctx->operation == EVP_PKEY_OP_UNDEFINED) {\\r\\nEVPerr(EVP_F_EVP_PKEY_CTX_CTRL, EVP_R_NO_OPERATION_SET);\\r\\nreturn -1;\\r\\n}\\r\\nif ((optype != -1) && !(ctx->operation & optype)) {\\r\\nEVPerr(EVP_F_EVP_PKEY_CTX_CTRL, EVP_R_INVALID_OPERATION);\\r\\nreturn -1;\\r\\n}\\r\\nret = ctx->pmeth->ctrl(ctx, cmd, p1, p2);\\r\\nif (ret == -2)\\r\\nEVPerr(EVP_F_EVP_PKEY_CTX_CTRL, EVP_R_COMMAND_NOT_SUPPORTED);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx,\\r\\nconst char *name, const char *value)\\r\\n{\\r\\nif (!ctx || !ctx->pmeth || !ctx->pmeth->ctrl_str) {\\r\\nEVPerr(EVP_F_EVP_PKEY_CTX_CTRL_STR, EVP_R_COMMAND_NOT_SUPPORTED);\\r\\nreturn -2;\\r\\n}\\r\\nif (!strcmp(name, \"digest\")) {\\r\\nconst EVP_MD *md;\\r\\nif (!value || !(md = EVP_get_digestbyname(value))) {\\r\\nEVPerr(EVP_F_EVP_PKEY_CTX_CTRL_STR, EVP_R_INVALID_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EVP_PKEY_CTX_set_signature_md(ctx, md);\\r\\n}\\r\\nreturn ctx->pmeth->ctrl_str(ctx, name, value);\\r\\n}\\r\\nint EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nreturn ctx->operation;\\r\\n}\\r\\nvoid EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen)\\r\\n{\\r\\nctx->keygen_info = dat;\\r\\nctx->keygen_info_count = datlen;\\r\\n}\\r\\nvoid EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data)\\r\\n{\\r\\nctx->data = data;\\r\\n}\\r\\nvoid *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nreturn ctx->data;\\r\\n}\\r\\nEVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nreturn ctx->pkey;\\r\\n}\\r\\nEVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nreturn ctx->peerkey;\\r\\n}\\r\\nvoid EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data)\\r\\n{\\r\\nctx->app_data = data;\\r\\n}\\r\\nvoid *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nreturn ctx->app_data;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,\\r\\nint (*init) (EVP_PKEY_CTX *ctx))\\r\\n{\\r\\npmeth->init = init;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,\\r\\nint (*copy) (EVP_PKEY_CTX *dst,\\r\\nEVP_PKEY_CTX *src))\\r\\n{\\r\\npmeth->copy = copy;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,\\r\\nvoid (*cleanup) (EVP_PKEY_CTX *ctx))\\r\\n{\\r\\npmeth->cleanup = cleanup;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,\\r\\nint (*paramgen_init) (EVP_PKEY_CTX *ctx),\\r\\nint (*paramgen) (EVP_PKEY_CTX *ctx,\\r\\nEVP_PKEY *pkey))\\r\\n{\\r\\npmeth->paramgen_init = paramgen_init;\\r\\npmeth->paramgen = paramgen;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,\\r\\nint (*keygen_init) (EVP_PKEY_CTX *ctx),\\r\\nint (*keygen) (EVP_PKEY_CTX *ctx,\\r\\nEVP_PKEY *pkey))\\r\\n{\\r\\npmeth->keygen_init = keygen_init;\\r\\npmeth->keygen = keygen;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,\\r\\nint (*sign_init) (EVP_PKEY_CTX *ctx),\\r\\nint (*sign) (EVP_PKEY_CTX *ctx,\\r\\nunsigned char *sig, size_t *siglen,\\r\\nconst unsigned char *tbs,\\r\\nsize_t tbslen))\\r\\n{\\r\\npmeth->sign_init = sign_init;\\r\\npmeth->sign = sign;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,\\r\\nint (*verify_init) (EVP_PKEY_CTX *ctx),\\r\\nint (*verify) (EVP_PKEY_CTX *ctx,\\r\\nconst unsigned char *sig,\\r\\nsize_t siglen,\\r\\nconst unsigned char *tbs,\\r\\nsize_t tbslen))\\r\\n{\\r\\npmeth->verify_init = verify_init;\\r\\npmeth->verify = verify;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,\\r\\nint (*verify_recover_init) (EVP_PKEY_CTX\\r\\n*ctx),\\r\\nint (*verify_recover) (EVP_PKEY_CTX\\r\\n*ctx,\\r\\nunsigned char\\r\\n*sig,\\r\\nsize_t *siglen,\\r\\nconst unsigned\\r\\nchar *tbs,\\r\\nsize_t tbslen))\\r\\n{\\r\\npmeth->verify_recover_init = verify_recover_init;\\r\\npmeth->verify_recover = verify_recover;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,\\r\\nint (*signctx_init) (EVP_PKEY_CTX *ctx,\\r\\nEVP_MD_CTX *mctx),\\r\\nint (*signctx) (EVP_PKEY_CTX *ctx,\\r\\nunsigned char *sig,\\r\\nsize_t *siglen,\\r\\nEVP_MD_CTX *mctx))\\r\\n{\\r\\npmeth->signctx_init = signctx_init;\\r\\npmeth->signctx = signctx;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,\\r\\nint (*verifyctx_init) (EVP_PKEY_CTX *ctx,\\r\\nEVP_MD_CTX *mctx),\\r\\nint (*verifyctx) (EVP_PKEY_CTX *ctx,\\r\\nconst unsigned char *sig,\\r\\nint siglen,\\r\\nEVP_MD_CTX *mctx))\\r\\n{\\r\\npmeth->verifyctx_init = verifyctx_init;\\r\\npmeth->verifyctx = verifyctx;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,\\r\\nint (*encrypt_init) (EVP_PKEY_CTX *ctx),\\r\\nint (*encryptfn) (EVP_PKEY_CTX *ctx,\\r\\nunsigned char *out,\\r\\nsize_t *outlen,\\r\\nconst unsigned char *in,\\r\\nsize_t inlen))\\r\\n{\\r\\npmeth->encrypt_init = encrypt_init;\\r\\npmeth->encrypt = encryptfn;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,\\r\\nint (*decrypt_init) (EVP_PKEY_CTX *ctx),\\r\\nint (*decrypt) (EVP_PKEY_CTX *ctx,\\r\\nunsigned char *out,\\r\\nsize_t *outlen,\\r\\nconst unsigned char *in,\\r\\nsize_t inlen))\\r\\n{\\r\\npmeth->decrypt_init = decrypt_init;\\r\\npmeth->decrypt = decrypt;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,\\r\\nint (*derive_init) (EVP_PKEY_CTX *ctx),\\r\\nint (*derive) (EVP_PKEY_CTX *ctx,\\r\\nunsigned char *key,\\r\\nsize_t *keylen))\\r\\n{\\r\\npmeth->derive_init = derive_init;\\r\\npmeth->derive = derive;\\r\\n}\\r\\nvoid EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,\\r\\nint (*ctrl) (EVP_PKEY_CTX *ctx, int type, int p1,\\r\\nvoid *p2),\\r\\nint (*ctrl_str) (EVP_PKEY_CTX *ctx,\\r\\nconst char *type,\\r\\nconst char *value))\\r\\n{\\r\\npmeth->ctrl = ctrl;\\r\\npmeth->ctrl_str = ctrl_str;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_s_socket_c", "target": 0, "func": "static LONG FAR PASCAL topHookProc(HWND hwnd, UINT message, WPARAM wParam,\\r\\nLPARAM lParam)\\r\\n{\\r\\nif (hwnd == topWnd) {\\r\\nswitch (message) {\\r\\ncase WM_DESTROY:\\r\\ncase WM_CLOSE:\\r\\nSetWindowLong(topWnd, GWL_WNDPROC, (LONG) lpTopWndProc);\\r\\nssl_sock_cleanup();\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn CallWindowProc(lpTopWndProc, hwnd, message, wParam, lParam);\\r\\n}\\r\\nstatic BOOL CALLBACK enumproc(HWND hwnd, LPARAM lParam)\\r\\n{\\r\\ntopWnd = hwnd;\\r\\nreturn (FALSE);\\r\\n}\\r\\nstatic void ssl_sock_cleanup(void)\\r\\n{\\r\\nif (wsa_init_done) {\\r\\nwsa_init_done = 0;\\r\\n# ifndef OPENSSL_SYS_WINCE\\r\\nWSACancelBlockingCall();\\r\\n# endif\\r\\nWSACleanup();\\r\\n}\\r\\n}\\r\\nstatic void sock_cleanup(void)\\r\\n{\\r\\nif (wsa_init_done) {\\r\\nwsa_init_done = 0;\\r\\nWSACleanup();\\r\\n}\\r\\n}\\r\\nstatic int ssl_sock_init(void)\\r\\n{\\r\\n# ifdef WATT32\\r\\nextern int _watt_do_exit;\\r\\n_watt_do_exit = 0;\\r\\nif (sock_init())\\r\\nreturn (0);\\r\\n# elif defined(OPENSSL_SYS_WINDOWS)\\r\\nif (!wsa_init_done) {\\r\\nint err;\\r\\n# ifdef SIGINT\\r\\nsignal(SIGINT, (void (*)(int))ssl_sock_cleanup);\\r\\n# endif\\r\\nwsa_init_done = 1;\\r\\nmemset(&wsa_state, 0, sizeof(wsa_state));\\r\\nif (WSAStartup(0x0101, &wsa_state) != 0) {\\r\\nerr = WSAGetLastError();\\r\\nBIO_printf(bio_err, \"unable to start WINSOCK, error code=%d\\n\",\\r\\nerr);\\r\\nreturn (0);\\r\\n}\\r\\n# ifdef OPENSSL_SYS_WIN16\\r\\nEnumTaskWindows(GetCurrentTask(), enumproc, 0L);\\r\\nlpTopWndProc = (FARPROC) GetWindowLong(topWnd, GWL_WNDPROC);\\r\\nlpTopHookProc = MakeProcInstance((FARPROC) topHookProc, _hInstance);\\r\\nSetWindowLong(topWnd, GWL_WNDPROC, (LONG) lpTopHookProc);\\r\\n# endif\\r\\n}\\r\\n# elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)\\r\\nWORD wVerReq;\\r\\nWSADATA wsaData;\\r\\nint err;\\r\\nif (!wsa_init_done) {\\r\\n# ifdef SIGINT\\r\\nsignal(SIGINT, (void (*)(int))sock_cleanup);\\r\\n# endif\\r\\nwsa_init_done = 1;\\r\\nwVerReq = MAKEWORD(2, 0);\\r\\nerr = WSAStartup(wVerReq, &wsaData);\\r\\nif (err != 0) {\\r\\nBIO_printf(bio_err, \"unable to start WINSOCK2, error code=%d\\n\",\\r\\nerr);\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\n# endif\\r\\nreturn (1);\\r\\n}\\r\\nint init_client(int *sock, char *host, int port, int type)\\r\\n{\\r\\nunsigned char ip[4];\\r\\nmemset(ip, '\\0', sizeof ip);\\r\\nif (!host_ip(host, &(ip[0])))\\r\\nreturn 0;\\r\\nreturn init_client_ip(sock, ip, port, type);\\r\\n}\\r\\nstatic int init_client_ip(int *sock, unsigned char ip[4], int port, int type)\\r\\n{\\r\\nunsigned long addr;\\r\\nstruct sockaddr_in them;\\r\\nint s, i;\\r\\nif (!ssl_sock_init())\\r\\nreturn (0);\\r\\nmemset((char *)&them, 0, sizeof(them));\\r\\nthem.sin_family = AF_INET;\\r\\nthem.sin_port = htons((unsigned short)port);\\r\\naddr = (unsigned long)\\r\\n((unsigned long)ip[0] << 24L) |\\r\\n((unsigned long)ip[1] << 16L) |\\r\\n((unsigned long)ip[2] << 8L) | ((unsigned long)ip[3]);\\r\\nthem.sin_addr.s_addr = htonl(addr);\\r\\nif (type == SOCK_STREAM)\\r\\ns = socket(AF_INET, SOCK_STREAM, SOCKET_PROTOCOL);\\r\\nelse\\r\\ns = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\\r\\nif (s == INVALID_SOCKET) {\\r\\nperror(\"socket\");\\r\\nreturn (0);\\r\\n}\\r\\n# if defined(SO_KEEPALIVE) && !defined(OPENSSL_SYS_MPE)\\r\\nif (type == SOCK_STREAM) {\\r\\ni = 0;\\r\\ni = setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (char *)&i, sizeof(i));\\r\\nif (i < 0) {\\r\\nclosesocket(s);\\r\\nperror(\"keepalive\");\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\n# endif\\r\\nif (connect(s, (struct sockaddr *)&them, sizeof(them)) == -1) {\\r\\nclosesocket(s);\\r\\nperror(\"connect\");\\r\\nreturn (0);\\r\\n}\\r\\n*sock = s;\\r\\nreturn (1);\\r\\n}\\r\\nint do_server(int port, int type, int *ret,\\r\\nint (*cb) (char *hostname, int s, int stype,\\r\\nunsigned char *context), unsigned char *context,\\r\\nint naccept)\\r\\n{\\r\\nint sock;\\r\\nchar *name = NULL;\\r\\nint accept_socket = 0;\\r\\nint i;\\r\\nif (!init_server(&accept_socket, port, type))\\r\\nreturn (0);\\r\\nif (ret != NULL) {\\r\\n*ret = accept_socket;\\r\\n}\\r\\nfor (;;) {\\r\\nif (type == SOCK_STREAM) {\\r\\nif (do_accept(accept_socket, &sock, &name) == 0) {\\r\\nSHUTDOWN(accept_socket);\\r\\nreturn (0);\\r\\n}\\r\\n} else\\r\\nsock = accept_socket;\\r\\ni = (*cb) (name, sock, type, context);\\r\\nif (name != NULL)\\r\\nOPENSSL_free(name);\\r\\nif (type == SOCK_STREAM)\\r\\nSHUTDOWN2(sock);\\r\\nif (naccept != -1)\\r\\nnaccept--;\\r\\nif (i < 0 || naccept == 0) {\\r\\nSHUTDOWN2(accept_socket);\\r\\nreturn (i);\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int init_server_long(int *sock, int port, char *ip, int type)\\r\\n{\\r\\nint ret = 0;\\r\\nstruct sockaddr_in server;\\r\\nint s = -1;\\r\\nif (!ssl_sock_init())\\r\\nreturn (0);\\r\\nmemset((char *)&server, 0, sizeof(server));\\r\\nserver.sin_family = AF_INET;\\r\\nserver.sin_port = htons((unsigned short)port);\\r\\nif (ip == NULL)\\r\\nserver.sin_addr.s_addr = INADDR_ANY;\\r\\nelse\\r\\n# ifndef BIT_FIELD_LIMITS\\r\\nmemcpy(&server.sin_addr.s_addr, ip, 4);\\r\\n# else\\r\\nmemcpy(&server.sin_addr, ip, 4);\\r\\n# endif\\r\\nif (type == SOCK_STREAM)\\r\\ns = socket(AF_INET, SOCK_STREAM, SOCKET_PROTOCOL);\\r\\nelse\\r\\ns = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\\r\\nif (s == INVALID_SOCKET)\\r\\ngoto err;\\r\\n# if defined SOL_SOCKET && defined SO_REUSEADDR\\r\\n{\\r\\nint j = 1;\\r\\nsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void *)&j, sizeof j);\\r\\n}\\r\\n# endif\\r\\nif (bind(s, (struct sockaddr *)&server, sizeof(server)) == -1) {\\r\\n# ifndef OPENSSL_SYS_WINDOWS\\r\\nperror(\"bind\");\\r\\n# endif\\r\\ngoto err;\\r\\n}\\r\\nif (type == SOCK_STREAM && listen(s, 128) == -1)\\r\\ngoto err;\\r\\n*sock = s;\\r\\nret = 1;\\r\\nerr:\\r\\nif ((ret == 0) && (s != -1)) {\\r\\nSHUTDOWN(s);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int init_server(int *sock, int port, int type)\\r\\n{\\r\\nreturn (init_server_long(sock, port, NULL, type));\\r\\n}\\r\\nstatic int do_accept(int acc_sock, int *sock, char **host)\\r\\n{\\r\\nint ret;\\r\\nstruct hostent *h1, *h2;\\r\\nstatic struct sockaddr_in from;\\r\\nint len;\\r\\nif (!ssl_sock_init())\\r\\nreturn (0);\\r\\n# ifndef OPENSSL_SYS_WINDOWS\\r\\nredoit:\\r\\n# endif\\r\\nmemset((char *)&from, 0, sizeof(from));\\r\\nlen = sizeof(from);\\r\\nret = accept(acc_sock, (struct sockaddr *)&from, (void *)&len);\\r\\nif (ret == INVALID_SOCKET) {\\r\\n# if defined(OPENSSL_SYS_WINDOWS) || (defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK))\\r\\nint i;\\r\\ni = WSAGetLastError();\\r\\nBIO_printf(bio_err, \"accept error %d\\n\", i);\\r\\n# else\\r\\nif (errno == EINTR) {\\r\\ngoto redoit;\\r\\n}\\r\\nfprintf(stderr, \"errno=%d \", errno);\\r\\nperror(\"accept\");\\r\\n# endif\\r\\nreturn (0);\\r\\n}\\r\\nif (host == NULL)\\r\\ngoto end;\\r\\n# ifndef BIT_FIELD_LIMITS\\r\\nh1 = gethostbyaddr((char *)&from.sin_addr.s_addr,\\r\\nsizeof(from.sin_addr.s_addr), AF_INET);\\r\\n# else\\r\\nh1 = gethostbyaddr((char *)&from.sin_addr,\\r\\nsizeof(struct in_addr), AF_INET);\\r\\n# endif\\r\\nif (h1 == NULL) {\\r\\nBIO_printf(bio_err, \"bad gethostbyaddr\\n\");\\r\\n*host = NULL;\\r\\n} else {\\r\\nif ((*host = (char *)OPENSSL_malloc(strlen(h1->h_name) + 1)) == NULL) {\\r\\nperror(\"OPENSSL_malloc\");\\r\\nclosesocket(ret);\\r\\nreturn (0);\\r\\n}\\r\\nBUF_strlcpy(*host, h1->h_name, strlen(h1->h_name) + 1);\\r\\nh2 = GetHostByName(*host);\\r\\nif (h2 == NULL) {\\r\\nBIO_printf(bio_err, \"gethostbyname failure\\n\");\\r\\nclosesocket(ret);\\r\\nreturn (0);\\r\\n}\\r\\nif (h2->h_addrtype != AF_INET) {\\r\\nBIO_printf(bio_err, \"gethostbyname addr is not AF_INET\\n\");\\r\\nclosesocket(ret);\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nend:\\r\\n*sock = ret;\\r\\nreturn (1);\\r\\n}\\r\\nint extract_host_port(char *str, char **host_ptr, unsigned char *ip,\\r\\nshort *port_ptr)\\r\\n{\\r\\nchar *h, *p;\\r\\nh = str;\\r\\np = strchr(str, ':');\\r\\nif (p == NULL) {\\r\\nBIO_printf(bio_err, \"no port defined\\n\");\\r\\nreturn (0);\\r\\n}\\r\\n*(p++) = '\\0';\\r\\nif ((ip != NULL) && !host_ip(str, ip))\\r\\ngoto err;\\r\\nif (host_ptr != NULL)\\r\\n*host_ptr = h;\\r\\nif (!extract_port(p, port_ptr))\\r\\ngoto err;\\r\\nreturn (1);\\r\\nerr:\\r\\nreturn (0);\\r\\n}\\r\\nstatic int host_ip(char *str, unsigned char ip[4])\\r\\n{\\r\\nunsigned int in[4];\\r\\nint i;\\r\\nif (sscanf(str, \"%u.%u.%u.%u\", &(in[0]), &(in[1]), &(in[2]), &(in[3])) ==\\r\\n4) {\\r\\nfor (i = 0; i < 4; i++)\\r\\nif (in[i] > 255) {\\r\\nBIO_printf(bio_err, \"invalid IP address\\n\");\\r\\ngoto err;\\r\\n}\\r\\nip[0] = in[0];\\r\\nip[1] = in[1];\\r\\nip[2] = in[2];\\r\\nip[3] = in[3];\\r\\n} else {\\r\\nstruct hostent *he;\\r\\nif (!ssl_sock_init())\\r\\nreturn (0);\\r\\nhe = GetHostByName(str);\\r\\nif (he == NULL) {\\r\\nBIO_printf(bio_err, \"gethostbyname failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((short)he->h_addrtype != AF_INET) {\\r\\nBIO_printf(bio_err, \"gethostbyname addr is not AF_INET\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nip[0] = he->h_addr_list[0][0];\\r\\nip[1] = he->h_addr_list[0][1];\\r\\nip[2] = he->h_addr_list[0][2];\\r\\nip[3] = he->h_addr_list[0][3];\\r\\n}\\r\\nreturn (1);\\r\\nerr:\\r\\nreturn (0);\\r\\n}\\r\\nint extract_port(char *str, short *port_ptr)\\r\\n{\\r\\nint i;\\r\\nstruct servent *s;\\r\\ni = atoi(str);\\r\\nif (i != 0)\\r\\n*port_ptr = (unsigned short)i;\\r\\nelse {\\r\\ns = getservbyname(str, \"tcp\");\\r\\nif (s == NULL) {\\r\\nBIO_printf(bio_err, \"getservbyname failure for %s\\n\", str);\\r\\nreturn (0);\\r\\n}\\r\\n*port_ptr = ntohs((unsigned short)s->s_port);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic struct hostent *GetHostByName(char *name)\\r\\n{\\r\\nstruct hostent *ret;\\r\\nint i, lowi = 0;\\r\\nunsigned long low = (unsigned long)-1;\\r\\nfor (i = 0; i < GHBN_NUM; i++) {\\r\\nif (low > ghbn_cache[i].order) {\\r\\nlow = ghbn_cache[i].order;\\r\\nlowi = i;\\r\\n}\\r\\nif (ghbn_cache[i].order > 0) {\\r\\nif (strncmp(name, ghbn_cache[i].name, 128) == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (i == GHBN_NUM) {\\r\\nghbn_miss++;\\r\\nret = gethostbyname(name);\\r\\nif (ret == NULL)\\r\\nreturn (NULL);\\r\\nif (strlen(name) < sizeof ghbn_cache[0].name) {\\r\\nstrcpy(ghbn_cache[lowi].name, name);\\r\\nmemcpy((char *)&(ghbn_cache[lowi].ent), ret,\\r\\nsizeof(struct hostent));\\r\\nghbn_cache[lowi].order = ghbn_miss + ghbn_hits;\\r\\n}\\r\\nreturn (ret);\\r\\n} else {\\r\\nghbn_hits++;\\r\\nret = &(ghbn_cache[i].ent);\\r\\nghbn_cache[i].order = ghbn_miss + ghbn_hits;\\r\\nreturn (ret);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cmll_ofb_c", "target": 0, "func": "void Camellia_ofb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const CAMELLIA_KEY *key,\\r\\nunsigned char *ivec, int *num)\\r\\n{\\r\\nCRYPTO_ofb128_encrypt(in, out, length, key, ivec, num,\\r\\n(block128_f) Camellia_encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_passwd_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret = 1;\\r\\nchar *infile = NULL;\\r\\nint in_stdin = 0;\\r\\nint in_noverify = 0;\\r\\nchar *salt = NULL, *passwd = NULL, **passwds = NULL;\\r\\nchar *salt_malloc = NULL, *passwd_malloc = NULL;\\r\\nsize_t passwd_malloc_size = 0;\\r\\nint pw_source_defined = 0;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint i, badopt, opt_done;\\r\\nint passed_salt = 0, quiet = 0, table = 0, reverse = 0;\\r\\nint usecrypt = 0, use1 = 0, useapr1 = 0;\\r\\nsize_t pw_maxlen = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto err;\\r\\nout = BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\ngoto err;\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\nbadopt = 0, opt_done = 0;\\r\\ni = 0;\\r\\nwhile (!badopt && !opt_done && argv[++i] != NULL) {\\r\\nif (strcmp(argv[i], \"-crypt\") == 0)\\r\\nusecrypt = 1;\\r\\nelse if (strcmp(argv[i], \"-1\") == 0)\\r\\nuse1 = 1;\\r\\nelse if (strcmp(argv[i], \"-apr1\") == 0)\\r\\nuseapr1 = 1;\\r\\nelse if (strcmp(argv[i], \"-salt\") == 0) {\\r\\nif ((argv[i + 1] != NULL) && (salt == NULL)) {\\r\\npassed_salt = 1;\\r\\nsalt = argv[++i];\\r\\n} else\\r\\nbadopt = 1;\\r\\n} else if (strcmp(argv[i], \"-in\") == 0) {\\r\\nif ((argv[i + 1] != NULL) && !pw_source_defined) {\\r\\npw_source_defined = 1;\\r\\ninfile = argv[++i];\\r\\n} else\\r\\nbadopt = 1;\\r\\n} else if (strcmp(argv[i], \"-stdin\") == 0) {\\r\\nif (!pw_source_defined) {\\r\\npw_source_defined = 1;\\r\\nin_stdin = 1;\\r\\n} else\\r\\nbadopt = 1;\\r\\n} else if (strcmp(argv[i], \"-noverify\") == 0)\\r\\nin_noverify = 1;\\r\\nelse if (strcmp(argv[i], \"-quiet\") == 0)\\r\\nquiet = 1;\\r\\nelse if (strcmp(argv[i], \"-table\") == 0)\\r\\ntable = 1;\\r\\nelse if (strcmp(argv[i], \"-reverse\") == 0)\\r\\nreverse = 1;\\r\\nelse if (argv[i][0] == '-')\\r\\nbadopt = 1;\\r\\nelse if (!pw_source_defined)\\r\\n{\\r\\npw_source_defined = 1;\\r\\npasswds = &argv[i];\\r\\nopt_done = 1;\\r\\n} else\\r\\nbadopt = 1;\\r\\n}\\r\\nif (!usecrypt && !use1 && !useapr1)\\r\\nusecrypt = 1;\\r\\nif (usecrypt + use1 + useapr1 > 1)\\r\\nbadopt = 1;\\r\\n# ifdef OPENSSL_NO_DES\\r\\nif (usecrypt)\\r\\nbadopt = 1;\\r\\n# endif\\r\\n# ifdef NO_MD5CRYPT_1\\r\\nif (use1 || useapr1)\\r\\nbadopt = 1;\\r\\n# endif\\r\\nif (badopt) {\\r\\nBIO_printf(bio_err, \"Usage: passwd [options] [passwords]\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\n# ifndef OPENSSL_NO_DES\\r\\nBIO_printf(bio_err,\\r\\n\"-crypt standard Unix password algorithm (default)\\n\");\\r\\n# endif\\r\\n# ifndef NO_MD5CRYPT_1\\r\\nBIO_printf(bio_err,\\r\\n\"-1 MD5-based password algorithm\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-apr1 MD5-based password algorithm, Apache variant\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \"-salt string use provided salt\\n\");\\r\\nBIO_printf(bio_err, \"-in file read passwords from file\\n\");\\r\\nBIO_printf(bio_err, \"-stdin read passwords from stdin\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-noverify never verify when reading password from terminal\\n\");\\r\\nBIO_printf(bio_err, \"-quiet no warnings\\n\");\\r\\nBIO_printf(bio_err, \"-table format output as table\\n\");\\r\\nBIO_printf(bio_err, \"-reverse switch table columns\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((infile != NULL) || in_stdin) {\\r\\nin = BIO_new(BIO_s_file());\\r\\nif (in == NULL)\\r\\ngoto err;\\r\\nif (infile != NULL) {\\r\\nassert(in_stdin == 0);\\r\\nif (BIO_read_filename(in, infile) <= 0)\\r\\ngoto err;\\r\\n} else {\\r\\nassert(in_stdin);\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\n}\\r\\n}\\r\\nif (usecrypt)\\r\\npw_maxlen = 8;\\r\\nelse if (use1 || useapr1)\\r\\npw_maxlen = 256;\\r\\nif (passwds == NULL) {\\r\\npasswd_malloc_size = pw_maxlen + 2;\\r\\npasswd = passwd_malloc = OPENSSL_malloc(passwd_malloc_size);\\r\\nif (passwd_malloc == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif ((in == NULL) && (passwds == NULL)) {\\r\\nstatic char *passwds_static[2] = { NULL, NULL };\\r\\npasswds = passwds_static;\\r\\nif (in == NULL)\\r\\nif (EVP_read_pw_string\\r\\n(passwd_malloc, passwd_malloc_size, \"Password: \",\\r\\n!(passed_salt || in_noverify)) != 0)\\r\\ngoto err;\\r\\npasswds[0] = passwd_malloc;\\r\\n}\\r\\nif (in == NULL) {\\r\\nassert(passwds != NULL);\\r\\nassert(*passwds != NULL);\\r\\ndo {\\r\\npasswd = *passwds++;\\r\\nif (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, out,\\r\\nquiet, table, reverse, pw_maxlen, usecrypt, use1,\\r\\nuseapr1))\\r\\ngoto err;\\r\\n}\\r\\nwhile (*passwds != NULL);\\r\\n} else\\r\\n{\\r\\nint done;\\r\\nassert(passwd != NULL);\\r\\ndo {\\r\\nint r = BIO_gets(in, passwd, pw_maxlen + 1);\\r\\nif (r > 0) {\\r\\nchar *c = (strchr(passwd, '\\n'));\\r\\nif (c != NULL)\\r\\n*c = 0;\\r\\nelse {\\r\\nchar trash[BUFSIZ];\\r\\ndo\\r\\nr = BIO_gets(in, trash, sizeof trash);\\r\\nwhile ((r > 0) && (!strchr(trash, '\\n')));\\r\\n}\\r\\nif (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, out,\\r\\nquiet, table, reverse, pw_maxlen, usecrypt,\\r\\nuse1, useapr1))\\r\\ngoto err;\\r\\n}\\r\\ndone = (r <= 0);\\r\\n}\\r\\nwhile (!done);\\r\\n}\\r\\nret = 0;\\r\\nerr:\\r\\nERR_print_errors(bio_err);\\r\\nif (salt_malloc)\\r\\nOPENSSL_free(salt_malloc);\\r\\nif (passwd_malloc)\\r\\nOPENSSL_free(passwd_malloc);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free_all(out);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic char *md5crypt(const char *passwd, const char *magic, const char *salt)\\r\\n{\\r\\nstatic char out_buf[6 + 9 + 24 + 2];\\r\\nunsigned char buf[MD5_DIGEST_LENGTH];\\r\\nchar *salt_out;\\r\\nint n;\\r\\nunsigned int i;\\r\\nEVP_MD_CTX md, md2;\\r\\nsize_t passwd_len, salt_len;\\r\\npasswd_len = strlen(passwd);\\r\\nout_buf[0] = '$';\\r\\nout_buf[1] = 0;\\r\\nassert(strlen(magic) <= 4);\\r\\nstrncat(out_buf, magic, 4);\\r\\nstrncat(out_buf, \"$\", 1);\\r\\nstrncat(out_buf, salt, 8);\\r\\nassert(strlen(out_buf) <= 6 + 8);\\r\\nsalt_out = out_buf + 2 + strlen(magic);\\r\\nsalt_len = strlen(salt_out);\\r\\nassert(salt_len <= 8);\\r\\nEVP_MD_CTX_init(&md);\\r\\nEVP_DigestInit_ex(&md, EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md, passwd, passwd_len);\\r\\nEVP_DigestUpdate(&md, \"$\", 1);\\r\\nEVP_DigestUpdate(&md, magic, strlen(magic));\\r\\nEVP_DigestUpdate(&md, \"$\", 1);\\r\\nEVP_DigestUpdate(&md, salt_out, salt_len);\\r\\nEVP_MD_CTX_init(&md2);\\r\\nEVP_DigestInit_ex(&md2, EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md2, passwd, passwd_len);\\r\\nEVP_DigestUpdate(&md2, salt_out, salt_len);\\r\\nEVP_DigestUpdate(&md2, passwd, passwd_len);\\r\\nEVP_DigestFinal_ex(&md2, buf, NULL);\\r\\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf)\\r\\nEVP_DigestUpdate(&md, buf, sizeof buf);\\r\\nEVP_DigestUpdate(&md, buf, i);\\r\\nn = passwd_len;\\r\\nwhile (n) {\\r\\nEVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1);\\r\\nn >>= 1;\\r\\n}\\r\\nEVP_DigestFinal_ex(&md, buf, NULL);\\r\\nfor (i = 0; i < 1000; i++) {\\r\\nEVP_DigestInit_ex(&md2, EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md2, (i & 1) ? (unsigned const char *)passwd : buf,\\r\\n(i & 1) ? passwd_len : sizeof buf);\\r\\nif (i % 3)\\r\\nEVP_DigestUpdate(&md2, salt_out, salt_len);\\r\\nif (i % 7)\\r\\nEVP_DigestUpdate(&md2, passwd, passwd_len);\\r\\nEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned const char *)passwd,\\r\\n(i & 1) ? sizeof buf : passwd_len);\\r\\nEVP_DigestFinal_ex(&md2, buf, NULL);\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&md2);\\r\\n{\\r\\nunsigned char buf_perm[sizeof buf];\\r\\nint dest, source;\\r\\nchar *output;\\r\\nfor (dest = 0, source = 0; dest < 14;\\r\\ndest++, source = (source + 6) % 17)\\r\\nbuf_perm[dest] = buf[source];\\r\\nbuf_perm[14] = buf[5];\\r\\nbuf_perm[15] = buf[11];\\r\\n# ifndef PEDANTIC\\r\\nassert(16 == sizeof buf_perm);\\r\\n# endif\\r\\noutput = salt_out + salt_len;\\r\\nassert(output == out_buf + strlen(out_buf));\\r\\n*output++ = '$';\\r\\nfor (i = 0; i < 15; i += 3) {\\r\\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\\r\\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\\r\\n(buf_perm[i + 2] >> 6)];\\r\\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\\r\\n(buf_perm[i + 1] >> 4)];\\r\\n*output++ = cov_2char[buf_perm[i] >> 2];\\r\\n}\\r\\nassert(i == 15);\\r\\n*output++ = cov_2char[buf_perm[i] & 0x3f];\\r\\n*output++ = cov_2char[buf_perm[i] >> 6];\\r\\n*output = 0;\\r\\nassert(strlen(out_buf) < sizeof(out_buf));\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&md);\\r\\nreturn out_buf;\\r\\n}\\r\\nstatic int do_passwd(int passed_salt, char **salt_p, char **salt_malloc_p,\\r\\nchar *passwd, BIO *out, int quiet, int table,\\r\\nint reverse, size_t pw_maxlen, int usecrypt, int use1,\\r\\nint useapr1)\\r\\n{\\r\\nchar *hash = NULL;\\r\\nassert(salt_p != NULL);\\r\\nassert(salt_malloc_p != NULL);\\r\\nif (!passed_salt) {\\r\\n# ifndef OPENSSL_NO_DES\\r\\nif (usecrypt) {\\r\\nif (*salt_malloc_p == NULL) {\\r\\n*salt_p = *salt_malloc_p = OPENSSL_malloc(3);\\r\\nif (*salt_malloc_p == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (RAND_pseudo_bytes((unsigned char *)*salt_p, 2) < 0)\\r\\ngoto err;\\r\\n(*salt_p)[0] = cov_2char[(*salt_p)[0] & 0x3f];\\r\\n(*salt_p)[1] = cov_2char[(*salt_p)[1] & 0x3f];\\r\\n(*salt_p)[2] = 0;\\r\\n# ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(*salt_p, *salt_p, 2);\\r\\n# endif\\r\\n}\\r\\n# endif\\r\\n# ifndef NO_MD5CRYPT_1\\r\\nif (use1 || useapr1) {\\r\\nint i;\\r\\nif (*salt_malloc_p == NULL) {\\r\\n*salt_p = *salt_malloc_p = OPENSSL_malloc(9);\\r\\nif (*salt_malloc_p == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (RAND_pseudo_bytes((unsigned char *)*salt_p, 8) < 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < 8; i++)\\r\\n(*salt_p)[i] = cov_2char[(*salt_p)[i] & 0x3f];\\r\\n(*salt_p)[8] = 0;\\r\\n}\\r\\n# endif\\r\\n}\\r\\nassert(*salt_p != NULL);\\r\\nif ((strlen(passwd) > pw_maxlen)) {\\r\\nif (!quiet)\\r\\nBIO_printf(bio_err,\\r\\n\"Warning: truncating password to %u characters\\n\",\\r\\n(unsigned)pw_maxlen);\\r\\npasswd[pw_maxlen] = 0;\\r\\n}\\r\\nassert(strlen(passwd) <= pw_maxlen);\\r\\n# ifndef OPENSSL_NO_DES\\r\\nif (usecrypt)\\r\\nhash = DES_crypt(passwd, *salt_p);\\r\\n# endif\\r\\n# ifndef NO_MD5CRYPT_1\\r\\nif (use1 || useapr1)\\r\\nhash = md5crypt(passwd, (use1 ? \"1\" : \"apr1\"), *salt_p);\\r\\n# endif\\r\\nassert(hash != NULL);\\r\\nif (table && !reverse)\\r\\nBIO_printf(out, \"%s\\t%s\\n\", passwd, hash);\\r\\nelse if (table && reverse)\\r\\nBIO_printf(out, \"%s\\t%s\\n\", hash, passwd);\\r\\nelse\\r\\nBIO_printf(out, \"%s\\n\", hash);\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nfputs(\"Program not available.\\n\", stderr)\\r\\nOPENSSL_EXIT(1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_c_enc_c", "target": 0, "func": "void CAST_encrypt(CAST_LONG *data, const CAST_KEY *key)\\r\\n{\\r\\nregister CAST_LONG l, r, t;\\r\\nconst register CAST_LONG *k;\\r\\nk = &(key->data[0]);\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nE_CAST(0, k, l, r, +, ^, -);\\r\\nE_CAST(1, k, r, l, ^, -, +);\\r\\nE_CAST(2, k, l, r, -, +, ^);\\r\\nE_CAST(3, k, r, l, +, ^, -);\\r\\nE_CAST(4, k, l, r, ^, -, +);\\r\\nE_CAST(5, k, r, l, -, +, ^);\\r\\nE_CAST(6, k, l, r, +, ^, -);\\r\\nE_CAST(7, k, r, l, ^, -, +);\\r\\nE_CAST(8, k, l, r, -, +, ^);\\r\\nE_CAST(9, k, r, l, +, ^, -);\\r\\nE_CAST(10, k, l, r, ^, -, +);\\r\\nE_CAST(11, k, r, l, -, +, ^);\\r\\nif (!key->short_key) {\\r\\nE_CAST(12, k, l, r, +, ^, -);\\r\\nE_CAST(13, k, r, l, ^, -, +);\\r\\nE_CAST(14, k, l, r, -, +, ^);\\r\\nE_CAST(15, k, r, l, +, ^, -);\\r\\n}\\r\\ndata[1] = l & 0xffffffffL;\\r\\ndata[0] = r & 0xffffffffL;\\r\\n}\\r\\nvoid CAST_decrypt(CAST_LONG *data, const CAST_KEY *key)\\r\\n{\\r\\nregister CAST_LONG l, r, t;\\r\\nconst register CAST_LONG *k;\\r\\nk = &(key->data[0]);\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nif (!key->short_key) {\\r\\nE_CAST(15, k, l, r, +, ^, -);\\r\\nE_CAST(14, k, r, l, -, +, ^);\\r\\nE_CAST(13, k, l, r, ^, -, +);\\r\\nE_CAST(12, k, r, l, +, ^, -);\\r\\n}\\r\\nE_CAST(11, k, l, r, -, +, ^);\\r\\nE_CAST(10, k, r, l, ^, -, +);\\r\\nE_CAST(9, k, l, r, +, ^, -);\\r\\nE_CAST(8, k, r, l, -, +, ^);\\r\\nE_CAST(7, k, l, r, ^, -, +);\\r\\nE_CAST(6, k, r, l, +, ^, -);\\r\\nE_CAST(5, k, l, r, -, +, ^);\\r\\nE_CAST(4, k, r, l, ^, -, +);\\r\\nE_CAST(3, k, l, r, +, ^, -);\\r\\nE_CAST(2, k, r, l, -, +, ^);\\r\\nE_CAST(1, k, l, r, ^, -, +);\\r\\nE_CAST(0, k, r, l, +, ^, -);\\r\\ndata[1] = l & 0xffffffffL;\\r\\ndata[0] = r & 0xffffffffL;\\r\\n}\\r\\nvoid CAST_cbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, const CAST_KEY *ks, unsigned char *iv,\\r\\nint enc)\\r\\n{\\r\\nregister CAST_LONG tin0, tin1;\\r\\nregister CAST_LONG tout0, tout1, xor0, xor1;\\r\\nregister long l = length;\\r\\nCAST_LONG tin[2];\\r\\nif (enc) {\\r\\nn2l(iv, tout0);\\r\\nn2l(iv, tout1);\\r\\niv -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nCAST_encrypt(tin, ks);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\n}\\r\\nif (l != -8) {\\r\\nn2ln(in, tin0, tin1, l + 8);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nCAST_encrypt(tin, ks);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\n}\\r\\nl2n(tout0, iv);\\r\\nl2n(tout1, iv);\\r\\n} else {\\r\\nn2l(iv, xor0);\\r\\nn2l(iv, xor1);\\r\\niv -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nCAST_decrypt(tin, ks);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nif (l != -8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nCAST_decrypt(tin, ks);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2nn(tout0, tout1, out, l + 8);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nl2n(xor0, iv);\\r\\nl2n(xor1, iv);\\r\\n}\\r\\ntin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;\\r\\ntin[0] = tin[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_names_c", "target": 0, "func": "int EVP_add_cipher(const EVP_CIPHER *c)\\r\\n{\\r\\nint r;\\r\\nif (c == NULL)\\r\\nreturn 0;\\r\\nOPENSSL_init();\\r\\nr = OBJ_NAME_add(OBJ_nid2sn(c->nid), OBJ_NAME_TYPE_CIPHER_METH,\\r\\n(const char *)c);\\r\\nif (r == 0)\\r\\nreturn (0);\\r\\ncheck_defer(c->nid);\\r\\nr = OBJ_NAME_add(OBJ_nid2ln(c->nid), OBJ_NAME_TYPE_CIPHER_METH,\\r\\n(const char *)c);\\r\\nreturn (r);\\r\\n}\\r\\nint EVP_add_digest(const EVP_MD *md)\\r\\n{\\r\\nint r;\\r\\nconst char *name;\\r\\nOPENSSL_init();\\r\\nname = OBJ_nid2sn(md->type);\\r\\nr = OBJ_NAME_add(name, OBJ_NAME_TYPE_MD_METH, (const char *)md);\\r\\nif (r == 0)\\r\\nreturn (0);\\r\\ncheck_defer(md->type);\\r\\nr = OBJ_NAME_add(OBJ_nid2ln(md->type), OBJ_NAME_TYPE_MD_METH,\\r\\n(const char *)md);\\r\\nif (r == 0)\\r\\nreturn (0);\\r\\nif (md->pkey_type && md->type != md->pkey_type) {\\r\\nr = OBJ_NAME_add(OBJ_nid2sn(md->pkey_type),\\r\\nOBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, name);\\r\\nif (r == 0)\\r\\nreturn (0);\\r\\ncheck_defer(md->pkey_type);\\r\\nr = OBJ_NAME_add(OBJ_nid2ln(md->pkey_type),\\r\\nOBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, name);\\r\\n}\\r\\nreturn (r);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_get_cipherbyname(const char *name)\\r\\n{\\r\\nconst EVP_CIPHER *cp;\\r\\ncp = (const EVP_CIPHER *)OBJ_NAME_get(name, OBJ_NAME_TYPE_CIPHER_METH);\\r\\nreturn (cp);\\r\\n}\\r\\nconst EVP_MD *EVP_get_digestbyname(const char *name)\\r\\n{\\r\\nconst EVP_MD *cp;\\r\\ncp = (const EVP_MD *)OBJ_NAME_get(name, OBJ_NAME_TYPE_MD_METH);\\r\\nreturn (cp);\\r\\n}\\r\\nvoid EVP_cleanup(void)\\r\\n{\\r\\nOBJ_NAME_cleanup(OBJ_NAME_TYPE_CIPHER_METH);\\r\\nOBJ_NAME_cleanup(OBJ_NAME_TYPE_MD_METH);\\r\\nOBJ_NAME_cleanup(-1);\\r\\nEVP_PBE_cleanup();\\r\\nif (obj_cleanup_defer == 2) {\\r\\nobj_cleanup_defer = 0;\\r\\nOBJ_cleanup();\\r\\n}\\r\\nOBJ_sigid_free();\\r\\n}\\r\\nstatic void do_all_cipher_fn(const OBJ_NAME *nm, void *arg)\\r\\n{\\r\\nstruct doall_cipher *dc = arg;\\r\\nif (nm->alias)\\r\\ndc->fn(NULL, nm->name, nm->data, dc->arg);\\r\\nelse\\r\\ndc->fn((const EVP_CIPHER *)nm->data, nm->name, NULL, dc->arg);\\r\\n}\\r\\nvoid EVP_CIPHER_do_all(void (*fn) (const EVP_CIPHER *ciph,\\r\\nconst char *from, const char *to, void *x),\\r\\nvoid *arg)\\r\\n{\\r\\nstruct doall_cipher dc;\\r\\ndc.fn = fn;\\r\\ndc.arg = arg;\\r\\nOBJ_NAME_do_all(OBJ_NAME_TYPE_CIPHER_METH, do_all_cipher_fn, &dc);\\r\\n}\\r\\nvoid EVP_CIPHER_do_all_sorted(void (*fn) (const EVP_CIPHER *ciph,\\r\\nconst char *from, const char *to,\\r\\nvoid *x), void *arg)\\r\\n{\\r\\nstruct doall_cipher dc;\\r\\ndc.fn = fn;\\r\\ndc.arg = arg;\\r\\nOBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_CIPHER_METH, do_all_cipher_fn, &dc);\\r\\n}\\r\\nstatic void do_all_md_fn(const OBJ_NAME *nm, void *arg)\\r\\n{\\r\\nstruct doall_md *dc = arg;\\r\\nif (nm->alias)\\r\\ndc->fn(NULL, nm->name, nm->data, dc->arg);\\r\\nelse\\r\\ndc->fn((const EVP_MD *)nm->data, nm->name, NULL, dc->arg);\\r\\n}\\r\\nvoid EVP_MD_do_all(void (*fn) (const EVP_MD *md,\\r\\nconst char *from, const char *to, void *x),\\r\\nvoid *arg)\\r\\n{\\r\\nstruct doall_md dc;\\r\\ndc.fn = fn;\\r\\ndc.arg = arg;\\r\\nOBJ_NAME_do_all(OBJ_NAME_TYPE_MD_METH, do_all_md_fn, &dc);\\r\\n}\\r\\nvoid EVP_MD_do_all_sorted(void (*fn) (const EVP_MD *md,\\r\\nconst char *from, const char *to,\\r\\nvoid *x), void *arg)\\r\\n{\\r\\nstruct doall_md dc;\\r\\ndc.fn = fn;\\r\\ndc.arg = arg;\\r\\nOBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_MD_METH, do_all_md_fn, &dc);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eck_prn_c", "target": 0, "func": "int ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nECerr(EC_F_ECPKPARAMETERS_PRINT_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = ECPKParameters_print(b, x, off);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint EC_KEY_print_fp(FILE *fp, const EC_KEY *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nECerr(EC_F_EC_KEY_PRINT_FP, ERR_R_BIO_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = EC_KEY_print(b, x, off);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint ECParameters_print_fp(FILE *fp, const EC_KEY *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nECerr(EC_F_ECPARAMETERS_PRINT_FP, ERR_R_BIO_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = ECParameters_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint EC_KEY_print(BIO *bp, const EC_KEY *x, int off)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret;\\r\\npk = EVP_PKEY_new();\\r\\nif (!pk || !EVP_PKEY_set1_EC_KEY(pk, (EC_KEY *)x))\\r\\nreturn 0;\\r\\nret = EVP_PKEY_print_private(bp, pk, off, NULL);\\r\\nEVP_PKEY_free(pk);\\r\\nreturn ret;\\r\\n}\\r\\nint ECParameters_print(BIO *bp, const EC_KEY *x)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret;\\r\\npk = EVP_PKEY_new();\\r\\nif (!pk || !EVP_PKEY_set1_EC_KEY(pk, (EC_KEY *)x))\\r\\nreturn 0;\\r\\nret = EVP_PKEY_print_params(bp, pk, 4, NULL);\\r\\nEVP_PKEY_free(pk);\\r\\nreturn ret;\\r\\n}\\r\\nint ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off)\\r\\n{\\r\\nunsigned char *buffer = NULL;\\r\\nsize_t buf_len = 0, i;\\r\\nint ret = 0, reason = ERR_R_BIO_LIB;\\r\\nBN_CTX *ctx = NULL;\\r\\nconst EC_POINT *point = NULL;\\r\\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *gen = NULL,\\r\\n*order = NULL, *cofactor = NULL;\\r\\nconst unsigned char *seed;\\r\\nsize_t seed_len = 0;\\r\\nstatic const char *gen_compressed = \"Generator (compressed):\";\\r\\nstatic const char *gen_uncompressed = \"Generator (uncompressed):\";\\r\\nstatic const char *gen_hybrid = \"Generator (hybrid):\";\\r\\nif (!x) {\\r\\nreason = ERR_R_PASSED_NULL_PARAMETER;\\r\\ngoto err;\\r\\n}\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL) {\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (EC_GROUP_get_asn1_flag(x)) {\\r\\nint nid;\\r\\nconst char *nname;\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nnid = EC_GROUP_get_curve_name(x);\\r\\nif (nid == 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"ASN1 OID: %s\", OBJ_nid2sn(nid)) <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\nnname = EC_curve_nid2nist(nid);\\r\\nif (nname) {\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"NIST CURVE: %s\\n\", nname) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nint is_char_two = 0;\\r\\npoint_conversion_form_t form;\\r\\nint tmp_nid = EC_METHOD_get_field_type(EC_GROUP_method_of(x));\\r\\nif (tmp_nid == NID_X9_62_characteristic_two_field)\\r\\nis_char_two = 1;\\r\\nif ((p = BN_new()) == NULL || (a = BN_new()) == NULL ||\\r\\n(b = BN_new()) == NULL || (order = BN_new()) == NULL ||\\r\\n(cofactor = BN_new()) == NULL) {\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_EC2M\\r\\nif (is_char_two) {\\r\\nif (!EC_GROUP_get_curve_GF2m(x, p, a, b, ctx)) {\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\n#endif\\r\\n{\\r\\nif (!EC_GROUP_get_curve_GFp(x, p, a, b, ctx)) {\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((point = EC_GROUP_get0_generator(x)) == NULL) {\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_get_order(x, order, NULL) ||\\r\\n!EC_GROUP_get_cofactor(x, cofactor, NULL)) {\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\nform = EC_GROUP_get_point_conversion_form(x);\\r\\nif ((gen = EC_POINT_point2bn(x, point, form, NULL, ctx)) == NULL) {\\r\\nreason = ERR_R_EC_LIB;\\r\\ngoto err;\\r\\n}\\r\\nbuf_len = (size_t)BN_num_bytes(p);\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(a)))\\r\\nbuf_len = i;\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(b)))\\r\\nbuf_len = i;\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(gen)))\\r\\nbuf_len = i;\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(order)))\\r\\nbuf_len = i;\\r\\nif (buf_len < (i = (size_t)BN_num_bytes(cofactor)))\\r\\nbuf_len = i;\\r\\nif ((seed = EC_GROUP_get0_seed(x)) != NULL)\\r\\nseed_len = EC_GROUP_get_seed_len(x);\\r\\nbuf_len += 10;\\r\\nif ((buffer = OPENSSL_malloc(buf_len)) == NULL) {\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"Field Type: %s\\n\", OBJ_nid2sn(tmp_nid))\\r\\n<= 0)\\r\\ngoto err;\\r\\nif (is_char_two) {\\r\\nint basis_type = EC_GROUP_get_basis_type(x);\\r\\nif (basis_type == 0)\\r\\ngoto err;\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"Basis Type: %s\\n\",\\r\\nOBJ_nid2sn(basis_type)) <= 0)\\r\\ngoto err;\\r\\nif ((p != NULL) && !ASN1_bn_print(bp, \"Polynomial:\", p, buffer,\\r\\noff))\\r\\ngoto err;\\r\\n} else {\\r\\nif ((p != NULL) && !ASN1_bn_print(bp, \"Prime:\", p, buffer, off))\\r\\ngoto err;\\r\\n}\\r\\nif ((a != NULL) && !ASN1_bn_print(bp, \"A: \", a, buffer, off))\\r\\ngoto err;\\r\\nif ((b != NULL) && !ASN1_bn_print(bp, \"B: \", b, buffer, off))\\r\\ngoto err;\\r\\nif (form == POINT_CONVERSION_COMPRESSED) {\\r\\nif ((gen != NULL) && !ASN1_bn_print(bp, gen_compressed, gen,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\n} else if (form == POINT_CONVERSION_UNCOMPRESSED) {\\r\\nif ((gen != NULL) && !ASN1_bn_print(bp, gen_uncompressed, gen,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\n} else {\\r\\nif ((gen != NULL) && !ASN1_bn_print(bp, gen_hybrid, gen,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\n}\\r\\nif ((order != NULL) && !ASN1_bn_print(bp, \"Order: \", order,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\nif ((cofactor != NULL) && !ASN1_bn_print(bp, \"Cofactor: \", cofactor,\\r\\nbuffer, off))\\r\\ngoto err;\\r\\nif (seed && !print_bin(bp, \"Seed:\", seed, seed_len, off))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (!ret)\\r\\nECerr(EC_F_ECPKPARAMETERS_PRINT, reason);\\r\\nif (p)\\r\\nBN_free(p);\\r\\nif (a)\\r\\nBN_free(a);\\r\\nif (b)\\r\\nBN_free(b);\\r\\nif (gen)\\r\\nBN_free(gen);\\r\\nif (order)\\r\\nBN_free(order);\\r\\nif (cofactor)\\r\\nBN_free(cofactor);\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nif (buffer != NULL)\\r\\nOPENSSL_free(buffer);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int print_bin(BIO *fp, const char *name, const unsigned char *buf,\\r\\nsize_t len, int off)\\r\\n{\\r\\nsize_t i;\\r\\nchar str[128];\\r\\nif (buf == NULL)\\r\\nreturn 1;\\r\\nif (off) {\\r\\nif (off > 128)\\r\\noff = 128;\\r\\nmemset(str, ' ', off);\\r\\nif (BIO_write(fp, str, off) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_printf(fp, \"%s\", name) <= 0)\\r\\nreturn 0;\\r\\nfor (i = 0; i < len; i++) {\\r\\nif ((i % 15) == 0) {\\r\\nstr[0] = '\\n';\\r\\nmemset(&(str[1]), ' ', off + 4);\\r\\nif (BIO_write(fp, str, off + 1 + 4) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_printf(fp, \"%02x%s\", buf[i], ((i + 1) == len) ? \"\" : \":\") <=\\r\\n0)\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_write(fp, \"\\n\", 1) <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_md4_dgst_c", "target": 0, "func": "void md4_block_data_order(MD4_CTX *c, const void *data_, size_t num)\\r\\n{\\r\\nconst unsigned char *data = data_;\\r\\nregister unsigned MD32_REG_T A, B, C, D, l;\\r\\n# ifndef MD32_XARRAY\\r\\nunsigned MD32_REG_T XX0, XX1, XX2, XX3, XX4, XX5, XX6, XX7,\\r\\nXX8, XX9, XX10, XX11, XX12, XX13, XX14, XX15;\\r\\n# define X(i) XX##i\\r\\n# else\\r\\nMD4_LONG XX[MD4_LBLOCK];\\r\\n# define X(i) XX[i]\\r\\n# endif\\r\\nA = c->A;\\r\\nB = c->B;\\r\\nC = c->C;\\r\\nD = c->D;\\r\\nfor (; num--;) {\\r\\n(void)HOST_c2l(data, l);\\r\\nX(0) = l;\\r\\n(void)HOST_c2l(data, l);\\r\\nX(1) = l;\\r\\nR0(A, B, C, D, X(0), 3, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(2) = l;\\r\\nR0(D, A, B, C, X(1), 7, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(3) = l;\\r\\nR0(C, D, A, B, X(2), 11, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(4) = l;\\r\\nR0(B, C, D, A, X(3), 19, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(5) = l;\\r\\nR0(A, B, C, D, X(4), 3, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(6) = l;\\r\\nR0(D, A, B, C, X(5), 7, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(7) = l;\\r\\nR0(C, D, A, B, X(6), 11, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(8) = l;\\r\\nR0(B, C, D, A, X(7), 19, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(9) = l;\\r\\nR0(A, B, C, D, X(8), 3, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(10) = l;\\r\\nR0(D, A, B, C, X(9), 7, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(11) = l;\\r\\nR0(C, D, A, B, X(10), 11, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(12) = l;\\r\\nR0(B, C, D, A, X(11), 19, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(13) = l;\\r\\nR0(A, B, C, D, X(12), 3, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(14) = l;\\r\\nR0(D, A, B, C, X(13), 7, 0);\\r\\n(void)HOST_c2l(data, l);\\r\\nX(15) = l;\\r\\nR0(C, D, A, B, X(14), 11, 0);\\r\\nR0(B, C, D, A, X(15), 19, 0);\\r\\nR1(A, B, C, D, X(0), 3, 0x5A827999L);\\r\\nR1(D, A, B, C, X(4), 5, 0x5A827999L);\\r\\nR1(C, D, A, B, X(8), 9, 0x5A827999L);\\r\\nR1(B, C, D, A, X(12), 13, 0x5A827999L);\\r\\nR1(A, B, C, D, X(1), 3, 0x5A827999L);\\r\\nR1(D, A, B, C, X(5), 5, 0x5A827999L);\\r\\nR1(C, D, A, B, X(9), 9, 0x5A827999L);\\r\\nR1(B, C, D, A, X(13), 13, 0x5A827999L);\\r\\nR1(A, B, C, D, X(2), 3, 0x5A827999L);\\r\\nR1(D, A, B, C, X(6), 5, 0x5A827999L);\\r\\nR1(C, D, A, B, X(10), 9, 0x5A827999L);\\r\\nR1(B, C, D, A, X(14), 13, 0x5A827999L);\\r\\nR1(A, B, C, D, X(3), 3, 0x5A827999L);\\r\\nR1(D, A, B, C, X(7), 5, 0x5A827999L);\\r\\nR1(C, D, A, B, X(11), 9, 0x5A827999L);\\r\\nR1(B, C, D, A, X(15), 13, 0x5A827999L);\\r\\nR2(A, B, C, D, X(0), 3, 0x6ED9EBA1L);\\r\\nR2(D, A, B, C, X(8), 9, 0x6ED9EBA1L);\\r\\nR2(C, D, A, B, X(4), 11, 0x6ED9EBA1L);\\r\\nR2(B, C, D, A, X(12), 15, 0x6ED9EBA1L);\\r\\nR2(A, B, C, D, X(2), 3, 0x6ED9EBA1L);\\r\\nR2(D, A, B, C, X(10), 9, 0x6ED9EBA1L);\\r\\nR2(C, D, A, B, X(6), 11, 0x6ED9EBA1L);\\r\\nR2(B, C, D, A, X(14), 15, 0x6ED9EBA1L);\\r\\nR2(A, B, C, D, X(1), 3, 0x6ED9EBA1L);\\r\\nR2(D, A, B, C, X(9), 9, 0x6ED9EBA1L);\\r\\nR2(C, D, A, B, X(5), 11, 0x6ED9EBA1L);\\r\\nR2(B, C, D, A, X(13), 15, 0x6ED9EBA1L);\\r\\nR2(A, B, C, D, X(3), 3, 0x6ED9EBA1L);\\r\\nR2(D, A, B, C, X(11), 9, 0x6ED9EBA1L);\\r\\nR2(C, D, A, B, X(7), 11, 0x6ED9EBA1L);\\r\\nR2(B, C, D, A, X(15), 15, 0x6ED9EBA1L);\\r\\nA = c->A += A;\\r\\nB = c->B += B;\\r\\nC = c->C += C;\\r\\nD = c->D += D;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dso_dl_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_dl(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nDSO_METHOD *DSO_METHOD_dl(void)\\r\\n{\\r\\nreturn (&dso_meth_dl);\\r\\n}\\r\\nstatic int dl_load(DSO *dso)\\r\\n{\\r\\nshl_t ptr = NULL;\\r\\nchar *filename = DSO_convert_filename(dso, NULL);\\r\\nif (filename == NULL) {\\r\\nDSOerr(DSO_F_DL_LOAD, DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\nptr = shl_load(filename, BIND_IMMEDIATE |\\r\\n(dso->flags & DSO_FLAG_NO_NAME_TRANSLATION ? 0 :\\r\\nDYNAMIC_PATH), 0L);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_DL_LOAD, DSO_R_LOAD_FAILED);\\r\\nERR_add_error_data(4, \"filename(\", filename, \"): \", strerror(errno));\\r\\ngoto err;\\r\\n}\\r\\nif (!sk_push(dso->meth_data, (char *)ptr)) {\\r\\nDSOerr(DSO_F_DL_LOAD, DSO_R_STACK_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndso->loaded_filename = filename;\\r\\nreturn (1);\\r\\nerr:\\r\\nif (filename != NULL)\\r\\nOPENSSL_free(filename);\\r\\nif (ptr != NULL)\\r\\nshl_unload(ptr);\\r\\nreturn (0);\\r\\n}\\r\\nstatic int dl_unload(DSO *dso)\\r\\n{\\r\\nshl_t ptr;\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_DL_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (sk_num(dso->meth_data) < 1)\\r\\nreturn (1);\\r\\nptr = (shl_t) sk_pop(dso->meth_data);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_DL_UNLOAD, DSO_R_NULL_HANDLE);\\r\\nsk_push(dso->meth_data, (char *)ptr);\\r\\nreturn (0);\\r\\n}\\r\\nshl_unload(ptr);\\r\\nreturn (1);\\r\\n}\\r\\nstatic void *dl_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nshl_t ptr;\\r\\nvoid *sym;\\r\\nif ((dso == NULL) || (symname == NULL)) {\\r\\nDSOerr(DSO_F_DL_BIND_VAR, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (sk_num(dso->meth_data) < 1) {\\r\\nDSOerr(DSO_F_DL_BIND_VAR, DSO_R_STACK_ERROR);\\r\\nreturn (NULL);\\r\\n}\\r\\nptr = (shl_t) sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_DL_BIND_VAR, DSO_R_NULL_HANDLE);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (shl_findsym(&ptr, symname, TYPE_UNDEFINED, &sym) < 0) {\\r\\nDSOerr(DSO_F_DL_BIND_VAR, DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(4, \"symname(\", symname, \"): \", strerror(errno));\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (sym);\\r\\n}\\r\\nstatic DSO_FUNC_TYPE dl_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nshl_t ptr;\\r\\nvoid *sym;\\r\\nif ((dso == NULL) || (symname == NULL)) {\\r\\nDSOerr(DSO_F_DL_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (sk_num(dso->meth_data) < 1) {\\r\\nDSOerr(DSO_F_DL_BIND_FUNC, DSO_R_STACK_ERROR);\\r\\nreturn (NULL);\\r\\n}\\r\\nptr = (shl_t) sk_value(dso->meth_data, sk_num(dso->meth_data) - 1);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_DL_BIND_FUNC, DSO_R_NULL_HANDLE);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (shl_findsym(&ptr, symname, TYPE_UNDEFINED, &sym) < 0) {\\r\\nDSOerr(DSO_F_DL_BIND_FUNC, DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(4, \"symname(\", symname, \"): \", strerror(errno));\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn ((DSO_FUNC_TYPE)sym);\\r\\n}\\r\\nstatic char *dl_merger(DSO *dso, const char *filespec1, const char *filespec2)\\r\\n{\\r\\nchar *merged;\\r\\nif (!filespec1 && !filespec2) {\\r\\nDSOerr(DSO_F_DL_MERGER, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (!filespec2 || filespec1[0] == '/') {\\r\\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\\r\\nif (!merged) {\\r\\nDSOerr(DSO_F_DL_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nstrcpy(merged, filespec1);\\r\\n}\\r\\nelse if (!filespec1) {\\r\\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\\r\\nif (!merged) {\\r\\nDSOerr(DSO_F_DL_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\n} else\\r\\n{\\r\\nint spec2len, len;\\r\\nspec2len = (filespec2 ? strlen(filespec2) : 0);\\r\\nlen = spec2len + (filespec1 ? strlen(filespec1) : 0);\\r\\nif (filespec2 && filespec2[spec2len - 1] == '/') {\\r\\nspec2len--;\\r\\nlen--;\\r\\n}\\r\\nmerged = OPENSSL_malloc(len + 2);\\r\\nif (!merged) {\\r\\nDSOerr(DSO_F_DL_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\nmerged[spec2len] = '/';\\r\\nstrcpy(&merged[spec2len + 1], filespec1);\\r\\n}\\r\\nreturn (merged);\\r\\n}\\r\\nstatic char *dl_name_converter(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *translated;\\r\\nint len, rsize, transform;\\r\\nlen = strlen(filename);\\r\\nrsize = len + 1;\\r\\ntransform = (strstr(filename, \"/\") == NULL);\\r\\n{\\r\\nrsize += strlen(extension);\\r\\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\\r\\nrsize += 3;\\r\\n}\\r\\ntranslated = OPENSSL_malloc(rsize);\\r\\nif (translated == NULL) {\\r\\nDSOerr(DSO_F_DL_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (transform) {\\r\\nif ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)\\r\\nsprintf(translated, \"lib%s%s\", filename, extension);\\r\\nelse\\r\\nsprintf(translated, \"%s%s\", filename, extension);\\r\\n} else\\r\\nsprintf(translated, \"%s\", filename);\\r\\nreturn (translated);\\r\\n}\\r\\nstatic int dl_pathbyaddr(void *addr, char *path, int sz)\\r\\n{\\r\\nstruct shl_descriptor inf;\\r\\nint i, len;\\r\\nif (addr == NULL) {\\r\\nunion {\\r\\nint (*f) (void *, char *, int);\\r\\nvoid *p;\\r\\n} t = {\\r\\ndl_pathbyaddr\\r\\n};\\r\\naddr = t.p;\\r\\n}\\r\\nfor (i = -1; shl_get_r(i, &inf) == 0; i++) {\\r\\nif (((size_t)addr >= inf.tstart && (size_t)addr < inf.tend) ||\\r\\n((size_t)addr >= inf.dstart && (size_t)addr < inf.dend)) {\\r\\nlen = (int)strlen(inf.filename);\\r\\nif (sz <= 0)\\r\\nreturn len + 1;\\r\\nif (len >= sz)\\r\\nlen = sz - 1;\\r\\nmemcpy(path, inf.filename, len);\\r\\npath[len++] = 0;\\r\\nreturn len;\\r\\n}\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nstatic void *dl_globallookup(const char *name)\\r\\n{\\r\\nvoid *ret;\\r\\nshl_t h = NULL;\\r\\nreturn shl_findsym(&h, name, TYPE_UNDEFINED, &ret) ? NULL : ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_c_cfb64_c", "target": 0, "func": "void CAST_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, const CAST_KEY *schedule,\\r\\nunsigned char *ivec, int *num, int enc)\\r\\n{\\r\\nregister CAST_LONG v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nCAST_LONG ti[2];\\r\\nunsigned char *iv, c, cc;\\r\\niv = ivec;\\r\\nif (enc) {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nn2l(iv, v0);\\r\\nti[0] = v0;\\r\\nn2l(iv, v1);\\r\\nti[1] = v1;\\r\\nCAST_encrypt((CAST_LONG *)ti, schedule);\\r\\niv = ivec;\\r\\nt = ti[0];\\r\\nl2n(t, iv);\\r\\nt = ti[1];\\r\\nl2n(t, iv);\\r\\niv = ivec;\\r\\n}\\r\\nc = *(in++) ^ iv[n];\\r\\n*(out++) = c;\\r\\niv[n] = c;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n} else {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nn2l(iv, v0);\\r\\nti[0] = v0;\\r\\nn2l(iv, v1);\\r\\nti[1] = v1;\\r\\nCAST_encrypt((CAST_LONG *)ti, schedule);\\r\\niv = ivec;\\r\\nt = ti[0];\\r\\nl2n(t, iv);\\r\\nt = ti[1];\\r\\nl2n(t, iv);\\r\\niv = ivec;\\r\\n}\\r\\ncc = *(in++);\\r\\nc = iv[n];\\r\\niv[n] = cc;\\r\\n*(out++) = c ^ cc;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n}\\r\\nv0 = v1 = ti[0] = ti[1] = t = c = cc = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_o_init_c", "target": 0, "func": "void OPENSSL_init(void)\\r\\n{\\r\\nstatic int done = 0;\\r\\nif (done)\\r\\nreturn;\\r\\ndone = 1;\\r\\n#ifdef OPENSSL_FIPS\\r\\nFIPS_set_locking_callbacks(CRYPTO_lock, CRYPTO_add_lock);\\r\\nFIPS_set_error_callbacks(ERR_put_error, ERR_add_error_vdata);\\r\\nFIPS_set_malloc_callbacks(CRYPTO_malloc, CRYPTO_free);\\r\\nRAND_init_fips();\\r\\n#endif\\r\\n#if 0\\r\\nfprintf(stderr, \"Called OPENSSL_init\\n\");\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_sock_c", "target": 0, "func": "BIO_METHOD *BIO_s_socket(void)\\r\\n{\\r\\nreturn (&methods_sockp);\\r\\n}\\r\\nBIO *BIO_new_socket(int fd, int close_flag)\\r\\n{\\r\\nBIO *ret;\\r\\nret = BIO_new(BIO_s_socket());\\r\\nif (ret == NULL)\\r\\nreturn (NULL);\\r\\nBIO_set_fd(ret, fd, close_flag);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int sock_new(BIO *bi)\\r\\n{\\r\\nbi->init = 0;\\r\\nbi->num = 0;\\r\\nbi->ptr = NULL;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int sock_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (a->shutdown) {\\r\\nif (a->init) {\\r\\nSHUTDOWN2(a->num);\\r\\n}\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int sock_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nif (out != NULL) {\\r\\nclear_socket_error();\\r\\nret = readsocket(b->num, out, outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0) {\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int sock_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nclear_socket_error();\\r\\nret = writesocket(b->num, in, inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0) {\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_write(b);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long sock_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret = 1;\\r\\nint *ip;\\r\\nswitch (cmd) {\\r\\ncase BIO_C_SET_FD:\\r\\nsock_free(b);\\r\\nb->num = *((int *)ptr);\\r\\nb->shutdown = (int)num;\\r\\nb->init = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init) {\\r\\nip = (int *)ptr;\\r\\nif (ip != NULL)\\r\\n*ip = b->num;\\r\\nret = b->num;\\r\\n} else\\r\\nret = -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown = (int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret = 1;\\r\\nbreak;\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int sock_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = sock_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}\\r\\nint BIO_sock_should_retry(int i)\\r\\n{\\r\\nint err;\\r\\nif ((i == 0) || (i == -1)) {\\r\\nerr = get_last_socket_error();\\r\\n# if defined(OPENSSL_SYS_WINDOWS) && 0\\r\\nif ((i == -1) && (err == 0))\\r\\nreturn (1);\\r\\n# endif\\r\\nreturn (BIO_sock_non_fatal_error(err));\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nint BIO_sock_non_fatal_error(int err)\\r\\n{\\r\\nswitch (err) {\\r\\n# if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_NETWARE)\\r\\n# if defined(WSAEWOULDBLOCK)\\r\\ncase WSAEWOULDBLOCK:\\r\\n# endif\\r\\n# if 0\\r\\n# if defined(WSAENOTCONN)\\r\\ncase WSAENOTCONN:\\r\\n# endif\\r\\n# endif\\r\\n# endif\\r\\n# ifdef EWOULDBLOCK\\r\\n# ifdef WSAEWOULDBLOCK\\r\\n# if WSAEWOULDBLOCK != EWOULDBLOCK\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n# else\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n# endif\\r\\n# if defined(ENOTCONN)\\r\\ncase ENOTCONN:\\r\\n# endif\\r\\n# ifdef EINTR\\r\\ncase EINTR:\\r\\n# endif\\r\\n# ifdef EAGAIN\\r\\n# if EWOULDBLOCK != EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\n# endif\\r\\n# ifdef EPROTO\\r\\ncase EPROTO:\\r\\n# endif\\r\\n# ifdef EINPROGRESS\\r\\ncase EINPROGRESS:\\r\\n# endif\\r\\n# ifdef EALREADY\\r\\ncase EALREADY:\\r\\n# endif\\r\\nreturn (1);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn (0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p8_pkey_c", "target": 0, "func": "static int pkey_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nif (operation == ASN1_OP_FREE_PRE) {\\r\\nPKCS8_PRIV_KEY_INFO *key = (PKCS8_PRIV_KEY_INFO *)*pval;\\r\\nif (key->pkey->value.octet_string)\\r\\nOPENSSL_cleanse(key->pkey->value.octet_string->data,\\r\\nkey->pkey->value.octet_string->length);\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_openssl_c", "target": 0, "func": "static void lock_dbg_cb(int mode, int type, const char *file, int line)\\r\\n{\\r\\nstatic int modes[CRYPTO_NUM_LOCKS];\\r\\nconst char *errstr = NULL;\\r\\nint rw;\\r\\nrw = mode & (CRYPTO_READ | CRYPTO_WRITE);\\r\\nif (!((rw == CRYPTO_READ) || (rw == CRYPTO_WRITE))) {\\r\\nerrstr = \"invalid mode\";\\r\\ngoto err;\\r\\n}\\r\\nif (type < 0 || type >= CRYPTO_NUM_LOCKS) {\\r\\nerrstr = \"type out of bounds\";\\r\\ngoto err;\\r\\n}\\r\\nif (mode & CRYPTO_LOCK) {\\r\\nif (modes[type]) {\\r\\nerrstr = \"already locked\";\\r\\ngoto err;\\r\\n}\\r\\nmodes[type] = rw;\\r\\n} else if (mode & CRYPTO_UNLOCK) {\\r\\nif (!modes[type]) {\\r\\nerrstr = \"not locked\";\\r\\ngoto err;\\r\\n}\\r\\nif (modes[type] != rw) {\\r\\nerrstr = (rw == CRYPTO_READ) ?\\r\\n\"CRYPTO_r_unlock on write lock\" :\\r\\n\"CRYPTO_w_unlock on read lock\";\\r\\n}\\r\\nmodes[type] = 0;\\r\\n} else {\\r\\nerrstr = \"invalid mode\";\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (errstr) {\\r\\nfprintf(stderr,\\r\\n\"openssl (lock_dbg_cb): %s (mode=%d, type=%d) at %s:%d\\n\",\\r\\nerrstr, mode, type, file, line);\\r\\n}\\r\\n}\\r\\nint main(int Argc, char *ARGV[])\\r\\n{\\r\\nARGS arg;\\r\\n#define PROG_NAME_SIZE 39\\r\\nchar pname[PROG_NAME_SIZE + 1];\\r\\nFUNCTION f, *fp;\\r\\nMS_STATIC const char *prompt;\\r\\nMS_STATIC char buf[1024];\\r\\nchar *to_free = NULL;\\r\\nint n, i, ret = 0;\\r\\nint argc;\\r\\nchar **argv, *p;\\r\\nLHASH_OF(FUNCTION) *prog = NULL;\\r\\nlong errline;\\r\\n#if defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64)\\r\\nchar **Argv = NULL;\\r\\nint free_Argv = 0;\\r\\nif ((sizeof(_Argv) < 8)\\r\\n# if !defined( VMS_TRUST_ARGV)\\r\\n|| (_Argv[Argc] != NULL)\\r\\n# endif\\r\\n) {\\r\\nint i;\\r\\nArgv = OPENSSL_malloc((Argc + 1) * sizeof(char *));\\r\\nif (Argv == NULL) {\\r\\nret = -1;\\r\\ngoto end;\\r\\n}\\r\\nfor (i = 0; i < Argc; i++)\\r\\nArgv[i] = _Argv[i];\\r\\nArgv[Argc] = NULL;\\r\\nfree_Argv = 1;\\r\\n} else {\\r\\nArgv = (char **)_Argv;\\r\\n}\\r\\n#endif\\r\\narg.data = NULL;\\r\\narg.count = 0;\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) {\\r\\nif (!(0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\"))) {\\r\\nCRYPTO_malloc_debug_init();\\r\\nCRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);\\r\\n} else {\\r\\nCRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0);\\r\\n}\\r\\n}\\r\\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\\r\\n#if 0\\r\\nif (getenv(\"OPENSSL_DEBUG_LOCKING\") != NULL)\\r\\n#endif\\r\\n{\\r\\nCRYPTO_set_locking_callback(lock_dbg_cb);\\r\\n}\\r\\nif (getenv(\"OPENSSL_FIPS\")) {\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (!FIPS_mode_set(1)) {\\r\\nERR_load_crypto_strings();\\r\\nERR_print_errors(BIO_new_fp(stderr, BIO_NOCLOSE));\\r\\nEXIT(1);\\r\\n}\\r\\n#else\\r\\nfprintf(stderr, \"FIPS mode not supported.\\n\");\\r\\nEXIT(1);\\r\\n#endif\\r\\n}\\r\\napps_startup();\\r\\np = getenv(\"OPENSSL_CONF\");\\r\\nif (p == NULL)\\r\\np = getenv(\"SSLEAY_CONF\");\\r\\nif (p == NULL)\\r\\np = to_free = make_config_name();\\r\\ndefault_config_file = p;\\r\\nconfig = NCONF_new(NULL);\\r\\ni = NCONF_load(config, p, &errline);\\r\\nif (i == 0) {\\r\\nif (ERR_GET_REASON(ERR_peek_last_error())\\r\\n== CONF_R_NO_SUCH_FILE) {\\r\\nBIO_printf(bio_err, \"WARNING: can't open config file: %s\\n\", p);\\r\\nERR_clear_error();\\r\\nNCONF_free(config);\\r\\nconfig = NULL;\\r\\n} else {\\r\\nERR_print_errors(bio_err);\\r\\nNCONF_free(config);\\r\\nexit(1);\\r\\n}\\r\\n}\\r\\nprog = prog_init();\\r\\nprogram_name(Argv[0], pname, sizeof pname);\\r\\nf.name = pname;\\r\\nfp = lh_FUNCTION_retrieve(prog, &f);\\r\\nif (fp != NULL) {\\r\\nArgv[0] = pname;\\r\\nret = fp->func(Argc, Argv);\\r\\ngoto end;\\r\\n}\\r\\nif (Argc != 1) {\\r\\nArgc--;\\r\\nArgv++;\\r\\nret = do_cmd(prog, Argc, Argv);\\r\\nif (ret < 0)\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nfor (;;) {\\r\\nret = 0;\\r\\np = buf;\\r\\nn = sizeof buf;\\r\\ni = 0;\\r\\nfor (;;) {\\r\\np[0] = '\\0';\\r\\nif (i++)\\r\\nprompt = \">\";\\r\\nelse\\r\\nprompt = \"OpenSSL> \";\\r\\nfputs(prompt, stdout);\\r\\nfflush(stdout);\\r\\nif (!fgets(p, n, stdin))\\r\\ngoto end;\\r\\nif (p[0] == '\\0')\\r\\ngoto end;\\r\\ni = strlen(p);\\r\\nif (i <= 1)\\r\\nbreak;\\r\\nif (p[i - 2] != '\\\\')\\r\\nbreak;\\r\\ni -= 2;\\r\\np += i;\\r\\nn -= i;\\r\\n}\\r\\nif (!chopup_args(&arg, buf, &argc, &argv))\\r\\nbreak;\\r\\nret = do_cmd(prog, argc, argv);\\r\\nif (ret < 0) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (ret != 0)\\r\\nBIO_printf(bio_err, \"error in %s\\n\", argv[0]);\\r\\n(void)BIO_flush(bio_err);\\r\\n}\\r\\nBIO_printf(bio_err, \"bad exit\\n\");\\r\\nret = 1;\\r\\nend:\\r\\nif (to_free)\\r\\nOPENSSL_free(to_free);\\r\\nif (config != NULL) {\\r\\nNCONF_free(config);\\r\\nconfig = NULL;\\r\\n}\\r\\nif (prog != NULL)\\r\\nlh_FUNCTION_free(prog);\\r\\nif (arg.data != NULL)\\r\\nOPENSSL_free(arg.data);\\r\\nif (bio_err != NULL) {\\r\\nBIO_free(bio_err);\\r\\nbio_err = NULL;\\r\\n}\\r\\n#if defined( OPENSSL_SYS_VMS) && (__INITIAL_POINTER_SIZE == 64)\\r\\nif (free_Argv) {\\r\\nOPENSSL_free(Argv);\\r\\n}\\r\\n#endif\\r\\napps_shutdown();\\r\\nCRYPTO_mem_leaks(bio_err);\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int SortFnByName(const void *_f1, const void *_f2)\\r\\n{\\r\\nconst FUNCTION *f1 = _f1;\\r\\nconst FUNCTION *f2 = _f2;\\r\\nif (f1->type != f2->type)\\r\\nreturn f1->type - f2->type;\\r\\nreturn strcmp(f1->name, f2->name);\\r\\n}\\r\\nstatic void list_pkey(BIO *out)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < EVP_PKEY_asn1_get_count(); i++) {\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nint pkey_id, pkey_base_id, pkey_flags;\\r\\nconst char *pinfo, *pem_str;\\r\\nameth = EVP_PKEY_asn1_get0(i);\\r\\nEVP_PKEY_asn1_get0_info(&pkey_id, &pkey_base_id, &pkey_flags,\\r\\n&pinfo, &pem_str, ameth);\\r\\nif (pkey_flags & ASN1_PKEY_ALIAS) {\\r\\nBIO_printf(out, \"Name: %s\\n\", OBJ_nid2ln(pkey_id));\\r\\nBIO_printf(out, \"\\tType: Alias to %s\\n\",\\r\\nOBJ_nid2ln(pkey_base_id));\\r\\n} else {\\r\\nBIO_printf(out, \"Name: %s\\n\", pinfo);\\r\\nBIO_printf(out, \"\\tType: %s Algorithm\\n\",\\r\\npkey_flags & ASN1_PKEY_DYNAMIC ?\\r\\n\"External\" : \"Builtin\");\\r\\nBIO_printf(out, \"\\tOID: %s\\n\", OBJ_nid2ln(pkey_id));\\r\\nif (pem_str == NULL)\\r\\npem_str = \"(none)\";\\r\\nBIO_printf(out, \"\\tPEM string: %s\\n\", pem_str);\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic void list_cipher_fn(const EVP_CIPHER *c,\\r\\nconst char *from, const char *to, void *arg)\\r\\n{\\r\\nif (c)\\r\\nBIO_printf(arg, \"%s\\n\", EVP_CIPHER_name(c));\\r\\nelse {\\r\\nif (!from)\\r\\nfrom = \"<undefined>\";\\r\\nif (!to)\\r\\nto = \"<undefined>\";\\r\\nBIO_printf(arg, \"%s => %s\\n\", from, to);\\r\\n}\\r\\n}\\r\\nstatic void list_cipher(BIO *out)\\r\\n{\\r\\nEVP_CIPHER_do_all_sorted(list_cipher_fn, out);\\r\\n}\\r\\nstatic void list_md_fn(const EVP_MD *m,\\r\\nconst char *from, const char *to, void *arg)\\r\\n{\\r\\nif (m)\\r\\nBIO_printf(arg, \"%s\\n\", EVP_MD_name(m));\\r\\nelse {\\r\\nif (!from)\\r\\nfrom = \"<undefined>\";\\r\\nif (!to)\\r\\nto = \"<undefined>\";\\r\\nBIO_printf(arg, \"%s => %s\\n\", from, to);\\r\\n}\\r\\n}\\r\\nstatic void list_md(BIO *out)\\r\\n{\\r\\nEVP_MD_do_all_sorted(list_md_fn, out);\\r\\n}\\r\\nstatic int MS_CALLBACK function_cmp(const FUNCTION * a, const FUNCTION * b)\\r\\n{\\r\\nreturn strncmp(a->name, b->name, 8);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_dyn_c", "target": 0, "func": "static void int_free_str(char *s)\\r\\n{\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nstatic void dynamic_data_ctx_free_func(void *parent, void *ptr,\\r\\nCRYPTO_EX_DATA *ad, int idx, long argl,\\r\\nvoid *argp)\\r\\n{\\r\\nif (ptr) {\\r\\ndynamic_data_ctx *ctx = (dynamic_data_ctx *)ptr;\\r\\nif (ctx->dynamic_dso)\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nif (ctx->DYNAMIC_LIBNAME)\\r\\nOPENSSL_free((void *)ctx->DYNAMIC_LIBNAME);\\r\\nif (ctx->engine_id)\\r\\nOPENSSL_free((void *)ctx->engine_id);\\r\\nif (ctx->dirs)\\r\\nsk_OPENSSL_STRING_pop_free(ctx->dirs, int_free_str);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\n}\\r\\nstatic int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx)\\r\\n{\\r\\ndynamic_data_ctx *c;\\r\\nc = OPENSSL_malloc(sizeof(dynamic_data_ctx));\\r\\nif (!c) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nmemset(c, 0, sizeof(dynamic_data_ctx));\\r\\nc->dynamic_dso = NULL;\\r\\nc->v_check = NULL;\\r\\nc->bind_engine = NULL;\\r\\nc->DYNAMIC_LIBNAME = NULL;\\r\\nc->no_vcheck = 0;\\r\\nc->engine_id = NULL;\\r\\nc->list_add_value = 0;\\r\\nc->DYNAMIC_F1 = \"v_check\";\\r\\nc->DYNAMIC_F2 = \"bind_engine\";\\r\\nc->dir_load = 1;\\r\\nc->dirs = sk_OPENSSL_STRING_new_null();\\r\\nif (!c->dirs) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(c);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif ((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e,\\r\\ndynamic_ex_data_idx))\\r\\n== NULL) {\\r\\nENGINE_set_ex_data(e, dynamic_ex_data_idx, c);\\r\\n*ctx = c;\\r\\nc = NULL;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nif (c)\\r\\nOPENSSL_free(c);\\r\\nreturn 1;\\r\\n}\\r\\nstatic dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e)\\r\\n{\\r\\ndynamic_data_ctx *ctx;\\r\\nif (dynamic_ex_data_idx < 0) {\\r\\nint new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL,\\r\\ndynamic_data_ctx_free_func);\\r\\nif (new_idx == -1) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX, ENGINE_R_NO_INDEX);\\r\\nreturn NULL;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nif (dynamic_ex_data_idx < 0) {\\r\\ndynamic_ex_data_idx = new_idx;\\r\\nnew_idx = -1;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\n}\\r\\nctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx);\\r\\nif ((ctx == NULL) && !dynamic_set_data_ctx(e, &ctx))\\r\\nreturn NULL;\\r\\nreturn ctx;\\r\\n}\\r\\nstatic ENGINE *engine_dynamic(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!ENGINE_set_id(ret, engine_dynamic_id) ||\\r\\n!ENGINE_set_name(ret, engine_dynamic_name) ||\\r\\n!ENGINE_set_init_function(ret, dynamic_init) ||\\r\\n!ENGINE_set_finish_function(ret, dynamic_finish) ||\\r\\n!ENGINE_set_ctrl_function(ret, dynamic_ctrl) ||\\r\\n!ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) ||\\r\\n!ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) {\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_dynamic(void)\\r\\n{\\r\\nENGINE *toadd = engine_dynamic();\\r\\nif (!toadd)\\r\\nreturn;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int dynamic_init(ENGINE *e)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dynamic_finish(ENGINE *e)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))\\r\\n{\\r\\ndynamic_data_ctx *ctx = dynamic_get_data_ctx(e);\\r\\nint initialised;\\r\\nif (!ctx) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_NOT_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\ninitialised = ((ctx->dynamic_dso == NULL) ? 0 : 1);\\r\\nif (initialised) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_ALREADY_LOADED);\\r\\nreturn 0;\\r\\n}\\r\\nswitch (cmd) {\\r\\ncase DYNAMIC_CMD_SO_PATH:\\r\\nif (p && (strlen((const char *)p) < 1))\\r\\np = NULL;\\r\\nif (ctx->DYNAMIC_LIBNAME)\\r\\nOPENSSL_free((void *)ctx->DYNAMIC_LIBNAME);\\r\\nif (p)\\r\\nctx->DYNAMIC_LIBNAME = BUF_strdup(p);\\r\\nelse\\r\\nctx->DYNAMIC_LIBNAME = NULL;\\r\\nreturn (ctx->DYNAMIC_LIBNAME ? 1 : 0);\\r\\ncase DYNAMIC_CMD_NO_VCHECK:\\r\\nctx->no_vcheck = ((i == 0) ? 0 : 1);\\r\\nreturn 1;\\r\\ncase DYNAMIC_CMD_ID:\\r\\nif (p && (strlen((const char *)p) < 1))\\r\\np = NULL;\\r\\nif (ctx->engine_id)\\r\\nOPENSSL_free((void *)ctx->engine_id);\\r\\nif (p)\\r\\nctx->engine_id = BUF_strdup(p);\\r\\nelse\\r\\nctx->engine_id = NULL;\\r\\nreturn (ctx->engine_id ? 1 : 0);\\r\\ncase DYNAMIC_CMD_LIST_ADD:\\r\\nif ((i < 0) || (i > 2)) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\nctx->list_add_value = (int)i;\\r\\nreturn 1;\\r\\ncase DYNAMIC_CMD_LOAD:\\r\\nreturn dynamic_load(e, ctx);\\r\\ncase DYNAMIC_CMD_DIR_LOAD:\\r\\nif ((i < 0) || (i > 2)) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\nctx->dir_load = (int)i;\\r\\nreturn 1;\\r\\ncase DYNAMIC_CMD_DIR_ADD:\\r\\nif (!p || (strlen((const char *)p) < 1)) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\n{\\r\\nchar *tmp_str = BUF_strdup(p);\\r\\nif (!tmp_str) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nsk_OPENSSL_STRING_insert(ctx->dirs, tmp_str, -1);\\r\\n}\\r\\nreturn 1;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int int_load(dynamic_data_ctx *ctx)\\r\\n{\\r\\nint num, loop;\\r\\nif ((ctx->dir_load != 2) && (DSO_load(ctx->dynamic_dso,\\r\\nctx->DYNAMIC_LIBNAME, NULL,\\r\\n0)) != NULL)\\r\\nreturn 1;\\r\\nif (!ctx->dir_load || (num = sk_OPENSSL_STRING_num(ctx->dirs)) < 1)\\r\\nreturn 0;\\r\\nfor (loop = 0; loop < num; loop++) {\\r\\nconst char *s = sk_OPENSSL_STRING_value(ctx->dirs, loop);\\r\\nchar *merge = DSO_merge(ctx->dynamic_dso, ctx->DYNAMIC_LIBNAME, s);\\r\\nif (!merge)\\r\\nreturn 0;\\r\\nif (DSO_load(ctx->dynamic_dso, merge, NULL, 0)) {\\r\\nOPENSSL_free(merge);\\r\\nreturn 1;\\r\\n}\\r\\nOPENSSL_free(merge);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx)\\r\\n{\\r\\nENGINE cpy;\\r\\ndynamic_fns fns;\\r\\nif (!ctx->dynamic_dso)\\r\\nctx->dynamic_dso = DSO_new();\\r\\nif (!ctx->DYNAMIC_LIBNAME) {\\r\\nif (!ctx->engine_id)\\r\\nreturn 0;\\r\\nctx->DYNAMIC_LIBNAME =\\r\\nDSO_convert_filename(ctx->dynamic_dso, ctx->engine_id);\\r\\n}\\r\\nif (!int_load(ctx)) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_NOT_FOUND);\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nctx->dynamic_dso = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nif (!\\r\\n(ctx->bind_engine =\\r\\n(dynamic_bind_engine) DSO_bind_func(ctx->dynamic_dso,\\r\\nctx->DYNAMIC_F2))) {\\r\\nctx->bind_engine = NULL;\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nctx->dynamic_dso = NULL;\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ctx->no_vcheck) {\\r\\nunsigned long vcheck_res = 0;\\r\\nctx->v_check =\\r\\n(dynamic_v_check_fn) DSO_bind_func(ctx->dynamic_dso,\\r\\nctx->DYNAMIC_F1);\\r\\nif (ctx->v_check)\\r\\nvcheck_res = ctx->v_check(OSSL_DYNAMIC_VERSION);\\r\\nif (vcheck_res < OSSL_DYNAMIC_OLDEST) {\\r\\nctx->bind_engine = NULL;\\r\\nctx->v_check = NULL;\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nctx->dynamic_dso = NULL;\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\\r\\nENGINE_R_VERSION_INCOMPATIBILITY);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nmemcpy(&cpy, e, sizeof(ENGINE));\\r\\nfns.static_state = ENGINE_get_static_state();\\r\\nfns.err_fns = ERR_get_implementation();\\r\\nfns.ex_data_fns = CRYPTO_get_ex_data_implementation();\\r\\nCRYPTO_get_mem_functions(&fns.mem_fns.malloc_cb,\\r\\n&fns.mem_fns.realloc_cb, &fns.mem_fns.free_cb);\\r\\nfns.lock_fns.lock_locking_cb = CRYPTO_get_locking_callback();\\r\\nfns.lock_fns.lock_add_lock_cb = CRYPTO_get_add_lock_callback();\\r\\nfns.lock_fns.dynlock_create_cb = CRYPTO_get_dynlock_create_callback();\\r\\nfns.lock_fns.dynlock_lock_cb = CRYPTO_get_dynlock_lock_callback();\\r\\nfns.lock_fns.dynlock_destroy_cb = CRYPTO_get_dynlock_destroy_callback();\\r\\nengine_set_all_null(e);\\r\\nif (!ctx->bind_engine(e, ctx->engine_id, &fns)) {\\r\\nctx->bind_engine = NULL;\\r\\nctx->v_check = NULL;\\r\\nDSO_free(ctx->dynamic_dso);\\r\\nctx->dynamic_dso = NULL;\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_INIT_FAILED);\\r\\nmemcpy(e, &cpy, sizeof(ENGINE));\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx->list_add_value > 0) {\\r\\nif (!ENGINE_add(e)) {\\r\\nif (ctx->list_add_value > 1) {\\r\\nENGINEerr(ENGINE_F_DYNAMIC_LOAD,\\r\\nENGINE_R_CONFLICTING_ENGINE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_mod_c", "target": 0, "func": "int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)\\r\\n{\\r\\nif (!(BN_mod(r, m, d, ctx)))\\r\\nreturn 0;\\r\\nif (!r->neg)\\r\\nreturn 1;\\r\\nreturn (d->neg ? BN_sub : BN_add) (r, r, d);\\r\\n}\\r\\nint BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (!BN_add(r, a, b))\\r\\nreturn 0;\\r\\nreturn BN_nnmod(r, r, m, ctx);\\r\\n}\\r\\nint BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\\r\\nconst BIGNUM *m)\\r\\n{\\r\\nif (!BN_uadd(r, a, b))\\r\\nreturn 0;\\r\\nif (BN_ucmp(r, m) >= 0)\\r\\nreturn BN_usub(r, r, m);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (!BN_sub(r, a, b))\\r\\nreturn 0;\\r\\nreturn BN_nnmod(r, r, m, ctx);\\r\\n}\\r\\nint BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\\r\\nconst BIGNUM *m)\\r\\n{\\r\\nif (!BN_sub(r, a, b))\\r\\nreturn 0;\\r\\nif (r->neg)\\r\\nreturn BN_add(r, r, m);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t;\\r\\nint ret = 0;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(m);\\r\\nBN_CTX_start(ctx);\\r\\nif ((t = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (a == b) {\\r\\nif (!BN_sqr(t, a, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mul(t, a, b, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_nnmod(r, t, m, ctx))\\r\\ngoto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_sqr(r, a, ctx))\\r\\nreturn 0;\\r\\nreturn BN_mod(r, r, m, ctx);\\r\\n}\\r\\nint BN_mod_lshift1(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)\\r\\n{\\r\\nif (!BN_lshift1(r, a))\\r\\nreturn 0;\\r\\nbn_check_top(r);\\r\\nreturn BN_nnmod(r, r, m, ctx);\\r\\n}\\r\\nint BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m)\\r\\n{\\r\\nif (!BN_lshift1(r, a))\\r\\nreturn 0;\\r\\nbn_check_top(r);\\r\\nif (BN_cmp(r, m) >= 0)\\r\\nreturn BN_sub(r, r, m);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_mod_lshift(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *abs_m = NULL;\\r\\nint ret;\\r\\nif (!BN_nnmod(r, a, m, ctx))\\r\\nreturn 0;\\r\\nif (m->neg) {\\r\\nabs_m = BN_dup(m);\\r\\nif (abs_m == NULL)\\r\\nreturn 0;\\r\\nabs_m->neg = 0;\\r\\n}\\r\\nret = BN_mod_lshift_quick(r, r, n, (abs_m ? abs_m : m));\\r\\nbn_check_top(r);\\r\\nif (abs_m)\\r\\nBN_free(abs_m);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m)\\r\\n{\\r\\nif (r != a) {\\r\\nif (BN_copy(r, a) == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nwhile (n > 0) {\\r\\nint max_shift;\\r\\nmax_shift = BN_num_bits(m) - BN_num_bits(r);\\r\\nif (max_shift < 0) {\\r\\nBNerr(BN_F_BN_MOD_LSHIFT_QUICK, BN_R_INPUT_NOT_REDUCED);\\r\\nreturn 0;\\r\\n}\\r\\nif (max_shift > n)\\r\\nmax_shift = n;\\r\\nif (max_shift) {\\r\\nif (!BN_lshift(r, r, max_shift))\\r\\nreturn 0;\\r\\nn -= max_shift;\\r\\n} else {\\r\\nif (!BN_lshift1(r, r))\\r\\nreturn 0;\\r\\n--n;\\r\\n}\\r\\nif (BN_cmp(r, m) >= 0) {\\r\\nif (!BN_sub(r, r, m))\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_asn1_c", "target": 0, "func": "static int dh_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nif (operation == ASN1_OP_NEW_PRE) {\\r\\n*pval = (ASN1_VALUE *)DH_new();\\r\\nif (*pval)\\r\\nreturn 2;\\r\\nreturn 0;\\r\\n} else if (operation == ASN1_OP_FREE_PRE) {\\r\\nDH_free((DH *)*pval);\\r\\n*pval = NULL;\\r\\nreturn 2;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nDH *d2i_DHxparams(DH **a, const unsigned char **pp, long length)\\r\\n{\\r\\nint_dhx942_dh *dhx = NULL;\\r\\nDH *dh = NULL;\\r\\ndh = DH_new();\\r\\nif (!dh)\\r\\nreturn NULL;\\r\\ndhx = d2i_int_dhx(NULL, pp, length);\\r\\nif (!dhx) {\\r\\nDH_free(dh);\\r\\nreturn NULL;\\r\\n}\\r\\nif (a) {\\r\\nif (*a)\\r\\nDH_free(*a);\\r\\n*a = dh;\\r\\n}\\r\\ndh->p = dhx->p;\\r\\ndh->q = dhx->q;\\r\\ndh->g = dhx->g;\\r\\ndh->j = dhx->j;\\r\\nif (dhx->vparams) {\\r\\ndh->seed = dhx->vparams->seed->data;\\r\\ndh->seedlen = dhx->vparams->seed->length;\\r\\ndh->counter = dhx->vparams->counter;\\r\\ndhx->vparams->seed->data = NULL;\\r\\nASN1_BIT_STRING_free(dhx->vparams->seed);\\r\\nOPENSSL_free(dhx->vparams);\\r\\ndhx->vparams = NULL;\\r\\n}\\r\\nOPENSSL_free(dhx);\\r\\nreturn dh;\\r\\n}\\r\\nint i2d_DHxparams(const DH *dh, unsigned char **pp)\\r\\n{\\r\\nint_dhx942_dh dhx;\\r\\nint_dhvparams dhv;\\r\\nASN1_BIT_STRING bs;\\r\\ndhx.p = dh->p;\\r\\ndhx.g = dh->g;\\r\\ndhx.q = dh->q;\\r\\ndhx.j = dh->j;\\r\\nif (dh->counter && dh->seed && dh->seedlen > 0) {\\r\\nbs.flags = ASN1_STRING_FLAG_BITS_LEFT;\\r\\nbs.data = dh->seed;\\r\\nbs.length = dh->seedlen;\\r\\ndhv.seed = &bs;\\r\\ndhv.counter = dh->counter;\\r\\ndhx.vparams = &dhv;\\r\\n} else\\r\\ndhx.vparams = NULL;\\r\\nreturn i2d_int_dhx(&dhx, pp);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pcy_lib_c", "target": 0, "func": "int X509_policy_tree_level_count(const X509_POLICY_TREE *tree)\\r\\n{\\r\\nif (!tree)\\r\\nreturn 0;\\r\\nreturn tree->nlevel;\\r\\n}\\r\\nX509_POLICY_LEVEL *X509_policy_tree_get0_level(const X509_POLICY_TREE *tree,\\r\\nint i)\\r\\n{\\r\\nif (!tree || (i < 0) || (i >= tree->nlevel))\\r\\nreturn NULL;\\r\\nreturn tree->levels + i;\\r\\n}\\r\\nX509_POLICY_NODE *X509_policy_level_get0_node(X509_POLICY_LEVEL *level, int i)\\r\\n{\\r\\nif (!level)\\r\\nreturn NULL;\\r\\nif (level->anyPolicy) {\\r\\nif (i == 0)\\r\\nreturn level->anyPolicy;\\r\\ni--;\\r\\n}\\r\\nreturn sk_X509_POLICY_NODE_value(level->nodes, i);\\r\\n}\\r\\nconst ASN1_OBJECT *X509_policy_node_get0_policy(const X509_POLICY_NODE *node)\\r\\n{\\r\\nif (!node)\\r\\nreturn NULL;\\r\\nreturn node->data->valid_policy;\\r\\n}\\r\\nX509_POLICY_NODE *X509_policy_node_get0_parent(const X509_POLICY_NODE\\r\\n*node)\\r\\n{\\r\\nif (!node)\\r\\nreturn NULL;\\r\\nreturn node->parent;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p_verify_c", "target": 0, "func": "int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf,\\r\\nunsigned int siglen, EVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char m[EVP_MAX_MD_SIZE];\\r\\nunsigned int m_len;\\r\\nint i = 0, ok = 0, v;\\r\\nEVP_MD_CTX tmp_ctx;\\r\\nEVP_PKEY_CTX *pkctx = NULL;\\r\\nEVP_MD_CTX_init(&tmp_ctx);\\r\\nif (!EVP_MD_CTX_copy_ex(&tmp_ctx, ctx))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&tmp_ctx, &(m[0]), &m_len))\\r\\ngoto err;\\r\\nEVP_MD_CTX_cleanup(&tmp_ctx);\\r\\nif (ctx->digest->flags & EVP_MD_FLAG_PKEY_METHOD_SIGNATURE) {\\r\\ni = -1;\\r\\npkctx = EVP_PKEY_CTX_new(pkey, NULL);\\r\\nif (!pkctx)\\r\\ngoto err;\\r\\nif (EVP_PKEY_verify_init(pkctx) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set_signature_md(pkctx, ctx->digest) <= 0)\\r\\ngoto err;\\r\\ni = EVP_PKEY_verify(pkctx, sigbuf, siglen, m, m_len);\\r\\nerr:\\r\\nEVP_PKEY_CTX_free(pkctx);\\r\\nreturn i;\\r\\n}\\r\\nfor (i = 0; i < 4; i++) {\\r\\nv = ctx->digest->required_pkey_type[i];\\r\\nif (v == 0)\\r\\nbreak;\\r\\nif (pkey->type == v) {\\r\\nok = 1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!ok) {\\r\\nEVPerr(EVP_F_EVP_VERIFYFINAL, EVP_R_WRONG_PUBLIC_KEY_TYPE);\\r\\nreturn (-1);\\r\\n}\\r\\nif (ctx->digest->verify == NULL) {\\r\\nEVPerr(EVP_F_EVP_VERIFYFINAL, EVP_R_NO_VERIFY_FUNCTION_CONFIGURED);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (ctx->digest->verify(ctx->digest->type, m, m_len,\\r\\nsigbuf, siglen, pkey->pkey.ptr));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_crl_c", "target": 0, "func": "static int crl_inf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nX509_CRL_INFO *a = (X509_CRL_INFO *)*pval;\\r\\nif (!a || !a->revoked)\\r\\nreturn 1;\\r\\nswitch (operation) {\\r\\ncase ASN1_OP_D2I_POST:\\r\\n(void)sk_X509_REVOKED_set_cmp_func(a->revoked, X509_REVOKED_cmp);\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint crl_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nX509_CRL *crl = (X509_CRL *)*pval;\\r\\nSTACK_OF(X509_EXTENSION) *exts;\\r\\nX509_EXTENSION *ext;\\r\\nint idx;\\r\\nswitch (operation) {\\r\\ncase ASN1_OP_NEW_POST:\\r\\ncrl->idp = NULL;\\r\\ncrl->akid = NULL;\\r\\ncrl->flags = 0;\\r\\ncrl->idp_flags = 0;\\r\\ncrl->idp_reasons = CRLDP_ALL_REASONS;\\r\\ncrl->meth = default_crl_method;\\r\\ncrl->meth_data = NULL;\\r\\ncrl->issuers = NULL;\\r\\ncrl->crl_number = NULL;\\r\\ncrl->base_crl_number = NULL;\\r\\nbreak;\\r\\ncase ASN1_OP_D2I_POST:\\r\\n#ifndef OPENSSL_NO_SHA\\r\\nX509_CRL_digest(crl, EVP_sha1(), crl->sha1_hash, NULL);\\r\\n#endif\\r\\ncrl->idp = X509_CRL_get_ext_d2i(crl,\\r\\nNID_issuing_distribution_point, NULL,\\r\\nNULL);\\r\\nif (crl->idp)\\r\\nsetup_idp(crl, crl->idp);\\r\\ncrl->akid = X509_CRL_get_ext_d2i(crl,\\r\\nNID_authority_key_identifier, NULL,\\r\\nNULL);\\r\\ncrl->crl_number = X509_CRL_get_ext_d2i(crl,\\r\\nNID_crl_number, NULL, NULL);\\r\\ncrl->base_crl_number = X509_CRL_get_ext_d2i(crl,\\r\\nNID_delta_crl, NULL,\\r\\nNULL);\\r\\nif (crl->base_crl_number && !crl->crl_number)\\r\\ncrl->flags |= EXFLAG_INVALID;\\r\\nexts = crl->crl->extensions;\\r\\nfor (idx = 0; idx < sk_X509_EXTENSION_num(exts); idx++) {\\r\\nint nid;\\r\\next = sk_X509_EXTENSION_value(exts, idx);\\r\\nnid = OBJ_obj2nid(ext->object);\\r\\nif (nid == NID_freshest_crl)\\r\\ncrl->flags |= EXFLAG_FRESHEST;\\r\\nif (ext->critical > 0) {\\r\\nif ((nid == NID_issuing_distribution_point)\\r\\n|| (nid == NID_authority_key_identifier)\\r\\n|| (nid == NID_delta_crl))\\r\\nbreak;;\\r\\ncrl->flags |= EXFLAG_CRITICAL;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!crl_set_issuers(crl))\\r\\nreturn 0;\\r\\nif (crl->meth->crl_init) {\\r\\nif (crl->meth->crl_init(crl) == 0)\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ncase ASN1_OP_FREE_POST:\\r\\nif (crl->meth->crl_free) {\\r\\nif (!crl->meth->crl_free(crl))\\r\\nreturn 0;\\r\\n}\\r\\nif (crl->akid)\\r\\nAUTHORITY_KEYID_free(crl->akid);\\r\\nif (crl->idp)\\r\\nISSUING_DIST_POINT_free(crl->idp);\\r\\nASN1_INTEGER_free(crl->crl_number);\\r\\nASN1_INTEGER_free(crl->base_crl_number);\\r\\nsk_GENERAL_NAMES_pop_free(crl->issuers, GENERAL_NAMES_free);\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void setup_idp(X509_CRL *crl, ISSUING_DIST_POINT *idp)\\r\\n{\\r\\nint idp_only = 0;\\r\\ncrl->idp_flags |= IDP_PRESENT;\\r\\nif (idp->onlyuser > 0) {\\r\\nidp_only++;\\r\\ncrl->idp_flags |= IDP_ONLYUSER;\\r\\n}\\r\\nif (idp->onlyCA > 0) {\\r\\nidp_only++;\\r\\ncrl->idp_flags |= IDP_ONLYCA;\\r\\n}\\r\\nif (idp->onlyattr > 0) {\\r\\nidp_only++;\\r\\ncrl->idp_flags |= IDP_ONLYATTR;\\r\\n}\\r\\nif (idp_only > 1)\\r\\ncrl->idp_flags |= IDP_INVALID;\\r\\nif (idp->indirectCRL > 0)\\r\\ncrl->idp_flags |= IDP_INDIRECT;\\r\\nif (idp->onlysomereasons) {\\r\\ncrl->idp_flags |= IDP_REASONS;\\r\\nif (idp->onlysomereasons->length > 0)\\r\\ncrl->idp_reasons = idp->onlysomereasons->data[0];\\r\\nif (idp->onlysomereasons->length > 1)\\r\\ncrl->idp_reasons |= (idp->onlysomereasons->data[1] << 8);\\r\\ncrl->idp_reasons &= CRLDP_ALL_REASONS;\\r\\n}\\r\\nDIST_POINT_set_dpname(idp->distpoint, X509_CRL_get_issuer(crl));\\r\\n}\\r\\nint X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev)\\r\\n{\\r\\nX509_CRL_INFO *inf;\\r\\ninf = crl->crl;\\r\\nif (!inf->revoked)\\r\\ninf->revoked = sk_X509_REVOKED_new(X509_REVOKED_cmp);\\r\\nif (!inf->revoked || !sk_X509_REVOKED_push(inf->revoked, rev)) {\\r\\nASN1err(ASN1_F_X509_CRL_ADD0_REVOKED, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\ninf->enc.modified = 1;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_CRL_verify(X509_CRL *crl, EVP_PKEY *r)\\r\\n{\\r\\nif (crl->meth->crl_verify)\\r\\nreturn crl->meth->crl_verify(crl, r);\\r\\nreturn 0;\\r\\n}\\r\\nint X509_CRL_get0_by_serial(X509_CRL *crl,\\r\\nX509_REVOKED **ret, ASN1_INTEGER *serial)\\r\\n{\\r\\nif (crl->meth->crl_lookup)\\r\\nreturn crl->meth->crl_lookup(crl, ret, serial, NULL);\\r\\nreturn 0;\\r\\n}\\r\\nint X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **ret, X509 *x)\\r\\n{\\r\\nif (crl->meth->crl_lookup)\\r\\nreturn crl->meth->crl_lookup(crl, ret,\\r\\nX509_get_serialNumber(x),\\r\\nX509_get_issuer_name(x));\\r\\nreturn 0;\\r\\n}\\r\\nstatic int def_crl_verify(X509_CRL *crl, EVP_PKEY *r)\\r\\n{\\r\\nreturn (ASN1_item_verify(ASN1_ITEM_rptr(X509_CRL_INFO),\\r\\ncrl->sig_alg, crl->signature, crl->crl, r));\\r\\n}\\r\\nstatic int crl_revoked_issuer_match(X509_CRL *crl, X509_NAME *nm,\\r\\nX509_REVOKED *rev)\\r\\n{\\r\\nint i;\\r\\nif (!rev->issuer) {\\r\\nif (!nm)\\r\\nreturn 1;\\r\\nif (!X509_NAME_cmp(nm, X509_CRL_get_issuer(crl)))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nif (!nm)\\r\\nnm = X509_CRL_get_issuer(crl);\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(rev->issuer); i++) {\\r\\nGENERAL_NAME *gen = sk_GENERAL_NAME_value(rev->issuer, i);\\r\\nif (gen->type != GEN_DIRNAME)\\r\\ncontinue;\\r\\nif (!X509_NAME_cmp(nm, gen->d.directoryName))\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int def_crl_lookup(X509_CRL *crl,\\r\\nX509_REVOKED **ret, ASN1_INTEGER *serial,\\r\\nX509_NAME *issuer)\\r\\n{\\r\\nX509_REVOKED rtmp, *rev;\\r\\nint idx;\\r\\nrtmp.serialNumber = serial;\\r\\nif (!sk_X509_REVOKED_is_sorted(crl->crl->revoked)) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_CRL);\\r\\nsk_X509_REVOKED_sort(crl->crl->revoked);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_CRL);\\r\\n}\\r\\nidx = sk_X509_REVOKED_find(crl->crl->revoked, &rtmp);\\r\\nif (idx < 0)\\r\\nreturn 0;\\r\\nfor (; idx < sk_X509_REVOKED_num(crl->crl->revoked); idx++) {\\r\\nrev = sk_X509_REVOKED_value(crl->crl->revoked, idx);\\r\\nif (ASN1_INTEGER_cmp(rev->serialNumber, serial))\\r\\nreturn 0;\\r\\nif (crl_revoked_issuer_match(crl, issuer, rev)) {\\r\\nif (ret)\\r\\n*ret = rev;\\r\\nif (rev->reason == CRL_REASON_REMOVE_FROM_CRL)\\r\\nreturn 2;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid X509_CRL_set_default_method(const X509_CRL_METHOD *meth)\\r\\n{\\r\\nif (meth == NULL)\\r\\ndefault_crl_method = &int_crl_meth;\\r\\nelse\\r\\ndefault_crl_method = meth;\\r\\n}\\r\\nX509_CRL_METHOD *X509_CRL_METHOD_new(int (*crl_init) (X509_CRL *crl),\\r\\nint (*crl_free) (X509_CRL *crl),\\r\\nint (*crl_lookup) (X509_CRL *crl,\\r\\nX509_REVOKED **ret,\\r\\nASN1_INTEGER *ser,\\r\\nX509_NAME *issuer),\\r\\nint (*crl_verify) (X509_CRL *crl,\\r\\nEVP_PKEY *pk))\\r\\n{\\r\\nX509_CRL_METHOD *m;\\r\\nm = OPENSSL_malloc(sizeof(X509_CRL_METHOD));\\r\\nif (!m)\\r\\nreturn NULL;\\r\\nm->crl_init = crl_init;\\r\\nm->crl_free = crl_free;\\r\\nm->crl_lookup = crl_lookup;\\r\\nm->crl_verify = crl_verify;\\r\\nm->flags = X509_CRL_METHOD_DYNAMIC;\\r\\nreturn m;\\r\\n}\\r\\nvoid X509_CRL_METHOD_free(X509_CRL_METHOD *m)\\r\\n{\\r\\nif (!(m->flags & X509_CRL_METHOD_DYNAMIC))\\r\\nreturn;\\r\\nOPENSSL_free(m);\\r\\n}\\r\\nvoid X509_CRL_set_meth_data(X509_CRL *crl, void *dat)\\r\\n{\\r\\ncrl->meth_data = dat;\\r\\n}\\r\\nvoid *X509_CRL_get_meth_data(X509_CRL *crl)\\r\\n{\\r\\nreturn crl->meth_data;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_req_c", "target": 0, "func": "X509_REQ *X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nX509_REQ *ret;\\r\\nX509_REQ_INFO *ri;\\r\\nint i;\\r\\nEVP_PKEY *pktmp;\\r\\nret = X509_REQ_new();\\r\\nif (ret == NULL) {\\r\\nX509err(X509_F_X509_TO_X509_REQ, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nri = ret->req_info;\\r\\nri->version->length = 1;\\r\\nri->version->data = (unsigned char *)OPENSSL_malloc(1);\\r\\nif (ri->version->data == NULL)\\r\\ngoto err;\\r\\nri->version->data[0] = 0;\\r\\nif (!X509_REQ_set_subject_name(ret, X509_get_subject_name(x)))\\r\\ngoto err;\\r\\npktmp = X509_get_pubkey(x);\\r\\ni = X509_REQ_set_pubkey(ret, pktmp);\\r\\nEVP_PKEY_free(pktmp);\\r\\nif (!i)\\r\\ngoto err;\\r\\nif (pkey != NULL) {\\r\\nif (!X509_REQ_sign(ret, pkey, md))\\r\\ngoto err;\\r\\n}\\r\\nreturn (ret);\\r\\nerr:\\r\\nX509_REQ_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nEVP_PKEY *X509_REQ_get_pubkey(X509_REQ *req)\\r\\n{\\r\\nif ((req == NULL) || (req->req_info == NULL))\\r\\nreturn (NULL);\\r\\nreturn (X509_PUBKEY_get(req->req_info->pubkey));\\r\\n}\\r\\nint X509_REQ_check_private_key(X509_REQ *x, EVP_PKEY *k)\\r\\n{\\r\\nEVP_PKEY *xk = NULL;\\r\\nint ok = 0;\\r\\nxk = X509_REQ_get_pubkey(x);\\r\\nswitch (EVP_PKEY_cmp(xk, k)) {\\r\\ncase 1:\\r\\nok = 1;\\r\\nbreak;\\r\\ncase 0:\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,\\r\\nX509_R_KEY_VALUES_MISMATCH);\\r\\nbreak;\\r\\ncase -1:\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_KEY_TYPE_MISMATCH);\\r\\nbreak;\\r\\ncase -2:\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (k->type == EVP_PKEY_EC) {\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, ERR_R_EC_LIB);\\r\\nbreak;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (k->type == EVP_PKEY_DH) {\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY,\\r\\nX509_R_CANT_CHECK_DH_KEY);\\r\\nbreak;\\r\\n}\\r\\n#endif\\r\\nX509err(X509_F_X509_REQ_CHECK_PRIVATE_KEY, X509_R_UNKNOWN_KEY_TYPE);\\r\\n}\\r\\nEVP_PKEY_free(xk);\\r\\nreturn (ok);\\r\\n}\\r\\nint X509_REQ_extension_nid(int req_nid)\\r\\n{\\r\\nint i, nid;\\r\\nfor (i = 0;; i++) {\\r\\nnid = ext_nids[i];\\r\\nif (nid == NID_undef)\\r\\nreturn 0;\\r\\nelse if (req_nid == nid)\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nint *X509_REQ_get_extension_nids(void)\\r\\n{\\r\\nreturn ext_nids;\\r\\n}\\r\\nvoid X509_REQ_set_extension_nids(int *nids)\\r\\n{\\r\\next_nids = nids;\\r\\n}\\r\\nint X509_REQ_get_attr_count(const X509_REQ *req)\\r\\n{\\r\\nreturn X509at_get_attr_count(req->req_info->attributes);\\r\\n}\\r\\nint X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid, int lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_NID(req->req_info->attributes, nid, lastpos);\\r\\n}\\r\\nint X509_REQ_get_attr_by_OBJ(const X509_REQ *req, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn X509at_get_attr_by_OBJ(req->req_info->attributes, obj, lastpos);\\r\\n}\\r\\nX509_ATTRIBUTE *X509_REQ_get_attr(const X509_REQ *req, int loc)\\r\\n{\\r\\nreturn X509at_get_attr(req->req_info->attributes, loc);\\r\\n}\\r\\nX509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req, int loc)\\r\\n{\\r\\nreturn X509at_delete_attr(req->req_info->attributes, loc);\\r\\n}\\r\\nint X509_REQ_add1_attr(X509_REQ *req, X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif (X509at_add1_attr(&req->req_info->attributes, attr))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint X509_REQ_add1_attr_by_OBJ(X509_REQ *req,\\r\\nconst ASN1_OBJECT *obj, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_OBJ(&req->req_info->attributes, obj,\\r\\ntype, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint X509_REQ_add1_attr_by_NID(X509_REQ *req,\\r\\nint nid, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&req->req_info->attributes, nid,\\r\\ntype, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint X509_REQ_add1_attr_by_txt(X509_REQ *req,\\r\\nconst char *attrname, int type,\\r\\nconst unsigned char *bytes, int len)\\r\\n{\\r\\nif (X509at_add1_attr_by_txt(&req->req_info->attributes, attrname,\\r\\ntype, bytes, len))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_gf2m_c", "target": 0, "func": "static void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a,\\r\\nconst BN_ULONG b)\\r\\n{\\r\\nregister BN_ULONG h, l, s;\\r\\nBN_ULONG tab[8], top2b = a >> 30;\\r\\nregister BN_ULONG a1, a2, a4;\\r\\na1 = a & (0x3FFFFFFF);\\r\\na2 = a1 << 1;\\r\\na4 = a2 << 1;\\r\\ntab[0] = 0;\\r\\ntab[1] = a1;\\r\\ntab[2] = a2;\\r\\ntab[3] = a1 ^ a2;\\r\\ntab[4] = a4;\\r\\ntab[5] = a1 ^ a4;\\r\\ntab[6] = a2 ^ a4;\\r\\ntab[7] = a1 ^ a2 ^ a4;\\r\\ns = tab[b & 0x7];\\r\\nl = s;\\r\\ns = tab[b >> 3 & 0x7];\\r\\nl ^= s << 3;\\r\\nh = s >> 29;\\r\\ns = tab[b >> 6 & 0x7];\\r\\nl ^= s << 6;\\r\\nh ^= s >> 26;\\r\\ns = tab[b >> 9 & 0x7];\\r\\nl ^= s << 9;\\r\\nh ^= s >> 23;\\r\\ns = tab[b >> 12 & 0x7];\\r\\nl ^= s << 12;\\r\\nh ^= s >> 20;\\r\\ns = tab[b >> 15 & 0x7];\\r\\nl ^= s << 15;\\r\\nh ^= s >> 17;\\r\\ns = tab[b >> 18 & 0x7];\\r\\nl ^= s << 18;\\r\\nh ^= s >> 14;\\r\\ns = tab[b >> 21 & 0x7];\\r\\nl ^= s << 21;\\r\\nh ^= s >> 11;\\r\\ns = tab[b >> 24 & 0x7];\\r\\nl ^= s << 24;\\r\\nh ^= s >> 8;\\r\\ns = tab[b >> 27 & 0x7];\\r\\nl ^= s << 27;\\r\\nh ^= s >> 5;\\r\\ns = tab[b >> 30];\\r\\nl ^= s << 30;\\r\\nh ^= s >> 2;\\r\\nif (top2b & 01) {\\r\\nl ^= b << 30;\\r\\nh ^= b >> 2;\\r\\n}\\r\\nif (top2b & 02) {\\r\\nl ^= b << 31;\\r\\nh ^= b >> 1;\\r\\n}\\r\\n*r1 = h;\\r\\n*r0 = l;\\r\\n}\\r\\nstatic void bn_GF2m_mul_1x1(BN_ULONG *r1, BN_ULONG *r0, const BN_ULONG a,\\r\\nconst BN_ULONG b)\\r\\n{\\r\\nregister BN_ULONG h, l, s;\\r\\nBN_ULONG tab[16], top3b = a >> 61;\\r\\nregister BN_ULONG a1, a2, a4, a8;\\r\\na1 = a & (0x1FFFFFFFFFFFFFFFULL);\\r\\na2 = a1 << 1;\\r\\na4 = a2 << 1;\\r\\na8 = a4 << 1;\\r\\ntab[0] = 0;\\r\\ntab[1] = a1;\\r\\ntab[2] = a2;\\r\\ntab[3] = a1 ^ a2;\\r\\ntab[4] = a4;\\r\\ntab[5] = a1 ^ a4;\\r\\ntab[6] = a2 ^ a4;\\r\\ntab[7] = a1 ^ a2 ^ a4;\\r\\ntab[8] = a8;\\r\\ntab[9] = a1 ^ a8;\\r\\ntab[10] = a2 ^ a8;\\r\\ntab[11] = a1 ^ a2 ^ a8;\\r\\ntab[12] = a4 ^ a8;\\r\\ntab[13] = a1 ^ a4 ^ a8;\\r\\ntab[14] = a2 ^ a4 ^ a8;\\r\\ntab[15] = a1 ^ a2 ^ a4 ^ a8;\\r\\ns = tab[b & 0xF];\\r\\nl = s;\\r\\ns = tab[b >> 4 & 0xF];\\r\\nl ^= s << 4;\\r\\nh = s >> 60;\\r\\ns = tab[b >> 8 & 0xF];\\r\\nl ^= s << 8;\\r\\nh ^= s >> 56;\\r\\ns = tab[b >> 12 & 0xF];\\r\\nl ^= s << 12;\\r\\nh ^= s >> 52;\\r\\ns = tab[b >> 16 & 0xF];\\r\\nl ^= s << 16;\\r\\nh ^= s >> 48;\\r\\ns = tab[b >> 20 & 0xF];\\r\\nl ^= s << 20;\\r\\nh ^= s >> 44;\\r\\ns = tab[b >> 24 & 0xF];\\r\\nl ^= s << 24;\\r\\nh ^= s >> 40;\\r\\ns = tab[b >> 28 & 0xF];\\r\\nl ^= s << 28;\\r\\nh ^= s >> 36;\\r\\ns = tab[b >> 32 & 0xF];\\r\\nl ^= s << 32;\\r\\nh ^= s >> 32;\\r\\ns = tab[b >> 36 & 0xF];\\r\\nl ^= s << 36;\\r\\nh ^= s >> 28;\\r\\ns = tab[b >> 40 & 0xF];\\r\\nl ^= s << 40;\\r\\nh ^= s >> 24;\\r\\ns = tab[b >> 44 & 0xF];\\r\\nl ^= s << 44;\\r\\nh ^= s >> 20;\\r\\ns = tab[b >> 48 & 0xF];\\r\\nl ^= s << 48;\\r\\nh ^= s >> 16;\\r\\ns = tab[b >> 52 & 0xF];\\r\\nl ^= s << 52;\\r\\nh ^= s >> 12;\\r\\ns = tab[b >> 56 & 0xF];\\r\\nl ^= s << 56;\\r\\nh ^= s >> 8;\\r\\ns = tab[b >> 60];\\r\\nl ^= s << 60;\\r\\nh ^= s >> 4;\\r\\nif (top3b & 01) {\\r\\nl ^= b << 61;\\r\\nh ^= b >> 3;\\r\\n}\\r\\nif (top3b & 02) {\\r\\nl ^= b << 62;\\r\\nh ^= b >> 2;\\r\\n}\\r\\nif (top3b & 04) {\\r\\nl ^= b << 63;\\r\\nh ^= b >> 1;\\r\\n}\\r\\n*r1 = h;\\r\\n*r0 = l;\\r\\n}\\r\\nstatic void bn_GF2m_mul_2x2(BN_ULONG *r, const BN_ULONG a1, const BN_ULONG a0,\\r\\nconst BN_ULONG b1, const BN_ULONG b0)\\r\\n{\\r\\nBN_ULONG m1, m0;\\r\\nbn_GF2m_mul_1x1(r + 3, r + 2, a1, b1);\\r\\nbn_GF2m_mul_1x1(r + 1, r, a0, b0);\\r\\nbn_GF2m_mul_1x1(&m1, &m0, a0 ^ a1, b0 ^ b1);\\r\\nr[2] ^= m1 ^ r[1] ^ r[3];\\r\\nr[1] = r[3] ^ r[2] ^ r[0] ^ m1 ^ m0;\\r\\n}\\r\\nint BN_GF2m_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nconst BIGNUM *at, *bt;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->top < b->top) {\\r\\nat = b;\\r\\nbt = a;\\r\\n} else {\\r\\nat = a;\\r\\nbt = b;\\r\\n}\\r\\nif (bn_wexpand(r, at->top) == NULL)\\r\\nreturn 0;\\r\\nfor (i = 0; i < bt->top; i++) {\\r\\nr->d[i] = at->d[i] ^ bt->d[i];\\r\\n}\\r\\nfor (; i < at->top; i++) {\\r\\nr->d[i] = at->d[i];\\r\\n}\\r\\nr->top = at->top;\\r\\nbn_correct_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[])\\r\\n{\\r\\nint j, k;\\r\\nint n, dN, d0, d1;\\r\\nBN_ULONG zz, *z;\\r\\nbn_check_top(a);\\r\\nif (!p[0]) {\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nif (a != r) {\\r\\nif (!bn_wexpand(r, a->top))\\r\\nreturn 0;\\r\\nfor (j = 0; j < a->top; j++) {\\r\\nr->d[j] = a->d[j];\\r\\n}\\r\\nr->top = a->top;\\r\\n}\\r\\nz = r->d;\\r\\ndN = p[0] / BN_BITS2;\\r\\nfor (j = r->top - 1; j > dN;) {\\r\\nzz = z[j];\\r\\nif (z[j] == 0) {\\r\\nj--;\\r\\ncontinue;\\r\\n}\\r\\nz[j] = 0;\\r\\nfor (k = 1; p[k] != 0; k++) {\\r\\nn = p[0] - p[k];\\r\\nd0 = n % BN_BITS2;\\r\\nd1 = BN_BITS2 - d0;\\r\\nn /= BN_BITS2;\\r\\nz[j - n] ^= (zz >> d0);\\r\\nif (d0)\\r\\nz[j - n - 1] ^= (zz << d1);\\r\\n}\\r\\nn = dN;\\r\\nd0 = p[0] % BN_BITS2;\\r\\nd1 = BN_BITS2 - d0;\\r\\nz[j - n] ^= (zz >> d0);\\r\\nif (d0)\\r\\nz[j - n - 1] ^= (zz << d1);\\r\\n}\\r\\nwhile (j == dN) {\\r\\nd0 = p[0] % BN_BITS2;\\r\\nzz = z[dN] >> d0;\\r\\nif (zz == 0)\\r\\nbreak;\\r\\nd1 = BN_BITS2 - d0;\\r\\nif (d0)\\r\\nz[dN] = (z[dN] << d1) >> d1;\\r\\nelse\\r\\nz[dN] = 0;\\r\\nz[0] ^= zz;\\r\\nfor (k = 1; p[k] != 0; k++) {\\r\\nBN_ULONG tmp_ulong;\\r\\nn = p[k] / BN_BITS2;\\r\\nd0 = p[k] % BN_BITS2;\\r\\nd1 = BN_BITS2 - d0;\\r\\nz[n] ^= (zz << d0);\\r\\ntmp_ulong = zz >> d1;\\r\\nif (d0 && tmp_ulong)\\r\\nz[n + 1] ^= tmp_ulong;\\r\\n}\\r\\n}\\r\\nbn_correct_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p)\\r\\n{\\r\\nint ret = 0;\\r\\nint arr[6];\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nret = BN_GF2m_poly2arr(p, arr, sizeof(arr) / sizeof(arr[0]));\\r\\nif (!ret || ret > (int)(sizeof(arr) / sizeof(arr[0]))) {\\r\\nBNerr(BN_F_BN_GF2M_MOD, BN_R_INVALID_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\nret = BN_GF2m_mod_arr(r, a, arr);\\r\\nbn_check_top(r);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\\r\\nconst int p[], BN_CTX *ctx)\\r\\n{\\r\\nint zlen, i, j, k, ret = 0;\\r\\nBIGNUM *s;\\r\\nBN_ULONG x1, x0, y1, y0, zz[4];\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a == b) {\\r\\nreturn BN_GF2m_mod_sqr_arr(r, a, p, ctx);\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nif ((s = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nzlen = a->top + b->top + 4;\\r\\nif (!bn_wexpand(s, zlen))\\r\\ngoto err;\\r\\ns->top = zlen;\\r\\nfor (i = 0; i < zlen; i++)\\r\\ns->d[i] = 0;\\r\\nfor (j = 0; j < b->top; j += 2) {\\r\\ny0 = b->d[j];\\r\\ny1 = ((j + 1) == b->top) ? 0 : b->d[j + 1];\\r\\nfor (i = 0; i < a->top; i += 2) {\\r\\nx0 = a->d[i];\\r\\nx1 = ((i + 1) == a->top) ? 0 : a->d[i + 1];\\r\\nbn_GF2m_mul_2x2(zz, x1, x0, y1, y0);\\r\\nfor (k = 0; k < 4; k++)\\r\\ns->d[i + j + k] ^= zz[k];\\r\\n}\\r\\n}\\r\\nbn_correct_top(s);\\r\\nif (BN_GF2m_mod_arr(r, s, p))\\r\\nret = 1;\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\\r\\nconst BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p) + 1;\\r\\nint *arr = NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(p);\\r\\nif ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL)\\r\\ngoto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max) {\\r\\nBNerr(BN_F_BN_GF2M_MOD_MUL, BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_mul_arr(r, a, b, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr)\\r\\nOPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const int p[],\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint i, ret = 0;\\r\\nBIGNUM *s;\\r\\nbn_check_top(a);\\r\\nBN_CTX_start(ctx);\\r\\nif ((s = BN_CTX_get(ctx)) == NULL)\\r\\nreturn 0;\\r\\nif (!bn_wexpand(s, 2 * a->top))\\r\\ngoto err;\\r\\nfor (i = a->top - 1; i >= 0; i--) {\\r\\ns->d[2 * i + 1] = SQR1(a->d[i]);\\r\\ns->d[2 * i] = SQR0(a->d[i]);\\r\\n}\\r\\ns->top = 2 * a->top;\\r\\nbn_correct_top(s);\\r\\nif (!BN_GF2m_mod_arr(r, s, p))\\r\\ngoto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p) + 1;\\r\\nint *arr = NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nif ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL)\\r\\ngoto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max) {\\r\\nBNerr(BN_F_BN_GF2M_MOD_SQR, BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_sqr_arr(r, a, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr)\\r\\nOPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *b, *c = NULL, *u = NULL, *v = NULL, *tmp;\\r\\nint ret = 0;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nBN_CTX_start(ctx);\\r\\nif ((b = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif ((c = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif ((u = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif ((v = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod(u, a, p))\\r\\ngoto err;\\r\\nif (BN_is_zero(u))\\r\\ngoto err;\\r\\nif (!BN_copy(v, p))\\r\\ngoto err;\\r\\n# if 0\\r\\nif (!BN_one(b))\\r\\ngoto err;\\r\\nwhile (1) {\\r\\nwhile (!BN_is_odd(u)) {\\r\\nif (BN_is_zero(u))\\r\\ngoto err;\\r\\nif (!BN_rshift1(u, u))\\r\\ngoto err;\\r\\nif (BN_is_odd(b)) {\\r\\nif (!BN_GF2m_add(b, b, p))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_rshift1(b, b))\\r\\ngoto err;\\r\\n}\\r\\nif (BN_abs_is_word(u, 1))\\r\\nbreak;\\r\\nif (BN_num_bits(u) < BN_num_bits(v)) {\\r\\ntmp = u;\\r\\nu = v;\\r\\nv = tmp;\\r\\ntmp = b;\\r\\nb = c;\\r\\nc = tmp;\\r\\n}\\r\\nif (!BN_GF2m_add(u, u, v))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(b, b, c))\\r\\ngoto err;\\r\\n}\\r\\n# else\\r\\n{\\r\\nint i, ubits = BN_num_bits(u), vbits = BN_num_bits(v),\\r\\ntop = p->top;\\r\\nBN_ULONG *udp, *bdp, *vdp, *cdp;\\r\\nbn_wexpand(u, top);\\r\\nudp = u->d;\\r\\nfor (i = u->top; i < top; i++)\\r\\nudp[i] = 0;\\r\\nu->top = top;\\r\\nbn_wexpand(b, top);\\r\\nbdp = b->d;\\r\\nbdp[0] = 1;\\r\\nfor (i = 1; i < top; i++)\\r\\nbdp[i] = 0;\\r\\nb->top = top;\\r\\nbn_wexpand(c, top);\\r\\ncdp = c->d;\\r\\nfor (i = 0; i < top; i++)\\r\\ncdp[i] = 0;\\r\\nc->top = top;\\r\\nvdp = v->d;\\r\\nwhile (1) {\\r\\nwhile (ubits && !(udp[0] & 1)) {\\r\\nBN_ULONG u0, u1, b0, b1, mask;\\r\\nu0 = udp[0];\\r\\nb0 = bdp[0];\\r\\nmask = (BN_ULONG)0 - (b0 & 1);\\r\\nb0 ^= p->d[0] & mask;\\r\\nfor (i = 0; i < top - 1; i++) {\\r\\nu1 = udp[i + 1];\\r\\nudp[i] = ((u0 >> 1) | (u1 << (BN_BITS2 - 1))) & BN_MASK2;\\r\\nu0 = u1;\\r\\nb1 = bdp[i + 1] ^ (p->d[i + 1] & mask);\\r\\nbdp[i] = ((b0 >> 1) | (b1 << (BN_BITS2 - 1))) & BN_MASK2;\\r\\nb0 = b1;\\r\\n}\\r\\nudp[i] = u0 >> 1;\\r\\nbdp[i] = b0 >> 1;\\r\\nubits--;\\r\\n}\\r\\nif (ubits <= BN_BITS2 && udp[0] == 1)\\r\\nbreak;\\r\\nif (ubits < vbits) {\\r\\ni = ubits;\\r\\nubits = vbits;\\r\\nvbits = i;\\r\\ntmp = u;\\r\\nu = v;\\r\\nv = tmp;\\r\\ntmp = b;\\r\\nb = c;\\r\\nc = tmp;\\r\\nudp = vdp;\\r\\nvdp = v->d;\\r\\nbdp = cdp;\\r\\ncdp = c->d;\\r\\n}\\r\\nfor (i = 0; i < top; i++) {\\r\\nudp[i] ^= vdp[i];\\r\\nbdp[i] ^= cdp[i];\\r\\n}\\r\\nif (ubits == vbits) {\\r\\nBN_ULONG ul;\\r\\nint utop = (ubits - 1) / BN_BITS2;\\r\\nwhile ((ul = udp[utop]) == 0 && utop)\\r\\nutop--;\\r\\nubits = utop * BN_BITS2 + BN_num_bits_word(ul);\\r\\n}\\r\\n}\\r\\nbn_correct_top(b);\\r\\n}\\r\\n# endif\\r\\nif (!BN_copy(r, b))\\r\\ngoto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\n# ifdef BN_DEBUG\\r\\nbn_correct_top(c);\\r\\nbn_correct_top(u);\\r\\nbn_correct_top(v);\\r\\n# endif\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *xx, const int p[],\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *field;\\r\\nint ret = 0;\\r\\nbn_check_top(xx);\\r\\nBN_CTX_start(ctx);\\r\\nif ((field = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_arr2poly(p, field))\\r\\ngoto err;\\r\\nret = BN_GF2m_mod_inv(r, xx, field, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *y, const BIGNUM *x,\\r\\nconst BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *xinv = NULL;\\r\\nint ret = 0;\\r\\nbn_check_top(y);\\r\\nbn_check_top(x);\\r\\nbn_check_top(p);\\r\\nBN_CTX_start(ctx);\\r\\nxinv = BN_CTX_get(ctx);\\r\\nif (xinv == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_inv(xinv, x, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_mul(r, y, xinv, p, ctx))\\r\\ngoto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *y, const BIGNUM *x,\\r\\nconst BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *a, *b, *u, *v;\\r\\nint ret = 0;\\r\\nbn_check_top(y);\\r\\nbn_check_top(x);\\r\\nbn_check_top(p);\\r\\nBN_CTX_start(ctx);\\r\\na = BN_CTX_get(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nu = BN_CTX_get(ctx);\\r\\nv = BN_CTX_get(ctx);\\r\\nif (v == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod(u, y, p))\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod(a, x, p))\\r\\ngoto err;\\r\\nif (!BN_copy(b, p))\\r\\ngoto err;\\r\\nwhile (!BN_is_odd(a)) {\\r\\nif (!BN_rshift1(a, a))\\r\\ngoto err;\\r\\nif (BN_is_odd(u))\\r\\nif (!BN_GF2m_add(u, u, p))\\r\\ngoto err;\\r\\nif (!BN_rshift1(u, u))\\r\\ngoto err;\\r\\n}\\r\\ndo {\\r\\nif (BN_GF2m_cmp(b, a) > 0) {\\r\\nif (!BN_GF2m_add(b, b, a))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(v, v, u))\\r\\ngoto err;\\r\\ndo {\\r\\nif (!BN_rshift1(b, b))\\r\\ngoto err;\\r\\nif (BN_is_odd(v))\\r\\nif (!BN_GF2m_add(v, v, p))\\r\\ngoto err;\\r\\nif (!BN_rshift1(v, v))\\r\\ngoto err;\\r\\n} while (!BN_is_odd(b));\\r\\n} else if (BN_abs_is_word(a, 1))\\r\\nbreak;\\r\\nelse {\\r\\nif (!BN_GF2m_add(a, a, b))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(u, u, v))\\r\\ngoto err;\\r\\ndo {\\r\\nif (!BN_rshift1(a, a))\\r\\ngoto err;\\r\\nif (BN_is_odd(u))\\r\\nif (!BN_GF2m_add(u, u, p))\\r\\ngoto err;\\r\\nif (!BN_rshift1(u, u))\\r\\ngoto err;\\r\\n} while (!BN_is_odd(a));\\r\\n}\\r\\n} while (1);\\r\\nif (!BN_copy(r, u))\\r\\ngoto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *yy, const BIGNUM *xx,\\r\\nconst int p[], BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *field;\\r\\nint ret = 0;\\r\\nbn_check_top(yy);\\r\\nbn_check_top(xx);\\r\\nBN_CTX_start(ctx);\\r\\nif ((field = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_arr2poly(p, field))\\r\\ngoto err;\\r\\nret = BN_GF2m_mod_div(r, yy, xx, field, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\\r\\nconst int p[], BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0, i, n;\\r\\nBIGNUM *u;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (BN_is_zero(b))\\r\\nreturn (BN_one(r));\\r\\nif (BN_abs_is_word(b, 1))\\r\\nreturn (BN_copy(r, a) != NULL);\\r\\nBN_CTX_start(ctx);\\r\\nif ((u = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_arr(u, a, p))\\r\\ngoto err;\\r\\nn = BN_num_bits(b) - 1;\\r\\nfor (i = n - 1; i >= 0; i--) {\\r\\nif (!BN_GF2m_mod_sqr_arr(u, u, p, ctx))\\r\\ngoto err;\\r\\nif (BN_is_bit_set(b, i)) {\\r\\nif (!BN_GF2m_mod_mul_arr(u, u, a, p, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_copy(r, u))\\r\\ngoto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,\\r\\nconst BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p) + 1;\\r\\nint *arr = NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nbn_check_top(p);\\r\\nif ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL)\\r\\ngoto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max) {\\r\\nBNerr(BN_F_BN_GF2M_MOD_EXP, BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_exp_arr(r, a, b, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr)\\r\\nOPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a, const int p[],\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *u;\\r\\nbn_check_top(a);\\r\\nif (!p[0]) {\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nif ((u = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_set_bit(u, p[0] - 1))\\r\\ngoto err;\\r\\nret = BN_GF2m_mod_exp_arr(r, a, u, p, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p) + 1;\\r\\nint *arr = NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nif ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL)\\r\\ngoto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max) {\\r\\nBNerr(BN_F_BN_GF2M_MOD_SQRT, BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_sqrt_arr(r, a, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr)\\r\\nOPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a_, const int p[],\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = 0, count = 0, j;\\r\\nBIGNUM *a, *z, *rho, *w, *w2, *tmp;\\r\\nbn_check_top(a_);\\r\\nif (!p[0]) {\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\na = BN_CTX_get(ctx);\\r\\nz = BN_CTX_get(ctx);\\r\\nw = BN_CTX_get(ctx);\\r\\nif (w == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_arr(a, a_, p))\\r\\ngoto err;\\r\\nif (BN_is_zero(a)) {\\r\\nBN_zero(r);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (p[0] & 0x1) {\\r\\nif (!BN_copy(z, a))\\r\\ngoto err;\\r\\nfor (j = 1; j <= (p[0] - 1) / 2; j++) {\\r\\nif (!BN_GF2m_mod_sqr_arr(z, z, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_sqr_arr(z, z, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(z, z, a))\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nrho = BN_CTX_get(ctx);\\r\\nw2 = BN_CTX_get(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nif (tmp == NULL)\\r\\ngoto err;\\r\\ndo {\\r\\nif (!BN_rand(rho, p[0], 0, 0))\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_arr(rho, rho, p))\\r\\ngoto err;\\r\\nBN_zero(z);\\r\\nif (!BN_copy(w, rho))\\r\\ngoto err;\\r\\nfor (j = 1; j <= p[0] - 1; j++) {\\r\\nif (!BN_GF2m_mod_sqr_arr(z, z, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_sqr_arr(w2, w, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_mul_arr(tmp, w2, a, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(z, z, tmp))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(w, w2, rho))\\r\\ngoto err;\\r\\n}\\r\\ncount++;\\r\\n} while (BN_is_zero(w) && (count < MAX_ITERATIONS));\\r\\nif (BN_is_zero(w)) {\\r\\nBNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR, BN_R_TOO_MANY_ITERATIONS);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_GF2m_mod_sqr_arr(w, z, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(w, z, w))\\r\\ngoto err;\\r\\nif (BN_GF2m_cmp(w, a)) {\\r\\nBNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR, BN_R_NO_SOLUTION);\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_copy(r, z))\\r\\ngoto err;\\r\\nbn_check_top(r);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nconst int max = BN_num_bits(p) + 1;\\r\\nint *arr = NULL;\\r\\nbn_check_top(a);\\r\\nbn_check_top(p);\\r\\nif ((arr = (int *)OPENSSL_malloc(sizeof(int) * max)) == NULL)\\r\\ngoto err;\\r\\nret = BN_GF2m_poly2arr(p, arr, max);\\r\\nif (!ret || ret > max) {\\r\\nBNerr(BN_F_BN_GF2M_MOD_SOLVE_QUAD, BN_R_INVALID_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nret = BN_GF2m_mod_solve_quad_arr(r, a, arr, ctx);\\r\\nbn_check_top(r);\\r\\nerr:\\r\\nif (arr)\\r\\nOPENSSL_free(arr);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)\\r\\n{\\r\\nint i, j, k = 0;\\r\\nBN_ULONG mask;\\r\\nif (BN_is_zero(a))\\r\\nreturn 0;\\r\\nfor (i = a->top - 1; i >= 0; i--) {\\r\\nif (!a->d[i])\\r\\ncontinue;\\r\\nmask = BN_TBIT;\\r\\nfor (j = BN_BITS2 - 1; j >= 0; j--) {\\r\\nif (a->d[i] & mask) {\\r\\nif (k < max)\\r\\np[k] = BN_BITS2 * i + j;\\r\\nk++;\\r\\n}\\r\\nmask >>= 1;\\r\\n}\\r\\n}\\r\\nif (k < max) {\\r\\np[k] = -1;\\r\\nk++;\\r\\n}\\r\\nreturn k;\\r\\n}\\r\\nint BN_GF2m_arr2poly(const int p[], BIGNUM *a)\\r\\n{\\r\\nint i;\\r\\nbn_check_top(a);\\r\\nBN_zero(a);\\r\\nfor (i = 0; p[i] != -1; i++) {\\r\\nif (BN_set_bit(a, p[i]) == 0)\\r\\nreturn 0;\\r\\n}\\r\\nbn_check_top(a);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_chk_c", "target": 0, "func": "int RSA_check_key(const RSA *key)\\r\\n{\\r\\nBIGNUM *i, *j, *k, *l, *m;\\r\\nBN_CTX *ctx;\\r\\nint r;\\r\\nint ret = 1;\\r\\nif (!key->p || !key->q || !key->n || !key->e || !key->d) {\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_VALUE_MISSING);\\r\\nreturn 0;\\r\\n}\\r\\ni = BN_new();\\r\\nj = BN_new();\\r\\nk = BN_new();\\r\\nl = BN_new();\\r\\nm = BN_new();\\r\\nctx = BN_CTX_new();\\r\\nif (i == NULL || j == NULL || k == NULL || l == NULL ||\\r\\nm == NULL || ctx == NULL) {\\r\\nret = -1;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nr = BN_is_prime_ex(key->p, BN_prime_checks, NULL, NULL);\\r\\nif (r != 1) {\\r\\nret = r;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_P_NOT_PRIME);\\r\\n}\\r\\nr = BN_is_prime_ex(key->q, BN_prime_checks, NULL, NULL);\\r\\nif (r != 1) {\\r\\nret = r;\\r\\nif (r != 0)\\r\\ngoto err;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_Q_NOT_PRIME);\\r\\n}\\r\\nr = BN_mul(i, key->p, key->q, ctx);\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (BN_cmp(i, key->n) != 0) {\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_N_DOES_NOT_EQUAL_P_Q);\\r\\n}\\r\\nr = BN_sub(i, key->p, BN_value_one());\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nr = BN_sub(j, key->q, BN_value_one());\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nr = BN_mul(l, i, j, ctx);\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nr = BN_gcd(m, i, j, ctx);\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nr = BN_div(k, NULL, l, m, ctx);\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nr = BN_mod_mul(i, key->d, key->e, k, ctx);\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_is_one(i)) {\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_D_E_NOT_CONGRUENT_TO_1);\\r\\n}\\r\\nif (key->dmp1 != NULL && key->dmq1 != NULL && key->iqmp != NULL) {\\r\\nr = BN_sub(i, key->p, BN_value_one());\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nr = BN_mod(j, key->d, i, ctx);\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (BN_cmp(j, key->dmp1) != 0) {\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_DMP1_NOT_CONGRUENT_TO_D);\\r\\n}\\r\\nr = BN_sub(i, key->q, BN_value_one());\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nr = BN_mod(j, key->d, i, ctx);\\r\\nif (!r) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (BN_cmp(j, key->dmq1) != 0) {\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_DMQ1_NOT_CONGRUENT_TO_D);\\r\\n}\\r\\nif (!BN_mod_inverse(i, key->q, key->p, ctx)) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (BN_cmp(i, key->iqmp) != 0) {\\r\\nret = 0;\\r\\nRSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_IQMP_NOT_INVERSE_OF_Q);\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (i != NULL)\\r\\nBN_free(i);\\r\\nif (j != NULL)\\r\\nBN_free(j);\\r\\nif (k != NULL)\\r\\nBN_free(k);\\r\\nif (l != NULL)\\r\\nBN_free(l);\\r\\nif (m != NULL)\\r\\nBN_free(m);\\r\\nif (ctx != NULL)\\r\\nBN_CTX_free(ctx);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ocsp_lib_c", "target": 0, "func": "OCSP_CERTID *OCSP_cert_to_id(const EVP_MD *dgst, X509 *subject, X509 *issuer)\\r\\n{\\r\\nX509_NAME *iname;\\r\\nASN1_INTEGER *serial;\\r\\nASN1_BIT_STRING *ikey;\\r\\n#ifndef OPENSSL_NO_SHA1\\r\\nif (!dgst)\\r\\ndgst = EVP_sha1();\\r\\n#endif\\r\\nif (subject) {\\r\\niname = X509_get_issuer_name(subject);\\r\\nserial = X509_get_serialNumber(subject);\\r\\n} else {\\r\\niname = X509_get_subject_name(issuer);\\r\\nserial = NULL;\\r\\n}\\r\\nikey = X509_get0_pubkey_bitstr(issuer);\\r\\nreturn OCSP_cert_id_new(dgst, iname, ikey, serial);\\r\\n}\\r\\nOCSP_CERTID *OCSP_cert_id_new(const EVP_MD *dgst,\\r\\nX509_NAME *issuerName,\\r\\nASN1_BIT_STRING *issuerKey,\\r\\nASN1_INTEGER *serialNumber)\\r\\n{\\r\\nint nid;\\r\\nunsigned int i;\\r\\nX509_ALGOR *alg;\\r\\nOCSP_CERTID *cid = NULL;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nif (!(cid = OCSP_CERTID_new()))\\r\\ngoto err;\\r\\nalg = cid->hashAlgorithm;\\r\\nif (alg->algorithm != NULL)\\r\\nASN1_OBJECT_free(alg->algorithm);\\r\\nif ((nid = EVP_MD_type(dgst)) == NID_undef) {\\r\\nOCSPerr(OCSP_F_OCSP_CERT_ID_NEW, OCSP_R_UNKNOWN_NID);\\r\\ngoto err;\\r\\n}\\r\\nif (!(alg->algorithm = OBJ_nid2obj(nid)))\\r\\ngoto err;\\r\\nif ((alg->parameter = ASN1_TYPE_new()) == NULL)\\r\\ngoto err;\\r\\nalg->parameter->type = V_ASN1_NULL;\\r\\nif (!X509_NAME_digest(issuerName, dgst, md, &i))\\r\\ngoto digerr;\\r\\nif (!(ASN1_OCTET_STRING_set(cid->issuerNameHash, md, i)))\\r\\ngoto err;\\r\\nif (!EVP_Digest(issuerKey->data, issuerKey->length, md, &i, dgst, NULL))\\r\\ngoto err;\\r\\nif (!(ASN1_OCTET_STRING_set(cid->issuerKeyHash, md, i)))\\r\\ngoto err;\\r\\nif (serialNumber) {\\r\\nASN1_INTEGER_free(cid->serialNumber);\\r\\nif (!(cid->serialNumber = ASN1_INTEGER_dup(serialNumber)))\\r\\ngoto err;\\r\\n}\\r\\nreturn cid;\\r\\ndigerr:\\r\\nOCSPerr(OCSP_F_OCSP_CERT_ID_NEW, OCSP_R_DIGEST_ERR);\\r\\nerr:\\r\\nif (cid)\\r\\nOCSP_CERTID_free(cid);\\r\\nreturn NULL;\\r\\n}\\r\\nint OCSP_id_issuer_cmp(OCSP_CERTID *a, OCSP_CERTID *b)\\r\\n{\\r\\nint ret;\\r\\nret = OBJ_cmp(a->hashAlgorithm->algorithm, b->hashAlgorithm->algorithm);\\r\\nif (ret)\\r\\nreturn ret;\\r\\nret = ASN1_OCTET_STRING_cmp(a->issuerNameHash, b->issuerNameHash);\\r\\nif (ret)\\r\\nreturn ret;\\r\\nreturn ASN1_OCTET_STRING_cmp(a->issuerKeyHash, b->issuerKeyHash);\\r\\n}\\r\\nint OCSP_id_cmp(OCSP_CERTID *a, OCSP_CERTID *b)\\r\\n{\\r\\nint ret;\\r\\nret = OCSP_id_issuer_cmp(a, b);\\r\\nif (ret)\\r\\nreturn ret;\\r\\nreturn ASN1_INTEGER_cmp(a->serialNumber, b->serialNumber);\\r\\n}\\r\\nint OCSP_parse_url(const char *url, char **phost, char **pport, char **ppath,\\r\\nint *pssl)\\r\\n{\\r\\nchar *p, *buf;\\r\\nchar *host, *port;\\r\\n*phost = NULL;\\r\\n*pport = NULL;\\r\\n*ppath = NULL;\\r\\nbuf = BUF_strdup(url);\\r\\nif (!buf)\\r\\ngoto mem_err;\\r\\np = strchr(buf, ':');\\r\\nif (!p)\\r\\ngoto parse_err;\\r\\n*(p++) = '\\0';\\r\\nif (!strcmp(buf, \"http\")) {\\r\\n*pssl = 0;\\r\\nport = \"80\";\\r\\n} else if (!strcmp(buf, \"https\")) {\\r\\n*pssl = 1;\\r\\nport = \"443\";\\r\\n} else\\r\\ngoto parse_err;\\r\\nif ((p[0] != '/') || (p[1] != '/'))\\r\\ngoto parse_err;\\r\\np += 2;\\r\\nhost = p;\\r\\np = strchr(p, '/');\\r\\nif (!p)\\r\\n*ppath = BUF_strdup(\"/\");\\r\\nelse {\\r\\n*ppath = BUF_strdup(p);\\r\\n*p = '\\0';\\r\\n}\\r\\nif (!*ppath)\\r\\ngoto mem_err;\\r\\np = host;\\r\\nif (host[0] == '[') {\\r\\nhost++;\\r\\np = strchr(host, ']');\\r\\nif (!p)\\r\\ngoto parse_err;\\r\\n*p = '\\0';\\r\\np++;\\r\\n}\\r\\nif ((p = strchr(p, ':'))) {\\r\\n*p = 0;\\r\\nport = p + 1;\\r\\n} else {\\r\\nif (*pssl)\\r\\nport = \"443\";\\r\\nelse\\r\\nport = \"80\";\\r\\n}\\r\\n*pport = BUF_strdup(port);\\r\\nif (!*pport)\\r\\ngoto mem_err;\\r\\n*phost = BUF_strdup(host);\\r\\nif (!*phost)\\r\\ngoto mem_err;\\r\\nOPENSSL_free(buf);\\r\\nreturn 1;\\r\\nmem_err:\\r\\nOCSPerr(OCSP_F_OCSP_PARSE_URL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\nparse_err:\\r\\nOCSPerr(OCSP_F_OCSP_PARSE_URL, OCSP_R_ERROR_PARSING_URL);\\r\\nerr:\\r\\nif (buf)\\r\\nOPENSSL_free(buf);\\r\\nif (*ppath)\\r\\nOPENSSL_free(*ppath);\\r\\nif (*pport)\\r\\nOPENSSL_free(*pport);\\r\\nif (*phost)\\r\\nOPENSSL_free(*phost);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_s_client_c", "target": 0, "func": "static unsigned int psk_client_cb(SSL *ssl, const char *hint, char *identity,\\r\\nunsigned int max_identity_len,\\r\\nunsigned char *psk,\\r\\nunsigned int max_psk_len)\\r\\n{\\r\\nunsigned int psk_len = 0;\\r\\nint ret;\\r\\nBIGNUM *bn = NULL;\\r\\nif (c_debug)\\r\\nBIO_printf(bio_c_out, \"psk_client_cb\\n\");\\r\\nif (!hint) {\\r\\nif (c_debug)\\r\\nBIO_printf(bio_c_out,\\r\\n\"NULL received PSK identity hint, continuing anyway\\n\");\\r\\n} else if (c_debug)\\r\\nBIO_printf(bio_c_out, \"Received PSK identity hint '%s'\\n\", hint);\\r\\nret = BIO_snprintf(identity, max_identity_len, \"%s\", psk_identity);\\r\\nif (ret < 0 || (unsigned int)ret > max_identity_len)\\r\\ngoto out_err;\\r\\nif (c_debug)\\r\\nBIO_printf(bio_c_out, \"created identity '%s' len=%d\\n\", identity,\\r\\nret);\\r\\nret = BN_hex2bn(&bn, psk_key);\\r\\nif (!ret) {\\r\\nBIO_printf(bio_err, \"Could not convert PSK key '%s' to BIGNUM\\n\",\\r\\npsk_key);\\r\\nif (bn)\\r\\nBN_free(bn);\\r\\nreturn 0;\\r\\n}\\r\\nif ((unsigned int)BN_num_bytes(bn) > max_psk_len) {\\r\\nBIO_printf(bio_err,\\r\\n\"psk buffer of callback is too small (%d) for key (%d)\\n\",\\r\\nmax_psk_len, BN_num_bytes(bn));\\r\\nBN_free(bn);\\r\\nreturn 0;\\r\\n}\\r\\npsk_len = BN_bn2bin(bn, psk);\\r\\nBN_free(bn);\\r\\nif (psk_len == 0)\\r\\ngoto out_err;\\r\\nif (c_debug)\\r\\nBIO_printf(bio_c_out, \"created PSK len=%d\\n\", psk_len);\\r\\nreturn psk_len;\\r\\nout_err:\\r\\nif (c_debug)\\r\\nBIO_printf(bio_err, \"Error in PSK client callback\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nstatic void sc_usage(void)\\r\\n{\\r\\nBIO_printf(bio_err, \"usage: s_client args\\n\");\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\nBIO_printf(bio_err, \" -host host - use -connect instead\\n\");\\r\\nBIO_printf(bio_err, \" -port port - use -connect instead\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -connect host:port - who to connect to (default is %s:%s)\\n\",\\r\\nSSL_HOST_NAME, PORT_STR);\\r\\nBIO_printf(bio_err,\\r\\n\" -verify_host host - check peer certificate matches \\\"host\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -verify_email email - check peer certificate matches \\\"email\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -verify_ip ipaddr - check peer certificate matches \\\"ipaddr\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -verify arg - turn on peer certificate verification\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -verify_return_error - return verification errors\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -cert arg - certificate file to use, PEM format assumed\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -certform arg - certificate format (PEM or DER) PEM default\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -key arg - Private key file to use, in cert file if\\n\");\\r\\nBIO_printf(bio_err, \" not specified but cert file is.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -keyform arg - key format (PEM or DER) PEM default\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -pass arg - private key file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \" -CApath arg - PEM format directory of CA's\\n\");\\r\\nBIO_printf(bio_err, \" -CAfile arg - PEM format file of CA's\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -reconnect - Drop and re-make the connection with the same Session-ID\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -pause - sleep(1) after each read(2) and write(2) system call\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -prexit - print session information even on connection failure\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -showcerts - show all certificates in the chain\\n\");\\r\\nBIO_printf(bio_err, \" -debug - extra output\\n\");\\r\\n#ifdef WATT32\\r\\nBIO_printf(bio_err, \" -wdebug - WATT-32 tcp debugging\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \" -msg - Show protocol messages\\n\");\\r\\nBIO_printf(bio_err, \" -nbio_test - more ssl protocol testing\\n\");\\r\\nBIO_printf(bio_err, \" -state - print the 'ssl' states\\n\");\\r\\n#ifdef FIONBIO\\r\\nBIO_printf(bio_err, \" -nbio - Run with non-blocking IO\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\\r\\n\" -crlf - convert LF from terminal into CRLF\\n\");\\r\\nBIO_printf(bio_err, \" -quiet - no s_client output\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -ign_eof - ignore input eof (default when -quiet)\\n\");\\r\\nBIO_printf(bio_err, \" -no_ign_eof - don't ignore input eof\\n\");\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nBIO_printf(bio_err, \" -psk_identity arg - PSK identity\\n\");\\r\\nBIO_printf(bio_err, \" -psk arg - PSK in hex (without 0x)\\n\");\\r\\n# ifndef OPENSSL_NO_JPAKE\\r\\nBIO_printf(bio_err, \" -jpake arg - JPAKE secret to use\\n\");\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nBIO_printf(bio_err,\\r\\n\" -srpuser user - SRP authentification for 'user'\\n\");\\r\\nBIO_printf(bio_err, \" -srppass arg - password for 'user'\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -srp_lateuser - SRP username into second ClientHello message\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -srp_moregroups - Tolerate other than the known g N values.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -srp_strength int - minimal length in bits for N (default %d).\\n\",\\r\\nSRP_MINIMAL_N);\\r\\n#endif\\r\\nBIO_printf(bio_err, \" -ssl2 - just use SSLv2\\n\");\\r\\n#ifndef OPENSSL_NO_SSL3_METHOD\\r\\nBIO_printf(bio_err, \" -ssl3 - just use SSLv3\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \" -tls1_2 - just use TLSv1.2\\n\");\\r\\nBIO_printf(bio_err, \" -tls1_1 - just use TLSv1.1\\n\");\\r\\nBIO_printf(bio_err, \" -tls1 - just use TLSv1\\n\");\\r\\nBIO_printf(bio_err, \" -dtls1 - just use DTLSv1\\n\");\\r\\nBIO_printf(bio_err, \" -fallback_scsv - send TLS_FALLBACK_SCSV\\n\");\\r\\nBIO_printf(bio_err, \" -mtu - set the link layer MTU\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -no_tls1_2/-no_tls1_1/-no_tls1/-no_ssl3/-no_ssl2 - turn off that protocol\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -bugs - Switch on all SSL implementation bug workarounds\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -serverpref - Use server's cipher preferences (only SSLv2)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -cipher - preferred cipher to use, use the 'openssl ciphers'\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" command to see what is available\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -starttls prot - use the STARTTLS command before starting TLS\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" for those protocols that support it, where\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" 'prot' defines which one to assume. Currently,\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" only \\\"smtp\\\", \\\"pop3\\\", \\\"imap\\\", \\\"ftp\\\" and \\\"xmpp\\\"\\n\");\\r\\nBIO_printf(bio_err, \" are supported.\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine id - Initialise and use the specified engine\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err, \" -sess_out arg - file to write SSL session to\\n\");\\r\\nBIO_printf(bio_err, \" -sess_in arg - file to read SSL session from\\n\");\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nBIO_printf(bio_err,\\r\\n\" -servername host - Set TLS extension servername in ClientHello\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -tlsextdebug - hex dump of all TLS extensions received\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -status - request certificate status from server\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -no_ticket - disable use of RFC4507bis session tickets\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -serverinfo types - send empty ClientHello extensions (comma-separated numbers)\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nBIO_printf(bio_err,\\r\\n\" -nextprotoneg arg - enable NPN extension, considering named protocols supported (comma-separated list)\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\\r\\n\" -alpn arg - enable ALPN extension, considering named protocols supported (comma-separated list)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -legacy_renegotiation - enable use of legacy renegotiation (dangerous)\\n\");\\r\\n#ifndef OPENSSL_NO_SRTP\\r\\nBIO_printf(bio_err,\\r\\n\" -use_srtp profiles - Offer SRTP key management with a colon-separated profile list\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\\r\\n\" -keymatexport label - Export keying material using label\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -keymatexportlen len - Export len bytes of keying material (default 20)\\n\");\\r\\n}\\r\\nstatic int MS_CALLBACK ssl_servername_cb(SSL *s, int *ad, void *arg)\\r\\n{\\r\\ntlsextctx *p = (tlsextctx *) arg;\\r\\nconst char *hn = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);\\r\\nif (SSL_get_servername_type(s) != -1)\\r\\np->ack = !SSL_session_reused(s) && hn != NULL;\\r\\nelse\\r\\nBIO_printf(bio_err, \"Can't use SSL_get_servername\\n\");\\r\\nreturn SSL_TLSEXT_ERR_OK;\\r\\n}\\r\\nstatic int srp_Verify_N_and_g(BIGNUM *N, BIGNUM *g)\\r\\n{\\r\\nBN_CTX *bn_ctx = BN_CTX_new();\\r\\nBIGNUM *p = BN_new();\\r\\nBIGNUM *r = BN_new();\\r\\nint ret =\\r\\ng != NULL && N != NULL && bn_ctx != NULL && BN_is_odd(N) &&\\r\\nBN_is_prime_ex(N, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) &&\\r\\np != NULL && BN_rshift1(p, N) &&\\r\\nBN_is_prime_ex(p, SRP_NUMBER_ITERATIONS_FOR_PRIME, bn_ctx, NULL) &&\\r\\nr != NULL &&\\r\\nBN_mod_exp(r, g, p, N, bn_ctx) &&\\r\\nBN_add_word(r, 1) && BN_cmp(r, N) == 0;\\r\\nif (r)\\r\\nBN_free(r);\\r\\nif (p)\\r\\nBN_free(p);\\r\\nif (bn_ctx)\\r\\nBN_CTX_free(bn_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int MS_CALLBACK ssl_srp_verify_param_cb(SSL *s, void *arg)\\r\\n{\\r\\nSRP_ARG *srp_arg = (SRP_ARG *)arg;\\r\\nBIGNUM *N = NULL, *g = NULL;\\r\\nif (!(N = SSL_get_srp_N(s)) || !(g = SSL_get_srp_g(s)))\\r\\nreturn 0;\\r\\nif (srp_arg->debug || srp_arg->msg || srp_arg->amp == 1) {\\r\\nBIO_printf(bio_err, \"SRP parameters:\\n\");\\r\\nBIO_printf(bio_err, \"\\tN=\");\\r\\nBN_print(bio_err, N);\\r\\nBIO_printf(bio_err, \"\\n\\tg=\");\\r\\nBN_print(bio_err, g);\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\n}\\r\\nif (SRP_check_known_gN_param(g, N))\\r\\nreturn 1;\\r\\nif (srp_arg->amp == 1) {\\r\\nif (srp_arg->debug)\\r\\nBIO_printf(bio_err,\\r\\n\"SRP param N and g are not known params, going to check deeper.\\n\");\\r\\nif (BN_num_bits(g) <= BN_BITS && srp_Verify_N_and_g(N, g))\\r\\nreturn 1;\\r\\n}\\r\\nBIO_printf(bio_err, \"SRP param N and g rejected.\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nstatic char *MS_CALLBACK ssl_give_srp_client_pwd_cb(SSL *s, void *arg)\\r\\n{\\r\\nSRP_ARG *srp_arg = (SRP_ARG *)arg;\\r\\nchar *pass = (char *)OPENSSL_malloc(PWD_STRLEN + 1);\\r\\nPW_CB_DATA cb_tmp;\\r\\nint l;\\r\\ncb_tmp.password = (char *)srp_arg->srppassin;\\r\\ncb_tmp.prompt_info = \"SRP user\";\\r\\nif ((l = password_callback(pass, PWD_STRLEN, 0, &cb_tmp)) < 0) {\\r\\nBIO_printf(bio_err, \"Can't read Password\\n\");\\r\\nOPENSSL_free(pass);\\r\\nreturn NULL;\\r\\n}\\r\\n*(pass + l) = '\\0';\\r\\nreturn pass;\\r\\n}\\r\\nstatic int next_proto_cb(SSL *s, unsigned char **out, unsigned char *outlen,\\r\\nconst unsigned char *in, unsigned int inlen,\\r\\nvoid *arg)\\r\\n{\\r\\ntlsextnextprotoctx *ctx = arg;\\r\\nif (!c_quiet) {\\r\\nunsigned i;\\r\\nBIO_printf(bio_c_out, \"Protocols advertised by server: \");\\r\\nfor (i = 0; i < inlen;) {\\r\\nif (i)\\r\\nBIO_write(bio_c_out, \", \", 2);\\r\\nBIO_write(bio_c_out, &in[i + 1], in[i]);\\r\\ni += in[i] + 1;\\r\\n}\\r\\nBIO_write(bio_c_out, \"\\n\", 1);\\r\\n}\\r\\nctx->status =\\r\\nSSL_select_next_proto(out, outlen, in, inlen, ctx->data, ctx->len);\\r\\nreturn SSL_TLSEXT_ERR_OK;\\r\\n}\\r\\nstatic int serverinfo_cli_parse_cb(SSL *s, unsigned int ext_type,\\r\\nconst unsigned char *in, size_t inlen,\\r\\nint *al, void *arg)\\r\\n{\\r\\nchar pem_name[100];\\r\\nunsigned char ext_buf[4 + 65536];\\r\\next_buf[0] = ext_type >> 8;\\r\\next_buf[1] = ext_type & 0xFF;\\r\\next_buf[2] = inlen >> 8;\\r\\next_buf[3] = inlen & 0xFF;\\r\\nmemcpy(ext_buf + 4, in, inlen);\\r\\nBIO_snprintf(pem_name, sizeof(pem_name), \"SERVERINFO FOR EXTENSION %d\",\\r\\next_type);\\r\\nPEM_write_bio(bio_c_out, pem_name, \"\", ext_buf, 4 + inlen);\\r\\nreturn 1;\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nint build_chain = 0;\\r\\nSSL *con = NULL;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nKSSL_CTX *kctx;\\r\\n#endif\\r\\nint s, k, width, state = 0;\\r\\nchar *cbuf = NULL, *sbuf = NULL, *mbuf = NULL;\\r\\nint cbuf_len, cbuf_off;\\r\\nint sbuf_len, sbuf_off;\\r\\nfd_set readfds, writefds;\\r\\nshort port = PORT;\\r\\nint full_log = 1;\\r\\nchar *host = SSL_HOST_NAME;\\r\\nchar *cert_file = NULL, *key_file = NULL, *chain_file = NULL;\\r\\nint cert_format = FORMAT_PEM, key_format = FORMAT_PEM;\\r\\nchar *passarg = NULL, *pass = NULL;\\r\\nX509 *cert = NULL;\\r\\nEVP_PKEY *key = NULL;\\r\\nSTACK_OF(X509) *chain = NULL;\\r\\nchar *CApath = NULL, *CAfile = NULL;\\r\\nchar *chCApath = NULL, *chCAfile = NULL;\\r\\nchar *vfyCApath = NULL, *vfyCAfile = NULL;\\r\\nint reconnect = 0, badop = 0, verify = SSL_VERIFY_NONE;\\r\\nint crlf = 0;\\r\\nint write_tty, read_tty, write_ssl, read_ssl, tty_on, ssl_pending;\\r\\nSSL_CTX *ctx = NULL;\\r\\nint ret = 1, in_init = 1, i, nbio_test = 0;\\r\\nint starttls_proto = PROTO_OFF;\\r\\nint prexit = 0;\\r\\nX509_VERIFY_PARAM *vpm = NULL;\\r\\nint badarg = 0;\\r\\nconst SSL_METHOD *meth = NULL;\\r\\nint socket_type = SOCK_STREAM;\\r\\nBIO *sbio;\\r\\nchar *inrand = NULL;\\r\\nint mbuf_len = 0;\\r\\nstruct timeval timeout, *timeoutp;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine_id = NULL;\\r\\nchar *ssl_client_engine_id = NULL;\\r\\nENGINE *ssl_client_engine = NULL;\\r\\n#endif\\r\\nENGINE *e = NULL;\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)\\r\\nstruct timeval tv;\\r\\n# if defined(OPENSSL_SYS_BEOS_R5)\\r\\nint stdin_set = 0;\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nchar *servername = NULL;\\r\\ntlsextctx tlsextcbp = { NULL, 0 };\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nconst char *next_proto_neg_in = NULL;\\r\\n# endif\\r\\nconst char *alpn_in = NULL;\\r\\n# define MAX_SI_TYPES 100\\r\\nunsigned short serverinfo_types[MAX_SI_TYPES];\\r\\nint serverinfo_types_count = 0;\\r\\n#endif\\r\\nchar *sess_in = NULL;\\r\\nchar *sess_out = NULL;\\r\\nstruct sockaddr peer;\\r\\nint peerlen = sizeof(peer);\\r\\nint fallback_scsv = 0;\\r\\nint enable_timeouts = 0;\\r\\nlong socket_mtu = 0;\\r\\n#ifndef OPENSSL_NO_JPAKE\\r\\nstatic char *jpake_secret = NULL;\\r\\n# define no_jpake !jpake_secret\\r\\n#else\\r\\n# define no_jpake 1\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nchar *srppass = NULL;\\r\\nint srp_lateuser = 0;\\r\\nSRP_ARG srp_arg = { NULL, NULL, 0, 0, 0, 1024 };\\r\\n#endif\\r\\nSSL_EXCERT *exc = NULL;\\r\\nSSL_CONF_CTX *cctx = NULL;\\r\\nSTACK_OF(OPENSSL_STRING) *ssl_args = NULL;\\r\\nchar *crl_file = NULL;\\r\\nint crl_format = FORMAT_PEM;\\r\\nint crl_download = 0;\\r\\nSTACK_OF(X509_CRL) *crls = NULL;\\r\\nmeth = SSLv23_client_method();\\r\\napps_startup();\\r\\nc_Pause = 0;\\r\\nc_quiet = 0;\\r\\nc_ign_eof = 0;\\r\\nc_debug = 0;\\r\\nc_msg = 0;\\r\\nc_showcerts = 0;\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ncctx = SSL_CONF_CTX_new();\\r\\nif (!cctx)\\r\\ngoto end;\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CLIENT);\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CMDLINE);\\r\\nif (((cbuf = OPENSSL_malloc(BUFSIZZ)) == NULL) ||\\r\\n((sbuf = OPENSSL_malloc(BUFSIZZ)) == NULL) ||\\r\\n((mbuf = OPENSSL_malloc(BUFSIZZ)) == NULL)) {\\r\\nBIO_printf(bio_err, \"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nverify_depth = 0;\\r\\nverify_error = X509_V_OK;\\r\\n#ifdef FIONBIO\\r\\nc_nbio = 0;\\r\\n#endif\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-host\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nhost = *(++argv);\\r\\n} else if (strcmp(*argv, \"-port\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nport = atoi(*(++argv));\\r\\nif (port == 0)\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-connect\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!extract_host_port(*(++argv), &host, NULL, &port))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-verify\") == 0) {\\r\\nverify = SSL_VERIFY_PEER;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nverify_depth = atoi(*(++argv));\\r\\nif (!c_quiet)\\r\\nBIO_printf(bio_err, \"verify depth is %d\\n\", verify_depth);\\r\\n} else if (strcmp(*argv, \"-cert\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncert_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-CRL\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncrl_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-crl_download\") == 0)\\r\\ncrl_download = 1;\\r\\nelse if (strcmp(*argv, \"-sess_out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsess_out = *(++argv);\\r\\n} else if (strcmp(*argv, \"-sess_in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsess_in = *(++argv);\\r\\n} else if (strcmp(*argv, \"-certform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncert_format = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-CRLform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncrl_format = str2fmt(*(++argv));\\r\\n} else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm)) {\\r\\nif (badarg)\\r\\ngoto bad;\\r\\ncontinue;\\r\\n} else if (strcmp(*argv, \"-verify_return_error\") == 0)\\r\\nverify_return_error = 1;\\r\\nelse if (strcmp(*argv, \"-verify_quiet\") == 0)\\r\\nverify_quiet = 1;\\r\\nelse if (strcmp(*argv, \"-brief\") == 0) {\\r\\nc_brief = 1;\\r\\nverify_quiet = 1;\\r\\nc_quiet = 1;\\r\\n} else if (args_excert(&argv, &argc, &badarg, bio_err, &exc)) {\\r\\nif (badarg)\\r\\ngoto bad;\\r\\ncontinue;\\r\\n} else if (args_ssl(&argv, &argc, cctx, &badarg, bio_err, &ssl_args)) {\\r\\nif (badarg)\\r\\ngoto bad;\\r\\ncontinue;\\r\\n} else if (strcmp(*argv, \"-prexit\") == 0)\\r\\nprexit = 1;\\r\\nelse if (strcmp(*argv, \"-crlf\") == 0)\\r\\ncrlf = 1;\\r\\nelse if (strcmp(*argv, \"-quiet\") == 0) {\\r\\nc_quiet = 1;\\r\\nc_ign_eof = 1;\\r\\n} else if (strcmp(*argv, \"-ign_eof\") == 0)\\r\\nc_ign_eof = 1;\\r\\nelse if (strcmp(*argv, \"-no_ign_eof\") == 0)\\r\\nc_ign_eof = 0;\\r\\nelse if (strcmp(*argv, \"-pause\") == 0)\\r\\nc_Pause = 1;\\r\\nelse if (strcmp(*argv, \"-debug\") == 0)\\r\\nc_debug = 1;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nelse if (strcmp(*argv, \"-tlsextdebug\") == 0)\\r\\nc_tlsextdebug = 1;\\r\\nelse if (strcmp(*argv, \"-status\") == 0)\\r\\nc_status_req = 1;\\r\\n#endif\\r\\n#ifdef WATT32\\r\\nelse if (strcmp(*argv, \"-wdebug\") == 0)\\r\\ndbug_init();\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-msg\") == 0)\\r\\nc_msg = 1;\\r\\nelse if (strcmp(*argv, \"-msgfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nbio_c_msg = BIO_new_file(*(++argv), \"w\");\\r\\n}\\r\\n#ifndef OPENSSL_NO_SSL_TRACE\\r\\nelse if (strcmp(*argv, \"-trace\") == 0)\\r\\nc_msg = 2;\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-showcerts\") == 0)\\r\\nc_showcerts = 1;\\r\\nelse if (strcmp(*argv, \"-nbio_test\") == 0)\\r\\nnbio_test = 1;\\r\\nelse if (strcmp(*argv, \"-state\") == 0)\\r\\nstate = 1;\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nelse if (strcmp(*argv, \"-psk_identity\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npsk_identity = *(++argv);\\r\\n} else if (strcmp(*argv, \"-psk\") == 0) {\\r\\nsize_t j;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npsk_key = *(++argv);\\r\\nfor (j = 0; j < strlen(psk_key); j++) {\\r\\nif (isxdigit((unsigned char)psk_key[j]))\\r\\ncontinue;\\r\\nBIO_printf(bio_err, \"Not a hex number '%s'\\n\", *argv);\\r\\ngoto bad;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nelse if (strcmp(*argv, \"-srpuser\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsrp_arg.srplogin = *(++argv);\\r\\nmeth = TLSv1_client_method();\\r\\n} else if (strcmp(*argv, \"-srppass\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsrppass = *(++argv);\\r\\nmeth = TLSv1_client_method();\\r\\n} else if (strcmp(*argv, \"-srp_strength\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsrp_arg.strength = atoi(*(++argv));\\r\\nBIO_printf(bio_err, \"SRP minimal length for N is %d\\n\",\\r\\nsrp_arg.strength);\\r\\nmeth = TLSv1_client_method();\\r\\n} else if (strcmp(*argv, \"-srp_lateuser\") == 0) {\\r\\nsrp_lateuser = 1;\\r\\nmeth = TLSv1_client_method();\\r\\n} else if (strcmp(*argv, \"-srp_moregroups\") == 0) {\\r\\nsrp_arg.amp = 1;\\r\\nmeth = TLSv1_client_method();\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nelse if (strcmp(*argv, \"-ssl2\") == 0)\\r\\nmeth = SSLv2_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3_METHOD\\r\\nelse if (strcmp(*argv, \"-ssl3\") == 0)\\r\\nmeth = SSLv3_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLS1\\r\\nelse if (strcmp(*argv, \"-tls1_2\") == 0)\\r\\nmeth = TLSv1_2_client_method();\\r\\nelse if (strcmp(*argv, \"-tls1_1\") == 0)\\r\\nmeth = TLSv1_1_client_method();\\r\\nelse if (strcmp(*argv, \"-tls1\") == 0)\\r\\nmeth = TLSv1_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DTLS1\\r\\nelse if (strcmp(*argv, \"-dtls\") == 0) {\\r\\nmeth = DTLS_client_method();\\r\\nsocket_type = SOCK_DGRAM;\\r\\n} else if (strcmp(*argv, \"-dtls1\") == 0) {\\r\\nmeth = DTLSv1_client_method();\\r\\nsocket_type = SOCK_DGRAM;\\r\\n} else if (strcmp(*argv, \"-dtls1_2\") == 0) {\\r\\nmeth = DTLSv1_2_client_method();\\r\\nsocket_type = SOCK_DGRAM;\\r\\n} else if (strcmp(*argv, \"-timeout\") == 0)\\r\\nenable_timeouts = 1;\\r\\nelse if (strcmp(*argv, \"-mtu\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsocket_mtu = atol(*(++argv));\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-fallback_scsv\") == 0) {\\r\\nfallback_scsv = 1;\\r\\n} else if (strcmp(*argv, \"-keyform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkey_format = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-pass\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassarg = *(++argv);\\r\\n} else if (strcmp(*argv, \"-cert_chain\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nchain_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-key\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkey_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-reconnect\") == 0) {\\r\\nreconnect = 5;\\r\\n} else if (strcmp(*argv, \"-CApath\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCApath = *(++argv);\\r\\n} else if (strcmp(*argv, \"-chainCApath\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nchCApath = *(++argv);\\r\\n} else if (strcmp(*argv, \"-verifyCApath\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nvfyCApath = *(++argv);\\r\\n} else if (strcmp(*argv, \"-build_chain\") == 0)\\r\\nbuild_chain = 1;\\r\\nelse if (strcmp(*argv, \"-CAfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCAfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-chainCAfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nchCAfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-verifyCAfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nvfyCAfile = *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nelse if (strcmp(*argv, \"-nextprotoneg\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nnext_proto_neg_in = *(++argv);\\r\\n}\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-alpn\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nalpn_in = *(++argv);\\r\\n} else if (strcmp(*argv, \"-serverinfo\") == 0) {\\r\\nchar *c;\\r\\nint start = 0;\\r\\nint len;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nc = *(++argv);\\r\\nserverinfo_types_count = 0;\\r\\nlen = strlen(c);\\r\\nfor (i = 0; i <= len; ++i) {\\r\\nif (i == len || c[i] == ',') {\\r\\nserverinfo_types[serverinfo_types_count]\\r\\n= atoi(c + start);\\r\\nserverinfo_types_count++;\\r\\nstart = i + 1;\\r\\n}\\r\\nif (serverinfo_types_count == MAX_SI_TYPES)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifdef FIONBIO\\r\\nelse if (strcmp(*argv, \"-nbio\") == 0) {\\r\\nc_nbio = 1;\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-starttls\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\n++argv;\\r\\nif (strcmp(*argv, \"smtp\") == 0)\\r\\nstarttls_proto = PROTO_SMTP;\\r\\nelse if (strcmp(*argv, \"pop3\") == 0)\\r\\nstarttls_proto = PROTO_POP3;\\r\\nelse if (strcmp(*argv, \"imap\") == 0)\\r\\nstarttls_proto = PROTO_IMAP;\\r\\nelse if (strcmp(*argv, \"ftp\") == 0)\\r\\nstarttls_proto = PROTO_FTP;\\r\\nelse if (strcmp(*argv, \"xmpp\") == 0)\\r\\nstarttls_proto = PROTO_XMPP;\\r\\nelse\\r\\ngoto bad;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine_id = *(++argv);\\r\\n} else if (strcmp(*argv, \"-ssl_client_engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nssl_client_engine_id = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninrand = *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nelse if (strcmp(*argv, \"-servername\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nservername = *(++argv);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_JPAKE\\r\\nelse if (strcmp(*argv, \"-jpake\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\njpake_secret = *++argv;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRTP\\r\\nelse if (strcmp(*argv, \"-use_srtp\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsrtp_profiles = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-keymatexport\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeymatexportlabel = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keymatexportlen\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeymatexportlen = atoi(*(++argv));\\r\\nif (keymatexportlen == 0)\\r\\ngoto bad;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadop = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badop) {\\r\\nbad:\\r\\nsc_usage();\\r\\ngoto end;\\r\\n}\\r\\n#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)\\r\\nif (jpake_secret) {\\r\\nif (psk_key) {\\r\\nBIO_printf(bio_err, \"Can't use JPAKE and PSK together\\n\");\\r\\ngoto end;\\r\\n}\\r\\npsk_identity = \"JPAKE\";\\r\\n}\\r\\n#endif\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nSSL_load_error_strings();\\r\\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\\r\\nnext_proto.status = -1;\\r\\nif (next_proto_neg_in) {\\r\\nnext_proto.data =\\r\\nnext_protos_parse(&next_proto.len, next_proto_neg_in);\\r\\nif (next_proto.data == NULL) {\\r\\nBIO_printf(bio_err, \"Error parsing -nextprotoneg argument\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nnext_proto.data = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine_id, 1);\\r\\nif (ssl_client_engine_id) {\\r\\nssl_client_engine = ENGINE_by_id(ssl_client_engine_id);\\r\\nif (!ssl_client_engine) {\\r\\nBIO_printf(bio_err, \"Error getting client auth engine\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (!app_passwd(bio_err, passarg, NULL, &pass, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (key_file == NULL)\\r\\nkey_file = cert_file;\\r\\nif (key_file) {\\r\\nkey = load_key(bio_err, key_file, key_format, 0, pass, e,\\r\\n\"client certificate private key file\");\\r\\nif (!key) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (cert_file) {\\r\\ncert = load_cert(bio_err, cert_file, cert_format,\\r\\nNULL, e, \"client certificate file\");\\r\\nif (!cert) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (chain_file) {\\r\\nchain = load_certs(bio_err, chain_file, FORMAT_PEM,\\r\\nNULL, e, \"client certificate chain\");\\r\\nif (!chain)\\r\\ngoto end;\\r\\n}\\r\\nif (crl_file) {\\r\\nX509_CRL *crl;\\r\\ncrl = load_crl(crl_file, crl_format);\\r\\nif (!crl) {\\r\\nBIO_puts(bio_err, \"Error loading CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ncrls = sk_X509_CRL_new_null();\\r\\nif (!crls || !sk_X509_CRL_push(crls, crl)) {\\r\\nBIO_puts(bio_err, \"Error adding CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nX509_CRL_free(crl);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!load_excert(&exc, bio_err))\\r\\ngoto end;\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL\\r\\n&& !RAND_status()) {\\r\\nBIO_printf(bio_err,\\r\\n\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nif (bio_c_out == NULL) {\\r\\nif (c_quiet && !c_debug) {\\r\\nbio_c_out = BIO_new(BIO_s_null());\\r\\nif (c_msg && !bio_c_msg)\\r\\nbio_c_msg = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n} else {\\r\\nif (bio_c_out == NULL)\\r\\nbio_c_out = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n}\\r\\n}\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nif (!app_passwd(bio_err, srppass, NULL, &srp_arg.srppassin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nctx = SSL_CTX_new(meth);\\r\\nif (ctx == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (vpm)\\r\\nSSL_CTX_set1_param(ctx, vpm);\\r\\nif (!args_ssl_call(ctx, bio_err, cctx, ssl_args, 1, no_jpake)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!ssl_load_stores(ctx, vfyCApath, vfyCAfile, chCApath, chCAfile,\\r\\ncrls, crl_download)) {\\r\\nBIO_printf(bio_err, \"Error loading store locations\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ssl_client_engine) {\\r\\nif (!SSL_CTX_set_client_cert_engine(ctx, ssl_client_engine)) {\\r\\nBIO_puts(bio_err, \"Error setting client auth engine\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nENGINE_free(ssl_client_engine);\\r\\ngoto end;\\r\\n}\\r\\nENGINE_free(ssl_client_engine);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\n# ifdef OPENSSL_NO_JPAKE\\r\\nif (psk_key != NULL)\\r\\n# else\\r\\nif (psk_key != NULL || jpake_secret)\\r\\n# endif\\r\\n{\\r\\nif (c_debug)\\r\\nBIO_printf(bio_c_out,\\r\\n\"PSK key given or JPAKE in use, setting client callback\\n\");\\r\\nSSL_CTX_set_psk_client_callback(ctx, psk_client_cb);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRTP\\r\\nif (srtp_profiles != NULL)\\r\\nSSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles);\\r\\n#endif\\r\\nif (exc)\\r\\nssl_ctx_set_excert(ctx, exc);\\r\\nif (socket_type == SOCK_DGRAM)\\r\\nSSL_CTX_set_read_ahead(ctx, 1);\\r\\n#if !defined(OPENSSL_NO_TLSEXT)\\r\\n# if !defined(OPENSSL_NO_NEXTPROTONEG)\\r\\nif (next_proto.data)\\r\\nSSL_CTX_set_next_proto_select_cb(ctx, next_proto_cb, &next_proto);\\r\\n# endif\\r\\nif (alpn_in) {\\r\\nunsigned short alpn_len;\\r\\nunsigned char *alpn = next_protos_parse(&alpn_len, alpn_in);\\r\\nif (alpn == NULL) {\\r\\nBIO_printf(bio_err, \"Error parsing -alpn argument\\n\");\\r\\ngoto end;\\r\\n}\\r\\nSSL_CTX_set_alpn_protos(ctx, alpn, alpn_len);\\r\\nOPENSSL_free(alpn);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nfor (i = 0; i < serverinfo_types_count; i++) {\\r\\nSSL_CTX_add_client_custom_ext(ctx,\\r\\nserverinfo_types[i],\\r\\nNULL, NULL, NULL,\\r\\nserverinfo_cli_parse_cb, NULL);\\r\\n}\\r\\n#endif\\r\\nif (state)\\r\\nSSL_CTX_set_info_callback(ctx, apps_ssl_info_callback);\\r\\n#if 0\\r\\nelse\\r\\nSSL_CTX_set_cipher_list(ctx, getenv(\"SSL_CIPHER\"));\\r\\n#endif\\r\\nSSL_CTX_set_verify(ctx, verify, verify_callback);\\r\\nif ((!SSL_CTX_load_verify_locations(ctx, CAfile, CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(ctx))) {\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nssl_ctx_add_crls(ctx, crls, crl_download);\\r\\nif (!set_cert_key_stuff(ctx, cert, key, chain, build_chain))\\r\\ngoto end;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (servername != NULL) {\\r\\ntlsextcbp.biodebug = bio_err;\\r\\nSSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);\\r\\nSSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);\\r\\n}\\r\\n# ifndef OPENSSL_NO_SRP\\r\\nif (srp_arg.srplogin) {\\r\\nif (!srp_lateuser && !SSL_CTX_set_srp_username(ctx, srp_arg.srplogin)) {\\r\\nBIO_printf(bio_err, \"Unable to set SRP username\\n\");\\r\\ngoto end;\\r\\n}\\r\\nsrp_arg.msg = c_msg;\\r\\nsrp_arg.debug = c_debug;\\r\\nSSL_CTX_set_srp_cb_arg(ctx, &srp_arg);\\r\\nSSL_CTX_set_srp_client_pwd_callback(ctx, ssl_give_srp_client_pwd_cb);\\r\\nSSL_CTX_set_srp_strength(ctx, srp_arg.strength);\\r\\nif (c_msg || c_debug || srp_arg.amp == 0)\\r\\nSSL_CTX_set_srp_verify_param_callback(ctx,\\r\\nssl_srp_verify_param_cb);\\r\\n}\\r\\n# endif\\r\\n#endif\\r\\ncon = SSL_new(ctx);\\r\\nif (sess_in) {\\r\\nSSL_SESSION *sess;\\r\\nBIO *stmp = BIO_new_file(sess_in, \"r\");\\r\\nif (!stmp) {\\r\\nBIO_printf(bio_err, \"Can't open session file %s\\n\", sess_in);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nsess = PEM_read_bio_SSL_SESSION(stmp, NULL, 0, NULL);\\r\\nBIO_free(stmp);\\r\\nif (!sess) {\\r\\nBIO_printf(bio_err, \"Can't open session file %s\\n\", sess_in);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nSSL_set_session(con, sess);\\r\\nSSL_SESSION_free(sess);\\r\\n}\\r\\nif (fallback_scsv)\\r\\nSSL_set_mode(con, SSL_MODE_SEND_FALLBACK_SCSV);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (servername != NULL) {\\r\\nif (!SSL_set_tlsext_host_name(con, servername)) {\\r\\nBIO_printf(bio_err, \"Unable to set TLS servername extension.\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (con && (kctx = kssl_ctx_new()) != NULL) {\\r\\nSSL_set0_kssl_ctx(con, kctx);\\r\\nkssl_ctx_setstring(kctx, KSSL_SERVER, host);\\r\\n}\\r\\n#endif\\r\\n#if 0\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nSSL_set_tlsext_opaque_prf_input(con, \"Test client\", 11);\\r\\n# endif\\r\\n#endif\\r\\nre_start:\\r\\nif (init_client(&s, host, port, socket_type) == 0) {\\r\\nBIO_printf(bio_err, \"connect:errno=%d\\n\", get_last_socket_error());\\r\\nSHUTDOWN(s);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_c_out, \"CONNECTED(%08X)\\n\", s);\\r\\n#ifdef FIONBIO\\r\\nif (c_nbio) {\\r\\nunsigned long l = 1;\\r\\nBIO_printf(bio_c_out, \"turning on non blocking io\\n\");\\r\\nif (BIO_socket_ioctl(s, FIONBIO, &l) < 0) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (c_Pause & 0x01)\\r\\nSSL_set_debug(con, 1);\\r\\nif (socket_type == SOCK_DGRAM) {\\r\\nsbio = BIO_new_dgram(s, BIO_NOCLOSE);\\r\\nif (getsockname(s, &peer, (void *)&peerlen) < 0) {\\r\\nBIO_printf(bio_err, \"getsockname:errno=%d\\n\",\\r\\nget_last_socket_error());\\r\\nSHUTDOWN(s);\\r\\ngoto end;\\r\\n}\\r\\n(void)BIO_ctrl_set_connected(sbio, 1, &peer);\\r\\nif (enable_timeouts) {\\r\\ntimeout.tv_sec = 0;\\r\\ntimeout.tv_usec = DGRAM_RCV_TIMEOUT;\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);\\r\\ntimeout.tv_sec = 0;\\r\\ntimeout.tv_usec = DGRAM_SND_TIMEOUT;\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);\\r\\n}\\r\\nif (socket_mtu) {\\r\\nif (socket_mtu < DTLS_get_link_min_mtu(con)) {\\r\\nBIO_printf(bio_err, \"MTU too small. Must be at least %ld\\n\",\\r\\nDTLS_get_link_min_mtu(con));\\r\\nBIO_free(sbio);\\r\\ngoto shut;\\r\\n}\\r\\nSSL_set_options(con, SSL_OP_NO_QUERY_MTU);\\r\\nif (!DTLS_set_link_mtu(con, socket_mtu)) {\\r\\nBIO_printf(bio_err, \"Failed to set MTU\\n\");\\r\\nBIO_free(sbio);\\r\\ngoto shut;\\r\\n}\\r\\n} else\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);\\r\\n} else\\r\\nsbio = BIO_new_socket(s, BIO_NOCLOSE);\\r\\nif (nbio_test) {\\r\\nBIO *test;\\r\\ntest = BIO_new(BIO_f_nbio_test());\\r\\nsbio = BIO_push(test, sbio);\\r\\n}\\r\\nif (c_debug) {\\r\\nSSL_set_debug(con, 1);\\r\\nBIO_set_callback(sbio, bio_dump_callback);\\r\\nBIO_set_callback_arg(sbio, (char *)bio_c_out);\\r\\n}\\r\\nif (c_msg) {\\r\\n#ifndef OPENSSL_NO_SSL_TRACE\\r\\nif (c_msg == 2)\\r\\nSSL_set_msg_callback(con, SSL_trace);\\r\\nelse\\r\\n#endif\\r\\nSSL_set_msg_callback(con, msg_cb);\\r\\nSSL_set_msg_callback_arg(con, bio_c_msg ? bio_c_msg : bio_c_out);\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (c_tlsextdebug) {\\r\\nSSL_set_tlsext_debug_callback(con, tlsext_cb);\\r\\nSSL_set_tlsext_debug_arg(con, bio_c_out);\\r\\n}\\r\\nif (c_status_req) {\\r\\nSSL_set_tlsext_status_type(con, TLSEXT_STATUSTYPE_ocsp);\\r\\nSSL_CTX_set_tlsext_status_cb(ctx, ocsp_resp_cb);\\r\\nSSL_CTX_set_tlsext_status_arg(ctx, bio_c_out);\\r\\n# if 0\\r\\n{\\r\\nSTACK_OF(OCSP_RESPID) *ids = sk_OCSP_RESPID_new_null();\\r\\nOCSP_RESPID *id = OCSP_RESPID_new();\\r\\nid->value.byKey = ASN1_OCTET_STRING_new();\\r\\nid->type = V_OCSP_RESPID_KEY;\\r\\nASN1_STRING_set(id->value.byKey, \"Hello World\", -1);\\r\\nsk_OCSP_RESPID_push(ids, id);\\r\\nSSL_set_tlsext_status_ids(con, ids);\\r\\n}\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_JPAKE\\r\\nif (jpake_secret)\\r\\njpake_client_auth(bio_c_out, sbio, jpake_secret);\\r\\n#endif\\r\\nSSL_set_bio(con, sbio, sbio);\\r\\nSSL_set_connect_state(con);\\r\\nwidth = SSL_get_fd(con) + 1;\\r\\nread_tty = 1;\\r\\nwrite_tty = 0;\\r\\ntty_on = 0;\\r\\nread_ssl = 1;\\r\\nwrite_ssl = 1;\\r\\ncbuf_len = 0;\\r\\ncbuf_off = 0;\\r\\nsbuf_len = 0;\\r\\nsbuf_off = 0;\\r\\nif (starttls_proto == PROTO_SMTP) {\\r\\nint foundit = 0;\\r\\nBIO *fbio = BIO_new(BIO_f_buffer());\\r\\nBIO_push(fbio, sbio);\\r\\ndo {\\r\\nmbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\\r\\n}\\r\\nwhile (mbuf_len > 3 && mbuf[3] == '-');\\r\\nBIO_printf(fbio, \"EHLO openssl.client.net\\r\\n\");\\r\\n(void)BIO_flush(fbio);\\r\\ndo {\\r\\nmbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\\r\\nif (strstr(mbuf, \"STARTTLS\"))\\r\\nfoundit = 1;\\r\\n}\\r\\nwhile (mbuf_len > 3 && mbuf[3] == '-');\\r\\n(void)BIO_flush(fbio);\\r\\nBIO_pop(fbio);\\r\\nBIO_free(fbio);\\r\\nif (!foundit)\\r\\nBIO_printf(bio_err,\\r\\n\"didn't found starttls in server response,\"\\r\\n\" try anyway...\\n\");\\r\\nBIO_printf(sbio, \"STARTTLS\\r\\n\");\\r\\nBIO_read(sbio, sbuf, BUFSIZZ);\\r\\n} else if (starttls_proto == PROTO_POP3) {\\r\\nBIO_read(sbio, mbuf, BUFSIZZ);\\r\\nBIO_printf(sbio, \"STLS\\r\\n\");\\r\\nBIO_read(sbio, sbuf, BUFSIZZ);\\r\\n} else if (starttls_proto == PROTO_IMAP) {\\r\\nint foundit = 0;\\r\\nBIO *fbio = BIO_new(BIO_f_buffer());\\r\\nBIO_push(fbio, sbio);\\r\\nBIO_gets(fbio, mbuf, BUFSIZZ);\\r\\nBIO_printf(fbio, \". CAPABILITY\\r\\n\");\\r\\n(void)BIO_flush(fbio);\\r\\ndo {\\r\\nmbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\\r\\nif (strstr(mbuf, \"STARTTLS\"))\\r\\nfoundit = 1;\\r\\n}\\r\\nwhile (mbuf_len > 3 && mbuf[0] != '.');\\r\\n(void)BIO_flush(fbio);\\r\\nBIO_pop(fbio);\\r\\nBIO_free(fbio);\\r\\nif (!foundit)\\r\\nBIO_printf(bio_err,\\r\\n\"didn't found STARTTLS in server response,\"\\r\\n\" try anyway...\\n\");\\r\\nBIO_printf(sbio, \". STARTTLS\\r\\n\");\\r\\nBIO_read(sbio, sbuf, BUFSIZZ);\\r\\n} else if (starttls_proto == PROTO_FTP) {\\r\\nBIO *fbio = BIO_new(BIO_f_buffer());\\r\\nBIO_push(fbio, sbio);\\r\\ndo {\\r\\nmbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\\r\\n}\\r\\nwhile (mbuf_len > 3 && mbuf[3] == '-');\\r\\n(void)BIO_flush(fbio);\\r\\nBIO_pop(fbio);\\r\\nBIO_free(fbio);\\r\\nBIO_printf(sbio, \"AUTH TLS\\r\\n\");\\r\\nBIO_read(sbio, sbuf, BUFSIZZ);\\r\\n}\\r\\nif (starttls_proto == PROTO_XMPP) {\\r\\nint seen = 0;\\r\\nBIO_printf(sbio, \"<stream:stream \"\\r\\n\"xmlns:stream='http://etherx.jabber.org/streams' \"\\r\\n\"xmlns='jabber:client' to='%s' version='1.0'>\", host);\\r\\nseen = BIO_read(sbio, mbuf, BUFSIZZ);\\r\\nmbuf[seen] = 0;\\r\\nwhile (!strstr\\r\\n(mbuf, \"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'\")) {\\r\\nif (strstr(mbuf, \"/stream:features>\"))\\r\\ngoto shut;\\r\\nseen = BIO_read(sbio, mbuf, BUFSIZZ);\\r\\nmbuf[seen] = 0;\\r\\n}\\r\\nBIO_printf(sbio,\\r\\n\"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\");\\r\\nseen = BIO_read(sbio, sbuf, BUFSIZZ);\\r\\nsbuf[seen] = 0;\\r\\nif (!strstr(sbuf, \"<proceed\"))\\r\\ngoto shut;\\r\\nmbuf[0] = 0;\\r\\n}\\r\\nfor (;;) {\\r\\nFD_ZERO(&readfds);\\r\\nFD_ZERO(&writefds);\\r\\nif ((SSL_version(con) == DTLS1_VERSION) &&\\r\\nDTLSv1_get_timeout(con, &timeout))\\r\\ntimeoutp = &timeout;\\r\\nelse\\r\\ntimeoutp = NULL;\\r\\nif (SSL_in_init(con) && !SSL_total_renegotiations(con)) {\\r\\nin_init = 1;\\r\\ntty_on = 0;\\r\\n} else {\\r\\ntty_on = 1;\\r\\nif (in_init) {\\r\\nin_init = 0;\\r\\n#if 0\\r\\n# ifndef OPENSSL_NO_TLSEXT\\r\\nif (servername != NULL && !SSL_session_reused(con)) {\\r\\nBIO_printf(bio_c_out,\\r\\n\"Server did %sacknowledge servername extension.\\n\",\\r\\ntlsextcbp.ack ? \"\" : \"not \");\\r\\n}\\r\\n# endif\\r\\n#endif\\r\\nif (sess_out) {\\r\\nBIO *stmp = BIO_new_file(sess_out, \"w\");\\r\\nif (stmp) {\\r\\nPEM_write_bio_SSL_SESSION(stmp, SSL_get_session(con));\\r\\nBIO_free(stmp);\\r\\n} else\\r\\nBIO_printf(bio_err, \"Error writing session file %s\\n\",\\r\\nsess_out);\\r\\n}\\r\\nif (c_brief) {\\r\\nBIO_puts(bio_err, \"CONNECTION ESTABLISHED\\n\");\\r\\nprint_ssl_summary(bio_err, con);\\r\\n}\\r\\nprint_stuff(bio_c_out, con, full_log);\\r\\nif (full_log > 0)\\r\\nfull_log--;\\r\\nif (starttls_proto) {\\r\\nBIO_printf(bio_err, \"%s\", mbuf);\\r\\nstarttls_proto = PROTO_OFF;\\r\\n}\\r\\nif (reconnect) {\\r\\nreconnect--;\\r\\nBIO_printf(bio_c_out,\\r\\n\"drop connection and then reconnect\\n\");\\r\\nSSL_shutdown(con);\\r\\nSSL_set_connect_state(con);\\r\\nSHUTDOWN(SSL_get_fd(con));\\r\\ngoto re_start;\\r\\n}\\r\\n}\\r\\n}\\r\\nssl_pending = read_ssl && SSL_pending(con);\\r\\nif (!ssl_pending) {\\r\\n#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE) && !defined (OPENSSL_SYS_BEOS_R5)\\r\\nif (tty_on) {\\r\\nif (read_tty)\\r\\nopenssl_fdset(fileno(stdin), &readfds);\\r\\nif (write_tty)\\r\\nopenssl_fdset(fileno(stdout), &writefds);\\r\\n}\\r\\nif (read_ssl)\\r\\nopenssl_fdset(SSL_get_fd(con), &readfds);\\r\\nif (write_ssl)\\r\\nopenssl_fdset(SSL_get_fd(con), &writefds);\\r\\n#else\\r\\nif (!tty_on || !write_tty) {\\r\\nif (read_ssl)\\r\\nopenssl_fdset(SSL_get_fd(con), &readfds);\\r\\nif (write_ssl)\\r\\nopenssl_fdset(SSL_get_fd(con), &writefds);\\r\\n}\\r\\n#endif\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)\\r\\ni = 0;\\r\\nif (!write_tty) {\\r\\nif (read_tty) {\\r\\ntv.tv_sec = 1;\\r\\ntv.tv_usec = 0;\\r\\ni = select(width, (void *)&readfds, (void *)&writefds,\\r\\nNULL, &tv);\\r\\n# if defined(OPENSSL_SYS_WINCE) || defined(OPENSSL_SYS_MSDOS)\\r\\nif (!i && (!_kbhit() || !read_tty))\\r\\ncontinue;\\r\\n# else\\r\\nif (!i && (!((_kbhit())\\r\\n|| (WAIT_OBJECT_0 ==\\r\\nWaitForSingleObject(GetStdHandle\\r\\n(STD_INPUT_HANDLE),\\r\\n0)))\\r\\n|| !read_tty))\\r\\ncontinue;\\r\\n# endif\\r\\n} else\\r\\ni = select(width, (void *)&readfds, (void *)&writefds,\\r\\nNULL, timeoutp);\\r\\n}\\r\\n#elif defined(OPENSSL_SYS_NETWARE)\\r\\nif (!write_tty) {\\r\\nif (read_tty) {\\r\\ntv.tv_sec = 1;\\r\\ntv.tv_usec = 0;\\r\\ni = select(width, (void *)&readfds, (void *)&writefds,\\r\\nNULL, &tv);\\r\\n} else\\r\\ni = select(width, (void *)&readfds, (void *)&writefds,\\r\\nNULL, timeoutp);\\r\\n}\\r\\n#elif defined(OPENSSL_SYS_BEOS_R5)\\r\\ni = 0;\\r\\nstdin_set = 0;\\r\\n(void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);\\r\\nif (!write_tty) {\\r\\nif (read_tty) {\\r\\ntv.tv_sec = 1;\\r\\ntv.tv_usec = 0;\\r\\ni = select(width, (void *)&readfds, (void *)&writefds,\\r\\nNULL, &tv);\\r\\nif (read(fileno(stdin), sbuf, 0) >= 0)\\r\\nstdin_set = 1;\\r\\nif (!i && (stdin_set != 1 || !read_tty))\\r\\ncontinue;\\r\\n} else\\r\\ni = select(width, (void *)&readfds, (void *)&writefds,\\r\\nNULL, timeoutp);\\r\\n}\\r\\n(void)fcntl(fileno(stdin), F_SETFL, 0);\\r\\n#else\\r\\ni = select(width, (void *)&readfds, (void *)&writefds,\\r\\nNULL, timeoutp);\\r\\n#endif\\r\\nif (i < 0) {\\r\\nBIO_printf(bio_err, \"bad select %d\\n\",\\r\\nget_last_socket_error());\\r\\ngoto shut;\\r\\n}\\r\\n}\\r\\nif ((SSL_version(con) == DTLS1_VERSION)\\r\\n&& DTLSv1_handle_timeout(con) > 0) {\\r\\nBIO_printf(bio_err, \"TIMEOUT occured\\n\");\\r\\n}\\r\\nif (!ssl_pending && FD_ISSET(SSL_get_fd(con), &writefds)) {\\r\\nk = SSL_write(con, &(cbuf[cbuf_off]), (unsigned int)cbuf_len);\\r\\nswitch (SSL_get_error(con, k)) {\\r\\ncase SSL_ERROR_NONE:\\r\\ncbuf_off += k;\\r\\ncbuf_len -= k;\\r\\nif (k <= 0)\\r\\ngoto end;\\r\\nif (cbuf_len <= 0) {\\r\\nread_tty = 1;\\r\\nwrite_ssl = 0;\\r\\n} else {\\r\\nread_tty = 0;\\r\\nwrite_ssl = 1;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_printf(bio_c_out, \"write W BLOCK\\n\");\\r\\nwrite_ssl = 1;\\r\\nread_tty = 0;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_printf(bio_c_out, \"write R BLOCK\\n\");\\r\\nwrite_tty = 0;\\r\\nread_ssl = 1;\\r\\nwrite_ssl = 0;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_c_out, \"write X BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nif (cbuf_len != 0) {\\r\\nBIO_printf(bio_c_out, \"shutdown\\n\");\\r\\nret = 0;\\r\\ngoto shut;\\r\\n} else {\\r\\nread_tty = 1;\\r\\nwrite_ssl = 0;\\r\\nbreak;\\r\\n}\\r\\ncase SSL_ERROR_SYSCALL:\\r\\nif ((k != 0) || (cbuf_len != 0)) {\\r\\nBIO_printf(bio_err, \"write:errno=%d\\n\",\\r\\nget_last_socket_error());\\r\\ngoto shut;\\r\\n} else {\\r\\nread_tty = 1;\\r\\nwrite_ssl = 0;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_ERROR_SSL:\\r\\nERR_print_errors(bio_err);\\r\\ngoto shut;\\r\\n}\\r\\n}\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)\\r\\nelse if (!ssl_pending && write_tty)\\r\\n#else\\r\\nelse if (!ssl_pending && FD_ISSET(fileno(stdout), &writefds))\\r\\n#endif\\r\\n{\\r\\n#ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(&(sbuf[sbuf_off]), &(sbuf[sbuf_off]), sbuf_len);\\r\\n#endif\\r\\ni = raw_write_stdout(&(sbuf[sbuf_off]), sbuf_len);\\r\\nif (i <= 0) {\\r\\nBIO_printf(bio_c_out, \"DONE\\n\");\\r\\nret = 0;\\r\\ngoto shut;\\r\\n}\\r\\nsbuf_len -= i;;\\r\\nsbuf_off += i;\\r\\nif (sbuf_len <= 0) {\\r\\nread_ssl = 1;\\r\\nwrite_tty = 0;\\r\\n}\\r\\n} else if (ssl_pending || FD_ISSET(SSL_get_fd(con), &readfds)) {\\r\\n#ifdef RENEG\\r\\n{\\r\\nstatic int iiii;\\r\\nif (++iiii == 52) {\\r\\nSSL_renegotiate(con);\\r\\niiii = 0;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#if 1\\r\\nk = SSL_read(con, sbuf, 1024 );\\r\\n#else\\r\\nk = SSL_read(con, sbuf, 16);\\r\\n{\\r\\nchar zbuf[10240];\\r\\nprintf(\"read=%d pending=%d peek=%d\\n\", k, SSL_pending(con),\\r\\nSSL_peek(con, zbuf, 10240));\\r\\n}\\r\\n#endif\\r\\nswitch (SSL_get_error(con, k)) {\\r\\ncase SSL_ERROR_NONE:\\r\\nif (k <= 0)\\r\\ngoto end;\\r\\nsbuf_off = 0;\\r\\nsbuf_len = k;\\r\\nread_ssl = 0;\\r\\nwrite_tty = 1;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\nBIO_printf(bio_c_out, \"read W BLOCK\\n\");\\r\\nwrite_ssl = 1;\\r\\nread_tty = 0;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_printf(bio_c_out, \"read R BLOCK\\n\");\\r\\nwrite_tty = 0;\\r\\nread_ssl = 1;\\r\\nif ((read_tty == 0) && (write_ssl == 0))\\r\\nwrite_ssl = 1;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_c_out, \"read X BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\nret = get_last_socket_error();\\r\\nif (c_brief)\\r\\nBIO_puts(bio_err, \"CONNECTION CLOSED BY SERVER\\n\");\\r\\nelse\\r\\nBIO_printf(bio_err, \"read:errno=%d\\n\", ret);\\r\\ngoto shut;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nBIO_printf(bio_c_out, \"closed\\n\");\\r\\nret = 0;\\r\\ngoto shut;\\r\\ncase SSL_ERROR_SSL:\\r\\nERR_print_errors(bio_err);\\r\\ngoto shut;\\r\\n}\\r\\n}\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)\\r\\n# if defined(OPENSSL_SYS_WINCE) || defined(OPENSSL_SYS_MSDOS)\\r\\nelse if (_kbhit())\\r\\n# else\\r\\nelse if ((_kbhit())\\r\\n|| (WAIT_OBJECT_0 ==\\r\\nWaitForSingleObject(GetStdHandle(STD_INPUT_HANDLE), 0)))\\r\\n# endif\\r\\n#elif defined (OPENSSL_SYS_NETWARE)\\r\\nelse if (_kbhit())\\r\\n#elif defined(OPENSSL_SYS_BEOS_R5)\\r\\nelse if (stdin_set)\\r\\n#else\\r\\nelse if (FD_ISSET(fileno(stdin), &readfds))\\r\\n#endif\\r\\n{\\r\\nif (crlf) {\\r\\nint j, lf_num;\\r\\ni = raw_read_stdin(cbuf, BUFSIZZ / 2);\\r\\nlf_num = 0;\\r\\nfor (j = 0; j < i; j++)\\r\\nif (cbuf[j] == '\\n')\\r\\nlf_num++;\\r\\nfor (j = i - 1; j >= 0; j--) {\\r\\ncbuf[j + lf_num] = cbuf[j];\\r\\nif (cbuf[j] == '\\n') {\\r\\nlf_num--;\\r\\ni++;\\r\\ncbuf[j + lf_num] = '\\r';\\r\\n}\\r\\n}\\r\\nassert(lf_num == 0);\\r\\n} else\\r\\ni = raw_read_stdin(cbuf, BUFSIZZ);\\r\\nif ((!c_ign_eof) && ((i <= 0) || (cbuf[0] == 'Q'))) {\\r\\nBIO_printf(bio_err, \"DONE\\n\");\\r\\nret = 0;\\r\\ngoto shut;\\r\\n}\\r\\nif ((!c_ign_eof) && (cbuf[0] == 'R')) {\\r\\nBIO_printf(bio_err, \"RENEGOTIATING\\n\");\\r\\nSSL_renegotiate(con);\\r\\ncbuf_len = 0;\\r\\n}\\r\\n#ifndef OPENSSL_NO_HEARTBEATS\\r\\nelse if ((!c_ign_eof) && (cbuf[0] == 'B')) {\\r\\nBIO_printf(bio_err, \"HEARTBEATING\\n\");\\r\\nSSL_heartbeat(con);\\r\\ncbuf_len = 0;\\r\\n}\\r\\n#endif\\r\\nelse {\\r\\ncbuf_len = i;\\r\\ncbuf_off = 0;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(cbuf, cbuf, i);\\r\\n#endif\\r\\n}\\r\\nwrite_ssl = 1;\\r\\nread_tty = 0;\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nshut:\\r\\nif (in_init)\\r\\nprint_stuff(bio_c_out, con, full_log);\\r\\nSSL_shutdown(con);\\r\\nSHUTDOWN(SSL_get_fd(con));\\r\\nend:\\r\\nif (con != NULL) {\\r\\nif (prexit != 0)\\r\\nprint_stuff(bio_c_out, con, 1);\\r\\nSSL_free(con);\\r\\n}\\r\\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\\r\\nif (next_proto.data)\\r\\nOPENSSL_free(next_proto.data);\\r\\n#endif\\r\\nif (ctx != NULL)\\r\\nSSL_CTX_free(ctx);\\r\\nif (cert)\\r\\nX509_free(cert);\\r\\nif (crls)\\r\\nsk_X509_CRL_pop_free(crls, X509_CRL_free);\\r\\nif (key)\\r\\nEVP_PKEY_free(key);\\r\\nif (chain)\\r\\nsk_X509_pop_free(chain, X509_free);\\r\\nif (pass)\\r\\nOPENSSL_free(pass);\\r\\nif (vpm)\\r\\nX509_VERIFY_PARAM_free(vpm);\\r\\nssl_excert_free(exc);\\r\\nif (ssl_args)\\r\\nsk_OPENSSL_STRING_free(ssl_args);\\r\\nif (cctx)\\r\\nSSL_CONF_CTX_free(cctx);\\r\\n#ifndef OPENSSL_NO_JPAKE\\r\\nif (jpake_secret && psk_key)\\r\\nOPENSSL_free(psk_key);\\r\\n#endif\\r\\nif (cbuf != NULL) {\\r\\nOPENSSL_cleanse(cbuf, BUFSIZZ);\\r\\nOPENSSL_free(cbuf);\\r\\n}\\r\\nif (sbuf != NULL) {\\r\\nOPENSSL_cleanse(sbuf, BUFSIZZ);\\r\\nOPENSSL_free(sbuf);\\r\\n}\\r\\nif (mbuf != NULL) {\\r\\nOPENSSL_cleanse(mbuf, BUFSIZZ);\\r\\nOPENSSL_free(mbuf);\\r\\n}\\r\\nif (bio_c_out != NULL) {\\r\\nBIO_free(bio_c_out);\\r\\nbio_c_out = NULL;\\r\\n}\\r\\nif (bio_c_msg != NULL) {\\r\\nBIO_free(bio_c_msg);\\r\\nbio_c_msg = NULL;\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic void print_stuff(BIO *bio, SSL *s, int full)\\r\\n{\\r\\nX509 *peer = NULL;\\r\\nchar *p;\\r\\nstatic const char *space = \" \";\\r\\nchar buf[BUFSIZ];\\r\\nSTACK_OF(X509) *sk;\\r\\nSTACK_OF(X509_NAME) *sk2;\\r\\nconst SSL_CIPHER *c;\\r\\nX509_NAME *xn;\\r\\nint j, i;\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nconst COMP_METHOD *comp, *expansion;\\r\\n#endif\\r\\nunsigned char *exportedkeymat;\\r\\nif (full) {\\r\\nint got_a_chain = 0;\\r\\nsk = SSL_get_peer_cert_chain(s);\\r\\nif (sk != NULL) {\\r\\ngot_a_chain = 1;\\r\\nBIO_printf(bio, \"---\\nCertificate chain\\n\");\\r\\nfor (i = 0; i < sk_X509_num(sk); i++) {\\r\\nX509_NAME_oneline(X509_get_subject_name(sk_X509_value(sk, i)),\\r\\nbuf, sizeof buf);\\r\\nBIO_printf(bio, \"%2d s:%s\\n\", i, buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(sk_X509_value(sk, i)),\\r\\nbuf, sizeof buf);\\r\\nBIO_printf(bio, \" i:%s\\n\", buf);\\r\\nif (c_showcerts)\\r\\nPEM_write_bio_X509(bio, sk_X509_value(sk, i));\\r\\n}\\r\\n}\\r\\nBIO_printf(bio, \"---\\n\");\\r\\npeer = SSL_get_peer_certificate(s);\\r\\nif (peer != NULL) {\\r\\nBIO_printf(bio, \"Server certificate\\n\");\\r\\nif (!(c_showcerts && got_a_chain))\\r\\nPEM_write_bio_X509(bio, peer);\\r\\nX509_NAME_oneline(X509_get_subject_name(peer), buf, sizeof buf);\\r\\nBIO_printf(bio, \"subject=%s\\n\", buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(peer), buf, sizeof buf);\\r\\nBIO_printf(bio, \"issuer=%s\\n\", buf);\\r\\n} else\\r\\nBIO_printf(bio, \"no peer certificate available\\n\");\\r\\nsk2 = SSL_get_client_CA_list(s);\\r\\nif ((sk2 != NULL) && (sk_X509_NAME_num(sk2) > 0)) {\\r\\nBIO_printf(bio, \"---\\nAcceptable client certificate CA names\\n\");\\r\\nfor (i = 0; i < sk_X509_NAME_num(sk2); i++) {\\r\\nxn = sk_X509_NAME_value(sk2, i);\\r\\nX509_NAME_oneline(xn, buf, sizeof(buf));\\r\\nBIO_write(bio, buf, strlen(buf));\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\n}\\r\\n} else {\\r\\nBIO_printf(bio, \"---\\nNo client certificate CA names sent\\n\");\\r\\n}\\r\\np = SSL_get_shared_ciphers(s, buf, sizeof buf);\\r\\nif (p != NULL) {\\r\\nBIO_printf(bio,\\r\\n\"---\\nCiphers common between both SSL endpoints:\\n\");\\r\\nj = i = 0;\\r\\nwhile (*p) {\\r\\nif (*p == ':') {\\r\\nBIO_write(bio, space, 15 - j % 25);\\r\\ni++;\\r\\nj = 0;\\r\\nBIO_write(bio, ((i % 3) ? \" \" : \"\\n\"), 1);\\r\\n} else {\\r\\nBIO_write(bio, p, 1);\\r\\nj++;\\r\\n}\\r\\np++;\\r\\n}\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\n}\\r\\nssl_print_sigalgs(bio, s);\\r\\nssl_print_tmp_key(bio, s);\\r\\nBIO_printf(bio,\\r\\n\"---\\nSSL handshake has read %ld bytes and written %ld bytes\\n\",\\r\\nBIO_number_read(SSL_get_rbio(s)),\\r\\nBIO_number_written(SSL_get_wbio(s)));\\r\\n}\\r\\nBIO_printf(bio, (SSL_cache_hit(s) ? \"---\\nReused, \" : \"---\\nNew, \"));\\r\\nc = SSL_get_current_cipher(s);\\r\\nBIO_printf(bio, \"%s, Cipher is %s\\n\",\\r\\nSSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c));\\r\\nif (peer != NULL) {\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = X509_get_pubkey(peer);\\r\\nBIO_printf(bio, \"Server public key is %d bit\\n\",\\r\\nEVP_PKEY_bits(pktmp));\\r\\nEVP_PKEY_free(pktmp);\\r\\n}\\r\\nBIO_printf(bio, \"Secure Renegotiation IS%s supported\\n\",\\r\\nSSL_get_secure_renegotiation_support(s) ? \"\" : \" NOT\");\\r\\n#ifndef OPENSSL_NO_COMP\\r\\ncomp = SSL_get_current_compression(s);\\r\\nexpansion = SSL_get_current_expansion(s);\\r\\nBIO_printf(bio, \"Compression: %s\\n\",\\r\\ncomp ? SSL_COMP_get_name(comp) : \"NONE\");\\r\\nBIO_printf(bio, \"Expansion: %s\\n\",\\r\\nexpansion ? SSL_COMP_get_name(expansion) : \"NONE\");\\r\\n#endif\\r\\n#ifdef SSL_DEBUG\\r\\n{\\r\\nint sock;\\r\\nstruct sockaddr_in ladd;\\r\\nsocklen_t ladd_size = sizeof(ladd);\\r\\nsock = SSL_get_fd(s);\\r\\ngetsockname(sock, (struct sockaddr *)&ladd, &ladd_size);\\r\\nBIO_printf(bio_c_out, \"LOCAL PORT is %u\\n\", ntohs(ladd.sin_port));\\r\\n}\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_TLSEXT)\\r\\n# if !defined(OPENSSL_NO_NEXTPROTONEG)\\r\\nif (next_proto.status != -1) {\\r\\nconst unsigned char *proto;\\r\\nunsigned int proto_len;\\r\\nSSL_get0_next_proto_negotiated(s, &proto, &proto_len);\\r\\nBIO_printf(bio, \"Next protocol: (%d) \", next_proto.status);\\r\\nBIO_write(bio, proto, proto_len);\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\n}\\r\\n# endif\\r\\n{\\r\\nconst unsigned char *proto;\\r\\nunsigned int proto_len;\\r\\nSSL_get0_alpn_selected(s, &proto, &proto_len);\\r\\nif (proto_len > 0) {\\r\\nBIO_printf(bio, \"ALPN protocol: \");\\r\\nBIO_write(bio, proto, proto_len);\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\n} else\\r\\nBIO_printf(bio, \"No ALPN negotiated\\n\");\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRTP\\r\\n{\\r\\nSRTP_PROTECTION_PROFILE *srtp_profile =\\r\\nSSL_get_selected_srtp_profile(s);\\r\\nif (srtp_profile)\\r\\nBIO_printf(bio, \"SRTP Extension negotiated, profile=%s\\n\",\\r\\nsrtp_profile->name);\\r\\n}\\r\\n#endif\\r\\nSSL_SESSION_print(bio, SSL_get_session(s));\\r\\nif (keymatexportlabel != NULL) {\\r\\nBIO_printf(bio, \"Keying material exporter:\\n\");\\r\\nBIO_printf(bio, \" Label: '%s'\\n\", keymatexportlabel);\\r\\nBIO_printf(bio, \" Length: %i bytes\\n\", keymatexportlen);\\r\\nexportedkeymat = OPENSSL_malloc(keymatexportlen);\\r\\nif (exportedkeymat != NULL) {\\r\\nif (!SSL_export_keying_material(s, exportedkeymat,\\r\\nkeymatexportlen,\\r\\nkeymatexportlabel,\\r\\nstrlen(keymatexportlabel),\\r\\nNULL, 0, 0)) {\\r\\nBIO_printf(bio, \" Error\\n\");\\r\\n} else {\\r\\nBIO_printf(bio, \" Keying material: \");\\r\\nfor (i = 0; i < keymatexportlen; i++)\\r\\nBIO_printf(bio, \"%02X\", exportedkeymat[i]);\\r\\nBIO_printf(bio, \"\\n\");\\r\\n}\\r\\nOPENSSL_free(exportedkeymat);\\r\\n}\\r\\n}\\r\\nBIO_printf(bio, \"---\\n\");\\r\\nif (peer != NULL)\\r\\nX509_free(peer);\\r\\n(void)BIO_flush(bio);\\r\\n}\\r\\nstatic int ocsp_resp_cb(SSL *s, void *arg)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nint len;\\r\\nOCSP_RESPONSE *rsp;\\r\\nlen = SSL_get_tlsext_status_ocsp_resp(s, &p);\\r\\nBIO_puts(arg, \"OCSP response: \");\\r\\nif (!p) {\\r\\nBIO_puts(arg, \"no response sent\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nrsp = d2i_OCSP_RESPONSE(NULL, &p, len);\\r\\nif (!rsp) {\\r\\nBIO_puts(arg, \"response parse error\\n\");\\r\\nBIO_dump_indent(arg, (char *)p, len, 4);\\r\\nreturn 0;\\r\\n}\\r\\nBIO_puts(arg, \"\\n======================================\\n\");\\r\\nOCSP_RESPONSE_print(arg, rsp, 0);\\r\\nBIO_puts(arg, \"======================================\\n\");\\r\\nOCSP_RESPONSE_free(rsp);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pqueue_c", "target": 0, "func": "pitem *pitem_new(unsigned char *prio64be, void *data)\\r\\n{\\r\\npitem *item = (pitem *)OPENSSL_malloc(sizeof(pitem));\\r\\nif (item == NULL)\\r\\nreturn NULL;\\r\\nmemcpy(item->priority, prio64be, sizeof(item->priority));\\r\\nitem->data = data;\\r\\nitem->next = NULL;\\r\\nreturn item;\\r\\n}\\r\\nvoid pitem_free(pitem *item)\\r\\n{\\r\\nif (item == NULL)\\r\\nreturn;\\r\\nOPENSSL_free(item);\\r\\n}\\r\\npqueue_s *pqueue_new()\\r\\n{\\r\\npqueue_s *pq = (pqueue_s *)OPENSSL_malloc(sizeof(pqueue_s));\\r\\nif (pq == NULL)\\r\\nreturn NULL;\\r\\nmemset(pq, 0x00, sizeof(pqueue_s));\\r\\nreturn pq;\\r\\n}\\r\\nvoid pqueue_free(pqueue_s *pq)\\r\\n{\\r\\nif (pq == NULL)\\r\\nreturn;\\r\\nOPENSSL_free(pq);\\r\\n}\\r\\npitem *pqueue_insert(pqueue_s *pq, pitem *item)\\r\\n{\\r\\npitem *curr, *next;\\r\\nif (pq->items == NULL) {\\r\\npq->items = item;\\r\\nreturn item;\\r\\n}\\r\\nfor (curr = NULL, next = pq->items;\\r\\nnext != NULL; curr = next, next = next->next) {\\r\\nint cmp = memcmp(next->priority, item->priority, 8);\\r\\nif (cmp > 0) {\\r\\nitem->next = next;\\r\\nif (curr == NULL)\\r\\npq->items = item;\\r\\nelse\\r\\ncurr->next = item;\\r\\nreturn item;\\r\\n}\\r\\nelse if (cmp == 0)\\r\\nreturn NULL;\\r\\n}\\r\\nitem->next = NULL;\\r\\ncurr->next = item;\\r\\nreturn item;\\r\\n}\\r\\npitem *pqueue_peek(pqueue_s *pq)\\r\\n{\\r\\nreturn pq->items;\\r\\n}\\r\\npitem *pqueue_pop(pqueue_s *pq)\\r\\n{\\r\\npitem *item = pq->items;\\r\\nif (pq->items != NULL)\\r\\npq->items = pq->items->next;\\r\\nreturn item;\\r\\n}\\r\\npitem *pqueue_find(pqueue_s *pq, unsigned char *prio64be)\\r\\n{\\r\\npitem *next;\\r\\npitem *found = NULL;\\r\\nif (pq->items == NULL)\\r\\nreturn NULL;\\r\\nfor (next = pq->items; next->next != NULL; next = next->next) {\\r\\nif (memcmp(next->priority, prio64be, 8) == 0) {\\r\\nfound = next;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (memcmp(next->priority, prio64be, 8) == 0)\\r\\nfound = next;\\r\\nif (!found)\\r\\nreturn NULL;\\r\\n#if 0\\r\\nif (prev == NULL)\\r\\npq->items = next->next;\\r\\nelse\\r\\nprev->next = next->next;\\r\\n#endif\\r\\nreturn found;\\r\\n}\\r\\nvoid pqueue_print(pqueue_s *pq)\\r\\n{\\r\\npitem *item = pq->items;\\r\\nwhile (item != NULL) {\\r\\nprintf(\"item\\t%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\\r\\nitem->priority[0], item->priority[1],\\r\\nitem->priority[2], item->priority[3],\\r\\nitem->priority[4], item->priority[5],\\r\\nitem->priority[6], item->priority[7]);\\r\\nitem = item->next;\\r\\n}\\r\\n}\\r\\npitem *pqueue_iterator(pqueue_s *pq)\\r\\n{\\r\\nreturn pqueue_peek(pq);\\r\\n}\\r\\npitem *pqueue_next(pitem **item)\\r\\n{\\r\\npitem *ret;\\r\\nif (item == NULL || *item == NULL)\\r\\nreturn NULL;\\r\\nret = *item;\\r\\n*item = (*item)->next;\\r\\nreturn ret;\\r\\n}\\r\\nint pqueue_size(pqueue_s *pq)\\r\\n{\\r\\npitem *item = pq->items;\\r\\nint count = 0;\\r\\nwhile (item != NULL) {\\r\\ncount++;\\r\\nitem = item->next;\\r\\n}\\r\\nreturn count;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_dup_c", "target": 0, "func": "void *ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, void *x)\\r\\n{\\r\\nunsigned char *b, *p;\\r\\nconst unsigned char *p2;\\r\\nint i;\\r\\nchar *ret;\\r\\nif (x == NULL)\\r\\nreturn (NULL);\\r\\ni = i2d(x, NULL);\\r\\nb = OPENSSL_malloc(i + 10);\\r\\nif (b == NULL) {\\r\\nASN1err(ASN1_F_ASN1_DUP, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\np = b;\\r\\ni = i2d(x, &p);\\r\\np2 = b;\\r\\nret = d2i(NULL, &p2, i);\\r\\nOPENSSL_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nvoid *ASN1_item_dup(const ASN1_ITEM *it, void *x)\\r\\n{\\r\\nunsigned char *b = NULL;\\r\\nconst unsigned char *p;\\r\\nlong i;\\r\\nvoid *ret;\\r\\nif (x == NULL)\\r\\nreturn (NULL);\\r\\ni = ASN1_item_i2d(x, &b, it);\\r\\nif (b == NULL) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_DUP, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\np = b;\\r\\nret = ASN1_item_d2i(NULL, &p, i, it);\\r\\nOPENSSL_free(b);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tb_asnmth_c", "target": 0, "func": "void ENGINE_unregister_pkey_asn1_meths(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&pkey_asn1_meth_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_pkey_asn1_meths(void)\\r\\n{\\r\\nengine_table_cleanup(&pkey_asn1_meth_table);\\r\\n}\\r\\nint ENGINE_register_pkey_asn1_meths(ENGINE *e)\\r\\n{\\r\\nif (e->pkey_asn1_meths) {\\r\\nconst int *nids;\\r\\nint num_nids = e->pkey_asn1_meths(e, NULL, &nids, 0);\\r\\nif (num_nids > 0)\\r\\nreturn engine_table_register(&pkey_asn1_meth_table,\\r\\nengine_unregister_all_pkey_asn1_meths,\\r\\ne, nids, num_nids, 0);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_pkey_asn1_meths(void)\\r\\n{\\r\\nENGINE *e;\\r\\nfor (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))\\r\\nENGINE_register_pkey_asn1_meths(e);\\r\\n}\\r\\nint ENGINE_set_default_pkey_asn1_meths(ENGINE *e)\\r\\n{\\r\\nif (e->pkey_asn1_meths) {\\r\\nconst int *nids;\\r\\nint num_nids = e->pkey_asn1_meths(e, NULL, &nids, 0);\\r\\nif (num_nids > 0)\\r\\nreturn engine_table_register(&pkey_asn1_meth_table,\\r\\nengine_unregister_all_pkey_asn1_meths,\\r\\ne, nids, num_nids, 1);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_pkey_asn1_meth_engine(int nid)\\r\\n{\\r\\nreturn engine_table_select(&pkey_asn1_meth_table, nid);\\r\\n}\\r\\nconst EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth(ENGINE *e, int nid)\\r\\n{\\r\\nEVP_PKEY_ASN1_METHOD *ret;\\r\\nENGINE_PKEY_ASN1_METHS_PTR fn = ENGINE_get_pkey_asn1_meths(e);\\r\\nif (!fn || !fn(e, &ret, NULL, nid)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_PKEY_ASN1_METH,\\r\\nENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nENGINE_PKEY_ASN1_METHS_PTR ENGINE_get_pkey_asn1_meths(const ENGINE *e)\\r\\n{\\r\\nreturn e->pkey_asn1_meths;\\r\\n}\\r\\nint ENGINE_set_pkey_asn1_meths(ENGINE *e, ENGINE_PKEY_ASN1_METHS_PTR f)\\r\\n{\\r\\ne->pkey_asn1_meths = f;\\r\\nreturn 1;\\r\\n}\\r\\nvoid engine_pkey_asn1_meths_free(ENGINE *e)\\r\\n{\\r\\nint i;\\r\\nEVP_PKEY_ASN1_METHOD *pkm;\\r\\nif (e->pkey_asn1_meths) {\\r\\nconst int *pknids;\\r\\nint npknids;\\r\\nnpknids = e->pkey_asn1_meths(e, NULL, &pknids, 0);\\r\\nfor (i = 0; i < npknids; i++) {\\r\\nif (e->pkey_asn1_meths(e, &pkm, NULL, pknids[i])) {\\r\\nEVP_PKEY_asn1_free(pkm);\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nconst EVP_PKEY_ASN1_METHOD *ENGINE_get_pkey_asn1_meth_str(ENGINE *e,\\r\\nconst char *str,\\r\\nint len)\\r\\n{\\r\\nint i, nidcount;\\r\\nconst int *nids;\\r\\nEVP_PKEY_ASN1_METHOD *ameth;\\r\\nif (!e->pkey_asn1_meths)\\r\\nreturn NULL;\\r\\nif (len == -1)\\r\\nlen = strlen(str);\\r\\nnidcount = e->pkey_asn1_meths(e, NULL, &nids, 0);\\r\\nfor (i = 0; i < nidcount; i++) {\\r\\ne->pkey_asn1_meths(e, &ameth, NULL, nids[i]);\\r\\nif (((int)strlen(ameth->pem_str) == len) &&\\r\\n!strncasecmp(ameth->pem_str, str, len))\\r\\nreturn ameth;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nconst EVP_PKEY_ASN1_METHOD *ENGINE_pkey_asn1_find_str(ENGINE **pe,\\r\\nconst char *str,\\r\\nint len)\\r\\n{\\r\\nENGINE_FIND_STR fstr;\\r\\nfstr.e = NULL;\\r\\nfstr.ameth = NULL;\\r\\nfstr.str = str;\\r\\nfstr.len = len;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nengine_table_doall(pkey_asn1_meth_table, look_str_cb, &fstr);\\r\\nif (fstr.e) {\\r\\nfstr.e->struct_ref++;\\r\\nengine_ref_debug(fstr.e, 0, 1)\\r\\n}\\r\\n*pe = fstr.e;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nreturn fstr.ameth;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_obj_err_c", "target": 0, "func": "void ERR_load_OBJ_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(OBJ_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, OBJ_str_functs);\\r\\nERR_load_strings(0, OBJ_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_lib_c", "target": 0, "func": "const ASN1_OBJECT *CMS_get0_type(CMS_ContentInfo *cms)\\r\\n{\\r\\nreturn cms->contentType;\\r\\n}\\r\\nCMS_ContentInfo *cms_Data_create(void)\\r\\n{\\r\\nCMS_ContentInfo *cms;\\r\\ncms = CMS_ContentInfo_new();\\r\\nif (cms) {\\r\\ncms->contentType = OBJ_nid2obj(NID_pkcs7_data);\\r\\nCMS_set_detached(cms, 0);\\r\\n}\\r\\nreturn cms;\\r\\n}\\r\\nBIO *cms_content_bio(CMS_ContentInfo *cms)\\r\\n{\\r\\nASN1_OCTET_STRING **pos = CMS_get0_content(cms);\\r\\nif (!pos)\\r\\nreturn NULL;\\r\\nif (!*pos)\\r\\nreturn BIO_new(BIO_s_null());\\r\\nif (!*pos || ((*pos)->flags == ASN1_STRING_FLAG_CONT))\\r\\nreturn BIO_new(BIO_s_mem());\\r\\nreturn BIO_new_mem_buf((*pos)->data, (*pos)->length);\\r\\n}\\r\\nBIO *CMS_dataInit(CMS_ContentInfo *cms, BIO *icont)\\r\\n{\\r\\nBIO *cmsbio, *cont;\\r\\nif (icont)\\r\\ncont = icont;\\r\\nelse\\r\\ncont = cms_content_bio(cms);\\r\\nif (!cont) {\\r\\nCMSerr(CMS_F_CMS_DATAINIT, CMS_R_NO_CONTENT);\\r\\nreturn NULL;\\r\\n}\\r\\nswitch (OBJ_obj2nid(cms->contentType)) {\\r\\ncase NID_pkcs7_data:\\r\\nreturn cont;\\r\\ncase NID_pkcs7_signed:\\r\\ncmsbio = cms_SignedData_init_bio(cms);\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\ncmsbio = cms_DigestedData_init_bio(cms);\\r\\nbreak;\\r\\n#ifdef ZLIB\\r\\ncase NID_id_smime_ct_compressedData:\\r\\ncmsbio = cms_CompressedData_init_bio(cms);\\r\\nbreak;\\r\\n#endif\\r\\ncase NID_pkcs7_encrypted:\\r\\ncmsbio = cms_EncryptedData_init_bio(cms);\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\ncmsbio = cms_EnvelopedData_init_bio(cms);\\r\\nbreak;\\r\\ndefault:\\r\\nCMSerr(CMS_F_CMS_DATAINIT, CMS_R_UNSUPPORTED_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (cmsbio)\\r\\nreturn BIO_push(cmsbio, cont);\\r\\nif (!icont)\\r\\nBIO_free(cont);\\r\\nreturn NULL;\\r\\n}\\r\\nint CMS_dataFinal(CMS_ContentInfo *cms, BIO *cmsbio)\\r\\n{\\r\\nASN1_OCTET_STRING **pos = CMS_get0_content(cms);\\r\\nif (!pos)\\r\\nreturn 0;\\r\\nif (*pos && ((*pos)->flags & ASN1_STRING_FLAG_CONT)) {\\r\\nBIO *mbio;\\r\\nunsigned char *cont;\\r\\nlong contlen;\\r\\nmbio = BIO_find_type(cmsbio, BIO_TYPE_MEM);\\r\\nif (!mbio) {\\r\\nCMSerr(CMS_F_CMS_DATAFINAL, CMS_R_CONTENT_NOT_FOUND);\\r\\nreturn 0;\\r\\n}\\r\\ncontlen = BIO_get_mem_data(mbio, &cont);\\r\\nBIO_set_flags(mbio, BIO_FLAGS_MEM_RDONLY);\\r\\nBIO_set_mem_eof_return(mbio, 0);\\r\\nASN1_STRING_set0(*pos, cont, contlen);\\r\\n(*pos)->flags &= ~ASN1_STRING_FLAG_CONT;\\r\\n}\\r\\nswitch (OBJ_obj2nid(cms->contentType)) {\\r\\ncase NID_pkcs7_data:\\r\\ncase NID_pkcs7_enveloped:\\r\\ncase NID_pkcs7_encrypted:\\r\\ncase NID_id_smime_ct_compressedData:\\r\\nreturn 1;\\r\\ncase NID_pkcs7_signed:\\r\\nreturn cms_SignedData_final(cms, cmsbio);\\r\\ncase NID_pkcs7_digest:\\r\\nreturn cms_DigestedData_do_final(cms, cmsbio, 0);\\r\\ndefault:\\r\\nCMSerr(CMS_F_CMS_DATAFINAL, CMS_R_UNSUPPORTED_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nASN1_OCTET_STRING **CMS_get0_content(CMS_ContentInfo *cms)\\r\\n{\\r\\nswitch (OBJ_obj2nid(cms->contentType)) {\\r\\ncase NID_pkcs7_data:\\r\\nreturn &cms->d.data;\\r\\ncase NID_pkcs7_signed:\\r\\nreturn &cms->d.signedData->encapContentInfo->eContent;\\r\\ncase NID_pkcs7_enveloped:\\r\\nreturn &cms->d.envelopedData->encryptedContentInfo->encryptedContent;\\r\\ncase NID_pkcs7_digest:\\r\\nreturn &cms->d.digestedData->encapContentInfo->eContent;\\r\\ncase NID_pkcs7_encrypted:\\r\\nreturn &cms->d.encryptedData->encryptedContentInfo->encryptedContent;\\r\\ncase NID_id_smime_ct_authData:\\r\\nreturn &cms->d.authenticatedData->encapContentInfo->eContent;\\r\\ncase NID_id_smime_ct_compressedData:\\r\\nreturn &cms->d.compressedData->encapContentInfo->eContent;\\r\\ndefault:\\r\\nif (cms->d.other->type == V_ASN1_OCTET_STRING)\\r\\nreturn &cms->d.other->value.octet_string;\\r\\nCMSerr(CMS_F_CMS_GET0_CONTENT, CMS_R_UNSUPPORTED_CONTENT_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nstatic ASN1_OBJECT **cms_get0_econtent_type(CMS_ContentInfo *cms)\\r\\n{\\r\\nswitch (OBJ_obj2nid(cms->contentType)) {\\r\\ncase NID_pkcs7_signed:\\r\\nreturn &cms->d.signedData->encapContentInfo->eContentType;\\r\\ncase NID_pkcs7_enveloped:\\r\\nreturn &cms->d.envelopedData->encryptedContentInfo->contentType;\\r\\ncase NID_pkcs7_digest:\\r\\nreturn &cms->d.digestedData->encapContentInfo->eContentType;\\r\\ncase NID_pkcs7_encrypted:\\r\\nreturn &cms->d.encryptedData->encryptedContentInfo->contentType;\\r\\ncase NID_id_smime_ct_authData:\\r\\nreturn &cms->d.authenticatedData->encapContentInfo->eContentType;\\r\\ncase NID_id_smime_ct_compressedData:\\r\\nreturn &cms->d.compressedData->encapContentInfo->eContentType;\\r\\ndefault:\\r\\nCMSerr(CMS_F_CMS_GET0_ECONTENT_TYPE, CMS_R_UNSUPPORTED_CONTENT_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nconst ASN1_OBJECT *CMS_get0_eContentType(CMS_ContentInfo *cms)\\r\\n{\\r\\nASN1_OBJECT **petype;\\r\\npetype = cms_get0_econtent_type(cms);\\r\\nif (petype)\\r\\nreturn *petype;\\r\\nreturn NULL;\\r\\n}\\r\\nint CMS_set1_eContentType(CMS_ContentInfo *cms, const ASN1_OBJECT *oid)\\r\\n{\\r\\nASN1_OBJECT **petype, *etype;\\r\\npetype = cms_get0_econtent_type(cms);\\r\\nif (!petype)\\r\\nreturn 0;\\r\\nif (!oid)\\r\\nreturn 1;\\r\\netype = OBJ_dup(oid);\\r\\nif (!etype)\\r\\nreturn 0;\\r\\nASN1_OBJECT_free(*petype);\\r\\n*petype = etype;\\r\\nreturn 1;\\r\\n}\\r\\nint CMS_is_detached(CMS_ContentInfo *cms)\\r\\n{\\r\\nASN1_OCTET_STRING **pos;\\r\\npos = CMS_get0_content(cms);\\r\\nif (!pos)\\r\\nreturn -1;\\r\\nif (*pos)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint CMS_set_detached(CMS_ContentInfo *cms, int detached)\\r\\n{\\r\\nASN1_OCTET_STRING **pos;\\r\\npos = CMS_get0_content(cms);\\r\\nif (!pos)\\r\\nreturn 0;\\r\\nif (detached) {\\r\\nif (*pos) {\\r\\nASN1_OCTET_STRING_free(*pos);\\r\\n*pos = NULL;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nif (!*pos)\\r\\n*pos = ASN1_OCTET_STRING_new();\\r\\nif (*pos) {\\r\\n(*pos)->flags |= ASN1_STRING_FLAG_CONT;\\r\\nreturn 1;\\r\\n}\\r\\nCMSerr(CMS_F_CMS_SET_DETACHED, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nvoid cms_DigestAlgorithm_set(X509_ALGOR *alg, const EVP_MD *md)\\r\\n{\\r\\nint param_type;\\r\\nif (md->flags & EVP_MD_FLAG_DIGALGID_ABSENT)\\r\\nparam_type = V_ASN1_UNDEF;\\r\\nelse\\r\\nparam_type = V_ASN1_NULL;\\r\\nX509_ALGOR_set0(alg, OBJ_nid2obj(EVP_MD_type(md)), param_type, NULL);\\r\\n}\\r\\nBIO *cms_DigestAlgorithm_init_bio(X509_ALGOR *digestAlgorithm)\\r\\n{\\r\\nBIO *mdbio = NULL;\\r\\nASN1_OBJECT *digestoid;\\r\\nconst EVP_MD *digest;\\r\\nX509_ALGOR_get0(&digestoid, NULL, NULL, digestAlgorithm);\\r\\ndigest = EVP_get_digestbyobj(digestoid);\\r\\nif (!digest) {\\r\\nCMSerr(CMS_F_CMS_DIGESTALGORITHM_INIT_BIO,\\r\\nCMS_R_UNKNOWN_DIGEST_ALGORIHM);\\r\\ngoto err;\\r\\n}\\r\\nmdbio = BIO_new(BIO_f_md());\\r\\nif (!mdbio || !BIO_set_md(mdbio, digest)) {\\r\\nCMSerr(CMS_F_CMS_DIGESTALGORITHM_INIT_BIO, CMS_R_MD_BIO_INIT_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nreturn mdbio;\\r\\nerr:\\r\\nif (mdbio)\\r\\nBIO_free(mdbio);\\r\\nreturn NULL;\\r\\n}\\r\\nint cms_DigestAlgorithm_find_ctx(EVP_MD_CTX *mctx, BIO *chain,\\r\\nX509_ALGOR *mdalg)\\r\\n{\\r\\nint nid;\\r\\nASN1_OBJECT *mdoid;\\r\\nX509_ALGOR_get0(&mdoid, NULL, NULL, mdalg);\\r\\nnid = OBJ_obj2nid(mdoid);\\r\\nfor (;;) {\\r\\nEVP_MD_CTX *mtmp;\\r\\nchain = BIO_find_type(chain, BIO_TYPE_MD);\\r\\nif (chain == NULL) {\\r\\nCMSerr(CMS_F_CMS_DIGESTALGORITHM_FIND_CTX,\\r\\nCMS_R_NO_MATCHING_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nBIO_get_md_ctx(chain, &mtmp);\\r\\nif (EVP_MD_CTX_type(mtmp) == nid\\r\\n|| EVP_MD_pkey_type(EVP_MD_CTX_md(mtmp)) == nid)\\r\\nreturn EVP_MD_CTX_copy_ex(mctx, mtmp);\\r\\nchain = BIO_next(chain);\\r\\n}\\r\\n}\\r\\nint CMS_add1_cert(CMS_ContentInfo *cms, X509 *cert)\\r\\n{\\r\\nint r;\\r\\nr = CMS_add0_cert(cms, cert);\\r\\nif (r > 0)\\r\\nCRYPTO_add(&cert->references, 1, CRYPTO_LOCK_X509);\\r\\nreturn r;\\r\\n}\\r\\nint CMS_add1_crl(CMS_ContentInfo *cms, X509_CRL *crl)\\r\\n{\\r\\nint r;\\r\\nr = CMS_add0_crl(cms, crl);\\r\\nif (r > 0)\\r\\nCRYPTO_add(&crl->references, 1, CRYPTO_LOCK_X509_CRL);\\r\\nreturn r;\\r\\n}\\r\\nint cms_keyid_cert_cmp(ASN1_OCTET_STRING *keyid, X509 *cert)\\r\\n{\\r\\nX509_check_purpose(cert, -1, -1);\\r\\nif (!cert->skid)\\r\\nreturn -1;\\r\\nreturn ASN1_OCTET_STRING_cmp(keyid, cert->skid);\\r\\n}\\r\\nint cms_set1_ias(CMS_IssuerAndSerialNumber **pias, X509 *cert)\\r\\n{\\r\\nCMS_IssuerAndSerialNumber *ias;\\r\\nias = M_ASN1_new_of(CMS_IssuerAndSerialNumber);\\r\\nif (!ias)\\r\\ngoto err;\\r\\nif (!X509_NAME_set(&ias->issuer, X509_get_issuer_name(cert)))\\r\\ngoto err;\\r\\nif (!ASN1_STRING_copy(ias->serialNumber, X509_get_serialNumber(cert)))\\r\\ngoto err;\\r\\nif (*pias)\\r\\nM_ASN1_free_of(*pias, CMS_IssuerAndSerialNumber);\\r\\n*pias = ias;\\r\\nreturn 1;\\r\\nerr:\\r\\nif (ias)\\r\\nM_ASN1_free_of(ias, CMS_IssuerAndSerialNumber);\\r\\nCMSerr(CMS_F_CMS_SET1_IAS, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nint cms_set1_keyid(ASN1_OCTET_STRING **pkeyid, X509 *cert)\\r\\n{\\r\\nASN1_OCTET_STRING *keyid = NULL;\\r\\nX509_check_purpose(cert, -1, -1);\\r\\nif (!cert->skid) {\\r\\nCMSerr(CMS_F_CMS_SET1_KEYID, CMS_R_CERTIFICATE_HAS_NO_KEYID);\\r\\nreturn 0;\\r\\n}\\r\\nkeyid = ASN1_STRING_dup(cert->skid);\\r\\nif (!keyid) {\\r\\nCMSerr(CMS_F_CMS_SET1_KEYID, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (*pkeyid)\\r\\nASN1_OCTET_STRING_free(*pkeyid);\\r\\n*pkeyid = keyid;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_genn_c", "target": 0, "func": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\\r\\n{\\r\\nint result = -1;\\r\\nif (!a || !b || a->type != b->type)\\r\\nreturn -1;\\r\\nswitch (a->type) {\\r\\ncase GEN_X400:\\r\\ncase GEN_EDIPARTY:\\r\\nresult = ASN1_TYPE_cmp(a->d.other, b->d.other);\\r\\nbreak;\\r\\ncase GEN_OTHERNAME:\\r\\nresult = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\\r\\nbreak;\\r\\ncase GEN_EMAIL:\\r\\ncase GEN_DNS:\\r\\ncase GEN_URI:\\r\\nresult = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\\r\\nbreak;\\r\\ncase GEN_DIRNAME:\\r\\nresult = X509_NAME_cmp(a->d.dirn, b->d.dirn);\\r\\nbreak;\\r\\ncase GEN_IPADD:\\r\\nresult = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\\r\\nbreak;\\r\\ncase GEN_RID:\\r\\nresult = OBJ_cmp(a->d.rid, b->d.rid);\\r\\nbreak;\\r\\n}\\r\\nreturn result;\\r\\n}\\r\\nint OTHERNAME_cmp(OTHERNAME *a, OTHERNAME *b)\\r\\n{\\r\\nint result = -1;\\r\\nif (!a || !b)\\r\\nreturn -1;\\r\\nif ((result = OBJ_cmp(a->type_id, b->type_id)) != 0)\\r\\nreturn result;\\r\\nresult = ASN1_TYPE_cmp(a->value, b->value);\\r\\nreturn result;\\r\\n}\\r\\nvoid GENERAL_NAME_set0_value(GENERAL_NAME *a, int type, void *value)\\r\\n{\\r\\nswitch (type) {\\r\\ncase GEN_X400:\\r\\ncase GEN_EDIPARTY:\\r\\na->d.other = value;\\r\\nbreak;\\r\\ncase GEN_OTHERNAME:\\r\\na->d.otherName = value;\\r\\nbreak;\\r\\ncase GEN_EMAIL:\\r\\ncase GEN_DNS:\\r\\ncase GEN_URI:\\r\\na->d.ia5 = value;\\r\\nbreak;\\r\\ncase GEN_DIRNAME:\\r\\na->d.dirn = value;\\r\\nbreak;\\r\\ncase GEN_IPADD:\\r\\na->d.ip = value;\\r\\nbreak;\\r\\ncase GEN_RID:\\r\\na->d.rid = value;\\r\\nbreak;\\r\\n}\\r\\na->type = type;\\r\\n}\\r\\nvoid *GENERAL_NAME_get0_value(GENERAL_NAME *a, int *ptype)\\r\\n{\\r\\nif (ptype)\\r\\n*ptype = a->type;\\r\\nswitch (a->type) {\\r\\ncase GEN_X400:\\r\\ncase GEN_EDIPARTY:\\r\\nreturn a->d.other;\\r\\ncase GEN_OTHERNAME:\\r\\nreturn a->d.otherName;\\r\\ncase GEN_EMAIL:\\r\\ncase GEN_DNS:\\r\\ncase GEN_URI:\\r\\nreturn a->d.ia5;\\r\\ncase GEN_DIRNAME:\\r\\nreturn a->d.dirn;\\r\\ncase GEN_IPADD:\\r\\nreturn a->d.ip;\\r\\ncase GEN_RID:\\r\\nreturn a->d.rid;\\r\\ndefault:\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nint GENERAL_NAME_set0_othername(GENERAL_NAME *gen,\\r\\nASN1_OBJECT *oid, ASN1_TYPE *value)\\r\\n{\\r\\nOTHERNAME *oth;\\r\\noth = OTHERNAME_new();\\r\\nif (!oth)\\r\\nreturn 0;\\r\\noth->type_id = oid;\\r\\noth->value = value;\\r\\nGENERAL_NAME_set0_value(gen, GEN_OTHERNAME, oth);\\r\\nreturn 1;\\r\\n}\\r\\nint GENERAL_NAME_get0_otherName(GENERAL_NAME *gen,\\r\\nASN1_OBJECT **poid, ASN1_TYPE **pvalue)\\r\\n{\\r\\nif (gen->type != GEN_OTHERNAME)\\r\\nreturn 0;\\r\\nif (poid)\\r\\n*poid = gen->d.otherName->type_id;\\r\\nif (pvalue)\\r\\n*pvalue = gen->d.otherName->value;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_attr_c", "target": 0, "func": "int PKCS12_add_localkeyid(PKCS12_SAFEBAG *bag, unsigned char *name,\\r\\nint namelen)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&bag->attrib, NID_localKeyID,\\r\\nV_ASN1_OCTET_STRING, name, namelen))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint PKCS8_add_keyusage(PKCS8_PRIV_KEY_INFO *p8, int usage)\\r\\n{\\r\\nunsigned char us_val;\\r\\nus_val = (unsigned char)usage;\\r\\nif (X509at_add1_attr_by_NID(&p8->attributes, NID_key_usage,\\r\\nV_ASN1_BIT_STRING, &us_val, 1))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint PKCS12_add_friendlyname_asc(PKCS12_SAFEBAG *bag, const char *name,\\r\\nint namelen)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&bag->attrib, NID_friendlyName,\\r\\nMBSTRING_ASC, (unsigned char *)name, namelen))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint PKCS12_add_friendlyname_uni(PKCS12_SAFEBAG *bag,\\r\\nconst unsigned char *name, int namelen)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&bag->attrib, NID_friendlyName,\\r\\nMBSTRING_BMP, name, namelen))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint PKCS12_add_CSPName_asc(PKCS12_SAFEBAG *bag, const char *name, int namelen)\\r\\n{\\r\\nif (X509at_add1_attr_by_NID(&bag->attrib, NID_ms_csp_name,\\r\\nMBSTRING_ASC, (unsigned char *)name, namelen))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nchar *PKCS12_get_friendlyname(PKCS12_SAFEBAG *bag)\\r\\n{\\r\\nASN1_TYPE *atype;\\r\\nif (!(atype = PKCS12_get_attr(bag, NID_friendlyName)))\\r\\nreturn NULL;\\r\\nif (atype->type != V_ASN1_BMPSTRING)\\r\\nreturn NULL;\\r\\nreturn OPENSSL_uni2asc(atype->value.bmpstring->data,\\r\\natype->value.bmpstring->length);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_md4_one_c", "target": 0, "func": "unsigned char *MD4(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nMD4_CTX c;\\r\\nstatic unsigned char m[MD4_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nif (!MD4_Init(&c))\\r\\nreturn NULL;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nMD4_Update(&c, d, n);\\r\\n#else\\r\\n{\\r\\nchar temp[1024];\\r\\nunsigned long chunk;\\r\\nwhile (n > 0) {\\r\\nchunk = (n > sizeof(temp)) ? sizeof(temp) : n;\\r\\nebcdic2ascii(temp, d, chunk);\\r\\nMD4_Update(&c, temp, chunk);\\r\\nn -= chunk;\\r\\nd += chunk;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nMD4_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cbc_cksm_c", "target": 0, "func": "DES_LONG DES_cbc_cksum(const unsigned char *in, DES_cblock *output,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nconst_DES_cblock *ivec)\\r\\n{\\r\\nregister DES_LONG tout0, tout1, tin0, tin1;\\r\\nregister long l = length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *out = &(*output)[0];\\r\\nconst unsigned char *iv = &(*ivec)[0];\\r\\nc2l(iv, tout0);\\r\\nc2l(iv, tout1);\\r\\nfor (; l > 0; l -= 8) {\\r\\nif (l >= 8) {\\r\\nc2l(in, tin0);\\r\\nc2l(in, tin1);\\r\\n} else\\r\\nc2ln(in, tin0, tin1, l);\\r\\ntin0 ^= tout0;\\r\\ntin[0] = tin0;\\r\\ntin1 ^= tout1;\\r\\ntin[1] = tin1;\\r\\nDES_encrypt1((DES_LONG *)tin, schedule, DES_ENCRYPT);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\n}\\r\\nif (out != NULL) {\\r\\nl2c(tout0, out);\\r\\nl2c(tout1, out);\\r\\n}\\r\\ntout0 = tin0 = tin1 = tin[0] = tin[1] = 0;\\r\\ntout1 = ((tout1 >> 24L) & 0x000000FF)\\r\\n| ((tout1 >> 8L) & 0x0000FF00)\\r\\n| ((tout1 << 8L) & 0x00FF0000)\\r\\n| ((tout1 << 24L) & 0xFF000000);\\r\\nreturn (tout1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ebcdic_c", "target": 0, "func": "void *ebcdic2ascii(void *dest, const void *srce, size_t count)\\r\\n{\\r\\nunsigned char *udest = dest;\\r\\nconst unsigned char *usrce = srce;\\r\\nwhile (count-- != 0) {\\r\\n*udest++ = os_toascii[*usrce++];\\r\\n}\\r\\nreturn dest;\\r\\n}\\r\\nvoid *ascii2ebcdic(void *dest, const void *srce, size_t count)\\r\\n{\\r\\nunsigned char *udest = dest;\\r\\nconst unsigned char *usrce = srce;\\r\\nwhile (count-- != 0) {\\r\\n*udest++ = os_toebcdic[*usrce++];\\r\\n}\\r\\nreturn dest;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dso_vms_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_vms(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nDSO_METHOD *DSO_METHOD_vms(void)\\r\\n{\\r\\nreturn (&dso_meth_vms);\\r\\n}\\r\\nstatic int vms_load(DSO *dso)\\r\\n{\\r\\nvoid *ptr = NULL;\\r\\nchar *filename = DSO_convert_filename(dso, NULL);\\r\\n# if __INITIAL_POINTER_SIZE == 64\\r\\n# define DSO_MALLOC _malloc32\\r\\n# pragma pointer_size save\\r\\n# pragma pointer_size 32\\r\\n# else\\r\\n# define DSO_MALLOC OPENSSL_malloc\\r\\n# endif\\r\\nDSO_VMS_INTERNAL *p = NULL;\\r\\n# if __INITIAL_POINTER_SIZE == 64\\r\\n# pragma pointer_size restore\\r\\n# endif\\r\\nconst char *sp1, *sp2;\\r\\nif (filename == NULL) {\\r\\nDSOerr(DSO_F_VMS_LOAD, DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\nsp1 = strrchr(filename, ']');\\r\\nsp2 = strrchr(filename, '>');\\r\\nif (sp1 == NULL)\\r\\nsp1 = sp2;\\r\\nif (sp2 != NULL && sp2 > sp1)\\r\\nsp1 = sp2;\\r\\nif (sp1 == NULL)\\r\\nsp1 = strrchr(filename, ':');\\r\\nif (sp1 == NULL)\\r\\nsp1 = filename;\\r\\nelse\\r\\nsp1++;\\r\\nsp2 = strchr(sp1, '.');\\r\\nif (sp2 == NULL)\\r\\nsp2 = strchr(sp1, ';');\\r\\nif (sp2 == NULL)\\r\\nsp2 = sp1 + strlen(sp1);\\r\\nif (sp2 - sp1 > FILENAME_MAX\\r\\n|| (sp1 - filename) + strlen(sp2) > FILENAME_MAX) {\\r\\nDSOerr(DSO_F_VMS_LOAD, DSO_R_FILENAME_TOO_BIG);\\r\\ngoto err;\\r\\n}\\r\\np = DSO_MALLOC(sizeof(DSO_VMS_INTERNAL));\\r\\nif (p == NULL) {\\r\\nDSOerr(DSO_F_VMS_LOAD, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nstrncpy(p->filename, sp1, sp2 - sp1);\\r\\np->filename[sp2 - sp1] = '\\0';\\r\\nstrncpy(p->imagename, filename, sp1 - filename);\\r\\np->imagename[sp1 - filename] = '\\0';\\r\\nstrcat(p->imagename, sp2);\\r\\np->filename_dsc.dsc$w_length = strlen(p->filename);\\r\\np->filename_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\np->filename_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\np->filename_dsc.dsc$a_pointer = p->filename;\\r\\np->imagename_dsc.dsc$w_length = strlen(p->imagename);\\r\\np->imagename_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\np->imagename_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\np->imagename_dsc.dsc$a_pointer = p->imagename;\\r\\nif (!sk_void_push(dso->meth_data, (char *)p)) {\\r\\nDSOerr(DSO_F_VMS_LOAD, DSO_R_STACK_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndso->loaded_filename = filename;\\r\\nreturn (1);\\r\\nerr:\\r\\nif (p != NULL)\\r\\nOPENSSL_free(p);\\r\\nif (filename != NULL)\\r\\nOPENSSL_free(filename);\\r\\nreturn (0);\\r\\n}\\r\\nstatic int vms_unload(DSO *dso)\\r\\n{\\r\\nDSO_VMS_INTERNAL *p;\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_VMS_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (sk_void_num(dso->meth_data) < 1)\\r\\nreturn (1);\\r\\np = (DSO_VMS_INTERNAL *)sk_void_pop(dso->meth_data);\\r\\nif (p == NULL) {\\r\\nDSOerr(DSO_F_VMS_UNLOAD, DSO_R_NULL_HANDLE);\\r\\nreturn (0);\\r\\n}\\r\\nOPENSSL_free(p);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int do_find_symbol(DSO_VMS_INTERNAL *ptr,\\r\\nstruct dsc$descriptor_s *symname_dsc, void **sym,\\r\\nunsigned long flags)\\r\\n{\\r\\nlib$establish(lib$sig_to_ret);\\r\\nif (ptr->imagename_dsc.dsc$w_length)\\r\\nreturn lib$find_image_symbol(&ptr->filename_dsc,\\r\\nsymname_dsc, sym,\\r\\n&ptr->imagename_dsc, flags);\\r\\nelse\\r\\nreturn lib$find_image_symbol(&ptr->filename_dsc,\\r\\nsymname_dsc, sym, 0, flags);\\r\\n}\\r\\nvoid vms_bind_sym(DSO *dso, const char *symname, void **sym)\\r\\n{\\r\\nDSO_VMS_INTERNAL *ptr;\\r\\nint status;\\r\\n# if 0\\r\\nint flags = (1 << 4);\\r\\n# else\\r\\nint flags = 0;\\r\\n# endif\\r\\nstruct dsc$descriptor_s symname_dsc;\\r\\n# if __INITIAL_POINTER_SIZE == 64\\r\\n# define SYMNAME symname_32p\\r\\n# pragma pointer_size save\\r\\n# pragma pointer_size 32\\r\\nchar *symname_32p;\\r\\n# pragma pointer_size restore\\r\\nchar symname_32[NAMX_MAXRSS + 1];\\r\\n# else\\r\\n# define SYMNAME ((char *) symname)\\r\\n# endif\\r\\n*sym = NULL;\\r\\nif ((dso == NULL) || (symname == NULL)) {\\r\\nDSOerr(DSO_F_VMS_BIND_SYM, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn;\\r\\n}\\r\\n# if __INITIAL_POINTER_SIZE == 64\\r\\nsymname_32p = symname_32;\\r\\nstrcpy(symname_32p, symname);\\r\\n# endif\\r\\nsymname_dsc.dsc$w_length = strlen(SYMNAME);\\r\\nsymname_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nsymname_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nsymname_dsc.dsc$a_pointer = SYMNAME;\\r\\nif (sk_void_num(dso->meth_data) < 1) {\\r\\nDSOerr(DSO_F_VMS_BIND_SYM, DSO_R_STACK_ERROR);\\r\\nreturn;\\r\\n}\\r\\nptr = (DSO_VMS_INTERNAL *)sk_void_value(dso->meth_data,\\r\\nsk_void_num(dso->meth_data) - 1);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_VMS_BIND_SYM, DSO_R_NULL_HANDLE);\\r\\nreturn;\\r\\n}\\r\\nif (dso->flags & DSO_FLAG_UPCASE_SYMBOL)\\r\\nflags = 0;\\r\\nstatus = do_find_symbol(ptr, &symname_dsc, sym, flags);\\r\\nif (!$VMS_STATUS_SUCCESS(status)) {\\r\\nunsigned short length;\\r\\nchar errstring[257];\\r\\nstruct dsc$descriptor_s errstring_dsc;\\r\\nerrstring_dsc.dsc$w_length = sizeof(errstring);\\r\\nerrstring_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nerrstring_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nerrstring_dsc.dsc$a_pointer = errstring;\\r\\n*sym = NULL;\\r\\nstatus = sys$getmsg(status, &length, &errstring_dsc, 1, 0);\\r\\nif (!$VMS_STATUS_SUCCESS(status))\\r\\nlib$signal(status);\\r\\nelse {\\r\\nerrstring[length] = '\\0';\\r\\nDSOerr(DSO_F_VMS_BIND_SYM, DSO_R_SYM_FAILURE);\\r\\nif (ptr->imagename_dsc.dsc$w_length)\\r\\nERR_add_error_data(9,\\r\\n\"Symbol \", symname,\\r\\n\" in \", ptr->filename,\\r\\n\" (\", ptr->imagename, \")\",\\r\\n\": \", errstring);\\r\\nelse\\r\\nERR_add_error_data(6,\\r\\n\"Symbol \", symname,\\r\\n\" in \", ptr->filename, \": \", errstring);\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nstatic void *vms_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nvoid *sym = 0;\\r\\nvms_bind_sym(dso, symname, &sym);\\r\\nreturn sym;\\r\\n}\\r\\nstatic DSO_FUNC_TYPE vms_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nDSO_FUNC_TYPE sym = 0;\\r\\nvms_bind_sym(dso, symname, (void **)&sym);\\r\\nreturn sym;\\r\\n}\\r\\nstatic char *vms_merger(DSO *dso, const char *filespec1,\\r\\nconst char *filespec2)\\r\\n{\\r\\nint status;\\r\\nint filespec1len, filespec2len;\\r\\nstruct FAB fab;\\r\\nstruct NAMX_STRUCT nam;\\r\\nchar esa[NAMX_MAXRSS + 1];\\r\\nchar *merged;\\r\\n# if __INITIAL_POINTER_SIZE == 64\\r\\n# define FILESPEC1 filespec1_32p;\\r\\n# define FILESPEC2 filespec2_32p;\\r\\n# pragma pointer_size save\\r\\n# pragma pointer_size 32\\r\\nchar *filespec1_32p;\\r\\nchar *filespec2_32p;\\r\\n# pragma pointer_size restore\\r\\nchar filespec1_32[NAMX_MAXRSS + 1];\\r\\nchar filespec2_32[NAMX_MAXRSS + 1];\\r\\n# else\\r\\n# define FILESPEC1 ((char *) filespec1)\\r\\n# define FILESPEC2 ((char *) filespec2)\\r\\n# endif\\r\\nif (!filespec1)\\r\\nfilespec1 = \"\";\\r\\nif (!filespec2)\\r\\nfilespec2 = \"\";\\r\\nfilespec1len = strlen(filespec1);\\r\\nfilespec2len = strlen(filespec2);\\r\\n# if __INITIAL_POINTER_SIZE == 64\\r\\nfilespec1_32p = filespec1_32;\\r\\nfilespec2_32p = filespec2_32;\\r\\nstrcpy(filespec1_32p, filespec1);\\r\\nstrcpy(filespec2_32p, filespec2);\\r\\n# endif\\r\\nfab = cc$rms_fab;\\r\\nnam = CC_RMS_NAMX;\\r\\nFAB_OR_NAML(fab, nam).FAB_OR_NAML_FNA = FILESPEC1;\\r\\nFAB_OR_NAML(fab, nam).FAB_OR_NAML_FNS = filespec1len;\\r\\nFAB_OR_NAML(fab, nam).FAB_OR_NAML_DNA = FILESPEC2;\\r\\nFAB_OR_NAML(fab, nam).FAB_OR_NAML_DNS = filespec2len;\\r\\nNAMX_DNA_FNA_SET(fab)\\r\\nnam.NAMX_ESA = esa;\\r\\nnam.NAMX_ESS = NAMX_MAXRSS;\\r\\nnam.NAMX_NOP = NAM$M_SYNCHK | NAM$M_PWD;\\r\\nSET_NAMX_NO_SHORT_UPCASE(nam);\\r\\nfab.FAB_NAMX = &nam;\\r\\nstatus = sys$parse(&fab, 0, 0);\\r\\nif (!$VMS_STATUS_SUCCESS(status)) {\\r\\nunsigned short length;\\r\\nchar errstring[257];\\r\\nstruct dsc$descriptor_s errstring_dsc;\\r\\nerrstring_dsc.dsc$w_length = sizeof(errstring);\\r\\nerrstring_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nerrstring_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nerrstring_dsc.dsc$a_pointer = errstring;\\r\\nstatus = sys$getmsg(status, &length, &errstring_dsc, 1, 0);\\r\\nif (!$VMS_STATUS_SUCCESS(status))\\r\\nlib$signal(status);\\r\\nelse {\\r\\nerrstring[length] = '\\0';\\r\\nDSOerr(DSO_F_VMS_MERGER, DSO_R_FAILURE);\\r\\nERR_add_error_data(7,\\r\\n\"filespec \\\"\", filespec1, \"\\\", \",\\r\\n\"defaults \\\"\", filespec2, \"\\\": \", errstring);\\r\\n}\\r\\nreturn (NULL);\\r\\n}\\r\\nmerged = OPENSSL_malloc(nam.NAMX_ESL + 1);\\r\\nif (!merged)\\r\\ngoto malloc_err;\\r\\nstrncpy(merged, nam.NAMX_ESA, nam.NAMX_ESL);\\r\\nmerged[nam.NAMX_ESL] = '\\0';\\r\\nreturn (merged);\\r\\nmalloc_err:\\r\\nDSOerr(DSO_F_VMS_MERGER, ERR_R_MALLOC_FAILURE);\\r\\n}\\r\\nstatic char *vms_name_converter(DSO *dso, const char *filename)\\r\\n{\\r\\nint len = strlen(filename);\\r\\nchar *not_translated = OPENSSL_malloc(len + 1);\\r\\nstrcpy(not_translated, filename);\\r\\nreturn (not_translated);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_client-conf_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *sbio = NULL, *out = NULL;\\r\\nint i, len, rv;\\r\\nchar tmpbuf[1024];\\r\\nSSL_CTX *ctx = NULL;\\r\\nSSL_CONF_CTX *cctx = NULL;\\r\\nSSL *ssl = NULL;\\r\\nCONF *conf = NULL;\\r\\nSTACK_OF(CONF_VALUE) *sect = NULL;\\r\\nCONF_VALUE *cnf;\\r\\nconst char *connect_str = \"localhost:4433\";\\r\\nlong errline = -1;\\r\\nERR_load_crypto_strings();\\r\\nERR_load_SSL_strings();\\r\\nSSL_library_init();\\r\\nconf = NCONF_new(NULL);\\r\\nif (NCONF_load(conf, \"connect.cnf\", &errline) <= 0) {\\r\\nif (errline <= 0)\\r\\nfprintf(stderr, \"Error processing config file\\n\");\\r\\nelse\\r\\nfprintf(stderr, \"Error on line %ld\\n\", errline);\\r\\ngoto end;\\r\\n}\\r\\nsect = NCONF_get_section(conf, \"default\");\\r\\nif (sect == NULL) {\\r\\nfprintf(stderr, \"Error retrieving default section\\n\");\\r\\ngoto end;\\r\\n}\\r\\nctx = SSL_CTX_new(SSLv23_client_method());\\r\\ncctx = SSL_CONF_CTX_new();\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CLIENT);\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_FILE);\\r\\nSSL_CONF_CTX_set_ssl_ctx(cctx, ctx);\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(sect); i++) {\\r\\ncnf = sk_CONF_VALUE_value(sect, i);\\r\\nrv = SSL_CONF_cmd(cctx, cnf->name, cnf->value);\\r\\nif (rv > 0)\\r\\ncontinue;\\r\\nif (rv != -2) {\\r\\nfprintf(stderr, \"Error processing %s = %s\\n\",\\r\\ncnf->name, cnf->value);\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto end;\\r\\n}\\r\\nif (!strcmp(cnf->name, \"Connect\")) {\\r\\nconnect_str = cnf->value;\\r\\n} else {\\r\\nfprintf(stderr, \"Unknown configuration option %s\\n\", cnf->name);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!SSL_CONF_CTX_finish(cctx)) {\\r\\nfprintf(stderr, \"Finish error\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto err;\\r\\n}\\r\\nsbio = BIO_new_ssl_connect(ctx);\\r\\nBIO_get_ssl(sbio, &ssl);\\r\\nif (!ssl) {\\r\\nfprintf(stderr, \"Can't locate SSL pointer\\n\");\\r\\ngoto end;\\r\\n}\\r\\nSSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\\r\\nBIO_set_conn_hostname(sbio, connect_str);\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\nif (BIO_do_connect(sbio) <= 0) {\\r\\nfprintf(stderr, \"Error connecting to server\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_do_handshake(sbio) <= 0) {\\r\\nfprintf(stderr, \"Error establishing SSL connection\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto end;\\r\\n}\\r\\nBIO_puts(sbio, \"GET / HTTP/1.0\\n\\n\");\\r\\nfor (;;) {\\r\\nlen = BIO_read(sbio, tmpbuf, 1024);\\r\\nif (len <= 0)\\r\\nbreak;\\r\\nBIO_write(out, tmpbuf, len);\\r\\n}\\r\\nend:\\r\\nSSL_CONF_CTX_free(cctx);\\r\\nBIO_free_all(sbio);\\r\\nBIO_free(out);\\r\\nNCONF_free(conf);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ocsp_cl_c", "target": 0, "func": "OCSP_ONEREQ *OCSP_request_add0_id(OCSP_REQUEST *req, OCSP_CERTID *cid)\\r\\n{\\r\\nOCSP_ONEREQ *one = NULL;\\r\\nif (!(one = OCSP_ONEREQ_new()))\\r\\ngoto err;\\r\\nif (one->reqCert)\\r\\nOCSP_CERTID_free(one->reqCert);\\r\\none->reqCert = cid;\\r\\nif (req && !sk_OCSP_ONEREQ_push(req->tbsRequest->requestList, one))\\r\\ngoto err;\\r\\nreturn one;\\r\\nerr:\\r\\nOCSP_ONEREQ_free(one);\\r\\nreturn NULL;\\r\\n}\\r\\nint OCSP_request_set1_name(OCSP_REQUEST *req, X509_NAME *nm)\\r\\n{\\r\\nGENERAL_NAME *gen;\\r\\ngen = GENERAL_NAME_new();\\r\\nif (gen == NULL)\\r\\nreturn 0;\\r\\nif (!X509_NAME_set(&gen->d.directoryName, nm)) {\\r\\nGENERAL_NAME_free(gen);\\r\\nreturn 0;\\r\\n}\\r\\ngen->type = GEN_DIRNAME;\\r\\nif (req->tbsRequest->requestorName)\\r\\nGENERAL_NAME_free(req->tbsRequest->requestorName);\\r\\nreq->tbsRequest->requestorName = gen;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_request_add1_cert(OCSP_REQUEST *req, X509 *cert)\\r\\n{\\r\\nOCSP_SIGNATURE *sig;\\r\\nif (!req->optionalSignature)\\r\\nreq->optionalSignature = OCSP_SIGNATURE_new();\\r\\nsig = req->optionalSignature;\\r\\nif (!sig)\\r\\nreturn 0;\\r\\nif (!cert)\\r\\nreturn 1;\\r\\nif (!sig->certs && !(sig->certs = sk_X509_new_null()))\\r\\nreturn 0;\\r\\nif (!sk_X509_push(sig->certs, cert))\\r\\nreturn 0;\\r\\nCRYPTO_add(&cert->references, 1, CRYPTO_LOCK_X509);\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_response_status(OCSP_RESPONSE *resp)\\r\\n{\\r\\nreturn ASN1_ENUMERATED_get(resp->responseStatus);\\r\\n}\\r\\nOCSP_BASICRESP *OCSP_response_get1_basic(OCSP_RESPONSE *resp)\\r\\n{\\r\\nOCSP_RESPBYTES *rb;\\r\\nrb = resp->responseBytes;\\r\\nif (!rb) {\\r\\nOCSPerr(OCSP_F_OCSP_RESPONSE_GET1_BASIC, OCSP_R_NO_RESPONSE_DATA);\\r\\nreturn NULL;\\r\\n}\\r\\nif (OBJ_obj2nid(rb->responseType) != NID_id_pkix_OCSP_basic) {\\r\\nOCSPerr(OCSP_F_OCSP_RESPONSE_GET1_BASIC, OCSP_R_NOT_BASIC_RESPONSE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ASN1_item_unpack(rb->response, ASN1_ITEM_rptr(OCSP_BASICRESP));\\r\\n}\\r\\nint OCSP_resp_count(OCSP_BASICRESP *bs)\\r\\n{\\r\\nif (!bs)\\r\\nreturn -1;\\r\\nreturn sk_OCSP_SINGLERESP_num(bs->tbsResponseData->responses);\\r\\n}\\r\\nOCSP_SINGLERESP *OCSP_resp_get0(OCSP_BASICRESP *bs, int idx)\\r\\n{\\r\\nif (!bs)\\r\\nreturn NULL;\\r\\nreturn sk_OCSP_SINGLERESP_value(bs->tbsResponseData->responses, idx);\\r\\n}\\r\\nint OCSP_resp_find(OCSP_BASICRESP *bs, OCSP_CERTID *id, int last)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(OCSP_SINGLERESP) *sresp;\\r\\nOCSP_SINGLERESP *single;\\r\\nif (!bs)\\r\\nreturn -1;\\r\\nif (last < 0)\\r\\nlast = 0;\\r\\nelse\\r\\nlast++;\\r\\nsresp = bs->tbsResponseData->responses;\\r\\nfor (i = last; i < sk_OCSP_SINGLERESP_num(sresp); i++) {\\r\\nsingle = sk_OCSP_SINGLERESP_value(sresp, i);\\r\\nif (!OCSP_id_cmp(id, single->certId))\\r\\nreturn i;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nint OCSP_single_get0_status(OCSP_SINGLERESP *single, int *reason,\\r\\nASN1_GENERALIZEDTIME **revtime,\\r\\nASN1_GENERALIZEDTIME **thisupd,\\r\\nASN1_GENERALIZEDTIME **nextupd)\\r\\n{\\r\\nint ret;\\r\\nOCSP_CERTSTATUS *cst;\\r\\nif (!single)\\r\\nreturn -1;\\r\\ncst = single->certStatus;\\r\\nret = cst->type;\\r\\nif (ret == V_OCSP_CERTSTATUS_REVOKED) {\\r\\nOCSP_REVOKEDINFO *rev = cst->value.revoked;\\r\\nif (revtime)\\r\\n*revtime = rev->revocationTime;\\r\\nif (reason) {\\r\\nif (rev->revocationReason)\\r\\n*reason = ASN1_ENUMERATED_get(rev->revocationReason);\\r\\nelse\\r\\n*reason = -1;\\r\\n}\\r\\n}\\r\\nif (thisupd)\\r\\n*thisupd = single->thisUpdate;\\r\\nif (nextupd)\\r\\n*nextupd = single->nextUpdate;\\r\\nreturn ret;\\r\\n}\\r\\nint OCSP_resp_find_status(OCSP_BASICRESP *bs, OCSP_CERTID *id, int *status,\\r\\nint *reason,\\r\\nASN1_GENERALIZEDTIME **revtime,\\r\\nASN1_GENERALIZEDTIME **thisupd,\\r\\nASN1_GENERALIZEDTIME **nextupd)\\r\\n{\\r\\nint i;\\r\\nOCSP_SINGLERESP *single;\\r\\ni = OCSP_resp_find(bs, id, -1);\\r\\nif (i < 0)\\r\\nreturn 0;\\r\\nsingle = OCSP_resp_get0(bs, i);\\r\\ni = OCSP_single_get0_status(single, reason, revtime, thisupd, nextupd);\\r\\nif (status)\\r\\n*status = i;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_check_validity(ASN1_GENERALIZEDTIME *thisupd,\\r\\nASN1_GENERALIZEDTIME *nextupd, long nsec, long maxsec)\\r\\n{\\r\\nint ret = 1;\\r\\ntime_t t_now, t_tmp;\\r\\ntime(&t_now);\\r\\nif (!ASN1_GENERALIZEDTIME_check(thisupd)) {\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_ERROR_IN_THISUPDATE_FIELD);\\r\\nret = 0;\\r\\n} else {\\r\\nt_tmp = t_now + nsec;\\r\\nif (X509_cmp_time(thisupd, &t_tmp) > 0) {\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_STATUS_NOT_YET_VALID);\\r\\nret = 0;\\r\\n}\\r\\nif (maxsec >= 0) {\\r\\nt_tmp = t_now - maxsec;\\r\\nif (X509_cmp_time(thisupd, &t_tmp) < 0) {\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_STATUS_TOO_OLD);\\r\\nret = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!nextupd)\\r\\nreturn ret;\\r\\nif (!ASN1_GENERALIZEDTIME_check(nextupd)) {\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_ERROR_IN_NEXTUPDATE_FIELD);\\r\\nret = 0;\\r\\n} else {\\r\\nt_tmp = t_now - nsec;\\r\\nif (X509_cmp_time(nextupd, &t_tmp) < 0) {\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY, OCSP_R_STATUS_EXPIRED);\\r\\nret = 0;\\r\\n}\\r\\n}\\r\\nif (ASN1_STRING_cmp(nextupd, thisupd) < 0) {\\r\\nOCSPerr(OCSP_F_OCSP_CHECK_VALIDITY,\\r\\nOCSP_R_NEXTUPDATE_BEFORE_THISUPDATE);\\r\\nret = 0;\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_seed_c", "target": 0, "func": "void SEED_set_key(const unsigned char rawkey[SEED_KEY_LENGTH],\\r\\nSEED_KEY_SCHEDULE *ks)\\r\\n# ifdef OPENSSL_FIPS\\r\\n{\\r\\nfips_cipher_abort(SEED);\\r\\nprivate_SEED_set_key(rawkey, ks);\\r\\n}\\r\\nvoid private_SEED_set_key(const unsigned char rawkey[SEED_KEY_LENGTH],\\r\\nSEED_KEY_SCHEDULE *ks)\\r\\n# endif\\r\\n{\\r\\nseed_word x1, x2, x3, x4;\\r\\nseed_word t0, t1;\\r\\nchar2word(rawkey, x1);\\r\\nchar2word(rawkey + 4, x2);\\r\\nchar2word(rawkey + 8, x3);\\r\\nchar2word(rawkey + 12, x4);\\r\\nt0 = (x1 + x3 - KC0) & 0xffffffff;\\r\\nt1 = (x2 - x4 + KC0) & 0xffffffff;\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[0]);\\r\\nKEYSCHEDULE_UPDATE1(t0, t1, x1, x2, x3, x4, KC1);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[2]);\\r\\n# if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nKEYSCHEDULE_UPDATE0(t0, t1, x1, x2, x3, x4, KC2);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[4]);\\r\\nKEYSCHEDULE_UPDATE1(t0, t1, x1, x2, x3, x4, KC3);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[6]);\\r\\nKEYSCHEDULE_UPDATE0(t0, t1, x1, x2, x3, x4, KC4);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[8]);\\r\\nKEYSCHEDULE_UPDATE1(t0, t1, x1, x2, x3, x4, KC5);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[10]);\\r\\nKEYSCHEDULE_UPDATE0(t0, t1, x1, x2, x3, x4, KC6);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[12]);\\r\\nKEYSCHEDULE_UPDATE1(t0, t1, x1, x2, x3, x4, KC7);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[14]);\\r\\nKEYSCHEDULE_UPDATE0(t0, t1, x1, x2, x3, x4, KC8);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[16]);\\r\\nKEYSCHEDULE_UPDATE1(t0, t1, x1, x2, x3, x4, KC9);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[18]);\\r\\nKEYSCHEDULE_UPDATE0(t0, t1, x1, x2, x3, x4, KC10);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[20]);\\r\\nKEYSCHEDULE_UPDATE1(t0, t1, x1, x2, x3, x4, KC11);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[22]);\\r\\nKEYSCHEDULE_UPDATE0(t0, t1, x1, x2, x3, x4, KC12);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[24]);\\r\\nKEYSCHEDULE_UPDATE1(t0, t1, x1, x2, x3, x4, KC13);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[26]);\\r\\nKEYSCHEDULE_UPDATE0(t0, t1, x1, x2, x3, x4, KC14);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[28]);\\r\\nKEYSCHEDULE_UPDATE1(t0, t1, x1, x2, x3, x4, KC15);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[30]);\\r\\n# else\\r\\n{\\r\\nint i;\\r\\nfor (i = 2; i < 16; i += 2) {\\r\\nKEYSCHEDULE_UPDATE0(t0, t1, x1, x2, x3, x4, KC[i]);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[i * 2]);\\r\\nKEYSCHEDULE_UPDATE1(t0, t1, x1, x2, x3, x4, KC[i + 1]);\\r\\nKEYUPDATE_TEMP(t0, t1, &ks->data[i * 2 + 2]);\\r\\n}\\r\\n}\\r\\n# endif\\r\\n}\\r\\nvoid SEED_encrypt(const unsigned char s[SEED_BLOCK_SIZE],\\r\\nunsigned char d[SEED_BLOCK_SIZE],\\r\\nconst SEED_KEY_SCHEDULE *ks)\\r\\n{\\r\\nseed_word x1, x2, x3, x4;\\r\\nseed_word t0, t1;\\r\\nchar2word(s, x1);\\r\\nchar2word(s + 4, x2);\\r\\nchar2word(s + 8, x3);\\r\\nchar2word(s + 12, x4);\\r\\n# if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 0);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 2);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 4);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 6);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 8);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 10);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 12);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 14);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 16);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 18);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 20);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 22);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 24);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 26);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 28);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 30);\\r\\n# else\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < 30; i += 4) {\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, i);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, i + 2);\\r\\n}\\r\\n}\\r\\n# endif\\r\\nword2char(x3, d);\\r\\nword2char(x4, d + 4);\\r\\nword2char(x1, d + 8);\\r\\nword2char(x2, d + 12);\\r\\n}\\r\\nvoid SEED_decrypt(const unsigned char s[SEED_BLOCK_SIZE],\\r\\nunsigned char d[SEED_BLOCK_SIZE],\\r\\nconst SEED_KEY_SCHEDULE *ks)\\r\\n{\\r\\nseed_word x1, x2, x3, x4;\\r\\nseed_word t0, t1;\\r\\nchar2word(s, x1);\\r\\nchar2word(s + 4, x2);\\r\\nchar2word(s + 8, x3);\\r\\nchar2word(s + 12, x4);\\r\\n# if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 30);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 28);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 26);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 24);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 22);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 20);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 18);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 16);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 14);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 12);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 10);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 8);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 6);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 4);\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, 2);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, 0);\\r\\n# else\\r\\n{\\r\\nint i;\\r\\nfor (i = 30; i > 0; i -= 4) {\\r\\nE_SEED(t0, t1, x1, x2, x3, x4, i);\\r\\nE_SEED(t0, t1, x3, x4, x1, x2, i - 2);\\r\\n}\\r\\n}\\r\\n# endif\\r\\nword2char(x3, d);\\r\\nword2char(x4, d + 4);\\r\\nword2char(x1, d + 8);\\r\\nword2char(x2, d + 12);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509cset_c", "target": 0, "func": "int X509_CRL_set_version(X509_CRL *x, long version)\\r\\n{\\r\\nif (x == NULL)\\r\\nreturn (0);\\r\\nif (x->crl->version == NULL) {\\r\\nif ((x->crl->version = M_ASN1_INTEGER_new()) == NULL)\\r\\nreturn (0);\\r\\n}\\r\\nreturn (ASN1_INTEGER_set(x->crl->version, version));\\r\\n}\\r\\nint X509_CRL_set_issuer_name(X509_CRL *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->crl == NULL))\\r\\nreturn (0);\\r\\nreturn (X509_NAME_set(&x->crl->issuer, name));\\r\\n}\\r\\nint X509_CRL_set_lastUpdate(X509_CRL *x, const ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif (x == NULL)\\r\\nreturn (0);\\r\\nin = x->crl->lastUpdate;\\r\\nif (in != tm) {\\r\\nin = M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL) {\\r\\nM_ASN1_TIME_free(x->crl->lastUpdate);\\r\\nx->crl->lastUpdate = in;\\r\\n}\\r\\n}\\r\\nreturn (in != NULL);\\r\\n}\\r\\nint X509_CRL_set_nextUpdate(X509_CRL *x, const ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif (x == NULL)\\r\\nreturn (0);\\r\\nin = x->crl->nextUpdate;\\r\\nif (in != tm) {\\r\\nin = M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL) {\\r\\nM_ASN1_TIME_free(x->crl->nextUpdate);\\r\\nx->crl->nextUpdate = in;\\r\\n}\\r\\n}\\r\\nreturn (in != NULL);\\r\\n}\\r\\nint X509_CRL_sort(X509_CRL *c)\\r\\n{\\r\\nint i;\\r\\nX509_REVOKED *r;\\r\\nsk_X509_REVOKED_sort(c->crl->revoked);\\r\\nfor (i = 0; i < sk_X509_REVOKED_num(c->crl->revoked); i++) {\\r\\nr = sk_X509_REVOKED_value(c->crl->revoked, i);\\r\\nr->sequence = i;\\r\\n}\\r\\nc->crl->enc.modified = 1;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_REVOKED_set_revocationDate(X509_REVOKED *x, ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif (x == NULL)\\r\\nreturn (0);\\r\\nin = x->revocationDate;\\r\\nif (in != tm) {\\r\\nin = M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL) {\\r\\nM_ASN1_TIME_free(x->revocationDate);\\r\\nx->revocationDate = in;\\r\\n}\\r\\n}\\r\\nreturn (in != NULL);\\r\\n}\\r\\nint X509_REVOKED_set_serialNumber(X509_REVOKED *x, ASN1_INTEGER *serial)\\r\\n{\\r\\nASN1_INTEGER *in;\\r\\nif (x == NULL)\\r\\nreturn (0);\\r\\nin = x->serialNumber;\\r\\nif (in != serial) {\\r\\nin = M_ASN1_INTEGER_dup(serial);\\r\\nif (in != NULL) {\\r\\nM_ASN1_INTEGER_free(x->serialNumber);\\r\\nx->serialNumber = in;\\r\\n}\\r\\n}\\r\\nreturn (in != NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_att_c", "target": 0, "func": "int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype,\\r\\nconst void *data, int len)\\r\\n{\\r\\nASN1_TYPE *ttmp;\\r\\nASN1_STRING *stmp = NULL;\\r\\nint atype = 0;\\r\\nif (!attr)\\r\\nreturn 0;\\r\\nif (attrtype & MBSTRING_FLAG) {\\r\\nstmp = ASN1_STRING_set_by_NID(NULL, data, len, attrtype,\\r\\nOBJ_obj2nid(attr->object));\\r\\nif (!stmp) {\\r\\nX509err(X509_F_X509_ATTRIBUTE_SET1_DATA, ERR_R_ASN1_LIB);\\r\\nreturn 0;\\r\\n}\\r\\natype = stmp->type;\\r\\n} else if (len != -1) {\\r\\nif (!(stmp = ASN1_STRING_type_new(attrtype)))\\r\\ngoto err;\\r\\nif (!ASN1_STRING_set(stmp, data, len))\\r\\ngoto err;\\r\\natype = attrtype;\\r\\n}\\r\\nif (!(attr->value.set = sk_ASN1_TYPE_new_null()))\\r\\ngoto err;\\r\\nattr->single = 0;\\r\\nif (attrtype == 0)\\r\\nreturn 1;\\r\\nif (!(ttmp = ASN1_TYPE_new()))\\r\\ngoto err;\\r\\nif ((len == -1) && !(attrtype & MBSTRING_FLAG)) {\\r\\nif (!ASN1_TYPE_set1(ttmp, attrtype, data))\\r\\ngoto err;\\r\\n} else\\r\\nASN1_TYPE_set(ttmp, atype, stmp);\\r\\nif (!sk_ASN1_TYPE_push(attr->value.set, ttmp))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nX509err(X509_F_X509_ATTRIBUTE_SET1_DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nint X509_ATTRIBUTE_count(X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif (!attr->single)\\r\\nreturn sk_ASN1_TYPE_num(attr->value.set);\\r\\nif (attr->value.single)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr)\\r\\n{\\r\\nif (attr == NULL)\\r\\nreturn (NULL);\\r\\nreturn (attr->object);\\r\\n}\\r\\nvoid *X509_ATTRIBUTE_get0_data(X509_ATTRIBUTE *attr, int idx,\\r\\nint atrtype, void *data)\\r\\n{\\r\\nASN1_TYPE *ttmp;\\r\\nttmp = X509_ATTRIBUTE_get0_type(attr, idx);\\r\\nif (!ttmp)\\r\\nreturn NULL;\\r\\nif (atrtype != ASN1_TYPE_get(ttmp)) {\\r\\nX509err(X509_F_X509_ATTRIBUTE_GET0_DATA, X509_R_WRONG_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ttmp->value.ptr;\\r\\n}\\r\\nASN1_TYPE *X509_ATTRIBUTE_get0_type(X509_ATTRIBUTE *attr, int idx)\\r\\n{\\r\\nif (attr == NULL)\\r\\nreturn (NULL);\\r\\nif (idx >= X509_ATTRIBUTE_count(attr))\\r\\nreturn NULL;\\r\\nif (!attr->single)\\r\\nreturn sk_ASN1_TYPE_value(attr->value.set, idx);\\r\\nelse\\r\\nreturn attr->value.single;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_hm_ameth_c", "target": 0, "func": "static int hmac_size(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn EVP_MAX_MD_SIZE;\\r\\n}\\r\\nstatic void hmac_key_free(EVP_PKEY *pkey)\\r\\n{\\r\\nASN1_OCTET_STRING *os = (ASN1_OCTET_STRING *)pkey->pkey.ptr;\\r\\nif (os) {\\r\\nif (os->data)\\r\\nOPENSSL_cleanse(os->data, os->length);\\r\\nASN1_OCTET_STRING_free(os);\\r\\n}\\r\\n}\\r\\nstatic int hmac_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)\\r\\n{\\r\\nswitch (op) {\\r\\ncase ASN1_PKEY_CTRL_DEFAULT_MD_NID:\\r\\n*(int *)arg2 = NID_sha256;\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\n}\\r\\nstatic int old_hmac_decode(EVP_PKEY *pkey,\\r\\nconst unsigned char **pder, int derlen)\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nos = ASN1_OCTET_STRING_new();\\r\\nif (!os || !ASN1_OCTET_STRING_set(os, *pder, derlen))\\r\\nreturn 0;\\r\\nEVP_PKEY_assign(pkey, EVP_PKEY_HMAC, os);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int old_hmac_encode(const EVP_PKEY *pkey, unsigned char **pder)\\r\\n{\\r\\nint inc;\\r\\nASN1_OCTET_STRING *os = (ASN1_OCTET_STRING *)pkey->pkey.ptr;\\r\\nif (pder) {\\r\\nif (!*pder) {\\r\\n*pder = OPENSSL_malloc(os->length);\\r\\ninc = 0;\\r\\n} else\\r\\ninc = 1;\\r\\nmemcpy(*pder, os->data, os->length);\\r\\nif (inc)\\r\\n*pder += os->length;\\r\\n}\\r\\nreturn os->length;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tb_rsa_c", "target": 0, "func": "void ENGINE_unregister_RSA(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&rsa_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_RSA(void)\\r\\n{\\r\\nengine_table_cleanup(&rsa_table);\\r\\n}\\r\\nint ENGINE_register_RSA(ENGINE *e)\\r\\n{\\r\\nif (e->rsa_meth)\\r\\nreturn engine_table_register(&rsa_table,\\r\\nengine_unregister_all_RSA, e, &dummy_nid,\\r\\n1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_RSA()\\r\\n{\\r\\nENGINE *e;\\r\\nfor (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))\\r\\nENGINE_register_RSA(e);\\r\\n}\\r\\nint ENGINE_set_default_RSA(ENGINE *e)\\r\\n{\\r\\nif (e->rsa_meth)\\r\\nreturn engine_table_register(&rsa_table,\\r\\nengine_unregister_all_RSA, e, &dummy_nid,\\r\\n1, 1);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_RSA(void)\\r\\n{\\r\\nreturn engine_table_select(&rsa_table, dummy_nid);\\r\\n}\\r\\nconst RSA_METHOD *ENGINE_get_RSA(const ENGINE *e)\\r\\n{\\r\\nreturn e->rsa_meth;\\r\\n}\\r\\nint ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth)\\r\\n{\\r\\ne->rsa_meth = rsa_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_sign_c", "target": 0, "func": "int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1, X509_ALGOR *algor2,\\r\\nASN1_BIT_STRING *signature, char *data, EVP_PKEY *pkey,\\r\\nconst EVP_MD *type)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char *p, *buf_in = NULL, *buf_out = NULL;\\r\\nint i, inl = 0, outl = 0, outll = 0;\\r\\nX509_ALGOR *a;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nfor (i = 0; i < 2; i++) {\\r\\nif (i == 0)\\r\\na = algor1;\\r\\nelse\\r\\na = algor2;\\r\\nif (a == NULL)\\r\\ncontinue;\\r\\nif (type->pkey_type == NID_dsaWithSHA1) {\\r\\nASN1_TYPE_free(a->parameter);\\r\\na->parameter = NULL;\\r\\n} else if ((a->parameter == NULL) ||\\r\\n(a->parameter->type != V_ASN1_NULL)) {\\r\\nASN1_TYPE_free(a->parameter);\\r\\nif ((a->parameter = ASN1_TYPE_new()) == NULL)\\r\\ngoto err;\\r\\na->parameter->type = V_ASN1_NULL;\\r\\n}\\r\\nASN1_OBJECT_free(a->algorithm);\\r\\na->algorithm = OBJ_nid2obj(type->pkey_type);\\r\\nif (a->algorithm == NULL) {\\r\\nASN1err(ASN1_F_ASN1_SIGN, ASN1_R_UNKNOWN_OBJECT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (a->algorithm->length == 0) {\\r\\nASN1err(ASN1_F_ASN1_SIGN,\\r\\nASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ninl = i2d(data, NULL);\\r\\nbuf_in = (unsigned char *)OPENSSL_malloc((unsigned int)inl);\\r\\noutll = outl = EVP_PKEY_size(pkey);\\r\\nbuf_out = (unsigned char *)OPENSSL_malloc((unsigned int)outl);\\r\\nif ((buf_in == NULL) || (buf_out == NULL)) {\\r\\noutl = 0;\\r\\nASN1err(ASN1_F_ASN1_SIGN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np = buf_in;\\r\\ni2d(data, &p);\\r\\nif (!EVP_SignInit_ex(&ctx, type, NULL)\\r\\n|| !EVP_SignUpdate(&ctx, (unsigned char *)buf_in, inl)\\r\\n|| !EVP_SignFinal(&ctx, (unsigned char *)buf_out,\\r\\n(unsigned int *)&outl, pkey)) {\\r\\noutl = 0;\\r\\nASN1err(ASN1_F_ASN1_SIGN, ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (signature->data != NULL)\\r\\nOPENSSL_free(signature->data);\\r\\nsignature->data = buf_out;\\r\\nbuf_out = NULL;\\r\\nsignature->length = outl;\\r\\nsignature->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\nsignature->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nif (buf_in != NULL) {\\r\\nOPENSSL_cleanse((char *)buf_in, (unsigned int)inl);\\r\\nOPENSSL_free(buf_in);\\r\\n}\\r\\nif (buf_out != NULL) {\\r\\nOPENSSL_cleanse((char *)buf_out, outll);\\r\\nOPENSSL_free(buf_out);\\r\\n}\\r\\nreturn (outl);\\r\\n}\\r\\nint ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1,\\r\\nX509_ALGOR *algor2, ASN1_BIT_STRING *signature, void *asn,\\r\\nEVP_PKEY *pkey, const EVP_MD *type)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nif (!EVP_DigestSignInit(&ctx, NULL, type, NULL, pkey)) {\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn 0;\\r\\n}\\r\\nreturn ASN1_item_sign_ctx(it, algor1, algor2, signature, asn, &ctx);\\r\\n}\\r\\nint ASN1_item_sign_ctx(const ASN1_ITEM *it,\\r\\nX509_ALGOR *algor1, X509_ALGOR *algor2,\\r\\nASN1_BIT_STRING *signature, void *asn, EVP_MD_CTX *ctx)\\r\\n{\\r\\nconst EVP_MD *type;\\r\\nEVP_PKEY *pkey;\\r\\nunsigned char *buf_in = NULL, *buf_out = NULL;\\r\\nsize_t inl = 0, outl = 0, outll = 0;\\r\\nint signid, paramtype;\\r\\nint rv;\\r\\ntype = EVP_MD_CTX_md(ctx);\\r\\npkey = EVP_PKEY_CTX_get0_pkey(ctx->pctx);\\r\\nif (!type || !pkey) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ASN1_R_CONTEXT_NOT_INITIALISED);\\r\\nreturn 0;\\r\\n}\\r\\nif (pkey->ameth->item_sign) {\\r\\nrv = pkey->ameth->item_sign(ctx, it, asn, algor1, algor2, signature);\\r\\nif (rv == 1)\\r\\noutl = signature->length;\\r\\nif (rv <= 0)\\r\\nASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_EVP_LIB);\\r\\nif (rv <= 1)\\r\\ngoto err;\\r\\n} else\\r\\nrv = 2;\\r\\nif (rv == 2) {\\r\\nif (type->flags & EVP_MD_FLAG_PKEY_METHOD_SIGNATURE) {\\r\\nif (!pkey->ameth ||\\r\\n!OBJ_find_sigid_by_algs(&signid,\\r\\nEVP_MD_nid(type),\\r\\npkey->ameth->pkey_id)) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX,\\r\\nASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED);\\r\\nreturn 0;\\r\\n}\\r\\n} else\\r\\nsignid = type->pkey_type;\\r\\nif (pkey->ameth->pkey_flags & ASN1_PKEY_SIGPARAM_NULL)\\r\\nparamtype = V_ASN1_NULL;\\r\\nelse\\r\\nparamtype = V_ASN1_UNDEF;\\r\\nif (algor1)\\r\\nX509_ALGOR_set0(algor1, OBJ_nid2obj(signid), paramtype, NULL);\\r\\nif (algor2)\\r\\nX509_ALGOR_set0(algor2, OBJ_nid2obj(signid), paramtype, NULL);\\r\\n}\\r\\ninl = ASN1_item_i2d(asn, &buf_in, it);\\r\\noutll = outl = EVP_PKEY_size(pkey);\\r\\nbuf_out = OPENSSL_malloc((unsigned int)outl);\\r\\nif ((buf_in == NULL) || (buf_out == NULL)) {\\r\\noutl = 0;\\r\\nASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DigestSignUpdate(ctx, buf_in, inl)\\r\\n|| !EVP_DigestSignFinal(ctx, buf_out, &outl)) {\\r\\noutl = 0;\\r\\nASN1err(ASN1_F_ASN1_ITEM_SIGN_CTX, ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (signature->data != NULL)\\r\\nOPENSSL_free(signature->data);\\r\\nsignature->data = buf_out;\\r\\nbuf_out = NULL;\\r\\nsignature->length = outl;\\r\\nsignature->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\nsignature->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(ctx);\\r\\nif (buf_in != NULL) {\\r\\nOPENSSL_cleanse((char *)buf_in, (unsigned int)inl);\\r\\nOPENSSL_free(buf_in);\\r\\n}\\r\\nif (buf_out != NULL) {\\r\\nOPENSSL_cleanse((char *)buf_out, outll);\\r\\nOPENSSL_free(buf_out);\\r\\n}\\r\\nreturn (outl);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_digest_c", "target": 0, "func": "int ASN1_digest(i2d_of_void *i2d, const EVP_MD *type, char *data,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nint i;\\r\\nunsigned char *str, *p;\\r\\ni = i2d(data, NULL);\\r\\nif ((str = (unsigned char *)OPENSSL_malloc(i)) == NULL) {\\r\\nASN1err(ASN1_F_ASN1_DIGEST, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\np = str;\\r\\ni2d(data, &p);\\r\\nif (!EVP_Digest(str, i, md, len, type, NULL))\\r\\nreturn 0;\\r\\nOPENSSL_free(str);\\r\\nreturn (1);\\r\\n}\\r\\nint ASN1_item_digest(const ASN1_ITEM *it, const EVP_MD *type, void *asn,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nint i;\\r\\nunsigned char *str = NULL;\\r\\ni = ASN1_item_i2d(asn, &str, it);\\r\\nif (!str)\\r\\nreturn (0);\\r\\nif (!EVP_Digest(str, i, md, len, type, NULL))\\r\\nreturn 0;\\r\\nOPENSSL_free(str);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_shift_c", "target": 0, "func": "int BN_lshift1(BIGNUM *r, const BIGNUM *a)\\r\\n{\\r\\nregister BN_ULONG *ap, *rp, t, c;\\r\\nint i;\\r\\nbn_check_top(r);\\r\\nbn_check_top(a);\\r\\nif (r != a) {\\r\\nr->neg = a->neg;\\r\\nif (bn_wexpand(r, a->top + 1) == NULL)\\r\\nreturn (0);\\r\\nr->top = a->top;\\r\\n} else {\\r\\nif (bn_wexpand(r, a->top + 1) == NULL)\\r\\nreturn (0);\\r\\n}\\r\\nap = a->d;\\r\\nrp = r->d;\\r\\nc = 0;\\r\\nfor (i = 0; i < a->top; i++) {\\r\\nt = *(ap++);\\r\\n*(rp++) = ((t << 1) | c) & BN_MASK2;\\r\\nc = (t & BN_TBIT) ? 1 : 0;\\r\\n}\\r\\nif (c) {\\r\\n*rp = 1;\\r\\nr->top++;\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn (1);\\r\\n}\\r\\nint BN_rshift1(BIGNUM *r, const BIGNUM *a)\\r\\n{\\r\\nBN_ULONG *ap, *rp, t, c;\\r\\nint i, j;\\r\\nbn_check_top(r);\\r\\nbn_check_top(a);\\r\\nif (BN_is_zero(a)) {\\r\\nBN_zero(r);\\r\\nreturn (1);\\r\\n}\\r\\ni = a->top;\\r\\nap = a->d;\\r\\nj = i - (ap[i - 1] == 1);\\r\\nif (a != r) {\\r\\nif (bn_wexpand(r, j) == NULL)\\r\\nreturn (0);\\r\\nr->neg = a->neg;\\r\\n}\\r\\nrp = r->d;\\r\\nt = ap[--i];\\r\\nc = (t & 1) ? BN_TBIT : 0;\\r\\nif (t >>= 1)\\r\\nrp[i] = t;\\r\\nwhile (i > 0) {\\r\\nt = ap[--i];\\r\\nrp[i] = ((t >> 1) & BN_MASK2) | c;\\r\\nc = (t & 1) ? BN_TBIT : 0;\\r\\n}\\r\\nr->top = j;\\r\\nbn_check_top(r);\\r\\nreturn (1);\\r\\n}\\r\\nint BN_lshift(BIGNUM *r, const BIGNUM *a, int n)\\r\\n{\\r\\nint i, nw, lb, rb;\\r\\nBN_ULONG *t, *f;\\r\\nBN_ULONG l;\\r\\nbn_check_top(r);\\r\\nbn_check_top(a);\\r\\nr->neg = a->neg;\\r\\nnw = n / BN_BITS2;\\r\\nif (bn_wexpand(r, a->top + nw + 1) == NULL)\\r\\nreturn (0);\\r\\nlb = n % BN_BITS2;\\r\\nrb = BN_BITS2 - lb;\\r\\nf = a->d;\\r\\nt = r->d;\\r\\nt[a->top + nw] = 0;\\r\\nif (lb == 0)\\r\\nfor (i = a->top - 1; i >= 0; i--)\\r\\nt[nw + i] = f[i];\\r\\nelse\\r\\nfor (i = a->top - 1; i >= 0; i--) {\\r\\nl = f[i];\\r\\nt[nw + i + 1] |= (l >> rb) & BN_MASK2;\\r\\nt[nw + i] = (l << lb) & BN_MASK2;\\r\\n}\\r\\nmemset(t, 0, nw * sizeof(t[0]));\\r\\nr->top = a->top + nw + 1;\\r\\nbn_correct_top(r);\\r\\nbn_check_top(r);\\r\\nreturn (1);\\r\\n}\\r\\nint BN_rshift(BIGNUM *r, const BIGNUM *a, int n)\\r\\n{\\r\\nint i, j, nw, lb, rb;\\r\\nBN_ULONG *t, *f;\\r\\nBN_ULONG l, tmp;\\r\\nbn_check_top(r);\\r\\nbn_check_top(a);\\r\\nnw = n / BN_BITS2;\\r\\nrb = n % BN_BITS2;\\r\\nlb = BN_BITS2 - rb;\\r\\nif (nw >= a->top || a->top == 0) {\\r\\nBN_zero(r);\\r\\nreturn (1);\\r\\n}\\r\\ni = (BN_num_bits(a) - n + (BN_BITS2 - 1)) / BN_BITS2;\\r\\nif (r != a) {\\r\\nr->neg = a->neg;\\r\\nif (bn_wexpand(r, i) == NULL)\\r\\nreturn (0);\\r\\n} else {\\r\\nif (n == 0)\\r\\nreturn 1;\\r\\n}\\r\\nf = &(a->d[nw]);\\r\\nt = r->d;\\r\\nj = a->top - nw;\\r\\nr->top = i;\\r\\nif (rb == 0) {\\r\\nfor (i = j; i != 0; i--)\\r\\n*(t++) = *(f++);\\r\\n} else {\\r\\nl = *(f++);\\r\\nfor (i = j - 1; i != 0; i--) {\\r\\ntmp = (l >> rb) & BN_MASK2;\\r\\nl = *(f++);\\r\\n*(t++) = (tmp | (l << lb)) & BN_MASK2;\\r\\n}\\r\\nif ((l = (l >> rb) & BN_MASK2))\\r\\n*(t) = l;\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_md5_one_c", "target": 0, "func": "unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nMD5_CTX c;\\r\\nstatic unsigned char m[MD5_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nif (!MD5_Init(&c))\\r\\nreturn NULL;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nMD5_Update(&c, d, n);\\r\\n#else\\r\\n{\\r\\nchar temp[1024];\\r\\nunsigned long chunk;\\r\\nwhile (n > 0) {\\r\\nchunk = (n > sizeof(temp)) ? sizeof(temp) : n;\\r\\nebcdic2ascii(temp, d, chunk);\\r\\nMD5_Update(&c, temp, chunk);\\r\\nn -= chunk;\\r\\nd += chunk;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nMD5_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_ameth_c", "target": 0, "func": "static int rsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char *penc = NULL;\\r\\nint penclen;\\r\\npenclen = i2d_RSAPublicKey(pkey->pkey.rsa, &penc);\\r\\nif (penclen <= 0)\\r\\nreturn 0;\\r\\nif (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(EVP_PKEY_RSA),\\r\\nV_ASN1_NULL, NULL, penc, penclen))\\r\\nreturn 1;\\r\\nOPENSSL_free(penc);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int rsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nint pklen;\\r\\nRSA *rsa = NULL;\\r\\nif (!X509_PUBKEY_get0_param(NULL, &p, &pklen, NULL, pubkey))\\r\\nreturn 0;\\r\\nif (!(rsa = d2i_RSAPublicKey(NULL, &p, pklen))) {\\r\\nRSAerr(RSA_F_RSA_PUB_DECODE, ERR_R_RSA_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_assign_RSA(pkey, rsa);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rsa_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nif (BN_cmp(b->pkey.rsa->n, a->pkey.rsa->n) != 0\\r\\n|| BN_cmp(b->pkey.rsa->e, a->pkey.rsa->e) != 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int old_rsa_priv_decode(EVP_PKEY *pkey,\\r\\nconst unsigned char **pder, int derlen)\\r\\n{\\r\\nRSA *rsa;\\r\\nif (!(rsa = d2i_RSAPrivateKey(NULL, pder, derlen))) {\\r\\nRSAerr(RSA_F_OLD_RSA_PRIV_DECODE, ERR_R_RSA_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_assign_RSA(pkey, rsa);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int old_rsa_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)\\r\\n{\\r\\nreturn i2d_RSAPrivateKey(pkey->pkey.rsa, pder);\\r\\n}\\r\\nstatic int rsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\\r\\n{\\r\\nunsigned char *rk = NULL;\\r\\nint rklen;\\r\\nrklen = i2d_RSAPrivateKey(pkey->pkey.rsa, &rk);\\r\\nif (rklen <= 0) {\\r\\nRSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_rsaEncryption), 0,\\r\\nV_ASN1_NULL, NULL, rk, rklen)) {\\r\\nRSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nint pklen;\\r\\nif (!PKCS8_pkey_get0(NULL, &p, &pklen, NULL, p8))\\r\\nreturn 0;\\r\\nreturn old_rsa_priv_decode(pkey, &p, pklen);\\r\\n}\\r\\nstatic int int_rsa_size(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn RSA_size(pkey->pkey.rsa);\\r\\n}\\r\\nstatic int rsa_bits(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn BN_num_bits(pkey->pkey.rsa->n);\\r\\n}\\r\\nstatic void int_rsa_free(EVP_PKEY *pkey)\\r\\n{\\r\\nRSA_free(pkey->pkey.rsa);\\r\\n}\\r\\nstatic void update_buflen(const BIGNUM *b, size_t *pbuflen)\\r\\n{\\r\\nsize_t i;\\r\\nif (!b)\\r\\nreturn;\\r\\nif (*pbuflen < (i = (size_t)BN_num_bytes(b)))\\r\\n*pbuflen = i;\\r\\n}\\r\\nstatic int do_rsa_print(BIO *bp, const RSA *x, int off, int priv)\\r\\n{\\r\\nchar *str;\\r\\nconst char *s;\\r\\nunsigned char *m = NULL;\\r\\nint ret = 0, mod_len = 0;\\r\\nsize_t buf_len = 0;\\r\\nupdate_buflen(x->n, &buf_len);\\r\\nupdate_buflen(x->e, &buf_len);\\r\\nif (priv) {\\r\\nupdate_buflen(x->d, &buf_len);\\r\\nupdate_buflen(x->p, &buf_len);\\r\\nupdate_buflen(x->q, &buf_len);\\r\\nupdate_buflen(x->dmp1, &buf_len);\\r\\nupdate_buflen(x->dmq1, &buf_len);\\r\\nupdate_buflen(x->iqmp, &buf_len);\\r\\n}\\r\\nm = (unsigned char *)OPENSSL_malloc(buf_len + 10);\\r\\nif (m == NULL) {\\r\\nRSAerr(RSA_F_DO_RSA_PRINT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (x->n != NULL)\\r\\nmod_len = BN_num_bits(x->n);\\r\\nif (!BIO_indent(bp, off, 128))\\r\\ngoto err;\\r\\nif (priv && x->d) {\\r\\nif (BIO_printf(bp, \"Private-Key: (%d bit)\\n\", mod_len)\\r\\n<= 0)\\r\\ngoto err;\\r\\nstr = \"modulus:\";\\r\\ns = \"publicExponent:\";\\r\\n} else {\\r\\nif (BIO_printf(bp, \"Public-Key: (%d bit)\\n\", mod_len)\\r\\n<= 0)\\r\\ngoto err;\\r\\nstr = \"Modulus:\";\\r\\ns = \"Exponent:\";\\r\\n}\\r\\nif (!ASN1_bn_print(bp, str, x->n, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, s, x->e, m, off))\\r\\ngoto err;\\r\\nif (priv) {\\r\\nif (!ASN1_bn_print(bp, \"privateExponent:\", x->d, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"prime1:\", x->p, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"prime2:\", x->q, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"exponent1:\", x->dmp1, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"exponent2:\", x->dmq1, m, off))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"coefficient:\", x->iqmp, m, off))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (m != NULL)\\r\\nOPENSSL_free(m);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int rsa_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_rsa_print(bp, pkey->pkey.rsa, indent, 0);\\r\\n}\\r\\nstatic int rsa_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_rsa_print(bp, pkey->pkey.rsa, indent, 1);\\r\\n}\\r\\nstatic X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nint plen;\\r\\nif (alg == NULL)\\r\\nreturn NULL;\\r\\nif (OBJ_obj2nid(alg->algorithm) != NID_mgf1)\\r\\nreturn NULL;\\r\\nif (alg->parameter->type != V_ASN1_SEQUENCE)\\r\\nreturn NULL;\\r\\np = alg->parameter->value.sequence->data;\\r\\nplen = alg->parameter->value.sequence->length;\\r\\nreturn d2i_X509_ALGOR(NULL, &p, plen);\\r\\n}\\r\\nstatic RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\\r\\nX509_ALGOR **pmaskHash)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nint plen;\\r\\nRSA_PSS_PARAMS *pss;\\r\\n*pmaskHash = NULL;\\r\\nif (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\\r\\nreturn NULL;\\r\\np = alg->parameter->value.sequence->data;\\r\\nplen = alg->parameter->value.sequence->length;\\r\\npss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\\r\\nif (!pss)\\r\\nreturn NULL;\\r\\n*pmaskHash = rsa_mgf1_decode(pss->maskGenAlgorithm);\\r\\nreturn pss;\\r\\n}\\r\\nstatic int rsa_pss_param_print(BIO *bp, RSA_PSS_PARAMS *pss,\\r\\nX509_ALGOR *maskHash, int indent)\\r\\n{\\r\\nint rv = 0;\\r\\nif (!pss) {\\r\\nif (BIO_puts(bp, \" (INVALID PSS PARAMETERS)\\n\") <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\nif (!BIO_indent(bp, indent, 128))\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"Hash Algorithm: \") <= 0)\\r\\ngoto err;\\r\\nif (pss->hashAlgorithm) {\\r\\nif (i2a_ASN1_OBJECT(bp, pss->hashAlgorithm->algorithm) <= 0)\\r\\ngoto err;\\r\\n} else if (BIO_puts(bp, \"sha1 (default)\") <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\nif (!BIO_indent(bp, indent, 128))\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"Mask Algorithm: \") <= 0)\\r\\ngoto err;\\r\\nif (pss->maskGenAlgorithm) {\\r\\nif (i2a_ASN1_OBJECT(bp, pss->maskGenAlgorithm->algorithm) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \" with \") <= 0)\\r\\ngoto err;\\r\\nif (maskHash) {\\r\\nif (i2a_ASN1_OBJECT(bp, maskHash->algorithm) <= 0)\\r\\ngoto err;\\r\\n} else if (BIO_puts(bp, \"INVALID\") <= 0)\\r\\ngoto err;\\r\\n} else if (BIO_puts(bp, \"mgf1 with sha1 (default)\") <= 0)\\r\\ngoto err;\\r\\nBIO_puts(bp, \"\\n\");\\r\\nif (!BIO_indent(bp, indent, 128))\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"Salt Length: 0x\") <= 0)\\r\\ngoto err;\\r\\nif (pss->saltLength) {\\r\\nif (i2a_ASN1_INTEGER(bp, pss->saltLength) <= 0)\\r\\ngoto err;\\r\\n} else if (BIO_puts(bp, \"14 (default)\") <= 0)\\r\\ngoto err;\\r\\nBIO_puts(bp, \"\\n\");\\r\\nif (!BIO_indent(bp, indent, 128))\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"Trailer Field: 0x\") <= 0)\\r\\ngoto err;\\r\\nif (pss->trailerField) {\\r\\nif (i2a_ASN1_INTEGER(bp, pss->trailerField) <= 0)\\r\\ngoto err;\\r\\n} else if (BIO_puts(bp, \"BC (default)\") <= 0)\\r\\ngoto err;\\r\\nBIO_puts(bp, \"\\n\");\\r\\nrv = 1;\\r\\nerr:\\r\\nreturn rv;\\r\\n}\\r\\nstatic int rsa_sig_print(BIO *bp, const X509_ALGOR *sigalg,\\r\\nconst ASN1_STRING *sig, int indent, ASN1_PCTX *pctx)\\r\\n{\\r\\nif (OBJ_obj2nid(sigalg->algorithm) == NID_rsassaPss) {\\r\\nint rv;\\r\\nRSA_PSS_PARAMS *pss;\\r\\nX509_ALGOR *maskHash;\\r\\npss = rsa_pss_decode(sigalg, &maskHash);\\r\\nrv = rsa_pss_param_print(bp, pss, maskHash, indent);\\r\\nif (pss)\\r\\nRSA_PSS_PARAMS_free(pss);\\r\\nif (maskHash)\\r\\nX509_ALGOR_free(maskHash);\\r\\nif (!rv)\\r\\nreturn 0;\\r\\n} else if (!sig && BIO_puts(bp, \"\\n\") <= 0)\\r\\nreturn 0;\\r\\nif (sig)\\r\\nreturn X509_signature_dump(bp, sig, indent);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)\\r\\n{\\r\\nX509_ALGOR *alg = NULL;\\r\\nswitch (op) {\\r\\ncase ASN1_PKEY_CTRL_PKCS7_SIGN:\\r\\nif (arg1 == 0)\\r\\nPKCS7_SIGNER_INFO_get0_algs(arg2, NULL, NULL, &alg);\\r\\nbreak;\\r\\ncase ASN1_PKEY_CTRL_PKCS7_ENCRYPT:\\r\\nif (arg1 == 0)\\r\\nPKCS7_RECIP_INFO_get0_alg(arg2, &alg);\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_CMS\\r\\ncase ASN1_PKEY_CTRL_CMS_SIGN:\\r\\nif (arg1 == 0)\\r\\nreturn rsa_cms_sign(arg2);\\r\\nelse if (arg1 == 1)\\r\\nreturn rsa_cms_verify(arg2);\\r\\nbreak;\\r\\ncase ASN1_PKEY_CTRL_CMS_ENVELOPE:\\r\\nif (arg1 == 0)\\r\\nreturn rsa_cms_encrypt(arg2);\\r\\nelse if (arg1 == 1)\\r\\nreturn rsa_cms_decrypt(arg2);\\r\\nbreak;\\r\\ncase ASN1_PKEY_CTRL_CMS_RI_TYPE:\\r\\n*(int *)arg2 = CMS_RECIPINFO_TRANS;\\r\\nreturn 1;\\r\\n#endif\\r\\ncase ASN1_PKEY_CTRL_DEFAULT_MD_NID:\\r\\n*(int *)arg2 = NID_sha256;\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\nif (alg)\\r\\nX509_ALGOR_set0(alg, OBJ_nid2obj(NID_rsaEncryption), V_ASN1_NULL, 0);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rsa_md_to_algor(X509_ALGOR **palg, const EVP_MD *md)\\r\\n{\\r\\nif (EVP_MD_type(md) == NID_sha1)\\r\\nreturn 1;\\r\\n*palg = X509_ALGOR_new();\\r\\nif (!*palg)\\r\\nreturn 0;\\r\\nX509_ALGOR_set_md(*palg, md);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rsa_md_to_mgf1(X509_ALGOR **palg, const EVP_MD *mgf1md)\\r\\n{\\r\\nX509_ALGOR *algtmp = NULL;\\r\\nASN1_STRING *stmp = NULL;\\r\\n*palg = NULL;\\r\\nif (EVP_MD_type(mgf1md) == NID_sha1)\\r\\nreturn 1;\\r\\nif (!rsa_md_to_algor(&algtmp, mgf1md))\\r\\ngoto err;\\r\\nif (!ASN1_item_pack(algtmp, ASN1_ITEM_rptr(X509_ALGOR), &stmp))\\r\\ngoto err;\\r\\n*palg = X509_ALGOR_new();\\r\\nif (!*palg)\\r\\ngoto err;\\r\\nX509_ALGOR_set0(*palg, OBJ_nid2obj(NID_mgf1), V_ASN1_SEQUENCE, stmp);\\r\\nstmp = NULL;\\r\\nerr:\\r\\nif (stmp)\\r\\nASN1_STRING_free(stmp);\\r\\nif (algtmp)\\r\\nX509_ALGOR_free(algtmp);\\r\\nif (*palg)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic const EVP_MD *rsa_algor_to_md(X509_ALGOR *alg)\\r\\n{\\r\\nconst EVP_MD *md;\\r\\nif (!alg)\\r\\nreturn EVP_sha1();\\r\\nmd = EVP_get_digestbyobj(alg->algorithm);\\r\\nif (md == NULL)\\r\\nRSAerr(RSA_F_RSA_ALGOR_TO_MD, RSA_R_UNKNOWN_DIGEST);\\r\\nreturn md;\\r\\n}\\r\\nstatic const EVP_MD *rsa_mgf1_to_md(X509_ALGOR *alg, X509_ALGOR *maskHash)\\r\\n{\\r\\nconst EVP_MD *md;\\r\\nif (!alg)\\r\\nreturn EVP_sha1();\\r\\nif (OBJ_obj2nid(alg->algorithm) != NID_mgf1) {\\r\\nRSAerr(RSA_F_RSA_MGF1_TO_MD, RSA_R_UNSUPPORTED_MASK_ALGORITHM);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!maskHash) {\\r\\nRSAerr(RSA_F_RSA_MGF1_TO_MD, RSA_R_UNSUPPORTED_MASK_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nmd = EVP_get_digestbyobj(maskHash->algorithm);\\r\\nif (md == NULL) {\\r\\nRSAerr(RSA_F_RSA_MGF1_TO_MD, RSA_R_UNKNOWN_MASK_DIGEST);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn md;\\r\\n}\\r\\nstatic ASN1_STRING *rsa_ctx_to_pss(EVP_PKEY_CTX *pkctx)\\r\\n{\\r\\nconst EVP_MD *sigmd, *mgf1md;\\r\\nRSA_PSS_PARAMS *pss = NULL;\\r\\nASN1_STRING *os = NULL;\\r\\nEVP_PKEY *pk = EVP_PKEY_CTX_get0_pkey(pkctx);\\r\\nint saltlen, rv = 0;\\r\\nif (EVP_PKEY_CTX_get_signature_md(pkctx, &sigmd) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_get_rsa_mgf1_md(pkctx, &mgf1md) <= 0)\\r\\ngoto err;\\r\\nif (!EVP_PKEY_CTX_get_rsa_pss_saltlen(pkctx, &saltlen))\\r\\ngoto err;\\r\\nif (saltlen == -1)\\r\\nsaltlen = EVP_MD_size(sigmd);\\r\\nelse if (saltlen == -2) {\\r\\nsaltlen = EVP_PKEY_size(pk) - EVP_MD_size(sigmd) - 2;\\r\\nif (((EVP_PKEY_bits(pk) - 1) & 0x7) == 0)\\r\\nsaltlen--;\\r\\n}\\r\\npss = RSA_PSS_PARAMS_new();\\r\\nif (!pss)\\r\\ngoto err;\\r\\nif (saltlen != 20) {\\r\\npss->saltLength = ASN1_INTEGER_new();\\r\\nif (!pss->saltLength)\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(pss->saltLength, saltlen))\\r\\ngoto err;\\r\\n}\\r\\nif (!rsa_md_to_algor(&pss->hashAlgorithm, sigmd))\\r\\ngoto err;\\r\\nif (!rsa_md_to_mgf1(&pss->maskGenAlgorithm, mgf1md))\\r\\ngoto err;\\r\\nif (!ASN1_item_pack(pss, ASN1_ITEM_rptr(RSA_PSS_PARAMS), &os))\\r\\ngoto err;\\r\\nrv = 1;\\r\\nerr:\\r\\nif (pss)\\r\\nRSA_PSS_PARAMS_free(pss);\\r\\nif (rv)\\r\\nreturn os;\\r\\nif (os)\\r\\nASN1_STRING_free(os);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int rsa_pss_to_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pkctx,\\r\\nX509_ALGOR *sigalg, EVP_PKEY *pkey)\\r\\n{\\r\\nint rv = -1;\\r\\nint saltlen;\\r\\nconst EVP_MD *mgf1md = NULL, *md = NULL;\\r\\nRSA_PSS_PARAMS *pss;\\r\\nX509_ALGOR *maskHash;\\r\\nif (OBJ_obj2nid(sigalg->algorithm) != NID_rsassaPss) {\\r\\nRSAerr(RSA_F_RSA_PSS_TO_CTX, RSA_R_UNSUPPORTED_SIGNATURE_TYPE);\\r\\nreturn -1;\\r\\n}\\r\\npss = rsa_pss_decode(sigalg, &maskHash);\\r\\nif (pss == NULL) {\\r\\nRSAerr(RSA_F_RSA_PSS_TO_CTX, RSA_R_INVALID_PSS_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\nmgf1md = rsa_mgf1_to_md(pss->maskGenAlgorithm, maskHash);\\r\\nif (!mgf1md)\\r\\ngoto err;\\r\\nmd = rsa_algor_to_md(pss->hashAlgorithm);\\r\\nif (!md)\\r\\ngoto err;\\r\\nif (pss->saltLength) {\\r\\nsaltlen = ASN1_INTEGER_get(pss->saltLength);\\r\\nif (saltlen < 0) {\\r\\nRSAerr(RSA_F_RSA_PSS_TO_CTX, RSA_R_INVALID_SALT_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\nsaltlen = 20;\\r\\nif (pss->trailerField && ASN1_INTEGER_get(pss->trailerField) != 1) {\\r\\nRSAerr(RSA_F_RSA_PSS_TO_CTX, RSA_R_INVALID_TRAILER);\\r\\ngoto err;\\r\\n}\\r\\nif (pkey) {\\r\\nif (!EVP_DigestVerifyInit(ctx, &pkctx, md, NULL, pkey))\\r\\ngoto err;\\r\\n} else {\\r\\nconst EVP_MD *checkmd;\\r\\nif (EVP_PKEY_CTX_get_signature_md(pkctx, &checkmd) <= 0)\\r\\ngoto err;\\r\\nif (EVP_MD_type(md) != EVP_MD_type(checkmd)) {\\r\\nRSAerr(RSA_F_RSA_PSS_TO_CTX, RSA_R_DIGEST_DOES_NOT_MATCH);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (EVP_PKEY_CTX_set_rsa_padding(pkctx, RSA_PKCS1_PSS_PADDING) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, saltlen) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set_rsa_mgf1_md(pkctx, mgf1md) <= 0)\\r\\ngoto err;\\r\\nrv = 1;\\r\\nerr:\\r\\nRSA_PSS_PARAMS_free(pss);\\r\\nif (maskHash)\\r\\nX509_ALGOR_free(maskHash);\\r\\nreturn rv;\\r\\n}\\r\\nstatic int rsa_cms_verify(CMS_SignerInfo *si)\\r\\n{\\r\\nint nid, nid2;\\r\\nX509_ALGOR *alg;\\r\\nEVP_PKEY_CTX *pkctx = CMS_SignerInfo_get0_pkey_ctx(si);\\r\\nCMS_SignerInfo_get0_algs(si, NULL, NULL, NULL, &alg);\\r\\nnid = OBJ_obj2nid(alg->algorithm);\\r\\nif (nid == NID_rsaEncryption)\\r\\nreturn 1;\\r\\nif (nid == NID_rsassaPss)\\r\\nreturn rsa_pss_to_ctx(NULL, pkctx, alg, NULL);\\r\\nif (OBJ_find_sigid_algs(nid, NULL, &nid2)) {\\r\\nif (nid2 == NID_rsaEncryption)\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int rsa_item_verify(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,\\r\\nX509_ALGOR *sigalg, ASN1_BIT_STRING *sig,\\r\\nEVP_PKEY *pkey)\\r\\n{\\r\\nif (OBJ_obj2nid(sigalg->algorithm) != NID_rsassaPss) {\\r\\nRSAerr(RSA_F_RSA_ITEM_VERIFY, RSA_R_UNSUPPORTED_SIGNATURE_TYPE);\\r\\nreturn -1;\\r\\n}\\r\\nif (rsa_pss_to_ctx(ctx, NULL, sigalg, pkey))\\r\\nreturn 2;\\r\\nreturn -1;\\r\\n}\\r\\nstatic int rsa_cms_sign(CMS_SignerInfo *si)\\r\\n{\\r\\nint pad_mode = RSA_PKCS1_PADDING;\\r\\nX509_ALGOR *alg;\\r\\nEVP_PKEY_CTX *pkctx = CMS_SignerInfo_get0_pkey_ctx(si);\\r\\nASN1_STRING *os = NULL;\\r\\nCMS_SignerInfo_get0_algs(si, NULL, NULL, NULL, &alg);\\r\\nif (pkctx) {\\r\\nif (EVP_PKEY_CTX_get_rsa_padding(pkctx, &pad_mode) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (pad_mode == RSA_PKCS1_PADDING) {\\r\\nX509_ALGOR_set0(alg, OBJ_nid2obj(NID_rsaEncryption), V_ASN1_NULL, 0);\\r\\nreturn 1;\\r\\n}\\r\\nif (pad_mode != RSA_PKCS1_PSS_PADDING)\\r\\nreturn 0;\\r\\nos = rsa_ctx_to_pss(pkctx);\\r\\nif (!os)\\r\\nreturn 0;\\r\\nX509_ALGOR_set0(alg, OBJ_nid2obj(NID_rsassaPss), V_ASN1_SEQUENCE, os);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rsa_item_sign(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,\\r\\nX509_ALGOR *alg1, X509_ALGOR *alg2,\\r\\nASN1_BIT_STRING *sig)\\r\\n{\\r\\nint pad_mode;\\r\\nEVP_PKEY_CTX *pkctx = ctx->pctx;\\r\\nif (EVP_PKEY_CTX_get_rsa_padding(pkctx, &pad_mode) <= 0)\\r\\nreturn 0;\\r\\nif (pad_mode == RSA_PKCS1_PADDING)\\r\\nreturn 2;\\r\\nif (pad_mode == RSA_PKCS1_PSS_PADDING) {\\r\\nASN1_STRING *os1 = NULL;\\r\\nos1 = rsa_ctx_to_pss(pkctx);\\r\\nif (!os1)\\r\\nreturn 0;\\r\\nif (alg2) {\\r\\nASN1_STRING *os2 = ASN1_STRING_dup(os1);\\r\\nif (!os2) {\\r\\nASN1_STRING_free(os1);\\r\\nreturn 0;\\r\\n}\\r\\nX509_ALGOR_set0(alg2, OBJ_nid2obj(NID_rsassaPss),\\r\\nV_ASN1_SEQUENCE, os2);\\r\\n}\\r\\nX509_ALGOR_set0(alg1, OBJ_nid2obj(NID_rsassaPss),\\r\\nV_ASN1_SEQUENCE, os1);\\r\\nreturn 3;\\r\\n}\\r\\nreturn 2;\\r\\n}\\r\\nstatic RSA_OAEP_PARAMS *rsa_oaep_decode(const X509_ALGOR *alg,\\r\\nX509_ALGOR **pmaskHash)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nint plen;\\r\\nRSA_OAEP_PARAMS *pss;\\r\\n*pmaskHash = NULL;\\r\\nif (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\\r\\nreturn NULL;\\r\\np = alg->parameter->value.sequence->data;\\r\\nplen = alg->parameter->value.sequence->length;\\r\\npss = d2i_RSA_OAEP_PARAMS(NULL, &p, plen);\\r\\nif (!pss)\\r\\nreturn NULL;\\r\\n*pmaskHash = rsa_mgf1_decode(pss->maskGenFunc);\\r\\nreturn pss;\\r\\n}\\r\\nstatic int rsa_cms_decrypt(CMS_RecipientInfo *ri)\\r\\n{\\r\\nEVP_PKEY_CTX *pkctx;\\r\\nX509_ALGOR *cmsalg;\\r\\nint nid;\\r\\nint rv = -1;\\r\\nunsigned char *label = NULL;\\r\\nint labellen = 0;\\r\\nconst EVP_MD *mgf1md = NULL, *md = NULL;\\r\\nRSA_OAEP_PARAMS *oaep;\\r\\nX509_ALGOR *maskHash;\\r\\npkctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\\r\\nif (!pkctx)\\r\\nreturn 0;\\r\\nif (!CMS_RecipientInfo_ktri_get0_algs(ri, NULL, NULL, &cmsalg))\\r\\nreturn -1;\\r\\nnid = OBJ_obj2nid(cmsalg->algorithm);\\r\\nif (nid == NID_rsaEncryption)\\r\\nreturn 1;\\r\\nif (nid != NID_rsaesOaep) {\\r\\nRSAerr(RSA_F_RSA_CMS_DECRYPT, RSA_R_UNSUPPORTED_ENCRYPTION_TYPE);\\r\\nreturn -1;\\r\\n}\\r\\noaep = rsa_oaep_decode(cmsalg, &maskHash);\\r\\nif (oaep == NULL) {\\r\\nRSAerr(RSA_F_RSA_CMS_DECRYPT, RSA_R_INVALID_OAEP_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\nmgf1md = rsa_mgf1_to_md(oaep->maskGenFunc, maskHash);\\r\\nif (!mgf1md)\\r\\ngoto err;\\r\\nmd = rsa_algor_to_md(oaep->hashFunc);\\r\\nif (!md)\\r\\ngoto err;\\r\\nif (oaep->pSourceFunc) {\\r\\nX509_ALGOR *plab = oaep->pSourceFunc;\\r\\nif (OBJ_obj2nid(plab->algorithm) != NID_pSpecified) {\\r\\nRSAerr(RSA_F_RSA_CMS_DECRYPT, RSA_R_UNSUPPORTED_LABEL_SOURCE);\\r\\ngoto err;\\r\\n}\\r\\nif (plab->parameter->type != V_ASN1_OCTET_STRING) {\\r\\nRSAerr(RSA_F_RSA_CMS_DECRYPT, RSA_R_INVALID_LABEL);\\r\\ngoto err;\\r\\n}\\r\\nlabel = plab->parameter->value.octet_string->data;\\r\\nplab->parameter->value.octet_string->data = NULL;\\r\\nlabellen = plab->parameter->value.octet_string->length;\\r\\n}\\r\\nif (EVP_PKEY_CTX_set_rsa_padding(pkctx, RSA_PKCS1_OAEP_PADDING) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set_rsa_oaep_md(pkctx, md) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set_rsa_mgf1_md(pkctx, mgf1md) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set0_rsa_oaep_label(pkctx, label, labellen) <= 0)\\r\\ngoto err;\\r\\nrv = 1;\\r\\nerr:\\r\\nRSA_OAEP_PARAMS_free(oaep);\\r\\nif (maskHash)\\r\\nX509_ALGOR_free(maskHash);\\r\\nreturn rv;\\r\\n}\\r\\nstatic int rsa_cms_encrypt(CMS_RecipientInfo *ri)\\r\\n{\\r\\nconst EVP_MD *md, *mgf1md;\\r\\nRSA_OAEP_PARAMS *oaep = NULL;\\r\\nASN1_STRING *os = NULL;\\r\\nX509_ALGOR *alg;\\r\\nEVP_PKEY_CTX *pkctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\\r\\nint pad_mode = RSA_PKCS1_PADDING, rv = 0, labellen;\\r\\nunsigned char *label;\\r\\nCMS_RecipientInfo_ktri_get0_algs(ri, NULL, NULL, &alg);\\r\\nif (pkctx) {\\r\\nif (EVP_PKEY_CTX_get_rsa_padding(pkctx, &pad_mode) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (pad_mode == RSA_PKCS1_PADDING) {\\r\\nX509_ALGOR_set0(alg, OBJ_nid2obj(NID_rsaEncryption), V_ASN1_NULL, 0);\\r\\nreturn 1;\\r\\n}\\r\\nif (pad_mode != RSA_PKCS1_OAEP_PADDING)\\r\\nreturn 0;\\r\\nif (EVP_PKEY_CTX_get_rsa_oaep_md(pkctx, &md) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_get_rsa_mgf1_md(pkctx, &mgf1md) <= 0)\\r\\ngoto err;\\r\\nlabellen = EVP_PKEY_CTX_get0_rsa_oaep_label(pkctx, &label);\\r\\nif (labellen < 0)\\r\\ngoto err;\\r\\noaep = RSA_OAEP_PARAMS_new();\\r\\nif (!oaep)\\r\\ngoto err;\\r\\nif (!rsa_md_to_algor(&oaep->hashFunc, md))\\r\\ngoto err;\\r\\nif (!rsa_md_to_mgf1(&oaep->maskGenFunc, mgf1md))\\r\\ngoto err;\\r\\nif (labellen > 0) {\\r\\nASN1_OCTET_STRING *los = ASN1_OCTET_STRING_new();\\r\\noaep->pSourceFunc = X509_ALGOR_new();\\r\\nif (!oaep->pSourceFunc)\\r\\ngoto err;\\r\\nif (!los)\\r\\ngoto err;\\r\\nif (!ASN1_OCTET_STRING_set(los, label, labellen)) {\\r\\nASN1_OCTET_STRING_free(los);\\r\\ngoto err;\\r\\n}\\r\\nX509_ALGOR_set0(oaep->pSourceFunc, OBJ_nid2obj(NID_pSpecified),\\r\\nV_ASN1_OCTET_STRING, los);\\r\\n}\\r\\nif (!ASN1_item_pack(oaep, ASN1_ITEM_rptr(RSA_OAEP_PARAMS), &os))\\r\\ngoto err;\\r\\nX509_ALGOR_set0(alg, OBJ_nid2obj(NID_rsaesOaep), V_ASN1_SEQUENCE, os);\\r\\nos = NULL;\\r\\nrv = 1;\\r\\nerr:\\r\\nif (oaep)\\r\\nRSA_OAEP_PARAMS_free(oaep);\\r\\nif (os)\\r\\nASN1_STRING_free(os);\\r\\nreturn rv;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_skey_c", "target": 0, "func": "void BF_set_key(BF_KEY *key, int len, const unsigned char *data)\\r\\n#ifdef OPENSSL_FIPS\\r\\n{\\r\\nfips_cipher_abort(BLOWFISH);\\r\\nprivate_BF_set_key(key, len, data);\\r\\n}\\r\\nvoid private_BF_set_key(BF_KEY *key, int len, const unsigned char *data)\\r\\n#endif\\r\\n{\\r\\nint i;\\r\\nBF_LONG *p, ri, in[2];\\r\\nconst unsigned char *d, *end;\\r\\nmemcpy(key, &bf_init, sizeof(BF_KEY));\\r\\np = key->P;\\r\\nif (len > ((BF_ROUNDS + 2) * 4))\\r\\nlen = (BF_ROUNDS + 2) * 4;\\r\\nd = data;\\r\\nend = &(data[len]);\\r\\nfor (i = 0; i < (BF_ROUNDS + 2); i++) {\\r\\nri = *(d++);\\r\\nif (d >= end)\\r\\nd = data;\\r\\nri <<= 8;\\r\\nri |= *(d++);\\r\\nif (d >= end)\\r\\nd = data;\\r\\nri <<= 8;\\r\\nri |= *(d++);\\r\\nif (d >= end)\\r\\nd = data;\\r\\nri <<= 8;\\r\\nri |= *(d++);\\r\\nif (d >= end)\\r\\nd = data;\\r\\np[i] ^= ri;\\r\\n}\\r\\nin[0] = 0L;\\r\\nin[1] = 0L;\\r\\nfor (i = 0; i < (BF_ROUNDS + 2); i += 2) {\\r\\nBF_encrypt(in, key);\\r\\np[i] = in[0];\\r\\np[i + 1] = in[1];\\r\\n}\\r\\np = key->S;\\r\\nfor (i = 0; i < 4 * 256; i += 2) {\\r\\nBF_encrypt(in, key);\\r\\np[i] = in[0];\\r\\np[i + 1] = in[1];\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ocsp_ht_c", "target": 0, "func": "OCSP_REQ_CTX *OCSP_REQ_CTX_new(BIO *io, int maxline)\\r\\n{\\r\\nOCSP_REQ_CTX *rctx;\\r\\nrctx = OPENSSL_malloc(sizeof(OCSP_REQ_CTX));\\r\\nif (!rctx)\\r\\nreturn NULL;\\r\\nrctx->state = OHS_ERROR;\\r\\nrctx->max_resp_len = OCSP_MAX_RESP_LENGTH;\\r\\nrctx->mem = BIO_new(BIO_s_mem());\\r\\nrctx->io = io;\\r\\nrctx->asn1_len = 0;\\r\\nif (maxline > 0)\\r\\nrctx->iobuflen = maxline;\\r\\nelse\\r\\nrctx->iobuflen = OCSP_MAX_LINE_LEN;\\r\\nrctx->iobuf = OPENSSL_malloc(rctx->iobuflen);\\r\\nif (!rctx->iobuf || !rctx->mem) {\\r\\nOCSP_REQ_CTX_free(rctx);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn rctx;\\r\\n}\\r\\nvoid OCSP_REQ_CTX_free(OCSP_REQ_CTX *rctx)\\r\\n{\\r\\nif (rctx->mem)\\r\\nBIO_free(rctx->mem);\\r\\nif (rctx->iobuf)\\r\\nOPENSSL_free(rctx->iobuf);\\r\\nOPENSSL_free(rctx);\\r\\n}\\r\\nBIO *OCSP_REQ_CTX_get0_mem_bio(OCSP_REQ_CTX *rctx)\\r\\n{\\r\\nreturn rctx->mem;\\r\\n}\\r\\nvoid OCSP_set_max_response_length(OCSP_REQ_CTX *rctx, unsigned long len)\\r\\n{\\r\\nif (len == 0)\\r\\nrctx->max_resp_len = OCSP_MAX_RESP_LENGTH;\\r\\nelse\\r\\nrctx->max_resp_len = len;\\r\\n}\\r\\nint OCSP_REQ_CTX_i2d(OCSP_REQ_CTX *rctx, const ASN1_ITEM *it, ASN1_VALUE *val)\\r\\n{\\r\\nstatic const char req_hdr[] =\\r\\n\"Content-Type: application/ocsp-request\\r\\n\"\\r\\n\"Content-Length: %d\\r\\n\\r\\n\";\\r\\nint reqlen = ASN1_item_i2d(val, NULL, it);\\r\\nif (BIO_printf(rctx->mem, req_hdr, reqlen) <= 0)\\r\\nreturn 0;\\r\\nif (ASN1_item_i2d_bio(it, rctx->mem, val) <= 0)\\r\\nreturn 0;\\r\\nrctx->state = OHS_ASN1_WRITE_INIT;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_REQ_CTX_nbio_d2i(OCSP_REQ_CTX *rctx,\\r\\nASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nint rv, len;\\r\\nconst unsigned char *p;\\r\\nrv = OCSP_REQ_CTX_nbio(rctx);\\r\\nif (rv != 1)\\r\\nreturn rv;\\r\\nlen = BIO_get_mem_data(rctx->mem, &p);\\r\\n*pval = ASN1_item_d2i(NULL, &p, len, it);\\r\\nif (*pval == NULL) {\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_REQ_CTX_http(OCSP_REQ_CTX *rctx, const char *op, const char *path)\\r\\n{\\r\\nstatic const char http_hdr[] = \"%s %s HTTP/1.0\\r\\n\";\\r\\nif (!path)\\r\\npath = \"/\";\\r\\nif (BIO_printf(rctx->mem, http_hdr, op, path) <= 0)\\r\\nreturn 0;\\r\\nrctx->state = OHS_HTTP_HEADER;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_REQ_CTX_set1_req(OCSP_REQ_CTX *rctx, OCSP_REQUEST *req)\\r\\n{\\r\\nreturn OCSP_REQ_CTX_i2d(rctx, ASN1_ITEM_rptr(OCSP_REQUEST),\\r\\n(ASN1_VALUE *)req);\\r\\n}\\r\\nint OCSP_REQ_CTX_add1_header(OCSP_REQ_CTX *rctx,\\r\\nconst char *name, const char *value)\\r\\n{\\r\\nif (!name)\\r\\nreturn 0;\\r\\nif (BIO_puts(rctx->mem, name) <= 0)\\r\\nreturn 0;\\r\\nif (value) {\\r\\nif (BIO_write(rctx->mem, \": \", 2) != 2)\\r\\nreturn 0;\\r\\nif (BIO_puts(rctx->mem, value) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_write(rctx->mem, \"\\r\\n\", 2) != 2)\\r\\nreturn 0;\\r\\nrctx->state = OHS_HTTP_HEADER;\\r\\nreturn 1;\\r\\n}\\r\\nOCSP_REQ_CTX *OCSP_sendreq_new(BIO *io, const char *path, OCSP_REQUEST *req,\\r\\nint maxline)\\r\\n{\\r\\nOCSP_REQ_CTX *rctx = NULL;\\r\\nrctx = OCSP_REQ_CTX_new(io, maxline);\\r\\nif (!rctx)\\r\\nreturn NULL;\\r\\nif (!OCSP_REQ_CTX_http(rctx, \"POST\", path))\\r\\ngoto err;\\r\\nif (req && !OCSP_REQ_CTX_set1_req(rctx, req))\\r\\ngoto err;\\r\\nreturn rctx;\\r\\nerr:\\r\\nOCSP_REQ_CTX_free(rctx);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int parse_http_line1(char *line)\\r\\n{\\r\\nint retcode;\\r\\nchar *p, *q, *r;\\r\\nfor (p = line; *p && !isspace((unsigned char)*p); p++)\\r\\ncontinue;\\r\\nif (!*p) {\\r\\nOCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nwhile (*p && isspace((unsigned char)*p))\\r\\np++;\\r\\nif (!*p) {\\r\\nOCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nfor (q = p; *q && !isspace((unsigned char)*q); q++)\\r\\ncontinue;\\r\\nif (!*q) {\\r\\nOCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n*q++ = 0;\\r\\nretcode = strtoul(p, &r, 10);\\r\\nif (*r)\\r\\nreturn 0;\\r\\nwhile (*q && isspace((unsigned char)*q))\\r\\nq++;\\r\\nif (*q) {\\r\\nfor (r = q + strlen(q) - 1; isspace((unsigned char)*r); r--)\\r\\n*r = 0;\\r\\n}\\r\\nif (retcode != 200) {\\r\\nOCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_ERROR);\\r\\nif (!*q)\\r\\nERR_add_error_data(2, \"Code=\", p);\\r\\nelse\\r\\nERR_add_error_data(4, \"Code=\", p, \",Reason=\", q);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_REQ_CTX_nbio(OCSP_REQ_CTX *rctx)\\r\\n{\\r\\nint i, n;\\r\\nconst unsigned char *p;\\r\\nnext_io:\\r\\nif (!(rctx->state & OHS_NOREAD)) {\\r\\nn = BIO_read(rctx->io, rctx->iobuf, rctx->iobuflen);\\r\\nif (n <= 0) {\\r\\nif (BIO_should_retry(rctx->io))\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_write(rctx->mem, rctx->iobuf, n) != n)\\r\\nreturn 0;\\r\\n}\\r\\nswitch (rctx->state) {\\r\\ncase OHS_HTTP_HEADER:\\r\\nif (BIO_write(rctx->mem, \"\\r\\n\", 2) != 2) {\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nrctx->state = OHS_ASN1_WRITE_INIT;\\r\\ncase OHS_ASN1_WRITE_INIT:\\r\\nrctx->asn1_len = BIO_get_mem_data(rctx->mem, NULL);\\r\\nrctx->state = OHS_ASN1_WRITE;\\r\\ncase OHS_ASN1_WRITE:\\r\\nn = BIO_get_mem_data(rctx->mem, &p);\\r\\ni = BIO_write(rctx->io, p + (n - rctx->asn1_len), rctx->asn1_len);\\r\\nif (i <= 0) {\\r\\nif (BIO_should_retry(rctx->io))\\r\\nreturn -1;\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nrctx->asn1_len -= i;\\r\\nif (rctx->asn1_len > 0)\\r\\ngoto next_io;\\r\\nrctx->state = OHS_ASN1_FLUSH;\\r\\n(void)BIO_reset(rctx->mem);\\r\\ncase OHS_ASN1_FLUSH:\\r\\ni = BIO_flush(rctx->io);\\r\\nif (i > 0) {\\r\\nrctx->state = OHS_FIRSTLINE;\\r\\ngoto next_io;\\r\\n}\\r\\nif (BIO_should_retry(rctx->io))\\r\\nreturn -1;\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\ncase OHS_ERROR:\\r\\nreturn 0;\\r\\ncase OHS_FIRSTLINE:\\r\\ncase OHS_HEADERS:\\r\\nnext_line:\\r\\nn = BIO_get_mem_data(rctx->mem, &p);\\r\\nif ((n <= 0) || !memchr(p, '\\n', n)) {\\r\\nif (n >= rctx->iobuflen) {\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\ngoto next_io;\\r\\n}\\r\\nn = BIO_gets(rctx->mem, (char *)rctx->iobuf, rctx->iobuflen);\\r\\nif (n <= 0) {\\r\\nif (BIO_should_retry(rctx->mem))\\r\\ngoto next_io;\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (n == rctx->iobuflen) {\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (rctx->state == OHS_FIRSTLINE) {\\r\\nif (parse_http_line1((char *)rctx->iobuf)) {\\r\\nrctx->state = OHS_HEADERS;\\r\\ngoto next_line;\\r\\n} else {\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\n} else {\\r\\nfor (p = rctx->iobuf; *p; p++) {\\r\\nif ((*p != '\\r') && (*p != '\\n'))\\r\\nbreak;\\r\\n}\\r\\nif (*p)\\r\\ngoto next_line;\\r\\nrctx->state = OHS_ASN1_HEADER;\\r\\n}\\r\\ncase OHS_ASN1_HEADER:\\r\\nn = BIO_get_mem_data(rctx->mem, &p);\\r\\nif (n < 2)\\r\\ngoto next_io;\\r\\nif (*p++ != (V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED)) {\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nif (*p & 0x80) {\\r\\nif (n < 6)\\r\\ngoto next_io;\\r\\nn = *p & 0x7F;\\r\\nif (!n || (n > 4)) {\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\np++;\\r\\nrctx->asn1_len = 0;\\r\\nfor (i = 0; i < n; i++) {\\r\\nrctx->asn1_len <<= 8;\\r\\nrctx->asn1_len |= *p++;\\r\\n}\\r\\nif (rctx->asn1_len > rctx->max_resp_len) {\\r\\nrctx->state = OHS_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nrctx->asn1_len += n + 2;\\r\\n} else\\r\\nrctx->asn1_len = *p + 2;\\r\\nrctx->state = OHS_ASN1_CONTENT;\\r\\ncase OHS_ASN1_CONTENT:\\r\\nn = BIO_get_mem_data(rctx->mem, NULL);\\r\\nif (n < (int)rctx->asn1_len)\\r\\ngoto next_io;\\r\\nrctx->state = OHS_DONE;\\r\\nreturn 1;\\r\\nbreak;\\r\\ncase OHS_DONE:\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint OCSP_sendreq_nbio(OCSP_RESPONSE **presp, OCSP_REQ_CTX *rctx)\\r\\n{\\r\\nreturn OCSP_REQ_CTX_nbio_d2i(rctx,\\r\\n(ASN1_VALUE **)presp,\\r\\nASN1_ITEM_rptr(OCSP_RESPONSE));\\r\\n}\\r\\nOCSP_RESPONSE *OCSP_sendreq_bio(BIO *b, const char *path, OCSP_REQUEST *req)\\r\\n{\\r\\nOCSP_RESPONSE *resp = NULL;\\r\\nOCSP_REQ_CTX *ctx;\\r\\nint rv;\\r\\nctx = OCSP_sendreq_new(b, path, req, -1);\\r\\nif (!ctx)\\r\\nreturn NULL;\\r\\ndo {\\r\\nrv = OCSP_sendreq_nbio(&resp, ctx);\\r\\n} while ((rv == -1) && BIO_should_retry(b));\\r\\nOCSP_REQ_CTX_free(ctx);\\r\\nif (rv)\\r\\nreturn resp;\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_chil_err_c", "target": 0, "func": "static void ERR_load_HWCRHK_strings(void)\\r\\n{\\r\\nif (HWCRHK_lib_error_code == 0)\\r\\nHWCRHK_lib_error_code = ERR_get_next_error_library();\\r\\nif (HWCRHK_error_init) {\\r\\nHWCRHK_error_init = 0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(HWCRHK_lib_error_code, HWCRHK_str_functs);\\r\\nERR_load_strings(HWCRHK_lib_error_code, HWCRHK_str_reasons);\\r\\n#endif\\r\\n#ifdef HWCRHK_LIB_NAME\\r\\nHWCRHK_lib_name->error = ERR_PACK(HWCRHK_lib_error_code, 0, 0);\\r\\nERR_load_strings(0, HWCRHK_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_HWCRHK_strings(void)\\r\\n{\\r\\nif (HWCRHK_error_init == 0) {\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(HWCRHK_lib_error_code, HWCRHK_str_functs);\\r\\nERR_unload_strings(HWCRHK_lib_error_code, HWCRHK_str_reasons);\\r\\n#endif\\r\\n#ifdef HWCRHK_LIB_NAME\\r\\nERR_unload_strings(0, HWCRHK_lib_name);\\r\\n#endif\\r\\nHWCRHK_error_init = 1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_HWCRHK_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (HWCRHK_lib_error_code == 0)\\r\\nHWCRHK_lib_error_code = ERR_get_next_error_library();\\r\\nERR_PUT_error(HWCRHK_lib_error_code, function, reason, file, line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cfb64enc_c", "target": 0, "func": "void DES_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nDES_cblock *ivec, int *num, int enc)\\r\\n{\\r\\nregister DES_LONG v0, v1;\\r\\nregister long l = length;\\r\\nregister int n = *num;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv, c, cc;\\r\\niv = &(*ivec)[0];\\r\\nif (enc) {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nc2l(iv, v0);\\r\\nti[0] = v0;\\r\\nc2l(iv, v1);\\r\\nti[1] = v1;\\r\\nDES_encrypt1(ti, schedule, DES_ENCRYPT);\\r\\niv = &(*ivec)[0];\\r\\nv0 = ti[0];\\r\\nl2c(v0, iv);\\r\\nv0 = ti[1];\\r\\nl2c(v0, iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\nc = *(in++) ^ iv[n];\\r\\n*(out++) = c;\\r\\niv[n] = c;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n} else {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nc2l(iv, v0);\\r\\nti[0] = v0;\\r\\nc2l(iv, v1);\\r\\nti[1] = v1;\\r\\nDES_encrypt1(ti, schedule, DES_ENCRYPT);\\r\\niv = &(*ivec)[0];\\r\\nv0 = ti[0];\\r\\nl2c(v0, iv);\\r\\nv0 = ti[1];\\r\\nl2c(v0, iv);\\r\\niv = &(*ivec)[0];\\r\\n}\\r\\ncc = *(in++);\\r\\nc = iv[n];\\r\\niv[n] = cc;\\r\\n*(out++) = c ^ cc;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n}\\r\\nv0 = v1 = ti[0] = ti[1] = c = cc = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_p8d_c", "target": 0, "func": "PKCS8_PRIV_KEY_INFO *PKCS8_decrypt(X509_SIG *p8, const char *pass,\\r\\nint passlen)\\r\\n{\\r\\nreturn PKCS12_item_decrypt_d2i(p8->algor,\\r\\nASN1_ITEM_rptr(PKCS8_PRIV_KEY_INFO), pass,\\r\\npasslen, p8->digest, 1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_lib_c", "target": 0, "func": "void DH_set_default_method(const DH_METHOD *meth)\\r\\n{\\r\\ndefault_DH_method = meth;\\r\\n}\\r\\nconst DH_METHOD *DH_get_default_method(void)\\r\\n{\\r\\nif (!default_DH_method) {\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_dh_openssl();\\r\\nelse\\r\\nreturn DH_OpenSSL();\\r\\n#else\\r\\ndefault_DH_method = DH_OpenSSL();\\r\\n#endif\\r\\n}\\r\\nreturn default_DH_method;\\r\\n}\\r\\nint DH_set_method(DH *dh, const DH_METHOD *meth)\\r\\n{\\r\\nconst DH_METHOD *mtmp;\\r\\nmtmp = dh->meth;\\r\\nif (mtmp->finish)\\r\\nmtmp->finish(dh);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (dh->engine) {\\r\\nENGINE_finish(dh->engine);\\r\\ndh->engine = NULL;\\r\\n}\\r\\n#endif\\r\\ndh->meth = meth;\\r\\nif (meth->init)\\r\\nmeth->init(dh);\\r\\nreturn 1;\\r\\n}\\r\\nDH *DH_new(void)\\r\\n{\\r\\nreturn DH_new_method(NULL);\\r\\n}\\r\\nDH *DH_new_method(ENGINE *engine)\\r\\n{\\r\\nDH *ret;\\r\\nret = (DH *)OPENSSL_malloc(sizeof(DH));\\r\\nif (ret == NULL) {\\r\\nDHerr(DH_F_DH_NEW_METHOD, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nret->meth = DH_get_default_method();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (engine) {\\r\\nif (!ENGINE_init(engine)) {\\r\\nDHerr(DH_F_DH_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nret->engine = engine;\\r\\n} else\\r\\nret->engine = ENGINE_get_default_DH();\\r\\nif (ret->engine) {\\r\\nret->meth = ENGINE_get_DH(ret->engine);\\r\\nif (!ret->meth) {\\r\\nDHerr(DH_F_DH_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nENGINE_finish(ret->engine);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret->pad = 0;\\r\\nret->version = 0;\\r\\nret->p = NULL;\\r\\nret->g = NULL;\\r\\nret->length = 0;\\r\\nret->pub_key = NULL;\\r\\nret->priv_key = NULL;\\r\\nret->q = NULL;\\r\\nret->j = NULL;\\r\\nret->seed = NULL;\\r\\nret->seedlen = 0;\\r\\nret->counter = NULL;\\r\\nret->method_mont_p = NULL;\\r\\nret->references = 1;\\r\\nret->flags = ret->meth->flags & ~DH_FLAG_NON_FIPS_ALLOW;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_DH, ret, &ret->ex_data);\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret)) {\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ret->engine)\\r\\nENGINE_finish(ret->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, ret, &ret->ex_data);\\r\\nOPENSSL_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid DH_free(DH *r)\\r\\n{\\r\\nint i;\\r\\nif (r == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_DH);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DH\", r);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"DH_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (r->meth->finish)\\r\\nr->meth->finish(r);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (r->engine)\\r\\nENGINE_finish(r->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_DH, r, &r->ex_data);\\r\\nif (r->p != NULL)\\r\\nBN_clear_free(r->p);\\r\\nif (r->g != NULL)\\r\\nBN_clear_free(r->g);\\r\\nif (r->q != NULL)\\r\\nBN_clear_free(r->q);\\r\\nif (r->j != NULL)\\r\\nBN_clear_free(r->j);\\r\\nif (r->seed)\\r\\nOPENSSL_free(r->seed);\\r\\nif (r->counter != NULL)\\r\\nBN_clear_free(r->counter);\\r\\nif (r->pub_key != NULL)\\r\\nBN_clear_free(r->pub_key);\\r\\nif (r->priv_key != NULL)\\r\\nBN_clear_free(r->priv_key);\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nint DH_up_ref(DH *r)\\r\\n{\\r\\nint i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_DH);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DH\", r);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (i < 2) {\\r\\nfprintf(stderr, \"DH_up, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nreturn ((i > 1) ? 1 : 0);\\r\\n}\\r\\nint DH_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DH, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint DH_set_ex_data(DH *d, int idx, void *arg)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&d->ex_data, idx, arg));\\r\\n}\\r\\nvoid *DH_get_ex_data(DH *d, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&d->ex_data, idx));\\r\\n}\\r\\nint DH_size(const DH *dh)\\r\\n{\\r\\nreturn (BN_num_bytes(dh->p));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_seed_c", "target": 0, "func": "static int seed_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nSEED_set_key(key, ctx->cipher_data);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ex_data_c", "target": 0, "func": "static void impl_check(void)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\nif (!impl)\\r\\nimpl = &impl_default;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\n}\\r\\nconst CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void)\\r\\n{\\r\\nIMPL_CHECK return impl;\\r\\n}\\r\\nint CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i)\\r\\n{\\r\\nint toret = 0;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\nif (!impl) {\\r\\nimpl = i;\\r\\ntoret = 1;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nreturn toret;\\r\\n}\\r\\nstatic unsigned long ex_class_item_hash(const EX_CLASS_ITEM *a)\\r\\n{\\r\\nreturn a->class_index;\\r\\n}\\r\\nvoid def_cleanup_util_cb(CRYPTO_EX_DATA_FUNCS *funcs)\\r\\n{\\r\\nOPENSSL_free(funcs);\\r\\n}\\r\\nstatic void def_cleanup_cb(void *a_void)\\r\\n{\\r\\nEX_CLASS_ITEM *item = (EX_CLASS_ITEM *)a_void;\\r\\nsk_CRYPTO_EX_DATA_FUNCS_pop_free(item->meth, def_cleanup_util_cb);\\r\\nOPENSSL_free(item);\\r\\n}\\r\\nstatic EX_CLASS_ITEM *def_get_class(int class_index)\\r\\n{\\r\\nEX_CLASS_ITEM d, *p, *gen;\\r\\nEX_DATA_CHECK(return NULL;)\\r\\nd.class_index = class_index;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\np = lh_EX_CLASS_ITEM_retrieve(ex_data, &d);\\r\\nif (!p) {\\r\\ngen = OPENSSL_malloc(sizeof(EX_CLASS_ITEM));\\r\\nif (gen) {\\r\\ngen->class_index = class_index;\\r\\ngen->meth_num = 0;\\r\\ngen->meth = sk_CRYPTO_EX_DATA_FUNCS_new_null();\\r\\nif (!gen->meth)\\r\\nOPENSSL_free(gen);\\r\\nelse {\\r\\n(void)lh_EX_CLASS_ITEM_insert(ex_data, gen);\\r\\np = gen;\\r\\n}\\r\\n}\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nif (!p)\\r\\nCRYPTOerr(CRYPTO_F_DEF_GET_CLASS, ERR_R_MALLOC_FAILURE);\\r\\nreturn p;\\r\\n}\\r\\nstatic int def_add_index(EX_CLASS_ITEM *item, long argl, void *argp,\\r\\nCRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nint toret = -1;\\r\\nCRYPTO_EX_DATA_FUNCS *a =\\r\\n(CRYPTO_EX_DATA_FUNCS *)OPENSSL_malloc(sizeof(CRYPTO_EX_DATA_FUNCS));\\r\\nif (!a) {\\r\\nCRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\na->argl = argl;\\r\\na->argp = argp;\\r\\na->new_func = new_func;\\r\\na->dup_func = dup_func;\\r\\na->free_func = free_func;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\nwhile (sk_CRYPTO_EX_DATA_FUNCS_num(item->meth) <= item->meth_num) {\\r\\nif (!sk_CRYPTO_EX_DATA_FUNCS_push(item->meth, NULL)) {\\r\\nCRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(a);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ntoret = item->meth_num++;\\r\\n(void)sk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);\\r\\nerr:\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nreturn toret;\\r\\n}\\r\\nstatic int int_new_class(void)\\r\\n{\\r\\nint toret;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);\\r\\ntoret = ex_class++;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nreturn toret;\\r\\n}\\r\\nstatic void int_cleanup(void)\\r\\n{\\r\\nEX_DATA_CHECK(return;)\\r\\nlh_EX_CLASS_ITEM_doall(ex_data, def_cleanup_cb);\\r\\nlh_EX_CLASS_ITEM_free(ex_data);\\r\\nex_data = NULL;\\r\\nimpl = NULL;\\r\\n}\\r\\nstatic int int_get_new_index(int class_index, long argl, void *argp,\\r\\nCRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nEX_CLASS_ITEM *item = def_get_class(class_index);\\r\\nif (!item)\\r\\nreturn -1;\\r\\nreturn def_add_index(item, argl, argp, new_func, dup_func, free_func);\\r\\n}\\r\\nstatic int int_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\\r\\n{\\r\\nint mx, i;\\r\\nvoid *ptr;\\r\\nCRYPTO_EX_DATA_FUNCS **storage = NULL;\\r\\nEX_CLASS_ITEM *item = def_get_class(class_index);\\r\\nif (!item)\\r\\nreturn 0;\\r\\nad->sk = NULL;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);\\r\\nmx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);\\r\\nif (mx > 0) {\\r\\nstorage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS *));\\r\\nif (!storage)\\r\\ngoto skip;\\r\\nfor (i = 0; i < mx; i++)\\r\\nstorage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);\\r\\n}\\r\\nskip:\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nif ((mx > 0) && !storage) {\\r\\nCRYPTOerr(CRYPTO_F_INT_NEW_EX_DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < mx; i++) {\\r\\nif (storage[i] && storage[i]->new_func) {\\r\\nptr = CRYPTO_get_ex_data(ad, i);\\r\\nstorage[i]->new_func(obj, ptr, ad, i,\\r\\nstorage[i]->argl, storage[i]->argp);\\r\\n}\\r\\n}\\r\\nif (storage)\\r\\nOPENSSL_free(storage);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,\\r\\nCRYPTO_EX_DATA *from)\\r\\n{\\r\\nint mx, j, i;\\r\\nchar *ptr;\\r\\nCRYPTO_EX_DATA_FUNCS **storage = NULL;\\r\\nEX_CLASS_ITEM *item;\\r\\nif (!from->sk)\\r\\nreturn 1;\\r\\nif ((item = def_get_class(class_index)) == NULL)\\r\\nreturn 0;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);\\r\\nmx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);\\r\\nj = sk_void_num(from->sk);\\r\\nif (j < mx)\\r\\nmx = j;\\r\\nif (mx > 0) {\\r\\nstorage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS *));\\r\\nif (!storage)\\r\\ngoto skip;\\r\\nfor (i = 0; i < mx; i++)\\r\\nstorage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);\\r\\n}\\r\\nskip:\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nif ((mx > 0) && !storage) {\\r\\nCRYPTOerr(CRYPTO_F_INT_DUP_EX_DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < mx; i++) {\\r\\nptr = CRYPTO_get_ex_data(from, i);\\r\\nif (storage[i] && storage[i]->dup_func)\\r\\nstorage[i]->dup_func(to, from, &ptr, i,\\r\\nstorage[i]->argl, storage[i]->argp);\\r\\nCRYPTO_set_ex_data(to, i, ptr);\\r\\n}\\r\\nif (storage)\\r\\nOPENSSL_free(storage);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void int_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\\r\\n{\\r\\nint mx, i;\\r\\nEX_CLASS_ITEM *item;\\r\\nvoid *ptr;\\r\\nCRYPTO_EX_DATA_FUNCS **storage = NULL;\\r\\nif ((item = def_get_class(class_index)) == NULL)\\r\\nreturn;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);\\r\\nmx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);\\r\\nif (mx > 0) {\\r\\nstorage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS *));\\r\\nif (!storage)\\r\\ngoto skip;\\r\\nfor (i = 0; i < mx; i++)\\r\\nstorage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);\\r\\n}\\r\\nskip:\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);\\r\\nif ((mx > 0) && !storage) {\\r\\nCRYPTOerr(CRYPTO_F_INT_FREE_EX_DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn;\\r\\n}\\r\\nfor (i = 0; i < mx; i++) {\\r\\nif (storage[i] && storage[i]->free_func) {\\r\\nptr = CRYPTO_get_ex_data(ad, i);\\r\\nstorage[i]->free_func(obj, ptr, ad, i,\\r\\nstorage[i]->argl, storage[i]->argp);\\r\\n}\\r\\n}\\r\\nif (storage)\\r\\nOPENSSL_free(storage);\\r\\nif (ad->sk) {\\r\\nsk_void_free(ad->sk);\\r\\nad->sk = NULL;\\r\\n}\\r\\n}\\r\\nint CRYPTO_ex_data_new_class(void)\\r\\n{\\r\\nIMPL_CHECK return EX_IMPL(new_class) ();\\r\\n}\\r\\nvoid CRYPTO_cleanup_all_ex_data(void)\\r\\n{\\r\\nIMPL_CHECK EX_IMPL(cleanup) ();\\r\\n}\\r\\nint CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,\\r\\nCRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nint ret = -1;\\r\\nIMPL_CHECK\\r\\nret = EX_IMPL(get_new_index) (class_index,\\r\\nargl, argp, new_func, dup_func,\\r\\nfree_func);\\r\\nreturn ret;\\r\\n}\\r\\nint CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\\r\\n{\\r\\nIMPL_CHECK return EX_IMPL(new_ex_data) (class_index, obj, ad);\\r\\n}\\r\\nint CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,\\r\\nCRYPTO_EX_DATA *from)\\r\\n{\\r\\nIMPL_CHECK return EX_IMPL(dup_ex_data) (class_index, to, from);\\r\\n}\\r\\nvoid CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)\\r\\n{\\r\\nIMPL_CHECK EX_IMPL(free_ex_data) (class_index, obj, ad);\\r\\n}\\r\\nint CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)\\r\\n{\\r\\nint i;\\r\\nif (ad->sk == NULL) {\\r\\nif ((ad->sk = sk_void_new_null()) == NULL) {\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\ni = sk_void_num(ad->sk);\\r\\nwhile (i <= idx) {\\r\\nif (!sk_void_push(ad->sk, NULL)) {\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\ni++;\\r\\n}\\r\\nsk_void_set(ad->sk, idx, val);\\r\\nreturn (1);\\r\\n}\\r\\nvoid *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)\\r\\n{\\r\\nif (ad->sk == NULL)\\r\\nreturn (0);\\r\\nelse if (idx >= sk_void_num(ad->sk))\\r\\nreturn (0);\\r\\nelse\\r\\nreturn (sk_void_value(ad->sk, idx));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ofb64ede_c", "target": 0, "func": "void DES_ede3_ofb64_encrypt(register const unsigned char *in,\\r\\nregister unsigned char *out, long length,\\r\\nDES_key_schedule *k1, DES_key_schedule *k2,\\r\\nDES_key_schedule *k3, DES_cblock *ivec, int *num)\\r\\n{\\r\\nregister DES_LONG v0, v1;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nDES_cblock d;\\r\\nregister char *dp;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save = 0;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\ndp = (char *)d;\\r\\nl2c(v0, dp);\\r\\nl2c(v1, dp);\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nDES_encrypt3(ti, k1, k2, k3);\\r\\nv0 = ti[0];\\r\\nv1 = ti[1];\\r\\ndp = (char *)d;\\r\\nl2c(v0, dp);\\r\\nl2c(v1, dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++) = *(in++) ^ d[n];\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\nif (save) {\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\n}\\r\\nv0 = v1 = ti[0] = ti[1] = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pk12err_c", "target": 0, "func": "void ERR_load_PKCS12_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(PKCS12_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, PKCS12_str_functs);\\r\\nERR_load_strings(0, PKCS12_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_genpkey_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nchar **args, *outfile = NULL;\\r\\nchar *passarg = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nconst EVP_CIPHER *cipher = NULL;\\r\\nint outformat;\\r\\nint text = 0;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nEVP_PKEY_CTX *ctx = NULL;\\r\\nchar *pass = NULL;\\r\\nint badarg = 0;\\r\\nint ret = 1, rv;\\r\\nint do_param = 0;\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\noutformat = FORMAT_PEM;\\r\\nERR_load_crypto_strings();\\r\\nOpenSSL_add_all_algorithms();\\r\\nargs = argv + 1;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp(*args, \"-outform\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutformat = str2fmt(*args);\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-pass\")) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\npassarg = *(++args);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*args, \"-engine\") == 0) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\ne = setup_engine(bio_err, *(++args), 0);\\r\\n}\\r\\n#endif\\r\\nelse if (!strcmp(*args, \"-paramfile\")) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\nargs++;\\r\\nif (do_param == 1)\\r\\ngoto bad;\\r\\nif (!init_keygen_file(bio_err, &ctx, *args, e))\\r\\ngoto end;\\r\\n} else if (!strcmp(*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (strcmp(*args, \"-algorithm\") == 0) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\nif (!init_gen_str(bio_err, &ctx, *(++args), e, do_param))\\r\\ngoto end;\\r\\n} else if (strcmp(*args, \"-pkeyopt\") == 0) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\nif (!ctx) {\\r\\nBIO_puts(bio_err, \"No keytype specified\\n\");\\r\\ngoto bad;\\r\\n} else if (pkey_ctrl_string(ctx, *(++args)) <= 0) {\\r\\nBIO_puts(bio_err, \"parameter setting error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else if (strcmp(*args, \"-genparam\") == 0) {\\r\\nif (ctx)\\r\\ngoto bad;\\r\\ndo_param = 1;\\r\\n} else if (strcmp(*args, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse {\\r\\ncipher = EVP_get_cipherbyname(*args + 1);\\r\\nif (!cipher) {\\r\\nBIO_printf(bio_err, \"Unknown cipher %s\\n\", *args + 1);\\r\\nbadarg = 1;\\r\\n}\\r\\nif (do_param == 1)\\r\\nbadarg = 1;\\r\\n}\\r\\nargs++;\\r\\n}\\r\\nif (!ctx)\\r\\nbadarg = 1;\\r\\nif (badarg) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"Usage: genpkey [options]\\n\");\\r\\nBIO_printf(bio_err, \"where options may be\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-outform X output format (DER or PEM)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-pass arg output file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-<cipher> use cipher <cipher> to encrypt the key\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \"-paramfile file parameters file\\n\");\\r\\nBIO_printf(bio_err, \"-algorithm alg the public key algorithm\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-pkeyopt opt:value set the public key algorithm option <opt>\\n\"\\r\\n\" to value <value>\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-genparam generate parameters, not key\\n\");\\r\\nBIO_printf(bio_err, \"-text print the in text\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"NB: options order may be important! See the manual page.\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!app_passwd(bio_err, passarg, NULL, &pass, NULL)) {\\r\\nBIO_puts(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file(outfile, \"wb\"))) {\\r\\nBIO_printf(bio_err, \"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nEVP_PKEY_CTX_set_cb(ctx, genpkey_cb);\\r\\nEVP_PKEY_CTX_set_app_data(ctx, bio_err);\\r\\nif (do_param) {\\r\\nif (EVP_PKEY_paramgen(ctx, &pkey) <= 0) {\\r\\nBIO_puts(bio_err, \"Error generating parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nif (EVP_PKEY_keygen(ctx, &pkey) <= 0) {\\r\\nBIO_puts(bio_err, \"Error generating key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (do_param)\\r\\nrv = PEM_write_bio_Parameters(out, pkey);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\nrv = PEM_write_bio_PrivateKey(out, pkey, cipher, NULL, 0, NULL, pass);\\r\\nelse if (outformat == FORMAT_ASN1)\\r\\nrv = i2d_PrivateKey_bio(out, pkey);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (rv <= 0) {\\r\\nBIO_puts(bio_err, \"Error writing key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif (text) {\\r\\nif (do_param)\\r\\nrv = EVP_PKEY_print_params(out, pkey, 0, NULL);\\r\\nelse\\r\\nrv = EVP_PKEY_print_private(out, pkey, 0, NULL);\\r\\nif (rv <= 0) {\\r\\nBIO_puts(bio_err, \"Error printing key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (pkey)\\r\\nEVP_PKEY_free(pkey);\\r\\nif (ctx)\\r\\nEVP_PKEY_CTX_free(ctx);\\r\\nif (out)\\r\\nBIO_free_all(out);\\r\\nBIO_free(in);\\r\\nif (pass)\\r\\nOPENSSL_free(pass);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int init_keygen_file(BIO *err, EVP_PKEY_CTX **pctx,\\r\\nconst char *file, ENGINE *e)\\r\\n{\\r\\nBIO *pbio;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nEVP_PKEY_CTX *ctx = NULL;\\r\\nif (*pctx) {\\r\\nBIO_puts(err, \"Parameters already set!\\n\");\\r\\nreturn 0;\\r\\n}\\r\\npbio = BIO_new_file(file, \"r\");\\r\\nif (!pbio) {\\r\\nBIO_printf(err, \"Can't open parameter file %s\\n\", file);\\r\\nreturn 0;\\r\\n}\\r\\npkey = PEM_read_bio_Parameters(pbio, NULL);\\r\\nBIO_free(pbio);\\r\\nif (!pkey) {\\r\\nBIO_printf(bio_err, \"Error reading parameter file %s\\n\", file);\\r\\nreturn 0;\\r\\n}\\r\\nctx = EVP_PKEY_CTX_new(pkey, e);\\r\\nif (!ctx)\\r\\ngoto err;\\r\\nif (EVP_PKEY_keygen_init(ctx) <= 0)\\r\\ngoto err;\\r\\nEVP_PKEY_free(pkey);\\r\\n*pctx = ctx;\\r\\nreturn 1;\\r\\nerr:\\r\\nBIO_puts(err, \"Error initializing context\\n\");\\r\\nERR_print_errors(err);\\r\\nif (ctx)\\r\\nEVP_PKEY_CTX_free(ctx);\\r\\nif (pkey)\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn 0;\\r\\n}\\r\\nint init_gen_str(BIO *err, EVP_PKEY_CTX **pctx,\\r\\nconst char *algname, ENGINE *e, int do_param)\\r\\n{\\r\\nEVP_PKEY_CTX *ctx = NULL;\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nENGINE *tmpeng = NULL;\\r\\nint pkey_id;\\r\\nif (*pctx) {\\r\\nBIO_puts(err, \"Algorithm already set!\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nameth = EVP_PKEY_asn1_find_str(&tmpeng, algname, -1);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (!ameth && e)\\r\\nameth = ENGINE_get_pkey_asn1_meth_str(e, algname, -1);\\r\\n#endif\\r\\nif (!ameth) {\\r\\nBIO_printf(bio_err, \"Algorithm %s not found\\n\", algname);\\r\\nreturn 0;\\r\\n}\\r\\nERR_clear_error();\\r\\nEVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL, ameth);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (tmpeng)\\r\\nENGINE_finish(tmpeng);\\r\\n#endif\\r\\nctx = EVP_PKEY_CTX_new_id(pkey_id, e);\\r\\nif (!ctx)\\r\\ngoto err;\\r\\nif (do_param) {\\r\\nif (EVP_PKEY_paramgen_init(ctx) <= 0)\\r\\ngoto err;\\r\\n} else {\\r\\nif (EVP_PKEY_keygen_init(ctx) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n*pctx = ctx;\\r\\nreturn 1;\\r\\nerr:\\r\\nBIO_printf(err, \"Error initializing %s context\\n\", algname);\\r\\nERR_print_errors(err);\\r\\nif (ctx)\\r\\nEVP_PKEY_CTX_free(ctx);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int genpkey_cb(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nchar c = '*';\\r\\nBIO *b = EVP_PKEY_CTX_get_app_data(ctx);\\r\\nint p;\\r\\np = EVP_PKEY_CTX_get_keygen_info(ctx, 0);\\r\\nif (p == 0)\\r\\nc = '.';\\r\\nif (p == 1)\\r\\nc = '+';\\r\\nif (p == 2)\\r\\nc = '*';\\r\\nif (p == 3)\\r\\nc = '\\n';\\r\\nBIO_write(b, &c, 1);\\r\\n(void)BIO_flush(b);\\r\\n#ifdef LINT\\r\\np = n;\\r\\n#endif\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_gendsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nDSA *dsa = NULL;\\r\\nint ret = 1;\\r\\nchar *outfile = NULL;\\r\\nchar *inrand = NULL, *dsaparams = NULL;\\r\\nchar *passargout = NULL, *passout = NULL;\\r\\nBIO *out = NULL, *in = NULL;\\r\\nconst EVP_CIPHER *enc = NULL;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n# endif\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nargv++;\\r\\nargc--;\\r\\nfor (;;) {\\r\\nif (argc <= 0)\\r\\nbreak;\\r\\nif (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passout\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargout = *(++argv);\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninrand = *(++argv);\\r\\n} else if (strcmp(*argv, \"-\") == 0)\\r\\ngoto bad;\\r\\n# ifndef OPENSSL_NO_DES\\r\\nelse if (strcmp(*argv, \"-des\") == 0)\\r\\nenc = EVP_des_cbc();\\r\\nelse if (strcmp(*argv, \"-des3\") == 0)\\r\\nenc = EVP_des_ede3_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_IDEA\\r\\nelse if (strcmp(*argv, \"-idea\") == 0)\\r\\nenc = EVP_idea_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nelse if (strcmp(*argv, \"-seed\") == 0)\\r\\nenc = EVP_seed_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nelse if (strcmp(*argv, \"-aes128\") == 0)\\r\\nenc = EVP_aes_128_cbc();\\r\\nelse if (strcmp(*argv, \"-aes192\") == 0)\\r\\nenc = EVP_aes_192_cbc();\\r\\nelse if (strcmp(*argv, \"-aes256\") == 0)\\r\\nenc = EVP_aes_256_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nelse if (strcmp(*argv, \"-camellia128\") == 0)\\r\\nenc = EVP_camellia_128_cbc();\\r\\nelse if (strcmp(*argv, \"-camellia192\") == 0)\\r\\nenc = EVP_camellia_192_cbc();\\r\\nelse if (strcmp(*argv, \"-camellia256\") == 0)\\r\\nenc = EVP_camellia_256_cbc();\\r\\n# endif\\r\\nelse if (**argv != '-' && dsaparams == NULL) {\\r\\ndsaparams = *argv;\\r\\n} else\\r\\ngoto bad;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif (dsaparams == NULL) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"usage: gendsa [args] dsaparam-file\\n\");\\r\\nBIO_printf(bio_err, \" -out file - output the key to 'file'\\n\");\\r\\n# ifndef OPENSSL_NO_DES\\r\\nBIO_printf(bio_err,\\r\\n\" -des - encrypt the generated key with DES in cbc mode\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -des3 - encrypt the generated key with DES in ede cbc mode (168 bit key)\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf(bio_err,\\r\\n\" -idea - encrypt the generated key with IDEA in cbc mode\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nBIO_printf(bio_err, \" -seed\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc seed\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err, \" -aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc aes\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nBIO_printf(bio_err, \" -camellia128, -camellia192, -camellia256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc camellia\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e - use engine e, possibly a hardware device.\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\\r\\n\" - load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\nBIO_printf(bio_err, \" dsaparam-file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" - a DSA parameter file as generated by the dsaparam command\\n\");\\r\\ngoto end;\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (!app_passwd(bio_err, NULL, passargout, NULL, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin = BIO_new(BIO_s_file());\\r\\nif (!(BIO_read_filename(in, dsaparams))) {\\r\\nperror(dsaparams);\\r\\ngoto end;\\r\\n}\\r\\nif ((dsa = PEM_read_bio_DSAparams(in, NULL, NULL, NULL)) == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load DSA parameter file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_free(in);\\r\\nin = NULL;\\r\\nout = BIO_new(BIO_s_file());\\r\\nif (out == NULL)\\r\\ngoto end;\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL) {\\r\\nBIO_printf(bio_err,\\r\\n\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nBIO_printf(bio_err, \"Generating DSA key, %d bits\\n\", BN_num_bits(dsa->p));\\r\\nif (!DSA_generate_key(dsa))\\r\\ngoto end;\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nif (!PEM_write_bio_DSAPrivateKey(out, dsa, enc, NULL, 0, NULL, passout))\\r\\ngoto end;\\r\\nret = 0;\\r\\nend:\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (dsa != NULL)\\r\\nDSA_free(dsa);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_conf_c", "target": 0, "func": "X509_EXTENSION *X509V3_EXT_nconf(CONF *conf, X509V3_CTX *ctx, char *name,\\r\\nchar *value)\\r\\n{\\r\\nint crit;\\r\\nint ext_type;\\r\\nX509_EXTENSION *ret;\\r\\ncrit = v3_check_critical(&value);\\r\\nif ((ext_type = v3_check_generic(&value)))\\r\\nreturn v3_generic_extension(name, value, crit, ext_type, ctx);\\r\\nret = do_ext_nconf(conf, ctx, OBJ_sn2nid(name), crit, value);\\r\\nif (!ret) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_NCONF, X509V3_R_ERROR_IN_EXTENSION);\\r\\nERR_add_error_data(4, \"name=\", name, \", value=\", value);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nX509_EXTENSION *X509V3_EXT_nconf_nid(CONF *conf, X509V3_CTX *ctx, int ext_nid,\\r\\nchar *value)\\r\\n{\\r\\nint crit;\\r\\nint ext_type;\\r\\ncrit = v3_check_critical(&value);\\r\\nif ((ext_type = v3_check_generic(&value)))\\r\\nreturn v3_generic_extension(OBJ_nid2sn(ext_nid),\\r\\nvalue, crit, ext_type, ctx);\\r\\nreturn do_ext_nconf(conf, ctx, ext_nid, crit, value);\\r\\n}\\r\\nstatic X509_EXTENSION *do_ext_nconf(CONF *conf, X509V3_CTX *ctx, int ext_nid,\\r\\nint crit, char *value)\\r\\n{\\r\\nconst X509V3_EXT_METHOD *method;\\r\\nX509_EXTENSION *ext;\\r\\nSTACK_OF(CONF_VALUE) *nval;\\r\\nvoid *ext_struc;\\r\\nif (ext_nid == NID_undef) {\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF, X509V3_R_UNKNOWN_EXTENSION_NAME);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(method = X509V3_EXT_get_nid(ext_nid))) {\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF, X509V3_R_UNKNOWN_EXTENSION);\\r\\nreturn NULL;\\r\\n}\\r\\nif (method->v2i) {\\r\\nif (*value == '@')\\r\\nnval = NCONF_get_section(conf, value + 1);\\r\\nelse\\r\\nnval = X509V3_parse_list(value);\\r\\nif (sk_CONF_VALUE_num(nval) <= 0) {\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF,\\r\\nX509V3_R_INVALID_EXTENSION_STRING);\\r\\nERR_add_error_data(4, \"name=\", OBJ_nid2sn(ext_nid), \",section=\",\\r\\nvalue);\\r\\nreturn NULL;\\r\\n}\\r\\next_struc = method->v2i(method, ctx, nval);\\r\\nif (*value != '@')\\r\\nsk_CONF_VALUE_pop_free(nval, X509V3_conf_free);\\r\\nif (!ext_struc)\\r\\nreturn NULL;\\r\\n} else if (method->s2i) {\\r\\nif (!(ext_struc = method->s2i(method, ctx, value)))\\r\\nreturn NULL;\\r\\n} else if (method->r2i) {\\r\\nif (!ctx->db || !ctx->db_meth) {\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF, X509V3_R_NO_CONFIG_DATABASE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(ext_struc = method->r2i(method, ctx, value)))\\r\\nreturn NULL;\\r\\n} else {\\r\\nX509V3err(X509V3_F_DO_EXT_NCONF,\\r\\nX509V3_R_EXTENSION_SETTING_NOT_SUPPORTED);\\r\\nERR_add_error_data(2, \"name=\", OBJ_nid2sn(ext_nid));\\r\\nreturn NULL;\\r\\n}\\r\\next = do_ext_i2d(method, ext_nid, crit, ext_struc);\\r\\nif (method->it)\\r\\nASN1_item_free(ext_struc, ASN1_ITEM_ptr(method->it));\\r\\nelse\\r\\nmethod->ext_free(ext_struc);\\r\\nreturn ext;\\r\\n}\\r\\nstatic X509_EXTENSION *do_ext_i2d(const X509V3_EXT_METHOD *method,\\r\\nint ext_nid, int crit, void *ext_struc)\\r\\n{\\r\\nunsigned char *ext_der;\\r\\nint ext_len;\\r\\nASN1_OCTET_STRING *ext_oct;\\r\\nX509_EXTENSION *ext;\\r\\nif (method->it) {\\r\\next_der = NULL;\\r\\next_len =\\r\\nASN1_item_i2d(ext_struc, &ext_der, ASN1_ITEM_ptr(method->it));\\r\\nif (ext_len < 0)\\r\\ngoto merr;\\r\\n} else {\\r\\nunsigned char *p;\\r\\next_len = method->i2d(ext_struc, NULL);\\r\\nif (!(ext_der = OPENSSL_malloc(ext_len)))\\r\\ngoto merr;\\r\\np = ext_der;\\r\\nmethod->i2d(ext_struc, &p);\\r\\n}\\r\\nif (!(ext_oct = M_ASN1_OCTET_STRING_new()))\\r\\ngoto merr;\\r\\next_oct->data = ext_der;\\r\\next_oct->length = ext_len;\\r\\next = X509_EXTENSION_create_by_NID(NULL, ext_nid, crit, ext_oct);\\r\\nif (!ext)\\r\\ngoto merr;\\r\\nM_ASN1_OCTET_STRING_free(ext_oct);\\r\\nreturn ext;\\r\\nmerr:\\r\\nX509V3err(X509V3_F_DO_EXT_I2D, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nX509_EXTENSION *X509V3_EXT_i2d(int ext_nid, int crit, void *ext_struc)\\r\\n{\\r\\nconst X509V3_EXT_METHOD *method;\\r\\nif (!(method = X509V3_EXT_get_nid(ext_nid))) {\\r\\nX509V3err(X509V3_F_X509V3_EXT_I2D, X509V3_R_UNKNOWN_EXTENSION);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn do_ext_i2d(method, ext_nid, crit, ext_struc);\\r\\n}\\r\\nstatic int v3_check_critical(char **value)\\r\\n{\\r\\nchar *p = *value;\\r\\nif ((strlen(p) < 9) || strncmp(p, \"critical,\", 9))\\r\\nreturn 0;\\r\\np += 9;\\r\\nwhile (isspace((unsigned char)*p))\\r\\np++;\\r\\n*value = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int v3_check_generic(char **value)\\r\\n{\\r\\nint gen_type = 0;\\r\\nchar *p = *value;\\r\\nif ((strlen(p) >= 4) && !strncmp(p, \"DER:\", 4)) {\\r\\np += 4;\\r\\ngen_type = 1;\\r\\n} else if ((strlen(p) >= 5) && !strncmp(p, \"ASN1:\", 5)) {\\r\\np += 5;\\r\\ngen_type = 2;\\r\\n} else\\r\\nreturn 0;\\r\\nwhile (isspace((unsigned char)*p))\\r\\np++;\\r\\n*value = p;\\r\\nreturn gen_type;\\r\\n}\\r\\nstatic X509_EXTENSION *v3_generic_extension(const char *ext, char *value,\\r\\nint crit, int gen_type,\\r\\nX509V3_CTX *ctx)\\r\\n{\\r\\nunsigned char *ext_der = NULL;\\r\\nlong ext_len;\\r\\nASN1_OBJECT *obj = NULL;\\r\\nASN1_OCTET_STRING *oct = NULL;\\r\\nX509_EXTENSION *extension = NULL;\\r\\nif (!(obj = OBJ_txt2obj(ext, 0))) {\\r\\nX509V3err(X509V3_F_V3_GENERIC_EXTENSION,\\r\\nX509V3_R_EXTENSION_NAME_ERROR);\\r\\nERR_add_error_data(2, \"name=\", ext);\\r\\ngoto err;\\r\\n}\\r\\nif (gen_type == 1)\\r\\next_der = string_to_hex(value, &ext_len);\\r\\nelse if (gen_type == 2)\\r\\next_der = generic_asn1(value, ctx, &ext_len);\\r\\nif (ext_der == NULL) {\\r\\nX509V3err(X509V3_F_V3_GENERIC_EXTENSION,\\r\\nX509V3_R_EXTENSION_VALUE_ERROR);\\r\\nERR_add_error_data(2, \"value=\", value);\\r\\ngoto err;\\r\\n}\\r\\nif (!(oct = M_ASN1_OCTET_STRING_new())) {\\r\\nX509V3err(X509V3_F_V3_GENERIC_EXTENSION, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\noct->data = ext_der;\\r\\noct->length = ext_len;\\r\\next_der = NULL;\\r\\nextension = X509_EXTENSION_create_by_OBJ(NULL, obj, crit, oct);\\r\\nerr:\\r\\nASN1_OBJECT_free(obj);\\r\\nM_ASN1_OCTET_STRING_free(oct);\\r\\nif (ext_der)\\r\\nOPENSSL_free(ext_der);\\r\\nreturn extension;\\r\\n}\\r\\nstatic unsigned char *generic_asn1(char *value, X509V3_CTX *ctx,\\r\\nlong *ext_len)\\r\\n{\\r\\nASN1_TYPE *typ;\\r\\nunsigned char *ext_der = NULL;\\r\\ntyp = ASN1_generate_v3(value, ctx);\\r\\nif (typ == NULL)\\r\\nreturn NULL;\\r\\n*ext_len = i2d_ASN1_TYPE(typ, &ext_der);\\r\\nASN1_TYPE_free(typ);\\r\\nreturn ext_der;\\r\\n}\\r\\nint X509V3_EXT_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,\\r\\nX509 *cert)\\r\\n{\\r\\nSTACK_OF(X509_EXTENSION) **sk = NULL;\\r\\nif (cert)\\r\\nsk = &cert->cert_info->extensions;\\r\\nreturn X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);\\r\\n}\\r\\nint X509V3_EXT_CRL_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,\\r\\nX509_CRL *crl)\\r\\n{\\r\\nSTACK_OF(X509_EXTENSION) **sk = NULL;\\r\\nif (crl)\\r\\nsk = &crl->crl->extensions;\\r\\nreturn X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);\\r\\n}\\r\\nint X509V3_EXT_REQ_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section,\\r\\nX509_REQ *req)\\r\\n{\\r\\nSTACK_OF(X509_EXTENSION) *extlist = NULL, **sk = NULL;\\r\\nint i;\\r\\nif (req)\\r\\nsk = &extlist;\\r\\ni = X509V3_EXT_add_nconf_sk(conf, ctx, section, sk);\\r\\nif (!i || !sk)\\r\\nreturn i;\\r\\ni = X509_REQ_add_extensions(req, extlist);\\r\\nsk_X509_EXTENSION_pop_free(extlist, X509_EXTENSION_free);\\r\\nreturn i;\\r\\n}\\r\\nchar *X509V3_get_string(X509V3_CTX *ctx, char *name, char *section)\\r\\n{\\r\\nif (!ctx->db || !ctx->db_meth || !ctx->db_meth->get_string) {\\r\\nX509V3err(X509V3_F_X509V3_GET_STRING, X509V3_R_OPERATION_NOT_DEFINED);\\r\\nreturn NULL;\\r\\n}\\r\\nif (ctx->db_meth->get_string)\\r\\nreturn ctx->db_meth->get_string(ctx->db, name, section);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic char *nconf_get_string(void *db, char *section, char *value)\\r\\n{\\r\\nreturn NCONF_get_string(db, section, value);\\r\\n}\\r\\nvoid X509V3_set_nconf(X509V3_CTX *ctx, CONF *conf)\\r\\n{\\r\\nctx->db_meth = &nconf_method;\\r\\nctx->db = conf;\\r\\n}\\r\\nvoid X509V3_set_ctx(X509V3_CTX *ctx, X509 *issuer, X509 *subj, X509_REQ *req,\\r\\nX509_CRL *crl, int flags)\\r\\n{\\r\\nctx->issuer_cert = issuer;\\r\\nctx->subject_cert = subj;\\r\\nctx->crl = crl;\\r\\nctx->subject_req = req;\\r\\nctx->flags = flags;\\r\\n}\\r\\nstatic char *conf_lhash_get_string(void *db, char *section, char *value)\\r\\n{\\r\\nreturn CONF_get_string(db, section, value);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_err_prn_c", "target": 0, "func": "void ERR_print_errors_cb(int (*cb) (const char *str, size_t len, void *u),\\r\\nvoid *u)\\r\\n{\\r\\nunsigned long l;\\r\\nchar buf[256];\\r\\nchar buf2[4096];\\r\\nconst char *file, *data;\\r\\nint line, flags;\\r\\nunsigned long es;\\r\\nCRYPTO_THREADID cur;\\r\\nCRYPTO_THREADID_current(&cur);\\r\\nes = CRYPTO_THREADID_hash(&cur);\\r\\nwhile ((l = ERR_get_error_line_data(&file, &line, &data, &flags)) != 0) {\\r\\nERR_error_string_n(l, buf, sizeof buf);\\r\\nBIO_snprintf(buf2, sizeof(buf2), \"%lu:%s:%s:%d:%s\\n\", es, buf,\\r\\nfile, line, (flags & ERR_TXT_STRING) ? data : \"\");\\r\\nif (cb(buf2, strlen(buf2), u) <= 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nstatic int print_fp(const char *str, size_t len, void *fp)\\r\\n{\\r\\nBIO bio;\\r\\nBIO_set(&bio, BIO_s_file());\\r\\nBIO_set_fp(&bio, fp, BIO_NOCLOSE);\\r\\nreturn BIO_printf(&bio, \"%s\", str);\\r\\n}\\r\\nvoid ERR_print_errors_fp(FILE *fp)\\r\\n{\\r\\nERR_print_errors_cb(print_fp, fp);\\r\\n}\\r\\nstatic int print_bio(const char *str, size_t len, void *bp)\\r\\n{\\r\\nreturn BIO_write((BIO *)bp, str, len);\\r\\n}\\r\\nvoid ERR_print_errors(BIO *bp)\\r\\n{\\r\\nERR_print_errors_cb(print_bio, bp);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_armcap_c", "target": 0, "func": "void OPENSSL_cpuid_setup(void)\\r\\n{\\r\\n}\\r\\nunsigned long OPENSSL_rdtsc(void)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nstatic void ill_handler(int sig)\\r\\n{\\r\\nsiglongjmp(ill_jmp, sig);\\r\\n}\\r\\nunsigned long OPENSSL_rdtsc(void)\\r\\n{\\r\\nif (OPENSSL_armcap_P & ARMV7_TICK)\\r\\nreturn _armv7_tick();\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nvoid OPENSSL_cpuid_setup(void)\\r\\n{\\r\\nchar *e;\\r\\nstruct sigaction ill_oact, ill_act;\\r\\nsigset_t oset;\\r\\nstatic int trigger = 0;\\r\\nif (trigger)\\r\\nreturn;\\r\\ntrigger = 1;\\r\\nif ((e = getenv(\"OPENSSL_armcap\"))) {\\r\\nOPENSSL_armcap_P = (unsigned int)strtoul(e, NULL, 0);\\r\\nreturn;\\r\\n}\\r\\nsigfillset(&all_masked);\\r\\nsigdelset(&all_masked, SIGILL);\\r\\nsigdelset(&all_masked, SIGTRAP);\\r\\nsigdelset(&all_masked, SIGFPE);\\r\\nsigdelset(&all_masked, SIGBUS);\\r\\nsigdelset(&all_masked, SIGSEGV);\\r\\nOPENSSL_armcap_P = 0;\\r\\nmemset(&ill_act, 0, sizeof(ill_act));\\r\\nill_act.sa_handler = ill_handler;\\r\\nill_act.sa_mask = all_masked;\\r\\nsigprocmask(SIG_SETMASK, &ill_act.sa_mask, &oset);\\r\\nsigaction(SIGILL, &ill_act, &ill_oact);\\r\\nif (getauxval != NULL) {\\r\\nif (getauxval(HWCAP) & HWCAP_NEON) {\\r\\nunsigned long hwcap = getauxval(HWCAP_CE);\\r\\nOPENSSL_armcap_P |= ARMV7_NEON;\\r\\nif (hwcap & HWCAP_CE_AES)\\r\\nOPENSSL_armcap_P |= ARMV8_AES;\\r\\nif (hwcap & HWCAP_CE_PMULL)\\r\\nOPENSSL_armcap_P |= ARMV8_PMULL;\\r\\nif (hwcap & HWCAP_CE_SHA1)\\r\\nOPENSSL_armcap_P |= ARMV8_SHA1;\\r\\nif (hwcap & HWCAP_CE_SHA256)\\r\\nOPENSSL_armcap_P |= ARMV8_SHA256;\\r\\n}\\r\\n} else if (sigsetjmp(ill_jmp, 1) == 0) {\\r\\n_armv7_neon_probe();\\r\\nOPENSSL_armcap_P |= ARMV7_NEON;\\r\\nif (sigsetjmp(ill_jmp, 1) == 0) {\\r\\n_armv8_pmull_probe();\\r\\nOPENSSL_armcap_P |= ARMV8_PMULL | ARMV8_AES;\\r\\n} else if (sigsetjmp(ill_jmp, 1) == 0) {\\r\\n_armv8_aes_probe();\\r\\nOPENSSL_armcap_P |= ARMV8_AES;\\r\\n}\\r\\nif (sigsetjmp(ill_jmp, 1) == 0) {\\r\\n_armv8_sha1_probe();\\r\\nOPENSSL_armcap_P |= ARMV8_SHA1;\\r\\n}\\r\\nif (sigsetjmp(ill_jmp, 1) == 0) {\\r\\n_armv8_sha256_probe();\\r\\nOPENSSL_armcap_P |= ARMV8_SHA256;\\r\\n}\\r\\n}\\r\\nif (sigsetjmp(ill_jmp, 1) == 0) {\\r\\n_armv7_tick();\\r\\nOPENSSL_armcap_P |= ARMV7_TICK;\\r\\n}\\r\\nsigaction(SIGILL, &ill_oact, NULL);\\r\\nsigprocmask(SIG_SETMASK, &oset, NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_asn1_lib_c", "target": 0, "func": "static int _asn1_check_infinite_end(const unsigned char **p, long len)\\r\\n{\\r\\nif (len <= 0)\\r\\nreturn (1);\\r\\nelse if ((len >= 2) && ((*p)[0] == 0) && ((*p)[1] == 0)) {\\r\\n(*p) += 2;\\r\\nreturn (1);\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nint ASN1_check_infinite_end(unsigned char **p, long len)\\r\\n{\\r\\nreturn _asn1_check_infinite_end((const unsigned char **)p, len);\\r\\n}\\r\\nint ASN1_const_check_infinite_end(const unsigned char **p, long len)\\r\\n{\\r\\nreturn _asn1_check_infinite_end(p, len);\\r\\n}\\r\\nint ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,\\r\\nint *pclass, long omax)\\r\\n{\\r\\nint i, ret;\\r\\nlong l;\\r\\nconst unsigned char *p = *pp;\\r\\nint tag, xclass, inf;\\r\\nlong max = omax;\\r\\nif (!max)\\r\\ngoto err;\\r\\nret = (*p & V_ASN1_CONSTRUCTED);\\r\\nxclass = (*p & V_ASN1_PRIVATE);\\r\\ni = *p & V_ASN1_PRIMITIVE_TAG;\\r\\nif (i == V_ASN1_PRIMITIVE_TAG) {\\r\\np++;\\r\\nif (--max == 0)\\r\\ngoto err;\\r\\nl = 0;\\r\\nwhile (*p & 0x80) {\\r\\nl <<= 7L;\\r\\nl |= *(p++) & 0x7f;\\r\\nif (--max == 0)\\r\\ngoto err;\\r\\nif (l > (INT_MAX >> 7L))\\r\\ngoto err;\\r\\n}\\r\\nl <<= 7L;\\r\\nl |= *(p++) & 0x7f;\\r\\ntag = (int)l;\\r\\nif (--max == 0)\\r\\ngoto err;\\r\\n} else {\\r\\ntag = i;\\r\\np++;\\r\\nif (--max == 0)\\r\\ngoto err;\\r\\n}\\r\\n*ptag = tag;\\r\\n*pclass = xclass;\\r\\nif (!asn1_get_length(&p, &inf, plength, (int)max))\\r\\ngoto err;\\r\\nif (inf && !(ret & V_ASN1_CONSTRUCTED))\\r\\ngoto err;\\r\\n#if 0\\r\\nfprintf(stderr, \"p=%d + *plength=%ld > omax=%ld + *pp=%d (%d > %d)\\n\",\\r\\n(int)p, *plength, omax, (int)*pp, (int)(p + *plength),\\r\\n(int)(omax + *pp));\\r\\n#endif\\r\\nif (*plength > (omax - (p - *pp))) {\\r\\nASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_TOO_LONG);\\r\\nret |= 0x80;\\r\\n}\\r\\n*pp = p;\\r\\nreturn (ret | inf);\\r\\nerr:\\r\\nASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_HEADER_TOO_LONG);\\r\\nreturn (0x80);\\r\\n}\\r\\nstatic int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\\r\\nint max)\\r\\n{\\r\\nconst unsigned char *p = *pp;\\r\\nunsigned long ret = 0;\\r\\nunsigned int i;\\r\\nif (max-- < 1)\\r\\nreturn (0);\\r\\nif (*p == 0x80) {\\r\\n*inf = 1;\\r\\nret = 0;\\r\\np++;\\r\\n} else {\\r\\n*inf = 0;\\r\\ni = *p & 0x7f;\\r\\nif (*(p++) & 0x80) {\\r\\nif (i > sizeof(long))\\r\\nreturn 0;\\r\\nif (max-- == 0)\\r\\nreturn (0);\\r\\nwhile (i-- > 0) {\\r\\nret <<= 8L;\\r\\nret |= *(p++);\\r\\nif (max-- == 0)\\r\\nreturn (0);\\r\\n}\\r\\n} else\\r\\nret = i;\\r\\n}\\r\\nif (ret > LONG_MAX)\\r\\nreturn 0;\\r\\n*pp = p;\\r\\n*rl = (long)ret;\\r\\nreturn (1);\\r\\n}\\r\\nvoid ASN1_put_object(unsigned char **pp, int constructed, int length, int tag,\\r\\nint xclass)\\r\\n{\\r\\nunsigned char *p = *pp;\\r\\nint i, ttag;\\r\\ni = (constructed) ? V_ASN1_CONSTRUCTED : 0;\\r\\ni |= (xclass & V_ASN1_PRIVATE);\\r\\nif (tag < 31)\\r\\n*(p++) = i | (tag & V_ASN1_PRIMITIVE_TAG);\\r\\nelse {\\r\\n*(p++) = i | V_ASN1_PRIMITIVE_TAG;\\r\\nfor (i = 0, ttag = tag; ttag > 0; i++)\\r\\nttag >>= 7;\\r\\nttag = i;\\r\\nwhile (i-- > 0) {\\r\\np[i] = tag & 0x7f;\\r\\nif (i != (ttag - 1))\\r\\np[i] |= 0x80;\\r\\ntag >>= 7;\\r\\n}\\r\\np += ttag;\\r\\n}\\r\\nif (constructed == 2)\\r\\n*(p++) = 0x80;\\r\\nelse\\r\\nasn1_put_length(&p, length);\\r\\n*pp = p;\\r\\n}\\r\\nint ASN1_put_eoc(unsigned char **pp)\\r\\n{\\r\\nunsigned char *p = *pp;\\r\\n*p++ = 0;\\r\\n*p++ = 0;\\r\\n*pp = p;\\r\\nreturn 2;\\r\\n}\\r\\nstatic void asn1_put_length(unsigned char **pp, int length)\\r\\n{\\r\\nunsigned char *p = *pp;\\r\\nint i, l;\\r\\nif (length <= 127)\\r\\n*(p++) = (unsigned char)length;\\r\\nelse {\\r\\nl = length;\\r\\nfor (i = 0; l > 0; i++)\\r\\nl >>= 8;\\r\\n*(p++) = i | 0x80;\\r\\nl = i;\\r\\nwhile (i-- > 0) {\\r\\np[i] = length & 0xff;\\r\\nlength >>= 8;\\r\\n}\\r\\np += l;\\r\\n}\\r\\n*pp = p;\\r\\n}\\r\\nint ASN1_object_size(int constructed, int length, int tag)\\r\\n{\\r\\nint ret;\\r\\nret = length;\\r\\nret++;\\r\\nif (tag >= 31) {\\r\\nwhile (tag > 0) {\\r\\ntag >>= 7;\\r\\nret++;\\r\\n}\\r\\n}\\r\\nif (constructed == 2)\\r\\nreturn ret + 3;\\r\\nret++;\\r\\nif (length > 127) {\\r\\nwhile (length > 0) {\\r\\nlength >>= 8;\\r\\nret++;\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int _asn1_Finish(ASN1_const_CTX *c)\\r\\n{\\r\\nif ((c->inf == (1 | V_ASN1_CONSTRUCTED)) && (!c->eos)) {\\r\\nif (!ASN1_const_check_infinite_end(&c->p, c->slen)) {\\r\\nc->error = ERR_R_MISSING_ASN1_EOS;\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nif (((c->slen != 0) && !(c->inf & 1)) || ((c->slen < 0) && (c->inf & 1))) {\\r\\nc->error = ERR_R_ASN1_LENGTH_MISMATCH;\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nint asn1_Finish(ASN1_CTX *c)\\r\\n{\\r\\nreturn _asn1_Finish((ASN1_const_CTX *)c);\\r\\n}\\r\\nint asn1_const_Finish(ASN1_const_CTX *c)\\r\\n{\\r\\nreturn _asn1_Finish(c);\\r\\n}\\r\\nint asn1_GetSequence(ASN1_const_CTX *c, long *length)\\r\\n{\\r\\nconst unsigned char *q;\\r\\nq = c->p;\\r\\nc->inf = ASN1_get_object(&(c->p), &(c->slen), &(c->tag), &(c->xclass),\\r\\n*length);\\r\\nif (c->inf & 0x80) {\\r\\nc->error = ERR_R_BAD_GET_ASN1_OBJECT_CALL;\\r\\nreturn (0);\\r\\n}\\r\\nif (c->tag != V_ASN1_SEQUENCE) {\\r\\nc->error = ERR_R_EXPECTING_AN_ASN1_SEQUENCE;\\r\\nreturn (0);\\r\\n}\\r\\n(*length) -= (c->p - q);\\r\\nif (c->max && (*length < 0)) {\\r\\nc->error = ERR_R_ASN1_LENGTH_MISMATCH;\\r\\nreturn (0);\\r\\n}\\r\\nif (c->inf == (1 | V_ASN1_CONSTRUCTED))\\r\\nc->slen = *length + *(c->pp) - c->p;\\r\\nc->eos = 0;\\r\\nreturn (1);\\r\\n}\\r\\nint ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str)\\r\\n{\\r\\nif (str == NULL)\\r\\nreturn 0;\\r\\ndst->type = str->type;\\r\\nif (!ASN1_STRING_set(dst, str->data, str->length))\\r\\nreturn 0;\\r\\ndst->flags = str->flags;\\r\\nreturn 1;\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_dup(const ASN1_STRING *str)\\r\\n{\\r\\nASN1_STRING *ret;\\r\\nif (!str)\\r\\nreturn NULL;\\r\\nret = ASN1_STRING_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!ASN1_STRING_copy(ret, str)) {\\r\\nASN1_STRING_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint ASN1_STRING_set(ASN1_STRING *str, const void *_data, int len)\\r\\n{\\r\\nunsigned char *c;\\r\\nconst char *data = _data;\\r\\nif (len < 0) {\\r\\nif (data == NULL)\\r\\nreturn (0);\\r\\nelse\\r\\nlen = strlen(data);\\r\\n}\\r\\nif ((str->length < len) || (str->data == NULL)) {\\r\\nc = str->data;\\r\\nif (c == NULL)\\r\\nstr->data = OPENSSL_malloc(len + 1);\\r\\nelse\\r\\nstr->data = OPENSSL_realloc(c, len + 1);\\r\\nif (str->data == NULL) {\\r\\nASN1err(ASN1_F_ASN1_STRING_SET, ERR_R_MALLOC_FAILURE);\\r\\nstr->data = c;\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nstr->length = len;\\r\\nif (data != NULL) {\\r\\nmemcpy(str->data, data, len);\\r\\nstr->data[len] = '\\0';\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nvoid ASN1_STRING_set0(ASN1_STRING *str, void *data, int len)\\r\\n{\\r\\nif (str->data)\\r\\nOPENSSL_free(str->data);\\r\\nstr->data = data;\\r\\nstr->length = len;\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_new(void)\\r\\n{\\r\\nreturn (ASN1_STRING_type_new(V_ASN1_OCTET_STRING));\\r\\n}\\r\\nASN1_STRING *ASN1_STRING_type_new(int type)\\r\\n{\\r\\nASN1_STRING *ret;\\r\\nret = (ASN1_STRING *)OPENSSL_malloc(sizeof(ASN1_STRING));\\r\\nif (ret == NULL) {\\r\\nASN1err(ASN1_F_ASN1_STRING_TYPE_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nret->length = 0;\\r\\nret->type = type;\\r\\nret->data = NULL;\\r\\nret->flags = 0;\\r\\nreturn (ret);\\r\\n}\\r\\nvoid ASN1_STRING_free(ASN1_STRING *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn;\\r\\nif (a->data && !(a->flags & ASN1_STRING_FLAG_NDEF))\\r\\nOPENSSL_free(a->data);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nint ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b)\\r\\n{\\r\\nint i;\\r\\ni = (a->length - b->length);\\r\\nif (i == 0) {\\r\\ni = memcmp(a->data, b->data, a->length);\\r\\nif (i == 0)\\r\\nreturn (a->type - b->type);\\r\\nelse\\r\\nreturn (i);\\r\\n} else\\r\\nreturn (i);\\r\\n}\\r\\nvoid asn1_add_error(const unsigned char *address, int offset)\\r\\n{\\r\\nchar buf1[DECIMAL_SIZE(address) + 1], buf2[DECIMAL_SIZE(offset) + 1];\\r\\nBIO_snprintf(buf1, sizeof buf1, \"%lu\", (unsigned long)address);\\r\\nBIO_snprintf(buf2, sizeof buf2, \"%d\", offset);\\r\\nERR_add_error_data(4, \"address=\", buf1, \" offset=\", buf2);\\r\\n}\\r\\nint ASN1_STRING_length(const ASN1_STRING *x)\\r\\n{\\r\\nreturn M_ASN1_STRING_length(x);\\r\\n}\\r\\nvoid ASN1_STRING_length_set(ASN1_STRING *x, int len)\\r\\n{\\r\\nM_ASN1_STRING_length_set(x, len);\\r\\nreturn;\\r\\n}\\r\\nint ASN1_STRING_type(ASN1_STRING *x)\\r\\n{\\r\\nreturn M_ASN1_STRING_type(x);\\r\\n}\\r\\nunsigned char *ASN1_STRING_data(ASN1_STRING *x)\\r\\n{\\r\\nreturn M_ASN1_STRING_data(x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dso_win32_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_win32(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nstatic FARPROC GetProcAddressA(HMODULE hModule, LPCSTR lpProcName)\\r\\n{\\r\\nWCHAR lpProcNameW[64];\\r\\nint i;\\r\\nfor (i = 0; lpProcName[i] && i < 64; i++)\\r\\nlpProcNameW[i] = (WCHAR)lpProcName[i];\\r\\nif (i == 64)\\r\\nreturn NULL;\\r\\nlpProcNameW[i] = 0;\\r\\nreturn GetProcAddressW(hModule, lpProcNameW);\\r\\n}\\r\\nstatic HINSTANCE LoadLibraryA(LPCSTR lpLibFileName)\\r\\n{\\r\\nWCHAR *fnamw;\\r\\nsize_t len_0 = strlen(lpLibFileName) + 1, i;\\r\\n# ifdef _MSC_VER\\r\\nfnamw = (WCHAR *)_alloca(len_0 * sizeof(WCHAR));\\r\\n# else\\r\\nfnamw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\\r\\n# endif\\r\\nif (fnamw == NULL) {\\r\\nSetLastError(ERROR_NOT_ENOUGH_MEMORY);\\r\\nreturn NULL;\\r\\n}\\r\\n# if defined(_WIN32_WCE) && _WIN32_WCE>=101\\r\\nif (!MultiByteToWideChar(CP_ACP, 0, lpLibFileName, len_0, fnamw, len_0))\\r\\n# endif\\r\\nfor (i = 0; i < len_0; i++)\\r\\nfnamw[i] = (WCHAR)lpLibFileName[i];\\r\\nreturn LoadLibraryW(fnamw);\\r\\n}\\r\\nDSO_METHOD *DSO_METHOD_win32(void)\\r\\n{\\r\\nreturn (&dso_meth_win32);\\r\\n}\\r\\nstatic int win32_load(DSO *dso)\\r\\n{\\r\\nHINSTANCE h = NULL, *p = NULL;\\r\\nchar *filename = DSO_convert_filename(dso, NULL);\\r\\nif (filename == NULL) {\\r\\nDSOerr(DSO_F_WIN32_LOAD, DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\nh = LoadLibraryA(filename);\\r\\nif (h == NULL) {\\r\\nDSOerr(DSO_F_WIN32_LOAD, DSO_R_LOAD_FAILED);\\r\\nERR_add_error_data(3, \"filename(\", filename, \")\");\\r\\ngoto err;\\r\\n}\\r\\np = (HINSTANCE *) OPENSSL_malloc(sizeof(HINSTANCE));\\r\\nif (p == NULL) {\\r\\nDSOerr(DSO_F_WIN32_LOAD, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n*p = h;\\r\\nif (!sk_void_push(dso->meth_data, p)) {\\r\\nDSOerr(DSO_F_WIN32_LOAD, DSO_R_STACK_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndso->loaded_filename = filename;\\r\\nreturn (1);\\r\\nerr:\\r\\nif (filename != NULL)\\r\\nOPENSSL_free(filename);\\r\\nif (p != NULL)\\r\\nOPENSSL_free(p);\\r\\nif (h != NULL)\\r\\nFreeLibrary(h);\\r\\nreturn (0);\\r\\n}\\r\\nstatic int win32_unload(DSO *dso)\\r\\n{\\r\\nHINSTANCE *p;\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_WIN32_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (sk_void_num(dso->meth_data) < 1)\\r\\nreturn (1);\\r\\np = sk_void_pop(dso->meth_data);\\r\\nif (p == NULL) {\\r\\nDSOerr(DSO_F_WIN32_UNLOAD, DSO_R_NULL_HANDLE);\\r\\nreturn (0);\\r\\n}\\r\\nif (!FreeLibrary(*p)) {\\r\\nDSOerr(DSO_F_WIN32_UNLOAD, DSO_R_UNLOAD_FAILED);\\r\\nsk_void_push(dso->meth_data, p);\\r\\nreturn (0);\\r\\n}\\r\\nOPENSSL_free(p);\\r\\nreturn (1);\\r\\n}\\r\\nstatic void *win32_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nHINSTANCE *ptr;\\r\\nvoid *sym;\\r\\nif ((dso == NULL) || (symname == NULL)) {\\r\\nDSOerr(DSO_F_WIN32_BIND_VAR, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (sk_void_num(dso->meth_data) < 1) {\\r\\nDSOerr(DSO_F_WIN32_BIND_VAR, DSO_R_STACK_ERROR);\\r\\nreturn (NULL);\\r\\n}\\r\\nptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_WIN32_BIND_VAR, DSO_R_NULL_HANDLE);\\r\\nreturn (NULL);\\r\\n}\\r\\nsym = GetProcAddress(*ptr, symname);\\r\\nif (sym == NULL) {\\r\\nDSOerr(DSO_F_WIN32_BIND_VAR, DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(3, \"symname(\", symname, \")\");\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (sym);\\r\\n}\\r\\nstatic DSO_FUNC_TYPE win32_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nHINSTANCE *ptr;\\r\\nvoid *sym;\\r\\nif ((dso == NULL) || (symname == NULL)) {\\r\\nDSOerr(DSO_F_WIN32_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (sk_void_num(dso->meth_data) < 1) {\\r\\nDSOerr(DSO_F_WIN32_BIND_FUNC, DSO_R_STACK_ERROR);\\r\\nreturn (NULL);\\r\\n}\\r\\nptr = sk_void_value(dso->meth_data, sk_void_num(dso->meth_data) - 1);\\r\\nif (ptr == NULL) {\\r\\nDSOerr(DSO_F_WIN32_BIND_FUNC, DSO_R_NULL_HANDLE);\\r\\nreturn (NULL);\\r\\n}\\r\\nsym = GetProcAddress(*ptr, symname);\\r\\nif (sym == NULL) {\\r\\nDSOerr(DSO_F_WIN32_BIND_FUNC, DSO_R_SYM_FAILURE);\\r\\nERR_add_error_data(3, \"symname(\", symname, \")\");\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn ((DSO_FUNC_TYPE)sym);\\r\\n}\\r\\nstatic struct file_st *win32_splitter(DSO *dso, const char *filename,\\r\\nint assume_last_is_dir)\\r\\n{\\r\\nstruct file_st *result = NULL;\\r\\nenum { IN_NODE, IN_DEVICE, IN_FILE } position;\\r\\nconst char *start = filename;\\r\\nchar last;\\r\\nif (!filename) {\\r\\nDSOerr(DSO_F_WIN32_SPLITTER, DSO_R_NO_FILENAME);\\r\\nreturn (NULL);\\r\\n}\\r\\nresult = OPENSSL_malloc(sizeof(struct file_st));\\r\\nif (result == NULL) {\\r\\nDSOerr(DSO_F_WIN32_SPLITTER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nmemset(result, 0, sizeof(struct file_st));\\r\\nposition = IN_DEVICE;\\r\\nif ((filename[0] == '\\\\' && filename[1] == '\\\\')\\r\\n|| (filename[0] == '/' && filename[1] == '/')) {\\r\\nposition = IN_NODE;\\r\\nfilename += 2;\\r\\nstart = filename;\\r\\nresult->node = start;\\r\\n}\\r\\ndo {\\r\\nlast = filename[0];\\r\\nswitch (last) {\\r\\ncase ':':\\r\\nif (position != IN_DEVICE) {\\r\\nDSOerr(DSO_F_WIN32_SPLITTER, DSO_R_INCORRECT_FILE_SYNTAX);\\r\\nOPENSSL_free(result);\\r\\nreturn (NULL);\\r\\n}\\r\\nresult->device = start;\\r\\nresult->devicelen = (int)(filename - start);\\r\\nposition = IN_FILE;\\r\\nstart = ++filename;\\r\\nresult->dir = start;\\r\\nbreak;\\r\\ncase '\\\\':\\r\\ncase '/':\\r\\nif (position == IN_NODE) {\\r\\nresult->nodelen = (int)(filename - start);\\r\\nposition = IN_FILE;\\r\\nstart = ++filename;\\r\\nresult->dir = start;\\r\\n} else if (position == IN_DEVICE) {\\r\\nposition = IN_FILE;\\r\\nfilename++;\\r\\nresult->dir = start;\\r\\nresult->dirlen = (int)(filename - start);\\r\\nstart = filename;\\r\\n} else {\\r\\nfilename++;\\r\\nresult->dirlen += (int)(filename - start);\\r\\nstart = filename;\\r\\n}\\r\\nbreak;\\r\\ncase '\\0':\\r\\nif (position == IN_NODE) {\\r\\nresult->nodelen = (int)(filename - start);\\r\\n} else {\\r\\nif (filename - start > 0) {\\r\\nif (assume_last_is_dir) {\\r\\nif (position == IN_DEVICE) {\\r\\nresult->dir = start;\\r\\nresult->dirlen = 0;\\r\\n}\\r\\nresult->dirlen += (int)(filename - start);\\r\\n} else {\\r\\nresult->file = start;\\r\\nresult->filelen = (int)(filename - start);\\r\\n}\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nfilename++;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nwhile (last);\\r\\nif (!result->nodelen)\\r\\nresult->node = NULL;\\r\\nif (!result->devicelen)\\r\\nresult->device = NULL;\\r\\nif (!result->dirlen)\\r\\nresult->dir = NULL;\\r\\nif (!result->filelen)\\r\\nresult->file = NULL;\\r\\nreturn (result);\\r\\n}\\r\\nstatic char *win32_joiner(DSO *dso, const struct file_st *file_split)\\r\\n{\\r\\nint len = 0, offset = 0;\\r\\nchar *result = NULL;\\r\\nconst char *start;\\r\\nif (!file_split) {\\r\\nDSOerr(DSO_F_WIN32_JOINER, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (file_split->node) {\\r\\nlen += 2 + file_split->nodelen;\\r\\nif (file_split->predir || file_split->dir || file_split->file)\\r\\nlen++;\\r\\n} else if (file_split->device) {\\r\\nlen += file_split->devicelen + 1;\\r\\n}\\r\\nlen += file_split->predirlen;\\r\\nif (file_split->predir && (file_split->dir || file_split->file)) {\\r\\nlen++;\\r\\n}\\r\\nlen += file_split->dirlen;\\r\\nif (file_split->dir && file_split->file) {\\r\\nlen++;\\r\\n}\\r\\nlen += file_split->filelen;\\r\\nif (!len) {\\r\\nDSOerr(DSO_F_WIN32_JOINER, DSO_R_EMPTY_FILE_STRUCTURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nresult = OPENSSL_malloc(len + 1);\\r\\nif (!result) {\\r\\nDSOerr(DSO_F_WIN32_JOINER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (file_split->node) {\\r\\nstrcpy(&result[offset], \"\\\\\\\\\");\\r\\noffset += 2;\\r\\nstrncpy(&result[offset], file_split->node, file_split->nodelen);\\r\\noffset += file_split->nodelen;\\r\\nif (file_split->predir || file_split->dir || file_split->file) {\\r\\nresult[offset] = '\\\\';\\r\\noffset++;\\r\\n}\\r\\n} else if (file_split->device) {\\r\\nstrncpy(&result[offset], file_split->device, file_split->devicelen);\\r\\noffset += file_split->devicelen;\\r\\nresult[offset] = ':';\\r\\noffset++;\\r\\n}\\r\\nstart = file_split->predir;\\r\\nwhile (file_split->predirlen > (start - file_split->predir)) {\\r\\nconst char *end = openssl_strnchr(start, '/',\\r\\nfile_split->predirlen - (start -\\r\\nfile_split->predir));\\r\\nif (!end)\\r\\nend = start\\r\\n+ file_split->predirlen - (start - file_split->predir);\\r\\nstrncpy(&result[offset], start, end - start);\\r\\noffset += (int)(end - start);\\r\\nresult[offset] = '\\\\';\\r\\noffset++;\\r\\nstart = end + 1;\\r\\n}\\r\\n# if 0\\r\\nif (file_split->predir && (file_split->dir || file_split->file)) {\\r\\nresult[offset] = '\\\\';\\r\\noffset++;\\r\\n}\\r\\n# endif\\r\\nstart = file_split->dir;\\r\\nwhile (file_split->dirlen > (start - file_split->dir)) {\\r\\nconst char *end = openssl_strnchr(start, '/',\\r\\nfile_split->dirlen - (start -\\r\\nfile_split->dir));\\r\\nif (!end)\\r\\nend = start + file_split->dirlen - (start - file_split->dir);\\r\\nstrncpy(&result[offset], start, end - start);\\r\\noffset += (int)(end - start);\\r\\nresult[offset] = '\\\\';\\r\\noffset++;\\r\\nstart = end + 1;\\r\\n}\\r\\n# if 0\\r\\nif (file_split->dir && file_split->file) {\\r\\nresult[offset] = '\\\\';\\r\\noffset++;\\r\\n}\\r\\n# endif\\r\\nstrncpy(&result[offset], file_split->file, file_split->filelen);\\r\\noffset += file_split->filelen;\\r\\nresult[offset] = '\\0';\\r\\nreturn (result);\\r\\n}\\r\\nstatic char *win32_merger(DSO *dso, const char *filespec1,\\r\\nconst char *filespec2)\\r\\n{\\r\\nchar *merged = NULL;\\r\\nstruct file_st *filespec1_split = NULL;\\r\\nstruct file_st *filespec2_split = NULL;\\r\\nif (!filespec1 && !filespec2) {\\r\\nDSOerr(DSO_F_WIN32_MERGER, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (!filespec2) {\\r\\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\\r\\nif (!merged) {\\r\\nDSOerr(DSO_F_WIN32_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nstrcpy(merged, filespec1);\\r\\n} else if (!filespec1) {\\r\\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\\r\\nif (!merged) {\\r\\nDSOerr(DSO_F_WIN32_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nstrcpy(merged, filespec2);\\r\\n} else {\\r\\nfilespec1_split = win32_splitter(dso, filespec1, 0);\\r\\nif (!filespec1_split) {\\r\\nDSOerr(DSO_F_WIN32_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nfilespec2_split = win32_splitter(dso, filespec2, 1);\\r\\nif (!filespec2_split) {\\r\\nDSOerr(DSO_F_WIN32_MERGER, ERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(filespec1_split);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (!filespec1_split->node && !filespec1_split->device) {\\r\\nfilespec1_split->node = filespec2_split->node;\\r\\nfilespec1_split->nodelen = filespec2_split->nodelen;\\r\\nfilespec1_split->device = filespec2_split->device;\\r\\nfilespec1_split->devicelen = filespec2_split->devicelen;\\r\\n}\\r\\nif (!filespec1_split->dir) {\\r\\nfilespec1_split->dir = filespec2_split->dir;\\r\\nfilespec1_split->dirlen = filespec2_split->dirlen;\\r\\n} else if (filespec1_split->dir[0] != '\\\\'\\r\\n&& filespec1_split->dir[0] != '/') {\\r\\nfilespec1_split->predir = filespec2_split->dir;\\r\\nfilespec1_split->predirlen = filespec2_split->dirlen;\\r\\n}\\r\\nif (!filespec1_split->file) {\\r\\nfilespec1_split->file = filespec2_split->file;\\r\\nfilespec1_split->filelen = filespec2_split->filelen;\\r\\n}\\r\\nmerged = win32_joiner(dso, filespec1_split);\\r\\n}\\r\\nOPENSSL_free(filespec1_split);\\r\\nOPENSSL_free(filespec2_split);\\r\\nreturn (merged);\\r\\n}\\r\\nstatic char *win32_name_converter(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *translated;\\r\\nint len, transform;\\r\\nlen = strlen(filename);\\r\\ntransform = ((strstr(filename, \"/\") == NULL) &&\\r\\n(strstr(filename, \"\\\\\") == NULL) &&\\r\\n(strstr(filename, \":\") == NULL));\\r\\nif (transform)\\r\\ntranslated = OPENSSL_malloc(len + 5);\\r\\nelse\\r\\ntranslated = OPENSSL_malloc(len + 1);\\r\\nif (translated == NULL) {\\r\\nDSOerr(DSO_F_WIN32_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (transform)\\r\\nsprintf(translated, \"%s.dll\", filename);\\r\\nelse\\r\\nsprintf(translated, \"%s\", filename);\\r\\nreturn (translated);\\r\\n}\\r\\nstatic const char *openssl_strnchr(const char *string, int c, size_t len)\\r\\n{\\r\\nsize_t i;\\r\\nconst char *p;\\r\\nfor (i = 0, p = string; i < len && *p; i++, p++) {\\r\\nif (*p == c)\\r\\nreturn p;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int win32_pathbyaddr(void *addr, char *path, int sz)\\r\\n{\\r\\nHMODULE dll;\\r\\nHANDLE hModuleSnap = INVALID_HANDLE_VALUE;\\r\\nMODULEENTRY32 me32;\\r\\nCREATETOOLHELP32SNAPSHOT create_snap;\\r\\nCLOSETOOLHELP32SNAPSHOT close_snap;\\r\\nMODULE32 module_first, module_next;\\r\\nif (addr == NULL) {\\r\\nunion {\\r\\nint (*f) (void *, char *, int);\\r\\nvoid *p;\\r\\n} t = {\\r\\nwin32_pathbyaddr\\r\\n};\\r\\naddr = t.p;\\r\\n}\\r\\ndll = LoadLibrary(TEXT(DLLNAME));\\r\\nif (dll == NULL) {\\r\\nDSOerr(DSO_F_WIN32_PATHBYADDR, DSO_R_UNSUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\ncreate_snap = (CREATETOOLHELP32SNAPSHOT)\\r\\nGetProcAddress(dll, \"CreateToolhelp32Snapshot\");\\r\\nif (create_snap == NULL) {\\r\\nFreeLibrary(dll);\\r\\nDSOerr(DSO_F_WIN32_PATHBYADDR, DSO_R_UNSUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\n# ifdef _WIN32_WCE\\r\\nclose_snap = (CLOSETOOLHELP32SNAPSHOT)\\r\\nGetProcAddress(dll, \"CloseToolhelp32Snapshot\");\\r\\n# else\\r\\nclose_snap = (CLOSETOOLHELP32SNAPSHOT) CloseHandle;\\r\\n# endif\\r\\nmodule_first = (MODULE32) GetProcAddress(dll, \"Module32First\");\\r\\nmodule_next = (MODULE32) GetProcAddress(dll, \"Module32Next\");\\r\\nhModuleSnap = (*create_snap) (TH32CS_SNAPMODULE, 0);\\r\\nif (hModuleSnap == INVALID_HANDLE_VALUE) {\\r\\nFreeLibrary(dll);\\r\\nDSOerr(DSO_F_WIN32_PATHBYADDR, DSO_R_UNSUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nme32.dwSize = sizeof(me32);\\r\\nif (!(*module_first) (hModuleSnap, &me32)) {\\r\\n(*close_snap) (hModuleSnap);\\r\\nFreeLibrary(dll);\\r\\nDSOerr(DSO_F_WIN32_PATHBYADDR, DSO_R_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\ndo {\\r\\nif ((BYTE *) addr >= me32.modBaseAddr &&\\r\\n(BYTE *) addr < me32.modBaseAddr + me32.modBaseSize) {\\r\\n(*close_snap) (hModuleSnap);\\r\\nFreeLibrary(dll);\\r\\n# ifdef _WIN32_WCE\\r\\n# if _WIN32_WCE >= 101\\r\\nreturn WideCharToMultiByte(CP_ACP, 0, me32.szExePath, -1,\\r\\npath, sz, NULL, NULL);\\r\\n# else\\r\\n{\\r\\nint i, len = (int)wcslen(me32.szExePath);\\r\\nif (sz <= 0)\\r\\nreturn len + 1;\\r\\nif (len >= sz)\\r\\nlen = sz - 1;\\r\\nfor (i = 0; i < len; i++)\\r\\npath[i] = (char)me32.szExePath[i];\\r\\npath[len++] = 0;\\r\\nreturn len;\\r\\n}\\r\\n# endif\\r\\n# else\\r\\n{\\r\\nint len = (int)strlen(me32.szExePath);\\r\\nif (sz <= 0)\\r\\nreturn len + 1;\\r\\nif (len >= sz)\\r\\nlen = sz - 1;\\r\\nmemcpy(path, me32.szExePath, len);\\r\\npath[len++] = 0;\\r\\nreturn len;\\r\\n}\\r\\n# endif\\r\\n}\\r\\n} while ((*module_next) (hModuleSnap, &me32));\\r\\n(*close_snap) (hModuleSnap);\\r\\nFreeLibrary(dll);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void *win32_globallookup(const char *name)\\r\\n{\\r\\nHMODULE dll;\\r\\nHANDLE hModuleSnap = INVALID_HANDLE_VALUE;\\r\\nMODULEENTRY32 me32;\\r\\nCREATETOOLHELP32SNAPSHOT create_snap;\\r\\nCLOSETOOLHELP32SNAPSHOT close_snap;\\r\\nMODULE32 module_first, module_next;\\r\\nFARPROC ret = NULL;\\r\\ndll = LoadLibrary(TEXT(DLLNAME));\\r\\nif (dll == NULL) {\\r\\nDSOerr(DSO_F_WIN32_GLOBALLOOKUP, DSO_R_UNSUPPORTED);\\r\\nreturn NULL;\\r\\n}\\r\\ncreate_snap = (CREATETOOLHELP32SNAPSHOT)\\r\\nGetProcAddress(dll, \"CreateToolhelp32Snapshot\");\\r\\nif (create_snap == NULL) {\\r\\nFreeLibrary(dll);\\r\\nDSOerr(DSO_F_WIN32_GLOBALLOOKUP, DSO_R_UNSUPPORTED);\\r\\nreturn NULL;\\r\\n}\\r\\n# ifdef _WIN32_WCE\\r\\nclose_snap = (CLOSETOOLHELP32SNAPSHOT)\\r\\nGetProcAddress(dll, \"CloseToolhelp32Snapshot\");\\r\\n# else\\r\\nclose_snap = (CLOSETOOLHELP32SNAPSHOT) CloseHandle;\\r\\n# endif\\r\\nmodule_first = (MODULE32) GetProcAddress(dll, \"Module32First\");\\r\\nmodule_next = (MODULE32) GetProcAddress(dll, \"Module32Next\");\\r\\nhModuleSnap = (*create_snap) (TH32CS_SNAPMODULE, 0);\\r\\nif (hModuleSnap == INVALID_HANDLE_VALUE) {\\r\\nFreeLibrary(dll);\\r\\nDSOerr(DSO_F_WIN32_GLOBALLOOKUP, DSO_R_UNSUPPORTED);\\r\\nreturn NULL;\\r\\n}\\r\\nme32.dwSize = sizeof(me32);\\r\\nif (!(*module_first) (hModuleSnap, &me32)) {\\r\\n(*close_snap) (hModuleSnap);\\r\\nFreeLibrary(dll);\\r\\nreturn NULL;\\r\\n}\\r\\ndo {\\r\\nif ((ret = GetProcAddress(me32.hModule, name))) {\\r\\n(*close_snap) (hModuleSnap);\\r\\nFreeLibrary(dll);\\r\\nreturn ret;\\r\\n}\\r\\n} while ((*module_next) (hModuleSnap, &me32));\\r\\n(*close_snap) (hModuleSnap);\\r\\nFreeLibrary(dll);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_word_c", "target": 0, "func": "BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\n#ifndef BN_LLONG\\r\\nBN_ULONG ret = 0;\\r\\n#else\\r\\nBN_ULLONG ret = 0;\\r\\n#endif\\r\\nint i;\\r\\nif (w == 0)\\r\\nreturn (BN_ULONG)-1;\\r\\nbn_check_top(a);\\r\\nw &= BN_MASK2;\\r\\nfor (i = a->top - 1; i >= 0; i--) {\\r\\n#ifndef BN_LLONG\\r\\nret = ((ret << BN_BITS4) | ((a->d[i] >> BN_BITS4) & BN_MASK2l)) % w;\\r\\nret = ((ret << BN_BITS4) | (a->d[i] & BN_MASK2l)) % w;\\r\\n#else\\r\\nret = (BN_ULLONG) (((ret << (BN_ULLONG) BN_BITS2) | a->d[i]) %\\r\\n(BN_ULLONG) w);\\r\\n#endif\\r\\n}\\r\\nreturn ((BN_ULONG)ret);\\r\\n}\\r\\nBN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG ret = 0;\\r\\nint i, j;\\r\\nbn_check_top(a);\\r\\nw &= BN_MASK2;\\r\\nif (!w)\\r\\nreturn (BN_ULONG)-1;\\r\\nif (a->top == 0)\\r\\nreturn 0;\\r\\nj = BN_BITS2 - BN_num_bits_word(w);\\r\\nw <<= j;\\r\\nif (!BN_lshift(a, a, j))\\r\\nreturn (BN_ULONG)-1;\\r\\nfor (i = a->top - 1; i >= 0; i--) {\\r\\nBN_ULONG l, d;\\r\\nl = a->d[i];\\r\\nd = bn_div_words(ret, l, w);\\r\\nret = (l - ((d * w) & BN_MASK2)) & BN_MASK2;\\r\\na->d[i] = d;\\r\\n}\\r\\nif ((a->top > 0) && (a->d[a->top - 1] == 0))\\r\\na->top--;\\r\\nret >>= j;\\r\\nbn_check_top(a);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_add_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG l;\\r\\nint i;\\r\\nbn_check_top(a);\\r\\nw &= BN_MASK2;\\r\\nif (!w)\\r\\nreturn 1;\\r\\nif (BN_is_zero(a))\\r\\nreturn BN_set_word(a, w);\\r\\nif (a->neg) {\\r\\na->neg = 0;\\r\\ni = BN_sub_word(a, w);\\r\\nif (!BN_is_zero(a))\\r\\na->neg = !(a->neg);\\r\\nreturn (i);\\r\\n}\\r\\nfor (i = 0; w != 0 && i < a->top; i++) {\\r\\na->d[i] = l = (a->d[i] + w) & BN_MASK2;\\r\\nw = (w > l) ? 1 : 0;\\r\\n}\\r\\nif (w && i == a->top) {\\r\\nif (bn_wexpand(a, a->top + 1) == NULL)\\r\\nreturn 0;\\r\\na->top++;\\r\\na->d[i] = w;\\r\\n}\\r\\nbn_check_top(a);\\r\\nreturn (1);\\r\\n}\\r\\nint BN_sub_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nint i;\\r\\nbn_check_top(a);\\r\\nw &= BN_MASK2;\\r\\nif (!w)\\r\\nreturn 1;\\r\\nif (BN_is_zero(a)) {\\r\\ni = BN_set_word(a, w);\\r\\nif (i != 0)\\r\\nBN_set_negative(a, 1);\\r\\nreturn i;\\r\\n}\\r\\nif (a->neg) {\\r\\na->neg = 0;\\r\\ni = BN_add_word(a, w);\\r\\na->neg = 1;\\r\\nreturn (i);\\r\\n}\\r\\nif ((a->top == 1) && (a->d[0] < w)) {\\r\\na->d[0] = w - a->d[0];\\r\\na->neg = 1;\\r\\nreturn (1);\\r\\n}\\r\\ni = 0;\\r\\nfor (;;) {\\r\\nif (a->d[i] >= w) {\\r\\na->d[i] -= w;\\r\\nbreak;\\r\\n} else {\\r\\na->d[i] = (a->d[i] - w) & BN_MASK2;\\r\\ni++;\\r\\nw = 1;\\r\\n}\\r\\n}\\r\\nif ((a->d[i] == 0) && (i == (a->top - 1)))\\r\\na->top--;\\r\\nbn_check_top(a);\\r\\nreturn (1);\\r\\n}\\r\\nint BN_mul_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nBN_ULONG ll;\\r\\nbn_check_top(a);\\r\\nw &= BN_MASK2;\\r\\nif (a->top) {\\r\\nif (w == 0)\\r\\nBN_zero(a);\\r\\nelse {\\r\\nll = bn_mul_words(a->d, a->d, a->top, w);\\r\\nif (ll) {\\r\\nif (bn_wexpand(a, a->top + 1) == NULL)\\r\\nreturn (0);\\r\\na->d[a->top++] = ll;\\r\\n}\\r\\n}\\r\\n}\\r\\nbn_check_top(a);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_x931p_c", "target": 0, "func": "static int bn_x931_derive_pi(BIGNUM *pi, const BIGNUM *Xpi, BN_CTX *ctx,\\r\\nBN_GENCB *cb)\\r\\n{\\r\\nint i = 0;\\r\\nif (!BN_copy(pi, Xpi))\\r\\nreturn 0;\\r\\nif (!BN_is_odd(pi) && !BN_add_word(pi, 1))\\r\\nreturn 0;\\r\\nfor (;;) {\\r\\ni++;\\r\\nBN_GENCB_call(cb, 0, i);\\r\\nif (BN_is_prime_fasttest_ex(pi, 27, ctx, 1, cb))\\r\\nbreak;\\r\\nif (!BN_add_word(pi, 2))\\r\\nreturn 0;\\r\\n}\\r\\nBN_GENCB_call(cb, 2, i);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_X931_derive_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2,\\r\\nconst BIGNUM *Xp, const BIGNUM *Xp1,\\r\\nconst BIGNUM *Xp2, const BIGNUM *e, BN_CTX *ctx,\\r\\nBN_GENCB *cb)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *t, *p1p2, *pm1;\\r\\nif (!BN_is_odd(e))\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (!p1)\\r\\np1 = BN_CTX_get(ctx);\\r\\nif (!p2)\\r\\np2 = BN_CTX_get(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\np1p2 = BN_CTX_get(ctx);\\r\\npm1 = BN_CTX_get(ctx);\\r\\nif (!bn_x931_derive_pi(p1, Xp1, ctx, cb))\\r\\ngoto err;\\r\\nif (!bn_x931_derive_pi(p2, Xp2, ctx, cb))\\r\\ngoto err;\\r\\nif (!BN_mul(p1p2, p1, p2, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_inverse(p, p2, p1, ctx))\\r\\ngoto err;\\r\\nif (!BN_mul(p, p, p2, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_inverse(t, p1, p2, ctx))\\r\\ngoto err;\\r\\nif (!BN_mul(t, t, p1, ctx))\\r\\ngoto err;\\r\\nif (!BN_sub(p, p, t))\\r\\ngoto err;\\r\\nif (p->neg && !BN_add(p, p, p1p2))\\r\\ngoto err;\\r\\nif (!BN_mod_sub(p, p, Xp, p1p2, ctx))\\r\\ngoto err;\\r\\nif (!BN_add(p, p, Xp))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nint i = 1;\\r\\nBN_GENCB_call(cb, 0, i++);\\r\\nif (!BN_copy(pm1, p))\\r\\ngoto err;\\r\\nif (!BN_sub_word(pm1, 1))\\r\\ngoto err;\\r\\nif (!BN_gcd(t, pm1, e, ctx))\\r\\ngoto err;\\r\\nif (BN_is_one(t)\\r\\n&& BN_is_prime_fasttest_ex(p, 50, ctx, 1, cb))\\r\\nbreak;\\r\\nif (!BN_add(p, p, p1p2))\\r\\ngoto err;\\r\\n}\\r\\nBN_GENCB_call(cb, 3, 0);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_X931_generate_Xpq(BIGNUM *Xp, BIGNUM *Xq, int nbits, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *t;\\r\\nint i;\\r\\nif ((nbits < 1024) || (nbits & 0xff))\\r\\nreturn 0;\\r\\nnbits >>= 1;\\r\\nif (!BN_rand(Xp, nbits, 1, 0))\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\nfor (i = 0; i < 1000; i++) {\\r\\nif (!BN_rand(Xq, nbits, 1, 0))\\r\\nreturn 0;\\r\\nBN_sub(t, Xp, Xq);\\r\\nif (BN_num_bits(t) > (nbits - 100))\\r\\nbreak;\\r\\n}\\r\\nBN_CTX_end(ctx);\\r\\nif (i < 1000)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint BN_X931_generate_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2,\\r\\nBIGNUM *Xp1, BIGNUM *Xp2,\\r\\nconst BIGNUM *Xp,\\r\\nconst BIGNUM *e, BN_CTX *ctx, BN_GENCB *cb)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (!Xp1)\\r\\nXp1 = BN_CTX_get(ctx);\\r\\nif (!Xp2)\\r\\nXp2 = BN_CTX_get(ctx);\\r\\nif (!BN_rand(Xp1, 101, 0, 0))\\r\\ngoto error;\\r\\nif (!BN_rand(Xp2, 101, 0, 0))\\r\\ngoto error;\\r\\nif (!BN_X931_derive_prime_ex(p, p1, p2, Xp, Xp1, Xp2, e, ctx, cb))\\r\\ngoto error;\\r\\nret = 1;\\r\\nerror:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_rc2_c", "target": 0, "func": "const EVP_CIPHER *EVP_rc2_64_cbc(void)\\r\\n{\\r\\nreturn (&r2_64_cbc_cipher);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_rc2_40_cbc(void)\\r\\n{\\r\\nreturn (&r2_40_cbc_cipher);\\r\\n}\\r\\nstatic int rc2_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nRC2_set_key(&data(ctx)->ks, EVP_CIPHER_CTX_key_length(ctx),\\r\\nkey, data(ctx)->key_bits);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rc2_meth_to_magic(EVP_CIPHER_CTX *e)\\r\\n{\\r\\nint i;\\r\\nEVP_CIPHER_CTX_ctrl(e, EVP_CTRL_GET_RC2_KEY_BITS, 0, &i);\\r\\nif (i == 128)\\r\\nreturn (RC2_128_MAGIC);\\r\\nelse if (i == 64)\\r\\nreturn (RC2_64_MAGIC);\\r\\nelse if (i == 40)\\r\\nreturn (RC2_40_MAGIC);\\r\\nelse\\r\\nreturn (0);\\r\\n}\\r\\nstatic int rc2_magic_to_meth(int i)\\r\\n{\\r\\nif (i == RC2_128_MAGIC)\\r\\nreturn 128;\\r\\nelse if (i == RC2_64_MAGIC)\\r\\nreturn 64;\\r\\nelse if (i == RC2_40_MAGIC)\\r\\nreturn 40;\\r\\nelse {\\r\\nEVPerr(EVP_F_RC2_MAGIC_TO_METH, EVP_R_UNSUPPORTED_KEY_SIZE);\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nstatic int rc2_get_asn1_type_and_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nlong num = 0;\\r\\nint i = 0;\\r\\nint key_bits;\\r\\nunsigned int l;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nif (type != NULL) {\\r\\nl = EVP_CIPHER_CTX_iv_length(c);\\r\\nOPENSSL_assert(l <= sizeof(iv));\\r\\ni = ASN1_TYPE_get_int_octetstring(type, &num, iv, l);\\r\\nif (i != (int)l)\\r\\nreturn (-1);\\r\\nkey_bits = rc2_magic_to_meth((int)num);\\r\\nif (!key_bits)\\r\\nreturn (-1);\\r\\nif (i > 0 && !EVP_CipherInit_ex(c, NULL, NULL, NULL, iv, -1))\\r\\nreturn -1;\\r\\nEVP_CIPHER_CTX_ctrl(c, EVP_CTRL_SET_RC2_KEY_BITS, key_bits, NULL);\\r\\nEVP_CIPHER_CTX_set_key_length(c, key_bits / 8);\\r\\n}\\r\\nreturn (i);\\r\\n}\\r\\nstatic int rc2_set_asn1_type_and_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)\\r\\n{\\r\\nlong num;\\r\\nint i = 0, j;\\r\\nif (type != NULL) {\\r\\nnum = rc2_meth_to_magic(c);\\r\\nj = EVP_CIPHER_CTX_iv_length(c);\\r\\ni = ASN1_TYPE_set_int_octetstring(type, num, c->oiv, j);\\r\\n}\\r\\nreturn (i);\\r\\n}\\r\\nstatic int rc2_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nswitch (type) {\\r\\ncase EVP_CTRL_INIT:\\r\\ndata(c)->key_bits = EVP_CIPHER_CTX_key_length(c) * 8;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GET_RC2_KEY_BITS:\\r\\n*(int *)ptr = data(c)->key_bits;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_SET_RC2_KEY_BITS:\\r\\nif (arg > 0) {\\r\\ndata(c)->key_bits = arg;\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n# ifdef PBE_PRF_TEST\\r\\ncase EVP_CTRL_PBE_PRF_NID:\\r\\n*(int *)ptr = NID_hmacWithMD5;\\r\\nreturn 1;\\r\\n# endif\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_md_rand_c", "target": 0, "func": "RAND_METHOD *RAND_SSLeay(void)\\r\\n{\\r\\nreturn (&rand_ssleay_meth);\\r\\n}\\r\\nstatic void ssleay_rand_cleanup(void)\\r\\n{\\r\\nOPENSSL_cleanse(state, sizeof(state));\\r\\nstate_num = 0;\\r\\nstate_index = 0;\\r\\nOPENSSL_cleanse(md, MD_DIGEST_LENGTH);\\r\\nmd_count[0] = 0;\\r\\nmd_count[1] = 0;\\r\\nentropy = 0;\\r\\ninitialized = 0;\\r\\n}\\r\\nstatic void ssleay_rand_add(const void *buf, int num, double add)\\r\\n{\\r\\nint i, j, k, st_idx;\\r\\nlong md_c[2];\\r\\nunsigned char local_md[MD_DIGEST_LENGTH];\\r\\nEVP_MD_CTX m;\\r\\nint do_not_lock;\\r\\nif (!num)\\r\\nreturn;\\r\\nif (crypto_lock_rand) {\\r\\nCRYPTO_THREADID cur;\\r\\nCRYPTO_THREADID_current(&cur);\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_RAND2);\\r\\ndo_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_RAND2);\\r\\n} else\\r\\ndo_not_lock = 0;\\r\\nif (!do_not_lock)\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nst_idx = state_index;\\r\\nmd_c[0] = md_count[0];\\r\\nmd_c[1] = md_count[1];\\r\\nmemcpy(local_md, md, sizeof md);\\r\\nstate_index += num;\\r\\nif (state_index >= STATE_SIZE) {\\r\\nstate_index %= STATE_SIZE;\\r\\nstate_num = STATE_SIZE;\\r\\n} else if (state_num < STATE_SIZE) {\\r\\nif (state_index > state_num)\\r\\nstate_num = state_index;\\r\\n}\\r\\nmd_count[1] += (num / MD_DIGEST_LENGTH) + (num % MD_DIGEST_LENGTH > 0);\\r\\nif (!do_not_lock)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nEVP_MD_CTX_init(&m);\\r\\nfor (i = 0; i < num; i += MD_DIGEST_LENGTH) {\\r\\nj = (num - i);\\r\\nj = (j > MD_DIGEST_LENGTH) ? MD_DIGEST_LENGTH : j;\\r\\nMD_Init(&m);\\r\\nMD_Update(&m, local_md, MD_DIGEST_LENGTH);\\r\\nk = (st_idx + j) - STATE_SIZE;\\r\\nif (k > 0) {\\r\\nMD_Update(&m, &(state[st_idx]), j - k);\\r\\nMD_Update(&m, &(state[0]), k);\\r\\n} else\\r\\nMD_Update(&m, &(state[st_idx]), j);\\r\\nMD_Update(&m, buf, j);\\r\\nMD_Update(&m, (unsigned char *)&(md_c[0]), sizeof(md_c));\\r\\nMD_Final(&m, local_md);\\r\\nmd_c[1]++;\\r\\nbuf = (const char *)buf + j;\\r\\nfor (k = 0; k < j; k++) {\\r\\nstate[st_idx++] ^= local_md[k];\\r\\nif (st_idx >= STATE_SIZE)\\r\\nst_idx = 0;\\r\\n}\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&m);\\r\\nif (!do_not_lock)\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nfor (k = 0; k < (int)sizeof(md); k++) {\\r\\nmd[k] ^= local_md[k];\\r\\n}\\r\\nif (entropy < ENTROPY_NEEDED)\\r\\nentropy += add;\\r\\nif (!do_not_lock)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\n#if !defined(OPENSSL_THREADS) && !defined(OPENSSL_SYS_WIN32)\\r\\nassert(md_c[1] == md_count[1]);\\r\\n#endif\\r\\n}\\r\\nstatic void ssleay_rand_seed(const void *buf, int num)\\r\\n{\\r\\nssleay_rand_add(buf, num, (double)num);\\r\\n}\\r\\nint ssleay_rand_bytes(unsigned char *buf, int num, int pseudo, int lock)\\r\\n{\\r\\nstatic volatile int stirred_pool = 0;\\r\\nint i, j, k, st_num, st_idx;\\r\\nint num_ceil;\\r\\nint ok;\\r\\nlong md_c[2];\\r\\nunsigned char local_md[MD_DIGEST_LENGTH];\\r\\nEVP_MD_CTX m;\\r\\n#ifndef GETPID_IS_MEANINGLESS\\r\\npid_t curr_pid = getpid();\\r\\n#endif\\r\\nint do_stir_pool = 0;\\r\\n#ifdef PREDICT\\r\\nif (rand_predictable) {\\r\\nstatic unsigned char val = 0;\\r\\nfor (i = 0; i < num; i++)\\r\\nbuf[i] = val++;\\r\\nreturn (1);\\r\\n}\\r\\n#endif\\r\\nif (num <= 0)\\r\\nreturn 1;\\r\\nEVP_MD_CTX_init(&m);\\r\\nnum_ceil =\\r\\n(1 + (num - 1) / (MD_DIGEST_LENGTH / 2)) * (MD_DIGEST_LENGTH / 2);\\r\\nif (lock)\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND2);\\r\\nCRYPTO_THREADID_current(&locking_threadid);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND2);\\r\\ncrypto_lock_rand = 1;\\r\\nif (!initialized) {\\r\\nRAND_poll();\\r\\ninitialized = 1;\\r\\n}\\r\\nif (!stirred_pool)\\r\\ndo_stir_pool = 1;\\r\\nok = (entropy >= ENTROPY_NEEDED);\\r\\nif (!ok) {\\r\\nentropy -= num;\\r\\nif (entropy < 0)\\r\\nentropy = 0;\\r\\n}\\r\\nif (do_stir_pool) {\\r\\nint n = STATE_SIZE;\\r\\nwhile (n > 0) {\\r\\n#if MD_DIGEST_LENGTH > 20\\r\\n# error \"Please adjust DUMMY_SEED.\"\\r\\n#endif\\r\\n#define DUMMY_SEED \"....................\"\\r\\nssleay_rand_add(DUMMY_SEED, MD_DIGEST_LENGTH, 0.0);\\r\\nn -= MD_DIGEST_LENGTH;\\r\\n}\\r\\nif (ok)\\r\\nstirred_pool = 1;\\r\\n}\\r\\nst_idx = state_index;\\r\\nst_num = state_num;\\r\\nmd_c[0] = md_count[0];\\r\\nmd_c[1] = md_count[1];\\r\\nmemcpy(local_md, md, sizeof md);\\r\\nstate_index += num_ceil;\\r\\nif (state_index > state_num)\\r\\nstate_index %= state_num;\\r\\nmd_count[0] += 1;\\r\\ncrypto_lock_rand = 0;\\r\\nif (lock)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nwhile (num > 0) {\\r\\nj = (num >= MD_DIGEST_LENGTH / 2) ? MD_DIGEST_LENGTH / 2 : num;\\r\\nnum -= j;\\r\\nMD_Init(&m);\\r\\n#ifndef GETPID_IS_MEANINGLESS\\r\\nif (curr_pid) {\\r\\nMD_Update(&m, (unsigned char *)&curr_pid, sizeof curr_pid);\\r\\ncurr_pid = 0;\\r\\n}\\r\\n#endif\\r\\nMD_Update(&m, local_md, MD_DIGEST_LENGTH);\\r\\nMD_Update(&m, (unsigned char *)&(md_c[0]), sizeof(md_c));\\r\\n#ifndef PURIFY\\r\\nMD_Update(&m, buf, j);\\r\\n#endif\\r\\nk = (st_idx + MD_DIGEST_LENGTH / 2) - st_num;\\r\\nif (k > 0) {\\r\\nMD_Update(&m, &(state[st_idx]), MD_DIGEST_LENGTH / 2 - k);\\r\\nMD_Update(&m, &(state[0]), k);\\r\\n} else\\r\\nMD_Update(&m, &(state[st_idx]), MD_DIGEST_LENGTH / 2);\\r\\nMD_Final(&m, local_md);\\r\\nfor (i = 0; i < MD_DIGEST_LENGTH / 2; i++) {\\r\\nstate[st_idx++] ^= local_md[i];\\r\\nif (st_idx >= st_num)\\r\\nst_idx = 0;\\r\\nif (i < j)\\r\\n*(buf++) = local_md[i + MD_DIGEST_LENGTH / 2];\\r\\n}\\r\\n}\\r\\nMD_Init(&m);\\r\\nMD_Update(&m, (unsigned char *)&(md_c[0]), sizeof(md_c));\\r\\nMD_Update(&m, local_md, MD_DIGEST_LENGTH);\\r\\nif (lock)\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nMD_Update(&m, md, MD_DIGEST_LENGTH);\\r\\nMD_Final(&m, md);\\r\\nif (lock)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\nEVP_MD_CTX_cleanup(&m);\\r\\nif (ok)\\r\\nreturn (1);\\r\\nelse if (pseudo)\\r\\nreturn 0;\\r\\nelse {\\r\\nRANDerr(RAND_F_SSLEAY_RAND_BYTES, RAND_R_PRNG_NOT_SEEDED);\\r\\nERR_add_error_data(1, \"You need to read the OpenSSL FAQ, \"\\r\\n\"http://www.openssl.org/support/faq.html\");\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nstatic int ssleay_rand_nopseudo_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nreturn ssleay_rand_bytes(buf, num, 0, 1);\\r\\n}\\r\\nstatic int ssleay_rand_pseudo_bytes(unsigned char *buf, int num)\\r\\n{\\r\\nreturn ssleay_rand_bytes(buf, num, 1, 1);\\r\\n}\\r\\nstatic int ssleay_rand_status(void)\\r\\n{\\r\\nCRYPTO_THREADID cur;\\r\\nint ret;\\r\\nint do_not_lock;\\r\\nCRYPTO_THREADID_current(&cur);\\r\\nif (crypto_lock_rand) {\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_RAND2);\\r\\ndo_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_RAND2);\\r\\n} else\\r\\ndo_not_lock = 0;\\r\\nif (!do_not_lock) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_RAND2);\\r\\nCRYPTO_THREADID_cpy(&locking_threadid, &cur);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND2);\\r\\ncrypto_lock_rand = 1;\\r\\n}\\r\\nif (!initialized) {\\r\\nRAND_poll();\\r\\ninitialized = 1;\\r\\n}\\r\\nret = entropy >= ENTROPY_NEEDED;\\r\\nif (!do_not_lock) {\\r\\ncrypto_lock_rand = 0;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_RAND);\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec2_oct_c", "target": 0, "func": "int ec_GF2m_simple_set_compressed_coordinates(const EC_GROUP *group,\\r\\nEC_POINT *point,\\r\\nconst BIGNUM *x_, int y_bit,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp, *x, *y, *z;\\r\\nint ret = 0, z0;\\r\\nERR_clear_error();\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\ny_bit = (y_bit != 0) ? 1 : 0;\\r\\nBN_CTX_start(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nz = BN_CTX_get(ctx);\\r\\nif (z == NULL)\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_arr(x, x_, group->poly))\\r\\ngoto err;\\r\\nif (BN_is_zero(x)) {\\r\\nif (!BN_GF2m_mod_sqrt_arr(y, &group->b, group->poly, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!group->meth->field_sqr(group, tmp, x, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_div(group, tmp, &group->b, tmp, ctx))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(tmp, &group->a, tmp))\\r\\ngoto err;\\r\\nif (!BN_GF2m_add(tmp, x, tmp))\\r\\ngoto err;\\r\\nif (!BN_GF2m_mod_solve_quad_arr(z, tmp, group->poly, ctx)) {\\r\\nunsigned long err = ERR_peek_last_error();\\r\\nif (ERR_GET_LIB(err) == ERR_LIB_BN\\r\\n&& ERR_GET_REASON(err) == BN_R_NO_SOLUTION) {\\r\\nERR_clear_error();\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES,\\r\\nEC_R_INVALID_COMPRESSED_POINT);\\r\\n} else\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES,\\r\\nERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nz0 = (BN_is_odd(z)) ? 1 : 0;\\r\\nif (!group->meth->field_mul(group, y, x, z, ctx))\\r\\ngoto err;\\r\\nif (z0 != y_bit) {\\r\\nif (!BN_GF2m_add(y, y, x))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, point, x, y, ctx))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nsize_t ec_GF2m_simple_point2oct(const EC_GROUP *group, const EC_POINT *point,\\r\\npoint_conversion_form_t form,\\r\\nunsigned char *buf, size_t len, BN_CTX *ctx)\\r\\n{\\r\\nsize_t ret;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint used_ctx = 0;\\r\\nBIGNUM *x, *y, *yxi;\\r\\nsize_t field_len, i, skip;\\r\\nif ((form != POINT_CONVERSION_COMPRESSED)\\r\\n&& (form != POINT_CONVERSION_UNCOMPRESSED)\\r\\n&& (form != POINT_CONVERSION_HYBRID)) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_INVALID_FORM);\\r\\ngoto err;\\r\\n}\\r\\nif (EC_POINT_is_at_infinity(group, point)) {\\r\\nif (buf != NULL) {\\r\\nif (len < 1) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nbuf[0] = 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nfield_len = (EC_GROUP_get_degree(group) + 7) / 8;\\r\\nret =\\r\\n(form ==\\r\\nPOINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2 * field_len;\\r\\nif (buf != NULL) {\\r\\nif (len < ret) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, EC_R_BUFFER_TOO_SMALL);\\r\\ngoto err;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nused_ctx = 1;\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nyxi = BN_CTX_get(ctx);\\r\\nif (yxi == NULL)\\r\\ngoto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, point, x, y, ctx))\\r\\ngoto err;\\r\\nbuf[0] = form;\\r\\nif ((form != POINT_CONVERSION_UNCOMPRESSED) && !BN_is_zero(x)) {\\r\\nif (!group->meth->field_div(group, yxi, y, x, ctx))\\r\\ngoto err;\\r\\nif (BN_is_odd(yxi))\\r\\nbuf[0]++;\\r\\n}\\r\\ni = 1;\\r\\nskip = field_len - BN_num_bytes(x);\\r\\nif (skip > field_len) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwhile (skip > 0) {\\r\\nbuf[i++] = 0;\\r\\nskip--;\\r\\n}\\r\\nskip = BN_bn2bin(x, buf + i);\\r\\ni += skip;\\r\\nif (i != 1 + field_len) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_UNCOMPRESSED\\r\\n|| form == POINT_CONVERSION_HYBRID) {\\r\\nskip = field_len - BN_num_bytes(y);\\r\\nif (skip > field_len) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nwhile (skip > 0) {\\r\\nbuf[i++] = 0;\\r\\nskip--;\\r\\n}\\r\\nskip = BN_bn2bin(y, buf + i);\\r\\ni += skip;\\r\\n}\\r\\nif (i != ret) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_POINT2OCT, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (used_ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\nerr:\\r\\nif (used_ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn 0;\\r\\n}\\r\\nint ec_GF2m_simple_oct2point(const EC_GROUP *group, EC_POINT *point,\\r\\nconst unsigned char *buf, size_t len,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\npoint_conversion_form_t form;\\r\\nint y_bit;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y, *yxi;\\r\\nsize_t field_len, enc_len;\\r\\nint ret = 0;\\r\\nif (len == 0) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_BUFFER_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nform = buf[0];\\r\\ny_bit = form & 1;\\r\\nform = form & ~1U;\\r\\nif ((form != 0) && (form != POINT_CONVERSION_COMPRESSED)\\r\\n&& (form != POINT_CONVERSION_UNCOMPRESSED)\\r\\n&& (form != POINT_CONVERSION_HYBRID)) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif ((form == 0 || form == POINT_CONVERSION_UNCOMPRESSED) && y_bit) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif (form == 0) {\\r\\nif (len != 1) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EC_POINT_set_to_infinity(group, point);\\r\\n}\\r\\nfield_len = (EC_GROUP_get_degree(group) + 7) / 8;\\r\\nenc_len =\\r\\n(form ==\\r\\nPOINT_CONVERSION_COMPRESSED) ? 1 + field_len : 1 + 2 * field_len;\\r\\nif (len != enc_len) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nyxi = BN_CTX_get(ctx);\\r\\nif (yxi == NULL)\\r\\ngoto err;\\r\\nif (!BN_bin2bn(buf + 1, field_len, x))\\r\\ngoto err;\\r\\nif (BN_ucmp(x, &group->field) >= 0) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_COMPRESSED) {\\r\\nif (!EC_POINT_set_compressed_coordinates_GF2m\\r\\n(group, point, x, y_bit, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_bin2bn(buf + 1 + field_len, field_len, y))\\r\\ngoto err;\\r\\nif (BN_ucmp(y, &group->field) >= 0) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\nif (form == POINT_CONVERSION_HYBRID) {\\r\\nif (!group->meth->field_div(group, yxi, y, x, ctx))\\r\\ngoto err;\\r\\nif (y_bit != BN_is_odd(yxi)) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_INVALID_ENCODING);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, point, x, y, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_is_on_curve(group, point, ctx)) {\\r\\nECerr(EC_F_EC_GF2M_SIMPLE_OCT2POINT, EC_R_POINT_IS_NOT_ON_CURVE);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_mdc2_one_c", "target": 0, "func": "unsigned char *MDC2(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nMDC2_CTX c;\\r\\nstatic unsigned char m[MDC2_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nif (!MDC2_Init(&c))\\r\\nreturn NULL;\\r\\nMDC2_Update(&c, d, n);\\r\\nMDC2_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_i2d_fp_c", "target": 0, "func": "int ASN1_i2d_fp(i2d_of_void *i2d, FILE *out, void *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nASN1err(ASN1_F_ASN1_I2D_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, out, BIO_NOCLOSE);\\r\\nret = ASN1_i2d_bio(i2d, b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, unsigned char *x)\\r\\n{\\r\\nchar *b;\\r\\nunsigned char *p;\\r\\nint i, j = 0, n, ret = 1;\\r\\nn = i2d(x, NULL);\\r\\nb = (char *)OPENSSL_malloc(n);\\r\\nif (b == NULL) {\\r\\nASN1err(ASN1_F_ASN1_I2D_BIO, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\np = (unsigned char *)b;\\r\\ni2d(x, &p);\\r\\nfor (;;) {\\r\\ni = BIO_write(out, &(b[j]), n);\\r\\nif (i == n)\\r\\nbreak;\\r\\nif (i <= 0) {\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nj += i;\\r\\nn -= i;\\r\\n}\\r\\nOPENSSL_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, void *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_I2D_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, out, BIO_NOCLOSE);\\r\\nret = ASN1_item_i2d_bio(it, b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, void *x)\\r\\n{\\r\\nunsigned char *b = NULL;\\r\\nint i, j = 0, n, ret = 1;\\r\\nn = ASN1_item_i2d(x, &b, it);\\r\\nif (b == NULL) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_I2D_BIO, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nfor (;;) {\\r\\ni = BIO_write(out, &(b[j]), n);\\r\\nif (i == n)\\r\\nbreak;\\r\\nif (i <= 0) {\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nj += i;\\r\\nn -= i;\\r\\n}\\r\\nOPENSSL_free(b);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rand_win_c", "target": 0, "func": "int RAND_poll(void)\\r\\n{\\r\\nMEMORYSTATUS m;\\r\\nHCRYPTPROV hProvider = 0;\\r\\nDWORD w;\\r\\nint good = 0;\\r\\n# if defined(OPENSSL_SYS_WINCE)\\r\\n# if defined(_WIN32_WCE) && _WIN32_WCE>=300\\r\\n{\\r\\nBYTE buf[64];\\r\\nif (CryptAcquireContextW(&hProvider, NULL, NULL, PROV_RSA_FULL,\\r\\nCRYPT_VERIFYCONTEXT)) {\\r\\nif (CryptGenRandom(hProvider, sizeof(buf), buf))\\r\\nRAND_add(buf, sizeof(buf), sizeof(buf));\\r\\nCryptReleaseContext(hProvider, 0);\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# else\\r\\n{\\r\\nHMODULE advapi = LoadLibrary(TEXT(\"ADVAPI32.DLL\"));\\r\\nHMODULE kernel = LoadLibrary(TEXT(\"KERNEL32.DLL\"));\\r\\nHMODULE user = NULL;\\r\\nHMODULE netapi = LoadLibrary(TEXT(\"NETAPI32.DLL\"));\\r\\nCRYPTACQUIRECONTEXTW acquire = NULL;\\r\\nCRYPTGENRANDOM gen = NULL;\\r\\nCRYPTRELEASECONTEXT release = NULL;\\r\\nNETSTATGET netstatget = NULL;\\r\\nNETFREE netfree = NULL;\\r\\nBYTE buf[64];\\r\\nif (netapi) {\\r\\nnetstatget =\\r\\n(NETSTATGET) GetProcAddress(netapi, \"NetStatisticsGet\");\\r\\nnetfree = (NETFREE) GetProcAddress(netapi, \"NetApiBufferFree\");\\r\\n}\\r\\nif (netstatget && netfree) {\\r\\nLPBYTE outbuf;\\r\\nif (netstatget(NULL, L\"LanmanWorkstation\", 0, 0, &outbuf) == 0) {\\r\\nRAND_add(outbuf, sizeof(STAT_WORKSTATION_0), 45);\\r\\nnetfree(outbuf);\\r\\n}\\r\\nif (netstatget(NULL, L\"LanmanServer\", 0, 0, &outbuf) == 0) {\\r\\nRAND_add(outbuf, sizeof(STAT_SERVER_0), 17);\\r\\nnetfree(outbuf);\\r\\n}\\r\\n}\\r\\nif (netapi)\\r\\nFreeLibrary(netapi);\\r\\nif (advapi) {\\r\\nacquire = (CRYPTACQUIRECONTEXTW) GetProcAddress(advapi,\\r\\n\"CryptAcquireContextW\");\\r\\ngen = (CRYPTGENRANDOM) GetProcAddress(advapi, \"CryptGenRandom\");\\r\\nrelease = (CRYPTRELEASECONTEXT) GetProcAddress(advapi,\\r\\n\"CryptReleaseContext\");\\r\\n}\\r\\nif (acquire && gen && release) {\\r\\nif (acquire(&hProvider, NULL, NULL, PROV_RSA_FULL,\\r\\nCRYPT_VERIFYCONTEXT)) {\\r\\nif (gen(hProvider, sizeof(buf), buf) != 0) {\\r\\nRAND_add(buf, sizeof(buf), 0);\\r\\ngood = 1;\\r\\n# if 0\\r\\nprintf(\"randomness from PROV_RSA_FULL\\n\");\\r\\n# endif\\r\\n}\\r\\nrelease(hProvider, 0);\\r\\n}\\r\\nif (acquire(&hProvider, 0, INTEL_DEF_PROV, PROV_INTEL_SEC, 0)) {\\r\\nif (gen(hProvider, sizeof(buf), buf) != 0) {\\r\\nRAND_add(buf, sizeof(buf), sizeof(buf));\\r\\ngood = 1;\\r\\n# if 0\\r\\nprintf(\"randomness from PROV_INTEL_SEC\\n\");\\r\\n# endif\\r\\n}\\r\\nrelease(hProvider, 0);\\r\\n}\\r\\n}\\r\\nif (advapi)\\r\\nFreeLibrary(advapi);\\r\\nif ((!check_winnt() ||\\r\\n!OPENSSL_isservice()) &&\\r\\n(user = LoadLibrary(TEXT(\"USER32.DLL\")))) {\\r\\nGETCURSORINFO cursor;\\r\\nGETFOREGROUNDWINDOW win;\\r\\nGETQUEUESTATUS queue;\\r\\nwin =\\r\\n(GETFOREGROUNDWINDOW) GetProcAddress(user,\\r\\n\"GetForegroundWindow\");\\r\\ncursor = (GETCURSORINFO) GetProcAddress(user, \"GetCursorInfo\");\\r\\nqueue = (GETQUEUESTATUS) GetProcAddress(user, \"GetQueueStatus\");\\r\\nif (win) {\\r\\nHWND h = win();\\r\\nRAND_add(&h, sizeof(h), 0);\\r\\n}\\r\\nif (cursor) {\\r\\nif (check_winnt() && !check_win_minplat(5))\\r\\ncursor = 0;\\r\\n}\\r\\nif (cursor) {\\r\\nCURSORINFO ci;\\r\\nci.cbSize = sizeof(CURSORINFO);\\r\\nif (cursor(&ci))\\r\\nRAND_add(&ci, ci.cbSize, 2);\\r\\n}\\r\\nif (queue) {\\r\\nw = queue(QS_ALLEVENTS);\\r\\nRAND_add(&w, sizeof(w), 1);\\r\\n}\\r\\nFreeLibrary(user);\\r\\n}\\r\\nif (kernel) {\\r\\nCREATETOOLHELP32SNAPSHOT snap;\\r\\nCLOSETOOLHELP32SNAPSHOT close_snap;\\r\\nHANDLE handle;\\r\\nHEAP32FIRST heap_first;\\r\\nHEAP32NEXT heap_next;\\r\\nHEAP32LIST heaplist_first, heaplist_next;\\r\\nPROCESS32 process_first, process_next;\\r\\nTHREAD32 thread_first, thread_next;\\r\\nMODULE32 module_first, module_next;\\r\\nHEAPLIST32 hlist;\\r\\nHEAPENTRY32 hentry;\\r\\nPROCESSENTRY32 p;\\r\\nTHREADENTRY32 t;\\r\\nMODULEENTRY32 m;\\r\\nDWORD starttime = 0;\\r\\nsnap = (CREATETOOLHELP32SNAPSHOT)\\r\\nGetProcAddress(kernel, \"CreateToolhelp32Snapshot\");\\r\\nclose_snap = (CLOSETOOLHELP32SNAPSHOT)\\r\\nGetProcAddress(kernel, \"CloseToolhelp32Snapshot\");\\r\\nheap_first = (HEAP32FIRST) GetProcAddress(kernel, \"Heap32First\");\\r\\nheap_next = (HEAP32NEXT) GetProcAddress(kernel, \"Heap32Next\");\\r\\nheaplist_first =\\r\\n(HEAP32LIST) GetProcAddress(kernel, \"Heap32ListFirst\");\\r\\nheaplist_next =\\r\\n(HEAP32LIST) GetProcAddress(kernel, \"Heap32ListNext\");\\r\\nprocess_first =\\r\\n(PROCESS32) GetProcAddress(kernel, \"Process32First\");\\r\\nprocess_next =\\r\\n(PROCESS32) GetProcAddress(kernel, \"Process32Next\");\\r\\nthread_first = (THREAD32) GetProcAddress(kernel, \"Thread32First\");\\r\\nthread_next = (THREAD32) GetProcAddress(kernel, \"Thread32Next\");\\r\\nmodule_first = (MODULE32) GetProcAddress(kernel, \"Module32First\");\\r\\nmodule_next = (MODULE32) GetProcAddress(kernel, \"Module32Next\");\\r\\nif (snap && heap_first && heap_next && heaplist_first &&\\r\\nheaplist_next && process_first && process_next &&\\r\\nthread_first && thread_next && module_first &&\\r\\nmodule_next && (handle = snap(TH32CS_SNAPALL, 0))\\r\\n!= INVALID_HANDLE_VALUE) {\\r\\nZeroMemory(&hlist, sizeof(HEAPLIST32));\\r\\nhlist.dwSize = sizeof(HEAPLIST32);\\r\\nif (good)\\r\\nstarttime = GetTickCount();\\r\\n# ifdef _MSC_VER\\r\\nif (heaplist_first(handle, &hlist)) {\\r\\nint ex_cnt_limit = 42;\\r\\ndo {\\r\\nRAND_add(&hlist, hlist.dwSize, 3);\\r\\n__try {\\r\\nZeroMemory(&hentry, sizeof(HEAPENTRY32));\\r\\nhentry.dwSize = sizeof(HEAPENTRY32);\\r\\nif (heap_first(&hentry,\\r\\nhlist.th32ProcessID,\\r\\nhlist.th32HeapID)) {\\r\\nint entrycnt = 80;\\r\\ndo\\r\\nRAND_add(&hentry, hentry.dwSize, 5);\\r\\nwhile (heap_next(&hentry)\\r\\n&& (!good\\r\\n|| (GetTickCount() - starttime) <\\r\\nMAXDELAY)\\r\\n&& --entrycnt > 0);\\r\\n}\\r\\n}\\r\\n__except(EXCEPTION_EXECUTE_HANDLER) {\\r\\nex_cnt_limit--;\\r\\n}\\r\\n} while (heaplist_next(handle, &hlist)\\r\\n&& (!good\\r\\n|| (GetTickCount() - starttime) < MAXDELAY)\\r\\n&& ex_cnt_limit > 0);\\r\\n}\\r\\n# else\\r\\nif (heaplist_first(handle, &hlist)) {\\r\\ndo {\\r\\nRAND_add(&hlist, hlist.dwSize, 3);\\r\\nhentry.dwSize = sizeof(HEAPENTRY32);\\r\\nif (heap_first(&hentry,\\r\\nhlist.th32ProcessID,\\r\\nhlist.th32HeapID)) {\\r\\nint entrycnt = 80;\\r\\ndo\\r\\nRAND_add(&hentry, hentry.dwSize, 5);\\r\\nwhile (heap_next(&hentry)\\r\\n&& --entrycnt > 0);\\r\\n}\\r\\n} while (heaplist_next(handle, &hlist)\\r\\n&& (!good\\r\\n|| (GetTickCount() - starttime) < MAXDELAY));\\r\\n}\\r\\n# endif\\r\\np.dwSize = sizeof(PROCESSENTRY32);\\r\\nif (good)\\r\\nstarttime = GetTickCount();\\r\\nif (process_first(handle, &p))\\r\\ndo\\r\\nRAND_add(&p, p.dwSize, 9);\\r\\nwhile (process_next(handle, &p)\\r\\n&& (!good\\r\\n|| (GetTickCount() - starttime) < MAXDELAY));\\r\\nt.dwSize = sizeof(THREADENTRY32);\\r\\nif (good)\\r\\nstarttime = GetTickCount();\\r\\nif (thread_first(handle, &t))\\r\\ndo\\r\\nRAND_add(&t, t.dwSize, 6);\\r\\nwhile (thread_next(handle, &t)\\r\\n&& (!good\\r\\n|| (GetTickCount() - starttime) < MAXDELAY));\\r\\nm.dwSize = sizeof(MODULEENTRY32);\\r\\nif (good)\\r\\nstarttime = GetTickCount();\\r\\nif (module_first(handle, &m))\\r\\ndo\\r\\nRAND_add(&m, m.dwSize, 9);\\r\\nwhile (module_next(handle, &m)\\r\\n&& (!good\\r\\n|| (GetTickCount() - starttime) < MAXDELAY));\\r\\nif (close_snap)\\r\\nclose_snap(handle);\\r\\nelse\\r\\nCloseHandle(handle);\\r\\n}\\r\\nFreeLibrary(kernel);\\r\\n}\\r\\n}\\r\\n# endif\\r\\nreadtimer();\\r\\nGlobalMemoryStatus(&m);\\r\\nRAND_add(&m, sizeof(m), 1);\\r\\nw = GetCurrentProcessId();\\r\\nRAND_add(&w, sizeof(w), 1);\\r\\n# if 0\\r\\nprintf(\"Exiting RAND_poll\\n\");\\r\\n# endif\\r\\nreturn (1);\\r\\n}\\r\\nint RAND_event(UINT iMsg, WPARAM wParam, LPARAM lParam)\\r\\n{\\r\\ndouble add_entropy = 0;\\r\\nswitch (iMsg) {\\r\\ncase WM_KEYDOWN:\\r\\n{\\r\\nstatic WPARAM key;\\r\\nif (key != wParam)\\r\\nadd_entropy = 0.05;\\r\\nkey = wParam;\\r\\n}\\r\\nbreak;\\r\\ncase WM_MOUSEMOVE:\\r\\n{\\r\\nstatic int lastx, lasty, lastdx, lastdy;\\r\\nint x, y, dx, dy;\\r\\nx = LOWORD(lParam);\\r\\ny = HIWORD(lParam);\\r\\ndx = lastx - x;\\r\\ndy = lasty - y;\\r\\nif (dx != 0 && dy != 0 && dx - lastdx != 0 && dy - lastdy != 0)\\r\\nadd_entropy = .2;\\r\\nlastx = x, lasty = y;\\r\\nlastdx = dx, lastdy = dy;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreadtimer();\\r\\nRAND_add(&iMsg, sizeof(iMsg), add_entropy);\\r\\nRAND_add(&wParam, sizeof(wParam), 0);\\r\\nRAND_add(&lParam, sizeof(lParam), 0);\\r\\nreturn (RAND_status());\\r\\n}\\r\\nvoid RAND_screen(void)\\r\\n{\\r\\nRAND_poll();\\r\\nreadscreen();\\r\\n}\\r\\nstatic void readtimer(void)\\r\\n{\\r\\nDWORD w;\\r\\nLARGE_INTEGER l;\\r\\nstatic int have_perfc = 1;\\r\\n# if defined(_MSC_VER) && defined(_M_X86)\\r\\nstatic int have_tsc = 1;\\r\\nDWORD cyclecount;\\r\\nif (have_tsc) {\\r\\n__try {\\r\\n__asm {\\r\\n_emit 0x0f _emit 0x31 mov cyclecount, eax}\\r\\nRAND_add(&cyclecount, sizeof(cyclecount), 1);\\r\\n}\\r\\n__except(EXCEPTION_EXECUTE_HANDLER) {\\r\\nhave_tsc = 0;\\r\\n}\\r\\n}\\r\\n# else\\r\\n# define have_tsc 0\\r\\n# endif\\r\\nif (have_perfc) {\\r\\nif (QueryPerformanceCounter(&l) == 0)\\r\\nhave_perfc = 0;\\r\\nelse\\r\\nRAND_add(&l, sizeof(l), 0);\\r\\n}\\r\\nif (!have_tsc && !have_perfc) {\\r\\nw = GetTickCount();\\r\\nRAND_add(&w, sizeof(w), 0);\\r\\n}\\r\\n}\\r\\nstatic void readscreen(void)\\r\\n{\\r\\n# if !defined(OPENSSL_SYS_WINCE) && !defined(OPENSSL_SYS_WIN32_CYGWIN)\\r\\nHDC hScrDC;\\r\\nHBITMAP hBitmap;\\r\\nBITMAP bm;\\r\\nunsigned int size;\\r\\nchar *bmbits;\\r\\nint w;\\r\\nint h;\\r\\nint y;\\r\\nint n = 16;\\r\\nBITMAPINFOHEADER bi;\\r\\nif (check_winnt() && OPENSSL_isservice() > 0)\\r\\nreturn;\\r\\nhScrDC = GetDC(NULL);\\r\\nw = GetDeviceCaps(hScrDC, HORZRES);\\r\\nh = GetDeviceCaps(hScrDC, VERTRES);\\r\\nhBitmap = CreateCompatibleBitmap(hScrDC, w, n);\\r\\nGetObject(hBitmap, sizeof(BITMAP), (LPSTR) & bm);\\r\\nsize = (unsigned int)bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes;\\r\\nbi.biSize = sizeof(BITMAPINFOHEADER);\\r\\nbi.biWidth = bm.bmWidth;\\r\\nbi.biHeight = bm.bmHeight;\\r\\nbi.biPlanes = bm.bmPlanes;\\r\\nbi.biBitCount = bm.bmBitsPixel;\\r\\nbi.biCompression = BI_RGB;\\r\\nbi.biSizeImage = 0;\\r\\nbi.biXPelsPerMeter = 0;\\r\\nbi.biYPelsPerMeter = 0;\\r\\nbi.biClrUsed = 0;\\r\\nbi.biClrImportant = 0;\\r\\nbmbits = OPENSSL_malloc(size);\\r\\nif (bmbits) {\\r\\nfor (y = 0; y < h - n; y += n) {\\r\\nunsigned char md[MD_DIGEST_LENGTH];\\r\\nGetDIBits(hScrDC, hBitmap, y, n,\\r\\nbmbits, (BITMAPINFO *) & bi, DIB_RGB_COLORS);\\r\\nMD(bmbits, size, md);\\r\\nRAND_add(md, MD_DIGEST_LENGTH, 0);\\r\\n}\\r\\nOPENSSL_free(bmbits);\\r\\n}\\r\\nDeleteObject(hBitmap);\\r\\nReleaseDC(NULL, hScrDC);\\r\\n# endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_req_print_c", "target": 0, "func": "int TS_REQ_print_bio(BIO *bio, TS_REQ *a)\\r\\n{\\r\\nint v;\\r\\nASN1_OBJECT *policy_id;\\r\\nconst ASN1_INTEGER *nonce;\\r\\nif (a == NULL)\\r\\nreturn 0;\\r\\nv = TS_REQ_get_version(a);\\r\\nBIO_printf(bio, \"Version: %d\\n\", v);\\r\\nTS_MSG_IMPRINT_print_bio(bio, TS_REQ_get_msg_imprint(a));\\r\\nBIO_printf(bio, \"Policy OID: \");\\r\\npolicy_id = TS_REQ_get_policy_id(a);\\r\\nif (policy_id == NULL)\\r\\nBIO_printf(bio, \"unspecified\\n\");\\r\\nelse\\r\\nTS_OBJ_print_bio(bio, policy_id);\\r\\nBIO_printf(bio, \"Nonce: \");\\r\\nnonce = TS_REQ_get_nonce(a);\\r\\nif (nonce == NULL)\\r\\nBIO_printf(bio, \"unspecified\");\\r\\nelse\\r\\nTS_ASN1_INTEGER_print_bio(bio, nonce);\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\nBIO_printf(bio, \"Certificate required: %s\\n\",\\r\\nTS_REQ_get_cert_req(a) ? \"yes\" : \"no\");\\r\\nTS_ext_print_bio(bio, TS_REQ_get_exts(a));\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pem_all_c", "target": 0, "func": "static RSA *pkey_get_rsa(EVP_PKEY *key, RSA **rsa)\\r\\n{\\r\\nRSA *rtmp;\\r\\nif (!key)\\r\\nreturn NULL;\\r\\nrtmp = EVP_PKEY_get1_RSA(key);\\r\\nEVP_PKEY_free(key);\\r\\nif (!rtmp)\\r\\nreturn NULL;\\r\\nif (rsa) {\\r\\nRSA_free(*rsa);\\r\\n*rsa = rtmp;\\r\\n}\\r\\nreturn rtmp;\\r\\n}\\r\\nRSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **rsa, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);\\r\\nreturn pkey_get_rsa(pktmp, rsa);\\r\\n}\\r\\nRSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **rsa, pem_password_cb *cb, void *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_PrivateKey(fp, NULL, cb, u);\\r\\nreturn pkey_get_rsa(pktmp, rsa);\\r\\n}\\r\\nint PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc,\\r\\nunsigned char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nif (FIPS_mode()) {\\r\\nEVP_PKEY *k;\\r\\nint ret;\\r\\nk = EVP_PKEY_new();\\r\\nif (!k)\\r\\nreturn 0;\\r\\nEVP_PKEY_set1_RSA(k, x);\\r\\nret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);\\r\\nEVP_PKEY_free(k);\\r\\nreturn ret;\\r\\n} else\\r\\nreturn PEM_ASN1_write_bio((i2d_of_void *)i2d_RSAPrivateKey,\\r\\nPEM_STRING_RSA, bp, x, enc, kstr, klen, cb,\\r\\nu);\\r\\n}\\r\\nint PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc,\\r\\nunsigned char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nif (FIPS_mode()) {\\r\\nEVP_PKEY *k;\\r\\nint ret;\\r\\nk = EVP_PKEY_new();\\r\\nif (!k)\\r\\nreturn 0;\\r\\nEVP_PKEY_set1_RSA(k, x);\\r\\nret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);\\r\\nEVP_PKEY_free(k);\\r\\nreturn ret;\\r\\n} else\\r\\nreturn PEM_ASN1_write((i2d_of_void *)i2d_RSAPrivateKey,\\r\\nPEM_STRING_RSA, fp, x, enc, kstr, klen, cb, u);\\r\\n}\\r\\nstatic DSA *pkey_get_dsa(EVP_PKEY *key, DSA **dsa)\\r\\n{\\r\\nDSA *dtmp;\\r\\nif (!key)\\r\\nreturn NULL;\\r\\ndtmp = EVP_PKEY_get1_DSA(key);\\r\\nEVP_PKEY_free(key);\\r\\nif (!dtmp)\\r\\nreturn NULL;\\r\\nif (dsa) {\\r\\nDSA_free(*dsa);\\r\\n*dsa = dtmp;\\r\\n}\\r\\nreturn dtmp;\\r\\n}\\r\\nDSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **dsa, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);\\r\\nreturn pkey_get_dsa(pktmp, dsa);\\r\\n}\\r\\nint PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc,\\r\\nunsigned char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nif (FIPS_mode()) {\\r\\nEVP_PKEY *k;\\r\\nint ret;\\r\\nk = EVP_PKEY_new();\\r\\nif (!k)\\r\\nreturn 0;\\r\\nEVP_PKEY_set1_DSA(k, x);\\r\\nret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);\\r\\nEVP_PKEY_free(k);\\r\\nreturn ret;\\r\\n} else\\r\\nreturn PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAPrivateKey,\\r\\nPEM_STRING_DSA, bp, x, enc, kstr, klen, cb,\\r\\nu);\\r\\n}\\r\\nint PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc,\\r\\nunsigned char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nif (FIPS_mode()) {\\r\\nEVP_PKEY *k;\\r\\nint ret;\\r\\nk = EVP_PKEY_new();\\r\\nif (!k)\\r\\nreturn 0;\\r\\nEVP_PKEY_set1_DSA(k, x);\\r\\nret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);\\r\\nEVP_PKEY_free(k);\\r\\nreturn ret;\\r\\n} else\\r\\nreturn PEM_ASN1_write((i2d_of_void *)i2d_DSAPrivateKey,\\r\\nPEM_STRING_DSA, fp, x, enc, kstr, klen, cb, u);\\r\\n}\\r\\nDSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **dsa, pem_password_cb *cb, void *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_PrivateKey(fp, NULL, cb, u);\\r\\nreturn pkey_get_dsa(pktmp, dsa);\\r\\n}\\r\\nstatic EC_KEY *pkey_get_eckey(EVP_PKEY *key, EC_KEY **eckey)\\r\\n{\\r\\nEC_KEY *dtmp;\\r\\nif (!key)\\r\\nreturn NULL;\\r\\ndtmp = EVP_PKEY_get1_EC_KEY(key);\\r\\nEVP_PKEY_free(key);\\r\\nif (!dtmp)\\r\\nreturn NULL;\\r\\nif (eckey) {\\r\\nEC_KEY_free(*eckey);\\r\\n*eckey = dtmp;\\r\\n}\\r\\nreturn dtmp;\\r\\n}\\r\\nEC_KEY *PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **key, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_bio_PrivateKey(bp, NULL, cb, u);\\r\\nreturn pkey_get_eckey(pktmp, key);\\r\\n}\\r\\nint PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x, const EVP_CIPHER *enc,\\r\\nunsigned char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nif (FIPS_mode()) {\\r\\nEVP_PKEY *k;\\r\\nint ret;\\r\\nk = EVP_PKEY_new();\\r\\nif (!k)\\r\\nreturn 0;\\r\\nEVP_PKEY_set1_EC_KEY(k, x);\\r\\nret = PEM_write_bio_PrivateKey(bp, k, enc, kstr, klen, cb, u);\\r\\nEVP_PKEY_free(k);\\r\\nreturn ret;\\r\\n} else\\r\\nreturn PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPrivateKey,\\r\\nPEM_STRING_ECPRIVATEKEY,\\r\\nbp, x, enc, kstr, klen, cb, u);\\r\\n}\\r\\nint PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc,\\r\\nunsigned char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nif (FIPS_mode()) {\\r\\nEVP_PKEY *k;\\r\\nint ret;\\r\\nk = EVP_PKEY_new();\\r\\nif (!k)\\r\\nreturn 0;\\r\\nEVP_PKEY_set1_EC_KEY(k, x);\\r\\nret = PEM_write_PrivateKey(fp, k, enc, kstr, klen, cb, u);\\r\\nEVP_PKEY_free(k);\\r\\nreturn ret;\\r\\n} else\\r\\nreturn PEM_ASN1_write((i2d_of_void *)i2d_ECPrivateKey,\\r\\nPEM_STRING_ECPRIVATEKEY,\\r\\nfp, x, enc, kstr, klen, cb, u);\\r\\n}\\r\\nEC_KEY *PEM_read_ECPrivateKey(FILE *fp, EC_KEY **eckey, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = PEM_read_PrivateKey(fp, NULL, cb, u);\\r\\nreturn pkey_get_eckey(pktmp, eckey);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cmac_c", "target": 0, "func": "static void make_kn(unsigned char *k1, unsigned char *l, int bl)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < bl; i++) {\\r\\nk1[i] = l[i] << 1;\\r\\nif (i < bl - 1 && l[i + 1] & 0x80)\\r\\nk1[i] |= 1;\\r\\n}\\r\\nif (l[0] & 0x80)\\r\\nk1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\\r\\n}\\r\\nCMAC_CTX *CMAC_CTX_new(void)\\r\\n{\\r\\nCMAC_CTX *ctx;\\r\\nctx = OPENSSL_malloc(sizeof(CMAC_CTX));\\r\\nif (!ctx)\\r\\nreturn NULL;\\r\\nEVP_CIPHER_CTX_init(&ctx->cctx);\\r\\nctx->nlast_block = -1;\\r\\nreturn ctx;\\r\\n}\\r\\nvoid CMAC_CTX_cleanup(CMAC_CTX *ctx)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !ctx->cctx.engine) {\\r\\nFIPS_cmac_ctx_cleanup(ctx);\\r\\nreturn;\\r\\n}\\r\\n#endif\\r\\nEVP_CIPHER_CTX_cleanup(&ctx->cctx);\\r\\nOPENSSL_cleanse(ctx->tbl, EVP_MAX_BLOCK_LENGTH);\\r\\nOPENSSL_cleanse(ctx->k1, EVP_MAX_BLOCK_LENGTH);\\r\\nOPENSSL_cleanse(ctx->k2, EVP_MAX_BLOCK_LENGTH);\\r\\nOPENSSL_cleanse(ctx->last_block, EVP_MAX_BLOCK_LENGTH);\\r\\nctx->nlast_block = -1;\\r\\n}\\r\\nEVP_CIPHER_CTX *CMAC_CTX_get0_cipher_ctx(CMAC_CTX *ctx)\\r\\n{\\r\\nreturn &ctx->cctx;\\r\\n}\\r\\nvoid CMAC_CTX_free(CMAC_CTX *ctx)\\r\\n{\\r\\nCMAC_CTX_cleanup(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nint CMAC_CTX_copy(CMAC_CTX *out, const CMAC_CTX *in)\\r\\n{\\r\\nint bl;\\r\\nif (in->nlast_block == -1)\\r\\nreturn 0;\\r\\nif (!EVP_CIPHER_CTX_copy(&out->cctx, &in->cctx))\\r\\nreturn 0;\\r\\nbl = EVP_CIPHER_CTX_block_size(&in->cctx);\\r\\nmemcpy(out->k1, in->k1, bl);\\r\\nmemcpy(out->k2, in->k2, bl);\\r\\nmemcpy(out->tbl, in->tbl, bl);\\r\\nmemcpy(out->last_block, in->last_block, bl);\\r\\nout->nlast_block = in->nlast_block;\\r\\nreturn 1;\\r\\n}\\r\\nint CMAC_Init(CMAC_CTX *ctx, const void *key, size_t keylen,\\r\\nconst EVP_CIPHER *cipher, ENGINE *impl)\\r\\n{\\r\\nstatic unsigned char zero_iv[EVP_MAX_BLOCK_LENGTH];\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode()) {\\r\\nif ((impl || ctx->cctx.engine)\\r\\n&& !(ctx->cctx.flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW)) {\\r\\nEVPerr(EVP_F_CMAC_INIT, EVP_R_DISABLED_FOR_FIPS);\\r\\nreturn 0;\\r\\n}\\r\\nif (!impl && !ctx->cctx.engine)\\r\\nreturn FIPS_cmac_init(ctx, key, keylen, cipher, NULL);\\r\\n}\\r\\n#endif\\r\\nif (!key && !cipher && !impl && keylen == 0) {\\r\\nif (ctx->nlast_block == -1)\\r\\nreturn 0;\\r\\nif (!EVP_EncryptInit_ex(&ctx->cctx, NULL, NULL, NULL, zero_iv))\\r\\nreturn 0;\\r\\nmemset(ctx->tbl, 0, EVP_CIPHER_CTX_block_size(&ctx->cctx));\\r\\nctx->nlast_block = 0;\\r\\nreturn 1;\\r\\n}\\r\\nif (cipher && !EVP_EncryptInit_ex(&ctx->cctx, cipher, impl, NULL, NULL))\\r\\nreturn 0;\\r\\nif (key) {\\r\\nint bl;\\r\\nif (!EVP_CIPHER_CTX_cipher(&ctx->cctx))\\r\\nreturn 0;\\r\\nif (!EVP_CIPHER_CTX_set_key_length(&ctx->cctx, keylen))\\r\\nreturn 0;\\r\\nif (!EVP_EncryptInit_ex(&ctx->cctx, NULL, NULL, key, zero_iv))\\r\\nreturn 0;\\r\\nbl = EVP_CIPHER_CTX_block_size(&ctx->cctx);\\r\\nif (!EVP_Cipher(&ctx->cctx, ctx->tbl, zero_iv, bl))\\r\\nreturn 0;\\r\\nmake_kn(ctx->k1, ctx->tbl, bl);\\r\\nmake_kn(ctx->k2, ctx->k1, bl);\\r\\nOPENSSL_cleanse(ctx->tbl, bl);\\r\\nif (!EVP_EncryptInit_ex(&ctx->cctx, NULL, NULL, NULL, zero_iv))\\r\\nreturn 0;\\r\\nmemset(ctx->tbl, 0, bl);\\r\\nctx->nlast_block = 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint CMAC_Update(CMAC_CTX *ctx, const void *in, size_t dlen)\\r\\n{\\r\\nconst unsigned char *data = in;\\r\\nsize_t bl;\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !ctx->cctx.engine)\\r\\nreturn FIPS_cmac_update(ctx, in, dlen);\\r\\n#endif\\r\\nif (ctx->nlast_block == -1)\\r\\nreturn 0;\\r\\nif (dlen == 0)\\r\\nreturn 1;\\r\\nbl = EVP_CIPHER_CTX_block_size(&ctx->cctx);\\r\\nif (ctx->nlast_block > 0) {\\r\\nsize_t nleft;\\r\\nnleft = bl - ctx->nlast_block;\\r\\nif (dlen < nleft)\\r\\nnleft = dlen;\\r\\nmemcpy(ctx->last_block + ctx->nlast_block, data, nleft);\\r\\ndlen -= nleft;\\r\\nctx->nlast_block += nleft;\\r\\nif (dlen == 0)\\r\\nreturn 1;\\r\\ndata += nleft;\\r\\nif (!EVP_Cipher(&ctx->cctx, ctx->tbl, ctx->last_block, bl))\\r\\nreturn 0;\\r\\n}\\r\\nwhile (dlen > bl) {\\r\\nif (!EVP_Cipher(&ctx->cctx, ctx->tbl, data, bl))\\r\\nreturn 0;\\r\\ndlen -= bl;\\r\\ndata += bl;\\r\\n}\\r\\nmemcpy(ctx->last_block, data, dlen);\\r\\nctx->nlast_block = dlen;\\r\\nreturn 1;\\r\\n}\\r\\nint CMAC_Final(CMAC_CTX *ctx, unsigned char *out, size_t *poutlen)\\r\\n{\\r\\nint i, bl, lb;\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !ctx->cctx.engine)\\r\\nreturn FIPS_cmac_final(ctx, out, poutlen);\\r\\n#endif\\r\\nif (ctx->nlast_block == -1)\\r\\nreturn 0;\\r\\nbl = EVP_CIPHER_CTX_block_size(&ctx->cctx);\\r\\n*poutlen = (size_t)bl;\\r\\nif (!out)\\r\\nreturn 1;\\r\\nlb = ctx->nlast_block;\\r\\nif (lb == bl) {\\r\\nfor (i = 0; i < bl; i++)\\r\\nout[i] = ctx->last_block[i] ^ ctx->k1[i];\\r\\n} else {\\r\\nctx->last_block[lb] = 0x80;\\r\\nif (bl - lb > 1)\\r\\nmemset(ctx->last_block + lb + 1, 0, bl - lb - 1);\\r\\nfor (i = 0; i < bl; i++)\\r\\nout[i] = ctx->last_block[i] ^ ctx->k2[i];\\r\\n}\\r\\nif (!EVP_Cipher(&ctx->cctx, out, out, bl)) {\\r\\nOPENSSL_cleanse(out, bl);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint CMAC_resume(CMAC_CTX *ctx)\\r\\n{\\r\\nif (ctx->nlast_block == -1)\\r\\nreturn 0;\\r\\nreturn EVP_EncryptInit_ex(&ctx->cctx, NULL, NULL, NULL, ctx->tbl);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_gentm_c", "target": 0, "func": "int asn1_generalizedtime_to_tm(struct tm *tm, const ASN1_GENERALIZEDTIME *d)\\r\\n{\\r\\nstatic const int min[9] = { 0, 0, 1, 1, 0, 0, 0, 0, 0 };\\r\\nstatic const int max[9] = { 99, 99, 12, 31, 23, 59, 59, 12, 59 };\\r\\nchar *a;\\r\\nint n, i, l, o;\\r\\nif (d->type != V_ASN1_GENERALIZEDTIME)\\r\\nreturn (0);\\r\\nl = d->length;\\r\\na = (char *)d->data;\\r\\no = 0;\\r\\nif (l < 13)\\r\\ngoto err;\\r\\nfor (i = 0; i < 7; i++) {\\r\\nif ((i == 6) && ((a[o] == 'Z') || (a[o] == '+') || (a[o] == '-'))) {\\r\\ni++;\\r\\nif (tm)\\r\\ntm->tm_sec = 0;\\r\\nbreak;\\r\\n}\\r\\nif ((a[o] < '0') || (a[o] > '9'))\\r\\ngoto err;\\r\\nn = a[o] - '0';\\r\\nif (++o > l)\\r\\ngoto err;\\r\\nif ((a[o] < '0') || (a[o] > '9'))\\r\\ngoto err;\\r\\nn = (n * 10) + a[o] - '0';\\r\\nif (++o > l)\\r\\ngoto err;\\r\\nif ((n < min[i]) || (n > max[i]))\\r\\ngoto err;\\r\\nif (tm) {\\r\\nswitch (i) {\\r\\ncase 0:\\r\\ntm->tm_year = n * 100 - 1900;\\r\\nbreak;\\r\\ncase 1:\\r\\ntm->tm_year += n;\\r\\nbreak;\\r\\ncase 2:\\r\\ntm->tm_mon = n - 1;\\r\\nbreak;\\r\\ncase 3:\\r\\ntm->tm_mday = n;\\r\\nbreak;\\r\\ncase 4:\\r\\ntm->tm_hour = n;\\r\\nbreak;\\r\\ncase 5:\\r\\ntm->tm_min = n;\\r\\nbreak;\\r\\ncase 6:\\r\\ntm->tm_sec = n;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (a[o] == '.') {\\r\\nif (++o > l)\\r\\ngoto err;\\r\\ni = o;\\r\\nwhile ((a[o] >= '0') && (a[o] <= '9') && (o <= l))\\r\\no++;\\r\\nif (i == o)\\r\\ngoto err;\\r\\n}\\r\\nif (a[o] == 'Z')\\r\\no++;\\r\\nelse if ((a[o] == '+') || (a[o] == '-')) {\\r\\nint offsign = a[o] == '-' ? -1 : 1, offset = 0;\\r\\no++;\\r\\nif (o + 4 > l)\\r\\ngoto err;\\r\\nfor (i = 7; i < 9; i++) {\\r\\nif ((a[o] < '0') || (a[o] > '9'))\\r\\ngoto err;\\r\\nn = a[o] - '0';\\r\\no++;\\r\\nif ((a[o] < '0') || (a[o] > '9'))\\r\\ngoto err;\\r\\nn = (n * 10) + a[o] - '0';\\r\\nif ((n < min[i]) || (n > max[i]))\\r\\ngoto err;\\r\\nif (tm) {\\r\\nif (i == 7)\\r\\noffset = n * 3600;\\r\\nelse if (i == 8)\\r\\noffset += n * 60;\\r\\n}\\r\\no++;\\r\\n}\\r\\nif (offset && !OPENSSL_gmtime_adj(tm, 0, offset * offsign))\\r\\nreturn 0;\\r\\n} else if (a[o]) {\\r\\ngoto err;\\r\\n}\\r\\nreturn (o == l);\\r\\nerr:\\r\\nreturn (0);\\r\\n}\\r\\nint ASN1_GENERALIZEDTIME_check(const ASN1_GENERALIZEDTIME *d)\\r\\n{\\r\\nreturn asn1_generalizedtime_to_tm(NULL, d);\\r\\n}\\r\\nint ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str)\\r\\n{\\r\\nASN1_GENERALIZEDTIME t;\\r\\nt.type = V_ASN1_GENERALIZEDTIME;\\r\\nt.length = strlen(str);\\r\\nt.data = (unsigned char *)str;\\r\\nif (ASN1_GENERALIZEDTIME_check(&t)) {\\r\\nif (s != NULL) {\\r\\nif (!ASN1_STRING_set((ASN1_STRING *)s,\\r\\n(unsigned char *)str, t.length))\\r\\nreturn 0;\\r\\ns->type = V_ASN1_GENERALIZEDTIME;\\r\\n}\\r\\nreturn (1);\\r\\n} else\\r\\nreturn (0);\\r\\n}\\r\\nASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s,\\r\\ntime_t t)\\r\\n{\\r\\nreturn ASN1_GENERALIZEDTIME_adj(s, t, 0, 0);\\r\\n}\\r\\nASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,\\r\\ntime_t t, int offset_day,\\r\\nlong offset_sec)\\r\\n{\\r\\nchar *p;\\r\\nstruct tm *ts;\\r\\nstruct tm data;\\r\\nsize_t len = 20;\\r\\nif (s == NULL)\\r\\ns = M_ASN1_GENERALIZEDTIME_new();\\r\\nif (s == NULL)\\r\\nreturn (NULL);\\r\\nts = OPENSSL_gmtime(&t, &data);\\r\\nif (ts == NULL)\\r\\nreturn (NULL);\\r\\nif (offset_day || offset_sec) {\\r\\nif (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))\\r\\nreturn NULL;\\r\\n}\\r\\np = (char *)s->data;\\r\\nif ((p == NULL) || ((size_t)s->length < len)) {\\r\\np = OPENSSL_malloc(len);\\r\\nif (p == NULL) {\\r\\nASN1err(ASN1_F_ASN1_GENERALIZEDTIME_ADJ, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (s->data != NULL)\\r\\nOPENSSL_free(s->data);\\r\\ns->data = (unsigned char *)p;\\r\\n}\\r\\nBIO_snprintf(p, len, \"%04d%02d%02d%02d%02d%02dZ\", ts->tm_year + 1900,\\r\\nts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min,\\r\\nts->tm_sec);\\r\\ns->length = strlen(p);\\r\\ns->type = V_ASN1_GENERALIZEDTIME;\\r\\n#ifdef CHARSET_EBCDIC_not\\r\\nebcdic2ascii(s->data, s->data, s->length);\\r\\n#endif\\r\\nreturn (s);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_cb_c", "target": 0, "func": "long MS_CALLBACK BIO_debug_callback(BIO *bio, int cmd, const char *argp,\\r\\nint argi, long argl, long ret)\\r\\n{\\r\\nBIO *b;\\r\\nMS_STATIC char buf[256];\\r\\nchar *p;\\r\\nlong r = 1;\\r\\nsize_t p_maxlen;\\r\\nif (BIO_CB_RETURN & cmd)\\r\\nr = ret;\\r\\nBIO_snprintf(buf, sizeof buf, \"BIO[%08lX]:\", (unsigned long)bio);\\r\\np = &(buf[14]);\\r\\np_maxlen = sizeof buf - 14;\\r\\nswitch (cmd) {\\r\\ncase BIO_CB_FREE:\\r\\nBIO_snprintf(p, p_maxlen, \"Free - %s\\n\", bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_READ:\\r\\nif (bio->method->type & BIO_TYPE_DESCRIPTOR)\\r\\nBIO_snprintf(p, p_maxlen, \"read(%d,%lu) - %s fd=%d\\n\",\\r\\nbio->num, (unsigned long)argi,\\r\\nbio->method->name, bio->num);\\r\\nelse\\r\\nBIO_snprintf(p, p_maxlen, \"read(%d,%lu) - %s\\n\",\\r\\nbio->num, (unsigned long)argi, bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_WRITE:\\r\\nif (bio->method->type & BIO_TYPE_DESCRIPTOR)\\r\\nBIO_snprintf(p, p_maxlen, \"write(%d,%lu) - %s fd=%d\\n\",\\r\\nbio->num, (unsigned long)argi,\\r\\nbio->method->name, bio->num);\\r\\nelse\\r\\nBIO_snprintf(p, p_maxlen, \"write(%d,%lu) - %s\\n\",\\r\\nbio->num, (unsigned long)argi, bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_PUTS:\\r\\nBIO_snprintf(p, p_maxlen, \"puts() - %s\\n\", bio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_GETS:\\r\\nBIO_snprintf(p, p_maxlen, \"gets(%lu) - %s\\n\", (unsigned long)argi,\\r\\nbio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_CTRL:\\r\\nBIO_snprintf(p, p_maxlen, \"ctrl(%lu) - %s\\n\", (unsigned long)argi,\\r\\nbio->method->name);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN | BIO_CB_READ:\\r\\nBIO_snprintf(p, p_maxlen, \"read return %ld\\n\", ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN | BIO_CB_WRITE:\\r\\nBIO_snprintf(p, p_maxlen, \"write return %ld\\n\", ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN | BIO_CB_GETS:\\r\\nBIO_snprintf(p, p_maxlen, \"gets return %ld\\n\", ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN | BIO_CB_PUTS:\\r\\nBIO_snprintf(p, p_maxlen, \"puts return %ld\\n\", ret);\\r\\nbreak;\\r\\ncase BIO_CB_RETURN | BIO_CB_CTRL:\\r\\nBIO_snprintf(p, p_maxlen, \"ctrl return %ld\\n\", ret);\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_snprintf(p, p_maxlen, \"bio callback - unknown type (%d)\\n\", cmd);\\r\\nbreak;\\r\\n}\\r\\nb = (BIO *)bio->cb_arg;\\r\\nif (b != NULL)\\r\\nBIO_write(b, buf, strlen(buf));\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nelse\\r\\nfputs(buf, stderr);\\r\\n#endif\\r\\nreturn (r);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_int_c", "target": 0, "func": "static void *s2i_asn1_int(X509V3_EXT_METHOD *meth, X509V3_CTX *ctx,\\r\\nchar *value)\\r\\n{\\r\\nreturn s2i_ASN1_INTEGER(meth, value);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_stat_c", "target": 0, "func": "const char *SSL_state_string_long(const SSL *s)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (s->state) {\\r\\ncase SSL_ST_BEFORE:\\r\\nstr = \"before SSL initialization\";\\r\\nbreak;\\r\\ncase SSL_ST_ACCEPT:\\r\\nstr = \"before accept initialization\";\\r\\nbreak;\\r\\ncase SSL_ST_CONNECT:\\r\\nstr = \"before connect initialization\";\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nstr = \"SSL negotiation finished successfully\";\\r\\nbreak;\\r\\ncase SSL_ST_RENEGOTIATE:\\r\\nstr = \"SSL renegotiate ciphers\";\\r\\nbreak;\\r\\ncase SSL_ST_BEFORE | SSL_ST_CONNECT:\\r\\nstr = \"before/connect initialization\";\\r\\nbreak;\\r\\ncase SSL_ST_OK | SSL_ST_CONNECT:\\r\\nstr = \"ok/connect SSL initialization\";\\r\\nbreak;\\r\\ncase SSL_ST_BEFORE | SSL_ST_ACCEPT:\\r\\nstr = \"before/accept initialization\";\\r\\nbreak;\\r\\ncase SSL_ST_OK | SSL_ST_ACCEPT:\\r\\nstr = \"ok/accept SSL initialization\";\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\ncase SSL2_ST_CLIENT_START_ENCRYPTION:\\r\\nstr = \"SSLv2 client start encryption\";\\r\\nbreak;\\r\\ncase SSL2_ST_SERVER_START_ENCRYPTION:\\r\\nstr = \"SSLv2 server start encryption\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_A:\\r\\nstr = \"SSLv2 write client hello A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_B:\\r\\nstr = \"SSLv2 write client hello B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_A:\\r\\nstr = \"SSLv2 read server hello A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_B:\\r\\nstr = \"SSLv2 read server hello B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A:\\r\\nstr = \"SSLv2 write client master key A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B:\\r\\nstr = \"SSLv2 write client master key B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_A:\\r\\nstr = \"SSLv2 write client finished A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_B:\\r\\nstr = \"SSLv2 write client finished B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A:\\r\\nstr = \"SSLv2 write client certificate A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B:\\r\\nstr = \"SSLv2 write client certificate B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C:\\r\\nstr = \"SSLv2 write client certificate C\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D:\\r\\nstr = \"SSLv2 write client certificate D\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_A:\\r\\nstr = \"SSLv2 read server verify A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_B:\\r\\nstr = \"SSLv2 read server verify B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_A:\\r\\nstr = \"SSLv2 read server finished A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_B:\\r\\nstr = \"SSLv2 read server finished B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_A:\\r\\nstr = \"SSLv2 read client hello A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_B:\\r\\nstr = \"SSLv2 read client hello B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_C:\\r\\nstr = \"SSLv2 read client hello C\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_A:\\r\\nstr = \"SSLv2 write server hello A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_B:\\r\\nstr = \"SSLv2 write server hello B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_A:\\r\\nstr = \"SSLv2 read client master key A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_B:\\r\\nstr = \"SSLv2 read client master key B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_A:\\r\\nstr = \"SSLv2 write server verify A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_B:\\r\\nstr = \"SSLv2 write server verify B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_C:\\r\\nstr = \"SSLv2 write server verify C\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_A:\\r\\nstr = \"SSLv2 read client finished A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_B:\\r\\nstr = \"SSLv2 read client finished B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_A:\\r\\nstr = \"SSLv2 write server finished A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_B:\\r\\nstr = \"SSLv2 write server finished B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_A:\\r\\nstr = \"SSLv2 write request certificate A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_B:\\r\\nstr = \"SSLv2 write request certificate B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_C:\\r\\nstr = \"SSLv2 write request certificate C\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_D:\\r\\nstr = \"SSLv2 write request certificate D\";\\r\\nbreak;\\r\\ncase SSL2_ST_X509_GET_SERVER_CERTIFICATE:\\r\\nstr = \"SSLv2 X509 read server certificate\";\\r\\nbreak;\\r\\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE:\\r\\nstr = \"SSLv2 X509 read client certificate\";\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\ncase SSL3_ST_CW_CLNT_HELLO_A:\\r\\nstr = \"SSLv3 write client hello A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_B:\\r\\nstr = \"SSLv3 write client hello B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_A:\\r\\nstr = \"SSLv3 read server hello A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_B:\\r\\nstr = \"SSLv3 read server hello B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_A:\\r\\nstr = \"SSLv3 read server certificate A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_B:\\r\\nstr = \"SSLv3 read server certificate B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_KEY_EXCH_A:\\r\\nstr = \"SSLv3 read server key exchange A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_KEY_EXCH_B:\\r\\nstr = \"SSLv3 read server key exchange B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_REQ_A:\\r\\nstr = \"SSLv3 read server certificate request A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_REQ_B:\\r\\nstr = \"SSLv3 read server certificate request B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SESSION_TICKET_A:\\r\\nstr = \"SSLv3 read server session ticket A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SESSION_TICKET_B:\\r\\nstr = \"SSLv3 read server session ticket B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_DONE_A:\\r\\nstr = \"SSLv3 read server done A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_DONE_B:\\r\\nstr = \"SSLv3 read server done B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_A:\\r\\nstr = \"SSLv3 write client certificate A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_B:\\r\\nstr = \"SSLv3 write client certificate B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_C:\\r\\nstr = \"SSLv3 write client certificate C\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_D:\\r\\nstr = \"SSLv3 write client certificate D\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_KEY_EXCH_A:\\r\\nstr = \"SSLv3 write client key exchange A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_KEY_EXCH_B:\\r\\nstr = \"SSLv3 write client key exchange B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_VRFY_A:\\r\\nstr = \"SSLv3 write certificate verify A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_VRFY_B:\\r\\nstr = \"SSLv3 write certificate verify B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CHANGE_A:\\r\\ncase SSL3_ST_SW_CHANGE_A:\\r\\nstr = \"SSLv3 write change cipher spec A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CHANGE_B:\\r\\ncase SSL3_ST_SW_CHANGE_B:\\r\\nstr = \"SSLv3 write change cipher spec B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_FINISHED_A:\\r\\ncase SSL3_ST_SW_FINISHED_A:\\r\\nstr = \"SSLv3 write finished A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_FINISHED_B:\\r\\ncase SSL3_ST_SW_FINISHED_B:\\r\\nstr = \"SSLv3 write finished B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CHANGE_A:\\r\\ncase SSL3_ST_SR_CHANGE_A:\\r\\nstr = \"SSLv3 read change cipher spec A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CHANGE_B:\\r\\ncase SSL3_ST_SR_CHANGE_B:\\r\\nstr = \"SSLv3 read change cipher spec B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_FINISHED_A:\\r\\ncase SSL3_ST_SR_FINISHED_A:\\r\\nstr = \"SSLv3 read finished A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_FINISHED_B:\\r\\ncase SSL3_ST_SR_FINISHED_B:\\r\\nstr = \"SSLv3 read finished B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_FLUSH:\\r\\ncase SSL3_ST_SW_FLUSH:\\r\\nstr = \"SSLv3 flush data\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_A:\\r\\nstr = \"SSLv3 read client hello A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_B:\\r\\nstr = \"SSLv3 read client hello B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_C:\\r\\nstr = \"SSLv3 read client hello C\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_A:\\r\\nstr = \"SSLv3 write hello request A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_B:\\r\\nstr = \"SSLv3 write hello request B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_C:\\r\\nstr = \"SSLv3 write hello request C\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_A:\\r\\nstr = \"SSLv3 write server hello A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_B:\\r\\nstr = \"SSLv3 write server hello B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_A:\\r\\nstr = \"SSLv3 write certificate A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_B:\\r\\nstr = \"SSLv3 write certificate B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_KEY_EXCH_A:\\r\\nstr = \"SSLv3 write key exchange A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_KEY_EXCH_B:\\r\\nstr = \"SSLv3 write key exchange B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_REQ_A:\\r\\nstr = \"SSLv3 write certificate request A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_REQ_B:\\r\\nstr = \"SSLv3 write certificate request B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SESSION_TICKET_A:\\r\\nstr = \"SSLv3 write session ticket A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SESSION_TICKET_B:\\r\\nstr = \"SSLv3 write session ticket B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_DONE_A:\\r\\nstr = \"SSLv3 write server done A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_DONE_B:\\r\\nstr = \"SSLv3 write server done B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_A:\\r\\nstr = \"SSLv3 read client certificate A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_B:\\r\\nstr = \"SSLv3 read client certificate B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_KEY_EXCH_A:\\r\\nstr = \"SSLv3 read client key exchange A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_KEY_EXCH_B:\\r\\nstr = \"SSLv3 read client key exchange B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_VRFY_A:\\r\\nstr = \"SSLv3 read certificate verify A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_VRFY_B:\\r\\nstr = \"SSLv3 read certificate verify B\";\\r\\nbreak;\\r\\n#endif\\r\\ncase SSL23_ST_CW_CLNT_HELLO_A:\\r\\nstr = \"SSLv2/v3 write client hello A\";\\r\\nbreak;\\r\\ncase SSL23_ST_CW_CLNT_HELLO_B:\\r\\nstr = \"SSLv2/v3 write client hello B\";\\r\\nbreak;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_A:\\r\\nstr = \"SSLv2/v3 read server hello A\";\\r\\nbreak;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_B:\\r\\nstr = \"SSLv2/v3 read server hello B\";\\r\\nbreak;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_A:\\r\\nstr = \"SSLv2/v3 read client hello A\";\\r\\nbreak;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_B:\\r\\nstr = \"SSLv2/v3 read client hello B\";\\r\\nbreak;\\r\\ncase DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A:\\r\\nstr = \"DTLS1 read hello verify request A\";\\r\\nbreak;\\r\\ncase DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B:\\r\\nstr = \"DTLS1 read hello verify request B\";\\r\\nbreak;\\r\\ncase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:\\r\\nstr = \"DTLS1 write hello verify request A\";\\r\\nbreak;\\r\\ncase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:\\r\\nstr = \"DTLS1 write hello verify request B\";\\r\\nbreak;\\r\\ndefault:\\r\\nstr = \"unknown state\";\\r\\nbreak;\\r\\n}\\r\\nreturn (str);\\r\\n}\\r\\nconst char *SSL_rstate_string_long(const SSL *s)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (s->rstate) {\\r\\ncase SSL_ST_READ_HEADER:\\r\\nstr = \"read header\";\\r\\nbreak;\\r\\ncase SSL_ST_READ_BODY:\\r\\nstr = \"read body\";\\r\\nbreak;\\r\\ncase SSL_ST_READ_DONE:\\r\\nstr = \"read done\";\\r\\nbreak;\\r\\ndefault:\\r\\nstr = \"unknown\";\\r\\nbreak;\\r\\n}\\r\\nreturn (str);\\r\\n}\\r\\nconst char *SSL_state_string(const SSL *s)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (s->state) {\\r\\ncase SSL_ST_BEFORE:\\r\\nstr = \"PINIT \";\\r\\nbreak;\\r\\ncase SSL_ST_ACCEPT:\\r\\nstr = \"AINIT \";\\r\\nbreak;\\r\\ncase SSL_ST_CONNECT:\\r\\nstr = \"CINIT \";\\r\\nbreak;\\r\\ncase SSL_ST_OK:\\r\\nstr = \"SSLOK \";\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\ncase SSL2_ST_CLIENT_START_ENCRYPTION:\\r\\nstr = \"2CSENC\";\\r\\nbreak;\\r\\ncase SSL2_ST_SERVER_START_ENCRYPTION:\\r\\nstr = \"2SSENC\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_A:\\r\\nstr = \"2SCH_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_HELLO_B:\\r\\nstr = \"2SCH_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_A:\\r\\nstr = \"2GSH_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_HELLO_B:\\r\\nstr = \"2GSH_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_A:\\r\\nstr = \"2SCMKA\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_MASTER_KEY_B:\\r\\nstr = \"2SCMKB\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_A:\\r\\nstr = \"2SCF_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_FINISHED_B:\\r\\nstr = \"2SCF_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_A:\\r\\nstr = \"2SCC_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_B:\\r\\nstr = \"2SCC_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_C:\\r\\nstr = \"2SCC_C\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_CLIENT_CERTIFICATE_D:\\r\\nstr = \"2SCC_D\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_A:\\r\\nstr = \"2GSV_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_VERIFY_B:\\r\\nstr = \"2GSV_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_A:\\r\\nstr = \"2GSF_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_SERVER_FINISHED_B:\\r\\nstr = \"2GSF_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_A:\\r\\nstr = \"2GCH_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_B:\\r\\nstr = \"2GCH_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_HELLO_C:\\r\\nstr = \"2GCH_C\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_A:\\r\\nstr = \"2SSH_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_HELLO_B:\\r\\nstr = \"2SSH_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_A:\\r\\nstr = \"2GCMKA\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_MASTER_KEY_B:\\r\\nstr = \"2GCMKA\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_A:\\r\\nstr = \"2SSV_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_B:\\r\\nstr = \"2SSV_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_VERIFY_C:\\r\\nstr = \"2SSV_C\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_A:\\r\\nstr = \"2GCF_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_GET_CLIENT_FINISHED_B:\\r\\nstr = \"2GCF_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_A:\\r\\nstr = \"2SSF_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_SERVER_FINISHED_B:\\r\\nstr = \"2SSF_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_A:\\r\\nstr = \"2SRC_A\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_B:\\r\\nstr = \"2SRC_B\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_C:\\r\\nstr = \"2SRC_C\";\\r\\nbreak;\\r\\ncase SSL2_ST_SEND_REQUEST_CERTIFICATE_D:\\r\\nstr = \"2SRC_D\";\\r\\nbreak;\\r\\ncase SSL2_ST_X509_GET_SERVER_CERTIFICATE:\\r\\nstr = \"2X9GSC\";\\r\\nbreak;\\r\\ncase SSL2_ST_X509_GET_CLIENT_CERTIFICATE:\\r\\nstr = \"2X9GCC\";\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\ncase SSL3_ST_SW_FLUSH:\\r\\ncase SSL3_ST_CW_FLUSH:\\r\\nstr = \"3FLUSH\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_A:\\r\\nstr = \"3WCH_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CLNT_HELLO_B:\\r\\nstr = \"3WCH_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_A:\\r\\nstr = \"3RSH_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_HELLO_B:\\r\\nstr = \"3RSH_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_A:\\r\\nstr = \"3RSC_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_B:\\r\\nstr = \"3RSC_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_KEY_EXCH_A:\\r\\nstr = \"3RSKEA\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_KEY_EXCH_B:\\r\\nstr = \"3RSKEB\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_REQ_A:\\r\\nstr = \"3RCR_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_CERT_REQ_B:\\r\\nstr = \"3RCR_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_DONE_A:\\r\\nstr = \"3RSD_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CR_SRVR_DONE_B:\\r\\nstr = \"3RSD_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_A:\\r\\nstr = \"3WCC_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_B:\\r\\nstr = \"3WCC_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_C:\\r\\nstr = \"3WCC_C\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_D:\\r\\nstr = \"3WCC_D\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_KEY_EXCH_A:\\r\\nstr = \"3WCKEA\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_KEY_EXCH_B:\\r\\nstr = \"3WCKEB\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_VRFY_A:\\r\\nstr = \"3WCV_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_CW_CERT_VRFY_B:\\r\\nstr = \"3WCV_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CHANGE_A:\\r\\ncase SSL3_ST_CW_CHANGE_A:\\r\\nstr = \"3WCCSA\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CHANGE_B:\\r\\ncase SSL3_ST_CW_CHANGE_B:\\r\\nstr = \"3WCCSB\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_FINISHED_A:\\r\\ncase SSL3_ST_CW_FINISHED_A:\\r\\nstr = \"3WFINA\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_FINISHED_B:\\r\\ncase SSL3_ST_CW_FINISHED_B:\\r\\nstr = \"3WFINB\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CHANGE_A:\\r\\ncase SSL3_ST_CR_CHANGE_A:\\r\\nstr = \"3RCCSA\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CHANGE_B:\\r\\ncase SSL3_ST_CR_CHANGE_B:\\r\\nstr = \"3RCCSB\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_FINISHED_A:\\r\\ncase SSL3_ST_CR_FINISHED_A:\\r\\nstr = \"3RFINA\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_FINISHED_B:\\r\\ncase SSL3_ST_CR_FINISHED_B:\\r\\nstr = \"3RFINB\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_A:\\r\\nstr = \"3WHR_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_B:\\r\\nstr = \"3WHR_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_HELLO_REQ_C:\\r\\nstr = \"3WHR_C\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_A:\\r\\nstr = \"3RCH_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_B:\\r\\nstr = \"3RCH_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CLNT_HELLO_C:\\r\\nstr = \"3RCH_C\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_A:\\r\\nstr = \"3WSH_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_HELLO_B:\\r\\nstr = \"3WSH_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_A:\\r\\nstr = \"3WSC_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_B:\\r\\nstr = \"3WSC_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_KEY_EXCH_A:\\r\\nstr = \"3WSKEA\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_KEY_EXCH_B:\\r\\nstr = \"3WSKEB\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_REQ_A:\\r\\nstr = \"3WCR_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_CERT_REQ_B:\\r\\nstr = \"3WCR_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_DONE_A:\\r\\nstr = \"3WSD_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SW_SRVR_DONE_B:\\r\\nstr = \"3WSD_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_A:\\r\\nstr = \"3RCC_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_B:\\r\\nstr = \"3RCC_B\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_KEY_EXCH_A:\\r\\nstr = \"3RCKEA\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_KEY_EXCH_B:\\r\\nstr = \"3RCKEB\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_VRFY_A:\\r\\nstr = \"3RCV_A\";\\r\\nbreak;\\r\\ncase SSL3_ST_SR_CERT_VRFY_B:\\r\\nstr = \"3RCV_B\";\\r\\nbreak;\\r\\n#endif\\r\\ncase SSL23_ST_CW_CLNT_HELLO_A:\\r\\nstr = \"23WCHA\";\\r\\nbreak;\\r\\ncase SSL23_ST_CW_CLNT_HELLO_B:\\r\\nstr = \"23WCHB\";\\r\\nbreak;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_A:\\r\\nstr = \"23RSHA\";\\r\\nbreak;\\r\\ncase SSL23_ST_CR_SRVR_HELLO_B:\\r\\nstr = \"23RSHA\";\\r\\nbreak;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_A:\\r\\nstr = \"23RCHA\";\\r\\nbreak;\\r\\ncase SSL23_ST_SR_CLNT_HELLO_B:\\r\\nstr = \"23RCHB\";\\r\\nbreak;\\r\\ncase DTLS1_ST_CR_HELLO_VERIFY_REQUEST_A:\\r\\nstr = \"DRCHVA\";\\r\\nbreak;\\r\\ncase DTLS1_ST_CR_HELLO_VERIFY_REQUEST_B:\\r\\nstr = \"DRCHVB\";\\r\\nbreak;\\r\\ncase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_A:\\r\\nstr = \"DWCHVA\";\\r\\nbreak;\\r\\ncase DTLS1_ST_SW_HELLO_VERIFY_REQUEST_B:\\r\\nstr = \"DWCHVB\";\\r\\nbreak;\\r\\ndefault:\\r\\nstr = \"UNKWN \";\\r\\nbreak;\\r\\n}\\r\\nreturn (str);\\r\\n}\\r\\nconst char *SSL_alert_type_string_long(int value)\\r\\n{\\r\\nvalue >>= 8;\\r\\nif (value == SSL3_AL_WARNING)\\r\\nreturn (\"warning\");\\r\\nelse if (value == SSL3_AL_FATAL)\\r\\nreturn (\"fatal\");\\r\\nelse\\r\\nreturn (\"unknown\");\\r\\n}\\r\\nconst char *SSL_alert_type_string(int value)\\r\\n{\\r\\nvalue >>= 8;\\r\\nif (value == SSL3_AL_WARNING)\\r\\nreturn (\"W\");\\r\\nelse if (value == SSL3_AL_FATAL)\\r\\nreturn (\"F\");\\r\\nelse\\r\\nreturn (\"U\");\\r\\n}\\r\\nconst char *SSL_alert_desc_string(int value)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (value & 0xff) {\\r\\ncase SSL3_AD_CLOSE_NOTIFY:\\r\\nstr = \"CN\";\\r\\nbreak;\\r\\ncase SSL3_AD_UNEXPECTED_MESSAGE:\\r\\nstr = \"UM\";\\r\\nbreak;\\r\\ncase SSL3_AD_BAD_RECORD_MAC:\\r\\nstr = \"BM\";\\r\\nbreak;\\r\\ncase SSL3_AD_DECOMPRESSION_FAILURE:\\r\\nstr = \"DF\";\\r\\nbreak;\\r\\ncase SSL3_AD_HANDSHAKE_FAILURE:\\r\\nstr = \"HF\";\\r\\nbreak;\\r\\ncase SSL3_AD_NO_CERTIFICATE:\\r\\nstr = \"NC\";\\r\\nbreak;\\r\\ncase SSL3_AD_BAD_CERTIFICATE:\\r\\nstr = \"BC\";\\r\\nbreak;\\r\\ncase SSL3_AD_UNSUPPORTED_CERTIFICATE:\\r\\nstr = \"UC\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_REVOKED:\\r\\nstr = \"CR\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_EXPIRED:\\r\\nstr = \"CE\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_UNKNOWN:\\r\\nstr = \"CU\";\\r\\nbreak;\\r\\ncase SSL3_AD_ILLEGAL_PARAMETER:\\r\\nstr = \"IP\";\\r\\nbreak;\\r\\ncase TLS1_AD_DECRYPTION_FAILED:\\r\\nstr = \"DC\";\\r\\nbreak;\\r\\ncase TLS1_AD_RECORD_OVERFLOW:\\r\\nstr = \"RO\";\\r\\nbreak;\\r\\ncase TLS1_AD_UNKNOWN_CA:\\r\\nstr = \"CA\";\\r\\nbreak;\\r\\ncase TLS1_AD_ACCESS_DENIED:\\r\\nstr = \"AD\";\\r\\nbreak;\\r\\ncase TLS1_AD_DECODE_ERROR:\\r\\nstr = \"DE\";\\r\\nbreak;\\r\\ncase TLS1_AD_DECRYPT_ERROR:\\r\\nstr = \"CY\";\\r\\nbreak;\\r\\ncase TLS1_AD_EXPORT_RESTRICTION:\\r\\nstr = \"ER\";\\r\\nbreak;\\r\\ncase TLS1_AD_PROTOCOL_VERSION:\\r\\nstr = \"PV\";\\r\\nbreak;\\r\\ncase TLS1_AD_INSUFFICIENT_SECURITY:\\r\\nstr = \"IS\";\\r\\nbreak;\\r\\ncase TLS1_AD_INTERNAL_ERROR:\\r\\nstr = \"IE\";\\r\\nbreak;\\r\\ncase TLS1_AD_USER_CANCELLED:\\r\\nstr = \"US\";\\r\\nbreak;\\r\\ncase TLS1_AD_NO_RENEGOTIATION:\\r\\nstr = \"NR\";\\r\\nbreak;\\r\\ncase TLS1_AD_UNSUPPORTED_EXTENSION:\\r\\nstr = \"UE\";\\r\\nbreak;\\r\\ncase TLS1_AD_CERTIFICATE_UNOBTAINABLE:\\r\\nstr = \"CO\";\\r\\nbreak;\\r\\ncase TLS1_AD_UNRECOGNIZED_NAME:\\r\\nstr = \"UN\";\\r\\nbreak;\\r\\ncase TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE:\\r\\nstr = \"BR\";\\r\\nbreak;\\r\\ncase TLS1_AD_BAD_CERTIFICATE_HASH_VALUE:\\r\\nstr = \"BH\";\\r\\nbreak;\\r\\ncase TLS1_AD_UNKNOWN_PSK_IDENTITY:\\r\\nstr = \"UP\";\\r\\nbreak;\\r\\ndefault:\\r\\nstr = \"UK\";\\r\\nbreak;\\r\\n}\\r\\nreturn (str);\\r\\n}\\r\\nconst char *SSL_alert_desc_string_long(int value)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (value & 0xff) {\\r\\ncase SSL3_AD_CLOSE_NOTIFY:\\r\\nstr = \"close notify\";\\r\\nbreak;\\r\\ncase SSL3_AD_UNEXPECTED_MESSAGE:\\r\\nstr = \"unexpected_message\";\\r\\nbreak;\\r\\ncase SSL3_AD_BAD_RECORD_MAC:\\r\\nstr = \"bad record mac\";\\r\\nbreak;\\r\\ncase SSL3_AD_DECOMPRESSION_FAILURE:\\r\\nstr = \"decompression failure\";\\r\\nbreak;\\r\\ncase SSL3_AD_HANDSHAKE_FAILURE:\\r\\nstr = \"handshake failure\";\\r\\nbreak;\\r\\ncase SSL3_AD_NO_CERTIFICATE:\\r\\nstr = \"no certificate\";\\r\\nbreak;\\r\\ncase SSL3_AD_BAD_CERTIFICATE:\\r\\nstr = \"bad certificate\";\\r\\nbreak;\\r\\ncase SSL3_AD_UNSUPPORTED_CERTIFICATE:\\r\\nstr = \"unsupported certificate\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_REVOKED:\\r\\nstr = \"certificate revoked\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_EXPIRED:\\r\\nstr = \"certificate expired\";\\r\\nbreak;\\r\\ncase SSL3_AD_CERTIFICATE_UNKNOWN:\\r\\nstr = \"certificate unknown\";\\r\\nbreak;\\r\\ncase SSL3_AD_ILLEGAL_PARAMETER:\\r\\nstr = \"illegal parameter\";\\r\\nbreak;\\r\\ncase TLS1_AD_DECRYPTION_FAILED:\\r\\nstr = \"decryption failed\";\\r\\nbreak;\\r\\ncase TLS1_AD_RECORD_OVERFLOW:\\r\\nstr = \"record overflow\";\\r\\nbreak;\\r\\ncase TLS1_AD_UNKNOWN_CA:\\r\\nstr = \"unknown CA\";\\r\\nbreak;\\r\\ncase TLS1_AD_ACCESS_DENIED:\\r\\nstr = \"access denied\";\\r\\nbreak;\\r\\ncase TLS1_AD_DECODE_ERROR:\\r\\nstr = \"decode error\";\\r\\nbreak;\\r\\ncase TLS1_AD_DECRYPT_ERROR:\\r\\nstr = \"decrypt error\";\\r\\nbreak;\\r\\ncase TLS1_AD_EXPORT_RESTRICTION:\\r\\nstr = \"export restriction\";\\r\\nbreak;\\r\\ncase TLS1_AD_PROTOCOL_VERSION:\\r\\nstr = \"protocol version\";\\r\\nbreak;\\r\\ncase TLS1_AD_INSUFFICIENT_SECURITY:\\r\\nstr = \"insufficient security\";\\r\\nbreak;\\r\\ncase TLS1_AD_INTERNAL_ERROR:\\r\\nstr = \"internal error\";\\r\\nbreak;\\r\\ncase TLS1_AD_USER_CANCELLED:\\r\\nstr = \"user canceled\";\\r\\nbreak;\\r\\ncase TLS1_AD_NO_RENEGOTIATION:\\r\\nstr = \"no renegotiation\";\\r\\nbreak;\\r\\ncase TLS1_AD_UNSUPPORTED_EXTENSION:\\r\\nstr = \"unsupported extension\";\\r\\nbreak;\\r\\ncase TLS1_AD_CERTIFICATE_UNOBTAINABLE:\\r\\nstr = \"certificate unobtainable\";\\r\\nbreak;\\r\\ncase TLS1_AD_UNRECOGNIZED_NAME:\\r\\nstr = \"unrecognized name\";\\r\\nbreak;\\r\\ncase TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE:\\r\\nstr = \"bad certificate status response\";\\r\\nbreak;\\r\\ncase TLS1_AD_BAD_CERTIFICATE_HASH_VALUE:\\r\\nstr = \"bad certificate hash value\";\\r\\nbreak;\\r\\ncase TLS1_AD_UNKNOWN_PSK_IDENTITY:\\r\\nstr = \"unknown PSK identity\";\\r\\nbreak;\\r\\ndefault:\\r\\nstr = \"unknown\";\\r\\nbreak;\\r\\n}\\r\\nreturn (str);\\r\\n}\\r\\nconst char *SSL_rstate_string(const SSL *s)\\r\\n{\\r\\nconst char *str;\\r\\nswitch (s->rstate) {\\r\\ncase SSL_ST_READ_HEADER:\\r\\nstr = \"RH\";\\r\\nbreak;\\r\\ncase SSL_ST_READ_BODY:\\r\\nstr = \"RB\";\\r\\nbreak;\\r\\ncase SSL_ST_READ_DONE:\\r\\nstr = \"RD\";\\r\\nbreak;\\r\\ndefault:\\r\\nstr = \"unknown\";\\r\\nbreak;\\r\\n}\\r\\nreturn (str);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_ext_c", "target": 0, "func": "int X509_CRL_get_ext_count(X509_CRL *x)\\r\\n{\\r\\nreturn (X509v3_get_ext_count(x->crl->extensions));\\r\\n}\\r\\nint X509_CRL_get_ext_by_NID(X509_CRL *x, int nid, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_NID(x->crl->extensions, nid, lastpos));\\r\\n}\\r\\nint X509_CRL_get_ext_by_OBJ(X509_CRL *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_OBJ(x->crl->extensions, obj, lastpos));\\r\\n}\\r\\nint X509_CRL_get_ext_by_critical(X509_CRL *x, int crit, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_critical(x->crl->extensions, crit, lastpos));\\r\\n}\\r\\nX509_EXTENSION *X509_CRL_get_ext(X509_CRL *x, int loc)\\r\\n{\\r\\nreturn (X509v3_get_ext(x->crl->extensions, loc));\\r\\n}\\r\\nX509_EXTENSION *X509_CRL_delete_ext(X509_CRL *x, int loc)\\r\\n{\\r\\nreturn (X509v3_delete_ext(x->crl->extensions, loc));\\r\\n}\\r\\nvoid *X509_CRL_get_ext_d2i(X509_CRL *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->crl->extensions, nid, crit, idx);\\r\\n}\\r\\nint X509_CRL_add1_ext_i2d(X509_CRL *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->crl->extensions, nid, value, crit, flags);\\r\\n}\\r\\nint X509_CRL_add_ext(X509_CRL *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn (X509v3_add_ext(&(x->crl->extensions), ex, loc) != NULL);\\r\\n}\\r\\nint X509_get_ext_count(X509 *x)\\r\\n{\\r\\nreturn (X509v3_get_ext_count(x->cert_info->extensions));\\r\\n}\\r\\nint X509_get_ext_by_NID(X509 *x, int nid, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_NID(x->cert_info->extensions, nid, lastpos));\\r\\n}\\r\\nint X509_get_ext_by_OBJ(X509 *x, ASN1_OBJECT *obj, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_OBJ(x->cert_info->extensions, obj, lastpos));\\r\\n}\\r\\nint X509_get_ext_by_critical(X509 *x, int crit, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_critical\\r\\n(x->cert_info->extensions, crit, lastpos));\\r\\n}\\r\\nX509_EXTENSION *X509_get_ext(X509 *x, int loc)\\r\\n{\\r\\nreturn (X509v3_get_ext(x->cert_info->extensions, loc));\\r\\n}\\r\\nX509_EXTENSION *X509_delete_ext(X509 *x, int loc)\\r\\n{\\r\\nreturn (X509v3_delete_ext(x->cert_info->extensions, loc));\\r\\n}\\r\\nint X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn (X509v3_add_ext(&(x->cert_info->extensions), ex, loc) != NULL);\\r\\n}\\r\\nvoid *X509_get_ext_d2i(X509 *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->cert_info->extensions, nid, crit, idx);\\r\\n}\\r\\nint X509_add1_ext_i2d(X509 *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->cert_info->extensions, nid, value, crit,\\r\\nflags);\\r\\n}\\r\\nint X509_REVOKED_get_ext_count(X509_REVOKED *x)\\r\\n{\\r\\nreturn (X509v3_get_ext_count(x->extensions));\\r\\n}\\r\\nint X509_REVOKED_get_ext_by_NID(X509_REVOKED *x, int nid, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_NID(x->extensions, nid, lastpos));\\r\\n}\\r\\nint X509_REVOKED_get_ext_by_OBJ(X509_REVOKED *x, ASN1_OBJECT *obj,\\r\\nint lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_OBJ(x->extensions, obj, lastpos));\\r\\n}\\r\\nint X509_REVOKED_get_ext_by_critical(X509_REVOKED *x, int crit, int lastpos)\\r\\n{\\r\\nreturn (X509v3_get_ext_by_critical(x->extensions, crit, lastpos));\\r\\n}\\r\\nX509_EXTENSION *X509_REVOKED_get_ext(X509_REVOKED *x, int loc)\\r\\n{\\r\\nreturn (X509v3_get_ext(x->extensions, loc));\\r\\n}\\r\\nX509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *x, int loc)\\r\\n{\\r\\nreturn (X509v3_delete_ext(x->extensions, loc));\\r\\n}\\r\\nint X509_REVOKED_add_ext(X509_REVOKED *x, X509_EXTENSION *ex, int loc)\\r\\n{\\r\\nreturn (X509v3_add_ext(&(x->extensions), ex, loc) != NULL);\\r\\n}\\r\\nvoid *X509_REVOKED_get_ext_d2i(X509_REVOKED *x, int nid, int *crit, int *idx)\\r\\n{\\r\\nreturn X509V3_get_d2i(x->extensions, nid, crit, idx);\\r\\n}\\r\\nint X509_REVOKED_add1_ext_i2d(X509_REVOKED *x, int nid, void *value, int crit,\\r\\nunsigned long flags)\\r\\n{\\r\\nreturn X509V3_add1_i2d(&x->extensions, nid, value, crit, flags);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_txt_db_c", "target": 0, "func": "TXT_DB *TXT_DB_read(BIO *in, int num)\\r\\n{\\r\\nTXT_DB *ret = NULL;\\r\\nint er = 1;\\r\\nint esc = 0;\\r\\nlong ln = 0;\\r\\nint i, add, n;\\r\\nint size = BUFSIZE;\\r\\nint offset = 0;\\r\\nchar *p, *f;\\r\\nOPENSSL_STRING *pp;\\r\\nBUF_MEM *buf = NULL;\\r\\nif ((buf = BUF_MEM_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BUF_MEM_grow(buf, size))\\r\\ngoto err;\\r\\nif ((ret = OPENSSL_malloc(sizeof(TXT_DB))) == NULL)\\r\\ngoto err;\\r\\nret->num_fields = num;\\r\\nret->index = NULL;\\r\\nret->qual = NULL;\\r\\nif ((ret->data = sk_OPENSSL_PSTRING_new_null()) == NULL)\\r\\ngoto err;\\r\\nif ((ret->index = OPENSSL_malloc(sizeof(*ret->index) * num)) == NULL)\\r\\ngoto err;\\r\\nif ((ret->qual = OPENSSL_malloc(sizeof(*(ret->qual)) * num)) == NULL)\\r\\ngoto err;\\r\\nfor (i = 0; i < num; i++) {\\r\\nret->index[i] = NULL;\\r\\nret->qual[i] = NULL;\\r\\n}\\r\\nadd = (num + 1) * sizeof(char *);\\r\\nbuf->data[size - 1] = '\\0';\\r\\noffset = 0;\\r\\nfor (;;) {\\r\\nif (offset != 0) {\\r\\nsize += BUFSIZE;\\r\\nif (!BUF_MEM_grow_clean(buf, size))\\r\\ngoto err;\\r\\n}\\r\\nbuf->data[offset] = '\\0';\\r\\nBIO_gets(in, &(buf->data[offset]), size - offset);\\r\\nln++;\\r\\nif (buf->data[offset] == '\\0')\\r\\nbreak;\\r\\nif ((offset == 0) && (buf->data[0] == '#'))\\r\\ncontinue;\\r\\ni = strlen(&(buf->data[offset]));\\r\\noffset += i;\\r\\nif (buf->data[offset - 1] != '\\n')\\r\\ncontinue;\\r\\nelse {\\r\\nbuf->data[offset - 1] = '\\0';\\r\\nif (!(p = OPENSSL_malloc(add + offset)))\\r\\ngoto err;\\r\\noffset = 0;\\r\\n}\\r\\npp = (char **)p;\\r\\np += add;\\r\\nn = 0;\\r\\npp[n++] = p;\\r\\ni = 0;\\r\\nf = buf->data;\\r\\nesc = 0;\\r\\nfor (;;) {\\r\\nif (*f == '\\0')\\r\\nbreak;\\r\\nif (*f == '\\t') {\\r\\nif (esc)\\r\\np--;\\r\\nelse {\\r\\n*(p++) = '\\0';\\r\\nf++;\\r\\nif (n >= num)\\r\\nbreak;\\r\\npp[n++] = p;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nesc = (*f == '\\\\');\\r\\n*(p++) = *(f++);\\r\\n}\\r\\n*(p++) = '\\0';\\r\\nif ((n != num) || (*f != '\\0')) {\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nfprintf(stderr,\\r\\n\"wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)\\n\",\\r\\nln, num, n, f);\\r\\n#endif\\r\\ner = 2;\\r\\ngoto err;\\r\\n}\\r\\npp[n] = p;\\r\\nif (!sk_OPENSSL_PSTRING_push(ret->data, pp)) {\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nfprintf(stderr, \"failure in sk_push\\n\");\\r\\n#endif\\r\\ner = 2;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ner = 0;\\r\\nerr:\\r\\nBUF_MEM_free(buf);\\r\\nif (er) {\\r\\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\\r\\nif (er == 1)\\r\\nfprintf(stderr, \"OPENSSL_malloc failure\\n\");\\r\\n#endif\\r\\nif (ret != NULL) {\\r\\nif (ret->data != NULL)\\r\\nsk_OPENSSL_PSTRING_free(ret->data);\\r\\nif (ret->index != NULL)\\r\\nOPENSSL_free(ret->index);\\r\\nif (ret->qual != NULL)\\r\\nOPENSSL_free(ret->qual);\\r\\nif (ret != NULL)\\r\\nOPENSSL_free(ret);\\r\\n}\\r\\nreturn (NULL);\\r\\n} else\\r\\nreturn (ret);\\r\\n}\\r\\nOPENSSL_STRING *TXT_DB_get_by_index(TXT_DB *db, int idx,\\r\\nOPENSSL_STRING *value)\\r\\n{\\r\\nOPENSSL_STRING *ret;\\r\\nLHASH_OF(OPENSSL_STRING) *lh;\\r\\nif (idx >= db->num_fields) {\\r\\ndb->error = DB_ERROR_INDEX_OUT_OF_RANGE;\\r\\nreturn (NULL);\\r\\n}\\r\\nlh = db->index[idx];\\r\\nif (lh == NULL) {\\r\\ndb->error = DB_ERROR_NO_INDEX;\\r\\nreturn (NULL);\\r\\n}\\r\\nret = lh_OPENSSL_STRING_retrieve(lh, value);\\r\\ndb->error = DB_ERROR_OK;\\r\\nreturn (ret);\\r\\n}\\r\\nint TXT_DB_create_index(TXT_DB *db, int field, int (*qual) (OPENSSL_STRING *),\\r\\nLHASH_HASH_FN_TYPE hash, LHASH_COMP_FN_TYPE cmp)\\r\\n{\\r\\nLHASH_OF(OPENSSL_STRING) *idx;\\r\\nOPENSSL_STRING *r;\\r\\nint i, n;\\r\\nif (field >= db->num_fields) {\\r\\ndb->error = DB_ERROR_INDEX_OUT_OF_RANGE;\\r\\nreturn (0);\\r\\n}\\r\\nif ((idx = (LHASH_OF(OPENSSL_STRING) *)lh_new(hash, cmp)) == NULL) {\\r\\ndb->error = DB_ERROR_MALLOC;\\r\\nreturn (0);\\r\\n}\\r\\nn = sk_OPENSSL_PSTRING_num(db->data);\\r\\nfor (i = 0; i < n; i++) {\\r\\nr = sk_OPENSSL_PSTRING_value(db->data, i);\\r\\nif ((qual != NULL) && (qual(r) == 0))\\r\\ncontinue;\\r\\nif ((r = lh_OPENSSL_STRING_insert(idx, r)) != NULL) {\\r\\ndb->error = DB_ERROR_INDEX_CLASH;\\r\\ndb->arg1 = sk_OPENSSL_PSTRING_find(db->data, r);\\r\\ndb->arg2 = i;\\r\\nlh_OPENSSL_STRING_free(idx);\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nif (db->index[field] != NULL)\\r\\nlh_OPENSSL_STRING_free(db->index[field]);\\r\\ndb->index[field] = idx;\\r\\ndb->qual[field] = qual;\\r\\nreturn (1);\\r\\n}\\r\\nlong TXT_DB_write(BIO *out, TXT_DB *db)\\r\\n{\\r\\nlong i, j, n, nn, l, tot = 0;\\r\\nchar *p, **pp, *f;\\r\\nBUF_MEM *buf = NULL;\\r\\nlong ret = -1;\\r\\nif ((buf = BUF_MEM_new()) == NULL)\\r\\ngoto err;\\r\\nn = sk_OPENSSL_PSTRING_num(db->data);\\r\\nnn = db->num_fields;\\r\\nfor (i = 0; i < n; i++) {\\r\\npp = sk_OPENSSL_PSTRING_value(db->data, i);\\r\\nl = 0;\\r\\nfor (j = 0; j < nn; j++) {\\r\\nif (pp[j] != NULL)\\r\\nl += strlen(pp[j]);\\r\\n}\\r\\nif (!BUF_MEM_grow_clean(buf, (int)(l * 2 + nn)))\\r\\ngoto err;\\r\\np = buf->data;\\r\\nfor (j = 0; j < nn; j++) {\\r\\nf = pp[j];\\r\\nif (f != NULL)\\r\\nfor (;;) {\\r\\nif (*f == '\\0')\\r\\nbreak;\\r\\nif (*f == '\\t')\\r\\n*(p++) = '\\\\';\\r\\n*(p++) = *(f++);\\r\\n}\\r\\n*(p++) = '\\t';\\r\\n}\\r\\np[-1] = '\\n';\\r\\nj = p - buf->data;\\r\\nif (BIO_write(out, buf->data, (int)j) != j)\\r\\ngoto err;\\r\\ntot += j;\\r\\n}\\r\\nret = tot;\\r\\nerr:\\r\\nif (buf != NULL)\\r\\nBUF_MEM_free(buf);\\r\\nreturn (ret);\\r\\n}\\r\\nint TXT_DB_insert(TXT_DB *db, OPENSSL_STRING *row)\\r\\n{\\r\\nint i;\\r\\nOPENSSL_STRING *r;\\r\\nfor (i = 0; i < db->num_fields; i++) {\\r\\nif (db->index[i] != NULL) {\\r\\nif ((db->qual[i] != NULL) && (db->qual[i] (row) == 0))\\r\\ncontinue;\\r\\nr = lh_OPENSSL_STRING_retrieve(db->index[i], row);\\r\\nif (r != NULL) {\\r\\ndb->error = DB_ERROR_INDEX_CLASH;\\r\\ndb->arg1 = i;\\r\\ndb->arg_row = r;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!sk_OPENSSL_PSTRING_push(db->data, row)) {\\r\\ndb->error = DB_ERROR_MALLOC;\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < db->num_fields; i++) {\\r\\nif (db->index[i] != NULL) {\\r\\nif ((db->qual[i] != NULL) && (db->qual[i] (row) == 0))\\r\\ncontinue;\\r\\n(void)lh_OPENSSL_STRING_insert(db->index[i], row);\\r\\n}\\r\\n}\\r\\nreturn (1);\\r\\nerr:\\r\\nreturn (0);\\r\\n}\\r\\nvoid TXT_DB_free(TXT_DB *db)\\r\\n{\\r\\nint i, n;\\r\\nchar **p, *max;\\r\\nif (db == NULL)\\r\\nreturn;\\r\\nif (db->index != NULL) {\\r\\nfor (i = db->num_fields - 1; i >= 0; i--)\\r\\nif (db->index[i] != NULL)\\r\\nlh_OPENSSL_STRING_free(db->index[i]);\\r\\nOPENSSL_free(db->index);\\r\\n}\\r\\nif (db->qual != NULL)\\r\\nOPENSSL_free(db->qual);\\r\\nif (db->data != NULL) {\\r\\nfor (i = sk_OPENSSL_PSTRING_num(db->data) - 1; i >= 0; i--) {\\r\\np = sk_OPENSSL_PSTRING_value(db->data, i);\\r\\nmax = p[db->num_fields];\\r\\nif (max == NULL) {\\r\\nfor (n = 0; n < db->num_fields; n++)\\r\\nif (p[n] != NULL)\\r\\nOPENSSL_free(p[n]);\\r\\n} else {\\r\\nfor (n = 0; n < db->num_fields; n++) {\\r\\nif (((p[n] < (char *)p) || (p[n] > max))\\r\\n&& (p[n] != NULL))\\r\\nOPENSSL_free(p[n]);\\r\\n}\\r\\n}\\r\\nOPENSSL_free(sk_OPENSSL_PSTRING_value(db->data, i));\\r\\n}\\r\\nsk_OPENSSL_PSTRING_free(db->data);\\r\\n}\\r\\nOPENSSL_free(db);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pem_pk8_c", "target": 0, "func": "int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey(bp, x, 0, nid, NULL, kstr, klen, cb, u);\\r\\n}\\r\\nint PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey(bp, x, 0, -1, enc, kstr, klen, cb, u);\\r\\n}\\r\\nint i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey(bp, x, 1, -1, enc, kstr, klen, cb, u);\\r\\n}\\r\\nint i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey(bp, x, 1, nid, NULL, kstr, klen, cb, u);\\r\\n}\\r\\nstatic int do_pk8pkey(BIO *bp, EVP_PKEY *x, int isder, int nid,\\r\\nconst EVP_CIPHER *enc, char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nX509_SIG *p8;\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nchar buf[PEM_BUFSIZE];\\r\\nint ret;\\r\\nif (!(p8inf = EVP_PKEY2PKCS8(x))) {\\r\\nPEMerr(PEM_F_DO_PK8PKEY, PEM_R_ERROR_CONVERTING_PRIVATE_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nif (enc || (nid != -1)) {\\r\\nif (!kstr) {\\r\\nif (!cb)\\r\\nklen = PEM_def_callback(buf, PEM_BUFSIZE, 1, u);\\r\\nelse\\r\\nklen = cb(buf, PEM_BUFSIZE, 1, u);\\r\\nif (klen <= 0) {\\r\\nPEMerr(PEM_F_DO_PK8PKEY, PEM_R_READ_KEY);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn 0;\\r\\n}\\r\\nkstr = buf;\\r\\n}\\r\\np8 = PKCS8_encrypt(nid, enc, kstr, klen, NULL, 0, 0, p8inf);\\r\\nif (kstr == buf)\\r\\nOPENSSL_cleanse(buf, klen);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nif (isder)\\r\\nret = i2d_PKCS8_bio(bp, p8);\\r\\nelse\\r\\nret = PEM_write_bio_PKCS8(bp, p8);\\r\\nX509_SIG_free(p8);\\r\\nreturn ret;\\r\\n} else {\\r\\nif (isder)\\r\\nret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);\\r\\nelse\\r\\nret = PEM_write_bio_PKCS8_PRIV_KEY_INFO(bp, p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn ret;\\r\\n}\\r\\n}\\r\\nEVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8inf = NULL;\\r\\nX509_SIG *p8 = NULL;\\r\\nint klen;\\r\\nEVP_PKEY *ret;\\r\\nchar psbuf[PEM_BUFSIZE];\\r\\np8 = d2i_PKCS8_bio(bp, NULL);\\r\\nif (!p8)\\r\\nreturn NULL;\\r\\nif (cb)\\r\\nklen = cb(psbuf, PEM_BUFSIZE, 0, u);\\r\\nelse\\r\\nklen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);\\r\\nif (klen <= 0) {\\r\\nPEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_BIO, PEM_R_BAD_PASSWORD_READ);\\r\\nX509_SIG_free(p8);\\r\\nreturn NULL;\\r\\n}\\r\\np8inf = PKCS8_decrypt(p8, psbuf, klen);\\r\\nX509_SIG_free(p8);\\r\\nif (!p8inf)\\r\\nreturn NULL;\\r\\nret = EVP_PKCS82PKEY(p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (x) {\\r\\nif (*x)\\r\\nEVP_PKEY_free(*x);\\r\\n*x = ret;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen, pem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey_fp(fp, x, 1, -1, enc, kstr, klen, cb, u);\\r\\n}\\r\\nint i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey_fp(fp, x, 1, nid, NULL, kstr, klen, cb, u);\\r\\n}\\r\\nint PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,\\r\\nchar *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nreturn do_pk8pkey_fp(fp, x, 0, nid, NULL, kstr, klen, cb, u);\\r\\n}\\r\\nint PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nchar *kstr, int klen, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nreturn do_pk8pkey_fp(fp, x, 0, -1, enc, kstr, klen, cb, u);\\r\\n}\\r\\nstatic int do_pk8pkey_fp(FILE *fp, EVP_PKEY *x, int isder, int nid,\\r\\nconst EVP_CIPHER *enc, char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *bp;\\r\\nint ret;\\r\\nif (!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {\\r\\nPEMerr(PEM_F_DO_PK8PKEY_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nret = do_pk8pkey(bp, x, isder, nid, enc, kstr, klen, cb, u);\\r\\nBIO_free(bp);\\r\\nreturn ret;\\r\\n}\\r\\nEVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nBIO *bp;\\r\\nEVP_PKEY *ret;\\r\\nif (!(bp = BIO_new_fp(fp, BIO_NOCLOSE))) {\\r\\nPEMerr(PEM_F_D2I_PKCS8PRIVATEKEY_FP, ERR_R_BUF_LIB);\\r\\nreturn NULL;\\r\\n}\\r\\nret = d2i_PKCS8PrivateKey_bio(bp, x, cb, u);\\r\\nBIO_free(bp);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3conf_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nLHASH *conf;\\r\\nX509 *cert;\\r\\nFILE *inf;\\r\\nchar *conf_file;\\r\\nint i;\\r\\nint count;\\r\\nX509_EXTENSION *ext;\\r\\nX509V3_add_standard_extensions();\\r\\nERR_load_crypto_strings();\\r\\nif (!argv[1]) {\\r\\nfprintf(stderr, \"Usage: v3conf cert.pem [file.cnf]\\n\");\\r\\nexit(1);\\r\\n}\\r\\nconf_file = argv[2];\\r\\nif (!conf_file)\\r\\nconf_file = \"test.cnf\";\\r\\nconf = CONF_load(NULL, \"test.cnf\", NULL);\\r\\nif (!conf) {\\r\\nfprintf(stderr, \"Error opening Config file %s\\n\", conf_file);\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\ninf = fopen(argv[1], \"r\");\\r\\nif (!inf) {\\r\\nfprintf(stderr, \"Can't open certificate file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\ncert = PEM_read_X509(inf, NULL, NULL);\\r\\nif (!cert) {\\r\\nfprintf(stderr, \"Error reading certificate file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\nfclose(inf);\\r\\nsk_pop_free(cert->cert_info->extensions, X509_EXTENSION_free);\\r\\ncert->cert_info->extensions = NULL;\\r\\nif (!X509V3_EXT_add_conf(conf, NULL, \"test_section\", cert)) {\\r\\nfprintf(stderr, \"Error adding extensions\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\ncount = X509_get_ext_count(cert);\\r\\nprintf(\"%d extensions\\n\", count);\\r\\nfor (i = 0; i < count; i++) {\\r\\next = X509_get_ext(cert, i);\\r\\nprintf(\"%s\", OBJ_nid2ln(OBJ_obj2nid(ext->object)));\\r\\nif (ext->critical)\\r\\nprintf(\",critical:\\n\");\\r\\nelse\\r\\nprintf(\":\\n\");\\r\\nX509V3_EXT_print_fp(stdout, ext, 0, 0);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_lib_c", "target": 0, "func": "void DSA_set_default_method(const DSA_METHOD *meth)\\r\\n{\\r\\ndefault_DSA_method = meth;\\r\\n}\\r\\nconst DSA_METHOD *DSA_get_default_method(void)\\r\\n{\\r\\nif (!default_DSA_method) {\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_dsa_openssl();\\r\\nelse\\r\\nreturn DSA_OpenSSL();\\r\\n#else\\r\\ndefault_DSA_method = DSA_OpenSSL();\\r\\n#endif\\r\\n}\\r\\nreturn default_DSA_method;\\r\\n}\\r\\nDSA *DSA_new(void)\\r\\n{\\r\\nreturn DSA_new_method(NULL);\\r\\n}\\r\\nint DSA_set_method(DSA *dsa, const DSA_METHOD *meth)\\r\\n{\\r\\nconst DSA_METHOD *mtmp;\\r\\nmtmp = dsa->meth;\\r\\nif (mtmp->finish)\\r\\nmtmp->finish(dsa);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (dsa->engine) {\\r\\nENGINE_finish(dsa->engine);\\r\\ndsa->engine = NULL;\\r\\n}\\r\\n#endif\\r\\ndsa->meth = meth;\\r\\nif (meth->init)\\r\\nmeth->init(dsa);\\r\\nreturn 1;\\r\\n}\\r\\nDSA *DSA_new_method(ENGINE *engine)\\r\\n{\\r\\nDSA *ret;\\r\\nret = (DSA *)OPENSSL_malloc(sizeof(DSA));\\r\\nif (ret == NULL) {\\r\\nDSAerr(DSA_F_DSA_NEW_METHOD, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nret->meth = DSA_get_default_method();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (engine) {\\r\\nif (!ENGINE_init(engine)) {\\r\\nDSAerr(DSA_F_DSA_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nret->engine = engine;\\r\\n} else\\r\\nret->engine = ENGINE_get_default_DSA();\\r\\nif (ret->engine) {\\r\\nret->meth = ENGINE_get_DSA(ret->engine);\\r\\nif (!ret->meth) {\\r\\nDSAerr(DSA_F_DSA_NEW_METHOD, ERR_R_ENGINE_LIB);\\r\\nENGINE_finish(ret->engine);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nret->pad = 0;\\r\\nret->version = 0;\\r\\nret->write_params = 1;\\r\\nret->p = NULL;\\r\\nret->q = NULL;\\r\\nret->g = NULL;\\r\\nret->pub_key = NULL;\\r\\nret->priv_key = NULL;\\r\\nret->kinv = NULL;\\r\\nret->r = NULL;\\r\\nret->method_mont_p = NULL;\\r\\nret->references = 1;\\r\\nret->flags = ret->meth->flags & ~DSA_FLAG_NON_FIPS_ALLOW;\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_DSA, ret, &ret->ex_data);\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret)) {\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ret->engine)\\r\\nENGINE_finish(ret->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_DSA, ret, &ret->ex_data);\\r\\nOPENSSL_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid DSA_free(DSA *r)\\r\\n{\\r\\nint i;\\r\\nif (r == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_DSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DSA\", r);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"DSA_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (r->meth->finish)\\r\\nr->meth->finish(r);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (r->engine)\\r\\nENGINE_finish(r->engine);\\r\\n#endif\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_DSA, r, &r->ex_data);\\r\\nif (r->p != NULL)\\r\\nBN_clear_free(r->p);\\r\\nif (r->q != NULL)\\r\\nBN_clear_free(r->q);\\r\\nif (r->g != NULL)\\r\\nBN_clear_free(r->g);\\r\\nif (r->pub_key != NULL)\\r\\nBN_clear_free(r->pub_key);\\r\\nif (r->priv_key != NULL)\\r\\nBN_clear_free(r->priv_key);\\r\\nif (r->kinv != NULL)\\r\\nBN_clear_free(r->kinv);\\r\\nif (r->r != NULL)\\r\\nBN_clear_free(r->r);\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nint DSA_up_ref(DSA *r)\\r\\n{\\r\\nint i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_DSA);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DSA\", r);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (i < 2) {\\r\\nfprintf(stderr, \"DSA_up_ref, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nreturn ((i > 1) ? 1 : 0);\\r\\n}\\r\\nint DSA_size(const DSA *r)\\r\\n{\\r\\nint ret, i;\\r\\nASN1_INTEGER bs;\\r\\nunsigned char buf[4];\\r\\ni = BN_num_bits(r->q);\\r\\nbs.length = (i + 7) / 8;\\r\\nbs.data = buf;\\r\\nbs.type = V_ASN1_INTEGER;\\r\\nbuf[0] = 0xff;\\r\\ni = i2d_ASN1_INTEGER(&bs, NULL);\\r\\ni += i;\\r\\nret = ASN1_object_size(1, i, V_ASN1_SEQUENCE);\\r\\nreturn (ret);\\r\\n}\\r\\nint DSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DSA, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint DSA_set_ex_data(DSA *d, int idx, void *arg)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&d->ex_data, idx, arg));\\r\\n}\\r\\nvoid *DSA_get_ex_data(DSA *d, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&d->ex_data, idx));\\r\\n}\\r\\nDH *DSA_dup_DH(const DSA *r)\\r\\n{\\r\\nDH *ret = NULL;\\r\\nif (r == NULL)\\r\\ngoto err;\\r\\nret = DH_new();\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\nif (r->p != NULL)\\r\\nif ((ret->p = BN_dup(r->p)) == NULL)\\r\\ngoto err;\\r\\nif (r->q != NULL) {\\r\\nret->length = BN_num_bits(r->q);\\r\\nif ((ret->q = BN_dup(r->q)) == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (r->g != NULL)\\r\\nif ((ret->g = BN_dup(r->g)) == NULL)\\r\\ngoto err;\\r\\nif (r->pub_key != NULL)\\r\\nif ((ret->pub_key = BN_dup(r->pub_key)) == NULL)\\r\\ngoto err;\\r\\nif (r->priv_key != NULL)\\r\\nif ((ret->priv_key = BN_dup(r->priv_key)) == NULL)\\r\\ngoto err;\\r\\nreturn ret;\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nDH_free(ret);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t1_enc_c", "target": 0, "func": "static int tls1_P_hash(const EVP_MD *md, const unsigned char *sec,\\r\\nint sec_len,\\r\\nconst void *seed1, int seed1_len,\\r\\nconst void *seed2, int seed2_len,\\r\\nconst void *seed3, int seed3_len,\\r\\nconst void *seed4, int seed4_len,\\r\\nconst void *seed5, int seed5_len,\\r\\nunsigned char *out, int olen)\\r\\n{\\r\\nint chunk;\\r\\nsize_t j;\\r\\nEVP_MD_CTX ctx, ctx_tmp, ctx_init;\\r\\nEVP_PKEY *mac_key;\\r\\nunsigned char A1[EVP_MAX_MD_SIZE];\\r\\nsize_t A1_len;\\r\\nint ret = 0;\\r\\nchunk = EVP_MD_size(md);\\r\\nOPENSSL_assert(chunk >= 0);\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_MD_CTX_init(&ctx_tmp);\\r\\nEVP_MD_CTX_init(&ctx_init);\\r\\nEVP_MD_CTX_set_flags(&ctx_init, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\\r\\nmac_key = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, sec, sec_len);\\r\\nif (!mac_key)\\r\\ngoto err;\\r\\nif (!EVP_DigestSignInit(&ctx_init, NULL, md, NULL, mac_key))\\r\\ngoto err;\\r\\nif (!EVP_MD_CTX_copy_ex(&ctx, &ctx_init))\\r\\ngoto err;\\r\\nif (seed1 && !EVP_DigestSignUpdate(&ctx, seed1, seed1_len))\\r\\ngoto err;\\r\\nif (seed2 && !EVP_DigestSignUpdate(&ctx, seed2, seed2_len))\\r\\ngoto err;\\r\\nif (seed3 && !EVP_DigestSignUpdate(&ctx, seed3, seed3_len))\\r\\ngoto err;\\r\\nif (seed4 && !EVP_DigestSignUpdate(&ctx, seed4, seed4_len))\\r\\ngoto err;\\r\\nif (seed5 && !EVP_DigestSignUpdate(&ctx, seed5, seed5_len))\\r\\ngoto err;\\r\\nif (!EVP_DigestSignFinal(&ctx, A1, &A1_len))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nif (!EVP_MD_CTX_copy_ex(&ctx, &ctx_init))\\r\\ngoto err;\\r\\nif (!EVP_DigestSignUpdate(&ctx, A1, A1_len))\\r\\ngoto err;\\r\\nif (olen > chunk && !EVP_MD_CTX_copy_ex(&ctx_tmp, &ctx))\\r\\ngoto err;\\r\\nif (seed1 && !EVP_DigestSignUpdate(&ctx, seed1, seed1_len))\\r\\ngoto err;\\r\\nif (seed2 && !EVP_DigestSignUpdate(&ctx, seed2, seed2_len))\\r\\ngoto err;\\r\\nif (seed3 && !EVP_DigestSignUpdate(&ctx, seed3, seed3_len))\\r\\ngoto err;\\r\\nif (seed4 && !EVP_DigestSignUpdate(&ctx, seed4, seed4_len))\\r\\ngoto err;\\r\\nif (seed5 && !EVP_DigestSignUpdate(&ctx, seed5, seed5_len))\\r\\ngoto err;\\r\\nif (olen > chunk) {\\r\\nif (!EVP_DigestSignFinal(&ctx, out, &j))\\r\\ngoto err;\\r\\nout += j;\\r\\nolen -= j;\\r\\nif (!EVP_DigestSignFinal(&ctx_tmp, A1, &A1_len))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!EVP_DigestSignFinal(&ctx, A1, &A1_len))\\r\\ngoto err;\\r\\nmemcpy(out, A1, olen);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nEVP_PKEY_free(mac_key);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nEVP_MD_CTX_cleanup(&ctx_tmp);\\r\\nEVP_MD_CTX_cleanup(&ctx_init);\\r\\nOPENSSL_cleanse(A1, sizeof(A1));\\r\\nreturn ret;\\r\\n}\\r\\nstatic int tls1_PRF(long digest_mask,\\r\\nconst void *seed1, int seed1_len,\\r\\nconst void *seed2, int seed2_len,\\r\\nconst void *seed3, int seed3_len,\\r\\nconst void *seed4, int seed4_len,\\r\\nconst void *seed5, int seed5_len,\\r\\nconst unsigned char *sec, int slen,\\r\\nunsigned char *out1, unsigned char *out2, int olen)\\r\\n{\\r\\nint len, i, idx, count;\\r\\nconst unsigned char *S1;\\r\\nlong m;\\r\\nconst EVP_MD *md;\\r\\nint ret = 0;\\r\\ncount = 0;\\r\\nfor (idx = 0; ssl_get_handshake_digest(idx, &m, &md); idx++) {\\r\\nif ((m << TLS1_PRF_DGST_SHIFT) & digest_mask)\\r\\ncount++;\\r\\n}\\r\\nlen = slen / count;\\r\\nif (count == 1)\\r\\nslen = 0;\\r\\nS1 = sec;\\r\\nmemset(out1, 0, olen);\\r\\nfor (idx = 0; ssl_get_handshake_digest(idx, &m, &md); idx++) {\\r\\nif ((m << TLS1_PRF_DGST_SHIFT) & digest_mask) {\\r\\nif (!md) {\\r\\nSSLerr(SSL_F_TLS1_PRF, SSL_R_UNSUPPORTED_DIGEST_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (!tls1_P_hash(md, S1, len + (slen & 1),\\r\\nseed1, seed1_len, seed2, seed2_len, seed3,\\r\\nseed3_len, seed4, seed4_len, seed5, seed5_len,\\r\\nout2, olen))\\r\\ngoto err;\\r\\nS1 += len;\\r\\nfor (i = 0; i < olen; i++) {\\r\\nout1[i] ^= out2[i];\\r\\n}\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nstatic int tls1_generate_key_block(SSL *s, unsigned char *km,\\r\\nunsigned char *tmp, int num)\\r\\n{\\r\\nint ret;\\r\\nret = tls1_PRF(ssl_get_algorithm2(s),\\r\\nTLS_MD_KEY_EXPANSION_CONST,\\r\\nTLS_MD_KEY_EXPANSION_CONST_SIZE, s->s3->server_random,\\r\\nSSL3_RANDOM_SIZE, s->s3->client_random, SSL3_RANDOM_SIZE,\\r\\nNULL, 0, NULL, 0, s->session->master_key,\\r\\ns->session->master_key_length, km, tmp, num);\\r\\n#ifdef KSSL_DEBUG\\r\\nfprintf(stderr, \"tls1_generate_key_block() ==> %d byte master_key =\\n\\t\",\\r\\ns->session->master_key_length);\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < s->session->master_key_length; i++) {\\r\\nfprintf(stderr, \"%02X\", s->session->master_key[i]);\\r\\n}\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n#endif\\r\\nreturn ret;\\r\\n}\\r\\nint tls1_change_cipher_state(SSL *s, int which)\\r\\n{\\r\\nstatic const unsigned char empty[] = \"\";\\r\\nunsigned char *p, *mac_secret;\\r\\nunsigned char *exp_label;\\r\\nunsigned char tmp1[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char tmp2[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv1[EVP_MAX_IV_LENGTH * 2];\\r\\nunsigned char iv2[EVP_MAX_IV_LENGTH * 2];\\r\\nunsigned char *ms, *key, *iv;\\r\\nint client_write;\\r\\nEVP_CIPHER_CTX *dd;\\r\\nconst EVP_CIPHER *c;\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nconst SSL_COMP *comp;\\r\\n#endif\\r\\nconst EVP_MD *m;\\r\\nint mac_type;\\r\\nint *mac_secret_size;\\r\\nEVP_MD_CTX *mac_ctx;\\r\\nEVP_PKEY *mac_key;\\r\\nint is_export, n, i, j, k, exp_label_len, cl;\\r\\nint reuse_dd = 0;\\r\\nis_export = SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\\r\\nc = s->s3->tmp.new_sym_enc;\\r\\nm = s->s3->tmp.new_hash;\\r\\nmac_type = s->s3->tmp.new_mac_pkey_type;\\r\\n#ifndef OPENSSL_NO_COMP\\r\\ncomp = s->s3->tmp.new_compression;\\r\\n#endif\\r\\n#ifdef KSSL_DEBUG\\r\\nfprintf(stderr, \"tls1_change_cipher_state(which= %d) w/\\n\", which);\\r\\nfprintf(stderr, \"\\talg= %ld/%ld, comp= %p\\n\",\\r\\ns->s3->tmp.new_cipher->algorithm_mkey,\\r\\ns->s3->tmp.new_cipher->algorithm_auth, comp);\\r\\nfprintf(stderr, \"\\tevp_cipher == %p ==? &d_cbc_ede_cipher3\\n\", c);\\r\\nfprintf(stderr, \"\\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\\n\",\\r\\nc->nid, c->block_size, c->key_len, c->iv_len);\\r\\nfprintf(stderr, \"\\tkey_block: len= %d, data= \",\\r\\ns->s3->tmp.key_block_length);\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < s->s3->tmp.key_block_length; i++)\\r\\nfprintf(stderr, \"%02x\", s->s3->tmp.key_block[i]);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n#endif\\r\\nif (which & SSL3_CC_READ) {\\r\\nif (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\\r\\ns->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;\\r\\nelse\\r\\ns->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;\\r\\nif (s->enc_read_ctx != NULL)\\r\\nreuse_dd = 1;\\r\\nelse if ((s->enc_read_ctx =\\r\\nOPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\\r\\ngoto err;\\r\\nelse\\r\\nEVP_CIPHER_CTX_init(s->enc_read_ctx);\\r\\ndd = s->enc_read_ctx;\\r\\nmac_ctx = ssl_replace_hash(&s->read_hash, NULL);\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nif (s->expand != NULL) {\\r\\nCOMP_CTX_free(s->expand);\\r\\ns->expand = NULL;\\r\\n}\\r\\nif (comp != NULL) {\\r\\ns->expand = COMP_CTX_new(comp->method);\\r\\nif (s->expand == NULL) {\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,\\r\\nSSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ns->s3->rrec.comp = (unsigned char *)\\r\\nOPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\nif (s->version != DTLS1_VERSION)\\r\\nmemset(&(s->s3->read_sequence[0]), 0, 8);\\r\\nmac_secret = &(s->s3->read_mac_secret[0]);\\r\\nmac_secret_size = &(s->s3->read_mac_secret_size);\\r\\n} else {\\r\\nif (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\\r\\ns->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;\\r\\nelse\\r\\ns->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;\\r\\nif (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))\\r\\nreuse_dd = 1;\\r\\nelse if ((s->enc_write_ctx = EVP_CIPHER_CTX_new()) == NULL)\\r\\ngoto err;\\r\\ndd = s->enc_write_ctx;\\r\\nif (SSL_IS_DTLS(s)) {\\r\\nmac_ctx = EVP_MD_CTX_create();\\r\\nif (!mac_ctx)\\r\\ngoto err;\\r\\ns->write_hash = mac_ctx;\\r\\n} else\\r\\nmac_ctx = ssl_replace_hash(&s->write_hash, NULL);\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nif (s->compress != NULL) {\\r\\nCOMP_CTX_free(s->compress);\\r\\ns->compress = NULL;\\r\\n}\\r\\nif (comp != NULL) {\\r\\ns->compress = COMP_CTX_new(comp->method);\\r\\nif (s->compress == NULL) {\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,\\r\\nSSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (s->version != DTLS1_VERSION)\\r\\nmemset(&(s->s3->write_sequence[0]), 0, 8);\\r\\nmac_secret = &(s->s3->write_mac_secret[0]);\\r\\nmac_secret_size = &(s->s3->write_mac_secret_size);\\r\\n}\\r\\nif (reuse_dd)\\r\\nEVP_CIPHER_CTX_cleanup(dd);\\r\\np = s->s3->tmp.key_block;\\r\\ni = *mac_secret_size = s->s3->tmp.new_mac_secret_size;\\r\\ncl = EVP_CIPHER_key_length(c);\\r\\nj = is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?\\r\\ncl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;\\r\\nif (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\\r\\nk = EVP_GCM_TLS_FIXED_IV_LEN;\\r\\nelse\\r\\nk = EVP_CIPHER_iv_length(c);\\r\\nif ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\\r\\n(which == SSL3_CHANGE_CIPHER_SERVER_READ)) {\\r\\nms = &(p[0]);\\r\\nn = i + i;\\r\\nkey = &(p[n]);\\r\\nn += j + j;\\r\\niv = &(p[n]);\\r\\nn += k + k;\\r\\nexp_label = (unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;\\r\\nexp_label_len = TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;\\r\\nclient_write = 1;\\r\\n} else {\\r\\nn = i;\\r\\nms = &(p[n]);\\r\\nn += i + j;\\r\\nkey = &(p[n]);\\r\\nn += j + k;\\r\\niv = &(p[n]);\\r\\nn += k;\\r\\nexp_label = (unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;\\r\\nexp_label_len = TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;\\r\\nclient_write = 0;\\r\\n}\\r\\nif (n > s->s3->tmp.key_block_length) {\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nmemcpy(mac_secret, ms, i);\\r\\nif (!(EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER)) {\\r\\nmac_key = EVP_PKEY_new_mac_key(mac_type, NULL,\\r\\nmac_secret, *mac_secret_size);\\r\\nEVP_DigestSignInit(mac_ctx, NULL, m, NULL, mac_key);\\r\\nEVP_PKEY_free(mac_key);\\r\\n}\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"which = %04X\\nmac key=\", which);\\r\\n{\\r\\nint z;\\r\\nfor (z = 0; z < i; z++)\\r\\nprintf(\"%02X%c\", ms[z], ((z + 1) % 16) ? ' ' : '\\n');\\r\\n}\\r\\n#endif\\r\\nif (is_export) {\\r\\nif (!tls1_PRF(ssl_get_algorithm2(s),\\r\\nexp_label, exp_label_len,\\r\\ns->s3->client_random, SSL3_RANDOM_SIZE,\\r\\ns->s3->server_random, SSL3_RANDOM_SIZE,\\r\\nNULL, 0, NULL, 0,\\r\\nkey, j, tmp1, tmp2, EVP_CIPHER_key_length(c)))\\r\\ngoto err2;\\r\\nkey = tmp1;\\r\\nif (k > 0) {\\r\\nif (!tls1_PRF(ssl_get_algorithm2(s),\\r\\nTLS_MD_IV_BLOCK_CONST, TLS_MD_IV_BLOCK_CONST_SIZE,\\r\\ns->s3->client_random, SSL3_RANDOM_SIZE,\\r\\ns->s3->server_random, SSL3_RANDOM_SIZE,\\r\\nNULL, 0, NULL, 0, empty, 0, iv1, iv2, k * 2))\\r\\ngoto err2;\\r\\nif (client_write)\\r\\niv = iv1;\\r\\nelse\\r\\niv = &(iv1[k]);\\r\\n}\\r\\n}\\r\\ns->session->key_arg_length = 0;\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nint i;\\r\\nfprintf(stderr, \"EVP_CipherInit_ex(dd,c,key=,iv=,which)\\n\");\\r\\nfprintf(stderr, \"\\tkey= \");\\r\\nfor (i = 0; i < c->key_len; i++)\\r\\nfprintf(stderr, \"%02x\", key[i]);\\r\\nfprintf(stderr, \"\\n\");\\r\\nfprintf(stderr, \"\\t iv= \");\\r\\nfor (i = 0; i < c->iv_len; i++)\\r\\nfprintf(stderr, \"%02x\", iv[i]);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n#endif\\r\\nif (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) {\\r\\nEVP_CipherInit_ex(dd, c, NULL, key, NULL, (which & SSL3_CC_WRITE));\\r\\nEVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);\\r\\n} else\\r\\nEVP_CipherInit_ex(dd, c, NULL, key, iv, (which & SSL3_CC_WRITE));\\r\\nif ((EVP_CIPHER_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)\\r\\nEVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_MAC_KEY,\\r\\n*mac_secret_size, mac_secret);\\r\\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\\r\\nif (s->msg_callback) {\\r\\nint wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0;\\r\\nif (*mac_secret_size)\\r\\ns->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_MAC,\\r\\nmac_secret, *mac_secret_size,\\r\\ns, s->msg_callback_arg);\\r\\nif (c->key_len)\\r\\ns->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_KEY,\\r\\nkey, c->key_len, s, s->msg_callback_arg);\\r\\nif (k) {\\r\\nif (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)\\r\\nwh |= TLS1_RT_CRYPTO_FIXED_IV;\\r\\nelse\\r\\nwh |= TLS1_RT_CRYPTO_IV;\\r\\ns->msg_callback(2, s->version, wh, iv, k, s, s->msg_callback_arg);\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"which = %04X\\nkey=\", which);\\r\\n{\\r\\nint z;\\r\\nfor (z = 0; z < EVP_CIPHER_key_length(c); z++)\\r\\nprintf(\"%02X%c\", key[z], ((z + 1) % 16) ? ' ' : '\\n');\\r\\n}\\r\\nprintf(\"\\niv=\");\\r\\n{\\r\\nint z;\\r\\nfor (z = 0; z < k; z++)\\r\\nprintf(\"%02X%c\", iv[z], ((z + 1) % 16) ? ' ' : '\\n');\\r\\n}\\r\\nprintf(\"\\n\");\\r\\n#endif\\r\\nOPENSSL_cleanse(tmp1, sizeof(tmp1));\\r\\nOPENSSL_cleanse(tmp2, sizeof(tmp1));\\r\\nOPENSSL_cleanse(iv1, sizeof(iv1));\\r\\nOPENSSL_cleanse(iv2, sizeof(iv2));\\r\\nreturn (1);\\r\\nerr:\\r\\nSSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\\r\\nerr2:\\r\\nreturn (0);\\r\\n}\\r\\nint tls1_setup_key_block(SSL *s)\\r\\n{\\r\\nunsigned char *p1, *p2 = NULL;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *hash;\\r\\nint num;\\r\\nSSL_COMP *comp;\\r\\nint mac_type = NID_undef, mac_secret_size = 0;\\r\\nint ret = 0;\\r\\n#ifdef KSSL_DEBUG\\r\\nfprintf(stderr, \"tls1_setup_key_block()\\n\");\\r\\n#endif\\r\\nif (s->s3->tmp.key_block_length != 0)\\r\\nreturn (1);\\r\\nif (!ssl_cipher_get_evp\\r\\n(s->session, &c, &hash, &mac_type, &mac_secret_size, &comp)) {\\r\\nSSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\\r\\nreturn (0);\\r\\n}\\r\\ns->s3->tmp.new_sym_enc = c;\\r\\ns->s3->tmp.new_hash = hash;\\r\\ns->s3->tmp.new_mac_pkey_type = mac_type;\\r\\ns->s3->tmp.new_mac_secret_size = mac_secret_size;\\r\\nnum =\\r\\nEVP_CIPHER_key_length(c) + mac_secret_size + EVP_CIPHER_iv_length(c);\\r\\nnum *= 2;\\r\\nssl3_cleanup_key_block(s);\\r\\nif ((p1 = (unsigned char *)OPENSSL_malloc(num)) == NULL) {\\r\\nSSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ns->s3->tmp.key_block_length = num;\\r\\ns->s3->tmp.key_block = p1;\\r\\nif ((p2 = (unsigned char *)OPENSSL_malloc(num)) == NULL) {\\r\\nSSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"client random\\n\");\\r\\n{\\r\\nint z;\\r\\nfor (z = 0; z < SSL3_RANDOM_SIZE; z++)\\r\\nprintf(\"%02X%c\", s->s3->client_random[z],\\r\\n((z + 1) % 16) ? ' ' : '\\n');\\r\\n}\\r\\nprintf(\"server random\\n\");\\r\\n{\\r\\nint z;\\r\\nfor (z = 0; z < SSL3_RANDOM_SIZE; z++)\\r\\nprintf(\"%02X%c\", s->s3->server_random[z],\\r\\n((z + 1) % 16) ? ' ' : '\\n');\\r\\n}\\r\\nprintf(\"pre-master\\n\");\\r\\n{\\r\\nint z;\\r\\nfor (z = 0; z < s->session->master_key_length; z++)\\r\\nprintf(\"%02X%c\", s->session->master_key[z],\\r\\n((z + 1) % 16) ? ' ' : '\\n');\\r\\n}\\r\\n#endif\\r\\nif (!tls1_generate_key_block(s, p1, p2, num))\\r\\ngoto err;\\r\\n#ifdef TLS_DEBUG\\r\\nprintf(\"\\nkey block\\n\");\\r\\n{\\r\\nint z;\\r\\nfor (z = 0; z < num; z++)\\r\\nprintf(\"%02X%c\", p1[z], ((z + 1) % 16) ? ' ' : '\\n');\\r\\n}\\r\\n#endif\\r\\nif (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)\\r\\n&& s->method->version <= TLS1_VERSION) {\\r\\ns->s3->need_empty_fragments = 1;\\r\\nif (s->session->cipher != NULL) {\\r\\nif (s->session->cipher->algorithm_enc == SSL_eNULL)\\r\\ns->s3->need_empty_fragments = 0;\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nif (s->session->cipher->algorithm_enc == SSL_RC4)\\r\\ns->s3->need_empty_fragments = 0;\\r\\n#endif\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (p2) {\\r\\nOPENSSL_cleanse(p2, num);\\r\\nOPENSSL_free(p2);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint tls1_enc(SSL *s, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nEVP_CIPHER_CTX *ds;\\r\\nunsigned long l;\\r\\nint bs, i, j, k, pad = 0, ret, mac_size = 0;\\r\\nconst EVP_CIPHER *enc;\\r\\nif (send) {\\r\\nif (EVP_MD_CTX_md(s->write_hash)) {\\r\\nint n = EVP_MD_CTX_size(s->write_hash);\\r\\nOPENSSL_assert(n >= 0);\\r\\n}\\r\\nds = s->enc_write_ctx;\\r\\nrec = &(s->s3->wrec);\\r\\nif (s->enc_write_ctx == NULL)\\r\\nenc = NULL;\\r\\nelse {\\r\\nint ivlen;\\r\\nenc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\\r\\nif (SSL_USE_EXPLICIT_IV(s)\\r\\n&& EVP_CIPHER_mode(enc) == EVP_CIPH_CBC_MODE)\\r\\nivlen = EVP_CIPHER_iv_length(enc);\\r\\nelse\\r\\nivlen = 0;\\r\\nif (ivlen > 1) {\\r\\nif (rec->data != rec->input)\\r\\nfprintf(stderr,\\r\\n\"%s:%d: rec->data != rec->input\\n\",\\r\\n__FILE__, __LINE__);\\r\\nelse if (RAND_bytes(rec->input, ivlen) <= 0)\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\n} else {\\r\\nif (EVP_MD_CTX_md(s->read_hash)) {\\r\\nint n = EVP_MD_CTX_size(s->read_hash);\\r\\nOPENSSL_assert(n >= 0);\\r\\n}\\r\\nds = s->enc_read_ctx;\\r\\nrec = &(s->s3->rrec);\\r\\nif (s->enc_read_ctx == NULL)\\r\\nenc = NULL;\\r\\nelse\\r\\nenc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\nfprintf(stderr, \"tls1_enc(%d)\\n\", send);\\r\\n#endif\\r\\nif ((s->session == NULL) || (ds == NULL) || (enc == NULL)) {\\r\\nmemmove(rec->data, rec->input, rec->length);\\r\\nrec->input = rec->data;\\r\\nret = 1;\\r\\n} else {\\r\\nl = rec->length;\\r\\nbs = EVP_CIPHER_block_size(ds->cipher);\\r\\nif (EVP_CIPHER_flags(ds->cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) {\\r\\nunsigned char buf[13], *seq;\\r\\nseq = send ? s->s3->write_sequence : s->s3->read_sequence;\\r\\nif (SSL_IS_DTLS(s)) {\\r\\nunsigned char dtlsseq[9], *p = dtlsseq;\\r\\ns2n(send ? s->d1->w_epoch : s->d1->r_epoch, p);\\r\\nmemcpy(p, &seq[2], 6);\\r\\nmemcpy(buf, dtlsseq, 8);\\r\\n} else {\\r\\nmemcpy(buf, seq, 8);\\r\\nfor (i = 7; i >= 0; i--) {\\r\\n++seq[i];\\r\\nif (seq[i] != 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf[8] = rec->type;\\r\\nbuf[9] = (unsigned char)(s->version >> 8);\\r\\nbuf[10] = (unsigned char)(s->version);\\r\\nbuf[11] = rec->length >> 8;\\r\\nbuf[12] = rec->length & 0xff;\\r\\npad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD, 13, buf);\\r\\nif (send) {\\r\\nl += pad;\\r\\nrec->length += pad;\\r\\n}\\r\\n} else if ((bs != 1) && send) {\\r\\ni = bs - ((int)l % bs);\\r\\nj = i - 1;\\r\\nif (s->options & SSL_OP_TLS_BLOCK_PADDING_BUG) {\\r\\nif (s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG)\\r\\nj++;\\r\\n}\\r\\nfor (k = (int)l; k < (int)(l + i); k++)\\r\\nrec->input[k] = j;\\r\\nl += i;\\r\\nrec->length += i;\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nunsigned long ui;\\r\\nfprintf(stderr,\\r\\n\"EVP_Cipher(ds=%p,rec->data=%p,rec->input=%p,l=%ld) ==>\\n\",\\r\\nds, rec->data, rec->input, l);\\r\\nfprintf(stderr,\\r\\n\"\\tEVP_CIPHER_CTX: %d buf_len, %d key_len [%lu %lu], %d iv_len\\n\",\\r\\nds->buf_len, ds->cipher->key_len, DES_KEY_SZ,\\r\\nDES_SCHEDULE_SZ, ds->cipher->iv_len);\\r\\nfprintf(stderr, \"\\t\\tIV: \");\\r\\nfor (i = 0; i < ds->cipher->iv_len; i++)\\r\\nfprintf(stderr, \"%02X\", ds->iv[i]);\\r\\nfprintf(stderr, \"\\n\");\\r\\nfprintf(stderr, \"\\trec->input=\");\\r\\nfor (ui = 0; ui < l; ui++)\\r\\nfprintf(stderr, \" %02x\", rec->input[ui]);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n#endif\\r\\nif (!send) {\\r\\nif (l == 0 || l % bs != 0)\\r\\nreturn 0;\\r\\n}\\r\\ni = EVP_Cipher(ds, rec->data, rec->input, l);\\r\\nif ((EVP_CIPHER_flags(ds->cipher) & EVP_CIPH_FLAG_CUSTOM_CIPHER)\\r\\n? (i < 0)\\r\\n: (i == 0))\\r\\nreturn -1;\\r\\nif (EVP_CIPHER_mode(enc) == EVP_CIPH_GCM_MODE && !send) {\\r\\nrec->data += EVP_GCM_TLS_EXPLICIT_IV_LEN;\\r\\nrec->input += EVP_GCM_TLS_EXPLICIT_IV_LEN;\\r\\nrec->length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\\r\\n}\\r\\n#ifdef KSSL_DEBUG\\r\\n{\\r\\nunsigned long i;\\r\\nfprintf(stderr, \"\\trec->data=\");\\r\\nfor (i = 0; i < l; i++)\\r\\nfprintf(stderr, \" %02x\", rec->data[i]);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n#endif\\r\\nret = 1;\\r\\nif (EVP_MD_CTX_md(s->read_hash) != NULL)\\r\\nmac_size = EVP_MD_CTX_size(s->read_hash);\\r\\nif ((bs != 1) && !send)\\r\\nret = tls1_cbc_remove_padding(s, rec, bs, mac_size);\\r\\nif (pad && !send)\\r\\nrec->length -= pad;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *out)\\r\\n{\\r\\nunsigned int ret;\\r\\nEVP_MD_CTX ctx, *d = NULL;\\r\\nint i;\\r\\nif (s->s3->handshake_buffer)\\r\\nif (!ssl3_digest_cached_records(s))\\r\\nreturn 0;\\r\\nfor (i = 0; i < SSL_MAX_DIGEST; i++) {\\r\\nif (s->s3->handshake_dgst[i]\\r\\n&& EVP_MD_CTX_type(s->s3->handshake_dgst[i]) == md_nid) {\\r\\nd = s->s3->handshake_dgst[i];\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!d) {\\r\\nSSLerr(SSL_F_TLS1_CERT_VERIFY_MAC, SSL_R_NO_REQUIRED_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_MD_CTX_copy_ex(&ctx, d);\\r\\nEVP_DigestFinal_ex(&ctx, out, &ret);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn ((int)ret);\\r\\n}\\r\\nint tls1_final_finish_mac(SSL *s,\\r\\nconst char *str, int slen, unsigned char *out)\\r\\n{\\r\\nunsigned int i;\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char buf[2 * EVP_MAX_MD_SIZE];\\r\\nunsigned char *q, buf2[12];\\r\\nint idx;\\r\\nlong mask;\\r\\nint err = 0;\\r\\nconst EVP_MD *md;\\r\\nq = buf;\\r\\nif (s->s3->handshake_buffer)\\r\\nif (!ssl3_digest_cached_records(s))\\r\\nreturn 0;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nfor (idx = 0; ssl_get_handshake_digest(idx, &mask, &md); idx++) {\\r\\nif (mask & ssl_get_algorithm2(s)) {\\r\\nint hashsize = EVP_MD_size(md);\\r\\nEVP_MD_CTX *hdgst = s->s3->handshake_dgst[idx];\\r\\nif (!hdgst || hashsize < 0\\r\\n|| hashsize > (int)(sizeof buf - (size_t)(q - buf))) {\\r\\nerr = 1;\\r\\n} else {\\r\\nif (!EVP_MD_CTX_copy_ex(&ctx, hdgst) ||\\r\\n!EVP_DigestFinal_ex(&ctx, q, &i) ||\\r\\n(i != (unsigned int)hashsize))\\r\\nerr = 1;\\r\\nq += hashsize;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!tls1_PRF(ssl_get_algorithm2(s),\\r\\nstr, slen, buf, (int)(q - buf), NULL, 0, NULL, 0, NULL, 0,\\r\\ns->session->master_key, s->session->master_key_length,\\r\\nout, buf2, sizeof buf2))\\r\\nerr = 1;\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nif (err)\\r\\nreturn 0;\\r\\nelse\\r\\nreturn sizeof buf2;\\r\\n}\\r\\nint tls1_mac(SSL *ssl, unsigned char *md, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nunsigned char *seq;\\r\\nEVP_MD_CTX *hash;\\r\\nsize_t md_size, orig_len;\\r\\nint i;\\r\\nEVP_MD_CTX hmac, *mac_ctx;\\r\\nunsigned char header[13];\\r\\nint stream_mac = (send ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM)\\r\\n: (ssl->mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM));\\r\\nint t;\\r\\nif (send) {\\r\\nrec = &(ssl->s3->wrec);\\r\\nseq = &(ssl->s3->write_sequence[0]);\\r\\nhash = ssl->write_hash;\\r\\n} else {\\r\\nrec = &(ssl->s3->rrec);\\r\\nseq = &(ssl->s3->read_sequence[0]);\\r\\nhash = ssl->read_hash;\\r\\n}\\r\\nt = EVP_MD_CTX_size(hash);\\r\\nOPENSSL_assert(t >= 0);\\r\\nmd_size = t;\\r\\nif (stream_mac) {\\r\\nmac_ctx = hash;\\r\\n} else {\\r\\nif (!EVP_MD_CTX_copy(&hmac, hash))\\r\\nreturn -1;\\r\\nmac_ctx = &hmac;\\r\\n}\\r\\nif (SSL_IS_DTLS(ssl)) {\\r\\nunsigned char dtlsseq[8], *p = dtlsseq;\\r\\ns2n(send ? ssl->d1->w_epoch : ssl->d1->r_epoch, p);\\r\\nmemcpy(p, &seq[2], 6);\\r\\nmemcpy(header, dtlsseq, 8);\\r\\n} else\\r\\nmemcpy(header, seq, 8);\\r\\norig_len = rec->length + md_size + ((unsigned int)rec->type >> 8);\\r\\nrec->type &= 0xff;\\r\\nheader[8] = rec->type;\\r\\nheader[9] = (unsigned char)(ssl->version >> 8);\\r\\nheader[10] = (unsigned char)(ssl->version);\\r\\nheader[11] = (rec->length) >> 8;\\r\\nheader[12] = (rec->length) & 0xff;\\r\\nif (!send &&\\r\\nEVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\\r\\nssl3_cbc_record_digest_supported(mac_ctx)) {\\r\\nssl3_cbc_digest_record(mac_ctx,\\r\\nmd, &md_size,\\r\\nheader, rec->input,\\r\\nrec->length + md_size, orig_len,\\r\\nssl->s3->read_mac_secret,\\r\\nssl->s3->read_mac_secret_size, 0);\\r\\n} else {\\r\\nEVP_DigestSignUpdate(mac_ctx, header, sizeof(header));\\r\\nEVP_DigestSignUpdate(mac_ctx, rec->input, rec->length);\\r\\nt = EVP_DigestSignFinal(mac_ctx, md, &md_size);\\r\\nOPENSSL_assert(t > 0);\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (!send && FIPS_mode())\\r\\ntls_fips_digest_extra(ssl->enc_read_ctx,\\r\\nmac_ctx, rec->input, rec->length, orig_len);\\r\\n#endif\\r\\n}\\r\\nif (!stream_mac)\\r\\nEVP_MD_CTX_cleanup(&hmac);\\r\\n#ifdef TLS_DEBUG\\r\\nfprintf(stderr, \"seq=\");\\r\\n{\\r\\nint z;\\r\\nfor (z = 0; z < 8; z++)\\r\\nfprintf(stderr, \"%02X \", seq[z]);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\nfprintf(stderr, \"rec=\");\\r\\n{\\r\\nunsigned int z;\\r\\nfor (z = 0; z < rec->length; z++)\\r\\nfprintf(stderr, \"%02X \", rec->data[z]);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n#endif\\r\\nif (!SSL_IS_DTLS(ssl)) {\\r\\nfor (i = 7; i >= 0; i--) {\\r\\n++seq[i];\\r\\nif (seq[i] != 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n#ifdef TLS_DEBUG\\r\\n{\\r\\nunsigned int z;\\r\\nfor (z = 0; z < md_size; z++)\\r\\nfprintf(stderr, \"%02X \", md[z]);\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n#endif\\r\\nreturn (md_size);\\r\\n}\\r\\nint tls1_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,\\r\\nint len)\\r\\n{\\r\\nunsigned char buff[SSL_MAX_MASTER_KEY_LENGTH];\\r\\nconst void *co = NULL, *so = NULL;\\r\\nint col = 0, sol = 0;\\r\\n#ifdef KSSL_DEBUG\\r\\nfprintf(stderr, \"tls1_generate_master_secret(%p,%p, %p, %d)\\n\", s, out, p,\\r\\nlen);\\r\\n#endif\\r\\n#ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nif (s->s3->client_opaque_prf_input != NULL\\r\\n&& s->s3->server_opaque_prf_input != NULL\\r\\n&& s->s3->client_opaque_prf_input_len > 0\\r\\n&& s->s3->client_opaque_prf_input_len ==\\r\\ns->s3->server_opaque_prf_input_len) {\\r\\nco = s->s3->client_opaque_prf_input;\\r\\ncol = s->s3->server_opaque_prf_input_len;\\r\\nso = s->s3->server_opaque_prf_input;\\r\\nsol = s->s3->client_opaque_prf_input_len;\\r\\n}\\r\\n#endif\\r\\ntls1_PRF(ssl_get_algorithm2(s),\\r\\nTLS_MD_MASTER_SECRET_CONST, TLS_MD_MASTER_SECRET_CONST_SIZE,\\r\\ns->s3->client_random, SSL3_RANDOM_SIZE,\\r\\nco, col,\\r\\ns->s3->server_random, SSL3_RANDOM_SIZE,\\r\\nso, sol, p, len, s->session->master_key, buff, sizeof buff);\\r\\n#ifdef SSL_DEBUG\\r\\nfprintf(stderr, \"Premaster Secret:\\n\");\\r\\nBIO_dump_fp(stderr, (char *)p, len);\\r\\nfprintf(stderr, \"Client Random:\\n\");\\r\\nBIO_dump_fp(stderr, (char *)s->s3->client_random, SSL3_RANDOM_SIZE);\\r\\nfprintf(stderr, \"Server Random:\\n\");\\r\\nBIO_dump_fp(stderr, (char *)s->s3->server_random, SSL3_RANDOM_SIZE);\\r\\nfprintf(stderr, \"Master Secret:\\n\");\\r\\nBIO_dump_fp(stderr, (char *)s->session->master_key,\\r\\nSSL3_MASTER_SECRET_SIZE);\\r\\n#endif\\r\\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\\r\\nif (s->msg_callback) {\\r\\ns->msg_callback(2, s->version, TLS1_RT_CRYPTO_PREMASTER,\\r\\np, len, s, s->msg_callback_arg);\\r\\ns->msg_callback(2, s->version, TLS1_RT_CRYPTO_CLIENT_RANDOM,\\r\\ns->s3->client_random, SSL3_RANDOM_SIZE,\\r\\ns, s->msg_callback_arg);\\r\\ns->msg_callback(2, s->version, TLS1_RT_CRYPTO_SERVER_RANDOM,\\r\\ns->s3->server_random, SSL3_RANDOM_SIZE,\\r\\ns, s->msg_callback_arg);\\r\\ns->msg_callback(2, s->version, TLS1_RT_CRYPTO_MASTER,\\r\\ns->session->master_key,\\r\\nSSL3_MASTER_SECRET_SIZE, s, s->msg_callback_arg);\\r\\n}\\r\\n#endif\\r\\n#ifdef KSSL_DEBUG\\r\\nfprintf(stderr, \"tls1_generate_master_secret() complete\\n\");\\r\\n#endif\\r\\nreturn (SSL3_MASTER_SECRET_SIZE);\\r\\n}\\r\\nint tls1_export_keying_material(SSL *s, unsigned char *out, size_t olen,\\r\\nconst char *label, size_t llen,\\r\\nconst unsigned char *context,\\r\\nsize_t contextlen, int use_context)\\r\\n{\\r\\nunsigned char *buff;\\r\\nunsigned char *val = NULL;\\r\\nsize_t vallen, currentvalpos;\\r\\nint rv;\\r\\n#ifdef KSSL_DEBUG\\r\\nfprintf(stderr, \"tls1_export_keying_material(%p,%p,%lu,%s,%lu,%p,%lu)\\n\",\\r\\ns, out, olen, label, llen, context, contextlen);\\r\\n#endif\\r\\nbuff = OPENSSL_malloc(olen);\\r\\nif (buff == NULL)\\r\\ngoto err2;\\r\\nvallen = llen + SSL3_RANDOM_SIZE * 2;\\r\\nif (use_context) {\\r\\nvallen += 2 + contextlen;\\r\\n}\\r\\nval = OPENSSL_malloc(vallen);\\r\\nif (val == NULL)\\r\\ngoto err2;\\r\\ncurrentvalpos = 0;\\r\\nmemcpy(val + currentvalpos, (unsigned char *)label, llen);\\r\\ncurrentvalpos += llen;\\r\\nmemcpy(val + currentvalpos, s->s3->client_random, SSL3_RANDOM_SIZE);\\r\\ncurrentvalpos += SSL3_RANDOM_SIZE;\\r\\nmemcpy(val + currentvalpos, s->s3->server_random, SSL3_RANDOM_SIZE);\\r\\ncurrentvalpos += SSL3_RANDOM_SIZE;\\r\\nif (use_context) {\\r\\nval[currentvalpos] = (contextlen >> 8) & 0xff;\\r\\ncurrentvalpos++;\\r\\nval[currentvalpos] = contextlen & 0xff;\\r\\ncurrentvalpos++;\\r\\nif ((contextlen > 0) || (context != NULL)) {\\r\\nmemcpy(val + currentvalpos, context, contextlen);\\r\\n}\\r\\n}\\r\\nif (memcmp(val, TLS_MD_CLIENT_FINISH_CONST,\\r\\nTLS_MD_CLIENT_FINISH_CONST_SIZE) == 0)\\r\\ngoto err1;\\r\\nif (memcmp(val, TLS_MD_SERVER_FINISH_CONST,\\r\\nTLS_MD_SERVER_FINISH_CONST_SIZE) == 0)\\r\\ngoto err1;\\r\\nif (memcmp(val, TLS_MD_MASTER_SECRET_CONST,\\r\\nTLS_MD_MASTER_SECRET_CONST_SIZE) == 0)\\r\\ngoto err1;\\r\\nif (memcmp(val, TLS_MD_KEY_EXPANSION_CONST,\\r\\nTLS_MD_KEY_EXPANSION_CONST_SIZE) == 0)\\r\\ngoto err1;\\r\\nrv = tls1_PRF(ssl_get_algorithm2(s),\\r\\nval, vallen,\\r\\nNULL, 0,\\r\\nNULL, 0,\\r\\nNULL, 0,\\r\\nNULL, 0,\\r\\ns->session->master_key, s->session->master_key_length,\\r\\nout, buff, olen);\\r\\n#ifdef KSSL_DEBUG\\r\\nfprintf(stderr, \"tls1_export_keying_material() complete\\n\");\\r\\n#endif\\r\\ngoto ret;\\r\\nerr1:\\r\\nSSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL,\\r\\nSSL_R_TLS_ILLEGAL_EXPORTER_LABEL);\\r\\nrv = 0;\\r\\ngoto ret;\\r\\nerr2:\\r\\nSSLerr(SSL_F_TLS1_EXPORT_KEYING_MATERIAL, ERR_R_MALLOC_FAILURE);\\r\\nrv = 0;\\r\\nret:\\r\\nif (buff != NULL)\\r\\nOPENSSL_free(buff);\\r\\nif (val != NULL)\\r\\nOPENSSL_free(val);\\r\\nreturn (rv);\\r\\n}\\r\\nint tls1_alert_code(int code)\\r\\n{\\r\\nswitch (code) {\\r\\ncase SSL_AD_CLOSE_NOTIFY:\\r\\nreturn (SSL3_AD_CLOSE_NOTIFY);\\r\\ncase SSL_AD_UNEXPECTED_MESSAGE:\\r\\nreturn (SSL3_AD_UNEXPECTED_MESSAGE);\\r\\ncase SSL_AD_BAD_RECORD_MAC:\\r\\nreturn (SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_DECRYPTION_FAILED:\\r\\nreturn (TLS1_AD_DECRYPTION_FAILED);\\r\\ncase SSL_AD_RECORD_OVERFLOW:\\r\\nreturn (TLS1_AD_RECORD_OVERFLOW);\\r\\ncase SSL_AD_DECOMPRESSION_FAILURE:\\r\\nreturn (SSL3_AD_DECOMPRESSION_FAILURE);\\r\\ncase SSL_AD_HANDSHAKE_FAILURE:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_NO_CERTIFICATE:\\r\\nreturn (-1);\\r\\ncase SSL_AD_BAD_CERTIFICATE:\\r\\nreturn (SSL3_AD_BAD_CERTIFICATE);\\r\\ncase SSL_AD_UNSUPPORTED_CERTIFICATE:\\r\\nreturn (SSL3_AD_UNSUPPORTED_CERTIFICATE);\\r\\ncase SSL_AD_CERTIFICATE_REVOKED:\\r\\nreturn (SSL3_AD_CERTIFICATE_REVOKED);\\r\\ncase SSL_AD_CERTIFICATE_EXPIRED:\\r\\nreturn (SSL3_AD_CERTIFICATE_EXPIRED);\\r\\ncase SSL_AD_CERTIFICATE_UNKNOWN:\\r\\nreturn (SSL3_AD_CERTIFICATE_UNKNOWN);\\r\\ncase SSL_AD_ILLEGAL_PARAMETER:\\r\\nreturn (SSL3_AD_ILLEGAL_PARAMETER);\\r\\ncase SSL_AD_UNKNOWN_CA:\\r\\nreturn (TLS1_AD_UNKNOWN_CA);\\r\\ncase SSL_AD_ACCESS_DENIED:\\r\\nreturn (TLS1_AD_ACCESS_DENIED);\\r\\ncase SSL_AD_DECODE_ERROR:\\r\\nreturn (TLS1_AD_DECODE_ERROR);\\r\\ncase SSL_AD_DECRYPT_ERROR:\\r\\nreturn (TLS1_AD_DECRYPT_ERROR);\\r\\ncase SSL_AD_EXPORT_RESTRICTION:\\r\\nreturn (TLS1_AD_EXPORT_RESTRICTION);\\r\\ncase SSL_AD_PROTOCOL_VERSION:\\r\\nreturn (TLS1_AD_PROTOCOL_VERSION);\\r\\ncase SSL_AD_INSUFFICIENT_SECURITY:\\r\\nreturn (TLS1_AD_INSUFFICIENT_SECURITY);\\r\\ncase SSL_AD_INTERNAL_ERROR:\\r\\nreturn (TLS1_AD_INTERNAL_ERROR);\\r\\ncase SSL_AD_USER_CANCELLED:\\r\\nreturn (TLS1_AD_USER_CANCELLED);\\r\\ncase SSL_AD_NO_RENEGOTIATION:\\r\\nreturn (TLS1_AD_NO_RENEGOTIATION);\\r\\ncase SSL_AD_UNSUPPORTED_EXTENSION:\\r\\nreturn (TLS1_AD_UNSUPPORTED_EXTENSION);\\r\\ncase SSL_AD_CERTIFICATE_UNOBTAINABLE:\\r\\nreturn (TLS1_AD_CERTIFICATE_UNOBTAINABLE);\\r\\ncase SSL_AD_UNRECOGNIZED_NAME:\\r\\nreturn (TLS1_AD_UNRECOGNIZED_NAME);\\r\\ncase SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE:\\r\\nreturn (TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE);\\r\\ncase SSL_AD_BAD_CERTIFICATE_HASH_VALUE:\\r\\nreturn (TLS1_AD_BAD_CERTIFICATE_HASH_VALUE);\\r\\ncase SSL_AD_UNKNOWN_PSK_IDENTITY:\\r\\nreturn (TLS1_AD_UNKNOWN_PSK_IDENTITY);\\r\\ncase SSL_AD_INAPPROPRIATE_FALLBACK:\\r\\nreturn (TLS1_AD_INAPPROPRIATE_FALLBACK);\\r\\n#if 0\\r\\ncase DTLS1_AD_MISSING_HANDSHAKE_MESSAGE:\\r\\nreturn (DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\\r\\n#endif\\r\\ndefault:\\r\\nreturn (-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pvkfmt_c", "target": 0, "func": "static unsigned int read_ledword(const unsigned char **in)\\r\\n{\\r\\nconst unsigned char *p = *in;\\r\\nunsigned int ret;\\r\\nret = *p++;\\r\\nret |= (*p++ << 8);\\r\\nret |= (*p++ << 16);\\r\\nret |= (*p++ << 24);\\r\\n*in = p;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nunsigned char *tmpbuf, *q;\\r\\nunsigned int i;\\r\\np = *in + nbyte - 1;\\r\\ntmpbuf = OPENSSL_malloc(nbyte);\\r\\nif (!tmpbuf)\\r\\nreturn 0;\\r\\nq = tmpbuf;\\r\\nfor (i = 0; i < nbyte; i++)\\r\\n*q++ = *p--;\\r\\n*r = BN_bin2bn(tmpbuf, nbyte, NULL);\\r\\nOPENSSL_free(tmpbuf);\\r\\nif (*r) {\\r\\n*in += nbyte;\\r\\nreturn 1;\\r\\n} else\\r\\nreturn 0;\\r\\n}\\r\\nstatic int do_blob_header(const unsigned char **in, unsigned int length,\\r\\nunsigned int *pmagic, unsigned int *pbitlen,\\r\\nint *pisdss, int *pispub)\\r\\n{\\r\\nconst unsigned char *p = *in;\\r\\nif (length < 16)\\r\\nreturn 0;\\r\\nif (*p == MS_PUBLICKEYBLOB) {\\r\\nif (*pispub == 0) {\\r\\nPEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_EXPECTING_PRIVATE_KEY_BLOB);\\r\\nreturn 0;\\r\\n}\\r\\n*pispub = 1;\\r\\n} else if (*p == MS_PRIVATEKEYBLOB) {\\r\\nif (*pispub == 1) {\\r\\nPEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_EXPECTING_PUBLIC_KEY_BLOB);\\r\\nreturn 0;\\r\\n}\\r\\n*pispub = 0;\\r\\n} else\\r\\nreturn 0;\\r\\np++;\\r\\nif (*p++ != 0x2) {\\r\\nPEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_BAD_VERSION_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\np += 6;\\r\\n*pmagic = read_ledword(&p);\\r\\n*pbitlen = read_ledword(&p);\\r\\n*pisdss = 0;\\r\\nswitch (*pmagic) {\\r\\ncase MS_DSS1MAGIC:\\r\\n*pisdss = 1;\\r\\ncase MS_RSA1MAGIC:\\r\\nif (*pispub == 0) {\\r\\nPEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_EXPECTING_PRIVATE_KEY_BLOB);\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ncase MS_DSS2MAGIC:\\r\\n*pisdss = 1;\\r\\ncase MS_RSA2MAGIC:\\r\\nif (*pispub == 1) {\\r\\nPEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_EXPECTING_PUBLIC_KEY_BLOB);\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPEMerr(PEM_F_DO_BLOB_HEADER, PEM_R_BAD_MAGIC_NUMBER);\\r\\nreturn -1;\\r\\n}\\r\\n*in = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic unsigned int blob_length(unsigned bitlen, int isdss, int ispub)\\r\\n{\\r\\nunsigned int nbyte, hnbyte;\\r\\nnbyte = (bitlen + 7) >> 3;\\r\\nhnbyte = (bitlen + 15) >> 4;\\r\\nif (isdss) {\\r\\nif (ispub)\\r\\nreturn 44 + 3 * nbyte;\\r\\nelse\\r\\nreturn 64 + 2 * nbyte;\\r\\n} else {\\r\\nif (ispub)\\r\\nreturn 4 + nbyte;\\r\\nelse\\r\\nreturn 4 + 2 * nbyte + 5 * hnbyte;\\r\\n}\\r\\n}\\r\\nstatic EVP_PKEY *do_b2i(const unsigned char **in, unsigned int length,\\r\\nint ispub)\\r\\n{\\r\\nconst unsigned char *p = *in;\\r\\nunsigned int bitlen, magic;\\r\\nint isdss;\\r\\nif (do_blob_header(&p, length, &magic, &bitlen, &isdss, &ispub) <= 0) {\\r\\nPEMerr(PEM_F_DO_B2I, PEM_R_KEYBLOB_HEADER_PARSE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nlength -= 16;\\r\\nif (length < blob_length(bitlen, isdss, ispub)) {\\r\\nPEMerr(PEM_F_DO_B2I, PEM_R_KEYBLOB_TOO_SHORT);\\r\\nreturn NULL;\\r\\n}\\r\\nif (isdss)\\r\\nreturn b2i_dss(&p, length, bitlen, ispub);\\r\\nelse\\r\\nreturn b2i_rsa(&p, length, bitlen, ispub);\\r\\n}\\r\\nstatic EVP_PKEY *do_b2i_bio(BIO *in, int ispub)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nunsigned char hdr_buf[16], *buf = NULL;\\r\\nunsigned int bitlen, magic, length;\\r\\nint isdss;\\r\\nEVP_PKEY *ret = NULL;\\r\\nif (BIO_read(in, hdr_buf, 16) != 16) {\\r\\nPEMerr(PEM_F_DO_B2I_BIO, PEM_R_KEYBLOB_TOO_SHORT);\\r\\nreturn NULL;\\r\\n}\\r\\np = hdr_buf;\\r\\nif (do_blob_header(&p, 16, &magic, &bitlen, &isdss, &ispub) <= 0)\\r\\nreturn NULL;\\r\\nlength = blob_length(bitlen, isdss, ispub);\\r\\nbuf = OPENSSL_malloc(length);\\r\\nif (!buf) {\\r\\nPEMerr(PEM_F_DO_B2I_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np = buf;\\r\\nif (BIO_read(in, buf, length) != (int)length) {\\r\\nPEMerr(PEM_F_DO_B2I_BIO, PEM_R_KEYBLOB_TOO_SHORT);\\r\\ngoto err;\\r\\n}\\r\\nif (isdss)\\r\\nret = b2i_dss(&p, length, bitlen, ispub);\\r\\nelse\\r\\nret = b2i_rsa(&p, length, bitlen, ispub);\\r\\nerr:\\r\\nif (buf)\\r\\nOPENSSL_free(buf);\\r\\nreturn ret;\\r\\n}\\r\\nstatic EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,\\r\\nunsigned int bitlen, int ispub)\\r\\n{\\r\\nconst unsigned char *p = *in;\\r\\nEVP_PKEY *ret = NULL;\\r\\nDSA *dsa = NULL;\\r\\nBN_CTX *ctx = NULL;\\r\\nunsigned int nbyte;\\r\\nnbyte = (bitlen + 7) >> 3;\\r\\ndsa = DSA_new();\\r\\nret = EVP_PKEY_new();\\r\\nif (!dsa || !ret)\\r\\ngoto memerr;\\r\\nif (!read_lebn(&p, nbyte, &dsa->p))\\r\\ngoto memerr;\\r\\nif (!read_lebn(&p, 20, &dsa->q))\\r\\ngoto memerr;\\r\\nif (!read_lebn(&p, nbyte, &dsa->g))\\r\\ngoto memerr;\\r\\nif (ispub) {\\r\\nif (!read_lebn(&p, nbyte, &dsa->pub_key))\\r\\ngoto memerr;\\r\\n} else {\\r\\nif (!read_lebn(&p, 20, &dsa->priv_key))\\r\\ngoto memerr;\\r\\nif (!(dsa->pub_key = BN_new()))\\r\\ngoto memerr;\\r\\nif (!(ctx = BN_CTX_new()))\\r\\ngoto memerr;\\r\\nif (!BN_mod_exp(dsa->pub_key, dsa->g, dsa->priv_key, dsa->p, ctx))\\r\\ngoto memerr;\\r\\nBN_CTX_free(ctx);\\r\\n}\\r\\nEVP_PKEY_set1_DSA(ret, dsa);\\r\\nDSA_free(dsa);\\r\\n*in = p;\\r\\nreturn ret;\\r\\nmemerr:\\r\\nPEMerr(PEM_F_B2I_DSS, ERR_R_MALLOC_FAILURE);\\r\\nif (dsa)\\r\\nDSA_free(dsa);\\r\\nif (ret)\\r\\nEVP_PKEY_free(ret);\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,\\r\\nunsigned int bitlen, int ispub)\\r\\n{\\r\\nconst unsigned char *p = *in;\\r\\nEVP_PKEY *ret = NULL;\\r\\nRSA *rsa = NULL;\\r\\nunsigned int nbyte, hnbyte;\\r\\nnbyte = (bitlen + 7) >> 3;\\r\\nhnbyte = (bitlen + 15) >> 4;\\r\\nrsa = RSA_new();\\r\\nret = EVP_PKEY_new();\\r\\nif (!rsa || !ret)\\r\\ngoto memerr;\\r\\nrsa->e = BN_new();\\r\\nif (!rsa->e)\\r\\ngoto memerr;\\r\\nif (!BN_set_word(rsa->e, read_ledword(&p)))\\r\\ngoto memerr;\\r\\nif (!read_lebn(&p, nbyte, &rsa->n))\\r\\ngoto memerr;\\r\\nif (!ispub) {\\r\\nif (!read_lebn(&p, hnbyte, &rsa->p))\\r\\ngoto memerr;\\r\\nif (!read_lebn(&p, hnbyte, &rsa->q))\\r\\ngoto memerr;\\r\\nif (!read_lebn(&p, hnbyte, &rsa->dmp1))\\r\\ngoto memerr;\\r\\nif (!read_lebn(&p, hnbyte, &rsa->dmq1))\\r\\ngoto memerr;\\r\\nif (!read_lebn(&p, hnbyte, &rsa->iqmp))\\r\\ngoto memerr;\\r\\nif (!read_lebn(&p, nbyte, &rsa->d))\\r\\ngoto memerr;\\r\\n}\\r\\nEVP_PKEY_set1_RSA(ret, rsa);\\r\\nRSA_free(rsa);\\r\\n*in = p;\\r\\nreturn ret;\\r\\nmemerr:\\r\\nPEMerr(PEM_F_B2I_RSA, ERR_R_MALLOC_FAILURE);\\r\\nif (rsa)\\r\\nRSA_free(rsa);\\r\\nif (ret)\\r\\nEVP_PKEY_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nEVP_PKEY *b2i_PrivateKey(const unsigned char **in, long length)\\r\\n{\\r\\nreturn do_b2i(in, length, 0);\\r\\n}\\r\\nEVP_PKEY *b2i_PublicKey(const unsigned char **in, long length)\\r\\n{\\r\\nreturn do_b2i(in, length, 1);\\r\\n}\\r\\nEVP_PKEY *b2i_PrivateKey_bio(BIO *in)\\r\\n{\\r\\nreturn do_b2i_bio(in, 0);\\r\\n}\\r\\nEVP_PKEY *b2i_PublicKey_bio(BIO *in)\\r\\n{\\r\\nreturn do_b2i_bio(in, 1);\\r\\n}\\r\\nstatic void write_ledword(unsigned char **out, unsigned int dw)\\r\\n{\\r\\nunsigned char *p = *out;\\r\\n*p++ = dw & 0xff;\\r\\n*p++ = (dw >> 8) & 0xff;\\r\\n*p++ = (dw >> 16) & 0xff;\\r\\n*p++ = (dw >> 24) & 0xff;\\r\\n*out = p;\\r\\n}\\r\\nstatic void write_lebn(unsigned char **out, const BIGNUM *bn, int len)\\r\\n{\\r\\nint nb, i;\\r\\nunsigned char *p = *out, *q, c;\\r\\nnb = BN_num_bytes(bn);\\r\\nBN_bn2bin(bn, p);\\r\\nq = p + nb - 1;\\r\\nfor (i = 0; i < nb / 2; i++) {\\r\\nc = *p;\\r\\n*p++ = *q;\\r\\n*q-- = c;\\r\\n}\\r\\n*out += nb;\\r\\nif (len > 0) {\\r\\nlen -= nb;\\r\\nif (len > 0) {\\r\\nmemset(*out, 0, len);\\r\\n*out += len;\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)\\r\\n{\\r\\nunsigned char *p;\\r\\nunsigned int bitlen, magic = 0, keyalg;\\r\\nint outlen, noinc = 0;\\r\\nif (pk->type == EVP_PKEY_DSA) {\\r\\nbitlen = check_bitlen_dsa(pk->pkey.dsa, ispub, &magic);\\r\\nkeyalg = MS_KEYALG_DSS_SIGN;\\r\\n} else if (pk->type == EVP_PKEY_RSA) {\\r\\nbitlen = check_bitlen_rsa(pk->pkey.rsa, ispub, &magic);\\r\\nkeyalg = MS_KEYALG_RSA_KEYX;\\r\\n} else\\r\\nreturn -1;\\r\\nif (bitlen == 0)\\r\\nreturn -1;\\r\\noutlen = 16 + blob_length(bitlen,\\r\\nkeyalg == MS_KEYALG_DSS_SIGN ? 1 : 0, ispub);\\r\\nif (out == NULL)\\r\\nreturn outlen;\\r\\nif (*out)\\r\\np = *out;\\r\\nelse {\\r\\np = OPENSSL_malloc(outlen);\\r\\nif (!p)\\r\\nreturn -1;\\r\\n*out = p;\\r\\nnoinc = 1;\\r\\n}\\r\\nif (ispub)\\r\\n*p++ = MS_PUBLICKEYBLOB;\\r\\nelse\\r\\n*p++ = MS_PRIVATEKEYBLOB;\\r\\n*p++ = 0x2;\\r\\n*p++ = 0;\\r\\n*p++ = 0;\\r\\nwrite_ledword(&p, keyalg);\\r\\nwrite_ledword(&p, magic);\\r\\nwrite_ledword(&p, bitlen);\\r\\nif (keyalg == MS_KEYALG_DSS_SIGN)\\r\\nwrite_dsa(&p, pk->pkey.dsa, ispub);\\r\\nelse\\r\\nwrite_rsa(&p, pk->pkey.rsa, ispub);\\r\\nif (!noinc)\\r\\n*out += outlen;\\r\\nreturn outlen;\\r\\n}\\r\\nstatic int do_i2b_bio(BIO *out, EVP_PKEY *pk, int ispub)\\r\\n{\\r\\nunsigned char *tmp = NULL;\\r\\nint outlen, wrlen;\\r\\noutlen = do_i2b(&tmp, pk, ispub);\\r\\nif (outlen < 0)\\r\\nreturn -1;\\r\\nwrlen = BIO_write(out, tmp, outlen);\\r\\nOPENSSL_free(tmp);\\r\\nif (wrlen == outlen)\\r\\nreturn outlen;\\r\\nreturn -1;\\r\\n}\\r\\nstatic int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *pmagic)\\r\\n{\\r\\nint bitlen;\\r\\nbitlen = BN_num_bits(dsa->p);\\r\\nif ((bitlen & 7) || (BN_num_bits(dsa->q) != 160)\\r\\n|| (BN_num_bits(dsa->g) > bitlen))\\r\\ngoto badkey;\\r\\nif (ispub) {\\r\\nif (BN_num_bits(dsa->pub_key) > bitlen)\\r\\ngoto badkey;\\r\\n*pmagic = MS_DSS1MAGIC;\\r\\n} else {\\r\\nif (BN_num_bits(dsa->priv_key) > 160)\\r\\ngoto badkey;\\r\\n*pmagic = MS_DSS2MAGIC;\\r\\n}\\r\\nreturn bitlen;\\r\\nbadkey:\\r\\nPEMerr(PEM_F_CHECK_BITLEN_DSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)\\r\\n{\\r\\nint nbyte, hnbyte, bitlen;\\r\\nif (BN_num_bits(rsa->e) > 32)\\r\\ngoto badkey;\\r\\nbitlen = BN_num_bits(rsa->n);\\r\\nnbyte = BN_num_bytes(rsa->n);\\r\\nhnbyte = (BN_num_bits(rsa->n) + 15) >> 4;\\r\\nif (ispub) {\\r\\n*pmagic = MS_RSA1MAGIC;\\r\\nreturn bitlen;\\r\\n} else {\\r\\n*pmagic = MS_RSA2MAGIC;\\r\\nif (BN_num_bytes(rsa->d) > nbyte)\\r\\ngoto badkey;\\r\\nif ((BN_num_bytes(rsa->iqmp) > hnbyte)\\r\\n|| (BN_num_bytes(rsa->p) > hnbyte)\\r\\n|| (BN_num_bytes(rsa->q) > hnbyte)\\r\\n|| (BN_num_bytes(rsa->dmp1) > hnbyte)\\r\\n|| (BN_num_bytes(rsa->dmq1) > hnbyte))\\r\\ngoto badkey;\\r\\n}\\r\\nreturn bitlen;\\r\\nbadkey:\\r\\nPEMerr(PEM_F_CHECK_BITLEN_RSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void write_rsa(unsigned char **out, RSA *rsa, int ispub)\\r\\n{\\r\\nint nbyte, hnbyte;\\r\\nnbyte = BN_num_bytes(rsa->n);\\r\\nhnbyte = (BN_num_bits(rsa->n) + 15) >> 4;\\r\\nwrite_lebn(out, rsa->e, 4);\\r\\nwrite_lebn(out, rsa->n, -1);\\r\\nif (ispub)\\r\\nreturn;\\r\\nwrite_lebn(out, rsa->p, hnbyte);\\r\\nwrite_lebn(out, rsa->q, hnbyte);\\r\\nwrite_lebn(out, rsa->dmp1, hnbyte);\\r\\nwrite_lebn(out, rsa->dmq1, hnbyte);\\r\\nwrite_lebn(out, rsa->iqmp, hnbyte);\\r\\nwrite_lebn(out, rsa->d, nbyte);\\r\\n}\\r\\nstatic void write_dsa(unsigned char **out, DSA *dsa, int ispub)\\r\\n{\\r\\nint nbyte;\\r\\nnbyte = BN_num_bytes(dsa->p);\\r\\nwrite_lebn(out, dsa->p, nbyte);\\r\\nwrite_lebn(out, dsa->q, 20);\\r\\nwrite_lebn(out, dsa->g, nbyte);\\r\\nif (ispub)\\r\\nwrite_lebn(out, dsa->pub_key, nbyte);\\r\\nelse\\r\\nwrite_lebn(out, dsa->priv_key, 20);\\r\\nmemset(*out, 0xff, 24);\\r\\n*out += 24;\\r\\nreturn;\\r\\n}\\r\\nint i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk)\\r\\n{\\r\\nreturn do_i2b_bio(out, pk, 0);\\r\\n}\\r\\nint i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk)\\r\\n{\\r\\nreturn do_i2b_bio(out, pk, 1);\\r\\n}\\r\\nstatic int do_PVK_header(const unsigned char **in, unsigned int length,\\r\\nint skip_magic,\\r\\nunsigned int *psaltlen, unsigned int *pkeylen)\\r\\n{\\r\\nconst unsigned char *p = *in;\\r\\nunsigned int pvk_magic, is_encrypted;\\r\\nif (skip_magic) {\\r\\nif (length < 20) {\\r\\nPEMerr(PEM_F_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);\\r\\nreturn 0;\\r\\n}\\r\\nlength -= 20;\\r\\n} else {\\r\\nif (length < 24) {\\r\\nPEMerr(PEM_F_DO_PVK_HEADER, PEM_R_PVK_TOO_SHORT);\\r\\nreturn 0;\\r\\n}\\r\\nlength -= 24;\\r\\npvk_magic = read_ledword(&p);\\r\\nif (pvk_magic != MS_PVKMAGIC) {\\r\\nPEMerr(PEM_F_DO_PVK_HEADER, PEM_R_BAD_MAGIC_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\np += 4;\\r\\nread_ledword(&p);\\r\\nis_encrypted = read_ledword(&p);\\r\\n*psaltlen = read_ledword(&p);\\r\\n*pkeylen = read_ledword(&p);\\r\\nif (is_encrypted && !*psaltlen) {\\r\\nPEMerr(PEM_F_DO_PVK_HEADER, PEM_R_INCONSISTENT_HEADER);\\r\\nreturn 0;\\r\\n}\\r\\n*in = p;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int derive_pvk_key(unsigned char *key,\\r\\nconst unsigned char *salt, unsigned int saltlen,\\r\\nconst unsigned char *pass, int passlen)\\r\\n{\\r\\nEVP_MD_CTX mctx;\\r\\nint rv = 1;\\r\\nEVP_MD_CTX_init(&mctx);\\r\\nif (!EVP_DigestInit_ex(&mctx, EVP_sha1(), NULL)\\r\\n|| !EVP_DigestUpdate(&mctx, salt, saltlen)\\r\\n|| !EVP_DigestUpdate(&mctx, pass, passlen)\\r\\n|| !EVP_DigestFinal_ex(&mctx, key, NULL))\\r\\nrv = 0;\\r\\nEVP_MD_CTX_cleanup(&mctx);\\r\\nreturn rv;\\r\\n}\\r\\nstatic EVP_PKEY *do_PVK_body(const unsigned char **in,\\r\\nunsigned int saltlen, unsigned int keylen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nEVP_PKEY *ret = NULL;\\r\\nconst unsigned char *p = *in;\\r\\nunsigned int magic;\\r\\nunsigned char *enctmp = NULL, *q;\\r\\nEVP_CIPHER_CTX cctx;\\r\\nEVP_CIPHER_CTX_init(&cctx);\\r\\nif (saltlen) {\\r\\nchar psbuf[PEM_BUFSIZE];\\r\\nunsigned char keybuf[20];\\r\\nint enctmplen, inlen;\\r\\nif (cb)\\r\\ninlen = cb(psbuf, PEM_BUFSIZE, 0, u);\\r\\nelse\\r\\ninlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);\\r\\nif (inlen <= 0) {\\r\\nPEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_PASSWORD_READ);\\r\\nreturn NULL;\\r\\n}\\r\\nenctmp = OPENSSL_malloc(keylen + 8);\\r\\nif (!enctmp) {\\r\\nPEMerr(PEM_F_DO_PVK_BODY, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!derive_pvk_key(keybuf, p, saltlen,\\r\\n(unsigned char *)psbuf, inlen))\\r\\nreturn NULL;\\r\\np += saltlen;\\r\\nmemcpy(enctmp, p, 8);\\r\\np += 8;\\r\\nif (keylen < 8) {\\r\\nPEMerr(PEM_F_DO_PVK_BODY, PEM_R_PVK_TOO_SHORT);\\r\\nreturn NULL;\\r\\n}\\r\\ninlen = keylen - 8;\\r\\nq = enctmp + 8;\\r\\nif (!EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf, NULL))\\r\\ngoto err;\\r\\nif (!EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen))\\r\\ngoto err;\\r\\nif (!EVP_DecryptFinal_ex(&cctx, q + enctmplen, &enctmplen))\\r\\ngoto err;\\r\\nmagic = read_ledword((const unsigned char **)&q);\\r\\nif (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC) {\\r\\nq = enctmp + 8;\\r\\nmemset(keybuf + 5, 0, 11);\\r\\nif (!EVP_DecryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf, NULL))\\r\\ngoto err;\\r\\nOPENSSL_cleanse(keybuf, 20);\\r\\nif (!EVP_DecryptUpdate(&cctx, q, &enctmplen, p, inlen))\\r\\ngoto err;\\r\\nif (!EVP_DecryptFinal_ex(&cctx, q + enctmplen, &enctmplen))\\r\\ngoto err;\\r\\nmagic = read_ledword((const unsigned char **)&q);\\r\\nif (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC) {\\r\\nPEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_DECRYPT);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\nOPENSSL_cleanse(keybuf, 20);\\r\\np = enctmp;\\r\\n}\\r\\nret = b2i_PrivateKey(&p, keylen);\\r\\nerr:\\r\\nEVP_CIPHER_CTX_cleanup(&cctx);\\r\\nif (enctmp && saltlen)\\r\\nOPENSSL_free(enctmp);\\r\\nreturn ret;\\r\\n}\\r\\nEVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u)\\r\\n{\\r\\nunsigned char pvk_hdr[24], *buf = NULL;\\r\\nconst unsigned char *p;\\r\\nint buflen;\\r\\nEVP_PKEY *ret = NULL;\\r\\nunsigned int saltlen, keylen;\\r\\nif (BIO_read(in, pvk_hdr, 24) != 24) {\\r\\nPEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);\\r\\nreturn NULL;\\r\\n}\\r\\np = pvk_hdr;\\r\\nif (!do_PVK_header(&p, 24, 0, &saltlen, &keylen))\\r\\nreturn 0;\\r\\nbuflen = (int)keylen + saltlen;\\r\\nbuf = OPENSSL_malloc(buflen);\\r\\nif (!buf) {\\r\\nPEMerr(PEM_F_B2I_PVK_BIO, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\np = buf;\\r\\nif (BIO_read(in, buf, buflen) != buflen) {\\r\\nPEMerr(PEM_F_B2I_PVK_BIO, PEM_R_PVK_DATA_TOO_SHORT);\\r\\ngoto err;\\r\\n}\\r\\nret = do_PVK_body(&p, saltlen, keylen, cb, u);\\r\\nerr:\\r\\nif (buf) {\\r\\nOPENSSL_cleanse(buf, buflen);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int i2b_PVK(unsigned char **out, EVP_PKEY *pk, int enclevel,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nint outlen = 24, pklen;\\r\\nunsigned char *p, *salt = NULL;\\r\\nEVP_CIPHER_CTX cctx;\\r\\nEVP_CIPHER_CTX_init(&cctx);\\r\\nif (enclevel)\\r\\noutlen += PVK_SALTLEN;\\r\\npklen = do_i2b(NULL, pk, 0);\\r\\nif (pklen < 0)\\r\\nreturn -1;\\r\\noutlen += pklen;\\r\\nif (!out)\\r\\nreturn outlen;\\r\\nif (*out)\\r\\np = *out;\\r\\nelse {\\r\\np = OPENSSL_malloc(outlen);\\r\\nif (!p) {\\r\\nPEMerr(PEM_F_I2B_PVK, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n*out = p;\\r\\n}\\r\\nwrite_ledword(&p, MS_PVKMAGIC);\\r\\nwrite_ledword(&p, 0);\\r\\nif (pk->type == EVP_PKEY_DSA)\\r\\nwrite_ledword(&p, MS_KEYTYPE_SIGN);\\r\\nelse\\r\\nwrite_ledword(&p, MS_KEYTYPE_KEYX);\\r\\nwrite_ledword(&p, enclevel ? 1 : 0);\\r\\nwrite_ledword(&p, enclevel ? PVK_SALTLEN : 0);\\r\\nwrite_ledword(&p, pklen);\\r\\nif (enclevel) {\\r\\nif (RAND_bytes(p, PVK_SALTLEN) <= 0)\\r\\ngoto error;\\r\\nsalt = p;\\r\\np += PVK_SALTLEN;\\r\\n}\\r\\ndo_i2b(&p, pk, 0);\\r\\nif (enclevel == 0)\\r\\nreturn outlen;\\r\\nelse {\\r\\nchar psbuf[PEM_BUFSIZE];\\r\\nunsigned char keybuf[20];\\r\\nint enctmplen, inlen;\\r\\nif (cb)\\r\\ninlen = cb(psbuf, PEM_BUFSIZE, 1, u);\\r\\nelse\\r\\ninlen = PEM_def_callback(psbuf, PEM_BUFSIZE, 1, u);\\r\\nif (inlen <= 0) {\\r\\nPEMerr(PEM_F_I2B_PVK, PEM_R_BAD_PASSWORD_READ);\\r\\ngoto error;\\r\\n}\\r\\nif (!derive_pvk_key(keybuf, salt, PVK_SALTLEN,\\r\\n(unsigned char *)psbuf, inlen))\\r\\ngoto error;\\r\\nif (enclevel == 1)\\r\\nmemset(keybuf + 5, 0, 11);\\r\\np = salt + PVK_SALTLEN + 8;\\r\\nif (!EVP_EncryptInit_ex(&cctx, EVP_rc4(), NULL, keybuf, NULL))\\r\\ngoto error;\\r\\nOPENSSL_cleanse(keybuf, 20);\\r\\nif (!EVP_DecryptUpdate(&cctx, p, &enctmplen, p, pklen - 8))\\r\\ngoto error;\\r\\nif (!EVP_DecryptFinal_ex(&cctx, p + enctmplen, &enctmplen))\\r\\ngoto error;\\r\\n}\\r\\nEVP_CIPHER_CTX_cleanup(&cctx);\\r\\nreturn outlen;\\r\\nerror:\\r\\nEVP_CIPHER_CTX_cleanup(&cctx);\\r\\nreturn -1;\\r\\n}\\r\\nint i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nunsigned char *tmp = NULL;\\r\\nint outlen, wrlen;\\r\\noutlen = i2b_PVK(&tmp, pk, enclevel, cb, u);\\r\\nif (outlen < 0)\\r\\nreturn -1;\\r\\nwrlen = BIO_write(out, tmp, outlen);\\r\\nOPENSSL_free(tmp);\\r\\nif (wrlen == outlen) {\\r\\nPEMerr(PEM_F_I2B_PVK_BIO, PEM_R_BIO_WRITE_FAILURE);\\r\\nreturn outlen;\\r\\n}\\r\\nreturn -1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_s3_cbc_c", "target": 0, "func": "int ssl3_cbc_remove_padding(const SSL *s,\\r\\nSSL3_RECORD *rec,\\r\\nunsigned block_size, unsigned mac_size)\\r\\n{\\r\\nunsigned padding_length, good;\\r\\nconst unsigned overhead = 1 + mac_size;\\r\\nif (overhead > rec->length)\\r\\nreturn 0;\\r\\npadding_length = rec->data[rec->length - 1];\\r\\ngood = constant_time_ge(rec->length, padding_length + overhead);\\r\\ngood &= constant_time_ge(block_size, padding_length + 1);\\r\\npadding_length = good & (padding_length + 1);\\r\\nrec->length -= padding_length;\\r\\nrec->type |= padding_length << 8;\\r\\nreturn constant_time_select_int(good, 1, -1);\\r\\n}\\r\\nint tls1_cbc_remove_padding(const SSL *s,\\r\\nSSL3_RECORD *rec,\\r\\nunsigned block_size, unsigned mac_size)\\r\\n{\\r\\nunsigned padding_length, good, to_check, i;\\r\\nconst unsigned overhead = 1 + mac_size;\\r\\nif (SSL_USE_EXPLICIT_IV(s)) {\\r\\nif (overhead + block_size > rec->length)\\r\\nreturn 0;\\r\\nrec->data += block_size;\\r\\nrec->input += block_size;\\r\\nrec->length -= block_size;\\r\\n} else if (overhead > rec->length)\\r\\nreturn 0;\\r\\npadding_length = rec->data[rec->length - 1];\\r\\nif ((s->options & SSL_OP_TLS_BLOCK_PADDING_BUG) && !s->expand) {\\r\\nif ((memcmp(s->s3->read_sequence, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 8) == 0) &&\\r\\n!(padding_length & 1)) {\\r\\ns->s3->flags |= TLS1_FLAGS_TLS_PADDING_BUG;\\r\\n}\\r\\nif ((s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG) && padding_length > 0) {\\r\\npadding_length--;\\r\\n}\\r\\n}\\r\\nif (EVP_CIPHER_flags(s->enc_read_ctx->cipher) & EVP_CIPH_FLAG_AEAD_CIPHER) {\\r\\nrec->length -= padding_length + 1;\\r\\nreturn 1;\\r\\n}\\r\\ngood = constant_time_ge(rec->length, overhead + padding_length);\\r\\nto_check = 255;\\r\\nif (to_check > rec->length - 1)\\r\\nto_check = rec->length - 1;\\r\\nfor (i = 0; i < to_check; i++) {\\r\\nunsigned char mask = constant_time_ge_8(padding_length, i);\\r\\nunsigned char b = rec->data[rec->length - 1 - i];\\r\\ngood &= ~(mask & (padding_length ^ b));\\r\\n}\\r\\ngood = constant_time_eq(0xff, good & 0xff);\\r\\npadding_length = good & (padding_length + 1);\\r\\nrec->length -= padding_length;\\r\\nrec->type |= padding_length << 8;\\r\\nreturn constant_time_select_int(good, 1, -1);\\r\\n}\\r\\nvoid ssl3_cbc_copy_mac(unsigned char *out,\\r\\nconst SSL3_RECORD *rec,\\r\\nunsigned md_size, unsigned orig_len)\\r\\n{\\r\\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\\r\\nunsigned char rotated_mac_buf[64 + EVP_MAX_MD_SIZE];\\r\\nunsigned char *rotated_mac;\\r\\n#else\\r\\nunsigned char rotated_mac[EVP_MAX_MD_SIZE];\\r\\n#endif\\r\\nunsigned mac_end = rec->length;\\r\\nunsigned mac_start = mac_end - md_size;\\r\\nunsigned scan_start = 0;\\r\\nunsigned i, j;\\r\\nunsigned div_spoiler;\\r\\nunsigned rotate_offset;\\r\\nOPENSSL_assert(orig_len >= md_size);\\r\\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\\r\\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\\r\\nrotated_mac = rotated_mac_buf + ((0 - (size_t)rotated_mac_buf) & 63);\\r\\n#endif\\r\\nif (orig_len > md_size + 255 + 1)\\r\\nscan_start = orig_len - (md_size + 255 + 1);\\r\\ndiv_spoiler = md_size >> 1;\\r\\ndiv_spoiler <<= (sizeof(div_spoiler) - 1) * 8;\\r\\nrotate_offset = (div_spoiler + mac_start - scan_start) % md_size;\\r\\nmemset(rotated_mac, 0, md_size);\\r\\nfor (i = scan_start, j = 0; i < orig_len; i++) {\\r\\nunsigned char mac_started = constant_time_ge_8(i, mac_start);\\r\\nunsigned char mac_ended = constant_time_ge_8(i, mac_end);\\r\\nunsigned char b = rec->data[i];\\r\\nrotated_mac[j++] |= b & mac_started & ~mac_ended;\\r\\nj &= constant_time_lt(j, md_size);\\r\\n}\\r\\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\\r\\nj = 0;\\r\\nfor (i = 0; i < md_size; i++) {\\r\\n((volatile unsigned char *)rotated_mac)[rotate_offset ^ 32];\\r\\nout[j++] = rotated_mac[rotate_offset++];\\r\\nrotate_offset &= constant_time_lt(rotate_offset, md_size);\\r\\n}\\r\\n#else\\r\\nmemset(out, 0, md_size);\\r\\nrotate_offset = md_size - rotate_offset;\\r\\nrotate_offset &= constant_time_lt(rotate_offset, md_size);\\r\\nfor (i = 0; i < md_size; i++) {\\r\\nfor (j = 0; j < md_size; j++)\\r\\nout[j] |= rotated_mac[i] & constant_time_eq_8(j, rotate_offset);\\r\\nrotate_offset++;\\r\\nrotate_offset &= constant_time_lt(rotate_offset, md_size);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nstatic void tls1_md5_final_raw(void *ctx, unsigned char *md_out)\\r\\n{\\r\\nMD5_CTX *md5 = ctx;\\r\\nu32toLE(md5->A, md_out);\\r\\nu32toLE(md5->B, md_out);\\r\\nu32toLE(md5->C, md_out);\\r\\nu32toLE(md5->D, md_out);\\r\\n}\\r\\nstatic void tls1_sha1_final_raw(void *ctx, unsigned char *md_out)\\r\\n{\\r\\nSHA_CTX *sha1 = ctx;\\r\\nl2n(sha1->h0, md_out);\\r\\nl2n(sha1->h1, md_out);\\r\\nl2n(sha1->h2, md_out);\\r\\nl2n(sha1->h3, md_out);\\r\\nl2n(sha1->h4, md_out);\\r\\n}\\r\\nstatic void tls1_sha256_final_raw(void *ctx, unsigned char *md_out)\\r\\n{\\r\\nSHA256_CTX *sha256 = ctx;\\r\\nunsigned i;\\r\\nfor (i = 0; i < 8; i++) {\\r\\nl2n(sha256->h[i], md_out);\\r\\n}\\r\\n}\\r\\nstatic void tls1_sha512_final_raw(void *ctx, unsigned char *md_out)\\r\\n{\\r\\nSHA512_CTX *sha512 = ctx;\\r\\nunsigned i;\\r\\nfor (i = 0; i < 8; i++) {\\r\\nl2n8(sha512->h[i], md_out);\\r\\n}\\r\\n}\\r\\nchar ssl3_cbc_record_digest_supported(const EVP_MD_CTX *ctx)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn 0;\\r\\n#endif\\r\\nswitch (EVP_MD_CTX_type(ctx)) {\\r\\ncase NID_md5:\\r\\ncase NID_sha1:\\r\\n#ifndef OPENSSL_NO_SHA256\\r\\ncase NID_sha224:\\r\\ncase NID_sha256:\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA512\\r\\ncase NID_sha384:\\r\\ncase NID_sha512:\\r\\n#endif\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nvoid ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,\\r\\nunsigned char *md_out,\\r\\nsize_t *md_out_size,\\r\\nconst unsigned char header[13],\\r\\nconst unsigned char *data,\\r\\nsize_t data_plus_mac_size,\\r\\nsize_t data_plus_mac_plus_padding_size,\\r\\nconst unsigned char *mac_secret,\\r\\nunsigned mac_secret_length, char is_sslv3)\\r\\n{\\r\\nunion {\\r\\ndouble align;\\r\\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\\r\\n} md_state;\\r\\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\\r\\nvoid (*md_transform) (void *ctx, const unsigned char *block);\\r\\nunsigned md_size, md_block_size = 64;\\r\\nunsigned sslv3_pad_length = 40, header_length, variance_blocks,\\r\\nlen, max_mac_bytes, num_blocks,\\r\\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\\r\\nunsigned int bits;\\r\\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\\r\\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\\r\\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\\r\\nunsigned char mac_out[EVP_MAX_MD_SIZE];\\r\\nunsigned i, j, md_out_size_u;\\r\\nEVP_MD_CTX md_ctx;\\r\\nunsigned md_length_size = 8;\\r\\nchar length_is_big_endian = 1;\\r\\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\\r\\nswitch (EVP_MD_CTX_type(ctx)) {\\r\\ncase NID_md5:\\r\\nMD5_Init((MD5_CTX *)md_state.c);\\r\\nmd_final_raw = tls1_md5_final_raw;\\r\\nmd_transform =\\r\\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\\r\\nmd_size = 16;\\r\\nsslv3_pad_length = 48;\\r\\nlength_is_big_endian = 0;\\r\\nbreak;\\r\\ncase NID_sha1:\\r\\nSHA1_Init((SHA_CTX *)md_state.c);\\r\\nmd_final_raw = tls1_sha1_final_raw;\\r\\nmd_transform =\\r\\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\\r\\nmd_size = 20;\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_SHA256\\r\\ncase NID_sha224:\\r\\nSHA224_Init((SHA256_CTX *)md_state.c);\\r\\nmd_final_raw = tls1_sha256_final_raw;\\r\\nmd_transform =\\r\\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\\r\\nmd_size = 224 / 8;\\r\\nbreak;\\r\\ncase NID_sha256:\\r\\nSHA256_Init((SHA256_CTX *)md_state.c);\\r\\nmd_final_raw = tls1_sha256_final_raw;\\r\\nmd_transform =\\r\\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\\r\\nmd_size = 32;\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA512\\r\\ncase NID_sha384:\\r\\nSHA384_Init((SHA512_CTX *)md_state.c);\\r\\nmd_final_raw = tls1_sha512_final_raw;\\r\\nmd_transform =\\r\\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\\r\\nmd_size = 384 / 8;\\r\\nmd_block_size = 128;\\r\\nmd_length_size = 16;\\r\\nbreak;\\r\\ncase NID_sha512:\\r\\nSHA512_Init((SHA512_CTX *)md_state.c);\\r\\nmd_final_raw = tls1_sha512_final_raw;\\r\\nmd_transform =\\r\\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\\r\\nmd_size = 64;\\r\\nmd_block_size = 128;\\r\\nmd_length_size = 16;\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nOPENSSL_assert(0);\\r\\nif (md_out_size)\\r\\n*md_out_size = -1;\\r\\nreturn;\\r\\n}\\r\\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\\r\\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\\r\\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\\r\\nheader_length = 13;\\r\\nif (is_sslv3) {\\r\\nheader_length = mac_secret_length + sslv3_pad_length + 8 +\\r\\n1 +\\r\\n2 ;\\r\\n}\\r\\nvariance_blocks = is_sslv3 ? 2 : 6;\\r\\nlen = data_plus_mac_plus_padding_size + header_length;\\r\\nmax_mac_bytes = len - md_size - 1;\\r\\nnum_blocks =\\r\\n(max_mac_bytes + 1 + md_length_size + md_block_size -\\r\\n1) / md_block_size;\\r\\nnum_starting_blocks = 0;\\r\\nk = 0;\\r\\nmac_end_offset = data_plus_mac_size + header_length - md_size;\\r\\nc = mac_end_offset % md_block_size;\\r\\nindex_a = mac_end_offset / md_block_size;\\r\\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\\r\\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\\r\\nnum_starting_blocks = num_blocks - variance_blocks;\\r\\nk = md_block_size * num_starting_blocks;\\r\\n}\\r\\nbits = 8 * mac_end_offset;\\r\\nif (!is_sslv3) {\\r\\nbits += 8 * md_block_size;\\r\\nmemset(hmac_pad, 0, md_block_size);\\r\\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\\r\\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\\r\\nfor (i = 0; i < md_block_size; i++)\\r\\nhmac_pad[i] ^= 0x36;\\r\\nmd_transform(md_state.c, hmac_pad);\\r\\n}\\r\\nif (length_is_big_endian) {\\r\\nmemset(length_bytes, 0, md_length_size - 4);\\r\\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\\r\\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\\r\\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\\r\\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\\r\\n} else {\\r\\nmemset(length_bytes, 0, md_length_size);\\r\\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\\r\\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\\r\\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\\r\\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\\r\\n}\\r\\nif (k > 0) {\\r\\nif (is_sslv3) {\\r\\nunsigned overhang = header_length - md_block_size;\\r\\nmd_transform(md_state.c, header);\\r\\nmemcpy(first_block, header + md_block_size, overhang);\\r\\nmemcpy(first_block + overhang, data, md_block_size - overhang);\\r\\nmd_transform(md_state.c, first_block);\\r\\nfor (i = 1; i < k / md_block_size - 1; i++)\\r\\nmd_transform(md_state.c, data + md_block_size * i - overhang);\\r\\n} else {\\r\\nmemcpy(first_block, header, 13);\\r\\nmemcpy(first_block + 13, data, md_block_size - 13);\\r\\nmd_transform(md_state.c, first_block);\\r\\nfor (i = 1; i < k / md_block_size; i++)\\r\\nmd_transform(md_state.c, data + md_block_size * i - 13);\\r\\n}\\r\\n}\\r\\nmemset(mac_out, 0, sizeof(mac_out));\\r\\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\\r\\ni++) {\\r\\nunsigned char block[MAX_HASH_BLOCK_SIZE];\\r\\nunsigned char is_block_a = constant_time_eq_8(i, index_a);\\r\\nunsigned char is_block_b = constant_time_eq_8(i, index_b);\\r\\nfor (j = 0; j < md_block_size; j++) {\\r\\nunsigned char b = 0, is_past_c, is_past_cp1;\\r\\nif (k < header_length)\\r\\nb = header[k];\\r\\nelse if (k < data_plus_mac_plus_padding_size + header_length)\\r\\nb = data[k - header_length];\\r\\nk++;\\r\\nis_past_c = is_block_a & constant_time_ge_8(j, c);\\r\\nis_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);\\r\\nb = constant_time_select_8(is_past_c, 0x80, b);\\r\\nb = b & ~is_past_cp1;\\r\\nb &= ~is_block_b | is_block_a;\\r\\nif (j >= md_block_size - md_length_size) {\\r\\nb = constant_time_select_8(is_block_b,\\r\\nlength_bytes[j -\\r\\n(md_block_size -\\r\\nmd_length_size)], b);\\r\\n}\\r\\nblock[j] = b;\\r\\n}\\r\\nmd_transform(md_state.c, block);\\r\\nmd_final_raw(md_state.c, block);\\r\\nfor (j = 0; j < md_size; j++)\\r\\nmac_out[j] |= block[j] & is_block_b;\\r\\n}\\r\\nEVP_MD_CTX_init(&md_ctx);\\r\\nEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL );\\r\\nif (is_sslv3) {\\r\\nmemset(hmac_pad, 0x5c, sslv3_pad_length);\\r\\nEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length);\\r\\nEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length);\\r\\nEVP_DigestUpdate(&md_ctx, mac_out, md_size);\\r\\n} else {\\r\\nfor (i = 0; i < md_block_size; i++)\\r\\nhmac_pad[i] ^= 0x6a;\\r\\nEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size);\\r\\nEVP_DigestUpdate(&md_ctx, mac_out, md_size);\\r\\n}\\r\\nEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u);\\r\\nif (md_out_size)\\r\\n*md_out_size = md_out_size_u;\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\n}\\r\\nvoid tls_fips_digest_extra(const EVP_CIPHER_CTX *cipher_ctx,\\r\\nEVP_MD_CTX *mac_ctx, const unsigned char *data,\\r\\nsize_t data_len, size_t orig_len)\\r\\n{\\r\\nsize_t block_size, digest_pad, blocks_data, blocks_orig;\\r\\nif (EVP_CIPHER_CTX_mode(cipher_ctx) != EVP_CIPH_CBC_MODE)\\r\\nreturn;\\r\\nblock_size = EVP_MD_CTX_block_size(mac_ctx);\\r\\ndigest_pad = block_size == 64 ? 21 : 29;\\r\\nblocks_orig = (orig_len + digest_pad) / block_size;\\r\\nblocks_data = (data_len + digest_pad) / block_size;\\r\\nEVP_DigestSignUpdate(mac_ctx, data,\\r\\n(blocks_orig - blocks_data + 1) * block_size);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_kron_c", "target": 0, "func": "int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint i;\\r\\nint ret = -2;\\r\\nint err = 0;\\r\\nBIGNUM *A, *B, *tmp;\\r\\nstatic const int tab[8] = { 0, 1, 0, -1, 0, -1, 0, 1 };\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nBN_CTX_start(ctx);\\r\\nA = BN_CTX_get(ctx);\\r\\nB = BN_CTX_get(ctx);\\r\\nif (B == NULL)\\r\\ngoto end;\\r\\nerr = !BN_copy(A, a);\\r\\nif (err)\\r\\ngoto end;\\r\\nerr = !BN_copy(B, b);\\r\\nif (err)\\r\\ngoto end;\\r\\nif (BN_is_zero(B)) {\\r\\nret = BN_abs_is_word(A, 1);\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_is_odd(A) && !BN_is_odd(B)) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\ni = 0;\\r\\nwhile (!BN_is_bit_set(B, i))\\r\\ni++;\\r\\nerr = !BN_rshift(B, B, i);\\r\\nif (err)\\r\\ngoto end;\\r\\nif (i & 1) {\\r\\nret = tab[BN_lsw(A) & 7];\\r\\n} else {\\r\\nret = 1;\\r\\n}\\r\\nif (B->neg) {\\r\\nB->neg = 0;\\r\\nif (A->neg)\\r\\nret = -ret;\\r\\n}\\r\\nwhile (1) {\\r\\nif (BN_is_zero(A)) {\\r\\nret = BN_is_one(B) ? ret : 0;\\r\\ngoto end;\\r\\n}\\r\\ni = 0;\\r\\nwhile (!BN_is_bit_set(A, i))\\r\\ni++;\\r\\nerr = !BN_rshift(A, A, i);\\r\\nif (err)\\r\\ngoto end;\\r\\nif (i & 1) {\\r\\nret = ret * tab[BN_lsw(B) & 7];\\r\\n}\\r\\nif ((A->neg ? ~BN_lsw(A) : BN_lsw(A)) & BN_lsw(B) & 2)\\r\\nret = -ret;\\r\\nerr = !BN_nnmod(B, B, A, ctx);\\r\\nif (err)\\r\\ngoto end;\\r\\ntmp = A;\\r\\nA = B;\\r\\nB = tmp;\\r\\ntmp->neg = 0;\\r\\n}\\r\\nend:\\r\\nBN_CTX_end(ctx);\\r\\nif (err)\\r\\nreturn -2;\\r\\nelse\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_lib_c", "target": 0, "func": "ENGINE *ENGINE_new(void)\\r\\n{\\r\\nENGINE *ret;\\r\\nret = (ENGINE *)OPENSSL_malloc(sizeof(ENGINE));\\r\\nif (ret == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(ret, 0, sizeof(ENGINE));\\r\\nret->struct_ref = 1;\\r\\nengine_ref_debug(ret, 0, 1)\\r\\nCRYPTO_new_ex_data(CRYPTO_EX_INDEX_ENGINE, ret, &ret->ex_data);\\r\\nreturn ret;\\r\\n}\\r\\nvoid engine_set_all_null(ENGINE *e)\\r\\n{\\r\\ne->id = NULL;\\r\\ne->name = NULL;\\r\\ne->rsa_meth = NULL;\\r\\ne->dsa_meth = NULL;\\r\\ne->dh_meth = NULL;\\r\\ne->rand_meth = NULL;\\r\\ne->store_meth = NULL;\\r\\ne->ciphers = NULL;\\r\\ne->digests = NULL;\\r\\ne->destroy = NULL;\\r\\ne->init = NULL;\\r\\ne->finish = NULL;\\r\\ne->ctrl = NULL;\\r\\ne->load_privkey = NULL;\\r\\ne->load_pubkey = NULL;\\r\\ne->cmd_defns = NULL;\\r\\ne->flags = 0;\\r\\n}\\r\\nint engine_free_util(ENGINE *e, int locked)\\r\\n{\\r\\nint i;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_FREE_UTIL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (locked)\\r\\ni = CRYPTO_add(&e->struct_ref, -1, CRYPTO_LOCK_ENGINE);\\r\\nelse\\r\\ni = --e->struct_ref;\\r\\nengine_ref_debug(e, 0, -1)\\r\\nif (i > 0)\\r\\nreturn 1;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"ENGINE_free, bad structural reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nengine_pkey_meths_free(e);\\r\\nengine_pkey_asn1_meths_free(e);\\r\\nif (e->destroy)\\r\\ne->destroy(e);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_ENGINE, e, &e->ex_data);\\r\\nOPENSSL_free(e);\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_free(ENGINE *e)\\r\\n{\\r\\nreturn engine_free_util(e, 1);\\r\\n}\\r\\nstatic int int_cleanup_check(int create)\\r\\n{\\r\\nif (cleanup_stack)\\r\\nreturn 1;\\r\\nif (!create)\\r\\nreturn 0;\\r\\ncleanup_stack = sk_ENGINE_CLEANUP_ITEM_new_null();\\r\\nreturn (cleanup_stack ? 1 : 0);\\r\\n}\\r\\nstatic ENGINE_CLEANUP_ITEM *int_cleanup_item(ENGINE_CLEANUP_CB *cb)\\r\\n{\\r\\nENGINE_CLEANUP_ITEM *item = OPENSSL_malloc(sizeof(ENGINE_CLEANUP_ITEM));\\r\\nif (!item)\\r\\nreturn NULL;\\r\\nitem->cb = cb;\\r\\nreturn item;\\r\\n}\\r\\nvoid engine_cleanup_add_first(ENGINE_CLEANUP_CB *cb)\\r\\n{\\r\\nENGINE_CLEANUP_ITEM *item;\\r\\nif (!int_cleanup_check(1))\\r\\nreturn;\\r\\nitem = int_cleanup_item(cb);\\r\\nif (item)\\r\\nsk_ENGINE_CLEANUP_ITEM_insert(cleanup_stack, item, 0);\\r\\n}\\r\\nvoid engine_cleanup_add_last(ENGINE_CLEANUP_CB *cb)\\r\\n{\\r\\nENGINE_CLEANUP_ITEM *item;\\r\\nif (!int_cleanup_check(1))\\r\\nreturn;\\r\\nitem = int_cleanup_item(cb);\\r\\nif (item)\\r\\nsk_ENGINE_CLEANUP_ITEM_push(cleanup_stack, item);\\r\\n}\\r\\nstatic void engine_cleanup_cb_free(ENGINE_CLEANUP_ITEM *item)\\r\\n{\\r\\n(*(item->cb)) ();\\r\\nOPENSSL_free(item);\\r\\n}\\r\\nvoid ENGINE_cleanup(void)\\r\\n{\\r\\nif (int_cleanup_check(0)) {\\r\\nsk_ENGINE_CLEANUP_ITEM_pop_free(cleanup_stack,\\r\\nengine_cleanup_cb_free);\\r\\ncleanup_stack = NULL;\\r\\n}\\r\\nRAND_set_rand_method(NULL);\\r\\n}\\r\\nint ENGINE_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,\\r\\nCRYPTO_EX_dup *dup_func,\\r\\nCRYPTO_EX_free *free_func)\\r\\n{\\r\\nreturn CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_ENGINE, argl, argp,\\r\\nnew_func, dup_func, free_func);\\r\\n}\\r\\nint ENGINE_set_ex_data(ENGINE *e, int idx, void *arg)\\r\\n{\\r\\nreturn (CRYPTO_set_ex_data(&e->ex_data, idx, arg));\\r\\n}\\r\\nvoid *ENGINE_get_ex_data(const ENGINE *e, int idx)\\r\\n{\\r\\nreturn (CRYPTO_get_ex_data(&e->ex_data, idx));\\r\\n}\\r\\nint ENGINE_set_id(ENGINE *e, const char *id)\\r\\n{\\r\\nif (id == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_SET_ID, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\ne->id = id;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_name(ENGINE *e, const char *name)\\r\\n{\\r\\nif (name == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_SET_NAME, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\ne->name = name;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f)\\r\\n{\\r\\ne->destroy = destroy_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f)\\r\\n{\\r\\ne->init = init_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f)\\r\\n{\\r\\ne->finish = finish_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f)\\r\\n{\\r\\ne->ctrl = ctrl_f;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_flags(ENGINE *e, int flags)\\r\\n{\\r\\ne->flags = flags;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns)\\r\\n{\\r\\ne->cmd_defns = defns;\\r\\nreturn 1;\\r\\n}\\r\\nconst char *ENGINE_get_id(const ENGINE *e)\\r\\n{\\r\\nreturn e->id;\\r\\n}\\r\\nconst char *ENGINE_get_name(const ENGINE *e)\\r\\n{\\r\\nreturn e->name;\\r\\n}\\r\\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->destroy;\\r\\n}\\r\\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->init;\\r\\n}\\r\\nENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->finish;\\r\\n}\\r\\nENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)\\r\\n{\\r\\nreturn e->ctrl;\\r\\n}\\r\\nint ENGINE_get_flags(const ENGINE *e)\\r\\n{\\r\\nreturn e->flags;\\r\\n}\\r\\nconst ENGINE_CMD_DEFN *ENGINE_get_cmd_defns(const ENGINE *e)\\r\\n{\\r\\nreturn e->cmd_defns;\\r\\n}\\r\\nvoid *ENGINE_get_static_state(void)\\r\\n{\\r\\nreturn &internal_static_hack;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint ret = 1;\\r\\nX509_REQ *req = NULL;\\r\\nX509 *x = NULL, *xca = NULL;\\r\\nASN1_OBJECT *objtmp;\\r\\nSTACK_OF(OPENSSL_STRING) *sigopts = NULL;\\r\\nEVP_PKEY *Upkey = NULL, *CApkey = NULL, *fkey = NULL;\\r\\nASN1_INTEGER *sno = NULL;\\r\\nint i, num, badops = 0, badsig = 0;\\r\\nBIO *out = NULL;\\r\\nBIO *STDout = NULL;\\r\\nSTACK_OF(ASN1_OBJECT) *trust = NULL, *reject = NULL;\\r\\nint informat, outformat, keyformat, CAformat, CAkeyformat;\\r\\nchar *infile = NULL, *outfile = NULL, *keyfile = NULL, *CAfile = NULL;\\r\\nchar *CAkeyfile = NULL, *CAserial = NULL;\\r\\nchar *fkeyfile = NULL;\\r\\nchar *alias = NULL;\\r\\nint text = 0, serial = 0, subject = 0, issuer = 0, startdate =\\r\\n0, enddate = 0;\\r\\nint next_serial = 0;\\r\\nint subject_hash = 0, issuer_hash = 0, ocspid = 0;\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nint subject_hash_old = 0, issuer_hash_old = 0;\\r\\n#endif\\r\\nint noout = 0, sign_flag = 0, CA_flag = 0, CA_createserial = 0, email = 0;\\r\\nint ocsp_uri = 0;\\r\\nint trustout = 0, clrtrust = 0, clrreject = 0, aliasout = 0, clrext = 0;\\r\\nint C = 0;\\r\\nint x509req = 0, days = DEF_DAYS, modulus = 0, pubkey = 0;\\r\\nint pprint = 0;\\r\\nconst char **pp;\\r\\nX509_STORE *ctx = NULL;\\r\\nX509_REQ *rq = NULL;\\r\\nint fingerprint = 0;\\r\\nchar buf[256];\\r\\nconst EVP_MD *md_alg, *digest = NULL;\\r\\nCONF *extconf = NULL;\\r\\nchar *extsect = NULL, *extfile = NULL, *passin = NULL, *passargin = NULL;\\r\\nint need_rand = 0;\\r\\nint checkend = 0, checkoffset = 0;\\r\\nunsigned long nmflag = 0, certflag = 0;\\r\\nchar *checkhost = NULL;\\r\\nchar *checkemail = NULL;\\r\\nchar *checkip = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nreqfile = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nSTDout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nSTDout = BIO_push(tmpbio, STDout);\\r\\n}\\r\\n#endif\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nkeyformat = FORMAT_PEM;\\r\\nCAformat = FORMAT_PEM;\\r\\nCAkeyformat = FORMAT_PEM;\\r\\nctx = X509_STORE_new();\\r\\nif (ctx == NULL)\\r\\ngoto end;\\r\\nX509_STORE_set_verify_cb(ctx, callb);\\r\\nargc--;\\r\\nargv++;\\r\\nnum = 0;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-keyform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-req\") == 0) {\\r\\nreqfile = 1;\\r\\nneed_rand = 1;\\r\\n} else if (strcmp(*argv, \"-CAform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCAformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-CAkeyform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCAkeyformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-sigopt\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!sigopts)\\r\\nsigopts = sk_OPENSSL_STRING_new_null();\\r\\nif (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))\\r\\ngoto bad;\\r\\n}\\r\\n#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\\r\\nelse if (strcmp(*argv, \"-force_version\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nforce_version = atoi(*(++argv)) - 1;\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-days\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ndays = atoi(*(++argv));\\r\\nif (days == 0) {\\r\\nBIO_printf(bio_err, \"bad number of days\\n\");\\r\\ngoto bad;\\r\\n}\\r\\n} else if (strcmp(*argv, \"-passin\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-extfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nextfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-extensions\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nextsect = *(++argv);\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-signkey\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyfile = *(++argv);\\r\\nsign_flag = ++num;\\r\\nneed_rand = 1;\\r\\n} else if (strcmp(*argv, \"-CA\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCAfile = *(++argv);\\r\\nCA_flag = ++num;\\r\\nneed_rand = 1;\\r\\n} else if (strcmp(*argv, \"-CAkey\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCAkeyfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-CAserial\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCAserial = *(++argv);\\r\\n} else if (strcmp(*argv, \"-set_serial\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!(sno = s2i_ASN1_INTEGER(NULL, *(++argv))))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-force_pubkey\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nfkeyfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-addtrust\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!(objtmp = OBJ_txt2obj(*(++argv), 0))) {\\r\\nBIO_printf(bio_err, \"Invalid trust object value %s\\n\", *argv);\\r\\ngoto bad;\\r\\n}\\r\\nif (!trust)\\r\\ntrust = sk_ASN1_OBJECT_new_null();\\r\\nsk_ASN1_OBJECT_push(trust, objtmp);\\r\\ntrustout = 1;\\r\\n} else if (strcmp(*argv, \"-addreject\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!(objtmp = OBJ_txt2obj(*(++argv), 0))) {\\r\\nBIO_printf(bio_err,\\r\\n\"Invalid reject object value %s\\n\", *argv);\\r\\ngoto bad;\\r\\n}\\r\\nif (!reject)\\r\\nreject = sk_ASN1_OBJECT_new_null();\\r\\nsk_ASN1_OBJECT_push(reject, objtmp);\\r\\ntrustout = 1;\\r\\n} else if (strcmp(*argv, \"-setalias\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nalias = *(++argv);\\r\\ntrustout = 1;\\r\\n} else if (strcmp(*argv, \"-certopt\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!set_cert_ex(&certflag, *(++argv)))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-nameopt\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!set_name_ex(&nmflag, *(++argv)))\\r\\ngoto bad;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-C\") == 0)\\r\\nC = ++num;\\r\\nelse if (strcmp(*argv, \"-email\") == 0)\\r\\nemail = ++num;\\r\\nelse if (strcmp(*argv, \"-ocsp_uri\") == 0)\\r\\nocsp_uri = ++num;\\r\\nelse if (strcmp(*argv, \"-serial\") == 0)\\r\\nserial = ++num;\\r\\nelse if (strcmp(*argv, \"-next_serial\") == 0)\\r\\nnext_serial = ++num;\\r\\nelse if (strcmp(*argv, \"-modulus\") == 0)\\r\\nmodulus = ++num;\\r\\nelse if (strcmp(*argv, \"-pubkey\") == 0)\\r\\npubkey = ++num;\\r\\nelse if (strcmp(*argv, \"-x509toreq\") == 0)\\r\\nx509req = ++num;\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = ++num;\\r\\nelse if (strcmp(*argv, \"-hash\") == 0\\r\\n|| strcmp(*argv, \"-subject_hash\") == 0)\\r\\nsubject_hash = ++num;\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nelse if (strcmp(*argv, \"-subject_hash_old\") == 0)\\r\\nsubject_hash_old = ++num;\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-issuer_hash\") == 0)\\r\\nissuer_hash = ++num;\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nelse if (strcmp(*argv, \"-issuer_hash_old\") == 0)\\r\\nissuer_hash_old = ++num;\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-subject\") == 0)\\r\\nsubject = ++num;\\r\\nelse if (strcmp(*argv, \"-issuer\") == 0)\\r\\nissuer = ++num;\\r\\nelse if (strcmp(*argv, \"-fingerprint\") == 0)\\r\\nfingerprint = ++num;\\r\\nelse if (strcmp(*argv, \"-dates\") == 0) {\\r\\nstartdate = ++num;\\r\\nenddate = ++num;\\r\\n} else if (strcmp(*argv, \"-purpose\") == 0)\\r\\npprint = ++num;\\r\\nelse if (strcmp(*argv, \"-startdate\") == 0)\\r\\nstartdate = ++num;\\r\\nelse if (strcmp(*argv, \"-enddate\") == 0)\\r\\nenddate = ++num;\\r\\nelse if (strcmp(*argv, \"-checkend\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncheckoffset = atoi(*(++argv));\\r\\ncheckend = 1;\\r\\n} else if (strcmp(*argv, \"-checkhost\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncheckhost = *(++argv);\\r\\n} else if (strcmp(*argv, \"-checkemail\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncheckemail = *(++argv);\\r\\n} else if (strcmp(*argv, \"-checkip\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncheckip = *(++argv);\\r\\n} else if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = ++num;\\r\\nelse if (strcmp(*argv, \"-trustout\") == 0)\\r\\ntrustout = 1;\\r\\nelse if (strcmp(*argv, \"-clrtrust\") == 0)\\r\\nclrtrust = ++num;\\r\\nelse if (strcmp(*argv, \"-clrreject\") == 0)\\r\\nclrreject = ++num;\\r\\nelse if (strcmp(*argv, \"-alias\") == 0)\\r\\naliasout = ++num;\\r\\nelse if (strcmp(*argv, \"-CAcreateserial\") == 0)\\r\\nCA_createserial = ++num;\\r\\nelse if (strcmp(*argv, \"-clrext\") == 0)\\r\\nclrext = 1;\\r\\n#if 1\\r\\nelse if (strcmp(*argv, \"-crlext\") == 0) {\\r\\nBIO_printf(bio_err, \"use -clrext instead of -crlext\\n\");\\r\\nclrext = 1;\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-ocspid\") == 0)\\r\\nocspid = ++num;\\r\\nelse if (strcmp(*argv, \"-badsig\") == 0)\\r\\nbadsig = 1;\\r\\nelse if ((md_alg = EVP_get_digestbyname(*argv + 1))) {\\r\\ndigest = md_alg;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nfor (pp = x509_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err, \"%s\", *pp);\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (need_rand)\\r\\napp_RAND_load_file(NULL, bio_err, 0);\\r\\nERR_load_crypto_strings();\\r\\nif (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!X509_STORE_set_default_paths(ctx)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (fkeyfile) {\\r\\nfkey = load_pubkey(bio_err, fkeyfile, keyformat, 0,\\r\\nNULL, e, \"Forced key\");\\r\\nif (fkey == NULL)\\r\\ngoto end;\\r\\n}\\r\\nif ((CAkeyfile == NULL) && (CA_flag) && (CAformat == FORMAT_PEM)) {\\r\\nCAkeyfile = CAfile;\\r\\n} else if ((CA_flag) && (CAkeyfile == NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"need to specify a CAkey if using the CA command\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (extfile) {\\r\\nlong errorline = -1;\\r\\nX509V3_CTX ctx2;\\r\\nextconf = NCONF_new(NULL);\\r\\nif (!NCONF_load(extconf, extfile, &errorline)) {\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err,\\r\\n\"error loading the config file '%s'\\n\", extfile);\\r\\nelse\\r\\nBIO_printf(bio_err,\\r\\n\"error on line %ld of config file '%s'\\n\",\\r\\nerrorline, extfile);\\r\\ngoto end;\\r\\n}\\r\\nif (!extsect) {\\r\\nextsect = NCONF_get_string(extconf, \"default\", \"extensions\");\\r\\nif (!extsect) {\\r\\nERR_clear_error();\\r\\nextsect = \"default\";\\r\\n}\\r\\n}\\r\\nX509V3_set_ctx_test(&ctx2);\\r\\nX509V3_set_nconf(&ctx2, extconf);\\r\\nif (!X509V3_EXT_add_nconf(extconf, &ctx2, extsect, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\", extsect);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (reqfile) {\\r\\nEVP_PKEY *pkey;\\r\\nBIO *in;\\r\\nif (!sign_flag && !CA_flag) {\\r\\nBIO_printf(bio_err, \"We need a private key to sign with\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin = BIO_new(BIO_s_file());\\r\\nif (in == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\nBIO_free(in);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nreq = PEM_read_bio_X509_REQ(in, NULL, NULL, NULL);\\r\\nBIO_free(in);\\r\\nif (req == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif ((req->req_info == NULL) ||\\r\\n(req->req_info->pubkey == NULL) ||\\r\\n(req->req_info->pubkey->public_key == NULL) ||\\r\\n(req->req_info->pubkey->public_key->data == NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"The certificate request appears to corrupted\\n\");\\r\\nBIO_printf(bio_err, \"It does not contain a public key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((pkey = X509_REQ_get_pubkey(req)) == NULL) {\\r\\nBIO_printf(bio_err, \"error unpacking public key\\n\");\\r\\ngoto end;\\r\\n}\\r\\ni = X509_REQ_verify(req, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (i < 0) {\\r\\nBIO_printf(bio_err, \"Signature verification error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (i == 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"Signature did not match the certificate request\\n\");\\r\\ngoto end;\\r\\n} else\\r\\nBIO_printf(bio_err, \"Signature ok\\n\");\\r\\nprint_name(bio_err, \"subject=\", X509_REQ_get_subject_name(req),\\r\\nnmflag);\\r\\nif ((x = X509_new()) == NULL)\\r\\ngoto end;\\r\\nif (sno == NULL) {\\r\\nsno = ASN1_INTEGER_new();\\r\\nif (!sno || !rand_serial(NULL, sno))\\r\\ngoto end;\\r\\nif (!X509_set_serialNumber(x, sno))\\r\\ngoto end;\\r\\nASN1_INTEGER_free(sno);\\r\\nsno = NULL;\\r\\n} else if (!X509_set_serialNumber(x, sno))\\r\\ngoto end;\\r\\nif (!X509_set_issuer_name(x, req->req_info->subject))\\r\\ngoto end;\\r\\nif (!X509_set_subject_name(x, req->req_info->subject))\\r\\ngoto end;\\r\\nX509_gmtime_adj(X509_get_notBefore(x), 0);\\r\\nX509_time_adj_ex(X509_get_notAfter(x), days, 0, NULL);\\r\\nif (fkey)\\r\\nX509_set_pubkey(x, fkey);\\r\\nelse {\\r\\npkey = X509_REQ_get_pubkey(req);\\r\\nX509_set_pubkey(x, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\n} else\\r\\nx = load_cert(bio_err, infile, informat, NULL, e, \"Certificate\");\\r\\nif (x == NULL)\\r\\ngoto end;\\r\\nif (CA_flag) {\\r\\nxca = load_cert(bio_err, CAfile, CAformat, NULL, e, \"CA Certificate\");\\r\\nif (xca == NULL)\\r\\ngoto end;\\r\\n}\\r\\nif (!noout || text || next_serial) {\\r\\nOBJ_create(\"2.99999.3\", \"SET.ex3\", \"SET x509v3 extension 3\");\\r\\nout = BIO_new(BIO_s_file());\\r\\nif (out == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (alias)\\r\\nX509_alias_set1(x, (unsigned char *)alias, -1);\\r\\nif (clrtrust)\\r\\nX509_trust_clear(x);\\r\\nif (clrreject)\\r\\nX509_reject_clear(x);\\r\\nif (trust) {\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(trust); i++) {\\r\\nobjtmp = sk_ASN1_OBJECT_value(trust, i);\\r\\nX509_add1_trust_object(x, objtmp);\\r\\n}\\r\\n}\\r\\nif (reject) {\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(reject); i++) {\\r\\nobjtmp = sk_ASN1_OBJECT_value(reject, i);\\r\\nX509_add1_reject_object(x, objtmp);\\r\\n}\\r\\n}\\r\\nif (num) {\\r\\nfor (i = 1; i <= num; i++) {\\r\\nif (issuer == i) {\\r\\nprint_name(STDout, \"issuer= \",\\r\\nX509_get_issuer_name(x), nmflag);\\r\\n} else if (subject == i) {\\r\\nprint_name(STDout, \"subject= \",\\r\\nX509_get_subject_name(x), nmflag);\\r\\n} else if (serial == i) {\\r\\nBIO_printf(STDout, \"serial=\");\\r\\ni2a_ASN1_INTEGER(STDout, X509_get_serialNumber(x));\\r\\nBIO_printf(STDout, \"\\n\");\\r\\n} else if (next_serial == i) {\\r\\nBIGNUM *bnser;\\r\\nASN1_INTEGER *ser;\\r\\nser = X509_get_serialNumber(x);\\r\\nbnser = ASN1_INTEGER_to_BN(ser, NULL);\\r\\nif (!bnser)\\r\\ngoto end;\\r\\nif (!BN_add_word(bnser, 1))\\r\\ngoto end;\\r\\nser = BN_to_ASN1_INTEGER(bnser, NULL);\\r\\nif (!ser)\\r\\ngoto end;\\r\\nBN_free(bnser);\\r\\ni2a_ASN1_INTEGER(out, ser);\\r\\nASN1_INTEGER_free(ser);\\r\\nBIO_puts(out, \"\\n\");\\r\\n} else if ((email == i) || (ocsp_uri == i)) {\\r\\nint j;\\r\\nSTACK_OF(OPENSSL_STRING) *emlst;\\r\\nif (email == i)\\r\\nemlst = X509_get1_email(x);\\r\\nelse\\r\\nemlst = X509_get1_ocsp(x);\\r\\nfor (j = 0; j < sk_OPENSSL_STRING_num(emlst); j++)\\r\\nBIO_printf(STDout, \"%s\\n\",\\r\\nsk_OPENSSL_STRING_value(emlst, j));\\r\\nX509_email_free(emlst);\\r\\n} else if (aliasout == i) {\\r\\nunsigned char *alstr;\\r\\nalstr = X509_alias_get0(x, NULL);\\r\\nif (alstr)\\r\\nBIO_printf(STDout, \"%s\\n\", alstr);\\r\\nelse\\r\\nBIO_puts(STDout, \"<No Alias>\\n\");\\r\\n} else if (subject_hash == i) {\\r\\nBIO_printf(STDout, \"%08lx\\n\", X509_subject_name_hash(x));\\r\\n}\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nelse if (subject_hash_old == i) {\\r\\nBIO_printf(STDout, \"%08lx\\n\", X509_subject_name_hash_old(x));\\r\\n}\\r\\n#endif\\r\\nelse if (issuer_hash == i) {\\r\\nBIO_printf(STDout, \"%08lx\\n\", X509_issuer_name_hash(x));\\r\\n}\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nelse if (issuer_hash_old == i) {\\r\\nBIO_printf(STDout, \"%08lx\\n\", X509_issuer_name_hash_old(x));\\r\\n}\\r\\n#endif\\r\\nelse if (pprint == i) {\\r\\nX509_PURPOSE *ptmp;\\r\\nint j;\\r\\nBIO_printf(STDout, \"Certificate purposes:\\n\");\\r\\nfor (j = 0; j < X509_PURPOSE_get_count(); j++) {\\r\\nptmp = X509_PURPOSE_get0(j);\\r\\npurpose_print(STDout, x, ptmp);\\r\\n}\\r\\n} else if (modulus == i) {\\r\\nEVP_PKEY *pkey;\\r\\npkey = X509_get_pubkey(x);\\r\\nif (pkey == NULL) {\\r\\nBIO_printf(bio_err, \"Modulus=unavailable\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(STDout, \"Modulus=\");\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pkey->type == EVP_PKEY_RSA)\\r\\nBN_print(STDout, pkey->pkey.rsa->n);\\r\\nelse\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA)\\r\\nBN_print(STDout, pkey->pkey.dsa->pub_key);\\r\\nelse\\r\\n#endif\\r\\nBIO_printf(STDout, \"Wrong Algorithm type\");\\r\\nBIO_printf(STDout, \"\\n\");\\r\\nEVP_PKEY_free(pkey);\\r\\n} else if (pubkey == i) {\\r\\nEVP_PKEY *pkey;\\r\\npkey = X509_get_pubkey(x);\\r\\nif (pkey == NULL) {\\r\\nBIO_printf(bio_err, \"Error getting public key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nPEM_write_bio_PUBKEY(STDout, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\n} else if (C == i) {\\r\\nunsigned char *d;\\r\\nchar *m;\\r\\nint y, z;\\r\\nX509_NAME_oneline(X509_get_subject_name(x), buf, sizeof buf);\\r\\nBIO_printf(STDout, \"/* subject:%s */\\n\", buf);\\r\\nm = X509_NAME_oneline(X509_get_issuer_name(x), buf,\\r\\nsizeof buf);\\r\\nBIO_printf(STDout, \"/* issuer :%s */\\n\", buf);\\r\\nz = i2d_X509(x, NULL);\\r\\nm = OPENSSL_malloc(z);\\r\\nd = (unsigned char *)m;\\r\\nz = i2d_X509_NAME(X509_get_subject_name(x), &d);\\r\\nBIO_printf(STDout, \"unsigned char XXX_subject_name[%d]={\\n\",\\r\\nz);\\r\\nd = (unsigned char *)m;\\r\\nfor (y = 0; y < z; y++) {\\r\\nBIO_printf(STDout, \"0x%02X,\", d[y]);\\r\\nif ((y & 0x0f) == 0x0f)\\r\\nBIO_printf(STDout, \"\\n\");\\r\\n}\\r\\nif (y % 16 != 0)\\r\\nBIO_printf(STDout, \"\\n\");\\r\\nBIO_printf(STDout, \"};\\n\");\\r\\nz = i2d_X509_PUBKEY(X509_get_X509_PUBKEY(x), &d);\\r\\nBIO_printf(STDout, \"unsigned char XXX_public_key[%d]={\\n\", z);\\r\\nd = (unsigned char *)m;\\r\\nfor (y = 0; y < z; y++) {\\r\\nBIO_printf(STDout, \"0x%02X,\", d[y]);\\r\\nif ((y & 0x0f) == 0x0f)\\r\\nBIO_printf(STDout, \"\\n\");\\r\\n}\\r\\nif (y % 16 != 0)\\r\\nBIO_printf(STDout, \"\\n\");\\r\\nBIO_printf(STDout, \"};\\n\");\\r\\nz = i2d_X509(x, &d);\\r\\nBIO_printf(STDout, \"unsigned char XXX_certificate[%d]={\\n\",\\r\\nz);\\r\\nd = (unsigned char *)m;\\r\\nfor (y = 0; y < z; y++) {\\r\\nBIO_printf(STDout, \"0x%02X,\", d[y]);\\r\\nif ((y & 0x0f) == 0x0f)\\r\\nBIO_printf(STDout, \"\\n\");\\r\\n}\\r\\nif (y % 16 != 0)\\r\\nBIO_printf(STDout, \"\\n\");\\r\\nBIO_printf(STDout, \"};\\n\");\\r\\nOPENSSL_free(m);\\r\\n} else if (text == i) {\\r\\nX509_print_ex(STDout, x, nmflag, certflag);\\r\\n} else if (startdate == i) {\\r\\nBIO_puts(STDout, \"notBefore=\");\\r\\nASN1_TIME_print(STDout, X509_get_notBefore(x));\\r\\nBIO_puts(STDout, \"\\n\");\\r\\n} else if (enddate == i) {\\r\\nBIO_puts(STDout, \"notAfter=\");\\r\\nASN1_TIME_print(STDout, X509_get_notAfter(x));\\r\\nBIO_puts(STDout, \"\\n\");\\r\\n} else if (fingerprint == i) {\\r\\nint j;\\r\\nunsigned int n;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nconst EVP_MD *fdig = digest;\\r\\nif (!fdig)\\r\\nfdig = EVP_sha1();\\r\\nif (!X509_digest(x, fdig, md, &n)) {\\r\\nBIO_printf(bio_err, \"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(STDout, \"%s Fingerprint=\",\\r\\nOBJ_nid2sn(EVP_MD_type(fdig)));\\r\\nfor (j = 0; j < (int)n; j++) {\\r\\nBIO_printf(STDout, \"%02X%c\", md[j], (j + 1 == (int)n)\\r\\n? '\\n' : ':');\\r\\n}\\r\\n}\\r\\nelse if ((sign_flag == i) && (x509req == 0)) {\\r\\nBIO_printf(bio_err, \"Getting Private key\\n\");\\r\\nif (Upkey == NULL) {\\r\\nUpkey = load_key(bio_err,\\r\\nkeyfile, keyformat, 0,\\r\\npassin, e, \"Private key\");\\r\\nif (Upkey == NULL)\\r\\ngoto end;\\r\\n}\\r\\nassert(need_rand);\\r\\nif (!sign(x, Upkey, days, clrext, digest, extconf, extsect))\\r\\ngoto end;\\r\\n} else if (CA_flag == i) {\\r\\nBIO_printf(bio_err, \"Getting CA Private Key\\n\");\\r\\nif (CAkeyfile != NULL) {\\r\\nCApkey = load_key(bio_err,\\r\\nCAkeyfile, CAkeyformat,\\r\\n0, passin, e, \"CA Private Key\");\\r\\nif (CApkey == NULL)\\r\\ngoto end;\\r\\n}\\r\\nassert(need_rand);\\r\\nif (!x509_certify(ctx, CAfile, digest, x, xca,\\r\\nCApkey, sigopts,\\r\\nCAserial, CA_createserial, days, clrext,\\r\\nextconf, extsect, sno))\\r\\ngoto end;\\r\\n} else if (x509req == i) {\\r\\nEVP_PKEY *pk;\\r\\nBIO_printf(bio_err, \"Getting request Private Key\\n\");\\r\\nif (keyfile == NULL) {\\r\\nBIO_printf(bio_err, \"no request key file specified\\n\");\\r\\ngoto end;\\r\\n} else {\\r\\npk = load_key(bio_err,\\r\\nkeyfile, keyformat, 0,\\r\\npassin, e, \"request key\");\\r\\nif (pk == NULL)\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err, \"Generating certificate request\\n\");\\r\\nrq = X509_to_X509_REQ(x, pk, digest);\\r\\nEVP_PKEY_free(pk);\\r\\nif (rq == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!noout) {\\r\\nX509_REQ_print(out, rq);\\r\\nPEM_write_bio_X509_REQ(out, rq);\\r\\n}\\r\\nnoout = 1;\\r\\n} else if (ocspid == i) {\\r\\nX509_ocspid_print(out, x);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (checkend) {\\r\\ntime_t tcheck = time(NULL) + checkoffset;\\r\\nif (X509_cmp_time(X509_get_notAfter(x), &tcheck) < 0) {\\r\\nBIO_printf(out, \"Certificate will expire\\n\");\\r\\nret = 1;\\r\\n} else {\\r\\nBIO_printf(out, \"Certificate will not expire\\n\");\\r\\nret = 0;\\r\\n}\\r\\ngoto end;\\r\\n}\\r\\nprint_cert_checks(STDout, x, checkhost, checkemail, checkip);\\r\\nif (noout) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (badsig)\\r\\nx->signature->data[x->signature->length - 1] ^= 0x1;\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_X509_bio(out, x);\\r\\nelse if (outformat == FORMAT_PEM) {\\r\\nif (trustout)\\r\\ni = PEM_write_bio_X509_AUX(out, x);\\r\\nelse\\r\\ni = PEM_write_bio_X509(out, x);\\r\\n} else if (outformat == FORMAT_NETSCAPE) {\\r\\nNETSCAPE_X509 nx;\\r\\nASN1_OCTET_STRING hdr;\\r\\nhdr.data = (unsigned char *)NETSCAPE_CERT_HDR;\\r\\nhdr.length = strlen(NETSCAPE_CERT_HDR);\\r\\nnx.header = &hdr;\\r\\nnx.cert = x;\\r\\ni = ASN1_item_i2d_bio(ASN1_ITEM_rptr(NETSCAPE_X509), out, &nx);\\r\\n} else {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write certificate\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (need_rand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nOBJ_cleanup();\\r\\nNCONF_free(extconf);\\r\\nBIO_free_all(out);\\r\\nBIO_free_all(STDout);\\r\\nX509_STORE_free(ctx);\\r\\nX509_REQ_free(req);\\r\\nX509_free(x);\\r\\nX509_free(xca);\\r\\nEVP_PKEY_free(Upkey);\\r\\nEVP_PKEY_free(CApkey);\\r\\nEVP_PKEY_free(fkey);\\r\\nif (sigopts)\\r\\nsk_OPENSSL_STRING_free(sigopts);\\r\\nX509_REQ_free(rq);\\r\\nASN1_INTEGER_free(sno);\\r\\nsk_ASN1_OBJECT_pop_free(trust, ASN1_OBJECT_free);\\r\\nsk_ASN1_OBJECT_pop_free(reject, ASN1_OBJECT_free);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic ASN1_INTEGER *x509_load_serial(char *CAfile, char *serialfile,\\r\\nint create)\\r\\n{\\r\\nchar *buf = NULL, *p;\\r\\nASN1_INTEGER *bs = NULL;\\r\\nBIGNUM *serial = NULL;\\r\\nsize_t len;\\r\\nlen = ((serialfile == NULL)\\r\\n? (strlen(CAfile) + strlen(POSTFIX) + 1)\\r\\n: (strlen(serialfile))) + 1;\\r\\nbuf = OPENSSL_malloc(len);\\r\\nif (buf == NULL) {\\r\\nBIO_printf(bio_err, \"out of mem\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (serialfile == NULL) {\\r\\nBUF_strlcpy(buf, CAfile, len);\\r\\nfor (p = buf; *p; p++)\\r\\nif (*p == '.') {\\r\\n*p = '\\0';\\r\\nbreak;\\r\\n}\\r\\nBUF_strlcat(buf, POSTFIX, len);\\r\\n} else\\r\\nBUF_strlcpy(buf, serialfile, len);\\r\\nserial = load_serial(buf, create, NULL);\\r\\nif (serial == NULL)\\r\\ngoto end;\\r\\nif (!BN_add_word(serial, 1)) {\\r\\nBIO_printf(bio_err, \"add_word failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!save_serial(buf, NULL, serial, &bs))\\r\\ngoto end;\\r\\nend:\\r\\nif (buf)\\r\\nOPENSSL_free(buf);\\r\\nBN_free(serial);\\r\\nreturn bs;\\r\\n}\\r\\nstatic int MS_CALLBACK callb(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nint err;\\r\\nX509 *err_cert;\\r\\nerr = X509_STORE_CTX_get_error(ctx);\\r\\nif (err == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT)\\r\\nreturn 1;\\r\\nif (ok) {\\r\\nBIO_printf(bio_err,\\r\\n\"error with certificate to be certified - should be self signed\\n\");\\r\\nreturn 0;\\r\\n} else {\\r\\nerr_cert = X509_STORE_CTX_get_current_cert(ctx);\\r\\nprint_name(bio_err, NULL, X509_get_subject_name(err_cert), 0);\\r\\nBIO_printf(bio_err,\\r\\n\"error with certificate - error %d at depth %d\\n%s\\n\", err,\\r\\nX509_STORE_CTX_get_error_depth(ctx),\\r\\nX509_verify_cert_error_string(err));\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nstatic int sign(X509 *x, EVP_PKEY *pkey, int days, int clrext,\\r\\nconst EVP_MD *digest, CONF *conf, char *section)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = X509_get_pubkey(x);\\r\\nEVP_PKEY_copy_parameters(pktmp, pkey);\\r\\nEVP_PKEY_save_parameters(pktmp, 1);\\r\\nEVP_PKEY_free(pktmp);\\r\\nif (!X509_set_issuer_name(x, X509_get_subject_name(x)))\\r\\ngoto err;\\r\\nif (X509_gmtime_adj(X509_get_notBefore(x), 0) == NULL)\\r\\ngoto err;\\r\\nif (X509_gmtime_adj(X509_get_notAfter(x), (long)60 * 60 * 24 * days) ==\\r\\nNULL)\\r\\ngoto err;\\r\\nif (!X509_set_pubkey(x, pkey))\\r\\ngoto err;\\r\\nif (clrext) {\\r\\nwhile (X509_get_ext_count(x) > 0)\\r\\nX509_delete_ext(x, 0);\\r\\n}\\r\\nif (conf) {\\r\\nX509V3_CTX ctx;\\r\\n#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\\r\\nX509_set_version(x, force_version);\\r\\n#else\\r\\nX509_set_version(x, 2);\\r\\n#endif\\r\\nX509V3_set_ctx(&ctx, x, x, NULL, NULL, 0);\\r\\nX509V3_set_nconf(&ctx, conf);\\r\\nif (!X509V3_EXT_add_nconf(conf, &ctx, section, x))\\r\\ngoto err;\\r\\n}\\r\\nif (!X509_sign(x, pkey, digest))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nERR_print_errors(bio_err);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int purpose_print(BIO *bio, X509 *cert, X509_PURPOSE *pt)\\r\\n{\\r\\nint id, i, idret;\\r\\nchar *pname;\\r\\nid = X509_PURPOSE_get_id(pt);\\r\\npname = X509_PURPOSE_get0_name(pt);\\r\\nfor (i = 0; i < 2; i++) {\\r\\nidret = X509_check_purpose(cert, id, i);\\r\\nBIO_printf(bio, \"%s%s : \", pname, i ? \" CA\" : \"\");\\r\\nif (idret == 1)\\r\\nBIO_printf(bio, \"Yes\\n\");\\r\\nelse if (idret == 0)\\r\\nBIO_printf(bio, \"No\\n\");\\r\\nelse\\r\\nBIO_printf(bio, \"Yes (WARNING code=%d)\\n\", idret);\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_ddec_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL, *dcont = NULL;\\r\\nX509 *rcert = NULL;\\r\\nEVP_PKEY *rkey = NULL;\\r\\nCMS_ContentInfo *cms = NULL;\\r\\nint ret = 1;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\ntbio = BIO_new_file(\"signer.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nrcert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nBIO_reset(tbio);\\r\\nrkey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);\\r\\nif (!rcert || !rkey)\\r\\ngoto err;\\r\\nin = BIO_new_file(\"smencr.pem\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\ncms = PEM_read_bio_CMS(in, NULL, 0, NULL);\\r\\nif (!cms)\\r\\ngoto err;\\r\\ndcont = BIO_new_file(\"smencr.out\", \"rb\");\\r\\nif (!in)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"encrout.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!CMS_decrypt(cms, rkey, rcert, dcont, out, 0))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Decrypting Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nif (rcert)\\r\\nX509_free(rcert);\\r\\nif (rkey)\\r\\nEVP_PKEY_free(rkey);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nif (dcont)\\r\\nBIO_free(dcont);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_nsseq_c", "target": 0, "func": "static int nsseq_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nif (operation == ASN1_OP_NEW_POST) {\\r\\nNETSCAPE_CERT_SEQUENCE *nsseq;\\r\\nnsseq = (NETSCAPE_CERT_SEQUENCE *)*pval;\\r\\nnsseq->type = OBJ_nid2obj(NID_netscape_cert_sequence);\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_openssl_c", "target": 0, "func": "static int bind_helper(ENGINE *e)\\r\\n{\\r\\nif (!ENGINE_set_id(e, engine_openssl_id)\\r\\n|| !ENGINE_set_name(e, engine_openssl_name)\\r\\n#ifndef TEST_ENG_OPENSSL_NO_ALGORITHMS\\r\\n# ifndef OPENSSL_NO_RSA\\r\\n|| !ENGINE_set_RSA(e, RSA_get_default_method())\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DSA\\r\\n|| !ENGINE_set_DSA(e, DSA_get_default_method())\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ECDH\\r\\n|| !ENGINE_set_ECDH(e, ECDH_OpenSSL())\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ECDSA\\r\\n|| !ENGINE_set_ECDSA(e, ECDSA_OpenSSL())\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_DH\\r\\n|| !ENGINE_set_DH(e, DH_get_default_method())\\r\\n# endif\\r\\n|| !ENGINE_set_RAND(e, RAND_SSLeay())\\r\\n# ifdef TEST_ENG_OPENSSL_RC4\\r\\n|| !ENGINE_set_ciphers(e, openssl_ciphers)\\r\\n# endif\\r\\n# ifdef TEST_ENG_OPENSSL_SHA\\r\\n|| !ENGINE_set_digests(e, openssl_digests)\\r\\n# endif\\r\\n#endif\\r\\n#ifdef TEST_ENG_OPENSSL_PKEY\\r\\n|| !ENGINE_set_load_privkey_function(e, openssl_load_privkey)\\r\\n#endif\\r\\n)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_openssl(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!bind_helper(ret)) {\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_openssl(void)\\r\\n{\\r\\nENGINE *toadd = engine_openssl();\\r\\nif (!toadd)\\r\\nreturn;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif (id && (strcmp(id, engine_openssl_id) != 0))\\r\\nreturn 0;\\r\\nif (!bind_helper(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int test_rc4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\n# ifdef TEST_ENG_OPENSSL_RC4_P_INIT\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_RC4) test_init_key() called\\n\");\\r\\n# endif\\r\\nmemcpy(&test(ctx)->key[0], key, EVP_CIPHER_CTX_key_length(ctx));\\r\\nRC4_set_key(&test(ctx)->ks, EVP_CIPHER_CTX_key_length(ctx),\\r\\ntest(ctx)->key);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int test_rc4_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\n# ifdef TEST_ENG_OPENSSL_RC4_P_CIPHER\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_RC4) test_cipher() called\\n\");\\r\\n# endif\\r\\nRC4(&test(ctx)->ks, inl, in, out);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int openssl_ciphers(ENGINE *e, const EVP_CIPHER **cipher,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nif (!cipher) {\\r\\n*nids = test_cipher_nids;\\r\\nreturn test_cipher_nids_number;\\r\\n}\\r\\nif (nid == NID_rc4)\\r\\n*cipher = &test_r4_cipher;\\r\\nelse if (nid == NID_rc4_40)\\r\\n*cipher = &test_r4_40_cipher;\\r\\nelse {\\r\\n# ifdef TEST_ENG_OPENSSL_RC4_OTHERS\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_RC4) returning NULL for \"\\r\\n\"nid %d\\n\", nid);\\r\\n# endif\\r\\n*cipher = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int test_sha1_init(EVP_MD_CTX *ctx)\\r\\n{\\r\\n# ifdef TEST_ENG_OPENSSL_SHA_P_INIT\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_SHA) test_sha1_init() called\\n\");\\r\\n# endif\\r\\nreturn SHA1_Init(ctx->md_data);\\r\\n}\\r\\nstatic int test_sha1_update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\n# ifdef TEST_ENG_OPENSSL_SHA_P_UPDATE\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_SHA) test_sha1_update() called\\n\");\\r\\n# endif\\r\\nreturn SHA1_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int test_sha1_final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\n# ifdef TEST_ENG_OPENSSL_SHA_P_FINAL\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_SHA) test_sha1_final() called\\n\");\\r\\n# endif\\r\\nreturn SHA1_Final(md, ctx->md_data);\\r\\n}\\r\\nstatic int openssl_digests(ENGINE *e, const EVP_MD **digest,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nif (!digest) {\\r\\n*nids = test_digest_nids;\\r\\nreturn test_digest_nids_number;\\r\\n}\\r\\nif (nid == NID_sha1)\\r\\n*digest = &test_sha_md;\\r\\nelse {\\r\\n# ifdef TEST_ENG_OPENSSL_SHA_OTHERS\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_SHA) returning NULL for \"\\r\\n\"nid %d\\n\", nid);\\r\\n# endif\\r\\n*digest = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic EVP_PKEY *openssl_load_privkey(ENGINE *eng, const char *key_id,\\r\\nUI_METHOD *ui_method,\\r\\nvoid *callback_data)\\r\\n{\\r\\nBIO *in;\\r\\nEVP_PKEY *key;\\r\\nfprintf(stderr, \"(TEST_ENG_OPENSSL_PKEY)Loading Private key %s\\n\",\\r\\nkey_id);\\r\\nin = BIO_new_file(key_id, \"r\");\\r\\nif (!in)\\r\\nreturn NULL;\\r\\nkey = PEM_read_bio_PrivateKey(in, NULL, 0, NULL);\\r\\nBIO_free(in);\\r\\nreturn key;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_p8e_c", "target": 0, "func": "X509_SIG *PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher,\\r\\nconst char *pass, int passlen,\\r\\nunsigned char *salt, int saltlen, int iter,\\r\\nPKCS8_PRIV_KEY_INFO *p8inf)\\r\\n{\\r\\nX509_SIG *p8 = NULL;\\r\\nX509_ALGOR *pbe;\\r\\nif (!(p8 = X509_SIG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ENCRYPT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (pbe_nid == -1)\\r\\npbe = PKCS5_pbe2_set(cipher, iter, salt, saltlen);\\r\\nelse if (EVP_PBE_find(EVP_PBE_TYPE_PRF, pbe_nid, NULL, NULL, 0))\\r\\npbe = PKCS5_pbe2_set_iv(cipher, iter, salt, saltlen, NULL, pbe_nid);\\r\\nelse {\\r\\nERR_clear_error();\\r\\npbe = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);\\r\\n}\\r\\nif (!pbe) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ENCRYPT, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nX509_ALGOR_free(p8->algor);\\r\\np8->algor = pbe;\\r\\nM_ASN1_OCTET_STRING_free(p8->digest);\\r\\np8->digest =\\r\\nPKCS12_item_i2d_encrypt(pbe, ASN1_ITEM_rptr(PKCS8_PRIV_KEY_INFO),\\r\\npass, passlen, p8inf, 1);\\r\\nif (!p8->digest) {\\r\\nPKCS12err(PKCS12_F_PKCS8_ENCRYPT, PKCS12_R_ENCRYPT_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nreturn p8;\\r\\nerr:\\r\\nX509_SIG_free(p8);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ocsp_srv_c", "target": 0, "func": "int OCSP_request_onereq_count(OCSP_REQUEST *req)\\r\\n{\\r\\nreturn sk_OCSP_ONEREQ_num(req->tbsRequest->requestList);\\r\\n}\\r\\nOCSP_ONEREQ *OCSP_request_onereq_get0(OCSP_REQUEST *req, int i)\\r\\n{\\r\\nreturn sk_OCSP_ONEREQ_value(req->tbsRequest->requestList, i);\\r\\n}\\r\\nOCSP_CERTID *OCSP_onereq_get0_id(OCSP_ONEREQ *one)\\r\\n{\\r\\nreturn one->reqCert;\\r\\n}\\r\\nint OCSP_id_get0_info(ASN1_OCTET_STRING **piNameHash, ASN1_OBJECT **pmd,\\r\\nASN1_OCTET_STRING **pikeyHash,\\r\\nASN1_INTEGER **pserial, OCSP_CERTID *cid)\\r\\n{\\r\\nif (!cid)\\r\\nreturn 0;\\r\\nif (pmd)\\r\\n*pmd = cid->hashAlgorithm->algorithm;\\r\\nif (piNameHash)\\r\\n*piNameHash = cid->issuerNameHash;\\r\\nif (pikeyHash)\\r\\n*pikeyHash = cid->issuerKeyHash;\\r\\nif (pserial)\\r\\n*pserial = cid->serialNumber;\\r\\nreturn 1;\\r\\n}\\r\\nint OCSP_request_is_signed(OCSP_REQUEST *req)\\r\\n{\\r\\nif (req->optionalSignature)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nOCSP_RESPONSE *OCSP_response_create(int status, OCSP_BASICRESP *bs)\\r\\n{\\r\\nOCSP_RESPONSE *rsp = NULL;\\r\\nif (!(rsp = OCSP_RESPONSE_new()))\\r\\ngoto err;\\r\\nif (!(ASN1_ENUMERATED_set(rsp->responseStatus, status)))\\r\\ngoto err;\\r\\nif (!bs)\\r\\nreturn rsp;\\r\\nif (!(rsp->responseBytes = OCSP_RESPBYTES_new()))\\r\\ngoto err;\\r\\nrsp->responseBytes->responseType = OBJ_nid2obj(NID_id_pkix_OCSP_basic);\\r\\nif (!ASN1_item_pack\\r\\n(bs, ASN1_ITEM_rptr(OCSP_BASICRESP), &rsp->responseBytes->response))\\r\\ngoto err;\\r\\nreturn rsp;\\r\\nerr:\\r\\nif (rsp)\\r\\nOCSP_RESPONSE_free(rsp);\\r\\nreturn NULL;\\r\\n}\\r\\nOCSP_SINGLERESP *OCSP_basic_add1_status(OCSP_BASICRESP *rsp,\\r\\nOCSP_CERTID *cid,\\r\\nint status, int reason,\\r\\nASN1_TIME *revtime,\\r\\nASN1_TIME *thisupd,\\r\\nASN1_TIME *nextupd)\\r\\n{\\r\\nOCSP_SINGLERESP *single = NULL;\\r\\nOCSP_CERTSTATUS *cs;\\r\\nOCSP_REVOKEDINFO *ri;\\r\\nif (!rsp->tbsResponseData->responses &&\\r\\n!(rsp->tbsResponseData->responses = sk_OCSP_SINGLERESP_new_null()))\\r\\ngoto err;\\r\\nif (!(single = OCSP_SINGLERESP_new()))\\r\\ngoto err;\\r\\nif (!ASN1_TIME_to_generalizedtime(thisupd, &single->thisUpdate))\\r\\ngoto err;\\r\\nif (nextupd &&\\r\\n!ASN1_TIME_to_generalizedtime(nextupd, &single->nextUpdate))\\r\\ngoto err;\\r\\nOCSP_CERTID_free(single->certId);\\r\\nif (!(single->certId = OCSP_CERTID_dup(cid)))\\r\\ngoto err;\\r\\ncs = single->certStatus;\\r\\nswitch (cs->type = status) {\\r\\ncase V_OCSP_CERTSTATUS_REVOKED:\\r\\nif (!revtime) {\\r\\nOCSPerr(OCSP_F_OCSP_BASIC_ADD1_STATUS, OCSP_R_NO_REVOKED_TIME);\\r\\ngoto err;\\r\\n}\\r\\nif (!(cs->value.revoked = ri = OCSP_REVOKEDINFO_new()))\\r\\ngoto err;\\r\\nif (!ASN1_TIME_to_generalizedtime(revtime, &ri->revocationTime))\\r\\ngoto err;\\r\\nif (reason != OCSP_REVOKED_STATUS_NOSTATUS) {\\r\\nif (!(ri->revocationReason = ASN1_ENUMERATED_new()))\\r\\ngoto err;\\r\\nif (!(ASN1_ENUMERATED_set(ri->revocationReason, reason)))\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase V_OCSP_CERTSTATUS_GOOD:\\r\\ncs->value.good = ASN1_NULL_new();\\r\\nbreak;\\r\\ncase V_OCSP_CERTSTATUS_UNKNOWN:\\r\\ncs->value.unknown = ASN1_NULL_new();\\r\\nbreak;\\r\\ndefault:\\r\\ngoto err;\\r\\n}\\r\\nif (!(sk_OCSP_SINGLERESP_push(rsp->tbsResponseData->responses, single)))\\r\\ngoto err;\\r\\nreturn single;\\r\\nerr:\\r\\nOCSP_SINGLERESP_free(single);\\r\\nreturn NULL;\\r\\n}\\r\\nint OCSP_basic_add1_cert(OCSP_BASICRESP *resp, X509 *cert)\\r\\n{\\r\\nif (!resp->certs && !(resp->certs = sk_X509_new_null()))\\r\\nreturn 0;\\r\\nif (!sk_X509_push(resp->certs, cert))\\r\\nreturn 0;\\r\\nCRYPTO_add(&cert->references, 1, CRYPTO_LOCK_X509);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint ret = 1;\\r\\nRSA *rsa = NULL;\\r\\nint i, badops = 0, sgckey = 0;\\r\\nconst EVP_CIPHER *enc = NULL;\\r\\nBIO *out = NULL;\\r\\nint informat, outformat, text = 0, check = 0, noout = 0;\\r\\nint pubin = 0, pubout = 0;\\r\\nchar *infile, *outfile, *prog;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n# endif\\r\\nint modulus = 0;\\r\\nint pvk_encr = 2;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninfile = NULL;\\r\\noutfile = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passin\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passout\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargout = *(++argv);\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-sgckey\") == 0)\\r\\nsgckey = 1;\\r\\nelse if (strcmp(*argv, \"-pubin\") == 0)\\r\\npubin = 1;\\r\\nelse if (strcmp(*argv, \"-pubout\") == 0)\\r\\npubout = 1;\\r\\nelse if (strcmp(*argv, \"-RSAPublicKey_in\") == 0)\\r\\npubin = 2;\\r\\nelse if (strcmp(*argv, \"-RSAPublicKey_out\") == 0)\\r\\npubout = 2;\\r\\nelse if (strcmp(*argv, \"-pvk-strong\") == 0)\\r\\npvk_encr = 2;\\r\\nelse if (strcmp(*argv, \"-pvk-weak\") == 0)\\r\\npvk_encr = 1;\\r\\nelse if (strcmp(*argv, \"-pvk-none\") == 0)\\r\\npvk_encr = 0;\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv, \"-modulus\") == 0)\\r\\nmodulus = 1;\\r\\nelse if (strcmp(*argv, \"-check\") == 0)\\r\\ncheck = 1;\\r\\nelse if ((enc = EVP_get_cipherbyname(&(argv[0][1]))) == NULL) {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile >outfile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -inform arg input format - one of DER NET PEM\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -outform arg output format - one of DER NET PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err, \" -sgckey Use IIS SGC key format\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -passout arg output file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -des encrypt PEM output with cbc des\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -des3 encrypt PEM output with ede cbc des using 168 bit key\\n\");\\r\\n# ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf(bio_err,\\r\\n\" -idea encrypt PEM output with cbc idea\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nBIO_printf(bio_err,\\r\\n\" -seed encrypt PEM output with cbc seed\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err, \" -aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc aes\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nBIO_printf(bio_err, \" -camellia128, -camellia192, -camellia256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc camellia\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \" -text print the key in text\\n\");\\r\\nBIO_printf(bio_err, \" -noout don't print key out\\n\");\\r\\nBIO_printf(bio_err, \" -modulus print the RSA key modulus\\n\");\\r\\nBIO_printf(bio_err, \" -check verify key consistency\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -pubin expect a public key in input file\\n\");\\r\\nBIO_printf(bio_err, \" -pubout output a public key\\n\");\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n# endif\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (check && pubin) {\\r\\nBIO_printf(bio_err, \"Only private keys can be checked\\n\");\\r\\ngoto end;\\r\\n}\\r\\nout = BIO_new(BIO_s_file());\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nif (pubin) {\\r\\nint tmpformat = -1;\\r\\nif (pubin == 2) {\\r\\nif (informat == FORMAT_PEM)\\r\\ntmpformat = FORMAT_PEMRSA;\\r\\nelse if (informat == FORMAT_ASN1)\\r\\ntmpformat = FORMAT_ASN1RSA;\\r\\n} else if (informat == FORMAT_NETSCAPE && sgckey)\\r\\ntmpformat = FORMAT_IISSGC;\\r\\nelse\\r\\ntmpformat = informat;\\r\\npkey = load_pubkey(bio_err, infile, tmpformat, 1,\\r\\npassin, e, \"Public Key\");\\r\\n} else\\r\\npkey = load_key(bio_err, infile,\\r\\n(informat == FORMAT_NETSCAPE && sgckey ?\\r\\nFORMAT_IISSGC : informat), 1,\\r\\npassin, e, \"Private Key\");\\r\\nif (pkey != NULL)\\r\\nrsa = EVP_PKEY_get1_RSA(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nif (rsa == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text)\\r\\nif (!RSA_print(out, rsa, 0)) {\\r\\nperror(outfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (modulus) {\\r\\nBIO_printf(out, \"Modulus=\");\\r\\nBN_print(out, rsa->n);\\r\\nBIO_printf(out, \"\\n\");\\r\\n}\\r\\nif (check) {\\r\\nint r = RSA_check_key(rsa);\\r\\nif (r == 1)\\r\\nBIO_printf(out, \"RSA key ok\\n\");\\r\\nelse if (r == 0) {\\r\\nunsigned long err;\\r\\nwhile ((err = ERR_peek_error()) != 0 &&\\r\\nERR_GET_LIB(err) == ERR_LIB_RSA &&\\r\\nERR_GET_FUNC(err) == RSA_F_RSA_CHECK_KEY &&\\r\\nERR_GET_REASON(err) != ERR_R_MALLOC_FAILURE) {\\r\\nBIO_printf(out, \"RSA key error: %s\\n\",\\r\\nERR_reason_error_string(err));\\r\\nERR_get_error();\\r\\n}\\r\\n}\\r\\nif (r == -1 || ERR_peek_error() != 0) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (noout) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err, \"writing RSA key\\n\");\\r\\nif (outformat == FORMAT_ASN1) {\\r\\nif (pubout || pubin) {\\r\\nif (pubout == 2)\\r\\ni = i2d_RSAPublicKey_bio(out, rsa);\\r\\nelse\\r\\ni = i2d_RSA_PUBKEY_bio(out, rsa);\\r\\n} else\\r\\ni = i2d_RSAPrivateKey_bio(out, rsa);\\r\\n}\\r\\n# ifndef OPENSSL_NO_RC4\\r\\nelse if (outformat == FORMAT_NETSCAPE) {\\r\\nunsigned char *p, *pp;\\r\\nint size;\\r\\ni = 1;\\r\\nsize = i2d_RSA_NET(rsa, NULL, NULL, sgckey);\\r\\nif ((p = (unsigned char *)OPENSSL_malloc(size)) == NULL) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto end;\\r\\n}\\r\\npp = p;\\r\\ni2d_RSA_NET(rsa, &p, NULL, sgckey);\\r\\nBIO_write(out, (char *)pp, size);\\r\\nOPENSSL_free(pp);\\r\\n}\\r\\n# endif\\r\\nelse if (outformat == FORMAT_PEM) {\\r\\nif (pubout || pubin) {\\r\\nif (pubout == 2)\\r\\ni = PEM_write_bio_RSAPublicKey(out, rsa);\\r\\nelse\\r\\ni = PEM_write_bio_RSA_PUBKEY(out, rsa);\\r\\n} else\\r\\ni = PEM_write_bio_RSAPrivateKey(out, rsa,\\r\\nenc, NULL, 0, NULL, passout);\\r\\n# if !defined(OPENSSL_NO_DSA) && !defined(OPENSSL_NO_RC4)\\r\\n} else if (outformat == FORMAT_MSBLOB || outformat == FORMAT_PVK) {\\r\\nEVP_PKEY *pk;\\r\\npk = EVP_PKEY_new();\\r\\nEVP_PKEY_set1_RSA(pk, rsa);\\r\\nif (outformat == FORMAT_PVK)\\r\\ni = i2b_PVK_bio(out, pk, pvk_encr, 0, passout);\\r\\nelse if (pubin || pubout)\\r\\ni = i2b_PublicKey_bio(out, pk);\\r\\nelse\\r\\ni = i2b_PrivateKey_bio(out, pk);\\r\\nEVP_PKEY_free(pk);\\r\\n# endif\\r\\n} else {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (i <= 0) {\\r\\nBIO_printf(bio_err, \"unable to write key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n} else\\r\\nret = 0;\\r\\nend:\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (rsa != NULL)\\r\\nRSA_free(rsa);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dso_err_c", "target": 0, "func": "void ERR_load_DSO_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(DSO_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, DSO_str_functs);\\r\\nERR_load_strings(0, DSO_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pem_oth_c", "target": 0, "func": "void *PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nconst unsigned char *p = NULL;\\r\\nunsigned char *data = NULL;\\r\\nlong len;\\r\\nchar *ret = NULL;\\r\\nif (!PEM_bytes_read_bio(&data, &len, NULL, name, bp, cb, u))\\r\\nreturn NULL;\\r\\np = data;\\r\\nret = d2i(x, &p, len);\\r\\nif (ret == NULL)\\r\\nPEMerr(PEM_F_PEM_ASN1_READ_BIO, ERR_R_ASN1_LIB);\\r\\nOPENSSL_free(data);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecp_smpl_c", "target": 0, "func": "const EC_METHOD *EC_GFp_simple_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nEC_FLAGS_DEFAULT_OCT,\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_simple_group_init,\\r\\nec_GFp_simple_group_finish,\\r\\nec_GFp_simple_group_clear_finish,\\r\\nec_GFp_simple_group_copy,\\r\\nec_GFp_simple_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\nec_GFp_simple_point_get_affine_coordinates,\\r\\n0, 0, 0,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GFp_simple_field_mul,\\r\\nec_GFp_simple_field_sqr,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\n0\\r\\n};\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn fips_ec_gfp_simple_method();\\r\\n#endif\\r\\nreturn &ret;\\r\\n}\\r\\nint ec_GFp_simple_group_init(EC_GROUP *group)\\r\\n{\\r\\nBN_init(&group->field);\\r\\nBN_init(&group->a);\\r\\nBN_init(&group->b);\\r\\ngroup->a_is_minus3 = 0;\\r\\nreturn 1;\\r\\n}\\r\\nvoid ec_GFp_simple_group_finish(EC_GROUP *group)\\r\\n{\\r\\nBN_free(&group->field);\\r\\nBN_free(&group->a);\\r\\nBN_free(&group->b);\\r\\n}\\r\\nvoid ec_GFp_simple_group_clear_finish(EC_GROUP *group)\\r\\n{\\r\\nBN_clear_free(&group->field);\\r\\nBN_clear_free(&group->a);\\r\\nBN_clear_free(&group->b);\\r\\n}\\r\\nint ec_GFp_simple_group_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\nif (!BN_copy(&dest->field, &src->field))\\r\\nreturn 0;\\r\\nif (!BN_copy(&dest->a, &src->a))\\r\\nreturn 0;\\r\\nif (!BN_copy(&dest->b, &src->b))\\r\\nreturn 0;\\r\\ndest->a_is_minus3 = src->a_is_minus3;\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GFp_simple_group_set_curve(EC_GROUP *group,\\r\\nconst BIGNUM *p, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp_a;\\r\\nif (BN_num_bits(p) <= 2 || !BN_is_odd(p)) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE, EC_R_INVALID_FIELD);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ntmp_a = BN_CTX_get(ctx);\\r\\nif (tmp_a == NULL)\\r\\ngoto err;\\r\\nif (!BN_copy(&group->field, p))\\r\\ngoto err;\\r\\nBN_set_negative(&group->field, 0);\\r\\nif (!BN_nnmod(tmp_a, a, p, ctx))\\r\\ngoto err;\\r\\nif (group->meth->field_encode) {\\r\\nif (!group->meth->field_encode(group, &group->a, tmp_a, ctx))\\r\\ngoto err;\\r\\n} else if (!BN_copy(&group->a, tmp_a))\\r\\ngoto err;\\r\\nif (!BN_nnmod(&group->b, b, p, ctx))\\r\\ngoto err;\\r\\nif (group->meth->field_encode)\\r\\nif (!group->meth->field_encode(group, &group->b, &group->b, ctx))\\r\\ngoto err;\\r\\nif (!BN_add_word(tmp_a, 3))\\r\\ngoto err;\\r\\ngroup->a_is_minus3 = (0 == BN_cmp(tmp_a, &group->field));\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_group_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a,\\r\\nBIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nif (p != NULL) {\\r\\nif (!BN_copy(p, &group->field))\\r\\nreturn 0;\\r\\n}\\r\\nif (a != NULL || b != NULL) {\\r\\nif (group->meth->field_decode) {\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (a != NULL) {\\r\\nif (!group->meth->field_decode(group, a, &group->a, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (b != NULL) {\\r\\nif (!group->meth->field_decode(group, b, &group->b, ctx))\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nif (a != NULL) {\\r\\nif (!BN_copy(a, &group->a))\\r\\ngoto err;\\r\\n}\\r\\nif (b != NULL) {\\r\\nif (!BN_copy(b, &group->b))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (new_ctx)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_group_get_degree(const EC_GROUP *group)\\r\\n{\\r\\nreturn BN_num_bits(&group->field);\\r\\n}\\r\\nint ec_GFp_simple_group_check_discriminant(const EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *a, *b, *order, *tmp_1, *tmp_2;\\r\\nconst BIGNUM *p = &group->field;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\na = BN_CTX_get(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\ntmp_1 = BN_CTX_get(ctx);\\r\\ntmp_2 = BN_CTX_get(ctx);\\r\\norder = BN_CTX_get(ctx);\\r\\nif (order == NULL)\\r\\ngoto err;\\r\\nif (group->meth->field_decode) {\\r\\nif (!group->meth->field_decode(group, a, &group->a, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_decode(group, b, &group->b, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_copy(a, &group->a))\\r\\ngoto err;\\r\\nif (!BN_copy(b, &group->b))\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_zero(a)) {\\r\\nif (BN_is_zero(b))\\r\\ngoto err;\\r\\n} else if (!BN_is_zero(b)) {\\r\\nif (!BN_mod_sqr(tmp_1, a, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(tmp_2, tmp_1, a, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_lshift(tmp_1, tmp_2, 2))\\r\\ngoto err;\\r\\nif (!BN_mod_sqr(tmp_2, b, p, ctx))\\r\\ngoto err;\\r\\nif (!BN_mul_word(tmp_2, 27))\\r\\ngoto err;\\r\\nif (!BN_mod_add(a, tmp_1, tmp_2, p, ctx))\\r\\ngoto err;\\r\\nif (BN_is_zero(a))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_point_init(EC_POINT *point)\\r\\n{\\r\\nBN_init(&point->X);\\r\\nBN_init(&point->Y);\\r\\nBN_init(&point->Z);\\r\\npoint->Z_is_one = 0;\\r\\nreturn 1;\\r\\n}\\r\\nvoid ec_GFp_simple_point_finish(EC_POINT *point)\\r\\n{\\r\\nBN_free(&point->X);\\r\\nBN_free(&point->Y);\\r\\nBN_free(&point->Z);\\r\\n}\\r\\nvoid ec_GFp_simple_point_clear_finish(EC_POINT *point)\\r\\n{\\r\\nBN_clear_free(&point->X);\\r\\nBN_clear_free(&point->Y);\\r\\nBN_clear_free(&point->Z);\\r\\npoint->Z_is_one = 0;\\r\\n}\\r\\nint ec_GFp_simple_point_copy(EC_POINT *dest, const EC_POINT *src)\\r\\n{\\r\\nif (!BN_copy(&dest->X, &src->X))\\r\\nreturn 0;\\r\\nif (!BN_copy(&dest->Y, &src->Y))\\r\\nreturn 0;\\r\\nif (!BN_copy(&dest->Z, &src->Z))\\r\\nreturn 0;\\r\\ndest->Z_is_one = src->Z_is_one;\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GFp_simple_point_set_to_infinity(const EC_GROUP *group,\\r\\nEC_POINT *point)\\r\\n{\\r\\npoint->Z_is_one = 0;\\r\\nBN_zero(&point->Z);\\r\\nreturn 1;\\r\\n}\\r\\nint ec_GFp_simple_set_Jprojective_coordinates_GFp(const EC_GROUP *group,\\r\\nEC_POINT *point,\\r\\nconst BIGNUM *x,\\r\\nconst BIGNUM *y,\\r\\nconst BIGNUM *z,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint ret = 0;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (x != NULL) {\\r\\nif (!BN_nnmod(&point->X, x, &group->field, ctx))\\r\\ngoto err;\\r\\nif (group->meth->field_encode) {\\r\\nif (!group->meth->field_encode(group, &point->X, &point->X, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (y != NULL) {\\r\\nif (!BN_nnmod(&point->Y, y, &group->field, ctx))\\r\\ngoto err;\\r\\nif (group->meth->field_encode) {\\r\\nif (!group->meth->field_encode(group, &point->Y, &point->Y, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (z != NULL) {\\r\\nint Z_is_one;\\r\\nif (!BN_nnmod(&point->Z, z, &group->field, ctx))\\r\\ngoto err;\\r\\nZ_is_one = BN_is_one(&point->Z);\\r\\nif (group->meth->field_encode) {\\r\\nif (Z_is_one && (group->meth->field_set_to_one != 0)) {\\r\\nif (!group->meth->field_set_to_one(group, &point->Z, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!group->\\r\\nmeth->field_encode(group, &point->Z, &point->Z, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\npoint->Z_is_one = Z_is_one;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_get_Jprojective_coordinates_GFp(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y,\\r\\nBIGNUM *z, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nint ret = 0;\\r\\nif (group->meth->field_decode != 0) {\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (x != NULL) {\\r\\nif (!group->meth->field_decode(group, x, &point->X, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (y != NULL) {\\r\\nif (!group->meth->field_decode(group, y, &point->Y, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (z != NULL) {\\r\\nif (!group->meth->field_decode(group, z, &point->Z, ctx))\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nif (x != NULL) {\\r\\nif (!BN_copy(x, &point->X))\\r\\ngoto err;\\r\\n}\\r\\nif (y != NULL) {\\r\\nif (!BN_copy(y, &point->Y))\\r\\ngoto err;\\r\\n}\\r\\nif (z != NULL) {\\r\\nif (!BN_copy(z, &point->Z))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *group,\\r\\nEC_POINT *point,\\r\\nconst BIGNUM *x,\\r\\nconst BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nif (x == NULL || y == NULL) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EC_POINT_set_Jprojective_coordinates_GFp(group, point, x, y,\\r\\nBN_value_one(), ctx);\\r\\n}\\r\\nint ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *Z, *Z_1, *Z_2, *Z_3;\\r\\nconst BIGNUM *Z_;\\r\\nint ret = 0;\\r\\nif (EC_POINT_is_at_infinity(group, point)) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES,\\r\\nEC_R_POINT_AT_INFINITY);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nZ = BN_CTX_get(ctx);\\r\\nZ_1 = BN_CTX_get(ctx);\\r\\nZ_2 = BN_CTX_get(ctx);\\r\\nZ_3 = BN_CTX_get(ctx);\\r\\nif (Z_3 == NULL)\\r\\ngoto err;\\r\\nif (group->meth->field_decode) {\\r\\nif (!group->meth->field_decode(group, Z, &point->Z, ctx))\\r\\ngoto err;\\r\\nZ_ = Z;\\r\\n} else {\\r\\nZ_ = &point->Z;\\r\\n}\\r\\nif (BN_is_one(Z_)) {\\r\\nif (group->meth->field_decode) {\\r\\nif (x != NULL) {\\r\\nif (!group->meth->field_decode(group, x, &point->X, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (y != NULL) {\\r\\nif (!group->meth->field_decode(group, y, &point->Y, ctx))\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nif (x != NULL) {\\r\\nif (!BN_copy(x, &point->X))\\r\\ngoto err;\\r\\n}\\r\\nif (y != NULL) {\\r\\nif (!BN_copy(y, &point->Y))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n} else {\\r\\nif (!BN_mod_inverse(Z_1, Z_, &group->field, ctx)) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES,\\r\\nERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (group->meth->field_encode == 0) {\\r\\nif (!group->meth->field_sqr(group, Z_2, Z_1, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mod_sqr(Z_2, Z_1, &group->field, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (x != NULL) {\\r\\nif (!group->meth->field_mul(group, x, &point->X, Z_2, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (y != NULL) {\\r\\nif (group->meth->field_encode == 0) {\\r\\nif (!group->meth->field_mul(group, Z_3, Z_2, Z_1, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mod_mul(Z_3, Z_2, Z_1, &group->field, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!group->meth->field_mul(group, y, &point->Y, Z_3, ctx))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\\r\\nconst EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nint (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,\\r\\nconst BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nconst BIGNUM *p;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *n0, *n1, *n2, *n3, *n4, *n5, *n6;\\r\\nint ret = 0;\\r\\nif (a == b)\\r\\nreturn EC_POINT_dbl(group, r, a, ctx);\\r\\nif (EC_POINT_is_at_infinity(group, a))\\r\\nreturn EC_POINT_copy(r, b);\\r\\nif (EC_POINT_is_at_infinity(group, b))\\r\\nreturn EC_POINT_copy(r, a);\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\np = &group->field;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nn0 = BN_CTX_get(ctx);\\r\\nn1 = BN_CTX_get(ctx);\\r\\nn2 = BN_CTX_get(ctx);\\r\\nn3 = BN_CTX_get(ctx);\\r\\nn4 = BN_CTX_get(ctx);\\r\\nn5 = BN_CTX_get(ctx);\\r\\nn6 = BN_CTX_get(ctx);\\r\\nif (n6 == NULL)\\r\\ngoto end;\\r\\nif (b->Z_is_one) {\\r\\nif (!BN_copy(n1, &a->X))\\r\\ngoto end;\\r\\nif (!BN_copy(n2, &a->Y))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!field_sqr(group, n0, &b->Z, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, n1, &a->X, n0, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, n0, n0, &b->Z, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, n2, &a->Y, n0, ctx))\\r\\ngoto end;\\r\\n}\\r\\nif (a->Z_is_one) {\\r\\nif (!BN_copy(n3, &b->X))\\r\\ngoto end;\\r\\nif (!BN_copy(n4, &b->Y))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!field_sqr(group, n0, &a->Z, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, n3, &b->X, n0, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, n0, n0, &a->Z, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, n4, &b->Y, n0, ctx))\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_mod_sub_quick(n5, n1, n3, p))\\r\\ngoto end;\\r\\nif (!BN_mod_sub_quick(n6, n2, n4, p))\\r\\ngoto end;\\r\\nif (BN_is_zero(n5)) {\\r\\nif (BN_is_zero(n6)) {\\r\\nBN_CTX_end(ctx);\\r\\nret = EC_POINT_dbl(group, r, a, ctx);\\r\\nctx = NULL;\\r\\ngoto end;\\r\\n} else {\\r\\nBN_zero(&r->Z);\\r\\nr->Z_is_one = 0;\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!BN_mod_add_quick(n1, n1, n3, p))\\r\\ngoto end;\\r\\nif (!BN_mod_add_quick(n2, n2, n4, p))\\r\\ngoto end;\\r\\nif (a->Z_is_one && b->Z_is_one) {\\r\\nif (!BN_copy(&r->Z, n5))\\r\\ngoto end;\\r\\n} else {\\r\\nif (a->Z_is_one) {\\r\\nif (!BN_copy(n0, &b->Z))\\r\\ngoto end;\\r\\n} else if (b->Z_is_one) {\\r\\nif (!BN_copy(n0, &a->Z))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!field_mul(group, n0, &a->Z, &b->Z, ctx))\\r\\ngoto end;\\r\\n}\\r\\nif (!field_mul(group, &r->Z, n0, n5, ctx))\\r\\ngoto end;\\r\\n}\\r\\nr->Z_is_one = 0;\\r\\nif (!field_sqr(group, n0, n6, ctx))\\r\\ngoto end;\\r\\nif (!field_sqr(group, n4, n5, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, n3, n1, n4, ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_sub_quick(&r->X, n0, n3, p))\\r\\ngoto end;\\r\\nif (!BN_mod_lshift1_quick(n0, &r->X, p))\\r\\ngoto end;\\r\\nif (!BN_mod_sub_quick(n0, n3, n0, p))\\r\\ngoto end;\\r\\nif (!field_mul(group, n0, n0, n6, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, n5, n4, n5, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, n1, n2, n5, ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_sub_quick(n0, n0, n1, p))\\r\\ngoto end;\\r\\nif (BN_is_odd(n0))\\r\\nif (!BN_add(n0, n0, p))\\r\\ngoto end;\\r\\nif (!BN_rshift1(&r->Y, n0))\\r\\ngoto end;\\r\\nret = 1;\\r\\nend:\\r\\nif (ctx)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,\\r\\nconst BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nconst BIGNUM *p;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *n0, *n1, *n2, *n3;\\r\\nint ret = 0;\\r\\nif (EC_POINT_is_at_infinity(group, a)) {\\r\\nBN_zero(&r->Z);\\r\\nr->Z_is_one = 0;\\r\\nreturn 1;\\r\\n}\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\np = &group->field;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nn0 = BN_CTX_get(ctx);\\r\\nn1 = BN_CTX_get(ctx);\\r\\nn2 = BN_CTX_get(ctx);\\r\\nn3 = BN_CTX_get(ctx);\\r\\nif (n3 == NULL)\\r\\ngoto err;\\r\\nif (a->Z_is_one) {\\r\\nif (!field_sqr(group, n0, &a->X, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_lshift1_quick(n1, n0, p))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(n0, n0, n1, p))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(n1, n0, &group->a, p))\\r\\ngoto err;\\r\\n} else if (group->a_is_minus3) {\\r\\nif (!field_sqr(group, n1, &a->Z, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(n0, &a->X, n1, p))\\r\\ngoto err;\\r\\nif (!BN_mod_sub_quick(n2, &a->X, n1, p))\\r\\ngoto err;\\r\\nif (!field_mul(group, n1, n0, n2, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_lshift1_quick(n0, n1, p))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(n1, n0, n1, p))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!field_sqr(group, n0, &a->X, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_lshift1_quick(n1, n0, p))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(n0, n0, n1, p))\\r\\ngoto err;\\r\\nif (!field_sqr(group, n1, &a->Z, ctx))\\r\\ngoto err;\\r\\nif (!field_sqr(group, n1, n1, ctx))\\r\\ngoto err;\\r\\nif (!field_mul(group, n1, n1, &group->a, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(n1, n1, n0, p))\\r\\ngoto err;\\r\\n}\\r\\nif (a->Z_is_one) {\\r\\nif (!BN_copy(n0, &a->Y))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!field_mul(group, n0, &a->Y, &a->Z, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_mod_lshift1_quick(&r->Z, n0, p))\\r\\ngoto err;\\r\\nr->Z_is_one = 0;\\r\\nif (!field_sqr(group, n3, &a->Y, ctx))\\r\\ngoto err;\\r\\nif (!field_mul(group, n2, &a->X, n3, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_lshift_quick(n2, n2, 2, p))\\r\\ngoto err;\\r\\nif (!BN_mod_lshift1_quick(n0, n2, p))\\r\\ngoto err;\\r\\nif (!field_sqr(group, &r->X, n1, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_sub_quick(&r->X, &r->X, n0, p))\\r\\ngoto err;\\r\\nif (!field_sqr(group, n0, n3, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_lshift_quick(n3, n0, 3, p))\\r\\ngoto err;\\r\\nif (!BN_mod_sub_quick(n0, n2, &r->X, p))\\r\\ngoto err;\\r\\nif (!field_mul(group, n0, n1, n0, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_sub_quick(&r->Y, n0, n3, p))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_invert(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nif (EC_POINT_is_at_infinity(group, point) || BN_is_zero(&point->Y))\\r\\nreturn 1;\\r\\nreturn BN_usub(&point->Y, &group->field, &point->Y);\\r\\n}\\r\\nint ec_GFp_simple_is_at_infinity(const EC_GROUP *group, const EC_POINT *point)\\r\\n{\\r\\nreturn BN_is_zero(&point->Z);\\r\\n}\\r\\nint ec_GFp_simple_is_on_curve(const EC_GROUP *group, const EC_POINT *point,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,\\r\\nconst BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nconst BIGNUM *p;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *rh, *tmp, *Z4, *Z6;\\r\\nint ret = -1;\\r\\nif (EC_POINT_is_at_infinity(group, point))\\r\\nreturn 1;\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\np = &group->field;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nrh = BN_CTX_get(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nZ4 = BN_CTX_get(ctx);\\r\\nZ6 = BN_CTX_get(ctx);\\r\\nif (Z6 == NULL)\\r\\ngoto err;\\r\\nif (!field_sqr(group, rh, &point->X, ctx))\\r\\ngoto err;\\r\\nif (!point->Z_is_one) {\\r\\nif (!field_sqr(group, tmp, &point->Z, ctx))\\r\\ngoto err;\\r\\nif (!field_sqr(group, Z4, tmp, ctx))\\r\\ngoto err;\\r\\nif (!field_mul(group, Z6, Z4, tmp, ctx))\\r\\ngoto err;\\r\\nif (group->a_is_minus3) {\\r\\nif (!BN_mod_lshift1_quick(tmp, Z4, p))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(tmp, tmp, Z4, p))\\r\\ngoto err;\\r\\nif (!BN_mod_sub_quick(rh, rh, tmp, p))\\r\\ngoto err;\\r\\nif (!field_mul(group, rh, rh, &point->X, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!field_mul(group, tmp, Z4, &group->a, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(rh, rh, tmp, p))\\r\\ngoto err;\\r\\nif (!field_mul(group, rh, rh, &point->X, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!field_mul(group, tmp, &group->b, Z6, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(rh, rh, tmp, p))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mod_add_quick(rh, rh, &group->a, p))\\r\\ngoto err;\\r\\nif (!field_mul(group, rh, rh, &point->X, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_add_quick(rh, rh, &group->b, p))\\r\\ngoto err;\\r\\n}\\r\\nif (!field_sqr(group, tmp, &point->Y, ctx))\\r\\ngoto err;\\r\\nret = (0 == BN_ucmp(tmp, rh));\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_cmp(const EC_GROUP *group, const EC_POINT *a,\\r\\nconst EC_POINT *b, BN_CTX *ctx)\\r\\n{\\r\\nint (*field_mul) (const EC_GROUP *, BIGNUM *, const BIGNUM *,\\r\\nconst BIGNUM *, BN_CTX *);\\r\\nint (*field_sqr) (const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp1, *tmp2, *Za23, *Zb23;\\r\\nconst BIGNUM *tmp1_, *tmp2_;\\r\\nint ret = -1;\\r\\nif (EC_POINT_is_at_infinity(group, a)) {\\r\\nreturn EC_POINT_is_at_infinity(group, b) ? 0 : 1;\\r\\n}\\r\\nif (EC_POINT_is_at_infinity(group, b))\\r\\nreturn 1;\\r\\nif (a->Z_is_one && b->Z_is_one) {\\r\\nreturn ((BN_cmp(&a->X, &b->X) == 0)\\r\\n&& BN_cmp(&a->Y, &b->Y) == 0) ? 0 : 1;\\r\\n}\\r\\nfield_mul = group->meth->field_mul;\\r\\nfield_sqr = group->meth->field_sqr;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn -1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ntmp1 = BN_CTX_get(ctx);\\r\\ntmp2 = BN_CTX_get(ctx);\\r\\nZa23 = BN_CTX_get(ctx);\\r\\nZb23 = BN_CTX_get(ctx);\\r\\nif (Zb23 == NULL)\\r\\ngoto end;\\r\\nif (!b->Z_is_one) {\\r\\nif (!field_sqr(group, Zb23, &b->Z, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, tmp1, &a->X, Zb23, ctx))\\r\\ngoto end;\\r\\ntmp1_ = tmp1;\\r\\n} else\\r\\ntmp1_ = &a->X;\\r\\nif (!a->Z_is_one) {\\r\\nif (!field_sqr(group, Za23, &a->Z, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, tmp2, &b->X, Za23, ctx))\\r\\ngoto end;\\r\\ntmp2_ = tmp2;\\r\\n} else\\r\\ntmp2_ = &b->X;\\r\\nif (BN_cmp(tmp1_, tmp2_) != 0) {\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nif (!b->Z_is_one) {\\r\\nif (!field_mul(group, Zb23, Zb23, &b->Z, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, tmp1, &a->Y, Zb23, ctx))\\r\\ngoto end;\\r\\n} else\\r\\ntmp1_ = &a->Y;\\r\\nif (!a->Z_is_one) {\\r\\nif (!field_mul(group, Za23, Za23, &a->Z, ctx))\\r\\ngoto end;\\r\\nif (!field_mul(group, tmp2, &b->Y, Za23, ctx))\\r\\ngoto end;\\r\\n} else\\r\\ntmp2_ = &b->Y;\\r\\nif (BN_cmp(tmp1_, tmp2_) != 0) {\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_make_affine(const EC_GROUP *group, EC_POINT *point,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y;\\r\\nint ret = 0;\\r\\nif (point->Z_is_one || EC_POINT_is_at_infinity(group, point))\\r\\nreturn 1;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL)\\r\\ngoto err;\\r\\nif (!EC_POINT_get_affine_coordinates_GFp(group, point, x, y, ctx))\\r\\ngoto err;\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, point, x, y, ctx))\\r\\ngoto err;\\r\\nif (!point->Z_is_one) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_MAKE_AFFINE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_points_make_affine(const EC_GROUP *group, size_t num,\\r\\nEC_POINT *points[], BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *tmp, *tmp_Z;\\r\\nBIGNUM **prod_Z = NULL;\\r\\nsize_t i;\\r\\nint ret = 0;\\r\\nif (num == 0)\\r\\nreturn 1;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\ntmp_Z = BN_CTX_get(ctx);\\r\\nif (tmp == NULL || tmp_Z == NULL)\\r\\ngoto err;\\r\\nprod_Z = OPENSSL_malloc(num * sizeof prod_Z[0]);\\r\\nif (prod_Z == NULL)\\r\\ngoto err;\\r\\nfor (i = 0; i < num; i++) {\\r\\nprod_Z[i] = BN_new();\\r\\nif (prod_Z[i] == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_is_zero(&points[0]->Z)) {\\r\\nif (!BN_copy(prod_Z[0], &points[0]->Z))\\r\\ngoto err;\\r\\n} else {\\r\\nif (group->meth->field_set_to_one != 0) {\\r\\nif (!group->meth->field_set_to_one(group, prod_Z[0], ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_one(prod_Z[0]))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nfor (i = 1; i < num; i++) {\\r\\nif (!BN_is_zero(&points[i]->Z)) {\\r\\nif (!group->meth->field_mul(group, prod_Z[i], prod_Z[i - 1],\\r\\n&points[i]->Z, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_copy(prod_Z[i], prod_Z[i - 1]))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_mod_inverse(tmp, prod_Z[num - 1], &group->field, ctx)) {\\r\\nECerr(EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (group->meth->field_encode != 0) {\\r\\nif (!group->meth->field_encode(group, tmp, tmp, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_encode(group, tmp, tmp, ctx))\\r\\ngoto err;\\r\\n}\\r\\nfor (i = num - 1; i > 0; --i) {\\r\\nif (!BN_is_zero(&points[i]->Z)) {\\r\\nif (!group->\\r\\nmeth->field_mul(group, tmp_Z, prod_Z[i - 1], tmp, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, tmp, tmp, &points[i]->Z, ctx))\\r\\ngoto err;\\r\\nif (!BN_copy(&points[i]->Z, tmp_Z))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!BN_is_zero(&points[0]->Z)) {\\r\\nif (!BN_copy(&points[0]->Z, tmp))\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < num; i++) {\\r\\nEC_POINT *p = points[i];\\r\\nif (!BN_is_zero(&p->Z)) {\\r\\nif (!group->meth->field_sqr(group, tmp, &p->Z, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, &p->X, &p->X, tmp, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, tmp, tmp, &p->Z, ctx))\\r\\ngoto err;\\r\\nif (!group->meth->field_mul(group, &p->Y, &p->Y, tmp, ctx))\\r\\ngoto err;\\r\\nif (group->meth->field_set_to_one != 0) {\\r\\nif (!group->meth->field_set_to_one(group, &p->Z, ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_one(&p->Z))\\r\\ngoto err;\\r\\n}\\r\\np->Z_is_one = 1;\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (prod_Z != NULL) {\\r\\nfor (i = 0; i < num; i++) {\\r\\nif (prod_Z[i] == NULL)\\r\\nbreak;\\r\\nBN_clear_free(prod_Z[i]);\\r\\n}\\r\\nOPENSSL_free(prod_Z);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_simple_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_mod_mul(r, a, b, &group->field, ctx);\\r\\n}\\r\\nint ec_GFp_simple_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nreturn BN_mod_sqr(r, a, &group->field, ctx);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_ctx_c", "target": 0, "func": "static void ctxdbg(BN_CTX *ctx)\\r\\n{\\r\\nunsigned int bnidx = 0, fpidx = 0;\\r\\nBN_POOL_ITEM *item = ctx->pool.head;\\r\\nBN_STACK *stack = &ctx->stack;\\r\\nfprintf(stderr, \"(%16p): \", ctx);\\r\\nwhile (bnidx < ctx->used) {\\r\\nfprintf(stderr, \"%03x \", item->vals[bnidx++ % BN_CTX_POOL_SIZE].dmax);\\r\\nif (!(bnidx % BN_CTX_POOL_SIZE))\\r\\nitem = item->next;\\r\\n}\\r\\nfprintf(stderr, \"\\n\");\\r\\nbnidx = 0;\\r\\nfprintf(stderr, \" : \");\\r\\nwhile (fpidx < stack->depth) {\\r\\nwhile (bnidx++ < stack->indexes[fpidx])\\r\\nfprintf(stderr, \" \");\\r\\nfprintf(stderr, \"^^^ \");\\r\\nbnidx++;\\r\\nfpidx++;\\r\\n}\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\nvoid BN_CTX_init(BN_CTX *ctx)\\r\\n{\\r\\nBN_POOL_reset(&ctx->pool);\\r\\nBN_STACK_reset(&ctx->stack);\\r\\nctx->used = 0;\\r\\nctx->err_stack = 0;\\r\\nctx->too_many = 0;\\r\\n}\\r\\nBN_CTX *BN_CTX_new(void)\\r\\n{\\r\\nBN_CTX *ret = OPENSSL_malloc(sizeof(BN_CTX));\\r\\nif (!ret) {\\r\\nBNerr(BN_F_BN_CTX_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nBN_POOL_init(&ret->pool);\\r\\nBN_STACK_init(&ret->stack);\\r\\nret->used = 0;\\r\\nret->err_stack = 0;\\r\\nret->too_many = 0;\\r\\nreturn ret;\\r\\n}\\r\\nvoid BN_CTX_free(BN_CTX *ctx)\\r\\n{\\r\\nif (ctx == NULL)\\r\\nreturn;\\r\\n#ifdef BN_CTX_DEBUG\\r\\n{\\r\\nBN_POOL_ITEM *pool = ctx->pool.head;\\r\\nfprintf(stderr, \"BN_CTX_free, stack-size=%d, pool-bignums=%d\\n\",\\r\\nctx->stack.size, ctx->pool.size);\\r\\nfprintf(stderr, \"dmaxs: \");\\r\\nwhile (pool) {\\r\\nunsigned loop = 0;\\r\\nwhile (loop < BN_CTX_POOL_SIZE)\\r\\nfprintf(stderr, \"%02x \", pool->vals[loop++].dmax);\\r\\npool = pool->next;\\r\\n}\\r\\nfprintf(stderr, \"\\n\");\\r\\n}\\r\\n#endif\\r\\nBN_STACK_finish(&ctx->stack);\\r\\nBN_POOL_finish(&ctx->pool);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nvoid BN_CTX_start(BN_CTX *ctx)\\r\\n{\\r\\nCTXDBG_ENTRY(\"BN_CTX_start\", ctx);\\r\\nif (ctx->err_stack || ctx->too_many)\\r\\nctx->err_stack++;\\r\\nelse if (!BN_STACK_push(&ctx->stack, ctx->used)) {\\r\\nBNerr(BN_F_BN_CTX_START, BN_R_TOO_MANY_TEMPORARY_VARIABLES);\\r\\nctx->err_stack++;\\r\\n}\\r\\nCTXDBG_EXIT(ctx);\\r\\n}\\r\\nvoid BN_CTX_end(BN_CTX *ctx)\\r\\n{\\r\\nCTXDBG_ENTRY(\"BN_CTX_end\", ctx);\\r\\nif (ctx->err_stack)\\r\\nctx->err_stack--;\\r\\nelse {\\r\\nunsigned int fp = BN_STACK_pop(&ctx->stack);\\r\\nif (fp < ctx->used)\\r\\nBN_POOL_release(&ctx->pool, ctx->used - fp);\\r\\nctx->used = fp;\\r\\nctx->too_many = 0;\\r\\n}\\r\\nCTXDBG_EXIT(ctx);\\r\\n}\\r\\nBIGNUM *BN_CTX_get(BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nCTXDBG_ENTRY(\"BN_CTX_get\", ctx);\\r\\nif (ctx->err_stack || ctx->too_many)\\r\\nreturn NULL;\\r\\nif ((ret = BN_POOL_get(&ctx->pool)) == NULL) {\\r\\nctx->too_many = 1;\\r\\nBNerr(BN_F_BN_CTX_GET, BN_R_TOO_MANY_TEMPORARY_VARIABLES);\\r\\nreturn NULL;\\r\\n}\\r\\nBN_zero(ret);\\r\\nctx->used++;\\r\\nCTXDBG_RET(ctx, ret);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void BN_STACK_init(BN_STACK *st)\\r\\n{\\r\\nst->indexes = NULL;\\r\\nst->depth = st->size = 0;\\r\\n}\\r\\nstatic void BN_STACK_finish(BN_STACK *st)\\r\\n{\\r\\nif (st->size)\\r\\nOPENSSL_free(st->indexes);\\r\\n}\\r\\nstatic void BN_STACK_reset(BN_STACK *st)\\r\\n{\\r\\nst->depth = 0;\\r\\n}\\r\\nstatic int BN_STACK_push(BN_STACK *st, unsigned int idx)\\r\\n{\\r\\nif (st->depth == st->size)\\r\\n{\\r\\nunsigned int newsize = (st->size ?\\r\\n(st->size * 3 / 2) : BN_CTX_START_FRAMES);\\r\\nunsigned int *newitems = OPENSSL_malloc(newsize *\\r\\nsizeof(unsigned int));\\r\\nif (!newitems)\\r\\nreturn 0;\\r\\nif (st->depth)\\r\\nmemcpy(newitems, st->indexes, st->depth * sizeof(unsigned int));\\r\\nif (st->size)\\r\\nOPENSSL_free(st->indexes);\\r\\nst->indexes = newitems;\\r\\nst->size = newsize;\\r\\n}\\r\\nst->indexes[(st->depth)++] = idx;\\r\\nreturn 1;\\r\\n}\\r\\nstatic unsigned int BN_STACK_pop(BN_STACK *st)\\r\\n{\\r\\nreturn st->indexes[--(st->depth)];\\r\\n}\\r\\nstatic void BN_POOL_init(BN_POOL *p)\\r\\n{\\r\\np->head = p->current = p->tail = NULL;\\r\\np->used = p->size = 0;\\r\\n}\\r\\nstatic void BN_POOL_finish(BN_POOL *p)\\r\\n{\\r\\nwhile (p->head) {\\r\\nunsigned int loop = 0;\\r\\nBIGNUM *bn = p->head->vals;\\r\\nwhile (loop++ < BN_CTX_POOL_SIZE) {\\r\\nif (bn->d)\\r\\nBN_clear_free(bn);\\r\\nbn++;\\r\\n}\\r\\np->current = p->head->next;\\r\\nOPENSSL_free(p->head);\\r\\np->head = p->current;\\r\\n}\\r\\n}\\r\\nstatic void BN_POOL_reset(BN_POOL *p)\\r\\n{\\r\\nBN_POOL_ITEM *item = p->head;\\r\\nwhile (item) {\\r\\nunsigned int loop = 0;\\r\\nBIGNUM *bn = item->vals;\\r\\nwhile (loop++ < BN_CTX_POOL_SIZE) {\\r\\nif (bn->d)\\r\\nBN_clear(bn);\\r\\nbn++;\\r\\n}\\r\\nitem = item->next;\\r\\n}\\r\\np->current = p->head;\\r\\np->used = 0;\\r\\n}\\r\\nstatic BIGNUM *BN_POOL_get(BN_POOL *p)\\r\\n{\\r\\nif (p->used == p->size) {\\r\\nBIGNUM *bn;\\r\\nunsigned int loop = 0;\\r\\nBN_POOL_ITEM *item = OPENSSL_malloc(sizeof(BN_POOL_ITEM));\\r\\nif (!item)\\r\\nreturn NULL;\\r\\nbn = item->vals;\\r\\nwhile (loop++ < BN_CTX_POOL_SIZE)\\r\\nBN_init(bn++);\\r\\nitem->prev = p->tail;\\r\\nitem->next = NULL;\\r\\nif (!p->head)\\r\\np->head = p->current = p->tail = item;\\r\\nelse {\\r\\np->tail->next = item;\\r\\np->tail = item;\\r\\np->current = item;\\r\\n}\\r\\np->size += BN_CTX_POOL_SIZE;\\r\\np->used++;\\r\\nreturn item->vals;\\r\\n}\\r\\nif (!p->used)\\r\\np->current = p->head;\\r\\nelse if ((p->used % BN_CTX_POOL_SIZE) == 0)\\r\\np->current = p->current->next;\\r\\nreturn p->current->vals + ((p->used++) % BN_CTX_POOL_SIZE);\\r\\n}\\r\\nstatic void BN_POOL_release(BN_POOL *p, unsigned int num)\\r\\n{\\r\\nunsigned int offset = (p->used - 1) % BN_CTX_POOL_SIZE;\\r\\np->used -= num;\\r\\nwhile (num--) {\\r\\nbn_check_top(p->current->vals + offset);\\r\\nif (!offset) {\\r\\noffset = BN_CTX_POOL_SIZE - 1;\\r\\np->current = p->current->prev;\\r\\n} else\\r\\noffset--;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pcy_tree_c", "target": 0, "func": "static void expected_print(BIO *err, X509_POLICY_LEVEL *lev,\\r\\nX509_POLICY_NODE *node, int indent)\\r\\n{\\r\\nif ((lev->flags & X509_V_FLAG_INHIBIT_MAP)\\r\\n|| !(node->data->flags & POLICY_DATA_FLAG_MAP_MASK))\\r\\nBIO_puts(err, \" Not Mapped\\n\");\\r\\nelse {\\r\\nint i;\\r\\nSTACK_OF(ASN1_OBJECT) *pset = node->data->expected_policy_set;\\r\\nASN1_OBJECT *oid;\\r\\nBIO_puts(err, \" Expected: \");\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(pset); i++) {\\r\\noid = sk_ASN1_OBJECT_value(pset, i);\\r\\nif (i)\\r\\nBIO_puts(err, \", \");\\r\\ni2a_ASN1_OBJECT(err, oid);\\r\\n}\\r\\nBIO_puts(err, \"\\n\");\\r\\n}\\r\\n}\\r\\nstatic void tree_print(char *str, X509_POLICY_TREE *tree,\\r\\nX509_POLICY_LEVEL *curr)\\r\\n{\\r\\nX509_POLICY_LEVEL *plev;\\r\\nX509_POLICY_NODE *node;\\r\\nint i;\\r\\nBIO *err;\\r\\nerr = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!curr)\\r\\ncurr = tree->levels + tree->nlevel;\\r\\nelse\\r\\ncurr++;\\r\\nBIO_printf(err, \"Level print after %s\\n\", str);\\r\\nBIO_printf(err, \"Printing Up to Level %ld\\n\", curr - tree->levels);\\r\\nfor (plev = tree->levels; plev != curr; plev++) {\\r\\nBIO_printf(err, \"Level %ld, flags = %x\\n\",\\r\\nplev - tree->levels, plev->flags);\\r\\nfor (i = 0; i < sk_X509_POLICY_NODE_num(plev->nodes); i++) {\\r\\nnode = sk_X509_POLICY_NODE_value(plev->nodes, i);\\r\\nX509_POLICY_NODE_print(err, node, 2);\\r\\nexpected_print(err, plev, node, 2);\\r\\nBIO_printf(err, \" Flags: %x\\n\", node->data->flags);\\r\\n}\\r\\nif (plev->anyPolicy)\\r\\nX509_POLICY_NODE_print(err, plev->anyPolicy, 2);\\r\\n}\\r\\nBIO_free(err);\\r\\n}\\r\\nstatic int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\\r\\nconst X509_POLICY_DATA *data)\\r\\n{\\r\\nX509_POLICY_LEVEL *last = curr - 1;\\r\\nX509_POLICY_NODE *node;\\r\\nint i, matched = 0;\\r\\nfor (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\\r\\nnode = sk_X509_POLICY_NODE_value(last->nodes, i);\\r\\nif (policy_node_match(last, node, data->valid_policy)) {\\r\\nif (!level_add_node(curr, data, node, NULL))\\r\\nreturn 0;\\r\\nmatched = 1;\\r\\n}\\r\\n}\\r\\nif (!matched && last->anyPolicy) {\\r\\nif (!level_add_node(curr, data, last->anyPolicy, NULL))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tree_link_nodes(X509_POLICY_LEVEL *curr,\\r\\nconst X509_POLICY_CACHE *cache)\\r\\n{\\r\\nint i;\\r\\nX509_POLICY_DATA *data;\\r\\nfor (i = 0; i < sk_X509_POLICY_DATA_num(cache->data); i++) {\\r\\ndata = sk_X509_POLICY_DATA_value(cache->data, i);\\r\\n#if 0\\r\\nif ((data->flags & POLICY_DATA_FLAG_MAPPED_ANY)\\r\\n&& !(curr->flags & X509_V_FLAG_INHIBIT_ANY))\\r\\ncontinue;\\r\\n#endif\\r\\nif (!tree_link_matching_nodes(curr, data))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tree_add_unmatched(X509_POLICY_LEVEL *curr,\\r\\nconst X509_POLICY_CACHE *cache,\\r\\nconst ASN1_OBJECT *id,\\r\\nX509_POLICY_NODE *node, X509_POLICY_TREE *tree)\\r\\n{\\r\\nX509_POLICY_DATA *data;\\r\\nif (id == NULL)\\r\\nid = node->data->valid_policy;\\r\\ndata = policy_data_new(NULL, id, node_critical(node));\\r\\nif (data == NULL)\\r\\nreturn 0;\\r\\ndata->qualifier_set = cache->anyPolicy->qualifier_set;\\r\\ndata->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\\r\\nif (!level_add_node(curr, data, node, tree)) {\\r\\npolicy_data_free(data);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tree_link_unmatched(X509_POLICY_LEVEL *curr,\\r\\nconst X509_POLICY_CACHE *cache,\\r\\nX509_POLICY_NODE *node, X509_POLICY_TREE *tree)\\r\\n{\\r\\nconst X509_POLICY_LEVEL *last = curr - 1;\\r\\nint i;\\r\\nif ((last->flags & X509_V_FLAG_INHIBIT_MAP)\\r\\n|| !(node->data->flags & POLICY_DATA_FLAG_MAPPED)) {\\r\\nif (node->nchild)\\r\\nreturn 1;\\r\\nif (!tree_add_unmatched(curr, cache, NULL, node, tree))\\r\\nreturn 0;\\r\\n} else {\\r\\nSTACK_OF(ASN1_OBJECT) *expset = node->data->expected_policy_set;\\r\\nif (node->nchild == sk_ASN1_OBJECT_num(expset))\\r\\nreturn 1;\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(expset); i++) {\\r\\nASN1_OBJECT *oid = sk_ASN1_OBJECT_value(expset, i);\\r\\nif (level_find_node(curr, node, oid))\\r\\ncontinue;\\r\\nif (!tree_add_unmatched(curr, cache, oid, node, tree))\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tree_link_any(X509_POLICY_LEVEL *curr,\\r\\nconst X509_POLICY_CACHE *cache,\\r\\nX509_POLICY_TREE *tree)\\r\\n{\\r\\nint i;\\r\\nX509_POLICY_NODE *node;\\r\\nX509_POLICY_LEVEL *last = curr - 1;\\r\\nfor (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\\r\\nnode = sk_X509_POLICY_NODE_value(last->nodes, i);\\r\\nif (!tree_link_unmatched(curr, cache, node, tree))\\r\\nreturn 0;\\r\\n#if 0\\r\\nif (node->nchild)\\r\\ncontinue;\\r\\ndata = policy_data_new(NULL, node->data->valid_policy,\\r\\nnode_critical(node));\\r\\nif (data == NULL)\\r\\nreturn 0;\\r\\ndata->qualifier_set = cache->anyPolicy->qualifier_set;\\r\\ndata->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\\r\\nif (!level_add_node(curr, data, node, tree)) {\\r\\npolicy_data_free(data);\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (last->anyPolicy) {\\r\\nif (!level_add_node(curr, cache->anyPolicy, last->anyPolicy, NULL))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tree_prune(X509_POLICY_TREE *tree, X509_POLICY_LEVEL *curr)\\r\\n{\\r\\nSTACK_OF(X509_POLICY_NODE) *nodes;\\r\\nX509_POLICY_NODE *node;\\r\\nint i;\\r\\nnodes = curr->nodes;\\r\\nif (curr->flags & X509_V_FLAG_INHIBIT_MAP) {\\r\\nfor (i = sk_X509_POLICY_NODE_num(nodes) - 1; i >= 0; i--) {\\r\\nnode = sk_X509_POLICY_NODE_value(nodes, i);\\r\\nif (node->data->flags & POLICY_DATA_FLAG_MAP_MASK) {\\r\\nnode->parent->nchild--;\\r\\nOPENSSL_free(node);\\r\\n(void)sk_X509_POLICY_NODE_delete(nodes, i);\\r\\n}\\r\\n}\\r\\n}\\r\\nfor (;;) {\\r\\n--curr;\\r\\nnodes = curr->nodes;\\r\\nfor (i = sk_X509_POLICY_NODE_num(nodes) - 1; i >= 0; i--) {\\r\\nnode = sk_X509_POLICY_NODE_value(nodes, i);\\r\\nif (node->nchild == 0) {\\r\\nnode->parent->nchild--;\\r\\nOPENSSL_free(node);\\r\\n(void)sk_X509_POLICY_NODE_delete(nodes, i);\\r\\n}\\r\\n}\\r\\nif (curr->anyPolicy && !curr->anyPolicy->nchild) {\\r\\nif (curr->anyPolicy->parent)\\r\\ncurr->anyPolicy->parent->nchild--;\\r\\nOPENSSL_free(curr->anyPolicy);\\r\\ncurr->anyPolicy = NULL;\\r\\n}\\r\\nif (curr == tree->levels) {\\r\\nif (!curr->anyPolicy)\\r\\nreturn 2;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int tree_evaluate(X509_POLICY_TREE *tree)\\r\\n{\\r\\nint ret, i;\\r\\nX509_POLICY_LEVEL *curr = tree->levels + 1;\\r\\nconst X509_POLICY_CACHE *cache;\\r\\nfor (i = 1; i < tree->nlevel; i++, curr++) {\\r\\ncache = policy_cache_set(curr->cert);\\r\\nif (!tree_link_nodes(curr, cache))\\r\\nreturn 0;\\r\\nif (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)\\r\\n&& !tree_link_any(curr, cache, tree))\\r\\nreturn 0;\\r\\ntree_print(\"before tree_prune()\", tree, curr);\\r\\nret = tree_prune(tree, curr);\\r\\nif (ret != 1)\\r\\nreturn ret;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void exnode_free(X509_POLICY_NODE *node)\\r\\n{\\r\\nif (node->data && (node->data->flags & POLICY_DATA_FLAG_EXTRA_NODE))\\r\\nOPENSSL_free(node);\\r\\n}\\r\\nvoid X509_policy_tree_free(X509_POLICY_TREE *tree)\\r\\n{\\r\\nX509_POLICY_LEVEL *curr;\\r\\nint i;\\r\\nif (!tree)\\r\\nreturn;\\r\\nsk_X509_POLICY_NODE_free(tree->auth_policies);\\r\\nsk_X509_POLICY_NODE_pop_free(tree->user_policies, exnode_free);\\r\\nfor (i = 0, curr = tree->levels; i < tree->nlevel; i++, curr++) {\\r\\nif (curr->cert)\\r\\nX509_free(curr->cert);\\r\\nif (curr->nodes)\\r\\nsk_X509_POLICY_NODE_pop_free(curr->nodes, policy_node_free);\\r\\nif (curr->anyPolicy)\\r\\npolicy_node_free(curr->anyPolicy);\\r\\n}\\r\\nif (tree->extra_data)\\r\\nsk_X509_POLICY_DATA_pop_free(tree->extra_data, policy_data_free);\\r\\nOPENSSL_free(tree->levels);\\r\\nOPENSSL_free(tree);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_sha256_c", "target": 0, "func": "unsigned char *SHA224(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA256_CTX c;\\r\\nstatic unsigned char m[SHA224_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nSHA224_Init(&c);\\r\\nSHA256_Update(&c, d, n);\\r\\nSHA256_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}\\r\\nunsigned char *SHA256(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA256_CTX c;\\r\\nstatic unsigned char m[SHA256_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nSHA256_Init(&c);\\r\\nSHA256_Update(&c, d, n);\\r\\nSHA256_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}\\r\\nint SHA224_Update(SHA256_CTX *c, const void *data, size_t len)\\r\\n{\\r\\nreturn SHA256_Update(c, data, len);\\r\\n}\\r\\nint SHA224_Final(unsigned char *md, SHA256_CTX *c)\\r\\n{\\r\\nreturn SHA256_Final(md, c);\\r\\n}\\r\\nstatic void sha256_block_data_order(SHA256_CTX *ctx, const void *in,\\r\\nsize_t num)\\r\\n{\\r\\nunsigned MD32_REG_T a, b, c, d, e, f, g, h, s0, s1, T1, T2;\\r\\nSHA_LONG X[16], l;\\r\\nint i;\\r\\nconst unsigned char *data = in;\\r\\nwhile (num--) {\\r\\na = ctx->h[0];\\r\\nb = ctx->h[1];\\r\\nc = ctx->h[2];\\r\\nd = ctx->h[3];\\r\\ne = ctx->h[4];\\r\\nf = ctx->h[5];\\r\\ng = ctx->h[6];\\r\\nh = ctx->h[7];\\r\\nfor (i = 0; i < 16; i++) {\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[i] = l;\\r\\nT1 += h + Sigma1(e) + Ch(e, f, g) + K256[i];\\r\\nT2 = Sigma0(a) + Maj(a, b, c);\\r\\nh = g;\\r\\ng = f;\\r\\nf = e;\\r\\ne = d + T1;\\r\\nd = c;\\r\\nc = b;\\r\\nb = a;\\r\\na = T1 + T2;\\r\\n}\\r\\nfor (; i < 64; i++) {\\r\\ns0 = X[(i + 1) & 0x0f];\\r\\ns0 = sigma0(s0);\\r\\ns1 = X[(i + 14) & 0x0f];\\r\\ns1 = sigma1(s1);\\r\\nT1 = X[i & 0xf] += s0 + s1 + X[(i + 9) & 0xf];\\r\\nT1 += h + Sigma1(e) + Ch(e, f, g) + K256[i];\\r\\nT2 = Sigma0(a) + Maj(a, b, c);\\r\\nh = g;\\r\\ng = f;\\r\\nf = e;\\r\\ne = d + T1;\\r\\nd = c;\\r\\nc = b;\\r\\nb = a;\\r\\na = T1 + T2;\\r\\n}\\r\\nctx->h[0] += a;\\r\\nctx->h[1] += b;\\r\\nctx->h[2] += c;\\r\\nctx->h[3] += d;\\r\\nctx->h[4] += e;\\r\\nctx->h[5] += f;\\r\\nctx->h[6] += g;\\r\\nctx->h[7] += h;\\r\\n}\\r\\n}\\r\\nstatic void sha256_block_data_order(SHA256_CTX *ctx, const void *in,\\r\\nsize_t num)\\r\\n{\\r\\nunsigned MD32_REG_T a, b, c, d, e, f, g, h, s0, s1, T1;\\r\\nSHA_LONG X[16];\\r\\nint i;\\r\\nconst unsigned char *data = in;\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nwhile (num--) {\\r\\na = ctx->h[0];\\r\\nb = ctx->h[1];\\r\\nc = ctx->h[2];\\r\\nd = ctx->h[3];\\r\\ne = ctx->h[4];\\r\\nf = ctx->h[5];\\r\\ng = ctx->h[6];\\r\\nh = ctx->h[7];\\r\\nif (!is_endian.little && sizeof(SHA_LONG) == 4\\r\\n&& ((size_t)in % 4) == 0) {\\r\\nconst SHA_LONG *W = (const SHA_LONG *)data;\\r\\nT1 = X[0] = W[0];\\r\\nROUND_00_15(0, a, b, c, d, e, f, g, h);\\r\\nT1 = X[1] = W[1];\\r\\nROUND_00_15(1, h, a, b, c, d, e, f, g);\\r\\nT1 = X[2] = W[2];\\r\\nROUND_00_15(2, g, h, a, b, c, d, e, f);\\r\\nT1 = X[3] = W[3];\\r\\nROUND_00_15(3, f, g, h, a, b, c, d, e);\\r\\nT1 = X[4] = W[4];\\r\\nROUND_00_15(4, e, f, g, h, a, b, c, d);\\r\\nT1 = X[5] = W[5];\\r\\nROUND_00_15(5, d, e, f, g, h, a, b, c);\\r\\nT1 = X[6] = W[6];\\r\\nROUND_00_15(6, c, d, e, f, g, h, a, b);\\r\\nT1 = X[7] = W[7];\\r\\nROUND_00_15(7, b, c, d, e, f, g, h, a);\\r\\nT1 = X[8] = W[8];\\r\\nROUND_00_15(8, a, b, c, d, e, f, g, h);\\r\\nT1 = X[9] = W[9];\\r\\nROUND_00_15(9, h, a, b, c, d, e, f, g);\\r\\nT1 = X[10] = W[10];\\r\\nROUND_00_15(10, g, h, a, b, c, d, e, f);\\r\\nT1 = X[11] = W[11];\\r\\nROUND_00_15(11, f, g, h, a, b, c, d, e);\\r\\nT1 = X[12] = W[12];\\r\\nROUND_00_15(12, e, f, g, h, a, b, c, d);\\r\\nT1 = X[13] = W[13];\\r\\nROUND_00_15(13, d, e, f, g, h, a, b, c);\\r\\nT1 = X[14] = W[14];\\r\\nROUND_00_15(14, c, d, e, f, g, h, a, b);\\r\\nT1 = X[15] = W[15];\\r\\nROUND_00_15(15, b, c, d, e, f, g, h, a);\\r\\ndata += SHA256_CBLOCK;\\r\\n} else {\\r\\nSHA_LONG l;\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[0] = l;\\r\\nROUND_00_15(0, a, b, c, d, e, f, g, h);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[1] = l;\\r\\nROUND_00_15(1, h, a, b, c, d, e, f, g);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[2] = l;\\r\\nROUND_00_15(2, g, h, a, b, c, d, e, f);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[3] = l;\\r\\nROUND_00_15(3, f, g, h, a, b, c, d, e);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[4] = l;\\r\\nROUND_00_15(4, e, f, g, h, a, b, c, d);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[5] = l;\\r\\nROUND_00_15(5, d, e, f, g, h, a, b, c);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[6] = l;\\r\\nROUND_00_15(6, c, d, e, f, g, h, a, b);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[7] = l;\\r\\nROUND_00_15(7, b, c, d, e, f, g, h, a);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[8] = l;\\r\\nROUND_00_15(8, a, b, c, d, e, f, g, h);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[9] = l;\\r\\nROUND_00_15(9, h, a, b, c, d, e, f, g);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[10] = l;\\r\\nROUND_00_15(10, g, h, a, b, c, d, e, f);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[11] = l;\\r\\nROUND_00_15(11, f, g, h, a, b, c, d, e);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[12] = l;\\r\\nROUND_00_15(12, e, f, g, h, a, b, c, d);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[13] = l;\\r\\nROUND_00_15(13, d, e, f, g, h, a, b, c);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[14] = l;\\r\\nROUND_00_15(14, c, d, e, f, g, h, a, b);\\r\\nHOST_c2l(data, l);\\r\\nT1 = X[15] = l;\\r\\nROUND_00_15(15, b, c, d, e, f, g, h, a);\\r\\n}\\r\\nfor (i = 16; i < 64; i += 8) {\\r\\nROUND_16_63(i + 0, a, b, c, d, e, f, g, h, X);\\r\\nROUND_16_63(i + 1, h, a, b, c, d, e, f, g, X);\\r\\nROUND_16_63(i + 2, g, h, a, b, c, d, e, f, X);\\r\\nROUND_16_63(i + 3, f, g, h, a, b, c, d, e, X);\\r\\nROUND_16_63(i + 4, e, f, g, h, a, b, c, d, X);\\r\\nROUND_16_63(i + 5, d, e, f, g, h, a, b, c, X);\\r\\nROUND_16_63(i + 6, c, d, e, f, g, h, a, b, X);\\r\\nROUND_16_63(i + 7, b, c, d, e, f, g, h, a, X);\\r\\n}\\r\\nctx->h[0] += a;\\r\\nctx->h[1] += b;\\r\\nctx->h[2] += c;\\r\\nctx->h[3] += d;\\r\\nctx->h[4] += e;\\r\\nctx->h[5] += f;\\r\\nctx->h[6] += g;\\r\\nctx->h[7] += h;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_s_server_c", "target": 0, "func": "static DH *get_dh512(void)\\r\\n{\\r\\nDH *dh = NULL;\\r\\nif ((dh = DH_new()) == NULL)\\r\\nreturn (NULL);\\r\\ndh->p = BN_bin2bn(dh512_p, sizeof(dh512_p), NULL);\\r\\ndh->g = BN_bin2bn(dh512_g, sizeof(dh512_g), NULL);\\r\\nif ((dh->p == NULL) || (dh->g == NULL))\\r\\nreturn (NULL);\\r\\nreturn (dh);\\r\\n}\\r\\nstatic unsigned int psk_server_cb(SSL *ssl, const char *identity,\\r\\nunsigned char *psk,\\r\\nunsigned int max_psk_len)\\r\\n{\\r\\nunsigned int psk_len = 0;\\r\\nint ret;\\r\\nBIGNUM *bn = NULL;\\r\\nif (s_debug)\\r\\nBIO_printf(bio_s_out, \"psk_server_cb\\n\");\\r\\nif (!identity) {\\r\\nBIO_printf(bio_err, \"Error: client did not send PSK identity\\n\");\\r\\ngoto out_err;\\r\\n}\\r\\nif (s_debug)\\r\\nBIO_printf(bio_s_out, \"identity_len=%d identity=%s\\n\",\\r\\nidentity ? (int)strlen(identity) : 0, identity);\\r\\nif (strcmp(identity, psk_identity) != 0) {\\r\\nBIO_printf(bio_s_out, \"PSK error: client identity not found\"\\r\\n\" (got '%s' expected '%s')\\n\", identity, psk_identity);\\r\\ngoto out_err;\\r\\n}\\r\\nif (s_debug)\\r\\nBIO_printf(bio_s_out, \"PSK client identity found\\n\");\\r\\nret = BN_hex2bn(&bn, psk_key);\\r\\nif (!ret) {\\r\\nBIO_printf(bio_err, \"Could not convert PSK key '%s' to BIGNUM\\n\",\\r\\npsk_key);\\r\\nif (bn)\\r\\nBN_free(bn);\\r\\nreturn 0;\\r\\n}\\r\\nif (BN_num_bytes(bn) > (int)max_psk_len) {\\r\\nBIO_printf(bio_err,\\r\\n\"psk buffer of callback is too small (%d) for key (%d)\\n\",\\r\\nmax_psk_len, BN_num_bytes(bn));\\r\\nBN_free(bn);\\r\\nreturn 0;\\r\\n}\\r\\nret = BN_bn2bin(bn, psk);\\r\\nBN_free(bn);\\r\\nif (ret < 0)\\r\\ngoto out_err;\\r\\npsk_len = (unsigned int)ret;\\r\\nif (s_debug)\\r\\nBIO_printf(bio_s_out, \"fetched PSK len=%d\\n\", psk_len);\\r\\nreturn psk_len;\\r\\nout_err:\\r\\nif (s_debug)\\r\\nBIO_printf(bio_err, \"Error in PSK server callback\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nstatic int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)\\r\\n{\\r\\nsrpsrvparm *p = (srpsrvparm *) arg;\\r\\nif (p->login == NULL && p->user == NULL) {\\r\\np->login = SSL_get_srp_username(s);\\r\\nBIO_printf(bio_err, \"SRP username = \\\"%s\\\"\\n\", p->login);\\r\\nreturn (-1);\\r\\n}\\r\\nif (p->user == NULL) {\\r\\nBIO_printf(bio_err, \"User %s doesn't exist\\n\", p->login);\\r\\nreturn SSL3_AL_FATAL;\\r\\n}\\r\\nif (SSL_set_srp_server_param\\r\\n(s, p->user->N, p->user->g, p->user->s, p->user->v,\\r\\np->user->info) < 0) {\\r\\n*ad = SSL_AD_INTERNAL_ERROR;\\r\\nreturn SSL3_AL_FATAL;\\r\\n}\\r\\nBIO_printf(bio_err,\\r\\n\"SRP parameters set: username = \\\"%s\\\" info=\\\"%s\\\" \\n\",\\r\\np->login, p->user->info);\\r\\np->user = NULL;\\r\\np->login = NULL;\\r\\nreturn SSL_ERROR_NONE;\\r\\n}\\r\\nstatic void s_server_init(void)\\r\\n{\\r\\naccept_socket = -1;\\r\\ns_server_verify = SSL_VERIFY_NONE;\\r\\ns_dcert_file = NULL;\\r\\ns_dkey_file = NULL;\\r\\ns_dchain_file = NULL;\\r\\ns_cert_file = TEST_CERT;\\r\\ns_key_file = NULL;\\r\\ns_chain_file = NULL;\\r\\n# ifndef OPENSSL_NO_TLSEXT\\r\\ns_cert_file2 = TEST_CERT2;\\r\\ns_key_file2 = NULL;\\r\\nctx2 = NULL;\\r\\n# endif\\r\\n# ifdef FIONBIO\\r\\ns_nbio = 0;\\r\\n# endif\\r\\ns_nbio_test = 0;\\r\\nctx = NULL;\\r\\nwww = 0;\\r\\nbio_s_out = NULL;\\r\\ns_debug = 0;\\r\\ns_msg = 0;\\r\\ns_quiet = 0;\\r\\ns_brief = 0;\\r\\nhack = 0;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nengine_id = NULL;\\r\\n# endif\\r\\n}\\r\\nstatic void sv_usage(void)\\r\\n{\\r\\nBIO_printf(bio_err, \"usage: s_server [args ...]\\n\");\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -accept arg - port to accept on (default is %d)\\n\", PORT);\\r\\nBIO_printf(bio_err,\\r\\n\" -verify_host host - check peer certificate matches \\\"host\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -verify_email email - check peer certificate matches \\\"email\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -verify_ip ipaddr - check peer certificate matches \\\"ipaddr\\\"\\n\");\\r\\nBIO_printf(bio_err, \" -context arg - set session ID context\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -verify arg - turn on peer certificate verification\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -Verify arg - turn on peer certificate verification, must have a cert.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -verify_return_error - return verification errors\\n\");\\r\\nBIO_printf(bio_err, \" -cert arg - certificate file to use\\n\");\\r\\nBIO_printf(bio_err, \" (default is %s)\\n\", TEST_CERT);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nBIO_printf(bio_err,\\r\\n\" -serverinfo arg - PEM serverinfo file for certificate\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -auth - send and receive RFC 5878 TLS auth extensions and supplemental data\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -auth_require_reneg - Do not send TLS auth extensions until renegotiation\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\\r\\n\" -no_resumption_on_reneg - set SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION flag\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -crl_check - check the peer certificate has not been revoked by its CA.\\n\"\\r\\n\" The CRL(s) are appended to the certificate file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -crl_check_all - check the peer certificate has not been revoked by its CA\\n\"\\r\\n\" or any other CRL in the CA chain. CRL(s) are appened to the\\n\"\\r\\n\" the certificate file.\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -certform arg - certificate format (PEM or DER) PEM default\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -key arg - Private Key file to use, in cert file if\\n\");\\r\\nBIO_printf(bio_err, \" not specified (default is %s)\\n\",\\r\\nTEST_CERT);\\r\\nBIO_printf(bio_err,\\r\\n\" -keyform arg - key format (PEM, DER or ENGINE) PEM default\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -pass arg - private key file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -dcert arg - second certificate file to use (usually for DSA)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -dcertform x - second certificate format (PEM or DER) PEM default\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -dkey arg - second private key file to use (usually for DSA)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -dkeyform arg - second key format (PEM, DER or ENGINE) PEM default\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -dpass arg - second private key file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -dhparam arg - DH parameter file to use, in cert file if not specified\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" or a default set of parameters is used\\n\");\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nBIO_printf(bio_err,\\r\\n\" -named_curve arg - Elliptic curve name to use for ephemeral ECDH keys.\\n\"\\r\\n\" Use \\\"openssl ecparam -list_curves\\\" for all names\\n\"\\r\\n\" (default is nistp256).\\n\");\\r\\n#endif\\r\\n#ifdef FIONBIO\\r\\nBIO_printf(bio_err, \" -nbio - Run with non-blocking IO\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\\r\\n\" -nbio_test - test with the non-blocking test bio\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -crlf - convert LF from terminal into CRLF\\n\");\\r\\nBIO_printf(bio_err, \" -debug - Print more output\\n\");\\r\\nBIO_printf(bio_err, \" -msg - Show protocol messages\\n\");\\r\\nBIO_printf(bio_err, \" -state - Print the SSL states\\n\");\\r\\nBIO_printf(bio_err, \" -CApath arg - PEM format directory of CA's\\n\");\\r\\nBIO_printf(bio_err, \" -CAfile arg - PEM format file of CA's\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -nocert - Don't use any certificates (Anon-DH)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -cipher arg - play with 'openssl ciphers' to see what goes here\\n\");\\r\\nBIO_printf(bio_err, \" -serverpref - Use server's cipher preferences\\n\");\\r\\nBIO_printf(bio_err, \" -quiet - No server output\\n\");\\r\\nBIO_printf(bio_err, \" -no_tmp_rsa - Do not generate a tmp RSA key\\n\");\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nBIO_printf(bio_err, \" -psk_hint arg - PSK identity hint to use\\n\");\\r\\nBIO_printf(bio_err, \" -psk arg - PSK in hex (without 0x)\\n\");\\r\\n# ifndef OPENSSL_NO_JPAKE\\r\\nBIO_printf(bio_err, \" -jpake arg - JPAKE secret to use\\n\");\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nBIO_printf(bio_err, \" -srpvfile file - The verifier file for SRP\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -srpuserseed string - A seed string for a default user salt.\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \" -ssl2 - Just talk SSLv2\\n\");\\r\\n#ifndef OPENSSL_NO_SSL3_METHOD\\r\\nBIO_printf(bio_err, \" -ssl3 - Just talk SSLv3\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \" -tls1_2 - Just talk TLSv1.2\\n\");\\r\\nBIO_printf(bio_err, \" -tls1_1 - Just talk TLSv1.1\\n\");\\r\\nBIO_printf(bio_err, \" -tls1 - Just talk TLSv1\\n\");\\r\\nBIO_printf(bio_err, \" -dtls1 - Just talk DTLSv1\\n\");\\r\\nBIO_printf(bio_err, \" -dtls1_2 - Just talk DTLSv1.2\\n\");\\r\\nBIO_printf(bio_err, \" -timeout - Enable timeouts\\n\");\\r\\nBIO_printf(bio_err, \" -mtu - Set link layer MTU\\n\");\\r\\nBIO_printf(bio_err, \" -chain - Read a certificate chain\\n\");\\r\\nBIO_printf(bio_err, \" -no_ssl2 - Just disable SSLv2\\n\");\\r\\nBIO_printf(bio_err, \" -no_ssl3 - Just disable SSLv3\\n\");\\r\\nBIO_printf(bio_err, \" -no_tls1 - Just disable TLSv1\\n\");\\r\\nBIO_printf(bio_err, \" -no_tls1_1 - Just disable TLSv1.1\\n\");\\r\\nBIO_printf(bio_err, \" -no_tls1_2 - Just disable TLSv1.2\\n\");\\r\\n#ifndef OPENSSL_NO_DH\\r\\nBIO_printf(bio_err, \" -no_dhe - Disable ephemeral DH\\n\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nBIO_printf(bio_err, \" -no_ecdhe - Disable ephemeral ECDH\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err, \" -bugs - Turn on SSL bug compatibility\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -hack - workaround for early Netscape code\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -www - Respond to a 'GET /' with a status page\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -WWW - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -HTTP - Respond to a 'GET /<path> HTTP/1.0' with file ./<path>\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" with the assumption it contains a complete HTTP response.\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine id - Initialise and use the specified engine\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\\r\\n\" -id_prefix arg - Generate SSL/TLS session IDs prefixed by 'arg'\\n\");\\r\\nBIO_printf(bio_err, \" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nBIO_printf(bio_err,\\r\\n\" -servername host - servername for HostName TLS extension\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -servername_fatal - on mismatch send fatal alert (default warning alert)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -cert2 arg - certificate file to use for servername\\n\");\\r\\nBIO_printf(bio_err, \" (default is %s)\\n\", TEST_CERT2);\\r\\nBIO_printf(bio_err,\\r\\n\" -key2 arg - Private Key file to use for servername, in cert file if\\n\");\\r\\nBIO_printf(bio_err, \" not specified (default is %s)\\n\",\\r\\nTEST_CERT2);\\r\\nBIO_printf(bio_err,\\r\\n\" -tlsextdebug - hex dump of all TLS extensions received\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -no_ticket - disable use of RFC4507bis session tickets\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -legacy_renegotiation - enable use of legacy renegotiation (dangerous)\\n\");\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nBIO_printf(bio_err,\\r\\n\" -nextprotoneg arg - set the advertised protocols for the NPN extension (comma-separated list)\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SRTP\\r\\nBIO_printf(bio_err,\\r\\n\" -use_srtp profiles - Offer SRTP key management with a colon-separated profile list\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err,\\r\\n\" -alpn arg - set the advertised protocols for the ALPN extension (comma-separated list)\\n\");\\r\\n#endif\\r\\nBIO_printf(bio_err,\\r\\n\" -keymatexport label - Export keying material using label\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -keymatexportlen len - Export len bytes of keying material (default 20)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -status - respond to certificate status requests\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -status_verbose - enable status request verbose printout\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -status_timeout n - status request responder timeout\\n\");\\r\\nBIO_printf(bio_err, \" -status_url URL - status request fallback URL\\n\");\\r\\n}\\r\\nBIO_METHOD *BIO_f_ebcdic_filter()\\r\\n{\\r\\nreturn (&methods_ebcdic);\\r\\n}\\r\\nstatic int ebcdic_new(BIO *bi)\\r\\n{\\r\\nEBCDIC_OUTBUFF *wbuf;\\r\\nwbuf = (EBCDIC_OUTBUFF *) OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + 1024);\\r\\nwbuf->alloced = 1024;\\r\\nwbuf->buff[0] = '\\0';\\r\\nbi->ptr = (char *)wbuf;\\r\\nbi->init = 1;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int ebcdic_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (a->ptr != NULL)\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr = NULL;\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int ebcdic_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nif (out == NULL || outl == 0)\\r\\nreturn (0);\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_read(b->next_bio, out, outl);\\r\\nif (ret > 0)\\r\\nascii2ebcdic(out, out, ret);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ebcdic_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nEBCDIC_OUTBUFF *wbuf;\\r\\nint ret = 0;\\r\\nint num;\\r\\nunsigned char n;\\r\\nif ((in == NULL) || (inl <= 0))\\r\\nreturn (0);\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nwbuf = (EBCDIC_OUTBUFF *) b->ptr;\\r\\nif (inl > (num = wbuf->alloced)) {\\r\\nnum = num + num;\\r\\nif (num < inl)\\r\\nnum = inl;\\r\\nOPENSSL_free(wbuf);\\r\\nwbuf =\\r\\n(EBCDIC_OUTBUFF *) OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + num);\\r\\nwbuf->alloced = num;\\r\\nwbuf->buff[0] = '\\0';\\r\\nb->ptr = (char *)wbuf;\\r\\n}\\r\\nebcdic2ascii(wbuf->buff, in, inl);\\r\\nret = BIO_write(b->next_bio, wbuf->buff, inl);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long ebcdic_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_DUP:\\r\\nret = 0L;\\r\\nbreak;\\r\\ndefault:\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ebcdic_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint i, ret = 0;\\r\\nif (bp->next_bio == NULL)\\r\\nreturn (0);\\r\\nfor (i = 0; i < size - 1; ++i) {\\r\\nret = ebcdic_read(bp, &buf[i], 1);\\r\\nif (ret <= 0)\\r\\nbreak;\\r\\nelse if (buf[i] == '\\n') {\\r\\n++i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (i < size)\\r\\nbuf[i] = '\\0';\\r\\nreturn (ret < 0 && i == 0) ? ret : i;\\r\\n}\\r\\nstatic int ebcdic_puts(BIO *bp, const char *str)\\r\\n{\\r\\nif (bp->next_bio == NULL)\\r\\nreturn (0);\\r\\nreturn ebcdic_write(bp, str, strlen(str));\\r\\n}\\r\\nstatic int MS_CALLBACK ssl_servername_cb(SSL *s, int *ad, void *arg)\\r\\n{\\r\\ntlsextctx *p = (tlsextctx *) arg;\\r\\nconst char *servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);\\r\\nif (servername && p->biodebug)\\r\\nBIO_printf(p->biodebug, \"Hostname in TLS extension: \\\"%s\\\"\\n\",\\r\\nservername);\\r\\nif (!p->servername)\\r\\nreturn SSL_TLSEXT_ERR_NOACK;\\r\\nif (servername) {\\r\\nif (strcasecmp(servername, p->servername))\\r\\nreturn p->extension_error;\\r\\nif (ctx2) {\\r\\nBIO_printf(p->biodebug, \"Switching server context.\\n\");\\r\\nSSL_set_SSL_CTX(s, ctx2);\\r\\n}\\r\\n}\\r\\nreturn SSL_TLSEXT_ERR_OK;\\r\\n}\\r\\nstatic int cert_status_cb(SSL *s, void *arg)\\r\\n{\\r\\ntlsextstatusctx *srctx = arg;\\r\\nBIO *err = srctx->err;\\r\\nchar *host, *port, *path;\\r\\nint use_ssl;\\r\\nunsigned char *rspder = NULL;\\r\\nint rspderlen;\\r\\nSTACK_OF(OPENSSL_STRING) *aia = NULL;\\r\\nX509 *x = NULL;\\r\\nX509_STORE_CTX inctx;\\r\\nX509_OBJECT obj;\\r\\nOCSP_REQUEST *req = NULL;\\r\\nOCSP_RESPONSE *resp = NULL;\\r\\nOCSP_CERTID *id = NULL;\\r\\nSTACK_OF(X509_EXTENSION) *exts;\\r\\nint ret = SSL_TLSEXT_ERR_NOACK;\\r\\nint i;\\r\\n# if 0\\r\\nSTACK_OF(OCSP_RESPID) *ids;\\r\\nSSL_get_tlsext_status_ids(s, &ids);\\r\\nBIO_printf(err, \"cert_status: received %d ids\\n\",\\r\\nsk_OCSP_RESPID_num(ids));\\r\\n# endif\\r\\nif (srctx->verbose)\\r\\nBIO_puts(err, \"cert_status: callback called\\n\");\\r\\nx = SSL_get_certificate(s);\\r\\naia = X509_get1_ocsp(x);\\r\\nif (aia) {\\r\\nif (!OCSP_parse_url(sk_OPENSSL_STRING_value(aia, 0),\\r\\n&host, &port, &path, &use_ssl)) {\\r\\nBIO_puts(err, \"cert_status: can't parse AIA URL\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (srctx->verbose)\\r\\nBIO_printf(err, \"cert_status: AIA URL: %s\\n\",\\r\\nsk_OPENSSL_STRING_value(aia, 0));\\r\\n} else {\\r\\nif (!srctx->host) {\\r\\nBIO_puts(srctx->err,\\r\\n\"cert_status: no AIA and no default responder URL\\n\");\\r\\ngoto done;\\r\\n}\\r\\nhost = srctx->host;\\r\\npath = srctx->path;\\r\\nport = srctx->port;\\r\\nuse_ssl = srctx->use_ssl;\\r\\n}\\r\\nif (!X509_STORE_CTX_init(&inctx,\\r\\nSSL_CTX_get_cert_store(SSL_get_SSL_CTX(s)),\\r\\nNULL, NULL))\\r\\ngoto err;\\r\\nif (X509_STORE_get_by_subject(&inctx, X509_LU_X509,\\r\\nX509_get_issuer_name(x), &obj) <= 0) {\\r\\nBIO_puts(err, \"cert_status: Can't retrieve issuer certificate.\\n\");\\r\\nX509_STORE_CTX_cleanup(&inctx);\\r\\ngoto done;\\r\\n}\\r\\nreq = OCSP_REQUEST_new();\\r\\nif (!req)\\r\\ngoto err;\\r\\nid = OCSP_cert_to_id(NULL, x, obj.data.x509);\\r\\nX509_free(obj.data.x509);\\r\\nX509_STORE_CTX_cleanup(&inctx);\\r\\nif (!id)\\r\\ngoto err;\\r\\nif (!OCSP_request_add0_id(req, id))\\r\\ngoto err;\\r\\nid = NULL;\\r\\nSSL_get_tlsext_status_exts(s, &exts);\\r\\nfor (i = 0; i < sk_X509_EXTENSION_num(exts); i++) {\\r\\nX509_EXTENSION *ext = sk_X509_EXTENSION_value(exts, i);\\r\\nif (!OCSP_REQUEST_add_ext(req, ext, -1))\\r\\ngoto err;\\r\\n}\\r\\nresp = process_responder(err, req, host, path, port, use_ssl, NULL,\\r\\nsrctx->timeout);\\r\\nif (!resp) {\\r\\nBIO_puts(err, \"cert_status: error querying responder\\n\");\\r\\ngoto done;\\r\\n}\\r\\nrspderlen = i2d_OCSP_RESPONSE(resp, &rspder);\\r\\nif (rspderlen <= 0)\\r\\ngoto err;\\r\\nSSL_set_tlsext_status_ocsp_resp(s, rspder, rspderlen);\\r\\nif (srctx->verbose) {\\r\\nBIO_puts(err, \"cert_status: ocsp response sent:\\n\");\\r\\nOCSP_RESPONSE_print(err, resp, 2);\\r\\n}\\r\\nret = SSL_TLSEXT_ERR_OK;\\r\\ndone:\\r\\nif (ret != SSL_TLSEXT_ERR_OK)\\r\\nERR_print_errors(err);\\r\\nif (aia) {\\r\\nOPENSSL_free(host);\\r\\nOPENSSL_free(path);\\r\\nOPENSSL_free(port);\\r\\nX509_email_free(aia);\\r\\n}\\r\\nif (id)\\r\\nOCSP_CERTID_free(id);\\r\\nif (req)\\r\\nOCSP_REQUEST_free(req);\\r\\nif (resp)\\r\\nOCSP_RESPONSE_free(resp);\\r\\nreturn ret;\\r\\nerr:\\r\\nret = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\ngoto done;\\r\\n}\\r\\nstatic int next_proto_cb(SSL *s, const unsigned char **data,\\r\\nunsigned int *len, void *arg)\\r\\n{\\r\\ntlsextnextprotoctx *next_proto = arg;\\r\\n*data = next_proto->data;\\r\\n*len = next_proto->len;\\r\\nreturn SSL_TLSEXT_ERR_OK;\\r\\n}\\r\\nstatic int alpn_cb(SSL *s, const unsigned char **out, unsigned char *outlen,\\r\\nconst unsigned char *in, unsigned int inlen, void *arg)\\r\\n{\\r\\ntlsextalpnctx *alpn_ctx = arg;\\r\\nif (!s_quiet) {\\r\\nunsigned i;\\r\\nBIO_printf(bio_s_out, \"ALPN protocols advertised by the client: \");\\r\\nfor (i = 0; i < inlen;) {\\r\\nif (i)\\r\\nBIO_write(bio_s_out, \", \", 2);\\r\\nBIO_write(bio_s_out, &in[i + 1], in[i]);\\r\\ni += in[i] + 1;\\r\\n}\\r\\nBIO_write(bio_s_out, \"\\n\", 1);\\r\\n}\\r\\nif (SSL_select_next_proto\\r\\n((unsigned char **)out, outlen, alpn_ctx->data, alpn_ctx->len, in,\\r\\ninlen) != OPENSSL_NPN_NEGOTIATED) {\\r\\nreturn SSL_TLSEXT_ERR_NOACK;\\r\\n}\\r\\nif (!s_quiet) {\\r\\nBIO_printf(bio_s_out, \"ALPN protocols selected: \");\\r\\nBIO_write(bio_s_out, *out, *outlen);\\r\\nBIO_write(bio_s_out, \"\\n\", 1);\\r\\n}\\r\\nreturn SSL_TLSEXT_ERR_OK;\\r\\n}\\r\\nint MAIN(int argc, char *argv[])\\r\\n{\\r\\nX509_VERIFY_PARAM *vpm = NULL;\\r\\nint badarg = 0;\\r\\nshort port = PORT;\\r\\nchar *CApath = NULL, *CAfile = NULL;\\r\\nchar *chCApath = NULL, *chCAfile = NULL;\\r\\nchar *vfyCApath = NULL, *vfyCAfile = NULL;\\r\\nunsigned char *context = NULL;\\r\\nchar *dhfile = NULL;\\r\\nint badop = 0;\\r\\nint ret = 1;\\r\\nint build_chain = 0;\\r\\nint no_tmp_rsa = 0, no_dhe = 0, no_ecdhe = 0, nocert = 0;\\r\\nint state = 0;\\r\\nconst SSL_METHOD *meth = NULL;\\r\\nint socket_type = SOCK_STREAM;\\r\\nENGINE *e = NULL;\\r\\nchar *inrand = NULL;\\r\\nint s_cert_format = FORMAT_PEM, s_key_format = FORMAT_PEM;\\r\\nchar *passarg = NULL, *pass = NULL;\\r\\nchar *dpassarg = NULL, *dpass = NULL;\\r\\nint s_dcert_format = FORMAT_PEM, s_dkey_format = FORMAT_PEM;\\r\\nX509 *s_cert = NULL, *s_dcert = NULL;\\r\\nSTACK_OF(X509) *s_chain = NULL, *s_dchain = NULL;\\r\\nEVP_PKEY *s_key = NULL, *s_dkey = NULL;\\r\\nint no_cache = 0, ext_cache = 0;\\r\\nint rev = 0, naccept = -1;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nEVP_PKEY *s_key2 = NULL;\\r\\nX509 *s_cert2 = NULL;\\r\\ntlsextctx tlsextcbp = { NULL, NULL, SSL_TLSEXT_ERR_ALERT_WARNING };\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nconst char *next_proto_neg_in = NULL;\\r\\ntlsextnextprotoctx next_proto = { NULL, 0 };\\r\\n# endif\\r\\nconst char *alpn_in = NULL;\\r\\ntlsextalpnctx alpn_ctx = { NULL, 0 };\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nstatic char *psk_identity_hint = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nchar *srpuserseed = NULL;\\r\\nchar *srp_verifier_file = NULL;\\r\\n#endif\\r\\nSSL_EXCERT *exc = NULL;\\r\\nSSL_CONF_CTX *cctx = NULL;\\r\\nSTACK_OF(OPENSSL_STRING) *ssl_args = NULL;\\r\\nchar *crl_file = NULL;\\r\\nint crl_format = FORMAT_PEM;\\r\\nint crl_download = 0;\\r\\nSTACK_OF(X509_CRL) *crls = NULL;\\r\\nmeth = SSLv23_server_method();\\r\\nlocal_argc = argc;\\r\\nlocal_argv = argv;\\r\\napps_startup();\\r\\n#ifdef MONOLITH\\r\\ns_server_init();\\r\\n#endif\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ncctx = SSL_CONF_CTX_new();\\r\\nif (!cctx)\\r\\ngoto end;\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_SERVER);\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CMDLINE);\\r\\nverify_depth = 0;\\r\\n#ifdef FIONBIO\\r\\ns_nbio = 0;\\r\\n#endif\\r\\ns_nbio_test = 0;\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif ((strcmp(*argv, \"-port\") == 0) || (strcmp(*argv, \"-accept\") == 0)) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!extract_port(*(++argv), &port))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-naccept\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nnaccept = atol(*(++argv));\\r\\nif (naccept <= 0) {\\r\\nBIO_printf(bio_err, \"bad accept value %s\\n\", *argv);\\r\\ngoto bad;\\r\\n}\\r\\n} else if (strcmp(*argv, \"-verify\") == 0) {\\r\\ns_server_verify = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nverify_depth = atoi(*(++argv));\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err, \"verify depth is %d\\n\", verify_depth);\\r\\n} else if (strcmp(*argv, \"-Verify\") == 0) {\\r\\ns_server_verify =\\r\\nSSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT |\\r\\nSSL_VERIFY_CLIENT_ONCE;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nverify_depth = atoi(*(++argv));\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err,\\r\\n\"verify depth is %d, must return a certificate\\n\",\\r\\nverify_depth);\\r\\n} else if (strcmp(*argv, \"-context\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncontext = (unsigned char *)*(++argv);\\r\\n} else if (strcmp(*argv, \"-cert\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_cert_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-CRL\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncrl_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-crl_download\") == 0)\\r\\ncrl_download = 1;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nelse if (strcmp(*argv, \"-serverinfo\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_serverinfo_file = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-certform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_cert_format = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-key\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_key_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keyform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_key_format = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-pass\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassarg = *(++argv);\\r\\n} else if (strcmp(*argv, \"-cert_chain\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_chain_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-dhparam\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ndhfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-dcertform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_dcert_format = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-dcert\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_dcert_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-dkeyform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_dkey_format = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-dpass\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ndpassarg = *(++argv);\\r\\n} else if (strcmp(*argv, \"-dkey\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_dkey_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-dcert_chain\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_dchain_file = *(++argv);\\r\\n} else if (strcmp(*argv, \"-nocert\") == 0) {\\r\\nnocert = 1;\\r\\n} else if (strcmp(*argv, \"-CApath\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCApath = *(++argv);\\r\\n} else if (strcmp(*argv, \"-chainCApath\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nchCApath = *(++argv);\\r\\n} else if (strcmp(*argv, \"-verifyCApath\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nvfyCApath = *(++argv);\\r\\n} else if (strcmp(*argv, \"-no_cache\") == 0)\\r\\nno_cache = 1;\\r\\nelse if (strcmp(*argv, \"-ext_cache\") == 0)\\r\\next_cache = 1;\\r\\nelse if (strcmp(*argv, \"-CRLform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncrl_format = str2fmt(*(++argv));\\r\\n} else if (args_verify(&argv, &argc, &badarg, bio_err, &vpm)) {\\r\\nif (badarg)\\r\\ngoto bad;\\r\\ncontinue;\\r\\n} else if (args_excert(&argv, &argc, &badarg, bio_err, &exc)) {\\r\\nif (badarg)\\r\\ngoto bad;\\r\\ncontinue;\\r\\n} else if (args_ssl(&argv, &argc, cctx, &badarg, bio_err, &ssl_args)) {\\r\\nif (badarg)\\r\\ngoto bad;\\r\\ncontinue;\\r\\n} else if (strcmp(*argv, \"-verify_return_error\") == 0)\\r\\nverify_return_error = 1;\\r\\nelse if (strcmp(*argv, \"-verify_quiet\") == 0)\\r\\nverify_quiet = 1;\\r\\nelse if (strcmp(*argv, \"-build_chain\") == 0)\\r\\nbuild_chain = 1;\\r\\nelse if (strcmp(*argv, \"-CAfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nCAfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-chainCAfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nchCAfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-verifyCAfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nvfyCAfile = *(++argv);\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nelse if (strcmp(*argv, \"-nbio\") == 0) {\\r\\ns_nbio = 1;\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-nbio_test\") == 0) {\\r\\n#ifdef FIONBIO\\r\\ns_nbio = 1;\\r\\n#endif\\r\\ns_nbio_test = 1;\\r\\n} else if (strcmp(*argv, \"-ign_eof\") == 0)\\r\\ns_ign_eof = 1;\\r\\nelse if (strcmp(*argv, \"-no_ign_eof\") == 0)\\r\\ns_ign_eof = 0;\\r\\nelse if (strcmp(*argv, \"-debug\") == 0) {\\r\\ns_debug = 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nelse if (strcmp(*argv, \"-tlsextdebug\") == 0)\\r\\ns_tlsextdebug = 1;\\r\\nelse if (strcmp(*argv, \"-status\") == 0)\\r\\ns_tlsextstatus = 1;\\r\\nelse if (strcmp(*argv, \"-status_verbose\") == 0) {\\r\\ns_tlsextstatus = 1;\\r\\ntlscstatp.verbose = 1;\\r\\n} else if (!strcmp(*argv, \"-status_timeout\")) {\\r\\ns_tlsextstatus = 1;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ntlscstatp.timeout = atoi(*(++argv));\\r\\n} else if (!strcmp(*argv, \"-status_url\")) {\\r\\ns_tlsextstatus = 1;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!OCSP_parse_url(*(++argv),\\r\\n&tlscstatp.host,\\r\\n&tlscstatp.port,\\r\\n&tlscstatp.path, &tlscstatp.use_ssl)) {\\r\\nBIO_printf(bio_err, \"Error parsing URL\\n\");\\r\\ngoto bad;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-msg\") == 0) {\\r\\ns_msg = 1;\\r\\n} else if (strcmp(*argv, \"-msgfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nbio_s_msg = BIO_new_file(*(++argv), \"w\");\\r\\n}\\r\\n#ifndef OPENSSL_NO_SSL_TRACE\\r\\nelse if (strcmp(*argv, \"-trace\") == 0) {\\r\\ns_msg = 2;\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-hack\") == 0) {\\r\\nhack = 1;\\r\\n} else if (strcmp(*argv, \"-state\") == 0) {\\r\\nstate = 1;\\r\\n} else if (strcmp(*argv, \"-crlf\") == 0) {\\r\\ns_crlf = 1;\\r\\n} else if (strcmp(*argv, \"-quiet\") == 0) {\\r\\ns_quiet = 1;\\r\\n} else if (strcmp(*argv, \"-brief\") == 0) {\\r\\ns_quiet = 1;\\r\\ns_brief = 1;\\r\\nverify_quiet = 1;\\r\\n} else if (strcmp(*argv, \"-no_tmp_rsa\") == 0) {\\r\\nno_tmp_rsa = 1;\\r\\n} else if (strcmp(*argv, \"-no_dhe\") == 0) {\\r\\nno_dhe = 1;\\r\\n} else if (strcmp(*argv, \"-no_ecdhe\") == 0) {\\r\\nno_ecdhe = 1;\\r\\n} else if (strcmp(*argv, \"-no_resume_ephemeral\") == 0) {\\r\\nno_resume_ephemeral = 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nelse if (strcmp(*argv, \"-psk_hint\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npsk_identity_hint = *(++argv);\\r\\n} else if (strcmp(*argv, \"-psk\") == 0) {\\r\\nsize_t i;\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npsk_key = *(++argv);\\r\\nfor (i = 0; i < strlen(psk_key); i++) {\\r\\nif (isxdigit((unsigned char)psk_key[i]))\\r\\ncontinue;\\r\\nBIO_printf(bio_err, \"Not a hex number '%s'\\n\", *argv);\\r\\ngoto bad;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nelse if (strcmp(*argv, \"-srpvfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsrp_verifier_file = *(++argv);\\r\\nmeth = TLSv1_server_method();\\r\\n} else if (strcmp(*argv, \"-srpuserseed\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsrpuserseed = *(++argv);\\r\\nmeth = TLSv1_server_method();\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-rev\") == 0) {\\r\\nrev = 1;\\r\\n} else if (strcmp(*argv, \"-www\") == 0) {\\r\\nwww = 1;\\r\\n} else if (strcmp(*argv, \"-WWW\") == 0) {\\r\\nwww = 2;\\r\\n} else if (strcmp(*argv, \"-HTTP\") == 0) {\\r\\nwww = 3;\\r\\n}\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nelse if (strcmp(*argv, \"-ssl2\") == 0) {\\r\\nno_ecdhe = 1;\\r\\nmeth = SSLv2_server_method();\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3_METHOD\\r\\nelse if (strcmp(*argv, \"-ssl3\") == 0) {\\r\\nmeth = SSLv3_server_method();\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLS1\\r\\nelse if (strcmp(*argv, \"-tls1\") == 0) {\\r\\nmeth = TLSv1_server_method();\\r\\n} else if (strcmp(*argv, \"-tls1_1\") == 0) {\\r\\nmeth = TLSv1_1_server_method();\\r\\n} else if (strcmp(*argv, \"-tls1_2\") == 0) {\\r\\nmeth = TLSv1_2_server_method();\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DTLS1\\r\\nelse if (strcmp(*argv, \"-dtls\") == 0) {\\r\\nmeth = DTLS_server_method();\\r\\nsocket_type = SOCK_DGRAM;\\r\\n} else if (strcmp(*argv, \"-dtls1\") == 0) {\\r\\nmeth = DTLSv1_server_method();\\r\\nsocket_type = SOCK_DGRAM;\\r\\n} else if (strcmp(*argv, \"-dtls1_2\") == 0) {\\r\\nmeth = DTLSv1_2_server_method();\\r\\nsocket_type = SOCK_DGRAM;\\r\\n} else if (strcmp(*argv, \"-timeout\") == 0)\\r\\nenable_timeouts = 1;\\r\\nelse if (strcmp(*argv, \"-mtu\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsocket_mtu = atol(*(++argv));\\r\\n} else if (strcmp(*argv, \"-chain\") == 0)\\r\\ncert_chain = 1;\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-id_prefix\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsession_id_prefix = *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine_id = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninrand = *(++argv);\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nelse if (strcmp(*argv, \"-servername\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ntlsextcbp.servername = *(++argv);\\r\\n} else if (strcmp(*argv, \"-servername_fatal\") == 0) {\\r\\ntlsextcbp.extension_error = SSL_TLSEXT_ERR_ALERT_FATAL;\\r\\n} else if (strcmp(*argv, \"-cert2\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_cert_file2 = *(++argv);\\r\\n} else if (strcmp(*argv, \"-key2\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ns_key_file2 = *(++argv);\\r\\n}\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nelse if (strcmp(*argv, \"-nextprotoneg\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nnext_proto_neg_in = *(++argv);\\r\\n}\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-alpn\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nalpn_in = *(++argv);\\r\\n}\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)\\r\\nelse if (strcmp(*argv, \"-jpake\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\njpake_secret = *(++argv);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRTP\\r\\nelse if (strcmp(*argv, \"-use_srtp\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsrtp_profiles = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-keymatexport\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeymatexportlabel = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keymatexportlen\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeymatexportlen = atoi(*(++argv));\\r\\nif (keymatexportlen == 0)\\r\\ngoto bad;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadop = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badop) {\\r\\nbad:\\r\\nsv_usage();\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DTLS1\\r\\nif (www && socket_type == SOCK_DGRAM) {\\r\\nBIO_printf(bio_err, \"Can't use -HTTP, -www or -WWW with DTLS\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_JPAKE) && !defined(OPENSSL_NO_PSK)\\r\\nif (jpake_secret) {\\r\\nif (psk_key) {\\r\\nBIO_printf(bio_err, \"Can't use JPAKE and PSK together\\n\");\\r\\ngoto end;\\r\\n}\\r\\npsk_identity = \"JPAKE\";\\r\\n}\\r\\n#endif\\r\\nSSL_load_error_strings();\\r\\nOpenSSL_add_ssl_algorithms();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine_id, 1);\\r\\n#endif\\r\\nif (!app_passwd(bio_err, passarg, dpassarg, &pass, &dpass)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (s_key_file == NULL)\\r\\ns_key_file = s_cert_file;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s_key_file2 == NULL)\\r\\ns_key_file2 = s_cert_file2;\\r\\n#endif\\r\\nif (!load_excert(&exc, bio_err))\\r\\ngoto end;\\r\\nif (nocert == 0) {\\r\\ns_key = load_key(bio_err, s_key_file, s_key_format, 0, pass, e,\\r\\n\"server certificate private key file\");\\r\\nif (!s_key) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ns_cert = load_cert(bio_err, s_cert_file, s_cert_format,\\r\\nNULL, e, \"server certificate file\");\\r\\nif (!s_cert) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (s_chain_file) {\\r\\ns_chain = load_certs(bio_err, s_chain_file, FORMAT_PEM,\\r\\nNULL, e, \"server certificate chain\");\\r\\nif (!s_chain)\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (tlsextcbp.servername) {\\r\\ns_key2 = load_key(bio_err, s_key_file2, s_key_format, 0, pass, e,\\r\\n\"second server certificate private key file\");\\r\\nif (!s_key2) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ns_cert2 = load_cert(bio_err, s_cert_file2, s_cert_format,\\r\\nNULL, e, \"second server certificate file\");\\r\\nif (!s_cert2) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n#endif\\r\\n}\\r\\n#if !defined(OPENSSL_NO_TLSEXT)\\r\\n# if !defined(OPENSSL_NO_NEXTPROTONEG)\\r\\nif (next_proto_neg_in) {\\r\\nunsigned short len;\\r\\nnext_proto.data = next_protos_parse(&len, next_proto_neg_in);\\r\\nif (next_proto.data == NULL)\\r\\ngoto end;\\r\\nnext_proto.len = len;\\r\\n} else {\\r\\nnext_proto.data = NULL;\\r\\n}\\r\\n# endif\\r\\nalpn_ctx.data = NULL;\\r\\nif (alpn_in) {\\r\\nunsigned short len;\\r\\nalpn_ctx.data = next_protos_parse(&len, alpn_in);\\r\\nif (alpn_ctx.data == NULL)\\r\\ngoto end;\\r\\nalpn_ctx.len = len;\\r\\n}\\r\\n#endif\\r\\nif (crl_file) {\\r\\nX509_CRL *crl;\\r\\ncrl = load_crl(crl_file, crl_format);\\r\\nif (!crl) {\\r\\nBIO_puts(bio_err, \"Error loading CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ncrls = sk_X509_CRL_new_null();\\r\\nif (!crls || !sk_X509_CRL_push(crls, crl)) {\\r\\nBIO_puts(bio_err, \"Error adding CRL\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nX509_CRL_free(crl);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (s_dcert_file) {\\r\\nif (s_dkey_file == NULL)\\r\\ns_dkey_file = s_dcert_file;\\r\\ns_dkey = load_key(bio_err, s_dkey_file, s_dkey_format,\\r\\n0, dpass, e, \"second certificate private key file\");\\r\\nif (!s_dkey) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\ns_dcert = load_cert(bio_err, s_dcert_file, s_dcert_format,\\r\\nNULL, e, \"second server certificate file\");\\r\\nif (!s_dcert) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (s_dchain_file) {\\r\\ns_dchain = load_certs(bio_err, s_dchain_file, FORMAT_PEM,\\r\\nNULL, e, \"second server certificate chain\");\\r\\nif (!s_dchain)\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL\\r\\n&& !RAND_status()) {\\r\\nBIO_printf(bio_err,\\r\\n\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nif (bio_s_out == NULL) {\\r\\nif (s_quiet && !s_debug) {\\r\\nbio_s_out = BIO_new(BIO_s_null());\\r\\nif (s_msg && !bio_s_msg)\\r\\nbio_s_msg = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n} else {\\r\\nif (bio_s_out == NULL)\\r\\nbio_s_out = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n}\\r\\n}\\r\\n#if !defined(OPENSSL_NO_RSA) || !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_ECDSA)\\r\\nif (nocert)\\r\\n#endif\\r\\n{\\r\\ns_cert_file = NULL;\\r\\ns_key_file = NULL;\\r\\ns_dcert_file = NULL;\\r\\ns_dkey_file = NULL;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\ns_cert_file2 = NULL;\\r\\ns_key_file2 = NULL;\\r\\n#endif\\r\\n}\\r\\nctx = SSL_CTX_new(meth);\\r\\nif (ctx == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (session_id_prefix) {\\r\\nif (strlen(session_id_prefix) >= 32)\\r\\nBIO_printf(bio_err,\\r\\n\"warning: id_prefix is too long, only one new session will be possible\\n\");\\r\\nelse if (strlen(session_id_prefix) >= 16)\\r\\nBIO_printf(bio_err,\\r\\n\"warning: id_prefix is too long if you use SSLv2\\n\");\\r\\nif (!SSL_CTX_set_generate_session_id(ctx, generate_session_id)) {\\r\\nBIO_printf(bio_err, \"error setting 'id_prefix'\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err, \"id_prefix '%s' set.\\n\", session_id_prefix);\\r\\n}\\r\\nSSL_CTX_set_quiet_shutdown(ctx, 1);\\r\\nif (hack)\\r\\nSSL_CTX_set_options(ctx, SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);\\r\\nif (exc)\\r\\nssl_ctx_set_excert(ctx, exc);\\r\\nif (socket_type == SOCK_DGRAM)\\r\\nSSL_CTX_set_read_ahead(ctx, 1);\\r\\nif (state)\\r\\nSSL_CTX_set_info_callback(ctx, apps_ssl_info_callback);\\r\\nif (no_cache)\\r\\nSSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);\\r\\nelse if (ext_cache)\\r\\ninit_session_cache_ctx(ctx);\\r\\nelse\\r\\nSSL_CTX_sess_set_cache_size(ctx, 128);\\r\\n#ifndef OPENSSL_NO_SRTP\\r\\nif (srtp_profiles != NULL)\\r\\nSSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles);\\r\\n#endif\\r\\n#if 0\\r\\nif (cipher == NULL)\\r\\ncipher = getenv(\"SSL_CIPHER\");\\r\\n#endif\\r\\n#if 0\\r\\nif (s_cert_file == NULL) {\\r\\nBIO_printf(bio_err,\\r\\n\"You must specify a certificate file for the server to use\\n\");\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nif ((!SSL_CTX_load_verify_locations(ctx, CAfile, CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(ctx))) {\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif (vpm)\\r\\nSSL_CTX_set1_param(ctx, vpm);\\r\\nssl_ctx_add_crls(ctx, crls, 0);\\r\\nif (!args_ssl_call(ctx, bio_err, cctx, ssl_args, no_ecdhe, no_jpake))\\r\\ngoto end;\\r\\nif (!ssl_load_stores(ctx, vfyCApath, vfyCAfile, chCApath, chCAfile,\\r\\ncrls, crl_download)) {\\r\\nBIO_printf(bio_err, \"Error loading store locations\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s_cert2) {\\r\\nctx2 = SSL_CTX_new(meth);\\r\\nif (ctx2 == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (ctx2) {\\r\\nBIO_printf(bio_s_out, \"Setting secondary ctx parameters\\n\");\\r\\nif (session_id_prefix) {\\r\\nif (strlen(session_id_prefix) >= 32)\\r\\nBIO_printf(bio_err,\\r\\n\"warning: id_prefix is too long, only one new session will be possible\\n\");\\r\\nelse if (strlen(session_id_prefix) >= 16)\\r\\nBIO_printf(bio_err,\\r\\n\"warning: id_prefix is too long if you use SSLv2\\n\");\\r\\nif (!SSL_CTX_set_generate_session_id(ctx2, generate_session_id)) {\\r\\nBIO_printf(bio_err, \"error setting 'id_prefix'\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err, \"id_prefix '%s' set.\\n\", session_id_prefix);\\r\\n}\\r\\nSSL_CTX_set_quiet_shutdown(ctx2, 1);\\r\\nif (hack)\\r\\nSSL_CTX_set_options(ctx2, SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG);\\r\\nif (exc)\\r\\nssl_ctx_set_excert(ctx2, exc);\\r\\nif (socket_type == SOCK_DGRAM)\\r\\nSSL_CTX_set_read_ahead(ctx2, 1);\\r\\nif (state)\\r\\nSSL_CTX_set_info_callback(ctx2, apps_ssl_info_callback);\\r\\nif (no_cache)\\r\\nSSL_CTX_set_session_cache_mode(ctx2, SSL_SESS_CACHE_OFF);\\r\\nelse if (ext_cache)\\r\\ninit_session_cache_ctx(ctx2);\\r\\nelse\\r\\nSSL_CTX_sess_set_cache_size(ctx2, 128);\\r\\nif ((!SSL_CTX_load_verify_locations(ctx2, CAfile, CApath)) ||\\r\\n(!SSL_CTX_set_default_verify_paths(ctx2))) {\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nif (vpm)\\r\\nSSL_CTX_set1_param(ctx2, vpm);\\r\\nssl_ctx_add_crls(ctx2, crls, 0);\\r\\nif (!args_ssl_call(ctx2, bio_err, cctx, ssl_args, no_ecdhe, no_jpake))\\r\\ngoto end;\\r\\n}\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nif (next_proto.data)\\r\\nSSL_CTX_set_next_protos_advertised_cb(ctx, next_proto_cb,\\r\\n&next_proto);\\r\\n# endif\\r\\nif (alpn_ctx.data)\\r\\nSSL_CTX_set_alpn_select_cb(ctx, alpn_cb, &alpn_ctx);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (!no_dhe) {\\r\\nDH *dh = NULL;\\r\\nif (dhfile)\\r\\ndh = load_dh_param(dhfile);\\r\\nelse if (s_cert_file)\\r\\ndh = load_dh_param(s_cert_file);\\r\\nif (dh != NULL) {\\r\\nBIO_printf(bio_s_out, \"Setting temp DH parameters\\n\");\\r\\n} else {\\r\\nBIO_printf(bio_s_out, \"Using default temp DH parameters\\n\");\\r\\ndh = get_dh512();\\r\\n}\\r\\n(void)BIO_flush(bio_s_out);\\r\\nSSL_CTX_set_tmp_dh(ctx, dh);\\r\\n# ifndef OPENSSL_NO_TLSEXT\\r\\nif (ctx2) {\\r\\nif (!dhfile) {\\r\\nDH *dh2 = load_dh_param(s_cert_file2);\\r\\nif (dh2 != NULL) {\\r\\nBIO_printf(bio_s_out, \"Setting temp DH parameters\\n\");\\r\\n(void)BIO_flush(bio_s_out);\\r\\nDH_free(dh);\\r\\ndh = dh2;\\r\\n}\\r\\n}\\r\\nSSL_CTX_set_tmp_dh(ctx2, dh);\\r\\n}\\r\\n# endif\\r\\nDH_free(dh);\\r\\n}\\r\\n#endif\\r\\nif (!set_cert_key_stuff(ctx, s_cert, s_key, s_chain, build_chain))\\r\\ngoto end;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s_serverinfo_file != NULL\\r\\n&& !SSL_CTX_use_serverinfo_file(ctx, s_serverinfo_file)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (ctx2 && !set_cert_key_stuff(ctx2, s_cert2, s_key2, NULL, build_chain))\\r\\ngoto end;\\r\\n#endif\\r\\nif (s_dcert != NULL) {\\r\\nif (!set_cert_key_stuff(ctx, s_dcert, s_dkey, s_dchain, build_chain))\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\n# if 1\\r\\nif (!no_tmp_rsa) {\\r\\nSSL_CTX_set_tmp_rsa_callback(ctx, tmp_rsa_cb);\\r\\n# ifndef OPENSSL_NO_TLSEXT\\r\\nif (ctx2)\\r\\nSSL_CTX_set_tmp_rsa_callback(ctx2, tmp_rsa_cb);\\r\\n# endif\\r\\n}\\r\\n# else\\r\\nif (!no_tmp_rsa && SSL_CTX_need_tmp_RSA(ctx)) {\\r\\nRSA *rsa;\\r\\nBIO_printf(bio_s_out, \"Generating temp (512 bit) RSA key...\");\\r\\nBIO_flush(bio_s_out);\\r\\nrsa = RSA_generate_key(512, RSA_F4, NULL);\\r\\nif (!SSL_CTX_set_tmp_rsa(ctx, rsa)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n# ifndef OPENSSL_NO_TLSEXT\\r\\nif (ctx2) {\\r\\nif (!SSL_CTX_set_tmp_rsa(ctx2, rsa)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n# endif\\r\\nRSA_free(rsa);\\r\\nBIO_printf(bio_s_out, \"\\n\");\\r\\n}\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\n# ifdef OPENSSL_NO_JPAKE\\r\\nif (psk_key != NULL)\\r\\n# else\\r\\nif (psk_key != NULL || jpake_secret)\\r\\n# endif\\r\\n{\\r\\nif (s_debug)\\r\\nBIO_printf(bio_s_out,\\r\\n\"PSK key given or JPAKE in use, setting server callback\\n\");\\r\\nSSL_CTX_set_psk_server_callback(ctx, psk_server_cb);\\r\\n}\\r\\nif (!SSL_CTX_use_psk_identity_hint(ctx, psk_identity_hint)) {\\r\\nBIO_printf(bio_err, \"error setting PSK identity hint to context\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n#endif\\r\\nSSL_CTX_set_verify(ctx, s_server_verify, verify_callback);\\r\\nSSL_CTX_set_session_id_context(ctx, (void *)&s_server_session_id_context,\\r\\nsizeof s_server_session_id_context);\\r\\nSSL_CTX_set_cookie_generate_cb(ctx, generate_cookie_callback);\\r\\nSSL_CTX_set_cookie_verify_cb(ctx, verify_cookie_callback);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (ctx2) {\\r\\nSSL_CTX_set_verify(ctx2, s_server_verify, verify_callback);\\r\\nSSL_CTX_set_session_id_context(ctx2,\\r\\n(void *)&s_server_session_id_context,\\r\\nsizeof s_server_session_id_context);\\r\\ntlsextcbp.biodebug = bio_s_out;\\r\\nSSL_CTX_set_tlsext_servername_callback(ctx2, ssl_servername_cb);\\r\\nSSL_CTX_set_tlsext_servername_arg(ctx2, &tlsextcbp);\\r\\nSSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);\\r\\nSSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nif (srp_verifier_file != NULL) {\\r\\nsrp_callback_parm.vb = SRP_VBASE_new(srpuserseed);\\r\\nsrp_callback_parm.user = NULL;\\r\\nsrp_callback_parm.login = NULL;\\r\\nif ((ret =\\r\\nSRP_VBASE_init(srp_callback_parm.vb,\\r\\nsrp_verifier_file)) != SRP_NO_ERROR) {\\r\\nBIO_printf(bio_err,\\r\\n\"Cannot initialize SRP verifier file \\\"%s\\\":ret=%d\\n\",\\r\\nsrp_verifier_file, ret);\\r\\ngoto end;\\r\\n}\\r\\nSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, verify_callback);\\r\\nSSL_CTX_set_srp_cb_arg(ctx, &srp_callback_parm);\\r\\nSSL_CTX_set_srp_username_callback(ctx, ssl_srp_server_param_cb);\\r\\n} else\\r\\n#endif\\r\\nif (CAfile != NULL) {\\r\\nSSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file(CAfile));\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (ctx2)\\r\\nSSL_CTX_set_client_CA_list(ctx2, SSL_load_client_CA_file(CAfile));\\r\\n#endif\\r\\n}\\r\\nBIO_printf(bio_s_out, \"ACCEPT\\n\");\\r\\n(void)BIO_flush(bio_s_out);\\r\\nif (rev)\\r\\ndo_server(port, socket_type, &accept_socket, rev_body, context,\\r\\nnaccept);\\r\\nelse if (www)\\r\\ndo_server(port, socket_type, &accept_socket, www_body, context,\\r\\nnaccept);\\r\\nelse\\r\\ndo_server(port, socket_type, &accept_socket, sv_body, context,\\r\\nnaccept);\\r\\nprint_stats(bio_s_out, ctx);\\r\\nret = 0;\\r\\nend:\\r\\nif (ctx != NULL)\\r\\nSSL_CTX_free(ctx);\\r\\nif (s_cert)\\r\\nX509_free(s_cert);\\r\\nif (crls)\\r\\nsk_X509_CRL_pop_free(crls, X509_CRL_free);\\r\\nif (s_dcert)\\r\\nX509_free(s_dcert);\\r\\nif (s_key)\\r\\nEVP_PKEY_free(s_key);\\r\\nif (s_dkey)\\r\\nEVP_PKEY_free(s_dkey);\\r\\nif (s_chain)\\r\\nsk_X509_pop_free(s_chain, X509_free);\\r\\nif (s_dchain)\\r\\nsk_X509_pop_free(s_dchain, X509_free);\\r\\nif (pass)\\r\\nOPENSSL_free(pass);\\r\\nif (dpass)\\r\\nOPENSSL_free(dpass);\\r\\nif (vpm)\\r\\nX509_VERIFY_PARAM_free(vpm);\\r\\nfree_sessions();\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (tlscstatp.host)\\r\\nOPENSSL_free(tlscstatp.host);\\r\\nif (tlscstatp.port)\\r\\nOPENSSL_free(tlscstatp.port);\\r\\nif (tlscstatp.path)\\r\\nOPENSSL_free(tlscstatp.path);\\r\\nif (ctx2 != NULL)\\r\\nSSL_CTX_free(ctx2);\\r\\nif (s_cert2)\\r\\nX509_free(s_cert2);\\r\\nif (s_key2)\\r\\nEVP_PKEY_free(s_key2);\\r\\nif (serverinfo_in != NULL)\\r\\nBIO_free(serverinfo_in);\\r\\n# ifndef OPENSSL_NO_NEXTPROTONEG\\r\\nif (next_proto.data)\\r\\nOPENSSL_free(next_proto.data);\\r\\n# endif\\r\\nif (alpn_ctx.data)\\r\\nOPENSSL_free(alpn_ctx.data);\\r\\n#endif\\r\\nssl_excert_free(exc);\\r\\nif (ssl_args)\\r\\nsk_OPENSSL_STRING_free(ssl_args);\\r\\nif (cctx)\\r\\nSSL_CONF_CTX_free(cctx);\\r\\n#ifndef OPENSSL_NO_JPAKE\\r\\nif (jpake_secret && psk_key)\\r\\nOPENSSL_free(psk_key);\\r\\n#endif\\r\\nif (bio_s_out != NULL) {\\r\\nBIO_free(bio_s_out);\\r\\nbio_s_out = NULL;\\r\\n}\\r\\nif (bio_s_msg != NULL) {\\r\\nBIO_free(bio_s_msg);\\r\\nbio_s_msg = NULL;\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic void print_stats(BIO *bio, SSL_CTX *ssl_ctx)\\r\\n{\\r\\nBIO_printf(bio, \"%4ld items in the session cache\\n\",\\r\\nSSL_CTX_sess_number(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld client connects (SSL_connect())\\n\",\\r\\nSSL_CTX_sess_connect(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld client renegotiates (SSL_connect())\\n\",\\r\\nSSL_CTX_sess_connect_renegotiate(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld client connects that finished\\n\",\\r\\nSSL_CTX_sess_connect_good(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld server accepts (SSL_accept())\\n\",\\r\\nSSL_CTX_sess_accept(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld server renegotiates (SSL_accept())\\n\",\\r\\nSSL_CTX_sess_accept_renegotiate(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld server accepts that finished\\n\",\\r\\nSSL_CTX_sess_accept_good(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld session cache hits\\n\", SSL_CTX_sess_hits(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld session cache misses\\n\",\\r\\nSSL_CTX_sess_misses(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld session cache timeouts\\n\",\\r\\nSSL_CTX_sess_timeouts(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld callback cache hits\\n\",\\r\\nSSL_CTX_sess_cb_hits(ssl_ctx));\\r\\nBIO_printf(bio, \"%4ld cache full overflows (%ld allowed)\\n\",\\r\\nSSL_CTX_sess_cache_full(ssl_ctx),\\r\\nSSL_CTX_sess_get_cache_size(ssl_ctx));\\r\\n}\\r\\nstatic int sv_body(char *hostname, int s, int stype, unsigned char *context)\\r\\n{\\r\\nchar *buf = NULL;\\r\\nfd_set readfds;\\r\\nint ret = 1, width;\\r\\nint k, i;\\r\\nunsigned long l;\\r\\nSSL *con = NULL;\\r\\nBIO *sbio;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nKSSL_CTX *kctx;\\r\\n#endif\\r\\nstruct timeval timeout;\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS_R5)\\r\\nstruct timeval tv;\\r\\n#else\\r\\nstruct timeval *timeoutp;\\r\\n#endif\\r\\nif ((buf = OPENSSL_malloc(bufsize)) == NULL) {\\r\\nBIO_printf(bio_err, \"out of memory\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifdef FIONBIO\\r\\nif (s_nbio) {\\r\\nunsigned long sl = 1;\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err, \"turning on non blocking io\\n\");\\r\\nif (BIO_socket_ioctl(s, FIONBIO, &sl) < 0)\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n#endif\\r\\nif (con == NULL) {\\r\\ncon = SSL_new(ctx);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s_tlsextdebug) {\\r\\nSSL_set_tlsext_debug_callback(con, tlsext_cb);\\r\\nSSL_set_tlsext_debug_arg(con, bio_s_out);\\r\\n}\\r\\nif (s_tlsextstatus) {\\r\\nSSL_CTX_set_tlsext_status_cb(ctx, cert_status_cb);\\r\\ntlscstatp.err = bio_err;\\r\\nSSL_CTX_set_tlsext_status_arg(ctx, &tlscstatp);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif ((kctx = kssl_ctx_new()) != NULL) {\\r\\nSSL_set0_kssl_ctx(con, kctx);\\r\\nkssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);\\r\\nkssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);\\r\\n}\\r\\n#endif\\r\\nif (context)\\r\\nSSL_set_session_id_context(con, context, strlen((char *)context));\\r\\n}\\r\\nSSL_clear(con);\\r\\n#if 0\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\nSSL_set_tlsext_opaque_prf_input(con, \"Test server\", 11);\\r\\n# endif\\r\\n#endif\\r\\nif (stype == SOCK_DGRAM) {\\r\\nsbio = BIO_new_dgram(s, BIO_NOCLOSE);\\r\\nif (enable_timeouts) {\\r\\ntimeout.tv_sec = 0;\\r\\ntimeout.tv_usec = DGRAM_RCV_TIMEOUT;\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);\\r\\ntimeout.tv_sec = 0;\\r\\ntimeout.tv_usec = DGRAM_SND_TIMEOUT;\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);\\r\\n}\\r\\nif (socket_mtu) {\\r\\nif (socket_mtu < DTLS_get_link_min_mtu(con)) {\\r\\nBIO_printf(bio_err, \"MTU too small. Must be at least %ld\\n\",\\r\\nDTLS_get_link_min_mtu(con));\\r\\nret = -1;\\r\\nBIO_free(sbio);\\r\\ngoto err;\\r\\n}\\r\\nSSL_set_options(con, SSL_OP_NO_QUERY_MTU);\\r\\nif (!DTLS_set_link_mtu(con, socket_mtu)) {\\r\\nBIO_printf(bio_err, \"Failed to set MTU\\n\");\\r\\nret = -1;\\r\\nBIO_free(sbio);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\nBIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);\\r\\nSSL_set_options(con, SSL_OP_COOKIE_EXCHANGE);\\r\\n} else\\r\\nsbio = BIO_new_socket(s, BIO_NOCLOSE);\\r\\nif (s_nbio_test) {\\r\\nBIO *test;\\r\\ntest = BIO_new(BIO_f_nbio_test());\\r\\nsbio = BIO_push(test, sbio);\\r\\n}\\r\\n#ifndef OPENSSL_NO_JPAKE\\r\\nif (jpake_secret)\\r\\njpake_server_auth(bio_s_out, sbio, jpake_secret);\\r\\n#endif\\r\\nSSL_set_bio(con, sbio, sbio);\\r\\nSSL_set_accept_state(con);\\r\\nif (s_debug) {\\r\\nSSL_set_debug(con, 1);\\r\\nBIO_set_callback(SSL_get_rbio(con), bio_dump_callback);\\r\\nBIO_set_callback_arg(SSL_get_rbio(con), (char *)bio_s_out);\\r\\n}\\r\\nif (s_msg) {\\r\\n#ifndef OPENSSL_NO_SSL_TRACE\\r\\nif (s_msg == 2)\\r\\nSSL_set_msg_callback(con, SSL_trace);\\r\\nelse\\r\\n#endif\\r\\nSSL_set_msg_callback(con, msg_cb);\\r\\nSSL_set_msg_callback_arg(con, bio_s_msg ? bio_s_msg : bio_s_out);\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s_tlsextdebug) {\\r\\nSSL_set_tlsext_debug_callback(con, tlsext_cb);\\r\\nSSL_set_tlsext_debug_arg(con, bio_s_out);\\r\\n}\\r\\n#endif\\r\\nwidth = s + 1;\\r\\nfor (;;) {\\r\\nint read_from_terminal;\\r\\nint read_from_sslcon;\\r\\nread_from_terminal = 0;\\r\\nread_from_sslcon = SSL_pending(con);\\r\\nif (!read_from_sslcon) {\\r\\nFD_ZERO(&readfds);\\r\\n#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS) && !defined(OPENSSL_SYS_NETWARE) && !defined(OPENSSL_SYS_BEOS_R5)\\r\\nopenssl_fdset(fileno(stdin), &readfds);\\r\\n#endif\\r\\nopenssl_fdset(s, &readfds);\\r\\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_NETWARE)\\r\\ntv.tv_sec = 1;\\r\\ntv.tv_usec = 0;\\r\\ni = select(width, (void *)&readfds, NULL, NULL, &tv);\\r\\nif ((i < 0) || (!i && !_kbhit()))\\r\\ncontinue;\\r\\nif (_kbhit())\\r\\nread_from_terminal = 1;\\r\\n#elif defined(OPENSSL_SYS_BEOS_R5)\\r\\ntv.tv_sec = 1;\\r\\ntv.tv_usec = 0;\\r\\n(void)fcntl(fileno(stdin), F_SETFL, O_NONBLOCK);\\r\\ni = select(width, (void *)&readfds, NULL, NULL, &tv);\\r\\nif ((i < 0) || (!i && read(fileno(stdin), buf, 0) < 0))\\r\\ncontinue;\\r\\nif (read(fileno(stdin), buf, 0) >= 0)\\r\\nread_from_terminal = 1;\\r\\n(void)fcntl(fileno(stdin), F_SETFL, 0);\\r\\n#else\\r\\nif ((SSL_version(con) == DTLS1_VERSION) &&\\r\\nDTLSv1_get_timeout(con, &timeout))\\r\\ntimeoutp = &timeout;\\r\\nelse\\r\\ntimeoutp = NULL;\\r\\ni = select(width, (void *)&readfds, NULL, NULL, timeoutp);\\r\\nif ((SSL_version(con) == DTLS1_VERSION)\\r\\n&& DTLSv1_handle_timeout(con) > 0) {\\r\\nBIO_printf(bio_err, \"TIMEOUT occured\\n\");\\r\\n}\\r\\nif (i <= 0)\\r\\ncontinue;\\r\\nif (FD_ISSET(fileno(stdin), &readfds))\\r\\nread_from_terminal = 1;\\r\\n#endif\\r\\nif (FD_ISSET(s, &readfds))\\r\\nread_from_sslcon = 1;\\r\\n}\\r\\nif (read_from_terminal) {\\r\\nif (s_crlf) {\\r\\nint j, lf_num;\\r\\ni = raw_read_stdin(buf, bufsize / 2);\\r\\nlf_num = 0;\\r\\nfor (j = 0; j < i; j++)\\r\\nif (buf[j] == '\\n')\\r\\nlf_num++;\\r\\nfor (j = i - 1; j >= 0; j--) {\\r\\nbuf[j + lf_num] = buf[j];\\r\\nif (buf[j] == '\\n') {\\r\\nlf_num--;\\r\\ni++;\\r\\nbuf[j + lf_num] = '\\r';\\r\\n}\\r\\n}\\r\\nassert(lf_num == 0);\\r\\n} else\\r\\ni = raw_read_stdin(buf, bufsize);\\r\\nif (!s_quiet && !s_brief) {\\r\\nif ((i <= 0) || (buf[0] == 'Q')) {\\r\\nBIO_printf(bio_s_out, \"DONE\\n\");\\r\\nSHUTDOWN(s);\\r\\nclose_accept_socket();\\r\\nret = -11;\\r\\ngoto err;\\r\\n}\\r\\nif ((i <= 0) || (buf[0] == 'q')) {\\r\\nBIO_printf(bio_s_out, \"DONE\\n\");\\r\\nif (SSL_version(con) != DTLS1_VERSION)\\r\\nSHUTDOWN(s);\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_HEARTBEATS\\r\\nif ((buf[0] == 'B') && ((buf[1] == '\\n') || (buf[1] == '\\r'))) {\\r\\nBIO_printf(bio_err, \"HEARTBEATING\\n\");\\r\\nSSL_heartbeat(con);\\r\\ni = 0;\\r\\ncontinue;\\r\\n}\\r\\n#endif\\r\\nif ((buf[0] == 'r') && ((buf[1] == '\\n') || (buf[1] == '\\r'))) {\\r\\nSSL_renegotiate(con);\\r\\ni = SSL_do_handshake(con);\\r\\nprintf(\"SSL_do_handshake -> %d\\n\", i);\\r\\ni = 0;\\r\\ncontinue;\\r\\n}\\r\\nif ((buf[0] == 'R') && ((buf[1] == '\\n') || (buf[1] == '\\r'))) {\\r\\nSSL_set_verify(con,\\r\\nSSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE,\\r\\nNULL);\\r\\nSSL_renegotiate(con);\\r\\ni = SSL_do_handshake(con);\\r\\nprintf(\"SSL_do_handshake -> %d\\n\", i);\\r\\ni = 0;\\r\\ncontinue;\\r\\n}\\r\\nif (buf[0] == 'P') {\\r\\nstatic const char *str = \"Lets print some clear text\\n\";\\r\\nBIO_write(SSL_get_wbio(con), str, strlen(str));\\r\\n}\\r\\nif (buf[0] == 'S') {\\r\\nprint_stats(bio_s_out, SSL_get_SSL_CTX(con));\\r\\n}\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(buf, buf, i);\\r\\n#endif\\r\\nl = k = 0;\\r\\nfor (;;) {\\r\\n#ifdef RENEG\\r\\n{\\r\\nstatic count = 0;\\r\\nif (++count == 100) {\\r\\ncount = 0;\\r\\nSSL_renegotiate(con);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nk = SSL_write(con, &(buf[l]), (unsigned int)i);\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nwhile (SSL_get_error(con, k) == SSL_ERROR_WANT_X509_LOOKUP) {\\r\\nBIO_printf(bio_s_out, \"LOOKUP renego during write\\n\");\\r\\nsrp_callback_parm.user =\\r\\nSRP_VBASE_get_by_user(srp_callback_parm.vb,\\r\\nsrp_callback_parm.login);\\r\\nif (srp_callback_parm.user)\\r\\nBIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\\r\\nsrp_callback_parm.user->info);\\r\\nelse\\r\\nBIO_printf(bio_s_out, \"LOOKUP not successful\\n\");\\r\\nk = SSL_write(con, &(buf[l]), (unsigned int)i);\\r\\n}\\r\\n#endif\\r\\nswitch (SSL_get_error(con, k)) {\\r\\ncase SSL_ERROR_NONE:\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\ncase SSL_ERROR_WANT_READ:\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\nBIO_printf(bio_s_out, \"Write BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\nBIO_printf(bio_s_out, \"ERROR\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nret = 1;\\r\\ngoto err;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nBIO_printf(bio_s_out, \"DONE\\n\");\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nl += k;\\r\\ni -= k;\\r\\nif (i <= 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (read_from_sslcon) {\\r\\nif (!SSL_is_init_finished(con)) {\\r\\ni = init_ssl_connection(con);\\r\\nif (i < 0) {\\r\\nret = 0;\\r\\ngoto err;\\r\\n} else if (i == 0) {\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nagain:\\r\\ni = SSL_read(con, (char *)buf, bufsize);\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nwhile (SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {\\r\\nBIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");\\r\\nsrp_callback_parm.user =\\r\\nSRP_VBASE_get_by_user(srp_callback_parm.vb,\\r\\nsrp_callback_parm.login);\\r\\nif (srp_callback_parm.user)\\r\\nBIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\\r\\nsrp_callback_parm.user->info);\\r\\nelse\\r\\nBIO_printf(bio_s_out, \"LOOKUP not successful\\n\");\\r\\ni = SSL_read(con, (char *)buf, bufsize);\\r\\n}\\r\\n#endif\\r\\nswitch (SSL_get_error(con, i)) {\\r\\ncase SSL_ERROR_NONE:\\r\\n#ifdef CHARSET_EBCDIC\\r\\nascii2ebcdic(buf, buf, i);\\r\\n#endif\\r\\nraw_write_stdout(buf, (unsigned int)i);\\r\\nif (SSL_pending(con))\\r\\ngoto again;\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\ncase SSL_ERROR_WANT_READ:\\r\\nBIO_printf(bio_s_out, \"Read BLOCK\\n\");\\r\\nbreak;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\nBIO_printf(bio_s_out, \"ERROR\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nret = 1;\\r\\ngoto err;\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nBIO_printf(bio_s_out, \"DONE\\n\");\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (con != NULL) {\\r\\nBIO_printf(bio_s_out, \"shutting down SSL\\n\");\\r\\n#if 1\\r\\nSSL_set_shutdown(con, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\nSSL_shutdown(con);\\r\\n#endif\\r\\nSSL_free(con);\\r\\n}\\r\\nBIO_printf(bio_s_out, \"CONNECTION CLOSED\\n\");\\r\\nif (buf != NULL) {\\r\\nOPENSSL_cleanse(buf, bufsize);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nif (ret >= 0)\\r\\nBIO_printf(bio_s_out, \"ACCEPT\\n\");\\r\\nreturn (ret);\\r\\n}\\r\\nstatic void close_accept_socket(void)\\r\\n{\\r\\nBIO_printf(bio_err, \"shutdown accept socket\\n\");\\r\\nif (accept_socket >= 0) {\\r\\nSHUTDOWN2(accept_socket);\\r\\n}\\r\\n}\\r\\nstatic int init_ssl_connection(SSL *con)\\r\\n{\\r\\nint i;\\r\\nconst char *str;\\r\\nX509 *peer;\\r\\nlong verify_error;\\r\\nMS_STATIC char buf[BUFSIZ];\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nchar *client_princ;\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\\r\\nconst unsigned char *next_proto_neg;\\r\\nunsigned next_proto_neg_len;\\r\\n#endif\\r\\nunsigned char *exportedkeymat;\\r\\ni = SSL_accept(con);\\r\\n#ifdef CERT_CB_TEST_RETRY\\r\\n{\\r\\nwhile (i <= 0 && SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP\\r\\n&& SSL_state(con) == SSL3_ST_SR_CLNT_HELLO_C) {\\r\\nfprintf(stderr,\\r\\n\"LOOKUP from certificate callback during accept\\n\");\\r\\ni = SSL_accept(con);\\r\\n}\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nwhile (i <= 0 && SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {\\r\\nBIO_printf(bio_s_out, \"LOOKUP during accept %s\\n\",\\r\\nsrp_callback_parm.login);\\r\\nsrp_callback_parm.user =\\r\\nSRP_VBASE_get_by_user(srp_callback_parm.vb,\\r\\nsrp_callback_parm.login);\\r\\nif (srp_callback_parm.user)\\r\\nBIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\\r\\nsrp_callback_parm.user->info);\\r\\nelse\\r\\nBIO_printf(bio_s_out, \"LOOKUP not successful\\n\");\\r\\ni = SSL_accept(con);\\r\\n}\\r\\n#endif\\r\\nif (i <= 0) {\\r\\nif (BIO_sock_should_retry(i)) {\\r\\nBIO_printf(bio_s_out, \"DELAY\\n\");\\r\\nreturn (1);\\r\\n}\\r\\nBIO_printf(bio_err, \"ERROR\\n\");\\r\\nverify_error = SSL_get_verify_result(con);\\r\\nif (verify_error != X509_V_OK) {\\r\\nBIO_printf(bio_err, \"verify error:%s\\n\",\\r\\nX509_verify_cert_error_string(verify_error));\\r\\n}\\r\\nERR_print_errors(bio_err);\\r\\nreturn (0);\\r\\n}\\r\\nif (s_brief)\\r\\nprint_ssl_summary(bio_err, con);\\r\\nPEM_write_bio_SSL_SESSION(bio_s_out, SSL_get_session(con));\\r\\npeer = SSL_get_peer_certificate(con);\\r\\nif (peer != NULL) {\\r\\nBIO_printf(bio_s_out, \"Client certificate\\n\");\\r\\nPEM_write_bio_X509(bio_s_out, peer);\\r\\nX509_NAME_oneline(X509_get_subject_name(peer), buf, sizeof buf);\\r\\nBIO_printf(bio_s_out, \"subject=%s\\n\", buf);\\r\\nX509_NAME_oneline(X509_get_issuer_name(peer), buf, sizeof buf);\\r\\nBIO_printf(bio_s_out, \"issuer=%s\\n\", buf);\\r\\nX509_free(peer);\\r\\n}\\r\\nif (SSL_get_shared_ciphers(con, buf, sizeof buf) != NULL)\\r\\nBIO_printf(bio_s_out, \"Shared ciphers:%s\\n\", buf);\\r\\nstr = SSL_CIPHER_get_name(SSL_get_current_cipher(con));\\r\\nssl_print_sigalgs(bio_s_out, con);\\r\\n#ifndef OPENSSL_NO_EC\\r\\nssl_print_point_formats(bio_s_out, con);\\r\\nssl_print_curves(bio_s_out, con, 0);\\r\\n#endif\\r\\nBIO_printf(bio_s_out, \"CIPHER is %s\\n\", (str != NULL) ? str : \"(NONE)\");\\r\\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\\r\\nSSL_get0_next_proto_negotiated(con, &next_proto_neg, &next_proto_neg_len);\\r\\nif (next_proto_neg) {\\r\\nBIO_printf(bio_s_out, \"NEXTPROTO is \");\\r\\nBIO_write(bio_s_out, next_proto_neg, next_proto_neg_len);\\r\\nBIO_printf(bio_s_out, \"\\n\");\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRTP\\r\\n{\\r\\nSRTP_PROTECTION_PROFILE *srtp_profile\\r\\n= SSL_get_selected_srtp_profile(con);\\r\\nif (srtp_profile)\\r\\nBIO_printf(bio_s_out, \"SRTP Extension negotiated, profile=%s\\n\",\\r\\nsrtp_profile->name);\\r\\n}\\r\\n#endif\\r\\nif (SSL_cache_hit(con))\\r\\nBIO_printf(bio_s_out, \"Reused session-id\\n\");\\r\\nif (SSL_ctrl(con, SSL_CTRL_GET_FLAGS, 0, NULL) &\\r\\nTLS1_FLAGS_TLS_PADDING_BUG)\\r\\nBIO_printf(bio_s_out, \"Peer has incorrect TLSv1 block padding\\n\");\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nclient_princ = kssl_ctx_get0_client_princ(SSL_get0_kssl_ctx(con));\\r\\nif (client_princ != NULL) {\\r\\nBIO_printf(bio_s_out, \"Kerberos peer principal is %s\\n\",\\r\\nclient_princ);\\r\\n}\\r\\n#endif\\r\\nBIO_printf(bio_s_out, \"Secure Renegotiation IS%s supported\\n\",\\r\\nSSL_get_secure_renegotiation_support(con) ? \"\" : \" NOT\");\\r\\nif (keymatexportlabel != NULL) {\\r\\nBIO_printf(bio_s_out, \"Keying material exporter:\\n\");\\r\\nBIO_printf(bio_s_out, \" Label: '%s'\\n\", keymatexportlabel);\\r\\nBIO_printf(bio_s_out, \" Length: %i bytes\\n\", keymatexportlen);\\r\\nexportedkeymat = OPENSSL_malloc(keymatexportlen);\\r\\nif (exportedkeymat != NULL) {\\r\\nif (!SSL_export_keying_material(con, exportedkeymat,\\r\\nkeymatexportlen,\\r\\nkeymatexportlabel,\\r\\nstrlen(keymatexportlabel),\\r\\nNULL, 0, 0)) {\\r\\nBIO_printf(bio_s_out, \" Error\\n\");\\r\\n} else {\\r\\nBIO_printf(bio_s_out, \" Keying material: \");\\r\\nfor (i = 0; i < keymatexportlen; i++)\\r\\nBIO_printf(bio_s_out, \"%02X\", exportedkeymat[i]);\\r\\nBIO_printf(bio_s_out, \"\\n\");\\r\\n}\\r\\nOPENSSL_free(exportedkeymat);\\r\\n}\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic DH *load_dh_param(const char *dhfile)\\r\\n{\\r\\nDH *ret = NULL;\\r\\nBIO *bio;\\r\\nif ((bio = BIO_new_file(dhfile, \"r\")) == NULL)\\r\\ngoto err;\\r\\nret = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);\\r\\nerr:\\r\\nif (bio != NULL)\\r\\nBIO_free(bio);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int www_body(char *hostname, int s, int stype, unsigned char *context)\\r\\n{\\r\\nchar *buf = NULL;\\r\\nint ret = 1;\\r\\nint i, j, k, dot;\\r\\nSSL *con;\\r\\nconst SSL_CIPHER *c;\\r\\nBIO *io, *ssl_bio, *sbio;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nKSSL_CTX *kctx;\\r\\n#endif\\r\\nbuf = OPENSSL_malloc(bufsize);\\r\\nif (buf == NULL)\\r\\nreturn (0);\\r\\nio = BIO_new(BIO_f_buffer());\\r\\nssl_bio = BIO_new(BIO_f_ssl());\\r\\nif ((io == NULL) || (ssl_bio == NULL))\\r\\ngoto err;\\r\\n#ifdef FIONBIO\\r\\nif (s_nbio) {\\r\\nunsigned long sl = 1;\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err, \"turning on non blocking io\\n\");\\r\\nif (BIO_socket_ioctl(s, FIONBIO, &sl) < 0)\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n#endif\\r\\nif (!BIO_set_write_buffer_size(io, bufsize))\\r\\ngoto err;\\r\\nif ((con = SSL_new(ctx)) == NULL)\\r\\ngoto err;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s_tlsextdebug) {\\r\\nSSL_set_tlsext_debug_callback(con, tlsext_cb);\\r\\nSSL_set_tlsext_debug_arg(con, bio_s_out);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif ((kctx = kssl_ctx_new()) != NULL) {\\r\\nkssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);\\r\\nkssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);\\r\\n}\\r\\n#endif\\r\\nif (context)\\r\\nSSL_set_session_id_context(con, context, strlen((char *)context));\\r\\nsbio = BIO_new_socket(s, BIO_NOCLOSE);\\r\\nif (s_nbio_test) {\\r\\nBIO *test;\\r\\ntest = BIO_new(BIO_f_nbio_test());\\r\\nsbio = BIO_push(test, sbio);\\r\\n}\\r\\nSSL_set_bio(con, sbio, sbio);\\r\\nSSL_set_accept_state(con);\\r\\nBIO_set_ssl(ssl_bio, con, BIO_CLOSE);\\r\\nBIO_push(io, ssl_bio);\\r\\n#ifdef CHARSET_EBCDIC\\r\\nio = BIO_push(BIO_new(BIO_f_ebcdic_filter()), io);\\r\\n#endif\\r\\nif (s_debug) {\\r\\nSSL_set_debug(con, 1);\\r\\nBIO_set_callback(SSL_get_rbio(con), bio_dump_callback);\\r\\nBIO_set_callback_arg(SSL_get_rbio(con), (char *)bio_s_out);\\r\\n}\\r\\nif (s_msg) {\\r\\n#ifndef OPENSSL_NO_SSL_TRACE\\r\\nif (s_msg == 2)\\r\\nSSL_set_msg_callback(con, SSL_trace);\\r\\nelse\\r\\n#endif\\r\\nSSL_set_msg_callback(con, msg_cb);\\r\\nSSL_set_msg_callback_arg(con, bio_s_msg ? bio_s_msg : bio_s_out);\\r\\n}\\r\\nfor (;;) {\\r\\nif (hack) {\\r\\ni = SSL_accept(con);\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nwhile (i <= 0\\r\\n&& SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {\\r\\nBIO_printf(bio_s_out, \"LOOKUP during accept %s\\n\",\\r\\nsrp_callback_parm.login);\\r\\nsrp_callback_parm.user =\\r\\nSRP_VBASE_get_by_user(srp_callback_parm.vb,\\r\\nsrp_callback_parm.login);\\r\\nif (srp_callback_parm.user)\\r\\nBIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\\r\\nsrp_callback_parm.user->info);\\r\\nelse\\r\\nBIO_printf(bio_s_out, \"LOOKUP not successful\\n\");\\r\\ni = SSL_accept(con);\\r\\n}\\r\\n#endif\\r\\nswitch (SSL_get_error(con, i)) {\\r\\ncase SSL_ERROR_NONE:\\r\\nbreak;\\r\\ncase SSL_ERROR_WANT_WRITE:\\r\\ncase SSL_ERROR_WANT_READ:\\r\\ncase SSL_ERROR_WANT_X509_LOOKUP:\\r\\ncontinue;\\r\\ncase SSL_ERROR_SYSCALL:\\r\\ncase SSL_ERROR_SSL:\\r\\ncase SSL_ERROR_ZERO_RETURN:\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nSSL_renegotiate(con);\\r\\nSSL_write(con, NULL, 0);\\r\\n}\\r\\ni = BIO_gets(io, buf, bufsize - 1);\\r\\nif (i < 0) {\\r\\nif (!BIO_should_retry(io)) {\\r\\nif (!s_quiet)\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n} else {\\r\\nBIO_printf(bio_s_out, \"read R BLOCK\\n\");\\r\\n#if defined(OPENSSL_SYS_NETWARE)\\r\\ndelay(1000);\\r\\n#elif !defined(OPENSSL_SYS_MSDOS) && !defined(__DJGPP__)\\r\\nsleep(1);\\r\\n#endif\\r\\ncontinue;\\r\\n}\\r\\n} else if (i == 0) {\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\nif (((www == 1) && (strncmp(\"GET \", buf, 4) == 0)) ||\\r\\n((www == 2) && (strncmp(\"GET /stats \", buf, 10) == 0))) {\\r\\nchar *p;\\r\\nX509 *peer;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nstatic const char *space = \" \";\\r\\nBIO_puts(io,\\r\\n\"HTTP/1.0 200 ok\\r\\nContent-type: text/html\\r\\n\\r\\n\");\\r\\nBIO_puts(io, \"<HTML><BODY BGCOLOR=\\\"#ffffff\\\">\\n\");\\r\\nBIO_puts(io, \"<pre>\\n\");\\r\\nBIO_puts(io, \"\\n\");\\r\\nfor (i = 0; i < local_argc; i++) {\\r\\nBIO_puts(io, local_argv[i]);\\r\\nBIO_write(io, \" \", 1);\\r\\n}\\r\\nBIO_puts(io, \"\\n\");\\r\\nBIO_printf(io,\\r\\n\"Secure Renegotiation IS%s supported\\n\",\\r\\nSSL_get_secure_renegotiation_support(con) ?\\r\\n\"\" : \" NOT\");\\r\\nBIO_printf(io, \"Ciphers supported in s_server binary\\n\");\\r\\nsk = SSL_get_ciphers(con);\\r\\nj = sk_SSL_CIPHER_num(sk);\\r\\nfor (i = 0; i < j; i++) {\\r\\nc = sk_SSL_CIPHER_value(sk, i);\\r\\nBIO_printf(io, \"%-11s:%-25s\",\\r\\nSSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c));\\r\\nif ((((i + 1) % 2) == 0) && (i + 1 != j))\\r\\nBIO_puts(io, \"\\n\");\\r\\n}\\r\\nBIO_puts(io, \"\\n\");\\r\\np = SSL_get_shared_ciphers(con, buf, bufsize);\\r\\nif (p != NULL) {\\r\\nBIO_printf(io,\\r\\n\"---\\nCiphers common between both SSL end points:\\n\");\\r\\nj = i = 0;\\r\\nwhile (*p) {\\r\\nif (*p == ':') {\\r\\nBIO_write(io, space, 26 - j);\\r\\ni++;\\r\\nj = 0;\\r\\nBIO_write(io, ((i % 3) ? \" \" : \"\\n\"), 1);\\r\\n} else {\\r\\nBIO_write(io, p, 1);\\r\\nj++;\\r\\n}\\r\\np++;\\r\\n}\\r\\nBIO_puts(io, \"\\n\");\\r\\n}\\r\\nssl_print_sigalgs(io, con);\\r\\n#ifndef OPENSSL_NO_EC\\r\\nssl_print_curves(io, con, 0);\\r\\n#endif\\r\\nBIO_printf(io, (SSL_cache_hit(con)\\r\\n? \"---\\nReused, \" : \"---\\nNew, \"));\\r\\nc = SSL_get_current_cipher(con);\\r\\nBIO_printf(io, \"%s, Cipher is %s\\n\",\\r\\nSSL_CIPHER_get_version(c), SSL_CIPHER_get_name(c));\\r\\nSSL_SESSION_print(io, SSL_get_session(con));\\r\\nBIO_printf(io, \"---\\n\");\\r\\nprint_stats(io, SSL_get_SSL_CTX(con));\\r\\nBIO_printf(io, \"---\\n\");\\r\\npeer = SSL_get_peer_certificate(con);\\r\\nif (peer != NULL) {\\r\\nBIO_printf(io, \"Client certificate\\n\");\\r\\nX509_print(io, peer);\\r\\nPEM_write_bio_X509(io, peer);\\r\\n} else\\r\\nBIO_puts(io, \"no client certificate available\\n\");\\r\\nBIO_puts(io, \"</BODY></HTML>\\r\\n\\r\\n\");\\r\\nbreak;\\r\\n} else if ((www == 2 || www == 3)\\r\\n&& (strncmp(\"GET /\", buf, 5) == 0)) {\\r\\nBIO *file;\\r\\nchar *p, *e;\\r\\nstatic const char *text =\\r\\n\"HTTP/1.0 200 ok\\r\\nContent-type: text/plain\\r\\n\\r\\n\";\\r\\np = &(buf[5]);\\r\\ndot = 1;\\r\\nfor (e = p; *e != '\\0'; e++) {\\r\\nif (e[0] == ' ')\\r\\nbreak;\\r\\nswitch (dot) {\\r\\ncase 1:\\r\\ndot = (e[0] == '.') ? 2 : 0;\\r\\nbreak;\\r\\ncase 2:\\r\\ndot = (e[0] == '.') ? 3 : 0;\\r\\nbreak;\\r\\ncase 3:\\r\\ndot = (e[0] == '/') ? -1 : 0;\\r\\nbreak;\\r\\n}\\r\\nif (dot == 0)\\r\\ndot = (e[0] == '/') ? 1 : 0;\\r\\n}\\r\\ndot = (dot == 3) || (dot == -1);\\r\\nif (*e == '\\0') {\\r\\nBIO_puts(io, text);\\r\\nBIO_printf(io, \"'%s' is an invalid file name\\r\\n\", p);\\r\\nbreak;\\r\\n}\\r\\n*e = '\\0';\\r\\nif (dot) {\\r\\nBIO_puts(io, text);\\r\\nBIO_printf(io, \"'%s' contains '..' reference\\r\\n\", p);\\r\\nbreak;\\r\\n}\\r\\nif (*p == '/') {\\r\\nBIO_puts(io, text);\\r\\nBIO_printf(io, \"'%s' is an invalid path\\r\\n\", p);\\r\\nbreak;\\r\\n}\\r\\n#if 0\\r\\nif (e[-1] == '/')\\r\\nstrcat(p, \"index.html\");\\r\\n#endif\\r\\nif (app_isdir(p) > 0) {\\r\\n#if 0\\r\\nstrcat(p, \"/index.html\");\\r\\n#else\\r\\nBIO_puts(io, text);\\r\\nBIO_printf(io, \"'%s' is a directory\\r\\n\", p);\\r\\nbreak;\\r\\n#endif\\r\\n}\\r\\nif ((file = BIO_new_file(p, \"r\")) == NULL) {\\r\\nBIO_puts(io, text);\\r\\nBIO_printf(io, \"Error opening '%s'\\r\\n\", p);\\r\\nERR_print_errors(io);\\r\\nbreak;\\r\\n}\\r\\nif (!s_quiet)\\r\\nBIO_printf(bio_err, \"FILE:%s\\n\", p);\\r\\nif (www == 2) {\\r\\ni = strlen(p);\\r\\nif (((i > 5) && (strcmp(&(p[i - 5]), \".html\") == 0)) ||\\r\\n((i > 4) && (strcmp(&(p[i - 4]), \".php\") == 0)) ||\\r\\n((i > 4) && (strcmp(&(p[i - 4]), \".htm\") == 0)))\\r\\nBIO_puts(io,\\r\\n\"HTTP/1.0 200 ok\\r\\nContent-type: text/html\\r\\n\\r\\n\");\\r\\nelse\\r\\nBIO_puts(io,\\r\\n\"HTTP/1.0 200 ok\\r\\nContent-type: text/plain\\r\\n\\r\\n\");\\r\\n}\\r\\nfor (;;) {\\r\\ni = BIO_read(file, buf, bufsize);\\r\\nif (i <= 0)\\r\\nbreak;\\r\\n#ifdef RENEG\\r\\ntotal_bytes += i;\\r\\nfprintf(stderr, \"%d\\n\", i);\\r\\nif (total_bytes > 3 * 1024) {\\r\\ntotal_bytes = 0;\\r\\nfprintf(stderr, \"RENEGOTIATE\\n\");\\r\\nSSL_renegotiate(con);\\r\\n}\\r\\n#endif\\r\\nfor (j = 0; j < i;) {\\r\\n#ifdef RENEG\\r\\n{\\r\\nstatic count = 0;\\r\\nif (++count == 13) {\\r\\nSSL_renegotiate(con);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nk = BIO_write(io, &(buf[j]), i - j);\\r\\nif (k <= 0) {\\r\\nif (!BIO_should_retry(io))\\r\\ngoto write_error;\\r\\nelse {\\r\\nBIO_printf(bio_s_out, \"rwrite W BLOCK\\n\");\\r\\n}\\r\\n} else {\\r\\nj += k;\\r\\n}\\r\\n}\\r\\n}\\r\\nwrite_error:\\r\\nBIO_free(file);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nfor (;;) {\\r\\ni = (int)BIO_flush(io);\\r\\nif (i <= 0) {\\r\\nif (!BIO_should_retry(io))\\r\\nbreak;\\r\\n} else\\r\\nbreak;\\r\\n}\\r\\nend:\\r\\n#if 1\\r\\nSSL_set_shutdown(con, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);\\r\\n#else\\r\\n#endif\\r\\nerr:\\r\\nif (ret >= 0)\\r\\nBIO_printf(bio_s_out, \"ACCEPT\\n\");\\r\\nif (buf != NULL)\\r\\nOPENSSL_free(buf);\\r\\nif (io != NULL)\\r\\nBIO_free_all(io);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int rev_body(char *hostname, int s, int stype, unsigned char *context)\\r\\n{\\r\\nchar *buf = NULL;\\r\\nint i;\\r\\nint ret = 1;\\r\\nSSL *con;\\r\\nBIO *io, *ssl_bio, *sbio;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nKSSL_CTX *kctx;\\r\\n#endif\\r\\nbuf = OPENSSL_malloc(bufsize);\\r\\nif (buf == NULL)\\r\\nreturn (0);\\r\\nio = BIO_new(BIO_f_buffer());\\r\\nssl_bio = BIO_new(BIO_f_ssl());\\r\\nif ((io == NULL) || (ssl_bio == NULL))\\r\\ngoto err;\\r\\nif (!BIO_set_write_buffer_size(io, bufsize))\\r\\ngoto err;\\r\\nif ((con = SSL_new(ctx)) == NULL)\\r\\ngoto err;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (s_tlsextdebug) {\\r\\nSSL_set_tlsext_debug_callback(con, tlsext_cb);\\r\\nSSL_set_tlsext_debug_arg(con, bio_s_out);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif ((kctx = kssl_ctx_new()) != NULL) {\\r\\nkssl_ctx_setstring(kctx, KSSL_SERVICE, KRB5SVC);\\r\\nkssl_ctx_setstring(kctx, KSSL_KEYTAB, KRB5KEYTAB);\\r\\n}\\r\\n#endif\\r\\nif (context)\\r\\nSSL_set_session_id_context(con, context, strlen((char *)context));\\r\\nsbio = BIO_new_socket(s, BIO_NOCLOSE);\\r\\nSSL_set_bio(con, sbio, sbio);\\r\\nSSL_set_accept_state(con);\\r\\nBIO_set_ssl(ssl_bio, con, BIO_CLOSE);\\r\\nBIO_push(io, ssl_bio);\\r\\n#ifdef CHARSET_EBCDIC\\r\\nio = BIO_push(BIO_new(BIO_f_ebcdic_filter()), io);\\r\\n#endif\\r\\nif (s_debug) {\\r\\nSSL_set_debug(con, 1);\\r\\nBIO_set_callback(SSL_get_rbio(con), bio_dump_callback);\\r\\nBIO_set_callback_arg(SSL_get_rbio(con), (char *)bio_s_out);\\r\\n}\\r\\nif (s_msg) {\\r\\n#ifndef OPENSSL_NO_SSL_TRACE\\r\\nif (s_msg == 2)\\r\\nSSL_set_msg_callback(con, SSL_trace);\\r\\nelse\\r\\n#endif\\r\\nSSL_set_msg_callback(con, msg_cb);\\r\\nSSL_set_msg_callback_arg(con, bio_s_msg ? bio_s_msg : bio_s_out);\\r\\n}\\r\\nfor (;;) {\\r\\ni = BIO_do_handshake(io);\\r\\nif (i > 0)\\r\\nbreak;\\r\\nif (!BIO_should_retry(io)) {\\r\\nBIO_puts(bio_err, \"CONNECTION FAILURE\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err, \"CONNECTION ESTABLISHED\\n\");\\r\\nprint_ssl_summary(bio_err, con);\\r\\nfor (;;) {\\r\\ni = BIO_gets(io, buf, bufsize - 1);\\r\\nif (i < 0) {\\r\\nif (!BIO_should_retry(io)) {\\r\\nif (!s_quiet)\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n} else {\\r\\nBIO_printf(bio_s_out, \"read R BLOCK\\n\");\\r\\n#if defined(OPENSSL_SYS_NETWARE)\\r\\ndelay(1000);\\r\\n#elif !defined(OPENSSL_SYS_MSDOS) && !defined(__DJGPP__)\\r\\nsleep(1);\\r\\n#endif\\r\\ncontinue;\\r\\n}\\r\\n} else if (i == 0) {\\r\\nret = 1;\\r\\nBIO_printf(bio_err, \"CONNECTION CLOSED\\n\");\\r\\ngoto end;\\r\\n} else {\\r\\nchar *p = buf + i - 1;\\r\\nwhile (i && (*p == '\\n' || *p == '\\r')) {\\r\\np--;\\r\\ni--;\\r\\n}\\r\\nif (!s_ign_eof && i == 5 && !strncmp(buf, \"CLOSE\", 5)) {\\r\\nret = 1;\\r\\nBIO_printf(bio_err, \"CONNECTION CLOSED\\n\");\\r\\ngoto end;\\r\\n}\\r\\nBUF_reverse((unsigned char *)buf, NULL, i);\\r\\nbuf[i] = '\\n';\\r\\nBIO_write(io, buf, i + 1);\\r\\nfor (;;) {\\r\\ni = BIO_flush(io);\\r\\nif (i > 0)\\r\\nbreak;\\r\\nif (!BIO_should_retry(io))\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nend:\\r\\nSSL_set_shutdown(con, SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN);\\r\\nerr:\\r\\nif (buf != NULL)\\r\\nOPENSSL_free(buf);\\r\\nif (io != NULL)\\r\\nBIO_free_all(io);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)\\r\\n{\\r\\nBIGNUM *bn = NULL;\\r\\nstatic RSA *rsa_tmp = NULL;\\r\\nif (!rsa_tmp && ((bn = BN_new()) == NULL))\\r\\nBIO_printf(bio_err, \"Allocation error in generating RSA key\\n\");\\r\\nif (!rsa_tmp && bn) {\\r\\nif (!s_quiet) {\\r\\nBIO_printf(bio_err, \"Generating temp (%d bit) RSA key...\",\\r\\nkeylength);\\r\\n(void)BIO_flush(bio_err);\\r\\n}\\r\\nif (!BN_set_word(bn, RSA_F4) || ((rsa_tmp = RSA_new()) == NULL) ||\\r\\n!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL)) {\\r\\nif (rsa_tmp)\\r\\nRSA_free(rsa_tmp);\\r\\nrsa_tmp = NULL;\\r\\n}\\r\\nif (!s_quiet) {\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\n(void)BIO_flush(bio_err);\\r\\n}\\r\\nBN_free(bn);\\r\\n}\\r\\nreturn (rsa_tmp);\\r\\n}\\r\\nstatic int generate_session_id(const SSL *ssl, unsigned char *id,\\r\\nunsigned int *id_len)\\r\\n{\\r\\nunsigned int count = 0;\\r\\ndo {\\r\\nRAND_pseudo_bytes(id, *id_len);\\r\\nmemcpy(id, session_id_prefix,\\r\\n(strlen(session_id_prefix) < *id_len) ?\\r\\nstrlen(session_id_prefix) : *id_len);\\r\\n}\\r\\nwhile (SSL_has_matching_session_id(ssl, id, *id_len) &&\\r\\n(++count < MAX_SESSION_ID_ATTEMPTS));\\r\\nif (count >= MAX_SESSION_ID_ATTEMPTS)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int add_session(SSL *ssl, SSL_SESSION *session)\\r\\n{\\r\\nsimple_ssl_session *sess;\\r\\nunsigned char *p;\\r\\nsess = OPENSSL_malloc(sizeof(simple_ssl_session));\\r\\nSSL_SESSION_get_id(session, &sess->idlen);\\r\\nsess->derlen = i2d_SSL_SESSION(session, NULL);\\r\\nsess->id = BUF_memdup(SSL_SESSION_get_id(session, NULL), sess->idlen);\\r\\nsess->der = OPENSSL_malloc(sess->derlen);\\r\\np = sess->der;\\r\\ni2d_SSL_SESSION(session, &p);\\r\\nsess->next = first;\\r\\nfirst = sess;\\r\\nBIO_printf(bio_err, \"New session added to external cache\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nstatic SSL_SESSION *get_session(SSL *ssl, unsigned char *id, int idlen,\\r\\nint *do_copy)\\r\\n{\\r\\nsimple_ssl_session *sess;\\r\\n*do_copy = 0;\\r\\nfor (sess = first; sess; sess = sess->next) {\\r\\nif (idlen == (int)sess->idlen && !memcmp(sess->id, id, idlen)) {\\r\\nconst unsigned char *p = sess->der;\\r\\nBIO_printf(bio_err, \"Lookup session: cache hit\\n\");\\r\\nreturn d2i_SSL_SESSION(NULL, &p, sess->derlen);\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err, \"Lookup session: cache miss\\n\");\\r\\nreturn NULL;\\r\\n}\\r\\nstatic void del_session(SSL_CTX *sctx, SSL_SESSION *session)\\r\\n{\\r\\nsimple_ssl_session *sess, *prev = NULL;\\r\\nconst unsigned char *id;\\r\\nunsigned int idlen;\\r\\nid = SSL_SESSION_get_id(session, &idlen);\\r\\nfor (sess = first; sess; sess = sess->next) {\\r\\nif (idlen == sess->idlen && !memcmp(sess->id, id, idlen)) {\\r\\nif (prev)\\r\\nprev->next = sess->next;\\r\\nelse\\r\\nfirst = sess->next;\\r\\nOPENSSL_free(sess->id);\\r\\nOPENSSL_free(sess->der);\\r\\nOPENSSL_free(sess);\\r\\nreturn;\\r\\n}\\r\\nprev = sess;\\r\\n}\\r\\n}\\r\\nstatic void init_session_cache_ctx(SSL_CTX *sctx)\\r\\n{\\r\\nSSL_CTX_set_session_cache_mode(sctx,\\r\\nSSL_SESS_CACHE_NO_INTERNAL |\\r\\nSSL_SESS_CACHE_SERVER);\\r\\nSSL_CTX_sess_set_new_cb(sctx, add_session);\\r\\nSSL_CTX_sess_set_get_cb(sctx, get_session);\\r\\nSSL_CTX_sess_set_remove_cb(sctx, del_session);\\r\\n}\\r\\nstatic void free_sessions(void)\\r\\n{\\r\\nsimple_ssl_session *sess, *tsess;\\r\\nfor (sess = first; sess;) {\\r\\nOPENSSL_free(sess->id);\\r\\nOPENSSL_free(sess->der);\\r\\ntsess = sess;\\r\\nsess = sess->next;\\r\\nOPENSSL_free(tsess);\\r\\n}\\r\\nfirst = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p_lib_c", "target": 0, "func": "int EVP_PKEY_bits(EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey && pkey->ameth && pkey->ameth->pkey_bits)\\r\\nreturn pkey->ameth->pkey_bits(pkey);\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_size(EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey && pkey->ameth && pkey->ameth->pkey_size)\\r\\nreturn pkey->ameth->pkey_size(pkey);\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif (pkey->type == EVP_PKEY_DSA) {\\r\\nint ret = pkey->save_parameters;\\r\\nif (mode >= 0)\\r\\npkey->save_parameters = mode;\\r\\nreturn (ret);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\nif (pkey->type == EVP_PKEY_EC) {\\r\\nint ret = pkey->save_parameters;\\r\\nif (mode >= 0)\\r\\npkey->save_parameters = mode;\\r\\nreturn (ret);\\r\\n}\\r\\n#endif\\r\\nreturn (0);\\r\\n}\\r\\nint EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)\\r\\n{\\r\\nif (to->type != from->type) {\\r\\nEVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS, EVP_R_DIFFERENT_KEY_TYPES);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_missing_parameters(from)) {\\r\\nEVPerr(EVP_F_EVP_PKEY_COPY_PARAMETERS, EVP_R_MISSING_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\nif (from->ameth && from->ameth->param_copy)\\r\\nreturn from->ameth->param_copy(to, from);\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_missing_parameters(const EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey->ameth && pkey->ameth->param_missing)\\r\\nreturn pkey->ameth->param_missing(pkey);\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nif (a->type != b->type)\\r\\nreturn -1;\\r\\nif (a->ameth && a->ameth->param_cmp)\\r\\nreturn a->ameth->param_cmp(a, b);\\r\\nreturn -2;\\r\\n}\\r\\nint EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nif (a->type != b->type)\\r\\nreturn -1;\\r\\nif (a->ameth) {\\r\\nint ret;\\r\\nif (a->ameth->param_cmp) {\\r\\nret = a->ameth->param_cmp(a, b);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\n}\\r\\nif (a->ameth->pub_cmp)\\r\\nreturn a->ameth->pub_cmp(a, b);\\r\\n}\\r\\nreturn -2;\\r\\n}\\r\\nEVP_PKEY *EVP_PKEY_new(void)\\r\\n{\\r\\nEVP_PKEY *ret;\\r\\nret = (EVP_PKEY *)OPENSSL_malloc(sizeof(EVP_PKEY));\\r\\nif (ret == NULL) {\\r\\nEVPerr(EVP_F_EVP_PKEY_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nret->type = EVP_PKEY_NONE;\\r\\nret->save_type = EVP_PKEY_NONE;\\r\\nret->references = 1;\\r\\nret->ameth = NULL;\\r\\nret->engine = NULL;\\r\\nret->pkey.ptr = NULL;\\r\\nret->attributes = NULL;\\r\\nret->save_parameters = 1;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int pkey_set_type(EVP_PKEY *pkey, int type, const char *str, int len)\\r\\n{\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nENGINE *e = NULL;\\r\\nif (pkey) {\\r\\nif (pkey->pkey.ptr)\\r\\nEVP_PKEY_free_it(pkey);\\r\\nif ((type == pkey->save_type) && pkey->ameth)\\r\\nreturn 1;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (pkey->engine) {\\r\\nENGINE_finish(pkey->engine);\\r\\npkey->engine = NULL;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (str)\\r\\nameth = EVP_PKEY_asn1_find_str(&e, str, len);\\r\\nelse\\r\\nameth = EVP_PKEY_asn1_find(&e, type);\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (!pkey && e)\\r\\nENGINE_finish(e);\\r\\n#endif\\r\\nif (!ameth) {\\r\\nEVPerr(EVP_F_PKEY_SET_TYPE, EVP_R_UNSUPPORTED_ALGORITHM);\\r\\nreturn 0;\\r\\n}\\r\\nif (pkey) {\\r\\npkey->ameth = ameth;\\r\\npkey->engine = e;\\r\\npkey->type = pkey->ameth->pkey_id;\\r\\npkey->save_type = type;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_PKEY_set_type(EVP_PKEY *pkey, int type)\\r\\n{\\r\\nreturn pkey_set_type(pkey, type, NULL, -1);\\r\\n}\\r\\nint EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len)\\r\\n{\\r\\nreturn pkey_set_type(pkey, EVP_PKEY_NONE, str, len);\\r\\n}\\r\\nint EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key)\\r\\n{\\r\\nif (!EVP_PKEY_set_type(pkey, type))\\r\\nreturn 0;\\r\\npkey->pkey.ptr = key;\\r\\nreturn (key != NULL);\\r\\n}\\r\\nvoid *EVP_PKEY_get0(EVP_PKEY *pkey)\\r\\n{\\r\\nreturn pkey->pkey.ptr;\\r\\n}\\r\\nint EVP_PKEY_set1_RSA(EVP_PKEY *pkey, RSA *key)\\r\\n{\\r\\nint ret = EVP_PKEY_assign_RSA(pkey, key);\\r\\nif (ret)\\r\\nRSA_up_ref(key);\\r\\nreturn ret;\\r\\n}\\r\\nRSA *EVP_PKEY_get1_RSA(EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey->type != EVP_PKEY_RSA) {\\r\\nEVPerr(EVP_F_EVP_PKEY_GET1_RSA, EVP_R_EXPECTING_AN_RSA_KEY);\\r\\nreturn NULL;\\r\\n}\\r\\nRSA_up_ref(pkey->pkey.rsa);\\r\\nreturn pkey->pkey.rsa;\\r\\n}\\r\\nint EVP_PKEY_set1_DSA(EVP_PKEY *pkey, DSA *key)\\r\\n{\\r\\nint ret = EVP_PKEY_assign_DSA(pkey, key);\\r\\nif (ret)\\r\\nDSA_up_ref(key);\\r\\nreturn ret;\\r\\n}\\r\\nDSA *EVP_PKEY_get1_DSA(EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey->type != EVP_PKEY_DSA) {\\r\\nEVPerr(EVP_F_EVP_PKEY_GET1_DSA, EVP_R_EXPECTING_A_DSA_KEY);\\r\\nreturn NULL;\\r\\n}\\r\\nDSA_up_ref(pkey->pkey.dsa);\\r\\nreturn pkey->pkey.dsa;\\r\\n}\\r\\nint EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, EC_KEY *key)\\r\\n{\\r\\nint ret = EVP_PKEY_assign_EC_KEY(pkey, key);\\r\\nif (ret)\\r\\nEC_KEY_up_ref(key);\\r\\nreturn ret;\\r\\n}\\r\\nEC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey->type != EVP_PKEY_EC) {\\r\\nEVPerr(EVP_F_EVP_PKEY_GET1_EC_KEY, EVP_R_EXPECTING_A_EC_KEY);\\r\\nreturn NULL;\\r\\n}\\r\\nEC_KEY_up_ref(pkey->pkey.ec);\\r\\nreturn pkey->pkey.ec;\\r\\n}\\r\\nint EVP_PKEY_set1_DH(EVP_PKEY *pkey, DH *key)\\r\\n{\\r\\nint ret = EVP_PKEY_assign_DH(pkey, key);\\r\\nif (ret)\\r\\nDH_up_ref(key);\\r\\nreturn ret;\\r\\n}\\r\\nDH *EVP_PKEY_get1_DH(EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey->type != EVP_PKEY_DH && pkey->type != EVP_PKEY_DHX) {\\r\\nEVPerr(EVP_F_EVP_PKEY_GET1_DH, EVP_R_EXPECTING_A_DH_KEY);\\r\\nreturn NULL;\\r\\n}\\r\\nDH_up_ref(pkey->pkey.dh);\\r\\nreturn pkey->pkey.dh;\\r\\n}\\r\\nint EVP_PKEY_type(int type)\\r\\n{\\r\\nint ret;\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nENGINE *e;\\r\\nameth = EVP_PKEY_asn1_find(&e, type);\\r\\nif (ameth)\\r\\nret = ameth->pkey_id;\\r\\nelse\\r\\nret = NID_undef;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (e)\\r\\nENGINE_finish(e);\\r\\n#endif\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_PKEY_id(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn pkey->type;\\r\\n}\\r\\nint EVP_PKEY_base_id(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn EVP_PKEY_type(pkey->type);\\r\\n}\\r\\nvoid EVP_PKEY_free(EVP_PKEY *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&x->references, -1, CRYPTO_LOCK_EVP_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"EVP_PKEY\", x);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"EVP_PKEY_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nEVP_PKEY_free_it(x);\\r\\nif (x->attributes)\\r\\nsk_X509_ATTRIBUTE_pop_free(x->attributes, X509_ATTRIBUTE_free);\\r\\nOPENSSL_free(x);\\r\\n}\\r\\nstatic void EVP_PKEY_free_it(EVP_PKEY *x)\\r\\n{\\r\\nif (x->ameth && x->ameth->pkey_free) {\\r\\nx->ameth->pkey_free(x);\\r\\nx->pkey.ptr = NULL;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (x->engine) {\\r\\nENGINE_finish(x->engine);\\r\\nx->engine = NULL;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nstatic int unsup_alg(BIO *out, const EVP_PKEY *pkey, int indent,\\r\\nconst char *kstr)\\r\\n{\\r\\nBIO_indent(out, indent, 128);\\r\\nBIO_printf(out, \"%s algorithm \\\"%s\\\" unsupported\\n\",\\r\\nkstr, OBJ_nid2ln(pkey->type));\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,\\r\\nint indent, ASN1_PCTX *pctx)\\r\\n{\\r\\nif (pkey->ameth && pkey->ameth->pub_print)\\r\\nreturn pkey->ameth->pub_print(out, pkey, indent, pctx);\\r\\nreturn unsup_alg(out, pkey, indent, \"Public Key\");\\r\\n}\\r\\nint EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,\\r\\nint indent, ASN1_PCTX *pctx)\\r\\n{\\r\\nif (pkey->ameth && pkey->ameth->priv_print)\\r\\nreturn pkey->ameth->priv_print(out, pkey, indent, pctx);\\r\\nreturn unsup_alg(out, pkey, indent, \"Private Key\");\\r\\n}\\r\\nint EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,\\r\\nint indent, ASN1_PCTX *pctx)\\r\\n{\\r\\nif (pkey->ameth && pkey->ameth->param_print)\\r\\nreturn pkey->ameth->param_print(out, pkey, indent, pctx);\\r\\nreturn unsup_alg(out, pkey, indent, \"Parameters\");\\r\\n}\\r\\nint EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid)\\r\\n{\\r\\nif (!pkey->ameth || !pkey->ameth->pkey_ctrl)\\r\\nreturn -2;\\r\\nreturn pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_DEFAULT_MD_NID,\\r\\n0, pnid);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_alt_c", "target": 0, "func": "static int copy_issuer(X509V3_CTX *ctx, GENERAL_NAMES *gens)\\r\\n{\\r\\nGENERAL_NAMES *ialt;\\r\\nGENERAL_NAME *gen;\\r\\nX509_EXTENSION *ext;\\r\\nint i;\\r\\nif (ctx && (ctx->flags == CTX_TEST))\\r\\nreturn 1;\\r\\nif (!ctx || !ctx->issuer_cert) {\\r\\nX509V3err(X509V3_F_COPY_ISSUER, X509V3_R_NO_ISSUER_DETAILS);\\r\\ngoto err;\\r\\n}\\r\\ni = X509_get_ext_by_NID(ctx->issuer_cert, NID_subject_alt_name, -1);\\r\\nif (i < 0)\\r\\nreturn 1;\\r\\nif (!(ext = X509_get_ext(ctx->issuer_cert, i)) ||\\r\\n!(ialt = X509V3_EXT_d2i(ext))) {\\r\\nX509V3err(X509V3_F_COPY_ISSUER, X509V3_R_ISSUER_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < sk_GENERAL_NAME_num(ialt); i++) {\\r\\ngen = sk_GENERAL_NAME_value(ialt, i);\\r\\nif (!sk_GENERAL_NAME_push(gens, gen)) {\\r\\nX509V3err(X509V3_F_COPY_ISSUER, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nsk_GENERAL_NAME_free(ialt);\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nstatic int copy_email(X509V3_CTX *ctx, GENERAL_NAMES *gens, int move_p)\\r\\n{\\r\\nX509_NAME *nm;\\r\\nASN1_IA5STRING *email = NULL;\\r\\nX509_NAME_ENTRY *ne;\\r\\nGENERAL_NAME *gen = NULL;\\r\\nint i;\\r\\nif (ctx != NULL && ctx->flags == CTX_TEST)\\r\\nreturn 1;\\r\\nif (!ctx || (!ctx->subject_cert && !ctx->subject_req)) {\\r\\nX509V3err(X509V3_F_COPY_EMAIL, X509V3_R_NO_SUBJECT_DETAILS);\\r\\ngoto err;\\r\\n}\\r\\nif (ctx->subject_cert)\\r\\nnm = X509_get_subject_name(ctx->subject_cert);\\r\\nelse\\r\\nnm = X509_REQ_get_subject_name(ctx->subject_req);\\r\\ni = -1;\\r\\nwhile ((i = X509_NAME_get_index_by_NID(nm,\\r\\nNID_pkcs9_emailAddress, i)) >= 0) {\\r\\nne = X509_NAME_get_entry(nm, i);\\r\\nemail = M_ASN1_IA5STRING_dup(X509_NAME_ENTRY_get_data(ne));\\r\\nif (move_p) {\\r\\nX509_NAME_delete_entry(nm, i);\\r\\nX509_NAME_ENTRY_free(ne);\\r\\ni--;\\r\\n}\\r\\nif (!email || !(gen = GENERAL_NAME_new())) {\\r\\nX509V3err(X509V3_F_COPY_EMAIL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ngen->d.ia5 = email;\\r\\nemail = NULL;\\r\\ngen->type = GEN_EMAIL;\\r\\nif (!sk_GENERAL_NAME_push(gens, gen)) {\\r\\nX509V3err(X509V3_F_COPY_EMAIL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ngen = NULL;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nGENERAL_NAME_free(gen);\\r\\nM_ASN1_IA5STRING_free(email);\\r\\nreturn 0;\\r\\n}\\r\\nGENERAL_NAME *v2i_GENERAL_NAME(const X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, CONF_VALUE *cnf)\\r\\n{\\r\\nreturn v2i_GENERAL_NAME_ex(NULL, method, ctx, cnf, 0);\\r\\n}\\r\\nGENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *out,\\r\\nconst X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, int gen_type, char *value,\\r\\nint is_nc)\\r\\n{\\r\\nchar is_string = 0;\\r\\nGENERAL_NAME *gen = NULL;\\r\\nif (!value) {\\r\\nX509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_MISSING_VALUE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (out)\\r\\ngen = out;\\r\\nelse {\\r\\ngen = GENERAL_NAME_new();\\r\\nif (gen == NULL) {\\r\\nX509V3err(X509V3_F_A2I_GENERAL_NAME, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nswitch (gen_type) {\\r\\ncase GEN_URI:\\r\\ncase GEN_EMAIL:\\r\\ncase GEN_DNS:\\r\\nis_string = 1;\\r\\nbreak;\\r\\ncase GEN_RID:\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nif (!(obj = OBJ_txt2obj(value, 0))) {\\r\\nX509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_BAD_OBJECT);\\r\\nERR_add_error_data(2, \"value=\", value);\\r\\ngoto err;\\r\\n}\\r\\ngen->d.rid = obj;\\r\\n}\\r\\nbreak;\\r\\ncase GEN_IPADD:\\r\\nif (is_nc)\\r\\ngen->d.ip = a2i_IPADDRESS_NC(value);\\r\\nelse\\r\\ngen->d.ip = a2i_IPADDRESS(value);\\r\\nif (gen->d.ip == NULL) {\\r\\nX509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_BAD_IP_ADDRESS);\\r\\nERR_add_error_data(2, \"value=\", value);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase GEN_DIRNAME:\\r\\nif (!do_dirname(gen, value, ctx)) {\\r\\nX509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_DIRNAME_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase GEN_OTHERNAME:\\r\\nif (!do_othername(gen, value, ctx)) {\\r\\nX509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_OTHERNAME_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nX509V3err(X509V3_F_A2I_GENERAL_NAME, X509V3_R_UNSUPPORTED_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (is_string) {\\r\\nif (!(gen->d.ia5 = M_ASN1_IA5STRING_new()) ||\\r\\n!ASN1_STRING_set(gen->d.ia5, (unsigned char *)value,\\r\\nstrlen(value))) {\\r\\nX509V3err(X509V3_F_A2I_GENERAL_NAME, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\ngen->type = gen_type;\\r\\nreturn gen;\\r\\nerr:\\r\\nif (!out)\\r\\nGENERAL_NAME_free(gen);\\r\\nreturn NULL;\\r\\n}\\r\\nGENERAL_NAME *v2i_GENERAL_NAME_ex(GENERAL_NAME *out,\\r\\nconst X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, CONF_VALUE *cnf, int is_nc)\\r\\n{\\r\\nint type;\\r\\nchar *name, *value;\\r\\nname = cnf->name;\\r\\nvalue = cnf->value;\\r\\nif (!value) {\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX, X509V3_R_MISSING_VALUE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!name_cmp(name, \"email\"))\\r\\ntype = GEN_EMAIL;\\r\\nelse if (!name_cmp(name, \"URI\"))\\r\\ntype = GEN_URI;\\r\\nelse if (!name_cmp(name, \"DNS\"))\\r\\ntype = GEN_DNS;\\r\\nelse if (!name_cmp(name, \"RID\"))\\r\\ntype = GEN_RID;\\r\\nelse if (!name_cmp(name, \"IP\"))\\r\\ntype = GEN_IPADD;\\r\\nelse if (!name_cmp(name, \"dirName\"))\\r\\ntype = GEN_DIRNAME;\\r\\nelse if (!name_cmp(name, \"otherName\"))\\r\\ntype = GEN_OTHERNAME;\\r\\nelse {\\r\\nX509V3err(X509V3_F_V2I_GENERAL_NAME_EX, X509V3_R_UNSUPPORTED_OPTION);\\r\\nERR_add_error_data(2, \"name=\", name);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn a2i_GENERAL_NAME(out, method, ctx, type, value, is_nc);\\r\\n}\\r\\nstatic int do_othername(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)\\r\\n{\\r\\nchar *objtmp = NULL, *p;\\r\\nint objlen;\\r\\nif (!(p = strchr(value, ';')))\\r\\nreturn 0;\\r\\nif (!(gen->d.otherName = OTHERNAME_new()))\\r\\nreturn 0;\\r\\nASN1_TYPE_free(gen->d.otherName->value);\\r\\nif (!(gen->d.otherName->value = ASN1_generate_v3(p + 1, ctx)))\\r\\nreturn 0;\\r\\nobjlen = p - value;\\r\\nobjtmp = OPENSSL_malloc(objlen + 1);\\r\\nstrncpy(objtmp, value, objlen);\\r\\nobjtmp[objlen] = 0;\\r\\ngen->d.otherName->type_id = OBJ_txt2obj(objtmp, 0);\\r\\nOPENSSL_free(objtmp);\\r\\nif (!gen->d.otherName->type_id)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int do_dirname(GENERAL_NAME *gen, char *value, X509V3_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nSTACK_OF(CONF_VALUE) *sk;\\r\\nX509_NAME *nm;\\r\\nif (!(nm = X509_NAME_new()))\\r\\nreturn 0;\\r\\nsk = X509V3_get_section(ctx, value);\\r\\nif (!sk) {\\r\\nX509V3err(X509V3_F_DO_DIRNAME, X509V3_R_SECTION_NOT_FOUND);\\r\\nERR_add_error_data(2, \"section=\", value);\\r\\nX509_NAME_free(nm);\\r\\nreturn 0;\\r\\n}\\r\\nret = X509V3_NAME_from_section(nm, sk, MBSTRING_ASC);\\r\\nif (!ret)\\r\\nX509_NAME_free(nm);\\r\\ngen->d.dirn = nm;\\r\\nX509V3_section_free(ctx, sk);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_d2_c", "target": 0, "func": "int X509_STORE_set_default_paths(X509_STORE *ctx)\\r\\n{\\r\\nX509_LOOKUP *lookup;\\r\\nlookup = X509_STORE_add_lookup(ctx, X509_LOOKUP_file());\\r\\nif (lookup == NULL)\\r\\nreturn (0);\\r\\nX509_LOOKUP_load_file(lookup, NULL, X509_FILETYPE_DEFAULT);\\r\\nlookup = X509_STORE_add_lookup(ctx, X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL)\\r\\nreturn (0);\\r\\nX509_LOOKUP_add_dir(lookup, NULL, X509_FILETYPE_DEFAULT);\\r\\nERR_clear_error();\\r\\nreturn (1);\\r\\n}\\r\\nint X509_STORE_load_locations(X509_STORE *ctx, const char *file,\\r\\nconst char *path)\\r\\n{\\r\\nX509_LOOKUP *lookup;\\r\\nif (file != NULL) {\\r\\nlookup = X509_STORE_add_lookup(ctx, X509_LOOKUP_file());\\r\\nif (lookup == NULL)\\r\\nreturn (0);\\r\\nif (X509_LOOKUP_load_file(lookup, file, X509_FILETYPE_PEM) != 1)\\r\\nreturn (0);\\r\\n}\\r\\nif (path != NULL) {\\r\\nlookup = X509_STORE_add_lookup(ctx, X509_LOOKUP_hash_dir());\\r\\nif (lookup == NULL)\\r\\nreturn (0);\\r\\nif (X509_LOOKUP_add_dir(lookup, path, X509_FILETYPE_PEM) != 1)\\r\\nreturn (0);\\r\\n}\\r\\nif ((path == NULL) && (file == NULL))\\r\\nreturn (0);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_lbuf_c", "target": 0, "func": "BIO_METHOD *BIO_f_linebuffer(void)\\r\\n{\\r\\nreturn (&methods_linebuffer);\\r\\n}\\r\\nstatic int linebuffer_new(BIO *bi)\\r\\n{\\r\\nBIO_LINEBUFFER_CTX *ctx;\\r\\nctx = (BIO_LINEBUFFER_CTX *)OPENSSL_malloc(sizeof(BIO_LINEBUFFER_CTX));\\r\\nif (ctx == NULL)\\r\\nreturn (0);\\r\\nctx->obuf = (char *)OPENSSL_malloc(DEFAULT_LINEBUFFER_SIZE);\\r\\nif (ctx->obuf == NULL) {\\r\\nOPENSSL_free(ctx);\\r\\nreturn (0);\\r\\n}\\r\\nctx->obuf_size = DEFAULT_LINEBUFFER_SIZE;\\r\\nctx->obuf_len = 0;\\r\\nbi->init = 1;\\r\\nbi->ptr = (char *)ctx;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int linebuffer_free(BIO *a)\\r\\n{\\r\\nBIO_LINEBUFFER_CTX *b;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nb = (BIO_LINEBUFFER_CTX *)a->ptr;\\r\\nif (b->obuf != NULL)\\r\\nOPENSSL_free(b->obuf);\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr = NULL;\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int linebuffer_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_read(b->next_bio, out, outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int linebuffer_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint i, num = 0, foundnl;\\r\\nBIO_LINEBUFFER_CTX *ctx;\\r\\nif ((in == NULL) || (inl <= 0))\\r\\nreturn (0);\\r\\nctx = (BIO_LINEBUFFER_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL))\\r\\nreturn (0);\\r\\nBIO_clear_retry_flags(b);\\r\\ndo {\\r\\nconst char *p;\\r\\nfor (p = in; p < in + inl && *p != '\\n'; p++) ;\\r\\nif (*p == '\\n') {\\r\\np++;\\r\\nfoundnl = 1;\\r\\n} else\\r\\nfoundnl = 0;\\r\\nwhile ((foundnl || p - in > ctx->obuf_size - ctx->obuf_len)\\r\\n&& ctx->obuf_len > 0) {\\r\\nint orig_olen = ctx->obuf_len;\\r\\ni = ctx->obuf_size - ctx->obuf_len;\\r\\nif (p - in > 0) {\\r\\nif (i >= p - in) {\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]), in, p - in);\\r\\nctx->obuf_len += p - in;\\r\\ninl -= p - in;\\r\\nnum += p - in;\\r\\nin = p;\\r\\n} else {\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]), in, i);\\r\\nctx->obuf_len += i;\\r\\ninl -= i;\\r\\nin += i;\\r\\nnum += i;\\r\\n}\\r\\n}\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \"<*<\", 3);\\r\\n#endif\\r\\ni = BIO_write(b->next_bio, ctx->obuf, ctx->obuf_len);\\r\\nif (i <= 0) {\\r\\nctx->obuf_len = orig_olen;\\r\\nBIO_copy_next_retry(b);\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \">*>\", 3);\\r\\n#endif\\r\\nif (i < 0)\\r\\nreturn ((num > 0) ? num : i);\\r\\nif (i == 0)\\r\\nreturn (num);\\r\\n}\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \">*>\", 3);\\r\\n#endif\\r\\nif (i < ctx->obuf_len)\\r\\nmemmove(ctx->obuf, ctx->obuf + i, ctx->obuf_len - i);\\r\\nctx->obuf_len -= i;\\r\\n}\\r\\nif ((foundnl || p - in > ctx->obuf_size) && p - in > 0) {\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \"<*<\", 3);\\r\\n#endif\\r\\ni = BIO_write(b->next_bio, in, p - in);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \">*>\", 3);\\r\\n#endif\\r\\nif (i < 0)\\r\\nreturn ((num > 0) ? num : i);\\r\\nif (i == 0)\\r\\nreturn (num);\\r\\n}\\r\\n#if 0\\r\\nBIO_write(b->next_bio, \">*>\", 3);\\r\\n#endif\\r\\nnum += i;\\r\\nin += i;\\r\\ninl -= i;\\r\\n}\\r\\n}\\r\\nwhile (foundnl && inl > 0);\\r\\nif (inl > 0) {\\r\\nmemcpy(&(ctx->obuf[ctx->obuf_len]), in, inl);\\r\\nctx->obuf_len += inl;\\r\\nnum += inl;\\r\\n}\\r\\nreturn num;\\r\\n}\\r\\nstatic long linebuffer_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_LINEBUFFER_CTX *ctx;\\r\\nlong ret = 1;\\r\\nchar *p;\\r\\nint r;\\r\\nint obs;\\r\\nctx = (BIO_LINEBUFFER_CTX *)b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->obuf_len = 0;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret = (long)ctx->obuf_len;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = (long)ctx->obuf_len;\\r\\nif (ret == 0) {\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_BUFF_SIZE:\\r\\nobs = (int)num;\\r\\np = ctx->obuf;\\r\\nif ((obs > DEFAULT_LINEBUFFER_SIZE) && (obs != ctx->obuf_size)) {\\r\\np = (char *)OPENSSL_malloc((int)num);\\r\\nif (p == NULL)\\r\\ngoto malloc_error;\\r\\n}\\r\\nif (ctx->obuf != p) {\\r\\nif (ctx->obuf_len > obs) {\\r\\nctx->obuf_len = obs;\\r\\n}\\r\\nmemcpy(p, ctx->obuf, ctx->obuf_len);\\r\\nOPENSSL_free(ctx->obuf);\\r\\nctx->obuf = p;\\r\\nctx->obuf_size = obs;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nif (ctx->obuf_len <= 0) {\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nfor (;;) {\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->obuf_len > 0) {\\r\\nr = BIO_write(b->next_bio, ctx->obuf, ctx->obuf_len);\\r\\n#if 0\\r\\nfprintf(stderr, \"FLUSH %3d -> %3d\\n\", ctx->obuf_len, r);\\r\\n#endif\\r\\nBIO_copy_next_retry(b);\\r\\nif (r <= 0)\\r\\nreturn ((long)r);\\r\\nif (r < ctx->obuf_len)\\r\\nmemmove(ctx->obuf, ctx->obuf + r, ctx->obuf_len - r);\\r\\nctx->obuf_len -= r;\\r\\n} else {\\r\\nctx->obuf_len = 0;\\r\\nret = 1;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio = (BIO *)ptr;\\r\\nif (!BIO_set_write_buffer_size(dbio, ctx->obuf_size))\\r\\nret = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\nmalloc_error:\\r\\nBIOerr(BIO_F_LINEBUFFER_CTRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nstatic long linebuffer_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret = 1;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\nret = BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int linebuffer_gets(BIO *b, char *buf, int size)\\r\\n{\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nreturn (BIO_gets(b->next_bio, buf, size));\\r\\n}\\r\\nstatic int linebuffer_puts(BIO *b, const char *str)\\r\\n{\\r\\nreturn (linebuffer_write(b, str, strlen(str)));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_fd_c", "target": 0, "func": "BIO *BIO_new_fd(int fd, int close_flag)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nint BIO_fd_non_fatal_error(int err)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nint BIO_fd_should_retry(int i)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nBIO_METHOD *BIO_s_fd(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nBIO_METHOD *BIO_s_fd(void)\\r\\n{\\r\\nreturn (&methods_fdp);\\r\\n}\\r\\nBIO *BIO_new_fd(int fd, int close_flag)\\r\\n{\\r\\nBIO *ret;\\r\\nret = BIO_new(BIO_s_fd());\\r\\nif (ret == NULL)\\r\\nreturn (NULL);\\r\\nBIO_set_fd(ret, fd, close_flag);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int fd_new(BIO *bi)\\r\\n{\\r\\nbi->init = 0;\\r\\nbi->num = -1;\\r\\nbi->ptr = NULL;\\r\\nbi->flags = BIO_FLAGS_UPLINK;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int fd_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (a->shutdown) {\\r\\nif (a->init) {\\r\\nUP_close(a->num);\\r\\n}\\r\\na->init = 0;\\r\\na->flags = BIO_FLAGS_UPLINK;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int fd_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nif (out != NULL) {\\r\\nclear_sys_error();\\r\\nret = UP_read(b->num, out, outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0) {\\r\\nif (BIO_fd_should_retry(ret))\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int fd_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nclear_sys_error();\\r\\nret = UP_write(b->num, in, inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0) {\\r\\nif (BIO_fd_should_retry(ret))\\r\\nBIO_set_retry_write(b);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long fd_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret = 1;\\r\\nint *ip;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nnum = 0;\\r\\ncase BIO_C_FILE_SEEK:\\r\\nret = (long)UP_lseek(b->num, num, 0);\\r\\nbreak;\\r\\ncase BIO_C_FILE_TELL:\\r\\ncase BIO_CTRL_INFO:\\r\\nret = (long)UP_lseek(b->num, 0, 1);\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\nfd_free(b);\\r\\nb->num = *((int *)ptr);\\r\\nb->shutdown = (int)num;\\r\\nb->init = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init) {\\r\\nip = (int *)ptr;\\r\\nif (ip != NULL)\\r\\n*ip = b->num;\\r\\nret = b->num;\\r\\n} else\\r\\nret = -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown = (int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret = 1;\\r\\nbreak;\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int fd_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = fd_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int fd_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint ret = 0;\\r\\nchar *ptr = buf;\\r\\nchar *end = buf + size - 1;\\r\\nwhile ((ptr < end) && (fd_read(bp, ptr, 1) > 0) && (ptr[0] != '\\n'))\\r\\nptr++;\\r\\nptr[0] = '\\0';\\r\\nif (buf[0] != '\\0')\\r\\nret = strlen(buf);\\r\\nreturn (ret);\\r\\n}\\r\\nint BIO_fd_should_retry(int i)\\r\\n{\\r\\nint err;\\r\\nif ((i == 0) || (i == -1)) {\\r\\nerr = get_last_sys_error();\\r\\n# if defined(OPENSSL_SYS_WINDOWS) && 0\\r\\nif ((i == -1) && (err == 0))\\r\\nreturn (1);\\r\\n# endif\\r\\nreturn (BIO_fd_non_fatal_error(err));\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nint BIO_fd_non_fatal_error(int err)\\r\\n{\\r\\nswitch (err) {\\r\\n# ifdef EWOULDBLOCK\\r\\n# ifdef WSAEWOULDBLOCK\\r\\n# if WSAEWOULDBLOCK != EWOULDBLOCK\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n# else\\r\\ncase EWOULDBLOCK:\\r\\n# endif\\r\\n# endif\\r\\n# if defined(ENOTCONN)\\r\\ncase ENOTCONN:\\r\\n# endif\\r\\n# ifdef EINTR\\r\\ncase EINTR:\\r\\n# endif\\r\\n# ifdef EAGAIN\\r\\n# if EWOULDBLOCK != EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\n# endif\\r\\n# ifdef EPROTO\\r\\ncase EPROTO:\\r\\n# endif\\r\\n# ifdef EINPROGRESS\\r\\ncase EINPROGRESS:\\r\\n# endif\\r\\n# ifdef EALREADY\\r\\ncase EALREADY:\\r\\n# endif\\r\\nreturn (1);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn (0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_crpt_c", "target": 0, "func": "int RSA_size(const RSA *r)\\r\\n{\\r\\nreturn (BN_num_bytes(r->n));\\r\\n}\\r\\nint RSA_public_encrypt(int flen, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)\\r\\n&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nRSAerr(RSA_F_RSA_PUBLIC_ENCRYPT, RSA_R_NON_FIPS_RSA_METHOD);\\r\\nreturn -1;\\r\\n}\\r\\n#endif\\r\\nreturn (rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_private_encrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)\\r\\n&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nRSAerr(RSA_F_RSA_PRIVATE_ENCRYPT, RSA_R_NON_FIPS_RSA_METHOD);\\r\\nreturn -1;\\r\\n}\\r\\n#endif\\r\\nreturn (rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_private_decrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)\\r\\n&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nRSAerr(RSA_F_RSA_PRIVATE_DECRYPT, RSA_R_NON_FIPS_RSA_METHOD);\\r\\nreturn -1;\\r\\n}\\r\\n#endif\\r\\nreturn (rsa->meth->rsa_priv_dec(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_public_decrypt(int flen, const unsigned char *from, unsigned char *to,\\r\\nRSA *rsa, int padding)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)\\r\\n&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nRSAerr(RSA_F_RSA_PUBLIC_DECRYPT, RSA_R_NON_FIPS_RSA_METHOD);\\r\\nreturn -1;\\r\\n}\\r\\n#endif\\r\\nreturn (rsa->meth->rsa_pub_dec(flen, from, to, rsa, padding));\\r\\n}\\r\\nint RSA_flags(const RSA *r)\\r\\n{\\r\\nreturn ((r == NULL) ? 0 : r->meth->flags);\\r\\n}\\r\\nvoid RSA_blinding_off(RSA *rsa)\\r\\n{\\r\\nif (rsa->blinding != NULL) {\\r\\nBN_BLINDING_free(rsa->blinding);\\r\\nrsa->blinding = NULL;\\r\\n}\\r\\nrsa->flags &= ~RSA_FLAG_BLINDING;\\r\\nrsa->flags |= RSA_FLAG_NO_BLINDING;\\r\\n}\\r\\nint RSA_blinding_on(RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nif (rsa->blinding != NULL)\\r\\nRSA_blinding_off(rsa);\\r\\nrsa->blinding = RSA_setup_blinding(rsa, ctx);\\r\\nif (rsa->blinding == NULL)\\r\\ngoto err;\\r\\nrsa->flags |= RSA_FLAG_BLINDING;\\r\\nrsa->flags &= ~RSA_FLAG_NO_BLINDING;\\r\\nret = 1;\\r\\nerr:\\r\\nreturn (ret);\\r\\n}\\r\\nstatic BIGNUM *rsa_get_public_exp(const BIGNUM *d, const BIGNUM *p,\\r\\nconst BIGNUM *q, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *ret = NULL, *r0, *r1, *r2;\\r\\nif (d == NULL || p == NULL || q == NULL)\\r\\nreturn NULL;\\r\\nBN_CTX_start(ctx);\\r\\nr0 = BN_CTX_get(ctx);\\r\\nr1 = BN_CTX_get(ctx);\\r\\nr2 = BN_CTX_get(ctx);\\r\\nif (r2 == NULL)\\r\\ngoto err;\\r\\nif (!BN_sub(r1, p, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_sub(r2, q, BN_value_one()))\\r\\ngoto err;\\r\\nif (!BN_mul(r0, r1, r2, ctx))\\r\\ngoto err;\\r\\nret = BN_mod_inverse(NULL, d, r0, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nreturn ret;\\r\\n}\\r\\nBN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)\\r\\n{\\r\\nBIGNUM local_n;\\r\\nBIGNUM *e, *n;\\r\\nBN_CTX *ctx;\\r\\nBN_BLINDING *ret = NULL;\\r\\nif (in_ctx == NULL) {\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\n} else\\r\\nctx = in_ctx;\\r\\nBN_CTX_start(ctx);\\r\\ne = BN_CTX_get(ctx);\\r\\nif (e == NULL) {\\r\\nRSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (rsa->e == NULL) {\\r\\ne = rsa_get_public_exp(rsa->d, rsa->p, rsa->q, ctx);\\r\\nif (e == NULL) {\\r\\nRSAerr(RSA_F_RSA_SETUP_BLINDING, RSA_R_NO_PUBLIC_EXPONENT);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\ne = rsa->e;\\r\\nif ((RAND_status() == 0) && rsa->d != NULL && rsa->d->d != NULL) {\\r\\nRAND_add(rsa->d->d, rsa->d->dmax * sizeof rsa->d->d[0], 0.0);\\r\\n}\\r\\nif (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\\r\\nn = &local_n;\\r\\nBN_with_flags(n, rsa->n, BN_FLG_CONSTTIME);\\r\\n} else\\r\\nn = rsa->n;\\r\\nret = BN_BLINDING_create_param(NULL, e, n, ctx,\\r\\nrsa->meth->bn_mod_exp, rsa->_method_mod_n);\\r\\nif (ret == NULL) {\\r\\nRSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nCRYPTO_THREADID_current(BN_BLINDING_thread_id(ret));\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (in_ctx == NULL)\\r\\nBN_CTX_free(ctx);\\r\\nif (rsa->e == NULL)\\r\\nBN_free(e);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_c_alld_c", "target": 0, "func": "void OpenSSL_add_all_digests(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_MD4\\r\\nEVP_add_digest(EVP_md4());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_MD5\\r\\nEVP_add_digest(EVP_md5());\\r\\nEVP_add_digest_alias(SN_md5, \"ssl2-md5\");\\r\\nEVP_add_digest_alias(SN_md5, \"ssl3-md5\");\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA0)\\r\\nEVP_add_digest(EVP_sha());\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nEVP_add_digest(EVP_dss());\\r\\n# endif\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)\\r\\nEVP_add_digest(EVP_sha1());\\r\\nEVP_add_digest_alias(SN_sha1, \"ssl3-sha1\");\\r\\nEVP_add_digest_alias(SN_sha1WithRSAEncryption, SN_sha1WithRSA);\\r\\n# ifndef OPENSSL_NO_DSA\\r\\nEVP_add_digest(EVP_dss1());\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1, SN_dsaWithSHA1_2);\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1, \"DSS1\");\\r\\nEVP_add_digest_alias(SN_dsaWithSHA1, \"dss1\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_ECDSA\\r\\nEVP_add_digest(EVP_ecdsa());\\r\\n# endif\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_MDC2) && !defined(OPENSSL_NO_DES)\\r\\nEVP_add_digest(EVP_mdc2());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RIPEMD\\r\\nEVP_add_digest(EVP_ripemd160());\\r\\nEVP_add_digest_alias(SN_ripemd160, \"ripemd\");\\r\\nEVP_add_digest_alias(SN_ripemd160, \"rmd160\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA256\\r\\nEVP_add_digest(EVP_sha224());\\r\\nEVP_add_digest(EVP_sha256());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SHA512\\r\\nEVP_add_digest(EVP_sha384());\\r\\nEVP_add_digest(EVP_sha512());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_WHIRLPOOL\\r\\nEVP_add_digest(EVP_whirlpool());\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_rand_c", "target": 0, "func": "static int bnrand(int pseudorand, BIGNUM *rnd, int bits, int top, int bottom)\\r\\n{\\r\\nunsigned char *buf = NULL;\\r\\nint ret = 0, bit, bytes, mask;\\r\\ntime_t tim;\\r\\nif (bits == 0) {\\r\\nBN_zero(rnd);\\r\\nreturn 1;\\r\\n}\\r\\nbytes = (bits + 7) / 8;\\r\\nbit = (bits - 1) % 8;\\r\\nmask = 0xff << (bit + 1);\\r\\nbuf = (unsigned char *)OPENSSL_malloc(bytes);\\r\\nif (buf == NULL) {\\r\\nBNerr(BN_F_BNRAND, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ntime(&tim);\\r\\nRAND_add(&tim, sizeof(tim), 0.0);\\r\\nif (pseudorand) {\\r\\nif (RAND_pseudo_bytes(buf, bytes) == -1)\\r\\ngoto err;\\r\\n} else {\\r\\nif (RAND_bytes(buf, bytes) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n#if 1\\r\\nif (pseudorand == 2) {\\r\\nint i;\\r\\nunsigned char c;\\r\\nfor (i = 0; i < bytes; i++) {\\r\\nRAND_pseudo_bytes(&c, 1);\\r\\nif (c >= 128 && i > 0)\\r\\nbuf[i] = buf[i - 1];\\r\\nelse if (c < 42)\\r\\nbuf[i] = 0;\\r\\nelse if (c < 84)\\r\\nbuf[i] = 255;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (top != -1) {\\r\\nif (top) {\\r\\nif (bit == 0) {\\r\\nbuf[0] = 1;\\r\\nbuf[1] |= 0x80;\\r\\n} else {\\r\\nbuf[0] |= (3 << (bit - 1));\\r\\n}\\r\\n} else {\\r\\nbuf[0] |= (1 << bit);\\r\\n}\\r\\n}\\r\\nbuf[0] &= ~mask;\\r\\nif (bottom)\\r\\nbuf[bytes - 1] |= 1;\\r\\nif (!BN_bin2bn(buf, bytes, rnd))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (buf != NULL) {\\r\\nOPENSSL_cleanse(buf, bytes);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nbn_check_top(rnd);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_rand(BIGNUM *rnd, int bits, int top, int bottom)\\r\\n{\\r\\nreturn bnrand(0, rnd, bits, top, bottom);\\r\\n}\\r\\nint BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom)\\r\\n{\\r\\nreturn bnrand(1, rnd, bits, top, bottom);\\r\\n}\\r\\nint BN_bntest_rand(BIGNUM *rnd, int bits, int top, int bottom)\\r\\n{\\r\\nreturn bnrand(2, rnd, bits, top, bottom);\\r\\n}\\r\\nstatic int bn_rand_range(int pseudo, BIGNUM *r, const BIGNUM *range)\\r\\n{\\r\\nint (*bn_rand) (BIGNUM *, int, int, int) =\\r\\npseudo ? BN_pseudo_rand : BN_rand;\\r\\nint n;\\r\\nint count = 100;\\r\\nif (range->neg || BN_is_zero(range)) {\\r\\nBNerr(BN_F_BN_RAND_RANGE, BN_R_INVALID_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\nn = BN_num_bits(range);\\r\\nif (n == 1)\\r\\nBN_zero(r);\\r\\nelse if (!BN_is_bit_set(range, n - 2) && !BN_is_bit_set(range, n - 3)) {\\r\\ndo {\\r\\nif (!bn_rand(r, n + 1, -1, 0))\\r\\nreturn 0;\\r\\nif (BN_cmp(r, range) >= 0) {\\r\\nif (!BN_sub(r, r, range))\\r\\nreturn 0;\\r\\nif (BN_cmp(r, range) >= 0)\\r\\nif (!BN_sub(r, r, range))\\r\\nreturn 0;\\r\\n}\\r\\nif (!--count) {\\r\\nBNerr(BN_F_BN_RAND_RANGE, BN_R_TOO_MANY_ITERATIONS);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nwhile (BN_cmp(r, range) >= 0);\\r\\n} else {\\r\\ndo {\\r\\nif (!bn_rand(r, n, -1, 0))\\r\\nreturn 0;\\r\\nif (!--count) {\\r\\nBNerr(BN_F_BN_RAND_RANGE, BN_R_TOO_MANY_ITERATIONS);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nwhile (BN_cmp(r, range) >= 0);\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_rand_range(BIGNUM *r, const BIGNUM *range)\\r\\n{\\r\\nreturn bn_rand_range(0, r, range);\\r\\n}\\r\\nint BN_pseudo_rand_range(BIGNUM *r, const BIGNUM *range)\\r\\n{\\r\\nreturn bn_rand_range(1, r, range);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_gcd_c", "target": 0, "func": "int BN_gcd(BIGNUM *r, const BIGNUM *in_a, const BIGNUM *in_b, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *a, *b, *t;\\r\\nint ret = 0;\\r\\nbn_check_top(in_a);\\r\\nbn_check_top(in_b);\\r\\nBN_CTX_start(ctx);\\r\\na = BN_CTX_get(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nif (a == NULL || b == NULL)\\r\\ngoto err;\\r\\nif (BN_copy(a, in_a) == NULL)\\r\\ngoto err;\\r\\nif (BN_copy(b, in_b) == NULL)\\r\\ngoto err;\\r\\na->neg = 0;\\r\\nb->neg = 0;\\r\\nif (BN_cmp(a, b) < 0) {\\r\\nt = a;\\r\\na = b;\\r\\nb = t;\\r\\n}\\r\\nt = euclid(a, b);\\r\\nif (t == NULL)\\r\\ngoto err;\\r\\nif (BN_copy(r, t) == NULL)\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(r);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic BIGNUM *euclid(BIGNUM *a, BIGNUM *b)\\r\\n{\\r\\nBIGNUM *t;\\r\\nint shifts = 0;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nwhile (!BN_is_zero(b)) {\\r\\nif (BN_is_odd(a)) {\\r\\nif (BN_is_odd(b)) {\\r\\nif (!BN_sub(a, a, b))\\r\\ngoto err;\\r\\nif (!BN_rshift1(a, a))\\r\\ngoto err;\\r\\nif (BN_cmp(a, b) < 0) {\\r\\nt = a;\\r\\na = b;\\r\\nb = t;\\r\\n}\\r\\n} else {\\r\\nif (!BN_rshift1(b, b))\\r\\ngoto err;\\r\\nif (BN_cmp(a, b) < 0) {\\r\\nt = a;\\r\\na = b;\\r\\nb = t;\\r\\n}\\r\\n}\\r\\n} else {\\r\\nif (BN_is_odd(b)) {\\r\\nif (!BN_rshift1(a, a))\\r\\ngoto err;\\r\\nif (BN_cmp(a, b) < 0) {\\r\\nt = a;\\r\\na = b;\\r\\nb = t;\\r\\n}\\r\\n} else {\\r\\nif (!BN_rshift1(a, a))\\r\\ngoto err;\\r\\nif (!BN_rshift1(b, b))\\r\\ngoto err;\\r\\nshifts++;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (shifts) {\\r\\nif (!BN_lshift(a, a, shifts))\\r\\ngoto err;\\r\\n}\\r\\nbn_check_top(a);\\r\\nreturn (a);\\r\\nerr:\\r\\nreturn (NULL);\\r\\n}\\r\\nBIGNUM *BN_mod_inverse(BIGNUM *in,\\r\\nconst BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *A, *B, *X, *Y, *M, *D, *T, *R = NULL;\\r\\nBIGNUM *ret = NULL;\\r\\nint sign;\\r\\nif ((BN_get_flags(a, BN_FLG_CONSTTIME) != 0)\\r\\n|| (BN_get_flags(n, BN_FLG_CONSTTIME) != 0)) {\\r\\nreturn BN_mod_inverse_no_branch(in, a, n, ctx);\\r\\n}\\r\\nbn_check_top(a);\\r\\nbn_check_top(n);\\r\\nBN_CTX_start(ctx);\\r\\nA = BN_CTX_get(ctx);\\r\\nB = BN_CTX_get(ctx);\\r\\nX = BN_CTX_get(ctx);\\r\\nD = BN_CTX_get(ctx);\\r\\nM = BN_CTX_get(ctx);\\r\\nY = BN_CTX_get(ctx);\\r\\nT = BN_CTX_get(ctx);\\r\\nif (T == NULL)\\r\\ngoto err;\\r\\nif (in == NULL)\\r\\nR = BN_new();\\r\\nelse\\r\\nR = in;\\r\\nif (R == NULL)\\r\\ngoto err;\\r\\nBN_one(X);\\r\\nBN_zero(Y);\\r\\nif (BN_copy(B, a) == NULL)\\r\\ngoto err;\\r\\nif (BN_copy(A, n) == NULL)\\r\\ngoto err;\\r\\nA->neg = 0;\\r\\nif (B->neg || (BN_ucmp(B, A) >= 0)) {\\r\\nif (!BN_nnmod(B, B, A, ctx))\\r\\ngoto err;\\r\\n}\\r\\nsign = -1;\\r\\nif (BN_is_odd(n) && (BN_num_bits(n) <= (BN_BITS <= 32 ? 450 : 2048))) {\\r\\nint shift;\\r\\nwhile (!BN_is_zero(B)) {\\r\\nshift = 0;\\r\\nwhile (!BN_is_bit_set(B, shift)) {\\r\\nshift++;\\r\\nif (BN_is_odd(X)) {\\r\\nif (!BN_uadd(X, X, n))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_rshift1(X, X))\\r\\ngoto err;\\r\\n}\\r\\nif (shift > 0) {\\r\\nif (!BN_rshift(B, B, shift))\\r\\ngoto err;\\r\\n}\\r\\nshift = 0;\\r\\nwhile (!BN_is_bit_set(A, shift)) {\\r\\nshift++;\\r\\nif (BN_is_odd(Y)) {\\r\\nif (!BN_uadd(Y, Y, n))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_rshift1(Y, Y))\\r\\ngoto err;\\r\\n}\\r\\nif (shift > 0) {\\r\\nif (!BN_rshift(A, A, shift))\\r\\ngoto err;\\r\\n}\\r\\nif (BN_ucmp(B, A) >= 0) {\\r\\nif (!BN_uadd(X, X, Y))\\r\\ngoto err;\\r\\nif (!BN_usub(B, B, A))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_uadd(Y, Y, X))\\r\\ngoto err;\\r\\nif (!BN_usub(A, A, B))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n} else {\\r\\nwhile (!BN_is_zero(B)) {\\r\\nBIGNUM *tmp;\\r\\nif (BN_num_bits(A) == BN_num_bits(B)) {\\r\\nif (!BN_one(D))\\r\\ngoto err;\\r\\nif (!BN_sub(M, A, B))\\r\\ngoto err;\\r\\n} else if (BN_num_bits(A) == BN_num_bits(B) + 1) {\\r\\nif (!BN_lshift1(T, B))\\r\\ngoto err;\\r\\nif (BN_ucmp(A, T) < 0) {\\r\\nif (!BN_one(D))\\r\\ngoto err;\\r\\nif (!BN_sub(M, A, B))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_sub(M, A, T))\\r\\ngoto err;\\r\\nif (!BN_add(D, T, B))\\r\\ngoto err;\\r\\nif (BN_ucmp(A, D) < 0) {\\r\\nif (!BN_set_word(D, 2))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_set_word(D, 3))\\r\\ngoto err;\\r\\nif (!BN_sub(M, M, B))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n} else {\\r\\nif (!BN_div(D, M, A, B, ctx))\\r\\ngoto err;\\r\\n}\\r\\ntmp = A;\\r\\nA = B;\\r\\nB = M;\\r\\nif (BN_is_one(D)) {\\r\\nif (!BN_add(tmp, X, Y))\\r\\ngoto err;\\r\\n} else {\\r\\nif (BN_is_word(D, 2)) {\\r\\nif (!BN_lshift1(tmp, X))\\r\\ngoto err;\\r\\n} else if (BN_is_word(D, 4)) {\\r\\nif (!BN_lshift(tmp, X, 2))\\r\\ngoto err;\\r\\n} else if (D->top == 1) {\\r\\nif (!BN_copy(tmp, X))\\r\\ngoto err;\\r\\nif (!BN_mul_word(tmp, D->d[0]))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mul(tmp, D, X, ctx))\\r\\ngoto err;\\r\\n}\\r\\nif (!BN_add(tmp, tmp, Y))\\r\\ngoto err;\\r\\n}\\r\\nM = Y;\\r\\nY = X;\\r\\nX = tmp;\\r\\nsign = -sign;\\r\\n}\\r\\n}\\r\\nif (sign < 0) {\\r\\nif (!BN_sub(Y, n, Y))\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_one(A)) {\\r\\nif (!Y->neg && BN_ucmp(Y, n) < 0) {\\r\\nif (!BN_copy(R, Y))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_nnmod(R, Y, n, ctx))\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nBNerr(BN_F_BN_MOD_INVERSE, BN_R_NO_INVERSE);\\r\\ngoto err;\\r\\n}\\r\\nret = R;\\r\\nerr:\\r\\nif ((ret == NULL) && (in == NULL))\\r\\nBN_free(R);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(ret);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic BIGNUM *BN_mod_inverse_no_branch(BIGNUM *in,\\r\\nconst BIGNUM *a, const BIGNUM *n,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *A, *B, *X, *Y, *M, *D, *T, *R = NULL;\\r\\nBIGNUM local_A, local_B;\\r\\nBIGNUM *pA, *pB;\\r\\nBIGNUM *ret = NULL;\\r\\nint sign;\\r\\nbn_check_top(a);\\r\\nbn_check_top(n);\\r\\nBN_CTX_start(ctx);\\r\\nA = BN_CTX_get(ctx);\\r\\nB = BN_CTX_get(ctx);\\r\\nX = BN_CTX_get(ctx);\\r\\nD = BN_CTX_get(ctx);\\r\\nM = BN_CTX_get(ctx);\\r\\nY = BN_CTX_get(ctx);\\r\\nT = BN_CTX_get(ctx);\\r\\nif (T == NULL)\\r\\ngoto err;\\r\\nif (in == NULL)\\r\\nR = BN_new();\\r\\nelse\\r\\nR = in;\\r\\nif (R == NULL)\\r\\ngoto err;\\r\\nBN_one(X);\\r\\nBN_zero(Y);\\r\\nif (BN_copy(B, a) == NULL)\\r\\ngoto err;\\r\\nif (BN_copy(A, n) == NULL)\\r\\ngoto err;\\r\\nA->neg = 0;\\r\\nif (B->neg || (BN_ucmp(B, A) >= 0)) {\\r\\npB = &local_B;\\r\\nBN_with_flags(pB, B, BN_FLG_CONSTTIME);\\r\\nif (!BN_nnmod(B, pB, A, ctx))\\r\\ngoto err;\\r\\n}\\r\\nsign = -1;\\r\\nwhile (!BN_is_zero(B)) {\\r\\nBIGNUM *tmp;\\r\\npA = &local_A;\\r\\nBN_with_flags(pA, A, BN_FLG_CONSTTIME);\\r\\nif (!BN_div(D, M, pA, B, ctx))\\r\\ngoto err;\\r\\ntmp = A;\\r\\nA = B;\\r\\nB = M;\\r\\nif (!BN_mul(tmp, D, X, ctx))\\r\\ngoto err;\\r\\nif (!BN_add(tmp, tmp, Y))\\r\\ngoto err;\\r\\nM = Y;\\r\\nY = X;\\r\\nX = tmp;\\r\\nsign = -sign;\\r\\n}\\r\\nif (sign < 0) {\\r\\nif (!BN_sub(Y, n, Y))\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_one(A)) {\\r\\nif (!Y->neg && BN_ucmp(Y, n) < 0) {\\r\\nif (!BN_copy(R, Y))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_nnmod(R, Y, n, ctx))\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nBNerr(BN_F_BN_MOD_INVERSE_NO_BRANCH, BN_R_NO_INVERSE);\\r\\ngoto err;\\r\\n}\\r\\nret = R;\\r\\nerr:\\r\\nif ((ret == NULL) && (in == NULL))\\r\\nBN_free(R);\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(ret);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cfb_enc_c", "target": 0, "func": "void DES_cfb_encrypt(const unsigned char *in, unsigned char *out, int numbits,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nDES_cblock *ivec, int enc)\\r\\n{\\r\\nregister DES_LONG d0, d1, v0, v1;\\r\\nregister unsigned long l = length;\\r\\nregister int num = numbits / 8, n = (numbits + 7) / 8, i, rem =\\r\\nnumbits % 8;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\n#ifndef L_ENDIAN\\r\\nunsigned char ovec[16];\\r\\n#else\\r\\nunsigned int sh[4];\\r\\nunsigned char *ovec = (unsigned char *)sh;\\r\\nassert(sizeof(sh[0]) == 4);\\r\\n#endif\\r\\nif (numbits <= 0 || numbits > 64)\\r\\nreturn;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\nif (enc) {\\r\\nwhile (l >= (unsigned long)n) {\\r\\nl -= n;\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\nDES_encrypt1((DES_LONG *)ti, schedule, DES_ENCRYPT);\\r\\nc2ln(in, d0, d1, n);\\r\\nin += n;\\r\\nd0 ^= ti[0];\\r\\nd1 ^= ti[1];\\r\\nl2cn(d0, d1, out, n);\\r\\nout += n;\\r\\nif (numbits == 32) {\\r\\nv0 = v1;\\r\\nv1 = d0;\\r\\n} else if (numbits == 64) {\\r\\nv0 = d0;\\r\\nv1 = d1;\\r\\n} else {\\r\\n#ifndef L_ENDIAN\\r\\niv = &ovec[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\nl2c(d0, iv);\\r\\nl2c(d1, iv);\\r\\n#else\\r\\nsh[0] = v0, sh[1] = v1, sh[2] = d0, sh[3] = d1;\\r\\n#endif\\r\\nif (rem == 0)\\r\\nmemmove(ovec, ovec + num, 8);\\r\\nelse\\r\\nfor (i = 0; i < 8; ++i)\\r\\novec[i] = ovec[i + num] << rem |\\r\\novec[i + num + 1] >> (8 - rem);\\r\\n#ifdef L_ENDIAN\\r\\nv0 = sh[0], v1 = sh[1];\\r\\n#else\\r\\niv = &ovec[0];\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\n#endif\\r\\n}\\r\\n}\\r\\n} else {\\r\\nwhile (l >= (unsigned long)n) {\\r\\nl -= n;\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\nDES_encrypt1((DES_LONG *)ti, schedule, DES_ENCRYPT);\\r\\nc2ln(in, d0, d1, n);\\r\\nin += n;\\r\\nif (numbits == 32) {\\r\\nv0 = v1;\\r\\nv1 = d0;\\r\\n} else if (numbits == 64) {\\r\\nv0 = d0;\\r\\nv1 = d1;\\r\\n} else {\\r\\n#ifndef L_ENDIAN\\r\\niv = &ovec[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\nl2c(d0, iv);\\r\\nl2c(d1, iv);\\r\\n#else\\r\\nsh[0] = v0, sh[1] = v1, sh[2] = d0, sh[3] = d1;\\r\\n#endif\\r\\nif (rem == 0)\\r\\nmemmove(ovec, ovec + num, 8);\\r\\nelse\\r\\nfor (i = 0; i < 8; ++i)\\r\\novec[i] = ovec[i + num] << rem |\\r\\novec[i + num + 1] >> (8 - rem);\\r\\n#ifdef L_ENDIAN\\r\\nv0 = sh[0], v1 = sh[1];\\r\\n#else\\r\\niv = &ovec[0];\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\n#endif\\r\\n}\\r\\nd0 ^= ti[0];\\r\\nd1 ^= ti[1];\\r\\nl2cn(d0, d1, out, n);\\r\\nout += n;\\r\\n}\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\nv0 = v1 = d0 = d1 = ti[0] = ti[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_pss_c", "target": 0, "func": "int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,\\r\\nconst EVP_MD *Hash, const unsigned char *EM,\\r\\nint sLen)\\r\\n{\\r\\nreturn RSA_verify_PKCS1_PSS_mgf1(rsa, mHash, Hash, NULL, EM, sLen);\\r\\n}\\r\\nint RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,\\r\\nconst EVP_MD *Hash, const EVP_MD *mgf1Hash,\\r\\nconst unsigned char *EM, int sLen)\\r\\n{\\r\\nint i;\\r\\nint ret = 0;\\r\\nint hLen, maskedDBLen, MSBits, emLen;\\r\\nconst unsigned char *H;\\r\\nunsigned char *DB = NULL;\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char H_[EVP_MAX_MD_SIZE];\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nif (mgf1Hash == NULL)\\r\\nmgf1Hash = Hash;\\r\\nhLen = EVP_MD_size(Hash);\\r\\nif (hLen < 0)\\r\\ngoto err;\\r\\nif (sLen == -1)\\r\\nsLen = hLen;\\r\\nelse if (sLen == -2)\\r\\nsLen = -2;\\r\\nelse if (sLen < -2) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_SLEN_CHECK_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nMSBits = (BN_num_bits(rsa->n) - 1) & 0x7;\\r\\nemLen = RSA_size(rsa);\\r\\nif (EM[0] & (0xFF << MSBits)) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_FIRST_OCTET_INVALID);\\r\\ngoto err;\\r\\n}\\r\\nif (MSBits == 0) {\\r\\nEM++;\\r\\nemLen--;\\r\\n}\\r\\nif (emLen < (hLen + sLen + 2)) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_DATA_TOO_LARGE);\\r\\ngoto err;\\r\\n}\\r\\nif (EM[emLen - 1] != 0xbc) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_LAST_OCTET_INVALID);\\r\\ngoto err;\\r\\n}\\r\\nmaskedDBLen = emLen - hLen - 1;\\r\\nH = EM + maskedDBLen;\\r\\nDB = OPENSSL_malloc(maskedDBLen);\\r\\nif (!DB) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (PKCS1_MGF1(DB, maskedDBLen, H, hLen, mgf1Hash) < 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < maskedDBLen; i++)\\r\\nDB[i] ^= EM[i];\\r\\nif (MSBits)\\r\\nDB[0] &= 0xFF >> (8 - MSBits);\\r\\nfor (i = 0; DB[i] == 0 && i < (maskedDBLen - 1); i++) ;\\r\\nif (DB[i++] != 0x1) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_SLEN_RECOVERY_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nif (sLen >= 0 && (maskedDBLen - i) != sLen) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_SLEN_CHECK_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DigestInit_ex(&ctx, Hash, NULL)\\r\\n|| !EVP_DigestUpdate(&ctx, zeroes, sizeof zeroes)\\r\\n|| !EVP_DigestUpdate(&ctx, mHash, hLen))\\r\\ngoto err;\\r\\nif (maskedDBLen - i) {\\r\\nif (!EVP_DigestUpdate(&ctx, DB + i, maskedDBLen - i))\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DigestFinal_ex(&ctx, H_, NULL))\\r\\ngoto err;\\r\\nif (memcmp(H_, H, hLen)) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1, RSA_R_BAD_SIGNATURE);\\r\\nret = 0;\\r\\n} else\\r\\nret = 1;\\r\\nerr:\\r\\nif (DB)\\r\\nOPENSSL_free(DB);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,\\r\\nconst unsigned char *mHash,\\r\\nconst EVP_MD *Hash, int sLen)\\r\\n{\\r\\nreturn RSA_padding_add_PKCS1_PSS_mgf1(rsa, EM, mHash, Hash, NULL, sLen);\\r\\n}\\r\\nint RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,\\r\\nconst unsigned char *mHash,\\r\\nconst EVP_MD *Hash, const EVP_MD *mgf1Hash,\\r\\nint sLen)\\r\\n{\\r\\nint i;\\r\\nint ret = 0;\\r\\nint hLen, maskedDBLen, MSBits, emLen;\\r\\nunsigned char *H, *salt = NULL, *p;\\r\\nEVP_MD_CTX ctx;\\r\\nif (mgf1Hash == NULL)\\r\\nmgf1Hash = Hash;\\r\\nhLen = EVP_MD_size(Hash);\\r\\nif (hLen < 0)\\r\\ngoto err;\\r\\nif (sLen == -1)\\r\\nsLen = hLen;\\r\\nelse if (sLen == -2)\\r\\nsLen = -2;\\r\\nelse if (sLen < -2) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1, RSA_R_SLEN_CHECK_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nMSBits = (BN_num_bits(rsa->n) - 1) & 0x7;\\r\\nemLen = RSA_size(rsa);\\r\\nif (MSBits == 0) {\\r\\n*EM++ = 0;\\r\\nemLen--;\\r\\n}\\r\\nif (sLen == -2) {\\r\\nsLen = emLen - hLen - 2;\\r\\n} else if (emLen < (hLen + sLen + 2)) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1,\\r\\nRSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\ngoto err;\\r\\n}\\r\\nif (sLen > 0) {\\r\\nsalt = OPENSSL_malloc(sLen);\\r\\nif (!salt) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1,\\r\\nERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (RAND_bytes(salt, sLen) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nmaskedDBLen = emLen - hLen - 1;\\r\\nH = EM + maskedDBLen;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nif (!EVP_DigestInit_ex(&ctx, Hash, NULL)\\r\\n|| !EVP_DigestUpdate(&ctx, zeroes, sizeof zeroes)\\r\\n|| !EVP_DigestUpdate(&ctx, mHash, hLen))\\r\\ngoto err;\\r\\nif (sLen && !EVP_DigestUpdate(&ctx, salt, sLen))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&ctx, H, NULL))\\r\\ngoto err;\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nif (PKCS1_MGF1(EM, maskedDBLen, H, hLen, mgf1Hash))\\r\\ngoto err;\\r\\np = EM;\\r\\np += emLen - sLen - hLen - 2;\\r\\n*p++ ^= 0x1;\\r\\nif (sLen > 0) {\\r\\nfor (i = 0; i < sLen; i++)\\r\\n*p++ ^= salt[i];\\r\\n}\\r\\nif (MSBits)\\r\\nEM[0] &= 0xFF >> (8 - MSBits);\\r\\nEM[emLen - 1] = 0xbc;\\r\\nret = 1;\\r\\nerr:\\r\\nif (salt)\\r\\nOPENSSL_free(salt);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_mem_c", "target": 0, "func": "BIO_METHOD *BIO_s_mem(void)\\r\\n{\\r\\nreturn (&mem_method);\\r\\n}\\r\\nBIO *BIO_new_mem_buf(void *buf, int len)\\r\\n{\\r\\nBIO *ret;\\r\\nBUF_MEM *b;\\r\\nsize_t sz;\\r\\nif (!buf) {\\r\\nBIOerr(BIO_F_BIO_NEW_MEM_BUF, BIO_R_NULL_PARAMETER);\\r\\nreturn NULL;\\r\\n}\\r\\nsz = (len < 0) ? strlen(buf) : (size_t)len;\\r\\nif (!(ret = BIO_new(BIO_s_mem())))\\r\\nreturn NULL;\\r\\nb = (BUF_MEM *)ret->ptr;\\r\\nb->data = buf;\\r\\nb->length = sz;\\r\\nb->max = sz;\\r\\nret->flags |= BIO_FLAGS_MEM_RDONLY;\\r\\nret->num = 0;\\r\\nreturn ret;\\r\\n}\\r\\nstatic int mem_new(BIO *bi)\\r\\n{\\r\\nBUF_MEM *b;\\r\\nif ((b = BUF_MEM_new()) == NULL)\\r\\nreturn (0);\\r\\nbi->shutdown = 1;\\r\\nbi->init = 1;\\r\\nbi->num = -1;\\r\\nbi->ptr = (char *)b;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int mem_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (a->shutdown) {\\r\\nif ((a->init) && (a->ptr != NULL)) {\\r\\nBUF_MEM *b;\\r\\nb = (BUF_MEM *)a->ptr;\\r\\nif (a->flags & BIO_FLAGS_MEM_RDONLY)\\r\\nb->data = NULL;\\r\\nBUF_MEM_free(b);\\r\\na->ptr = NULL;\\r\\n}\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int mem_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = -1;\\r\\nBUF_MEM *bm;\\r\\nbm = (BUF_MEM *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\nret = (outl >= 0 && (size_t)outl > bm->length) ? (int)bm->length : outl;\\r\\nif ((out != NULL) && (ret > 0)) {\\r\\nmemcpy(out, bm->data, ret);\\r\\nbm->length -= ret;\\r\\nif (b->flags & BIO_FLAGS_MEM_RDONLY)\\r\\nbm->data += ret;\\r\\nelse {\\r\\nmemmove(&(bm->data[0]), &(bm->data[ret]), bm->length);\\r\\n}\\r\\n} else if (bm->length == 0) {\\r\\nret = b->num;\\r\\nif (ret != 0)\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int mem_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret = -1;\\r\\nint blen;\\r\\nBUF_MEM *bm;\\r\\nbm = (BUF_MEM *)b->ptr;\\r\\nif (in == NULL) {\\r\\nBIOerr(BIO_F_MEM_WRITE, BIO_R_NULL_PARAMETER);\\r\\ngoto end;\\r\\n}\\r\\nif (b->flags & BIO_FLAGS_MEM_RDONLY) {\\r\\nBIOerr(BIO_F_MEM_WRITE, BIO_R_WRITE_TO_READ_ONLY_BIO);\\r\\ngoto end;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nblen = bm->length;\\r\\nif (BUF_MEM_grow_clean(bm, blen + inl) != (blen + inl))\\r\\ngoto end;\\r\\nmemcpy(&(bm->data[blen]), in, inl);\\r\\nret = inl;\\r\\nend:\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long mem_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret = 1;\\r\\nchar **pptr;\\r\\nBUF_MEM *bm = (BUF_MEM *)b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nif (bm->data != NULL) {\\r\\nif (b->flags & BIO_FLAGS_MEM_RDONLY) {\\r\\nbm->data -= bm->max - bm->length;\\r\\nbm->length = bm->max;\\r\\n} else {\\r\\nmemset(bm->data, 0, bm->max);\\r\\nbm->length = 0;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nret = (long)(bm->length == 0);\\r\\nbreak;\\r\\ncase BIO_C_SET_BUF_MEM_EOF_RETURN:\\r\\nb->num = (int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\nret = (long)bm->length;\\r\\nif (ptr != NULL) {\\r\\npptr = (char **)ptr;\\r\\n*pptr = (char *)&(bm->data[0]);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_BUF_MEM:\\r\\nmem_free(b);\\r\\nb->shutdown = (int)num;\\r\\nb->ptr = ptr;\\r\\nbreak;\\r\\ncase BIO_C_GET_BUF_MEM_PTR:\\r\\nif (ptr != NULL) {\\r\\npptr = (char **)ptr;\\r\\n*pptr = (char *)bm;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = (long)b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown = (int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = 0L;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret = (long)bm->length;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_PUSH:\\r\\ncase BIO_CTRL_POP:\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int mem_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint i, j;\\r\\nint ret = -1;\\r\\nchar *p;\\r\\nBUF_MEM *bm = (BUF_MEM *)bp->ptr;\\r\\nBIO_clear_retry_flags(bp);\\r\\nj = bm->length;\\r\\nif ((size - 1) < j)\\r\\nj = size - 1;\\r\\nif (j <= 0) {\\r\\n*buf = '\\0';\\r\\nreturn 0;\\r\\n}\\r\\np = bm->data;\\r\\nfor (i = 0; i < j; i++) {\\r\\nif (p[i] == '\\n') {\\r\\ni++;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\ni = mem_read(bp, buf, i);\\r\\nif (i > 0)\\r\\nbuf[i] = '\\0';\\r\\nret = i;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int mem_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = mem_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_add_c", "target": 0, "func": "int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nconst BIGNUM *tmp;\\r\\nint a_neg = a->neg, ret;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a_neg ^ b->neg) {\\r\\nif (a_neg) {\\r\\ntmp = a;\\r\\na = b;\\r\\nb = tmp;\\r\\n}\\r\\nif (BN_ucmp(a, b) < 0) {\\r\\nif (!BN_usub(r, b, a))\\r\\nreturn (0);\\r\\nr->neg = 1;\\r\\n} else {\\r\\nif (!BN_usub(r, a, b))\\r\\nreturn (0);\\r\\nr->neg = 0;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nret = BN_uadd(r, a, b);\\r\\nr->neg = a_neg;\\r\\nbn_check_top(r);\\r\\nreturn ret;\\r\\n}\\r\\nint BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint max, min, dif;\\r\\nBN_ULONG *ap, *bp, *rp, carry, t1, t2;\\r\\nconst BIGNUM *tmp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->top < b->top) {\\r\\ntmp = a;\\r\\na = b;\\r\\nb = tmp;\\r\\n}\\r\\nmax = a->top;\\r\\nmin = b->top;\\r\\ndif = max - min;\\r\\nif (bn_wexpand(r, max + 1) == NULL)\\r\\nreturn 0;\\r\\nr->top = max;\\r\\nap = a->d;\\r\\nbp = b->d;\\r\\nrp = r->d;\\r\\ncarry = bn_add_words(rp, ap, bp, min);\\r\\nrp += min;\\r\\nap += min;\\r\\nbp += min;\\r\\nif (carry) {\\r\\nwhile (dif) {\\r\\ndif--;\\r\\nt1 = *(ap++);\\r\\nt2 = (t1 + 1) & BN_MASK2;\\r\\n*(rp++) = t2;\\r\\nif (t2) {\\r\\ncarry = 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (carry) {\\r\\n*rp = 1;\\r\\nr->top++;\\r\\n}\\r\\n}\\r\\nif (dif && rp != ap)\\r\\nwhile (dif--)\\r\\n*(rp++) = *(ap++);\\r\\nr->neg = 0;\\r\\nbn_check_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint max, min, dif;\\r\\nregister BN_ULONG t1, t2, *ap, *bp, *rp;\\r\\nint i, carry;\\r\\n#if defined(IRIX_CC_BUG) && !defined(LINT)\\r\\nint dummy;\\r\\n#endif\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nmax = a->top;\\r\\nmin = b->top;\\r\\ndif = max - min;\\r\\nif (dif < 0) {\\r\\nBNerr(BN_F_BN_USUB, BN_R_ARG2_LT_ARG3);\\r\\nreturn (0);\\r\\n}\\r\\nif (bn_wexpand(r, max) == NULL)\\r\\nreturn (0);\\r\\nap = a->d;\\r\\nbp = b->d;\\r\\nrp = r->d;\\r\\n#if 1\\r\\ncarry = 0;\\r\\nfor (i = min; i != 0; i--) {\\r\\nt1 = *(ap++);\\r\\nt2 = *(bp++);\\r\\nif (carry) {\\r\\ncarry = (t1 <= t2);\\r\\nt1 = (t1 - t2 - 1) & BN_MASK2;\\r\\n} else {\\r\\ncarry = (t1 < t2);\\r\\nt1 = (t1 - t2) & BN_MASK2;\\r\\n}\\r\\n# if defined(IRIX_CC_BUG) && !defined(LINT)\\r\\ndummy = t1;\\r\\n# endif\\r\\n*(rp++) = t1 & BN_MASK2;\\r\\n}\\r\\n#else\\r\\ncarry = bn_sub_words(rp, ap, bp, min);\\r\\nap += min;\\r\\nbp += min;\\r\\nrp += min;\\r\\n#endif\\r\\nif (carry) {\\r\\nif (!dif)\\r\\nreturn 0;\\r\\nwhile (dif) {\\r\\ndif--;\\r\\nt1 = *(ap++);\\r\\nt2 = (t1 - 1) & BN_MASK2;\\r\\n*(rp++) = t2;\\r\\nif (t1)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n#if 0\\r\\nmemcpy(rp, ap, sizeof(*rp) * (max - i));\\r\\n#else\\r\\nif (rp != ap) {\\r\\nfor (;;) {\\r\\nif (!dif--)\\r\\nbreak;\\r\\nrp[0] = ap[0];\\r\\nif (!dif--)\\r\\nbreak;\\r\\nrp[1] = ap[1];\\r\\nif (!dif--)\\r\\nbreak;\\r\\nrp[2] = ap[2];\\r\\nif (!dif--)\\r\\nbreak;\\r\\nrp[3] = ap[3];\\r\\nrp += 4;\\r\\nap += 4;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nr->top = max;\\r\\nr->neg = 0;\\r\\nbn_correct_top(r);\\r\\nreturn (1);\\r\\n}\\r\\nint BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint max;\\r\\nint add = 0, neg = 0;\\r\\nconst BIGNUM *tmp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->neg) {\\r\\nif (b->neg) {\\r\\ntmp = a;\\r\\na = b;\\r\\nb = tmp;\\r\\n} else {\\r\\nadd = 1;\\r\\nneg = 1;\\r\\n}\\r\\n} else {\\r\\nif (b->neg) {\\r\\nadd = 1;\\r\\nneg = 0;\\r\\n}\\r\\n}\\r\\nif (add) {\\r\\nif (!BN_uadd(r, a, b))\\r\\nreturn (0);\\r\\nr->neg = neg;\\r\\nreturn (1);\\r\\n}\\r\\nmax = (a->top > b->top) ? a->top : b->top;\\r\\nif (bn_wexpand(r, max) == NULL)\\r\\nreturn (0);\\r\\nif (BN_ucmp(a, b) < 0) {\\r\\nif (!BN_usub(r, b, a))\\r\\nreturn (0);\\r\\nr->neg = 1;\\r\\n} else {\\r\\nif (!BN_usub(r, a, b))\\r\\nreturn (0);\\r\\nr->neg = 0;\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_b64_c", "target": 0, "func": "BIO_METHOD *BIO_f_base64(void)\\r\\n{\\r\\nreturn (&methods_b64);\\r\\n}\\r\\nstatic int b64_new(BIO *bi)\\r\\n{\\r\\nBIO_B64_CTX *ctx;\\r\\nctx = (BIO_B64_CTX *)OPENSSL_malloc(sizeof(BIO_B64_CTX));\\r\\nif (ctx == NULL)\\r\\nreturn (0);\\r\\nctx->buf_len = 0;\\r\\nctx->tmp_len = 0;\\r\\nctx->tmp_nl = 0;\\r\\nctx->buf_off = 0;\\r\\nctx->cont = 1;\\r\\nctx->start = 1;\\r\\nctx->encode = 0;\\r\\nbi->init = 1;\\r\\nbi->ptr = (char *)ctx;\\r\\nbi->flags = 0;\\r\\nbi->num = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int b64_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr = NULL;\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int b64_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0, i, ii, j, k, x, n, num, ret_code = 0;\\r\\nBIO_B64_CTX *ctx;\\r\\nunsigned char *p, *q;\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nctx = (BIO_B64_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL))\\r\\nreturn (0);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->encode != B64_DECODE) {\\r\\nctx->encode = B64_DECODE;\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\nctx->tmp_len = 0;\\r\\nEVP_DecodeInit(&(ctx->base64));\\r\\n}\\r\\nif (ctx->buf_len > 0) {\\r\\nOPENSSL_assert(ctx->buf_len >= ctx->buf_off);\\r\\ni = ctx->buf_len - ctx->buf_off;\\r\\nif (i > outl)\\r\\ni = outl;\\r\\nOPENSSL_assert(ctx->buf_off + i < (int)sizeof(ctx->buf));\\r\\nmemcpy(out, &(ctx->buf[ctx->buf_off]), i);\\r\\nret = i;\\r\\nout += i;\\r\\noutl -= i;\\r\\nctx->buf_off += i;\\r\\nif (ctx->buf_len == ctx->buf_off) {\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\n}\\r\\n}\\r\\nret_code = 0;\\r\\nwhile (outl > 0) {\\r\\nif (ctx->cont <= 0)\\r\\nbreak;\\r\\ni = BIO_read(b->next_bio, &(ctx->tmp[ctx->tmp_len]),\\r\\nB64_BLOCK_SIZE - ctx->tmp_len);\\r\\nif (i <= 0) {\\r\\nret_code = i;\\r\\nif (!BIO_should_retry(b->next_bio)) {\\r\\nctx->cont = i;\\r\\nif (ctx->tmp_len == 0)\\r\\nbreak;\\r\\nelse\\r\\ni = 0;\\r\\n}\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\ni += ctx->tmp_len;\\r\\nctx->tmp_len = i;\\r\\nif (ctx->start && (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL)) {\\r\\nctx->tmp_len = 0;\\r\\n} else if (ctx->start) {\\r\\nq = p = (unsigned char *)ctx->tmp;\\r\\nnum = 0;\\r\\nfor (j = 0; j < i; j++) {\\r\\nif (*(q++) != '\\n')\\r\\ncontinue;\\r\\nif (ctx->tmp_nl) {\\r\\np = q;\\r\\nctx->tmp_nl = 0;\\r\\ncontinue;\\r\\n}\\r\\nk = EVP_DecodeUpdate(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf,\\r\\n&num, p, q - p);\\r\\nif ((k <= 0) && (num == 0) && (ctx->start))\\r\\nEVP_DecodeInit(&ctx->base64);\\r\\nelse {\\r\\nif (p != (unsigned char *)\\r\\n&(ctx->tmp[0])) {\\r\\ni -= (p - (unsigned char *)\\r\\n&(ctx->tmp[0]));\\r\\nfor (x = 0; x < i; x++)\\r\\nctx->tmp[x] = p[x];\\r\\n}\\r\\nEVP_DecodeInit(&ctx->base64);\\r\\nctx->start = 0;\\r\\nbreak;\\r\\n}\\r\\np = q;\\r\\n}\\r\\nif ((j == i) && (num == 0)) {\\r\\nif (p == (unsigned char *)&(ctx->tmp[0])) {\\r\\nif (i == B64_BLOCK_SIZE) {\\r\\nctx->tmp_nl = 1;\\r\\nctx->tmp_len = 0;\\r\\n}\\r\\n} else if (p != q) {\\r\\nn = q - p;\\r\\nfor (ii = 0; ii < n; ii++)\\r\\nctx->tmp[ii] = p[ii];\\r\\nctx->tmp_len = n;\\r\\n}\\r\\ncontinue;\\r\\n} else {\\r\\nctx->tmp_len = 0;\\r\\n}\\r\\n} else if ((i < B64_BLOCK_SIZE) && (ctx->cont > 0)) {\\r\\ncontinue;\\r\\n}\\r\\nif (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL) {\\r\\nint z, jj;\\r\\n#if 0\\r\\njj = (i >> 2) << 2;\\r\\n#else\\r\\njj = i & ~3;\\r\\n#endif\\r\\nz = EVP_DecodeBlock((unsigned char *)ctx->buf,\\r\\n(unsigned char *)ctx->tmp, jj);\\r\\nif (jj > 2) {\\r\\nif (ctx->tmp[jj - 1] == '=') {\\r\\nz--;\\r\\nif (ctx->tmp[jj - 2] == '=')\\r\\nz--;\\r\\n}\\r\\n}\\r\\nif (jj != i) {\\r\\nmemmove(ctx->tmp, &ctx->tmp[jj], i - jj);\\r\\nctx->tmp_len = i - jj;\\r\\n}\\r\\nctx->buf_len = 0;\\r\\nif (z > 0) {\\r\\nctx->buf_len = z;\\r\\n}\\r\\ni = z;\\r\\n} else {\\r\\ni = EVP_DecodeUpdate(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf, &ctx->buf_len,\\r\\n(unsigned char *)ctx->tmp, i);\\r\\nctx->tmp_len = 0;\\r\\n}\\r\\nctx->buf_off = 0;\\r\\nif (i < 0) {\\r\\nret_code = 0;\\r\\nctx->buf_len = 0;\\r\\nbreak;\\r\\n}\\r\\nif (ctx->buf_len <= outl)\\r\\ni = ctx->buf_len;\\r\\nelse\\r\\ni = outl;\\r\\nmemcpy(out, ctx->buf, i);\\r\\nret += i;\\r\\nctx->buf_off = i;\\r\\nif (ctx->buf_off == ctx->buf_len) {\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\n}\\r\\noutl -= i;\\r\\nout += i;\\r\\n}\\r\\nBIO_copy_next_retry(b);\\r\\nreturn ((ret == 0) ? ret_code : ret);\\r\\n}\\r\\nstatic int b64_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret = 0;\\r\\nint n;\\r\\nint i;\\r\\nBIO_B64_CTX *ctx;\\r\\nctx = (BIO_B64_CTX *)b->ptr;\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ctx->encode != B64_ENCODE) {\\r\\nctx->encode = B64_ENCODE;\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\nctx->tmp_len = 0;\\r\\nEVP_EncodeInit(&(ctx->base64));\\r\\n}\\r\\nOPENSSL_assert(ctx->buf_off < (int)sizeof(ctx->buf));\\r\\nOPENSSL_assert(ctx->buf_len <= (int)sizeof(ctx->buf));\\r\\nOPENSSL_assert(ctx->buf_len >= ctx->buf_off);\\r\\nn = ctx->buf_len - ctx->buf_off;\\r\\nwhile (n > 0) {\\r\\ni = BIO_write(b->next_bio, &(ctx->buf[ctx->buf_off]), n);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (i);\\r\\n}\\r\\nOPENSSL_assert(i <= n);\\r\\nctx->buf_off += i;\\r\\nOPENSSL_assert(ctx->buf_off <= (int)sizeof(ctx->buf));\\r\\nOPENSSL_assert(ctx->buf_len >= ctx->buf_off);\\r\\nn -= i;\\r\\n}\\r\\nctx->buf_off = 0;\\r\\nctx->buf_len = 0;\\r\\nif ((in == NULL) || (inl <= 0))\\r\\nreturn (0);\\r\\nwhile (inl > 0) {\\r\\nn = (inl > B64_BLOCK_SIZE) ? B64_BLOCK_SIZE : inl;\\r\\nif (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL) {\\r\\nif (ctx->tmp_len > 0) {\\r\\nOPENSSL_assert(ctx->tmp_len <= 3);\\r\\nn = 3 - ctx->tmp_len;\\r\\nif (n > inl)\\r\\nn = inl;\\r\\nmemcpy(&(ctx->tmp[ctx->tmp_len]), in, n);\\r\\nctx->tmp_len += n;\\r\\nret += n;\\r\\nif (ctx->tmp_len < 3)\\r\\nbreak;\\r\\nctx->buf_len =\\r\\nEVP_EncodeBlock((unsigned char *)ctx->buf,\\r\\n(unsigned char *)ctx->tmp, ctx->tmp_len);\\r\\nOPENSSL_assert(ctx->buf_len <= (int)sizeof(ctx->buf));\\r\\nOPENSSL_assert(ctx->buf_len >= ctx->buf_off);\\r\\nctx->tmp_len = 0;\\r\\n} else {\\r\\nif (n < 3) {\\r\\nmemcpy(ctx->tmp, in, n);\\r\\nctx->tmp_len = n;\\r\\nret += n;\\r\\nbreak;\\r\\n}\\r\\nn -= n % 3;\\r\\nctx->buf_len =\\r\\nEVP_EncodeBlock((unsigned char *)ctx->buf,\\r\\n(const unsigned char *)in, n);\\r\\nOPENSSL_assert(ctx->buf_len <= (int)sizeof(ctx->buf));\\r\\nOPENSSL_assert(ctx->buf_len >= ctx->buf_off);\\r\\nret += n;\\r\\n}\\r\\n} else {\\r\\nEVP_EncodeUpdate(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf, &ctx->buf_len,\\r\\n(unsigned char *)in, n);\\r\\nOPENSSL_assert(ctx->buf_len <= (int)sizeof(ctx->buf));\\r\\nOPENSSL_assert(ctx->buf_len >= ctx->buf_off);\\r\\nret += n;\\r\\n}\\r\\ninl -= n;\\r\\nin += n;\\r\\nctx->buf_off = 0;\\r\\nn = ctx->buf_len;\\r\\nwhile (n > 0) {\\r\\ni = BIO_write(b->next_bio, &(ctx->buf[ctx->buf_off]), n);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nreturn ((ret == 0) ? i : ret);\\r\\n}\\r\\nOPENSSL_assert(i <= n);\\r\\nn -= i;\\r\\nctx->buf_off += i;\\r\\nOPENSSL_assert(ctx->buf_off <= (int)sizeof(ctx->buf));\\r\\nOPENSSL_assert(ctx->buf_len >= ctx->buf_off);\\r\\n}\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long b64_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO_B64_CTX *ctx;\\r\\nlong ret = 1;\\r\\nint i;\\r\\nctx = (BIO_B64_CTX *)b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->cont = 1;\\r\\nctx->start = 1;\\r\\nctx->encode = B64_NONE;\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret = 1;\\r\\nelse\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nOPENSSL_assert(ctx->buf_len >= ctx->buf_off);\\r\\nret = ctx->buf_len - ctx->buf_off;\\r\\nif ((ret == 0) && (ctx->encode != B64_NONE)\\r\\n&& (ctx->base64.num != 0))\\r\\nret = 1;\\r\\nelse if (ret <= 0)\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nOPENSSL_assert(ctx->buf_len >= ctx->buf_off);\\r\\nret = ctx->buf_len - ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nagain:\\r\\nwhile (ctx->buf_len != ctx->buf_off) {\\r\\ni = b64_write(b, NULL, 0);\\r\\nif (i < 0)\\r\\nreturn i;\\r\\n}\\r\\nif (BIO_get_flags(b) & BIO_FLAGS_BASE64_NO_NL) {\\r\\nif (ctx->tmp_len != 0) {\\r\\nctx->buf_len = EVP_EncodeBlock((unsigned char *)ctx->buf,\\r\\n(unsigned char *)ctx->tmp,\\r\\nctx->tmp_len);\\r\\nctx->buf_off = 0;\\r\\nctx->tmp_len = 0;\\r\\ngoto again;\\r\\n}\\r\\n} else if (ctx->encode != B64_NONE && ctx->base64.num != 0) {\\r\\nctx->buf_off = 0;\\r\\nEVP_EncodeFinal(&(ctx->base64),\\r\\n(unsigned char *)ctx->buf, &(ctx->buf_len));\\r\\ngoto again;\\r\\n}\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nbreak;\\r\\ncase BIO_CTRL_INFO:\\r\\ncase BIO_CTRL_GET:\\r\\ncase BIO_CTRL_SET:\\r\\ndefault:\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long b64_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret = 1;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\nret = BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int b64_puts(BIO *b, const char *str)\\r\\n{\\r\\nreturn b64_write(b, str, strlen(str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_check_c", "target": 0, "func": "int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBIGNUM *order;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nEC_POINT *point = NULL;\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL) {\\r\\nECerr(EC_F_EC_GROUP_CHECK, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nif ((order = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!EC_GROUP_check_discriminant(group, ctx)) {\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_DISCRIMINANT_IS_ZERO);\\r\\ngoto err;\\r\\n}\\r\\nif (group->generator == NULL) {\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_UNDEFINED_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_is_on_curve(group, group->generator, ctx)) {\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_POINT_IS_NOT_ON_CURVE);\\r\\ngoto err;\\r\\n}\\r\\nif ((point = EC_POINT_new(group)) == NULL)\\r\\ngoto err;\\r\\nif (!EC_GROUP_get_order(group, order, ctx))\\r\\ngoto err;\\r\\nif (BN_is_zero(order)) {\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_UNDEFINED_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_mul(group, point, order, NULL, NULL, ctx))\\r\\ngoto err;\\r\\nif (!EC_POINT_is_at_infinity(group, point)) {\\r\\nECerr(EC_F_EC_GROUP_CHECK, EC_R_INVALID_GROUP_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (point)\\r\\nEC_POINT_free(point);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_init_c", "target": 0, "func": "PKCS12 *PKCS12_init(int mode)\\r\\n{\\r\\nPKCS12 *pkcs12;\\r\\nif (!(pkcs12 = PKCS12_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nASN1_INTEGER_set(pkcs12->version, 3);\\r\\npkcs12->authsafes->type = OBJ_nid2obj(mode);\\r\\nswitch (mode) {\\r\\ncase NID_pkcs7_data:\\r\\nif (!(pkcs12->authsafes->d.data = M_ASN1_OCTET_STRING_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS12err(PKCS12_F_PKCS12_INIT, PKCS12_R_UNSUPPORTED_PKCS12_MODE);\\r\\ngoto err;\\r\\n}\\r\\nreturn pkcs12;\\r\\nerr:\\r\\nif (pkcs12 != NULL)\\r\\nPKCS12_free(pkcs12);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_idea_c", "target": 0, "func": "static int idea_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nBLOCK_CIPHER_ecb_loop()\\r\\nidea_ecb_encrypt(in + i, out + i, ctx->cipher_data);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int idea_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nif (!enc) {\\r\\nif (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_OFB_MODE)\\r\\nenc = 1;\\r\\nelse if (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CFB_MODE)\\r\\nenc = 1;\\r\\n}\\r\\nif (enc)\\r\\nidea_set_encrypt_key(key, ctx->cipher_data);\\r\\nelse {\\r\\nIDEA_KEY_SCHEDULE tmp;\\r\\nidea_set_encrypt_key(key, &tmp);\\r\\nidea_set_decrypt_key(&tmp, ctx->cipher_data);\\r\\nOPENSSL_cleanse((unsigned char *)&tmp, sizeof(IDEA_KEY_SCHEDULE));\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc5_enc_c", "target": 0, "func": "void RC5_32_cbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC5_32_KEY *ks, unsigned char *iv,\\r\\nint encrypt)\\r\\n{\\r\\nregister unsigned long tin0, tin1;\\r\\nregister unsigned long tout0, tout1, xor0, xor1;\\r\\nregister long l = length;\\r\\nunsigned long tin[2];\\r\\nif (encrypt) {\\r\\nc2l(iv, tout0);\\r\\nc2l(iv, tout1);\\r\\niv -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nc2l(in, tin0);\\r\\nc2l(in, tin1);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nRC5_32_encrypt(tin, ks);\\r\\ntout0 = tin[0];\\r\\nl2c(tout0, out);\\r\\ntout1 = tin[1];\\r\\nl2c(tout1, out);\\r\\n}\\r\\nif (l != -8) {\\r\\nc2ln(in, tin0, tin1, l + 8);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nRC5_32_encrypt(tin, ks);\\r\\ntout0 = tin[0];\\r\\nl2c(tout0, out);\\r\\ntout1 = tin[1];\\r\\nl2c(tout1, out);\\r\\n}\\r\\nl2c(tout0, iv);\\r\\nl2c(tout1, iv);\\r\\n} else {\\r\\nc2l(iv, xor0);\\r\\nc2l(iv, xor1);\\r\\niv -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nc2l(in, tin0);\\r\\ntin[0] = tin0;\\r\\nc2l(in, tin1);\\r\\ntin[1] = tin1;\\r\\nRC5_32_decrypt(tin, ks);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2c(tout0, out);\\r\\nl2c(tout1, out);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nif (l != -8) {\\r\\nc2l(in, tin0);\\r\\ntin[0] = tin0;\\r\\nc2l(in, tin1);\\r\\ntin[1] = tin1;\\r\\nRC5_32_decrypt(tin, ks);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2cn(tout0, tout1, out, l + 8);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nl2c(xor0, iv);\\r\\nl2c(xor1, iv);\\r\\n}\\r\\ntin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;\\r\\ntin[0] = tin[1] = 0;\\r\\n}\\r\\nvoid RC5_32_encrypt(unsigned long *d, RC5_32_KEY *key)\\r\\n{\\r\\nRC5_32_INT a, b, *s;\\r\\ns = key->data;\\r\\na = d[0] + s[0];\\r\\nb = d[1] + s[1];\\r\\nE_RC5_32(a, b, s, 2);\\r\\nE_RC5_32(a, b, s, 4);\\r\\nE_RC5_32(a, b, s, 6);\\r\\nE_RC5_32(a, b, s, 8);\\r\\nE_RC5_32(a, b, s, 10);\\r\\nE_RC5_32(a, b, s, 12);\\r\\nE_RC5_32(a, b, s, 14);\\r\\nE_RC5_32(a, b, s, 16);\\r\\nif (key->rounds == 12) {\\r\\nE_RC5_32(a, b, s, 18);\\r\\nE_RC5_32(a, b, s, 20);\\r\\nE_RC5_32(a, b, s, 22);\\r\\nE_RC5_32(a, b, s, 24);\\r\\n} else if (key->rounds == 16) {\\r\\nE_RC5_32(a, b, s, 18);\\r\\nE_RC5_32(a, b, s, 20);\\r\\nE_RC5_32(a, b, s, 22);\\r\\nE_RC5_32(a, b, s, 24);\\r\\nE_RC5_32(a, b, s, 26);\\r\\nE_RC5_32(a, b, s, 28);\\r\\nE_RC5_32(a, b, s, 30);\\r\\nE_RC5_32(a, b, s, 32);\\r\\n}\\r\\nd[0] = a;\\r\\nd[1] = b;\\r\\n}\\r\\nvoid RC5_32_decrypt(unsigned long *d, RC5_32_KEY *key)\\r\\n{\\r\\nRC5_32_INT a, b, *s;\\r\\ns = key->data;\\r\\na = d[0];\\r\\nb = d[1];\\r\\nif (key->rounds == 16) {\\r\\nD_RC5_32(a, b, s, 32);\\r\\nD_RC5_32(a, b, s, 30);\\r\\nD_RC5_32(a, b, s, 28);\\r\\nD_RC5_32(a, b, s, 26);\\r\\nD_RC5_32(a, b, s, 24);\\r\\nD_RC5_32(a, b, s, 22);\\r\\nD_RC5_32(a, b, s, 20);\\r\\nD_RC5_32(a, b, s, 18);\\r\\n} else if (key->rounds == 12) {\\r\\nD_RC5_32(a, b, s, 24);\\r\\nD_RC5_32(a, b, s, 22);\\r\\nD_RC5_32(a, b, s, 20);\\r\\nD_RC5_32(a, b, s, 18);\\r\\n}\\r\\nD_RC5_32(a, b, s, 16);\\r\\nD_RC5_32(a, b, s, 14);\\r\\nD_RC5_32(a, b, s, 12);\\r\\nD_RC5_32(a, b, s, 10);\\r\\nD_RC5_32(a, b, s, 8);\\r\\nD_RC5_32(a, b, s, 6);\\r\\nD_RC5_32(a, b, s, 4);\\r\\nD_RC5_32(a, b, s, 2);\\r\\nd[0] = a - s[0];\\r\\nd[1] = b - s[1];\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_fat_c", "target": 0, "func": "int ENGINE_set_default(ENGINE *e, unsigned int flags)\\r\\n{\\r\\nif ((flags & ENGINE_METHOD_CIPHERS) && !ENGINE_set_default_ciphers(e))\\r\\nreturn 0;\\r\\nif ((flags & ENGINE_METHOD_DIGESTS) && !ENGINE_set_default_digests(e))\\r\\nreturn 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif ((flags & ENGINE_METHOD_RSA) && !ENGINE_set_default_RSA(e))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nif ((flags & ENGINE_METHOD_DSA) && !ENGINE_set_default_DSA(e))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif ((flags & ENGINE_METHOD_DH) && !ENGINE_set_default_DH(e))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif ((flags & ENGINE_METHOD_ECDH) && !ENGINE_set_default_ECDH(e))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nif ((flags & ENGINE_METHOD_ECDSA) && !ENGINE_set_default_ECDSA(e))\\r\\nreturn 0;\\r\\n#endif\\r\\nif ((flags & ENGINE_METHOD_RAND) && !ENGINE_set_default_RAND(e))\\r\\nreturn 0;\\r\\nif ((flags & ENGINE_METHOD_PKEY_METHS)\\r\\n&& !ENGINE_set_default_pkey_meths(e))\\r\\nreturn 0;\\r\\nif ((flags & ENGINE_METHOD_PKEY_ASN1_METHS)\\r\\n&& !ENGINE_set_default_pkey_asn1_meths(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_def_cb(const char *alg, int len, void *arg)\\r\\n{\\r\\nunsigned int *pflags = arg;\\r\\nif (!strncmp(alg, \"ALL\", len))\\r\\n*pflags |= ENGINE_METHOD_ALL;\\r\\nelse if (!strncmp(alg, \"RSA\", len))\\r\\n*pflags |= ENGINE_METHOD_RSA;\\r\\nelse if (!strncmp(alg, \"DSA\", len))\\r\\n*pflags |= ENGINE_METHOD_DSA;\\r\\nelse if (!strncmp(alg, \"ECDH\", len))\\r\\n*pflags |= ENGINE_METHOD_ECDH;\\r\\nelse if (!strncmp(alg, \"ECDSA\", len))\\r\\n*pflags |= ENGINE_METHOD_ECDSA;\\r\\nelse if (!strncmp(alg, \"DH\", len))\\r\\n*pflags |= ENGINE_METHOD_DH;\\r\\nelse if (!strncmp(alg, \"RAND\", len))\\r\\n*pflags |= ENGINE_METHOD_RAND;\\r\\nelse if (!strncmp(alg, \"CIPHERS\", len))\\r\\n*pflags |= ENGINE_METHOD_CIPHERS;\\r\\nelse if (!strncmp(alg, \"DIGESTS\", len))\\r\\n*pflags |= ENGINE_METHOD_DIGESTS;\\r\\nelse if (!strncmp(alg, \"PKEY\", len))\\r\\n*pflags |= ENGINE_METHOD_PKEY_METHS | ENGINE_METHOD_PKEY_ASN1_METHS;\\r\\nelse if (!strncmp(alg, \"PKEY_CRYPTO\", len))\\r\\n*pflags |= ENGINE_METHOD_PKEY_METHS;\\r\\nelse if (!strncmp(alg, \"PKEY_ASN1\", len))\\r\\n*pflags |= ENGINE_METHOD_PKEY_ASN1_METHS;\\r\\nelse\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_set_default_string(ENGINE *e, const char *def_list)\\r\\n{\\r\\nunsigned int flags = 0;\\r\\nif (!CONF_parse_list(def_list, ',', 1, int_def_cb, &flags)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_SET_DEFAULT_STRING,\\r\\nENGINE_R_INVALID_STRING);\\r\\nERR_add_error_data(2, \"str=\", def_list);\\r\\nreturn 0;\\r\\n}\\r\\nreturn ENGINE_set_default(e, flags);\\r\\n}\\r\\nint ENGINE_register_complete(ENGINE *e)\\r\\n{\\r\\nENGINE_register_ciphers(e);\\r\\nENGINE_register_digests(e);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nENGINE_register_RSA(e);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\nENGINE_register_DSA(e);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nENGINE_register_DH(e);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nENGINE_register_ECDH(e);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\nENGINE_register_ECDSA(e);\\r\\n#endif\\r\\nENGINE_register_RAND(e);\\r\\nENGINE_register_pkey_meths(e);\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_register_all_complete(void)\\r\\n{\\r\\nENGINE *e;\\r\\nfor (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))\\r\\nif (!(e->flags & ENGINE_FLAGS_NO_REGISTER_ALL))\\r\\nENGINE_register_complete(e);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_evp_pbe_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nint i, nid_md, nid_cipher;\\r\\nEVP_PBE_CTL *tpbe, *tpbe2;\\r\\nfor (i = 0; i < sizeof(builtin_pbe) / sizeof(EVP_PBE_CTL); i++) {\\r\\ntpbe = builtin_pbe + i;\\r\\nfprintf(stderr, \"%d %d %s \", tpbe->pbe_type, tpbe->pbe_nid,\\r\\nOBJ_nid2sn(tpbe->pbe_nid));\\r\\nif (EVP_PBE_find(tpbe->pbe_type, tpbe->pbe_nid,\\r\\n&nid_cipher, &nid_md, 0))\\r\\nfprintf(stderr, \"Found %s %s\\n\",\\r\\nOBJ_nid2sn(nid_cipher), OBJ_nid2sn(nid_md));\\r\\nelse\\r\\nfprintf(stderr, \"Find ERROR!!\\n\");\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\\r\\nASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)\\r\\n{\\r\\nconst EVP_CIPHER *cipher;\\r\\nconst EVP_MD *md;\\r\\nint cipher_nid, md_nid;\\r\\nEVP_PBE_KEYGEN *keygen;\\r\\nif (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj),\\r\\n&cipher_nid, &md_nid, &keygen)) {\\r\\nchar obj_tmp[80];\\r\\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM);\\r\\nif (!pbe_obj)\\r\\nBUF_strlcpy(obj_tmp, \"NULL\", sizeof obj_tmp);\\r\\nelse\\r\\ni2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj);\\r\\nERR_add_error_data(2, \"TYPE=\", obj_tmp);\\r\\nreturn 0;\\r\\n}\\r\\nif (!pass)\\r\\npasslen = 0;\\r\\nelse if (passlen == -1)\\r\\npasslen = strlen(pass);\\r\\nif (cipher_nid == -1)\\r\\ncipher = NULL;\\r\\nelse {\\r\\ncipher = EVP_get_cipherbynid(cipher_nid);\\r\\nif (!cipher) {\\r\\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (md_nid == -1)\\r\\nmd = NULL;\\r\\nelse {\\r\\nmd = EVP_get_digestbynid(md_nid);\\r\\nif (!md) {\\r\\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (!keygen(ctx, pass, passlen, param, cipher, md, en_de)) {\\r\\nEVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_KEYGEN_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pbe2_cmp(const EVP_PBE_CTL *pbe1, const EVP_PBE_CTL *pbe2)\\r\\n{\\r\\nint ret = pbe1->pbe_type - pbe2->pbe_type;\\r\\nif (ret)\\r\\nreturn ret;\\r\\nelse\\r\\nreturn pbe1->pbe_nid - pbe2->pbe_nid;\\r\\n}\\r\\nstatic int pbe_cmp(const EVP_PBE_CTL *const *a, const EVP_PBE_CTL *const *b)\\r\\n{\\r\\nint ret = (*a)->pbe_type - (*b)->pbe_type;\\r\\nif (ret)\\r\\nreturn ret;\\r\\nelse\\r\\nreturn (*a)->pbe_nid - (*b)->pbe_nid;\\r\\n}\\r\\nint EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid,\\r\\nint md_nid, EVP_PBE_KEYGEN *keygen)\\r\\n{\\r\\nEVP_PBE_CTL *pbe_tmp;\\r\\nif (!pbe_algs)\\r\\npbe_algs = sk_EVP_PBE_CTL_new(pbe_cmp);\\r\\nif (!(pbe_tmp = (EVP_PBE_CTL *)OPENSSL_malloc(sizeof(EVP_PBE_CTL)))) {\\r\\nEVPerr(EVP_F_EVP_PBE_ALG_ADD_TYPE, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\npbe_tmp->pbe_type = pbe_type;\\r\\npbe_tmp->pbe_nid = pbe_nid;\\r\\npbe_tmp->cipher_nid = cipher_nid;\\r\\npbe_tmp->md_nid = md_nid;\\r\\npbe_tmp->keygen = keygen;\\r\\nsk_EVP_PBE_CTL_push(pbe_algs, pbe_tmp);\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,\\r\\nEVP_PBE_KEYGEN *keygen)\\r\\n{\\r\\nint cipher_nid, md_nid;\\r\\nif (cipher)\\r\\ncipher_nid = EVP_CIPHER_nid(cipher);\\r\\nelse\\r\\ncipher_nid = -1;\\r\\nif (md)\\r\\nmd_nid = EVP_MD_type(md);\\r\\nelse\\r\\nmd_nid = -1;\\r\\nreturn EVP_PBE_alg_add_type(EVP_PBE_TYPE_OUTER, nid,\\r\\ncipher_nid, md_nid, keygen);\\r\\n}\\r\\nint EVP_PBE_find(int type, int pbe_nid,\\r\\nint *pcnid, int *pmnid, EVP_PBE_KEYGEN **pkeygen)\\r\\n{\\r\\nEVP_PBE_CTL *pbetmp = NULL, pbelu;\\r\\nint i;\\r\\nif (pbe_nid == NID_undef)\\r\\nreturn 0;\\r\\npbelu.pbe_type = type;\\r\\npbelu.pbe_nid = pbe_nid;\\r\\nif (pbe_algs) {\\r\\ni = sk_EVP_PBE_CTL_find(pbe_algs, &pbelu);\\r\\nif (i != -1)\\r\\npbetmp = sk_EVP_PBE_CTL_value(pbe_algs, i);\\r\\n}\\r\\nif (pbetmp == NULL) {\\r\\npbetmp = OBJ_bsearch_pbe2(&pbelu, builtin_pbe,\\r\\nsizeof(builtin_pbe) / sizeof(EVP_PBE_CTL));\\r\\n}\\r\\nif (pbetmp == NULL)\\r\\nreturn 0;\\r\\nif (pcnid)\\r\\n*pcnid = pbetmp->cipher_nid;\\r\\nif (pmnid)\\r\\n*pmnid = pbetmp->md_nid;\\r\\nif (pkeygen)\\r\\n*pkeygen = pbetmp->keygen;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void free_evp_pbe_ctl(EVP_PBE_CTL *pbe)\\r\\n{\\r\\nOPENSSL_freeFunc(pbe);\\r\\n}\\r\\nvoid EVP_PBE_cleanup(void)\\r\\n{\\r\\nsk_EVP_PBE_CTL_pop_free(pbe_algs, free_evp_pbe_ctl);\\r\\npbe_algs = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_aes_cbc_hmac_sha256_c", "target": 0, "func": "static int aesni_cbc_hmac_sha256_init_key(EVP_CIPHER_CTX *ctx,\\r\\nconst unsigned char *inkey,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_AES_HMAC_SHA256 *key = data(ctx);\\r\\nint ret;\\r\\nif (enc)\\r\\nmemset(&key->ks, 0, sizeof(key->ks.rd_key)),\\r\\nret = aesni_set_encrypt_key(inkey, ctx->key_len * 8, &key->ks);\\r\\nelse\\r\\nret = aesni_set_decrypt_key(inkey, ctx->key_len * 8, &key->ks);\\r\\nSHA256_Init(&key->head);\\r\\nkey->tail = key->head;\\r\\nkey->md = key->head;\\r\\nkey->payload_length = NO_PAYLOAD_LENGTH;\\r\\nreturn ret < 0 ? 0 : 1;\\r\\n}\\r\\nstatic void sha256_update(SHA256_CTX *c, const void *data, size_t len)\\r\\n{\\r\\nconst unsigned char *ptr = data;\\r\\nsize_t res;\\r\\nif ((res = c->num)) {\\r\\nres = SHA256_CBLOCK - res;\\r\\nif (len < res)\\r\\nres = len;\\r\\nSHA256_Update(c, ptr, res);\\r\\nptr += res;\\r\\nlen -= res;\\r\\n}\\r\\nres = len % SHA256_CBLOCK;\\r\\nlen -= res;\\r\\nif (len) {\\r\\nsha256_block_data_order(c, ptr, len / SHA256_CBLOCK);\\r\\nptr += len;\\r\\nc->Nh += len >> 29;\\r\\nc->Nl += len <<= 3;\\r\\nif (c->Nl < (unsigned int)len)\\r\\nc->Nh++;\\r\\n}\\r\\nif (res)\\r\\nSHA256_Update(c, ptr, res);\\r\\n}\\r\\nstatic size_t tls1_1_multi_block_encrypt(EVP_AES_HMAC_SHA256 *key,\\r\\nunsigned char *out,\\r\\nconst unsigned char *inp,\\r\\nsize_t inp_len, int n4x)\\r\\n{\\r\\nHASH_DESC hash_d[8], edges[8];\\r\\nCIPH_DESC ciph_d[8];\\r\\nunsigned char storage[sizeof(SHA256_MB_CTX) + 32];\\r\\nunion {\\r\\nu64 q[16];\\r\\nu32 d[32];\\r\\nu8 c[128];\\r\\n} blocks[8];\\r\\nSHA256_MB_CTX *ctx;\\r\\nunsigned int frag, last, packlen, i, x4 = 4 * n4x, minblocks, processed =\\r\\n0;\\r\\nsize_t ret = 0;\\r\\nu8 *IVs;\\r\\n# if defined(BSWAP8)\\r\\nu64 seqnum;\\r\\n# endif\\r\\nif (RAND_bytes((IVs = blocks[0].c), 16 * x4) <= 0)\\r\\nreturn 0;\\r\\nctx = (SHA256_MB_CTX *) (storage + 32 - ((size_t)storage % 32));\\r\\nfrag = (unsigned int)inp_len >> (1 + n4x);\\r\\nlast = (unsigned int)inp_len + frag - (frag << (1 + n4x));\\r\\nif (last > frag && ((last + 13 + 9) % 64) < (x4 - 1)) {\\r\\nfrag++;\\r\\nlast -= x4 - 1;\\r\\n}\\r\\npacklen = 5 + 16 + ((frag + 32 + 16) & -16);\\r\\nhash_d[0].ptr = inp;\\r\\nciph_d[0].inp = inp;\\r\\nciph_d[0].out = out + 5 + 16;\\r\\nmemcpy(ciph_d[0].out - 16, IVs, 16);\\r\\nmemcpy(ciph_d[0].iv, IVs, 16);\\r\\nIVs += 16;\\r\\nfor (i = 1; i < x4; i++) {\\r\\nciph_d[i].inp = hash_d[i].ptr = hash_d[i - 1].ptr + frag;\\r\\nciph_d[i].out = ciph_d[i - 1].out + packlen;\\r\\nmemcpy(ciph_d[i].out - 16, IVs, 16);\\r\\nmemcpy(ciph_d[i].iv, IVs, 16);\\r\\nIVs += 16;\\r\\n}\\r\\n# if defined(BSWAP8)\\r\\nmemcpy(blocks[0].c, key->md.data, 8);\\r\\nseqnum = BSWAP8(blocks[0].q[0]);\\r\\n# endif\\r\\nfor (i = 0; i < x4; i++) {\\r\\nunsigned int len = (i == (x4 - 1) ? last : frag);\\r\\n# if !defined(BSWAP8)\\r\\nunsigned int carry, j;\\r\\n# endif\\r\\nctx->A[i] = key->md.h[0];\\r\\nctx->B[i] = key->md.h[1];\\r\\nctx->C[i] = key->md.h[2];\\r\\nctx->D[i] = key->md.h[3];\\r\\nctx->E[i] = key->md.h[4];\\r\\nctx->F[i] = key->md.h[5];\\r\\nctx->G[i] = key->md.h[6];\\r\\nctx->H[i] = key->md.h[7];\\r\\n# if defined(BSWAP8)\\r\\nblocks[i].q[0] = BSWAP8(seqnum + i);\\r\\n# else\\r\\nfor (carry = i, j = 8; j--;) {\\r\\nblocks[i].c[j] = ((u8 *)key->md.data)[j] + carry;\\r\\ncarry = (blocks[i].c[j] - carry) >> (sizeof(carry) * 8 - 1);\\r\\n}\\r\\n# endif\\r\\nblocks[i].c[8] = ((u8 *)key->md.data)[8];\\r\\nblocks[i].c[9] = ((u8 *)key->md.data)[9];\\r\\nblocks[i].c[10] = ((u8 *)key->md.data)[10];\\r\\nblocks[i].c[11] = (u8)(len >> 8);\\r\\nblocks[i].c[12] = (u8)(len);\\r\\nmemcpy(blocks[i].c + 13, hash_d[i].ptr, 64 - 13);\\r\\nhash_d[i].ptr += 64 - 13;\\r\\nhash_d[i].blocks = (len - (64 - 13)) / 64;\\r\\nedges[i].ptr = blocks[i].c;\\r\\nedges[i].blocks = 1;\\r\\n}\\r\\nsha256_multi_block(ctx, edges, n4x);\\r\\n# define MAXCHUNKSIZE 2048\\r\\n# if MAXCHUNKSIZE%64\\r\\n# error \"MAXCHUNKSIZE is not divisible by 64\"\\r\\n# elif MAXCHUNKSIZE\\r\\nminblocks = ((frag <= last ? frag : last) - (64 - 13)) / 64;\\r\\nif (minblocks > MAXCHUNKSIZE / 64) {\\r\\nfor (i = 0; i < x4; i++) {\\r\\nedges[i].ptr = hash_d[i].ptr;\\r\\nedges[i].blocks = MAXCHUNKSIZE / 64;\\r\\nciph_d[i].blocks = MAXCHUNKSIZE / 16;\\r\\n}\\r\\ndo {\\r\\nsha256_multi_block(ctx, edges, n4x);\\r\\naesni_multi_cbc_encrypt(ciph_d, &key->ks, n4x);\\r\\nfor (i = 0; i < x4; i++) {\\r\\nedges[i].ptr = hash_d[i].ptr += MAXCHUNKSIZE;\\r\\nhash_d[i].blocks -= MAXCHUNKSIZE / 64;\\r\\nedges[i].blocks = MAXCHUNKSIZE / 64;\\r\\nciph_d[i].inp += MAXCHUNKSIZE;\\r\\nciph_d[i].out += MAXCHUNKSIZE;\\r\\nciph_d[i].blocks = MAXCHUNKSIZE / 16;\\r\\nmemcpy(ciph_d[i].iv, ciph_d[i].out - 16, 16);\\r\\n}\\r\\nprocessed += MAXCHUNKSIZE;\\r\\nminblocks -= MAXCHUNKSIZE / 64;\\r\\n} while (minblocks > MAXCHUNKSIZE / 64);\\r\\n}\\r\\n# endif\\r\\n# undef MAXCHUNKSIZE\\r\\nsha256_multi_block(ctx, hash_d, n4x);\\r\\nmemset(blocks, 0, sizeof(blocks));\\r\\nfor (i = 0; i < x4; i++) {\\r\\nunsigned int len = (i == (x4 - 1) ? last : frag),\\r\\noff = hash_d[i].blocks * 64;\\r\\nconst unsigned char *ptr = hash_d[i].ptr + off;\\r\\noff = (len - processed) - (64 - 13) - off;\\r\\nmemcpy(blocks[i].c, ptr, off);\\r\\nblocks[i].c[off] = 0x80;\\r\\nlen += 64 + 13;\\r\\nlen *= 8;\\r\\nif (off < (64 - 8)) {\\r\\n# ifdef BSWAP4\\r\\nblocks[i].d[15] = BSWAP4(len);\\r\\n# else\\r\\nPUTU32(blocks[i].c + 60, len);\\r\\n# endif\\r\\nedges[i].blocks = 1;\\r\\n} else {\\r\\n# ifdef BSWAP4\\r\\nblocks[i].d[31] = BSWAP4(len);\\r\\n# else\\r\\nPUTU32(blocks[i].c + 124, len);\\r\\n# endif\\r\\nedges[i].blocks = 2;\\r\\n}\\r\\nedges[i].ptr = blocks[i].c;\\r\\n}\\r\\nsha256_multi_block(ctx, edges, n4x);\\r\\nmemset(blocks, 0, sizeof(blocks));\\r\\nfor (i = 0; i < x4; i++) {\\r\\n# ifdef BSWAP4\\r\\nblocks[i].d[0] = BSWAP4(ctx->A[i]);\\r\\nctx->A[i] = key->tail.h[0];\\r\\nblocks[i].d[1] = BSWAP4(ctx->B[i]);\\r\\nctx->B[i] = key->tail.h[1];\\r\\nblocks[i].d[2] = BSWAP4(ctx->C[i]);\\r\\nctx->C[i] = key->tail.h[2];\\r\\nblocks[i].d[3] = BSWAP4(ctx->D[i]);\\r\\nctx->D[i] = key->tail.h[3];\\r\\nblocks[i].d[4] = BSWAP4(ctx->E[i]);\\r\\nctx->E[i] = key->tail.h[4];\\r\\nblocks[i].d[5] = BSWAP4(ctx->F[i]);\\r\\nctx->F[i] = key->tail.h[5];\\r\\nblocks[i].d[6] = BSWAP4(ctx->G[i]);\\r\\nctx->G[i] = key->tail.h[6];\\r\\nblocks[i].d[7] = BSWAP4(ctx->H[i]);\\r\\nctx->H[i] = key->tail.h[7];\\r\\nblocks[i].c[32] = 0x80;\\r\\nblocks[i].d[15] = BSWAP4((64 + 32) * 8);\\r\\n# else\\r\\nPUTU32(blocks[i].c + 0, ctx->A[i]);\\r\\nctx->A[i] = key->tail.h[0];\\r\\nPUTU32(blocks[i].c + 4, ctx->B[i]);\\r\\nctx->B[i] = key->tail.h[1];\\r\\nPUTU32(blocks[i].c + 8, ctx->C[i]);\\r\\nctx->C[i] = key->tail.h[2];\\r\\nPUTU32(blocks[i].c + 12, ctx->D[i]);\\r\\nctx->D[i] = key->tail.h[3];\\r\\nPUTU32(blocks[i].c + 16, ctx->E[i]);\\r\\nctx->E[i] = key->tail.h[4];\\r\\nPUTU32(blocks[i].c + 20, ctx->F[i]);\\r\\nctx->F[i] = key->tail.h[5];\\r\\nPUTU32(blocks[i].c + 24, ctx->G[i]);\\r\\nctx->G[i] = key->tail.h[6];\\r\\nPUTU32(blocks[i].c + 28, ctx->H[i]);\\r\\nctx->H[i] = key->tail.h[7];\\r\\nblocks[i].c[32] = 0x80;\\r\\nPUTU32(blocks[i].c + 60, (64 + 32) * 8);\\r\\n# endif\\r\\nedges[i].ptr = blocks[i].c;\\r\\nedges[i].blocks = 1;\\r\\n}\\r\\nsha256_multi_block(ctx, edges, n4x);\\r\\nfor (i = 0; i < x4; i++) {\\r\\nunsigned int len = (i == (x4 - 1) ? last : frag), pad, j;\\r\\nunsigned char *out0 = out;\\r\\nmemcpy(ciph_d[i].out, ciph_d[i].inp, len - processed);\\r\\nciph_d[i].inp = ciph_d[i].out;\\r\\nout += 5 + 16 + len;\\r\\nPUTU32(out + 0, ctx->A[i]);\\r\\nPUTU32(out + 4, ctx->B[i]);\\r\\nPUTU32(out + 8, ctx->C[i]);\\r\\nPUTU32(out + 12, ctx->D[i]);\\r\\nPUTU32(out + 16, ctx->E[i]);\\r\\nPUTU32(out + 20, ctx->F[i]);\\r\\nPUTU32(out + 24, ctx->G[i]);\\r\\nPUTU32(out + 28, ctx->H[i]);\\r\\nout += 32;\\r\\nlen += 32;\\r\\npad = 15 - len % 16;\\r\\nfor (j = 0; j <= pad; j++)\\r\\n*(out++) = pad;\\r\\nlen += pad + 1;\\r\\nciph_d[i].blocks = (len - processed) / 16;\\r\\nlen += 16;\\r\\nout0[0] = ((u8 *)key->md.data)[8];\\r\\nout0[1] = ((u8 *)key->md.data)[9];\\r\\nout0[2] = ((u8 *)key->md.data)[10];\\r\\nout0[3] = (u8)(len >> 8);\\r\\nout0[4] = (u8)(len);\\r\\nret += len + 5;\\r\\ninp += frag;\\r\\n}\\r\\naesni_multi_cbc_encrypt(ciph_d, &key->ks, n4x);\\r\\nOPENSSL_cleanse(blocks, sizeof(blocks));\\r\\nOPENSSL_cleanse(ctx, sizeof(*ctx));\\r\\nreturn ret;\\r\\n}\\r\\nstatic int aesni_cbc_hmac_sha256_cipher(EVP_CIPHER_CTX *ctx,\\r\\nunsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_AES_HMAC_SHA256 *key = data(ctx);\\r\\nunsigned int l;\\r\\nsize_t plen = key->payload_length, iv = 0,\\r\\nsha_off = 0;\\r\\n# if defined(STITCHED_CALL)\\r\\nsize_t aes_off = 0, blocks;\\r\\nsha_off = SHA256_CBLOCK - key->md.num;\\r\\n# endif\\r\\nkey->payload_length = NO_PAYLOAD_LENGTH;\\r\\nif (len % AES_BLOCK_SIZE)\\r\\nreturn 0;\\r\\nif (ctx->encrypt) {\\r\\nif (plen == NO_PAYLOAD_LENGTH)\\r\\nplen = len;\\r\\nelse if (len !=\\r\\n((plen + SHA256_DIGEST_LENGTH +\\r\\nAES_BLOCK_SIZE) & -AES_BLOCK_SIZE))\\r\\nreturn 0;\\r\\nelse if (key->aux.tls_ver >= TLS1_1_VERSION)\\r\\niv = AES_BLOCK_SIZE;\\r\\n# if defined(STITCHED_CALL)\\r\\nif (OPENSSL_ia32cap_P[1] & (1 << (60 - 32)) &&\\r\\nplen > (sha_off + iv) &&\\r\\n(blocks = (plen - (sha_off + iv)) / SHA256_CBLOCK)) {\\r\\nSHA256_Update(&key->md, in + iv, sha_off);\\r\\n(void)aesni_cbc_sha256_enc(in, out, blocks, &key->ks,\\r\\nctx->iv, &key->md, in + iv + sha_off);\\r\\nblocks *= SHA256_CBLOCK;\\r\\naes_off += blocks;\\r\\nsha_off += blocks;\\r\\nkey->md.Nh += blocks >> 29;\\r\\nkey->md.Nl += blocks <<= 3;\\r\\nif (key->md.Nl < (unsigned int)blocks)\\r\\nkey->md.Nh++;\\r\\n} else {\\r\\nsha_off = 0;\\r\\n}\\r\\n# endif\\r\\nsha_off += iv;\\r\\nSHA256_Update(&key->md, in + sha_off, plen - sha_off);\\r\\nif (plen != len) {\\r\\nif (in != out)\\r\\nmemcpy(out + aes_off, in + aes_off, plen - aes_off);\\r\\nSHA256_Final(out + plen, &key->md);\\r\\nkey->md = key->tail;\\r\\nSHA256_Update(&key->md, out + plen, SHA256_DIGEST_LENGTH);\\r\\nSHA256_Final(out + plen, &key->md);\\r\\nplen += SHA256_DIGEST_LENGTH;\\r\\nfor (l = len - plen - 1; plen < len; plen++)\\r\\nout[plen] = l;\\r\\naesni_cbc_encrypt(out + aes_off, out + aes_off, len - aes_off,\\r\\n&key->ks, ctx->iv, 1);\\r\\n} else {\\r\\naesni_cbc_encrypt(in + aes_off, out + aes_off, len - aes_off,\\r\\n&key->ks, ctx->iv, 1);\\r\\n}\\r\\n} else {\\r\\nunion {\\r\\nunsigned int u[SHA256_DIGEST_LENGTH / sizeof(unsigned int)];\\r\\nunsigned char c[64 + SHA256_DIGEST_LENGTH];\\r\\n} mac, *pmac;\\r\\npmac = (void *)(((size_t)mac.c + 63) & ((size_t)0 - 64));\\r\\naesni_cbc_encrypt(in, out, len, &key->ks, ctx->iv, 0);\\r\\nif (plen != NO_PAYLOAD_LENGTH) {\\r\\nsize_t inp_len, mask, j, i;\\r\\nunsigned int res, maxpad, pad, bitlen;\\r\\nint ret = 1;\\r\\nunion {\\r\\nunsigned int u[SHA_LBLOCK];\\r\\nunsigned char c[SHA256_CBLOCK];\\r\\n} *data = (void *)key->md.data;\\r\\nif ((key->aux.tls_aad[plen - 4] << 8 | key->aux.tls_aad[plen - 3])\\r\\n>= TLS1_1_VERSION)\\r\\niv = AES_BLOCK_SIZE;\\r\\nif (len < (iv + SHA256_DIGEST_LENGTH + 1))\\r\\nreturn 0;\\r\\nout += iv;\\r\\nlen -= iv;\\r\\npad = out[len - 1];\\r\\nmaxpad = len - (SHA256_DIGEST_LENGTH + 1);\\r\\nmaxpad |= (255 - maxpad) >> (sizeof(maxpad) * 8 - 8);\\r\\nmaxpad &= 255;\\r\\ninp_len = len - (SHA256_DIGEST_LENGTH + pad + 1);\\r\\nmask = (0 - ((inp_len - len) >> (sizeof(inp_len) * 8 - 1)));\\r\\ninp_len &= mask;\\r\\nret &= (int)mask;\\r\\nkey->aux.tls_aad[plen - 2] = inp_len >> 8;\\r\\nkey->aux.tls_aad[plen - 1] = inp_len;\\r\\nkey->md = key->head;\\r\\nSHA256_Update(&key->md, key->aux.tls_aad, plen);\\r\\n# if 1\\r\\nlen -= SHA256_DIGEST_LENGTH;\\r\\nif (len >= (256 + SHA256_CBLOCK)) {\\r\\nj = (len - (256 + SHA256_CBLOCK)) & (0 - SHA256_CBLOCK);\\r\\nj += SHA256_CBLOCK - key->md.num;\\r\\nSHA256_Update(&key->md, out, j);\\r\\nout += j;\\r\\nlen -= j;\\r\\ninp_len -= j;\\r\\n}\\r\\nbitlen = key->md.Nl + (inp_len << 3);\\r\\n# ifdef BSWAP4\\r\\nbitlen = BSWAP4(bitlen);\\r\\n# else\\r\\nmac.c[0] = 0;\\r\\nmac.c[1] = (unsigned char)(bitlen >> 16);\\r\\nmac.c[2] = (unsigned char)(bitlen >> 8);\\r\\nmac.c[3] = (unsigned char)bitlen;\\r\\nbitlen = mac.u[0];\\r\\n# endif\\r\\npmac->u[0] = 0;\\r\\npmac->u[1] = 0;\\r\\npmac->u[2] = 0;\\r\\npmac->u[3] = 0;\\r\\npmac->u[4] = 0;\\r\\npmac->u[5] = 0;\\r\\npmac->u[6] = 0;\\r\\npmac->u[7] = 0;\\r\\nfor (res = key->md.num, j = 0; j < len; j++) {\\r\\nsize_t c = out[j];\\r\\nmask = (j - inp_len) >> (sizeof(j) * 8 - 8);\\r\\nc &= mask;\\r\\nc |= 0x80 & ~mask & ~((inp_len - j) >> (sizeof(j) * 8 - 8));\\r\\ndata->c[res++] = (unsigned char)c;\\r\\nif (res != SHA256_CBLOCK)\\r\\ncontinue;\\r\\nmask = 0 - ((inp_len + 7 - j) >> (sizeof(j) * 8 - 1));\\r\\ndata->u[SHA_LBLOCK - 1] |= bitlen & mask;\\r\\nsha256_block_data_order(&key->md, data, 1);\\r\\nmask &= 0 - ((j - inp_len - 72) >> (sizeof(j) * 8 - 1));\\r\\npmac->u[0] |= key->md.h[0] & mask;\\r\\npmac->u[1] |= key->md.h[1] & mask;\\r\\npmac->u[2] |= key->md.h[2] & mask;\\r\\npmac->u[3] |= key->md.h[3] & mask;\\r\\npmac->u[4] |= key->md.h[4] & mask;\\r\\npmac->u[5] |= key->md.h[5] & mask;\\r\\npmac->u[6] |= key->md.h[6] & mask;\\r\\npmac->u[7] |= key->md.h[7] & mask;\\r\\nres = 0;\\r\\n}\\r\\nfor (i = res; i < SHA256_CBLOCK; i++, j++)\\r\\ndata->c[i] = 0;\\r\\nif (res > SHA256_CBLOCK - 8) {\\r\\nmask = 0 - ((inp_len + 8 - j) >> (sizeof(j) * 8 - 1));\\r\\ndata->u[SHA_LBLOCK - 1] |= bitlen & mask;\\r\\nsha256_block_data_order(&key->md, data, 1);\\r\\nmask &= 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\\r\\npmac->u[0] |= key->md.h[0] & mask;\\r\\npmac->u[1] |= key->md.h[1] & mask;\\r\\npmac->u[2] |= key->md.h[2] & mask;\\r\\npmac->u[3] |= key->md.h[3] & mask;\\r\\npmac->u[4] |= key->md.h[4] & mask;\\r\\npmac->u[5] |= key->md.h[5] & mask;\\r\\npmac->u[6] |= key->md.h[6] & mask;\\r\\npmac->u[7] |= key->md.h[7] & mask;\\r\\nmemset(data, 0, SHA256_CBLOCK);\\r\\nj += 64;\\r\\n}\\r\\ndata->u[SHA_LBLOCK - 1] = bitlen;\\r\\nsha256_block_data_order(&key->md, data, 1);\\r\\nmask = 0 - ((j - inp_len - 73) >> (sizeof(j) * 8 - 1));\\r\\npmac->u[0] |= key->md.h[0] & mask;\\r\\npmac->u[1] |= key->md.h[1] & mask;\\r\\npmac->u[2] |= key->md.h[2] & mask;\\r\\npmac->u[3] |= key->md.h[3] & mask;\\r\\npmac->u[4] |= key->md.h[4] & mask;\\r\\npmac->u[5] |= key->md.h[5] & mask;\\r\\npmac->u[6] |= key->md.h[6] & mask;\\r\\npmac->u[7] |= key->md.h[7] & mask;\\r\\n# ifdef BSWAP4\\r\\npmac->u[0] = BSWAP4(pmac->u[0]);\\r\\npmac->u[1] = BSWAP4(pmac->u[1]);\\r\\npmac->u[2] = BSWAP4(pmac->u[2]);\\r\\npmac->u[3] = BSWAP4(pmac->u[3]);\\r\\npmac->u[4] = BSWAP4(pmac->u[4]);\\r\\npmac->u[5] = BSWAP4(pmac->u[5]);\\r\\npmac->u[6] = BSWAP4(pmac->u[6]);\\r\\npmac->u[7] = BSWAP4(pmac->u[7]);\\r\\n# else\\r\\nfor (i = 0; i < 8; i++) {\\r\\nres = pmac->u[i];\\r\\npmac->c[4 * i + 0] = (unsigned char)(res >> 24);\\r\\npmac->c[4 * i + 1] = (unsigned char)(res >> 16);\\r\\npmac->c[4 * i + 2] = (unsigned char)(res >> 8);\\r\\npmac->c[4 * i + 3] = (unsigned char)res;\\r\\n}\\r\\n# endif\\r\\nlen += SHA256_DIGEST_LENGTH;\\r\\n# else\\r\\nSHA256_Update(&key->md, out, inp_len);\\r\\nres = key->md.num;\\r\\nSHA256_Final(pmac->c, &key->md);\\r\\n{\\r\\nunsigned int inp_blocks, pad_blocks;\\r\\ninp_blocks =\\r\\n1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\\r\\nres += (unsigned int)(len - inp_len);\\r\\npad_blocks = res / SHA256_CBLOCK;\\r\\nres %= SHA256_CBLOCK;\\r\\npad_blocks +=\\r\\n1 + ((SHA256_CBLOCK - 9 - res) >> (sizeof(res) * 8 - 1));\\r\\nfor (; inp_blocks < pad_blocks; inp_blocks++)\\r\\nsha1_block_data_order(&key->md, data, 1);\\r\\n}\\r\\n# endif\\r\\nkey->md = key->tail;\\r\\nSHA256_Update(&key->md, pmac->c, SHA256_DIGEST_LENGTH);\\r\\nSHA256_Final(pmac->c, &key->md);\\r\\nout += inp_len;\\r\\nlen -= inp_len;\\r\\n# if 1\\r\\n{\\r\\nunsigned char *p =\\r\\nout + len - 1 - maxpad - SHA256_DIGEST_LENGTH;\\r\\nsize_t off = out - p;\\r\\nunsigned int c, cmask;\\r\\nmaxpad += SHA256_DIGEST_LENGTH;\\r\\nfor (res = 0, i = 0, j = 0; j < maxpad; j++) {\\r\\nc = p[j];\\r\\ncmask =\\r\\n((int)(j - off - SHA256_DIGEST_LENGTH)) >>\\r\\n(sizeof(int) * 8 - 1);\\r\\nres |= (c ^ pad) & ~cmask;\\r\\ncmask &= ((int)(off - 1 - j)) >> (sizeof(int) * 8 - 1);\\r\\nres |= (c ^ pmac->c[i]) & cmask;\\r\\ni += 1 & cmask;\\r\\n}\\r\\nmaxpad -= SHA256_DIGEST_LENGTH;\\r\\nres = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\\r\\nret &= (int)~res;\\r\\n}\\r\\n# else\\r\\nfor (res = 0, i = 0; i < SHA256_DIGEST_LENGTH; i++)\\r\\nres |= out[i] ^ pmac->c[i];\\r\\nres = 0 - ((0 - res) >> (sizeof(res) * 8 - 1));\\r\\nret &= (int)~res;\\r\\npad = (pad & ~res) | (maxpad & res);\\r\\nout = out + len - 1 - pad;\\r\\nfor (res = 0, i = 0; i < pad; i++)\\r\\nres |= out[i] ^ pad;\\r\\nres = (0 - res) >> (sizeof(res) * 8 - 1);\\r\\nret &= (int)~res;\\r\\n# endif\\r\\nreturn ret;\\r\\n} else {\\r\\nSHA256_Update(&key->md, out, len);\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int aesni_cbc_hmac_sha256_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\\r\\nvoid *ptr)\\r\\n{\\r\\nEVP_AES_HMAC_SHA256 *key = data(ctx);\\r\\nswitch (type) {\\r\\ncase EVP_CTRL_AEAD_SET_MAC_KEY:\\r\\n{\\r\\nunsigned int i;\\r\\nunsigned char hmac_key[64];\\r\\nmemset(hmac_key, 0, sizeof(hmac_key));\\r\\nif (arg > (int)sizeof(hmac_key)) {\\r\\nSHA256_Init(&key->head);\\r\\nSHA256_Update(&key->head, ptr, arg);\\r\\nSHA256_Final(hmac_key, &key->head);\\r\\n} else {\\r\\nmemcpy(hmac_key, ptr, arg);\\r\\n}\\r\\nfor (i = 0; i < sizeof(hmac_key); i++)\\r\\nhmac_key[i] ^= 0x36;\\r\\nSHA256_Init(&key->head);\\r\\nSHA256_Update(&key->head, hmac_key, sizeof(hmac_key));\\r\\nfor (i = 0; i < sizeof(hmac_key); i++)\\r\\nhmac_key[i] ^= 0x36 ^ 0x5c;\\r\\nSHA256_Init(&key->tail);\\r\\nSHA256_Update(&key->tail, hmac_key, sizeof(hmac_key));\\r\\nOPENSSL_cleanse(hmac_key, sizeof(hmac_key));\\r\\nreturn 1;\\r\\n}\\r\\ncase EVP_CTRL_AEAD_TLS1_AAD:\\r\\n{\\r\\nunsigned char *p = ptr;\\r\\nunsigned int len = p[arg - 2] << 8 | p[arg - 1];\\r\\nif (ctx->encrypt) {\\r\\nkey->payload_length = len;\\r\\nif ((key->aux.tls_ver =\\r\\np[arg - 4] << 8 | p[arg - 3]) >= TLS1_1_VERSION) {\\r\\nlen -= AES_BLOCK_SIZE;\\r\\np[arg - 2] = len >> 8;\\r\\np[arg - 1] = len;\\r\\n}\\r\\nkey->md = key->head;\\r\\nSHA256_Update(&key->md, p, arg);\\r\\nreturn (int)(((len + SHA256_DIGEST_LENGTH +\\r\\nAES_BLOCK_SIZE) & -AES_BLOCK_SIZE)\\r\\n- len);\\r\\n} else {\\r\\nif (arg > 13)\\r\\narg = 13;\\r\\nmemcpy(key->aux.tls_aad, ptr, arg);\\r\\nkey->payload_length = arg;\\r\\nreturn SHA256_DIGEST_LENGTH;\\r\\n}\\r\\n}\\r\\n# if !defined(OPENSSL_NO_MULTIBLOCK) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK\\r\\ncase EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE:\\r\\nreturn (int)(5 + 16 + ((arg + 32 + 16) & -16));\\r\\ncase EVP_CTRL_TLS1_1_MULTIBLOCK_AAD:\\r\\n{\\r\\nEVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param =\\r\\n(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *) ptr;\\r\\nunsigned int n4x = 1, x4;\\r\\nunsigned int frag, last, packlen, inp_len;\\r\\nif (arg < (int)sizeof(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM))\\r\\nreturn -1;\\r\\ninp_len = param->inp[11] << 8 | param->inp[12];\\r\\nif (ctx->encrypt) {\\r\\nif ((param->inp[9] << 8 | param->inp[10]) < TLS1_1_VERSION)\\r\\nreturn -1;\\r\\nif (inp_len) {\\r\\nif (inp_len < 4096)\\r\\nreturn 0;\\r\\nif (inp_len >= 8192 && OPENSSL_ia32cap_P[2] & (1 << 5))\\r\\nn4x = 2;\\r\\n} else if ((n4x = param->interleave / 4) && n4x <= 2)\\r\\ninp_len = param->len;\\r\\nelse\\r\\nreturn -1;\\r\\nkey->md = key->head;\\r\\nSHA256_Update(&key->md, param->inp, 13);\\r\\nx4 = 4 * n4x;\\r\\nn4x += 1;\\r\\nfrag = inp_len >> n4x;\\r\\nlast = inp_len + frag - (frag << n4x);\\r\\nif (last > frag && ((last + 13 + 9) % 64 < (x4 - 1))) {\\r\\nfrag++;\\r\\nlast -= x4 - 1;\\r\\n}\\r\\npacklen = 5 + 16 + ((frag + 32 + 16) & -16);\\r\\npacklen = (packlen << n4x) - packlen;\\r\\npacklen += 5 + 16 + ((last + 32 + 16) & -16);\\r\\nparam->interleave = x4;\\r\\nreturn (int)packlen;\\r\\n} else\\r\\nreturn -1;\\r\\n}\\r\\ncase EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT:\\r\\n{\\r\\nEVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *param =\\r\\n(EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM *) ptr;\\r\\nreturn (int)tls1_1_multi_block_encrypt(key, param->out,\\r\\nparam->inp, param->len,\\r\\nparam->interleave / 4);\\r\\n}\\r\\ncase EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT:\\r\\n# endif\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_128_cbc_hmac_sha256(void)\\r\\n{\\r\\nreturn ((OPENSSL_ia32cap_P[1] & AESNI_CAPABLE) &&\\r\\naesni_cbc_sha256_enc(NULL, NULL, 0, NULL, NULL, NULL, NULL) ?\\r\\n&aesni_128_cbc_hmac_sha256_cipher : NULL);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void)\\r\\n{\\r\\nreturn ((OPENSSL_ia32cap_P[1] & AESNI_CAPABLE) &&\\r\\naesni_cbc_sha256_enc(NULL, NULL, 0, NULL, NULL, NULL, NULL) ?\\r\\n&aesni_256_cbc_hmac_sha256_cipher : NULL);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_128_cbc_hmac_sha256(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nconst EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_cert_c", "target": 0, "func": "int SSL_get_ex_data_X509_STORE_CTX_idx(void)\\r\\n{\\r\\nstatic volatile int ssl_x509_store_ctx_idx = -1;\\r\\nint got_write_lock = 0;\\r\\nif (((size_t)&ssl_x509_store_ctx_idx &\\r\\n(sizeof(ssl_x509_store_ctx_idx) - 1))\\r\\n== 0) {\\r\\nint ret;\\r\\nif ((ret = ssl_x509_store_ctx_idx) < 0) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nif ((ret = ssl_x509_store_ctx_idx) < 0) {\\r\\nret = ssl_x509_store_ctx_idx =\\r\\nX509_STORE_CTX_get_ex_new_index(0,\\r\\n\"SSL for verify callback\",\\r\\nNULL, NULL, NULL);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\n}\\r\\nreturn ret;\\r\\n} else {\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);\\r\\nif (ssl_x509_store_ctx_idx < 0) {\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\\r\\ngot_write_lock = 1;\\r\\nif (ssl_x509_store_ctx_idx < 0) {\\r\\nssl_x509_store_ctx_idx =\\r\\nX509_STORE_CTX_get_ex_new_index(0,\\r\\n\"SSL for verify callback\",\\r\\nNULL, NULL, NULL);\\r\\n}\\r\\n}\\r\\nif (got_write_lock)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nelse\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);\\r\\nreturn ssl_x509_store_ctx_idx;\\r\\n}\\r\\n}\\r\\nvoid ssl_cert_set_default_md(CERT *cert)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncert->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_sha1();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncert->pkeys[SSL_PKEY_RSA_SIGN].digest = EVP_sha1();\\r\\ncert->pkeys[SSL_PKEY_RSA_ENC].digest = EVP_sha1();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDSA\\r\\ncert->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();\\r\\n#endif\\r\\n}\\r\\nCERT *ssl_cert_new(void)\\r\\n{\\r\\nCERT *ret;\\r\\nret = (CERT *)OPENSSL_malloc(sizeof(CERT));\\r\\nif (ret == NULL) {\\r\\nSSLerr(SSL_F_SSL_CERT_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nmemset(ret, 0, sizeof(CERT));\\r\\nret->key = &(ret->pkeys[SSL_PKEY_RSA_ENC]);\\r\\nret->references = 1;\\r\\nssl_cert_set_default_md(ret);\\r\\nreturn (ret);\\r\\n}\\r\\nCERT *ssl_cert_dup(CERT *cert)\\r\\n{\\r\\nCERT *ret;\\r\\nint i;\\r\\nret = (CERT *)OPENSSL_malloc(sizeof(CERT));\\r\\nif (ret == NULL) {\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nmemset(ret, 0, sizeof(CERT));\\r\\nret->key = &ret->pkeys[cert->key - &cert->pkeys[0]];\\r\\nret->valid = cert->valid;\\r\\nret->mask_k = cert->mask_k;\\r\\nret->mask_a = cert->mask_a;\\r\\nret->export_mask_k = cert->export_mask_k;\\r\\nret->export_mask_a = cert->export_mask_a;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (cert->rsa_tmp != NULL) {\\r\\nRSA_up_ref(cert->rsa_tmp);\\r\\nret->rsa_tmp = cert->rsa_tmp;\\r\\n}\\r\\nret->rsa_tmp_cb = cert->rsa_tmp_cb;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (cert->dh_tmp != NULL) {\\r\\nret->dh_tmp = DHparams_dup(cert->dh_tmp);\\r\\nif (ret->dh_tmp == NULL) {\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_DH_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (cert->dh_tmp->priv_key) {\\r\\nBIGNUM *b = BN_dup(cert->dh_tmp->priv_key);\\r\\nif (!b) {\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->dh_tmp->priv_key = b;\\r\\n}\\r\\nif (cert->dh_tmp->pub_key) {\\r\\nBIGNUM *b = BN_dup(cert->dh_tmp->pub_key);\\r\\nif (!b) {\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret->dh_tmp->pub_key = b;\\r\\n}\\r\\n}\\r\\nret->dh_tmp_cb = cert->dh_tmp_cb;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (cert->ecdh_tmp) {\\r\\nret->ecdh_tmp = EC_KEY_dup(cert->ecdh_tmp);\\r\\nif (ret->ecdh_tmp == NULL) {\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nret->ecdh_tmp_cb = cert->ecdh_tmp_cb;\\r\\nret->ecdh_tmp_auto = cert->ecdh_tmp_auto;\\r\\n#endif\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++) {\\r\\nCERT_PKEY *cpk = cert->pkeys + i;\\r\\nCERT_PKEY *rpk = ret->pkeys + i;\\r\\nif (cpk->x509 != NULL) {\\r\\nrpk->x509 = cpk->x509;\\r\\nCRYPTO_add(&rpk->x509->references, 1, CRYPTO_LOCK_X509);\\r\\n}\\r\\nif (cpk->privatekey != NULL) {\\r\\nrpk->privatekey = cpk->privatekey;\\r\\nCRYPTO_add(&cpk->privatekey->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\n}\\r\\nif (cpk->chain) {\\r\\nrpk->chain = X509_chain_up_ref(cpk->chain);\\r\\nif (!rpk->chain) {\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nrpk->valid_flags = 0;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (cert->pkeys[i].serverinfo != NULL) {\\r\\nret->pkeys[i].serverinfo =\\r\\nOPENSSL_malloc(cert->pkeys[i].serverinfo_length);\\r\\nif (ret->pkeys[i].serverinfo == NULL) {\\r\\nSSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nret->pkeys[i].serverinfo_length =\\r\\ncert->pkeys[i].serverinfo_length;\\r\\nmemcpy(ret->pkeys[i].serverinfo,\\r\\ncert->pkeys[i].serverinfo,\\r\\ncert->pkeys[i].serverinfo_length);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nret->references = 1;\\r\\nssl_cert_set_default_md(ret);\\r\\nret->peer_sigalgs = NULL;\\r\\nret->peer_sigalgslen = 0;\\r\\nif (cert->conf_sigalgs) {\\r\\nret->conf_sigalgs = OPENSSL_malloc(cert->conf_sigalgslen);\\r\\nif (!ret->conf_sigalgs)\\r\\ngoto err;\\r\\nmemcpy(ret->conf_sigalgs, cert->conf_sigalgs, cert->conf_sigalgslen);\\r\\nret->conf_sigalgslen = cert->conf_sigalgslen;\\r\\n} else\\r\\nret->conf_sigalgs = NULL;\\r\\nif (cert->client_sigalgs) {\\r\\nret->client_sigalgs = OPENSSL_malloc(cert->client_sigalgslen);\\r\\nif (!ret->client_sigalgs)\\r\\ngoto err;\\r\\nmemcpy(ret->client_sigalgs, cert->client_sigalgs,\\r\\ncert->client_sigalgslen);\\r\\nret->client_sigalgslen = cert->client_sigalgslen;\\r\\n} else\\r\\nret->client_sigalgs = NULL;\\r\\nret->shared_sigalgs = NULL;\\r\\nif (cert->ctypes) {\\r\\nret->ctypes = OPENSSL_malloc(cert->ctype_num);\\r\\nif (!ret->ctypes)\\r\\ngoto err;\\r\\nmemcpy(ret->ctypes, cert->ctypes, cert->ctype_num);\\r\\nret->ctype_num = cert->ctype_num;\\r\\n}\\r\\nret->cert_flags = cert->cert_flags;\\r\\nret->cert_cb = cert->cert_cb;\\r\\nret->cert_cb_arg = cert->cert_cb_arg;\\r\\nif (cert->verify_store) {\\r\\nCRYPTO_add(&cert->verify_store->references, 1,\\r\\nCRYPTO_LOCK_X509_STORE);\\r\\nret->verify_store = cert->verify_store;\\r\\n}\\r\\nif (cert->chain_store) {\\r\\nCRYPTO_add(&cert->chain_store->references, 1, CRYPTO_LOCK_X509_STORE);\\r\\nret->chain_store = cert->chain_store;\\r\\n}\\r\\nret->ciphers_raw = NULL;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (!custom_exts_copy(&ret->cli_ext, &cert->cli_ext))\\r\\ngoto err;\\r\\nif (!custom_exts_copy(&ret->srv_ext, &cert->srv_ext))\\r\\ngoto err;\\r\\n#endif\\r\\nreturn (ret);\\r\\n#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_ECDH)\\r\\nerr:\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (ret->rsa_tmp != NULL)\\r\\nRSA_free(ret->rsa_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (ret->dh_tmp != NULL)\\r\\nDH_free(ret->dh_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (ret->ecdh_tmp != NULL)\\r\\nEC_KEY_free(ret->ecdh_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\ncustom_exts_free(&ret->cli_ext);\\r\\ncustom_exts_free(&ret->srv_ext);\\r\\n#endif\\r\\nssl_cert_clear_certs(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nvoid ssl_cert_clear_certs(CERT *c)\\r\\n{\\r\\nint i;\\r\\nif (c == NULL)\\r\\nreturn;\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++) {\\r\\nCERT_PKEY *cpk = c->pkeys + i;\\r\\nif (cpk->x509) {\\r\\nX509_free(cpk->x509);\\r\\ncpk->x509 = NULL;\\r\\n}\\r\\nif (cpk->privatekey) {\\r\\nEVP_PKEY_free(cpk->privatekey);\\r\\ncpk->privatekey = NULL;\\r\\n}\\r\\nif (cpk->chain) {\\r\\nsk_X509_pop_free(cpk->chain, X509_free);\\r\\ncpk->chain = NULL;\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (cpk->serverinfo) {\\r\\nOPENSSL_free(cpk->serverinfo);\\r\\ncpk->serverinfo = NULL;\\r\\ncpk->serverinfo_length = 0;\\r\\n}\\r\\n#endif\\r\\ncpk->valid_flags &= CERT_PKEY_EXPLICIT_SIGN;\\r\\n}\\r\\n}\\r\\nvoid ssl_cert_free(CERT *c)\\r\\n{\\r\\nint i;\\r\\nif (c == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&c->references, -1, CRYPTO_LOCK_SSL_CERT);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"CERT\", c);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"ssl_cert_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (c->rsa_tmp)\\r\\nRSA_free(c->rsa_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (c->dh_tmp)\\r\\nDH_free(c->dh_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (c->ecdh_tmp)\\r\\nEC_KEY_free(c->ecdh_tmp);\\r\\n#endif\\r\\nssl_cert_clear_certs(c);\\r\\nif (c->peer_sigalgs)\\r\\nOPENSSL_free(c->peer_sigalgs);\\r\\nif (c->conf_sigalgs)\\r\\nOPENSSL_free(c->conf_sigalgs);\\r\\nif (c->client_sigalgs)\\r\\nOPENSSL_free(c->client_sigalgs);\\r\\nif (c->shared_sigalgs)\\r\\nOPENSSL_free(c->shared_sigalgs);\\r\\nif (c->ctypes)\\r\\nOPENSSL_free(c->ctypes);\\r\\nif (c->verify_store)\\r\\nX509_STORE_free(c->verify_store);\\r\\nif (c->chain_store)\\r\\nX509_STORE_free(c->chain_store);\\r\\nif (c->ciphers_raw)\\r\\nOPENSSL_free(c->ciphers_raw);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\ncustom_exts_free(&c->cli_ext);\\r\\ncustom_exts_free(&c->srv_ext);\\r\\n#endif\\r\\nOPENSSL_free(c);\\r\\n}\\r\\nint ssl_cert_inst(CERT **o)\\r\\n{\\r\\nif (o == NULL) {\\r\\nSSLerr(SSL_F_SSL_CERT_INST, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (*o == NULL) {\\r\\nif ((*o = ssl_cert_new()) == NULL) {\\r\\nSSLerr(SSL_F_SSL_CERT_INST, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nint ssl_cert_add0_chain_cert(CERT *c, X509 *x)\\r\\n{\\r\\nCERT_PKEY *cpk = c->key;\\r\\nif (!cpk)\\r\\nreturn 0;\\r\\nif (!cpk->chain)\\r\\ncpk->chain = sk_X509_new_null();\\r\\nif (!cpk->chain || !sk_X509_push(cpk->chain, x))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_cert_add1_chain_cert(CERT *c, X509 *x)\\r\\n{\\r\\nif (!ssl_cert_add0_chain_cert(c, x))\\r\\nreturn 0;\\r\\nCRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_cert_select_current(CERT *c, X509 *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL)\\r\\nreturn 0;\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++) {\\r\\nCERT_PKEY *cpk = c->pkeys + i;\\r\\nif (cpk->x509 == x && cpk->privatekey) {\\r\\nc->key = cpk;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++) {\\r\\nCERT_PKEY *cpk = c->pkeys + i;\\r\\nif (cpk->privatekey && cpk->x509 && !X509_cmp(cpk->x509, x)) {\\r\\nc->key = cpk;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint ssl_cert_set_current(CERT *c, long op)\\r\\n{\\r\\nint i, idx;\\r\\nif (!c)\\r\\nreturn 0;\\r\\nif (op == SSL_CERT_SET_FIRST)\\r\\nidx = 0;\\r\\nelse if (op == SSL_CERT_SET_NEXT) {\\r\\nidx = (int)(c->key - c->pkeys + 1);\\r\\nif (idx >= SSL_PKEY_NUM)\\r\\nreturn 0;\\r\\n} else\\r\\nreturn 0;\\r\\nfor (i = idx; i < SSL_PKEY_NUM; i++) {\\r\\nCERT_PKEY *cpk = c->pkeys + i;\\r\\nif (cpk->x509 && cpk->privatekey) {\\r\\nc->key = cpk;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid ssl_cert_set_cert_cb(CERT *c, int (*cb) (SSL *ssl, void *arg), void *arg)\\r\\n{\\r\\nc->cert_cb = cb;\\r\\nc->cert_cb_arg = arg;\\r\\n}\\r\\nSESS_CERT *ssl_sess_cert_new(void)\\r\\n{\\r\\nSESS_CERT *ret;\\r\\nret = OPENSSL_malloc(sizeof *ret);\\r\\nif (ret == NULL) {\\r\\nSSLerr(SSL_F_SSL_SESS_CERT_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemset(ret, 0, sizeof *ret);\\r\\nret->peer_key = &(ret->peer_pkeys[SSL_PKEY_RSA_ENC]);\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nvoid ssl_sess_cert_free(SESS_CERT *sc)\\r\\n{\\r\\nint i;\\r\\nif (sc == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&sc->references, -1, CRYPTO_LOCK_SSL_SESS_CERT);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"SESS_CERT\", sc);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"ssl_sess_cert_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (sc->cert_chain != NULL)\\r\\nsk_X509_pop_free(sc->cert_chain, X509_free);\\r\\nfor (i = 0; i < SSL_PKEY_NUM; i++) {\\r\\nif (sc->peer_pkeys[i].x509 != NULL)\\r\\nX509_free(sc->peer_pkeys[i].x509);\\r\\n#if 0\\r\\nif (sc->peer_pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(sc->peer_pkeys[i].privatekey);\\r\\n#endif\\r\\n}\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (sc->peer_rsa_tmp != NULL)\\r\\nRSA_free(sc->peer_rsa_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DH\\r\\nif (sc->peer_dh_tmp != NULL)\\r\\nDH_free(sc->peer_dh_tmp);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\nif (sc->peer_ecdh_tmp != NULL)\\r\\nEC_KEY_free(sc->peer_ecdh_tmp);\\r\\n#endif\\r\\nOPENSSL_free(sc);\\r\\n}\\r\\nint ssl_set_peer_cert_type(SESS_CERT *sc, int type)\\r\\n{\\r\\nsc->peer_cert_type = type;\\r\\nreturn (1);\\r\\n}\\r\\nint SSL_add_client_CA(SSL *ssl, X509 *x)\\r\\n{\\r\\nreturn (add_client_CA(&(ssl->client_CA), x));\\r\\n}\\r\\nint SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *x)\\r\\n{\\r\\nreturn (add_client_CA(&(ctx->client_CA), x));\\r\\n}\\r\\nstatic int xname_cmp(const X509_NAME *const *a, const X509_NAME *const *b)\\r\\n{\\r\\nreturn (X509_NAME_cmp(*a, *b));\\r\\n}\\r\\nstatic int ssl_add_cert_to_buf(BUF_MEM *buf, unsigned long *l, X509 *x)\\r\\n{\\r\\nint n;\\r\\nunsigned char *p;\\r\\nn = i2d_X509(x, NULL);\\r\\nif (!BUF_MEM_grow_clean(buf, (int)(n + (*l) + 3))) {\\r\\nSSLerr(SSL_F_SSL_ADD_CERT_TO_BUF, ERR_R_BUF_LIB);\\r\\nreturn 0;\\r\\n}\\r\\np = (unsigned char *)&(buf->data[*l]);\\r\\nl2n3(n, p);\\r\\ni2d_X509(x, &p);\\r\\n*l += n + 3;\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_add_cert_chain(SSL *s, CERT_PKEY *cpk, unsigned long *l)\\r\\n{\\r\\nBUF_MEM *buf = s->init_buf;\\r\\nint no_chain;\\r\\nint i;\\r\\nX509 *x;\\r\\nSTACK_OF(X509) *extra_certs;\\r\\nX509_STORE *chain_store;\\r\\nif (cpk)\\r\\nx = cpk->x509;\\r\\nelse\\r\\nx = NULL;\\r\\nif (s->cert->chain_store)\\r\\nchain_store = s->cert->chain_store;\\r\\nelse\\r\\nchain_store = s->ctx->cert_store;\\r\\nif (cpk && cpk->chain)\\r\\nextra_certs = cpk->chain;\\r\\nelse\\r\\nextra_certs = s->ctx->extra_certs;\\r\\nif ((s->mode & SSL_MODE_NO_AUTO_CHAIN) || extra_certs)\\r\\nno_chain = 1;\\r\\nelse\\r\\nno_chain = 0;\\r\\nif (!BUF_MEM_grow_clean(buf, 10)) {\\r\\nSSLerr(SSL_F_SSL_ADD_CERT_CHAIN, ERR_R_BUF_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nif (x != NULL) {\\r\\nif (no_chain) {\\r\\nif (!ssl_add_cert_to_buf(buf, l, x))\\r\\nreturn 0;\\r\\n} else {\\r\\nX509_STORE_CTX xs_ctx;\\r\\nif (!X509_STORE_CTX_init(&xs_ctx, chain_store, x, NULL)) {\\r\\nSSLerr(SSL_F_SSL_ADD_CERT_CHAIN, ERR_R_X509_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nX509_verify_cert(&xs_ctx);\\r\\nERR_clear_error();\\r\\nfor (i = 0; i < sk_X509_num(xs_ctx.chain); i++) {\\r\\nx = sk_X509_value(xs_ctx.chain, i);\\r\\nif (!ssl_add_cert_to_buf(buf, l, x)) {\\r\\nX509_STORE_CTX_cleanup(&xs_ctx);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nX509_STORE_CTX_cleanup(&xs_ctx);\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < sk_X509_num(extra_certs); i++) {\\r\\nx = sk_X509_value(extra_certs, i);\\r\\nif (!ssl_add_cert_to_buf(buf, l, x))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_build_cert_chain(CERT *c, X509_STORE *chain_store, int flags)\\r\\n{\\r\\nCERT_PKEY *cpk = c->key;\\r\\nX509_STORE_CTX xs_ctx;\\r\\nSTACK_OF(X509) *chain = NULL, *untrusted = NULL;\\r\\nX509 *x;\\r\\nint i, rv = 0;\\r\\nunsigned long error;\\r\\nif (!cpk->x509) {\\r\\nSSLerr(SSL_F_SSL_BUILD_CERT_CHAIN, SSL_R_NO_CERTIFICATE_SET);\\r\\ngoto err;\\r\\n}\\r\\nif (flags & SSL_BUILD_CHAIN_FLAG_CHECK) {\\r\\nchain_store = X509_STORE_new();\\r\\nif (!chain_store)\\r\\ngoto err;\\r\\nfor (i = 0; i < sk_X509_num(cpk->chain); i++) {\\r\\nx = sk_X509_value(cpk->chain, i);\\r\\nif (!X509_STORE_add_cert(chain_store, x)) {\\r\\nerror = ERR_peek_last_error();\\r\\nif (ERR_GET_LIB(error) != ERR_LIB_X509 ||\\r\\nERR_GET_REASON(error) !=\\r\\nX509_R_CERT_ALREADY_IN_HASH_TABLE)\\r\\ngoto err;\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\nif (!X509_STORE_add_cert(chain_store, cpk->x509)) {\\r\\nerror = ERR_peek_last_error();\\r\\nif (ERR_GET_LIB(error) != ERR_LIB_X509 ||\\r\\nERR_GET_REASON(error) != X509_R_CERT_ALREADY_IN_HASH_TABLE)\\r\\ngoto err;\\r\\nERR_clear_error();\\r\\n}\\r\\n} else {\\r\\nif (c->chain_store)\\r\\nchain_store = c->chain_store;\\r\\nif (flags & SSL_BUILD_CHAIN_FLAG_UNTRUSTED)\\r\\nuntrusted = cpk->chain;\\r\\n}\\r\\nif (!X509_STORE_CTX_init(&xs_ctx, chain_store, cpk->x509, untrusted)) {\\r\\nSSLerr(SSL_F_SSL_BUILD_CERT_CHAIN, ERR_R_X509_LIB);\\r\\ngoto err;\\r\\n}\\r\\nX509_STORE_CTX_set_flags(&xs_ctx,\\r\\nc->cert_flags & SSL_CERT_FLAG_SUITEB_128_LOS);\\r\\ni = X509_verify_cert(&xs_ctx);\\r\\nif (i <= 0 && flags & SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR) {\\r\\nif (flags & SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR)\\r\\nERR_clear_error();\\r\\ni = 1;\\r\\nrv = 2;\\r\\n}\\r\\nif (i > 0)\\r\\nchain = X509_STORE_CTX_get1_chain(&xs_ctx);\\r\\nif (i <= 0) {\\r\\nSSLerr(SSL_F_SSL_BUILD_CERT_CHAIN, SSL_R_CERTIFICATE_VERIFY_FAILED);\\r\\ni = X509_STORE_CTX_get_error(&xs_ctx);\\r\\nERR_add_error_data(2, \"Verify error:\",\\r\\nX509_verify_cert_error_string(i));\\r\\nX509_STORE_CTX_cleanup(&xs_ctx);\\r\\ngoto err;\\r\\n}\\r\\nX509_STORE_CTX_cleanup(&xs_ctx);\\r\\nif (cpk->chain)\\r\\nsk_X509_pop_free(cpk->chain, X509_free);\\r\\nx = sk_X509_shift(chain);\\r\\nX509_free(x);\\r\\nif (flags & SSL_BUILD_CHAIN_FLAG_NO_ROOT) {\\r\\nif (sk_X509_num(chain) > 0) {\\r\\nx = sk_X509_value(chain, sk_X509_num(chain) - 1);\\r\\nX509_check_purpose(x, -1, 0);\\r\\nif (x->ex_flags & EXFLAG_SS) {\\r\\nx = sk_X509_pop(chain);\\r\\nX509_free(x);\\r\\n}\\r\\n}\\r\\n}\\r\\ncpk->chain = chain;\\r\\nif (rv == 0)\\r\\nrv = 1;\\r\\nerr:\\r\\nif (flags & SSL_BUILD_CHAIN_FLAG_CHECK)\\r\\nX509_STORE_free(chain_store);\\r\\nreturn rv;\\r\\n}\\r\\nint ssl_cert_set_cert_store(CERT *c, X509_STORE *store, int chain, int ref)\\r\\n{\\r\\nX509_STORE **pstore;\\r\\nif (chain)\\r\\npstore = &c->chain_store;\\r\\nelse\\r\\npstore = &c->verify_store;\\r\\nif (*pstore)\\r\\nX509_STORE_free(*pstore);\\r\\n*pstore = store;\\r\\nif (ref && store)\\r\\nCRYPTO_add(&store->references, 1, CRYPTO_LOCK_X509_STORE);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pk7_asn1_c", "target": 0, "func": "static int pk7_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nASN1_STREAM_ARG *sarg = exarg;\\r\\nPKCS7 **pp7 = (PKCS7 **)pval;\\r\\nswitch (operation) {\\r\\ncase ASN1_OP_STREAM_PRE:\\r\\nif (PKCS7_stream(&sarg->boundary, *pp7) <= 0)\\r\\nreturn 0;\\r\\ncase ASN1_OP_DETACHED_PRE:\\r\\nsarg->ndef_bio = PKCS7_dataInit(*pp7, sarg->out);\\r\\nif (!sarg->ndef_bio)\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase ASN1_OP_STREAM_POST:\\r\\ncase ASN1_OP_DETACHED_POST:\\r\\nif (PKCS7_dataFinal(*pp7, sarg->ndef_bio) <= 0)\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ciphers_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret = 1, i;\\r\\nint verbose = 0, Verbose = 0;\\r\\n#ifndef OPENSSL_NO_SSL_TRACE\\r\\nint stdname = 0;\\r\\n#endif\\r\\nconst char **pp;\\r\\nconst char *p;\\r\\nint badops = 0;\\r\\nSSL_CTX *ctx = NULL;\\r\\nSSL *ssl = NULL;\\r\\nchar *ciphers = NULL;\\r\\nconst SSL_METHOD *meth = NULL;\\r\\nSTACK_OF(SSL_CIPHER) *sk;\\r\\nchar buf[512];\\r\\nBIO *STDout = NULL;\\r\\nmeth = SSLv23_server_method();\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nSTDout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nSTDout = BIO_push(tmpbio, STDout);\\r\\n}\\r\\n#endif\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-v\") == 0)\\r\\nverbose = 1;\\r\\nelse if (strcmp(*argv, \"-V\") == 0)\\r\\nverbose = Verbose = 1;\\r\\n#ifndef OPENSSL_NO_SSL_TRACE\\r\\nelse if (strcmp(*argv, \"-stdname\") == 0)\\r\\nstdname = verbose = 1;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL2\\r\\nelse if (strcmp(*argv, \"-ssl2\") == 0)\\r\\nmeth = SSLv2_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SSL3\\r\\nelse if (strcmp(*argv, \"-ssl3\") == 0)\\r\\nmeth = SSLv3_client_method();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLS1\\r\\nelse if (strcmp(*argv, \"-tls1\") == 0)\\r\\nmeth = TLSv1_client_method();\\r\\n#endif\\r\\nelse if ((strncmp(*argv, \"-h\", 2) == 0) || (strcmp(*argv, \"-?\") == 0)) {\\r\\nbadops = 1;\\r\\nbreak;\\r\\n} else {\\r\\nciphers = *argv;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nfor (pp = ciphers_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err, \"%s\", *pp);\\r\\ngoto end;\\r\\n}\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nctx = SSL_CTX_new(meth);\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\nif (ciphers != NULL) {\\r\\nif (!SSL_CTX_set_cipher_list(ctx, ciphers)) {\\r\\nBIO_printf(bio_err, \"Error in cipher list\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nssl = SSL_new(ctx);\\r\\nif (ssl == NULL)\\r\\ngoto err;\\r\\nif (!verbose) {\\r\\nfor (i = 0;; i++) {\\r\\np = SSL_get_cipher_list(ssl, i);\\r\\nif (p == NULL)\\r\\nbreak;\\r\\nif (i != 0)\\r\\nBIO_printf(STDout, \":\");\\r\\nBIO_printf(STDout, \"%s\", p);\\r\\n}\\r\\nBIO_printf(STDout, \"\\n\");\\r\\n} else {\\r\\nsk = SSL_get_ciphers(ssl);\\r\\nfor (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {\\r\\nSSL_CIPHER *c;\\r\\nc = sk_SSL_CIPHER_value(sk, i);\\r\\nif (Verbose) {\\r\\nunsigned long id = SSL_CIPHER_get_id(c);\\r\\nint id0 = (int)(id >> 24);\\r\\nint id1 = (int)((id >> 16) & 0xffL);\\r\\nint id2 = (int)((id >> 8) & 0xffL);\\r\\nint id3 = (int)(id & 0xffL);\\r\\nif ((id & 0xff000000L) == 0x02000000L) {\\r\\nBIO_printf(STDout, \" 0x%02X,0x%02X,0x%02X - \", id1,\\r\\nid2, id3);\\r\\n} else if ((id & 0xff000000L) == 0x03000000L) {\\r\\nBIO_printf(STDout, \" 0x%02X,0x%02X - \", id2,\\r\\nid3);\\r\\n} else {\\r\\nBIO_printf(STDout, \"0x%02X,0x%02X,0x%02X,0x%02X - \", id0,\\r\\nid1, id2, id3);\\r\\n}\\r\\n}\\r\\n#ifndef OPENSSL_NO_SSL_TRACE\\r\\nif (stdname) {\\r\\nconst char *nm = SSL_CIPHER_standard_name(c);\\r\\nif (nm == NULL)\\r\\nnm = \"UNKNOWN\";\\r\\nBIO_printf(STDout, \"%s - \", nm);\\r\\n}\\r\\n#endif\\r\\nBIO_puts(STDout, SSL_CIPHER_description(c, buf, sizeof buf));\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nif (0) {\\r\\nerr:\\r\\nSSL_load_error_strings();\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nend:\\r\\nif (ctx != NULL)\\r\\nSSL_CTX_free(ctx);\\r\\nif (ssl != NULL)\\r\\nSSL_free(ssl);\\r\\nif (STDout != NULL)\\r\\nBIO_free_all(STDout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_n_pkey_c", "target": 0, "func": "int i2d_Netscape_RSA(const RSA *a, unsigned char **pp,\\r\\nint (*cb) (char *buf, int len, const char *prompt,\\r\\nint verify))\\r\\n{\\r\\nreturn i2d_RSA_NET(a, pp, cb, 0);\\r\\n}\\r\\nint i2d_RSA_NET(const RSA *a, unsigned char **pp,\\r\\nint (*cb) (char *buf, int len, const char *prompt,\\r\\nint verify), int sgckey)\\r\\n{\\r\\nint i, j, ret = 0;\\r\\nint rsalen, pkeylen, olen;\\r\\nNETSCAPE_PKEY *pkey = NULL;\\r\\nNETSCAPE_ENCRYPTED_PKEY *enckey = NULL;\\r\\nunsigned char buf[256], *zz;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nEVP_CIPHER_CTX ctx;\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif ((pkey = NETSCAPE_PKEY_new()) == NULL)\\r\\ngoto err;\\r\\nif ((enckey = NETSCAPE_ENCRYPTED_PKEY_new()) == NULL)\\r\\ngoto err;\\r\\npkey->version = 0;\\r\\npkey->algor->algorithm = OBJ_nid2obj(NID_rsaEncryption);\\r\\nif ((pkey->algor->parameter = ASN1_TYPE_new()) == NULL)\\r\\ngoto err;\\r\\npkey->algor->parameter->type = V_ASN1_NULL;\\r\\nrsalen = i2d_RSAPrivateKey(a, NULL);\\r\\npkey->private_key->length = rsalen;\\r\\npkeylen = i2d_NETSCAPE_PKEY(pkey, NULL);\\r\\nenckey->enckey->digest->length = pkeylen;\\r\\nenckey->os->length = 11;\\r\\nenckey->enckey->algor->algorithm = OBJ_nid2obj(NID_rc4);\\r\\nif ((enckey->enckey->algor->parameter = ASN1_TYPE_new()) == NULL)\\r\\ngoto err;\\r\\nenckey->enckey->algor->parameter->type = V_ASN1_NULL;\\r\\nif (pp == NULL) {\\r\\nolen = i2d_NETSCAPE_ENCRYPTED_PKEY(enckey, NULL);\\r\\nNETSCAPE_PKEY_free(pkey);\\r\\nNETSCAPE_ENCRYPTED_PKEY_free(enckey);\\r\\nreturn olen;\\r\\n}\\r\\nif ((zz = (unsigned char *)OPENSSL_malloc(rsalen)) == NULL) {\\r\\nASN1err(ASN1_F_I2D_RSA_NET, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npkey->private_key->data = zz;\\r\\ni2d_RSAPrivateKey(a, &zz);\\r\\nif ((zz = OPENSSL_malloc(pkeylen)) == NULL) {\\r\\nASN1err(ASN1_F_I2D_RSA_NET, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ASN1_STRING_set(enckey->os, \"private-key\", -1)) {\\r\\nASN1err(ASN1_F_I2D_RSA_NET, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nenckey->enckey->digest->data = zz;\\r\\ni2d_NETSCAPE_PKEY(pkey, &zz);\\r\\nOPENSSL_cleanse(pkey->private_key->data, rsalen);\\r\\nif (cb == NULL)\\r\\ncb = EVP_read_pw_string;\\r\\ni = cb((char *)buf, 256, \"Enter Private Key password:\", 1);\\r\\nif (i != 0) {\\r\\nASN1err(ASN1_F_I2D_RSA_NET, ASN1_R_BAD_PASSWORD_READ);\\r\\ngoto err;\\r\\n}\\r\\ni = strlen((char *)buf);\\r\\nif (sgckey) {\\r\\nif (!EVP_Digest(buf, i, buf, NULL, EVP_md5(), NULL))\\r\\ngoto err;\\r\\nmemcpy(buf + 16, \"SGCKEYSALT\", 10);\\r\\ni = 26;\\r\\n}\\r\\nif (!EVP_BytesToKey(EVP_rc4(), EVP_md5(), NULL, buf, i, 1, key, NULL))\\r\\ngoto err;\\r\\nOPENSSL_cleanse(buf, 256);\\r\\nzz = enckey->enckey->digest->data;\\r\\nif (!EVP_EncryptInit_ex(&ctx, EVP_rc4(), NULL, key, NULL))\\r\\ngoto err;\\r\\nif (!EVP_EncryptUpdate(&ctx, zz, &i, zz, pkeylen))\\r\\ngoto err;\\r\\nif (!EVP_EncryptFinal_ex(&ctx, zz + i, &j))\\r\\ngoto err;\\r\\nret = i2d_NETSCAPE_ENCRYPTED_PKEY(enckey, pp);\\r\\nerr:\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nNETSCAPE_ENCRYPTED_PKEY_free(enckey);\\r\\nNETSCAPE_PKEY_free(pkey);\\r\\nreturn (ret);\\r\\n}\\r\\nRSA *d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length,\\r\\nint (*cb) (char *buf, int len, const char *prompt,\\r\\nint verify))\\r\\n{\\r\\nreturn d2i_RSA_NET(a, pp, length, cb, 0);\\r\\n}\\r\\nRSA *d2i_RSA_NET(RSA **a, const unsigned char **pp, long length,\\r\\nint (*cb) (char *buf, int len, const char *prompt,\\r\\nint verify), int sgckey)\\r\\n{\\r\\nRSA *ret = NULL;\\r\\nconst unsigned char *p;\\r\\nNETSCAPE_ENCRYPTED_PKEY *enckey = NULL;\\r\\np = *pp;\\r\\nenckey = d2i_NETSCAPE_ENCRYPTED_PKEY(NULL, &p, length);\\r\\nif (!enckey) {\\r\\nASN1err(ASN1_F_D2I_RSA_NET, ASN1_R_DECODING_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif ((enckey->os->length != 11) || (strncmp(\"private-key\",\\r\\n(char *)enckey->os->data,\\r\\n11) != 0)) {\\r\\nASN1err(ASN1_F_D2I_RSA_NET, ASN1_R_PRIVATE_KEY_HEADER_MISSING);\\r\\nNETSCAPE_ENCRYPTED_PKEY_free(enckey);\\r\\nreturn NULL;\\r\\n}\\r\\nif (OBJ_obj2nid(enckey->enckey->algor->algorithm) != NID_rc4) {\\r\\nASN1err(ASN1_F_D2I_RSA_NET, ASN1_R_UNSUPPORTED_ENCRYPTION_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nif (cb == NULL)\\r\\ncb = EVP_read_pw_string;\\r\\nif ((ret = d2i_RSA_NET_2(a, enckey->enckey->digest, cb, sgckey)) == NULL)\\r\\ngoto err;\\r\\n*pp = p;\\r\\nerr:\\r\\nNETSCAPE_ENCRYPTED_PKEY_free(enckey);\\r\\nreturn ret;\\r\\n}\\r\\nstatic RSA *d2i_RSA_NET_2(RSA **a, ASN1_OCTET_STRING *os,\\r\\nint (*cb) (char *buf, int len, const char *prompt,\\r\\nint verify), int sgckey)\\r\\n{\\r\\nNETSCAPE_PKEY *pkey = NULL;\\r\\nRSA *ret = NULL;\\r\\nint i, j;\\r\\nunsigned char buf[256];\\r\\nconst unsigned char *zz;\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nEVP_CIPHER_CTX ctx;\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\ni = cb((char *)buf, 256, \"Enter Private Key password:\", 0);\\r\\nif (i != 0) {\\r\\nASN1err(ASN1_F_D2I_RSA_NET_2, ASN1_R_BAD_PASSWORD_READ);\\r\\ngoto err;\\r\\n}\\r\\ni = strlen((char *)buf);\\r\\nif (sgckey) {\\r\\nif (!EVP_Digest(buf, i, buf, NULL, EVP_md5(), NULL))\\r\\ngoto err;\\r\\nmemcpy(buf + 16, \"SGCKEYSALT\", 10);\\r\\ni = 26;\\r\\n}\\r\\nif (!EVP_BytesToKey(EVP_rc4(), EVP_md5(), NULL, buf, i, 1, key, NULL))\\r\\ngoto err;\\r\\nOPENSSL_cleanse(buf, 256);\\r\\nif (!EVP_DecryptInit_ex(&ctx, EVP_rc4(), NULL, key, NULL))\\r\\ngoto err;\\r\\nif (!EVP_DecryptUpdate(&ctx, os->data, &i, os->data, os->length))\\r\\ngoto err;\\r\\nif (!EVP_DecryptFinal_ex(&ctx, &(os->data[i]), &j))\\r\\ngoto err;\\r\\nos->length = i + j;\\r\\nzz = os->data;\\r\\nif ((pkey = d2i_NETSCAPE_PKEY(NULL, &zz, os->length)) == NULL) {\\r\\nASN1err(ASN1_F_D2I_RSA_NET_2,\\r\\nASN1_R_UNABLE_TO_DECODE_RSA_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nzz = pkey->private_key->data;\\r\\nif ((ret = d2i_RSAPrivateKey(a, &zz, pkey->private_key->length)) == NULL) {\\r\\nASN1err(ASN1_F_D2I_RSA_NET_2, ASN1_R_UNABLE_TO_DECODE_RSA_KEY);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nNETSCAPE_PKEY_free(pkey);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pcbc_enc_c", "target": 0, "func": "void DES_pcbc_encrypt(const unsigned char *input, unsigned char *output,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nDES_cblock *ivec, int enc)\\r\\n{\\r\\nregister DES_LONG sin0, sin1, xor0, xor1, tout0, tout1;\\r\\nDES_LONG tin[2];\\r\\nconst unsigned char *in;\\r\\nunsigned char *out, *iv;\\r\\nin = input;\\r\\nout = output;\\r\\niv = &(*ivec)[0];\\r\\nif (enc) {\\r\\nc2l(iv, xor0);\\r\\nc2l(iv, xor1);\\r\\nfor (; length > 0; length -= 8) {\\r\\nif (length >= 8) {\\r\\nc2l(in, sin0);\\r\\nc2l(in, sin1);\\r\\n} else\\r\\nc2ln(in, sin0, sin1, length);\\r\\ntin[0] = sin0 ^ xor0;\\r\\ntin[1] = sin1 ^ xor1;\\r\\nDES_encrypt1((DES_LONG *)tin, schedule, DES_ENCRYPT);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\nxor0 = sin0 ^ tout0;\\r\\nxor1 = sin1 ^ tout1;\\r\\nl2c(tout0, out);\\r\\nl2c(tout1, out);\\r\\n}\\r\\n} else {\\r\\nc2l(iv, xor0);\\r\\nc2l(iv, xor1);\\r\\nfor (; length > 0; length -= 8) {\\r\\nc2l(in, sin0);\\r\\nc2l(in, sin1);\\r\\ntin[0] = sin0;\\r\\ntin[1] = sin1;\\r\\nDES_encrypt1((DES_LONG *)tin, schedule, DES_DECRYPT);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nif (length >= 8) {\\r\\nl2c(tout0, out);\\r\\nl2c(tout1, out);\\r\\n} else\\r\\nl2cn(tout0, tout1, out, length);\\r\\nxor0 = tout0 ^ sin0;\\r\\nxor1 = tout1 ^ sin1;\\r\\n}\\r\\n}\\r\\ntin[0] = tin[1] = 0;\\r\\nsin0 = sin1 = xor0 = xor1 = tout0 = tout1 = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_genrsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nBN_GENCB cb;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e = NULL;\\r\\n# endif\\r\\nint ret = 1;\\r\\nint i, num = DEFBITS;\\r\\nlong l;\\r\\nconst EVP_CIPHER *enc = NULL;\\r\\nunsigned long f4 = RSA_F4;\\r\\nchar *outfile = NULL;\\r\\nchar *passargout = NULL, *passout = NULL;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n# endif\\r\\nchar *inrand = NULL;\\r\\nBIO *out = NULL;\\r\\nBIGNUM *bn = BN_new();\\r\\nRSA *rsa = NULL;\\r\\nif (!bn)\\r\\ngoto err;\\r\\napps_startup();\\r\\nBN_GENCB_set(&cb, genrsa_cb, bio_err);\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto err;\\r\\nif ((out = BIO_new(BIO_s_file())) == NULL) {\\r\\nBIO_printf(bio_err, \"unable to create BIO for output\\n\");\\r\\ngoto err;\\r\\n}\\r\\nargv++;\\r\\nargc--;\\r\\nfor (;;) {\\r\\nif (argc <= 0)\\r\\nbreak;\\r\\nif (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-3\") == 0)\\r\\nf4 = 3;\\r\\nelse if (strcmp(*argv, \"-F4\") == 0 || strcmp(*argv, \"-f4\") == 0)\\r\\nf4 = RSA_F4;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninrand = *(++argv);\\r\\n}\\r\\n# ifndef OPENSSL_NO_DES\\r\\nelse if (strcmp(*argv, \"-des\") == 0)\\r\\nenc = EVP_des_cbc();\\r\\nelse if (strcmp(*argv, \"-des3\") == 0)\\r\\nenc = EVP_des_ede3_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_IDEA\\r\\nelse if (strcmp(*argv, \"-idea\") == 0)\\r\\nenc = EVP_idea_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nelse if (strcmp(*argv, \"-seed\") == 0)\\r\\nenc = EVP_seed_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nelse if (strcmp(*argv, \"-aes128\") == 0)\\r\\nenc = EVP_aes_128_cbc();\\r\\nelse if (strcmp(*argv, \"-aes192\") == 0)\\r\\nenc = EVP_aes_192_cbc();\\r\\nelse if (strcmp(*argv, \"-aes256\") == 0)\\r\\nenc = EVP_aes_256_cbc();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nelse if (strcmp(*argv, \"-camellia128\") == 0)\\r\\nenc = EVP_camellia_128_cbc();\\r\\nelse if (strcmp(*argv, \"-camellia192\") == 0)\\r\\nenc = EVP_camellia_192_cbc();\\r\\nelse if (strcmp(*argv, \"-camellia256\") == 0)\\r\\nenc = EVP_camellia_256_cbc();\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-passout\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargout = *(++argv);\\r\\n} else\\r\\nbreak;\\r\\nargv++;\\r\\nargc--;\\r\\n}\\r\\nif ((argc >= 1) && ((sscanf(*argv, \"%d\", &num) == 0) || (num < 0))) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"usage: genrsa [args] [numbits]\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -des encrypt the generated key with DES in cbc mode\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -des3 encrypt the generated key with DES in ede cbc mode (168 bit key)\\n\");\\r\\n# ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf(bio_err,\\r\\n\" -idea encrypt the generated key with IDEA in cbc mode\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nBIO_printf(bio_err, \" -seed\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc seed\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err, \" -aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc aes\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nBIO_printf(bio_err, \" -camellia128, -camellia192, -camellia256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc camellia\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \" -out file output the key to 'file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -passout arg output file pass phrase source\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -f4 use F4 (0x10001) for the E value\\n\");\\r\\nBIO_printf(bio_err, \" -3 use 3 for the E value\\n\");\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \" -rand file%cfile%c...\\n\", LIST_SEPARATOR_CHAR,\\r\\nLIST_SEPARATOR_CHAR);\\r\\nBIO_printf(bio_err,\\r\\n\" load the file (or the files in the directory) into\\n\");\\r\\nBIO_printf(bio_err, \" the random number generator\\n\");\\r\\ngoto err;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nif (!app_passwd(bio_err, NULL, passargout, NULL, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto err;\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!app_RAND_load_file(NULL, bio_err, 1) && inrand == NULL\\r\\n&& !RAND_status()) {\\r\\nBIO_printf(bio_err,\\r\\n\"warning, not much extra random data, consider using the -rand option\\n\");\\r\\n}\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\nBIO_printf(bio_err, \"Generating RSA private key, %d bit long modulus\\n\",\\r\\nnum);\\r\\n# ifdef OPENSSL_NO_ENGINE\\r\\nrsa = RSA_new();\\r\\n# else\\r\\nrsa = RSA_new_method(e);\\r\\n# endif\\r\\nif (!rsa)\\r\\ngoto err;\\r\\nif (!BN_set_word(bn, f4) || !RSA_generate_key_ex(rsa, num, bn, &cb))\\r\\ngoto err;\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nl = 0L;\\r\\nfor (i = 0; i < rsa->e->top; i++) {\\r\\n# ifndef SIXTY_FOUR_BIT\\r\\nl <<= BN_BITS4;\\r\\nl <<= BN_BITS4;\\r\\n# endif\\r\\nl += rsa->e->d[i];\\r\\n}\\r\\nBIO_printf(bio_err, \"e is %ld (0x%lX)\\n\", l, l);\\r\\n{\\r\\nPW_CB_DATA cb_data;\\r\\ncb_data.password = passout;\\r\\ncb_data.prompt_info = outfile;\\r\\nif (!PEM_write_bio_RSAPrivateKey(out, rsa, enc, NULL, 0,\\r\\n(pem_password_cb *)password_callback,\\r\\n&cb_data))\\r\\ngoto err;\\r\\n}\\r\\nret = 0;\\r\\nerr:\\r\\nif (bn)\\r\\nBN_free(bn);\\r\\nif (rsa)\\r\\nRSA_free(rsa);\\r\\nif (out)\\r\\nBIO_free_all(out);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\nif (ret != 0)\\r\\nERR_print_errors(bio_err);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int MS_CALLBACK genrsa_cb(int p, int n, BN_GENCB *cb)\\r\\n{\\r\\nchar c = '*';\\r\\nif (p == 0)\\r\\nc = '.';\\r\\nif (p == 1)\\r\\nc = '+';\\r\\nif (p == 2)\\r\\nc = '*';\\r\\nif (p == 3)\\r\\nc = '\\n';\\r\\nBIO_write(cb->arg, &c, 1);\\r\\n(void)BIO_flush(cb->arg);\\r\\n# ifdef LINT\\r\\np = n;\\r\\n# endif\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_obj_dat_c", "target": 0, "func": "static int sn_cmp(const ASN1_OBJECT *const *a, const unsigned int *b)\\r\\n{\\r\\nreturn (strcmp((*a)->sn, nid_objs[*b].sn));\\r\\n}\\r\\nstatic int ln_cmp(const ASN1_OBJECT *const *a, const unsigned int *b)\\r\\n{\\r\\nreturn (strcmp((*a)->ln, nid_objs[*b].ln));\\r\\n}\\r\\nstatic unsigned long added_obj_hash(const ADDED_OBJ *ca)\\r\\n{\\r\\nconst ASN1_OBJECT *a;\\r\\nint i;\\r\\nunsigned long ret = 0;\\r\\nunsigned char *p;\\r\\na = ca->obj;\\r\\nswitch (ca->type) {\\r\\ncase ADDED_DATA:\\r\\nret = a->length << 20L;\\r\\np = (unsigned char *)a->data;\\r\\nfor (i = 0; i < a->length; i++)\\r\\nret ^= p[i] << ((i * 3) % 24);\\r\\nbreak;\\r\\ncase ADDED_SNAME:\\r\\nret = lh_strhash(a->sn);\\r\\nbreak;\\r\\ncase ADDED_LNAME:\\r\\nret = lh_strhash(a->ln);\\r\\nbreak;\\r\\ncase ADDED_NID:\\r\\nret = a->nid;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nret &= 0x3fffffffL;\\r\\nret |= ((unsigned long)ca->type) << 30L;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int init_added(void)\\r\\n{\\r\\nif (added != NULL)\\r\\nreturn (1);\\r\\nadded = lh_ADDED_OBJ_new();\\r\\nreturn (added != NULL);\\r\\n}\\r\\nstatic void cleanup1_doall(ADDED_OBJ *a)\\r\\n{\\r\\na->obj->nid = 0;\\r\\na->obj->flags |= ASN1_OBJECT_FLAG_DYNAMIC |\\r\\nASN1_OBJECT_FLAG_DYNAMIC_STRINGS | ASN1_OBJECT_FLAG_DYNAMIC_DATA;\\r\\n}\\r\\nstatic void cleanup2_doall(ADDED_OBJ *a)\\r\\n{\\r\\na->obj->nid++;\\r\\n}\\r\\nstatic void cleanup3_doall(ADDED_OBJ *a)\\r\\n{\\r\\nif (--a->obj->nid == 0)\\r\\nASN1_OBJECT_free(a->obj);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nvoid check_defer(int nid)\\r\\n{\\r\\nif (!obj_cleanup_defer && nid >= NUM_NID)\\r\\nobj_cleanup_defer = 1;\\r\\n}\\r\\nvoid OBJ_cleanup(void)\\r\\n{\\r\\nif (obj_cleanup_defer) {\\r\\nobj_cleanup_defer = 2;\\r\\nreturn;\\r\\n}\\r\\nif (added == NULL)\\r\\nreturn;\\r\\nlh_ADDED_OBJ_down_load(added) = 0;\\r\\nlh_ADDED_OBJ_doall(added, LHASH_DOALL_FN(cleanup1));\\r\\nlh_ADDED_OBJ_doall(added, LHASH_DOALL_FN(cleanup2));\\r\\nlh_ADDED_OBJ_doall(added, LHASH_DOALL_FN(cleanup3));\\r\\nlh_ADDED_OBJ_free(added);\\r\\nadded = NULL;\\r\\n}\\r\\nint OBJ_new_nid(int num)\\r\\n{\\r\\nint i;\\r\\ni = new_nid;\\r\\nnew_nid += num;\\r\\nreturn (i);\\r\\n}\\r\\nint OBJ_add_object(const ASN1_OBJECT *obj)\\r\\n{\\r\\nASN1_OBJECT *o;\\r\\nADDED_OBJ *ao[4] = { NULL, NULL, NULL, NULL }, *aop;\\r\\nint i;\\r\\nif (added == NULL)\\r\\nif (!init_added())\\r\\nreturn (0);\\r\\nif ((o = OBJ_dup(obj)) == NULL)\\r\\ngoto err;\\r\\nif (!(ao[ADDED_NID] = (ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ))))\\r\\ngoto err2;\\r\\nif ((o->length != 0) && (obj->data != NULL))\\r\\nif (!\\r\\n(ao[ADDED_DATA] = (ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ))))\\r\\ngoto err2;\\r\\nif (o->sn != NULL)\\r\\nif (!\\r\\n(ao[ADDED_SNAME] =\\r\\n(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ))))\\r\\ngoto err2;\\r\\nif (o->ln != NULL)\\r\\nif (!\\r\\n(ao[ADDED_LNAME] =\\r\\n(ADDED_OBJ *)OPENSSL_malloc(sizeof(ADDED_OBJ))))\\r\\ngoto err2;\\r\\nfor (i = ADDED_DATA; i <= ADDED_NID; i++) {\\r\\nif (ao[i] != NULL) {\\r\\nao[i]->type = i;\\r\\nao[i]->obj = o;\\r\\naop = lh_ADDED_OBJ_insert(added, ao[i]);\\r\\nif (aop != NULL)\\r\\nOPENSSL_free(aop);\\r\\n}\\r\\n}\\r\\no->flags &=\\r\\n~(ASN1_OBJECT_FLAG_DYNAMIC | ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |\\r\\nASN1_OBJECT_FLAG_DYNAMIC_DATA);\\r\\nreturn (o->nid);\\r\\nerr2:\\r\\nOBJerr(OBJ_F_OBJ_ADD_OBJECT, ERR_R_MALLOC_FAILURE);\\r\\nerr:\\r\\nfor (i = ADDED_DATA; i <= ADDED_NID; i++)\\r\\nif (ao[i] != NULL)\\r\\nOPENSSL_free(ao[i]);\\r\\nif (o != NULL)\\r\\nOPENSSL_free(o);\\r\\nreturn (NID_undef);\\r\\n}\\r\\nASN1_OBJECT *OBJ_nid2obj(int n)\\r\\n{\\r\\nADDED_OBJ ad, *adp;\\r\\nASN1_OBJECT ob;\\r\\nif ((n >= 0) && (n < NUM_NID)) {\\r\\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {\\r\\nOBJerr(OBJ_F_OBJ_NID2OBJ, OBJ_R_UNKNOWN_NID);\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn ((ASN1_OBJECT *)&(nid_objs[n]));\\r\\n} else if (added == NULL)\\r\\nreturn (NULL);\\r\\nelse {\\r\\nad.type = ADDED_NID;\\r\\nad.obj = &ob;\\r\\nob.nid = n;\\r\\nadp = lh_ADDED_OBJ_retrieve(added, &ad);\\r\\nif (adp != NULL)\\r\\nreturn (adp->obj);\\r\\nelse {\\r\\nOBJerr(OBJ_F_OBJ_NID2OBJ, OBJ_R_UNKNOWN_NID);\\r\\nreturn (NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nconst char *OBJ_nid2sn(int n)\\r\\n{\\r\\nADDED_OBJ ad, *adp;\\r\\nASN1_OBJECT ob;\\r\\nif ((n >= 0) && (n < NUM_NID)) {\\r\\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {\\r\\nOBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (nid_objs[n].sn);\\r\\n} else if (added == NULL)\\r\\nreturn (NULL);\\r\\nelse {\\r\\nad.type = ADDED_NID;\\r\\nad.obj = &ob;\\r\\nob.nid = n;\\r\\nadp = lh_ADDED_OBJ_retrieve(added, &ad);\\r\\nif (adp != NULL)\\r\\nreturn (adp->obj->sn);\\r\\nelse {\\r\\nOBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);\\r\\nreturn (NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nconst char *OBJ_nid2ln(int n)\\r\\n{\\r\\nADDED_OBJ ad, *adp;\\r\\nASN1_OBJECT ob;\\r\\nif ((n >= 0) && (n < NUM_NID)) {\\r\\nif ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {\\r\\nOBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (nid_objs[n].ln);\\r\\n} else if (added == NULL)\\r\\nreturn (NULL);\\r\\nelse {\\r\\nad.type = ADDED_NID;\\r\\nad.obj = &ob;\\r\\nob.nid = n;\\r\\nadp = lh_ADDED_OBJ_retrieve(added, &ad);\\r\\nif (adp != NULL)\\r\\nreturn (adp->obj->ln);\\r\\nelse {\\r\\nOBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);\\r\\nreturn (NULL);\\r\\n}\\r\\n}\\r\\n}\\r\\nstatic int obj_cmp(const ASN1_OBJECT *const *ap, const unsigned int *bp)\\r\\n{\\r\\nint j;\\r\\nconst ASN1_OBJECT *a = *ap;\\r\\nconst ASN1_OBJECT *b = &nid_objs[*bp];\\r\\nj = (a->length - b->length);\\r\\nif (j)\\r\\nreturn (j);\\r\\nreturn (memcmp(a->data, b->data, a->length));\\r\\n}\\r\\nint OBJ_obj2nid(const ASN1_OBJECT *a)\\r\\n{\\r\\nconst unsigned int *op;\\r\\nADDED_OBJ ad, *adp;\\r\\nif (a == NULL)\\r\\nreturn (NID_undef);\\r\\nif (a->nid != 0)\\r\\nreturn (a->nid);\\r\\nif (added != NULL) {\\r\\nad.type = ADDED_DATA;\\r\\nad.obj = (ASN1_OBJECT *)a;\\r\\nadp = lh_ADDED_OBJ_retrieve(added, &ad);\\r\\nif (adp != NULL)\\r\\nreturn (adp->obj->nid);\\r\\n}\\r\\nop = OBJ_bsearch_obj(&a, obj_objs, NUM_OBJ);\\r\\nif (op == NULL)\\r\\nreturn (NID_undef);\\r\\nreturn (nid_objs[*op].nid);\\r\\n}\\r\\nASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)\\r\\n{\\r\\nint nid = NID_undef;\\r\\nASN1_OBJECT *op = NULL;\\r\\nunsigned char *buf;\\r\\nunsigned char *p;\\r\\nconst unsigned char *cp;\\r\\nint i, j;\\r\\nif (!no_name) {\\r\\nif (((nid = OBJ_sn2nid(s)) != NID_undef) ||\\r\\n((nid = OBJ_ln2nid(s)) != NID_undef))\\r\\nreturn OBJ_nid2obj(nid);\\r\\n}\\r\\ni = a2d_ASN1_OBJECT(NULL, 0, s, -1);\\r\\nif (i <= 0) {\\r\\nreturn NULL;\\r\\n}\\r\\nj = ASN1_object_size(0, i, V_ASN1_OBJECT);\\r\\nif ((buf = (unsigned char *)OPENSSL_malloc(j)) == NULL)\\r\\nreturn NULL;\\r\\np = buf;\\r\\nASN1_put_object(&p, 0, i, V_ASN1_OBJECT, V_ASN1_UNIVERSAL);\\r\\na2d_ASN1_OBJECT(p, i, s, -1);\\r\\ncp = buf;\\r\\nop = d2i_ASN1_OBJECT(NULL, &cp, j);\\r\\nOPENSSL_free(buf);\\r\\nreturn op;\\r\\n}\\r\\nint OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\\r\\n{\\r\\nint i, n = 0, len, nid, first, use_bn;\\r\\nBIGNUM *bl;\\r\\nunsigned long l;\\r\\nconst unsigned char *p;\\r\\nchar tbuf[DECIMAL_SIZE(i) + DECIMAL_SIZE(l) + 2];\\r\\nif (buf && buf_len > 0)\\r\\nbuf[0] = '\\0';\\r\\nif ((a == NULL) || (a->data == NULL))\\r\\nreturn (0);\\r\\nif (!no_name && (nid = OBJ_obj2nid(a)) != NID_undef) {\\r\\nconst char *s;\\r\\ns = OBJ_nid2ln(nid);\\r\\nif (s == NULL)\\r\\ns = OBJ_nid2sn(nid);\\r\\nif (s) {\\r\\nif (buf)\\r\\nBUF_strlcpy(buf, s, buf_len);\\r\\nn = strlen(s);\\r\\nreturn n;\\r\\n}\\r\\n}\\r\\nlen = a->length;\\r\\np = a->data;\\r\\nfirst = 1;\\r\\nbl = NULL;\\r\\nwhile (len > 0) {\\r\\nl = 0;\\r\\nuse_bn = 0;\\r\\nfor (;;) {\\r\\nunsigned char c = *p++;\\r\\nlen--;\\r\\nif ((len == 0) && (c & 0x80))\\r\\ngoto err;\\r\\nif (use_bn) {\\r\\nif (!BN_add_word(bl, c & 0x7f))\\r\\ngoto err;\\r\\n} else\\r\\nl |= c & 0x7f;\\r\\nif (!(c & 0x80))\\r\\nbreak;\\r\\nif (!use_bn && (l > (ULONG_MAX >> 7L))) {\\r\\nif (!bl && !(bl = BN_new()))\\r\\ngoto err;\\r\\nif (!BN_set_word(bl, l))\\r\\ngoto err;\\r\\nuse_bn = 1;\\r\\n}\\r\\nif (use_bn) {\\r\\nif (!BN_lshift(bl, bl, 7))\\r\\ngoto err;\\r\\n} else\\r\\nl <<= 7L;\\r\\n}\\r\\nif (first) {\\r\\nfirst = 0;\\r\\nif (l >= 80) {\\r\\ni = 2;\\r\\nif (use_bn) {\\r\\nif (!BN_sub_word(bl, 80))\\r\\ngoto err;\\r\\n} else\\r\\nl -= 80;\\r\\n} else {\\r\\ni = (int)(l / 40);\\r\\nl -= (long)(i * 40);\\r\\n}\\r\\nif (buf && (buf_len > 1)) {\\r\\n*buf++ = i + '0';\\r\\n*buf = '\\0';\\r\\nbuf_len--;\\r\\n}\\r\\nn++;\\r\\n}\\r\\nif (use_bn) {\\r\\nchar *bndec;\\r\\nbndec = BN_bn2dec(bl);\\r\\nif (!bndec)\\r\\ngoto err;\\r\\ni = strlen(bndec);\\r\\nif (buf) {\\r\\nif (buf_len > 1) {\\r\\n*buf++ = '.';\\r\\n*buf = '\\0';\\r\\nbuf_len--;\\r\\n}\\r\\nBUF_strlcpy(buf, bndec, buf_len);\\r\\nif (i > buf_len) {\\r\\nbuf += buf_len;\\r\\nbuf_len = 0;\\r\\n} else {\\r\\nbuf += i;\\r\\nbuf_len -= i;\\r\\n}\\r\\n}\\r\\nn++;\\r\\nn += i;\\r\\nOPENSSL_free(bndec);\\r\\n} else {\\r\\nBIO_snprintf(tbuf, sizeof tbuf, \".%lu\", l);\\r\\ni = strlen(tbuf);\\r\\nif (buf && (buf_len > 0)) {\\r\\nBUF_strlcpy(buf, tbuf, buf_len);\\r\\nif (i > buf_len) {\\r\\nbuf += buf_len;\\r\\nbuf_len = 0;\\r\\n} else {\\r\\nbuf += i;\\r\\nbuf_len -= i;\\r\\n}\\r\\n}\\r\\nn += i;\\r\\nl = 0;\\r\\n}\\r\\n}\\r\\nif (bl)\\r\\nBN_free(bl);\\r\\nreturn n;\\r\\nerr:\\r\\nif (bl)\\r\\nBN_free(bl);\\r\\nreturn -1;\\r\\n}\\r\\nint OBJ_txt2nid(const char *s)\\r\\n{\\r\\nASN1_OBJECT *obj;\\r\\nint nid;\\r\\nobj = OBJ_txt2obj(s, 0);\\r\\nnid = OBJ_obj2nid(obj);\\r\\nASN1_OBJECT_free(obj);\\r\\nreturn nid;\\r\\n}\\r\\nint OBJ_ln2nid(const char *s)\\r\\n{\\r\\nASN1_OBJECT o;\\r\\nconst ASN1_OBJECT *oo = &o;\\r\\nADDED_OBJ ad, *adp;\\r\\nconst unsigned int *op;\\r\\no.ln = s;\\r\\nif (added != NULL) {\\r\\nad.type = ADDED_LNAME;\\r\\nad.obj = &o;\\r\\nadp = lh_ADDED_OBJ_retrieve(added, &ad);\\r\\nif (adp != NULL)\\r\\nreturn (adp->obj->nid);\\r\\n}\\r\\nop = OBJ_bsearch_ln(&oo, ln_objs, NUM_LN);\\r\\nif (op == NULL)\\r\\nreturn (NID_undef);\\r\\nreturn (nid_objs[*op].nid);\\r\\n}\\r\\nint OBJ_sn2nid(const char *s)\\r\\n{\\r\\nASN1_OBJECT o;\\r\\nconst ASN1_OBJECT *oo = &o;\\r\\nADDED_OBJ ad, *adp;\\r\\nconst unsigned int *op;\\r\\no.sn = s;\\r\\nif (added != NULL) {\\r\\nad.type = ADDED_SNAME;\\r\\nad.obj = &o;\\r\\nadp = lh_ADDED_OBJ_retrieve(added, &ad);\\r\\nif (adp != NULL)\\r\\nreturn (adp->obj->nid);\\r\\n}\\r\\nop = OBJ_bsearch_sn(&oo, sn_objs, NUM_SN);\\r\\nif (op == NULL)\\r\\nreturn (NID_undef);\\r\\nreturn (nid_objs[*op].nid);\\r\\n}\\r\\nconst void *OBJ_bsearch_(const void *key, const void *base, int num, int size,\\r\\nint (*cmp) (const void *, const void *))\\r\\n{\\r\\nreturn OBJ_bsearch_ex_(key, base, num, size, cmp, 0);\\r\\n}\\r\\nconst void *OBJ_bsearch_ex_(const void *key, const void *base_, int num,\\r\\nint size,\\r\\nint (*cmp) (const void *, const void *),\\r\\nint flags)\\r\\n{\\r\\nconst char *base = base_;\\r\\nint l, h, i = 0, c = 0;\\r\\nconst char *p = NULL;\\r\\nif (num == 0)\\r\\nreturn (NULL);\\r\\nl = 0;\\r\\nh = num;\\r\\nwhile (l < h) {\\r\\ni = (l + h) / 2;\\r\\np = &(base[i * size]);\\r\\nc = (*cmp) (key, p);\\r\\nif (c < 0)\\r\\nh = i;\\r\\nelse if (c > 0)\\r\\nl = i + 1;\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nif (c != 0) {\\r\\nfor (i = 0; i < num; ++i) {\\r\\np = &(base[i * size]);\\r\\nc = (*cmp) (key, p);\\r\\nif (c == 0 || (c < 0 && (flags & OBJ_BSEARCH_VALUE_ON_NOMATCH)))\\r\\nreturn p;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (c != 0 && !(flags & OBJ_BSEARCH_VALUE_ON_NOMATCH))\\r\\np = NULL;\\r\\nelse if (c == 0 && (flags & OBJ_BSEARCH_FIRST_VALUE_ON_MATCH)) {\\r\\nwhile (i > 0 && (*cmp) (key, &(base[(i - 1) * size])) == 0)\\r\\ni--;\\r\\np = &(base[i * size]);\\r\\n}\\r\\nreturn (p);\\r\\n}\\r\\nint OBJ_create_objects(BIO *in)\\r\\n{\\r\\nMS_STATIC char buf[512];\\r\\nint i, num = 0;\\r\\nchar *o, *s, *l = NULL;\\r\\nfor (;;) {\\r\\ns = o = NULL;\\r\\ni = BIO_gets(in, buf, 512);\\r\\nif (i <= 0)\\r\\nreturn (num);\\r\\nbuf[i - 1] = '\\0';\\r\\nif (!isalnum((unsigned char)buf[0]))\\r\\nreturn (num);\\r\\no = s = buf;\\r\\nwhile (isdigit((unsigned char)*s) || (*s == '.'))\\r\\ns++;\\r\\nif (*s != '\\0') {\\r\\n*(s++) = '\\0';\\r\\nwhile (isspace((unsigned char)*s))\\r\\ns++;\\r\\nif (*s == '\\0')\\r\\ns = NULL;\\r\\nelse {\\r\\nl = s;\\r\\nwhile ((*l != '\\0') && !isspace((unsigned char)*l))\\r\\nl++;\\r\\nif (*l != '\\0') {\\r\\n*(l++) = '\\0';\\r\\nwhile (isspace((unsigned char)*l))\\r\\nl++;\\r\\nif (*l == '\\0')\\r\\nl = NULL;\\r\\n} else\\r\\nl = NULL;\\r\\n}\\r\\n} else\\r\\ns = NULL;\\r\\nif ((o == NULL) || (*o == '\\0'))\\r\\nreturn (num);\\r\\nif (!OBJ_create(o, s, l))\\r\\nreturn (num);\\r\\nnum++;\\r\\n}\\r\\n}\\r\\nint OBJ_create(const char *oid, const char *sn, const char *ln)\\r\\n{\\r\\nint ok = 0;\\r\\nASN1_OBJECT *op = NULL;\\r\\nunsigned char *buf;\\r\\nint i;\\r\\ni = a2d_ASN1_OBJECT(NULL, 0, oid, -1);\\r\\nif (i <= 0)\\r\\nreturn (0);\\r\\nif ((buf = (unsigned char *)OPENSSL_malloc(i)) == NULL) {\\r\\nOBJerr(OBJ_F_OBJ_CREATE, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\ni = a2d_ASN1_OBJECT(buf, i, oid, -1);\\r\\nif (i == 0)\\r\\ngoto err;\\r\\nop = (ASN1_OBJECT *)ASN1_OBJECT_create(OBJ_new_nid(1), buf, i, sn, ln);\\r\\nif (op == NULL)\\r\\ngoto err;\\r\\nok = OBJ_add_object(op);\\r\\nerr:\\r\\nASN1_OBJECT_free(op);\\r\\nOPENSSL_free(buf);\\r\\nreturn (ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_div_c", "target": 0, "func": "int BN_div(BIGNUM *dv, BIGNUM *rm, const BIGNUM *num, const BIGNUM *divisor,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint norm_shift, i, loop;\\r\\nBIGNUM *tmp, wnum, *snum, *sdiv, *res;\\r\\nBN_ULONG *resp, *wnump;\\r\\nBN_ULONG d0, d1;\\r\\nint num_n, div_n;\\r\\nint no_branch = 0;\\r\\nif ((num->top > 0 && num->d[num->top - 1] == 0) ||\\r\\n(divisor->top > 0 && divisor->d[divisor->top - 1] == 0)) {\\r\\nBNerr(BN_F_BN_DIV, BN_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nbn_check_top(num);\\r\\nbn_check_top(divisor);\\r\\nif ((BN_get_flags(num, BN_FLG_CONSTTIME) != 0)\\r\\n|| (BN_get_flags(divisor, BN_FLG_CONSTTIME) != 0)) {\\r\\nno_branch = 1;\\r\\n}\\r\\nbn_check_top(dv);\\r\\nbn_check_top(rm);\\r\\nif (BN_is_zero(divisor)) {\\r\\nBNerr(BN_F_BN_DIV, BN_R_DIV_BY_ZERO);\\r\\nreturn (0);\\r\\n}\\r\\nif (!no_branch && BN_ucmp(num, divisor) < 0) {\\r\\nif (rm != NULL) {\\r\\nif (BN_copy(rm, num) == NULL)\\r\\nreturn (0);\\r\\n}\\r\\nif (dv != NULL)\\r\\nBN_zero(dv);\\r\\nreturn (1);\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nsnum = BN_CTX_get(ctx);\\r\\nsdiv = BN_CTX_get(ctx);\\r\\nif (dv == NULL)\\r\\nres = BN_CTX_get(ctx);\\r\\nelse\\r\\nres = dv;\\r\\nif (sdiv == NULL || res == NULL || tmp == NULL || snum == NULL)\\r\\ngoto err;\\r\\nnorm_shift = BN_BITS2 - ((BN_num_bits(divisor)) % BN_BITS2);\\r\\nif (!(BN_lshift(sdiv, divisor, norm_shift)))\\r\\ngoto err;\\r\\nsdiv->neg = 0;\\r\\nnorm_shift += BN_BITS2;\\r\\nif (!(BN_lshift(snum, num, norm_shift)))\\r\\ngoto err;\\r\\nsnum->neg = 0;\\r\\nif (no_branch) {\\r\\nif (snum->top <= sdiv->top + 1) {\\r\\nif (bn_wexpand(snum, sdiv->top + 2) == NULL)\\r\\ngoto err;\\r\\nfor (i = snum->top; i < sdiv->top + 2; i++)\\r\\nsnum->d[i] = 0;\\r\\nsnum->top = sdiv->top + 2;\\r\\n} else {\\r\\nif (bn_wexpand(snum, snum->top + 1) == NULL)\\r\\ngoto err;\\r\\nsnum->d[snum->top] = 0;\\r\\nsnum->top++;\\r\\n}\\r\\n}\\r\\ndiv_n = sdiv->top;\\r\\nnum_n = snum->top;\\r\\nloop = num_n - div_n;\\r\\nwnum.neg = 0;\\r\\nwnum.d = &(snum->d[loop]);\\r\\nwnum.top = div_n;\\r\\nwnum.dmax = snum->dmax - loop;\\r\\nd0 = sdiv->d[div_n - 1];\\r\\nd1 = (div_n == 1) ? 0 : sdiv->d[div_n - 2];\\r\\nwnump = &(snum->d[num_n - 1]);\\r\\nres->neg = (num->neg ^ divisor->neg);\\r\\nif (!bn_wexpand(res, (loop + 1)))\\r\\ngoto err;\\r\\nres->top = loop - no_branch;\\r\\nresp = &(res->d[loop - 1]);\\r\\nif (!bn_wexpand(tmp, (div_n + 1)))\\r\\ngoto err;\\r\\nif (!no_branch) {\\r\\nif (BN_ucmp(&wnum, sdiv) >= 0) {\\r\\nbn_clear_top2max(&wnum);\\r\\nbn_sub_words(wnum.d, wnum.d, sdiv->d, div_n);\\r\\n*resp = 1;\\r\\n} else\\r\\nres->top--;\\r\\n}\\r\\nif (res->top == 0)\\r\\nres->neg = 0;\\r\\nelse\\r\\nresp--;\\r\\nfor (i = 0; i < loop - 1; i++, wnump--, resp--) {\\r\\nBN_ULONG q, l0;\\r\\n# if defined(BN_DIV3W) && !defined(OPENSSL_NO_ASM)\\r\\nBN_ULONG bn_div_3_words(BN_ULONG *, BN_ULONG, BN_ULONG);\\r\\nq = bn_div_3_words(wnump, d1, d0);\\r\\n# else\\r\\nBN_ULONG n0, n1, rem = 0;\\r\\nn0 = wnump[0];\\r\\nn1 = wnump[-1];\\r\\nif (n0 == d0)\\r\\nq = BN_MASK2;\\r\\nelse {\\r\\n# ifdef BN_LLONG\\r\\nBN_ULLONG t2;\\r\\n# if defined(BN_LLONG) && defined(BN_DIV2W) && !defined(bn_div_words)\\r\\nq = (BN_ULONG)(((((BN_ULLONG) n0) << BN_BITS2) | n1) / d0);\\r\\n# else\\r\\nq = bn_div_words(n0, n1, d0);\\r\\n# ifdef BN_DEBUG_LEVITTE\\r\\nfprintf(stderr, \"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\\\\r\\nX) -> 0x%08X\\n\", n0, n1, d0, q);\\r\\n# endif\\r\\n# endif\\r\\n# ifndef REMAINDER_IS_ALREADY_CALCULATED\\r\\nrem = (n1 - q * d0) & BN_MASK2;\\r\\n# endif\\r\\nt2 = (BN_ULLONG) d1 *q;\\r\\nfor (;;) {\\r\\nif (t2 <= ((((BN_ULLONG) rem) << BN_BITS2) | wnump[-2]))\\r\\nbreak;\\r\\nq--;\\r\\nrem += d0;\\r\\nif (rem < d0)\\r\\nbreak;\\r\\nt2 -= d1;\\r\\n}\\r\\n# else\\r\\nBN_ULONG t2l, t2h;\\r\\nq = bn_div_words(n0, n1, d0);\\r\\n# ifdef BN_DEBUG_LEVITTE\\r\\nfprintf(stderr, \"DEBUG: bn_div_words(0x%08X,0x%08X,0x%08\\\\r\\nX) -> 0x%08X\\n\", n0, n1, d0, q);\\r\\n# endif\\r\\n# ifndef REMAINDER_IS_ALREADY_CALCULATED\\r\\nrem = (n1 - q * d0) & BN_MASK2;\\r\\n# endif\\r\\n# if defined(BN_UMULT_LOHI)\\r\\nBN_UMULT_LOHI(t2l, t2h, d1, q);\\r\\n# elif defined(BN_UMULT_HIGH)\\r\\nt2l = d1 * q;\\r\\nt2h = BN_UMULT_HIGH(d1, q);\\r\\n# else\\r\\n{\\r\\nBN_ULONG ql, qh;\\r\\nt2l = LBITS(d1);\\r\\nt2h = HBITS(d1);\\r\\nql = LBITS(q);\\r\\nqh = HBITS(q);\\r\\nmul64(t2l, t2h, ql, qh);\\r\\n}\\r\\n# endif\\r\\nfor (;;) {\\r\\nif ((t2h < rem) || ((t2h == rem) && (t2l <= wnump[-2])))\\r\\nbreak;\\r\\nq--;\\r\\nrem += d0;\\r\\nif (rem < d0)\\r\\nbreak;\\r\\nif (t2l < d1)\\r\\nt2h--;\\r\\nt2l -= d1;\\r\\n}\\r\\n# endif\\r\\n}\\r\\n# endif\\r\\nl0 = bn_mul_words(tmp->d, sdiv->d, div_n, q);\\r\\ntmp->d[div_n] = l0;\\r\\nwnum.d--;\\r\\nif (bn_sub_words(wnum.d, wnum.d, tmp->d, div_n + 1)) {\\r\\nq--;\\r\\nif (bn_add_words(wnum.d, wnum.d, sdiv->d, div_n))\\r\\n(*wnump)++;\\r\\n}\\r\\n*resp = q;\\r\\n}\\r\\nbn_correct_top(snum);\\r\\nif (rm != NULL) {\\r\\nint neg = num->neg;\\r\\nBN_rshift(rm, snum, norm_shift);\\r\\nif (!BN_is_zero(rm))\\r\\nrm->neg = neg;\\r\\nbn_check_top(rm);\\r\\n}\\r\\nif (no_branch)\\r\\nbn_correct_top(res);\\r\\nBN_CTX_end(ctx);\\r\\nreturn (1);\\r\\nerr:\\r\\nbn_check_top(rm);\\r\\nBN_CTX_end(ctx);\\r\\nreturn (0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_long_c", "target": 0, "func": "static void long_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\n*(long *)pval = it->size;\\r\\n}\\r\\nstatic int long_i2c(ASN1_VALUE **pval, unsigned char *cont, int *putype, const ASN1_ITEM *it)\\r\\n{\\r\\nlong ltmp;\\r\\nunsigned long utmp;\\r\\nint clen, pad, i;\\r\\nchar *cp = (char *)pval;\\r\\nmemcpy(&ltmp, cp, sizeof(long));\\r\\nif(ltmp == it->size) return -1;\\r\\nif(ltmp < 0) utmp = -ltmp - 1;\\r\\nelse utmp = ltmp;\\r\\nclen = BN_num_bits_word(utmp);\\r\\nif(!(clen & 0x7)) pad = 1;\\r\\nelse pad = 0;\\r\\nclen = (clen + 7) >> 3;\\r\\nif(cont) {\\r\\nif(pad) *cont++ = (ltmp < 0) ? 0xff : 0;\\r\\nfor(i = clen - 1; i >= 0; i--) {\\r\\ncont[i] = (unsigned char)(utmp & 0xff);\\r\\nif(ltmp < 0) cont[i] ^= 0xff;\\r\\nutmp >>= 8;\\r\\n}\\r\\n}\\r\\nreturn clen + pad;\\r\\n}\\r\\nstatic int long_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,\\r\\nint utype, char *free_cont, const ASN1_ITEM *it)\\r\\n{\\r\\nint neg, i;\\r\\nlong ltmp;\\r\\nunsigned long utmp = 0;\\r\\nchar *cp = (char *)pval;\\r\\nif(len > (int)sizeof(long)) {\\r\\nASN1err(ASN1_F_LONG_C2I, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nif(len && (cont[0] & 0x80)) neg = 1;\\r\\nelse neg = 0;\\r\\nutmp = 0;\\r\\nfor(i = 0; i < len; i++) {\\r\\nutmp <<= 8;\\r\\nif(neg) utmp |= cont[i] ^ 0xff;\\r\\nelse utmp |= cont[i];\\r\\n}\\r\\nltmp = (long)utmp;\\r\\nif(neg) {\\r\\nltmp++;\\r\\nltmp = -ltmp;\\r\\n}\\r\\nif(ltmp == it->size) {\\r\\nASN1err(ASN1_F_LONG_C2I, ASN1_R_INTEGER_TOO_LARGE_FOR_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(cp, &ltmp, sizeof(long));\\r\\nreturn 1;\\r\\n}\\r\\nstatic int long_print(BIO *out, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nint indent, const ASN1_PCTX *pctx)\\r\\n{\\r\\nreturn BIO_printf(out, \"%ld\\n\", *(long *)pval);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_aes_ige_c", "target": 0, "func": "void AES_ige_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const AES_KEY *key,\\r\\nunsigned char *ivec, const int enc)\\r\\n{\\r\\nsize_t n;\\r\\nsize_t len = length;\\r\\nOPENSSL_assert(in && out && key && ivec);\\r\\nOPENSSL_assert((AES_ENCRYPT == enc) || (AES_DECRYPT == enc));\\r\\nOPENSSL_assert((length % AES_BLOCK_SIZE) == 0);\\r\\nlen = length / AES_BLOCK_SIZE;\\r\\nif (AES_ENCRYPT == enc) {\\r\\nif (in != out &&\\r\\n(UNALIGNED_MEMOPS_ARE_FAST\\r\\n|| ((size_t)in | (size_t)out | (size_t)ivec) % sizeof(long) ==\\r\\n0)) {\\r\\naes_block_t *ivp = (aes_block_t *) ivec;\\r\\naes_block_t *iv2p = (aes_block_t *) (ivec + AES_BLOCK_SIZE);\\r\\nwhile (len) {\\r\\naes_block_t *inp = (aes_block_t *) in;\\r\\naes_block_t *outp = (aes_block_t *) out;\\r\\nfor (n = 0; n < N_WORDS; ++n)\\r\\noutp->data[n] = inp->data[n] ^ ivp->data[n];\\r\\nAES_encrypt((unsigned char *)outp->data,\\r\\n(unsigned char *)outp->data, key);\\r\\nfor (n = 0; n < N_WORDS; ++n)\\r\\noutp->data[n] ^= iv2p->data[n];\\r\\nivp = outp;\\r\\niv2p = inp;\\r\\n--len;\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\n}\\r\\nmemcpy(ivec, ivp->data, AES_BLOCK_SIZE);\\r\\nmemcpy(ivec + AES_BLOCK_SIZE, iv2p->data, AES_BLOCK_SIZE);\\r\\n} else {\\r\\naes_block_t tmp, tmp2;\\r\\naes_block_t iv;\\r\\naes_block_t iv2;\\r\\nload_block(iv, ivec);\\r\\nload_block(iv2, ivec + AES_BLOCK_SIZE);\\r\\nwhile (len) {\\r\\nload_block(tmp, in);\\r\\nfor (n = 0; n < N_WORDS; ++n)\\r\\ntmp2.data[n] = tmp.data[n] ^ iv.data[n];\\r\\nAES_encrypt((unsigned char *)tmp2.data,\\r\\n(unsigned char *)tmp2.data, key);\\r\\nfor (n = 0; n < N_WORDS; ++n)\\r\\ntmp2.data[n] ^= iv2.data[n];\\r\\nstore_block(out, tmp2);\\r\\niv = tmp2;\\r\\niv2 = tmp;\\r\\n--len;\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\n}\\r\\nmemcpy(ivec, iv.data, AES_BLOCK_SIZE);\\r\\nmemcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);\\r\\n}\\r\\n} else {\\r\\nif (in != out &&\\r\\n(UNALIGNED_MEMOPS_ARE_FAST\\r\\n|| ((size_t)in | (size_t)out | (size_t)ivec) % sizeof(long) ==\\r\\n0)) {\\r\\naes_block_t *ivp = (aes_block_t *) ivec;\\r\\naes_block_t *iv2p = (aes_block_t *) (ivec + AES_BLOCK_SIZE);\\r\\nwhile (len) {\\r\\naes_block_t tmp;\\r\\naes_block_t *inp = (aes_block_t *) in;\\r\\naes_block_t *outp = (aes_block_t *) out;\\r\\nfor (n = 0; n < N_WORDS; ++n)\\r\\ntmp.data[n] = inp->data[n] ^ iv2p->data[n];\\r\\nAES_decrypt((unsigned char *)tmp.data,\\r\\n(unsigned char *)outp->data, key);\\r\\nfor (n = 0; n < N_WORDS; ++n)\\r\\noutp->data[n] ^= ivp->data[n];\\r\\nivp = inp;\\r\\niv2p = outp;\\r\\n--len;\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\n}\\r\\nmemcpy(ivec, ivp->data, AES_BLOCK_SIZE);\\r\\nmemcpy(ivec + AES_BLOCK_SIZE, iv2p->data, AES_BLOCK_SIZE);\\r\\n} else {\\r\\naes_block_t tmp, tmp2;\\r\\naes_block_t iv;\\r\\naes_block_t iv2;\\r\\nload_block(iv, ivec);\\r\\nload_block(iv2, ivec + AES_BLOCK_SIZE);\\r\\nwhile (len) {\\r\\nload_block(tmp, in);\\r\\ntmp2 = tmp;\\r\\nfor (n = 0; n < N_WORDS; ++n)\\r\\ntmp.data[n] ^= iv2.data[n];\\r\\nAES_decrypt((unsigned char *)tmp.data,\\r\\n(unsigned char *)tmp.data, key);\\r\\nfor (n = 0; n < N_WORDS; ++n)\\r\\ntmp.data[n] ^= iv.data[n];\\r\\nstore_block(out, tmp);\\r\\niv = tmp2;\\r\\niv2 = tmp;\\r\\n--len;\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\n}\\r\\nmemcpy(ivec, iv.data, AES_BLOCK_SIZE);\\r\\nmemcpy(ivec + AES_BLOCK_SIZE, iv2.data, AES_BLOCK_SIZE);\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid AES_bi_ige_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const AES_KEY *key,\\r\\nconst AES_KEY *key2, const unsigned char *ivec,\\r\\nconst int enc)\\r\\n{\\r\\nsize_t n;\\r\\nsize_t len = length;\\r\\nunsigned char tmp[AES_BLOCK_SIZE];\\r\\nunsigned char tmp2[AES_BLOCK_SIZE];\\r\\nunsigned char tmp3[AES_BLOCK_SIZE];\\r\\nunsigned char prev[AES_BLOCK_SIZE];\\r\\nconst unsigned char *iv;\\r\\nconst unsigned char *iv2;\\r\\nOPENSSL_assert(in && out && key && ivec);\\r\\nOPENSSL_assert((AES_ENCRYPT == enc) || (AES_DECRYPT == enc));\\r\\nOPENSSL_assert((length % AES_BLOCK_SIZE) == 0);\\r\\nif (AES_ENCRYPT == enc) {\\r\\niv = ivec;\\r\\niv2 = ivec + AES_BLOCK_SIZE;\\r\\nwhile (len >= AES_BLOCK_SIZE) {\\r\\nfor (n = 0; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] = in[n] ^ iv[n];\\r\\nAES_encrypt(out, out, key);\\r\\nfor (n = 0; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] ^= iv2[n];\\r\\niv = out;\\r\\nmemcpy(prev, in, AES_BLOCK_SIZE);\\r\\niv2 = prev;\\r\\nlen -= AES_BLOCK_SIZE;\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\n}\\r\\niv = ivec + AES_BLOCK_SIZE * 2;\\r\\niv2 = ivec + AES_BLOCK_SIZE * 3;\\r\\nlen = length;\\r\\nwhile (len >= AES_BLOCK_SIZE) {\\r\\nout -= AES_BLOCK_SIZE;\\r\\nmemcpy(tmp, out, AES_BLOCK_SIZE);\\r\\nfor (n = 0; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] ^= iv[n];\\r\\nAES_encrypt(out, out, key);\\r\\nfor (n = 0; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] ^= iv2[n];\\r\\niv = out;\\r\\nmemcpy(prev, tmp, AES_BLOCK_SIZE);\\r\\niv2 = prev;\\r\\nlen -= AES_BLOCK_SIZE;\\r\\n}\\r\\n} else {\\r\\niv = ivec + AES_BLOCK_SIZE * 2;\\r\\niv2 = ivec + AES_BLOCK_SIZE * 3;\\r\\nin += length;\\r\\nout += length;\\r\\nwhile (len >= AES_BLOCK_SIZE) {\\r\\nin -= AES_BLOCK_SIZE;\\r\\nout -= AES_BLOCK_SIZE;\\r\\nmemcpy(tmp, in, AES_BLOCK_SIZE);\\r\\nmemcpy(tmp2, in, AES_BLOCK_SIZE);\\r\\nfor (n = 0; n < AES_BLOCK_SIZE; ++n)\\r\\ntmp[n] ^= iv2[n];\\r\\nAES_decrypt(tmp, out, key);\\r\\nfor (n = 0; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] ^= iv[n];\\r\\nmemcpy(tmp3, tmp2, AES_BLOCK_SIZE);\\r\\niv = tmp3;\\r\\niv2 = out;\\r\\nlen -= AES_BLOCK_SIZE;\\r\\n}\\r\\niv = ivec;\\r\\niv2 = ivec + AES_BLOCK_SIZE;\\r\\nlen = length;\\r\\nwhile (len >= AES_BLOCK_SIZE) {\\r\\nmemcpy(tmp, out, AES_BLOCK_SIZE);\\r\\nmemcpy(tmp2, out, AES_BLOCK_SIZE);\\r\\nfor (n = 0; n < AES_BLOCK_SIZE; ++n)\\r\\ntmp[n] ^= iv2[n];\\r\\nAES_decrypt(tmp, out, key);\\r\\nfor (n = 0; n < AES_BLOCK_SIZE; ++n)\\r\\nout[n] ^= iv[n];\\r\\nmemcpy(tmp3, tmp2, AES_BLOCK_SIZE);\\r\\niv = tmp3;\\r\\niv2 = out;\\r\\nlen -= AES_BLOCK_SIZE;\\r\\nin += AES_BLOCK_SIZE;\\r\\nout += AES_BLOCK_SIZE;\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509rset_c", "target": 0, "func": "int X509_REQ_set_version(X509_REQ *x, long version)\\r\\n{\\r\\nif (x == NULL)\\r\\nreturn (0);\\r\\nreturn (ASN1_INTEGER_set(x->req_info->version, version));\\r\\n}\\r\\nint X509_REQ_set_subject_name(X509_REQ *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->req_info == NULL))\\r\\nreturn (0);\\r\\nreturn (X509_NAME_set(&x->req_info->subject, name));\\r\\n}\\r\\nint X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey)\\r\\n{\\r\\nif ((x == NULL) || (x->req_info == NULL))\\r\\nreturn (0);\\r\\nreturn (X509_PUBKEY_set(&x->req_info->pubkey, pkey));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc5_ecb_c", "target": 0, "func": "void RC5_32_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nRC5_32_KEY *ks, int encrypt)\\r\\n{\\r\\nunsigned long l, d[2];\\r\\nc2l(in, l);\\r\\nd[0] = l;\\r\\nc2l(in, l);\\r\\nd[1] = l;\\r\\nif (encrypt)\\r\\nRC5_32_encrypt(d, ks);\\r\\nelse\\r\\nRC5_32_decrypt(d, ks);\\r\\nl = d[0];\\r\\nl2c(l, out);\\r\\nl = d[1];\\r\\nl2c(l, out);\\r\\nl = d[0] = d[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p_seal_c", "target": 0, "func": "int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\\r\\nunsigned char **ek, int *ekl, unsigned char *iv,\\r\\nEVP_PKEY **pubk, int npubk)\\r\\n{\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nint i;\\r\\nif (type) {\\r\\nEVP_CIPHER_CTX_init(ctx);\\r\\nif (!EVP_EncryptInit_ex(ctx, type, NULL, NULL, NULL))\\r\\nreturn 0;\\r\\n}\\r\\nif ((npubk <= 0) || !pubk)\\r\\nreturn 1;\\r\\nif (EVP_CIPHER_CTX_rand_key(ctx, key) <= 0)\\r\\nreturn 0;\\r\\nif (EVP_CIPHER_CTX_iv_length(ctx))\\r\\nRAND_pseudo_bytes(iv, EVP_CIPHER_CTX_iv_length(ctx));\\r\\nif (!EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv))\\r\\nreturn 0;\\r\\nfor (i = 0; i < npubk; i++) {\\r\\nekl[i] =\\r\\nEVP_PKEY_encrypt_old(ek[i], key, EVP_CIPHER_CTX_key_length(ctx),\\r\\npubk[i]);\\r\\nif (ekl[i] <= 0)\\r\\nreturn (-1);\\r\\n}\\r\\nreturn (npubk);\\r\\n}\\r\\nint EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i;\\r\\ni = EVP_EncryptFinal_ex(ctx, out, outl);\\r\\nif (i)\\r\\ni = EVP_EncryptInit_ex(ctx, NULL, NULL, NULL, NULL);\\r\\nreturn i;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_time_c", "target": 0, "func": "ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t)\\r\\n{\\r\\nreturn ASN1_TIME_adj(s, t, 0, 0);\\r\\n}\\r\\nASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t,\\r\\nint offset_day, long offset_sec)\\r\\n{\\r\\nstruct tm *ts;\\r\\nstruct tm data;\\r\\nts = OPENSSL_gmtime(&t, &data);\\r\\nif (ts == NULL) {\\r\\nASN1err(ASN1_F_ASN1_TIME_ADJ, ASN1_R_ERROR_GETTING_TIME);\\r\\nreturn NULL;\\r\\n}\\r\\nif (offset_day || offset_sec) {\\r\\nif (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))\\r\\nreturn NULL;\\r\\n}\\r\\nif ((ts->tm_year >= 50) && (ts->tm_year < 150))\\r\\nreturn ASN1_UTCTIME_adj(s, t, offset_day, offset_sec);\\r\\nreturn ASN1_GENERALIZEDTIME_adj(s, t, offset_day, offset_sec);\\r\\n}\\r\\nint ASN1_TIME_check(ASN1_TIME *t)\\r\\n{\\r\\nif (t->type == V_ASN1_GENERALIZEDTIME)\\r\\nreturn ASN1_GENERALIZEDTIME_check(t);\\r\\nelse if (t->type == V_ASN1_UTCTIME)\\r\\nreturn ASN1_UTCTIME_check(t);\\r\\nreturn 0;\\r\\n}\\r\\nASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t,\\r\\nASN1_GENERALIZEDTIME **out)\\r\\n{\\r\\nASN1_GENERALIZEDTIME *ret;\\r\\nchar *str;\\r\\nint newlen;\\r\\nif (!ASN1_TIME_check(t))\\r\\nreturn NULL;\\r\\nif (!out || !*out) {\\r\\nif (!(ret = ASN1_GENERALIZEDTIME_new()))\\r\\nreturn NULL;\\r\\nif (out)\\r\\n*out = ret;\\r\\n} else\\r\\nret = *out;\\r\\nif (t->type == V_ASN1_GENERALIZEDTIME) {\\r\\nif (!ASN1_STRING_set(ret, t->data, t->length))\\r\\nreturn NULL;\\r\\nreturn ret;\\r\\n}\\r\\nif (!ASN1_STRING_set(ret, NULL, t->length + 2))\\r\\nreturn NULL;\\r\\nnewlen = t->length + 2 + 1;\\r\\nstr = (char *)ret->data;\\r\\nif (t->data[0] >= '5')\\r\\nBUF_strlcpy(str, \"19\", newlen);\\r\\nelse\\r\\nBUF_strlcpy(str, \"20\", newlen);\\r\\nBUF_strlcat(str, (char *)t->data, newlen);\\r\\nreturn ret;\\r\\n}\\r\\nint ASN1_TIME_set_string(ASN1_TIME *s, const char *str)\\r\\n{\\r\\nASN1_TIME t;\\r\\nt.length = strlen(str);\\r\\nt.data = (unsigned char *)str;\\r\\nt.flags = 0;\\r\\nt.type = V_ASN1_UTCTIME;\\r\\nif (!ASN1_TIME_check(&t)) {\\r\\nt.type = V_ASN1_GENERALIZEDTIME;\\r\\nif (!ASN1_TIME_check(&t))\\r\\nreturn 0;\\r\\n}\\r\\nif (s && !ASN1_STRING_copy((ASN1_STRING *)s, (ASN1_STRING *)&t))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int asn1_time_to_tm(struct tm *tm, const ASN1_TIME *t)\\r\\n{\\r\\nif (t == NULL) {\\r\\ntime_t now_t;\\r\\ntime(&now_t);\\r\\nif (OPENSSL_gmtime(&now_t, tm))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nif (t->type == V_ASN1_UTCTIME)\\r\\nreturn asn1_utctime_to_tm(tm, t);\\r\\nelse if (t->type == V_ASN1_GENERALIZEDTIME)\\r\\nreturn asn1_generalizedtime_to_tm(tm, t);\\r\\nreturn 0;\\r\\n}\\r\\nint ASN1_TIME_diff(int *pday, int *psec,\\r\\nconst ASN1_TIME *from, const ASN1_TIME *to)\\r\\n{\\r\\nstruct tm tm_from, tm_to;\\r\\nif (!asn1_time_to_tm(&tm_from, from))\\r\\nreturn 0;\\r\\nif (!asn1_time_to_tm(&tm_to, to))\\r\\nreturn 0;\\r\\nreturn OPENSSL_gmtime_diff(pday, psec, &tm_from, &tm_to);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_conf_lib_c", "target": 0, "func": "int CONF_set_default_method(CONF_METHOD *meth)\\r\\n{\\r\\ndefault_CONF_method = meth;\\r\\nreturn 1;\\r\\n}\\r\\nCONF *NCONF_new(CONF_METHOD *meth)\\r\\n{\\r\\nCONF *ret;\\r\\nif (meth == NULL)\\r\\nmeth = NCONF_default();\\r\\nret = meth->create(meth);\\r\\nif (ret == NULL) {\\r\\nCONFerr(CONF_F_NCONF_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid NCONF_free(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn;\\r\\nconf->meth->destroy(conf);\\r\\n}\\r\\nvoid NCONF_free_data(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn;\\r\\nconf->meth->destroy_data(conf);\\r\\n}\\r\\nint NCONF_load(CONF *conf, const char *file, long *eline)\\r\\n{\\r\\nif (conf == NULL) {\\r\\nCONFerr(CONF_F_NCONF_LOAD, CONF_R_NO_CONF);\\r\\nreturn 0;\\r\\n}\\r\\nreturn conf->meth->load(conf, file, eline);\\r\\n}\\r\\nint NCONF_load_fp(CONF *conf, FILE *fp, long *eline)\\r\\n{\\r\\nBIO *btmp;\\r\\nint ret;\\r\\nif (!(btmp = BIO_new_fp(fp, BIO_NOCLOSE))) {\\r\\nCONFerr(CONF_F_NCONF_LOAD_FP, ERR_R_BUF_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret = NCONF_load_bio(conf, btmp, eline);\\r\\nBIO_free(btmp);\\r\\nreturn ret;\\r\\n}\\r\\nint NCONF_load_bio(CONF *conf, BIO *bp, long *eline)\\r\\n{\\r\\nif (conf == NULL) {\\r\\nCONFerr(CONF_F_NCONF_LOAD_BIO, CONF_R_NO_CONF);\\r\\nreturn 0;\\r\\n}\\r\\nreturn conf->meth->load_bio(conf, bp, eline);\\r\\n}\\r\\nint NCONF_dump_fp(const CONF *conf, FILE *out)\\r\\n{\\r\\nBIO *btmp;\\r\\nint ret;\\r\\nif (!(btmp = BIO_new_fp(out, BIO_NOCLOSE))) {\\r\\nCONFerr(CONF_F_NCONF_DUMP_FP, ERR_R_BUF_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret = NCONF_dump_bio(conf, btmp);\\r\\nBIO_free(btmp);\\r\\nreturn ret;\\r\\n}\\r\\nint NCONF_dump_bio(const CONF *conf, BIO *out)\\r\\n{\\r\\nif (conf == NULL) {\\r\\nCONFerr(CONF_F_NCONF_DUMP_BIO, CONF_R_NO_CONF);\\r\\nreturn 0;\\r\\n}\\r\\nreturn conf->meth->dump(conf, out);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nint ret = 1;\\r\\nDSA *dsa = NULL;\\r\\nint i, badops = 0;\\r\\nconst EVP_CIPHER *enc = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat, text = 0, noout = 0;\\r\\nint pubin = 0, pubout = 0;\\r\\nchar *infile, *outfile, *prog;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine;\\r\\n# endif\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\nint modulus = 0;\\r\\nint pvk_encr = 2;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nengine = NULL;\\r\\n# endif\\r\\ninfile = NULL;\\r\\noutfile = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passin\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passout\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargout = *(++argv);\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n# endif\\r\\nelse if (strcmp(*argv, \"-pvk-strong\") == 0)\\r\\npvk_encr = 2;\\r\\nelse if (strcmp(*argv, \"-pvk-weak\") == 0)\\r\\npvk_encr = 1;\\r\\nelse if (strcmp(*argv, \"-pvk-none\") == 0)\\r\\npvk_encr = 0;\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv, \"-modulus\") == 0)\\r\\nmodulus = 1;\\r\\nelse if (strcmp(*argv, \"-pubin\") == 0)\\r\\npubin = 1;\\r\\nelse if (strcmp(*argv, \"-pubout\") == 0)\\r\\npubout = 1;\\r\\nelse if ((enc = EVP_get_cipherbyname(&(argv[0][1]))) == NULL) {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile >outfile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -outform arg output format - DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -passout arg output file pass phrase source\\n\");\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\" -engine e use engine e, possibly a hardware device.\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err,\\r\\n\" -des encrypt PEM output with cbc des\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" -des3 encrypt PEM output with ede cbc des using 168 bit key\\n\");\\r\\n# ifndef OPENSSL_NO_IDEA\\r\\nBIO_printf(bio_err,\\r\\n\" -idea encrypt PEM output with cbc idea\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_AES\\r\\nBIO_printf(bio_err, \" -aes128, -aes192, -aes256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc aes\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_CAMELLIA\\r\\nBIO_printf(bio_err, \" -camellia128, -camellia192, -camellia256\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\" encrypt PEM output with cbc camellia\\n\");\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_SEED\\r\\nBIO_printf(bio_err,\\r\\n\" -seed encrypt PEM output with cbc seed\\n\");\\r\\n# endif\\r\\nBIO_printf(bio_err, \" -text print the key in text\\n\");\\r\\nBIO_printf(bio_err, \" -noout don't print key out\\n\");\\r\\nBIO_printf(bio_err, \" -modulus print the DSA public value\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err, \"read DSA key\\n\");\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nif (pubin)\\r\\npkey = load_pubkey(bio_err, infile, informat, 1,\\r\\npassin, e, \"Public Key\");\\r\\nelse\\r\\npkey = load_key(bio_err, infile, informat, 1,\\r\\npassin, e, \"Private Key\");\\r\\nif (pkey) {\\r\\ndsa = EVP_PKEY_get1_DSA(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\n}\\r\\nif (dsa == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load Key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text)\\r\\nif (!DSA_print(out, dsa, 0)) {\\r\\nperror(outfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (modulus) {\\r\\nfprintf(stdout, \"Public Key=\");\\r\\nBN_print(out, dsa->pub_key);\\r\\nfprintf(stdout, \"\\n\");\\r\\n}\\r\\nif (noout)\\r\\ngoto end;\\r\\nBIO_printf(bio_err, \"writing DSA key\\n\");\\r\\nif (outformat == FORMAT_ASN1) {\\r\\nif (pubin || pubout)\\r\\ni = i2d_DSA_PUBKEY_bio(out, dsa);\\r\\nelse\\r\\ni = i2d_DSAPrivateKey_bio(out, dsa);\\r\\n} else if (outformat == FORMAT_PEM) {\\r\\nif (pubin || pubout)\\r\\ni = PEM_write_bio_DSA_PUBKEY(out, dsa);\\r\\nelse\\r\\ni = PEM_write_bio_DSAPrivateKey(out, dsa, enc,\\r\\nNULL, 0, NULL, passout);\\r\\n# if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_RC4)\\r\\n} else if (outformat == FORMAT_MSBLOB || outformat == FORMAT_PVK) {\\r\\nEVP_PKEY *pk;\\r\\npk = EVP_PKEY_new();\\r\\nEVP_PKEY_set1_DSA(pk, dsa);\\r\\nif (outformat == FORMAT_PVK)\\r\\ni = i2b_PVK_bio(out, pk, pvk_encr, 0, passout);\\r\\nelse if (pubin || pubout)\\r\\ni = i2b_PublicKey_bio(out, pk);\\r\\nelse\\r\\ni = i2b_PrivateKey_bio(out, pk);\\r\\nEVP_PKEY_free(pk);\\r\\n# endif\\r\\n} else {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (i <= 0) {\\r\\nBIO_printf(bio_err, \"unable to write private key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n} else\\r\\nret = 0;\\r\\nend:\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (dsa != NULL)\\r\\nDSA_free(dsa);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_srp_lib_c", "target": 0, "func": "static BIGNUM *srp_Calc_k(BIGNUM *N, BIGNUM *g)\\r\\n{\\r\\nunsigned char digest[SHA_DIGEST_LENGTH];\\r\\nunsigned char *tmp;\\r\\nEVP_MD_CTX ctxt;\\r\\nint longg;\\r\\nint longN = BN_num_bytes(N);\\r\\nif (BN_ucmp(g, N) >= 0)\\r\\nreturn NULL;\\r\\nif ((tmp = OPENSSL_malloc(longN)) == NULL)\\r\\nreturn NULL;\\r\\nBN_bn2bin(N, tmp);\\r\\nEVP_MD_CTX_init(&ctxt);\\r\\nEVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);\\r\\nEVP_DigestUpdate(&ctxt, tmp, longN);\\r\\nmemset(tmp, 0, longN);\\r\\nlongg = BN_bn2bin(g, tmp);\\r\\nEVP_DigestUpdate(&ctxt, tmp + longg, longN - longg);\\r\\nEVP_DigestUpdate(&ctxt, tmp, longg);\\r\\nOPENSSL_free(tmp);\\r\\nEVP_DigestFinal_ex(&ctxt, digest, NULL);\\r\\nEVP_MD_CTX_cleanup(&ctxt);\\r\\nreturn BN_bin2bn(digest, sizeof(digest), NULL);\\r\\n}\\r\\nBIGNUM *SRP_Calc_u(BIGNUM *A, BIGNUM *B, BIGNUM *N)\\r\\n{\\r\\nBIGNUM *u;\\r\\nunsigned char cu[SHA_DIGEST_LENGTH];\\r\\nunsigned char *cAB;\\r\\nEVP_MD_CTX ctxt;\\r\\nint longN;\\r\\nif ((A == NULL) || (B == NULL) || (N == NULL))\\r\\nreturn NULL;\\r\\nif (BN_ucmp(A, N) >= 0 || BN_ucmp(B, N) >= 0)\\r\\nreturn NULL;\\r\\nlongN = BN_num_bytes(N);\\r\\nif ((cAB = OPENSSL_malloc(2 * longN)) == NULL)\\r\\nreturn NULL;\\r\\nmemset(cAB, 0, longN);\\r\\nEVP_MD_CTX_init(&ctxt);\\r\\nEVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);\\r\\nEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(A, cAB + longN), longN);\\r\\nEVP_DigestUpdate(&ctxt, cAB + BN_bn2bin(B, cAB + longN), longN);\\r\\nOPENSSL_free(cAB);\\r\\nEVP_DigestFinal_ex(&ctxt, cu, NULL);\\r\\nEVP_MD_CTX_cleanup(&ctxt);\\r\\nif (!(u = BN_bin2bn(cu, sizeof(cu), NULL)))\\r\\nreturn NULL;\\r\\nif (!BN_is_zero(u))\\r\\nreturn u;\\r\\nBN_free(u);\\r\\nreturn NULL;\\r\\n}\\r\\nBIGNUM *SRP_Calc_server_key(BIGNUM *A, BIGNUM *v, BIGNUM *u, BIGNUM *b,\\r\\nBIGNUM *N)\\r\\n{\\r\\nBIGNUM *tmp = NULL, *S = NULL;\\r\\nBN_CTX *bn_ctx;\\r\\nif (u == NULL || A == NULL || v == NULL || b == NULL || N == NULL)\\r\\nreturn NULL;\\r\\nif ((bn_ctx = BN_CTX_new()) == NULL ||\\r\\n(tmp = BN_new()) == NULL || (S = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_mod_exp(tmp, v, u, N, bn_ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(tmp, A, tmp, N, bn_ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_exp(S, tmp, b, N, bn_ctx))\\r\\ngoto err;\\r\\nerr:\\r\\nBN_CTX_free(bn_ctx);\\r\\nBN_clear_free(tmp);\\r\\nreturn S;\\r\\n}\\r\\nBIGNUM *SRP_Calc_B(BIGNUM *b, BIGNUM *N, BIGNUM *g, BIGNUM *v)\\r\\n{\\r\\nBIGNUM *kv = NULL, *gb = NULL;\\r\\nBIGNUM *B = NULL, *k = NULL;\\r\\nBN_CTX *bn_ctx;\\r\\nif (b == NULL || N == NULL || g == NULL || v == NULL ||\\r\\n(bn_ctx = BN_CTX_new()) == NULL)\\r\\nreturn NULL;\\r\\nif ((kv = BN_new()) == NULL ||\\r\\n(gb = BN_new()) == NULL || (B = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_mod_exp(gb, g, b, N, bn_ctx) ||\\r\\n!(k = srp_Calc_k(N, g)) ||\\r\\n!BN_mod_mul(kv, v, k, N, bn_ctx) ||\\r\\n!BN_mod_add(B, gb, kv, N, bn_ctx)) {\\r\\nBN_free(B);\\r\\nB = NULL;\\r\\n}\\r\\nerr:\\r\\nBN_CTX_free(bn_ctx);\\r\\nBN_clear_free(kv);\\r\\nBN_clear_free(gb);\\r\\nBN_free(k);\\r\\nreturn B;\\r\\n}\\r\\nBIGNUM *SRP_Calc_x(BIGNUM *s, const char *user, const char *pass)\\r\\n{\\r\\nunsigned char dig[SHA_DIGEST_LENGTH];\\r\\nEVP_MD_CTX ctxt;\\r\\nunsigned char *cs;\\r\\nif ((s == NULL) || (user == NULL) || (pass == NULL))\\r\\nreturn NULL;\\r\\nif ((cs = OPENSSL_malloc(BN_num_bytes(s))) == NULL)\\r\\nreturn NULL;\\r\\nEVP_MD_CTX_init(&ctxt);\\r\\nEVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);\\r\\nEVP_DigestUpdate(&ctxt, user, strlen(user));\\r\\nEVP_DigestUpdate(&ctxt, \":\", 1);\\r\\nEVP_DigestUpdate(&ctxt, pass, strlen(pass));\\r\\nEVP_DigestFinal_ex(&ctxt, dig, NULL);\\r\\nEVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL);\\r\\nBN_bn2bin(s, cs);\\r\\nEVP_DigestUpdate(&ctxt, cs, BN_num_bytes(s));\\r\\nOPENSSL_free(cs);\\r\\nEVP_DigestUpdate(&ctxt, dig, sizeof(dig));\\r\\nEVP_DigestFinal_ex(&ctxt, dig, NULL);\\r\\nEVP_MD_CTX_cleanup(&ctxt);\\r\\nreturn BN_bin2bn(dig, sizeof(dig), NULL);\\r\\n}\\r\\nBIGNUM *SRP_Calc_A(BIGNUM *a, BIGNUM *N, BIGNUM *g)\\r\\n{\\r\\nBN_CTX *bn_ctx;\\r\\nBIGNUM *A = NULL;\\r\\nif (a == NULL || N == NULL || g == NULL ||\\r\\n(bn_ctx = BN_CTX_new()) == NULL)\\r\\nreturn NULL;\\r\\nif ((A = BN_new()) != NULL && !BN_mod_exp(A, g, a, N, bn_ctx)) {\\r\\nBN_free(A);\\r\\nA = NULL;\\r\\n}\\r\\nBN_CTX_free(bn_ctx);\\r\\nreturn A;\\r\\n}\\r\\nBIGNUM *SRP_Calc_client_key(BIGNUM *N, BIGNUM *B, BIGNUM *g, BIGNUM *x,\\r\\nBIGNUM *a, BIGNUM *u)\\r\\n{\\r\\nBIGNUM *tmp = NULL, *tmp2 = NULL, *tmp3 = NULL, *k = NULL, *K = NULL;\\r\\nBN_CTX *bn_ctx;\\r\\nif (u == NULL || B == NULL || N == NULL || g == NULL || x == NULL\\r\\n|| a == NULL || (bn_ctx = BN_CTX_new()) == NULL)\\r\\nreturn NULL;\\r\\nif ((tmp = BN_new()) == NULL ||\\r\\n(tmp2 = BN_new()) == NULL ||\\r\\n(tmp3 = BN_new()) == NULL || (K = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_mod_exp(tmp, g, x, N, bn_ctx))\\r\\ngoto err;\\r\\nif (!(k = srp_Calc_k(N, g)))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(tmp2, tmp, k, N, bn_ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_sub(tmp, B, tmp2, N, bn_ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(tmp3, u, x, N, bn_ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_add(tmp2, a, tmp3, N, bn_ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_exp(K, tmp, tmp2, N, bn_ctx))\\r\\ngoto err;\\r\\nerr:\\r\\nBN_CTX_free(bn_ctx);\\r\\nBN_clear_free(tmp);\\r\\nBN_clear_free(tmp2);\\r\\nBN_clear_free(tmp3);\\r\\nBN_free(k);\\r\\nreturn K;\\r\\n}\\r\\nint SRP_Verify_B_mod_N(BIGNUM *B, BIGNUM *N)\\r\\n{\\r\\nBIGNUM *r;\\r\\nBN_CTX *bn_ctx;\\r\\nint ret = 0;\\r\\nif (B == NULL || N == NULL || (bn_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nif ((r = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BN_nnmod(r, B, N, bn_ctx))\\r\\ngoto err;\\r\\nret = !BN_is_zero(r);\\r\\nerr:\\r\\nBN_CTX_free(bn_ctx);\\r\\nBN_free(r);\\r\\nreturn ret;\\r\\n}\\r\\nint SRP_Verify_A_mod_N(BIGNUM *A, BIGNUM *N)\\r\\n{\\r\\nreturn SRP_Verify_B_mod_N(A, N);\\r\\n}\\r\\nchar *SRP_check_known_gN_param(BIGNUM *g, BIGNUM *N)\\r\\n{\\r\\nsize_t i;\\r\\nif ((g == NULL) || (N == NULL))\\r\\nreturn 0;\\r\\nsrp_bn_print(g);\\r\\nsrp_bn_print(N);\\r\\nfor (i = 0; i < KNOWN_GN_NUMBER; i++) {\\r\\nif (BN_cmp(knowngN[i].g, g) == 0 && BN_cmp(knowngN[i].N, N) == 0)\\r\\nreturn knowngN[i].id;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nSRP_gN *SRP_get_default_gN(const char *id)\\r\\n{\\r\\nsize_t i;\\r\\nif (id == NULL)\\r\\nreturn knowngN;\\r\\nfor (i = 0; i < KNOWN_GN_NUMBER; i++) {\\r\\nif (strcmp(knowngN[i].id, id) == 0)\\r\\nreturn knowngN + i;\\r\\n}\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecp_nistz256_c", "target": 0, "func": "static unsigned int _booth_recode_w5(unsigned int in)\\r\\n{\\r\\nunsigned int s, d;\\r\\ns = ~((in >> 5) - 1);\\r\\nd = (1 << 6) - in - 1;\\r\\nd = (d & s) | (in & ~s);\\r\\nd = (d >> 1) + (d & 1);\\r\\nreturn (d << 1) + (s & 1);\\r\\n}\\r\\nstatic unsigned int _booth_recode_w7(unsigned int in)\\r\\n{\\r\\nunsigned int s, d;\\r\\ns = ~((in >> 7) - 1);\\r\\nd = (1 << 8) - in - 1;\\r\\nd = (d & s) | (in & ~s);\\r\\nd = (d >> 1) + (d & 1);\\r\\nreturn (d << 1) + (s & 1);\\r\\n}\\r\\nstatic void copy_conditional(BN_ULONG dst[P256_LIMBS],\\r\\nconst BN_ULONG src[P256_LIMBS], BN_ULONG move)\\r\\n{\\r\\nBN_ULONG mask1 = -move;\\r\\nBN_ULONG mask2 = ~mask1;\\r\\ndst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\\r\\ndst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\\r\\ndst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\\r\\ndst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\\r\\nif (P256_LIMBS == 8) {\\r\\ndst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\\r\\ndst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\\r\\ndst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\\r\\ndst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\\r\\n}\\r\\n}\\r\\nstatic BN_ULONG is_zero(BN_ULONG in)\\r\\n{\\r\\nin |= (0 - in);\\r\\nin = ~in;\\r\\nin &= BN_MASK2;\\r\\nin >>= BN_BITS2 - 1;\\r\\nreturn in;\\r\\n}\\r\\nstatic BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\\r\\nconst BN_ULONG b[P256_LIMBS])\\r\\n{\\r\\nBN_ULONG res;\\r\\nres = a[0] ^ b[0];\\r\\nres |= a[1] ^ b[1];\\r\\nres |= a[2] ^ b[2];\\r\\nres |= a[3] ^ b[3];\\r\\nif (P256_LIMBS == 8) {\\r\\nres |= a[4] ^ b[4];\\r\\nres |= a[5] ^ b[5];\\r\\nres |= a[6] ^ b[6];\\r\\nres |= a[7] ^ b[7];\\r\\n}\\r\\nreturn is_zero(res);\\r\\n}\\r\\nstatic BN_ULONG is_one(const BN_ULONG a[P256_LIMBS])\\r\\n{\\r\\nBN_ULONG res;\\r\\nres = a[0] ^ ONE[0];\\r\\nres |= a[1] ^ ONE[1];\\r\\nres |= a[2] ^ ONE[2];\\r\\nres |= a[3] ^ ONE[3];\\r\\nif (P256_LIMBS == 8) {\\r\\nres |= a[4] ^ ONE[4];\\r\\nres |= a[5] ^ ONE[5];\\r\\nres |= a[6] ^ ONE[6];\\r\\n}\\r\\nreturn is_zero(res);\\r\\n}\\r\\nstatic void ecp_nistz256_point_double(P256_POINT *r, const P256_POINT *a)\\r\\n{\\r\\nBN_ULONG S[P256_LIMBS];\\r\\nBN_ULONG M[P256_LIMBS];\\r\\nBN_ULONG Zsqr[P256_LIMBS];\\r\\nBN_ULONG tmp0[P256_LIMBS];\\r\\nconst BN_ULONG *in_x = a->X;\\r\\nconst BN_ULONG *in_y = a->Y;\\r\\nconst BN_ULONG *in_z = a->Z;\\r\\nBN_ULONG *res_x = r->X;\\r\\nBN_ULONG *res_y = r->Y;\\r\\nBN_ULONG *res_z = r->Z;\\r\\necp_nistz256_mul_by_2(S, in_y);\\r\\necp_nistz256_sqr_mont(Zsqr, in_z);\\r\\necp_nistz256_sqr_mont(S, S);\\r\\necp_nistz256_mul_mont(res_z, in_z, in_y);\\r\\necp_nistz256_mul_by_2(res_z, res_z);\\r\\necp_nistz256_add(M, in_x, Zsqr);\\r\\necp_nistz256_sub(Zsqr, in_x, Zsqr);\\r\\necp_nistz256_sqr_mont(res_y, S);\\r\\necp_nistz256_div_by_2(res_y, res_y);\\r\\necp_nistz256_mul_mont(M, M, Zsqr);\\r\\necp_nistz256_mul_by_3(M, M);\\r\\necp_nistz256_mul_mont(S, S, in_x);\\r\\necp_nistz256_mul_by_2(tmp0, S);\\r\\necp_nistz256_sqr_mont(res_x, M);\\r\\necp_nistz256_sub(res_x, res_x, tmp0);\\r\\necp_nistz256_sub(S, S, res_x);\\r\\necp_nistz256_mul_mont(S, S, M);\\r\\necp_nistz256_sub(res_y, S, res_y);\\r\\n}\\r\\nstatic void ecp_nistz256_point_add(P256_POINT *r,\\r\\nconst P256_POINT *a, const P256_POINT *b)\\r\\n{\\r\\nBN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\\r\\nBN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\\r\\nBN_ULONG Z1sqr[P256_LIMBS];\\r\\nBN_ULONG Z2sqr[P256_LIMBS];\\r\\nBN_ULONG H[P256_LIMBS], R[P256_LIMBS];\\r\\nBN_ULONG Hsqr[P256_LIMBS];\\r\\nBN_ULONG Rsqr[P256_LIMBS];\\r\\nBN_ULONG Hcub[P256_LIMBS];\\r\\nBN_ULONG res_x[P256_LIMBS];\\r\\nBN_ULONG res_y[P256_LIMBS];\\r\\nBN_ULONG res_z[P256_LIMBS];\\r\\nBN_ULONG in1infty, in2infty;\\r\\nconst BN_ULONG *in1_x = a->X;\\r\\nconst BN_ULONG *in1_y = a->Y;\\r\\nconst BN_ULONG *in1_z = a->Z;\\r\\nconst BN_ULONG *in2_x = b->X;\\r\\nconst BN_ULONG *in2_y = b->Y;\\r\\nconst BN_ULONG *in2_z = b->Z;\\r\\nin1infty = (in1_x[0] | in1_x[1] | in1_x[2] | in1_x[3] |\\r\\nin1_y[0] | in1_y[1] | in1_y[2] | in1_y[3]);\\r\\nif (P256_LIMBS == 8)\\r\\nin1infty |= (in1_x[4] | in1_x[5] | in1_x[6] | in1_x[7] |\\r\\nin1_y[4] | in1_y[5] | in1_y[6] | in1_y[7]);\\r\\nin2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\\r\\nin2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\\r\\nif (P256_LIMBS == 8)\\r\\nin2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\\r\\nin2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\\r\\nin1infty = is_zero(in1infty);\\r\\nin2infty = is_zero(in2infty);\\r\\necp_nistz256_sqr_mont(Z2sqr, in2_z);\\r\\necp_nistz256_sqr_mont(Z1sqr, in1_z);\\r\\necp_nistz256_mul_mont(S1, Z2sqr, in2_z);\\r\\necp_nistz256_mul_mont(S2, Z1sqr, in1_z);\\r\\necp_nistz256_mul_mont(S1, S1, in1_y);\\r\\necp_nistz256_mul_mont(S2, S2, in2_y);\\r\\necp_nistz256_sub(R, S2, S1);\\r\\necp_nistz256_mul_mont(U1, in1_x, Z2sqr);\\r\\necp_nistz256_mul_mont(U2, in2_x, Z1sqr);\\r\\necp_nistz256_sub(H, U2, U1);\\r\\nif (is_equal(U1, U2) && !in1infty && !in2infty) {\\r\\nif (is_equal(S1, S2)) {\\r\\necp_nistz256_point_double(r, a);\\r\\nreturn;\\r\\n} else {\\r\\nmemset(r, 0, sizeof(*r));\\r\\nreturn;\\r\\n}\\r\\n}\\r\\necp_nistz256_sqr_mont(Rsqr, R);\\r\\necp_nistz256_mul_mont(res_z, H, in1_z);\\r\\necp_nistz256_sqr_mont(Hsqr, H);\\r\\necp_nistz256_mul_mont(res_z, res_z, in2_z);\\r\\necp_nistz256_mul_mont(Hcub, Hsqr, H);\\r\\necp_nistz256_mul_mont(U2, U1, Hsqr);\\r\\necp_nistz256_mul_by_2(Hsqr, U2);\\r\\necp_nistz256_sub(res_x, Rsqr, Hsqr);\\r\\necp_nistz256_sub(res_x, res_x, Hcub);\\r\\necp_nistz256_sub(res_y, U2, res_x);\\r\\necp_nistz256_mul_mont(S2, S1, Hcub);\\r\\necp_nistz256_mul_mont(res_y, R, res_y);\\r\\necp_nistz256_sub(res_y, res_y, S2);\\r\\ncopy_conditional(res_x, in2_x, in1infty);\\r\\ncopy_conditional(res_y, in2_y, in1infty);\\r\\ncopy_conditional(res_z, in2_z, in1infty);\\r\\ncopy_conditional(res_x, in1_x, in2infty);\\r\\ncopy_conditional(res_y, in1_y, in2infty);\\r\\ncopy_conditional(res_z, in1_z, in2infty);\\r\\nmemcpy(r->X, res_x, sizeof(res_x));\\r\\nmemcpy(r->Y, res_y, sizeof(res_y));\\r\\nmemcpy(r->Z, res_z, sizeof(res_z));\\r\\n}\\r\\nstatic void ecp_nistz256_point_add_affine(P256_POINT *r,\\r\\nconst P256_POINT *a,\\r\\nconst P256_POINT_AFFINE *b)\\r\\n{\\r\\nBN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\\r\\nBN_ULONG Z1sqr[P256_LIMBS];\\r\\nBN_ULONG H[P256_LIMBS], R[P256_LIMBS];\\r\\nBN_ULONG Hsqr[P256_LIMBS];\\r\\nBN_ULONG Rsqr[P256_LIMBS];\\r\\nBN_ULONG Hcub[P256_LIMBS];\\r\\nBN_ULONG res_x[P256_LIMBS];\\r\\nBN_ULONG res_y[P256_LIMBS];\\r\\nBN_ULONG res_z[P256_LIMBS];\\r\\nBN_ULONG in1infty, in2infty;\\r\\nconst BN_ULONG *in1_x = a->X;\\r\\nconst BN_ULONG *in1_y = a->Y;\\r\\nconst BN_ULONG *in1_z = a->Z;\\r\\nconst BN_ULONG *in2_x = b->X;\\r\\nconst BN_ULONG *in2_y = b->Y;\\r\\nin1infty = (in1_x[0] | in1_x[1] | in1_x[2] | in1_x[3] |\\r\\nin1_y[0] | in1_y[1] | in1_y[2] | in1_y[3]);\\r\\nif (P256_LIMBS == 8)\\r\\nin1infty |= (in1_x[4] | in1_x[5] | in1_x[6] | in1_x[7] |\\r\\nin1_y[4] | in1_y[5] | in1_y[6] | in1_y[7]);\\r\\nin2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\\r\\nin2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\\r\\nif (P256_LIMBS == 8)\\r\\nin2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\\r\\nin2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\\r\\nin1infty = is_zero(in1infty);\\r\\nin2infty = is_zero(in2infty);\\r\\necp_nistz256_sqr_mont(Z1sqr, in1_z);\\r\\necp_nistz256_mul_mont(U2, in2_x, Z1sqr);\\r\\necp_nistz256_sub(H, U2, in1_x);\\r\\necp_nistz256_mul_mont(S2, Z1sqr, in1_z);\\r\\necp_nistz256_mul_mont(res_z, H, in1_z);\\r\\necp_nistz256_mul_mont(S2, S2, in2_y);\\r\\necp_nistz256_sub(R, S2, in1_y);\\r\\necp_nistz256_sqr_mont(Hsqr, H);\\r\\necp_nistz256_sqr_mont(Rsqr, R);\\r\\necp_nistz256_mul_mont(Hcub, Hsqr, H);\\r\\necp_nistz256_mul_mont(U2, in1_x, Hsqr);\\r\\necp_nistz256_mul_by_2(Hsqr, U2);\\r\\necp_nistz256_sub(res_x, Rsqr, Hsqr);\\r\\necp_nistz256_sub(res_x, res_x, Hcub);\\r\\necp_nistz256_sub(H, U2, res_x);\\r\\necp_nistz256_mul_mont(S2, in1_y, Hcub);\\r\\necp_nistz256_mul_mont(H, H, R);\\r\\necp_nistz256_sub(res_y, H, S2);\\r\\ncopy_conditional(res_x, in2_x, in1infty);\\r\\ncopy_conditional(res_x, in1_x, in2infty);\\r\\ncopy_conditional(res_y, in2_y, in1infty);\\r\\ncopy_conditional(res_y, in1_y, in2infty);\\r\\ncopy_conditional(res_z, ONE, in1infty);\\r\\ncopy_conditional(res_z, in1_z, in2infty);\\r\\nmemcpy(r->X, res_x, sizeof(res_x));\\r\\nmemcpy(r->Y, res_y, sizeof(res_y));\\r\\nmemcpy(r->Z, res_z, sizeof(res_z));\\r\\n}\\r\\nstatic void ecp_nistz256_mod_inverse(BN_ULONG r[P256_LIMBS],\\r\\nconst BN_ULONG in[P256_LIMBS])\\r\\n{\\r\\nBN_ULONG p2[P256_LIMBS];\\r\\nBN_ULONG p4[P256_LIMBS];\\r\\nBN_ULONG p8[P256_LIMBS];\\r\\nBN_ULONG p16[P256_LIMBS];\\r\\nBN_ULONG p32[P256_LIMBS];\\r\\nBN_ULONG res[P256_LIMBS];\\r\\nint i;\\r\\necp_nistz256_sqr_mont(res, in);\\r\\necp_nistz256_mul_mont(p2, res, in);\\r\\necp_nistz256_sqr_mont(res, p2);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(p4, res, p2);\\r\\necp_nistz256_sqr_mont(res, p4);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(p8, res, p4);\\r\\necp_nistz256_sqr_mont(res, p8);\\r\\nfor (i = 0; i < 7; i++)\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(p16, res, p8);\\r\\necp_nistz256_sqr_mont(res, p16);\\r\\nfor (i = 0; i < 15; i++)\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(p32, res, p16);\\r\\necp_nistz256_sqr_mont(res, p32);\\r\\nfor (i = 0; i < 31; i++)\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(res, res, in);\\r\\nfor (i = 0; i < 32 * 4; i++)\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(res, res, p32);\\r\\nfor (i = 0; i < 32; i++)\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(res, res, p32);\\r\\nfor (i = 0; i < 16; i++)\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(res, res, p16);\\r\\nfor (i = 0; i < 8; i++)\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(res, res, p8);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(res, res, p4);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(res, res, p2);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_sqr_mont(res, res);\\r\\necp_nistz256_mul_mont(res, res, in);\\r\\nmemcpy(r, res, sizeof(res));\\r\\n}\\r\\nstatic int ecp_nistz256_bignum_to_field_elem(BN_ULONG out[P256_LIMBS],\\r\\nconst BIGNUM *in)\\r\\n{\\r\\nif (in->top > P256_LIMBS)\\r\\nreturn 0;\\r\\nmemset(out, 0, sizeof(BN_ULONG) * P256_LIMBS);\\r\\nmemcpy(out, in->d, sizeof(BN_ULONG) * in->top);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void ecp_nistz256_windowed_mul(const EC_GROUP *group,\\r\\nP256_POINT *r,\\r\\nconst BIGNUM **scalar,\\r\\nconst EC_POINT **point,\\r\\nint num, BN_CTX *ctx)\\r\\n{\\r\\nint i, j;\\r\\nunsigned int index;\\r\\nunsigned char (*p_str)[33] = NULL;\\r\\nconst unsigned int window_size = 5;\\r\\nconst unsigned int mask = (1 << (window_size + 1)) - 1;\\r\\nunsigned int wvalue;\\r\\nBN_ULONG tmp[P256_LIMBS];\\r\\nALIGN32 P256_POINT h;\\r\\nconst BIGNUM **scalars = NULL;\\r\\nP256_POINT (*table)[16] = NULL;\\r\\nvoid *table_storage = NULL;\\r\\nif ((table_storage =\\r\\nOPENSSL_malloc(num * 16 * sizeof(P256_POINT) + 64)) == NULL\\r\\n|| (p_str =\\r\\nOPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\\r\\n|| (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL) {\\r\\nECerr(EC_F_ECP_NISTZ256_WINDOWED_MUL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n} else {\\r\\ntable = (void *)ALIGNPTR(table_storage, 64);\\r\\n}\\r\\nfor (i = 0; i < num; i++) {\\r\\nP256_POINT *row = table[i];\\r\\nif ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\\r\\nBIGNUM *mod;\\r\\nif ((mod = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_nnmod(mod, scalar[i], &group->order, ctx)) {\\r\\nECerr(EC_F_ECP_NISTZ256_WINDOWED_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nscalars[i] = mod;\\r\\n} else\\r\\nscalars[i] = scalar[i];\\r\\nfor (j = 0; j < scalars[i]->top * BN_BYTES; j += BN_BYTES) {\\r\\nBN_ULONG d = scalars[i]->d[j / BN_BYTES];\\r\\np_str[i][j + 0] = d & 0xff;\\r\\np_str[i][j + 1] = (d >> 8) & 0xff;\\r\\np_str[i][j + 2] = (d >> 16) & 0xff;\\r\\np_str[i][j + 3] = (d >>= 24) & 0xff;\\r\\nif (BN_BYTES == 8) {\\r\\nd >>= 8;\\r\\np_str[i][j + 4] = d & 0xff;\\r\\np_str[i][j + 5] = (d >> 8) & 0xff;\\r\\np_str[i][j + 6] = (d >> 16) & 0xff;\\r\\np_str[i][j + 7] = (d >> 24) & 0xff;\\r\\n}\\r\\n}\\r\\nfor (; j < 33; j++)\\r\\np_str[i][j] = 0;\\r\\nif (!ecp_nistz256_bignum_to_field_elem(row[1 - 1].X, &point[i]->X)\\r\\n|| !ecp_nistz256_bignum_to_field_elem(row[1 - 1].Y, &point[i]->Y)\\r\\n|| !ecp_nistz256_bignum_to_field_elem(row[1 - 1].Z, &point[i]->Z)) {\\r\\nECerr(EC_F_ECP_NISTZ256_WINDOWED_MUL, EC_R_COORDINATES_OUT_OF_RANGE);\\r\\ngoto err;\\r\\n}\\r\\necp_nistz256_point_double(&row[ 2 - 1], &row[ 1 - 1]);\\r\\necp_nistz256_point_add (&row[ 3 - 1], &row[ 2 - 1], &row[1 - 1]);\\r\\necp_nistz256_point_double(&row[ 4 - 1], &row[ 2 - 1]);\\r\\necp_nistz256_point_double(&row[ 6 - 1], &row[ 3 - 1]);\\r\\necp_nistz256_point_double(&row[ 8 - 1], &row[ 4 - 1]);\\r\\necp_nistz256_point_double(&row[12 - 1], &row[ 6 - 1]);\\r\\necp_nistz256_point_add (&row[ 5 - 1], &row[ 4 - 1], &row[1 - 1]);\\r\\necp_nistz256_point_add (&row[ 7 - 1], &row[ 6 - 1], &row[1 - 1]);\\r\\necp_nistz256_point_add (&row[ 9 - 1], &row[ 8 - 1], &row[1 - 1]);\\r\\necp_nistz256_point_add (&row[13 - 1], &row[12 - 1], &row[1 - 1]);\\r\\necp_nistz256_point_double(&row[14 - 1], &row[ 7 - 1]);\\r\\necp_nistz256_point_double(&row[10 - 1], &row[ 5 - 1]);\\r\\necp_nistz256_point_add (&row[15 - 1], &row[14 - 1], &row[1 - 1]);\\r\\necp_nistz256_point_add (&row[11 - 1], &row[10 - 1], &row[1 - 1]);\\r\\necp_nistz256_point_add (&row[16 - 1], &row[15 - 1], &row[1 - 1]);\\r\\n}\\r\\nindex = 255;\\r\\nwvalue = p_str[0][(index - 1) / 8];\\r\\nwvalue = (wvalue >> ((index - 1) % 8)) & mask;\\r\\necp_nistz256_select_w5(r, table[0], _booth_recode_w5(wvalue) >> 1);\\r\\nwhile (index >= 5) {\\r\\nfor (i = (index == 255 ? 1 : 0); i < num; i++) {\\r\\nunsigned int off = (index - 1) / 8;\\r\\nwvalue = p_str[i][off] | p_str[i][off + 1] << 8;\\r\\nwvalue = (wvalue >> ((index - 1) % 8)) & mask;\\r\\nwvalue = _booth_recode_w5(wvalue);\\r\\necp_nistz256_select_w5(&h, table[i], wvalue >> 1);\\r\\necp_nistz256_neg(tmp, h.Y);\\r\\ncopy_conditional(h.Y, tmp, (wvalue & 1));\\r\\necp_nistz256_point_add(r, r, &h);\\r\\n}\\r\\nindex -= window_size;\\r\\necp_nistz256_point_double(r, r);\\r\\necp_nistz256_point_double(r, r);\\r\\necp_nistz256_point_double(r, r);\\r\\necp_nistz256_point_double(r, r);\\r\\necp_nistz256_point_double(r, r);\\r\\n}\\r\\nfor (i = 0; i < num; i++) {\\r\\nwvalue = p_str[i][0];\\r\\nwvalue = (wvalue << 1) & mask;\\r\\nwvalue = _booth_recode_w5(wvalue);\\r\\necp_nistz256_select_w5(&h, table[i], wvalue >> 1);\\r\\necp_nistz256_neg(tmp, h.Y);\\r\\ncopy_conditional(h.Y, tmp, wvalue & 1);\\r\\necp_nistz256_point_add(r, r, &h);\\r\\n}\\r\\nerr:\\r\\nif (table_storage)\\r\\nOPENSSL_free(table_storage);\\r\\nif (p_str)\\r\\nOPENSSL_free(p_str);\\r\\nif (scalars)\\r\\nOPENSSL_free(scalars);\\r\\n}\\r\\nstatic int ecp_nistz256_is_affine_G(const EC_POINT *generator)\\r\\n{\\r\\nreturn (generator->X.top == P256_LIMBS) &&\\r\\n(generator->Y.top == P256_LIMBS) &&\\r\\n(generator->Z.top == (P256_LIMBS - P256_LIMBS / 8)) &&\\r\\nis_equal(generator->X.d, def_xG) &&\\r\\nis_equal(generator->Y.d, def_yG) && is_one(generator->Z.d);\\r\\n}\\r\\nstatic int ecp_nistz256_mult_precompute(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *order;\\r\\nEC_POINT *P = NULL, *T = NULL;\\r\\nconst EC_POINT *generator;\\r\\nEC_PRE_COMP *pre_comp;\\r\\nint i, j, k, ret = 0;\\r\\nsize_t w;\\r\\nPRECOMP256_ROW *preComputedTable = NULL;\\r\\nunsigned char *precomp_storage = NULL;\\r\\nEC_EX_DATA_free_data(&group->extra_data, ecp_nistz256_pre_comp_dup,\\r\\necp_nistz256_pre_comp_free,\\r\\necp_nistz256_pre_comp_clear_free);\\r\\ngenerator = EC_GROUP_get0_generator(group);\\r\\nif (generator == NULL) {\\r\\nECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE, EC_R_UNDEFINED_GENERATOR);\\r\\nreturn 0;\\r\\n}\\r\\nif (ecp_nistz256_is_affine_G(generator)) {\\r\\nreturn 1;\\r\\n}\\r\\nif ((pre_comp = ecp_nistz256_pre_comp_new(group)) == NULL)\\r\\nreturn 0;\\r\\nif (ctx == NULL) {\\r\\nctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\ngoto err;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\norder = BN_CTX_get(ctx);\\r\\nif (order == NULL)\\r\\ngoto err;\\r\\nif (!EC_GROUP_get_order(group, order, ctx))\\r\\ngoto err;\\r\\nif (BN_is_zero(order)) {\\r\\nECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE, EC_R_UNKNOWN_ORDER);\\r\\ngoto err;\\r\\n}\\r\\nw = 7;\\r\\nif ((precomp_storage =\\r\\nOPENSSL_malloc(37 * 64 * sizeof(P256_POINT_AFFINE) + 64)) == NULL) {\\r\\nECerr(EC_F_ECP_NISTZ256_MULT_PRECOMPUTE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n} else {\\r\\npreComputedTable = (void *)ALIGNPTR(precomp_storage, 64);\\r\\n}\\r\\nP = EC_POINT_new(group);\\r\\nT = EC_POINT_new(group);\\r\\nEC_POINT_copy(T, generator);\\r\\nfor (k = 0; k < 64; k++) {\\r\\nEC_POINT_copy(P, T);\\r\\nfor (j = 0; j < 37; j++) {\\r\\nec_GFp_simple_make_affine(group, P, ctx);\\r\\necp_nistz256_bignum_to_field_elem(preComputedTable[j]\\r\\n[k].X, &P->X);\\r\\necp_nistz256_bignum_to_field_elem(preComputedTable[j]\\r\\n[k].Y, &P->Y);\\r\\nfor (i = 0; i < 7; i++)\\r\\nec_GFp_simple_dbl(group, P, P, ctx);\\r\\n}\\r\\nec_GFp_simple_add(group, T, T, generator, ctx);\\r\\n}\\r\\npre_comp->group = group;\\r\\npre_comp->w = w;\\r\\npre_comp->precomp = preComputedTable;\\r\\npre_comp->precomp_storage = precomp_storage;\\r\\nprecomp_storage = NULL;\\r\\nif (!EC_EX_DATA_set_data(&group->extra_data, pre_comp,\\r\\necp_nistz256_pre_comp_dup,\\r\\necp_nistz256_pre_comp_free,\\r\\necp_nistz256_pre_comp_clear_free)) {\\r\\ngoto err;\\r\\n}\\r\\npre_comp = NULL;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ctx != NULL)\\r\\nBN_CTX_end(ctx);\\r\\nif (pre_comp)\\r\\necp_nistz256_pre_comp_free(pre_comp);\\r\\nif (precomp_storage)\\r\\nOPENSSL_free(precomp_storage);\\r\\nif (P)\\r\\nEC_POINT_free(P);\\r\\nif (T)\\r\\nEC_POINT_free(T);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void booth_recode_w7(unsigned char *sign,\\r\\nunsigned char *digit, unsigned char in)\\r\\n{\\r\\nunsigned char s, d;\\r\\ns = ~((in >> 7) - 1);\\r\\nd = (1 << 8) - in - 1;\\r\\nd = (d & s) | (in & ~s);\\r\\nd = (d >> 1) + (d & 1);\\r\\n*sign = s & 1;\\r\\n*digit = d;\\r\\n}\\r\\nstatic int ecp_nistz256_set_from_affine(EC_POINT *out, const EC_GROUP *group,\\r\\nconst P256_POINT_AFFINE *in,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nBIGNUM x, y;\\r\\nBN_ULONG d_x[P256_LIMBS], d_y[P256_LIMBS];\\r\\nint ret = 0;\\r\\nmemcpy(d_x, in->X, sizeof(d_x));\\r\\nx.d = d_x;\\r\\nx.dmax = x.top = P256_LIMBS;\\r\\nx.neg = 0;\\r\\nx.flags = BN_FLG_STATIC_DATA;\\r\\nmemcpy(d_y, in->Y, sizeof(d_y));\\r\\ny.d = d_y;\\r\\ny.dmax = y.top = P256_LIMBS;\\r\\ny.neg = 0;\\r\\ny.flags = BN_FLG_STATIC_DATA;\\r\\nret = EC_POINT_set_affine_coordinates_GFp(group, out, &x, &y, ctx);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ecp_nistz256_points_mul(const EC_GROUP *group,\\r\\nEC_POINT *r,\\r\\nconst BIGNUM *scalar,\\r\\nsize_t num,\\r\\nconst EC_POINT *points[],\\r\\nconst BIGNUM *scalars[], BN_CTX *ctx)\\r\\n{\\r\\nint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\\r\\nsize_t j;\\r\\nunsigned char p_str[33] = { 0 };\\r\\nconst PRECOMP256_ROW *preComputedTable = NULL;\\r\\nconst EC_PRE_COMP *pre_comp = NULL;\\r\\nconst EC_POINT *generator = NULL;\\r\\nunsigned int index = 0;\\r\\nconst unsigned int window_size = 7;\\r\\nconst unsigned int mask = (1 << (window_size + 1)) - 1;\\r\\nunsigned int wvalue;\\r\\nALIGN32 union {\\r\\nP256_POINT p;\\r\\nP256_POINT_AFFINE a;\\r\\n} t, p;\\r\\nBIGNUM *tmp_scalar;\\r\\nif (group->meth != r->meth) {\\r\\nECerr(EC_F_ECP_NISTZ256_POINTS_MUL, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\nif ((scalar == NULL) && (num == 0))\\r\\nreturn EC_POINT_set_to_infinity(group, r);\\r\\nfor (j = 0; j < num; j++) {\\r\\nif (group->meth != points[j]->meth) {\\r\\nECerr(EC_F_ECP_NISTZ256_POINTS_MUL, EC_R_INCOMPATIBLE_OBJECTS);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nbn_wexpand(&r->X, P256_LIMBS);\\r\\nbn_wexpand(&r->Y, P256_LIMBS);\\r\\nbn_wexpand(&r->Z, P256_LIMBS);\\r\\nr->X.top = P256_LIMBS;\\r\\nr->Y.top = P256_LIMBS;\\r\\nr->Z.top = P256_LIMBS;\\r\\nif (scalar) {\\r\\ngenerator = EC_GROUP_get0_generator(group);\\r\\nif (generator == NULL) {\\r\\nECerr(EC_F_ECP_NISTZ256_POINTS_MUL, EC_R_UNDEFINED_GENERATOR);\\r\\ngoto err;\\r\\n}\\r\\npre_comp =\\r\\nEC_EX_DATA_get_data(group->extra_data, ecp_nistz256_pre_comp_dup,\\r\\necp_nistz256_pre_comp_free,\\r\\necp_nistz256_pre_comp_clear_free);\\r\\nif (pre_comp) {\\r\\nEC_POINT *pre_comp_generator = EC_POINT_new(group);\\r\\nif (pre_comp_generator == NULL)\\r\\ngoto err;\\r\\nif (!ecp_nistz256_set_from_affine\\r\\n(pre_comp_generator, group, pre_comp->precomp[0], ctx))\\r\\ngoto err;\\r\\nif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\\r\\npreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\\r\\nEC_POINT_free(pre_comp_generator);\\r\\n}\\r\\nif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\\r\\npreComputedTable = (const PRECOMP256_ROW *)ecp_nistz256_precomputed;\\r\\n}\\r\\nif (preComputedTable) {\\r\\nif ((BN_num_bits(scalar) > 256)\\r\\n|| BN_is_negative(scalar)) {\\r\\nif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\\r\\ngoto err;\\r\\nif (!BN_nnmod(tmp_scalar, scalar, &group->order, ctx)) {\\r\\nECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nscalar = tmp_scalar;\\r\\n}\\r\\nfor (i = 0; i < scalar->top * BN_BYTES; i += BN_BYTES) {\\r\\nBN_ULONG d = scalar->d[i / BN_BYTES];\\r\\np_str[i + 0] = d & 0xff;\\r\\np_str[i + 1] = (d >> 8) & 0xff;\\r\\np_str[i + 2] = (d >> 16) & 0xff;\\r\\np_str[i + 3] = (d >>= 24) & 0xff;\\r\\nif (BN_BYTES == 8) {\\r\\nd >>= 8;\\r\\np_str[i + 4] = d & 0xff;\\r\\np_str[i + 5] = (d >> 8) & 0xff;\\r\\np_str[i + 6] = (d >> 16) & 0xff;\\r\\np_str[i + 7] = (d >> 24) & 0xff;\\r\\n}\\r\\n}\\r\\nfor (; i < 33; i++)\\r\\np_str[i] = 0;\\r\\n#if defined(ECP_NISTZ256_AVX2)\\r\\nif (ecp_nistz_avx2_eligible()) {\\r\\necp_nistz256_avx2_mul_g(&p.p, p_str, preComputedTable);\\r\\n} else\\r\\n#endif\\r\\n{\\r\\nwvalue = (p_str[0] << 1) & mask;\\r\\nindex += window_size;\\r\\nwvalue = _booth_recode_w7(wvalue);\\r\\necp_nistz256_select_w7(&p.a, preComputedTable[0], wvalue >> 1);\\r\\necp_nistz256_neg(p.p.Z, p.p.Y);\\r\\ncopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\\r\\nmemcpy(p.p.Z, ONE, sizeof(ONE));\\r\\nfor (i = 1; i < 37; i++) {\\r\\nunsigned int off = (index - 1) / 8;\\r\\nwvalue = p_str[off] | p_str[off + 1] << 8;\\r\\nwvalue = (wvalue >> ((index - 1) % 8)) & mask;\\r\\nindex += window_size;\\r\\nwvalue = _booth_recode_w7(wvalue);\\r\\necp_nistz256_select_w7(&t.a,\\r\\npreComputedTable[i], wvalue >> 1);\\r\\necp_nistz256_neg(t.p.Z, t.a.Y);\\r\\ncopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\\r\\necp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\\r\\n}\\r\\n}\\r\\n} else {\\r\\np_is_infinity = 1;\\r\\nno_precomp_for_generator = 1;\\r\\n}\\r\\n} else\\r\\np_is_infinity = 1;\\r\\nif (no_precomp_for_generator) {\\r\\nconst BIGNUM **new_scalars;\\r\\nconst EC_POINT **new_points;\\r\\nnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\\r\\nif (!new_scalars) {\\r\\nECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\\r\\nif (!new_points) {\\r\\nOPENSSL_free(new_scalars);\\r\\nECerr(EC_F_ECP_NISTZ256_POINTS_MUL, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\\r\\nnew_scalars[num] = scalar;\\r\\nmemcpy(new_points, points, num * sizeof(EC_POINT *));\\r\\nnew_points[num] = generator;\\r\\nscalars = new_scalars;\\r\\npoints = new_points;\\r\\nnum++;\\r\\n}\\r\\nif (num) {\\r\\nP256_POINT *out = &t.p;\\r\\nif (p_is_infinity)\\r\\nout = &p.p;\\r\\necp_nistz256_windowed_mul(group, out, scalars, points, num, ctx);\\r\\nif (!p_is_infinity)\\r\\necp_nistz256_point_add(&p.p, &p.p, out);\\r\\n}\\r\\nif (no_precomp_for_generator) {\\r\\nOPENSSL_free(points);\\r\\nOPENSSL_free(scalars);\\r\\n}\\r\\nmemcpy(r->X.d, p.p.X, sizeof(p.p.X));\\r\\nmemcpy(r->Y.d, p.p.Y, sizeof(p.p.Y));\\r\\nmemcpy(r->Z.d, p.p.Z, sizeof(p.p.Z));\\r\\nbn_correct_top(&r->X);\\r\\nbn_correct_top(&r->Y);\\r\\nbn_correct_top(&r->Z);\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nstatic int ecp_nistz256_get_affine(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y, BN_CTX *ctx)\\r\\n{\\r\\nBN_ULONG z_inv2[P256_LIMBS];\\r\\nBN_ULONG z_inv3[P256_LIMBS];\\r\\nBN_ULONG x_aff[P256_LIMBS];\\r\\nBN_ULONG y_aff[P256_LIMBS];\\r\\nBN_ULONG point_x[P256_LIMBS], point_y[P256_LIMBS], point_z[P256_LIMBS];\\r\\nif (EC_POINT_is_at_infinity(group, point)) {\\r\\nECerr(EC_F_ECP_NISTZ256_GET_AFFINE, EC_R_POINT_AT_INFINITY);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ecp_nistz256_bignum_to_field_elem(point_x, &point->X) ||\\r\\n!ecp_nistz256_bignum_to_field_elem(point_y, &point->Y) ||\\r\\n!ecp_nistz256_bignum_to_field_elem(point_z, &point->Z)) {\\r\\nECerr(EC_F_ECP_NISTZ256_GET_AFFINE, EC_R_COORDINATES_OUT_OF_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\necp_nistz256_mod_inverse(z_inv3, point_z);\\r\\necp_nistz256_sqr_mont(z_inv2, z_inv3);\\r\\necp_nistz256_mul_mont(x_aff, z_inv2, point_x);\\r\\nif (x != NULL) {\\r\\nbn_wexpand(x, P256_LIMBS);\\r\\nx->top = P256_LIMBS;\\r\\necp_nistz256_from_mont(x->d, x_aff);\\r\\nbn_correct_top(x);\\r\\n}\\r\\nif (y != NULL) {\\r\\necp_nistz256_mul_mont(z_inv3, z_inv3, z_inv2);\\r\\necp_nistz256_mul_mont(y_aff, z_inv3, point_y);\\r\\nbn_wexpand(y, P256_LIMBS);\\r\\ny->top = P256_LIMBS;\\r\\necp_nistz256_from_mont(y->d, y_aff);\\r\\nbn_correct_top(y);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic EC_PRE_COMP *ecp_nistz256_pre_comp_new(const EC_GROUP *group)\\r\\n{\\r\\nEC_PRE_COMP *ret = NULL;\\r\\nif (!group)\\r\\nreturn NULL;\\r\\nret = (EC_PRE_COMP *)OPENSSL_malloc(sizeof(EC_PRE_COMP));\\r\\nif (!ret) {\\r\\nECerr(EC_F_ECP_NISTZ256_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn ret;\\r\\n}\\r\\nret->group = group;\\r\\nret->w = 6;\\r\\nret->precomp = NULL;\\r\\nret->precomp_storage = NULL;\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nstatic void *ecp_nistz256_pre_comp_dup(void *src_)\\r\\n{\\r\\nEC_PRE_COMP *src = src_;\\r\\nCRYPTO_add(&src->references, 1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nreturn src_;\\r\\n}\\r\\nstatic void ecp_nistz256_pre_comp_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nEC_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nif (pre->precomp_storage)\\r\\nOPENSSL_free(pre->precomp_storage);\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nstatic void ecp_nistz256_pre_comp_clear_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nEC_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nif (pre->precomp_storage) {\\r\\nOPENSSL_cleanse(pre->precomp,\\r\\n32 * sizeof(unsigned char) * (1 << pre->w) * 2 * 37);\\r\\nOPENSSL_free(pre->precomp_storage);\\r\\n}\\r\\nOPENSSL_cleanse(pre, sizeof *pre);\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nstatic int ecp_nistz256_window_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nconst EC_POINT *generator = EC_GROUP_get0_generator(group);\\r\\nif (generator != NULL && ecp_nistz256_is_affine_G(generator)) {\\r\\nreturn 1;\\r\\n}\\r\\nreturn EC_EX_DATA_get_data(group->extra_data, ecp_nistz256_pre_comp_dup,\\r\\necp_nistz256_pre_comp_free,\\r\\necp_nistz256_pre_comp_clear_free) != NULL;\\r\\n}\\r\\nconst EC_METHOD *EC_GFp_nistz256_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nEC_FLAGS_DEFAULT_OCT,\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_mont_group_init,\\r\\nec_GFp_mont_group_finish,\\r\\nec_GFp_mont_group_clear_finish,\\r\\nec_GFp_mont_group_copy,\\r\\nec_GFp_mont_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\necp_nistz256_get_affine,\\r\\n0, 0, 0,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\necp_nistz256_points_mul,\\r\\necp_nistz256_mult_precompute,\\r\\necp_nistz256_window_have_precompute_mult,\\r\\nec_GFp_mont_field_mul,\\r\\nec_GFp_mont_field_sqr,\\r\\n0,\\r\\nec_GFp_mont_field_encode,\\r\\nec_GFp_mont_field_decode,\\r\\nec_GFp_mont_field_set_to_one\\r\\n};\\r\\nreturn &ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dso_openssl_c", "target": 0, "func": "DSO_METHOD *DSO_METHOD_openssl(void)\\r\\n{\\r\\n#ifdef DEF_DSO_METHOD\\r\\nreturn (DEF_DSO_METHOD());\\r\\n#elif defined(DSO_DLFCN)\\r\\nreturn (DSO_METHOD_dlfcn());\\r\\n#elif defined(DSO_DL)\\r\\nreturn (DSO_METHOD_dl());\\r\\n#elif defined(DSO_WIN32)\\r\\nreturn (DSO_METHOD_win32());\\r\\n#elif defined(DSO_VMS)\\r\\nreturn (DSO_METHOD_vms());\\r\\n#elif defined(DSO_BEOS)\\r\\nreturn (DSO_METHOD_beos());\\r\\n#else\\r\\nreturn (DSO_METHOD_null());\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_s390xcap_c", "target": 0, "func": "static void ill_handler(int sig)\\r\\n{\\r\\nsiglongjmp(ill_jmp, sig);\\r\\n}\\r\\nvoid OPENSSL_cpuid_setup(void)\\r\\n{\\r\\nsigset_t oset;\\r\\nstruct sigaction ill_act, oact;\\r\\nif (OPENSSL_s390xcap_P[0])\\r\\nreturn;\\r\\nOPENSSL_s390xcap_P[0] = 1UL << (8 * sizeof(unsigned long) - 1);\\r\\nmemset(&ill_act, 0, sizeof(ill_act));\\r\\nill_act.sa_handler = ill_handler;\\r\\nsigfillset(&ill_act.sa_mask);\\r\\nsigdelset(&ill_act.sa_mask, SIGILL);\\r\\nsigdelset(&ill_act.sa_mask, SIGTRAP);\\r\\nsigprocmask(SIG_SETMASK, &ill_act.sa_mask, &oset);\\r\\nsigaction(SIGILL, &ill_act, &oact);\\r\\nif (sigsetjmp(ill_jmp, 1) == 0)\\r\\nOPENSSL_s390x_facilities();\\r\\nsigaction(SIGILL, &oact, NULL);\\r\\nsigprocmask(SIG_SETMASK, &oset, NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_null_c", "target": 0, "func": "BIO_METHOD *BIO_s_null(void)\\r\\n{\\r\\nreturn (&null_method);\\r\\n}\\r\\nstatic int null_new(BIO *bi)\\r\\n{\\r\\nbi->init = 1;\\r\\nbi->num = 0;\\r\\nbi->ptr = (NULL);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int null_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int null_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nreturn (0);\\r\\n}\\r\\nstatic int null_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nreturn (inl);\\r\\n}\\r\\nstatic long null_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret = 1;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\ncase BIO_CTRL_EOF:\\r\\ncase BIO_CTRL_SET:\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\ncase BIO_CTRL_FLUSH:\\r\\ncase BIO_CTRL_DUP:\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\ncase BIO_CTRL_INFO:\\r\\ncase BIO_CTRL_GET:\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int null_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nreturn (0);\\r\\n}\\r\\nstatic int null_puts(BIO *bp, const char *str)\\r\\n{\\r\\nif (str == NULL)\\r\\nreturn (0);\\r\\nreturn (strlen(str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_s3_enc_c", "target": 0, "func": "static int ssl3_generate_key_block(SSL *s, unsigned char *km, int num)\\r\\n{\\r\\nEVP_MD_CTX m5;\\r\\nEVP_MD_CTX s1;\\r\\nunsigned char buf[16], smd[SHA_DIGEST_LENGTH];\\r\\nunsigned char c = 'A';\\r\\nunsigned int i, j, k;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nc = os_toascii[c];\\r\\n#endif\\r\\nk = 0;\\r\\nEVP_MD_CTX_init(&m5);\\r\\nEVP_MD_CTX_set_flags(&m5, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\\r\\nEVP_MD_CTX_init(&s1);\\r\\nfor (i = 0; (int)i < num; i += MD5_DIGEST_LENGTH) {\\r\\nk++;\\r\\nif (k > sizeof buf) {\\r\\nSSLerr(SSL_F_SSL3_GENERATE_KEY_BLOCK, ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nfor (j = 0; j < k; j++)\\r\\nbuf[j] = c;\\r\\nc++;\\r\\nEVP_DigestInit_ex(&s1, EVP_sha1(), NULL);\\r\\nEVP_DigestUpdate(&s1, buf, k);\\r\\nEVP_DigestUpdate(&s1, s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&s1, s->s3->server_random, SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&s1, s->s3->client_random, SSL3_RANDOM_SIZE);\\r\\nEVP_DigestFinal_ex(&s1, smd, NULL);\\r\\nEVP_DigestInit_ex(&m5, EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&m5, s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&m5, smd, SHA_DIGEST_LENGTH);\\r\\nif ((int)(i + MD5_DIGEST_LENGTH) > num) {\\r\\nEVP_DigestFinal_ex(&m5, smd, NULL);\\r\\nmemcpy(km, smd, (num - i));\\r\\n} else\\r\\nEVP_DigestFinal_ex(&m5, km, NULL);\\r\\nkm += MD5_DIGEST_LENGTH;\\r\\n}\\r\\nOPENSSL_cleanse(smd, SHA_DIGEST_LENGTH);\\r\\nEVP_MD_CTX_cleanup(&m5);\\r\\nEVP_MD_CTX_cleanup(&s1);\\r\\nreturn 1;\\r\\n}\\r\\nint ssl3_change_cipher_state(SSL *s, int which)\\r\\n{\\r\\nunsigned char *p, *mac_secret;\\r\\nunsigned char exp_key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char exp_iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char *ms, *key, *iv, *er1, *er2;\\r\\nEVP_CIPHER_CTX *dd;\\r\\nconst EVP_CIPHER *c;\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nCOMP_METHOD *comp;\\r\\n#endif\\r\\nconst EVP_MD *m;\\r\\nEVP_MD_CTX md;\\r\\nint is_exp, n, i, j, k, cl;\\r\\nint reuse_dd = 0;\\r\\nis_exp = SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);\\r\\nc = s->s3->tmp.new_sym_enc;\\r\\nm = s->s3->tmp.new_hash;\\r\\nOPENSSL_assert(m);\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nif (s->s3->tmp.new_compression == NULL)\\r\\ncomp = NULL;\\r\\nelse\\r\\ncomp = s->s3->tmp.new_compression->method;\\r\\n#endif\\r\\nif (which & SSL3_CC_READ) {\\r\\nif (s->enc_read_ctx != NULL)\\r\\nreuse_dd = 1;\\r\\nelse if ((s->enc_read_ctx =\\r\\nOPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\\r\\ngoto err;\\r\\nelse\\r\\nEVP_CIPHER_CTX_init(s->enc_read_ctx);\\r\\ndd = s->enc_read_ctx;\\r\\nssl_replace_hash(&s->read_hash, m);\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nif (s->expand != NULL) {\\r\\nCOMP_CTX_free(s->expand);\\r\\ns->expand = NULL;\\r\\n}\\r\\nif (comp != NULL) {\\r\\ns->expand = COMP_CTX_new(comp);\\r\\nif (s->expand == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,\\r\\nSSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ns->s3->rrec.comp = (unsigned char *)\\r\\nOPENSSL_malloc(SSL3_RT_MAX_PLAIN_LENGTH);\\r\\nif (s->s3->rrec.comp == NULL)\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\nmemset(&(s->s3->read_sequence[0]), 0, 8);\\r\\nmac_secret = &(s->s3->read_mac_secret[0]);\\r\\n} else {\\r\\nif (s->enc_write_ctx != NULL)\\r\\nreuse_dd = 1;\\r\\nelse if ((s->enc_write_ctx =\\r\\nOPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)\\r\\ngoto err;\\r\\nelse\\r\\nEVP_CIPHER_CTX_init(s->enc_write_ctx);\\r\\ndd = s->enc_write_ctx;\\r\\nssl_replace_hash(&s->write_hash, m);\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nif (s->compress != NULL) {\\r\\nCOMP_CTX_free(s->compress);\\r\\ns->compress = NULL;\\r\\n}\\r\\nif (comp != NULL) {\\r\\ns->compress = COMP_CTX_new(comp);\\r\\nif (s->compress == NULL) {\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE,\\r\\nSSL_R_COMPRESSION_LIBRARY_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nmemset(&(s->s3->write_sequence[0]), 0, 8);\\r\\nmac_secret = &(s->s3->write_mac_secret[0]);\\r\\n}\\r\\nif (reuse_dd)\\r\\nEVP_CIPHER_CTX_cleanup(dd);\\r\\np = s->s3->tmp.key_block;\\r\\ni = EVP_MD_size(m);\\r\\nif (i < 0)\\r\\ngoto err2;\\r\\ncl = EVP_CIPHER_key_length(c);\\r\\nj = is_exp ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?\\r\\ncl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;\\r\\nk = EVP_CIPHER_iv_length(c);\\r\\nif ((which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||\\r\\n(which == SSL3_CHANGE_CIPHER_SERVER_READ)) {\\r\\nms = &(p[0]);\\r\\nn = i + i;\\r\\nkey = &(p[n]);\\r\\nn += j + j;\\r\\niv = &(p[n]);\\r\\nn += k + k;\\r\\ner1 = &(s->s3->client_random[0]);\\r\\ner2 = &(s->s3->server_random[0]);\\r\\n} else {\\r\\nn = i;\\r\\nms = &(p[n]);\\r\\nn += i + j;\\r\\nkey = &(p[n]);\\r\\nn += j + k;\\r\\niv = &(p[n]);\\r\\nn += k;\\r\\ner1 = &(s->s3->server_random[0]);\\r\\ner2 = &(s->s3->client_random[0]);\\r\\n}\\r\\nif (n > s->s3->tmp.key_block_length) {\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\\r\\ngoto err2;\\r\\n}\\r\\nEVP_MD_CTX_init(&md);\\r\\nmemcpy(mac_secret, ms, i);\\r\\nif (is_exp) {\\r\\nEVP_DigestInit_ex(&md, EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md, key, j);\\r\\nEVP_DigestUpdate(&md, er1, SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md, er2, SSL3_RANDOM_SIZE);\\r\\nEVP_DigestFinal_ex(&md, &(exp_key[0]), NULL);\\r\\nkey = &(exp_key[0]);\\r\\nif (k > 0) {\\r\\nEVP_DigestInit_ex(&md, EVP_md5(), NULL);\\r\\nEVP_DigestUpdate(&md, er1, SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&md, er2, SSL3_RANDOM_SIZE);\\r\\nEVP_DigestFinal_ex(&md, &(exp_iv[0]), NULL);\\r\\niv = &(exp_iv[0]);\\r\\n}\\r\\n}\\r\\ns->session->key_arg_length = 0;\\r\\nEVP_CipherInit_ex(dd, c, NULL, key, iv, (which & SSL3_CC_WRITE));\\r\\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\\r\\nif (s->msg_callback) {\\r\\nint wh = which & SSL3_CC_WRITE ?\\r\\nTLS1_RT_CRYPTO_WRITE : TLS1_RT_CRYPTO_READ;\\r\\ns->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_MAC,\\r\\nmac_secret, EVP_MD_size(m), s, s->msg_callback_arg);\\r\\nif (c->key_len)\\r\\ns->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_KEY,\\r\\nkey, c->key_len, s, s->msg_callback_arg);\\r\\nif (k) {\\r\\ns->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_IV,\\r\\niv, k, s, s->msg_callback_arg);\\r\\n}\\r\\n}\\r\\n#endif\\r\\nOPENSSL_cleanse(&(exp_key[0]), sizeof(exp_key));\\r\\nOPENSSL_cleanse(&(exp_iv[0]), sizeof(exp_iv));\\r\\nEVP_MD_CTX_cleanup(&md);\\r\\nreturn (1);\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL3_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\\r\\nerr2:\\r\\nreturn (0);\\r\\n}\\r\\nint ssl3_setup_key_block(SSL *s)\\r\\n{\\r\\nunsigned char *p;\\r\\nconst EVP_CIPHER *c;\\r\\nconst EVP_MD *hash;\\r\\nint num;\\r\\nint ret = 0;\\r\\nSSL_COMP *comp;\\r\\nif (s->s3->tmp.key_block_length != 0)\\r\\nreturn (1);\\r\\nif (!ssl_cipher_get_evp(s->session, &c, &hash, NULL, NULL, &comp)) {\\r\\nSSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\\r\\nreturn (0);\\r\\n}\\r\\ns->s3->tmp.new_sym_enc = c;\\r\\ns->s3->tmp.new_hash = hash;\\r\\n#ifdef OPENSSL_NO_COMP\\r\\ns->s3->tmp.new_compression = NULL;\\r\\n#else\\r\\ns->s3->tmp.new_compression = comp;\\r\\n#endif\\r\\nnum = EVP_MD_size(hash);\\r\\nif (num < 0)\\r\\nreturn 0;\\r\\nnum = EVP_CIPHER_key_length(c) + num + EVP_CIPHER_iv_length(c);\\r\\nnum *= 2;\\r\\nssl3_cleanup_key_block(s);\\r\\nif ((p = OPENSSL_malloc(num)) == NULL)\\r\\ngoto err;\\r\\ns->s3->tmp.key_block_length = num;\\r\\ns->s3->tmp.key_block = p;\\r\\nret = ssl3_generate_key_block(s, p, num);\\r\\nif (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS)) {\\r\\ns->s3->need_empty_fragments = 1;\\r\\nif (s->session->cipher != NULL) {\\r\\nif (s->session->cipher->algorithm_enc == SSL_eNULL)\\r\\ns->s3->need_empty_fragments = 0;\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nif (s->session->cipher->algorithm_enc == SSL_RC4)\\r\\ns->s3->need_empty_fragments = 0;\\r\\n#endif\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\nerr:\\r\\nSSLerr(SSL_F_SSL3_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nvoid ssl3_cleanup_key_block(SSL *s)\\r\\n{\\r\\nif (s->s3->tmp.key_block != NULL) {\\r\\nOPENSSL_cleanse(s->s3->tmp.key_block, s->s3->tmp.key_block_length);\\r\\nOPENSSL_free(s->s3->tmp.key_block);\\r\\ns->s3->tmp.key_block = NULL;\\r\\n}\\r\\ns->s3->tmp.key_block_length = 0;\\r\\n}\\r\\nint ssl3_enc(SSL *s, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nEVP_CIPHER_CTX *ds;\\r\\nunsigned long l;\\r\\nint bs, i, mac_size = 0;\\r\\nconst EVP_CIPHER *enc;\\r\\nif (send) {\\r\\nds = s->enc_write_ctx;\\r\\nrec = &(s->s3->wrec);\\r\\nif (s->enc_write_ctx == NULL)\\r\\nenc = NULL;\\r\\nelse\\r\\nenc = EVP_CIPHER_CTX_cipher(s->enc_write_ctx);\\r\\n} else {\\r\\nds = s->enc_read_ctx;\\r\\nrec = &(s->s3->rrec);\\r\\nif (s->enc_read_ctx == NULL)\\r\\nenc = NULL;\\r\\nelse\\r\\nenc = EVP_CIPHER_CTX_cipher(s->enc_read_ctx);\\r\\n}\\r\\nif ((s->session == NULL) || (ds == NULL) || (enc == NULL)) {\\r\\nmemmove(rec->data, rec->input, rec->length);\\r\\nrec->input = rec->data;\\r\\n} else {\\r\\nl = rec->length;\\r\\nbs = EVP_CIPHER_block_size(ds->cipher);\\r\\nif ((bs != 1) && send) {\\r\\ni = bs - ((int)l % bs);\\r\\nl += i;\\r\\nmemset(&rec->input[rec->length], 0, i);\\r\\nrec->length += i;\\r\\nrec->input[l - 1] = (i - 1);\\r\\n}\\r\\nif (!send) {\\r\\nif (l == 0 || l % bs != 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (EVP_Cipher(ds, rec->data, rec->input, l) < 1)\\r\\nreturn -1;\\r\\nif (EVP_MD_CTX_md(s->read_hash) != NULL)\\r\\nmac_size = EVP_MD_CTX_size(s->read_hash);\\r\\nif ((bs != 1) && !send)\\r\\nreturn ssl3_cbc_remove_padding(s, rec, bs, mac_size);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nvoid ssl3_init_finished_mac(SSL *s)\\r\\n{\\r\\nif (s->s3->handshake_buffer)\\r\\nBIO_free(s->s3->handshake_buffer);\\r\\nif (s->s3->handshake_dgst)\\r\\nssl3_free_digest_list(s);\\r\\ns->s3->handshake_buffer = BIO_new(BIO_s_mem());\\r\\n(void)BIO_set_close(s->s3->handshake_buffer, BIO_CLOSE);\\r\\n}\\r\\nvoid ssl3_free_digest_list(SSL *s)\\r\\n{\\r\\nint i;\\r\\nif (!s->s3->handshake_dgst)\\r\\nreturn;\\r\\nfor (i = 0; i < SSL_MAX_DIGEST; i++) {\\r\\nif (s->s3->handshake_dgst[i])\\r\\nEVP_MD_CTX_destroy(s->s3->handshake_dgst[i]);\\r\\n}\\r\\nOPENSSL_free(s->s3->handshake_dgst);\\r\\ns->s3->handshake_dgst = NULL;\\r\\n}\\r\\nvoid ssl3_finish_mac(SSL *s, const unsigned char *buf, int len)\\r\\n{\\r\\nif (s->s3->handshake_buffer\\r\\n&& !(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) {\\r\\nBIO_write(s->s3->handshake_buffer, (void *)buf, len);\\r\\n} else {\\r\\nint i;\\r\\nfor (i = 0; i < SSL_MAX_DIGEST; i++) {\\r\\nif (s->s3->handshake_dgst[i] != NULL)\\r\\nEVP_DigestUpdate(s->s3->handshake_dgst[i], buf, len);\\r\\n}\\r\\n}\\r\\n}\\r\\nint ssl3_digest_cached_records(SSL *s)\\r\\n{\\r\\nint i;\\r\\nlong mask;\\r\\nconst EVP_MD *md;\\r\\nlong hdatalen;\\r\\nvoid *hdata;\\r\\nssl3_free_digest_list(s);\\r\\ns->s3->handshake_dgst =\\r\\nOPENSSL_malloc(SSL_MAX_DIGEST * sizeof(EVP_MD_CTX *));\\r\\nmemset(s->s3->handshake_dgst, 0, SSL_MAX_DIGEST * sizeof(EVP_MD_CTX *));\\r\\nhdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\\r\\nif (hdatalen <= 0) {\\r\\nSSLerr(SSL_F_SSL3_DIGEST_CACHED_RECORDS, SSL_R_BAD_HANDSHAKE_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; ssl_get_handshake_digest(i, &mask, &md); i++) {\\r\\nif ((mask & ssl_get_algorithm2(s)) && md) {\\r\\ns->s3->handshake_dgst[i] = EVP_MD_CTX_create();\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (EVP_MD_nid(md) == NID_md5) {\\r\\nEVP_MD_CTX_set_flags(s->s3->handshake_dgst[i],\\r\\nEVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\\r\\n}\\r\\n#endif\\r\\nEVP_DigestInit_ex(s->s3->handshake_dgst[i], md, NULL);\\r\\nEVP_DigestUpdate(s->s3->handshake_dgst[i], hdata, hdatalen);\\r\\n} else {\\r\\ns->s3->handshake_dgst[i] = NULL;\\r\\n}\\r\\n}\\r\\nif (!(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) {\\r\\nBIO_free(s->s3->handshake_buffer);\\r\\ns->s3->handshake_buffer = NULL;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ssl3_cert_verify_mac(SSL *s, int md_nid, unsigned char *p)\\r\\n{\\r\\nreturn (ssl3_handshake_mac(s, md_nid, NULL, 0, p));\\r\\n}\\r\\nint ssl3_final_finish_mac(SSL *s,\\r\\nconst char *sender, int len, unsigned char *p)\\r\\n{\\r\\nint ret, sha1len;\\r\\nret = ssl3_handshake_mac(s, NID_md5, sender, len, p);\\r\\nif (ret == 0)\\r\\nreturn 0;\\r\\np += ret;\\r\\nsha1len = ssl3_handshake_mac(s, NID_sha1, sender, len, p);\\r\\nif (sha1len == 0)\\r\\nreturn 0;\\r\\nret += sha1len;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ssl3_handshake_mac(SSL *s, int md_nid,\\r\\nconst char *sender, int len, unsigned char *p)\\r\\n{\\r\\nunsigned int ret;\\r\\nint npad, n;\\r\\nunsigned int i;\\r\\nunsigned char md_buf[EVP_MAX_MD_SIZE];\\r\\nEVP_MD_CTX ctx, *d = NULL;\\r\\nif (s->s3->handshake_buffer)\\r\\nif (!ssl3_digest_cached_records(s))\\r\\nreturn 0;\\r\\nfor (i = 0; i < SSL_MAX_DIGEST; i++) {\\r\\nif (s->s3->handshake_dgst[i]\\r\\n&& EVP_MD_CTX_type(s->s3->handshake_dgst[i]) == md_nid) {\\r\\nd = s->s3->handshake_dgst[i];\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (!d) {\\r\\nSSLerr(SSL_F_SSL3_HANDSHAKE_MAC, SSL_R_NO_REQUIRED_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nEVP_MD_CTX_set_flags(&ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\\r\\nEVP_MD_CTX_copy_ex(&ctx, d);\\r\\nn = EVP_MD_CTX_size(&ctx);\\r\\nif (n < 0)\\r\\nreturn 0;\\r\\nnpad = (48 / n) * n;\\r\\nif (sender != NULL)\\r\\nEVP_DigestUpdate(&ctx, sender, len);\\r\\nEVP_DigestUpdate(&ctx, s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&ctx, ssl3_pad_1, npad);\\r\\nEVP_DigestFinal_ex(&ctx, md_buf, &i);\\r\\nEVP_DigestInit_ex(&ctx, EVP_MD_CTX_md(&ctx), NULL);\\r\\nEVP_DigestUpdate(&ctx, s->session->master_key,\\r\\ns->session->master_key_length);\\r\\nEVP_DigestUpdate(&ctx, ssl3_pad_2, npad);\\r\\nEVP_DigestUpdate(&ctx, md_buf, i);\\r\\nEVP_DigestFinal_ex(&ctx, p, &ret);\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn ((int)ret);\\r\\n}\\r\\nint n_ssl3_mac(SSL *ssl, unsigned char *md, int send)\\r\\n{\\r\\nSSL3_RECORD *rec;\\r\\nunsigned char *mac_sec, *seq;\\r\\nEVP_MD_CTX md_ctx;\\r\\nconst EVP_MD_CTX *hash;\\r\\nunsigned char *p, rec_char;\\r\\nsize_t md_size, orig_len;\\r\\nint npad;\\r\\nint t;\\r\\nif (send) {\\r\\nrec = &(ssl->s3->wrec);\\r\\nmac_sec = &(ssl->s3->write_mac_secret[0]);\\r\\nseq = &(ssl->s3->write_sequence[0]);\\r\\nhash = ssl->write_hash;\\r\\n} else {\\r\\nrec = &(ssl->s3->rrec);\\r\\nmac_sec = &(ssl->s3->read_mac_secret[0]);\\r\\nseq = &(ssl->s3->read_sequence[0]);\\r\\nhash = ssl->read_hash;\\r\\n}\\r\\nt = EVP_MD_CTX_size(hash);\\r\\nif (t < 0)\\r\\nreturn -1;\\r\\nmd_size = t;\\r\\nnpad = (48 / md_size) * md_size;\\r\\norig_len = rec->length + md_size + ((unsigned int)rec->type >> 8);\\r\\nrec->type &= 0xff;\\r\\nif (!send &&\\r\\nEVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\\r\\nssl3_cbc_record_digest_supported(hash)) {\\r\\nunsigned char header[75];\\r\\nunsigned j = 0;\\r\\nmemcpy(header + j, mac_sec, md_size);\\r\\nj += md_size;\\r\\nmemcpy(header + j, ssl3_pad_1, npad);\\r\\nj += npad;\\r\\nmemcpy(header + j, seq, 8);\\r\\nj += 8;\\r\\nheader[j++] = rec->type;\\r\\nheader[j++] = rec->length >> 8;\\r\\nheader[j++] = rec->length & 0xff;\\r\\nssl3_cbc_digest_record(hash,\\r\\nmd, &md_size,\\r\\nheader, rec->input,\\r\\nrec->length + md_size, orig_len,\\r\\nmac_sec, md_size, 1);\\r\\n} else {\\r\\nunsigned int md_size_u;\\r\\nEVP_MD_CTX_init(&md_ctx);\\r\\nEVP_MD_CTX_copy_ex(&md_ctx, hash);\\r\\nEVP_DigestUpdate(&md_ctx, mac_sec, md_size);\\r\\nEVP_DigestUpdate(&md_ctx, ssl3_pad_1, npad);\\r\\nEVP_DigestUpdate(&md_ctx, seq, 8);\\r\\nrec_char = rec->type;\\r\\nEVP_DigestUpdate(&md_ctx, &rec_char, 1);\\r\\np = md;\\r\\ns2n(rec->length, p);\\r\\nEVP_DigestUpdate(&md_ctx, md, 2);\\r\\nEVP_DigestUpdate(&md_ctx, rec->input, rec->length);\\r\\nEVP_DigestFinal_ex(&md_ctx, md, NULL);\\r\\nEVP_MD_CTX_copy_ex(&md_ctx, hash);\\r\\nEVP_DigestUpdate(&md_ctx, mac_sec, md_size);\\r\\nEVP_DigestUpdate(&md_ctx, ssl3_pad_2, npad);\\r\\nEVP_DigestUpdate(&md_ctx, md, md_size);\\r\\nEVP_DigestFinal_ex(&md_ctx, md, &md_size_u);\\r\\nmd_size = md_size_u;\\r\\nEVP_MD_CTX_cleanup(&md_ctx);\\r\\n}\\r\\nssl3_record_sequence_update(seq);\\r\\nreturn (md_size);\\r\\n}\\r\\nvoid ssl3_record_sequence_update(unsigned char *seq)\\r\\n{\\r\\nint i;\\r\\nfor (i = 7; i >= 0; i--) {\\r\\n++seq[i];\\r\\nif (seq[i] != 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nint ssl3_generate_master_secret(SSL *s, unsigned char *out, unsigned char *p,\\r\\nint len)\\r\\n{\\r\\nstatic const unsigned char *salt[3] = {\\r\\n#ifndef CHARSET_EBCDIC\\r\\n(const unsigned char *)\"A\",\\r\\n(const unsigned char *)\"BB\",\\r\\n(const unsigned char *)\"CCC\",\\r\\n#else\\r\\n(const unsigned char *)\"\\x41\",\\r\\n(const unsigned char *)\"\\x42\\x42\",\\r\\n(const unsigned char *)\"\\x43\\x43\\x43\",\\r\\n#endif\\r\\n};\\r\\nunsigned char buf[EVP_MAX_MD_SIZE];\\r\\nEVP_MD_CTX ctx;\\r\\nint i, ret = 0;\\r\\nunsigned int n;\\r\\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\\r\\nunsigned char *tmpout = out;\\r\\n#endif\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nfor (i = 0; i < 3; i++) {\\r\\nEVP_DigestInit_ex(&ctx, s->ctx->sha1, NULL);\\r\\nEVP_DigestUpdate(&ctx, salt[i], strlen((const char *)salt[i]));\\r\\nEVP_DigestUpdate(&ctx, p, len);\\r\\nEVP_DigestUpdate(&ctx, &(s->s3->client_random[0]), SSL3_RANDOM_SIZE);\\r\\nEVP_DigestUpdate(&ctx, &(s->s3->server_random[0]), SSL3_RANDOM_SIZE);\\r\\nEVP_DigestFinal_ex(&ctx, buf, &n);\\r\\nEVP_DigestInit_ex(&ctx, s->ctx->md5, NULL);\\r\\nEVP_DigestUpdate(&ctx, p, len);\\r\\nEVP_DigestUpdate(&ctx, buf, n);\\r\\nEVP_DigestFinal_ex(&ctx, out, &n);\\r\\nout += n;\\r\\nret += n;\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\\r\\nif (s->msg_callback) {\\r\\ns->msg_callback(2, s->version, TLS1_RT_CRYPTO_PREMASTER,\\r\\np, len, s, s->msg_callback_arg);\\r\\ns->msg_callback(2, s->version, TLS1_RT_CRYPTO_CLIENT_RANDOM,\\r\\ns->s3->client_random, SSL3_RANDOM_SIZE,\\r\\ns, s->msg_callback_arg);\\r\\ns->msg_callback(2, s->version, TLS1_RT_CRYPTO_SERVER_RANDOM,\\r\\ns->s3->server_random, SSL3_RANDOM_SIZE,\\r\\ns, s->msg_callback_arg);\\r\\ns->msg_callback(2, s->version, TLS1_RT_CRYPTO_MASTER,\\r\\ntmpout, SSL3_MASTER_SECRET_SIZE,\\r\\ns, s->msg_callback_arg);\\r\\n}\\r\\n#endif\\r\\nreturn (ret);\\r\\n}\\r\\nint ssl3_alert_code(int code)\\r\\n{\\r\\nswitch (code) {\\r\\ncase SSL_AD_CLOSE_NOTIFY:\\r\\nreturn (SSL3_AD_CLOSE_NOTIFY);\\r\\ncase SSL_AD_UNEXPECTED_MESSAGE:\\r\\nreturn (SSL3_AD_UNEXPECTED_MESSAGE);\\r\\ncase SSL_AD_BAD_RECORD_MAC:\\r\\nreturn (SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_DECRYPTION_FAILED:\\r\\nreturn (SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_RECORD_OVERFLOW:\\r\\nreturn (SSL3_AD_BAD_RECORD_MAC);\\r\\ncase SSL_AD_DECOMPRESSION_FAILURE:\\r\\nreturn (SSL3_AD_DECOMPRESSION_FAILURE);\\r\\ncase SSL_AD_HANDSHAKE_FAILURE:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_NO_CERTIFICATE:\\r\\nreturn (SSL3_AD_NO_CERTIFICATE);\\r\\ncase SSL_AD_BAD_CERTIFICATE:\\r\\nreturn (SSL3_AD_BAD_CERTIFICATE);\\r\\ncase SSL_AD_UNSUPPORTED_CERTIFICATE:\\r\\nreturn (SSL3_AD_UNSUPPORTED_CERTIFICATE);\\r\\ncase SSL_AD_CERTIFICATE_REVOKED:\\r\\nreturn (SSL3_AD_CERTIFICATE_REVOKED);\\r\\ncase SSL_AD_CERTIFICATE_EXPIRED:\\r\\nreturn (SSL3_AD_CERTIFICATE_EXPIRED);\\r\\ncase SSL_AD_CERTIFICATE_UNKNOWN:\\r\\nreturn (SSL3_AD_CERTIFICATE_UNKNOWN);\\r\\ncase SSL_AD_ILLEGAL_PARAMETER:\\r\\nreturn (SSL3_AD_ILLEGAL_PARAMETER);\\r\\ncase SSL_AD_UNKNOWN_CA:\\r\\nreturn (SSL3_AD_BAD_CERTIFICATE);\\r\\ncase SSL_AD_ACCESS_DENIED:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_DECODE_ERROR:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_DECRYPT_ERROR:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_EXPORT_RESTRICTION:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_PROTOCOL_VERSION:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_INSUFFICIENT_SECURITY:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_INTERNAL_ERROR:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_USER_CANCELLED:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_NO_RENEGOTIATION:\\r\\nreturn (-1);\\r\\ncase SSL_AD_UNSUPPORTED_EXTENSION:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_CERTIFICATE_UNOBTAINABLE:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_UNRECOGNIZED_NAME:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_BAD_CERTIFICATE_HASH_VALUE:\\r\\nreturn (SSL3_AD_HANDSHAKE_FAILURE);\\r\\ncase SSL_AD_UNKNOWN_PSK_IDENTITY:\\r\\nreturn (TLS1_AD_UNKNOWN_PSK_IDENTITY);\\r\\ncase SSL_AD_INAPPROPRIATE_FALLBACK:\\r\\nreturn (TLS1_AD_INAPPROPRIATE_FALLBACK);\\r\\ndefault:\\r\\nreturn (-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_bignum_c", "target": 0, "func": "static void bn_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nif(!*pval) return;\\r\\nif(it->size & BN_SENSITIVE) BN_clear_free((BIGNUM *)*pval);\\r\\nelse BN_free((BIGNUM *)*pval);\\r\\n*pval = NULL;\\r\\n}\\r\\nstatic int bn_i2c(ASN1_VALUE **pval, unsigned char *cont, int *putype, const ASN1_ITEM *it)\\r\\n{\\r\\nBIGNUM *bn;\\r\\nint pad;\\r\\nif(!*pval) return -1;\\r\\nbn = (BIGNUM *)*pval;\\r\\nif(BN_num_bits(bn) & 0x7) pad = 0;\\r\\nelse pad = 1;\\r\\nif(cont) {\\r\\nif(pad) *cont++ = 0;\\r\\nBN_bn2bin(bn, cont);\\r\\n}\\r\\nreturn pad + BN_num_bytes(bn);\\r\\n}\\r\\nstatic int bn_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,\\r\\nint utype, char *free_cont, const ASN1_ITEM *it)\\r\\n{\\r\\nBIGNUM *bn;\\r\\nif(!*pval) bn_new(pval, it);\\r\\nbn = (BIGNUM *)*pval;\\r\\nif(!BN_bin2bn(cont, len, bn)) {\\r\\nbn_free(pval, it);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_mpi_c", "target": 0, "func": "int BN_bn2mpi(const BIGNUM *a, unsigned char *d)\\r\\n{\\r\\nint bits;\\r\\nint num = 0;\\r\\nint ext = 0;\\r\\nlong l;\\r\\nbits = BN_num_bits(a);\\r\\nnum = (bits + 7) / 8;\\r\\nif (bits > 0) {\\r\\next = ((bits & 0x07) == 0);\\r\\n}\\r\\nif (d == NULL)\\r\\nreturn (num + 4 + ext);\\r\\nl = num + ext;\\r\\nd[0] = (unsigned char)(l >> 24) & 0xff;\\r\\nd[1] = (unsigned char)(l >> 16) & 0xff;\\r\\nd[2] = (unsigned char)(l >> 8) & 0xff;\\r\\nd[3] = (unsigned char)(l) & 0xff;\\r\\nif (ext)\\r\\nd[4] = 0;\\r\\nnum = BN_bn2bin(a, &(d[4 + ext]));\\r\\nif (a->neg)\\r\\nd[4] |= 0x80;\\r\\nreturn (num + 4 + ext);\\r\\n}\\r\\nBIGNUM *BN_mpi2bn(const unsigned char *d, int n, BIGNUM *a)\\r\\n{\\r\\nlong len;\\r\\nint neg = 0;\\r\\nif (n < 4) {\\r\\nBNerr(BN_F_BN_MPI2BN, BN_R_INVALID_LENGTH);\\r\\nreturn (NULL);\\r\\n}\\r\\nlen = ((long)d[0] << 24) | ((long)d[1] << 16) | ((int)d[2] << 8) | (int)\\r\\nd[3];\\r\\nif ((len + 4) != n) {\\r\\nBNerr(BN_F_BN_MPI2BN, BN_R_ENCODING_ERROR);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (a == NULL)\\r\\na = BN_new();\\r\\nif (a == NULL)\\r\\nreturn (NULL);\\r\\nif (len == 0) {\\r\\na->neg = 0;\\r\\na->top = 0;\\r\\nreturn (a);\\r\\n}\\r\\nd += 4;\\r\\nif ((*d) & 0x80)\\r\\nneg = 1;\\r\\nif (BN_bin2bn(d, (int)len, a) == NULL)\\r\\nreturn (NULL);\\r\\na->neg = neg;\\r\\nif (neg) {\\r\\nBN_clear_bit(a, BN_num_bits(a) - 1);\\r\\n}\\r\\nbn_check_top(a);\\r\\nreturn (a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_fcrypt_c", "target": 0, "func": "char *DES_crypt(const char *buf, const char *salt)\\r\\n{\\r\\nstatic char buff[14];\\r\\n#ifndef CHARSET_EBCDIC\\r\\nreturn (DES_fcrypt(buf, salt, buff));\\r\\n#else\\r\\nchar e_salt[2 + 1];\\r\\nchar e_buf[32 + 1];\\r\\nchar *ret;\\r\\nif ((e_salt[0] = salt[0]) != '\\0')\\r\\ne_salt[1] = salt[1];\\r\\nstrncpy(e_buf, buf, sizeof(e_buf));\\r\\ne_salt[sizeof(e_salt) - 1] = e_buf[sizeof(e_buf) - 1] = '\\0';\\r\\nebcdic2ascii(e_salt, e_salt, sizeof e_salt);\\r\\nebcdic2ascii(e_buf, e_buf, sizeof e_buf);\\r\\nret = DES_fcrypt(e_buf, e_salt, buff);\\r\\nascii2ebcdic(ret, ret, strlen(ret));\\r\\nreturn ret;\\r\\n#endif\\r\\n}\\r\\nchar *DES_fcrypt(const char *buf, const char *salt, char *ret)\\r\\n{\\r\\nunsigned int i, j, x, y;\\r\\nDES_LONG Eswap0, Eswap1;\\r\\nDES_LONG out[2], ll;\\r\\nDES_cblock key;\\r\\nDES_key_schedule ks;\\r\\nunsigned char bb[9];\\r\\nunsigned char *b = bb;\\r\\nunsigned char c, u;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nx = ret[0] = ((salt[0] == '\\0') ? 'A' : salt[0]);\\r\\nEswap0 = con_salt[x] << 2;\\r\\nx = ret[1] = ((salt[1] == '\\0') ? 'A' : salt[1]);\\r\\nEswap1 = con_salt[x] << 6;\\r\\n#else\\r\\nx = ret[0] = ((salt[0] == '\\0') ? os_toascii['A'] : salt[0]);\\r\\nEswap0 = con_salt[x] << 2;\\r\\nx = ret[1] = ((salt[1] == '\\0') ? os_toascii['A'] : salt[1]);\\r\\nEswap1 = con_salt[x] << 6;\\r\\n#endif\\r\\nfor (i = 0; i < 8; i++) {\\r\\nc = *(buf++);\\r\\nif (!c)\\r\\nbreak;\\r\\nkey[i] = (c << 1);\\r\\n}\\r\\nfor (; i < 8; i++)\\r\\nkey[i] = 0;\\r\\nDES_set_key_unchecked(&key, &ks);\\r\\nfcrypt_body(&(out[0]), &ks, Eswap0, Eswap1);\\r\\nll = out[0];\\r\\nl2c(ll, b);\\r\\nll = out[1];\\r\\nl2c(ll, b);\\r\\ny = 0;\\r\\nu = 0x80;\\r\\nbb[8] = 0;\\r\\nfor (i = 2; i < 13; i++) {\\r\\nc = 0;\\r\\nfor (j = 0; j < 6; j++) {\\r\\nc <<= 1;\\r\\nif (bb[y] & u)\\r\\nc |= 1;\\r\\nu >>= 1;\\r\\nif (!u) {\\r\\ny++;\\r\\nu = 0x80;\\r\\n}\\r\\n}\\r\\nret[i] = cov_2char[c];\\r\\n}\\r\\nret[13] = '\\0';\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ocsp_err_c", "target": 0, "func": "void ERR_load_OCSP_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(OCSP_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, OCSP_str_functs);\\r\\nERR_load_strings(0, OCSP_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_c_allc_c", "target": 0, "func": "void OpenSSL_add_all_ciphers(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_DES\\r\\nEVP_add_cipher(EVP_des_cfb());\\r\\nEVP_add_cipher(EVP_des_cfb1());\\r\\nEVP_add_cipher(EVP_des_cfb8());\\r\\nEVP_add_cipher(EVP_des_ede_cfb());\\r\\nEVP_add_cipher(EVP_des_ede3_cfb());\\r\\nEVP_add_cipher(EVP_des_ede3_cfb1());\\r\\nEVP_add_cipher(EVP_des_ede3_cfb8());\\r\\nEVP_add_cipher(EVP_des_ofb());\\r\\nEVP_add_cipher(EVP_des_ede_ofb());\\r\\nEVP_add_cipher(EVP_des_ede3_ofb());\\r\\nEVP_add_cipher(EVP_desx_cbc());\\r\\nEVP_add_cipher_alias(SN_desx_cbc, \"DESX\");\\r\\nEVP_add_cipher_alias(SN_desx_cbc, \"desx\");\\r\\nEVP_add_cipher(EVP_des_cbc());\\r\\nEVP_add_cipher_alias(SN_des_cbc, \"DES\");\\r\\nEVP_add_cipher_alias(SN_des_cbc, \"des\");\\r\\nEVP_add_cipher(EVP_des_ede_cbc());\\r\\nEVP_add_cipher(EVP_des_ede3_cbc());\\r\\nEVP_add_cipher_alias(SN_des_ede3_cbc, \"DES3\");\\r\\nEVP_add_cipher_alias(SN_des_ede3_cbc, \"des3\");\\r\\nEVP_add_cipher(EVP_des_ecb());\\r\\nEVP_add_cipher(EVP_des_ede());\\r\\nEVP_add_cipher(EVP_des_ede3());\\r\\nEVP_add_cipher(EVP_des_ede3_wrap());\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC4\\r\\nEVP_add_cipher(EVP_rc4());\\r\\nEVP_add_cipher(EVP_rc4_40());\\r\\n# ifndef OPENSSL_NO_MD5\\r\\nEVP_add_cipher(EVP_rc4_hmac_md5());\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nEVP_add_cipher(EVP_idea_ecb());\\r\\nEVP_add_cipher(EVP_idea_cfb());\\r\\nEVP_add_cipher(EVP_idea_ofb());\\r\\nEVP_add_cipher(EVP_idea_cbc());\\r\\nEVP_add_cipher_alias(SN_idea_cbc, \"IDEA\");\\r\\nEVP_add_cipher_alias(SN_idea_cbc, \"idea\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SEED\\r\\nEVP_add_cipher(EVP_seed_ecb());\\r\\nEVP_add_cipher(EVP_seed_cfb());\\r\\nEVP_add_cipher(EVP_seed_ofb());\\r\\nEVP_add_cipher(EVP_seed_cbc());\\r\\nEVP_add_cipher_alias(SN_seed_cbc, \"SEED\");\\r\\nEVP_add_cipher_alias(SN_seed_cbc, \"seed\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC2\\r\\nEVP_add_cipher(EVP_rc2_ecb());\\r\\nEVP_add_cipher(EVP_rc2_cfb());\\r\\nEVP_add_cipher(EVP_rc2_ofb());\\r\\nEVP_add_cipher(EVP_rc2_cbc());\\r\\nEVP_add_cipher(EVP_rc2_40_cbc());\\r\\nEVP_add_cipher(EVP_rc2_64_cbc());\\r\\nEVP_add_cipher_alias(SN_rc2_cbc, \"RC2\");\\r\\nEVP_add_cipher_alias(SN_rc2_cbc, \"rc2\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_BF\\r\\nEVP_add_cipher(EVP_bf_ecb());\\r\\nEVP_add_cipher(EVP_bf_cfb());\\r\\nEVP_add_cipher(EVP_bf_ofb());\\r\\nEVP_add_cipher(EVP_bf_cbc());\\r\\nEVP_add_cipher_alias(SN_bf_cbc, \"BF\");\\r\\nEVP_add_cipher_alias(SN_bf_cbc, \"bf\");\\r\\nEVP_add_cipher_alias(SN_bf_cbc, \"blowfish\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_CAST\\r\\nEVP_add_cipher(EVP_cast5_ecb());\\r\\nEVP_add_cipher(EVP_cast5_cfb());\\r\\nEVP_add_cipher(EVP_cast5_ofb());\\r\\nEVP_add_cipher(EVP_cast5_cbc());\\r\\nEVP_add_cipher_alias(SN_cast5_cbc, \"CAST\");\\r\\nEVP_add_cipher_alias(SN_cast5_cbc, \"cast\");\\r\\nEVP_add_cipher_alias(SN_cast5_cbc, \"CAST-cbc\");\\r\\nEVP_add_cipher_alias(SN_cast5_cbc, \"cast-cbc\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RC5\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_ecb());\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_cfb());\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_ofb());\\r\\nEVP_add_cipher(EVP_rc5_32_12_16_cbc());\\r\\nEVP_add_cipher_alias(SN_rc5_cbc, \"rc5\");\\r\\nEVP_add_cipher_alias(SN_rc5_cbc, \"RC5\");\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_AES\\r\\nEVP_add_cipher(EVP_aes_128_ecb());\\r\\nEVP_add_cipher(EVP_aes_128_cbc());\\r\\nEVP_add_cipher(EVP_aes_128_cfb());\\r\\nEVP_add_cipher(EVP_aes_128_cfb1());\\r\\nEVP_add_cipher(EVP_aes_128_cfb8());\\r\\nEVP_add_cipher(EVP_aes_128_ofb());\\r\\nEVP_add_cipher(EVP_aes_128_ctr());\\r\\nEVP_add_cipher(EVP_aes_128_gcm());\\r\\nEVP_add_cipher(EVP_aes_128_xts());\\r\\nEVP_add_cipher(EVP_aes_128_ccm());\\r\\nEVP_add_cipher(EVP_aes_128_wrap());\\r\\nEVP_add_cipher_alias(SN_aes_128_cbc, \"AES128\");\\r\\nEVP_add_cipher_alias(SN_aes_128_cbc, \"aes128\");\\r\\nEVP_add_cipher(EVP_aes_192_ecb());\\r\\nEVP_add_cipher(EVP_aes_192_cbc());\\r\\nEVP_add_cipher(EVP_aes_192_cfb());\\r\\nEVP_add_cipher(EVP_aes_192_cfb1());\\r\\nEVP_add_cipher(EVP_aes_192_cfb8());\\r\\nEVP_add_cipher(EVP_aes_192_ofb());\\r\\nEVP_add_cipher(EVP_aes_192_ctr());\\r\\nEVP_add_cipher(EVP_aes_192_gcm());\\r\\nEVP_add_cipher(EVP_aes_192_ccm());\\r\\nEVP_add_cipher(EVP_aes_192_wrap());\\r\\nEVP_add_cipher_alias(SN_aes_192_cbc, \"AES192\");\\r\\nEVP_add_cipher_alias(SN_aes_192_cbc, \"aes192\");\\r\\nEVP_add_cipher(EVP_aes_256_ecb());\\r\\nEVP_add_cipher(EVP_aes_256_cbc());\\r\\nEVP_add_cipher(EVP_aes_256_cfb());\\r\\nEVP_add_cipher(EVP_aes_256_cfb1());\\r\\nEVP_add_cipher(EVP_aes_256_cfb8());\\r\\nEVP_add_cipher(EVP_aes_256_ofb());\\r\\nEVP_add_cipher(EVP_aes_256_ctr());\\r\\nEVP_add_cipher(EVP_aes_256_gcm());\\r\\nEVP_add_cipher(EVP_aes_256_xts());\\r\\nEVP_add_cipher(EVP_aes_256_ccm());\\r\\nEVP_add_cipher(EVP_aes_256_wrap());\\r\\nEVP_add_cipher_alias(SN_aes_256_cbc, \"AES256\");\\r\\nEVP_add_cipher_alias(SN_aes_256_cbc, \"aes256\");\\r\\n# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)\\r\\nEVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());\\r\\nEVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());\\r\\n# endif\\r\\n# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA256)\\r\\nEVP_add_cipher(EVP_aes_128_cbc_hmac_sha256());\\r\\nEVP_add_cipher(EVP_aes_256_cbc_hmac_sha256());\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_CAMELLIA\\r\\nEVP_add_cipher(EVP_camellia_128_ecb());\\r\\nEVP_add_cipher(EVP_camellia_128_cbc());\\r\\nEVP_add_cipher(EVP_camellia_128_cfb());\\r\\nEVP_add_cipher(EVP_camellia_128_cfb1());\\r\\nEVP_add_cipher(EVP_camellia_128_cfb8());\\r\\nEVP_add_cipher(EVP_camellia_128_ofb());\\r\\nEVP_add_cipher_alias(SN_camellia_128_cbc, \"CAMELLIA128\");\\r\\nEVP_add_cipher_alias(SN_camellia_128_cbc, \"camellia128\");\\r\\nEVP_add_cipher(EVP_camellia_192_ecb());\\r\\nEVP_add_cipher(EVP_camellia_192_cbc());\\r\\nEVP_add_cipher(EVP_camellia_192_cfb());\\r\\nEVP_add_cipher(EVP_camellia_192_cfb1());\\r\\nEVP_add_cipher(EVP_camellia_192_cfb8());\\r\\nEVP_add_cipher(EVP_camellia_192_ofb());\\r\\nEVP_add_cipher_alias(SN_camellia_192_cbc, \"CAMELLIA192\");\\r\\nEVP_add_cipher_alias(SN_camellia_192_cbc, \"camellia192\");\\r\\nEVP_add_cipher(EVP_camellia_256_ecb());\\r\\nEVP_add_cipher(EVP_camellia_256_cbc());\\r\\nEVP_add_cipher(EVP_camellia_256_cfb());\\r\\nEVP_add_cipher(EVP_camellia_256_cfb1());\\r\\nEVP_add_cipher(EVP_camellia_256_cfb8());\\r\\nEVP_add_cipher(EVP_camellia_256_ofb());\\r\\nEVP_add_cipher_alias(SN_camellia_256_cbc, \"CAMELLIA256\");\\r\\nEVP_add_cipher_alias(SN_camellia_256_cbc, \"camellia256\");\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_utst_c", "target": 0, "func": "const struct openssl_ssl_test_functions *SSL_test_functions(void)\\r\\n{\\r\\nreturn &ssl_test_functions;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cmll_cbc_c", "target": 0, "func": "void Camellia_cbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const CAMELLIA_KEY *key,\\r\\nunsigned char *ivec, const int enc)\\r\\n{\\r\\nif (enc)\\r\\nCRYPTO_cbc128_encrypt(in, out, len, key, ivec,\\r\\n(block128_f) Camellia_encrypt);\\r\\nelse\\r\\nCRYPTO_cbc128_decrypt(in, out, len, key, ivec,\\r\\n(block128_f) Camellia_decrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_smver_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL, *cont = NULL;\\r\\nX509_STORE *st = NULL;\\r\\nX509 *cacert = NULL;\\r\\nPKCS7 *p7 = NULL;\\r\\nint ret = 1;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\nst = X509_STORE_new();\\r\\ntbio = BIO_new_file(\"cacert.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\ncacert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nif (!cacert)\\r\\ngoto err;\\r\\nif (!X509_STORE_add_cert(st, cacert))\\r\\ngoto err;\\r\\nin = BIO_new_file(\"smout.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\np7 = SMIME_read_PKCS7(in, &cont);\\r\\nif (!p7)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smver.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!PKCS7_verify(p7, NULL, st, cont, out, 0)) {\\r\\nfprintf(stderr, \"Verification Failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nfprintf(stderr, \"Verification Successful\\n\");\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Verifying Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (p7)\\r\\nPKCS7_free(p7);\\r\\nif (cacert)\\r\\nX509_free(cacert);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_txt_c", "target": 0, "func": "const char *X509_verify_cert_error_string(long n)\\r\\n{\\r\\nstatic char buf[100];\\r\\nswitch ((int)n) {\\r\\ncase X509_V_OK:\\r\\nreturn (\"ok\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\nreturn (\"unable to get issuer certificate\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_CRL:\\r\\nreturn (\"unable to get certificate CRL\");\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:\\r\\nreturn (\"unable to decrypt certificate's signature\");\\r\\ncase X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:\\r\\nreturn (\"unable to decrypt CRL's signature\");\\r\\ncase X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:\\r\\nreturn (\"unable to decode issuer public key\");\\r\\ncase X509_V_ERR_CERT_SIGNATURE_FAILURE:\\r\\nreturn (\"certificate signature failure\");\\r\\ncase X509_V_ERR_CRL_SIGNATURE_FAILURE:\\r\\nreturn (\"CRL signature failure\");\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\nreturn (\"certificate is not yet valid\");\\r\\ncase X509_V_ERR_CRL_NOT_YET_VALID:\\r\\nreturn (\"CRL is not yet valid\");\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\nreturn (\"certificate has expired\");\\r\\ncase X509_V_ERR_CRL_HAS_EXPIRED:\\r\\nreturn (\"CRL has expired\");\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\nreturn (\"format error in certificate's notBefore field\");\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\nreturn (\"format error in certificate's notAfter field\");\\r\\ncase X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:\\r\\nreturn (\"format error in CRL's lastUpdate field\");\\r\\ncase X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:\\r\\nreturn (\"format error in CRL's nextUpdate field\");\\r\\ncase X509_V_ERR_OUT_OF_MEM:\\r\\nreturn (\"out of memory\");\\r\\ncase X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\\r\\nreturn (\"self signed certificate\");\\r\\ncase X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:\\r\\nreturn (\"self signed certificate in certificate chain\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\\r\\nreturn (\"unable to get local issuer certificate\");\\r\\ncase X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:\\r\\nreturn (\"unable to verify the first certificate\");\\r\\ncase X509_V_ERR_CERT_CHAIN_TOO_LONG:\\r\\nreturn (\"certificate chain too long\");\\r\\ncase X509_V_ERR_CERT_REVOKED:\\r\\nreturn (\"certificate revoked\");\\r\\ncase X509_V_ERR_INVALID_CA:\\r\\nreturn (\"invalid CA certificate\");\\r\\ncase X509_V_ERR_INVALID_NON_CA:\\r\\nreturn (\"invalid non-CA certificate (has CA markings)\");\\r\\ncase X509_V_ERR_PATH_LENGTH_EXCEEDED:\\r\\nreturn (\"path length constraint exceeded\");\\r\\ncase X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED:\\r\\nreturn (\"proxy path length constraint exceeded\");\\r\\ncase X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED:\\r\\nreturn\\r\\n(\"proxy certificates not allowed, please set the appropriate flag\");\\r\\ncase X509_V_ERR_INVALID_PURPOSE:\\r\\nreturn (\"unsupported certificate purpose\");\\r\\ncase X509_V_ERR_CERT_UNTRUSTED:\\r\\nreturn (\"certificate not trusted\");\\r\\ncase X509_V_ERR_CERT_REJECTED:\\r\\nreturn (\"certificate rejected\");\\r\\ncase X509_V_ERR_APPLICATION_VERIFICATION:\\r\\nreturn (\"application verification failure\");\\r\\ncase X509_V_ERR_SUBJECT_ISSUER_MISMATCH:\\r\\nreturn (\"subject issuer mismatch\");\\r\\ncase X509_V_ERR_AKID_SKID_MISMATCH:\\r\\nreturn (\"authority and subject key identifier mismatch\");\\r\\ncase X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH:\\r\\nreturn (\"authority and issuer serial number mismatch\");\\r\\ncase X509_V_ERR_KEYUSAGE_NO_CERTSIGN:\\r\\nreturn (\"key usage does not include certificate signing\");\\r\\ncase X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER:\\r\\nreturn (\"unable to get CRL issuer certificate\");\\r\\ncase X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION:\\r\\nreturn (\"unhandled critical extension\");\\r\\ncase X509_V_ERR_KEYUSAGE_NO_CRL_SIGN:\\r\\nreturn (\"key usage does not include CRL signing\");\\r\\ncase X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE:\\r\\nreturn (\"key usage does not include digital signature\");\\r\\ncase X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION:\\r\\nreturn (\"unhandled critical CRL extension\");\\r\\ncase X509_V_ERR_INVALID_EXTENSION:\\r\\nreturn (\"invalid or inconsistent certificate extension\");\\r\\ncase X509_V_ERR_INVALID_POLICY_EXTENSION:\\r\\nreturn (\"invalid or inconsistent certificate policy extension\");\\r\\ncase X509_V_ERR_NO_EXPLICIT_POLICY:\\r\\nreturn (\"no explicit policy\");\\r\\ncase X509_V_ERR_DIFFERENT_CRL_SCOPE:\\r\\nreturn (\"Different CRL scope\");\\r\\ncase X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE:\\r\\nreturn (\"Unsupported extension feature\");\\r\\ncase X509_V_ERR_UNNESTED_RESOURCE:\\r\\nreturn (\"RFC 3779 resource not subset of parent's resources\");\\r\\ncase X509_V_ERR_PERMITTED_VIOLATION:\\r\\nreturn (\"permitted subtree violation\");\\r\\ncase X509_V_ERR_EXCLUDED_VIOLATION:\\r\\nreturn (\"excluded subtree violation\");\\r\\ncase X509_V_ERR_SUBTREE_MINMAX:\\r\\nreturn (\"name constraints minimum and maximum not supported\");\\r\\ncase X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE:\\r\\nreturn (\"unsupported name constraint type\");\\r\\ncase X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX:\\r\\nreturn (\"unsupported or invalid name constraint syntax\");\\r\\ncase X509_V_ERR_UNSUPPORTED_NAME_SYNTAX:\\r\\nreturn (\"unsupported or invalid name syntax\");\\r\\ncase X509_V_ERR_CRL_PATH_VALIDATION_ERROR:\\r\\nreturn (\"CRL path validation error\");\\r\\ncase X509_V_ERR_SUITE_B_INVALID_VERSION:\\r\\nreturn (\"Suite B: certificate version invalid\");\\r\\ncase X509_V_ERR_SUITE_B_INVALID_ALGORITHM:\\r\\nreturn (\"Suite B: invalid public key algorithm\");\\r\\ncase X509_V_ERR_SUITE_B_INVALID_CURVE:\\r\\nreturn (\"Suite B: invalid ECC curve\");\\r\\ncase X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM:\\r\\nreturn (\"Suite B: invalid signature algorithm\");\\r\\ncase X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED:\\r\\nreturn (\"Suite B: curve not allowed for this LOS\");\\r\\ncase X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256:\\r\\nreturn (\"Suite B: cannot sign P-384 with P-256\");\\r\\ncase X509_V_ERR_HOSTNAME_MISMATCH:\\r\\nreturn (\"Hostname mismatch\");\\r\\ncase X509_V_ERR_EMAIL_MISMATCH:\\r\\nreturn (\"Email address mismatch\");\\r\\ncase X509_V_ERR_IP_ADDRESS_MISMATCH:\\r\\nreturn (\"IP address mismatch\");\\r\\ndefault:\\r\\nBIO_snprintf(buf, sizeof buf, \"error number %ld\", n);\\r\\nreturn (buf);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3prin_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nX509 *cert;\\r\\nFILE *inf;\\r\\nint i, count;\\r\\nX509_EXTENSION *ext;\\r\\nX509V3_add_standard_extensions();\\r\\nERR_load_crypto_strings();\\r\\nif (!argv[1]) {\\r\\nfprintf(stderr, \"Usage v3prin cert.pem\\n\");\\r\\nexit(1);\\r\\n}\\r\\nif (!(inf = fopen(argv[1], \"r\"))) {\\r\\nfprintf(stderr, \"Can't open %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\nif (!(cert = PEM_read_X509(inf, NULL, NULL))) {\\r\\nfprintf(stderr, \"Can't read certificate %s\\n\", argv[1]);\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\nfclose(inf);\\r\\ncount = X509_get_ext_count(cert);\\r\\nprintf(\"%d extensions\\n\", count);\\r\\nfor (i = 0; i < count; i++) {\\r\\next = X509_get_ext(cert, i);\\r\\nprintf(\"%s\\n\", OBJ_nid2ln(OBJ_obj2nid(ext->object)));\\r\\nif (!X509V3_EXT_print_fp(stdout, ext, 0, 0))\\r\\nERR_print_errors_fp(stderr);\\r\\nprintf(\"\\n\");\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t1_ext_c", "target": 0, "func": "static custom_ext_method *custom_ext_find(custom_ext_methods *exts,\\r\\nunsigned int ext_type)\\r\\n{\\r\\nsize_t i;\\r\\ncustom_ext_method *meth = exts->meths;\\r\\nfor (i = 0; i < exts->meths_count; i++, meth++) {\\r\\nif (ext_type == meth->ext_type)\\r\\nreturn meth;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nvoid custom_ext_init(custom_ext_methods *exts)\\r\\n{\\r\\nsize_t i;\\r\\ncustom_ext_method *meth = exts->meths;\\r\\nfor (i = 0; i < exts->meths_count; i++, meth++)\\r\\nmeth->ext_flags = 0;\\r\\n}\\r\\nint custom_ext_parse(SSL *s, int server,\\r\\nunsigned int ext_type,\\r\\nconst unsigned char *ext_data, size_t ext_size, int *al)\\r\\n{\\r\\ncustom_ext_methods *exts = server ? &s->cert->srv_ext : &s->cert->cli_ext;\\r\\ncustom_ext_method *meth;\\r\\nmeth = custom_ext_find(exts, ext_type);\\r\\nif (!meth)\\r\\nreturn 1;\\r\\nif (!server) {\\r\\nif (!(meth->ext_flags & SSL_EXT_FLAG_SENT)) {\\r\\n*al = TLS1_AD_UNSUPPORTED_EXTENSION;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (meth->ext_flags & SSL_EXT_FLAG_RECEIVED) {\\r\\n*al = TLS1_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nmeth->ext_flags |= SSL_EXT_FLAG_RECEIVED;\\r\\nif (!meth->parse_cb)\\r\\nreturn 1;\\r\\nreturn meth->parse_cb(s, ext_type, ext_data, ext_size, al,\\r\\nmeth->parse_arg);\\r\\n}\\r\\nint custom_ext_add(SSL *s, int server,\\r\\nunsigned char **pret, unsigned char *limit, int *al)\\r\\n{\\r\\ncustom_ext_methods *exts = server ? &s->cert->srv_ext : &s->cert->cli_ext;\\r\\ncustom_ext_method *meth;\\r\\nunsigned char *ret = *pret;\\r\\nsize_t i;\\r\\nfor (i = 0; i < exts->meths_count; i++) {\\r\\nconst unsigned char *out = NULL;\\r\\nsize_t outlen = 0;\\r\\nmeth = exts->meths + i;\\r\\nif (server) {\\r\\nif (!(meth->ext_flags & SSL_EXT_FLAG_RECEIVED))\\r\\ncontinue;\\r\\nif (!meth->add_cb)\\r\\ncontinue;\\r\\n}\\r\\nif (meth->add_cb) {\\r\\nint cb_retval = 0;\\r\\ncb_retval = meth->add_cb(s, meth->ext_type,\\r\\n&out, &outlen, al, meth->add_arg);\\r\\nif (cb_retval < 0)\\r\\nreturn 0;\\r\\nif (cb_retval == 0)\\r\\ncontinue;\\r\\n}\\r\\nif (4 > limit - ret || outlen > (size_t)(limit - ret - 4))\\r\\nreturn 0;\\r\\ns2n(meth->ext_type, ret);\\r\\ns2n(outlen, ret);\\r\\nif (outlen) {\\r\\nmemcpy(ret, out, outlen);\\r\\nret += outlen;\\r\\n}\\r\\nOPENSSL_assert(!(meth->ext_flags & SSL_EXT_FLAG_SENT));\\r\\nmeth->ext_flags |= SSL_EXT_FLAG_SENT;\\r\\nif (meth->free_cb)\\r\\nmeth->free_cb(s, meth->ext_type, out, meth->add_arg);\\r\\n}\\r\\n*pret = ret;\\r\\nreturn 1;\\r\\n}\\r\\nint custom_exts_copy(custom_ext_methods *dst, const custom_ext_methods *src)\\r\\n{\\r\\nif (src->meths_count) {\\r\\ndst->meths =\\r\\nBUF_memdup(src->meths,\\r\\nsizeof(custom_ext_method) * src->meths_count);\\r\\nif (dst->meths == NULL)\\r\\nreturn 0;\\r\\ndst->meths_count = src->meths_count;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid custom_exts_free(custom_ext_methods *exts)\\r\\n{\\r\\nif (exts->meths)\\r\\nOPENSSL_free(exts->meths);\\r\\n}\\r\\nstatic int custom_ext_meth_add(custom_ext_methods *exts,\\r\\nunsigned int ext_type,\\r\\ncustom_ext_add_cb add_cb,\\r\\ncustom_ext_free_cb free_cb,\\r\\nvoid *add_arg,\\r\\ncustom_ext_parse_cb parse_cb, void *parse_arg)\\r\\n{\\r\\ncustom_ext_method *meth;\\r\\nif (!add_cb && free_cb)\\r\\nreturn 0;\\r\\nif (SSL_extension_supported(ext_type))\\r\\nreturn 0;\\r\\nif (ext_type > 0xffff)\\r\\nreturn 0;\\r\\nif (custom_ext_find(exts, ext_type))\\r\\nreturn 0;\\r\\nexts->meths = OPENSSL_realloc(exts->meths,\\r\\n(exts->meths_count +\\r\\n1) * sizeof(custom_ext_method));\\r\\nif (!exts->meths) {\\r\\nexts->meths_count = 0;\\r\\nreturn 0;\\r\\n}\\r\\nmeth = exts->meths + exts->meths_count;\\r\\nmemset(meth, 0, sizeof(custom_ext_method));\\r\\nmeth->parse_cb = parse_cb;\\r\\nmeth->add_cb = add_cb;\\r\\nmeth->free_cb = free_cb;\\r\\nmeth->ext_type = ext_type;\\r\\nmeth->add_arg = add_arg;\\r\\nmeth->parse_arg = parse_arg;\\r\\nexts->meths_count++;\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_CTX_add_client_custom_ext(SSL_CTX *ctx, unsigned int ext_type,\\r\\ncustom_ext_add_cb add_cb,\\r\\ncustom_ext_free_cb free_cb,\\r\\nvoid *add_arg,\\r\\ncustom_ext_parse_cb parse_cb,\\r\\nvoid *parse_arg)\\r\\n{\\r\\nreturn custom_ext_meth_add(&ctx->cert->cli_ext, ext_type,\\r\\nadd_cb, free_cb, add_arg, parse_cb, parse_arg);\\r\\n}\\r\\nint SSL_CTX_add_server_custom_ext(SSL_CTX *ctx, unsigned int ext_type,\\r\\ncustom_ext_add_cb add_cb,\\r\\ncustom_ext_free_cb free_cb,\\r\\nvoid *add_arg,\\r\\ncustom_ext_parse_cb parse_cb,\\r\\nvoid *parse_arg)\\r\\n{\\r\\nreturn custom_ext_meth_add(&ctx->cert->srv_ext, ext_type,\\r\\nadd_cb, free_cb, add_arg, parse_cb, parse_arg);\\r\\n}\\r\\nint SSL_extension_supported(unsigned int ext_type)\\r\\n{\\r\\nswitch (ext_type) {\\r\\ncase TLSEXT_TYPE_application_layer_protocol_negotiation:\\r\\ncase TLSEXT_TYPE_ec_point_formats:\\r\\ncase TLSEXT_TYPE_elliptic_curves:\\r\\ncase TLSEXT_TYPE_heartbeat:\\r\\ncase TLSEXT_TYPE_next_proto_neg:\\r\\ncase TLSEXT_TYPE_padding:\\r\\ncase TLSEXT_TYPE_renegotiate:\\r\\ncase TLSEXT_TYPE_server_name:\\r\\ncase TLSEXT_TYPE_session_ticket:\\r\\ncase TLSEXT_TYPE_signature_algorithms:\\r\\ncase TLSEXT_TYPE_srp:\\r\\ncase TLSEXT_TYPE_status_request:\\r\\ncase TLSEXT_TYPE_use_srtp:\\r\\n# ifdef TLSEXT_TYPE_opaque_prf_input\\r\\ncase TLSEXT_TYPE_opaque_prf_input:\\r\\n# endif\\r\\n# ifdef TLSEXT_TYPE_encrypt_then_mac\\r\\ncase TLSEXT_TYPE_encrypt_then_mac:\\r\\n# endif\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pk7_mime_c", "target": 0, "func": "int i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)\\r\\n{\\r\\nreturn i2d_ASN1_bio_stream(out, (ASN1_VALUE *)p7, in, flags,\\r\\nASN1_ITEM_rptr(PKCS7));\\r\\n}\\r\\nint PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags)\\r\\n{\\r\\nreturn PEM_write_bio_ASN1_stream(out, (ASN1_VALUE *)p7, in, flags,\\r\\n\"PKCS7\", ASN1_ITEM_rptr(PKCS7));\\r\\n}\\r\\nint SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\\r\\n{\\r\\nSTACK_OF(X509_ALGOR) *mdalgs;\\r\\nint ctype_nid = OBJ_obj2nid(p7->type);\\r\\nif (ctype_nid == NID_pkcs7_signed)\\r\\nmdalgs = p7->d.sign->md_algs;\\r\\nelse\\r\\nmdalgs = NULL;\\r\\nflags ^= SMIME_OLDMIME;\\r\\nreturn SMIME_write_ASN1(bio, (ASN1_VALUE *)p7, data, flags,\\r\\nctype_nid, NID_undef, mdalgs,\\r\\nASN1_ITEM_rptr(PKCS7));\\r\\n}\\r\\nPKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont)\\r\\n{\\r\\nreturn (PKCS7 *)SMIME_read_ASN1(bio, bcont, ASN1_ITEM_rptr(PKCS7));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_pmeth_c", "target": 0, "func": "static int pkey_ec_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nEC_PKEY_CTX *dctx;\\r\\ndctx = OPENSSL_malloc(sizeof(EC_PKEY_CTX));\\r\\nif (!dctx)\\r\\nreturn 0;\\r\\ndctx->gen_group = NULL;\\r\\ndctx->md = NULL;\\r\\ndctx->cofactor_mode = -1;\\r\\ndctx->co_key = NULL;\\r\\ndctx->kdf_type = EVP_PKEY_ECDH_KDF_NONE;\\r\\ndctx->kdf_md = NULL;\\r\\ndctx->kdf_outlen = 0;\\r\\ndctx->kdf_ukm = NULL;\\r\\ndctx->kdf_ukmlen = 0;\\r\\nctx->data = dctx;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_ec_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)\\r\\n{\\r\\nEC_PKEY_CTX *dctx, *sctx;\\r\\nif (!pkey_ec_init(dst))\\r\\nreturn 0;\\r\\nsctx = src->data;\\r\\ndctx = dst->data;\\r\\nif (sctx->gen_group) {\\r\\ndctx->gen_group = EC_GROUP_dup(sctx->gen_group);\\r\\nif (!dctx->gen_group)\\r\\nreturn 0;\\r\\n}\\r\\ndctx->md = sctx->md;\\r\\nif (sctx->co_key) {\\r\\ndctx->co_key = EC_KEY_dup(sctx->co_key);\\r\\nif (!dctx->co_key)\\r\\nreturn 0;\\r\\n}\\r\\ndctx->kdf_type = sctx->kdf_type;\\r\\ndctx->kdf_md = sctx->kdf_md;\\r\\ndctx->kdf_outlen = sctx->kdf_outlen;\\r\\nif (sctx->kdf_ukm) {\\r\\ndctx->kdf_ukm = BUF_memdup(sctx->kdf_ukm, sctx->kdf_ukmlen);\\r\\nif (!dctx->kdf_ukm)\\r\\nreturn 0;\\r\\n} else\\r\\ndctx->kdf_ukm = NULL;\\r\\ndctx->kdf_ukmlen = sctx->kdf_ukmlen;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void pkey_ec_cleanup(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nEC_PKEY_CTX *dctx = ctx->data;\\r\\nif (dctx) {\\r\\nif (dctx->gen_group)\\r\\nEC_GROUP_free(dctx->gen_group);\\r\\nif (dctx->co_key)\\r\\nEC_KEY_free(dctx->co_key);\\r\\nif (dctx->kdf_ukm)\\r\\nOPENSSL_free(dctx->kdf_ukm);\\r\\nOPENSSL_free(dctx);\\r\\n}\\r\\n}\\r\\nstatic int pkey_ec_sign(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,\\r\\nconst unsigned char *tbs, size_t tbslen)\\r\\n{\\r\\nint ret, type;\\r\\nunsigned int sltmp;\\r\\nEC_PKEY_CTX *dctx = ctx->data;\\r\\nEC_KEY *ec = ctx->pkey->pkey.ec;\\r\\nif (!sig) {\\r\\n*siglen = ECDSA_size(ec);\\r\\nreturn 1;\\r\\n} else if (*siglen < (size_t)ECDSA_size(ec)) {\\r\\nECerr(EC_F_PKEY_EC_SIGN, EC_R_BUFFER_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nif (dctx->md)\\r\\ntype = EVP_MD_type(dctx->md);\\r\\nelse\\r\\ntype = NID_sha1;\\r\\nret = ECDSA_sign(type, tbs, tbslen, sig, &sltmp, ec);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\n*siglen = (size_t)sltmp;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_ec_verify(EVP_PKEY_CTX *ctx,\\r\\nconst unsigned char *sig, size_t siglen,\\r\\nconst unsigned char *tbs, size_t tbslen)\\r\\n{\\r\\nint ret, type;\\r\\nEC_PKEY_CTX *dctx = ctx->data;\\r\\nEC_KEY *ec = ctx->pkey->pkey.ec;\\r\\nif (dctx->md)\\r\\ntype = EVP_MD_type(dctx->md);\\r\\nelse\\r\\ntype = NID_sha1;\\r\\nret = ECDSA_verify(type, tbs, tbslen, sig, siglen, ec);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int pkey_ec_derive(EVP_PKEY_CTX *ctx, unsigned char *key,\\r\\nsize_t *keylen)\\r\\n{\\r\\nint ret;\\r\\nsize_t outlen;\\r\\nconst EC_POINT *pubkey = NULL;\\r\\nEC_KEY *eckey;\\r\\nEC_PKEY_CTX *dctx = ctx->data;\\r\\nif (!ctx->pkey || !ctx->peerkey) {\\r\\nECerr(EC_F_PKEY_EC_DERIVE, EC_R_KEYS_NOT_SET);\\r\\nreturn 0;\\r\\n}\\r\\neckey = dctx->co_key ? dctx->co_key : ctx->pkey->pkey.ec;\\r\\nif (!key) {\\r\\nconst EC_GROUP *group;\\r\\ngroup = EC_KEY_get0_group(eckey);\\r\\n*keylen = (EC_GROUP_get_degree(group) + 7) / 8;\\r\\nreturn 1;\\r\\n}\\r\\npubkey = EC_KEY_get0_public_key(ctx->peerkey->pkey.ec);\\r\\noutlen = *keylen;\\r\\nret = ECDH_compute_key(key, outlen, pubkey, eckey, 0);\\r\\nif (ret <= 0)\\r\\nreturn 0;\\r\\n*keylen = ret;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_ec_kdf_derive(EVP_PKEY_CTX *ctx,\\r\\nunsigned char *key, size_t *keylen)\\r\\n{\\r\\nEC_PKEY_CTX *dctx = ctx->data;\\r\\nunsigned char *ktmp = NULL;\\r\\nsize_t ktmplen;\\r\\nint rv = 0;\\r\\nif (dctx->kdf_type == EVP_PKEY_ECDH_KDF_NONE)\\r\\nreturn pkey_ec_derive(ctx, key, keylen);\\r\\nif (!key) {\\r\\n*keylen = dctx->kdf_outlen;\\r\\nreturn 1;\\r\\n}\\r\\nif (*keylen != dctx->kdf_outlen)\\r\\nreturn 0;\\r\\nif (!pkey_ec_derive(ctx, NULL, &ktmplen))\\r\\nreturn 0;\\r\\nktmp = OPENSSL_malloc(ktmplen);\\r\\nif (!ktmp)\\r\\nreturn 0;\\r\\nif (!pkey_ec_derive(ctx, ktmp, &ktmplen))\\r\\ngoto err;\\r\\nif (!ECDH_KDF_X9_62(key, *keylen, ktmp, ktmplen,\\r\\ndctx->kdf_ukm, dctx->kdf_ukmlen, dctx->kdf_md))\\r\\ngoto err;\\r\\nrv = 1;\\r\\nerr:\\r\\nif (ktmp) {\\r\\nOPENSSL_cleanse(ktmp, ktmplen);\\r\\nOPENSSL_free(ktmp);\\r\\n}\\r\\nreturn rv;\\r\\n}\\r\\nstatic int pkey_ec_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)\\r\\n{\\r\\nEC_PKEY_CTX *dctx = ctx->data;\\r\\nEC_GROUP *group;\\r\\nswitch (type) {\\r\\ncase EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID:\\r\\ngroup = EC_GROUP_new_by_curve_name(p1);\\r\\nif (group == NULL) {\\r\\nECerr(EC_F_PKEY_EC_CTRL, EC_R_INVALID_CURVE);\\r\\nreturn 0;\\r\\n}\\r\\nif (dctx->gen_group)\\r\\nEC_GROUP_free(dctx->gen_group);\\r\\ndctx->gen_group = group;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_EC_PARAM_ENC:\\r\\nif (!dctx->gen_group) {\\r\\nECerr(EC_F_PKEY_EC_CTRL, EC_R_NO_PARAMETERS_SET);\\r\\nreturn 0;\\r\\n}\\r\\nEC_GROUP_set_asn1_flag(dctx->gen_group, p1);\\r\\nreturn 1;\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase EVP_PKEY_CTRL_EC_ECDH_COFACTOR:\\r\\nif (p1 == -2) {\\r\\nif (dctx->cofactor_mode != -1)\\r\\nreturn dctx->cofactor_mode;\\r\\nelse {\\r\\nEC_KEY *ec_key = ctx->pkey->pkey.ec;\\r\\nreturn EC_KEY_get_flags(ec_key) & EC_FLAG_COFACTOR_ECDH ? 1 :\\r\\n0;\\r\\n}\\r\\n} else if (p1 < -1 || p1 > 1)\\r\\nreturn -2;\\r\\ndctx->cofactor_mode = p1;\\r\\nif (p1 != -1) {\\r\\nEC_KEY *ec_key = ctx->pkey->pkey.ec;\\r\\nif (!ec_key->group)\\r\\nreturn -2;\\r\\nif (BN_is_one(&ec_key->group->cofactor))\\r\\nreturn 1;\\r\\nif (!dctx->co_key) {\\r\\ndctx->co_key = EC_KEY_dup(ec_key);\\r\\nif (!dctx->co_key)\\r\\nreturn 0;\\r\\n}\\r\\nif (p1)\\r\\nEC_KEY_set_flags(dctx->co_key, EC_FLAG_COFACTOR_ECDH);\\r\\nelse\\r\\nEC_KEY_clear_flags(dctx->co_key, EC_FLAG_COFACTOR_ECDH);\\r\\n} else if (dctx->co_key) {\\r\\nEC_KEY_free(dctx->co_key);\\r\\ndctx->co_key = NULL;\\r\\n}\\r\\nreturn 1;\\r\\n#endif\\r\\ncase EVP_PKEY_CTRL_EC_KDF_TYPE:\\r\\nif (p1 == -2)\\r\\nreturn dctx->kdf_type;\\r\\nif (p1 != EVP_PKEY_ECDH_KDF_NONE && p1 != EVP_PKEY_ECDH_KDF_X9_62)\\r\\nreturn -2;\\r\\ndctx->kdf_type = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_EC_KDF_MD:\\r\\ndctx->kdf_md = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_EC_KDF_MD:\\r\\n*(const EVP_MD **)p2 = dctx->kdf_md;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_EC_KDF_OUTLEN:\\r\\nif (p1 <= 0)\\r\\nreturn -2;\\r\\ndctx->kdf_outlen = (size_t)p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN:\\r\\n*(int *)p2 = dctx->kdf_outlen;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_EC_KDF_UKM:\\r\\nif (dctx->kdf_ukm)\\r\\nOPENSSL_free(dctx->kdf_ukm);\\r\\ndctx->kdf_ukm = p2;\\r\\nif (p2)\\r\\ndctx->kdf_ukmlen = p1;\\r\\nelse\\r\\ndctx->kdf_ukmlen = 0;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_EC_KDF_UKM:\\r\\n*(unsigned char **)p2 = dctx->kdf_ukm;\\r\\nreturn dctx->kdf_ukmlen;\\r\\ncase EVP_PKEY_CTRL_MD:\\r\\nif (EVP_MD_type((const EVP_MD *)p2) != NID_sha1 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_ecdsa_with_SHA1 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha224 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha256 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha384 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha512) {\\r\\nECerr(EC_F_PKEY_EC_CTRL, EC_R_INVALID_DIGEST_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\ndctx->md = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_MD:\\r\\n*(const EVP_MD **)p2 = dctx->md;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_PEER_KEY:\\r\\ncase EVP_PKEY_CTRL_DIGESTINIT:\\r\\ncase EVP_PKEY_CTRL_PKCS7_SIGN:\\r\\ncase EVP_PKEY_CTRL_CMS_SIGN:\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\n}\\r\\nstatic int pkey_ec_ctrl_str(EVP_PKEY_CTX *ctx,\\r\\nconst char *type, const char *value)\\r\\n{\\r\\nif (!strcmp(type, \"ec_paramgen_curve\")) {\\r\\nint nid;\\r\\nnid = EC_curve_nist2nid(value);\\r\\nif (nid == NID_undef)\\r\\nnid = OBJ_sn2nid(value);\\r\\nif (nid == NID_undef)\\r\\nnid = OBJ_ln2nid(value);\\r\\nif (nid == NID_undef) {\\r\\nECerr(EC_F_PKEY_EC_CTRL_STR, EC_R_INVALID_CURVE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid);\\r\\n} else if (!strcmp(type, \"ec_param_enc\")) {\\r\\nint param_enc;\\r\\nif (!strcmp(value, \"explicit\"))\\r\\nparam_enc = 0;\\r\\nelse if (!strcmp(value, \"named_curve\"))\\r\\nparam_enc = OPENSSL_EC_NAMED_CURVE;\\r\\nelse\\r\\nreturn -2;\\r\\nreturn EVP_PKEY_CTX_set_ec_param_enc(ctx, param_enc);\\r\\n} else if (!strcmp(type, \"ecdh_kdf_md\")) {\\r\\nconst EVP_MD *md;\\r\\nif (!(md = EVP_get_digestbyname(value))) {\\r\\nECerr(EC_F_PKEY_EC_CTRL_STR, EC_R_INVALID_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EVP_PKEY_CTX_set_ecdh_kdf_md(ctx, md);\\r\\n} else if (!strcmp(type, \"ecdh_cofactor_mode\")) {\\r\\nint co_mode;\\r\\nco_mode = atoi(value);\\r\\nreturn EVP_PKEY_CTX_set_ecdh_cofactor_mode(ctx, co_mode);\\r\\n}\\r\\nreturn -2;\\r\\n}\\r\\nstatic int pkey_ec_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nEC_KEY *ec = NULL;\\r\\nEC_PKEY_CTX *dctx = ctx->data;\\r\\nint ret = 0;\\r\\nif (dctx->gen_group == NULL) {\\r\\nECerr(EC_F_PKEY_EC_PARAMGEN, EC_R_NO_PARAMETERS_SET);\\r\\nreturn 0;\\r\\n}\\r\\nec = EC_KEY_new();\\r\\nif (!ec)\\r\\nreturn 0;\\r\\nret = EC_KEY_set_group(ec, dctx->gen_group);\\r\\nif (ret)\\r\\nEVP_PKEY_assign_EC_KEY(pkey, ec);\\r\\nelse\\r\\nEC_KEY_free(ec);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int pkey_ec_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nEC_KEY *ec = NULL;\\r\\nEC_PKEY_CTX *dctx = ctx->data;\\r\\nif (ctx->pkey == NULL && dctx->gen_group == NULL) {\\r\\nECerr(EC_F_PKEY_EC_KEYGEN, EC_R_NO_PARAMETERS_SET);\\r\\nreturn 0;\\r\\n}\\r\\nec = EC_KEY_new();\\r\\nif (!ec)\\r\\nreturn 0;\\r\\nEVP_PKEY_assign_EC_KEY(pkey, ec);\\r\\nif (ctx->pkey) {\\r\\nif (!EVP_PKEY_copy_parameters(pkey, ctx->pkey))\\r\\nreturn 0;\\r\\n} else {\\r\\nif (!EC_KEY_set_group(ec, dctx->gen_group))\\r\\nreturn 0;\\r\\n}\\r\\nreturn EC_KEY_generate_key(pkey->pkey.ec);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_sign2_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL;\\r\\nX509 *scert = NULL, *scert2 = NULL;\\r\\nEVP_PKEY *skey = NULL, *skey2 = NULL;\\r\\nCMS_ContentInfo *cms = NULL;\\r\\nint ret = 1;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\ntbio = BIO_new_file(\"signer.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nscert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nBIO_reset(tbio);\\r\\nskey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);\\r\\nBIO_free(tbio);\\r\\ntbio = BIO_new_file(\"signer2.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nscert2 = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nBIO_reset(tbio);\\r\\nskey2 = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);\\r\\nif (!scert2 || !skey2)\\r\\ngoto err;\\r\\nin = BIO_new_file(\"sign.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\ncms = CMS_sign(NULL, NULL, NULL, in, CMS_STREAM | CMS_PARTIAL);\\r\\nif (!cms)\\r\\ngoto err;\\r\\nif (!CMS_add1_signer(cms, scert, skey, NULL, 0))\\r\\ngoto err;\\r\\nif (!CMS_add1_signer(cms, scert2, skey2, NULL, 0))\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smout.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!SMIME_write_CMS(out, cms, in, CMS_STREAM))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Signing Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nif (scert)\\r\\nX509_free(scert);\\r\\nif (skey)\\r\\nEVP_PKEY_free(skey);\\r\\nif (scert2)\\r\\nX509_free(scert2);\\r\\nif (skey)\\r\\nEVP_PKEY_free(skey2);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_cbc_c", "target": 0, "func": "void BF_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nconst BF_KEY *schedule, unsigned char *ivec, int encrypt)\\r\\n{\\r\\nregister BF_LONG tin0, tin1;\\r\\nregister BF_LONG tout0, tout1, xor0, xor1;\\r\\nregister long l = length;\\r\\nBF_LONG tin[2];\\r\\nif (encrypt) {\\r\\nn2l(ivec, tout0);\\r\\nn2l(ivec, tout1);\\r\\nivec -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nBF_encrypt(tin, schedule);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\n}\\r\\nif (l != -8) {\\r\\nn2ln(in, tin0, tin1, l + 8);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nBF_encrypt(tin, schedule);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\n}\\r\\nl2n(tout0, ivec);\\r\\nl2n(tout1, ivec);\\r\\n} else {\\r\\nn2l(ivec, xor0);\\r\\nn2l(ivec, xor1);\\r\\nivec -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nBF_decrypt(tin, schedule);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nif (l != -8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nBF_decrypt(tin, schedule);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2nn(tout0, tout1, out, l + 8);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nl2n(xor0, ivec);\\r\\nl2n(xor1, ivec);\\r\\n}\\r\\ntin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;\\r\\ntin[0] = tin[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_table_c", "target": 0, "func": "unsigned int ENGINE_get_table_flags(void)\\r\\n{\\r\\nreturn table_flags;\\r\\n}\\r\\nvoid ENGINE_set_table_flags(unsigned int flags)\\r\\n{\\r\\ntable_flags = flags;\\r\\n}\\r\\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\\r\\n{\\r\\nreturn c->nid;\\r\\n}\\r\\nstatic int engine_pile_cmp(const ENGINE_PILE *a, const ENGINE_PILE *b)\\r\\n{\\r\\nreturn a->nid - b->nid;\\r\\n}\\r\\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile, ENGINE *e)\\r\\n{\\r\\nint n;\\r\\nwhile ((n = sk_ENGINE_find(pile->sk, e)) >= 0) {\\r\\n(void)sk_ENGINE_delete(pile->sk, n);\\r\\npile->uptodate = 0;\\r\\n}\\r\\nif (pile->funct == e) {\\r\\nengine_unlocked_finish(e, 0);\\r\\npile->funct = NULL;\\r\\n}\\r\\n}\\r\\nvoid int_cleanup_cb_doall(ENGINE_PILE *p)\\r\\n{\\r\\nsk_ENGINE_free(p->sk);\\r\\nif (p->funct)\\r\\nengine_unlocked_finish(p->funct, 0);\\r\\nOPENSSL_free(p);\\r\\n}\\r\\nvoid int_cb_doall_arg(ENGINE_PILE *pile, ENGINE_PILE_DOALL *dall)\\r\\n{\\r\\ndall->cb(pile->nid, pile->sk, pile->funct, dall->arg);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rand_err_c", "target": 0, "func": "void ERR_load_RAND_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(RAND_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, RAND_str_functs);\\r\\nERR_load_strings(0, RAND_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_pmeth_c", "target": 0, "func": "static int pkey_dsa_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nDSA_PKEY_CTX *dctx;\\r\\ndctx = OPENSSL_malloc(sizeof(DSA_PKEY_CTX));\\r\\nif (!dctx)\\r\\nreturn 0;\\r\\ndctx->nbits = 1024;\\r\\ndctx->qbits = 160;\\r\\ndctx->pmd = NULL;\\r\\ndctx->md = NULL;\\r\\nctx->data = dctx;\\r\\nctx->keygen_info = dctx->gentmp;\\r\\nctx->keygen_info_count = 2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_dsa_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)\\r\\n{\\r\\nDSA_PKEY_CTX *dctx, *sctx;\\r\\nif (!pkey_dsa_init(dst))\\r\\nreturn 0;\\r\\nsctx = src->data;\\r\\ndctx = dst->data;\\r\\ndctx->nbits = sctx->nbits;\\r\\ndctx->qbits = sctx->qbits;\\r\\ndctx->pmd = sctx->pmd;\\r\\ndctx->md = sctx->md;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void pkey_dsa_cleanup(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nDSA_PKEY_CTX *dctx = ctx->data;\\r\\nif (dctx)\\r\\nOPENSSL_free(dctx);\\r\\n}\\r\\nstatic int pkey_dsa_sign(EVP_PKEY_CTX *ctx, unsigned char *sig,\\r\\nsize_t *siglen, const unsigned char *tbs,\\r\\nsize_t tbslen)\\r\\n{\\r\\nint ret, type;\\r\\nunsigned int sltmp;\\r\\nDSA_PKEY_CTX *dctx = ctx->data;\\r\\nDSA *dsa = ctx->pkey->pkey.dsa;\\r\\nif (dctx->md)\\r\\ntype = EVP_MD_type(dctx->md);\\r\\nelse\\r\\ntype = NID_sha1;\\r\\nret = DSA_sign(type, tbs, tbslen, sig, &sltmp, dsa);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\n*siglen = sltmp;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_dsa_verify(EVP_PKEY_CTX *ctx,\\r\\nconst unsigned char *sig, size_t siglen,\\r\\nconst unsigned char *tbs, size_t tbslen)\\r\\n{\\r\\nint ret, type;\\r\\nDSA_PKEY_CTX *dctx = ctx->data;\\r\\nDSA *dsa = ctx->pkey->pkey.dsa;\\r\\nif (dctx->md)\\r\\ntype = EVP_MD_type(dctx->md);\\r\\nelse\\r\\ntype = NID_sha1;\\r\\nret = DSA_verify(type, tbs, tbslen, sig, siglen, dsa);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int pkey_dsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)\\r\\n{\\r\\nDSA_PKEY_CTX *dctx = ctx->data;\\r\\nswitch (type) {\\r\\ncase EVP_PKEY_CTRL_DSA_PARAMGEN_BITS:\\r\\nif (p1 < 256)\\r\\nreturn -2;\\r\\ndctx->nbits = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS:\\r\\nif (p1 != 160 && p1 != 224 && p1 && p1 != 256)\\r\\nreturn -2;\\r\\ndctx->qbits = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DSA_PARAMGEN_MD:\\r\\nif (EVP_MD_type((const EVP_MD *)p2) != NID_sha1 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha224 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha256) {\\r\\nDSAerr(DSA_F_PKEY_DSA_CTRL, DSA_R_INVALID_DIGEST_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\ndctx->md = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_MD:\\r\\nif (EVP_MD_type((const EVP_MD *)p2) != NID_sha1 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_dsa &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_dsaWithSHA &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha224 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha256 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha384 &&\\r\\nEVP_MD_type((const EVP_MD *)p2) != NID_sha512) {\\r\\nDSAerr(DSA_F_PKEY_DSA_CTRL, DSA_R_INVALID_DIGEST_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\ndctx->md = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_MD:\\r\\n*(const EVP_MD **)p2 = dctx->md;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_DIGESTINIT:\\r\\ncase EVP_PKEY_CTRL_PKCS7_SIGN:\\r\\ncase EVP_PKEY_CTRL_CMS_SIGN:\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_PEER_KEY:\\r\\nDSAerr(DSA_F_PKEY_DSA_CTRL,\\r\\nEVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\n}\\r\\nstatic int pkey_dsa_ctrl_str(EVP_PKEY_CTX *ctx,\\r\\nconst char *type, const char *value)\\r\\n{\\r\\nif (!strcmp(type, \"dsa_paramgen_bits\")) {\\r\\nint nbits;\\r\\nnbits = atoi(value);\\r\\nreturn EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx, nbits);\\r\\n}\\r\\nif (!strcmp(type, \"dsa_paramgen_q_bits\")) {\\r\\nint qbits = atoi(value);\\r\\nreturn EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DSA, EVP_PKEY_OP_PARAMGEN,\\r\\nEVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS, qbits,\\r\\nNULL);\\r\\n}\\r\\nif (!strcmp(type, \"dsa_paramgen_md\")) {\\r\\nreturn EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_DSA, EVP_PKEY_OP_PARAMGEN,\\r\\nEVP_PKEY_CTRL_DSA_PARAMGEN_MD, 0,\\r\\n(void *)EVP_get_digestbyname(value));\\r\\n}\\r\\nreturn -2;\\r\\n}\\r\\nstatic int pkey_dsa_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nDSA *dsa = NULL;\\r\\nDSA_PKEY_CTX *dctx = ctx->data;\\r\\nBN_GENCB *pcb, cb;\\r\\nint ret;\\r\\nif (ctx->pkey_gencb) {\\r\\npcb = &cb;\\r\\nevp_pkey_set_cb_translate(pcb, ctx);\\r\\n} else\\r\\npcb = NULL;\\r\\ndsa = DSA_new();\\r\\nif (!dsa)\\r\\nreturn 0;\\r\\nret = dsa_builtin_paramgen(dsa, dctx->nbits, dctx->qbits, dctx->pmd,\\r\\nNULL, 0, NULL, NULL, NULL, pcb);\\r\\nif (ret)\\r\\nEVP_PKEY_assign_DSA(pkey, dsa);\\r\\nelse\\r\\nDSA_free(dsa);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int pkey_dsa_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nDSA *dsa = NULL;\\r\\nif (ctx->pkey == NULL) {\\r\\nDSAerr(DSA_F_PKEY_DSA_KEYGEN, DSA_R_NO_PARAMETERS_SET);\\r\\nreturn 0;\\r\\n}\\r\\ndsa = DSA_new();\\r\\nif (!dsa)\\r\\nreturn 0;\\r\\nEVP_PKEY_assign_DSA(pkey, dsa);\\r\\nif (!EVP_PKEY_copy_parameters(pkey, ctx->pkey))\\r\\nreturn 0;\\r\\nreturn DSA_generate_key(pkey->pkey.dsa);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_mem_dbg_c", "target": 0, "func": "static void app_info_free(APP_INFO *inf)\\r\\n{\\r\\nif (--(inf->references) <= 0) {\\r\\nif (inf->next != NULL) {\\r\\napp_info_free(inf->next);\\r\\n}\\r\\nOPENSSL_free(inf);\\r\\n}\\r\\n}\\r\\nint CRYPTO_mem_ctrl(int mode)\\r\\n{\\r\\nint ret = mh_mode;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nswitch (mode) {\\r\\ncase CRYPTO_MEM_CHECK_ON:\\r\\nmh_mode = CRYPTO_MEM_CHECK_ON | CRYPTO_MEM_CHECK_ENABLE;\\r\\nnum_disable = 0;\\r\\nbreak;\\r\\ncase CRYPTO_MEM_CHECK_OFF:\\r\\nmh_mode = 0;\\r\\nnum_disable = 0;\\r\\nbreak;\\r\\ncase CRYPTO_MEM_CHECK_DISABLE:\\r\\nif (mh_mode & CRYPTO_MEM_CHECK_ON) {\\r\\nCRYPTO_THREADID cur;\\r\\nCRYPTO_THREADID_current(&cur);\\r\\nif (!num_disable\\r\\n|| CRYPTO_THREADID_cmp(&disabling_threadid, &cur)) {\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_MALLOC);\\r\\nmh_mode &= ~CRYPTO_MEM_CHECK_ENABLE;\\r\\nCRYPTO_THREADID_cpy(&disabling_threadid, &cur);\\r\\n}\\r\\nnum_disable++;\\r\\n}\\r\\nbreak;\\r\\ncase CRYPTO_MEM_CHECK_ENABLE:\\r\\nif (mh_mode & CRYPTO_MEM_CHECK_ON) {\\r\\nif (num_disable) {\\r\\nnum_disable--;\\r\\nif (num_disable == 0) {\\r\\nmh_mode |= CRYPTO_MEM_CHECK_ENABLE;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);\\r\\n}\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);\\r\\nreturn (ret);\\r\\n}\\r\\nint CRYPTO_is_mem_check_on(void)\\r\\n{\\r\\nint ret = 0;\\r\\nif (mh_mode & CRYPTO_MEM_CHECK_ON) {\\r\\nCRYPTO_THREADID cur;\\r\\nCRYPTO_THREADID_current(&cur);\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_MALLOC);\\r\\nret = (mh_mode & CRYPTO_MEM_CHECK_ENABLE)\\r\\n|| CRYPTO_THREADID_cmp(&disabling_threadid, &cur);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_MALLOC);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid CRYPTO_dbg_set_options(long bits)\\r\\n{\\r\\noptions = bits;\\r\\n}\\r\\nlong CRYPTO_dbg_get_options(void)\\r\\n{\\r\\nreturn options;\\r\\n}\\r\\nstatic int mem_cmp(const MEM *a, const MEM *b)\\r\\n{\\r\\n#ifdef _WIN64\\r\\nconst char *ap = (const char *)a->addr, *bp = (const char *)b->addr;\\r\\nif (ap == bp)\\r\\nreturn 0;\\r\\nelse if (ap > bp)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn -1;\\r\\n#else\\r\\nreturn (const char *)a->addr - (const char *)b->addr;\\r\\n#endif\\r\\n}\\r\\nint CRYPTO_pop_info(void)\\r\\n{\\r\\nint ret = 0;\\r\\nif (is_MemCheck_on()) {\\r\\nMemCheck_off();\\r\\nret = (pop_info() != NULL);\\r\\nMemCheck_on();\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint CRYPTO_remove_all_info(void)\\r\\n{\\r\\nint ret = 0;\\r\\nif (is_MemCheck_on()) {\\r\\nMemCheck_off();\\r\\nwhile (pop_info() != NULL)\\r\\nret++;\\r\\nMemCheck_on();\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid CRYPTO_dbg_malloc(void *addr, int num, const char *file, int line,\\r\\nint before_p)\\r\\n{\\r\\nMEM *m, *mm;\\r\\nAPP_INFO tmp, *amim;\\r\\nswitch (before_p & 127) {\\r\\ncase 0:\\r\\nbreak;\\r\\ncase 1:\\r\\nif (addr == NULL)\\r\\nbreak;\\r\\nif (is_MemCheck_on()) {\\r\\nMemCheck_off();\\r\\nif ((m = (MEM *)OPENSSL_malloc(sizeof(MEM))) == NULL) {\\r\\nOPENSSL_free(addr);\\r\\nMemCheck_on();\\r\\nreturn;\\r\\n}\\r\\nif (mh == NULL) {\\r\\nif ((mh = lh_MEM_new()) == NULL) {\\r\\nOPENSSL_free(addr);\\r\\nOPENSSL_free(m);\\r\\naddr = NULL;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nm->addr = addr;\\r\\nm->file = file;\\r\\nm->line = line;\\r\\nm->num = num;\\r\\nif (options & V_CRYPTO_MDEBUG_THREAD)\\r\\nCRYPTO_THREADID_current(&m->threadid);\\r\\nelse\\r\\nmemset(&m->threadid, 0, sizeof(m->threadid));\\r\\nif (order == break_order_num) {\\r\\nm->order = order;\\r\\n}\\r\\nm->order = order++;\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: [%5ld] %c 0x%p (%d)\\n\",\\r\\nm->order, (before_p & 128) ? '*' : '+', m->addr, m->num);\\r\\n#endif\\r\\nif (options & V_CRYPTO_MDEBUG_TIME)\\r\\nm->time = time(NULL);\\r\\nelse\\r\\nm->time = 0;\\r\\nCRYPTO_THREADID_current(&tmp.threadid);\\r\\nm->app_info = NULL;\\r\\nif (amih != NULL\\r\\n&& (amim = lh_APP_INFO_retrieve(amih, &tmp)) != NULL) {\\r\\nm->app_info = amim;\\r\\namim->references++;\\r\\n}\\r\\nif ((mm = lh_MEM_insert(mh, m)) != NULL) {\\r\\nif (mm->app_info != NULL) {\\r\\nmm->app_info->references--;\\r\\n}\\r\\nOPENSSL_free(mm);\\r\\n}\\r\\nerr:\\r\\nMemCheck_on();\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nvoid CRYPTO_dbg_free(void *addr, int before_p)\\r\\n{\\r\\nMEM m, *mp;\\r\\nswitch (before_p) {\\r\\ncase 0:\\r\\nif (addr == NULL)\\r\\nbreak;\\r\\nif (is_MemCheck_on() && (mh != NULL)) {\\r\\nMemCheck_off();\\r\\nm.addr = addr;\\r\\nmp = lh_MEM_delete(mh, &m);\\r\\nif (mp != NULL) {\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr, \"LEVITTE_DEBUG_MEM: [%5ld] - 0x%p (%d)\\n\",\\r\\nmp->order, mp->addr, mp->num);\\r\\n#endif\\r\\nif (mp->app_info != NULL)\\r\\napp_info_free(mp->app_info);\\r\\nOPENSSL_free(mp);\\r\\n}\\r\\nMemCheck_on();\\r\\n}\\r\\nbreak;\\r\\ncase 1:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvoid CRYPTO_dbg_realloc(void *addr1, void *addr2, int num,\\r\\nconst char *file, int line, int before_p)\\r\\n{\\r\\nMEM m, *mp;\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr,\\r\\n\"LEVITTE_DEBUG_MEM: --> CRYPTO_dbg_malloc(addr1 = %p, addr2 = %p, num = %d, file = \\\"%s\\\", line = %d, before_p = %d)\\n\",\\r\\naddr1, addr2, num, file, line, before_p);\\r\\n#endif\\r\\nswitch (before_p) {\\r\\ncase 0:\\r\\nbreak;\\r\\ncase 1:\\r\\nif (addr2 == NULL)\\r\\nbreak;\\r\\nif (addr1 == NULL) {\\r\\nCRYPTO_dbg_malloc(addr2, num, file, line, 128 | before_p);\\r\\nbreak;\\r\\n}\\r\\nif (is_MemCheck_on()) {\\r\\nMemCheck_off();\\r\\nm.addr = addr1;\\r\\nmp = lh_MEM_delete(mh, &m);\\r\\nif (mp != NULL) {\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nfprintf(stderr,\\r\\n\"LEVITTE_DEBUG_MEM: [%5ld] * 0x%p (%d) -> 0x%p (%d)\\n\",\\r\\nmp->order, mp->addr, mp->num, addr2, num);\\r\\n#endif\\r\\nmp->addr = addr2;\\r\\nmp->num = num;\\r\\n(void)lh_MEM_insert(mh, mp);\\r\\n}\\r\\nMemCheck_on();\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn;\\r\\n}\\r\\nstatic void print_leak_doall_arg(const MEM *m, MEM_LEAK *l)\\r\\n{\\r\\nchar buf[1024];\\r\\nchar *bufp = buf;\\r\\nAPP_INFO *amip;\\r\\nint ami_cnt;\\r\\nstruct tm *lcl = NULL;\\r\\nCRYPTO_THREADID ti;\\r\\n#define BUF_REMAIN (sizeof buf - (size_t)(bufp - buf))\\r\\nif (m->addr == (char *)l->bio)\\r\\nreturn;\\r\\nif (options & V_CRYPTO_MDEBUG_TIME) {\\r\\nlcl = localtime(&m->time);\\r\\nBIO_snprintf(bufp, BUF_REMAIN, \"[%02d:%02d:%02d] \",\\r\\nlcl->tm_hour, lcl->tm_min, lcl->tm_sec);\\r\\nbufp += strlen(bufp);\\r\\n}\\r\\nBIO_snprintf(bufp, BUF_REMAIN, \"%5lu file=%s, line=%d, \",\\r\\nm->order, m->file, m->line);\\r\\nbufp += strlen(bufp);\\r\\nif (options & V_CRYPTO_MDEBUG_THREAD) {\\r\\nBIO_snprintf(bufp, BUF_REMAIN, \"thread=%lu, \",\\r\\nCRYPTO_THREADID_hash(&m->threadid));\\r\\nbufp += strlen(bufp);\\r\\n}\\r\\nBIO_snprintf(bufp, BUF_REMAIN, \"number=%d, address=%08lX\\n\",\\r\\nm->num, (unsigned long)m->addr);\\r\\nbufp += strlen(bufp);\\r\\nBIO_puts(l->bio, buf);\\r\\nl->chunks++;\\r\\nl->bytes += m->num;\\r\\namip = m->app_info;\\r\\nami_cnt = 0;\\r\\nif (!amip)\\r\\nreturn;\\r\\nCRYPTO_THREADID_cpy(&ti, &amip->threadid);\\r\\ndo {\\r\\nint buf_len;\\r\\nint info_len;\\r\\nami_cnt++;\\r\\nmemset(buf, '>', ami_cnt);\\r\\nBIO_snprintf(buf + ami_cnt, sizeof buf - ami_cnt,\\r\\n\" thread=%lu, file=%s, line=%d, info=\\\"\",\\r\\nCRYPTO_THREADID_hash(&amip->threadid), amip->file,\\r\\namip->line);\\r\\nbuf_len = strlen(buf);\\r\\ninfo_len = strlen(amip->info);\\r\\nif (128 - buf_len - 3 < info_len) {\\r\\nmemcpy(buf + buf_len, amip->info, 128 - buf_len - 3);\\r\\nbuf_len = 128 - 3;\\r\\n} else {\\r\\nBUF_strlcpy(buf + buf_len, amip->info, sizeof buf - buf_len);\\r\\nbuf_len = strlen(buf);\\r\\n}\\r\\nBIO_snprintf(buf + buf_len, sizeof buf - buf_len, \"\\\"\\n\");\\r\\nBIO_puts(l->bio, buf);\\r\\namip = amip->next;\\r\\n}\\r\\nwhile (amip && !CRYPTO_THREADID_cmp(&amip->threadid, &ti));\\r\\n#ifdef LEVITTE_DEBUG_MEM\\r\\nif (amip) {\\r\\nfprintf(stderr, \"Thread switch detected in backtrace!!!!\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\n}\\r\\nstatic void cb_leak_doall_arg(const MEM *m, PCRYPTO_MEM_LEAK_CB *cb)\\r\\n{\\r\\n(*cb) (m->order, m->file, m->line, m->num, m->addr);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tasn_new_c", "target": 0, "func": "ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_VALUE *ret = NULL;\\r\\nif (ASN1_item_ex_new(&ret, it) > 0)\\r\\nreturn ret;\\r\\nreturn NULL;\\r\\n}\\r\\nint ASN1_item_ex_new(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nreturn asn1_item_ex_combine_new(pval, it, 0);\\r\\n}\\r\\nstatic int asn1_item_ex_combine_new(ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nint combine)\\r\\n{\\r\\nconst ASN1_TEMPLATE *tt = NULL;\\r\\nconst ASN1_COMPAT_FUNCS *cf;\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_aux_cb *asn1_cb;\\r\\nASN1_VALUE **pseqval;\\r\\nint i;\\r\\nif (aux && aux->asn1_cb)\\r\\nasn1_cb = aux->asn1_cb;\\r\\nelse\\r\\nasn1_cb = 0;\\r\\nif (!combine)\\r\\n*pval = NULL;\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_push_info(it->sname);\\r\\n#endif\\r\\nswitch (it->itype) {\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nif (ef && ef->asn1_ex_new) {\\r\\nif (!ef->asn1_ex_new(pval, it))\\r\\ngoto memerr;\\r\\n}\\r\\nbreak;\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncf = it->funcs;\\r\\nif (cf && cf->asn1_new) {\\r\\n*pval = cf->asn1_new();\\r\\nif (!*pval)\\r\\ngoto memerr;\\r\\n}\\r\\nbreak;\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates) {\\r\\nif (!ASN1_template_new(pval, it->templates))\\r\\ngoto memerr;\\r\\n} else if (!ASN1_primitive_new(pval, it))\\r\\ngoto memerr;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nif (!ASN1_primitive_new(pval, it))\\r\\ngoto memerr;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\nif (asn1_cb) {\\r\\ni = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);\\r\\nif (!i)\\r\\ngoto auxerr;\\r\\nif (i == 2) {\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nif (!combine) {\\r\\n*pval = OPENSSL_malloc(it->size);\\r\\nif (!*pval)\\r\\ngoto memerr;\\r\\nmemset(*pval, 0, it->size);\\r\\n}\\r\\nasn1_set_choice_selector(pval, -1, it);\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL))\\r\\ngoto auxerr;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\nif (asn1_cb) {\\r\\ni = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);\\r\\nif (!i)\\r\\ngoto auxerr;\\r\\nif (i == 2) {\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nif (!combine) {\\r\\n*pval = OPENSSL_malloc(it->size);\\r\\nif (!*pval)\\r\\ngoto memerr;\\r\\nmemset(*pval, 0, it->size);\\r\\nasn1_do_lock(pval, 0, it);\\r\\nasn1_enc_init(pval, it);\\r\\n}\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {\\r\\npseqval = asn1_get_field_ptr(pval, tt);\\r\\nif (!ASN1_template_new(pseqval, tt))\\r\\ngoto memerr;\\r\\n}\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL))\\r\\ngoto auxerr;\\r\\nbreak;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 1;\\r\\nmemerr:\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_COMBINE_NEW, ERR_R_MALLOC_FAILURE);\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 0;\\r\\nauxerr:\\r\\nASN1err(ASN1_F_ASN1_ITEM_EX_COMBINE_NEW, ASN1_R_AUX_ERROR);\\r\\nASN1_item_ex_free(pval, it);\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nreturn 0;\\r\\n}\\r\\nstatic void asn1_item_clear(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nswitch (it->itype) {\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nif (ef && ef->asn1_ex_clear)\\r\\nef->asn1_ex_clear(pval, it);\\r\\nelse\\r\\n*pval = NULL;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates)\\r\\nasn1_template_clear(pval, it->templates);\\r\\nelse\\r\\nasn1_primitive_clear(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nasn1_primitive_clear(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\n*pval = NULL;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nint ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nconst ASN1_ITEM *it = ASN1_ITEM_ptr(tt->item);\\r\\nint ret;\\r\\nif (tt->flags & ASN1_TFLG_OPTIONAL) {\\r\\nasn1_template_clear(pval, tt);\\r\\nreturn 1;\\r\\n}\\r\\nif (tt->flags & ASN1_TFLG_ADB_MASK) {\\r\\n*pval = NULL;\\r\\nreturn 1;\\r\\n}\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (tt->field_name)\\r\\nCRYPTO_push_info(tt->field_name);\\r\\n#endif\\r\\nif (tt->flags & ASN1_TFLG_SK_MASK) {\\r\\nSTACK_OF(ASN1_VALUE) *skval;\\r\\nskval = sk_ASN1_VALUE_new_null();\\r\\nif (!skval) {\\r\\nASN1err(ASN1_F_ASN1_TEMPLATE_NEW, ERR_R_MALLOC_FAILURE);\\r\\nret = 0;\\r\\ngoto done;\\r\\n}\\r\\n*pval = (ASN1_VALUE *)skval;\\r\\nret = 1;\\r\\ngoto done;\\r\\n}\\r\\nret = asn1_item_ex_combine_new(pval, it, tt->flags & ASN1_TFLG_COMBINE);\\r\\ndone:\\r\\n#ifdef CRYPTO_MDEBUG\\r\\nif (it->sname)\\r\\nCRYPTO_pop_info();\\r\\n#endif\\r\\nreturn ret;\\r\\n}\\r\\nstatic void asn1_template_clear(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nif (tt->flags & (ASN1_TFLG_ADB_MASK | ASN1_TFLG_SK_MASK))\\r\\n*pval = NULL;\\r\\nelse\\r\\nasn1_item_clear(pval, ASN1_ITEM_ptr(tt->item));\\r\\n}\\r\\nint ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_TYPE *typ;\\r\\nASN1_STRING *str;\\r\\nint utype;\\r\\nif (it && it->funcs) {\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf = it->funcs;\\r\\nif (pf->prim_new)\\r\\nreturn pf->prim_new(pval, it);\\r\\n}\\r\\nif (!it || (it->itype == ASN1_ITYPE_MSTRING))\\r\\nutype = -1;\\r\\nelse\\r\\nutype = it->utype;\\r\\nswitch (utype) {\\r\\ncase V_ASN1_OBJECT:\\r\\n*pval = (ASN1_VALUE *)OBJ_nid2obj(NID_undef);\\r\\nreturn 1;\\r\\ncase V_ASN1_BOOLEAN:\\r\\n*(ASN1_BOOLEAN *)pval = it->size;\\r\\nreturn 1;\\r\\ncase V_ASN1_NULL:\\r\\n*pval = (ASN1_VALUE *)1;\\r\\nreturn 1;\\r\\ncase V_ASN1_ANY:\\r\\ntyp = OPENSSL_malloc(sizeof(ASN1_TYPE));\\r\\nif (!typ)\\r\\nreturn 0;\\r\\ntyp->value.ptr = NULL;\\r\\ntyp->type = -1;\\r\\n*pval = (ASN1_VALUE *)typ;\\r\\nbreak;\\r\\ndefault:\\r\\nstr = ASN1_STRING_type_new(utype);\\r\\nif (it->itype == ASN1_ITYPE_MSTRING && str)\\r\\nstr->flags |= ASN1_STRING_FLAG_MSTRING;\\r\\n*pval = (ASN1_VALUE *)str;\\r\\nbreak;\\r\\n}\\r\\nif (*pval)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic void asn1_primitive_clear(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nint utype;\\r\\nif (it && it->funcs) {\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf = it->funcs;\\r\\nif (pf->prim_clear)\\r\\npf->prim_clear(pval, it);\\r\\nelse\\r\\n*pval = NULL;\\r\\nreturn;\\r\\n}\\r\\nif (!it || (it->itype == ASN1_ITYPE_MSTRING))\\r\\nutype = -1;\\r\\nelse\\r\\nutype = it->utype;\\r\\nif (utype == V_ASN1_BOOLEAN)\\r\\n*(ASN1_BOOLEAN *)pval = it->size;\\r\\nelse\\r\\n*pval = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_sha1_one_c", "target": 0, "func": "unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nSHA_CTX c;\\r\\nstatic unsigned char m[SHA_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nif (!SHA1_Init(&c))\\r\\nreturn NULL;\\r\\nSHA1_Update(&c, d, n);\\r\\nSHA1_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_prn_c", "target": 0, "func": "int RSA_print_fp(FILE *fp, const RSA *x, int off)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nRSAerr(RSA_F_RSA_PRINT_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = RSA_print(b, x, off);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint RSA_print(BIO *bp, const RSA *x, int off)\\r\\n{\\r\\nEVP_PKEY *pk;\\r\\nint ret;\\r\\npk = EVP_PKEY_new();\\r\\nif (!pk || !EVP_PKEY_set1_RSA(pk, (RSA *)x))\\r\\nreturn 0;\\r\\nret = EVP_PKEY_print_private(bp, pk, off, NULL);\\r\\nEVP_PKEY_free(pk);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_all_c", "target": 0, "func": "void ENGINE_load_builtin_engines(void)\\r\\n{\\r\\nOPENSSL_cpuid_setup();\\r\\n#if 0\\r\\nENGINE_load_openssl();\\r\\n#endif\\r\\n#if !defined(OPENSSL_NO_HW) && (defined(__OpenBSD__) || defined(__FreeBSD__) || defined(HAVE_CRYPTODEV))\\r\\nENGINE_load_cryptodev();\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_RDRAND\\r\\nENGINE_load_rdrand();\\r\\n#endif\\r\\nENGINE_load_dynamic();\\r\\n#ifndef OPENSSL_NO_STATIC_ENGINE\\r\\n# ifndef OPENSSL_NO_HW\\r\\n# ifndef OPENSSL_NO_HW_4758_CCA\\r\\nENGINE_load_4758cca();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_HW_AEP\\r\\nENGINE_load_aep();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_HW_ATALLA\\r\\nENGINE_load_atalla();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_HW_CSWIFT\\r\\nENGINE_load_cswift();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_HW_NCIPHER\\r\\nENGINE_load_chil();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_HW_NURON\\r\\nENGINE_load_nuron();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_HW_SUREWARE\\r\\nENGINE_load_sureware();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_HW_UBSEC\\r\\nENGINE_load_ubsec();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_HW_PADLOCK\\r\\nENGINE_load_padlock();\\r\\n# endif\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_GOST\\r\\nENGINE_load_gost();\\r\\n# endif\\r\\n# ifndef OPENSSL_NO_GMP\\r\\nENGINE_load_gmp();\\r\\n# endif\\r\\n# if defined(OPENSSL_SYS_WIN32) && !defined(OPENSSL_NO_CAPIENG)\\r\\nENGINE_load_capi();\\r\\n# endif\\r\\n#endif\\r\\nENGINE_register_all_complete();\\r\\n}\\r\\nvoid ENGINE_setup_bsd_cryptodev(void)\\r\\n{\\r\\nstatic int bsd_cryptodev_default_loaded = 0;\\r\\nif (!bsd_cryptodev_default_loaded) {\\r\\nENGINE_load_cryptodev();\\r\\nENGINE_register_all_complete();\\r\\n}\\r\\nbsd_cryptodev_default_loaded = 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ocsp_prn_c", "target": 0, "func": "static int ocsp_certid_print(BIO *bp, OCSP_CERTID *a, int indent)\\r\\n{\\r\\nBIO_printf(bp, \"%*sCertificate ID:\\n\", indent, \"\");\\r\\nindent += 2;\\r\\nBIO_printf(bp, \"%*sHash Algorithm: \", indent, \"\");\\r\\ni2a_ASN1_OBJECT(bp, a->hashAlgorithm->algorithm);\\r\\nBIO_printf(bp, \"\\n%*sIssuer Name Hash: \", indent, \"\");\\r\\ni2a_ASN1_STRING(bp, a->issuerNameHash, V_ASN1_OCTET_STRING);\\r\\nBIO_printf(bp, \"\\n%*sIssuer Key Hash: \", indent, \"\");\\r\\ni2a_ASN1_STRING(bp, a->issuerKeyHash, V_ASN1_OCTET_STRING);\\r\\nBIO_printf(bp, \"\\n%*sSerial Number: \", indent, \"\");\\r\\ni2a_ASN1_INTEGER(bp, a->serialNumber);\\r\\nBIO_printf(bp, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic const char *table2string(long s, const OCSP_TBLSTR *ts, int len)\\r\\n{\\r\\nconst OCSP_TBLSTR *p;\\r\\nfor (p = ts; p < ts + len; p++)\\r\\nif (p->t == s)\\r\\nreturn p->m;\\r\\nreturn \"(UNKNOWN)\";\\r\\n}\\r\\nconst char *OCSP_response_status_str(long s)\\r\\n{\\r\\nstatic const OCSP_TBLSTR rstat_tbl[] = {\\r\\n{OCSP_RESPONSE_STATUS_SUCCESSFUL, \"successful\"},\\r\\n{OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, \"malformedrequest\"},\\r\\n{OCSP_RESPONSE_STATUS_INTERNALERROR, \"internalerror\"},\\r\\n{OCSP_RESPONSE_STATUS_TRYLATER, \"trylater\"},\\r\\n{OCSP_RESPONSE_STATUS_SIGREQUIRED, \"sigrequired\"},\\r\\n{OCSP_RESPONSE_STATUS_UNAUTHORIZED, \"unauthorized\"}\\r\\n};\\r\\nreturn table2string(s, rstat_tbl, 6);\\r\\n}\\r\\nconst char *OCSP_cert_status_str(long s)\\r\\n{\\r\\nstatic const OCSP_TBLSTR cstat_tbl[] = {\\r\\n{V_OCSP_CERTSTATUS_GOOD, \"good\"},\\r\\n{V_OCSP_CERTSTATUS_REVOKED, \"revoked\"},\\r\\n{V_OCSP_CERTSTATUS_UNKNOWN, \"unknown\"}\\r\\n};\\r\\nreturn table2string(s, cstat_tbl, 3);\\r\\n}\\r\\nconst char *OCSP_crl_reason_str(long s)\\r\\n{\\r\\nstatic const OCSP_TBLSTR reason_tbl[] = {\\r\\n{OCSP_REVOKED_STATUS_UNSPECIFIED, \"unspecified\"},\\r\\n{OCSP_REVOKED_STATUS_KEYCOMPROMISE, \"keyCompromise\"},\\r\\n{OCSP_REVOKED_STATUS_CACOMPROMISE, \"cACompromise\"},\\r\\n{OCSP_REVOKED_STATUS_AFFILIATIONCHANGED, \"affiliationChanged\"},\\r\\n{OCSP_REVOKED_STATUS_SUPERSEDED, \"superseded\"},\\r\\n{OCSP_REVOKED_STATUS_CESSATIONOFOPERATION, \"cessationOfOperation\"},\\r\\n{OCSP_REVOKED_STATUS_CERTIFICATEHOLD, \"certificateHold\"},\\r\\n{OCSP_REVOKED_STATUS_REMOVEFROMCRL, \"removeFromCRL\"}\\r\\n};\\r\\nreturn table2string(s, reason_tbl, 8);\\r\\n}\\r\\nint OCSP_REQUEST_print(BIO *bp, OCSP_REQUEST *o, unsigned long flags)\\r\\n{\\r\\nint i;\\r\\nlong l;\\r\\nOCSP_CERTID *cid = NULL;\\r\\nOCSP_ONEREQ *one = NULL;\\r\\nOCSP_REQINFO *inf = o->tbsRequest;\\r\\nOCSP_SIGNATURE *sig = o->optionalSignature;\\r\\nif (BIO_write(bp, \"OCSP Request Data:\\n\", 19) <= 0)\\r\\ngoto err;\\r\\nl = ASN1_INTEGER_get(inf->version);\\r\\nif (BIO_printf(bp, \" Version: %lu (0x%lx)\", l + 1, l) <= 0)\\r\\ngoto err;\\r\\nif (inf->requestorName != NULL) {\\r\\nif (BIO_write(bp, \"\\n Requestor Name: \", 21) <= 0)\\r\\ngoto err;\\r\\nGENERAL_NAME_print(bp, inf->requestorName);\\r\\n}\\r\\nif (BIO_write(bp, \"\\n Requestor List:\\n\", 21) <= 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < sk_OCSP_ONEREQ_num(inf->requestList); i++) {\\r\\none = sk_OCSP_ONEREQ_value(inf->requestList, i);\\r\\ncid = one->reqCert;\\r\\nocsp_certid_print(bp, cid, 8);\\r\\nif (!X509V3_extensions_print(bp,\\r\\n\"Request Single Extensions\",\\r\\none->singleRequestExtensions, flags, 8))\\r\\ngoto err;\\r\\n}\\r\\nif (!X509V3_extensions_print(bp, \"Request Extensions\",\\r\\ninf->requestExtensions, flags, 4))\\r\\ngoto err;\\r\\nif (sig) {\\r\\nX509_signature_print(bp, sig->signatureAlgorithm, sig->signature);\\r\\nfor (i = 0; i < sk_X509_num(sig->certs); i++) {\\r\\nX509_print(bp, sk_X509_value(sig->certs, i));\\r\\nPEM_write_bio_X509(bp, sk_X509_value(sig->certs, i));\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint OCSP_RESPONSE_print(BIO *bp, OCSP_RESPONSE *o, unsigned long flags)\\r\\n{\\r\\nint i, ret = 0;\\r\\nlong l;\\r\\nOCSP_CERTID *cid = NULL;\\r\\nOCSP_BASICRESP *br = NULL;\\r\\nOCSP_RESPID *rid = NULL;\\r\\nOCSP_RESPDATA *rd = NULL;\\r\\nOCSP_CERTSTATUS *cst = NULL;\\r\\nOCSP_REVOKEDINFO *rev = NULL;\\r\\nOCSP_SINGLERESP *single = NULL;\\r\\nOCSP_RESPBYTES *rb = o->responseBytes;\\r\\nif (BIO_puts(bp, \"OCSP Response Data:\\n\") <= 0)\\r\\ngoto err;\\r\\nl = ASN1_ENUMERATED_get(o->responseStatus);\\r\\nif (BIO_printf(bp, \" OCSP Response Status: %s (0x%lx)\\n\",\\r\\nOCSP_response_status_str(l), l) <= 0)\\r\\ngoto err;\\r\\nif (rb == NULL)\\r\\nreturn 1;\\r\\nif (BIO_puts(bp, \" Response Type: \") <= 0)\\r\\ngoto err;\\r\\nif (i2a_ASN1_OBJECT(bp, rb->responseType) <= 0)\\r\\ngoto err;\\r\\nif (OBJ_obj2nid(rb->responseType) != NID_id_pkix_OCSP_basic) {\\r\\nBIO_puts(bp, \" (unknown response type)\\n\");\\r\\nreturn 1;\\r\\n}\\r\\ni = ASN1_STRING_length(rb->response);\\r\\nif (!(br = OCSP_response_get1_basic(o)))\\r\\ngoto err;\\r\\nrd = br->tbsResponseData;\\r\\nl = ASN1_INTEGER_get(rd->version);\\r\\nif (BIO_printf(bp, \"\\n Version: %lu (0x%lx)\\n\", l + 1, l) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \" Responder Id: \") <= 0)\\r\\ngoto err;\\r\\nrid = rd->responderId;\\r\\nswitch (rid->type) {\\r\\ncase V_OCSP_RESPID_NAME:\\r\\nX509_NAME_print_ex(bp, rid->value.byName, 0, XN_FLAG_ONELINE);\\r\\nbreak;\\r\\ncase V_OCSP_RESPID_KEY:\\r\\ni2a_ASN1_STRING(bp, rid->value.byKey, V_ASN1_OCTET_STRING);\\r\\nbreak;\\r\\n}\\r\\nif (BIO_printf(bp, \"\\n Produced At: \") <= 0)\\r\\ngoto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp, rd->producedAt))\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"\\n Responses:\\n\") <= 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < sk_OCSP_SINGLERESP_num(rd->responses); i++) {\\r\\nif (!sk_OCSP_SINGLERESP_value(rd->responses, i))\\r\\ncontinue;\\r\\nsingle = sk_OCSP_SINGLERESP_value(rd->responses, i);\\r\\ncid = single->certId;\\r\\nif (ocsp_certid_print(bp, cid, 4) <= 0)\\r\\ngoto err;\\r\\ncst = single->certStatus;\\r\\nif (BIO_printf(bp, \" Cert Status: %s\",\\r\\nOCSP_cert_status_str(cst->type)) <= 0)\\r\\ngoto err;\\r\\nif (cst->type == V_OCSP_CERTSTATUS_REVOKED) {\\r\\nrev = cst->value.revoked;\\r\\nif (BIO_printf(bp, \"\\n Revocation Time: \") <= 0)\\r\\ngoto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp, rev->revocationTime))\\r\\ngoto err;\\r\\nif (rev->revocationReason) {\\r\\nl = ASN1_ENUMERATED_get(rev->revocationReason);\\r\\nif (BIO_printf(bp,\\r\\n\"\\n Revocation Reason: %s (0x%lx)\",\\r\\nOCSP_crl_reason_str(l), l) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (BIO_printf(bp, \"\\n This Update: \") <= 0)\\r\\ngoto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp, single->thisUpdate))\\r\\ngoto err;\\r\\nif (single->nextUpdate) {\\r\\nif (BIO_printf(bp, \"\\n Next Update: \") <= 0)\\r\\ngoto err;\\r\\nif (!ASN1_GENERALIZEDTIME_print(bp, single->nextUpdate))\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\nif (!X509V3_extensions_print(bp,\\r\\n\"Response Single Extensions\",\\r\\nsingle->singleExtensions, flags, 8))\\r\\ngoto err;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!X509V3_extensions_print(bp, \"Response Extensions\",\\r\\nrd->responseExtensions, flags, 4))\\r\\ngoto err;\\r\\nif (X509_signature_print(bp, br->signatureAlgorithm, br->signature) <= 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < sk_X509_num(br->certs); i++) {\\r\\nX509_print(bp, sk_X509_value(br->certs, i));\\r\\nPEM_write_bio_X509(bp, sk_X509_value(br->certs, i));\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nOCSP_BASICRESP_free(br);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_aes_wrap_c", "target": 0, "func": "int AES_wrap_key(AES_KEY *key, const unsigned char *iv,\\r\\nunsigned char *out,\\r\\nconst unsigned char *in, unsigned int inlen)\\r\\n{\\r\\nreturn CRYPTO_128_wrap(key, iv, out, in, inlen, (block128_f) AES_encrypt);\\r\\n}\\r\\nint AES_unwrap_key(AES_KEY *key, const unsigned char *iv,\\r\\nunsigned char *out,\\r\\nconst unsigned char *in, unsigned int inlen)\\r\\n{\\r\\nreturn CRYPTO_128_unwrap(key, iv, out, in, inlen,\\r\\n(block128_f) AES_decrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_ssl_c", "target": 0, "func": "int RSA_padding_add_SSLv23(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nint i, j;\\r\\nunsigned char *p;\\r\\nif (flen > (tlen - 11)) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_SSLV23,\\r\\nRSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn (0);\\r\\n}\\r\\np = (unsigned char *)to;\\r\\n*(p++) = 0;\\r\\n*(p++) = 2;\\r\\nj = tlen - 3 - 8 - flen;\\r\\nif (RAND_bytes(p, j) <= 0)\\r\\nreturn (0);\\r\\nfor (i = 0; i < j; i++) {\\r\\nif (*p == '\\0')\\r\\ndo {\\r\\nif (RAND_bytes(p, 1) <= 0)\\r\\nreturn (0);\\r\\n} while (*p == '\\0');\\r\\np++;\\r\\n}\\r\\nmemset(p, 3, 8);\\r\\np += 8;\\r\\n*(p++) = '\\0';\\r\\nmemcpy(p, from, (unsigned int)flen);\\r\\nreturn (1);\\r\\n}\\r\\nint RSA_padding_check_SSLv23(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num)\\r\\n{\\r\\nint i, j, k;\\r\\nconst unsigned char *p;\\r\\np = from;\\r\\nif (flen < 10) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_DATA_TOO_SMALL);\\r\\nreturn (-1);\\r\\n}\\r\\nif ((num != (flen + 1)) || (*(p++) != 02)) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_BLOCK_TYPE_IS_NOT_02);\\r\\nreturn (-1);\\r\\n}\\r\\nj = flen - 1;\\r\\nfor (i = 0; i < j; i++)\\r\\nif (*(p++) == 0)\\r\\nbreak;\\r\\nif ((i == j) || (i < 8)) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23,\\r\\nRSA_R_NULL_BEFORE_BLOCK_MISSING);\\r\\nreturn (-1);\\r\\n}\\r\\nfor (k = -9; k < -1; k++) {\\r\\nif (p[k] != 0x03)\\r\\nbreak;\\r\\n}\\r\\nif (k == -1) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_SSLV3_ROLLBACK_ATTACK);\\r\\nreturn (-1);\\r\\n}\\r\\ni++;\\r\\nj -= i;\\r\\nif (j > tlen) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_SSLV23, RSA_R_DATA_TOO_LARGE);\\r\\nreturn (-1);\\r\\n}\\r\\nmemcpy(to, p, (unsigned int)j);\\r\\nreturn (j);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_seed_cfb_c", "target": 0, "func": "void SEED_cfb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const SEED_KEY_SCHEDULE *ks,\\r\\nunsigned char ivec[SEED_BLOCK_SIZE], int *num,\\r\\nint enc)\\r\\n{\\r\\nCRYPTO_cfb128_encrypt(in, out, len, ks, ivec, num, enc,\\r\\n(block128_f) SEED_encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_conf_c", "target": 0, "func": "static int ssl_match_option(SSL_CONF_CTX *cctx, const ssl_flag_tbl *tbl,\\r\\nconst char *name, int namelen, int onoff)\\r\\n{\\r\\nif (!(cctx->flags & tbl->name_flags & SSL_TFLAG_BOTH))\\r\\nreturn 0;\\r\\nif (namelen == -1) {\\r\\nif (strcmp(tbl->name, name))\\r\\nreturn 0;\\r\\n} else if (tbl->namelen != namelen\\r\\n|| strncasecmp(tbl->name, name, namelen))\\r\\nreturn 0;\\r\\nif (cctx->poptions) {\\r\\nif (tbl->name_flags & SSL_TFLAG_INV)\\r\\nonoff ^= 1;\\r\\nif (tbl->name_flags & SSL_TFLAG_CERT) {\\r\\nif (onoff)\\r\\n*cctx->pcert_flags |= tbl->option_value;\\r\\nelse\\r\\n*cctx->pcert_flags &= ~tbl->option_value;\\r\\n} else {\\r\\nif (onoff)\\r\\n*cctx->poptions |= tbl->option_value;\\r\\nelse\\r\\n*cctx->poptions &= ~tbl->option_value;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_set_option_list(const char *elem, int len, void *usr)\\r\\n{\\r\\nSSL_CONF_CTX *cctx = usr;\\r\\nsize_t i;\\r\\nconst ssl_flag_tbl *tbl;\\r\\nint onoff = 1;\\r\\nif (len != -1) {\\r\\nif (*elem == '+') {\\r\\nelem++;\\r\\nlen--;\\r\\nonoff = 1;\\r\\n} else if (*elem == '-') {\\r\\nelem++;\\r\\nlen--;\\r\\nonoff = 0;\\r\\n}\\r\\n}\\r\\nfor (i = 0, tbl = cctx->tbl; i < cctx->ntbl; i++, tbl++) {\\r\\nif (ssl_match_option(cctx, tbl, elem, len, onoff))\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ctrl_str_option(SSL_CONF_CTX *cctx, const char *cmd)\\r\\n{\\r\\nstatic const ssl_flag_tbl ssl_option_single[] = {\\r\\nSSL_FLAG_TBL(\"no_ssl2\", SSL_OP_NO_SSLv2),\\r\\nSSL_FLAG_TBL(\"no_ssl3\", SSL_OP_NO_SSLv3),\\r\\nSSL_FLAG_TBL(\"no_tls1\", SSL_OP_NO_TLSv1),\\r\\nSSL_FLAG_TBL(\"no_tls1_1\", SSL_OP_NO_TLSv1_1),\\r\\nSSL_FLAG_TBL(\"no_tls1_2\", SSL_OP_NO_TLSv1_2),\\r\\nSSL_FLAG_TBL(\"bugs\", SSL_OP_ALL),\\r\\nSSL_FLAG_TBL(\"no_comp\", SSL_OP_NO_COMPRESSION),\\r\\nSSL_FLAG_TBL_SRV(\"ecdh_single\", SSL_OP_SINGLE_ECDH_USE),\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nSSL_FLAG_TBL(\"no_ticket\", SSL_OP_NO_TICKET),\\r\\n#endif\\r\\nSSL_FLAG_TBL_SRV(\"serverpref\", SSL_OP_CIPHER_SERVER_PREFERENCE),\\r\\nSSL_FLAG_TBL(\"legacy_renegotiation\",\\r\\nSSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION),\\r\\nSSL_FLAG_TBL_SRV(\"legacy_server_connect\",\\r\\nSSL_OP_LEGACY_SERVER_CONNECT),\\r\\nSSL_FLAG_TBL_SRV(\"no_resumption_on_reneg\",\\r\\nSSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION),\\r\\nSSL_FLAG_TBL_SRV_INV(\"no_legacy_server_connect\",\\r\\nSSL_OP_LEGACY_SERVER_CONNECT),\\r\\nSSL_FLAG_TBL_CERT(\"strict\", SSL_CERT_FLAG_TLS_STRICT),\\r\\n#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\\r\\nSSL_FLAG_TBL_CERT(\"debug_broken_protocol\",\\r\\nSSL_CERT_FLAG_BROKEN_PROTOCOL),\\r\\n#endif\\r\\n};\\r\\ncctx->tbl = ssl_option_single;\\r\\ncctx->ntbl = sizeof(ssl_option_single) / sizeof(ssl_flag_tbl);\\r\\nreturn ssl_set_option_list(cmd, -1, cctx);\\r\\n}\\r\\nstatic int cmd_SignatureAlgorithms(SSL_CONF_CTX *cctx, const char *value)\\r\\n{\\r\\nint rv;\\r\\nif (cctx->ssl)\\r\\nrv = SSL_set1_sigalgs_list(cctx->ssl, value);\\r\\nelse\\r\\nrv = SSL_CTX_set1_sigalgs_list(cctx->ctx, value);\\r\\nreturn rv > 0;\\r\\n}\\r\\nstatic int cmd_ClientSignatureAlgorithms(SSL_CONF_CTX *cctx,\\r\\nconst char *value)\\r\\n{\\r\\nint rv;\\r\\nif (cctx->ssl)\\r\\nrv = SSL_set1_client_sigalgs_list(cctx->ssl, value);\\r\\nelse\\r\\nrv = SSL_CTX_set1_client_sigalgs_list(cctx->ctx, value);\\r\\nreturn rv > 0;\\r\\n}\\r\\nstatic int cmd_Curves(SSL_CONF_CTX *cctx, const char *value)\\r\\n{\\r\\nint rv;\\r\\nif (cctx->ssl)\\r\\nrv = SSL_set1_curves_list(cctx->ssl, value);\\r\\nelse\\r\\nrv = SSL_CTX_set1_curves_list(cctx->ctx, value);\\r\\nreturn rv > 0;\\r\\n}\\r\\nstatic int cmd_ECDHParameters(SSL_CONF_CTX *cctx, const char *value)\\r\\n{\\r\\nint onoff = -1, rv = 1;\\r\\nif (!(cctx->flags & SSL_CONF_FLAG_SERVER))\\r\\nreturn -2;\\r\\nif (cctx->flags & SSL_CONF_FLAG_FILE) {\\r\\nif (*value == '+') {\\r\\nonoff = 1;\\r\\nvalue++;\\r\\n}\\r\\nif (*value == '-') {\\r\\nonoff = 0;\\r\\nvalue++;\\r\\n}\\r\\nif (!strcasecmp(value, \"automatic\")) {\\r\\nif (onoff == -1)\\r\\nonoff = 1;\\r\\n} else if (onoff != -1)\\r\\nreturn 0;\\r\\n} else if (cctx->flags & SSL_CONF_FLAG_CMDLINE) {\\r\\nif (!strcmp(value, \"auto\"))\\r\\nonoff = 1;\\r\\n}\\r\\nif (onoff != -1) {\\r\\nif (cctx->ctx)\\r\\nrv = SSL_CTX_set_ecdh_auto(cctx->ctx, onoff);\\r\\nelse if (cctx->ssl)\\r\\nrv = SSL_set_ecdh_auto(cctx->ssl, onoff);\\r\\n} else {\\r\\nEC_KEY *ecdh;\\r\\nint nid;\\r\\nnid = EC_curve_nist2nid(value);\\r\\nif (nid == NID_undef)\\r\\nnid = OBJ_sn2nid(value);\\r\\nif (nid == 0)\\r\\nreturn 0;\\r\\necdh = EC_KEY_new_by_curve_name(nid);\\r\\nif (!ecdh)\\r\\nreturn 0;\\r\\nif (cctx->ctx)\\r\\nrv = SSL_CTX_set_tmp_ecdh(cctx->ctx, ecdh);\\r\\nelse if (cctx->ssl)\\r\\nrv = SSL_set_tmp_ecdh(cctx->ssl, ecdh);\\r\\nEC_KEY_free(ecdh);\\r\\n}\\r\\nreturn rv > 0;\\r\\n}\\r\\nstatic int cmd_CipherString(SSL_CONF_CTX *cctx, const char *value)\\r\\n{\\r\\nint rv = 1;\\r\\nif (cctx->ctx)\\r\\nrv = SSL_CTX_set_cipher_list(cctx->ctx, value);\\r\\nif (cctx->ssl)\\r\\nrv = SSL_set_cipher_list(cctx->ssl, value);\\r\\nreturn rv > 0;\\r\\n}\\r\\nstatic int cmd_Protocol(SSL_CONF_CTX *cctx, const char *value)\\r\\n{\\r\\nstatic const ssl_flag_tbl ssl_protocol_list[] = {\\r\\nSSL_FLAG_TBL_INV(\"ALL\", SSL_OP_NO_SSL_MASK),\\r\\nSSL_FLAG_TBL_INV(\"SSLv2\", SSL_OP_NO_SSLv2),\\r\\nSSL_FLAG_TBL_INV(\"SSLv3\", SSL_OP_NO_SSLv3),\\r\\nSSL_FLAG_TBL_INV(\"TLSv1\", SSL_OP_NO_TLSv1),\\r\\nSSL_FLAG_TBL_INV(\"TLSv1.1\", SSL_OP_NO_TLSv1_1),\\r\\nSSL_FLAG_TBL_INV(\"TLSv1.2\", SSL_OP_NO_TLSv1_2)\\r\\n};\\r\\nif (!(cctx->flags & SSL_CONF_FLAG_FILE))\\r\\nreturn -2;\\r\\ncctx->tbl = ssl_protocol_list;\\r\\ncctx->ntbl = sizeof(ssl_protocol_list) / sizeof(ssl_flag_tbl);\\r\\nreturn CONF_parse_list(value, ',', 1, ssl_set_option_list, cctx);\\r\\n}\\r\\nstatic int cmd_Options(SSL_CONF_CTX *cctx, const char *value)\\r\\n{\\r\\nstatic const ssl_flag_tbl ssl_option_list[] = {\\r\\nSSL_FLAG_TBL_INV(\"SessionTicket\", SSL_OP_NO_TICKET),\\r\\nSSL_FLAG_TBL_INV(\"EmptyFragments\",\\r\\nSSL_OP_DONT_INSERT_EMPTY_FRAGMENTS),\\r\\nSSL_FLAG_TBL(\"Bugs\", SSL_OP_ALL),\\r\\nSSL_FLAG_TBL_INV(\"Compression\", SSL_OP_NO_COMPRESSION),\\r\\nSSL_FLAG_TBL_SRV(\"ServerPreference\", SSL_OP_CIPHER_SERVER_PREFERENCE),\\r\\nSSL_FLAG_TBL_SRV(\"NoResumptionOnRenegotiation\",\\r\\nSSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION),\\r\\nSSL_FLAG_TBL_SRV(\"DHSingle\", SSL_OP_SINGLE_DH_USE),\\r\\nSSL_FLAG_TBL_SRV(\"ECDHSingle\", SSL_OP_SINGLE_ECDH_USE),\\r\\nSSL_FLAG_TBL(\"UnsafeLegacyRenegotiation\",\\r\\nSSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION),\\r\\n};\\r\\nif (!(cctx->flags & SSL_CONF_FLAG_FILE))\\r\\nreturn -2;\\r\\nif (value == NULL)\\r\\nreturn -3;\\r\\ncctx->tbl = ssl_option_list;\\r\\ncctx->ntbl = sizeof(ssl_option_list) / sizeof(ssl_flag_tbl);\\r\\nreturn CONF_parse_list(value, ',', 1, ssl_set_option_list, cctx);\\r\\n}\\r\\nstatic int cmd_Certificate(SSL_CONF_CTX *cctx, const char *value)\\r\\n{\\r\\nint rv = 1;\\r\\nif (!(cctx->flags & SSL_CONF_FLAG_CERTIFICATE))\\r\\nreturn -2;\\r\\nif (cctx->ctx)\\r\\nrv = SSL_CTX_use_certificate_chain_file(cctx->ctx, value);\\r\\nif (cctx->ssl)\\r\\nrv = SSL_use_certificate_file(cctx->ssl, value, SSL_FILETYPE_PEM);\\r\\nreturn rv > 0;\\r\\n}\\r\\nstatic int cmd_PrivateKey(SSL_CONF_CTX *cctx, const char *value)\\r\\n{\\r\\nint rv = 1;\\r\\nif (!(cctx->flags & SSL_CONF_FLAG_CERTIFICATE))\\r\\nreturn -2;\\r\\nif (cctx->ctx)\\r\\nrv = SSL_CTX_use_PrivateKey_file(cctx->ctx, value, SSL_FILETYPE_PEM);\\r\\nif (cctx->ssl)\\r\\nrv = SSL_use_PrivateKey_file(cctx->ssl, value, SSL_FILETYPE_PEM);\\r\\nreturn rv > 0;\\r\\n}\\r\\nstatic int cmd_DHParameters(SSL_CONF_CTX *cctx, const char *value)\\r\\n{\\r\\nint rv = 0;\\r\\nDH *dh = NULL;\\r\\nBIO *in = NULL;\\r\\nif (!(cctx->flags & SSL_CONF_FLAG_CERTIFICATE))\\r\\nreturn -2;\\r\\nif (cctx->ctx || cctx->ssl) {\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif (!in)\\r\\ngoto end;\\r\\nif (BIO_read_filename(in, value) <= 0)\\r\\ngoto end;\\r\\ndh = PEM_read_bio_DHparams(in, NULL, NULL, NULL);\\r\\nif (!dh)\\r\\ngoto end;\\r\\n} else\\r\\nreturn 1;\\r\\nif (cctx->ctx)\\r\\nrv = SSL_CTX_set_tmp_dh(cctx->ctx, dh);\\r\\nif (cctx->ssl)\\r\\nrv = SSL_set_tmp_dh(cctx->ssl, dh);\\r\\nend:\\r\\nif (dh)\\r\\nDH_free(dh);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nreturn rv > 0;\\r\\n}\\r\\nstatic int ssl_conf_cmd_skip_prefix(SSL_CONF_CTX *cctx, const char **pcmd)\\r\\n{\\r\\nif (!pcmd || !*pcmd)\\r\\nreturn 0;\\r\\nif (cctx->prefix) {\\r\\nif (strlen(*pcmd) <= cctx->prefixlen)\\r\\nreturn 0;\\r\\nif (cctx->flags & SSL_CONF_FLAG_CMDLINE &&\\r\\nstrncmp(*pcmd, cctx->prefix, cctx->prefixlen))\\r\\nreturn 0;\\r\\nif (cctx->flags & SSL_CONF_FLAG_FILE &&\\r\\nstrncasecmp(*pcmd, cctx->prefix, cctx->prefixlen))\\r\\nreturn 0;\\r\\n*pcmd += cctx->prefixlen;\\r\\n} else if (cctx->flags & SSL_CONF_FLAG_CMDLINE) {\\r\\nif (**pcmd != '-' || !(*pcmd)[1])\\r\\nreturn 0;\\r\\n*pcmd += 1;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic const ssl_conf_cmd_tbl *ssl_conf_cmd_lookup(SSL_CONF_CTX *cctx,\\r\\nconst char *cmd)\\r\\n{\\r\\nconst ssl_conf_cmd_tbl *t;\\r\\nsize_t i;\\r\\nif (cmd == NULL)\\r\\nreturn NULL;\\r\\nfor (i = 0, t = ssl_conf_cmds;\\r\\ni < sizeof(ssl_conf_cmds) / sizeof(ssl_conf_cmd_tbl); i++, t++) {\\r\\nif (cctx->flags & SSL_CONF_FLAG_CMDLINE) {\\r\\nif (t->str_cmdline && !strcmp(t->str_cmdline, cmd))\\r\\nreturn t;\\r\\n}\\r\\nif (cctx->flags & SSL_CONF_FLAG_FILE) {\\r\\nif (t->str_file && !strcasecmp(t->str_file, cmd))\\r\\nreturn t;\\r\\n}\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nint SSL_CONF_cmd(SSL_CONF_CTX *cctx, const char *cmd, const char *value)\\r\\n{\\r\\nconst ssl_conf_cmd_tbl *runcmd;\\r\\nif (cmd == NULL) {\\r\\nSSLerr(SSL_F_SSL_CONF_CMD, SSL_R_INVALID_NULL_CMD_NAME);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ssl_conf_cmd_skip_prefix(cctx, &cmd))\\r\\nreturn -2;\\r\\nruncmd = ssl_conf_cmd_lookup(cctx, cmd);\\r\\nif (runcmd) {\\r\\nint rv;\\r\\nif (value == NULL)\\r\\nreturn -3;\\r\\nrv = runcmd->cmd(cctx, value);\\r\\nif (rv > 0)\\r\\nreturn 2;\\r\\nif (rv == -2)\\r\\nreturn -2;\\r\\nif (cctx->flags & SSL_CONF_FLAG_SHOW_ERRORS) {\\r\\nSSLerr(SSL_F_SSL_CONF_CMD, SSL_R_BAD_VALUE);\\r\\nERR_add_error_data(4, \"cmd=\", cmd, \", value=\", value);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nif (cctx->flags & SSL_CONF_FLAG_CMDLINE) {\\r\\nif (ctrl_str_option(cctx, cmd))\\r\\nreturn 1;\\r\\n}\\r\\nif (cctx->flags & SSL_CONF_FLAG_SHOW_ERRORS) {\\r\\nSSLerr(SSL_F_SSL_CONF_CMD, SSL_R_UNKNOWN_CMD_NAME);\\r\\nERR_add_error_data(2, \"cmd=\", cmd);\\r\\n}\\r\\nreturn -2;\\r\\n}\\r\\nint SSL_CONF_cmd_argv(SSL_CONF_CTX *cctx, int *pargc, char ***pargv)\\r\\n{\\r\\nint rv;\\r\\nconst char *arg = NULL, *argn;\\r\\nif (pargc && *pargc == 0)\\r\\nreturn 0;\\r\\nif (!pargc || *pargc > 0)\\r\\narg = **pargv;\\r\\nif (arg == NULL)\\r\\nreturn 0;\\r\\nif (!pargc || *pargc > 1)\\r\\nargn = (*pargv)[1];\\r\\nelse\\r\\nargn = NULL;\\r\\ncctx->flags &= ~SSL_CONF_FLAG_FILE;\\r\\ncctx->flags |= SSL_CONF_FLAG_CMDLINE;\\r\\nrv = SSL_CONF_cmd(cctx, arg, argn);\\r\\nif (rv > 0) {\\r\\n(*pargv) += rv;\\r\\nif (pargc)\\r\\n(*pargc) -= rv;\\r\\nreturn rv;\\r\\n}\\r\\nif (rv == -2)\\r\\nreturn 0;\\r\\nif (rv == 0)\\r\\nreturn -1;\\r\\nreturn rv;\\r\\n}\\r\\nint SSL_CONF_cmd_value_type(SSL_CONF_CTX *cctx, const char *cmd)\\r\\n{\\r\\nif (ssl_conf_cmd_skip_prefix(cctx, &cmd)) {\\r\\nconst ssl_conf_cmd_tbl *runcmd;\\r\\nruncmd = ssl_conf_cmd_lookup(cctx, cmd);\\r\\nif (runcmd)\\r\\nreturn runcmd->value_type;\\r\\n}\\r\\nreturn SSL_CONF_TYPE_UNKNOWN;\\r\\n}\\r\\nSSL_CONF_CTX *SSL_CONF_CTX_new(void)\\r\\n{\\r\\nSSL_CONF_CTX *ret;\\r\\nret = OPENSSL_malloc(sizeof(SSL_CONF_CTX));\\r\\nif (ret) {\\r\\nret->flags = 0;\\r\\nret->prefix = NULL;\\r\\nret->prefixlen = 0;\\r\\nret->ssl = NULL;\\r\\nret->ctx = NULL;\\r\\nret->poptions = NULL;\\r\\nret->pcert_flags = NULL;\\r\\nret->tbl = NULL;\\r\\nret->ntbl = 0;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint SSL_CONF_CTX_finish(SSL_CONF_CTX *cctx)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nvoid SSL_CONF_CTX_free(SSL_CONF_CTX *cctx)\\r\\n{\\r\\nif (cctx) {\\r\\nif (cctx->prefix)\\r\\nOPENSSL_free(cctx->prefix);\\r\\nOPENSSL_free(cctx);\\r\\n}\\r\\n}\\r\\nunsigned int SSL_CONF_CTX_set_flags(SSL_CONF_CTX *cctx, unsigned int flags)\\r\\n{\\r\\ncctx->flags |= flags;\\r\\nreturn cctx->flags;\\r\\n}\\r\\nunsigned int SSL_CONF_CTX_clear_flags(SSL_CONF_CTX *cctx, unsigned int flags)\\r\\n{\\r\\ncctx->flags &= ~flags;\\r\\nreturn cctx->flags;\\r\\n}\\r\\nint SSL_CONF_CTX_set1_prefix(SSL_CONF_CTX *cctx, const char *pre)\\r\\n{\\r\\nchar *tmp = NULL;\\r\\nif (pre) {\\r\\ntmp = BUF_strdup(pre);\\r\\nif (tmp == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nif (cctx->prefix)\\r\\nOPENSSL_free(cctx->prefix);\\r\\ncctx->prefix = tmp;\\r\\nif (tmp)\\r\\ncctx->prefixlen = strlen(tmp);\\r\\nelse\\r\\ncctx->prefixlen = 0;\\r\\nreturn 1;\\r\\n}\\r\\nvoid SSL_CONF_CTX_set_ssl(SSL_CONF_CTX *cctx, SSL *ssl)\\r\\n{\\r\\ncctx->ssl = ssl;\\r\\ncctx->ctx = NULL;\\r\\nif (ssl) {\\r\\ncctx->poptions = &ssl->options;\\r\\ncctx->pcert_flags = &ssl->cert->cert_flags;\\r\\n} else {\\r\\ncctx->poptions = NULL;\\r\\ncctx->pcert_flags = NULL;\\r\\n}\\r\\n}\\r\\nvoid SSL_CONF_CTX_set_ssl_ctx(SSL_CONF_CTX *cctx, SSL_CTX *ctx)\\r\\n{\\r\\ncctx->ctx = ctx;\\r\\ncctx->ssl = NULL;\\r\\nif (ctx) {\\r\\ncctx->poptions = &ctx->options;\\r\\ncctx->pcert_flags = &ctx->cert->cert_flags;\\r\\n} else {\\r\\ncctx->poptions = NULL;\\r\\ncctx->pcert_flags = NULL;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tb_pkmeth_c", "target": 0, "func": "void ENGINE_unregister_pkey_meths(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&pkey_meth_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_pkey_meths(void)\\r\\n{\\r\\nengine_table_cleanup(&pkey_meth_table);\\r\\n}\\r\\nint ENGINE_register_pkey_meths(ENGINE *e)\\r\\n{\\r\\nif (e->pkey_meths) {\\r\\nconst int *nids;\\r\\nint num_nids = e->pkey_meths(e, NULL, &nids, 0);\\r\\nif (num_nids > 0)\\r\\nreturn engine_table_register(&pkey_meth_table,\\r\\nengine_unregister_all_pkey_meths, e,\\r\\nnids, num_nids, 0);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_pkey_meths()\\r\\n{\\r\\nENGINE *e;\\r\\nfor (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))\\r\\nENGINE_register_pkey_meths(e);\\r\\n}\\r\\nint ENGINE_set_default_pkey_meths(ENGINE *e)\\r\\n{\\r\\nif (e->pkey_meths) {\\r\\nconst int *nids;\\r\\nint num_nids = e->pkey_meths(e, NULL, &nids, 0);\\r\\nif (num_nids > 0)\\r\\nreturn engine_table_register(&pkey_meth_table,\\r\\nengine_unregister_all_pkey_meths, e,\\r\\nnids, num_nids, 1);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_pkey_meth_engine(int nid)\\r\\n{\\r\\nreturn engine_table_select(&pkey_meth_table, nid);\\r\\n}\\r\\nconst EVP_PKEY_METHOD *ENGINE_get_pkey_meth(ENGINE *e, int nid)\\r\\n{\\r\\nEVP_PKEY_METHOD *ret;\\r\\nENGINE_PKEY_METHS_PTR fn = ENGINE_get_pkey_meths(e);\\r\\nif (!fn || !fn(e, &ret, NULL, nid)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_PKEY_METH,\\r\\nENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nENGINE_PKEY_METHS_PTR ENGINE_get_pkey_meths(const ENGINE *e)\\r\\n{\\r\\nreturn e->pkey_meths;\\r\\n}\\r\\nint ENGINE_set_pkey_meths(ENGINE *e, ENGINE_PKEY_METHS_PTR f)\\r\\n{\\r\\ne->pkey_meths = f;\\r\\nreturn 1;\\r\\n}\\r\\nvoid engine_pkey_meths_free(ENGINE *e)\\r\\n{\\r\\nint i;\\r\\nEVP_PKEY_METHOD *pkm;\\r\\nif (e->pkey_meths) {\\r\\nconst int *pknids;\\r\\nint npknids;\\r\\nnpknids = e->pkey_meths(e, NULL, &pknids, 0);\\r\\nfor (i = 0; i < npknids; i++) {\\r\\nif (e->pkey_meths(e, &pkm, NULL, pknids[i])) {\\r\\nEVP_PKEY_meth_free(pkm);\\r\\n}\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_lhash_c", "target": 0, "func": "_LHASH *lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)\\r\\n{\\r\\n_LHASH *ret;\\r\\nint i;\\r\\nif ((ret = OPENSSL_malloc(sizeof(_LHASH))) == NULL)\\r\\ngoto err0;\\r\\nif ((ret->b = OPENSSL_malloc(sizeof(LHASH_NODE *) * MIN_NODES)) == NULL)\\r\\ngoto err1;\\r\\nfor (i = 0; i < MIN_NODES; i++)\\r\\nret->b[i] = NULL;\\r\\nret->comp = ((c == NULL) ? (LHASH_COMP_FN_TYPE)strcmp : c);\\r\\nret->hash = ((h == NULL) ? (LHASH_HASH_FN_TYPE)lh_strhash : h);\\r\\nret->num_nodes = MIN_NODES / 2;\\r\\nret->num_alloc_nodes = MIN_NODES;\\r\\nret->p = 0;\\r\\nret->pmax = MIN_NODES / 2;\\r\\nret->up_load = UP_LOAD;\\r\\nret->down_load = DOWN_LOAD;\\r\\nret->num_items = 0;\\r\\nret->num_expands = 0;\\r\\nret->num_expand_reallocs = 0;\\r\\nret->num_contracts = 0;\\r\\nret->num_contract_reallocs = 0;\\r\\nret->num_hash_calls = 0;\\r\\nret->num_comp_calls = 0;\\r\\nret->num_insert = 0;\\r\\nret->num_replace = 0;\\r\\nret->num_delete = 0;\\r\\nret->num_no_delete = 0;\\r\\nret->num_retrieve = 0;\\r\\nret->num_retrieve_miss = 0;\\r\\nret->num_hash_comps = 0;\\r\\nret->error = 0;\\r\\nreturn (ret);\\r\\nerr1:\\r\\nOPENSSL_free(ret);\\r\\nerr0:\\r\\nreturn (NULL);\\r\\n}\\r\\nvoid lh_free(_LHASH *lh)\\r\\n{\\r\\nunsigned int i;\\r\\nLHASH_NODE *n, *nn;\\r\\nif (lh == NULL)\\r\\nreturn;\\r\\nfor (i = 0; i < lh->num_nodes; i++) {\\r\\nn = lh->b[i];\\r\\nwhile (n != NULL) {\\r\\nnn = n->next;\\r\\nOPENSSL_free(n);\\r\\nn = nn;\\r\\n}\\r\\n}\\r\\nOPENSSL_free(lh->b);\\r\\nOPENSSL_free(lh);\\r\\n}\\r\\nvoid *lh_insert(_LHASH *lh, void *data)\\r\\n{\\r\\nunsigned long hash;\\r\\nLHASH_NODE *nn, **rn;\\r\\nvoid *ret;\\r\\nlh->error = 0;\\r\\nif (lh->up_load <= (lh->num_items * LH_LOAD_MULT / lh->num_nodes))\\r\\nexpand(lh);\\r\\nrn = getrn(lh, data, &hash);\\r\\nif (*rn == NULL) {\\r\\nif ((nn = (LHASH_NODE *)OPENSSL_malloc(sizeof(LHASH_NODE))) == NULL) {\\r\\nlh->error++;\\r\\nreturn (NULL);\\r\\n}\\r\\nnn->data = data;\\r\\nnn->next = NULL;\\r\\n#ifndef OPENSSL_NO_HASH_COMP\\r\\nnn->hash = hash;\\r\\n#endif\\r\\n*rn = nn;\\r\\nret = NULL;\\r\\nlh->num_insert++;\\r\\nlh->num_items++;\\r\\n} else {\\r\\nret = (*rn)->data;\\r\\n(*rn)->data = data;\\r\\nlh->num_replace++;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid *lh_delete(_LHASH *lh, const void *data)\\r\\n{\\r\\nunsigned long hash;\\r\\nLHASH_NODE *nn, **rn;\\r\\nvoid *ret;\\r\\nlh->error = 0;\\r\\nrn = getrn(lh, data, &hash);\\r\\nif (*rn == NULL) {\\r\\nlh->num_no_delete++;\\r\\nreturn (NULL);\\r\\n} else {\\r\\nnn = *rn;\\r\\n*rn = nn->next;\\r\\nret = nn->data;\\r\\nOPENSSL_free(nn);\\r\\nlh->num_delete++;\\r\\n}\\r\\nlh->num_items--;\\r\\nif ((lh->num_nodes > MIN_NODES) &&\\r\\n(lh->down_load >= (lh->num_items * LH_LOAD_MULT / lh->num_nodes)))\\r\\ncontract(lh);\\r\\nreturn (ret);\\r\\n}\\r\\nvoid *lh_retrieve(_LHASH *lh, const void *data)\\r\\n{\\r\\nunsigned long hash;\\r\\nLHASH_NODE **rn;\\r\\nvoid *ret;\\r\\nlh->error = 0;\\r\\nrn = getrn(lh, data, &hash);\\r\\nif (*rn == NULL) {\\r\\nlh->num_retrieve_miss++;\\r\\nreturn (NULL);\\r\\n} else {\\r\\nret = (*rn)->data;\\r\\nlh->num_retrieve++;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic void doall_util_fn(_LHASH *lh, int use_arg, LHASH_DOALL_FN_TYPE func,\\r\\nLHASH_DOALL_ARG_FN_TYPE func_arg, void *arg)\\r\\n{\\r\\nint i;\\r\\nLHASH_NODE *a, *n;\\r\\nif (lh == NULL)\\r\\nreturn;\\r\\nfor (i = lh->num_nodes - 1; i >= 0; i--) {\\r\\na = lh->b[i];\\r\\nwhile (a != NULL) {\\r\\nn = a->next;\\r\\nif (use_arg)\\r\\nfunc_arg(a->data, arg);\\r\\nelse\\r\\nfunc(a->data);\\r\\na = n;\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid lh_doall(_LHASH *lh, LHASH_DOALL_FN_TYPE func)\\r\\n{\\r\\ndoall_util_fn(lh, 0, func, (LHASH_DOALL_ARG_FN_TYPE)0, NULL);\\r\\n}\\r\\nvoid lh_doall_arg(_LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)\\r\\n{\\r\\ndoall_util_fn(lh, 1, (LHASH_DOALL_FN_TYPE)0, func, arg);\\r\\n}\\r\\nstatic void expand(_LHASH *lh)\\r\\n{\\r\\nLHASH_NODE **n, **n1, **n2, *np;\\r\\nunsigned int p, i, j;\\r\\nunsigned long hash, nni;\\r\\nlh->num_nodes++;\\r\\nlh->num_expands++;\\r\\np = (int)lh->p++;\\r\\nn1 = &(lh->b[p]);\\r\\nn2 = &(lh->b[p + (int)lh->pmax]);\\r\\n*n2 = NULL;\\r\\nnni = lh->num_alloc_nodes;\\r\\nfor (np = *n1; np != NULL;) {\\r\\n#ifndef OPENSSL_NO_HASH_COMP\\r\\nhash = np->hash;\\r\\n#else\\r\\nhash = lh->hash(np->data);\\r\\nlh->num_hash_calls++;\\r\\n#endif\\r\\nif ((hash % nni) != p) {\\r\\n*n1 = (*n1)->next;\\r\\nnp->next = *n2;\\r\\n*n2 = np;\\r\\n} else\\r\\nn1 = &((*n1)->next);\\r\\nnp = *n1;\\r\\n}\\r\\nif ((lh->p) >= lh->pmax) {\\r\\nj = (int)lh->num_alloc_nodes * 2;\\r\\nn = (LHASH_NODE **)OPENSSL_realloc(lh->b,\\r\\n(int)(sizeof(LHASH_NODE *) * j));\\r\\nif (n == NULL) {\\r\\nlh->error++;\\r\\nlh->p = 0;\\r\\nreturn;\\r\\n}\\r\\nfor (i = (int)lh->num_alloc_nodes; i < j; i++)\\r\\nn[i] = NULL;\\r\\nlh->pmax = lh->num_alloc_nodes;\\r\\nlh->num_alloc_nodes = j;\\r\\nlh->num_expand_reallocs++;\\r\\nlh->p = 0;\\r\\nlh->b = n;\\r\\n}\\r\\n}\\r\\nstatic void contract(_LHASH *lh)\\r\\n{\\r\\nLHASH_NODE **n, *n1, *np;\\r\\nnp = lh->b[lh->p + lh->pmax - 1];\\r\\nlh->b[lh->p + lh->pmax - 1] = NULL;\\r\\nif (lh->p == 0) {\\r\\nn = (LHASH_NODE **)OPENSSL_realloc(lh->b,\\r\\n(unsigned int)(sizeof(LHASH_NODE *)\\r\\n* lh->pmax));\\r\\nif (n == NULL) {\\r\\nlh->error++;\\r\\nreturn;\\r\\n}\\r\\nlh->num_contract_reallocs++;\\r\\nlh->num_alloc_nodes /= 2;\\r\\nlh->pmax /= 2;\\r\\nlh->p = lh->pmax - 1;\\r\\nlh->b = n;\\r\\n} else\\r\\nlh->p--;\\r\\nlh->num_nodes--;\\r\\nlh->num_contracts++;\\r\\nn1 = lh->b[(int)lh->p];\\r\\nif (n1 == NULL)\\r\\nlh->b[(int)lh->p] = np;\\r\\nelse {\\r\\nwhile (n1->next != NULL)\\r\\nn1 = n1->next;\\r\\nn1->next = np;\\r\\n}\\r\\n}\\r\\nstatic LHASH_NODE **getrn(_LHASH *lh, const void *data, unsigned long *rhash)\\r\\n{\\r\\nLHASH_NODE **ret, *n1;\\r\\nunsigned long hash, nn;\\r\\nLHASH_COMP_FN_TYPE cf;\\r\\nhash = (*(lh->hash)) (data);\\r\\nlh->num_hash_calls++;\\r\\n*rhash = hash;\\r\\nnn = hash % lh->pmax;\\r\\nif (nn < lh->p)\\r\\nnn = hash % lh->num_alloc_nodes;\\r\\ncf = lh->comp;\\r\\nret = &(lh->b[(int)nn]);\\r\\nfor (n1 = *ret; n1 != NULL; n1 = n1->next) {\\r\\n#ifndef OPENSSL_NO_HASH_COMP\\r\\nlh->num_hash_comps++;\\r\\nif (n1->hash != hash) {\\r\\nret = &(n1->next);\\r\\ncontinue;\\r\\n}\\r\\n#endif\\r\\nlh->num_comp_calls++;\\r\\nif (cf(n1->data, data) == 0)\\r\\nbreak;\\r\\nret = &(n1->next);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nunsigned long lh_strhash(const char *c)\\r\\n{\\r\\nunsigned long ret = 0;\\r\\nlong n;\\r\\nunsigned long v;\\r\\nint r;\\r\\nif ((c == NULL) || (*c == '\\0'))\\r\\nreturn (ret);\\r\\nn = 0x100;\\r\\nwhile (*c) {\\r\\nv = n | (*c);\\r\\nn += 0x100;\\r\\nr = (int)((v >> 2) ^ v) & 0x0f;\\r\\nret = (ret << r) | (ret >> (32 - r));\\r\\nret &= 0xFFFFFFFFL;\\r\\nret ^= v * v;\\r\\nc++;\\r\\n}\\r\\nreturn ((ret >> 16) ^ ret);\\r\\n}\\r\\nunsigned long lh_num_items(const _LHASH *lh)\\r\\n{\\r\\nreturn lh ? lh->num_items : 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_txt_c", "target": 0, "func": "int SSL_SESSION_print_fp(FILE *fp, const SSL_SESSION *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file_internal())) == NULL) {\\r\\nSSLerr(SSL_F_SSL_SESSION_PRINT_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = SSL_SESSION_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_SESSION_print(BIO *bp, const SSL_SESSION *x)\\r\\n{\\r\\nunsigned int i;\\r\\nconst char *s;\\r\\nif (x == NULL)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"SSL-Session:\\n\") <= 0)\\r\\ngoto err;\\r\\nif (x->ssl_version == SSL2_VERSION)\\r\\ns = \"SSLv2\";\\r\\nelse if (x->ssl_version == SSL3_VERSION)\\r\\ns = \"SSLv3\";\\r\\nelse if (x->ssl_version == TLS1_2_VERSION)\\r\\ns = \"TLSv1.2\";\\r\\nelse if (x->ssl_version == TLS1_1_VERSION)\\r\\ns = \"TLSv1.1\";\\r\\nelse if (x->ssl_version == TLS1_VERSION)\\r\\ns = \"TLSv1\";\\r\\nelse if (x->ssl_version == DTLS1_VERSION)\\r\\ns = \"DTLSv1\";\\r\\nelse if (x->ssl_version == DTLS1_2_VERSION)\\r\\ns = \"DTLSv1.2\";\\r\\nelse if (x->ssl_version == DTLS1_BAD_VER)\\r\\ns = \"DTLSv1-bad\";\\r\\nelse\\r\\ns = \"unknown\";\\r\\nif (BIO_printf(bp, \" Protocol : %s\\n\", s) <= 0)\\r\\ngoto err;\\r\\nif (x->cipher == NULL) {\\r\\nif (((x->cipher_id) & 0xff000000) == 0x02000000) {\\r\\nif (BIO_printf\\r\\n(bp, \" Cipher : %06lX\\n\", x->cipher_id & 0xffffff) <= 0)\\r\\ngoto err;\\r\\n} else {\\r\\nif (BIO_printf\\r\\n(bp, \" Cipher : %04lX\\n\", x->cipher_id & 0xffff) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nif (BIO_printf\\r\\n(bp, \" Cipher : %s\\n\",\\r\\n((x->cipher == NULL) ? \"unknown\" : x->cipher->name)) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_puts(bp, \" Session-ID: \") <= 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < x->session_id_length; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", x->session_id[i]) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_puts(bp, \"\\n Session-ID-ctx: \") <= 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < x->sid_ctx_length; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", x->sid_ctx[i]) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_puts(bp, \"\\n Master-Key: \") <= 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < (unsigned int)x->master_key_length; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", x->master_key[i]) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_puts(bp, \"\\n Key-Arg : \") <= 0)\\r\\ngoto err;\\r\\nif (x->key_arg_length == 0) {\\r\\nif (BIO_puts(bp, \"None\") <= 0)\\r\\ngoto err;\\r\\n} else\\r\\nfor (i = 0; i < x->key_arg_length; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", x->key_arg[i]) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (BIO_puts(bp, \"\\n Krb5 Principal: \") <= 0)\\r\\ngoto err;\\r\\nif (x->krb5_client_princ_len == 0) {\\r\\nif (BIO_puts(bp, \"None\") <= 0)\\r\\ngoto err;\\r\\n} else\\r\\nfor (i = 0; i < x->krb5_client_princ_len; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", x->krb5_client_princ[i]) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nif (BIO_puts(bp, \"\\n PSK identity: \") <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"%s\", x->psk_identity ? x->psk_identity : \"None\") <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"\\n PSK identity hint: \") <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf\\r\\n(bp, \"%s\", x->psk_identity_hint ? x->psk_identity_hint : \"None\") <= 0)\\r\\ngoto err;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nif (BIO_puts(bp, \"\\n SRP username: \") <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"%s\", x->srp_username ? x->srp_username : \"None\") <= 0)\\r\\ngoto err;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (x->tlsext_tick_lifetime_hint) {\\r\\nif (BIO_printf(bp,\\r\\n\"\\n TLS session ticket lifetime hint: %ld (seconds)\",\\r\\nx->tlsext_tick_lifetime_hint) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (x->tlsext_tick) {\\r\\nif (BIO_puts(bp, \"\\n TLS session ticket:\\n\") <= 0)\\r\\ngoto err;\\r\\nif (BIO_dump_indent(bp, (char *)x->tlsext_tick, x->tlsext_ticklen, 4)\\r\\n<= 0)\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nif (x->compress_meth != 0) {\\r\\nSSL_COMP *comp = NULL;\\r\\nssl_cipher_get_evp(x, NULL, NULL, NULL, NULL, &comp);\\r\\nif (comp == NULL) {\\r\\nif (BIO_printf(bp, \"\\n Compression: %d\", x->compress_meth) <=\\r\\n0)\\r\\ngoto err;\\r\\n} else {\\r\\nif (BIO_printf\\r\\n(bp, \"\\n Compression: %d (%s)\", comp->id,\\r\\ncomp->method->name) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif (x->time != 0L) {\\r\\nif (BIO_printf(bp, \"\\n Start Time: %ld\", x->time) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (x->timeout != 0L) {\\r\\nif (BIO_printf(bp, \"\\n Timeout : %ld (sec)\", x->timeout) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \" Verify return code: \") <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"%ld (%s)\\n\", x->verify_result,\\r\\nX509_verify_cert_error_string(x->verify_result)) <= 0)\\r\\ngoto err;\\r\\nreturn (1);\\r\\nerr:\\r\\nreturn (0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_sqr_c", "target": 0, "func": "int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nint max, al;\\r\\nint ret = 0;\\r\\nBIGNUM *tmp, *rr;\\r\\n#ifdef BN_COUNT\\r\\nfprintf(stderr, \"BN_sqr %d * %d\\n\", a->top, a->top);\\r\\n#endif\\r\\nbn_check_top(a);\\r\\nal = a->top;\\r\\nif (al <= 0) {\\r\\nr->top = 0;\\r\\nr->neg = 0;\\r\\nreturn 1;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nrr = (a != r) ? r : BN_CTX_get(ctx);\\r\\ntmp = BN_CTX_get(ctx);\\r\\nif (!rr || !tmp)\\r\\ngoto err;\\r\\nmax = 2 * al;\\r\\nif (bn_wexpand(rr, max) == NULL)\\r\\ngoto err;\\r\\nif (al == 4) {\\r\\n#ifndef BN_SQR_COMBA\\r\\nBN_ULONG t[8];\\r\\nbn_sqr_normal(rr->d, a->d, 4, t);\\r\\n#else\\r\\nbn_sqr_comba4(rr->d, a->d);\\r\\n#endif\\r\\n} else if (al == 8) {\\r\\n#ifndef BN_SQR_COMBA\\r\\nBN_ULONG t[16];\\r\\nbn_sqr_normal(rr->d, a->d, 8, t);\\r\\n#else\\r\\nbn_sqr_comba8(rr->d, a->d);\\r\\n#endif\\r\\n} else {\\r\\n#if defined(BN_RECURSION)\\r\\nif (al < BN_SQR_RECURSIVE_SIZE_NORMAL) {\\r\\nBN_ULONG t[BN_SQR_RECURSIVE_SIZE_NORMAL * 2];\\r\\nbn_sqr_normal(rr->d, a->d, al, t);\\r\\n} else {\\r\\nint j, k;\\r\\nj = BN_num_bits_word((BN_ULONG)al);\\r\\nj = 1 << (j - 1);\\r\\nk = j + j;\\r\\nif (al == j) {\\r\\nif (bn_wexpand(tmp, k * 2) == NULL)\\r\\ngoto err;\\r\\nbn_sqr_recursive(rr->d, a->d, al, tmp->d);\\r\\n} else {\\r\\nif (bn_wexpand(tmp, max) == NULL)\\r\\ngoto err;\\r\\nbn_sqr_normal(rr->d, a->d, al, tmp->d);\\r\\n}\\r\\n}\\r\\n#else\\r\\nif (bn_wexpand(tmp, max) == NULL)\\r\\ngoto err;\\r\\nbn_sqr_normal(rr->d, a->d, al, tmp->d);\\r\\n#endif\\r\\n}\\r\\nrr->neg = 0;\\r\\nif (a->d[al - 1] == (a->d[al - 1] & BN_MASK2l))\\r\\nrr->top = max - 1;\\r\\nelse\\r\\nrr->top = max;\\r\\nif (rr != r)\\r\\nBN_copy(r, rr);\\r\\nret = 1;\\r\\nerr:\\r\\nbn_check_top(rr);\\r\\nbn_check_top(tmp);\\r\\nBN_CTX_end(ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nvoid bn_sqr_normal(BN_ULONG *r, const BN_ULONG *a, int n, BN_ULONG *tmp)\\r\\n{\\r\\nint i, j, max;\\r\\nconst BN_ULONG *ap;\\r\\nBN_ULONG *rp;\\r\\nmax = n * 2;\\r\\nap = a;\\r\\nrp = r;\\r\\nrp[0] = rp[max - 1] = 0;\\r\\nrp++;\\r\\nj = n;\\r\\nif (--j > 0) {\\r\\nap++;\\r\\nrp[j] = bn_mul_words(rp, ap, j, ap[-1]);\\r\\nrp += 2;\\r\\n}\\r\\nfor (i = n - 2; i > 0; i--) {\\r\\nj--;\\r\\nap++;\\r\\nrp[j] = bn_mul_add_words(rp, ap, j, ap[-1]);\\r\\nrp += 2;\\r\\n}\\r\\nbn_add_words(r, r, r, max);\\r\\nbn_sqr_words(tmp, a, n);\\r\\nbn_add_words(r, r, tmp, max);\\r\\n}\\r\\nvoid bn_sqr_recursive(BN_ULONG *r, const BN_ULONG *a, int n2, BN_ULONG *t)\\r\\n{\\r\\nint n = n2 / 2;\\r\\nint zero, c1;\\r\\nBN_ULONG ln, lo, *p;\\r\\n# ifdef BN_COUNT\\r\\nfprintf(stderr, \" bn_sqr_recursive %d * %d\\n\", n2, n2);\\r\\n# endif\\r\\nif (n2 == 4) {\\r\\n# ifndef BN_SQR_COMBA\\r\\nbn_sqr_normal(r, a, 4, t);\\r\\n# else\\r\\nbn_sqr_comba4(r, a);\\r\\n# endif\\r\\nreturn;\\r\\n} else if (n2 == 8) {\\r\\n# ifndef BN_SQR_COMBA\\r\\nbn_sqr_normal(r, a, 8, t);\\r\\n# else\\r\\nbn_sqr_comba8(r, a);\\r\\n# endif\\r\\nreturn;\\r\\n}\\r\\nif (n2 < BN_SQR_RECURSIVE_SIZE_NORMAL) {\\r\\nbn_sqr_normal(r, a, n2, t);\\r\\nreturn;\\r\\n}\\r\\nc1 = bn_cmp_words(a, &(a[n]), n);\\r\\nzero = 0;\\r\\nif (c1 > 0)\\r\\nbn_sub_words(t, a, &(a[n]), n);\\r\\nelse if (c1 < 0)\\r\\nbn_sub_words(t, &(a[n]), a, n);\\r\\nelse\\r\\nzero = 1;\\r\\np = &(t[n2 * 2]);\\r\\nif (!zero)\\r\\nbn_sqr_recursive(&(t[n2]), t, n, p);\\r\\nelse\\r\\nmemset(&(t[n2]), 0, n2 * sizeof(BN_ULONG));\\r\\nbn_sqr_recursive(r, a, n, p);\\r\\nbn_sqr_recursive(&(r[n2]), &(a[n]), n, p);\\r\\nc1 = (int)(bn_add_words(t, r, &(r[n2]), n2));\\r\\nc1 -= (int)(bn_sub_words(&(t[n2]), t, &(t[n2]), n2));\\r\\nc1 += (int)(bn_add_words(&(r[n]), &(r[n]), &(t[n2]), n2));\\r\\nif (c1) {\\r\\np = &(r[n + n2]);\\r\\nlo = *p;\\r\\nln = (lo + c1) & BN_MASK2;\\r\\n*p = ln;\\r\\nif (ln < (BN_ULONG)c1) {\\r\\ndo {\\r\\np++;\\r\\nlo = *p;\\r\\nln = (lo + 1) & BN_MASK2;\\r\\n*p = ln;\\r\\n} while (ln == 0);\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_errstr_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint i, ret = 0;\\r\\nchar buf[256];\\r\\nunsigned long l;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nSSL_load_error_strings();\\r\\nif ((argc > 1) && (strcmp(argv[1], \"-stats\") == 0)) {\\r\\nBIO *out = NULL;\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((out != NULL) && BIO_set_fp(out, stdout, BIO_NOCLOSE)) {\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\nlh_ERR_STRING_DATA_node_stats_bio(ERR_get_string_table(), out);\\r\\nlh_ERR_STRING_DATA_stats_bio(ERR_get_string_table(), out);\\r\\nlh_ERR_STRING_DATA_node_usage_stats_bio(ERR_get_string_table(),\\r\\nout);\\r\\n}\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nfor (i = 1; i < argc; i++) {\\r\\nif (sscanf(argv[i], \"%lx\", &l)) {\\r\\nERR_error_string_n(l, buf, sizeof buf);\\r\\nprintf(\"%s\\n\", buf);\\r\\n} else {\\r\\nprintf(\"%s: bad error code\\n\", argv[i]);\\r\\nprintf(\"usage: errstr [-stats] <errno> ...\\n\");\\r\\nret++;\\r\\n}\\r\\n}\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_d2i_pr_c", "target": 0, "func": "EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nEVP_PKEY *ret;\\r\\nif ((a == NULL) || (*a == NULL)) {\\r\\nif ((ret = EVP_PKEY_new()) == NULL) {\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY, ERR_R_EVP_LIB);\\r\\nreturn (NULL);\\r\\n}\\r\\n} else {\\r\\nret = *a;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (ret->engine) {\\r\\nENGINE_finish(ret->engine);\\r\\nret->engine = NULL;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (!EVP_PKEY_set_type(ret, type)) {\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (!ret->ameth->old_priv_decode ||\\r\\n!ret->ameth->old_priv_decode(ret, pp, length)) {\\r\\nif (ret->ameth->priv_decode) {\\r\\nPKCS8_PRIV_KEY_INFO *p8 = NULL;\\r\\np8 = d2i_PKCS8_PRIV_KEY_INFO(NULL, pp, length);\\r\\nif (!p8)\\r\\ngoto err;\\r\\nEVP_PKEY_free(ret);\\r\\nret = EVP_PKCS82PKEY(p8);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\n} else {\\r\\nASN1err(ASN1_F_D2I_PRIVATEKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (a != NULL)\\r\\n(*a) = ret;\\r\\nreturn (ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nEVP_PKEY_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nEVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nSTACK_OF(ASN1_TYPE) *inkey;\\r\\nconst unsigned char *p;\\r\\nint keytype;\\r\\np = *pp;\\r\\ninkey = d2i_ASN1_SEQUENCE_ANY(NULL, &p, length);\\r\\nif (sk_ASN1_TYPE_num(inkey) == 6)\\r\\nkeytype = EVP_PKEY_DSA;\\r\\nelse if (sk_ASN1_TYPE_num(inkey) == 4)\\r\\nkeytype = EVP_PKEY_EC;\\r\\nelse if (sk_ASN1_TYPE_num(inkey) == 3) {\\r\\nPKCS8_PRIV_KEY_INFO *p8 = d2i_PKCS8_PRIV_KEY_INFO(NULL, pp, length);\\r\\nEVP_PKEY *ret;\\r\\nsk_ASN1_TYPE_pop_free(inkey, ASN1_TYPE_free);\\r\\nif (!p8) {\\r\\nASN1err(ASN1_F_D2I_AUTOPRIVATEKEY,\\r\\nASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\nret = EVP_PKCS82PKEY(p8);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8);\\r\\nif (a) {\\r\\n*a = ret;\\r\\n}\\r\\nreturn ret;\\r\\n} else\\r\\nkeytype = EVP_PKEY_RSA;\\r\\nsk_ASN1_TYPE_pop_free(inkey, ASN1_TYPE_free);\\r\\nreturn d2i_PrivateKey(keytype, a, pp, length);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pk7_smime_c", "target": 0, "func": "int PKCS7_final(PKCS7 *p7, BIO *data, int flags)\\r\\n{\\r\\nBIO *p7bio;\\r\\nint ret = 0;\\r\\nif (!(p7bio = PKCS7_dataInit(p7, NULL))) {\\r\\nPKCS7err(PKCS7_F_PKCS7_FINAL, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nSMIME_crlf_copy(data, p7bio, flags);\\r\\n(void)BIO_flush(p7bio);\\r\\nif (!PKCS7_dataFinal(p7, p7bio)) {\\r\\nPKCS7err(PKCS7_F_PKCS7_FINAL, PKCS7_R_PKCS7_DATASIGN);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nBIO_free_all(p7bio);\\r\\nreturn ret;\\r\\n}\\r\\nPKCS7_SIGNER_INFO *PKCS7_sign_add_signer(PKCS7 *p7, X509 *signcert,\\r\\nEVP_PKEY *pkey, const EVP_MD *md,\\r\\nint flags)\\r\\n{\\r\\nPKCS7_SIGNER_INFO *si = NULL;\\r\\nSTACK_OF(X509_ALGOR) *smcap = NULL;\\r\\nif (!X509_check_private_key(signcert, pkey)) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGN_ADD_SIGNER,\\r\\nPKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(si = PKCS7_add_signature(p7, signcert, pkey, md))) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGN_ADD_SIGNER,\\r\\nPKCS7_R_PKCS7_ADD_SIGNATURE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(flags & PKCS7_NOCERTS)) {\\r\\nif (!PKCS7_add_certificate(p7, signcert))\\r\\ngoto err;\\r\\n}\\r\\nif (!(flags & PKCS7_NOATTR)) {\\r\\nif (!PKCS7_add_attrib_content_type(si, NULL))\\r\\ngoto err;\\r\\nif (!(flags & PKCS7_NOSMIMECAP)) {\\r\\nif (!(smcap = sk_X509_ALGOR_new_null())) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGN_ADD_SIGNER, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!add_cipher_smcap(smcap, NID_aes_256_cbc, -1)\\r\\n|| !add_digest_smcap(smcap, NID_id_GostR3411_94, -1)\\r\\n|| !add_cipher_smcap(smcap, NID_id_Gost28147_89, -1)\\r\\n|| !add_cipher_smcap(smcap, NID_aes_192_cbc, -1)\\r\\n|| !add_cipher_smcap(smcap, NID_aes_128_cbc, -1)\\r\\n|| !add_cipher_smcap(smcap, NID_des_ede3_cbc, -1)\\r\\n|| !add_cipher_smcap(smcap, NID_rc2_cbc, 128)\\r\\n|| !add_cipher_smcap(smcap, NID_rc2_cbc, 64)\\r\\n|| !add_cipher_smcap(smcap, NID_des_cbc, -1)\\r\\n|| !add_cipher_smcap(smcap, NID_rc2_cbc, 40)\\r\\n|| !PKCS7_add_attrib_smimecap(si, smcap))\\r\\ngoto err;\\r\\nsk_X509_ALGOR_pop_free(smcap, X509_ALGOR_free);\\r\\nsmcap = NULL;\\r\\n}\\r\\nif (flags & PKCS7_REUSE_DIGEST) {\\r\\nif (!pkcs7_copy_existing_digest(p7, si))\\r\\ngoto err;\\r\\nif (!(flags & PKCS7_PARTIAL) && !PKCS7_SIGNER_INFO_sign(si))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nreturn si;\\r\\nerr:\\r\\nif (smcap)\\r\\nsk_X509_ALGOR_pop_free(smcap, X509_ALGOR_free);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int pkcs7_copy_existing_digest(PKCS7 *p7, PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *sinfos;\\r\\nPKCS7_SIGNER_INFO *sitmp;\\r\\nASN1_OCTET_STRING *osdig = NULL;\\r\\nsinfos = PKCS7_get_signer_info(p7);\\r\\nfor (i = 0; i < sk_PKCS7_SIGNER_INFO_num(sinfos); i++) {\\r\\nsitmp = sk_PKCS7_SIGNER_INFO_value(sinfos, i);\\r\\nif (si == sitmp)\\r\\nbreak;\\r\\nif (sk_X509_ATTRIBUTE_num(sitmp->auth_attr) <= 0)\\r\\ncontinue;\\r\\nif (!OBJ_cmp(si->digest_alg->algorithm, sitmp->digest_alg->algorithm)) {\\r\\nosdig = PKCS7_digest_from_attributes(sitmp->auth_attr);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (osdig)\\r\\nreturn PKCS7_add1_attrib_digest(si, osdig->data, osdig->length);\\r\\nPKCS7err(PKCS7_F_PKCS7_COPY_EXISTING_DIGEST,\\r\\nPKCS7_R_NO_MATCHING_DIGEST_TYPE_FOUND);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_ctrl_c", "target": 0, "func": "static int int_ctrl_cmd_is_null(const ENGINE_CMD_DEFN *defn)\\r\\n{\\r\\nif ((defn->cmd_num == 0) || (defn->cmd_name == NULL))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int int_ctrl_cmd_by_name(const ENGINE_CMD_DEFN *defn, const char *s)\\r\\n{\\r\\nint idx = 0;\\r\\nwhile (!int_ctrl_cmd_is_null(defn) && (strcmp(defn->cmd_name, s) != 0)) {\\r\\nidx++;\\r\\ndefn++;\\r\\n}\\r\\nif (int_ctrl_cmd_is_null(defn))\\r\\nreturn -1;\\r\\nreturn idx;\\r\\n}\\r\\nstatic int int_ctrl_cmd_by_num(const ENGINE_CMD_DEFN *defn, unsigned int num)\\r\\n{\\r\\nint idx = 0;\\r\\nwhile (!int_ctrl_cmd_is_null(defn) && (defn->cmd_num < num)) {\\r\\nidx++;\\r\\ndefn++;\\r\\n}\\r\\nif (defn->cmd_num == num)\\r\\nreturn idx;\\r\\nreturn -1;\\r\\n}\\r\\nstatic int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,\\r\\nvoid (*f) (void))\\r\\n{\\r\\nint idx;\\r\\nchar *s = (char *)p;\\r\\nif (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\\r\\nif ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\\r\\nreturn 0;\\r\\nreturn e->cmd_defns->cmd_num;\\r\\n}\\r\\nif ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\\r\\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\\r\\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\\r\\nif (s == NULL) {\\r\\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\\r\\nif ((e->cmd_defns == NULL)\\r\\n|| ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\\r\\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);\\r\\nreturn -1;\\r\\n}\\r\\nreturn e->cmd_defns[idx].cmd_num;\\r\\n}\\r\\nif ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,\\r\\n(unsigned int)\\r\\ni)) < 0)) {\\r\\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);\\r\\nreturn -1;\\r\\n}\\r\\nswitch (cmd) {\\r\\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\\r\\nidx++;\\r\\nif (int_ctrl_cmd_is_null(e->cmd_defns + idx))\\r\\nreturn 0;\\r\\nelse\\r\\nreturn e->cmd_defns[idx].cmd_num;\\r\\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\\r\\nreturn strlen(e->cmd_defns[idx].cmd_name);\\r\\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\\r\\nreturn BIO_snprintf(s, strlen(e->cmd_defns[idx].cmd_name) + 1,\\r\\n\"%s\", e->cmd_defns[idx].cmd_name);\\r\\ncase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\\r\\nif (e->cmd_defns[idx].cmd_desc)\\r\\nreturn strlen(e->cmd_defns[idx].cmd_desc);\\r\\nreturn strlen(int_no_description);\\r\\ncase ENGINE_CTRL_GET_DESC_FROM_CMD:\\r\\nif (e->cmd_defns[idx].cmd_desc)\\r\\nreturn BIO_snprintf(s,\\r\\nstrlen(e->cmd_defns[idx].cmd_desc) + 1,\\r\\n\"%s\", e->cmd_defns[idx].cmd_desc);\\r\\nreturn BIO_snprintf(s, strlen(int_no_description) + 1, \"%s\",\\r\\nint_no_description);\\r\\ncase ENGINE_CTRL_GET_CMD_FLAGS:\\r\\nreturn e->cmd_defns[idx].cmd_flags;\\r\\n}\\r\\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn -1;\\r\\n}\\r\\nint ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))\\r\\n{\\r\\nint ctrl_exists, ref_exists;\\r\\nif (e == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ENGINE);\\r\\nref_exists = ((e->struct_ref > 0) ? 1 : 0);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);\\r\\nctrl_exists = ((e->ctrl == NULL) ? 0 : 1);\\r\\nif (!ref_exists) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_REFERENCE);\\r\\nreturn 0;\\r\\n}\\r\\nswitch (cmd) {\\r\\ncase ENGINE_CTRL_HAS_CTRL_FUNCTION:\\r\\nreturn ctrl_exists;\\r\\ncase ENGINE_CTRL_GET_FIRST_CMD_TYPE:\\r\\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\\r\\ncase ENGINE_CTRL_GET_CMD_FROM_NAME:\\r\\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\\r\\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\\r\\ncase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\\r\\ncase ENGINE_CTRL_GET_DESC_FROM_CMD:\\r\\ncase ENGINE_CTRL_GET_CMD_FLAGS:\\r\\nif (ctrl_exists && !(e->flags & ENGINE_FLAGS_MANUAL_CMD_CTRL))\\r\\nreturn int_ctrl_helper(e, cmd, i, p, f);\\r\\nif (!ctrl_exists) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION);\\r\\nreturn -1;\\r\\n}\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nif (!ctrl_exists) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION);\\r\\nreturn 0;\\r\\n}\\r\\nreturn e->ctrl(e, cmd, i, p, f);\\r\\n}\\r\\nint ENGINE_cmd_is_executable(ENGINE *e, int cmd)\\r\\n{\\r\\nint flags;\\r\\nif ((flags =\\r\\nENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, cmd, NULL, NULL)) < 0) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CMD_IS_EXECUTABLE,\\r\\nENGINE_R_INVALID_CMD_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(flags & ENGINE_CMD_FLAG_NO_INPUT) &&\\r\\n!(flags & ENGINE_CMD_FLAG_NUMERIC) &&\\r\\n!(flags & ENGINE_CMD_FLAG_STRING))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name,\\r\\nlong i, void *p, void (*f) (void), int cmd_optional)\\r\\n{\\r\\nint num;\\r\\nif ((e == NULL) || (cmd_name == NULL)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif ((e->ctrl == NULL) || ((num = ENGINE_ctrl(e,\\r\\nENGINE_CTRL_GET_CMD_FROM_NAME,\\r\\n0, (void *)cmd_name,\\r\\nNULL)) <= 0)) {\\r\\nif (cmd_optional) {\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD, ENGINE_R_INVALID_CMD_NAME);\\r\\nreturn 0;\\r\\n}\\r\\nif (ENGINE_ctrl(e, num, i, p, f) > 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nint ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg,\\r\\nint cmd_optional)\\r\\n{\\r\\nint num, flags;\\r\\nlong l;\\r\\nchar *ptr;\\r\\nif ((e == NULL) || (cmd_name == NULL)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif ((e->ctrl == NULL) || ((num = ENGINE_ctrl(e,\\r\\nENGINE_CTRL_GET_CMD_FROM_NAME,\\r\\n0, (void *)cmd_name,\\r\\nNULL)) <= 0)) {\\r\\nif (cmd_optional) {\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INVALID_CMD_NAME);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ENGINE_cmd_is_executable(e, num)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_CMD_NOT_EXECUTABLE);\\r\\nreturn 0;\\r\\n}\\r\\nif ((flags =\\r\\nENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num, NULL, NULL)) < 0) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (flags & ENGINE_CMD_FLAG_NO_INPUT) {\\r\\nif (arg != NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_COMMAND_TAKES_NO_INPUT);\\r\\nreturn 0;\\r\\n}\\r\\nif (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) > 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nif (arg == NULL) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_COMMAND_TAKES_INPUT);\\r\\nreturn 0;\\r\\n}\\r\\nif (flags & ENGINE_CMD_FLAG_STRING) {\\r\\nif (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) > 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nif (!(flags & ENGINE_CMD_FLAG_NUMERIC)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_INTERNAL_LIST_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nl = strtol(arg, &ptr, 10);\\r\\nif ((arg == ptr) || (*ptr != '\\0')) {\\r\\nENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING,\\r\\nENGINE_R_ARGUMENT_IS_NOT_A_NUMBER);\\r\\nreturn 0;\\r\\n}\\r\\nif (ENGINE_ctrl(e, num, l, NULL, NULL) > 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ameth_lib_c", "target": 0, "func": "void main()\\r\\n{\\r\\nint i;\\r\\nfor (i = 0;\\r\\ni < sizeof(standard_methods) / sizeof(EVP_PKEY_ASN1_METHOD *); i++)\\r\\nfprintf(stderr, \"Number %d id=%d (%s)\\n\", i,\\r\\nstandard_methods[i]->pkey_id,\\r\\nOBJ_nid2sn(standard_methods[i]->pkey_id));\\r\\n}\\r\\nstatic int ameth_cmp(const EVP_PKEY_ASN1_METHOD *const *a,\\r\\nconst EVP_PKEY_ASN1_METHOD *const *b)\\r\\n{\\r\\nreturn ((*a)->pkey_id - (*b)->pkey_id);\\r\\n}\\r\\nint EVP_PKEY_asn1_get_count(void)\\r\\n{\\r\\nint num = sizeof(standard_methods) / sizeof(EVP_PKEY_ASN1_METHOD *);\\r\\nif (app_methods)\\r\\nnum += sk_EVP_PKEY_ASN1_METHOD_num(app_methods);\\r\\nreturn num;\\r\\n}\\r\\nconst EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx)\\r\\n{\\r\\nint num = sizeof(standard_methods) / sizeof(EVP_PKEY_ASN1_METHOD *);\\r\\nif (idx < 0)\\r\\nreturn NULL;\\r\\nif (idx < num)\\r\\nreturn standard_methods[idx];\\r\\nidx -= num;\\r\\nreturn sk_EVP_PKEY_ASN1_METHOD_value(app_methods, idx);\\r\\n}\\r\\nstatic const EVP_PKEY_ASN1_METHOD *pkey_asn1_find(int type)\\r\\n{\\r\\nEVP_PKEY_ASN1_METHOD tmp;\\r\\nconst EVP_PKEY_ASN1_METHOD *t = &tmp, **ret;\\r\\ntmp.pkey_id = type;\\r\\nif (app_methods) {\\r\\nint idx;\\r\\nidx = sk_EVP_PKEY_ASN1_METHOD_find(app_methods, &tmp);\\r\\nif (idx >= 0)\\r\\nreturn sk_EVP_PKEY_ASN1_METHOD_value(app_methods, idx);\\r\\n}\\r\\nret = OBJ_bsearch_ameth(&t, standard_methods, sizeof(standard_methods)\\r\\n/ sizeof(EVP_PKEY_ASN1_METHOD *));\\r\\nif (!ret || !*ret)\\r\\nreturn NULL;\\r\\nreturn *ret;\\r\\n}\\r\\nconst EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type)\\r\\n{\\r\\nconst EVP_PKEY_ASN1_METHOD *t;\\r\\nfor (;;) {\\r\\nt = pkey_asn1_find(type);\\r\\nif (!t || !(t->pkey_flags & ASN1_PKEY_ALIAS))\\r\\nbreak;\\r\\ntype = t->pkey_base_id;\\r\\n}\\r\\nif (pe) {\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e;\\r\\ne = ENGINE_get_pkey_asn1_meth_engine(type);\\r\\nif (e) {\\r\\n*pe = e;\\r\\nreturn ENGINE_get_pkey_asn1_meth(e, type);\\r\\n}\\r\\n#endif\\r\\n*pe = NULL;\\r\\n}\\r\\nreturn t;\\r\\n}\\r\\nconst EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe,\\r\\nconst char *str, int len)\\r\\n{\\r\\nint i;\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nif (len == -1)\\r\\nlen = strlen(str);\\r\\nif (pe) {\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE *e;\\r\\nameth = ENGINE_pkey_asn1_find_str(&e, str, len);\\r\\nif (ameth) {\\r\\nif (!ENGINE_init(e))\\r\\nameth = NULL;\\r\\nENGINE_free(e);\\r\\n*pe = e;\\r\\nreturn ameth;\\r\\n}\\r\\n#endif\\r\\n*pe = NULL;\\r\\n}\\r\\nfor (i = 0; i < EVP_PKEY_asn1_get_count(); i++) {\\r\\nameth = EVP_PKEY_asn1_get0(i);\\r\\nif (ameth->pkey_flags & ASN1_PKEY_ALIAS)\\r\\ncontinue;\\r\\nif (((int)strlen(ameth->pem_str) == len) &&\\r\\n!strncasecmp(ameth->pem_str, str, len))\\r\\nreturn ameth;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nint EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth)\\r\\n{\\r\\nif (app_methods == NULL) {\\r\\napp_methods = sk_EVP_PKEY_ASN1_METHOD_new(ameth_cmp);\\r\\nif (!app_methods)\\r\\nreturn 0;\\r\\n}\\r\\nif (!sk_EVP_PKEY_ASN1_METHOD_push(app_methods, ameth))\\r\\nreturn 0;\\r\\nsk_EVP_PKEY_ASN1_METHOD_sort(app_methods);\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_PKEY_asn1_add_alias(int to, int from)\\r\\n{\\r\\nEVP_PKEY_ASN1_METHOD *ameth;\\r\\nameth = EVP_PKEY_asn1_new(from, ASN1_PKEY_ALIAS, NULL, NULL);\\r\\nif (!ameth)\\r\\nreturn 0;\\r\\nameth->pkey_base_id = to;\\r\\nif (!EVP_PKEY_asn1_add0(ameth)) {\\r\\nEVP_PKEY_asn1_free(ameth);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint EVP_PKEY_asn1_get0_info(int *ppkey_id, int *ppkey_base_id,\\r\\nint *ppkey_flags, const char **pinfo,\\r\\nconst char **ppem_str,\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth)\\r\\n{\\r\\nif (!ameth)\\r\\nreturn 0;\\r\\nif (ppkey_id)\\r\\n*ppkey_id = ameth->pkey_id;\\r\\nif (ppkey_base_id)\\r\\n*ppkey_base_id = ameth->pkey_base_id;\\r\\nif (ppkey_flags)\\r\\n*ppkey_flags = ameth->pkey_flags;\\r\\nif (pinfo)\\r\\n*pinfo = ameth->info;\\r\\nif (ppem_str)\\r\\n*ppem_str = ameth->pem_str;\\r\\nreturn 1;\\r\\n}\\r\\nconst EVP_PKEY_ASN1_METHOD *EVP_PKEY_get0_asn1(EVP_PKEY *pkey)\\r\\n{\\r\\nreturn pkey->ameth;\\r\\n}\\r\\nEVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_new(int id, int flags,\\r\\nconst char *pem_str, const char *info)\\r\\n{\\r\\nEVP_PKEY_ASN1_METHOD *ameth;\\r\\nameth = OPENSSL_malloc(sizeof(EVP_PKEY_ASN1_METHOD));\\r\\nif (!ameth)\\r\\nreturn NULL;\\r\\nmemset(ameth, 0, sizeof(EVP_PKEY_ASN1_METHOD));\\r\\nameth->pkey_id = id;\\r\\nameth->pkey_base_id = id;\\r\\nameth->pkey_flags = flags | ASN1_PKEY_DYNAMIC;\\r\\nif (info) {\\r\\nameth->info = BUF_strdup(info);\\r\\nif (!ameth->info)\\r\\ngoto err;\\r\\n} else\\r\\nameth->info = NULL;\\r\\nif (pem_str) {\\r\\nameth->pem_str = BUF_strdup(pem_str);\\r\\nif (!ameth->pem_str)\\r\\ngoto err;\\r\\n} else\\r\\nameth->pem_str = NULL;\\r\\nameth->pub_decode = 0;\\r\\nameth->pub_encode = 0;\\r\\nameth->pub_cmp = 0;\\r\\nameth->pub_print = 0;\\r\\nameth->priv_decode = 0;\\r\\nameth->priv_encode = 0;\\r\\nameth->priv_print = 0;\\r\\nameth->old_priv_encode = 0;\\r\\nameth->old_priv_decode = 0;\\r\\nameth->item_verify = 0;\\r\\nameth->item_sign = 0;\\r\\nameth->pkey_size = 0;\\r\\nameth->pkey_bits = 0;\\r\\nameth->param_decode = 0;\\r\\nameth->param_encode = 0;\\r\\nameth->param_missing = 0;\\r\\nameth->param_copy = 0;\\r\\nameth->param_cmp = 0;\\r\\nameth->param_print = 0;\\r\\nameth->pkey_free = 0;\\r\\nameth->pkey_ctrl = 0;\\r\\nreturn ameth;\\r\\nerr:\\r\\nEVP_PKEY_asn1_free(ameth);\\r\\nreturn NULL;\\r\\n}\\r\\nvoid EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst,\\r\\nconst EVP_PKEY_ASN1_METHOD *src)\\r\\n{\\r\\ndst->pub_decode = src->pub_decode;\\r\\ndst->pub_encode = src->pub_encode;\\r\\ndst->pub_cmp = src->pub_cmp;\\r\\ndst->pub_print = src->pub_print;\\r\\ndst->priv_decode = src->priv_decode;\\r\\ndst->priv_encode = src->priv_encode;\\r\\ndst->priv_print = src->priv_print;\\r\\ndst->old_priv_encode = src->old_priv_encode;\\r\\ndst->old_priv_decode = src->old_priv_decode;\\r\\ndst->pkey_size = src->pkey_size;\\r\\ndst->pkey_bits = src->pkey_bits;\\r\\ndst->param_decode = src->param_decode;\\r\\ndst->param_encode = src->param_encode;\\r\\ndst->param_missing = src->param_missing;\\r\\ndst->param_copy = src->param_copy;\\r\\ndst->param_cmp = src->param_cmp;\\r\\ndst->param_print = src->param_print;\\r\\ndst->pkey_free = src->pkey_free;\\r\\ndst->pkey_ctrl = src->pkey_ctrl;\\r\\ndst->item_sign = src->item_sign;\\r\\ndst->item_verify = src->item_verify;\\r\\n}\\r\\nvoid EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth)\\r\\n{\\r\\nif (ameth && (ameth->pkey_flags & ASN1_PKEY_DYNAMIC)) {\\r\\nif (ameth->pem_str)\\r\\nOPENSSL_free(ameth->pem_str);\\r\\nif (ameth->info)\\r\\nOPENSSL_free(ameth->info);\\r\\nOPENSSL_free(ameth);\\r\\n}\\r\\n}\\r\\nvoid EVP_PKEY_asn1_set_public(EVP_PKEY_ASN1_METHOD *ameth,\\r\\nint (*pub_decode) (EVP_PKEY *pk,\\r\\nX509_PUBKEY *pub),\\r\\nint (*pub_encode) (X509_PUBKEY *pub,\\r\\nconst EVP_PKEY *pk),\\r\\nint (*pub_cmp) (const EVP_PKEY *a,\\r\\nconst EVP_PKEY *b),\\r\\nint (*pub_print) (BIO *out,\\r\\nconst EVP_PKEY *pkey,\\r\\nint indent, ASN1_PCTX *pctx),\\r\\nint (*pkey_size) (const EVP_PKEY *pk),\\r\\nint (*pkey_bits) (const EVP_PKEY *pk))\\r\\n{\\r\\nameth->pub_decode = pub_decode;\\r\\nameth->pub_encode = pub_encode;\\r\\nameth->pub_cmp = pub_cmp;\\r\\nameth->pub_print = pub_print;\\r\\nameth->pkey_size = pkey_size;\\r\\nameth->pkey_bits = pkey_bits;\\r\\n}\\r\\nvoid EVP_PKEY_asn1_set_private(EVP_PKEY_ASN1_METHOD *ameth,\\r\\nint (*priv_decode) (EVP_PKEY *pk,\\r\\nPKCS8_PRIV_KEY_INFO\\r\\n*p8inf),\\r\\nint (*priv_encode) (PKCS8_PRIV_KEY_INFO *p8,\\r\\nconst EVP_PKEY *pk),\\r\\nint (*priv_print) (BIO *out,\\r\\nconst EVP_PKEY *pkey,\\r\\nint indent,\\r\\nASN1_PCTX *pctx))\\r\\n{\\r\\nameth->priv_decode = priv_decode;\\r\\nameth->priv_encode = priv_encode;\\r\\nameth->priv_print = priv_print;\\r\\n}\\r\\nvoid EVP_PKEY_asn1_set_param(EVP_PKEY_ASN1_METHOD *ameth,\\r\\nint (*param_decode) (EVP_PKEY *pkey,\\r\\nconst unsigned char **pder,\\r\\nint derlen),\\r\\nint (*param_encode) (const EVP_PKEY *pkey,\\r\\nunsigned char **pder),\\r\\nint (*param_missing) (const EVP_PKEY *pk),\\r\\nint (*param_copy) (EVP_PKEY *to,\\r\\nconst EVP_PKEY *from),\\r\\nint (*param_cmp) (const EVP_PKEY *a,\\r\\nconst EVP_PKEY *b),\\r\\nint (*param_print) (BIO *out,\\r\\nconst EVP_PKEY *pkey,\\r\\nint indent, ASN1_PCTX *pctx))\\r\\n{\\r\\nameth->param_decode = param_decode;\\r\\nameth->param_encode = param_encode;\\r\\nameth->param_missing = param_missing;\\r\\nameth->param_copy = param_copy;\\r\\nameth->param_cmp = param_cmp;\\r\\nameth->param_print = param_print;\\r\\n}\\r\\nvoid EVP_PKEY_asn1_set_free(EVP_PKEY_ASN1_METHOD *ameth,\\r\\nvoid (*pkey_free) (EVP_PKEY *pkey))\\r\\n{\\r\\nameth->pkey_free = pkey_free;\\r\\n}\\r\\nvoid EVP_PKEY_asn1_set_ctrl(EVP_PKEY_ASN1_METHOD *ameth,\\r\\nint (*pkey_ctrl) (EVP_PKEY *pkey, int op,\\r\\nlong arg1, void *arg2))\\r\\n{\\r\\nameth->pkey_ctrl = pkey_ctrl;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rand_vms_c", "target": 0, "func": "int RAND_poll(void)\\r\\n{\\r\\nlong pid, iosb[2];\\r\\nint status = 0;\\r\\nstruct {\\r\\nshort length, code;\\r\\nlong *buffer;\\r\\nint *retlen;\\r\\n} item[32], *pitem;\\r\\nunsigned char data_buffer[256];\\r\\nshort total_length = 0;\\r\\nstruct items_data_st *pitems_data;\\r\\npitems_data = items_data;\\r\\npitem = item;\\r\\nwhile (pitems_data->length && (total_length + pitems_data->length <= 256)) {\\r\\npitem->length = pitems_data->length;\\r\\npitem->code = pitems_data->code;\\r\\npitem->buffer = (long *)&data_buffer[total_length];\\r\\npitem->retlen = 0;\\r\\ntotal_length += pitems_data->length;\\r\\npitems_data++;\\r\\npitem ++;\\r\\n}\\r\\npitem->length = pitem->code = 0;\\r\\npid = -1;\\r\\nwhile ((status = sys$getjpiw(0, &pid, 0, item, iosb, 0, 0))\\r\\n!= SS$_NOMOREPROC) {\\r\\nif (status == SS$_NORMAL) {\\r\\nRAND_add((PTR_T) data_buffer, total_length, total_length / 2);\\r\\n}\\r\\n}\\r\\nsys$gettim(iosb);\\r\\nRAND_add((PTR_T) iosb, sizeof(iosb), sizeof(iosb) / 2);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_f_int_c", "target": 0, "func": "int i2a_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *a)\\r\\n{\\r\\nint i, n = 0;\\r\\nstatic const char *h = \"0123456789ABCDEF\";\\r\\nchar buf[2];\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (a->type & V_ASN1_NEG) {\\r\\nif (BIO_write(bp, \"-\", 1) != 1)\\r\\ngoto err;\\r\\nn = 1;\\r\\n}\\r\\nif (a->length == 0) {\\r\\nif (BIO_write(bp, \"00\", 2) != 2)\\r\\ngoto err;\\r\\nn += 2;\\r\\n} else {\\r\\nfor (i = 0; i < a->length; i++) {\\r\\nif ((i != 0) && (i % 35 == 0)) {\\r\\nif (BIO_write(bp, \"\\\\\\n\", 2) != 2)\\r\\ngoto err;\\r\\nn += 2;\\r\\n}\\r\\nbuf[0] = h[((unsigned char)a->data[i] >> 4) & 0x0f];\\r\\nbuf[1] = h[((unsigned char)a->data[i]) & 0x0f];\\r\\nif (BIO_write(bp, buf, 2) != 2)\\r\\ngoto err;\\r\\nn += 2;\\r\\n}\\r\\n}\\r\\nreturn (n);\\r\\nerr:\\r\\nreturn (-1);\\r\\n}\\r\\nint a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)\\r\\n{\\r\\nint ret = 0;\\r\\nint i, j, k, m, n, again, bufsize;\\r\\nunsigned char *s = NULL, *sp;\\r\\nunsigned char *bufp;\\r\\nint num = 0, slen = 0, first = 1;\\r\\nbs->type = V_ASN1_INTEGER;\\r\\nbufsize = BIO_gets(bp, buf, size);\\r\\nfor (;;) {\\r\\nif (bufsize < 1)\\r\\ngoto err_sl;\\r\\ni = bufsize;\\r\\nif (buf[i - 1] == '\\n')\\r\\nbuf[--i] = '\\0';\\r\\nif (i == 0)\\r\\ngoto err_sl;\\r\\nif (buf[i - 1] == '\\r')\\r\\nbuf[--i] = '\\0';\\r\\nif (i == 0)\\r\\ngoto err_sl;\\r\\nagain = (buf[i - 1] == '\\\\');\\r\\nfor (j = 0; j < i; j++) {\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (!(((buf[j] >= '0') && (buf[j] <= '9')) ||\\r\\n((buf[j] >= 'a') && (buf[j] <= 'f')) ||\\r\\n((buf[j] >= 'A') && (buf[j] <= 'F'))))\\r\\n#else\\r\\nif (!isxdigit(buf[j]))\\r\\n#endif\\r\\n{\\r\\ni = j;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf[i] = '\\0';\\r\\nif (i < 2)\\r\\ngoto err_sl;\\r\\nbufp = (unsigned char *)buf;\\r\\nif (first) {\\r\\nfirst = 0;\\r\\nif ((bufp[0] == '0') && (buf[1] == '0')) {\\r\\nbufp += 2;\\r\\ni -= 2;\\r\\n}\\r\\n}\\r\\nk = 0;\\r\\ni -= again;\\r\\nif (i % 2 != 0) {\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER, ASN1_R_ODD_NUMBER_OF_CHARS);\\r\\ngoto err;\\r\\n}\\r\\ni /= 2;\\r\\nif (num + i > slen) {\\r\\nif (s == NULL)\\r\\nsp = (unsigned char *)OPENSSL_malloc((unsigned int)num +\\r\\ni * 2);\\r\\nelse\\r\\nsp = OPENSSL_realloc_clean(s, slen, num + i * 2);\\r\\nif (sp == NULL) {\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);\\r\\nif (s != NULL)\\r\\nOPENSSL_free(s);\\r\\ngoto err;\\r\\n}\\r\\ns = sp;\\r\\nslen = num + i * 2;\\r\\n}\\r\\nfor (j = 0; j < i; j++, k += 2) {\\r\\nfor (n = 0; n < 2; n++) {\\r\\nm = bufp[k + n];\\r\\nif ((m >= '0') && (m <= '9'))\\r\\nm -= '0';\\r\\nelse if ((m >= 'a') && (m <= 'f'))\\r\\nm = m - 'a' + 10;\\r\\nelse if ((m >= 'A') && (m <= 'F'))\\r\\nm = m - 'A' + 10;\\r\\nelse {\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER,\\r\\nASN1_R_NON_HEX_CHARACTERS);\\r\\ngoto err;\\r\\n}\\r\\ns[num + j] <<= 4;\\r\\ns[num + j] |= m;\\r\\n}\\r\\n}\\r\\nnum += i;\\r\\nif (again)\\r\\nbufsize = BIO_gets(bp, buf, size);\\r\\nelse\\r\\nbreak;\\r\\n}\\r\\nbs->length = num;\\r\\nbs->data = s;\\r\\nret = 1;\\r\\nerr:\\r\\nif (0) {\\r\\nerr_sl:\\r\\nASN1err(ASN1_F_A2I_ASN1_INTEGER, ASN1_R_SHORT_LINE);\\r\\n}\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ofb64enc_c", "target": 0, "func": "void DES_ofb64_encrypt(register const unsigned char *in,\\r\\nregister unsigned char *out, long length,\\r\\nDES_key_schedule *schedule, DES_cblock *ivec, int *num)\\r\\n{\\r\\nregister DES_LONG v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nDES_cblock d;\\r\\nregister unsigned char *dp;\\r\\nDES_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save = 0;\\r\\niv = &(*ivec)[0];\\r\\nc2l(iv, v0);\\r\\nc2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\ndp = d;\\r\\nl2c(v0, dp);\\r\\nl2c(v1, dp);\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nDES_encrypt1(ti, schedule, DES_ENCRYPT);\\r\\ndp = d;\\r\\nt = ti[0];\\r\\nl2c(t, dp);\\r\\nt = ti[1];\\r\\nl2c(t, dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++) = *(in++) ^ d[n];\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\nif (save) {\\r\\nv0 = ti[0];\\r\\nv1 = ti[1];\\r\\niv = &(*ivec)[0];\\r\\nl2c(v0, iv);\\r\\nl2c(v1, iv);\\r\\n}\\r\\nt = v0 = v1 = ti[0] = ti[1] = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tab_c", "target": 0, "func": "main()\\r\\n{\\r\\nint i, j;\\r\\nfor (i = 0; i < 256; i++) {\\r\\nfor (j = 0; j < 256; j++)\\r\\nif (ebits_to_num[j] == i) {\\r\\nprintf(\"0x%02x,\", j);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_rsa_c", "target": 0, "func": "int SSL_use_certificate(SSL *ssl, X509 *x)\\r\\n{\\r\\nif (x == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ssl->cert)) {\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (ssl_set_cert(ssl->cert, x));\\r\\n}\\r\\nint SSL_use_certificate_file(SSL *ssl, const char *file, int type)\\r\\n{\\r\\nint j;\\r\\nBIO *in;\\r\\nint ret = 0;\\r\\nX509 *x = NULL;\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE, ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in, file) <= 0) {\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE, ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1) {\\r\\nj = ERR_R_ASN1_LIB;\\r\\nx = d2i_X509_bio(in, NULL);\\r\\n} else if (type == SSL_FILETYPE_PEM) {\\r\\nj = ERR_R_PEM_LIB;\\r\\nx = PEM_read_bio_X509(in, NULL, ssl->ctx->default_passwd_callback,\\r\\nssl->ctx->default_passwd_callback_userdata);\\r\\n} else {\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE, SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_FILE, j);\\r\\ngoto end;\\r\\n}\\r\\nret = SSL_use_certificate(ssl, x);\\r\\nend:\\r\\nif (x != NULL)\\r\\nX509_free(x);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len)\\r\\n{\\r\\nX509 *x;\\r\\nint ret;\\r\\nx = d2i_X509(NULL, &d, (long)len);\\r\\nif (x == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_CERTIFICATE_ASN1, ERR_R_ASN1_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nret = SSL_use_certificate(ssl, x);\\r\\nX509_free(x);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nint ret;\\r\\nif (rsa == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ssl->cert)) {\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nif ((pkey = EVP_PKEY_new()) == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY, ERR_R_EVP_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nRSA_up_ref(rsa);\\r\\nEVP_PKEY_assign_RSA(pkey, rsa);\\r\\nret = ssl_set_pkey(ssl->cert, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int ssl_set_pkey(CERT *c, EVP_PKEY *pkey)\\r\\n{\\r\\nint i;\\r\\nif (pkey->type == EVP_PKEY_DH) {\\r\\nX509 *x;\\r\\ni = -1;\\r\\nx = c->pkeys[SSL_PKEY_DH_RSA].x509;\\r\\nif (x && X509_check_private_key(x, pkey))\\r\\ni = SSL_PKEY_DH_RSA;\\r\\nx = c->pkeys[SSL_PKEY_DH_DSA].x509;\\r\\nif (i == -1 && x && X509_check_private_key(x, pkey))\\r\\ni = SSL_PKEY_DH_DSA;\\r\\nERR_clear_error();\\r\\n} else\\r\\ni = ssl_cert_type(NULL, pkey);\\r\\nif (i < 0) {\\r\\nSSLerr(SSL_F_SSL_SET_PKEY, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\\r\\nreturn (0);\\r\\n}\\r\\nif (c->pkeys[i].x509 != NULL) {\\r\\nEVP_PKEY *pktmp;\\r\\npktmp = X509_get_pubkey(c->pkeys[i].x509);\\r\\nEVP_PKEY_copy_parameters(pktmp, pkey);\\r\\nEVP_PKEY_free(pktmp);\\r\\nERR_clear_error();\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif ((pkey->type == EVP_PKEY_RSA) &&\\r\\n(RSA_flags(pkey->pkey.rsa) & RSA_METHOD_FLAG_NO_CHECK)) ;\\r\\nelse\\r\\n#endif\\r\\nif (!X509_check_private_key(c->pkeys[i].x509, pkey)) {\\r\\nX509_free(c->pkeys[i].x509);\\r\\nc->pkeys[i].x509 = NULL;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (c->pkeys[i].privatekey != NULL)\\r\\nEVP_PKEY_free(c->pkeys[i].privatekey);\\r\\nCRYPTO_add(&pkey->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\nc->pkeys[i].privatekey = pkey;\\r\\nc->key = &(c->pkeys[i]);\\r\\nc->valid = 0;\\r\\nreturn (1);\\r\\n}\\r\\nint SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type)\\r\\n{\\r\\nint j, ret = 0;\\r\\nBIO *in;\\r\\nRSA *rsa = NULL;\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE, ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in, file) <= 0) {\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE, ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1) {\\r\\nj = ERR_R_ASN1_LIB;\\r\\nrsa = d2i_RSAPrivateKey_bio(in, NULL);\\r\\n} else if (type == SSL_FILETYPE_PEM) {\\r\\nj = ERR_R_PEM_LIB;\\r\\nrsa = PEM_read_bio_RSAPrivateKey(in, NULL,\\r\\nssl->ctx->default_passwd_callback,\\r\\nssl->\\r\\nctx->default_passwd_callback_userdata);\\r\\n} else {\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (rsa == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_FILE, j);\\r\\ngoto end;\\r\\n}\\r\\nret = SSL_use_RSAPrivateKey(ssl, rsa);\\r\\nRSA_free(rsa);\\r\\nend:\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len)\\r\\n{\\r\\nint ret;\\r\\nconst unsigned char *p;\\r\\nRSA *rsa;\\r\\np = d;\\r\\nif ((rsa = d2i_RSAPrivateKey(NULL, &p, (long)len)) == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1, ERR_R_ASN1_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nret = SSL_use_RSAPrivateKey(ssl, rsa);\\r\\nRSA_free(rsa);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey)\\r\\n{\\r\\nint ret;\\r\\nif (pkey == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ssl->cert)) {\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nret = ssl_set_pkey(ssl->cert, pkey);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type)\\r\\n{\\r\\nint j, ret = 0;\\r\\nBIO *in;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE, ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in, file) <= 0) {\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE, ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_PEM) {\\r\\nj = ERR_R_PEM_LIB;\\r\\npkey = PEM_read_bio_PrivateKey(in, NULL,\\r\\nssl->ctx->default_passwd_callback,\\r\\nssl->\\r\\nctx->default_passwd_callback_userdata);\\r\\n} else if (type == SSL_FILETYPE_ASN1) {\\r\\nj = ERR_R_ASN1_LIB;\\r\\npkey = d2i_PrivateKey_bio(in, NULL);\\r\\n} else {\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (pkey == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_FILE, j);\\r\\ngoto end;\\r\\n}\\r\\nret = SSL_use_PrivateKey(ssl, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nend:\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_use_PrivateKey_ASN1(int type, SSL *ssl, const unsigned char *d,\\r\\nlong len)\\r\\n{\\r\\nint ret;\\r\\nconst unsigned char *p;\\r\\nEVP_PKEY *pkey;\\r\\np = d;\\r\\nif ((pkey = d2i_PrivateKey(type, NULL, &p, (long)len)) == NULL) {\\r\\nSSLerr(SSL_F_SSL_USE_PRIVATEKEY_ASN1, ERR_R_ASN1_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nret = SSL_use_PrivateKey(ssl, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x)\\r\\n{\\r\\nif (x == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert)) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (ssl_set_cert(ctx->cert, x));\\r\\n}\\r\\nstatic int ssl_set_cert(CERT *c, X509 *x)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nint i;\\r\\npkey = X509_get_pubkey(x);\\r\\nif (pkey == NULL) {\\r\\nSSLerr(SSL_F_SSL_SET_CERT, SSL_R_X509_LIB);\\r\\nreturn (0);\\r\\n}\\r\\ni = ssl_cert_type(x, pkey);\\r\\nif (i < 0) {\\r\\nSSLerr(SSL_F_SSL_SET_CERT, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn (0);\\r\\n}\\r\\nif (c->pkeys[i].privatekey != NULL) {\\r\\nEVP_PKEY_copy_parameters(pkey, c->pkeys[i].privatekey);\\r\\nERR_clear_error();\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif ((c->pkeys[i].privatekey->type == EVP_PKEY_RSA) &&\\r\\n(RSA_flags(c->pkeys[i].privatekey->pkey.rsa) &\\r\\nRSA_METHOD_FLAG_NO_CHECK)) ;\\r\\nelse\\r\\n#endif\\r\\nif (!X509_check_private_key(x, c->pkeys[i].privatekey)) {\\r\\nEVP_PKEY_free(c->pkeys[i].privatekey);\\r\\nc->pkeys[i].privatekey = NULL;\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\nEVP_PKEY_free(pkey);\\r\\nif (c->pkeys[i].x509 != NULL)\\r\\nX509_free(c->pkeys[i].x509);\\r\\nCRYPTO_add(&x->references, 1, CRYPTO_LOCK_X509);\\r\\nc->pkeys[i].x509 = x;\\r\\nc->key = &(c->pkeys[i]);\\r\\nc->valid = 0;\\r\\nreturn (1);\\r\\n}\\r\\nint SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type)\\r\\n{\\r\\nint j;\\r\\nBIO *in;\\r\\nint ret = 0;\\r\\nX509 *x = NULL;\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE, ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in, file) <= 0) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE, ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1) {\\r\\nj = ERR_R_ASN1_LIB;\\r\\nx = d2i_X509_bio(in, NULL);\\r\\n} else if (type == SSL_FILETYPE_PEM) {\\r\\nj = ERR_R_PEM_LIB;\\r\\nx = PEM_read_bio_X509(in, NULL, ctx->default_passwd_callback,\\r\\nctx->default_passwd_callback_userdata);\\r\\n} else {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE, SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_FILE, j);\\r\\ngoto end;\\r\\n}\\r\\nret = SSL_CTX_use_certificate(ctx, x);\\r\\nend:\\r\\nif (x != NULL)\\r\\nX509_free(x);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len,\\r\\nconst unsigned char *d)\\r\\n{\\r\\nX509 *x;\\r\\nint ret;\\r\\nx = d2i_X509(NULL, &d, (long)len);\\r\\nif (x == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1, ERR_R_ASN1_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nret = SSL_CTX_use_certificate(ctx, x);\\r\\nX509_free(x);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa)\\r\\n{\\r\\nint ret;\\r\\nEVP_PKEY *pkey;\\r\\nif (rsa == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert)) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nif ((pkey = EVP_PKEY_new()) == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY, ERR_R_EVP_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nRSA_up_ref(rsa);\\r\\nEVP_PKEY_assign_RSA(pkey, rsa);\\r\\nret = ssl_set_pkey(ctx->cert, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type)\\r\\n{\\r\\nint j, ret = 0;\\r\\nBIO *in;\\r\\nRSA *rsa = NULL;\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE, ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in, file) <= 0) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE, ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_ASN1) {\\r\\nj = ERR_R_ASN1_LIB;\\r\\nrsa = d2i_RSAPrivateKey_bio(in, NULL);\\r\\n} else if (type == SSL_FILETYPE_PEM) {\\r\\nj = ERR_R_PEM_LIB;\\r\\nrsa = PEM_read_bio_RSAPrivateKey(in, NULL,\\r\\nctx->default_passwd_callback,\\r\\nctx->default_passwd_callback_userdata);\\r\\n} else {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (rsa == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE, j);\\r\\ngoto end;\\r\\n}\\r\\nret = SSL_CTX_use_RSAPrivateKey(ctx, rsa);\\r\\nRSA_free(rsa);\\r\\nend:\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d,\\r\\nlong len)\\r\\n{\\r\\nint ret;\\r\\nconst unsigned char *p;\\r\\nRSA *rsa;\\r\\np = d;\\r\\nif ((rsa = d2i_RSAPrivateKey(NULL, &p, (long)len)) == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1, ERR_R_ASN1_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nret = SSL_CTX_use_RSAPrivateKey(ctx, rsa);\\r\\nRSA_free(rsa);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nif (pkey == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert)) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nreturn (ssl_set_pkey(ctx->cert, pkey));\\r\\n}\\r\\nint SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type)\\r\\n{\\r\\nint j, ret = 0;\\r\\nBIO *in;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in, file) <= 0) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (type == SSL_FILETYPE_PEM) {\\r\\nj = ERR_R_PEM_LIB;\\r\\npkey = PEM_read_bio_PrivateKey(in, NULL,\\r\\nctx->default_passwd_callback,\\r\\nctx->default_passwd_callback_userdata);\\r\\n} else if (type == SSL_FILETYPE_ASN1) {\\r\\nj = ERR_R_ASN1_LIB;\\r\\npkey = d2i_PrivateKey_bio(in, NULL);\\r\\n} else {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, SSL_R_BAD_SSL_FILETYPE);\\r\\ngoto end;\\r\\n}\\r\\nif (pkey == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE, j);\\r\\ngoto end;\\r\\n}\\r\\nret = SSL_CTX_use_PrivateKey(ctx, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nend:\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_CTX_use_PrivateKey_ASN1(int type, SSL_CTX *ctx,\\r\\nconst unsigned char *d, long len)\\r\\n{\\r\\nint ret;\\r\\nconst unsigned char *p;\\r\\nEVP_PKEY *pkey;\\r\\np = d;\\r\\nif ((pkey = d2i_PrivateKey(type, NULL, &p, (long)len)) == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1, ERR_R_ASN1_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nret = SSL_CTX_use_PrivateKey(ctx, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nreturn (ret);\\r\\n}\\r\\nint SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file)\\r\\n{\\r\\nBIO *in;\\r\\nint ret = 0;\\r\\nX509 *x = NULL;\\r\\nERR_clear_error();\\r\\nin = BIO_new(BIO_s_file_internal());\\r\\nif (in == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(in, file) <= 0) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nx = PEM_read_bio_X509_AUX(in, NULL, ctx->default_passwd_callback,\\r\\nctx->default_passwd_callback_userdata);\\r\\nif (x == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_CERTIFICATE_CHAIN_FILE, ERR_R_PEM_LIB);\\r\\ngoto end;\\r\\n}\\r\\nret = SSL_CTX_use_certificate(ctx, x);\\r\\nif (ERR_peek_error() != 0)\\r\\nret = 0;\\r\\nif (ret) {\\r\\nX509 *ca;\\r\\nint r;\\r\\nunsigned long err;\\r\\nSSL_CTX_clear_chain_certs(ctx);\\r\\nwhile ((ca = PEM_read_bio_X509(in, NULL,\\r\\nctx->default_passwd_callback,\\r\\nctx->default_passwd_callback_userdata))\\r\\n!= NULL) {\\r\\nr = SSL_CTX_add0_chain_cert(ctx, ca);\\r\\nif (!r) {\\r\\nX509_free(ca);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nerr = ERR_peek_last_error();\\r\\nif (ERR_GET_LIB(err) == ERR_LIB_PEM\\r\\n&& ERR_GET_REASON(err) == PEM_R_NO_START_LINE)\\r\\nERR_clear_error();\\r\\nelse\\r\\nret = 0;\\r\\n}\\r\\nend:\\r\\nif (x != NULL)\\r\\nX509_free(x);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int serverinfo_find_extension(const unsigned char *serverinfo,\\r\\nsize_t serverinfo_length,\\r\\nunsigned int extension_type,\\r\\nconst unsigned char **extension_data,\\r\\nsize_t *extension_length)\\r\\n{\\r\\n*extension_data = NULL;\\r\\n*extension_length = 0;\\r\\nif (serverinfo == NULL || serverinfo_length == 0)\\r\\nreturn 0;\\r\\nfor (;;) {\\r\\nunsigned int type = 0;\\r\\nsize_t len = 0;\\r\\nif (serverinfo_length == 0)\\r\\nreturn -1;\\r\\nif (serverinfo_length < 2)\\r\\nreturn 0;\\r\\ntype = (serverinfo[0] << 8) + serverinfo[1];\\r\\nserverinfo += 2;\\r\\nserverinfo_length -= 2;\\r\\nif (serverinfo_length < 2)\\r\\nreturn 0;\\r\\nlen = (serverinfo[0] << 8) + serverinfo[1];\\r\\nserverinfo += 2;\\r\\nserverinfo_length -= 2;\\r\\nif (len > serverinfo_length)\\r\\nreturn 0;\\r\\nif (type == extension_type) {\\r\\n*extension_data = serverinfo;\\r\\n*extension_length = len;\\r\\nreturn 1;\\r\\n}\\r\\nserverinfo += len;\\r\\nserverinfo_length -= len;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int serverinfo_srv_parse_cb(SSL *s, unsigned int ext_type,\\r\\nconst unsigned char *in,\\r\\nsize_t inlen, int *al, void *arg)\\r\\n{\\r\\nif (inlen != 0) {\\r\\n*al = SSL_AD_DECODE_ERROR;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int serverinfo_srv_add_cb(SSL *s, unsigned int ext_type,\\r\\nconst unsigned char **out, size_t *outlen,\\r\\nint *al, void *arg)\\r\\n{\\r\\nconst unsigned char *serverinfo = NULL;\\r\\nsize_t serverinfo_length = 0;\\r\\nif ((ssl_get_server_cert_serverinfo(s, &serverinfo,\\r\\n&serverinfo_length)) != 0) {\\r\\nint retval = serverinfo_find_extension(serverinfo, serverinfo_length,\\r\\next_type, out, outlen);\\r\\nif (retval == 0)\\r\\nreturn 0;\\r\\nif (retval == -1)\\r\\nreturn -1;\\r\\nreturn 1;\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nstatic int serverinfo_process_buffer(const unsigned char *serverinfo,\\r\\nsize_t serverinfo_length, SSL_CTX *ctx)\\r\\n{\\r\\nif (serverinfo == NULL || serverinfo_length == 0)\\r\\nreturn 0;\\r\\nfor (;;) {\\r\\nunsigned int ext_type = 0;\\r\\nsize_t len = 0;\\r\\nif (serverinfo_length == 0)\\r\\nreturn 1;\\r\\nif (serverinfo_length < 2)\\r\\nreturn 0;\\r\\next_type = (serverinfo[0] << 8) + serverinfo[1];\\r\\nif (ctx && !SSL_CTX_add_server_custom_ext(ctx, ext_type,\\r\\nserverinfo_srv_add_cb,\\r\\nNULL, NULL,\\r\\nserverinfo_srv_parse_cb,\\r\\nNULL))\\r\\nreturn 0;\\r\\nserverinfo += 2;\\r\\nserverinfo_length -= 2;\\r\\nif (serverinfo_length < 2)\\r\\nreturn 0;\\r\\nlen = (serverinfo[0] << 8) + serverinfo[1];\\r\\nserverinfo += 2;\\r\\nserverinfo_length -= 2;\\r\\nif (len > serverinfo_length)\\r\\nreturn 0;\\r\\nserverinfo += len;\\r\\nserverinfo_length -= len;\\r\\n}\\r\\n}\\r\\nint SSL_CTX_use_serverinfo(SSL_CTX *ctx, const unsigned char *serverinfo,\\r\\nsize_t serverinfo_length)\\r\\n{\\r\\nif (ctx == NULL || serverinfo == NULL || serverinfo_length == 0) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nif (!serverinfo_process_buffer(serverinfo, serverinfo_length, NULL)) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO, SSL_R_INVALID_SERVERINFO_DATA);\\r\\nreturn 0;\\r\\n}\\r\\nif (!ssl_cert_inst(&ctx->cert)) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (ctx->cert->key == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO, ERR_R_INTERNAL_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nctx->cert->key->serverinfo = OPENSSL_realloc(ctx->cert->key->serverinfo,\\r\\nserverinfo_length);\\r\\nif (ctx->cert->key->serverinfo == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nmemcpy(ctx->cert->key->serverinfo, serverinfo, serverinfo_length);\\r\\nctx->cert->key->serverinfo_length = serverinfo_length;\\r\\nif (!serverinfo_process_buffer(serverinfo, serverinfo_length, ctx)) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO, SSL_R_INVALID_SERVERINFO_DATA);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint SSL_CTX_use_serverinfo_file(SSL_CTX *ctx, const char *file)\\r\\n{\\r\\nunsigned char *serverinfo = NULL;\\r\\nsize_t serverinfo_length = 0;\\r\\nunsigned char *extension = 0;\\r\\nlong extension_length = 0;\\r\\nchar *name = NULL;\\r\\nchar *header = NULL;\\r\\nchar namePrefix[] = \"SERVERINFO FOR \";\\r\\nint ret = 0;\\r\\nBIO *bin = NULL;\\r\\nsize_t num_extensions = 0;\\r\\nif (ctx == NULL || file == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO_FILE,\\r\\nERR_R_PASSED_NULL_PARAMETER);\\r\\ngoto end;\\r\\n}\\r\\nbin = BIO_new(BIO_s_file_internal());\\r\\nif (bin == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO_FILE, ERR_R_BUF_LIB);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_read_filename(bin, file) <= 0) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO_FILE, ERR_R_SYS_LIB);\\r\\ngoto end;\\r\\n}\\r\\nfor (num_extensions = 0;; num_extensions++) {\\r\\nif (PEM_read_bio(bin, &name, &header, &extension, &extension_length)\\r\\n== 0) {\\r\\nif (num_extensions == 0) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO_FILE,\\r\\nSSL_R_NO_PEM_EXTENSIONS);\\r\\ngoto end;\\r\\n} else\\r\\nbreak;\\r\\n}\\r\\nif (strlen(name) < strlen(namePrefix)) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO_FILE,\\r\\nSSL_R_PEM_NAME_TOO_SHORT);\\r\\ngoto end;\\r\\n}\\r\\nif (strncmp(name, namePrefix, strlen(namePrefix)) != 0) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO_FILE,\\r\\nSSL_R_PEM_NAME_BAD_PREFIX);\\r\\ngoto end;\\r\\n}\\r\\nif (extension_length < 4\\r\\n|| (extension[2] << 8) + extension[3] != extension_length - 4) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO_FILE, SSL_R_BAD_DATA);\\r\\ngoto end;\\r\\n}\\r\\nserverinfo =\\r\\nOPENSSL_realloc(serverinfo, serverinfo_length + extension_length);\\r\\nif (serverinfo == NULL) {\\r\\nSSLerr(SSL_F_SSL_CTX_USE_SERVERINFO_FILE, ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nmemcpy(serverinfo + serverinfo_length, extension, extension_length);\\r\\nserverinfo_length += extension_length;\\r\\nOPENSSL_free(name);\\r\\nname = NULL;\\r\\nOPENSSL_free(header);\\r\\nheader = NULL;\\r\\nOPENSSL_free(extension);\\r\\nextension = NULL;\\r\\n}\\r\\nret = SSL_CTX_use_serverinfo(ctx, serverinfo, serverinfo_length);\\r\\nend:\\r\\nOPENSSL_free(name);\\r\\nOPENSSL_free(header);\\r\\nOPENSSL_free(extension);\\r\\nOPENSSL_free(serverinfo);\\r\\nif (bin != NULL)\\r\\nBIO_free(bin);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_type_c", "target": 0, "func": "int ASN1_TYPE_get(ASN1_TYPE *a)\\r\\n{\\r\\nif ((a->value.ptr != NULL) || (a->type == V_ASN1_NULL))\\r\\nreturn (a->type);\\r\\nelse\\r\\nreturn (0);\\r\\n}\\r\\nvoid ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value)\\r\\n{\\r\\nif (a->value.ptr != NULL) {\\r\\nASN1_TYPE **tmp_a = &a;\\r\\nASN1_primitive_free((ASN1_VALUE **)tmp_a, NULL);\\r\\n}\\r\\na->type = type;\\r\\nif (type == V_ASN1_BOOLEAN)\\r\\na->value.boolean = value ? 0xff : 0;\\r\\nelse\\r\\na->value.ptr = value;\\r\\n}\\r\\nint ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value)\\r\\n{\\r\\nif (!value || (type == V_ASN1_BOOLEAN)) {\\r\\nvoid *p = (void *)value;\\r\\nASN1_TYPE_set(a, type, p);\\r\\n} else if (type == V_ASN1_OBJECT) {\\r\\nASN1_OBJECT *odup;\\r\\nodup = OBJ_dup(value);\\r\\nif (!odup)\\r\\nreturn 0;\\r\\nASN1_TYPE_set(a, type, odup);\\r\\n} else {\\r\\nASN1_STRING *sdup;\\r\\nsdup = ASN1_STRING_dup(value);\\r\\nif (!sdup)\\r\\nreturn 0;\\r\\nASN1_TYPE_set(a, type, sdup);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)\\r\\n{\\r\\nint result = -1;\\r\\nif (!a || !b || a->type != b->type)\\r\\nreturn -1;\\r\\nswitch (a->type) {\\r\\ncase V_ASN1_OBJECT:\\r\\nresult = OBJ_cmp(a->value.object, b->value.object);\\r\\nbreak;\\r\\ncase V_ASN1_NULL:\\r\\nresult = 0;\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_NEG_INTEGER:\\r\\ncase V_ASN1_ENUMERATED:\\r\\ncase V_ASN1_NEG_ENUMERATED:\\r\\ncase V_ASN1_BIT_STRING:\\r\\ncase V_ASN1_OCTET_STRING:\\r\\ncase V_ASN1_SEQUENCE:\\r\\ncase V_ASN1_SET:\\r\\ncase V_ASN1_NUMERICSTRING:\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\ncase V_ASN1_T61STRING:\\r\\ncase V_ASN1_VIDEOTEXSTRING:\\r\\ncase V_ASN1_IA5STRING:\\r\\ncase V_ASN1_UTCTIME:\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\ncase V_ASN1_GRAPHICSTRING:\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\ncase V_ASN1_GENERALSTRING:\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\ncase V_ASN1_BMPSTRING:\\r\\ncase V_ASN1_UTF8STRING:\\r\\ncase V_ASN1_OTHER:\\r\\ndefault:\\r\\nresult = ASN1_STRING_cmp((ASN1_STRING *)a->value.ptr,\\r\\n(ASN1_STRING *)b->value.ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn result;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_uncomp_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL;\\r\\nCMS_ContentInfo *cms = NULL;\\r\\nint ret = 1;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\nin = BIO_new_file(\"smcomp.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\ncms = SMIME_read_CMS(in, NULL);\\r\\nif (!cms)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smuncomp.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!CMS_uncompress(cms, out, NULL, 0))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Uncompressing Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_evp_err_c", "target": 0, "func": "void ERR_load_EVP_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(EVP_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, EVP_str_functs);\\r\\nERR_load_strings(0, EVP_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cmll_ecb_c", "target": 0, "func": "void Camellia_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst CAMELLIA_KEY *key, const int enc)\\r\\n{\\r\\nassert(in && out && key);\\r\\nassert((CAMELLIA_ENCRYPT == enc) || (CAMELLIA_DECRYPT == enc));\\r\\nif (CAMELLIA_ENCRYPT == enc)\\r\\nCamellia_encrypt(in, out, key);\\r\\nelse\\r\\nCamellia_decrypt(in, out, key);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cts128_c", "target": 0, "func": "size_t CRYPTO_cts128_encrypt_block(const unsigned char *in,\\r\\nunsigned char *out, size_t len,\\r\\nconst void *key, unsigned char ivec[16],\\r\\nblock128_f block)\\r\\n{\\r\\nsize_t residue, n;\\r\\nassert(in && out && key && ivec);\\r\\nif (len <= 16)\\r\\nreturn 0;\\r\\nif ((residue = len % 16) == 0)\\r\\nresidue = 16;\\r\\nlen -= residue;\\r\\nCRYPTO_cbc128_encrypt(in, out, len, key, ivec, block);\\r\\nin += len;\\r\\nout += len;\\r\\nfor (n = 0; n < residue; ++n)\\r\\nivec[n] ^= in[n];\\r\\n(*block) (ivec, ivec, key);\\r\\nmemcpy(out, out - 16, residue);\\r\\nmemcpy(out - 16, ivec, 16);\\r\\nreturn len + residue;\\r\\n}\\r\\nsize_t CRYPTO_nistcts128_encrypt_block(const unsigned char *in,\\r\\nunsigned char *out, size_t len,\\r\\nconst void *key,\\r\\nunsigned char ivec[16],\\r\\nblock128_f block)\\r\\n{\\r\\nsize_t residue, n;\\r\\nassert(in && out && key && ivec);\\r\\nif (len < 16)\\r\\nreturn 0;\\r\\nresidue = len % 16;\\r\\nlen -= residue;\\r\\nCRYPTO_cbc128_encrypt(in, out, len, key, ivec, block);\\r\\nif (residue == 0)\\r\\nreturn len;\\r\\nin += len;\\r\\nout += len;\\r\\nfor (n = 0; n < residue; ++n)\\r\\nivec[n] ^= in[n];\\r\\n(*block) (ivec, ivec, key);\\r\\nmemcpy(out - 16 + residue, ivec, 16);\\r\\nreturn len + residue;\\r\\n}\\r\\nsize_t CRYPTO_cts128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16], cbc128_f cbc)\\r\\n{\\r\\nsize_t residue;\\r\\nunion {\\r\\nsize_t align;\\r\\nunsigned char c[16];\\r\\n} tmp;\\r\\nassert(in && out && key && ivec);\\r\\nif (len <= 16)\\r\\nreturn 0;\\r\\nif ((residue = len % 16) == 0)\\r\\nresidue = 16;\\r\\nlen -= residue;\\r\\n(*cbc) (in, out, len, key, ivec, 1);\\r\\nin += len;\\r\\nout += len;\\r\\n#if defined(CBC_HANDLES_TRUNCATED_IO)\\r\\nmemcpy(tmp.c, out - 16, 16);\\r\\n(*cbc) (in, out - 16, residue, key, ivec, 1);\\r\\nmemcpy(out, tmp.c, residue);\\r\\n#else\\r\\nmemset(tmp.c, 0, sizeof(tmp));\\r\\nmemcpy(tmp.c, in, residue);\\r\\nmemcpy(out, out - 16, residue);\\r\\n(*cbc) (tmp.c, out - 16, 16, key, ivec, 1);\\r\\n#endif\\r\\nreturn len + residue;\\r\\n}\\r\\nsize_t CRYPTO_nistcts128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16], cbc128_f cbc)\\r\\n{\\r\\nsize_t residue;\\r\\nunion {\\r\\nsize_t align;\\r\\nunsigned char c[16];\\r\\n} tmp;\\r\\nassert(in && out && key && ivec);\\r\\nif (len < 16)\\r\\nreturn 0;\\r\\nresidue = len % 16;\\r\\nlen -= residue;\\r\\n(*cbc) (in, out, len, key, ivec, 1);\\r\\nif (residue == 0)\\r\\nreturn len;\\r\\nin += len;\\r\\nout += len;\\r\\n#if defined(CBC_HANDLES_TRUNCATED_IO)\\r\\n(*cbc) (in, out - 16 + residue, residue, key, ivec, 1);\\r\\n#else\\r\\nmemset(tmp.c, 0, sizeof(tmp));\\r\\nmemcpy(tmp.c, in, residue);\\r\\n(*cbc) (tmp.c, out - 16 + residue, 16, key, ivec, 1);\\r\\n#endif\\r\\nreturn len + residue;\\r\\n}\\r\\nsize_t CRYPTO_cts128_decrypt_block(const unsigned char *in,\\r\\nunsigned char *out, size_t len,\\r\\nconst void *key, unsigned char ivec[16],\\r\\nblock128_f block)\\r\\n{\\r\\nsize_t residue, n;\\r\\nunion {\\r\\nsize_t align;\\r\\nunsigned char c[32];\\r\\n} tmp;\\r\\nassert(in && out && key && ivec);\\r\\nif (len <= 16)\\r\\nreturn 0;\\r\\nif ((residue = len % 16) == 0)\\r\\nresidue = 16;\\r\\nlen -= 16 + residue;\\r\\nif (len) {\\r\\nCRYPTO_cbc128_decrypt(in, out, len, key, ivec, block);\\r\\nin += len;\\r\\nout += len;\\r\\n}\\r\\n(*block) (in, tmp.c + 16, key);\\r\\nmemcpy(tmp.c, tmp.c + 16, 16);\\r\\nmemcpy(tmp.c, in + 16, residue);\\r\\n(*block) (tmp.c, tmp.c, key);\\r\\nfor (n = 0; n < 16; ++n) {\\r\\nunsigned char c = in[n];\\r\\nout[n] = tmp.c[n] ^ ivec[n];\\r\\nivec[n] = c;\\r\\n}\\r\\nfor (residue += 16; n < residue; ++n)\\r\\nout[n] = tmp.c[n] ^ in[n];\\r\\nreturn 16 + len + residue;\\r\\n}\\r\\nsize_t CRYPTO_nistcts128_decrypt_block(const unsigned char *in,\\r\\nunsigned char *out, size_t len,\\r\\nconst void *key,\\r\\nunsigned char ivec[16],\\r\\nblock128_f block)\\r\\n{\\r\\nsize_t residue, n;\\r\\nunion {\\r\\nsize_t align;\\r\\nunsigned char c[32];\\r\\n} tmp;\\r\\nassert(in && out && key && ivec);\\r\\nif (len < 16)\\r\\nreturn 0;\\r\\nresidue = len % 16;\\r\\nif (residue == 0) {\\r\\nCRYPTO_cbc128_decrypt(in, out, len, key, ivec, block);\\r\\nreturn len;\\r\\n}\\r\\nlen -= 16 + residue;\\r\\nif (len) {\\r\\nCRYPTO_cbc128_decrypt(in, out, len, key, ivec, block);\\r\\nin += len;\\r\\nout += len;\\r\\n}\\r\\n(*block) (in + residue, tmp.c + 16, key);\\r\\nmemcpy(tmp.c, tmp.c + 16, 16);\\r\\nmemcpy(tmp.c, in, residue);\\r\\n(*block) (tmp.c, tmp.c, key);\\r\\nfor (n = 0; n < 16; ++n) {\\r\\nunsigned char c = in[n];\\r\\nout[n] = tmp.c[n] ^ ivec[n];\\r\\nivec[n] = in[n + residue];\\r\\ntmp.c[n] = c;\\r\\n}\\r\\nfor (residue += 16; n < residue; ++n)\\r\\nout[n] = tmp.c[n] ^ tmp.c[n - 16];\\r\\nreturn 16 + len + residue;\\r\\n}\\r\\nsize_t CRYPTO_cts128_decrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16], cbc128_f cbc)\\r\\n{\\r\\nsize_t residue;\\r\\nunion {\\r\\nsize_t align;\\r\\nunsigned char c[32];\\r\\n} tmp;\\r\\nassert(in && out && key && ivec);\\r\\nif (len <= 16)\\r\\nreturn 0;\\r\\nif ((residue = len % 16) == 0)\\r\\nresidue = 16;\\r\\nlen -= 16 + residue;\\r\\nif (len) {\\r\\n(*cbc) (in, out, len, key, ivec, 0);\\r\\nin += len;\\r\\nout += len;\\r\\n}\\r\\nmemset(tmp.c, 0, sizeof(tmp));\\r\\n(*cbc) (in, tmp.c, 16, key, tmp.c + 16, 0);\\r\\nmemcpy(tmp.c, in + 16, residue);\\r\\n#if defined(CBC_HANDLES_TRUNCATED_IO)\\r\\n(*cbc) (tmp.c, out, 16 + residue, key, ivec, 0);\\r\\n#else\\r\\n(*cbc) (tmp.c, tmp.c, 32, key, ivec, 0);\\r\\nmemcpy(out, tmp.c, 16 + residue);\\r\\n#endif\\r\\nreturn 16 + len + residue;\\r\\n}\\r\\nsize_t CRYPTO_nistcts128_decrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16], cbc128_f cbc)\\r\\n{\\r\\nsize_t residue;\\r\\nunion {\\r\\nsize_t align;\\r\\nunsigned char c[32];\\r\\n} tmp;\\r\\nassert(in && out && key && ivec);\\r\\nif (len < 16)\\r\\nreturn 0;\\r\\nresidue = len % 16;\\r\\nif (residue == 0) {\\r\\n(*cbc) (in, out, len, key, ivec, 0);\\r\\nreturn len;\\r\\n}\\r\\nlen -= 16 + residue;\\r\\nif (len) {\\r\\n(*cbc) (in, out, len, key, ivec, 0);\\r\\nin += len;\\r\\nout += len;\\r\\n}\\r\\nmemset(tmp.c, 0, sizeof(tmp));\\r\\n(*cbc) (in + residue, tmp.c, 16, key, tmp.c + 16, 0);\\r\\nmemcpy(tmp.c, in, residue);\\r\\n#if defined(CBC_HANDLES_TRUNCATED_IO)\\r\\n(*cbc) (tmp.c, out, 16 + residue, key, ivec, 0);\\r\\n#else\\r\\n(*cbc) (tmp.c, tmp.c, 32, key, ivec, 0);\\r\\nmemcpy(out, tmp.c, 16 + residue);\\r\\n#endif\\r\\nreturn 16 + len + residue;\\r\\n}\\r\\nvoid test_vector(const unsigned char *vector, size_t len)\\r\\n{\\r\\nunsigned char iv[sizeof(test_iv)];\\r\\nunsigned char cleartext[64], ciphertext[64];\\r\\nsize_t tail;\\r\\nprintf(\"vector_%d\\n\", len);\\r\\nfflush(stdout);\\r\\nif ((tail = len % 16) == 0)\\r\\ntail = 16;\\r\\ntail += 16;\\r\\nmemcpy(iv, test_iv, sizeof(test_iv));\\r\\nCRYPTO_cts128_encrypt_block(test_input, ciphertext, len, &encks, iv,\\r\\n(block128_f) AES_encrypt);\\r\\nif (memcmp(ciphertext, vector, len))\\r\\nfprintf(stderr, \"output_%d mismatch\\n\", len), exit(1);\\r\\nif (memcmp(iv, vector + len - tail, sizeof(iv)))\\r\\nfprintf(stderr, \"iv_%d mismatch\\n\", len), exit(1);\\r\\nmemcpy(iv, test_iv, sizeof(test_iv));\\r\\nCRYPTO_cts128_decrypt_block(ciphertext, cleartext, len, &decks, iv,\\r\\n(block128_f) AES_decrypt);\\r\\nif (memcmp(cleartext, test_input, len))\\r\\nfprintf(stderr, \"input_%d mismatch\\n\", len), exit(2);\\r\\nif (memcmp(iv, vector + len - tail, sizeof(iv)))\\r\\nfprintf(stderr, \"iv_%d mismatch\\n\", len), exit(2);\\r\\nmemcpy(iv, test_iv, sizeof(test_iv));\\r\\nCRYPTO_cts128_encrypt(test_input, ciphertext, len, &encks, iv,\\r\\n(cbc128_f) AES_cbc_encrypt);\\r\\nif (memcmp(ciphertext, vector, len))\\r\\nfprintf(stderr, \"output_%d mismatch\\n\", len), exit(3);\\r\\nif (memcmp(iv, vector + len - tail, sizeof(iv)))\\r\\nfprintf(stderr, \"iv_%d mismatch\\n\", len), exit(3);\\r\\nmemcpy(iv, test_iv, sizeof(test_iv));\\r\\nCRYPTO_cts128_decrypt(ciphertext, cleartext, len, &decks, iv,\\r\\n(cbc128_f) AES_cbc_encrypt);\\r\\nif (memcmp(cleartext, test_input, len))\\r\\nfprintf(stderr, \"input_%d mismatch\\n\", len), exit(4);\\r\\nif (memcmp(iv, vector + len - tail, sizeof(iv)))\\r\\nfprintf(stderr, \"iv_%d mismatch\\n\", len), exit(4);\\r\\n}\\r\\nvoid test_nistvector(const unsigned char *vector, size_t len)\\r\\n{\\r\\nunsigned char iv[sizeof(test_iv)];\\r\\nunsigned char cleartext[64], ciphertext[64], nistvector[64];\\r\\nsize_t tail;\\r\\nprintf(\"nistvector_%d\\n\", len);\\r\\nfflush(stdout);\\r\\nif ((tail = len % 16) == 0)\\r\\ntail = 16;\\r\\nlen -= 16 + tail;\\r\\nmemcpy(nistvector, vector, len);\\r\\nmemcpy(nistvector + len, vector + len + 16, tail);\\r\\nmemcpy(nistvector + len + tail, vector + len, 16);\\r\\nlen += 16 + tail;\\r\\ntail = 16;\\r\\nmemcpy(iv, test_iv, sizeof(test_iv));\\r\\nCRYPTO_nistcts128_encrypt_block(test_input, ciphertext, len, &encks, iv,\\r\\n(block128_f) AES_encrypt);\\r\\nif (memcmp(ciphertext, nistvector, len))\\r\\nfprintf(stderr, \"output_%d mismatch\\n\", len), exit(1);\\r\\nif (memcmp(iv, nistvector + len - tail, sizeof(iv)))\\r\\nfprintf(stderr, \"iv_%d mismatch\\n\", len), exit(1);\\r\\nmemcpy(iv, test_iv, sizeof(test_iv));\\r\\nCRYPTO_nistcts128_decrypt_block(ciphertext, cleartext, len, &decks, iv,\\r\\n(block128_f) AES_decrypt);\\r\\nif (memcmp(cleartext, test_input, len))\\r\\nfprintf(stderr, \"input_%d mismatch\\n\", len), exit(2);\\r\\nif (memcmp(iv, nistvector + len - tail, sizeof(iv)))\\r\\nfprintf(stderr, \"iv_%d mismatch\\n\", len), exit(2);\\r\\nmemcpy(iv, test_iv, sizeof(test_iv));\\r\\nCRYPTO_nistcts128_encrypt(test_input, ciphertext, len, &encks, iv,\\r\\n(cbc128_f) AES_cbc_encrypt);\\r\\nif (memcmp(ciphertext, nistvector, len))\\r\\nfprintf(stderr, \"output_%d mismatch\\n\", len), exit(3);\\r\\nif (memcmp(iv, nistvector + len - tail, sizeof(iv)))\\r\\nfprintf(stderr, \"iv_%d mismatch\\n\", len), exit(3);\\r\\nmemcpy(iv, test_iv, sizeof(test_iv));\\r\\nCRYPTO_nistcts128_decrypt(ciphertext, cleartext, len, &decks, iv,\\r\\n(cbc128_f) AES_cbc_encrypt);\\r\\nif (memcmp(cleartext, test_input, len))\\r\\nfprintf(stderr, \"input_%d mismatch\\n\", len), exit(4);\\r\\nif (memcmp(iv, nistvector + len - tail, sizeof(iv)))\\r\\nfprintf(stderr, \"iv_%d mismatch\\n\", len), exit(4);\\r\\n}\\r\\nint main()\\r\\n{\\r\\nAES_set_encrypt_key(test_key, 128, &encks);\\r\\nAES_set_decrypt_key(test_key, 128, &decks);\\r\\ntest_vector(vector_17, sizeof(vector_17));\\r\\ntest_vector(vector_31, sizeof(vector_31));\\r\\ntest_vector(vector_32, sizeof(vector_32));\\r\\ntest_vector(vector_47, sizeof(vector_47));\\r\\ntest_vector(vector_48, sizeof(vector_48));\\r\\ntest_vector(vector_64, sizeof(vector_64));\\r\\ntest_nistvector(vector_17, sizeof(vector_17));\\r\\ntest_nistvector(vector_31, sizeof(vector_31));\\r\\ntest_nistvector(vector_32, sizeof(vector_32));\\r\\ntest_nistvector(vector_47, sizeof(vector_47));\\r\\ntest_nistvector(vector_48, sizeof(vector_48));\\r\\ntest_nistvector(vector_64, sizeof(vector_64));\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_conf_mall_c", "target": 0, "func": "void OPENSSL_load_builtin_modules(void)\\r\\n{\\r\\nASN1_add_oid_module();\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nENGINE_add_conf_module();\\r\\n#endif\\r\\nEVP_add_alg_module();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_lib_c", "target": 0, "func": "void BN_set_params(int mult, int high, int low, int mont)\\r\\n{\\r\\nif (mult >= 0) {\\r\\nif (mult > (int)(sizeof(int) * 8) - 1)\\r\\nmult = sizeof(int) * 8 - 1;\\r\\nbn_limit_bits = mult;\\r\\nbn_limit_num = 1 << mult;\\r\\n}\\r\\nif (high >= 0) {\\r\\nif (high > (int)(sizeof(int) * 8) - 1)\\r\\nhigh = sizeof(int) * 8 - 1;\\r\\nbn_limit_bits_high = high;\\r\\nbn_limit_num_high = 1 << high;\\r\\n}\\r\\nif (low >= 0) {\\r\\nif (low > (int)(sizeof(int) * 8) - 1)\\r\\nlow = sizeof(int) * 8 - 1;\\r\\nbn_limit_bits_low = low;\\r\\nbn_limit_num_low = 1 << low;\\r\\n}\\r\\nif (mont >= 0) {\\r\\nif (mont > (int)(sizeof(int) * 8) - 1)\\r\\nmont = sizeof(int) * 8 - 1;\\r\\nbn_limit_bits_mont = mont;\\r\\nbn_limit_num_mont = 1 << mont;\\r\\n}\\r\\n}\\r\\nint BN_get_params(int which)\\r\\n{\\r\\nif (which == 0)\\r\\nreturn (bn_limit_bits);\\r\\nelse if (which == 1)\\r\\nreturn (bn_limit_bits_high);\\r\\nelse if (which == 2)\\r\\nreturn (bn_limit_bits_low);\\r\\nelse if (which == 3)\\r\\nreturn (bn_limit_bits_mont);\\r\\nelse\\r\\nreturn (0);\\r\\n}\\r\\nconst BIGNUM *BN_value_one(void)\\r\\n{\\r\\nstatic const BN_ULONG data_one = 1L;\\r\\nstatic const BIGNUM const_one =\\r\\n{ (BN_ULONG *)&data_one, 1, 1, 0, BN_FLG_STATIC_DATA };\\r\\nreturn (&const_one);\\r\\n}\\r\\nint BN_num_bits_word(BN_ULONG l)\\r\\n{\\r\\nstatic const unsigned char bits[256] = {\\r\\n0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\\r\\n5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\\r\\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\r\\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\\r\\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\\r\\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\\r\\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\\r\\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\\r\\n8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\\r\\n8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\\r\\n8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\\r\\n8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\\r\\n8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\\r\\n8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\\r\\n8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\\r\\n8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\\r\\n};\\r\\n#if defined(SIXTY_FOUR_BIT_LONG)\\r\\nif (l & 0xffffffff00000000L) {\\r\\nif (l & 0xffff000000000000L) {\\r\\nif (l & 0xff00000000000000L) {\\r\\nreturn (bits[(int)(l >> 56)] + 56);\\r\\n} else\\r\\nreturn (bits[(int)(l >> 48)] + 48);\\r\\n} else {\\r\\nif (l & 0x0000ff0000000000L) {\\r\\nreturn (bits[(int)(l >> 40)] + 40);\\r\\n} else\\r\\nreturn (bits[(int)(l >> 32)] + 32);\\r\\n}\\r\\n} else\\r\\n#else\\r\\n# ifdef SIXTY_FOUR_BIT\\r\\nif (l & 0xffffffff00000000LL) {\\r\\nif (l & 0xffff000000000000LL) {\\r\\nif (l & 0xff00000000000000LL) {\\r\\nreturn (bits[(int)(l >> 56)] + 56);\\r\\n} else\\r\\nreturn (bits[(int)(l >> 48)] + 48);\\r\\n} else {\\r\\nif (l & 0x0000ff0000000000LL) {\\r\\nreturn (bits[(int)(l >> 40)] + 40);\\r\\n} else\\r\\nreturn (bits[(int)(l >> 32)] + 32);\\r\\n}\\r\\n} else\\r\\n# endif\\r\\n#endif\\r\\n{\\r\\n#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\\r\\nif (l & 0xffff0000L) {\\r\\nif (l & 0xff000000L)\\r\\nreturn (bits[(int)(l >> 24L)] + 24);\\r\\nelse\\r\\nreturn (bits[(int)(l >> 16L)] + 16);\\r\\n} else\\r\\n#endif\\r\\n{\\r\\n#if defined(THIRTY_TWO_BIT) || defined(SIXTY_FOUR_BIT) || defined(SIXTY_FOUR_BIT_LONG)\\r\\nif (l & 0xff00L)\\r\\nreturn (bits[(int)(l >> 8)] + 8);\\r\\nelse\\r\\n#endif\\r\\nreturn (bits[(int)(l)]);\\r\\n}\\r\\n}\\r\\n}\\r\\nint BN_num_bits(const BIGNUM *a)\\r\\n{\\r\\nint i = a->top - 1;\\r\\nbn_check_top(a);\\r\\nif (BN_is_zero(a))\\r\\nreturn 0;\\r\\nreturn ((i * BN_BITS2) + BN_num_bits_word(a->d[i]));\\r\\n}\\r\\nvoid BN_clear_free(BIGNUM *a)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL)\\r\\nreturn;\\r\\nbn_check_top(a);\\r\\nif (a->d != NULL) {\\r\\nOPENSSL_cleanse(a->d, a->dmax * sizeof(a->d[0]));\\r\\nif (!(BN_get_flags(a, BN_FLG_STATIC_DATA)))\\r\\nOPENSSL_free(a->d);\\r\\n}\\r\\ni = BN_get_flags(a, BN_FLG_MALLOCED);\\r\\nOPENSSL_cleanse(a, sizeof(BIGNUM));\\r\\nif (i)\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nvoid BN_free(BIGNUM *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn;\\r\\nbn_check_top(a);\\r\\nif ((a->d != NULL) && !(BN_get_flags(a, BN_FLG_STATIC_DATA)))\\r\\nOPENSSL_free(a->d);\\r\\nif (a->flags & BN_FLG_MALLOCED)\\r\\nOPENSSL_free(a);\\r\\nelse {\\r\\n#ifndef OPENSSL_NO_DEPRECATED\\r\\na->flags |= BN_FLG_FREE;\\r\\n#endif\\r\\na->d = NULL;\\r\\n}\\r\\n}\\r\\nvoid BN_init(BIGNUM *a)\\r\\n{\\r\\nmemset(a, 0, sizeof(BIGNUM));\\r\\nbn_check_top(a);\\r\\n}\\r\\nBIGNUM *BN_new(void)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nif ((ret = (BIGNUM *)OPENSSL_malloc(sizeof(BIGNUM))) == NULL) {\\r\\nBNerr(BN_F_BN_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nret->flags = BN_FLG_MALLOCED;\\r\\nret->top = 0;\\r\\nret->neg = 0;\\r\\nret->dmax = 0;\\r\\nret->d = NULL;\\r\\nbn_check_top(ret);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)\\r\\n{\\r\\nBN_ULONG *A, *a = NULL;\\r\\nconst BN_ULONG *B;\\r\\nint i;\\r\\nbn_check_top(b);\\r\\nif (words > (INT_MAX / (4 * BN_BITS2))) {\\r\\nBNerr(BN_F_BN_EXPAND_INTERNAL, BN_R_BIGNUM_TOO_LONG);\\r\\nreturn NULL;\\r\\n}\\r\\nif (BN_get_flags(b, BN_FLG_STATIC_DATA)) {\\r\\nBNerr(BN_F_BN_EXPAND_INTERNAL, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);\\r\\nreturn (NULL);\\r\\n}\\r\\na = A = (BN_ULONG *)OPENSSL_malloc(sizeof(BN_ULONG) * words);\\r\\nif (A == NULL) {\\r\\nBNerr(BN_F_BN_EXPAND_INTERNAL, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\n#ifdef PURIFY\\r\\nmemset(a, 0, sizeof(BN_ULONG) * words);\\r\\n#endif\\r\\n#if 1\\r\\nB = b->d;\\r\\nif (B != NULL) {\\r\\nfor (i = b->top >> 2; i > 0; i--, A += 4, B += 4) {\\r\\nBN_ULONG a0, a1, a2, a3;\\r\\na0 = B[0];\\r\\na1 = B[1];\\r\\na2 = B[2];\\r\\na3 = B[3];\\r\\nA[0] = a0;\\r\\nA[1] = a1;\\r\\nA[2] = a2;\\r\\nA[3] = a3;\\r\\n}\\r\\nswitch (b->top & 3) {\\r\\ncase 3:\\r\\nA[2] = B[2];\\r\\ncase 2:\\r\\nA[1] = B[1];\\r\\ncase 1:\\r\\nA[0] = B[0];\\r\\ncase 0:\\r\\n;\\r\\n}\\r\\n}\\r\\n#else\\r\\nmemset(A, 0, sizeof(BN_ULONG) * words);\\r\\nmemcpy(A, b->d, sizeof(b->d[0]) * b->top);\\r\\n#endif\\r\\nreturn (a);\\r\\n}\\r\\nBIGNUM *bn_dup_expand(const BIGNUM *b, int words)\\r\\n{\\r\\nBIGNUM *r = NULL;\\r\\nbn_check_top(b);\\r\\nif (words > b->dmax) {\\r\\nBN_ULONG *a = bn_expand_internal(b, words);\\r\\nif (a) {\\r\\nr = BN_new();\\r\\nif (r) {\\r\\nr->top = b->top;\\r\\nr->dmax = words;\\r\\nr->neg = b->neg;\\r\\nr->d = a;\\r\\n} else {\\r\\nOPENSSL_free(a);\\r\\n}\\r\\n}\\r\\n} else {\\r\\nr = BN_dup(b);\\r\\n}\\r\\nbn_check_top(r);\\r\\nreturn r;\\r\\n}\\r\\nBIGNUM *bn_expand2(BIGNUM *b, int words)\\r\\n{\\r\\nbn_check_top(b);\\r\\nif (words > b->dmax) {\\r\\nBN_ULONG *a = bn_expand_internal(b, words);\\r\\nif (!a)\\r\\nreturn NULL;\\r\\nif (b->d)\\r\\nOPENSSL_free(b->d);\\r\\nb->d = a;\\r\\nb->dmax = words;\\r\\n}\\r\\n#if 0\\r\\nif (b->top < b->dmax) {\\r\\nint i;\\r\\nBN_ULONG *A = &(b->d[b->top]);\\r\\nfor (i = (b->dmax - b->top) >> 3; i > 0; i--, A += 8) {\\r\\nA[0] = 0;\\r\\nA[1] = 0;\\r\\nA[2] = 0;\\r\\nA[3] = 0;\\r\\nA[4] = 0;\\r\\nA[5] = 0;\\r\\nA[6] = 0;\\r\\nA[7] = 0;\\r\\n}\\r\\nfor (i = (b->dmax - b->top) & 7; i > 0; i--, A++)\\r\\nA[0] = 0;\\r\\nassert(A == &(b->d[b->dmax]));\\r\\n}\\r\\n#endif\\r\\nbn_check_top(b);\\r\\nreturn b;\\r\\n}\\r\\nBIGNUM *BN_dup(const BIGNUM *a)\\r\\n{\\r\\nBIGNUM *t;\\r\\nif (a == NULL)\\r\\nreturn NULL;\\r\\nbn_check_top(a);\\r\\nt = BN_new();\\r\\nif (t == NULL)\\r\\nreturn NULL;\\r\\nif (!BN_copy(t, a)) {\\r\\nBN_free(t);\\r\\nreturn NULL;\\r\\n}\\r\\nbn_check_top(t);\\r\\nreturn t;\\r\\n}\\r\\nBIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG *A;\\r\\nconst BN_ULONG *B;\\r\\nbn_check_top(b);\\r\\nif (a == b)\\r\\nreturn (a);\\r\\nif (bn_wexpand(a, b->top) == NULL)\\r\\nreturn (NULL);\\r\\n#if 1\\r\\nA = a->d;\\r\\nB = b->d;\\r\\nfor (i = b->top >> 2; i > 0; i--, A += 4, B += 4) {\\r\\nBN_ULONG a0, a1, a2, a3;\\r\\na0 = B[0];\\r\\na1 = B[1];\\r\\na2 = B[2];\\r\\na3 = B[3];\\r\\nA[0] = a0;\\r\\nA[1] = a1;\\r\\nA[2] = a2;\\r\\nA[3] = a3;\\r\\n}\\r\\nswitch (b->top & 3) {\\r\\ncase 3:\\r\\nA[2] = B[2];\\r\\ncase 2:\\r\\nA[1] = B[1];\\r\\ncase 1:\\r\\nA[0] = B[0];\\r\\ncase 0:;\\r\\n}\\r\\n#else\\r\\nmemcpy(a->d, b->d, sizeof(b->d[0]) * b->top);\\r\\n#endif\\r\\na->top = b->top;\\r\\na->neg = b->neg;\\r\\nbn_check_top(a);\\r\\nreturn (a);\\r\\n}\\r\\nvoid BN_swap(BIGNUM *a, BIGNUM *b)\\r\\n{\\r\\nint flags_old_a, flags_old_b;\\r\\nBN_ULONG *tmp_d;\\r\\nint tmp_top, tmp_dmax, tmp_neg;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nflags_old_a = a->flags;\\r\\nflags_old_b = b->flags;\\r\\ntmp_d = a->d;\\r\\ntmp_top = a->top;\\r\\ntmp_dmax = a->dmax;\\r\\ntmp_neg = a->neg;\\r\\na->d = b->d;\\r\\na->top = b->top;\\r\\na->dmax = b->dmax;\\r\\na->neg = b->neg;\\r\\nb->d = tmp_d;\\r\\nb->top = tmp_top;\\r\\nb->dmax = tmp_dmax;\\r\\nb->neg = tmp_neg;\\r\\na->flags =\\r\\n(flags_old_a & BN_FLG_MALLOCED) | (flags_old_b & BN_FLG_STATIC_DATA);\\r\\nb->flags =\\r\\n(flags_old_b & BN_FLG_MALLOCED) | (flags_old_a & BN_FLG_STATIC_DATA);\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\n}\\r\\nvoid BN_clear(BIGNUM *a)\\r\\n{\\r\\nbn_check_top(a);\\r\\nif (a->d != NULL)\\r\\nmemset(a->d, 0, a->dmax * sizeof(a->d[0]));\\r\\na->top = 0;\\r\\na->neg = 0;\\r\\n}\\r\\nBN_ULONG BN_get_word(const BIGNUM *a)\\r\\n{\\r\\nif (a->top > 1)\\r\\nreturn BN_MASK2;\\r\\nelse if (a->top == 1)\\r\\nreturn a->d[0];\\r\\nreturn 0;\\r\\n}\\r\\nint BN_set_word(BIGNUM *a, BN_ULONG w)\\r\\n{\\r\\nbn_check_top(a);\\r\\nif (bn_expand(a, (int)sizeof(BN_ULONG) * 8) == NULL)\\r\\nreturn (0);\\r\\na->neg = 0;\\r\\na->d[0] = w;\\r\\na->top = (w ? 1 : 0);\\r\\nbn_check_top(a);\\r\\nreturn (1);\\r\\n}\\r\\nBIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret)\\r\\n{\\r\\nunsigned int i, m;\\r\\nunsigned int n;\\r\\nBN_ULONG l;\\r\\nBIGNUM *bn = NULL;\\r\\nif (ret == NULL)\\r\\nret = bn = BN_new();\\r\\nif (ret == NULL)\\r\\nreturn (NULL);\\r\\nbn_check_top(ret);\\r\\nl = 0;\\r\\nn = len;\\r\\nif (n == 0) {\\r\\nret->top = 0;\\r\\nreturn (ret);\\r\\n}\\r\\ni = ((n - 1) / BN_BYTES) + 1;\\r\\nm = ((n - 1) % (BN_BYTES));\\r\\nif (bn_wexpand(ret, (int)i) == NULL) {\\r\\nif (bn)\\r\\nBN_free(bn);\\r\\nreturn NULL;\\r\\n}\\r\\nret->top = i;\\r\\nret->neg = 0;\\r\\nwhile (n--) {\\r\\nl = (l << 8L) | *(s++);\\r\\nif (m-- == 0) {\\r\\nret->d[--i] = l;\\r\\nl = 0;\\r\\nm = BN_BYTES - 1;\\r\\n}\\r\\n}\\r\\nbn_correct_top(ret);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_bn2bin(const BIGNUM *a, unsigned char *to)\\r\\n{\\r\\nint n, i;\\r\\nBN_ULONG l;\\r\\nbn_check_top(a);\\r\\nn = i = BN_num_bytes(a);\\r\\nwhile (i--) {\\r\\nl = a->d[i / BN_BYTES];\\r\\n*(to++) = (unsigned char)(l >> (8 * (i % BN_BYTES))) & 0xff;\\r\\n}\\r\\nreturn (n);\\r\\n}\\r\\nint BN_ucmp(const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG t1, t2, *ap, *bp;\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\ni = a->top - b->top;\\r\\nif (i != 0)\\r\\nreturn (i);\\r\\nap = a->d;\\r\\nbp = b->d;\\r\\nfor (i = a->top - 1; i >= 0; i--) {\\r\\nt1 = ap[i];\\r\\nt2 = bp[i];\\r\\nif (t1 != t2)\\r\\nreturn ((t1 > t2) ? 1 : -1);\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nint BN_cmp(const BIGNUM *a, const BIGNUM *b)\\r\\n{\\r\\nint i;\\r\\nint gt, lt;\\r\\nBN_ULONG t1, t2;\\r\\nif ((a == NULL) || (b == NULL)) {\\r\\nif (a != NULL)\\r\\nreturn (-1);\\r\\nelse if (b != NULL)\\r\\nreturn (1);\\r\\nelse\\r\\nreturn (0);\\r\\n}\\r\\nbn_check_top(a);\\r\\nbn_check_top(b);\\r\\nif (a->neg != b->neg) {\\r\\nif (a->neg)\\r\\nreturn (-1);\\r\\nelse\\r\\nreturn (1);\\r\\n}\\r\\nif (a->neg == 0) {\\r\\ngt = 1;\\r\\nlt = -1;\\r\\n} else {\\r\\ngt = -1;\\r\\nlt = 1;\\r\\n}\\r\\nif (a->top > b->top)\\r\\nreturn (gt);\\r\\nif (a->top < b->top)\\r\\nreturn (lt);\\r\\nfor (i = a->top - 1; i >= 0; i--) {\\r\\nt1 = a->d[i];\\r\\nt2 = b->d[i];\\r\\nif (t1 > t2)\\r\\nreturn (gt);\\r\\nif (t1 < t2)\\r\\nreturn (lt);\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nint BN_set_bit(BIGNUM *a, int n)\\r\\n{\\r\\nint i, j, k;\\r\\nif (n < 0)\\r\\nreturn 0;\\r\\ni = n / BN_BITS2;\\r\\nj = n % BN_BITS2;\\r\\nif (a->top <= i) {\\r\\nif (bn_wexpand(a, i + 1) == NULL)\\r\\nreturn (0);\\r\\nfor (k = a->top; k < i + 1; k++)\\r\\na->d[k] = 0;\\r\\na->top = i + 1;\\r\\n}\\r\\na->d[i] |= (((BN_ULONG)1) << j);\\r\\nbn_check_top(a);\\r\\nreturn (1);\\r\\n}\\r\\nint BN_clear_bit(BIGNUM *a, int n)\\r\\n{\\r\\nint i, j;\\r\\nbn_check_top(a);\\r\\nif (n < 0)\\r\\nreturn 0;\\r\\ni = n / BN_BITS2;\\r\\nj = n % BN_BITS2;\\r\\nif (a->top <= i)\\r\\nreturn (0);\\r\\na->d[i] &= (~(((BN_ULONG)1) << j));\\r\\nbn_correct_top(a);\\r\\nreturn (1);\\r\\n}\\r\\nint BN_is_bit_set(const BIGNUM *a, int n)\\r\\n{\\r\\nint i, j;\\r\\nbn_check_top(a);\\r\\nif (n < 0)\\r\\nreturn 0;\\r\\ni = n / BN_BITS2;\\r\\nj = n % BN_BITS2;\\r\\nif (a->top <= i)\\r\\nreturn 0;\\r\\nreturn (int)(((a->d[i]) >> j) & ((BN_ULONG)1));\\r\\n}\\r\\nint BN_mask_bits(BIGNUM *a, int n)\\r\\n{\\r\\nint b, w;\\r\\nbn_check_top(a);\\r\\nif (n < 0)\\r\\nreturn 0;\\r\\nw = n / BN_BITS2;\\r\\nb = n % BN_BITS2;\\r\\nif (w >= a->top)\\r\\nreturn 0;\\r\\nif (b == 0)\\r\\na->top = w;\\r\\nelse {\\r\\na->top = w + 1;\\r\\na->d[w] &= ~(BN_MASK2 << b);\\r\\n}\\r\\nbn_correct_top(a);\\r\\nreturn (1);\\r\\n}\\r\\nvoid BN_set_negative(BIGNUM *a, int b)\\r\\n{\\r\\nif (b && !BN_is_zero(a))\\r\\na->neg = 1;\\r\\nelse\\r\\na->neg = 0;\\r\\n}\\r\\nint bn_cmp_words(const BN_ULONG *a, const BN_ULONG *b, int n)\\r\\n{\\r\\nint i;\\r\\nBN_ULONG aa, bb;\\r\\naa = a[n - 1];\\r\\nbb = b[n - 1];\\r\\nif (aa != bb)\\r\\nreturn ((aa > bb) ? 1 : -1);\\r\\nfor (i = n - 2; i >= 0; i--) {\\r\\naa = a[i];\\r\\nbb = b[i];\\r\\nif (aa != bb)\\r\\nreturn ((aa > bb) ? 1 : -1);\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nint bn_cmp_part_words(const BN_ULONG *a, const BN_ULONG *b, int cl, int dl)\\r\\n{\\r\\nint n, i;\\r\\nn = cl - 1;\\r\\nif (dl < 0) {\\r\\nfor (i = dl; i < 0; i++) {\\r\\nif (b[n - i] != 0)\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif (dl > 0) {\\r\\nfor (i = dl; i > 0; i--) {\\r\\nif (a[n + i] != 0)\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nreturn bn_cmp_words(a, b, cl);\\r\\n}\\r\\nvoid BN_consttime_swap(BN_ULONG condition, BIGNUM *a, BIGNUM *b, int nwords)\\r\\n{\\r\\nBN_ULONG t;\\r\\nint i;\\r\\nbn_wcheck_size(a, nwords);\\r\\nbn_wcheck_size(b, nwords);\\r\\nassert(a != b);\\r\\nassert((condition & (condition - 1)) == 0);\\r\\nassert(sizeof(BN_ULONG) >= sizeof(int));\\r\\ncondition = ((condition - 1) >> (BN_BITS2 - 1)) - 1;\\r\\nt = (a->top ^ b->top) & condition;\\r\\na->top ^= t;\\r\\nb->top ^= t;\\r\\n#define BN_CONSTTIME_SWAP(ind) \\\\r\\ndo { \\\\r\\nt = (a->d[ind] ^ b->d[ind]) & condition; \\\\r\\na->d[ind] ^= t; \\\\r\\nb->d[ind] ^= t; \\\\r\\n} while (0)\\r\\nswitch (nwords) {\\r\\ndefault:\\r\\nfor (i = 10; i < nwords; i++)\\r\\nBN_CONSTTIME_SWAP(i);\\r\\ncase 10:\\r\\nBN_CONSTTIME_SWAP(9);\\r\\ncase 9:\\r\\nBN_CONSTTIME_SWAP(8);\\r\\ncase 8:\\r\\nBN_CONSTTIME_SWAP(7);\\r\\ncase 7:\\r\\nBN_CONSTTIME_SWAP(6);\\r\\ncase 6:\\r\\nBN_CONSTTIME_SWAP(5);\\r\\ncase 5:\\r\\nBN_CONSTTIME_SWAP(4);\\r\\ncase 4:\\r\\nBN_CONSTTIME_SWAP(3);\\r\\ncase 3:\\r\\nBN_CONSTTIME_SWAP(2);\\r\\ncase 2:\\r\\nBN_CONSTTIME_SWAP(1);\\r\\ncase 1:\\r\\nBN_CONSTTIME_SWAP(0);\\r\\n}\\r\\n#undef BN_CONSTTIME_SWAP\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_aes_core_c", "target": 0, "func": "int private_AES_set_encrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key)\\r\\n{\\r\\nu32 *rk;\\r\\nint i = 0;\\r\\nu32 temp;\\r\\nif (!userKey || !key)\\r\\nreturn -1;\\r\\nif (bits != 128 && bits != 192 && bits != 256)\\r\\nreturn -2;\\r\\nrk = key->rd_key;\\r\\nif (bits==128)\\r\\nkey->rounds = 10;\\r\\nelse if (bits==192)\\r\\nkey->rounds = 12;\\r\\nelse\\r\\nkey->rounds = 14;\\r\\nrk[0] = GETU32(userKey );\\r\\nrk[1] = GETU32(userKey + 4);\\r\\nrk[2] = GETU32(userKey + 8);\\r\\nrk[3] = GETU32(userKey + 12);\\r\\nif (bits == 128) {\\r\\nwhile (1) {\\r\\ntemp = rk[3];\\r\\nrk[4] = rk[0] ^\\r\\n(Te2[(temp >> 16) & 0xff] & 0xff000000) ^\\r\\n(Te3[(temp >> 8) & 0xff] & 0x00ff0000) ^\\r\\n(Te0[(temp ) & 0xff] & 0x0000ff00) ^\\r\\n(Te1[(temp >> 24) ] & 0x000000ff) ^\\r\\nrcon[i];\\r\\nrk[5] = rk[1] ^ rk[4];\\r\\nrk[6] = rk[2] ^ rk[5];\\r\\nrk[7] = rk[3] ^ rk[6];\\r\\nif (++i == 10) {\\r\\nreturn 0;\\r\\n}\\r\\nrk += 4;\\r\\n}\\r\\n}\\r\\nrk[4] = GETU32(userKey + 16);\\r\\nrk[5] = GETU32(userKey + 20);\\r\\nif (bits == 192) {\\r\\nwhile (1) {\\r\\ntemp = rk[ 5];\\r\\nrk[ 6] = rk[ 0] ^\\r\\n(Te2[(temp >> 16) & 0xff] & 0xff000000) ^\\r\\n(Te3[(temp >> 8) & 0xff] & 0x00ff0000) ^\\r\\n(Te0[(temp ) & 0xff] & 0x0000ff00) ^\\r\\n(Te1[(temp >> 24) ] & 0x000000ff) ^\\r\\nrcon[i];\\r\\nrk[ 7] = rk[ 1] ^ rk[ 6];\\r\\nrk[ 8] = rk[ 2] ^ rk[ 7];\\r\\nrk[ 9] = rk[ 3] ^ rk[ 8];\\r\\nif (++i == 8) {\\r\\nreturn 0;\\r\\n}\\r\\nrk[10] = rk[ 4] ^ rk[ 9];\\r\\nrk[11] = rk[ 5] ^ rk[10];\\r\\nrk += 6;\\r\\n}\\r\\n}\\r\\nrk[6] = GETU32(userKey + 24);\\r\\nrk[7] = GETU32(userKey + 28);\\r\\nif (bits == 256) {\\r\\nwhile (1) {\\r\\ntemp = rk[ 7];\\r\\nrk[ 8] = rk[ 0] ^\\r\\n(Te2[(temp >> 16) & 0xff] & 0xff000000) ^\\r\\n(Te3[(temp >> 8) & 0xff] & 0x00ff0000) ^\\r\\n(Te0[(temp ) & 0xff] & 0x0000ff00) ^\\r\\n(Te1[(temp >> 24) ] & 0x000000ff) ^\\r\\nrcon[i];\\r\\nrk[ 9] = rk[ 1] ^ rk[ 8];\\r\\nrk[10] = rk[ 2] ^ rk[ 9];\\r\\nrk[11] = rk[ 3] ^ rk[10];\\r\\nif (++i == 7) {\\r\\nreturn 0;\\r\\n}\\r\\ntemp = rk[11];\\r\\nrk[12] = rk[ 4] ^\\r\\n(Te2[(temp >> 24) ] & 0xff000000) ^\\r\\n(Te3[(temp >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te0[(temp >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te1[(temp ) & 0xff] & 0x000000ff);\\r\\nrk[13] = rk[ 5] ^ rk[12];\\r\\nrk[14] = rk[ 6] ^ rk[13];\\r\\nrk[15] = rk[ 7] ^ rk[14];\\r\\nrk += 8;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint private_AES_set_decrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key)\\r\\n{\\r\\nu32 *rk;\\r\\nint i, j, status;\\r\\nu32 temp;\\r\\nstatus = private_AES_set_encrypt_key(userKey, bits, key);\\r\\nif (status < 0)\\r\\nreturn status;\\r\\nrk = key->rd_key;\\r\\nfor (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\\r\\ntemp = rk[i ]; rk[i ] = rk[j ]; rk[j ] = temp;\\r\\ntemp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\\r\\ntemp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\\r\\ntemp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\\r\\n}\\r\\nfor (i = 1; i < (key->rounds); i++) {\\r\\nrk += 4;\\r\\nrk[0] =\\r\\nTd0[Te1[(rk[0] >> 24) ] & 0xff] ^\\r\\nTd1[Te1[(rk[0] >> 16) & 0xff] & 0xff] ^\\r\\nTd2[Te1[(rk[0] >> 8) & 0xff] & 0xff] ^\\r\\nTd3[Te1[(rk[0] ) & 0xff] & 0xff];\\r\\nrk[1] =\\r\\nTd0[Te1[(rk[1] >> 24) ] & 0xff] ^\\r\\nTd1[Te1[(rk[1] >> 16) & 0xff] & 0xff] ^\\r\\nTd2[Te1[(rk[1] >> 8) & 0xff] & 0xff] ^\\r\\nTd3[Te1[(rk[1] ) & 0xff] & 0xff];\\r\\nrk[2] =\\r\\nTd0[Te1[(rk[2] >> 24) ] & 0xff] ^\\r\\nTd1[Te1[(rk[2] >> 16) & 0xff] & 0xff] ^\\r\\nTd2[Te1[(rk[2] >> 8) & 0xff] & 0xff] ^\\r\\nTd3[Te1[(rk[2] ) & 0xff] & 0xff];\\r\\nrk[3] =\\r\\nTd0[Te1[(rk[3] >> 24) ] & 0xff] ^\\r\\nTd1[Te1[(rk[3] >> 16) & 0xff] & 0xff] ^\\r\\nTd2[Te1[(rk[3] >> 8) & 0xff] & 0xff] ^\\r\\nTd3[Te1[(rk[3] ) & 0xff] & 0xff];\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nvoid AES_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst AES_KEY *key) {\\r\\nconst u32 *rk;\\r\\nu32 s0, s1, s2, s3, t0, t1, t2, t3;\\r\\n#ifndef FULL_UNROLL\\r\\nint r;\\r\\n#endif\\r\\nassert(in && out && key);\\r\\nrk = key->rd_key;\\r\\ns0 = GETU32(in ) ^ rk[0];\\r\\ns1 = GETU32(in + 4) ^ rk[1];\\r\\ns2 = GETU32(in + 8) ^ rk[2];\\r\\ns3 = GETU32(in + 12) ^ rk[3];\\r\\n#ifdef FULL_UNROLL\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[ 4];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[ 5];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[ 6];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[ 7];\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[ 8];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[ 9];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[12];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[13];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[14];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[15];\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[16];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[17];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[18];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[19];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[20];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[21];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[22];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[23];\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[24];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[25];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[26];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[27];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[28];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[29];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[30];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[31];\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[32];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[33];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[34];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[35];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[36];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[37];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[38];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[39];\\r\\nif (key->rounds > 10) {\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[40];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[41];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[42];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[43];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[44];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[45];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[46];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[47];\\r\\nif (key->rounds > 12) {\\r\\ns0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[48];\\r\\ns1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[49];\\r\\ns2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[50];\\r\\ns3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[51];\\r\\nt0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[52];\\r\\nt1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[53];\\r\\nt2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[54];\\r\\nt3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[55];\\r\\n}\\r\\n}\\r\\nrk += key->rounds << 2;\\r\\n#else\\r\\nr = key->rounds >> 1;\\r\\nfor (;;) {\\r\\nt0 =\\r\\nTe0[(s0 >> 24) ] ^\\r\\nTe1[(s1 >> 16) & 0xff] ^\\r\\nTe2[(s2 >> 8) & 0xff] ^\\r\\nTe3[(s3 ) & 0xff] ^\\r\\nrk[4];\\r\\nt1 =\\r\\nTe0[(s1 >> 24) ] ^\\r\\nTe1[(s2 >> 16) & 0xff] ^\\r\\nTe2[(s3 >> 8) & 0xff] ^\\r\\nTe3[(s0 ) & 0xff] ^\\r\\nrk[5];\\r\\nt2 =\\r\\nTe0[(s2 >> 24) ] ^\\r\\nTe1[(s3 >> 16) & 0xff] ^\\r\\nTe2[(s0 >> 8) & 0xff] ^\\r\\nTe3[(s1 ) & 0xff] ^\\r\\nrk[6];\\r\\nt3 =\\r\\nTe0[(s3 >> 24) ] ^\\r\\nTe1[(s0 >> 16) & 0xff] ^\\r\\nTe2[(s1 >> 8) & 0xff] ^\\r\\nTe3[(s2 ) & 0xff] ^\\r\\nrk[7];\\r\\nrk += 8;\\r\\nif (--r == 0) {\\r\\nbreak;\\r\\n}\\r\\ns0 =\\r\\nTe0[(t0 >> 24) ] ^\\r\\nTe1[(t1 >> 16) & 0xff] ^\\r\\nTe2[(t2 >> 8) & 0xff] ^\\r\\nTe3[(t3 ) & 0xff] ^\\r\\nrk[0];\\r\\ns1 =\\r\\nTe0[(t1 >> 24) ] ^\\r\\nTe1[(t2 >> 16) & 0xff] ^\\r\\nTe2[(t3 >> 8) & 0xff] ^\\r\\nTe3[(t0 ) & 0xff] ^\\r\\nrk[1];\\r\\ns2 =\\r\\nTe0[(t2 >> 24) ] ^\\r\\nTe1[(t3 >> 16) & 0xff] ^\\r\\nTe2[(t0 >> 8) & 0xff] ^\\r\\nTe3[(t1 ) & 0xff] ^\\r\\nrk[2];\\r\\ns3 =\\r\\nTe0[(t3 >> 24) ] ^\\r\\nTe1[(t0 >> 16) & 0xff] ^\\r\\nTe2[(t1 >> 8) & 0xff] ^\\r\\nTe3[(t2 ) & 0xff] ^\\r\\nrk[3];\\r\\n}\\r\\n#endif\\r\\ns0 =\\r\\n(Te2[(t0 >> 24) ] & 0xff000000) ^\\r\\n(Te3[(t1 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te0[(t2 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te1[(t3 ) & 0xff] & 0x000000ff) ^\\r\\nrk[0];\\r\\nPUTU32(out , s0);\\r\\ns1 =\\r\\n(Te2[(t1 >> 24) ] & 0xff000000) ^\\r\\n(Te3[(t2 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te0[(t3 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te1[(t0 ) & 0xff] & 0x000000ff) ^\\r\\nrk[1];\\r\\nPUTU32(out + 4, s1);\\r\\ns2 =\\r\\n(Te2[(t2 >> 24) ] & 0xff000000) ^\\r\\n(Te3[(t3 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te0[(t0 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te1[(t1 ) & 0xff] & 0x000000ff) ^\\r\\nrk[2];\\r\\nPUTU32(out + 8, s2);\\r\\ns3 =\\r\\n(Te2[(t3 >> 24) ] & 0xff000000) ^\\r\\n(Te3[(t0 >> 16) & 0xff] & 0x00ff0000) ^\\r\\n(Te0[(t1 >> 8) & 0xff] & 0x0000ff00) ^\\r\\n(Te1[(t2 ) & 0xff] & 0x000000ff) ^\\r\\nrk[3];\\r\\nPUTU32(out + 12, s3);\\r\\n}\\r\\nvoid AES_decrypt(const unsigned char *in, unsigned char *out,\\r\\nconst AES_KEY *key)\\r\\n{\\r\\nconst u32 *rk;\\r\\nu32 s0, s1, s2, s3, t0, t1, t2, t3;\\r\\n#ifndef FULL_UNROLL\\r\\nint r;\\r\\n#endif\\r\\nassert(in && out && key);\\r\\nrk = key->rd_key;\\r\\ns0 = GETU32(in ) ^ rk[0];\\r\\ns1 = GETU32(in + 4) ^ rk[1];\\r\\ns2 = GETU32(in + 8) ^ rk[2];\\r\\ns3 = GETU32(in + 12) ^ rk[3];\\r\\n#ifdef FULL_UNROLL\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[ 4];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[ 5];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[ 6];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[ 7];\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[ 8];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[ 9];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[10];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[11];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[12];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[13];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[14];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[15];\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[16];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[17];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[18];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[19];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[20];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[21];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[22];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[23];\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[24];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[25];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[26];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[27];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[28];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[29];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[30];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[31];\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[32];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[33];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[34];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[35];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[36];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[37];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[38];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[39];\\r\\nif (key->rounds > 10) {\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[40];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[41];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[42];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[43];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[44];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[45];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[46];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[47];\\r\\nif (key->rounds > 12) {\\r\\ns0 = Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >> 8) & 0xff] ^ Td3[t1 & 0xff] ^ rk[48];\\r\\ns1 = Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >> 8) & 0xff] ^ Td3[t2 & 0xff] ^ rk[49];\\r\\ns2 = Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >> 8) & 0xff] ^ Td3[t3 & 0xff] ^ rk[50];\\r\\ns3 = Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >> 8) & 0xff] ^ Td3[t0 & 0xff] ^ rk[51];\\r\\nt0 = Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >> 8) & 0xff] ^ Td3[s1 & 0xff] ^ rk[52];\\r\\nt1 = Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >> 8) & 0xff] ^ Td3[s2 & 0xff] ^ rk[53];\\r\\nt2 = Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >> 8) & 0xff] ^ Td3[s3 & 0xff] ^ rk[54];\\r\\nt3 = Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >> 8) & 0xff] ^ Td3[s0 & 0xff] ^ rk[55];\\r\\n}\\r\\n}\\r\\nrk += key->rounds << 2;\\r\\n#else\\r\\nr = key->rounds >> 1;\\r\\nfor (;;) {\\r\\nt0 =\\r\\nTd0[(s0 >> 24) ] ^\\r\\nTd1[(s3 >> 16) & 0xff] ^\\r\\nTd2[(s2 >> 8) & 0xff] ^\\r\\nTd3[(s1 ) & 0xff] ^\\r\\nrk[4];\\r\\nt1 =\\r\\nTd0[(s1 >> 24) ] ^\\r\\nTd1[(s0 >> 16) & 0xff] ^\\r\\nTd2[(s3 >> 8) & 0xff] ^\\r\\nTd3[(s2 ) & 0xff] ^\\r\\nrk[5];\\r\\nt2 =\\r\\nTd0[(s2 >> 24) ] ^\\r\\nTd1[(s1 >> 16) & 0xff] ^\\r\\nTd2[(s0 >> 8) & 0xff] ^\\r\\nTd3[(s3 ) & 0xff] ^\\r\\nrk[6];\\r\\nt3 =\\r\\nTd0[(s3 >> 24) ] ^\\r\\nTd1[(s2 >> 16) & 0xff] ^\\r\\nTd2[(s1 >> 8) & 0xff] ^\\r\\nTd3[(s0 ) & 0xff] ^\\r\\nrk[7];\\r\\nrk += 8;\\r\\nif (--r == 0) {\\r\\nbreak;\\r\\n}\\r\\ns0 =\\r\\nTd0[(t0 >> 24) ] ^\\r\\nTd1[(t3 >> 16) & 0xff] ^\\r\\nTd2[(t2 >> 8) & 0xff] ^\\r\\nTd3[(t1 ) & 0xff] ^\\r\\nrk[0];\\r\\ns1 =\\r\\nTd0[(t1 >> 24) ] ^\\r\\nTd1[(t0 >> 16) & 0xff] ^\\r\\nTd2[(t3 >> 8) & 0xff] ^\\r\\nTd3[(t2 ) & 0xff] ^\\r\\nrk[1];\\r\\ns2 =\\r\\nTd0[(t2 >> 24) ] ^\\r\\nTd1[(t1 >> 16) & 0xff] ^\\r\\nTd2[(t0 >> 8) & 0xff] ^\\r\\nTd3[(t3 ) & 0xff] ^\\r\\nrk[2];\\r\\ns3 =\\r\\nTd0[(t3 >> 24) ] ^\\r\\nTd1[(t2 >> 16) & 0xff] ^\\r\\nTd2[(t1 >> 8) & 0xff] ^\\r\\nTd3[(t0 ) & 0xff] ^\\r\\nrk[3];\\r\\n}\\r\\n#endif\\r\\ns0 =\\r\\n(Td4[(t0 >> 24) ] << 24) ^\\r\\n(Td4[(t3 >> 16) & 0xff] << 16) ^\\r\\n(Td4[(t2 >> 8) & 0xff] << 8) ^\\r\\n(Td4[(t1 ) & 0xff]) ^\\r\\nrk[0];\\r\\nPUTU32(out , s0);\\r\\ns1 =\\r\\n(Td4[(t1 >> 24) ] << 24) ^\\r\\n(Td4[(t0 >> 16) & 0xff] << 16) ^\\r\\n(Td4[(t3 >> 8) & 0xff] << 8) ^\\r\\n(Td4[(t2 ) & 0xff]) ^\\r\\nrk[1];\\r\\nPUTU32(out + 4, s1);\\r\\ns2 =\\r\\n(Td4[(t2 >> 24) ] << 24) ^\\r\\n(Td4[(t1 >> 16) & 0xff] << 16) ^\\r\\n(Td4[(t0 >> 8) & 0xff] << 8) ^\\r\\n(Td4[(t3 ) & 0xff]) ^\\r\\nrk[2];\\r\\nPUTU32(out + 8, s2);\\r\\ns3 =\\r\\n(Td4[(t3 >> 24) ] << 24) ^\\r\\n(Td4[(t2 >> 16) & 0xff] << 16) ^\\r\\n(Td4[(t1 >> 8) & 0xff] << 8) ^\\r\\n(Td4[(t0 ) & 0xff]) ^\\r\\nrk[3];\\r\\nPUTU32(out + 12, s3);\\r\\n}\\r\\nint private_AES_set_encrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key)\\r\\n{\\r\\nu32 *rk;\\r\\nint i = 0;\\r\\nu32 temp;\\r\\nif (!userKey || !key)\\r\\nreturn -1;\\r\\nif (bits != 128 && bits != 192 && bits != 256)\\r\\nreturn -2;\\r\\nrk = key->rd_key;\\r\\nif (bits==128)\\r\\nkey->rounds = 10;\\r\\nelse if (bits==192)\\r\\nkey->rounds = 12;\\r\\nelse\\r\\nkey->rounds = 14;\\r\\nrk[0] = GETU32(userKey );\\r\\nrk[1] = GETU32(userKey + 4);\\r\\nrk[2] = GETU32(userKey + 8);\\r\\nrk[3] = GETU32(userKey + 12);\\r\\nif (bits == 128) {\\r\\nwhile (1) {\\r\\ntemp = rk[3];\\r\\nrk[4] = rk[0] ^\\r\\n(Te4[(temp >> 16) & 0xff] << 24) ^\\r\\n(Te4[(temp >> 8) & 0xff] << 16) ^\\r\\n(Te4[(temp ) & 0xff] << 8) ^\\r\\n(Te4[(temp >> 24) ]) ^\\r\\nrcon[i];\\r\\nrk[5] = rk[1] ^ rk[4];\\r\\nrk[6] = rk[2] ^ rk[5];\\r\\nrk[7] = rk[3] ^ rk[6];\\r\\nif (++i == 10) {\\r\\nreturn 0;\\r\\n}\\r\\nrk += 4;\\r\\n}\\r\\n}\\r\\nrk[4] = GETU32(userKey + 16);\\r\\nrk[5] = GETU32(userKey + 20);\\r\\nif (bits == 192) {\\r\\nwhile (1) {\\r\\ntemp = rk[ 5];\\r\\nrk[ 6] = rk[ 0] ^\\r\\n(Te4[(temp >> 16) & 0xff] << 24) ^\\r\\n(Te4[(temp >> 8) & 0xff] << 16) ^\\r\\n(Te4[(temp ) & 0xff] << 8) ^\\r\\n(Te4[(temp >> 24) ]) ^\\r\\nrcon[i];\\r\\nrk[ 7] = rk[ 1] ^ rk[ 6];\\r\\nrk[ 8] = rk[ 2] ^ rk[ 7];\\r\\nrk[ 9] = rk[ 3] ^ rk[ 8];\\r\\nif (++i == 8) {\\r\\nreturn 0;\\r\\n}\\r\\nrk[10] = rk[ 4] ^ rk[ 9];\\r\\nrk[11] = rk[ 5] ^ rk[10];\\r\\nrk += 6;\\r\\n}\\r\\n}\\r\\nrk[6] = GETU32(userKey + 24);\\r\\nrk[7] = GETU32(userKey + 28);\\r\\nif (bits == 256) {\\r\\nwhile (1) {\\r\\ntemp = rk[ 7];\\r\\nrk[ 8] = rk[ 0] ^\\r\\n(Te4[(temp >> 16) & 0xff] << 24) ^\\r\\n(Te4[(temp >> 8) & 0xff] << 16) ^\\r\\n(Te4[(temp ) & 0xff] << 8) ^\\r\\n(Te4[(temp >> 24) ]) ^\\r\\nrcon[i];\\r\\nrk[ 9] = rk[ 1] ^ rk[ 8];\\r\\nrk[10] = rk[ 2] ^ rk[ 9];\\r\\nrk[11] = rk[ 3] ^ rk[10];\\r\\nif (++i == 7) {\\r\\nreturn 0;\\r\\n}\\r\\ntemp = rk[11];\\r\\nrk[12] = rk[ 4] ^\\r\\n(Te4[(temp >> 24) ] << 24) ^\\r\\n(Te4[(temp >> 16) & 0xff] << 16) ^\\r\\n(Te4[(temp >> 8) & 0xff] << 8) ^\\r\\n(Te4[(temp ) & 0xff]);\\r\\nrk[13] = rk[ 5] ^ rk[12];\\r\\nrk[14] = rk[ 6] ^ rk[13];\\r\\nrk[15] = rk[ 7] ^ rk[14];\\r\\nrk += 8;\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint private_AES_set_decrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key)\\r\\n{\\r\\nu32 *rk;\\r\\nint i, j, status;\\r\\nu32 temp;\\r\\nstatus = private_AES_set_encrypt_key(userKey, bits, key);\\r\\nif (status < 0)\\r\\nreturn status;\\r\\nrk = key->rd_key;\\r\\nfor (i = 0, j = 4*(key->rounds); i < j; i += 4, j -= 4) {\\r\\ntemp = rk[i ]; rk[i ] = rk[j ]; rk[j ] = temp;\\r\\ntemp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;\\r\\ntemp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;\\r\\ntemp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;\\r\\n}\\r\\nfor (i = 1; i < (key->rounds); i++) {\\r\\nrk += 4;\\r\\nfor (j = 0; j < 4; j++) {\\r\\nu32 tp1, tp2, tp4, tp8, tp9, tpb, tpd, tpe, m;\\r\\ntp1 = rk[j];\\r\\nm = tp1 & 0x80808080;\\r\\ntp2 = ((tp1 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\nm = tp2 & 0x80808080;\\r\\ntp4 = ((tp2 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\nm = tp4 & 0x80808080;\\r\\ntp8 = ((tp4 & 0x7f7f7f7f) << 1) ^\\r\\n((m - (m >> 7)) & 0x1b1b1b1b);\\r\\ntp9 = tp8 ^ tp1;\\r\\ntpb = tp9 ^ tp2;\\r\\ntpd = tp9 ^ tp4;\\r\\ntpe = tp8 ^ tp4 ^ tp2;\\r\\n#if defined(ROTATE)\\r\\nrk[j] = tpe ^ ROTATE(tpd,16) ^\\r\\nROTATE(tp9,24) ^ ROTATE(tpb,8);\\r\\n#else\\r\\nrk[j] = tpe ^ (tpd >> 16) ^ (tpd << 16) ^\\r\\n(tp9 >> 8) ^ (tp9 << 24) ^\\r\\n(tpb >> 24) ^ (tpb << 8);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tasn_enc_c", "target": 0, "func": "int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nreturn asn1_item_flags_i2d(val, out, it, ASN1_TFLG_NDEF);\\r\\n}\\r\\nint ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it)\\r\\n{\\r\\nreturn asn1_item_flags_i2d(val, out, it, 0);\\r\\n}\\r\\nstatic int asn1_item_flags_i2d(ASN1_VALUE *val, unsigned char **out,\\r\\nconst ASN1_ITEM *it, int flags)\\r\\n{\\r\\nif (out && !*out) {\\r\\nunsigned char *p, *buf;\\r\\nint len;\\r\\nlen = ASN1_item_ex_i2d(&val, NULL, it, -1, flags);\\r\\nif (len <= 0)\\r\\nreturn len;\\r\\nbuf = OPENSSL_malloc(len);\\r\\nif (!buf)\\r\\nreturn -1;\\r\\np = buf;\\r\\nASN1_item_ex_i2d(&val, &p, it, -1, flags);\\r\\n*out = buf;\\r\\nreturn len;\\r\\n}\\r\\nreturn ASN1_item_ex_i2d(&val, out, it, -1, flags);\\r\\n}\\r\\nint ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned char **out,\\r\\nconst ASN1_ITEM *it, int tag, int aclass)\\r\\n{\\r\\nconst ASN1_TEMPLATE *tt = NULL;\\r\\nunsigned char *p = NULL;\\r\\nint i, seqcontlen, seqlen, ndef = 1;\\r\\nconst ASN1_COMPAT_FUNCS *cf;\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_aux_cb *asn1_cb = 0;\\r\\nif ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)\\r\\nreturn 0;\\r\\nif (aux && aux->asn1_cb)\\r\\nasn1_cb = aux->asn1_cb;\\r\\nswitch (it->itype) {\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates)\\r\\nreturn asn1_template_ex_i2d(pval, out, it->templates,\\r\\ntag, aclass);\\r\\nreturn asn1_i2d_ex_primitive(pval, out, it, tag, aclass);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nreturn asn1_i2d_ex_primitive(pval, out, it, -1, aclass);\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\\r\\nreturn 0;\\r\\ni = asn1_get_choice_selector(pval, it);\\r\\nif ((i >= 0) && (i < it->tcount)) {\\r\\nASN1_VALUE **pchval;\\r\\nconst ASN1_TEMPLATE *chtt;\\r\\nchtt = it->templates + i;\\r\\npchval = asn1_get_field_ptr(pval, chtt);\\r\\nreturn asn1_template_ex_i2d(pchval, out, chtt, -1, aclass);\\r\\n}\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nreturn ef->asn1_ex_i2d(pval, out, it, tag, aclass);\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncf = it->funcs;\\r\\nif (out)\\r\\np = *out;\\r\\ni = cf->asn1_i2d(*pval, out);\\r\\nif (out && (tag != -1))\\r\\n*p = aclass | tag | (*p & V_ASN1_CONSTRUCTED);\\r\\nreturn i;\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\nif (aclass & ASN1_TFLG_NDEF)\\r\\nndef = 2;\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\ni = asn1_enc_restore(&seqcontlen, out, pval, it);\\r\\nif (i < 0)\\r\\nreturn 0;\\r\\nif (i > 0)\\r\\nreturn seqcontlen;\\r\\nseqcontlen = 0;\\r\\nif (tag == -1) {\\r\\ntag = V_ASN1_SEQUENCE;\\r\\naclass = (aclass & ~ASN1_TFLG_TAG_CLASS)\\r\\n| V_ASN1_UNIVERSAL;\\r\\n}\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))\\r\\nreturn 0;\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {\\r\\nconst ASN1_TEMPLATE *seqtt;\\r\\nASN1_VALUE **pseqval;\\r\\nseqtt = asn1_do_adb(pval, tt, 1);\\r\\nif (!seqtt)\\r\\nreturn 0;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nseqcontlen += asn1_template_ex_i2d(pseqval, NULL, seqtt,\\r\\n-1, aclass);\\r\\n}\\r\\nseqlen = ASN1_object_size(ndef, seqcontlen, tag);\\r\\nif (!out)\\r\\nreturn seqlen;\\r\\nASN1_put_object(out, ndef, seqcontlen, tag, aclass);\\r\\nfor (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {\\r\\nconst ASN1_TEMPLATE *seqtt;\\r\\nASN1_VALUE **pseqval;\\r\\nseqtt = asn1_do_adb(pval, tt, 1);\\r\\nif (!seqtt)\\r\\nreturn 0;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nasn1_template_ex_i2d(pseqval, out, seqtt, -1, aclass);\\r\\n}\\r\\nif (ndef == 2)\\r\\nASN1_put_eoc(out);\\r\\nif (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))\\r\\nreturn 0;\\r\\nreturn seqlen;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint ASN1_template_i2d(ASN1_VALUE **pval, unsigned char **out,\\r\\nconst ASN1_TEMPLATE *tt)\\r\\n{\\r\\nreturn asn1_template_ex_i2d(pval, out, tt, -1, 0);\\r\\n}\\r\\nstatic int asn1_template_ex_i2d(ASN1_VALUE **pval, unsigned char **out,\\r\\nconst ASN1_TEMPLATE *tt, int tag, int iclass)\\r\\n{\\r\\nint i, ret, flags, ttag, tclass, ndef;\\r\\nflags = tt->flags;\\r\\nif (flags & ASN1_TFLG_TAG_MASK) {\\r\\nif (tag != -1)\\r\\nreturn -1;\\r\\nttag = tt->tag;\\r\\ntclass = flags & ASN1_TFLG_TAG_CLASS;\\r\\n} else if (tag != -1) {\\r\\nttag = tag;\\r\\ntclass = iclass & ASN1_TFLG_TAG_CLASS;\\r\\n} else {\\r\\nttag = -1;\\r\\ntclass = 0;\\r\\n}\\r\\niclass &= ~ASN1_TFLG_TAG_CLASS;\\r\\nif ((flags & ASN1_TFLG_NDEF) && (iclass & ASN1_TFLG_NDEF))\\r\\nndef = 2;\\r\\nelse\\r\\nndef = 1;\\r\\nif (flags & ASN1_TFLG_SK_MASK) {\\r\\nSTACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\\r\\nint isset, sktag, skaclass;\\r\\nint skcontlen, sklen;\\r\\nASN1_VALUE *skitem;\\r\\nif (!*pval)\\r\\nreturn 0;\\r\\nif (flags & ASN1_TFLG_SET_OF) {\\r\\nisset = 1;\\r\\nif (flags & ASN1_TFLG_SEQUENCE_OF)\\r\\nisset = 2;\\r\\n} else\\r\\nisset = 0;\\r\\nif ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG)) {\\r\\nsktag = ttag;\\r\\nskaclass = tclass;\\r\\n} else {\\r\\nskaclass = V_ASN1_UNIVERSAL;\\r\\nif (isset)\\r\\nsktag = V_ASN1_SET;\\r\\nelse\\r\\nsktag = V_ASN1_SEQUENCE;\\r\\n}\\r\\nskcontlen = 0;\\r\\nfor (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {\\r\\nskitem = sk_ASN1_VALUE_value(sk, i);\\r\\nskcontlen += ASN1_item_ex_i2d(&skitem, NULL,\\r\\nASN1_ITEM_ptr(tt->item),\\r\\n-1, iclass);\\r\\n}\\r\\nsklen = ASN1_object_size(ndef, skcontlen, sktag);\\r\\nif (flags & ASN1_TFLG_EXPTAG)\\r\\nret = ASN1_object_size(ndef, sklen, ttag);\\r\\nelse\\r\\nret = sklen;\\r\\nif (!out)\\r\\nreturn ret;\\r\\nif (flags & ASN1_TFLG_EXPTAG)\\r\\nASN1_put_object(out, ndef, sklen, ttag, tclass);\\r\\nASN1_put_object(out, ndef, skcontlen, sktag, skaclass);\\r\\nasn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item),\\r\\nisset, iclass);\\r\\nif (ndef == 2) {\\r\\nASN1_put_eoc(out);\\r\\nif (flags & ASN1_TFLG_EXPTAG)\\r\\nASN1_put_eoc(out);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nif (flags & ASN1_TFLG_EXPTAG) {\\r\\ni = ASN1_item_ex_i2d(pval, NULL, ASN1_ITEM_ptr(tt->item), -1, iclass);\\r\\nif (!i)\\r\\nreturn 0;\\r\\nret = ASN1_object_size(ndef, i, ttag);\\r\\nif (out) {\\r\\nASN1_put_object(out, ndef, i, ttag, tclass);\\r\\nASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, iclass);\\r\\nif (ndef == 2)\\r\\nASN1_put_eoc(out);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nreturn ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),\\r\\nttag, tclass | iclass);\\r\\n}\\r\\nstatic int der_cmp(const void *a, const void *b)\\r\\n{\\r\\nconst DER_ENC *d1 = a, *d2 = b;\\r\\nint cmplen, i;\\r\\ncmplen = (d1->length < d2->length) ? d1->length : d2->length;\\r\\ni = memcmp(d1->data, d2->data, cmplen);\\r\\nif (i)\\r\\nreturn i;\\r\\nreturn d1->length - d2->length;\\r\\n}\\r\\nstatic int asn1_i2d_ex_primitive(ASN1_VALUE **pval, unsigned char **out,\\r\\nconst ASN1_ITEM *it, int tag, int aclass)\\r\\n{\\r\\nint len;\\r\\nint utype;\\r\\nint usetag;\\r\\nint ndef = 0;\\r\\nutype = it->utype;\\r\\nlen = asn1_ex_i2c(pval, NULL, &utype, it);\\r\\nif ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||\\r\\n(utype == V_ASN1_OTHER))\\r\\nusetag = 0;\\r\\nelse\\r\\nusetag = 1;\\r\\nif (len == -1)\\r\\nreturn 0;\\r\\nif (len == -2) {\\r\\nndef = 2;\\r\\nlen = 0;\\r\\n}\\r\\nif (tag == -1)\\r\\ntag = utype;\\r\\nif (out) {\\r\\nif (usetag)\\r\\nASN1_put_object(out, ndef, len, tag, aclass);\\r\\nasn1_ex_i2c(pval, *out, &utype, it);\\r\\nif (ndef)\\r\\nASN1_put_eoc(out);\\r\\nelse\\r\\n*out += len;\\r\\n}\\r\\nif (usetag)\\r\\nreturn ASN1_object_size(ndef, len, tag);\\r\\nreturn len;\\r\\n}\\r\\nint asn1_ex_i2c(ASN1_VALUE **pval, unsigned char *cout, int *putype,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nASN1_BOOLEAN *tbool = NULL;\\r\\nASN1_STRING *strtmp;\\r\\nASN1_OBJECT *otmp;\\r\\nint utype;\\r\\nconst unsigned char *cont;\\r\\nunsigned char c;\\r\\nint len;\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf;\\r\\npf = it->funcs;\\r\\nif (pf && pf->prim_i2c)\\r\\nreturn pf->prim_i2c(pval, cout, putype, it);\\r\\nif ((it->itype != ASN1_ITYPE_PRIMITIVE)\\r\\n|| (it->utype != V_ASN1_BOOLEAN)) {\\r\\nif (!*pval)\\r\\nreturn -1;\\r\\n}\\r\\nif (it->itype == ASN1_ITYPE_MSTRING) {\\r\\nstrtmp = (ASN1_STRING *)*pval;\\r\\nutype = strtmp->type;\\r\\n*putype = utype;\\r\\n} else if (it->utype == V_ASN1_ANY) {\\r\\nASN1_TYPE *typ;\\r\\ntyp = (ASN1_TYPE *)*pval;\\r\\nutype = typ->type;\\r\\n*putype = utype;\\r\\npval = &typ->value.asn1_value;\\r\\n} else\\r\\nutype = *putype;\\r\\nswitch (utype) {\\r\\ncase V_ASN1_OBJECT:\\r\\notmp = (ASN1_OBJECT *)*pval;\\r\\ncont = otmp->data;\\r\\nlen = otmp->length;\\r\\nbreak;\\r\\ncase V_ASN1_NULL:\\r\\ncont = NULL;\\r\\nlen = 0;\\r\\nbreak;\\r\\ncase V_ASN1_BOOLEAN:\\r\\ntbool = (ASN1_BOOLEAN *)pval;\\r\\nif (*tbool == -1)\\r\\nreturn -1;\\r\\nif (it->utype != V_ASN1_ANY) {\\r\\nif (*tbool && (it->size > 0))\\r\\nreturn -1;\\r\\nif (!*tbool && !it->size)\\r\\nreturn -1;\\r\\n}\\r\\nc = (unsigned char)*tbool;\\r\\ncont = &c;\\r\\nlen = 1;\\r\\nbreak;\\r\\ncase V_ASN1_BIT_STRING:\\r\\nreturn i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval,\\r\\ncout ? &cout : NULL);\\r\\nbreak;\\r\\ncase V_ASN1_INTEGER:\\r\\ncase V_ASN1_NEG_INTEGER:\\r\\ncase V_ASN1_ENUMERATED:\\r\\ncase V_ASN1_NEG_ENUMERATED:\\r\\nreturn i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? &cout : NULL);\\r\\nbreak;\\r\\ncase V_ASN1_OCTET_STRING:\\r\\ncase V_ASN1_NUMERICSTRING:\\r\\ncase V_ASN1_PRINTABLESTRING:\\r\\ncase V_ASN1_T61STRING:\\r\\ncase V_ASN1_VIDEOTEXSTRING:\\r\\ncase V_ASN1_IA5STRING:\\r\\ncase V_ASN1_UTCTIME:\\r\\ncase V_ASN1_GENERALIZEDTIME:\\r\\ncase V_ASN1_GRAPHICSTRING:\\r\\ncase V_ASN1_VISIBLESTRING:\\r\\ncase V_ASN1_GENERALSTRING:\\r\\ncase V_ASN1_UNIVERSALSTRING:\\r\\ncase V_ASN1_BMPSTRING:\\r\\ncase V_ASN1_UTF8STRING:\\r\\ncase V_ASN1_SEQUENCE:\\r\\ncase V_ASN1_SET:\\r\\ndefault:\\r\\nstrtmp = (ASN1_STRING *)*pval;\\r\\nif ((it->size == ASN1_TFLG_NDEF)\\r\\n&& (strtmp->flags & ASN1_STRING_FLAG_NDEF)) {\\r\\nif (cout) {\\r\\nstrtmp->data = cout;\\r\\nstrtmp->length = 0;\\r\\n}\\r\\nreturn -2;\\r\\n}\\r\\ncont = strtmp->data;\\r\\nlen = strtmp->length;\\r\\nbreak;\\r\\n}\\r\\nif (cout && len)\\r\\nmemcpy(cout, cont, len);\\r\\nreturn len;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_asn_mime_c", "target": 0, "func": "int i2d_ASN1_bio_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nif (flags & SMIME_STREAM) {\\r\\nBIO *bio, *tbio;\\r\\nbio = BIO_new_NDEF(out, val, it);\\r\\nif (!bio) {\\r\\nASN1err(ASN1_F_I2D_ASN1_BIO_STREAM, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nSMIME_crlf_copy(in, bio, flags);\\r\\n(void)BIO_flush(bio);\\r\\ndo {\\r\\ntbio = BIO_pop(bio);\\r\\nBIO_free(bio);\\r\\nbio = tbio;\\r\\n} while (bio != out);\\r\\n}\\r\\nelse\\r\\nASN1_item_i2d_bio(it, out, val);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int B64_write_ASN1(BIO *out, ASN1_VALUE *val, BIO *in, int flags,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nBIO *b64;\\r\\nint r;\\r\\nb64 = BIO_new(BIO_f_base64());\\r\\nif (!b64) {\\r\\nASN1err(ASN1_F_B64_WRITE_ASN1, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nout = BIO_push(b64, out);\\r\\nr = i2d_ASN1_bio_stream(out, val, in, flags, it);\\r\\n(void)BIO_flush(out);\\r\\nBIO_pop(out);\\r\\nBIO_free(b64);\\r\\nreturn r;\\r\\n}\\r\\nint PEM_write_bio_ASN1_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,\\r\\nconst char *hdr, const ASN1_ITEM *it)\\r\\n{\\r\\nint r;\\r\\nBIO_printf(out, \"-----BEGIN %s-----\\n\", hdr);\\r\\nr = B64_write_ASN1(out, val, in, flags, it);\\r\\nBIO_printf(out, \"-----END %s-----\\n\", hdr);\\r\\nreturn r;\\r\\n}\\r\\nstatic ASN1_VALUE *b64_read_asn1(BIO *bio, const ASN1_ITEM *it)\\r\\n{\\r\\nBIO *b64;\\r\\nASN1_VALUE *val;\\r\\nif (!(b64 = BIO_new(BIO_f_base64()))) {\\r\\nASN1err(ASN1_F_B64_READ_ASN1, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nbio = BIO_push(b64, bio);\\r\\nval = ASN1_item_d2i_bio(it, bio, NULL);\\r\\nif (!val)\\r\\nASN1err(ASN1_F_B64_READ_ASN1, ASN1_R_DECODE_ERROR);\\r\\n(void)BIO_flush(bio);\\r\\nbio = BIO_pop(bio);\\r\\nBIO_free(b64);\\r\\nreturn val;\\r\\n}\\r\\nstatic int asn1_output_data(BIO *out, BIO *data, ASN1_VALUE *val, int flags,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nBIO *tmpbio;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_STREAM_ARG sarg;\\r\\nint rv = 1;\\r\\nif (!(flags & SMIME_DETACHED) || (flags & PKCS7_REUSE_DIGEST)) {\\r\\nSMIME_crlf_copy(data, out, flags);\\r\\nreturn 1;\\r\\n}\\r\\nif (!aux || !aux->asn1_cb) {\\r\\nASN1err(ASN1_F_ASN1_OUTPUT_DATA, ASN1_R_STREAMING_NOT_SUPPORTED);\\r\\nreturn 0;\\r\\n}\\r\\nsarg.out = out;\\r\\nsarg.ndef_bio = NULL;\\r\\nsarg.boundary = NULL;\\r\\nif (aux->asn1_cb(ASN1_OP_DETACHED_PRE, &val, it, &sarg) <= 0)\\r\\nreturn 0;\\r\\nSMIME_crlf_copy(data, sarg.ndef_bio, flags);\\r\\nif (aux->asn1_cb(ASN1_OP_DETACHED_POST, &val, it, &sarg) <= 0)\\r\\nrv = 0;\\r\\nwhile (sarg.ndef_bio != out) {\\r\\ntmpbio = BIO_pop(sarg.ndef_bio);\\r\\nBIO_free(sarg.ndef_bio);\\r\\nsarg.ndef_bio = tmpbio;\\r\\n}\\r\\nreturn rv;\\r\\n}\\r\\nASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)\\r\\n{\\r\\nBIO *asnin;\\r\\nSTACK_OF(MIME_HEADER) *headers = NULL;\\r\\nSTACK_OF(BIO) *parts = NULL;\\r\\nMIME_HEADER *hdr;\\r\\nMIME_PARAM *prm;\\r\\nASN1_VALUE *val;\\r\\nint ret;\\r\\nif (bcont)\\r\\n*bcont = NULL;\\r\\nif (!(headers = mime_parse_hdr(bio))) {\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_MIME_PARSE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(hdr = mime_hdr_find(headers, \"content-type\")) || !hdr->value) {\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_CONTENT_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!strcmp(hdr->value, \"multipart/signed\")) {\\r\\nprm = mime_param_find(hdr, \"boundary\");\\r\\nif (!prm || !prm->param_value) {\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_MULTIPART_BOUNDARY);\\r\\nreturn NULL;\\r\\n}\\r\\nret = multi_split(bio, prm->param_value, &parts);\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nif (!ret || (sk_BIO_num(parts) != 2)) {\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_MULTIPART_BODY_FAILURE);\\r\\nsk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn NULL;\\r\\n}\\r\\nasnin = sk_BIO_value(parts, 1);\\r\\nif (!(headers = mime_parse_hdr(asnin))) {\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_MIME_SIG_PARSE_ERROR);\\r\\nsk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(hdr = mime_hdr_find(headers, \"content-type\")) || !hdr->value) {\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_NO_SIG_CONTENT_TYPE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (strcmp(hdr->value, \"application/x-pkcs7-signature\") &&\\r\\nstrcmp(hdr->value, \"application/pkcs7-signature\")) {\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_SIG_INVALID_MIME_TYPE);\\r\\nERR_add_error_data(2, \"type: \", hdr->value);\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nsk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn NULL;\\r\\n}\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nif (!(val = b64_read_asn1(asnin, it))) {\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_ASN1_SIG_PARSE_ERROR);\\r\\nsk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn NULL;\\r\\n}\\r\\nif (bcont) {\\r\\n*bcont = sk_BIO_value(parts, 0);\\r\\nBIO_free(asnin);\\r\\nsk_BIO_free(parts);\\r\\n} else\\r\\nsk_BIO_pop_free(parts, BIO_vfree);\\r\\nreturn val;\\r\\n}\\r\\nif (strcmp(hdr->value, \"application/x-pkcs7-mime\") &&\\r\\nstrcmp(hdr->value, \"application/pkcs7-mime\")) {\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_INVALID_MIME_TYPE);\\r\\nERR_add_error_data(2, \"type: \", hdr->value);\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nreturn NULL;\\r\\n}\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nif (!(val = b64_read_asn1(bio, it))) {\\r\\nASN1err(ASN1_F_SMIME_READ_ASN1, ASN1_R_ASN1_PARSE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn val;\\r\\n}\\r\\nint SMIME_crlf_copy(BIO *in, BIO *out, int flags)\\r\\n{\\r\\nBIO *bf;\\r\\nchar eol;\\r\\nint len;\\r\\nchar linebuf[MAX_SMLEN];\\r\\nbf = BIO_new(BIO_f_buffer());\\r\\nif (!bf)\\r\\nreturn 0;\\r\\nout = BIO_push(bf, out);\\r\\nif (flags & SMIME_BINARY) {\\r\\nwhile ((len = BIO_read(in, linebuf, MAX_SMLEN)) > 0)\\r\\nBIO_write(out, linebuf, len);\\r\\n} else {\\r\\nif (flags & SMIME_TEXT)\\r\\nBIO_printf(out, \"Content-Type: text/plain\\r\\n\\r\\n\");\\r\\nwhile ((len = BIO_gets(in, linebuf, MAX_SMLEN)) > 0) {\\r\\neol = strip_eol(linebuf, &len);\\r\\nif (len)\\r\\nBIO_write(out, linebuf, len);\\r\\nif (eol)\\r\\nBIO_write(out, \"\\r\\n\", 2);\\r\\n}\\r\\n}\\r\\n(void)BIO_flush(out);\\r\\nBIO_pop(out);\\r\\nBIO_free(bf);\\r\\nreturn 1;\\r\\n}\\r\\nint SMIME_text(BIO *in, BIO *out)\\r\\n{\\r\\nchar iobuf[4096];\\r\\nint len;\\r\\nSTACK_OF(MIME_HEADER) *headers;\\r\\nMIME_HEADER *hdr;\\r\\nif (!(headers = mime_parse_hdr(in))) {\\r\\nASN1err(ASN1_F_SMIME_TEXT, ASN1_R_MIME_PARSE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(hdr = mime_hdr_find(headers, \"content-type\")) || !hdr->value) {\\r\\nASN1err(ASN1_F_SMIME_TEXT, ASN1_R_MIME_NO_CONTENT_TYPE);\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nreturn 0;\\r\\n}\\r\\nif (strcmp(hdr->value, \"text/plain\")) {\\r\\nASN1err(ASN1_F_SMIME_TEXT, ASN1_R_INVALID_MIME_TYPE);\\r\\nERR_add_error_data(2, \"type: \", hdr->value);\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nreturn 0;\\r\\n}\\r\\nsk_MIME_HEADER_pop_free(headers, mime_hdr_free);\\r\\nwhile ((len = BIO_read(in, iobuf, sizeof(iobuf))) > 0)\\r\\nBIO_write(out, iobuf, len);\\r\\nif (len < 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nchar *strip_ends(char *name)\\r\\n{\\r\\nreturn strip_end(strip_start(name));\\r\\n}\\r\\nstatic char *strip_start(char *name)\\r\\n{\\r\\nchar *p, c;\\r\\nfor (p = name; (c = *p); p++) {\\r\\nif (c == '\"') {\\r\\nif (p[1])\\r\\nreturn p + 1;\\r\\nreturn NULL;\\r\\n}\\r\\nif (!isspace((unsigned char)c))\\r\\nreturn p;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic char *strip_end(char *name)\\r\\n{\\r\\nchar *p, c;\\r\\nif (!name)\\r\\nreturn NULL;\\r\\nfor (p = name + strlen(name) - 1; p >= name; p--) {\\r\\nc = *p;\\r\\nif (c == '\"') {\\r\\nif (p - 1 == name)\\r\\nreturn NULL;\\r\\n*p = 0;\\r\\nreturn name;\\r\\n}\\r\\nif (isspace((unsigned char)c))\\r\\n*p = 0;\\r\\nelse\\r\\nreturn name;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic MIME_HEADER *mime_hdr_new(char *name, char *value)\\r\\n{\\r\\nMIME_HEADER *mhdr;\\r\\nchar *tmpname, *tmpval, *p;\\r\\nint c;\\r\\nif (name) {\\r\\nif (!(tmpname = BUF_strdup(name)))\\r\\nreturn NULL;\\r\\nfor (p = tmpname; *p; p++) {\\r\\nc = (unsigned char)*p;\\r\\nif (isupper(c)) {\\r\\nc = tolower(c);\\r\\n*p = c;\\r\\n}\\r\\n}\\r\\n} else\\r\\ntmpname = NULL;\\r\\nif (value) {\\r\\nif (!(tmpval = BUF_strdup(value)))\\r\\nreturn NULL;\\r\\nfor (p = tmpval; *p; p++) {\\r\\nc = (unsigned char)*p;\\r\\nif (isupper(c)) {\\r\\nc = tolower(c);\\r\\n*p = c;\\r\\n}\\r\\n}\\r\\n} else\\r\\ntmpval = NULL;\\r\\nmhdr = (MIME_HEADER *)OPENSSL_malloc(sizeof(MIME_HEADER));\\r\\nif (!mhdr)\\r\\nreturn NULL;\\r\\nmhdr->name = tmpname;\\r\\nmhdr->value = tmpval;\\r\\nif (!(mhdr->params = sk_MIME_PARAM_new(mime_param_cmp)))\\r\\nreturn NULL;\\r\\nreturn mhdr;\\r\\n}\\r\\nstatic int mime_hdr_addparam(MIME_HEADER *mhdr, char *name, char *value)\\r\\n{\\r\\nchar *tmpname, *tmpval, *p;\\r\\nint c;\\r\\nMIME_PARAM *mparam;\\r\\nif (name) {\\r\\ntmpname = BUF_strdup(name);\\r\\nif (!tmpname)\\r\\nreturn 0;\\r\\nfor (p = tmpname; *p; p++) {\\r\\nc = (unsigned char)*p;\\r\\nif (isupper(c)) {\\r\\nc = tolower(c);\\r\\n*p = c;\\r\\n}\\r\\n}\\r\\n} else\\r\\ntmpname = NULL;\\r\\nif (value) {\\r\\ntmpval = BUF_strdup(value);\\r\\nif (!tmpval)\\r\\nreturn 0;\\r\\n} else\\r\\ntmpval = NULL;\\r\\nmparam = (MIME_PARAM *)OPENSSL_malloc(sizeof(MIME_PARAM));\\r\\nif (!mparam)\\r\\nreturn 0;\\r\\nmparam->param_name = tmpname;\\r\\nmparam->param_value = tmpval;\\r\\nsk_MIME_PARAM_push(mhdr->params, mparam);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int mime_hdr_cmp(const MIME_HEADER *const *a,\\r\\nconst MIME_HEADER *const *b)\\r\\n{\\r\\nif (!(*a)->name || !(*b)->name)\\r\\nreturn ! !(*a)->name - ! !(*b)->name;\\r\\nreturn (strcmp((*a)->name, (*b)->name));\\r\\n}\\r\\nstatic int mime_param_cmp(const MIME_PARAM *const *a,\\r\\nconst MIME_PARAM *const *b)\\r\\n{\\r\\nif (!(*a)->param_name || !(*b)->param_name)\\r\\nreturn ! !(*a)->param_name - ! !(*b)->param_name;\\r\\nreturn (strcmp((*a)->param_name, (*b)->param_name));\\r\\n}\\r\\nstatic MIME_PARAM *mime_param_find(MIME_HEADER *hdr, char *name)\\r\\n{\\r\\nMIME_PARAM param;\\r\\nint idx;\\r\\nparam.param_name = name;\\r\\nidx = sk_MIME_PARAM_find(hdr->params, &param);\\r\\nif (idx < 0)\\r\\nreturn NULL;\\r\\nreturn sk_MIME_PARAM_value(hdr->params, idx);\\r\\n}\\r\\nstatic void mime_hdr_free(MIME_HEADER *hdr)\\r\\n{\\r\\nif (hdr->name)\\r\\nOPENSSL_free(hdr->name);\\r\\nif (hdr->value)\\r\\nOPENSSL_free(hdr->value);\\r\\nif (hdr->params)\\r\\nsk_MIME_PARAM_pop_free(hdr->params, mime_param_free);\\r\\nOPENSSL_free(hdr);\\r\\n}\\r\\nstatic void mime_param_free(MIME_PARAM *param)\\r\\n{\\r\\nif (param->param_name)\\r\\nOPENSSL_free(param->param_name);\\r\\nif (param->param_value)\\r\\nOPENSSL_free(param->param_value);\\r\\nOPENSSL_free(param);\\r\\n}\\r\\nstatic int mime_bound_check(char *line, int linelen, char *bound, int blen)\\r\\n{\\r\\nif (linelen == -1)\\r\\nlinelen = strlen(line);\\r\\nif (blen == -1)\\r\\nblen = strlen(bound);\\r\\nif (blen + 2 > linelen)\\r\\nreturn 0;\\r\\nif (!strncmp(line, \"--\", 2) && !strncmp(line + 2, bound, blen)) {\\r\\nif (!strncmp(line + blen + 2, \"--\", 2))\\r\\nreturn 2;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int strip_eol(char *linebuf, int *plen)\\r\\n{\\r\\nint len = *plen;\\r\\nchar *p, c;\\r\\nint is_eol = 0;\\r\\np = linebuf + len - 1;\\r\\nfor (p = linebuf + len - 1; len > 0; len--, p--) {\\r\\nc = *p;\\r\\nif (c == '\\n')\\r\\nis_eol = 1;\\r\\nelse if (c != '\\r')\\r\\nbreak;\\r\\n}\\r\\n*plen = len;\\r\\nreturn is_eol;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_client-arg_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *sbio = NULL, *out = NULL;\\r\\nint len;\\r\\nchar tmpbuf[1024];\\r\\nSSL_CTX *ctx;\\r\\nSSL_CONF_CTX *cctx;\\r\\nSSL *ssl;\\r\\nchar **args = argv + 1;\\r\\nconst char *connect_str = \"localhost:4433\";\\r\\nint nargs = argc - 1;\\r\\nERR_load_crypto_strings();\\r\\nERR_load_SSL_strings();\\r\\nSSL_library_init();\\r\\nctx = SSL_CTX_new(SSLv23_client_method());\\r\\ncctx = SSL_CONF_CTX_new();\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CLIENT);\\r\\nSSL_CONF_CTX_set_ssl_ctx(cctx, ctx);\\r\\nwhile (*args && **args == '-') {\\r\\nint rv;\\r\\nrv = SSL_CONF_cmd_argv(cctx, &nargs, &args);\\r\\nif (rv == -3) {\\r\\nfprintf(stderr, \"Missing argument for %s\\n\", *args);\\r\\ngoto end;\\r\\n}\\r\\nif (rv < 0) {\\r\\nfprintf(stderr, \"Error in command %s\\n\", *args);\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto end;\\r\\n}\\r\\nif (rv > 0)\\r\\ncontinue;\\r\\nif (!strcmp(*args, \"-connect\")) {\\r\\nconnect_str = args[1];\\r\\nif (connect_str == NULL) {\\r\\nfprintf(stderr, \"Missing -connect argument\\n\");\\r\\ngoto end;\\r\\n}\\r\\nargs += 2;\\r\\nnargs -= 2;\\r\\ncontinue;\\r\\n} else {\\r\\nfprintf(stderr, \"Unknown argument %s\\n\", *args);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!SSL_CONF_CTX_finish(cctx)) {\\r\\nfprintf(stderr, \"Finish error\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto err;\\r\\n}\\r\\nsbio = BIO_new_ssl_connect(ctx);\\r\\nBIO_get_ssl(sbio, &ssl);\\r\\nif (!ssl) {\\r\\nfprintf(stderr, \"Can't locate SSL pointer\\n\");\\r\\ngoto end;\\r\\n}\\r\\nSSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\\r\\nBIO_set_conn_hostname(sbio, connect_str);\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\nif (BIO_do_connect(sbio) <= 0) {\\r\\nfprintf(stderr, \"Error connecting to server\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_do_handshake(sbio) <= 0) {\\r\\nfprintf(stderr, \"Error establishing SSL connection\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto end;\\r\\n}\\r\\nBIO_puts(sbio, \"GET / HTTP/1.0\\n\\n\");\\r\\nfor (;;) {\\r\\nlen = BIO_read(sbio, tmpbuf, 1024);\\r\\nif (len <= 0)\\r\\nbreak;\\r\\nBIO_write(out, tmpbuf, len);\\r\\n}\\r\\nend:\\r\\nSSL_CONF_CTX_free(cctx);\\r\\nBIO_free_all(sbio);\\r\\nBIO_free(out);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_rsp_verify_c", "target": 0, "func": "static ESS_SIGNING_CERT *ESS_get_signing_cert(PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nASN1_TYPE *attr;\\r\\nconst unsigned char *p;\\r\\nattr = PKCS7_get_signed_attribute(si, NID_id_smime_aa_signingCertificate);\\r\\nif (!attr)\\r\\nreturn NULL;\\r\\np = attr->value.sequence->data;\\r\\nreturn d2i_ESS_SIGNING_CERT(NULL, &p, attr->value.sequence->length);\\r\\n}\\r\\nstatic int TS_issuer_serial_cmp(ESS_ISSUER_SERIAL *is, X509_CINF *cinfo)\\r\\n{\\r\\nGENERAL_NAME *issuer;\\r\\nif (!is || !cinfo || sk_GENERAL_NAME_num(is->issuer) != 1)\\r\\nreturn -1;\\r\\nissuer = sk_GENERAL_NAME_value(is->issuer, 0);\\r\\nif (issuer->type != GEN_DIRNAME\\r\\n|| X509_NAME_cmp(issuer->d.dirn, cinfo->issuer))\\r\\nreturn -1;\\r\\nif (ASN1_INTEGER_cmp(is->serial, cinfo->serialNumber))\\r\\nreturn -1;\\r\\nreturn 0;\\r\\n}\\r\\nint TS_RESP_verify_response(TS_VERIFY_CTX *ctx, TS_RESP *response)\\r\\n{\\r\\nPKCS7 *token = TS_RESP_get_token(response);\\r\\nTS_TST_INFO *tst_info = TS_RESP_get_tst_info(response);\\r\\nint ret = 0;\\r\\nif (!TS_check_status_info(response))\\r\\ngoto err;\\r\\nif (!int_TS_RESP_verify_token(ctx, token, tst_info))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint TS_RESP_verify_token(TS_VERIFY_CTX *ctx, PKCS7 *token)\\r\\n{\\r\\nTS_TST_INFO *tst_info = PKCS7_to_TS_TST_INFO(token);\\r\\nint ret = 0;\\r\\nif (tst_info) {\\r\\nret = int_TS_RESP_verify_token(ctx, token, tst_info);\\r\\nTS_TST_INFO_free(tst_info);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int int_TS_RESP_verify_token(TS_VERIFY_CTX *ctx,\\r\\nPKCS7 *token, TS_TST_INFO *tst_info)\\r\\n{\\r\\nX509 *signer = NULL;\\r\\nGENERAL_NAME *tsa_name = TS_TST_INFO_get_tsa(tst_info);\\r\\nX509_ALGOR *md_alg = NULL;\\r\\nunsigned char *imprint = NULL;\\r\\nunsigned imprint_len = 0;\\r\\nint ret = 0;\\r\\nif ((ctx->flags & TS_VFY_SIGNATURE)\\r\\n&& !TS_RESP_verify_signature(token, ctx->certs, ctx->store, &signer))\\r\\ngoto err;\\r\\nif ((ctx->flags & TS_VFY_VERSION)\\r\\n&& TS_TST_INFO_get_version(tst_info) != 1) {\\r\\nTSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_UNSUPPORTED_VERSION);\\r\\ngoto err;\\r\\n}\\r\\nif ((ctx->flags & TS_VFY_POLICY)\\r\\n&& !TS_check_policy(ctx->policy, tst_info))\\r\\ngoto err;\\r\\nif ((ctx->flags & TS_VFY_IMPRINT)\\r\\n&& !TS_check_imprints(ctx->md_alg, ctx->imprint, ctx->imprint_len,\\r\\ntst_info))\\r\\ngoto err;\\r\\nif ((ctx->flags & TS_VFY_DATA)\\r\\n&& (!TS_compute_imprint(ctx->data, tst_info,\\r\\n&md_alg, &imprint, &imprint_len)\\r\\n|| !TS_check_imprints(md_alg, imprint, imprint_len, tst_info)))\\r\\ngoto err;\\r\\nif ((ctx->flags & TS_VFY_NONCE)\\r\\n&& !TS_check_nonces(ctx->nonce, tst_info))\\r\\ngoto err;\\r\\nif ((ctx->flags & TS_VFY_SIGNER)\\r\\n&& tsa_name && !TS_check_signer_name(tsa_name, signer)) {\\r\\nTSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_TSA_NAME_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nif ((ctx->flags & TS_VFY_TSA_NAME)\\r\\n&& !TS_check_signer_name(ctx->tsa_name, signer)) {\\r\\nTSerr(TS_F_INT_TS_RESP_VERIFY_TOKEN, TS_R_TSA_UNTRUSTED);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nX509_free(signer);\\r\\nX509_ALGOR_free(md_alg);\\r\\nOPENSSL_free(imprint);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int TS_check_status_info(TS_RESP *response)\\r\\n{\\r\\nTS_STATUS_INFO *info = TS_RESP_get_status_info(response);\\r\\nlong status = ASN1_INTEGER_get(info->status);\\r\\nconst char *status_text = NULL;\\r\\nchar *embedded_status_text = NULL;\\r\\nchar failure_text[TS_STATUS_BUF_SIZE] = \"\";\\r\\nif (status == 0 || status == 1)\\r\\nreturn 1;\\r\\nif (0 <= status && status < (long)TS_STATUS_TEXT_SIZE)\\r\\nstatus_text = TS_status_text[status];\\r\\nelse\\r\\nstatus_text = \"unknown code\";\\r\\nif (sk_ASN1_UTF8STRING_num(info->text) > 0\\r\\n&& !(embedded_status_text = TS_get_status_text(info->text)))\\r\\nreturn 0;\\r\\nif (info->failure_info) {\\r\\nint i;\\r\\nint first = 1;\\r\\nfor (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i) {\\r\\nif (ASN1_BIT_STRING_get_bit(info->failure_info,\\r\\nTS_failure_info[i].code)) {\\r\\nif (!first)\\r\\nstrcpy(failure_text, \",\");\\r\\nelse\\r\\nfirst = 0;\\r\\nstrcat(failure_text, TS_failure_info[i].text);\\r\\n}\\r\\n}\\r\\n}\\r\\nif (failure_text[0] == '\\0')\\r\\nstrcpy(failure_text, \"unspecified\");\\r\\nTSerr(TS_F_TS_CHECK_STATUS_INFO, TS_R_NO_TIME_STAMP_TOKEN);\\r\\nERR_add_error_data(6,\\r\\n\"status code: \", status_text,\\r\\n\", status text: \", embedded_status_text ?\\r\\nembedded_status_text : \"unspecified\",\\r\\n\", failure codes: \", failure_text);\\r\\nOPENSSL_free(embedded_status_text);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int TS_check_policy(ASN1_OBJECT *req_oid, TS_TST_INFO *tst_info)\\r\\n{\\r\\nASN1_OBJECT *resp_oid = TS_TST_INFO_get_policy_id(tst_info);\\r\\nif (OBJ_cmp(req_oid, resp_oid) != 0) {\\r\\nTSerr(TS_F_TS_CHECK_POLICY, TS_R_POLICY_MISMATCH);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int TS_compute_imprint(BIO *data, TS_TST_INFO *tst_info,\\r\\nX509_ALGOR **md_alg,\\r\\nunsigned char **imprint, unsigned *imprint_len)\\r\\n{\\r\\nTS_MSG_IMPRINT *msg_imprint = TS_TST_INFO_get_msg_imprint(tst_info);\\r\\nX509_ALGOR *md_alg_resp = TS_MSG_IMPRINT_get_algo(msg_imprint);\\r\\nconst EVP_MD *md;\\r\\nEVP_MD_CTX md_ctx;\\r\\nunsigned char buffer[4096];\\r\\nint length;\\r\\n*md_alg = NULL;\\r\\n*imprint = NULL;\\r\\nif (!(*md_alg = X509_ALGOR_dup(md_alg_resp)))\\r\\ngoto err;\\r\\nif (!(md = EVP_get_digestbyobj((*md_alg)->algorithm))) {\\r\\nTSerr(TS_F_TS_COMPUTE_IMPRINT, TS_R_UNSUPPORTED_MD_ALGORITHM);\\r\\ngoto err;\\r\\n}\\r\\nlength = EVP_MD_size(md);\\r\\nif (length < 0)\\r\\ngoto err;\\r\\n*imprint_len = length;\\r\\nif (!(*imprint = OPENSSL_malloc(*imprint_len))) {\\r\\nTSerr(TS_F_TS_COMPUTE_IMPRINT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DigestInit(&md_ctx, md))\\r\\ngoto err;\\r\\nwhile ((length = BIO_read(data, buffer, sizeof(buffer))) > 0) {\\r\\nif (!EVP_DigestUpdate(&md_ctx, buffer, length))\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DigestFinal(&md_ctx, *imprint, NULL))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nX509_ALGOR_free(*md_alg);\\r\\nOPENSSL_free(*imprint);\\r\\n*imprint_len = 0;\\r\\n*imprint = 0;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int TS_check_imprints(X509_ALGOR *algor_a,\\r\\nunsigned char *imprint_a, unsigned len_a,\\r\\nTS_TST_INFO *tst_info)\\r\\n{\\r\\nTS_MSG_IMPRINT *b = TS_TST_INFO_get_msg_imprint(tst_info);\\r\\nX509_ALGOR *algor_b = TS_MSG_IMPRINT_get_algo(b);\\r\\nint ret = 0;\\r\\nif (algor_a) {\\r\\nif (OBJ_cmp(algor_a->algorithm, algor_b->algorithm))\\r\\ngoto err;\\r\\nif ((algor_a->parameter\\r\\n&& ASN1_TYPE_get(algor_a->parameter) != V_ASN1_NULL)\\r\\n|| (algor_b->parameter\\r\\n&& ASN1_TYPE_get(algor_b->parameter) != V_ASN1_NULL))\\r\\ngoto err;\\r\\n}\\r\\nret = len_a == (unsigned)ASN1_STRING_length(b->hashed_msg) &&\\r\\nmemcmp(imprint_a, ASN1_STRING_data(b->hashed_msg), len_a) == 0;\\r\\nerr:\\r\\nif (!ret)\\r\\nTSerr(TS_F_TS_CHECK_IMPRINTS, TS_R_MESSAGE_IMPRINT_MISMATCH);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int TS_check_nonces(const ASN1_INTEGER *a, TS_TST_INFO *tst_info)\\r\\n{\\r\\nconst ASN1_INTEGER *b = TS_TST_INFO_get_nonce(tst_info);\\r\\nif (!b) {\\r\\nTSerr(TS_F_TS_CHECK_NONCES, TS_R_NONCE_NOT_RETURNED);\\r\\nreturn 0;\\r\\n}\\r\\nif (ASN1_INTEGER_cmp(a, b) != 0) {\\r\\nTSerr(TS_F_TS_CHECK_NONCES, TS_R_NONCE_MISMATCH);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int TS_check_signer_name(GENERAL_NAME *tsa_name, X509 *signer)\\r\\n{\\r\\nSTACK_OF(GENERAL_NAME) *gen_names = NULL;\\r\\nint idx = -1;\\r\\nint found = 0;\\r\\nif (tsa_name->type == GEN_DIRNAME\\r\\n&& X509_name_cmp(tsa_name->d.dirn, signer->cert_info->subject) == 0)\\r\\nreturn 1;\\r\\ngen_names = X509_get_ext_d2i(signer, NID_subject_alt_name, NULL, &idx);\\r\\nwhile (gen_names != NULL\\r\\n&& !(found = TS_find_name(gen_names, tsa_name) >= 0)) {\\r\\nGENERAL_NAMES_free(gen_names);\\r\\ngen_names = X509_get_ext_d2i(signer, NID_subject_alt_name,\\r\\nNULL, &idx);\\r\\n}\\r\\nif (gen_names)\\r\\nGENERAL_NAMES_free(gen_names);\\r\\nreturn found;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_sd_c", "target": 0, "func": "static CMS_SignedData *cms_get0_signed(CMS_ContentInfo *cms)\\r\\n{\\r\\nif (OBJ_obj2nid(cms->contentType) != NID_pkcs7_signed) {\\r\\nCMSerr(CMS_F_CMS_GET0_SIGNED, CMS_R_CONTENT_TYPE_NOT_SIGNED_DATA);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn cms->d.signedData;\\r\\n}\\r\\nstatic CMS_SignedData *cms_signed_data_init(CMS_ContentInfo *cms)\\r\\n{\\r\\nif (cms->d.other == NULL) {\\r\\ncms->d.signedData = M_ASN1_new_of(CMS_SignedData);\\r\\nif (!cms->d.signedData) {\\r\\nCMSerr(CMS_F_CMS_SIGNED_DATA_INIT, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\ncms->d.signedData->version = 1;\\r\\ncms->d.signedData->encapContentInfo->eContentType =\\r\\nOBJ_nid2obj(NID_pkcs7_data);\\r\\ncms->d.signedData->encapContentInfo->partial = 1;\\r\\nASN1_OBJECT_free(cms->contentType);\\r\\ncms->contentType = OBJ_nid2obj(NID_pkcs7_signed);\\r\\nreturn cms->d.signedData;\\r\\n}\\r\\nreturn cms_get0_signed(cms);\\r\\n}\\r\\nint CMS_SignedData_init(CMS_ContentInfo *cms)\\r\\n{\\r\\nif (cms_signed_data_init(cms))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nstatic void cms_sd_set_version(CMS_SignedData *sd)\\r\\n{\\r\\nint i;\\r\\nCMS_CertificateChoices *cch;\\r\\nCMS_RevocationInfoChoice *rch;\\r\\nCMS_SignerInfo *si;\\r\\nfor (i = 0; i < sk_CMS_CertificateChoices_num(sd->certificates); i++) {\\r\\ncch = sk_CMS_CertificateChoices_value(sd->certificates, i);\\r\\nif (cch->type == CMS_CERTCHOICE_OTHER) {\\r\\nif (sd->version < 5)\\r\\nsd->version = 5;\\r\\n} else if (cch->type == CMS_CERTCHOICE_V2ACERT) {\\r\\nif (sd->version < 4)\\r\\nsd->version = 4;\\r\\n} else if (cch->type == CMS_CERTCHOICE_V1ACERT) {\\r\\nif (sd->version < 3)\\r\\nsd->version = 3;\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < sk_CMS_RevocationInfoChoice_num(sd->crls); i++) {\\r\\nrch = sk_CMS_RevocationInfoChoice_value(sd->crls, i);\\r\\nif (rch->type == CMS_REVCHOICE_OTHER) {\\r\\nif (sd->version < 5)\\r\\nsd->version = 5;\\r\\n}\\r\\n}\\r\\nif ((OBJ_obj2nid(sd->encapContentInfo->eContentType) != NID_pkcs7_data)\\r\\n&& (sd->version < 3))\\r\\nsd->version = 3;\\r\\nfor (i = 0; i < sk_CMS_SignerInfo_num(sd->signerInfos); i++) {\\r\\nsi = sk_CMS_SignerInfo_value(sd->signerInfos, i);\\r\\nif (si->sid->type == CMS_SIGNERINFO_KEYIDENTIFIER) {\\r\\nif (si->version < 3)\\r\\nsi->version = 3;\\r\\nif (sd->version < 3)\\r\\nsd->version = 3;\\r\\n} else if (si->version < 1)\\r\\nsi->version = 1;\\r\\n}\\r\\nif (sd->version < 1)\\r\\nsd->version = 1;\\r\\n}\\r\\nstatic int cms_copy_messageDigest(CMS_ContentInfo *cms, CMS_SignerInfo *si)\\r\\n{\\r\\nSTACK_OF(CMS_SignerInfo) *sinfos;\\r\\nCMS_SignerInfo *sitmp;\\r\\nint i;\\r\\nsinfos = CMS_get0_SignerInfos(cms);\\r\\nfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++) {\\r\\nASN1_OCTET_STRING *messageDigest;\\r\\nsitmp = sk_CMS_SignerInfo_value(sinfos, i);\\r\\nif (sitmp == si)\\r\\ncontinue;\\r\\nif (CMS_signed_get_attr_count(sitmp) < 0)\\r\\ncontinue;\\r\\nif (OBJ_cmp(si->digestAlgorithm->algorithm,\\r\\nsitmp->digestAlgorithm->algorithm))\\r\\ncontinue;\\r\\nmessageDigest = CMS_signed_get0_data_by_OBJ(sitmp,\\r\\nOBJ_nid2obj\\r\\n(NID_pkcs9_messageDigest),\\r\\n-3, V_ASN1_OCTET_STRING);\\r\\nif (!messageDigest) {\\r\\nCMSerr(CMS_F_CMS_COPY_MESSAGEDIGEST,\\r\\nCMS_R_ERROR_READING_MESSAGEDIGEST_ATTRIBUTE);\\r\\nreturn 0;\\r\\n}\\r\\nif (CMS_signed_add1_attr_by_NID(si, NID_pkcs9_messageDigest,\\r\\nV_ASN1_OCTET_STRING,\\r\\nmessageDigest, -1))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nCMSerr(CMS_F_CMS_COPY_MESSAGEDIGEST, CMS_R_NO_MATCHING_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nint cms_set1_SignerIdentifier(CMS_SignerIdentifier *sid, X509 *cert, int type)\\r\\n{\\r\\nswitch (type) {\\r\\ncase CMS_SIGNERINFO_ISSUER_SERIAL:\\r\\nif (!cms_set1_ias(&sid->d.issuerAndSerialNumber, cert))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase CMS_SIGNERINFO_KEYIDENTIFIER:\\r\\nif (!cms_set1_keyid(&sid->d.subjectKeyIdentifier, cert))\\r\\nreturn 0;\\r\\nbreak;\\r\\ndefault:\\r\\nCMSerr(CMS_F_CMS_SET1_SIGNERIDENTIFIER, CMS_R_UNKNOWN_ID);\\r\\nreturn 0;\\r\\n}\\r\\nsid->type = type;\\r\\nreturn 1;\\r\\n}\\r\\nint cms_SignerIdentifier_get0_signer_id(CMS_SignerIdentifier *sid,\\r\\nASN1_OCTET_STRING **keyid,\\r\\nX509_NAME **issuer,\\r\\nASN1_INTEGER **sno)\\r\\n{\\r\\nif (sid->type == CMS_SIGNERINFO_ISSUER_SERIAL) {\\r\\nif (issuer)\\r\\n*issuer = sid->d.issuerAndSerialNumber->issuer;\\r\\nif (sno)\\r\\n*sno = sid->d.issuerAndSerialNumber->serialNumber;\\r\\n} else if (sid->type == CMS_SIGNERINFO_KEYIDENTIFIER) {\\r\\nif (keyid)\\r\\n*keyid = sid->d.subjectKeyIdentifier;\\r\\n} else\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint cms_SignerIdentifier_cert_cmp(CMS_SignerIdentifier *sid, X509 *cert)\\r\\n{\\r\\nif (sid->type == CMS_SIGNERINFO_ISSUER_SERIAL)\\r\\nreturn cms_ias_cert_cmp(sid->d.issuerAndSerialNumber, cert);\\r\\nelse if (sid->type == CMS_SIGNERINFO_KEYIDENTIFIER)\\r\\nreturn cms_keyid_cert_cmp(sid->d.subjectKeyIdentifier, cert);\\r\\nelse\\r\\nreturn -1;\\r\\n}\\r\\nstatic int cms_sd_asn1_ctrl(CMS_SignerInfo *si, int cmd)\\r\\n{\\r\\nEVP_PKEY *pkey = si->pkey;\\r\\nint i;\\r\\nif (!pkey->ameth || !pkey->ameth->pkey_ctrl)\\r\\nreturn 1;\\r\\ni = pkey->ameth->pkey_ctrl(pkey, ASN1_PKEY_CTRL_CMS_SIGN, cmd, si);\\r\\nif (i == -2) {\\r\\nCMSerr(CMS_F_CMS_SD_ASN1_CTRL, CMS_R_NOT_SUPPORTED_FOR_THIS_KEY_TYPE);\\r\\nreturn 0;\\r\\n}\\r\\nif (i <= 0) {\\r\\nCMSerr(CMS_F_CMS_SD_ASN1_CTRL, CMS_R_CTRL_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nCMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,\\r\\nX509 *signer, EVP_PKEY *pk, const EVP_MD *md,\\r\\nunsigned int flags)\\r\\n{\\r\\nCMS_SignedData *sd;\\r\\nCMS_SignerInfo *si = NULL;\\r\\nX509_ALGOR *alg;\\r\\nint i, type;\\r\\nif (!X509_check_private_key(signer, pk)) {\\r\\nCMSerr(CMS_F_CMS_ADD1_SIGNER,\\r\\nCMS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);\\r\\nreturn NULL;\\r\\n}\\r\\nsd = cms_signed_data_init(cms);\\r\\nif (!sd)\\r\\ngoto err;\\r\\nsi = M_ASN1_new_of(CMS_SignerInfo);\\r\\nif (!si)\\r\\ngoto merr;\\r\\nX509_check_purpose(signer, -1, -1);\\r\\nCRYPTO_add(&pk->references, 1, CRYPTO_LOCK_EVP_PKEY);\\r\\nCRYPTO_add(&signer->references, 1, CRYPTO_LOCK_X509);\\r\\nsi->pkey = pk;\\r\\nsi->signer = signer;\\r\\nEVP_MD_CTX_init(&si->mctx);\\r\\nsi->pctx = NULL;\\r\\nif (flags & CMS_USE_KEYID) {\\r\\nsi->version = 3;\\r\\nif (sd->version < 3)\\r\\nsd->version = 3;\\r\\ntype = CMS_SIGNERINFO_KEYIDENTIFIER;\\r\\n} else {\\r\\ntype = CMS_SIGNERINFO_ISSUER_SERIAL;\\r\\nsi->version = 1;\\r\\n}\\r\\nif (!cms_set1_SignerIdentifier(si->sid, signer, type))\\r\\ngoto err;\\r\\nif (md == NULL) {\\r\\nint def_nid;\\r\\nif (EVP_PKEY_get_default_digest_nid(pk, &def_nid) <= 0)\\r\\ngoto err;\\r\\nmd = EVP_get_digestbynid(def_nid);\\r\\nif (md == NULL) {\\r\\nCMSerr(CMS_F_CMS_ADD1_SIGNER, CMS_R_NO_DEFAULT_DIGEST);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!md) {\\r\\nCMSerr(CMS_F_CMS_ADD1_SIGNER, CMS_R_NO_DIGEST_SET);\\r\\ngoto err;\\r\\n}\\r\\ncms_DigestAlgorithm_set(si->digestAlgorithm, md);\\r\\nfor (i = 0; i < sk_X509_ALGOR_num(sd->digestAlgorithms); i++) {\\r\\nASN1_OBJECT *aoid;\\r\\nalg = sk_X509_ALGOR_value(sd->digestAlgorithms, i);\\r\\nX509_ALGOR_get0(&aoid, NULL, NULL, alg);\\r\\nif (OBJ_obj2nid(aoid) == EVP_MD_type(md))\\r\\nbreak;\\r\\n}\\r\\nif (i == sk_X509_ALGOR_num(sd->digestAlgorithms)) {\\r\\nalg = X509_ALGOR_new();\\r\\nif (!alg)\\r\\ngoto merr;\\r\\ncms_DigestAlgorithm_set(alg, md);\\r\\nif (!sk_X509_ALGOR_push(sd->digestAlgorithms, alg)) {\\r\\nX509_ALGOR_free(alg);\\r\\ngoto merr;\\r\\n}\\r\\n}\\r\\nif (!(flags & CMS_KEY_PARAM) && !cms_sd_asn1_ctrl(si, 0))\\r\\ngoto err;\\r\\nif (!(flags & CMS_NOATTR)) {\\r\\nif (!si->signedAttrs) {\\r\\nsi->signedAttrs = sk_X509_ATTRIBUTE_new_null();\\r\\nif (!si->signedAttrs)\\r\\ngoto merr;\\r\\n}\\r\\nif (!(flags & CMS_NOSMIMECAP)) {\\r\\nSTACK_OF(X509_ALGOR) *smcap = NULL;\\r\\ni = CMS_add_standard_smimecap(&smcap);\\r\\nif (i)\\r\\ni = CMS_add_smimecap(si, smcap);\\r\\nsk_X509_ALGOR_pop_free(smcap, X509_ALGOR_free);\\r\\nif (!i)\\r\\ngoto merr;\\r\\n}\\r\\nif (flags & CMS_REUSE_DIGEST) {\\r\\nif (!cms_copy_messageDigest(cms, si))\\r\\ngoto err;\\r\\nif (!(flags & (CMS_PARTIAL | CMS_KEY_PARAM)) &&\\r\\n!CMS_SignerInfo_sign(si))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!(flags & CMS_NOCERTS)) {\\r\\nif (!CMS_add1_cert(cms, signer))\\r\\ngoto merr;\\r\\n}\\r\\nif (flags & CMS_KEY_PARAM) {\\r\\nif (flags & CMS_NOATTR) {\\r\\nsi->pctx = EVP_PKEY_CTX_new(si->pkey, NULL);\\r\\nif (!si->pctx)\\r\\ngoto err;\\r\\nif (EVP_PKEY_sign_init(si->pctx) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set_signature_md(si->pctx, md) <= 0)\\r\\ngoto err;\\r\\n} else if (EVP_DigestSignInit(&si->mctx, &si->pctx, md, NULL, pk) <=\\r\\n0)\\r\\ngoto err;\\r\\n}\\r\\nif (!sd->signerInfos)\\r\\nsd->signerInfos = sk_CMS_SignerInfo_new_null();\\r\\nif (!sd->signerInfos || !sk_CMS_SignerInfo_push(sd->signerInfos, si))\\r\\ngoto merr;\\r\\nreturn si;\\r\\nmerr:\\r\\nCMSerr(CMS_F_CMS_ADD1_SIGNER, ERR_R_MALLOC_FAILURE);\\r\\nerr:\\r\\nif (si)\\r\\nM_ASN1_free_of(si, CMS_SignerInfo);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int cms_add1_signingTime(CMS_SignerInfo *si, ASN1_TIME *t)\\r\\n{\\r\\nASN1_TIME *tt;\\r\\nint r = 0;\\r\\nif (t)\\r\\ntt = t;\\r\\nelse\\r\\ntt = X509_gmtime_adj(NULL, 0);\\r\\nif (!tt)\\r\\ngoto merr;\\r\\nif (CMS_signed_add1_attr_by_NID(si, NID_pkcs9_signingTime,\\r\\ntt->type, tt, -1) <= 0)\\r\\ngoto merr;\\r\\nr = 1;\\r\\nmerr:\\r\\nif (!t)\\r\\nASN1_TIME_free(tt);\\r\\nif (!r)\\r\\nCMSerr(CMS_F_CMS_ADD1_SIGNINGTIME, ERR_R_MALLOC_FAILURE);\\r\\nreturn r;\\r\\n}\\r\\nEVP_PKEY_CTX *CMS_SignerInfo_get0_pkey_ctx(CMS_SignerInfo *si)\\r\\n{\\r\\nreturn si->pctx;\\r\\n}\\r\\nEVP_MD_CTX *CMS_SignerInfo_get0_md_ctx(CMS_SignerInfo *si)\\r\\n{\\r\\nreturn &si->mctx;\\r\\n}\\r\\nint CMS_SignerInfo_get0_signer_id(CMS_SignerInfo *si,\\r\\nASN1_OCTET_STRING **keyid,\\r\\nX509_NAME **issuer, ASN1_INTEGER **sno)\\r\\n{\\r\\nreturn cms_SignerIdentifier_get0_signer_id(si->sid, keyid, issuer, sno);\\r\\n}\\r\\nint CMS_SignerInfo_cert_cmp(CMS_SignerInfo *si, X509 *cert)\\r\\n{\\r\\nreturn cms_SignerIdentifier_cert_cmp(si->sid, cert);\\r\\n}\\r\\nvoid CMS_SignerInfo_get0_algs(CMS_SignerInfo *si, EVP_PKEY **pk,\\r\\nX509 **signer, X509_ALGOR **pdig,\\r\\nX509_ALGOR **psig)\\r\\n{\\r\\nif (pk)\\r\\n*pk = si->pkey;\\r\\nif (signer)\\r\\n*signer = si->signer;\\r\\nif (pdig)\\r\\n*pdig = si->digestAlgorithm;\\r\\nif (psig)\\r\\n*psig = si->signatureAlgorithm;\\r\\n}\\r\\nASN1_OCTET_STRING *CMS_SignerInfo_get0_signature(CMS_SignerInfo *si)\\r\\n{\\r\\nreturn si->signature;\\r\\n}\\r\\nstatic int cms_SignerInfo_content_sign(CMS_ContentInfo *cms,\\r\\nCMS_SignerInfo *si, BIO *chain)\\r\\n{\\r\\nEVP_MD_CTX mctx;\\r\\nint r = 0;\\r\\nEVP_PKEY_CTX *pctx = NULL;\\r\\nEVP_MD_CTX_init(&mctx);\\r\\nif (!si->pkey) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, CMS_R_NO_PRIVATE_KEY);\\r\\nreturn 0;\\r\\n}\\r\\nif (!cms_DigestAlgorithm_find_ctx(&mctx, chain, si->digestAlgorithm))\\r\\ngoto err;\\r\\nif (si->pctx && !cms_sd_asn1_ctrl(si, 0))\\r\\ngoto err;\\r\\nif (CMS_signed_get_attr_count(si) >= 0) {\\r\\nASN1_OBJECT *ctype =\\r\\ncms->d.signedData->encapContentInfo->eContentType;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nunsigned int mdlen;\\r\\nif (!EVP_DigestFinal_ex(&mctx, md, &mdlen))\\r\\ngoto err;\\r\\nif (!CMS_signed_add1_attr_by_NID(si, NID_pkcs9_messageDigest,\\r\\nV_ASN1_OCTET_STRING, md, mdlen))\\r\\ngoto err;\\r\\nif (CMS_signed_add1_attr_by_NID(si, NID_pkcs9_contentType,\\r\\nV_ASN1_OBJECT, ctype, -1) <= 0)\\r\\ngoto err;\\r\\nif (!CMS_SignerInfo_sign(si))\\r\\ngoto err;\\r\\n} else if (si->pctx) {\\r\\nunsigned char *sig;\\r\\nsize_t siglen;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nunsigned int mdlen;\\r\\npctx = si->pctx;\\r\\nif (!EVP_DigestFinal_ex(&mctx, md, &mdlen))\\r\\ngoto err;\\r\\nsiglen = EVP_PKEY_size(si->pkey);\\r\\nsig = OPENSSL_malloc(siglen);\\r\\nif (!sig) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_sign(pctx, sig, &siglen, md, mdlen) <= 0)\\r\\ngoto err;\\r\\nASN1_STRING_set0(si->signature, sig, siglen);\\r\\n} else {\\r\\nunsigned char *sig;\\r\\nunsigned int siglen;\\r\\nsig = OPENSSL_malloc(EVP_PKEY_size(si->pkey));\\r\\nif (!sig) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_SignFinal(&mctx, sig, &siglen, si->pkey)) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_CONTENT_SIGN, CMS_R_SIGNFINAL_ERROR);\\r\\nOPENSSL_free(sig);\\r\\ngoto err;\\r\\n}\\r\\nASN1_STRING_set0(si->signature, sig, siglen);\\r\\n}\\r\\nr = 1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&mctx);\\r\\nif (pctx)\\r\\nEVP_PKEY_CTX_free(pctx);\\r\\nreturn r;\\r\\n}\\r\\nint cms_SignedData_final(CMS_ContentInfo *cms, BIO *chain)\\r\\n{\\r\\nSTACK_OF(CMS_SignerInfo) *sinfos;\\r\\nCMS_SignerInfo *si;\\r\\nint i;\\r\\nsinfos = CMS_get0_SignerInfos(cms);\\r\\nfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++) {\\r\\nsi = sk_CMS_SignerInfo_value(sinfos, i);\\r\\nif (!cms_SignerInfo_content_sign(cms, si, chain))\\r\\nreturn 0;\\r\\n}\\r\\ncms->d.signedData->encapContentInfo->partial = 0;\\r\\nreturn 1;\\r\\n}\\r\\nint CMS_SignerInfo_sign(CMS_SignerInfo *si)\\r\\n{\\r\\nEVP_MD_CTX *mctx = &si->mctx;\\r\\nEVP_PKEY_CTX *pctx;\\r\\nunsigned char *abuf = NULL;\\r\\nint alen;\\r\\nsize_t siglen;\\r\\nconst EVP_MD *md = NULL;\\r\\nmd = EVP_get_digestbyobj(si->digestAlgorithm->algorithm);\\r\\nif (md == NULL)\\r\\nreturn 0;\\r\\nif (CMS_signed_get_attr_by_NID(si, NID_pkcs9_signingTime, -1) < 0) {\\r\\nif (!cms_add1_signingTime(si, NULL))\\r\\ngoto err;\\r\\n}\\r\\nif (si->pctx)\\r\\npctx = si->pctx;\\r\\nelse {\\r\\nEVP_MD_CTX_init(mctx);\\r\\nif (EVP_DigestSignInit(mctx, &pctx, md, NULL, si->pkey) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\\r\\nEVP_PKEY_CTRL_CMS_SIGN, 0, si) <= 0) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_SIGN, CMS_R_CTRL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nalen = ASN1_item_i2d((ASN1_VALUE *)si->signedAttrs, &abuf,\\r\\nASN1_ITEM_rptr(CMS_Attributes_Sign));\\r\\nif (!abuf)\\r\\ngoto err;\\r\\nif (EVP_DigestSignUpdate(mctx, abuf, alen) <= 0)\\r\\ngoto err;\\r\\nif (EVP_DigestSignFinal(mctx, NULL, &siglen) <= 0)\\r\\ngoto err;\\r\\nOPENSSL_free(abuf);\\r\\nabuf = OPENSSL_malloc(siglen);\\r\\nif (!abuf)\\r\\ngoto err;\\r\\nif (EVP_DigestSignFinal(mctx, abuf, &siglen) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\\r\\nEVP_PKEY_CTRL_CMS_SIGN, 1, si) <= 0) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_SIGN, CMS_R_CTRL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nEVP_MD_CTX_cleanup(mctx);\\r\\nASN1_STRING_set0(si->signature, abuf, siglen);\\r\\nreturn 1;\\r\\nerr:\\r\\nif (abuf)\\r\\nOPENSSL_free(abuf);\\r\\nEVP_MD_CTX_cleanup(mctx);\\r\\nreturn 0;\\r\\n}\\r\\nint CMS_SignerInfo_verify(CMS_SignerInfo *si)\\r\\n{\\r\\nEVP_MD_CTX *mctx = &si->mctx;\\r\\nunsigned char *abuf = NULL;\\r\\nint alen, r = -1;\\r\\nconst EVP_MD *md = NULL;\\r\\nif (!si->pkey) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_VERIFY, CMS_R_NO_PUBLIC_KEY);\\r\\nreturn -1;\\r\\n}\\r\\nmd = EVP_get_digestbyobj(si->digestAlgorithm->algorithm);\\r\\nif (md == NULL)\\r\\nreturn -1;\\r\\nEVP_MD_CTX_init(mctx);\\r\\nif (EVP_DigestVerifyInit(mctx, &si->pctx, md, NULL, si->pkey) <= 0)\\r\\ngoto err;\\r\\nif (!cms_sd_asn1_ctrl(si, 1))\\r\\ngoto err;\\r\\nalen = ASN1_item_i2d((ASN1_VALUE *)si->signedAttrs, &abuf,\\r\\nASN1_ITEM_rptr(CMS_Attributes_Verify));\\r\\nif (!abuf)\\r\\ngoto err;\\r\\nr = EVP_DigestVerifyUpdate(mctx, abuf, alen);\\r\\nOPENSSL_free(abuf);\\r\\nif (r <= 0) {\\r\\nr = -1;\\r\\ngoto err;\\r\\n}\\r\\nr = EVP_DigestVerifyFinal(mctx,\\r\\nsi->signature->data, si->signature->length);\\r\\nif (r <= 0)\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_VERIFY, CMS_R_VERIFICATION_FAILURE);\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(mctx);\\r\\nreturn r;\\r\\n}\\r\\nBIO *cms_SignedData_init_bio(CMS_ContentInfo *cms)\\r\\n{\\r\\nint i;\\r\\nCMS_SignedData *sd;\\r\\nBIO *chain = NULL;\\r\\nsd = cms_get0_signed(cms);\\r\\nif (!sd)\\r\\nreturn NULL;\\r\\nif (cms->d.signedData->encapContentInfo->partial)\\r\\ncms_sd_set_version(sd);\\r\\nfor (i = 0; i < sk_X509_ALGOR_num(sd->digestAlgorithms); i++) {\\r\\nX509_ALGOR *digestAlgorithm;\\r\\nBIO *mdbio;\\r\\ndigestAlgorithm = sk_X509_ALGOR_value(sd->digestAlgorithms, i);\\r\\nmdbio = cms_DigestAlgorithm_init_bio(digestAlgorithm);\\r\\nif (!mdbio)\\r\\ngoto err;\\r\\nif (chain)\\r\\nBIO_push(chain, mdbio);\\r\\nelse\\r\\nchain = mdbio;\\r\\n}\\r\\nreturn chain;\\r\\nerr:\\r\\nif (chain)\\r\\nBIO_free_all(chain);\\r\\nreturn NULL;\\r\\n}\\r\\nint CMS_SignerInfo_verify_content(CMS_SignerInfo *si, BIO *chain)\\r\\n{\\r\\nASN1_OCTET_STRING *os = NULL;\\r\\nEVP_MD_CTX mctx;\\r\\nEVP_PKEY_CTX *pkctx = NULL;\\r\\nint r = -1;\\r\\nunsigned char mval[EVP_MAX_MD_SIZE];\\r\\nunsigned int mlen;\\r\\nEVP_MD_CTX_init(&mctx);\\r\\nif (CMS_signed_get_attr_count(si) >= 0) {\\r\\nos = CMS_signed_get0_data_by_OBJ(si,\\r\\nOBJ_nid2obj(NID_pkcs9_messageDigest),\\r\\n-3, V_ASN1_OCTET_STRING);\\r\\nif (!os) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,\\r\\nCMS_R_ERROR_READING_MESSAGEDIGEST_ATTRIBUTE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!cms_DigestAlgorithm_find_ctx(&mctx, chain, si->digestAlgorithm))\\r\\ngoto err;\\r\\nif (EVP_DigestFinal_ex(&mctx, mval, &mlen) <= 0) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,\\r\\nCMS_R_UNABLE_TO_FINALIZE_CONTEXT);\\r\\ngoto err;\\r\\n}\\r\\nif (os) {\\r\\nif (mlen != (unsigned int)os->length) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,\\r\\nCMS_R_MESSAGEDIGEST_ATTRIBUTE_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nif (memcmp(mval, os->data, mlen)) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,\\r\\nCMS_R_VERIFICATION_FAILURE);\\r\\nr = 0;\\r\\n} else\\r\\nr = 1;\\r\\n} else {\\r\\nconst EVP_MD *md = EVP_MD_CTX_md(&mctx);\\r\\npkctx = EVP_PKEY_CTX_new(si->pkey, NULL);\\r\\nif (EVP_PKEY_verify_init(pkctx) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set_signature_md(pkctx, md) <= 0)\\r\\ngoto err;\\r\\nsi->pctx = pkctx;\\r\\nif (!cms_sd_asn1_ctrl(si, 1))\\r\\ngoto err;\\r\\nr = EVP_PKEY_verify(pkctx, si->signature->data,\\r\\nsi->signature->length, mval, mlen);\\r\\nif (r <= 0) {\\r\\nCMSerr(CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT,\\r\\nCMS_R_VERIFICATION_FAILURE);\\r\\nr = 0;\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (pkctx)\\r\\nEVP_PKEY_CTX_free(pkctx);\\r\\nEVP_MD_CTX_cleanup(&mctx);\\r\\nreturn r;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_buf_err_c", "target": 0, "func": "void ERR_load_BUF_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(BUF_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, BUF_str_functs);\\r\\nERR_load_strings(0, BUF_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cbc128_c", "target": 0, "func": "void CRYPTO_cbc128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16], block128_f block)\\r\\n{\\r\\nsize_t n;\\r\\nconst unsigned char *iv = ivec;\\r\\nassert(in && out && key && ivec);\\r\\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nif (STRICT_ALIGNMENT &&\\r\\n((size_t)in | (size_t)out | (size_t)ivec) % sizeof(size_t) != 0) {\\r\\nwhile (len >= 16) {\\r\\nfor (n = 0; n < 16; ++n)\\r\\nout[n] = in[n] ^ iv[n];\\r\\n(*block) (out, out, key);\\r\\niv = out;\\r\\nlen -= 16;\\r\\nin += 16;\\r\\nout += 16;\\r\\n}\\r\\n} else {\\r\\nwhile (len >= 16) {\\r\\nfor (n = 0; n < 16; n += sizeof(size_t))\\r\\n*(size_t *)(out + n) =\\r\\n*(size_t *)(in + n) ^ *(size_t *)(iv + n);\\r\\n(*block) (out, out, key);\\r\\niv = out;\\r\\nlen -= 16;\\r\\nin += 16;\\r\\nout += 16;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nwhile (len) {\\r\\nfor (n = 0; n < 16 && n < len; ++n)\\r\\nout[n] = in[n] ^ iv[n];\\r\\nfor (; n < 16; ++n)\\r\\nout[n] = iv[n];\\r\\n(*block) (out, out, key);\\r\\niv = out;\\r\\nif (len <= 16)\\r\\nbreak;\\r\\nlen -= 16;\\r\\nin += 16;\\r\\nout += 16;\\r\\n}\\r\\nmemcpy(ivec, iv, 16);\\r\\n}\\r\\nvoid CRYPTO_cbc128_decrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16], block128_f block)\\r\\n{\\r\\nsize_t n;\\r\\nunion {\\r\\nsize_t t[16 / sizeof(size_t)];\\r\\nunsigned char c[16];\\r\\n} tmp;\\r\\nassert(in && out && key && ivec);\\r\\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nif (in != out) {\\r\\nconst unsigned char *iv = ivec;\\r\\nif (STRICT_ALIGNMENT &&\\r\\n((size_t)in | (size_t)out | (size_t)ivec) % sizeof(size_t) != 0) {\\r\\nwhile (len >= 16) {\\r\\n(*block) (in, out, key);\\r\\nfor (n = 0; n < 16; ++n)\\r\\nout[n] ^= iv[n];\\r\\niv = in;\\r\\nlen -= 16;\\r\\nin += 16;\\r\\nout += 16;\\r\\n}\\r\\n} else if (16 % sizeof(size_t) == 0) {\\r\\nwhile (len >= 16) {\\r\\nsize_t *out_t = (size_t *)out, *iv_t = (size_t *)iv;\\r\\n(*block) (in, out, key);\\r\\nfor (n = 0; n < 16 / sizeof(size_t); n++)\\r\\nout_t[n] ^= iv_t[n];\\r\\niv = in;\\r\\nlen -= 16;\\r\\nin += 16;\\r\\nout += 16;\\r\\n}\\r\\n}\\r\\nmemcpy(ivec, iv, 16);\\r\\n} else {\\r\\nif (STRICT_ALIGNMENT &&\\r\\n((size_t)in | (size_t)out | (size_t)ivec) % sizeof(size_t) != 0) {\\r\\nunsigned char c;\\r\\nwhile (len >= 16) {\\r\\n(*block) (in, tmp.c, key);\\r\\nfor (n = 0; n < 16; ++n) {\\r\\nc = in[n];\\r\\nout[n] = tmp.c[n] ^ ivec[n];\\r\\nivec[n] = c;\\r\\n}\\r\\nlen -= 16;\\r\\nin += 16;\\r\\nout += 16;\\r\\n}\\r\\n} else if (16 % sizeof(size_t) == 0) {\\r\\nwhile (len >= 16) {\\r\\nsize_t c, *out_t = (size_t *)out, *ivec_t = (size_t *)ivec;\\r\\nconst size_t *in_t = (const size_t *)in;\\r\\n(*block) (in, tmp.c, key);\\r\\nfor (n = 0; n < 16 / sizeof(size_t); n++) {\\r\\nc = in_t[n];\\r\\nout_t[n] = tmp.t[n] ^ ivec_t[n];\\r\\nivec_t[n] = c;\\r\\n}\\r\\nlen -= 16;\\r\\nin += 16;\\r\\nout += 16;\\r\\n}\\r\\n}\\r\\n}\\r\\n#endif\\r\\nwhile (len) {\\r\\nunsigned char c;\\r\\n(*block) (in, tmp.c, key);\\r\\nfor (n = 0; n < 16 && n < len; ++n) {\\r\\nc = in[n];\\r\\nout[n] = tmp.c[n] ^ ivec[n];\\r\\nivec[n] = c;\\r\\n}\\r\\nif (len <= 16) {\\r\\nfor (; n < 16; ++n)\\r\\nivec[n] = in[n];\\r\\nbreak;\\r\\n}\\r\\nlen -= 16;\\r\\nin += 16;\\r\\nout += 16;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_camellia_c", "target": 0, "func": "int Camellia_Ekeygen(int keyBitLength, const u8 *rawKey, KEY_TABLE_TYPE k)\\r\\n{\\r\\nregister u32 s0, s1, s2, s3;\\r\\nk[0] = s0 = GETU32(rawKey);\\r\\nk[1] = s1 = GETU32(rawKey + 4);\\r\\nk[2] = s2 = GETU32(rawKey + 8);\\r\\nk[3] = s3 = GETU32(rawKey + 12);\\r\\nif (keyBitLength != 128) {\\r\\nk[8] = s0 = GETU32(rawKey + 16);\\r\\nk[9] = s1 = GETU32(rawKey + 20);\\r\\nif (keyBitLength == 192) {\\r\\nk[10] = s2 = ~s0;\\r\\nk[11] = s3 = ~s1;\\r\\n} else {\\r\\nk[10] = s2 = GETU32(rawKey + 24);\\r\\nk[11] = s3 = GETU32(rawKey + 28);\\r\\n}\\r\\ns0 ^= k[0], s1 ^= k[1], s2 ^= k[2], s3 ^= k[3];\\r\\n}\\r\\nCamellia_Feistel(s0, s1, s2, s3, SIGMA + 0);\\r\\nCamellia_Feistel(s2, s3, s0, s1, SIGMA + 2);\\r\\ns0 ^= k[0], s1 ^= k[1], s2 ^= k[2], s3 ^= k[3];\\r\\nCamellia_Feistel(s0, s1, s2, s3, SIGMA + 4);\\r\\nCamellia_Feistel(s2, s3, s0, s1, SIGMA + 6);\\r\\nif (keyBitLength == 128) {\\r\\nk[4] = s0, k[5] = s1, k[6] = s2, k[7] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 15);\\r\\nk[12] = s0, k[13] = s1, k[14] = s2, k[15] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 15);\\r\\nk[16] = s0, k[17] = s1, k[18] = s2, k[19] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 15);\\r\\nk[24] = s0, k[25] = s1;\\r\\nRotLeft128(s0, s1, s2, s3, 15);\\r\\nk[28] = s0, k[29] = s1, k[30] = s2, k[31] = s3;\\r\\nRotLeft128(s1, s2, s3, s0, 2);\\r\\nk[40] = s1, k[41] = s2, k[42] = s3, k[43] = s0;\\r\\nRotLeft128(s1, s2, s3, s0, 17);\\r\\nk[48] = s1, k[49] = s2, k[50] = s3, k[51] = s0;\\r\\ns0 = k[0], s1 = k[1], s2 = k[2], s3 = k[3];\\r\\nRotLeft128(s0, s1, s2, s3, 15);\\r\\nk[8] = s0, k[9] = s1, k[10] = s2, k[11] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 30);\\r\\nk[20] = s0, k[21] = s1, k[22] = s2, k[23] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 15);\\r\\nk[26] = s2, k[27] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 17);\\r\\nk[32] = s0, k[33] = s1, k[34] = s2, k[35] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 17);\\r\\nk[36] = s0, k[37] = s1, k[38] = s2, k[39] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 17);\\r\\nk[44] = s0, k[45] = s1, k[46] = s2, k[47] = s3;\\r\\nreturn 3;\\r\\n} else {\\r\\nk[12] = s0, k[13] = s1, k[14] = s2, k[15] = s3;\\r\\ns0 ^= k[8], s1 ^= k[9], s2 ^= k[10], s3 ^= k[11];\\r\\nCamellia_Feistel(s0, s1, s2, s3, (SIGMA + 8));\\r\\nCamellia_Feistel(s2, s3, s0, s1, (SIGMA + 10));\\r\\nk[4] = s0, k[5] = s1, k[6] = s2, k[7] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 30);\\r\\nk[20] = s0, k[21] = s1, k[22] = s2, k[23] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 30);\\r\\nk[40] = s0, k[41] = s1, k[42] = s2, k[43] = s3;\\r\\nRotLeft128(s1, s2, s3, s0, 19);\\r\\nk[64] = s1, k[65] = s2, k[66] = s3, k[67] = s0;\\r\\ns0 = k[8], s1 = k[9], s2 = k[10], s3 = k[11];\\r\\nRotLeft128(s0, s1, s2, s3, 15);\\r\\nk[8] = s0, k[9] = s1, k[10] = s2, k[11] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 15);\\r\\nk[16] = s0, k[17] = s1, k[18] = s2, k[19] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 30);\\r\\nk[36] = s0, k[37] = s1, k[38] = s2, k[39] = s3;\\r\\nRotLeft128(s1, s2, s3, s0, 2);\\r\\nk[52] = s1, k[53] = s2, k[54] = s3, k[55] = s0;\\r\\ns0 = k[12], s1 = k[13], s2 = k[14], s3 = k[15];\\r\\nRotLeft128(s0, s1, s2, s3, 15);\\r\\nk[12] = s0, k[13] = s1, k[14] = s2, k[15] = s3;\\r\\nRotLeft128(s0, s1, s2, s3, 30);\\r\\nk[28] = s0, k[29] = s1, k[30] = s2, k[31] = s3;\\r\\nk[48] = s1, k[49] = s2, k[50] = s3, k[51] = s0;\\r\\nRotLeft128(s1, s2, s3, s0, 17);\\r\\nk[56] = s1, k[57] = s2, k[58] = s3, k[59] = s0;\\r\\ns0 = k[0], s1 = k[1], s2 = k[2], s3 = k[3];\\r\\nRotLeft128(s1, s2, s3, s0, 13);\\r\\nk[24] = s1, k[25] = s2, k[26] = s3, k[27] = s0;\\r\\nRotLeft128(s1, s2, s3, s0, 15);\\r\\nk[32] = s1, k[33] = s2, k[34] = s3, k[35] = s0;\\r\\nRotLeft128(s1, s2, s3, s0, 17);\\r\\nk[44] = s1, k[45] = s2, k[46] = s3, k[47] = s0;\\r\\nRotLeft128(s2, s3, s0, s1, 2);\\r\\nk[60] = s2, k[61] = s3, k[62] = s0, k[63] = s1;\\r\\nreturn 4;\\r\\n}\\r\\n}\\r\\nvoid Camellia_EncryptBlock_Rounds(int grandRounds, const u8 plaintext[],\\r\\nconst KEY_TABLE_TYPE keyTable,\\r\\nu8 ciphertext[])\\r\\n{\\r\\nregister u32 s0, s1, s2, s3;\\r\\nconst u32 *k = keyTable, *kend = keyTable + grandRounds * 16;\\r\\ns0 = GETU32(plaintext) ^ k[0];\\r\\ns1 = GETU32(plaintext + 4) ^ k[1];\\r\\ns2 = GETU32(plaintext + 8) ^ k[2];\\r\\ns3 = GETU32(plaintext + 12) ^ k[3];\\r\\nk += 4;\\r\\nwhile (1) {\\r\\nCamellia_Feistel(s0, s1, s2, s3, k + 0);\\r\\nCamellia_Feistel(s2, s3, s0, s1, k + 2);\\r\\nCamellia_Feistel(s0, s1, s2, s3, k + 4);\\r\\nCamellia_Feistel(s2, s3, s0, s1, k + 6);\\r\\nCamellia_Feistel(s0, s1, s2, s3, k + 8);\\r\\nCamellia_Feistel(s2, s3, s0, s1, k + 10);\\r\\nk += 12;\\r\\nif (k == kend)\\r\\nbreak;\\r\\ns1 ^= LeftRotate(s0 & k[0], 1);\\r\\ns2 ^= s3 | k[3];\\r\\ns0 ^= s1 | k[1];\\r\\ns3 ^= LeftRotate(s2 & k[2], 1);\\r\\nk += 4;\\r\\n}\\r\\ns2 ^= k[0], s3 ^= k[1], s0 ^= k[2], s1 ^= k[3];\\r\\nPUTU32(ciphertext, s2);\\r\\nPUTU32(ciphertext + 4, s3);\\r\\nPUTU32(ciphertext + 8, s0);\\r\\nPUTU32(ciphertext + 12, s1);\\r\\n}\\r\\nvoid Camellia_EncryptBlock(int keyBitLength, const u8 plaintext[],\\r\\nconst KEY_TABLE_TYPE keyTable, u8 ciphertext[])\\r\\n{\\r\\nCamellia_EncryptBlock_Rounds(keyBitLength == 128 ? 3 : 4,\\r\\nplaintext, keyTable, ciphertext);\\r\\n}\\r\\nvoid Camellia_DecryptBlock_Rounds(int grandRounds, const u8 ciphertext[],\\r\\nconst KEY_TABLE_TYPE keyTable,\\r\\nu8 plaintext[])\\r\\n{\\r\\nu32 s0, s1, s2, s3;\\r\\nconst u32 *k = keyTable + grandRounds * 16, *kend = keyTable + 4;\\r\\ns0 = GETU32(ciphertext) ^ k[0];\\r\\ns1 = GETU32(ciphertext + 4) ^ k[1];\\r\\ns2 = GETU32(ciphertext + 8) ^ k[2];\\r\\ns3 = GETU32(ciphertext + 12) ^ k[3];\\r\\nwhile (1) {\\r\\nk -= 12;\\r\\nCamellia_Feistel(s0, s1, s2, s3, k + 10);\\r\\nCamellia_Feistel(s2, s3, s0, s1, k + 8);\\r\\nCamellia_Feistel(s0, s1, s2, s3, k + 6);\\r\\nCamellia_Feistel(s2, s3, s0, s1, k + 4);\\r\\nCamellia_Feistel(s0, s1, s2, s3, k + 2);\\r\\nCamellia_Feistel(s2, s3, s0, s1, k + 0);\\r\\nif (k == kend)\\r\\nbreak;\\r\\nk -= 4;\\r\\ns1 ^= LeftRotate(s0 & k[2], 1);\\r\\ns2 ^= s3 | k[1];\\r\\ns0 ^= s1 | k[3];\\r\\ns3 ^= LeftRotate(s2 & k[0], 1);\\r\\n}\\r\\nk -= 4;\\r\\ns2 ^= k[0], s3 ^= k[1], s0 ^= k[2], s1 ^= k[3];\\r\\nPUTU32(plaintext, s2);\\r\\nPUTU32(plaintext + 4, s3);\\r\\nPUTU32(plaintext + 8, s0);\\r\\nPUTU32(plaintext + 12, s1);\\r\\n}\\r\\nvoid Camellia_DecryptBlock(int keyBitLength, const u8 plaintext[],\\r\\nconst KEY_TABLE_TYPE keyTable, u8 ciphertext[])\\r\\n{\\r\\nCamellia_DecryptBlock_Rounds(keyBitLength == 128 ? 3 : 4,\\r\\nplaintext, keyTable, ciphertext);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ca_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nchar *key = NULL, *passargin = NULL;\\r\\nint create_ser = 0;\\r\\nint free_key = 0;\\r\\nint total = 0;\\r\\nint total_done = 0;\\r\\nint badops = 0;\\r\\nint ret = 1;\\r\\nint email_dn = 1;\\r\\nint req = 0;\\r\\nint verbose = 0;\\r\\nint gencrl = 0;\\r\\nint dorevoke = 0;\\r\\nint doupdatedb = 0;\\r\\nlong crldays = 0;\\r\\nlong crlhours = 0;\\r\\nlong crlsec = 0;\\r\\nlong errorline = -1;\\r\\nchar *configfile = NULL;\\r\\nchar *md = NULL;\\r\\nchar *policy = NULL;\\r\\nchar *keyfile = NULL;\\r\\nchar *certfile = NULL;\\r\\nint keyform = FORMAT_PEM;\\r\\nchar *infile = NULL;\\r\\nchar *spkac_file = NULL;\\r\\nchar *ss_cert_file = NULL;\\r\\nchar *ser_status = NULL;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nint output_der = 0;\\r\\nchar *outfile = NULL;\\r\\nchar *outdir = NULL;\\r\\nchar *serialfile = NULL;\\r\\nchar *crlnumberfile = NULL;\\r\\nchar *extensions = NULL;\\r\\nchar *extfile = NULL;\\r\\nchar *subj = NULL;\\r\\nunsigned long chtype = MBSTRING_ASC;\\r\\nint multirdn = 0;\\r\\nchar *tmp_email_dn = NULL;\\r\\nchar *crl_ext = NULL;\\r\\nint rev_type = REV_NONE;\\r\\nchar *rev_arg = NULL;\\r\\nBIGNUM *serial = NULL;\\r\\nBIGNUM *crlnumber = NULL;\\r\\nchar *startdate = NULL;\\r\\nchar *enddate = NULL;\\r\\nlong days = 0;\\r\\nint batch = 0;\\r\\nint notext = 0;\\r\\nunsigned long nameopt = 0, certopt = 0;\\r\\nint default_op = 1;\\r\\nint ext_copy = EXT_COPY_NONE;\\r\\nint selfsign = 0;\\r\\nX509 *x509 = NULL, *x509p = NULL;\\r\\nX509 *x = NULL;\\r\\nBIO *in = NULL, *out = NULL, *Sout = NULL, *Cout = NULL;\\r\\nchar *dbfile = NULL;\\r\\nCA_DB *db = NULL;\\r\\nX509_CRL *crl = NULL;\\r\\nX509_REVOKED *r = NULL;\\r\\nASN1_TIME *tmptm;\\r\\nASN1_INTEGER *tmpser;\\r\\nchar *f;\\r\\nconst char *p;\\r\\nchar *const *pp;\\r\\nint i, j;\\r\\nconst EVP_MD *dgst = NULL;\\r\\nSTACK_OF(CONF_VALUE) *attribs = NULL;\\r\\nSTACK_OF(X509) *cert_sk = NULL;\\r\\nSTACK_OF(OPENSSL_STRING) *sigopts = NULL;\\r\\n#undef BSIZE\\r\\n#define BSIZE 256\\r\\nMS_STATIC char buf[3][BSIZE];\\r\\nchar *randfile = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nchar *tofree = NULL;\\r\\nDB_ATTR db_attr;\\r\\n#ifdef EFENCE\\r\\nEF_PROTECT_FREE = 1;\\r\\nEF_PROTECT_BELOW = 1;\\r\\nEF_ALIGNMENT = 0;\\r\\n#endif\\r\\napps_startup();\\r\\nconf = NULL;\\r\\nkey = NULL;\\r\\nsection = NULL;\\r\\npreserve = 0;\\r\\nmsie_hack = 0;\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-verbose\") == 0)\\r\\nverbose = 1;\\r\\nelse if (strcmp(*argv, \"-config\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nconfigfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-name\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsection = *(++argv);\\r\\n} else if (strcmp(*argv, \"-subj\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nsubj = *(++argv);\\r\\n} else if (strcmp(*argv, \"-utf8\") == 0)\\r\\nchtype = MBSTRING_UTF8;\\r\\nelse if (strcmp(*argv, \"-create_serial\") == 0)\\r\\ncreate_ser = 1;\\r\\nelse if (strcmp(*argv, \"-multivalue-rdn\") == 0)\\r\\nmultirdn = 1;\\r\\nelse if (strcmp(*argv, \"-startdate\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nstartdate = *(++argv);\\r\\n} else if (strcmp(*argv, \"-enddate\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nenddate = *(++argv);\\r\\n} else if (strcmp(*argv, \"-days\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ndays = atoi(*(++argv));\\r\\n} else if (strcmp(*argv, \"-md\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nmd = *(++argv);\\r\\n} else if (strcmp(*argv, \"-policy\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npolicy = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keyfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keyform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkeyform = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-passin\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-key\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nkey = *(++argv);\\r\\n} else if (strcmp(*argv, \"-cert\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncertfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-selfsign\") == 0)\\r\\nselfsign = 1;\\r\\nelse if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\nreq = 1;\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-outdir\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutdir = *(++argv);\\r\\n} else if (strcmp(*argv, \"-sigopt\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nif (!sigopts)\\r\\nsigopts = sk_OPENSSL_STRING_new_null();\\r\\nif (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-notext\") == 0)\\r\\nnotext = 1;\\r\\nelse if (strcmp(*argv, \"-batch\") == 0)\\r\\nbatch = 1;\\r\\nelse if (strcmp(*argv, \"-preserveDN\") == 0)\\r\\npreserve = 1;\\r\\nelse if (strcmp(*argv, \"-noemailDN\") == 0)\\r\\nemail_dn = 0;\\r\\nelse if (strcmp(*argv, \"-gencrl\") == 0)\\r\\ngencrl = 1;\\r\\nelse if (strcmp(*argv, \"-msie_hack\") == 0)\\r\\nmsie_hack = 1;\\r\\nelse if (strcmp(*argv, \"-crldays\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncrldays = atol(*(++argv));\\r\\n} else if (strcmp(*argv, \"-crlhours\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncrlhours = atol(*(++argv));\\r\\n} else if (strcmp(*argv, \"-crlsec\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncrlsec = atol(*(++argv));\\r\\n} else if (strcmp(*argv, \"-infiles\") == 0) {\\r\\nargc--;\\r\\nargv++;\\r\\nreq = 1;\\r\\nbreak;\\r\\n} else if (strcmp(*argv, \"-ss_cert\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nss_cert_file = *(++argv);\\r\\nreq = 1;\\r\\n} else if (strcmp(*argv, \"-spkac\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nspkac_file = *(++argv);\\r\\nreq = 1;\\r\\n} else if (strcmp(*argv, \"-revoke\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\ndorevoke = 1;\\r\\n} else if (strcmp(*argv, \"-valid\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\ndorevoke = 2;\\r\\n} else if (strcmp(*argv, \"-extensions\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nextensions = *(++argv);\\r\\n} else if (strcmp(*argv, \"-extfile\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nextfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-status\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nser_status = *(++argv);\\r\\n} else if (strcmp(*argv, \"-updatedb\") == 0) {\\r\\ndoupdatedb = 1;\\r\\n} else if (strcmp(*argv, \"-crlexts\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncrl_ext = *(++argv);\\r\\n} else if (strcmp(*argv, \"-crl_reason\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nrev_arg = *(++argv);\\r\\nrev_type = REV_CRL_REASON;\\r\\n} else if (strcmp(*argv, \"-crl_hold\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nrev_arg = *(++argv);\\r\\nrev_type = REV_HOLD;\\r\\n} else if (strcmp(*argv, \"-crl_compromise\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nrev_arg = *(++argv);\\r\\nrev_type = REV_KEY_COMPROMISE;\\r\\n} else if (strcmp(*argv, \"-crl_CA_compromise\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nrev_arg = *(++argv);\\r\\nrev_type = REV_CA_COMPROMISE;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n}\\r\\n#endif\\r\\nelse {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nconst char **pp2;\\r\\nfor (pp2 = ca_usage; (*pp2 != NULL); pp2++)\\r\\nBIO_printf(bio_err, \"%s\", *pp2);\\r\\ngoto err;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\ntofree = NULL;\\r\\nif (configfile == NULL)\\r\\nconfigfile = getenv(\"OPENSSL_CONF\");\\r\\nif (configfile == NULL)\\r\\nconfigfile = getenv(\"SSLEAY_CONF\");\\r\\nif (configfile == NULL) {\\r\\nconst char *s = X509_get_default_cert_area();\\r\\nsize_t len;\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nlen = strlen(s) + sizeof(CONFIG_FILE);\\r\\ntofree = OPENSSL_malloc(len);\\r\\nstrcpy(tofree, s);\\r\\n#else\\r\\nlen = strlen(s) + sizeof(CONFIG_FILE) + 1;\\r\\ntofree = OPENSSL_malloc(len);\\r\\nBUF_strlcpy(tofree, s, len);\\r\\nBUF_strlcat(tofree, \"/\", len);\\r\\n#endif\\r\\nBUF_strlcat(tofree, CONFIG_FILE, len);\\r\\nconfigfile = tofree;\\r\\n}\\r\\nBIO_printf(bio_err, \"Using configuration from %s\\n\", configfile);\\r\\nconf = NCONF_new(NULL);\\r\\nif (NCONF_load(conf, configfile, &errorline) <= 0) {\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err, \"error loading the config file '%s'\\n\",\\r\\nconfigfile);\\r\\nelse\\r\\nBIO_printf(bio_err, \"error on line %ld of config file '%s'\\n\",\\r\\nerrorline, configfile);\\r\\ngoto err;\\r\\n}\\r\\nif (tofree) {\\r\\nOPENSSL_free(tofree);\\r\\ntofree = NULL;\\r\\n}\\r\\nif (!load_config(bio_err, conf))\\r\\ngoto err;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (section == NULL) {\\r\\nsection = NCONF_get_string(conf, BASE_SECTION, ENV_DEFAULT_CA);\\r\\nif (section == NULL) {\\r\\nlookup_fail(BASE_SECTION, ENV_DEFAULT_CA);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (conf != NULL) {\\r\\np = NCONF_get_string(conf, NULL, \"oid_file\");\\r\\nif (p == NULL)\\r\\nERR_clear_error();\\r\\nif (p != NULL) {\\r\\nBIO *oid_bio;\\r\\noid_bio = BIO_new_file(p, \"r\");\\r\\nif (oid_bio == NULL) {\\r\\nERR_clear_error();\\r\\n} else {\\r\\nOBJ_create_objects(oid_bio);\\r\\nBIO_free(oid_bio);\\r\\n}\\r\\n}\\r\\nif (!add_oid_section(bio_err, conf)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nrandfile = NCONF_get_string(conf, BASE_SECTION, \"RANDFILE\");\\r\\nif (randfile == NULL)\\r\\nERR_clear_error();\\r\\napp_RAND_load_file(randfile, bio_err, 0);\\r\\nf = NCONF_get_string(conf, section, STRING_MASK);\\r\\nif (!f)\\r\\nERR_clear_error();\\r\\nif (f && !ASN1_STRING_set_default_mask_asc(f)) {\\r\\nBIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", f);\\r\\ngoto err;\\r\\n}\\r\\nif (chtype != MBSTRING_UTF8) {\\r\\nf = NCONF_get_string(conf, section, UTF8_IN);\\r\\nif (!f)\\r\\nERR_clear_error();\\r\\nelse if (!strcmp(f, \"yes\"))\\r\\nchtype = MBSTRING_UTF8;\\r\\n}\\r\\ndb_attr.unique_subject = 1;\\r\\np = NCONF_get_string(conf, section, ENV_UNIQUE_SUBJECT);\\r\\nif (p) {\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: unique_subject = \\\"%s\\\"\\n\", p);\\r\\n#endif\\r\\ndb_attr.unique_subject = parse_yesno(p, 1);\\r\\n} else\\r\\nERR_clear_error();\\r\\n#ifdef RL_DEBUG\\r\\nif (!p)\\r\\nBIO_printf(bio_err, \"DEBUG: unique_subject undefined\\n\");\\r\\n#endif\\r\\n#ifdef RL_DEBUG\\r\\nBIO_printf(bio_err, \"DEBUG: configured unique_subject is %d\\n\",\\r\\ndb_attr.unique_subject);\\r\\n#endif\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nSout = BIO_new(BIO_s_file());\\r\\nCout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL) || (Sout == NULL) || (Cout == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nif (ser_status) {\\r\\nif ((dbfile = NCONF_get_string(conf, section, ENV_DATABASE)) == NULL) {\\r\\nlookup_fail(section, ENV_DATABASE);\\r\\ngoto err;\\r\\n}\\r\\ndb = load_index(dbfile, &db_attr);\\r\\nif (db == NULL)\\r\\ngoto err;\\r\\nif (!index_index(db))\\r\\ngoto err;\\r\\nif (get_certificate_status(ser_status, db) != 1)\\r\\nBIO_printf(bio_err, \"Error verifying serial %s!\\n\", ser_status);\\r\\ngoto err;\\r\\n}\\r\\nif ((keyfile == NULL) && ((keyfile = NCONF_get_string(conf,\\r\\nsection,\\r\\nENV_PRIVATE_KEY)) ==\\r\\nNULL)) {\\r\\nlookup_fail(section, ENV_PRIVATE_KEY);\\r\\ngoto err;\\r\\n}\\r\\nif (!key) {\\r\\nfree_key = 1;\\r\\nif (!app_passwd(bio_err, passargin, NULL, &key, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\npkey = load_key(bio_err, keyfile, keyform, 0, key, e, \"CA private key\");\\r\\nif (key)\\r\\nOPENSSL_cleanse(key, strlen(key));\\r\\nif (pkey == NULL) {\\r\\ngoto err;\\r\\n}\\r\\nif (!selfsign || spkac_file || ss_cert_file || gencrl) {\\r\\nif ((certfile == NULL)\\r\\n&& ((certfile = NCONF_get_string(conf,\\r\\nsection,\\r\\nENV_CERTIFICATE)) == NULL)) {\\r\\nlookup_fail(section, ENV_CERTIFICATE);\\r\\ngoto err;\\r\\n}\\r\\nx509 = load_cert(bio_err, certfile, FORMAT_PEM, NULL, e,\\r\\n\"CA certificate\");\\r\\nif (x509 == NULL)\\r\\ngoto err;\\r\\nif (!X509_check_private_key(x509, pkey)) {\\r\\nBIO_printf(bio_err,\\r\\n\"CA certificate and CA private key do not match\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!selfsign)\\r\\nx509p = x509;\\r\\nf = NCONF_get_string(conf, BASE_SECTION, ENV_PRESERVE);\\r\\nif (f == NULL)\\r\\nERR_clear_error();\\r\\nif ((f != NULL) && ((*f == 'y') || (*f == 'Y')))\\r\\npreserve = 1;\\r\\nf = NCONF_get_string(conf, BASE_SECTION, ENV_MSIE_HACK);\\r\\nif (f == NULL)\\r\\nERR_clear_error();\\r\\nif ((f != NULL) && ((*f == 'y') || (*f == 'Y')))\\r\\nmsie_hack = 1;\\r\\nf = NCONF_get_string(conf, section, ENV_NAMEOPT);\\r\\nif (f) {\\r\\nif (!set_name_ex(&nameopt, f)) {\\r\\nBIO_printf(bio_err, \"Invalid name options: \\\"%s\\\"\\n\", f);\\r\\ngoto err;\\r\\n}\\r\\ndefault_op = 0;\\r\\n} else\\r\\nERR_clear_error();\\r\\nf = NCONF_get_string(conf, section, ENV_CERTOPT);\\r\\nif (f) {\\r\\nif (!set_cert_ex(&certopt, f)) {\\r\\nBIO_printf(bio_err, \"Invalid certificate options: \\\"%s\\\"\\n\", f);\\r\\ngoto err;\\r\\n}\\r\\ndefault_op = 0;\\r\\n} else\\r\\nERR_clear_error();\\r\\nf = NCONF_get_string(conf, section, ENV_EXTCOPY);\\r\\nif (f) {\\r\\nif (!set_ext_copy(&ext_copy, f)) {\\r\\nBIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\", f);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\nERR_clear_error();\\r\\nif ((outdir == NULL) && (req)) {\\r\\nif ((outdir = NCONF_get_string(conf, section, ENV_NEW_CERTS_DIR))\\r\\n== NULL) {\\r\\nBIO_printf(bio_err,\\r\\n\"there needs to be defined a directory for new certificate to be placed in\\n\");\\r\\ngoto err;\\r\\n}\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\n# ifndef _WIN32\\r\\nif (access(outdir, R_OK | W_OK | X_OK) != 0)\\r\\n# else\\r\\nif (_access(outdir, R_OK | W_OK | X_OK) != 0)\\r\\n# endif\\r\\n{\\r\\nBIO_printf(bio_err, \"I am unable to access the %s directory\\n\",\\r\\noutdir);\\r\\nperror(outdir);\\r\\ngoto err;\\r\\n}\\r\\nif (app_isdir(outdir) <= 0) {\\r\\nBIO_printf(bio_err, \"%s need to be a directory\\n\", outdir);\\r\\nperror(outdir);\\r\\ngoto err;\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif ((dbfile = NCONF_get_string(conf, section, ENV_DATABASE)) == NULL) {\\r\\nlookup_fail(section, ENV_DATABASE);\\r\\ngoto err;\\r\\n}\\r\\ndb = load_index(dbfile, &db_attr);\\r\\nif (db == NULL)\\r\\ngoto err;\\r\\nfor (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\\r\\npp = sk_OPENSSL_PSTRING_value(db->db->data, i);\\r\\nif ((pp[DB_type][0] != DB_TYPE_REV) && (pp[DB_rev_date][0] != '\\0')) {\\r\\nBIO_printf(bio_err,\\r\\n\"entry %d: not revoked yet, but has a revocation date\\n\",\\r\\ni + 1);\\r\\ngoto err;\\r\\n}\\r\\nif ((pp[DB_type][0] == DB_TYPE_REV) &&\\r\\n!make_revoked(NULL, pp[DB_rev_date])) {\\r\\nBIO_printf(bio_err, \" in entry %d\\n\", i + 1);\\r\\ngoto err;\\r\\n}\\r\\nif (!check_time_format((char *)pp[DB_exp_date])) {\\r\\nBIO_printf(bio_err, \"entry %d: invalid expiry date\\n\", i + 1);\\r\\ngoto err;\\r\\n}\\r\\np = pp[DB_serial];\\r\\nj = strlen(p);\\r\\nif (*p == '-') {\\r\\np++;\\r\\nj--;\\r\\n}\\r\\nif ((j & 1) || (j < 2)) {\\r\\nBIO_printf(bio_err, \"entry %d: bad serial number length (%d)\\n\",\\r\\ni + 1, j);\\r\\ngoto err;\\r\\n}\\r\\nwhile (*p) {\\r\\nif (!(((*p >= '0') && (*p <= '9')) ||\\r\\n((*p >= 'A') && (*p <= 'F')) ||\\r\\n((*p >= 'a') && (*p <= 'f')))) {\\r\\nBIO_printf(bio_err,\\r\\n\"entry %d: bad serial number characters, char pos %ld, char is '%c'\\n\",\\r\\ni + 1, (long)(p - pp[DB_serial]), *p);\\r\\ngoto err;\\r\\n}\\r\\np++;\\r\\n}\\r\\n}\\r\\nif (verbose) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\nTXT_DB_write(out, db->db);\\r\\nBIO_printf(bio_err, \"%d entries loaded from the database\\n\",\\r\\nsk_OPENSSL_PSTRING_num(db->db->data));\\r\\nBIO_printf(bio_err, \"generating index\\n\");\\r\\n}\\r\\nif (!index_index(db))\\r\\ngoto err;\\r\\nif (doupdatedb) {\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"Updating %s ...\\n\", dbfile);\\r\\ni = do_updatedb(db);\\r\\nif (i == -1) {\\r\\nBIO_printf(bio_err, \"Malloc failure\\n\");\\r\\ngoto err;\\r\\n} else if (i == 0) {\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"No entries found to mark expired\\n\");\\r\\n} else {\\r\\nif (!save_index(dbfile, \"new\", db))\\r\\ngoto err;\\r\\nif (!rotate_index(dbfile, \"new\", \"old\"))\\r\\ngoto err;\\r\\nif (verbose)\\r\\nBIO_printf(bio_err,\\r\\n\"Done. %d entries marked as expired\\n\", i);\\r\\n}\\r\\n}\\r\\nif (extfile) {\\r\\nextconf = NCONF_new(NULL);\\r\\nif (NCONF_load(extconf, extfile, &errorline) <= 0) {\\r\\nif (errorline <= 0)\\r\\nBIO_printf(bio_err, \"ERROR: loading the config file '%s'\\n\",\\r\\nextfile);\\r\\nelse\\r\\nBIO_printf(bio_err,\\r\\n\"ERROR: on line %ld of config file '%s'\\n\",\\r\\nerrorline, extfile);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"Successfully loaded extensions file %s\\n\",\\r\\nextfile);\\r\\nif (!extensions\\r\\n&& !(extensions =\\r\\nNCONF_get_string(extconf, \"default\", \"extensions\")))\\r\\nextensions = \"default\";\\r\\n}\\r\\nif (req || gencrl) {\\r\\nif (outfile != NULL) {\\r\\nif (BIO_write_filename(Sout, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto err;\\r\\n}\\r\\n} else {\\r\\nBIO_set_fp(Sout, stdout, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nSout = BIO_push(tmpbio, Sout);\\r\\n}\\r\\n#endif\\r\\n}\\r\\n}\\r\\nif ((md == NULL) && ((md = NCONF_get_string(conf,\\r\\nsection,\\r\\nENV_DEFAULT_MD)) == NULL)) {\\r\\nlookup_fail(section, ENV_DEFAULT_MD);\\r\\ngoto err;\\r\\n}\\r\\nif (!strcmp(md, \"default\")) {\\r\\nint def_nid;\\r\\nif (EVP_PKEY_get_default_digest_nid(pkey, &def_nid) <= 0) {\\r\\nBIO_puts(bio_err, \"no default digest\\n\");\\r\\ngoto err;\\r\\n}\\r\\nmd = (char *)OBJ_nid2sn(def_nid);\\r\\n}\\r\\nif ((dgst = EVP_get_digestbyname(md)) == NULL) {\\r\\nBIO_printf(bio_err, \"%s is an unsupported message digest type\\n\", md);\\r\\ngoto err;\\r\\n}\\r\\nif (req) {\\r\\nif ((email_dn == 1) && ((tmp_email_dn = NCONF_get_string(conf,\\r\\nsection,\\r\\nENV_DEFAULT_EMAIL_DN))\\r\\n!= NULL)) {\\r\\nif (strcmp(tmp_email_dn, \"no\") == 0)\\r\\nemail_dn = 0;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"message digest is %s\\n\",\\r\\nOBJ_nid2ln(dgst->type));\\r\\nif ((policy == NULL) && ((policy = NCONF_get_string(conf,\\r\\nsection,\\r\\nENV_POLICY)) ==\\r\\nNULL)) {\\r\\nlookup_fail(section, ENV_POLICY);\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"policy is %s\\n\", policy);\\r\\nif ((serialfile = NCONF_get_string(conf, section, ENV_SERIAL))\\r\\n== NULL) {\\r\\nlookup_fail(section, ENV_SERIAL);\\r\\ngoto err;\\r\\n}\\r\\nif (!extconf) {\\r\\nif (!extensions) {\\r\\nextensions = NCONF_get_string(conf, section, ENV_EXTENSIONS);\\r\\nif (!extensions)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (extensions) {\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_nconf(&ctx, conf);\\r\\nif (!X509V3_EXT_add_nconf(conf, &ctx, extensions, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading extension section %s\\n\",\\r\\nextensions);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (startdate == NULL) {\\r\\nstartdate = NCONF_get_string(conf, section,\\r\\nENV_DEFAULT_STARTDATE);\\r\\nif (startdate == NULL)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (startdate && !ASN1_TIME_set_string(NULL, startdate)) {\\r\\nBIO_printf(bio_err,\\r\\n\"start date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (startdate == NULL)\\r\\nstartdate = \"today\";\\r\\nif (enddate == NULL) {\\r\\nenddate = NCONF_get_string(conf, section, ENV_DEFAULT_ENDDATE);\\r\\nif (enddate == NULL)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (enddate && !ASN1_TIME_set_string(NULL, enddate)) {\\r\\nBIO_printf(bio_err,\\r\\n\"end date is invalid, it should be YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (days == 0) {\\r\\nif (!NCONF_get_number(conf, section, ENV_DEFAULT_DAYS, &days))\\r\\ndays = 0;\\r\\n}\\r\\nif (!enddate && (days == 0)) {\\r\\nBIO_printf(bio_err,\\r\\n\"cannot lookup how many days to certify for\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif ((serial = load_serial(serialfile, create_ser, NULL)) == NULL) {\\r\\nBIO_printf(bio_err, \"error while loading serial number\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (verbose) {\\r\\nif (BN_is_zero(serial))\\r\\nBIO_printf(bio_err, \"next serial number is 00\\n\");\\r\\nelse {\\r\\nif ((f = BN_bn2hex(serial)) == NULL)\\r\\ngoto err;\\r\\nBIO_printf(bio_err, \"next serial number is %s\\n\", f);\\r\\nOPENSSL_free(f);\\r\\n}\\r\\n}\\r\\nif ((attribs = NCONF_get_section(conf, policy)) == NULL) {\\r\\nBIO_printf(bio_err, \"unable to find 'section' for %s\\n\", policy);\\r\\ngoto err;\\r\\n}\\r\\nif ((cert_sk = sk_X509_new_null()) == NULL) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (spkac_file != NULL) {\\r\\ntotal++;\\r\\nj = certify_spkac(&x, spkac_file, pkey, x509, dgst, sigopts,\\r\\nattribs, db, serial, subj, chtype, multirdn,\\r\\nemail_dn, startdate, enddate, days, extensions,\\r\\nconf, verbose, certopt, nameopt, default_op,\\r\\next_copy);\\r\\nif (j < 0)\\r\\ngoto err;\\r\\nif (j > 0) {\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\nif (!BN_add_word(serial, 1))\\r\\ngoto err;\\r\\nif (!sk_X509_push(cert_sk, x)) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (outfile) {\\r\\noutput_der = 1;\\r\\nbatch = 1;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (ss_cert_file != NULL) {\\r\\ntotal++;\\r\\nj = certify_cert(&x, ss_cert_file, pkey, x509, dgst, sigopts,\\r\\nattribs,\\r\\ndb, serial, subj, chtype, multirdn, email_dn,\\r\\nstartdate, enddate, days, batch, extensions,\\r\\nconf, verbose, certopt, nameopt, default_op,\\r\\next_copy, e);\\r\\nif (j < 0)\\r\\ngoto err;\\r\\nif (j > 0) {\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\nif (!BN_add_word(serial, 1))\\r\\ngoto err;\\r\\nif (!sk_X509_push(cert_sk, x)) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (infile != NULL) {\\r\\ntotal++;\\r\\nj = certify(&x, infile, pkey, x509p, dgst, sigopts, attribs, db,\\r\\nserial, subj, chtype, multirdn, email_dn, startdate,\\r\\nenddate, days, batch, extensions, conf, verbose,\\r\\ncertopt, nameopt, default_op, ext_copy, selfsign);\\r\\nif (j < 0)\\r\\ngoto err;\\r\\nif (j > 0) {\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\nif (!BN_add_word(serial, 1))\\r\\ngoto err;\\r\\nif (!sk_X509_push(cert_sk, x)) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < argc; i++) {\\r\\ntotal++;\\r\\nj = certify(&x, argv[i], pkey, x509p, dgst, sigopts, attribs, db,\\r\\nserial, subj, chtype, multirdn, email_dn, startdate,\\r\\nenddate, days, batch, extensions, conf, verbose,\\r\\ncertopt, nameopt, default_op, ext_copy, selfsign);\\r\\nif (j < 0)\\r\\ngoto err;\\r\\nif (j > 0) {\\r\\ntotal_done++;\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\nif (!BN_add_word(serial, 1))\\r\\ngoto err;\\r\\nif (!sk_X509_push(cert_sk, x)) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (sk_X509_num(cert_sk) > 0) {\\r\\nif (!batch) {\\r\\nBIO_printf(bio_err,\\r\\n\"\\n%d out of %d certificate requests certified, commit? [y/n]\",\\r\\ntotal_done, total);\\r\\n(void)BIO_flush(bio_err);\\r\\nbuf[0][0] = '\\0';\\r\\nif (!fgets(buf[0], 10, stdin)) {\\r\\nBIO_printf(bio_err,\\r\\n\"CERTIFICATION CANCELED: I/O error\\n\");\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\nif ((buf[0][0] != 'y') && (buf[0][0] != 'Y')) {\\r\\nBIO_printf(bio_err, \"CERTIFICATION CANCELED\\n\");\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err, \"Write out database with %d new entries\\n\",\\r\\nsk_X509_num(cert_sk));\\r\\nif (!save_serial(serialfile, \"new\", serial, NULL))\\r\\ngoto err;\\r\\nif (!save_index(dbfile, \"new\", db))\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"writing new certificates\\n\");\\r\\nfor (i = 0; i < sk_X509_num(cert_sk); i++) {\\r\\nint k;\\r\\nchar *n;\\r\\nx = sk_X509_value(cert_sk, i);\\r\\nj = x->cert_info->serialNumber->length;\\r\\np = (const char *)x->cert_info->serialNumber->data;\\r\\nif (strlen(outdir) >= (size_t)(j ? BSIZE - j * 2 - 6 : BSIZE - 8)) {\\r\\nBIO_printf(bio_err, \"certificate file name too long\\n\");\\r\\ngoto err;\\r\\n}\\r\\nstrcpy(buf[2], outdir);\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBUF_strlcat(buf[2], \"/\", sizeof(buf[2]));\\r\\n#endif\\r\\nn = (char *)&(buf[2][strlen(buf[2])]);\\r\\nif (j > 0) {\\r\\nfor (k = 0; k < j; k++) {\\r\\nif (n >= &(buf[2][sizeof(buf[2])]))\\r\\nbreak;\\r\\nBIO_snprintf(n,\\r\\n&buf[2][0] + sizeof(buf[2]) - n,\\r\\n\"%02X\", (unsigned char)*(p++));\\r\\nn += 2;\\r\\n}\\r\\n} else {\\r\\n*(n++) = '0';\\r\\n*(n++) = '0';\\r\\n}\\r\\n*(n++) = '.';\\r\\n*(n++) = 'p';\\r\\n*(n++) = 'e';\\r\\n*(n++) = 'm';\\r\\n*n = '\\0';\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"writing %s\\n\", buf[2]);\\r\\nif (BIO_write_filename(Cout, buf[2]) <= 0) {\\r\\nperror(buf[2]);\\r\\ngoto err;\\r\\n}\\r\\nwrite_new_certificate(Cout, x, 0, notext);\\r\\nwrite_new_certificate(Sout, x, output_der, notext);\\r\\n}\\r\\nif (sk_X509_num(cert_sk)) {\\r\\nif (!rotate_serial(serialfile, \"new\", \"old\"))\\r\\ngoto err;\\r\\nif (!rotate_index(dbfile, \"new\", \"old\"))\\r\\ngoto err;\\r\\nBIO_printf(bio_err, \"Data Base Updated\\n\");\\r\\n}\\r\\n}\\r\\nif (gencrl) {\\r\\nint crl_v2 = 0;\\r\\nif (!crl_ext) {\\r\\ncrl_ext = NCONF_get_string(conf, section, ENV_CRLEXT);\\r\\nif (!crl_ext)\\r\\nERR_clear_error();\\r\\n}\\r\\nif (crl_ext) {\\r\\nX509V3_CTX ctx;\\r\\nX509V3_set_ctx_test(&ctx);\\r\\nX509V3_set_nconf(&ctx, conf);\\r\\nif (!X509V3_EXT_add_nconf(conf, &ctx, crl_ext, NULL)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Error Loading CRL extension section %s\\n\",\\r\\ncrl_ext);\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif ((crlnumberfile = NCONF_get_string(conf, section, ENV_CRLNUMBER))\\r\\n!= NULL)\\r\\nif ((crlnumber = load_serial(crlnumberfile, 0, NULL)) == NULL) {\\r\\nBIO_printf(bio_err, \"error while loading CRL number\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (!crldays && !crlhours && !crlsec) {\\r\\nif (!NCONF_get_number(conf, section,\\r\\nENV_DEFAULT_CRL_DAYS, &crldays))\\r\\ncrldays = 0;\\r\\nif (!NCONF_get_number(conf, section,\\r\\nENV_DEFAULT_CRL_HOURS, &crlhours))\\r\\ncrlhours = 0;\\r\\nERR_clear_error();\\r\\n}\\r\\nif ((crldays == 0) && (crlhours == 0) && (crlsec == 0)) {\\r\\nBIO_printf(bio_err,\\r\\n\"cannot lookup how long until the next CRL is issued\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"making CRL\\n\");\\r\\nif ((crl = X509_CRL_new()) == NULL)\\r\\ngoto err;\\r\\nif (!X509_CRL_set_issuer_name(crl, X509_get_subject_name(x509)))\\r\\ngoto err;\\r\\ntmptm = ASN1_TIME_new();\\r\\nif (!tmptm)\\r\\ngoto err;\\r\\nX509_gmtime_adj(tmptm, 0);\\r\\nX509_CRL_set_lastUpdate(crl, tmptm);\\r\\nif (!X509_time_adj_ex(tmptm, crldays, crlhours * 60 * 60 + crlsec,\\r\\nNULL)) {\\r\\nBIO_puts(bio_err, \"error setting CRL nextUpdate\\n\");\\r\\ngoto err;\\r\\n}\\r\\nX509_CRL_set_nextUpdate(crl, tmptm);\\r\\nASN1_TIME_free(tmptm);\\r\\nfor (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\\r\\npp = sk_OPENSSL_PSTRING_value(db->db->data, i);\\r\\nif (pp[DB_type][0] == DB_TYPE_REV) {\\r\\nif ((r = X509_REVOKED_new()) == NULL)\\r\\ngoto err;\\r\\nj = make_revoked(r, pp[DB_rev_date]);\\r\\nif (!j)\\r\\ngoto err;\\r\\nif (j == 2)\\r\\ncrl_v2 = 1;\\r\\nif (!BN_hex2bn(&serial, pp[DB_serial]))\\r\\ngoto err;\\r\\ntmpser = BN_to_ASN1_INTEGER(serial, NULL);\\r\\nBN_free(serial);\\r\\nserial = NULL;\\r\\nif (!tmpser)\\r\\ngoto err;\\r\\nX509_REVOKED_set_serialNumber(r, tmpser);\\r\\nASN1_INTEGER_free(tmpser);\\r\\nX509_CRL_add0_revoked(crl, r);\\r\\n}\\r\\n}\\r\\nX509_CRL_sort(crl);\\r\\nif (verbose)\\r\\nBIO_printf(bio_err, \"signing CRL\\n\");\\r\\nif (crl_ext || crlnumberfile != NULL) {\\r\\nX509V3_CTX crlctx;\\r\\nX509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);\\r\\nX509V3_set_nconf(&crlctx, conf);\\r\\nif (crl_ext)\\r\\nif (!X509V3_EXT_CRL_add_nconf(conf, &crlctx, crl_ext, crl))\\r\\ngoto err;\\r\\nif (crlnumberfile != NULL) {\\r\\ntmpser = BN_to_ASN1_INTEGER(crlnumber, NULL);\\r\\nif (!tmpser)\\r\\ngoto err;\\r\\nX509_CRL_add1_ext_i2d(crl, NID_crl_number, tmpser, 0, 0);\\r\\nASN1_INTEGER_free(tmpser);\\r\\ncrl_v2 = 1;\\r\\nif (!BN_add_word(crlnumber, 1))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (crl_ext || crl_v2) {\\r\\nif (!X509_CRL_set_version(crl, 1))\\r\\ngoto err;\\r\\n}\\r\\nif (crlnumberfile != NULL)\\r\\nif (!save_serial(crlnumberfile, \"new\", crlnumber, NULL))\\r\\ngoto err;\\r\\nif (crlnumber) {\\r\\nBN_free(crlnumber);\\r\\ncrlnumber = NULL;\\r\\n}\\r\\nif (!do_X509_CRL_sign(bio_err, crl, pkey, dgst, sigopts))\\r\\ngoto err;\\r\\nPEM_write_bio_X509_CRL(Sout, crl);\\r\\nif (crlnumberfile != NULL)\\r\\nif (!rotate_serial(crlnumberfile, \"new\", \"old\"))\\r\\ngoto err;\\r\\n}\\r\\nif (dorevoke) {\\r\\nif (infile == NULL) {\\r\\nBIO_printf(bio_err, \"no input files\\n\");\\r\\ngoto err;\\r\\n} else {\\r\\nX509 *revcert;\\r\\nrevcert = load_cert(bio_err, infile, FORMAT_PEM, NULL, e, infile);\\r\\nif (revcert == NULL)\\r\\ngoto err;\\r\\nif (dorevoke == 2)\\r\\nrev_type = -1;\\r\\nj = do_revoke(revcert, db, rev_type, rev_arg);\\r\\nif (j <= 0)\\r\\ngoto err;\\r\\nX509_free(revcert);\\r\\nif (!save_index(dbfile, \"new\", db))\\r\\ngoto err;\\r\\nif (!rotate_index(dbfile, \"new\", \"old\"))\\r\\ngoto err;\\r\\nBIO_printf(bio_err, \"Data Base Updated\\n\");\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nerr:\\r\\nif (tofree)\\r\\nOPENSSL_free(tofree);\\r\\nBIO_free_all(Cout);\\r\\nBIO_free_all(Sout);\\r\\nBIO_free_all(out);\\r\\nBIO_free_all(in);\\r\\nif (cert_sk)\\r\\nsk_X509_pop_free(cert_sk, X509_free);\\r\\nif (ret)\\r\\nERR_print_errors(bio_err);\\r\\napp_RAND_write_file(randfile, bio_err);\\r\\nif (free_key && key)\\r\\nOPENSSL_free(key);\\r\\nBN_free(serial);\\r\\nBN_free(crlnumber);\\r\\nfree_index(db);\\r\\nif (sigopts)\\r\\nsk_OPENSSL_STRING_free(sigopts);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (x509)\\r\\nX509_free(x509);\\r\\nX509_CRL_free(crl);\\r\\nNCONF_free(conf);\\r\\nNCONF_free(extconf);\\r\\nOBJ_cleanup();\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic void lookup_fail(const char *name, const char *tag)\\r\\n{\\r\\nBIO_printf(bio_err, \"variable lookup failed for %s::%s\\n\", name, tag);\\r\\n}\\r\\nstatic void write_new_certificate(BIO *bp, X509 *x, int output_der,\\r\\nint notext)\\r\\n{\\r\\nif (output_der) {\\r\\n(void)i2d_X509_bio(bp, x);\\r\\nreturn;\\r\\n}\\r\\n#if 0\\r\\nf = X509_NAME_oneline(X509_get_issuer_name(x), buf, 256);\\r\\nBIO_printf(bp, \"issuer :%s\\n\", f);\\r\\nf = X509_NAME_oneline(X509_get_subject_name(x), buf, 256);\\r\\nBIO_printf(bp, \"subject:%s\\n\", f);\\r\\nBIO_puts(bp, \"serial :\");\\r\\ni2a_ASN1_INTEGER(bp, x->cert_info->serialNumber);\\r\\nBIO_puts(bp, \"\\n\\n\");\\r\\n#endif\\r\\nif (!notext)\\r\\nX509_print(bp, x);\\r\\nPEM_write_bio_X509(bp, x);\\r\\n}\\r\\nstatic int check_time_format(const char *str)\\r\\n{\\r\\nreturn ASN1_TIME_set_string(NULL, str);\\r\\n}\\r\\nstatic int do_revoke(X509 *x509, CA_DB *db, int type, char *value)\\r\\n{\\r\\nASN1_UTCTIME *tm = NULL;\\r\\nchar *row[DB_NUMBER], **rrow, **irow;\\r\\nchar *rev_str = NULL;\\r\\nBIGNUM *bn = NULL;\\r\\nint ok = -1, i;\\r\\nfor (i = 0; i < DB_NUMBER; i++)\\r\\nrow[i] = NULL;\\r\\nrow[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\\r\\nbn = ASN1_INTEGER_to_BN(X509_get_serialNumber(x509), NULL);\\r\\nif (!bn)\\r\\ngoto err;\\r\\nif (BN_is_zero(bn))\\r\\nrow[DB_serial] = BUF_strdup(\"00\");\\r\\nelse\\r\\nrow[DB_serial] = BN_bn2hex(bn);\\r\\nBN_free(bn);\\r\\nif ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nrrow = TXT_DB_get_by_index(db->db, DB_serial, row);\\r\\nif (rrow == NULL) {\\r\\nBIO_printf(bio_err,\\r\\n\"Adding Entry with serial number %s to DB for %s\\n\",\\r\\nrow[DB_serial], row[DB_name]);\\r\\nrow[DB_type] = (char *)OPENSSL_malloc(2);\\r\\ntm = X509_get_notAfter(x509);\\r\\nrow[DB_exp_date] = (char *)OPENSSL_malloc(tm->length + 1);\\r\\nmemcpy(row[DB_exp_date], tm->data, tm->length);\\r\\nrow[DB_exp_date][tm->length] = '\\0';\\r\\nrow[DB_rev_date] = NULL;\\r\\nrow[DB_file] = (char *)OPENSSL_malloc(8);\\r\\nif ((row[DB_type] == NULL) || (row[DB_exp_date] == NULL) ||\\r\\n(row[DB_file] == NULL)) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nBUF_strlcpy(row[DB_file], \"unknown\", 8);\\r\\nrow[DB_type][0] = 'V';\\r\\nrow[DB_type][1] = '\\0';\\r\\nif ((irow =\\r\\n(char **)OPENSSL_malloc(sizeof(char *) * (DB_NUMBER + 1))) ==\\r\\nNULL) {\\r\\nBIO_printf(bio_err, \"Memory allocation failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < DB_NUMBER; i++) {\\r\\nirow[i] = row[i];\\r\\nrow[i] = NULL;\\r\\n}\\r\\nirow[DB_NUMBER] = NULL;\\r\\nif (!TXT_DB_insert(db->db, irow)) {\\r\\nBIO_printf(bio_err, \"failed to update database\\n\");\\r\\nBIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\\r\\ngoto err;\\r\\n}\\r\\nif (type == -1)\\r\\nok = 1;\\r\\nelse\\r\\nok = do_revoke(x509, db, type, value);\\r\\ngoto err;\\r\\n} else if (index_name_cmp_noconst(row, rrow)) {\\r\\nBIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\\r\\ngoto err;\\r\\n} else if (type == -1) {\\r\\nBIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\\r\\nrow[DB_serial]);\\r\\ngoto err;\\r\\n} else if (rrow[DB_type][0] == 'R') {\\r\\nBIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\\r\\nrow[DB_serial]);\\r\\ngoto err;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\\r\\nrev_str = make_revocation_str(type, value);\\r\\nif (!rev_str) {\\r\\nBIO_printf(bio_err, \"Error in revocation arguments\\n\");\\r\\ngoto err;\\r\\n}\\r\\nrrow[DB_type][0] = 'R';\\r\\nrrow[DB_type][1] = '\\0';\\r\\nrrow[DB_rev_date] = rev_str;\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nfor (i = 0; i < DB_NUMBER; i++) {\\r\\nif (row[i] != NULL)\\r\\nOPENSSL_free(row[i]);\\r\\n}\\r\\nreturn (ok);\\r\\n}\\r\\nstatic int get_certificate_status(const char *serial, CA_DB *db)\\r\\n{\\r\\nchar *row[DB_NUMBER], **rrow;\\r\\nint ok = -1, i;\\r\\nfor (i = 0; i < DB_NUMBER; i++)\\r\\nrow[i] = NULL;\\r\\nrow[DB_serial] = OPENSSL_malloc(strlen(serial) + 2);\\r\\nif (row[DB_serial] == NULL) {\\r\\nBIO_printf(bio_err, \"Malloc failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nif (strlen(serial) % 2) {\\r\\n;\\r\\nrow[DB_serial][0] = '0';\\r\\nmemcpy(row[DB_serial] + 1, serial, strlen(serial));\\r\\nrow[DB_serial][strlen(serial) + 1] = '\\0';\\r\\n} else {\\r\\nmemcpy(row[DB_serial], serial, strlen(serial));\\r\\nrow[DB_serial][strlen(serial)] = '\\0';\\r\\n}\\r\\nfor (i = 0; row[DB_serial][i] != '\\0'; i++)\\r\\nrow[DB_serial][i] = toupper((unsigned char)row[DB_serial][i]);\\r\\nok = 1;\\r\\nrrow = TXT_DB_get_by_index(db->db, DB_serial, row);\\r\\nif (rrow == NULL) {\\r\\nBIO_printf(bio_err, \"Serial %s not present in db.\\n\", row[DB_serial]);\\r\\nok = -1;\\r\\ngoto err;\\r\\n} else if (rrow[DB_type][0] == 'V') {\\r\\nBIO_printf(bio_err, \"%s=Valid (%c)\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\ngoto err;\\r\\n} else if (rrow[DB_type][0] == 'R') {\\r\\nBIO_printf(bio_err, \"%s=Revoked (%c)\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\ngoto err;\\r\\n} else if (rrow[DB_type][0] == 'E') {\\r\\nBIO_printf(bio_err, \"%s=Expired (%c)\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\ngoto err;\\r\\n} else if (rrow[DB_type][0] == 'S') {\\r\\nBIO_printf(bio_err, \"%s=Suspended (%c)\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\ngoto err;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"%s=Unknown (%c).\\n\",\\r\\nrow[DB_serial], rrow[DB_type][0]);\\r\\nok = -1;\\r\\n}\\r\\nerr:\\r\\nfor (i = 0; i < DB_NUMBER; i++) {\\r\\nif (row[i] != NULL)\\r\\nOPENSSL_free(row[i]);\\r\\n}\\r\\nreturn (ok);\\r\\n}\\r\\nstatic int do_updatedb(CA_DB *db)\\r\\n{\\r\\nASN1_UTCTIME *a_tm = NULL;\\r\\nint i, cnt = 0;\\r\\nint db_y2k, a_y2k;\\r\\nchar **rrow, *a_tm_s;\\r\\na_tm = ASN1_UTCTIME_new();\\r\\na_tm = X509_gmtime_adj(a_tm, 0);\\r\\na_tm_s = (char *)OPENSSL_malloc(a_tm->length + 1);\\r\\nif (a_tm_s == NULL) {\\r\\ncnt = -1;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(a_tm_s, a_tm->data, a_tm->length);\\r\\na_tm_s[a_tm->length] = '\\0';\\r\\nif (strncmp(a_tm_s, \"49\", 2) <= 0)\\r\\na_y2k = 1;\\r\\nelse\\r\\na_y2k = 0;\\r\\nfor (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\\r\\nrrow = sk_OPENSSL_PSTRING_value(db->db->data, i);\\r\\nif (rrow[DB_type][0] == 'V') {\\r\\nif (strncmp(rrow[DB_exp_date], \"49\", 2) <= 0)\\r\\ndb_y2k = 1;\\r\\nelse\\r\\ndb_y2k = 0;\\r\\nif (db_y2k == a_y2k) {\\r\\nif (strcmp(rrow[DB_exp_date], a_tm_s) <= 0) {\\r\\nrrow[DB_type][0] = 'E';\\r\\nrrow[DB_type][1] = '\\0';\\r\\ncnt++;\\r\\nBIO_printf(bio_err, \"%s=Expired\\n\", rrow[DB_serial]);\\r\\n}\\r\\n} else if (db_y2k < a_y2k) {\\r\\nrrow[DB_type][0] = 'E';\\r\\nrrow[DB_type][1] = '\\0';\\r\\ncnt++;\\r\\nBIO_printf(bio_err, \"%s=Expired\\n\", rrow[DB_serial]);\\r\\n}\\r\\n}\\r\\n}\\r\\nerr:\\r\\nASN1_UTCTIME_free(a_tm);\\r\\nOPENSSL_free(a_tm_s);\\r\\nreturn (cnt);\\r\\n}\\r\\nchar *make_revocation_str(int rev_type, char *rev_arg)\\r\\n{\\r\\nchar *other = NULL, *str;\\r\\nconst char *reason = NULL;\\r\\nASN1_OBJECT *otmp;\\r\\nASN1_UTCTIME *revtm = NULL;\\r\\nint i;\\r\\nswitch (rev_type) {\\r\\ncase REV_NONE:\\r\\nbreak;\\r\\ncase REV_CRL_REASON:\\r\\nfor (i = 0; i < 8; i++) {\\r\\nif (!strcasecmp(rev_arg, crl_reasons[i])) {\\r\\nreason = crl_reasons[i];\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (reason == NULL) {\\r\\nBIO_printf(bio_err, \"Unknown CRL reason %s\\n\", rev_arg);\\r\\nreturn NULL;\\r\\n}\\r\\nbreak;\\r\\ncase REV_HOLD:\\r\\notmp = OBJ_txt2obj(rev_arg, 0);\\r\\nASN1_OBJECT_free(otmp);\\r\\nif (otmp == NULL) {\\r\\nBIO_printf(bio_err, \"Invalid object identifier %s\\n\", rev_arg);\\r\\nreturn NULL;\\r\\n}\\r\\nreason = \"holdInstruction\";\\r\\nother = rev_arg;\\r\\nbreak;\\r\\ncase REV_KEY_COMPROMISE:\\r\\ncase REV_CA_COMPROMISE:\\r\\nif (!ASN1_GENERALIZEDTIME_set_string(NULL, rev_arg)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Invalid time format %s. Need YYYYMMDDHHMMSSZ\\n\",\\r\\nrev_arg);\\r\\nreturn NULL;\\r\\n}\\r\\nother = rev_arg;\\r\\nif (rev_type == REV_KEY_COMPROMISE)\\r\\nreason = \"keyTime\";\\r\\nelse\\r\\nreason = \"CAkeyTime\";\\r\\nbreak;\\r\\n}\\r\\nrevtm = X509_gmtime_adj(NULL, 0);\\r\\nif (!revtm)\\r\\nreturn NULL;\\r\\ni = revtm->length + 1;\\r\\nif (reason)\\r\\ni += strlen(reason) + 1;\\r\\nif (other)\\r\\ni += strlen(other) + 1;\\r\\nstr = OPENSSL_malloc(i);\\r\\nif (!str)\\r\\nreturn NULL;\\r\\nBUF_strlcpy(str, (char *)revtm->data, i);\\r\\nif (reason) {\\r\\nBUF_strlcat(str, \",\", i);\\r\\nBUF_strlcat(str, reason, i);\\r\\n}\\r\\nif (other) {\\r\\nBUF_strlcat(str, \",\", i);\\r\\nBUF_strlcat(str, other, i);\\r\\n}\\r\\nASN1_UTCTIME_free(revtm);\\r\\nreturn str;\\r\\n}\\r\\nint make_revoked(X509_REVOKED *rev, const char *str)\\r\\n{\\r\\nchar *tmp = NULL;\\r\\nint reason_code = -1;\\r\\nint i, ret = 0;\\r\\nASN1_OBJECT *hold = NULL;\\r\\nASN1_GENERALIZEDTIME *comp_time = NULL;\\r\\nASN1_ENUMERATED *rtmp = NULL;\\r\\nASN1_TIME *revDate = NULL;\\r\\ni = unpack_revinfo(&revDate, &reason_code, &hold, &comp_time, str);\\r\\nif (i == 0)\\r\\ngoto err;\\r\\nif (rev && !X509_REVOKED_set_revocationDate(rev, revDate))\\r\\ngoto err;\\r\\nif (rev && (reason_code != OCSP_REVOKED_STATUS_NOSTATUS)) {\\r\\nrtmp = ASN1_ENUMERATED_new();\\r\\nif (!rtmp || !ASN1_ENUMERATED_set(rtmp, reason_code))\\r\\ngoto err;\\r\\nif (!X509_REVOKED_add1_ext_i2d(rev, NID_crl_reason, rtmp, 0, 0))\\r\\ngoto err;\\r\\n}\\r\\nif (rev && comp_time) {\\r\\nif (!X509_REVOKED_add1_ext_i2d\\r\\n(rev, NID_invalidity_date, comp_time, 0, 0))\\r\\ngoto err;\\r\\n}\\r\\nif (rev && hold) {\\r\\nif (!X509_REVOKED_add1_ext_i2d\\r\\n(rev, NID_hold_instruction_code, hold, 0, 0))\\r\\ngoto err;\\r\\n}\\r\\nif (reason_code != OCSP_REVOKED_STATUS_NOSTATUS)\\r\\nret = 2;\\r\\nelse\\r\\nret = 1;\\r\\nerr:\\r\\nif (tmp)\\r\\nOPENSSL_free(tmp);\\r\\nASN1_OBJECT_free(hold);\\r\\nASN1_GENERALIZEDTIME_free(comp_time);\\r\\nASN1_ENUMERATED_free(rtmp);\\r\\nASN1_TIME_free(revDate);\\r\\nreturn ret;\\r\\n}\\r\\nint old_entry_print(BIO *bp, ASN1_OBJECT *obj, ASN1_STRING *str)\\r\\n{\\r\\nchar buf[25], *pbuf, *p;\\r\\nint j;\\r\\nj = i2a_ASN1_OBJECT(bp, obj);\\r\\npbuf = buf;\\r\\nfor (j = 22 - j; j > 0; j--)\\r\\n*(pbuf++) = ' ';\\r\\n*(pbuf++) = ':';\\r\\n*(pbuf++) = '\\0';\\r\\nBIO_puts(bp, buf);\\r\\nif (str->type == V_ASN1_PRINTABLESTRING)\\r\\nBIO_printf(bp, \"PRINTABLE:'\");\\r\\nelse if (str->type == V_ASN1_T61STRING)\\r\\nBIO_printf(bp, \"T61STRING:'\");\\r\\nelse if (str->type == V_ASN1_IA5STRING)\\r\\nBIO_printf(bp, \"IA5STRING:'\");\\r\\nelse if (str->type == V_ASN1_UNIVERSALSTRING)\\r\\nBIO_printf(bp, \"UNIVERSALSTRING:'\");\\r\\nelse\\r\\nBIO_printf(bp, \"ASN.1 %2d:'\", str->type);\\r\\np = (char *)str->data;\\r\\nfor (j = str->length; j > 0; j--) {\\r\\nif ((*p >= ' ') && (*p <= '~'))\\r\\nBIO_printf(bp, \"%c\", *p);\\r\\nelse if (*p & 0x80)\\r\\nBIO_printf(bp, \"\\\\0x%02X\", *p);\\r\\nelse if ((unsigned char)*p == 0xf7)\\r\\nBIO_printf(bp, \"^?\");\\r\\nelse\\r\\nBIO_printf(bp, \"^%c\", *p + '@');\\r\\np++;\\r\\n}\\r\\nBIO_printf(bp, \"'\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nint unpack_revinfo(ASN1_TIME **prevtm, int *preason, ASN1_OBJECT **phold,\\r\\nASN1_GENERALIZEDTIME **pinvtm, const char *str)\\r\\n{\\r\\nchar *tmp = NULL;\\r\\nchar *rtime_str, *reason_str = NULL, *arg_str = NULL, *p;\\r\\nint reason_code = -1;\\r\\nint ret = 0;\\r\\nunsigned int i;\\r\\nASN1_OBJECT *hold = NULL;\\r\\nASN1_GENERALIZEDTIME *comp_time = NULL;\\r\\ntmp = BUF_strdup(str);\\r\\np = strchr(tmp, ',');\\r\\nrtime_str = tmp;\\r\\nif (p) {\\r\\n*p = '\\0';\\r\\np++;\\r\\nreason_str = p;\\r\\np = strchr(p, ',');\\r\\nif (p) {\\r\\n*p = '\\0';\\r\\narg_str = p + 1;\\r\\n}\\r\\n}\\r\\nif (prevtm) {\\r\\n*prevtm = ASN1_UTCTIME_new();\\r\\nif (!ASN1_UTCTIME_set_string(*prevtm, rtime_str)) {\\r\\nBIO_printf(bio_err, \"invalid revocation date %s\\n\", rtime_str);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (reason_str) {\\r\\nfor (i = 0; i < NUM_REASONS; i++) {\\r\\nif (!strcasecmp(reason_str, crl_reasons[i])) {\\r\\nreason_code = i;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (reason_code == OCSP_REVOKED_STATUS_NOSTATUS) {\\r\\nBIO_printf(bio_err, \"invalid reason code %s\\n\", reason_str);\\r\\ngoto err;\\r\\n}\\r\\nif (reason_code == 7)\\r\\nreason_code = OCSP_REVOKED_STATUS_REMOVEFROMCRL;\\r\\nelse if (reason_code == 8) {\\r\\nif (!arg_str) {\\r\\nBIO_printf(bio_err, \"missing hold instruction\\n\");\\r\\ngoto err;\\r\\n}\\r\\nreason_code = OCSP_REVOKED_STATUS_CERTIFICATEHOLD;\\r\\nhold = OBJ_txt2obj(arg_str, 0);\\r\\nif (!hold) {\\r\\nBIO_printf(bio_err, \"invalid object identifier %s\\n\",\\r\\narg_str);\\r\\ngoto err;\\r\\n}\\r\\nif (phold)\\r\\n*phold = hold;\\r\\n} else if ((reason_code == 9) || (reason_code == 10)) {\\r\\nif (!arg_str) {\\r\\nBIO_printf(bio_err, \"missing compromised time\\n\");\\r\\ngoto err;\\r\\n}\\r\\ncomp_time = ASN1_GENERALIZEDTIME_new();\\r\\nif (!ASN1_GENERALIZEDTIME_set_string(comp_time, arg_str)) {\\r\\nBIO_printf(bio_err, \"invalid compromised time %s\\n\", arg_str);\\r\\ngoto err;\\r\\n}\\r\\nif (reason_code == 9)\\r\\nreason_code = OCSP_REVOKED_STATUS_KEYCOMPROMISE;\\r\\nelse\\r\\nreason_code = OCSP_REVOKED_STATUS_CACOMPROMISE;\\r\\n}\\r\\n}\\r\\nif (preason)\\r\\n*preason = reason_code;\\r\\nif (pinvtm)\\r\\n*pinvtm = comp_time;\\r\\nelse\\r\\nASN1_GENERALIZEDTIME_free(comp_time);\\r\\nret = 1;\\r\\nerr:\\r\\nif (tmp)\\r\\nOPENSSL_free(tmp);\\r\\nif (!phold)\\r\\nASN1_OBJECT_free(hold);\\r\\nif (!pinvtm)\\r\\nASN1_GENERALIZEDTIME_free(comp_time);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_err_c", "target": 0, "func": "void ERR_load_CMS_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(CMS_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, CMS_str_functs);\\r\\nERR_load_strings(0, CMS_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_asn_moid_c", "target": 0, "func": "static int oid_module_init(CONF_IMODULE *md, const CONF *cnf)\\r\\n{\\r\\nint i;\\r\\nconst char *oid_section;\\r\\nSTACK_OF(CONF_VALUE) *sktmp;\\r\\nCONF_VALUE *oval;\\r\\noid_section = CONF_imodule_get_value(md);\\r\\nif (!(sktmp = NCONF_get_section(cnf, oid_section))) {\\r\\nASN1err(ASN1_F_OID_MODULE_INIT, ASN1_R_ERROR_LOADING_SECTION);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {\\r\\noval = sk_CONF_VALUE_value(sktmp, i);\\r\\nif (!do_create(oval->value, oval->name)) {\\r\\nASN1err(ASN1_F_OID_MODULE_INIT, ASN1_R_ADDING_OBJECT);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void oid_module_finish(CONF_IMODULE *md)\\r\\n{\\r\\nOBJ_cleanup();\\r\\n}\\r\\nvoid ASN1_add_oid_module(void)\\r\\n{\\r\\nCONF_module_add(\"oid_section\", oid_module_init, oid_module_finish);\\r\\n}\\r\\nstatic int do_create(char *value, char *name)\\r\\n{\\r\\nint nid;\\r\\nASN1_OBJECT *oid;\\r\\nchar *ln, *ostr, *p, *lntmp;\\r\\np = strrchr(value, ',');\\r\\nif (!p) {\\r\\nln = name;\\r\\nostr = value;\\r\\n} else {\\r\\nln = NULL;\\r\\nostr = p + 1;\\r\\nif (!*ostr)\\r\\nreturn 0;\\r\\nwhile (isspace((unsigned char)*ostr))\\r\\nostr++;\\r\\n}\\r\\nnid = OBJ_create(ostr, name, ln);\\r\\nif (nid == NID_undef)\\r\\nreturn 0;\\r\\nif (p) {\\r\\nln = value;\\r\\nwhile (isspace((unsigned char)*ln))\\r\\nln++;\\r\\np--;\\r\\nwhile (isspace((unsigned char)*p)) {\\r\\nif (p == ln)\\r\\nreturn 0;\\r\\np--;\\r\\n}\\r\\np++;\\r\\nlntmp = OPENSSL_malloc((p - ln) + 1);\\r\\nif (lntmp == NULL)\\r\\nreturn 0;\\r\\nmemcpy(lntmp, ln, p - ln);\\r\\nlntmp[p - ln] = 0;\\r\\noid = OBJ_nid2obj(nid);\\r\\noid->ln = lntmp;\\r\\n}\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_verify_ctx_c", "target": 0, "func": "TS_VERIFY_CTX *TS_VERIFY_CTX_new(void)\\r\\n{\\r\\nTS_VERIFY_CTX *ctx =\\r\\n(TS_VERIFY_CTX *)OPENSSL_malloc(sizeof(TS_VERIFY_CTX));\\r\\nif (ctx)\\r\\nmemset(ctx, 0, sizeof(TS_VERIFY_CTX));\\r\\nelse\\r\\nTSerr(TS_F_TS_VERIFY_CTX_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn ctx;\\r\\n}\\r\\nvoid TS_VERIFY_CTX_init(TS_VERIFY_CTX *ctx)\\r\\n{\\r\\nOPENSSL_assert(ctx != NULL);\\r\\nmemset(ctx, 0, sizeof(TS_VERIFY_CTX));\\r\\n}\\r\\nvoid TS_VERIFY_CTX_free(TS_VERIFY_CTX *ctx)\\r\\n{\\r\\nif (!ctx)\\r\\nreturn;\\r\\nTS_VERIFY_CTX_cleanup(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nvoid TS_VERIFY_CTX_cleanup(TS_VERIFY_CTX *ctx)\\r\\n{\\r\\nif (!ctx)\\r\\nreturn;\\r\\nX509_STORE_free(ctx->store);\\r\\nsk_X509_pop_free(ctx->certs, X509_free);\\r\\nASN1_OBJECT_free(ctx->policy);\\r\\nX509_ALGOR_free(ctx->md_alg);\\r\\nOPENSSL_free(ctx->imprint);\\r\\nBIO_free_all(ctx->data);\\r\\nASN1_INTEGER_free(ctx->nonce);\\r\\nGENERAL_NAME_free(ctx->tsa_name);\\r\\nTS_VERIFY_CTX_init(ctx);\\r\\n}\\r\\nTS_VERIFY_CTX *TS_REQ_to_TS_VERIFY_CTX(TS_REQ *req, TS_VERIFY_CTX *ctx)\\r\\n{\\r\\nTS_VERIFY_CTX *ret = ctx;\\r\\nASN1_OBJECT *policy;\\r\\nTS_MSG_IMPRINT *imprint;\\r\\nX509_ALGOR *md_alg;\\r\\nASN1_OCTET_STRING *msg;\\r\\nconst ASN1_INTEGER *nonce;\\r\\nOPENSSL_assert(req != NULL);\\r\\nif (ret)\\r\\nTS_VERIFY_CTX_cleanup(ret);\\r\\nelse if (!(ret = TS_VERIFY_CTX_new()))\\r\\nreturn NULL;\\r\\nret->flags = TS_VFY_ALL_IMPRINT & ~(TS_VFY_TSA_NAME | TS_VFY_SIGNATURE);\\r\\nif ((policy = TS_REQ_get_policy_id(req)) != NULL) {\\r\\nif (!(ret->policy = OBJ_dup(policy)))\\r\\ngoto err;\\r\\n} else\\r\\nret->flags &= ~TS_VFY_POLICY;\\r\\nimprint = TS_REQ_get_msg_imprint(req);\\r\\nmd_alg = TS_MSG_IMPRINT_get_algo(imprint);\\r\\nif (!(ret->md_alg = X509_ALGOR_dup(md_alg)))\\r\\ngoto err;\\r\\nmsg = TS_MSG_IMPRINT_get_msg(imprint);\\r\\nret->imprint_len = ASN1_STRING_length(msg);\\r\\nif (!(ret->imprint = OPENSSL_malloc(ret->imprint_len)))\\r\\ngoto err;\\r\\nmemcpy(ret->imprint, ASN1_STRING_data(msg), ret->imprint_len);\\r\\nif ((nonce = TS_REQ_get_nonce(req)) != NULL) {\\r\\nif (!(ret->nonce = ASN1_INTEGER_dup(nonce)))\\r\\ngoto err;\\r\\n} else\\r\\nret->flags &= ~TS_VFY_NONCE;\\r\\nreturn ret;\\r\\nerr:\\r\\nif (ctx)\\r\\nTS_VERIFY_CTX_cleanup(ctx);\\r\\nelse\\r\\nTS_VERIFY_CTX_free(ret);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dso_lib_c", "target": 0, "func": "DSO *DSO_new(void)\\r\\n{\\r\\nreturn (DSO_new_method(NULL));\\r\\n}\\r\\nvoid DSO_set_default_method(DSO_METHOD *meth)\\r\\n{\\r\\ndefault_DSO_meth = meth;\\r\\n}\\r\\nDSO_METHOD *DSO_get_default_method(void)\\r\\n{\\r\\nreturn (default_DSO_meth);\\r\\n}\\r\\nDSO_METHOD *DSO_get_method(DSO *dso)\\r\\n{\\r\\nreturn (dso->meth);\\r\\n}\\r\\nDSO_METHOD *DSO_set_method(DSO *dso, DSO_METHOD *meth)\\r\\n{\\r\\nDSO_METHOD *mtmp;\\r\\nmtmp = dso->meth;\\r\\ndso->meth = meth;\\r\\nreturn (mtmp);\\r\\n}\\r\\nDSO *DSO_new_method(DSO_METHOD *meth)\\r\\n{\\r\\nDSO *ret;\\r\\nif (default_DSO_meth == NULL)\\r\\ndefault_DSO_meth = DSO_METHOD_openssl();\\r\\nret = (DSO *)OPENSSL_malloc(sizeof(DSO));\\r\\nif (ret == NULL) {\\r\\nDSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nmemset(ret, 0, sizeof(DSO));\\r\\nret->meth_data = sk_void_new_null();\\r\\nif (ret->meth_data == NULL) {\\r\\nDSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);\\r\\nOPENSSL_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (meth == NULL)\\r\\nret->meth = default_DSO_meth;\\r\\nelse\\r\\nret->meth = meth;\\r\\nret->references = 1;\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret)) {\\r\\nOPENSSL_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint DSO_free(DSO *dso)\\r\\n{\\r\\nint i;\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_DSO_FREE, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\ni = CRYPTO_add(&dso->references, -1, CRYPTO_LOCK_DSO);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"DSO\", dso);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn (1);\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"DSO_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif ((dso->meth->dso_unload != NULL) && !dso->meth->dso_unload(dso)) {\\r\\nDSOerr(DSO_F_DSO_FREE, DSO_R_UNLOAD_FAILED);\\r\\nreturn (0);\\r\\n}\\r\\nif ((dso->meth->finish != NULL) && !dso->meth->finish(dso)) {\\r\\nDSOerr(DSO_F_DSO_FREE, DSO_R_FINISH_FAILED);\\r\\nreturn (0);\\r\\n}\\r\\nsk_void_free(dso->meth_data);\\r\\nif (dso->filename != NULL)\\r\\nOPENSSL_free(dso->filename);\\r\\nif (dso->loaded_filename != NULL)\\r\\nOPENSSL_free(dso->loaded_filename);\\r\\nOPENSSL_free(dso);\\r\\nreturn (1);\\r\\n}\\r\\nint DSO_flags(DSO *dso)\\r\\n{\\r\\nreturn ((dso == NULL) ? 0 : dso->flags);\\r\\n}\\r\\nint DSO_up_ref(DSO *dso)\\r\\n{\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_DSO_UP_REF, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nCRYPTO_add(&dso->references, 1, CRYPTO_LOCK_DSO);\\r\\nreturn (1);\\r\\n}\\r\\nDSO *DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags)\\r\\n{\\r\\nDSO *ret;\\r\\nint allocated = 0;\\r\\nif (dso == NULL) {\\r\\nret = DSO_new_method(meth);\\r\\nif (ret == NULL) {\\r\\nDSOerr(DSO_F_DSO_LOAD, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nallocated = 1;\\r\\nif (DSO_ctrl(ret, DSO_CTRL_SET_FLAGS, flags, NULL) < 0) {\\r\\nDSOerr(DSO_F_DSO_LOAD, DSO_R_CTRL_FAILED);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\nret = dso;\\r\\nif (ret->filename != NULL) {\\r\\nDSOerr(DSO_F_DSO_LOAD, DSO_R_DSO_ALREADY_LOADED);\\r\\ngoto err;\\r\\n}\\r\\nif (filename != NULL)\\r\\nif (!DSO_set_filename(ret, filename)) {\\r\\nDSOerr(DSO_F_DSO_LOAD, DSO_R_SET_FILENAME_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nfilename = ret->filename;\\r\\nif (filename == NULL) {\\r\\nDSOerr(DSO_F_DSO_LOAD, DSO_R_NO_FILENAME);\\r\\ngoto err;\\r\\n}\\r\\nif (ret->meth->dso_load == NULL) {\\r\\nDSOerr(DSO_F_DSO_LOAD, DSO_R_UNSUPPORTED);\\r\\ngoto err;\\r\\n}\\r\\nif (!ret->meth->dso_load(ret)) {\\r\\nDSOerr(DSO_F_DSO_LOAD, DSO_R_LOAD_FAILED);\\r\\ngoto err;\\r\\n}\\r\\nreturn (ret);\\r\\nerr:\\r\\nif (allocated)\\r\\nDSO_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nvoid *DSO_bind_var(DSO *dso, const char *symname)\\r\\n{\\r\\nvoid *ret = NULL;\\r\\nif ((dso == NULL) || (symname == NULL)) {\\r\\nDSOerr(DSO_F_DSO_BIND_VAR, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (dso->meth->dso_bind_var == NULL) {\\r\\nDSOerr(DSO_F_DSO_BIND_VAR, DSO_R_UNSUPPORTED);\\r\\nreturn (NULL);\\r\\n}\\r\\nif ((ret = dso->meth->dso_bind_var(dso, symname)) == NULL) {\\r\\nDSOerr(DSO_F_DSO_BIND_VAR, DSO_R_SYM_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nDSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname)\\r\\n{\\r\\nDSO_FUNC_TYPE ret = NULL;\\r\\nif ((dso == NULL) || (symname == NULL)) {\\r\\nDSOerr(DSO_F_DSO_BIND_FUNC, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (dso->meth->dso_bind_func == NULL) {\\r\\nDSOerr(DSO_F_DSO_BIND_FUNC, DSO_R_UNSUPPORTED);\\r\\nreturn (NULL);\\r\\n}\\r\\nif ((ret = dso->meth->dso_bind_func(dso, symname)) == NULL) {\\r\\nDSOerr(DSO_F_DSO_BIND_FUNC, DSO_R_SYM_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nlong DSO_ctrl(DSO *dso, int cmd, long larg, void *parg)\\r\\n{\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_DSO_CTRL, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (-1);\\r\\n}\\r\\nswitch (cmd) {\\r\\ncase DSO_CTRL_GET_FLAGS:\\r\\nreturn dso->flags;\\r\\ncase DSO_CTRL_SET_FLAGS:\\r\\ndso->flags = (int)larg;\\r\\nreturn (0);\\r\\ncase DSO_CTRL_OR_FLAGS:\\r\\ndso->flags |= (int)larg;\\r\\nreturn (0);\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nif ((dso->meth == NULL) || (dso->meth->dso_ctrl == NULL)) {\\r\\nDSOerr(DSO_F_DSO_CTRL, DSO_R_UNSUPPORTED);\\r\\nreturn (-1);\\r\\n}\\r\\nreturn (dso->meth->dso_ctrl(dso, cmd, larg, parg));\\r\\n}\\r\\nint DSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb,\\r\\nDSO_NAME_CONVERTER_FUNC *oldcb)\\r\\n{\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_DSO_SET_NAME_CONVERTER, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (oldcb)\\r\\n*oldcb = dso->name_converter;\\r\\ndso->name_converter = cb;\\r\\nreturn (1);\\r\\n}\\r\\nconst char *DSO_get_filename(DSO *dso)\\r\\n{\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_DSO_GET_FILENAME, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (dso->filename);\\r\\n}\\r\\nint DSO_set_filename(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *copied;\\r\\nif ((dso == NULL) || (filename == NULL)) {\\r\\nDSOerr(DSO_F_DSO_SET_FILENAME, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (0);\\r\\n}\\r\\nif (dso->loaded_filename) {\\r\\nDSOerr(DSO_F_DSO_SET_FILENAME, DSO_R_DSO_ALREADY_LOADED);\\r\\nreturn (0);\\r\\n}\\r\\ncopied = OPENSSL_malloc(strlen(filename) + 1);\\r\\nif (copied == NULL) {\\r\\nDSOerr(DSO_F_DSO_SET_FILENAME, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nBUF_strlcpy(copied, filename, strlen(filename) + 1);\\r\\nif (dso->filename)\\r\\nOPENSSL_free(dso->filename);\\r\\ndso->filename = copied;\\r\\nreturn (1);\\r\\n}\\r\\nchar *DSO_merge(DSO *dso, const char *filespec1, const char *filespec2)\\r\\n{\\r\\nchar *result = NULL;\\r\\nif (dso == NULL || filespec1 == NULL) {\\r\\nDSOerr(DSO_F_DSO_MERGE, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif ((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0) {\\r\\nif (dso->merger != NULL)\\r\\nresult = dso->merger(dso, filespec1, filespec2);\\r\\nelse if (dso->meth->dso_merger != NULL)\\r\\nresult = dso->meth->dso_merger(dso, filespec1, filespec2);\\r\\n}\\r\\nreturn (result);\\r\\n}\\r\\nchar *DSO_convert_filename(DSO *dso, const char *filename)\\r\\n{\\r\\nchar *result = NULL;\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (filename == NULL)\\r\\nfilename = dso->filename;\\r\\nif (filename == NULL) {\\r\\nDSOerr(DSO_F_DSO_CONVERT_FILENAME, DSO_R_NO_FILENAME);\\r\\nreturn (NULL);\\r\\n}\\r\\nif ((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0) {\\r\\nif (dso->name_converter != NULL)\\r\\nresult = dso->name_converter(dso, filename);\\r\\nelse if (dso->meth->dso_name_converter != NULL)\\r\\nresult = dso->meth->dso_name_converter(dso, filename);\\r\\n}\\r\\nif (result == NULL) {\\r\\nresult = OPENSSL_malloc(strlen(filename) + 1);\\r\\nif (result == NULL) {\\r\\nDSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nBUF_strlcpy(result, filename, strlen(filename) + 1);\\r\\n}\\r\\nreturn (result);\\r\\n}\\r\\nconst char *DSO_get_loaded_filename(DSO *dso)\\r\\n{\\r\\nif (dso == NULL) {\\r\\nDSOerr(DSO_F_DSO_GET_LOADED_FILENAME, ERR_R_PASSED_NULL_PARAMETER);\\r\\nreturn (NULL);\\r\\n}\\r\\nreturn (dso->loaded_filename);\\r\\n}\\r\\nint DSO_pathbyaddr(void *addr, char *path, int sz)\\r\\n{\\r\\nDSO_METHOD *meth = default_DSO_meth;\\r\\nif (meth == NULL)\\r\\nmeth = DSO_METHOD_openssl();\\r\\nif (meth->pathbyaddr == NULL) {\\r\\nDSOerr(DSO_F_DSO_PATHBYADDR, DSO_R_UNSUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nreturn (*meth->pathbyaddr) (addr, path, sz);\\r\\n}\\r\\nvoid *DSO_global_lookup(const char *name)\\r\\n{\\r\\nDSO_METHOD *meth = default_DSO_meth;\\r\\nif (meth == NULL)\\r\\nmeth = DSO_METHOD_openssl();\\r\\nif (meth->globallookup == NULL) {\\r\\nDSOerr(DSO_F_DSO_GLOBAL_LOOKUP, DSO_R_UNSUPPORTED);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn (*meth->globallookup) (name);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_conn_c", "target": 0, "func": "static int conn_state(BIO *b, BIO_CONNECT *c)\\r\\n{\\r\\nint ret = -1, i;\\r\\nunsigned long l;\\r\\nchar *p, *q;\\r\\nint (*cb) (const BIO *, int, int) = NULL;\\r\\nif (c->info_callback != NULL)\\r\\ncb = c->info_callback;\\r\\nfor (;;) {\\r\\nswitch (c->state) {\\r\\ncase BIO_CONN_S_BEFORE:\\r\\np = c->param_hostname;\\r\\nif (p == NULL) {\\r\\nBIOerr(BIO_F_CONN_STATE, BIO_R_NO_HOSTNAME_SPECIFIED);\\r\\ngoto exit_loop;\\r\\n}\\r\\nfor (; *p != '\\0'; p++) {\\r\\nif ((*p == ':') || (*p == '/'))\\r\\nbreak;\\r\\n}\\r\\ni = *p;\\r\\nif ((i == ':') || (i == '/')) {\\r\\n*(p++) = '\\0';\\r\\nif (i == ':') {\\r\\nfor (q = p; *q; q++)\\r\\nif (*q == '/') {\\r\\n*q = '\\0';\\r\\nbreak;\\r\\n}\\r\\nif (c->param_port != NULL)\\r\\nOPENSSL_free(c->param_port);\\r\\nc->param_port = BUF_strdup(p);\\r\\n}\\r\\n}\\r\\nif (c->param_port == NULL) {\\r\\nBIOerr(BIO_F_CONN_STATE, BIO_R_NO_PORT_SPECIFIED);\\r\\nERR_add_error_data(2, \"host=\", c->param_hostname);\\r\\ngoto exit_loop;\\r\\n}\\r\\nc->state = BIO_CONN_S_GET_IP;\\r\\nbreak;\\r\\ncase BIO_CONN_S_GET_IP:\\r\\nif (BIO_get_host_ip(c->param_hostname, &(c->ip[0])) <= 0)\\r\\ngoto exit_loop;\\r\\nc->state = BIO_CONN_S_GET_PORT;\\r\\nbreak;\\r\\ncase BIO_CONN_S_GET_PORT:\\r\\nif (c->param_port == NULL) {\\r\\ngoto exit_loop;\\r\\n} else if (BIO_get_port(c->param_port, &c->port) <= 0)\\r\\ngoto exit_loop;\\r\\nc->state = BIO_CONN_S_CREATE_SOCKET;\\r\\nbreak;\\r\\ncase BIO_CONN_S_CREATE_SOCKET:\\r\\nmemset((char *)&c->them, 0, sizeof(c->them));\\r\\nc->them.sin_family = AF_INET;\\r\\nc->them.sin_port = htons((unsigned short)c->port);\\r\\nl = (unsigned long)\\r\\n((unsigned long)c->ip[0] << 24L) |\\r\\n((unsigned long)c->ip[1] << 16L) |\\r\\n((unsigned long)c->ip[2] << 8L) | ((unsigned long)c->ip[3]);\\r\\nc->them.sin_addr.s_addr = htonl(l);\\r\\nc->state = BIO_CONN_S_CREATE_SOCKET;\\r\\nret = socket(AF_INET, SOCK_STREAM, SOCKET_PROTOCOL);\\r\\nif (ret == INVALID_SOCKET) {\\r\\nSYSerr(SYS_F_SOCKET, get_last_socket_error());\\r\\nERR_add_error_data(4, \"host=\", c->param_hostname,\\r\\n\":\", c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE, BIO_R_UNABLE_TO_CREATE_SOCKET);\\r\\ngoto exit_loop;\\r\\n}\\r\\nb->num = ret;\\r\\nc->state = BIO_CONN_S_NBIO;\\r\\nbreak;\\r\\ncase BIO_CONN_S_NBIO:\\r\\nif (c->nbio) {\\r\\nif (!BIO_socket_nbio(b->num, 1)) {\\r\\nBIOerr(BIO_F_CONN_STATE, BIO_R_ERROR_SETTING_NBIO);\\r\\nERR_add_error_data(4, \"host=\",\\r\\nc->param_hostname, \":\", c->param_port);\\r\\ngoto exit_loop;\\r\\n}\\r\\n}\\r\\nc->state = BIO_CONN_S_CONNECT;\\r\\n# if defined(SO_KEEPALIVE) && !defined(OPENSSL_SYS_MPE)\\r\\ni = 1;\\r\\ni = setsockopt(b->num, SOL_SOCKET, SO_KEEPALIVE, (char *)&i,\\r\\nsizeof(i));\\r\\nif (i < 0) {\\r\\nSYSerr(SYS_F_SOCKET, get_last_socket_error());\\r\\nERR_add_error_data(4, \"host=\", c->param_hostname,\\r\\n\":\", c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE, BIO_R_KEEPALIVE);\\r\\ngoto exit_loop;\\r\\n}\\r\\n# endif\\r\\nbreak;\\r\\ncase BIO_CONN_S_CONNECT:\\r\\nBIO_clear_retry_flags(b);\\r\\nret = connect(b->num,\\r\\n(struct sockaddr *)&c->them, sizeof(c->them));\\r\\nb->retry_reason = 0;\\r\\nif (ret < 0) {\\r\\nif (BIO_sock_should_retry(ret)) {\\r\\nBIO_set_retry_special(b);\\r\\nc->state = BIO_CONN_S_BLOCKED_CONNECT;\\r\\nb->retry_reason = BIO_RR_CONNECT;\\r\\n} else {\\r\\nSYSerr(SYS_F_CONNECT, get_last_socket_error());\\r\\nERR_add_error_data(4, \"host=\",\\r\\nc->param_hostname, \":\", c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE, BIO_R_CONNECT_ERROR);\\r\\n}\\r\\ngoto exit_loop;\\r\\n} else\\r\\nc->state = BIO_CONN_S_OK;\\r\\nbreak;\\r\\ncase BIO_CONN_S_BLOCKED_CONNECT:\\r\\ni = BIO_sock_error(b->num);\\r\\nif (i) {\\r\\nBIO_clear_retry_flags(b);\\r\\nSYSerr(SYS_F_CONNECT, i);\\r\\nERR_add_error_data(4, \"host=\",\\r\\nc->param_hostname, \":\", c->param_port);\\r\\nBIOerr(BIO_F_CONN_STATE, BIO_R_NBIO_CONNECT_ERROR);\\r\\nret = 0;\\r\\ngoto exit_loop;\\r\\n} else\\r\\nc->state = BIO_CONN_S_OK;\\r\\nbreak;\\r\\ncase BIO_CONN_S_OK:\\r\\nret = 1;\\r\\ngoto exit_loop;\\r\\ndefault:\\r\\ngoto exit_loop;\\r\\n}\\r\\nif (cb != NULL) {\\r\\nif (!(ret = cb((BIO *)b, c->state, ret)))\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nexit_loop:\\r\\nif (cb != NULL)\\r\\nret = cb((BIO *)b, c->state, ret);\\r\\nend:\\r\\nreturn (ret);\\r\\n}\\r\\nBIO_CONNECT *BIO_CONNECT_new(void)\\r\\n{\\r\\nBIO_CONNECT *ret;\\r\\nif ((ret = (BIO_CONNECT *)OPENSSL_malloc(sizeof(BIO_CONNECT))) == NULL)\\r\\nreturn (NULL);\\r\\nret->state = BIO_CONN_S_BEFORE;\\r\\nret->param_hostname = NULL;\\r\\nret->param_port = NULL;\\r\\nret->info_callback = NULL;\\r\\nret->nbio = 0;\\r\\nret->ip[0] = 0;\\r\\nret->ip[1] = 0;\\r\\nret->ip[2] = 0;\\r\\nret->ip[3] = 0;\\r\\nret->port = 0;\\r\\nmemset((char *)&ret->them, 0, sizeof(ret->them));\\r\\nreturn (ret);\\r\\n}\\r\\nvoid BIO_CONNECT_free(BIO_CONNECT *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn;\\r\\nif (a->param_hostname != NULL)\\r\\nOPENSSL_free(a->param_hostname);\\r\\nif (a->param_port != NULL)\\r\\nOPENSSL_free(a->param_port);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nBIO_METHOD *BIO_s_connect(void)\\r\\n{\\r\\nreturn (&methods_connectp);\\r\\n}\\r\\nstatic int conn_new(BIO *bi)\\r\\n{\\r\\nbi->init = 0;\\r\\nbi->num = INVALID_SOCKET;\\r\\nbi->flags = 0;\\r\\nif ((bi->ptr = (char *)BIO_CONNECT_new()) == NULL)\\r\\nreturn (0);\\r\\nelse\\r\\nreturn (1);\\r\\n}\\r\\nstatic void conn_close_socket(BIO *bio)\\r\\n{\\r\\nBIO_CONNECT *c;\\r\\nc = (BIO_CONNECT *)bio->ptr;\\r\\nif (bio->num != INVALID_SOCKET) {\\r\\nif (c->state == BIO_CONN_S_OK)\\r\\nshutdown(bio->num, 2);\\r\\nclosesocket(bio->num);\\r\\nbio->num = INVALID_SOCKET;\\r\\n}\\r\\n}\\r\\nstatic int conn_free(BIO *a)\\r\\n{\\r\\nBIO_CONNECT *data;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\ndata = (BIO_CONNECT *)a->ptr;\\r\\nif (a->shutdown) {\\r\\nconn_close_socket(a);\\r\\nBIO_CONNECT_free(data);\\r\\na->ptr = NULL;\\r\\na->flags = 0;\\r\\na->init = 0;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int conn_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nBIO_CONNECT *data;\\r\\ndata = (BIO_CONNECT *)b->ptr;\\r\\nif (data->state != BIO_CONN_S_OK) {\\r\\nret = conn_state(b, data);\\r\\nif (ret <= 0)\\r\\nreturn (ret);\\r\\n}\\r\\nif (out != NULL) {\\r\\nclear_socket_error();\\r\\nret = readsocket(b->num, out, outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0) {\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_read(b);\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int conn_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nBIO_CONNECT *data;\\r\\ndata = (BIO_CONNECT *)b->ptr;\\r\\nif (data->state != BIO_CONN_S_OK) {\\r\\nret = conn_state(b, data);\\r\\nif (ret <= 0)\\r\\nreturn (ret);\\r\\n}\\r\\nclear_socket_error();\\r\\nret = writesocket(b->num, in, inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nif (ret <= 0) {\\r\\nif (BIO_sock_should_retry(ret))\\r\\nBIO_set_retry_write(b);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long conn_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nint *ip;\\r\\nconst char **pptr;\\r\\nlong ret = 1;\\r\\nBIO_CONNECT *data;\\r\\ndata = (BIO_CONNECT *)b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nret = 0;\\r\\ndata->state = BIO_CONN_S_BEFORE;\\r\\nconn_close_socket(b);\\r\\nb->flags = 0;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nif (data->state != BIO_CONN_S_OK)\\r\\nret = (long)conn_state(b, data);\\r\\nelse\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_CONNECT:\\r\\nif (ptr != NULL) {\\r\\npptr = (const char **)ptr;\\r\\nif (num == 0) {\\r\\n*pptr = data->param_hostname;\\r\\n} else if (num == 1) {\\r\\n*pptr = data->param_port;\\r\\n} else if (num == 2) {\\r\\n*pptr = (char *)&(data->ip[0]);\\r\\n} else if (num == 3) {\\r\\n*((int *)ptr) = data->port;\\r\\n}\\r\\nif ((!b->init) || (ptr == NULL))\\r\\n*pptr = \"not initialized\";\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_CONNECT:\\r\\nif (ptr != NULL) {\\r\\nb->init = 1;\\r\\nif (num == 0) {\\r\\nif (data->param_hostname != NULL)\\r\\nOPENSSL_free(data->param_hostname);\\r\\ndata->param_hostname = BUF_strdup(ptr);\\r\\n} else if (num == 1) {\\r\\nif (data->param_port != NULL)\\r\\nOPENSSL_free(data->param_port);\\r\\ndata->param_port = BUF_strdup(ptr);\\r\\n} else if (num == 2) {\\r\\nchar buf[16];\\r\\nunsigned char *p = ptr;\\r\\nBIO_snprintf(buf, sizeof buf, \"%d.%d.%d.%d\",\\r\\np[0], p[1], p[2], p[3]);\\r\\nif (data->param_hostname != NULL)\\r\\nOPENSSL_free(data->param_hostname);\\r\\ndata->param_hostname = BUF_strdup(buf);\\r\\nmemcpy(&(data->ip[0]), ptr, 4);\\r\\n} else if (num == 3) {\\r\\nchar buf[DECIMAL_SIZE(int) + 1];\\r\\nBIO_snprintf(buf, sizeof buf, \"%d\", *(int *)ptr);\\r\\nif (data->param_port != NULL)\\r\\nOPENSSL_free(data->param_port);\\r\\ndata->param_port = BUF_strdup(buf);\\r\\ndata->port = *(int *)ptr;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_NBIO:\\r\\ndata->nbio = (int)num;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init) {\\r\\nip = (int *)ptr;\\r\\nif (ip != NULL)\\r\\n*ip = b->num;\\r\\nret = b->num;\\r\\n} else\\r\\nret = -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown = (int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\n{\\r\\ndbio = (BIO *)ptr;\\r\\nif (data->param_port)\\r\\nBIO_set_conn_port(dbio, data->param_port);\\r\\nif (data->param_hostname)\\r\\nBIO_set_conn_hostname(dbio, data->param_hostname);\\r\\nBIO_set_nbio(dbio, data->nbio);\\r\\n(void)BIO_set_info_callback(dbio,\\r\\n(bio_info_cb *)data->info_callback);\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\n{\\r\\n# if 0\\r\\nBIOerr(BIO_F_CONN_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\\r\\nret = -1;\\r\\n# else\\r\\nret = 0;\\r\\n# endif\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CALLBACK:\\r\\n{\\r\\nint (**fptr) (const BIO *bio, int state, int xret);\\r\\nfptr = (int (**)(const BIO *bio, int state, int xret))ptr;\\r\\n*fptr = data->info_callback;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long conn_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret = 1;\\r\\nBIO_CONNECT *data;\\r\\ndata = (BIO_CONNECT *)b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_SET_CALLBACK:\\r\\n{\\r\\ndata->info_callback =\\r\\n(int (*)(const struct bio_st *, int, int))fp;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int conn_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = conn_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}\\r\\nBIO *BIO_new_connect(const char *str)\\r\\n{\\r\\nBIO *ret;\\r\\nret = BIO_new(BIO_s_connect());\\r\\nif (ret == NULL)\\r\\nreturn (NULL);\\r\\nif (BIO_set_conn_hostname(ret, str))\\r\\nreturn (ret);\\r\\nelse {\\r\\nBIO_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pk7_doit_c", "target": 1, "func": "static int PKCS7_type_is_other(PKCS7 *p7)\\r\\n{\\r\\nint isOther = 1;\\r\\nint nid = OBJ_obj2nid(p7->type);\\r\\nswitch (nid) {\\r\\ncase NID_pkcs7_data:\\r\\ncase NID_pkcs7_signed:\\r\\ncase NID_pkcs7_enveloped:\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\ncase NID_pkcs7_digest:\\r\\ncase NID_pkcs7_encrypted:\\r\\nisOther = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nisOther = 1;\\r\\n}\\r\\nreturn isOther;\\r\\n}\\r\\nstatic ASN1_OCTET_STRING *PKCS7_get_octet_string(PKCS7 *p7)\\r\\n{\\r\\nif (PKCS7_type_is_data(p7))\\r\\nreturn p7->d.data;\\r\\nif (PKCS7_type_is_other(p7) && p7->d.other\\r\\n&& (p7->d.other->type == V_ASN1_OCTET_STRING))\\r\\nreturn p7->d.other->value.octet_string;\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int PKCS7_bio_add_digest(BIO **pbio, X509_ALGOR *alg)\\r\\n{\\r\\nBIO *btmp;\\r\\nconst EVP_MD *md;\\r\\nif ((btmp = BIO_new(BIO_f_md())) == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nmd = EVP_get_digestbyobj(alg->algorithm);\\r\\nif (md == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, PKCS7_R_UNKNOWN_DIGEST_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_md(btmp, md);\\r\\nif (*pbio == NULL)\\r\\n*pbio = btmp;\\r\\nelse if (!BIO_push(*pbio, btmp)) {\\r\\nPKCS7err(PKCS7_F_PKCS7_BIO_ADD_DIGEST, ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbtmp = NULL;\\r\\nreturn 1;\\r\\nerr:\\r\\nif (btmp)\\r\\nBIO_free(btmp);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int pkcs7_encode_rinfo(PKCS7_RECIP_INFO *ri,\\r\\nunsigned char *key, int keylen)\\r\\n{\\r\\nEVP_PKEY_CTX *pctx = NULL;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nunsigned char *ek = NULL;\\r\\nint ret = 0;\\r\\nsize_t eklen;\\r\\npkey = X509_get_pubkey(ri->cert);\\r\\nif (!pkey)\\r\\nreturn 0;\\r\\npctx = EVP_PKEY_CTX_new(pkey, NULL);\\r\\nif (!pctx)\\r\\nreturn 0;\\r\\nif (EVP_PKEY_encrypt_init(pctx) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_ENCRYPT,\\r\\nEVP_PKEY_CTRL_PKCS7_ENCRYPT, 0, ri) <= 0) {\\r\\nPKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, PKCS7_R_CTRL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_encrypt(pctx, NULL, &eklen, key, keylen) <= 0)\\r\\ngoto err;\\r\\nek = OPENSSL_malloc(eklen);\\r\\nif (ek == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_ENCODE_RINFO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_encrypt(pctx, ek, &eklen, key, keylen) <= 0)\\r\\ngoto err;\\r\\nASN1_STRING_set0(ri->enc_key, ek, eklen);\\r\\nek = NULL;\\r\\nret = 1;\\r\\nerr:\\r\\nif (pkey)\\r\\nEVP_PKEY_free(pkey);\\r\\nif (pctx)\\r\\nEVP_PKEY_CTX_free(pctx);\\r\\nif (ek)\\r\\nOPENSSL_free(ek);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,\\r\\nPKCS7_RECIP_INFO *ri, EVP_PKEY *pkey)\\r\\n{\\r\\nEVP_PKEY_CTX *pctx = NULL;\\r\\nunsigned char *ek = NULL;\\r\\nsize_t eklen;\\r\\nint ret = -1;\\r\\npctx = EVP_PKEY_CTX_new(pkey, NULL);\\r\\nif (!pctx)\\r\\nreturn -1;\\r\\nif (EVP_PKEY_decrypt_init(pctx) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DECRYPT,\\r\\nEVP_PKEY_CTRL_PKCS7_DECRYPT, 0, ri) <= 0) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, PKCS7_R_CTRL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_decrypt(pctx, NULL, &eklen,\\r\\nri->enc_key->data, ri->enc_key->length) <= 0)\\r\\ngoto err;\\r\\nek = OPENSSL_malloc(eklen);\\r\\nif (ek == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_decrypt(pctx, ek, &eklen,\\r\\nri->enc_key->data, ri->enc_key->length) <= 0) {\\r\\nret = 0;\\r\\nPKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nif (*pek) {\\r\\nOPENSSL_cleanse(*pek, *peklen);\\r\\nOPENSSL_free(*pek);\\r\\n}\\r\\n*pek = ek;\\r\\n*peklen = eklen;\\r\\nerr:\\r\\nif (pctx)\\r\\nEVP_PKEY_CTX_free(pctx);\\r\\nif (!ret && ek)\\r\\nOPENSSL_free(ek);\\r\\nreturn ret;\\r\\n}\\r\\nBIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)\\r\\n{\\r\\nint i;\\r\\nBIO *out = NULL, *btmp = NULL;\\r\\nX509_ALGOR *xa = NULL;\\r\\nconst EVP_CIPHER *evp_cipher = NULL;\\r\\nSTACK_OF(X509_ALGOR) *md_sk = NULL;\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\\r\\nX509_ALGOR *xalg = NULL;\\r\\nPKCS7_RECIP_INFO *ri = NULL;\\r\\nASN1_OCTET_STRING *os = NULL;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\np7->state = PKCS7_S_HEADER;\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_signed:\\r\\nmd_sk = p7->d.sign->md_algs;\\r\\nos = PKCS7_get_octet_string(p7->d.sign->contents);\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nrsk = p7->d.signed_and_enveloped->recipientinfo;\\r\\nmd_sk = p7->d.signed_and_enveloped->md_algs;\\r\\nxalg = p7->d.signed_and_enveloped->enc_data->algorithm;\\r\\nevp_cipher = p7->d.signed_and_enveloped->enc_data->cipher;\\r\\nif (evp_cipher == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nrsk = p7->d.enveloped->recipientinfo;\\r\\nxalg = p7->d.enveloped->enc_data->algorithm;\\r\\nevp_cipher = p7->d.enveloped->enc_data->cipher;\\r\\nif (evp_cipher == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nxa = p7->d.digest->md;\\r\\nos = PKCS7_get_octet_string(p7->d.digest->contents);\\r\\nbreak;\\r\\ncase NID_pkcs7_data:\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < sk_X509_ALGOR_num(md_sk); i++)\\r\\nif (!PKCS7_bio_add_digest(&out, sk_X509_ALGOR_value(md_sk, i)))\\r\\ngoto err;\\r\\nif (xa && !PKCS7_bio_add_digest(&out, xa))\\r\\ngoto err;\\r\\nif (evp_cipher != NULL) {\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nint keylen, ivlen;\\r\\nEVP_CIPHER_CTX *ctx;\\r\\nif ((btmp = BIO_new(BIO_f_cipher())) == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAINIT, ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nBIO_get_cipher_ctx(btmp, &ctx);\\r\\nkeylen = EVP_CIPHER_key_length(evp_cipher);\\r\\nivlen = EVP_CIPHER_iv_length(evp_cipher);\\r\\nxalg->algorithm = OBJ_nid2obj(EVP_CIPHER_type(evp_cipher));\\r\\nif (ivlen > 0)\\r\\nif (RAND_pseudo_bytes(iv, ivlen) <= 0)\\r\\ngoto err;\\r\\nif (EVP_CipherInit_ex(ctx, evp_cipher, NULL, NULL, NULL, 1) <= 0)\\r\\ngoto err;\\r\\nif (EVP_CIPHER_CTX_rand_key(ctx, key) <= 0)\\r\\ngoto err;\\r\\nif (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, 1) <= 0)\\r\\ngoto err;\\r\\nif (ivlen > 0) {\\r\\nif (xalg->parameter == NULL) {\\r\\nxalg->parameter = ASN1_TYPE_new();\\r\\nif (xalg->parameter == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_CIPHER_param_to_asn1(ctx, xalg->parameter) < 0)\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\\r\\nri = sk_PKCS7_RECIP_INFO_value(rsk, i);\\r\\nif (pkcs7_encode_rinfo(ri, key, keylen) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nOPENSSL_cleanse(key, keylen);\\r\\nif (out == NULL)\\r\\nout = btmp;\\r\\nelse\\r\\nBIO_push(out, btmp);\\r\\nbtmp = NULL;\\r\\n}\\r\\nif (bio == NULL) {\\r\\nif (PKCS7_is_detached(p7))\\r\\nbio = BIO_new(BIO_s_null());\\r\\nelse if (os && os->length > 0)\\r\\nbio = BIO_new_mem_buf(os->data, os->length);\\r\\nif (bio == NULL) {\\r\\nbio = BIO_new(BIO_s_mem());\\r\\nif (bio == NULL)\\r\\ngoto err;\\r\\nBIO_set_mem_eof_return(bio, 0);\\r\\n}\\r\\n}\\r\\nif (out)\\r\\nBIO_push(out, bio);\\r\\nelse\\r\\nout = bio;\\r\\nbio = NULL;\\r\\nif (0) {\\r\\nerr:\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (btmp != NULL)\\r\\nBIO_free_all(btmp);\\r\\nout = NULL;\\r\\n}\\r\\nreturn (out);\\r\\n}\\r\\nstatic int pkcs7_cmp_ri(PKCS7_RECIP_INFO *ri, X509 *pcert)\\r\\n{\\r\\nint ret;\\r\\nret = X509_NAME_cmp(ri->issuer_and_serial->issuer,\\r\\npcert->cert_info->issuer);\\r\\nif (ret)\\r\\nreturn ret;\\r\\nreturn M_ASN1_INTEGER_cmp(pcert->cert_info->serialNumber,\\r\\nri->issuer_and_serial->serial);\\r\\n}\\r\\nBIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\\r\\n{\\r\\nint i, j;\\r\\nBIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;\\r\\nX509_ALGOR *xa;\\r\\nASN1_OCTET_STRING *data_body = NULL;\\r\\nconst EVP_MD *evp_md;\\r\\nconst EVP_CIPHER *evp_cipher = NULL;\\r\\nEVP_CIPHER_CTX *evp_ctx = NULL;\\r\\nX509_ALGOR *enc_alg = NULL;\\r\\nSTACK_OF(X509_ALGOR) *md_sk = NULL;\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\\r\\nPKCS7_RECIP_INFO *ri = NULL;\\r\\nunsigned char *ek = NULL, *tkey = NULL;\\r\\nint eklen = 0, tkeylen = 0;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\np7->state = PKCS7_S_HEADER;\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_signed:\\r\\ndata_body = PKCS7_get_octet_string(p7->d.sign->contents);\\r\\nif (!PKCS7_is_detached(p7) && data_body == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,\\r\\nPKCS7_R_INVALID_SIGNED_DATA_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nmd_sk = p7->d.sign->md_algs;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nrsk = p7->d.signed_and_enveloped->recipientinfo;\\r\\nmd_sk = p7->d.signed_and_enveloped->md_algs;\\r\\ndata_body = p7->d.signed_and_enveloped->enc_data->enc_data;\\r\\nenc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\\r\\nevp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\\r\\nif (evp_cipher == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,\\r\\nPKCS7_R_UNSUPPORTED_CIPHER_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nrsk = p7->d.enveloped->recipientinfo;\\r\\nenc_alg = p7->d.enveloped->enc_data->algorithm;\\r\\ndata_body = p7->d.enveloped->enc_data->enc_data;\\r\\nevp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\\r\\nif (evp_cipher == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,\\r\\nPKCS7_R_UNSUPPORTED_CIPHER_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (md_sk != NULL) {\\r\\nfor (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\\r\\nxa = sk_X509_ALGOR_value(md_sk, i);\\r\\nif ((btmp = BIO_new(BIO_f_md())) == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nj = OBJ_obj2nid(xa->algorithm);\\r\\nevp_md = EVP_get_digestbynid(j);\\r\\nif (evp_md == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,\\r\\nPKCS7_R_UNKNOWN_DIGEST_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nBIO_set_md(btmp, evp_md);\\r\\nif (out == NULL)\\r\\nout = btmp;\\r\\nelse\\r\\nBIO_push(out, btmp);\\r\\nbtmp = NULL;\\r\\n}\\r\\n}\\r\\nif (evp_cipher != NULL) {\\r\\n#if 0\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH];\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nunsigned char *p;\\r\\nint keylen, ivlen;\\r\\nint max;\\r\\nX509_OBJECT ret;\\r\\n#endif\\r\\nif ((etmp = BIO_new(BIO_f_cipher())) == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (pcert) {\\r\\nfor (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\\r\\nri = sk_PKCS7_RECIP_INFO_value(rsk, i);\\r\\nif (!pkcs7_cmp_ri(ri, pcert))\\r\\nbreak;\\r\\nri = NULL;\\r\\n}\\r\\nif (ri == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATADECODE,\\r\\nPKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (pcert == NULL) {\\r\\nfor (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\\r\\nri = sk_PKCS7_RECIP_INFO_value(rsk, i);\\r\\nif (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\\r\\ngoto err;\\r\\nERR_clear_error();\\r\\n}\\r\\n} else {\\r\\nif (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\\r\\ngoto err;\\r\\nERR_clear_error();\\r\\n}\\r\\nevp_ctx = NULL;\\r\\nBIO_get_cipher_ctx(etmp, &evp_ctx);\\r\\nif (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0)\\r\\ngoto err;\\r\\nif (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0)\\r\\ngoto err;\\r\\ntkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);\\r\\ntkey = OPENSSL_malloc(tkeylen);\\r\\nif (!tkey)\\r\\ngoto err;\\r\\nif (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)\\r\\ngoto err;\\r\\nif (ek == NULL) {\\r\\nek = tkey;\\r\\neklen = tkeylen;\\r\\ntkey = NULL;\\r\\n}\\r\\nif (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) {\\r\\nif (!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen)) {\\r\\nOPENSSL_cleanse(ek, eklen);\\r\\nOPENSSL_free(ek);\\r\\nek = tkey;\\r\\neklen = tkeylen;\\r\\ntkey = NULL;\\r\\n}\\r\\n}\\r\\nERR_clear_error();\\r\\nif (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0)\\r\\ngoto err;\\r\\nif (ek) {\\r\\nOPENSSL_cleanse(ek, eklen);\\r\\nOPENSSL_free(ek);\\r\\nek = NULL;\\r\\n}\\r\\nif (tkey) {\\r\\nOPENSSL_cleanse(tkey, tkeylen);\\r\\nOPENSSL_free(tkey);\\r\\ntkey = NULL;\\r\\n}\\r\\nif (out == NULL)\\r\\nout = etmp;\\r\\nelse\\r\\nBIO_push(out, etmp);\\r\\netmp = NULL;\\r\\n}\\r\\n#if 1\\r\\nif (PKCS7_is_detached(p7) || (in_bio != NULL)) {\\r\\nbio = in_bio;\\r\\n} else {\\r\\n# if 0\\r\\nbio = BIO_new(BIO_s_mem());\\r\\nBIO_set_mem_eof_return(bio, 0);\\r\\nif (data_body->length > 0)\\r\\nBIO_write(bio, (char *)data_body->data, data_body->length);\\r\\n# else\\r\\nif (data_body->length > 0)\\r\\nbio = BIO_new_mem_buf(data_body->data, data_body->length);\\r\\nelse {\\r\\nbio = BIO_new(BIO_s_mem());\\r\\nBIO_set_mem_eof_return(bio, 0);\\r\\n}\\r\\nif (bio == NULL)\\r\\ngoto err;\\r\\n# endif\\r\\n}\\r\\nBIO_push(out, bio);\\r\\nbio = NULL;\\r\\n#endif\\r\\nif (0) {\\r\\nerr:\\r\\nif (ek) {\\r\\nOPENSSL_cleanse(ek, eklen);\\r\\nOPENSSL_free(ek);\\r\\n}\\r\\nif (tkey) {\\r\\nOPENSSL_cleanse(tkey, tkeylen);\\r\\nOPENSSL_free(tkey);\\r\\n}\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (btmp != NULL)\\r\\nBIO_free_all(btmp);\\r\\nif (etmp != NULL)\\r\\nBIO_free_all(etmp);\\r\\nif (bio != NULL)\\r\\nBIO_free_all(bio);\\r\\nout = NULL;\\r\\n}\\r\\nreturn (out);\\r\\n}\\r\\nstatic BIO *PKCS7_find_digest(EVP_MD_CTX **pmd, BIO *bio, int nid)\\r\\n{\\r\\nfor (;;) {\\r\\nbio = BIO_find_type(bio, BIO_TYPE_MD);\\r\\nif (bio == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_FIND_DIGEST,\\r\\nPKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\\r\\nreturn NULL;\\r\\n}\\r\\nBIO_get_md_ctx(bio, pmd);\\r\\nif (*pmd == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_FIND_DIGEST, ERR_R_INTERNAL_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (EVP_MD_CTX_type(*pmd) == nid)\\r\\nreturn bio;\\r\\nbio = BIO_next(bio);\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int do_pkcs7_signed_attrib(PKCS7_SIGNER_INFO *si, EVP_MD_CTX *mctx)\\r\\n{\\r\\nunsigned char md_data[EVP_MAX_MD_SIZE];\\r\\nunsigned int md_len;\\r\\nif (!PKCS7_get_signed_attribute(si, NID_pkcs9_signingTime)) {\\r\\nif (!PKCS7_add0_attrib_signing_time(si, NULL)) {\\r\\nPKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (!EVP_DigestFinal_ex(mctx, md_data, &md_len)) {\\r\\nPKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_EVP_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS7_add1_attrib_digest(si, md_data, md_len)) {\\r\\nPKCS7err(PKCS7_F_DO_PKCS7_SIGNED_ATTRIB, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (!PKCS7_SIGNER_INFO_sign(si))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint PKCS7_dataFinal(PKCS7 *p7, BIO *bio)\\r\\n{\\r\\nint ret = 0;\\r\\nint i, j;\\r\\nBIO *btmp;\\r\\nPKCS7_SIGNER_INFO *si;\\r\\nEVP_MD_CTX *mdc, ctx_tmp;\\r\\nSTACK_OF(X509_ATTRIBUTE) *sk;\\r\\nSTACK_OF(PKCS7_SIGNER_INFO) *si_sk = NULL;\\r\\nASN1_OCTET_STRING *os = NULL;\\r\\nEVP_MD_CTX_init(&ctx_tmp);\\r\\ni = OBJ_obj2nid(p7->type);\\r\\np7->state = PKCS7_S_HEADER;\\r\\nswitch (i) {\\r\\ncase NID_pkcs7_data:\\r\\nos = p7->d.data;\\r\\nbreak;\\r\\ncase NID_pkcs7_signedAndEnveloped:\\r\\nsi_sk = p7->d.signed_and_enveloped->signer_info;\\r\\nos = p7->d.signed_and_enveloped->enc_data->enc_data;\\r\\nif (!os) {\\r\\nos = M_ASN1_OCTET_STRING_new();\\r\\nif (!os) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np7->d.signed_and_enveloped->enc_data->enc_data = os;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_enveloped:\\r\\nos = p7->d.enveloped->enc_data->enc_data;\\r\\nif (!os) {\\r\\nos = M_ASN1_OCTET_STRING_new();\\r\\nif (!os) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np7->d.enveloped->enc_data->enc_data = os;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_signed:\\r\\nsi_sk = p7->d.sign->signer_info;\\r\\nos = PKCS7_get_octet_string(p7->d.sign->contents);\\r\\nif (PKCS7_type_is_data(p7->d.sign->contents) && p7->detached) {\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\np7->d.sign->contents->d.data = NULL;\\r\\n}\\r\\nbreak;\\r\\ncase NID_pkcs7_digest:\\r\\nos = PKCS7_get_octet_string(p7->d.digest->contents);\\r\\nif (PKCS7_type_is_data(p7->d.digest->contents) && p7->detached) {\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\np7->d.digest->contents->d.data = NULL;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (si_sk != NULL) {\\r\\nfor (i = 0; i < sk_PKCS7_SIGNER_INFO_num(si_sk); i++) {\\r\\nsi = sk_PKCS7_SIGNER_INFO_value(si_sk, i);\\r\\nif (si->pkey == NULL)\\r\\ncontinue;\\r\\nj = OBJ_obj2nid(si->digest_alg->algorithm);\\r\\nbtmp = bio;\\r\\nbtmp = PKCS7_find_digest(&mdc, btmp, j);\\r\\nif (btmp == NULL)\\r\\ngoto err;\\r\\nif (!EVP_MD_CTX_copy_ex(&ctx_tmp, mdc))\\r\\ngoto err;\\r\\nsk = si->auth_attr;\\r\\nif (sk_X509_ATTRIBUTE_num(sk) > 0) {\\r\\nif (!do_pkcs7_signed_attrib(si, &ctx_tmp))\\r\\ngoto err;\\r\\n} else {\\r\\nunsigned char *abuf = NULL;\\r\\nunsigned int abuflen;\\r\\nabuflen = EVP_PKEY_size(si->pkey);\\r\\nabuf = OPENSSL_malloc(abuflen);\\r\\nif (!abuf)\\r\\ngoto err;\\r\\nif (!EVP_SignFinal(&ctx_tmp, abuf, &abuflen, si->pkey)) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL, ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nASN1_STRING_set0(si->enc_digest, abuf, abuflen);\\r\\n}\\r\\n}\\r\\n} else if (i == NID_pkcs7_digest) {\\r\\nunsigned char md_data[EVP_MAX_MD_SIZE];\\r\\nunsigned int md_len;\\r\\nif (!PKCS7_find_digest(&mdc, bio,\\r\\nOBJ_obj2nid(p7->d.digest->md->algorithm)))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(mdc, md_data, &md_len))\\r\\ngoto err;\\r\\nM_ASN1_OCTET_STRING_set(p7->d.digest->digest, md_data, md_len);\\r\\n}\\r\\nif (!PKCS7_is_detached(p7) && !(os->flags & ASN1_STRING_FLAG_NDEF)) {\\r\\nchar *cont;\\r\\nlong contlen;\\r\\nbtmp = BIO_find_type(bio, BIO_TYPE_MEM);\\r\\nif (btmp == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAFINAL, PKCS7_R_UNABLE_TO_FIND_MEM_BIO);\\r\\ngoto err;\\r\\n}\\r\\ncontlen = BIO_get_mem_data(btmp, &cont);\\r\\nBIO_set_flags(btmp, BIO_FLAGS_MEM_RDONLY);\\r\\nBIO_set_mem_eof_return(btmp, 0);\\r\\nASN1_STRING_set0(os, (unsigned char *)cont, contlen);\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx_tmp);\\r\\nreturn (ret);\\r\\n}\\r\\nint PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nEVP_MD_CTX mctx;\\r\\nEVP_PKEY_CTX *pctx;\\r\\nunsigned char *abuf = NULL;\\r\\nint alen;\\r\\nsize_t siglen;\\r\\nconst EVP_MD *md = NULL;\\r\\nmd = EVP_get_digestbyobj(si->digest_alg->algorithm);\\r\\nif (md == NULL)\\r\\nreturn 0;\\r\\nEVP_MD_CTX_init(&mctx);\\r\\nif (EVP_DigestSignInit(&mctx, &pctx, md, NULL, si->pkey) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\\r\\nEVP_PKEY_CTRL_PKCS7_SIGN, 0, si) <= 0) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nalen = ASN1_item_i2d((ASN1_VALUE *)si->auth_attr, &abuf,\\r\\nASN1_ITEM_rptr(PKCS7_ATTR_SIGN));\\r\\nif (!abuf)\\r\\ngoto err;\\r\\nif (EVP_DigestSignUpdate(&mctx, abuf, alen) <= 0)\\r\\ngoto err;\\r\\nOPENSSL_free(abuf);\\r\\nabuf = NULL;\\r\\nif (EVP_DigestSignFinal(&mctx, NULL, &siglen) <= 0)\\r\\ngoto err;\\r\\nabuf = OPENSSL_malloc(siglen);\\r\\nif (!abuf)\\r\\ngoto err;\\r\\nif (EVP_DigestSignFinal(&mctx, abuf, &siglen) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_SIGN,\\r\\nEVP_PKEY_CTRL_PKCS7_SIGN, 1, si) <= 0) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNER_INFO_SIGN, PKCS7_R_CTRL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nEVP_MD_CTX_cleanup(&mctx);\\r\\nASN1_STRING_set0(si->enc_digest, abuf, siglen);\\r\\nreturn 1;\\r\\nerr:\\r\\nif (abuf)\\r\\nOPENSSL_free(abuf);\\r\\nEVP_MD_CTX_cleanup(&mctx);\\r\\nreturn 0;\\r\\n}\\r\\nint PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,\\r\\nPKCS7 *p7, PKCS7_SIGNER_INFO *si)\\r\\n{\\r\\nPKCS7_ISSUER_AND_SERIAL *ias;\\r\\nint ret = 0, i;\\r\\nSTACK_OF(X509) *cert;\\r\\nX509 *x509;\\r\\nif (PKCS7_type_is_signed(p7)) {\\r\\ncert = p7->d.sign->cert;\\r\\n} else if (PKCS7_type_is_signedAndEnveloped(p7)) {\\r\\ncert = p7->d.signed_and_enveloped->cert;\\r\\n} else {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_WRONG_PKCS7_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nias = si->issuer_and_serial;\\r\\nx509 = X509_find_by_issuer_and_serial(cert, ias->issuer, ias->serial);\\r\\nif (x509 == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY,\\r\\nPKCS7_R_UNABLE_TO_FIND_CERTIFICATE);\\r\\ngoto err;\\r\\n}\\r\\nif (!X509_STORE_CTX_init(ctx, cert_store, x509, cert)) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);\\r\\ngoto err;\\r\\n}\\r\\nX509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_SMIME_SIGN);\\r\\ni = X509_verify_cert(ctx);\\r\\nif (i <= 0) {\\r\\nPKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);\\r\\nX509_STORE_CTX_cleanup(ctx);\\r\\ngoto err;\\r\\n}\\r\\nX509_STORE_CTX_cleanup(ctx);\\r\\nreturn PKCS7_signatureVerify(bio, p7, si, x509);\\r\\nerr:\\r\\nreturn ret;\\r\\n}\\r\\nint PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,\\r\\nX509 *x509)\\r\\n{\\r\\nASN1_OCTET_STRING *os;\\r\\nEVP_MD_CTX mdc_tmp, *mdc;\\r\\nint ret = 0, i;\\r\\nint md_type;\\r\\nSTACK_OF(X509_ATTRIBUTE) *sk;\\r\\nBIO *btmp;\\r\\nEVP_PKEY *pkey;\\r\\nEVP_MD_CTX_init(&mdc_tmp);\\r\\nif (!PKCS7_type_is_signed(p7) && !PKCS7_type_is_signedAndEnveloped(p7)) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, PKCS7_R_WRONG_PKCS7_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nmd_type = OBJ_obj2nid(si->digest_alg->algorithm);\\r\\nbtmp = bio;\\r\\nfor (;;) {\\r\\nif ((btmp == NULL) ||\\r\\n((btmp = BIO_find_type(btmp, BIO_TYPE_MD)) == NULL)) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\\r\\ngoto err;\\r\\n}\\r\\nBIO_get_md_ctx(btmp, &mdc);\\r\\nif (mdc == NULL) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, ERR_R_INTERNAL_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_MD_CTX_type(mdc) == md_type)\\r\\nbreak;\\r\\nif (EVP_MD_pkey_type(EVP_MD_CTX_md(mdc)) == md_type)\\r\\nbreak;\\r\\nbtmp = BIO_next(btmp);\\r\\n}\\r\\nif (!EVP_MD_CTX_copy_ex(&mdc_tmp, mdc))\\r\\ngoto err;\\r\\nsk = si->auth_attr;\\r\\nif ((sk != NULL) && (sk_X509_ATTRIBUTE_num(sk) != 0)) {\\r\\nunsigned char md_dat[EVP_MAX_MD_SIZE], *abuf = NULL;\\r\\nunsigned int md_len;\\r\\nint alen;\\r\\nASN1_OCTET_STRING *message_digest;\\r\\nif (!EVP_DigestFinal_ex(&mdc_tmp, md_dat, &md_len))\\r\\ngoto err;\\r\\nmessage_digest = PKCS7_digest_from_attributes(sk);\\r\\nif (!message_digest) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY,\\r\\nPKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST);\\r\\ngoto err;\\r\\n}\\r\\nif ((message_digest->length != (int)md_len) ||\\r\\n(memcmp(message_digest->data, md_dat, md_len))) {\\r\\n#if 0\\r\\n{\\r\\nint ii;\\r\\nfor (ii = 0; ii < message_digest->length; ii++)\\r\\nprintf(\"%02X\", message_digest->data[ii]);\\r\\nprintf(\" sent\\n\");\\r\\nfor (ii = 0; ii < md_len; ii++)\\r\\nprintf(\"%02X\", md_dat[ii]);\\r\\nprintf(\" calc\\n\");\\r\\n}\\r\\n#endif\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, PKCS7_R_DIGEST_FAILURE);\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_VerifyInit_ex(&mdc_tmp, EVP_get_digestbynid(md_type), NULL))\\r\\ngoto err;\\r\\nalen = ASN1_item_i2d((ASN1_VALUE *)sk, &abuf,\\r\\nASN1_ITEM_rptr(PKCS7_ATTR_VERIFY));\\r\\nif (alen <= 0) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, ERR_R_ASN1_LIB);\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_VerifyUpdate(&mdc_tmp, abuf, alen))\\r\\ngoto err;\\r\\nOPENSSL_free(abuf);\\r\\n}\\r\\nos = si->enc_digest;\\r\\npkey = X509_get_pubkey(x509);\\r\\nif (!pkey) {\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\ni = EVP_VerifyFinal(&mdc_tmp, os->data, os->length, pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (i <= 0) {\\r\\nPKCS7err(PKCS7_F_PKCS7_SIGNATUREVERIFY, PKCS7_R_SIGNATURE_FAILURE);\\r\\nret = -1;\\r\\ngoto err;\\r\\n} else\\r\\nret = 1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&mdc_tmp);\\r\\nreturn (ret);\\r\\n}\\r\\nPKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx)\\r\\n{\\r\\nSTACK_OF(PKCS7_RECIP_INFO) *rsk;\\r\\nPKCS7_RECIP_INFO *ri;\\r\\nint i;\\r\\ni = OBJ_obj2nid(p7->type);\\r\\nif (i != NID_pkcs7_signedAndEnveloped)\\r\\nreturn NULL;\\r\\nif (p7->d.signed_and_enveloped == NULL)\\r\\nreturn NULL;\\r\\nrsk = p7->d.signed_and_enveloped->recipientinfo;\\r\\nif (rsk == NULL)\\r\\nreturn NULL;\\r\\nri = sk_PKCS7_RECIP_INFO_value(rsk, 0);\\r\\nif (sk_PKCS7_RECIP_INFO_num(rsk) <= idx)\\r\\nreturn (NULL);\\r\\nri = sk_PKCS7_RECIP_INFO_value(rsk, idx);\\r\\nreturn (ri->issuer_and_serial);\\r\\n}\\r\\nASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid)\\r\\n{\\r\\nreturn (get_attribute(si->auth_attr, nid));\\r\\n}\\r\\nASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)\\r\\n{\\r\\nreturn (get_attribute(si->unauth_attr, nid));\\r\\n}\\r\\nint PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,\\r\\nvoid *value)\\r\\n{\\r\\nreturn (add_attribute(&(p7si->auth_attr), nid, atrtype, value));\\r\\n}\\r\\nint PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,\\r\\nvoid *value)\\r\\n{\\r\\nreturn (add_attribute(&(p7si->unauth_attr), nid, atrtype, value));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pcy_cache_c", "target": 0, "func": "static int policy_cache_create(X509 *x,\\r\\nCERTIFICATEPOLICIES *policies, int crit)\\r\\n{\\r\\nint i;\\r\\nint ret = 0;\\r\\nX509_POLICY_CACHE *cache = x->policy_cache;\\r\\nX509_POLICY_DATA *data = NULL;\\r\\nPOLICYINFO *policy;\\r\\nif (sk_POLICYINFO_num(policies) == 0)\\r\\ngoto bad_policy;\\r\\ncache->data = sk_X509_POLICY_DATA_new(policy_data_cmp);\\r\\nif (!cache->data)\\r\\ngoto bad_policy;\\r\\nfor (i = 0; i < sk_POLICYINFO_num(policies); i++) {\\r\\npolicy = sk_POLICYINFO_value(policies, i);\\r\\ndata = policy_data_new(policy, NULL, crit);\\r\\nif (!data)\\r\\ngoto bad_policy;\\r\\nif (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\\r\\nif (cache->anyPolicy) {\\r\\nret = -1;\\r\\ngoto bad_policy;\\r\\n}\\r\\ncache->anyPolicy = data;\\r\\n} else if (sk_X509_POLICY_DATA_find(cache->data, data) != -1) {\\r\\nret = -1;\\r\\ngoto bad_policy;\\r\\n} else if (!sk_X509_POLICY_DATA_push(cache->data, data))\\r\\ngoto bad_policy;\\r\\ndata = NULL;\\r\\n}\\r\\nret = 1;\\r\\nbad_policy:\\r\\nif (ret == -1)\\r\\nx->ex_flags |= EXFLAG_INVALID_POLICY;\\r\\nif (data)\\r\\npolicy_data_free(data);\\r\\nsk_POLICYINFO_pop_free(policies, POLICYINFO_free);\\r\\nif (ret <= 0) {\\r\\nsk_X509_POLICY_DATA_pop_free(cache->data, policy_data_free);\\r\\ncache->data = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int policy_cache_new(X509 *x)\\r\\n{\\r\\nX509_POLICY_CACHE *cache;\\r\\nASN1_INTEGER *ext_any = NULL;\\r\\nPOLICY_CONSTRAINTS *ext_pcons = NULL;\\r\\nCERTIFICATEPOLICIES *ext_cpols = NULL;\\r\\nPOLICY_MAPPINGS *ext_pmaps = NULL;\\r\\nint i;\\r\\ncache = OPENSSL_malloc(sizeof(X509_POLICY_CACHE));\\r\\nif (!cache)\\r\\nreturn 0;\\r\\ncache->anyPolicy = NULL;\\r\\ncache->data = NULL;\\r\\ncache->any_skip = -1;\\r\\ncache->explicit_skip = -1;\\r\\ncache->map_skip = -1;\\r\\nx->policy_cache = cache;\\r\\next_pcons = X509_get_ext_d2i(x, NID_policy_constraints, &i, NULL);\\r\\nif (!ext_pcons) {\\r\\nif (i != -1)\\r\\ngoto bad_cache;\\r\\n} else {\\r\\nif (!ext_pcons->requireExplicitPolicy\\r\\n&& !ext_pcons->inhibitPolicyMapping)\\r\\ngoto bad_cache;\\r\\nif (!policy_cache_set_int(&cache->explicit_skip,\\r\\next_pcons->requireExplicitPolicy))\\r\\ngoto bad_cache;\\r\\nif (!policy_cache_set_int(&cache->map_skip,\\r\\next_pcons->inhibitPolicyMapping))\\r\\ngoto bad_cache;\\r\\n}\\r\\next_cpols = X509_get_ext_d2i(x, NID_certificate_policies, &i, NULL);\\r\\nif (!ext_cpols) {\\r\\nif (i != -1)\\r\\ngoto bad_cache;\\r\\nreturn 1;\\r\\n}\\r\\ni = policy_cache_create(x, ext_cpols, i);\\r\\nif (i <= 0)\\r\\nreturn i;\\r\\next_pmaps = X509_get_ext_d2i(x, NID_policy_mappings, &i, NULL);\\r\\nif (!ext_pmaps) {\\r\\nif (i != -1)\\r\\ngoto bad_cache;\\r\\n} else {\\r\\ni = policy_cache_set_mapping(x, ext_pmaps);\\r\\nif (i <= 0)\\r\\ngoto bad_cache;\\r\\n}\\r\\next_any = X509_get_ext_d2i(x, NID_inhibit_any_policy, &i, NULL);\\r\\nif (!ext_any) {\\r\\nif (i != -1)\\r\\ngoto bad_cache;\\r\\n} else if (!policy_cache_set_int(&cache->any_skip, ext_any))\\r\\ngoto bad_cache;\\r\\nif (0) {\\r\\nbad_cache:\\r\\nx->ex_flags |= EXFLAG_INVALID_POLICY;\\r\\n}\\r\\nif (ext_pcons)\\r\\nPOLICY_CONSTRAINTS_free(ext_pcons);\\r\\nif (ext_any)\\r\\nASN1_INTEGER_free(ext_any);\\r\\nreturn 1;\\r\\n}\\r\\nvoid policy_cache_free(X509_POLICY_CACHE *cache)\\r\\n{\\r\\nif (!cache)\\r\\nreturn;\\r\\nif (cache->anyPolicy)\\r\\npolicy_data_free(cache->anyPolicy);\\r\\nif (cache->data)\\r\\nsk_X509_POLICY_DATA_pop_free(cache->data, policy_data_free);\\r\\nOPENSSL_free(cache);\\r\\n}\\r\\nconst X509_POLICY_CACHE *policy_cache_set(X509 *x)\\r\\n{\\r\\nif (x->policy_cache == NULL) {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509);\\r\\npolicy_cache_new(x);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509);\\r\\n}\\r\\nreturn x->policy_cache;\\r\\n}\\r\\nX509_POLICY_DATA *policy_cache_find_data(const X509_POLICY_CACHE *cache,\\r\\nconst ASN1_OBJECT *id)\\r\\n{\\r\\nint idx;\\r\\nX509_POLICY_DATA tmp;\\r\\ntmp.valid_policy = (ASN1_OBJECT *)id;\\r\\nidx = sk_X509_POLICY_DATA_find(cache->data, &tmp);\\r\\nif (idx == -1)\\r\\nreturn NULL;\\r\\nreturn sk_X509_POLICY_DATA_value(cache->data, idx);\\r\\n}\\r\\nstatic int policy_data_cmp(const X509_POLICY_DATA *const *a,\\r\\nconst X509_POLICY_DATA *const *b)\\r\\n{\\r\\nreturn OBJ_cmp((*a)->valid_policy, (*b)->valid_policy);\\r\\n}\\r\\nstatic int policy_cache_set_int(long *out, ASN1_INTEGER *value)\\r\\n{\\r\\nif (value == NULL)\\r\\nreturn 1;\\r\\nif (value->type == V_ASN1_NEG_INTEGER)\\r\\nreturn 0;\\r\\n*out = ASN1_INTEGER_get(value);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rmd_one_c", "target": 0, "func": "unsigned char *RIPEMD160(const unsigned char *d, size_t n, unsigned char *md)\\r\\n{\\r\\nRIPEMD160_CTX c;\\r\\nstatic unsigned char m[RIPEMD160_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nif (!RIPEMD160_Init(&c))\\r\\nreturn NULL;\\r\\nRIPEMD160_Update(&c, d, n);\\r\\nRIPEMD160_Final(md, &c);\\r\\nOPENSSL_cleanse(&c, sizeof(c));\\r\\nreturn (md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_asn1_par_c", "target": 0, "func": "static int asn1_print_info(BIO *bp, int tag, int xclass, int constructed,\\r\\nint indent)\\r\\n{\\r\\nstatic const char fmt[] = \"%-18s\";\\r\\nchar str[128];\\r\\nconst char *p;\\r\\nif (constructed & V_ASN1_CONSTRUCTED)\\r\\np = \"cons: \";\\r\\nelse\\r\\np = \"prim: \";\\r\\nif (BIO_write(bp, p, 6) < 6)\\r\\ngoto err;\\r\\nBIO_indent(bp, indent, 128);\\r\\np = str;\\r\\nif ((xclass & V_ASN1_PRIVATE) == V_ASN1_PRIVATE)\\r\\nBIO_snprintf(str, sizeof str, \"priv [ %d ] \", tag);\\r\\nelse if ((xclass & V_ASN1_CONTEXT_SPECIFIC) == V_ASN1_CONTEXT_SPECIFIC)\\r\\nBIO_snprintf(str, sizeof str, \"cont [ %d ]\", tag);\\r\\nelse if ((xclass & V_ASN1_APPLICATION) == V_ASN1_APPLICATION)\\r\\nBIO_snprintf(str, sizeof str, \"appl [ %d ]\", tag);\\r\\nelse if (tag > 30)\\r\\nBIO_snprintf(str, sizeof str, \"<ASN1 %d>\", tag);\\r\\nelse\\r\\np = ASN1_tag2str(tag);\\r\\nif (BIO_printf(bp, fmt, p) <= 0)\\r\\ngoto err;\\r\\nreturn (1);\\r\\nerr:\\r\\nreturn (0);\\r\\n}\\r\\nint ASN1_parse(BIO *bp, const unsigned char *pp, long len, int indent)\\r\\n{\\r\\nreturn (asn1_parse2(bp, &pp, len, 0, 0, indent, 0));\\r\\n}\\r\\nint ASN1_parse_dump(BIO *bp, const unsigned char *pp, long len, int indent,\\r\\nint dump)\\r\\n{\\r\\nreturn (asn1_parse2(bp, &pp, len, 0, 0, indent, dump));\\r\\n}\\r\\nstatic int asn1_parse2(BIO *bp, const unsigned char **pp, long length,\\r\\nint offset, int depth, int indent, int dump)\\r\\n{\\r\\nconst unsigned char *p, *ep, *tot, *op, *opp;\\r\\nlong len;\\r\\nint tag, xclass, ret = 0;\\r\\nint nl, hl, j, r;\\r\\nASN1_OBJECT *o = NULL;\\r\\nASN1_OCTET_STRING *os = NULL;\\r\\nint dump_indent;\\r\\n#if 0\\r\\ndump_indent = indent;\\r\\n#else\\r\\ndump_indent = 6;\\r\\n#endif\\r\\np = *pp;\\r\\ntot = p + length;\\r\\nop = p - 1;\\r\\nwhile ((p < tot) && (op < p)) {\\r\\nop = p;\\r\\nj = ASN1_get_object(&p, &len, &tag, &xclass, length);\\r\\n#ifdef LINT\\r\\nj = j;\\r\\n#endif\\r\\nif (j & 0x80) {\\r\\nif (BIO_write(bp, \"Error in encoding\\n\", 18) <= 0)\\r\\ngoto end;\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nhl = (p - op);\\r\\nlength -= hl;\\r\\nif (BIO_printf(bp, \"%5ld:\", (long)offset + (long)(op - *pp))\\r\\n<= 0)\\r\\ngoto end;\\r\\nif (j != (V_ASN1_CONSTRUCTED | 1)) {\\r\\nif (BIO_printf(bp, \"d=%-2d hl=%ld l=%4ld \",\\r\\ndepth, (long)hl, len) <= 0)\\r\\ngoto end;\\r\\n} else {\\r\\nif (BIO_printf(bp, \"d=%-2d hl=%ld l=inf \", depth, (long)hl) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (!asn1_print_info(bp, tag, xclass, j, (indent) ? depth : 0))\\r\\ngoto end;\\r\\nif (j & V_ASN1_CONSTRUCTED) {\\r\\nep = p + len;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto end;\\r\\nif (len > length) {\\r\\nBIO_printf(bp, \"length is greater than %ld\\n\", length);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif ((j == 0x21) && (len == 0)) {\\r\\nfor (;;) {\\r\\nr = asn1_parse2(bp, &p, (long)(tot - p),\\r\\noffset + (p - *pp), depth + 1,\\r\\nindent, dump);\\r\\nif (r == 0) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif ((r == 2) || (p >= tot))\\r\\nbreak;\\r\\n}\\r\\n} else\\r\\nwhile (p < ep) {\\r\\nr = asn1_parse2(bp, &p, (long)len,\\r\\noffset + (p - *pp), depth + 1,\\r\\nindent, dump);\\r\\nif (r == 0) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n} else if (xclass != 0) {\\r\\np += len;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto end;\\r\\n} else {\\r\\nnl = 0;\\r\\nif ((tag == V_ASN1_PRINTABLESTRING) ||\\r\\n(tag == V_ASN1_T61STRING) ||\\r\\n(tag == V_ASN1_IA5STRING) ||\\r\\n(tag == V_ASN1_VISIBLESTRING) ||\\r\\n(tag == V_ASN1_NUMERICSTRING) ||\\r\\n(tag == V_ASN1_UTF8STRING) ||\\r\\n(tag == V_ASN1_UTCTIME) || (tag == V_ASN1_GENERALIZEDTIME)) {\\r\\nif (BIO_write(bp, \":\", 1) <= 0)\\r\\ngoto end;\\r\\nif ((len > 0) && BIO_write(bp, (const char *)p, (int)len)\\r\\n!= (int)len)\\r\\ngoto end;\\r\\n} else if (tag == V_ASN1_OBJECT) {\\r\\nopp = op;\\r\\nif (d2i_ASN1_OBJECT(&o, &opp, len + hl) != NULL) {\\r\\nif (BIO_write(bp, \":\", 1) <= 0)\\r\\ngoto end;\\r\\ni2a_ASN1_OBJECT(bp, o);\\r\\n} else {\\r\\nif (BIO_write(bp, \":BAD OBJECT\", 11) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n} else if (tag == V_ASN1_BOOLEAN) {\\r\\nint ii;\\r\\nopp = op;\\r\\nii = d2i_ASN1_BOOLEAN(NULL, &opp, len + hl);\\r\\nif (ii < 0) {\\r\\nif (BIO_write(bp, \"Bad boolean\\n\", 12) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bp, \":%d\", ii);\\r\\n} else if (tag == V_ASN1_BMPSTRING) {\\r\\n} else if (tag == V_ASN1_OCTET_STRING) {\\r\\nint i, printable = 1;\\r\\nopp = op;\\r\\nos = d2i_ASN1_OCTET_STRING(NULL, &opp, len + hl);\\r\\nif (os != NULL && os->length > 0) {\\r\\nopp = os->data;\\r\\nfor (i = 0; i < os->length; i++) {\\r\\nif (((opp[i] < ' ') &&\\r\\n(opp[i] != '\\n') &&\\r\\n(opp[i] != '\\r') &&\\r\\n(opp[i] != '\\t')) || (opp[i] > '~')) {\\r\\nprintable = 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (printable)\\r\\n{\\r\\nif (BIO_write(bp, \":\", 1) <= 0)\\r\\ngoto end;\\r\\nif (BIO_write(bp, (const char *)opp, os->length) <= 0)\\r\\ngoto end;\\r\\n} else if (!dump)\\r\\n{\\r\\nif (BIO_write(bp, \"[HEX DUMP]:\", 11) <= 0)\\r\\ngoto end;\\r\\nfor (i = 0; i < os->length; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", opp[i]) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\n{\\r\\nif (!nl) {\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_dump_indent(bp,\\r\\n(const char *)opp,\\r\\n((dump == -1 || dump >\\r\\nos->\\r\\nlength) ? os->length : dump),\\r\\ndump_indent) <= 0)\\r\\ngoto end;\\r\\nnl = 1;\\r\\n}\\r\\n}\\r\\nif (os != NULL) {\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\nos = NULL;\\r\\n}\\r\\n} else if (tag == V_ASN1_INTEGER) {\\r\\nASN1_INTEGER *bs;\\r\\nint i;\\r\\nopp = op;\\r\\nbs = d2i_ASN1_INTEGER(NULL, &opp, len + hl);\\r\\nif (bs != NULL) {\\r\\nif (BIO_write(bp, \":\", 1) <= 0)\\r\\ngoto end;\\r\\nif (bs->type == V_ASN1_NEG_INTEGER)\\r\\nif (BIO_write(bp, \"-\", 1) <= 0)\\r\\ngoto end;\\r\\nfor (i = 0; i < bs->length; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", bs->data[i]) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (bs->length == 0) {\\r\\nif (BIO_write(bp, \"00\", 2) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nif (BIO_write(bp, \"BAD INTEGER\", 11) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nM_ASN1_INTEGER_free(bs);\\r\\n} else if (tag == V_ASN1_ENUMERATED) {\\r\\nASN1_ENUMERATED *bs;\\r\\nint i;\\r\\nopp = op;\\r\\nbs = d2i_ASN1_ENUMERATED(NULL, &opp, len + hl);\\r\\nif (bs != NULL) {\\r\\nif (BIO_write(bp, \":\", 1) <= 0)\\r\\ngoto end;\\r\\nif (bs->type == V_ASN1_NEG_ENUMERATED)\\r\\nif (BIO_write(bp, \"-\", 1) <= 0)\\r\\ngoto end;\\r\\nfor (i = 0; i < bs->length; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", bs->data[i]) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (bs->length == 0) {\\r\\nif (BIO_write(bp, \"00\", 2) <= 0)\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nif (BIO_write(bp, \"BAD ENUMERATED\", 11) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nM_ASN1_ENUMERATED_free(bs);\\r\\n} else if (len > 0 && dump) {\\r\\nif (!nl) {\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto end;\\r\\n}\\r\\nif (BIO_dump_indent(bp, (const char *)p,\\r\\n((dump == -1 || dump > len) ? len : dump),\\r\\ndump_indent) <= 0)\\r\\ngoto end;\\r\\nnl = 1;\\r\\n}\\r\\nif (!nl) {\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto end;\\r\\n}\\r\\np += len;\\r\\nif ((tag == V_ASN1_EOC) && (xclass == 0)) {\\r\\nret = 2;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nlength -= len;\\r\\n}\\r\\nret = 1;\\r\\nend:\\r\\nif (o != NULL)\\r\\nASN1_OBJECT_free(o);\\r\\nif (os != NULL)\\r\\nM_ASN1_OCTET_STRING_free(os);\\r\\n*pp = p;\\r\\nreturn (ret);\\r\\n}\\r\\nconst char *ASN1_tag2str(int tag)\\r\\n{\\r\\nstatic const char *const tag2str[] = {\\r\\n\"EOC\", \"BOOLEAN\", \"INTEGER\", \"BIT STRING\", \"OCTET STRING\",\\r\\n\"NULL\", \"OBJECT\", \"OBJECT DESCRIPTOR\", \"EXTERNAL\", \"REAL\",\\r\\n\"ENUMERATED\", \"<ASN1 11>\", \"UTF8STRING\", \"<ASN1 13>\",\\r\\n\"<ASN1 14>\", \"<ASN1 15>\", \"SEQUENCE\", \"SET\",\\r\\n\"NUMERICSTRING\", \"PRINTABLESTRING\", \"T61STRING\",\\r\\n\"VIDEOTEXSTRING\", \"IA5STRING\", \"UTCTIME\", \"GENERALIZEDTIME\",\\r\\n\"GRAPHICSTRING\", \"VISIBLESTRING\", \"GENERALSTRING\",\\r\\n\"UNIVERSALSTRING\", \"<ASN1 29>\", \"BMPSTRING\"\\r\\n};\\r\\nif ((tag == V_ASN1_NEG_INTEGER) || (tag == V_ASN1_NEG_ENUMERATED))\\r\\ntag &= ~0x100;\\r\\nif (tag < 0 || tag > 30)\\r\\nreturn \"(unknown)\";\\r\\nreturn tag2str[tag];\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pkey_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nchar **args, *infile = NULL, *outfile = NULL;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nconst EVP_CIPHER *cipher = NULL;\\r\\nint informat, outformat;\\r\\nint pubin = 0, pubout = 0, pubtext = 0, text = 0, noout = 0;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\nint badarg = 0;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nint ret = 1;\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nERR_load_crypto_strings();\\r\\nOpenSSL_add_all_algorithms();\\r\\nargs = argv + 1;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp(*args, \"-inform\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninformat = str2fmt(*args);\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-outform\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutformat = str2fmt(*args);\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-passin\")) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\npassargin = *(++args);\\r\\n} else if (!strcmp(*args, \"-passout\")) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\npassargout = *(++args);\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*args, \"-engine\") == 0) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\nengine = *(++args);\\r\\n}\\r\\n#endif\\r\\nelse if (!strcmp(*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (strcmp(*args, \"-pubin\") == 0) {\\r\\npubin = 1;\\r\\npubout = 1;\\r\\npubtext = 1;\\r\\n} else if (strcmp(*args, \"-pubout\") == 0)\\r\\npubout = 1;\\r\\nelse if (strcmp(*args, \"-text_pub\") == 0) {\\r\\npubtext = 1;\\r\\ntext = 1;\\r\\n} else if (strcmp(*args, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*args, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse {\\r\\ncipher = EVP_get_cipherbyname(*args + 1);\\r\\nif (!cipher) {\\r\\nBIO_printf(bio_err, \"Unknown cipher %s\\n\", *args + 1);\\r\\nbadarg = 1;\\r\\n}\\r\\n}\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"Usage pkey [options]\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err, \"-inform X input format (DER or PEM)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-passin arg input file pass phrase source\\n\");\\r\\nBIO_printf(bio_err, \"-outform X output format (DER or PEM)\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-passout arg output file pass phrase source\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file(outfile, \"wb\"))) {\\r\\nBIO_printf(bio_err, \"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (pubin)\\r\\npkey = load_pubkey(bio_err, infile, informat, 1,\\r\\npassin, e, \"Public Key\");\\r\\nelse\\r\\npkey = load_key(bio_err, infile, informat, 1, passin, e, \"key\");\\r\\nif (!pkey)\\r\\ngoto end;\\r\\nif (!noout) {\\r\\nif (outformat == FORMAT_PEM) {\\r\\nif (pubout)\\r\\nPEM_write_bio_PUBKEY(out, pkey);\\r\\nelse\\r\\nPEM_write_bio_PrivateKey(out, pkey, cipher,\\r\\nNULL, 0, NULL, passout);\\r\\n} else if (outformat == FORMAT_ASN1) {\\r\\nif (pubout)\\r\\ni2d_PUBKEY_bio(out, pkey);\\r\\nelse\\r\\ni2d_PrivateKey_bio(out, pkey);\\r\\n} else {\\r\\nBIO_printf(bio_err, \"Bad format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (text) {\\r\\nif (pubtext)\\r\\nEVP_PKEY_print_public(out, pkey, 0, NULL);\\r\\nelse\\r\\nEVP_PKEY_print_private(out, pkey, 0, NULL);\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nBIO_free(in);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_d2i_pu_c", "target": 0, "func": "EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nEVP_PKEY *ret;\\r\\nif ((a == NULL) || (*a == NULL)) {\\r\\nif ((ret = EVP_PKEY_new()) == NULL) {\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_EVP_LIB);\\r\\nreturn (NULL);\\r\\n}\\r\\n} else\\r\\nret = *a;\\r\\nif (!EVP_PKEY_set_type(ret, type)) {\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nswitch (EVP_PKEY_id(ret)) {\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nif ((ret->pkey.rsa = d2i_RSAPublicKey(NULL,\\r\\n(const unsigned char **)pp,\\r\\nlength)) == NULL) {\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nif (!d2i_DSAPublicKey(&(ret->pkey.dsa),\\r\\n(const unsigned char **)pp, length)) {\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase EVP_PKEY_EC:\\r\\nif (!o2i_ECPublicKey(&(ret->pkey.ec),\\r\\n(const unsigned char **)pp, length)) {\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY, ERR_R_ASN1_LIB);\\r\\ngoto err;\\r\\n}\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nASN1err(ASN1_F_D2I_PUBLICKEY, ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (a != NULL)\\r\\n(*a) = ret;\\r\\nreturn (ret);\\r\\nerr:\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nEVP_PKEY_free(ret);\\r\\nreturn (NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_null_c", "target": 0, "func": "const RSA_METHOD *RSA_null_method(void)\\r\\n{\\r\\nreturn (&rsa_null_meth);\\r\\n}\\r\\nstatic int RSA_null_public_encrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NULL_PUBLIC_ENCRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int RSA_null_private_encrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NULL_PRIVATE_ENCRYPT,\\r\\nRSA_R_RSA_OPERATIONS_NOT_SUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int RSA_null_private_decrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NULL_PRIVATE_DECRYPT,\\r\\nRSA_R_RSA_OPERATIONS_NOT_SUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int RSA_null_public_decrypt(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nRSAerr(RSA_F_RSA_NULL_PUBLIC_DECRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int RSA_null_init(RSA *rsa)\\r\\n{\\r\\nreturn (1);\\r\\n}\\r\\nstatic int RSA_null_finish(RSA *rsa)\\r\\n{\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_enc_c", "target": 0, "func": "BIO_METHOD *BIO_f_cipher(void)\\r\\n{\\r\\nreturn (&methods_enc);\\r\\n}\\r\\nstatic int enc_new(BIO *bi)\\r\\n{\\r\\nBIO_ENC_CTX *ctx;\\r\\nctx = (BIO_ENC_CTX *)OPENSSL_malloc(sizeof(BIO_ENC_CTX));\\r\\nif (ctx == NULL)\\r\\nreturn (0);\\r\\nEVP_CIPHER_CTX_init(&ctx->cipher);\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\nctx->cont = 1;\\r\\nctx->finished = 0;\\r\\nctx->ok = 1;\\r\\nbi->init = 0;\\r\\nbi->ptr = (char *)ctx;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int enc_free(BIO *a)\\r\\n{\\r\\nBIO_ENC_CTX *b;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nb = (BIO_ENC_CTX *)a->ptr;\\r\\nEVP_CIPHER_CTX_cleanup(&(b->cipher));\\r\\nOPENSSL_cleanse(a->ptr, sizeof(BIO_ENC_CTX));\\r\\nOPENSSL_free(a->ptr);\\r\\na->ptr = NULL;\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int enc_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0, i;\\r\\nBIO_ENC_CTX *ctx;\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nctx = (BIO_ENC_CTX *)b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL))\\r\\nreturn (0);\\r\\nif (ctx->buf_len > 0) {\\r\\ni = ctx->buf_len - ctx->buf_off;\\r\\nif (i > outl)\\r\\ni = outl;\\r\\nmemcpy(out, &(ctx->buf[ctx->buf_off]), i);\\r\\nret = i;\\r\\nout += i;\\r\\noutl -= i;\\r\\nctx->buf_off += i;\\r\\nif (ctx->buf_len == ctx->buf_off) {\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\n}\\r\\n}\\r\\nwhile (outl > 0) {\\r\\nif (ctx->cont <= 0)\\r\\nbreak;\\r\\ni = BIO_read(b->next_bio, &(ctx->buf[BUF_OFFSET]), ENC_BLOCK_SIZE);\\r\\nif (i <= 0) {\\r\\nif (!BIO_should_retry(b->next_bio)) {\\r\\nctx->cont = i;\\r\\ni = EVP_CipherFinal_ex(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\nctx->ok = i;\\r\\nctx->buf_off = 0;\\r\\n} else {\\r\\nret = (ret == 0) ? i : ret;\\r\\nbreak;\\r\\n}\\r\\n} else {\\r\\nEVP_CipherUpdate(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf, &ctx->buf_len,\\r\\n(unsigned char *)&(ctx->buf[BUF_OFFSET]), i);\\r\\nctx->cont = 1;\\r\\nif (ctx->buf_len == 0)\\r\\ncontinue;\\r\\n}\\r\\nif (ctx->buf_len <= outl)\\r\\ni = ctx->buf_len;\\r\\nelse\\r\\ni = outl;\\r\\nif (i <= 0)\\r\\nbreak;\\r\\nmemcpy(out, ctx->buf, i);\\r\\nret += i;\\r\\nctx->buf_off = i;\\r\\noutl -= i;\\r\\nout += i;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn ((ret == 0) ? ctx->cont : ret);\\r\\n}\\r\\nstatic int enc_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret = 0, n, i;\\r\\nBIO_ENC_CTX *ctx;\\r\\nctx = (BIO_ENC_CTX *)b->ptr;\\r\\nret = inl;\\r\\nBIO_clear_retry_flags(b);\\r\\nn = ctx->buf_len - ctx->buf_off;\\r\\nwhile (n > 0) {\\r\\ni = BIO_write(b->next_bio, &(ctx->buf[ctx->buf_off]), n);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (i);\\r\\n}\\r\\nctx->buf_off += i;\\r\\nn -= i;\\r\\n}\\r\\nif ((in == NULL) || (inl <= 0))\\r\\nreturn (0);\\r\\nctx->buf_off = 0;\\r\\nwhile (inl > 0) {\\r\\nn = (inl > ENC_BLOCK_SIZE) ? ENC_BLOCK_SIZE : inl;\\r\\nEVP_CipherUpdate(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf, &ctx->buf_len,\\r\\n(unsigned char *)in, n);\\r\\ninl -= n;\\r\\nin += n;\\r\\nctx->buf_off = 0;\\r\\nn = ctx->buf_len;\\r\\nwhile (n > 0) {\\r\\ni = BIO_write(b->next_bio, &(ctx->buf[ctx->buf_off]), n);\\r\\nif (i <= 0) {\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret == inl) ? i : ret - inl;\\r\\n}\\r\\nn -= i;\\r\\nctx->buf_off += i;\\r\\n}\\r\\nctx->buf_len = 0;\\r\\nctx->buf_off = 0;\\r\\n}\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long enc_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nBIO *dbio;\\r\\nBIO_ENC_CTX *ctx, *dctx;\\r\\nlong ret = 1;\\r\\nint i;\\r\\nEVP_CIPHER_CTX **c_ctx;\\r\\nctx = (BIO_ENC_CTX *)b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nctx->ok = 1;\\r\\nctx->finished = 0;\\r\\nEVP_CipherInit_ex(&(ctx->cipher), NULL, NULL, NULL, NULL,\\r\\nctx->cipher.encrypt);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (ctx->cont <= 0)\\r\\nret = 1;\\r\\nelse\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = ctx->buf_len - ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nret = ctx->buf_len - ctx->buf_off;\\r\\nif (ret <= 0)\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nagain:\\r\\nwhile (ctx->buf_len != ctx->buf_off) {\\r\\ni = enc_write(b, NULL, 0);\\r\\nif (i < 0)\\r\\nreturn i;\\r\\n}\\r\\nif (!ctx->finished) {\\r\\nctx->finished = 1;\\r\\nctx->buf_off = 0;\\r\\nret = EVP_CipherFinal_ex(&(ctx->cipher),\\r\\n(unsigned char *)ctx->buf,\\r\\n&(ctx->buf_len));\\r\\nctx->ok = (int)ret;\\r\\nif (ret <= 0)\\r\\nbreak;\\r\\ngoto again;\\r\\n}\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_C_GET_CIPHER_STATUS:\\r\\nret = (long)ctx->ok;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_C_GET_CIPHER_CTX:\\r\\nc_ctx = (EVP_CIPHER_CTX **)ptr;\\r\\n(*c_ctx) = &(ctx->cipher);\\r\\nb->init = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio = (BIO *)ptr;\\r\\ndctx = (BIO_ENC_CTX *)dbio->ptr;\\r\\nEVP_CIPHER_CTX_init(&dctx->cipher);\\r\\nret = EVP_CIPHER_CTX_copy(&dctx->cipher, &ctx->cipher);\\r\\nif (ret)\\r\\ndbio->init = 1;\\r\\nbreak;\\r\\ndefault:\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long enc_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret = 1;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\nret = BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid BIO_set_cipher(BIO *b, const EVP_CIPHER *c, const unsigned char *k,\\r\\nconst unsigned char *i, int e)\\r\\n{\\r\\nBIO_ENC_CTX *ctx;\\r\\nif (b == NULL)\\r\\nreturn;\\r\\nif ((b->callback != NULL) &&\\r\\n(b->callback(b, BIO_CB_CTRL, (const char *)c, BIO_CTRL_SET, e, 0L) <=\\r\\n0))\\r\\nreturn;\\r\\nb->init = 1;\\r\\nctx = (BIO_ENC_CTX *)b->ptr;\\r\\nEVP_CipherInit_ex(&(ctx->cipher), c, NULL, k, i, e);\\r\\nif (b->callback != NULL)\\r\\nb->callback(b, BIO_CB_CTRL, (const char *)c, BIO_CTRL_SET, e, 1L);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_acpt_c", "target": 0, "func": "BIO_METHOD *BIO_s_accept(void)\\r\\n{\\r\\nreturn (&methods_acceptp);\\r\\n}\\r\\nstatic int acpt_new(BIO *bi)\\r\\n{\\r\\nBIO_ACCEPT *ba;\\r\\nbi->init = 0;\\r\\nbi->num = INVALID_SOCKET;\\r\\nbi->flags = 0;\\r\\nif ((ba = BIO_ACCEPT_new()) == NULL)\\r\\nreturn (0);\\r\\nbi->ptr = (char *)ba;\\r\\nba->state = ACPT_S_BEFORE;\\r\\nbi->shutdown = 1;\\r\\nreturn (1);\\r\\n}\\r\\nstatic BIO_ACCEPT *BIO_ACCEPT_new(void)\\r\\n{\\r\\nBIO_ACCEPT *ret;\\r\\nif ((ret = (BIO_ACCEPT *)OPENSSL_malloc(sizeof(BIO_ACCEPT))) == NULL)\\r\\nreturn (NULL);\\r\\nmemset(ret, 0, sizeof(BIO_ACCEPT));\\r\\nret->accept_sock = INVALID_SOCKET;\\r\\nret->bind_mode = BIO_BIND_NORMAL;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic void BIO_ACCEPT_free(BIO_ACCEPT *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn;\\r\\nif (a->param_addr != NULL)\\r\\nOPENSSL_free(a->param_addr);\\r\\nif (a->addr != NULL)\\r\\nOPENSSL_free(a->addr);\\r\\nif (a->bio_chain != NULL)\\r\\nBIO_free(a->bio_chain);\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nstatic void acpt_close_socket(BIO *bio)\\r\\n{\\r\\nBIO_ACCEPT *c;\\r\\nc = (BIO_ACCEPT *)bio->ptr;\\r\\nif (c->accept_sock != INVALID_SOCKET) {\\r\\nshutdown(c->accept_sock, 2);\\r\\nclosesocket(c->accept_sock);\\r\\nc->accept_sock = INVALID_SOCKET;\\r\\nbio->num = INVALID_SOCKET;\\r\\n}\\r\\n}\\r\\nstatic int acpt_free(BIO *a)\\r\\n{\\r\\nBIO_ACCEPT *data;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\ndata = (BIO_ACCEPT *)a->ptr;\\r\\nif (a->shutdown) {\\r\\nacpt_close_socket(a);\\r\\nBIO_ACCEPT_free(data);\\r\\na->ptr = NULL;\\r\\na->flags = 0;\\r\\na->init = 0;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int acpt_state(BIO *b, BIO_ACCEPT *c)\\r\\n{\\r\\nBIO *bio = NULL, *dbio;\\r\\nint s = -1;\\r\\nint i;\\r\\nagain:\\r\\nswitch (c->state) {\\r\\ncase ACPT_S_BEFORE:\\r\\nif (c->param_addr == NULL) {\\r\\nBIOerr(BIO_F_ACPT_STATE, BIO_R_NO_ACCEPT_PORT_SPECIFIED);\\r\\nreturn (-1);\\r\\n}\\r\\ns = BIO_get_accept_socket(c->param_addr, c->bind_mode);\\r\\nif (s == INVALID_SOCKET)\\r\\nreturn (-1);\\r\\nif (c->accept_nbio) {\\r\\nif (!BIO_socket_nbio(s, 1)) {\\r\\nclosesocket(s);\\r\\nBIOerr(BIO_F_ACPT_STATE,\\r\\nBIO_R_ERROR_SETTING_NBIO_ON_ACCEPT_SOCKET);\\r\\nreturn (-1);\\r\\n}\\r\\n}\\r\\nc->accept_sock = s;\\r\\nb->num = s;\\r\\nc->state = ACPT_S_GET_ACCEPT_SOCKET;\\r\\nreturn (1);\\r\\ncase ACPT_S_GET_ACCEPT_SOCKET:\\r\\nif (b->next_bio != NULL) {\\r\\nc->state = ACPT_S_OK;\\r\\ngoto again;\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nb->retry_reason = 0;\\r\\ni = BIO_accept(c->accept_sock, &(c->addr));\\r\\nif (i == -2) {\\r\\nBIO_set_retry_special(b);\\r\\nb->retry_reason = BIO_RR_ACCEPT;\\r\\nreturn -1;\\r\\n}\\r\\nif (i < 0)\\r\\nreturn (i);\\r\\nbio = BIO_new_socket(i, BIO_CLOSE);\\r\\nif (bio == NULL)\\r\\ngoto err;\\r\\nBIO_set_callback(bio, BIO_get_callback(b));\\r\\nBIO_set_callback_arg(bio, BIO_get_callback_arg(b));\\r\\nif (c->nbio) {\\r\\nif (!BIO_socket_nbio(i, 1)) {\\r\\nBIOerr(BIO_F_ACPT_STATE,\\r\\nBIO_R_ERROR_SETTING_NBIO_ON_ACCEPTED_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (c->bio_chain != NULL) {\\r\\nif ((dbio = BIO_dup_chain(c->bio_chain)) == NULL)\\r\\ngoto err;\\r\\nif (!BIO_push(dbio, bio))\\r\\ngoto err;\\r\\nbio = dbio;\\r\\n}\\r\\nif (BIO_push(b, bio) == NULL)\\r\\ngoto err;\\r\\nc->state = ACPT_S_OK;\\r\\nreturn (1);\\r\\nerr:\\r\\nif (bio != NULL)\\r\\nBIO_free(bio);\\r\\nelse if (s >= 0)\\r\\nclosesocket(s);\\r\\nreturn (0);\\r\\ncase ACPT_S_OK:\\r\\nif (b->next_bio == NULL) {\\r\\nc->state = ACPT_S_GET_ACCEPT_SOCKET;\\r\\ngoto again;\\r\\n}\\r\\nreturn (1);\\r\\ndefault:\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nstatic int acpt_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nBIO_ACCEPT *data;\\r\\nBIO_clear_retry_flags(b);\\r\\ndata = (BIO_ACCEPT *)b->ptr;\\r\\nwhile (b->next_bio == NULL) {\\r\\nret = acpt_state(b, data);\\r\\nif (ret <= 0)\\r\\nreturn (ret);\\r\\n}\\r\\nret = BIO_read(b->next_bio, out, outl);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int acpt_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret;\\r\\nBIO_ACCEPT *data;\\r\\nBIO_clear_retry_flags(b);\\r\\ndata = (BIO_ACCEPT *)b->ptr;\\r\\nwhile (b->next_bio == NULL) {\\r\\nret = acpt_state(b, data);\\r\\nif (ret <= 0)\\r\\nreturn (ret);\\r\\n}\\r\\nret = BIO_write(b->next_bio, in, inl);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long acpt_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nint *ip;\\r\\nlong ret = 1;\\r\\nBIO_ACCEPT *data;\\r\\nchar **pp;\\r\\ndata = (BIO_ACCEPT *)b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nret = 0;\\r\\ndata->state = ACPT_S_BEFORE;\\r\\nacpt_close_socket(b);\\r\\nb->flags = 0;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nret = (long)acpt_state(b, data);\\r\\nbreak;\\r\\ncase BIO_C_SET_ACCEPT:\\r\\nif (ptr != NULL) {\\r\\nif (num == 0) {\\r\\nb->init = 1;\\r\\nif (data->param_addr != NULL)\\r\\nOPENSSL_free(data->param_addr);\\r\\ndata->param_addr = BUF_strdup(ptr);\\r\\n} else if (num == 1) {\\r\\ndata->accept_nbio = (ptr != NULL);\\r\\n} else if (num == 2) {\\r\\nif (data->bio_chain != NULL)\\r\\nBIO_free(data->bio_chain);\\r\\ndata->bio_chain = (BIO *)ptr;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_NBIO:\\r\\ndata->nbio = (int)num;\\r\\nbreak;\\r\\ncase BIO_C_SET_FD:\\r\\nb->init = 1;\\r\\nb->num = *((int *)ptr);\\r\\ndata->accept_sock = b->num;\\r\\ndata->state = ACPT_S_GET_ACCEPT_SOCKET;\\r\\nb->shutdown = (int)num;\\r\\nb->init = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_FD:\\r\\nif (b->init) {\\r\\nip = (int *)ptr;\\r\\nif (ip != NULL)\\r\\n*ip = data->accept_sock;\\r\\nret = data->accept_sock;\\r\\n} else\\r\\nret = -1;\\r\\nbreak;\\r\\ncase BIO_C_GET_ACCEPT:\\r\\nif (b->init) {\\r\\nif (ptr != NULL) {\\r\\npp = (char **)ptr;\\r\\n*pp = data->param_addr;\\r\\n} else\\r\\nret = -1;\\r\\n} else\\r\\nret = -1;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown = (int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_WPENDING:\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nbreak;\\r\\ncase BIO_C_SET_BIND_MODE:\\r\\ndata->bind_mode = (int)num;\\r\\nbreak;\\r\\ncase BIO_C_GET_BIND_MODE:\\r\\nret = (long)data->bind_mode;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nbreak;\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int acpt_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = acpt_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}\\r\\nBIO *BIO_new_accept(const char *str)\\r\\n{\\r\\nBIO *ret;\\r\\nret = BIO_new(BIO_s_accept());\\r\\nif (ret == NULL)\\r\\nreturn (NULL);\\r\\nif (BIO_set_accept_port(ret, str))\\r\\nreturn (ret);\\r\\nelse {\\r\\nBIO_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_pk1_c", "target": 0, "func": "int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nint j;\\r\\nunsigned char *p;\\r\\nif (flen > (tlen - RSA_PKCS1_PADDING_SIZE)) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1,\\r\\nRSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn (0);\\r\\n}\\r\\np = (unsigned char *)to;\\r\\n*(p++) = 0;\\r\\n*(p++) = 1;\\r\\nj = tlen - 3 - flen;\\r\\nmemset(p, 0xff, j);\\r\\np += j;\\r\\n*(p++) = '\\0';\\r\\nmemcpy(p, from, (unsigned int)flen);\\r\\nreturn (1);\\r\\n}\\r\\nint RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen,\\r\\nint num)\\r\\n{\\r\\nint i, j;\\r\\nconst unsigned char *p;\\r\\np = from;\\r\\nif ((num != (flen + 1)) || (*(p++) != 01)) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,\\r\\nRSA_R_BLOCK_TYPE_IS_NOT_01);\\r\\nreturn (-1);\\r\\n}\\r\\nj = flen - 1;\\r\\nfor (i = 0; i < j; i++) {\\r\\nif (*p != 0xff) {\\r\\nif (*p == 0) {\\r\\np++;\\r\\nbreak;\\r\\n} else {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,\\r\\nRSA_R_BAD_FIXED_HEADER_DECRYPT);\\r\\nreturn (-1);\\r\\n}\\r\\n}\\r\\np++;\\r\\n}\\r\\nif (i == j) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,\\r\\nRSA_R_NULL_BEFORE_BLOCK_MISSING);\\r\\nreturn (-1);\\r\\n}\\r\\nif (i < 8) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1,\\r\\nRSA_R_BAD_PAD_BYTE_COUNT);\\r\\nreturn (-1);\\r\\n}\\r\\ni++;\\r\\nj -= i;\\r\\nif (j > tlen) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1, RSA_R_DATA_TOO_LARGE);\\r\\nreturn (-1);\\r\\n}\\r\\nmemcpy(to, p, (unsigned int)j);\\r\\nreturn (j);\\r\\n}\\r\\nint RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen)\\r\\n{\\r\\nint i, j;\\r\\nunsigned char *p;\\r\\nif (flen > (tlen - 11)) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2,\\r\\nRSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn (0);\\r\\n}\\r\\np = (unsigned char *)to;\\r\\n*(p++) = 0;\\r\\n*(p++) = 2;\\r\\nj = tlen - 3 - flen;\\r\\nif (RAND_bytes(p, j) <= 0)\\r\\nreturn (0);\\r\\nfor (i = 0; i < j; i++) {\\r\\nif (*p == '\\0')\\r\\ndo {\\r\\nif (RAND_bytes(p, 1) <= 0)\\r\\nreturn (0);\\r\\n} while (*p == '\\0');\\r\\np++;\\r\\n}\\r\\n*(p++) = '\\0';\\r\\nmemcpy(p, from, (unsigned int)flen);\\r\\nreturn (1);\\r\\n}\\r\\nint RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen,\\r\\nint num)\\r\\n{\\r\\nint i;\\r\\nunsigned char *em = NULL;\\r\\nunsigned int good, found_zero_byte;\\r\\nint zero_index = 0, msg_index, mlen = -1;\\r\\nif (tlen < 0 || flen < 0)\\r\\nreturn -1;\\r\\nif (flen > num)\\r\\ngoto err;\\r\\nif (num < 11)\\r\\ngoto err;\\r\\nem = OPENSSL_malloc(num);\\r\\nif (em == NULL) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nmemset(em, 0, num);\\r\\nmemcpy(em + num - flen, from, flen);\\r\\ngood = constant_time_is_zero(em[0]);\\r\\ngood &= constant_time_eq(em[1], 2);\\r\\nfound_zero_byte = 0;\\r\\nfor (i = 2; i < num; i++) {\\r\\nunsigned int equals0 = constant_time_is_zero(em[i]);\\r\\nzero_index =\\r\\nconstant_time_select_int(~found_zero_byte & equals0, i,\\r\\nzero_index);\\r\\nfound_zero_byte |= equals0;\\r\\n}\\r\\ngood &= constant_time_ge((unsigned int)(zero_index), 2 + 8);\\r\\nmsg_index = zero_index + 1;\\r\\nmlen = num - msg_index;\\r\\ngood &= constant_time_ge((unsigned int)(tlen), (unsigned int)(mlen));\\r\\nif (!good) {\\r\\nmlen = -1;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(to, em + msg_index, mlen);\\r\\nerr:\\r\\nif (em != NULL)\\r\\nOPENSSL_free(em);\\r\\nif (mlen == -1)\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2,\\r\\nRSA_R_PKCS_DECODING_ERROR);\\r\\nreturn mlen;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t_x509_c", "target": 0, "func": "int X509_print_fp(FILE *fp, X509 *x)\\r\\n{\\r\\nreturn X509_print_ex_fp(fp, x, XN_FLAG_COMPAT, X509_FLAG_COMPAT);\\r\\n}\\r\\nint X509_print_ex_fp(FILE *fp, X509 *x, unsigned long nmflag,\\r\\nunsigned long cflag)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nX509err(X509_F_X509_PRINT_EX_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = X509_print_ex(b, x, nmflag, cflag);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint X509_print(BIO *bp, X509 *x)\\r\\n{\\r\\nreturn X509_print_ex(bp, x, XN_FLAG_COMPAT, X509_FLAG_COMPAT);\\r\\n}\\r\\nint X509_print_ex(BIO *bp, X509 *x, unsigned long nmflags,\\r\\nunsigned long cflag)\\r\\n{\\r\\nlong l;\\r\\nint ret = 0, i;\\r\\nchar *m = NULL, mlch = ' ';\\r\\nint nmindent = 0;\\r\\nX509_CINF *ci;\\r\\nASN1_INTEGER *bs;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nconst char *neg;\\r\\nif ((nmflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {\\r\\nmlch = '\\n';\\r\\nnmindent = 12;\\r\\n}\\r\\nif (nmflags == X509_FLAG_COMPAT)\\r\\nnmindent = 16;\\r\\nci = x->cert_info;\\r\\nif (!(cflag & X509_FLAG_NO_HEADER)) {\\r\\nif (BIO_write(bp, \"Certificate:\\n\", 13) <= 0)\\r\\ngoto err;\\r\\nif (BIO_write(bp, \" Data:\\n\", 10) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_VERSION)) {\\r\\nl = X509_get_version(x);\\r\\nif (BIO_printf(bp, \"%8sVersion: %lu (0x%lx)\\n\", \"\", l + 1, l) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_SERIAL)) {\\r\\nif (BIO_write(bp, \" Serial Number:\", 22) <= 0)\\r\\ngoto err;\\r\\nbs = X509_get_serialNumber(x);\\r\\nif (bs->length <= (int)sizeof(long)) {\\r\\nl = ASN1_INTEGER_get(bs);\\r\\nif (bs->type == V_ASN1_NEG_INTEGER) {\\r\\nl = -l;\\r\\nneg = \"-\";\\r\\n} else\\r\\nneg = \"\";\\r\\nif (BIO_printf(bp, \" %s%lu (%s0x%lx)\\n\", neg, l, neg, l) <= 0)\\r\\ngoto err;\\r\\n} else {\\r\\nneg = (bs->type == V_ASN1_NEG_INTEGER) ? \" (Negative)\" : \"\";\\r\\nif (BIO_printf(bp, \"\\n%12s%s\", \"\", neg) <= 0)\\r\\ngoto err;\\r\\nfor (i = 0; i < bs->length; i++) {\\r\\nif (BIO_printf(bp, \"%02x%c\", bs->data[i],\\r\\n((i + 1 == bs->length) ? '\\n' : ':')) <= 0)\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_SIGNAME)) {\\r\\nif (X509_signature_print(bp, ci->signature, NULL) <= 0)\\r\\ngoto err;\\r\\n#if 0\\r\\nif (BIO_printf(bp, \"%8sSignature Algorithm: \", \"\") <= 0)\\r\\ngoto err;\\r\\nif (i2a_ASN1_OBJECT(bp, ci->signature->algorithm) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\n#endif\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_ISSUER)) {\\r\\nif (BIO_printf(bp, \" Issuer:%c\", mlch) <= 0)\\r\\ngoto err;\\r\\nif (X509_NAME_print_ex(bp, X509_get_issuer_name(x), nmindent, nmflags)\\r\\n< 0)\\r\\ngoto err;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_VALIDITY)) {\\r\\nif (BIO_write(bp, \" Validity\\n\", 17) <= 0)\\r\\ngoto err;\\r\\nif (BIO_write(bp, \" Not Before: \", 24) <= 0)\\r\\ngoto err;\\r\\nif (!ASN1_TIME_print(bp, X509_get_notBefore(x)))\\r\\ngoto err;\\r\\nif (BIO_write(bp, \"\\n Not After : \", 25) <= 0)\\r\\ngoto err;\\r\\nif (!ASN1_TIME_print(bp, X509_get_notAfter(x)))\\r\\ngoto err;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_SUBJECT)) {\\r\\nif (BIO_printf(bp, \" Subject:%c\", mlch) <= 0)\\r\\ngoto err;\\r\\nif (X509_NAME_print_ex\\r\\n(bp, X509_get_subject_name(x), nmindent, nmflags) < 0)\\r\\ngoto err;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_PUBKEY)) {\\r\\nif (BIO_write(bp, \" Subject Public Key Info:\\n\", 33) <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"%12sPublic Key Algorithm: \", \"\") <= 0)\\r\\ngoto err;\\r\\nif (i2a_ASN1_OBJECT(bp, ci->key->algor->algorithm) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\npkey = X509_get_pubkey(x);\\r\\nif (pkey == NULL) {\\r\\nBIO_printf(bp, \"%12sUnable to load Public Key\\n\", \"\");\\r\\nERR_print_errors(bp);\\r\\n} else {\\r\\nEVP_PKEY_print_public(bp, pkey, 16, NULL);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_IDS)) {\\r\\nif (ci->issuerUID) {\\r\\nif (BIO_printf(bp, \"%8sIssuer Unique ID: \", \"\") <= 0)\\r\\ngoto err;\\r\\nif (!X509_signature_dump(bp, ci->issuerUID, 12))\\r\\ngoto err;\\r\\n}\\r\\nif (ci->subjectUID) {\\r\\nif (BIO_printf(bp, \"%8sSubject Unique ID: \", \"\") <= 0)\\r\\ngoto err;\\r\\nif (!X509_signature_dump(bp, ci->subjectUID, 12))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_EXTENSIONS))\\r\\nX509V3_extensions_print(bp, \"X509v3 extensions\",\\r\\nci->extensions, cflag, 8);\\r\\nif (!(cflag & X509_FLAG_NO_SIGDUMP)) {\\r\\nif (X509_signature_print(bp, x->sig_alg, x->signature) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_AUX)) {\\r\\nif (!X509_CERT_AUX_print(bp, x->aux, 0))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (m != NULL)\\r\\nOPENSSL_free(m);\\r\\nreturn (ret);\\r\\n}\\r\\nint X509_ocspid_print(BIO *bp, X509 *x)\\r\\n{\\r\\nunsigned char *der = NULL;\\r\\nunsigned char *dertmp;\\r\\nint derlen;\\r\\nint i;\\r\\nunsigned char SHA1md[SHA_DIGEST_LENGTH];\\r\\nif (BIO_printf(bp, \" Subject OCSP hash: \") <= 0)\\r\\ngoto err;\\r\\nderlen = i2d_X509_NAME(x->cert_info->subject, NULL);\\r\\nif ((der = dertmp = (unsigned char *)OPENSSL_malloc(derlen)) == NULL)\\r\\ngoto err;\\r\\ni2d_X509_NAME(x->cert_info->subject, &dertmp);\\r\\nif (!EVP_Digest(der, derlen, SHA1md, NULL, EVP_sha1(), NULL))\\r\\ngoto err;\\r\\nfor (i = 0; i < SHA_DIGEST_LENGTH; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", SHA1md[i]) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nOPENSSL_free(der);\\r\\nder = NULL;\\r\\nif (BIO_printf(bp, \"\\n Public key OCSP hash: \") <= 0)\\r\\ngoto err;\\r\\nif (!EVP_Digest(x->cert_info->key->public_key->data,\\r\\nx->cert_info->key->public_key->length,\\r\\nSHA1md, NULL, EVP_sha1(), NULL))\\r\\ngoto err;\\r\\nfor (i = 0; i < SHA_DIGEST_LENGTH; i++) {\\r\\nif (BIO_printf(bp, \"%02X\", SHA1md[i]) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nBIO_printf(bp, \"\\n\");\\r\\nreturn (1);\\r\\nerr:\\r\\nif (der != NULL)\\r\\nOPENSSL_free(der);\\r\\nreturn (0);\\r\\n}\\r\\nint X509_signature_dump(BIO *bp, const ASN1_STRING *sig, int indent)\\r\\n{\\r\\nconst unsigned char *s;\\r\\nint i, n;\\r\\nn = sig->length;\\r\\ns = sig->data;\\r\\nfor (i = 0; i < n; i++) {\\r\\nif ((i % 18) == 0) {\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\nreturn 0;\\r\\nif (BIO_indent(bp, indent, indent) <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_printf(bp, \"%02x%s\", s[i], ((i + 1) == n) ? \"\" : \":\") <= 0)\\r\\nreturn 0;\\r\\n}\\r\\nif (BIO_write(bp, \"\\n\", 1) != 1)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_signature_print(BIO *bp, X509_ALGOR *sigalg, ASN1_STRING *sig)\\r\\n{\\r\\nint sig_nid;\\r\\nif (BIO_puts(bp, \" Signature Algorithm: \") <= 0)\\r\\nreturn 0;\\r\\nif (i2a_ASN1_OBJECT(bp, sigalg->algorithm) <= 0)\\r\\nreturn 0;\\r\\nsig_nid = OBJ_obj2nid(sigalg->algorithm);\\r\\nif (sig_nid != NID_undef) {\\r\\nint pkey_nid, dig_nid;\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nif (OBJ_find_sigid_algs(sig_nid, &dig_nid, &pkey_nid)) {\\r\\nameth = EVP_PKEY_asn1_find(NULL, pkey_nid);\\r\\nif (ameth && ameth->sig_print)\\r\\nreturn ameth->sig_print(bp, sigalg, sig, 9, 0);\\r\\n}\\r\\n}\\r\\nif (sig)\\r\\nreturn X509_signature_dump(bp, sig, 9);\\r\\nelse if (BIO_puts(bp, \"\\n\") <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint ASN1_STRING_print(BIO *bp, const ASN1_STRING *v)\\r\\n{\\r\\nint i, n;\\r\\nchar buf[80];\\r\\nconst char *p;\\r\\nif (v == NULL)\\r\\nreturn (0);\\r\\nn = 0;\\r\\np = (const char *)v->data;\\r\\nfor (i = 0; i < v->length; i++) {\\r\\nif ((p[i] > '~') || ((p[i] < ' ') &&\\r\\n(p[i] != '\\n') && (p[i] != '\\r')))\\r\\nbuf[n] = '.';\\r\\nelse\\r\\nbuf[n] = p[i];\\r\\nn++;\\r\\nif (n >= 80) {\\r\\nif (BIO_write(bp, buf, n) <= 0)\\r\\nreturn (0);\\r\\nn = 0;\\r\\n}\\r\\n}\\r\\nif (n > 0)\\r\\nif (BIO_write(bp, buf, n) <= 0)\\r\\nreturn (0);\\r\\nreturn (1);\\r\\n}\\r\\nint ASN1_TIME_print(BIO *bp, const ASN1_TIME *tm)\\r\\n{\\r\\nif (tm->type == V_ASN1_UTCTIME)\\r\\nreturn ASN1_UTCTIME_print(bp, tm);\\r\\nif (tm->type == V_ASN1_GENERALIZEDTIME)\\r\\nreturn ASN1_GENERALIZEDTIME_print(bp, tm);\\r\\nBIO_write(bp, \"Bad time value\", 14);\\r\\nreturn (0);\\r\\n}\\r\\nint ASN1_GENERALIZEDTIME_print(BIO *bp, const ASN1_GENERALIZEDTIME *tm)\\r\\n{\\r\\nchar *v;\\r\\nint gmt = 0;\\r\\nint i;\\r\\nint y = 0, M = 0, d = 0, h = 0, m = 0, s = 0;\\r\\nchar *f = NULL;\\r\\nint f_len = 0;\\r\\ni = tm->length;\\r\\nv = (char *)tm->data;\\r\\nif (i < 12)\\r\\ngoto err;\\r\\nif (v[i - 1] == 'Z')\\r\\ngmt = 1;\\r\\nfor (i = 0; i < 12; i++)\\r\\nif ((v[i] > '9') || (v[i] < '0'))\\r\\ngoto err;\\r\\ny = (v[0] - '0') * 1000 + (v[1] - '0') * 100\\r\\n+ (v[2] - '0') * 10 + (v[3] - '0');\\r\\nM = (v[4] - '0') * 10 + (v[5] - '0');\\r\\nif ((M > 12) || (M < 1))\\r\\ngoto err;\\r\\nd = (v[6] - '0') * 10 + (v[7] - '0');\\r\\nh = (v[8] - '0') * 10 + (v[9] - '0');\\r\\nm = (v[10] - '0') * 10 + (v[11] - '0');\\r\\nif (tm->length >= 14 &&\\r\\n(v[12] >= '0') && (v[12] <= '9') &&\\r\\n(v[13] >= '0') && (v[13] <= '9')) {\\r\\ns = (v[12] - '0') * 10 + (v[13] - '0');\\r\\nif (tm->length >= 15 && v[14] == '.') {\\r\\nint l = tm->length;\\r\\nf = &v[14];\\r\\nf_len = 1;\\r\\nwhile (14 + f_len < l && f[f_len] >= '0' && f[f_len] <= '9')\\r\\n++f_len;\\r\\n}\\r\\n}\\r\\nif (BIO_printf(bp, \"%s %2d %02d:%02d:%02d%.*s %d%s\",\\r\\nmon[M - 1], d, h, m, s, f_len, f, y,\\r\\n(gmt) ? \" GMT\" : \"\") <= 0)\\r\\nreturn (0);\\r\\nelse\\r\\nreturn (1);\\r\\nerr:\\r\\nBIO_write(bp, \"Bad time value\", 14);\\r\\nreturn (0);\\r\\n}\\r\\nint ASN1_UTCTIME_print(BIO *bp, const ASN1_UTCTIME *tm)\\r\\n{\\r\\nconst char *v;\\r\\nint gmt = 0;\\r\\nint i;\\r\\nint y = 0, M = 0, d = 0, h = 0, m = 0, s = 0;\\r\\ni = tm->length;\\r\\nv = (const char *)tm->data;\\r\\nif (i < 10)\\r\\ngoto err;\\r\\nif (v[i - 1] == 'Z')\\r\\ngmt = 1;\\r\\nfor (i = 0; i < 10; i++)\\r\\nif ((v[i] > '9') || (v[i] < '0'))\\r\\ngoto err;\\r\\ny = (v[0] - '0') * 10 + (v[1] - '0');\\r\\nif (y < 50)\\r\\ny += 100;\\r\\nM = (v[2] - '0') * 10 + (v[3] - '0');\\r\\nif ((M > 12) || (M < 1))\\r\\ngoto err;\\r\\nd = (v[4] - '0') * 10 + (v[5] - '0');\\r\\nh = (v[6] - '0') * 10 + (v[7] - '0');\\r\\nm = (v[8] - '0') * 10 + (v[9] - '0');\\r\\nif (tm->length >= 12 &&\\r\\n(v[10] >= '0') && (v[10] <= '9') && (v[11] >= '0') && (v[11] <= '9'))\\r\\ns = (v[10] - '0') * 10 + (v[11] - '0');\\r\\nif (BIO_printf(bp, \"%s %2d %02d:%02d:%02d %d%s\",\\r\\nmon[M - 1], d, h, m, s, y + 1900,\\r\\n(gmt) ? \" GMT\" : \"\") <= 0)\\r\\nreturn (0);\\r\\nelse\\r\\nreturn (1);\\r\\nerr:\\r\\nBIO_write(bp, \"Bad time value\", 14);\\r\\nreturn (0);\\r\\n}\\r\\nint X509_NAME_print(BIO *bp, X509_NAME *name, int obase)\\r\\n{\\r\\nchar *s, *c, *b;\\r\\nint ret = 0, l, i;\\r\\nl = 80 - 2 - obase;\\r\\nb = X509_NAME_oneline(name, NULL, 0);\\r\\nif (!b)\\r\\nreturn 0;\\r\\nif (!*b) {\\r\\nOPENSSL_free(b);\\r\\nreturn 1;\\r\\n}\\r\\ns = b + 1;\\r\\nc = s;\\r\\nfor (;;) {\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif (((*s == '/') &&\\r\\n((s[1] >= 'A') && (s[1] <= 'Z') && ((s[2] == '=') ||\\r\\n((s[2] >= 'A')\\r\\n&& (s[2] <= 'Z')\\r\\n&& (s[3] == '='))\\r\\n))) || (*s == '\\0'))\\r\\n#else\\r\\nif (((*s == '/') &&\\r\\n(isupper(s[1]) && ((s[2] == '=') ||\\r\\n(isupper(s[2]) && (s[3] == '='))\\r\\n))) || (*s == '\\0'))\\r\\n#endif\\r\\n{\\r\\ni = s - c;\\r\\nif (BIO_write(bp, c, i) != i)\\r\\ngoto err;\\r\\nc = s + 1;\\r\\nif (*s != '\\0') {\\r\\nif (BIO_write(bp, \", \", 2) != 2)\\r\\ngoto err;\\r\\n}\\r\\nl--;\\r\\n}\\r\\nif (*s == '\\0')\\r\\nbreak;\\r\\ns++;\\r\\nl--;\\r\\n}\\r\\nret = 1;\\r\\nif (0) {\\r\\nerr:\\r\\nX509err(X509_F_X509_NAME_PRINT, ERR_R_BUF_LIB);\\r\\n}\\r\\nOPENSSL_free(b);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_padlock_c", "target": 0, "func": "void ENGINE_load_padlock(void)\\r\\n{\\r\\n# ifdef COMPILE_HW_PADLOCK\\r\\nENGINE *toadd = ENGINE_padlock();\\r\\nif (!toadd)\\r\\nreturn;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n# endif\\r\\n}\\r\\nstatic int padlock_bind_helper(ENGINE *e)\\r\\n{\\r\\npadlock_available();\\r\\n# if 1\\r\\npadlock_use_rng = 0;\\r\\n# endif\\r\\nBIO_snprintf(padlock_name, sizeof(padlock_name),\\r\\n\"VIA PadLock (%s, %s)\",\\r\\npadlock_use_rng ? \"RNG\" : \"no-RNG\",\\r\\npadlock_use_ace ? \"ACE\" : \"no-ACE\");\\r\\nif (!ENGINE_set_id(e, padlock_id) ||\\r\\n!ENGINE_set_name(e, padlock_name) ||\\r\\n!ENGINE_set_init_function(e, padlock_init) ||\\r\\n# ifndef OPENSSL_NO_AES\\r\\n(padlock_use_ace && !ENGINE_set_ciphers(e, padlock_ciphers)) ||\\r\\n# endif\\r\\n(padlock_use_rng && !ENGINE_set_RAND(e, &padlock_rand))) {\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *ENGINE_padlock(void)\\r\\n{\\r\\nENGINE *eng = ENGINE_new();\\r\\nif (!eng) {\\r\\nreturn NULL;\\r\\n}\\r\\nif (!padlock_bind_helper(eng)) {\\r\\nENGINE_free(eng);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn eng;\\r\\n}\\r\\nstatic int padlock_init(ENGINE *e)\\r\\n{\\r\\nreturn (padlock_use_rng || padlock_use_ace);\\r\\n}\\r\\nstatic int padlock_bind_fn(ENGINE *e, const char *id)\\r\\n{\\r\\nif (id && (strcmp(id, padlock_id) != 0)) {\\r\\nreturn 0;\\r\\n}\\r\\nif (!padlock_bind_helper(e)) {\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int padlock_insn_cpuid_available(void)\\r\\n{\\r\\nint result = -1;\\r\\nasm volatile (\"pushf\\n\"\\r\\n\"popl %%eax\\n\"\\r\\n\"xorl $0x200000, %%eax\\n\"\\r\\n\"movl %%eax, %%ecx\\n\"\\r\\n\"andl $0x200000, %%ecx\\n\"\\r\\n\"pushl %%eax\\n\"\\r\\n\"popf\\n\"\\r\\n\"pushf\\n\"\\r\\n\"popl %%eax\\n\"\\r\\n\"andl $0x200000, %%eax\\n\"\\r\\n\"xorl %%eax, %%ecx\\n\"\\r\\n\"movl %%ecx, %0\\n\":\"=r\" (result)::\"eax\", \"ecx\");\\r\\nreturn (result == 0);\\r\\n}\\r\\nstatic int padlock_available(void)\\r\\n{\\r\\nchar vendor_string[16];\\r\\nunsigned int eax, edx;\\r\\nif (!padlock_insn_cpuid_available())\\r\\nreturn 0;\\r\\neax = 0x00000000;\\r\\nvendor_string[12] = 0;\\r\\nasm volatile (\"pushl %%ebx\\n\"\\r\\n\"cpuid\\n\"\\r\\n\"movl %%ebx,(%%edi)\\n\"\\r\\n\"movl %%edx,4(%%edi)\\n\"\\r\\n\"movl %%ecx,8(%%edi)\\n\"\\r\\n\"popl %%ebx\":\"+a\" (eax):\"D\"(vendor_string):\"ecx\", \"edx\");\\r\\nif (strcmp(vendor_string, \"CentaurHauls\") != 0)\\r\\nreturn 0;\\r\\neax = 0xC0000000;\\r\\nasm volatile (\"pushl %%ebx; cpuid; popl %%ebx\":\"+a\" (eax)::\"ecx\", \"edx\");\\r\\nif (eax < 0xC0000001)\\r\\nreturn 0;\\r\\neax = 0xC0000001;\\r\\nasm volatile (\"pushl %%ebx; cpuid; popl %%ebx\":\"+a\" (eax),\\r\\n\"=d\"(edx)::\"ecx\");\\r\\npadlock_use_ace = ((edx & (0x3 << 6)) == (0x3 << 6));\\r\\npadlock_use_rng = ((edx & (0x3 << 2)) == (0x3 << 2));\\r\\nreturn padlock_use_ace + padlock_use_rng;\\r\\n}\\r\\nstatic inline void padlock_bswapl(AES_KEY *ks)\\r\\n{\\r\\nsize_t i = sizeof(ks->rd_key) / sizeof(ks->rd_key[0]);\\r\\nunsigned int *key = ks->rd_key;\\r\\nwhile (i--) {\\r\\nasm volatile (\"bswapl %0\":\"+r\" (*key));\\r\\nkey++;\\r\\n}\\r\\n}\\r\\nstatic inline void padlock_reload_key(void)\\r\\n{\\r\\nasm volatile (\"pushfl; popfl\");\\r\\n}\\r\\nstatic inline void padlock_verify_context(struct padlock_cipher_data *cdata)\\r\\n{\\r\\nasm volatile (\"pushfl\\n\"\\r\\n\" btl $30,(%%esp)\\n\"\\r\\n\" jnc 1f\\n\"\\r\\n\" cmpl %2,%1\\n\"\\r\\n\" je 1f\\n\"\\r\\n\" popfl\\n\"\\r\\n\" subl $4,%%esp\\n\"\\r\\n\"1: addl $4,%%esp\\n\"\\r\\n\" movl %2,%0\":\"+m\" (padlock_saved_context)\\r\\n:\"r\"(padlock_saved_context), \"r\"(cdata):\"cc\");\\r\\n}\\r\\nstatic inline unsigned int padlock_xstore(void *addr, unsigned int edx_in)\\r\\n{\\r\\nunsigned int eax_out;\\r\\nasm volatile (\".byte 0x0f,0xa7,0xc0\"\\r\\n:\"=a\" (eax_out), \"=m\"(*(unsigned *)addr)\\r\\n:\"D\"(addr), \"d\"(edx_in)\\r\\n);\\r\\nreturn eax_out;\\r\\n}\\r\\nstatic inline unsigned char *padlock_memcpy(void *dst, const void *src,\\r\\nsize_t n)\\r\\n{\\r\\nlong *d = dst;\\r\\nconst long *s = src;\\r\\nn /= sizeof(*d);\\r\\ndo {\\r\\n*d++ = *s++;\\r\\n} while (--n);\\r\\nreturn dst;\\r\\n}\\r\\nstatic int __fastcall padlock_xstore(void *outp, unsigned int code)\\r\\n{\\r\\n_asm mov edi,ecx\\r\\n_asm _emit 0x0f _asm _emit 0xa7 _asm _emit 0xc0\\r\\n}\\r\\nstatic void __fastcall padlock_reload_key(void)\\r\\n{\\r\\n_asm pushfd\\r\\n_asm popfd\\r\\n}\\r\\nstatic void __fastcall padlock_verify_context(void *cdata)\\r\\n{\\r\\n_asm {\\r\\npushfd\\r\\nbt DWORD PTR[esp],30\\r\\njnc skip\\r\\ncmp ecx,padlock_saved_context\\r\\nje skip\\r\\npopfd\\r\\nsub esp,4\\r\\nskip: add esp,4\\r\\nmov padlock_saved_context,ecx\\r\\n}\\r\\n}\\r\\nstatic int\\r\\npadlock_available(void)\\r\\n{\\r\\n_asm {\\r\\npushfd\\r\\npop eax\\r\\nmov ecx,eax\\r\\nxor eax,1<<21\\r\\npush eax\\r\\npopfd\\r\\npushfd\\r\\npop eax\\r\\nxor eax,ecx\\r\\nbt eax,21\\r\\njnc noluck\\r\\nmov eax,0\\r\\ncpuid\\r\\nxor eax,eax\\r\\ncmp ebx,'tneC'\\r\\njne noluck\\r\\ncmp edx,'Hrua'\\r\\njne noluck\\r\\ncmp ecx,'slua'\\r\\njne noluck\\r\\nmov eax,0xC0000000\\r\\ncpuid\\r\\nmov edx,eax\\r\\nxor eax,eax\\r\\ncmp edx,0xC0000001\\r\\njb noluck\\r\\nmov eax,0xC0000001\\r\\ncpuid\\r\\nxor eax,eax\\r\\nbt edx,6\\r\\njnc skip_a\\r\\nbt edx,7\\r\\njnc skip_a\\r\\nmov padlock_use_ace,1\\r\\ninc eax\\r\\nskip_a: bt edx,2\\r\\njnc skip_r\\r\\nbt edx,3\\r\\njnc skip_r\\r\\nmov padlock_use_rng,1\\r\\ninc eax\\r\\nskip_r:\\r\\nnoluck:\\r\\n}\\r\\n}\\r\\nstatic void __fastcall padlock_bswapl(void *key)\\r\\n{\\r\\n_asm {\\r\\npushfd\\r\\ncld\\r\\nmov esi,ecx\\r\\nmov edi,ecx\\r\\nmov ecx,60\\r\\nup: lodsd\\r\\nbswap eax\\r\\nstosd\\r\\nloop up\\r\\npopfd\\r\\n}\\r\\n}\\r\\nstatic int\\r\\npadlock_ciphers(ENGINE *e, const EVP_CIPHER **cipher, const int **nids,\\r\\nint nid)\\r\\n{\\r\\nif (!cipher) {\\r\\n*nids = padlock_cipher_nids;\\r\\nreturn padlock_cipher_nids_num;\\r\\n}\\r\\nswitch (nid) {\\r\\ncase NID_aes_128_ecb:\\r\\n*cipher = &padlock_aes_128_ecb;\\r\\nbreak;\\r\\ncase NID_aes_128_cbc:\\r\\n*cipher = &padlock_aes_128_cbc;\\r\\nbreak;\\r\\ncase NID_aes_128_cfb:\\r\\n*cipher = &padlock_aes_128_cfb;\\r\\nbreak;\\r\\ncase NID_aes_128_ofb:\\r\\n*cipher = &padlock_aes_128_ofb;\\r\\nbreak;\\r\\ncase NID_aes_192_ecb:\\r\\n*cipher = &padlock_aes_192_ecb;\\r\\nbreak;\\r\\ncase NID_aes_192_cbc:\\r\\n*cipher = &padlock_aes_192_cbc;\\r\\nbreak;\\r\\ncase NID_aes_192_cfb:\\r\\n*cipher = &padlock_aes_192_cfb;\\r\\nbreak;\\r\\ncase NID_aes_192_ofb:\\r\\n*cipher = &padlock_aes_192_ofb;\\r\\nbreak;\\r\\ncase NID_aes_256_ecb:\\r\\n*cipher = &padlock_aes_256_ecb;\\r\\nbreak;\\r\\ncase NID_aes_256_cbc:\\r\\n*cipher = &padlock_aes_256_cbc;\\r\\nbreak;\\r\\ncase NID_aes_256_cfb:\\r\\n*cipher = &padlock_aes_256_cfb;\\r\\nbreak;\\r\\ncase NID_aes_256_ofb:\\r\\n*cipher = &padlock_aes_256_ofb;\\r\\nbreak;\\r\\ndefault:\\r\\n*cipher = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int\\r\\npadlock_aes_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nstruct padlock_cipher_data *cdata;\\r\\nint key_len = EVP_CIPHER_CTX_key_length(ctx) * 8;\\r\\nif (key == NULL)\\r\\nreturn 0;\\r\\ncdata = ALIGNED_CIPHER_DATA(ctx);\\r\\nmemset(cdata, 0, sizeof(struct padlock_cipher_data));\\r\\nif (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_OFB_MODE)\\r\\ncdata->cword.b.encdec = 0;\\r\\nelse\\r\\ncdata->cword.b.encdec = (ctx->encrypt == 0);\\r\\ncdata->cword.b.rounds = 10 + (key_len - 128) / 32;\\r\\ncdata->cword.b.ksize = (key_len - 128) / 64;\\r\\nswitch (key_len) {\\r\\ncase 128:\\r\\nmemcpy(cdata->ks.rd_key, key, AES_KEY_SIZE_128);\\r\\ncdata->cword.b.keygen = 0;\\r\\nbreak;\\r\\ncase 192:\\r\\ncase 256:\\r\\nif (EVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_CFB_MODE ||\\r\\nEVP_CIPHER_CTX_mode(ctx) == EVP_CIPH_OFB_MODE || enc)\\r\\nAES_set_encrypt_key(key, key_len, &cdata->ks);\\r\\nelse\\r\\nAES_set_decrypt_key(key, key_len, &cdata->ks);\\r\\n# ifndef AES_ASM\\r\\npadlock_bswapl(&cdata->ks);\\r\\n# endif\\r\\ncdata->cword.b.keygen = 1;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\npadlock_reload_key();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int\\r\\npadlock_aes_cipher_omnivorous(EVP_CIPHER_CTX *ctx, unsigned char *out_arg,\\r\\nconst unsigned char *in_arg, size_t nbytes)\\r\\n{\\r\\nstruct padlock_cipher_data *cdata;\\r\\nvoid *iv;\\r\\ncdata = ALIGNED_CIPHER_DATA(ctx);\\r\\npadlock_verify_context(cdata);\\r\\nswitch (EVP_CIPHER_CTX_mode(ctx)) {\\r\\ncase EVP_CIPH_ECB_MODE:\\r\\npadlock_xcrypt_ecb(nbytes / AES_BLOCK_SIZE, cdata, out_arg, in_arg);\\r\\nbreak;\\r\\ncase EVP_CIPH_CBC_MODE:\\r\\nmemcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);\\r\\niv = padlock_xcrypt_cbc(nbytes / AES_BLOCK_SIZE, cdata, out_arg,\\r\\nin_arg);\\r\\nmemcpy(ctx->iv, iv, AES_BLOCK_SIZE);\\r\\nbreak;\\r\\ncase EVP_CIPH_CFB_MODE:\\r\\nmemcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);\\r\\niv = padlock_xcrypt_cfb(nbytes / AES_BLOCK_SIZE, cdata, out_arg,\\r\\nin_arg);\\r\\nmemcpy(ctx->iv, iv, AES_BLOCK_SIZE);\\r\\nbreak;\\r\\ncase EVP_CIPH_OFB_MODE:\\r\\nmemcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);\\r\\npadlock_xcrypt_ofb(nbytes / AES_BLOCK_SIZE, cdata, out_arg, in_arg);\\r\\nmemcpy(ctx->iv, cdata->iv, AES_BLOCK_SIZE);\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nmemset(cdata->iv, 0, AES_BLOCK_SIZE);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int\\r\\npadlock_aes_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out_arg,\\r\\nconst unsigned char *in_arg, size_t nbytes)\\r\\n{\\r\\nstruct padlock_cipher_data *cdata;\\r\\nconst void *inp;\\r\\nunsigned char *out;\\r\\nvoid *iv;\\r\\nint inp_misaligned, out_misaligned, realign_in_loop;\\r\\nsize_t chunk, allocated = 0;\\r\\nif ((chunk = ctx->num)) {\\r\\nunsigned char *ivp = ctx->iv;\\r\\nswitch (EVP_CIPHER_CTX_mode(ctx)) {\\r\\ncase EVP_CIPH_CFB_MODE:\\r\\nif (chunk >= AES_BLOCK_SIZE)\\r\\nreturn 0;\\r\\nif (ctx->encrypt)\\r\\nwhile (chunk < AES_BLOCK_SIZE && nbytes != 0) {\\r\\nivp[chunk] = *(out_arg++) = *(in_arg++) ^ ivp[chunk];\\r\\nchunk++, nbytes--;\\r\\n} else\\r\\nwhile (chunk < AES_BLOCK_SIZE && nbytes != 0) {\\r\\nunsigned char c = *(in_arg++);\\r\\n*(out_arg++) = c ^ ivp[chunk];\\r\\nivp[chunk++] = c, nbytes--;\\r\\n}\\r\\nctx->num = chunk % AES_BLOCK_SIZE;\\r\\nbreak;\\r\\ncase EVP_CIPH_OFB_MODE:\\r\\nif (chunk >= AES_BLOCK_SIZE)\\r\\nreturn 0;\\r\\nwhile (chunk < AES_BLOCK_SIZE && nbytes != 0) {\\r\\n*(out_arg++) = *(in_arg++) ^ ivp[chunk];\\r\\nchunk++, nbytes--;\\r\\n}\\r\\nctx->num = chunk % AES_BLOCK_SIZE;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (nbytes == 0)\\r\\nreturn 1;\\r\\n# if 0\\r\\nif (nbytes % AES_BLOCK_SIZE)\\r\\nreturn 0;\\r\\n# else\\r\\n# endif\\r\\nif (!padlock_aes_align_required && (nbytes % AES_BLOCK_SIZE) == 0)\\r\\nreturn padlock_aes_cipher_omnivorous(ctx, out_arg, in_arg, nbytes);\\r\\ninp_misaligned = (((size_t)in_arg) & 0x0F);\\r\\nout_misaligned = (((size_t)out_arg) & 0x0F);\\r\\nrealign_in_loop = out_misaligned | inp_misaligned;\\r\\nif (!realign_in_loop && (nbytes % AES_BLOCK_SIZE) == 0)\\r\\nreturn padlock_aes_cipher_omnivorous(ctx, out_arg, in_arg, nbytes);\\r\\nchunk = nbytes;\\r\\nchunk %= PADLOCK_CHUNK;\\r\\nif (chunk == 0)\\r\\nchunk = PADLOCK_CHUNK;\\r\\nif (out_misaligned) {\\r\\nallocated = (chunk < nbytes ? PADLOCK_CHUNK : nbytes);\\r\\nout = alloca(0x10 + allocated);\\r\\nout = NEAREST_ALIGNED(out);\\r\\n} else\\r\\nout = out_arg;\\r\\ncdata = ALIGNED_CIPHER_DATA(ctx);\\r\\npadlock_verify_context(cdata);\\r\\nswitch (EVP_CIPHER_CTX_mode(ctx)) {\\r\\ncase EVP_CIPH_ECB_MODE:\\r\\ndo {\\r\\nif (inp_misaligned)\\r\\ninp = padlock_memcpy(out, in_arg, chunk);\\r\\nelse\\r\\ninp = in_arg;\\r\\nin_arg += chunk;\\r\\npadlock_xcrypt_ecb(chunk / AES_BLOCK_SIZE, cdata, out, inp);\\r\\nif (out_misaligned)\\r\\nout_arg = padlock_memcpy(out_arg, out, chunk) + chunk;\\r\\nelse\\r\\nout = out_arg += chunk;\\r\\nnbytes -= chunk;\\r\\nchunk = PADLOCK_CHUNK;\\r\\n} while (nbytes);\\r\\nbreak;\\r\\ncase EVP_CIPH_CBC_MODE:\\r\\nmemcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);\\r\\ngoto cbc_shortcut;\\r\\ndo {\\r\\nif (iv != cdata->iv)\\r\\nmemcpy(cdata->iv, iv, AES_BLOCK_SIZE);\\r\\nchunk = PADLOCK_CHUNK;\\r\\ncbc_shortcut:\\r\\nif (inp_misaligned)\\r\\ninp = padlock_memcpy(out, in_arg, chunk);\\r\\nelse\\r\\ninp = in_arg;\\r\\nin_arg += chunk;\\r\\niv = padlock_xcrypt_cbc(chunk / AES_BLOCK_SIZE, cdata, out, inp);\\r\\nif (out_misaligned)\\r\\nout_arg = padlock_memcpy(out_arg, out, chunk) + chunk;\\r\\nelse\\r\\nout = out_arg += chunk;\\r\\n} while (nbytes -= chunk);\\r\\nmemcpy(ctx->iv, iv, AES_BLOCK_SIZE);\\r\\nbreak;\\r\\ncase EVP_CIPH_CFB_MODE:\\r\\nmemcpy(iv = cdata->iv, ctx->iv, AES_BLOCK_SIZE);\\r\\nchunk &= ~(AES_BLOCK_SIZE - 1);\\r\\nif (chunk)\\r\\ngoto cfb_shortcut;\\r\\nelse\\r\\ngoto cfb_skiploop;\\r\\ndo {\\r\\nif (iv != cdata->iv)\\r\\nmemcpy(cdata->iv, iv, AES_BLOCK_SIZE);\\r\\nchunk = PADLOCK_CHUNK;\\r\\ncfb_shortcut:\\r\\nif (inp_misaligned)\\r\\ninp = padlock_memcpy(out, in_arg, chunk);\\r\\nelse\\r\\ninp = in_arg;\\r\\nin_arg += chunk;\\r\\niv = padlock_xcrypt_cfb(chunk / AES_BLOCK_SIZE, cdata, out, inp);\\r\\nif (out_misaligned)\\r\\nout_arg = padlock_memcpy(out_arg, out, chunk) + chunk;\\r\\nelse\\r\\nout = out_arg += chunk;\\r\\nnbytes -= chunk;\\r\\n} while (nbytes >= AES_BLOCK_SIZE);\\r\\ncfb_skiploop:\\r\\nif (nbytes) {\\r\\nunsigned char *ivp = cdata->iv;\\r\\nif (iv != ivp) {\\r\\nmemcpy(ivp, iv, AES_BLOCK_SIZE);\\r\\niv = ivp;\\r\\n}\\r\\nctx->num = nbytes;\\r\\nif (cdata->cword.b.encdec) {\\r\\ncdata->cword.b.encdec = 0;\\r\\npadlock_reload_key();\\r\\npadlock_xcrypt_ecb(1, cdata, ivp, ivp);\\r\\ncdata->cword.b.encdec = 1;\\r\\npadlock_reload_key();\\r\\nwhile (nbytes) {\\r\\nunsigned char c = *(in_arg++);\\r\\n*(out_arg++) = c ^ *ivp;\\r\\n*(ivp++) = c, nbytes--;\\r\\n}\\r\\n} else {\\r\\npadlock_reload_key();\\r\\npadlock_xcrypt_ecb(1, cdata, ivp, ivp);\\r\\npadlock_reload_key();\\r\\nwhile (nbytes) {\\r\\n*ivp = *(out_arg++) = *(in_arg++) ^ *ivp;\\r\\nivp++, nbytes--;\\r\\n}\\r\\n}\\r\\n}\\r\\nmemcpy(ctx->iv, iv, AES_BLOCK_SIZE);\\r\\nbreak;\\r\\ncase EVP_CIPH_OFB_MODE:\\r\\nmemcpy(cdata->iv, ctx->iv, AES_BLOCK_SIZE);\\r\\nchunk &= ~(AES_BLOCK_SIZE - 1);\\r\\nif (chunk)\\r\\ndo {\\r\\nif (inp_misaligned)\\r\\ninp = padlock_memcpy(out, in_arg, chunk);\\r\\nelse\\r\\ninp = in_arg;\\r\\nin_arg += chunk;\\r\\npadlock_xcrypt_ofb(chunk / AES_BLOCK_SIZE, cdata, out, inp);\\r\\nif (out_misaligned)\\r\\nout_arg = padlock_memcpy(out_arg, out, chunk) + chunk;\\r\\nelse\\r\\nout = out_arg += chunk;\\r\\nnbytes -= chunk;\\r\\nchunk = PADLOCK_CHUNK;\\r\\n} while (nbytes >= AES_BLOCK_SIZE);\\r\\nif (nbytes) {\\r\\nunsigned char *ivp = cdata->iv;\\r\\nctx->num = nbytes;\\r\\npadlock_reload_key();\\r\\npadlock_xcrypt_ecb(1, cdata, ivp, ivp);\\r\\npadlock_reload_key();\\r\\nwhile (nbytes) {\\r\\n*(out_arg++) = *(in_arg++) ^ *ivp;\\r\\nivp++, nbytes--;\\r\\n}\\r\\n}\\r\\nmemcpy(ctx->iv, cdata->iv, AES_BLOCK_SIZE);\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nif (out_misaligned) {\\r\\nvolatile unsigned long *p = (void *)out;\\r\\nsize_t n = allocated / sizeof(*p);\\r\\nwhile (n--)\\r\\n*p++ = 0;\\r\\n}\\r\\nmemset(cdata->iv, 0, AES_BLOCK_SIZE);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int padlock_rand_bytes(unsigned char *output, int count)\\r\\n{\\r\\nunsigned int eax, buf;\\r\\nwhile (count >= 8) {\\r\\neax = padlock_xstore(output, 0);\\r\\nif (!(eax & (1 << 6)))\\r\\nreturn 0;\\r\\nif (eax & (0x1F << 10))\\r\\nreturn 0;\\r\\nif ((eax & 0x1F) == 0)\\r\\ncontinue;\\r\\nif ((eax & 0x1F) != 8)\\r\\nreturn 0;\\r\\noutput += 8;\\r\\ncount -= 8;\\r\\n}\\r\\nwhile (count > 0) {\\r\\neax = padlock_xstore(&buf, 3);\\r\\nif (!(eax & (1 << 6)))\\r\\nreturn 0;\\r\\nif (eax & (0x1F << 10))\\r\\nreturn 0;\\r\\nif ((eax & 0x1F) == 0)\\r\\ncontinue;\\r\\nif ((eax & 0x1F) != 1)\\r\\nreturn 0;\\r\\n*output++ = (unsigned char)buf;\\r\\ncount--;\\r\\n}\\r\\n*(volatile unsigned int *)&buf = 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int padlock_rand_status(void)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nOPENSSL_EXPORT\\r\\nint bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns)\\r\\n{\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_b_sock_c", "target": 0, "func": "int BIO_get_host_ip(const char *str, unsigned char *ip)\\r\\n{\\r\\nint i;\\r\\nint err = 1;\\r\\nint locked = 0;\\r\\nstruct hostent *he;\\r\\ni = get_ip(str, ip);\\r\\nif (i < 0) {\\r\\nBIOerr(BIO_F_BIO_GET_HOST_IP, BIO_R_INVALID_IP_ADDRESS);\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_sock_init() != 1)\\r\\nreturn 0;\\r\\nif (i > 0)\\r\\nreturn (1);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\nlocked = 1;\\r\\nhe = BIO_gethostbyname(str);\\r\\nif (he == NULL) {\\r\\nBIOerr(BIO_F_BIO_GET_HOST_IP, BIO_R_BAD_HOSTNAME_LOOKUP);\\r\\ngoto err;\\r\\n}\\r\\nif ((short)he->h_addrtype != AF_INET) {\\r\\nBIOerr(BIO_F_BIO_GET_HOST_IP,\\r\\nBIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET);\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < 4; i++)\\r\\nip[i] = he->h_addr_list[0][i];\\r\\nerr = 0;\\r\\nerr:\\r\\nif (locked)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\nif (err) {\\r\\nERR_add_error_data(2, \"host=\", str);\\r\\nreturn 0;\\r\\n} else\\r\\nreturn 1;\\r\\n}\\r\\nint BIO_get_port(const char *str, unsigned short *port_ptr)\\r\\n{\\r\\nint i;\\r\\nstruct servent *s;\\r\\nif (str == NULL) {\\r\\nBIOerr(BIO_F_BIO_GET_PORT, BIO_R_NO_PORT_DEFINED);\\r\\nreturn (0);\\r\\n}\\r\\ni = atoi(str);\\r\\nif (i != 0)\\r\\n*port_ptr = (unsigned short)i;\\r\\nelse {\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_GETSERVBYNAME);\\r\\n# ifndef CONST_STRICT\\r\\ns = getservbyname((char *)str, \"tcp\");\\r\\n# else\\r\\ns = getservbyname(str, \"tcp\");\\r\\n# endif\\r\\nif (s != NULL)\\r\\n*port_ptr = ntohs((unsigned short)s->s_port);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_GETSERVBYNAME);\\r\\nif (s == NULL) {\\r\\nif (strcmp(str, \"http\") == 0)\\r\\n*port_ptr = 80;\\r\\nelse if (strcmp(str, \"telnet\") == 0)\\r\\n*port_ptr = 23;\\r\\nelse if (strcmp(str, \"socks\") == 0)\\r\\n*port_ptr = 1080;\\r\\nelse if (strcmp(str, \"https\") == 0)\\r\\n*port_ptr = 443;\\r\\nelse if (strcmp(str, \"ssl\") == 0)\\r\\n*port_ptr = 443;\\r\\nelse if (strcmp(str, \"ftp\") == 0)\\r\\n*port_ptr = 21;\\r\\nelse if (strcmp(str, \"gopher\") == 0)\\r\\n*port_ptr = 70;\\r\\n# if 0\\r\\nelse if (strcmp(str, \"wais\") == 0)\\r\\n*port_ptr = 21;\\r\\n# endif\\r\\nelse {\\r\\nSYSerr(SYS_F_GETSERVBYNAME, get_last_socket_error());\\r\\nERR_add_error_data(3, \"service='\", str, \"'\");\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nint BIO_sock_error(int sock)\\r\\n{\\r\\nint j, i;\\r\\nunion {\\r\\nsize_t s;\\r\\nint i;\\r\\n} size;\\r\\n# if defined(OPENSSL_SYS_BEOS_R5)\\r\\nreturn 0;\\r\\n# endif\\r\\nsize.s = 0, size.i = sizeof(j);\\r\\ni = getsockopt(sock, SOL_SOCKET, SO_ERROR, (void *)&j, (void *)&size);\\r\\nif (i < 0)\\r\\nreturn (1);\\r\\nelse\\r\\nreturn (j);\\r\\n}\\r\\nstruct hostent *BIO_gethostbyname(const char *name)\\r\\n{\\r\\n# if 1\\r\\n# if (defined(NETWARE_BSDSOCK) && !defined(__NOVELL_LIBC__))\\r\\nreturn gethostbyname((char *)name);\\r\\n# else\\r\\nreturn gethostbyname(name);\\r\\n# endif\\r\\n# else\\r\\nstruct hostent *ret;\\r\\nint i, lowi = 0, j;\\r\\nunsigned long low = (unsigned long)-1;\\r\\n# if 0\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\n# endif\\r\\nj = strlen(name);\\r\\nif (j < 128) {\\r\\nfor (i = 0; i < GHBN_NUM; i++) {\\r\\nif (low > ghbn_cache[i].order) {\\r\\nlow = ghbn_cache[i].order;\\r\\nlowi = i;\\r\\n}\\r\\nif (ghbn_cache[i].order > 0) {\\r\\nif (strncmp(name, ghbn_cache[i].name, 128) == 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n} else\\r\\ni = GHBN_NUM;\\r\\nif (i == GHBN_NUM) {\\r\\nBIO_ghbn_miss++;\\r\\n# ifndef CONST_STRICT\\r\\nret = gethostbyname((char *)name);\\r\\n# else\\r\\nret = gethostbyname(name);\\r\\n# endif\\r\\nif (ret == NULL)\\r\\ngoto end;\\r\\nif (j > 128) {\\r\\n# if 0\\r\\nret = NULL;\\r\\n# endif\\r\\ngoto end;\\r\\n}\\r\\nif (ghbn_cache[lowi].ent != NULL)\\r\\nghbn_free(ghbn_cache[lowi].ent);\\r\\nghbn_cache[lowi].name[0] = '\\0';\\r\\nif ((ret = ghbn_cache[lowi].ent = ghbn_dup(ret)) == NULL) {\\r\\nBIOerr(BIO_F_BIO_GETHOSTBYNAME, ERR_R_MALLOC_FAILURE);\\r\\ngoto end;\\r\\n}\\r\\nstrncpy(ghbn_cache[lowi].name, name, 128);\\r\\nghbn_cache[lowi].order = BIO_ghbn_miss + BIO_ghbn_hits;\\r\\n} else {\\r\\nBIO_ghbn_hits++;\\r\\nret = ghbn_cache[i].ent;\\r\\nghbn_cache[i].order = BIO_ghbn_miss + BIO_ghbn_hits;\\r\\n}\\r\\nend:\\r\\n# if 0\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_GETHOSTBYNAME);\\r\\n# endif\\r\\nreturn (ret);\\r\\n# endif\\r\\n}\\r\\nint BIO_sock_init(void)\\r\\n{\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\nstatic struct WSAData wsa_state;\\r\\nif (!wsa_init_done) {\\r\\nint err;\\r\\nwsa_init_done = 1;\\r\\nmemset(&wsa_state, 0, sizeof(wsa_state));\\r\\nif (WSAStartup(0x0202, &wsa_state) != 0) {\\r\\nerr = WSAGetLastError();\\r\\nSYSerr(SYS_F_WSASTARTUP, err);\\r\\nBIOerr(BIO_F_BIO_SOCK_INIT, BIO_R_WSASTARTUP);\\r\\nreturn (-1);\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# ifdef WATT32\\r\\nextern int _watt_do_exit;\\r\\n_watt_do_exit = 0;\\r\\nif (sock_init())\\r\\nreturn (-1);\\r\\n# endif\\r\\n# if defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)\\r\\nWORD wVerReq;\\r\\nWSADATA wsaData;\\r\\nint err;\\r\\nif (!wsa_init_done) {\\r\\nwsa_init_done = 1;\\r\\nwVerReq = MAKEWORD(2, 0);\\r\\nerr = WSAStartup(wVerReq, &wsaData);\\r\\nif (err != 0) {\\r\\nSYSerr(SYS_F_WSASTARTUP, err);\\r\\nBIOerr(BIO_F_BIO_SOCK_INIT, BIO_R_WSASTARTUP);\\r\\nreturn (-1);\\r\\n}\\r\\n}\\r\\n# endif\\r\\nreturn (1);\\r\\n}\\r\\nvoid BIO_sock_cleanup(void)\\r\\n{\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\nif (wsa_init_done) {\\r\\nwsa_init_done = 0;\\r\\n# if 0\\r\\nWSACancelBlockingCall();\\r\\n# endif\\r\\nWSACleanup();\\r\\n}\\r\\n# elif defined(OPENSSL_SYS_NETWARE) && !defined(NETWARE_BSDSOCK)\\r\\nif (wsa_init_done) {\\r\\nwsa_init_done = 0;\\r\\nWSACleanup();\\r\\n}\\r\\n# endif\\r\\n}\\r\\nint BIO_socket_ioctl(int fd, long type, void *arg)\\r\\n{\\r\\nint i;\\r\\n# ifdef __DJGPP__\\r\\ni = ioctlsocket(fd, type, (char *)arg);\\r\\n# else\\r\\n# if defined(OPENSSL_SYS_VMS)\\r\\n# if __INITIAL_POINTER_SIZE == 64\\r\\n# define ARG arg_32p\\r\\n# pragma pointer_size save\\r\\n# pragma pointer_size 32\\r\\nunsigned long arg_32;\\r\\nunsigned long *arg_32p;\\r\\n# pragma pointer_size restore\\r\\narg_32p = &arg_32;\\r\\narg_32 = *((unsigned long *)arg);\\r\\n# else\\r\\n# define ARG arg\\r\\n# endif\\r\\n# else\\r\\n# define ARG arg\\r\\n# endif\\r\\ni = ioctlsocket(fd, type, ARG);\\r\\n# endif\\r\\nif (i < 0)\\r\\nSYSerr(SYS_F_IOCTLSOCKET, get_last_socket_error());\\r\\nreturn (i);\\r\\n}\\r\\nstatic int get_ip(const char *str, unsigned char ip[4])\\r\\n{\\r\\nunsigned int tmp[4];\\r\\nint num = 0, c, ok = 0;\\r\\ntmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\\r\\nfor (;;) {\\r\\nc = *(str++);\\r\\nif ((c >= '0') && (c <= '9')) {\\r\\nok = 1;\\r\\ntmp[num] = tmp[num] * 10 + c - '0';\\r\\nif (tmp[num] > 255)\\r\\nreturn (0);\\r\\n} else if (c == '.') {\\r\\nif (!ok)\\r\\nreturn (-1);\\r\\nif (num == 3)\\r\\nreturn (0);\\r\\nnum++;\\r\\nok = 0;\\r\\n} else if (c == '\\0' && (num == 3) && ok)\\r\\nbreak;\\r\\nelse\\r\\nreturn (0);\\r\\n}\\r\\nip[0] = tmp[0];\\r\\nip[1] = tmp[1];\\r\\nip[2] = tmp[2];\\r\\nip[3] = tmp[3];\\r\\nreturn (1);\\r\\n}\\r\\nint BIO_get_accept_socket(char *host, int bind_mode)\\r\\n{\\r\\nint ret = 0;\\r\\nunion {\\r\\nstruct sockaddr sa;\\r\\nstruct sockaddr_in sa_in;\\r\\n# if OPENSSL_USE_IPV6\\r\\nstruct sockaddr_in6 sa_in6;\\r\\n# endif\\r\\n} server, client;\\r\\nint s = INVALID_SOCKET, cs, addrlen;\\r\\nunsigned char ip[4];\\r\\nunsigned short port;\\r\\nchar *str = NULL, *e;\\r\\nchar *h, *p;\\r\\nunsigned long l;\\r\\nint err_num;\\r\\nif (BIO_sock_init() != 1)\\r\\nreturn (INVALID_SOCKET);\\r\\nif ((str = BUF_strdup(host)) == NULL)\\r\\nreturn (INVALID_SOCKET);\\r\\nh = p = NULL;\\r\\nh = str;\\r\\nfor (e = str; *e; e++) {\\r\\nif (*e == ':') {\\r\\np = e;\\r\\n} else if (*e == '/') {\\r\\n*e = '\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (p)\\r\\n*p++ = '\\0';\\r\\nelse\\r\\np = h, h = NULL;\\r\\n# ifdef EAI_FAMILY\\r\\ndo {\\r\\nstatic union {\\r\\nvoid *p;\\r\\nint (WSAAPI *f) (const char *, const char *,\\r\\nconst struct addrinfo *, struct addrinfo **);\\r\\n} p_getaddrinfo = {\\r\\nNULL\\r\\n};\\r\\nstatic union {\\r\\nvoid *p;\\r\\nvoid (WSAAPI *f) (struct addrinfo *);\\r\\n} p_freeaddrinfo = {\\r\\nNULL\\r\\n};\\r\\nstruct addrinfo *res, hint;\\r\\nif (p_getaddrinfo.p == NULL) {\\r\\nif ((p_getaddrinfo.p = DSO_global_lookup(\"getaddrinfo\")) == NULL\\r\\n|| (p_freeaddrinfo.p =\\r\\nDSO_global_lookup(\"freeaddrinfo\")) == NULL)\\r\\np_getaddrinfo.p = (void *)-1;\\r\\n}\\r\\nif (p_getaddrinfo.p == (void *)-1)\\r\\nbreak;\\r\\nmemset(&hint, 0, sizeof(hint));\\r\\nhint.ai_flags = AI_PASSIVE;\\r\\nif (h) {\\r\\nif (strchr(h, ':')) {\\r\\nif (h[1] == '\\0')\\r\\nh = NULL;\\r\\n# if OPENSSL_USE_IPV6\\r\\nhint.ai_family = AF_INET6;\\r\\n# else\\r\\nh = NULL;\\r\\n# endif\\r\\n} else if (h[0] == '*' && h[1] == '\\0') {\\r\\nhint.ai_family = AF_INET;\\r\\nh = NULL;\\r\\n}\\r\\n}\\r\\nif ((*p_getaddrinfo.f) (h, p, &hint, &res))\\r\\nbreak;\\r\\naddrlen = res->ai_addrlen <= sizeof(server) ?\\r\\nres->ai_addrlen : sizeof(server);\\r\\nmemcpy(&server, res->ai_addr, addrlen);\\r\\n(*p_freeaddrinfo.f) (res);\\r\\ngoto again;\\r\\n} while (0);\\r\\n# endif\\r\\nif (!BIO_get_port(p, &port))\\r\\ngoto err;\\r\\nmemset((char *)&server, 0, sizeof(server));\\r\\nserver.sa_in.sin_family = AF_INET;\\r\\nserver.sa_in.sin_port = htons(port);\\r\\naddrlen = sizeof(server.sa_in);\\r\\nif (h == NULL || strcmp(h, \"*\") == 0)\\r\\nserver.sa_in.sin_addr.s_addr = INADDR_ANY;\\r\\nelse {\\r\\nif (!BIO_get_host_ip(h, &(ip[0])))\\r\\ngoto err;\\r\\nl = (unsigned long)\\r\\n((unsigned long)ip[0] << 24L) |\\r\\n((unsigned long)ip[1] << 16L) |\\r\\n((unsigned long)ip[2] << 8L) | ((unsigned long)ip[3]);\\r\\nserver.sa_in.sin_addr.s_addr = htonl(l);\\r\\n}\\r\\nagain:\\r\\ns = socket(server.sa.sa_family, SOCK_STREAM, SOCKET_PROTOCOL);\\r\\nif (s == INVALID_SOCKET) {\\r\\nSYSerr(SYS_F_SOCKET, get_last_socket_error());\\r\\nERR_add_error_data(3, \"port='\", host, \"'\");\\r\\nBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET, BIO_R_UNABLE_TO_CREATE_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\n# ifdef SO_REUSEADDR\\r\\nif (bind_mode == BIO_BIND_REUSEADDR) {\\r\\nint i = 1;\\r\\nret = setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&i, sizeof(i));\\r\\nbind_mode = BIO_BIND_NORMAL;\\r\\n}\\r\\n# endif\\r\\nif (bind(s, &server.sa, addrlen) == -1) {\\r\\n# ifdef SO_REUSEADDR\\r\\nerr_num = get_last_socket_error();\\r\\nif ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) &&\\r\\n# ifdef OPENSSL_SYS_WINDOWS\\r\\n(err_num == WSAEADDRINUSE))\\r\\n# else\\r\\n(err_num == EADDRINUSE))\\r\\n# endif\\r\\n{\\r\\nclient = server;\\r\\nif (h == NULL || strcmp(h, \"*\") == 0) {\\r\\n# if OPENSSL_USE_IPV6\\r\\nif (client.sa.sa_family == AF_INET6) {\\r\\nmemset(&client.sa_in6.sin6_addr, 0,\\r\\nsizeof(client.sa_in6.sin6_addr));\\r\\nclient.sa_in6.sin6_addr.s6_addr[15] = 1;\\r\\n} else\\r\\n# endif\\r\\nif (client.sa.sa_family == AF_INET) {\\r\\nclient.sa_in.sin_addr.s_addr = htonl(0x7F000001);\\r\\n} else\\r\\ngoto err;\\r\\n}\\r\\ncs = socket(client.sa.sa_family, SOCK_STREAM, SOCKET_PROTOCOL);\\r\\nif (cs != INVALID_SOCKET) {\\r\\nint ii;\\r\\nii = connect(cs, &client.sa, addrlen);\\r\\nclosesocket(cs);\\r\\nif (ii == INVALID_SOCKET) {\\r\\nbind_mode = BIO_BIND_REUSEADDR;\\r\\nclosesocket(s);\\r\\ngoto again;\\r\\n}\\r\\n}\\r\\n}\\r\\n# endif\\r\\nSYSerr(SYS_F_BIND, err_num);\\r\\nERR_add_error_data(3, \"port='\", host, \"'\");\\r\\nBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET, BIO_R_UNABLE_TO_BIND_SOCKET);\\r\\ngoto err;\\r\\n}\\r\\nint BIO_set_tcp_ndelay(int s, int on)\\r\\n{\\r\\nint ret = 0;\\r\\n# if defined(TCP_NODELAY) && (defined(IPPROTO_TCP) || defined(SOL_TCP))\\r\\nint opt;\\r\\n# ifdef SOL_TCP\\r\\nopt = SOL_TCP;\\r\\n# else\\r\\n# ifdef IPPROTO_TCP\\r\\nopt = IPPROTO_TCP;\\r\\n# endif\\r\\n# endif\\r\\nret = setsockopt(s, opt, TCP_NODELAY, (char *)&on, sizeof(on));\\r\\n# endif\\r\\nreturn (ret == 0);\\r\\n}\\r\\nint BIO_socket_nbio(int s, int mode)\\r\\n{\\r\\nint ret = -1;\\r\\nint l;\\r\\nl = mode;\\r\\n# ifdef FIONBIO\\r\\nret = BIO_socket_ioctl(s, FIONBIO, &l);\\r\\n# endif\\r\\nreturn (ret == 0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pkwrite_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nFILE *fp;\\r\\nEVP_PKEY *pkey;\\r\\nX509 *cert;\\r\\nPKCS12 *p12;\\r\\nif (argc != 5) {\\r\\nfprintf(stderr, \"Usage: pkwrite infile password name p12file\\n\");\\r\\nexit(1);\\r\\n}\\r\\nSSLeay_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\nif (!(fp = fopen(argv[1], \"r\"))) {\\r\\nfprintf(stderr, \"Error opening file %s\\n\", argv[1]);\\r\\nexit(1);\\r\\n}\\r\\ncert = PEM_read_X509(fp, NULL, NULL, NULL);\\r\\nrewind(fp);\\r\\npkey = PEM_read_PrivateKey(fp, NULL, NULL, NULL);\\r\\nfclose(fp);\\r\\np12 = PKCS12_create(argv[2], argv[3], pkey, cert, NULL, 0, 0, 0, 0, 0);\\r\\nif (!p12) {\\r\\nfprintf(stderr, \"Error creating PKCS#12 structure\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\nif (!(fp = fopen(argv[4], \"wb\"))) {\\r\\nfprintf(stderr, \"Error opening file %s\\n\", argv[1]);\\r\\nERR_print_errors_fp(stderr);\\r\\nexit(1);\\r\\n}\\r\\ni2d_PKCS12_fp(fp, p12);\\r\\nPKCS12_free(p12);\\r\\nfclose(fp);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_c_ofb64_c", "target": 0, "func": "void CAST_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, const CAST_KEY *schedule,\\r\\nunsigned char *ivec, int *num)\\r\\n{\\r\\nregister CAST_LONG v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nCAST_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save = 0;\\r\\niv = ivec;\\r\\nn2l(iv, v0);\\r\\nn2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\ndp = (char *)d;\\r\\nl2n(v0, dp);\\r\\nl2n(v1, dp);\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nCAST_encrypt((CAST_LONG *)ti, schedule);\\r\\ndp = (char *)d;\\r\\nt = ti[0];\\r\\nl2n(t, dp);\\r\\nt = ti[1];\\r\\nl2n(t, dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++) = *(in++) ^ d[n];\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\nif (save) {\\r\\nv0 = ti[0];\\r\\nv1 = ti[1];\\r\\niv = ivec;\\r\\nl2n(v0, iv);\\r\\nl2n(v1, iv);\\r\\n}\\r\\nt = v0 = v1 = ti[0] = ti[1] = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_ia5_c", "target": 0, "func": "static char *i2s_ASN1_IA5STRING(X509V3_EXT_METHOD *method,\\r\\nASN1_IA5STRING *ia5)\\r\\n{\\r\\nchar *tmp;\\r\\nif (!ia5 || !ia5->length)\\r\\nreturn NULL;\\r\\nif (!(tmp = OPENSSL_malloc(ia5->length + 1))) {\\r\\nX509V3err(X509V3_F_I2S_ASN1_IA5STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nmemcpy(tmp, ia5->data, ia5->length);\\r\\ntmp[ia5->length] = 0;\\r\\nreturn tmp;\\r\\n}\\r\\nstatic ASN1_IA5STRING *s2i_ASN1_IA5STRING(X509V3_EXT_METHOD *method,\\r\\nX509V3_CTX *ctx, char *str)\\r\\n{\\r\\nASN1_IA5STRING *ia5;\\r\\nif (!str) {\\r\\nX509V3err(X509V3_F_S2I_ASN1_IA5STRING,\\r\\nX509V3_R_INVALID_NULL_ARGUMENT);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(ia5 = M_ASN1_IA5STRING_new()))\\r\\ngoto err;\\r\\nif (!ASN1_STRING_set((ASN1_STRING *)ia5, (unsigned char *)str,\\r\\nstrlen(str))) {\\r\\nM_ASN1_IA5STRING_free(ia5);\\r\\ngoto err;\\r\\n}\\r\\n#ifdef CHARSET_EBCDIC\\r\\nebcdic2ascii(ia5->data, ia5->data, ia5->length);\\r\\n#endif\\r\\nreturn ia5;\\r\\nerr:\\r\\nX509V3err(X509V3_F_S2I_ASN1_IA5STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecparam_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nEC_GROUP *group = NULL;\\r\\npoint_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;\\r\\nint new_form = 0;\\r\\nint asn1_flag = OPENSSL_EC_NAMED_CURVE;\\r\\nint new_asn1_flag = 0;\\r\\nchar *curve_name = NULL, *inrand = NULL;\\r\\nint list_curves = 0, no_seed = 0, check = 0,\\r\\nbadops = 0, text = 0, i, need_rand = 0, genkey = 0;\\r\\nchar *infile = NULL, *outfile = NULL, *prog;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat, noout = 0, C = 0, ret = 1;\\r\\nchar *engine = NULL;\\r\\nBIGNUM *ec_p = NULL, *ec_a = NULL, *ec_b = NULL,\\r\\n*ec_gen = NULL, *ec_order = NULL, *ec_cofactor = NULL;\\r\\nunsigned char *buffer = NULL;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv, \"-C\") == 0)\\r\\nC = 1;\\r\\nelse if (strcmp(*argv, \"-check\") == 0)\\r\\ncheck = 1;\\r\\nelse if (strcmp(*argv, \"-name\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncurve_name = *(++argv);\\r\\n} else if (strcmp(*argv, \"-list_curves\") == 0)\\r\\nlist_curves = 1;\\r\\nelse if (strcmp(*argv, \"-conv_form\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\n++argv;\\r\\nnew_form = 1;\\r\\nif (strcmp(*argv, \"compressed\") == 0)\\r\\nform = POINT_CONVERSION_COMPRESSED;\\r\\nelse if (strcmp(*argv, \"uncompressed\") == 0)\\r\\nform = POINT_CONVERSION_UNCOMPRESSED;\\r\\nelse if (strcmp(*argv, \"hybrid\") == 0)\\r\\nform = POINT_CONVERSION_HYBRID;\\r\\nelse\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-param_enc\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\n++argv;\\r\\nnew_asn1_flag = 1;\\r\\nif (strcmp(*argv, \"named_curve\") == 0)\\r\\nasn1_flag = OPENSSL_EC_NAMED_CURVE;\\r\\nelse if (strcmp(*argv, \"explicit\") == 0)\\r\\nasn1_flag = 0;\\r\\nelse\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-no_seed\") == 0)\\r\\nno_seed = 1;\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-genkey\") == 0) {\\r\\ngenkey = 1;\\r\\nneed_rand = 1;\\r\\n} else if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninrand = *(++argv);\\r\\nneed_rand = 1;\\r\\n} else if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile >outfile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - \"\\r\\n\"default PEM (DER or PEM)\\n\");\\r\\nBIO_printf(bio_err, \" -outform arg output format - \"\\r\\n\"default PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file - \"\\r\\n\"default stdin\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file - \"\\r\\n\"default stdout\\n\");\\r\\nBIO_printf(bio_err, \" -noout do not print the \"\\r\\n\"ec parameter\\n\");\\r\\nBIO_printf(bio_err, \" -text print the ec \"\\r\\n\"parameters in text form\\n\");\\r\\nBIO_printf(bio_err, \" -check validate the ec \"\\r\\n\"parameters\\n\");\\r\\nBIO_printf(bio_err, \" -C print a 'C' \"\\r\\n\"function creating the parameters\\n\");\\r\\nBIO_printf(bio_err, \" -name arg use the \"\\r\\n\"ec parameters with 'short name' name\\n\");\\r\\nBIO_printf(bio_err, \" -list_curves prints a list of \"\\r\\n\"all currently available curve 'short names'\\n\");\\r\\nBIO_printf(bio_err, \" -conv_form arg specifies the \"\\r\\n\"point conversion form \\n\");\\r\\nBIO_printf(bio_err, \" possible values:\"\\r\\n\" compressed\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\" uncompressed (default)\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\" hybrid\\n\");\\r\\nBIO_printf(bio_err, \" -param_enc arg specifies the way\"\\r\\n\" the ec parameters are encoded\\n\");\\r\\nBIO_printf(bio_err, \" in the asn1 der \"\\r\\n\"encoding\\n\");\\r\\nBIO_printf(bio_err, \" possible values:\"\\r\\n\" named_curve (default)\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\" explicit\\n\");\\r\\nBIO_printf(bio_err, \" -no_seed if 'explicit'\"\\r\\n\" parameters are chosen do not\" \" use the seed\\n\");\\r\\nBIO_printf(bio_err, \" -genkey generate ec\" \" key\\n\");\\r\\nBIO_printf(bio_err, \" -rand file files to use for\"\\r\\n\" random number input\\n\");\\r\\nBIO_printf(bio_err, \" -engine e use engine e, \"\\r\\n\"possibly a hardware device\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (list_curves) {\\r\\nEC_builtin_curve *curves = NULL;\\r\\nsize_t crv_len = 0;\\r\\nsize_t n = 0;\\r\\ncrv_len = EC_get_builtin_curves(NULL, 0);\\r\\ncurves = OPENSSL_malloc((int)(sizeof(EC_builtin_curve) * crv_len));\\r\\nif (curves == NULL)\\r\\ngoto end;\\r\\nif (!EC_get_builtin_curves(curves, crv_len)) {\\r\\nOPENSSL_free(curves);\\r\\ngoto end;\\r\\n}\\r\\nfor (n = 0; n < crv_len; n++) {\\r\\nconst char *comment;\\r\\nconst char *sname;\\r\\ncomment = curves[n].comment;\\r\\nsname = OBJ_nid2sn(curves[n].nid);\\r\\nif (comment == NULL)\\r\\ncomment = \"CURVE DESCRIPTION NOT AVAILABLE\";\\r\\nif (sname == NULL)\\r\\nsname = \"\";\\r\\nBIO_printf(out, \" %-10s: \", sname);\\r\\nBIO_printf(out, \"%s\\n\", comment);\\r\\n}\\r\\nOPENSSL_free(curves);\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (curve_name != NULL) {\\r\\nint nid;\\r\\nif (!strcmp(curve_name, \"secp192r1\")) {\\r\\nBIO_printf(bio_err, \"using curve name prime192v1 \"\\r\\n\"instead of secp192r1\\n\");\\r\\nnid = NID_X9_62_prime192v1;\\r\\n} else if (!strcmp(curve_name, \"secp256r1\")) {\\r\\nBIO_printf(bio_err, \"using curve name prime256v1 \"\\r\\n\"instead of secp256r1\\n\");\\r\\nnid = NID_X9_62_prime256v1;\\r\\n} else\\r\\nnid = OBJ_sn2nid(curve_name);\\r\\nif (nid == 0)\\r\\nnid = EC_curve_nist2nid(curve_name);\\r\\nif (nid == 0) {\\r\\nBIO_printf(bio_err, \"unknown curve name (%s)\\n\", curve_name);\\r\\ngoto end;\\r\\n}\\r\\ngroup = EC_GROUP_new_by_curve_name(nid);\\r\\nif (group == NULL) {\\r\\nBIO_printf(bio_err, \"unable to create curve (%s)\\n\", curve_name);\\r\\ngoto end;\\r\\n}\\r\\nEC_GROUP_set_asn1_flag(group, asn1_flag);\\r\\nEC_GROUP_set_point_conversion_form(group, form);\\r\\n} else if (informat == FORMAT_ASN1) {\\r\\ngroup = d2i_ECPKParameters_bio(in, NULL);\\r\\n} else if (informat == FORMAT_PEM) {\\r\\ngroup = PEM_read_bio_ECPKParameters(in, NULL, NULL, NULL);\\r\\n} else {\\r\\nBIO_printf(bio_err, \"bad input format specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (group == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load elliptic curve parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (new_form)\\r\\nEC_GROUP_set_point_conversion_form(group, form);\\r\\nif (new_asn1_flag)\\r\\nEC_GROUP_set_asn1_flag(group, asn1_flag);\\r\\nif (no_seed) {\\r\\nEC_GROUP_set_seed(group, NULL, 0);\\r\\n}\\r\\nif (text) {\\r\\nif (!ECPKParameters_print(out, group, 0))\\r\\ngoto end;\\r\\n}\\r\\nif (check) {\\r\\nif (group == NULL)\\r\\nBIO_printf(bio_err, \"no elliptic curve parameters\\n\");\\r\\nBIO_printf(bio_err, \"checking elliptic curve parameters: \");\\r\\nif (!EC_GROUP_check(group, NULL)) {\\r\\nBIO_printf(bio_err, \"failed\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n} else\\r\\nBIO_printf(bio_err, \"ok\\n\");\\r\\n}\\r\\nif (C) {\\r\\nsize_t buf_len = 0, tmp_len = 0;\\r\\nconst EC_POINT *point;\\r\\nint is_prime, len = 0;\\r\\nconst EC_METHOD *meth = EC_GROUP_method_of(group);\\r\\nif ((ec_p = BN_new()) == NULL || (ec_a = BN_new()) == NULL ||\\r\\n(ec_b = BN_new()) == NULL || (ec_gen = BN_new()) == NULL ||\\r\\n(ec_order = BN_new()) == NULL ||\\r\\n(ec_cofactor = BN_new()) == NULL) {\\r\\nperror(\"OPENSSL_malloc\");\\r\\ngoto end;\\r\\n}\\r\\nis_prime = (EC_METHOD_get_field_type(meth) == NID_X9_62_prime_field);\\r\\nif (is_prime) {\\r\\nif (!EC_GROUP_get_curve_GFp(group, ec_p, ec_a, ec_b, NULL))\\r\\ngoto end;\\r\\n} else {\\r\\ngoto end;\\r\\n}\\r\\nif ((point = EC_GROUP_get0_generator(group)) == NULL)\\r\\ngoto end;\\r\\nif (!EC_POINT_point2bn(group, point,\\r\\nEC_GROUP_get_point_conversion_form(group),\\r\\nec_gen, NULL))\\r\\ngoto end;\\r\\nif (!EC_GROUP_get_order(group, ec_order, NULL))\\r\\ngoto end;\\r\\nif (!EC_GROUP_get_cofactor(group, ec_cofactor, NULL))\\r\\ngoto end;\\r\\nif (!ec_p || !ec_a || !ec_b || !ec_gen || !ec_order || !ec_cofactor)\\r\\ngoto end;\\r\\nlen = BN_num_bits(ec_order);\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_p)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_a)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_b)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_gen)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_order)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nif ((tmp_len = (size_t)BN_num_bytes(ec_cofactor)) > buf_len)\\r\\nbuf_len = tmp_len;\\r\\nbuffer = (unsigned char *)OPENSSL_malloc(buf_len);\\r\\nif (buffer == NULL) {\\r\\nperror(\"OPENSSL_malloc\");\\r\\ngoto end;\\r\\n}\\r\\necparam_print_var(out, ec_p, \"ec_p\", len, buffer);\\r\\necparam_print_var(out, ec_a, \"ec_a\", len, buffer);\\r\\necparam_print_var(out, ec_b, \"ec_b\", len, buffer);\\r\\necparam_print_var(out, ec_gen, \"ec_gen\", len, buffer);\\r\\necparam_print_var(out, ec_order, \"ec_order\", len, buffer);\\r\\necparam_print_var(out, ec_cofactor, \"ec_cofactor\", len, buffer);\\r\\nBIO_printf(out, \"\\n\\n\");\\r\\nBIO_printf(out, \"EC_GROUP *get_ec_group_%d(void)\\n\\t{\\n\", len);\\r\\nBIO_printf(out, \"\\tint ok=0;\\n\");\\r\\nBIO_printf(out, \"\\tEC_GROUP *group = NULL;\\n\");\\r\\nBIO_printf(out, \"\\tEC_POINT *point = NULL;\\n\");\\r\\nBIO_printf(out, \"\\tBIGNUM *tmp_1 = NULL, *tmp_2 = NULL, \"\\r\\n\"*tmp_3 = NULL;\\n\\n\");\\r\\nBIO_printf(out, \"\\tif ((tmp_1 = BN_bin2bn(ec_p_%d, \"\\r\\n\"sizeof(ec_p_%d), NULL)) == NULL)\\n\\t\\t\"\\r\\n\"goto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tif ((tmp_2 = BN_bin2bn(ec_a_%d, \"\\r\\n\"sizeof(ec_a_%d), NULL)) == NULL)\\n\\t\\t\"\\r\\n\"goto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tif ((tmp_3 = BN_bin2bn(ec_b_%d, \"\\r\\n\"sizeof(ec_b_%d), NULL)) == NULL)\\n\\t\\t\"\\r\\n\"goto err;\\n\", len, len);\\r\\nif (is_prime) {\\r\\nBIO_printf(out, \"\\tif ((group = EC_GROUP_new_curve_\"\\r\\n\"GFp(tmp_1, tmp_2, tmp_3, NULL)) == NULL)\"\\r\\n\"\\n\\t\\tgoto err;\\n\\n\");\\r\\n} else {\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(out, \"\\t/* build generator */\\n\");\\r\\nBIO_printf(out, \"\\tif ((tmp_1 = BN_bin2bn(ec_gen_%d, \"\\r\\n\"sizeof(ec_gen_%d), tmp_1)) == NULL)\"\\r\\n\"\\n\\t\\tgoto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tpoint = EC_POINT_bn2point(group, tmp_1, \"\\r\\n\"NULL, NULL);\\n\");\\r\\nBIO_printf(out, \"\\tif (point == NULL)\\n\\t\\tgoto err;\\n\");\\r\\nBIO_printf(out, \"\\tif ((tmp_2 = BN_bin2bn(ec_order_%d, \"\\r\\n\"sizeof(ec_order_%d), tmp_2)) == NULL)\"\\r\\n\"\\n\\t\\tgoto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tif ((tmp_3 = BN_bin2bn(ec_cofactor_%d, \"\\r\\n\"sizeof(ec_cofactor_%d), tmp_3)) == NULL)\"\\r\\n\"\\n\\t\\tgoto err;\\n\", len, len);\\r\\nBIO_printf(out, \"\\tif (!EC_GROUP_set_generator(group, point,\"\\r\\n\" tmp_2, tmp_3))\\n\\t\\tgoto err;\\n\");\\r\\nBIO_printf(out, \"\\n\\tok=1;\\n\");\\r\\nBIO_printf(out, \"err:\\n\");\\r\\nBIO_printf(out, \"\\tif (tmp_1)\\n\\t\\tBN_free(tmp_1);\\n\");\\r\\nBIO_printf(out, \"\\tif (tmp_2)\\n\\t\\tBN_free(tmp_2);\\n\");\\r\\nBIO_printf(out, \"\\tif (tmp_3)\\n\\t\\tBN_free(tmp_3);\\n\");\\r\\nBIO_printf(out, \"\\tif (point)\\n\\t\\tEC_POINT_free(point);\\n\");\\r\\nBIO_printf(out, \"\\tif (!ok)\\n\");\\r\\nBIO_printf(out, \"\\t\\t{\\n\");\\r\\nBIO_printf(out, \"\\t\\tEC_GROUP_free(group);\\n\");\\r\\nBIO_printf(out, \"\\t\\tgroup = NULL;\\n\");\\r\\nBIO_printf(out, \"\\t\\t}\\n\");\\r\\nBIO_printf(out, \"\\treturn(group);\\n\\t}\\n\");\\r\\n}\\r\\nif (!noout) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_ECPKParameters_bio(out, group);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_ECPKParameters(out, group);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified for\"\\r\\n\" outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write elliptic \"\\r\\n\"curve parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (need_rand) {\\r\\napp_RAND_load_file(NULL, bio_err, (inrand != NULL));\\r\\nif (inrand != NULL)\\r\\nBIO_printf(bio_err, \"%ld semi-random bytes loaded\\n\",\\r\\napp_RAND_load_files(inrand));\\r\\n}\\r\\nif (genkey) {\\r\\nEC_KEY *eckey = EC_KEY_new();\\r\\nif (eckey == NULL)\\r\\ngoto end;\\r\\nassert(need_rand);\\r\\nif (EC_KEY_set_group(eckey, group) == 0)\\r\\ngoto end;\\r\\nif (!EC_KEY_generate_key(eckey)) {\\r\\nEC_KEY_free(eckey);\\r\\ngoto end;\\r\\n}\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_ECPrivateKey_bio(out, eckey);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_ECPrivateKey(out, eckey, NULL,\\r\\nNULL, 0, NULL, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified \"\\r\\n\"for outfile\\n\");\\r\\nEC_KEY_free(eckey);\\r\\ngoto end;\\r\\n}\\r\\nEC_KEY_free(eckey);\\r\\n}\\r\\nif (need_rand)\\r\\napp_RAND_write_file(NULL, bio_err);\\r\\nret = 0;\\r\\nend:\\r\\nif (ec_p)\\r\\nBN_free(ec_p);\\r\\nif (ec_a)\\r\\nBN_free(ec_a);\\r\\nif (ec_b)\\r\\nBN_free(ec_b);\\r\\nif (ec_gen)\\r\\nBN_free(ec_gen);\\r\\nif (ec_order)\\r\\nBN_free(ec_order);\\r\\nif (ec_cofactor)\\r\\nBN_free(ec_cofactor);\\r\\nif (buffer)\\r\\nOPENSSL_free(buffer);\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (group != NULL)\\r\\nEC_GROUP_free(group);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic int ecparam_print_var(BIO *out, BIGNUM *in, const char *var,\\r\\nint len, unsigned char *buffer)\\r\\n{\\r\\nBIO_printf(out, \"static unsigned char %s_%d[] = {\", var, len);\\r\\nif (BN_is_zero(in))\\r\\nBIO_printf(out, \"\\n\\t0x00\");\\r\\nelse {\\r\\nint i, l;\\r\\nl = BN_bn2bin(in, buffer);\\r\\nfor (i = 0; i < l - 1; i++) {\\r\\nif ((i % 12) == 0)\\r\\nBIO_printf(out, \"\\n\\t\");\\r\\nBIO_printf(out, \"0x%02X,\", buffer[i]);\\r\\n}\\r\\nif ((i % 12) == 0)\\r\\nBIO_printf(out, \"\\n\\t\");\\r\\nBIO_printf(out, \"0x%02X\", buffer[i]);\\r\\n}\\r\\nBIO_printf(out, \"\\n\\t};\\n\\n\");\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_sxnet_c", "target": 0, "func": "int SXNET_add_id_asc(SXNET **psx, char *zone, char *user, int userlen)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nif (!(izone = s2i_ASN1_INTEGER(NULL, zone))) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_ASC, X509V3_R_ERROR_CONVERTING_ZONE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn SXNET_add_id_INTEGER(psx, izone, user, userlen);\\r\\n}\\r\\nint SXNET_add_id_ulong(SXNET **psx, unsigned long lzone, char *user,\\r\\nint userlen)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nif (!(izone = M_ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_ULONG, ERR_R_MALLOC_FAILURE);\\r\\nM_ASN1_INTEGER_free(izone);\\r\\nreturn 0;\\r\\n}\\r\\nreturn SXNET_add_id_INTEGER(psx, izone, user, userlen);\\r\\n}\\r\\nint SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, char *user,\\r\\nint userlen)\\r\\n{\\r\\nSXNET *sx = NULL;\\r\\nSXNETID *id = NULL;\\r\\nif (!psx || !zone || !user) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER,\\r\\nX509V3_R_INVALID_NULL_ARGUMENT);\\r\\nreturn 0;\\r\\n}\\r\\nif (userlen == -1)\\r\\nuserlen = strlen(user);\\r\\nif (userlen > 64) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, X509V3_R_USER_TOO_LONG);\\r\\nreturn 0;\\r\\n}\\r\\nif (!*psx) {\\r\\nif (!(sx = SXNET_new()))\\r\\ngoto err;\\r\\nif (!ASN1_INTEGER_set(sx->version, 0))\\r\\ngoto err;\\r\\n*psx = sx;\\r\\n} else\\r\\nsx = *psx;\\r\\nif (SXNET_get_id_INTEGER(sx, zone)) {\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, X509V3_R_DUPLICATE_ZONE_ID);\\r\\nreturn 0;\\r\\n}\\r\\nif (!(id = SXNETID_new()))\\r\\ngoto err;\\r\\nif (userlen == -1)\\r\\nuserlen = strlen(user);\\r\\nif (!M_ASN1_OCTET_STRING_set(id->user, user, userlen))\\r\\ngoto err;\\r\\nif (!sk_SXNETID_push(sx->ids, id))\\r\\ngoto err;\\r\\nid->zone = zone;\\r\\nreturn 1;\\r\\nerr:\\r\\nX509V3err(X509V3_F_SXNET_ADD_ID_INTEGER, ERR_R_MALLOC_FAILURE);\\r\\nSXNETID_free(id);\\r\\nSXNET_free(sx);\\r\\n*psx = NULL;\\r\\nreturn 0;\\r\\n}\\r\\nASN1_OCTET_STRING *SXNET_get_id_asc(SXNET *sx, char *zone)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nASN1_OCTET_STRING *oct;\\r\\nif (!(izone = s2i_ASN1_INTEGER(NULL, zone))) {\\r\\nX509V3err(X509V3_F_SXNET_GET_ID_ASC, X509V3_R_ERROR_CONVERTING_ZONE);\\r\\nreturn NULL;\\r\\n}\\r\\noct = SXNET_get_id_INTEGER(sx, izone);\\r\\nM_ASN1_INTEGER_free(izone);\\r\\nreturn oct;\\r\\n}\\r\\nASN1_OCTET_STRING *SXNET_get_id_ulong(SXNET *sx, unsigned long lzone)\\r\\n{\\r\\nASN1_INTEGER *izone = NULL;\\r\\nASN1_OCTET_STRING *oct;\\r\\nif (!(izone = M_ASN1_INTEGER_new()) || !ASN1_INTEGER_set(izone, lzone)) {\\r\\nX509V3err(X509V3_F_SXNET_GET_ID_ULONG, ERR_R_MALLOC_FAILURE);\\r\\nM_ASN1_INTEGER_free(izone);\\r\\nreturn NULL;\\r\\n}\\r\\noct = SXNET_get_id_INTEGER(sx, izone);\\r\\nM_ASN1_INTEGER_free(izone);\\r\\nreturn oct;\\r\\n}\\r\\nASN1_OCTET_STRING *SXNET_get_id_INTEGER(SXNET *sx, ASN1_INTEGER *zone)\\r\\n{\\r\\nSXNETID *id;\\r\\nint i;\\r\\nfor (i = 0; i < sk_SXNETID_num(sx->ids); i++) {\\r\\nid = sk_SXNETID_value(sx->ids, i);\\r\\nif (!M_ASN1_INTEGER_cmp(id->zone, zone))\\r\\nreturn id->user;\\r\\n}\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_xts128_c", "target": 0, "func": "int CRYPTO_xts128_encrypt(const XTS128_CONTEXT *ctx,\\r\\nconst unsigned char iv[16],\\r\\nconst unsigned char *inp, unsigned char *out,\\r\\nsize_t len, int enc)\\r\\n{\\r\\nconst union {\\r\\nlong one;\\r\\nchar little;\\r\\n} is_endian = {\\r\\n1\\r\\n};\\r\\nunion {\\r\\nu64 u[2];\\r\\nu32 d[4];\\r\\nu8 c[16];\\r\\n} tweak, scratch;\\r\\nunsigned int i;\\r\\nif (len < 16)\\r\\nreturn -1;\\r\\nmemcpy(tweak.c, iv, 16);\\r\\n(*ctx->block2) (tweak.c, tweak.c, ctx->key2);\\r\\nif (!enc && (len % 16))\\r\\nlen -= 16;\\r\\nwhile (len >= 16) {\\r\\n#if defined(STRICT_ALIGNMENT)\\r\\nmemcpy(scratch.c, inp, 16);\\r\\nscratch.u[0] ^= tweak.u[0];\\r\\nscratch.u[1] ^= tweak.u[1];\\r\\n#else\\r\\nscratch.u[0] = ((u64 *)inp)[0] ^ tweak.u[0];\\r\\nscratch.u[1] = ((u64 *)inp)[1] ^ tweak.u[1];\\r\\n#endif\\r\\n(*ctx->block1) (scratch.c, scratch.c, ctx->key1);\\r\\n#if defined(STRICT_ALIGNMENT)\\r\\nscratch.u[0] ^= tweak.u[0];\\r\\nscratch.u[1] ^= tweak.u[1];\\r\\nmemcpy(out, scratch.c, 16);\\r\\n#else\\r\\n((u64 *)out)[0] = scratch.u[0] ^= tweak.u[0];\\r\\n((u64 *)out)[1] = scratch.u[1] ^= tweak.u[1];\\r\\n#endif\\r\\ninp += 16;\\r\\nout += 16;\\r\\nlen -= 16;\\r\\nif (len == 0)\\r\\nreturn 0;\\r\\nif (is_endian.little) {\\r\\nunsigned int carry, res;\\r\\nres = 0x87 & (((int)tweak.d[3]) >> 31);\\r\\ncarry = (unsigned int)(tweak.u[0] >> 63);\\r\\ntweak.u[0] = (tweak.u[0] << 1) ^ res;\\r\\ntweak.u[1] = (tweak.u[1] << 1) | carry;\\r\\n} else {\\r\\nsize_t c;\\r\\nfor (c = 0, i = 0; i < 16; ++i) {\\r\\nc += ((size_t)tweak.c[i]) << 1;\\r\\ntweak.c[i] = (u8)c;\\r\\nc = c >> 8;\\r\\n}\\r\\ntweak.c[0] ^= (u8)(0x87 & (0 - c));\\r\\n}\\r\\n}\\r\\nif (enc) {\\r\\nfor (i = 0; i < len; ++i) {\\r\\nu8 c = inp[i];\\r\\nout[i] = scratch.c[i];\\r\\nscratch.c[i] = c;\\r\\n}\\r\\nscratch.u[0] ^= tweak.u[0];\\r\\nscratch.u[1] ^= tweak.u[1];\\r\\n(*ctx->block1) (scratch.c, scratch.c, ctx->key1);\\r\\nscratch.u[0] ^= tweak.u[0];\\r\\nscratch.u[1] ^= tweak.u[1];\\r\\nmemcpy(out - 16, scratch.c, 16);\\r\\n} else {\\r\\nunion {\\r\\nu64 u[2];\\r\\nu8 c[16];\\r\\n} tweak1;\\r\\nif (is_endian.little) {\\r\\nunsigned int carry, res;\\r\\nres = 0x87 & (((int)tweak.d[3]) >> 31);\\r\\ncarry = (unsigned int)(tweak.u[0] >> 63);\\r\\ntweak1.u[0] = (tweak.u[0] << 1) ^ res;\\r\\ntweak1.u[1] = (tweak.u[1] << 1) | carry;\\r\\n} else {\\r\\nsize_t c;\\r\\nfor (c = 0, i = 0; i < 16; ++i) {\\r\\nc += ((size_t)tweak.c[i]) << 1;\\r\\ntweak1.c[i] = (u8)c;\\r\\nc = c >> 8;\\r\\n}\\r\\ntweak1.c[0] ^= (u8)(0x87 & (0 - c));\\r\\n}\\r\\n#if defined(STRICT_ALIGNMENT)\\r\\nmemcpy(scratch.c, inp, 16);\\r\\nscratch.u[0] ^= tweak1.u[0];\\r\\nscratch.u[1] ^= tweak1.u[1];\\r\\n#else\\r\\nscratch.u[0] = ((u64 *)inp)[0] ^ tweak1.u[0];\\r\\nscratch.u[1] = ((u64 *)inp)[1] ^ tweak1.u[1];\\r\\n#endif\\r\\n(*ctx->block1) (scratch.c, scratch.c, ctx->key1);\\r\\nscratch.u[0] ^= tweak1.u[0];\\r\\nscratch.u[1] ^= tweak1.u[1];\\r\\nfor (i = 0; i < len; ++i) {\\r\\nu8 c = inp[16 + i];\\r\\nout[16 + i] = scratch.c[i];\\r\\nscratch.c[i] = c;\\r\\n}\\r\\nscratch.u[0] ^= tweak.u[0];\\r\\nscratch.u[1] ^= tweak.u[1];\\r\\n(*ctx->block1) (scratch.c, scratch.c, ctx->key1);\\r\\n#if defined(STRICT_ALIGNMENT)\\r\\nscratch.u[0] ^= tweak.u[0];\\r\\nscratch.u[1] ^= tweak.u[1];\\r\\nmemcpy(out, scratch.c, 16);\\r\\n#else\\r\\n((u64 *)out)[0] = scratch.u[0] ^ tweak.u[0];\\r\\n((u64 *)out)[1] = scratch.u[1] ^ tweak.u[1];\\r\\n#endif\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc4_skey_c", "target": 0, "func": "const char *RC4_options(void)\\r\\n{\\r\\n#ifdef RC4_INDEX\\r\\nif (sizeof(RC4_INT) == 1)\\r\\nreturn (\"rc4(idx,char)\");\\r\\nelse\\r\\nreturn (\"rc4(idx,int)\");\\r\\n#else\\r\\nif (sizeof(RC4_INT) == 1)\\r\\nreturn (\"rc4(ptr,char)\");\\r\\nelse\\r\\nreturn (\"rc4(ptr,int)\");\\r\\n#endif\\r\\n}\\r\\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\\r\\n{\\r\\nregister RC4_INT tmp;\\r\\nregister int id1, id2;\\r\\nregister RC4_INT *d;\\r\\nunsigned int i;\\r\\nd = &(key->data[0]);\\r\\nkey->x = 0;\\r\\nkey->y = 0;\\r\\nid1 = id2 = 0;\\r\\n#define SK_LOOP(d,n) { \\\\r\\ntmp=d[(n)]; \\\\r\\nid2 = (data[id1] + tmp + id2) & 0xff; \\\\r\\nif (++id1 == len) id1=0; \\\\r\\nd[(n)]=d[id2]; \\\\r\\nd[id2]=tmp; }\\r\\nfor (i = 0; i < 256; i++)\\r\\nd[i] = i;\\r\\nfor (i = 0; i < 256; i += 4) {\\r\\nSK_LOOP(d, i + 0);\\r\\nSK_LOOP(d, i + 1);\\r\\nSK_LOOP(d, i + 2);\\r\\nSK_LOOP(d, i + 3);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_engine_c", "target": 0, "func": "static void identity(char *ptr)\\r\\n{\\r\\nreturn;\\r\\n}\\r\\nstatic int append_buf(char **buf, const char *s, int *size, int step)\\r\\n{\\r\\nint l = strlen(s);\\r\\nif (*buf == NULL) {\\r\\n*size = step;\\r\\n*buf = OPENSSL_malloc(*size);\\r\\nif (*buf == NULL)\\r\\nreturn 0;\\r\\n**buf = '\\0';\\r\\n}\\r\\nif (**buf != '\\0')\\r\\nl += 2;\\r\\nif (strlen(*buf) + strlen(s) >= (unsigned int)*size) {\\r\\n*size += step;\\r\\n*buf = OPENSSL_realloc(*buf, *size);\\r\\n}\\r\\nif (*buf == NULL)\\r\\nreturn 0;\\r\\nif (**buf != '\\0')\\r\\nBUF_strlcat(*buf, \", \", *size);\\r\\nBUF_strlcat(*buf, s, *size);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int util_flags(BIO *bio_out, unsigned int flags, const char *indent)\\r\\n{\\r\\nint started = 0, err = 0;\\r\\nBIO_printf(bio_out, \"%s%s(input flags): \", indent, indent);\\r\\nif (flags == 0) {\\r\\nBIO_printf(bio_out, \"<no flags>\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nif (flags & ENGINE_CMD_FLAG_INTERNAL) {\\r\\nBIO_printf(bio_out, \"[Internal] \");\\r\\n}\\r\\nif (flags & ENGINE_CMD_FLAG_NUMERIC) {\\r\\nBIO_printf(bio_out, \"NUMERIC\");\\r\\nstarted = 1;\\r\\n}\\r\\nif (flags & ENGINE_CMD_FLAG_STRING) {\\r\\nif (started) {\\r\\nBIO_printf(bio_out, \"|\");\\r\\nerr = 1;\\r\\n}\\r\\nBIO_printf(bio_out, \"STRING\");\\r\\nstarted = 1;\\r\\n}\\r\\nif (flags & ENGINE_CMD_FLAG_NO_INPUT) {\\r\\nif (started) {\\r\\nBIO_printf(bio_out, \"|\");\\r\\nerr = 1;\\r\\n}\\r\\nBIO_printf(bio_out, \"NO_INPUT\");\\r\\nstarted = 1;\\r\\n}\\r\\nflags = flags & ~ENGINE_CMD_FLAG_NUMERIC &\\r\\n~ENGINE_CMD_FLAG_STRING &\\r\\n~ENGINE_CMD_FLAG_NO_INPUT & ~ENGINE_CMD_FLAG_INTERNAL;\\r\\nif (flags) {\\r\\nif (started)\\r\\nBIO_printf(bio_out, \"|\");\\r\\nBIO_printf(bio_out, \"<0x%04X>\", flags);\\r\\n}\\r\\nif (err)\\r\\nBIO_printf(bio_out, \" <illegal flags!>\");\\r\\nBIO_printf(bio_out, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic int util_verbose(ENGINE *e, int verbose, BIO *bio_out,\\r\\nconst char *indent)\\r\\n{\\r\\nstatic const int line_wrap = 78;\\r\\nint num;\\r\\nint ret = 0;\\r\\nchar *name = NULL;\\r\\nchar *desc = NULL;\\r\\nint flags;\\r\\nint xpos = 0;\\r\\nSTACK_OF(OPENSSL_STRING) *cmds = NULL;\\r\\nif (!ENGINE_ctrl(e, ENGINE_CTRL_HAS_CTRL_FUNCTION, 0, NULL, NULL) ||\\r\\n((num = ENGINE_ctrl(e, ENGINE_CTRL_GET_FIRST_CMD_TYPE,\\r\\n0, NULL, NULL)) <= 0)) {\\r\\n# if 0\\r\\nBIO_printf(bio_out, \"%s<no control commands>\\n\", indent);\\r\\n# endif\\r\\nreturn 1;\\r\\n}\\r\\ncmds = sk_OPENSSL_STRING_new_null();\\r\\nif (!cmds)\\r\\ngoto err;\\r\\ndo {\\r\\nint len;\\r\\nif ((flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num,\\r\\nNULL, NULL)) < 0)\\r\\ngoto err;\\r\\nif (!(flags & ENGINE_CMD_FLAG_INTERNAL) || verbose >= 4) {\\r\\nif ((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_LEN_FROM_CMD, num,\\r\\nNULL, NULL)) <= 0)\\r\\ngoto err;\\r\\nif ((name = OPENSSL_malloc(len + 1)) == NULL)\\r\\ngoto err;\\r\\nif (ENGINE_ctrl(e, ENGINE_CTRL_GET_NAME_FROM_CMD, num, name,\\r\\nNULL) <= 0)\\r\\ngoto err;\\r\\nif ((len = ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_LEN_FROM_CMD, num,\\r\\nNULL, NULL)) < 0)\\r\\ngoto err;\\r\\nif (len > 0) {\\r\\nif ((desc = OPENSSL_malloc(len + 1)) == NULL)\\r\\ngoto err;\\r\\nif (ENGINE_ctrl(e, ENGINE_CTRL_GET_DESC_FROM_CMD, num, desc,\\r\\nNULL) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (xpos == 0)\\r\\nxpos = BIO_puts(bio_out, indent);\\r\\nelse\\r\\nxpos += BIO_printf(bio_out, \", \");\\r\\nif (verbose == 1) {\\r\\nif ((xpos > (int)strlen(indent)) &&\\r\\n(xpos + (int)strlen(name) > line_wrap)) {\\r\\nBIO_printf(bio_out, \"\\n\");\\r\\nxpos = BIO_puts(bio_out, indent);\\r\\n}\\r\\nxpos += BIO_printf(bio_out, \"%s\", name);\\r\\n} else {\\r\\nBIO_printf(bio_out, \"%s: %s\\n\", name,\\r\\n(desc == NULL) ? \"<no description>\" : desc);\\r\\nif ((verbose >= 3) && !util_flags(bio_out, flags, indent))\\r\\ngoto err;\\r\\nxpos = 0;\\r\\n}\\r\\n}\\r\\nOPENSSL_free(name);\\r\\nname = NULL;\\r\\nif (desc) {\\r\\nOPENSSL_free(desc);\\r\\ndesc = NULL;\\r\\n}\\r\\nnum = ENGINE_ctrl(e, ENGINE_CTRL_GET_NEXT_CMD_TYPE, num, NULL, NULL);\\r\\n} while (num > 0);\\r\\nif (xpos > 0)\\r\\nBIO_printf(bio_out, \"\\n\");\\r\\nret = 1;\\r\\nerr:\\r\\nif (cmds)\\r\\nsk_OPENSSL_STRING_pop_free(cmds, identity);\\r\\nif (name)\\r\\nOPENSSL_free(name);\\r\\nif (desc)\\r\\nOPENSSL_free(desc);\\r\\nreturn ret;\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret = 1, i;\\r\\nconst char **pp;\\r\\nint verbose = 0, list_cap = 0, test_avail = 0, test_avail_noise = 0;\\r\\nENGINE *e;\\r\\nSTACK_OF(OPENSSL_STRING) *engines = sk_OPENSSL_STRING_new_null();\\r\\nSTACK_OF(OPENSSL_STRING) *pre_cmds = sk_OPENSSL_STRING_new_null();\\r\\nSTACK_OF(OPENSSL_STRING) *post_cmds = sk_OPENSSL_STRING_new_null();\\r\\nint badops = 1;\\r\\nBIO *bio_out = NULL;\\r\\nconst char *indent = \" \";\\r\\napps_startup();\\r\\nSSL_load_error_strings();\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nbio_out = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nbio_out = BIO_push(tmpbio, bio_out);\\r\\n}\\r\\n# endif\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strncmp(*argv, \"-v\", 2) == 0) {\\r\\nif (strspn(*argv + 1, \"v\") < strlen(*argv + 1))\\r\\ngoto skip_arg_loop;\\r\\nif ((verbose = strlen(*argv + 1)) > 4)\\r\\ngoto skip_arg_loop;\\r\\n} else if (strcmp(*argv, \"-c\") == 0)\\r\\nlist_cap = 1;\\r\\nelse if (strncmp(*argv, \"-t\", 2) == 0) {\\r\\ntest_avail = 1;\\r\\nif (strspn(*argv + 1, \"t\") < strlen(*argv + 1))\\r\\ngoto skip_arg_loop;\\r\\nif ((test_avail_noise = strlen(*argv + 1) - 1) > 1)\\r\\ngoto skip_arg_loop;\\r\\n} else if (strcmp(*argv, \"-pre\") == 0) {\\r\\nargc--;\\r\\nargv++;\\r\\nif (argc == 0)\\r\\ngoto skip_arg_loop;\\r\\nsk_OPENSSL_STRING_push(pre_cmds, *argv);\\r\\n} else if (strcmp(*argv, \"-post\") == 0) {\\r\\nargc--;\\r\\nargv++;\\r\\nif (argc == 0)\\r\\ngoto skip_arg_loop;\\r\\nsk_OPENSSL_STRING_push(post_cmds, *argv);\\r\\n} else if ((strncmp(*argv, \"-h\", 2) == 0) ||\\r\\n(strcmp(*argv, \"-?\") == 0))\\r\\ngoto skip_arg_loop;\\r\\nelse\\r\\nsk_OPENSSL_STRING_push(engines, *argv);\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nbadops = 0;\\r\\nskip_arg_loop:\\r\\nif (badops) {\\r\\nfor (pp = engine_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err, \"%s\", *pp);\\r\\ngoto end;\\r\\n}\\r\\nif (sk_OPENSSL_STRING_num(engines) == 0) {\\r\\nfor (e = ENGINE_get_first(); e != NULL; e = ENGINE_get_next(e)) {\\r\\nsk_OPENSSL_STRING_push(engines, (char *)ENGINE_get_id(e));\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < sk_OPENSSL_STRING_num(engines); i++) {\\r\\nconst char *id = sk_OPENSSL_STRING_value(engines, i);\\r\\nif ((e = ENGINE_by_id(id)) != NULL) {\\r\\nconst char *name = ENGINE_get_name(e);\\r\\nBIO_printf(bio_out, \"(%s) %s\\n\", id, name);\\r\\nutil_do_cmds(e, pre_cmds, bio_out, indent);\\r\\nif (strcmp(ENGINE_get_id(e), id) != 0) {\\r\\nBIO_printf(bio_out, \"Loaded: (%s) %s\\n\",\\r\\nENGINE_get_id(e), ENGINE_get_name(e));\\r\\n}\\r\\nif (list_cap) {\\r\\nint cap_size = 256;\\r\\nchar *cap_buf = NULL;\\r\\nint k, n;\\r\\nconst int *nids;\\r\\nENGINE_CIPHERS_PTR fn_c;\\r\\nENGINE_DIGESTS_PTR fn_d;\\r\\nENGINE_PKEY_METHS_PTR fn_pk;\\r\\nif (ENGINE_get_RSA(e) != NULL\\r\\n&& !append_buf(&cap_buf, \"RSA\", &cap_size, 256))\\r\\ngoto end;\\r\\nif (ENGINE_get_DSA(e) != NULL\\r\\n&& !append_buf(&cap_buf, \"DSA\", &cap_size, 256))\\r\\ngoto end;\\r\\nif (ENGINE_get_DH(e) != NULL\\r\\n&& !append_buf(&cap_buf, \"DH\", &cap_size, 256))\\r\\ngoto end;\\r\\nif (ENGINE_get_RAND(e) != NULL\\r\\n&& !append_buf(&cap_buf, \"RAND\", &cap_size, 256))\\r\\ngoto end;\\r\\nfn_c = ENGINE_get_ciphers(e);\\r\\nif (!fn_c)\\r\\ngoto skip_ciphers;\\r\\nn = fn_c(e, NULL, &nids, 0);\\r\\nfor (k = 0; k < n; ++k)\\r\\nif (!append_buf(&cap_buf,\\r\\nOBJ_nid2sn(nids[k]), &cap_size, 256))\\r\\ngoto end;\\r\\nskip_ciphers:\\r\\nfn_d = ENGINE_get_digests(e);\\r\\nif (!fn_d)\\r\\ngoto skip_digests;\\r\\nn = fn_d(e, NULL, &nids, 0);\\r\\nfor (k = 0; k < n; ++k)\\r\\nif (!append_buf(&cap_buf,\\r\\nOBJ_nid2sn(nids[k]), &cap_size, 256))\\r\\ngoto end;\\r\\nskip_digests:\\r\\nfn_pk = ENGINE_get_pkey_meths(e);\\r\\nif (!fn_pk)\\r\\ngoto skip_pmeths;\\r\\nn = fn_pk(e, NULL, &nids, 0);\\r\\nfor (k = 0; k < n; ++k)\\r\\nif (!append_buf(&cap_buf,\\r\\nOBJ_nid2sn(nids[k]), &cap_size, 256))\\r\\ngoto end;\\r\\nskip_pmeths:\\r\\nif (cap_buf && (*cap_buf != '\\0'))\\r\\nBIO_printf(bio_out, \" [%s]\\n\", cap_buf);\\r\\nOPENSSL_free(cap_buf);\\r\\n}\\r\\nif (test_avail) {\\r\\nBIO_printf(bio_out, \"%s\", indent);\\r\\nif (ENGINE_init(e)) {\\r\\nBIO_printf(bio_out, \"[ available ]\\n\");\\r\\nutil_do_cmds(e, post_cmds, bio_out, indent);\\r\\nENGINE_finish(e);\\r\\n} else {\\r\\nBIO_printf(bio_out, \"[ unavailable ]\\n\");\\r\\nif (test_avail_noise)\\r\\nERR_print_errors_fp(stdout);\\r\\nERR_clear_error();\\r\\n}\\r\\n}\\r\\nif ((verbose > 0) && !util_verbose(e, verbose, bio_out, indent))\\r\\ngoto end;\\r\\nENGINE_free(e);\\r\\n} else\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nERR_print_errors(bio_err);\\r\\nsk_OPENSSL_STRING_pop_free(engines, identity);\\r\\nsk_OPENSSL_STRING_pop_free(pre_cmds, identity);\\r\\nsk_OPENSSL_STRING_pop_free(post_cmds, identity);\\r\\nif (bio_out != NULL)\\r\\nBIO_free_all(bio_out);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_mem_clr_c", "target": 0, "func": "void OPENSSL_cleanse(void *ptr, size_t len)\\r\\n{\\r\\nunsigned char *p = ptr;\\r\\nsize_t loop = len, ctr = cleanse_ctr;\\r\\nwhile (loop--) {\\r\\n*(p++) = (unsigned char)ctr;\\r\\nctr += (17 + ((size_t)p & 0xF));\\r\\n}\\r\\np = memchr(ptr, (unsigned char)ctr, len);\\r\\nif (p)\\r\\nctr += (63 + (size_t)p);\\r\\ncleanse_ctr = (unsigned char)ctr;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_cryptodev_c", "target": 0, "func": "void ENGINE_load_cryptodev(void)\\r\\n{\\r\\nreturn;\\r\\n}\\r\\nstatic int open_dev_crypto(void)\\r\\n{\\r\\nstatic int fd = -1;\\r\\nif (fd == -1) {\\r\\nif ((fd = open(\"/dev/crypto\", O_RDWR, 0)) == -1)\\r\\nreturn (-1);\\r\\nif (fcntl(fd, F_SETFD, 1) == -1) {\\r\\nclose(fd);\\r\\nfd = -1;\\r\\nreturn (-1);\\r\\n}\\r\\n}\\r\\nreturn (fd);\\r\\n}\\r\\nstatic int get_dev_crypto(void)\\r\\n{\\r\\nint fd, retfd;\\r\\nif ((fd = open_dev_crypto()) == -1)\\r\\nreturn (-1);\\r\\n# ifndef CRIOGET_NOT_NEEDED\\r\\nif (ioctl(fd, CRIOGET, &retfd) == -1)\\r\\nreturn (-1);\\r\\nif (fcntl(retfd, F_SETFD, 1) == -1) {\\r\\nclose(retfd);\\r\\nreturn (-1);\\r\\n}\\r\\n# else\\r\\nretfd = fd;\\r\\n# endif\\r\\nreturn (retfd);\\r\\n}\\r\\nstatic void put_dev_crypto(int fd)\\r\\n{\\r\\n# ifndef CRIOGET_NOT_NEEDED\\r\\nclose(fd);\\r\\n# endif\\r\\n}\\r\\nstatic int get_asym_dev_crypto(void)\\r\\n{\\r\\nstatic int fd = -1;\\r\\nif (fd == -1)\\r\\nfd = get_dev_crypto();\\r\\nreturn fd;\\r\\n}\\r\\nstatic int get_cryptodev_ciphers(const int **cnids)\\r\\n{\\r\\nstatic int nids[CRYPTO_ALGORITHM_MAX];\\r\\nstruct session_op sess;\\r\\nint fd, i, count = 0;\\r\\nif ((fd = get_dev_crypto()) < 0) {\\r\\n*cnids = NULL;\\r\\nreturn (0);\\r\\n}\\r\\nmemset(&sess, 0, sizeof(sess));\\r\\nsess.key = (caddr_t) \"123456789abcdefghijklmno\";\\r\\nfor (i = 0; ciphers[i].id && count < CRYPTO_ALGORITHM_MAX; i++) {\\r\\nif (ciphers[i].nid == NID_undef)\\r\\ncontinue;\\r\\nsess.cipher = ciphers[i].id;\\r\\nsess.keylen = ciphers[i].keylen;\\r\\nsess.mac = 0;\\r\\nif (ioctl(fd, CIOCGSESSION, &sess) != -1 &&\\r\\nioctl(fd, CIOCFSESSION, &sess.ses) != -1)\\r\\nnids[count++] = ciphers[i].nid;\\r\\n}\\r\\nput_dev_crypto(fd);\\r\\nif (count > 0)\\r\\n*cnids = nids;\\r\\nelse\\r\\n*cnids = NULL;\\r\\nreturn (count);\\r\\n}\\r\\nstatic int get_cryptodev_digests(const int **cnids)\\r\\n{\\r\\nstatic int nids[CRYPTO_ALGORITHM_MAX];\\r\\nstruct session_op sess;\\r\\nint fd, i, count = 0;\\r\\nif ((fd = get_dev_crypto()) < 0) {\\r\\n*cnids = NULL;\\r\\nreturn (0);\\r\\n}\\r\\nmemset(&sess, 0, sizeof(sess));\\r\\nsess.mackey = (caddr_t) \"123456789abcdefghijklmno\";\\r\\nfor (i = 0; digests[i].id && count < CRYPTO_ALGORITHM_MAX; i++) {\\r\\nif (digests[i].nid == NID_undef)\\r\\ncontinue;\\r\\nsess.mac = digests[i].id;\\r\\nsess.mackeylen = digests[i].keylen;\\r\\nsess.cipher = 0;\\r\\nif (ioctl(fd, CIOCGSESSION, &sess) != -1 &&\\r\\nioctl(fd, CIOCFSESSION, &sess.ses) != -1)\\r\\nnids[count++] = digests[i].nid;\\r\\n}\\r\\nput_dev_crypto(fd);\\r\\nif (count > 0)\\r\\n*cnids = nids;\\r\\nelse\\r\\n*cnids = NULL;\\r\\nreturn (count);\\r\\n}\\r\\nstatic int cryptodev_usable_ciphers(const int **nids)\\r\\n{\\r\\nreturn (get_cryptodev_ciphers(nids));\\r\\n}\\r\\nstatic int cryptodev_usable_digests(const int **nids)\\r\\n{\\r\\n# ifdef USE_CRYPTODEV_DIGESTS\\r\\nreturn (get_cryptodev_digests(nids));\\r\\n# else\\r\\n*nids = NULL;\\r\\nreturn (0);\\r\\n# endif\\r\\n}\\r\\nstatic int\\r\\ncryptodev_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nstruct crypt_op cryp;\\r\\nstruct dev_crypto_state *state = ctx->cipher_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nconst void *iiv;\\r\\nunsigned char save_iv[EVP_MAX_IV_LENGTH];\\r\\nif (state->d_fd < 0)\\r\\nreturn (0);\\r\\nif (!inl)\\r\\nreturn (1);\\r\\nif ((inl % ctx->cipher->block_size) != 0)\\r\\nreturn (0);\\r\\nmemset(&cryp, 0, sizeof(cryp));\\r\\ncryp.ses = sess->ses;\\r\\ncryp.flags = 0;\\r\\ncryp.len = inl;\\r\\ncryp.src = (caddr_t) in;\\r\\ncryp.dst = (caddr_t) out;\\r\\ncryp.mac = 0;\\r\\ncryp.op = ctx->encrypt ? COP_ENCRYPT : COP_DECRYPT;\\r\\nif (ctx->cipher->iv_len) {\\r\\ncryp.iv = (caddr_t) ctx->iv;\\r\\nif (!ctx->encrypt) {\\r\\niiv = in + inl - ctx->cipher->iv_len;\\r\\nmemcpy(save_iv, iiv, ctx->cipher->iv_len);\\r\\n}\\r\\n} else\\r\\ncryp.iv = NULL;\\r\\nif (ioctl(state->d_fd, CIOCCRYPT, &cryp) == -1) {\\r\\nreturn (0);\\r\\n}\\r\\nif (ctx->cipher->iv_len) {\\r\\nif (ctx->encrypt)\\r\\niiv = out + inl - ctx->cipher->iv_len;\\r\\nelse\\r\\niiv = save_iv;\\r\\nmemcpy(ctx->iv, iiv, ctx->cipher->iv_len);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nstruct dev_crypto_state *state = ctx->cipher_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nint cipher = -1, i;\\r\\nfor (i = 0; ciphers[i].id; i++)\\r\\nif (ctx->cipher->nid == ciphers[i].nid &&\\r\\nctx->cipher->iv_len <= ciphers[i].ivmax &&\\r\\nctx->key_len == ciphers[i].keylen) {\\r\\ncipher = ciphers[i].id;\\r\\nbreak;\\r\\n}\\r\\nif (!ciphers[i].id) {\\r\\nstate->d_fd = -1;\\r\\nreturn (0);\\r\\n}\\r\\nmemset(sess, 0, sizeof(struct session_op));\\r\\nif ((state->d_fd = get_dev_crypto()) < 0)\\r\\nreturn (0);\\r\\nsess->key = (caddr_t) key;\\r\\nsess->keylen = ctx->key_len;\\r\\nsess->cipher = cipher;\\r\\nif (ioctl(state->d_fd, CIOCGSESSION, sess) == -1) {\\r\\nput_dev_crypto(state->d_fd);\\r\\nstate->d_fd = -1;\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int cryptodev_cleanup(EVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nstruct dev_crypto_state *state = ctx->cipher_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nif (state->d_fd < 0)\\r\\nreturn (0);\\r\\nif (ioctl(state->d_fd, CIOCFSESSION, &sess->ses) == -1) {\\r\\nret = 0;\\r\\n} else {\\r\\nret = 1;\\r\\n}\\r\\nput_dev_crypto(state->d_fd);\\r\\nstate->d_fd = -1;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_engine_ciphers(ENGINE *e, const EVP_CIPHER **cipher,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nif (!cipher)\\r\\nreturn (cryptodev_usable_ciphers(nids));\\r\\nswitch (nid) {\\r\\ncase NID_rc4:\\r\\n*cipher = &cryptodev_rc4;\\r\\nbreak;\\r\\ncase NID_des_ede3_cbc:\\r\\n*cipher = &cryptodev_3des_cbc;\\r\\nbreak;\\r\\ncase NID_des_cbc:\\r\\n*cipher = &cryptodev_des_cbc;\\r\\nbreak;\\r\\ncase NID_bf_cbc:\\r\\n*cipher = &cryptodev_bf_cbc;\\r\\nbreak;\\r\\ncase NID_cast5_cbc:\\r\\n*cipher = &cryptodev_cast_cbc;\\r\\nbreak;\\r\\ncase NID_aes_128_cbc:\\r\\n*cipher = &cryptodev_aes_cbc;\\r\\nbreak;\\r\\ncase NID_aes_192_cbc:\\r\\n*cipher = &cryptodev_aes_192_cbc;\\r\\nbreak;\\r\\ncase NID_aes_256_cbc:\\r\\n*cipher = &cryptodev_aes_256_cbc;\\r\\nbreak;\\r\\n# ifdef CRYPTO_AES_CTR\\r\\ncase NID_aes_128_ctr:\\r\\n*cipher = &cryptodev_aes_ctr;\\r\\nbreak;\\r\\ncase NID_aes_192_ctr:\\r\\n*cipher = &cryptodev_aes_ctr_192;\\r\\nbreak;\\r\\ncase NID_aes_256_ctr:\\r\\n*cipher = &cryptodev_aes_ctr_256;\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\n*cipher = NULL;\\r\\nbreak;\\r\\n}\\r\\nreturn (*cipher != NULL);\\r\\n}\\r\\nstatic int digest_nid_to_cryptodev(int nid)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; digests[i].id; i++)\\r\\nif (digests[i].nid == nid)\\r\\nreturn (digests[i].id);\\r\\nreturn (0);\\r\\n}\\r\\nstatic int digest_key_length(int nid)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; digests[i].id; i++)\\r\\nif (digests[i].nid == nid)\\r\\nreturn digests[i].keylen;\\r\\nreturn (0);\\r\\n}\\r\\nstatic int cryptodev_digest_init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nstruct dev_crypto_state *state = ctx->md_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nint digest;\\r\\nif ((digest = digest_nid_to_cryptodev(ctx->digest->type)) == NID_undef) {\\r\\nprintf(\"cryptodev_digest_init: Can't get digest \\n\");\\r\\nreturn (0);\\r\\n}\\r\\nmemset(state, 0, sizeof(struct dev_crypto_state));\\r\\nif ((state->d_fd = get_dev_crypto()) < 0) {\\r\\nprintf(\"cryptodev_digest_init: Can't get Dev \\n\");\\r\\nreturn (0);\\r\\n}\\r\\nsess->mackey = state->dummy_mac_key;\\r\\nsess->mackeylen = digest_key_length(ctx->digest->type);\\r\\nsess->mac = digest;\\r\\nif (ioctl(state->d_fd, CIOCGSESSION, sess) < 0) {\\r\\nput_dev_crypto(state->d_fd);\\r\\nstate->d_fd = -1;\\r\\nprintf(\"cryptodev_digest_init: Open session failed\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int cryptodev_digest_update(EVP_MD_CTX *ctx, const void *data,\\r\\nsize_t count)\\r\\n{\\r\\nstruct crypt_op cryp;\\r\\nstruct dev_crypto_state *state = ctx->md_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nif (!data || state->d_fd < 0) {\\r\\nprintf(\"cryptodev_digest_update: illegal inputs \\n\");\\r\\nreturn (0);\\r\\n}\\r\\nif (!count) {\\r\\nreturn (0);\\r\\n}\\r\\nif (!(ctx->flags & EVP_MD_CTX_FLAG_ONESHOT)) {\\r\\nstate->mac_data =\\r\\nOPENSSL_realloc(state->mac_data, state->mac_len + count);\\r\\nif (!state->mac_data) {\\r\\nprintf(\"cryptodev_digest_update: realloc failed\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nmemcpy(state->mac_data + state->mac_len, data, count);\\r\\nstate->mac_len += count;\\r\\nreturn (1);\\r\\n}\\r\\nmemset(&cryp, 0, sizeof(cryp));\\r\\ncryp.ses = sess->ses;\\r\\ncryp.flags = 0;\\r\\ncryp.len = count;\\r\\ncryp.src = (caddr_t) data;\\r\\ncryp.dst = NULL;\\r\\ncryp.mac = (caddr_t) state->digest_res;\\r\\nif (ioctl(state->d_fd, CIOCCRYPT, &cryp) < 0) {\\r\\nprintf(\"cryptodev_digest_update: digest failed\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int cryptodev_digest_final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nstruct crypt_op cryp;\\r\\nstruct dev_crypto_state *state = ctx->md_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nint ret = 1;\\r\\nif (!md || state->d_fd < 0) {\\r\\nprintf(\"cryptodev_digest_final: illegal input\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nif (!(ctx->flags & EVP_MD_CTX_FLAG_ONESHOT)) {\\r\\nmemset(&cryp, 0, sizeof(cryp));\\r\\ncryp.ses = sess->ses;\\r\\ncryp.flags = 0;\\r\\ncryp.len = state->mac_len;\\r\\ncryp.src = state->mac_data;\\r\\ncryp.dst = NULL;\\r\\ncryp.mac = (caddr_t) md;\\r\\nif (ioctl(state->d_fd, CIOCCRYPT, &cryp) < 0) {\\r\\nprintf(\"cryptodev_digest_final: digest failed\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nmemcpy(md, state->digest_res, ctx->digest->md_size);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int cryptodev_digest_cleanup(EVP_MD_CTX *ctx)\\r\\n{\\r\\nint ret = 1;\\r\\nstruct dev_crypto_state *state = ctx->md_data;\\r\\nstruct session_op *sess = &state->d_sess;\\r\\nif (state == NULL)\\r\\nreturn 0;\\r\\nif (state->d_fd < 0) {\\r\\nprintf(\"cryptodev_digest_cleanup: illegal input\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nif (state->mac_data) {\\r\\nOPENSSL_free(state->mac_data);\\r\\nstate->mac_data = NULL;\\r\\nstate->mac_len = 0;\\r\\n}\\r\\nif (ioctl(state->d_fd, CIOCFSESSION, &sess->ses) < 0) {\\r\\nprintf(\"cryptodev_digest_cleanup: failed to close session\\n\");\\r\\nret = 0;\\r\\n} else {\\r\\nret = 1;\\r\\n}\\r\\nput_dev_crypto(state->d_fd);\\r\\nstate->d_fd = -1;\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int cryptodev_digest_copy(EVP_MD_CTX *to, const EVP_MD_CTX *from)\\r\\n{\\r\\nstruct dev_crypto_state *fstate = from->md_data;\\r\\nstruct dev_crypto_state *dstate = to->md_data;\\r\\nstruct session_op *sess;\\r\\nint digest;\\r\\nif (dstate == NULL || fstate == NULL)\\r\\nreturn 1;\\r\\nmemcpy(dstate, fstate, sizeof(struct dev_crypto_state));\\r\\nsess = &dstate->d_sess;\\r\\ndigest = digest_nid_to_cryptodev(to->digest->type);\\r\\nsess->mackey = dstate->dummy_mac_key;\\r\\nsess->mackeylen = digest_key_length(to->digest->type);\\r\\nsess->mac = digest;\\r\\ndstate->d_fd = get_dev_crypto();\\r\\nif (ioctl(dstate->d_fd, CIOCGSESSION, sess) < 0) {\\r\\nput_dev_crypto(dstate->d_fd);\\r\\ndstate->d_fd = -1;\\r\\nprintf(\"cryptodev_digest_init: Open session failed\\n\");\\r\\nreturn (0);\\r\\n}\\r\\nif (fstate->mac_len != 0) {\\r\\nif (fstate->mac_data != NULL) {\\r\\ndstate->mac_data = OPENSSL_malloc(fstate->mac_len);\\r\\nmemcpy(dstate->mac_data, fstate->mac_data, fstate->mac_len);\\r\\ndstate->mac_len = fstate->mac_len;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int\\r\\ncryptodev_engine_digests(ENGINE *e, const EVP_MD **digest,\\r\\nconst int **nids, int nid)\\r\\n{\\r\\nif (!digest)\\r\\nreturn (cryptodev_usable_digests(nids));\\r\\nswitch (nid) {\\r\\n# ifdef USE_CRYPTODEV_DIGESTS\\r\\ncase NID_md5:\\r\\n*digest = &cryptodev_md5;\\r\\nbreak;\\r\\ncase NID_sha1:\\r\\n*digest = &cryptodev_sha1;\\r\\nbreak;\\r\\ndefault:\\r\\n# endif\\r\\n*digest = NULL;\\r\\nbreak;\\r\\n}\\r\\nreturn (*digest != NULL);\\r\\n}\\r\\nstatic int bn2crparam(const BIGNUM *a, struct crparam *crp)\\r\\n{\\r\\nint i, j, k;\\r\\nssize_t bytes, bits;\\r\\nu_char *b;\\r\\ncrp->crp_p = NULL;\\r\\ncrp->crp_nbits = 0;\\r\\nbits = BN_num_bits(a);\\r\\nbytes = (bits + 7) / 8;\\r\\nb = malloc(bytes);\\r\\nif (b == NULL)\\r\\nreturn (1);\\r\\nmemset(b, 0, bytes);\\r\\ncrp->crp_p = (caddr_t) b;\\r\\ncrp->crp_nbits = bits;\\r\\nfor (i = 0, j = 0; i < a->top; i++) {\\r\\nfor (k = 0; k < BN_BITS2 / 8; k++) {\\r\\nif ((j + k) >= bytes)\\r\\nreturn (0);\\r\\nb[j + k] = a->d[i] >> (k * 8);\\r\\n}\\r\\nj += BN_BITS2 / 8;\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nstatic int crparam2bn(struct crparam *crp, BIGNUM *a)\\r\\n{\\r\\nu_int8_t *pd;\\r\\nint i, bytes;\\r\\nbytes = (crp->crp_nbits + 7) / 8;\\r\\nif (bytes == 0)\\r\\nreturn (-1);\\r\\nif ((pd = (u_int8_t *) malloc(bytes)) == NULL)\\r\\nreturn (-1);\\r\\nfor (i = 0; i < bytes; i++)\\r\\npd[i] = crp->crp_p[bytes - i - 1];\\r\\nBN_bin2bn(pd, bytes, a);\\r\\nfree(pd);\\r\\nreturn (0);\\r\\n}\\r\\nstatic void zapparams(struct crypt_kop *kop)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < kop->crk_iparams + kop->crk_oparams; i++) {\\r\\nif (kop->crk_param[i].crp_p)\\r\\nfree(kop->crk_param[i].crp_p);\\r\\nkop->crk_param[i].crp_p = NULL;\\r\\nkop->crk_param[i].crp_nbits = 0;\\r\\n}\\r\\n}\\r\\nstatic int\\r\\ncryptodev_asym(struct crypt_kop *kop, int rlen, BIGNUM *r, int slen,\\r\\nBIGNUM *s)\\r\\n{\\r\\nint fd, ret = -1;\\r\\nif ((fd = get_asym_dev_crypto()) < 0)\\r\\nreturn (ret);\\r\\nif (r) {\\r\\nkop->crk_param[kop->crk_iparams].crp_p = calloc(rlen, sizeof(char));\\r\\nkop->crk_param[kop->crk_iparams].crp_nbits = rlen * 8;\\r\\nkop->crk_oparams++;\\r\\n}\\r\\nif (s) {\\r\\nkop->crk_param[kop->crk_iparams + 1].crp_p =\\r\\ncalloc(slen, sizeof(char));\\r\\nkop->crk_param[kop->crk_iparams + 1].crp_nbits = slen * 8;\\r\\nkop->crk_oparams++;\\r\\n}\\r\\nif (ioctl(fd, CIOCKEY, kop) == 0) {\\r\\nif (r)\\r\\ncrparam2bn(&kop->crk_param[kop->crk_iparams], r);\\r\\nif (s)\\r\\ncrparam2bn(&kop->crk_param[kop->crk_iparams + 1], s);\\r\\nret = 0;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_bn_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nint ret = 1;\\r\\nif (cryptodev_asymfeat == 0) {\\r\\nret = BN_mod_exp(r, a, p, m, ctx);\\r\\nreturn (ret);\\r\\n}\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_MOD_EXP;\\r\\nif (bn2crparam(a, &kop.crk_param[0]))\\r\\ngoto err;\\r\\nif (bn2crparam(p, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(m, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 3;\\r\\nif (cryptodev_asym(&kop, BN_num_bytes(m), r, 0, NULL)) {\\r\\nconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\\r\\nprintf(\"OCF asym process failed, Running in software\\n\");\\r\\nret = meth->bn_mod_exp(r, a, p, m, ctx, in_mont);\\r\\n} else if (ECANCELED == kop.crk_status) {\\r\\nconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\\r\\nprintf(\"OCF hardware operation cancelled. Running in Software\\n\");\\r\\nret = meth->bn_mod_exp(r, a, p, m, ctx, in_mont);\\r\\n}\\r\\nerr:\\r\\nzapparams(&kop);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_rsa_nocrt_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint r;\\r\\nctx = BN_CTX_new();\\r\\nr = cryptodev_bn_mod_exp(r0, I, rsa->d, rsa->n, ctx, NULL);\\r\\nBN_CTX_free(ctx);\\r\\nreturn (r);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nint ret = 1;\\r\\nif (!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp) {\\r\\nreturn (0);\\r\\n}\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_MOD_EXP_CRT;\\r\\nif (bn2crparam(rsa->p, &kop.crk_param[0]))\\r\\ngoto err;\\r\\nif (bn2crparam(rsa->q, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(I, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nif (bn2crparam(rsa->dmp1, &kop.crk_param[3]))\\r\\ngoto err;\\r\\nif (bn2crparam(rsa->dmq1, &kop.crk_param[4]))\\r\\ngoto err;\\r\\nif (bn2crparam(rsa->iqmp, &kop.crk_param[5]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 6;\\r\\nif (cryptodev_asym(&kop, BN_num_bytes(rsa->n), r0, 0, NULL)) {\\r\\nconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\\r\\nprintf(\"OCF asym process failed, running in Software\\n\");\\r\\nret = (*meth->rsa_mod_exp) (r0, I, rsa, ctx);\\r\\n} else if (ECANCELED == kop.crk_status) {\\r\\nconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\\r\\nprintf(\"OCF hardware operation cancelled. Running in Software\\n\");\\r\\nret = (*meth->rsa_mod_exp) (r0, I, rsa, ctx);\\r\\n}\\r\\nerr:\\r\\nzapparams(&kop);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_dsa_bn_mod_exp(DSA *dsa, BIGNUM *r, BIGNUM *a, const BIGNUM *p,\\r\\nconst BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn (cryptodev_bn_mod_exp(r, a, p, m, ctx, m_ctx));\\r\\n}\\r\\nstatic int\\r\\ncryptodev_dsa_dsa_mod_exp(DSA *dsa, BIGNUM *t1, BIGNUM *g,\\r\\nBIGNUM *u1, BIGNUM *pub_key, BIGNUM *u2, BIGNUM *p,\\r\\nBN_CTX *ctx, BN_MONT_CTX *mont)\\r\\n{\\r\\nBIGNUM t2;\\r\\nint ret = 0;\\r\\nBN_init(&t2);\\r\\nret = 0;\\r\\nif (!dsa->meth->bn_mod_exp(dsa, t1, dsa->g, u1, dsa->p, ctx, mont))\\r\\ngoto err;\\r\\nif (!dsa->meth->bn_mod_exp(dsa, &t2, dsa->pub_key, u2, dsa->p, ctx, mont))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(u1, t1, &t2, dsa->p, ctx))\\r\\ngoto err;\\r\\nBN_copy(t1, u1);\\r\\nret = 1;\\r\\nerr:\\r\\nBN_free(&t2);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic DSA_SIG *cryptodev_dsa_do_sign(const unsigned char *dgst, int dlen,\\r\\nDSA *dsa)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nBIGNUM *r = NULL, *s = NULL;\\r\\nDSA_SIG *dsaret = NULL;\\r\\nif ((r = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif ((s = BN_new()) == NULL) {\\r\\nBN_free(r);\\r\\ngoto err;\\r\\n}\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_DSA_SIGN;\\r\\nkop.crk_param[0].crp_p = (caddr_t) dgst;\\r\\nkop.crk_param[0].crp_nbits = dlen * 8;\\r\\nif (bn2crparam(dsa->p, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->q, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->g, &kop.crk_param[3]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->priv_key, &kop.crk_param[4]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 5;\\r\\nif (cryptodev_asym(&kop, BN_num_bytes(dsa->q), r,\\r\\nBN_num_bytes(dsa->q), s) == 0) {\\r\\ndsaret = DSA_SIG_new();\\r\\ndsaret->r = r;\\r\\ndsaret->s = s;\\r\\n} else {\\r\\nconst DSA_METHOD *meth = DSA_OpenSSL();\\r\\nBN_free(r);\\r\\nBN_free(s);\\r\\ndsaret = (meth->dsa_do_sign) (dgst, dlen, dsa);\\r\\n}\\r\\nerr:\\r\\nkop.crk_param[0].crp_p = NULL;\\r\\nzapparams(&kop);\\r\\nreturn (dsaret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_dsa_verify(const unsigned char *dgst, int dlen,\\r\\nDSA_SIG *sig, DSA *dsa)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nint dsaret = 1;\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_DSA_VERIFY;\\r\\nkop.crk_param[0].crp_p = (caddr_t) dgst;\\r\\nkop.crk_param[0].crp_nbits = dlen * 8;\\r\\nif (bn2crparam(dsa->p, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->q, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->g, &kop.crk_param[3]))\\r\\ngoto err;\\r\\nif (bn2crparam(dsa->pub_key, &kop.crk_param[4]))\\r\\ngoto err;\\r\\nif (bn2crparam(sig->r, &kop.crk_param[5]))\\r\\ngoto err;\\r\\nif (bn2crparam(sig->s, &kop.crk_param[6]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 7;\\r\\nif (cryptodev_asym(&kop, 0, NULL, 0, NULL) == 0) {\\r\\nif (0 != kop.crk_status)\\r\\ndsaret = 0;\\r\\n} else {\\r\\nconst DSA_METHOD *meth = DSA_OpenSSL();\\r\\ndsaret = (meth->dsa_do_verify) (dgst, dlen, sig, dsa);\\r\\n}\\r\\nerr:\\r\\nkop.crk_param[0].crp_p = NULL;\\r\\nzapparams(&kop);\\r\\nreturn (dsaret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_mod_exp_dh(const DH *dh, BIGNUM *r, const BIGNUM *a,\\r\\nconst BIGNUM *p, const BIGNUM *m, BN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nreturn (cryptodev_bn_mod_exp(r, a, p, m, ctx, m_ctx));\\r\\n}\\r\\nstatic int\\r\\ncryptodev_dh_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh)\\r\\n{\\r\\nstruct crypt_kop kop;\\r\\nint dhret = 1;\\r\\nint fd, keylen;\\r\\nif ((fd = get_asym_dev_crypto()) < 0) {\\r\\nconst DH_METHOD *meth = DH_OpenSSL();\\r\\nreturn ((meth->compute_key) (key, pub_key, dh));\\r\\n}\\r\\nkeylen = BN_num_bits(dh->p);\\r\\nmemset(&kop, 0, sizeof kop);\\r\\nkop.crk_op = CRK_DH_COMPUTE_KEY;\\r\\nif (bn2crparam(dh->priv_key, &kop.crk_param[0]))\\r\\ngoto err;\\r\\nif (bn2crparam(pub_key, &kop.crk_param[1]))\\r\\ngoto err;\\r\\nif (bn2crparam(dh->p, &kop.crk_param[2]))\\r\\ngoto err;\\r\\nkop.crk_iparams = 3;\\r\\nkop.crk_param[3].crp_p = (caddr_t) key;\\r\\nkop.crk_param[3].crp_nbits = keylen * 8;\\r\\nkop.crk_oparams = 1;\\r\\nif (ioctl(fd, CIOCKEY, &kop) == -1) {\\r\\nconst DH_METHOD *meth = DH_OpenSSL();\\r\\ndhret = (meth->compute_key) (key, pub_key, dh);\\r\\n}\\r\\nerr:\\r\\nkop.crk_param[3].crp_p = NULL;\\r\\nzapparams(&kop);\\r\\nreturn (dhret);\\r\\n}\\r\\nstatic int\\r\\ncryptodev_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))\\r\\n{\\r\\n# ifdef HAVE_SYSLOG_R\\r\\nstruct syslog_data sd = SYSLOG_DATA_INIT;\\r\\n# endif\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\n# ifdef HAVE_SYSLOG_R\\r\\nsyslog_r(LOG_ERR, &sd, \"cryptodev_ctrl: unknown command %d\", cmd);\\r\\n# else\\r\\nsyslog(LOG_ERR, \"cryptodev_ctrl: unknown command %d\", cmd);\\r\\n# endif\\r\\nbreak;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nvoid ENGINE_load_cryptodev(void)\\r\\n{\\r\\nENGINE *engine = ENGINE_new();\\r\\nint fd;\\r\\nif (engine == NULL)\\r\\nreturn;\\r\\nif ((fd = get_dev_crypto()) < 0) {\\r\\nENGINE_free(engine);\\r\\nreturn;\\r\\n}\\r\\nif (ioctl(fd, CIOCASYMFEAT, &cryptodev_asymfeat) == -1) {\\r\\nput_dev_crypto(fd);\\r\\nENGINE_free(engine);\\r\\nreturn;\\r\\n}\\r\\nput_dev_crypto(fd);\\r\\nif (!ENGINE_set_id(engine, \"cryptodev\") ||\\r\\n!ENGINE_set_name(engine, \"BSD cryptodev engine\") ||\\r\\n!ENGINE_set_ciphers(engine, cryptodev_engine_ciphers) ||\\r\\n!ENGINE_set_digests(engine, cryptodev_engine_digests) ||\\r\\n!ENGINE_set_ctrl_function(engine, cryptodev_ctrl) ||\\r\\n!ENGINE_set_cmd_defns(engine, cryptodev_defns)) {\\r\\nENGINE_free(engine);\\r\\nreturn;\\r\\n}\\r\\nif (ENGINE_set_RSA(engine, &cryptodev_rsa)) {\\r\\nconst RSA_METHOD *rsa_meth = RSA_PKCS1_SSLeay();\\r\\ncryptodev_rsa.bn_mod_exp = rsa_meth->bn_mod_exp;\\r\\ncryptodev_rsa.rsa_mod_exp = rsa_meth->rsa_mod_exp;\\r\\ncryptodev_rsa.rsa_pub_enc = rsa_meth->rsa_pub_enc;\\r\\ncryptodev_rsa.rsa_pub_dec = rsa_meth->rsa_pub_dec;\\r\\ncryptodev_rsa.rsa_priv_enc = rsa_meth->rsa_priv_enc;\\r\\ncryptodev_rsa.rsa_priv_dec = rsa_meth->rsa_priv_dec;\\r\\nif (cryptodev_asymfeat & CRF_MOD_EXP) {\\r\\ncryptodev_rsa.bn_mod_exp = cryptodev_bn_mod_exp;\\r\\nif (cryptodev_asymfeat & CRF_MOD_EXP_CRT)\\r\\ncryptodev_rsa.rsa_mod_exp = cryptodev_rsa_mod_exp;\\r\\nelse\\r\\ncryptodev_rsa.rsa_mod_exp = cryptodev_rsa_nocrt_mod_exp;\\r\\n}\\r\\n}\\r\\nif (ENGINE_set_DSA(engine, &cryptodev_dsa)) {\\r\\nconst DSA_METHOD *meth = DSA_OpenSSL();\\r\\nmemcpy(&cryptodev_dsa, meth, sizeof(DSA_METHOD));\\r\\nif (cryptodev_asymfeat & CRF_DSA_SIGN)\\r\\ncryptodev_dsa.dsa_do_sign = cryptodev_dsa_do_sign;\\r\\nif (cryptodev_asymfeat & CRF_MOD_EXP) {\\r\\ncryptodev_dsa.bn_mod_exp = cryptodev_dsa_bn_mod_exp;\\r\\ncryptodev_dsa.dsa_mod_exp = cryptodev_dsa_dsa_mod_exp;\\r\\n}\\r\\nif (cryptodev_asymfeat & CRF_DSA_VERIFY)\\r\\ncryptodev_dsa.dsa_do_verify = cryptodev_dsa_verify;\\r\\n}\\r\\nif (ENGINE_set_DH(engine, &cryptodev_dh)) {\\r\\nconst DH_METHOD *dh_meth = DH_OpenSSL();\\r\\ncryptodev_dh.generate_key = dh_meth->generate_key;\\r\\ncryptodev_dh.compute_key = dh_meth->compute_key;\\r\\ncryptodev_dh.bn_mod_exp = dh_meth->bn_mod_exp;\\r\\nif (cryptodev_asymfeat & CRF_MOD_EXP) {\\r\\ncryptodev_dh.bn_mod_exp = cryptodev_mod_exp_dh;\\r\\nif (cryptodev_asymfeat & CRF_DH_COMPUTE_KEY)\\r\\ncryptodev_dh.compute_key = cryptodev_dh_compute_key;\\r\\n}\\r\\n}\\r\\nENGINE_add(engine);\\r\\nENGINE_free(engine);\\r\\nERR_clear_error();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_aes_misc_c", "target": 0, "func": "const char *AES_options(void)\\r\\n{\\r\\n#ifdef FULL_UNROLL\\r\\nreturn \"aes(full)\";\\r\\n#else\\r\\nreturn \"aes(partial)\";\\r\\n#endif\\r\\n}\\r\\nint AES_set_encrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nfips_cipher_abort(AES);\\r\\n#endif\\r\\nreturn private_AES_set_encrypt_key(userKey, bits, key);\\r\\n}\\r\\nint AES_set_decrypt_key(const unsigned char *userKey, const int bits,\\r\\nAES_KEY *key)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nfips_cipher_abort(AES);\\r\\n#endif\\r\\nreturn private_AES_set_decrypt_key(userKey, bits, key);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_sconnect_c", "target": 0, "func": "int main(argc, argv)\\r\\nint argc;\\r\\nchar *argv[];\\r\\n{\\r\\nchar *host;\\r\\nBIO *out;\\r\\nchar buf[1024 * 10], *p;\\r\\nSSL_CTX *ssl_ctx = NULL;\\r\\nSSL *ssl;\\r\\nBIO *ssl_bio;\\r\\nint i, len, off, ret = 1;\\r\\nif (argc <= 1)\\r\\nhost = \"localhost:4433\";\\r\\nelse\\r\\nhost = argv[1];\\r\\n#ifdef WATT32\\r\\ndbug_init();\\r\\nsock_init();\\r\\n#endif\\r\\nSSL_load_error_strings();\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nssl_ctx = SSL_CTX_new(SSLv23_client_method());\\r\\nssl = SSL_new(ssl_ctx);\\r\\nSSL_set_connect_state(ssl);\\r\\nssl_bio = BIO_new(BIO_f_ssl());\\r\\nBIO_set_ssl(ssl_bio, ssl, BIO_CLOSE);\\r\\nout = BIO_new(BIO_s_connect());\\r\\nBIO_set_conn_hostname(out, host);\\r\\nBIO_set_nbio(out, 1);\\r\\nout = BIO_push(ssl_bio, out);\\r\\np = \"GET / HTTP/1.0\\r\\n\\r\\n\";\\r\\nlen = strlen(p);\\r\\noff = 0;\\r\\nfor (;;) {\\r\\ni = BIO_write(out, &(p[off]), len);\\r\\nif (i <= 0) {\\r\\nif (BIO_should_retry(out)) {\\r\\nfprintf(stderr, \"write DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n} else {\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\noff += i;\\r\\nlen -= i;\\r\\nif (len <= 0)\\r\\nbreak;\\r\\n}\\r\\nfor (;;) {\\r\\ni = BIO_read(out, buf, sizeof(buf));\\r\\nif (i == 0)\\r\\nbreak;\\r\\nif (i < 0) {\\r\\nif (BIO_should_retry(out)) {\\r\\nfprintf(stderr, \"read DELAY\\n\");\\r\\nsleep(1);\\r\\ncontinue;\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\nfwrite(buf, 1, i, stdout);\\r\\n}\\r\\nret = 1;\\r\\nif (0) {\\r\\nerr:\\r\\nif (ERR_peek_error() == 0) {\\r\\nfprintf(stderr, \"errno=%d \", errno);\\r\\nperror(\"error\");\\r\\n} else\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nBIO_free_all(out);\\r\\nif (ssl_ctx != NULL)\\r\\nSSL_CTX_free(ssl_ctx);\\r\\nexit(!ret);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nint ret = 1;\\r\\nEC_KEY *eckey = NULL;\\r\\nconst EC_GROUP *group;\\r\\nint i, badops = 0;\\r\\nconst EVP_CIPHER *enc = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint informat, outformat, text = 0, noout = 0;\\r\\nint pubin = 0, pubout = 0, param_out = 0;\\r\\nchar *infile, *outfile, *prog, *engine;\\r\\nchar *passargin = NULL, *passargout = NULL;\\r\\nchar *passin = NULL, *passout = NULL;\\r\\npoint_conversion_form_t form = POINT_CONVERSION_UNCOMPRESSED;\\r\\nint new_form = 0;\\r\\nint asn1_flag = OPENSSL_EC_NAMED_CURVE;\\r\\nint new_asn1_flag = 0;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nengine = NULL;\\r\\ninfile = NULL;\\r\\noutfile = NULL;\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nprog = argv[0];\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passin\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-passout\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\npassargout = *(++argv);\\r\\n} else if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\nengine = *(++argv);\\r\\n} else if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nelse if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*argv, \"-conv_form\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\n++argv;\\r\\nnew_form = 1;\\r\\nif (strcmp(*argv, \"compressed\") == 0)\\r\\nform = POINT_CONVERSION_COMPRESSED;\\r\\nelse if (strcmp(*argv, \"uncompressed\") == 0)\\r\\nform = POINT_CONVERSION_UNCOMPRESSED;\\r\\nelse if (strcmp(*argv, \"hybrid\") == 0)\\r\\nform = POINT_CONVERSION_HYBRID;\\r\\nelse\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-param_enc\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\n++argv;\\r\\nnew_asn1_flag = 1;\\r\\nif (strcmp(*argv, \"named_curve\") == 0)\\r\\nasn1_flag = OPENSSL_EC_NAMED_CURVE;\\r\\nelse if (strcmp(*argv, \"explicit\") == 0)\\r\\nasn1_flag = 0;\\r\\nelse\\r\\ngoto bad;\\r\\n} else if (strcmp(*argv, \"-param_out\") == 0)\\r\\nparam_out = 1;\\r\\nelse if (strcmp(*argv, \"-pubin\") == 0)\\r\\npubin = 1;\\r\\nelse if (strcmp(*argv, \"-pubout\") == 0)\\r\\npubout = 1;\\r\\nelse if ((enc = EVP_get_cipherbyname(&(argv[0][1]))) == NULL) {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nBIO_printf(bio_err, \"%s [options] <infile >outfile\\n\", prog);\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \" -inform arg input format - \"\\r\\n\"DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -outform arg output format - \"\\r\\n\"DER or PEM\\n\");\\r\\nBIO_printf(bio_err, \" -in arg input file\\n\");\\r\\nBIO_printf(bio_err, \" -passin arg input file pass \"\\r\\n\"phrase source\\n\");\\r\\nBIO_printf(bio_err, \" -out arg output file\\n\");\\r\\nBIO_printf(bio_err, \" -passout arg output file pass \"\\r\\n\"phrase source\\n\");\\r\\nBIO_printf(bio_err, \" -engine e use engine e, \"\\r\\n\"possibly a hardware device.\\n\");\\r\\nBIO_printf(bio_err, \" -des encrypt PEM output, \"\\r\\n\"instead of 'des' every other \\n\"\\r\\n\" cipher \"\\r\\n\"supported by OpenSSL can be used\\n\");\\r\\nBIO_printf(bio_err, \" -text print the key\\n\");\\r\\nBIO_printf(bio_err, \" -noout don't print key out\\n\");\\r\\nBIO_printf(bio_err, \" -param_out print the elliptic \"\\r\\n\"curve parameters\\n\");\\r\\nBIO_printf(bio_err, \" -conv_form arg specifies the \"\\r\\n\"point conversion form \\n\");\\r\\nBIO_printf(bio_err, \" possible values:\"\\r\\n\" compressed\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\" uncompressed (default)\\n\");\\r\\nBIO_printf(bio_err, \" \" \" hybrid\\n\");\\r\\nBIO_printf(bio_err, \" -param_enc arg specifies the way\"\\r\\n\" the ec parameters are encoded\\n\");\\r\\nBIO_printf(bio_err, \" in the asn1 der \" \"encoding\\n\");\\r\\nBIO_printf(bio_err, \" possible values:\"\\r\\n\" named_curve (default)\\n\");\\r\\nBIO_printf(bio_err, \" \"\\r\\n\"explicit\\n\");\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (!app_passwd(bio_err, passargin, passargout, &passin, &passout)) {\\r\\nBIO_printf(bio_err, \"Error getting passwords\\n\");\\r\\ngoto end;\\r\\n}\\r\\nin = BIO_new(BIO_s_file());\\r\\nout = BIO_new(BIO_s_file());\\r\\nif ((in == NULL) || (out == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nBIO_printf(bio_err, \"read EC key\\n\");\\r\\nif (informat == FORMAT_ASN1) {\\r\\nif (pubin)\\r\\neckey = d2i_EC_PUBKEY_bio(in, NULL);\\r\\nelse\\r\\neckey = d2i_ECPrivateKey_bio(in, NULL);\\r\\n} else if (informat == FORMAT_PEM) {\\r\\nif (pubin)\\r\\neckey = PEM_read_bio_EC_PUBKEY(in, NULL, NULL, NULL);\\r\\nelse\\r\\neckey = PEM_read_bio_ECPrivateKey(in, NULL, NULL, passin);\\r\\n} else {\\r\\nBIO_printf(bio_err, \"bad input format specified for key\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (eckey == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load Key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\ngroup = EC_KEY_get0_group(eckey);\\r\\nif (new_form)\\r\\nEC_KEY_set_conv_form(eckey, form);\\r\\nif (new_asn1_flag)\\r\\nEC_KEY_set_asn1_flag(eckey, asn1_flag);\\r\\nif (text)\\r\\nif (!EC_KEY_print(out, eckey, 0)) {\\r\\nperror(outfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (noout) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nBIO_printf(bio_err, \"writing EC key\\n\");\\r\\nif (outformat == FORMAT_ASN1) {\\r\\nif (param_out)\\r\\ni = i2d_ECPKParameters_bio(out, group);\\r\\nelse if (pubin || pubout)\\r\\ni = i2d_EC_PUBKEY_bio(out, eckey);\\r\\nelse\\r\\ni = i2d_ECPrivateKey_bio(out, eckey);\\r\\n} else if (outformat == FORMAT_PEM) {\\r\\nif (param_out)\\r\\ni = PEM_write_bio_ECPKParameters(out, group);\\r\\nelse if (pubin || pubout)\\r\\ni = PEM_write_bio_EC_PUBKEY(out, eckey);\\r\\nelse\\r\\ni = PEM_write_bio_ECPrivateKey(out, eckey, enc,\\r\\nNULL, 0, NULL, passout);\\r\\n} else {\\r\\nBIO_printf(bio_err, \"bad output format specified for \" \"outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write private key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n} else\\r\\nret = 0;\\r\\nend:\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free_all(out);\\r\\nif (eckey)\\r\\nEC_KEY_free(eckey);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nif (passout)\\r\\nOPENSSL_free(passout);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_depr_c", "target": 0, "func": "DSA *DSA_generate_parameters(int bits,\\r\\nunsigned char *seed_in, int seed_len,\\r\\nint *counter_ret, unsigned long *h_ret,\\r\\nvoid (*callback) (int, int, void *),\\r\\nvoid *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nDSA *ret;\\r\\nif ((ret = DSA_new()) == NULL)\\r\\nreturn NULL;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nif (DSA_generate_parameters_ex(ret, bits, seed_in, seed_len,\\r\\ncounter_ret, h_ret, &cb))\\r\\nreturn ret;\\r\\nDSA_free(ret);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_print_c", "target": 0, "func": "char *BN_bn2hex(const BIGNUM *a)\\r\\n{\\r\\nint i, j, v, z = 0;\\r\\nchar *buf;\\r\\nchar *p;\\r\\nbuf = (char *)OPENSSL_malloc(a->top * BN_BYTES * 2 + 2);\\r\\nif (buf == NULL) {\\r\\nBNerr(BN_F_BN_BN2HEX, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\np = buf;\\r\\nif (a->neg)\\r\\n*(p++) = '-';\\r\\nif (BN_is_zero(a))\\r\\n*(p++) = '0';\\r\\nfor (i = a->top - 1; i >= 0; i--) {\\r\\nfor (j = BN_BITS2 - 8; j >= 0; j -= 8) {\\r\\nv = ((int)(a->d[i] >> (long)j)) & 0xff;\\r\\nif (z || (v != 0)) {\\r\\n*(p++) = Hex[v >> 4];\\r\\n*(p++) = Hex[v & 0x0f];\\r\\nz = 1;\\r\\n}\\r\\n}\\r\\n}\\r\\n*p = '\\0';\\r\\nerr:\\r\\nreturn (buf);\\r\\n}\\r\\nchar *BN_bn2dec(const BIGNUM *a)\\r\\n{\\r\\nint i = 0, num, ok = 0;\\r\\nchar *buf = NULL;\\r\\nchar *p;\\r\\nBIGNUM *t = NULL;\\r\\nBN_ULONG *bn_data = NULL, *lp;\\r\\ni = BN_num_bits(a) * 3;\\r\\nnum = (i / 10 + i / 1000 + 1) + 1;\\r\\nbn_data =\\r\\n(BN_ULONG *)OPENSSL_malloc((num / BN_DEC_NUM + 1) * sizeof(BN_ULONG));\\r\\nbuf = (char *)OPENSSL_malloc(num + 3);\\r\\nif ((buf == NULL) || (bn_data == NULL)) {\\r\\nBNerr(BN_F_BN_BN2DEC, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif ((t = BN_dup(a)) == NULL)\\r\\ngoto err;\\r\\n#define BUF_REMAIN (num+3 - (size_t)(p - buf))\\r\\np = buf;\\r\\nlp = bn_data;\\r\\nif (BN_is_zero(t)) {\\r\\n*(p++) = '0';\\r\\n*(p++) = '\\0';\\r\\n} else {\\r\\nif (BN_is_negative(t))\\r\\n*p++ = '-';\\r\\ni = 0;\\r\\nwhile (!BN_is_zero(t)) {\\r\\n*lp = BN_div_word(t, BN_DEC_CONV);\\r\\nlp++;\\r\\n}\\r\\nlp--;\\r\\nBIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT1, *lp);\\r\\nwhile (*p)\\r\\np++;\\r\\nwhile (lp != bn_data) {\\r\\nlp--;\\r\\nBIO_snprintf(p, BUF_REMAIN, BN_DEC_FMT2, *lp);\\r\\nwhile (*p)\\r\\np++;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (bn_data != NULL)\\r\\nOPENSSL_free(bn_data);\\r\\nif (t != NULL)\\r\\nBN_free(t);\\r\\nif (!ok && buf) {\\r\\nOPENSSL_free(buf);\\r\\nbuf = NULL;\\r\\n}\\r\\nreturn (buf);\\r\\n}\\r\\nint BN_hex2bn(BIGNUM **bn, const char *a)\\r\\n{\\r\\nBIGNUM *ret = NULL;\\r\\nBN_ULONG l = 0;\\r\\nint neg = 0, h, m, i, j, k, c;\\r\\nint num;\\r\\nif ((a == NULL) || (*a == '\\0'))\\r\\nreturn (0);\\r\\nif (*a == '-') {\\r\\nneg = 1;\\r\\na++;\\r\\n}\\r\\nfor (i = 0; isxdigit((unsigned char)a[i]); i++) ;\\r\\nnum = i + neg;\\r\\nif (bn == NULL)\\r\\nreturn (num);\\r\\nif (*bn == NULL) {\\r\\nif ((ret = BN_new()) == NULL)\\r\\nreturn (0);\\r\\n} else {\\r\\nret = *bn;\\r\\nBN_zero(ret);\\r\\n}\\r\\nif (bn_expand(ret, i * 4) == NULL)\\r\\ngoto err;\\r\\nj = i;\\r\\nm = 0;\\r\\nh = 0;\\r\\nwhile (j > 0) {\\r\\nm = ((BN_BYTES * 2) <= j) ? (BN_BYTES * 2) : j;\\r\\nl = 0;\\r\\nfor (;;) {\\r\\nc = a[j - m];\\r\\nif ((c >= '0') && (c <= '9'))\\r\\nk = c - '0';\\r\\nelse if ((c >= 'a') && (c <= 'f'))\\r\\nk = c - 'a' + 10;\\r\\nelse if ((c >= 'A') && (c <= 'F'))\\r\\nk = c - 'A' + 10;\\r\\nelse\\r\\nk = 0;\\r\\nl = (l << 4) | k;\\r\\nif (--m <= 0) {\\r\\nret->d[h++] = l;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nj -= (BN_BYTES * 2);\\r\\n}\\r\\nret->top = h;\\r\\nbn_correct_top(ret);\\r\\nret->neg = neg;\\r\\n*bn = ret;\\r\\nbn_check_top(ret);\\r\\nreturn (num);\\r\\nerr:\\r\\nif (*bn == NULL)\\r\\nBN_free(ret);\\r\\nreturn (0);\\r\\n}\\r\\nint BN_dec2bn(BIGNUM **bn, const char *a)\\r\\n{\\r\\nBIGNUM *ret = NULL;\\r\\nBN_ULONG l = 0;\\r\\nint neg = 0, i, j;\\r\\nint num;\\r\\nif ((a == NULL) || (*a == '\\0'))\\r\\nreturn (0);\\r\\nif (*a == '-') {\\r\\nneg = 1;\\r\\na++;\\r\\n}\\r\\nfor (i = 0; isdigit((unsigned char)a[i]); i++) ;\\r\\nnum = i + neg;\\r\\nif (bn == NULL)\\r\\nreturn (num);\\r\\nif (*bn == NULL) {\\r\\nif ((ret = BN_new()) == NULL)\\r\\nreturn (0);\\r\\n} else {\\r\\nret = *bn;\\r\\nBN_zero(ret);\\r\\n}\\r\\nif (bn_expand(ret, i * 4) == NULL)\\r\\ngoto err;\\r\\nj = BN_DEC_NUM - (i % BN_DEC_NUM);\\r\\nif (j == BN_DEC_NUM)\\r\\nj = 0;\\r\\nl = 0;\\r\\nwhile (*a) {\\r\\nl *= 10;\\r\\nl += *a - '0';\\r\\na++;\\r\\nif (++j == BN_DEC_NUM) {\\r\\nBN_mul_word(ret, BN_DEC_CONV);\\r\\nBN_add_word(ret, l);\\r\\nl = 0;\\r\\nj = 0;\\r\\n}\\r\\n}\\r\\nret->neg = neg;\\r\\nbn_correct_top(ret);\\r\\n*bn = ret;\\r\\nbn_check_top(ret);\\r\\nreturn (num);\\r\\nerr:\\r\\nif (*bn == NULL)\\r\\nBN_free(ret);\\r\\nreturn (0);\\r\\n}\\r\\nint BN_asc2bn(BIGNUM **bn, const char *a)\\r\\n{\\r\\nconst char *p = a;\\r\\nif (*p == '-')\\r\\np++;\\r\\nif (p[0] == '0' && (p[1] == 'X' || p[1] == 'x')) {\\r\\nif (!BN_hex2bn(bn, p + 2))\\r\\nreturn 0;\\r\\n} else {\\r\\nif (!BN_dec2bn(bn, p))\\r\\nreturn 0;\\r\\n}\\r\\nif (*a == '-')\\r\\n(*bn)->neg = 1;\\r\\nreturn 1;\\r\\n}\\r\\nint BN_print_fp(FILE *fp, const BIGNUM *a)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL)\\r\\nreturn (0);\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = BN_print(b, a);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_print(BIO *bp, const BIGNUM *a)\\r\\n{\\r\\nint i, j, v, z = 0;\\r\\nint ret = 0;\\r\\nif ((a->neg) && (BIO_write(bp, \"-\", 1) != 1))\\r\\ngoto end;\\r\\nif (BN_is_zero(a) && (BIO_write(bp, \"0\", 1) != 1))\\r\\ngoto end;\\r\\nfor (i = a->top - 1; i >= 0; i--) {\\r\\nfor (j = BN_BITS2 - 4; j >= 0; j -= 4) {\\r\\nv = ((int)(a->d[i] >> (long)j)) & 0x0f;\\r\\nif (z || (v != 0)) {\\r\\nif (BIO_write(bp, &(Hex[v]), 1) != 1)\\r\\ngoto end;\\r\\nz = 1;\\r\\n}\\r\\n}\\r\\n}\\r\\nret = 1;\\r\\nend:\\r\\nreturn (ret);\\r\\n}\\r\\nchar *BN_options(void)\\r\\n{\\r\\nstatic int init = 0;\\r\\nstatic char data[16];\\r\\nif (!init) {\\r\\ninit++;\\r\\n#ifdef BN_LLONG\\r\\nBIO_snprintf(data, sizeof data, \"bn(%d,%d)\",\\r\\n(int)sizeof(BN_ULLONG) * 8, (int)sizeof(BN_ULONG) * 8);\\r\\n#else\\r\\nBIO_snprintf(data, sizeof data, \"bn(%d,%d)\",\\r\\n(int)sizeof(BN_ULONG) * 8, (int)sizeof(BN_ULONG) * 8);\\r\\n#endif\\r\\n}\\r\\nreturn (data);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_vrf_c", "target": 0, "func": "int DSA_do_verify(const unsigned char *dgst, int dgst_len, DSA_SIG *sig,\\r\\nDSA *dsa)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(dsa->meth->flags & DSA_FLAG_FIPS_METHOD)\\r\\n&& !(dsa->flags & DSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nDSAerr(DSA_F_DSA_DO_VERIFY, DSA_R_NON_FIPS_DSA_METHOD);\\r\\nreturn -1;\\r\\n}\\r\\n#endif\\r\\nreturn dsa->meth->dsa_do_verify(dgst, dgst_len, sig, dsa);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cversion_c", "target": 0, "func": "const char *SSLeay_version(int t)\\r\\n{\\r\\nif (t == SSLEAY_VERSION)\\r\\nreturn OPENSSL_VERSION_TEXT;\\r\\nif (t == SSLEAY_BUILT_ON) {\\r\\n#ifdef DATE\\r\\n# ifdef OPENSSL_USE_BUILD_DATE\\r\\nreturn (DATE);\\r\\n# else\\r\\nreturn (\"built on: reproducible build, date unspecified\");\\r\\n# endif\\r\\n#else\\r\\nreturn (\"built on: date not available\");\\r\\n#endif\\r\\n}\\r\\nif (t == SSLEAY_CFLAGS) {\\r\\n#ifdef CFLAGS\\r\\nreturn (CFLAGS);\\r\\n#else\\r\\nreturn (\"compiler: information not available\");\\r\\n#endif\\r\\n}\\r\\nif (t == SSLEAY_PLATFORM) {\\r\\n#ifdef PLATFORM\\r\\nreturn (PLATFORM);\\r\\n#else\\r\\nreturn (\"platform: information not available\");\\r\\n#endif\\r\\n}\\r\\nif (t == SSLEAY_DIR) {\\r\\n#ifdef OPENSSLDIR\\r\\nreturn \"OPENSSLDIR: \\\"\" OPENSSLDIR \"\\\"\";\\r\\n#else\\r\\nreturn \"OPENSSLDIR: N/A\";\\r\\n#endif\\r\\n}\\r\\nreturn (\"not available\");\\r\\n}\\r\\nunsigned long SSLeay(void)\\r\\n{\\r\\nreturn (SSLEAY_VERSION_NUMBER);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_server-conf_c", "target": 0, "func": "int main(int argc, char *argv[])\\r\\n{\\r\\nchar *port = \"*:4433\";\\r\\nBIO *in = NULL;\\r\\nBIO *ssl_bio, *tmp;\\r\\nSSL_CTX *ctx;\\r\\nSSL_CONF_CTX *cctx = NULL;\\r\\nCONF *conf = NULL;\\r\\nSTACK_OF(CONF_VALUE) *sect = NULL;\\r\\nCONF_VALUE *cnf;\\r\\nlong errline = -1;\\r\\nchar buf[512];\\r\\nint ret = 1, i;\\r\\nSSL_load_error_strings();\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nconf = NCONF_new(NULL);\\r\\nif (NCONF_load(conf, \"accept.cnf\", &errline) <= 0) {\\r\\nif (errline <= 0)\\r\\nfprintf(stderr, \"Error processing config file\\n\");\\r\\nelse\\r\\nfprintf(stderr, \"Error on line %ld\\n\", errline);\\r\\ngoto err;\\r\\n}\\r\\nsect = NCONF_get_section(conf, \"default\");\\r\\nif (sect == NULL) {\\r\\nfprintf(stderr, \"Error retrieving default section\\n\");\\r\\ngoto err;\\r\\n}\\r\\nctx = SSL_CTX_new(SSLv23_server_method());\\r\\ncctx = SSL_CONF_CTX_new();\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_SERVER);\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CERTIFICATE);\\r\\nSSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_FILE);\\r\\nSSL_CONF_CTX_set_ssl_ctx(cctx, ctx);\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(sect); i++) {\\r\\nint rv;\\r\\ncnf = sk_CONF_VALUE_value(sect, i);\\r\\nrv = SSL_CONF_cmd(cctx, cnf->name, cnf->value);\\r\\nif (rv > 0)\\r\\ncontinue;\\r\\nif (rv != -2) {\\r\\nfprintf(stderr, \"Error processing %s = %s\\n\",\\r\\ncnf->name, cnf->value);\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto err;\\r\\n}\\r\\nif (!strcmp(cnf->name, \"Port\")) {\\r\\nport = cnf->value;\\r\\n} else {\\r\\nfprintf(stderr, \"Unknown configuration option %s\\n\", cnf->name);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!SSL_CONF_CTX_finish(cctx)) {\\r\\nfprintf(stderr, \"Finish error\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\ngoto err;\\r\\n}\\r\\nssl_bio = BIO_new_ssl(ctx, 0);\\r\\nif ((in = BIO_new_accept(port)) == NULL)\\r\\ngoto err;\\r\\nBIO_set_accept_bios(in, ssl_bio);\\r\\nagain:\\r\\nif (BIO_do_accept(in) <= 0)\\r\\ngoto err;\\r\\nfor (;;) {\\r\\ni = BIO_read(in, buf, 512);\\r\\nif (i == 0) {\\r\\nprintf(\"Done\\n\");\\r\\ntmp = BIO_pop(in);\\r\\nBIO_free_all(tmp);\\r\\ngoto again;\\r\\n}\\r\\nif (i < 0) {\\r\\nif (BIO_should_retry(in))\\r\\ncontinue;\\r\\ngoto err;\\r\\n}\\r\\nfwrite(buf, 1, i, stdout);\\r\\nfflush(stdout);\\r\\n}\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nexit(ret);\\r\\nreturn (!ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_pk7_c", "target": 0, "func": "BIO *BIO_new_PKCS7(BIO *out, PKCS7 *p7)\\r\\n{\\r\\nreturn BIO_new_NDEF(out, (ASN1_VALUE *)p7, ASN1_ITEM_rptr(PKCS7));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_xcbc_enc_c", "target": 0, "func": "void DES_xcbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, DES_key_schedule *schedule,\\r\\nDES_cblock *ivec, const_DES_cblock *inw,\\r\\nconst_DES_cblock *outw, int enc)\\r\\n{\\r\\nregister DES_LONG tin0, tin1;\\r\\nregister DES_LONG tout0, tout1, xor0, xor1;\\r\\nregister DES_LONG inW0, inW1, outW0, outW1;\\r\\nregister const unsigned char *in2;\\r\\nregister long l = length;\\r\\nDES_LONG tin[2];\\r\\nunsigned char *iv;\\r\\nin2 = &(*inw)[0];\\r\\nc2l(in2, inW0);\\r\\nc2l(in2, inW1);\\r\\nin2 = &(*outw)[0];\\r\\nc2l(in2, outW0);\\r\\nc2l(in2, outW1);\\r\\niv = &(*ivec)[0];\\r\\nif (enc) {\\r\\nc2l(iv, tout0);\\r\\nc2l(iv, tout1);\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nc2l(in, tin0);\\r\\nc2l(in, tin1);\\r\\ntin0 ^= tout0 ^ inW0;\\r\\ntin[0] = tin0;\\r\\ntin1 ^= tout1 ^ inW1;\\r\\ntin[1] = tin1;\\r\\nDES_encrypt1(tin, schedule, DES_ENCRYPT);\\r\\ntout0 = tin[0] ^ outW0;\\r\\nl2c(tout0, out);\\r\\ntout1 = tin[1] ^ outW1;\\r\\nl2c(tout1, out);\\r\\n}\\r\\nif (l != -8) {\\r\\nc2ln(in, tin0, tin1, l + 8);\\r\\ntin0 ^= tout0 ^ inW0;\\r\\ntin[0] = tin0;\\r\\ntin1 ^= tout1 ^ inW1;\\r\\ntin[1] = tin1;\\r\\nDES_encrypt1(tin, schedule, DES_ENCRYPT);\\r\\ntout0 = tin[0] ^ outW0;\\r\\nl2c(tout0, out);\\r\\ntout1 = tin[1] ^ outW1;\\r\\nl2c(tout1, out);\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(tout0, iv);\\r\\nl2c(tout1, iv);\\r\\n} else {\\r\\nc2l(iv, xor0);\\r\\nc2l(iv, xor1);\\r\\nfor (l -= 8; l > 0; l -= 8) {\\r\\nc2l(in, tin0);\\r\\ntin[0] = tin0 ^ outW0;\\r\\nc2l(in, tin1);\\r\\ntin[1] = tin1 ^ outW1;\\r\\nDES_encrypt1(tin, schedule, DES_DECRYPT);\\r\\ntout0 = tin[0] ^ xor0 ^ inW0;\\r\\ntout1 = tin[1] ^ xor1 ^ inW1;\\r\\nl2c(tout0, out);\\r\\nl2c(tout1, out);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nif (l != -8) {\\r\\nc2l(in, tin0);\\r\\ntin[0] = tin0 ^ outW0;\\r\\nc2l(in, tin1);\\r\\ntin[1] = tin1 ^ outW1;\\r\\nDES_encrypt1(tin, schedule, DES_DECRYPT);\\r\\ntout0 = tin[0] ^ xor0 ^ inW0;\\r\\ntout1 = tin[1] ^ xor1 ^ inW1;\\r\\nl2cn(tout0, tout1, out, l + 8);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\niv = &(*ivec)[0];\\r\\nl2c(xor0, iv);\\r\\nl2c(xor1, iv);\\r\\n}\\r\\ntin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;\\r\\ninW0 = inW1 = outW0 = outW1 = 0;\\r\\ntin[0] = tin[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_pubkey_c", "target": 0, "func": "static int pubkey_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nvoid *exarg)\\r\\n{\\r\\nif (operation == ASN1_OP_FREE_POST) {\\r\\nX509_PUBKEY *pubkey = (X509_PUBKEY *)*pval;\\r\\nEVP_PKEY_free(pubkey->pkey);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nRSA *d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nRSA *key;\\r\\nconst unsigned char *q;\\r\\nq = *pp;\\r\\npkey = d2i_PUBKEY(NULL, &q, length);\\r\\nif (!pkey)\\r\\nreturn NULL;\\r\\nkey = EVP_PKEY_get1_RSA(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (!key)\\r\\nreturn NULL;\\r\\n*pp = q;\\r\\nif (a) {\\r\\nRSA_free(*a);\\r\\n*a = key;\\r\\n}\\r\\nreturn key;\\r\\n}\\r\\nint i2d_RSA_PUBKEY(RSA *a, unsigned char **pp)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\nint ret;\\r\\nif (!a)\\r\\nreturn 0;\\r\\npktmp = EVP_PKEY_new();\\r\\nif (!pktmp) {\\r\\nASN1err(ASN1_F_I2D_RSA_PUBKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_set1_RSA(pktmp, a);\\r\\nret = i2d_PUBKEY(pktmp, pp);\\r\\nEVP_PKEY_free(pktmp);\\r\\nreturn ret;\\r\\n}\\r\\nDSA *d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp, long length)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nDSA *key;\\r\\nconst unsigned char *q;\\r\\nq = *pp;\\r\\npkey = d2i_PUBKEY(NULL, &q, length);\\r\\nif (!pkey)\\r\\nreturn NULL;\\r\\nkey = EVP_PKEY_get1_DSA(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (!key)\\r\\nreturn NULL;\\r\\n*pp = q;\\r\\nif (a) {\\r\\nDSA_free(*a);\\r\\n*a = key;\\r\\n}\\r\\nreturn key;\\r\\n}\\r\\nint i2d_DSA_PUBKEY(DSA *a, unsigned char **pp)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\nint ret;\\r\\nif (!a)\\r\\nreturn 0;\\r\\npktmp = EVP_PKEY_new();\\r\\nif (!pktmp) {\\r\\nASN1err(ASN1_F_I2D_DSA_PUBKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_set1_DSA(pktmp, a);\\r\\nret = i2d_PUBKEY(pktmp, pp);\\r\\nEVP_PKEY_free(pktmp);\\r\\nreturn ret;\\r\\n}\\r\\nEC_KEY *d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp, long length)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nEC_KEY *key;\\r\\nconst unsigned char *q;\\r\\nq = *pp;\\r\\npkey = d2i_PUBKEY(NULL, &q, length);\\r\\nif (!pkey)\\r\\nreturn (NULL);\\r\\nkey = EVP_PKEY_get1_EC_KEY(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (!key)\\r\\nreturn (NULL);\\r\\n*pp = q;\\r\\nif (a) {\\r\\nEC_KEY_free(*a);\\r\\n*a = key;\\r\\n}\\r\\nreturn (key);\\r\\n}\\r\\nint i2d_EC_PUBKEY(EC_KEY *a, unsigned char **pp)\\r\\n{\\r\\nEVP_PKEY *pktmp;\\r\\nint ret;\\r\\nif (!a)\\r\\nreturn (0);\\r\\nif ((pktmp = EVP_PKEY_new()) == NULL) {\\r\\nASN1err(ASN1_F_I2D_EC_PUBKEY, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nEVP_PKEY_set1_EC_KEY(pktmp, a);\\r\\nret = i2d_PUBKEY(pktmp, pp);\\r\\nEVP_PKEY_free(pktmp);\\r\\nreturn (ret);\\r\\n}\\r\\nint X509_PUBKEY_set0_param(X509_PUBKEY *pub, ASN1_OBJECT *aobj,\\r\\nint ptype, void *pval,\\r\\nunsigned char *penc, int penclen)\\r\\n{\\r\\nif (!X509_ALGOR_set0(pub->algor, aobj, ptype, pval))\\r\\nreturn 0;\\r\\nif (penc) {\\r\\nif (pub->public_key->data)\\r\\nOPENSSL_free(pub->public_key->data);\\r\\npub->public_key->data = penc;\\r\\npub->public_key->length = penclen;\\r\\npub->public_key->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\npub->public_key->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint X509_PUBKEY_get0_param(ASN1_OBJECT **ppkalg,\\r\\nconst unsigned char **pk, int *ppklen,\\r\\nX509_ALGOR **pa, X509_PUBKEY *pub)\\r\\n{\\r\\nif (ppkalg)\\r\\n*ppkalg = pub->algor->algorithm;\\r\\nif (pk) {\\r\\n*pk = pub->public_key->data;\\r\\n*ppklen = pub->public_key->length;\\r\\n}\\r\\nif (pa)\\r\\n*pa = pub->algor;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_s_cb_c", "target": 0, "func": "int MS_CALLBACK verify_callback(int ok, X509_STORE_CTX *ctx)\\r\\n{\\r\\nX509 *err_cert;\\r\\nint err, depth;\\r\\nerr_cert = X509_STORE_CTX_get_current_cert(ctx);\\r\\nerr = X509_STORE_CTX_get_error(ctx);\\r\\ndepth = X509_STORE_CTX_get_error_depth(ctx);\\r\\nif (!verify_quiet || !ok) {\\r\\nBIO_printf(bio_err, \"depth=%d \", depth);\\r\\nif (err_cert) {\\r\\nX509_NAME_print_ex(bio_err,\\r\\nX509_get_subject_name(err_cert),\\r\\n0, XN_FLAG_ONELINE);\\r\\nBIO_puts(bio_err, \"\\n\");\\r\\n} else\\r\\nBIO_puts(bio_err, \"<no cert>\\n\");\\r\\n}\\r\\nif (!ok) {\\r\\nBIO_printf(bio_err, \"verify error:num=%d:%s\\n\", err,\\r\\nX509_verify_cert_error_string(err));\\r\\nif (verify_depth >= depth) {\\r\\nif (!verify_return_error)\\r\\nok = 1;\\r\\nverify_error = X509_V_OK;\\r\\n} else {\\r\\nok = 0;\\r\\nverify_error = X509_V_ERR_CERT_CHAIN_TOO_LONG;\\r\\n}\\r\\n}\\r\\nswitch (err) {\\r\\ncase X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\\r\\nBIO_puts(bio_err, \"issuer= \");\\r\\nX509_NAME_print_ex(bio_err, X509_get_issuer_name(err_cert),\\r\\n0, XN_FLAG_ONELINE);\\r\\nBIO_puts(bio_err, \"\\n\");\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_NOT_YET_VALID:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:\\r\\nBIO_printf(bio_err, \"notBefore=\");\\r\\nASN1_TIME_print(bio_err, X509_get_notBefore(err_cert));\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\nbreak;\\r\\ncase X509_V_ERR_CERT_HAS_EXPIRED:\\r\\ncase X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:\\r\\nBIO_printf(bio_err, \"notAfter=\");\\r\\nASN1_TIME_print(bio_err, X509_get_notAfter(err_cert));\\r\\nBIO_printf(bio_err, \"\\n\");\\r\\nbreak;\\r\\ncase X509_V_ERR_NO_EXPLICIT_POLICY:\\r\\nif (!verify_quiet)\\r\\npolicies_print(bio_err, ctx);\\r\\nbreak;\\r\\n}\\r\\nif (err == X509_V_OK && ok == 2 && !verify_quiet)\\r\\npolicies_print(bio_err, ctx);\\r\\nif (ok && !verify_quiet)\\r\\nBIO_printf(bio_err, \"verify return:%d\\n\", ok);\\r\\nreturn (ok);\\r\\n}\\r\\nint set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file)\\r\\n{\\r\\nif (cert_file != NULL) {\\r\\nif (SSL_CTX_use_certificate_file(ctx, cert_file,\\r\\nSSL_FILETYPE_PEM) <= 0) {\\r\\nBIO_printf(bio_err, \"unable to get certificate from '%s'\\n\",\\r\\ncert_file);\\r\\nERR_print_errors(bio_err);\\r\\nreturn (0);\\r\\n}\\r\\nif (key_file == NULL)\\r\\nkey_file = cert_file;\\r\\nif (SSL_CTX_use_PrivateKey_file(ctx, key_file, SSL_FILETYPE_PEM) <= 0) {\\r\\nBIO_printf(bio_err, \"unable to get private key from '%s'\\n\",\\r\\nkey_file);\\r\\nERR_print_errors(bio_err);\\r\\nreturn (0);\\r\\n}\\r\\nif (!SSL_CTX_check_private_key(ctx)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Private key does not match the certificate public key\\n\");\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic void ssl_print_client_cert_types(BIO *bio, SSL *s)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nint i;\\r\\nint cert_type_num = SSL_get0_certificate_types(s, &p);\\r\\nif (!cert_type_num)\\r\\nreturn;\\r\\nBIO_puts(bio, \"Client Certificate Types: \");\\r\\nfor (i = 0; i < cert_type_num; i++) {\\r\\nunsigned char cert_type = p[i];\\r\\nchar *cname;\\r\\nswitch (cert_type) {\\r\\ncase TLS_CT_RSA_SIGN:\\r\\ncname = \"RSA sign\";\\r\\nbreak;\\r\\ncase TLS_CT_DSS_SIGN:\\r\\ncname = \"DSA sign\";\\r\\nbreak;\\r\\ncase TLS_CT_RSA_FIXED_DH:\\r\\ncname = \"RSA fixed DH\";\\r\\nbreak;\\r\\ncase TLS_CT_DSS_FIXED_DH:\\r\\ncname = \"DSS fixed DH\";\\r\\nbreak;\\r\\ncase TLS_CT_ECDSA_SIGN:\\r\\ncname = \"ECDSA sign\";\\r\\nbreak;\\r\\ncase TLS_CT_RSA_FIXED_ECDH:\\r\\ncname = \"RSA fixed ECDH\";\\r\\nbreak;\\r\\ncase TLS_CT_ECDSA_FIXED_ECDH:\\r\\ncname = \"ECDSA fixed ECDH\";\\r\\nbreak;\\r\\ncase TLS_CT_GOST94_SIGN:\\r\\ncname = \"GOST94 Sign\";\\r\\nbreak;\\r\\ncase TLS_CT_GOST01_SIGN:\\r\\ncname = \"GOST01 Sign\";\\r\\nbreak;\\r\\ndefault:\\r\\ncname = NULL;\\r\\n}\\r\\nif (i)\\r\\nBIO_puts(bio, \", \");\\r\\nif (cname)\\r\\nBIO_puts(bio, cname);\\r\\nelse\\r\\nBIO_printf(bio, \"UNKNOWN (%d),\", cert_type);\\r\\n}\\r\\nBIO_puts(bio, \"\\n\");\\r\\n}\\r\\nstatic int do_print_sigalgs(BIO *out, SSL *s, int shared)\\r\\n{\\r\\nint i, nsig, client;\\r\\nclient = SSL_is_server(s) ? 0 : 1;\\r\\nif (shared)\\r\\nnsig = SSL_get_shared_sigalgs(s, -1, NULL, NULL, NULL, NULL, NULL);\\r\\nelse\\r\\nnsig = SSL_get_sigalgs(s, -1, NULL, NULL, NULL, NULL, NULL);\\r\\nif (nsig == 0)\\r\\nreturn 1;\\r\\nif (shared)\\r\\nBIO_puts(out, \"Shared \");\\r\\nif (client)\\r\\nBIO_puts(out, \"Requested \");\\r\\nBIO_puts(out, \"Signature Algorithms: \");\\r\\nfor (i = 0; i < nsig; i++) {\\r\\nint hash_nid, sign_nid;\\r\\nunsigned char rhash, rsign;\\r\\nconst char *sstr = NULL;\\r\\nif (shared)\\r\\nSSL_get_shared_sigalgs(s, i, &sign_nid, &hash_nid, NULL,\\r\\n&rsign, &rhash);\\r\\nelse\\r\\nSSL_get_sigalgs(s, i, &sign_nid, &hash_nid, NULL, &rsign, &rhash);\\r\\nif (i)\\r\\nBIO_puts(out, \":\");\\r\\nif (sign_nid == EVP_PKEY_RSA)\\r\\nsstr = \"RSA\";\\r\\nelse if (sign_nid == EVP_PKEY_DSA)\\r\\nsstr = \"DSA\";\\r\\nelse if (sign_nid == EVP_PKEY_EC)\\r\\nsstr = \"ECDSA\";\\r\\nif (sstr)\\r\\nBIO_printf(out, \"%s+\", sstr);\\r\\nelse\\r\\nBIO_printf(out, \"0x%02X+\", (int)rsign);\\r\\nif (hash_nid != NID_undef)\\r\\nBIO_printf(out, \"%s\", OBJ_nid2sn(hash_nid));\\r\\nelse\\r\\nBIO_printf(out, \"0x%02X\", (int)rhash);\\r\\n}\\r\\nBIO_puts(out, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_print_sigalgs(BIO *out, SSL *s)\\r\\n{\\r\\nint mdnid;\\r\\nif (!SSL_is_server(s))\\r\\nssl_print_client_cert_types(out, s);\\r\\ndo_print_sigalgs(out, s, 0);\\r\\ndo_print_sigalgs(out, s, 1);\\r\\nif (SSL_get_peer_signature_nid(s, &mdnid))\\r\\nBIO_printf(out, \"Peer signing digest: %s\\n\", OBJ_nid2sn(mdnid));\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_print_point_formats(BIO *out, SSL *s)\\r\\n{\\r\\nint i, nformats;\\r\\nconst char *pformats;\\r\\nnformats = SSL_get0_ec_point_formats(s, &pformats);\\r\\nif (nformats <= 0)\\r\\nreturn 1;\\r\\nBIO_puts(out, \"Supported Elliptic Curve Point Formats: \");\\r\\nfor (i = 0; i < nformats; i++, pformats++) {\\r\\nif (i)\\r\\nBIO_puts(out, \":\");\\r\\nswitch (*pformats) {\\r\\ncase TLSEXT_ECPOINTFORMAT_uncompressed:\\r\\nBIO_puts(out, \"uncompressed\");\\r\\nbreak;\\r\\ncase TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime:\\r\\nBIO_puts(out, \"ansiX962_compressed_prime\");\\r\\nbreak;\\r\\ncase TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2:\\r\\nBIO_puts(out, \"ansiX962_compressed_char2\");\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_printf(out, \"unknown(%d)\", (int)*pformats);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nif (nformats <= 0)\\r\\nBIO_puts(out, \"NONE\");\\r\\nBIO_puts(out, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_print_curves(BIO *out, SSL *s, int noshared)\\r\\n{\\r\\nint i, ncurves, *curves, nid;\\r\\nconst char *cname;\\r\\nncurves = SSL_get1_curves(s, NULL);\\r\\nif (ncurves <= 0)\\r\\nreturn 1;\\r\\ncurves = OPENSSL_malloc(ncurves * sizeof(int));\\r\\nSSL_get1_curves(s, curves);\\r\\nBIO_puts(out, \"Supported Elliptic Curves: \");\\r\\nfor (i = 0; i < ncurves; i++) {\\r\\nif (i)\\r\\nBIO_puts(out, \":\");\\r\\nnid = curves[i];\\r\\nif (nid & TLSEXT_nid_unknown)\\r\\nBIO_printf(out, \"0x%04X\", nid & 0xFFFF);\\r\\nelse {\\r\\ncname = EC_curve_nid2nist(nid);\\r\\nif (!cname)\\r\\ncname = OBJ_nid2sn(nid);\\r\\nBIO_printf(out, \"%s\", cname);\\r\\n}\\r\\n}\\r\\nif (ncurves == 0)\\r\\nBIO_puts(out, \"NONE\");\\r\\nOPENSSL_free(curves);\\r\\nif (noshared) {\\r\\nBIO_puts(out, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nBIO_puts(out, \"\\nShared Elliptic curves: \");\\r\\nncurves = SSL_get_shared_curve(s, -1);\\r\\nfor (i = 0; i < ncurves; i++) {\\r\\nif (i)\\r\\nBIO_puts(out, \":\");\\r\\nnid = SSL_get_shared_curve(s, i);\\r\\ncname = EC_curve_nid2nist(nid);\\r\\nif (!cname)\\r\\ncname = OBJ_nid2sn(nid);\\r\\nBIO_printf(out, \"%s\", cname);\\r\\n}\\r\\nif (ncurves == 0)\\r\\nBIO_puts(out, \"NONE\");\\r\\nBIO_puts(out, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nint ssl_print_tmp_key(BIO *out, SSL *s)\\r\\n{\\r\\nEVP_PKEY *key;\\r\\nif (!SSL_get_server_tmp_key(s, &key))\\r\\nreturn 1;\\r\\nBIO_puts(out, \"Server Temp Key: \");\\r\\nswitch (EVP_PKEY_id(key)) {\\r\\ncase EVP_PKEY_RSA:\\r\\nBIO_printf(out, \"RSA, %d bits\\n\", EVP_PKEY_bits(key));\\r\\nbreak;\\r\\ncase EVP_PKEY_DH:\\r\\nBIO_printf(out, \"DH, %d bits\\n\", EVP_PKEY_bits(key));\\r\\nbreak;\\r\\n#ifndef OPENSSL_NO_ECDH\\r\\ncase EVP_PKEY_EC:\\r\\n{\\r\\nEC_KEY *ec = EVP_PKEY_get1_EC_KEY(key);\\r\\nint nid;\\r\\nconst char *cname;\\r\\nnid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));\\r\\nEC_KEY_free(ec);\\r\\ncname = EC_curve_nid2nist(nid);\\r\\nif (!cname)\\r\\ncname = OBJ_nid2sn(nid);\\r\\nBIO_printf(out, \"ECDH, %s, %d bits\\n\", cname, EVP_PKEY_bits(key));\\r\\n}\\r\\n#endif\\r\\n}\\r\\nEVP_PKEY_free(key);\\r\\nreturn 1;\\r\\n}\\r\\nlong MS_CALLBACK bio_dump_callback(BIO *bio, int cmd, const char *argp,\\r\\nint argi, long argl, long ret)\\r\\n{\\r\\nBIO *out;\\r\\nout = (BIO *)BIO_get_callback_arg(bio);\\r\\nif (out == NULL)\\r\\nreturn (ret);\\r\\nif (cmd == (BIO_CB_READ | BIO_CB_RETURN)) {\\r\\nBIO_printf(out, \"read from %p [%p] (%lu bytes => %ld (0x%lX))\\n\",\\r\\n(void *)bio, argp, (unsigned long)argi, ret, ret);\\r\\nBIO_dump(out, argp, (int)ret);\\r\\nreturn (ret);\\r\\n} else if (cmd == (BIO_CB_WRITE | BIO_CB_RETURN)) {\\r\\nBIO_printf(out, \"write to %p [%p] (%lu bytes => %ld (0x%lX))\\n\",\\r\\n(void *)bio, argp, (unsigned long)argi, ret, ret);\\r\\nBIO_dump(out, argp, (int)ret);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid MS_CALLBACK apps_ssl_info_callback(const SSL *s, int where, int ret)\\r\\n{\\r\\nconst char *str;\\r\\nint w;\\r\\nw = where & ~SSL_ST_MASK;\\r\\nif (w & SSL_ST_CONNECT)\\r\\nstr = \"SSL_connect\";\\r\\nelse if (w & SSL_ST_ACCEPT)\\r\\nstr = \"SSL_accept\";\\r\\nelse\\r\\nstr = \"undefined\";\\r\\nif (where & SSL_CB_LOOP) {\\r\\nBIO_printf(bio_err, \"%s:%s\\n\", str, SSL_state_string_long(s));\\r\\n} else if (where & SSL_CB_ALERT) {\\r\\nstr = (where & SSL_CB_READ) ? \"read\" : \"write\";\\r\\nBIO_printf(bio_err, \"SSL3 alert %s:%s:%s\\n\",\\r\\nstr,\\r\\nSSL_alert_type_string_long(ret),\\r\\nSSL_alert_desc_string_long(ret));\\r\\n} else if (where & SSL_CB_EXIT) {\\r\\nif (ret == 0)\\r\\nBIO_printf(bio_err, \"%s:failed in %s\\n\",\\r\\nstr, SSL_state_string_long(s));\\r\\nelse if (ret < 0) {\\r\\nBIO_printf(bio_err, \"%s:error in %s\\n\",\\r\\nstr, SSL_state_string_long(s));\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid MS_CALLBACK msg_cb(int write_p, int version, int content_type,\\r\\nconst void *buf, size_t len, SSL *ssl, void *arg)\\r\\n{\\r\\nBIO *bio = arg;\\r\\nconst char *str_write_p, *str_version, *str_content_type =\\r\\n\"\", *str_details1 = \"\", *str_details2 = \"\";\\r\\nstr_write_p = write_p ? \">>>\" : \"<<<\";\\r\\nswitch (version) {\\r\\ncase SSL2_VERSION:\\r\\nstr_version = \"SSL 2.0\";\\r\\nbreak;\\r\\ncase SSL3_VERSION:\\r\\nstr_version = \"SSL 3.0 \";\\r\\nbreak;\\r\\ncase TLS1_VERSION:\\r\\nstr_version = \"TLS 1.0 \";\\r\\nbreak;\\r\\ncase TLS1_1_VERSION:\\r\\nstr_version = \"TLS 1.1 \";\\r\\nbreak;\\r\\ncase TLS1_2_VERSION:\\r\\nstr_version = \"TLS 1.2 \";\\r\\nbreak;\\r\\ncase DTLS1_VERSION:\\r\\nstr_version = \"DTLS 1.0 \";\\r\\nbreak;\\r\\ncase DTLS1_BAD_VER:\\r\\nstr_version = \"DTLS 1.0 (bad) \";\\r\\nbreak;\\r\\ndefault:\\r\\nstr_version = \"???\";\\r\\n}\\r\\nif (version == SSL2_VERSION) {\\r\\nstr_details1 = \"???\";\\r\\nif (len > 0) {\\r\\nswitch (((const unsigned char *)buf)[0]) {\\r\\ncase 0:\\r\\nstr_details1 = \", ERROR:\";\\r\\nstr_details2 = \" ???\";\\r\\nif (len >= 3) {\\r\\nunsigned err =\\r\\n(((const unsigned char *)buf)[1] << 8) +\\r\\n((const unsigned char *)buf)[2];\\r\\nswitch (err) {\\r\\ncase 0x0001:\\r\\nstr_details2 = \" NO-CIPHER-ERROR\";\\r\\nbreak;\\r\\ncase 0x0002:\\r\\nstr_details2 = \" NO-CERTIFICATE-ERROR\";\\r\\nbreak;\\r\\ncase 0x0004:\\r\\nstr_details2 = \" BAD-CERTIFICATE-ERROR\";\\r\\nbreak;\\r\\ncase 0x0006:\\r\\nstr_details2 = \" UNSUPPORTED-CERTIFICATE-TYPE-ERROR\";\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbreak;\\r\\ncase 1:\\r\\nstr_details1 = \", CLIENT-HELLO\";\\r\\nbreak;\\r\\ncase 2:\\r\\nstr_details1 = \", CLIENT-MASTER-KEY\";\\r\\nbreak;\\r\\ncase 3:\\r\\nstr_details1 = \", CLIENT-FINISHED\";\\r\\nbreak;\\r\\ncase 4:\\r\\nstr_details1 = \", SERVER-HELLO\";\\r\\nbreak;\\r\\ncase 5:\\r\\nstr_details1 = \", SERVER-VERIFY\";\\r\\nbreak;\\r\\ncase 6:\\r\\nstr_details1 = \", SERVER-FINISHED\";\\r\\nbreak;\\r\\ncase 7:\\r\\nstr_details1 = \", REQUEST-CERTIFICATE\";\\r\\nbreak;\\r\\ncase 8:\\r\\nstr_details1 = \", CLIENT-CERTIFICATE\";\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (version == SSL3_VERSION ||\\r\\nversion == TLS1_VERSION ||\\r\\nversion == TLS1_1_VERSION ||\\r\\nversion == TLS1_2_VERSION ||\\r\\nversion == DTLS1_VERSION || version == DTLS1_BAD_VER) {\\r\\nswitch (content_type) {\\r\\ncase 20:\\r\\nstr_content_type = \"ChangeCipherSpec\";\\r\\nbreak;\\r\\ncase 21:\\r\\nstr_content_type = \"Alert\";\\r\\nbreak;\\r\\ncase 22:\\r\\nstr_content_type = \"Handshake\";\\r\\nbreak;\\r\\n}\\r\\nif (content_type == 21) {\\r\\nstr_details1 = \", ???\";\\r\\nif (len == 2) {\\r\\nswitch (((const unsigned char *)buf)[0]) {\\r\\ncase 1:\\r\\nstr_details1 = \", warning\";\\r\\nbreak;\\r\\ncase 2:\\r\\nstr_details1 = \", fatal\";\\r\\nbreak;\\r\\n}\\r\\nstr_details2 = \" ???\";\\r\\nswitch (((const unsigned char *)buf)[1]) {\\r\\ncase 0:\\r\\nstr_details2 = \" close_notify\";\\r\\nbreak;\\r\\ncase 10:\\r\\nstr_details2 = \" unexpected_message\";\\r\\nbreak;\\r\\ncase 20:\\r\\nstr_details2 = \" bad_record_mac\";\\r\\nbreak;\\r\\ncase 21:\\r\\nstr_details2 = \" decryption_failed\";\\r\\nbreak;\\r\\ncase 22:\\r\\nstr_details2 = \" record_overflow\";\\r\\nbreak;\\r\\ncase 30:\\r\\nstr_details2 = \" decompression_failure\";\\r\\nbreak;\\r\\ncase 40:\\r\\nstr_details2 = \" handshake_failure\";\\r\\nbreak;\\r\\ncase 42:\\r\\nstr_details2 = \" bad_certificate\";\\r\\nbreak;\\r\\ncase 43:\\r\\nstr_details2 = \" unsupported_certificate\";\\r\\nbreak;\\r\\ncase 44:\\r\\nstr_details2 = \" certificate_revoked\";\\r\\nbreak;\\r\\ncase 45:\\r\\nstr_details2 = \" certificate_expired\";\\r\\nbreak;\\r\\ncase 46:\\r\\nstr_details2 = \" certificate_unknown\";\\r\\nbreak;\\r\\ncase 47:\\r\\nstr_details2 = \" illegal_parameter\";\\r\\nbreak;\\r\\ncase 48:\\r\\nstr_details2 = \" unknown_ca\";\\r\\nbreak;\\r\\ncase 49:\\r\\nstr_details2 = \" access_denied\";\\r\\nbreak;\\r\\ncase 50:\\r\\nstr_details2 = \" decode_error\";\\r\\nbreak;\\r\\ncase 51:\\r\\nstr_details2 = \" decrypt_error\";\\r\\nbreak;\\r\\ncase 60:\\r\\nstr_details2 = \" export_restriction\";\\r\\nbreak;\\r\\ncase 70:\\r\\nstr_details2 = \" protocol_version\";\\r\\nbreak;\\r\\ncase 71:\\r\\nstr_details2 = \" insufficient_security\";\\r\\nbreak;\\r\\ncase 80:\\r\\nstr_details2 = \" internal_error\";\\r\\nbreak;\\r\\ncase 90:\\r\\nstr_details2 = \" user_canceled\";\\r\\nbreak;\\r\\ncase 100:\\r\\nstr_details2 = \" no_renegotiation\";\\r\\nbreak;\\r\\ncase 110:\\r\\nstr_details2 = \" unsupported_extension\";\\r\\nbreak;\\r\\ncase 111:\\r\\nstr_details2 = \" certificate_unobtainable\";\\r\\nbreak;\\r\\ncase 112:\\r\\nstr_details2 = \" unrecognized_name\";\\r\\nbreak;\\r\\ncase 113:\\r\\nstr_details2 = \" bad_certificate_status_response\";\\r\\nbreak;\\r\\ncase 114:\\r\\nstr_details2 = \" bad_certificate_hash_value\";\\r\\nbreak;\\r\\ncase 115:\\r\\nstr_details2 = \" unknown_psk_identity\";\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (content_type == 22) {\\r\\nstr_details1 = \"???\";\\r\\nif (len > 0) {\\r\\nswitch (((const unsigned char *)buf)[0]) {\\r\\ncase 0:\\r\\nstr_details1 = \", HelloRequest\";\\r\\nbreak;\\r\\ncase 1:\\r\\nstr_details1 = \", ClientHello\";\\r\\nbreak;\\r\\ncase 2:\\r\\nstr_details1 = \", ServerHello\";\\r\\nbreak;\\r\\ncase 3:\\r\\nstr_details1 = \", HelloVerifyRequest\";\\r\\nbreak;\\r\\ncase 11:\\r\\nstr_details1 = \", Certificate\";\\r\\nbreak;\\r\\ncase 12:\\r\\nstr_details1 = \", ServerKeyExchange\";\\r\\nbreak;\\r\\ncase 13:\\r\\nstr_details1 = \", CertificateRequest\";\\r\\nbreak;\\r\\ncase 14:\\r\\nstr_details1 = \", ServerHelloDone\";\\r\\nbreak;\\r\\ncase 15:\\r\\nstr_details1 = \", CertificateVerify\";\\r\\nbreak;\\r\\ncase 16:\\r\\nstr_details1 = \", ClientKeyExchange\";\\r\\nbreak;\\r\\ncase 20:\\r\\nstr_details1 = \", Finished\";\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\n#ifndef OPENSSL_NO_HEARTBEATS\\r\\nif (content_type == 24) {\\r\\nstr_details1 = \", Heartbeat\";\\r\\nif (len > 0) {\\r\\nswitch (((const unsigned char *)buf)[0]) {\\r\\ncase 1:\\r\\nstr_details1 = \", HeartbeatRequest\";\\r\\nbreak;\\r\\ncase 2:\\r\\nstr_details1 = \", HeartbeatResponse\";\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\n#endif\\r\\n}\\r\\nBIO_printf(bio, \"%s %s%s [length %04lx]%s%s\\n\", str_write_p, str_version,\\r\\nstr_content_type, (unsigned long)len, str_details1,\\r\\nstr_details2);\\r\\nif (len > 0) {\\r\\nsize_t num, i;\\r\\nBIO_printf(bio, \" \");\\r\\nnum = len;\\r\\n#if 0\\r\\nif (num > 16)\\r\\nnum = 16;\\r\\n#endif\\r\\nfor (i = 0; i < num; i++) {\\r\\nif (i % 16 == 0 && i > 0)\\r\\nBIO_printf(bio, \"\\n \");\\r\\nBIO_printf(bio, \" %02x\", ((const unsigned char *)buf)[i]);\\r\\n}\\r\\nif (i < len)\\r\\nBIO_printf(bio, \" ...\");\\r\\nBIO_printf(bio, \"\\n\");\\r\\n}\\r\\n(void)BIO_flush(bio);\\r\\n}\\r\\nvoid MS_CALLBACK tlsext_cb(SSL *s, int client_server, int type,\\r\\nunsigned char *data, int len, void *arg)\\r\\n{\\r\\nBIO *bio = arg;\\r\\nchar *extname;\\r\\nswitch (type) {\\r\\ncase TLSEXT_TYPE_server_name:\\r\\nextname = \"server name\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_max_fragment_length:\\r\\nextname = \"max fragment length\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_client_certificate_url:\\r\\nextname = \"client certificate URL\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_trusted_ca_keys:\\r\\nextname = \"trusted CA keys\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_truncated_hmac:\\r\\nextname = \"truncated HMAC\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_status_request:\\r\\nextname = \"status request\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_user_mapping:\\r\\nextname = \"user mapping\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_client_authz:\\r\\nextname = \"client authz\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_server_authz:\\r\\nextname = \"server authz\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_cert_type:\\r\\nextname = \"cert type\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_elliptic_curves:\\r\\nextname = \"elliptic curves\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_ec_point_formats:\\r\\nextname = \"EC point formats\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_srp:\\r\\nextname = \"SRP\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_signature_algorithms:\\r\\nextname = \"signature algorithms\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_use_srtp:\\r\\nextname = \"use SRTP\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_heartbeat:\\r\\nextname = \"heartbeat\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_session_ticket:\\r\\nextname = \"session ticket\";\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_renegotiate:\\r\\nextname = \"renegotiation info\";\\r\\nbreak;\\r\\n#ifdef TLSEXT_TYPE_opaque_prf_input\\r\\ncase TLSEXT_TYPE_opaque_prf_input:\\r\\nextname = \"opaque PRF input\";\\r\\nbreak;\\r\\n#endif\\r\\n#ifdef TLSEXT_TYPE_next_proto_neg\\r\\ncase TLSEXT_TYPE_next_proto_neg:\\r\\nextname = \"next protocol\";\\r\\nbreak;\\r\\n#endif\\r\\ncase TLSEXT_TYPE_padding:\\r\\nextname = \"TLS padding\";\\r\\nbreak;\\r\\ndefault:\\r\\nextname = \"unknown\";\\r\\nbreak;\\r\\n}\\r\\nBIO_printf(bio, \"TLS %s extension \\\"%s\\\" (id=%d), len=%d\\n\",\\r\\nclient_server ? \"server\" : \"client\", extname, type, len);\\r\\nBIO_dump(bio, (char *)data, len);\\r\\n(void)BIO_flush(bio);\\r\\n}\\r\\nint MS_CALLBACK generate_cookie_callback(SSL *ssl, unsigned char *cookie,\\r\\nunsigned int *cookie_len)\\r\\n{\\r\\nunsigned char *buffer, result[EVP_MAX_MD_SIZE];\\r\\nunsigned int length, resultlength;\\r\\nunion {\\r\\nstruct sockaddr sa;\\r\\nstruct sockaddr_in s4;\\r\\n#if OPENSSL_USE_IPV6\\r\\nstruct sockaddr_in6 s6;\\r\\n#endif\\r\\n} peer;\\r\\nif (!cookie_initialized) {\\r\\nif (!RAND_bytes(cookie_secret, COOKIE_SECRET_LENGTH)) {\\r\\nBIO_printf(bio_err, \"error setting random cookie secret\\n\");\\r\\nreturn 0;\\r\\n}\\r\\ncookie_initialized = 1;\\r\\n}\\r\\n(void)BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);\\r\\nlength = 0;\\r\\nswitch (peer.sa.sa_family) {\\r\\ncase AF_INET:\\r\\nlength += sizeof(struct in_addr);\\r\\nlength += sizeof(peer.s4.sin_port);\\r\\nbreak;\\r\\n#if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\nlength += sizeof(struct in6_addr);\\r\\nlength += sizeof(peer.s6.sin6_port);\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nOPENSSL_assert(0);\\r\\nbreak;\\r\\n}\\r\\nbuffer = OPENSSL_malloc(length);\\r\\nif (buffer == NULL) {\\r\\nBIO_printf(bio_err, \"out of memory\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nswitch (peer.sa.sa_family) {\\r\\ncase AF_INET:\\r\\nmemcpy(buffer, &peer.s4.sin_port, sizeof(peer.s4.sin_port));\\r\\nmemcpy(buffer + sizeof(peer.s4.sin_port),\\r\\n&peer.s4.sin_addr, sizeof(struct in_addr));\\r\\nbreak;\\r\\n#if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\nmemcpy(buffer, &peer.s6.sin6_port, sizeof(peer.s6.sin6_port));\\r\\nmemcpy(buffer + sizeof(peer.s6.sin6_port),\\r\\n&peer.s6.sin6_addr, sizeof(struct in6_addr));\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nOPENSSL_assert(0);\\r\\nbreak;\\r\\n}\\r\\nHMAC(EVP_sha1(), cookie_secret, COOKIE_SECRET_LENGTH,\\r\\nbuffer, length, result, &resultlength);\\r\\nOPENSSL_free(buffer);\\r\\nmemcpy(cookie, result, resultlength);\\r\\n*cookie_len = resultlength;\\r\\nreturn 1;\\r\\n}\\r\\nint MS_CALLBACK verify_cookie_callback(SSL *ssl, unsigned char *cookie,\\r\\nunsigned int cookie_len)\\r\\n{\\r\\nunsigned char *buffer, result[EVP_MAX_MD_SIZE];\\r\\nunsigned int length, resultlength;\\r\\nunion {\\r\\nstruct sockaddr sa;\\r\\nstruct sockaddr_in s4;\\r\\n#if OPENSSL_USE_IPV6\\r\\nstruct sockaddr_in6 s6;\\r\\n#endif\\r\\n} peer;\\r\\nif (!cookie_initialized)\\r\\nreturn 0;\\r\\n(void)BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);\\r\\nlength = 0;\\r\\nswitch (peer.sa.sa_family) {\\r\\ncase AF_INET:\\r\\nlength += sizeof(struct in_addr);\\r\\nlength += sizeof(peer.s4.sin_port);\\r\\nbreak;\\r\\n#if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\nlength += sizeof(struct in6_addr);\\r\\nlength += sizeof(peer.s6.sin6_port);\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nOPENSSL_assert(0);\\r\\nbreak;\\r\\n}\\r\\nbuffer = OPENSSL_malloc(length);\\r\\nif (buffer == NULL) {\\r\\nBIO_printf(bio_err, \"out of memory\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nswitch (peer.sa.sa_family) {\\r\\ncase AF_INET:\\r\\nmemcpy(buffer, &peer.s4.sin_port, sizeof(peer.s4.sin_port));\\r\\nmemcpy(buffer + sizeof(peer.s4.sin_port),\\r\\n&peer.s4.sin_addr, sizeof(struct in_addr));\\r\\nbreak;\\r\\n#if OPENSSL_USE_IPV6\\r\\ncase AF_INET6:\\r\\nmemcpy(buffer, &peer.s6.sin6_port, sizeof(peer.s6.sin6_port));\\r\\nmemcpy(buffer + sizeof(peer.s6.sin6_port),\\r\\n&peer.s6.sin6_addr, sizeof(struct in6_addr));\\r\\nbreak;\\r\\n#endif\\r\\ndefault:\\r\\nOPENSSL_assert(0);\\r\\nbreak;\\r\\n}\\r\\nHMAC(EVP_sha1(), cookie_secret, COOKIE_SECRET_LENGTH,\\r\\nbuffer, length, result, &resultlength);\\r\\nOPENSSL_free(buffer);\\r\\nif (cookie_len == resultlength\\r\\n&& memcmp(result, cookie, resultlength) == 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic void print_chain_flags(BIO *out, SSL *s, int flags)\\r\\n{\\r\\nstruct chain_flags *ctmp = chain_flags_list;\\r\\nwhile (ctmp->name) {\\r\\nBIO_printf(out, \"\\t%s: %s\\n\", ctmp->name,\\r\\nflags & ctmp->flag ? \"OK\" : \"NOT OK\");\\r\\nctmp++;\\r\\n}\\r\\nBIO_printf(out, \"\\tSuite B: \");\\r\\nif (SSL_set_cert_flags(s, 0) & SSL_CERT_FLAG_SUITEB_128_LOS)\\r\\nBIO_puts(out, flags & CERT_PKEY_SUITEB ? \"OK\\n\" : \"NOT OK\\n\");\\r\\nelse\\r\\nBIO_printf(out, \"not tested\\n\");\\r\\n}\\r\\nstatic int set_cert_cb(SSL *ssl, void *arg)\\r\\n{\\r\\nint i, rv;\\r\\nSSL_EXCERT *exc = arg;\\r\\n#ifdef CERT_CB_TEST_RETRY\\r\\nstatic int retry_cnt;\\r\\nif (retry_cnt < 5) {\\r\\nretry_cnt++;\\r\\nfprintf(stderr, \"Certificate callback retry test: count %d\\n\",\\r\\nretry_cnt);\\r\\nreturn -1;\\r\\n}\\r\\n#endif\\r\\nSSL_certs_clear(ssl);\\r\\nif (!exc)\\r\\nreturn 1;\\r\\nwhile (exc->next)\\r\\nexc = exc->next;\\r\\ni = 0;\\r\\nwhile (exc) {\\r\\ni++;\\r\\nrv = SSL_check_chain(ssl, exc->cert, exc->key, exc->chain);\\r\\nBIO_printf(bio_err, \"Checking cert chain %d:\\nSubject: \", i);\\r\\nX509_NAME_print_ex(bio_err, X509_get_subject_name(exc->cert), 0,\\r\\nXN_FLAG_ONELINE);\\r\\nBIO_puts(bio_err, \"\\n\");\\r\\nprint_chain_flags(bio_err, ssl, rv);\\r\\nif (rv & CERT_PKEY_VALID) {\\r\\nSSL_use_certificate(ssl, exc->cert);\\r\\nSSL_use_PrivateKey(ssl, exc->key);\\r\\nif (exc->build_chain) {\\r\\nif (!SSL_build_cert_chain(ssl, 0))\\r\\nreturn 0;\\r\\n} else if (exc->chain)\\r\\nSSL_set1_chain(ssl, exc->chain);\\r\\n}\\r\\nexc = exc->prev;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid ssl_ctx_set_excert(SSL_CTX *ctx, SSL_EXCERT *exc)\\r\\n{\\r\\nSSL_CTX_set_cert_cb(ctx, set_cert_cb, exc);\\r\\n}\\r\\nstatic int ssl_excert_prepend(SSL_EXCERT **pexc)\\r\\n{\\r\\nSSL_EXCERT *exc;\\r\\nexc = OPENSSL_malloc(sizeof(SSL_EXCERT));\\r\\nif (!exc)\\r\\nreturn 0;\\r\\nexc->certfile = NULL;\\r\\nexc->keyfile = NULL;\\r\\nexc->chainfile = NULL;\\r\\nexc->cert = NULL;\\r\\nexc->key = NULL;\\r\\nexc->chain = NULL;\\r\\nexc->prev = NULL;\\r\\nexc->build_chain = 0;\\r\\nexc->next = *pexc;\\r\\n*pexc = exc;\\r\\nif (exc->next) {\\r\\nexc->certform = exc->next->certform;\\r\\nexc->keyform = exc->next->keyform;\\r\\nexc->next->prev = exc;\\r\\n} else {\\r\\nexc->certform = FORMAT_PEM;\\r\\nexc->keyform = FORMAT_PEM;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid ssl_excert_free(SSL_EXCERT *exc)\\r\\n{\\r\\nSSL_EXCERT *curr;\\r\\nwhile (exc) {\\r\\nif (exc->cert)\\r\\nX509_free(exc->cert);\\r\\nif (exc->key)\\r\\nEVP_PKEY_free(exc->key);\\r\\nif (exc->chain)\\r\\nsk_X509_pop_free(exc->chain, X509_free);\\r\\ncurr = exc;\\r\\nexc = exc->next;\\r\\nOPENSSL_free(curr);\\r\\n}\\r\\n}\\r\\nint load_excert(SSL_EXCERT **pexc, BIO *err)\\r\\n{\\r\\nSSL_EXCERT *exc = *pexc;\\r\\nif (!exc)\\r\\nreturn 1;\\r\\nif (!exc->certfile && !exc->next) {\\r\\nssl_excert_free(exc);\\r\\n*pexc = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nfor (; exc; exc = exc->next) {\\r\\nif (!exc->certfile) {\\r\\nBIO_printf(err, \"Missing filename\\n\");\\r\\nreturn 0;\\r\\n}\\r\\nexc->cert = load_cert(err, exc->certfile, exc->certform,\\r\\nNULL, NULL, \"Server Certificate\");\\r\\nif (!exc->cert)\\r\\nreturn 0;\\r\\nif (exc->keyfile) {\\r\\nexc->key = load_key(err, exc->keyfile, exc->keyform,\\r\\n0, NULL, NULL, \"Server Key\");\\r\\n} else {\\r\\nexc->key = load_key(err, exc->certfile, exc->certform,\\r\\n0, NULL, NULL, \"Server Key\");\\r\\n}\\r\\nif (!exc->key)\\r\\nreturn 0;\\r\\nif (exc->chainfile) {\\r\\nexc->chain = load_certs(err,\\r\\nexc->chainfile, FORMAT_PEM,\\r\\nNULL, NULL, \"Server Chain\");\\r\\nif (!exc->chain)\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint args_excert(char ***pargs, int *pargc,\\r\\nint *badarg, BIO *err, SSL_EXCERT **pexc)\\r\\n{\\r\\nchar *arg = **pargs, *argn = (*pargs)[1];\\r\\nSSL_EXCERT *exc = *pexc;\\r\\nint narg = 2;\\r\\nif (!exc) {\\r\\nif (ssl_excert_prepend(&exc))\\r\\n*pexc = exc;\\r\\nelse {\\r\\nBIO_printf(err, \"Error initialising xcert\\n\");\\r\\n*badarg = 1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (strcmp(arg, \"-xcert\") == 0) {\\r\\nif (!argn) {\\r\\n*badarg = 1;\\r\\nreturn 1;\\r\\n}\\r\\nif (exc->certfile && !ssl_excert_prepend(&exc)) {\\r\\nBIO_printf(err, \"Error adding xcert\\n\");\\r\\n*badarg = 1;\\r\\ngoto err;\\r\\n}\\r\\nexc->certfile = argn;\\r\\n} else if (strcmp(arg, \"-xkey\") == 0) {\\r\\nif (!argn) {\\r\\n*badarg = 1;\\r\\nreturn 1;\\r\\n}\\r\\nif (exc->keyfile) {\\r\\nBIO_printf(err, \"Key already specified\\n\");\\r\\n*badarg = 1;\\r\\nreturn 1;\\r\\n}\\r\\nexc->keyfile = argn;\\r\\n} else if (strcmp(arg, \"-xchain\") == 0) {\\r\\nif (!argn) {\\r\\n*badarg = 1;\\r\\nreturn 1;\\r\\n}\\r\\nif (exc->chainfile) {\\r\\nBIO_printf(err, \"Chain already specified\\n\");\\r\\n*badarg = 1;\\r\\nreturn 1;\\r\\n}\\r\\nexc->chainfile = argn;\\r\\n} else if (strcmp(arg, \"-xchain_build\") == 0) {\\r\\nnarg = 1;\\r\\nexc->build_chain = 1;\\r\\n} else if (strcmp(arg, \"-xcertform\") == 0) {\\r\\nif (!argn) {\\r\\n*badarg = 1;\\r\\ngoto err;\\r\\n}\\r\\nexc->certform = str2fmt(argn);\\r\\n} else if (strcmp(arg, \"-xkeyform\") == 0) {\\r\\nif (!argn) {\\r\\n*badarg = 1;\\r\\ngoto err;\\r\\n}\\r\\nexc->keyform = str2fmt(argn);\\r\\n} else\\r\\nreturn 0;\\r\\n(*pargs) += narg;\\r\\nif (pargc)\\r\\n*pargc -= narg;\\r\\n*pexc = exc;\\r\\nreturn 1;\\r\\nerr:\\r\\nERR_print_errors(err);\\r\\nssl_excert_free(exc);\\r\\n*pexc = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void print_raw_cipherlist(BIO *bio, SSL *s)\\r\\n{\\r\\nconst unsigned char *rlist;\\r\\nstatic const unsigned char scsv_id[] = { 0, 0, 0xFF };\\r\\nsize_t i, rlistlen, num;\\r\\nif (!SSL_is_server(s))\\r\\nreturn;\\r\\nnum = SSL_get0_raw_cipherlist(s, NULL);\\r\\nrlistlen = SSL_get0_raw_cipherlist(s, &rlist);\\r\\nBIO_puts(bio, \"Client cipher list: \");\\r\\nfor (i = 0; i < rlistlen; i += num, rlist += num) {\\r\\nconst SSL_CIPHER *c = SSL_CIPHER_find(s, rlist);\\r\\nif (i)\\r\\nBIO_puts(bio, \":\");\\r\\nif (c)\\r\\nBIO_puts(bio, SSL_CIPHER_get_name(c));\\r\\nelse if (!memcmp(rlist, scsv_id - num + 3, num))\\r\\nBIO_puts(bio, \"SCSV\");\\r\\nelse {\\r\\nsize_t j;\\r\\nBIO_puts(bio, \"0x\");\\r\\nfor (j = 0; j < num; j++)\\r\\nBIO_printf(bio, \"%02X\", rlist[j]);\\r\\n}\\r\\n}\\r\\nBIO_puts(bio, \"\\n\");\\r\\n}\\r\\nvoid print_ssl_summary(BIO *bio, SSL *s)\\r\\n{\\r\\nconst SSL_CIPHER *c;\\r\\nX509 *peer;\\r\\nBIO_printf(bio, \"Protocol version: %s\\n\", SSL_get_version(s));\\r\\nprint_raw_cipherlist(bio, s);\\r\\nc = SSL_get_current_cipher(s);\\r\\nBIO_printf(bio, \"Ciphersuite: %s\\n\", SSL_CIPHER_get_name(c));\\r\\ndo_print_sigalgs(bio, s, 0);\\r\\npeer = SSL_get_peer_certificate(s);\\r\\nif (peer) {\\r\\nint nid;\\r\\nBIO_puts(bio, \"Peer certificate: \");\\r\\nX509_NAME_print_ex(bio, X509_get_subject_name(peer),\\r\\n0, XN_FLAG_ONELINE);\\r\\nBIO_puts(bio, \"\\n\");\\r\\nif (SSL_get_peer_signature_nid(s, &nid))\\r\\nBIO_printf(bio, \"Hash used: %s\\n\", OBJ_nid2sn(nid));\\r\\n} else\\r\\nBIO_puts(bio, \"No peer certificate\\n\");\\r\\nif (peer)\\r\\nX509_free(peer);\\r\\n#ifndef OPENSSL_NO_EC\\r\\nssl_print_point_formats(bio, s);\\r\\nif (SSL_is_server(s))\\r\\nssl_print_curves(bio, s, 1);\\r\\nelse\\r\\nssl_print_tmp_key(bio, s);\\r\\n#else\\r\\nif (!SSL_is_server(s))\\r\\nssl_print_tmp_key(bio, s);\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_i_ofb64_c", "target": 0, "func": "void idea_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, IDEA_KEY_SCHEDULE *schedule,\\r\\nunsigned char *ivec, int *num)\\r\\n{\\r\\nregister unsigned long v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv;\\r\\nint save = 0;\\r\\niv = (unsigned char *)ivec;\\r\\nn2l(iv, v0);\\r\\nn2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\ndp = (char *)d;\\r\\nl2n(v0, dp);\\r\\nl2n(v1, dp);\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nidea_encrypt((unsigned long *)ti, schedule);\\r\\ndp = (char *)d;\\r\\nt = ti[0];\\r\\nl2n(t, dp);\\r\\nt = ti[1];\\r\\nl2n(t, dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++) = *(in++) ^ d[n];\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\nif (save) {\\r\\nv0 = ti[0];\\r\\nv1 = ti[1];\\r\\niv = (unsigned char *)ivec;\\r\\nl2n(v0, iv);\\r\\nl2n(v1, iv);\\r\\n}\\r\\nt = v0 = v1 = ti[0] = ti[1] = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_obj_c", "target": 0, "func": "char *X509_NAME_oneline(X509_NAME *a, char *buf, int len)\\r\\n{\\r\\nX509_NAME_ENTRY *ne;\\r\\nint i;\\r\\nint n, lold, l, l1, l2, num, j, type;\\r\\nconst char *s;\\r\\nchar *p;\\r\\nunsigned char *q;\\r\\nBUF_MEM *b = NULL;\\r\\nstatic const char hex[17] = \"0123456789ABCDEF\";\\r\\nint gs_doit[4];\\r\\nchar tmp_buf[80];\\r\\n#ifdef CHARSET_EBCDIC\\r\\nchar ebcdic_buf[1024];\\r\\n#endif\\r\\nif (buf == NULL) {\\r\\nif ((b = BUF_MEM_new()) == NULL)\\r\\ngoto err;\\r\\nif (!BUF_MEM_grow(b, 200))\\r\\ngoto err;\\r\\nb->data[0] = '\\0';\\r\\nlen = 200;\\r\\n}\\r\\nif (a == NULL) {\\r\\nif (b) {\\r\\nbuf = b->data;\\r\\nOPENSSL_free(b);\\r\\n}\\r\\nstrncpy(buf, \"NO X509_NAME\", len);\\r\\nbuf[len - 1] = '\\0';\\r\\nreturn buf;\\r\\n}\\r\\nlen--;\\r\\nl = 0;\\r\\nfor (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\\r\\nne = sk_X509_NAME_ENTRY_value(a->entries, i);\\r\\nn = OBJ_obj2nid(ne->object);\\r\\nif ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {\\r\\ni2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);\\r\\ns = tmp_buf;\\r\\n}\\r\\nl1 = strlen(s);\\r\\ntype = ne->value->type;\\r\\nnum = ne->value->length;\\r\\nq = ne->value->data;\\r\\n#ifdef CHARSET_EBCDIC\\r\\nif (type == V_ASN1_GENERALSTRING ||\\r\\ntype == V_ASN1_VISIBLESTRING ||\\r\\ntype == V_ASN1_PRINTABLESTRING ||\\r\\ntype == V_ASN1_TELETEXSTRING ||\\r\\ntype == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) {\\r\\nascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf)\\r\\n? sizeof ebcdic_buf : num);\\r\\nq = ebcdic_buf;\\r\\n}\\r\\n#endif\\r\\nif ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {\\r\\ngs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;\\r\\nfor (j = 0; j < num; j++)\\r\\nif (q[j] != 0)\\r\\ngs_doit[j & 3] = 1;\\r\\nif (gs_doit[0] | gs_doit[1] | gs_doit[2])\\r\\ngs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\\r\\nelse {\\r\\ngs_doit[0] = gs_doit[1] = gs_doit[2] = 0;\\r\\ngs_doit[3] = 1;\\r\\n}\\r\\n} else\\r\\ngs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;\\r\\nfor (l2 = j = 0; j < num; j++) {\\r\\nif (!gs_doit[j & 3])\\r\\ncontinue;\\r\\nl2++;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif ((q[j] < ' ') || (q[j] > '~'))\\r\\nl2 += 3;\\r\\n#else\\r\\nif ((os_toascii[q[j]] < os_toascii[' ']) ||\\r\\n(os_toascii[q[j]] > os_toascii['~']))\\r\\nl2 += 3;\\r\\n#endif\\r\\n}\\r\\nlold = l;\\r\\nl += 1 + l1 + 1 + l2;\\r\\nif (b != NULL) {\\r\\nif (!BUF_MEM_grow(b, l + 1))\\r\\ngoto err;\\r\\np = &(b->data[lold]);\\r\\n} else if (l > len) {\\r\\nbreak;\\r\\n} else\\r\\np = &(buf[lold]);\\r\\n*(p++) = '/';\\r\\nmemcpy(p, s, (unsigned int)l1);\\r\\np += l1;\\r\\n*(p++) = '=';\\r\\n#ifndef CHARSET_EBCDIC\\r\\nq = ne->value->data;\\r\\n#endif\\r\\nfor (j = 0; j < num; j++) {\\r\\nif (!gs_doit[j & 3])\\r\\ncontinue;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nn = q[j];\\r\\nif ((n < ' ') || (n > '~')) {\\r\\n*(p++) = '\\\\';\\r\\n*(p++) = 'x';\\r\\n*(p++) = hex[(n >> 4) & 0x0f];\\r\\n*(p++) = hex[n & 0x0f];\\r\\n} else\\r\\n*(p++) = n;\\r\\n#else\\r\\nn = os_toascii[q[j]];\\r\\nif ((n < os_toascii[' ']) || (n > os_toascii['~'])) {\\r\\n*(p++) = '\\\\';\\r\\n*(p++) = 'x';\\r\\n*(p++) = hex[(n >> 4) & 0x0f];\\r\\n*(p++) = hex[n & 0x0f];\\r\\n} else\\r\\n*(p++) = q[j];\\r\\n#endif\\r\\n}\\r\\n*p = '\\0';\\r\\n}\\r\\nif (b != NULL) {\\r\\np = b->data;\\r\\nOPENSSL_free(b);\\r\\n} else\\r\\np = buf;\\r\\nif (i == 0)\\r\\n*p = '\\0';\\r\\nreturn (p);\\r\\nerr:\\r\\nX509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);\\r\\nif (b != NULL)\\r\\nBUF_MEM_free(b);\\r\\nreturn (NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_asn1_c", "target": 0, "func": "int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp)\\r\\n{\\r\\n#define LSIZE2 (sizeof(long)*2)\\r\\nint v1 = 0, v2 = 0, v3 = 0, v4 = 0, v5 = 0, v7 = 0, v8 = 0;\\r\\nunsigned char buf[4], ibuf1[LSIZE2], ibuf2[LSIZE2];\\r\\nunsigned char ibuf3[LSIZE2], ibuf4[LSIZE2], ibuf5[LSIZE2];\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nint v6 = 0, v9 = 0, v10 = 0;\\r\\nunsigned char ibuf6[LSIZE2];\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nunsigned char cbuf;\\r\\nint v11 = 0;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nint v12 = 0;\\r\\n#endif\\r\\nlong l;\\r\\nSSL_SESSION_ASN1 a;\\r\\nM_ASN1_I2D_vars(in);\\r\\nif ((in == NULL) || ((in->cipher == NULL) && (in->cipher_id == 0)))\\r\\nreturn (0);\\r\\na.version.length = LSIZE2;\\r\\na.version.type = V_ASN1_INTEGER;\\r\\na.version.data = ibuf1;\\r\\nASN1_INTEGER_set(&(a.version), SSL_SESSION_ASN1_VERSION);\\r\\na.ssl_version.length = LSIZE2;\\r\\na.ssl_version.type = V_ASN1_INTEGER;\\r\\na.ssl_version.data = ibuf2;\\r\\nASN1_INTEGER_set(&(a.ssl_version), in->ssl_version);\\r\\na.cipher.type = V_ASN1_OCTET_STRING;\\r\\na.cipher.data = buf;\\r\\nif (in->cipher == NULL)\\r\\nl = in->cipher_id;\\r\\nelse\\r\\nl = in->cipher->id;\\r\\nif (in->ssl_version == SSL2_VERSION) {\\r\\na.cipher.length = 3;\\r\\nbuf[0] = ((unsigned char)(l >> 16L)) & 0xff;\\r\\nbuf[1] = ((unsigned char)(l >> 8L)) & 0xff;\\r\\nbuf[2] = ((unsigned char)(l)) & 0xff;\\r\\n} else {\\r\\na.cipher.length = 2;\\r\\nbuf[0] = ((unsigned char)(l >> 8L)) & 0xff;\\r\\nbuf[1] = ((unsigned char)(l)) & 0xff;\\r\\n}\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nif (in->compress_meth) {\\r\\ncbuf = (unsigned char)in->compress_meth;\\r\\na.comp_id.length = 1;\\r\\na.comp_id.type = V_ASN1_OCTET_STRING;\\r\\na.comp_id.data = &cbuf;\\r\\n}\\r\\n#endif\\r\\na.master_key.length = in->master_key_length;\\r\\na.master_key.type = V_ASN1_OCTET_STRING;\\r\\na.master_key.data = in->master_key;\\r\\na.session_id.length = in->session_id_length;\\r\\na.session_id.type = V_ASN1_OCTET_STRING;\\r\\na.session_id.data = in->session_id;\\r\\na.session_id_context.length = in->sid_ctx_length;\\r\\na.session_id_context.type = V_ASN1_OCTET_STRING;\\r\\na.session_id_context.data = in->sid_ctx;\\r\\na.key_arg.length = in->key_arg_length;\\r\\na.key_arg.type = V_ASN1_OCTET_STRING;\\r\\na.key_arg.data = in->key_arg;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (in->krb5_client_princ_len) {\\r\\na.krb5_princ.length = in->krb5_client_princ_len;\\r\\na.krb5_princ.type = V_ASN1_OCTET_STRING;\\r\\na.krb5_princ.data = in->krb5_client_princ;\\r\\n}\\r\\n#endif\\r\\nif (in->time != 0L) {\\r\\na.time.length = LSIZE2;\\r\\na.time.type = V_ASN1_INTEGER;\\r\\na.time.data = ibuf3;\\r\\nASN1_INTEGER_set(&(a.time), in->time);\\r\\n}\\r\\nif (in->timeout != 0L) {\\r\\na.timeout.length = LSIZE2;\\r\\na.timeout.type = V_ASN1_INTEGER;\\r\\na.timeout.data = ibuf4;\\r\\nASN1_INTEGER_set(&(a.timeout), in->timeout);\\r\\n}\\r\\nif (in->verify_result != X509_V_OK) {\\r\\na.verify_result.length = LSIZE2;\\r\\na.verify_result.type = V_ASN1_INTEGER;\\r\\na.verify_result.data = ibuf5;\\r\\nASN1_INTEGER_set(&a.verify_result, in->verify_result);\\r\\n}\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (in->tlsext_hostname) {\\r\\na.tlsext_hostname.length = strlen(in->tlsext_hostname);\\r\\na.tlsext_hostname.type = V_ASN1_OCTET_STRING;\\r\\na.tlsext_hostname.data = (unsigned char *)in->tlsext_hostname;\\r\\n}\\r\\nif (in->tlsext_tick) {\\r\\na.tlsext_tick.length = in->tlsext_ticklen;\\r\\na.tlsext_tick.type = V_ASN1_OCTET_STRING;\\r\\na.tlsext_tick.data = (unsigned char *)in->tlsext_tick;\\r\\n}\\r\\nif (in->tlsext_tick_lifetime_hint > 0) {\\r\\na.tlsext_tick_lifetime.length = LSIZE2;\\r\\na.tlsext_tick_lifetime.type = V_ASN1_INTEGER;\\r\\na.tlsext_tick_lifetime.data = ibuf6;\\r\\nASN1_INTEGER_set(&a.tlsext_tick_lifetime,\\r\\nin->tlsext_tick_lifetime_hint);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nif (in->psk_identity_hint) {\\r\\na.psk_identity_hint.length = strlen(in->psk_identity_hint);\\r\\na.psk_identity_hint.type = V_ASN1_OCTET_STRING;\\r\\na.psk_identity_hint.data = (unsigned char *)(in->psk_identity_hint);\\r\\n}\\r\\nif (in->psk_identity) {\\r\\na.psk_identity.length = strlen(in->psk_identity);\\r\\na.psk_identity.type = V_ASN1_OCTET_STRING;\\r\\na.psk_identity.data = (unsigned char *)(in->psk_identity);\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nif (in->srp_username) {\\r\\na.srp_username.length = strlen(in->srp_username);\\r\\na.srp_username.type = V_ASN1_OCTET_STRING;\\r\\na.srp_username.data = (unsigned char *)(in->srp_username);\\r\\n}\\r\\n#endif\\r\\nM_ASN1_I2D_len(&(a.version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(&(a.ssl_version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_len(&(a.cipher), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len(&(a.session_id), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_len(&(a.master_key), i2d_ASN1_OCTET_STRING);\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (in->krb5_client_princ_len)\\r\\nM_ASN1_I2D_len(&(a.krb5_princ), i2d_ASN1_OCTET_STRING);\\r\\n#endif\\r\\nif (in->key_arg_length > 0)\\r\\nM_ASN1_I2D_len_IMP_opt(&(a.key_arg), i2d_ASN1_OCTET_STRING);\\r\\nif (in->time != 0L)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.time), i2d_ASN1_INTEGER, 1, v1);\\r\\nif (in->timeout != 0L)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.timeout), i2d_ASN1_INTEGER, 2, v2);\\r\\nif (in->peer != NULL)\\r\\nM_ASN1_I2D_len_EXP_opt(in->peer, i2d_X509, 3, v3);\\r\\nM_ASN1_I2D_len_EXP_opt(&a.session_id_context, i2d_ASN1_OCTET_STRING, 4,\\r\\nv4);\\r\\nif (in->verify_result != X509_V_OK)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.verify_result), i2d_ASN1_INTEGER, 5, v5);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (in->tlsext_tick_lifetime_hint > 0)\\r\\nM_ASN1_I2D_len_EXP_opt(&a.tlsext_tick_lifetime, i2d_ASN1_INTEGER, 9,\\r\\nv9);\\r\\nif (in->tlsext_tick)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.tlsext_tick), i2d_ASN1_OCTET_STRING, 10,\\r\\nv10);\\r\\nif (in->tlsext_hostname)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.tlsext_hostname), i2d_ASN1_OCTET_STRING, 6,\\r\\nv6);\\r\\n# ifndef OPENSSL_NO_COMP\\r\\nif (in->compress_meth)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.comp_id), i2d_ASN1_OCTET_STRING, 11, v11);\\r\\n# endif\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nif (in->psk_identity_hint)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.psk_identity_hint), i2d_ASN1_OCTET_STRING,\\r\\n7, v7);\\r\\nif (in->psk_identity)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.psk_identity), i2d_ASN1_OCTET_STRING, 8,\\r\\nv8);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nif (in->srp_username)\\r\\nM_ASN1_I2D_len_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING, 12,\\r\\nv12);\\r\\n#endif\\r\\nM_ASN1_I2D_seq_total();\\r\\nM_ASN1_I2D_put(&(a.version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(&(a.ssl_version), i2d_ASN1_INTEGER);\\r\\nM_ASN1_I2D_put(&(a.cipher), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put(&(a.session_id), i2d_ASN1_OCTET_STRING);\\r\\nM_ASN1_I2D_put(&(a.master_key), i2d_ASN1_OCTET_STRING);\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nif (in->krb5_client_princ_len)\\r\\nM_ASN1_I2D_put(&(a.krb5_princ), i2d_ASN1_OCTET_STRING);\\r\\n#endif\\r\\nif (in->key_arg_length > 0)\\r\\nM_ASN1_I2D_put_IMP_opt(&(a.key_arg), i2d_ASN1_OCTET_STRING, 0);\\r\\nif (in->time != 0L)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.time), i2d_ASN1_INTEGER, 1, v1);\\r\\nif (in->timeout != 0L)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.timeout), i2d_ASN1_INTEGER, 2, v2);\\r\\nif (in->peer != NULL)\\r\\nM_ASN1_I2D_put_EXP_opt(in->peer, i2d_X509, 3, v3);\\r\\nM_ASN1_I2D_put_EXP_opt(&a.session_id_context, i2d_ASN1_OCTET_STRING, 4,\\r\\nv4);\\r\\nif (in->verify_result != X509_V_OK)\\r\\nM_ASN1_I2D_put_EXP_opt(&a.verify_result, i2d_ASN1_INTEGER, 5, v5);\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (in->tlsext_hostname)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.tlsext_hostname), i2d_ASN1_OCTET_STRING, 6,\\r\\nv6);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nif (in->psk_identity_hint)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.psk_identity_hint), i2d_ASN1_OCTET_STRING,\\r\\n7, v7);\\r\\nif (in->psk_identity)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.psk_identity), i2d_ASN1_OCTET_STRING, 8,\\r\\nv8);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nif (in->tlsext_tick_lifetime_hint > 0)\\r\\nM_ASN1_I2D_put_EXP_opt(&a.tlsext_tick_lifetime, i2d_ASN1_INTEGER, 9,\\r\\nv9);\\r\\nif (in->tlsext_tick)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.tlsext_tick), i2d_ASN1_OCTET_STRING, 10,\\r\\nv10);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nif (in->compress_meth)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.comp_id), i2d_ASN1_OCTET_STRING, 11, v11);\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nif (in->srp_username)\\r\\nM_ASN1_I2D_put_EXP_opt(&(a.srp_username), i2d_ASN1_OCTET_STRING, 12,\\r\\nv12);\\r\\n#endif\\r\\nM_ASN1_I2D_finish();\\r\\n}\\r\\nSSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nint ssl_version = 0, i;\\r\\nlong id;\\r\\nASN1_INTEGER ai, *aip;\\r\\nASN1_OCTET_STRING os, *osp;\\r\\nM_ASN1_D2I_vars(a, SSL_SESSION *, SSL_SESSION_new);\\r\\naip = &ai;\\r\\nosp = &os;\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nai.data = NULL;\\r\\nai.length = 0;\\r\\nM_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\\r\\nif (ai.data != NULL) {\\r\\nOPENSSL_free(ai.data);\\r\\nai.data = NULL;\\r\\nai.length = 0;\\r\\n}\\r\\nM_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\\r\\nssl_version = (int)ASN1_INTEGER_get(aip);\\r\\nret->ssl_version = ssl_version;\\r\\nif (ai.data != NULL) {\\r\\nOPENSSL_free(ai.data);\\r\\nai.data = NULL;\\r\\nai.length = 0;\\r\\n}\\r\\nos.data = NULL;\\r\\nos.length = 0;\\r\\nM_ASN1_D2I_get_x(ASN1_OCTET_STRING, osp, d2i_ASN1_OCTET_STRING);\\r\\nif (ssl_version == SSL2_VERSION) {\\r\\nif (os.length != 3) {\\r\\nc.error = SSL_R_CIPHER_CODE_WRONG_LENGTH;\\r\\nc.line = __LINE__;\\r\\ngoto err;\\r\\n}\\r\\nid = 0x02000000L |\\r\\n((unsigned long)os.data[0] << 16L) |\\r\\n((unsigned long)os.data[1] << 8L) | (unsigned long)os.data[2];\\r\\n} else if ((ssl_version >> 8) >= SSL3_VERSION_MAJOR) {\\r\\nif (os.length != 2) {\\r\\nc.error = SSL_R_CIPHER_CODE_WRONG_LENGTH;\\r\\nc.line = __LINE__;\\r\\ngoto err;\\r\\n}\\r\\nid = 0x03000000L |\\r\\n((unsigned long)os.data[0] << 8L) | (unsigned long)os.data[1];\\r\\n} else {\\r\\nc.error = SSL_R_UNKNOWN_SSL_VERSION;\\r\\nc.line = __LINE__;\\r\\ngoto err;\\r\\n}\\r\\nret->cipher = NULL;\\r\\nret->cipher_id = id;\\r\\nM_ASN1_D2I_get_x(ASN1_OCTET_STRING, osp, d2i_ASN1_OCTET_STRING);\\r\\nif ((ssl_version >> 8) >= SSL3_VERSION_MAJOR)\\r\\ni = SSL3_MAX_SSL_SESSION_ID_LENGTH;\\r\\nelse\\r\\ni = SSL2_MAX_SSL_SESSION_ID_LENGTH;\\r\\nif (os.length > i)\\r\\nos.length = i;\\r\\nif (os.length > (int)sizeof(ret->session_id))\\r\\nos.length = sizeof(ret->session_id);\\r\\nret->session_id_length = os.length;\\r\\nOPENSSL_assert(os.length <= (int)sizeof(ret->session_id));\\r\\nmemcpy(ret->session_id, os.data, os.length);\\r\\nM_ASN1_D2I_get_x(ASN1_OCTET_STRING, osp, d2i_ASN1_OCTET_STRING);\\r\\nif (os.length > SSL_MAX_MASTER_KEY_LENGTH)\\r\\nret->master_key_length = SSL_MAX_MASTER_KEY_LENGTH;\\r\\nelse\\r\\nret->master_key_length = os.length;\\r\\nmemcpy(ret->master_key, os.data, ret->master_key_length);\\r\\nos.length = 0;\\r\\n#ifndef OPENSSL_NO_KRB5\\r\\nos.length = 0;\\r\\nM_ASN1_D2I_get_opt(osp, d2i_ASN1_OCTET_STRING, V_ASN1_OCTET_STRING);\\r\\nif (os.data) {\\r\\nif (os.length > SSL_MAX_KRB5_PRINCIPAL_LENGTH)\\r\\nret->krb5_client_princ_len = 0;\\r\\nelse\\r\\nret->krb5_client_princ_len = os.length;\\r\\nmemcpy(ret->krb5_client_princ, os.data, ret->krb5_client_princ_len);\\r\\nOPENSSL_free(os.data);\\r\\nos.data = NULL;\\r\\nos.length = 0;\\r\\n} else\\r\\nret->krb5_client_princ_len = 0;\\r\\n#endif\\r\\nM_ASN1_D2I_get_IMP_opt(osp, d2i_ASN1_OCTET_STRING, 0,\\r\\nV_ASN1_OCTET_STRING);\\r\\nif (os.length > SSL_MAX_KEY_ARG_LENGTH)\\r\\nret->key_arg_length = SSL_MAX_KEY_ARG_LENGTH;\\r\\nelse\\r\\nret->key_arg_length = os.length;\\r\\nmemcpy(ret->key_arg, os.data, ret->key_arg_length);\\r\\nif (os.data != NULL)\\r\\nOPENSSL_free(os.data);\\r\\nai.length = 0;\\r\\nM_ASN1_D2I_get_EXP_opt(aip, d2i_ASN1_INTEGER, 1);\\r\\nif (ai.data != NULL) {\\r\\nret->time = ASN1_INTEGER_get(aip);\\r\\nOPENSSL_free(ai.data);\\r\\nai.data = NULL;\\r\\nai.length = 0;\\r\\n} else\\r\\nret->time = (unsigned long)time(NULL);\\r\\nai.length = 0;\\r\\nM_ASN1_D2I_get_EXP_opt(aip, d2i_ASN1_INTEGER, 2);\\r\\nif (ai.data != NULL) {\\r\\nret->timeout = ASN1_INTEGER_get(aip);\\r\\nOPENSSL_free(ai.data);\\r\\nai.data = NULL;\\r\\nai.length = 0;\\r\\n} else\\r\\nret->timeout = 3;\\r\\nif (ret->peer != NULL) {\\r\\nX509_free(ret->peer);\\r\\nret->peer = NULL;\\r\\n}\\r\\nM_ASN1_D2I_get_EXP_opt(ret->peer, d2i_X509, 3);\\r\\nos.length = 0;\\r\\nos.data = NULL;\\r\\nM_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 4);\\r\\nif (os.data != NULL) {\\r\\nif (os.length > SSL_MAX_SID_CTX_LENGTH) {\\r\\nc.error = SSL_R_BAD_LENGTH;\\r\\nc.line = __LINE__;\\r\\ngoto err;\\r\\n} else {\\r\\nret->sid_ctx_length = os.length;\\r\\nmemcpy(ret->sid_ctx, os.data, os.length);\\r\\n}\\r\\nOPENSSL_free(os.data);\\r\\nos.data = NULL;\\r\\nos.length = 0;\\r\\n} else\\r\\nret->sid_ctx_length = 0;\\r\\nai.length = 0;\\r\\nM_ASN1_D2I_get_EXP_opt(aip, d2i_ASN1_INTEGER, 5);\\r\\nif (ai.data != NULL) {\\r\\nret->verify_result = ASN1_INTEGER_get(aip);\\r\\nOPENSSL_free(ai.data);\\r\\nai.data = NULL;\\r\\nai.length = 0;\\r\\n} else\\r\\nret->verify_result = X509_V_OK;\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nos.length = 0;\\r\\nos.data = NULL;\\r\\nM_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 6);\\r\\nif (os.data) {\\r\\nret->tlsext_hostname = BUF_strndup((char *)os.data, os.length);\\r\\nOPENSSL_free(os.data);\\r\\nos.data = NULL;\\r\\nos.length = 0;\\r\\n} else\\r\\nret->tlsext_hostname = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_PSK\\r\\nos.length = 0;\\r\\nos.data = NULL;\\r\\nM_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 7);\\r\\nif (os.data) {\\r\\nret->psk_identity_hint = BUF_strndup((char *)os.data, os.length);\\r\\nOPENSSL_free(os.data);\\r\\nos.data = NULL;\\r\\nos.length = 0;\\r\\n} else\\r\\nret->psk_identity_hint = NULL;\\r\\nos.length = 0;\\r\\nos.data = NULL;\\r\\nM_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 8);\\r\\nif (os.data) {\\r\\nret->psk_identity = BUF_strndup((char *)os.data, os.length);\\r\\nOPENSSL_free(os.data);\\r\\nos.data = NULL;\\r\\nos.length = 0;\\r\\n} else\\r\\nret->psk_identity = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_TLSEXT\\r\\nai.length = 0;\\r\\nM_ASN1_D2I_get_EXP_opt(aip, d2i_ASN1_INTEGER, 9);\\r\\nif (ai.data != NULL) {\\r\\nret->tlsext_tick_lifetime_hint = ASN1_INTEGER_get(aip);\\r\\nOPENSSL_free(ai.data);\\r\\nai.data = NULL;\\r\\nai.length = 0;\\r\\n} else if (ret->tlsext_ticklen && ret->session_id_length)\\r\\nret->tlsext_tick_lifetime_hint = -1;\\r\\nelse\\r\\nret->tlsext_tick_lifetime_hint = 0;\\r\\nos.length = 0;\\r\\nos.data = NULL;\\r\\nM_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 10);\\r\\nif (os.data) {\\r\\nret->tlsext_tick = os.data;\\r\\nret->tlsext_ticklen = os.length;\\r\\nos.data = NULL;\\r\\nos.length = 0;\\r\\n} else\\r\\nret->tlsext_tick = NULL;\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nos.length = 0;\\r\\nos.data = NULL;\\r\\nM_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 11);\\r\\nif (os.data) {\\r\\nret->compress_meth = os.data[0];\\r\\nOPENSSL_free(os.data);\\r\\nos.data = NULL;\\r\\n}\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_SRP\\r\\nos.length = 0;\\r\\nos.data = NULL;\\r\\nM_ASN1_D2I_get_EXP_opt(osp, d2i_ASN1_OCTET_STRING, 12);\\r\\nif (os.data) {\\r\\nret->srp_username = BUF_strndup((char *)os.data, os.length);\\r\\nOPENSSL_free(os.data);\\r\\nos.data = NULL;\\r\\nos.length = 0;\\r\\n} else\\r\\nret->srp_username = NULL;\\r\\n#endif\\r\\nM_ASN1_D2I_Finish(a, SSL_SESSION_free, SSL_F_D2I_SSL_SESSION);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_vms_decc_init_c", "target": 0, "func": "static void decc_init(void)\\r\\n{\\r\\nchar *openssl_debug_decc_init;\\r\\nint verbose = 0;\\r\\nint feat_index;\\r\\nint feat_value;\\r\\nint feat_value_max;\\r\\nint feat_value_min;\\r\\nint i;\\r\\nint sts;\\r\\nopenssl_debug_decc_init = getenv(\"OPENSSL_DEBUG_DECC_INIT\");\\r\\nif (openssl_debug_decc_init != NULL) {\\r\\nverbose = strtol(openssl_debug_decc_init, NULL, 10);\\r\\nif (verbose <= 0) {\\r\\nverbose = 1;\\r\\n}\\r\\n}\\r\\ndecc_init_done = 1;\\r\\nfor (i = 0; decc_feat_array[i].name != NULL; i++) {\\r\\nfeat_index = decc$feature_get_index(decc_feat_array[i].name);\\r\\nif (feat_index >= 0) {\\r\\nfeat_value = decc$feature_get_value(feat_index, 1);\\r\\nfeat_value_min = decc$feature_get_value(feat_index, 2);\\r\\nfeat_value_max = decc$feature_get_value(feat_index, 3);\\r\\nif ((decc_feat_array[i].value >= feat_value_min) &&\\r\\n(decc_feat_array[i].value <= feat_value_max)) {\\r\\nif (feat_value != decc_feat_array[i].value) {\\r\\nsts = decc$feature_set_value(feat_index,\\r\\n1, decc_feat_array[i].value);\\r\\nif (verbose > 1) {\\r\\nfprintf(stderr, \" %s = %d, sts = %d.\\n\",\\r\\ndecc_feat_array[i].name,\\r\\ndecc_feat_array[i].value, sts);\\r\\n}\\r\\n}\\r\\n} else {\\r\\nfprintf(stderr,\\r\\n\" INVALID DECC$FEATURE VALUE, %d: %d <= %s <= %d.\\n\",\\r\\nfeat_value,\\r\\nfeat_value_min, decc_feat_array[i].name,\\r\\nfeat_value_max);\\r\\n}\\r\\n} else {\\r\\nfprintf(stderr,\\r\\n\" UNKNOWN DECC$FEATURE: %s.\\n\", decc_feat_array[i].name);\\r\\n}\\r\\n}\\r\\nif (verbose > 0) {\\r\\nfprintf(stderr, \" DECC_INIT complete.\\n\");\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3err_c", "target": 0, "func": "void ERR_load_X509V3_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(X509V3_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, X509V3_str_functs);\\r\\nERR_load_strings(0, X509V3_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cmll_misc_c", "target": 0, "func": "int private_Camellia_set_key(const unsigned char *userKey, const int bits,\\r\\nCAMELLIA_KEY *key)\\r\\n{\\r\\nif (!userKey || !key)\\r\\nreturn -1;\\r\\nif (bits != 128 && bits != 192 && bits != 256)\\r\\nreturn -2;\\r\\nkey->grand_rounds = Camellia_Ekeygen(bits, userKey, key->u.rd_key);\\r\\nreturn 0;\\r\\n}\\r\\nvoid Camellia_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst CAMELLIA_KEY *key)\\r\\n{\\r\\nCamellia_EncryptBlock_Rounds(key->grand_rounds, in, key->u.rd_key, out);\\r\\n}\\r\\nvoid Camellia_decrypt(const unsigned char *in, unsigned char *out,\\r\\nconst CAMELLIA_KEY *key)\\r\\n{\\r\\nCamellia_DecryptBlock_Rounds(key->grand_rounds, in, key->u.rd_key, out);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_wrap128_c", "target": 0, "func": "size_t CRYPTO_128_wrap(void *key, const unsigned char *iv,\\r\\nunsigned char *out,\\r\\nconst unsigned char *in, size_t inlen,\\r\\nblock128_f block)\\r\\n{\\r\\nunsigned char *A, B[16], *R;\\r\\nsize_t i, j, t;\\r\\nif ((inlen & 0x7) || (inlen < 8) || (inlen > CRYPTO128_WRAP_MAX))\\r\\nreturn 0;\\r\\nA = B;\\r\\nt = 1;\\r\\nmemcpy(out + 8, in, inlen);\\r\\nif (!iv)\\r\\niv = default_iv;\\r\\nmemcpy(A, iv, 8);\\r\\nfor (j = 0; j < 6; j++) {\\r\\nR = out + 8;\\r\\nfor (i = 0; i < inlen; i += 8, t++, R += 8) {\\r\\nmemcpy(B + 8, R, 8);\\r\\nblock(B, B, key);\\r\\nA[7] ^= (unsigned char)(t & 0xff);\\r\\nif (t > 0xff) {\\r\\nA[6] ^= (unsigned char)((t >> 8) & 0xff);\\r\\nA[5] ^= (unsigned char)((t >> 16) & 0xff);\\r\\nA[4] ^= (unsigned char)((t >> 24) & 0xff);\\r\\n}\\r\\nmemcpy(R, B + 8, 8);\\r\\n}\\r\\n}\\r\\nmemcpy(out, A, 8);\\r\\nreturn inlen + 8;\\r\\n}\\r\\nsize_t CRYPTO_128_unwrap(void *key, const unsigned char *iv,\\r\\nunsigned char *out,\\r\\nconst unsigned char *in, size_t inlen,\\r\\nblock128_f block)\\r\\n{\\r\\nunsigned char *A, B[16], *R;\\r\\nsize_t i, j, t;\\r\\ninlen -= 8;\\r\\nif ((inlen & 0x7) || (inlen < 16) || (inlen > CRYPTO128_WRAP_MAX))\\r\\nreturn 0;\\r\\nA = B;\\r\\nt = 6 * (inlen >> 3);\\r\\nmemcpy(A, in, 8);\\r\\nmemcpy(out, in + 8, inlen);\\r\\nfor (j = 0; j < 6; j++) {\\r\\nR = out + inlen - 8;\\r\\nfor (i = 0; i < inlen; i += 8, t--, R -= 8) {\\r\\nA[7] ^= (unsigned char)(t & 0xff);\\r\\nif (t > 0xff) {\\r\\nA[6] ^= (unsigned char)((t >> 8) & 0xff);\\r\\nA[5] ^= (unsigned char)((t >> 16) & 0xff);\\r\\nA[4] ^= (unsigned char)((t >> 24) & 0xff);\\r\\n}\\r\\nmemcpy(B + 8, R, 8);\\r\\nblock(B, B, key);\\r\\nmemcpy(R, B + 8, 8);\\r\\n}\\r\\n}\\r\\nif (!iv)\\r\\niv = default_iv;\\r\\nif (memcmp(A, iv, 8)) {\\r\\nOPENSSL_cleanse(out, inlen);\\r\\nreturn 0;\\r\\n}\\r\\nreturn inlen;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_enc_c", "target": 0, "func": "void BF_encrypt(BF_LONG *data, const BF_KEY *key)\\r\\n{\\r\\n#ifndef BF_PTR2\\r\\nregister BF_LONG l, r;\\r\\nregister const BF_LONG *p, *s;\\r\\np = key->P;\\r\\ns = &(key->S[0]);\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nl ^= p[0];\\r\\nBF_ENC(r, l, s, p[1]);\\r\\nBF_ENC(l, r, s, p[2]);\\r\\nBF_ENC(r, l, s, p[3]);\\r\\nBF_ENC(l, r, s, p[4]);\\r\\nBF_ENC(r, l, s, p[5]);\\r\\nBF_ENC(l, r, s, p[6]);\\r\\nBF_ENC(r, l, s, p[7]);\\r\\nBF_ENC(l, r, s, p[8]);\\r\\nBF_ENC(r, l, s, p[9]);\\r\\nBF_ENC(l, r, s, p[10]);\\r\\nBF_ENC(r, l, s, p[11]);\\r\\nBF_ENC(l, r, s, p[12]);\\r\\nBF_ENC(r, l, s, p[13]);\\r\\nBF_ENC(l, r, s, p[14]);\\r\\nBF_ENC(r, l, s, p[15]);\\r\\nBF_ENC(l, r, s, p[16]);\\r\\n# if BF_ROUNDS == 20\\r\\nBF_ENC(r, l, s, p[17]);\\r\\nBF_ENC(l, r, s, p[18]);\\r\\nBF_ENC(r, l, s, p[19]);\\r\\nBF_ENC(l, r, s, p[20]);\\r\\n# endif\\r\\nr ^= p[BF_ROUNDS + 1];\\r\\ndata[1] = l & 0xffffffffL;\\r\\ndata[0] = r & 0xffffffffL;\\r\\n#else\\r\\nregister BF_LONG l, r, t, *k;\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nk = (BF_LONG *)key;\\r\\nl ^= k[0];\\r\\nBF_ENC(r, l, k, 1);\\r\\nBF_ENC(l, r, k, 2);\\r\\nBF_ENC(r, l, k, 3);\\r\\nBF_ENC(l, r, k, 4);\\r\\nBF_ENC(r, l, k, 5);\\r\\nBF_ENC(l, r, k, 6);\\r\\nBF_ENC(r, l, k, 7);\\r\\nBF_ENC(l, r, k, 8);\\r\\nBF_ENC(r, l, k, 9);\\r\\nBF_ENC(l, r, k, 10);\\r\\nBF_ENC(r, l, k, 11);\\r\\nBF_ENC(l, r, k, 12);\\r\\nBF_ENC(r, l, k, 13);\\r\\nBF_ENC(l, r, k, 14);\\r\\nBF_ENC(r, l, k, 15);\\r\\nBF_ENC(l, r, k, 16);\\r\\n# if BF_ROUNDS == 20\\r\\nBF_ENC(r, l, k, 17);\\r\\nBF_ENC(l, r, k, 18);\\r\\nBF_ENC(r, l, k, 19);\\r\\nBF_ENC(l, r, k, 20);\\r\\n# endif\\r\\nr ^= k[BF_ROUNDS + 1];\\r\\ndata[1] = l & 0xffffffffL;\\r\\ndata[0] = r & 0xffffffffL;\\r\\n#endif\\r\\n}\\r\\nvoid BF_decrypt(BF_LONG *data, const BF_KEY *key)\\r\\n{\\r\\n# ifndef BF_PTR2\\r\\nregister BF_LONG l, r;\\r\\nregister const BF_LONG *p, *s;\\r\\np = key->P;\\r\\ns = &(key->S[0]);\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nl ^= p[BF_ROUNDS + 1];\\r\\n# if BF_ROUNDS == 20\\r\\nBF_ENC(r, l, s, p[20]);\\r\\nBF_ENC(l, r, s, p[19]);\\r\\nBF_ENC(r, l, s, p[18]);\\r\\nBF_ENC(l, r, s, p[17]);\\r\\n# endif\\r\\nBF_ENC(r, l, s, p[16]);\\r\\nBF_ENC(l, r, s, p[15]);\\r\\nBF_ENC(r, l, s, p[14]);\\r\\nBF_ENC(l, r, s, p[13]);\\r\\nBF_ENC(r, l, s, p[12]);\\r\\nBF_ENC(l, r, s, p[11]);\\r\\nBF_ENC(r, l, s, p[10]);\\r\\nBF_ENC(l, r, s, p[9]);\\r\\nBF_ENC(r, l, s, p[8]);\\r\\nBF_ENC(l, r, s, p[7]);\\r\\nBF_ENC(r, l, s, p[6]);\\r\\nBF_ENC(l, r, s, p[5]);\\r\\nBF_ENC(r, l, s, p[4]);\\r\\nBF_ENC(l, r, s, p[3]);\\r\\nBF_ENC(r, l, s, p[2]);\\r\\nBF_ENC(l, r, s, p[1]);\\r\\nr ^= p[0];\\r\\ndata[1] = l & 0xffffffffL;\\r\\ndata[0] = r & 0xffffffffL;\\r\\n# else\\r\\nregister BF_LONG l, r, t, *k;\\r\\nl = data[0];\\r\\nr = data[1];\\r\\nk = (BF_LONG *)key;\\r\\nl ^= k[BF_ROUNDS + 1];\\r\\n# if BF_ROUNDS == 20\\r\\nBF_ENC(r, l, k, 20);\\r\\nBF_ENC(l, r, k, 19);\\r\\nBF_ENC(r, l, k, 18);\\r\\nBF_ENC(l, r, k, 17);\\r\\n# endif\\r\\nBF_ENC(r, l, k, 16);\\r\\nBF_ENC(l, r, k, 15);\\r\\nBF_ENC(r, l, k, 14);\\r\\nBF_ENC(l, r, k, 13);\\r\\nBF_ENC(r, l, k, 12);\\r\\nBF_ENC(l, r, k, 11);\\r\\nBF_ENC(r, l, k, 10);\\r\\nBF_ENC(l, r, k, 9);\\r\\nBF_ENC(r, l, k, 8);\\r\\nBF_ENC(l, r, k, 7);\\r\\nBF_ENC(r, l, k, 6);\\r\\nBF_ENC(l, r, k, 5);\\r\\nBF_ENC(r, l, k, 4);\\r\\nBF_ENC(l, r, k, 3);\\r\\nBF_ENC(r, l, k, 2);\\r\\nBF_ENC(l, r, k, 1);\\r\\nr ^= k[0];\\r\\ndata[1] = l & 0xffffffffL;\\r\\ndata[0] = r & 0xffffffffL;\\r\\n# endif\\r\\n}\\r\\nvoid BF_cbc_encrypt(const unsigned char *in, unsigned char *out, long length,\\r\\nconst BF_KEY *schedule, unsigned char *ivec, int encrypt)\\r\\n{\\r\\nregister BF_LONG tin0, tin1;\\r\\nregister BF_LONG tout0, tout1, xor0, xor1;\\r\\nregister long l = length;\\r\\nBF_LONG tin[2];\\r\\nif (encrypt) {\\r\\nn2l(ivec, tout0);\\r\\nn2l(ivec, tout1);\\r\\nivec -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nBF_encrypt(tin, schedule);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\n}\\r\\nif (l != -8) {\\r\\nn2ln(in, tin0, tin1, l + 8);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nBF_encrypt(tin, schedule);\\r\\ntout0 = tin[0];\\r\\ntout1 = tin[1];\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\n}\\r\\nl2n(tout0, ivec);\\r\\nl2n(tout1, ivec);\\r\\n} else {\\r\\nn2l(ivec, xor0);\\r\\nn2l(ivec, xor1);\\r\\nivec -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nBF_decrypt(tin, schedule);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nif (l != -8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nBF_decrypt(tin, schedule);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2nn(tout0, tout1, out, l + 8);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nl2n(xor0, ivec);\\r\\nl2n(xor1, ivec);\\r\\n}\\r\\ntin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;\\r\\ntin[0] = tin[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p_enc_c", "target": 0, "func": "int EVP_PKEY_encrypt_old(unsigned char *ek, const unsigned char *key,\\r\\nint key_len, EVP_PKEY *pubk)\\r\\n{\\r\\nint ret = 0;\\r\\n#ifndef OPENSSL_NO_RSA\\r\\nif (pubk->type != EVP_PKEY_RSA) {\\r\\n#endif\\r\\nEVPerr(EVP_F_EVP_PKEY_ENCRYPT_OLD, EVP_R_PUBLIC_KEY_NOT_RSA);\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ngoto err;\\r\\n}\\r\\nret =\\r\\nRSA_public_encrypt(key_len, key, ek, pubk->pkey.rsa,\\r\\nRSA_PKCS1_PADDING);\\r\\nerr:\\r\\n#endif\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_name_c", "target": 0, "func": "static int x509_name_ex_new(ASN1_VALUE **val, const ASN1_ITEM *it)\\r\\n{\\r\\nX509_NAME *ret = NULL;\\r\\nret = OPENSSL_malloc(sizeof(X509_NAME));\\r\\nif (!ret)\\r\\ngoto memerr;\\r\\nif ((ret->entries = sk_X509_NAME_ENTRY_new_null()) == NULL)\\r\\ngoto memerr;\\r\\nif ((ret->bytes = BUF_MEM_new()) == NULL)\\r\\ngoto memerr;\\r\\nret->canon_enc = NULL;\\r\\nret->canon_enclen = 0;\\r\\nret->modified = 1;\\r\\n*val = (ASN1_VALUE *)ret;\\r\\nreturn 1;\\r\\nmemerr:\\r\\nASN1err(ASN1_F_X509_NAME_EX_NEW, ERR_R_MALLOC_FAILURE);\\r\\nif (ret) {\\r\\nif (ret->entries)\\r\\nsk_X509_NAME_ENTRY_free(ret->entries);\\r\\nOPENSSL_free(ret);\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic void x509_name_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nX509_NAME *a;\\r\\nif (!pval || !*pval)\\r\\nreturn;\\r\\na = (X509_NAME *)*pval;\\r\\nBUF_MEM_free(a->bytes);\\r\\nsk_X509_NAME_ENTRY_pop_free(a->entries, X509_NAME_ENTRY_free);\\r\\nif (a->canon_enc)\\r\\nOPENSSL_free(a->canon_enc);\\r\\nOPENSSL_free(a);\\r\\n*pval = NULL;\\r\\n}\\r\\nstatic int x509_name_ex_d2i(ASN1_VALUE **val,\\r\\nconst unsigned char **in, long len,\\r\\nconst ASN1_ITEM *it, int tag, int aclass,\\r\\nchar opt, ASN1_TLC *ctx)\\r\\n{\\r\\nconst unsigned char *p = *in, *q;\\r\\nunion {\\r\\nSTACK_OF(STACK_OF_X509_NAME_ENTRY) *s;\\r\\nASN1_VALUE *a;\\r\\n} intname = {\\r\\nNULL\\r\\n};\\r\\nunion {\\r\\nX509_NAME *x;\\r\\nASN1_VALUE *a;\\r\\n} nm = {\\r\\nNULL\\r\\n};\\r\\nint i, j, ret;\\r\\nSTACK_OF(X509_NAME_ENTRY) *entries;\\r\\nX509_NAME_ENTRY *entry;\\r\\nq = p;\\r\\nret = ASN1_item_ex_d2i(&intname.a,\\r\\n&p, len, ASN1_ITEM_rptr(X509_NAME_INTERNAL),\\r\\ntag, aclass, opt, ctx);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\nif (*val)\\r\\nx509_name_ex_free(val, NULL);\\r\\nif (!x509_name_ex_new(&nm.a, NULL))\\r\\ngoto err;\\r\\nif (!BUF_MEM_grow(nm.x->bytes, p - q))\\r\\ngoto err;\\r\\nmemcpy(nm.x->bytes->data, q, p - q);\\r\\nfor (i = 0; i < sk_STACK_OF_X509_NAME_ENTRY_num(intname.s); i++) {\\r\\nentries = sk_STACK_OF_X509_NAME_ENTRY_value(intname.s, i);\\r\\nfor (j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {\\r\\nentry = sk_X509_NAME_ENTRY_value(entries, j);\\r\\nentry->set = i;\\r\\nif (!sk_X509_NAME_ENTRY_push(nm.x->entries, entry))\\r\\ngoto err;\\r\\n}\\r\\nsk_X509_NAME_ENTRY_free(entries);\\r\\n}\\r\\nsk_STACK_OF_X509_NAME_ENTRY_free(intname.s);\\r\\nret = x509_name_canon(nm.x);\\r\\nif (!ret)\\r\\ngoto err;\\r\\nnm.x->modified = 0;\\r\\n*val = nm.a;\\r\\n*in = p;\\r\\nreturn ret;\\r\\nerr:\\r\\nif (nm.x != NULL)\\r\\nX509_NAME_free(nm.x);\\r\\nASN1err(ASN1_F_X509_NAME_EX_D2I, ERR_R_NESTED_ASN1_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int x509_name_ex_i2d(ASN1_VALUE **val, unsigned char **out,\\r\\nconst ASN1_ITEM *it, int tag, int aclass)\\r\\n{\\r\\nint ret;\\r\\nX509_NAME *a = (X509_NAME *)*val;\\r\\nif (a->modified) {\\r\\nret = x509_name_encode(a);\\r\\nif (ret < 0)\\r\\nreturn ret;\\r\\nret = x509_name_canon(a);\\r\\nif (ret < 0)\\r\\nreturn ret;\\r\\n}\\r\\nret = a->bytes->length;\\r\\nif (out != NULL) {\\r\\nmemcpy(*out, a->bytes->data, ret);\\r\\n*out += ret;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int x509_name_encode(X509_NAME *a)\\r\\n{\\r\\nunion {\\r\\nSTACK_OF(STACK_OF_X509_NAME_ENTRY) *s;\\r\\nASN1_VALUE *a;\\r\\n} intname = {\\r\\nNULL\\r\\n};\\r\\nint len;\\r\\nunsigned char *p;\\r\\nSTACK_OF(X509_NAME_ENTRY) *entries = NULL;\\r\\nX509_NAME_ENTRY *entry;\\r\\nint i, set = -1;\\r\\nintname.s = sk_STACK_OF_X509_NAME_ENTRY_new_null();\\r\\nif (!intname.s)\\r\\ngoto memerr;\\r\\nfor (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\\r\\nentry = sk_X509_NAME_ENTRY_value(a->entries, i);\\r\\nif (entry->set != set) {\\r\\nentries = sk_X509_NAME_ENTRY_new_null();\\r\\nif (!entries)\\r\\ngoto memerr;\\r\\nif (!sk_STACK_OF_X509_NAME_ENTRY_push(intname.s, entries))\\r\\ngoto memerr;\\r\\nset = entry->set;\\r\\n}\\r\\nif (!sk_X509_NAME_ENTRY_push(entries, entry))\\r\\ngoto memerr;\\r\\n}\\r\\nlen = ASN1_item_ex_i2d(&intname.a, NULL,\\r\\nASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);\\r\\nif (!BUF_MEM_grow(a->bytes, len))\\r\\ngoto memerr;\\r\\np = (unsigned char *)a->bytes->data;\\r\\nASN1_item_ex_i2d(&intname.a,\\r\\n&p, ASN1_ITEM_rptr(X509_NAME_INTERNAL), -1, -1);\\r\\nsk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,\\r\\nlocal_sk_X509_NAME_ENTRY_free);\\r\\na->modified = 0;\\r\\nreturn len;\\r\\nmemerr:\\r\\nsk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,\\r\\nlocal_sk_X509_NAME_ENTRY_free);\\r\\nASN1err(ASN1_F_X509_NAME_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nstatic int x509_name_ex_print(BIO *out, ASN1_VALUE **pval,\\r\\nint indent,\\r\\nconst char *fname, const ASN1_PCTX *pctx)\\r\\n{\\r\\nif (X509_NAME_print_ex(out, (X509_NAME *)*pval,\\r\\nindent, pctx->nm_flags) <= 0)\\r\\nreturn 0;\\r\\nreturn 2;\\r\\n}\\r\\nstatic int x509_name_canon(X509_NAME *a)\\r\\n{\\r\\nunsigned char *p;\\r\\nSTACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;\\r\\nSTACK_OF(X509_NAME_ENTRY) *entries = NULL;\\r\\nX509_NAME_ENTRY *entry, *tmpentry = NULL;\\r\\nint i, set = -1, ret = 0;\\r\\nif (a->canon_enc) {\\r\\nOPENSSL_free(a->canon_enc);\\r\\na->canon_enc = NULL;\\r\\n}\\r\\nif (sk_X509_NAME_ENTRY_num(a->entries) == 0) {\\r\\na->canon_enclen = 0;\\r\\nreturn 1;\\r\\n}\\r\\nintname = sk_STACK_OF_X509_NAME_ENTRY_new_null();\\r\\nif (!intname)\\r\\ngoto err;\\r\\nfor (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {\\r\\nentry = sk_X509_NAME_ENTRY_value(a->entries, i);\\r\\nif (entry->set != set) {\\r\\nentries = sk_X509_NAME_ENTRY_new_null();\\r\\nif (!entries)\\r\\ngoto err;\\r\\nif (!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries))\\r\\ngoto err;\\r\\nset = entry->set;\\r\\n}\\r\\ntmpentry = X509_NAME_ENTRY_new();\\r\\nif (!tmpentry)\\r\\ngoto err;\\r\\ntmpentry->object = OBJ_dup(entry->object);\\r\\nif (!asn1_string_canon(tmpentry->value, entry->value))\\r\\ngoto err;\\r\\nif (!sk_X509_NAME_ENTRY_push(entries, tmpentry))\\r\\ngoto err;\\r\\ntmpentry = NULL;\\r\\n}\\r\\na->canon_enclen = i2d_name_canon(intname, NULL);\\r\\np = OPENSSL_malloc(a->canon_enclen);\\r\\nif (!p)\\r\\ngoto err;\\r\\na->canon_enc = p;\\r\\ni2d_name_canon(intname, &p);\\r\\nret = 1;\\r\\nerr:\\r\\nif (tmpentry)\\r\\nX509_NAME_ENTRY_free(tmpentry);\\r\\nif (intname)\\r\\nsk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,\\r\\nlocal_sk_X509_NAME_ENTRY_pop_free);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int asn1_string_canon(ASN1_STRING *out, ASN1_STRING *in)\\r\\n{\\r\\nunsigned char *to, *from;\\r\\nint len, i;\\r\\nif (!(ASN1_tag2bit(in->type) & ASN1_MASK_CANON)) {\\r\\nif (!ASN1_STRING_copy(out, in))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nout->type = V_ASN1_UTF8STRING;\\r\\nout->length = ASN1_STRING_to_UTF8(&out->data, in);\\r\\nif (out->length == -1)\\r\\nreturn 0;\\r\\nto = out->data;\\r\\nfrom = to;\\r\\nlen = out->length;\\r\\nwhile ((len > 0) && !(*from & 0x80) && isspace(*from)) {\\r\\nfrom++;\\r\\nlen--;\\r\\n}\\r\\nto = from + len - 1;\\r\\nwhile ((len > 0) && !(*to & 0x80) && isspace(*to)) {\\r\\nto--;\\r\\nlen--;\\r\\n}\\r\\nto = out->data;\\r\\ni = 0;\\r\\nwhile (i < len) {\\r\\nif (*from & 0x80) {\\r\\n*to++ = *from++;\\r\\ni++;\\r\\n}\\r\\nelse if (isspace(*from)) {\\r\\n*to++ = ' ';\\r\\ndo {\\r\\nfrom++;\\r\\ni++;\\r\\n}\\r\\nwhile (!(*from & 0x80) && isspace(*from));\\r\\n} else {\\r\\n*to++ = tolower(*from);\\r\\nfrom++;\\r\\ni++;\\r\\n}\\r\\n}\\r\\nout->length = to - out->data;\\r\\nreturn 1;\\r\\n}\\r\\nint X509_NAME_set(X509_NAME **xn, X509_NAME *name)\\r\\n{\\r\\nX509_NAME *in;\\r\\nif (!xn || !name)\\r\\nreturn (0);\\r\\nif (*xn != name) {\\r\\nin = X509_NAME_dup(name);\\r\\nif (in != NULL) {\\r\\nX509_NAME_free(*xn);\\r\\n*xn = in;\\r\\n}\\r\\n}\\r\\nreturn (*xn != NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_all_c", "target": 0, "func": "int X509_verify(X509 *a, EVP_PKEY *r)\\r\\n{\\r\\nif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))\\r\\nreturn 0;\\r\\nreturn (ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF), a->sig_alg,\\r\\na->signature, a->cert_info, r));\\r\\n}\\r\\nint X509_REQ_verify(X509_REQ *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn (ASN1_item_verify(ASN1_ITEM_rptr(X509_REQ_INFO),\\r\\na->sig_alg, a->signature, a->req_info, r));\\r\\n}\\r\\nint NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r)\\r\\n{\\r\\nreturn (ASN1_item_verify(ASN1_ITEM_rptr(NETSCAPE_SPKAC),\\r\\na->sig_algor, a->signature, a->spkac, r));\\r\\n}\\r\\nint X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nx->cert_info->enc.modified = 1;\\r\\nreturn (ASN1_item_sign(ASN1_ITEM_rptr(X509_CINF), x->cert_info->signature,\\r\\nx->sig_alg, x->signature, x->cert_info, pkey, md));\\r\\n}\\r\\nint X509_sign_ctx(X509 *x, EVP_MD_CTX *ctx)\\r\\n{\\r\\nx->cert_info->enc.modified = 1;\\r\\nreturn ASN1_item_sign_ctx(ASN1_ITEM_rptr(X509_CINF),\\r\\nx->cert_info->signature,\\r\\nx->sig_alg, x->signature, x->cert_info, ctx);\\r\\n}\\r\\nint X509_http_nbio(OCSP_REQ_CTX *rctx, X509 **pcert)\\r\\n{\\r\\nreturn OCSP_REQ_CTX_nbio_d2i(rctx,\\r\\n(ASN1_VALUE **)pcert, ASN1_ITEM_rptr(X509));\\r\\n}\\r\\nint X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nreturn (ASN1_item_sign(ASN1_ITEM_rptr(X509_REQ_INFO), x->sig_alg, NULL,\\r\\nx->signature, x->req_info, pkey, md));\\r\\n}\\r\\nint X509_REQ_sign_ctx(X509_REQ *x, EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn ASN1_item_sign_ctx(ASN1_ITEM_rptr(X509_REQ_INFO),\\r\\nx->sig_alg, NULL, x->signature, x->req_info,\\r\\nctx);\\r\\n}\\r\\nint X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nx->crl->enc.modified = 1;\\r\\nreturn (ASN1_item_sign(ASN1_ITEM_rptr(X509_CRL_INFO), x->crl->sig_alg,\\r\\nx->sig_alg, x->signature, x->crl, pkey, md));\\r\\n}\\r\\nint X509_CRL_sign_ctx(X509_CRL *x, EVP_MD_CTX *ctx)\\r\\n{\\r\\nx->crl->enc.modified = 1;\\r\\nreturn ASN1_item_sign_ctx(ASN1_ITEM_rptr(X509_CRL_INFO),\\r\\nx->crl->sig_alg, x->sig_alg, x->signature,\\r\\nx->crl, ctx);\\r\\n}\\r\\nint X509_CRL_http_nbio(OCSP_REQ_CTX *rctx, X509_CRL **pcrl)\\r\\n{\\r\\nreturn OCSP_REQ_CTX_nbio_d2i(rctx,\\r\\n(ASN1_VALUE **)pcrl,\\r\\nASN1_ITEM_rptr(X509_CRL));\\r\\n}\\r\\nint NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x, EVP_PKEY *pkey, const EVP_MD *md)\\r\\n{\\r\\nreturn (ASN1_item_sign(ASN1_ITEM_rptr(NETSCAPE_SPKAC), x->sig_algor, NULL,\\r\\nx->signature, x->spkac, pkey, md));\\r\\n}\\r\\nX509 *d2i_X509_fp(FILE *fp, X509 **x509)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(X509), fp, x509);\\r\\n}\\r\\nint i2d_X509_fp(FILE *fp, X509 *x509)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(X509), fp, x509);\\r\\n}\\r\\nX509 *d2i_X509_bio(BIO *bp, X509 **x509)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(X509), bp, x509);\\r\\n}\\r\\nint i2d_X509_bio(BIO *bp, X509 *x509)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509), bp, x509);\\r\\n}\\r\\nX509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **crl)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(X509_CRL), fp, crl);\\r\\n}\\r\\nint i2d_X509_CRL_fp(FILE *fp, X509_CRL *crl)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(X509_CRL), fp, crl);\\r\\n}\\r\\nX509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **crl)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(X509_CRL), bp, crl);\\r\\n}\\r\\nint i2d_X509_CRL_bio(BIO *bp, X509_CRL *crl)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509_CRL), bp, crl);\\r\\n}\\r\\nPKCS7 *d2i_PKCS7_fp(FILE *fp, PKCS7 **p7)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(PKCS7), fp, p7);\\r\\n}\\r\\nint i2d_PKCS7_fp(FILE *fp, PKCS7 *p7)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(PKCS7), fp, p7);\\r\\n}\\r\\nPKCS7 *d2i_PKCS7_bio(BIO *bp, PKCS7 **p7)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(PKCS7), bp, p7);\\r\\n}\\r\\nint i2d_PKCS7_bio(BIO *bp, PKCS7 *p7)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(PKCS7), bp, p7);\\r\\n}\\r\\nX509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **req)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(X509_REQ), fp, req);\\r\\n}\\r\\nint i2d_X509_REQ_fp(FILE *fp, X509_REQ *req)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(X509_REQ), fp, req);\\r\\n}\\r\\nX509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **req)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(X509_REQ), bp, req);\\r\\n}\\r\\nint i2d_X509_REQ_bio(BIO *bp, X509_REQ *req)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509_REQ), bp, req);\\r\\n}\\r\\nRSA *d2i_RSAPrivateKey_fp(FILE *fp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(RSAPrivateKey), fp, rsa);\\r\\n}\\r\\nint i2d_RSAPrivateKey_fp(FILE *fp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(RSAPrivateKey), fp, rsa);\\r\\n}\\r\\nRSA *d2i_RSAPublicKey_fp(FILE *fp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_item_d2i_fp(ASN1_ITEM_rptr(RSAPublicKey), fp, rsa);\\r\\n}\\r\\nRSA *d2i_RSA_PUBKEY_fp(FILE *fp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_d2i_fp((void *(*)(void))\\r\\nRSA_new, (D2I_OF(void)) d2i_RSA_PUBKEY, fp,\\r\\n(void **)rsa);\\r\\n}\\r\\nint i2d_RSAPublicKey_fp(FILE *fp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_i2d_fp(ASN1_ITEM_rptr(RSAPublicKey), fp, rsa);\\r\\n}\\r\\nint i2d_RSA_PUBKEY_fp(FILE *fp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_i2d_fp((I2D_OF(void))i2d_RSA_PUBKEY, fp, rsa);\\r\\n}\\r\\nRSA *d2i_RSAPrivateKey_bio(BIO *bp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(RSAPrivateKey), bp, rsa);\\r\\n}\\r\\nint i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(RSAPrivateKey), bp, rsa);\\r\\n}\\r\\nRSA *d2i_RSAPublicKey_bio(BIO *bp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_item_d2i_bio(ASN1_ITEM_rptr(RSAPublicKey), bp, rsa);\\r\\n}\\r\\nRSA *d2i_RSA_PUBKEY_bio(BIO *bp, RSA **rsa)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(RSA, RSA_new, d2i_RSA_PUBKEY, bp, rsa);\\r\\n}\\r\\nint i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_item_i2d_bio(ASN1_ITEM_rptr(RSAPublicKey), bp, rsa);\\r\\n}\\r\\nint i2d_RSA_PUBKEY_bio(BIO *bp, RSA *rsa)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(RSA, i2d_RSA_PUBKEY, bp, rsa);\\r\\n}\\r\\nDSA *d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(DSA, DSA_new, d2i_DSAPrivateKey, fp, dsa);\\r\\n}\\r\\nint i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of_const(DSA, i2d_DSAPrivateKey, fp, dsa);\\r\\n}\\r\\nDSA *d2i_DSA_PUBKEY_fp(FILE *fp, DSA **dsa)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(DSA, DSA_new, d2i_DSA_PUBKEY, fp, dsa);\\r\\n}\\r\\nint i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(DSA, i2d_DSA_PUBKEY, fp, dsa);\\r\\n}\\r\\nDSA *d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(DSA, DSA_new, d2i_DSAPrivateKey, bp, dsa);\\r\\n}\\r\\nint i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of_const(DSA, i2d_DSAPrivateKey, bp, dsa);\\r\\n}\\r\\nDSA *d2i_DSA_PUBKEY_bio(BIO *bp, DSA **dsa)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(DSA, DSA_new, d2i_DSA_PUBKEY, bp, dsa);\\r\\n}\\r\\nint i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(DSA, i2d_DSA_PUBKEY, bp, dsa);\\r\\n}\\r\\nEC_KEY *d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(EC_KEY, EC_KEY_new, d2i_EC_PUBKEY, fp, eckey);\\r\\n}\\r\\nint i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(EC_KEY, i2d_EC_PUBKEY, fp, eckey);\\r\\n}\\r\\nEC_KEY *d2i_ECPrivateKey_fp(FILE *fp, EC_KEY **eckey)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(EC_KEY, EC_KEY_new, d2i_ECPrivateKey, fp, eckey);\\r\\n}\\r\\nint i2d_ECPrivateKey_fp(FILE *fp, EC_KEY *eckey)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(EC_KEY, i2d_ECPrivateKey, fp, eckey);\\r\\n}\\r\\nEC_KEY *d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(EC_KEY, EC_KEY_new, d2i_EC_PUBKEY, bp, eckey);\\r\\n}\\r\\nint i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *ecdsa)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(EC_KEY, i2d_EC_PUBKEY, bp, ecdsa);\\r\\n}\\r\\nEC_KEY *d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(EC_KEY, EC_KEY_new, d2i_ECPrivateKey, bp, eckey);\\r\\n}\\r\\nint i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(EC_KEY, i2d_ECPrivateKey, bp, eckey);\\r\\n}\\r\\nint X509_pubkey_digest(const X509 *data, const EVP_MD *type,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nASN1_BIT_STRING *key;\\r\\nkey = X509_get0_pubkey_bitstr(data);\\r\\nif (!key)\\r\\nreturn 0;\\r\\nreturn EVP_Digest(key->data, key->length, md, len, type, NULL);\\r\\n}\\r\\nint X509_digest(const X509 *data, const EVP_MD *type, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nreturn (ASN1_item_digest\\r\\n(ASN1_ITEM_rptr(X509), type, (char *)data, md, len));\\r\\n}\\r\\nint X509_CRL_digest(const X509_CRL *data, const EVP_MD *type,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nreturn (ASN1_item_digest\\r\\n(ASN1_ITEM_rptr(X509_CRL), type, (char *)data, md, len));\\r\\n}\\r\\nint X509_REQ_digest(const X509_REQ *data, const EVP_MD *type,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nreturn (ASN1_item_digest\\r\\n(ASN1_ITEM_rptr(X509_REQ), type, (char *)data, md, len));\\r\\n}\\r\\nint X509_NAME_digest(const X509_NAME *data, const EVP_MD *type,\\r\\nunsigned char *md, unsigned int *len)\\r\\n{\\r\\nreturn (ASN1_item_digest\\r\\n(ASN1_ITEM_rptr(X509_NAME), type, (char *)data, md, len));\\r\\n}\\r\\nint PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data,\\r\\nconst EVP_MD *type, unsigned char *md,\\r\\nunsigned int *len)\\r\\n{\\r\\nreturn (ASN1_item_digest(ASN1_ITEM_rptr(PKCS7_ISSUER_AND_SERIAL), type,\\r\\n(char *)data, md, len));\\r\\n}\\r\\nX509_SIG *d2i_PKCS8_fp(FILE *fp, X509_SIG **p8)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(X509_SIG, X509_SIG_new, d2i_X509_SIG, fp, p8);\\r\\n}\\r\\nint i2d_PKCS8_fp(FILE *fp, X509_SIG *p8)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(X509_SIG, i2d_X509_SIG, fp, p8);\\r\\n}\\r\\nX509_SIG *d2i_PKCS8_bio(BIO *bp, X509_SIG **p8)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(X509_SIG, X509_SIG_new, d2i_X509_SIG, bp, p8);\\r\\n}\\r\\nint i2d_PKCS8_bio(BIO *bp, X509_SIG *p8)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(X509_SIG, i2d_X509_SIG, bp, p8);\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,\\r\\nPKCS8_PRIV_KEY_INFO **p8inf)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO_new,\\r\\nd2i_PKCS8_PRIV_KEY_INFO, fp, p8inf);\\r\\n}\\r\\nint i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, PKCS8_PRIV_KEY_INFO *p8inf)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(PKCS8_PRIV_KEY_INFO, i2d_PKCS8_PRIV_KEY_INFO, fp,\\r\\np8inf);\\r\\n}\\r\\nint i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, EVP_PKEY *key)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nint ret;\\r\\np8inf = EVP_PKEY2PKCS8(key);\\r\\nif (!p8inf)\\r\\nreturn 0;\\r\\nret = i2d_PKCS8_PRIV_KEY_INFO_fp(fp, p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn ret;\\r\\n}\\r\\nint i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(EVP_PKEY, i2d_PrivateKey, fp, pkey);\\r\\n}\\r\\nEVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(EVP_PKEY, EVP_PKEY_new, d2i_AutoPrivateKey, fp, a);\\r\\n}\\r\\nint i2d_PUBKEY_fp(FILE *fp, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn ASN1_i2d_fp_of(EVP_PKEY, i2d_PUBKEY, fp, pkey);\\r\\n}\\r\\nEVP_PKEY *d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a)\\r\\n{\\r\\nreturn ASN1_d2i_fp_of(EVP_PKEY, EVP_PKEY_new, d2i_PUBKEY, fp, a);\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,\\r\\nPKCS8_PRIV_KEY_INFO **p8inf)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO_new,\\r\\nd2i_PKCS8_PRIV_KEY_INFO, bp, p8inf);\\r\\n}\\r\\nint i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(PKCS8_PRIV_KEY_INFO, i2d_PKCS8_PRIV_KEY_INFO, bp,\\r\\np8inf);\\r\\n}\\r\\nint i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, EVP_PKEY *key)\\r\\n{\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nint ret;\\r\\np8inf = EVP_PKEY2PKCS8(key);\\r\\nif (!p8inf)\\r\\nreturn 0;\\r\\nret = i2d_PKCS8_PRIV_KEY_INFO_bio(bp, p8inf);\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\nreturn ret;\\r\\n}\\r\\nint i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(EVP_PKEY, i2d_PrivateKey, bp, pkey);\\r\\n}\\r\\nEVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(EVP_PKEY, EVP_PKEY_new, d2i_AutoPrivateKey, bp, a);\\r\\n}\\r\\nint i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey)\\r\\n{\\r\\nreturn ASN1_i2d_bio_of(EVP_PKEY, i2d_PUBKEY, bp, pkey);\\r\\n}\\r\\nEVP_PKEY *d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a)\\r\\n{\\r\\nreturn ASN1_d2i_bio_of(EVP_PKEY, EVP_PKEY_new, d2i_PUBKEY, bp, a);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tb_cipher_c", "target": 0, "func": "void ENGINE_unregister_ciphers(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&cipher_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_ciphers(void)\\r\\n{\\r\\nengine_table_cleanup(&cipher_table);\\r\\n}\\r\\nint ENGINE_register_ciphers(ENGINE *e)\\r\\n{\\r\\nif (e->ciphers) {\\r\\nconst int *nids;\\r\\nint num_nids = e->ciphers(e, NULL, &nids, 0);\\r\\nif (num_nids > 0)\\r\\nreturn engine_table_register(&cipher_table,\\r\\nengine_unregister_all_ciphers, e,\\r\\nnids, num_nids, 0);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_ciphers()\\r\\n{\\r\\nENGINE *e;\\r\\nfor (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))\\r\\nENGINE_register_ciphers(e);\\r\\n}\\r\\nint ENGINE_set_default_ciphers(ENGINE *e)\\r\\n{\\r\\nif (e->ciphers) {\\r\\nconst int *nids;\\r\\nint num_nids = e->ciphers(e, NULL, &nids, 0);\\r\\nif (num_nids > 0)\\r\\nreturn engine_table_register(&cipher_table,\\r\\nengine_unregister_all_ciphers, e,\\r\\nnids, num_nids, 1);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_cipher_engine(int nid)\\r\\n{\\r\\nreturn engine_table_select(&cipher_table, nid);\\r\\n}\\r\\nconst EVP_CIPHER *ENGINE_get_cipher(ENGINE *e, int nid)\\r\\n{\\r\\nconst EVP_CIPHER *ret;\\r\\nENGINE_CIPHERS_PTR fn = ENGINE_get_ciphers(e);\\r\\nif (!fn || !fn(e, &ret, NULL, nid)) {\\r\\nENGINEerr(ENGINE_F_ENGINE_GET_CIPHER, ENGINE_R_UNIMPLEMENTED_CIPHER);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e)\\r\\n{\\r\\nreturn e->ciphers;\\r\\n}\\r\\nint ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f)\\r\\n{\\r\\ne->ciphers = f;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_LPdir_unix_c", "target": 0, "func": "const char *LP_find_file(LP_DIR_CTX **ctx, const char *directory)\\r\\n{\\r\\nstruct dirent *direntry = NULL;\\r\\nif (ctx == NULL || directory == NULL) {\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nerrno = 0;\\r\\nif (*ctx == NULL) {\\r\\n*ctx = (LP_DIR_CTX *)malloc(sizeof(LP_DIR_CTX));\\r\\nif (*ctx == NULL) {\\r\\nerrno = ENOMEM;\\r\\nreturn 0;\\r\\n}\\r\\nmemset(*ctx, '\\0', sizeof(LP_DIR_CTX));\\r\\n(*ctx)->dir = opendir(directory);\\r\\nif ((*ctx)->dir == NULL) {\\r\\nint save_errno = errno;\\r\\nfree(*ctx);\\r\\n*ctx = NULL;\\r\\nerrno = save_errno;\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\ndirentry = readdir((*ctx)->dir);\\r\\nif (direntry == NULL) {\\r\\nreturn 0;\\r\\n}\\r\\nstrncpy((*ctx)->entry_name, direntry->d_name,\\r\\nsizeof((*ctx)->entry_name) - 1);\\r\\n(*ctx)->entry_name[sizeof((*ctx)->entry_name) - 1] = '\\0';\\r\\nreturn (*ctx)->entry_name;\\r\\n}\\r\\nint LP_find_file_end(LP_DIR_CTX **ctx)\\r\\n{\\r\\nif (ctx != NULL && *ctx != NULL) {\\r\\nint ret = closedir((*ctx)->dir);\\r\\nfree(*ctx);\\r\\nswitch (ret) {\\r\\ncase 0:\\r\\nreturn 1;\\r\\ncase -1:\\r\\nreturn 0;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_ess_c", "target": 0, "func": "int CMS_get1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest **prr)\\r\\n{\\r\\nASN1_STRING *str;\\r\\nCMS_ReceiptRequest *rr = NULL;\\r\\nif (prr)\\r\\n*prr = NULL;\\r\\nstr = CMS_signed_get0_data_by_OBJ(si,\\r\\nOBJ_nid2obj\\r\\n(NID_id_smime_aa_receiptRequest), -3,\\r\\nV_ASN1_SEQUENCE);\\r\\nif (!str)\\r\\nreturn 0;\\r\\nrr = ASN1_item_unpack(str, ASN1_ITEM_rptr(CMS_ReceiptRequest));\\r\\nif (!rr)\\r\\nreturn -1;\\r\\nif (prr)\\r\\n*prr = rr;\\r\\nelse\\r\\nCMS_ReceiptRequest_free(rr);\\r\\nreturn 1;\\r\\n}\\r\\nint CMS_add1_ReceiptRequest(CMS_SignerInfo *si, CMS_ReceiptRequest *rr)\\r\\n{\\r\\nunsigned char *rrder = NULL;\\r\\nint rrderlen, r = 0;\\r\\nrrderlen = i2d_CMS_ReceiptRequest(rr, &rrder);\\r\\nif (rrderlen < 0)\\r\\ngoto merr;\\r\\nif (!CMS_signed_add1_attr_by_NID(si, NID_id_smime_aa_receiptRequest,\\r\\nV_ASN1_SEQUENCE, rrder, rrderlen))\\r\\ngoto merr;\\r\\nr = 1;\\r\\nmerr:\\r\\nif (!r)\\r\\nCMSerr(CMS_F_CMS_ADD1_RECEIPTREQUEST, ERR_R_MALLOC_FAILURE);\\r\\nif (rrder)\\r\\nOPENSSL_free(rrder);\\r\\nreturn r;\\r\\n}\\r\\nstatic int cms_msgSigDigest(CMS_SignerInfo *si,\\r\\nunsigned char *dig, unsigned int *diglen)\\r\\n{\\r\\nconst EVP_MD *md;\\r\\nmd = EVP_get_digestbyobj(si->digestAlgorithm->algorithm);\\r\\nif (md == NULL)\\r\\nreturn 0;\\r\\nif (!ASN1_item_digest(ASN1_ITEM_rptr(CMS_Attributes_Verify), md,\\r\\nsi->signedAttrs, dig, diglen))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nint cms_msgSigDigest_add1(CMS_SignerInfo *dest, CMS_SignerInfo *src)\\r\\n{\\r\\nunsigned char dig[EVP_MAX_MD_SIZE];\\r\\nunsigned int diglen;\\r\\nif (!cms_msgSigDigest(src, dig, &diglen)) {\\r\\nCMSerr(CMS_F_CMS_MSGSIGDIGEST_ADD1, CMS_R_MSGSIGDIGEST_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!CMS_signed_add1_attr_by_NID(dest, NID_id_smime_aa_msgSigDigest,\\r\\nV_ASN1_OCTET_STRING, dig, diglen)) {\\r\\nCMSerr(CMS_F_CMS_MSGSIGDIGEST_ADD1, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint cms_Receipt_verify(CMS_ContentInfo *cms, CMS_ContentInfo *req_cms)\\r\\n{\\r\\nint r = 0, i;\\r\\nCMS_ReceiptRequest *rr = NULL;\\r\\nCMS_Receipt *rct = NULL;\\r\\nSTACK_OF(CMS_SignerInfo) *sis, *osis;\\r\\nCMS_SignerInfo *si, *osi = NULL;\\r\\nASN1_OCTET_STRING *msig, **pcont;\\r\\nASN1_OBJECT *octype;\\r\\nunsigned char dig[EVP_MAX_MD_SIZE];\\r\\nunsigned int diglen;\\r\\nosis = CMS_get0_SignerInfos(req_cms);\\r\\nsis = CMS_get0_SignerInfos(cms);\\r\\nif (!osis || !sis)\\r\\ngoto err;\\r\\nif (sk_CMS_SignerInfo_num(sis) != 1) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NEED_ONE_SIGNER);\\r\\ngoto err;\\r\\n}\\r\\nif (OBJ_obj2nid(CMS_get0_eContentType(cms)) != NID_id_smime_ct_receipt) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NOT_A_SIGNED_RECEIPT);\\r\\ngoto err;\\r\\n}\\r\\npcont = CMS_get0_content(cms);\\r\\nif (!pcont || !*pcont) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_CONTENT);\\r\\ngoto err;\\r\\n}\\r\\nrct = ASN1_item_unpack(*pcont, ASN1_ITEM_rptr(CMS_Receipt));\\r\\nif (!rct) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_RECEIPT_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nfor (i = 0; i < sk_CMS_SignerInfo_num(osis); i++) {\\r\\nosi = sk_CMS_SignerInfo_value(osis, i);\\r\\nif (!ASN1_STRING_cmp(osi->signature, rct->originatorSignatureValue))\\r\\nbreak;\\r\\n}\\r\\nif (i == sk_CMS_SignerInfo_num(osis)) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_MATCHING_SIGNATURE);\\r\\ngoto err;\\r\\n}\\r\\nsi = sk_CMS_SignerInfo_value(sis, 0);\\r\\nmsig = CMS_signed_get0_data_by_OBJ(si,\\r\\nOBJ_nid2obj\\r\\n(NID_id_smime_aa_msgSigDigest), -3,\\r\\nV_ASN1_OCTET_STRING);\\r\\nif (!msig) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_MSGSIGDIGEST);\\r\\ngoto err;\\r\\n}\\r\\nif (!cms_msgSigDigest(osi, dig, &diglen)) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_MSGSIGDIGEST_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (diglen != (unsigned int)msig->length) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_MSGSIGDIGEST_WRONG_LENGTH);\\r\\ngoto err;\\r\\n}\\r\\nif (memcmp(dig, msig->data, diglen)) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY,\\r\\nCMS_R_MSGSIGDIGEST_VERIFICATION_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\noctype = CMS_signed_get0_data_by_OBJ(osi,\\r\\nOBJ_nid2obj(NID_pkcs9_contentType),\\r\\n-3, V_ASN1_OBJECT);\\r\\nif (!octype) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nif (OBJ_cmp(octype, rct->contentType)) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_CONTENT_TYPE_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nif (CMS_get1_ReceiptRequest(osi, &rr) <= 0) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_NO_RECEIPT_REQUEST);\\r\\ngoto err;\\r\\n}\\r\\nif (ASN1_STRING_cmp(rr->signedContentIdentifier,\\r\\nrct->signedContentIdentifier)) {\\r\\nCMSerr(CMS_F_CMS_RECEIPT_VERIFY, CMS_R_CONTENTIDENTIFIER_MISMATCH);\\r\\ngoto err;\\r\\n}\\r\\nr = 1;\\r\\nerr:\\r\\nif (rr)\\r\\nCMS_ReceiptRequest_free(rr);\\r\\nif (rct)\\r\\nM_ASN1_free_of(rct, CMS_Receipt);\\r\\nreturn r;\\r\\n}\\r\\nASN1_OCTET_STRING *cms_encode_Receipt(CMS_SignerInfo *si)\\r\\n{\\r\\nCMS_Receipt rct;\\r\\nCMS_ReceiptRequest *rr = NULL;\\r\\nASN1_OBJECT *ctype;\\r\\nASN1_OCTET_STRING *os = NULL;\\r\\nif (CMS_get1_ReceiptRequest(si, &rr) <= 0) {\\r\\nCMSerr(CMS_F_CMS_ENCODE_RECEIPT, CMS_R_NO_RECEIPT_REQUEST);\\r\\ngoto err;\\r\\n}\\r\\nctype = CMS_signed_get0_data_by_OBJ(si,\\r\\nOBJ_nid2obj(NID_pkcs9_contentType),\\r\\n-3, V_ASN1_OBJECT);\\r\\nif (!ctype) {\\r\\nCMSerr(CMS_F_CMS_ENCODE_RECEIPT, CMS_R_NO_CONTENT_TYPE);\\r\\ngoto err;\\r\\n}\\r\\nrct.version = 1;\\r\\nrct.contentType = ctype;\\r\\nrct.signedContentIdentifier = rr->signedContentIdentifier;\\r\\nrct.originatorSignatureValue = si->signature;\\r\\nos = ASN1_item_pack(&rct, ASN1_ITEM_rptr(CMS_Receipt), NULL);\\r\\nerr:\\r\\nif (rr)\\r\\nCMS_ReceiptRequest_free(rr);\\r\\nreturn os;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t1_trce_c", "target": 0, "func": "static const char *do_ssl_trace_str(int val, ssl_trace_tbl *tbl, size_t ntbl)\\r\\n{\\r\\nsize_t i;\\r\\nfor (i = 0; i < ntbl; i++, tbl++) {\\r\\nif (tbl->num == val)\\r\\nreturn tbl->name;\\r\\n}\\r\\nreturn \"UNKNOWN\";\\r\\n}\\r\\nstatic int do_ssl_trace_list(BIO *bio, int indent,\\r\\nconst unsigned char *msg, size_t msglen,\\r\\nsize_t vlen, ssl_trace_tbl *tbl, size_t ntbl)\\r\\n{\\r\\nint val;\\r\\nif (msglen % vlen)\\r\\nreturn 0;\\r\\nwhile (msglen) {\\r\\nval = msg[0];\\r\\nif (vlen == 2)\\r\\nval = (val << 8) | msg[1];\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"%s (%d)\\n\", do_ssl_trace_str(val, tbl, ntbl), val);\\r\\nmsg += vlen;\\r\\nmsglen -= vlen;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void ssl_print_hex(BIO *bio, int indent, const char *name,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nsize_t i;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"%s (len=%d): \", name, (int)msglen);\\r\\nfor (i = 0; i < msglen; i++)\\r\\nBIO_printf(bio, \"%02X\", msg[i]);\\r\\nBIO_puts(bio, \"\\n\");\\r\\n}\\r\\nstatic int ssl_print_hexbuf(BIO *bio, int indent,\\r\\nconst char *name, size_t nlen,\\r\\nconst unsigned char **pmsg, size_t *pmsglen)\\r\\n{\\r\\nsize_t blen;\\r\\nconst unsigned char *p = *pmsg;\\r\\nif (*pmsglen < nlen)\\r\\nreturn 0;\\r\\nblen = p[0];\\r\\nif (nlen > 1)\\r\\nblen = (blen << 8) | p[1];\\r\\nif (*pmsglen < nlen + blen)\\r\\nreturn 0;\\r\\np += nlen;\\r\\nssl_print_hex(bio, indent, name, p, blen);\\r\\n*pmsg += blen + nlen;\\r\\n*pmsglen -= blen + nlen;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_version(BIO *bio, int indent, const char *name,\\r\\nconst unsigned char **pmsg, size_t *pmsglen)\\r\\n{\\r\\nint vers;\\r\\nif (*pmsglen < 2)\\r\\nreturn 0;\\r\\nvers = ((*pmsg)[0] << 8) | (*pmsg)[1];\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"%s=0x%x (%s)\\n\",\\r\\nname, vers, ssl_trace_str(vers, ssl_version_tbl));\\r\\n*pmsg += 2;\\r\\n*pmsglen -= 2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_random(BIO *bio, int indent,\\r\\nconst unsigned char **pmsg, size_t *pmsglen)\\r\\n{\\r\\nunsigned int tm;\\r\\nconst unsigned char *p = *pmsg;\\r\\nif (*pmsglen < 32)\\r\\nreturn 0;\\r\\ntm = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];\\r\\np += 4;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_puts(bio, \"Random:\\n\");\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_printf(bio, \"gmt_unix_time=0x%08X\\n\", tm);\\r\\nssl_print_hex(bio, indent + 2, \"random_bytes\", p, 28);\\r\\n*pmsg += 32;\\r\\n*pmsglen -= 32;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_signature(BIO *bio, int indent, SSL *s,\\r\\nconst unsigned char **pmsg, size_t *pmsglen)\\r\\n{\\r\\nif (*pmsglen < 2)\\r\\nreturn 0;\\r\\nif (SSL_USE_SIGALGS(s)) {\\r\\nconst unsigned char *p = *pmsg;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"Signature Algorithm %s+%s (%d+%d)\\n\",\\r\\nssl_trace_str(p[0], ssl_md_tbl),\\r\\nssl_trace_str(p[1], ssl_sig_tbl), p[0], p[1]);\\r\\n*pmsg += 2;\\r\\n*pmsglen -= 2;\\r\\n}\\r\\nreturn ssl_print_hexbuf(bio, indent, \"Signature\", 2, pmsg, pmsglen);\\r\\n}\\r\\nstatic int ssl_print_extension(BIO *bio, int indent, int server, int extype,\\r\\nconst unsigned char *ext, size_t extlen)\\r\\n{\\r\\nsize_t xlen;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"extension_type=%s(%d), length=%d\\n\",\\r\\nssl_trace_str(extype, ssl_exts_tbl), extype, (int)extlen);\\r\\nswitch (extype) {\\r\\ncase TLSEXT_TYPE_ec_point_formats:\\r\\nif (extlen < 1)\\r\\nreturn 0;\\r\\nxlen = ext[0];\\r\\nif (extlen != xlen + 1)\\r\\nreturn 0;\\r\\nreturn ssl_trace_list(bio, indent + 2,\\r\\next + 1, xlen, 1, ssl_point_tbl);\\r\\ncase TLSEXT_TYPE_elliptic_curves:\\r\\nif (extlen < 2)\\r\\nreturn 0;\\r\\nxlen = (ext[0] << 8) | ext[1];\\r\\nif (extlen != xlen + 2)\\r\\nreturn 0;\\r\\nreturn ssl_trace_list(bio, indent + 2,\\r\\next + 2, xlen, 2, ssl_curve_tbl);\\r\\ncase TLSEXT_TYPE_signature_algorithms:\\r\\nif (extlen < 2)\\r\\nreturn 0;\\r\\nxlen = (ext[0] << 8) | ext[1];\\r\\nif (extlen != xlen + 2)\\r\\nreturn 0;\\r\\nif (xlen & 1)\\r\\nreturn 0;\\r\\next += 2;\\r\\nwhile (xlen > 0) {\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_printf(bio, \"%s+%s (%d+%d)\\n\",\\r\\nssl_trace_str(ext[0], ssl_md_tbl),\\r\\nssl_trace_str(ext[1], ssl_sig_tbl), ext[0], ext[1]);\\r\\nxlen -= 2;\\r\\next += 2;\\r\\n}\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_renegotiate:\\r\\nif (extlen < 1)\\r\\nreturn 0;\\r\\nxlen = ext[0];\\r\\nif (xlen + 1 != extlen)\\r\\nreturn 0;\\r\\next++;\\r\\nif (xlen) {\\r\\nif (server) {\\r\\nif (xlen & 1)\\r\\nreturn 0;\\r\\nxlen >>= 1;\\r\\n}\\r\\nssl_print_hex(bio, indent + 4, \"client_verify_data\", ext, xlen);\\r\\nif (server) {\\r\\next += xlen;\\r\\nssl_print_hex(bio, indent + 4,\\r\\n\"server_verify_data\", ext, xlen);\\r\\n}\\r\\n} else {\\r\\nBIO_indent(bio, indent + 4, 80);\\r\\nBIO_puts(bio, \"<EMPTY>\\n\");\\r\\n}\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_heartbeat:\\r\\nif (extlen != 1)\\r\\nreturn 0;\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_printf(bio, \"HeartbeatMode: %s\\n\",\\r\\nssl_trace_str(ext[0], ssl_hb_tbl));\\r\\nbreak;\\r\\ncase TLSEXT_TYPE_session_ticket:\\r\\nif (extlen != 0)\\r\\nssl_print_hex(bio, indent + 4, \"ticket\", ext, extlen);\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_dump_indent(bio, (char *)ext, extlen, indent + 2);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_extensions(BIO *bio, int indent, int server,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nsize_t extslen;\\r\\nBIO_indent(bio, indent, 80);\\r\\nif (msglen == 0) {\\r\\nBIO_puts(bio, \"No Extensions\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nextslen = (msg[0] << 8) | msg[1];\\r\\nif (extslen != msglen - 2)\\r\\nreturn 0;\\r\\nmsg += 2;\\r\\nmsglen = extslen;\\r\\nBIO_printf(bio, \"extensions, length = %d\\n\", (int)msglen);\\r\\nwhile (msglen > 0) {\\r\\nint extype;\\r\\nsize_t extlen;\\r\\nif (msglen < 4)\\r\\nreturn 0;\\r\\nextype = (msg[0] << 8) | msg[1];\\r\\nextlen = (msg[2] << 8) | msg[3];\\r\\nif (msglen < extlen + 4)\\r\\nreturn 0;\\r\\nmsg += 4;\\r\\nif (!ssl_print_extension(bio, indent + 2, server,\\r\\nextype, msg, extlen))\\r\\nreturn 0;\\r\\nmsg += extlen;\\r\\nmsglen -= extlen + 4;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_client_hello(BIO *bio, SSL *ssl, int indent,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nsize_t len;\\r\\nunsigned int cs;\\r\\nif (!ssl_print_version(bio, indent, \"client_version\", &msg, &msglen))\\r\\nreturn 0;\\r\\nif (!ssl_print_random(bio, indent, &msg, &msglen))\\r\\nreturn 0;\\r\\nif (!ssl_print_hexbuf(bio, indent, \"session_id\", 1, &msg, &msglen))\\r\\nreturn 0;\\r\\nif (SSL_IS_DTLS(ssl)) {\\r\\nif (!ssl_print_hexbuf(bio, indent, \"cookie\", 1, &msg, &msglen))\\r\\nreturn 0;\\r\\n}\\r\\nif (msglen < 2)\\r\\nreturn 0;\\r\\nlen = (msg[0] << 8) | msg[1];\\r\\nmsg += 2;\\r\\nmsglen -= 2;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"cipher_suites (len=%d)\\n\", (int)len);\\r\\nif (msglen < len || len & 1)\\r\\nreturn 0;\\r\\nwhile (len > 0) {\\r\\ncs = (msg[0] << 8) | msg[1];\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_printf(bio, \"{0x%02X, 0x%02X} %s\\n\",\\r\\nmsg[0], msg[1], ssl_trace_str(cs, ssl_ciphers_tbl));\\r\\nmsg += 2;\\r\\nmsglen -= 2;\\r\\nlen -= 2;\\r\\n}\\r\\nif (msglen < 1)\\r\\nreturn 0;\\r\\nlen = msg[0];\\r\\nmsg++;\\r\\nmsglen--;\\r\\nif (msglen < len)\\r\\nreturn 0;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"compression_methods (len=%d)\\n\", (int)len);\\r\\nwhile (len > 0) {\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_printf(bio, \"%s (0x%02X)\\n\",\\r\\nssl_trace_str(msg[0], ssl_comp_tbl), msg[0]);\\r\\nmsg++;\\r\\nmsglen--;\\r\\nlen--;\\r\\n}\\r\\nif (!ssl_print_extensions(bio, indent, 0, msg, msglen))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int dtls_print_hello_vfyrequest(BIO *bio, int indent,\\r\\nconst unsigned char *msg,\\r\\nsize_t msglen)\\r\\n{\\r\\nif (!ssl_print_version(bio, indent, \"server_version\", &msg, &msglen))\\r\\nreturn 0;\\r\\nif (!ssl_print_hexbuf(bio, indent, \"cookie\", 1, &msg, &msglen))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_server_hello(BIO *bio, int indent,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nunsigned int cs;\\r\\nif (!ssl_print_version(bio, indent, \"server_version\", &msg, &msglen))\\r\\nreturn 0;\\r\\nif (!ssl_print_random(bio, indent, &msg, &msglen))\\r\\nreturn 0;\\r\\nif (!ssl_print_hexbuf(bio, indent, \"session_id\", 1, &msg, &msglen))\\r\\nreturn 0;\\r\\nif (msglen < 2)\\r\\nreturn 0;\\r\\ncs = (msg[0] << 8) | msg[1];\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"cipher_suite {0x%02X, 0x%02X} %s\\n\",\\r\\nmsg[0], msg[1], ssl_trace_str(cs, ssl_ciphers_tbl));\\r\\nmsg += 2;\\r\\nmsglen -= 2;\\r\\nif (msglen < 1)\\r\\nreturn 0;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"compression_method: %s (0x%02X)\\n\",\\r\\nssl_trace_str(msg[0], ssl_comp_tbl), msg[0]);\\r\\nmsg++;\\r\\nmsglen--;\\r\\nif (!ssl_print_extensions(bio, indent, 1, msg, msglen))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_get_keyex(const char **pname, SSL *ssl)\\r\\n{\\r\\nunsigned long alg_k = ssl->s3->tmp.new_cipher->algorithm_mkey;\\r\\nif (alg_k & SSL_kRSA) {\\r\\n*pname = \"rsa\";\\r\\nreturn SSL_kRSA;\\r\\n}\\r\\nif (alg_k & SSL_kDHr) {\\r\\n*pname = \"dh_rsa\";\\r\\nreturn SSL_kDHr;\\r\\n}\\r\\nif (alg_k & SSL_kDHd) {\\r\\n*pname = \"dh_dss\";\\r\\nreturn SSL_kDHd;\\r\\n}\\r\\nif (alg_k & SSL_kKRB5) {\\r\\n*pname = \"krb5\";\\r\\nreturn SSL_kKRB5;\\r\\n}\\r\\nif (alg_k & SSL_kEDH) {\\r\\n*pname = \"edh\";\\r\\nreturn SSL_kEDH;\\r\\n}\\r\\nif (alg_k & SSL_kEECDH) {\\r\\n*pname = \"EECDH\";\\r\\nreturn SSL_kEECDH;\\r\\n}\\r\\nif (alg_k & SSL_kECDHr) {\\r\\n*pname = \"ECDH RSA\";\\r\\nreturn SSL_kECDHr;\\r\\n}\\r\\nif (alg_k & SSL_kECDHe) {\\r\\n*pname = \"ECDH ECDSA\";\\r\\nreturn SSL_kECDHe;\\r\\n}\\r\\nif (alg_k & SSL_kPSK) {\\r\\n*pname = \"PSK\";\\r\\nreturn SSL_kPSK;\\r\\n}\\r\\nif (alg_k & SSL_kSRP) {\\r\\n*pname = \"SRP\";\\r\\nreturn SSL_kSRP;\\r\\n}\\r\\nif (alg_k & SSL_kGOST) {\\r\\n*pname = \"GOST\";\\r\\nreturn SSL_kGOST;\\r\\n}\\r\\n*pname = \"UNKNOWN\";\\r\\nreturn 0;\\r\\n}\\r\\nstatic int ssl_print_client_keyex(BIO *bio, int indent, SSL *ssl,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nconst char *algname;\\r\\nint id;\\r\\nid = ssl_get_keyex(&algname, ssl);\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"KeyExchangeAlgorithm=%s\\n\", algname);\\r\\nswitch (id) {\\r\\ncase SSL_kRSA:\\r\\nif (TLS1_get_version(ssl) == SSL3_VERSION) {\\r\\nssl_print_hex(bio, indent + 2,\\r\\n\"EncyptedPreMasterSecret\", msg, msglen);\\r\\n} else {\\r\\nif (!ssl_print_hexbuf(bio, indent + 2,\\r\\n\"EncyptedPreMasterSecret\", 2,\\r\\n&msg, &msglen))\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ncase SSL_kDHd:\\r\\ncase SSL_kDHr:\\r\\nif (msglen == 0) {\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_puts(bio, \"implicit\\n\");\\r\\nbreak;\\r\\n}\\r\\ncase SSL_kEDH:\\r\\nif (!ssl_print_hexbuf(bio, indent + 2, \"dh_Yc\", 2, &msg, &msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL_kECDHr:\\r\\ncase SSL_kECDHe:\\r\\nif (msglen == 0) {\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_puts(bio, \"implicit\\n\");\\r\\nbreak;\\r\\n}\\r\\ncase SSL_kEECDH:\\r\\nif (!ssl_print_hexbuf(bio, indent + 2, \"ecdh_Yc\", 1, &msg, &msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_server_keyex(BIO *bio, int indent, SSL *ssl,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nconst char *algname;\\r\\nint id;\\r\\nid = ssl_get_keyex(&algname, ssl);\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"KeyExchangeAlgorithm=%s\\n\", algname);\\r\\nswitch (id) {\\r\\ncase SSL_kDHd:\\r\\ncase SSL_kDHr:\\r\\ncase SSL_kECDHr:\\r\\ncase SSL_kECDHe:\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_printf(bio, \"Unexpected Message\\n\");\\r\\nbreak;\\r\\ncase SSL_kRSA:\\r\\nif (!ssl_print_hexbuf(bio, indent + 2, \"rsa_modulus\", 2,\\r\\n&msg, &msglen))\\r\\nreturn 0;\\r\\nif (!ssl_print_hexbuf(bio, indent + 2, \"rsa_exponent\", 2,\\r\\n&msg, &msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL_kEDH:\\r\\nif (!ssl_print_hexbuf(bio, indent + 2, \"dh_p\", 2, &msg, &msglen))\\r\\nreturn 0;\\r\\nif (!ssl_print_hexbuf(bio, indent + 2, \"dh_g\", 2, &msg, &msglen))\\r\\nreturn 0;\\r\\nif (!ssl_print_hexbuf(bio, indent + 2, \"dh_Ys\", 2, &msg, &msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL_kEECDH:\\r\\nif (msglen < 1)\\r\\nreturn 0;\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nif (msg[0] == EXPLICIT_PRIME_CURVE_TYPE)\\r\\nBIO_puts(bio, \"explicit_prime\\n\");\\r\\nelse if (msg[0] == EXPLICIT_CHAR2_CURVE_TYPE)\\r\\nBIO_puts(bio, \"explicit_char2\\n\");\\r\\nelse if (msg[0] == NAMED_CURVE_TYPE) {\\r\\nint curve;\\r\\nif (msglen < 3)\\r\\nreturn 0;\\r\\ncurve = (msg[1] << 8) | msg[2];\\r\\nBIO_printf(bio, \"named_curve: %s (%d)\\n\",\\r\\nssl_trace_str(curve, ssl_curve_tbl), curve);\\r\\nmsg += 3;\\r\\nmsglen -= 3;\\r\\nif (!ssl_print_hexbuf(bio, indent + 2, \"point\", 1, &msg, &msglen))\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nreturn ssl_print_signature(bio, indent, ssl, &msg, &msglen);\\r\\n}\\r\\nstatic int ssl_print_certificate(BIO *bio, int indent,\\r\\nconst unsigned char **pmsg, size_t *pmsglen)\\r\\n{\\r\\nsize_t msglen = *pmsglen;\\r\\nsize_t clen;\\r\\nX509 *x;\\r\\nconst unsigned char *p = *pmsg, *q;\\r\\nif (msglen < 3)\\r\\nreturn 0;\\r\\nclen = (p[0] << 16) | (p[1] << 8) | p[2];\\r\\nif (msglen < clen + 3)\\r\\nreturn 0;\\r\\nq = p + 3;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"ASN.1Cert, length=%d\", (int)clen);\\r\\nx = d2i_X509(NULL, &q, clen);\\r\\nif (!x)\\r\\nBIO_puts(bio, \"<UNPARSEABLE CERTIFICATE>\\n\");\\r\\nelse {\\r\\nBIO_puts(bio, \"\\n------details-----\\n\");\\r\\nX509_print_ex(bio, x, XN_FLAG_ONELINE, 0);\\r\\nPEM_write_bio_X509(bio, x);\\r\\nBIO_puts(bio, \"------------------\\n\");\\r\\nX509_free(x);\\r\\n}\\r\\nif (q != p + 3 + clen) {\\r\\nBIO_puts(bio, \"<TRAILING GARBAGE AFTER CERTIFICATE>\\n\");\\r\\n}\\r\\n*pmsg += clen + 3;\\r\\n*pmsglen -= clen + 3;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_certificates(BIO *bio, int indent,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nsize_t clen;\\r\\nif (msglen < 3)\\r\\nreturn 0;\\r\\nclen = (msg[0] << 16) | (msg[1] << 8) | msg[2];\\r\\nif (msglen != clen + 3)\\r\\nreturn 0;\\r\\nmsg += 3;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"certificate_list, length=%d\\n\", (int)clen);\\r\\nwhile (clen > 0) {\\r\\nif (!ssl_print_certificate(bio, indent + 2, &msg, &clen))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_cert_request(BIO *bio, int indent, SSL *s,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nsize_t xlen;\\r\\nif (msglen < 1)\\r\\nreturn 0;\\r\\nxlen = msg[0];\\r\\nif (msglen < xlen + 1)\\r\\nreturn 0;\\r\\nmsg++;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"certificate_types (len=%d)\\n\", (int)xlen);\\r\\nif (!ssl_trace_list(bio, indent + 2, msg, xlen, 1, ssl_ctype_tbl))\\r\\nreturn 0;\\r\\nmsg += xlen;\\r\\nmsglen -= xlen + 1;\\r\\nif (!SSL_USE_SIGALGS(s))\\r\\ngoto skip_sig;\\r\\nif (msglen < 2)\\r\\nreturn 0;\\r\\nxlen = (msg[0] << 8) | msg[1];\\r\\nif (msglen < xlen + 2 || (xlen & 1))\\r\\nreturn 0;\\r\\nmsg += 2;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"signature_algorithms (len=%d)\\n\", (int)xlen);\\r\\nwhile (xlen > 0) {\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_printf(bio, \"%s+%s (%d+%d)\\n\",\\r\\nssl_trace_str(msg[0], ssl_md_tbl),\\r\\nssl_trace_str(msg[1], ssl_sig_tbl), msg[0], msg[1]);\\r\\nxlen -= 2;\\r\\nmsg += 2;\\r\\n}\\r\\nmsg += xlen;\\r\\nmsglen -= xlen + 2;\\r\\nskip_sig:\\r\\nxlen = (msg[0] << 8) | msg[1];\\r\\nBIO_indent(bio, indent, 80);\\r\\nif (msglen < xlen + 2)\\r\\nreturn 0;\\r\\nmsg += 2;\\r\\nmsglen -= 2;\\r\\nBIO_printf(bio, \"certificate_authorities (len=%d)\\n\", (int)xlen);\\r\\nwhile (xlen > 0) {\\r\\nsize_t dlen;\\r\\nX509_NAME *nm;\\r\\nconst unsigned char *p;\\r\\nif (xlen < 2)\\r\\nreturn 0;\\r\\ndlen = (msg[0] << 8) | msg[1];\\r\\nif (xlen < dlen + 2)\\r\\nreturn 0;\\r\\nmsg += 2;\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_printf(bio, \"DistinguishedName (len=%d): \", (int)dlen);\\r\\np = msg;\\r\\nnm = d2i_X509_NAME(NULL, &p, dlen);\\r\\nif (!nm) {\\r\\nBIO_puts(bio, \"<UNPARSEABLE DN>\\n\");\\r\\n} else {\\r\\nX509_NAME_print_ex(bio, nm, 0, XN_FLAG_ONELINE);\\r\\nBIO_puts(bio, \"\\n\");\\r\\nX509_NAME_free(nm);\\r\\n}\\r\\nxlen -= dlen + 2;\\r\\nmsg += dlen;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_ticket(BIO *bio, int indent,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nunsigned int tick_life;\\r\\nif (msglen == 0) {\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_puts(bio, \"No Ticket\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nif (msglen < 4)\\r\\nreturn 0;\\r\\ntick_life = (msg[0] << 24) | (msg[1] << 16) | (msg[2] << 8) | msg[3];\\r\\nmsglen -= 4;\\r\\nmsg += 4;\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_printf(bio, \"ticket_lifetime_hint=%u\\n\", tick_life);\\r\\nif (!ssl_print_hexbuf(bio, indent + 2, \"ticket\", 2, &msg, &msglen))\\r\\nreturn 0;\\r\\nif (msglen)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_handshake(BIO *bio, SSL *ssl,\\r\\nconst unsigned char *msg, size_t msglen,\\r\\nint indent)\\r\\n{\\r\\nsize_t hlen;\\r\\nunsigned char htype;\\r\\nif (msglen < 4)\\r\\nreturn 0;\\r\\nhtype = msg[0];\\r\\nhlen = (msg[1] << 16) | (msg[2] << 8) | msg[3];\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"%s, Length=%d\\n\",\\r\\nssl_trace_str(htype, ssl_handshake_tbl), (int)hlen);\\r\\nmsg += 4;\\r\\nmsglen -= 4;\\r\\nif (SSL_IS_DTLS(ssl)) {\\r\\nif (msglen < 8)\\r\\nreturn 0;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"message_seq=%d, fragment_offset=%d, \"\\r\\n\"fragment_length=%d\\n\",\\r\\n(msg[0] << 8) | msg[1],\\r\\n(msg[2] << 16) | (msg[3] << 8) | msg[4],\\r\\n(msg[5] << 16) | (msg[6] << 8) | msg[7]);\\r\\nmsg += 8;\\r\\nmsglen -= 8;\\r\\n}\\r\\nif (msglen < hlen)\\r\\nreturn 0;\\r\\nswitch (htype) {\\r\\ncase SSL3_MT_CLIENT_HELLO:\\r\\nif (!ssl_print_client_hello(bio, ssl, indent + 2, msg, msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase DTLS1_MT_HELLO_VERIFY_REQUEST:\\r\\nif (!dtls_print_hello_vfyrequest(bio, indent + 2, msg, msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL3_MT_SERVER_HELLO:\\r\\nif (!ssl_print_server_hello(bio, indent + 2, msg, msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL3_MT_SERVER_KEY_EXCHANGE:\\r\\nif (!ssl_print_server_keyex(bio, indent + 2, ssl, msg, msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL3_MT_CLIENT_KEY_EXCHANGE:\\r\\nif (!ssl_print_client_keyex(bio, indent + 2, ssl, msg, msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL3_MT_CERTIFICATE:\\r\\nif (!ssl_print_certificates(bio, indent + 2, msg, msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL3_MT_CERTIFICATE_VERIFY:\\r\\nif (!ssl_print_signature(bio, indent + 2, ssl, &msg, &msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL3_MT_CERTIFICATE_REQUEST:\\r\\nif (!ssl_print_cert_request(bio, indent + 2, ssl, msg, msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ncase SSL3_MT_FINISHED:\\r\\nssl_print_hex(bio, indent + 2, \"verify_data\", msg, msglen);\\r\\nbreak;\\r\\ncase SSL3_MT_SERVER_DONE:\\r\\nif (msglen != 0)\\r\\nssl_print_hex(bio, indent + 2, \"unexpected value\", msg, msglen);\\r\\nbreak;\\r\\ncase SSL3_MT_NEWSESSION_TICKET:\\r\\nif (!ssl_print_ticket(bio, indent + 2, msg, msglen))\\r\\nreturn 0;\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_indent(bio, indent + 2, 80);\\r\\nBIO_puts(bio, \"Unsupported, hex dump follows:\\n\");\\r\\nBIO_dump_indent(bio, (char *)msg, msglen, indent + 4);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int ssl_print_heartbeat(BIO *bio, int indent,\\r\\nconst unsigned char *msg, size_t msglen)\\r\\n{\\r\\nif (msglen < 3)\\r\\nreturn 0;\\r\\nBIO_indent(bio, indent, 80);\\r\\nBIO_printf(bio, \"HeartBeatMessageType: %s\\n\",\\r\\nssl_trace_str(msg[0], ssl_hb_type_tbl));\\r\\nmsg++;\\r\\nmsglen--;\\r\\nif (!ssl_print_hexbuf(bio, indent, \"payload\", 2, &msg, &msglen))\\r\\nreturn 0;\\r\\nssl_print_hex(bio, indent, \"padding\", msg, msglen);\\r\\nreturn 1;\\r\\n}\\r\\nconst char *SSL_CIPHER_standard_name(const SSL_CIPHER *c)\\r\\n{\\r\\nif (c->algorithm_ssl & SSL_SSLV2)\\r\\nreturn NULL;\\r\\nreturn ssl_trace_str(c->id & 0xFFFF, ssl_ciphers_tbl);\\r\\n}\\r\\nvoid SSL_trace(int write_p, int version, int content_type,\\r\\nconst void *buf, size_t msglen, SSL *ssl, void *arg)\\r\\n{\\r\\nconst unsigned char *msg = buf;\\r\\nBIO *bio = arg;\\r\\nif (write_p == 2) {\\r\\nBIO_puts(bio, \"Session \");\\r\\nssl_print_hex(bio, 0,\\r\\nssl_trace_str(content_type, ssl_crypto_tbl),\\r\\nmsg, msglen);\\r\\nreturn;\\r\\n}\\r\\nswitch (content_type) {\\r\\ncase SSL3_RT_HEADER:\\r\\n{\\r\\nint hvers = msg[1] << 8 | msg[2];\\r\\nBIO_puts(bio, write_p ? \"Sent\" : \"Received\");\\r\\nBIO_printf(bio, \" Record\\nHeader:\\n Version = %s (0x%x)\\n\",\\r\\nssl_trace_str(hvers, ssl_version_tbl), hvers);\\r\\nif (SSL_IS_DTLS(ssl)) {\\r\\nBIO_printf(bio,\\r\\n\" epoch=%d, sequence_number=%04x%04x%04x\\n\",\\r\\n(msg[3] << 8 | msg[4]),\\r\\n(msg[5] << 8 | msg[6]),\\r\\n(msg[7] << 8 | msg[8]), (msg[9] << 8 | msg[10]));\\r\\n# if 0\\r\\nBIO_printf(bio, \"(%s)\\n\",\\r\\nssl_trace_str(msg[msglen], ssl_handshake_tbl));\\r\\n# endif\\r\\n}\\r\\nBIO_printf(bio, \" Content Type = %s (%d)\\n Length = %d\",\\r\\nssl_trace_str(msg[0], ssl_content_tbl), msg[0],\\r\\nmsg[msglen - 2] << 8 | msg[msglen - 1]);\\r\\n}\\r\\nbreak;\\r\\ncase SSL3_RT_HANDSHAKE:\\r\\nif (!ssl_print_handshake(bio, ssl, msg, msglen, 4))\\r\\nBIO_printf(bio, \"Message length parse error!\\n\");\\r\\nbreak;\\r\\ncase SSL3_RT_CHANGE_CIPHER_SPEC:\\r\\nif (msglen == 1 && msg[0] == 1)\\r\\nBIO_puts(bio, \" change_cipher_spec (1)\\n\");\\r\\nelse\\r\\nssl_print_hex(bio, 4, \"unknown value\", msg, msglen);\\r\\nbreak;\\r\\ncase SSL3_RT_ALERT:\\r\\nif (msglen != 2)\\r\\nBIO_puts(bio, \" Illegal Alert Length\\n\");\\r\\nelse {\\r\\nBIO_printf(bio, \" Level=%s(%d), description=%s(%d)\\n\",\\r\\nSSL_alert_type_string_long(msg[0] << 8),\\r\\nmsg[0], SSL_alert_desc_string_long(msg[1]), msg[1]);\\r\\n}\\r\\ncase TLS1_RT_HEARTBEAT:\\r\\nssl_print_heartbeat(bio, 4, msg, msglen);\\r\\nbreak;\\r\\n}\\r\\nBIO_puts(bio, \"\\n\");\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_sqrt_c", "target": 0, "func": "BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\\r\\n{\\r\\nBIGNUM *ret = in;\\r\\nint err = 1;\\r\\nint r;\\r\\nBIGNUM *A, *b, *q, *t, *x, *y;\\r\\nint e, i, j;\\r\\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\\r\\nif (BN_abs_is_word(p, 2)) {\\r\\nif (ret == NULL)\\r\\nret = BN_new();\\r\\nif (ret == NULL)\\r\\ngoto end;\\r\\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\\r\\nif (ret != in)\\r\\nBN_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nbn_check_top(ret);\\r\\nreturn ret;\\r\\n}\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\\r\\nreturn (NULL);\\r\\n}\\r\\nif (BN_is_zero(a) || BN_is_one(a)) {\\r\\nif (ret == NULL)\\r\\nret = BN_new();\\r\\nif (ret == NULL)\\r\\ngoto end;\\r\\nif (!BN_set_word(ret, BN_is_one(a))) {\\r\\nif (ret != in)\\r\\nBN_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nbn_check_top(ret);\\r\\nreturn ret;\\r\\n}\\r\\nBN_CTX_start(ctx);\\r\\nA = BN_CTX_get(ctx);\\r\\nb = BN_CTX_get(ctx);\\r\\nq = BN_CTX_get(ctx);\\r\\nt = BN_CTX_get(ctx);\\r\\nx = BN_CTX_get(ctx);\\r\\ny = BN_CTX_get(ctx);\\r\\nif (y == NULL)\\r\\ngoto end;\\r\\nif (ret == NULL)\\r\\nret = BN_new();\\r\\nif (ret == NULL)\\r\\ngoto end;\\r\\nif (!BN_nnmod(A, a, p, ctx))\\r\\ngoto end;\\r\\ne = 1;\\r\\nwhile (!BN_is_bit_set(p, e))\\r\\ne++;\\r\\nif (e == 1) {\\r\\nif (!BN_rshift(q, p, 2))\\r\\ngoto end;\\r\\nq->neg = 0;\\r\\nif (!BN_add_word(q, 1))\\r\\ngoto end;\\r\\nif (!BN_mod_exp(ret, A, q, p, ctx))\\r\\ngoto end;\\r\\nerr = 0;\\r\\ngoto vrfy;\\r\\n}\\r\\nif (e == 2) {\\r\\nif (!BN_mod_lshift1_quick(t, A, p))\\r\\ngoto end;\\r\\nif (!BN_rshift(q, p, 3))\\r\\ngoto end;\\r\\nq->neg = 0;\\r\\nif (!BN_mod_exp(b, t, q, p, ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_sqr(y, b, p, ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_mul(t, t, y, p, ctx))\\r\\ngoto end;\\r\\nif (!BN_sub_word(t, 1))\\r\\ngoto end;\\r\\nif (!BN_mod_mul(x, A, b, p, ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_mul(x, x, t, p, ctx))\\r\\ngoto end;\\r\\nif (!BN_copy(ret, x))\\r\\ngoto end;\\r\\nerr = 0;\\r\\ngoto vrfy;\\r\\n}\\r\\nif (!BN_copy(q, p))\\r\\ngoto end;\\r\\nq->neg = 0;\\r\\ni = 2;\\r\\ndo {\\r\\nif (i < 22) {\\r\\nif (!BN_set_word(y, i))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0))\\r\\ngoto end;\\r\\nif (BN_ucmp(y, p) >= 0) {\\r\\nif (!(p->neg ? BN_add : BN_sub) (y, y, p))\\r\\ngoto end;\\r\\n}\\r\\nif (BN_is_zero(y))\\r\\nif (!BN_set_word(y, i))\\r\\ngoto end;\\r\\n}\\r\\nr = BN_kronecker(y, q, ctx);\\r\\nif (r < -1)\\r\\ngoto end;\\r\\nif (r == 0) {\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nwhile (r == 1 && ++i < 82);\\r\\nif (r != -1) {\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_rshift(q, q, e))\\r\\ngoto end;\\r\\nif (!BN_mod_exp(y, y, q, p, ctx))\\r\\ngoto end;\\r\\nif (BN_is_one(y)) {\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_rshift1(t, q))\\r\\ngoto end;\\r\\nif (BN_is_zero(t)) {\\r\\nif (!BN_nnmod(t, A, p, ctx))\\r\\ngoto end;\\r\\nif (BN_is_zero(t)) {\\r\\nBN_zero(ret);\\r\\nerr = 0;\\r\\ngoto end;\\r\\n} else if (!BN_one(x))\\r\\ngoto end;\\r\\n} else {\\r\\nif (!BN_mod_exp(x, A, t, p, ctx))\\r\\ngoto end;\\r\\nif (BN_is_zero(x)) {\\r\\nBN_zero(ret);\\r\\nerr = 0;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!BN_mod_sqr(b, x, p, ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_mul(b, b, A, p, ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_mul(x, x, A, p, ctx))\\r\\ngoto end;\\r\\nwhile (1) {\\r\\nif (BN_is_one(b)) {\\r\\nif (!BN_copy(ret, x))\\r\\ngoto end;\\r\\nerr = 0;\\r\\ngoto vrfy;\\r\\n}\\r\\ni = 1;\\r\\nif (!BN_mod_sqr(t, b, p, ctx))\\r\\ngoto end;\\r\\nwhile (!BN_is_one(t)) {\\r\\ni++;\\r\\nif (i == e) {\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_mod_mul(t, t, t, p, ctx))\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_copy(t, y))\\r\\ngoto end;\\r\\nfor (j = e - i - 1; j > 0; j--) {\\r\\nif (!BN_mod_sqr(t, t, p, ctx))\\r\\ngoto end;\\r\\n}\\r\\nif (!BN_mod_mul(y, t, t, p, ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_mul(x, x, t, p, ctx))\\r\\ngoto end;\\r\\nif (!BN_mod_mul(b, b, y, p, ctx))\\r\\ngoto end;\\r\\ne = i;\\r\\n}\\r\\nvrfy:\\r\\nif (!err) {\\r\\nif (!BN_mod_sqr(x, ret, p, ctx))\\r\\nerr = 1;\\r\\nif (!err && 0 != BN_cmp(x, A)) {\\r\\nBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\\r\\nerr = 1;\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (err) {\\r\\nif (ret != NULL && ret != in) {\\r\\nBN_clear_free(ret);\\r\\n}\\r\\nret = NULL;\\r\\n}\\r\\nBN_CTX_end(ctx);\\r\\nbn_check_top(ret);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_m_null_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nstatic int final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nconst EVP_MD *EVP_md_null(void)\\r\\n{\\r\\nreturn (&null_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_err_c", "target": 0, "func": "void ERR_load_BN_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(BN_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, BN_str_functs);\\r\\nERR_load_strings(0, BN_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_info_c", "target": 0, "func": "int i2a_ACCESS_DESCRIPTION(BIO *bp, ACCESS_DESCRIPTION *a)\\r\\n{\\r\\ni2a_ASN1_OBJECT(bp, a->method);\\r\\n#ifdef UNDEF\\r\\ni2a_GENERAL_NAME(bp, a->location);\\r\\n#endif\\r\\nreturn 2;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ts_rsp_print_c", "target": 0, "func": "int TS_RESP_print_bio(BIO *bio, TS_RESP *a)\\r\\n{\\r\\nTS_TST_INFO *tst_info;\\r\\nBIO_printf(bio, \"Status info:\\n\");\\r\\nTS_STATUS_INFO_print_bio(bio, TS_RESP_get_status_info(a));\\r\\nBIO_printf(bio, \"\\nTST info:\\n\");\\r\\ntst_info = TS_RESP_get_tst_info(a);\\r\\nif (tst_info != NULL)\\r\\nTS_TST_INFO_print_bio(bio, TS_RESP_get_tst_info(a));\\r\\nelse\\r\\nBIO_printf(bio, \"Not included.\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nint TS_STATUS_INFO_print_bio(BIO *bio, TS_STATUS_INFO *a)\\r\\n{\\r\\nstatic const char *status_map[] = {\\r\\n\"Granted.\",\\r\\n\"Granted with modifications.\",\\r\\n\"Rejected.\",\\r\\n\"Waiting.\",\\r\\n\"Revocation warning.\",\\r\\n\"Revoked.\"\\r\\n};\\r\\nstatic struct status_map_st failure_map[] = {\\r\\n{TS_INFO_BAD_ALG,\\r\\n\"unrecognized or unsupported algorithm identifier\"},\\r\\n{TS_INFO_BAD_REQUEST,\\r\\n\"transaction not permitted or supported\"},\\r\\n{TS_INFO_BAD_DATA_FORMAT,\\r\\n\"the data submitted has the wrong format\"},\\r\\n{TS_INFO_TIME_NOT_AVAILABLE,\\r\\n\"the TSA's time source is not available\"},\\r\\n{TS_INFO_UNACCEPTED_POLICY,\\r\\n\"the requested TSA policy is not supported by the TSA\"},\\r\\n{TS_INFO_UNACCEPTED_EXTENSION,\\r\\n\"the requested extension is not supported by the TSA\"},\\r\\n{TS_INFO_ADD_INFO_NOT_AVAILABLE,\\r\\n\"the additional information requested could not be understood \"\\r\\n\"or is not available\"},\\r\\n{TS_INFO_SYSTEM_FAILURE,\\r\\n\"the request cannot be handled due to system failure\"},\\r\\n{-1, NULL}\\r\\n};\\r\\nlong status;\\r\\nint i, lines = 0;\\r\\nBIO_printf(bio, \"Status: \");\\r\\nstatus = ASN1_INTEGER_get(a->status);\\r\\nif (0 <= status\\r\\n&& status < (long)(sizeof(status_map) / sizeof(status_map[0])))\\r\\nBIO_printf(bio, \"%s\\n\", status_map[status]);\\r\\nelse\\r\\nBIO_printf(bio, \"out of bounds\\n\");\\r\\nBIO_printf(bio, \"Status description: \");\\r\\nfor (i = 0; i < sk_ASN1_UTF8STRING_num(a->text); ++i) {\\r\\nif (i > 0)\\r\\nBIO_puts(bio, \"\\t\");\\r\\nASN1_STRING_print_ex(bio, sk_ASN1_UTF8STRING_value(a->text, i), 0);\\r\\nBIO_puts(bio, \"\\n\");\\r\\n}\\r\\nif (i == 0)\\r\\nBIO_printf(bio, \"unspecified\\n\");\\r\\nBIO_printf(bio, \"Failure info: \");\\r\\nif (a->failure_info != NULL)\\r\\nlines = TS_status_map_print(bio, failure_map, a->failure_info);\\r\\nif (lines == 0)\\r\\nBIO_printf(bio, \"unspecified\");\\r\\nBIO_printf(bio, \"\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nstatic int TS_status_map_print(BIO *bio, struct status_map_st *a,\\r\\nASN1_BIT_STRING *v)\\r\\n{\\r\\nint lines = 0;\\r\\nfor (; a->bit >= 0; ++a) {\\r\\nif (ASN1_BIT_STRING_get_bit(v, a->bit)) {\\r\\nif (++lines > 1)\\r\\nBIO_printf(bio, \", \");\\r\\nBIO_printf(bio, \"%s\", a->text);\\r\\n}\\r\\n}\\r\\nreturn lines;\\r\\n}\\r\\nint TS_TST_INFO_print_bio(BIO *bio, TS_TST_INFO *a)\\r\\n{\\r\\nint v;\\r\\nASN1_OBJECT *policy_id;\\r\\nconst ASN1_INTEGER *serial;\\r\\nconst ASN1_GENERALIZEDTIME *gtime;\\r\\nTS_ACCURACY *accuracy;\\r\\nconst ASN1_INTEGER *nonce;\\r\\nGENERAL_NAME *tsa_name;\\r\\nif (a == NULL)\\r\\nreturn 0;\\r\\nv = TS_TST_INFO_get_version(a);\\r\\nBIO_printf(bio, \"Version: %d\\n\", v);\\r\\nBIO_printf(bio, \"Policy OID: \");\\r\\npolicy_id = TS_TST_INFO_get_policy_id(a);\\r\\nTS_OBJ_print_bio(bio, policy_id);\\r\\nTS_MSG_IMPRINT_print_bio(bio, TS_TST_INFO_get_msg_imprint(a));\\r\\nBIO_printf(bio, \"Serial number: \");\\r\\nserial = TS_TST_INFO_get_serial(a);\\r\\nif (serial == NULL)\\r\\nBIO_printf(bio, \"unspecified\");\\r\\nelse\\r\\nTS_ASN1_INTEGER_print_bio(bio, serial);\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\nBIO_printf(bio, \"Time stamp: \");\\r\\ngtime = TS_TST_INFO_get_time(a);\\r\\nASN1_GENERALIZEDTIME_print(bio, gtime);\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\nBIO_printf(bio, \"Accuracy: \");\\r\\naccuracy = TS_TST_INFO_get_accuracy(a);\\r\\nif (accuracy == NULL)\\r\\nBIO_printf(bio, \"unspecified\");\\r\\nelse\\r\\nTS_ACCURACY_print_bio(bio, accuracy);\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\nBIO_printf(bio, \"Ordering: %s\\n\",\\r\\nTS_TST_INFO_get_ordering(a) ? \"yes\" : \"no\");\\r\\nBIO_printf(bio, \"Nonce: \");\\r\\nnonce = TS_TST_INFO_get_nonce(a);\\r\\nif (nonce == NULL)\\r\\nBIO_printf(bio, \"unspecified\");\\r\\nelse\\r\\nTS_ASN1_INTEGER_print_bio(bio, nonce);\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\nBIO_printf(bio, \"TSA: \");\\r\\ntsa_name = TS_TST_INFO_get_tsa(a);\\r\\nif (tsa_name == NULL)\\r\\nBIO_printf(bio, \"unspecified\");\\r\\nelse {\\r\\nSTACK_OF(CONF_VALUE) *nval;\\r\\nif ((nval = i2v_GENERAL_NAME(NULL, tsa_name, NULL)))\\r\\nX509V3_EXT_val_prn(bio, nval, 0, 0);\\r\\nsk_CONF_VALUE_pop_free(nval, X509V3_conf_free);\\r\\n}\\r\\nBIO_write(bio, \"\\n\", 1);\\r\\nTS_ext_print_bio(bio, TS_TST_INFO_get_exts(a));\\r\\nreturn 1;\\r\\n}\\r\\nstatic int TS_ACCURACY_print_bio(BIO *bio, const TS_ACCURACY *accuracy)\\r\\n{\\r\\nconst ASN1_INTEGER *seconds = TS_ACCURACY_get_seconds(accuracy);\\r\\nconst ASN1_INTEGER *millis = TS_ACCURACY_get_millis(accuracy);\\r\\nconst ASN1_INTEGER *micros = TS_ACCURACY_get_micros(accuracy);\\r\\nif (seconds != NULL)\\r\\nTS_ASN1_INTEGER_print_bio(bio, seconds);\\r\\nelse\\r\\nBIO_printf(bio, \"unspecified\");\\r\\nBIO_printf(bio, \" seconds, \");\\r\\nif (millis != NULL)\\r\\nTS_ASN1_INTEGER_print_bio(bio, millis);\\r\\nelse\\r\\nBIO_printf(bio, \"unspecified\");\\r\\nBIO_printf(bio, \" millis, \");\\r\\nif (micros != NULL)\\r\\nTS_ASN1_INTEGER_print_bio(bio, micros);\\r\\nelse\\r\\nBIO_printf(bio, \"unspecified\");\\r\\nBIO_printf(bio, \" micros\");\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_blind_c", "target": 0, "func": "BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod)\\r\\n{\\r\\nBN_BLINDING *ret = NULL;\\r\\nbn_check_top(mod);\\r\\nif ((ret = (BN_BLINDING *)OPENSSL_malloc(sizeof(BN_BLINDING))) == NULL) {\\r\\nBNerr(BN_F_BN_BLINDING_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nmemset(ret, 0, sizeof(BN_BLINDING));\\r\\nif (A != NULL) {\\r\\nif ((ret->A = BN_dup(A)) == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif (Ai != NULL) {\\r\\nif ((ret->Ai = BN_dup(Ai)) == NULL)\\r\\ngoto err;\\r\\n}\\r\\nif ((ret->mod = BN_dup(mod)) == NULL)\\r\\ngoto err;\\r\\nif (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0)\\r\\nBN_set_flags(ret->mod, BN_FLG_CONSTTIME);\\r\\nret->counter = -1;\\r\\nCRYPTO_THREADID_current(&ret->tid);\\r\\nreturn (ret);\\r\\nerr:\\r\\nif (ret != NULL)\\r\\nBN_BLINDING_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nvoid BN_BLINDING_free(BN_BLINDING *r)\\r\\n{\\r\\nif (r == NULL)\\r\\nreturn;\\r\\nif (r->A != NULL)\\r\\nBN_free(r->A);\\r\\nif (r->Ai != NULL)\\r\\nBN_free(r->Ai);\\r\\nif (r->e != NULL)\\r\\nBN_free(r->e);\\r\\nif (r->mod != NULL)\\r\\nBN_free(r->mod);\\r\\nOPENSSL_free(r);\\r\\n}\\r\\nint BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nif ((b->A == NULL) || (b->Ai == NULL)) {\\r\\nBNerr(BN_F_BN_BLINDING_UPDATE, BN_R_NOT_INITIALIZED);\\r\\ngoto err;\\r\\n}\\r\\nif (b->counter == -1)\\r\\nb->counter = 0;\\r\\nif (++b->counter == BN_BLINDING_COUNTER && b->e != NULL &&\\r\\n!(b->flags & BN_BLINDING_NO_RECREATE)) {\\r\\nif (!BN_BLINDING_create_param(b, NULL, NULL, ctx, NULL, NULL))\\r\\ngoto err;\\r\\n} else if (!(b->flags & BN_BLINDING_NO_UPDATE)) {\\r\\nif (!BN_mod_mul(b->A, b->A, b->A, b->mod, ctx))\\r\\ngoto err;\\r\\nif (!BN_mod_mul(b->Ai, b->Ai, b->Ai, b->mod, ctx))\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (b->counter == BN_BLINDING_COUNTER)\\r\\nb->counter = 0;\\r\\nreturn (ret);\\r\\n}\\r\\nint BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_BLINDING_convert_ex(n, NULL, b, ctx);\\r\\n}\\r\\nint BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 1;\\r\\nbn_check_top(n);\\r\\nif ((b->A == NULL) || (b->Ai == NULL)) {\\r\\nBNerr(BN_F_BN_BLINDING_CONVERT_EX, BN_R_NOT_INITIALIZED);\\r\\nreturn (0);\\r\\n}\\r\\nif (b->counter == -1)\\r\\nb->counter = 0;\\r\\nelse if (!BN_BLINDING_update(b, ctx))\\r\\nreturn (0);\\r\\nif (r != NULL) {\\r\\nif (!BN_copy(r, b->Ai))\\r\\nret = 0;\\r\\n}\\r\\nif (!BN_mod_mul(n, n, b->A, b->mod, ctx))\\r\\nret = 0;\\r\\nreturn ret;\\r\\n}\\r\\nint BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)\\r\\n{\\r\\nreturn BN_BLINDING_invert_ex(n, NULL, b, ctx);\\r\\n}\\r\\nint BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret;\\r\\nbn_check_top(n);\\r\\nif (r != NULL)\\r\\nret = BN_mod_mul(n, n, r, b->mod, ctx);\\r\\nelse {\\r\\nif (b->Ai == NULL) {\\r\\nBNerr(BN_F_BN_BLINDING_INVERT_EX, BN_R_NOT_INITIALIZED);\\r\\nreturn (0);\\r\\n}\\r\\nret = BN_mod_mul(n, n, b->Ai, b->mod, ctx);\\r\\n}\\r\\nbn_check_top(n);\\r\\nreturn (ret);\\r\\n}\\r\\nunsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *b)\\r\\n{\\r\\nreturn b->thread_id;\\r\\n}\\r\\nvoid BN_BLINDING_set_thread_id(BN_BLINDING *b, unsigned long n)\\r\\n{\\r\\nb->thread_id = n;\\r\\n}\\r\\nCRYPTO_THREADID *BN_BLINDING_thread_id(BN_BLINDING *b)\\r\\n{\\r\\nreturn &b->tid;\\r\\n}\\r\\nunsigned long BN_BLINDING_get_flags(const BN_BLINDING *b)\\r\\n{\\r\\nreturn b->flags;\\r\\n}\\r\\nvoid BN_BLINDING_set_flags(BN_BLINDING *b, unsigned long flags)\\r\\n{\\r\\nb->flags = flags;\\r\\n}\\r\\nBN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,\\r\\nconst BIGNUM *e, BIGNUM *m, BN_CTX *ctx,\\r\\nint (*bn_mod_exp) (BIGNUM *r,\\r\\nconst BIGNUM *a,\\r\\nconst BIGNUM *p,\\r\\nconst BIGNUM *m,\\r\\nBN_CTX *ctx,\\r\\nBN_MONT_CTX *m_ctx),\\r\\nBN_MONT_CTX *m_ctx)\\r\\n{\\r\\nint retry_counter = 32;\\r\\nBN_BLINDING *ret = NULL;\\r\\nif (b == NULL)\\r\\nret = BN_BLINDING_new(NULL, NULL, m);\\r\\nelse\\r\\nret = b;\\r\\nif (ret == NULL)\\r\\ngoto err;\\r\\nif (ret->A == NULL && (ret->A = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (ret->Ai == NULL && (ret->Ai = BN_new()) == NULL)\\r\\ngoto err;\\r\\nif (e != NULL) {\\r\\nif (ret->e != NULL)\\r\\nBN_free(ret->e);\\r\\nret->e = BN_dup(e);\\r\\n}\\r\\nif (ret->e == NULL)\\r\\ngoto err;\\r\\nif (bn_mod_exp != NULL)\\r\\nret->bn_mod_exp = bn_mod_exp;\\r\\nif (m_ctx != NULL)\\r\\nret->m_ctx = m_ctx;\\r\\ndo {\\r\\nif (!BN_rand_range(ret->A, ret->mod))\\r\\ngoto err;\\r\\nif (BN_mod_inverse(ret->Ai, ret->A, ret->mod, ctx) == NULL) {\\r\\nunsigned long error = ERR_peek_last_error();\\r\\nif (ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\\r\\nif (retry_counter-- == 0) {\\r\\nBNerr(BN_F_BN_BLINDING_CREATE_PARAM,\\r\\nBN_R_TOO_MANY_ITERATIONS);\\r\\ngoto err;\\r\\n}\\r\\nERR_clear_error();\\r\\n} else\\r\\ngoto err;\\r\\n} else\\r\\nbreak;\\r\\n} while (1);\\r\\nif (ret->bn_mod_exp != NULL && ret->m_ctx != NULL) {\\r\\nif (!ret->bn_mod_exp\\r\\n(ret->A, ret->A, ret->e, ret->mod, ctx, ret->m_ctx))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!BN_mod_exp(ret->A, ret->A, ret->e, ret->mod, ctx))\\r\\ngoto err;\\r\\n}\\r\\nreturn ret;\\r\\nerr:\\r\\nif (b == NULL && ret != NULL) {\\r\\nBN_BLINDING_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_set_c", "target": 0, "func": "int X509_set_version(X509 *x, long version)\\r\\n{\\r\\nif (x == NULL)\\r\\nreturn (0);\\r\\nif (version == 0) {\\r\\nM_ASN1_INTEGER_free(x->cert_info->version);\\r\\nx->cert_info->version = NULL;\\r\\nreturn (1);\\r\\n}\\r\\nif (x->cert_info->version == NULL) {\\r\\nif ((x->cert_info->version = M_ASN1_INTEGER_new()) == NULL)\\r\\nreturn (0);\\r\\n}\\r\\nreturn (ASN1_INTEGER_set(x->cert_info->version, version));\\r\\n}\\r\\nint X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial)\\r\\n{\\r\\nASN1_INTEGER *in;\\r\\nif (x == NULL)\\r\\nreturn (0);\\r\\nin = x->cert_info->serialNumber;\\r\\nif (in != serial) {\\r\\nin = M_ASN1_INTEGER_dup(serial);\\r\\nif (in != NULL) {\\r\\nM_ASN1_INTEGER_free(x->cert_info->serialNumber);\\r\\nx->cert_info->serialNumber = in;\\r\\n}\\r\\n}\\r\\nreturn (in != NULL);\\r\\n}\\r\\nint X509_set_issuer_name(X509 *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL))\\r\\nreturn (0);\\r\\nreturn (X509_NAME_set(&x->cert_info->issuer, name));\\r\\n}\\r\\nint X509_set_subject_name(X509 *x, X509_NAME *name)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL))\\r\\nreturn (0);\\r\\nreturn (X509_NAME_set(&x->cert_info->subject, name));\\r\\n}\\r\\nint X509_set_notBefore(X509 *x, const ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif ((x == NULL) || (x->cert_info->validity == NULL))\\r\\nreturn (0);\\r\\nin = x->cert_info->validity->notBefore;\\r\\nif (in != tm) {\\r\\nin = M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL) {\\r\\nM_ASN1_TIME_free(x->cert_info->validity->notBefore);\\r\\nx->cert_info->validity->notBefore = in;\\r\\n}\\r\\n}\\r\\nreturn (in != NULL);\\r\\n}\\r\\nint X509_set_notAfter(X509 *x, const ASN1_TIME *tm)\\r\\n{\\r\\nASN1_TIME *in;\\r\\nif ((x == NULL) || (x->cert_info->validity == NULL))\\r\\nreturn (0);\\r\\nin = x->cert_info->validity->notAfter;\\r\\nif (in != tm) {\\r\\nin = M_ASN1_TIME_dup(tm);\\r\\nif (in != NULL) {\\r\\nM_ASN1_TIME_free(x->cert_info->validity->notAfter);\\r\\nx->cert_info->validity->notAfter = in;\\r\\n}\\r\\n}\\r\\nreturn (in != NULL);\\r\\n}\\r\\nint X509_set_pubkey(X509 *x, EVP_PKEY *pkey)\\r\\n{\\r\\nif ((x == NULL) || (x->cert_info == NULL))\\r\\nreturn (0);\\r\\nreturn (X509_PUBKEY_set(&(x->cert_info->key), pkey));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rc2cfb64_c", "target": 0, "func": "void RC2_cfb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, RC2_KEY *schedule, unsigned char *ivec,\\r\\nint *num, int encrypt)\\r\\n{\\r\\nregister unsigned long v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nunsigned long ti[2];\\r\\nunsigned char *iv, c, cc;\\r\\niv = (unsigned char *)ivec;\\r\\nif (encrypt) {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nc2l(iv, v0);\\r\\nti[0] = v0;\\r\\nc2l(iv, v1);\\r\\nti[1] = v1;\\r\\nRC2_encrypt((unsigned long *)ti, schedule);\\r\\niv = (unsigned char *)ivec;\\r\\nt = ti[0];\\r\\nl2c(t, iv);\\r\\nt = ti[1];\\r\\nl2c(t, iv);\\r\\niv = (unsigned char *)ivec;\\r\\n}\\r\\nc = *(in++) ^ iv[n];\\r\\n*(out++) = c;\\r\\niv[n] = c;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n} else {\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nc2l(iv, v0);\\r\\nti[0] = v0;\\r\\nc2l(iv, v1);\\r\\nti[1] = v1;\\r\\nRC2_encrypt((unsigned long *)ti, schedule);\\r\\niv = (unsigned char *)ivec;\\r\\nt = ti[0];\\r\\nl2c(t, iv);\\r\\nt = ti[1];\\r\\nl2c(t, iv);\\r\\niv = (unsigned char *)ivec;\\r\\n}\\r\\ncc = *(in++);\\r\\nc = iv[n];\\r\\niv[n] = cc;\\r\\n*(out++) = c ^ cc;\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\n}\\r\\nv0 = v1 = ti[0] = ti[1] = t = c = cc = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecp_nistputil_c", "target": 0, "func": "void ec_GFp_nistp_points_make_affine_internal(size_t num, void *point_array,\\r\\nsize_t felem_size,\\r\\nvoid *tmp_felems,\\r\\nvoid (*felem_one) (void *out),\\r\\nint (*felem_is_zero) (const void\\r\\n*in),\\r\\nvoid (*felem_assign) (void *out,\\r\\nconst void\\r\\n*in),\\r\\nvoid (*felem_square) (void *out,\\r\\nconst void\\r\\n*in),\\r\\nvoid (*felem_mul) (void *out,\\r\\nconst void\\r\\n*in1,\\r\\nconst void\\r\\n*in2),\\r\\nvoid (*felem_inv) (void *out,\\r\\nconst void\\r\\n*in),\\r\\nvoid (*felem_contract) (void\\r\\n*out,\\r\\nconst\\r\\nvoid\\r\\n*in))\\r\\n{\\r\\nint i = 0;\\r\\n# define tmp_felem(I) (&((char *)tmp_felems)[(I) * felem_size])\\r\\n# define X(I) (&((char *)point_array)[3*(I) * felem_size])\\r\\n# define Y(I) (&((char *)point_array)[(3*(I) + 1) * felem_size])\\r\\n# define Z(I) (&((char *)point_array)[(3*(I) + 2) * felem_size])\\r\\nif (!felem_is_zero(Z(0)))\\r\\nfelem_assign(tmp_felem(0), Z(0));\\r\\nelse\\r\\nfelem_one(tmp_felem(0));\\r\\nfor (i = 1; i < (int)num; i++) {\\r\\nif (!felem_is_zero(Z(i)))\\r\\nfelem_mul(tmp_felem(i), tmp_felem(i - 1), Z(i));\\r\\nelse\\r\\nfelem_assign(tmp_felem(i), tmp_felem(i - 1));\\r\\n}\\r\\nfelem_inv(tmp_felem(num - 1), tmp_felem(num - 1));\\r\\nfor (i = num - 1; i >= 0; i--) {\\r\\nif (i > 0)\\r\\nfelem_mul(tmp_felem(num), tmp_felem(i - 1), tmp_felem(i));\\r\\nelse\\r\\nfelem_assign(tmp_felem(num), tmp_felem(0));\\r\\nif (!felem_is_zero(Z(i))) {\\r\\nif (i > 0)\\r\\nfelem_mul(tmp_felem(i - 1), tmp_felem(i), Z(i));\\r\\nfelem_square(Z(i), tmp_felem(num));\\r\\nfelem_mul(X(i), X(i), Z(i));\\r\\nfelem_mul(Z(i), Z(i), tmp_felem(num));\\r\\nfelem_mul(Y(i), Y(i), Z(i));\\r\\nfelem_contract(X(i), X(i));\\r\\nfelem_contract(Y(i), Y(i));\\r\\nfelem_one(Z(i));\\r\\n} else {\\r\\nif (i > 0)\\r\\nfelem_assign(tmp_felem(i - 1), tmp_felem(i));\\r\\n}\\r\\n}\\r\\n}\\r\\nvoid ec_GFp_nistp_recode_scalar_bits(unsigned char *sign,\\r\\nunsigned char *digit, unsigned char in)\\r\\n{\\r\\nunsigned char s, d;\\r\\ns = ~((in >> 5) - 1);\\r\\nd = (1 << 6) - in - 1;\\r\\nd = (d & s) | (in & ~s);\\r\\nd = (d >> 1) + (d & 1);\\r\\n*sign = s & 1;\\r\\n*digit = d;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_i_ecb_c", "target": 0, "func": "const char *idea_options(void)\\r\\n{\\r\\nif (sizeof(short) != sizeof(IDEA_INT))\\r\\nreturn (\"idea(int)\");\\r\\nelse\\r\\nreturn (\"idea(short)\");\\r\\n}\\r\\nvoid idea_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nIDEA_KEY_SCHEDULE *ks)\\r\\n{\\r\\nunsigned long l0, l1, d[2];\\r\\nn2l(in, l0);\\r\\nd[0] = l0;\\r\\nn2l(in, l1);\\r\\nd[1] = l1;\\r\\nidea_encrypt(d, ks);\\r\\nl0 = d[0];\\r\\nl2n(l0, out);\\r\\nl1 = d[1];\\r\\nl2n(l1, out);\\r\\nl0 = l1 = d[0] = d[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t_req_c", "target": 0, "func": "int X509_REQ_print_fp(FILE *fp, X509_REQ *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nX509err(X509_F_X509_REQ_PRINT_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = X509_REQ_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflags,\\r\\nunsigned long cflag)\\r\\n{\\r\\nunsigned long l;\\r\\nint i;\\r\\nconst char *neg;\\r\\nX509_REQ_INFO *ri;\\r\\nEVP_PKEY *pkey;\\r\\nSTACK_OF(X509_ATTRIBUTE) *sk;\\r\\nSTACK_OF(X509_EXTENSION) *exts;\\r\\nchar mlch = ' ';\\r\\nint nmindent = 0;\\r\\nif ((nmflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {\\r\\nmlch = '\\n';\\r\\nnmindent = 12;\\r\\n}\\r\\nif (nmflags == X509_FLAG_COMPAT)\\r\\nnmindent = 16;\\r\\nri = x->req_info;\\r\\nif (!(cflag & X509_FLAG_NO_HEADER)) {\\r\\nif (BIO_write(bp, \"Certificate Request:\\n\", 21) <= 0)\\r\\ngoto err;\\r\\nif (BIO_write(bp, \" Data:\\n\", 10) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_VERSION)) {\\r\\nneg = (ri->version->type == V_ASN1_NEG_INTEGER) ? \"-\" : \"\";\\r\\nl = 0;\\r\\nfor (i = 0; i < ri->version->length; i++) {\\r\\nl <<= 8;\\r\\nl += ri->version->data[i];\\r\\n}\\r\\nif (BIO_printf(bp, \"%8sVersion: %s%lu (%s0x%lx)\\n\", \"\", neg, l, neg,\\r\\nl) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_SUBJECT)) {\\r\\nif (BIO_printf(bp, \" Subject:%c\", mlch) <= 0)\\r\\ngoto err;\\r\\nif (X509_NAME_print_ex(bp, ri->subject, nmindent, nmflags) < 0)\\r\\ngoto err;\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_PUBKEY)) {\\r\\nif (BIO_write(bp, \" Subject Public Key Info:\\n\", 33) <= 0)\\r\\ngoto err;\\r\\nif (BIO_printf(bp, \"%12sPublic Key Algorithm: \", \"\") <= 0)\\r\\ngoto err;\\r\\nif (i2a_ASN1_OBJECT(bp, ri->pubkey->algor->algorithm) <= 0)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \"\\n\") <= 0)\\r\\ngoto err;\\r\\npkey = X509_REQ_get_pubkey(x);\\r\\nif (pkey == NULL) {\\r\\nBIO_printf(bp, \"%12sUnable to load Public Key\\n\", \"\");\\r\\nERR_print_errors(bp);\\r\\n} else {\\r\\nEVP_PKEY_print_public(bp, pkey, 16, NULL);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_ATTRIBUTES)) {\\r\\nif (BIO_printf(bp, \"%8sAttributes:\\n\", \"\") <= 0)\\r\\ngoto err;\\r\\nsk = x->req_info->attributes;\\r\\nif (sk_X509_ATTRIBUTE_num(sk) == 0) {\\r\\nif (BIO_printf(bp, \"%12sa0:00\\n\", \"\") <= 0)\\r\\ngoto err;\\r\\n} else {\\r\\nfor (i = 0; i < sk_X509_ATTRIBUTE_num(sk); i++) {\\r\\nASN1_TYPE *at;\\r\\nX509_ATTRIBUTE *a;\\r\\nASN1_BIT_STRING *bs = NULL;\\r\\nASN1_TYPE *t;\\r\\nint j, type = 0, count = 1, ii = 0;\\r\\na = sk_X509_ATTRIBUTE_value(sk, i);\\r\\nif (X509_REQ_extension_nid(OBJ_obj2nid(a->object)))\\r\\ncontinue;\\r\\nif (BIO_printf(bp, \"%12s\", \"\") <= 0)\\r\\ngoto err;\\r\\nif ((j = i2a_ASN1_OBJECT(bp, a->object)) > 0) {\\r\\nif (a->single) {\\r\\nt = a->value.single;\\r\\ntype = t->type;\\r\\nbs = t->value.bit_string;\\r\\n} else {\\r\\nii = 0;\\r\\ncount = sk_ASN1_TYPE_num(a->value.set);\\r\\nget_next:\\r\\nat = sk_ASN1_TYPE_value(a->value.set, ii);\\r\\ntype = at->type;\\r\\nbs = at->value.asn1_string;\\r\\n}\\r\\n}\\r\\nfor (j = 25 - j; j > 0; j--)\\r\\nif (BIO_write(bp, \" \", 1) != 1)\\r\\ngoto err;\\r\\nif (BIO_puts(bp, \":\") <= 0)\\r\\ngoto err;\\r\\nif ((type == V_ASN1_PRINTABLESTRING) ||\\r\\n(type == V_ASN1_T61STRING) ||\\r\\n(type == V_ASN1_IA5STRING)) {\\r\\nif (BIO_write(bp, (char *)bs->data, bs->length)\\r\\n!= bs->length)\\r\\ngoto err;\\r\\nBIO_puts(bp, \"\\n\");\\r\\n} else {\\r\\nBIO_puts(bp, \"unable to print attribute\\n\");\\r\\n}\\r\\nif (++ii < count)\\r\\ngoto get_next;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_EXTENSIONS)) {\\r\\nexts = X509_REQ_get_extensions(x);\\r\\nif (exts) {\\r\\nBIO_printf(bp, \"%8sRequested Extensions:\\n\", \"\");\\r\\nfor (i = 0; i < sk_X509_EXTENSION_num(exts); i++) {\\r\\nASN1_OBJECT *obj;\\r\\nX509_EXTENSION *ex;\\r\\nint j;\\r\\nex = sk_X509_EXTENSION_value(exts, i);\\r\\nif (BIO_printf(bp, \"%12s\", \"\") <= 0)\\r\\ngoto err;\\r\\nobj = X509_EXTENSION_get_object(ex);\\r\\ni2a_ASN1_OBJECT(bp, obj);\\r\\nj = X509_EXTENSION_get_critical(ex);\\r\\nif (BIO_printf(bp, \": %s\\n\", j ? \"critical\" : \"\") <= 0)\\r\\ngoto err;\\r\\nif (!X509V3_EXT_print(bp, ex, cflag, 16)) {\\r\\nBIO_printf(bp, \"%16s\", \"\");\\r\\nM_ASN1_OCTET_STRING_print(bp, ex->value);\\r\\n}\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nsk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);\\r\\n}\\r\\n}\\r\\nif (!(cflag & X509_FLAG_NO_SIGDUMP)) {\\r\\nif (!X509_signature_print(bp, x->sig_alg, x->signature))\\r\\ngoto err;\\r\\n}\\r\\nreturn (1);\\r\\nerr:\\r\\nX509err(X509_F_X509_REQ_PRINT_EX, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nint X509_REQ_print(BIO *bp, X509_REQ *x)\\r\\n{\\r\\nreturn X509_REQ_print_ex(bp, x, XN_FLAG_COMPAT, X509_FLAG_COMPAT);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tasn_fre_c", "target": 0, "func": "void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it)\\r\\n{\\r\\nasn1_item_combine_free(&val, it, 0);\\r\\n}\\r\\nvoid ASN1_item_ex_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nasn1_item_combine_free(pval, it, 0);\\r\\n}\\r\\nstatic void asn1_item_combine_free(ASN1_VALUE **pval, const ASN1_ITEM *it,\\r\\nint combine)\\r\\n{\\r\\nconst ASN1_TEMPLATE *tt = NULL, *seqtt;\\r\\nconst ASN1_EXTERN_FUNCS *ef;\\r\\nconst ASN1_COMPAT_FUNCS *cf;\\r\\nconst ASN1_AUX *aux = it->funcs;\\r\\nASN1_aux_cb *asn1_cb;\\r\\nint i;\\r\\nif (!pval)\\r\\nreturn;\\r\\nif ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)\\r\\nreturn;\\r\\nif (aux && aux->asn1_cb)\\r\\nasn1_cb = aux->asn1_cb;\\r\\nelse\\r\\nasn1_cb = 0;\\r\\nswitch (it->itype) {\\r\\ncase ASN1_ITYPE_PRIMITIVE:\\r\\nif (it->templates)\\r\\nASN1_template_free(pval, it->templates);\\r\\nelse\\r\\nASN1_primitive_free(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_MSTRING:\\r\\nASN1_primitive_free(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_CHOICE:\\r\\nif (asn1_cb) {\\r\\ni = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\\r\\nif (i == 2)\\r\\nreturn;\\r\\n}\\r\\ni = asn1_get_choice_selector(pval, it);\\r\\nif ((i >= 0) && (i < it->tcount)) {\\r\\nASN1_VALUE **pchval;\\r\\ntt = it->templates + i;\\r\\npchval = asn1_get_field_ptr(pval, tt);\\r\\nASN1_template_free(pchval, tt);\\r\\n}\\r\\nif (asn1_cb)\\r\\nasn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\\r\\nif (!combine) {\\r\\nOPENSSL_free(*pval);\\r\\n*pval = NULL;\\r\\n}\\r\\nbreak;\\r\\ncase ASN1_ITYPE_COMPAT:\\r\\ncf = it->funcs;\\r\\nif (cf && cf->asn1_free)\\r\\ncf->asn1_free(*pval);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_EXTERN:\\r\\nef = it->funcs;\\r\\nif (ef && ef->asn1_ex_free)\\r\\nef->asn1_ex_free(pval, it);\\r\\nbreak;\\r\\ncase ASN1_ITYPE_NDEF_SEQUENCE:\\r\\ncase ASN1_ITYPE_SEQUENCE:\\r\\nif (asn1_do_lock(pval, -1, it) > 0)\\r\\nreturn;\\r\\nif (asn1_cb) {\\r\\ni = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);\\r\\nif (i == 2)\\r\\nreturn;\\r\\n}\\r\\nasn1_enc_free(pval, it);\\r\\ntt = it->templates + it->tcount - 1;\\r\\nfor (i = 0; i < it->tcount; tt--, i++) {\\r\\nASN1_VALUE **pseqval;\\r\\nseqtt = asn1_do_adb(pval, tt, 0);\\r\\nif (!seqtt)\\r\\ncontinue;\\r\\npseqval = asn1_get_field_ptr(pval, seqtt);\\r\\nASN1_template_free(pseqval, seqtt);\\r\\n}\\r\\nif (asn1_cb)\\r\\nasn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);\\r\\nif (!combine) {\\r\\nOPENSSL_free(*pval);\\r\\n*pval = NULL;\\r\\n}\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvoid ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nint i;\\r\\nif (tt->flags & ASN1_TFLG_SK_MASK) {\\r\\nSTACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;\\r\\nfor (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {\\r\\nASN1_VALUE *vtmp;\\r\\nvtmp = sk_ASN1_VALUE_value(sk, i);\\r\\nasn1_item_combine_free(&vtmp, ASN1_ITEM_ptr(tt->item), 0);\\r\\n}\\r\\nsk_ASN1_VALUE_free(sk);\\r\\n*pval = NULL;\\r\\n} else\\r\\nasn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),\\r\\ntt->flags & ASN1_TFLG_COMBINE);\\r\\n}\\r\\nvoid ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nint utype;\\r\\nif (it) {\\r\\nconst ASN1_PRIMITIVE_FUNCS *pf;\\r\\npf = it->funcs;\\r\\nif (pf && pf->prim_free) {\\r\\npf->prim_free(pval, it);\\r\\nreturn;\\r\\n}\\r\\n}\\r\\nif (!it) {\\r\\nASN1_TYPE *typ = (ASN1_TYPE *)*pval;\\r\\nutype = typ->type;\\r\\npval = &typ->value.asn1_value;\\r\\nif (!*pval)\\r\\nreturn;\\r\\n} else if (it->itype == ASN1_ITYPE_MSTRING) {\\r\\nutype = -1;\\r\\nif (!*pval)\\r\\nreturn;\\r\\n} else {\\r\\nutype = it->utype;\\r\\nif ((utype != V_ASN1_BOOLEAN) && !*pval)\\r\\nreturn;\\r\\n}\\r\\nswitch (utype) {\\r\\ncase V_ASN1_OBJECT:\\r\\nASN1_OBJECT_free((ASN1_OBJECT *)*pval);\\r\\nbreak;\\r\\ncase V_ASN1_BOOLEAN:\\r\\nif (it)\\r\\n*(ASN1_BOOLEAN *)pval = it->size;\\r\\nelse\\r\\n*(ASN1_BOOLEAN *)pval = -1;\\r\\nreturn;\\r\\ncase V_ASN1_NULL:\\r\\nbreak;\\r\\ncase V_ASN1_ANY:\\r\\nASN1_primitive_free(pval, NULL);\\r\\nOPENSSL_free(*pval);\\r\\nbreak;\\r\\ndefault:\\r\\nASN1_STRING_free((ASN1_STRING *)*pval);\\r\\n*pval = NULL;\\r\\nbreak;\\r\\n}\\r\\n*pval = NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_m_mdc2_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn MDC2_Init(ctx->md_data);\\r\\n}\\r\\nstatic int update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn MDC2_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn MDC2_Final(md, ctx->md_data);\\r\\n}\\r\\nconst EVP_MD *EVP_mdc2(void)\\r\\n{\\r\\nreturn (&mdc2_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_buffer_c", "target": 0, "func": "BUF_MEM *BUF_MEM_new(void)\\r\\n{\\r\\nBUF_MEM *ret;\\r\\nret = OPENSSL_malloc(sizeof(BUF_MEM));\\r\\nif (ret == NULL) {\\r\\nBUFerr(BUF_F_BUF_MEM_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn (NULL);\\r\\n}\\r\\nret->length = 0;\\r\\nret->max = 0;\\r\\nret->data = NULL;\\r\\nreturn (ret);\\r\\n}\\r\\nvoid BUF_MEM_free(BUF_MEM *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn;\\r\\nif (a->data != NULL) {\\r\\nmemset(a->data, 0, (unsigned int)a->max);\\r\\nOPENSSL_free(a->data);\\r\\n}\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nint BUF_MEM_grow(BUF_MEM *str, size_t len)\\r\\n{\\r\\nchar *ret;\\r\\nsize_t n;\\r\\nif (str->length >= len) {\\r\\nstr->length = len;\\r\\nreturn (len);\\r\\n}\\r\\nif (str->max >= len) {\\r\\nmemset(&str->data[str->length], 0, len - str->length);\\r\\nstr->length = len;\\r\\nreturn (len);\\r\\n}\\r\\nif (len > LIMIT_BEFORE_EXPANSION) {\\r\\nBUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nn = (len + 3) / 3 * 4;\\r\\nif (str->data == NULL)\\r\\nret = OPENSSL_malloc(n);\\r\\nelse\\r\\nret = OPENSSL_realloc(str->data, n);\\r\\nif (ret == NULL) {\\r\\nBUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);\\r\\nlen = 0;\\r\\n} else {\\r\\nstr->data = ret;\\r\\nstr->max = n;\\r\\nmemset(&str->data[str->length], 0, len - str->length);\\r\\nstr->length = len;\\r\\n}\\r\\nreturn (len);\\r\\n}\\r\\nint BUF_MEM_grow_clean(BUF_MEM *str, size_t len)\\r\\n{\\r\\nchar *ret;\\r\\nsize_t n;\\r\\nif (str->length >= len) {\\r\\nmemset(&str->data[len], 0, str->length - len);\\r\\nstr->length = len;\\r\\nreturn (len);\\r\\n}\\r\\nif (str->max >= len) {\\r\\nmemset(&str->data[str->length], 0, len - str->length);\\r\\nstr->length = len;\\r\\nreturn (len);\\r\\n}\\r\\nif (len > LIMIT_BEFORE_EXPANSION) {\\r\\nBUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nn = (len + 3) / 3 * 4;\\r\\nif (str->data == NULL)\\r\\nret = OPENSSL_malloc(n);\\r\\nelse\\r\\nret = OPENSSL_realloc_clean(str->data, str->max, n);\\r\\nif (ret == NULL) {\\r\\nBUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);\\r\\nlen = 0;\\r\\n} else {\\r\\nstr->data = ret;\\r\\nstr->max = n;\\r\\nmemset(&str->data[str->length], 0, len - str->length);\\r\\nstr->length = len;\\r\\n}\\r\\nreturn (len);\\r\\n}\\r\\nvoid BUF_reverse(unsigned char *out, const unsigned char *in, size_t size)\\r\\n{\\r\\nsize_t i;\\r\\nif (in) {\\r\\nout += size - 1;\\r\\nfor (i = 0; i < size; i++)\\r\\n*out-- = *in++;\\r\\n} else {\\r\\nunsigned char *q;\\r\\nchar c;\\r\\nq = out + size - 1;\\r\\nfor (i = 0; i < size / 2; i++) {\\r\\nc = *q;\\r\\n*q-- = *out;\\r\\n*out++ = c;\\r\\n}\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_ofb64_c", "target": 0, "func": "void BF_ofb64_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, const BF_KEY *schedule,\\r\\nunsigned char *ivec, int *num)\\r\\n{\\r\\nregister BF_LONG v0, v1, t;\\r\\nregister int n = *num;\\r\\nregister long l = length;\\r\\nunsigned char d[8];\\r\\nregister char *dp;\\r\\nBF_LONG ti[2];\\r\\nunsigned char *iv;\\r\\nint save = 0;\\r\\niv = (unsigned char *)ivec;\\r\\nn2l(iv, v0);\\r\\nn2l(iv, v1);\\r\\nti[0] = v0;\\r\\nti[1] = v1;\\r\\ndp = (char *)d;\\r\\nl2n(v0, dp);\\r\\nl2n(v1, dp);\\r\\nwhile (l--) {\\r\\nif (n == 0) {\\r\\nBF_encrypt((BF_LONG *)ti, schedule);\\r\\ndp = (char *)d;\\r\\nt = ti[0];\\r\\nl2n(t, dp);\\r\\nt = ti[1];\\r\\nl2n(t, dp);\\r\\nsave++;\\r\\n}\\r\\n*(out++) = *(in++) ^ d[n];\\r\\nn = (n + 1) & 0x07;\\r\\n}\\r\\nif (save) {\\r\\nv0 = ti[0];\\r\\nv1 = ti[1];\\r\\niv = (unsigned char *)ivec;\\r\\nl2n(v0, iv);\\r\\nl2n(v1, iv);\\r\\n}\\r\\nt = v0 = v1 = ti[0] = ti[1] = 0;\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tb_rand_c", "target": 0, "func": "void ENGINE_unregister_RAND(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&rand_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_RAND(void)\\r\\n{\\r\\nengine_table_cleanup(&rand_table);\\r\\n}\\r\\nint ENGINE_register_RAND(ENGINE *e)\\r\\n{\\r\\nif (e->rand_meth)\\r\\nreturn engine_table_register(&rand_table,\\r\\nengine_unregister_all_RAND, e,\\r\\n&dummy_nid, 1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_RAND()\\r\\n{\\r\\nENGINE *e;\\r\\nfor (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))\\r\\nENGINE_register_RAND(e);\\r\\n}\\r\\nint ENGINE_set_default_RAND(ENGINE *e)\\r\\n{\\r\\nif (e->rand_meth)\\r\\nreturn engine_table_register(&rand_table,\\r\\nengine_unregister_all_RAND, e,\\r\\n&dummy_nid, 1, 1);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_RAND(void)\\r\\n{\\r\\nreturn engine_table_select(&rand_table, dummy_nid);\\r\\n}\\r\\nconst RAND_METHOD *ENGINE_get_RAND(const ENGINE *e)\\r\\n{\\r\\nreturn e->rand_meth;\\r\\n}\\r\\nint ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth)\\r\\n{\\r\\ne->rand_meth = rand_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_encode_c", "target": 0, "func": "void EVP_EncodeInit(EVP_ENCODE_CTX *ctx)\\r\\n{\\r\\nctx->length = 48;\\r\\nctx->num = 0;\\r\\nctx->line_num = 0;\\r\\n}\\r\\nvoid EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nint i, j;\\r\\nunsigned int total = 0;\\r\\n*outl = 0;\\r\\nif (inl == 0)\\r\\nreturn;\\r\\nOPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));\\r\\nif ((ctx->num + inl) < ctx->length) {\\r\\nmemcpy(&(ctx->enc_data[ctx->num]), in, inl);\\r\\nctx->num += inl;\\r\\nreturn;\\r\\n}\\r\\nif (ctx->num != 0) {\\r\\ni = ctx->length - ctx->num;\\r\\nmemcpy(&(ctx->enc_data[ctx->num]), in, i);\\r\\nin += i;\\r\\ninl -= i;\\r\\nj = EVP_EncodeBlock(out, ctx->enc_data, ctx->length);\\r\\nctx->num = 0;\\r\\nout += j;\\r\\n*(out++) = '\\n';\\r\\n*out = '\\0';\\r\\ntotal = j + 1;\\r\\n}\\r\\nwhile (inl >= ctx->length) {\\r\\nj = EVP_EncodeBlock(out, in, ctx->length);\\r\\nin += ctx->length;\\r\\ninl -= ctx->length;\\r\\nout += j;\\r\\n*(out++) = '\\n';\\r\\n*out = '\\0';\\r\\ntotal += j + 1;\\r\\n}\\r\\nif (inl != 0)\\r\\nmemcpy(&(ctx->enc_data[0]), in, inl);\\r\\nctx->num = inl;\\r\\n*outl = total;\\r\\n}\\r\\nvoid EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nunsigned int ret = 0;\\r\\nif (ctx->num != 0) {\\r\\nret = EVP_EncodeBlock(out, ctx->enc_data, ctx->num);\\r\\nout[ret++] = '\\n';\\r\\nout[ret] = '\\0';\\r\\nctx->num = 0;\\r\\n}\\r\\n*outl = ret;\\r\\n}\\r\\nint EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int dlen)\\r\\n{\\r\\nint i, ret = 0;\\r\\nunsigned long l;\\r\\nfor (i = dlen; i > 0; i -= 3) {\\r\\nif (i >= 3) {\\r\\nl = (((unsigned long)f[0]) << 16L) |\\r\\n(((unsigned long)f[1]) << 8L) | f[2];\\r\\n*(t++) = conv_bin2ascii(l >> 18L);\\r\\n*(t++) = conv_bin2ascii(l >> 12L);\\r\\n*(t++) = conv_bin2ascii(l >> 6L);\\r\\n*(t++) = conv_bin2ascii(l);\\r\\n} else {\\r\\nl = ((unsigned long)f[0]) << 16L;\\r\\nif (i == 2)\\r\\nl |= ((unsigned long)f[1] << 8L);\\r\\n*(t++) = conv_bin2ascii(l >> 18L);\\r\\n*(t++) = conv_bin2ascii(l >> 12L);\\r\\n*(t++) = (i == 1) ? '=' : conv_bin2ascii(l >> 6L);\\r\\n*(t++) = '=';\\r\\n}\\r\\nret += 4;\\r\\nf += 3;\\r\\n}\\r\\n*t = '\\0';\\r\\nreturn (ret);\\r\\n}\\r\\nvoid EVP_DecodeInit(EVP_ENCODE_CTX *ctx)\\r\\n{\\r\\nctx->length = 30;\\r\\nctx->num = 0;\\r\\nctx->line_num = 0;\\r\\nctx->expect_nl = 0;\\r\\n}\\r\\nint EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\\r\\nconst unsigned char *in, int inl)\\r\\n{\\r\\nint seof = -1, eof = 0, rv = -1, ret = 0, i, v, tmp, n, ln, exp_nl;\\r\\nunsigned char *d;\\r\\nn = ctx->num;\\r\\nd = ctx->enc_data;\\r\\nln = ctx->line_num;\\r\\nexp_nl = ctx->expect_nl;\\r\\nif ((inl == 0) || ((n == 0) && (conv_ascii2bin(in[0]) == B64_EOF))) {\\r\\nrv = 0;\\r\\ngoto end;\\r\\n}\\r\\nfor (i = 0; i < inl; i++) {\\r\\nif (ln >= 80) {\\r\\nrv = -1;\\r\\ngoto end;\\r\\n}\\r\\ntmp = *(in++);\\r\\nv = conv_ascii2bin(tmp);\\r\\nif (!B64_NOT_BASE64(v)) {\\r\\nOPENSSL_assert(n < (int)sizeof(ctx->enc_data));\\r\\nd[n++] = tmp;\\r\\nln++;\\r\\n} else if (v == B64_ERROR) {\\r\\nrv = -1;\\r\\ngoto end;\\r\\n}\\r\\nif (tmp == '=') {\\r\\nif (seof == -1)\\r\\nseof = n;\\r\\neof++;\\r\\n}\\r\\nif (v == B64_CR) {\\r\\nln = 0;\\r\\nif (exp_nl)\\r\\ncontinue;\\r\\n}\\r\\nif (v == B64_EOLN) {\\r\\nln = 0;\\r\\nif (exp_nl) {\\r\\nexp_nl = 0;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nexp_nl = 0;\\r\\nif (((i + 1) == inl) && (((n & 3) == 0) || eof)) {\\r\\nv = B64_EOF;\\r\\neof = 0;\\r\\nif (d[n - 1] == '=')\\r\\neof++;\\r\\nif (d[n - 2] == '=')\\r\\neof++;\\r\\n}\\r\\nif ((v == B64_EOF && (n & 3) == 0) || (n >= 64)) {\\r\\nif ((v != B64_EOF) && (n >= 64))\\r\\nexp_nl = 1;\\r\\nif (n > 0) {\\r\\nv = EVP_DecodeBlock(out, d, n);\\r\\nn = 0;\\r\\nif (v < 0) {\\r\\nrv = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (eof > v) {\\r\\nrv = -1;\\r\\ngoto end;\\r\\n}\\r\\nret += (v - eof);\\r\\n} else {\\r\\neof = 1;\\r\\nv = 0;\\r\\n}\\r\\nif ((v < ctx->length) && eof) {\\r\\nrv = 0;\\r\\ngoto end;\\r\\n} else\\r\\nctx->length = v;\\r\\nif (seof >= 0) {\\r\\nrv = 0;\\r\\ngoto end;\\r\\n}\\r\\nout += v;\\r\\n}\\r\\n}\\r\\nrv = 1;\\r\\nend:\\r\\n*outl = ret;\\r\\nctx->num = n;\\r\\nctx->line_num = ln;\\r\\nctx->expect_nl = exp_nl;\\r\\nreturn (rv);\\r\\n}\\r\\nint EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n)\\r\\n{\\r\\nint i, ret = 0, a, b, c, d;\\r\\nunsigned long l;\\r\\nwhile ((conv_ascii2bin(*f) == B64_WS) && (n > 0)) {\\r\\nf++;\\r\\nn--;\\r\\n}\\r\\nwhile ((n > 3) && (B64_NOT_BASE64(conv_ascii2bin(f[n - 1]))))\\r\\nn--;\\r\\nif (n % 4 != 0)\\r\\nreturn (-1);\\r\\nfor (i = 0; i < n; i += 4) {\\r\\na = conv_ascii2bin(*(f++));\\r\\nb = conv_ascii2bin(*(f++));\\r\\nc = conv_ascii2bin(*(f++));\\r\\nd = conv_ascii2bin(*(f++));\\r\\nif ((a & 0x80) || (b & 0x80) || (c & 0x80) || (d & 0x80))\\r\\nreturn (-1);\\r\\nl = ((((unsigned long)a) << 18L) |\\r\\n(((unsigned long)b) << 12L) |\\r\\n(((unsigned long)c) << 6L) | (((unsigned long)d)));\\r\\n*(t++) = (unsigned char)(l >> 16L) & 0xff;\\r\\n*(t++) = (unsigned char)(l >> 8L) & 0xff;\\r\\n*(t++) = (unsigned char)(l) & 0xff;\\r\\nret += 3;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i;\\r\\n*outl = 0;\\r\\nif (ctx->num != 0) {\\r\\ni = EVP_DecodeBlock(out, ctx->enc_data, ctx->num);\\r\\nif (i < 0)\\r\\nreturn (-1);\\r\\nctx->num = 0;\\r\\n*outl = i;\\r\\nreturn (1);\\r\\n} else\\r\\nreturn (1);\\r\\n}\\r\\nint EVP_DecodeValid(unsigned char *buf, int len)\\r\\n{\\r\\nint i, num = 0, bad = 0;\\r\\nif (len == 0)\\r\\nreturn (-1);\\r\\nwhile (conv_ascii2bin(*buf) == B64_WS) {\\r\\nbuf++;\\r\\nlen--;\\r\\nif (len == 0)\\r\\nreturn (-1);\\r\\n}\\r\\nfor (i = len; i >= 4; i -= 4) {\\r\\nif ((conv_ascii2bin(buf[0]) >= 0x40) ||\\r\\n(conv_ascii2bin(buf[1]) >= 0x40) ||\\r\\n(conv_ascii2bin(buf[2]) >= 0x40) ||\\r\\n(conv_ascii2bin(buf[3]) >= 0x40))\\r\\nreturn (-1);\\r\\nbuf += 4;\\r\\nnum += 1 + (buf[2] != '=') + (buf[3] != '=');\\r\\n}\\r\\nif ((i == 1) && (conv_ascii2bin(buf[0]) == B64_EOLN))\\r\\nreturn (num);\\r\\nif ((i == 2) && (conv_ascii2bin(buf[0]) == B64_EOLN) &&\\r\\n(conv_ascii2bin(buf[0]) == B64_EOLN))\\r\\nreturn (num);\\r\\nreturn (1);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_file_c", "target": 0, "func": "BIO *BIO_new_file(const char *filename, const char *mode)\\r\\n{\\r\\nBIO *ret;\\r\\nFILE *file = NULL;\\r\\n# if defined(_WIN32) && defined(CP_UTF8)\\r\\nint sz, len_0 = (int)strlen(filename) + 1;\\r\\nDWORD flags;\\r\\nif ((sz = MultiByteToWideChar(CP_UTF8, (flags = MB_ERR_INVALID_CHARS),\\r\\nfilename, len_0, NULL, 0)) > 0 ||\\r\\n(GetLastError() == ERROR_INVALID_FLAGS &&\\r\\n(sz = MultiByteToWideChar(CP_UTF8, (flags = 0),\\r\\nfilename, len_0, NULL, 0)) > 0)\\r\\n) {\\r\\nWCHAR wmode[8];\\r\\nWCHAR *wfilename = _alloca(sz * sizeof(WCHAR));\\r\\nif (MultiByteToWideChar(CP_UTF8, flags,\\r\\nfilename, len_0, wfilename, sz) &&\\r\\nMultiByteToWideChar(CP_UTF8, 0, mode, strlen(mode) + 1,\\r\\nwmode, sizeof(wmode) / sizeof(wmode[0])) &&\\r\\n(file = _wfopen(wfilename, wmode)) == NULL &&\\r\\n(errno == ENOENT || errno == EBADF)\\r\\n) {\\r\\nfile = fopen(filename, mode);\\r\\n}\\r\\n} else if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION) {\\r\\nfile = fopen(filename, mode);\\r\\n}\\r\\n# else\\r\\nfile = fopen(filename, mode);\\r\\n# endif\\r\\nif (file == NULL) {\\r\\nSYSerr(SYS_F_FOPEN, get_last_sys_error());\\r\\nERR_add_error_data(5, \"fopen('\", filename, \"','\", mode, \"')\");\\r\\nif (errno == ENOENT)\\r\\nBIOerr(BIO_F_BIO_NEW_FILE, BIO_R_NO_SUCH_FILE);\\r\\nelse\\r\\nBIOerr(BIO_F_BIO_NEW_FILE, ERR_R_SYS_LIB);\\r\\nreturn (NULL);\\r\\n}\\r\\nif ((ret = BIO_new(BIO_s_file())) == NULL) {\\r\\nfclose(file);\\r\\nreturn (NULL);\\r\\n}\\r\\nBIO_clear_flags(ret, BIO_FLAGS_UPLINK);\\r\\nBIO_set_fp(ret, file, BIO_CLOSE);\\r\\nreturn (ret);\\r\\n}\\r\\nBIO *BIO_new_fp(FILE *stream, int close_flag)\\r\\n{\\r\\nBIO *ret;\\r\\nif ((ret = BIO_new(BIO_s_file())) == NULL)\\r\\nreturn (NULL);\\r\\nBIO_set_flags(ret, BIO_FLAGS_UPLINK);\\r\\nBIO_set_fp(ret, stream, close_flag);\\r\\nreturn (ret);\\r\\n}\\r\\nBIO_METHOD *BIO_s_file(void)\\r\\n{\\r\\nreturn (&methods_filep);\\r\\n}\\r\\nstatic int MS_CALLBACK file_new(BIO *bi)\\r\\n{\\r\\nbi->init = 0;\\r\\nbi->num = 0;\\r\\nbi->ptr = NULL;\\r\\nbi->flags = BIO_FLAGS_UPLINK;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int MS_CALLBACK file_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nif (a->shutdown) {\\r\\nif ((a->init) && (a->ptr != NULL)) {\\r\\nif (a->flags & BIO_FLAGS_UPLINK)\\r\\nUP_fclose(a->ptr);\\r\\nelse\\r\\nfclose(a->ptr);\\r\\na->ptr = NULL;\\r\\na->flags = BIO_FLAGS_UPLINK;\\r\\n}\\r\\na->init = 0;\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nstatic int MS_CALLBACK file_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nif (b->init && (out != NULL)) {\\r\\nif (b->flags & BIO_FLAGS_UPLINK)\\r\\nret = UP_fread(out, 1, (int)outl, b->ptr);\\r\\nelse\\r\\nret = fread(out, 1, (int)outl, (FILE *)b->ptr);\\r\\nif (ret == 0\\r\\n&& (b->flags & BIO_FLAGS_UPLINK) ? UP_ferror((FILE *)b->ptr) :\\r\\nferror((FILE *)b->ptr)) {\\r\\nSYSerr(SYS_F_FREAD, get_last_sys_error());\\r\\nBIOerr(BIO_F_FILE_READ, ERR_R_SYS_LIB);\\r\\nret = -1;\\r\\n}\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int MS_CALLBACK file_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret = 0;\\r\\nif (b->init && (in != NULL)) {\\r\\nif (b->flags & BIO_FLAGS_UPLINK)\\r\\nret = UP_fwrite(in, (int)inl, 1, b->ptr);\\r\\nelse\\r\\nret = fwrite(in, (int)inl, 1, (FILE *)b->ptr);\\r\\nif (ret)\\r\\nret = inl;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long MS_CALLBACK file_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret = 1;\\r\\nFILE *fp = (FILE *)b->ptr;\\r\\nFILE **fpp;\\r\\nchar p[4];\\r\\nswitch (cmd) {\\r\\ncase BIO_C_FILE_SEEK:\\r\\ncase BIO_CTRL_RESET:\\r\\nif (b->flags & BIO_FLAGS_UPLINK)\\r\\nret = (long)UP_fseek(b->ptr, num, 0);\\r\\nelse\\r\\nret = (long)fseek(fp, num, 0);\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\nif (b->flags & BIO_FLAGS_UPLINK)\\r\\nret = (long)UP_feof(fp);\\r\\nelse\\r\\nret = (long)feof(fp);\\r\\nbreak;\\r\\ncase BIO_C_FILE_TELL:\\r\\ncase BIO_CTRL_INFO:\\r\\nif (b->flags & BIO_FLAGS_UPLINK)\\r\\nret = UP_ftell(b->ptr);\\r\\nelse\\r\\nret = ftell(fp);\\r\\nbreak;\\r\\ncase BIO_C_SET_FILE_PTR:\\r\\nfile_free(b);\\r\\nb->shutdown = (int)num & BIO_CLOSE;\\r\\nb->ptr = ptr;\\r\\nb->init = 1;\\r\\n# if BIO_FLAGS_UPLINK!=0\\r\\n# if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)\\r\\n# define _IOB_ENTRIES 20\\r\\n# endif\\r\\n# if defined(_IOB_ENTRIES)\\r\\nif ((size_t)ptr >= (size_t)stdin &&\\r\\n(size_t)ptr < (size_t)(stdin + _IOB_ENTRIES))\\r\\nBIO_clear_flags(b, BIO_FLAGS_UPLINK);\\r\\n# endif\\r\\n# endif\\r\\n# ifdef UP_fsetmod\\r\\nif (b->flags & BIO_FLAGS_UPLINK)\\r\\nUP_fsetmod(b->ptr, (char)((num & BIO_FP_TEXT) ? 't' : 'b'));\\r\\nelse\\r\\n# endif\\r\\n{\\r\\n# if defined(OPENSSL_SYS_WINDOWS)\\r\\nint fd = _fileno((FILE *)ptr);\\r\\nif (num & BIO_FP_TEXT)\\r\\n_setmode(fd, _O_TEXT);\\r\\nelse\\r\\n_setmode(fd, _O_BINARY);\\r\\n# elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)\\r\\nint fd = fileno((FILE *)ptr);\\r\\nif (num & BIO_FP_TEXT)\\r\\nsetmode(fd, O_TEXT);\\r\\nelse\\r\\nsetmode(fd, O_BINARY);\\r\\n# elif defined(OPENSSL_SYS_MSDOS)\\r\\nint fd = fileno((FILE *)ptr);\\r\\nif (num & BIO_FP_TEXT)\\r\\n_setmode(fd, _O_TEXT);\\r\\nelse {\\r\\nif (fd == STDIN_FILENO || fd == STDOUT_FILENO) {\\r\\nif (isatty(fd) <= 0)\\r\\n_setmode(fd, _O_BINARY);\\r\\n} else\\r\\n_setmode(fd, _O_BINARY);\\r\\n}\\r\\n# elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\\r\\nint fd = fileno((FILE *)ptr);\\r\\nif (num & BIO_FP_TEXT)\\r\\nsetmode(fd, O_TEXT);\\r\\nelse\\r\\nsetmode(fd, O_BINARY);\\r\\n# endif\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_SET_FILENAME:\\r\\nfile_free(b);\\r\\nb->shutdown = (int)num & BIO_CLOSE;\\r\\nif (num & BIO_FP_APPEND) {\\r\\nif (num & BIO_FP_READ)\\r\\nBUF_strlcpy(p, \"a+\", sizeof p);\\r\\nelse\\r\\nBUF_strlcpy(p, \"a\", sizeof p);\\r\\n} else if ((num & BIO_FP_READ) && (num & BIO_FP_WRITE))\\r\\nBUF_strlcpy(p, \"r+\", sizeof p);\\r\\nelse if (num & BIO_FP_WRITE)\\r\\nBUF_strlcpy(p, \"w\", sizeof p);\\r\\nelse if (num & BIO_FP_READ)\\r\\nBUF_strlcpy(p, \"r\", sizeof p);\\r\\nelse {\\r\\nBIOerr(BIO_F_FILE_CTRL, BIO_R_BAD_FOPEN_MODE);\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\n# if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)\\r\\nif (!(num & BIO_FP_TEXT))\\r\\nstrcat(p, \"b\");\\r\\nelse\\r\\nstrcat(p, \"t\");\\r\\n# endif\\r\\n# if defined(OPENSSL_SYS_NETWARE)\\r\\nif (!(num & BIO_FP_TEXT))\\r\\nstrcat(p, \"b\");\\r\\nelse\\r\\nstrcat(p, \"t\");\\r\\n# endif\\r\\nfp = fopen(ptr, p);\\r\\nif (fp == NULL) {\\r\\nSYSerr(SYS_F_FOPEN, get_last_sys_error());\\r\\nERR_add_error_data(5, \"fopen('\", ptr, \"','\", p, \"')\");\\r\\nBIOerr(BIO_F_FILE_CTRL, ERR_R_SYS_LIB);\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nb->ptr = fp;\\r\\nb->init = 1;\\r\\nBIO_clear_flags(b, BIO_FLAGS_UPLINK);\\r\\nbreak;\\r\\ncase BIO_C_GET_FILE_PTR:\\r\\nif (ptr != NULL) {\\r\\nfpp = (FILE **)ptr;\\r\\n*fpp = (FILE *)b->ptr;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = (long)b->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nb->shutdown = (int)num;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nif (b->flags & BIO_FLAGS_UPLINK)\\r\\nUP_fflush(b->ptr);\\r\\nelse\\r\\nfflush((FILE *)b->ptr);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\ncase BIO_CTRL_PENDING:\\r\\ncase BIO_CTRL_PUSH:\\r\\ncase BIO_CTRL_POP:\\r\\ndefault:\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int MS_CALLBACK file_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nint ret = 0;\\r\\nbuf[0] = '\\0';\\r\\nif (bp->flags & BIO_FLAGS_UPLINK) {\\r\\nif (!UP_fgets(buf, size, bp->ptr))\\r\\ngoto err;\\r\\n} else {\\r\\nif (!fgets(buf, size, (FILE *)bp->ptr))\\r\\ngoto err;\\r\\n}\\r\\nif (buf[0] != '\\0')\\r\\nret = strlen(buf);\\r\\nerr:\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int MS_CALLBACK file_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = file_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_wp_dgst_c", "target": 0, "func": "int WHIRLPOOL_Update(WHIRLPOOL_CTX *c, const void *_inp, size_t bytes)\\r\\n{\\r\\nsize_t chunk = ((size_t)1) << (sizeof(size_t) * 8 - 4);\\r\\nconst unsigned char *inp = _inp;\\r\\nwhile (bytes >= chunk) {\\r\\nWHIRLPOOL_BitUpdate(c, inp, chunk * 8);\\r\\nbytes -= chunk;\\r\\ninp += chunk;\\r\\n}\\r\\nif (bytes)\\r\\nWHIRLPOOL_BitUpdate(c, inp, bytes * 8);\\r\\nreturn (1);\\r\\n}\\r\\nvoid WHIRLPOOL_BitUpdate(WHIRLPOOL_CTX *c, const void *_inp, size_t bits)\\r\\n{\\r\\nsize_t n;\\r\\nunsigned int bitoff = c->bitoff,\\r\\nbitrem = bitoff % 8, inpgap = (8 - (unsigned int)bits % 8) & 7;\\r\\nconst unsigned char *inp = _inp;\\r\\nc->bitlen[0] += bits;\\r\\nif (c->bitlen[0] < bits) {\\r\\nn = 1;\\r\\ndo {\\r\\nc->bitlen[n]++;\\r\\n} while (c->bitlen[n] == 0\\r\\n&& ++n < (WHIRLPOOL_COUNTER / sizeof(size_t)));\\r\\n}\\r\\n#ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nreconsider:\\r\\nif (inpgap == 0 && bitrem == 0) {\\r\\nwhile (bits) {\\r\\nif (bitoff == 0 && (n = bits / WHIRLPOOL_BBLOCK)) {\\r\\nwhirlpool_block(c, inp, n);\\r\\ninp += n * WHIRLPOOL_BBLOCK / 8;\\r\\nbits %= WHIRLPOOL_BBLOCK;\\r\\n} else {\\r\\nunsigned int byteoff = bitoff / 8;\\r\\nbitrem = WHIRLPOOL_BBLOCK - bitoff;\\r\\nif (bits >= bitrem) {\\r\\nbits -= bitrem;\\r\\nbitrem /= 8;\\r\\nmemcpy(c->data + byteoff, inp, bitrem);\\r\\ninp += bitrem;\\r\\nwhirlpool_block(c, c->data, 1);\\r\\nbitoff = 0;\\r\\n} else {\\r\\nmemcpy(c->data + byteoff, inp, bits / 8);\\r\\nbitoff += (unsigned int)bits;\\r\\nbits = 0;\\r\\n}\\r\\nc->bitoff = bitoff;\\r\\n}\\r\\n}\\r\\n} else\\r\\n#endif\\r\\n{\\r\\nwhile (bits) {\\r\\nunsigned int byteoff = bitoff / 8;\\r\\nunsigned char b;\\r\\n#ifndef OPENSSL_SMALL_FOOTPRINT\\r\\nif (bitrem == inpgap) {\\r\\nc->data[byteoff++] |= inp[0] & (0xff >> inpgap);\\r\\ninpgap = 8 - inpgap;\\r\\nbitoff += inpgap;\\r\\nbitrem = 0;\\r\\nbits -= inpgap;\\r\\ninpgap = 0;\\r\\ninp++;\\r\\nif (bitoff == WHIRLPOOL_BBLOCK) {\\r\\nwhirlpool_block(c, c->data, 1);\\r\\nbitoff = 0;\\r\\n}\\r\\nc->bitoff = bitoff;\\r\\ngoto reconsider;\\r\\n} else\\r\\n#endif\\r\\nif (bits >= 8) {\\r\\nb = ((inp[0] << inpgap) | (inp[1] >> (8 - inpgap)));\\r\\nb &= 0xff;\\r\\nif (bitrem)\\r\\nc->data[byteoff++] |= b >> bitrem;\\r\\nelse\\r\\nc->data[byteoff++] = b;\\r\\nbitoff += 8;\\r\\nbits -= 8;\\r\\ninp++;\\r\\nif (bitoff >= WHIRLPOOL_BBLOCK) {\\r\\nwhirlpool_block(c, c->data, 1);\\r\\nbyteoff = 0;\\r\\nbitoff %= WHIRLPOOL_BBLOCK;\\r\\n}\\r\\nif (bitrem)\\r\\nc->data[byteoff] = b << (8 - bitrem);\\r\\n} else {\\r\\nb = (inp[0] << inpgap) & 0xff;\\r\\nif (bitrem)\\r\\nc->data[byteoff++] |= b >> bitrem;\\r\\nelse\\r\\nc->data[byteoff++] = b;\\r\\nbitoff += (unsigned int)bits;\\r\\nif (bitoff == WHIRLPOOL_BBLOCK) {\\r\\nwhirlpool_block(c, c->data, 1);\\r\\nbyteoff = 0;\\r\\nbitoff %= WHIRLPOOL_BBLOCK;\\r\\n}\\r\\nif (bitrem)\\r\\nc->data[byteoff] = b << (8 - bitrem);\\r\\nbits = 0;\\r\\n}\\r\\nc->bitoff = bitoff;\\r\\n}\\r\\n}\\r\\n}\\r\\nint WHIRLPOOL_Final(unsigned char *md, WHIRLPOOL_CTX *c)\\r\\n{\\r\\nunsigned int bitoff = c->bitoff, byteoff = bitoff / 8;\\r\\nsize_t i, j, v;\\r\\nunsigned char *p;\\r\\nbitoff %= 8;\\r\\nif (bitoff)\\r\\nc->data[byteoff] |= 0x80 >> bitoff;\\r\\nelse\\r\\nc->data[byteoff] = 0x80;\\r\\nbyteoff++;\\r\\nif (byteoff > (WHIRLPOOL_BBLOCK / 8 - WHIRLPOOL_COUNTER)) {\\r\\nif (byteoff < WHIRLPOOL_BBLOCK / 8)\\r\\nmemset(&c->data[byteoff], 0, WHIRLPOOL_BBLOCK / 8 - byteoff);\\r\\nwhirlpool_block(c, c->data, 1);\\r\\nbyteoff = 0;\\r\\n}\\r\\nif (byteoff < (WHIRLPOOL_BBLOCK / 8 - WHIRLPOOL_COUNTER))\\r\\nmemset(&c->data[byteoff], 0,\\r\\n(WHIRLPOOL_BBLOCK / 8 - WHIRLPOOL_COUNTER) - byteoff);\\r\\np = &c->data[WHIRLPOOL_BBLOCK / 8 - 1];\\r\\nfor (i = 0; i < WHIRLPOOL_COUNTER / sizeof(size_t); i++)\\r\\nfor (v = c->bitlen[i], j = 0; j < sizeof(size_t); j++, v >>= 8)\\r\\n*p-- = (unsigned char)(v & 0xff);\\r\\nwhirlpool_block(c, c->data, 1);\\r\\nif (md) {\\r\\nmemcpy(md, c->H.c, WHIRLPOOL_DIGEST_LENGTH);\\r\\nmemset(c, 0, sizeof(*c));\\r\\nreturn (1);\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nunsigned char *WHIRLPOOL(const void *inp, size_t bytes, unsigned char *md)\\r\\n{\\r\\nWHIRLPOOL_CTX ctx;\\r\\nstatic unsigned char m[WHIRLPOOL_DIGEST_LENGTH];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nWHIRLPOOL_Init(&ctx);\\r\\nWHIRLPOOL_Update(&ctx, inp, bytes);\\r\\nWHIRLPOOL_Final(md, &ctx);\\r\\nreturn (md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_ecb_c", "target": 0, "func": "const char *BF_options(void)\\r\\n{\\r\\n#ifdef BF_PTR\\r\\nreturn (\"blowfish(ptr)\");\\r\\n#elif defined(BF_PTR2)\\r\\nreturn (\"blowfish(ptr2)\");\\r\\n#else\\r\\nreturn (\"blowfish(idx)\");\\r\\n#endif\\r\\n}\\r\\nvoid BF_ecb_encrypt(const unsigned char *in, unsigned char *out,\\r\\nconst BF_KEY *key, int encrypt)\\r\\n{\\r\\nBF_LONG l, d[2];\\r\\nn2l(in, l);\\r\\nd[0] = l;\\r\\nn2l(in, l);\\r\\nd[1] = l;\\r\\nif (encrypt)\\r\\nBF_encrypt(d, key);\\r\\nelse\\r\\nBF_decrypt(d, key);\\r\\nl = d[0];\\r\\nl2n(l, out);\\r\\nl = d[1];\\r\\nl2n(l, out);\\r\\nl = d[0] = d[1] = 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_evp_cnf_c", "target": 0, "func": "static int alg_module_init(CONF_IMODULE *md, const CONF *cnf)\\r\\n{\\r\\nint i;\\r\\nconst char *oid_section;\\r\\nSTACK_OF(CONF_VALUE) *sktmp;\\r\\nCONF_VALUE *oval;\\r\\noid_section = CONF_imodule_get_value(md);\\r\\nif (!(sktmp = NCONF_get_section(cnf, oid_section))) {\\r\\nEVPerr(EVP_F_ALG_MODULE_INIT, EVP_R_ERROR_LOADING_SECTION);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(sktmp); i++) {\\r\\noval = sk_CONF_VALUE_value(sktmp, i);\\r\\nif (!strcmp(oval->name, \"fips_mode\")) {\\r\\nint m;\\r\\nif (!X509V3_get_value_bool(oval, &m)) {\\r\\nEVPerr(EVP_F_ALG_MODULE_INIT, EVP_R_INVALID_FIPS_MODE);\\r\\nreturn 0;\\r\\n}\\r\\nif (m > 0) {\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (!FIPS_mode() && !FIPS_mode_set(1)) {\\r\\nEVPerr(EVP_F_ALG_MODULE_INIT,\\r\\nEVP_R_ERROR_SETTING_FIPS_MODE);\\r\\nreturn 0;\\r\\n}\\r\\n#else\\r\\nEVPerr(EVP_F_ALG_MODULE_INIT, EVP_R_FIPS_MODE_NOT_SUPPORTED);\\r\\nreturn 0;\\r\\n#endif\\r\\n}\\r\\n} else {\\r\\nEVPerr(EVP_F_ALG_MODULE_INIT, EVP_R_UNKNOWN_OPTION);\\r\\nERR_add_error_data(4, \"name=\", oval->name,\\r\\n\", value=\", oval->value);\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nvoid EVP_add_alg_module(void)\\r\\n{\\r\\nCONF_module_add(\"alg_section\", alg_module_init, 0);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_seed_ofb_c", "target": 0, "func": "void SEED_ofb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const SEED_KEY_SCHEDULE *ks,\\r\\nunsigned char ivec[SEED_BLOCK_SIZE], int *num)\\r\\n{\\r\\nCRYPTO_ofb128_encrypt(in, out, len, ks, ivec, num,\\r\\n(block128_f) SEED_encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_conf_mod_c", "target": 0, "func": "int CONF_modules_load(const CONF *cnf, const char *appname,\\r\\nunsigned long flags)\\r\\n{\\r\\nSTACK_OF(CONF_VALUE) *values;\\r\\nCONF_VALUE *vl;\\r\\nchar *vsection = NULL;\\r\\nint ret, i;\\r\\nif (!cnf)\\r\\nreturn 1;\\r\\nif (appname)\\r\\nvsection = NCONF_get_string(cnf, NULL, appname);\\r\\nif (!appname || (!vsection && (flags & CONF_MFLAGS_DEFAULT_SECTION)))\\r\\nvsection = NCONF_get_string(cnf, NULL, \"openssl_conf\");\\r\\nif (!vsection) {\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nvalues = NCONF_get_section(cnf, vsection);\\r\\nif (!values)\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(values); i++) {\\r\\nvl = sk_CONF_VALUE_value(values, i);\\r\\nret = module_run(cnf, vl->name, vl->value, flags);\\r\\nif (ret <= 0)\\r\\nif (!(flags & CONF_MFLAGS_IGNORE_ERRORS))\\r\\nreturn ret;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint CONF_modules_load_file(const char *filename, const char *appname,\\r\\nunsigned long flags)\\r\\n{\\r\\nchar *file = NULL;\\r\\nCONF *conf = NULL;\\r\\nint ret = 0;\\r\\nconf = NCONF_new(NULL);\\r\\nif (!conf)\\r\\ngoto err;\\r\\nif (filename == NULL) {\\r\\nfile = CONF_get1_default_config_file();\\r\\nif (!file)\\r\\ngoto err;\\r\\n} else\\r\\nfile = (char *)filename;\\r\\nif (NCONF_load(conf, file, NULL) <= 0) {\\r\\nif ((flags & CONF_MFLAGS_IGNORE_MISSING_FILE) &&\\r\\n(ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE)) {\\r\\nERR_clear_error();\\r\\nret = 1;\\r\\n}\\r\\ngoto err;\\r\\n}\\r\\nret = CONF_modules_load(conf, appname, flags);\\r\\nerr:\\r\\nif (filename == NULL)\\r\\nOPENSSL_free(file);\\r\\nNCONF_free(conf);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int module_run(const CONF *cnf, char *name, char *value,\\r\\nunsigned long flags)\\r\\n{\\r\\nCONF_MODULE *md;\\r\\nint ret;\\r\\nmd = module_find(name);\\r\\nif (!md && !(flags & CONF_MFLAGS_NO_DSO))\\r\\nmd = module_load_dso(cnf, name, value, flags);\\r\\nif (!md) {\\r\\nif (!(flags & CONF_MFLAGS_SILENT)) {\\r\\nCONFerr(CONF_F_MODULE_RUN, CONF_R_UNKNOWN_MODULE_NAME);\\r\\nERR_add_error_data(2, \"module=\", name);\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nret = module_init(md, name, value, cnf);\\r\\nif (ret <= 0) {\\r\\nif (!(flags & CONF_MFLAGS_SILENT)) {\\r\\nchar rcode[DECIMAL_SIZE(ret) + 1];\\r\\nCONFerr(CONF_F_MODULE_RUN, CONF_R_MODULE_INITIALIZATION_ERROR);\\r\\nBIO_snprintf(rcode, sizeof rcode, \"%-8d\", ret);\\r\\nERR_add_error_data(6, \"module=\", name, \", value=\", value,\\r\\n\", retcode=\", rcode);\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic CONF_MODULE *module_load_dso(const CONF *cnf, char *name, char *value,\\r\\nunsigned long flags)\\r\\n{\\r\\nDSO *dso = NULL;\\r\\nconf_init_func *ifunc;\\r\\nconf_finish_func *ffunc;\\r\\nchar *path = NULL;\\r\\nint errcode = 0;\\r\\nCONF_MODULE *md;\\r\\npath = NCONF_get_string(cnf, value, \"path\");\\r\\nif (!path) {\\r\\nERR_clear_error();\\r\\npath = name;\\r\\n}\\r\\ndso = DSO_load(NULL, path, NULL, 0);\\r\\nif (!dso) {\\r\\nerrcode = CONF_R_ERROR_LOADING_DSO;\\r\\ngoto err;\\r\\n}\\r\\nifunc = (conf_init_func *)DSO_bind_func(dso, DSO_mod_init_name);\\r\\nif (!ifunc) {\\r\\nerrcode = CONF_R_MISSING_INIT_FUNCTION;\\r\\ngoto err;\\r\\n}\\r\\nffunc = (conf_finish_func *)DSO_bind_func(dso, DSO_mod_finish_name);\\r\\nmd = module_add(dso, name, ifunc, ffunc);\\r\\nif (!md)\\r\\ngoto err;\\r\\nreturn md;\\r\\nerr:\\r\\nif (dso)\\r\\nDSO_free(dso);\\r\\nCONFerr(CONF_F_MODULE_LOAD_DSO, errcode);\\r\\nERR_add_error_data(4, \"module=\", name, \", path=\", path);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic CONF_MODULE *module_add(DSO *dso, const char *name,\\r\\nconf_init_func *ifunc, conf_finish_func *ffunc)\\r\\n{\\r\\nCONF_MODULE *tmod = NULL;\\r\\nif (supported_modules == NULL)\\r\\nsupported_modules = sk_CONF_MODULE_new_null();\\r\\nif (supported_modules == NULL)\\r\\nreturn NULL;\\r\\ntmod = OPENSSL_malloc(sizeof(CONF_MODULE));\\r\\nif (tmod == NULL)\\r\\nreturn NULL;\\r\\ntmod->dso = dso;\\r\\ntmod->name = BUF_strdup(name);\\r\\ntmod->init = ifunc;\\r\\ntmod->finish = ffunc;\\r\\ntmod->links = 0;\\r\\nif (!sk_CONF_MODULE_push(supported_modules, tmod)) {\\r\\nOPENSSL_free(tmod);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn tmod;\\r\\n}\\r\\nstatic CONF_MODULE *module_find(char *name)\\r\\n{\\r\\nCONF_MODULE *tmod;\\r\\nint i, nchar;\\r\\nchar *p;\\r\\np = strrchr(name, '.');\\r\\nif (p)\\r\\nnchar = p - name;\\r\\nelse\\r\\nnchar = strlen(name);\\r\\nfor (i = 0; i < sk_CONF_MODULE_num(supported_modules); i++) {\\r\\ntmod = sk_CONF_MODULE_value(supported_modules, i);\\r\\nif (!strncmp(tmod->name, name, nchar))\\r\\nreturn tmod;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int module_init(CONF_MODULE *pmod, char *name, char *value,\\r\\nconst CONF *cnf)\\r\\n{\\r\\nint ret = 1;\\r\\nint init_called = 0;\\r\\nCONF_IMODULE *imod = NULL;\\r\\nimod = OPENSSL_malloc(sizeof(CONF_IMODULE));\\r\\nif (!imod)\\r\\ngoto err;\\r\\nimod->pmod = pmod;\\r\\nimod->name = BUF_strdup(name);\\r\\nimod->value = BUF_strdup(value);\\r\\nimod->usr_data = NULL;\\r\\nif (!imod->name || !imod->value)\\r\\ngoto memerr;\\r\\nif (pmod->init) {\\r\\nret = pmod->init(imod, cnf);\\r\\ninit_called = 1;\\r\\nif (ret <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (initialized_modules == NULL) {\\r\\ninitialized_modules = sk_CONF_IMODULE_new_null();\\r\\nif (!initialized_modules) {\\r\\nCONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (!sk_CONF_IMODULE_push(initialized_modules, imod)) {\\r\\nCONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npmod->links++;\\r\\nreturn ret;\\r\\nerr:\\r\\nif (pmod->finish && init_called)\\r\\npmod->finish(imod);\\r\\nmemerr:\\r\\nif (imod) {\\r\\nif (imod->name)\\r\\nOPENSSL_free(imod->name);\\r\\nif (imod->value)\\r\\nOPENSSL_free(imod->value);\\r\\nOPENSSL_free(imod);\\r\\n}\\r\\nreturn -1;\\r\\n}\\r\\nvoid CONF_modules_unload(int all)\\r\\n{\\r\\nint i;\\r\\nCONF_MODULE *md;\\r\\nCONF_modules_finish();\\r\\nfor (i = sk_CONF_MODULE_num(supported_modules) - 1; i >= 0; i--) {\\r\\nmd = sk_CONF_MODULE_value(supported_modules, i);\\r\\nif (((md->links > 0) || !md->dso) && !all)\\r\\ncontinue;\\r\\n(void)sk_CONF_MODULE_delete(supported_modules, i);\\r\\nmodule_free(md);\\r\\n}\\r\\nif (sk_CONF_MODULE_num(supported_modules) == 0) {\\r\\nsk_CONF_MODULE_free(supported_modules);\\r\\nsupported_modules = NULL;\\r\\n}\\r\\n}\\r\\nstatic void module_free(CONF_MODULE *md)\\r\\n{\\r\\nif (md->dso)\\r\\nDSO_free(md->dso);\\r\\nOPENSSL_free(md->name);\\r\\nOPENSSL_free(md);\\r\\n}\\r\\nvoid CONF_modules_finish(void)\\r\\n{\\r\\nCONF_IMODULE *imod;\\r\\nwhile (sk_CONF_IMODULE_num(initialized_modules) > 0) {\\r\\nimod = sk_CONF_IMODULE_pop(initialized_modules);\\r\\nmodule_finish(imod);\\r\\n}\\r\\nsk_CONF_IMODULE_free(initialized_modules);\\r\\ninitialized_modules = NULL;\\r\\n}\\r\\nstatic void module_finish(CONF_IMODULE *imod)\\r\\n{\\r\\nif (imod->pmod->finish)\\r\\nimod->pmod->finish(imod);\\r\\nimod->pmod->links--;\\r\\nOPENSSL_free(imod->name);\\r\\nOPENSSL_free(imod->value);\\r\\nOPENSSL_free(imod);\\r\\n}\\r\\nint CONF_module_add(const char *name, conf_init_func *ifunc,\\r\\nconf_finish_func *ffunc)\\r\\n{\\r\\nif (module_add(NULL, name, ifunc, ffunc))\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nvoid CONF_modules_free(void)\\r\\n{\\r\\nCONF_modules_finish();\\r\\nCONF_modules_unload(1);\\r\\n}\\r\\nconst char *CONF_imodule_get_name(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->name;\\r\\n}\\r\\nconst char *CONF_imodule_get_value(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->value;\\r\\n}\\r\\nvoid *CONF_imodule_get_usr_data(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->usr_data;\\r\\n}\\r\\nvoid CONF_imodule_set_usr_data(CONF_IMODULE *md, void *usr_data)\\r\\n{\\r\\nmd->usr_data = usr_data;\\r\\n}\\r\\nCONF_MODULE *CONF_imodule_get_module(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->pmod;\\r\\n}\\r\\nunsigned long CONF_imodule_get_flags(const CONF_IMODULE *md)\\r\\n{\\r\\nreturn md->flags;\\r\\n}\\r\\nvoid CONF_imodule_set_flags(CONF_IMODULE *md, unsigned long flags)\\r\\n{\\r\\nmd->flags = flags;\\r\\n}\\r\\nvoid *CONF_module_get_usr_data(CONF_MODULE *pmod)\\r\\n{\\r\\nreturn pmod->usr_data;\\r\\n}\\r\\nvoid CONF_module_set_usr_data(CONF_MODULE *pmod, void *usr_data)\\r\\n{\\r\\npmod->usr_data = usr_data;\\r\\n}\\r\\nchar *CONF_get1_default_config_file(void)\\r\\n{\\r\\nchar *file;\\r\\nint len;\\r\\nfile = getenv(\"OPENSSL_CONF\");\\r\\nif (file)\\r\\nreturn BUF_strdup(file);\\r\\nlen = strlen(X509_get_default_cert_area());\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nlen++;\\r\\n#endif\\r\\nlen += strlen(OPENSSL_CONF);\\r\\nfile = OPENSSL_malloc(len + 1);\\r\\nif (!file)\\r\\nreturn NULL;\\r\\nBUF_strlcpy(file, X509_get_default_cert_area(), len + 1);\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBUF_strlcat(file, \"/\", len + 1);\\r\\n#endif\\r\\nBUF_strlcat(file, OPENSSL_CONF, len + 1);\\r\\nreturn file;\\r\\n}\\r\\nint CONF_parse_list(const char *list_, int sep, int nospc,\\r\\nint (*list_cb) (const char *elem, int len, void *usr),\\r\\nvoid *arg)\\r\\n{\\r\\nint ret;\\r\\nconst char *lstart, *tmpend, *p;\\r\\nif (list_ == NULL) {\\r\\nCONFerr(CONF_F_CONF_PARSE_LIST, CONF_R_LIST_CANNOT_BE_NULL);\\r\\nreturn 0;\\r\\n}\\r\\nlstart = list_;\\r\\nfor (;;) {\\r\\nif (nospc) {\\r\\nwhile (*lstart && isspace((unsigned char)*lstart))\\r\\nlstart++;\\r\\n}\\r\\np = strchr(lstart, sep);\\r\\nif (p == lstart || !*lstart)\\r\\nret = list_cb(NULL, 0, arg);\\r\\nelse {\\r\\nif (p)\\r\\ntmpend = p - 1;\\r\\nelse\\r\\ntmpend = lstart + strlen(lstart) - 1;\\r\\nif (nospc) {\\r\\nwhile (isspace((unsigned char)*tmpend))\\r\\ntmpend--;\\r\\n}\\r\\nret = list_cb(lstart, tmpend - lstart + 1, arg);\\r\\n}\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\nif (p == NULL)\\r\\nreturn 1;\\r\\nlstart = p + 1;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_sign_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL;\\r\\nX509 *scert = NULL;\\r\\nEVP_PKEY *skey = NULL;\\r\\nCMS_ContentInfo *cms = NULL;\\r\\nint ret = 1;\\r\\nint flags = CMS_DETACHED | CMS_STREAM;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\ntbio = BIO_new_file(\"signer.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nscert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nBIO_reset(tbio);\\r\\nskey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);\\r\\nif (!scert || !skey)\\r\\ngoto err;\\r\\nin = BIO_new_file(\"sign.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\ncms = CMS_sign(scert, skey, NULL, in, flags);\\r\\nif (!cms)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smout.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!(flags & CMS_STREAM))\\r\\nBIO_reset(in);\\r\\nif (!SMIME_write_CMS(out, cms, in, flags))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Signing Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nif (scert)\\r\\nX509_free(scert);\\r\\nif (skey)\\r\\nEVP_PKEY_free(skey);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_evp_key_c", "target": 0, "func": "void EVP_set_pw_prompt(const char *prompt)\\r\\n{\\r\\nif (prompt == NULL)\\r\\nprompt_string[0] = '\\0';\\r\\nelse {\\r\\nstrncpy(prompt_string, prompt, 79);\\r\\nprompt_string[79] = '\\0';\\r\\n}\\r\\n}\\r\\nchar *EVP_get_pw_prompt(void)\\r\\n{\\r\\nif (prompt_string[0] == '\\0')\\r\\nreturn (NULL);\\r\\nelse\\r\\nreturn (prompt_string);\\r\\n}\\r\\nint EVP_read_pw_string(char *buf, int len, const char *prompt, int verify)\\r\\n{\\r\\nreturn EVP_read_pw_string_min(buf, 0, len, prompt, verify);\\r\\n}\\r\\nint EVP_read_pw_string_min(char *buf, int min, int len, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\nint ret;\\r\\nchar buff[BUFSIZ];\\r\\nUI *ui;\\r\\nif ((prompt == NULL) && (prompt_string[0] != '\\0'))\\r\\nprompt = prompt_string;\\r\\nui = UI_new();\\r\\nUI_add_input_string(ui, prompt, 0, buf, min,\\r\\n(len >= BUFSIZ) ? BUFSIZ - 1 : len);\\r\\nif (verify)\\r\\nUI_add_verify_string(ui, prompt, 0,\\r\\nbuff, min, (len >= BUFSIZ) ? BUFSIZ - 1 : len,\\r\\nbuf);\\r\\nret = UI_process(ui);\\r\\nUI_free(ui);\\r\\nOPENSSL_cleanse(buff, BUFSIZ);\\r\\nreturn ret;\\r\\n}\\r\\nint EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,\\r\\nconst unsigned char *salt, const unsigned char *data,\\r\\nint datal, int count, unsigned char *key,\\r\\nunsigned char *iv)\\r\\n{\\r\\nEVP_MD_CTX c;\\r\\nunsigned char md_buf[EVP_MAX_MD_SIZE];\\r\\nint niv, nkey, addmd = 0;\\r\\nunsigned int mds = 0, i;\\r\\nint rv = 0;\\r\\nnkey = type->key_len;\\r\\nniv = type->iv_len;\\r\\nOPENSSL_assert(nkey <= EVP_MAX_KEY_LENGTH);\\r\\nOPENSSL_assert(niv <= EVP_MAX_IV_LENGTH);\\r\\nif (data == NULL)\\r\\nreturn (nkey);\\r\\nEVP_MD_CTX_init(&c);\\r\\nfor (;;) {\\r\\nif (!EVP_DigestInit_ex(&c, md, NULL))\\r\\nreturn 0;\\r\\nif (addmd++)\\r\\nif (!EVP_DigestUpdate(&c, &(md_buf[0]), mds))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&c, data, datal))\\r\\ngoto err;\\r\\nif (salt != NULL)\\r\\nif (!EVP_DigestUpdate(&c, salt, PKCS5_SALT_LEN))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&c, &(md_buf[0]), &mds))\\r\\ngoto err;\\r\\nfor (i = 1; i < (unsigned int)count; i++) {\\r\\nif (!EVP_DigestInit_ex(&c, md, NULL))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&c, &(md_buf[0]), mds))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&c, &(md_buf[0]), &mds))\\r\\ngoto err;\\r\\n}\\r\\ni = 0;\\r\\nif (nkey) {\\r\\nfor (;;) {\\r\\nif (nkey == 0)\\r\\nbreak;\\r\\nif (i == mds)\\r\\nbreak;\\r\\nif (key != NULL)\\r\\n*(key++) = md_buf[i];\\r\\nnkey--;\\r\\ni++;\\r\\n}\\r\\n}\\r\\nif (niv && (i != mds)) {\\r\\nfor (;;) {\\r\\nif (niv == 0)\\r\\nbreak;\\r\\nif (i == mds)\\r\\nbreak;\\r\\nif (iv != NULL)\\r\\n*(iv++) = md_buf[i];\\r\\nniv--;\\r\\ni++;\\r\\n}\\r\\n}\\r\\nif ((nkey == 0) && (niv == 0))\\r\\nbreak;\\r\\n}\\r\\nrv = type->key_len;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&c);\\r\\nOPENSSL_cleanse(&(md_buf[0]), EVP_MAX_MD_SIZE);\\r\\nreturn rv;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ofb128_c", "target": 0, "func": "void CRYPTO_ofb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t len, const void *key,\\r\\nunsigned char ivec[16], int *num, block128_f block)\\r\\n{\\r\\nunsigned int n;\\r\\nsize_t l = 0;\\r\\nassert(in && out && key && ivec && num);\\r\\nn = *num;\\r\\n#if !defined(OPENSSL_SMALL_FOOTPRINT)\\r\\nif (16 % sizeof(size_t) == 0) {\\r\\ndo {\\r\\nwhile (n && len) {\\r\\n*(out++) = *(in++) ^ ivec[n];\\r\\n--len;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\n# if defined(STRICT_ALIGNMENT)\\r\\nif (((size_t)in | (size_t)out | (size_t)ivec) % sizeof(size_t) !=\\r\\n0)\\r\\nbreak;\\r\\n# endif\\r\\nwhile (len >= 16) {\\r\\n(*block) (ivec, ivec, key);\\r\\nfor (; n < 16; n += sizeof(size_t))\\r\\n*(size_t *)(out + n) =\\r\\n*(size_t *)(in + n) ^ *(size_t *)(ivec + n);\\r\\nlen -= 16;\\r\\nout += 16;\\r\\nin += 16;\\r\\nn = 0;\\r\\n}\\r\\nif (len) {\\r\\n(*block) (ivec, ivec, key);\\r\\nwhile (len--) {\\r\\nout[n] = in[n] ^ ivec[n];\\r\\n++n;\\r\\n}\\r\\n}\\r\\n*num = n;\\r\\nreturn;\\r\\n} while (0);\\r\\n}\\r\\n#endif\\r\\nwhile (l < len) {\\r\\nif (n == 0) {\\r\\n(*block) (ivec, ivec, key);\\r\\n}\\r\\nout[l] = in[l] ^ ivec[n];\\r\\n++l;\\r\\nn = (n + 1) % 16;\\r\\n}\\r\\n*num = n;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_conf_def_c", "target": 0, "func": "CONF_METHOD *NCONF_default()\\r\\n{\\r\\nreturn &default_method;\\r\\n}\\r\\nCONF_METHOD *NCONF_WIN32()\\r\\n{\\r\\nreturn &WIN32_method;\\r\\n}\\r\\nstatic CONF *def_create(CONF_METHOD *meth)\\r\\n{\\r\\nCONF *ret;\\r\\nret = OPENSSL_malloc(sizeof(CONF) + sizeof(unsigned short *));\\r\\nif (ret)\\r\\nif (meth->init(ret) == 0) {\\r\\nOPENSSL_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int def_init_default(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn 0;\\r\\nconf->meth = &default_method;\\r\\nconf->meth_data = CONF_type_default;\\r\\nconf->data = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int def_init_WIN32(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn 0;\\r\\nconf->meth = &WIN32_method;\\r\\nconf->meth_data = (void *)CONF_type_win32;\\r\\nconf->data = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int def_destroy(CONF *conf)\\r\\n{\\r\\nif (def_destroy_data(conf)) {\\r\\nOPENSSL_free(conf);\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int def_destroy_data(CONF *conf)\\r\\n{\\r\\nif (conf == NULL)\\r\\nreturn 0;\\r\\n_CONF_free_data(conf);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int def_load(CONF *conf, const char *name, long *line)\\r\\n{\\r\\nint ret;\\r\\nBIO *in = NULL;\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nin = BIO_new_file(name, \"r\");\\r\\n#else\\r\\nin = BIO_new_file(name, \"rb\");\\r\\n#endif\\r\\nif (in == NULL) {\\r\\nif (ERR_GET_REASON(ERR_peek_last_error()) == BIO_R_NO_SUCH_FILE)\\r\\nCONFerr(CONF_F_DEF_LOAD, CONF_R_NO_SUCH_FILE);\\r\\nelse\\r\\nCONFerr(CONF_F_DEF_LOAD, ERR_R_SYS_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret = def_load_bio(conf, in, line);\\r\\nBIO_free(in);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int def_load_bio(CONF *conf, BIO *in, long *line)\\r\\n{\\r\\n#define CONFBUFSIZE 512\\r\\nint bufnum = 0, i, ii;\\r\\nBUF_MEM *buff = NULL;\\r\\nchar *s, *p, *end;\\r\\nint again;\\r\\nlong eline = 0;\\r\\nchar btmp[DECIMAL_SIZE(eline) + 1];\\r\\nCONF_VALUE *v = NULL, *tv;\\r\\nCONF_VALUE *sv = NULL;\\r\\nchar *section = NULL, *buf;\\r\\nchar *start, *psection, *pname;\\r\\nvoid *h = (void *)(conf->data);\\r\\nif ((buff = BUF_MEM_new()) == NULL) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\nsection = (char *)OPENSSL_malloc(10);\\r\\nif (section == NULL) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nBUF_strlcpy(section, \"default\", 10);\\r\\nif (_CONF_new_data(conf) == 0) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nsv = _CONF_new_section(conf, section);\\r\\nif (sv == NULL) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION);\\r\\ngoto err;\\r\\n}\\r\\nbufnum = 0;\\r\\nagain = 0;\\r\\nfor (;;) {\\r\\nif (!BUF_MEM_grow(buff, bufnum + CONFBUFSIZE)) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB);\\r\\ngoto err;\\r\\n}\\r\\np = &(buff->data[bufnum]);\\r\\n*p = '\\0';\\r\\nBIO_gets(in, p, CONFBUFSIZE - 1);\\r\\np[CONFBUFSIZE - 1] = '\\0';\\r\\nii = i = strlen(p);\\r\\nif (i == 0 && !again)\\r\\nbreak;\\r\\nagain = 0;\\r\\nwhile (i > 0) {\\r\\nif ((p[i - 1] != '\\r') && (p[i - 1] != '\\n'))\\r\\nbreak;\\r\\nelse\\r\\ni--;\\r\\n}\\r\\nif (ii && i == ii)\\r\\nagain = 1;\\r\\nelse {\\r\\np[i] = '\\0';\\r\\neline++;\\r\\n}\\r\\nbufnum += i;\\r\\nv = NULL;\\r\\nif (bufnum >= 1) {\\r\\np = &(buff->data[bufnum - 1]);\\r\\nif (IS_ESC(conf, p[0]) && ((bufnum <= 1) || !IS_ESC(conf, p[-1]))) {\\r\\nbufnum--;\\r\\nagain = 1;\\r\\n}\\r\\n}\\r\\nif (again)\\r\\ncontinue;\\r\\nbufnum = 0;\\r\\nbuf = buff->data;\\r\\nclear_comments(conf, buf);\\r\\ns = eat_ws(conf, buf);\\r\\nif (IS_EOF(conf, *s))\\r\\ncontinue;\\r\\nif (*s == '[') {\\r\\nchar *ss;\\r\\ns++;\\r\\nstart = eat_ws(conf, s);\\r\\nss = start;\\r\\nagain:\\r\\nend = eat_alpha_numeric(conf, ss);\\r\\np = eat_ws(conf, end);\\r\\nif (*p != ']') {\\r\\nif (*p != '\\0' && ss != p) {\\r\\nss = p;\\r\\ngoto again;\\r\\n}\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nCONF_R_MISSING_CLOSE_SQUARE_BRACKET);\\r\\ngoto err;\\r\\n}\\r\\n*end = '\\0';\\r\\nif (!str_copy(conf, NULL, &section, start))\\r\\ngoto err;\\r\\nif ((sv = _CONF_get_section(conf, section)) == NULL)\\r\\nsv = _CONF_new_section(conf, section);\\r\\nif (sv == NULL) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\\r\\ngoto err;\\r\\n}\\r\\ncontinue;\\r\\n} else {\\r\\npname = s;\\r\\npsection = NULL;\\r\\nend = eat_alpha_numeric(conf, s);\\r\\nif ((end[0] == ':') && (end[1] == ':')) {\\r\\n*end = '\\0';\\r\\nend += 2;\\r\\npsection = pname;\\r\\npname = end;\\r\\nend = eat_alpha_numeric(conf, end);\\r\\n}\\r\\np = eat_ws(conf, end);\\r\\nif (*p != '=') {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_MISSING_EQUAL_SIGN);\\r\\ngoto err;\\r\\n}\\r\\n*end = '\\0';\\r\\np++;\\r\\nstart = eat_ws(conf, p);\\r\\nwhile (!IS_EOF(conf, *p))\\r\\np++;\\r\\np--;\\r\\nwhile ((p != start) && (IS_WS(conf, *p)))\\r\\np--;\\r\\np++;\\r\\n*p = '\\0';\\r\\nif (!(v = (CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE)))) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (psection == NULL)\\r\\npsection = section;\\r\\nv->name = (char *)OPENSSL_malloc(strlen(pname) + 1);\\r\\nv->value = NULL;\\r\\nif (v->name == NULL) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nBUF_strlcpy(v->name, pname, strlen(pname) + 1);\\r\\nif (!str_copy(conf, psection, &(v->value), start))\\r\\ngoto err;\\r\\nif (strcmp(psection, section) != 0) {\\r\\nif ((tv = _CONF_get_section(conf, psection))\\r\\n== NULL)\\r\\ntv = _CONF_new_section(conf, psection);\\r\\nif (tv == NULL) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO,\\r\\nCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\\r\\ngoto err;\\r\\n}\\r\\n} else\\r\\ntv = sv;\\r\\n#if 1\\r\\nif (_CONF_add_string(conf, tv, v) == 0) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\n#else\\r\\nv->section = tv->section;\\r\\nif (!sk_CONF_VALUE_push(ts, v)) {\\r\\nCONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nvv = (CONF_VALUE *)lh_insert(conf->data, v);\\r\\nif (vv != NULL) {\\r\\nsk_CONF_VALUE_delete_ptr(ts, vv);\\r\\nOPENSSL_free(vv->name);\\r\\nOPENSSL_free(vv->value);\\r\\nOPENSSL_free(vv);\\r\\n}\\r\\n#endif\\r\\nv = NULL;\\r\\n}\\r\\n}\\r\\nif (buff != NULL)\\r\\nBUF_MEM_free(buff);\\r\\nif (section != NULL)\\r\\nOPENSSL_free(section);\\r\\nreturn (1);\\r\\nerr:\\r\\nif (buff != NULL)\\r\\nBUF_MEM_free(buff);\\r\\nif (section != NULL)\\r\\nOPENSSL_free(section);\\r\\nif (line != NULL)\\r\\n*line = eline;\\r\\nBIO_snprintf(btmp, sizeof btmp, \"%ld\", eline);\\r\\nERR_add_error_data(2, \"line \", btmp);\\r\\nif ((h != conf->data) && (conf->data != NULL)) {\\r\\nCONF_free(conf->data);\\r\\nconf->data = NULL;\\r\\n}\\r\\nif (v != NULL) {\\r\\nif (v->name != NULL)\\r\\nOPENSSL_free(v->name);\\r\\nif (v->value != NULL)\\r\\nOPENSSL_free(v->value);\\r\\nif (v != NULL)\\r\\nOPENSSL_free(v);\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nstatic void clear_comments(CONF *conf, char *p)\\r\\n{\\r\\nfor (;;) {\\r\\nif (IS_FCOMMENT(conf, *p)) {\\r\\n*p = '\\0';\\r\\nreturn;\\r\\n}\\r\\nif (!IS_WS(conf, *p)) {\\r\\nbreak;\\r\\n}\\r\\np++;\\r\\n}\\r\\nfor (;;) {\\r\\nif (IS_COMMENT(conf, *p)) {\\r\\n*p = '\\0';\\r\\nreturn;\\r\\n}\\r\\nif (IS_DQUOTE(conf, *p)) {\\r\\np = scan_dquote(conf, p);\\r\\ncontinue;\\r\\n}\\r\\nif (IS_QUOTE(conf, *p)) {\\r\\np = scan_quote(conf, p);\\r\\ncontinue;\\r\\n}\\r\\nif (IS_ESC(conf, *p)) {\\r\\np = scan_esc(conf, p);\\r\\ncontinue;\\r\\n}\\r\\nif (IS_EOF(conf, *p))\\r\\nreturn;\\r\\nelse\\r\\np++;\\r\\n}\\r\\n}\\r\\nstatic int str_copy(CONF *conf, char *section, char **pto, char *from)\\r\\n{\\r\\nint q, r, rr = 0, to = 0, len = 0;\\r\\nchar *s, *e, *rp, *p, *rrp, *np, *cp, v;\\r\\nBUF_MEM *buf;\\r\\nif ((buf = BUF_MEM_new()) == NULL)\\r\\nreturn (0);\\r\\nlen = strlen(from) + 1;\\r\\nif (!BUF_MEM_grow(buf, len))\\r\\ngoto err;\\r\\nfor (;;) {\\r\\nif (IS_QUOTE(conf, *from)) {\\r\\nq = *from;\\r\\nfrom++;\\r\\nwhile (!IS_EOF(conf, *from) && (*from != q)) {\\r\\nif (IS_ESC(conf, *from)) {\\r\\nfrom++;\\r\\nif (IS_EOF(conf, *from))\\r\\nbreak;\\r\\n}\\r\\nbuf->data[to++] = *(from++);\\r\\n}\\r\\nif (*from == q)\\r\\nfrom++;\\r\\n} else if (IS_DQUOTE(conf, *from)) {\\r\\nq = *from;\\r\\nfrom++;\\r\\nwhile (!IS_EOF(conf, *from)) {\\r\\nif (*from == q) {\\r\\nif (*(from + 1) == q) {\\r\\nfrom++;\\r\\n} else {\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nbuf->data[to++] = *(from++);\\r\\n}\\r\\nif (*from == q)\\r\\nfrom++;\\r\\n} else if (IS_ESC(conf, *from)) {\\r\\nfrom++;\\r\\nv = *(from++);\\r\\nif (IS_EOF(conf, v))\\r\\nbreak;\\r\\nelse if (v == 'r')\\r\\nv = '\\r';\\r\\nelse if (v == 'n')\\r\\nv = '\\n';\\r\\nelse if (v == 'b')\\r\\nv = '\\b';\\r\\nelse if (v == 't')\\r\\nv = '\\t';\\r\\nbuf->data[to++] = v;\\r\\n} else if (IS_EOF(conf, *from))\\r\\nbreak;\\r\\nelse if (*from == '$') {\\r\\nrrp = NULL;\\r\\ns = &(from[1]);\\r\\nif (*s == '{')\\r\\nq = '}';\\r\\nelse if (*s == '(')\\r\\nq = ')';\\r\\nelse\\r\\nq = 0;\\r\\nif (q)\\r\\ns++;\\r\\ncp = section;\\r\\ne = np = s;\\r\\nwhile (IS_ALPHA_NUMERIC(conf, *e))\\r\\ne++;\\r\\nif ((e[0] == ':') && (e[1] == ':')) {\\r\\ncp = np;\\r\\nrrp = e;\\r\\nrr = *e;\\r\\n*rrp = '\\0';\\r\\ne += 2;\\r\\nnp = e;\\r\\nwhile (IS_ALPHA_NUMERIC(conf, *e))\\r\\ne++;\\r\\n}\\r\\nr = *e;\\r\\n*e = '\\0';\\r\\nrp = e;\\r\\nif (q) {\\r\\nif (r != q) {\\r\\nCONFerr(CONF_F_STR_COPY, CONF_R_NO_CLOSE_BRACE);\\r\\ngoto err;\\r\\n}\\r\\ne++;\\r\\n}\\r\\np = _CONF_get_string(conf, cp, np);\\r\\nif (rrp != NULL)\\r\\n*rrp = rr;\\r\\n*rp = r;\\r\\nif (p == NULL) {\\r\\nCONFerr(CONF_F_STR_COPY, CONF_R_VARIABLE_HAS_NO_VALUE);\\r\\ngoto err;\\r\\n}\\r\\nBUF_MEM_grow_clean(buf, (strlen(p) + buf->length - (e - from)));\\r\\nwhile (*p)\\r\\nbuf->data[to++] = *(p++);\\r\\nlen -= e - from;\\r\\nfrom = e;\\r\\n*rp = r;\\r\\n} else\\r\\nbuf->data[to++] = *(from++);\\r\\n}\\r\\nbuf->data[to] = '\\0';\\r\\nif (*pto != NULL)\\r\\nOPENSSL_free(*pto);\\r\\n*pto = buf->data;\\r\\nOPENSSL_free(buf);\\r\\nreturn (1);\\r\\nerr:\\r\\nif (buf != NULL)\\r\\nBUF_MEM_free(buf);\\r\\nreturn (0);\\r\\n}\\r\\nstatic char *eat_ws(CONF *conf, char *p)\\r\\n{\\r\\nwhile (IS_WS(conf, *p) && (!IS_EOF(conf, *p)))\\r\\np++;\\r\\nreturn (p);\\r\\n}\\r\\nstatic char *eat_alpha_numeric(CONF *conf, char *p)\\r\\n{\\r\\nfor (;;) {\\r\\nif (IS_ESC(conf, *p)) {\\r\\np = scan_esc(conf, p);\\r\\ncontinue;\\r\\n}\\r\\nif (!IS_ALPHA_NUMERIC_PUNCT(conf, *p))\\r\\nreturn (p);\\r\\np++;\\r\\n}\\r\\n}\\r\\nstatic char *scan_quote(CONF *conf, char *p)\\r\\n{\\r\\nint q = *p;\\r\\np++;\\r\\nwhile (!(IS_EOF(conf, *p)) && (*p != q)) {\\r\\nif (IS_ESC(conf, *p)) {\\r\\np++;\\r\\nif (IS_EOF(conf, *p))\\r\\nreturn (p);\\r\\n}\\r\\np++;\\r\\n}\\r\\nif (*p == q)\\r\\np++;\\r\\nreturn (p);\\r\\n}\\r\\nstatic char *scan_dquote(CONF *conf, char *p)\\r\\n{\\r\\nint q = *p;\\r\\np++;\\r\\nwhile (!(IS_EOF(conf, *p))) {\\r\\nif (*p == q) {\\r\\nif (*(p + 1) == q) {\\r\\np++;\\r\\n} else {\\r\\nbreak;\\r\\n}\\r\\n}\\r\\np++;\\r\\n}\\r\\nif (*p == q)\\r\\np++;\\r\\nreturn (p);\\r\\n}\\r\\nstatic void dump_value_doall_arg(CONF_VALUE *a, BIO *out)\\r\\n{\\r\\nif (a->name)\\r\\nBIO_printf(out, \"[%s] %s=%s\\n\", a->section, a->name, a->value);\\r\\nelse\\r\\nBIO_printf(out, \"[[%s]]\\n\", a->section);\\r\\n}\\r\\nstatic int def_is_number(const CONF *conf, char c)\\r\\n{\\r\\nreturn IS_NUMBER(conf, c);\\r\\n}\\r\\nstatic int def_to_int(const CONF *conf, char c)\\r\\n{\\r\\nreturn c - '0';\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pcy_node_c", "target": 0, "func": "static int node_cmp(const X509_POLICY_NODE *const *a,\\r\\nconst X509_POLICY_NODE *const *b)\\r\\n{\\r\\nreturn OBJ_cmp((*a)->data->valid_policy, (*b)->data->valid_policy);\\r\\n}\\r\\nX509_POLICY_NODE *level_find_node(const X509_POLICY_LEVEL *level,\\r\\nconst X509_POLICY_NODE *parent,\\r\\nconst ASN1_OBJECT *id)\\r\\n{\\r\\nX509_POLICY_NODE *node;\\r\\nint i;\\r\\nfor (i = 0; i < sk_X509_POLICY_NODE_num(level->nodes); i++) {\\r\\nnode = sk_X509_POLICY_NODE_value(level->nodes, i);\\r\\nif (node->parent == parent) {\\r\\nif (!OBJ_cmp(node->data->valid_policy, id))\\r\\nreturn node;\\r\\n}\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nX509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,\\r\\nconst X509_POLICY_DATA *data,\\r\\nX509_POLICY_NODE *parent,\\r\\nX509_POLICY_TREE *tree)\\r\\n{\\r\\nX509_POLICY_NODE *node;\\r\\nnode = OPENSSL_malloc(sizeof(X509_POLICY_NODE));\\r\\nif (!node)\\r\\nreturn NULL;\\r\\nnode->data = data;\\r\\nnode->parent = parent;\\r\\nnode->nchild = 0;\\r\\nif (level) {\\r\\nif (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\\r\\nif (level->anyPolicy)\\r\\ngoto node_error;\\r\\nlevel->anyPolicy = node;\\r\\n} else {\\r\\nif (!level->nodes)\\r\\nlevel->nodes = policy_node_cmp_new();\\r\\nif (!level->nodes)\\r\\ngoto node_error;\\r\\nif (!sk_X509_POLICY_NODE_push(level->nodes, node))\\r\\ngoto node_error;\\r\\n}\\r\\n}\\r\\nif (tree) {\\r\\nif (!tree->extra_data)\\r\\ntree->extra_data = sk_X509_POLICY_DATA_new_null();\\r\\nif (!tree->extra_data)\\r\\ngoto node_error;\\r\\nif (!sk_X509_POLICY_DATA_push(tree->extra_data, data))\\r\\ngoto node_error;\\r\\n}\\r\\nif (parent)\\r\\nparent->nchild++;\\r\\nreturn node;\\r\\nnode_error:\\r\\npolicy_node_free(node);\\r\\nreturn 0;\\r\\n}\\r\\nvoid policy_node_free(X509_POLICY_NODE *node)\\r\\n{\\r\\nOPENSSL_free(node);\\r\\n}\\r\\nint policy_node_match(const X509_POLICY_LEVEL *lvl,\\r\\nconst X509_POLICY_NODE *node, const ASN1_OBJECT *oid)\\r\\n{\\r\\nint i;\\r\\nASN1_OBJECT *policy_oid;\\r\\nconst X509_POLICY_DATA *x = node->data;\\r\\nif ((lvl->flags & X509_V_FLAG_INHIBIT_MAP)\\r\\n|| !(x->flags & POLICY_DATA_FLAG_MAP_MASK)) {\\r\\nif (!OBJ_cmp(x->valid_policy, oid))\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_ASN1_OBJECT_num(x->expected_policy_set); i++) {\\r\\npolicy_oid = sk_ASN1_OBJECT_value(x->expected_policy_set, i);\\r\\nif (!OBJ_cmp(policy_oid, oid))\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pem_pkey_c", "target": 0, "func": "EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nchar *nm = NULL;\\r\\nconst unsigned char *p = NULL;\\r\\nunsigned char *data = NULL;\\r\\nlong len;\\r\\nint slen;\\r\\nEVP_PKEY *ret = NULL;\\r\\nif (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_EVP_PKEY, bp, cb, u))\\r\\nreturn NULL;\\r\\np = data;\\r\\nif (strcmp(nm, PEM_STRING_PKCS8INF) == 0) {\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\np8inf = d2i_PKCS8_PRIV_KEY_INFO(NULL, &p, len);\\r\\nif (!p8inf)\\r\\ngoto p8err;\\r\\nret = EVP_PKCS82PKEY(p8inf);\\r\\nif (x) {\\r\\nif (*x)\\r\\nEVP_PKEY_free((EVP_PKEY *)*x);\\r\\n*x = ret;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\n} else if (strcmp(nm, PEM_STRING_PKCS8) == 0) {\\r\\nPKCS8_PRIV_KEY_INFO *p8inf;\\r\\nX509_SIG *p8;\\r\\nint klen;\\r\\nchar psbuf[PEM_BUFSIZE];\\r\\np8 = d2i_X509_SIG(NULL, &p, len);\\r\\nif (!p8)\\r\\ngoto p8err;\\r\\nif (cb)\\r\\nklen = cb(psbuf, PEM_BUFSIZE, 0, u);\\r\\nelse\\r\\nklen = PEM_def_callback(psbuf, PEM_BUFSIZE, 0, u);\\r\\nif (klen <= 0) {\\r\\nPEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY, PEM_R_BAD_PASSWORD_READ);\\r\\nX509_SIG_free(p8);\\r\\ngoto err;\\r\\n}\\r\\np8inf = PKCS8_decrypt(p8, psbuf, klen);\\r\\nX509_SIG_free(p8);\\r\\nif (!p8inf)\\r\\ngoto p8err;\\r\\nret = EVP_PKCS82PKEY(p8inf);\\r\\nif (x) {\\r\\nif (*x)\\r\\nEVP_PKEY_free((EVP_PKEY *)*x);\\r\\n*x = ret;\\r\\n}\\r\\nPKCS8_PRIV_KEY_INFO_free(p8inf);\\r\\n} else if ((slen = pem_check_suffix(nm, \"PRIVATE KEY\")) > 0) {\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nameth = EVP_PKEY_asn1_find_str(NULL, nm, slen);\\r\\nif (!ameth || !ameth->old_priv_decode)\\r\\ngoto p8err;\\r\\nret = d2i_PrivateKey(ameth->pkey_id, x, &p, len);\\r\\n}\\r\\np8err:\\r\\nif (ret == NULL)\\r\\nPEMerr(PEM_F_PEM_READ_BIO_PRIVATEKEY, ERR_R_ASN1_LIB);\\r\\nerr:\\r\\nOPENSSL_free(nm);\\r\\nOPENSSL_cleanse(data, len);\\r\\nOPENSSL_free(data);\\r\\nreturn (ret);\\r\\n}\\r\\nint PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nunsigned char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nchar pem_str[80];\\r\\nif (!x->ameth || x->ameth->priv_encode)\\r\\nreturn PEM_write_bio_PKCS8PrivateKey(bp, x, enc,\\r\\n(char *)kstr, klen, cb, u);\\r\\nBIO_snprintf(pem_str, 80, \"%s PRIVATE KEY\", x->ameth->pem_str);\\r\\nreturn PEM_ASN1_write_bio((i2d_of_void *)i2d_PrivateKey,\\r\\npem_str, bp, x, enc, kstr, klen, cb, u);\\r\\n}\\r\\nEVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x)\\r\\n{\\r\\nchar *nm = NULL;\\r\\nconst unsigned char *p = NULL;\\r\\nunsigned char *data = NULL;\\r\\nlong len;\\r\\nint slen;\\r\\nEVP_PKEY *ret = NULL;\\r\\nif (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_PARAMETERS,\\r\\nbp, 0, NULL))\\r\\nreturn NULL;\\r\\np = data;\\r\\nif ((slen = pem_check_suffix(nm, \"PARAMETERS\")) > 0) {\\r\\nret = EVP_PKEY_new();\\r\\nif (!ret)\\r\\ngoto err;\\r\\nif (!EVP_PKEY_set_type_str(ret, nm, slen)\\r\\n|| !ret->ameth->param_decode\\r\\n|| !ret->ameth->param_decode(ret, &p, len)) {\\r\\nEVP_PKEY_free(ret);\\r\\nret = NULL;\\r\\ngoto err;\\r\\n}\\r\\nif (x) {\\r\\nif (*x)\\r\\nEVP_PKEY_free((EVP_PKEY *)*x);\\r\\n*x = ret;\\r\\n}\\r\\n}\\r\\nerr:\\r\\nif (ret == NULL)\\r\\nPEMerr(PEM_F_PEM_READ_BIO_PARAMETERS, ERR_R_ASN1_LIB);\\r\\nOPENSSL_free(nm);\\r\\nOPENSSL_free(data);\\r\\nreturn (ret);\\r\\n}\\r\\nint PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x)\\r\\n{\\r\\nchar pem_str[80];\\r\\nif (!x->ameth || !x->ameth->param_encode)\\r\\nreturn 0;\\r\\nBIO_snprintf(pem_str, 80, \"%s PARAMETERS\", x->ameth->pem_str);\\r\\nreturn PEM_ASN1_write_bio((i2d_of_void *)x->ameth->param_encode,\\r\\npem_str, bp, x, NULL, NULL, 0, 0, NULL);\\r\\n}\\r\\nEVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,\\r\\nvoid *u)\\r\\n{\\r\\nBIO *b;\\r\\nEVP_PKEY *ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nPEMerr(PEM_F_PEM_READ_PRIVATEKEY, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = PEM_read_bio_PrivateKey(b, x, cb, u);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}\\r\\nint PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,\\r\\nunsigned char *kstr, int klen,\\r\\npem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new_fp(fp, BIO_NOCLOSE)) == NULL) {\\r\\nPEMerr(PEM_F_PEM_WRITE_PRIVATEKEY, ERR_R_BUF_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nret = PEM_write_bio_PrivateKey(b, x, enc, kstr, klen, cb, u);\\r\\nBIO_free(b);\\r\\nreturn ret;\\r\\n}\\r\\nDH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u)\\r\\n{\\r\\nchar *nm = NULL;\\r\\nconst unsigned char *p = NULL;\\r\\nunsigned char *data = NULL;\\r\\nlong len;\\r\\nDH *ret = NULL;\\r\\nif (!PEM_bytes_read_bio(&data, &len, &nm, PEM_STRING_DHPARAMS, bp, cb, u))\\r\\nreturn NULL;\\r\\np = data;\\r\\nif (!strcmp(nm, PEM_STRING_DHXPARAMS))\\r\\nret = d2i_DHxparams(x, &p, len);\\r\\nelse\\r\\nret = d2i_DHparams(x, &p, len);\\r\\nif (ret == NULL)\\r\\nPEMerr(PEM_F_PEM_READ_BIO_DHPARAMS, ERR_R_ASN1_LIB);\\r\\nOPENSSL_free(nm);\\r\\nOPENSSL_free(data);\\r\\nreturn ret;\\r\\n}\\r\\nDH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u)\\r\\n{\\r\\nBIO *b;\\r\\nDH *ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nPEMerr(PEM_F_PEM_READ_DHPARAMS, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = PEM_read_bio_DHparams(b, x, cb, u);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dsa_key_c", "target": 0, "func": "int DSA_generate_key(DSA *dsa)\\r\\n{\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !(dsa->meth->flags & DSA_FLAG_FIPS_METHOD)\\r\\n&& !(dsa->flags & DSA_FLAG_NON_FIPS_ALLOW)) {\\r\\nDSAerr(DSA_F_DSA_GENERATE_KEY, DSA_R_NON_FIPS_DSA_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\n# endif\\r\\nif (dsa->meth->dsa_keygen)\\r\\nreturn dsa->meth->dsa_keygen(dsa);\\r\\n# ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_dsa_generate_key(dsa);\\r\\n# endif\\r\\nreturn dsa_builtin_keygen(dsa);\\r\\n}\\r\\nstatic int dsa_builtin_keygen(DSA *dsa)\\r\\n{\\r\\nint ok = 0;\\r\\nBN_CTX *ctx = NULL;\\r\\nBIGNUM *pub_key = NULL, *priv_key = NULL;\\r\\nif ((ctx = BN_CTX_new()) == NULL)\\r\\ngoto err;\\r\\nif (dsa->priv_key == NULL) {\\r\\nif ((priv_key = BN_new()) == NULL)\\r\\ngoto err;\\r\\n} else\\r\\npriv_key = dsa->priv_key;\\r\\ndo\\r\\nif (!BN_rand_range(priv_key, dsa->q))\\r\\ngoto err;\\r\\nwhile (BN_is_zero(priv_key)) ;\\r\\nif (dsa->pub_key == NULL) {\\r\\nif ((pub_key = BN_new()) == NULL)\\r\\ngoto err;\\r\\n} else\\r\\npub_key = dsa->pub_key;\\r\\n{\\r\\nBIGNUM local_prk;\\r\\nBIGNUM *prk;\\r\\nif ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\\r\\nBN_init(&local_prk);\\r\\nprk = &local_prk;\\r\\nBN_with_flags(prk, priv_key, BN_FLG_CONSTTIME);\\r\\n} else\\r\\nprk = priv_key;\\r\\nif (!BN_mod_exp(pub_key, dsa->g, prk, dsa->p, ctx))\\r\\ngoto err;\\r\\n}\\r\\ndsa->priv_key = priv_key;\\r\\ndsa->pub_key = pub_key;\\r\\nok = 1;\\r\\nerr:\\r\\nif ((pub_key != NULL) && (dsa->pub_key == NULL))\\r\\nBN_free(pub_key);\\r\\nif ((priv_key != NULL) && (dsa->priv_key == NULL))\\r\\nBN_free(priv_key);\\r\\nif (ctx != NULL)\\r\\nBN_CTX_free(ctx);\\r\\nreturn (ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_add_c", "target": 0, "func": "PKCS12_SAFEBAG *PKCS12_item_pack_safebag(void *obj, const ASN1_ITEM *it,\\r\\nint nid1, int nid2)\\r\\n{\\r\\nPKCS12_BAGS *bag;\\r\\nPKCS12_SAFEBAG *safebag;\\r\\nif (!(bag = PKCS12_BAGS_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbag->type = OBJ_nid2obj(nid1);\\r\\nif (!ASN1_item_pack(obj, it, &bag->value.octet)) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!(safebag = PKCS12_SAFEBAG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nsafebag->value.bag = bag;\\r\\nsafebag->type = OBJ_nid2obj(nid2);\\r\\nreturn safebag;\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_MAKE_KEYBAG(PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nPKCS12_SAFEBAG *bag;\\r\\nif (!(bag = PKCS12_SAFEBAG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_MAKE_KEYBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbag->type = OBJ_nid2obj(NID_keyBag);\\r\\nbag->value.keybag = p8;\\r\\nreturn bag;\\r\\n}\\r\\nPKCS12_SAFEBAG *PKCS12_MAKE_SHKEYBAG(int pbe_nid, const char *pass,\\r\\nint passlen, unsigned char *salt,\\r\\nint saltlen, int iter,\\r\\nPKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nPKCS12_SAFEBAG *bag;\\r\\nconst EVP_CIPHER *pbe_ciph;\\r\\nif (!(bag = PKCS12_SAFEBAG_new())) {\\r\\nPKCS12err(PKCS12_F_PKCS12_MAKE_SHKEYBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nbag->type = OBJ_nid2obj(NID_pkcs8ShroudedKeyBag);\\r\\npbe_ciph = EVP_get_cipherbynid(pbe_nid);\\r\\nif (pbe_ciph)\\r\\npbe_nid = -1;\\r\\nif (!(bag->value.shkeybag =\\r\\nPKCS8_encrypt(pbe_nid, pbe_ciph, pass, passlen, salt, saltlen, iter,\\r\\np8))) {\\r\\nPKCS12err(PKCS12_F_PKCS12_MAKE_SHKEYBAG, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn bag;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_i_skey_c", "target": 0, "func": "void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks)\\r\\n#ifdef OPENSSL_FIPS\\r\\n{\\r\\nfips_cipher_abort(IDEA);\\r\\nprivate_idea_set_encrypt_key(key, ks);\\r\\n}\\r\\nvoid private_idea_set_encrypt_key(const unsigned char *key,\\r\\nIDEA_KEY_SCHEDULE *ks)\\r\\n#endif\\r\\n{\\r\\nint i;\\r\\nregister IDEA_INT *kt, *kf, r0, r1, r2;\\r\\nkt = &(ks->data[0][0]);\\r\\nn2s(key, kt[0]);\\r\\nn2s(key, kt[1]);\\r\\nn2s(key, kt[2]);\\r\\nn2s(key, kt[3]);\\r\\nn2s(key, kt[4]);\\r\\nn2s(key, kt[5]);\\r\\nn2s(key, kt[6]);\\r\\nn2s(key, kt[7]);\\r\\nkf = kt;\\r\\nkt += 8;\\r\\nfor (i = 0; i < 6; i++) {\\r\\nr2 = kf[1];\\r\\nr1 = kf[2];\\r\\n*(kt++) = ((r2 << 9) | (r1 >> 7)) & 0xffff;\\r\\nr0 = kf[3];\\r\\n*(kt++) = ((r1 << 9) | (r0 >> 7)) & 0xffff;\\r\\nr1 = kf[4];\\r\\n*(kt++) = ((r0 << 9) | (r1 >> 7)) & 0xffff;\\r\\nr0 = kf[5];\\r\\n*(kt++) = ((r1 << 9) | (r0 >> 7)) & 0xffff;\\r\\nr1 = kf[6];\\r\\n*(kt++) = ((r0 << 9) | (r1 >> 7)) & 0xffff;\\r\\nr0 = kf[7];\\r\\n*(kt++) = ((r1 << 9) | (r0 >> 7)) & 0xffff;\\r\\nr1 = kf[0];\\r\\nif (i >= 5)\\r\\nbreak;\\r\\n*(kt++) = ((r0 << 9) | (r1 >> 7)) & 0xffff;\\r\\n*(kt++) = ((r1 << 9) | (r2 >> 7)) & 0xffff;\\r\\nkf += 8;\\r\\n}\\r\\n}\\r\\nvoid idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk)\\r\\n{\\r\\nint r;\\r\\nregister IDEA_INT *fp, *tp, t;\\r\\ntp = &(dk->data[0][0]);\\r\\nfp = &(ek->data[8][0]);\\r\\nfor (r = 0; r < 9; r++) {\\r\\n*(tp++) = inverse(fp[0]);\\r\\n*(tp++) = ((int)(0x10000L - fp[2]) & 0xffff);\\r\\n*(tp++) = ((int)(0x10000L - fp[1]) & 0xffff);\\r\\n*(tp++) = inverse(fp[3]);\\r\\nif (r == 8)\\r\\nbreak;\\r\\nfp -= 6;\\r\\n*(tp++) = fp[4];\\r\\n*(tp++) = fp[5];\\r\\n}\\r\\ntp = &(dk->data[0][0]);\\r\\nt = tp[1];\\r\\ntp[1] = tp[2];\\r\\ntp[2] = t;\\r\\nt = tp[49];\\r\\ntp[49] = tp[50];\\r\\ntp[50] = t;\\r\\n}\\r\\nstatic IDEA_INT inverse(unsigned int xin)\\r\\n{\\r\\nlong n1, n2, q, r, b1, b2, t;\\r\\nif (xin == 0)\\r\\nb2 = 0;\\r\\nelse {\\r\\nn1 = 0x10001;\\r\\nn2 = xin;\\r\\nb2 = 1;\\r\\nb1 = 0;\\r\\ndo {\\r\\nr = (n1 % n2);\\r\\nq = (n1 - r) / n2;\\r\\nif (r == 0) {\\r\\nif (b2 < 0)\\r\\nb2 = 0x10001 + b2;\\r\\n} else {\\r\\nn1 = n2;\\r\\nn2 = r;\\r\\nt = b2;\\r\\nb2 = b1 - q * b2;\\r\\nb1 = t;\\r\\n}\\r\\n} while (r != 0);\\r\\n}\\r\\nreturn ((IDEA_INT) b2);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_b_dump_c", "target": 0, "func": "int BIO_dump_cb(int (*cb) (const void *data, size_t len, void *u),\\r\\nvoid *u, const char *s, int len)\\r\\n{\\r\\nreturn BIO_dump_indent_cb(cb, u, s, len, 0);\\r\\n}\\r\\nint BIO_dump_indent_cb(int (*cb) (const void *data, size_t len, void *u),\\r\\nvoid *u, const char *s, int len, int indent)\\r\\n{\\r\\nint ret = 0;\\r\\nchar buf[288 + 1], tmp[20], str[128 + 1];\\r\\nint i, j, rows, trc;\\r\\nunsigned char ch;\\r\\nint dump_width;\\r\\ntrc = 0;\\r\\n#ifdef TRUNCATE\\r\\nfor (; (len > 0) && ((s[len - 1] == ' ') || (s[len - 1] == '\\0')); len--)\\r\\ntrc++;\\r\\n#endif\\r\\nif (indent < 0)\\r\\nindent = 0;\\r\\nif (indent) {\\r\\nif (indent > 128)\\r\\nindent = 128;\\r\\nmemset(str, ' ', indent);\\r\\n}\\r\\nstr[indent] = '\\0';\\r\\ndump_width = DUMP_WIDTH_LESS_INDENT(indent);\\r\\nrows = (len / dump_width);\\r\\nif ((rows * dump_width) < len)\\r\\nrows++;\\r\\nfor (i = 0; i < rows; i++) {\\r\\nbuf[0] = '\\0';\\r\\nBUF_strlcpy(buf, str, sizeof buf);\\r\\nBIO_snprintf(tmp, sizeof tmp, \"%04x - \", i * dump_width);\\r\\nBUF_strlcat(buf, tmp, sizeof buf);\\r\\nfor (j = 0; j < dump_width; j++) {\\r\\nif (((i * dump_width) + j) >= len) {\\r\\nBUF_strlcat(buf, \" \", sizeof buf);\\r\\n} else {\\r\\nch = ((unsigned char)*(s + i * dump_width + j)) & 0xff;\\r\\nBIO_snprintf(tmp, sizeof tmp, \"%02x%c\", ch,\\r\\nj == 7 ? '-' : ' ');\\r\\nBUF_strlcat(buf, tmp, sizeof buf);\\r\\n}\\r\\n}\\r\\nBUF_strlcat(buf, \" \", sizeof buf);\\r\\nfor (j = 0; j < dump_width; j++) {\\r\\nif (((i * dump_width) + j) >= len)\\r\\nbreak;\\r\\nch = ((unsigned char)*(s + i * dump_width + j)) & 0xff;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nBIO_snprintf(tmp, sizeof tmp, \"%c\",\\r\\n((ch >= ' ') && (ch <= '~')) ? ch : '.');\\r\\n#else\\r\\nBIO_snprintf(tmp, sizeof tmp, \"%c\",\\r\\n((ch >= os_toascii[' ']) && (ch <= os_toascii['~']))\\r\\n? os_toebcdic[ch]\\r\\n: '.');\\r\\n#endif\\r\\nBUF_strlcat(buf, tmp, sizeof buf);\\r\\n}\\r\\nBUF_strlcat(buf, \"\\n\", sizeof buf);\\r\\nret += cb((void *)buf, strlen(buf), u);\\r\\n}\\r\\n#ifdef TRUNCATE\\r\\nif (trc > 0) {\\r\\nBIO_snprintf(buf, sizeof buf, \"%s%04x - <SPACES/NULS>\\n\", str,\\r\\nlen + trc);\\r\\nret += cb((void *)buf, strlen(buf), u);\\r\\n}\\r\\n#endif\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int write_fp(const void *data, size_t len, void *fp)\\r\\n{\\r\\nreturn UP_fwrite(data, len, 1, fp);\\r\\n}\\r\\nint BIO_dump_fp(FILE *fp, const char *s, int len)\\r\\n{\\r\\nreturn BIO_dump_cb(write_fp, fp, s, len);\\r\\n}\\r\\nint BIO_dump_indent_fp(FILE *fp, const char *s, int len, int indent)\\r\\n{\\r\\nreturn BIO_dump_indent_cb(write_fp, fp, s, len, indent);\\r\\n}\\r\\nstatic int write_bio(const void *data, size_t len, void *bp)\\r\\n{\\r\\nreturn BIO_write((BIO *)bp, (const char *)data, len);\\r\\n}\\r\\nint BIO_dump(BIO *bp, const char *s, int len)\\r\\n{\\r\\nreturn BIO_dump_cb(write_bio, bp, s, len);\\r\\n}\\r\\nint BIO_dump_indent(BIO *bp, const char *s, int len, int indent)\\r\\n{\\r\\nreturn BIO_dump_indent_cb(write_bio, bp, s, len, indent);\\r\\n}\\r\\nint BIO_hex_string(BIO *out, int indent, int width, unsigned char *data,\\r\\nint datalen)\\r\\n{\\r\\nint i, j = 0;\\r\\nif (datalen < 1)\\r\\nreturn 1;\\r\\nfor (i = 0; i < datalen - 1; i++) {\\r\\nif (i && !j)\\r\\nBIO_printf(out, \"%*s\", indent, \"\");\\r\\nBIO_printf(out, \"%02X:\", data[i]);\\r\\nj = (j + 1) % width;\\r\\nif (!j)\\r\\nBIO_printf(out, \"\\n\");\\r\\n}\\r\\nif (i && !j)\\r\\nBIO_printf(out, \"%*s\", indent, \"\");\\r\\nBIO_printf(out, \"%02X\", data[datalen - 1]);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_randfile_c", "target": 0, "func": "int RAND_load_file(const char *file, long bytes)\\r\\n{\\r\\nMS_STATIC unsigned char buf[BUFSIZE];\\r\\n#ifndef OPENSSL_NO_POSIX_IO\\r\\nstruct stat sb;\\r\\n#endif\\r\\nint i, ret = 0, n;\\r\\nFILE *in;\\r\\nif (file == NULL)\\r\\nreturn (0);\\r\\n#ifndef OPENSSL_NO_POSIX_IO\\r\\n# ifdef PURIFY\\r\\nmemset(&sb, 0, sizeof(sb));\\r\\n# endif\\r\\nif (stat(file, &sb) < 0)\\r\\nreturn (0);\\r\\nRAND_add(&sb, sizeof(sb), 0.0);\\r\\n#endif\\r\\nif (bytes == 0)\\r\\nreturn (ret);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nin = vms_fopen(file, \"rb\", VMS_OPEN_ATTRS);\\r\\n#else\\r\\nin = fopen(file, \"rb\");\\r\\n#endif\\r\\nif (in == NULL)\\r\\ngoto err;\\r\\n#if defined(S_IFBLK) && defined(S_IFCHR) && !defined(OPENSSL_NO_POSIX_IO)\\r\\nif (sb.st_mode & (S_IFBLK | S_IFCHR)) {\\r\\nbytes = (bytes == -1) ? 2048 : bytes;\\r\\n# ifndef OPENSSL_NO_SETVBUF_IONBF\\r\\nsetvbuf(in, NULL, _IONBF, 0);\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\nfor (;;) {\\r\\nif (bytes > 0)\\r\\nn = (bytes < BUFSIZE) ? (int)bytes : BUFSIZE;\\r\\nelse\\r\\nn = BUFSIZE;\\r\\ni = fread(buf, 1, n, in);\\r\\nif (i <= 0)\\r\\nbreak;\\r\\n#ifdef PURIFY\\r\\nRAND_add(buf, i, (double)i);\\r\\n#else\\r\\nRAND_add(buf, n, (double)i);\\r\\n#endif\\r\\nret += i;\\r\\nif (bytes > 0) {\\r\\nbytes -= n;\\r\\nif (bytes <= 0)\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nfclose(in);\\r\\nOPENSSL_cleanse(buf, BUFSIZE);\\r\\nerr:\\r\\nreturn (ret);\\r\\n}\\r\\nint RAND_write_file(const char *file)\\r\\n{\\r\\nunsigned char buf[BUFSIZE];\\r\\nint i, ret = 0, rand_err = 0;\\r\\nFILE *out = NULL;\\r\\nint n;\\r\\n#ifndef OPENSSL_NO_POSIX_IO\\r\\nstruct stat sb;\\r\\ni = stat(file, &sb);\\r\\nif (i != -1) {\\r\\n# if defined(S_ISBLK) && defined(S_ISCHR)\\r\\nif (S_ISBLK(sb.st_mode) || S_ISCHR(sb.st_mode)) {\\r\\nreturn (1);\\r\\n}\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\n#if defined(O_CREAT) && !defined(OPENSSL_NO_POSIX_IO) && !defined(OPENSSL_SYS_VMS)\\r\\n{\\r\\n# ifndef O_BINARY\\r\\n# define O_BINARY 0\\r\\n# endif\\r\\nint fd = open(file, O_WRONLY | O_CREAT | O_BINARY, 0600);\\r\\nif (fd != -1)\\r\\nout = fdopen(fd, \"wb\");\\r\\n}\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nout = vms_fopen(file, \"rb+\", VMS_OPEN_ATTRS);\\r\\nif (out == NULL)\\r\\nout = vms_fopen(file, \"wb\", VMS_OPEN_ATTRS);\\r\\n#else\\r\\nif (out == NULL)\\r\\nout = fopen(file, \"wb\");\\r\\n#endif\\r\\nif (out == NULL)\\r\\ngoto err;\\r\\n#ifndef NO_CHMOD\\r\\nchmod(file, 0600);\\r\\n#endif\\r\\nn = RAND_DATA;\\r\\nfor (;;) {\\r\\ni = (n > BUFSIZE) ? BUFSIZE : n;\\r\\nn -= BUFSIZE;\\r\\nif (RAND_bytes(buf, i) <= 0)\\r\\nrand_err = 1;\\r\\ni = fwrite(buf, 1, i, out);\\r\\nif (i <= 0) {\\r\\nret = 0;\\r\\nbreak;\\r\\n}\\r\\nret += i;\\r\\nif (n <= 0)\\r\\nbreak;\\r\\n}\\r\\nfclose(out);\\r\\nOPENSSL_cleanse(buf, BUFSIZE);\\r\\nerr:\\r\\nreturn (rand_err ? -1 : ret);\\r\\n}\\r\\nconst char *RAND_file_name(char *buf, size_t size)\\r\\n{\\r\\nchar *s = NULL;\\r\\n#ifdef __OpenBSD__\\r\\nstruct stat sb;\\r\\n#endif\\r\\nif (OPENSSL_issetugid() == 0)\\r\\ns = getenv(\"RANDFILE\");\\r\\nif (s != NULL && *s && strlen(s) + 1 < size) {\\r\\nif (BUF_strlcpy(buf, s, size) >= size)\\r\\nreturn NULL;\\r\\n} else {\\r\\nif (OPENSSL_issetugid() == 0)\\r\\ns = getenv(\"HOME\");\\r\\n#ifdef DEFAULT_HOME\\r\\nif (s == NULL) {\\r\\ns = DEFAULT_HOME;\\r\\n}\\r\\n#endif\\r\\nif (s && *s && strlen(s) + strlen(RFILE) + 2 < size) {\\r\\nBUF_strlcpy(buf, s, size);\\r\\n#ifndef OPENSSL_SYS_VMS\\r\\nBUF_strlcat(buf, \"/\", size);\\r\\n#endif\\r\\nBUF_strlcat(buf, RFILE, size);\\r\\n} else\\r\\nbuf[0] = '\\0';\\r\\n}\\r\\n#ifdef __OpenBSD__\\r\\nif (!buf[0])\\r\\nif (BUF_strlcpy(buf, \"/dev/arandom\", size) >= size) {\\r\\nreturn (NULL);\\r\\n}\\r\\nif (stat(buf, &sb) == -1)\\r\\nif (BUF_strlcpy(buf, \"/dev/arandom\", size) >= size) {\\r\\nreturn (NULL);\\r\\n}\\r\\n#endif\\r\\nreturn (buf);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ui_openssl_c", "target": 0, "func": "UI_METHOD *UI_OpenSSL(void)\\r\\n{\\r\\nreturn &ui_openssl;\\r\\n}\\r\\nstatic int write_string(UI *ui, UI_STRING *uis)\\r\\n{\\r\\nswitch (UI_get_string_type(uis)) {\\r\\ncase UIT_ERROR:\\r\\ncase UIT_INFO:\\r\\nfputs(UI_get0_output_string(uis), tty_out);\\r\\nfflush(tty_out);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int read_string(UI *ui, UI_STRING *uis)\\r\\n{\\r\\nint ok = 0;\\r\\nswitch (UI_get_string_type(uis)) {\\r\\ncase UIT_BOOLEAN:\\r\\nfputs(UI_get0_output_string(uis), tty_out);\\r\\nfputs(UI_get0_action_string(uis), tty_out);\\r\\nfflush(tty_out);\\r\\nreturn read_string_inner(ui, uis,\\r\\nUI_get_input_flags(uis) & UI_INPUT_FLAG_ECHO,\\r\\n0);\\r\\ncase UIT_PROMPT:\\r\\nfputs(UI_get0_output_string(uis), tty_out);\\r\\nfflush(tty_out);\\r\\nreturn read_string_inner(ui, uis,\\r\\nUI_get_input_flags(uis) & UI_INPUT_FLAG_ECHO,\\r\\n1);\\r\\ncase UIT_VERIFY:\\r\\nfprintf(tty_out, \"Verifying - %s\", UI_get0_output_string(uis));\\r\\nfflush(tty_out);\\r\\nif ((ok = read_string_inner(ui, uis,\\r\\nUI_get_input_flags(uis) &\\r\\nUI_INPUT_FLAG_ECHO, 1)) <= 0)\\r\\nreturn ok;\\r\\nif (strcmp(UI_get0_result_string(uis), UI_get0_test_string(uis)) != 0) {\\r\\nfprintf(tty_out, \"Verify failure\\n\");\\r\\nfflush(tty_out);\\r\\nreturn 0;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int read_till_nl(FILE *in)\\r\\n{\\r\\n# define SIZE 4\\r\\nchar buf[SIZE + 1];\\r\\ndo {\\r\\nif (!fgets(buf, SIZE, in))\\r\\nreturn 0;\\r\\n} while (strchr(buf, '\\n') == NULL);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int read_string_inner(UI *ui, UI_STRING *uis, int echo, int strip_nl)\\r\\n{\\r\\nstatic int ps;\\r\\nint ok;\\r\\nchar result[BUFSIZ];\\r\\nint maxsize = BUFSIZ - 1;\\r\\n#if !defined(OPENSSL_SYS_WIN16) && !defined(OPENSSL_SYS_WINCE)\\r\\nchar *p;\\r\\nintr_signal = 0;\\r\\nok = 0;\\r\\nps = 0;\\r\\npushsig();\\r\\nps = 1;\\r\\nif (!echo && !noecho_console(ui))\\r\\ngoto error;\\r\\nps = 2;\\r\\nresult[0] = '\\0';\\r\\n# ifdef OPENSSL_SYS_MSDOS\\r\\nif (!echo) {\\r\\nnoecho_fgets(result, maxsize, tty_in);\\r\\np = result;\\r\\n} else\\r\\np = fgets(result, maxsize, tty_in);\\r\\n# else\\r\\np = fgets(result, maxsize, tty_in);\\r\\n# endif\\r\\nif (!p)\\r\\ngoto error;\\r\\nif (feof(tty_in))\\r\\ngoto error;\\r\\nif (ferror(tty_in))\\r\\ngoto error;\\r\\nif ((p = (char *)strchr(result, '\\n')) != NULL) {\\r\\nif (strip_nl)\\r\\n*p = '\\0';\\r\\n} else if (!read_till_nl(tty_in))\\r\\ngoto error;\\r\\nif (UI_set_result(ui, uis, result) >= 0)\\r\\nok = 1;\\r\\nerror:\\r\\nif (intr_signal == SIGINT)\\r\\nok = -1;\\r\\nif (!echo)\\r\\nfprintf(tty_out, \"\\n\");\\r\\nif (ps >= 2 && !echo && !echo_console(ui))\\r\\nok = 0;\\r\\nif (ps >= 1)\\r\\npopsig();\\r\\n#else\\r\\nok = 1;\\r\\n#endif\\r\\nOPENSSL_cleanse(result, BUFSIZ);\\r\\nreturn ok;\\r\\n}\\r\\nstatic int open_console(UI *ui)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_UI);\\r\\nis_a_tty = 1;\\r\\n#if defined(OPENSSL_SYS_MACINTOSH_CLASSIC) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS)\\r\\ntty_in = stdin;\\r\\ntty_out = stderr;\\r\\n#else\\r\\n# ifdef OPENSSL_SYS_MSDOS\\r\\n# define DEV_TTY \"con\"\\r\\n# else\\r\\n# define DEV_TTY \"/dev/tty\"\\r\\n# endif\\r\\nif ((tty_in = fopen(DEV_TTY, \"r\")) == NULL)\\r\\ntty_in = stdin;\\r\\nif ((tty_out = fopen(DEV_TTY, \"w\")) == NULL)\\r\\ntty_out = stderr;\\r\\n#endif\\r\\n#if defined(TTY_get) && !defined(OPENSSL_SYS_VMS)\\r\\nif (TTY_get(fileno(tty_in), &tty_orig) == -1) {\\r\\n# ifdef ENOTTY\\r\\nif (errno == ENOTTY)\\r\\nis_a_tty = 0;\\r\\nelse\\r\\n# endif\\r\\n# ifdef EINVAL\\r\\nif (errno == EINVAL)\\r\\nis_a_tty = 0;\\r\\nelse\\r\\n# endif\\r\\nreturn 0;\\r\\n}\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nstatus = sys$assign(&terminal, &channel, 0, 0);\\r\\nif (status != SS$_NORMAL)\\r\\nreturn 0;\\r\\nstatus =\\r\\nsys$qiow(0, channel, IO$_SENSEMODE, &iosb, 0, 0, tty_orig, 12, 0, 0,\\r\\n0, 0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn 0;\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int noecho_console(UI *ui)\\r\\n{\\r\\n#ifdef TTY_FLAGS\\r\\nmemcpy(&(tty_new), &(tty_orig), sizeof(tty_orig));\\r\\ntty_new.TTY_FLAGS &= ~ECHO;\\r\\n#endif\\r\\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\\r\\nif (is_a_tty && (TTY_set(fileno(tty_in), &tty_new) == -1))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\ntty_new[0] = tty_orig[0];\\r\\ntty_new[1] = tty_orig[1] | TT$M_NOECHO;\\r\\ntty_new[2] = tty_orig[2];\\r\\nstatus =\\r\\nsys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12, 0, 0, 0,\\r\\n0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn 0;\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int echo_console(UI *ui)\\r\\n{\\r\\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\\r\\nmemcpy(&(tty_new), &(tty_orig), sizeof(tty_orig));\\r\\ntty_new.TTY_FLAGS |= ECHO;\\r\\n#endif\\r\\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\\r\\nif (is_a_tty && (TTY_set(fileno(tty_in), &tty_new) == -1))\\r\\nreturn 0;\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\ntty_new[0] = tty_orig[0];\\r\\ntty_new[1] = tty_orig[1] & ~TT$M_NOECHO;\\r\\ntty_new[2] = tty_orig[2];\\r\\nstatus =\\r\\nsys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12, 0, 0, 0,\\r\\n0);\\r\\nif ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\\r\\nreturn 0;\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int close_console(UI *ui)\\r\\n{\\r\\nif (tty_in != stdin)\\r\\nfclose(tty_in);\\r\\nif (tty_out != stderr)\\r\\nfclose(tty_out);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\nstatus = sys$dassgn(channel);\\r\\n#endif\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_UI);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void pushsig(void)\\r\\n{\\r\\n# ifndef OPENSSL_SYS_WIN32\\r\\nint i;\\r\\n# endif\\r\\n# ifdef SIGACTION\\r\\nstruct sigaction sa;\\r\\nmemset(&sa, 0, sizeof sa);\\r\\nsa.sa_handler = recsig;\\r\\n# endif\\r\\n# ifdef OPENSSL_SYS_WIN32\\r\\nsavsig[SIGABRT] = signal(SIGABRT, recsig);\\r\\nsavsig[SIGFPE] = signal(SIGFPE, recsig);\\r\\nsavsig[SIGILL] = signal(SIGILL, recsig);\\r\\nsavsig[SIGINT] = signal(SIGINT, recsig);\\r\\nsavsig[SIGSEGV] = signal(SIGSEGV, recsig);\\r\\nsavsig[SIGTERM] = signal(SIGTERM, recsig);\\r\\n# else\\r\\nfor (i = 1; i < NX509_SIG; i++) {\\r\\n# ifdef SIGUSR1\\r\\nif (i == SIGUSR1)\\r\\ncontinue;\\r\\n# endif\\r\\n# ifdef SIGUSR2\\r\\nif (i == SIGUSR2)\\r\\ncontinue;\\r\\n# endif\\r\\n# ifdef SIGKILL\\r\\nif (i == SIGKILL)\\r\\ncontinue;\\r\\n# endif\\r\\n# ifdef SIGACTION\\r\\nsigaction(i, &sa, &savsig[i]);\\r\\n# else\\r\\nsavsig[i] = signal(i, recsig);\\r\\n# endif\\r\\n}\\r\\n# endif\\r\\n# ifdef SIGWINCH\\r\\nsignal(SIGWINCH, SIG_DFL);\\r\\n# endif\\r\\n}\\r\\nstatic void popsig(void)\\r\\n{\\r\\n# ifdef OPENSSL_SYS_WIN32\\r\\nsignal(SIGABRT, savsig[SIGABRT]);\\r\\nsignal(SIGFPE, savsig[SIGFPE]);\\r\\nsignal(SIGILL, savsig[SIGILL]);\\r\\nsignal(SIGINT, savsig[SIGINT]);\\r\\nsignal(SIGSEGV, savsig[SIGSEGV]);\\r\\nsignal(SIGTERM, savsig[SIGTERM]);\\r\\n# else\\r\\nint i;\\r\\nfor (i = 1; i < NX509_SIG; i++) {\\r\\n# ifdef SIGUSR1\\r\\nif (i == SIGUSR1)\\r\\ncontinue;\\r\\n# endif\\r\\n# ifdef SIGUSR2\\r\\nif (i == SIGUSR2)\\r\\ncontinue;\\r\\n# endif\\r\\n# ifdef SIGACTION\\r\\nsigaction(i, &savsig[i], NULL);\\r\\n# else\\r\\nsignal(i, savsig[i]);\\r\\n# endif\\r\\n}\\r\\n# endif\\r\\n}\\r\\nstatic void recsig(int i)\\r\\n{\\r\\nintr_signal = i;\\r\\n}\\r\\nstatic int noecho_fgets(char *buf, int size, FILE *tty)\\r\\n{\\r\\nint i;\\r\\nchar *p;\\r\\np = buf;\\r\\nfor (;;) {\\r\\nif (size == 0) {\\r\\n*p = '\\0';\\r\\nbreak;\\r\\n}\\r\\nsize--;\\r\\n# ifdef WIN16TTY\\r\\ni = _inchar();\\r\\n# elif defined(_WIN32)\\r\\ni = _getch();\\r\\n# else\\r\\ni = getch();\\r\\n# endif\\r\\nif (i == '\\r')\\r\\ni = '\\n';\\r\\n*(p++) = i;\\r\\nif (i == '\\n') {\\r\\n*p = '\\0';\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n# ifdef WIN_CONSOLE_BUG\\r\\n{\\r\\nHANDLE inh;\\r\\ninh = GetStdHandle(STD_INPUT_HANDLE);\\r\\nFlushConsoleInputBuffer(inh);\\r\\n}\\r\\n# endif\\r\\nreturn (strlen(buf));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_des_c", "target": 0, "func": "static int des_ecb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nBLOCK_CIPHER_ecb_loop()\\r\\nDES_ecb_encrypt((DES_cblock *)(in + i), (DES_cblock *)(out + i),\\r\\nctx->cipher_data, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ofb_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nwhile (inl >= EVP_MAXCHUNK) {\\r\\nDES_ofb64_encrypt(in, out, (long)EVP_MAXCHUNK, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, &ctx->num);\\r\\ninl -= EVP_MAXCHUNK;\\r\\nin += EVP_MAXCHUNK;\\r\\nout += EVP_MAXCHUNK;\\r\\n}\\r\\nif (inl)\\r\\nDES_ofb64_encrypt(in, out, (long)inl, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, &ctx->num);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_cbc_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nEVP_DES_KEY *dat = (EVP_DES_KEY *) ctx->cipher_data;\\r\\nif (dat->stream.cbc) {\\r\\n(*dat->stream.cbc) (in, out, inl, &dat->ks.ks, ctx->iv);\\r\\nreturn 1;\\r\\n}\\r\\nwhile (inl >= EVP_MAXCHUNK) {\\r\\nDES_ncbc_encrypt(in, out, (long)EVP_MAXCHUNK, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, ctx->encrypt);\\r\\ninl -= EVP_MAXCHUNK;\\r\\nin += EVP_MAXCHUNK;\\r\\nout += EVP_MAXCHUNK;\\r\\n}\\r\\nif (inl)\\r\\nDES_ncbc_encrypt(in, out, (long)inl, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_cfb64_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nwhile (inl >= EVP_MAXCHUNK) {\\r\\nDES_cfb64_encrypt(in, out, (long)EVP_MAXCHUNK, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\\r\\ninl -= EVP_MAXCHUNK;\\r\\nin += EVP_MAXCHUNK;\\r\\nout += EVP_MAXCHUNK;\\r\\n}\\r\\nif (inl)\\r\\nDES_cfb64_encrypt(in, out, (long)inl, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, &ctx->num, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_cfb1_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nsize_t n, chunk = EVP_MAXCHUNK / 8;\\r\\nunsigned char c[1], d[1];\\r\\nif (inl < chunk)\\r\\nchunk = inl;\\r\\nwhile (inl && inl >= chunk) {\\r\\nfor (n = 0; n < chunk * 8; ++n) {\\r\\nc[0] = (in[n / 8] & (1 << (7 - n % 8))) ? 0x80 : 0;\\r\\nDES_cfb_encrypt(c, d, 1, 1, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, ctx->encrypt);\\r\\nout[n / 8] =\\r\\n(out[n / 8] & ~(0x80 >> (unsigned int)(n % 8))) |\\r\\n((d[0] & 0x80) >> (unsigned int)(n % 8));\\r\\n}\\r\\ninl -= chunk;\\r\\nin += chunk;\\r\\nout += chunk;\\r\\nif (inl < chunk)\\r\\nchunk = inl;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_cfb8_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nwhile (inl >= EVP_MAXCHUNK) {\\r\\nDES_cfb_encrypt(in, out, 8, (long)EVP_MAXCHUNK, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, ctx->encrypt);\\r\\ninl -= EVP_MAXCHUNK;\\r\\nin += EVP_MAXCHUNK;\\r\\nout += EVP_MAXCHUNK;\\r\\n}\\r\\nif (inl)\\r\\nDES_cfb_encrypt(in, out, 8, (long)inl, ctx->cipher_data,\\r\\n(DES_cblock *)ctx->iv, ctx->encrypt);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nDES_cblock *deskey = (DES_cblock *)key;\\r\\nEVP_DES_KEY *dat = (EVP_DES_KEY *) ctx->cipher_data;\\r\\ndat->stream.cbc = NULL;\\r\\n# if defined(SPARC_DES_CAPABLE)\\r\\nif (SPARC_DES_CAPABLE) {\\r\\nint mode = ctx->cipher->flags & EVP_CIPH_MODE;\\r\\nif (mode == EVP_CIPH_CBC_MODE) {\\r\\ndes_t4_key_expand(key, &dat->ks.ks);\\r\\ndat->stream.cbc = enc ? des_t4_cbc_encrypt : des_t4_cbc_decrypt;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\n# endif\\r\\n# ifdef EVP_CHECK_DES_KEY\\r\\nif (DES_set_key_checked(deskey, dat->ks.ks) != 0)\\r\\nreturn 0;\\r\\n# else\\r\\nDES_set_key_unchecked(deskey, ctx->cipher_data);\\r\\n# endif\\r\\nreturn 1;\\r\\n}\\r\\nstatic int des_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nswitch (type) {\\r\\ncase EVP_CTRL_RAND_KEY:\\r\\nif (RAND_bytes(ptr, 8) <= 0)\\r\\nreturn 0;\\r\\nDES_set_odd_parity((DES_cblock *)ptr);\\r\\nreturn 1;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_dec_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL;\\r\\nX509 *rcert = NULL;\\r\\nEVP_PKEY *rkey = NULL;\\r\\nCMS_ContentInfo *cms = NULL;\\r\\nint ret = 1;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\ntbio = BIO_new_file(\"signer.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nrcert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nBIO_reset(tbio);\\r\\nrkey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);\\r\\nif (!rcert || !rkey)\\r\\ngoto err;\\r\\nin = BIO_new_file(\"smencr.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\ncms = SMIME_read_CMS(in, NULL);\\r\\nif (!cms)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"decout.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!CMS_decrypt(cms, rkey, rcert, NULL, out, 0))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Decrypting Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nif (rcert)\\r\\nX509_free(rcert);\\r\\nif (rkey)\\r\\nEVP_PKEY_free(rkey);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cryptlib_c", "target": 0, "func": "int CRYPTO_get_new_lockid(char *name)\\r\\n{\\r\\nchar *str;\\r\\nint i;\\r\\n#if defined(OPENSSL_SYS_WIN32) || defined(OPENSSL_SYS_WIN16)\\r\\nSSLeay_MSVC5_hack = (double)name[0] * (double)name[1];\\r\\n#endif\\r\\nif ((app_locks == NULL)\\r\\n&& ((app_locks = sk_OPENSSL_STRING_new_null()) == NULL)) {\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nif ((str = BUF_strdup(name)) == NULL) {\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_LOCKID, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\ni = sk_OPENSSL_STRING_push(app_locks, str);\\r\\nif (!i)\\r\\nOPENSSL_free(str);\\r\\nelse\\r\\ni += CRYPTO_NUM_LOCKS;\\r\\nreturn (i);\\r\\n}\\r\\nint CRYPTO_num_locks(void)\\r\\n{\\r\\nreturn CRYPTO_NUM_LOCKS;\\r\\n}\\r\\nint CRYPTO_get_new_dynlockid(void)\\r\\n{\\r\\nint i = 0;\\r\\nCRYPTO_dynlock *pointer = NULL;\\r\\nif (dynlock_create_callback == NULL) {\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID,\\r\\nCRYPTO_R_NO_DYNLOCK_CREATE_CALLBACK);\\r\\nreturn (0);\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\\r\\nif ((dyn_locks == NULL)\\r\\n&& ((dyn_locks = sk_CRYPTO_dynlock_new_null()) == NULL)) {\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\npointer = (CRYPTO_dynlock *) OPENSSL_malloc(sizeof(CRYPTO_dynlock));\\r\\nif (pointer == NULL) {\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\npointer->references = 1;\\r\\npointer->data = dynlock_create_callback(__FILE__, __LINE__);\\r\\nif (pointer->data == NULL) {\\r\\nOPENSSL_free(pointer);\\r\\nCRYPTOerr(CRYPTO_F_CRYPTO_GET_NEW_DYNLOCKID, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\\r\\ni = sk_CRYPTO_dynlock_find(dyn_locks, NULL);\\r\\nif (i == -1)\\r\\ni = sk_CRYPTO_dynlock_push(dyn_locks, pointer) - 1;\\r\\nelse\\r\\n(void)sk_CRYPTO_dynlock_set(dyn_locks, i, pointer);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (i == -1) {\\r\\ndynlock_destroy_callback(pointer->data, __FILE__, __LINE__);\\r\\nOPENSSL_free(pointer);\\r\\n} else\\r\\ni += 1;\\r\\nreturn -i;\\r\\n}\\r\\nvoid CRYPTO_destroy_dynlockid(int i)\\r\\n{\\r\\nCRYPTO_dynlock *pointer = NULL;\\r\\nif (i)\\r\\ni = -i - 1;\\r\\nif (dynlock_destroy_callback == NULL)\\r\\nreturn;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (dyn_locks == NULL || i >= sk_CRYPTO_dynlock_num(dyn_locks)) {\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nreturn;\\r\\n}\\r\\npointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\\r\\nif (pointer != NULL) {\\r\\n--pointer->references;\\r\\n#ifdef REF_CHECK\\r\\nif (pointer->references < 0) {\\r\\nfprintf(stderr,\\r\\n\"CRYPTO_destroy_dynlockid, bad reference count\\n\");\\r\\nabort();\\r\\n} else\\r\\n#endif\\r\\nif (pointer->references <= 0) {\\r\\n(void)sk_CRYPTO_dynlock_set(dyn_locks, i, NULL);\\r\\n} else\\r\\npointer = NULL;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (pointer) {\\r\\ndynlock_destroy_callback(pointer->data, __FILE__, __LINE__);\\r\\nOPENSSL_free(pointer);\\r\\n}\\r\\n}\\r\\nstruct CRYPTO_dynlock_value *CRYPTO_get_dynlock_value(int i)\\r\\n{\\r\\nCRYPTO_dynlock *pointer = NULL;\\r\\nif (i)\\r\\ni = -i - 1;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (dyn_locks != NULL && i < sk_CRYPTO_dynlock_num(dyn_locks))\\r\\npointer = sk_CRYPTO_dynlock_value(dyn_locks, i);\\r\\nif (pointer)\\r\\npointer->references++;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_DYNLOCK);\\r\\nif (pointer)\\r\\nreturn pointer->data;\\r\\nreturn NULL;\\r\\n}\\r\\nvoid CRYPTO_set_dynlock_lock_callback(void (*func) (int mode,\\r\\nstruct\\r\\nCRYPTO_dynlock_value *l,\\r\\nconst char *file,\\r\\nint line))\\r\\n{\\r\\ndynlock_lock_callback = func;\\r\\n}\\r\\nvoid CRYPTO_set_dynlock_destroy_callback(void (*func)\\r\\n(struct CRYPTO_dynlock_value *l,\\r\\nconst char *file, int line))\\r\\n{\\r\\ndynlock_destroy_callback = func;\\r\\n}\\r\\nvoid CRYPTO_set_locking_callback(void (*func) (int mode, int type,\\r\\nconst char *file, int line))\\r\\n{\\r\\nOPENSSL_init();\\r\\nlocking_callback = func;\\r\\n}\\r\\nvoid CRYPTO_set_add_lock_callback(int (*func) (int *num, int mount, int type,\\r\\nconst char *file, int line))\\r\\n{\\r\\nadd_lock_callback = func;\\r\\n}\\r\\nvoid CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, unsigned long val)\\r\\n{\\r\\nmemset(id, 0, sizeof(*id));\\r\\nid->val = val;\\r\\n}\\r\\nvoid CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr)\\r\\n{\\r\\nunsigned char *dest = (void *)&id->val;\\r\\nunsigned int accum = 0;\\r\\nunsigned char dnum = sizeof(id->val);\\r\\nmemset(id, 0, sizeof(*id));\\r\\nid->ptr = ptr;\\r\\nif (sizeof(id->val) >= sizeof(id->ptr)) {\\r\\nid->val = (unsigned long)id->ptr;\\r\\nreturn;\\r\\n}\\r\\nwhile (dnum--) {\\r\\nconst unsigned char *src = (void *)&id->ptr;\\r\\nunsigned char snum = sizeof(id->ptr);\\r\\nwhile (snum--)\\r\\naccum += *(src++) * hash_coeffs[(snum + dnum) & 7];\\r\\naccum += dnum;\\r\\n*(dest++) = accum & 255;\\r\\n}\\r\\n}\\r\\nint CRYPTO_THREADID_set_callback(void (*func) (CRYPTO_THREADID *))\\r\\n{\\r\\nif (threadid_callback)\\r\\nreturn 0;\\r\\nthreadid_callback = func;\\r\\nreturn 1;\\r\\n}\\r\\nvoid CRYPTO_THREADID_current(CRYPTO_THREADID *id)\\r\\n{\\r\\nif (threadid_callback) {\\r\\nthreadid_callback(id);\\r\\nreturn;\\r\\n}\\r\\n#ifndef OPENSSL_NO_DEPRECATED\\r\\nif (id_callback) {\\r\\nCRYPTO_THREADID_set_numeric(id, id_callback());\\r\\nreturn;\\r\\n}\\r\\n#endif\\r\\n#ifdef OPENSSL_SYS_WIN16\\r\\nCRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentTask());\\r\\n#elif defined(OPENSSL_SYS_WIN32)\\r\\nCRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentThreadId());\\r\\n#elif defined(OPENSSL_SYS_BEOS)\\r\\nCRYPTO_THREADID_set_numeric(id, (unsigned long)find_thread(NULL));\\r\\n#else\\r\\nCRYPTO_THREADID_set_pointer(id, (void *)&errno);\\r\\n#endif\\r\\n}\\r\\nint CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a, const CRYPTO_THREADID *b)\\r\\n{\\r\\nreturn memcmp(a, b, sizeof(*a));\\r\\n}\\r\\nvoid CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest, const CRYPTO_THREADID *src)\\r\\n{\\r\\nmemcpy(dest, src, sizeof(*src));\\r\\n}\\r\\nunsigned long CRYPTO_THREADID_hash(const CRYPTO_THREADID *id)\\r\\n{\\r\\nreturn id->val;\\r\\n}\\r\\nunsigned long CRYPTO_thread_id(void)\\r\\n{\\r\\nunsigned long ret = 0;\\r\\nif (id_callback == NULL) {\\r\\n# ifdef OPENSSL_SYS_WIN16\\r\\nret = (unsigned long)GetCurrentTask();\\r\\n# elif defined(OPENSSL_SYS_WIN32)\\r\\nret = (unsigned long)GetCurrentThreadId();\\r\\n# elif defined(GETPID_IS_MEANINGLESS)\\r\\nret = 1L;\\r\\n# elif defined(OPENSSL_SYS_BEOS)\\r\\nret = (unsigned long)find_thread(NULL);\\r\\n# else\\r\\nret = (unsigned long)getpid();\\r\\n# endif\\r\\n} else\\r\\nret = id_callback();\\r\\nreturn (ret);\\r\\n}\\r\\nvoid CRYPTO_lock(int mode, int type, const char *file, int line)\\r\\n{\\r\\n#ifdef LOCK_DEBUG\\r\\n{\\r\\nCRYPTO_THREADID id;\\r\\nchar *rw_text, *operation_text;\\r\\nif (mode & CRYPTO_LOCK)\\r\\noperation_text = \"lock \";\\r\\nelse if (mode & CRYPTO_UNLOCK)\\r\\noperation_text = \"unlock\";\\r\\nelse\\r\\noperation_text = \"ERROR \";\\r\\nif (mode & CRYPTO_READ)\\r\\nrw_text = \"r\";\\r\\nelse if (mode & CRYPTO_WRITE)\\r\\nrw_text = \"w\";\\r\\nelse\\r\\nrw_text = \"ERROR\";\\r\\nCRYPTO_THREADID_current(&id);\\r\\nfprintf(stderr, \"lock:%08lx:(%s)%s %-18s %s:%d\\n\",\\r\\nCRYPTO_THREADID_hash(&id), rw_text, operation_text,\\r\\nCRYPTO_get_lock_name(type), file, line);\\r\\n}\\r\\n#endif\\r\\nif (type < 0) {\\r\\nif (dynlock_lock_callback != NULL) {\\r\\nstruct CRYPTO_dynlock_value *pointer\\r\\n= CRYPTO_get_dynlock_value(type);\\r\\nOPENSSL_assert(pointer != NULL);\\r\\ndynlock_lock_callback(mode, pointer, file, line);\\r\\nCRYPTO_destroy_dynlockid(type);\\r\\n}\\r\\n} else if (locking_callback != NULL)\\r\\nlocking_callback(mode, type, file, line);\\r\\n}\\r\\nint CRYPTO_add_lock(int *pointer, int amount, int type, const char *file,\\r\\nint line)\\r\\n{\\r\\nint ret = 0;\\r\\nif (add_lock_callback != NULL) {\\r\\n#ifdef LOCK_DEBUG\\r\\nint before = *pointer;\\r\\n#endif\\r\\nret = add_lock_callback(pointer, amount, type, file, line);\\r\\n#ifdef LOCK_DEBUG\\r\\n{\\r\\nCRYPTO_THREADID id;\\r\\nCRYPTO_THREADID_current(&id);\\r\\nfprintf(stderr, \"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\\r\\nCRYPTO_THREADID_hash(&id), before, amount, ret,\\r\\nCRYPTO_get_lock_name(type), file, line);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nCRYPTO_lock(CRYPTO_LOCK | CRYPTO_WRITE, type, file, line);\\r\\nret = *pointer + amount;\\r\\n#ifdef LOCK_DEBUG\\r\\n{\\r\\nCRYPTO_THREADID id;\\r\\nCRYPTO_THREADID_current(&id);\\r\\nfprintf(stderr, \"ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\\n\",\\r\\nCRYPTO_THREADID_hash(&id),\\r\\n*pointer, amount, ret,\\r\\nCRYPTO_get_lock_name(type), file, line);\\r\\n}\\r\\n#endif\\r\\n*pointer = ret;\\r\\nCRYPTO_lock(CRYPTO_UNLOCK | CRYPTO_WRITE, type, file, line);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nconst char *CRYPTO_get_lock_name(int type)\\r\\n{\\r\\nif (type < 0)\\r\\nreturn (\"dynamic\");\\r\\nelse if (type < CRYPTO_NUM_LOCKS)\\r\\nreturn (lock_names[type]);\\r\\nelse if (type - CRYPTO_NUM_LOCKS > sk_OPENSSL_STRING_num(app_locks))\\r\\nreturn (\"ERROR\");\\r\\nelse\\r\\nreturn (sk_OPENSSL_STRING_value(app_locks, type - CRYPTO_NUM_LOCKS));\\r\\n}\\r\\nunsigned long *OPENSSL_ia32cap_loc(void)\\r\\n{\\r\\nif (sizeof(long) == 4)\\r\\nOPENSSL_ia32cap_P[1] = 0;\\r\\nOPENSSL_ia32cap_P[2] = 0;\\r\\nreturn (unsigned long *)OPENSSL_ia32cap_P;\\r\\n}\\r\\nvoid OPENSSL_cpuid_setup(void)\\r\\n{\\r\\nstatic int trigger = 0;\\r\\nIA32CAP OPENSSL_ia32_cpuid(unsigned int *);\\r\\nIA32CAP vec;\\r\\nchar *env;\\r\\nif (trigger)\\r\\nreturn;\\r\\ntrigger = 1;\\r\\nif ((env = getenv(\"OPENSSL_ia32cap\"))) {\\r\\nint off = (env[0] == '~') ? 1 : 0;\\r\\n# if defined(_WIN32)\\r\\nif (!sscanf(env + off, \"%I64i\", &vec))\\r\\nvec = strtoul(env + off, NULL, 0);\\r\\n# else\\r\\nif (!sscanf(env + off, \"%lli\", (long long *)&vec))\\r\\nvec = strtoul(env + off, NULL, 0);\\r\\n# endif\\r\\nif (off)\\r\\nvec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P) & ~vec;\\r\\nelse if (env[0] == ':')\\r\\nvec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P);\\r\\nOPENSSL_ia32cap_P[2] = 0;\\r\\nif ((env = strchr(env, ':'))) {\\r\\nunsigned int vecx;\\r\\nenv++;\\r\\noff = (env[0] == '~') ? 1 : 0;\\r\\nvecx = strtoul(env + off, NULL, 0);\\r\\nif (off)\\r\\nOPENSSL_ia32cap_P[2] &= ~vecx;\\r\\nelse\\r\\nOPENSSL_ia32cap_P[2] = vecx;\\r\\n}\\r\\n} else\\r\\nvec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P);\\r\\nOPENSSL_ia32cap_P[0] = (unsigned int)vec | (1 << 10);\\r\\nOPENSSL_ia32cap_P[1] = (unsigned int)(vec >> 32);\\r\\n}\\r\\nunsigned long *OPENSSL_ia32cap_loc(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nvoid OPENSSL_cpuid_setup(void)\\r\\n{\\r\\n}\\r\\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\\r\\n{\\r\\nswitch (fdwReason) {\\r\\ncase DLL_PROCESS_ATTACH:\\r\\nOPENSSL_cpuid_setup();\\r\\n# if defined(_WIN32_WINNT)\\r\\n{\\r\\nIMAGE_DOS_HEADER *dos_header = (IMAGE_DOS_HEADER *) hinstDLL;\\r\\nIMAGE_NT_HEADERS *nt_headers;\\r\\nif (dos_header->e_magic == IMAGE_DOS_SIGNATURE) {\\r\\nnt_headers = (IMAGE_NT_HEADERS *) ((char *)dos_header\\r\\n+ dos_header->e_lfanew);\\r\\nif (nt_headers->Signature == IMAGE_NT_SIGNATURE &&\\r\\nhinstDLL !=\\r\\n(HINSTANCE) (nt_headers->OptionalHeader.ImageBase))\\r\\nOPENSSL_NONPIC_relocated = 1;\\r\\n}\\r\\n}\\r\\n# endif\\r\\nbreak;\\r\\ncase DLL_THREAD_ATTACH:\\r\\nbreak;\\r\\ncase DLL_THREAD_DETACH:\\r\\nbreak;\\r\\ncase DLL_PROCESS_DETACH:\\r\\nbreak;\\r\\n}\\r\\nreturn (TRUE);\\r\\n}\\r\\nint OPENSSL_isservice(void)\\r\\n{\\r\\nHWINSTA h;\\r\\nDWORD len;\\r\\nWCHAR *name;\\r\\nstatic union {\\r\\nvoid *p;\\r\\nint (*f) (void);\\r\\n} _OPENSSL_isservice = {\\r\\nNULL\\r\\n};\\r\\nif (_OPENSSL_isservice.p == NULL) {\\r\\nHANDLE h = GetModuleHandle(NULL);\\r\\nif (h != NULL)\\r\\n_OPENSSL_isservice.p = GetProcAddress(h, \"_OPENSSL_isservice\");\\r\\nif (_OPENSSL_isservice.p == NULL)\\r\\n_OPENSSL_isservice.p = (void *)-1;\\r\\n}\\r\\nif (_OPENSSL_isservice.p != (void *)-1)\\r\\nreturn (*_OPENSSL_isservice.f) ();\\r\\n(void)GetDesktopWindow();\\r\\nh = GetProcessWindowStation();\\r\\nif (h == NULL)\\r\\nreturn -1;\\r\\nif (GetUserObjectInformationW(h, UOI_NAME, NULL, 0, &len) ||\\r\\nGetLastError() != ERROR_INSUFFICIENT_BUFFER)\\r\\nreturn -1;\\r\\nif (len > 512)\\r\\nreturn -1;\\r\\nlen++, len &= ~1;\\r\\nname = (WCHAR *)alloca(len + sizeof(WCHAR));\\r\\nif (!GetUserObjectInformationW(h, UOI_NAME, name, len, &len))\\r\\nreturn -1;\\r\\nlen++, len &= ~1;\\r\\nname[len / sizeof(WCHAR)] = L'\\0';\\r\\n# if 1\\r\\nif (wcsstr(name, L\"Service-0x\"))\\r\\nreturn 1;\\r\\n# else\\r\\nif (!wcsstr(name, L\"WinSta0\"))\\r\\nreturn 1;\\r\\n# endif\\r\\nelse\\r\\nreturn 0;\\r\\n}\\r\\nint OPENSSL_isservice(void)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nvoid OPENSSL_showfatal(const char *fmta, ...)\\r\\n{\\r\\nva_list ap;\\r\\nTCHAR buf[256];\\r\\nconst TCHAR *fmt;\\r\\n# ifdef STD_ERROR_HANDLE\\r\\nHANDLE h;\\r\\nif ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\\r\\nGetFileType(h) != FILE_TYPE_UNKNOWN) {\\r\\nint len;\\r\\nDWORD out;\\r\\nva_start(ap, fmta);\\r\\nlen = _vsnprintf((char *)buf, sizeof(buf), fmta, ap);\\r\\nWriteFile(h, buf, len < 0 ? sizeof(buf) : (DWORD) len, &out, NULL);\\r\\nva_end(ap);\\r\\nreturn;\\r\\n}\\r\\n# endif\\r\\nif (sizeof(TCHAR) == sizeof(char))\\r\\nfmt = (const TCHAR *)fmta;\\r\\nelse\\r\\ndo {\\r\\nint keepgoing;\\r\\nsize_t len_0 = strlen(fmta) + 1, i;\\r\\nWCHAR *fmtw;\\r\\nfmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\\r\\nif (fmtw == NULL) {\\r\\nfmt = (const TCHAR *)L\"no stack?\";\\r\\nbreak;\\r\\n}\\r\\n# ifndef OPENSSL_NO_MULTIBYTE\\r\\nif (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\\r\\n# endif\\r\\nfor (i = 0; i < len_0; i++)\\r\\nfmtw[i] = (WCHAR)fmta[i];\\r\\nfor (i = 0; i < len_0; i++) {\\r\\nif (fmtw[i] == L'%')\\r\\ndo {\\r\\nkeepgoing = 0;\\r\\nswitch (fmtw[i + 1]) {\\r\\ncase L'0':\\r\\ncase L'1':\\r\\ncase L'2':\\r\\ncase L'3':\\r\\ncase L'4':\\r\\ncase L'5':\\r\\ncase L'6':\\r\\ncase L'7':\\r\\ncase L'8':\\r\\ncase L'9':\\r\\ncase L'.':\\r\\ncase L'*':\\r\\ncase L'-':\\r\\ni++;\\r\\nkeepgoing = 1;\\r\\nbreak;\\r\\ncase L's':\\r\\nfmtw[i + 1] = L'S';\\r\\nbreak;\\r\\ncase L'S':\\r\\nfmtw[i + 1] = L's';\\r\\nbreak;\\r\\ncase L'c':\\r\\nfmtw[i + 1] = L'C';\\r\\nbreak;\\r\\ncase L'C':\\r\\nfmtw[i + 1] = L'c';\\r\\nbreak;\\r\\n}\\r\\n} while (keepgoing);\\r\\n}\\r\\nfmt = (const TCHAR *)fmtw;\\r\\n} while (0);\\r\\nva_start(ap, fmta);\\r\\n_vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\\r\\nbuf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\\r\\nva_end(ap);\\r\\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\\r\\nif (check_winnt() && OPENSSL_isservice() > 0) {\\r\\nHANDLE h = RegisterEventSource(0, _T(\"OPENSSL\"));\\r\\nconst TCHAR *pmsg = buf;\\r\\nReportEvent(h, EVENTLOG_ERROR_TYPE, 0, 0, 0, 1, 0, &pmsg, 0);\\r\\nDeregisterEventSource(h);\\r\\n} else\\r\\n# endif\\r\\nMessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONSTOP);\\r\\n}\\r\\nvoid OPENSSL_showfatal(const char *fmta, ...)\\r\\n{\\r\\nva_list ap;\\r\\nva_start(ap, fmta);\\r\\nvfprintf(stderr, fmta, ap);\\r\\nva_end(ap);\\r\\n}\\r\\nint OPENSSL_isservice(void)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nvoid OpenSSLDie(const char *file, int line, const char *assertion)\\r\\n{\\r\\nOPENSSL_showfatal\\r\\n(\"%s(%d): OpenSSL internal error, assertion failed: %s\\n\", file, line,\\r\\nassertion);\\r\\n#if !defined(_WIN32) || defined(__CYGWIN__)\\r\\nabort();\\r\\n#else\\r\\n# if !defined(_WIN32_WCE)\\r\\nraise(SIGABRT);\\r\\n# endif\\r\\n_exit(3);\\r\\n#endif\\r\\n}\\r\\nvoid *OPENSSL_stderr(void)\\r\\n{\\r\\nreturn stderr;\\r\\n}\\r\\nint CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len)\\r\\n{\\r\\nsize_t i;\\r\\nconst unsigned char *a = in_a;\\r\\nconst unsigned char *b = in_b;\\r\\nunsigned char x = 0;\\r\\nfor (i = 0; i < len; i++)\\r\\nx |= a[i] ^ b[i];\\r\\nreturn x;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pkeyparam_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nchar **args, *infile = NULL, *outfile = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nint text = 0, noout = 0;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nint badarg = 0;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n#endif\\r\\nint ret = 1;\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nERR_load_crypto_strings();\\r\\nOpenSSL_add_all_algorithms();\\r\\nargs = argv + 1;\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp(*args, \"-in\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\ninfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*args, \"-engine\") == 0) {\\r\\nif (!args[1])\\r\\ngoto bad;\\r\\nengine = *(++args);\\r\\n}\\r\\n#endif\\r\\nelse if (strcmp(*args, \"-text\") == 0)\\r\\ntext = 1;\\r\\nelse if (strcmp(*args, \"-noout\") == 0)\\r\\nnoout = 1;\\r\\nargs++;\\r\\n}\\r\\nif (badarg) {\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nbad:\\r\\n#endif\\r\\nBIO_printf(bio_err, \"Usage pkeyparam [options]\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err, \"-text print parameters as text\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-noout don't output encoded parameters\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nreturn 1;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nsetup_engine(bio_err, engine, 0);\\r\\n#endif\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file(infile, \"r\"))) {\\r\\nBIO_printf(bio_err, \"Can't open input file %s\\n\", infile);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file(outfile, \"w\"))) {\\r\\nBIO_printf(bio_err, \"Can't open output file %s\\n\", outfile);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\npkey = PEM_read_bio_Parameters(in, NULL);\\r\\nif (!pkey) {\\r\\nBIO_printf(bio_err, \"Error reading parameters\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (!noout)\\r\\nPEM_write_bio_Parameters(out, pkey);\\r\\nif (text)\\r\\nEVP_PKEY_print_params(out, pkey, 0, NULL);\\r\\nret = 0;\\r\\nend:\\r\\nEVP_PKEY_free(pkey);\\r\\nBIO_free_all(out);\\r\\nBIO_free(in);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_int_c", "target": 0, "func": "ASN1_INTEGER *ASN1_INTEGER_dup(const ASN1_INTEGER *x)\\r\\n{\\r\\nreturn M_ASN1_INTEGER_dup(x);\\r\\n}\\r\\nint ASN1_INTEGER_cmp(const ASN1_INTEGER *x, const ASN1_INTEGER *y)\\r\\n{\\r\\nint neg, ret;\\r\\nneg = x->type & V_ASN1_NEG;\\r\\nif (neg != (y->type & V_ASN1_NEG)) {\\r\\nif (neg)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nret = ASN1_STRING_cmp(x, y);\\r\\nif (neg)\\r\\nreturn -ret;\\r\\nelse\\r\\nreturn ret;\\r\\n}\\r\\nint i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp)\\r\\n{\\r\\nint pad = 0, ret, i, neg;\\r\\nunsigned char *p, *n, pb = 0;\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nneg = a->type & V_ASN1_NEG;\\r\\nif (a->length == 0)\\r\\nret = 1;\\r\\nelse {\\r\\nret = a->length;\\r\\ni = a->data[0];\\r\\nif (!neg && (i > 127)) {\\r\\npad = 1;\\r\\npb = 0;\\r\\n} else if (neg) {\\r\\nif (i > 128) {\\r\\npad = 1;\\r\\npb = 0xFF;\\r\\n} else if (i == 128) {\\r\\nfor (i = 1; i < a->length; i++)\\r\\nif (a->data[i]) {\\r\\npad = 1;\\r\\npb = 0xFF;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\n}\\r\\nret += pad;\\r\\n}\\r\\nif (pp == NULL)\\r\\nreturn (ret);\\r\\np = *pp;\\r\\nif (pad)\\r\\n*(p++) = pb;\\r\\nif (a->length == 0)\\r\\n*(p++) = 0;\\r\\nelse if (!neg)\\r\\nmemcpy(p, a->data, (unsigned int)a->length);\\r\\nelse {\\r\\nn = a->data + a->length - 1;\\r\\np += a->length - 1;\\r\\ni = a->length;\\r\\nwhile (!*n) {\\r\\n*(p--) = 0;\\r\\nn--;\\r\\ni--;\\r\\n}\\r\\n*(p--) = ((*(n--)) ^ 0xff) + 1;\\r\\ni--;\\r\\nfor (; i > 0; i--)\\r\\n*(p--) = *(n--) ^ 0xff;\\r\\n}\\r\\n*pp += ret;\\r\\nreturn (ret);\\r\\n}\\r\\nASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **pp,\\r\\nlong len)\\r\\n{\\r\\nASN1_INTEGER *ret = NULL;\\r\\nconst unsigned char *p, *pend;\\r\\nunsigned char *to, *s;\\r\\nint i;\\r\\nif ((a == NULL) || ((*a) == NULL)) {\\r\\nif ((ret = M_ASN1_INTEGER_new()) == NULL)\\r\\nreturn (NULL);\\r\\nret->type = V_ASN1_INTEGER;\\r\\n} else\\r\\nret = (*a);\\r\\np = *pp;\\r\\npend = p + len;\\r\\ns = (unsigned char *)OPENSSL_malloc((int)len + 1);\\r\\nif (s == NULL) {\\r\\ni = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nto = s;\\r\\nif (!len) {\\r\\nret->type = V_ASN1_INTEGER;\\r\\n} else if (*p & 0x80) {\\r\\nret->type = V_ASN1_NEG_INTEGER;\\r\\nif ((*p == 0xff) && (len != 1)) {\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\ni = len;\\r\\np += i - 1;\\r\\nto += i - 1;\\r\\nwhile ((!*p) && i) {\\r\\n*(to--) = 0;\\r\\ni--;\\r\\np--;\\r\\n}\\r\\nif (!i) {\\r\\n*s = 1;\\r\\ns[len] = 0;\\r\\nlen++;\\r\\n} else {\\r\\n*(to--) = (*(p--) ^ 0xff) + 1;\\r\\ni--;\\r\\nfor (; i > 0; i--)\\r\\n*(to--) = *(p--) ^ 0xff;\\r\\n}\\r\\n} else {\\r\\nret->type = V_ASN1_INTEGER;\\r\\nif ((*p == 0) && (len != 1)) {\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\nmemcpy(s, p, (int)len);\\r\\n}\\r\\nif (ret->data != NULL)\\r\\nOPENSSL_free(ret->data);\\r\\nret->data = s;\\r\\nret->length = (int)len;\\r\\nif (a != NULL)\\r\\n(*a) = ret;\\r\\n*pp = pend;\\r\\nreturn (ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_C2I_ASN1_INTEGER, i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nM_ASN1_INTEGER_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nASN1_INTEGER *ret = NULL;\\r\\nconst unsigned char *p;\\r\\nunsigned char *s;\\r\\nlong len;\\r\\nint inf, tag, xclass;\\r\\nint i;\\r\\nif ((a == NULL) || ((*a) == NULL)) {\\r\\nif ((ret = M_ASN1_INTEGER_new()) == NULL)\\r\\nreturn (NULL);\\r\\nret->type = V_ASN1_INTEGER;\\r\\n} else\\r\\nret = (*a);\\r\\np = *pp;\\r\\ninf = ASN1_get_object(&p, &len, &tag, &xclass, length);\\r\\nif (inf & 0x80) {\\r\\ni = ASN1_R_BAD_OBJECT_HEADER;\\r\\ngoto err;\\r\\n}\\r\\nif (tag != V_ASN1_INTEGER) {\\r\\ni = ASN1_R_EXPECTING_AN_INTEGER;\\r\\ngoto err;\\r\\n}\\r\\ns = (unsigned char *)OPENSSL_malloc((int)len + 1);\\r\\nif (s == NULL) {\\r\\ni = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nret->type = V_ASN1_INTEGER;\\r\\nif (len) {\\r\\nif ((*p == 0) && (len != 1)) {\\r\\np++;\\r\\nlen--;\\r\\n}\\r\\nmemcpy(s, p, (int)len);\\r\\np += len;\\r\\n}\\r\\nif (ret->data != NULL)\\r\\nOPENSSL_free(ret->data);\\r\\nret->data = s;\\r\\nret->length = (int)len;\\r\\nif (a != NULL)\\r\\n(*a) = ret;\\r\\n*pp = p;\\r\\nreturn (ret);\\r\\nerr:\\r\\nASN1err(ASN1_F_D2I_ASN1_UINTEGER, i);\\r\\nif ((ret != NULL) && ((a == NULL) || (*a != ret)))\\r\\nM_ASN1_INTEGER_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nint ASN1_INTEGER_set(ASN1_INTEGER *a, long v)\\r\\n{\\r\\nint j, k;\\r\\nunsigned int i;\\r\\nunsigned char buf[sizeof(long) + 1];\\r\\nlong d;\\r\\na->type = V_ASN1_INTEGER;\\r\\nif (a->length < (int)(sizeof(long) + 1)) {\\r\\nif (a->data != NULL)\\r\\nOPENSSL_free(a->data);\\r\\nif ((a->data =\\r\\n(unsigned char *)OPENSSL_malloc(sizeof(long) + 1)) != NULL)\\r\\nmemset((char *)a->data, 0, sizeof(long) + 1);\\r\\n}\\r\\nif (a->data == NULL) {\\r\\nASN1err(ASN1_F_ASN1_INTEGER_SET, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nd = v;\\r\\nif (d < 0) {\\r\\nd = -d;\\r\\na->type = V_ASN1_NEG_INTEGER;\\r\\n}\\r\\nfor (i = 0; i < sizeof(long); i++) {\\r\\nif (d == 0)\\r\\nbreak;\\r\\nbuf[i] = (int)d & 0xff;\\r\\nd >>= 8;\\r\\n}\\r\\nj = 0;\\r\\nfor (k = i - 1; k >= 0; k--)\\r\\na->data[j++] = buf[k];\\r\\na->length = j;\\r\\nreturn (1);\\r\\n}\\r\\nlong ASN1_INTEGER_get(const ASN1_INTEGER *a)\\r\\n{\\r\\nint neg = 0, i;\\r\\nlong r = 0;\\r\\nif (a == NULL)\\r\\nreturn (0L);\\r\\ni = a->type;\\r\\nif (i == V_ASN1_NEG_INTEGER)\\r\\nneg = 1;\\r\\nelse if (i != V_ASN1_INTEGER)\\r\\nreturn -1;\\r\\nif (a->length > (int)sizeof(long)) {\\r\\nreturn -1;\\r\\n}\\r\\nif (a->data == NULL)\\r\\nreturn 0;\\r\\nfor (i = 0; i < a->length; i++) {\\r\\nr <<= 8;\\r\\nr |= (unsigned char)a->data[i];\\r\\n}\\r\\nif (neg)\\r\\nr = -r;\\r\\nreturn (r);\\r\\n}\\r\\nASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai)\\r\\n{\\r\\nASN1_INTEGER *ret;\\r\\nint len, j;\\r\\nif (ai == NULL)\\r\\nret = M_ASN1_INTEGER_new();\\r\\nelse\\r\\nret = ai;\\r\\nif (ret == NULL) {\\r\\nASN1err(ASN1_F_BN_TO_ASN1_INTEGER, ERR_R_NESTED_ASN1_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (BN_is_negative(bn))\\r\\nret->type = V_ASN1_NEG_INTEGER;\\r\\nelse\\r\\nret->type = V_ASN1_INTEGER;\\r\\nj = BN_num_bits(bn);\\r\\nlen = ((j == 0) ? 0 : ((j / 8) + 1));\\r\\nif (ret->length < len + 4) {\\r\\nunsigned char *new_data = OPENSSL_realloc(ret->data, len + 4);\\r\\nif (!new_data) {\\r\\nASN1err(ASN1_F_BN_TO_ASN1_INTEGER, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nret->data = new_data;\\r\\n}\\r\\nret->length = BN_bn2bin(bn, ret->data);\\r\\nif (!ret->length) {\\r\\nret->data[0] = 0;\\r\\nret->length = 1;\\r\\n}\\r\\nreturn (ret);\\r\\nerr:\\r\\nif (ret != ai)\\r\\nM_ASN1_INTEGER_free(ret);\\r\\nreturn (NULL);\\r\\n}\\r\\nBIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn)\\r\\n{\\r\\nBIGNUM *ret;\\r\\nif ((ret = BN_bin2bn(ai->data, ai->length, bn)) == NULL)\\r\\nASN1err(ASN1_F_ASN1_INTEGER_TO_BN, ASN1_R_BN_LIB);\\r\\nelse if (ai->type == V_ASN1_NEG_INTEGER)\\r\\nBN_set_negative(ret, 1);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecp_nistp256_c", "target": 0, "func": "static void bin32_to_felem(felem out, const u8 in[32])\\r\\n{\\r\\nout[0] = *((u64 *)&in[0]);\\r\\nout[1] = *((u64 *)&in[8]);\\r\\nout[2] = *((u64 *)&in[16]);\\r\\nout[3] = *((u64 *)&in[24]);\\r\\n}\\r\\nstatic void smallfelem_to_bin32(u8 out[32], const smallfelem in)\\r\\n{\\r\\n*((u64 *)&out[0]) = in[0];\\r\\n*((u64 *)&out[8]) = in[1];\\r\\n*((u64 *)&out[16]) = in[2];\\r\\n*((u64 *)&out[24]) = in[3];\\r\\n}\\r\\nstatic void flip_endian(u8 *out, const u8 *in, unsigned len)\\r\\n{\\r\\nunsigned i;\\r\\nfor (i = 0; i < len; ++i)\\r\\nout[i] = in[len - 1 - i];\\r\\n}\\r\\nstatic int BN_to_felem(felem out, const BIGNUM *bn)\\r\\n{\\r\\nfelem_bytearray b_in;\\r\\nfelem_bytearray b_out;\\r\\nunsigned num_bytes;\\r\\nmemset(b_out, 0, sizeof b_out);\\r\\nnum_bytes = BN_num_bytes(bn);\\r\\nif (num_bytes > sizeof b_out) {\\r\\nECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\nif (BN_is_negative(bn)) {\\r\\nECerr(EC_F_BN_TO_FELEM, EC_R_BIGNUM_OUT_OF_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\nnum_bytes = BN_bn2bin(bn, b_in);\\r\\nflip_endian(b_out, b_in, num_bytes);\\r\\nbin32_to_felem(out, b_out);\\r\\nreturn 1;\\r\\n}\\r\\nstatic BIGNUM *smallfelem_to_BN(BIGNUM *out, const smallfelem in)\\r\\n{\\r\\nfelem_bytearray b_in, b_out;\\r\\nsmallfelem_to_bin32(b_in, in);\\r\\nflip_endian(b_out, b_in, sizeof b_out);\\r\\nreturn BN_bin2bn(b_out, sizeof b_out, out);\\r\\n}\\r\\nstatic void smallfelem_one(smallfelem out)\\r\\n{\\r\\nout[0] = 1;\\r\\nout[1] = 0;\\r\\nout[2] = 0;\\r\\nout[3] = 0;\\r\\n}\\r\\nstatic void smallfelem_assign(smallfelem out, const smallfelem in)\\r\\n{\\r\\nout[0] = in[0];\\r\\nout[1] = in[1];\\r\\nout[2] = in[2];\\r\\nout[3] = in[3];\\r\\n}\\r\\nstatic void felem_assign(felem out, const felem in)\\r\\n{\\r\\nout[0] = in[0];\\r\\nout[1] = in[1];\\r\\nout[2] = in[2];\\r\\nout[3] = in[3];\\r\\n}\\r\\nstatic void felem_sum(felem out, const felem in)\\r\\n{\\r\\nout[0] += in[0];\\r\\nout[1] += in[1];\\r\\nout[2] += in[2];\\r\\nout[3] += in[3];\\r\\n}\\r\\nstatic void felem_small_sum(felem out, const smallfelem in)\\r\\n{\\r\\nout[0] += in[0];\\r\\nout[1] += in[1];\\r\\nout[2] += in[2];\\r\\nout[3] += in[3];\\r\\n}\\r\\nstatic void felem_scalar(felem out, const u64 scalar)\\r\\n{\\r\\nout[0] *= scalar;\\r\\nout[1] *= scalar;\\r\\nout[2] *= scalar;\\r\\nout[3] *= scalar;\\r\\n}\\r\\nstatic void longfelem_scalar(longfelem out, const u64 scalar)\\r\\n{\\r\\nout[0] *= scalar;\\r\\nout[1] *= scalar;\\r\\nout[2] *= scalar;\\r\\nout[3] *= scalar;\\r\\nout[4] *= scalar;\\r\\nout[5] *= scalar;\\r\\nout[6] *= scalar;\\r\\nout[7] *= scalar;\\r\\n}\\r\\nstatic void smallfelem_neg(felem out, const smallfelem small)\\r\\n{\\r\\nout[0] = zero105[0] - small[0];\\r\\nout[1] = zero105[1] - small[1];\\r\\nout[2] = zero105[2] - small[2];\\r\\nout[3] = zero105[3] - small[3];\\r\\n}\\r\\nstatic void felem_diff(felem out, const felem in)\\r\\n{\\r\\nout[0] += zero105[0];\\r\\nout[1] += zero105[1];\\r\\nout[2] += zero105[2];\\r\\nout[3] += zero105[3];\\r\\nout[0] -= in[0];\\r\\nout[1] -= in[1];\\r\\nout[2] -= in[2];\\r\\nout[3] -= in[3];\\r\\n}\\r\\nstatic void felem_diff_zero107(felem out, const felem in)\\r\\n{\\r\\nout[0] += zero107[0];\\r\\nout[1] += zero107[1];\\r\\nout[2] += zero107[2];\\r\\nout[3] += zero107[3];\\r\\nout[0] -= in[0];\\r\\nout[1] -= in[1];\\r\\nout[2] -= in[2];\\r\\nout[3] -= in[3];\\r\\n}\\r\\nstatic void longfelem_diff(longfelem out, const longfelem in)\\r\\n{\\r\\nstatic const limb two70m8p6 =\\r\\n(((limb) 1) << 70) - (((limb) 1) << 8) + (((limb) 1) << 6);\\r\\nstatic const limb two70p40 = (((limb) 1) << 70) + (((limb) 1) << 40);\\r\\nstatic const limb two70 = (((limb) 1) << 70);\\r\\nstatic const limb two70m40m38p6 =\\r\\n(((limb) 1) << 70) - (((limb) 1) << 40) - (((limb) 1) << 38) +\\r\\n(((limb) 1) << 6);\\r\\nstatic const limb two70m6 = (((limb) 1) << 70) - (((limb) 1) << 6);\\r\\nout[0] += two70m8p6;\\r\\nout[1] += two70p40;\\r\\nout[2] += two70;\\r\\nout[3] += two70m40m38p6;\\r\\nout[4] += two70m6;\\r\\nout[5] += two70m6;\\r\\nout[6] += two70m6;\\r\\nout[7] += two70m6;\\r\\nout[0] -= in[0];\\r\\nout[1] -= in[1];\\r\\nout[2] -= in[2];\\r\\nout[3] -= in[3];\\r\\nout[4] -= in[4];\\r\\nout[5] -= in[5];\\r\\nout[6] -= in[6];\\r\\nout[7] -= in[7];\\r\\n}\\r\\nstatic void felem_shrink(smallfelem out, const felem in)\\r\\n{\\r\\nfelem tmp;\\r\\nu64 a, b, mask;\\r\\ns64 high, low;\\r\\nstatic const u64 kPrime3Test = 0x7fffffff00000001ul;\\r\\ntmp[3] = zero110[3] + in[3] + ((u64)(in[2] >> 64));\\r\\ntmp[2] = zero110[2] + (u64)in[2];\\r\\ntmp[0] = zero110[0] + in[0];\\r\\ntmp[1] = zero110[1] + in[1];\\r\\na = tmp[3] >> 64;\\r\\ntmp[3] = (u64)tmp[3];\\r\\ntmp[3] -= a;\\r\\ntmp[3] += ((limb) a) << 32;\\r\\nb = a;\\r\\na = tmp[3] >> 64;\\r\\nb += a;\\r\\ntmp[3] = (u64)tmp[3];\\r\\ntmp[3] -= a;\\r\\ntmp[3] += ((limb) a) << 32;\\r\\ntmp[0] += b;\\r\\ntmp[1] -= (((limb) b) << 32);\\r\\nhigh = tmp[3] >> 64;\\r\\nhigh <<= 63;\\r\\nhigh >>= 63;\\r\\nlow = tmp[3];\\r\\nmask = low >> 63;\\r\\nlow &= bottom63bits;\\r\\nlow -= kPrime3Test;\\r\\nlow = ~low;\\r\\nlow >>= 63;\\r\\nmask = (mask & low) | high;\\r\\ntmp[0] -= mask & kPrime[0];\\r\\ntmp[1] -= mask & kPrime[1];\\r\\ntmp[3] -= mask & kPrime[3];\\r\\ntmp[1] += ((u64)(tmp[0] >> 64));\\r\\ntmp[0] = (u64)tmp[0];\\r\\ntmp[2] += ((u64)(tmp[1] >> 64));\\r\\ntmp[1] = (u64)tmp[1];\\r\\ntmp[3] += ((u64)(tmp[2] >> 64));\\r\\ntmp[2] = (u64)tmp[2];\\r\\nout[0] = tmp[0];\\r\\nout[1] = tmp[1];\\r\\nout[2] = tmp[2];\\r\\nout[3] = tmp[3];\\r\\n}\\r\\nstatic void smallfelem_expand(felem out, const smallfelem in)\\r\\n{\\r\\nout[0] = in[0];\\r\\nout[1] = in[1];\\r\\nout[2] = in[2];\\r\\nout[3] = in[3];\\r\\n}\\r\\nstatic void smallfelem_square(longfelem out, const smallfelem small)\\r\\n{\\r\\nlimb a;\\r\\nu64 high, low;\\r\\na = ((uint128_t) small[0]) * small[0];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[0] = low;\\r\\nout[1] = high;\\r\\na = ((uint128_t) small[0]) * small[1];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[1] += low;\\r\\nout[1] += low;\\r\\nout[2] = high;\\r\\na = ((uint128_t) small[0]) * small[2];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[2] += low;\\r\\nout[2] *= 2;\\r\\nout[3] = high;\\r\\na = ((uint128_t) small[0]) * small[3];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[3] += low;\\r\\nout[4] = high;\\r\\na = ((uint128_t) small[1]) * small[2];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[3] += low;\\r\\nout[3] *= 2;\\r\\nout[4] += high;\\r\\na = ((uint128_t) small[1]) * small[1];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[2] += low;\\r\\nout[3] += high;\\r\\na = ((uint128_t) small[1]) * small[3];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[4] += low;\\r\\nout[4] *= 2;\\r\\nout[5] = high;\\r\\na = ((uint128_t) small[2]) * small[3];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[5] += low;\\r\\nout[5] *= 2;\\r\\nout[6] = high;\\r\\nout[6] += high;\\r\\na = ((uint128_t) small[2]) * small[2];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[4] += low;\\r\\nout[5] += high;\\r\\na = ((uint128_t) small[3]) * small[3];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[6] += low;\\r\\nout[7] = high;\\r\\n}\\r\\nstatic void felem_square(longfelem out, const felem in)\\r\\n{\\r\\nu64 small[4];\\r\\nfelem_shrink(small, in);\\r\\nsmallfelem_square(out, small);\\r\\n}\\r\\nstatic void smallfelem_mul(longfelem out, const smallfelem small1,\\r\\nconst smallfelem small2)\\r\\n{\\r\\nlimb a;\\r\\nu64 high, low;\\r\\na = ((uint128_t) small1[0]) * small2[0];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[0] = low;\\r\\nout[1] = high;\\r\\na = ((uint128_t) small1[0]) * small2[1];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[1] += low;\\r\\nout[2] = high;\\r\\na = ((uint128_t) small1[1]) * small2[0];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[1] += low;\\r\\nout[2] += high;\\r\\na = ((uint128_t) small1[0]) * small2[2];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[2] += low;\\r\\nout[3] = high;\\r\\na = ((uint128_t) small1[1]) * small2[1];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[2] += low;\\r\\nout[3] += high;\\r\\na = ((uint128_t) small1[2]) * small2[0];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[2] += low;\\r\\nout[3] += high;\\r\\na = ((uint128_t) small1[0]) * small2[3];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[3] += low;\\r\\nout[4] = high;\\r\\na = ((uint128_t) small1[1]) * small2[2];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[3] += low;\\r\\nout[4] += high;\\r\\na = ((uint128_t) small1[2]) * small2[1];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[3] += low;\\r\\nout[4] += high;\\r\\na = ((uint128_t) small1[3]) * small2[0];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[3] += low;\\r\\nout[4] += high;\\r\\na = ((uint128_t) small1[1]) * small2[3];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[4] += low;\\r\\nout[5] = high;\\r\\na = ((uint128_t) small1[2]) * small2[2];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[4] += low;\\r\\nout[5] += high;\\r\\na = ((uint128_t) small1[3]) * small2[1];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[4] += low;\\r\\nout[5] += high;\\r\\na = ((uint128_t) small1[2]) * small2[3];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[5] += low;\\r\\nout[6] = high;\\r\\na = ((uint128_t) small1[3]) * small2[2];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[5] += low;\\r\\nout[6] += high;\\r\\na = ((uint128_t) small1[3]) * small2[3];\\r\\nlow = a;\\r\\nhigh = a >> 64;\\r\\nout[6] += low;\\r\\nout[7] = high;\\r\\n}\\r\\nstatic void felem_mul(longfelem out, const felem in1, const felem in2)\\r\\n{\\r\\nsmallfelem small1, small2;\\r\\nfelem_shrink(small1, in1);\\r\\nfelem_shrink(small2, in2);\\r\\nsmallfelem_mul(out, small1, small2);\\r\\n}\\r\\nstatic void felem_small_mul(longfelem out, const smallfelem small1,\\r\\nconst felem in2)\\r\\n{\\r\\nsmallfelem small2;\\r\\nfelem_shrink(small2, in2);\\r\\nsmallfelem_mul(out, small1, small2);\\r\\n}\\r\\nstatic void felem_reduce_(felem out, const longfelem in)\\r\\n{\\r\\nint128_t c;\\r\\nc = in[4] + (in[5] << 32);\\r\\nout[0] += c;\\r\\nout[3] -= c;\\r\\nc = in[5] - in[7];\\r\\nout[1] += c;\\r\\nout[2] -= c;\\r\\nout[1] -= (in[4] << 32);\\r\\nout[3] += (in[4] << 32);\\r\\nout[2] -= (in[5] << 32);\\r\\nout[0] -= in[6];\\r\\nout[0] -= (in[6] << 32);\\r\\nout[1] += (in[6] << 33);\\r\\nout[2] += (in[6] * 2);\\r\\nout[3] -= (in[6] << 32);\\r\\nout[0] -= in[7];\\r\\nout[0] -= (in[7] << 32);\\r\\nout[2] += (in[7] << 33);\\r\\nout[3] += (in[7] * 3);\\r\\n}\\r\\nstatic void felem_reduce(felem out, const longfelem in)\\r\\n{\\r\\nout[0] = zero100[0] + in[0];\\r\\nout[1] = zero100[1] + in[1];\\r\\nout[2] = zero100[2] + in[2];\\r\\nout[3] = zero100[3] + in[3];\\r\\nfelem_reduce_(out, in);\\r\\n}\\r\\nstatic void felem_reduce_zero105(felem out, const longfelem in)\\r\\n{\\r\\nout[0] = zero105[0] + in[0];\\r\\nout[1] = zero105[1] + in[1];\\r\\nout[2] = zero105[2] + in[2];\\r\\nout[3] = zero105[3] + in[3];\\r\\nfelem_reduce_(out, in);\\r\\n}\\r\\nstatic void subtract_u64(u64 *result, u64 *carry, u64 v)\\r\\n{\\r\\nuint128_t r = *result;\\r\\nr -= v;\\r\\n*carry = (r >> 64) & 1;\\r\\n*result = (u64)r;\\r\\n}\\r\\nstatic void felem_contract(smallfelem out, const felem in)\\r\\n{\\r\\nunsigned i;\\r\\nu64 all_equal_so_far = 0, result = 0, carry;\\r\\nfelem_shrink(out, in);\\r\\nall_equal_so_far--;\\r\\nfor (i = 3; i < 4; i--) {\\r\\nu64 equal;\\r\\nuint128_t a = ((uint128_t) kPrime[i]) - out[i];\\r\\nresult |= all_equal_so_far & ((u64)(a >> 64));\\r\\nequal = kPrime[i] ^ out[i];\\r\\nequal--;\\r\\nequal &= equal << 32;\\r\\nequal &= equal << 16;\\r\\nequal &= equal << 8;\\r\\nequal &= equal << 4;\\r\\nequal &= equal << 2;\\r\\nequal &= equal << 1;\\r\\nequal = ((s64) equal) >> 63;\\r\\nall_equal_so_far &= equal;\\r\\n}\\r\\nresult |= all_equal_so_far;\\r\\nsubtract_u64(&out[0], &carry, result & kPrime[0]);\\r\\nsubtract_u64(&out[1], &carry, carry);\\r\\nsubtract_u64(&out[2], &carry, carry);\\r\\nsubtract_u64(&out[3], &carry, carry);\\r\\nsubtract_u64(&out[1], &carry, result & kPrime[1]);\\r\\nsubtract_u64(&out[2], &carry, carry);\\r\\nsubtract_u64(&out[3], &carry, carry);\\r\\nsubtract_u64(&out[2], &carry, result & kPrime[2]);\\r\\nsubtract_u64(&out[3], &carry, carry);\\r\\nsubtract_u64(&out[3], &carry, result & kPrime[3]);\\r\\n}\\r\\nstatic void smallfelem_square_contract(smallfelem out, const smallfelem in)\\r\\n{\\r\\nlongfelem longtmp;\\r\\nfelem tmp;\\r\\nsmallfelem_square(longtmp, in);\\r\\nfelem_reduce(tmp, longtmp);\\r\\nfelem_contract(out, tmp);\\r\\n}\\r\\nstatic void smallfelem_mul_contract(smallfelem out, const smallfelem in1,\\r\\nconst smallfelem in2)\\r\\n{\\r\\nlongfelem longtmp;\\r\\nfelem tmp;\\r\\nsmallfelem_mul(longtmp, in1, in2);\\r\\nfelem_reduce(tmp, longtmp);\\r\\nfelem_contract(out, tmp);\\r\\n}\\r\\nstatic limb smallfelem_is_zero(const smallfelem small)\\r\\n{\\r\\nlimb result;\\r\\nu64 is_p;\\r\\nu64 is_zero = small[0] | small[1] | small[2] | small[3];\\r\\nis_zero--;\\r\\nis_zero &= is_zero << 32;\\r\\nis_zero &= is_zero << 16;\\r\\nis_zero &= is_zero << 8;\\r\\nis_zero &= is_zero << 4;\\r\\nis_zero &= is_zero << 2;\\r\\nis_zero &= is_zero << 1;\\r\\nis_zero = ((s64) is_zero) >> 63;\\r\\nis_p = (small[0] ^ kPrime[0]) |\\r\\n(small[1] ^ kPrime[1]) |\\r\\n(small[2] ^ kPrime[2]) | (small[3] ^ kPrime[3]);\\r\\nis_p--;\\r\\nis_p &= is_p << 32;\\r\\nis_p &= is_p << 16;\\r\\nis_p &= is_p << 8;\\r\\nis_p &= is_p << 4;\\r\\nis_p &= is_p << 2;\\r\\nis_p &= is_p << 1;\\r\\nis_p = ((s64) is_p) >> 63;\\r\\nis_zero |= is_p;\\r\\nresult = is_zero;\\r\\nresult |= ((limb) is_zero) << 64;\\r\\nreturn result;\\r\\n}\\r\\nstatic int smallfelem_is_zero_int(const smallfelem small)\\r\\n{\\r\\nreturn (int)(smallfelem_is_zero(small) & ((limb) 1));\\r\\n}\\r\\nstatic void felem_inv(felem out, const felem in)\\r\\n{\\r\\nfelem ftmp, ftmp2;\\r\\nfelem e2, e4, e8, e16, e32, e64;\\r\\nlongfelem tmp;\\r\\nunsigned i;\\r\\nfelem_square(tmp, in);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, in, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_assign(e2, ftmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, ftmp, e2);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_assign(e4, ftmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, ftmp, e4);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_assign(e8, ftmp);\\r\\nfor (i = 0; i < 8; i++) {\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp, e8);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_assign(e16, ftmp);\\r\\nfor (i = 0; i < 16; i++) {\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp, e16);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_assign(e32, ftmp);\\r\\nfor (i = 0; i < 32; i++) {\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\n}\\r\\nfelem_assign(e64, ftmp);\\r\\nfelem_mul(tmp, ftmp, in);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfor (i = 0; i < 192; i++) {\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\n}\\r\\nfelem_mul(tmp, e64, e32);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfor (i = 0; i < 16; i++) {\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp2, e16);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfor (i = 0; i < 8; i++) {\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp2, e8);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfor (i = 0; i < 4; i++) {\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\n}\\r\\nfelem_mul(tmp, ftmp2, e4);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, ftmp2, e2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_square(tmp, ftmp2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, ftmp2, in);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, ftmp2, ftmp);\\r\\nfelem_reduce(out, tmp);\\r\\n}\\r\\nstatic void smallfelem_inv_contract(smallfelem out, const smallfelem in)\\r\\n{\\r\\nfelem tmp;\\r\\nsmallfelem_expand(tmp, in);\\r\\nfelem_inv(tmp, tmp);\\r\\nfelem_contract(out, tmp);\\r\\n}\\r\\nstatic void\\r\\npoint_double(felem x_out, felem y_out, felem z_out,\\r\\nconst felem x_in, const felem y_in, const felem z_in)\\r\\n{\\r\\nlongfelem tmp, tmp2;\\r\\nfelem delta, gamma, beta, alpha, ftmp, ftmp2;\\r\\nsmallfelem small1, small2;\\r\\nfelem_assign(ftmp, x_in);\\r\\nfelem_assign(ftmp2, x_in);\\r\\nfelem_square(tmp, z_in);\\r\\nfelem_reduce(delta, tmp);\\r\\nfelem_square(tmp, y_in);\\r\\nfelem_reduce(gamma, tmp);\\r\\nfelem_shrink(small1, gamma);\\r\\nfelem_small_mul(tmp, small1, x_in);\\r\\nfelem_reduce(beta, tmp);\\r\\nfelem_diff(ftmp, delta);\\r\\nfelem_sum(ftmp2, delta);\\r\\nfelem_scalar(ftmp2, 3);\\r\\nfelem_mul(tmp, ftmp, ftmp2);\\r\\nfelem_reduce(alpha, tmp);\\r\\nfelem_shrink(small2, alpha);\\r\\nsmallfelem_square(tmp, small2);\\r\\nfelem_reduce(x_out, tmp);\\r\\nfelem_assign(ftmp, beta);\\r\\nfelem_scalar(ftmp, 8);\\r\\nfelem_diff(x_out, ftmp);\\r\\nfelem_sum(delta, gamma);\\r\\nfelem_assign(ftmp, y_in);\\r\\nfelem_sum(ftmp, z_in);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(z_out, tmp);\\r\\nfelem_diff(z_out, delta);\\r\\nfelem_scalar(beta, 4);\\r\\nfelem_diff_zero107(beta, x_out);\\r\\nfelem_small_mul(tmp, small2, beta);\\r\\nsmallfelem_square(tmp2, small1);\\r\\nlongfelem_scalar(tmp2, 8);\\r\\nlongfelem_diff(tmp, tmp2);\\r\\nfelem_reduce_zero105(y_out, tmp);\\r\\n}\\r\\nstatic void\\r\\npoint_double_small(smallfelem x_out, smallfelem y_out, smallfelem z_out,\\r\\nconst smallfelem x_in, const smallfelem y_in,\\r\\nconst smallfelem z_in)\\r\\n{\\r\\nfelem felem_x_out, felem_y_out, felem_z_out;\\r\\nfelem felem_x_in, felem_y_in, felem_z_in;\\r\\nsmallfelem_expand(felem_x_in, x_in);\\r\\nsmallfelem_expand(felem_y_in, y_in);\\r\\nsmallfelem_expand(felem_z_in, z_in);\\r\\npoint_double(felem_x_out, felem_y_out, felem_z_out,\\r\\nfelem_x_in, felem_y_in, felem_z_in);\\r\\nfelem_shrink(x_out, felem_x_out);\\r\\nfelem_shrink(y_out, felem_y_out);\\r\\nfelem_shrink(z_out, felem_z_out);\\r\\n}\\r\\nstatic void copy_conditional(felem out, const felem in, limb mask)\\r\\n{\\r\\nunsigned i;\\r\\nfor (i = 0; i < NLIMBS; ++i) {\\r\\nconst limb tmp = mask & (in[i] ^ out[i]);\\r\\nout[i] ^= tmp;\\r\\n}\\r\\n}\\r\\nstatic void copy_small_conditional(felem out, const smallfelem in, limb mask)\\r\\n{\\r\\nunsigned i;\\r\\nconst u64 mask64 = mask;\\r\\nfor (i = 0; i < NLIMBS; ++i) {\\r\\nout[i] = ((limb) (in[i] & mask64)) | (out[i] & ~mask);\\r\\n}\\r\\n}\\r\\nstatic void point_add(felem x3, felem y3, felem z3,\\r\\nconst felem x1, const felem y1, const felem z1,\\r\\nconst int mixed, const smallfelem x2,\\r\\nconst smallfelem y2, const smallfelem z2)\\r\\n{\\r\\nfelem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\\r\\nlongfelem tmp, tmp2;\\r\\nsmallfelem small1, small2, small3, small4, small5;\\r\\nlimb x_equal, y_equal, z1_is_zero, z2_is_zero;\\r\\nfelem_shrink(small3, z1);\\r\\nz1_is_zero = smallfelem_is_zero(small3);\\r\\nz2_is_zero = smallfelem_is_zero(z2);\\r\\nsmallfelem_square(tmp, small3);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_shrink(small1, ftmp);\\r\\nif (!mixed) {\\r\\nsmallfelem_square(tmp, z2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_shrink(small2, ftmp2);\\r\\nfelem_shrink(small5, x1);\\r\\nsmallfelem_mul(tmp, small5, small2);\\r\\nfelem_reduce(ftmp3, tmp);\\r\\nfelem_assign(ftmp5, z1);\\r\\nfelem_small_sum(ftmp5, z2);\\r\\nfelem_square(tmp, ftmp5);\\r\\nfelem_reduce(ftmp5, tmp);\\r\\nfelem_sum(ftmp2, ftmp);\\r\\nfelem_diff(ftmp5, ftmp2);\\r\\nsmallfelem_mul(tmp, small2, z2);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, y1, ftmp2);\\r\\nfelem_reduce(ftmp6, tmp);\\r\\n} else {\\r\\nfelem_assign(ftmp3, x1);\\r\\nfelem_assign(ftmp5, z1);\\r\\nfelem_scalar(ftmp5, 2);\\r\\nfelem_assign(ftmp6, y1);\\r\\n}\\r\\nsmallfelem_mul(tmp, x2, small1);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\nfelem_diff_zero107(ftmp4, ftmp3);\\r\\nfelem_shrink(small4, ftmp4);\\r\\nx_equal = smallfelem_is_zero(small4);\\r\\nfelem_small_mul(tmp, small4, ftmp5);\\r\\nfelem_reduce(z_out, tmp);\\r\\nsmallfelem_mul(tmp, small1, small3);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_small_mul(tmp, y2, ftmp);\\r\\nfelem_reduce(ftmp5, tmp);\\r\\nfelem_diff_zero107(ftmp5, ftmp6);\\r\\nfelem_scalar(ftmp5, 2);\\r\\nfelem_shrink(small1, ftmp5);\\r\\ny_equal = smallfelem_is_zero(small1);\\r\\nif (x_equal && y_equal && !z1_is_zero && !z2_is_zero) {\\r\\npoint_double(x3, y3, z3, x1, y1, z1);\\r\\nreturn;\\r\\n}\\r\\nfelem_assign(ftmp, ftmp4);\\r\\nfelem_scalar(ftmp, 2);\\r\\nfelem_square(tmp, ftmp);\\r\\nfelem_reduce(ftmp, tmp);\\r\\nfelem_mul(tmp, ftmp4, ftmp);\\r\\nfelem_reduce(ftmp2, tmp);\\r\\nfelem_mul(tmp, ftmp3, ftmp);\\r\\nfelem_reduce(ftmp4, tmp);\\r\\nsmallfelem_square(tmp, small1);\\r\\nfelem_reduce(x_out, tmp);\\r\\nfelem_assign(ftmp3, ftmp4);\\r\\nfelem_scalar(ftmp4, 2);\\r\\nfelem_sum(ftmp4, ftmp2);\\r\\nfelem_diff(x_out, ftmp4);\\r\\nfelem_diff_zero107(ftmp3, x_out);\\r\\nfelem_small_mul(tmp, small1, ftmp3);\\r\\nfelem_mul(tmp2, ftmp6, ftmp2);\\r\\nlongfelem_scalar(tmp2, 2);\\r\\nlongfelem_diff(tmp, tmp2);\\r\\nfelem_reduce_zero105(y_out, tmp);\\r\\ncopy_small_conditional(x_out, x2, z1_is_zero);\\r\\ncopy_conditional(x_out, x1, z2_is_zero);\\r\\ncopy_small_conditional(y_out, y2, z1_is_zero);\\r\\ncopy_conditional(y_out, y1, z2_is_zero);\\r\\ncopy_small_conditional(z_out, z2, z1_is_zero);\\r\\ncopy_conditional(z_out, z1, z2_is_zero);\\r\\nfelem_assign(x3, x_out);\\r\\nfelem_assign(y3, y_out);\\r\\nfelem_assign(z3, z_out);\\r\\n}\\r\\nstatic void point_add_small(smallfelem x3, smallfelem y3, smallfelem z3,\\r\\nsmallfelem x1, smallfelem y1, smallfelem z1,\\r\\nsmallfelem x2, smallfelem y2, smallfelem z2)\\r\\n{\\r\\nfelem felem_x3, felem_y3, felem_z3;\\r\\nfelem felem_x1, felem_y1, felem_z1;\\r\\nsmallfelem_expand(felem_x1, x1);\\r\\nsmallfelem_expand(felem_y1, y1);\\r\\nsmallfelem_expand(felem_z1, z1);\\r\\npoint_add(felem_x3, felem_y3, felem_z3, felem_x1, felem_y1, felem_z1, 0,\\r\\nx2, y2, z2);\\r\\nfelem_shrink(x3, felem_x3);\\r\\nfelem_shrink(y3, felem_y3);\\r\\nfelem_shrink(z3, felem_z3);\\r\\n}\\r\\nstatic void select_point(const u64 idx, unsigned int size,\\r\\nconst smallfelem pre_comp[16][3], smallfelem out[3])\\r\\n{\\r\\nunsigned i, j;\\r\\nu64 *outlimbs = &out[0][0];\\r\\nmemset(outlimbs, 0, 3 * sizeof(smallfelem));\\r\\nfor (i = 0; i < size; i++) {\\r\\nconst u64 *inlimbs = (u64 *)&pre_comp[i][0][0];\\r\\nu64 mask = i ^ idx;\\r\\nmask |= mask >> 4;\\r\\nmask |= mask >> 2;\\r\\nmask |= mask >> 1;\\r\\nmask &= 1;\\r\\nmask--;\\r\\nfor (j = 0; j < NLIMBS * 3; j++)\\r\\noutlimbs[j] |= inlimbs[j] & mask;\\r\\n}\\r\\n}\\r\\nstatic char get_bit(const felem_bytearray in, int i)\\r\\n{\\r\\nif ((i < 0) || (i >= 256))\\r\\nreturn 0;\\r\\nreturn (in[i >> 3] >> (i & 7)) & 1;\\r\\n}\\r\\nstatic void batch_mul(felem x_out, felem y_out, felem z_out,\\r\\nconst felem_bytearray scalars[],\\r\\nconst unsigned num_points, const u8 *g_scalar,\\r\\nconst int mixed, const smallfelem pre_comp[][17][3],\\r\\nconst smallfelem g_pre_comp[2][16][3])\\r\\n{\\r\\nint i, skip;\\r\\nunsigned num, gen_mul = (g_scalar != NULL);\\r\\nfelem nq[3], ftmp;\\r\\nsmallfelem tmp[3];\\r\\nu64 bits;\\r\\nu8 sign, digit;\\r\\nmemset(nq, 0, 3 * sizeof(felem));\\r\\nskip = 1;\\r\\nfor (i = (num_points ? 255 : 31); i >= 0; --i) {\\r\\nif (!skip)\\r\\npoint_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\\r\\nif (gen_mul && (i <= 31)) {\\r\\nbits = get_bit(g_scalar, i + 224) << 3;\\r\\nbits |= get_bit(g_scalar, i + 160) << 2;\\r\\nbits |= get_bit(g_scalar, i + 96) << 1;\\r\\nbits |= get_bit(g_scalar, i + 32);\\r\\nselect_point(bits, 16, g_pre_comp[1], tmp);\\r\\nif (!skip) {\\r\\npoint_add(nq[0], nq[1], nq[2],\\r\\nnq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\\r\\n} else {\\r\\nsmallfelem_expand(nq[0], tmp[0]);\\r\\nsmallfelem_expand(nq[1], tmp[1]);\\r\\nsmallfelem_expand(nq[2], tmp[2]);\\r\\nskip = 0;\\r\\n}\\r\\nbits = get_bit(g_scalar, i + 192) << 3;\\r\\nbits |= get_bit(g_scalar, i + 128) << 2;\\r\\nbits |= get_bit(g_scalar, i + 64) << 1;\\r\\nbits |= get_bit(g_scalar, i);\\r\\nselect_point(bits, 16, g_pre_comp[0], tmp);\\r\\npoint_add(nq[0], nq[1], nq[2],\\r\\nnq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\\r\\n}\\r\\nif (num_points && (i % 5 == 0)) {\\r\\nfor (num = 0; num < num_points; ++num) {\\r\\nbits = get_bit(scalars[num], i + 4) << 5;\\r\\nbits |= get_bit(scalars[num], i + 3) << 4;\\r\\nbits |= get_bit(scalars[num], i + 2) << 3;\\r\\nbits |= get_bit(scalars[num], i + 1) << 2;\\r\\nbits |= get_bit(scalars[num], i) << 1;\\r\\nbits |= get_bit(scalars[num], i - 1);\\r\\nec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\\r\\nselect_point(digit, 17, pre_comp[num], tmp);\\r\\nsmallfelem_neg(ftmp, tmp[1]);\\r\\ncopy_small_conditional(ftmp, tmp[1], (((limb) sign) - 1));\\r\\nfelem_contract(tmp[1], ftmp);\\r\\nif (!skip) {\\r\\npoint_add(nq[0], nq[1], nq[2],\\r\\nnq[0], nq[1], nq[2],\\r\\nmixed, tmp[0], tmp[1], tmp[2]);\\r\\n} else {\\r\\nsmallfelem_expand(nq[0], tmp[0]);\\r\\nsmallfelem_expand(nq[1], tmp[1]);\\r\\nsmallfelem_expand(nq[2], tmp[2]);\\r\\nskip = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nfelem_assign(x_out, nq[0]);\\r\\nfelem_assign(y_out, nq[1]);\\r\\nfelem_assign(z_out, nq[2]);\\r\\n}\\r\\nconst EC_METHOD *EC_GFp_nistp256_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nEC_FLAGS_DEFAULT_OCT,\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_nistp256_group_init,\\r\\nec_GFp_simple_group_finish,\\r\\nec_GFp_simple_group_clear_finish,\\r\\nec_GFp_nist_group_copy,\\r\\nec_GFp_nistp256_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\nec_GFp_nistp256_point_get_affine_coordinates,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\nec_GFp_nistp256_points_mul,\\r\\nec_GFp_nistp256_precompute_mult,\\r\\nec_GFp_nistp256_have_precompute_mult,\\r\\nec_GFp_nist_field_mul,\\r\\nec_GFp_nist_field_sqr,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\n0\\r\\n};\\r\\nreturn &ret;\\r\\n}\\r\\nstatic NISTP256_PRE_COMP *nistp256_pre_comp_new()\\r\\n{\\r\\nNISTP256_PRE_COMP *ret = NULL;\\r\\nret = (NISTP256_PRE_COMP *) OPENSSL_malloc(sizeof *ret);\\r\\nif (!ret) {\\r\\nECerr(EC_F_NISTP256_PRE_COMP_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn ret;\\r\\n}\\r\\nmemset(ret->g_pre_comp, 0, sizeof(ret->g_pre_comp));\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nstatic void *nistp256_pre_comp_dup(void *src_)\\r\\n{\\r\\nNISTP256_PRE_COMP *src = src_;\\r\\nCRYPTO_add(&src->references, 1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nreturn src_;\\r\\n}\\r\\nstatic void nistp256_pre_comp_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nNISTP256_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nstatic void nistp256_pre_comp_clear_free(void *pre_)\\r\\n{\\r\\nint i;\\r\\nNISTP256_PRE_COMP *pre = pre_;\\r\\nif (!pre)\\r\\nreturn;\\r\\ni = CRYPTO_add(&pre->references, -1, CRYPTO_LOCK_EC_PRE_COMP);\\r\\nif (i > 0)\\r\\nreturn;\\r\\nOPENSSL_cleanse(pre, sizeof *pre);\\r\\nOPENSSL_free(pre);\\r\\n}\\r\\nint ec_GFp_nistp256_group_init(EC_GROUP *group)\\r\\n{\\r\\nint ret;\\r\\nret = ec_GFp_simple_group_init(group);\\r\\ngroup->a_is_minus3 = 1;\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp256_group_set_curve(EC_GROUP *group, const BIGNUM *p,\\r\\nconst BIGNUM *a, const BIGNUM *b,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *curve_p, *curve_a, *curve_b;\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (((curve_p = BN_CTX_get(ctx)) == NULL) ||\\r\\n((curve_a = BN_CTX_get(ctx)) == NULL) ||\\r\\n((curve_b = BN_CTX_get(ctx)) == NULL))\\r\\ngoto err;\\r\\nBN_bin2bn(nistp256_curve_params[0], sizeof(felem_bytearray), curve_p);\\r\\nBN_bin2bn(nistp256_curve_params[1], sizeof(felem_bytearray), curve_a);\\r\\nBN_bin2bn(nistp256_curve_params[2], sizeof(felem_bytearray), curve_b);\\r\\nif ((BN_cmp(curve_p, p)) || (BN_cmp(curve_a, a)) || (BN_cmp(curve_b, b))) {\\r\\nECerr(EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE,\\r\\nEC_R_WRONG_CURVE_PARAMETERS);\\r\\ngoto err;\\r\\n}\\r\\ngroup->field_mod_func = BN_nist_mod_256;\\r\\nret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp256_point_get_affine_coordinates(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\nBIGNUM *x, BIGNUM *y,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nfelem z1, z2, x_in, y_in;\\r\\nsmallfelem x_out, y_out;\\r\\nlongfelem tmp;\\r\\nif (EC_POINT_is_at_infinity(group, point)) {\\r\\nECerr(EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES,\\r\\nEC_R_POINT_AT_INFINITY);\\r\\nreturn 0;\\r\\n}\\r\\nif ((!BN_to_felem(x_in, &point->X)) || (!BN_to_felem(y_in, &point->Y)) ||\\r\\n(!BN_to_felem(z1, &point->Z)))\\r\\nreturn 0;\\r\\nfelem_inv(z2, z1);\\r\\nfelem_square(tmp, z2);\\r\\nfelem_reduce(z1, tmp);\\r\\nfelem_mul(tmp, x_in, z1);\\r\\nfelem_reduce(x_in, tmp);\\r\\nfelem_contract(x_out, x_in);\\r\\nif (x != NULL) {\\r\\nif (!smallfelem_to_BN(x, x_out)) {\\r\\nECerr(EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES,\\r\\nERR_R_BN_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nfelem_mul(tmp, z1, z2);\\r\\nfelem_reduce(z1, tmp);\\r\\nfelem_mul(tmp, y_in, z1);\\r\\nfelem_reduce(y_in, tmp);\\r\\nfelem_contract(y_out, y_in);\\r\\nif (y != NULL) {\\r\\nif (!smallfelem_to_BN(y, y_out)) {\\r\\nECerr(EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES,\\r\\nERR_R_BN_LIB);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void make_points_affine(size_t num, smallfelem points[][3],\\r\\nsmallfelem tmp_smallfelems[])\\r\\n{\\r\\nec_GFp_nistp_points_make_affine_internal(num,\\r\\npoints,\\r\\nsizeof(smallfelem),\\r\\ntmp_smallfelems,\\r\\n(void (*)(void *))smallfelem_one,\\r\\n(int (*)(const void *))\\r\\nsmallfelem_is_zero_int,\\r\\n(void (*)(void *, const void *))\\r\\nsmallfelem_assign,\\r\\n(void (*)(void *, const void *))\\r\\nsmallfelem_square_contract,\\r\\n(void (*)\\r\\n(void *, const void *,\\r\\nconst void *))\\r\\nsmallfelem_mul_contract,\\r\\n(void (*)(void *, const void *))\\r\\nsmallfelem_inv_contract,\\r\\n(void (*)(void *, const void *))\\r\\nsmallfelem_assign);\\r\\n}\\r\\nint ec_GFp_nistp256_points_mul(const EC_GROUP *group, EC_POINT *r,\\r\\nconst BIGNUM *scalar, size_t num,\\r\\nconst EC_POINT *points[],\\r\\nconst BIGNUM *scalars[], BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nint j;\\r\\nint mixed = 0;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y, *z, *tmp_scalar;\\r\\nfelem_bytearray g_secret;\\r\\nfelem_bytearray *secrets = NULL;\\r\\nsmallfelem(*pre_comp)[17][3] = NULL;\\r\\nsmallfelem *tmp_smallfelems = NULL;\\r\\nfelem_bytearray tmp;\\r\\nunsigned i, num_bytes;\\r\\nint have_pre_comp = 0;\\r\\nsize_t num_points = num;\\r\\nsmallfelem x_in, y_in, z_in;\\r\\nfelem x_out, y_out, z_out;\\r\\nNISTP256_PRE_COMP *pre = NULL;\\r\\nconst smallfelem(*g_pre_comp)[16][3] = NULL;\\r\\nEC_POINT *generator = NULL;\\r\\nconst EC_POINT *p = NULL;\\r\\nconst BIGNUM *p_scalar = NULL;\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (((x = BN_CTX_get(ctx)) == NULL) ||\\r\\n((y = BN_CTX_get(ctx)) == NULL) ||\\r\\n((z = BN_CTX_get(ctx)) == NULL) ||\\r\\n((tmp_scalar = BN_CTX_get(ctx)) == NULL))\\r\\ngoto err;\\r\\nif (scalar != NULL) {\\r\\npre = EC_EX_DATA_get_data(group->extra_data,\\r\\nnistp256_pre_comp_dup,\\r\\nnistp256_pre_comp_free,\\r\\nnistp256_pre_comp_clear_free);\\r\\nif (pre)\\r\\ng_pre_comp = (const smallfelem(*)[16][3])pre->g_pre_comp;\\r\\nelse\\r\\ng_pre_comp = &gmul[0];\\r\\ngenerator = EC_POINT_new(group);\\r\\nif (generator == NULL)\\r\\ngoto err;\\r\\nif (!smallfelem_to_BN(x, g_pre_comp[0][1][0]) ||\\r\\n!smallfelem_to_BN(y, g_pre_comp[0][1][1]) ||\\r\\n!smallfelem_to_BN(z, g_pre_comp[0][1][2])) {\\r\\nECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_set_Jprojective_coordinates_GFp(group,\\r\\ngenerator, x, y, z,\\r\\nctx))\\r\\ngoto err;\\r\\nif (0 == EC_POINT_cmp(group, generator, group->generator, ctx))\\r\\nhave_pre_comp = 1;\\r\\nelse\\r\\nnum_points++;\\r\\n}\\r\\nif (num_points > 0) {\\r\\nif (num_points >= 3) {\\r\\nmixed = 1;\\r\\n}\\r\\nsecrets = OPENSSL_malloc(num_points * sizeof(felem_bytearray));\\r\\npre_comp = OPENSSL_malloc(num_points * 17 * 3 * sizeof(smallfelem));\\r\\nif (mixed)\\r\\ntmp_smallfelems =\\r\\nOPENSSL_malloc((num_points * 17 + 1) * sizeof(smallfelem));\\r\\nif ((secrets == NULL) || (pre_comp == NULL)\\r\\n|| (mixed && (tmp_smallfelems == NULL))) {\\r\\nECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nmemset(secrets, 0, num_points * sizeof(felem_bytearray));\\r\\nmemset(pre_comp, 0, num_points * 17 * 3 * sizeof(smallfelem));\\r\\nfor (i = 0; i < num_points; ++i) {\\r\\nif (i == num)\\r\\n{\\r\\np = EC_GROUP_get0_generator(group);\\r\\np_scalar = scalar;\\r\\n} else\\r\\n{\\r\\np = points[i];\\r\\np_scalar = scalars[i];\\r\\n}\\r\\nif ((p_scalar != NULL) && (p != NULL)) {\\r\\nif ((BN_num_bits(p_scalar) > 256)\\r\\n|| (BN_is_negative(p_scalar))) {\\r\\nif (!BN_nnmod(tmp_scalar, p_scalar, &group->order, ctx)) {\\r\\nECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nnum_bytes = BN_bn2bin(tmp_scalar, tmp);\\r\\n} else\\r\\nnum_bytes = BN_bn2bin(p_scalar, tmp);\\r\\nflip_endian(secrets[i], tmp, num_bytes);\\r\\nif ((!BN_to_felem(x_out, &p->X)) ||\\r\\n(!BN_to_felem(y_out, &p->Y)) ||\\r\\n(!BN_to_felem(z_out, &p->Z)))\\r\\ngoto err;\\r\\nfelem_shrink(pre_comp[i][1][0], x_out);\\r\\nfelem_shrink(pre_comp[i][1][1], y_out);\\r\\nfelem_shrink(pre_comp[i][1][2], z_out);\\r\\nfor (j = 2; j <= 16; ++j) {\\r\\nif (j & 1) {\\r\\npoint_add_small(pre_comp[i][j][0], pre_comp[i][j][1],\\r\\npre_comp[i][j][2], pre_comp[i][1][0],\\r\\npre_comp[i][1][1], pre_comp[i][1][2],\\r\\npre_comp[i][j - 1][0],\\r\\npre_comp[i][j - 1][1],\\r\\npre_comp[i][j - 1][2]);\\r\\n} else {\\r\\npoint_double_small(pre_comp[i][j][0],\\r\\npre_comp[i][j][1],\\r\\npre_comp[i][j][2],\\r\\npre_comp[i][j / 2][0],\\r\\npre_comp[i][j / 2][1],\\r\\npre_comp[i][j / 2][2]);\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nif (mixed)\\r\\nmake_points_affine(num_points * 17, pre_comp[0], tmp_smallfelems);\\r\\n}\\r\\nif ((scalar != NULL) && (have_pre_comp)) {\\r\\nmemset(g_secret, 0, sizeof(g_secret));\\r\\nif ((BN_num_bits(scalar) > 256) || (BN_is_negative(scalar))) {\\r\\nif (!BN_nnmod(tmp_scalar, scalar, &group->order, ctx)) {\\r\\nECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nnum_bytes = BN_bn2bin(tmp_scalar, tmp);\\r\\n} else\\r\\nnum_bytes = BN_bn2bin(scalar, tmp);\\r\\nflip_endian(g_secret, tmp, num_bytes);\\r\\nbatch_mul(x_out, y_out, z_out,\\r\\n(const felem_bytearray(*))secrets, num_points,\\r\\ng_secret,\\r\\nmixed, (const smallfelem(*)[17][3])pre_comp, g_pre_comp);\\r\\n} else\\r\\nbatch_mul(x_out, y_out, z_out,\\r\\n(const felem_bytearray(*))secrets, num_points,\\r\\nNULL, mixed, (const smallfelem(*)[17][3])pre_comp, NULL);\\r\\nfelem_contract(x_in, x_out);\\r\\nfelem_contract(y_in, y_out);\\r\\nfelem_contract(z_in, z_out);\\r\\nif ((!smallfelem_to_BN(x, x_in)) || (!smallfelem_to_BN(y, y_in)) ||\\r\\n(!smallfelem_to_BN(z, z_in))) {\\r\\nECerr(EC_F_EC_GFP_NISTP256_POINTS_MUL, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nret = EC_POINT_set_Jprojective_coordinates_GFp(group, r, x, y, z, ctx);\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (generator != NULL)\\r\\nEC_POINT_free(generator);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (secrets != NULL)\\r\\nOPENSSL_free(secrets);\\r\\nif (pre_comp != NULL)\\r\\nOPENSSL_free(pre_comp);\\r\\nif (tmp_smallfelems != NULL)\\r\\nOPENSSL_free(tmp_smallfelems);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp256_precompute_mult(EC_GROUP *group, BN_CTX *ctx)\\r\\n{\\r\\nint ret = 0;\\r\\nNISTP256_PRE_COMP *pre = NULL;\\r\\nint i, j;\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBIGNUM *x, *y;\\r\\nEC_POINT *generator = NULL;\\r\\nsmallfelem tmp_smallfelems[32];\\r\\nfelem x_tmp, y_tmp, z_tmp;\\r\\nEC_EX_DATA_free_data(&group->extra_data, nistp256_pre_comp_dup,\\r\\nnistp256_pre_comp_free,\\r\\nnistp256_pre_comp_clear_free);\\r\\nif (ctx == NULL)\\r\\nif ((ctx = new_ctx = BN_CTX_new()) == NULL)\\r\\nreturn 0;\\r\\nBN_CTX_start(ctx);\\r\\nif (((x = BN_CTX_get(ctx)) == NULL) || ((y = BN_CTX_get(ctx)) == NULL))\\r\\ngoto err;\\r\\nif (group->generator == NULL)\\r\\ngoto err;\\r\\ngenerator = EC_POINT_new(group);\\r\\nif (generator == NULL)\\r\\ngoto err;\\r\\nBN_bin2bn(nistp256_curve_params[3], sizeof(felem_bytearray), x);\\r\\nBN_bin2bn(nistp256_curve_params[4], sizeof(felem_bytearray), y);\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, generator, x, y, ctx))\\r\\ngoto err;\\r\\nif ((pre = nistp256_pre_comp_new()) == NULL)\\r\\ngoto err;\\r\\nif (0 == EC_POINT_cmp(group, generator, group->generator, ctx)) {\\r\\nmemcpy(pre->g_pre_comp, gmul, sizeof(pre->g_pre_comp));\\r\\nret = 1;\\r\\ngoto err;\\r\\n}\\r\\nif ((!BN_to_felem(x_tmp, &group->generator->X)) ||\\r\\n(!BN_to_felem(y_tmp, &group->generator->Y)) ||\\r\\n(!BN_to_felem(z_tmp, &group->generator->Z)))\\r\\ngoto err;\\r\\nfelem_shrink(pre->g_pre_comp[0][1][0], x_tmp);\\r\\nfelem_shrink(pre->g_pre_comp[0][1][1], y_tmp);\\r\\nfelem_shrink(pre->g_pre_comp[0][1][2], z_tmp);\\r\\nfor (i = 1; i <= 8; i <<= 1) {\\r\\npoint_double_small(pre->g_pre_comp[1][i][0], pre->g_pre_comp[1][i][1],\\r\\npre->g_pre_comp[1][i][2], pre->g_pre_comp[0][i][0],\\r\\npre->g_pre_comp[0][i][1],\\r\\npre->g_pre_comp[0][i][2]);\\r\\nfor (j = 0; j < 31; ++j) {\\r\\npoint_double_small(pre->g_pre_comp[1][i][0],\\r\\npre->g_pre_comp[1][i][1],\\r\\npre->g_pre_comp[1][i][2],\\r\\npre->g_pre_comp[1][i][0],\\r\\npre->g_pre_comp[1][i][1],\\r\\npre->g_pre_comp[1][i][2]);\\r\\n}\\r\\nif (i == 8)\\r\\nbreak;\\r\\npoint_double_small(pre->g_pre_comp[0][2 * i][0],\\r\\npre->g_pre_comp[0][2 * i][1],\\r\\npre->g_pre_comp[0][2 * i][2],\\r\\npre->g_pre_comp[1][i][0], pre->g_pre_comp[1][i][1],\\r\\npre->g_pre_comp[1][i][2]);\\r\\nfor (j = 0; j < 31; ++j) {\\r\\npoint_double_small(pre->g_pre_comp[0][2 * i][0],\\r\\npre->g_pre_comp[0][2 * i][1],\\r\\npre->g_pre_comp[0][2 * i][2],\\r\\npre->g_pre_comp[0][2 * i][0],\\r\\npre->g_pre_comp[0][2 * i][1],\\r\\npre->g_pre_comp[0][2 * i][2]);\\r\\n}\\r\\n}\\r\\nfor (i = 0; i < 2; i++) {\\r\\nmemset(pre->g_pre_comp[i][0], 0, sizeof(pre->g_pre_comp[i][0]));\\r\\npoint_add_small(pre->g_pre_comp[i][6][0], pre->g_pre_comp[i][6][1],\\r\\npre->g_pre_comp[i][6][2], pre->g_pre_comp[i][4][0],\\r\\npre->g_pre_comp[i][4][1], pre->g_pre_comp[i][4][2],\\r\\npre->g_pre_comp[i][2][0], pre->g_pre_comp[i][2][1],\\r\\npre->g_pre_comp[i][2][2]);\\r\\npoint_add_small(pre->g_pre_comp[i][10][0], pre->g_pre_comp[i][10][1],\\r\\npre->g_pre_comp[i][10][2], pre->g_pre_comp[i][8][0],\\r\\npre->g_pre_comp[i][8][1], pre->g_pre_comp[i][8][2],\\r\\npre->g_pre_comp[i][2][0], pre->g_pre_comp[i][2][1],\\r\\npre->g_pre_comp[i][2][2]);\\r\\npoint_add_small(pre->g_pre_comp[i][12][0], pre->g_pre_comp[i][12][1],\\r\\npre->g_pre_comp[i][12][2], pre->g_pre_comp[i][8][0],\\r\\npre->g_pre_comp[i][8][1], pre->g_pre_comp[i][8][2],\\r\\npre->g_pre_comp[i][4][0], pre->g_pre_comp[i][4][1],\\r\\npre->g_pre_comp[i][4][2]);\\r\\npoint_add_small(pre->g_pre_comp[i][14][0], pre->g_pre_comp[i][14][1],\\r\\npre->g_pre_comp[i][14][2], pre->g_pre_comp[i][12][0],\\r\\npre->g_pre_comp[i][12][1], pre->g_pre_comp[i][12][2],\\r\\npre->g_pre_comp[i][2][0], pre->g_pre_comp[i][2][1],\\r\\npre->g_pre_comp[i][2][2]);\\r\\nfor (j = 1; j < 8; ++j) {\\r\\npoint_add_small(pre->g_pre_comp[i][2 * j + 1][0],\\r\\npre->g_pre_comp[i][2 * j + 1][1],\\r\\npre->g_pre_comp[i][2 * j + 1][2],\\r\\npre->g_pre_comp[i][2 * j][0],\\r\\npre->g_pre_comp[i][2 * j][1],\\r\\npre->g_pre_comp[i][2 * j][2],\\r\\npre->g_pre_comp[i][1][0],\\r\\npre->g_pre_comp[i][1][1],\\r\\npre->g_pre_comp[i][1][2]);\\r\\n}\\r\\n}\\r\\nmake_points_affine(31, &(pre->g_pre_comp[0][1]), tmp_smallfelems);\\r\\nif (!EC_EX_DATA_set_data(&group->extra_data, pre, nistp256_pre_comp_dup,\\r\\nnistp256_pre_comp_free,\\r\\nnistp256_pre_comp_clear_free))\\r\\ngoto err;\\r\\nret = 1;\\r\\npre = NULL;\\r\\nerr:\\r\\nBN_CTX_end(ctx);\\r\\nif (generator != NULL)\\r\\nEC_POINT_free(generator);\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (pre)\\r\\nnistp256_pre_comp_free(pre);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_nistp256_have_precompute_mult(const EC_GROUP *group)\\r\\n{\\r\\nif (EC_EX_DATA_get_data(group->extra_data, nistp256_pre_comp_dup,\\r\\nnistp256_pre_comp_free,\\r\\nnistp256_pre_comp_clear_free)\\r\\n!= NULL)\\r\\nreturn 1;\\r\\nelse\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_asn_pack_c", "target": 0, "func": "void *ASN1_unpack_string(ASN1_STRING *oct, d2i_of_void *d2i)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nchar *ret;\\r\\np = oct->data;\\r\\nif (!(ret = d2i(NULL, &p, oct->length)))\\r\\nASN1err(ASN1_F_ASN1_UNPACK_STRING, ASN1_R_DECODE_ERROR);\\r\\nreturn ret;\\r\\n}\\r\\nASN1_STRING *ASN1_pack_string(void *obj, i2d_of_void *i2d, ASN1_STRING **oct)\\r\\n{\\r\\nunsigned char *p;\\r\\nASN1_STRING *octmp;\\r\\nif (!oct || !*oct) {\\r\\nif (!(octmp = ASN1_STRING_new())) {\\r\\nASN1err(ASN1_F_ASN1_PACK_STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (oct)\\r\\n*oct = octmp;\\r\\n} else\\r\\noctmp = *oct;\\r\\nif (!(octmp->length = i2d(obj, NULL))) {\\r\\nASN1err(ASN1_F_ASN1_PACK_STRING, ASN1_R_ENCODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!(p = OPENSSL_malloc(octmp->length))) {\\r\\nASN1err(ASN1_F_ASN1_PACK_STRING, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\noctmp->data = p;\\r\\ni2d(obj, &p);\\r\\nreturn octmp;\\r\\nerr:\\r\\nif (!oct || !*oct) {\\r\\nASN1_STRING_free(octmp);\\r\\nif (oct)\\r\\n*oct = NULL;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it, ASN1_STRING **oct)\\r\\n{\\r\\nASN1_STRING *octmp;\\r\\nif (!oct || !*oct) {\\r\\nif (!(octmp = ASN1_STRING_new())) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_PACK, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (oct)\\r\\n*oct = octmp;\\r\\n} else\\r\\noctmp = *oct;\\r\\nif (octmp->data) {\\r\\nOPENSSL_free(octmp->data);\\r\\noctmp->data = NULL;\\r\\n}\\r\\nif (!(octmp->length = ASN1_item_i2d(obj, &octmp->data, it))) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_PACK, ASN1_R_ENCODE_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!octmp->data) {\\r\\nASN1err(ASN1_F_ASN1_ITEM_PACK, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn octmp;\\r\\n}\\r\\nvoid *ASN1_item_unpack(ASN1_STRING *oct, const ASN1_ITEM *it)\\r\\n{\\r\\nconst unsigned char *p;\\r\\nvoid *ret;\\r\\np = oct->data;\\r\\nif (!(ret = ASN1_item_d2i(NULL, &p, oct->length, it)))\\r\\nASN1err(ASN1_F_ASN1_ITEM_UNPACK, ASN1_R_DECODE_ERROR);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_sess_id_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nSSL_SESSION *x = NULL;\\r\\nX509 *peer = NULL;\\r\\nint ret = 1, i, num, badops = 0;\\r\\nBIO *out = NULL;\\r\\nint informat, outformat;\\r\\nchar *infile = NULL, *outfile = NULL, *context = NULL;\\r\\nint cert = 0, noout = 0, text = 0;\\r\\nconst char **pp;\\r\\napps_startup();\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\ninformat = FORMAT_PEM;\\r\\noutformat = FORMAT_PEM;\\r\\nargc--;\\r\\nargv++;\\r\\nnum = 0;\\r\\nwhile (argc >= 1) {\\r\\nif (strcmp(*argv, \"-inform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-outform\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutformat = str2fmt(*(++argv));\\r\\n} else if (strcmp(*argv, \"-in\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ninfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-text\") == 0)\\r\\ntext = ++num;\\r\\nelse if (strcmp(*argv, \"-cert\") == 0)\\r\\ncert = ++num;\\r\\nelse if (strcmp(*argv, \"-noout\") == 0)\\r\\nnoout = ++num;\\r\\nelse if (strcmp(*argv, \"-context\") == 0) {\\r\\nif (--argc < 1)\\r\\ngoto bad;\\r\\ncontext = *++argv;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"unknown option %s\\n\", *argv);\\r\\nbadops = 1;\\r\\nbreak;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (badops) {\\r\\nbad:\\r\\nfor (pp = sess_id_usage; (*pp != NULL); pp++)\\r\\nBIO_printf(bio_err, \"%s\", *pp);\\r\\ngoto end;\\r\\n}\\r\\nERR_load_crypto_strings();\\r\\nx = load_sess_id(infile, informat);\\r\\nif (x == NULL) {\\r\\ngoto end;\\r\\n}\\r\\npeer = SSL_SESSION_get0_peer(x);\\r\\nif (context) {\\r\\nsize_t ctx_len = strlen(context);\\r\\nif (ctx_len > SSL_MAX_SID_CTX_LENGTH) {\\r\\nBIO_printf(bio_err, \"Context too long\\n\");\\r\\ngoto end;\\r\\n}\\r\\nSSL_SESSION_set1_id_context(x, (unsigned char *)context, ctx_len);\\r\\n}\\r\\n#ifdef undef\\r\\n{\\r\\nSSL_SESSION *s;\\r\\nchar buf[1024 * 10], *p;\\r\\nint i;\\r\\ns = SSL_SESSION_new();\\r\\np = &buf;\\r\\ni = i2d_SSL_SESSION(x, &p);\\r\\np = &buf;\\r\\nd2i_SSL_SESSION(&s, &p, (long)i);\\r\\np = &buf;\\r\\nd2i_SSL_SESSION(&s, &p, (long)i);\\r\\np = &buf;\\r\\nd2i_SSL_SESSION(&s, &p, (long)i);\\r\\nSSL_SESSION_free(s);\\r\\n}\\r\\n#endif\\r\\nif (!noout || text) {\\r\\nout = BIO_new(BIO_s_file());\\r\\nif (out == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (outfile == NULL) {\\r\\nBIO_set_fp(out, stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n} else {\\r\\nif (BIO_write_filename(out, outfile) <= 0) {\\r\\nperror(outfile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (text) {\\r\\nSSL_SESSION_print(out, x);\\r\\nif (cert) {\\r\\nif (peer == NULL)\\r\\nBIO_puts(out, \"No certificate present\\n\");\\r\\nelse\\r\\nX509_print(out, peer);\\r\\n}\\r\\n}\\r\\nif (!noout && !cert) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = i2d_SSL_SESSION_bio(out, x);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_SSL_SESSION(out, x);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write SSL_SESSION\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else if (!noout && (peer != NULL)) {\\r\\nif (outformat == FORMAT_ASN1)\\r\\ni = (int)i2d_X509_bio(out, peer);\\r\\nelse if (outformat == FORMAT_PEM)\\r\\ni = PEM_write_bio_X509(out, peer);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad output format specified for outfile\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!i) {\\r\\nBIO_printf(bio_err, \"unable to write X509\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nret = 0;\\r\\nend:\\r\\nif (out != NULL)\\r\\nBIO_free_all(out);\\r\\nif (x != NULL)\\r\\nSSL_SESSION_free(x);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic SSL_SESSION *load_sess_id(char *infile, int format)\\r\\n{\\r\\nSSL_SESSION *x = NULL;\\r\\nBIO *in = NULL;\\r\\nin = BIO_new(BIO_s_file());\\r\\nif (in == NULL) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile == NULL)\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nelse {\\r\\nif (BIO_read_filename(in, infile) <= 0) {\\r\\nperror(infile);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (format == FORMAT_ASN1)\\r\\nx = d2i_SSL_SESSION_bio(in, NULL);\\r\\nelse if (format == FORMAT_PEM)\\r\\nx = PEM_read_bio_SSL_SESSION(in, NULL, NULL, NULL);\\r\\nelse {\\r\\nBIO_printf(bio_err, \"bad input format specified for input crl\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (x == NULL) {\\r\\nBIO_printf(bio_err, \"unable to load SSL_SESSION\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nend:\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nreturn (x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_rc4_c", "target": 0, "func": "const EVP_CIPHER *EVP_rc4(void)\\r\\n{\\r\\nreturn (&r4_cipher);\\r\\n}\\r\\nconst EVP_CIPHER *EVP_rc4_40(void)\\r\\n{\\r\\nreturn (&r4_40_cipher);\\r\\n}\\r\\nstatic int rc4_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nRC4_set_key(&data(ctx)->ks, EVP_CIPHER_CTX_key_length(ctx), key);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rc4_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t inl)\\r\\n{\\r\\nRC4(&data(ctx)->ks, inl, in, out);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ccm128_c", "target": 0, "func": "void CRYPTO_ccm128_init(CCM128_CONTEXT *ctx,\\r\\nunsigned int M, unsigned int L, void *key,\\r\\nblock128_f block)\\r\\n{\\r\\nmemset(ctx->nonce.c, 0, sizeof(ctx->nonce.c));\\r\\nctx->nonce.c[0] = ((u8)(L - 1) & 7) | (u8)(((M - 2) / 2) & 7) << 3;\\r\\nctx->blocks = 0;\\r\\nctx->block = block;\\r\\nctx->key = key;\\r\\n}\\r\\nint CRYPTO_ccm128_setiv(CCM128_CONTEXT *ctx,\\r\\nconst unsigned char *nonce, size_t nlen, size_t mlen)\\r\\n{\\r\\nunsigned int L = ctx->nonce.c[0] & 7;\\r\\nif (nlen < (14 - L))\\r\\nreturn -1;\\r\\nif (sizeof(mlen) == 8 && L >= 3) {\\r\\nctx->nonce.c[8] = (u8)(mlen >> (56 % (sizeof(mlen) * 8)));\\r\\nctx->nonce.c[9] = (u8)(mlen >> (48 % (sizeof(mlen) * 8)));\\r\\nctx->nonce.c[10] = (u8)(mlen >> (40 % (sizeof(mlen) * 8)));\\r\\nctx->nonce.c[11] = (u8)(mlen >> (32 % (sizeof(mlen) * 8)));\\r\\n} else\\r\\nctx->nonce.u[1] = 0;\\r\\nctx->nonce.c[12] = (u8)(mlen >> 24);\\r\\nctx->nonce.c[13] = (u8)(mlen >> 16);\\r\\nctx->nonce.c[14] = (u8)(mlen >> 8);\\r\\nctx->nonce.c[15] = (u8)mlen;\\r\\nctx->nonce.c[0] &= ~0x40;\\r\\nmemcpy(&ctx->nonce.c[1], nonce, 14 - L);\\r\\nreturn 0;\\r\\n}\\r\\nvoid CRYPTO_ccm128_aad(CCM128_CONTEXT *ctx,\\r\\nconst unsigned char *aad, size_t alen)\\r\\n{\\r\\nunsigned int i;\\r\\nblock128_f block = ctx->block;\\r\\nif (alen == 0)\\r\\nreturn;\\r\\nctx->nonce.c[0] |= 0x40;\\r\\n(*block) (ctx->nonce.c, ctx->cmac.c, ctx->key), ctx->blocks++;\\r\\nif (alen < (0x10000 - 0x100)) {\\r\\nctx->cmac.c[0] ^= (u8)(alen >> 8);\\r\\nctx->cmac.c[1] ^= (u8)alen;\\r\\ni = 2;\\r\\n} else if (sizeof(alen) == 8\\r\\n&& alen >= (size_t)1 << (32 % (sizeof(alen) * 8))) {\\r\\nctx->cmac.c[0] ^= 0xFF;\\r\\nctx->cmac.c[1] ^= 0xFF;\\r\\nctx->cmac.c[2] ^= (u8)(alen >> (56 % (sizeof(alen) * 8)));\\r\\nctx->cmac.c[3] ^= (u8)(alen >> (48 % (sizeof(alen) * 8)));\\r\\nctx->cmac.c[4] ^= (u8)(alen >> (40 % (sizeof(alen) * 8)));\\r\\nctx->cmac.c[5] ^= (u8)(alen >> (32 % (sizeof(alen) * 8)));\\r\\nctx->cmac.c[6] ^= (u8)(alen >> 24);\\r\\nctx->cmac.c[7] ^= (u8)(alen >> 16);\\r\\nctx->cmac.c[8] ^= (u8)(alen >> 8);\\r\\nctx->cmac.c[9] ^= (u8)alen;\\r\\ni = 10;\\r\\n} else {\\r\\nctx->cmac.c[0] ^= 0xFF;\\r\\nctx->cmac.c[1] ^= 0xFE;\\r\\nctx->cmac.c[2] ^= (u8)(alen >> 24);\\r\\nctx->cmac.c[3] ^= (u8)(alen >> 16);\\r\\nctx->cmac.c[4] ^= (u8)(alen >> 8);\\r\\nctx->cmac.c[5] ^= (u8)alen;\\r\\ni = 6;\\r\\n}\\r\\ndo {\\r\\nfor (; i < 16 && alen; ++i, ++aad, --alen)\\r\\nctx->cmac.c[i] ^= *aad;\\r\\n(*block) (ctx->cmac.c, ctx->cmac.c, ctx->key), ctx->blocks++;\\r\\ni = 0;\\r\\n} while (alen);\\r\\n}\\r\\nstatic void ctr64_inc(unsigned char *counter)\\r\\n{\\r\\nunsigned int n = 8;\\r\\nu8 c;\\r\\ncounter += 8;\\r\\ndo {\\r\\n--n;\\r\\nc = counter[n];\\r\\n++c;\\r\\ncounter[n] = c;\\r\\nif (c)\\r\\nreturn;\\r\\n} while (n);\\r\\n}\\r\\nint CRYPTO_ccm128_encrypt(CCM128_CONTEXT *ctx,\\r\\nconst unsigned char *inp, unsigned char *out,\\r\\nsize_t len)\\r\\n{\\r\\nsize_t n;\\r\\nunsigned int i, L;\\r\\nunsigned char flags0 = ctx->nonce.c[0];\\r\\nblock128_f block = ctx->block;\\r\\nvoid *key = ctx->key;\\r\\nunion {\\r\\nu64 u[2];\\r\\nu8 c[16];\\r\\n} scratch;\\r\\nif (!(flags0 & 0x40))\\r\\n(*block) (ctx->nonce.c, ctx->cmac.c, key), ctx->blocks++;\\r\\nctx->nonce.c[0] = L = flags0 & 7;\\r\\nfor (n = 0, i = 15 - L; i < 15; ++i) {\\r\\nn |= ctx->nonce.c[i];\\r\\nctx->nonce.c[i] = 0;\\r\\nn <<= 8;\\r\\n}\\r\\nn |= ctx->nonce.c[15];\\r\\nctx->nonce.c[15] = 1;\\r\\nif (n != len)\\r\\nreturn -1;\\r\\nctx->blocks += ((len + 15) >> 3) | 1;\\r\\nif (ctx->blocks > (U64(1) << 61))\\r\\nreturn -2;\\r\\nwhile (len >= 16) {\\r\\n#if defined(STRICT_ALIGNMENT)\\r\\nunion {\\r\\nu64 u[2];\\r\\nu8 c[16];\\r\\n} temp;\\r\\nmemcpy(temp.c, inp, 16);\\r\\nctx->cmac.u[0] ^= temp.u[0];\\r\\nctx->cmac.u[1] ^= temp.u[1];\\r\\n#else\\r\\nctx->cmac.u[0] ^= ((u64 *)inp)[0];\\r\\nctx->cmac.u[1] ^= ((u64 *)inp)[1];\\r\\n#endif\\r\\n(*block) (ctx->cmac.c, ctx->cmac.c, key);\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nctr64_inc(ctx->nonce.c);\\r\\n#if defined(STRICT_ALIGNMENT)\\r\\ntemp.u[0] ^= scratch.u[0];\\r\\ntemp.u[1] ^= scratch.u[1];\\r\\nmemcpy(out, temp.c, 16);\\r\\n#else\\r\\n((u64 *)out)[0] = scratch.u[0] ^ ((u64 *)inp)[0];\\r\\n((u64 *)out)[1] = scratch.u[1] ^ ((u64 *)inp)[1];\\r\\n#endif\\r\\ninp += 16;\\r\\nout += 16;\\r\\nlen -= 16;\\r\\n}\\r\\nif (len) {\\r\\nfor (i = 0; i < len; ++i)\\r\\nctx->cmac.c[i] ^= inp[i];\\r\\n(*block) (ctx->cmac.c, ctx->cmac.c, key);\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nfor (i = 0; i < len; ++i)\\r\\nout[i] = scratch.c[i] ^ inp[i];\\r\\n}\\r\\nfor (i = 15 - L; i < 16; ++i)\\r\\nctx->nonce.c[i] = 0;\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nctx->cmac.u[0] ^= scratch.u[0];\\r\\nctx->cmac.u[1] ^= scratch.u[1];\\r\\nctx->nonce.c[0] = flags0;\\r\\nreturn 0;\\r\\n}\\r\\nint CRYPTO_ccm128_decrypt(CCM128_CONTEXT *ctx,\\r\\nconst unsigned char *inp, unsigned char *out,\\r\\nsize_t len)\\r\\n{\\r\\nsize_t n;\\r\\nunsigned int i, L;\\r\\nunsigned char flags0 = ctx->nonce.c[0];\\r\\nblock128_f block = ctx->block;\\r\\nvoid *key = ctx->key;\\r\\nunion {\\r\\nu64 u[2];\\r\\nu8 c[16];\\r\\n} scratch;\\r\\nif (!(flags0 & 0x40))\\r\\n(*block) (ctx->nonce.c, ctx->cmac.c, key);\\r\\nctx->nonce.c[0] = L = flags0 & 7;\\r\\nfor (n = 0, i = 15 - L; i < 15; ++i) {\\r\\nn |= ctx->nonce.c[i];\\r\\nctx->nonce.c[i] = 0;\\r\\nn <<= 8;\\r\\n}\\r\\nn |= ctx->nonce.c[15];\\r\\nctx->nonce.c[15] = 1;\\r\\nif (n != len)\\r\\nreturn -1;\\r\\nwhile (len >= 16) {\\r\\n#if defined(STRICT_ALIGNMENT)\\r\\nunion {\\r\\nu64 u[2];\\r\\nu8 c[16];\\r\\n} temp;\\r\\n#endif\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nctr64_inc(ctx->nonce.c);\\r\\n#if defined(STRICT_ALIGNMENT)\\r\\nmemcpy(temp.c, inp, 16);\\r\\nctx->cmac.u[0] ^= (scratch.u[0] ^= temp.u[0]);\\r\\nctx->cmac.u[1] ^= (scratch.u[1] ^= temp.u[1]);\\r\\nmemcpy(out, scratch.c, 16);\\r\\n#else\\r\\nctx->cmac.u[0] ^= (((u64 *)out)[0] = scratch.u[0] ^ ((u64 *)inp)[0]);\\r\\nctx->cmac.u[1] ^= (((u64 *)out)[1] = scratch.u[1] ^ ((u64 *)inp)[1]);\\r\\n#endif\\r\\n(*block) (ctx->cmac.c, ctx->cmac.c, key);\\r\\ninp += 16;\\r\\nout += 16;\\r\\nlen -= 16;\\r\\n}\\r\\nif (len) {\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nfor (i = 0; i < len; ++i)\\r\\nctx->cmac.c[i] ^= (out[i] = scratch.c[i] ^ inp[i]);\\r\\n(*block) (ctx->cmac.c, ctx->cmac.c, key);\\r\\n}\\r\\nfor (i = 15 - L; i < 16; ++i)\\r\\nctx->nonce.c[i] = 0;\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nctx->cmac.u[0] ^= scratch.u[0];\\r\\nctx->cmac.u[1] ^= scratch.u[1];\\r\\nctx->nonce.c[0] = flags0;\\r\\nreturn 0;\\r\\n}\\r\\nstatic void ctr64_add(unsigned char *counter, size_t inc)\\r\\n{\\r\\nsize_t n = 8, val = 0;\\r\\ncounter += 8;\\r\\ndo {\\r\\n--n;\\r\\nval += counter[n] + (inc & 0xff);\\r\\ncounter[n] = (unsigned char)val;\\r\\nval >>= 8;\\r\\ninc >>= 8;\\r\\n} while (n && (inc || val));\\r\\n}\\r\\nint CRYPTO_ccm128_encrypt_ccm64(CCM128_CONTEXT *ctx,\\r\\nconst unsigned char *inp, unsigned char *out,\\r\\nsize_t len, ccm128_f stream)\\r\\n{\\r\\nsize_t n;\\r\\nunsigned int i, L;\\r\\nunsigned char flags0 = ctx->nonce.c[0];\\r\\nblock128_f block = ctx->block;\\r\\nvoid *key = ctx->key;\\r\\nunion {\\r\\nu64 u[2];\\r\\nu8 c[16];\\r\\n} scratch;\\r\\nif (!(flags0 & 0x40))\\r\\n(*block) (ctx->nonce.c, ctx->cmac.c, key), ctx->blocks++;\\r\\nctx->nonce.c[0] = L = flags0 & 7;\\r\\nfor (n = 0, i = 15 - L; i < 15; ++i) {\\r\\nn |= ctx->nonce.c[i];\\r\\nctx->nonce.c[i] = 0;\\r\\nn <<= 8;\\r\\n}\\r\\nn |= ctx->nonce.c[15];\\r\\nctx->nonce.c[15] = 1;\\r\\nif (n != len)\\r\\nreturn -1;\\r\\nctx->blocks += ((len + 15) >> 3) | 1;\\r\\nif (ctx->blocks > (U64(1) << 61))\\r\\nreturn -2;\\r\\nif ((n = len / 16)) {\\r\\n(*stream) (inp, out, n, key, ctx->nonce.c, ctx->cmac.c);\\r\\nn *= 16;\\r\\ninp += n;\\r\\nout += n;\\r\\nlen -= n;\\r\\nif (len)\\r\\nctr64_add(ctx->nonce.c, n / 16);\\r\\n}\\r\\nif (len) {\\r\\nfor (i = 0; i < len; ++i)\\r\\nctx->cmac.c[i] ^= inp[i];\\r\\n(*block) (ctx->cmac.c, ctx->cmac.c, key);\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nfor (i = 0; i < len; ++i)\\r\\nout[i] = scratch.c[i] ^ inp[i];\\r\\n}\\r\\nfor (i = 15 - L; i < 16; ++i)\\r\\nctx->nonce.c[i] = 0;\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nctx->cmac.u[0] ^= scratch.u[0];\\r\\nctx->cmac.u[1] ^= scratch.u[1];\\r\\nctx->nonce.c[0] = flags0;\\r\\nreturn 0;\\r\\n}\\r\\nint CRYPTO_ccm128_decrypt_ccm64(CCM128_CONTEXT *ctx,\\r\\nconst unsigned char *inp, unsigned char *out,\\r\\nsize_t len, ccm128_f stream)\\r\\n{\\r\\nsize_t n;\\r\\nunsigned int i, L;\\r\\nunsigned char flags0 = ctx->nonce.c[0];\\r\\nblock128_f block = ctx->block;\\r\\nvoid *key = ctx->key;\\r\\nunion {\\r\\nu64 u[2];\\r\\nu8 c[16];\\r\\n} scratch;\\r\\nif (!(flags0 & 0x40))\\r\\n(*block) (ctx->nonce.c, ctx->cmac.c, key);\\r\\nctx->nonce.c[0] = L = flags0 & 7;\\r\\nfor (n = 0, i = 15 - L; i < 15; ++i) {\\r\\nn |= ctx->nonce.c[i];\\r\\nctx->nonce.c[i] = 0;\\r\\nn <<= 8;\\r\\n}\\r\\nn |= ctx->nonce.c[15];\\r\\nctx->nonce.c[15] = 1;\\r\\nif (n != len)\\r\\nreturn -1;\\r\\nif ((n = len / 16)) {\\r\\n(*stream) (inp, out, n, key, ctx->nonce.c, ctx->cmac.c);\\r\\nn *= 16;\\r\\ninp += n;\\r\\nout += n;\\r\\nlen -= n;\\r\\nif (len)\\r\\nctr64_add(ctx->nonce.c, n / 16);\\r\\n}\\r\\nif (len) {\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nfor (i = 0; i < len; ++i)\\r\\nctx->cmac.c[i] ^= (out[i] = scratch.c[i] ^ inp[i]);\\r\\n(*block) (ctx->cmac.c, ctx->cmac.c, key);\\r\\n}\\r\\nfor (i = 15 - L; i < 16; ++i)\\r\\nctx->nonce.c[i] = 0;\\r\\n(*block) (ctx->nonce.c, scratch.c, key);\\r\\nctx->cmac.u[0] ^= scratch.u[0];\\r\\nctx->cmac.u[1] ^= scratch.u[1];\\r\\nctx->nonce.c[0] = flags0;\\r\\nreturn 0;\\r\\n}\\r\\nsize_t CRYPTO_ccm128_tag(CCM128_CONTEXT *ctx, unsigned char *tag, size_t len)\\r\\n{\\r\\nunsigned int M = (ctx->nonce.c[0] >> 3) & 7;\\r\\nM *= 2;\\r\\nM += 2;\\r\\nif (len < M)\\r\\nreturn 0;\\r\\nmemcpy(tag, ctx->cmac.c, M);\\r\\nreturn M;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_pem_err_c", "target": 0, "func": "void ERR_load_PEM_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(PEM_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, PEM_str_functs);\\r\\nERR_load_strings(0, PEM_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_depr_c", "target": 0, "func": "DH *DH_generate_parameters(int prime_len, int generator,\\r\\nvoid (*callback) (int, int, void *), void *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nDH *ret = NULL;\\r\\nif ((ret = DH_new()) == NULL)\\r\\nreturn NULL;\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nif (DH_generate_parameters_ex(ret, prime_len, generator, &cb))\\r\\nreturn ret;\\r\\nDH_free(ret);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ecp_mont_c", "target": 0, "func": "const EC_METHOD *EC_GFp_mont_method(void)\\r\\n{\\r\\nstatic const EC_METHOD ret = {\\r\\nEC_FLAGS_DEFAULT_OCT,\\r\\nNID_X9_62_prime_field,\\r\\nec_GFp_mont_group_init,\\r\\nec_GFp_mont_group_finish,\\r\\nec_GFp_mont_group_clear_finish,\\r\\nec_GFp_mont_group_copy,\\r\\nec_GFp_mont_group_set_curve,\\r\\nec_GFp_simple_group_get_curve,\\r\\nec_GFp_simple_group_get_degree,\\r\\nec_GFp_simple_group_check_discriminant,\\r\\nec_GFp_simple_point_init,\\r\\nec_GFp_simple_point_finish,\\r\\nec_GFp_simple_point_clear_finish,\\r\\nec_GFp_simple_point_copy,\\r\\nec_GFp_simple_point_set_to_infinity,\\r\\nec_GFp_simple_set_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_get_Jprojective_coordinates_GFp,\\r\\nec_GFp_simple_point_set_affine_coordinates,\\r\\nec_GFp_simple_point_get_affine_coordinates,\\r\\n0, 0, 0,\\r\\nec_GFp_simple_add,\\r\\nec_GFp_simple_dbl,\\r\\nec_GFp_simple_invert,\\r\\nec_GFp_simple_is_at_infinity,\\r\\nec_GFp_simple_is_on_curve,\\r\\nec_GFp_simple_cmp,\\r\\nec_GFp_simple_make_affine,\\r\\nec_GFp_simple_points_make_affine,\\r\\n0 ,\\r\\n0 ,\\r\\n0 ,\\r\\nec_GFp_mont_field_mul,\\r\\nec_GFp_mont_field_sqr,\\r\\n0 ,\\r\\nec_GFp_mont_field_encode,\\r\\nec_GFp_mont_field_decode,\\r\\nec_GFp_mont_field_set_to_one\\r\\n};\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn fips_ec_gfp_mont_method();\\r\\n#endif\\r\\nreturn &ret;\\r\\n}\\r\\nint ec_GFp_mont_group_init(EC_GROUP *group)\\r\\n{\\r\\nint ok;\\r\\nok = ec_GFp_simple_group_init(group);\\r\\ngroup->field_data1 = NULL;\\r\\ngroup->field_data2 = NULL;\\r\\nreturn ok;\\r\\n}\\r\\nvoid ec_GFp_mont_group_finish(EC_GROUP *group)\\r\\n{\\r\\nif (group->field_data1 != NULL) {\\r\\nBN_MONT_CTX_free(group->field_data1);\\r\\ngroup->field_data1 = NULL;\\r\\n}\\r\\nif (group->field_data2 != NULL) {\\r\\nBN_free(group->field_data2);\\r\\ngroup->field_data2 = NULL;\\r\\n}\\r\\nec_GFp_simple_group_finish(group);\\r\\n}\\r\\nvoid ec_GFp_mont_group_clear_finish(EC_GROUP *group)\\r\\n{\\r\\nif (group->field_data1 != NULL) {\\r\\nBN_MONT_CTX_free(group->field_data1);\\r\\ngroup->field_data1 = NULL;\\r\\n}\\r\\nif (group->field_data2 != NULL) {\\r\\nBN_clear_free(group->field_data2);\\r\\ngroup->field_data2 = NULL;\\r\\n}\\r\\nec_GFp_simple_group_clear_finish(group);\\r\\n}\\r\\nint ec_GFp_mont_group_copy(EC_GROUP *dest, const EC_GROUP *src)\\r\\n{\\r\\nif (dest->field_data1 != NULL) {\\r\\nBN_MONT_CTX_free(dest->field_data1);\\r\\ndest->field_data1 = NULL;\\r\\n}\\r\\nif (dest->field_data2 != NULL) {\\r\\nBN_clear_free(dest->field_data2);\\r\\ndest->field_data2 = NULL;\\r\\n}\\r\\nif (!ec_GFp_simple_group_copy(dest, src))\\r\\nreturn 0;\\r\\nif (src->field_data1 != NULL) {\\r\\ndest->field_data1 = BN_MONT_CTX_new();\\r\\nif (dest->field_data1 == NULL)\\r\\nreturn 0;\\r\\nif (!BN_MONT_CTX_copy(dest->field_data1, src->field_data1))\\r\\ngoto err;\\r\\n}\\r\\nif (src->field_data2 != NULL) {\\r\\ndest->field_data2 = BN_dup(src->field_data2);\\r\\nif (dest->field_data2 == NULL)\\r\\ngoto err;\\r\\n}\\r\\nreturn 1;\\r\\nerr:\\r\\nif (dest->field_data1 != NULL) {\\r\\nBN_MONT_CTX_free(dest->field_data1);\\r\\ndest->field_data1 = NULL;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint ec_GFp_mont_group_set_curve(EC_GROUP *group, const BIGNUM *p,\\r\\nconst BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nBN_CTX *new_ctx = NULL;\\r\\nBN_MONT_CTX *mont = NULL;\\r\\nBIGNUM *one = NULL;\\r\\nint ret = 0;\\r\\nif (group->field_data1 != NULL) {\\r\\nBN_MONT_CTX_free(group->field_data1);\\r\\ngroup->field_data1 = NULL;\\r\\n}\\r\\nif (group->field_data2 != NULL) {\\r\\nBN_free(group->field_data2);\\r\\ngroup->field_data2 = NULL;\\r\\n}\\r\\nif (ctx == NULL) {\\r\\nctx = new_ctx = BN_CTX_new();\\r\\nif (ctx == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nmont = BN_MONT_CTX_new();\\r\\nif (mont == NULL)\\r\\ngoto err;\\r\\nif (!BN_MONT_CTX_set(mont, p, ctx)) {\\r\\nECerr(EC_F_EC_GFP_MONT_GROUP_SET_CURVE, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\none = BN_new();\\r\\nif (one == NULL)\\r\\ngoto err;\\r\\nif (!BN_to_montgomery(one, BN_value_one(), mont, ctx))\\r\\ngoto err;\\r\\ngroup->field_data1 = mont;\\r\\nmont = NULL;\\r\\ngroup->field_data2 = one;\\r\\none = NULL;\\r\\nret = ec_GFp_simple_group_set_curve(group, p, a, b, ctx);\\r\\nif (!ret) {\\r\\nBN_MONT_CTX_free(group->field_data1);\\r\\ngroup->field_data1 = NULL;\\r\\nBN_free(group->field_data2);\\r\\ngroup->field_data2 = NULL;\\r\\n}\\r\\nerr:\\r\\nif (new_ctx != NULL)\\r\\nBN_CTX_free(new_ctx);\\r\\nif (mont != NULL)\\r\\nBN_MONT_CTX_free(mont);\\r\\nreturn ret;\\r\\n}\\r\\nint ec_GFp_mont_field_mul(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,\\r\\nconst BIGNUM *b, BN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data1 == NULL) {\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_MUL, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn BN_mod_mul_montgomery(r, a, b, group->field_data1, ctx);\\r\\n}\\r\\nint ec_GFp_mont_field_sqr(const EC_GROUP *group, BIGNUM *r, const BIGNUM *a,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data1 == NULL) {\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_SQR, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn BN_mod_mul_montgomery(r, a, a, group->field_data1, ctx);\\r\\n}\\r\\nint ec_GFp_mont_field_encode(const EC_GROUP *group, BIGNUM *r,\\r\\nconst BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data1 == NULL) {\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_ENCODE, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn BN_to_montgomery(r, a, (BN_MONT_CTX *)group->field_data1, ctx);\\r\\n}\\r\\nint ec_GFp_mont_field_decode(const EC_GROUP *group, BIGNUM *r,\\r\\nconst BIGNUM *a, BN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data1 == NULL) {\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_DECODE, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nreturn BN_from_montgomery(r, a, group->field_data1, ctx);\\r\\n}\\r\\nint ec_GFp_mont_field_set_to_one(const EC_GROUP *group, BIGNUM *r,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nif (group->field_data2 == NULL) {\\r\\nECerr(EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE, EC_R_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nif (!BN_copy(r, group->field_data2))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dgst_c", "target": 0, "func": "static void list_md_fn(const EVP_MD *m,\\r\\nconst char *from, const char *to, void *arg)\\r\\n{\\r\\nconst char *mname;\\r\\nif (!m)\\r\\nreturn;\\r\\nmname = OBJ_nid2ln(EVP_MD_type(m));\\r\\nif (strcmp(from, mname))\\r\\nreturn;\\r\\nif (EVP_MD_flags(m) & EVP_MD_FLAG_PKEY_DIGEST)\\r\\nreturn;\\r\\nif (strchr(mname, ' '))\\r\\nmname = EVP_MD_name(m);\\r\\nBIO_printf(arg, \"-%-14s to use the %s message digest algorithm\\n\",\\r\\nmname, mname);\\r\\n}\\r\\nint MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL, *impl = NULL;\\r\\nunsigned char *buf = NULL;\\r\\nint i, err = 1;\\r\\nconst EVP_MD *md = NULL, *m;\\r\\nBIO *in = NULL, *inp;\\r\\nBIO *bmd = NULL;\\r\\nBIO *out = NULL;\\r\\n#define PROG_NAME_SIZE 39\\r\\nchar pname[PROG_NAME_SIZE + 1];\\r\\nint separator = 0;\\r\\nint debug = 0;\\r\\nint keyform = FORMAT_PEM;\\r\\nconst char *outfile = NULL, *keyfile = NULL;\\r\\nconst char *sigfile = NULL, *randfile = NULL;\\r\\nint out_bin = -1, want_pub = 0, do_verify = 0;\\r\\nEVP_PKEY *sigkey = NULL;\\r\\nunsigned char *sigbuf = NULL;\\r\\nint siglen = 0;\\r\\nchar *passargin = NULL, *passin = NULL;\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\nint engine_impl = 0;\\r\\n#endif\\r\\nchar *hmac_key = NULL;\\r\\nchar *mac_name = NULL;\\r\\nint non_fips_allow = 0;\\r\\nSTACK_OF(OPENSSL_STRING) *sigopts = NULL, *macopts = NULL;\\r\\napps_startup();\\r\\nif ((buf = (unsigned char *)OPENSSL_malloc(BUFSIZE)) == NULL) {\\r\\nBIO_printf(bio_err, \"out of memory\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (bio_err == NULL)\\r\\nif ((bio_err = BIO_new(BIO_s_file())) != NULL)\\r\\nBIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nprogram_name(argv[0], pname, sizeof pname);\\r\\nmd = EVP_get_digestbyname(pname);\\r\\nargc--;\\r\\nargv++;\\r\\nwhile (argc > 0) {\\r\\nif ((*argv)[0] != '-')\\r\\nbreak;\\r\\nif (strcmp(*argv, \"-c\") == 0)\\r\\nseparator = 1;\\r\\nelse if (strcmp(*argv, \"-r\") == 0)\\r\\nseparator = 2;\\r\\nelse if (strcmp(*argv, \"-rand\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nrandfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-out\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\noutfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-sign\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nkeyfile = *(++argv);\\r\\n} else if (!strcmp(*argv, \"-passin\")) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\npassargin = *++argv;\\r\\n} else if (strcmp(*argv, \"-verify\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nkeyfile = *(++argv);\\r\\nwant_pub = 1;\\r\\ndo_verify = 1;\\r\\n} else if (strcmp(*argv, \"-prverify\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nkeyfile = *(++argv);\\r\\ndo_verify = 1;\\r\\n} else if (strcmp(*argv, \"-signature\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nsigfile = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keyform\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nkeyform = str2fmt(*(++argv));\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nelse if (strcmp(*argv, \"-engine\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nengine = *(++argv);\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n} else if (strcmp(*argv, \"-engine_impl\") == 0)\\r\\nengine_impl = 1;\\r\\n#endif\\r\\nelse if (strcmp(*argv, \"-hex\") == 0)\\r\\nout_bin = 0;\\r\\nelse if (strcmp(*argv, \"-binary\") == 0)\\r\\nout_bin = 1;\\r\\nelse if (strcmp(*argv, \"-d\") == 0)\\r\\ndebug = 1;\\r\\nelse if (!strcmp(*argv, \"-fips-fingerprint\"))\\r\\nhmac_key = \"etaonrishdlcupfm\";\\r\\nelse if (strcmp(*argv, \"-non-fips-allow\") == 0)\\r\\nnon_fips_allow = 1;\\r\\nelse if (!strcmp(*argv, \"-hmac\")) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nhmac_key = *++argv;\\r\\n} else if (!strcmp(*argv, \"-mac\")) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nmac_name = *++argv;\\r\\n} else if (strcmp(*argv, \"-sigopt\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nif (!sigopts)\\r\\nsigopts = sk_OPENSSL_STRING_new_null();\\r\\nif (!sigopts || !sk_OPENSSL_STRING_push(sigopts, *(++argv)))\\r\\nbreak;\\r\\n} else if (strcmp(*argv, \"-macopt\") == 0) {\\r\\nif (--argc < 1)\\r\\nbreak;\\r\\nif (!macopts)\\r\\nmacopts = sk_OPENSSL_STRING_new_null();\\r\\nif (!macopts || !sk_OPENSSL_STRING_push(macopts, *(++argv)))\\r\\nbreak;\\r\\n} else if ((m = EVP_get_digestbyname(&((*argv)[1]))) != NULL)\\r\\nmd = m;\\r\\nelse\\r\\nbreak;\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (do_verify && !sigfile) {\\r\\nBIO_printf(bio_err,\\r\\n\"No signature to verify: use the -signature option\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((argc > 0) && (argv[0][0] == '-')) {\\r\\nBIO_printf(bio_err, \"unknown option '%s'\\n\", *argv);\\r\\nBIO_printf(bio_err, \"options are\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-c to output the digest with separating colons\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-r to output the digest in coreutils format\\n\");\\r\\nBIO_printf(bio_err, \"-d to output debug info\\n\");\\r\\nBIO_printf(bio_err, \"-hex output as hex dump\\n\");\\r\\nBIO_printf(bio_err, \"-binary output in binary form\\n\");\\r\\nBIO_printf(bio_err, \"-hmac arg set the HMAC key to arg\\n\");\\r\\nBIO_printf(bio_err, \"-non-fips-allow allow use of non FIPS digest\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-sign file sign digest using private key in file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-verify file verify a signature using public key in file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-prverify file verify a signature using private key in file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-keyform arg key file format (PEM or ENGINE)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-out filename output to filename rather than stdout\\n\");\\r\\nBIO_printf(bio_err, \"-signature file signature to verify\\n\");\\r\\nBIO_printf(bio_err, \"-sigopt nm:v signature parameter\\n\");\\r\\nBIO_printf(bio_err, \"-hmac key create hashed MAC with key\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-mac algorithm create MAC (not neccessarily HMAC)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-macopt nm:v MAC algorithm parameters or key\\n\");\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\n#endif\\r\\nEVP_MD_do_all_sorted(list_md_fn, bio_err);\\r\\ngoto end;\\r\\n}\\r\\n#ifndef OPENSSL_NO_ENGINE\\r\\nif (engine_impl)\\r\\nimpl = e;\\r\\n#endif\\r\\nin = BIO_new(BIO_s_file());\\r\\nbmd = BIO_new(BIO_f_md());\\r\\nif (debug) {\\r\\nBIO_set_callback(in, BIO_debug_callback);\\r\\nBIO_set_callback_arg(in, (char *)bio_err);\\r\\n}\\r\\nif (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif ((in == NULL) || (bmd == NULL)) {\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (out_bin == -1) {\\r\\nif (keyfile)\\r\\nout_bin = 1;\\r\\nelse\\r\\nout_bin = 0;\\r\\n}\\r\\nif (randfile)\\r\\napp_RAND_load_file(randfile, bio_err, 0);\\r\\nif (outfile) {\\r\\nif (out_bin)\\r\\nout = BIO_new_file(outfile, \"wb\");\\r\\nelse\\r\\nout = BIO_new_file(outfile, \"w\");\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n#ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n#endif\\r\\n}\\r\\nif (!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file %s\\n\",\\r\\noutfile ? outfile : \"(stdout)\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif ((! !mac_name + ! !keyfile + ! !hmac_key) > 1) {\\r\\nBIO_printf(bio_err, \"MAC and Signing key cannot both be specified\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (keyfile) {\\r\\nif (want_pub)\\r\\nsigkey = load_pubkey(bio_err, keyfile, keyform, 0, NULL,\\r\\ne, \"key file\");\\r\\nelse\\r\\nsigkey = load_key(bio_err, keyfile, keyform, 0, passin,\\r\\ne, \"key file\");\\r\\nif (!sigkey) {\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (mac_name) {\\r\\nEVP_PKEY_CTX *mac_ctx = NULL;\\r\\nint r = 0;\\r\\nif (!init_gen_str(bio_err, &mac_ctx, mac_name, impl, 0))\\r\\ngoto mac_end;\\r\\nif (macopts) {\\r\\nchar *macopt;\\r\\nfor (i = 0; i < sk_OPENSSL_STRING_num(macopts); i++) {\\r\\nmacopt = sk_OPENSSL_STRING_value(macopts, i);\\r\\nif (pkey_ctrl_string(mac_ctx, macopt) <= 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"MAC parameter error \\\"%s\\\"\\n\", macopt);\\r\\nERR_print_errors(bio_err);\\r\\ngoto mac_end;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (EVP_PKEY_keygen(mac_ctx, &sigkey) <= 0) {\\r\\nBIO_puts(bio_err, \"Error generating key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto mac_end;\\r\\n}\\r\\nr = 1;\\r\\nmac_end:\\r\\nif (mac_ctx)\\r\\nEVP_PKEY_CTX_free(mac_ctx);\\r\\nif (r == 0)\\r\\ngoto end;\\r\\n}\\r\\nif (non_fips_allow) {\\r\\nEVP_MD_CTX *md_ctx;\\r\\nBIO_get_md_ctx(bmd, &md_ctx);\\r\\nEVP_MD_CTX_set_flags(md_ctx, EVP_MD_CTX_FLAG_NON_FIPS_ALLOW);\\r\\n}\\r\\nif (hmac_key) {\\r\\nsigkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, impl,\\r\\n(unsigned char *)hmac_key, -1);\\r\\nif (!sigkey)\\r\\ngoto end;\\r\\n}\\r\\nif (sigkey) {\\r\\nEVP_MD_CTX *mctx = NULL;\\r\\nEVP_PKEY_CTX *pctx = NULL;\\r\\nint r;\\r\\nif (!BIO_get_md_ctx(bmd, &mctx)) {\\r\\nBIO_printf(bio_err, \"Error getting context\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (do_verify)\\r\\nr = EVP_DigestVerifyInit(mctx, &pctx, md, impl, sigkey);\\r\\nelse\\r\\nr = EVP_DigestSignInit(mctx, &pctx, md, impl, sigkey);\\r\\nif (!r) {\\r\\nBIO_printf(bio_err, \"Error setting context\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (sigopts) {\\r\\nchar *sigopt;\\r\\nfor (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++) {\\r\\nsigopt = sk_OPENSSL_STRING_value(sigopts, i);\\r\\nif (pkey_ctrl_string(pctx, sigopt) <= 0) {\\r\\nBIO_printf(bio_err, \"parameter error \\\"%s\\\"\\n\", sigopt);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nelse {\\r\\nEVP_MD_CTX *mctx = NULL;\\r\\nif (!BIO_get_md_ctx(bmd, &mctx)) {\\r\\nBIO_printf(bio_err, \"Error getting context\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (md == NULL)\\r\\nmd = EVP_md5();\\r\\nif (!EVP_DigestInit_ex(mctx, md, impl)) {\\r\\nBIO_printf(bio_err, \"Error setting digest %s\\n\", pname);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (sigfile && sigkey) {\\r\\nBIO *sigbio;\\r\\nsigbio = BIO_new_file(sigfile, \"rb\");\\r\\nsiglen = EVP_PKEY_size(sigkey);\\r\\nsigbuf = OPENSSL_malloc(siglen);\\r\\nif (!sigbio) {\\r\\nBIO_printf(bio_err, \"Error opening signature file %s\\n\", sigfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nsiglen = BIO_read(sigbio, sigbuf, siglen);\\r\\nBIO_free(sigbio);\\r\\nif (siglen <= 0) {\\r\\nBIO_printf(bio_err, \"Error reading signature file %s\\n\", sigfile);\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\ninp = BIO_push(bmd, in);\\r\\nif (md == NULL) {\\r\\nEVP_MD_CTX *tctx;\\r\\nBIO_get_md_ctx(bmd, &tctx);\\r\\nmd = EVP_MD_CTX_md(tctx);\\r\\n}\\r\\nif (argc == 0) {\\r\\nBIO_set_fp(in, stdin, BIO_NOCLOSE);\\r\\nerr = do_fp(out, buf, inp, separator, out_bin, sigkey, sigbuf,\\r\\nsiglen, NULL, NULL, \"stdin\", bmd);\\r\\n} else {\\r\\nconst char *md_name = NULL, *sig_name = NULL;\\r\\nif (!out_bin) {\\r\\nif (sigkey) {\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nameth = EVP_PKEY_get0_asn1(sigkey);\\r\\nif (ameth)\\r\\nEVP_PKEY_asn1_get0_info(NULL, NULL,\\r\\nNULL, NULL, &sig_name, ameth);\\r\\n}\\r\\nif (md)\\r\\nmd_name = EVP_MD_name(md);\\r\\n}\\r\\nerr = 0;\\r\\nfor (i = 0; i < argc; i++) {\\r\\nint r;\\r\\nif (BIO_read_filename(in, argv[i]) <= 0) {\\r\\nperror(argv[i]);\\r\\nerr++;\\r\\ncontinue;\\r\\n} else\\r\\nr = do_fp(out, buf, inp, separator, out_bin, sigkey, sigbuf,\\r\\nsiglen, sig_name, md_name, argv[i], bmd);\\r\\nif (r)\\r\\nerr = r;\\r\\n(void)BIO_reset(bmd);\\r\\n}\\r\\n}\\r\\nend:\\r\\nif (buf != NULL) {\\r\\nOPENSSL_cleanse(buf, BUFSIZE);\\r\\nOPENSSL_free(buf);\\r\\n}\\r\\nif (in != NULL)\\r\\nBIO_free(in);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nBIO_free_all(out);\\r\\nEVP_PKEY_free(sigkey);\\r\\nif (sigopts)\\r\\nsk_OPENSSL_STRING_free(sigopts);\\r\\nif (macopts)\\r\\nsk_OPENSSL_STRING_free(macopts);\\r\\nif (sigbuf)\\r\\nOPENSSL_free(sigbuf);\\r\\nif (bmd != NULL)\\r\\nBIO_free(bmd);\\r\\napps_shutdown();\\r\\nOPENSSL_EXIT(err);\\r\\n}\\r\\nint do_fp(BIO *out, unsigned char *buf, BIO *bp, int sep, int binout,\\r\\nEVP_PKEY *key, unsigned char *sigin, int siglen,\\r\\nconst char *sig_name, const char *md_name,\\r\\nconst char *file, BIO *bmd)\\r\\n{\\r\\nsize_t len;\\r\\nint i;\\r\\nfor (;;) {\\r\\ni = BIO_read(bp, (char *)buf, BUFSIZE);\\r\\nif (i < 0) {\\r\\nBIO_printf(bio_err, \"Read Error in %s\\n\", file);\\r\\nERR_print_errors(bio_err);\\r\\nreturn 1;\\r\\n}\\r\\nif (i == 0)\\r\\nbreak;\\r\\n}\\r\\nif (sigin) {\\r\\nEVP_MD_CTX *ctx;\\r\\nBIO_get_md_ctx(bp, &ctx);\\r\\ni = EVP_DigestVerifyFinal(ctx, sigin, (unsigned int)siglen);\\r\\nif (i > 0)\\r\\nBIO_printf(out, \"Verified OK\\n\");\\r\\nelse if (i == 0) {\\r\\nBIO_printf(out, \"Verification Failure\\n\");\\r\\nreturn 1;\\r\\n} else {\\r\\nBIO_printf(bio_err, \"Error Verifying Data\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nif (key) {\\r\\nEVP_MD_CTX *ctx;\\r\\nBIO_get_md_ctx(bp, &ctx);\\r\\nlen = BUFSIZE;\\r\\nif (!EVP_DigestSignFinal(ctx, buf, &len)) {\\r\\nBIO_printf(bio_err, \"Error Signing Data\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn 1;\\r\\n}\\r\\n} else {\\r\\nlen = BIO_gets(bp, (char *)buf, BUFSIZE);\\r\\nif ((int)len < 0) {\\r\\nERR_print_errors(bio_err);\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nif (binout)\\r\\nBIO_write(out, buf, len);\\r\\nelse if (sep == 2) {\\r\\nfor (i = 0; i < (int)len; i++)\\r\\nBIO_printf(out, \"%02x\", buf[i]);\\r\\nBIO_printf(out, \" *%s\\n\", file);\\r\\n} else {\\r\\nif (sig_name) {\\r\\nBIO_puts(out, sig_name);\\r\\nif (md_name)\\r\\nBIO_printf(out, \"-%s\", md_name);\\r\\nBIO_printf(out, \"(%s)= \", file);\\r\\n} else if (md_name)\\r\\nBIO_printf(out, \"%s(%s)= \", md_name, file);\\r\\nelse\\r\\nBIO_printf(out, \"(%s)= \", file);\\r\\nfor (i = 0; i < (int)len; i++) {\\r\\nif (sep && (i != 0))\\r\\nBIO_printf(out, \":\");\\r\\nBIO_printf(out, \"%02x\", buf[i]);\\r\\n}\\r\\nBIO_printf(out, \"\\n\");\\r\\n}\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_pmeth_c", "target": 0, "func": "static int pkey_rsa_init(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nRSA_PKEY_CTX *rctx;\\r\\nrctx = OPENSSL_malloc(sizeof(RSA_PKEY_CTX));\\r\\nif (!rctx)\\r\\nreturn 0;\\r\\nrctx->nbits = 1024;\\r\\nrctx->pub_exp = NULL;\\r\\nrctx->pad_mode = RSA_PKCS1_PADDING;\\r\\nrctx->md = NULL;\\r\\nrctx->mgf1md = NULL;\\r\\nrctx->tbuf = NULL;\\r\\nrctx->saltlen = -2;\\r\\nrctx->oaep_label = NULL;\\r\\nrctx->oaep_labellen = 0;\\r\\nctx->data = rctx;\\r\\nctx->keygen_info = rctx->gentmp;\\r\\nctx->keygen_info_count = 2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_rsa_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)\\r\\n{\\r\\nRSA_PKEY_CTX *dctx, *sctx;\\r\\nif (!pkey_rsa_init(dst))\\r\\nreturn 0;\\r\\nsctx = src->data;\\r\\ndctx = dst->data;\\r\\ndctx->nbits = sctx->nbits;\\r\\nif (sctx->pub_exp) {\\r\\ndctx->pub_exp = BN_dup(sctx->pub_exp);\\r\\nif (!dctx->pub_exp)\\r\\nreturn 0;\\r\\n}\\r\\ndctx->pad_mode = sctx->pad_mode;\\r\\ndctx->md = sctx->md;\\r\\ndctx->mgf1md = sctx->mgf1md;\\r\\nif (sctx->oaep_label) {\\r\\nif (dctx->oaep_label)\\r\\nOPENSSL_free(dctx->oaep_label);\\r\\ndctx->oaep_label = BUF_memdup(sctx->oaep_label, sctx->oaep_labellen);\\r\\nif (!dctx->oaep_label)\\r\\nreturn 0;\\r\\ndctx->oaep_labellen = sctx->oaep_labellen;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int setup_tbuf(RSA_PKEY_CTX *ctx, EVP_PKEY_CTX *pk)\\r\\n{\\r\\nif (ctx->tbuf)\\r\\nreturn 1;\\r\\nctx->tbuf = OPENSSL_malloc(EVP_PKEY_size(pk->pkey));\\r\\nif (!ctx->tbuf)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void pkey_rsa_cleanup(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nRSA_PKEY_CTX *rctx = ctx->data;\\r\\nif (rctx) {\\r\\nif (rctx->pub_exp)\\r\\nBN_free(rctx->pub_exp);\\r\\nif (rctx->tbuf)\\r\\nOPENSSL_free(rctx->tbuf);\\r\\nif (rctx->oaep_label)\\r\\nOPENSSL_free(rctx->oaep_label);\\r\\nOPENSSL_free(rctx);\\r\\n}\\r\\n}\\r\\nstatic int pkey_fips_check_ctx(EVP_PKEY_CTX *ctx)\\r\\n{\\r\\nRSA_PKEY_CTX *rctx = ctx->data;\\r\\nRSA *rsa = ctx->pkey->pkey.rsa;\\r\\nint rv = -1;\\r\\nif (!FIPS_mode())\\r\\nreturn 0;\\r\\nif (rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)\\r\\nrv = 0;\\r\\nif (!(rsa->meth->flags & RSA_FLAG_FIPS_METHOD) && rv)\\r\\nreturn -1;\\r\\nif (rctx->md) {\\r\\nconst EVP_MD *fmd;\\r\\nfmd = FIPS_get_digestbynid(EVP_MD_type(rctx->md));\\r\\nif (!fmd || !(fmd->flags & EVP_MD_FLAG_FIPS))\\r\\nreturn rv;\\r\\n}\\r\\nif (rctx->mgf1md && !(rctx->mgf1md->flags & EVP_MD_FLAG_FIPS)) {\\r\\nconst EVP_MD *fmd;\\r\\nfmd = FIPS_get_digestbynid(EVP_MD_type(rctx->mgf1md));\\r\\nif (!fmd || !(fmd->flags & EVP_MD_FLAG_FIPS))\\r\\nreturn rv;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_rsa_sign(EVP_PKEY_CTX *ctx, unsigned char *sig,\\r\\nsize_t *siglen, const unsigned char *tbs,\\r\\nsize_t tbslen)\\r\\n{\\r\\nint ret;\\r\\nRSA_PKEY_CTX *rctx = ctx->data;\\r\\nRSA *rsa = ctx->pkey->pkey.rsa;\\r\\n#ifdef OPENSSL_FIPS\\r\\nret = pkey_fips_check_ctx(ctx);\\r\\nif (ret < 0) {\\r\\nRSAerr(RSA_F_PKEY_RSA_SIGN, RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);\\r\\nreturn -1;\\r\\n}\\r\\n#endif\\r\\nif (rctx->md) {\\r\\nif (tbslen != (size_t)EVP_MD_size(rctx->md)) {\\r\\nRSAerr(RSA_F_PKEY_RSA_SIGN, RSA_R_INVALID_DIGEST_LENGTH);\\r\\nreturn -1;\\r\\n}\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (ret > 0) {\\r\\nunsigned int slen;\\r\\nret = FIPS_rsa_sign_digest(rsa, tbs, tbslen, rctx->md,\\r\\nrctx->pad_mode,\\r\\nrctx->saltlen,\\r\\nrctx->mgf1md, sig, &slen);\\r\\nif (ret > 0)\\r\\n*siglen = slen;\\r\\nelse\\r\\n*siglen = 0;\\r\\nreturn ret;\\r\\n}\\r\\n#endif\\r\\nif (EVP_MD_type(rctx->md) == NID_mdc2) {\\r\\nunsigned int sltmp;\\r\\nif (rctx->pad_mode != RSA_PKCS1_PADDING)\\r\\nreturn -1;\\r\\nret = RSA_sign_ASN1_OCTET_STRING(NID_mdc2,\\r\\ntbs, tbslen, sig, &sltmp, rsa);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\nret = sltmp;\\r\\n} else if (rctx->pad_mode == RSA_X931_PADDING) {\\r\\nif (!setup_tbuf(rctx, ctx))\\r\\nreturn -1;\\r\\nmemcpy(rctx->tbuf, tbs, tbslen);\\r\\nrctx->tbuf[tbslen] = RSA_X931_hash_id(EVP_MD_type(rctx->md));\\r\\nret = RSA_private_encrypt(tbslen + 1, rctx->tbuf,\\r\\nsig, rsa, RSA_X931_PADDING);\\r\\n} else if (rctx->pad_mode == RSA_PKCS1_PADDING) {\\r\\nunsigned int sltmp;\\r\\nret = RSA_sign(EVP_MD_type(rctx->md),\\r\\ntbs, tbslen, sig, &sltmp, rsa);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\nret = sltmp;\\r\\n} else if (rctx->pad_mode == RSA_PKCS1_PSS_PADDING) {\\r\\nif (!setup_tbuf(rctx, ctx))\\r\\nreturn -1;\\r\\nif (!RSA_padding_add_PKCS1_PSS_mgf1(rsa,\\r\\nrctx->tbuf, tbs,\\r\\nrctx->md, rctx->mgf1md,\\r\\nrctx->saltlen))\\r\\nreturn -1;\\r\\nret = RSA_private_encrypt(RSA_size(rsa), rctx->tbuf,\\r\\nsig, rsa, RSA_NO_PADDING);\\r\\n} else\\r\\nreturn -1;\\r\\n} else\\r\\nret = RSA_private_encrypt(tbslen, tbs, sig, ctx->pkey->pkey.rsa,\\r\\nrctx->pad_mode);\\r\\nif (ret < 0)\\r\\nreturn ret;\\r\\n*siglen = ret;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_rsa_verifyrecover(EVP_PKEY_CTX *ctx,\\r\\nunsigned char *rout, size_t *routlen,\\r\\nconst unsigned char *sig, size_t siglen)\\r\\n{\\r\\nint ret;\\r\\nRSA_PKEY_CTX *rctx = ctx->data;\\r\\nif (rctx->md) {\\r\\nif (rctx->pad_mode == RSA_X931_PADDING) {\\r\\nif (!setup_tbuf(rctx, ctx))\\r\\nreturn -1;\\r\\nret = RSA_public_decrypt(siglen, sig,\\r\\nrctx->tbuf, ctx->pkey->pkey.rsa,\\r\\nRSA_X931_PADDING);\\r\\nif (ret < 1)\\r\\nreturn 0;\\r\\nret--;\\r\\nif (rctx->tbuf[ret] != RSA_X931_hash_id(EVP_MD_type(rctx->md))) {\\r\\nRSAerr(RSA_F_PKEY_RSA_VERIFYRECOVER,\\r\\nRSA_R_ALGORITHM_MISMATCH);\\r\\nreturn 0;\\r\\n}\\r\\nif (ret != EVP_MD_size(rctx->md)) {\\r\\nRSAerr(RSA_F_PKEY_RSA_VERIFYRECOVER,\\r\\nRSA_R_INVALID_DIGEST_LENGTH);\\r\\nreturn 0;\\r\\n}\\r\\nif (rout)\\r\\nmemcpy(rout, rctx->tbuf, ret);\\r\\n} else if (rctx->pad_mode == RSA_PKCS1_PADDING) {\\r\\nsize_t sltmp;\\r\\nret = int_rsa_verify(EVP_MD_type(rctx->md),\\r\\nNULL, 0, rout, &sltmp,\\r\\nsig, siglen, ctx->pkey->pkey.rsa);\\r\\nif (ret <= 0)\\r\\nreturn 0;\\r\\nret = sltmp;\\r\\n} else\\r\\nreturn -1;\\r\\n} else\\r\\nret = RSA_public_decrypt(siglen, sig, rout, ctx->pkey->pkey.rsa,\\r\\nrctx->pad_mode);\\r\\nif (ret < 0)\\r\\nreturn ret;\\r\\n*routlen = ret;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_rsa_verify(EVP_PKEY_CTX *ctx,\\r\\nconst unsigned char *sig, size_t siglen,\\r\\nconst unsigned char *tbs, size_t tbslen)\\r\\n{\\r\\nRSA_PKEY_CTX *rctx = ctx->data;\\r\\nRSA *rsa = ctx->pkey->pkey.rsa;\\r\\nsize_t rslen;\\r\\n#ifdef OPENSSL_FIPS\\r\\nint rv;\\r\\nrv = pkey_fips_check_ctx(ctx);\\r\\nif (rv < 0) {\\r\\nRSAerr(RSA_F_PKEY_RSA_VERIFY,\\r\\nRSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);\\r\\nreturn -1;\\r\\n}\\r\\n#endif\\r\\nif (rctx->md) {\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (rv > 0) {\\r\\nreturn FIPS_rsa_verify_digest(rsa,\\r\\ntbs, tbslen,\\r\\nrctx->md,\\r\\nrctx->pad_mode,\\r\\nrctx->saltlen,\\r\\nrctx->mgf1md, sig, siglen);\\r\\n}\\r\\n#endif\\r\\nif (rctx->pad_mode == RSA_PKCS1_PADDING)\\r\\nreturn RSA_verify(EVP_MD_type(rctx->md), tbs, tbslen,\\r\\nsig, siglen, rsa);\\r\\nif (rctx->pad_mode == RSA_X931_PADDING) {\\r\\nif (pkey_rsa_verifyrecover(ctx, NULL, &rslen, sig, siglen) <= 0)\\r\\nreturn 0;\\r\\n} else if (rctx->pad_mode == RSA_PKCS1_PSS_PADDING) {\\r\\nint ret;\\r\\nif (!setup_tbuf(rctx, ctx))\\r\\nreturn -1;\\r\\nret = RSA_public_decrypt(siglen, sig, rctx->tbuf,\\r\\nrsa, RSA_NO_PADDING);\\r\\nif (ret <= 0)\\r\\nreturn 0;\\r\\nret = RSA_verify_PKCS1_PSS_mgf1(rsa, tbs,\\r\\nrctx->md, rctx->mgf1md,\\r\\nrctx->tbuf, rctx->saltlen);\\r\\nif (ret <= 0)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n} else\\r\\nreturn -1;\\r\\n} else {\\r\\nif (!setup_tbuf(rctx, ctx))\\r\\nreturn -1;\\r\\nrslen = RSA_public_decrypt(siglen, sig, rctx->tbuf,\\r\\nrsa, rctx->pad_mode);\\r\\nif (rslen == 0)\\r\\nreturn 0;\\r\\n}\\r\\nif ((rslen != tbslen) || memcmp(tbs, rctx->tbuf, rslen))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_rsa_encrypt(EVP_PKEY_CTX *ctx,\\r\\nunsigned char *out, size_t *outlen,\\r\\nconst unsigned char *in, size_t inlen)\\r\\n{\\r\\nint ret;\\r\\nRSA_PKEY_CTX *rctx = ctx->data;\\r\\nif (rctx->pad_mode == RSA_PKCS1_OAEP_PADDING) {\\r\\nint klen = RSA_size(ctx->pkey->pkey.rsa);\\r\\nif (!setup_tbuf(rctx, ctx))\\r\\nreturn -1;\\r\\nif (!RSA_padding_add_PKCS1_OAEP_mgf1(rctx->tbuf, klen,\\r\\nin, inlen,\\r\\nrctx->oaep_label,\\r\\nrctx->oaep_labellen,\\r\\nrctx->md, rctx->mgf1md))\\r\\nreturn -1;\\r\\nret = RSA_public_encrypt(klen, rctx->tbuf, out,\\r\\nctx->pkey->pkey.rsa, RSA_NO_PADDING);\\r\\n} else\\r\\nret = RSA_public_encrypt(inlen, in, out, ctx->pkey->pkey.rsa,\\r\\nrctx->pad_mode);\\r\\nif (ret < 0)\\r\\nreturn ret;\\r\\n*outlen = ret;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_rsa_decrypt(EVP_PKEY_CTX *ctx,\\r\\nunsigned char *out, size_t *outlen,\\r\\nconst unsigned char *in, size_t inlen)\\r\\n{\\r\\nint ret;\\r\\nRSA_PKEY_CTX *rctx = ctx->data;\\r\\nif (rctx->pad_mode == RSA_PKCS1_OAEP_PADDING) {\\r\\nint i;\\r\\nif (!setup_tbuf(rctx, ctx))\\r\\nreturn -1;\\r\\nret = RSA_private_decrypt(inlen, in, rctx->tbuf,\\r\\nctx->pkey->pkey.rsa, RSA_NO_PADDING);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\nfor (i = 0; i < ret; i++) {\\r\\nif (rctx->tbuf[i])\\r\\nbreak;\\r\\n}\\r\\nret = RSA_padding_check_PKCS1_OAEP_mgf1(out, ret, rctx->tbuf + i,\\r\\nret - i, ret,\\r\\nrctx->oaep_label,\\r\\nrctx->oaep_labellen,\\r\\nrctx->md, rctx->mgf1md);\\r\\n} else\\r\\nret = RSA_private_decrypt(inlen, in, out, ctx->pkey->pkey.rsa,\\r\\nrctx->pad_mode);\\r\\nif (ret < 0)\\r\\nreturn ret;\\r\\n*outlen = ret;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int check_padding_md(const EVP_MD *md, int padding)\\r\\n{\\r\\nif (!md)\\r\\nreturn 1;\\r\\nif (padding == RSA_NO_PADDING) {\\r\\nRSAerr(RSA_F_CHECK_PADDING_MD, RSA_R_INVALID_PADDING_MODE);\\r\\nreturn 0;\\r\\n}\\r\\nif (padding == RSA_X931_PADDING) {\\r\\nif (RSA_X931_hash_id(EVP_MD_type(md)) == -1) {\\r\\nRSAerr(RSA_F_CHECK_PADDING_MD, RSA_R_INVALID_X931_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)\\r\\n{\\r\\nRSA_PKEY_CTX *rctx = ctx->data;\\r\\nswitch (type) {\\r\\ncase EVP_PKEY_CTRL_RSA_PADDING:\\r\\nif ((p1 >= RSA_PKCS1_PADDING) && (p1 <= RSA_PKCS1_PSS_PADDING)) {\\r\\nif (!check_padding_md(rctx->md, p1))\\r\\nreturn 0;\\r\\nif (p1 == RSA_PKCS1_PSS_PADDING) {\\r\\nif (!(ctx->operation &\\r\\n(EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY)))\\r\\ngoto bad_pad;\\r\\nif (!rctx->md)\\r\\nrctx->md = EVP_sha1();\\r\\n}\\r\\nif (p1 == RSA_PKCS1_OAEP_PADDING) {\\r\\nif (!(ctx->operation & EVP_PKEY_OP_TYPE_CRYPT))\\r\\ngoto bad_pad;\\r\\nif (!rctx->md)\\r\\nrctx->md = EVP_sha1();\\r\\n}\\r\\nrctx->pad_mode = p1;\\r\\nreturn 1;\\r\\n}\\r\\nbad_pad:\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL,\\r\\nRSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE);\\r\\nreturn -2;\\r\\ncase EVP_PKEY_CTRL_GET_RSA_PADDING:\\r\\n*(int *)p2 = rctx->pad_mode;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_RSA_PSS_SALTLEN:\\r\\ncase EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN:\\r\\nif (rctx->pad_mode != RSA_PKCS1_PSS_PADDING) {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PSS_SALTLEN);\\r\\nreturn -2;\\r\\n}\\r\\nif (type == EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN)\\r\\n*(int *)p2 = rctx->saltlen;\\r\\nelse {\\r\\nif (p1 < -2)\\r\\nreturn -2;\\r\\nrctx->saltlen = p1;\\r\\n}\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_RSA_KEYGEN_BITS:\\r\\nif (p1 < 256) {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_KEYBITS);\\r\\nreturn -2;\\r\\n}\\r\\nrctx->nbits = p1;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP:\\r\\nif (!p2)\\r\\nreturn -2;\\r\\nBN_free(rctx->pub_exp);\\r\\nrctx->pub_exp = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_RSA_OAEP_MD:\\r\\ncase EVP_PKEY_CTRL_GET_RSA_OAEP_MD:\\r\\nif (rctx->pad_mode != RSA_PKCS1_OAEP_PADDING) {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PADDING_MODE);\\r\\nreturn -2;\\r\\n}\\r\\nif (type == EVP_PKEY_CTRL_GET_RSA_OAEP_MD)\\r\\n*(const EVP_MD **)p2 = rctx->md;\\r\\nelse\\r\\nrctx->md = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_MD:\\r\\nif (!check_padding_md(p2, rctx->pad_mode))\\r\\nreturn 0;\\r\\nrctx->md = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_MD:\\r\\n*(const EVP_MD **)p2 = rctx->md;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_RSA_MGF1_MD:\\r\\ncase EVP_PKEY_CTRL_GET_RSA_MGF1_MD:\\r\\nif (rctx->pad_mode != RSA_PKCS1_PSS_PADDING\\r\\n&& rctx->pad_mode != RSA_PKCS1_OAEP_PADDING) {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_MGF1_MD);\\r\\nreturn -2;\\r\\n}\\r\\nif (type == EVP_PKEY_CTRL_GET_RSA_MGF1_MD) {\\r\\nif (rctx->mgf1md)\\r\\n*(const EVP_MD **)p2 = rctx->mgf1md;\\r\\nelse\\r\\n*(const EVP_MD **)p2 = rctx->md;\\r\\n} else\\r\\nrctx->mgf1md = p2;\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_RSA_OAEP_LABEL:\\r\\nif (rctx->pad_mode != RSA_PKCS1_OAEP_PADDING) {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PADDING_MODE);\\r\\nreturn -2;\\r\\n}\\r\\nif (rctx->oaep_label)\\r\\nOPENSSL_free(rctx->oaep_label);\\r\\nif (p2 && p1 > 0) {\\r\\nrctx->oaep_label = p2;\\r\\nrctx->oaep_labellen = p1;\\r\\n} else {\\r\\nrctx->oaep_label = NULL;\\r\\nrctx->oaep_labellen = 0;\\r\\n}\\r\\nreturn 1;\\r\\ncase EVP_PKEY_CTRL_GET_RSA_OAEP_LABEL:\\r\\nif (rctx->pad_mode != RSA_PKCS1_OAEP_PADDING) {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PADDING_MODE);\\r\\nreturn -2;\\r\\n}\\r\\n*(unsigned char **)p2 = rctx->oaep_label;\\r\\nreturn rctx->oaep_labellen;\\r\\ncase EVP_PKEY_CTRL_DIGESTINIT:\\r\\ncase EVP_PKEY_CTRL_PKCS7_ENCRYPT:\\r\\ncase EVP_PKEY_CTRL_PKCS7_DECRYPT:\\r\\ncase EVP_PKEY_CTRL_PKCS7_SIGN:\\r\\nreturn 1;\\r\\n#ifndef OPENSSL_NO_CMS\\r\\ncase EVP_PKEY_CTRL_CMS_DECRYPT:\\r\\ncase EVP_PKEY_CTRL_CMS_ENCRYPT:\\r\\ncase EVP_PKEY_CTRL_CMS_SIGN:\\r\\nreturn 1;\\r\\n#endif\\r\\ncase EVP_PKEY_CTRL_PEER_KEY:\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL,\\r\\nRSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\\r\\nreturn -2;\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\n}\\r\\nstatic int pkey_rsa_ctrl_str(EVP_PKEY_CTX *ctx,\\r\\nconst char *type, const char *value)\\r\\n{\\r\\nif (!value) {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL_STR, RSA_R_VALUE_MISSING);\\r\\nreturn 0;\\r\\n}\\r\\nif (!strcmp(type, \"rsa_padding_mode\")) {\\r\\nint pm;\\r\\nif (!strcmp(value, \"pkcs1\"))\\r\\npm = RSA_PKCS1_PADDING;\\r\\nelse if (!strcmp(value, \"sslv23\"))\\r\\npm = RSA_SSLV23_PADDING;\\r\\nelse if (!strcmp(value, \"none\"))\\r\\npm = RSA_NO_PADDING;\\r\\nelse if (!strcmp(value, \"oeap\"))\\r\\npm = RSA_PKCS1_OAEP_PADDING;\\r\\nelse if (!strcmp(value, \"oaep\"))\\r\\npm = RSA_PKCS1_OAEP_PADDING;\\r\\nelse if (!strcmp(value, \"x931\"))\\r\\npm = RSA_X931_PADDING;\\r\\nelse if (!strcmp(value, \"pss\"))\\r\\npm = RSA_PKCS1_PSS_PADDING;\\r\\nelse {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL_STR, RSA_R_UNKNOWN_PADDING_TYPE);\\r\\nreturn -2;\\r\\n}\\r\\nreturn EVP_PKEY_CTX_set_rsa_padding(ctx, pm);\\r\\n}\\r\\nif (!strcmp(type, \"rsa_pss_saltlen\")) {\\r\\nint saltlen;\\r\\nsaltlen = atoi(value);\\r\\nreturn EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, saltlen);\\r\\n}\\r\\nif (!strcmp(type, \"rsa_keygen_bits\")) {\\r\\nint nbits;\\r\\nnbits = atoi(value);\\r\\nreturn EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, nbits);\\r\\n}\\r\\nif (!strcmp(type, \"rsa_keygen_pubexp\")) {\\r\\nint ret;\\r\\nBIGNUM *pubexp = NULL;\\r\\nif (!BN_asc2bn(&pubexp, value))\\r\\nreturn 0;\\r\\nret = EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, pubexp);\\r\\nif (ret <= 0)\\r\\nBN_free(pubexp);\\r\\nreturn ret;\\r\\n}\\r\\nif (!strcmp(type, \"rsa_mgf1_md\")) {\\r\\nconst EVP_MD *md;\\r\\nif (!(md = EVP_get_digestbyname(value))) {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL_STR, RSA_R_INVALID_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, md);\\r\\n}\\r\\nif (!strcmp(type, \"rsa_oaep_md\")) {\\r\\nconst EVP_MD *md;\\r\\nif (!(md = EVP_get_digestbyname(value))) {\\r\\nRSAerr(RSA_F_PKEY_RSA_CTRL_STR, RSA_R_INVALID_DIGEST);\\r\\nreturn 0;\\r\\n}\\r\\nreturn EVP_PKEY_CTX_set_rsa_oaep_md(ctx, md);\\r\\n}\\r\\nif (!strcmp(type, \"rsa_oaep_label\")) {\\r\\nunsigned char *lab;\\r\\nlong lablen;\\r\\nint ret;\\r\\nlab = string_to_hex(value, &lablen);\\r\\nif (!lab)\\r\\nreturn 0;\\r\\nret = EVP_PKEY_CTX_set0_rsa_oaep_label(ctx, lab, lablen);\\r\\nif (ret <= 0)\\r\\nOPENSSL_free(lab);\\r\\nreturn ret;\\r\\n}\\r\\nreturn -2;\\r\\n}\\r\\nstatic int pkey_rsa_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)\\r\\n{\\r\\nRSA *rsa = NULL;\\r\\nRSA_PKEY_CTX *rctx = ctx->data;\\r\\nBN_GENCB *pcb, cb;\\r\\nint ret;\\r\\nif (!rctx->pub_exp) {\\r\\nrctx->pub_exp = BN_new();\\r\\nif (!rctx->pub_exp || !BN_set_word(rctx->pub_exp, RSA_F4))\\r\\nreturn 0;\\r\\n}\\r\\nrsa = RSA_new();\\r\\nif (!rsa)\\r\\nreturn 0;\\r\\nif (ctx->pkey_gencb) {\\r\\npcb = &cb;\\r\\nevp_pkey_set_cb_translate(pcb, ctx);\\r\\n} else\\r\\npcb = NULL;\\r\\nret = RSA_generate_key_ex(rsa, rctx->nbits, rctx->pub_exp, pcb);\\r\\nif (ret > 0)\\r\\nEVP_PKEY_assign_RSA(pkey, rsa);\\r\\nelse\\r\\nRSA_free(rsa);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_str2key_c", "target": 0, "func": "void DES_string_to_key(const char *str, DES_cblock *key)\\r\\n{\\r\\nDES_key_schedule ks;\\r\\nint i, length;\\r\\nregister unsigned char j;\\r\\nmemset(key, 0, 8);\\r\\nlength = strlen(str);\\r\\n#ifdef OLD_STR_TO_KEY\\r\\nfor (i = 0; i < length; i++)\\r\\n(*key)[i % 8] ^= (str[i] << 1);\\r\\n#else\\r\\nfor (i = 0; i < length; i++) {\\r\\nj = str[i];\\r\\nif ((i % 16) < 8)\\r\\n(*key)[i % 8] ^= (j << 1);\\r\\nelse {\\r\\nj = ((j << 4) & 0xf0) | ((j >> 4) & 0x0f);\\r\\nj = ((j << 2) & 0xcc) | ((j >> 2) & 0x33);\\r\\nj = ((j << 1) & 0xaa) | ((j >> 1) & 0x55);\\r\\n(*key)[7 - (i % 8)] ^= j;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nDES_set_odd_parity(key);\\r\\n#ifdef EXPERIMENTAL_STR_TO_STRONG_KEY\\r\\nif (DES_is_weak_key(key))\\r\\n(*key)[7] ^= 0xF0;\\r\\nDES_set_key(key, &ks);\\r\\n#else\\r\\nDES_set_key_unchecked(key, &ks);\\r\\n#endif\\r\\nDES_cbc_cksum((const unsigned char *)str, key, length, &ks, key);\\r\\nOPENSSL_cleanse(&ks, sizeof(ks));\\r\\nDES_set_odd_parity(key);\\r\\n}\\r\\nvoid DES_string_to_2keys(const char *str, DES_cblock *key1, DES_cblock *key2)\\r\\n{\\r\\nDES_key_schedule ks;\\r\\nint i, length;\\r\\nregister unsigned char j;\\r\\nmemset(key1, 0, 8);\\r\\nmemset(key2, 0, 8);\\r\\nlength = strlen(str);\\r\\n#ifdef OLD_STR_TO_KEY\\r\\nif (length <= 8) {\\r\\nfor (i = 0; i < length; i++) {\\r\\n(*key2)[i] = (*key1)[i] = (str[i] << 1);\\r\\n}\\r\\n} else {\\r\\nfor (i = 0; i < length; i++) {\\r\\nif ((i / 8) & 1)\\r\\n(*key2)[i % 8] ^= (str[i] << 1);\\r\\nelse\\r\\n(*key1)[i % 8] ^= (str[i] << 1);\\r\\n}\\r\\n}\\r\\n#else\\r\\nfor (i = 0; i < length; i++) {\\r\\nj = str[i];\\r\\nif ((i % 32) < 16) {\\r\\nif ((i % 16) < 8)\\r\\n(*key1)[i % 8] ^= (j << 1);\\r\\nelse\\r\\n(*key2)[i % 8] ^= (j << 1);\\r\\n} else {\\r\\nj = ((j << 4) & 0xf0) | ((j >> 4) & 0x0f);\\r\\nj = ((j << 2) & 0xcc) | ((j >> 2) & 0x33);\\r\\nj = ((j << 1) & 0xaa) | ((j >> 1) & 0x55);\\r\\nif ((i % 16) < 8)\\r\\n(*key1)[7 - (i % 8)] ^= j;\\r\\nelse\\r\\n(*key2)[7 - (i % 8)] ^= j;\\r\\n}\\r\\n}\\r\\nif (length <= 8)\\r\\nmemcpy(key2, key1, 8);\\r\\n#endif\\r\\nDES_set_odd_parity(key1);\\r\\nDES_set_odd_parity(key2);\\r\\n#ifdef EXPERIMENTAL_STR_TO_STRONG_KEY\\r\\nif (DES_is_weak_key(key1))\\r\\n(*key1)[7] ^= 0xF0;\\r\\nDES_set_key(key1, &ks);\\r\\n#else\\r\\nDES_set_key_unchecked(key1, &ks);\\r\\n#endif\\r\\nDES_cbc_cksum((const unsigned char *)str, key1, length, &ks, key1);\\r\\n#ifdef EXPERIMENTAL_STR_TO_STRONG_KEY\\r\\nif (DES_is_weak_key(key2))\\r\\n(*key2)[7] ^= 0xF0;\\r\\nDES_set_key(key2, &ks);\\r\\n#else\\r\\nDES_set_key_unchecked(key2, &ks);\\r\\n#endif\\r\\nDES_cbc_cksum((const unsigned char *)str, key2, length, &ks, key2);\\r\\nOPENSSL_cleanse(&ks, sizeof(ks));\\r\\nDES_set_odd_parity(key1);\\r\\nDES_set_odd_parity(key2);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_applink_c", "target": 0, "func": "static void *app_stdin(void)\\r\\n{\\r\\nreturn stdin;\\r\\n}\\r\\nstatic void *app_stdout(void)\\r\\n{\\r\\nreturn stdout;\\r\\n}\\r\\nstatic void *app_stderr(void)\\r\\n{\\r\\nreturn stderr;\\r\\n}\\r\\nstatic int app_feof(FILE *fp)\\r\\n{\\r\\nreturn feof(fp);\\r\\n}\\r\\nstatic int app_ferror(FILE *fp)\\r\\n{\\r\\nreturn ferror(fp);\\r\\n}\\r\\nstatic void app_clearerr(FILE *fp)\\r\\n{\\r\\nclearerr(fp);\\r\\n}\\r\\nstatic int app_fileno(FILE *fp)\\r\\n{\\r\\nreturn _fileno(fp);\\r\\n}\\r\\nstatic int app_fsetmod(FILE *fp, char mod)\\r\\n{\\r\\nreturn _setmode(_fileno(fp), mod == 'b' ? _O_BINARY : _O_TEXT);\\r\\n}\\r\\nvoid **\\r\\n# if defined(__BORLANDC__)\\r\\n__stdcall\\r\\n# else\\r\\n__cdecl\\r\\n# endif\\r\\nOPENSSL_Applink(void)\\r\\n{\\r\\nstatic int once = 1;\\r\\nstatic void *OPENSSL_ApplinkTable[APPLINK_MAX + 1] =\\r\\n{ (void *)APPLINK_MAX };\\r\\nif (once) {\\r\\nOPENSSL_ApplinkTable[APPLINK_STDIN] = app_stdin;\\r\\nOPENSSL_ApplinkTable[APPLINK_STDOUT] = app_stdout;\\r\\nOPENSSL_ApplinkTable[APPLINK_STDERR] = app_stderr;\\r\\nOPENSSL_ApplinkTable[APPLINK_FPRINTF] = fprintf;\\r\\nOPENSSL_ApplinkTable[APPLINK_FGETS] = fgets;\\r\\nOPENSSL_ApplinkTable[APPLINK_FREAD] = fread;\\r\\nOPENSSL_ApplinkTable[APPLINK_FWRITE] = fwrite;\\r\\nOPENSSL_ApplinkTable[APPLINK_FSETMOD] = app_fsetmod;\\r\\nOPENSSL_ApplinkTable[APPLINK_FEOF] = app_feof;\\r\\nOPENSSL_ApplinkTable[APPLINK_FCLOSE] = fclose;\\r\\nOPENSSL_ApplinkTable[APPLINK_FOPEN] = fopen;\\r\\nOPENSSL_ApplinkTable[APPLINK_FSEEK] = fseek;\\r\\nOPENSSL_ApplinkTable[APPLINK_FTELL] = ftell;\\r\\nOPENSSL_ApplinkTable[APPLINK_FFLUSH] = fflush;\\r\\nOPENSSL_ApplinkTable[APPLINK_FERROR] = app_ferror;\\r\\nOPENSSL_ApplinkTable[APPLINK_CLEARERR] = app_clearerr;\\r\\nOPENSSL_ApplinkTable[APPLINK_FILENO] = app_fileno;\\r\\nOPENSSL_ApplinkTable[APPLINK_OPEN] = _open;\\r\\nOPENSSL_ApplinkTable[APPLINK_READ] = _read;\\r\\nOPENSSL_ApplinkTable[APPLINK_WRITE] = _write;\\r\\nOPENSSL_ApplinkTable[APPLINK_LSEEK] = _lseek;\\r\\nOPENSSL_ApplinkTable[APPLINK_CLOSE] = _close;\\r\\nonce = 0;\\r\\n}\\r\\nreturn OPENSSL_ApplinkTable;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bf_null_c", "target": 0, "func": "BIO_METHOD *BIO_f_null(void)\\r\\n{\\r\\nreturn (&methods_nullf);\\r\\n}\\r\\nstatic int nullf_new(BIO *bi)\\r\\n{\\r\\nbi->init = 1;\\r\\nbi->ptr = NULL;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int nullf_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int nullf_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_read(b->next_bio, out, outl);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int nullf_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret = 0;\\r\\nif ((in == NULL) || (inl <= 0))\\r\\nreturn (0);\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nret = BIO_write(b->next_bio, in, inl);\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long nullf_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\nret = 0L;\\r\\nbreak;\\r\\ndefault:\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long nullf_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret = 1;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\nret = BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int nullf_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nif (bp->next_bio == NULL)\\r\\nreturn (0);\\r\\nreturn (BIO_gets(bp->next_bio, buf, size));\\r\\n}\\r\\nstatic int nullf_puts(BIO *bp, const char *str)\\r\\n{\\r\\nif (bp->next_bio == NULL)\\r\\nreturn (0);\\r\\nreturn (BIO_puts(bp->next_bio, str));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_addr_c", "target": 0, "func": "int v3_addr_get_afi(const IPAddressFamily *f)\\r\\n{\\r\\nreturn ((f != NULL &&\\r\\nf->addressFamily != NULL && f->addressFamily->data != NULL)\\r\\n? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\\r\\n: 0);\\r\\n}\\r\\nstatic int addr_expand(unsigned char *addr,\\r\\nconst ASN1_BIT_STRING *bs,\\r\\nconst int length, const unsigned char fill)\\r\\n{\\r\\nif (bs->length < 0 || bs->length > length)\\r\\nreturn 0;\\r\\nif (bs->length > 0) {\\r\\nmemcpy(addr, bs->data, bs->length);\\r\\nif ((bs->flags & 7) != 0) {\\r\\nunsigned char mask = 0xFF >> (8 - (bs->flags & 7));\\r\\nif (fill == 0)\\r\\naddr[bs->length - 1] &= ~mask;\\r\\nelse\\r\\naddr[bs->length - 1] |= mask;\\r\\n}\\r\\n}\\r\\nmemset(addr + bs->length, fill, length - bs->length);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int i2r_address(BIO *out,\\r\\nconst unsigned afi,\\r\\nconst unsigned char fill, const ASN1_BIT_STRING *bs)\\r\\n{\\r\\nunsigned char addr[ADDR_RAW_BUF_LEN];\\r\\nint i, n;\\r\\nif (bs->length < 0)\\r\\nreturn 0;\\r\\nswitch (afi) {\\r\\ncase IANA_AFI_IPV4:\\r\\nif (!addr_expand(addr, bs, 4, fill))\\r\\nreturn 0;\\r\\nBIO_printf(out, \"%d.%d.%d.%d\", addr[0], addr[1], addr[2], addr[3]);\\r\\nbreak;\\r\\ncase IANA_AFI_IPV6:\\r\\nif (!addr_expand(addr, bs, 16, fill))\\r\\nreturn 0;\\r\\nfor (n = 16; n > 1 && addr[n - 1] == 0x00 && addr[n - 2] == 0x00;\\r\\nn -= 2) ;\\r\\nfor (i = 0; i < n; i += 2)\\r\\nBIO_printf(out, \"%x%s\", (addr[i] << 8) | addr[i + 1],\\r\\n(i < 14 ? \":\" : \"\"));\\r\\nif (i < 16)\\r\\nBIO_puts(out, \":\");\\r\\nif (i == 0)\\r\\nBIO_puts(out, \":\");\\r\\nbreak;\\r\\ndefault:\\r\\nfor (i = 0; i < bs->length; i++)\\r\\nBIO_printf(out, \"%s%02x\", (i > 0 ? \":\" : \"\"), bs->data[i]);\\r\\nBIO_printf(out, \"[%d]\", (int)(bs->flags & 7));\\r\\nbreak;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int i2r_IPAddressOrRanges(BIO *out,\\r\\nconst int indent,\\r\\nconst IPAddressOrRanges *aors,\\r\\nconst unsigned afi)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < sk_IPAddressOrRange_num(aors); i++) {\\r\\nconst IPAddressOrRange *aor = sk_IPAddressOrRange_value(aors, i);\\r\\nBIO_printf(out, \"%*s\", indent, \"\");\\r\\nswitch (aor->type) {\\r\\ncase IPAddressOrRange_addressPrefix:\\r\\nif (!i2r_address(out, afi, 0x00, aor->u.addressPrefix))\\r\\nreturn 0;\\r\\nBIO_printf(out, \"/%d\\n\", addr_prefixlen(aor->u.addressPrefix));\\r\\ncontinue;\\r\\ncase IPAddressOrRange_addressRange:\\r\\nif (!i2r_address(out, afi, 0x00, aor->u.addressRange->min))\\r\\nreturn 0;\\r\\nBIO_puts(out, \"-\");\\r\\nif (!i2r_address(out, afi, 0xFF, aor->u.addressRange->max))\\r\\nreturn 0;\\r\\nBIO_puts(out, \"\\n\");\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int i2r_IPAddrBlocks(const X509V3_EXT_METHOD *method,\\r\\nvoid *ext, BIO *out, int indent)\\r\\n{\\r\\nconst IPAddrBlocks *addr = ext;\\r\\nint i;\\r\\nfor (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\\r\\nIPAddressFamily *f = sk_IPAddressFamily_value(addr, i);\\r\\nconst unsigned int afi = v3_addr_get_afi(f);\\r\\nswitch (afi) {\\r\\ncase IANA_AFI_IPV4:\\r\\nBIO_printf(out, \"%*sIPv4\", indent, \"\");\\r\\nbreak;\\r\\ncase IANA_AFI_IPV6:\\r\\nBIO_printf(out, \"%*sIPv6\", indent, \"\");\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_printf(out, \"%*sUnknown AFI %u\", indent, \"\", afi);\\r\\nbreak;\\r\\n}\\r\\nif (f->addressFamily->length > 2) {\\r\\nswitch (f->addressFamily->data[2]) {\\r\\ncase 1:\\r\\nBIO_puts(out, \" (Unicast)\");\\r\\nbreak;\\r\\ncase 2:\\r\\nBIO_puts(out, \" (Multicast)\");\\r\\nbreak;\\r\\ncase 3:\\r\\nBIO_puts(out, \" (Unicast/Multicast)\");\\r\\nbreak;\\r\\ncase 4:\\r\\nBIO_puts(out, \" (MPLS)\");\\r\\nbreak;\\r\\ncase 64:\\r\\nBIO_puts(out, \" (Tunnel)\");\\r\\nbreak;\\r\\ncase 65:\\r\\nBIO_puts(out, \" (VPLS)\");\\r\\nbreak;\\r\\ncase 66:\\r\\nBIO_puts(out, \" (BGP MDT)\");\\r\\nbreak;\\r\\ncase 128:\\r\\nBIO_puts(out, \" (MPLS-labeled VPN)\");\\r\\nbreak;\\r\\ndefault:\\r\\nBIO_printf(out, \" (Unknown SAFI %u)\",\\r\\n(unsigned)f->addressFamily->data[2]);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nswitch (f->ipAddressChoice->type) {\\r\\ncase IPAddressChoice_inherit:\\r\\nBIO_puts(out, \": inherit\\n\");\\r\\nbreak;\\r\\ncase IPAddressChoice_addressesOrRanges:\\r\\nBIO_puts(out, \":\\n\");\\r\\nif (!i2r_IPAddressOrRanges(out,\\r\\nindent + 2,\\r\\nf->ipAddressChoice->\\r\\nu.addressesOrRanges, afi))\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int IPAddressOrRange_cmp(const IPAddressOrRange *a,\\r\\nconst IPAddressOrRange *b, const int length)\\r\\n{\\r\\nunsigned char addr_a[ADDR_RAW_BUF_LEN], addr_b[ADDR_RAW_BUF_LEN];\\r\\nint prefixlen_a = 0, prefixlen_b = 0;\\r\\nint r;\\r\\nswitch (a->type) {\\r\\ncase IPAddressOrRange_addressPrefix:\\r\\nif (!addr_expand(addr_a, a->u.addressPrefix, length, 0x00))\\r\\nreturn -1;\\r\\nprefixlen_a = addr_prefixlen(a->u.addressPrefix);\\r\\nbreak;\\r\\ncase IPAddressOrRange_addressRange:\\r\\nif (!addr_expand(addr_a, a->u.addressRange->min, length, 0x00))\\r\\nreturn -1;\\r\\nprefixlen_a = length * 8;\\r\\nbreak;\\r\\n}\\r\\nswitch (b->type) {\\r\\ncase IPAddressOrRange_addressPrefix:\\r\\nif (!addr_expand(addr_b, b->u.addressPrefix, length, 0x00))\\r\\nreturn -1;\\r\\nprefixlen_b = addr_prefixlen(b->u.addressPrefix);\\r\\nbreak;\\r\\ncase IPAddressOrRange_addressRange:\\r\\nif (!addr_expand(addr_b, b->u.addressRange->min, length, 0x00))\\r\\nreturn -1;\\r\\nprefixlen_b = length * 8;\\r\\nbreak;\\r\\n}\\r\\nif ((r = memcmp(addr_a, addr_b, length)) != 0)\\r\\nreturn r;\\r\\nelse\\r\\nreturn prefixlen_a - prefixlen_b;\\r\\n}\\r\\nstatic int v4IPAddressOrRange_cmp(const IPAddressOrRange *const *a,\\r\\nconst IPAddressOrRange *const *b)\\r\\n{\\r\\nreturn IPAddressOrRange_cmp(*a, *b, 4);\\r\\n}\\r\\nstatic int v6IPAddressOrRange_cmp(const IPAddressOrRange *const *a,\\r\\nconst IPAddressOrRange *const *b)\\r\\n{\\r\\nreturn IPAddressOrRange_cmp(*a, *b, 16);\\r\\n}\\r\\nstatic int range_should_be_prefix(const unsigned char *min,\\r\\nconst unsigned char *max, const int length)\\r\\n{\\r\\nunsigned char mask;\\r\\nint i, j;\\r\\nOPENSSL_assert(memcmp(min, max, length) <= 0);\\r\\nfor (i = 0; i < length && min[i] == max[i]; i++) ;\\r\\nfor (j = length - 1; j >= 0 && min[j] == 0x00 && max[j] == 0xFF; j--) ;\\r\\nif (i < j)\\r\\nreturn -1;\\r\\nif (i > j)\\r\\nreturn i * 8;\\r\\nmask = min[i] ^ max[i];\\r\\nswitch (mask) {\\r\\ncase 0x01:\\r\\nj = 7;\\r\\nbreak;\\r\\ncase 0x03:\\r\\nj = 6;\\r\\nbreak;\\r\\ncase 0x07:\\r\\nj = 5;\\r\\nbreak;\\r\\ncase 0x0F:\\r\\nj = 4;\\r\\nbreak;\\r\\ncase 0x1F:\\r\\nj = 3;\\r\\nbreak;\\r\\ncase 0x3F:\\r\\nj = 2;\\r\\nbreak;\\r\\ncase 0x7F:\\r\\nj = 1;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\nif ((min[i] & mask) != 0 || (max[i] & mask) != mask)\\r\\nreturn -1;\\r\\nelse\\r\\nreturn i * 8 + j;\\r\\n}\\r\\nstatic int make_addressPrefix(IPAddressOrRange **result,\\r\\nunsigned char *addr, const int prefixlen)\\r\\n{\\r\\nint bytelen = (prefixlen + 7) / 8, bitlen = prefixlen % 8;\\r\\nIPAddressOrRange *aor = IPAddressOrRange_new();\\r\\nif (aor == NULL)\\r\\nreturn 0;\\r\\naor->type = IPAddressOrRange_addressPrefix;\\r\\nif (aor->u.addressPrefix == NULL &&\\r\\n(aor->u.addressPrefix = ASN1_BIT_STRING_new()) == NULL)\\r\\ngoto err;\\r\\nif (!ASN1_BIT_STRING_set(aor->u.addressPrefix, addr, bytelen))\\r\\ngoto err;\\r\\naor->u.addressPrefix->flags &= ~7;\\r\\naor->u.addressPrefix->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\nif (bitlen > 0) {\\r\\naor->u.addressPrefix->data[bytelen - 1] &= ~(0xFF >> bitlen);\\r\\naor->u.addressPrefix->flags |= 8 - bitlen;\\r\\n}\\r\\n*result = aor;\\r\\nreturn 1;\\r\\nerr:\\r\\nIPAddressOrRange_free(aor);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int make_addressRange(IPAddressOrRange **result,\\r\\nunsigned char *min,\\r\\nunsigned char *max, const int length)\\r\\n{\\r\\nIPAddressOrRange *aor;\\r\\nint i, prefixlen;\\r\\nif ((prefixlen = range_should_be_prefix(min, max, length)) >= 0)\\r\\nreturn make_addressPrefix(result, min, prefixlen);\\r\\nif ((aor = IPAddressOrRange_new()) == NULL)\\r\\nreturn 0;\\r\\naor->type = IPAddressOrRange_addressRange;\\r\\nOPENSSL_assert(aor->u.addressRange == NULL);\\r\\nif ((aor->u.addressRange = IPAddressRange_new()) == NULL)\\r\\ngoto err;\\r\\nif (aor->u.addressRange->min == NULL &&\\r\\n(aor->u.addressRange->min = ASN1_BIT_STRING_new()) == NULL)\\r\\ngoto err;\\r\\nif (aor->u.addressRange->max == NULL &&\\r\\n(aor->u.addressRange->max = ASN1_BIT_STRING_new()) == NULL)\\r\\ngoto err;\\r\\nfor (i = length; i > 0 && min[i - 1] == 0x00; --i) ;\\r\\nif (!ASN1_BIT_STRING_set(aor->u.addressRange->min, min, i))\\r\\ngoto err;\\r\\naor->u.addressRange->min->flags &= ~7;\\r\\naor->u.addressRange->min->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\nif (i > 0) {\\r\\nunsigned char b = min[i - 1];\\r\\nint j = 1;\\r\\nwhile ((b & (0xFFU >> j)) != 0)\\r\\n++j;\\r\\naor->u.addressRange->min->flags |= 8 - j;\\r\\n}\\r\\nfor (i = length; i > 0 && max[i - 1] == 0xFF; --i) ;\\r\\nif (!ASN1_BIT_STRING_set(aor->u.addressRange->max, max, i))\\r\\ngoto err;\\r\\naor->u.addressRange->max->flags &= ~7;\\r\\naor->u.addressRange->max->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\nif (i > 0) {\\r\\nunsigned char b = max[i - 1];\\r\\nint j = 1;\\r\\nwhile ((b & (0xFFU >> j)) != (0xFFU >> j))\\r\\n++j;\\r\\naor->u.addressRange->max->flags |= 8 - j;\\r\\n}\\r\\n*result = aor;\\r\\nreturn 1;\\r\\nerr:\\r\\nIPAddressOrRange_free(aor);\\r\\nreturn 0;\\r\\n}\\r\\nstatic IPAddressFamily *make_IPAddressFamily(IPAddrBlocks *addr,\\r\\nconst unsigned afi,\\r\\nconst unsigned *safi)\\r\\n{\\r\\nIPAddressFamily *f;\\r\\nunsigned char key[3];\\r\\nunsigned keylen;\\r\\nint i;\\r\\nkey[0] = (afi >> 8) & 0xFF;\\r\\nkey[1] = afi & 0xFF;\\r\\nif (safi != NULL) {\\r\\nkey[2] = *safi & 0xFF;\\r\\nkeylen = 3;\\r\\n} else {\\r\\nkeylen = 2;\\r\\n}\\r\\nfor (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\\r\\nf = sk_IPAddressFamily_value(addr, i);\\r\\nOPENSSL_assert(f->addressFamily->data != NULL);\\r\\nif (f->addressFamily->length == keylen &&\\r\\n!memcmp(f->addressFamily->data, key, keylen))\\r\\nreturn f;\\r\\n}\\r\\nif ((f = IPAddressFamily_new()) == NULL)\\r\\ngoto err;\\r\\nif (f->ipAddressChoice == NULL &&\\r\\n(f->ipAddressChoice = IPAddressChoice_new()) == NULL)\\r\\ngoto err;\\r\\nif (f->addressFamily == NULL &&\\r\\n(f->addressFamily = ASN1_OCTET_STRING_new()) == NULL)\\r\\ngoto err;\\r\\nif (!ASN1_OCTET_STRING_set(f->addressFamily, key, keylen))\\r\\ngoto err;\\r\\nif (!sk_IPAddressFamily_push(addr, f))\\r\\ngoto err;\\r\\nreturn f;\\r\\nerr:\\r\\nIPAddressFamily_free(f);\\r\\nreturn NULL;\\r\\n}\\r\\nint v3_addr_add_inherit(IPAddrBlocks *addr,\\r\\nconst unsigned afi, const unsigned *safi)\\r\\n{\\r\\nIPAddressFamily *f = make_IPAddressFamily(addr, afi, safi);\\r\\nif (f == NULL ||\\r\\nf->ipAddressChoice == NULL ||\\r\\n(f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges &&\\r\\nf->ipAddressChoice->u.addressesOrRanges != NULL))\\r\\nreturn 0;\\r\\nif (f->ipAddressChoice->type == IPAddressChoice_inherit &&\\r\\nf->ipAddressChoice->u.inherit != NULL)\\r\\nreturn 1;\\r\\nif (f->ipAddressChoice->u.inherit == NULL &&\\r\\n(f->ipAddressChoice->u.inherit = ASN1_NULL_new()) == NULL)\\r\\nreturn 0;\\r\\nf->ipAddressChoice->type = IPAddressChoice_inherit;\\r\\nreturn 1;\\r\\n}\\r\\nstatic IPAddressOrRanges *make_prefix_or_range(IPAddrBlocks *addr,\\r\\nconst unsigned afi,\\r\\nconst unsigned *safi)\\r\\n{\\r\\nIPAddressFamily *f = make_IPAddressFamily(addr, afi, safi);\\r\\nIPAddressOrRanges *aors = NULL;\\r\\nif (f == NULL ||\\r\\nf->ipAddressChoice == NULL ||\\r\\n(f->ipAddressChoice->type == IPAddressChoice_inherit &&\\r\\nf->ipAddressChoice->u.inherit != NULL))\\r\\nreturn NULL;\\r\\nif (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges)\\r\\naors = f->ipAddressChoice->u.addressesOrRanges;\\r\\nif (aors != NULL)\\r\\nreturn aors;\\r\\nif ((aors = sk_IPAddressOrRange_new_null()) == NULL)\\r\\nreturn NULL;\\r\\nswitch (afi) {\\r\\ncase IANA_AFI_IPV4:\\r\\n(void)sk_IPAddressOrRange_set_cmp_func(aors, v4IPAddressOrRange_cmp);\\r\\nbreak;\\r\\ncase IANA_AFI_IPV6:\\r\\n(void)sk_IPAddressOrRange_set_cmp_func(aors, v6IPAddressOrRange_cmp);\\r\\nbreak;\\r\\n}\\r\\nf->ipAddressChoice->type = IPAddressChoice_addressesOrRanges;\\r\\nf->ipAddressChoice->u.addressesOrRanges = aors;\\r\\nreturn aors;\\r\\n}\\r\\nint v3_addr_add_prefix(IPAddrBlocks *addr,\\r\\nconst unsigned afi,\\r\\nconst unsigned *safi,\\r\\nunsigned char *a, const int prefixlen)\\r\\n{\\r\\nIPAddressOrRanges *aors = make_prefix_or_range(addr, afi, safi);\\r\\nIPAddressOrRange *aor;\\r\\nif (aors == NULL || !make_addressPrefix(&aor, a, prefixlen))\\r\\nreturn 0;\\r\\nif (sk_IPAddressOrRange_push(aors, aor))\\r\\nreturn 1;\\r\\nIPAddressOrRange_free(aor);\\r\\nreturn 0;\\r\\n}\\r\\nint v3_addr_add_range(IPAddrBlocks *addr,\\r\\nconst unsigned afi,\\r\\nconst unsigned *safi,\\r\\nunsigned char *min, unsigned char *max)\\r\\n{\\r\\nIPAddressOrRanges *aors = make_prefix_or_range(addr, afi, safi);\\r\\nIPAddressOrRange *aor;\\r\\nint length = length_from_afi(afi);\\r\\nif (aors == NULL)\\r\\nreturn 0;\\r\\nif (!make_addressRange(&aor, min, max, length))\\r\\nreturn 0;\\r\\nif (sk_IPAddressOrRange_push(aors, aor))\\r\\nreturn 1;\\r\\nIPAddressOrRange_free(aor);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int extract_min_max(IPAddressOrRange *aor,\\r\\nunsigned char *min, unsigned char *max, int length)\\r\\n{\\r\\nif (aor == NULL || min == NULL || max == NULL)\\r\\nreturn 0;\\r\\nswitch (aor->type) {\\r\\ncase IPAddressOrRange_addressPrefix:\\r\\nreturn (addr_expand(min, aor->u.addressPrefix, length, 0x00) &&\\r\\naddr_expand(max, aor->u.addressPrefix, length, 0xFF));\\r\\ncase IPAddressOrRange_addressRange:\\r\\nreturn (addr_expand(min, aor->u.addressRange->min, length, 0x00) &&\\r\\naddr_expand(max, aor->u.addressRange->max, length, 0xFF));\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nint v3_addr_get_range(IPAddressOrRange *aor,\\r\\nconst unsigned afi,\\r\\nunsigned char *min,\\r\\nunsigned char *max, const int length)\\r\\n{\\r\\nint afi_length = length_from_afi(afi);\\r\\nif (aor == NULL || min == NULL || max == NULL ||\\r\\nafi_length == 0 || length < afi_length ||\\r\\n(aor->type != IPAddressOrRange_addressPrefix &&\\r\\naor->type != IPAddressOrRange_addressRange) ||\\r\\n!extract_min_max(aor, min, max, afi_length))\\r\\nreturn 0;\\r\\nreturn afi_length;\\r\\n}\\r\\nstatic int IPAddressFamily_cmp(const IPAddressFamily *const *a_,\\r\\nconst IPAddressFamily *const *b_)\\r\\n{\\r\\nconst ASN1_OCTET_STRING *a = (*a_)->addressFamily;\\r\\nconst ASN1_OCTET_STRING *b = (*b_)->addressFamily;\\r\\nint len = ((a->length <= b->length) ? a->length : b->length);\\r\\nint cmp = memcmp(a->data, b->data, len);\\r\\nreturn cmp ? cmp : a->length - b->length;\\r\\n}\\r\\nint v3_addr_is_canonical(IPAddrBlocks *addr)\\r\\n{\\r\\nunsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];\\r\\nunsigned char b_min[ADDR_RAW_BUF_LEN], b_max[ADDR_RAW_BUF_LEN];\\r\\nIPAddressOrRanges *aors;\\r\\nint i, j, k;\\r\\nif (addr == NULL)\\r\\nreturn 1;\\r\\nfor (i = 0; i < sk_IPAddressFamily_num(addr) - 1; i++) {\\r\\nconst IPAddressFamily *a = sk_IPAddressFamily_value(addr, i);\\r\\nconst IPAddressFamily *b = sk_IPAddressFamily_value(addr, i + 1);\\r\\nif (IPAddressFamily_cmp(&a, &b) >= 0)\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\\r\\nIPAddressFamily *f = sk_IPAddressFamily_value(addr, i);\\r\\nint length = length_from_afi(v3_addr_get_afi(f));\\r\\nif (f == NULL || f->ipAddressChoice == NULL)\\r\\nreturn 0;\\r\\nswitch (f->ipAddressChoice->type) {\\r\\ncase IPAddressChoice_inherit:\\r\\ncontinue;\\r\\ncase IPAddressChoice_addressesOrRanges:\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\naors = f->ipAddressChoice->u.addressesOrRanges;\\r\\nif (sk_IPAddressOrRange_num(aors) == 0)\\r\\nreturn 0;\\r\\nfor (j = 0; j < sk_IPAddressOrRange_num(aors) - 1; j++) {\\r\\nIPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);\\r\\nIPAddressOrRange *b = sk_IPAddressOrRange_value(aors, j + 1);\\r\\nif (!extract_min_max(a, a_min, a_max, length) ||\\r\\n!extract_min_max(b, b_min, b_max, length))\\r\\nreturn 0;\\r\\nif (memcmp(a_min, b_min, length) >= 0 ||\\r\\nmemcmp(a_min, a_max, length) > 0 ||\\r\\nmemcmp(b_min, b_max, length) > 0)\\r\\nreturn 0;\\r\\nfor (k = length - 1; k >= 0 && b_min[k]-- == 0x00; k--) ;\\r\\nif (memcmp(a_max, b_min, length) >= 0)\\r\\nreturn 0;\\r\\nif (a->type == IPAddressOrRange_addressRange &&\\r\\nrange_should_be_prefix(a_min, a_max, length) >= 0)\\r\\nreturn 0;\\r\\n}\\r\\nj = sk_IPAddressOrRange_num(aors) - 1;\\r\\n{\\r\\nIPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);\\r\\nif (a != NULL && a->type == IPAddressOrRange_addressRange) {\\r\\nif (!extract_min_max(a, a_min, a_max, length))\\r\\nreturn 0;\\r\\nif (memcmp(a_min, a_max, length) > 0 ||\\r\\nrange_should_be_prefix(a_min, a_max, length) >= 0)\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int IPAddressOrRanges_canonize(IPAddressOrRanges *aors,\\r\\nconst unsigned afi)\\r\\n{\\r\\nint i, j, length = length_from_afi(afi);\\r\\nsk_IPAddressOrRange_sort(aors);\\r\\nfor (i = 0; i < sk_IPAddressOrRange_num(aors) - 1; i++) {\\r\\nIPAddressOrRange *a = sk_IPAddressOrRange_value(aors, i);\\r\\nIPAddressOrRange *b = sk_IPAddressOrRange_value(aors, i + 1);\\r\\nunsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];\\r\\nunsigned char b_min[ADDR_RAW_BUF_LEN], b_max[ADDR_RAW_BUF_LEN];\\r\\nif (!extract_min_max(a, a_min, a_max, length) ||\\r\\n!extract_min_max(b, b_min, b_max, length))\\r\\nreturn 0;\\r\\nif (memcmp(a_min, a_max, length) > 0 ||\\r\\nmemcmp(b_min, b_max, length) > 0)\\r\\nreturn 0;\\r\\nif (memcmp(a_max, b_min, length) >= 0)\\r\\nreturn 0;\\r\\nfor (j = length - 1; j >= 0 && b_min[j]-- == 0x00; j--) ;\\r\\nif (memcmp(a_max, b_min, length) == 0) {\\r\\nIPAddressOrRange *merged;\\r\\nif (!make_addressRange(&merged, a_min, b_max, length))\\r\\nreturn 0;\\r\\n(void)sk_IPAddressOrRange_set(aors, i, merged);\\r\\n(void)sk_IPAddressOrRange_delete(aors, i + 1);\\r\\nIPAddressOrRange_free(a);\\r\\nIPAddressOrRange_free(b);\\r\\n--i;\\r\\ncontinue;\\r\\n}\\r\\n}\\r\\nj = sk_IPAddressOrRange_num(aors) - 1;\\r\\n{\\r\\nIPAddressOrRange *a = sk_IPAddressOrRange_value(aors, j);\\r\\nif (a != NULL && a->type == IPAddressOrRange_addressRange) {\\r\\nunsigned char a_min[ADDR_RAW_BUF_LEN], a_max[ADDR_RAW_BUF_LEN];\\r\\nextract_min_max(a, a_min, a_max, length);\\r\\nif (memcmp(a_min, a_max, length) > 0)\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint v3_addr_canonize(IPAddrBlocks *addr)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\\r\\nIPAddressFamily *f = sk_IPAddressFamily_value(addr, i);\\r\\nif (f->ipAddressChoice->type == IPAddressChoice_addressesOrRanges &&\\r\\n!IPAddressOrRanges_canonize(f->ipAddressChoice->\\r\\nu.addressesOrRanges,\\r\\nv3_addr_get_afi(f)))\\r\\nreturn 0;\\r\\n}\\r\\n(void)sk_IPAddressFamily_set_cmp_func(addr, IPAddressFamily_cmp);\\r\\nsk_IPAddressFamily_sort(addr);\\r\\nOPENSSL_assert(v3_addr_is_canonical(addr));\\r\\nreturn 1;\\r\\n}\\r\\nint v3_addr_inherits(IPAddrBlocks *addr)\\r\\n{\\r\\nint i;\\r\\nif (addr == NULL)\\r\\nreturn 0;\\r\\nfor (i = 0; i < sk_IPAddressFamily_num(addr); i++) {\\r\\nIPAddressFamily *f = sk_IPAddressFamily_value(addr, i);\\r\\nif (f->ipAddressChoice->type == IPAddressChoice_inherit)\\r\\nreturn 1;\\r\\n}\\r\\nreturn 0;\\r\\n}\\r\\nstatic int addr_contains(IPAddressOrRanges *parent,\\r\\nIPAddressOrRanges *child, int length)\\r\\n{\\r\\nunsigned char p_min[ADDR_RAW_BUF_LEN], p_max[ADDR_RAW_BUF_LEN];\\r\\nunsigned char c_min[ADDR_RAW_BUF_LEN], c_max[ADDR_RAW_BUF_LEN];\\r\\nint p, c;\\r\\nif (child == NULL || parent == child)\\r\\nreturn 1;\\r\\nif (parent == NULL)\\r\\nreturn 0;\\r\\np = 0;\\r\\nfor (c = 0; c < sk_IPAddressOrRange_num(child); c++) {\\r\\nif (!extract_min_max(sk_IPAddressOrRange_value(child, c),\\r\\nc_min, c_max, length))\\r\\nreturn -1;\\r\\nfor (;; p++) {\\r\\nif (p >= sk_IPAddressOrRange_num(parent))\\r\\nreturn 0;\\r\\nif (!extract_min_max(sk_IPAddressOrRange_value(parent, p),\\r\\np_min, p_max, length))\\r\\nreturn 0;\\r\\nif (memcmp(p_max, c_max, length) < 0)\\r\\ncontinue;\\r\\nif (memcmp(p_min, c_min, length) > 0)\\r\\nreturn 0;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint v3_addr_subset(IPAddrBlocks *a, IPAddrBlocks *b)\\r\\n{\\r\\nint i;\\r\\nif (a == NULL || a == b)\\r\\nreturn 1;\\r\\nif (b == NULL || v3_addr_inherits(a) || v3_addr_inherits(b))\\r\\nreturn 0;\\r\\n(void)sk_IPAddressFamily_set_cmp_func(b, IPAddressFamily_cmp);\\r\\nfor (i = 0; i < sk_IPAddressFamily_num(a); i++) {\\r\\nIPAddressFamily *fa = sk_IPAddressFamily_value(a, i);\\r\\nint j = sk_IPAddressFamily_find(b, fa);\\r\\nIPAddressFamily *fb;\\r\\nfb = sk_IPAddressFamily_value(b, j);\\r\\nif (fb == NULL)\\r\\nreturn 0;\\r\\nif (!addr_contains(fb->ipAddressChoice->u.addressesOrRanges,\\r\\nfa->ipAddressChoice->u.addressesOrRanges,\\r\\nlength_from_afi(v3_addr_get_afi(fb))))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nint v3_addr_validate_path(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn v3_addr_validate_path_internal(ctx, ctx->chain, NULL);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_i_cbc_c", "target": 0, "func": "void idea_cbc_encrypt(const unsigned char *in, unsigned char *out,\\r\\nlong length, IDEA_KEY_SCHEDULE *ks, unsigned char *iv,\\r\\nint encrypt)\\r\\n{\\r\\nregister unsigned long tin0, tin1;\\r\\nregister unsigned long tout0, tout1, xor0, xor1;\\r\\nregister long l = length;\\r\\nunsigned long tin[2];\\r\\nif (encrypt) {\\r\\nn2l(iv, tout0);\\r\\nn2l(iv, tout1);\\r\\niv -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nn2l(in, tin0);\\r\\nn2l(in, tin1);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nidea_encrypt(tin, ks);\\r\\ntout0 = tin[0];\\r\\nl2n(tout0, out);\\r\\ntout1 = tin[1];\\r\\nl2n(tout1, out);\\r\\n}\\r\\nif (l != -8) {\\r\\nn2ln(in, tin0, tin1, l + 8);\\r\\ntin0 ^= tout0;\\r\\ntin1 ^= tout1;\\r\\ntin[0] = tin0;\\r\\ntin[1] = tin1;\\r\\nidea_encrypt(tin, ks);\\r\\ntout0 = tin[0];\\r\\nl2n(tout0, out);\\r\\ntout1 = tin[1];\\r\\nl2n(tout1, out);\\r\\n}\\r\\nl2n(tout0, iv);\\r\\nl2n(tout1, iv);\\r\\n} else {\\r\\nn2l(iv, xor0);\\r\\nn2l(iv, xor1);\\r\\niv -= 8;\\r\\nfor (l -= 8; l >= 0; l -= 8) {\\r\\nn2l(in, tin0);\\r\\ntin[0] = tin0;\\r\\nn2l(in, tin1);\\r\\ntin[1] = tin1;\\r\\nidea_encrypt(tin, ks);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2n(tout0, out);\\r\\nl2n(tout1, out);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nif (l != -8) {\\r\\nn2l(in, tin0);\\r\\ntin[0] = tin0;\\r\\nn2l(in, tin1);\\r\\ntin[1] = tin1;\\r\\nidea_encrypt(tin, ks);\\r\\ntout0 = tin[0] ^ xor0;\\r\\ntout1 = tin[1] ^ xor1;\\r\\nl2nn(tout0, tout1, out, l + 8);\\r\\nxor0 = tin0;\\r\\nxor1 = tin1;\\r\\n}\\r\\nl2n(xor0, iv);\\r\\nl2n(xor1, iv);\\r\\n}\\r\\ntin0 = tin1 = tout0 = tout1 = xor0 = xor1 = 0;\\r\\ntin[0] = tin[1] = 0;\\r\\n}\\r\\nvoid idea_encrypt(unsigned long *d, IDEA_KEY_SCHEDULE *key)\\r\\n{\\r\\nregister IDEA_INT *p;\\r\\nregister unsigned long x1, x2, x3, x4, t0, t1, ul;\\r\\nx2 = d[0];\\r\\nx1 = (x2 >> 16);\\r\\nx4 = d[1];\\r\\nx3 = (x4 >> 16);\\r\\np = &(key->data[0][0]);\\r\\nE_IDEA(0);\\r\\nE_IDEA(1);\\r\\nE_IDEA(2);\\r\\nE_IDEA(3);\\r\\nE_IDEA(4);\\r\\nE_IDEA(5);\\r\\nE_IDEA(6);\\r\\nE_IDEA(7);\\r\\nx1 &= 0xffff;\\r\\nidea_mul(x1, x1, *p, ul);\\r\\np++;\\r\\nt0 = x3 + *(p++);\\r\\nt1 = x2 + *(p++);\\r\\nx4 &= 0xffff;\\r\\nidea_mul(x4, x4, *p, ul);\\r\\nd[0] = (t0 & 0xffff) | ((x1 & 0xffff) << 16);\\r\\nd[1] = (x4 & 0xffff) | ((t1 & 0xffff) << 16);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_denc_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL, *dout = NULL;\\r\\nX509 *rcert = NULL;\\r\\nSTACK_OF(X509) *recips = NULL;\\r\\nCMS_ContentInfo *cms = NULL;\\r\\nint ret = 1;\\r\\nint flags = CMS_STREAM | CMS_DETACHED;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\ntbio = BIO_new_file(\"signer.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\nrcert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nif (!rcert)\\r\\ngoto err;\\r\\nrecips = sk_X509_new_null();\\r\\nif (!recips || !sk_X509_push(recips, rcert))\\r\\ngoto err;\\r\\nrcert = NULL;\\r\\nin = BIO_new_file(\"encr.txt\", \"r\");\\r\\ndout = BIO_new_file(\"smencr.out\", \"wb\");\\r\\nif (!in)\\r\\ngoto err;\\r\\ncms = CMS_encrypt(recips, in, EVP_des_ede3_cbc(), flags);\\r\\nif (!cms)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smencr.pem\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!CMS_final(cms, in, dout, flags))\\r\\ngoto err;\\r\\nif (!PEM_write_bio_CMS(out, cms))\\r\\ngoto err;\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Encrypting Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nif (rcert)\\r\\nX509_free(rcert);\\r\\nif (recips)\\r\\nsk_X509_pop_free(recips, X509_free);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (dout)\\r\\nBIO_free(dout);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p12_crt_c", "target": 0, "func": "static int copy_bag_attr(PKCS12_SAFEBAG *bag, EVP_PKEY *pkey, int nid)\\r\\n{\\r\\nint idx;\\r\\nX509_ATTRIBUTE *attr;\\r\\nidx = EVP_PKEY_get_attr_by_NID(pkey, nid, -1);\\r\\nif (idx < 0)\\r\\nreturn 1;\\r\\nattr = EVP_PKEY_get_attr(pkey, idx);\\r\\nif (!X509at_add1_attr(&bag->attrib, attr))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_rc4_hmac_md5_c", "target": 0, "func": "static int rc4_hmac_md5_init_key(EVP_CIPHER_CTX *ctx,\\r\\nconst unsigned char *inkey,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nEVP_RC4_HMAC_MD5 *key = data(ctx);\\r\\nRC4_set_key(&key->ks, EVP_CIPHER_CTX_key_length(ctx), inkey);\\r\\nMD5_Init(&key->head);\\r\\nkey->tail = key->head;\\r\\nkey->md = key->head;\\r\\nkey->payload_length = NO_PAYLOAD_LENGTH;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rc4_hmac_md5_cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\\r\\nconst unsigned char *in, size_t len)\\r\\n{\\r\\nEVP_RC4_HMAC_MD5 *key = data(ctx);\\r\\n# if defined(STITCHED_CALL)\\r\\nsize_t rc4_off = 32 - 1 - (key->ks.x & (32 - 1)),\\r\\nmd5_off = MD5_CBLOCK - key->md.num, blocks;\\r\\nunsigned int l;\\r\\nextern unsigned int OPENSSL_ia32cap_P[];\\r\\n# endif\\r\\nsize_t plen = key->payload_length;\\r\\nif (plen != NO_PAYLOAD_LENGTH && len != (plen + MD5_DIGEST_LENGTH))\\r\\nreturn 0;\\r\\nif (ctx->encrypt) {\\r\\nif (plen == NO_PAYLOAD_LENGTH)\\r\\nplen = len;\\r\\n# if defined(STITCHED_CALL)\\r\\nif (rc4_off > md5_off)\\r\\nmd5_off += MD5_CBLOCK;\\r\\nif (plen > md5_off && (blocks = (plen - md5_off) / MD5_CBLOCK) &&\\r\\n(OPENSSL_ia32cap_P[0] & (1 << 20)) == 0) {\\r\\nMD5_Update(&key->md, in, md5_off);\\r\\nRC4(&key->ks, rc4_off, in, out);\\r\\nrc4_md5_enc(&key->ks, in + rc4_off, out + rc4_off,\\r\\n&key->md, in + md5_off, blocks);\\r\\nblocks *= MD5_CBLOCK;\\r\\nrc4_off += blocks;\\r\\nmd5_off += blocks;\\r\\nkey->md.Nh += blocks >> 29;\\r\\nkey->md.Nl += blocks <<= 3;\\r\\nif (key->md.Nl < (unsigned int)blocks)\\r\\nkey->md.Nh++;\\r\\n} else {\\r\\nrc4_off = 0;\\r\\nmd5_off = 0;\\r\\n}\\r\\n# endif\\r\\nMD5_Update(&key->md, in + md5_off, plen - md5_off);\\r\\nif (plen != len) {\\r\\nif (in != out)\\r\\nmemcpy(out + rc4_off, in + rc4_off, plen - rc4_off);\\r\\nMD5_Final(out + plen, &key->md);\\r\\nkey->md = key->tail;\\r\\nMD5_Update(&key->md, out + plen, MD5_DIGEST_LENGTH);\\r\\nMD5_Final(out + plen, &key->md);\\r\\nRC4(&key->ks, len - rc4_off, out + rc4_off, out + rc4_off);\\r\\n} else {\\r\\nRC4(&key->ks, len - rc4_off, in + rc4_off, out + rc4_off);\\r\\n}\\r\\n} else {\\r\\nunsigned char mac[MD5_DIGEST_LENGTH];\\r\\n# if defined(STITCHED_CALL)\\r\\nif (md5_off > rc4_off)\\r\\nrc4_off += 2 * MD5_CBLOCK;\\r\\nelse\\r\\nrc4_off += MD5_CBLOCK;\\r\\nif (len > rc4_off && (blocks = (len - rc4_off) / MD5_CBLOCK) &&\\r\\n(OPENSSL_ia32cap_P[0] & (1 << 20)) == 0) {\\r\\nRC4(&key->ks, rc4_off, in, out);\\r\\nMD5_Update(&key->md, out, md5_off);\\r\\nrc4_md5_enc(&key->ks, in + rc4_off, out + rc4_off,\\r\\n&key->md, out + md5_off, blocks);\\r\\nblocks *= MD5_CBLOCK;\\r\\nrc4_off += blocks;\\r\\nmd5_off += blocks;\\r\\nl = (key->md.Nl + (blocks << 3)) & 0xffffffffU;\\r\\nif (l < key->md.Nl)\\r\\nkey->md.Nh++;\\r\\nkey->md.Nl = l;\\r\\nkey->md.Nh += blocks >> 29;\\r\\n} else {\\r\\nmd5_off = 0;\\r\\nrc4_off = 0;\\r\\n}\\r\\n# endif\\r\\nRC4(&key->ks, len - rc4_off, in + rc4_off, out + rc4_off);\\r\\nif (plen != NO_PAYLOAD_LENGTH) {\\r\\nMD5_Update(&key->md, out + md5_off, plen - md5_off);\\r\\nMD5_Final(mac, &key->md);\\r\\nkey->md = key->tail;\\r\\nMD5_Update(&key->md, mac, MD5_DIGEST_LENGTH);\\r\\nMD5_Final(mac, &key->md);\\r\\nif (memcmp(out + plen, mac, MD5_DIGEST_LENGTH))\\r\\nreturn 0;\\r\\n} else {\\r\\nMD5_Update(&key->md, out + md5_off, len - md5_off);\\r\\n}\\r\\n}\\r\\nkey->payload_length = NO_PAYLOAD_LENGTH;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int rc4_hmac_md5_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\\r\\nvoid *ptr)\\r\\n{\\r\\nEVP_RC4_HMAC_MD5 *key = data(ctx);\\r\\nswitch (type) {\\r\\ncase EVP_CTRL_AEAD_SET_MAC_KEY:\\r\\n{\\r\\nunsigned int i;\\r\\nunsigned char hmac_key[64];\\r\\nmemset(hmac_key, 0, sizeof(hmac_key));\\r\\nif (arg > (int)sizeof(hmac_key)) {\\r\\nMD5_Init(&key->head);\\r\\nMD5_Update(&key->head, ptr, arg);\\r\\nMD5_Final(hmac_key, &key->head);\\r\\n} else {\\r\\nmemcpy(hmac_key, ptr, arg);\\r\\n}\\r\\nfor (i = 0; i < sizeof(hmac_key); i++)\\r\\nhmac_key[i] ^= 0x36;\\r\\nMD5_Init(&key->head);\\r\\nMD5_Update(&key->head, hmac_key, sizeof(hmac_key));\\r\\nfor (i = 0; i < sizeof(hmac_key); i++)\\r\\nhmac_key[i] ^= 0x36 ^ 0x5c;\\r\\nMD5_Init(&key->tail);\\r\\nMD5_Update(&key->tail, hmac_key, sizeof(hmac_key));\\r\\nreturn 1;\\r\\n}\\r\\ncase EVP_CTRL_AEAD_TLS1_AAD:\\r\\n{\\r\\nunsigned char *p = ptr;\\r\\nunsigned int len = p[arg - 2] << 8 | p[arg - 1];\\r\\nif (!ctx->encrypt) {\\r\\nlen -= MD5_DIGEST_LENGTH;\\r\\np[arg - 2] = len >> 8;\\r\\np[arg - 1] = len;\\r\\n}\\r\\nkey->payload_length = len;\\r\\nkey->md = key->head;\\r\\nMD5_Update(&key->md, p, arg);\\r\\nreturn MD5_DIGEST_LENGTH;\\r\\n}\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nconst EVP_CIPHER *EVP_rc4_hmac_md5(void)\\r\\n{\\r\\nreturn (&r4_hmac_md5_cipher);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_pwri_c", "target": 0, "func": "int CMS_RecipientInfo_set0_password(CMS_RecipientInfo *ri,\\r\\nunsigned char *pass, ossl_ssize_t passlen)\\r\\n{\\r\\nCMS_PasswordRecipientInfo *pwri;\\r\\nif (ri->type != CMS_RECIPINFO_PASS) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_SET0_PASSWORD, CMS_R_NOT_PWRI);\\r\\nreturn 0;\\r\\n}\\r\\npwri = ri->d.pwri;\\r\\npwri->pass = pass;\\r\\nif (pass && passlen < 0)\\r\\npasslen = strlen((char *)pass);\\r\\npwri->passlen = passlen;\\r\\nreturn 1;\\r\\n}\\r\\nCMS_RecipientInfo *CMS_add0_recipient_password(CMS_ContentInfo *cms,\\r\\nint iter, int wrap_nid,\\r\\nint pbe_nid,\\r\\nunsigned char *pass,\\r\\nossl_ssize_t passlen,\\r\\nconst EVP_CIPHER *kekciph)\\r\\n{\\r\\nCMS_RecipientInfo *ri = NULL;\\r\\nCMS_EnvelopedData *env;\\r\\nCMS_PasswordRecipientInfo *pwri;\\r\\nEVP_CIPHER_CTX ctx;\\r\\nX509_ALGOR *encalg = NULL;\\r\\nunsigned char iv[EVP_MAX_IV_LENGTH];\\r\\nint ivlen;\\r\\nenv = cms_get0_enveloped(cms);\\r\\nif (!env)\\r\\nreturn NULL;\\r\\nif (wrap_nid <= 0)\\r\\nwrap_nid = NID_id_alg_PWRI_KEK;\\r\\nif (pbe_nid <= 0)\\r\\npbe_nid = NID_id_pbkdf2;\\r\\nif (kekciph == NULL)\\r\\nkekciph = env->encryptedContentInfo->cipher;\\r\\nif (kekciph == NULL) {\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, CMS_R_NO_CIPHER);\\r\\nreturn NULL;\\r\\n}\\r\\nif (wrap_nid != NID_id_alg_PWRI_KEK) {\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD,\\r\\nCMS_R_UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM);\\r\\nreturn NULL;\\r\\n}\\r\\nencalg = X509_ALGOR_new();\\r\\nEVP_CIPHER_CTX_init(&ctx);\\r\\nif (EVP_EncryptInit_ex(&ctx, kekciph, NULL, NULL, NULL) <= 0) {\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nivlen = EVP_CIPHER_CTX_iv_length(&ctx);\\r\\nif (ivlen > 0) {\\r\\nif (RAND_pseudo_bytes(iv, ivlen) <= 0)\\r\\ngoto err;\\r\\nif (EVP_EncryptInit_ex(&ctx, NULL, NULL, NULL, iv) <= 0) {\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nencalg->parameter = ASN1_TYPE_new();\\r\\nif (!encalg->parameter) {\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_CIPHER_param_to_asn1(&ctx, encalg->parameter) <= 0) {\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD,\\r\\nCMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nencalg->algorithm = OBJ_nid2obj(EVP_CIPHER_CTX_type(&ctx));\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nri = M_ASN1_new_of(CMS_RecipientInfo);\\r\\nif (!ri)\\r\\ngoto merr;\\r\\nri->d.pwri = M_ASN1_new_of(CMS_PasswordRecipientInfo);\\r\\nif (!ri->d.pwri)\\r\\ngoto merr;\\r\\nri->type = CMS_RECIPINFO_PASS;\\r\\npwri = ri->d.pwri;\\r\\nX509_ALGOR_free(pwri->keyEncryptionAlgorithm);\\r\\npwri->keyEncryptionAlgorithm = X509_ALGOR_new();\\r\\nif (!pwri->keyEncryptionAlgorithm)\\r\\ngoto merr;\\r\\npwri->keyEncryptionAlgorithm->algorithm = OBJ_nid2obj(wrap_nid);\\r\\npwri->keyEncryptionAlgorithm->parameter = ASN1_TYPE_new();\\r\\nif (!pwri->keyEncryptionAlgorithm->parameter)\\r\\ngoto merr;\\r\\nif (!ASN1_item_pack(encalg, ASN1_ITEM_rptr(X509_ALGOR),\\r\\n&pwri->keyEncryptionAlgorithm->parameter->\\r\\nvalue.sequence))\\r\\ngoto merr;\\r\\npwri->keyEncryptionAlgorithm->parameter->type = V_ASN1_SEQUENCE;\\r\\nX509_ALGOR_free(encalg);\\r\\nencalg = NULL;\\r\\npwri->keyDerivationAlgorithm = PKCS5_pbkdf2_set(iter, NULL, 0, -1, -1);\\r\\nif (!pwri->keyDerivationAlgorithm)\\r\\ngoto err;\\r\\nCMS_RecipientInfo_set0_password(ri, pass, passlen);\\r\\npwri->version = 0;\\r\\nif (!sk_CMS_RecipientInfo_push(env->recipientInfos, ri))\\r\\ngoto merr;\\r\\nreturn ri;\\r\\nmerr:\\r\\nCMSerr(CMS_F_CMS_ADD0_RECIPIENT_PASSWORD, ERR_R_MALLOC_FAILURE);\\r\\nerr:\\r\\nEVP_CIPHER_CTX_cleanup(&ctx);\\r\\nif (ri)\\r\\nM_ASN1_free_of(ri, CMS_RecipientInfo);\\r\\nif (encalg)\\r\\nX509_ALGOR_free(encalg);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int kek_unwrap_key(unsigned char *out, size_t *outlen,\\r\\nconst unsigned char *in, size_t inlen,\\r\\nEVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nsize_t blocklen = EVP_CIPHER_CTX_block_size(ctx);\\r\\nunsigned char *tmp;\\r\\nint outl, rv = 0;\\r\\nif (inlen < 2 * blocklen) {\\r\\nreturn 0;\\r\\n}\\r\\nif (inlen % blocklen) {\\r\\nreturn 0;\\r\\n}\\r\\ntmp = OPENSSL_malloc(inlen);\\r\\nEVP_DecryptUpdate(ctx, tmp + inlen - 2 * blocklen, &outl,\\r\\nin + inlen - 2 * blocklen, blocklen * 2);\\r\\nEVP_DecryptUpdate(ctx, tmp, &outl, tmp + inlen - blocklen, blocklen);\\r\\nEVP_DecryptUpdate(ctx, tmp, &outl, in, inlen - blocklen);\\r\\nEVP_DecryptInit_ex(ctx, NULL, NULL, NULL, NULL);\\r\\nEVP_DecryptUpdate(ctx, tmp, &outl, tmp, inlen);\\r\\nif (((tmp[1] ^ tmp[4]) & (tmp[2] ^ tmp[5]) & (tmp[3] ^ tmp[6])) != 0xff) {\\r\\ngoto err;\\r\\n}\\r\\nif (inlen < (size_t)(tmp[0] - 4)) {\\r\\ngoto err;\\r\\n}\\r\\n*outlen = (size_t)tmp[0];\\r\\nmemcpy(out, tmp + 4, *outlen);\\r\\nrv = 1;\\r\\nerr:\\r\\nOPENSSL_cleanse(tmp, inlen);\\r\\nOPENSSL_free(tmp);\\r\\nreturn rv;\\r\\n}\\r\\nstatic int kek_wrap_key(unsigned char *out, size_t *outlen,\\r\\nconst unsigned char *in, size_t inlen,\\r\\nEVP_CIPHER_CTX *ctx)\\r\\n{\\r\\nsize_t blocklen = EVP_CIPHER_CTX_block_size(ctx);\\r\\nsize_t olen;\\r\\nint dummy;\\r\\nolen = (inlen + 4 + blocklen - 1) / blocklen;\\r\\nolen *= blocklen;\\r\\nif (olen < 2 * blocklen) {\\r\\nreturn 0;\\r\\n}\\r\\nif (inlen > 0xFF) {\\r\\nreturn 0;\\r\\n}\\r\\nif (out) {\\r\\nout[0] = (unsigned char)inlen;\\r\\nout[1] = in[0] ^ 0xFF;\\r\\nout[2] = in[1] ^ 0xFF;\\r\\nout[3] = in[2] ^ 0xFF;\\r\\nmemcpy(out + 4, in, inlen);\\r\\nif (olen > inlen + 4)\\r\\nRAND_pseudo_bytes(out + 4 + inlen, olen - 4 - inlen);\\r\\nEVP_EncryptUpdate(ctx, out, &dummy, out, olen);\\r\\nEVP_EncryptUpdate(ctx, out, &dummy, out, olen);\\r\\n}\\r\\n*outlen = olen;\\r\\nreturn 1;\\r\\n}\\r\\nint cms_RecipientInfo_pwri_crypt(CMS_ContentInfo *cms, CMS_RecipientInfo *ri,\\r\\nint en_de)\\r\\n{\\r\\nCMS_EncryptedContentInfo *ec;\\r\\nCMS_PasswordRecipientInfo *pwri;\\r\\nconst unsigned char *p = NULL;\\r\\nint plen;\\r\\nint r = 0;\\r\\nX509_ALGOR *algtmp, *kekalg = NULL;\\r\\nEVP_CIPHER_CTX kekctx;\\r\\nconst EVP_CIPHER *kekcipher;\\r\\nunsigned char *key = NULL;\\r\\nsize_t keylen;\\r\\nec = cms->d.envelopedData->encryptedContentInfo;\\r\\npwri = ri->d.pwri;\\r\\nEVP_CIPHER_CTX_init(&kekctx);\\r\\nif (!pwri->pass) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, CMS_R_NO_PASSWORD);\\r\\nreturn 0;\\r\\n}\\r\\nalgtmp = pwri->keyEncryptionAlgorithm;\\r\\nif (!algtmp || OBJ_obj2nid(algtmp->algorithm) != NID_id_alg_PWRI_KEK) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT,\\r\\nCMS_R_UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM);\\r\\nreturn 0;\\r\\n}\\r\\nif (algtmp->parameter->type == V_ASN1_SEQUENCE) {\\r\\np = algtmp->parameter->value.sequence->data;\\r\\nplen = algtmp->parameter->value.sequence->length;\\r\\nkekalg = d2i_X509_ALGOR(NULL, &p, plen);\\r\\n}\\r\\nif (kekalg == NULL) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT,\\r\\nCMS_R_INVALID_KEY_ENCRYPTION_PARAMETER);\\r\\nreturn 0;\\r\\n}\\r\\nkekcipher = EVP_get_cipherbyobj(kekalg->algorithm);\\r\\nif (!kekcipher) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, CMS_R_UNKNOWN_CIPHER);\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_CipherInit_ex(&kekctx, kekcipher, NULL, NULL, NULL, en_de))\\r\\ngoto err;\\r\\nEVP_CIPHER_CTX_set_padding(&kekctx, 0);\\r\\nif (EVP_CIPHER_asn1_to_param(&kekctx, kekalg->parameter) < 0) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT,\\r\\nCMS_R_CIPHER_PARAMETER_INITIALISATION_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nalgtmp = pwri->keyDerivationAlgorithm;\\r\\nif (EVP_PBE_CipherInit(algtmp->algorithm,\\r\\n(char *)pwri->pass, pwri->passlen,\\r\\nalgtmp->parameter, &kekctx, en_de) < 0) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, ERR_R_EVP_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (en_de) {\\r\\nif (!kek_wrap_key(NULL, &keylen, ec->key, ec->keylen, &kekctx))\\r\\ngoto err;\\r\\nkey = OPENSSL_malloc(keylen);\\r\\nif (!key)\\r\\ngoto err;\\r\\nif (!kek_wrap_key(key, &keylen, ec->key, ec->keylen, &kekctx))\\r\\ngoto err;\\r\\npwri->encryptedKey->data = key;\\r\\npwri->encryptedKey->length = keylen;\\r\\n} else {\\r\\nkey = OPENSSL_malloc(pwri->encryptedKey->length);\\r\\nif (!key) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (!kek_unwrap_key(key, &keylen,\\r\\npwri->encryptedKey->data,\\r\\npwri->encryptedKey->length, &kekctx)) {\\r\\nCMSerr(CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT, CMS_R_UNWRAP_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nec->key = key;\\r\\nec->keylen = keylen;\\r\\n}\\r\\nr = 1;\\r\\nerr:\\r\\nEVP_CIPHER_CTX_cleanup(&kekctx);\\r\\nif (!r && key)\\r\\nOPENSSL_free(key);\\r\\nX509_ALGOR_free(kekalg);\\r\\nreturn r;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_md2_dgst_c", "target": 0, "func": "const char *MD2_options(void)\\r\\n{\\r\\nif (sizeof(MD2_INT) == 1)\\r\\nreturn (\"md2(char)\");\\r\\nelse\\r\\nreturn (\"md2(int)\");\\r\\n}\\r\\nint MD2_Update(MD2_CTX *c, const unsigned char *data, size_t len)\\r\\n{\\r\\nregister UCHAR *p;\\r\\nif (len == 0)\\r\\nreturn 1;\\r\\np = c->data;\\r\\nif (c->num != 0) {\\r\\nif ((c->num + len) >= MD2_BLOCK) {\\r\\nmemcpy(&(p[c->num]), data, MD2_BLOCK - c->num);\\r\\nmd2_block(c, c->data);\\r\\ndata += (MD2_BLOCK - c->num);\\r\\nlen -= (MD2_BLOCK - c->num);\\r\\nc->num = 0;\\r\\n} else {\\r\\nmemcpy(&(p[c->num]), data, len);\\r\\nc->num += (int)len;\\r\\nreturn 1;\\r\\n}\\r\\n}\\r\\nwhile (len >= MD2_BLOCK) {\\r\\nmd2_block(c, data);\\r\\ndata += MD2_BLOCK;\\r\\nlen -= MD2_BLOCK;\\r\\n}\\r\\nmemcpy(p, data, len);\\r\\nc->num = (int)len;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void md2_block(MD2_CTX *c, const unsigned char *d)\\r\\n{\\r\\nregister MD2_INT t, *sp1, *sp2;\\r\\nregister int i, j;\\r\\nMD2_INT state[48];\\r\\nsp1 = c->state;\\r\\nsp2 = c->cksm;\\r\\nj = sp2[MD2_BLOCK - 1];\\r\\nfor (i = 0; i < 16; i++) {\\r\\nstate[i] = sp1[i];\\r\\nstate[i + 16] = t = d[i];\\r\\nstate[i + 32] = (t ^ sp1[i]);\\r\\nj = sp2[i] ^= S[t ^ j];\\r\\n}\\r\\nt = 0;\\r\\nfor (i = 0; i < 18; i++) {\\r\\nfor (j = 0; j < 48; j += 8) {\\r\\nt = state[j + 0] ^= S[t];\\r\\nt = state[j + 1] ^= S[t];\\r\\nt = state[j + 2] ^= S[t];\\r\\nt = state[j + 3] ^= S[t];\\r\\nt = state[j + 4] ^= S[t];\\r\\nt = state[j + 5] ^= S[t];\\r\\nt = state[j + 6] ^= S[t];\\r\\nt = state[j + 7] ^= S[t];\\r\\n}\\r\\nt = (t + i) & 0xff;\\r\\n}\\r\\nmemcpy(sp1, state, 16 * sizeof(MD2_INT));\\r\\nOPENSSL_cleanse(state, 48 * sizeof(MD2_INT));\\r\\n}\\r\\nint MD2_Final(unsigned char *md, MD2_CTX *c)\\r\\n{\\r\\nint i, v;\\r\\nregister UCHAR *cp;\\r\\nregister MD2_INT *p1, *p2;\\r\\ncp = c->data;\\r\\np1 = c->state;\\r\\np2 = c->cksm;\\r\\nv = MD2_BLOCK - c->num;\\r\\nfor (i = c->num; i < MD2_BLOCK; i++)\\r\\ncp[i] = (UCHAR) v;\\r\\nmd2_block(c, cp);\\r\\nfor (i = 0; i < MD2_BLOCK; i++)\\r\\ncp[i] = (UCHAR) p2[i];\\r\\nmd2_block(c, cp);\\r\\nfor (i = 0; i < 16; i++)\\r\\nmd[i] = (UCHAR) (p1[i] & 0xff);\\r\\nmemset((char *)&c, 0, sizeof(c));\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_curve_c", "target": 0, "func": "static EC_GROUP *ec_group_new_from_data(const ec_list_element curve)\\r\\n{\\r\\nEC_GROUP *group = NULL;\\r\\nEC_POINT *P = NULL;\\r\\nBN_CTX *ctx = NULL;\\r\\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *x = NULL, *y = NULL, *order =\\r\\nNULL;\\r\\nint ok = 0;\\r\\nint seed_len, param_len;\\r\\nconst EC_METHOD *meth;\\r\\nconst EC_CURVE_DATA *data;\\r\\nconst unsigned char *params;\\r\\nif ((ctx = BN_CTX_new()) == NULL) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ndata = curve.data;\\r\\nseed_len = data->seed_len;\\r\\nparam_len = data->param_len;\\r\\nparams = (const unsigned char *)(data + 1);\\r\\nparams += seed_len;\\r\\nif (!(p = BN_bin2bn(params + 0 * param_len, param_len, NULL))\\r\\n|| !(a = BN_bin2bn(params + 1 * param_len, param_len, NULL))\\r\\n|| !(b = BN_bin2bn(params + 2 * param_len, param_len, NULL))) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (curve.meth != 0) {\\r\\nmeth = curve.meth();\\r\\nif (((group = EC_GROUP_new(meth)) == NULL) ||\\r\\n(!(group->meth->group_set_curve(group, p, a, b, ctx)))) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n} else if (data->field_type == NID_X9_62_prime_field) {\\r\\nif ((group = EC_GROUP_new_curve_GFp(p, a, b, ctx)) == NULL) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#ifndef OPENSSL_NO_EC2M\\r\\nelse {\\r\\nif ((group = EC_GROUP_new_curve_GF2m(p, a, b, ctx)) == NULL) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n#endif\\r\\nif ((P = EC_POINT_new(group)) == NULL) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!(x = BN_bin2bn(params + 3 * param_len, param_len, NULL))\\r\\n|| !(y = BN_bin2bn(params + 4 * param_len, param_len, NULL))) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!(order = BN_bin2bn(params + 5 * param_len, param_len, NULL))\\r\\n|| !BN_set_word(x, (BN_ULONG)data->cofactor)) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_BN_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (!EC_GROUP_set_generator(group, P, order, x)) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\nif (seed_len) {\\r\\nif (!EC_GROUP_set_seed(group, params - seed_len, seed_len)) {\\r\\nECerr(EC_F_EC_GROUP_NEW_FROM_DATA, ERR_R_EC_LIB);\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nok = 1;\\r\\nerr:\\r\\nif (!ok) {\\r\\nEC_GROUP_free(group);\\r\\ngroup = NULL;\\r\\n}\\r\\nif (P)\\r\\nEC_POINT_free(P);\\r\\nif (ctx)\\r\\nBN_CTX_free(ctx);\\r\\nif (p)\\r\\nBN_free(p);\\r\\nif (a)\\r\\nBN_free(a);\\r\\nif (b)\\r\\nBN_free(b);\\r\\nif (order)\\r\\nBN_free(order);\\r\\nif (x)\\r\\nBN_free(x);\\r\\nif (y)\\r\\nBN_free(y);\\r\\nreturn group;\\r\\n}\\r\\nEC_GROUP *EC_GROUP_new_by_curve_name(int nid)\\r\\n{\\r\\nsize_t i;\\r\\nEC_GROUP *ret = NULL;\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn FIPS_ec_group_new_by_curve_name(nid);\\r\\n#endif\\r\\nif (nid <= 0)\\r\\nreturn NULL;\\r\\nfor (i = 0; i < curve_list_length; i++)\\r\\nif (curve_list[i].nid == nid) {\\r\\nret = ec_group_new_from_data(curve_list[i]);\\r\\nbreak;\\r\\n}\\r\\nif (ret == NULL) {\\r\\nECerr(EC_F_EC_GROUP_NEW_BY_CURVE_NAME, EC_R_UNKNOWN_GROUP);\\r\\nreturn NULL;\\r\\n}\\r\\nEC_GROUP_set_curve_name(ret, nid);\\r\\nreturn ret;\\r\\n}\\r\\nsize_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems)\\r\\n{\\r\\nsize_t i, min;\\r\\nif (r == NULL || nitems == 0)\\r\\nreturn curve_list_length;\\r\\nmin = nitems < curve_list_length ? nitems : curve_list_length;\\r\\nfor (i = 0; i < min; i++) {\\r\\nr[i].nid = curve_list[i].nid;\\r\\nr[i].comment = curve_list[i].comment;\\r\\n}\\r\\nreturn curve_list_length;\\r\\n}\\r\\nconst char *EC_curve_nid2nist(int nid)\\r\\n{\\r\\nsize_t i;\\r\\nfor (i = 0; i < sizeof(nist_curves) / sizeof(EC_NIST_NAME); i++) {\\r\\nif (nist_curves[i].nid == nid)\\r\\nreturn nist_curves[i].name;\\r\\n}\\r\\nreturn NULL;\\r\\n}\\r\\nint EC_curve_nist2nid(const char *name)\\r\\n{\\r\\nsize_t i;\\r\\nfor (i = 0; i < sizeof(nist_curves) / sizeof(EC_NIST_NAME); i++) {\\r\\nif (!strcmp(nist_curves[i].name, name))\\r\\nreturn nist_curves[i].nid;\\r\\n}\\r\\nreturn NID_undef;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cmll_ctr_c", "target": 0, "func": "void Camellia_ctr128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const CAMELLIA_KEY *key,\\r\\nunsigned char ivec[CAMELLIA_BLOCK_SIZE],\\r\\nunsigned char ecount_buf[CAMELLIA_BLOCK_SIZE],\\r\\nunsigned int *num)\\r\\n{\\r\\nCRYPTO_ctr128_encrypt(in, out, length, key, ivec, ecount_buf, num,\\r\\n(block128_f) Camellia_encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_m_md4_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn MD4_Init(ctx->md_data);\\r\\n}\\r\\nstatic int update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn MD4_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn MD4_Final(md, ctx->md_data);\\r\\n}\\r\\nconst EVP_MD *EVP_md4(void)\\r\\n{\\r\\nreturn (&md4_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bn_nist_c", "target": 0, "func": "const BIGNUM *BN_get0_nist_prime_192(void)\\r\\n{\\r\\nreturn &_bignum_nist_p_192;\\r\\n}\\r\\nconst BIGNUM *BN_get0_nist_prime_224(void)\\r\\n{\\r\\nreturn &_bignum_nist_p_224;\\r\\n}\\r\\nconst BIGNUM *BN_get0_nist_prime_256(void)\\r\\n{\\r\\nreturn &_bignum_nist_p_256;\\r\\n}\\r\\nconst BIGNUM *BN_get0_nist_prime_384(void)\\r\\n{\\r\\nreturn &_bignum_nist_p_384;\\r\\n}\\r\\nconst BIGNUM *BN_get0_nist_prime_521(void)\\r\\n{\\r\\nreturn &_bignum_nist_p_521;\\r\\n}\\r\\nstatic void nist_cp_bn_0(BN_ULONG *dst, const BN_ULONG *src, int top, int max)\\r\\n{\\r\\nint i;\\r\\n#ifdef BN_DEBUG\\r\\nOPENSSL_assert(top <= max);\\r\\n#endif\\r\\nfor (i = 0; i < top; i++)\\r\\ndst[i] = src[i];\\r\\nfor (; i < max; i++)\\r\\ndst[i] = 0;\\r\\n}\\r\\nstatic void nist_cp_bn(BN_ULONG *dst, const BN_ULONG *src, int top)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < top; i++)\\r\\ndst[i] = src[i];\\r\\n}\\r\\nint BN_nist_mod_192(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint top = a->top, i;\\r\\nint carry;\\r\\nregister BN_ULONG *r_d, *a_d = a->d;\\r\\nunion {\\r\\nBN_ULONG bn[BN_NIST_192_TOP];\\r\\nunsigned int ui[BN_NIST_192_TOP * sizeof(BN_ULONG) /\\r\\nsizeof(unsigned int)];\\r\\n} buf;\\r\\nBN_ULONG c_d[BN_NIST_192_TOP], *res;\\r\\nPTR_SIZE_INT mask;\\r\\nstatic const BIGNUM _bignum_nist_p_192_sqr = {\\r\\n(BN_ULONG *)_nist_p_192_sqr,\\r\\nsizeof(_nist_p_192_sqr) / sizeof(_nist_p_192_sqr[0]),\\r\\nsizeof(_nist_p_192_sqr) / sizeof(_nist_p_192_sqr[0]),\\r\\n0, BN_FLG_STATIC_DATA\\r\\n};\\r\\nfield = &_bignum_nist_p_192;\\r\\nif (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_192_sqr) >= 0)\\r\\nreturn BN_nnmod(r, a, field, ctx);\\r\\ni = BN_ucmp(field, a);\\r\\nif (i == 0) {\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n} else if (i > 0)\\r\\nreturn (r == a) ? 1 : (BN_copy(r, a) != NULL);\\r\\nif (r != a) {\\r\\nif (!bn_wexpand(r, BN_NIST_192_TOP))\\r\\nreturn 0;\\r\\nr_d = r->d;\\r\\nnist_cp_bn(r_d, a_d, BN_NIST_192_TOP);\\r\\n} else\\r\\nr_d = a_d;\\r\\nnist_cp_bn_0(buf.bn, a_d + BN_NIST_192_TOP, top - BN_NIST_192_TOP,\\r\\nBN_NIST_192_TOP);\\r\\n#if defined(NIST_INT64)\\r\\n{\\r\\nNIST_INT64 acc;\\r\\nunsigned int *rp = (unsigned int *)r_d;\\r\\nconst unsigned int *bp = (const unsigned int *)buf.ui;\\r\\nacc = rp[0];\\r\\nacc += bp[3 * 2 - 6];\\r\\nacc += bp[5 * 2 - 6];\\r\\nrp[0] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[1];\\r\\nacc += bp[3 * 2 - 5];\\r\\nacc += bp[5 * 2 - 5];\\r\\nrp[1] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[2];\\r\\nacc += bp[3 * 2 - 6];\\r\\nacc += bp[4 * 2 - 6];\\r\\nacc += bp[5 * 2 - 6];\\r\\nrp[2] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[3];\\r\\nacc += bp[3 * 2 - 5];\\r\\nacc += bp[4 * 2 - 5];\\r\\nacc += bp[5 * 2 - 5];\\r\\nrp[3] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[4];\\r\\nacc += bp[4 * 2 - 6];\\r\\nacc += bp[5 * 2 - 6];\\r\\nrp[4] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[5];\\r\\nacc += bp[4 * 2 - 5];\\r\\nacc += bp[5 * 2 - 5];\\r\\nrp[5] = (unsigned int)acc;\\r\\ncarry = (int)(acc >> 32);\\r\\n}\\r\\n#else\\r\\n{\\r\\nBN_ULONG t_d[BN_NIST_192_TOP];\\r\\nnist_set_192(t_d, buf.bn, 0, 3, 3);\\r\\ncarry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);\\r\\nnist_set_192(t_d, buf.bn, 4, 4, 0);\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);\\r\\nnist_set_192(t_d, buf.bn, 5, 5, 5)\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_192_TOP);\\r\\n}\\r\\n#endif\\r\\nif (carry > 0)\\r\\ncarry =\\r\\n(int)bn_sub_words(r_d, r_d, _nist_p_192[carry - 1],\\r\\nBN_NIST_192_TOP);\\r\\nelse\\r\\ncarry = 1;\\r\\nmask =\\r\\n0 - (PTR_SIZE_INT) bn_sub_words(c_d, r_d, _nist_p_192[0],\\r\\nBN_NIST_192_TOP);\\r\\nmask &= 0 - (PTR_SIZE_INT) carry;\\r\\nres = c_d;\\r\\nres = (BN_ULONG *)\\r\\n(((PTR_SIZE_INT) res & ~mask) | ((PTR_SIZE_INT) r_d & mask));\\r\\nnist_cp_bn(r_d, res, BN_NIST_192_TOP);\\r\\nr->top = BN_NIST_192_TOP;\\r\\nbn_correct_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint top = a->top, i;\\r\\nint carry;\\r\\nBN_ULONG *r_d, *a_d = a->d;\\r\\nunion {\\r\\nBN_ULONG bn[BN_NIST_224_TOP];\\r\\nunsigned int ui[BN_NIST_224_TOP * sizeof(BN_ULONG) /\\r\\nsizeof(unsigned int)];\\r\\n} buf;\\r\\nBN_ULONG c_d[BN_NIST_224_TOP], *res;\\r\\nPTR_SIZE_INT mask;\\r\\nunion {\\r\\nbn_addsub_f f;\\r\\nPTR_SIZE_INT p;\\r\\n} u;\\r\\nstatic const BIGNUM _bignum_nist_p_224_sqr = {\\r\\n(BN_ULONG *)_nist_p_224_sqr,\\r\\nsizeof(_nist_p_224_sqr) / sizeof(_nist_p_224_sqr[0]),\\r\\nsizeof(_nist_p_224_sqr) / sizeof(_nist_p_224_sqr[0]),\\r\\n0, BN_FLG_STATIC_DATA\\r\\n};\\r\\nfield = &_bignum_nist_p_224;\\r\\nif (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_224_sqr) >= 0)\\r\\nreturn BN_nnmod(r, a, field, ctx);\\r\\ni = BN_ucmp(field, a);\\r\\nif (i == 0) {\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n} else if (i > 0)\\r\\nreturn (r == a) ? 1 : (BN_copy(r, a) != NULL);\\r\\nif (r != a) {\\r\\nif (!bn_wexpand(r, BN_NIST_224_TOP))\\r\\nreturn 0;\\r\\nr_d = r->d;\\r\\nnist_cp_bn(r_d, a_d, BN_NIST_224_TOP);\\r\\n} else\\r\\nr_d = a_d;\\r\\n#if BN_BITS2==64\\r\\nnist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP - 1),\\r\\ntop - (BN_NIST_224_TOP - 1), BN_NIST_224_TOP);\\r\\nnist_set_224(buf.bn, c_d, 14, 13, 12, 11, 10, 9, 8);\\r\\nr_d[BN_NIST_224_TOP - 1] &= BN_MASK2l;\\r\\n#else\\r\\nnist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP,\\r\\nBN_NIST_224_TOP);\\r\\n#endif\\r\\n#if defined(NIST_INT64) && BN_BITS2!=64\\r\\n{\\r\\nNIST_INT64 acc;\\r\\nunsigned int *rp = (unsigned int *)r_d;\\r\\nconst unsigned int *bp = (const unsigned int *)buf.ui;\\r\\nacc = rp[0];\\r\\nacc -= bp[7 - 7];\\r\\nacc -= bp[11 - 7];\\r\\nrp[0] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[1];\\r\\nacc -= bp[8 - 7];\\r\\nacc -= bp[12 - 7];\\r\\nrp[1] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[2];\\r\\nacc -= bp[9 - 7];\\r\\nacc -= bp[13 - 7];\\r\\nrp[2] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[3];\\r\\nacc += bp[7 - 7];\\r\\nacc += bp[11 - 7];\\r\\nacc -= bp[10 - 7];\\r\\nrp[3] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[4];\\r\\nacc += bp[8 - 7];\\r\\nacc += bp[12 - 7];\\r\\nacc -= bp[11 - 7];\\r\\nrp[4] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[5];\\r\\nacc += bp[9 - 7];\\r\\nacc += bp[13 - 7];\\r\\nacc -= bp[12 - 7];\\r\\nrp[5] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[6];\\r\\nacc += bp[10 - 7];\\r\\nacc -= bp[13 - 7];\\r\\nrp[6] = (unsigned int)acc;\\r\\ncarry = (int)(acc >> 32);\\r\\n# if BN_BITS2==64\\r\\nrp[7] = carry;\\r\\n# endif\\r\\n}\\r\\n#else\\r\\n{\\r\\nBN_ULONG t_d[BN_NIST_224_TOP];\\r\\nnist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);\\r\\ncarry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\\r\\nnist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\\r\\nnist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);\\r\\ncarry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\\r\\nnist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);\\r\\ncarry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\\r\\n# if BN_BITS2==64\\r\\ncarry = (int)(r_d[BN_NIST_224_TOP - 1] >> 32);\\r\\n# endif\\r\\n}\\r\\n#endif\\r\\nu.f = bn_sub_words;\\r\\nif (carry > 0) {\\r\\ncarry =\\r\\n(int)bn_sub_words(r_d, r_d, _nist_p_224[carry - 1],\\r\\nBN_NIST_224_TOP);\\r\\n#if BN_BITS2==64\\r\\ncarry = (int)(~(r_d[BN_NIST_224_TOP - 1] >> 32)) & 1;\\r\\n#endif\\r\\n} else if (carry < 0) {\\r\\ncarry =\\r\\n(int)bn_add_words(r_d, r_d, _nist_p_224[-carry - 1],\\r\\nBN_NIST_224_TOP);\\r\\nmask = 0 - (PTR_SIZE_INT) carry;\\r\\nu.p = ((PTR_SIZE_INT) bn_sub_words & mask) |\\r\\n((PTR_SIZE_INT) bn_add_words & ~mask);\\r\\n} else\\r\\ncarry = 1;\\r\\nmask =\\r\\n0 - (PTR_SIZE_INT) (*u.f) (c_d, r_d, _nist_p_224[0], BN_NIST_224_TOP);\\r\\nmask &= 0 - (PTR_SIZE_INT) carry;\\r\\nres = c_d;\\r\\nres = (BN_ULONG *)(((PTR_SIZE_INT) res & ~mask) |\\r\\n((PTR_SIZE_INT) r_d & mask));\\r\\nnist_cp_bn(r_d, res, BN_NIST_224_TOP);\\r\\nr->top = BN_NIST_224_TOP;\\r\\nbn_correct_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_nist_mod_256(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint i, top = a->top;\\r\\nint carry = 0;\\r\\nregister BN_ULONG *a_d = a->d, *r_d;\\r\\nunion {\\r\\nBN_ULONG bn[BN_NIST_256_TOP];\\r\\nunsigned int ui[BN_NIST_256_TOP * sizeof(BN_ULONG) /\\r\\nsizeof(unsigned int)];\\r\\n} buf;\\r\\nBN_ULONG c_d[BN_NIST_256_TOP], *res;\\r\\nPTR_SIZE_INT mask;\\r\\nunion {\\r\\nbn_addsub_f f;\\r\\nPTR_SIZE_INT p;\\r\\n} u;\\r\\nstatic const BIGNUM _bignum_nist_p_256_sqr = {\\r\\n(BN_ULONG *)_nist_p_256_sqr,\\r\\nsizeof(_nist_p_256_sqr) / sizeof(_nist_p_256_sqr[0]),\\r\\nsizeof(_nist_p_256_sqr) / sizeof(_nist_p_256_sqr[0]),\\r\\n0, BN_FLG_STATIC_DATA\\r\\n};\\r\\nfield = &_bignum_nist_p_256;\\r\\nif (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_256_sqr) >= 0)\\r\\nreturn BN_nnmod(r, a, field, ctx);\\r\\ni = BN_ucmp(field, a);\\r\\nif (i == 0) {\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n} else if (i > 0)\\r\\nreturn (r == a) ? 1 : (BN_copy(r, a) != NULL);\\r\\nif (r != a) {\\r\\nif (!bn_wexpand(r, BN_NIST_256_TOP))\\r\\nreturn 0;\\r\\nr_d = r->d;\\r\\nnist_cp_bn(r_d, a_d, BN_NIST_256_TOP);\\r\\n} else\\r\\nr_d = a_d;\\r\\nnist_cp_bn_0(buf.bn, a_d + BN_NIST_256_TOP, top - BN_NIST_256_TOP,\\r\\nBN_NIST_256_TOP);\\r\\n#if defined(NIST_INT64)\\r\\n{\\r\\nNIST_INT64 acc;\\r\\nunsigned int *rp = (unsigned int *)r_d;\\r\\nconst unsigned int *bp = (const unsigned int *)buf.ui;\\r\\nacc = rp[0];\\r\\nacc += bp[8 - 8];\\r\\nacc += bp[9 - 8];\\r\\nacc -= bp[11 - 8];\\r\\nacc -= bp[12 - 8];\\r\\nacc -= bp[13 - 8];\\r\\nacc -= bp[14 - 8];\\r\\nrp[0] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[1];\\r\\nacc += bp[9 - 8];\\r\\nacc += bp[10 - 8];\\r\\nacc -= bp[12 - 8];\\r\\nacc -= bp[13 - 8];\\r\\nacc -= bp[14 - 8];\\r\\nacc -= bp[15 - 8];\\r\\nrp[1] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[2];\\r\\nacc += bp[10 - 8];\\r\\nacc += bp[11 - 8];\\r\\nacc -= bp[13 - 8];\\r\\nacc -= bp[14 - 8];\\r\\nacc -= bp[15 - 8];\\r\\nrp[2] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[3];\\r\\nacc += bp[11 - 8];\\r\\nacc += bp[11 - 8];\\r\\nacc += bp[12 - 8];\\r\\nacc += bp[12 - 8];\\r\\nacc += bp[13 - 8];\\r\\nacc -= bp[15 - 8];\\r\\nacc -= bp[8 - 8];\\r\\nacc -= bp[9 - 8];\\r\\nrp[3] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[4];\\r\\nacc += bp[12 - 8];\\r\\nacc += bp[12 - 8];\\r\\nacc += bp[13 - 8];\\r\\nacc += bp[13 - 8];\\r\\nacc += bp[14 - 8];\\r\\nacc -= bp[9 - 8];\\r\\nacc -= bp[10 - 8];\\r\\nrp[4] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[5];\\r\\nacc += bp[13 - 8];\\r\\nacc += bp[13 - 8];\\r\\nacc += bp[14 - 8];\\r\\nacc += bp[14 - 8];\\r\\nacc += bp[15 - 8];\\r\\nacc -= bp[10 - 8];\\r\\nacc -= bp[11 - 8];\\r\\nrp[5] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[6];\\r\\nacc += bp[14 - 8];\\r\\nacc += bp[14 - 8];\\r\\nacc += bp[15 - 8];\\r\\nacc += bp[15 - 8];\\r\\nacc += bp[14 - 8];\\r\\nacc += bp[13 - 8];\\r\\nacc -= bp[8 - 8];\\r\\nacc -= bp[9 - 8];\\r\\nrp[6] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[7];\\r\\nacc += bp[15 - 8];\\r\\nacc += bp[15 - 8];\\r\\nacc += bp[15 - 8];\\r\\nacc += bp[8 - 8];\\r\\nacc -= bp[10 - 8];\\r\\nacc -= bp[11 - 8];\\r\\nacc -= bp[12 - 8];\\r\\nacc -= bp[13 - 8];\\r\\nrp[7] = (unsigned int)acc;\\r\\ncarry = (int)(acc >> 32);\\r\\n}\\r\\n#else\\r\\n{\\r\\nBN_ULONG t_d[BN_NIST_256_TOP];\\r\\nnist_set_256(t_d, buf.bn, 15, 14, 13, 12, 11, 0, 0, 0);\\r\\nnist_set_256(c_d, buf.bn, 0, 15, 14, 13, 12, 0, 0, 0);\\r\\ncarry = (int)bn_add_words(t_d, t_d, c_d, BN_NIST_256_TOP);\\r\\n{\\r\\nregister BN_ULONG *ap, t, c;\\r\\nap = t_d;\\r\\nc = 0;\\r\\nfor (i = BN_NIST_256_TOP; i != 0; --i) {\\r\\nt = *ap;\\r\\n*(ap++) = ((t << 1) | c) & BN_MASK2;\\r\\nc = (t & BN_TBIT) ? 1 : 0;\\r\\n}\\r\\ncarry <<= 1;\\r\\ncarry |= c;\\r\\n}\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);\\r\\nnist_set_256(t_d, buf.bn, 15, 14, 0, 0, 0, 10, 9, 8);\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);\\r\\nnist_set_256(t_d, buf.bn, 8, 13, 15, 14, 13, 11, 10, 9);\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_256_TOP);\\r\\nnist_set_256(t_d, buf.bn, 10, 8, 0, 0, 0, 13, 12, 11);\\r\\ncarry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);\\r\\nnist_set_256(t_d, buf.bn, 11, 9, 0, 0, 15, 14, 13, 12);\\r\\ncarry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);\\r\\nnist_set_256(t_d, buf.bn, 12, 0, 10, 9, 8, 15, 14, 13);\\r\\ncarry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);\\r\\nnist_set_256(t_d, buf.bn, 13, 0, 11, 10, 9, 0, 15, 14);\\r\\ncarry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_256_TOP);\\r\\n}\\r\\n#endif\\r\\nu.f = bn_sub_words;\\r\\nif (carry > 0)\\r\\ncarry =\\r\\n(int)bn_sub_words(r_d, r_d, _nist_p_256[carry - 1],\\r\\nBN_NIST_256_TOP);\\r\\nelse if (carry < 0) {\\r\\ncarry =\\r\\n(int)bn_add_words(r_d, r_d, _nist_p_256[-carry - 1],\\r\\nBN_NIST_256_TOP);\\r\\nmask = 0 - (PTR_SIZE_INT) carry;\\r\\nu.p = ((PTR_SIZE_INT) bn_sub_words & mask) |\\r\\n((PTR_SIZE_INT) bn_add_words & ~mask);\\r\\n} else\\r\\ncarry = 1;\\r\\nmask =\\r\\n0 - (PTR_SIZE_INT) (*u.f) (c_d, r_d, _nist_p_256[0], BN_NIST_256_TOP);\\r\\nmask &= 0 - (PTR_SIZE_INT) carry;\\r\\nres = c_d;\\r\\nres = (BN_ULONG *)(((PTR_SIZE_INT) res & ~mask) |\\r\\n((PTR_SIZE_INT) r_d & mask));\\r\\nnist_cp_bn(r_d, res, BN_NIST_256_TOP);\\r\\nr->top = BN_NIST_256_TOP;\\r\\nbn_correct_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_nist_mod_384(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint i, top = a->top;\\r\\nint carry = 0;\\r\\nregister BN_ULONG *r_d, *a_d = a->d;\\r\\nunion {\\r\\nBN_ULONG bn[BN_NIST_384_TOP];\\r\\nunsigned int ui[BN_NIST_384_TOP * sizeof(BN_ULONG) /\\r\\nsizeof(unsigned int)];\\r\\n} buf;\\r\\nBN_ULONG c_d[BN_NIST_384_TOP], *res;\\r\\nPTR_SIZE_INT mask;\\r\\nunion {\\r\\nbn_addsub_f f;\\r\\nPTR_SIZE_INT p;\\r\\n} u;\\r\\nstatic const BIGNUM _bignum_nist_p_384_sqr = {\\r\\n(BN_ULONG *)_nist_p_384_sqr,\\r\\nsizeof(_nist_p_384_sqr) / sizeof(_nist_p_384_sqr[0]),\\r\\nsizeof(_nist_p_384_sqr) / sizeof(_nist_p_384_sqr[0]),\\r\\n0, BN_FLG_STATIC_DATA\\r\\n};\\r\\nfield = &_bignum_nist_p_384;\\r\\nif (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_384_sqr) >= 0)\\r\\nreturn BN_nnmod(r, a, field, ctx);\\r\\ni = BN_ucmp(field, a);\\r\\nif (i == 0) {\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n} else if (i > 0)\\r\\nreturn (r == a) ? 1 : (BN_copy(r, a) != NULL);\\r\\nif (r != a) {\\r\\nif (!bn_wexpand(r, BN_NIST_384_TOP))\\r\\nreturn 0;\\r\\nr_d = r->d;\\r\\nnist_cp_bn(r_d, a_d, BN_NIST_384_TOP);\\r\\n} else\\r\\nr_d = a_d;\\r\\nnist_cp_bn_0(buf.bn, a_d + BN_NIST_384_TOP, top - BN_NIST_384_TOP,\\r\\nBN_NIST_384_TOP);\\r\\n#if defined(NIST_INT64)\\r\\n{\\r\\nNIST_INT64 acc;\\r\\nunsigned int *rp = (unsigned int *)r_d;\\r\\nconst unsigned int *bp = (const unsigned int *)buf.ui;\\r\\nacc = rp[0];\\r\\nacc += bp[12 - 12];\\r\\nacc += bp[21 - 12];\\r\\nacc += bp[20 - 12];\\r\\nacc -= bp[23 - 12];\\r\\nrp[0] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[1];\\r\\nacc += bp[13 - 12];\\r\\nacc += bp[22 - 12];\\r\\nacc += bp[23 - 12];\\r\\nacc -= bp[12 - 12];\\r\\nacc -= bp[20 - 12];\\r\\nrp[1] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[2];\\r\\nacc += bp[14 - 12];\\r\\nacc += bp[23 - 12];\\r\\nacc -= bp[13 - 12];\\r\\nacc -= bp[21 - 12];\\r\\nrp[2] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[3];\\r\\nacc += bp[15 - 12];\\r\\nacc += bp[12 - 12];\\r\\nacc += bp[20 - 12];\\r\\nacc += bp[21 - 12];\\r\\nacc -= bp[14 - 12];\\r\\nacc -= bp[22 - 12];\\r\\nacc -= bp[23 - 12];\\r\\nrp[3] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[4];\\r\\nacc += bp[21 - 12];\\r\\nacc += bp[21 - 12];\\r\\nacc += bp[16 - 12];\\r\\nacc += bp[13 - 12];\\r\\nacc += bp[12 - 12];\\r\\nacc += bp[20 - 12];\\r\\nacc += bp[22 - 12];\\r\\nacc -= bp[15 - 12];\\r\\nacc -= bp[23 - 12];\\r\\nacc -= bp[23 - 12];\\r\\nrp[4] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[5];\\r\\nacc += bp[22 - 12];\\r\\nacc += bp[22 - 12];\\r\\nacc += bp[17 - 12];\\r\\nacc += bp[14 - 12];\\r\\nacc += bp[13 - 12];\\r\\nacc += bp[21 - 12];\\r\\nacc += bp[23 - 12];\\r\\nacc -= bp[16 - 12];\\r\\nrp[5] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[6];\\r\\nacc += bp[23 - 12];\\r\\nacc += bp[23 - 12];\\r\\nacc += bp[18 - 12];\\r\\nacc += bp[15 - 12];\\r\\nacc += bp[14 - 12];\\r\\nacc += bp[22 - 12];\\r\\nacc -= bp[17 - 12];\\r\\nrp[6] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[7];\\r\\nacc += bp[19 - 12];\\r\\nacc += bp[16 - 12];\\r\\nacc += bp[15 - 12];\\r\\nacc += bp[23 - 12];\\r\\nacc -= bp[18 - 12];\\r\\nrp[7] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[8];\\r\\nacc += bp[20 - 12];\\r\\nacc += bp[17 - 12];\\r\\nacc += bp[16 - 12];\\r\\nacc -= bp[19 - 12];\\r\\nrp[8] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[9];\\r\\nacc += bp[21 - 12];\\r\\nacc += bp[18 - 12];\\r\\nacc += bp[17 - 12];\\r\\nacc -= bp[20 - 12];\\r\\nrp[9] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[10];\\r\\nacc += bp[22 - 12];\\r\\nacc += bp[19 - 12];\\r\\nacc += bp[18 - 12];\\r\\nacc -= bp[21 - 12];\\r\\nrp[10] = (unsigned int)acc;\\r\\nacc >>= 32;\\r\\nacc += rp[11];\\r\\nacc += bp[23 - 12];\\r\\nacc += bp[20 - 12];\\r\\nacc += bp[19 - 12];\\r\\nacc -= bp[22 - 12];\\r\\nrp[11] = (unsigned int)acc;\\r\\ncarry = (int)(acc >> 32);\\r\\n}\\r\\n#else\\r\\n{\\r\\nBN_ULONG t_d[BN_NIST_384_TOP];\\r\\nnist_set_256(t_d, buf.bn, 0, 0, 0, 0, 0, 23 - 4, 22 - 4, 21 - 4);\\r\\n{\\r\\nregister BN_ULONG *ap, t, c;\\r\\nap = t_d;\\r\\nc = 0;\\r\\nfor (i = 3; i != 0; --i) {\\r\\nt = *ap;\\r\\n*(ap++) = ((t << 1) | c) & BN_MASK2;\\r\\nc = (t & BN_TBIT) ? 1 : 0;\\r\\n}\\r\\n*ap = c;\\r\\n}\\r\\ncarry =\\r\\n(int)bn_add_words(r_d + (128 / BN_BITS2), r_d + (128 / BN_BITS2),\\r\\nt_d, BN_NIST_256_TOP);\\r\\ncarry += (int)bn_add_words(r_d, r_d, buf.bn, BN_NIST_384_TOP);\\r\\nnist_set_384(t_d, buf.bn, 20, 19, 18, 17, 16, 15, 14, 13, 12, 23, 22,\\r\\n21);\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);\\r\\nnist_set_384(t_d, buf.bn, 19, 18, 17, 16, 15, 14, 13, 12, 20, 0, 23,\\r\\n0);\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);\\r\\nnist_set_384(t_d, buf.bn, 0, 0, 0, 0, 23, 22, 21, 20, 0, 0, 0, 0);\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);\\r\\nnist_set_384(t_d, buf.bn, 0, 0, 0, 0, 0, 0, 23, 22, 21, 0, 0, 20);\\r\\ncarry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_384_TOP);\\r\\nnist_set_384(t_d, buf.bn, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12,\\r\\n23);\\r\\ncarry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);\\r\\nnist_set_384(t_d, buf.bn, 0, 0, 0, 0, 0, 0, 0, 23, 22, 21, 20, 0);\\r\\ncarry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);\\r\\nnist_set_384(t_d, buf.bn, 0, 0, 0, 0, 0, 0, 0, 23, 23, 0, 0, 0);\\r\\ncarry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_384_TOP);\\r\\n}\\r\\n#endif\\r\\nu.f = bn_sub_words;\\r\\nif (carry > 0)\\r\\ncarry =\\r\\n(int)bn_sub_words(r_d, r_d, _nist_p_384[carry - 1],\\r\\nBN_NIST_384_TOP);\\r\\nelse if (carry < 0) {\\r\\ncarry =\\r\\n(int)bn_add_words(r_d, r_d, _nist_p_384[-carry - 1],\\r\\nBN_NIST_384_TOP);\\r\\nmask = 0 - (PTR_SIZE_INT) carry;\\r\\nu.p = ((PTR_SIZE_INT) bn_sub_words & mask) |\\r\\n((PTR_SIZE_INT) bn_add_words & ~mask);\\r\\n} else\\r\\ncarry = 1;\\r\\nmask =\\r\\n0 - (PTR_SIZE_INT) (*u.f) (c_d, r_d, _nist_p_384[0], BN_NIST_384_TOP);\\r\\nmask &= 0 - (PTR_SIZE_INT) carry;\\r\\nres = c_d;\\r\\nres = (BN_ULONG *)(((PTR_SIZE_INT) res & ~mask) |\\r\\n((PTR_SIZE_INT) r_d & mask));\\r\\nnist_cp_bn(r_d, res, BN_NIST_384_TOP);\\r\\nr->top = BN_NIST_384_TOP;\\r\\nbn_correct_top(r);\\r\\nreturn 1;\\r\\n}\\r\\nint BN_nist_mod_521(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\\r\\nBN_CTX *ctx)\\r\\n{\\r\\nint top = a->top, i;\\r\\nBN_ULONG *r_d, *a_d = a->d, t_d[BN_NIST_521_TOP], val, tmp, *res;\\r\\nPTR_SIZE_INT mask;\\r\\nstatic const BIGNUM _bignum_nist_p_521_sqr = {\\r\\n(BN_ULONG *)_nist_p_521_sqr,\\r\\nsizeof(_nist_p_521_sqr) / sizeof(_nist_p_521_sqr[0]),\\r\\nsizeof(_nist_p_521_sqr) / sizeof(_nist_p_521_sqr[0]),\\r\\n0, BN_FLG_STATIC_DATA\\r\\n};\\r\\nfield = &_bignum_nist_p_521;\\r\\nif (BN_is_negative(a) || BN_ucmp(a, &_bignum_nist_p_521_sqr) >= 0)\\r\\nreturn BN_nnmod(r, a, field, ctx);\\r\\ni = BN_ucmp(field, a);\\r\\nif (i == 0) {\\r\\nBN_zero(r);\\r\\nreturn 1;\\r\\n} else if (i > 0)\\r\\nreturn (r == a) ? 1 : (BN_copy(r, a) != NULL);\\r\\nif (r != a) {\\r\\nif (!bn_wexpand(r, BN_NIST_521_TOP))\\r\\nreturn 0;\\r\\nr_d = r->d;\\r\\nnist_cp_bn(r_d, a_d, BN_NIST_521_TOP);\\r\\n} else\\r\\nr_d = a_d;\\r\\nnist_cp_bn_0(t_d, a_d + (BN_NIST_521_TOP - 1),\\r\\ntop - (BN_NIST_521_TOP - 1), BN_NIST_521_TOP);\\r\\nfor (val = t_d[0], i = 0; i < BN_NIST_521_TOP - 1; i++) {\\r\\nt_d[i] = (val >> BN_NIST_521_RSHIFT |\\r\\n(tmp = t_d[i + 1]) << BN_NIST_521_LSHIFT) & BN_MASK2;\\r\\nval = tmp;\\r\\n}\\r\\nt_d[i] = val >> BN_NIST_521_RSHIFT;\\r\\nr_d[i] &= BN_NIST_521_TOP_MASK;\\r\\nbn_add_words(r_d, r_d, t_d, BN_NIST_521_TOP);\\r\\nmask =\\r\\n0 - (PTR_SIZE_INT) bn_sub_words(t_d, r_d, _nist_p_521,\\r\\nBN_NIST_521_TOP);\\r\\nres = t_d;\\r\\nres = (BN_ULONG *)(((PTR_SIZE_INT) res & ~mask) |\\r\\n((PTR_SIZE_INT) r_d & mask));\\r\\nnist_cp_bn(r_d, res, BN_NIST_521_TOP);\\r\\nr->top = BN_NIST_521_TOP;\\r\\nbn_correct_top(r);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_o_names_c", "target": 0, "func": "static int obj_name_cmp(const void *a_void, const void *b_void)\\r\\n{\\r\\nint ret;\\r\\nconst OBJ_NAME *a = (const OBJ_NAME *)a_void;\\r\\nconst OBJ_NAME *b = (const OBJ_NAME *)b_void;\\r\\nret = a->type - b->type;\\r\\nif (ret == 0) {\\r\\nif ((name_funcs_stack != NULL)\\r\\n&& (sk_NAME_FUNCS_num(name_funcs_stack) > a->type)) {\\r\\nret = sk_NAME_FUNCS_value(name_funcs_stack,\\r\\na->type)->cmp_func(a->name, b->name);\\r\\n} else\\r\\nret = strcmp(a->name, b->name);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic unsigned long obj_name_hash(const void *a_void)\\r\\n{\\r\\nunsigned long ret;\\r\\nconst OBJ_NAME *a = (const OBJ_NAME *)a_void;\\r\\nif ((name_funcs_stack != NULL)\\r\\n&& (sk_NAME_FUNCS_num(name_funcs_stack) > a->type)) {\\r\\nret =\\r\\nsk_NAME_FUNCS_value(name_funcs_stack,\\r\\na->type)->hash_func(a->name);\\r\\n} else {\\r\\nret = lh_strhash(a->name);\\r\\n}\\r\\nret ^= a->type;\\r\\nreturn (ret);\\r\\n}\\r\\nconst char *OBJ_NAME_get(const char *name, int type)\\r\\n{\\r\\nOBJ_NAME on, *ret;\\r\\nint num = 0, alias;\\r\\nif (name == NULL)\\r\\nreturn (NULL);\\r\\nif ((names_lh == NULL) && !OBJ_NAME_init())\\r\\nreturn (NULL);\\r\\nalias = type & OBJ_NAME_ALIAS;\\r\\ntype &= ~OBJ_NAME_ALIAS;\\r\\non.name = name;\\r\\non.type = type;\\r\\nfor (;;) {\\r\\nret = lh_OBJ_NAME_retrieve(names_lh, &on);\\r\\nif (ret == NULL)\\r\\nreturn (NULL);\\r\\nif ((ret->alias) && !alias) {\\r\\nif (++num > 10)\\r\\nreturn (NULL);\\r\\non.name = ret->data;\\r\\n} else {\\r\\nreturn (ret->data);\\r\\n}\\r\\n}\\r\\n}\\r\\nint OBJ_NAME_add(const char *name, int type, const char *data)\\r\\n{\\r\\nOBJ_NAME *onp, *ret;\\r\\nint alias;\\r\\nif ((names_lh == NULL) && !OBJ_NAME_init())\\r\\nreturn (0);\\r\\nalias = type & OBJ_NAME_ALIAS;\\r\\ntype &= ~OBJ_NAME_ALIAS;\\r\\nonp = (OBJ_NAME *)OPENSSL_malloc(sizeof(OBJ_NAME));\\r\\nif (onp == NULL) {\\r\\nreturn (0);\\r\\n}\\r\\nonp->name = name;\\r\\nonp->alias = alias;\\r\\nonp->type = type;\\r\\nonp->data = data;\\r\\nret = lh_OBJ_NAME_insert(names_lh, onp);\\r\\nif (ret != NULL) {\\r\\nif ((name_funcs_stack != NULL)\\r\\n&& (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type)) {\\r\\nsk_NAME_FUNCS_value(name_funcs_stack,\\r\\nret->type)->free_func(ret->name, ret->type,\\r\\nret->data);\\r\\n}\\r\\nOPENSSL_free(ret);\\r\\n} else {\\r\\nif (lh_OBJ_NAME_error(names_lh)) {\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nreturn (1);\\r\\n}\\r\\nint OBJ_NAME_remove(const char *name, int type)\\r\\n{\\r\\nOBJ_NAME on, *ret;\\r\\nif (names_lh == NULL)\\r\\nreturn (0);\\r\\ntype &= ~OBJ_NAME_ALIAS;\\r\\non.name = name;\\r\\non.type = type;\\r\\nret = lh_OBJ_NAME_delete(names_lh, &on);\\r\\nif (ret != NULL) {\\r\\nif ((name_funcs_stack != NULL)\\r\\n&& (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type)) {\\r\\nsk_NAME_FUNCS_value(name_funcs_stack,\\r\\nret->type)->free_func(ret->name, ret->type,\\r\\nret->data);\\r\\n}\\r\\nOPENSSL_free(ret);\\r\\nreturn (1);\\r\\n} else\\r\\nreturn (0);\\r\\n}\\r\\nstatic void do_all_fn_doall_arg(const OBJ_NAME *name, struct doall *d)\\r\\n{\\r\\nif (name->type == d->type)\\r\\nd->fn(name, d->arg);\\r\\n}\\r\\nstatic void do_all_sorted_fn(const OBJ_NAME *name, void *d_)\\r\\n{\\r\\nstruct doall_sorted *d = d_;\\r\\nif (name->type != d->type)\\r\\nreturn;\\r\\nd->names[d->n++] = name;\\r\\n}\\r\\nstatic int do_all_sorted_cmp(const void *n1_, const void *n2_)\\r\\n{\\r\\nconst OBJ_NAME *const *n1 = n1_;\\r\\nconst OBJ_NAME *const *n2 = n2_;\\r\\nreturn strcmp((*n1)->name, (*n2)->name);\\r\\n}\\r\\nvoid OBJ_NAME_do_all_sorted(int type,\\r\\nvoid (*fn) (const OBJ_NAME *, void *arg),\\r\\nvoid *arg)\\r\\n{\\r\\nstruct doall_sorted d;\\r\\nint n;\\r\\nd.type = type;\\r\\nd.names =\\r\\nOPENSSL_malloc(lh_OBJ_NAME_num_items(names_lh) * sizeof *d.names);\\r\\nd.n = 0;\\r\\nOBJ_NAME_do_all(type, do_all_sorted_fn, &d);\\r\\nqsort((void *)d.names, d.n, sizeof *d.names, do_all_sorted_cmp);\\r\\nfor (n = 0; n < d.n; ++n)\\r\\nfn(d.names[n], arg);\\r\\nOPENSSL_free((void *)d.names);\\r\\n}\\r\\nstatic void names_lh_free_doall(OBJ_NAME *onp)\\r\\n{\\r\\nif (onp == NULL)\\r\\nreturn;\\r\\nif (free_type < 0 || free_type == onp->type)\\r\\nOBJ_NAME_remove(onp->name, onp->type);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_oaep_c", "target": 0, "func": "int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen,\\r\\nconst unsigned char *param, int plen)\\r\\n{\\r\\nreturn RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, from, flen,\\r\\nparam, plen, NULL, NULL);\\r\\n}\\r\\nint RSA_padding_add_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen,\\r\\nconst unsigned char *param, int plen,\\r\\nconst EVP_MD *md, const EVP_MD *mgf1md)\\r\\n{\\r\\nint i, emlen = tlen - 1;\\r\\nunsigned char *db, *seed;\\r\\nunsigned char *dbmask, seedmask[EVP_MAX_MD_SIZE];\\r\\nint mdlen;\\r\\nif (md == NULL)\\r\\nmd = EVP_sha1();\\r\\nif (mgf1md == NULL)\\r\\nmgf1md = md;\\r\\nmdlen = EVP_MD_size(md);\\r\\nif (flen > emlen - 2 * mdlen - 1) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1,\\r\\nRSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE);\\r\\nreturn 0;\\r\\n}\\r\\nif (emlen < 2 * mdlen + 1) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1,\\r\\nRSA_R_KEY_SIZE_TOO_SMALL);\\r\\nreturn 0;\\r\\n}\\r\\nto[0] = 0;\\r\\nseed = to + 1;\\r\\ndb = to + mdlen + 1;\\r\\nif (!EVP_Digest((void *)param, plen, db, NULL, md, NULL))\\r\\nreturn 0;\\r\\nmemset(db + mdlen, 0, emlen - flen - 2 * mdlen - 1);\\r\\ndb[emlen - flen - mdlen - 1] = 0x01;\\r\\nmemcpy(db + emlen - flen - mdlen, from, (unsigned int)flen);\\r\\nif (RAND_bytes(seed, mdlen) <= 0)\\r\\nreturn 0;\\r\\n# ifdef PKCS_TESTVECT\\r\\nmemcpy(seed,\\r\\n\"\\xaa\\xfd\\x12\\xf6\\x59\\xca\\xe6\\x34\\x89\\xb4\\x79\\xe5\\x07\\x6d\\xde\\xc2\\xf0\\x6c\\xb5\\x8f\",\\r\\n20);\\r\\n# endif\\r\\ndbmask = OPENSSL_malloc(emlen - mdlen);\\r\\nif (dbmask == NULL) {\\r\\nRSAerr(RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nif (PKCS1_MGF1(dbmask, emlen - mdlen, seed, mdlen, mgf1md) < 0)\\r\\nreturn 0;\\r\\nfor (i = 0; i < emlen - mdlen; i++)\\r\\ndb[i] ^= dbmask[i];\\r\\nif (PKCS1_MGF1(seedmask, mdlen, db, emlen - mdlen, mgf1md) < 0)\\r\\nreturn 0;\\r\\nfor (i = 0; i < mdlen; i++)\\r\\nseed[i] ^= seedmask[i];\\r\\nOPENSSL_free(dbmask);\\r\\nreturn 1;\\r\\n}\\r\\nint RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen, int num,\\r\\nconst unsigned char *param, int plen)\\r\\n{\\r\\nreturn RSA_padding_check_PKCS1_OAEP_mgf1(to, tlen, from, flen, num,\\r\\nparam, plen, NULL, NULL);\\r\\n}\\r\\nint RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,\\r\\nconst unsigned char *from, int flen,\\r\\nint num, const unsigned char *param,\\r\\nint plen, const EVP_MD *md,\\r\\nconst EVP_MD *mgf1md)\\r\\n{\\r\\nint i, dblen, mlen = -1, one_index = 0, msg_index;\\r\\nunsigned int good, found_one_byte;\\r\\nconst unsigned char *maskedseed, *maskeddb;\\r\\nunsigned char *db = NULL, *em = NULL, seed[EVP_MAX_MD_SIZE],\\r\\nphash[EVP_MAX_MD_SIZE];\\r\\nint mdlen;\\r\\nif (md == NULL)\\r\\nmd = EVP_sha1();\\r\\nif (mgf1md == NULL)\\r\\nmgf1md = md;\\r\\nmdlen = EVP_MD_size(md);\\r\\nif (tlen <= 0 || flen <= 0)\\r\\nreturn -1;\\r\\nif (num < flen || num < 2 * mdlen + 2)\\r\\ngoto decoding_err;\\r\\ndblen = num - mdlen - 1;\\r\\ndb = OPENSSL_malloc(dblen);\\r\\nem = OPENSSL_malloc(num);\\r\\nif (db == NULL || em == NULL) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1, ERR_R_MALLOC_FAILURE);\\r\\ngoto cleanup;\\r\\n}\\r\\nmemset(em, 0, num);\\r\\nmemcpy(em + num - flen, from, flen);\\r\\ngood = constant_time_is_zero(em[0]);\\r\\nmaskedseed = em + 1;\\r\\nmaskeddb = em + 1 + mdlen;\\r\\nif (PKCS1_MGF1(seed, mdlen, maskeddb, dblen, mgf1md))\\r\\ngoto cleanup;\\r\\nfor (i = 0; i < mdlen; i++)\\r\\nseed[i] ^= maskedseed[i];\\r\\nif (PKCS1_MGF1(db, dblen, seed, mdlen, mgf1md))\\r\\ngoto cleanup;\\r\\nfor (i = 0; i < dblen; i++)\\r\\ndb[i] ^= maskeddb[i];\\r\\nif (!EVP_Digest((void *)param, plen, phash, NULL, md, NULL))\\r\\ngoto cleanup;\\r\\ngood &= constant_time_is_zero(CRYPTO_memcmp(db, phash, mdlen));\\r\\nfound_one_byte = 0;\\r\\nfor (i = mdlen; i < dblen; i++) {\\r\\nunsigned int equals1 = constant_time_eq(db[i], 1);\\r\\nunsigned int equals0 = constant_time_is_zero(db[i]);\\r\\none_index = constant_time_select_int(~found_one_byte & equals1,\\r\\ni, one_index);\\r\\nfound_one_byte |= equals1;\\r\\ngood &= (found_one_byte | equals0);\\r\\n}\\r\\ngood &= found_one_byte;\\r\\nif (!good)\\r\\ngoto decoding_err;\\r\\nmsg_index = one_index + 1;\\r\\nmlen = dblen - msg_index;\\r\\nif (tlen < mlen) {\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1, RSA_R_DATA_TOO_LARGE);\\r\\nmlen = -1;\\r\\n} else {\\r\\nmemcpy(to, db + msg_index, mlen);\\r\\ngoto cleanup;\\r\\n}\\r\\ndecoding_err:\\r\\nRSAerr(RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1,\\r\\nRSA_R_OAEP_DECODING_ERROR);\\r\\ncleanup:\\r\\nif (db != NULL)\\r\\nOPENSSL_free(db);\\r\\nif (em != NULL)\\r\\nOPENSSL_free(em);\\r\\nreturn mlen;\\r\\n}\\r\\nint PKCS1_MGF1(unsigned char *mask, long len,\\r\\nconst unsigned char *seed, long seedlen, const EVP_MD *dgst)\\r\\n{\\r\\nlong i, outlen = 0;\\r\\nunsigned char cnt[4];\\r\\nEVP_MD_CTX c;\\r\\nunsigned char md[EVP_MAX_MD_SIZE];\\r\\nint mdlen;\\r\\nint rv = -1;\\r\\nEVP_MD_CTX_init(&c);\\r\\nmdlen = EVP_MD_size(dgst);\\r\\nif (mdlen < 0)\\r\\ngoto err;\\r\\nfor (i = 0; outlen < len; i++) {\\r\\ncnt[0] = (unsigned char)((i >> 24) & 255);\\r\\ncnt[1] = (unsigned char)((i >> 16) & 255);\\r\\ncnt[2] = (unsigned char)((i >> 8)) & 255;\\r\\ncnt[3] = (unsigned char)(i & 255);\\r\\nif (!EVP_DigestInit_ex(&c, dgst, NULL)\\r\\n|| !EVP_DigestUpdate(&c, seed, seedlen)\\r\\n|| !EVP_DigestUpdate(&c, cnt, 4))\\r\\ngoto err;\\r\\nif (outlen + mdlen <= len) {\\r\\nif (!EVP_DigestFinal_ex(&c, mask + outlen, NULL))\\r\\ngoto err;\\r\\noutlen += mdlen;\\r\\n} else {\\r\\nif (!EVP_DigestFinal_ex(&c, md, NULL))\\r\\ngoto err;\\r\\nmemcpy(mask + outlen, md, len - outlen);\\r\\noutlen = len;\\r\\n}\\r\\n}\\r\\nrv = 0;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&c);\\r\\nreturn rv;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_i2d_pu_c", "target": 0, "func": "int i2d_PublicKey(EVP_PKEY *a, unsigned char **pp)\\r\\n{\\r\\nswitch (a->type) {\\r\\n#ifndef OPENSSL_NO_RSA\\r\\ncase EVP_PKEY_RSA:\\r\\nreturn (i2d_RSAPublicKey(a->pkey.rsa, pp));\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_DSA\\r\\ncase EVP_PKEY_DSA:\\r\\nreturn (i2d_DSAPublicKey(a->pkey.dsa, pp));\\r\\n#endif\\r\\n#ifndef OPENSSL_NO_EC\\r\\ncase EVP_PKEY_EC:\\r\\nreturn (i2o_ECPublicKey(a->pkey.ec, pp));\\r\\n#endif\\r\\ndefault:\\r\\nASN1err(ASN1_F_I2D_PUBLICKEY, ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE);\\r\\nreturn (-1);\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_bio_c", "target": 0, "func": "BIO_METHOD *BIO_s_bio(void)\\r\\n{\\r\\nreturn &methods_biop;\\r\\n}\\r\\nstatic int bio_new(BIO *bio)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nb = OPENSSL_malloc(sizeof *b);\\r\\nif (b == NULL)\\r\\nreturn 0;\\r\\nb->peer = NULL;\\r\\nb->size = 17 * 1024;\\r\\nb->buf = NULL;\\r\\nbio->ptr = b;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bio_free(BIO *bio)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nif (bio == NULL)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nif (b->peer)\\r\\nbio_destroy_pair(bio);\\r\\nif (b->buf != NULL) {\\r\\nOPENSSL_free(b->buf);\\r\\n}\\r\\nOPENSSL_free(b);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bio_read(BIO *bio, char *buf, int size_)\\r\\n{\\r\\nsize_t size = size_;\\r\\nsize_t rest;\\r\\nstruct bio_bio_st *b, *peer_b;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\npeer_b = b->peer->ptr;\\r\\nassert(peer_b != NULL);\\r\\nassert(peer_b->buf != NULL);\\r\\npeer_b->request = 0;\\r\\nif (buf == NULL || size == 0)\\r\\nreturn 0;\\r\\nif (peer_b->len == 0) {\\r\\nif (peer_b->closed)\\r\\nreturn 0;\\r\\nelse {\\r\\nBIO_set_retry_read(bio);\\r\\nif (size <= peer_b->size)\\r\\npeer_b->request = size;\\r\\nelse\\r\\npeer_b->request = peer_b->size;\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif (peer_b->len < size)\\r\\nsize = peer_b->len;\\r\\nrest = size;\\r\\nassert(rest > 0);\\r\\ndo {\\r\\nsize_t chunk;\\r\\nassert(rest <= peer_b->len);\\r\\nif (peer_b->offset + rest <= peer_b->size)\\r\\nchunk = rest;\\r\\nelse\\r\\nchunk = peer_b->size - peer_b->offset;\\r\\nassert(peer_b->offset + chunk <= peer_b->size);\\r\\nmemcpy(buf, peer_b->buf + peer_b->offset, chunk);\\r\\npeer_b->len -= chunk;\\r\\nif (peer_b->len) {\\r\\npeer_b->offset += chunk;\\r\\nassert(peer_b->offset <= peer_b->size);\\r\\nif (peer_b->offset == peer_b->size)\\r\\npeer_b->offset = 0;\\r\\nbuf += chunk;\\r\\n} else {\\r\\nassert(chunk == rest);\\r\\npeer_b->offset = 0;\\r\\n}\\r\\nrest -= chunk;\\r\\n}\\r\\nwhile (rest);\\r\\nreturn size;\\r\\n}\\r\\nstatic ossl_ssize_t bio_nread0(BIO *bio, char **buf)\\r\\n{\\r\\nstruct bio_bio_st *b, *peer_b;\\r\\nossl_ssize_t num;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\npeer_b = b->peer->ptr;\\r\\nassert(peer_b != NULL);\\r\\nassert(peer_b->buf != NULL);\\r\\npeer_b->request = 0;\\r\\nif (peer_b->len == 0) {\\r\\nchar dummy;\\r\\nreturn bio_read(bio, &dummy, 1);\\r\\n}\\r\\nnum = peer_b->len;\\r\\nif (peer_b->size < peer_b->offset + num)\\r\\nnum = peer_b->size - peer_b->offset;\\r\\nassert(num > 0);\\r\\nif (buf != NULL)\\r\\n*buf = peer_b->buf + peer_b->offset;\\r\\nreturn num;\\r\\n}\\r\\nstatic ossl_ssize_t bio_nread(BIO *bio, char **buf, size_t num_)\\r\\n{\\r\\nstruct bio_bio_st *b, *peer_b;\\r\\nossl_ssize_t num, available;\\r\\nif (num_ > SSIZE_MAX)\\r\\nnum = SSIZE_MAX;\\r\\nelse\\r\\nnum = (ossl_ssize_t) num_;\\r\\navailable = bio_nread0(bio, buf);\\r\\nif (num > available)\\r\\nnum = available;\\r\\nif (num <= 0)\\r\\nreturn num;\\r\\nb = bio->ptr;\\r\\npeer_b = b->peer->ptr;\\r\\npeer_b->len -= num;\\r\\nif (peer_b->len) {\\r\\npeer_b->offset += num;\\r\\nassert(peer_b->offset <= peer_b->size);\\r\\nif (peer_b->offset == peer_b->size)\\r\\npeer_b->offset = 0;\\r\\n} else\\r\\npeer_b->offset = 0;\\r\\nreturn num;\\r\\n}\\r\\nstatic int bio_write(BIO *bio, const char *buf, int num_)\\r\\n{\\r\\nsize_t num = num_;\\r\\nsize_t rest;\\r\\nstruct bio_bio_st *b;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init || buf == NULL || num == 0)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\nassert(b->buf != NULL);\\r\\nb->request = 0;\\r\\nif (b->closed) {\\r\\nBIOerr(BIO_F_BIO_WRITE, BIO_R_BROKEN_PIPE);\\r\\nreturn -1;\\r\\n}\\r\\nassert(b->len <= b->size);\\r\\nif (b->len == b->size) {\\r\\nBIO_set_retry_write(bio);\\r\\nreturn -1;\\r\\n}\\r\\nif (num > b->size - b->len)\\r\\nnum = b->size - b->len;\\r\\nrest = num;\\r\\nassert(rest > 0);\\r\\ndo {\\r\\nsize_t write_offset;\\r\\nsize_t chunk;\\r\\nassert(b->len + rest <= b->size);\\r\\nwrite_offset = b->offset + b->len;\\r\\nif (write_offset >= b->size)\\r\\nwrite_offset -= b->size;\\r\\nif (write_offset + rest <= b->size)\\r\\nchunk = rest;\\r\\nelse\\r\\nchunk = b->size - write_offset;\\r\\nmemcpy(b->buf + write_offset, buf, chunk);\\r\\nb->len += chunk;\\r\\nassert(b->len <= b->size);\\r\\nrest -= chunk;\\r\\nbuf += chunk;\\r\\n}\\r\\nwhile (rest);\\r\\nreturn num;\\r\\n}\\r\\nstatic ossl_ssize_t bio_nwrite0(BIO *bio, char **buf)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nsize_t num;\\r\\nsize_t write_offset;\\r\\nBIO_clear_retry_flags(bio);\\r\\nif (!bio->init)\\r\\nreturn 0;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nassert(b->peer != NULL);\\r\\nassert(b->buf != NULL);\\r\\nb->request = 0;\\r\\nif (b->closed) {\\r\\nBIOerr(BIO_F_BIO_NWRITE0, BIO_R_BROKEN_PIPE);\\r\\nreturn -1;\\r\\n}\\r\\nassert(b->len <= b->size);\\r\\nif (b->len == b->size) {\\r\\nBIO_set_retry_write(bio);\\r\\nreturn -1;\\r\\n}\\r\\nnum = b->size - b->len;\\r\\nwrite_offset = b->offset + b->len;\\r\\nif (write_offset >= b->size)\\r\\nwrite_offset -= b->size;\\r\\nif (write_offset + num > b->size)\\r\\nnum = b->size - write_offset;\\r\\nif (buf != NULL)\\r\\n*buf = b->buf + write_offset;\\r\\nassert(write_offset + num <= b->size);\\r\\nreturn num;\\r\\n}\\r\\nstatic ossl_ssize_t bio_nwrite(BIO *bio, char **buf, size_t num_)\\r\\n{\\r\\nstruct bio_bio_st *b;\\r\\nossl_ssize_t num, space;\\r\\nif (num_ > SSIZE_MAX)\\r\\nnum = SSIZE_MAX;\\r\\nelse\\r\\nnum = (ossl_ssize_t) num_;\\r\\nspace = bio_nwrite0(bio, buf);\\r\\nif (num > space)\\r\\nnum = space;\\r\\nif (num <= 0)\\r\\nreturn num;\\r\\nb = bio->ptr;\\r\\nassert(b != NULL);\\r\\nb->len += num;\\r\\nassert(b->len <= b->size);\\r\\nreturn num;\\r\\n}\\r\\nstatic long bio_ctrl(BIO *bio, int cmd, long num, void *ptr)\\r\\n{\\r\\nlong ret;\\r\\nstruct bio_bio_st *b = bio->ptr;\\r\\nassert(b != NULL);\\r\\nswitch (cmd) {\\r\\ncase BIO_C_SET_WRITE_BUF_SIZE:\\r\\nif (b->peer) {\\r\\nBIOerr(BIO_F_BIO_CTRL, BIO_R_IN_USE);\\r\\nret = 0;\\r\\n} else if (num == 0) {\\r\\nBIOerr(BIO_F_BIO_CTRL, BIO_R_INVALID_ARGUMENT);\\r\\nret = 0;\\r\\n} else {\\r\\nsize_t new_size = num;\\r\\nif (b->size != new_size) {\\r\\nif (b->buf) {\\r\\nOPENSSL_free(b->buf);\\r\\nb->buf = NULL;\\r\\n}\\r\\nb->size = new_size;\\r\\n}\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_GET_WRITE_BUF_SIZE:\\r\\nret = (long)b->size;\\r\\nbreak;\\r\\ncase BIO_C_MAKE_BIO_PAIR:\\r\\n{\\r\\nBIO *other_bio = ptr;\\r\\nif (bio_make_pair(bio, other_bio))\\r\\nret = 1;\\r\\nelse\\r\\nret = 0;\\r\\n}\\r\\nbreak;\\r\\ncase BIO_C_DESTROY_BIO_PAIR:\\r\\nbio_destroy_pair(bio);\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_GET_WRITE_GUARANTEE:\\r\\nif (b->peer == NULL || b->closed)\\r\\nret = 0;\\r\\nelse\\r\\nret = (long)b->size - b->len;\\r\\nbreak;\\r\\ncase BIO_C_GET_READ_REQUEST:\\r\\nret = (long)b->request;\\r\\nbreak;\\r\\ncase BIO_C_RESET_READ_REQUEST:\\r\\nb->request = 0;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_SHUTDOWN_WR:\\r\\nb->closed = 1;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_C_NREAD0:\\r\\nret = (long)bio_nread0(bio, ptr);\\r\\nbreak;\\r\\ncase BIO_C_NREAD:\\r\\nret = (long)bio_nread(bio, ptr, (size_t)num);\\r\\nbreak;\\r\\ncase BIO_C_NWRITE0:\\r\\nret = (long)bio_nwrite0(bio, ptr);\\r\\nbreak;\\r\\ncase BIO_C_NWRITE:\\r\\nret = (long)bio_nwrite(bio, ptr, (size_t)num);\\r\\nbreak;\\r\\ncase BIO_CTRL_RESET:\\r\\nif (b->buf != NULL) {\\r\\nb->len = 0;\\r\\nb->offset = 0;\\r\\n}\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_GET_CLOSE:\\r\\nret = bio->shutdown;\\r\\nbreak;\\r\\ncase BIO_CTRL_SET_CLOSE:\\r\\nbio->shutdown = (int)num;\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_PENDING:\\r\\nif (b->peer != NULL) {\\r\\nstruct bio_bio_st *peer_b = b->peer->ptr;\\r\\nret = (long)peer_b->len;\\r\\n} else\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_WPENDING:\\r\\nif (b->buf != NULL)\\r\\nret = (long)b->len;\\r\\nelse\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\n{\\r\\nBIO *other_bio = ptr;\\r\\nstruct bio_bio_st *other_b;\\r\\nassert(other_bio != NULL);\\r\\nother_b = other_bio->ptr;\\r\\nassert(other_b != NULL);\\r\\nassert(other_b->buf == NULL);\\r\\nother_b->size = b->size;\\r\\n}\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_FLUSH:\\r\\nret = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_EOF:\\r\\n{\\r\\nBIO *other_bio = ptr;\\r\\nif (other_bio) {\\r\\nstruct bio_bio_st *other_b = other_bio->ptr;\\r\\nassert(other_b != NULL);\\r\\nret = other_b->len == 0 && other_b->closed;\\r\\n} else\\r\\nret = 1;\\r\\n}\\r\\nbreak;\\r\\ndefault:\\r\\nret = 0;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int bio_puts(BIO *bio, const char *str)\\r\\n{\\r\\nreturn bio_write(bio, str, strlen(str));\\r\\n}\\r\\nstatic int bio_make_pair(BIO *bio1, BIO *bio2)\\r\\n{\\r\\nstruct bio_bio_st *b1, *b2;\\r\\nassert(bio1 != NULL);\\r\\nassert(bio2 != NULL);\\r\\nb1 = bio1->ptr;\\r\\nb2 = bio2->ptr;\\r\\nif (b1->peer != NULL || b2->peer != NULL) {\\r\\nBIOerr(BIO_F_BIO_MAKE_PAIR, BIO_R_IN_USE);\\r\\nreturn 0;\\r\\n}\\r\\nif (b1->buf == NULL) {\\r\\nb1->buf = OPENSSL_malloc(b1->size);\\r\\nif (b1->buf == NULL) {\\r\\nBIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nb1->len = 0;\\r\\nb1->offset = 0;\\r\\n}\\r\\nif (b2->buf == NULL) {\\r\\nb2->buf = OPENSSL_malloc(b2->size);\\r\\nif (b2->buf == NULL) {\\r\\nBIOerr(BIO_F_BIO_MAKE_PAIR, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nb2->len = 0;\\r\\nb2->offset = 0;\\r\\n}\\r\\nb1->peer = bio2;\\r\\nb1->closed = 0;\\r\\nb1->request = 0;\\r\\nb2->peer = bio1;\\r\\nb2->closed = 0;\\r\\nb2->request = 0;\\r\\nbio1->init = 1;\\r\\nbio2->init = 1;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void bio_destroy_pair(BIO *bio)\\r\\n{\\r\\nstruct bio_bio_st *b = bio->ptr;\\r\\nif (b != NULL) {\\r\\nBIO *peer_bio = b->peer;\\r\\nif (peer_bio != NULL) {\\r\\nstruct bio_bio_st *peer_b = peer_bio->ptr;\\r\\nassert(peer_b != NULL);\\r\\nassert(peer_b->peer == bio);\\r\\npeer_b->peer = NULL;\\r\\npeer_bio->init = 0;\\r\\nassert(peer_b->buf != NULL);\\r\\npeer_b->len = 0;\\r\\npeer_b->offset = 0;\\r\\nb->peer = NULL;\\r\\nbio->init = 0;\\r\\nassert(b->buf != NULL);\\r\\nb->len = 0;\\r\\nb->offset = 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nint BIO_new_bio_pair(BIO **bio1_p, size_t writebuf1,\\r\\nBIO **bio2_p, size_t writebuf2)\\r\\n{\\r\\nBIO *bio1 = NULL, *bio2 = NULL;\\r\\nlong r;\\r\\nint ret = 0;\\r\\nbio1 = BIO_new(BIO_s_bio());\\r\\nif (bio1 == NULL)\\r\\ngoto err;\\r\\nbio2 = BIO_new(BIO_s_bio());\\r\\nif (bio2 == NULL)\\r\\ngoto err;\\r\\nif (writebuf1) {\\r\\nr = BIO_set_write_buf_size(bio1, writebuf1);\\r\\nif (!r)\\r\\ngoto err;\\r\\n}\\r\\nif (writebuf2) {\\r\\nr = BIO_set_write_buf_size(bio2, writebuf2);\\r\\nif (!r)\\r\\ngoto err;\\r\\n}\\r\\nr = BIO_make_bio_pair(bio1, bio2);\\r\\nif (!r)\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (ret == 0) {\\r\\nif (bio1) {\\r\\nBIO_free(bio1);\\r\\nbio1 = NULL;\\r\\n}\\r\\nif (bio2) {\\r\\nBIO_free(bio2);\\r\\nbio2 = NULL;\\r\\n}\\r\\n}\\r\\n*bio1_p = bio1;\\r\\n*bio2_p = bio2;\\r\\nreturn ret;\\r\\n}\\r\\nsize_t BIO_ctrl_get_write_guarantee(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_C_GET_WRITE_GUARANTEE, 0, NULL);\\r\\n}\\r\\nsize_t BIO_ctrl_get_read_request(BIO *bio)\\r\\n{\\r\\nreturn BIO_ctrl(bio, BIO_C_GET_READ_REQUEST, 0, NULL);\\r\\n}\\r\\nint BIO_ctrl_reset_read_request(BIO *bio)\\r\\n{\\r\\nreturn (BIO_ctrl(bio, BIO_C_RESET_READ_REQUEST, 0, NULL) != 0);\\r\\n}\\r\\nint BIO_nread0(BIO *bio, char **buf)\\r\\n{\\r\\nlong ret;\\r\\nif (!bio->init) {\\r\\nBIOerr(BIO_F_BIO_NREAD0, BIO_R_UNINITIALIZED);\\r\\nreturn -2;\\r\\n}\\r\\nret = BIO_ctrl(bio, BIO_C_NREAD0, 0, buf);\\r\\nif (ret > INT_MAX)\\r\\nreturn INT_MAX;\\r\\nelse\\r\\nreturn (int)ret;\\r\\n}\\r\\nint BIO_nread(BIO *bio, char **buf, int num)\\r\\n{\\r\\nint ret;\\r\\nif (!bio->init) {\\r\\nBIOerr(BIO_F_BIO_NREAD, BIO_R_UNINITIALIZED);\\r\\nreturn -2;\\r\\n}\\r\\nret = (int)BIO_ctrl(bio, BIO_C_NREAD, num, buf);\\r\\nif (ret > 0)\\r\\nbio->num_read += ret;\\r\\nreturn ret;\\r\\n}\\r\\nint BIO_nwrite0(BIO *bio, char **buf)\\r\\n{\\r\\nlong ret;\\r\\nif (!bio->init) {\\r\\nBIOerr(BIO_F_BIO_NWRITE0, BIO_R_UNINITIALIZED);\\r\\nreturn -2;\\r\\n}\\r\\nret = BIO_ctrl(bio, BIO_C_NWRITE0, 0, buf);\\r\\nif (ret > INT_MAX)\\r\\nreturn INT_MAX;\\r\\nelse\\r\\nreturn (int)ret;\\r\\n}\\r\\nint BIO_nwrite(BIO *bio, char **buf, int num)\\r\\n{\\r\\nint ret;\\r\\nif (!bio->init) {\\r\\nBIOerr(BIO_F_BIO_NWRITE, BIO_R_UNINITIALIZED);\\r\\nreturn -2;\\r\\n}\\r\\nret = BIO_ctrl(bio, BIO_C_NWRITE, num, buf);\\r\\nif (ret > 0)\\r\\nbio->num_write += ret;\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_hmac_c", "target": 0, "func": "int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,\\r\\nconst EVP_MD *md, ENGINE *impl)\\r\\n{\\r\\nint i, j, reset = 0;\\r\\nunsigned char pad[HMAC_MAX_MD_CBLOCK];\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode()) {\\r\\nconst EVP_MD *fipsmd;\\r\\nif (md) {\\r\\nfipsmd = FIPS_get_digestbynid(EVP_MD_type(md));\\r\\nif (fipsmd)\\r\\nmd = fipsmd;\\r\\n}\\r\\n}\\r\\nif (FIPS_mode()) {\\r\\nif ((impl || ctx->i_ctx.engine)\\r\\n&& !(ctx->i_ctx.flags & EVP_CIPH_FLAG_NON_FIPS_ALLOW)) {\\r\\nEVPerr(EVP_F_HMAC_INIT_EX, EVP_R_DISABLED_FOR_FIPS);\\r\\nreturn 0;\\r\\n}\\r\\nif (!impl && !ctx->i_ctx.engine)\\r\\nreturn FIPS_hmac_init_ex(ctx, key, len, md, NULL);\\r\\n}\\r\\n#endif\\r\\nif (md != NULL) {\\r\\nreset = 1;\\r\\nctx->md = md;\\r\\n} else\\r\\nmd = ctx->md;\\r\\nif (key != NULL) {\\r\\nreset = 1;\\r\\nj = EVP_MD_block_size(md);\\r\\nOPENSSL_assert(j <= (int)sizeof(ctx->key));\\r\\nif (j < len) {\\r\\nif (!EVP_DigestInit_ex(&ctx->md_ctx, md, impl))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&ctx->md_ctx, key, len))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&(ctx->md_ctx), ctx->key,\\r\\n&ctx->key_length))\\r\\ngoto err;\\r\\n} else {\\r\\nOPENSSL_assert(len >= 0 && len <= (int)sizeof(ctx->key));\\r\\nmemcpy(ctx->key, key, len);\\r\\nctx->key_length = len;\\r\\n}\\r\\nif (ctx->key_length != HMAC_MAX_MD_CBLOCK)\\r\\nmemset(&ctx->key[ctx->key_length], 0,\\r\\nHMAC_MAX_MD_CBLOCK - ctx->key_length);\\r\\n}\\r\\nif (reset) {\\r\\nfor (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\\r\\npad[i] = 0x36 ^ ctx->key[i];\\r\\nif (!EVP_DigestInit_ex(&ctx->i_ctx, md, impl))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&ctx->i_ctx, pad, EVP_MD_block_size(md)))\\r\\ngoto err;\\r\\nfor (i = 0; i < HMAC_MAX_MD_CBLOCK; i++)\\r\\npad[i] = 0x5c ^ ctx->key[i];\\r\\nif (!EVP_DigestInit_ex(&ctx->o_ctx, md, impl))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&ctx->o_ctx, pad, EVP_MD_block_size(md)))\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_MD_CTX_copy_ex(&ctx->md_ctx, &ctx->i_ctx))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nint HMAC_Init(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md)\\r\\n{\\r\\nif (key && md)\\r\\nHMAC_CTX_init(ctx);\\r\\nreturn HMAC_Init_ex(ctx, key, len, md, NULL);\\r\\n}\\r\\nint HMAC_Update(HMAC_CTX *ctx, const unsigned char *data, size_t len)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !ctx->i_ctx.engine)\\r\\nreturn FIPS_hmac_update(ctx, data, len);\\r\\n#endif\\r\\nreturn EVP_DigestUpdate(&ctx->md_ctx, data, len);\\r\\n}\\r\\nint HMAC_Final(HMAC_CTX *ctx, unsigned char *md, unsigned int *len)\\r\\n{\\r\\nunsigned int i;\\r\\nunsigned char buf[EVP_MAX_MD_SIZE];\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !ctx->i_ctx.engine)\\r\\nreturn FIPS_hmac_final(ctx, md, len);\\r\\n#endif\\r\\nif (!EVP_DigestFinal_ex(&ctx->md_ctx, buf, &i))\\r\\ngoto err;\\r\\nif (!EVP_MD_CTX_copy_ex(&ctx->md_ctx, &ctx->o_ctx))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&ctx->md_ctx, buf, i))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&ctx->md_ctx, md, len))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nvoid HMAC_CTX_init(HMAC_CTX *ctx)\\r\\n{\\r\\nEVP_MD_CTX_init(&ctx->i_ctx);\\r\\nEVP_MD_CTX_init(&ctx->o_ctx);\\r\\nEVP_MD_CTX_init(&ctx->md_ctx);\\r\\n}\\r\\nint HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx)\\r\\n{\\r\\nif (!EVP_MD_CTX_copy(&dctx->i_ctx, &sctx->i_ctx))\\r\\ngoto err;\\r\\nif (!EVP_MD_CTX_copy(&dctx->o_ctx, &sctx->o_ctx))\\r\\ngoto err;\\r\\nif (!EVP_MD_CTX_copy(&dctx->md_ctx, &sctx->md_ctx))\\r\\ngoto err;\\r\\nmemcpy(dctx->key, sctx->key, HMAC_MAX_MD_CBLOCK);\\r\\ndctx->key_length = sctx->key_length;\\r\\ndctx->md = sctx->md;\\r\\nreturn 1;\\r\\nerr:\\r\\nreturn 0;\\r\\n}\\r\\nvoid HMAC_CTX_cleanup(HMAC_CTX *ctx)\\r\\n{\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode() && !ctx->i_ctx.engine) {\\r\\nFIPS_hmac_ctx_cleanup(ctx);\\r\\nreturn;\\r\\n}\\r\\n#endif\\r\\nEVP_MD_CTX_cleanup(&ctx->i_ctx);\\r\\nEVP_MD_CTX_cleanup(&ctx->o_ctx);\\r\\nEVP_MD_CTX_cleanup(&ctx->md_ctx);\\r\\nmemset(ctx, 0, sizeof *ctx);\\r\\n}\\r\\nunsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,\\r\\nconst unsigned char *d, size_t n, unsigned char *md,\\r\\nunsigned int *md_len)\\r\\n{\\r\\nHMAC_CTX c;\\r\\nstatic unsigned char m[EVP_MAX_MD_SIZE];\\r\\nif (md == NULL)\\r\\nmd = m;\\r\\nHMAC_CTX_init(&c);\\r\\nif (!HMAC_Init(&c, key, key_len, evp_md))\\r\\ngoto err;\\r\\nif (!HMAC_Update(&c, d, n))\\r\\ngoto err;\\r\\nif (!HMAC_Final(&c, md, md_len))\\r\\ngoto err;\\r\\nHMAC_CTX_cleanup(&c);\\r\\nreturn md;\\r\\nerr:\\r\\nreturn NULL;\\r\\n}\\r\\nvoid HMAC_CTX_set_flags(HMAC_CTX *ctx, unsigned long flags)\\r\\n{\\r\\nEVP_MD_CTX_set_flags(&ctx->i_ctx, flags);\\r\\nEVP_MD_CTX_set_flags(&ctx->o_ctx, flags);\\r\\nEVP_MD_CTX_set_flags(&ctx->md_ctx, flags);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_m_sha1_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn SHA1_Init(ctx->md_data);\\r\\n}\\r\\nstatic int update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn SHA1_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn SHA1_Final(md, ctx->md_data);\\r\\n}\\r\\nconst EVP_MD *EVP_sha1(void)\\r\\n{\\r\\nreturn (&sha1_md);\\r\\n}\\r\\nstatic int init224(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn SHA224_Init(ctx->md_data);\\r\\n}\\r\\nstatic int init256(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn SHA256_Init(ctx->md_data);\\r\\n}\\r\\nstatic int update256(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn SHA256_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int final256(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn SHA256_Final(md, ctx->md_data);\\r\\n}\\r\\nconst EVP_MD *EVP_sha224(void)\\r\\n{\\r\\nreturn (&sha224_md);\\r\\n}\\r\\nconst EVP_MD *EVP_sha256(void)\\r\\n{\\r\\nreturn (&sha256_md);\\r\\n}\\r\\nstatic int init384(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn SHA384_Init(ctx->md_data);\\r\\n}\\r\\nstatic int init512(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn SHA512_Init(ctx->md_data);\\r\\n}\\r\\nstatic int update512(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn SHA512_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int final512(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn SHA512_Final(md, ctx->md_data);\\r\\n}\\r\\nconst EVP_MD *EVP_sha384(void)\\r\\n{\\r\\nreturn (&sha384_md);\\r\\n}\\r\\nconst EVP_MD *EVP_sha512(void)\\r\\n{\\r\\nreturn (&sha512_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_err_c", "target": 1, "func": "void ERR_load_SSL_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(SSL_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, SSL_str_functs);\\r\\nERR_load_strings(0, SSL_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_err_c", "target": 0, "func": "void ERR_load_DH_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(DH_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, DH_str_functs);\\r\\nERR_load_strings(0, DH_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_x509a_c", "target": 0, "func": "int X509_keyid_set1(X509 *x, unsigned char *id, int len)\\r\\n{\\r\\nX509_CERT_AUX *aux;\\r\\nif (!id) {\\r\\nif (!x || !x->aux || !x->aux->keyid)\\r\\nreturn 1;\\r\\nASN1_OCTET_STRING_free(x->aux->keyid);\\r\\nx->aux->keyid = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nif (!(aux = aux_get(x)))\\r\\nreturn 0;\\r\\nif (!aux->keyid && !(aux->keyid = ASN1_OCTET_STRING_new()))\\r\\nreturn 0;\\r\\nreturn ASN1_STRING_set(aux->keyid, id, len);\\r\\n}\\r\\nunsigned char *X509_alias_get0(X509 *x, int *len)\\r\\n{\\r\\nif (!x->aux || !x->aux->alias)\\r\\nreturn NULL;\\r\\nif (len)\\r\\n*len = x->aux->alias->length;\\r\\nreturn x->aux->alias->data;\\r\\n}\\r\\nunsigned char *X509_keyid_get0(X509 *x, int *len)\\r\\n{\\r\\nif (!x->aux || !x->aux->keyid)\\r\\nreturn NULL;\\r\\nif (len)\\r\\n*len = x->aux->keyid->length;\\r\\nreturn x->aux->keyid->data;\\r\\n}\\r\\nint X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj)\\r\\n{\\r\\nX509_CERT_AUX *aux;\\r\\nASN1_OBJECT *objtmp;\\r\\nif (!(objtmp = OBJ_dup(obj)))\\r\\nreturn 0;\\r\\nif (!(aux = aux_get(x)))\\r\\nreturn 0;\\r\\nif (!aux->trust && !(aux->trust = sk_ASN1_OBJECT_new_null()))\\r\\nreturn 0;\\r\\nreturn sk_ASN1_OBJECT_push(aux->trust, objtmp);\\r\\n}\\r\\nint X509_add1_reject_object(X509 *x, ASN1_OBJECT *obj)\\r\\n{\\r\\nX509_CERT_AUX *aux;\\r\\nASN1_OBJECT *objtmp;\\r\\nif (!(objtmp = OBJ_dup(obj)))\\r\\nreturn 0;\\r\\nif (!(aux = aux_get(x)))\\r\\nreturn 0;\\r\\nif (!aux->reject && !(aux->reject = sk_ASN1_OBJECT_new_null()))\\r\\nreturn 0;\\r\\nreturn sk_ASN1_OBJECT_push(aux->reject, objtmp);\\r\\n}\\r\\nvoid X509_trust_clear(X509 *x)\\r\\n{\\r\\nif (x->aux && x->aux->trust) {\\r\\nsk_ASN1_OBJECT_pop_free(x->aux->trust, ASN1_OBJECT_free);\\r\\nx->aux->trust = NULL;\\r\\n}\\r\\n}\\r\\nvoid X509_reject_clear(X509 *x)\\r\\n{\\r\\nif (x->aux && x->aux->reject) {\\r\\nsk_ASN1_OBJECT_pop_free(x->aux->reject, ASN1_OBJECT_free);\\r\\nx->aux->reject = NULL;\\r\\n}\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_t_spki_c", "target": 0, "func": "int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\\r\\n{\\r\\nEVP_PKEY *pkey;\\r\\nASN1_IA5STRING *chal;\\r\\nint i, n;\\r\\nchar *s;\\r\\nBIO_printf(out, \"Netscape SPKI:\\n\");\\r\\ni = OBJ_obj2nid(spki->spkac->pubkey->algor->algorithm);\\r\\nBIO_printf(out, \" Public Key Algorithm: %s\\n\",\\r\\n(i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\\r\\npkey = X509_PUBKEY_get(spki->spkac->pubkey);\\r\\nif (!pkey)\\r\\nBIO_printf(out, \" Unable to load public key\\n\");\\r\\nelse {\\r\\nEVP_PKEY_print_public(out, pkey, 4, NULL);\\r\\nEVP_PKEY_free(pkey);\\r\\n}\\r\\nchal = spki->spkac->challenge;\\r\\nif (chal->length)\\r\\nBIO_printf(out, \" Challenge String: %s\\n\", chal->data);\\r\\ni = OBJ_obj2nid(spki->sig_algor->algorithm);\\r\\nBIO_printf(out, \" Signature Algorithm: %s\",\\r\\n(i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\\r\\nn = spki->signature->length;\\r\\ns = (char *)spki->signature->data;\\r\\nfor (i = 0; i < n; i++) {\\r\\nif ((i % 18) == 0)\\r\\nBIO_write(out, \"\\n \", 7);\\r\\nBIO_printf(out, \"%02x%s\", (unsigned char)s[i],\\r\\n((i + 1) == n) ? \"\" : \":\");\\r\\n}\\r\\nBIO_write(out, \"\\n\", 1);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_eng_cnf_c", "target": 0, "func": "static char *skip_dot(char *name)\\r\\n{\\r\\nchar *p;\\r\\np = strchr(name, '.');\\r\\nif (p)\\r\\nreturn p + 1;\\r\\nreturn name;\\r\\n}\\r\\nstatic int int_engine_init(ENGINE *e)\\r\\n{\\r\\nif (!ENGINE_init(e))\\r\\nreturn 0;\\r\\nif (!initialized_engines)\\r\\ninitialized_engines = sk_ENGINE_new_null();\\r\\nif (!initialized_engines || !sk_ENGINE_push(initialized_engines, e)) {\\r\\nENGINE_finish(e);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_engine_configure(char *name, char *value, const CONF *cnf)\\r\\n{\\r\\nint i;\\r\\nint ret = 0;\\r\\nlong do_init = -1;\\r\\nSTACK_OF(CONF_VALUE) *ecmds;\\r\\nCONF_VALUE *ecmd = NULL;\\r\\nchar *ctrlname, *ctrlvalue;\\r\\nENGINE *e = NULL;\\r\\nint soft = 0;\\r\\nname = skip_dot(name);\\r\\n#ifdef ENGINE_CONF_DEBUG\\r\\nfprintf(stderr, \"Configuring engine %s\\n\", name);\\r\\n#endif\\r\\necmds = NCONF_get_section(cnf, value);\\r\\nif (!ecmds) {\\r\\nENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE,\\r\\nENGINE_R_ENGINE_SECTION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(ecmds); i++) {\\r\\necmd = sk_CONF_VALUE_value(ecmds, i);\\r\\nctrlname = skip_dot(ecmd->name);\\r\\nctrlvalue = ecmd->value;\\r\\n#ifdef ENGINE_CONF_DEBUG\\r\\nfprintf(stderr, \"ENGINE conf: doing ctrl(%s,%s)\\n\", ctrlname,\\r\\nctrlvalue);\\r\\n#endif\\r\\nif (!strcmp(ctrlname, \"engine_id\"))\\r\\nname = ctrlvalue;\\r\\nelse if (!strcmp(ctrlname, \"soft_load\"))\\r\\nsoft = 1;\\r\\nelse if (!strcmp(ctrlname, \"dynamic_path\")) {\\r\\ne = ENGINE_by_id(\"dynamic\");\\r\\nif (!e)\\r\\ngoto err;\\r\\nif (!ENGINE_ctrl_cmd_string(e, \"SO_PATH\", ctrlvalue, 0))\\r\\ngoto err;\\r\\nif (!ENGINE_ctrl_cmd_string(e, \"LIST_ADD\", \"2\", 0))\\r\\ngoto err;\\r\\nif (!ENGINE_ctrl_cmd_string(e, \"LOAD\", NULL, 0))\\r\\ngoto err;\\r\\n}\\r\\nelse {\\r\\nif (!e) {\\r\\ne = ENGINE_by_id(name);\\r\\nif (!e && soft) {\\r\\nERR_clear_error();\\r\\nreturn 1;\\r\\n}\\r\\nif (!e)\\r\\ngoto err;\\r\\n}\\r\\nif (!strcmp(ctrlvalue, \"EMPTY\"))\\r\\nctrlvalue = NULL;\\r\\nif (!strcmp(ctrlname, \"init\")) {\\r\\nif (!NCONF_get_number_e(cnf, value, \"init\", &do_init))\\r\\ngoto err;\\r\\nif (do_init == 1) {\\r\\nif (!int_engine_init(e))\\r\\ngoto err;\\r\\n} else if (do_init != 0) {\\r\\nENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE,\\r\\nENGINE_R_INVALID_INIT_VALUE);\\r\\ngoto err;\\r\\n}\\r\\n} else if (!strcmp(ctrlname, \"default_algorithms\")) {\\r\\nif (!ENGINE_set_default_string(e, ctrlvalue))\\r\\ngoto err;\\r\\n} else if (!ENGINE_ctrl_cmd_string(e, ctrlname, ctrlvalue, 0))\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nif (e && (do_init == -1) && !int_engine_init(e)) {\\r\\necmd = NULL;\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nerr:\\r\\nif (ret != 1) {\\r\\nENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE,\\r\\nENGINE_R_ENGINE_CONFIGURATION_ERROR);\\r\\nif (ecmd)\\r\\nERR_add_error_data(6, \"section=\", ecmd->section,\\r\\n\", name=\", ecmd->name,\\r\\n\", value=\", ecmd->value);\\r\\n}\\r\\nif (e)\\r\\nENGINE_free(e);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int int_engine_module_init(CONF_IMODULE *md, const CONF *cnf)\\r\\n{\\r\\nSTACK_OF(CONF_VALUE) *elist;\\r\\nCONF_VALUE *cval;\\r\\nint i;\\r\\n#ifdef ENGINE_CONF_DEBUG\\r\\nfprintf(stderr, \"Called engine module: name %s, value %s\\n\",\\r\\nCONF_imodule_get_name(md), CONF_imodule_get_value(md));\\r\\n#endif\\r\\nelist = NCONF_get_section(cnf, CONF_imodule_get_value(md));\\r\\nif (!elist) {\\r\\nENGINEerr(ENGINE_F_INT_ENGINE_MODULE_INIT,\\r\\nENGINE_R_ENGINES_SECTION_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nfor (i = 0; i < sk_CONF_VALUE_num(elist); i++) {\\r\\ncval = sk_CONF_VALUE_value(elist, i);\\r\\nif (!int_engine_configure(cval->name, cval->value, cnf))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic void int_engine_module_finish(CONF_IMODULE *md)\\r\\n{\\r\\nENGINE *e;\\r\\nwhile ((e = sk_ENGINE_pop(initialized_engines)))\\r\\nENGINE_finish(e);\\r\\nsk_ENGINE_free(initialized_engines);\\r\\ninitialized_engines = NULL;\\r\\n}\\r\\nvoid ENGINE_add_conf_module(void)\\r\\n{\\r\\nCONF_module_add(\"engines\",\\r\\nint_engine_module_init, int_engine_module_finish);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_depr_c", "target": 0, "func": "RSA *RSA_generate_key(int bits, unsigned long e_value,\\r\\nvoid (*callback) (int, int, void *), void *cb_arg)\\r\\n{\\r\\nBN_GENCB cb;\\r\\nint i;\\r\\nRSA *rsa = RSA_new();\\r\\nBIGNUM *e = BN_new();\\r\\nif (!rsa || !e)\\r\\ngoto err;\\r\\nfor (i = 0; i < (int)sizeof(unsigned long) * 8; i++) {\\r\\nif (e_value & (1UL << i))\\r\\nif (BN_set_bit(e, i) == 0)\\r\\ngoto err;\\r\\n}\\r\\nBN_GENCB_set_old(&cb, callback, cb_arg);\\r\\nif (RSA_generate_key_ex(rsa, bits, e, &cb)) {\\r\\nBN_free(e);\\r\\nreturn rsa;\\r\\n}\\r\\nerr:\\r\\nif (e)\\r\\nBN_free(e);\\r\\nif (rsa)\\r\\nRSA_free(rsa);\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_LPdir_win_c", "target": 0, "func": "const char *LP_find_file(LP_DIR_CTX **ctx, const char *directory)\\r\\n{\\r\\nif (ctx == NULL || directory == NULL) {\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\nerrno = 0;\\r\\nif (*ctx == NULL) {\\r\\nconst char *extdir = directory;\\r\\nchar *extdirbuf = NULL;\\r\\nsize_t dirlen = strlen(directory);\\r\\nif (dirlen == 0) {\\r\\nerrno = ENOENT;\\r\\nreturn 0;\\r\\n}\\r\\n*ctx = (LP_DIR_CTX *)malloc(sizeof(LP_DIR_CTX));\\r\\nif (*ctx == NULL) {\\r\\nerrno = ENOMEM;\\r\\nreturn 0;\\r\\n}\\r\\nmemset(*ctx, '\\0', sizeof(LP_DIR_CTX));\\r\\nif (directory[dirlen - 1] != '*') {\\r\\nextdirbuf = (char *)malloc(dirlen + 3);\\r\\nif (extdirbuf == NULL) {\\r\\nfree(*ctx);\\r\\n*ctx = NULL;\\r\\nerrno = ENOMEM;\\r\\nreturn 0;\\r\\n}\\r\\nif (directory[dirlen - 1] != '/' && directory[dirlen - 1] != '\\\\')\\r\\nextdir = strcat(strcpy(extdirbuf, directory), \"/*\");\\r\\nelse\\r\\nextdir = strcat(strcpy(extdirbuf, directory), \"*\");\\r\\n}\\r\\nif (sizeof(TCHAR) != sizeof(char)) {\\r\\nTCHAR *wdir = NULL;\\r\\nsize_t index = 0, len_0 = strlen(extdir) + 1;\\r\\nwdir = (TCHAR *)calloc(len_0, sizeof(TCHAR));\\r\\nif (wdir == NULL) {\\r\\nif (extdirbuf != NULL) {\\r\\nfree(extdirbuf);\\r\\n}\\r\\nfree(*ctx);\\r\\n*ctx = NULL;\\r\\nerrno = ENOMEM;\\r\\nreturn 0;\\r\\n}\\r\\n#ifdef LP_MULTIBYTE_AVAILABLE\\r\\nif (!MultiByteToWideChar\\r\\n(CP_ACP, 0, extdir, len_0, (WCHAR *)wdir, len_0))\\r\\n#endif\\r\\nfor (index = 0; index < len_0; index++)\\r\\nwdir[index] = (TCHAR)extdir[index];\\r\\n(*ctx)->handle = FindFirstFile(wdir, &(*ctx)->ctx);\\r\\nfree(wdir);\\r\\n} else {\\r\\n(*ctx)->handle = FindFirstFile((TCHAR *)extdir, &(*ctx)->ctx);\\r\\n}\\r\\nif (extdirbuf != NULL) {\\r\\nfree(extdirbuf);\\r\\n}\\r\\nif ((*ctx)->handle == INVALID_HANDLE_VALUE) {\\r\\nfree(*ctx);\\r\\n*ctx = NULL;\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}\\r\\n} else {\\r\\nif (FindNextFile((*ctx)->handle, &(*ctx)->ctx) == FALSE) {\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (sizeof(TCHAR) != sizeof(char)) {\\r\\nTCHAR *wdir = (*ctx)->ctx.cFileName;\\r\\nsize_t index, len_0 = 0;\\r\\nwhile (wdir[len_0] && len_0 < (sizeof((*ctx)->entry_name) - 1))\\r\\nlen_0++;\\r\\nlen_0++;\\r\\n#ifdef LP_MULTIBYTE_AVAILABLE\\r\\nif (!WideCharToMultiByte\\r\\n(CP_ACP, 0, (WCHAR *)wdir, len_0, (*ctx)->entry_name,\\r\\nsizeof((*ctx)->entry_name), NULL, 0))\\r\\n#endif\\r\\nfor (index = 0; index < len_0; index++)\\r\\n(*ctx)->entry_name[index] = (char)wdir[index];\\r\\n} else\\r\\nstrncpy((*ctx)->entry_name, (const char *)(*ctx)->ctx.cFileName,\\r\\nsizeof((*ctx)->entry_name) - 1);\\r\\n(*ctx)->entry_name[sizeof((*ctx)->entry_name) - 1] = '\\0';\\r\\nreturn (*ctx)->entry_name;\\r\\n}\\r\\nint LP_find_file_end(LP_DIR_CTX **ctx)\\r\\n{\\r\\nif (ctx != NULL && *ctx != NULL) {\\r\\nFindClose((*ctx)->handle);\\r\\nfree(*ctx);\\r\\n*ctx = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nerrno = EINVAL;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p5_crpt_c", "target": 0, "func": "void PKCS5_PBE_add(void)\\r\\n{\\r\\n}\\r\\nint PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *cctx, const char *pass, int passlen,\\r\\nASN1_TYPE *param, const EVP_CIPHER *cipher,\\r\\nconst EVP_MD *md, int en_de)\\r\\n{\\r\\nEVP_MD_CTX ctx;\\r\\nunsigned char md_tmp[EVP_MAX_MD_SIZE];\\r\\nunsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];\\r\\nint i;\\r\\nPBEPARAM *pbe;\\r\\nint saltlen, iter;\\r\\nunsigned char *salt;\\r\\nconst unsigned char *pbuf;\\r\\nint mdsize;\\r\\nint rv = 0;\\r\\nEVP_MD_CTX_init(&ctx);\\r\\nif (param == NULL || param->type != V_ASN1_SEQUENCE ||\\r\\nparam->value.sequence == NULL) {\\r\\nEVPerr(EVP_F_PKCS5_PBE_KEYIVGEN, EVP_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\npbuf = param->value.sequence->data;\\r\\nif (!(pbe = d2i_PBEPARAM(NULL, &pbuf, param->value.sequence->length))) {\\r\\nEVPerr(EVP_F_PKCS5_PBE_KEYIVGEN, EVP_R_DECODE_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nif (!pbe->iter)\\r\\niter = 1;\\r\\nelse\\r\\niter = ASN1_INTEGER_get(pbe->iter);\\r\\nsalt = pbe->salt->data;\\r\\nsaltlen = pbe->salt->length;\\r\\nif (!pass)\\r\\npasslen = 0;\\r\\nelse if (passlen == -1)\\r\\npasslen = strlen(pass);\\r\\nif (!EVP_DigestInit_ex(&ctx, md, NULL))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&ctx, pass, passlen))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&ctx, salt, saltlen))\\r\\ngoto err;\\r\\nPBEPARAM_free(pbe);\\r\\nif (!EVP_DigestFinal_ex(&ctx, md_tmp, NULL))\\r\\ngoto err;\\r\\nmdsize = EVP_MD_size(md);\\r\\nif (mdsize < 0)\\r\\nreturn 0;\\r\\nfor (i = 1; i < iter; i++) {\\r\\nif (!EVP_DigestInit_ex(&ctx, md, NULL))\\r\\ngoto err;\\r\\nif (!EVP_DigestUpdate(&ctx, md_tmp, mdsize))\\r\\ngoto err;\\r\\nif (!EVP_DigestFinal_ex(&ctx, md_tmp, NULL))\\r\\ngoto err;\\r\\n}\\r\\nOPENSSL_assert(EVP_CIPHER_key_length(cipher) <= (int)sizeof(md_tmp));\\r\\nmemcpy(key, md_tmp, EVP_CIPHER_key_length(cipher));\\r\\nOPENSSL_assert(EVP_CIPHER_iv_length(cipher) <= 16);\\r\\nmemcpy(iv, md_tmp + (16 - EVP_CIPHER_iv_length(cipher)),\\r\\nEVP_CIPHER_iv_length(cipher));\\r\\nif (!EVP_CipherInit_ex(cctx, cipher, NULL, key, iv, en_de))\\r\\ngoto err;\\r\\nOPENSSL_cleanse(md_tmp, EVP_MAX_MD_SIZE);\\r\\nOPENSSL_cleanse(key, EVP_MAX_KEY_LENGTH);\\r\\nOPENSSL_cleanse(iv, EVP_MAX_IV_LENGTH);\\r\\nrv = 1;\\r\\nerr:\\r\\nEVP_MD_CTX_cleanup(&ctx);\\r\\nreturn rv;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_v3_enum_c", "target": 0, "func": "char *i2s_ASN1_ENUMERATED_TABLE(X509V3_EXT_METHOD *method, ASN1_ENUMERATED *e)\\r\\n{\\r\\nENUMERATED_NAMES *enam;\\r\\nlong strval;\\r\\nstrval = ASN1_ENUMERATED_get(e);\\r\\nfor (enam = method->usr_data; enam->lname; enam++) {\\r\\nif (strval == enam->bitnum)\\r\\nreturn BUF_strdup(enam->lname);\\r\\n}\\r\\nreturn i2s_ASN1_ENUMERATED(method, e);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ui_util_c", "target": 0, "func": "int UI_UTIL_read_pw_string(char *buf, int length, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\nchar buff[BUFSIZ];\\r\\nint ret;\\r\\nret =\\r\\nUI_UTIL_read_pw(buf, buff, (length > BUFSIZ) ? BUFSIZ : length,\\r\\nprompt, verify);\\r\\nOPENSSL_cleanse(buff, BUFSIZ);\\r\\nreturn (ret);\\r\\n}\\r\\nint UI_UTIL_read_pw(char *buf, char *buff, int size, const char *prompt,\\r\\nint verify)\\r\\n{\\r\\nint ok = 0;\\r\\nUI *ui;\\r\\nif (size < 1)\\r\\nreturn -1;\\r\\nui = UI_new();\\r\\nif (ui) {\\r\\nok = UI_add_input_string(ui, prompt, 0, buf, 0, size - 1);\\r\\nif (ok >= 0 && verify)\\r\\nok = UI_add_verify_string(ui, prompt, 0, buff, 0, size - 1, buf);\\r\\nif (ok >= 0)\\r\\nok = UI_process(ui);\\r\\nUI_free(ui);\\r\\n}\\r\\nif (ok > 0)\\r\\nok = 0;\\r\\nreturn (ok);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_capi_err_c", "target": 0, "func": "static void ERR_load_CAPI_strings(void)\\r\\n{\\r\\nif (CAPI_lib_error_code == 0)\\r\\nCAPI_lib_error_code = ERR_get_next_error_library();\\r\\nif (CAPI_error_init) {\\r\\nCAPI_error_init = 0;\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_load_strings(CAPI_lib_error_code, CAPI_str_functs);\\r\\nERR_load_strings(CAPI_lib_error_code, CAPI_str_reasons);\\r\\n#endif\\r\\n#ifdef CAPI_LIB_NAME\\r\\nCAPI_lib_name->error = ERR_PACK(CAPI_lib_error_code, 0, 0);\\r\\nERR_load_strings(0, CAPI_lib_name);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nstatic void ERR_unload_CAPI_strings(void)\\r\\n{\\r\\nif (CAPI_error_init == 0) {\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nERR_unload_strings(CAPI_lib_error_code, CAPI_str_functs);\\r\\nERR_unload_strings(CAPI_lib_error_code, CAPI_str_reasons);\\r\\n#endif\\r\\n#ifdef CAPI_LIB_NAME\\r\\nERR_unload_strings(0, CAPI_lib_name);\\r\\n#endif\\r\\nCAPI_error_init = 1;\\r\\n}\\r\\n}\\r\\nstatic void ERR_CAPI_error(int function, int reason, char *file, int line)\\r\\n{\\r\\nif (CAPI_lib_error_code == 0)\\r\\nCAPI_lib_error_code = ERR_get_next_error_library();\\r\\nERR_PUT_error(CAPI_lib_error_code, function, reason, file, line);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_aes_cfb_c", "target": 0, "func": "void AES_cfb128_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const AES_KEY *key,\\r\\nunsigned char *ivec, int *num, const int enc)\\r\\n{\\r\\nCRYPTO_cfb128_encrypt(in, out, length, key, ivec, num, enc,\\r\\n(block128_f) AES_encrypt);\\r\\n}\\r\\nvoid AES_cfb1_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const AES_KEY *key,\\r\\nunsigned char *ivec, int *num, const int enc)\\r\\n{\\r\\nCRYPTO_cfb128_1_encrypt(in, out, length, key, ivec, num, enc,\\r\\n(block128_f) AES_encrypt);\\r\\n}\\r\\nvoid AES_cfb8_encrypt(const unsigned char *in, unsigned char *out,\\r\\nsize_t length, const AES_KEY *key,\\r\\nunsigned char *ivec, int *num, const int enc)\\r\\n{\\r\\nCRYPTO_cfb128_8_encrypt(in, out, length, key, ivec, num, enc,\\r\\n(block128_f) AES_encrypt);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_asn1_err_c", "target": 1, "func": "void ERR_load_ASN1_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(ASN1_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, ASN1_str_functs);\\r\\nERR_load_strings(0, ASN1_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_err_c", "target": 0, "func": "void ERR_load_X509_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(X509_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, X509_str_functs);\\r\\nERR_load_strings(0, X509_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_lu_c", "target": 0, "func": "X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method)\\r\\n{\\r\\nX509_LOOKUP *ret;\\r\\nret = (X509_LOOKUP *)OPENSSL_malloc(sizeof(X509_LOOKUP));\\r\\nif (ret == NULL)\\r\\nreturn NULL;\\r\\nret->init = 0;\\r\\nret->skip = 0;\\r\\nret->method = method;\\r\\nret->method_data = NULL;\\r\\nret->store_ctx = NULL;\\r\\nif ((method->new_item != NULL) && !method->new_item(ret)) {\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid X509_LOOKUP_free(X509_LOOKUP *ctx)\\r\\n{\\r\\nif (ctx == NULL)\\r\\nreturn;\\r\\nif ((ctx->method != NULL) && (ctx->method->free != NULL))\\r\\n(*ctx->method->free) (ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nint X509_LOOKUP_init(X509_LOOKUP *ctx)\\r\\n{\\r\\nif (ctx->method == NULL)\\r\\nreturn 0;\\r\\nif (ctx->method->init != NULL)\\r\\nreturn ctx->method->init(ctx);\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint X509_LOOKUP_shutdown(X509_LOOKUP *ctx)\\r\\n{\\r\\nif (ctx->method == NULL)\\r\\nreturn 0;\\r\\nif (ctx->method->shutdown != NULL)\\r\\nreturn ctx->method->shutdown(ctx);\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, long argl,\\r\\nchar **ret)\\r\\n{\\r\\nif (ctx->method == NULL)\\r\\nreturn -1;\\r\\nif (ctx->method->ctrl != NULL)\\r\\nreturn ctx->method->ctrl(ctx, cmd, argc, argl, ret);\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nint X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_subject == NULL))\\r\\nreturn X509_LU_FAIL;\\r\\nif (ctx->skip)\\r\\nreturn 0;\\r\\nreturn ctx->method->get_by_subject(ctx, type, name, ret);\\r\\n}\\r\\nint X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name,\\r\\nASN1_INTEGER *serial, X509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_issuer_serial == NULL))\\r\\nreturn X509_LU_FAIL;\\r\\nreturn ctx->method->get_by_issuer_serial(ctx, type, name, serial, ret);\\r\\n}\\r\\nint X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type,\\r\\nunsigned char *bytes, int len,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_fingerprint == NULL))\\r\\nreturn X509_LU_FAIL;\\r\\nreturn ctx->method->get_by_fingerprint(ctx, type, bytes, len, ret);\\r\\n}\\r\\nint X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str, int len,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nif ((ctx->method == NULL) || (ctx->method->get_by_alias == NULL))\\r\\nreturn X509_LU_FAIL;\\r\\nreturn ctx->method->get_by_alias(ctx, type, str, len, ret);\\r\\n}\\r\\nstatic int x509_object_cmp(const X509_OBJECT *const *a,\\r\\nconst X509_OBJECT *const *b)\\r\\n{\\r\\nint ret;\\r\\nret = ((*a)->type - (*b)->type);\\r\\nif (ret)\\r\\nreturn ret;\\r\\nswitch ((*a)->type) {\\r\\ncase X509_LU_X509:\\r\\nret = X509_subject_name_cmp((*a)->data.x509, (*b)->data.x509);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nret = X509_CRL_cmp((*a)->data.crl, (*b)->data.crl);\\r\\nbreak;\\r\\ndefault:\\r\\nreturn 0;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nX509_STORE *X509_STORE_new(void)\\r\\n{\\r\\nX509_STORE *ret;\\r\\nif ((ret = (X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL)\\r\\nreturn NULL;\\r\\nret->objs = sk_X509_OBJECT_new(x509_object_cmp);\\r\\nret->cache = 1;\\r\\nret->get_cert_methods = sk_X509_LOOKUP_new_null();\\r\\nret->verify = 0;\\r\\nret->verify_cb = 0;\\r\\nif ((ret->param = X509_VERIFY_PARAM_new()) == NULL)\\r\\nreturn NULL;\\r\\nret->get_issuer = 0;\\r\\nret->check_issued = 0;\\r\\nret->check_revocation = 0;\\r\\nret->get_crl = 0;\\r\\nret->check_crl = 0;\\r\\nret->cert_crl = 0;\\r\\nret->lookup_certs = 0;\\r\\nret->lookup_crls = 0;\\r\\nret->cleanup = 0;\\r\\nif (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data)) {\\r\\nsk_X509_OBJECT_free(ret->objs);\\r\\nOPENSSL_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nret->references = 1;\\r\\nreturn ret;\\r\\n}\\r\\nstatic void cleanup(X509_OBJECT *a)\\r\\n{\\r\\nif (a->type == X509_LU_X509) {\\r\\nX509_free(a->data.x509);\\r\\n} else if (a->type == X509_LU_CRL) {\\r\\nX509_CRL_free(a->data.crl);\\r\\n} else {\\r\\n}\\r\\nOPENSSL_free(a);\\r\\n}\\r\\nvoid X509_STORE_free(X509_STORE *vfy)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_LOOKUP) *sk;\\r\\nX509_LOOKUP *lu;\\r\\nif (vfy == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&vfy->references, -1, CRYPTO_LOCK_X509_STORE);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_STORE\", vfy);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"X509_STORE_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nsk = vfy->get_cert_methods;\\r\\nfor (i = 0; i < sk_X509_LOOKUP_num(sk); i++) {\\r\\nlu = sk_X509_LOOKUP_value(sk, i);\\r\\nX509_LOOKUP_shutdown(lu);\\r\\nX509_LOOKUP_free(lu);\\r\\n}\\r\\nsk_X509_LOOKUP_free(sk);\\r\\nsk_X509_OBJECT_pop_free(vfy->objs, cleanup);\\r\\nCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE, vfy, &vfy->ex_data);\\r\\nif (vfy->param)\\r\\nX509_VERIFY_PARAM_free(vfy->param);\\r\\nOPENSSL_free(vfy);\\r\\n}\\r\\nX509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)\\r\\n{\\r\\nint i;\\r\\nSTACK_OF(X509_LOOKUP) *sk;\\r\\nX509_LOOKUP *lu;\\r\\nsk = v->get_cert_methods;\\r\\nfor (i = 0; i < sk_X509_LOOKUP_num(sk); i++) {\\r\\nlu = sk_X509_LOOKUP_value(sk, i);\\r\\nif (m == lu->method) {\\r\\nreturn lu;\\r\\n}\\r\\n}\\r\\nlu = X509_LOOKUP_new(m);\\r\\nif (lu == NULL)\\r\\nreturn NULL;\\r\\nelse {\\r\\nlu->store_ctx = v;\\r\\nif (sk_X509_LOOKUP_push(v->get_cert_methods, lu))\\r\\nreturn lu;\\r\\nelse {\\r\\nX509_LOOKUP_free(lu);\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\n}\\r\\nint X509_STORE_get_by_subject(X509_STORE_CTX *vs, int type, X509_NAME *name,\\r\\nX509_OBJECT *ret)\\r\\n{\\r\\nX509_STORE *ctx = vs->ctx;\\r\\nX509_LOOKUP *lu;\\r\\nX509_OBJECT stmp, *tmp;\\r\\nint i, j;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\\r\\ntmp = X509_OBJECT_retrieve_by_subject(ctx->objs, type, name);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nif (tmp == NULL || type == X509_LU_CRL) {\\r\\nfor (i = vs->current_method;\\r\\ni < sk_X509_LOOKUP_num(ctx->get_cert_methods); i++) {\\r\\nlu = sk_X509_LOOKUP_value(ctx->get_cert_methods, i);\\r\\nj = X509_LOOKUP_by_subject(lu, type, name, &stmp);\\r\\nif (j < 0) {\\r\\nvs->current_method = j;\\r\\nreturn j;\\r\\n} else if (j) {\\r\\ntmp = &stmp;\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvs->current_method = 0;\\r\\nif (tmp == NULL)\\r\\nreturn 0;\\r\\n}\\r\\nret->type = tmp->type;\\r\\nret->data.ptr = tmp->data.ptr;\\r\\nX509_OBJECT_up_ref_count(ret);\\r\\nreturn 1;\\r\\n}\\r\\nint X509_STORE_add_cert(X509_STORE *ctx, X509 *x)\\r\\n{\\r\\nX509_OBJECT *obj;\\r\\nint ret = 1;\\r\\nif (x == NULL)\\r\\nreturn 0;\\r\\nobj = (X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));\\r\\nif (obj == NULL) {\\r\\nX509err(X509_F_X509_STORE_ADD_CERT, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nobj->type = X509_LU_X509;\\r\\nobj->data.x509 = x;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\\r\\nX509_OBJECT_up_ref_count(obj);\\r\\nif (X509_OBJECT_retrieve_match(ctx->objs, obj)) {\\r\\nX509_OBJECT_free_contents(obj);\\r\\nOPENSSL_free(obj);\\r\\nX509err(X509_F_X509_STORE_ADD_CERT,\\r\\nX509_R_CERT_ALREADY_IN_HASH_TABLE);\\r\\nret = 0;\\r\\n} else\\r\\nsk_X509_OBJECT_push(ctx->objs, obj);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nreturn ret;\\r\\n}\\r\\nint X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)\\r\\n{\\r\\nX509_OBJECT *obj;\\r\\nint ret = 1;\\r\\nif (x == NULL)\\r\\nreturn 0;\\r\\nobj = (X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));\\r\\nif (obj == NULL) {\\r\\nX509err(X509_F_X509_STORE_ADD_CRL, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\n}\\r\\nobj->type = X509_LU_CRL;\\r\\nobj->data.crl = x;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);\\r\\nX509_OBJECT_up_ref_count(obj);\\r\\nif (X509_OBJECT_retrieve_match(ctx->objs, obj)) {\\r\\nX509_OBJECT_free_contents(obj);\\r\\nOPENSSL_free(obj);\\r\\nX509err(X509_F_X509_STORE_ADD_CRL, X509_R_CERT_ALREADY_IN_HASH_TABLE);\\r\\nret = 0;\\r\\n} else\\r\\nsk_X509_OBJECT_push(ctx->objs, obj);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);\\r\\nreturn ret;\\r\\n}\\r\\nvoid X509_OBJECT_up_ref_count(X509_OBJECT *a)\\r\\n{\\r\\nswitch (a->type) {\\r\\ncase X509_LU_X509:\\r\\nCRYPTO_add(&a->data.x509->references, 1, CRYPTO_LOCK_X509);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nCRYPTO_add(&a->data.crl->references, 1, CRYPTO_LOCK_X509_CRL);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nvoid X509_OBJECT_free_contents(X509_OBJECT *a)\\r\\n{\\r\\nswitch (a->type) {\\r\\ncase X509_LU_X509:\\r\\nX509_free(a->data.x509);\\r\\nbreak;\\r\\ncase X509_LU_CRL:\\r\\nX509_CRL_free(a->data.crl);\\r\\nbreak;\\r\\n}\\r\\n}\\r\\nint X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_flags(ctx->param, flags);\\r\\n}\\r\\nint X509_STORE_set_depth(X509_STORE *ctx, int depth)\\r\\n{\\r\\nX509_VERIFY_PARAM_set_depth(ctx->param, depth);\\r\\nreturn 1;\\r\\n}\\r\\nint X509_STORE_set_purpose(X509_STORE *ctx, int purpose)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_purpose(ctx->param, purpose);\\r\\n}\\r\\nint X509_STORE_set_trust(X509_STORE *ctx, int trust)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set_trust(ctx->param, trust);\\r\\n}\\r\\nint X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *param)\\r\\n{\\r\\nreturn X509_VERIFY_PARAM_set1(ctx->param, param);\\r\\n}\\r\\nvoid X509_STORE_set_verify_cb(X509_STORE *ctx,\\r\\nint (*verify_cb) (int, X509_STORE_CTX *))\\r\\n{\\r\\nctx->verify_cb = verify_cb;\\r\\n}\\r\\nX509_STORE *X509_STORE_CTX_get0_store(X509_STORE_CTX *ctx)\\r\\n{\\r\\nreturn ctx->ctx;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_mbstr_c", "target": 0, "func": "int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in, int len,\\r\\nint inform, unsigned long mask)\\r\\n{\\r\\nreturn ASN1_mbstring_ncopy(out, in, len, inform, mask, 0, 0);\\r\\n}\\r\\nint ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,\\r\\nint inform, unsigned long mask,\\r\\nlong minsize, long maxsize)\\r\\n{\\r\\nint str_type;\\r\\nint ret;\\r\\nchar free_out;\\r\\nint outform, outlen = 0;\\r\\nASN1_STRING *dest;\\r\\nunsigned char *p;\\r\\nint nchar;\\r\\nchar strbuf[32];\\r\\nint (*cpyfunc) (unsigned long, void *) = NULL;\\r\\nif (len == -1)\\r\\nlen = strlen((const char *)in);\\r\\nif (!mask)\\r\\nmask = DIRSTRING_TYPE;\\r\\nswitch (inform) {\\r\\ncase MBSTRING_BMP:\\r\\nif (len & 1) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,\\r\\nASN1_R_INVALID_BMPSTRING_LENGTH);\\r\\nreturn -1;\\r\\n}\\r\\nnchar = len >> 1;\\r\\nbreak;\\r\\ncase MBSTRING_UNIV:\\r\\nif (len & 3) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,\\r\\nASN1_R_INVALID_UNIVERSALSTRING_LENGTH);\\r\\nreturn -1;\\r\\n}\\r\\nnchar = len >> 2;\\r\\nbreak;\\r\\ncase MBSTRING_UTF8:\\r\\nnchar = 0;\\r\\nret = traverse_string(in, len, MBSTRING_UTF8, in_utf8, &nchar);\\r\\nif (ret < 0) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_INVALID_UTF8STRING);\\r\\nreturn -1;\\r\\n}\\r\\nbreak;\\r\\ncase MBSTRING_ASC:\\r\\nnchar = len;\\r\\nbreak;\\r\\ndefault:\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_UNKNOWN_FORMAT);\\r\\nreturn -1;\\r\\n}\\r\\nif ((minsize > 0) && (nchar < minsize)) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_SHORT);\\r\\nBIO_snprintf(strbuf, sizeof strbuf, \"%ld\", minsize);\\r\\nERR_add_error_data(2, \"minsize=\", strbuf);\\r\\nreturn -1;\\r\\n}\\r\\nif ((maxsize > 0) && (nchar > maxsize)) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_LONG);\\r\\nBIO_snprintf(strbuf, sizeof strbuf, \"%ld\", maxsize);\\r\\nERR_add_error_data(2, \"maxsize=\", strbuf);\\r\\nreturn -1;\\r\\n}\\r\\nif (traverse_string(in, len, inform, type_str, &mask) < 0) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_ILLEGAL_CHARACTERS);\\r\\nreturn -1;\\r\\n}\\r\\noutform = MBSTRING_ASC;\\r\\nif (mask & B_ASN1_PRINTABLESTRING)\\r\\nstr_type = V_ASN1_PRINTABLESTRING;\\r\\nelse if (mask & B_ASN1_IA5STRING)\\r\\nstr_type = V_ASN1_IA5STRING;\\r\\nelse if (mask & B_ASN1_T61STRING)\\r\\nstr_type = V_ASN1_T61STRING;\\r\\nelse if (mask & B_ASN1_BMPSTRING) {\\r\\nstr_type = V_ASN1_BMPSTRING;\\r\\noutform = MBSTRING_BMP;\\r\\n} else if (mask & B_ASN1_UNIVERSALSTRING) {\\r\\nstr_type = V_ASN1_UNIVERSALSTRING;\\r\\noutform = MBSTRING_UNIV;\\r\\n} else {\\r\\nstr_type = V_ASN1_UTF8STRING;\\r\\noutform = MBSTRING_UTF8;\\r\\n}\\r\\nif (!out)\\r\\nreturn str_type;\\r\\nif (*out) {\\r\\nfree_out = 0;\\r\\ndest = *out;\\r\\nif (dest->data) {\\r\\ndest->length = 0;\\r\\nOPENSSL_free(dest->data);\\r\\ndest->data = NULL;\\r\\n}\\r\\ndest->type = str_type;\\r\\n} else {\\r\\nfree_out = 1;\\r\\ndest = ASN1_STRING_type_new(str_type);\\r\\nif (!dest) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\n*out = dest;\\r\\n}\\r\\nif (inform == outform) {\\r\\nif (!ASN1_STRING_set(dest, in, len)) {\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nreturn str_type;\\r\\n}\\r\\nswitch (outform) {\\r\\ncase MBSTRING_ASC:\\r\\noutlen = nchar;\\r\\ncpyfunc = cpy_asc;\\r\\nbreak;\\r\\ncase MBSTRING_BMP:\\r\\noutlen = nchar << 1;\\r\\ncpyfunc = cpy_bmp;\\r\\nbreak;\\r\\ncase MBSTRING_UNIV:\\r\\noutlen = nchar << 2;\\r\\ncpyfunc = cpy_univ;\\r\\nbreak;\\r\\ncase MBSTRING_UTF8:\\r\\noutlen = 0;\\r\\ntraverse_string(in, len, inform, out_utf8, &outlen);\\r\\ncpyfunc = cpy_utf8;\\r\\nbreak;\\r\\n}\\r\\nif (!(p = OPENSSL_malloc(outlen + 1))) {\\r\\nif (free_out)\\r\\nASN1_STRING_free(dest);\\r\\nASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\ndest->length = outlen;\\r\\ndest->data = p;\\r\\np[outlen] = 0;\\r\\ntraverse_string(in, len, inform, cpyfunc, &p);\\r\\nreturn str_type;\\r\\n}\\r\\nstatic int traverse_string(const unsigned char *p, int len, int inform,\\r\\nint (*rfunc) (unsigned long value, void *in),\\r\\nvoid *arg)\\r\\n{\\r\\nunsigned long value;\\r\\nint ret;\\r\\nwhile (len) {\\r\\nif (inform == MBSTRING_ASC) {\\r\\nvalue = *p++;\\r\\nlen--;\\r\\n} else if (inform == MBSTRING_BMP) {\\r\\nvalue = *p++ << 8;\\r\\nvalue |= *p++;\\r\\nlen -= 2;\\r\\n} else if (inform == MBSTRING_UNIV) {\\r\\nvalue = ((unsigned long)*p++) << 24;\\r\\nvalue |= ((unsigned long)*p++) << 16;\\r\\nvalue |= *p++ << 8;\\r\\nvalue |= *p++;\\r\\nlen -= 4;\\r\\n} else {\\r\\nret = UTF8_getc(p, len, &value);\\r\\nif (ret < 0)\\r\\nreturn -1;\\r\\nlen -= ret;\\r\\np += ret;\\r\\n}\\r\\nif (rfunc) {\\r\\nret = rfunc(value, arg);\\r\\nif (ret <= 0)\\r\\nreturn ret;\\r\\n}\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int in_utf8(unsigned long value, void *arg)\\r\\n{\\r\\nint *nchar;\\r\\nnchar = arg;\\r\\n(*nchar)++;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int out_utf8(unsigned long value, void *arg)\\r\\n{\\r\\nint *outlen;\\r\\noutlen = arg;\\r\\n*outlen += UTF8_putc(NULL, -1, value);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int type_str(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned long types;\\r\\ntypes = *((unsigned long *)arg);\\r\\nif ((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))\\r\\ntypes &= ~B_ASN1_PRINTABLESTRING;\\r\\nif ((types & B_ASN1_IA5STRING) && (value > 127))\\r\\ntypes &= ~B_ASN1_IA5STRING;\\r\\nif ((types & B_ASN1_T61STRING) && (value > 0xff))\\r\\ntypes &= ~B_ASN1_T61STRING;\\r\\nif ((types & B_ASN1_BMPSTRING) && (value > 0xffff))\\r\\ntypes &= ~B_ASN1_BMPSTRING;\\r\\nif (!types)\\r\\nreturn -1;\\r\\n*((unsigned long *)arg) = types;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cpy_asc(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned char **p, *q;\\r\\np = arg;\\r\\nq = *p;\\r\\n*q = (unsigned char)value;\\r\\n(*p)++;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cpy_bmp(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned char **p, *q;\\r\\np = arg;\\r\\nq = *p;\\r\\n*q++ = (unsigned char)((value >> 8) & 0xff);\\r\\n*q = (unsigned char)(value & 0xff);\\r\\n*p += 2;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cpy_univ(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned char **p, *q;\\r\\np = arg;\\r\\nq = *p;\\r\\n*q++ = (unsigned char)((value >> 24) & 0xff);\\r\\n*q++ = (unsigned char)((value >> 16) & 0xff);\\r\\n*q++ = (unsigned char)((value >> 8) & 0xff);\\r\\n*q = (unsigned char)(value & 0xff);\\r\\n*p += 4;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int cpy_utf8(unsigned long value, void *arg)\\r\\n{\\r\\nunsigned char **p;\\r\\nint ret;\\r\\np = arg;\\r\\nret = UTF8_putc(*p, 0xff, value);\\r\\n*p += ret;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int is_printable(unsigned long value)\\r\\n{\\r\\nint ch;\\r\\nif (value > 0x7f)\\r\\nreturn 0;\\r\\nch = (int)value;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nif ((ch >= 'a') && (ch <= 'z'))\\r\\nreturn 1;\\r\\nif ((ch >= 'A') && (ch <= 'Z'))\\r\\nreturn 1;\\r\\nif ((ch >= '0') && (ch <= '9'))\\r\\nreturn 1;\\r\\nif ((ch == ' ') || strchr(\"'()+,-./:=?\", ch))\\r\\nreturn 1;\\r\\n#else\\r\\nif ((ch >= os_toascii['a']) && (ch <= os_toascii['z']))\\r\\nreturn 1;\\r\\nif ((ch >= os_toascii['A']) && (ch <= os_toascii['Z']))\\r\\nreturn 1;\\r\\nif ((ch >= os_toascii['0']) && (ch <= os_toascii['9']))\\r\\nreturn 1;\\r\\nif ((ch == os_toascii[' ']) || strchr(\"'()+,-./:=?\", os_toebcdic[ch]))\\r\\nreturn 1;\\r\\n#endif\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_p_open_c", "target": 0, "func": "int EVP_OpenInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,\\r\\nconst unsigned char *ek, int ekl, const unsigned char *iv,\\r\\nEVP_PKEY *priv)\\r\\n{\\r\\nunsigned char *key = NULL;\\r\\nint i, size = 0, ret = 0;\\r\\nif (type) {\\r\\nEVP_CIPHER_CTX_init(ctx);\\r\\nif (!EVP_DecryptInit_ex(ctx, type, NULL, NULL, NULL))\\r\\nreturn 0;\\r\\n}\\r\\nif (!priv)\\r\\nreturn 1;\\r\\nif (priv->type != EVP_PKEY_RSA) {\\r\\nEVPerr(EVP_F_EVP_OPENINIT, EVP_R_PUBLIC_KEY_NOT_RSA);\\r\\ngoto err;\\r\\n}\\r\\nsize = RSA_size(priv->pkey.rsa);\\r\\nkey = (unsigned char *)OPENSSL_malloc(size + 2);\\r\\nif (key == NULL) {\\r\\nEVPerr(EVP_F_EVP_OPENINIT, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni = EVP_PKEY_decrypt_old(key, ek, ekl, priv);\\r\\nif ((i <= 0) || !EVP_CIPHER_CTX_set_key_length(ctx, i)) {\\r\\ngoto err;\\r\\n}\\r\\nif (!EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv))\\r\\ngoto err;\\r\\nret = 1;\\r\\nerr:\\r\\nif (key != NULL)\\r\\nOPENSSL_cleanse(key, size);\\r\\nOPENSSL_free(key);\\r\\nreturn (ret);\\r\\n}\\r\\nint EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\\r\\n{\\r\\nint i;\\r\\ni = EVP_DecryptFinal_ex(ctx, out, outl);\\r\\nif (i)\\r\\ni = EVP_DecryptInit_ex(ctx, NULL, NULL, NULL, NULL);\\r\\nreturn (i);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x509_v3_c", "target": 0, "func": "int X509_EXTENSION_set_critical(X509_EXTENSION *ex, int crit)\\r\\n{\\r\\nif (ex == NULL)\\r\\nreturn (0);\\r\\nex->critical = (crit) ? 0xFF : -1;\\r\\nreturn (1);\\r\\n}\\r\\nint X509_EXTENSION_set_data(X509_EXTENSION *ex, ASN1_OCTET_STRING *data)\\r\\n{\\r\\nint i;\\r\\nif (ex == NULL)\\r\\nreturn (0);\\r\\ni = M_ASN1_OCTET_STRING_set(ex->value, data->data, data->length);\\r\\nif (!i)\\r\\nreturn (0);\\r\\nreturn (1);\\r\\n}\\r\\nASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *ex)\\r\\n{\\r\\nif (ex == NULL)\\r\\nreturn (NULL);\\r\\nreturn (ex->object);\\r\\n}\\r\\nASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *ex)\\r\\n{\\r\\nif (ex == NULL)\\r\\nreturn (NULL);\\r\\nreturn (ex->value);\\r\\n}\\r\\nint X509_EXTENSION_get_critical(X509_EXTENSION *ex)\\r\\n{\\r\\nif (ex == NULL)\\r\\nreturn (0);\\r\\nif (ex->critical > 0)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_rc5_c", "target": 0, "func": "static int rc5_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\\r\\n{\\r\\nswitch (type) {\\r\\ncase EVP_CTRL_INIT:\\r\\ndata(c)->rounds = RC5_12_ROUNDS;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_GET_RC5_ROUNDS:\\r\\n*(int *)ptr = data(c)->rounds;\\r\\nreturn 1;\\r\\ncase EVP_CTRL_SET_RC5_ROUNDS:\\r\\nswitch (arg) {\\r\\ncase RC5_8_ROUNDS:\\r\\ncase RC5_12_ROUNDS:\\r\\ncase RC5_16_ROUNDS:\\r\\ndata(c)->rounds = arg;\\r\\nreturn 1;\\r\\ndefault:\\r\\nEVPerr(EVP_F_RC5_CTRL, EVP_R_UNSUPORTED_NUMBER_OF_ROUNDS);\\r\\nreturn 0;\\r\\n}\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nstatic int r_32_12_16_init_key(EVP_CIPHER_CTX *ctx, const unsigned char *key,\\r\\nconst unsigned char *iv, int enc)\\r\\n{\\r\\nRC5_32_set_key(&data(ctx)->ks, EVP_CIPHER_CTX_key_length(ctx),\\r\\nkey, data(ctx)->rounds);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bio_md_c", "target": 0, "func": "BIO_METHOD *BIO_f_md(void)\\r\\n{\\r\\nreturn (&methods_md);\\r\\n}\\r\\nstatic int md_new(BIO *bi)\\r\\n{\\r\\nEVP_MD_CTX *ctx;\\r\\nctx = EVP_MD_CTX_create();\\r\\nif (ctx == NULL)\\r\\nreturn (0);\\r\\nbi->init = 0;\\r\\nbi->ptr = (char *)ctx;\\r\\nbi->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int md_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nEVP_MD_CTX_destroy(a->ptr);\\r\\na->ptr = NULL;\\r\\na->init = 0;\\r\\na->flags = 0;\\r\\nreturn (1);\\r\\n}\\r\\nstatic int md_read(BIO *b, char *out, int outl)\\r\\n{\\r\\nint ret = 0;\\r\\nEVP_MD_CTX *ctx;\\r\\nif (out == NULL)\\r\\nreturn (0);\\r\\nctx = b->ptr;\\r\\nif ((ctx == NULL) || (b->next_bio == NULL))\\r\\nreturn (0);\\r\\nret = BIO_read(b->next_bio, out, outl);\\r\\nif (b->init) {\\r\\nif (ret > 0) {\\r\\nif (EVP_DigestUpdate(ctx, (unsigned char *)out,\\r\\n(unsigned int)ret) <= 0)\\r\\nreturn (-1);\\r\\n}\\r\\n}\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int md_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret = 0;\\r\\nEVP_MD_CTX *ctx;\\r\\nif ((in == NULL) || (inl <= 0))\\r\\nreturn (0);\\r\\nctx = b->ptr;\\r\\nif ((ctx != NULL) && (b->next_bio != NULL))\\r\\nret = BIO_write(b->next_bio, in, inl);\\r\\nif (b->init) {\\r\\nif (ret > 0) {\\r\\nif (!EVP_DigestUpdate(ctx, (const unsigned char *)in,\\r\\n(unsigned int)ret)) {\\r\\nBIO_clear_retry_flags(b);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (b->next_bio != NULL) {\\r\\nBIO_clear_retry_flags(b);\\r\\nBIO_copy_next_retry(b);\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long md_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nEVP_MD_CTX *ctx, *dctx, **pctx;\\r\\nconst EVP_MD **ppmd;\\r\\nEVP_MD *md;\\r\\nlong ret = 1;\\r\\nBIO *dbio;\\r\\nctx = b->ptr;\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_RESET:\\r\\nif (b->init)\\r\\nret = EVP_DigestInit_ex(ctx, ctx->digest, NULL);\\r\\nelse\\r\\nret = 0;\\r\\nif (ret > 0)\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\ncase BIO_C_GET_MD:\\r\\nif (b->init) {\\r\\nppmd = ptr;\\r\\n*ppmd = ctx->digest;\\r\\n} else\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_C_GET_MD_CTX:\\r\\npctx = ptr;\\r\\n*pctx = ctx;\\r\\nb->init = 1;\\r\\nbreak;\\r\\ncase BIO_C_SET_MD_CTX:\\r\\nif (b->init)\\r\\nb->ptr = ptr;\\r\\nelse\\r\\nret = 0;\\r\\nbreak;\\r\\ncase BIO_C_DO_STATE_MACHINE:\\r\\nBIO_clear_retry_flags(b);\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nBIO_copy_next_retry(b);\\r\\nbreak;\\r\\ncase BIO_C_SET_MD:\\r\\nmd = ptr;\\r\\nret = EVP_DigestInit_ex(ctx, md, NULL);\\r\\nif (ret > 0)\\r\\nb->init = 1;\\r\\nbreak;\\r\\ncase BIO_CTRL_DUP:\\r\\ndbio = ptr;\\r\\ndctx = dbio->ptr;\\r\\nif (!EVP_MD_CTX_copy_ex(dctx, ctx))\\r\\nreturn 0;\\r\\nb->init = 1;\\r\\nbreak;\\r\\ndefault:\\r\\nret = BIO_ctrl(b->next_bio, cmd, num, ptr);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long md_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\\r\\n{\\r\\nlong ret = 1;\\r\\nif (b->next_bio == NULL)\\r\\nreturn (0);\\r\\nswitch (cmd) {\\r\\ndefault:\\r\\nret = BIO_callback_ctrl(b->next_bio, cmd, fp);\\r\\nbreak;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int md_gets(BIO *bp, char *buf, int size)\\r\\n{\\r\\nEVP_MD_CTX *ctx;\\r\\nunsigned int ret;\\r\\nctx = bp->ptr;\\r\\nif (size < ctx->digest->md_size)\\r\\nreturn (0);\\r\\nif (EVP_DigestFinal_ex(ctx, (unsigned char *)buf, &ret) <= 0)\\r\\nreturn -1;\\r\\nreturn ((int)ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_err_c", "target": 0, "func": "static void err_fns_check(void)\\r\\n{\\r\\nif (err_fns)\\r\\nreturn;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (!err_fns)\\r\\nerr_fns = &err_defaults;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\n}\\r\\nconst ERR_FNS *ERR_get_implementation(void)\\r\\n{\\r\\nerr_fns_check();\\r\\nreturn err_fns;\\r\\n}\\r\\nint ERR_set_implementation(const ERR_FNS *fns)\\r\\n{\\r\\nint ret = 0;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (!err_fns) {\\r\\nerr_fns = fns;\\r\\nret = 1;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn ret;\\r\\n}\\r\\nstatic unsigned long err_string_data_hash(const ERR_STRING_DATA *a)\\r\\n{\\r\\nunsigned long ret, l;\\r\\nl = a->error;\\r\\nret = l ^ ERR_GET_LIB(l) ^ ERR_GET_FUNC(l);\\r\\nreturn (ret ^ ret % 19 * 13);\\r\\n}\\r\\nvoid int_err_del(void)\\r\\n{\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (int_error_hash) {\\r\\nlh_ERR_STRING_DATA_free(int_error_hash);\\r\\nint_error_hash = NULL;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\n}\\r\\nstatic ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *d)\\r\\n{\\r\\nERR_STRING_DATA *p;\\r\\nLHASH_OF(ERR_STRING_DATA) *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(err_get) (0);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_ERR);\\r\\np = lh_ERR_STRING_DATA_retrieve(hash, d);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn p;\\r\\n}\\r\\nstatic ERR_STRING_DATA *int_err_set_item(ERR_STRING_DATA *d)\\r\\n{\\r\\nERR_STRING_DATA *p;\\r\\nLHASH_OF(ERR_STRING_DATA) *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(err_get) (1);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\np = lh_ERR_STRING_DATA_insert(hash, d);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn p;\\r\\n}\\r\\nstatic ERR_STRING_DATA *int_err_del_item(ERR_STRING_DATA *d)\\r\\n{\\r\\nERR_STRING_DATA *p;\\r\\nLHASH_OF(ERR_STRING_DATA) *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(err_get) (0);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\np = lh_ERR_STRING_DATA_delete(hash, d);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn p;\\r\\n}\\r\\nstatic unsigned long err_state_hash(const ERR_STATE *a)\\r\\n{\\r\\nreturn CRYPTO_THREADID_hash(&a->tid) * 13;\\r\\n}\\r\\nstatic ERR_STATE *int_thread_get_item(const ERR_STATE *d)\\r\\n{\\r\\nERR_STATE *p;\\r\\nLHASH_OF(ERR_STATE) *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(thread_get) (0);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_ERR);\\r\\np = lh_ERR_STATE_retrieve(hash, d);\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR);\\r\\nERRFN(thread_release) (&hash);\\r\\nreturn p;\\r\\n}\\r\\nstatic ERR_STATE *int_thread_set_item(ERR_STATE *d)\\r\\n{\\r\\nERR_STATE *p;\\r\\nLHASH_OF(ERR_STATE) *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(thread_get) (1);\\r\\nif (!hash)\\r\\nreturn NULL;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\np = lh_ERR_STATE_insert(hash, d);\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nERRFN(thread_release) (&hash);\\r\\nreturn p;\\r\\n}\\r\\nstatic void int_thread_del_item(const ERR_STATE *d)\\r\\n{\\r\\nERR_STATE *p;\\r\\nLHASH_OF(ERR_STATE) *hash;\\r\\nerr_fns_check();\\r\\nhash = ERRFN(thread_get) (0);\\r\\nif (!hash)\\r\\nreturn;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\np = lh_ERR_STATE_delete(hash, d);\\r\\nif (int_thread_hash_references == 1\\r\\n&& int_thread_hash && lh_ERR_STATE_num_items(int_thread_hash) == 0) {\\r\\nlh_ERR_STATE_free(int_thread_hash);\\r\\nint_thread_hash = NULL;\\r\\n}\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nERRFN(thread_release) (&hash);\\r\\nif (p)\\r\\nERR_STATE_free(p);\\r\\n}\\r\\nstatic int int_err_get_next_lib(void)\\r\\n{\\r\\nint ret;\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nret = int_err_library_number++;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void build_SYS_str_reasons(void)\\r\\n{\\r\\nstatic char strerror_tab[NUM_SYS_STR_REASONS][LEN_SYS_STR_REASON];\\r\\nint i;\\r\\nstatic int init = 1;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_ERR);\\r\\nif (!init) {\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn;\\r\\n}\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_ERR);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_ERR);\\r\\nif (!init) {\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\nreturn;\\r\\n}\\r\\nfor (i = 1; i <= NUM_SYS_STR_REASONS; i++) {\\r\\nERR_STRING_DATA *str = &SYS_str_reasons[i - 1];\\r\\nstr->error = (unsigned long)i;\\r\\nif (str->string == NULL) {\\r\\nchar (*dest)[LEN_SYS_STR_REASON] = &(strerror_tab[i - 1]);\\r\\nchar *src = strerror(i);\\r\\nif (src != NULL) {\\r\\nstrncpy(*dest, src, sizeof *dest);\\r\\n(*dest)[sizeof *dest - 1] = '\\0';\\r\\nstr->string = *dest;\\r\\n}\\r\\n}\\r\\nif (str->string == NULL)\\r\\nstr->string = \"unknown\";\\r\\n}\\r\\ninit = 0;\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_ERR);\\r\\n}\\r\\nstatic void ERR_STATE_free(ERR_STATE *s)\\r\\n{\\r\\nint i;\\r\\nif (s == NULL)\\r\\nreturn;\\r\\nfor (i = 0; i < ERR_NUM_ERRORS; i++) {\\r\\nerr_clear_data(s, i);\\r\\n}\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nvoid ERR_load_ERR_strings(void)\\r\\n{\\r\\nerr_fns_check();\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nerr_load_strings(0, ERR_str_libraries);\\r\\nerr_load_strings(0, ERR_str_reasons);\\r\\nerr_load_strings(ERR_LIB_SYS, ERR_str_functs);\\r\\nbuild_SYS_str_reasons();\\r\\nerr_load_strings(ERR_LIB_SYS, SYS_str_reasons);\\r\\n#endif\\r\\n}\\r\\nstatic void err_load_strings(int lib, ERR_STRING_DATA *str)\\r\\n{\\r\\nwhile (str->error) {\\r\\nif (lib)\\r\\nstr->error |= ERR_PACK(lib, 0, 0);\\r\\nERRFN(err_set_item) (str);\\r\\nstr++;\\r\\n}\\r\\n}\\r\\nvoid ERR_load_strings(int lib, ERR_STRING_DATA *str)\\r\\n{\\r\\nERR_load_ERR_strings();\\r\\nerr_load_strings(lib, str);\\r\\n}\\r\\nvoid ERR_unload_strings(int lib, ERR_STRING_DATA *str)\\r\\n{\\r\\nwhile (str->error) {\\r\\nif (lib)\\r\\nstr->error |= ERR_PACK(lib, 0, 0);\\r\\nERRFN(err_del_item) (str);\\r\\nstr++;\\r\\n}\\r\\n}\\r\\nvoid ERR_free_strings(void)\\r\\n{\\r\\nerr_fns_check();\\r\\nERRFN(err_del) ();\\r\\n}\\r\\nvoid ERR_put_error(int lib, int func, int reason, const char *file, int line)\\r\\n{\\r\\nERR_STATE *es;\\r\\n#ifdef _OSD_POSIX\\r\\nif (strncmp(file, \"*POSIX(\", sizeof(\"*POSIX(\") - 1) == 0) {\\r\\nchar *end;\\r\\nfile += sizeof(\"*POSIX(\") - 1;\\r\\nend = &file[strlen(file) - 1];\\r\\nif (*end == ')')\\r\\n*end = '\\0';\\r\\nif ((end = strrchr(file, '/')) != NULL)\\r\\nfile = &end[1];\\r\\n}\\r\\n#endif\\r\\nes = ERR_get_state();\\r\\nes->top = (es->top + 1) % ERR_NUM_ERRORS;\\r\\nif (es->top == es->bottom)\\r\\nes->bottom = (es->bottom + 1) % ERR_NUM_ERRORS;\\r\\nes->err_flags[es->top] = 0;\\r\\nes->err_buffer[es->top] = ERR_PACK(lib, func, reason);\\r\\nes->err_file[es->top] = file;\\r\\nes->err_line[es->top] = line;\\r\\nerr_clear_data(es, es->top);\\r\\n}\\r\\nvoid ERR_clear_error(void)\\r\\n{\\r\\nint i;\\r\\nERR_STATE *es;\\r\\nes = ERR_get_state();\\r\\nfor (i = 0; i < ERR_NUM_ERRORS; i++) {\\r\\nerr_clear(es, i);\\r\\n}\\r\\nes->top = es->bottom = 0;\\r\\n}\\r\\nunsigned long ERR_get_error(void)\\r\\n{\\r\\nreturn (get_error_values(1, 0, NULL, NULL, NULL, NULL));\\r\\n}\\r\\nunsigned long ERR_get_error_line(const char **file, int *line)\\r\\n{\\r\\nreturn (get_error_values(1, 0, file, line, NULL, NULL));\\r\\n}\\r\\nunsigned long ERR_get_error_line_data(const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{\\r\\nreturn (get_error_values(1, 0, file, line, data, flags));\\r\\n}\\r\\nunsigned long ERR_peek_error(void)\\r\\n{\\r\\nreturn (get_error_values(0, 0, NULL, NULL, NULL, NULL));\\r\\n}\\r\\nunsigned long ERR_peek_error_line(const char **file, int *line)\\r\\n{\\r\\nreturn (get_error_values(0, 0, file, line, NULL, NULL));\\r\\n}\\r\\nunsigned long ERR_peek_error_line_data(const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{\\r\\nreturn (get_error_values(0, 0, file, line, data, flags));\\r\\n}\\r\\nunsigned long ERR_peek_last_error(void)\\r\\n{\\r\\nreturn (get_error_values(0, 1, NULL, NULL, NULL, NULL));\\r\\n}\\r\\nunsigned long ERR_peek_last_error_line(const char **file, int *line)\\r\\n{\\r\\nreturn (get_error_values(0, 1, file, line, NULL, NULL));\\r\\n}\\r\\nunsigned long ERR_peek_last_error_line_data(const char **file, int *line,\\r\\nconst char **data, int *flags)\\r\\n{\\r\\nreturn (get_error_values(0, 1, file, line, data, flags));\\r\\n}\\r\\nstatic unsigned long get_error_values(int inc, int top, const char **file,\\r\\nint *line, const char **data,\\r\\nint *flags)\\r\\n{\\r\\nint i = 0;\\r\\nERR_STATE *es;\\r\\nunsigned long ret;\\r\\nes = ERR_get_state();\\r\\nif (inc && top) {\\r\\nif (file)\\r\\n*file = \"\";\\r\\nif (line)\\r\\n*line = 0;\\r\\nif (data)\\r\\n*data = \"\";\\r\\nif (flags)\\r\\n*flags = 0;\\r\\nreturn ERR_R_INTERNAL_ERROR;\\r\\n}\\r\\nif (es->bottom == es->top)\\r\\nreturn 0;\\r\\nif (top)\\r\\ni = es->top;\\r\\nelse\\r\\ni = (es->bottom + 1) % ERR_NUM_ERRORS;\\r\\nret = es->err_buffer[i];\\r\\nif (inc) {\\r\\nes->bottom = i;\\r\\nes->err_buffer[i] = 0;\\r\\n}\\r\\nif ((file != NULL) && (line != NULL)) {\\r\\nif (es->err_file[i] == NULL) {\\r\\n*file = \"NA\";\\r\\nif (line != NULL)\\r\\n*line = 0;\\r\\n} else {\\r\\n*file = es->err_file[i];\\r\\nif (line != NULL)\\r\\n*line = es->err_line[i];\\r\\n}\\r\\n}\\r\\nif (data == NULL) {\\r\\nif (inc) {\\r\\nerr_clear_data(es, i);\\r\\n}\\r\\n} else {\\r\\nif (es->err_data[i] == NULL) {\\r\\n*data = \"\";\\r\\nif (flags != NULL)\\r\\n*flags = 0;\\r\\n} else {\\r\\n*data = es->err_data[i];\\r\\nif (flags != NULL)\\r\\n*flags = es->err_data_flags[i];\\r\\n}\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ERR_error_string_n(unsigned long e, char *buf, size_t len)\\r\\n{\\r\\nchar lsbuf[64], fsbuf[64], rsbuf[64];\\r\\nconst char *ls, *fs, *rs;\\r\\nunsigned long l, f, r;\\r\\nl = ERR_GET_LIB(e);\\r\\nf = ERR_GET_FUNC(e);\\r\\nr = ERR_GET_REASON(e);\\r\\nls = ERR_lib_error_string(e);\\r\\nfs = ERR_func_error_string(e);\\r\\nrs = ERR_reason_error_string(e);\\r\\nif (ls == NULL)\\r\\nBIO_snprintf(lsbuf, sizeof(lsbuf), \"lib(%lu)\", l);\\r\\nif (fs == NULL)\\r\\nBIO_snprintf(fsbuf, sizeof(fsbuf), \"func(%lu)\", f);\\r\\nif (rs == NULL)\\r\\nBIO_snprintf(rsbuf, sizeof(rsbuf), \"reason(%lu)\", r);\\r\\nBIO_snprintf(buf, len, \"error:%08lX:%s:%s:%s\", e, ls ? ls : lsbuf,\\r\\nfs ? fs : fsbuf, rs ? rs : rsbuf);\\r\\nif (strlen(buf) == len - 1) {\\r\\n#define NUM_COLONS 4\\r\\nif (len > NUM_COLONS) {\\r\\nint i;\\r\\nchar *s = buf;\\r\\nfor (i = 0; i < NUM_COLONS; i++) {\\r\\nchar *colon = strchr(s, ':');\\r\\nif (colon == NULL || colon > &buf[len - 1] - NUM_COLONS + i) {\\r\\ncolon = &buf[len - 1] - NUM_COLONS + i;\\r\\n*colon = ':';\\r\\n}\\r\\ns = colon + 1;\\r\\n}\\r\\n}\\r\\n}\\r\\n}\\r\\nchar *ERR_error_string(unsigned long e, char *ret)\\r\\n{\\r\\nstatic char buf[256];\\r\\nif (ret == NULL)\\r\\nret = buf;\\r\\nERR_error_string_n(e, ret, 256);\\r\\nreturn ret;\\r\\n}\\r\\nconst char *ERR_lib_error_string(unsigned long e)\\r\\n{\\r\\nERR_STRING_DATA d, *p;\\r\\nunsigned long l;\\r\\nerr_fns_check();\\r\\nl = ERR_GET_LIB(e);\\r\\nd.error = ERR_PACK(l, 0, 0);\\r\\np = ERRFN(err_get_item) (&d);\\r\\nreturn ((p == NULL) ? NULL : p->string);\\r\\n}\\r\\nconst char *ERR_func_error_string(unsigned long e)\\r\\n{\\r\\nERR_STRING_DATA d, *p;\\r\\nunsigned long l, f;\\r\\nerr_fns_check();\\r\\nl = ERR_GET_LIB(e);\\r\\nf = ERR_GET_FUNC(e);\\r\\nd.error = ERR_PACK(l, f, 0);\\r\\np = ERRFN(err_get_item) (&d);\\r\\nreturn ((p == NULL) ? NULL : p->string);\\r\\n}\\r\\nconst char *ERR_reason_error_string(unsigned long e)\\r\\n{\\r\\nERR_STRING_DATA d, *p = NULL;\\r\\nunsigned long l, r;\\r\\nerr_fns_check();\\r\\nl = ERR_GET_LIB(e);\\r\\nr = ERR_GET_REASON(e);\\r\\nd.error = ERR_PACK(l, 0, r);\\r\\np = ERRFN(err_get_item) (&d);\\r\\nif (!p) {\\r\\nd.error = ERR_PACK(0, 0, r);\\r\\np = ERRFN(err_get_item) (&d);\\r\\n}\\r\\nreturn ((p == NULL) ? NULL : p->string);\\r\\n}\\r\\nvoid ERR_remove_thread_state(const CRYPTO_THREADID *id)\\r\\n{\\r\\nERR_STATE tmp;\\r\\nif (id)\\r\\nCRYPTO_THREADID_cpy(&tmp.tid, id);\\r\\nelse\\r\\nCRYPTO_THREADID_current(&tmp.tid);\\r\\nerr_fns_check();\\r\\nERRFN(thread_del_item) (&tmp);\\r\\n}\\r\\nvoid ERR_remove_state(unsigned long pid)\\r\\n{\\r\\nERR_remove_thread_state(NULL);\\r\\n}\\r\\nERR_STATE *ERR_get_state(void)\\r\\n{\\r\\nstatic ERR_STATE fallback;\\r\\nERR_STATE *ret, tmp, *tmpp = NULL;\\r\\nint i;\\r\\nCRYPTO_THREADID tid;\\r\\nerr_fns_check();\\r\\nCRYPTO_THREADID_current(&tid);\\r\\nCRYPTO_THREADID_cpy(&tmp.tid, &tid);\\r\\nret = ERRFN(thread_get_item) (&tmp);\\r\\nif (ret == NULL) {\\r\\nret = (ERR_STATE *)OPENSSL_malloc(sizeof(ERR_STATE));\\r\\nif (ret == NULL)\\r\\nreturn (&fallback);\\r\\nCRYPTO_THREADID_cpy(&ret->tid, &tid);\\r\\nret->top = 0;\\r\\nret->bottom = 0;\\r\\nfor (i = 0; i < ERR_NUM_ERRORS; i++) {\\r\\nret->err_data[i] = NULL;\\r\\nret->err_data_flags[i] = 0;\\r\\n}\\r\\ntmpp = ERRFN(thread_set_item) (ret);\\r\\nif (ERRFN(thread_get_item) (ret) != ret) {\\r\\nERR_STATE_free(ret);\\r\\nreturn (&fallback);\\r\\n}\\r\\nif (tmpp)\\r\\nERR_STATE_free(tmpp);\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nint ERR_get_next_error_library(void)\\r\\n{\\r\\nerr_fns_check();\\r\\nreturn ERRFN(get_next_lib) ();\\r\\n}\\r\\nvoid ERR_set_error_data(char *data, int flags)\\r\\n{\\r\\nERR_STATE *es;\\r\\nint i;\\r\\nes = ERR_get_state();\\r\\ni = es->top;\\r\\nif (i == 0)\\r\\ni = ERR_NUM_ERRORS - 1;\\r\\nerr_clear_data(es, i);\\r\\nes->err_data[i] = data;\\r\\nes->err_data_flags[i] = flags;\\r\\n}\\r\\nvoid ERR_add_error_data(int num, ...)\\r\\n{\\r\\nva_list args;\\r\\nva_start(args, num);\\r\\nERR_add_error_vdata(num, args);\\r\\nva_end(args);\\r\\n}\\r\\nvoid ERR_add_error_vdata(int num, va_list args)\\r\\n{\\r\\nint i, n, s;\\r\\nchar *str, *p, *a;\\r\\ns = 80;\\r\\nstr = OPENSSL_malloc(s + 1);\\r\\nif (str == NULL)\\r\\nreturn;\\r\\nstr[0] = '\\0';\\r\\nn = 0;\\r\\nfor (i = 0; i < num; i++) {\\r\\na = va_arg(args, char *);\\r\\nif (a != NULL) {\\r\\nn += strlen(a);\\r\\nif (n > s) {\\r\\ns = n + 20;\\r\\np = OPENSSL_realloc(str, s + 1);\\r\\nif (p == NULL) {\\r\\nOPENSSL_free(str);\\r\\nreturn;\\r\\n} else\\r\\nstr = p;\\r\\n}\\r\\nBUF_strlcat(str, a, (size_t)s + 1);\\r\\n}\\r\\n}\\r\\nERR_set_error_data(str, ERR_TXT_MALLOCED | ERR_TXT_STRING);\\r\\n}\\r\\nint ERR_set_mark(void)\\r\\n{\\r\\nERR_STATE *es;\\r\\nes = ERR_get_state();\\r\\nif (es->bottom == es->top)\\r\\nreturn 0;\\r\\nes->err_flags[es->top] |= ERR_FLAG_MARK;\\r\\nreturn 1;\\r\\n}\\r\\nint ERR_pop_to_mark(void)\\r\\n{\\r\\nERR_STATE *es;\\r\\nes = ERR_get_state();\\r\\nwhile (es->bottom != es->top\\r\\n&& (es->err_flags[es->top] & ERR_FLAG_MARK) == 0) {\\r\\nerr_clear(es, es->top);\\r\\nes->top -= 1;\\r\\nif (es->top == -1)\\r\\nes->top = ERR_NUM_ERRORS - 1;\\r\\n}\\r\\nif (es->bottom == es->top)\\r\\nreturn 0;\\r\\nes->err_flags[es->top] &= ~ERR_FLAG_MARK;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_prn_c", "target": 0, "func": "int DHparams_print_fp(FILE *fp, const DH *x)\\r\\n{\\r\\nBIO *b;\\r\\nint ret;\\r\\nif ((b = BIO_new(BIO_s_file())) == NULL) {\\r\\nDHerr(DH_F_DHPARAMS_PRINT_FP, ERR_R_BUF_LIB);\\r\\nreturn (0);\\r\\n}\\r\\nBIO_set_fp(b, fp, BIO_NOCLOSE);\\r\\nret = DHparams_print(b, x);\\r\\nBIO_free(b);\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_pkey_c", "target": 0, "func": "int i2d_X509_PKEY(X509_PKEY *a, unsigned char **pp)\\r\\n{\\r\\nreturn (0);\\r\\n}\\r\\nX509_PKEY *d2i_X509_PKEY(X509_PKEY **a, const unsigned char **pp, long length)\\r\\n{\\r\\nint i;\\r\\nM_ASN1_D2I_vars(a, X509_PKEY *, X509_PKEY_new);\\r\\nM_ASN1_D2I_Init();\\r\\nM_ASN1_D2I_start_sequence();\\r\\nM_ASN1_D2I_get_x(X509_ALGOR, ret->enc_algor, d2i_X509_ALGOR);\\r\\nM_ASN1_D2I_get_x(ASN1_OCTET_STRING, ret->enc_pkey, d2i_ASN1_OCTET_STRING);\\r\\nret->cipher.cipher =\\r\\nEVP_get_cipherbyname(OBJ_nid2ln\\r\\n(OBJ_obj2nid(ret->enc_algor->algorithm)));\\r\\nif (ret->cipher.cipher == NULL) {\\r\\nc.error = ASN1_R_UNSUPPORTED_CIPHER;\\r\\nc.line = __LINE__;\\r\\ngoto err;\\r\\n}\\r\\nif (ret->enc_algor->parameter->type == V_ASN1_OCTET_STRING) {\\r\\ni = ret->enc_algor->parameter->value.octet_string->length;\\r\\nif (i > EVP_MAX_IV_LENGTH) {\\r\\nc.error = ASN1_R_IV_TOO_LARGE;\\r\\nc.line = __LINE__;\\r\\ngoto err;\\r\\n}\\r\\nmemcpy(ret->cipher.iv,\\r\\nret->enc_algor->parameter->value.octet_string->data, i);\\r\\n} else\\r\\nmemset(ret->cipher.iv, 0, EVP_MAX_IV_LENGTH);\\r\\nM_ASN1_D2I_Finish(a, X509_PKEY_free, ASN1_F_D2I_X509_PKEY);\\r\\n}\\r\\nX509_PKEY *X509_PKEY_new(void)\\r\\n{\\r\\nX509_PKEY *ret = NULL;\\r\\nASN1_CTX c;\\r\\nM_ASN1_New_Malloc(ret, X509_PKEY);\\r\\nret->version = 0;\\r\\nM_ASN1_New(ret->enc_algor, X509_ALGOR_new);\\r\\nM_ASN1_New(ret->enc_pkey, M_ASN1_OCTET_STRING_new);\\r\\nret->dec_pkey = NULL;\\r\\nret->key_length = 0;\\r\\nret->key_data = NULL;\\r\\nret->key_free = 0;\\r\\nret->cipher.cipher = NULL;\\r\\nmemset(ret->cipher.iv, 0, EVP_MAX_IV_LENGTH);\\r\\nret->references = 1;\\r\\nreturn (ret);\\r\\nM_ASN1_New_Error(ASN1_F_X509_PKEY_NEW);\\r\\n}\\r\\nvoid X509_PKEY_free(X509_PKEY *x)\\r\\n{\\r\\nint i;\\r\\nif (x == NULL)\\r\\nreturn;\\r\\ni = CRYPTO_add(&x->references, -1, CRYPTO_LOCK_X509_PKEY);\\r\\n#ifdef REF_PRINT\\r\\nREF_PRINT(\"X509_PKEY\", x);\\r\\n#endif\\r\\nif (i > 0)\\r\\nreturn;\\r\\n#ifdef REF_CHECK\\r\\nif (i < 0) {\\r\\nfprintf(stderr, \"X509_PKEY_free, bad reference count\\n\");\\r\\nabort();\\r\\n}\\r\\n#endif\\r\\nif (x->enc_algor != NULL)\\r\\nX509_ALGOR_free(x->enc_algor);\\r\\nif (x->enc_pkey != NULL)\\r\\nM_ASN1_OCTET_STRING_free(x->enc_pkey);\\r\\nif (x->dec_pkey != NULL)\\r\\nEVP_PKEY_free(x->dec_pkey);\\r\\nif ((x->key_data != NULL) && (x->key_free))\\r\\nOPENSSL_free(x->key_data);\\r\\nOPENSSL_free(x);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_x_algor_c", "target": 0, "func": "void X509_ALGOR_set_md(X509_ALGOR *alg, const EVP_MD *md)\\r\\n{\\r\\nint param_type;\\r\\nif (md->flags & EVP_MD_FLAG_DIGALGID_ABSENT)\\r\\nparam_type = V_ASN1_UNDEF;\\r\\nelse\\r\\nparam_type = V_ASN1_NULL;\\r\\nX509_ALGOR_set0(alg, OBJ_nid2obj(EVP_MD_type(md)), param_type, NULL);\\r\\n}\\r\\nint X509_ALGOR_cmp(const X509_ALGOR *a, const X509_ALGOR *b)\\r\\n{\\r\\nint rv;\\r\\nrv = OBJ_cmp(a->algorithm, b->algorithm);\\r\\nif (rv)\\r\\nreturn rv;\\r\\nif (!a->parameter && !b->parameter)\\r\\nreturn 0;\\r\\nreturn ASN1_TYPE_cmp(a->parameter, b->parameter);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tasn_utl_c", "target": 0, "func": "int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nint *sel = offset2ptr(*pval, it->utype);\\r\\nreturn *sel;\\r\\n}\\r\\nint asn1_set_choice_selector(ASN1_VALUE **pval, int value,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nint *sel, ret;\\r\\nsel = offset2ptr(*pval, it->utype);\\r\\nret = *sel;\\r\\n*sel = value;\\r\\nreturn ret;\\r\\n}\\r\\nint asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it)\\r\\n{\\r\\nconst ASN1_AUX *aux;\\r\\nint *lck, ret;\\r\\nif ((it->itype != ASN1_ITYPE_SEQUENCE)\\r\\n&& (it->itype != ASN1_ITYPE_NDEF_SEQUENCE))\\r\\nreturn 0;\\r\\naux = it->funcs;\\r\\nif (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT))\\r\\nreturn 0;\\r\\nlck = offset2ptr(*pval, aux->ref_offset);\\r\\nif (op == 0) {\\r\\n*lck = 1;\\r\\nreturn 1;\\r\\n}\\r\\nret = CRYPTO_add(lck, op, aux->ref_lock);\\r\\n#ifdef REF_PRINT\\r\\nfprintf(stderr, \"%s: Reference Count: %d\\n\", it->sname, *lck);\\r\\n#endif\\r\\n#ifdef REF_CHECK\\r\\nif (ret < 0)\\r\\nfprintf(stderr, \"%s, bad reference count\\n\", it->sname);\\r\\n#endif\\r\\nreturn ret;\\r\\n}\\r\\nstatic ASN1_ENCODING *asn1_get_enc_ptr(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nconst ASN1_AUX *aux;\\r\\nif (!pval || !*pval)\\r\\nreturn NULL;\\r\\naux = it->funcs;\\r\\nif (!aux || !(aux->flags & ASN1_AFLG_ENCODING))\\r\\nreturn NULL;\\r\\nreturn offset2ptr(*pval, aux->enc_offset);\\r\\n}\\r\\nvoid asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_ENCODING *enc;\\r\\nenc = asn1_get_enc_ptr(pval, it);\\r\\nif (enc) {\\r\\nenc->enc = NULL;\\r\\nenc->len = 0;\\r\\nenc->modified = 1;\\r\\n}\\r\\n}\\r\\nvoid asn1_enc_free(ASN1_VALUE **pval, const ASN1_ITEM *it)\\r\\n{\\r\\nASN1_ENCODING *enc;\\r\\nenc = asn1_get_enc_ptr(pval, it);\\r\\nif (enc) {\\r\\nif (enc->enc)\\r\\nOPENSSL_free(enc->enc);\\r\\nenc->enc = NULL;\\r\\nenc->len = 0;\\r\\nenc->modified = 1;\\r\\n}\\r\\n}\\r\\nint asn1_enc_save(ASN1_VALUE **pval, const unsigned char *in, int inlen,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nASN1_ENCODING *enc;\\r\\nenc = asn1_get_enc_ptr(pval, it);\\r\\nif (!enc)\\r\\nreturn 1;\\r\\nif (enc->enc)\\r\\nOPENSSL_free(enc->enc);\\r\\nenc->enc = OPENSSL_malloc(inlen);\\r\\nif (!enc->enc)\\r\\nreturn 0;\\r\\nmemcpy(enc->enc, in, inlen);\\r\\nenc->len = inlen;\\r\\nenc->modified = 0;\\r\\nreturn 1;\\r\\n}\\r\\nint asn1_enc_restore(int *len, unsigned char **out, ASN1_VALUE **pval,\\r\\nconst ASN1_ITEM *it)\\r\\n{\\r\\nASN1_ENCODING *enc;\\r\\nenc = asn1_get_enc_ptr(pval, it);\\r\\nif (!enc || enc->modified)\\r\\nreturn 0;\\r\\nif (out) {\\r\\nmemcpy(*out, enc->enc, enc->len);\\r\\n*out += enc->len;\\r\\n}\\r\\nif (len)\\r\\n*len = enc->len;\\r\\nreturn 1;\\r\\n}\\r\\nASN1_VALUE **asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)\\r\\n{\\r\\nASN1_VALUE **pvaltmp;\\r\\nif (tt->flags & ASN1_TFLG_COMBINE)\\r\\nreturn pval;\\r\\npvaltmp = offset2ptr(*pval, tt->offset);\\r\\nreturn pvaltmp;\\r\\n}\\r\\nconst ASN1_TEMPLATE *asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt,\\r\\nint nullerr)\\r\\n{\\r\\nconst ASN1_ADB *adb;\\r\\nconst ASN1_ADB_TABLE *atbl;\\r\\nlong selector;\\r\\nASN1_VALUE **sfld;\\r\\nint i;\\r\\nif (!(tt->flags & ASN1_TFLG_ADB_MASK))\\r\\nreturn tt;\\r\\nadb = ASN1_ADB_ptr(tt->item);\\r\\nsfld = offset2ptr(*pval, adb->offset);\\r\\nif (!sfld) {\\r\\nif (!adb->null_tt)\\r\\ngoto err;\\r\\nreturn adb->null_tt;\\r\\n}\\r\\nif (tt->flags & ASN1_TFLG_ADB_OID)\\r\\nselector = OBJ_obj2nid((ASN1_OBJECT *)*sfld);\\r\\nelse\\r\\nselector = ASN1_INTEGER_get((ASN1_INTEGER *)*sfld);\\r\\nfor (atbl = adb->tbl, i = 0; i < adb->tblcount; i++, atbl++)\\r\\nif (atbl->value == selector)\\r\\nreturn &atbl->tt;\\r\\nif (!adb->default_tt)\\r\\ngoto err;\\r\\nreturn adb->default_tt;\\r\\nerr:\\r\\nif (nullerr)\\r\\nASN1err(ASN1_F_ASN1_DO_ADB, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);\\r\\nreturn NULL;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_comp_lib_c", "target": 0, "func": "COMP_CTX *COMP_CTX_new(COMP_METHOD *meth)\\r\\n{\\r\\nCOMP_CTX *ret;\\r\\nif ((ret = (COMP_CTX *)OPENSSL_malloc(sizeof(COMP_CTX))) == NULL) {\\r\\nreturn (NULL);\\r\\n}\\r\\nmemset(ret, 0, sizeof(COMP_CTX));\\r\\nret->meth = meth;\\r\\nif ((ret->meth->init != NULL) && !ret->meth->init(ret)) {\\r\\nOPENSSL_free(ret);\\r\\nret = NULL;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nvoid COMP_CTX_free(COMP_CTX *ctx)\\r\\n{\\r\\nif (ctx == NULL)\\r\\nreturn;\\r\\nif (ctx->meth->finish != NULL)\\r\\nctx->meth->finish(ctx);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nint COMP_compress_block(COMP_CTX *ctx, unsigned char *out, int olen,\\r\\nunsigned char *in, int ilen)\\r\\n{\\r\\nint ret;\\r\\nif (ctx->meth->compress == NULL) {\\r\\nreturn (-1);\\r\\n}\\r\\nret = ctx->meth->compress(ctx, out, olen, in, ilen);\\r\\nif (ret > 0) {\\r\\nctx->compress_in += ilen;\\r\\nctx->compress_out += ret;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nint COMP_expand_block(COMP_CTX *ctx, unsigned char *out, int olen,\\r\\nunsigned char *in, int ilen)\\r\\n{\\r\\nint ret;\\r\\nif (ctx->meth->expand == NULL) {\\r\\nreturn (-1);\\r\\n}\\r\\nret = ctx->meth->expand(ctx, out, olen, in, ilen);\\r\\nif (ret > 0) {\\r\\nctx->expand_in += ilen;\\r\\nctx->expand_out += ret;\\r\\n}\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_e_capi_c", "target": 0, "func": "static int capi_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void))\\r\\n{\\r\\nint ret = 1;\\r\\nCAPI_CTX *ctx;\\r\\nBIO *out;\\r\\nif (capi_idx == -1) {\\r\\nCAPIerr(CAPI_F_CAPI_CTRL, CAPI_R_ENGINE_NOT_INITIALIZED);\\r\\nreturn 0;\\r\\n}\\r\\nctx = ENGINE_get_ex_data(e, capi_idx);\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\nswitch (cmd) {\\r\\ncase CAPI_CMD_LIST_CSPS:\\r\\nret = capi_list_providers(ctx, out);\\r\\nbreak;\\r\\ncase CAPI_CMD_LIST_CERTS:\\r\\nret = capi_list_certs(ctx, out, NULL);\\r\\nbreak;\\r\\ncase CAPI_CMD_LOOKUP_CERT:\\r\\nret = capi_list_certs(ctx, out, p);\\r\\nbreak;\\r\\ncase CAPI_CMD_LIST_CONTAINERS:\\r\\nret = capi_list_containers(ctx, out);\\r\\nbreak;\\r\\ncase CAPI_CMD_STORE_NAME:\\r\\nif (ctx->storename)\\r\\nOPENSSL_free(ctx->storename);\\r\\nctx->storename = BUF_strdup(p);\\r\\nCAPI_trace(ctx, \"Setting store name to %s\\n\", p);\\r\\nbreak;\\r\\ncase CAPI_CMD_STORE_FLAGS:\\r\\nif (i & 1) {\\r\\nctx->store_flags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;\\r\\nctx->store_flags &= ~CERT_SYSTEM_STORE_CURRENT_USER;\\r\\n} else {\\r\\nctx->store_flags |= CERT_SYSTEM_STORE_CURRENT_USER;\\r\\nctx->store_flags &= ~CERT_SYSTEM_STORE_LOCAL_MACHINE;\\r\\n}\\r\\nCAPI_trace(ctx, \"Setting flags to %d\\n\", i);\\r\\nbreak;\\r\\ncase CAPI_CMD_DEBUG_LEVEL:\\r\\nctx->debug_level = (int)i;\\r\\nCAPI_trace(ctx, \"Setting debug level to %d\\n\", ctx->debug_level);\\r\\nbreak;\\r\\ncase CAPI_CMD_DEBUG_FILE:\\r\\nctx->debug_file = BUF_strdup(p);\\r\\nCAPI_trace(ctx, \"Setting debug file to %s\\n\", ctx->debug_file);\\r\\nbreak;\\r\\ncase CAPI_CMD_KEYTYPE:\\r\\nctx->keytype = i;\\r\\nCAPI_trace(ctx, \"Setting key type to %d\\n\", ctx->keytype);\\r\\nbreak;\\r\\ncase CAPI_CMD_SET_CSP_IDX:\\r\\nret = capi_ctx_set_provname_idx(ctx, i);\\r\\nbreak;\\r\\ncase CAPI_CMD_LIST_OPTIONS:\\r\\nctx->dump_flags = i;\\r\\nbreak;\\r\\ncase CAPI_CMD_LOOKUP_METHOD:\\r\\nif (i < 1 || i > 3) {\\r\\nCAPIerr(CAPI_F_CAPI_CTRL, CAPI_R_INVALID_LOOKUP_METHOD);\\r\\nreturn 0;\\r\\n}\\r\\nctx->lookup_method = i;\\r\\nbreak;\\r\\ncase CAPI_CMD_SET_CSP_NAME:\\r\\nret = capi_ctx_set_provname(ctx, p, ctx->csptype, 1);\\r\\nbreak;\\r\\ncase CAPI_CMD_SET_CSP_TYPE:\\r\\nctx->csptype = i;\\r\\nbreak;\\r\\ndefault:\\r\\nCAPIerr(CAPI_F_CAPI_CTRL, CAPI_R_UNKNOWN_COMMAND);\\r\\nret = 0;\\r\\n}\\r\\nBIO_free(out);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int capi_init(ENGINE *e)\\r\\n{\\r\\nCAPI_CTX *ctx;\\r\\nconst RSA_METHOD *ossl_rsa_meth;\\r\\nconst DSA_METHOD *ossl_dsa_meth;\\r\\nif (capi_idx < 0) {\\r\\ncapi_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL, 0);\\r\\nif (capi_idx < 0)\\r\\ngoto memerr;\\r\\ncert_capi_idx = X509_get_ex_new_index(0, NULL, NULL, NULL, 0);\\r\\nrsa_capi_idx = RSA_get_ex_new_index(0, NULL, NULL, NULL, 0);\\r\\nossl_rsa_meth = RSA_PKCS1_SSLeay();\\r\\ncapi_rsa_method.rsa_pub_enc = ossl_rsa_meth->rsa_pub_enc;\\r\\ncapi_rsa_method.rsa_pub_dec = ossl_rsa_meth->rsa_pub_dec;\\r\\ncapi_rsa_method.rsa_mod_exp = ossl_rsa_meth->rsa_mod_exp;\\r\\ncapi_rsa_method.bn_mod_exp = ossl_rsa_meth->bn_mod_exp;\\r\\ndsa_capi_idx = DSA_get_ex_new_index(0, NULL, NULL, NULL, 0);\\r\\nossl_dsa_meth = DSA_OpenSSL();\\r\\ncapi_dsa_method.dsa_do_verify = ossl_dsa_meth->dsa_do_verify;\\r\\ncapi_dsa_method.dsa_mod_exp = ossl_dsa_meth->dsa_mod_exp;\\r\\ncapi_dsa_method.bn_mod_exp = ossl_dsa_meth->bn_mod_exp;\\r\\n}\\r\\nctx = capi_ctx_new();\\r\\nif (!ctx)\\r\\ngoto memerr;\\r\\nENGINE_set_ex_data(e, capi_idx, ctx);\\r\\n# ifdef OPENSSL_CAPIENG_DIALOG\\r\\n{\\r\\nHMODULE cryptui = LoadLibrary(TEXT(\"CRYPTUI.DLL\"));\\r\\nHMODULE kernel = GetModuleHandle(TEXT(\"KERNEL32.DLL\"));\\r\\nif (cryptui)\\r\\nctx->certselectdlg =\\r\\n(CERTDLG) GetProcAddress(cryptui,\\r\\n\"CryptUIDlgSelectCertificateFromStore\");\\r\\nif (kernel)\\r\\nctx->getconswindow =\\r\\n(GETCONSWIN) GetProcAddress(kernel, \"GetConsoleWindow\");\\r\\nif (cryptui && !OPENSSL_isservice())\\r\\nctx->client_cert_select = cert_select_dialog;\\r\\n}\\r\\n# endif\\r\\nreturn 1;\\r\\nmemerr:\\r\\nCAPIerr(CAPI_F_CAPI_INIT, ERR_R_MALLOC_FAILURE);\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int capi_destroy(ENGINE *e)\\r\\n{\\r\\nERR_unload_CAPI_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int capi_finish(ENGINE *e)\\r\\n{\\r\\nCAPI_CTX *ctx;\\r\\nctx = ENGINE_get_ex_data(e, capi_idx);\\r\\ncapi_ctx_free(ctx);\\r\\nENGINE_set_ex_data(e, capi_idx, NULL);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_capi(ENGINE *e)\\r\\n{\\r\\nif (!ENGINE_set_id(e, engine_capi_id)\\r\\n|| !ENGINE_set_name(e, engine_capi_name)\\r\\n|| !ENGINE_set_flags(e, ENGINE_FLAGS_NO_REGISTER_ALL)\\r\\n|| !ENGINE_set_init_function(e, capi_init)\\r\\n|| !ENGINE_set_finish_function(e, capi_finish)\\r\\n|| !ENGINE_set_destroy_function(e, capi_destroy)\\r\\n|| !ENGINE_set_RSA(e, &capi_rsa_method)\\r\\n|| !ENGINE_set_DSA(e, &capi_dsa_method)\\r\\n|| !ENGINE_set_load_privkey_function(e, capi_load_privkey)\\r\\n|| !ENGINE_set_load_ssl_client_cert_function(e,\\r\\ncapi_load_ssl_client_cert)\\r\\n|| !ENGINE_set_cmd_defns(e, capi_cmd_defns)\\r\\n|| !ENGINE_set_ctrl_function(e, capi_ctrl))\\r\\nreturn 0;\\r\\nERR_load_CAPI_strings();\\r\\nreturn 1;\\r\\n}\\r\\nstatic int bind_helper(ENGINE *e, const char *id)\\r\\n{\\r\\nif (id && (strcmp(id, engine_capi_id) != 0))\\r\\nreturn 0;\\r\\nif (!bind_capi(e))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic ENGINE *engine_capi(void)\\r\\n{\\r\\nENGINE *ret = ENGINE_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!bind_capi(ret)) {\\r\\nENGINE_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nvoid ENGINE_load_capi(void)\\r\\n{\\r\\nENGINE *toadd = engine_capi();\\r\\nif (!toadd)\\r\\nreturn;\\r\\nENGINE_add(toadd);\\r\\nENGINE_free(toadd);\\r\\nERR_clear_error();\\r\\n}\\r\\nstatic int lend_tobn(BIGNUM *bn, unsigned char *bin, int binlen)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < binlen / 2; i++) {\\r\\nunsigned char c;\\r\\nc = bin[i];\\r\\nbin[i] = bin[binlen - i - 1];\\r\\nbin[binlen - i - 1] = c;\\r\\n}\\r\\nif (!BN_bin2bn(bin, binlen, bn))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic EVP_PKEY *capi_get_pkey(ENGINE *eng, CAPI_KEY * key)\\r\\n{\\r\\nunsigned char *pubkey = NULL;\\r\\nDWORD len;\\r\\nBLOBHEADER *bh;\\r\\nRSA *rkey = NULL;\\r\\nDSA *dkey = NULL;\\r\\nEVP_PKEY *ret = NULL;\\r\\nif (!CryptExportKey(key->key, 0, PUBLICKEYBLOB, 0, NULL, &len)) {\\r\\nCAPIerr(CAPI_F_CAPI_GET_PKEY, CAPI_R_PUBKEY_EXPORT_LENGTH_ERROR);\\r\\ncapi_addlasterror();\\r\\nreturn NULL;\\r\\n}\\r\\npubkey = OPENSSL_malloc(len);\\r\\nif (!pubkey)\\r\\ngoto memerr;\\r\\nif (!CryptExportKey(key->key, 0, PUBLICKEYBLOB, 0, pubkey, &len)) {\\r\\nCAPIerr(CAPI_F_CAPI_GET_PKEY, CAPI_R_PUBKEY_EXPORT_ERROR);\\r\\ncapi_addlasterror();\\r\\ngoto err;\\r\\n}\\r\\nbh = (BLOBHEADER *) pubkey;\\r\\nif (bh->bType != PUBLICKEYBLOB) {\\r\\nCAPIerr(CAPI_F_CAPI_GET_PKEY, CAPI_R_INVALID_PUBLIC_KEY_BLOB);\\r\\ngoto err;\\r\\n}\\r\\nif (bh->aiKeyAlg == CALG_RSA_SIGN || bh->aiKeyAlg == CALG_RSA_KEYX) {\\r\\nRSAPUBKEY *rp;\\r\\nDWORD rsa_modlen;\\r\\nunsigned char *rsa_modulus;\\r\\nrp = (RSAPUBKEY *) (bh + 1);\\r\\nif (rp->magic != 0x31415352) {\\r\\nchar magstr[10];\\r\\nBIO_snprintf(magstr, 10, \"%lx\", rp->magic);\\r\\nCAPIerr(CAPI_F_CAPI_GET_PKEY,\\r\\nCAPI_R_INVALID_RSA_PUBLIC_KEY_BLOB_MAGIC_NUMBER);\\r\\nERR_add_error_data(2, \"magic=0x\", magstr);\\r\\ngoto err;\\r\\n}\\r\\nrsa_modulus = (unsigned char *)(rp + 1);\\r\\nrkey = RSA_new_method(eng);\\r\\nif (!rkey)\\r\\ngoto memerr;\\r\\nrkey->e = BN_new();\\r\\nrkey->n = BN_new();\\r\\nif (!rkey->e || !rkey->n)\\r\\ngoto memerr;\\r\\nif (!BN_set_word(rkey->e, rp->pubexp))\\r\\ngoto memerr;\\r\\nrsa_modlen = rp->bitlen / 8;\\r\\nif (!lend_tobn(rkey->n, rsa_modulus, rsa_modlen))\\r\\ngoto memerr;\\r\\nRSA_set_ex_data(rkey, rsa_capi_idx, key);\\r\\nif (!(ret = EVP_PKEY_new()))\\r\\ngoto memerr;\\r\\nEVP_PKEY_assign_RSA(ret, rkey);\\r\\nrkey = NULL;\\r\\n} else if (bh->aiKeyAlg == CALG_DSS_SIGN) {\\r\\nDSSPUBKEY *dp;\\r\\nDWORD dsa_plen;\\r\\nunsigned char *btmp;\\r\\ndp = (DSSPUBKEY *) (bh + 1);\\r\\nif (dp->magic != 0x31535344) {\\r\\nchar magstr[10];\\r\\nBIO_snprintf(magstr, 10, \"%lx\", dp->magic);\\r\\nCAPIerr(CAPI_F_CAPI_GET_PKEY,\\r\\nCAPI_R_INVALID_DSA_PUBLIC_KEY_BLOB_MAGIC_NUMBER);\\r\\nERR_add_error_data(2, \"magic=0x\", magstr);\\r\\ngoto err;\\r\\n}\\r\\ndsa_plen = dp->bitlen / 8;\\r\\nbtmp = (unsigned char *)(dp + 1);\\r\\ndkey = DSA_new_method(eng);\\r\\nif (!dkey)\\r\\ngoto memerr;\\r\\ndkey->p = BN_new();\\r\\ndkey->q = BN_new();\\r\\ndkey->g = BN_new();\\r\\ndkey->pub_key = BN_new();\\r\\nif (!dkey->p || !dkey->q || !dkey->g || !dkey->pub_key)\\r\\ngoto memerr;\\r\\nif (!lend_tobn(dkey->p, btmp, dsa_plen))\\r\\ngoto memerr;\\r\\nbtmp += dsa_plen;\\r\\nif (!lend_tobn(dkey->q, btmp, 20))\\r\\ngoto memerr;\\r\\nbtmp += 20;\\r\\nif (!lend_tobn(dkey->g, btmp, dsa_plen))\\r\\ngoto memerr;\\r\\nbtmp += dsa_plen;\\r\\nif (!lend_tobn(dkey->pub_key, btmp, dsa_plen))\\r\\ngoto memerr;\\r\\nbtmp += dsa_plen;\\r\\nDSA_set_ex_data(dkey, dsa_capi_idx, key);\\r\\nif (!(ret = EVP_PKEY_new()))\\r\\ngoto memerr;\\r\\nEVP_PKEY_assign_DSA(ret, dkey);\\r\\ndkey = NULL;\\r\\n} else {\\r\\nchar algstr[10];\\r\\nBIO_snprintf(algstr, 10, \"%lx\", bh->aiKeyAlg);\\r\\nCAPIerr(CAPI_F_CAPI_GET_PKEY,\\r\\nCAPI_R_UNSUPPORTED_PUBLIC_KEY_ALGORITHM);\\r\\nERR_add_error_data(2, \"aiKeyAlg=0x\", algstr);\\r\\ngoto err;\\r\\n}\\r\\nerr:\\r\\nif (pubkey)\\r\\nOPENSSL_free(pubkey);\\r\\nif (!ret) {\\r\\nif (rkey)\\r\\nRSA_free(rkey);\\r\\nif (dkey)\\r\\nDSA_free(dkey);\\r\\n}\\r\\nreturn ret;\\r\\nmemerr:\\r\\nCAPIerr(CAPI_F_CAPI_GET_PKEY, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nstatic EVP_PKEY *capi_load_privkey(ENGINE *eng, const char *key_id,\\r\\nUI_METHOD *ui_method, void *callback_data)\\r\\n{\\r\\nCAPI_CTX *ctx;\\r\\nCAPI_KEY *key;\\r\\nEVP_PKEY *ret;\\r\\nctx = ENGINE_get_ex_data(eng, capi_idx);\\r\\nif (!ctx) {\\r\\nCAPIerr(CAPI_F_CAPI_LOAD_PRIVKEY, CAPI_R_CANT_FIND_CAPI_CONTEXT);\\r\\nreturn NULL;\\r\\n}\\r\\nkey = capi_find_key(ctx, key_id);\\r\\nif (!key)\\r\\nreturn NULL;\\r\\nret = capi_get_pkey(eng, key);\\r\\nif (!ret)\\r\\ncapi_free_key(key);\\r\\nreturn ret;\\r\\n}\\r\\nint capi_rsa_priv_enc(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nCAPIerr(CAPI_F_CAPI_RSA_PRIV_ENC, CAPI_R_FUNCTION_NOT_SUPPORTED);\\r\\nreturn -1;\\r\\n}\\r\\nint capi_rsa_sign(int dtype, const unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigret, unsigned int *siglen, const RSA *rsa)\\r\\n{\\r\\nALG_ID alg;\\r\\nHCRYPTHASH hash;\\r\\nDWORD slen;\\r\\nunsigned int i;\\r\\nint ret = -1;\\r\\nCAPI_KEY *capi_key;\\r\\nCAPI_CTX *ctx;\\r\\nctx = ENGINE_get_ex_data(rsa->engine, capi_idx);\\r\\nCAPI_trace(ctx, \"Called CAPI_rsa_sign()\\n\");\\r\\ncapi_key = RSA_get_ex_data(rsa, rsa_capi_idx);\\r\\nif (!capi_key) {\\r\\nCAPIerr(CAPI_F_CAPI_RSA_SIGN, CAPI_R_CANT_GET_KEY);\\r\\nreturn -1;\\r\\n}\\r\\nswitch (dtype) {\\r\\ncase NID_sha1:\\r\\nalg = CALG_SHA1;\\r\\nbreak;\\r\\ncase NID_md5:\\r\\nalg = CALG_MD5;\\r\\nbreak;\\r\\ncase NID_md5_sha1:\\r\\nalg = CALG_SSL3_SHAMD5;\\r\\nbreak;\\r\\ndefault:\\r\\n{\\r\\nchar algstr[10];\\r\\nBIO_snprintf(algstr, 10, \"%lx\", dtype);\\r\\nCAPIerr(CAPI_F_CAPI_RSA_SIGN, CAPI_R_UNSUPPORTED_ALGORITHM_NID);\\r\\nERR_add_error_data(2, \"NID=0x\", algstr);\\r\\nreturn -1;\\r\\n}\\r\\n}\\r\\nif (!CryptCreateHash(capi_key->hprov, alg, 0, 0, &hash)) {\\r\\nCAPIerr(CAPI_F_CAPI_RSA_SIGN, CAPI_R_CANT_CREATE_HASH_OBJECT);\\r\\ncapi_addlasterror();\\r\\nreturn -1;\\r\\n}\\r\\nif (!CryptSetHashParam(hash, HP_HASHVAL, (unsigned char *)m, 0)) {\\r\\nCAPIerr(CAPI_F_CAPI_RSA_SIGN, CAPI_R_CANT_SET_HASH_VALUE);\\r\\ncapi_addlasterror();\\r\\ngoto err;\\r\\n}\\r\\nslen = RSA_size(rsa);\\r\\nif (!CryptSignHash(hash, capi_key->keyspec, NULL, 0, sigret, &slen)) {\\r\\nCAPIerr(CAPI_F_CAPI_RSA_SIGN, CAPI_R_ERROR_SIGNING_HASH);\\r\\ncapi_addlasterror();\\r\\ngoto err;\\r\\n} else {\\r\\nret = 1;\\r\\nfor (i = 0; i < slen / 2; i++) {\\r\\nunsigned char c;\\r\\nc = sigret[i];\\r\\nsigret[i] = sigret[slen - i - 1];\\r\\nsigret[slen - i - 1] = c;\\r\\n}\\r\\n*siglen = slen;\\r\\n}\\r\\nerr:\\r\\nCryptDestroyHash(hash);\\r\\nreturn ret;\\r\\n}\\r\\nint capi_rsa_priv_dec(int flen, const unsigned char *from,\\r\\nunsigned char *to, RSA *rsa, int padding)\\r\\n{\\r\\nint i;\\r\\nunsigned char *tmpbuf;\\r\\nCAPI_KEY *capi_key;\\r\\nCAPI_CTX *ctx;\\r\\nctx = ENGINE_get_ex_data(rsa->engine, capi_idx);\\r\\nCAPI_trace(ctx, \"Called capi_rsa_priv_dec()\\n\");\\r\\ncapi_key = RSA_get_ex_data(rsa, rsa_capi_idx);\\r\\nif (!capi_key) {\\r\\nCAPIerr(CAPI_F_CAPI_RSA_PRIV_DEC, CAPI_R_CANT_GET_KEY);\\r\\nreturn -1;\\r\\n}\\r\\nif (padding != RSA_PKCS1_PADDING) {\\r\\nchar errstr[10];\\r\\nBIO_snprintf(errstr, 10, \"%d\", padding);\\r\\nCAPIerr(CAPI_F_CAPI_RSA_PRIV_DEC, CAPI_R_UNSUPPORTED_PADDING);\\r\\nERR_add_error_data(2, \"padding=\", errstr);\\r\\nreturn -1;\\r\\n}\\r\\nif (!(tmpbuf = OPENSSL_malloc(flen))) {\\r\\nCAPIerr(CAPI_F_CAPI_RSA_PRIV_DEC, ERR_R_MALLOC_FAILURE);\\r\\nreturn -1;\\r\\n}\\r\\nfor (i = 0; i < flen; i++)\\r\\ntmpbuf[flen - i - 1] = from[i];\\r\\nif (!CryptDecrypt(capi_key->key, 0, TRUE, 0, tmpbuf, &flen)) {\\r\\nCAPIerr(CAPI_F_CAPI_RSA_PRIV_DEC, CAPI_R_DECRYPT_ERROR);\\r\\ncapi_addlasterror();\\r\\nOPENSSL_free(tmpbuf);\\r\\nreturn -1;\\r\\n} else\\r\\nmemcpy(to, tmpbuf, flen);\\r\\nOPENSSL_free(tmpbuf);\\r\\nreturn flen;\\r\\n}\\r\\nstatic int capi_rsa_free(RSA *rsa)\\r\\n{\\r\\nCAPI_KEY *capi_key;\\r\\ncapi_key = RSA_get_ex_data(rsa, rsa_capi_idx);\\r\\ncapi_free_key(capi_key);\\r\\nRSA_set_ex_data(rsa, rsa_capi_idx, 0);\\r\\nreturn 1;\\r\\n}\\r\\nstatic DSA_SIG *capi_dsa_do_sign(const unsigned char *digest, int dlen,\\r\\nDSA *dsa)\\r\\n{\\r\\nHCRYPTHASH hash;\\r\\nDWORD slen;\\r\\nDSA_SIG *ret = NULL;\\r\\nCAPI_KEY *capi_key;\\r\\nCAPI_CTX *ctx;\\r\\nunsigned char csigbuf[40];\\r\\nctx = ENGINE_get_ex_data(dsa->engine, capi_idx);\\r\\nCAPI_trace(ctx, \"Called CAPI_dsa_do_sign()\\n\");\\r\\ncapi_key = DSA_get_ex_data(dsa, dsa_capi_idx);\\r\\nif (!capi_key) {\\r\\nCAPIerr(CAPI_F_CAPI_DSA_DO_SIGN, CAPI_R_CANT_GET_KEY);\\r\\nreturn NULL;\\r\\n}\\r\\nif (dlen != 20) {\\r\\nCAPIerr(CAPI_F_CAPI_DSA_DO_SIGN, CAPI_R_INVALID_DIGEST_LENGTH);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!CryptCreateHash(capi_key->hprov, CALG_SHA1, 0, 0, &hash)) {\\r\\nCAPIerr(CAPI_F_CAPI_DSA_DO_SIGN, CAPI_R_CANT_CREATE_HASH_OBJECT);\\r\\ncapi_addlasterror();\\r\\nreturn NULL;\\r\\n}\\r\\nif (!CryptSetHashParam(hash, HP_HASHVAL, (unsigned char *)digest, 0)) {\\r\\nCAPIerr(CAPI_F_CAPI_DSA_DO_SIGN, CAPI_R_CANT_SET_HASH_VALUE);\\r\\ncapi_addlasterror();\\r\\ngoto err;\\r\\n}\\r\\nslen = sizeof(csigbuf);\\r\\nif (!CryptSignHash(hash, capi_key->keyspec, NULL, 0, csigbuf, &slen)) {\\r\\nCAPIerr(CAPI_F_CAPI_DSA_DO_SIGN, CAPI_R_ERROR_SIGNING_HASH);\\r\\ncapi_addlasterror();\\r\\ngoto err;\\r\\n} else {\\r\\nret = DSA_SIG_new();\\r\\nif (!ret)\\r\\ngoto err;\\r\\nret->r = BN_new();\\r\\nret->s = BN_new();\\r\\nif (!ret->r || !ret->s)\\r\\ngoto err;\\r\\nif (!lend_tobn(ret->r, csigbuf, 20)\\r\\n|| !lend_tobn(ret->s, csigbuf + 20, 20)) {\\r\\nDSA_SIG_free(ret);\\r\\nret = NULL;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\nerr:\\r\\nOPENSSL_cleanse(csigbuf, 40);\\r\\nCryptDestroyHash(hash);\\r\\nreturn ret;\\r\\n}\\r\\nstatic int capi_dsa_free(DSA *dsa)\\r\\n{\\r\\nCAPI_KEY *capi_key;\\r\\ncapi_key = DSA_get_ex_data(dsa, dsa_capi_idx);\\r\\ncapi_free_key(capi_key);\\r\\nDSA_set_ex_data(dsa, dsa_capi_idx, 0);\\r\\nreturn 1;\\r\\n}\\r\\nstatic void capi_vtrace(CAPI_CTX * ctx, int level, char *format,\\r\\nva_list argptr)\\r\\n{\\r\\nBIO *out;\\r\\nif (!ctx || (ctx->debug_level < level) || (!ctx->debug_file))\\r\\nreturn;\\r\\nout = BIO_new_file(ctx->debug_file, \"a+\");\\r\\nBIO_vprintf(out, format, argptr);\\r\\nBIO_free(out);\\r\\n}\\r\\nstatic void CAPI_trace(CAPI_CTX * ctx, char *format, ...)\\r\\n{\\r\\nva_list args;\\r\\nva_start(args, format);\\r\\ncapi_vtrace(ctx, CAPI_DBG_TRACE, format, args);\\r\\nva_end(args);\\r\\n}\\r\\nstatic void capi_addlasterror(void)\\r\\n{\\r\\ncapi_adderror(GetLastError());\\r\\n}\\r\\nstatic void capi_adderror(DWORD err)\\r\\n{\\r\\nchar errstr[10];\\r\\nBIO_snprintf(errstr, 10, \"%lX\", err);\\r\\nERR_add_error_data(2, \"Error code= 0x\", errstr);\\r\\n}\\r\\nstatic char *wide_to_asc(LPCWSTR wstr)\\r\\n{\\r\\nchar *str;\\r\\nint len_0, sz;\\r\\nif (!wstr)\\r\\nreturn NULL;\\r\\nlen_0 = (int)wcslen(wstr) + 1;\\r\\nsz = WideCharToMultiByte(CP_ACP, 0, wstr, len_0, NULL, 0, NULL, NULL);\\r\\nif (!sz) {\\r\\nCAPIerr(CAPI_F_WIDE_TO_ASC, CAPI_R_WIN32_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nstr = OPENSSL_malloc(sz);\\r\\nif (!str) {\\r\\nCAPIerr(CAPI_F_WIDE_TO_ASC, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!WideCharToMultiByte(CP_ACP, 0, wstr, len_0, str, sz, NULL, NULL)) {\\r\\nOPENSSL_free(str);\\r\\nCAPIerr(CAPI_F_WIDE_TO_ASC, CAPI_R_WIN32_ERROR);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn str;\\r\\n}\\r\\nstatic int capi_get_provname(CAPI_CTX * ctx, LPSTR * pname, DWORD * ptype,\\r\\nDWORD idx)\\r\\n{\\r\\nDWORD len, err;\\r\\nLPTSTR name;\\r\\nCAPI_trace(ctx, \"capi_get_provname, index=%d\\n\", idx);\\r\\nif (!CryptEnumProviders(idx, NULL, 0, ptype, NULL, &len)) {\\r\\nerr = GetLastError();\\r\\nif (err == ERROR_NO_MORE_ITEMS)\\r\\nreturn 2;\\r\\nCAPIerr(CAPI_F_CAPI_GET_PROVNAME, CAPI_R_CRYPTENUMPROVIDERS_ERROR);\\r\\ncapi_adderror(err);\\r\\nreturn 0;\\r\\n}\\r\\nif (sizeof(TCHAR) != sizeof(char))\\r\\nname = alloca(len);\\r\\nelse\\r\\nname = OPENSSL_malloc(len);\\r\\nif (!CryptEnumProviders(idx, NULL, 0, ptype, name, &len)) {\\r\\nerr = GetLastError();\\r\\nif (err == ERROR_NO_MORE_ITEMS)\\r\\nreturn 2;\\r\\nCAPIerr(CAPI_F_CAPI_GET_PROVNAME, CAPI_R_CRYPTENUMPROVIDERS_ERROR);\\r\\ncapi_adderror(err);\\r\\nreturn 0;\\r\\n}\\r\\nif (sizeof(TCHAR) != sizeof(char))\\r\\n*pname = wide_to_asc((WCHAR *)name);\\r\\nelse\\r\\n*pname = (char *)name;\\r\\nCAPI_trace(ctx, \"capi_get_provname, returned name=%s, type=%d\\n\", *pname,\\r\\n*ptype);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int capi_list_providers(CAPI_CTX * ctx, BIO *out)\\r\\n{\\r\\nDWORD idx, ptype;\\r\\nint ret;\\r\\nLPSTR provname = NULL;\\r\\nCAPI_trace(ctx, \"capi_list_providers\\n\");\\r\\nBIO_printf(out, \"Available CSPs:\\n\");\\r\\nfor (idx = 0;; idx++) {\\r\\nret = capi_get_provname(ctx, &provname, &ptype, idx);\\r\\nif (ret == 2)\\r\\nbreak;\\r\\nif (ret == 0)\\r\\nbreak;\\r\\nBIO_printf(out, \"%d. %s, type %d\\n\", idx, provname, ptype);\\r\\nOPENSSL_free(provname);\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int capi_list_containers(CAPI_CTX * ctx, BIO *out)\\r\\n{\\r\\nint ret = 1;\\r\\nHCRYPTPROV hprov;\\r\\nDWORD err, idx, flags, buflen = 0, clen;\\r\\nLPSTR cname;\\r\\nLPTSTR cspname = NULL;\\r\\nCAPI_trace(ctx, \"Listing containers CSP=%s, type = %d\\n\", ctx->cspname,\\r\\nctx->csptype);\\r\\nif (ctx->cspname && sizeof(TCHAR) != sizeof(char)) {\\r\\nif ((clen =\\r\\nMultiByteToWideChar(CP_ACP, 0, ctx->cspname, -1, NULL, 0))) {\\r\\ncspname = alloca(clen * sizeof(WCHAR));\\r\\nMultiByteToWideChar(CP_ACP, 0, ctx->cspname, -1, (WCHAR *)cspname,\\r\\nclen);\\r\\n}\\r\\nif (!cspname) {\\r\\nCAPIerr(CAPI_F_CAPI_LIST_CONTAINERS, ERR_R_MALLOC_FAILURE);\\r\\ncapi_addlasterror();\\r\\nreturn 0;\\r\\n}\\r\\n} else\\r\\ncspname = (TCHAR *)ctx->cspname;\\r\\nif (!CryptAcquireContext\\r\\n(&hprov, NULL, cspname, ctx->csptype, CRYPT_VERIFYCONTEXT)) {\\r\\nCAPIerr(CAPI_F_CAPI_LIST_CONTAINERS,\\r\\nCAPI_R_CRYPTACQUIRECONTEXT_ERROR);\\r\\ncapi_addlasterror();\\r\\nreturn 0;\\r\\n}\\r\\nif (!CryptGetProvParam\\r\\n(hprov, PP_ENUMCONTAINERS, NULL, &buflen, CRYPT_FIRST)) {\\r\\nCAPIerr(CAPI_F_CAPI_LIST_CONTAINERS, CAPI_R_ENUMCONTAINERS_ERROR);\\r\\ncapi_addlasterror();\\r\\nCryptReleaseContext(hprov, 0);\\r\\nreturn 0;\\r\\n}\\r\\nCAPI_trace(ctx, \"Got max container len %d\\n\", buflen);\\r\\nif (buflen == 0)\\r\\nbuflen = 1024;\\r\\ncname = OPENSSL_malloc(buflen);\\r\\nif (!cname) {\\r\\nCAPIerr(CAPI_F_CAPI_LIST_CONTAINERS, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nfor (idx = 0;; idx++) {\\r\\nclen = buflen;\\r\\ncname[0] = 0;\\r\\nif (idx == 0)\\r\\nflags = CRYPT_FIRST;\\r\\nelse\\r\\nflags = 0;\\r\\nif (!CryptGetProvParam\\r\\n(hprov, PP_ENUMCONTAINERS, (BYTE *) cname, &clen, flags)) {\\r\\nerr = GetLastError();\\r\\nif (err == ERROR_NO_MORE_ITEMS)\\r\\ngoto done;\\r\\nCAPIerr(CAPI_F_CAPI_LIST_CONTAINERS, CAPI_R_ENUMCONTAINERS_ERROR);\\r\\ncapi_adderror(err);\\r\\ngoto err;\\r\\n}\\r\\nCAPI_trace(ctx, \"Container name %s, len=%d, index=%d, flags=%d\\n\",\\r\\ncname, clen, idx, flags);\\r\\nif (!cname[0] && (clen == buflen)) {\\r\\nCAPI_trace(ctx, \"Enumerate bug: using workaround\\n\");\\r\\ngoto done;\\r\\n}\\r\\nBIO_printf(out, \"%d. %s\\n\", idx, cname);\\r\\n}\\r\\nerr:\\r\\nret = 0;\\r\\ndone:\\r\\nif (cname)\\r\\nOPENSSL_free(cname);\\r\\nCryptReleaseContext(hprov, 0);\\r\\nreturn ret;\\r\\n}\\r\\nCRYPT_KEY_PROV_INFO *capi_get_prov_info(CAPI_CTX * ctx, PCCERT_CONTEXT cert)\\r\\n{\\r\\nDWORD len;\\r\\nCRYPT_KEY_PROV_INFO *pinfo;\\r\\nif (!CertGetCertificateContextProperty\\r\\n(cert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &len))\\r\\nreturn NULL;\\r\\npinfo = OPENSSL_malloc(len);\\r\\nif (!pinfo) {\\r\\nCAPIerr(CAPI_F_CAPI_GET_PROV_INFO, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nif (!CertGetCertificateContextProperty\\r\\n(cert, CERT_KEY_PROV_INFO_PROP_ID, pinfo, &len)) {\\r\\nCAPIerr(CAPI_F_CAPI_GET_PROV_INFO,\\r\\nCAPI_R_ERROR_GETTING_KEY_PROVIDER_INFO);\\r\\ncapi_addlasterror();\\r\\nOPENSSL_free(pinfo);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn pinfo;\\r\\n}\\r\\nstatic void capi_dump_prov_info(CAPI_CTX * ctx, BIO *out,\\r\\nCRYPT_KEY_PROV_INFO * pinfo)\\r\\n{\\r\\nchar *provname = NULL, *contname = NULL;\\r\\nif (!pinfo) {\\r\\nBIO_printf(out, \" No Private Key\\n\");\\r\\nreturn;\\r\\n}\\r\\nprovname = wide_to_asc(pinfo->pwszProvName);\\r\\ncontname = wide_to_asc(pinfo->pwszContainerName);\\r\\nif (!provname || !contname)\\r\\ngoto err;\\r\\nBIO_printf(out, \" Private Key Info:\\n\");\\r\\nBIO_printf(out, \" Provider Name: %s, Provider Type %d\\n\", provname,\\r\\npinfo->dwProvType);\\r\\nBIO_printf(out, \" Container Name: %s, Key Type %d\\n\", contname,\\r\\npinfo->dwKeySpec);\\r\\nerr:\\r\\nif (provname)\\r\\nOPENSSL_free(provname);\\r\\nif (contname)\\r\\nOPENSSL_free(contname);\\r\\n}\\r\\nchar *capi_cert_get_fname(CAPI_CTX * ctx, PCCERT_CONTEXT cert)\\r\\n{\\r\\nLPWSTR wfname;\\r\\nDWORD dlen;\\r\\nCAPI_trace(ctx, \"capi_cert_get_fname\\n\");\\r\\nif (!CertGetCertificateContextProperty\\r\\n(cert, CERT_FRIENDLY_NAME_PROP_ID, NULL, &dlen))\\r\\nreturn NULL;\\r\\nwfname = OPENSSL_malloc(dlen);\\r\\nif (CertGetCertificateContextProperty\\r\\n(cert, CERT_FRIENDLY_NAME_PROP_ID, wfname, &dlen)) {\\r\\nchar *fname = wide_to_asc(wfname);\\r\\nOPENSSL_free(wfname);\\r\\nreturn fname;\\r\\n}\\r\\nCAPIerr(CAPI_F_CAPI_CERT_GET_FNAME, CAPI_R_ERROR_GETTING_FRIENDLY_NAME);\\r\\ncapi_addlasterror();\\r\\nOPENSSL_free(wfname);\\r\\nreturn NULL;\\r\\n}\\r\\nvoid capi_dump_cert(CAPI_CTX * ctx, BIO *out, PCCERT_CONTEXT cert)\\r\\n{\\r\\nX509 *x;\\r\\nunsigned char *p;\\r\\nunsigned long flags = ctx->dump_flags;\\r\\nif (flags & CAPI_DMP_FNAME) {\\r\\nchar *fname;\\r\\nfname = capi_cert_get_fname(ctx, cert);\\r\\nif (fname) {\\r\\nBIO_printf(out, \" Friendly Name \\\"%s\\\"\\n\", fname);\\r\\nOPENSSL_free(fname);\\r\\n} else\\r\\nBIO_printf(out, \" <No Friendly Name>\\n\");\\r\\n}\\r\\np = cert->pbCertEncoded;\\r\\nx = d2i_X509(NULL, &p, cert->cbCertEncoded);\\r\\nif (!x)\\r\\nBIO_printf(out, \" <Can't parse certificate>\\n\");\\r\\nif (flags & CAPI_DMP_SUMMARY) {\\r\\nBIO_printf(out, \" Subject: \");\\r\\nX509_NAME_print_ex(out, X509_get_subject_name(x), 0, XN_FLAG_ONELINE);\\r\\nBIO_printf(out, \"\\n Issuer: \");\\r\\nX509_NAME_print_ex(out, X509_get_issuer_name(x), 0, XN_FLAG_ONELINE);\\r\\nBIO_printf(out, \"\\n\");\\r\\n}\\r\\nif (flags & CAPI_DMP_FULL)\\r\\nX509_print_ex(out, x, XN_FLAG_ONELINE, 0);\\r\\nif (flags & CAPI_DMP_PKEYINFO) {\\r\\nCRYPT_KEY_PROV_INFO *pinfo;\\r\\npinfo = capi_get_prov_info(ctx, cert);\\r\\ncapi_dump_prov_info(ctx, out, pinfo);\\r\\nif (pinfo)\\r\\nOPENSSL_free(pinfo);\\r\\n}\\r\\nif (flags & CAPI_DMP_PEM)\\r\\nPEM_write_bio_X509(out, x);\\r\\nX509_free(x);\\r\\n}\\r\\nHCERTSTORE capi_open_store(CAPI_CTX * ctx, char *storename)\\r\\n{\\r\\nHCERTSTORE hstore;\\r\\nif (!storename)\\r\\nstorename = ctx->storename;\\r\\nif (!storename)\\r\\nstorename = \"MY\";\\r\\nCAPI_trace(ctx, \"Opening certificate store %s\\n\", storename);\\r\\nhstore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, 0, 0,\\r\\nctx->store_flags, storename);\\r\\nif (!hstore) {\\r\\nCAPIerr(CAPI_F_CAPI_OPEN_STORE, CAPI_R_ERROR_OPENING_STORE);\\r\\ncapi_addlasterror();\\r\\n}\\r\\nreturn hstore;\\r\\n}\\r\\nint capi_list_certs(CAPI_CTX * ctx, BIO *out, char *id)\\r\\n{\\r\\nchar *storename;\\r\\nint idx;\\r\\nint ret = 1;\\r\\nHCERTSTORE hstore;\\r\\nPCCERT_CONTEXT cert = NULL;\\r\\nstorename = ctx->storename;\\r\\nif (!storename)\\r\\nstorename = \"MY\";\\r\\nCAPI_trace(ctx, \"Listing certs for store %s\\n\", storename);\\r\\nhstore = capi_open_store(ctx, storename);\\r\\nif (!hstore)\\r\\nreturn 0;\\r\\nif (id) {\\r\\ncert = capi_find_cert(ctx, id, hstore);\\r\\nif (!cert) {\\r\\nret = 0;\\r\\ngoto err;\\r\\n}\\r\\ncapi_dump_cert(ctx, out, cert);\\r\\nCertFreeCertificateContext(cert);\\r\\n} else {\\r\\nfor (idx = 0;; idx++) {\\r\\ncert = CertEnumCertificatesInStore(hstore, cert);\\r\\nif (!cert)\\r\\nbreak;\\r\\nBIO_printf(out, \"Certificate %d\\n\", idx);\\r\\ncapi_dump_cert(ctx, out, cert);\\r\\n}\\r\\n}\\r\\nerr:\\r\\nCertCloseStore(hstore, 0);\\r\\nreturn ret;\\r\\n}\\r\\nstatic PCCERT_CONTEXT capi_find_cert(CAPI_CTX * ctx, const char *id,\\r\\nHCERTSTORE hstore)\\r\\n{\\r\\nPCCERT_CONTEXT cert = NULL;\\r\\nchar *fname = NULL;\\r\\nint match;\\r\\nswitch (ctx->lookup_method) {\\r\\ncase CAPI_LU_SUBSTR:\\r\\nreturn CertFindCertificateInStore(hstore,\\r\\nX509_ASN_ENCODING, 0,\\r\\nCERT_FIND_SUBJECT_STR_A, id, NULL);\\r\\ncase CAPI_LU_FNAME:\\r\\nfor (;;) {\\r\\ncert = CertEnumCertificatesInStore(hstore, cert);\\r\\nif (!cert)\\r\\nreturn NULL;\\r\\nfname = capi_cert_get_fname(ctx, cert);\\r\\nif (fname) {\\r\\nif (strcmp(fname, id))\\r\\nmatch = 0;\\r\\nelse\\r\\nmatch = 1;\\r\\nOPENSSL_free(fname);\\r\\nif (match)\\r\\nreturn cert;\\r\\n}\\r\\n}\\r\\ndefault:\\r\\nreturn NULL;\\r\\n}\\r\\n}\\r\\nstatic CAPI_KEY *capi_get_key(CAPI_CTX * ctx, const TCHAR *contname,\\r\\nTCHAR *provname, DWORD ptype, DWORD keyspec)\\r\\n{\\r\\nCAPI_KEY *key;\\r\\nDWORD dwFlags = 0;\\r\\nkey = OPENSSL_malloc(sizeof(CAPI_KEY));\\r\\nif (sizeof(TCHAR) == sizeof(char))\\r\\nCAPI_trace(ctx, \"capi_get_key, contname=%s, provname=%s, type=%d\\n\",\\r\\ncontname, provname, ptype);\\r\\nelse if (ctx && ctx->debug_level >= CAPI_DBG_TRACE && ctx->debug_file) {\\r\\nchar *_contname = wide_to_asc((WCHAR *)contname);\\r\\nchar *_provname = wide_to_asc((WCHAR *)provname);\\r\\nCAPI_trace(ctx, \"capi_get_key, contname=%s, provname=%s, type=%d\\n\",\\r\\n_contname, _provname, ptype);\\r\\nif (_provname)\\r\\nOPENSSL_free(_provname);\\r\\nif (_contname)\\r\\nOPENSSL_free(_contname);\\r\\n}\\r\\nif (ctx->store_flags & CERT_SYSTEM_STORE_LOCAL_MACHINE)\\r\\ndwFlags = CRYPT_MACHINE_KEYSET;\\r\\nif (!CryptAcquireContext(&key->hprov, contname, provname, ptype, dwFlags)) {\\r\\nCAPIerr(CAPI_F_CAPI_GET_KEY, CAPI_R_CRYPTACQUIRECONTEXT_ERROR);\\r\\ncapi_addlasterror();\\r\\ngoto err;\\r\\n}\\r\\nif (!CryptGetUserKey(key->hprov, keyspec, &key->key)) {\\r\\nCAPIerr(CAPI_F_CAPI_GET_KEY, CAPI_R_GETUSERKEY_ERROR);\\r\\ncapi_addlasterror();\\r\\nCryptReleaseContext(key->hprov, 0);\\r\\ngoto err;\\r\\n}\\r\\nkey->keyspec = keyspec;\\r\\nkey->pcert = NULL;\\r\\nreturn key;\\r\\nerr:\\r\\nOPENSSL_free(key);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic CAPI_KEY *capi_get_cert_key(CAPI_CTX * ctx, PCCERT_CONTEXT cert)\\r\\n{\\r\\nCAPI_KEY *key = NULL;\\r\\nCRYPT_KEY_PROV_INFO *pinfo = NULL;\\r\\nchar *provname = NULL, *contname = NULL;\\r\\npinfo = capi_get_prov_info(ctx, cert);\\r\\nif (!pinfo)\\r\\ngoto err;\\r\\nif (sizeof(TCHAR) != sizeof(char))\\r\\nkey = capi_get_key(ctx, (TCHAR *)pinfo->pwszContainerName,\\r\\n(TCHAR *)pinfo->pwszProvName,\\r\\npinfo->dwProvType, pinfo->dwKeySpec);\\r\\nelse {\\r\\nprovname = wide_to_asc(pinfo->pwszProvName);\\r\\ncontname = wide_to_asc(pinfo->pwszContainerName);\\r\\nif (!provname || !contname)\\r\\ngoto err;\\r\\nkey = capi_get_key(ctx, (TCHAR *)contname, (TCHAR *)provname,\\r\\npinfo->dwProvType, pinfo->dwKeySpec);\\r\\n}\\r\\nerr:\\r\\nif (pinfo)\\r\\nOPENSSL_free(pinfo);\\r\\nif (provname)\\r\\nOPENSSL_free(provname);\\r\\nif (contname)\\r\\nOPENSSL_free(contname);\\r\\nreturn key;\\r\\n}\\r\\nCAPI_KEY *capi_find_key(CAPI_CTX * ctx, const char *id)\\r\\n{\\r\\nPCCERT_CONTEXT cert;\\r\\nHCERTSTORE hstore;\\r\\nCAPI_KEY *key = NULL;\\r\\nswitch (ctx->lookup_method) {\\r\\ncase CAPI_LU_SUBSTR:\\r\\ncase CAPI_LU_FNAME:\\r\\nhstore = capi_open_store(ctx, NULL);\\r\\nif (!hstore)\\r\\nreturn NULL;\\r\\ncert = capi_find_cert(ctx, id, hstore);\\r\\nif (cert) {\\r\\nkey = capi_get_cert_key(ctx, cert);\\r\\nCertFreeCertificateContext(cert);\\r\\n}\\r\\nCertCloseStore(hstore, 0);\\r\\nbreak;\\r\\ncase CAPI_LU_CONTNAME:\\r\\nif (sizeof(TCHAR) != sizeof(char)) {\\r\\nWCHAR *contname, *provname;\\r\\nDWORD len;\\r\\nif ((len = MultiByteToWideChar(CP_ACP, 0, id, -1, NULL, 0)) &&\\r\\n(contname = alloca(len * sizeof(WCHAR)),\\r\\nMultiByteToWideChar(CP_ACP, 0, id, -1, contname, len)) &&\\r\\n(len =\\r\\nMultiByteToWideChar(CP_ACP, 0, ctx->cspname, -1, NULL, 0))\\r\\n&& (provname =\\r\\nalloca(len * sizeof(WCHAR)), MultiByteToWideChar(CP_ACP,\\r\\n0,\\r\\nctx->cspname,\\r\\n-1,\\r\\nprovname,\\r\\nlen)))\\r\\nkey =\\r\\ncapi_get_key(ctx, (TCHAR *)contname, (TCHAR *)provname,\\r\\nctx->csptype, ctx->keytype);\\r\\n} else\\r\\nkey = capi_get_key(ctx, (TCHAR *)id,\\r\\n(TCHAR *)ctx->cspname,\\r\\nctx->csptype, ctx->keytype);\\r\\nbreak;\\r\\n}\\r\\nreturn key;\\r\\n}\\r\\nvoid capi_free_key(CAPI_KEY * key)\\r\\n{\\r\\nif (!key)\\r\\nreturn;\\r\\nCryptDestroyKey(key->key);\\r\\nCryptReleaseContext(key->hprov, 0);\\r\\nif (key->pcert)\\r\\nCertFreeCertificateContext(key->pcert);\\r\\nOPENSSL_free(key);\\r\\n}\\r\\nstatic CAPI_CTX *capi_ctx_new()\\r\\n{\\r\\nCAPI_CTX *ctx;\\r\\nctx = OPENSSL_malloc(sizeof(CAPI_CTX));\\r\\nif (!ctx) {\\r\\nCAPIerr(CAPI_F_CAPI_CTX_NEW, ERR_R_MALLOC_FAILURE);\\r\\nreturn NULL;\\r\\n}\\r\\nctx->cspname = NULL;\\r\\nctx->csptype = PROV_RSA_FULL;\\r\\nctx->dump_flags = CAPI_DMP_SUMMARY | CAPI_DMP_FNAME;\\r\\nctx->keytype = AT_KEYEXCHANGE;\\r\\nctx->storename = NULL;\\r\\nctx->ssl_client_store = NULL;\\r\\nctx->store_flags = CERT_STORE_OPEN_EXISTING_FLAG |\\r\\nCERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_CURRENT_USER;\\r\\nctx->lookup_method = CAPI_LU_SUBSTR;\\r\\nctx->debug_level = 0;\\r\\nctx->debug_file = NULL;\\r\\nctx->client_cert_select = cert_select_simple;\\r\\nreturn ctx;\\r\\n}\\r\\nstatic void capi_ctx_free(CAPI_CTX * ctx)\\r\\n{\\r\\nCAPI_trace(ctx, \"Calling capi_ctx_free with %lx\\n\", ctx);\\r\\nif (!ctx)\\r\\nreturn;\\r\\nif (ctx->cspname)\\r\\nOPENSSL_free(ctx->cspname);\\r\\nif (ctx->debug_file)\\r\\nOPENSSL_free(ctx->debug_file);\\r\\nif (ctx->storename)\\r\\nOPENSSL_free(ctx->storename);\\r\\nif (ctx->ssl_client_store)\\r\\nOPENSSL_free(ctx->ssl_client_store);\\r\\nOPENSSL_free(ctx);\\r\\n}\\r\\nstatic int capi_ctx_set_provname(CAPI_CTX * ctx, LPSTR pname, DWORD type,\\r\\nint check)\\r\\n{\\r\\nCAPI_trace(ctx, \"capi_ctx_set_provname, name=%s, type=%d\\n\", pname, type);\\r\\nif (check) {\\r\\nHCRYPTPROV hprov;\\r\\nLPTSTR name = NULL;\\r\\nif (sizeof(TCHAR) != sizeof(char)) {\\r\\nDWORD len;\\r\\nif ((len = MultiByteToWideChar(CP_ACP, 0, pname, -1, NULL, 0))) {\\r\\nname = alloca(len * sizeof(WCHAR));\\r\\nMultiByteToWideChar(CP_ACP, 0, pname, -1, (WCHAR *)name, len);\\r\\n}\\r\\n} else\\r\\nname = (TCHAR *)pname;\\r\\nif (!name || !CryptAcquireContext(&hprov, NULL, name, type,\\r\\nCRYPT_VERIFYCONTEXT)) {\\r\\nCAPIerr(CAPI_F_CAPI_CTX_SET_PROVNAME,\\r\\nCAPI_R_CRYPTACQUIRECONTEXT_ERROR);\\r\\ncapi_addlasterror();\\r\\nreturn 0;\\r\\n}\\r\\nCryptReleaseContext(hprov, 0);\\r\\n}\\r\\nif (ctx->cspname)\\r\\nOPENSSL_free(ctx->cspname);\\r\\nctx->cspname = BUF_strdup(pname);\\r\\nctx->csptype = type;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int capi_ctx_set_provname_idx(CAPI_CTX * ctx, int idx)\\r\\n{\\r\\nLPSTR pname;\\r\\nDWORD type;\\r\\nint res;\\r\\nif (capi_get_provname(ctx, &pname, &type, idx) != 1)\\r\\nreturn 0;\\r\\nres = capi_ctx_set_provname(ctx, pname, type, 0);\\r\\nOPENSSL_free(pname);\\r\\nreturn res;\\r\\n}\\r\\nOPENSSL_EXPORT\\r\\nint bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns)\\r\\n{\\r\\nreturn 0;\\r\\n}\\r\\nvoid ENGINE_load_capi(void)\\r\\n{\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_tb_dsa_c", "target": 0, "func": "void ENGINE_unregister_DSA(ENGINE *e)\\r\\n{\\r\\nengine_table_unregister(&dsa_table, e);\\r\\n}\\r\\nstatic void engine_unregister_all_DSA(void)\\r\\n{\\r\\nengine_table_cleanup(&dsa_table);\\r\\n}\\r\\nint ENGINE_register_DSA(ENGINE *e)\\r\\n{\\r\\nif (e->dsa_meth)\\r\\nreturn engine_table_register(&dsa_table,\\r\\nengine_unregister_all_DSA, e, &dummy_nid,\\r\\n1, 0);\\r\\nreturn 1;\\r\\n}\\r\\nvoid ENGINE_register_all_DSA()\\r\\n{\\r\\nENGINE *e;\\r\\nfor (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))\\r\\nENGINE_register_DSA(e);\\r\\n}\\r\\nint ENGINE_set_default_DSA(ENGINE *e)\\r\\n{\\r\\nif (e->dsa_meth)\\r\\nreturn engine_table_register(&dsa_table,\\r\\nengine_unregister_all_DSA, e, &dummy_nid,\\r\\n1, 1);\\r\\nreturn 1;\\r\\n}\\r\\nENGINE *ENGINE_get_default_DSA(void)\\r\\n{\\r\\nreturn engine_table_select(&dsa_table, dummy_nid);\\r\\n}\\r\\nconst DSA_METHOD *ENGINE_get_DSA(const ENGINE *e)\\r\\n{\\r\\nreturn e->dsa_meth;\\r\\n}\\r\\nint ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth)\\r\\n{\\r\\ne->dsa_meth = dsa_meth;\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_dh_ameth_c", "target": 0, "func": "static DH *d2i_dhp(const EVP_PKEY *pkey, const unsigned char **pp,\\r\\nlong length)\\r\\n{\\r\\nif (pkey->ameth == &dhx_asn1_meth)\\r\\nreturn d2i_DHxparams(NULL, pp, length);\\r\\nreturn d2i_DHparams(NULL, pp, length);\\r\\n}\\r\\nstatic int i2d_dhp(const EVP_PKEY *pkey, const DH *a, unsigned char **pp)\\r\\n{\\r\\nif (pkey->ameth == &dhx_asn1_meth)\\r\\nreturn i2d_DHxparams(a, pp);\\r\\nreturn i2d_DHparams(a, pp);\\r\\n}\\r\\nstatic void int_dh_free(EVP_PKEY *pkey)\\r\\n{\\r\\nDH_free(pkey->pkey.dh);\\r\\n}\\r\\nstatic int dh_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)\\r\\n{\\r\\nconst unsigned char *p, *pm;\\r\\nint pklen, pmlen;\\r\\nint ptype;\\r\\nvoid *pval;\\r\\nASN1_STRING *pstr;\\r\\nX509_ALGOR *palg;\\r\\nASN1_INTEGER *public_key = NULL;\\r\\nDH *dh = NULL;\\r\\nif (!X509_PUBKEY_get0_param(NULL, &p, &pklen, &palg, pubkey))\\r\\nreturn 0;\\r\\nX509_ALGOR_get0(NULL, &ptype, &pval, palg);\\r\\nif (ptype != V_ASN1_SEQUENCE) {\\r\\nDHerr(DH_F_DH_PUB_DECODE, DH_R_PARAMETER_ENCODING_ERROR);\\r\\ngoto err;\\r\\n}\\r\\npstr = pval;\\r\\npm = pstr->data;\\r\\npmlen = pstr->length;\\r\\nif (!(dh = d2i_dhp(pkey, &pm, pmlen))) {\\r\\nDHerr(DH_F_DH_PUB_DECODE, DH_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!(public_key = d2i_ASN1_INTEGER(NULL, &p, pklen))) {\\r\\nDHerr(DH_F_DH_PUB_DECODE, DH_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!(dh->pub_key = ASN1_INTEGER_to_BN(public_key, NULL))) {\\r\\nDHerr(DH_F_DH_PUB_DECODE, DH_R_BN_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nASN1_INTEGER_free(public_key);\\r\\nEVP_PKEY_assign(pkey, pkey->ameth->pkey_id, dh);\\r\\nreturn 1;\\r\\nerr:\\r\\nif (public_key)\\r\\nASN1_INTEGER_free(public_key);\\r\\nif (dh)\\r\\nDH_free(dh);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dh_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)\\r\\n{\\r\\nDH *dh;\\r\\nvoid *pval = NULL;\\r\\nint ptype;\\r\\nunsigned char *penc = NULL;\\r\\nint penclen;\\r\\nASN1_STRING *str;\\r\\nASN1_INTEGER *pub_key = NULL;\\r\\ndh = pkey->pkey.dh;\\r\\nstr = ASN1_STRING_new();\\r\\nstr->length = i2d_dhp(pkey, dh, &str->data);\\r\\nif (str->length <= 0) {\\r\\nDHerr(DH_F_DH_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\npval = str;\\r\\nptype = V_ASN1_SEQUENCE;\\r\\npub_key = BN_to_ASN1_INTEGER(dh->pub_key, NULL);\\r\\nif (!pub_key)\\r\\ngoto err;\\r\\npenclen = i2d_ASN1_INTEGER(pub_key, &penc);\\r\\nASN1_INTEGER_free(pub_key);\\r\\nif (penclen <= 0) {\\r\\nDHerr(DH_F_DH_PUB_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nif (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(pkey->ameth->pkey_id),\\r\\nptype, pval, penc, penclen))\\r\\nreturn 1;\\r\\nerr:\\r\\nif (penc)\\r\\nOPENSSL_free(penc);\\r\\nif (pval)\\r\\nASN1_STRING_free(pval);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dh_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)\\r\\n{\\r\\nconst unsigned char *p, *pm;\\r\\nint pklen, pmlen;\\r\\nint ptype;\\r\\nvoid *pval;\\r\\nASN1_STRING *pstr;\\r\\nX509_ALGOR *palg;\\r\\nASN1_INTEGER *privkey = NULL;\\r\\nDH *dh = NULL;\\r\\nif (!PKCS8_pkey_get0(NULL, &p, &pklen, &palg, p8))\\r\\nreturn 0;\\r\\nX509_ALGOR_get0(NULL, &ptype, &pval, palg);\\r\\nif (ptype != V_ASN1_SEQUENCE)\\r\\ngoto decerr;\\r\\nif (!(privkey = d2i_ASN1_INTEGER(NULL, &p, pklen)))\\r\\ngoto decerr;\\r\\npstr = pval;\\r\\npm = pstr->data;\\r\\npmlen = pstr->length;\\r\\nif (!(dh = d2i_dhp(pkey, &pm, pmlen)))\\r\\ngoto decerr;\\r\\nif (!(dh->priv_key = ASN1_INTEGER_to_BN(privkey, NULL))) {\\r\\nDHerr(DH_F_DH_PRIV_DECODE, DH_R_BN_ERROR);\\r\\ngoto dherr;\\r\\n}\\r\\nif (!DH_generate_key(dh))\\r\\ngoto dherr;\\r\\nEVP_PKEY_assign(pkey, pkey->ameth->pkey_id, dh);\\r\\nASN1_INTEGER_free(privkey);\\r\\nreturn 1;\\r\\ndecerr:\\r\\nDHerr(DH_F_DH_PRIV_DECODE, EVP_R_DECODE_ERROR);\\r\\ndherr:\\r\\nDH_free(dh);\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dh_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\\r\\n{\\r\\nASN1_STRING *params = NULL;\\r\\nASN1_INTEGER *prkey = NULL;\\r\\nunsigned char *dp = NULL;\\r\\nint dplen;\\r\\nparams = ASN1_STRING_new();\\r\\nif (!params) {\\r\\nDHerr(DH_F_DH_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nparams->length = i2d_dhp(pkey, pkey->pkey.dh, &params->data);\\r\\nif (params->length <= 0) {\\r\\nDHerr(DH_F_DH_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\nparams->type = V_ASN1_SEQUENCE;\\r\\nprkey = BN_to_ASN1_INTEGER(pkey->pkey.dh->priv_key, NULL);\\r\\nif (!prkey) {\\r\\nDHerr(DH_F_DH_PRIV_ENCODE, DH_R_BN_ERROR);\\r\\ngoto err;\\r\\n}\\r\\ndplen = i2d_ASN1_INTEGER(prkey, &dp);\\r\\nASN1_INTEGER_free(prkey);\\r\\nif (!PKCS8_pkey_set0(p8, OBJ_nid2obj(pkey->ameth->pkey_id), 0,\\r\\nV_ASN1_SEQUENCE, params, dp, dplen))\\r\\ngoto err;\\r\\nreturn 1;\\r\\nerr:\\r\\nif (dp != NULL)\\r\\nOPENSSL_free(dp);\\r\\nif (params != NULL)\\r\\nASN1_STRING_free(params);\\r\\nif (prkey != NULL)\\r\\nASN1_INTEGER_free(prkey);\\r\\nreturn 0;\\r\\n}\\r\\nstatic void update_buflen(const BIGNUM *b, size_t *pbuflen)\\r\\n{\\r\\nsize_t i;\\r\\nif (!b)\\r\\nreturn;\\r\\nif (*pbuflen < (i = (size_t)BN_num_bytes(b)))\\r\\n*pbuflen = i;\\r\\n}\\r\\nstatic int dh_param_decode(EVP_PKEY *pkey,\\r\\nconst unsigned char **pder, int derlen)\\r\\n{\\r\\nDH *dh;\\r\\nif (!(dh = d2i_dhp(pkey, pder, derlen))) {\\r\\nDHerr(DH_F_DH_PARAM_DECODE, ERR_R_DH_LIB);\\r\\nreturn 0;\\r\\n}\\r\\nEVP_PKEY_assign(pkey, pkey->ameth->pkey_id, dh);\\r\\nreturn 1;\\r\\n}\\r\\nstatic int dh_param_encode(const EVP_PKEY *pkey, unsigned char **pder)\\r\\n{\\r\\nreturn i2d_dhp(pkey, pkey->pkey.dh, pder);\\r\\n}\\r\\nstatic int do_dh_print(BIO *bp, const DH *x, int indent,\\r\\nASN1_PCTX *ctx, int ptype)\\r\\n{\\r\\nunsigned char *m = NULL;\\r\\nint reason = ERR_R_BUF_LIB, ret = 0;\\r\\nsize_t buf_len = 0;\\r\\nconst char *ktype = NULL;\\r\\nBIGNUM *priv_key, *pub_key;\\r\\nif (ptype == 2)\\r\\npriv_key = x->priv_key;\\r\\nelse\\r\\npriv_key = NULL;\\r\\nif (ptype > 0)\\r\\npub_key = x->pub_key;\\r\\nelse\\r\\npub_key = NULL;\\r\\nupdate_buflen(x->p, &buf_len);\\r\\nif (buf_len == 0) {\\r\\nreason = ERR_R_PASSED_NULL_PARAMETER;\\r\\ngoto err;\\r\\n}\\r\\nupdate_buflen(x->g, &buf_len);\\r\\nupdate_buflen(x->q, &buf_len);\\r\\nupdate_buflen(x->j, &buf_len);\\r\\nupdate_buflen(x->counter, &buf_len);\\r\\nupdate_buflen(pub_key, &buf_len);\\r\\nupdate_buflen(priv_key, &buf_len);\\r\\nif (ptype == 2)\\r\\nktype = \"DH Private-Key\";\\r\\nelse if (ptype == 1)\\r\\nktype = \"DH Public-Key\";\\r\\nelse\\r\\nktype = \"DH Parameters\";\\r\\nm = OPENSSL_malloc(buf_len + 10);\\r\\nif (m == NULL) {\\r\\nreason = ERR_R_MALLOC_FAILURE;\\r\\ngoto err;\\r\\n}\\r\\nBIO_indent(bp, indent, 128);\\r\\nif (BIO_printf(bp, \"%s: (%d bit)\\n\", ktype, BN_num_bits(x->p)) <= 0)\\r\\ngoto err;\\r\\nindent += 4;\\r\\nif (!ASN1_bn_print(bp, \"private-key:\", priv_key, m, indent))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"public-key:\", pub_key, m, indent))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"prime:\", x->p, m, indent))\\r\\ngoto err;\\r\\nif (!ASN1_bn_print(bp, \"generator:\", x->g, m, indent))\\r\\ngoto err;\\r\\nif (x->q && !ASN1_bn_print(bp, \"subgroup order:\", x->q, m, indent))\\r\\ngoto err;\\r\\nif (x->j && !ASN1_bn_print(bp, \"subgroup factor:\", x->j, m, indent))\\r\\ngoto err;\\r\\nif (x->seed) {\\r\\nint i;\\r\\nBIO_indent(bp, indent, 128);\\r\\nBIO_puts(bp, \"seed:\");\\r\\nfor (i = 0; i < x->seedlen; i++) {\\r\\nif ((i % 15) == 0) {\\r\\nif (BIO_puts(bp, \"\\n\") <= 0\\r\\n|| !BIO_indent(bp, indent + 4, 128))\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_printf(bp, \"%02x%s\", x->seed[i],\\r\\n((i + 1) == x->seedlen) ? \"\" : \":\") <= 0)\\r\\ngoto err;\\r\\n}\\r\\nif (BIO_write(bp, \"\\n\", 1) <= 0)\\r\\nreturn (0);\\r\\n}\\r\\nif (x->counter && !ASN1_bn_print(bp, \"counter:\", x->counter, m, indent))\\r\\ngoto err;\\r\\nif (x->length != 0) {\\r\\nBIO_indent(bp, indent, 128);\\r\\nif (BIO_printf(bp, \"recommended-private-length: %d bits\\n\",\\r\\n(int)x->length) <= 0)\\r\\ngoto err;\\r\\n}\\r\\nret = 1;\\r\\nif (0) {\\r\\nerr:\\r\\nDHerr(DH_F_DO_DH_PRINT, reason);\\r\\n}\\r\\nif (m != NULL)\\r\\nOPENSSL_free(m);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic int int_dh_size(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn (DH_size(pkey->pkey.dh));\\r\\n}\\r\\nstatic int dh_bits(const EVP_PKEY *pkey)\\r\\n{\\r\\nreturn BN_num_bits(pkey->pkey.dh->p);\\r\\n}\\r\\nstatic int dh_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nif (BN_cmp(a->pkey.dh->p, b->pkey.dh->p) ||\\r\\nBN_cmp(a->pkey.dh->g, b->pkey.dh->g))\\r\\nreturn 0;\\r\\nelse if (a->ameth == &dhx_asn1_meth) {\\r\\nif (BN_cmp(a->pkey.dh->q, b->pkey.dh->q))\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_dh_bn_cpy(BIGNUM **dst, const BIGNUM *src)\\r\\n{\\r\\nBIGNUM *a;\\r\\nif (src) {\\r\\na = BN_dup(src);\\r\\nif (!a)\\r\\nreturn 0;\\r\\n} else\\r\\na = NULL;\\r\\nif (*dst)\\r\\nBN_free(*dst);\\r\\n*dst = a;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int int_dh_param_copy(DH *to, const DH *from, int is_x942)\\r\\n{\\r\\nif (is_x942 == -1)\\r\\nis_x942 = ! !from->q;\\r\\nif (!int_dh_bn_cpy(&to->p, from->p))\\r\\nreturn 0;\\r\\nif (!int_dh_bn_cpy(&to->g, from->g))\\r\\nreturn 0;\\r\\nif (is_x942) {\\r\\nif (!int_dh_bn_cpy(&to->q, from->q))\\r\\nreturn 0;\\r\\nif (!int_dh_bn_cpy(&to->j, from->j))\\r\\nreturn 0;\\r\\nif (to->seed) {\\r\\nOPENSSL_free(to->seed);\\r\\nto->seed = NULL;\\r\\nto->seedlen = 0;\\r\\n}\\r\\nif (from->seed) {\\r\\nto->seed = BUF_memdup(from->seed, from->seedlen);\\r\\nif (!to->seed)\\r\\nreturn 0;\\r\\nto->seedlen = from->seedlen;\\r\\n}\\r\\n} else\\r\\nto->length = from->length;\\r\\nreturn 1;\\r\\n}\\r\\nDH *DHparams_dup(DH *dh)\\r\\n{\\r\\nDH *ret;\\r\\nret = DH_new();\\r\\nif (!ret)\\r\\nreturn NULL;\\r\\nif (!int_dh_param_copy(ret, dh, -1)) {\\r\\nDH_free(ret);\\r\\nreturn NULL;\\r\\n}\\r\\nreturn ret;\\r\\n}\\r\\nstatic int dh_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)\\r\\n{\\r\\nreturn int_dh_param_copy(to->pkey.dh, from->pkey.dh,\\r\\nfrom->ameth == &dhx_asn1_meth);\\r\\n}\\r\\nstatic int dh_missing_parameters(const EVP_PKEY *a)\\r\\n{\\r\\nif (!a->pkey.dh->p || !a->pkey.dh->g)\\r\\nreturn 1;\\r\\nreturn 0;\\r\\n}\\r\\nstatic int dh_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)\\r\\n{\\r\\nif (dh_cmp_parameters(a, b) == 0)\\r\\nreturn 0;\\r\\nif (BN_cmp(b->pkey.dh->pub_key, a->pkey.dh->pub_key) != 0)\\r\\nreturn 0;\\r\\nelse\\r\\nreturn 1;\\r\\n}\\r\\nstatic int dh_param_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_dh_print(bp, pkey->pkey.dh, indent, ctx, 0);\\r\\n}\\r\\nstatic int dh_public_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_dh_print(bp, pkey->pkey.dh, indent, ctx, 1);\\r\\n}\\r\\nstatic int dh_private_print(BIO *bp, const EVP_PKEY *pkey, int indent,\\r\\nASN1_PCTX *ctx)\\r\\n{\\r\\nreturn do_dh_print(bp, pkey->pkey.dh, indent, ctx, 2);\\r\\n}\\r\\nint DHparams_print(BIO *bp, const DH *x)\\r\\n{\\r\\nreturn do_dh_print(bp, x, 4, NULL, 0);\\r\\n}\\r\\nstatic int dh_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)\\r\\n{\\r\\nswitch (op) {\\r\\n#ifndef OPENSSL_NO_CMS\\r\\ncase ASN1_PKEY_CTRL_CMS_ENVELOPE:\\r\\nif (arg1 == 1)\\r\\nreturn dh_cms_decrypt(arg2);\\r\\nelse if (arg1 == 0)\\r\\nreturn dh_cms_encrypt(arg2);\\r\\nreturn -2;\\r\\ncase ASN1_PKEY_CTRL_CMS_RI_TYPE:\\r\\n*(int *)arg2 = CMS_RECIPINFO_AGREE;\\r\\nreturn 1;\\r\\n#endif\\r\\ndefault:\\r\\nreturn -2;\\r\\n}\\r\\n}\\r\\nstatic int dh_cms_set_peerkey(EVP_PKEY_CTX *pctx,\\r\\nX509_ALGOR *alg, ASN1_BIT_STRING *pubkey)\\r\\n{\\r\\nASN1_OBJECT *aoid;\\r\\nint atype;\\r\\nvoid *aval;\\r\\nASN1_INTEGER *public_key = NULL;\\r\\nint rv = 0;\\r\\nEVP_PKEY *pkpeer = NULL, *pk = NULL;\\r\\nDH *dhpeer = NULL;\\r\\nconst unsigned char *p;\\r\\nint plen;\\r\\nX509_ALGOR_get0(&aoid, &atype, &aval, alg);\\r\\nif (OBJ_obj2nid(aoid) != NID_dhpublicnumber)\\r\\ngoto err;\\r\\nif (atype != V_ASN1_UNDEF && atype == V_ASN1_NULL)\\r\\ngoto err;\\r\\npk = EVP_PKEY_CTX_get0_pkey(pctx);\\r\\nif (!pk)\\r\\ngoto err;\\r\\nif (pk->type != EVP_PKEY_DHX)\\r\\ngoto err;\\r\\ndhpeer = DHparams_dup(pk->pkey.dh);\\r\\nplen = ASN1_STRING_length(pubkey);\\r\\np = ASN1_STRING_data(pubkey);\\r\\nif (!p || !plen)\\r\\ngoto err;\\r\\nif (!(public_key = d2i_ASN1_INTEGER(NULL, &p, plen))) {\\r\\nDHerr(DH_F_DH_CMS_SET_PEERKEY, DH_R_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (!(dhpeer->pub_key = ASN1_INTEGER_to_BN(public_key, NULL))) {\\r\\nDHerr(DH_F_DH_CMS_SET_PEERKEY, DH_R_BN_DECODE_ERROR);\\r\\ngoto err;\\r\\n}\\r\\npkpeer = EVP_PKEY_new();\\r\\nif (!pkpeer)\\r\\ngoto err;\\r\\nEVP_PKEY_assign(pkpeer, pk->ameth->pkey_id, dhpeer);\\r\\ndhpeer = NULL;\\r\\nif (EVP_PKEY_derive_set_peer(pctx, pkpeer) > 0)\\r\\nrv = 1;\\r\\nerr:\\r\\nif (public_key)\\r\\nASN1_INTEGER_free(public_key);\\r\\nif (pkpeer)\\r\\nEVP_PKEY_free(pkpeer);\\r\\nif (dhpeer)\\r\\nDH_free(dhpeer);\\r\\nreturn rv;\\r\\n}\\r\\nstatic int dh_cms_set_shared_info(EVP_PKEY_CTX *pctx, CMS_RecipientInfo *ri)\\r\\n{\\r\\nint rv = 0;\\r\\nX509_ALGOR *alg, *kekalg = NULL;\\r\\nASN1_OCTET_STRING *ukm;\\r\\nconst unsigned char *p;\\r\\nunsigned char *dukm = NULL;\\r\\nsize_t dukmlen = 0;\\r\\nint keylen, plen;\\r\\nconst EVP_CIPHER *kekcipher;\\r\\nEVP_CIPHER_CTX *kekctx;\\r\\nif (!CMS_RecipientInfo_kari_get0_alg(ri, &alg, &ukm))\\r\\ngoto err;\\r\\nif (OBJ_obj2nid(alg->algorithm) != NID_id_smime_alg_ESDH) {\\r\\nDHerr(DH_F_DH_CMS_SET_SHARED_INFO, DH_R_KDF_PARAMETER_ERROR);\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_CTX_set_dh_kdf_type(pctx, EVP_PKEY_DH_KDF_X9_42) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set_dh_kdf_md(pctx, EVP_sha1()) <= 0)\\r\\ngoto err;\\r\\nif (alg->parameter->type != V_ASN1_SEQUENCE)\\r\\ngoto err;\\r\\np = alg->parameter->value.sequence->data;\\r\\nplen = alg->parameter->value.sequence->length;\\r\\nkekalg = d2i_X509_ALGOR(NULL, &p, plen);\\r\\nif (!kekalg)\\r\\ngoto err;\\r\\nkekctx = CMS_RecipientInfo_kari_get0_ctx(ri);\\r\\nif (!kekctx)\\r\\ngoto err;\\r\\nkekcipher = EVP_get_cipherbyobj(kekalg->algorithm);\\r\\nif (!kekcipher || EVP_CIPHER_mode(kekcipher) != EVP_CIPH_WRAP_MODE)\\r\\ngoto err;\\r\\nif (!EVP_EncryptInit_ex(kekctx, kekcipher, NULL, NULL, NULL))\\r\\ngoto err;\\r\\nif (EVP_CIPHER_asn1_to_param(kekctx, kekalg->parameter) <= 0)\\r\\ngoto err;\\r\\nkeylen = EVP_CIPHER_CTX_key_length(kekctx);\\r\\nif (EVP_PKEY_CTX_set_dh_kdf_outlen(pctx, keylen) <= 0)\\r\\ngoto err;\\r\\nif (EVP_PKEY_CTX_set0_dh_kdf_oid(pctx,\\r\\nOBJ_nid2obj(EVP_CIPHER_type(kekcipher)))\\r\\n<= 0)\\r\\ngoto err;\\r\\nif (ukm) {\\r\\ndukmlen = ASN1_STRING_length(ukm);\\r\\ndukm = BUF_memdup(ASN1_STRING_data(ukm), dukmlen);\\r\\nif (!dukm)\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_CTX_set0_dh_kdf_ukm(pctx, dukm, dukmlen) <= 0)\\r\\ngoto err;\\r\\ndukm = NULL;\\r\\nrv = 1;\\r\\nerr:\\r\\nif (kekalg)\\r\\nX509_ALGOR_free(kekalg);\\r\\nif (dukm)\\r\\nOPENSSL_free(dukm);\\r\\nreturn rv;\\r\\n}\\r\\nstatic int dh_cms_decrypt(CMS_RecipientInfo *ri)\\r\\n{\\r\\nEVP_PKEY_CTX *pctx;\\r\\npctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\\r\\nif (!pctx)\\r\\nreturn 0;\\r\\nif (!EVP_PKEY_CTX_get0_peerkey(pctx)) {\\r\\nX509_ALGOR *alg;\\r\\nASN1_BIT_STRING *pubkey;\\r\\nif (!CMS_RecipientInfo_kari_get0_orig_id(ri, &alg, &pubkey,\\r\\nNULL, NULL, NULL))\\r\\nreturn 0;\\r\\nif (!alg || !pubkey)\\r\\nreturn 0;\\r\\nif (!dh_cms_set_peerkey(pctx, alg, pubkey)) {\\r\\nDHerr(DH_F_DH_CMS_DECRYPT, DH_R_PEER_KEY_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\n}\\r\\nif (!dh_cms_set_shared_info(pctx, ri)) {\\r\\nDHerr(DH_F_DH_CMS_DECRYPT, DH_R_SHARED_INFO_ERROR);\\r\\nreturn 0;\\r\\n}\\r\\nreturn 1;\\r\\n}\\r\\nstatic int dh_cms_encrypt(CMS_RecipientInfo *ri)\\r\\n{\\r\\nEVP_PKEY_CTX *pctx;\\r\\nEVP_PKEY *pkey;\\r\\nEVP_CIPHER_CTX *ctx;\\r\\nint keylen;\\r\\nX509_ALGOR *talg, *wrap_alg = NULL;\\r\\nASN1_OBJECT *aoid;\\r\\nASN1_BIT_STRING *pubkey;\\r\\nASN1_STRING *wrap_str;\\r\\nASN1_OCTET_STRING *ukm;\\r\\nunsigned char *penc = NULL, *dukm = NULL;\\r\\nint penclen;\\r\\nsize_t dukmlen = 0;\\r\\nint rv = 0;\\r\\nint kdf_type, wrap_nid;\\r\\nconst EVP_MD *kdf_md;\\r\\npctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\\r\\nif (!pctx)\\r\\nreturn 0;\\r\\npkey = EVP_PKEY_CTX_get0_pkey(pctx);\\r\\nif (!CMS_RecipientInfo_kari_get0_orig_id(ri, &talg, &pubkey,\\r\\nNULL, NULL, NULL))\\r\\ngoto err;\\r\\nX509_ALGOR_get0(&aoid, NULL, NULL, talg);\\r\\nif (aoid == OBJ_nid2obj(NID_undef)) {\\r\\nASN1_INTEGER *pubk;\\r\\npubk = BN_to_ASN1_INTEGER(pkey->pkey.dh->pub_key, NULL);\\r\\nif (!pubk)\\r\\ngoto err;\\r\\npenclen = i2d_ASN1_INTEGER(pubk, &penc);\\r\\nASN1_INTEGER_free(pubk);\\r\\nif (penclen <= 0)\\r\\ngoto err;\\r\\nASN1_STRING_set0(pubkey, penc, penclen);\\r\\npubkey->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);\\r\\npubkey->flags |= ASN1_STRING_FLAG_BITS_LEFT;\\r\\npenc = NULL;\\r\\nX509_ALGOR_set0(talg, OBJ_nid2obj(NID_dhpublicnumber),\\r\\nV_ASN1_UNDEF, NULL);\\r\\n}\\r\\nkdf_type = EVP_PKEY_CTX_get_dh_kdf_type(pctx);\\r\\nif (kdf_type <= 0)\\r\\ngoto err;\\r\\nif (!EVP_PKEY_CTX_get_dh_kdf_md(pctx, &kdf_md))\\r\\ngoto err;\\r\\nif (kdf_type == EVP_PKEY_DH_KDF_NONE) {\\r\\nkdf_type = EVP_PKEY_DH_KDF_X9_42;\\r\\nif (EVP_PKEY_CTX_set_dh_kdf_type(pctx, kdf_type) <= 0)\\r\\ngoto err;\\r\\n} else if (kdf_type != EVP_PKEY_DH_KDF_X9_42)\\r\\ngoto err;\\r\\nif (kdf_md == NULL) {\\r\\nkdf_md = EVP_sha1();\\r\\nif (EVP_PKEY_CTX_set_dh_kdf_md(pctx, kdf_md) <= 0)\\r\\ngoto err;\\r\\n} else if (EVP_MD_type(kdf_md) != NID_sha1)\\r\\ngoto err;\\r\\nif (!CMS_RecipientInfo_kari_get0_alg(ri, &talg, &ukm))\\r\\ngoto err;\\r\\nctx = CMS_RecipientInfo_kari_get0_ctx(ri);\\r\\nwrap_nid = EVP_CIPHER_CTX_type(ctx);\\r\\nif (EVP_PKEY_CTX_set0_dh_kdf_oid(pctx, OBJ_nid2obj(wrap_nid)) <= 0)\\r\\ngoto err;\\r\\nkeylen = EVP_CIPHER_CTX_key_length(ctx);\\r\\nwrap_alg = X509_ALGOR_new();\\r\\nif (!wrap_alg)\\r\\ngoto err;\\r\\nwrap_alg->algorithm = OBJ_nid2obj(wrap_nid);\\r\\nwrap_alg->parameter = ASN1_TYPE_new();\\r\\nif (!wrap_alg->parameter)\\r\\ngoto err;\\r\\nif (EVP_CIPHER_param_to_asn1(ctx, wrap_alg->parameter) <= 0)\\r\\ngoto err;\\r\\nif (ASN1_TYPE_get(wrap_alg->parameter) == NID_undef) {\\r\\nASN1_TYPE_free(wrap_alg->parameter);\\r\\nwrap_alg->parameter = NULL;\\r\\n}\\r\\nif (EVP_PKEY_CTX_set_dh_kdf_outlen(pctx, keylen) <= 0)\\r\\ngoto err;\\r\\nif (ukm) {\\r\\ndukmlen = ASN1_STRING_length(ukm);\\r\\ndukm = BUF_memdup(ASN1_STRING_data(ukm), dukmlen);\\r\\nif (!dukm)\\r\\ngoto err;\\r\\n}\\r\\nif (EVP_PKEY_CTX_set0_dh_kdf_ukm(pctx, dukm, dukmlen) <= 0)\\r\\ngoto err;\\r\\ndukm = NULL;\\r\\npenc = NULL;\\r\\npenclen = i2d_X509_ALGOR(wrap_alg, &penc);\\r\\nif (!penc || !penclen)\\r\\ngoto err;\\r\\nwrap_str = ASN1_STRING_new();\\r\\nif (!wrap_str)\\r\\ngoto err;\\r\\nASN1_STRING_set0(wrap_str, penc, penclen);\\r\\npenc = NULL;\\r\\nX509_ALGOR_set0(talg, OBJ_nid2obj(NID_id_smime_alg_ESDH),\\r\\nV_ASN1_SEQUENCE, wrap_str);\\r\\nrv = 1;\\r\\nerr:\\r\\nif (penc)\\r\\nOPENSSL_free(penc);\\r\\nif (wrap_alg)\\r\\nX509_ALGOR_free(wrap_alg);\\r\\nreturn rv;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_strex_c", "target": 0, "func": "static int send_bio_chars(void *arg, const void *buf, int len)\\r\\n{\\r\\nif (!arg)\\r\\nreturn 1;\\r\\nif (BIO_write(arg, buf, len) != len)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int send_fp_chars(void *arg, const void *buf, int len)\\r\\n{\\r\\nif (!arg)\\r\\nreturn 1;\\r\\nif (fwrite(buf, 1, len, arg) != (unsigned int)len)\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int do_esc_char(unsigned long c, unsigned char flags, char *do_quotes,\\r\\nchar_io *io_ch, void *arg)\\r\\n{\\r\\nunsigned char chflgs, chtmp;\\r\\nchar tmphex[HEX_SIZE(long) + 3];\\r\\nif (c > 0xffffffffL)\\r\\nreturn -1;\\r\\nif (c > 0xffff) {\\r\\nBIO_snprintf(tmphex, sizeof tmphex, \"\\\\W%08lX\", c);\\r\\nif (!io_ch(arg, tmphex, 10))\\r\\nreturn -1;\\r\\nreturn 10;\\r\\n}\\r\\nif (c > 0xff) {\\r\\nBIO_snprintf(tmphex, sizeof tmphex, \"\\\\U%04lX\", c);\\r\\nif (!io_ch(arg, tmphex, 6))\\r\\nreturn -1;\\r\\nreturn 6;\\r\\n}\\r\\nchtmp = (unsigned char)c;\\r\\nif (chtmp > 0x7f)\\r\\nchflgs = flags & ASN1_STRFLGS_ESC_MSB;\\r\\nelse\\r\\nchflgs = char_type[chtmp] & flags;\\r\\nif (chflgs & CHARTYPE_BS_ESC) {\\r\\nif (chflgs & ASN1_STRFLGS_ESC_QUOTE) {\\r\\nif (do_quotes)\\r\\n*do_quotes = 1;\\r\\nif (!io_ch(arg, &chtmp, 1))\\r\\nreturn -1;\\r\\nreturn 1;\\r\\n}\\r\\nif (!io_ch(arg, \"\\\\\", 1))\\r\\nreturn -1;\\r\\nif (!io_ch(arg, &chtmp, 1))\\r\\nreturn -1;\\r\\nreturn 2;\\r\\n}\\r\\nif (chflgs & (ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB)) {\\r\\nBIO_snprintf(tmphex, 11, \"\\\\%02X\", chtmp);\\r\\nif (!io_ch(arg, tmphex, 3))\\r\\nreturn -1;\\r\\nreturn 3;\\r\\n}\\r\\nif (chtmp == '\\\\' && flags & ESC_FLAGS) {\\r\\nif (!io_ch(arg, \"\\\\\\\\\", 2))\\r\\nreturn -1;\\r\\nreturn 2;\\r\\n}\\r\\nif (!io_ch(arg, &chtmp, 1))\\r\\nreturn -1;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int do_buf(unsigned char *buf, int buflen,\\r\\nint type, unsigned char flags, char *quotes, char_io *io_ch,\\r\\nvoid *arg)\\r\\n{\\r\\nint i, outlen, len;\\r\\nunsigned char orflags, *p, *q;\\r\\nunsigned long c;\\r\\np = buf;\\r\\nq = buf + buflen;\\r\\noutlen = 0;\\r\\nwhile (p != q) {\\r\\nif (p == buf && flags & ASN1_STRFLGS_ESC_2253)\\r\\norflags = CHARTYPE_FIRST_ESC_2253;\\r\\nelse\\r\\norflags = 0;\\r\\nswitch (type & BUF_TYPE_WIDTH_MASK) {\\r\\ncase 4:\\r\\nc = ((unsigned long)*p++) << 24;\\r\\nc |= ((unsigned long)*p++) << 16;\\r\\nc |= ((unsigned long)*p++) << 8;\\r\\nc |= *p++;\\r\\nbreak;\\r\\ncase 2:\\r\\nc = ((unsigned long)*p++) << 8;\\r\\nc |= *p++;\\r\\nbreak;\\r\\ncase 1:\\r\\nc = *p++;\\r\\nbreak;\\r\\ncase 0:\\r\\ni = UTF8_getc(p, buflen, &c);\\r\\nif (i < 0)\\r\\nreturn -1;\\r\\np += i;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\nif (p == q && flags & ASN1_STRFLGS_ESC_2253)\\r\\norflags = CHARTYPE_LAST_ESC_2253;\\r\\nif (type & BUF_TYPE_CONVUTF8) {\\r\\nunsigned char utfbuf[6];\\r\\nint utflen;\\r\\nutflen = UTF8_putc(utfbuf, sizeof utfbuf, c);\\r\\nfor (i = 0; i < utflen; i++) {\\r\\nlen =\\r\\ndo_esc_char(utfbuf[i], (unsigned char)(flags | orflags),\\r\\nquotes, io_ch, arg);\\r\\nif (len < 0)\\r\\nreturn -1;\\r\\noutlen += len;\\r\\n}\\r\\n} else {\\r\\nlen =\\r\\ndo_esc_char(c, (unsigned char)(flags | orflags), quotes,\\r\\nio_ch, arg);\\r\\nif (len < 0)\\r\\nreturn -1;\\r\\noutlen += len;\\r\\n}\\r\\n}\\r\\nreturn outlen;\\r\\n}\\r\\nstatic int do_hex_dump(char_io *io_ch, void *arg, unsigned char *buf,\\r\\nint buflen)\\r\\n{\\r\\nstatic const char hexdig[] = \"0123456789ABCDEF\";\\r\\nunsigned char *p, *q;\\r\\nchar hextmp[2];\\r\\nif (arg) {\\r\\np = buf;\\r\\nq = buf + buflen;\\r\\nwhile (p != q) {\\r\\nhextmp[0] = hexdig[*p >> 4];\\r\\nhextmp[1] = hexdig[*p & 0xf];\\r\\nif (!io_ch(arg, hextmp, 2))\\r\\nreturn -1;\\r\\np++;\\r\\n}\\r\\n}\\r\\nreturn buflen << 1;\\r\\n}\\r\\nstatic int do_dump(unsigned long lflags, char_io *io_ch, void *arg,\\r\\nASN1_STRING *str)\\r\\n{\\r\\nASN1_TYPE t;\\r\\nunsigned char *der_buf, *p;\\r\\nint outlen, der_len;\\r\\nif (!io_ch(arg, \"#\", 1))\\r\\nreturn -1;\\r\\nif (!(lflags & ASN1_STRFLGS_DUMP_DER)) {\\r\\noutlen = do_hex_dump(io_ch, arg, str->data, str->length);\\r\\nif (outlen < 0)\\r\\nreturn -1;\\r\\nreturn outlen + 1;\\r\\n}\\r\\nt.type = str->type;\\r\\nt.value.ptr = (char *)str;\\r\\nder_len = i2d_ASN1_TYPE(&t, NULL);\\r\\nder_buf = OPENSSL_malloc(der_len);\\r\\nif (!der_buf)\\r\\nreturn -1;\\r\\np = der_buf;\\r\\ni2d_ASN1_TYPE(&t, &p);\\r\\noutlen = do_hex_dump(io_ch, arg, der_buf, der_len);\\r\\nOPENSSL_free(der_buf);\\r\\nif (outlen < 0)\\r\\nreturn -1;\\r\\nreturn outlen + 1;\\r\\n}\\r\\nstatic int do_print_ex(char_io *io_ch, void *arg, unsigned long lflags,\\r\\nASN1_STRING *str)\\r\\n{\\r\\nint outlen, len;\\r\\nint type;\\r\\nchar quotes;\\r\\nunsigned char flags;\\r\\nquotes = 0;\\r\\nflags = (unsigned char)(lflags & ESC_FLAGS);\\r\\ntype = str->type;\\r\\noutlen = 0;\\r\\nif (lflags & ASN1_STRFLGS_SHOW_TYPE) {\\r\\nconst char *tagname;\\r\\ntagname = ASN1_tag2str(type);\\r\\noutlen += strlen(tagname);\\r\\nif (!io_ch(arg, tagname, outlen) || !io_ch(arg, \":\", 1))\\r\\nreturn -1;\\r\\noutlen++;\\r\\n}\\r\\nif (lflags & ASN1_STRFLGS_DUMP_ALL)\\r\\ntype = -1;\\r\\nelse if (lflags & ASN1_STRFLGS_IGNORE_TYPE)\\r\\ntype = 1;\\r\\nelse {\\r\\nif ((type > 0) && (type < 31))\\r\\ntype = tag2nbyte[type];\\r\\nelse\\r\\ntype = -1;\\r\\nif ((type == -1) && !(lflags & ASN1_STRFLGS_DUMP_UNKNOWN))\\r\\ntype = 1;\\r\\n}\\r\\nif (type == -1) {\\r\\nlen = do_dump(lflags, io_ch, arg, str);\\r\\nif (len < 0)\\r\\nreturn -1;\\r\\noutlen += len;\\r\\nreturn outlen;\\r\\n}\\r\\nif (lflags & ASN1_STRFLGS_UTF8_CONVERT) {\\r\\nif (!type)\\r\\ntype = 1;\\r\\nelse\\r\\ntype |= BUF_TYPE_CONVUTF8;\\r\\n}\\r\\nlen = do_buf(str->data, str->length, type, flags, &quotes, io_ch, NULL);\\r\\nif (len < 0)\\r\\nreturn -1;\\r\\noutlen += len;\\r\\nif (quotes)\\r\\noutlen += 2;\\r\\nif (!arg)\\r\\nreturn outlen;\\r\\nif (quotes && !io_ch(arg, \"\\\"\", 1))\\r\\nreturn -1;\\r\\nif (do_buf(str->data, str->length, type, flags, NULL, io_ch, arg) < 0)\\r\\nreturn -1;\\r\\nif (quotes && !io_ch(arg, \"\\\"\", 1))\\r\\nreturn -1;\\r\\nreturn outlen;\\r\\n}\\r\\nstatic int do_indent(char_io *io_ch, void *arg, int indent)\\r\\n{\\r\\nint i;\\r\\nfor (i = 0; i < indent; i++)\\r\\nif (!io_ch(arg, \" \", 1))\\r\\nreturn 0;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int do_name_ex(char_io *io_ch, void *arg, X509_NAME *n,\\r\\nint indent, unsigned long flags)\\r\\n{\\r\\nint i, prev = -1, orflags, cnt;\\r\\nint fn_opt, fn_nid;\\r\\nASN1_OBJECT *fn;\\r\\nASN1_STRING *val;\\r\\nX509_NAME_ENTRY *ent;\\r\\nchar objtmp[80];\\r\\nconst char *objbuf;\\r\\nint outlen, len;\\r\\nchar *sep_dn, *sep_mv, *sep_eq;\\r\\nint sep_dn_len, sep_mv_len, sep_eq_len;\\r\\nif (indent < 0)\\r\\nindent = 0;\\r\\noutlen = indent;\\r\\nif (!do_indent(io_ch, arg, indent))\\r\\nreturn -1;\\r\\nswitch (flags & XN_FLAG_SEP_MASK) {\\r\\ncase XN_FLAG_SEP_MULTILINE:\\r\\nsep_dn = \"\\n\";\\r\\nsep_dn_len = 1;\\r\\nsep_mv = \" + \";\\r\\nsep_mv_len = 3;\\r\\nbreak;\\r\\ncase XN_FLAG_SEP_COMMA_PLUS:\\r\\nsep_dn = \",\";\\r\\nsep_dn_len = 1;\\r\\nsep_mv = \"+\";\\r\\nsep_mv_len = 1;\\r\\nindent = 0;\\r\\nbreak;\\r\\ncase XN_FLAG_SEP_CPLUS_SPC:\\r\\nsep_dn = \", \";\\r\\nsep_dn_len = 2;\\r\\nsep_mv = \" + \";\\r\\nsep_mv_len = 3;\\r\\nindent = 0;\\r\\nbreak;\\r\\ncase XN_FLAG_SEP_SPLUS_SPC:\\r\\nsep_dn = \"; \";\\r\\nsep_dn_len = 2;\\r\\nsep_mv = \" + \";\\r\\nsep_mv_len = 3;\\r\\nindent = 0;\\r\\nbreak;\\r\\ndefault:\\r\\nreturn -1;\\r\\n}\\r\\nif (flags & XN_FLAG_SPC_EQ) {\\r\\nsep_eq = \" = \";\\r\\nsep_eq_len = 3;\\r\\n} else {\\r\\nsep_eq = \"=\";\\r\\nsep_eq_len = 1;\\r\\n}\\r\\nfn_opt = flags & XN_FLAG_FN_MASK;\\r\\ncnt = X509_NAME_entry_count(n);\\r\\nfor (i = 0; i < cnt; i++) {\\r\\nif (flags & XN_FLAG_DN_REV)\\r\\nent = X509_NAME_get_entry(n, cnt - i - 1);\\r\\nelse\\r\\nent = X509_NAME_get_entry(n, i);\\r\\nif (prev != -1) {\\r\\nif (prev == ent->set) {\\r\\nif (!io_ch(arg, sep_mv, sep_mv_len))\\r\\nreturn -1;\\r\\noutlen += sep_mv_len;\\r\\n} else {\\r\\nif (!io_ch(arg, sep_dn, sep_dn_len))\\r\\nreturn -1;\\r\\noutlen += sep_dn_len;\\r\\nif (!do_indent(io_ch, arg, indent))\\r\\nreturn -1;\\r\\noutlen += indent;\\r\\n}\\r\\n}\\r\\nprev = ent->set;\\r\\nfn = X509_NAME_ENTRY_get_object(ent);\\r\\nval = X509_NAME_ENTRY_get_data(ent);\\r\\nfn_nid = OBJ_obj2nid(fn);\\r\\nif (fn_opt != XN_FLAG_FN_NONE) {\\r\\nint objlen, fld_len;\\r\\nif ((fn_opt == XN_FLAG_FN_OID) || (fn_nid == NID_undef)) {\\r\\nOBJ_obj2txt(objtmp, sizeof objtmp, fn, 1);\\r\\nfld_len = 0;\\r\\nobjbuf = objtmp;\\r\\n} else {\\r\\nif (fn_opt == XN_FLAG_FN_SN) {\\r\\nfld_len = FN_WIDTH_SN;\\r\\nobjbuf = OBJ_nid2sn(fn_nid);\\r\\n} else if (fn_opt == XN_FLAG_FN_LN) {\\r\\nfld_len = FN_WIDTH_LN;\\r\\nobjbuf = OBJ_nid2ln(fn_nid);\\r\\n} else {\\r\\nfld_len = 0;\\r\\nobjbuf = \"\";\\r\\n}\\r\\n}\\r\\nobjlen = strlen(objbuf);\\r\\nif (!io_ch(arg, objbuf, objlen))\\r\\nreturn -1;\\r\\nif ((objlen < fld_len) && (flags & XN_FLAG_FN_ALIGN)) {\\r\\nif (!do_indent(io_ch, arg, fld_len - objlen))\\r\\nreturn -1;\\r\\noutlen += fld_len - objlen;\\r\\n}\\r\\nif (!io_ch(arg, sep_eq, sep_eq_len))\\r\\nreturn -1;\\r\\noutlen += objlen + sep_eq_len;\\r\\n}\\r\\nif ((fn_nid == NID_undef) && (flags & XN_FLAG_DUMP_UNKNOWN_FIELDS))\\r\\norflags = ASN1_STRFLGS_DUMP_ALL;\\r\\nelse\\r\\norflags = 0;\\r\\nlen = do_print_ex(io_ch, arg, flags | orflags, val);\\r\\nif (len < 0)\\r\\nreturn -1;\\r\\noutlen += len;\\r\\n}\\r\\nreturn outlen;\\r\\n}\\r\\nint X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent,\\r\\nunsigned long flags)\\r\\n{\\r\\nif (flags == XN_FLAG_COMPAT)\\r\\nreturn X509_NAME_print(out, nm, indent);\\r\\nreturn do_name_ex(send_bio_chars, out, nm, indent, flags);\\r\\n}\\r\\nint X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent,\\r\\nunsigned long flags)\\r\\n{\\r\\nif (flags == XN_FLAG_COMPAT) {\\r\\nBIO *btmp;\\r\\nint ret;\\r\\nbtmp = BIO_new_fp(fp, BIO_NOCLOSE);\\r\\nif (!btmp)\\r\\nreturn -1;\\r\\nret = X509_NAME_print(btmp, nm, indent);\\r\\nBIO_free(btmp);\\r\\nreturn ret;\\r\\n}\\r\\nreturn do_name_ex(send_fp_chars, fp, nm, indent, flags);\\r\\n}\\r\\nint ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unsigned long flags)\\r\\n{\\r\\nreturn do_print_ex(send_bio_chars, out, flags, str);\\r\\n}\\r\\nint ASN1_STRING_print_ex_fp(FILE *fp, ASN1_STRING *str, unsigned long flags)\\r\\n{\\r\\nreturn do_print_ex(send_fp_chars, fp, flags, str);\\r\\n}\\r\\nint ASN1_STRING_to_UTF8(unsigned char **out, ASN1_STRING *in)\\r\\n{\\r\\nASN1_STRING stmp, *str = &stmp;\\r\\nint mbflag, type, ret;\\r\\nif (!in)\\r\\nreturn -1;\\r\\ntype = in->type;\\r\\nif ((type < 0) || (type > 30))\\r\\nreturn -1;\\r\\nmbflag = tag2nbyte[type];\\r\\nif (mbflag == -1)\\r\\nreturn -1;\\r\\nmbflag |= MBSTRING_FLAG;\\r\\nstmp.data = NULL;\\r\\nstmp.length = 0;\\r\\nstmp.flags = 0;\\r\\nret =\\r\\nASN1_mbstring_copy(&str, in->data, in->length, mbflag,\\r\\nB_ASN1_UTF8STRING);\\r\\nif (ret < 0)\\r\\nreturn ret;\\r\\n*out = stmp.data;\\r\\nreturn stmp.length;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_cms_ver_c", "target": 0, "func": "int main(int argc, char **argv)\\r\\n{\\r\\nBIO *in = NULL, *out = NULL, *tbio = NULL, *cont = NULL;\\r\\nX509_STORE *st = NULL;\\r\\nX509 *cacert = NULL;\\r\\nCMS_ContentInfo *cms = NULL;\\r\\nint ret = 1;\\r\\nOpenSSL_add_all_algorithms();\\r\\nERR_load_crypto_strings();\\r\\nst = X509_STORE_new();\\r\\ntbio = BIO_new_file(\"cacert.pem\", \"r\");\\r\\nif (!tbio)\\r\\ngoto err;\\r\\ncacert = PEM_read_bio_X509(tbio, NULL, 0, NULL);\\r\\nif (!cacert)\\r\\ngoto err;\\r\\nif (!X509_STORE_add_cert(st, cacert))\\r\\ngoto err;\\r\\nin = BIO_new_file(\"smout.txt\", \"r\");\\r\\nif (!in)\\r\\ngoto err;\\r\\ncms = SMIME_read_CMS(in, &cont);\\r\\nif (!cms)\\r\\ngoto err;\\r\\nout = BIO_new_file(\"smver.txt\", \"w\");\\r\\nif (!out)\\r\\ngoto err;\\r\\nif (!CMS_verify(cms, NULL, st, cont, out, 0)) {\\r\\nfprintf(stderr, \"Verification Failure\\n\");\\r\\ngoto err;\\r\\n}\\r\\nfprintf(stderr, \"Verification Successful\\n\");\\r\\nret = 0;\\r\\nerr:\\r\\nif (ret) {\\r\\nfprintf(stderr, \"Error Verifying Data\\n\");\\r\\nERR_print_errors_fp(stderr);\\r\\n}\\r\\nif (cms)\\r\\nCMS_ContentInfo_free(cms);\\r\\nif (cacert)\\r\\nX509_free(cacert);\\r\\nif (in)\\r\\nBIO_free(in);\\r\\nif (out)\\r\\nBIO_free(out);\\r\\nif (tbio)\\r\\nBIO_free(tbio);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsaz_exp_c", "target": 0, "func": "void RSAZ_1024_mod_exp_avx2(BN_ULONG result_norm[16],\\r\\nconst BN_ULONG base_norm[16],\\r\\nconst BN_ULONG exponent[16],\\r\\nconst BN_ULONG m_norm[16], const BN_ULONG RR[16],\\r\\nBN_ULONG k0)\\r\\n{\\r\\nunsigned char storage[320 * 3 + 32 * 9 * 16 + 64];\\r\\nunsigned char *p_str = storage + (64 - ((size_t)storage % 64));\\r\\nunsigned char *a_inv, *m, *result;\\r\\nunsigned char *table_s = p_str + 320 * 3;\\r\\nunsigned char *R2 = table_s;\\r\\nint index;\\r\\nint wvalue;\\r\\nif ((((size_t)p_str & 4095) + 320) >> 12) {\\r\\nresult = p_str;\\r\\na_inv = p_str + 320;\\r\\nm = p_str + 320 * 2;\\r\\n} else {\\r\\nm = p_str;\\r\\nresult = p_str + 320;\\r\\na_inv = p_str + 320 * 2;\\r\\n}\\r\\nrsaz_1024_norm2red_avx2(m, m_norm);\\r\\nrsaz_1024_norm2red_avx2(a_inv, base_norm);\\r\\nrsaz_1024_norm2red_avx2(R2, RR);\\r\\nrsaz_1024_mul_avx2(R2, R2, R2, m, k0);\\r\\nrsaz_1024_mul_avx2(R2, R2, two80, m, k0);\\r\\nrsaz_1024_mul_avx2(result, R2, one, m, k0);\\r\\nrsaz_1024_mul_avx2(a_inv, a_inv, R2, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 0);\\r\\nrsaz_1024_scatter5_avx2(table_s, a_inv, 1);\\r\\nrsaz_1024_sqr_avx2(result, a_inv, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 2);\\r\\n#if 0\\r\\nfor (index = 3; index < 32; index++) {\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, index);\\r\\n}\\r\\n#else\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 4);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 8);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 16);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 17);\\r\\nrsaz_1024_gather5_avx2(result, table_s, 2);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 3);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 6);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 12);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 24);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 25);\\r\\nrsaz_1024_gather5_avx2(result, table_s, 4);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 5);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 10);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 20);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 21);\\r\\nrsaz_1024_gather5_avx2(result, table_s, 6);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 7);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 14);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 28);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 29);\\r\\nrsaz_1024_gather5_avx2(result, table_s, 8);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 9);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 18);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 19);\\r\\nrsaz_1024_gather5_avx2(result, table_s, 10);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 11);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 22);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 23);\\r\\nrsaz_1024_gather5_avx2(result, table_s, 12);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 13);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 26);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 27);\\r\\nrsaz_1024_gather5_avx2(result, table_s, 14);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 15);\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 1);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 30);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_scatter5_avx2(table_s, result, 31);\\r\\n#endif\\r\\np_str = (unsigned char *)exponent;\\r\\nwvalue = p_str[127] >> 3;\\r\\nrsaz_1024_gather5_avx2(result, table_s, wvalue);\\r\\nindex = 1014;\\r\\nwhile (index > -1) {\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 5);\\r\\nwvalue = *((unsigned short *)&p_str[index / 8]);\\r\\nwvalue = (wvalue >> (index % 8)) & 31;\\r\\nindex -= 5;\\r\\nrsaz_1024_gather5_avx2(a_inv, table_s, wvalue);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\n}\\r\\nrsaz_1024_sqr_avx2(result, result, m, k0, 4);\\r\\nwvalue = p_str[0] & 15;\\r\\nrsaz_1024_gather5_avx2(a_inv, table_s, wvalue);\\r\\nrsaz_1024_mul_avx2(result, result, a_inv, m, k0);\\r\\nrsaz_1024_mul_avx2(result, result, one, m, k0);\\r\\nrsaz_1024_red2norm_avx2(result_norm, result);\\r\\nOPENSSL_cleanse(storage, sizeof(storage));\\r\\n}\\r\\nvoid RSAZ_512_mod_exp(BN_ULONG result[8],\\r\\nconst BN_ULONG base[8], const BN_ULONG exponent[8],\\r\\nconst BN_ULONG m[8], BN_ULONG k0, const BN_ULONG RR[8])\\r\\n{\\r\\nunsigned char storage[16 * 8 * 8 + 64 * 2 + 64];\\r\\nunsigned char *table = storage + (64 - ((size_t)storage % 64));\\r\\nBN_ULONG *a_inv = (BN_ULONG *)(table + 16 * 8 * 8);\\r\\nBN_ULONG *temp = (BN_ULONG *)(table + 16 * 8 * 8 + 8 * 8);\\r\\nunsigned char *p_str = (unsigned char *)exponent;\\r\\nint index;\\r\\nunsigned int wvalue;\\r\\ntemp[0] = 0 - m[0];\\r\\ntemp[1] = ~m[1];\\r\\ntemp[2] = ~m[2];\\r\\ntemp[3] = ~m[3];\\r\\ntemp[4] = ~m[4];\\r\\ntemp[5] = ~m[5];\\r\\ntemp[6] = ~m[6];\\r\\ntemp[7] = ~m[7];\\r\\nrsaz_512_scatter4(table, temp, 0);\\r\\nrsaz_512_mul(a_inv, base, RR, m, k0);\\r\\nrsaz_512_scatter4(table, a_inv, 1);\\r\\nrsaz_512_sqr(temp, a_inv, m, k0, 1);\\r\\nrsaz_512_scatter4(table, temp, 2);\\r\\nfor (index = 3; index < 16; index++)\\r\\nrsaz_512_mul_scatter4(temp, a_inv, m, k0, table, index);\\r\\nwvalue = p_str[63];\\r\\nrsaz_512_gather4(temp, table, wvalue >> 4);\\r\\nrsaz_512_sqr(temp, temp, m, k0, 4);\\r\\nrsaz_512_mul_gather4(temp, temp, table, m, k0, wvalue & 0xf);\\r\\nfor (index = 62; index >= 0; index--) {\\r\\nwvalue = p_str[index];\\r\\nrsaz_512_sqr(temp, temp, m, k0, 4);\\r\\nrsaz_512_mul_gather4(temp, temp, table, m, k0, wvalue >> 4);\\r\\nrsaz_512_sqr(temp, temp, m, k0, 4);\\r\\nrsaz_512_mul_gather4(temp, temp, table, m, k0, wvalue & 0x0f);\\r\\n}\\r\\nrsaz_512_mul_by_one(result, temp, m, k0);\\r\\nOPENSSL_cleanse(storage, sizeof(storage));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_m_md5_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn MD5_Init(ctx->md_data);\\r\\n}\\r\\nstatic int update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn MD5_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn MD5_Final(md, ctx->md_data);\\r\\n}\\r\\nconst EVP_MD *EVP_md5(void)\\r\\n{\\r\\nreturn (&md5_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ssl_ciph_c", "target": 0, "func": "static int get_optional_pkey_id(const char *pkey_name)\\r\\n{\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nint pkey_id = 0;\\r\\nameth = EVP_PKEY_asn1_find_str(NULL, pkey_name, -1);\\r\\nif (ameth) {\\r\\nEVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL, ameth);\\r\\n}\\r\\nreturn pkey_id;\\r\\n}\\r\\nstatic int get_optional_pkey_id(const char *pkey_name)\\r\\n{\\r\\nconst EVP_PKEY_ASN1_METHOD *ameth;\\r\\nENGINE *tmpeng = NULL;\\r\\nint pkey_id = 0;\\r\\nameth = EVP_PKEY_asn1_find_str(&tmpeng, pkey_name, -1);\\r\\nif (ameth) {\\r\\nEVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL, ameth);\\r\\n}\\r\\nif (tmpeng)\\r\\nENGINE_finish(tmpeng);\\r\\nreturn pkey_id;\\r\\n}\\r\\nvoid ssl_load_ciphers(void)\\r\\n{\\r\\nssl_cipher_methods[SSL_ENC_DES_IDX] = EVP_get_cipherbyname(SN_des_cbc);\\r\\nssl_cipher_methods[SSL_ENC_3DES_IDX] =\\r\\nEVP_get_cipherbyname(SN_des_ede3_cbc);\\r\\nssl_cipher_methods[SSL_ENC_RC4_IDX] = EVP_get_cipherbyname(SN_rc4);\\r\\nssl_cipher_methods[SSL_ENC_RC2_IDX] = EVP_get_cipherbyname(SN_rc2_cbc);\\r\\n#ifndef OPENSSL_NO_IDEA\\r\\nssl_cipher_methods[SSL_ENC_IDEA_IDX] = EVP_get_cipherbyname(SN_idea_cbc);\\r\\n#else\\r\\nssl_cipher_methods[SSL_ENC_IDEA_IDX] = NULL;\\r\\n#endif\\r\\nssl_cipher_methods[SSL_ENC_AES128_IDX] =\\r\\nEVP_get_cipherbyname(SN_aes_128_cbc);\\r\\nssl_cipher_methods[SSL_ENC_AES256_IDX] =\\r\\nEVP_get_cipherbyname(SN_aes_256_cbc);\\r\\nssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] =\\r\\nEVP_get_cipherbyname(SN_camellia_128_cbc);\\r\\nssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] =\\r\\nEVP_get_cipherbyname(SN_camellia_256_cbc);\\r\\nssl_cipher_methods[SSL_ENC_GOST89_IDX] =\\r\\nEVP_get_cipherbyname(SN_gost89_cnt);\\r\\nssl_cipher_methods[SSL_ENC_SEED_IDX] = EVP_get_cipherbyname(SN_seed_cbc);\\r\\nssl_cipher_methods[SSL_ENC_AES128GCM_IDX] =\\r\\nEVP_get_cipherbyname(SN_aes_128_gcm);\\r\\nssl_cipher_methods[SSL_ENC_AES256GCM_IDX] =\\r\\nEVP_get_cipherbyname(SN_aes_256_gcm);\\r\\nssl_digest_methods[SSL_MD_MD5_IDX] = EVP_get_digestbyname(SN_md5);\\r\\nssl_mac_secret_size[SSL_MD_MD5_IDX] =\\r\\nEVP_MD_size(ssl_digest_methods[SSL_MD_MD5_IDX]);\\r\\nOPENSSL_assert(ssl_mac_secret_size[SSL_MD_MD5_IDX] >= 0);\\r\\nssl_digest_methods[SSL_MD_SHA1_IDX] = EVP_get_digestbyname(SN_sha1);\\r\\nssl_mac_secret_size[SSL_MD_SHA1_IDX] =\\r\\nEVP_MD_size(ssl_digest_methods[SSL_MD_SHA1_IDX]);\\r\\nOPENSSL_assert(ssl_mac_secret_size[SSL_MD_SHA1_IDX] >= 0);\\r\\nssl_digest_methods[SSL_MD_GOST94_IDX] =\\r\\nEVP_get_digestbyname(SN_id_GostR3411_94);\\r\\nif (ssl_digest_methods[SSL_MD_GOST94_IDX]) {\\r\\nssl_mac_secret_size[SSL_MD_GOST94_IDX] =\\r\\nEVP_MD_size(ssl_digest_methods[SSL_MD_GOST94_IDX]);\\r\\nOPENSSL_assert(ssl_mac_secret_size[SSL_MD_GOST94_IDX] >= 0);\\r\\n}\\r\\nssl_digest_methods[SSL_MD_GOST89MAC_IDX] =\\r\\nEVP_get_digestbyname(SN_id_Gost28147_89_MAC);\\r\\nssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX] = get_optional_pkey_id(\"gost-mac\");\\r\\nif (ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]) {\\r\\nssl_mac_secret_size[SSL_MD_GOST89MAC_IDX] = 32;\\r\\n}\\r\\nssl_digest_methods[SSL_MD_SHA256_IDX] = EVP_get_digestbyname(SN_sha256);\\r\\nssl_mac_secret_size[SSL_MD_SHA256_IDX] =\\r\\nEVP_MD_size(ssl_digest_methods[SSL_MD_SHA256_IDX]);\\r\\nssl_digest_methods[SSL_MD_SHA384_IDX] = EVP_get_digestbyname(SN_sha384);\\r\\nssl_mac_secret_size[SSL_MD_SHA384_IDX] =\\r\\nEVP_MD_size(ssl_digest_methods[SSL_MD_SHA384_IDX]);\\r\\n}\\r\\nstatic int sk_comp_cmp(const SSL_COMP *const *a, const SSL_COMP *const *b)\\r\\n{\\r\\nreturn ((*a)->id - (*b)->id);\\r\\n}\\r\\nstatic void load_builtin_compressions(void)\\r\\n{\\r\\nint got_write_lock = 0;\\r\\nCRYPTO_r_lock(CRYPTO_LOCK_SSL);\\r\\nif (ssl_comp_methods == NULL) {\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL);\\r\\nCRYPTO_w_lock(CRYPTO_LOCK_SSL);\\r\\ngot_write_lock = 1;\\r\\nif (ssl_comp_methods == NULL) {\\r\\nSSL_COMP *comp = NULL;\\r\\nMemCheck_off();\\r\\nssl_comp_methods = sk_SSL_COMP_new(sk_comp_cmp);\\r\\nif (ssl_comp_methods != NULL) {\\r\\ncomp = (SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));\\r\\nif (comp != NULL) {\\r\\ncomp->method = COMP_zlib();\\r\\nif (comp->method && comp->method->type == NID_undef)\\r\\nOPENSSL_free(comp);\\r\\nelse {\\r\\ncomp->id = SSL_COMP_ZLIB_IDX;\\r\\ncomp->name = comp->method->name;\\r\\nsk_SSL_COMP_push(ssl_comp_methods, comp);\\r\\n}\\r\\n}\\r\\nsk_SSL_COMP_sort(ssl_comp_methods);\\r\\n}\\r\\nMemCheck_on();\\r\\n}\\r\\n}\\r\\nif (got_write_lock)\\r\\nCRYPTO_w_unlock(CRYPTO_LOCK_SSL);\\r\\nelse\\r\\nCRYPTO_r_unlock(CRYPTO_LOCK_SSL);\\r\\n}\\r\\nint ssl_cipher_get_evp(const SSL_SESSION *s, const EVP_CIPHER **enc,\\r\\nconst EVP_MD **md, int *mac_pkey_type,\\r\\nint *mac_secret_size, SSL_COMP **comp)\\r\\n{\\r\\nint i;\\r\\nconst SSL_CIPHER *c;\\r\\nc = s->cipher;\\r\\nif (c == NULL)\\r\\nreturn (0);\\r\\nif (comp != NULL) {\\r\\nSSL_COMP ctmp;\\r\\n#ifndef OPENSSL_NO_COMP\\r\\nload_builtin_compressions();\\r\\n#endif\\r\\n*comp = NULL;\\r\\nctmp.id = s->compress_meth;\\r\\nif (ssl_comp_methods != NULL) {\\r\\ni = sk_SSL_COMP_find(ssl_comp_methods, &ctmp);\\r\\nif (i >= 0)\\r\\n*comp = sk_SSL_COMP_value(ssl_comp_methods, i);\\r\\nelse\\r\\n*comp = NULL;\\r\\n}\\r\\n}\\r\\nif ((enc == NULL) || (md == NULL))\\r\\nreturn (0);\\r\\nswitch (c->algorithm_enc) {\\r\\ncase SSL_DES:\\r\\ni = SSL_ENC_DES_IDX;\\r\\nbreak;\\r\\ncase SSL_3DES:\\r\\ni = SSL_ENC_3DES_IDX;\\r\\nbreak;\\r\\ncase SSL_RC4:\\r\\ni = SSL_ENC_RC4_IDX;\\r\\nbreak;\\r\\ncase SSL_RC2:\\r\\ni = SSL_ENC_RC2_IDX;\\r\\nbreak;\\r\\ncase SSL_IDEA:\\r\\ni = SSL_ENC_IDEA_IDX;\\r\\nbreak;\\r\\ncase SSL_eNULL:\\r\\ni = SSL_ENC_NULL_IDX;\\r\\nbreak;\\r\\ncase SSL_AES128:\\r\\ni = SSL_ENC_AES128_IDX;\\r\\nbreak;\\r\\ncase SSL_AES256:\\r\\ni = SSL_ENC_AES256_IDX;\\r\\nbreak;\\r\\ncase SSL_CAMELLIA128:\\r\\ni = SSL_ENC_CAMELLIA128_IDX;\\r\\nbreak;\\r\\ncase SSL_CAMELLIA256:\\r\\ni = SSL_ENC_CAMELLIA256_IDX;\\r\\nbreak;\\r\\ncase SSL_eGOST2814789CNT:\\r\\ni = SSL_ENC_GOST89_IDX;\\r\\nbreak;\\r\\ncase SSL_SEED:\\r\\ni = SSL_ENC_SEED_IDX;\\r\\nbreak;\\r\\ncase SSL_AES128GCM:\\r\\ni = SSL_ENC_AES128GCM_IDX;\\r\\nbreak;\\r\\ncase SSL_AES256GCM:\\r\\ni = SSL_ENC_AES256GCM_IDX;\\r\\nbreak;\\r\\ndefault:\\r\\ni = -1;\\r\\nbreak;\\r\\n}\\r\\nif ((i < 0) || (i >= SSL_ENC_NUM_IDX))\\r\\n*enc = NULL;\\r\\nelse {\\r\\nif (i == SSL_ENC_NULL_IDX)\\r\\n*enc = EVP_enc_null();\\r\\nelse\\r\\n*enc = ssl_cipher_methods[i];\\r\\n}\\r\\nswitch (c->algorithm_mac) {\\r\\ncase SSL_MD5:\\r\\ni = SSL_MD_MD5_IDX;\\r\\nbreak;\\r\\ncase SSL_SHA1:\\r\\ni = SSL_MD_SHA1_IDX;\\r\\nbreak;\\r\\ncase SSL_SHA256:\\r\\ni = SSL_MD_SHA256_IDX;\\r\\nbreak;\\r\\ncase SSL_SHA384:\\r\\ni = SSL_MD_SHA384_IDX;\\r\\nbreak;\\r\\ncase SSL_GOST94:\\r\\ni = SSL_MD_GOST94_IDX;\\r\\nbreak;\\r\\ncase SSL_GOST89MAC:\\r\\ni = SSL_MD_GOST89MAC_IDX;\\r\\nbreak;\\r\\ndefault:\\r\\ni = -1;\\r\\nbreak;\\r\\n}\\r\\nif ((i < 0) || (i >= SSL_MD_NUM_IDX)) {\\r\\n*md = NULL;\\r\\nif (mac_pkey_type != NULL)\\r\\n*mac_pkey_type = NID_undef;\\r\\nif (mac_secret_size != NULL)\\r\\n*mac_secret_size = 0;\\r\\nif (c->algorithm_mac == SSL_AEAD)\\r\\nmac_pkey_type = NULL;\\r\\n} else {\\r\\n*md = ssl_digest_methods[i];\\r\\nif (mac_pkey_type != NULL)\\r\\n*mac_pkey_type = ssl_mac_pkey_id[i];\\r\\nif (mac_secret_size != NULL)\\r\\n*mac_secret_size = ssl_mac_secret_size[i];\\r\\n}\\r\\nif ((*enc != NULL) &&\\r\\n(*md != NULL || (EVP_CIPHER_flags(*enc) & EVP_CIPH_FLAG_AEAD_CIPHER))\\r\\n&& (!mac_pkey_type || *mac_pkey_type != NID_undef)) {\\r\\nconst EVP_CIPHER *evp;\\r\\nif (s->ssl_version >> 8 != TLS1_VERSION_MAJOR ||\\r\\ns->ssl_version < TLS1_VERSION)\\r\\nreturn 1;\\r\\n#ifdef OPENSSL_FIPS\\r\\nif (FIPS_mode())\\r\\nreturn 1;\\r\\n#endif\\r\\nif (c->algorithm_enc == SSL_RC4 &&\\r\\nc->algorithm_mac == SSL_MD5 &&\\r\\n(evp = EVP_get_cipherbyname(\"RC4-HMAC-MD5\")))\\r\\n*enc = evp, *md = NULL;\\r\\nelse if (c->algorithm_enc == SSL_AES128 &&\\r\\nc->algorithm_mac == SSL_SHA1 &&\\r\\n(evp = EVP_get_cipherbyname(\"AES-128-CBC-HMAC-SHA1\")))\\r\\n*enc = evp, *md = NULL;\\r\\nelse if (c->algorithm_enc == SSL_AES256 &&\\r\\nc->algorithm_mac == SSL_SHA1 &&\\r\\n(evp = EVP_get_cipherbyname(\"AES-256-CBC-HMAC-SHA1\")))\\r\\n*enc = evp, *md = NULL;\\r\\nelse if (c->algorithm_enc == SSL_AES128 &&\\r\\nc->algorithm_mac == SSL_SHA256 &&\\r\\n(evp = EVP_get_cipherbyname(\"AES-128-CBC-HMAC-SHA256\")))\\r\\n*enc = evp, *md = NULL;\\r\\nelse if (c->algorithm_enc == SSL_AES256 &&\\r\\nc->algorithm_mac == SSL_SHA256 &&\\r\\n(evp = EVP_get_cipherbyname(\"AES-256-CBC-HMAC-SHA256\")))\\r\\n*enc = evp, *md = NULL;\\r\\nreturn (1);\\r\\n} else\\r\\nreturn (0);\\r\\n}\\r\\nint ssl_get_handshake_digest(int idx, long *mask, const EVP_MD **md)\\r\\n{\\r\\nif (idx < 0 || idx >= SSL_MD_NUM_IDX) {\\r\\nreturn 0;\\r\\n}\\r\\n*mask = ssl_handshake_digest_flag[idx];\\r\\nif (*mask)\\r\\n*md = ssl_digest_methods[idx];\\r\\nelse\\r\\n*md = NULL;\\r\\nreturn 1;\\r\\n}\\r\\nstatic void ll_append_tail(CIPHER_ORDER **head, CIPHER_ORDER *curr,\\r\\nCIPHER_ORDER **tail)\\r\\n{\\r\\nif (curr == *tail)\\r\\nreturn;\\r\\nif (curr == *head)\\r\\n*head = curr->next;\\r\\nif (curr->prev != NULL)\\r\\ncurr->prev->next = curr->next;\\r\\nif (curr->next != NULL)\\r\\ncurr->next->prev = curr->prev;\\r\\n(*tail)->next = curr;\\r\\ncurr->prev = *tail;\\r\\ncurr->next = NULL;\\r\\n*tail = curr;\\r\\n}\\r\\nstatic void ll_append_head(CIPHER_ORDER **head, CIPHER_ORDER *curr,\\r\\nCIPHER_ORDER **tail)\\r\\n{\\r\\nif (curr == *head)\\r\\nreturn;\\r\\nif (curr == *tail)\\r\\n*tail = curr->prev;\\r\\nif (curr->next != NULL)\\r\\ncurr->next->prev = curr->prev;\\r\\nif (curr->prev != NULL)\\r\\ncurr->prev->next = curr->next;\\r\\n(*head)->prev = curr;\\r\\ncurr->next = *head;\\r\\ncurr->prev = NULL;\\r\\n*head = curr;\\r\\n}\\r\\nstatic void ssl_cipher_get_disabled(unsigned long *mkey, unsigned long *auth,\\r\\nunsigned long *enc, unsigned long *mac,\\r\\nunsigned long *ssl)\\r\\n{\\r\\n*mkey = 0;\\r\\n*auth = 0;\\r\\n*enc = 0;\\r\\n*mac = 0;\\r\\n*ssl = 0;\\r\\n#ifdef OPENSSL_NO_RSA\\r\\n*mkey |= SSL_kRSA;\\r\\n*auth |= SSL_aRSA;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_DSA\\r\\n*auth |= SSL_aDSS;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_DH\\r\\n*mkey |= SSL_kDHr | SSL_kDHd | SSL_kEDH;\\r\\n*auth |= SSL_aDH;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_KRB5\\r\\n*mkey |= SSL_kKRB5;\\r\\n*auth |= SSL_aKRB5;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_ECDSA\\r\\n*auth |= SSL_aECDSA;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_ECDH\\r\\n*mkey |= SSL_kECDHe | SSL_kECDHr;\\r\\n*auth |= SSL_aECDH;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_PSK\\r\\n*mkey |= SSL_kPSK;\\r\\n*auth |= SSL_aPSK;\\r\\n#endif\\r\\n#ifdef OPENSSL_NO_SRP\\r\\n*mkey |= SSL_kSRP;\\r\\n#endif\\r\\nif (!get_optional_pkey_id(\"gost94\")) {\\r\\n*auth |= SSL_aGOST94;\\r\\n}\\r\\nif (!get_optional_pkey_id(\"gost2001\")) {\\r\\n*auth |= SSL_aGOST01;\\r\\n}\\r\\nif ((*auth & (SSL_aGOST94 | SSL_aGOST01)) == (SSL_aGOST94 | SSL_aGOST01)) {\\r\\n*mkey |= SSL_kGOST;\\r\\n}\\r\\n#ifdef SSL_FORBID_ENULL\\r\\n*enc |= SSL_eNULL;\\r\\n#endif\\r\\n*enc |= (ssl_cipher_methods[SSL_ENC_DES_IDX] == NULL) ? SSL_DES : 0;\\r\\n*enc |= (ssl_cipher_methods[SSL_ENC_3DES_IDX] == NULL) ? SSL_3DES : 0;\\r\\n*enc |= (ssl_cipher_methods[SSL_ENC_RC4_IDX] == NULL) ? SSL_RC4 : 0;\\r\\n*enc |= (ssl_cipher_methods[SSL_ENC_RC2_IDX] == NULL) ? SSL_RC2 : 0;\\r\\n*enc |= (ssl_cipher_methods[SSL_ENC_IDEA_IDX] == NULL) ? SSL_IDEA : 0;\\r\\n*enc |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES128 : 0;\\r\\n*enc |= (ssl_cipher_methods[SSL_ENC_AES256_IDX] == NULL) ? SSL_AES256 : 0;\\r\\n*enc |=\\r\\n(ssl_cipher_methods[SSL_ENC_AES128GCM_IDX] ==\\r\\nNULL) ? SSL_AES128GCM : 0;\\r\\n*enc |=\\r\\n(ssl_cipher_methods[SSL_ENC_AES256GCM_IDX] ==\\r\\nNULL) ? SSL_AES256GCM : 0;\\r\\n*enc |=\\r\\n(ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] ==\\r\\nNULL) ? SSL_CAMELLIA128 : 0;\\r\\n*enc |=\\r\\n(ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] ==\\r\\nNULL) ? SSL_CAMELLIA256 : 0;\\r\\n*enc |=\\r\\n(ssl_cipher_methods[SSL_ENC_GOST89_IDX] ==\\r\\nNULL) ? SSL_eGOST2814789CNT : 0;\\r\\n*enc |= (ssl_cipher_methods[SSL_ENC_SEED_IDX] == NULL) ? SSL_SEED : 0;\\r\\n*mac |= (ssl_digest_methods[SSL_MD_MD5_IDX] == NULL) ? SSL_MD5 : 0;\\r\\n*mac |= (ssl_digest_methods[SSL_MD_SHA1_IDX] == NULL) ? SSL_SHA1 : 0;\\r\\n*mac |= (ssl_digest_methods[SSL_MD_SHA256_IDX] == NULL) ? SSL_SHA256 : 0;\\r\\n*mac |= (ssl_digest_methods[SSL_MD_SHA384_IDX] == NULL) ? SSL_SHA384 : 0;\\r\\n*mac |= (ssl_digest_methods[SSL_MD_GOST94_IDX] == NULL) ? SSL_GOST94 : 0;\\r\\n*mac |= (ssl_digest_methods[SSL_MD_GOST89MAC_IDX] == NULL\\r\\n|| ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX] ==\\r\\nNID_undef) ? SSL_GOST89MAC : 0;\\r\\n}\\r\\nstatic void ssl_cipher_collect_ciphers(const SSL_METHOD *ssl_method,\\r\\nint num_of_ciphers,\\r\\nunsigned long disabled_mkey,\\r\\nunsigned long disabled_auth,\\r\\nunsigned long disabled_enc,\\r\\nunsigned long disabled_mac,\\r\\nunsigned long disabled_ssl,\\r\\nCIPHER_ORDER *co_list,\\r\\nCIPHER_ORDER **head_p,\\r\\nCIPHER_ORDER **tail_p)\\r\\n{\\r\\nint i, co_list_num;\\r\\nconst SSL_CIPHER *c;\\r\\nco_list_num = 0;\\r\\nfor (i = 0; i < num_of_ciphers; i++) {\\r\\nc = ssl_method->get_cipher(i);\\r\\nif ((c != NULL) && c->valid &&\\r\\n#ifdef OPENSSL_FIPS\\r\\n(!FIPS_mode() || (c->algo_strength & SSL_FIPS)) &&\\r\\n#endif\\r\\n!(c->algorithm_mkey & disabled_mkey) &&\\r\\n!(c->algorithm_auth & disabled_auth) &&\\r\\n!(c->algorithm_enc & disabled_enc) &&\\r\\n!(c->algorithm_mac & disabled_mac) &&\\r\\n!(c->algorithm_ssl & disabled_ssl)) {\\r\\nco_list[co_list_num].cipher = c;\\r\\nco_list[co_list_num].next = NULL;\\r\\nco_list[co_list_num].prev = NULL;\\r\\nco_list[co_list_num].active = 0;\\r\\nco_list_num++;\\r\\n#ifdef KSSL_DEBUG\\r\\nfprintf(stderr, \"\\t%d: %s %lx %lx %lx\\n\", i, c->name, c->id,\\r\\nc->algorithm_mkey, c->algorithm_auth);\\r\\n#endif\\r\\n}\\r\\n}\\r\\nif (co_list_num > 0) {\\r\\nco_list[0].prev = NULL;\\r\\nif (co_list_num > 1) {\\r\\nco_list[0].next = &co_list[1];\\r\\nfor (i = 1; i < co_list_num - 1; i++) {\\r\\nco_list[i].prev = &co_list[i - 1];\\r\\nco_list[i].next = &co_list[i + 1];\\r\\n}\\r\\nco_list[co_list_num - 1].prev = &co_list[co_list_num - 2];\\r\\n}\\r\\nco_list[co_list_num - 1].next = NULL;\\r\\n*head_p = &co_list[0];\\r\\n*tail_p = &co_list[co_list_num - 1];\\r\\n}\\r\\n}\\r\\nstatic void ssl_cipher_collect_aliases(const SSL_CIPHER **ca_list,\\r\\nint num_of_group_aliases,\\r\\nunsigned long disabled_mkey,\\r\\nunsigned long disabled_auth,\\r\\nunsigned long disabled_enc,\\r\\nunsigned long disabled_mac,\\r\\nunsigned long disabled_ssl,\\r\\nCIPHER_ORDER *head)\\r\\n{\\r\\nCIPHER_ORDER *ciph_curr;\\r\\nconst SSL_CIPHER **ca_curr;\\r\\nint i;\\r\\nunsigned long mask_mkey = ~disabled_mkey;\\r\\nunsigned long mask_auth = ~disabled_auth;\\r\\nunsigned long mask_enc = ~disabled_enc;\\r\\nunsigned long mask_mac = ~disabled_mac;\\r\\nunsigned long mask_ssl = ~disabled_ssl;\\r\\nciph_curr = head;\\r\\nca_curr = ca_list;\\r\\nwhile (ciph_curr != NULL) {\\r\\n*ca_curr = ciph_curr->cipher;\\r\\nca_curr++;\\r\\nciph_curr = ciph_curr->next;\\r\\n}\\r\\nfor (i = 0; i < num_of_group_aliases; i++) {\\r\\nunsigned long algorithm_mkey = cipher_aliases[i].algorithm_mkey;\\r\\nunsigned long algorithm_auth = cipher_aliases[i].algorithm_auth;\\r\\nunsigned long algorithm_enc = cipher_aliases[i].algorithm_enc;\\r\\nunsigned long algorithm_mac = cipher_aliases[i].algorithm_mac;\\r\\nunsigned long algorithm_ssl = cipher_aliases[i].algorithm_ssl;\\r\\nif (algorithm_mkey)\\r\\nif ((algorithm_mkey & mask_mkey) == 0)\\r\\ncontinue;\\r\\nif (algorithm_auth)\\r\\nif ((algorithm_auth & mask_auth) == 0)\\r\\ncontinue;\\r\\nif (algorithm_enc)\\r\\nif ((algorithm_enc & mask_enc) == 0)\\r\\ncontinue;\\r\\nif (algorithm_mac)\\r\\nif ((algorithm_mac & mask_mac) == 0)\\r\\ncontinue;\\r\\nif (algorithm_ssl)\\r\\nif ((algorithm_ssl & mask_ssl) == 0)\\r\\ncontinue;\\r\\n*ca_curr = (SSL_CIPHER *)(cipher_aliases + i);\\r\\nca_curr++;\\r\\n}\\r\\n*ca_curr = NULL;\\r\\n}\\r\\nstatic void ssl_cipher_apply_rule(unsigned long cipher_id,\\r\\nunsigned long alg_mkey,\\r\\nunsigned long alg_auth,\\r\\nunsigned long alg_enc,\\r\\nunsigned long alg_mac,\\r\\nunsigned long alg_ssl,\\r\\nunsigned long algo_strength, int rule,\\r\\nint strength_bits, CIPHER_ORDER **head_p,\\r\\nCIPHER_ORDER **tail_p)\\r\\n{\\r\\nCIPHER_ORDER *head, *tail, *curr, *next, *last;\\r\\nconst SSL_CIPHER *cp;\\r\\nint reverse = 0;\\r\\n#ifdef CIPHER_DEBUG\\r\\nfprintf(stderr,\\r\\n\"Applying rule %d with %08lx/%08lx/%08lx/%08lx/%08lx %08lx (%d)\\n\",\\r\\nrule, alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl,\\r\\nalgo_strength, strength_bits);\\r\\n#endif\\r\\nif (rule == CIPHER_DEL)\\r\\nreverse = 1;\\r\\nhead = *head_p;\\r\\ntail = *tail_p;\\r\\nif (reverse) {\\r\\nnext = tail;\\r\\nlast = head;\\r\\n} else {\\r\\nnext = head;\\r\\nlast = tail;\\r\\n}\\r\\ncurr = NULL;\\r\\nfor (;;) {\\r\\nif (curr == last)\\r\\nbreak;\\r\\ncurr = next;\\r\\nif (curr == NULL)\\r\\nbreak;\\r\\nnext = reverse ? curr->prev : curr->next;\\r\\ncp = curr->cipher;\\r\\nif (strength_bits >= 0) {\\r\\nif (strength_bits != cp->strength_bits)\\r\\ncontinue;\\r\\n} else {\\r\\n#ifdef CIPHER_DEBUG\\r\\nfprintf(stderr,\\r\\n\"\\nName: %s:\\nAlgo = %08lx/%08lx/%08lx/%08lx/%08lx Algo_strength = %08lx\\n\",\\r\\ncp->name, cp->algorithm_mkey, cp->algorithm_auth,\\r\\ncp->algorithm_enc, cp->algorithm_mac, cp->algorithm_ssl,\\r\\ncp->algo_strength);\\r\\n#endif\\r\\n#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL\\r\\nif (cipher_id && cipher_id != cp->id)\\r\\ncontinue;\\r\\n#endif\\r\\nif (alg_mkey && !(alg_mkey & cp->algorithm_mkey))\\r\\ncontinue;\\r\\nif (alg_auth && !(alg_auth & cp->algorithm_auth))\\r\\ncontinue;\\r\\nif (alg_enc && !(alg_enc & cp->algorithm_enc))\\r\\ncontinue;\\r\\nif (alg_mac && !(alg_mac & cp->algorithm_mac))\\r\\ncontinue;\\r\\nif (alg_ssl && !(alg_ssl & cp->algorithm_ssl))\\r\\ncontinue;\\r\\nif ((algo_strength & SSL_EXP_MASK)\\r\\n&& !(algo_strength & SSL_EXP_MASK & cp->algo_strength))\\r\\ncontinue;\\r\\nif ((algo_strength & SSL_STRONG_MASK)\\r\\n&& !(algo_strength & SSL_STRONG_MASK & cp->algo_strength))\\r\\ncontinue;\\r\\n}\\r\\n#ifdef CIPHER_DEBUG\\r\\nfprintf(stderr, \"Action = %d\\n\", rule);\\r\\n#endif\\r\\nif (rule == CIPHER_ADD) {\\r\\nif (!curr->active) {\\r\\nll_append_tail(&head, curr, &tail);\\r\\ncurr->active = 1;\\r\\n}\\r\\n}\\r\\nelse if (rule == CIPHER_ORD) {\\r\\nif (curr->active) {\\r\\nll_append_tail(&head, curr, &tail);\\r\\n}\\r\\n} else if (rule == CIPHER_DEL) {\\r\\nif (curr->active) {\\r\\nll_append_head(&head, curr, &tail);\\r\\ncurr->active = 0;\\r\\n}\\r\\n} else if (rule == CIPHER_KILL) {\\r\\nif (head == curr)\\r\\nhead = curr->next;\\r\\nelse\\r\\ncurr->prev->next = curr->next;\\r\\nif (tail == curr)\\r\\ntail = curr->prev;\\r\\ncurr->active = 0;\\r\\nif (curr->next != NULL)\\r\\ncurr->next->prev = curr->prev;\\r\\nif (curr->prev != NULL)\\r\\ncurr->prev->next = curr->next;\\r\\ncurr->next = NULL;\\r\\ncurr->prev = NULL;\\r\\n}\\r\\n}\\r\\n*head_p = head;\\r\\n*tail_p = tail;\\r\\n}\\r\\nstatic int ssl_cipher_strength_sort(CIPHER_ORDER **head_p,\\r\\nCIPHER_ORDER **tail_p)\\r\\n{\\r\\nint max_strength_bits, i, *number_uses;\\r\\nCIPHER_ORDER *curr;\\r\\nmax_strength_bits = 0;\\r\\ncurr = *head_p;\\r\\nwhile (curr != NULL) {\\r\\nif (curr->active && (curr->cipher->strength_bits > max_strength_bits))\\r\\nmax_strength_bits = curr->cipher->strength_bits;\\r\\ncurr = curr->next;\\r\\n}\\r\\nnumber_uses = OPENSSL_malloc((max_strength_bits + 1) * sizeof(int));\\r\\nif (!number_uses) {\\r\\nSSLerr(SSL_F_SSL_CIPHER_STRENGTH_SORT, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\nmemset(number_uses, 0, (max_strength_bits + 1) * sizeof(int));\\r\\ncurr = *head_p;\\r\\nwhile (curr != NULL) {\\r\\nif (curr->active)\\r\\nnumber_uses[curr->cipher->strength_bits]++;\\r\\ncurr = curr->next;\\r\\n}\\r\\nfor (i = max_strength_bits; i >= 0; i--)\\r\\nif (number_uses[i] > 0)\\r\\nssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_ORD, i, head_p,\\r\\ntail_p);\\r\\nOPENSSL_free(number_uses);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int ssl_cipher_process_rulestr(const char *rule_str,\\r\\nCIPHER_ORDER **head_p,\\r\\nCIPHER_ORDER **tail_p,\\r\\nconst SSL_CIPHER **ca_list)\\r\\n{\\r\\nunsigned long alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl,\\r\\nalgo_strength;\\r\\nconst char *l, *buf;\\r\\nint j, multi, found, rule, retval, ok, buflen;\\r\\nunsigned long cipher_id = 0;\\r\\nchar ch;\\r\\nretval = 1;\\r\\nl = rule_str;\\r\\nfor (;;) {\\r\\nch = *l;\\r\\nif (ch == '\\0')\\r\\nbreak;\\r\\nif (ch == '-') {\\r\\nrule = CIPHER_DEL;\\r\\nl++;\\r\\n} else if (ch == '+') {\\r\\nrule = CIPHER_ORD;\\r\\nl++;\\r\\n} else if (ch == '!') {\\r\\nrule = CIPHER_KILL;\\r\\nl++;\\r\\n} else if (ch == '@') {\\r\\nrule = CIPHER_SPECIAL;\\r\\nl++;\\r\\n} else {\\r\\nrule = CIPHER_ADD;\\r\\n}\\r\\nif (ITEM_SEP(ch)) {\\r\\nl++;\\r\\ncontinue;\\r\\n}\\r\\nalg_mkey = 0;\\r\\nalg_auth = 0;\\r\\nalg_enc = 0;\\r\\nalg_mac = 0;\\r\\nalg_ssl = 0;\\r\\nalgo_strength = 0;\\r\\nfor (;;) {\\r\\nch = *l;\\r\\nbuf = l;\\r\\nbuflen = 0;\\r\\n#ifndef CHARSET_EBCDIC\\r\\nwhile (((ch >= 'A') && (ch <= 'Z')) ||\\r\\n((ch >= '0') && (ch <= '9')) ||\\r\\n((ch >= 'a') && (ch <= 'z')) || (ch == '-') || (ch == '.'))\\r\\n#else\\r\\nwhile (isalnum(ch) || (ch == '-') || (ch == '.'))\\r\\n#endif\\r\\n{\\r\\nch = *(++l);\\r\\nbuflen++;\\r\\n}\\r\\nif (buflen == 0) {\\r\\nSSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,\\r\\nSSL_R_INVALID_COMMAND);\\r\\nretval = found = 0;\\r\\nl++;\\r\\nbreak;\\r\\n}\\r\\nif (rule == CIPHER_SPECIAL) {\\r\\nfound = 0;\\r\\nbreak;\\r\\n}\\r\\nif (ch == '+') {\\r\\nmulti = 1;\\r\\nl++;\\r\\n} else\\r\\nmulti = 0;\\r\\nj = found = 0;\\r\\ncipher_id = 0;\\r\\nwhile (ca_list[j]) {\\r\\nif (!strncmp(buf, ca_list[j]->name, buflen) &&\\r\\n(ca_list[j]->name[buflen] == '\\0')) {\\r\\nfound = 1;\\r\\nbreak;\\r\\n} else\\r\\nj++;\\r\\n}\\r\\nif (!found)\\r\\nbreak;\\r\\nif (ca_list[j]->algorithm_mkey) {\\r\\nif (alg_mkey) {\\r\\nalg_mkey &= ca_list[j]->algorithm_mkey;\\r\\nif (!alg_mkey) {\\r\\nfound = 0;\\r\\nbreak;\\r\\n}\\r\\n} else\\r\\nalg_mkey = ca_list[j]->algorithm_mkey;\\r\\n}\\r\\nif (ca_list[j]->algorithm_auth) {\\r\\nif (alg_auth) {\\r\\nalg_auth &= ca_list[j]->algorithm_auth;\\r\\nif (!alg_auth) {\\r\\nfound = 0;\\r\\nbreak;\\r\\n}\\r\\n} else\\r\\nalg_auth = ca_list[j]->algorithm_auth;\\r\\n}\\r\\nif (ca_list[j]->algorithm_enc) {\\r\\nif (alg_enc) {\\r\\nalg_enc &= ca_list[j]->algorithm_enc;\\r\\nif (!alg_enc) {\\r\\nfound = 0;\\r\\nbreak;\\r\\n}\\r\\n} else\\r\\nalg_enc = ca_list[j]->algorithm_enc;\\r\\n}\\r\\nif (ca_list[j]->algorithm_mac) {\\r\\nif (alg_mac) {\\r\\nalg_mac &= ca_list[j]->algorithm_mac;\\r\\nif (!alg_mac) {\\r\\nfound = 0;\\r\\nbreak;\\r\\n}\\r\\n} else\\r\\nalg_mac = ca_list[j]->algorithm_mac;\\r\\n}\\r\\nif (ca_list[j]->algo_strength & SSL_EXP_MASK) {\\r\\nif (algo_strength & SSL_EXP_MASK) {\\r\\nalgo_strength &=\\r\\n(ca_list[j]->algo_strength & SSL_EXP_MASK) |\\r\\n~SSL_EXP_MASK;\\r\\nif (!(algo_strength & SSL_EXP_MASK)) {\\r\\nfound = 0;\\r\\nbreak;\\r\\n}\\r\\n} else\\r\\nalgo_strength |= ca_list[j]->algo_strength & SSL_EXP_MASK;\\r\\n}\\r\\nif (ca_list[j]->algo_strength & SSL_STRONG_MASK) {\\r\\nif (algo_strength & SSL_STRONG_MASK) {\\r\\nalgo_strength &=\\r\\n(ca_list[j]->algo_strength & SSL_STRONG_MASK) |\\r\\n~SSL_STRONG_MASK;\\r\\nif (!(algo_strength & SSL_STRONG_MASK)) {\\r\\nfound = 0;\\r\\nbreak;\\r\\n}\\r\\n} else\\r\\nalgo_strength |=\\r\\nca_list[j]->algo_strength & SSL_STRONG_MASK;\\r\\n}\\r\\nif (ca_list[j]->valid) {\\r\\ncipher_id = ca_list[j]->id;\\r\\n} else {\\r\\nif (ca_list[j]->algorithm_ssl) {\\r\\nif (alg_ssl) {\\r\\nalg_ssl &= ca_list[j]->algorithm_ssl;\\r\\nif (!alg_ssl) {\\r\\nfound = 0;\\r\\nbreak;\\r\\n}\\r\\n} else\\r\\nalg_ssl = ca_list[j]->algorithm_ssl;\\r\\n}\\r\\n}\\r\\nif (!multi)\\r\\nbreak;\\r\\n}\\r\\nif (rule == CIPHER_SPECIAL) {\\r\\nok = 0;\\r\\nif ((buflen == 8) && !strncmp(buf, \"STRENGTH\", 8))\\r\\nok = ssl_cipher_strength_sort(head_p, tail_p);\\r\\nelse\\r\\nSSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,\\r\\nSSL_R_INVALID_COMMAND);\\r\\nif (ok == 0)\\r\\nretval = 0;\\r\\nwhile ((*l != '\\0') && !ITEM_SEP(*l))\\r\\nl++;\\r\\n} else if (found) {\\r\\nssl_cipher_apply_rule(cipher_id,\\r\\nalg_mkey, alg_auth, alg_enc, alg_mac,\\r\\nalg_ssl, algo_strength, rule, -1, head_p,\\r\\ntail_p);\\r\\n} else {\\r\\nwhile ((*l != '\\0') && !ITEM_SEP(*l))\\r\\nl++;\\r\\n}\\r\\nif (*l == '\\0')\\r\\nbreak;\\r\\n}\\r\\nreturn (retval);\\r\\n}\\r\\nstatic int check_suiteb_cipher_list(const SSL_METHOD *meth, CERT *c,\\r\\nconst char **prule_str)\\r\\n{\\r\\nunsigned int suiteb_flags = 0, suiteb_comb2 = 0;\\r\\nif (!strcmp(*prule_str, \"SUITEB128\"))\\r\\nsuiteb_flags = SSL_CERT_FLAG_SUITEB_128_LOS;\\r\\nelse if (!strcmp(*prule_str, \"SUITEB128ONLY\"))\\r\\nsuiteb_flags = SSL_CERT_FLAG_SUITEB_128_LOS_ONLY;\\r\\nelse if (!strcmp(*prule_str, \"SUITEB128C2\")) {\\r\\nsuiteb_comb2 = 1;\\r\\nsuiteb_flags = SSL_CERT_FLAG_SUITEB_128_LOS;\\r\\n} else if (!strcmp(*prule_str, \"SUITEB192\"))\\r\\nsuiteb_flags = SSL_CERT_FLAG_SUITEB_192_LOS;\\r\\nif (suiteb_flags) {\\r\\nc->cert_flags &= ~SSL_CERT_FLAG_SUITEB_128_LOS;\\r\\nc->cert_flags |= suiteb_flags;\\r\\n} else\\r\\nsuiteb_flags = c->cert_flags & SSL_CERT_FLAG_SUITEB_128_LOS;\\r\\nif (!suiteb_flags)\\r\\nreturn 1;\\r\\nif (!(meth->ssl3_enc->enc_flags & SSL_ENC_FLAG_TLS1_2_CIPHERS)) {\\r\\nif (meth->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS)\\r\\nSSLerr(SSL_F_CHECK_SUITEB_CIPHER_LIST,\\r\\nSSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\\r\\nelse\\r\\nSSLerr(SSL_F_CHECK_SUITEB_CIPHER_LIST,\\r\\nSSL_R_ONLY_TLS_1_2_ALLOWED_IN_SUITEB_MODE);\\r\\nreturn 0;\\r\\n}\\r\\n# ifndef OPENSSL_NO_ECDH\\r\\nswitch (suiteb_flags) {\\r\\ncase SSL_CERT_FLAG_SUITEB_128_LOS:\\r\\nif (suiteb_comb2)\\r\\n*prule_str = \"ECDHE-ECDSA-AES256-GCM-SHA384\";\\r\\nelse\\r\\n*prule_str =\\r\\n\"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384\";\\r\\nbreak;\\r\\ncase SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:\\r\\n*prule_str = \"ECDHE-ECDSA-AES128-GCM-SHA256\";\\r\\nbreak;\\r\\ncase SSL_CERT_FLAG_SUITEB_192_LOS:\\r\\n*prule_str = \"ECDHE-ECDSA-AES256-GCM-SHA384\";\\r\\nbreak;\\r\\n}\\r\\nc->ecdh_tmp_auto = 1;\\r\\nreturn 1;\\r\\n# else\\r\\nSSLerr(SSL_F_CHECK_SUITEB_CIPHER_LIST,\\r\\nSSL_R_ECDH_REQUIRED_FOR_SUITEB_MODE);\\r\\nreturn 0;\\r\\n# endif\\r\\n}\\r\\nchar *SSL_CIPHER_get_name(const SSL_CIPHER *c)\\r\\n{\\r\\nif (c != NULL)\\r\\nreturn (c->name);\\r\\nreturn (\"(NONE)\");\\r\\n}\\r\\nint SSL_CIPHER_get_bits(const SSL_CIPHER *c, int *alg_bits)\\r\\n{\\r\\nint ret = 0;\\r\\nif (c != NULL) {\\r\\nif (alg_bits != NULL)\\r\\n*alg_bits = c->alg_bits;\\r\\nret = c->strength_bits;\\r\\n}\\r\\nreturn (ret);\\r\\n}\\r\\nunsigned long SSL_CIPHER_get_id(const SSL_CIPHER *c)\\r\\n{\\r\\nreturn c->id;\\r\\n}\\r\\nvoid *SSL_COMP_get_compression_methods(void)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nint SSL_COMP_add_compression_method(int id, void *cm)\\r\\n{\\r\\nreturn 1;\\r\\n}\\r\\nconst char *SSL_COMP_get_name(const void *comp)\\r\\n{\\r\\nreturn NULL;\\r\\n}\\r\\nstatic void cmeth_free(SSL_COMP *cm)\\r\\n{\\r\\nOPENSSL_free(cm);\\r\\n}\\r\\nvoid SSL_COMP_free_compression_methods(void)\\r\\n{\\r\\nSTACK_OF(SSL_COMP) *old_meths = ssl_comp_methods;\\r\\nssl_comp_methods = NULL;\\r\\nsk_SSL_COMP_pop_free(old_meths, cmeth_free);\\r\\n}\\r\\nint SSL_COMP_add_compression_method(int id, COMP_METHOD *cm)\\r\\n{\\r\\nSSL_COMP *comp;\\r\\nif (cm == NULL || cm->type == NID_undef)\\r\\nreturn 1;\\r\\nif (id < 193 || id > 255) {\\r\\nSSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,\\r\\nSSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE);\\r\\nreturn 0;\\r\\n}\\r\\nMemCheck_off();\\r\\ncomp = (SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));\\r\\ncomp->id = id;\\r\\ncomp->method = cm;\\r\\nload_builtin_compressions();\\r\\nif (ssl_comp_methods && sk_SSL_COMP_find(ssl_comp_methods, comp) >= 0) {\\r\\nOPENSSL_free(comp);\\r\\nMemCheck_on();\\r\\nSSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD,\\r\\nSSL_R_DUPLICATE_COMPRESSION_ID);\\r\\nreturn (1);\\r\\n} else if ((ssl_comp_methods == NULL)\\r\\n|| !sk_SSL_COMP_push(ssl_comp_methods, comp)) {\\r\\nOPENSSL_free(comp);\\r\\nMemCheck_on();\\r\\nSSLerr(SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD, ERR_R_MALLOC_FAILURE);\\r\\nreturn (1);\\r\\n} else {\\r\\nMemCheck_on();\\r\\nreturn (0);\\r\\n}\\r\\n}\\r\\nconst char *SSL_COMP_get_name(const COMP_METHOD *comp)\\r\\n{\\r\\nif (comp)\\r\\nreturn comp->name;\\r\\nreturn NULL;\\r\\n}\\r\\nint ssl_cipher_get_cert_index(const SSL_CIPHER *c)\\r\\n{\\r\\nunsigned long alg_k, alg_a;\\r\\nalg_k = c->algorithm_mkey;\\r\\nalg_a = c->algorithm_auth;\\r\\nif (alg_k & (SSL_kECDHr | SSL_kECDHe)) {\\r\\nreturn SSL_PKEY_ECC;\\r\\n} else if (alg_a & SSL_aECDSA)\\r\\nreturn SSL_PKEY_ECC;\\r\\nelse if (alg_k & SSL_kDHr)\\r\\nreturn SSL_PKEY_DH_RSA;\\r\\nelse if (alg_k & SSL_kDHd)\\r\\nreturn SSL_PKEY_DH_DSA;\\r\\nelse if (alg_a & SSL_aDSS)\\r\\nreturn SSL_PKEY_DSA_SIGN;\\r\\nelse if (alg_a & SSL_aRSA)\\r\\nreturn SSL_PKEY_RSA_ENC;\\r\\nelse if (alg_a & SSL_aKRB5)\\r\\nreturn -1;\\r\\nelse if (alg_a & SSL_aGOST94)\\r\\nreturn SSL_PKEY_GOST94;\\r\\nelse if (alg_a & SSL_aGOST01)\\r\\nreturn SSL_PKEY_GOST01;\\r\\nreturn -1;\\r\\n}\\r\\nconst SSL_CIPHER *ssl_get_cipher_by_char(SSL *ssl, const unsigned char *ptr)\\r\\n{\\r\\nconst SSL_CIPHER *c;\\r\\nc = ssl->method->get_cipher_by_char(ptr);\\r\\nif (c == NULL || c->valid == 0)\\r\\nreturn NULL;\\r\\nreturn c;\\r\\n}\\r\\nconst SSL_CIPHER *SSL_CIPHER_find(SSL *ssl, const unsigned char *ptr)\\r\\n{\\r\\nreturn ssl->method->get_cipher_by_char(ptr);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rand_egd_c", "target": 0, "func": "int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)\\r\\n{\\r\\nreturn (-1);\\r\\n}\\r\\nint RAND_egd(const char *path)\\r\\n{\\r\\nreturn (-1);\\r\\n}\\r\\nint RAND_egd_bytes(const char *path, int bytes)\\r\\n{\\r\\nreturn (-1);\\r\\n}\\r\\nint RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)\\r\\n{\\r\\nint ret = 0;\\r\\nstruct sockaddr_un addr;\\r\\nint len, num, numbytes;\\r\\nint fd = -1;\\r\\nint success;\\r\\nunsigned char egdbuf[2], tempbuf[255], *retrievebuf;\\r\\nmemset(&addr, 0, sizeof(addr));\\r\\naddr.sun_family = AF_UNIX;\\r\\nif (strlen(path) >= sizeof(addr.sun_path))\\r\\nreturn (-1);\\r\\nBUF_strlcpy(addr.sun_path, path, sizeof addr.sun_path);\\r\\nlen = offsetof(struct sockaddr_un, sun_path) + strlen(path);\\r\\nfd = socket(AF_UNIX, SOCK_STREAM, 0);\\r\\nif (fd == -1)\\r\\nreturn (-1);\\r\\nsuccess = 0;\\r\\nwhile (!success) {\\r\\nif (connect(fd, (struct sockaddr *)&addr, len) == 0)\\r\\nsuccess = 1;\\r\\nelse {\\r\\nswitch (errno) {\\r\\n# ifdef EINTR\\r\\ncase EINTR:\\r\\n# endif\\r\\n# ifdef EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\n# ifdef EINPROGRESS\\r\\ncase EINPROGRESS:\\r\\n# endif\\r\\n# ifdef EALREADY\\r\\ncase EALREADY:\\r\\n# endif\\r\\nbreak;\\r\\n# ifdef EISCONN\\r\\ncase EISCONN:\\r\\nsuccess = 1;\\r\\nbreak;\\r\\n# endif\\r\\ndefault:\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nwhile (bytes > 0) {\\r\\negdbuf[0] = 1;\\r\\negdbuf[1] = bytes < 255 ? bytes : 255;\\r\\nnumbytes = 0;\\r\\nwhile (numbytes != 2) {\\r\\nnum = write(fd, egdbuf + numbytes, 2 - numbytes);\\r\\nif (num >= 0)\\r\\nnumbytes += num;\\r\\nelse {\\r\\nswitch (errno) {\\r\\n# ifdef EINTR\\r\\ncase EINTR:\\r\\n# endif\\r\\n# ifdef EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nnumbytes = 0;\\r\\nwhile (numbytes != 1) {\\r\\nnum = read(fd, egdbuf, 1);\\r\\nif (num == 0)\\r\\ngoto err;\\r\\nelse if (num > 0)\\r\\nnumbytes += num;\\r\\nelse {\\r\\nswitch (errno) {\\r\\n# ifdef EINTR\\r\\ncase EINTR:\\r\\n# endif\\r\\n# ifdef EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nif (egdbuf[0] == 0)\\r\\ngoto err;\\r\\nif (buf)\\r\\nretrievebuf = buf + ret;\\r\\nelse\\r\\nretrievebuf = tempbuf;\\r\\nnumbytes = 0;\\r\\nwhile (numbytes != egdbuf[0]) {\\r\\nnum = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes);\\r\\nif (num == 0)\\r\\ngoto err;\\r\\nelse if (num > 0)\\r\\nnumbytes += num;\\r\\nelse {\\r\\nswitch (errno) {\\r\\n# ifdef EINTR\\r\\ncase EINTR:\\r\\n# endif\\r\\n# ifdef EAGAIN\\r\\ncase EAGAIN:\\r\\n# endif\\r\\nbreak;\\r\\ndefault:\\r\\nret = -1;\\r\\ngoto err;\\r\\n}\\r\\n}\\r\\n}\\r\\nret += egdbuf[0];\\r\\nbytes -= egdbuf[0];\\r\\nif (!buf)\\r\\nRAND_seed(tempbuf, egdbuf[0]);\\r\\n}\\r\\nerr:\\r\\nif (fd != -1)\\r\\nclose(fd);\\r\\nreturn (ret);\\r\\n}\\r\\nint RAND_egd_bytes(const char *path, int bytes)\\r\\n{\\r\\nint num, ret = 0;\\r\\nnum = RAND_query_egd_bytes(path, NULL, bytes);\\r\\nif (num < 1)\\r\\ngoto err;\\r\\nif (RAND_status() == 1)\\r\\nret = num;\\r\\nerr:\\r\\nreturn (ret);\\r\\n}\\r\\nint RAND_egd(const char *path)\\r\\n{\\r\\nreturn (RAND_egd_bytes(path, 255));\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_bss_log_c", "target": 0, "func": "BIO_METHOD *BIO_s_log(void)\\r\\n{\\r\\nreturn (&methods_slg);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_new(BIO *bi)\\r\\n{\\r\\nbi->init = 1;\\r\\nbi->num = 0;\\r\\nbi->ptr = NULL;\\r\\nxopenlog(bi, \"application\", LOG_DAEMON);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_free(BIO *a)\\r\\n{\\r\\nif (a == NULL)\\r\\nreturn (0);\\r\\nxcloselog(a);\\r\\nreturn (1);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_write(BIO *b, const char *in, int inl)\\r\\n{\\r\\nint ret = inl;\\r\\nchar *buf;\\r\\nchar *pp;\\r\\nint priority, i;\\r\\nstatic const struct {\\r\\nint strl;\\r\\nchar str[10];\\r\\nint log_level;\\r\\n} mapping[] = {\\r\\n{\\r\\n6, \"PANIC \", LOG_EMERG\\r\\n},\\r\\n{\\r\\n6, \"EMERG \", LOG_EMERG\\r\\n},\\r\\n{\\r\\n4, \"EMR \", LOG_EMERG\\r\\n},\\r\\n{\\r\\n6, \"ALERT \", LOG_ALERT\\r\\n},\\r\\n{\\r\\n4, \"ALR \", LOG_ALERT\\r\\n},\\r\\n{\\r\\n5, \"CRIT \", LOG_CRIT\\r\\n},\\r\\n{\\r\\n4, \"CRI \", LOG_CRIT\\r\\n},\\r\\n{\\r\\n6, \"ERROR \", LOG_ERR\\r\\n},\\r\\n{\\r\\n4, \"ERR \", LOG_ERR\\r\\n},\\r\\n{\\r\\n8, \"WARNING \", LOG_WARNING\\r\\n},\\r\\n{\\r\\n5, \"WARN \", LOG_WARNING\\r\\n},\\r\\n{\\r\\n4, \"WAR \", LOG_WARNING\\r\\n},\\r\\n{\\r\\n7, \"NOTICE \", LOG_NOTICE\\r\\n},\\r\\n{\\r\\n5, \"NOTE \", LOG_NOTICE\\r\\n},\\r\\n{\\r\\n4, \"NOT \", LOG_NOTICE\\r\\n},\\r\\n{\\r\\n5, \"INFO \", LOG_INFO\\r\\n},\\r\\n{\\r\\n4, \"INF \", LOG_INFO\\r\\n},\\r\\n{\\r\\n6, \"DEBUG \", LOG_DEBUG\\r\\n},\\r\\n{\\r\\n4, \"DBG \", LOG_DEBUG\\r\\n},\\r\\n{\\r\\n0, \"\", LOG_ERR\\r\\n}\\r\\n};\\r\\nif ((buf = (char *)OPENSSL_malloc(inl + 1)) == NULL) {\\r\\nreturn (0);\\r\\n}\\r\\nstrncpy(buf, in, inl);\\r\\nbuf[inl] = '\\0';\\r\\ni = 0;\\r\\nwhile (strncmp(buf, mapping[i].str, mapping[i].strl) != 0)\\r\\ni++;\\r\\npriority = mapping[i].log_level;\\r\\npp = buf + mapping[i].strl;\\r\\nxsyslog(b, priority, pp);\\r\\nOPENSSL_free(buf);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)\\r\\n{\\r\\nswitch (cmd) {\\r\\ncase BIO_CTRL_SET:\\r\\nxcloselog(b);\\r\\nxopenlog(b, ptr, num);\\r\\nbreak;\\r\\ndefault:\\r\\nbreak;\\r\\n}\\r\\nreturn (0);\\r\\n}\\r\\nstatic int MS_CALLBACK slg_puts(BIO *bp, const char *str)\\r\\n{\\r\\nint n, ret;\\r\\nn = strlen(str);\\r\\nret = slg_write(bp, str, n);\\r\\nreturn (ret);\\r\\n}\\r\\nstatic void xopenlog(BIO *bp, char *name, int level)\\r\\n{\\r\\nif (check_winnt())\\r\\nbp->ptr = RegisterEventSourceA(NULL, name);\\r\\nelse\\r\\nbp->ptr = NULL;\\r\\n}\\r\\nstatic void xsyslog(BIO *bp, int priority, const char *string)\\r\\n{\\r\\nLPCSTR lpszStrings[2];\\r\\nWORD evtype = EVENTLOG_ERROR_TYPE;\\r\\nchar pidbuf[DECIMAL_SIZE(DWORD) + 4];\\r\\nif (bp->ptr == NULL)\\r\\nreturn;\\r\\nswitch (priority) {\\r\\ncase LOG_EMERG:\\r\\ncase LOG_ALERT:\\r\\ncase LOG_CRIT:\\r\\ncase LOG_ERR:\\r\\nevtype = EVENTLOG_ERROR_TYPE;\\r\\nbreak;\\r\\ncase LOG_WARNING:\\r\\nevtype = EVENTLOG_WARNING_TYPE;\\r\\nbreak;\\r\\ncase LOG_NOTICE:\\r\\ncase LOG_INFO:\\r\\ncase LOG_DEBUG:\\r\\nevtype = EVENTLOG_INFORMATION_TYPE;\\r\\nbreak;\\r\\ndefault:\\r\\nevtype = EVENTLOG_ERROR_TYPE;\\r\\nbreak;\\r\\n}\\r\\nsprintf(pidbuf, \"[%u] \", GetCurrentProcessId());\\r\\nlpszStrings[0] = pidbuf;\\r\\nlpszStrings[1] = string;\\r\\nReportEventA(bp->ptr, evtype, 0, 1024, NULL, 2, 0, lpszStrings, NULL);\\r\\n}\\r\\nstatic void xcloselog(BIO *bp)\\r\\n{\\r\\nif (bp->ptr)\\r\\nDeregisterEventSource((HANDLE) (bp->ptr));\\r\\nbp->ptr = NULL;\\r\\n}\\r\\nstatic void xopenlog(BIO *bp, char *name, int level)\\r\\n{\\r\\nVMS_OPC_target = level;\\r\\n}\\r\\nstatic void xsyslog(BIO *bp, int priority, const char *string)\\r\\n{\\r\\nstruct dsc$descriptor_s opc_dsc;\\r\\n# if __INITIAL_POINTER_SIZE == 64\\r\\n# pragma pointer_size save\\r\\n# pragma pointer_size 32\\r\\n# define OPCDEF_TYPE __char_ptr32\\r\\n# define OPCDEF_MALLOC _malloc32\\r\\n# else\\r\\n# define OPCDEF_TYPE char *\\r\\n# define OPCDEF_MALLOC OPENSSL_malloc\\r\\n# endif\\r\\nstruct opcdef *opcdef_p;\\r\\n# if __INITIAL_POINTER_SIZE == 64\\r\\n# pragma pointer_size restore\\r\\n# endif\\r\\nchar buf[10240];\\r\\nunsigned int len;\\r\\nstruct dsc$descriptor_s buf_dsc;\\r\\n$DESCRIPTOR(fao_cmd, \"!AZ: !AZ\");\\r\\nchar *priority_tag;\\r\\nswitch (priority) {\\r\\ncase LOG_EMERG:\\r\\npriority_tag = \"Emergency\";\\r\\nbreak;\\r\\ncase LOG_ALERT:\\r\\npriority_tag = \"Alert\";\\r\\nbreak;\\r\\ncase LOG_CRIT:\\r\\npriority_tag = \"Critical\";\\r\\nbreak;\\r\\ncase LOG_ERR:\\r\\npriority_tag = \"Error\";\\r\\nbreak;\\r\\ncase LOG_WARNING:\\r\\npriority_tag = \"Warning\";\\r\\nbreak;\\r\\ncase LOG_NOTICE:\\r\\npriority_tag = \"Notice\";\\r\\nbreak;\\r\\ncase LOG_INFO:\\r\\npriority_tag = \"Info\";\\r\\nbreak;\\r\\ncase LOG_DEBUG:\\r\\npriority_tag = \"DEBUG\";\\r\\nbreak;\\r\\n}\\r\\nbuf_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nbuf_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nbuf_dsc.dsc$a_pointer = buf;\\r\\nbuf_dsc.dsc$w_length = sizeof(buf) - 1;\\r\\nlib$sys_fao(&fao_cmd, &len, &buf_dsc, priority_tag, string);\\r\\nopcdef_p = OPCDEF_MALLOC(8 + len);\\r\\nopcdef_p->opc$b_ms_type = OPC$_RQ_RQST;\\r\\nmemcpy(opcdef_p->opc$z_ms_target_classes, &VMS_OPC_target, 3);\\r\\nopcdef_p->opc$l_ms_rqstid = 0;\\r\\nmemcpy(&opcdef_p->opc$l_ms_text, buf, len);\\r\\nopc_dsc.dsc$b_dtype = DSC$K_DTYPE_T;\\r\\nopc_dsc.dsc$b_class = DSC$K_CLASS_S;\\r\\nopc_dsc.dsc$a_pointer = (OPCDEF_TYPE) opcdef_p;\\r\\nopc_dsc.dsc$w_length = len + 8;\\r\\nsys$sndopr(opc_dsc, 0);\\r\\nOPENSSL_free(opcdef_p);\\r\\n}\\r\\nstatic void xcloselog(BIO *bp)\\r\\n{\\r\\n}\\r\\nstatic void xopenlog(BIO *bp, char *name, int level)\\r\\n{\\r\\n# ifdef WATT32\\r\\nopenlog(name, LOG_PID | LOG_CONS | LOG_NDELAY, level);\\r\\n# else\\r\\nopenlog(name, LOG_PID | LOG_CONS, level);\\r\\n# endif\\r\\n}\\r\\nstatic void xsyslog(BIO *bp, int priority, const char *string)\\r\\n{\\r\\nsyslog(priority, \"%s\", string);\\r\\n}\\r\\nstatic void xcloselog(BIO *bp)\\r\\n{\\r\\ncloselog();\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ocsp_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nchar **args;\\r\\nchar *host = NULL, *port = NULL, *path = \"/\";\\r\\nchar *thost = NULL, *tport = NULL, *tpath = NULL;\\r\\nchar *reqin = NULL, *respin = NULL;\\r\\nchar *reqout = NULL, *respout = NULL;\\r\\nchar *signfile = NULL, *keyfile = NULL;\\r\\nchar *rsignfile = NULL, *rkeyfile = NULL;\\r\\nchar *outfile = NULL;\\r\\nint add_nonce = 1, noverify = 0, use_ssl = -1;\\r\\nSTACK_OF(CONF_VALUE) *headers = NULL;\\r\\nOCSP_REQUEST *req = NULL;\\r\\nOCSP_RESPONSE *resp = NULL;\\r\\nOCSP_BASICRESP *bs = NULL;\\r\\nX509 *issuer = NULL, *cert = NULL;\\r\\nX509 *signer = NULL, *rsigner = NULL;\\r\\nEVP_PKEY *key = NULL, *rkey = NULL;\\r\\nBIO *acbio = NULL, *cbio = NULL;\\r\\nBIO *derbio = NULL;\\r\\nBIO *out = NULL;\\r\\nint req_timeout = -1;\\r\\nint req_text = 0, resp_text = 0;\\r\\nlong nsec = MAX_VALIDITY_PERIOD, maxage = -1;\\r\\nchar *CAfile = NULL, *CApath = NULL;\\r\\nX509_STORE *store = NULL;\\r\\nX509_VERIFY_PARAM *vpm = NULL;\\r\\nSTACK_OF(X509) *sign_other = NULL, *verify_other = NULL, *rother = NULL;\\r\\nchar *sign_certfile = NULL, *verify_certfile = NULL, *rcertfile = NULL;\\r\\nunsigned long sign_flags = 0, verify_flags = 0, rflags = 0;\\r\\nint ret = 1;\\r\\nint accept_count = -1;\\r\\nint badarg = 0;\\r\\nint badsig = 0;\\r\\nint i;\\r\\nint ignore_err = 0;\\r\\nSTACK_OF(OPENSSL_STRING) *reqnames = NULL;\\r\\nSTACK_OF(OCSP_CERTID) *ids = NULL;\\r\\nX509 *rca_cert = NULL;\\r\\nchar *ridx_filename = NULL;\\r\\nchar *rca_filename = NULL;\\r\\nCA_DB *rdb = NULL;\\r\\nint nmin = 0, ndays = -1;\\r\\nconst EVP_MD *cert_id_md = NULL, *rsign_md = NULL;\\r\\nif (bio_err == NULL)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nSSL_load_error_strings();\\r\\nOpenSSL_add_ssl_algorithms();\\r\\nargs = argv + 1;\\r\\nreqnames = sk_OPENSSL_STRING_new_null();\\r\\nids = sk_OCSP_CERTID_new_null();\\r\\nwhile (!badarg && *args && *args[0] == '-') {\\r\\nif (!strcmp(*args, \"-out\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\noutfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-timeout\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nreq_timeout = atol(*args);\\r\\nif (req_timeout < 0) {\\r\\nBIO_printf(bio_err, \"Illegal timeout value %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-url\")) {\\r\\nif (thost)\\r\\nOPENSSL_free(thost);\\r\\nif (tport)\\r\\nOPENSSL_free(tport);\\r\\nif (tpath)\\r\\nOPENSSL_free(tpath);\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nif (!OCSP_parse_url(*args, &host, &port, &path, &use_ssl)) {\\r\\nBIO_printf(bio_err, \"Error parsing URL\\n\");\\r\\nbadarg = 1;\\r\\n}\\r\\nthost = host;\\r\\ntport = port;\\r\\ntpath = path;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-host\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nhost = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-port\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nport = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-header\")) {\\r\\nif (args[1] && args[2]) {\\r\\nif (!X509V3_add_value(args[1], args[2], &headers))\\r\\ngoto end;\\r\\nargs += 2;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-ignore_err\"))\\r\\nignore_err = 1;\\r\\nelse if (!strcmp(*args, \"-noverify\"))\\r\\nnoverify = 1;\\r\\nelse if (!strcmp(*args, \"-nonce\"))\\r\\nadd_nonce = 2;\\r\\nelse if (!strcmp(*args, \"-no_nonce\"))\\r\\nadd_nonce = 0;\\r\\nelse if (!strcmp(*args, \"-resp_no_certs\"))\\r\\nrflags |= OCSP_NOCERTS;\\r\\nelse if (!strcmp(*args, \"-resp_key_id\"))\\r\\nrflags |= OCSP_RESPID_KEY;\\r\\nelse if (!strcmp(*args, \"-no_certs\"))\\r\\nsign_flags |= OCSP_NOCERTS;\\r\\nelse if (!strcmp(*args, \"-no_signature_verify\"))\\r\\nverify_flags |= OCSP_NOSIGS;\\r\\nelse if (!strcmp(*args, \"-no_cert_verify\"))\\r\\nverify_flags |= OCSP_NOVERIFY;\\r\\nelse if (!strcmp(*args, \"-no_chain\"))\\r\\nverify_flags |= OCSP_NOCHAIN;\\r\\nelse if (!strcmp(*args, \"-no_cert_checks\"))\\r\\nverify_flags |= OCSP_NOCHECKS;\\r\\nelse if (!strcmp(*args, \"-no_explicit\"))\\r\\nverify_flags |= OCSP_NOEXPLICIT;\\r\\nelse if (!strcmp(*args, \"-trust_other\"))\\r\\nverify_flags |= OCSP_TRUSTOTHER;\\r\\nelse if (!strcmp(*args, \"-no_intern\"))\\r\\nverify_flags |= OCSP_NOINTERN;\\r\\nelse if (!strcmp(*args, \"-badsig\"))\\r\\nbadsig = 1;\\r\\nelse if (!strcmp(*args, \"-text\")) {\\r\\nreq_text = 1;\\r\\nresp_text = 1;\\r\\n} else if (!strcmp(*args, \"-req_text\"))\\r\\nreq_text = 1;\\r\\nelse if (!strcmp(*args, \"-resp_text\"))\\r\\nresp_text = 1;\\r\\nelse if (!strcmp(*args, \"-reqin\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nreqin = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-respin\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nrespin = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-signer\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nsignfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-VAfile\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nverify_certfile = *args;\\r\\nverify_flags |= OCSP_TRUSTOTHER;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-sign_other\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nsign_certfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-verify_other\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nverify_certfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-CAfile\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nCAfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-CApath\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nCApath = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (args_verify(&args, NULL, &badarg, bio_err, &vpm)) {\\r\\nif (badarg)\\r\\ngoto end;\\r\\ncontinue;\\r\\n} else if (!strcmp(*args, \"-validity_period\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nnsec = atol(*args);\\r\\nif (nsec < 0) {\\r\\nBIO_printf(bio_err,\\r\\n\"Illegal validity period %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-status_age\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nmaxage = atol(*args);\\r\\nif (maxage < 0) {\\r\\nBIO_printf(bio_err, \"Illegal validity age %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-signkey\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nkeyfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-reqout\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nreqout = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-respout\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nrespout = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-path\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\npath = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-issuer\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nX509_free(issuer);\\r\\nissuer = load_cert(bio_err, *args, FORMAT_PEM,\\r\\nNULL, e, \"issuer certificate\");\\r\\nif (!issuer)\\r\\ngoto end;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-cert\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nX509_free(cert);\\r\\ncert = load_cert(bio_err, *args, FORMAT_PEM,\\r\\nNULL, e, \"certificate\");\\r\\nif (!cert)\\r\\ngoto end;\\r\\nif (!cert_id_md)\\r\\ncert_id_md = EVP_sha1();\\r\\nif (!add_ocsp_cert(&req, cert, cert_id_md, issuer, ids))\\r\\ngoto end;\\r\\nif (!sk_OPENSSL_STRING_push(reqnames, *args))\\r\\ngoto end;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-serial\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nif (!cert_id_md)\\r\\ncert_id_md = EVP_sha1();\\r\\nif (!add_ocsp_serial(&req, *args, cert_id_md, issuer, ids))\\r\\ngoto end;\\r\\nif (!sk_OPENSSL_STRING_push(reqnames, *args))\\r\\ngoto end;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-index\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nridx_filename = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-CA\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nrca_filename = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-nmin\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nnmin = atol(*args);\\r\\nif (nmin < 0) {\\r\\nBIO_printf(bio_err, \"Illegal update period %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n}\\r\\nif (ndays == -1)\\r\\nndays = 0;\\r\\nelse\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-nrequest\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\naccept_count = atol(*args);\\r\\nif (accept_count < 0) {\\r\\nBIO_printf(bio_err, \"Illegal accept count %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-ndays\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nndays = atol(*args);\\r\\nif (ndays < 0) {\\r\\nBIO_printf(bio_err, \"Illegal update period %s\\n\", *args);\\r\\nbadarg = 1;\\r\\n}\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-rsigner\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nrsignfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-rkey\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nrkeyfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-rother\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nrcertfile = *args;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if (!strcmp(*args, \"-rmd\")) {\\r\\nif (args[1]) {\\r\\nargs++;\\r\\nrsign_md = EVP_get_digestbyname(*args);\\r\\nif (!rsign_md)\\r\\nbadarg = 1;\\r\\n} else\\r\\nbadarg = 1;\\r\\n} else if ((cert_id_md = EVP_get_digestbyname((*args) + 1)) == NULL) {\\r\\nbadarg = 1;\\r\\n}\\r\\nargs++;\\r\\n}\\r\\nif (!req && !reqin && !respin && !(port && ridx_filename))\\r\\nbadarg = 1;\\r\\nif (badarg) {\\r\\nBIO_printf(bio_err, \"OCSP utility\\n\");\\r\\nBIO_printf(bio_err, \"Usage ocsp [options]\\n\");\\r\\nBIO_printf(bio_err, \"where options are\\n\");\\r\\nBIO_printf(bio_err, \"-out file output filename\\n\");\\r\\nBIO_printf(bio_err, \"-issuer file issuer certificate\\n\");\\r\\nBIO_printf(bio_err, \"-cert file certificate to check\\n\");\\r\\nBIO_printf(bio_err, \"-serial n serial number to check\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-signer file certificate to sign OCSP request with\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-signkey file private key to sign OCSP request with\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-sign_other file additional certificates to include in signed request\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-no_certs don't include any certificates in signed request\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-req_text print text form of request\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-resp_text print text form of response\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-text print text form of request and response\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-reqout file write DER encoded OCSP request to \\\"file\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-respout file write DER encoded OCSP reponse to \\\"file\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-reqin file read DER encoded OCSP request from \\\"file\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-respin file read DER encoded OCSP reponse from \\\"file\\\"\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nonce add OCSP nonce to request\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-no_nonce don't add OCSP nonce to request\\n\");\\r\\nBIO_printf(bio_err, \"-url URL OCSP responder URL\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-host host:n send OCSP request to host on port n\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-path path to use in OCSP request\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-CApath dir trusted certificates directory\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-CAfile file trusted certificates file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-VAfile file validator certificates file\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-validity_period n maximum validity discrepancy in seconds\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-status_age n maximum status age in seconds\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-noverify don't verify response at all\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-verify_other file additional certificates to search for signer\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-trust_other don't verify additional certificates\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-no_intern don't search certificates contained in response for signer\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-no_signature_verify don't check signature on response\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-no_cert_verify don't check signing certificate\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-no_chain don't chain verify response\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-no_cert_checks don't do additional checks on signing certificate\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-port num port to run responder on\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-index file certificate status index file\\n\");\\r\\nBIO_printf(bio_err, \"-CA file CA certificate\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-rsigner file responder certificate to sign responses with\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-rkey file responder key to sign responses with\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-rother file other certificates to include in response\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-resp_no_certs don't include any certificates in response\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nmin n number of minutes before next update\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-ndays n number of days before next update\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-resp_key_id identify reponse by signing certificate key ID\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-nrequest n number of requests to accept (default unlimited)\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-<dgst alg> use specified digest in the request\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-timeout n timeout connection to OCSP responder after n seconds\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (outfile)\\r\\nout = BIO_new_file(outfile, \"w\");\\r\\nelse\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\nif (!out) {\\r\\nBIO_printf(bio_err, \"Error opening output file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (!req && (add_nonce != 2))\\r\\nadd_nonce = 0;\\r\\nif (!req && reqin) {\\r\\nif (!strcmp(reqin, \"-\"))\\r\\nderbio = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nelse\\r\\nderbio = BIO_new_file(reqin, \"rb\");\\r\\nif (!derbio) {\\r\\nBIO_printf(bio_err, \"Error Opening OCSP request file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nreq = d2i_OCSP_REQUEST_bio(derbio, NULL);\\r\\nBIO_free(derbio);\\r\\nif (!req) {\\r\\nBIO_printf(bio_err, \"Error reading OCSP request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (!req && port) {\\r\\nacbio = init_responder(port);\\r\\nif (!acbio)\\r\\ngoto end;\\r\\n}\\r\\nif (rsignfile && !rdb) {\\r\\nif (!rkeyfile)\\r\\nrkeyfile = rsignfile;\\r\\nrsigner = load_cert(bio_err, rsignfile, FORMAT_PEM,\\r\\nNULL, e, \"responder certificate\");\\r\\nif (!rsigner) {\\r\\nBIO_printf(bio_err, \"Error loading responder certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\nrca_cert = load_cert(bio_err, rca_filename, FORMAT_PEM,\\r\\nNULL, e, \"CA certificate\");\\r\\nif (rcertfile) {\\r\\nrother = load_certs(bio_err, rcertfile, FORMAT_PEM,\\r\\nNULL, e, \"responder other certificates\");\\r\\nif (!rother)\\r\\ngoto end;\\r\\n}\\r\\nrkey = load_key(bio_err, rkeyfile, FORMAT_PEM, 0, NULL, NULL,\\r\\n\"responder private key\");\\r\\nif (!rkey)\\r\\ngoto end;\\r\\n}\\r\\nif (acbio)\\r\\nBIO_printf(bio_err, \"Waiting for OCSP client connections...\\n\");\\r\\nredo_accept:\\r\\nif (acbio) {\\r\\nif (!do_responder(&req, &cbio, acbio, port))\\r\\ngoto end;\\r\\nif (!req) {\\r\\nresp =\\r\\nOCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST,\\r\\nNULL);\\r\\nsend_ocsp_response(cbio, resp);\\r\\ngoto done_resp;\\r\\n}\\r\\n}\\r\\nif (!req && (signfile || reqout || host || add_nonce || ridx_filename)) {\\r\\nBIO_printf(bio_err, \"Need an OCSP request for this operation!\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (req && add_nonce)\\r\\nOCSP_request_add1_nonce(req, NULL, -1);\\r\\nif (signfile) {\\r\\nif (!keyfile)\\r\\nkeyfile = signfile;\\r\\nsigner = load_cert(bio_err, signfile, FORMAT_PEM,\\r\\nNULL, e, \"signer certificate\");\\r\\nif (!signer) {\\r\\nBIO_printf(bio_err, \"Error loading signer certificate\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (sign_certfile) {\\r\\nsign_other = load_certs(bio_err, sign_certfile, FORMAT_PEM,\\r\\nNULL, e, \"signer certificates\");\\r\\nif (!sign_other)\\r\\ngoto end;\\r\\n}\\r\\nkey = load_key(bio_err, keyfile, FORMAT_PEM, 0, NULL, NULL,\\r\\n\"signer private key\");\\r\\nif (!key)\\r\\ngoto end;\\r\\nif (!OCSP_request_sign\\r\\n(req, signer, key, NULL, sign_other, sign_flags)) {\\r\\nBIO_printf(bio_err, \"Error signing OCSP request\\n\");\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\nif (req_text && req)\\r\\nOCSP_REQUEST_print(out, req, 0);\\r\\nif (reqout) {\\r\\nif (!strcmp(reqout, \"-\"))\\r\\nderbio = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\nelse\\r\\nderbio = BIO_new_file(reqout, \"wb\");\\r\\nif (!derbio) {\\r\\nBIO_printf(bio_err, \"Error opening file %s\\n\", reqout);\\r\\ngoto end;\\r\\n}\\r\\ni2d_OCSP_REQUEST_bio(derbio, req);\\r\\nBIO_free(derbio);\\r\\n}\\r\\nif (ridx_filename && (!rkey || !rsigner || !rca_cert)) {\\r\\nBIO_printf(bio_err,\\r\\n\"Need a responder certificate, key and CA for this operation!\\n\");\\r\\ngoto end;\\r\\n}\\r\\nif (ridx_filename && !rdb) {\\r\\nrdb = load_index(ridx_filename, NULL);\\r\\nif (!rdb)\\r\\ngoto end;\\r\\nif (!index_index(rdb))\\r\\ngoto end;\\r\\n}\\r\\nif (rdb) {\\r\\ni = make_ocsp_response(&resp, req, rdb, rca_cert, rsigner, rkey,\\r\\nrsign_md, rother, rflags, nmin, ndays, badsig);\\r\\nif (cbio)\\r\\nsend_ocsp_response(cbio, resp);\\r\\n} else if (host) {\\r\\n# ifndef OPENSSL_NO_SOCK\\r\\nresp = process_responder(bio_err, req, host, path,\\r\\nport, use_ssl, headers, req_timeout);\\r\\nif (!resp)\\r\\ngoto end;\\r\\n# else\\r\\nBIO_printf(bio_err,\\r\\n\"Error creating connect BIO - sockets not supported.\\n\");\\r\\ngoto end;\\r\\n# endif\\r\\n} else if (respin) {\\r\\nif (!strcmp(respin, \"-\"))\\r\\nderbio = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nelse\\r\\nderbio = BIO_new_file(respin, \"rb\");\\r\\nif (!derbio) {\\r\\nBIO_printf(bio_err, \"Error Opening OCSP response file\\n\");\\r\\ngoto end;\\r\\n}\\r\\nresp = d2i_OCSP_RESPONSE_bio(derbio, NULL);\\r\\nBIO_free(derbio);\\r\\nif (!resp) {\\r\\nBIO_printf(bio_err, \"Error reading OCSP response\\n\");\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\ndone_resp:\\r\\nif (respout) {\\r\\nif (!strcmp(respout, \"-\"))\\r\\nderbio = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\nelse\\r\\nderbio = BIO_new_file(respout, \"wb\");\\r\\nif (!derbio) {\\r\\nBIO_printf(bio_err, \"Error opening file %s\\n\", respout);\\r\\ngoto end;\\r\\n}\\r\\ni2d_OCSP_RESPONSE_bio(derbio, resp);\\r\\nBIO_free(derbio);\\r\\n}\\r\\ni = OCSP_response_status(resp);\\r\\nif (i != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\\r\\nBIO_printf(out, \"Responder Error: %s (%d)\\n\",\\r\\nOCSP_response_status_str(i), i);\\r\\nif (ignore_err)\\r\\ngoto redo_accept;\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (resp_text)\\r\\nOCSP_RESPONSE_print(out, resp, 0);\\r\\nif (cbio) {\\r\\nif (accept_count > 0)\\r\\naccept_count--;\\r\\nif (accept_count) {\\r\\nBIO_free_all(cbio);\\r\\ncbio = NULL;\\r\\nOCSP_REQUEST_free(req);\\r\\nreq = NULL;\\r\\nOCSP_RESPONSE_free(resp);\\r\\nresp = NULL;\\r\\ngoto redo_accept;\\r\\n}\\r\\nret = 0;\\r\\ngoto end;\\r\\n} else if (ridx_filename) {\\r\\nret = 0;\\r\\ngoto end;\\r\\n}\\r\\nif (!store)\\r\\nstore = setup_verify(bio_err, CAfile, CApath);\\r\\nif (!store)\\r\\ngoto end;\\r\\nif (vpm)\\r\\nX509_STORE_set1_param(store, vpm);\\r\\nif (verify_certfile) {\\r\\nverify_other = load_certs(bio_err, verify_certfile, FORMAT_PEM,\\r\\nNULL, e, \"validator certificate\");\\r\\nif (!verify_other)\\r\\ngoto end;\\r\\n}\\r\\nbs = OCSP_response_get1_basic(resp);\\r\\nif (!bs) {\\r\\nBIO_printf(bio_err, \"Error parsing response\\n\");\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nif (!noverify) {\\r\\nif (req && ((i = OCSP_check_nonce(req, bs)) <= 0)) {\\r\\nif (i == -1)\\r\\nBIO_printf(bio_err, \"WARNING: no nonce in response\\n\");\\r\\nelse {\\r\\nBIO_printf(bio_err, \"Nonce Verify error\\n\");\\r\\nret = 1;\\r\\ngoto end;\\r\\n}\\r\\n}\\r\\ni = OCSP_basic_verify(bs, verify_other, store, verify_flags);\\r\\nif (i <= 0) {\\r\\nBIO_printf(bio_err, \"Response Verify Failure\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nret = 1;\\r\\n} else\\r\\nBIO_printf(bio_err, \"Response verify OK\\n\");\\r\\n}\\r\\nif (!print_ocsp_summary(out, bs, req, reqnames, ids, nsec, maxage))\\r\\nret = 1;\\r\\nend:\\r\\nERR_print_errors(bio_err);\\r\\nX509_free(signer);\\r\\nX509_STORE_free(store);\\r\\nif (vpm)\\r\\nX509_VERIFY_PARAM_free(vpm);\\r\\nEVP_PKEY_free(key);\\r\\nEVP_PKEY_free(rkey);\\r\\nX509_free(issuer);\\r\\nX509_free(cert);\\r\\nX509_free(rsigner);\\r\\nX509_free(rca_cert);\\r\\nfree_index(rdb);\\r\\nBIO_free_all(cbio);\\r\\nBIO_free_all(acbio);\\r\\nBIO_free(out);\\r\\nOCSP_REQUEST_free(req);\\r\\nOCSP_RESPONSE_free(resp);\\r\\nOCSP_BASICRESP_free(bs);\\r\\nsk_OPENSSL_STRING_free(reqnames);\\r\\nsk_OCSP_CERTID_free(ids);\\r\\nsk_X509_pop_free(sign_other, X509_free);\\r\\nsk_X509_pop_free(verify_other, X509_free);\\r\\nsk_CONF_VALUE_pop_free(headers, X509V3_conf_free);\\r\\nif (thost)\\r\\nOPENSSL_free(thost);\\r\\nif (tport)\\r\\nOPENSSL_free(tport);\\r\\nif (tpath)\\r\\nOPENSSL_free(tpath);\\r\\nOPENSSL_EXIT(ret);\\r\\n}\\r\\nstatic char **lookup_serial(CA_DB *db, ASN1_INTEGER *ser)\\r\\n{\\r\\nint i;\\r\\nBIGNUM *bn = NULL;\\r\\nchar *itmp, *row[DB_NUMBER], **rrow;\\r\\nfor (i = 0; i < DB_NUMBER; i++)\\r\\nrow[i] = NULL;\\r\\nbn = ASN1_INTEGER_to_BN(ser, NULL);\\r\\nOPENSSL_assert(bn);\\r\\nif (BN_is_zero(bn))\\r\\nitmp = BUF_strdup(\"00\");\\r\\nelse\\r\\nitmp = BN_bn2hex(bn);\\r\\nrow[DB_serial] = itmp;\\r\\nBN_free(bn);\\r\\nrrow = TXT_DB_get_by_index(db->db, DB_serial, row);\\r\\nOPENSSL_free(itmp);\\r\\nreturn rrow;\\r\\n}\\r\\nstatic BIO *init_responder(const char *port)\\r\\n{\\r\\nBIO *acbio = NULL, *bufbio = NULL;\\r\\nbufbio = BIO_new(BIO_f_buffer());\\r\\nif (!bufbio)\\r\\ngoto err;\\r\\n# ifndef OPENSSL_NO_SOCK\\r\\nacbio = BIO_new_accept(port);\\r\\n# else\\r\\nBIO_printf(bio_err,\\r\\n\"Error setting up accept BIO - sockets not supported.\\n\");\\r\\n# endif\\r\\nif (!acbio)\\r\\ngoto err;\\r\\nBIO_set_accept_bios(acbio, bufbio);\\r\\nbufbio = NULL;\\r\\nif (BIO_do_accept(acbio) <= 0) {\\r\\nBIO_printf(bio_err, \"Error setting up accept BIO\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto err;\\r\\n}\\r\\nreturn acbio;\\r\\nerr:\\r\\nBIO_free_all(acbio);\\r\\nBIO_free(bufbio);\\r\\nreturn NULL;\\r\\n}\\r\\nstatic int do_responder(OCSP_REQUEST **preq, BIO **pcbio, BIO *acbio,\\r\\nconst char *port)\\r\\n{\\r\\nint have_post = 0, len;\\r\\nOCSP_REQUEST *req = NULL;\\r\\nchar inbuf[1024];\\r\\nBIO *cbio = NULL;\\r\\nif (BIO_do_accept(acbio) <= 0) {\\r\\nBIO_printf(bio_err, \"Error accepting connection\\n\");\\r\\nERR_print_errors(bio_err);\\r\\nreturn 0;\\r\\n}\\r\\ncbio = BIO_pop(acbio);\\r\\n*pcbio = cbio;\\r\\nfor (;;) {\\r\\nlen = BIO_gets(cbio, inbuf, sizeof inbuf);\\r\\nif (len <= 0)\\r\\nreturn 1;\\r\\nif (!have_post) {\\r\\nif (strncmp(inbuf, \"POST\", 4)) {\\r\\nBIO_printf(bio_err, \"Invalid request\\n\");\\r\\nreturn 1;\\r\\n}\\r\\nhave_post = 1;\\r\\n}\\r\\nif ((inbuf[0] == '\\r') || (inbuf[0] == '\\n'))\\r\\nbreak;\\r\\n}\\r\\nreq = d2i_OCSP_REQUEST_bio(cbio, NULL);\\r\\nif (!req) {\\r\\nBIO_printf(bio_err, \"Error parsing OCSP request\\n\");\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n*preq = req;\\r\\nreturn 1;\\r\\n}\\r\\nstatic int send_ocsp_response(BIO *cbio, OCSP_RESPONSE *resp)\\r\\n{\\r\\nchar http_resp[] =\\r\\n\"HTTP/1.0 200 OK\\r\\nContent-type: application/ocsp-response\\r\\n\"\\r\\n\"Content-Length: %d\\r\\n\\r\\n\";\\r\\nif (!cbio)\\r\\nreturn 0;\\r\\nBIO_printf(cbio, http_resp, i2d_OCSP_RESPONSE(resp, NULL));\\r\\ni2d_OCSP_RESPONSE_bio(cbio, resp);\\r\\n(void)BIO_flush(cbio);\\r\\nreturn 1;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_a_octet_c", "target": 0, "func": "ASN1_OCTET_STRING *ASN1_OCTET_STRING_dup(const ASN1_OCTET_STRING *x)\\r\\n{\\r\\nreturn M_ASN1_OCTET_STRING_dup(x);\\r\\n}\\r\\nint ASN1_OCTET_STRING_cmp(const ASN1_OCTET_STRING *a,\\r\\nconst ASN1_OCTET_STRING *b)\\r\\n{\\r\\nreturn M_ASN1_OCTET_STRING_cmp(a, b);\\r\\n}\\r\\nint ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *x, const unsigned char *d,\\r\\nint len)\\r\\n{\\r\\nreturn M_ASN1_OCTET_STRING_set(x, d, len);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_m_ripemd_c", "target": 0, "func": "static int init(EVP_MD_CTX *ctx)\\r\\n{\\r\\nreturn RIPEMD160_Init(ctx->md_data);\\r\\n}\\r\\nstatic int update(EVP_MD_CTX *ctx, const void *data, size_t count)\\r\\n{\\r\\nreturn RIPEMD160_Update(ctx->md_data, data, count);\\r\\n}\\r\\nstatic int final(EVP_MD_CTX *ctx, unsigned char *md)\\r\\n{\\r\\nreturn RIPEMD160_Final(md, ctx->md_data);\\r\\n}\\r\\nconst EVP_MD *EVP_ripemd160(void)\\r\\n{\\r\\nreturn (&ripemd160_md);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_err_c", "target": 0, "func": "void ERR_load_EC_strings(void)\\r\\n{\\r\\n#ifndef OPENSSL_NO_ERR\\r\\nif (ERR_func_error_string(EC_str_functs[0].error) == NULL) {\\r\\nERR_load_strings(0, EC_str_functs);\\r\\nERR_load_strings(0, EC_str_reasons);\\r\\n}\\r\\n#endif\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsa_saos_c", "target": 0, "func": "int RSA_sign_ASN1_OCTET_STRING(int type,\\r\\nconst unsigned char *m, unsigned int m_len,\\r\\nunsigned char *sigret, unsigned int *siglen,\\r\\nRSA *rsa)\\r\\n{\\r\\nASN1_OCTET_STRING sig;\\r\\nint i, j, ret = 1;\\r\\nunsigned char *p, *s;\\r\\nsig.type = V_ASN1_OCTET_STRING;\\r\\nsig.length = m_len;\\r\\nsig.data = (unsigned char *)m;\\r\\ni = i2d_ASN1_OCTET_STRING(&sig, NULL);\\r\\nj = RSA_size(rsa);\\r\\nif (i > (j - RSA_PKCS1_PADDING_SIZE)) {\\r\\nRSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING,\\r\\nRSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);\\r\\nreturn (0);\\r\\n}\\r\\ns = (unsigned char *)OPENSSL_malloc((unsigned int)j + 1);\\r\\nif (s == NULL) {\\r\\nRSAerr(RSA_F_RSA_SIGN_ASN1_OCTET_STRING, ERR_R_MALLOC_FAILURE);\\r\\nreturn (0);\\r\\n}\\r\\np = s;\\r\\ni2d_ASN1_OCTET_STRING(&sig, &p);\\r\\ni = RSA_private_encrypt(i, s, sigret, rsa, RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\nret = 0;\\r\\nelse\\r\\n*siglen = i;\\r\\nOPENSSL_cleanse(s, (unsigned int)j + 1);\\r\\nOPENSSL_free(s);\\r\\nreturn (ret);\\r\\n}\\r\\nint RSA_verify_ASN1_OCTET_STRING(int dtype,\\r\\nconst unsigned char *m,\\r\\nunsigned int m_len, unsigned char *sigbuf,\\r\\nunsigned int siglen, RSA *rsa)\\r\\n{\\r\\nint i, ret = 0;\\r\\nunsigned char *s;\\r\\nconst unsigned char *p;\\r\\nASN1_OCTET_STRING *sig = NULL;\\r\\nif (siglen != (unsigned int)RSA_size(rsa)) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING,\\r\\nRSA_R_WRONG_SIGNATURE_LENGTH);\\r\\nreturn (0);\\r\\n}\\r\\ns = (unsigned char *)OPENSSL_malloc((unsigned int)siglen);\\r\\nif (s == NULL) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING, ERR_R_MALLOC_FAILURE);\\r\\ngoto err;\\r\\n}\\r\\ni = RSA_public_decrypt((int)siglen, sigbuf, s, rsa, RSA_PKCS1_PADDING);\\r\\nif (i <= 0)\\r\\ngoto err;\\r\\np = s;\\r\\nsig = d2i_ASN1_OCTET_STRING(NULL, &p, (long)i);\\r\\nif (sig == NULL)\\r\\ngoto err;\\r\\nif (((unsigned int)sig->length != m_len) ||\\r\\n(memcmp(m, sig->data, m_len) != 0)) {\\r\\nRSAerr(RSA_F_RSA_VERIFY_ASN1_OCTET_STRING, RSA_R_BAD_SIGNATURE);\\r\\n} else\\r\\nret = 1;\\r\\nerr:\\r\\nif (sig != NULL)\\r\\nM_ASN1_OCTET_STRING_free(sig);\\r\\nif (s != NULL) {\\r\\nOPENSSL_cleanse(s, (unsigned int)siglen);\\r\\nOPENSSL_free(s);\\r\\n}\\r\\nreturn (ret);\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_ec_print_c", "target": 0, "func": "BIGNUM *EC_POINT_point2bn(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\npoint_conversion_form_t form,\\r\\nBIGNUM *ret, BN_CTX *ctx)\\r\\n{\\r\\nsize_t buf_len = 0;\\r\\nunsigned char *buf;\\r\\nbuf_len = EC_POINT_point2oct(group, point, form, NULL, 0, ctx);\\r\\nif (buf_len == 0)\\r\\nreturn NULL;\\r\\nif ((buf = OPENSSL_malloc(buf_len)) == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_POINT_point2oct(group, point, form, buf, buf_len, ctx)) {\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nret = BN_bin2bn(buf, buf_len, ret);\\r\\nOPENSSL_free(buf);\\r\\nreturn ret;\\r\\n}\\r\\nEC_POINT *EC_POINT_bn2point(const EC_GROUP *group,\\r\\nconst BIGNUM *bn, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nsize_t buf_len = 0;\\r\\nunsigned char *buf;\\r\\nEC_POINT *ret;\\r\\nif ((buf_len = BN_num_bytes(bn)) == 0)\\r\\nreturn NULL;\\r\\nbuf = OPENSSL_malloc(buf_len);\\r\\nif (buf == NULL)\\r\\nreturn NULL;\\r\\nif (!BN_bn2bin(bn, buf)) {\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nif (point == NULL) {\\r\\nif ((ret = EC_POINT_new(group)) == NULL) {\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\n} else\\r\\nret = point;\\r\\nif (!EC_POINT_oct2point(group, ret, buf, buf_len, ctx)) {\\r\\nif (point == NULL)\\r\\nEC_POINT_clear_free(ret);\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nOPENSSL_free(buf);\\r\\nreturn ret;\\r\\n}\\r\\nchar *EC_POINT_point2hex(const EC_GROUP *group,\\r\\nconst EC_POINT *point,\\r\\npoint_conversion_form_t form, BN_CTX *ctx)\\r\\n{\\r\\nchar *ret, *p;\\r\\nsize_t buf_len = 0, i;\\r\\nunsigned char *buf, *pbuf;\\r\\nbuf_len = EC_POINT_point2oct(group, point, form, NULL, 0, ctx);\\r\\nif (buf_len == 0)\\r\\nreturn NULL;\\r\\nif ((buf = OPENSSL_malloc(buf_len)) == NULL)\\r\\nreturn NULL;\\r\\nif (!EC_POINT_point2oct(group, point, form, buf, buf_len, ctx)) {\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\nret = (char *)OPENSSL_malloc(buf_len * 2 + 2);\\r\\nif (ret == NULL) {\\r\\nOPENSSL_free(buf);\\r\\nreturn NULL;\\r\\n}\\r\\np = ret;\\r\\npbuf = buf;\\r\\nfor (i = buf_len; i > 0; i--) {\\r\\nint v = (int)*(pbuf++);\\r\\n*(p++) = HEX_DIGITS[v >> 4];\\r\\n*(p++) = HEX_DIGITS[v & 0x0F];\\r\\n}\\r\\n*p = '\\0';\\r\\nOPENSSL_free(buf);\\r\\nreturn ret;\\r\\n}\\r\\nEC_POINT *EC_POINT_hex2point(const EC_GROUP *group,\\r\\nconst char *buf, EC_POINT *point, BN_CTX *ctx)\\r\\n{\\r\\nEC_POINT *ret = NULL;\\r\\nBIGNUM *tmp_bn = NULL;\\r\\nif (!BN_hex2bn(&tmp_bn, buf))\\r\\nreturn NULL;\\r\\nret = EC_POINT_bn2point(group, tmp_bn, point, ctx);\\r\\nBN_clear_free(tmp_bn);\\r\\nreturn ret;\\r\\n}"
}
, {
"project": "openssl", "commit_id": "OpenSSL_1_0_2_rsautl_c", "target": 0, "func": "int MAIN(int argc, char **argv)\\r\\n{\\r\\nENGINE *e = NULL;\\r\\nBIO *in = NULL, *out = NULL;\\r\\nchar *infile = NULL, *outfile = NULL;\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nchar *engine = NULL;\\r\\n# endif\\r\\nchar *keyfile = NULL;\\r\\nchar rsa_mode = RSA_VERIFY, key_type = KEY_PRIVKEY;\\r\\nint keyform = FORMAT_PEM;\\r\\nchar need_priv = 0, badarg = 0, rev = 0;\\r\\nchar hexdump = 0, asn1parse = 0;\\r\\nX509 *x;\\r\\nEVP_PKEY *pkey = NULL;\\r\\nRSA *rsa = NULL;\\r\\nunsigned char *rsa_in = NULL, *rsa_out = NULL, pad;\\r\\nchar *passargin = NULL, *passin = NULL;\\r\\nint rsa_inlen, rsa_outlen = 0;\\r\\nint keysize;\\r\\nint ret = 1;\\r\\nargc--;\\r\\nargv++;\\r\\nif (!bio_err)\\r\\nbio_err = BIO_new_fp(stderr, BIO_NOCLOSE);\\r\\nif (!load_config(bio_err, NULL))\\r\\ngoto end;\\r\\nERR_load_crypto_strings();\\r\\nOpenSSL_add_all_algorithms();\\r\\npad = RSA_PKCS1_PADDING;\\r\\nwhile (argc >= 1) {\\r\\nif (!strcmp(*argv, \"-in\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\ninfile = *(++argv);\\r\\n} else if (!strcmp(*argv, \"-out\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\noutfile = *(++argv);\\r\\n} else if (!strcmp(*argv, \"-inkey\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\nkeyfile = *(++argv);\\r\\n} else if (!strcmp(*argv, \"-passin\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\npassargin = *(++argv);\\r\\n} else if (strcmp(*argv, \"-keyform\") == 0) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\nkeyform = str2fmt(*(++argv));\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\n} else if (!strcmp(*argv, \"-engine\")) {\\r\\nif (--argc < 1)\\r\\nbadarg = 1;\\r\\nelse\\r\\nengine = *(++argv);\\r\\n# endif\\r\\n} else if (!strcmp(*argv, \"-pubin\")) {\\r\\nkey_type = KEY_PUBKEY;\\r\\n} else if (!strcmp(*argv, \"-certin\")) {\\r\\nkey_type = KEY_CERT;\\r\\n} else if (!strcmp(*argv, \"-asn1parse\"))\\r\\nasn1parse = 1;\\r\\nelse if (!strcmp(*argv, \"-hexdump\"))\\r\\nhexdump = 1;\\r\\nelse if (!strcmp(*argv, \"-raw\"))\\r\\npad = RSA_NO_PADDING;\\r\\nelse if (!strcmp(*argv, \"-oaep\"))\\r\\npad = RSA_PKCS1_OAEP_PADDING;\\r\\nelse if (!strcmp(*argv, \"-ssl\"))\\r\\npad = RSA_SSLV23_PADDING;\\r\\nelse if (!strcmp(*argv, \"-pkcs\"))\\r\\npad = RSA_PKCS1_PADDING;\\r\\nelse if (!strcmp(*argv, \"-x931\"))\\r\\npad = RSA_X931_PADDING;\\r\\nelse if (!strcmp(*argv, \"-sign\")) {\\r\\nrsa_mode = RSA_SIGN;\\r\\nneed_priv = 1;\\r\\n} else if (!strcmp(*argv, \"-verify\"))\\r\\nrsa_mode = RSA_VERIFY;\\r\\nelse if (!strcmp(*argv, \"-rev\"))\\r\\nrev = 1;\\r\\nelse if (!strcmp(*argv, \"-encrypt\"))\\r\\nrsa_mode = RSA_ENCRYPT;\\r\\nelse if (!strcmp(*argv, \"-decrypt\")) {\\r\\nrsa_mode = RSA_DECRYPT;\\r\\nneed_priv = 1;\\r\\n} else\\r\\nbadarg = 1;\\r\\nif (badarg) {\\r\\nusage();\\r\\ngoto end;\\r\\n}\\r\\nargc--;\\r\\nargv++;\\r\\n}\\r\\nif (need_priv && (key_type != KEY_PRIVKEY)) {\\r\\nBIO_printf(bio_err, \"A private key is needed for this operation\\n\");\\r\\ngoto end;\\r\\n}\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\ne = setup_engine(bio_err, engine, 0);\\r\\n# endif\\r\\nif (!app_passwd(bio_err, passargin, NULL, &passin, NULL)) {\\r\\nBIO_printf(bio_err, \"Error getting password\\n\");\\r\\ngoto end;\\r\\n}\\r\\napp_RAND_load_file(NULL, bio_err, 0);\\r\\nswitch (key_type) {\\r\\ncase KEY_PRIVKEY:\\r\\npkey = load_key(bio_err, keyfile, keyform, 0,\\r\\npassin, e, \"Private Key\");\\r\\nbreak;\\r\\ncase KEY_PUBKEY:\\r\\npkey = load_pubkey(bio_err, keyfile, keyform, 0,\\r\\nNULL, e, \"Public Key\");\\r\\nbreak;\\r\\ncase KEY_CERT:\\r\\nx = load_cert(bio_err, keyfile, keyform, NULL, e, \"Certificate\");\\r\\nif (x) {\\r\\npkey = X509_get_pubkey(x);\\r\\nX509_free(x);\\r\\n}\\r\\nbreak;\\r\\n}\\r\\nif (!pkey) {\\r\\nreturn 1;\\r\\n}\\r\\nrsa = EVP_PKEY_get1_RSA(pkey);\\r\\nEVP_PKEY_free(pkey);\\r\\nif (!rsa) {\\r\\nBIO_printf(bio_err, \"Error getting RSA key\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nif (infile) {\\r\\nif (!(in = BIO_new_file(infile, \"rb\"))) {\\r\\nBIO_printf(bio_err, \"Error Reading Input File\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else\\r\\nin = BIO_new_fp(stdin, BIO_NOCLOSE);\\r\\nif (outfile) {\\r\\nif (!(out = BIO_new_file(outfile, \"wb\"))) {\\r\\nBIO_printf(bio_err, \"Error Reading Output File\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\n} else {\\r\\nout = BIO_new_fp(stdout, BIO_NOCLOSE);\\r\\n# ifdef OPENSSL_SYS_VMS\\r\\n{\\r\\nBIO *tmpbio = BIO_new(BIO_f_linebuffer());\\r\\nout = BIO_push(tmpbio, out);\\r\\n}\\r\\n# endif\\r\\n}\\r\\nkeysize = RSA_size(rsa);\\r\\nrsa_in = OPENSSL_malloc(keysize * 2);\\r\\nrsa_out = OPENSSL_malloc(keysize);\\r\\nrsa_inlen = BIO_read(in, rsa_in, keysize * 2);\\r\\nif (rsa_inlen <= 0) {\\r\\nBIO_printf(bio_err, \"Error reading input Data\\n\");\\r\\nexit(1);\\r\\n}\\r\\nif (rev) {\\r\\nint i;\\r\\nunsigned char ctmp;\\r\\nfor (i = 0; i < rsa_inlen / 2; i++) {\\r\\nctmp = rsa_in[i];\\r\\nrsa_in[i] = rsa_in[rsa_inlen - 1 - i];\\r\\nrsa_in[rsa_inlen - 1 - i] = ctmp;\\r\\n}\\r\\n}\\r\\nswitch (rsa_mode) {\\r\\ncase RSA_VERIFY:\\r\\nrsa_outlen = RSA_public_decrypt(rsa_inlen, rsa_in, rsa_out, rsa, pad);\\r\\nbreak;\\r\\ncase RSA_SIGN:\\r\\nrsa_outlen =\\r\\nRSA_private_encrypt(rsa_inlen, rsa_in, rsa_out, rsa, pad);\\r\\nbreak;\\r\\ncase RSA_ENCRYPT:\\r\\nrsa_outlen = RSA_public_encrypt(rsa_inlen, rsa_in, rsa_out, rsa, pad);\\r\\nbreak;\\r\\ncase RSA_DECRYPT:\\r\\nrsa_outlen =\\r\\nRSA_private_decrypt(rsa_inlen, rsa_in, rsa_out, rsa, pad);\\r\\nbreak;\\r\\n}\\r\\nif (rsa_outlen <= 0) {\\r\\nBIO_printf(bio_err, \"RSA operation error\\n\");\\r\\nERR_print_errors(bio_err);\\r\\ngoto end;\\r\\n}\\r\\nret = 0;\\r\\nif (asn1parse) {\\r\\nif (!ASN1_parse_dump(out, rsa_out, rsa_outlen, 1, -1)) {\\r\\nERR_print_errors(bio_err);\\r\\n}\\r\\n} else if (hexdump)\\r\\nBIO_dump(out, (char *)rsa_out, rsa_outlen);\\r\\nelse\\r\\nBIO_write(out, rsa_out, rsa_outlen);\\r\\nend:\\r\\nRSA_free(rsa);\\r\\nBIO_free(in);\\r\\nBIO_free_all(out);\\r\\nif (rsa_in)\\r\\nOPENSSL_free(rsa_in);\\r\\nif (rsa_out)\\r\\nOPENSSL_free(rsa_out);\\r\\nif (passin)\\r\\nOPENSSL_free(passin);\\r\\nreturn ret;\\r\\n}\\r\\nstatic void usage()\\r\\n{\\r\\nBIO_printf(bio_err, \"Usage: rsautl [options]\\n\");\\r\\nBIO_printf(bio_err, \"-in file input file\\n\");\\r\\nBIO_printf(bio_err, \"-out file output file\\n\");\\r\\nBIO_printf(bio_err, \"-inkey file input key\\n\");\\r\\nBIO_printf(bio_err, \"-keyform arg private key format - default PEM\\n\");\\r\\nBIO_printf(bio_err, \"-pubin input is an RSA public\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-certin input is a certificate carrying an RSA public key\\n\");\\r\\nBIO_printf(bio_err, \"-ssl use SSL v2 padding\\n\");\\r\\nBIO_printf(bio_err, \"-raw use no padding\\n\");\\r\\nBIO_printf(bio_err,\\r\\n\"-pkcs use PKCS#1 v1.5 padding (default)\\n\");\\r\\nBIO_printf(bio_err, \"-oaep use PKCS#1 OAEP\\n\");\\r\\nBIO_printf(bio_err, \"-sign sign with private key\\n\");\\r\\nBIO_printf(bio_err, \"-verify verify with public key\\n\");\\r\\nBIO_printf(bio_err, \"-encrypt encrypt with public key\\n\");\\r\\nBIO_printf(bio_err, \"-decrypt decrypt with private key\\n\");\\r\\nBIO_printf(bio_err, \"-hexdump hex dump output\\n\");\\r\\n# ifndef OPENSSL_NO_ENGINE\\r\\nBIO_printf(bio_err,\\r\\n\"-engine e use engine e, possibly a hardware device.\\n\");\\r\\nBIO_printf(bio_err, \"-passin arg pass phrase source\\n\");\\r\\n# endif\\r\\n}"
}
]
